var s6 = Object.defineProperty;
var l6 = (e, t, n) => t in e ? s6(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var Ku = (e, t, n) => l6(e, typeof t != "symbol" ? t + "" : t, n);
function u6(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const o in r)
        if (o !== "default" && !(o in e)) {
          const a = Object.getOwnPropertyDescriptor(r, o);
          a && Object.defineProperty(e, o, a.get ? a : {
            enumerable: !0,
            get: () => r[o]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
const c6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ArrayBufferDataStructure() {
    return o3;
  },
  get CTypeStructure() {
    return i3;
  },
  get DataPreviewViewRendererToHandlePreviewRenderer() {
    return w4;
  },
  get DataStructure() {
    return co;
  },
  get DataViewRendererToDataPreviewViewRenderer() {
    return zn;
  },
  get DataViewRendererToInputRenderer() {
    return _4;
  },
  get DataViewRendererToOverlayRenderer() {
    return Bm;
  },
  get FuncNodesRenderer() {
    return rj;
  },
  get JSONStructure() {
    return Qi;
  },
  get LATEST_VERSION() {
    return nj;
  },
  get TextStructure() {
    return a3;
  },
  get useFuncNodesContext() {
    return nt;
  },
  get useIOGetFullValue() {
    return qm;
  },
  get useIOStore() {
    return Rt;
  },
  get useIOValueStore() {
    return gie;
  },
  get useNodeStore() {
    return cr;
  },
  get useSetIOValue() {
    return Hl;
  },
  get useSetIOValueOptions() {
    return mie;
  },
  get useWorkerApi() {
    return Tn;
  }
}, Symbol.toStringTag, { value: "Module" }));
(function() {
  const t = document.createElement("link").relList;
  if (t && t.supports && t.supports("modulepreload")) return;
  for (const o of document.querySelectorAll('link[rel="modulepreload"]')) r(o);
  new MutationObserver((o) => {
    for (const a of o)
      if (a.type === "childList")
        for (const s of a.addedNodes) s.tagName === "LINK" && s.rel === "modulepreload" && r(s);
  }).observe(document, {
    childList: !0,
    subtree: !0
  });
  function n(o) {
    const a = {};
    return o.integrity && (a.integrity = o.integrity), o.referrerPolicy && (a.referrerPolicy = o.referrerPolicy), o.crossOrigin === "use-credentials" ? a.credentials = "include" : o.crossOrigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin", a;
  }
  function r(o) {
    if (o.ep) return;
    o.ep = !0;
    const a = n(o);
    fetch(o.href, a);
  }
})();
function Nl(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var dy = { exports: {} }, Zu = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tC;
function f6() {
  if (tC) return Zu;
  tC = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.fragment");
  function n(r, o, a) {
    var s = null;
    if (a !== void 0 && (s = "" + a), o.key !== void 0 && (s = "" + o.key), "key" in o) {
      a = {};
      for (var u in o)
        u !== "key" && (a[u] = o[u]);
    } else a = o;
    return o = a.ref, {
      $$typeof: e,
      type: r,
      key: s,
      ref: o !== void 0 ? o : null,
      props: a
    };
  }
  return Zu.Fragment = t, Zu.jsx = n, Zu.jsxs = n, Zu;
}
var nC;
function d6() {
  return nC || (nC = 1, dy.exports = f6()), dy.exports;
}
var x = d6(), hy = { exports: {} }, Qu = {}, py = { exports: {} }, my = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rC;
function h6() {
  return rC || (rC = 1, function(e) {
    function t(I, H) {
      var q = I.length;
      I.push(H);
      e: for (; 0 < q; ) {
        var G = q - 1 >>> 1, O = I[G];
        if (0 < o(O, H))
          I[G] = H, I[q] = O, q = G;
        else break e;
      }
    }
    function n(I) {
      return I.length === 0 ? null : I[0];
    }
    function r(I) {
      if (I.length === 0) return null;
      var H = I[0], q = I.pop();
      if (q !== H) {
        I[0] = q;
        e: for (var G = 0, O = I.length, Y = O >>> 1; G < Y; ) {
          var Z = 2 * (G + 1) - 1, L = I[Z], te = Z + 1, he = I[te];
          if (0 > o(L, q))
            te < O && 0 > o(he, L) ? (I[G] = he, I[te] = q, G = te) : (I[G] = L, I[Z] = q, G = Z);
          else if (te < O && 0 > o(he, q))
            I[G] = he, I[te] = q, G = te;
          else break e;
        }
      }
      return H;
    }
    function o(I, H) {
      var q = I.sortIndex - H.sortIndex;
      return q !== 0 ? q : I.id - H.id;
    }
    if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var a = performance;
      e.unstable_now = function() {
        return a.now();
      };
    } else {
      var s = Date, u = s.now();
      e.unstable_now = function() {
        return s.now() - u;
      };
    }
    var c = [], f = [], h = 1, p = null, g = 3, y = !1, w = !1, v = !1, S = !1, E = typeof setTimeout == "function" ? setTimeout : null, T = typeof clearTimeout == "function" ? clearTimeout : null, k = typeof setImmediate < "u" ? setImmediate : null;
    function A(I) {
      for (var H = n(f); H !== null; ) {
        if (H.callback === null) r(f);
        else if (H.startTime <= I)
          r(f), H.sortIndex = H.expirationTime, t(c, H);
        else break;
        H = n(f);
      }
    }
    function M(I) {
      if (v = !1, A(I), !w)
        if (n(c) !== null)
          w = !0, N || (N = !0, U());
        else {
          var H = n(f);
          H !== null && V(M, H.startTime - I);
        }
    }
    var N = !1, P = -1, z = 5, B = -1;
    function R() {
      return S ? !0 : !(e.unstable_now() - B < z);
    }
    function F() {
      if (S = !1, N) {
        var I = e.unstable_now();
        B = I;
        var H = !0;
        try {
          e: {
            w = !1, v && (v = !1, T(P), P = -1), y = !0;
            var q = g;
            try {
              t: {
                for (A(I), p = n(c); p !== null && !(p.expirationTime > I && R()); ) {
                  var G = p.callback;
                  if (typeof G == "function") {
                    p.callback = null, g = p.priorityLevel;
                    var O = G(
                      p.expirationTime <= I
                    );
                    if (I = e.unstable_now(), typeof O == "function") {
                      p.callback = O, A(I), H = !0;
                      break t;
                    }
                    p === n(c) && r(c), A(I);
                  } else r(c);
                  p = n(c);
                }
                if (p !== null) H = !0;
                else {
                  var Y = n(f);
                  Y !== null && V(
                    M,
                    Y.startTime - I
                  ), H = !1;
                }
              }
              break e;
            } finally {
              p = null, g = q, y = !1;
            }
            H = void 0;
          }
        } finally {
          H ? U() : N = !1;
        }
      }
    }
    var U;
    if (typeof k == "function")
      U = function() {
        k(F);
      };
    else if (typeof MessageChannel < "u") {
      var W = new MessageChannel(), j = W.port2;
      W.port1.onmessage = F, U = function() {
        j.postMessage(null);
      };
    } else
      U = function() {
        E(F, 0);
      };
    function V(I, H) {
      P = E(function() {
        I(e.unstable_now());
      }, H);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(I) {
      I.callback = null;
    }, e.unstable_forceFrameRate = function(I) {
      0 > I || 125 < I ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : z = 0 < I ? Math.floor(1e3 / I) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return g;
    }, e.unstable_next = function(I) {
      switch (g) {
        case 1:
        case 2:
        case 3:
          var H = 3;
          break;
        default:
          H = g;
      }
      var q = g;
      g = H;
      try {
        return I();
      } finally {
        g = q;
      }
    }, e.unstable_requestPaint = function() {
      S = !0;
    }, e.unstable_runWithPriority = function(I, H) {
      switch (I) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          I = 3;
      }
      var q = g;
      g = I;
      try {
        return H();
      } finally {
        g = q;
      }
    }, e.unstable_scheduleCallback = function(I, H, q) {
      var G = e.unstable_now();
      switch (typeof q == "object" && q !== null ? (q = q.delay, q = typeof q == "number" && 0 < q ? G + q : G) : q = G, I) {
        case 1:
          var O = -1;
          break;
        case 2:
          O = 250;
          break;
        case 5:
          O = 1073741823;
          break;
        case 4:
          O = 1e4;
          break;
        default:
          O = 5e3;
      }
      return O = q + O, I = {
        id: h++,
        callback: H,
        priorityLevel: I,
        startTime: q,
        expirationTime: O,
        sortIndex: -1
      }, q > G ? (I.sortIndex = q, t(f, I), n(c) === null && I === n(f) && (v ? (T(P), P = -1) : v = !0, V(M, q - G))) : (I.sortIndex = O, t(c, I), w || y || (w = !0, N || (N = !0, U()))), I;
    }, e.unstable_shouldYield = R, e.unstable_wrapCallback = function(I) {
      var H = g;
      return function() {
        var q = g;
        g = H;
        try {
          return I.apply(this, arguments);
        } finally {
          g = q;
        }
      };
    };
  }(my)), my;
}
var oC;
function p6() {
  return oC || (oC = 1, py.exports = h6()), py.exports;
}
var gy = { exports: {} }, $e = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var iC;
function m6() {
  if (iC) return $e;
  iC = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.consumer"), s = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), f = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), p = Symbol.iterator;
  function g(O) {
    return O === null || typeof O != "object" ? null : (O = p && O[p] || O["@@iterator"], typeof O == "function" ? O : null);
  }
  var y = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, w = Object.assign, v = {};
  function S(O, Y, Z) {
    this.props = O, this.context = Y, this.refs = v, this.updater = Z || y;
  }
  S.prototype.isReactComponent = {}, S.prototype.setState = function(O, Y) {
    if (typeof O != "object" && typeof O != "function" && O != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, O, Y, "setState");
  }, S.prototype.forceUpdate = function(O) {
    this.updater.enqueueForceUpdate(this, O, "forceUpdate");
  };
  function E() {
  }
  E.prototype = S.prototype;
  function T(O, Y, Z) {
    this.props = O, this.context = Y, this.refs = v, this.updater = Z || y;
  }
  var k = T.prototype = new E();
  k.constructor = T, w(k, S.prototype), k.isPureReactComponent = !0;
  var A = Array.isArray, M = { H: null, A: null, T: null, S: null, V: null }, N = Object.prototype.hasOwnProperty;
  function P(O, Y, Z, L, te, he) {
    return Z = he.ref, {
      $$typeof: e,
      type: O,
      key: Y,
      ref: Z !== void 0 ? Z : null,
      props: he
    };
  }
  function z(O, Y) {
    return P(
      O.type,
      Y,
      void 0,
      void 0,
      void 0,
      O.props
    );
  }
  function B(O) {
    return typeof O == "object" && O !== null && O.$$typeof === e;
  }
  function R(O) {
    var Y = { "=": "=0", ":": "=2" };
    return "$" + O.replace(/[=:]/g, function(Z) {
      return Y[Z];
    });
  }
  var F = /\/+/g;
  function U(O, Y) {
    return typeof O == "object" && O !== null && O.key != null ? R("" + O.key) : Y.toString(36);
  }
  function W() {
  }
  function j(O) {
    switch (O.status) {
      case "fulfilled":
        return O.value;
      case "rejected":
        throw O.reason;
      default:
        switch (typeof O.status == "string" ? O.then(W, W) : (O.status = "pending", O.then(
          function(Y) {
            O.status === "pending" && (O.status = "fulfilled", O.value = Y);
          },
          function(Y) {
            O.status === "pending" && (O.status = "rejected", O.reason = Y);
          }
        )), O.status) {
          case "fulfilled":
            return O.value;
          case "rejected":
            throw O.reason;
        }
    }
    throw O;
  }
  function V(O, Y, Z, L, te) {
    var he = typeof O;
    (he === "undefined" || he === "boolean") && (O = null);
    var oe = !1;
    if (O === null) oe = !0;
    else
      switch (he) {
        case "bigint":
        case "string":
        case "number":
          oe = !0;
          break;
        case "object":
          switch (O.$$typeof) {
            case e:
            case t:
              oe = !0;
              break;
            case h:
              return oe = O._init, V(
                oe(O._payload),
                Y,
                Z,
                L,
                te
              );
          }
      }
    if (oe)
      return te = te(O), oe = L === "" ? "." + U(O, 0) : L, A(te) ? (Z = "", oe != null && (Z = oe.replace(F, "$&/") + "/"), V(te, Y, Z, "", function(ye) {
        return ye;
      })) : te != null && (B(te) && (te = z(
        te,
        Z + (te.key == null || O && O.key === te.key ? "" : ("" + te.key).replace(
          F,
          "$&/"
        ) + "/") + oe
      )), Y.push(te)), 1;
    oe = 0;
    var de = L === "" ? "." : L + ":";
    if (A(O))
      for (var le = 0; le < O.length; le++)
        L = O[le], he = de + U(L, le), oe += V(
          L,
          Y,
          Z,
          he,
          te
        );
    else if (le = g(O), typeof le == "function")
      for (O = le.call(O), le = 0; !(L = O.next()).done; )
        L = L.value, he = de + U(L, le++), oe += V(
          L,
          Y,
          Z,
          he,
          te
        );
    else if (he === "object") {
      if (typeof O.then == "function")
        return V(
          j(O),
          Y,
          Z,
          L,
          te
        );
      throw Y = String(O), Error(
        "Objects are not valid as a React child (found: " + (Y === "[object Object]" ? "object with keys {" + Object.keys(O).join(", ") + "}" : Y) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return oe;
  }
  function I(O, Y, Z) {
    if (O == null) return O;
    var L = [], te = 0;
    return V(O, L, "", "", function(he) {
      return Y.call(Z, he, te++);
    }), L;
  }
  function H(O) {
    if (O._status === -1) {
      var Y = O._result;
      Y = Y(), Y.then(
        function(Z) {
          (O._status === 0 || O._status === -1) && (O._status = 1, O._result = Z);
        },
        function(Z) {
          (O._status === 0 || O._status === -1) && (O._status = 2, O._result = Z);
        }
      ), O._status === -1 && (O._status = 0, O._result = Y);
    }
    if (O._status === 1) return O._result.default;
    throw O._result;
  }
  var q = typeof reportError == "function" ? reportError : function(O) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var Y = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof O == "object" && O !== null && typeof O.message == "string" ? String(O.message) : String(O),
        error: O
      });
      if (!window.dispatchEvent(Y)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", O);
      return;
    }
    console.error(O);
  };
  function G() {
  }
  return $e.Children = {
    map: I,
    forEach: function(O, Y, Z) {
      I(
        O,
        function() {
          Y.apply(this, arguments);
        },
        Z
      );
    },
    count: function(O) {
      var Y = 0;
      return I(O, function() {
        Y++;
      }), Y;
    },
    toArray: function(O) {
      return I(O, function(Y) {
        return Y;
      }) || [];
    },
    only: function(O) {
      if (!B(O))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return O;
    }
  }, $e.Component = S, $e.Fragment = n, $e.Profiler = o, $e.PureComponent = T, $e.StrictMode = r, $e.Suspense = c, $e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = M, $e.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(O) {
      return M.H.useMemoCache(O);
    }
  }, $e.cache = function(O) {
    return function() {
      return O.apply(null, arguments);
    };
  }, $e.cloneElement = function(O, Y, Z) {
    if (O == null)
      throw Error(
        "The argument must be a React element, but you passed " + O + "."
      );
    var L = w({}, O.props), te = O.key, he = void 0;
    if (Y != null)
      for (oe in Y.ref !== void 0 && (he = void 0), Y.key !== void 0 && (te = "" + Y.key), Y)
        !N.call(Y, oe) || oe === "key" || oe === "__self" || oe === "__source" || oe === "ref" && Y.ref === void 0 || (L[oe] = Y[oe]);
    var oe = arguments.length - 2;
    if (oe === 1) L.children = Z;
    else if (1 < oe) {
      for (var de = Array(oe), le = 0; le < oe; le++)
        de[le] = arguments[le + 2];
      L.children = de;
    }
    return P(O.type, te, void 0, void 0, he, L);
  }, $e.createContext = function(O) {
    return O = {
      $$typeof: s,
      _currentValue: O,
      _currentValue2: O,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, O.Provider = O, O.Consumer = {
      $$typeof: a,
      _context: O
    }, O;
  }, $e.createElement = function(O, Y, Z) {
    var L, te = {}, he = null;
    if (Y != null)
      for (L in Y.key !== void 0 && (he = "" + Y.key), Y)
        N.call(Y, L) && L !== "key" && L !== "__self" && L !== "__source" && (te[L] = Y[L]);
    var oe = arguments.length - 2;
    if (oe === 1) te.children = Z;
    else if (1 < oe) {
      for (var de = Array(oe), le = 0; le < oe; le++)
        de[le] = arguments[le + 2];
      te.children = de;
    }
    if (O && O.defaultProps)
      for (L in oe = O.defaultProps, oe)
        te[L] === void 0 && (te[L] = oe[L]);
    return P(O, he, void 0, void 0, null, te);
  }, $e.createRef = function() {
    return { current: null };
  }, $e.forwardRef = function(O) {
    return { $$typeof: u, render: O };
  }, $e.isValidElement = B, $e.lazy = function(O) {
    return {
      $$typeof: h,
      _payload: { _status: -1, _result: O },
      _init: H
    };
  }, $e.memo = function(O, Y) {
    return {
      $$typeof: f,
      type: O,
      compare: Y === void 0 ? null : Y
    };
  }, $e.startTransition = function(O) {
    var Y = M.T, Z = {};
    M.T = Z;
    try {
      var L = O(), te = M.S;
      te !== null && te(Z, L), typeof L == "object" && L !== null && typeof L.then == "function" && L.then(G, q);
    } catch (he) {
      q(he);
    } finally {
      M.T = Y;
    }
  }, $e.unstable_useCacheRefresh = function() {
    return M.H.useCacheRefresh();
  }, $e.use = function(O) {
    return M.H.use(O);
  }, $e.useActionState = function(O, Y, Z) {
    return M.H.useActionState(O, Y, Z);
  }, $e.useCallback = function(O, Y) {
    return M.H.useCallback(O, Y);
  }, $e.useContext = function(O) {
    return M.H.useContext(O);
  }, $e.useDebugValue = function() {
  }, $e.useDeferredValue = function(O, Y) {
    return M.H.useDeferredValue(O, Y);
  }, $e.useEffect = function(O, Y, Z) {
    var L = M.H;
    if (typeof Z == "function")
      throw Error(
        "useEffect CRUD overload is not enabled in this build of React."
      );
    return L.useEffect(O, Y);
  }, $e.useId = function() {
    return M.H.useId();
  }, $e.useImperativeHandle = function(O, Y, Z) {
    return M.H.useImperativeHandle(O, Y, Z);
  }, $e.useInsertionEffect = function(O, Y) {
    return M.H.useInsertionEffect(O, Y);
  }, $e.useLayoutEffect = function(O, Y) {
    return M.H.useLayoutEffect(O, Y);
  }, $e.useMemo = function(O, Y) {
    return M.H.useMemo(O, Y);
  }, $e.useOptimistic = function(O, Y) {
    return M.H.useOptimistic(O, Y);
  }, $e.useReducer = function(O, Y, Z) {
    return M.H.useReducer(O, Y, Z);
  }, $e.useRef = function(O) {
    return M.H.useRef(O);
  }, $e.useState = function(O) {
    return M.H.useState(O);
  }, $e.useSyncExternalStore = function(O, Y, Z) {
    return M.H.useSyncExternalStore(
      O,
      Y,
      Z
    );
  }, $e.useTransition = function() {
    return M.H.useTransition();
  }, $e.version = "19.1.0", $e;
}
var aC;
function Qc() {
  return aC || (aC = 1, gy.exports = m6()), gy.exports;
}
var yy = { exports: {} }, pn = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var sC;
function g6() {
  if (sC) return pn;
  sC = 1;
  var e = Qc();
  function t(c) {
    var f = "https://react.dev/errors/" + c;
    if (1 < arguments.length) {
      f += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var h = 2; h < arguments.length; h++)
        f += "&args[]=" + encodeURIComponent(arguments[h]);
    }
    return "Minified React error #" + c + "; visit " + f + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function n() {
  }
  var r = {
    d: {
      f: n,
      r: function() {
        throw Error(t(522));
      },
      D: n,
      C: n,
      L: n,
      m: n,
      X: n,
      S: n,
      M: n
    },
    p: 0,
    findDOMNode: null
  }, o = Symbol.for("react.portal");
  function a(c, f, h) {
    var p = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: o,
      key: p == null ? null : "" + p,
      children: c,
      containerInfo: f,
      implementation: h
    };
  }
  var s = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function u(c, f) {
    if (c === "font") return "";
    if (typeof f == "string")
      return f === "use-credentials" ? f : "";
  }
  return pn.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r, pn.createPortal = function(c, f) {
    var h = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!f || f.nodeType !== 1 && f.nodeType !== 9 && f.nodeType !== 11)
      throw Error(t(299));
    return a(c, f, null, h);
  }, pn.flushSync = function(c) {
    var f = s.T, h = r.p;
    try {
      if (s.T = null, r.p = 2, c) return c();
    } finally {
      s.T = f, r.p = h, r.d.f();
    }
  }, pn.preconnect = function(c, f) {
    typeof c == "string" && (f ? (f = f.crossOrigin, f = typeof f == "string" ? f === "use-credentials" ? f : "" : void 0) : f = null, r.d.C(c, f));
  }, pn.prefetchDNS = function(c) {
    typeof c == "string" && r.d.D(c);
  }, pn.preinit = function(c, f) {
    if (typeof c == "string" && f && typeof f.as == "string") {
      var h = f.as, p = u(h, f.crossOrigin), g = typeof f.integrity == "string" ? f.integrity : void 0, y = typeof f.fetchPriority == "string" ? f.fetchPriority : void 0;
      h === "style" ? r.d.S(
        c,
        typeof f.precedence == "string" ? f.precedence : void 0,
        {
          crossOrigin: p,
          integrity: g,
          fetchPriority: y
        }
      ) : h === "script" && r.d.X(c, {
        crossOrigin: p,
        integrity: g,
        fetchPriority: y,
        nonce: typeof f.nonce == "string" ? f.nonce : void 0
      });
    }
  }, pn.preinitModule = function(c, f) {
    if (typeof c == "string")
      if (typeof f == "object" && f !== null) {
        if (f.as == null || f.as === "script") {
          var h = u(
            f.as,
            f.crossOrigin
          );
          r.d.M(c, {
            crossOrigin: h,
            integrity: typeof f.integrity == "string" ? f.integrity : void 0,
            nonce: typeof f.nonce == "string" ? f.nonce : void 0
          });
        }
      } else f == null && r.d.M(c);
  }, pn.preload = function(c, f) {
    if (typeof c == "string" && typeof f == "object" && f !== null && typeof f.as == "string") {
      var h = f.as, p = u(h, f.crossOrigin);
      r.d.L(c, h, {
        crossOrigin: p,
        integrity: typeof f.integrity == "string" ? f.integrity : void 0,
        nonce: typeof f.nonce == "string" ? f.nonce : void 0,
        type: typeof f.type == "string" ? f.type : void 0,
        fetchPriority: typeof f.fetchPriority == "string" ? f.fetchPriority : void 0,
        referrerPolicy: typeof f.referrerPolicy == "string" ? f.referrerPolicy : void 0,
        imageSrcSet: typeof f.imageSrcSet == "string" ? f.imageSrcSet : void 0,
        imageSizes: typeof f.imageSizes == "string" ? f.imageSizes : void 0,
        media: typeof f.media == "string" ? f.media : void 0
      });
    }
  }, pn.preloadModule = function(c, f) {
    if (typeof c == "string")
      if (f) {
        var h = u(f.as, f.crossOrigin);
        r.d.m(c, {
          as: typeof f.as == "string" && f.as !== "script" ? f.as : void 0,
          crossOrigin: h,
          integrity: typeof f.integrity == "string" ? f.integrity : void 0
        });
      } else r.d.m(c);
  }, pn.requestFormReset = function(c) {
    r.d.r(c);
  }, pn.unstable_batchedUpdates = function(c, f) {
    return c(f);
  }, pn.useFormState = function(c, f, h) {
    return s.H.useFormState(c, f, h);
  }, pn.useFormStatus = function() {
    return s.H.useHostTransitionStatus();
  }, pn.version = "19.1.0", pn;
}
var lC;
function QR() {
  if (lC) return yy.exports;
  lC = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), yy.exports = g6(), yy.exports;
}
var uC;
function y6() {
  if (uC) return Qu;
  uC = 1;
  /**
   * @license React
   * react-dom-client.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var e = p6(), t = Qc(), n = QR();
  function r(i) {
    var l = "https://react.dev/errors/" + i;
    if (1 < arguments.length) {
      l += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var d = 2; d < arguments.length; d++)
        l += "&args[]=" + encodeURIComponent(arguments[d]);
    }
    return "Minified React error #" + i + "; visit " + l + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function o(i) {
    return !(!i || i.nodeType !== 1 && i.nodeType !== 9 && i.nodeType !== 11);
  }
  function a(i) {
    var l = i, d = i;
    if (i.alternate) for (; l.return; ) l = l.return;
    else {
      i = l;
      do
        l = i, (l.flags & 4098) !== 0 && (d = l.return), i = l.return;
      while (i);
    }
    return l.tag === 3 ? d : null;
  }
  function s(i) {
    if (i.tag === 13) {
      var l = i.memoizedState;
      if (l === null && (i = i.alternate, i !== null && (l = i.memoizedState)), l !== null) return l.dehydrated;
    }
    return null;
  }
  function u(i) {
    if (a(i) !== i)
      throw Error(r(188));
  }
  function c(i) {
    var l = i.alternate;
    if (!l) {
      if (l = a(i), l === null) throw Error(r(188));
      return l !== i ? null : i;
    }
    for (var d = i, m = l; ; ) {
      var b = d.return;
      if (b === null) break;
      var C = b.alternate;
      if (C === null) {
        if (m = b.return, m !== null) {
          d = m;
          continue;
        }
        break;
      }
      if (b.child === C.child) {
        for (C = b.child; C; ) {
          if (C === d) return u(b), i;
          if (C === m) return u(b), l;
          C = C.sibling;
        }
        throw Error(r(188));
      }
      if (d.return !== m.return) d = b, m = C;
      else {
        for (var D = !1, $ = b.child; $; ) {
          if ($ === d) {
            D = !0, d = b, m = C;
            break;
          }
          if ($ === m) {
            D = !0, m = b, d = C;
            break;
          }
          $ = $.sibling;
        }
        if (!D) {
          for ($ = C.child; $; ) {
            if ($ === d) {
              D = !0, d = C, m = b;
              break;
            }
            if ($ === m) {
              D = !0, m = C, d = b;
              break;
            }
            $ = $.sibling;
          }
          if (!D) throw Error(r(189));
        }
      }
      if (d.alternate !== m) throw Error(r(190));
    }
    if (d.tag !== 3) throw Error(r(188));
    return d.stateNode.current === d ? i : l;
  }
  function f(i) {
    var l = i.tag;
    if (l === 5 || l === 26 || l === 27 || l === 6) return i;
    for (i = i.child; i !== null; ) {
      if (l = f(i), l !== null) return l;
      i = i.sibling;
    }
    return null;
  }
  var h = Object.assign, p = Symbol.for("react.element"), g = Symbol.for("react.transitional.element"), y = Symbol.for("react.portal"), w = Symbol.for("react.fragment"), v = Symbol.for("react.strict_mode"), S = Symbol.for("react.profiler"), E = Symbol.for("react.provider"), T = Symbol.for("react.consumer"), k = Symbol.for("react.context"), A = Symbol.for("react.forward_ref"), M = Symbol.for("react.suspense"), N = Symbol.for("react.suspense_list"), P = Symbol.for("react.memo"), z = Symbol.for("react.lazy"), B = Symbol.for("react.activity"), R = Symbol.for("react.memo_cache_sentinel"), F = Symbol.iterator;
  function U(i) {
    return i === null || typeof i != "object" ? null : (i = F && i[F] || i["@@iterator"], typeof i == "function" ? i : null);
  }
  var W = Symbol.for("react.client.reference");
  function j(i) {
    if (i == null) return null;
    if (typeof i == "function")
      return i.$$typeof === W ? null : i.displayName || i.name || null;
    if (typeof i == "string") return i;
    switch (i) {
      case w:
        return "Fragment";
      case S:
        return "Profiler";
      case v:
        return "StrictMode";
      case M:
        return "Suspense";
      case N:
        return "SuspenseList";
      case B:
        return "Activity";
    }
    if (typeof i == "object")
      switch (i.$$typeof) {
        case y:
          return "Portal";
        case k:
          return (i.displayName || "Context") + ".Provider";
        case T:
          return (i._context.displayName || "Context") + ".Consumer";
        case A:
          var l = i.render;
          return i = i.displayName, i || (i = l.displayName || l.name || "", i = i !== "" ? "ForwardRef(" + i + ")" : "ForwardRef"), i;
        case P:
          return l = i.displayName || null, l !== null ? l : j(i.type) || "Memo";
        case z:
          l = i._payload, i = i._init;
          try {
            return j(i(l));
          } catch {
          }
      }
    return null;
  }
  var V = Array.isArray, I = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, H = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, q = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, G = [], O = -1;
  function Y(i) {
    return { current: i };
  }
  function Z(i) {
    0 > O || (i.current = G[O], G[O] = null, O--);
  }
  function L(i, l) {
    O++, G[O] = i.current, i.current = l;
  }
  var te = Y(null), he = Y(null), oe = Y(null), de = Y(null);
  function le(i, l) {
    switch (L(oe, l), L(he, i), L(te, null), l.nodeType) {
      case 9:
      case 11:
        i = (i = l.documentElement) && (i = i.namespaceURI) ? RE(i) : 0;
        break;
      default:
        if (i = l.tagName, l = l.namespaceURI)
          l = RE(l), i = ME(l, i);
        else
          switch (i) {
            case "svg":
              i = 1;
              break;
            case "math":
              i = 2;
              break;
            default:
              i = 0;
          }
    }
    Z(te), L(te, i);
  }
  function ye() {
    Z(te), Z(he), Z(oe);
  }
  function je(i) {
    i.memoizedState !== null && L(de, i);
    var l = te.current, d = ME(l, i.type);
    l !== d && (L(he, i), L(te, d));
  }
  function Ne(i) {
    he.current === i && (Z(te), Z(he)), de.current === i && (Z(de), qu._currentValue = q);
  }
  var we = Object.prototype.hasOwnProperty, Ee = e.unstable_scheduleCallback, _e = e.unstable_cancelCallback, Xe = e.unstable_shouldYield, St = e.unstable_requestPaint, ct = e.unstable_now, cn = e.unstable_getCurrentPriorityLevel, fr = e.unstable_ImmediatePriority, Un = e.unstable_UserBlockingPriority, qn = e.unstable_NormalPriority, ze = e.unstable_LowPriority, qr = e.unstable_IdlePriority, ca = e.log, gi = e.unstable_setDisableYieldValue, ae = null, pe = null;
  function Ce(i) {
    if (typeof ca == "function" && gi(i), pe && typeof pe.setStrictMode == "function")
      try {
        pe.setStrictMode(ae, i);
      } catch {
      }
  }
  var De = Math.clz32 ? Math.clz32 : Ar, et = Math.log, wn = Math.LN2;
  function Ar(i) {
    return i >>>= 0, i === 0 ? 32 : 31 - (et(i) / wn | 0) | 0;
  }
  var fn = 256, dr = 4194304;
  function _n(i) {
    var l = i & 42;
    if (l !== 0) return l;
    switch (i & -i) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return i & 4194048;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return i & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return i;
    }
  }
  function $t(i, l, d) {
    var m = i.pendingLanes;
    if (m === 0) return 0;
    var b = 0, C = i.suspendedLanes, D = i.pingedLanes;
    i = i.warmLanes;
    var $ = m & 134217727;
    return $ !== 0 ? (m = $ & ~C, m !== 0 ? b = _n(m) : (D &= $, D !== 0 ? b = _n(D) : d || (d = $ & ~i, d !== 0 && (b = _n(d))))) : ($ = m & ~C, $ !== 0 ? b = _n($) : D !== 0 ? b = _n(D) : d || (d = m & ~i, d !== 0 && (b = _n(d)))), b === 0 ? 0 : l !== 0 && l !== b && (l & C) === 0 && (C = b & -b, d = l & -l, C >= d || C === 32 && (d & 4194048) !== 0) ? l : b;
  }
  function Rn(i, l) {
    return (i.pendingLanes & ~(i.suspendedLanes & ~i.pingedLanes) & l) === 0;
  }
  function Gn(i, l) {
    switch (i) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return l + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Af() {
    var i = fn;
    return fn <<= 1, (fn & 4194048) === 0 && (fn = 256), i;
  }
  function Rf() {
    var i = dr;
    return dr <<= 1, (dr & 62914560) === 0 && (dr = 4194304), i;
  }
  function Gl(i) {
    for (var l = [], d = 0; 31 > d; d++) l.push(i);
    return l;
  }
  function fa(i, l) {
    i.pendingLanes |= l, l !== 268435456 && (i.suspendedLanes = 0, i.pingedLanes = 0, i.warmLanes = 0);
  }
  function ng(i, l, d, m, b, C) {
    var D = i.pendingLanes;
    i.pendingLanes = d, i.suspendedLanes = 0, i.pingedLanes = 0, i.warmLanes = 0, i.expiredLanes &= d, i.entangledLanes &= d, i.errorRecoveryDisabledLanes &= d, i.shellSuspendCounter = 0;
    var $ = i.entanglements, X = i.expirationTimes, ee = i.hiddenUpdates;
    for (d = D & ~d; 0 < d; ) {
      var ue = 31 - De(d), fe = 1 << ue;
      $[ue] = 0, X[ue] = -1;
      var ne = ee[ue];
      if (ne !== null)
        for (ee[ue] = null, ue = 0; ue < ne.length; ue++) {
          var re = ne[ue];
          re !== null && (re.lane &= -536870913);
        }
      d &= ~fe;
    }
    m !== 0 && Mf(i, m, 0), C !== 0 && b === 0 && i.tag !== 0 && (i.suspendedLanes |= C & ~(D & ~l));
  }
  function Mf(i, l, d) {
    i.pendingLanes |= l, i.suspendedLanes &= ~l;
    var m = 31 - De(l);
    i.entangledLanes |= l, i.entanglements[m] = i.entanglements[m] | 1073741824 | d & 4194090;
  }
  function Yl(i, l) {
    var d = i.entangledLanes |= l;
    for (i = i.entanglements; d; ) {
      var m = 31 - De(d), b = 1 << m;
      b & l | i[m] & l && (i[m] |= l), d &= ~b;
    }
  }
  function Wl(i) {
    switch (i) {
      case 2:
        i = 1;
        break;
      case 8:
        i = 4;
        break;
      case 32:
        i = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        i = 128;
        break;
      case 268435456:
        i = 134217728;
        break;
      default:
        i = 0;
    }
    return i;
  }
  function Xl(i) {
    return i &= -i, 2 < i ? 8 < i ? (i & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function Of() {
    var i = H.p;
    return i !== 0 ? i : (i = window.event, i === void 0 ? 32 : XE(i.type));
  }
  function rg(i, l) {
    var d = H.p;
    try {
      return H.p = i, l();
    } finally {
      H.p = d;
    }
  }
  var Gr = Math.random().toString(36).slice(2), Qt = "__reactFiber$" + Gr, dn = "__reactProps$" + Gr, yi = "__reactContainer$" + Gr, Kl = "__reactEvents$" + Gr, og = "__reactListeners$" + Gr, ig = "__reactHandles$" + Gr, Nf = "__reactResources$" + Gr, da = "__reactMarker$" + Gr;
  function Zl(i) {
    delete i[Qt], delete i[dn], delete i[Kl], delete i[og], delete i[ig];
  }
  function vi(i) {
    var l = i[Qt];
    if (l) return l;
    for (var d = i.parentNode; d; ) {
      if (l = d[yi] || d[Qt]) {
        if (d = l.alternate, l.child !== null || d !== null && d.child !== null)
          for (i = PE(i); i !== null; ) {
            if (d = i[Qt]) return d;
            i = PE(i);
          }
        return l;
      }
      i = d, d = i.parentNode;
    }
    return null;
  }
  function ko(i) {
    if (i = i[Qt] || i[yi]) {
      var l = i.tag;
      if (l === 5 || l === 6 || l === 13 || l === 26 || l === 27 || l === 3)
        return i;
    }
    return null;
  }
  function bi(i) {
    var l = i.tag;
    if (l === 5 || l === 26 || l === 27 || l === 6) return i.stateNode;
    throw Error(r(33));
  }
  function To(i) {
    var l = i[Nf];
    return l || (l = i[Nf] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), l;
  }
  function Bt(i) {
    i[da] = !0;
  }
  var Df = /* @__PURE__ */ new Set(), Pf = {};
  function Ao(i, l) {
    xi(i, l), xi(i + "Capture", l);
  }
  function xi(i, l) {
    for (Pf[i] = l, i = 0; i < l.length; i++)
      Df.add(l[i]);
  }
  var ag = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), Ql = {}, jf = {};
  function sg(i) {
    return we.call(jf, i) ? !0 : we.call(Ql, i) ? !1 : ag.test(i) ? jf[i] = !0 : (Ql[i] = !0, !1);
  }
  function is(i, l, d) {
    if (sg(l))
      if (d === null) i.removeAttribute(l);
      else {
        switch (typeof d) {
          case "undefined":
          case "function":
          case "symbol":
            i.removeAttribute(l);
            return;
          case "boolean":
            var m = l.toLowerCase().slice(0, 5);
            if (m !== "data-" && m !== "aria-") {
              i.removeAttribute(l);
              return;
            }
        }
        i.setAttribute(l, "" + d);
      }
  }
  function as(i, l, d) {
    if (d === null) i.removeAttribute(l);
    else {
      switch (typeof d) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          i.removeAttribute(l);
          return;
      }
      i.setAttribute(l, "" + d);
    }
  }
  function Rr(i, l, d, m) {
    if (m === null) i.removeAttribute(d);
    else {
      switch (typeof m) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          i.removeAttribute(d);
          return;
      }
      i.setAttributeNS(l, d, "" + m);
    }
  }
  var Jl, If;
  function Ro(i) {
    if (Jl === void 0)
      try {
        throw Error();
      } catch (d) {
        var l = d.stack.trim().match(/\n( *(at )?)/);
        Jl = l && l[1] || "", If = -1 < d.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < d.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + Jl + i + If;
  }
  var eu = !1;
  function tu(i, l) {
    if (!i || eu) return "";
    eu = !0;
    var d = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var m = {
        DetermineComponentFrameRoot: function() {
          try {
            if (l) {
              var fe = function() {
                throw Error();
              };
              if (Object.defineProperty(fe.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(fe, []);
                } catch (re) {
                  var ne = re;
                }
                Reflect.construct(i, [], fe);
              } else {
                try {
                  fe.call();
                } catch (re) {
                  ne = re;
                }
                i.call(fe.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (re) {
                ne = re;
              }
              (fe = i()) && typeof fe.catch == "function" && fe.catch(function() {
              });
            }
          } catch (re) {
            if (re && ne && typeof re.stack == "string")
              return [re.stack, ne.stack];
          }
          return [null, null];
        }
      };
      m.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var b = Object.getOwnPropertyDescriptor(
        m.DetermineComponentFrameRoot,
        "name"
      );
      b && b.configurable && Object.defineProperty(
        m.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var C = m.DetermineComponentFrameRoot(), D = C[0], $ = C[1];
      if (D && $) {
        var X = D.split(`
`), ee = $.split(`
`);
        for (b = m = 0; m < X.length && !X[m].includes("DetermineComponentFrameRoot"); )
          m++;
        for (; b < ee.length && !ee[b].includes(
          "DetermineComponentFrameRoot"
        ); )
          b++;
        if (m === X.length || b === ee.length)
          for (m = X.length - 1, b = ee.length - 1; 1 <= m && 0 <= b && X[m] !== ee[b]; )
            b--;
        for (; 1 <= m && 0 <= b; m--, b--)
          if (X[m] !== ee[b]) {
            if (m !== 1 || b !== 1)
              do
                if (m--, b--, 0 > b || X[m] !== ee[b]) {
                  var ue = `
` + X[m].replace(" at new ", " at ");
                  return i.displayName && ue.includes("<anonymous>") && (ue = ue.replace("<anonymous>", i.displayName)), ue;
                }
              while (1 <= m && 0 <= b);
            break;
          }
      }
    } finally {
      eu = !1, Error.prepareStackTrace = d;
    }
    return (d = i ? i.displayName || i.name : "") ? Ro(d) : "";
  }
  function lg(i) {
    switch (i.tag) {
      case 26:
      case 27:
      case 5:
        return Ro(i.type);
      case 16:
        return Ro("Lazy");
      case 13:
        return Ro("Suspense");
      case 19:
        return Ro("SuspenseList");
      case 0:
      case 15:
        return tu(i.type, !1);
      case 11:
        return tu(i.type.render, !1);
      case 1:
        return tu(i.type, !0);
      case 31:
        return Ro("Activity");
      default:
        return "";
    }
  }
  function zf(i) {
    try {
      var l = "";
      do
        l += lg(i), i = i.return;
      while (i);
      return l;
    } catch (d) {
      return `
Error generating stack: ` + d.message + `
` + d.stack;
    }
  }
  function Mn(i) {
    switch (typeof i) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return i;
      case "object":
        return i;
      default:
        return "";
    }
  }
  function Lf(i) {
    var l = i.type;
    return (i = i.nodeName) && i.toLowerCase() === "input" && (l === "checkbox" || l === "radio");
  }
  function ug(i) {
    var l = Lf(i) ? "checked" : "value", d = Object.getOwnPropertyDescriptor(
      i.constructor.prototype,
      l
    ), m = "" + i[l];
    if (!i.hasOwnProperty(l) && typeof d < "u" && typeof d.get == "function" && typeof d.set == "function") {
      var b = d.get, C = d.set;
      return Object.defineProperty(i, l, {
        configurable: !0,
        get: function() {
          return b.call(this);
        },
        set: function(D) {
          m = "" + D, C.call(this, D);
        }
      }), Object.defineProperty(i, l, {
        enumerable: d.enumerable
      }), {
        getValue: function() {
          return m;
        },
        setValue: function(D) {
          m = "" + D;
        },
        stopTracking: function() {
          i._valueTracker = null, delete i[l];
        }
      };
    }
  }
  function ss(i) {
    i._valueTracker || (i._valueTracker = ug(i));
  }
  function nu(i) {
    if (!i) return !1;
    var l = i._valueTracker;
    if (!l) return !0;
    var d = l.getValue(), m = "";
    return i && (m = Lf(i) ? i.checked ? "true" : "false" : i.value), i = m, i !== d ? (l.setValue(i), !0) : !1;
  }
  function ls(i) {
    if (i = i || (typeof document < "u" ? document : void 0), typeof i > "u") return null;
    try {
      return i.activeElement || i.body;
    } catch {
      return i.body;
    }
  }
  var cg = /[\n"\\]/g;
  function On(i) {
    return i.replace(
      cg,
      function(l) {
        return "\\" + l.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function ha(i, l, d, m, b, C, D, $) {
    i.name = "", D != null && typeof D != "function" && typeof D != "symbol" && typeof D != "boolean" ? i.type = D : i.removeAttribute("type"), l != null ? D === "number" ? (l === 0 && i.value === "" || i.value != l) && (i.value = "" + Mn(l)) : i.value !== "" + Mn(l) && (i.value = "" + Mn(l)) : D !== "submit" && D !== "reset" || i.removeAttribute("value"), l != null ? ru(i, D, Mn(l)) : d != null ? ru(i, D, Mn(d)) : m != null && i.removeAttribute("value"), b == null && C != null && (i.defaultChecked = !!C), b != null && (i.checked = b && typeof b != "function" && typeof b != "symbol"), $ != null && typeof $ != "function" && typeof $ != "symbol" && typeof $ != "boolean" ? i.name = "" + Mn($) : i.removeAttribute("name");
  }
  function Ff(i, l, d, m, b, C, D, $) {
    if (C != null && typeof C != "function" && typeof C != "symbol" && typeof C != "boolean" && (i.type = C), l != null || d != null) {
      if (!(C !== "submit" && C !== "reset" || l != null))
        return;
      d = d != null ? "" + Mn(d) : "", l = l != null ? "" + Mn(l) : d, $ || l === i.value || (i.value = l), i.defaultValue = l;
    }
    m = m ?? b, m = typeof m != "function" && typeof m != "symbol" && !!m, i.checked = $ ? i.checked : !!m, i.defaultChecked = !!m, D != null && typeof D != "function" && typeof D != "symbol" && typeof D != "boolean" && (i.name = D);
  }
  function ru(i, l, d) {
    l === "number" && ls(i.ownerDocument) === i || i.defaultValue === "" + d || (i.defaultValue = "" + d);
  }
  function Mo(i, l, d, m) {
    if (i = i.options, l) {
      l = {};
      for (var b = 0; b < d.length; b++)
        l["$" + d[b]] = !0;
      for (d = 0; d < i.length; d++)
        b = l.hasOwnProperty("$" + i[d].value), i[d].selected !== b && (i[d].selected = b), b && m && (i[d].defaultSelected = !0);
    } else {
      for (d = "" + Mn(d), l = null, b = 0; b < i.length; b++) {
        if (i[b].value === d) {
          i[b].selected = !0, m && (i[b].defaultSelected = !0);
          return;
        }
        l !== null || i[b].disabled || (l = i[b]);
      }
      l !== null && (l.selected = !0);
    }
  }
  function Tw(i, l, d) {
    if (l != null && (l = "" + Mn(l), l !== i.value && (i.value = l), d == null)) {
      i.defaultValue !== l && (i.defaultValue = l);
      return;
    }
    i.defaultValue = d != null ? "" + Mn(d) : "";
  }
  function Aw(i, l, d, m) {
    if (l == null) {
      if (m != null) {
        if (d != null) throw Error(r(92));
        if (V(m)) {
          if (1 < m.length) throw Error(r(93));
          m = m[0];
        }
        d = m;
      }
      d == null && (d = ""), l = d;
    }
    d = Mn(l), i.defaultValue = d, m = i.textContent, m === d && m !== "" && m !== null && (i.value = m);
  }
  function us(i, l) {
    if (l) {
      var d = i.firstChild;
      if (d && d === i.lastChild && d.nodeType === 3) {
        d.nodeValue = l;
        return;
      }
    }
    i.textContent = l;
  }
  var oj = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function Rw(i, l, d) {
    var m = l.indexOf("--") === 0;
    d == null || typeof d == "boolean" || d === "" ? m ? i.setProperty(l, "") : l === "float" ? i.cssFloat = "" : i[l] = "" : m ? i.setProperty(l, d) : typeof d != "number" || d === 0 || oj.has(l) ? l === "float" ? i.cssFloat = d : i[l] = ("" + d).trim() : i[l] = d + "px";
  }
  function Mw(i, l, d) {
    if (l != null && typeof l != "object")
      throw Error(r(62));
    if (i = i.style, d != null) {
      for (var m in d)
        !d.hasOwnProperty(m) || l != null && l.hasOwnProperty(m) || (m.indexOf("--") === 0 ? i.setProperty(m, "") : m === "float" ? i.cssFloat = "" : i[m] = "");
      for (var b in l)
        m = l[b], l.hasOwnProperty(b) && d[b] !== m && Rw(i, b, m);
    } else
      for (var C in l)
        l.hasOwnProperty(C) && Rw(i, C, l[C]);
  }
  function fg(i) {
    if (i.indexOf("-") === -1) return !1;
    switch (i) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var ij = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), aj = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function $f(i) {
    return aj.test("" + i) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : i;
  }
  var dg = null;
  function hg(i) {
    return i = i.target || i.srcElement || window, i.correspondingUseElement && (i = i.correspondingUseElement), i.nodeType === 3 ? i.parentNode : i;
  }
  var cs = null, fs = null;
  function Ow(i) {
    var l = ko(i);
    if (l && (i = l.stateNode)) {
      var d = i[dn] || null;
      e: switch (i = l.stateNode, l.type) {
        case "input":
          if (ha(
            i,
            d.value,
            d.defaultValue,
            d.defaultValue,
            d.checked,
            d.defaultChecked,
            d.type,
            d.name
          ), l = d.name, d.type === "radio" && l != null) {
            for (d = i; d.parentNode; ) d = d.parentNode;
            for (d = d.querySelectorAll(
              'input[name="' + On(
                "" + l
              ) + '"][type="radio"]'
            ), l = 0; l < d.length; l++) {
              var m = d[l];
              if (m !== i && m.form === i.form) {
                var b = m[dn] || null;
                if (!b) throw Error(r(90));
                ha(
                  m,
                  b.value,
                  b.defaultValue,
                  b.defaultValue,
                  b.checked,
                  b.defaultChecked,
                  b.type,
                  b.name
                );
              }
            }
            for (l = 0; l < d.length; l++)
              m = d[l], m.form === i.form && nu(m);
          }
          break e;
        case "textarea":
          Tw(i, d.value, d.defaultValue);
          break e;
        case "select":
          l = d.value, l != null && Mo(i, !!d.multiple, l, !1);
      }
    }
  }
  var pg = !1;
  function Nw(i, l, d) {
    if (pg) return i(l, d);
    pg = !0;
    try {
      var m = i(l);
      return m;
    } finally {
      if (pg = !1, (cs !== null || fs !== null) && (Cd(), cs && (l = cs, i = fs, fs = cs = null, Ow(l), i)))
        for (l = 0; l < i.length; l++) Ow(i[l]);
    }
  }
  function ou(i, l) {
    var d = i.stateNode;
    if (d === null) return null;
    var m = d[dn] || null;
    if (m === null) return null;
    d = m[l];
    e: switch (l) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (m = !m.disabled) || (i = i.type, m = !(i === "button" || i === "input" || i === "select" || i === "textarea")), i = !m;
        break e;
      default:
        i = !1;
    }
    if (i) return null;
    if (d && typeof d != "function")
      throw Error(
        r(231, l, typeof d)
      );
    return d;
  }
  var Oo = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), mg = !1;
  if (Oo)
    try {
      var iu = {};
      Object.defineProperty(iu, "passive", {
        get: function() {
          mg = !0;
        }
      }), window.addEventListener("test", iu, iu), window.removeEventListener("test", iu, iu);
    } catch {
      mg = !1;
    }
  var wi = null, gg = null, Bf = null;
  function Dw() {
    if (Bf) return Bf;
    var i, l = gg, d = l.length, m, b = "value" in wi ? wi.value : wi.textContent, C = b.length;
    for (i = 0; i < d && l[i] === b[i]; i++) ;
    var D = d - i;
    for (m = 1; m <= D && l[d - m] === b[C - m]; m++) ;
    return Bf = b.slice(i, 1 < m ? 1 - m : void 0);
  }
  function Hf(i) {
    var l = i.keyCode;
    return "charCode" in i ? (i = i.charCode, i === 0 && l === 13 && (i = 13)) : i = l, i === 10 && (i = 13), 32 <= i || i === 13 ? i : 0;
  }
  function Vf() {
    return !0;
  }
  function Pw() {
    return !1;
  }
  function Nn(i) {
    function l(d, m, b, C, D) {
      this._reactName = d, this._targetInst = b, this.type = m, this.nativeEvent = C, this.target = D, this.currentTarget = null;
      for (var $ in i)
        i.hasOwnProperty($) && (d = i[$], this[$] = d ? d(C) : C[$]);
      return this.isDefaultPrevented = (C.defaultPrevented != null ? C.defaultPrevented : C.returnValue === !1) ? Vf : Pw, this.isPropagationStopped = Pw, this;
    }
    return h(l.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var d = this.nativeEvent;
        d && (d.preventDefault ? d.preventDefault() : typeof d.returnValue != "unknown" && (d.returnValue = !1), this.isDefaultPrevented = Vf);
      },
      stopPropagation: function() {
        var d = this.nativeEvent;
        d && (d.stopPropagation ? d.stopPropagation() : typeof d.cancelBubble != "unknown" && (d.cancelBubble = !0), this.isPropagationStopped = Vf);
      },
      persist: function() {
      },
      isPersistent: Vf
    }), l;
  }
  var pa = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(i) {
      return i.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, Uf = Nn(pa), au = h({}, pa, { view: 0, detail: 0 }), sj = Nn(au), yg, vg, su, qf = h({}, au, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: xg,
    button: 0,
    buttons: 0,
    relatedTarget: function(i) {
      return i.relatedTarget === void 0 ? i.fromElement === i.srcElement ? i.toElement : i.fromElement : i.relatedTarget;
    },
    movementX: function(i) {
      return "movementX" in i ? i.movementX : (i !== su && (su && i.type === "mousemove" ? (yg = i.screenX - su.screenX, vg = i.screenY - su.screenY) : vg = yg = 0, su = i), yg);
    },
    movementY: function(i) {
      return "movementY" in i ? i.movementY : vg;
    }
  }), jw = Nn(qf), lj = h({}, qf, { dataTransfer: 0 }), uj = Nn(lj), cj = h({}, au, { relatedTarget: 0 }), bg = Nn(cj), fj = h({}, pa, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), dj = Nn(fj), hj = h({}, pa, {
    clipboardData: function(i) {
      return "clipboardData" in i ? i.clipboardData : window.clipboardData;
    }
  }), pj = Nn(hj), mj = h({}, pa, { data: 0 }), Iw = Nn(mj), gj = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, yj = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, vj = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function bj(i) {
    var l = this.nativeEvent;
    return l.getModifierState ? l.getModifierState(i) : (i = vj[i]) ? !!l[i] : !1;
  }
  function xg() {
    return bj;
  }
  var xj = h({}, au, {
    key: function(i) {
      if (i.key) {
        var l = gj[i.key] || i.key;
        if (l !== "Unidentified") return l;
      }
      return i.type === "keypress" ? (i = Hf(i), i === 13 ? "Enter" : String.fromCharCode(i)) : i.type === "keydown" || i.type === "keyup" ? yj[i.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: xg,
    charCode: function(i) {
      return i.type === "keypress" ? Hf(i) : 0;
    },
    keyCode: function(i) {
      return i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0;
    },
    which: function(i) {
      return i.type === "keypress" ? Hf(i) : i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0;
    }
  }), wj = Nn(xj), _j = h({}, qf, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), zw = Nn(_j), Sj = h({}, au, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: xg
  }), Ej = Nn(Sj), Cj = h({}, pa, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), kj = Nn(Cj), Tj = h({}, qf, {
    deltaX: function(i) {
      return "deltaX" in i ? i.deltaX : "wheelDeltaX" in i ? -i.wheelDeltaX : 0;
    },
    deltaY: function(i) {
      return "deltaY" in i ? i.deltaY : "wheelDeltaY" in i ? -i.wheelDeltaY : "wheelDelta" in i ? -i.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Aj = Nn(Tj), Rj = h({}, pa, {
    newState: 0,
    oldState: 0
  }), Mj = Nn(Rj), Oj = [9, 13, 27, 32], wg = Oo && "CompositionEvent" in window, lu = null;
  Oo && "documentMode" in document && (lu = document.documentMode);
  var Nj = Oo && "TextEvent" in window && !lu, Lw = Oo && (!wg || lu && 8 < lu && 11 >= lu), Fw = " ", $w = !1;
  function Bw(i, l) {
    switch (i) {
      case "keyup":
        return Oj.indexOf(l.keyCode) !== -1;
      case "keydown":
        return l.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Hw(i) {
    return i = i.detail, typeof i == "object" && "data" in i ? i.data : null;
  }
  var ds = !1;
  function Dj(i, l) {
    switch (i) {
      case "compositionend":
        return Hw(l);
      case "keypress":
        return l.which !== 32 ? null : ($w = !0, Fw);
      case "textInput":
        return i = l.data, i === Fw && $w ? null : i;
      default:
        return null;
    }
  }
  function Pj(i, l) {
    if (ds)
      return i === "compositionend" || !wg && Bw(i, l) ? (i = Dw(), Bf = gg = wi = null, ds = !1, i) : null;
    switch (i) {
      case "paste":
        return null;
      case "keypress":
        if (!(l.ctrlKey || l.altKey || l.metaKey) || l.ctrlKey && l.altKey) {
          if (l.char && 1 < l.char.length)
            return l.char;
          if (l.which) return String.fromCharCode(l.which);
        }
        return null;
      case "compositionend":
        return Lw && l.locale !== "ko" ? null : l.data;
      default:
        return null;
    }
  }
  var jj = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function Vw(i) {
    var l = i && i.nodeName && i.nodeName.toLowerCase();
    return l === "input" ? !!jj[i.type] : l === "textarea";
  }
  function Uw(i, l, d, m) {
    cs ? fs ? fs.push(m) : fs = [m] : cs = m, l = Od(l, "onChange"), 0 < l.length && (d = new Uf(
      "onChange",
      "change",
      null,
      d,
      m
    ), i.push({ event: d, listeners: l }));
  }
  var uu = null, cu = null;
  function Ij(i) {
    EE(i, 0);
  }
  function Gf(i) {
    var l = bi(i);
    if (nu(l)) return i;
  }
  function qw(i, l) {
    if (i === "change") return l;
  }
  var Gw = !1;
  if (Oo) {
    var _g;
    if (Oo) {
      var Sg = "oninput" in document;
      if (!Sg) {
        var Yw = document.createElement("div");
        Yw.setAttribute("oninput", "return;"), Sg = typeof Yw.oninput == "function";
      }
      _g = Sg;
    } else _g = !1;
    Gw = _g && (!document.documentMode || 9 < document.documentMode);
  }
  function Ww() {
    uu && (uu.detachEvent("onpropertychange", Xw), cu = uu = null);
  }
  function Xw(i) {
    if (i.propertyName === "value" && Gf(cu)) {
      var l = [];
      Uw(
        l,
        cu,
        i,
        hg(i)
      ), Nw(Ij, l);
    }
  }
  function zj(i, l, d) {
    i === "focusin" ? (Ww(), uu = l, cu = d, uu.attachEvent("onpropertychange", Xw)) : i === "focusout" && Ww();
  }
  function Lj(i) {
    if (i === "selectionchange" || i === "keyup" || i === "keydown")
      return Gf(cu);
  }
  function Fj(i, l) {
    if (i === "click") return Gf(l);
  }
  function $j(i, l) {
    if (i === "input" || i === "change")
      return Gf(l);
  }
  function Bj(i, l) {
    return i === l && (i !== 0 || 1 / i === 1 / l) || i !== i && l !== l;
  }
  var Yn = typeof Object.is == "function" ? Object.is : Bj;
  function fu(i, l) {
    if (Yn(i, l)) return !0;
    if (typeof i != "object" || i === null || typeof l != "object" || l === null)
      return !1;
    var d = Object.keys(i), m = Object.keys(l);
    if (d.length !== m.length) return !1;
    for (m = 0; m < d.length; m++) {
      var b = d[m];
      if (!we.call(l, b) || !Yn(i[b], l[b]))
        return !1;
    }
    return !0;
  }
  function Kw(i) {
    for (; i && i.firstChild; ) i = i.firstChild;
    return i;
  }
  function Zw(i, l) {
    var d = Kw(i);
    i = 0;
    for (var m; d; ) {
      if (d.nodeType === 3) {
        if (m = i + d.textContent.length, i <= l && m >= l)
          return { node: d, offset: l - i };
        i = m;
      }
      e: {
        for (; d; ) {
          if (d.nextSibling) {
            d = d.nextSibling;
            break e;
          }
          d = d.parentNode;
        }
        d = void 0;
      }
      d = Kw(d);
    }
  }
  function Qw(i, l) {
    return i && l ? i === l ? !0 : i && i.nodeType === 3 ? !1 : l && l.nodeType === 3 ? Qw(i, l.parentNode) : "contains" in i ? i.contains(l) : i.compareDocumentPosition ? !!(i.compareDocumentPosition(l) & 16) : !1 : !1;
  }
  function Jw(i) {
    i = i != null && i.ownerDocument != null && i.ownerDocument.defaultView != null ? i.ownerDocument.defaultView : window;
    for (var l = ls(i.document); l instanceof i.HTMLIFrameElement; ) {
      try {
        var d = typeof l.contentWindow.location.href == "string";
      } catch {
        d = !1;
      }
      if (d) i = l.contentWindow;
      else break;
      l = ls(i.document);
    }
    return l;
  }
  function Eg(i) {
    var l = i && i.nodeName && i.nodeName.toLowerCase();
    return l && (l === "input" && (i.type === "text" || i.type === "search" || i.type === "tel" || i.type === "url" || i.type === "password") || l === "textarea" || i.contentEditable === "true");
  }
  var Hj = Oo && "documentMode" in document && 11 >= document.documentMode, hs = null, Cg = null, du = null, kg = !1;
  function e_(i, l, d) {
    var m = d.window === d ? d.document : d.nodeType === 9 ? d : d.ownerDocument;
    kg || hs == null || hs !== ls(m) || (m = hs, "selectionStart" in m && Eg(m) ? m = { start: m.selectionStart, end: m.selectionEnd } : (m = (m.ownerDocument && m.ownerDocument.defaultView || window).getSelection(), m = {
      anchorNode: m.anchorNode,
      anchorOffset: m.anchorOffset,
      focusNode: m.focusNode,
      focusOffset: m.focusOffset
    }), du && fu(du, m) || (du = m, m = Od(Cg, "onSelect"), 0 < m.length && (l = new Uf(
      "onSelect",
      "select",
      null,
      l,
      d
    ), i.push({ event: l, listeners: m }), l.target = hs)));
  }
  function ma(i, l) {
    var d = {};
    return d[i.toLowerCase()] = l.toLowerCase(), d["Webkit" + i] = "webkit" + l, d["Moz" + i] = "moz" + l, d;
  }
  var ps = {
    animationend: ma("Animation", "AnimationEnd"),
    animationiteration: ma("Animation", "AnimationIteration"),
    animationstart: ma("Animation", "AnimationStart"),
    transitionrun: ma("Transition", "TransitionRun"),
    transitionstart: ma("Transition", "TransitionStart"),
    transitioncancel: ma("Transition", "TransitionCancel"),
    transitionend: ma("Transition", "TransitionEnd")
  }, Tg = {}, t_ = {};
  Oo && (t_ = document.createElement("div").style, "AnimationEvent" in window || (delete ps.animationend.animation, delete ps.animationiteration.animation, delete ps.animationstart.animation), "TransitionEvent" in window || delete ps.transitionend.transition);
  function ga(i) {
    if (Tg[i]) return Tg[i];
    if (!ps[i]) return i;
    var l = ps[i], d;
    for (d in l)
      if (l.hasOwnProperty(d) && d in t_)
        return Tg[i] = l[d];
    return i;
  }
  var n_ = ga("animationend"), r_ = ga("animationiteration"), o_ = ga("animationstart"), Vj = ga("transitionrun"), Uj = ga("transitionstart"), qj = ga("transitioncancel"), i_ = ga("transitionend"), a_ = /* @__PURE__ */ new Map(), Ag = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  Ag.push("scrollEnd");
  function Mr(i, l) {
    a_.set(i, l), Ao(l, [i]);
  }
  var s_ = /* @__PURE__ */ new WeakMap();
  function hr(i, l) {
    if (typeof i == "object" && i !== null) {
      var d = s_.get(i);
      return d !== void 0 ? d : (l = {
        value: i,
        source: l,
        stack: zf(l)
      }, s_.set(i, l), l);
    }
    return {
      value: i,
      source: l,
      stack: zf(l)
    };
  }
  var pr = [], ms = 0, Rg = 0;
  function Yf() {
    for (var i = ms, l = Rg = ms = 0; l < i; ) {
      var d = pr[l];
      pr[l++] = null;
      var m = pr[l];
      pr[l++] = null;
      var b = pr[l];
      pr[l++] = null;
      var C = pr[l];
      if (pr[l++] = null, m !== null && b !== null) {
        var D = m.pending;
        D === null ? b.next = b : (b.next = D.next, D.next = b), m.pending = b;
      }
      C !== 0 && l_(d, b, C);
    }
  }
  function Wf(i, l, d, m) {
    pr[ms++] = i, pr[ms++] = l, pr[ms++] = d, pr[ms++] = m, Rg |= m, i.lanes |= m, i = i.alternate, i !== null && (i.lanes |= m);
  }
  function Mg(i, l, d, m) {
    return Wf(i, l, d, m), Xf(i);
  }
  function gs(i, l) {
    return Wf(i, null, null, l), Xf(i);
  }
  function l_(i, l, d) {
    i.lanes |= d;
    var m = i.alternate;
    m !== null && (m.lanes |= d);
    for (var b = !1, C = i.return; C !== null; )
      C.childLanes |= d, m = C.alternate, m !== null && (m.childLanes |= d), C.tag === 22 && (i = C.stateNode, i === null || i._visibility & 1 || (b = !0)), i = C, C = C.return;
    return i.tag === 3 ? (C = i.stateNode, b && l !== null && (b = 31 - De(d), i = C.hiddenUpdates, m = i[b], m === null ? i[b] = [l] : m.push(l), l.lane = d | 536870912), C) : null;
  }
  function Xf(i) {
    if (50 < zu)
      throw zu = 0, I0 = null, Error(r(185));
    for (var l = i.return; l !== null; )
      i = l, l = i.return;
    return i.tag === 3 ? i.stateNode : null;
  }
  var ys = {};
  function Gj(i, l, d, m) {
    this.tag = i, this.key = d, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = l, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = m, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Wn(i, l, d, m) {
    return new Gj(i, l, d, m);
  }
  function Og(i) {
    return i = i.prototype, !(!i || !i.isReactComponent);
  }
  function No(i, l) {
    var d = i.alternate;
    return d === null ? (d = Wn(
      i.tag,
      l,
      i.key,
      i.mode
    ), d.elementType = i.elementType, d.type = i.type, d.stateNode = i.stateNode, d.alternate = i, i.alternate = d) : (d.pendingProps = l, d.type = i.type, d.flags = 0, d.subtreeFlags = 0, d.deletions = null), d.flags = i.flags & 65011712, d.childLanes = i.childLanes, d.lanes = i.lanes, d.child = i.child, d.memoizedProps = i.memoizedProps, d.memoizedState = i.memoizedState, d.updateQueue = i.updateQueue, l = i.dependencies, d.dependencies = l === null ? null : { lanes: l.lanes, firstContext: l.firstContext }, d.sibling = i.sibling, d.index = i.index, d.ref = i.ref, d.refCleanup = i.refCleanup, d;
  }
  function u_(i, l) {
    i.flags &= 65011714;
    var d = i.alternate;
    return d === null ? (i.childLanes = 0, i.lanes = l, i.child = null, i.subtreeFlags = 0, i.memoizedProps = null, i.memoizedState = null, i.updateQueue = null, i.dependencies = null, i.stateNode = null) : (i.childLanes = d.childLanes, i.lanes = d.lanes, i.child = d.child, i.subtreeFlags = 0, i.deletions = null, i.memoizedProps = d.memoizedProps, i.memoizedState = d.memoizedState, i.updateQueue = d.updateQueue, i.type = d.type, l = d.dependencies, i.dependencies = l === null ? null : {
      lanes: l.lanes,
      firstContext: l.firstContext
    }), i;
  }
  function Kf(i, l, d, m, b, C) {
    var D = 0;
    if (m = i, typeof i == "function") Og(i) && (D = 1);
    else if (typeof i == "string")
      D = WI(
        i,
        d,
        te.current
      ) ? 26 : i === "html" || i === "head" || i === "body" ? 27 : 5;
    else
      e: switch (i) {
        case B:
          return i = Wn(31, d, l, b), i.elementType = B, i.lanes = C, i;
        case w:
          return ya(d.children, b, C, l);
        case v:
          D = 8, b |= 24;
          break;
        case S:
          return i = Wn(12, d, l, b | 2), i.elementType = S, i.lanes = C, i;
        case M:
          return i = Wn(13, d, l, b), i.elementType = M, i.lanes = C, i;
        case N:
          return i = Wn(19, d, l, b), i.elementType = N, i.lanes = C, i;
        default:
          if (typeof i == "object" && i !== null)
            switch (i.$$typeof) {
              case E:
              case k:
                D = 10;
                break e;
              case T:
                D = 9;
                break e;
              case A:
                D = 11;
                break e;
              case P:
                D = 14;
                break e;
              case z:
                D = 16, m = null;
                break e;
            }
          D = 29, d = Error(
            r(130, i === null ? "null" : typeof i, "")
          ), m = null;
      }
    return l = Wn(D, d, l, b), l.elementType = i, l.type = m, l.lanes = C, l;
  }
  function ya(i, l, d, m) {
    return i = Wn(7, i, m, l), i.lanes = d, i;
  }
  function Ng(i, l, d) {
    return i = Wn(6, i, null, l), i.lanes = d, i;
  }
  function Dg(i, l, d) {
    return l = Wn(
      4,
      i.children !== null ? i.children : [],
      i.key,
      l
    ), l.lanes = d, l.stateNode = {
      containerInfo: i.containerInfo,
      pendingChildren: null,
      implementation: i.implementation
    }, l;
  }
  var vs = [], bs = 0, Zf = null, Qf = 0, mr = [], gr = 0, va = null, Do = 1, Po = "";
  function ba(i, l) {
    vs[bs++] = Qf, vs[bs++] = Zf, Zf = i, Qf = l;
  }
  function c_(i, l, d) {
    mr[gr++] = Do, mr[gr++] = Po, mr[gr++] = va, va = i;
    var m = Do;
    i = Po;
    var b = 32 - De(m) - 1;
    m &= ~(1 << b), d += 1;
    var C = 32 - De(l) + b;
    if (30 < C) {
      var D = b - b % 5;
      C = (m & (1 << D) - 1).toString(32), m >>= D, b -= D, Do = 1 << 32 - De(l) + b | d << b | m, Po = C + i;
    } else
      Do = 1 << C | d << b | m, Po = i;
  }
  function Pg(i) {
    i.return !== null && (ba(i, 1), c_(i, 1, 0));
  }
  function jg(i) {
    for (; i === Zf; )
      Zf = vs[--bs], vs[bs] = null, Qf = vs[--bs], vs[bs] = null;
    for (; i === va; )
      va = mr[--gr], mr[gr] = null, Po = mr[--gr], mr[gr] = null, Do = mr[--gr], mr[gr] = null;
  }
  var Sn = null, Mt = null, rt = !1, xa = null, Yr = !1, Ig = Error(r(519));
  function wa(i) {
    var l = Error(r(418, ""));
    throw mu(hr(l, i)), Ig;
  }
  function f_(i) {
    var l = i.stateNode, d = i.type, m = i.memoizedProps;
    switch (l[Qt] = i, l[dn] = m, d) {
      case "dialog":
        Ye("cancel", l), Ye("close", l);
        break;
      case "iframe":
      case "object":
      case "embed":
        Ye("load", l);
        break;
      case "video":
      case "audio":
        for (d = 0; d < Fu.length; d++)
          Ye(Fu[d], l);
        break;
      case "source":
        Ye("error", l);
        break;
      case "img":
      case "image":
      case "link":
        Ye("error", l), Ye("load", l);
        break;
      case "details":
        Ye("toggle", l);
        break;
      case "input":
        Ye("invalid", l), Ff(
          l,
          m.value,
          m.defaultValue,
          m.checked,
          m.defaultChecked,
          m.type,
          m.name,
          !0
        ), ss(l);
        break;
      case "select":
        Ye("invalid", l);
        break;
      case "textarea":
        Ye("invalid", l), Aw(l, m.value, m.defaultValue, m.children), ss(l);
    }
    d = m.children, typeof d != "string" && typeof d != "number" && typeof d != "bigint" || l.textContent === "" + d || m.suppressHydrationWarning === !0 || AE(l.textContent, d) ? (m.popover != null && (Ye("beforetoggle", l), Ye("toggle", l)), m.onScroll != null && Ye("scroll", l), m.onScrollEnd != null && Ye("scrollend", l), m.onClick != null && (l.onclick = Nd), l = !0) : l = !1, l || wa(i);
  }
  function d_(i) {
    for (Sn = i.return; Sn; )
      switch (Sn.tag) {
        case 5:
        case 13:
          Yr = !1;
          return;
        case 27:
        case 3:
          Yr = !0;
          return;
        default:
          Sn = Sn.return;
      }
  }
  function hu(i) {
    if (i !== Sn) return !1;
    if (!rt) return d_(i), rt = !0, !1;
    var l = i.tag, d;
    if ((d = l !== 3 && l !== 27) && ((d = l === 5) && (d = i.type, d = !(d !== "form" && d !== "button") || Q0(i.type, i.memoizedProps)), d = !d), d && Mt && wa(i), d_(i), l === 13) {
      if (i = i.memoizedState, i = i !== null ? i.dehydrated : null, !i) throw Error(r(317));
      e: {
        for (i = i.nextSibling, l = 0; i; ) {
          if (i.nodeType === 8)
            if (d = i.data, d === "/$") {
              if (l === 0) {
                Mt = Nr(i.nextSibling);
                break e;
              }
              l--;
            } else
              d !== "$" && d !== "$!" && d !== "$?" || l++;
          i = i.nextSibling;
        }
        Mt = null;
      }
    } else
      l === 27 ? (l = Mt, zi(i.type) ? (i = ny, ny = null, Mt = i) : Mt = l) : Mt = Sn ? Nr(i.stateNode.nextSibling) : null;
    return !0;
  }
  function pu() {
    Mt = Sn = null, rt = !1;
  }
  function h_() {
    var i = xa;
    return i !== null && (jn === null ? jn = i : jn.push.apply(
      jn,
      i
    ), xa = null), i;
  }
  function mu(i) {
    xa === null ? xa = [i] : xa.push(i);
  }
  var zg = Y(null), _a = null, jo = null;
  function _i(i, l, d) {
    L(zg, l._currentValue), l._currentValue = d;
  }
  function Io(i) {
    i._currentValue = zg.current, Z(zg);
  }
  function Lg(i, l, d) {
    for (; i !== null; ) {
      var m = i.alternate;
      if ((i.childLanes & l) !== l ? (i.childLanes |= l, m !== null && (m.childLanes |= l)) : m !== null && (m.childLanes & l) !== l && (m.childLanes |= l), i === d) break;
      i = i.return;
    }
  }
  function Fg(i, l, d, m) {
    var b = i.child;
    for (b !== null && (b.return = i); b !== null; ) {
      var C = b.dependencies;
      if (C !== null) {
        var D = b.child;
        C = C.firstContext;
        e: for (; C !== null; ) {
          var $ = C;
          C = b;
          for (var X = 0; X < l.length; X++)
            if ($.context === l[X]) {
              C.lanes |= d, $ = C.alternate, $ !== null && ($.lanes |= d), Lg(
                C.return,
                d,
                i
              ), m || (D = null);
              break e;
            }
          C = $.next;
        }
      } else if (b.tag === 18) {
        if (D = b.return, D === null) throw Error(r(341));
        D.lanes |= d, C = D.alternate, C !== null && (C.lanes |= d), Lg(D, d, i), D = null;
      } else D = b.child;
      if (D !== null) D.return = b;
      else
        for (D = b; D !== null; ) {
          if (D === i) {
            D = null;
            break;
          }
          if (b = D.sibling, b !== null) {
            b.return = D.return, D = b;
            break;
          }
          D = D.return;
        }
      b = D;
    }
  }
  function gu(i, l, d, m) {
    i = null;
    for (var b = l, C = !1; b !== null; ) {
      if (!C) {
        if ((b.flags & 524288) !== 0) C = !0;
        else if ((b.flags & 262144) !== 0) break;
      }
      if (b.tag === 10) {
        var D = b.alternate;
        if (D === null) throw Error(r(387));
        if (D = D.memoizedProps, D !== null) {
          var $ = b.type;
          Yn(b.pendingProps.value, D.value) || (i !== null ? i.push($) : i = [$]);
        }
      } else if (b === de.current) {
        if (D = b.alternate, D === null) throw Error(r(387));
        D.memoizedState.memoizedState !== b.memoizedState.memoizedState && (i !== null ? i.push(qu) : i = [qu]);
      }
      b = b.return;
    }
    i !== null && Fg(
      l,
      i,
      d,
      m
    ), l.flags |= 262144;
  }
  function Jf(i) {
    for (i = i.firstContext; i !== null; ) {
      if (!Yn(
        i.context._currentValue,
        i.memoizedValue
      ))
        return !0;
      i = i.next;
    }
    return !1;
  }
  function Sa(i) {
    _a = i, jo = null, i = i.dependencies, i !== null && (i.firstContext = null);
  }
  function hn(i) {
    return p_(_a, i);
  }
  function ed(i, l) {
    return _a === null && Sa(i), p_(i, l);
  }
  function p_(i, l) {
    var d = l._currentValue;
    if (l = { context: l, memoizedValue: d, next: null }, jo === null) {
      if (i === null) throw Error(r(308));
      jo = l, i.dependencies = { lanes: 0, firstContext: l }, i.flags |= 524288;
    } else jo = jo.next = l;
    return d;
  }
  var Yj = typeof AbortController < "u" ? AbortController : function() {
    var i = [], l = this.signal = {
      aborted: !1,
      addEventListener: function(d, m) {
        i.push(m);
      }
    };
    this.abort = function() {
      l.aborted = !0, i.forEach(function(d) {
        return d();
      });
    };
  }, Wj = e.unstable_scheduleCallback, Xj = e.unstable_NormalPriority, Xt = {
    $$typeof: k,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function $g() {
    return {
      controller: new Yj(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function yu(i) {
    i.refCount--, i.refCount === 0 && Wj(Xj, function() {
      i.controller.abort();
    });
  }
  var vu = null, Bg = 0, xs = 0, ws = null;
  function Kj(i, l) {
    if (vu === null) {
      var d = vu = [];
      Bg = 0, xs = V0(), ws = {
        status: "pending",
        value: void 0,
        then: function(m) {
          d.push(m);
        }
      };
    }
    return Bg++, l.then(m_, m_), l;
  }
  function m_() {
    if (--Bg === 0 && vu !== null) {
      ws !== null && (ws.status = "fulfilled");
      var i = vu;
      vu = null, xs = 0, ws = null;
      for (var l = 0; l < i.length; l++) (0, i[l])();
    }
  }
  function Zj(i, l) {
    var d = [], m = {
      status: "pending",
      value: null,
      reason: null,
      then: function(b) {
        d.push(b);
      }
    };
    return i.then(
      function() {
        m.status = "fulfilled", m.value = l;
        for (var b = 0; b < d.length; b++) (0, d[b])(l);
      },
      function(b) {
        for (m.status = "rejected", m.reason = b, b = 0; b < d.length; b++)
          (0, d[b])(void 0);
      }
    ), m;
  }
  var g_ = I.S;
  I.S = function(i, l) {
    typeof l == "object" && l !== null && typeof l.then == "function" && Kj(i, l), g_ !== null && g_(i, l);
  };
  var Ea = Y(null);
  function Hg() {
    var i = Ea.current;
    return i !== null ? i : xt.pooledCache;
  }
  function td(i, l) {
    l === null ? L(Ea, Ea.current) : L(Ea, l.pool);
  }
  function y_() {
    var i = Hg();
    return i === null ? null : { parent: Xt._currentValue, pool: i };
  }
  var bu = Error(r(460)), v_ = Error(r(474)), nd = Error(r(542)), Vg = { then: function() {
  } };
  function b_(i) {
    return i = i.status, i === "fulfilled" || i === "rejected";
  }
  function rd() {
  }
  function x_(i, l, d) {
    switch (d = i[d], d === void 0 ? i.push(l) : d !== l && (l.then(rd, rd), l = d), l.status) {
      case "fulfilled":
        return l.value;
      case "rejected":
        throw i = l.reason, __(i), i;
      default:
        if (typeof l.status == "string") l.then(rd, rd);
        else {
          if (i = xt, i !== null && 100 < i.shellSuspendCounter)
            throw Error(r(482));
          i = l, i.status = "pending", i.then(
            function(m) {
              if (l.status === "pending") {
                var b = l;
                b.status = "fulfilled", b.value = m;
              }
            },
            function(m) {
              if (l.status === "pending") {
                var b = l;
                b.status = "rejected", b.reason = m;
              }
            }
          );
        }
        switch (l.status) {
          case "fulfilled":
            return l.value;
          case "rejected":
            throw i = l.reason, __(i), i;
        }
        throw xu = l, bu;
    }
  }
  var xu = null;
  function w_() {
    if (xu === null) throw Error(r(459));
    var i = xu;
    return xu = null, i;
  }
  function __(i) {
    if (i === bu || i === nd)
      throw Error(r(483));
  }
  var Si = !1;
  function Ug(i) {
    i.updateQueue = {
      baseState: i.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function qg(i, l) {
    i = i.updateQueue, l.updateQueue === i && (l.updateQueue = {
      baseState: i.baseState,
      firstBaseUpdate: i.firstBaseUpdate,
      lastBaseUpdate: i.lastBaseUpdate,
      shared: i.shared,
      callbacks: null
    });
  }
  function Ei(i) {
    return { lane: i, tag: 0, payload: null, callback: null, next: null };
  }
  function Ci(i, l, d) {
    var m = i.updateQueue;
    if (m === null) return null;
    if (m = m.shared, (lt & 2) !== 0) {
      var b = m.pending;
      return b === null ? l.next = l : (l.next = b.next, b.next = l), m.pending = l, l = Xf(i), l_(i, null, d), l;
    }
    return Wf(i, m, l, d), Xf(i);
  }
  function wu(i, l, d) {
    if (l = l.updateQueue, l !== null && (l = l.shared, (d & 4194048) !== 0)) {
      var m = l.lanes;
      m &= i.pendingLanes, d |= m, l.lanes = d, Yl(i, d);
    }
  }
  function Gg(i, l) {
    var d = i.updateQueue, m = i.alternate;
    if (m !== null && (m = m.updateQueue, d === m)) {
      var b = null, C = null;
      if (d = d.firstBaseUpdate, d !== null) {
        do {
          var D = {
            lane: d.lane,
            tag: d.tag,
            payload: d.payload,
            callback: null,
            next: null
          };
          C === null ? b = C = D : C = C.next = D, d = d.next;
        } while (d !== null);
        C === null ? b = C = l : C = C.next = l;
      } else b = C = l;
      d = {
        baseState: m.baseState,
        firstBaseUpdate: b,
        lastBaseUpdate: C,
        shared: m.shared,
        callbacks: m.callbacks
      }, i.updateQueue = d;
      return;
    }
    i = d.lastBaseUpdate, i === null ? d.firstBaseUpdate = l : i.next = l, d.lastBaseUpdate = l;
  }
  var Yg = !1;
  function _u() {
    if (Yg) {
      var i = ws;
      if (i !== null) throw i;
    }
  }
  function Su(i, l, d, m) {
    Yg = !1;
    var b = i.updateQueue;
    Si = !1;
    var C = b.firstBaseUpdate, D = b.lastBaseUpdate, $ = b.shared.pending;
    if ($ !== null) {
      b.shared.pending = null;
      var X = $, ee = X.next;
      X.next = null, D === null ? C = ee : D.next = ee, D = X;
      var ue = i.alternate;
      ue !== null && (ue = ue.updateQueue, $ = ue.lastBaseUpdate, $ !== D && ($ === null ? ue.firstBaseUpdate = ee : $.next = ee, ue.lastBaseUpdate = X));
    }
    if (C !== null) {
      var fe = b.baseState;
      D = 0, ue = ee = X = null, $ = C;
      do {
        var ne = $.lane & -536870913, re = ne !== $.lane;
        if (re ? (Ze & ne) === ne : (m & ne) === ne) {
          ne !== 0 && ne === xs && (Yg = !0), ue !== null && (ue = ue.next = {
            lane: 0,
            tag: $.tag,
            payload: $.payload,
            callback: null,
            next: null
          });
          e: {
            var Le = i, Pe = $;
            ne = l;
            var ht = d;
            switch (Pe.tag) {
              case 1:
                if (Le = Pe.payload, typeof Le == "function") {
                  fe = Le.call(ht, fe, ne);
                  break e;
                }
                fe = Le;
                break e;
              case 3:
                Le.flags = Le.flags & -65537 | 128;
              case 0:
                if (Le = Pe.payload, ne = typeof Le == "function" ? Le.call(ht, fe, ne) : Le, ne == null) break e;
                fe = h({}, fe, ne);
                break e;
              case 2:
                Si = !0;
            }
          }
          ne = $.callback, ne !== null && (i.flags |= 64, re && (i.flags |= 8192), re = b.callbacks, re === null ? b.callbacks = [ne] : re.push(ne));
        } else
          re = {
            lane: ne,
            tag: $.tag,
            payload: $.payload,
            callback: $.callback,
            next: null
          }, ue === null ? (ee = ue = re, X = fe) : ue = ue.next = re, D |= ne;
        if ($ = $.next, $ === null) {
          if ($ = b.shared.pending, $ === null)
            break;
          re = $, $ = re.next, re.next = null, b.lastBaseUpdate = re, b.shared.pending = null;
        }
      } while (!0);
      ue === null && (X = fe), b.baseState = X, b.firstBaseUpdate = ee, b.lastBaseUpdate = ue, C === null && (b.shared.lanes = 0), Di |= D, i.lanes = D, i.memoizedState = fe;
    }
  }
  function S_(i, l) {
    if (typeof i != "function")
      throw Error(r(191, i));
    i.call(l);
  }
  function E_(i, l) {
    var d = i.callbacks;
    if (d !== null)
      for (i.callbacks = null, i = 0; i < d.length; i++)
        S_(d[i], l);
  }
  var _s = Y(null), od = Y(0);
  function C_(i, l) {
    i = Vo, L(od, i), L(_s, l), Vo = i | l.baseLanes;
  }
  function Wg() {
    L(od, Vo), L(_s, _s.current);
  }
  function Xg() {
    Vo = od.current, Z(_s), Z(od);
  }
  var ki = 0, He = null, ft = null, Ht = null, id = !1, Ss = !1, Ca = !1, ad = 0, Eu = 0, Es = null, Qj = 0;
  function jt() {
    throw Error(r(321));
  }
  function Kg(i, l) {
    if (l === null) return !1;
    for (var d = 0; d < l.length && d < i.length; d++)
      if (!Yn(i[d], l[d])) return !1;
    return !0;
  }
  function Zg(i, l, d, m, b, C) {
    return ki = C, He = l, l.memoizedState = null, l.updateQueue = null, l.lanes = 0, I.H = i === null || i.memoizedState === null ? lS : uS, Ca = !1, C = d(m, b), Ca = !1, Ss && (C = T_(
      l,
      d,
      m,
      b
    )), k_(i), C;
  }
  function k_(i) {
    I.H = dd;
    var l = ft !== null && ft.next !== null;
    if (ki = 0, Ht = ft = He = null, id = !1, Eu = 0, Es = null, l) throw Error(r(300));
    i === null || Jt || (i = i.dependencies, i !== null && Jf(i) && (Jt = !0));
  }
  function T_(i, l, d, m) {
    He = i;
    var b = 0;
    do {
      if (Ss && (Es = null), Eu = 0, Ss = !1, 25 <= b) throw Error(r(301));
      if (b += 1, Ht = ft = null, i.updateQueue != null) {
        var C = i.updateQueue;
        C.lastEffect = null, C.events = null, C.stores = null, C.memoCache != null && (C.memoCache.index = 0);
      }
      I.H = iI, C = l(d, m);
    } while (Ss);
    return C;
  }
  function Jj() {
    var i = I.H, l = i.useState()[0];
    return l = typeof l.then == "function" ? Cu(l) : l, i = i.useState()[0], (ft !== null ? ft.memoizedState : null) !== i && (He.flags |= 1024), l;
  }
  function Qg() {
    var i = ad !== 0;
    return ad = 0, i;
  }
  function Jg(i, l, d) {
    l.updateQueue = i.updateQueue, l.flags &= -2053, i.lanes &= ~d;
  }
  function e0(i) {
    if (id) {
      for (i = i.memoizedState; i !== null; ) {
        var l = i.queue;
        l !== null && (l.pending = null), i = i.next;
      }
      id = !1;
    }
    ki = 0, Ht = ft = He = null, Ss = !1, Eu = ad = 0, Es = null;
  }
  function Dn() {
    var i = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return Ht === null ? He.memoizedState = Ht = i : Ht = Ht.next = i, Ht;
  }
  function Vt() {
    if (ft === null) {
      var i = He.alternate;
      i = i !== null ? i.memoizedState : null;
    } else i = ft.next;
    var l = Ht === null ? He.memoizedState : Ht.next;
    if (l !== null)
      Ht = l, ft = i;
    else {
      if (i === null)
        throw He.alternate === null ? Error(r(467)) : Error(r(310));
      ft = i, i = {
        memoizedState: ft.memoizedState,
        baseState: ft.baseState,
        baseQueue: ft.baseQueue,
        queue: ft.queue,
        next: null
      }, Ht === null ? He.memoizedState = Ht = i : Ht = Ht.next = i;
    }
    return Ht;
  }
  function t0() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function Cu(i) {
    var l = Eu;
    return Eu += 1, Es === null && (Es = []), i = x_(Es, i, l), l = He, (Ht === null ? l.memoizedState : Ht.next) === null && (l = l.alternate, I.H = l === null || l.memoizedState === null ? lS : uS), i;
  }
  function sd(i) {
    if (i !== null && typeof i == "object") {
      if (typeof i.then == "function") return Cu(i);
      if (i.$$typeof === k) return hn(i);
    }
    throw Error(r(438, String(i)));
  }
  function n0(i) {
    var l = null, d = He.updateQueue;
    if (d !== null && (l = d.memoCache), l == null) {
      var m = He.alternate;
      m !== null && (m = m.updateQueue, m !== null && (m = m.memoCache, m != null && (l = {
        data: m.data.map(function(b) {
          return b.slice();
        }),
        index: 0
      })));
    }
    if (l == null && (l = { data: [], index: 0 }), d === null && (d = t0(), He.updateQueue = d), d.memoCache = l, d = l.data[l.index], d === void 0)
      for (d = l.data[l.index] = Array(i), m = 0; m < i; m++)
        d[m] = R;
    return l.index++, d;
  }
  function zo(i, l) {
    return typeof l == "function" ? l(i) : l;
  }
  function ld(i) {
    var l = Vt();
    return r0(l, ft, i);
  }
  function r0(i, l, d) {
    var m = i.queue;
    if (m === null) throw Error(r(311));
    m.lastRenderedReducer = d;
    var b = i.baseQueue, C = m.pending;
    if (C !== null) {
      if (b !== null) {
        var D = b.next;
        b.next = C.next, C.next = D;
      }
      l.baseQueue = b = C, m.pending = null;
    }
    if (C = i.baseState, b === null) i.memoizedState = C;
    else {
      l = b.next;
      var $ = D = null, X = null, ee = l, ue = !1;
      do {
        var fe = ee.lane & -536870913;
        if (fe !== ee.lane ? (Ze & fe) === fe : (ki & fe) === fe) {
          var ne = ee.revertLane;
          if (ne === 0)
            X !== null && (X = X.next = {
              lane: 0,
              revertLane: 0,
              action: ee.action,
              hasEagerState: ee.hasEagerState,
              eagerState: ee.eagerState,
              next: null
            }), fe === xs && (ue = !0);
          else if ((ki & ne) === ne) {
            ee = ee.next, ne === xs && (ue = !0);
            continue;
          } else
            fe = {
              lane: 0,
              revertLane: ee.revertLane,
              action: ee.action,
              hasEagerState: ee.hasEagerState,
              eagerState: ee.eagerState,
              next: null
            }, X === null ? ($ = X = fe, D = C) : X = X.next = fe, He.lanes |= ne, Di |= ne;
          fe = ee.action, Ca && d(C, fe), C = ee.hasEagerState ? ee.eagerState : d(C, fe);
        } else
          ne = {
            lane: fe,
            revertLane: ee.revertLane,
            action: ee.action,
            hasEagerState: ee.hasEagerState,
            eagerState: ee.eagerState,
            next: null
          }, X === null ? ($ = X = ne, D = C) : X = X.next = ne, He.lanes |= fe, Di |= fe;
        ee = ee.next;
      } while (ee !== null && ee !== l);
      if (X === null ? D = C : X.next = $, !Yn(C, i.memoizedState) && (Jt = !0, ue && (d = ws, d !== null)))
        throw d;
      i.memoizedState = C, i.baseState = D, i.baseQueue = X, m.lastRenderedState = C;
    }
    return b === null && (m.lanes = 0), [i.memoizedState, m.dispatch];
  }
  function o0(i) {
    var l = Vt(), d = l.queue;
    if (d === null) throw Error(r(311));
    d.lastRenderedReducer = i;
    var m = d.dispatch, b = d.pending, C = l.memoizedState;
    if (b !== null) {
      d.pending = null;
      var D = b = b.next;
      do
        C = i(C, D.action), D = D.next;
      while (D !== b);
      Yn(C, l.memoizedState) || (Jt = !0), l.memoizedState = C, l.baseQueue === null && (l.baseState = C), d.lastRenderedState = C;
    }
    return [C, m];
  }
  function A_(i, l, d) {
    var m = He, b = Vt(), C = rt;
    if (C) {
      if (d === void 0) throw Error(r(407));
      d = d();
    } else d = l();
    var D = !Yn(
      (ft || b).memoizedState,
      d
    );
    D && (b.memoizedState = d, Jt = !0), b = b.queue;
    var $ = O_.bind(null, m, b, i);
    if (ku(2048, 8, $, [i]), b.getSnapshot !== l || D || Ht !== null && Ht.memoizedState.tag & 1) {
      if (m.flags |= 2048, Cs(
        9,
        ud(),
        M_.bind(
          null,
          m,
          b,
          d,
          l
        ),
        null
      ), xt === null) throw Error(r(349));
      C || (ki & 124) !== 0 || R_(m, l, d);
    }
    return d;
  }
  function R_(i, l, d) {
    i.flags |= 16384, i = { getSnapshot: l, value: d }, l = He.updateQueue, l === null ? (l = t0(), He.updateQueue = l, l.stores = [i]) : (d = l.stores, d === null ? l.stores = [i] : d.push(i));
  }
  function M_(i, l, d, m) {
    l.value = d, l.getSnapshot = m, N_(l) && D_(i);
  }
  function O_(i, l, d) {
    return d(function() {
      N_(l) && D_(i);
    });
  }
  function N_(i) {
    var l = i.getSnapshot;
    i = i.value;
    try {
      var d = l();
      return !Yn(i, d);
    } catch {
      return !0;
    }
  }
  function D_(i) {
    var l = gs(i, 2);
    l !== null && Jn(l, i, 2);
  }
  function i0(i) {
    var l = Dn();
    if (typeof i == "function") {
      var d = i;
      if (i = d(), Ca) {
        Ce(!0);
        try {
          d();
        } finally {
          Ce(!1);
        }
      }
    }
    return l.memoizedState = l.baseState = i, l.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: zo,
      lastRenderedState: i
    }, l;
  }
  function P_(i, l, d, m) {
    return i.baseState = d, r0(
      i,
      ft,
      typeof m == "function" ? m : zo
    );
  }
  function eI(i, l, d, m, b) {
    if (fd(i)) throw Error(r(485));
    if (i = l.action, i !== null) {
      var C = {
        payload: b,
        action: i,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(D) {
          C.listeners.push(D);
        }
      };
      I.T !== null ? d(!0) : C.isTransition = !1, m(C), d = l.pending, d === null ? (C.next = l.pending = C, j_(l, C)) : (C.next = d.next, l.pending = d.next = C);
    }
  }
  function j_(i, l) {
    var d = l.action, m = l.payload, b = i.state;
    if (l.isTransition) {
      var C = I.T, D = {};
      I.T = D;
      try {
        var $ = d(b, m), X = I.S;
        X !== null && X(D, $), I_(i, l, $);
      } catch (ee) {
        a0(i, l, ee);
      } finally {
        I.T = C;
      }
    } else
      try {
        C = d(b, m), I_(i, l, C);
      } catch (ee) {
        a0(i, l, ee);
      }
  }
  function I_(i, l, d) {
    d !== null && typeof d == "object" && typeof d.then == "function" ? d.then(
      function(m) {
        z_(i, l, m);
      },
      function(m) {
        return a0(i, l, m);
      }
    ) : z_(i, l, d);
  }
  function z_(i, l, d) {
    l.status = "fulfilled", l.value = d, L_(l), i.state = d, l = i.pending, l !== null && (d = l.next, d === l ? i.pending = null : (d = d.next, l.next = d, j_(i, d)));
  }
  function a0(i, l, d) {
    var m = i.pending;
    if (i.pending = null, m !== null) {
      m = m.next;
      do
        l.status = "rejected", l.reason = d, L_(l), l = l.next;
      while (l !== m);
    }
    i.action = null;
  }
  function L_(i) {
    i = i.listeners;
    for (var l = 0; l < i.length; l++) (0, i[l])();
  }
  function F_(i, l) {
    return l;
  }
  function $_(i, l) {
    if (rt) {
      var d = xt.formState;
      if (d !== null) {
        e: {
          var m = He;
          if (rt) {
            if (Mt) {
              t: {
                for (var b = Mt, C = Yr; b.nodeType !== 8; ) {
                  if (!C) {
                    b = null;
                    break t;
                  }
                  if (b = Nr(
                    b.nextSibling
                  ), b === null) {
                    b = null;
                    break t;
                  }
                }
                C = b.data, b = C === "F!" || C === "F" ? b : null;
              }
              if (b) {
                Mt = Nr(
                  b.nextSibling
                ), m = b.data === "F!";
                break e;
              }
            }
            wa(m);
          }
          m = !1;
        }
        m && (l = d[0]);
      }
    }
    return d = Dn(), d.memoizedState = d.baseState = l, m = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: F_,
      lastRenderedState: l
    }, d.queue = m, d = iS.bind(
      null,
      He,
      m
    ), m.dispatch = d, m = i0(!1), C = f0.bind(
      null,
      He,
      !1,
      m.queue
    ), m = Dn(), b = {
      state: l,
      dispatch: null,
      action: i,
      pending: null
    }, m.queue = b, d = eI.bind(
      null,
      He,
      b,
      C,
      d
    ), b.dispatch = d, m.memoizedState = i, [l, d, !1];
  }
  function B_(i) {
    var l = Vt();
    return H_(l, ft, i);
  }
  function H_(i, l, d) {
    if (l = r0(
      i,
      l,
      F_
    )[0], i = ld(zo)[0], typeof l == "object" && l !== null && typeof l.then == "function")
      try {
        var m = Cu(l);
      } catch (D) {
        throw D === bu ? nd : D;
      }
    else m = l;
    l = Vt();
    var b = l.queue, C = b.dispatch;
    return d !== l.memoizedState && (He.flags |= 2048, Cs(
      9,
      ud(),
      tI.bind(null, b, d),
      null
    )), [m, C, i];
  }
  function tI(i, l) {
    i.action = l;
  }
  function V_(i) {
    var l = Vt(), d = ft;
    if (d !== null)
      return H_(l, d, i);
    Vt(), l = l.memoizedState, d = Vt();
    var m = d.queue.dispatch;
    return d.memoizedState = i, [l, m, !1];
  }
  function Cs(i, l, d, m) {
    return i = { tag: i, create: d, deps: m, inst: l, next: null }, l = He.updateQueue, l === null && (l = t0(), He.updateQueue = l), d = l.lastEffect, d === null ? l.lastEffect = i.next = i : (m = d.next, d.next = i, i.next = m, l.lastEffect = i), i;
  }
  function ud() {
    return { destroy: void 0, resource: void 0 };
  }
  function U_() {
    return Vt().memoizedState;
  }
  function cd(i, l, d, m) {
    var b = Dn();
    m = m === void 0 ? null : m, He.flags |= i, b.memoizedState = Cs(
      1 | l,
      ud(),
      d,
      m
    );
  }
  function ku(i, l, d, m) {
    var b = Vt();
    m = m === void 0 ? null : m;
    var C = b.memoizedState.inst;
    ft !== null && m !== null && Kg(m, ft.memoizedState.deps) ? b.memoizedState = Cs(l, C, d, m) : (He.flags |= i, b.memoizedState = Cs(
      1 | l,
      C,
      d,
      m
    ));
  }
  function q_(i, l) {
    cd(8390656, 8, i, l);
  }
  function G_(i, l) {
    ku(2048, 8, i, l);
  }
  function Y_(i, l) {
    return ku(4, 2, i, l);
  }
  function W_(i, l) {
    return ku(4, 4, i, l);
  }
  function X_(i, l) {
    if (typeof l == "function") {
      i = i();
      var d = l(i);
      return function() {
        typeof d == "function" ? d() : l(null);
      };
    }
    if (l != null)
      return i = i(), l.current = i, function() {
        l.current = null;
      };
  }
  function K_(i, l, d) {
    d = d != null ? d.concat([i]) : null, ku(4, 4, X_.bind(null, l, i), d);
  }
  function s0() {
  }
  function Z_(i, l) {
    var d = Vt();
    l = l === void 0 ? null : l;
    var m = d.memoizedState;
    return l !== null && Kg(l, m[1]) ? m[0] : (d.memoizedState = [i, l], i);
  }
  function Q_(i, l) {
    var d = Vt();
    l = l === void 0 ? null : l;
    var m = d.memoizedState;
    if (l !== null && Kg(l, m[1]))
      return m[0];
    if (m = i(), Ca) {
      Ce(!0);
      try {
        i();
      } finally {
        Ce(!1);
      }
    }
    return d.memoizedState = [m, l], m;
  }
  function l0(i, l, d) {
    return d === void 0 || (ki & 1073741824) !== 0 ? i.memoizedState = l : (i.memoizedState = d, i = tE(), He.lanes |= i, Di |= i, d);
  }
  function J_(i, l, d, m) {
    return Yn(d, l) ? d : _s.current !== null ? (i = l0(i, d, m), Yn(i, l) || (Jt = !0), i) : (ki & 42) === 0 ? (Jt = !0, i.memoizedState = d) : (i = tE(), He.lanes |= i, Di |= i, l);
  }
  function eS(i, l, d, m, b) {
    var C = H.p;
    H.p = C !== 0 && 8 > C ? C : 8;
    var D = I.T, $ = {};
    I.T = $, f0(i, !1, l, d);
    try {
      var X = b(), ee = I.S;
      if (ee !== null && ee($, X), X !== null && typeof X == "object" && typeof X.then == "function") {
        var ue = Zj(
          X,
          m
        );
        Tu(
          i,
          l,
          ue,
          Qn(i)
        );
      } else
        Tu(
          i,
          l,
          m,
          Qn(i)
        );
    } catch (fe) {
      Tu(
        i,
        l,
        { then: function() {
        }, status: "rejected", reason: fe },
        Qn()
      );
    } finally {
      H.p = C, I.T = D;
    }
  }
  function nI() {
  }
  function u0(i, l, d, m) {
    if (i.tag !== 5) throw Error(r(476));
    var b = tS(i).queue;
    eS(
      i,
      b,
      l,
      q,
      d === null ? nI : function() {
        return nS(i), d(m);
      }
    );
  }
  function tS(i) {
    var l = i.memoizedState;
    if (l !== null) return l;
    l = {
      memoizedState: q,
      baseState: q,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: zo,
        lastRenderedState: q
      },
      next: null
    };
    var d = {};
    return l.next = {
      memoizedState: d,
      baseState: d,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: zo,
        lastRenderedState: d
      },
      next: null
    }, i.memoizedState = l, i = i.alternate, i !== null && (i.memoizedState = l), l;
  }
  function nS(i) {
    var l = tS(i).next.queue;
    Tu(i, l, {}, Qn());
  }
  function c0() {
    return hn(qu);
  }
  function rS() {
    return Vt().memoizedState;
  }
  function oS() {
    return Vt().memoizedState;
  }
  function rI(i) {
    for (var l = i.return; l !== null; ) {
      switch (l.tag) {
        case 24:
        case 3:
          var d = Qn();
          i = Ei(d);
          var m = Ci(l, i, d);
          m !== null && (Jn(m, l, d), wu(m, l, d)), l = { cache: $g() }, i.payload = l;
          return;
      }
      l = l.return;
    }
  }
  function oI(i, l, d) {
    var m = Qn();
    d = {
      lane: m,
      revertLane: 0,
      action: d,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, fd(i) ? aS(l, d) : (d = Mg(i, l, d, m), d !== null && (Jn(d, i, m), sS(d, l, m)));
  }
  function iS(i, l, d) {
    var m = Qn();
    Tu(i, l, d, m);
  }
  function Tu(i, l, d, m) {
    var b = {
      lane: m,
      revertLane: 0,
      action: d,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (fd(i)) aS(l, b);
    else {
      var C = i.alternate;
      if (i.lanes === 0 && (C === null || C.lanes === 0) && (C = l.lastRenderedReducer, C !== null))
        try {
          var D = l.lastRenderedState, $ = C(D, d);
          if (b.hasEagerState = !0, b.eagerState = $, Yn($, D))
            return Wf(i, l, b, 0), xt === null && Yf(), !1;
        } catch {
        } finally {
        }
      if (d = Mg(i, l, b, m), d !== null)
        return Jn(d, i, m), sS(d, l, m), !0;
    }
    return !1;
  }
  function f0(i, l, d, m) {
    if (m = {
      lane: 2,
      revertLane: V0(),
      action: m,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, fd(i)) {
      if (l) throw Error(r(479));
    } else
      l = Mg(
        i,
        d,
        m,
        2
      ), l !== null && Jn(l, i, 2);
  }
  function fd(i) {
    var l = i.alternate;
    return i === He || l !== null && l === He;
  }
  function aS(i, l) {
    Ss = id = !0;
    var d = i.pending;
    d === null ? l.next = l : (l.next = d.next, d.next = l), i.pending = l;
  }
  function sS(i, l, d) {
    if ((d & 4194048) !== 0) {
      var m = l.lanes;
      m &= i.pendingLanes, d |= m, l.lanes = d, Yl(i, d);
    }
  }
  var dd = {
    readContext: hn,
    use: sd,
    useCallback: jt,
    useContext: jt,
    useEffect: jt,
    useImperativeHandle: jt,
    useLayoutEffect: jt,
    useInsertionEffect: jt,
    useMemo: jt,
    useReducer: jt,
    useRef: jt,
    useState: jt,
    useDebugValue: jt,
    useDeferredValue: jt,
    useTransition: jt,
    useSyncExternalStore: jt,
    useId: jt,
    useHostTransitionStatus: jt,
    useFormState: jt,
    useActionState: jt,
    useOptimistic: jt,
    useMemoCache: jt,
    useCacheRefresh: jt
  }, lS = {
    readContext: hn,
    use: sd,
    useCallback: function(i, l) {
      return Dn().memoizedState = [
        i,
        l === void 0 ? null : l
      ], i;
    },
    useContext: hn,
    useEffect: q_,
    useImperativeHandle: function(i, l, d) {
      d = d != null ? d.concat([i]) : null, cd(
        4194308,
        4,
        X_.bind(null, l, i),
        d
      );
    },
    useLayoutEffect: function(i, l) {
      return cd(4194308, 4, i, l);
    },
    useInsertionEffect: function(i, l) {
      cd(4, 2, i, l);
    },
    useMemo: function(i, l) {
      var d = Dn();
      l = l === void 0 ? null : l;
      var m = i();
      if (Ca) {
        Ce(!0);
        try {
          i();
        } finally {
          Ce(!1);
        }
      }
      return d.memoizedState = [m, l], m;
    },
    useReducer: function(i, l, d) {
      var m = Dn();
      if (d !== void 0) {
        var b = d(l);
        if (Ca) {
          Ce(!0);
          try {
            d(l);
          } finally {
            Ce(!1);
          }
        }
      } else b = l;
      return m.memoizedState = m.baseState = b, i = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: i,
        lastRenderedState: b
      }, m.queue = i, i = i.dispatch = oI.bind(
        null,
        He,
        i
      ), [m.memoizedState, i];
    },
    useRef: function(i) {
      var l = Dn();
      return i = { current: i }, l.memoizedState = i;
    },
    useState: function(i) {
      i = i0(i);
      var l = i.queue, d = iS.bind(null, He, l);
      return l.dispatch = d, [i.memoizedState, d];
    },
    useDebugValue: s0,
    useDeferredValue: function(i, l) {
      var d = Dn();
      return l0(d, i, l);
    },
    useTransition: function() {
      var i = i0(!1);
      return i = eS.bind(
        null,
        He,
        i.queue,
        !0,
        !1
      ), Dn().memoizedState = i, [!1, i];
    },
    useSyncExternalStore: function(i, l, d) {
      var m = He, b = Dn();
      if (rt) {
        if (d === void 0)
          throw Error(r(407));
        d = d();
      } else {
        if (d = l(), xt === null)
          throw Error(r(349));
        (Ze & 124) !== 0 || R_(m, l, d);
      }
      b.memoizedState = d;
      var C = { value: d, getSnapshot: l };
      return b.queue = C, q_(O_.bind(null, m, C, i), [
        i
      ]), m.flags |= 2048, Cs(
        9,
        ud(),
        M_.bind(
          null,
          m,
          C,
          d,
          l
        ),
        null
      ), d;
    },
    useId: function() {
      var i = Dn(), l = xt.identifierPrefix;
      if (rt) {
        var d = Po, m = Do;
        d = (m & ~(1 << 32 - De(m) - 1)).toString(32) + d, l = "" + l + "R" + d, d = ad++, 0 < d && (l += "H" + d.toString(32)), l += "";
      } else
        d = Qj++, l = "" + l + "r" + d.toString(32) + "";
      return i.memoizedState = l;
    },
    useHostTransitionStatus: c0,
    useFormState: $_,
    useActionState: $_,
    useOptimistic: function(i) {
      var l = Dn();
      l.memoizedState = l.baseState = i;
      var d = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return l.queue = d, l = f0.bind(
        null,
        He,
        !0,
        d
      ), d.dispatch = l, [i, l];
    },
    useMemoCache: n0,
    useCacheRefresh: function() {
      return Dn().memoizedState = rI.bind(
        null,
        He
      );
    }
  }, uS = {
    readContext: hn,
    use: sd,
    useCallback: Z_,
    useContext: hn,
    useEffect: G_,
    useImperativeHandle: K_,
    useInsertionEffect: Y_,
    useLayoutEffect: W_,
    useMemo: Q_,
    useReducer: ld,
    useRef: U_,
    useState: function() {
      return ld(zo);
    },
    useDebugValue: s0,
    useDeferredValue: function(i, l) {
      var d = Vt();
      return J_(
        d,
        ft.memoizedState,
        i,
        l
      );
    },
    useTransition: function() {
      var i = ld(zo)[0], l = Vt().memoizedState;
      return [
        typeof i == "boolean" ? i : Cu(i),
        l
      ];
    },
    useSyncExternalStore: A_,
    useId: rS,
    useHostTransitionStatus: c0,
    useFormState: B_,
    useActionState: B_,
    useOptimistic: function(i, l) {
      var d = Vt();
      return P_(d, ft, i, l);
    },
    useMemoCache: n0,
    useCacheRefresh: oS
  }, iI = {
    readContext: hn,
    use: sd,
    useCallback: Z_,
    useContext: hn,
    useEffect: G_,
    useImperativeHandle: K_,
    useInsertionEffect: Y_,
    useLayoutEffect: W_,
    useMemo: Q_,
    useReducer: o0,
    useRef: U_,
    useState: function() {
      return o0(zo);
    },
    useDebugValue: s0,
    useDeferredValue: function(i, l) {
      var d = Vt();
      return ft === null ? l0(d, i, l) : J_(
        d,
        ft.memoizedState,
        i,
        l
      );
    },
    useTransition: function() {
      var i = o0(zo)[0], l = Vt().memoizedState;
      return [
        typeof i == "boolean" ? i : Cu(i),
        l
      ];
    },
    useSyncExternalStore: A_,
    useId: rS,
    useHostTransitionStatus: c0,
    useFormState: V_,
    useActionState: V_,
    useOptimistic: function(i, l) {
      var d = Vt();
      return ft !== null ? P_(d, ft, i, l) : (d.baseState = i, [i, d.queue.dispatch]);
    },
    useMemoCache: n0,
    useCacheRefresh: oS
  }, ks = null, Au = 0;
  function hd(i) {
    var l = Au;
    return Au += 1, ks === null && (ks = []), x_(ks, i, l);
  }
  function Ru(i, l) {
    l = l.props.ref, i.ref = l !== void 0 ? l : null;
  }
  function pd(i, l) {
    throw l.$$typeof === p ? Error(r(525)) : (i = Object.prototype.toString.call(l), Error(
      r(
        31,
        i === "[object Object]" ? "object with keys {" + Object.keys(l).join(", ") + "}" : i
      )
    ));
  }
  function cS(i) {
    var l = i._init;
    return l(i._payload);
  }
  function fS(i) {
    function l(Q, K) {
      if (i) {
        var J = Q.deletions;
        J === null ? (Q.deletions = [K], Q.flags |= 16) : J.push(K);
      }
    }
    function d(Q, K) {
      if (!i) return null;
      for (; K !== null; )
        l(Q, K), K = K.sibling;
      return null;
    }
    function m(Q) {
      for (var K = /* @__PURE__ */ new Map(); Q !== null; )
        Q.key !== null ? K.set(Q.key, Q) : K.set(Q.index, Q), Q = Q.sibling;
      return K;
    }
    function b(Q, K) {
      return Q = No(Q, K), Q.index = 0, Q.sibling = null, Q;
    }
    function C(Q, K, J) {
      return Q.index = J, i ? (J = Q.alternate, J !== null ? (J = J.index, J < K ? (Q.flags |= 67108866, K) : J) : (Q.flags |= 67108866, K)) : (Q.flags |= 1048576, K);
    }
    function D(Q) {
      return i && Q.alternate === null && (Q.flags |= 67108866), Q;
    }
    function $(Q, K, J, ce) {
      return K === null || K.tag !== 6 ? (K = Ng(J, Q.mode, ce), K.return = Q, K) : (K = b(K, J), K.return = Q, K);
    }
    function X(Q, K, J, ce) {
      var be = J.type;
      return be === w ? ue(
        Q,
        K,
        J.props.children,
        ce,
        J.key
      ) : K !== null && (K.elementType === be || typeof be == "object" && be !== null && be.$$typeof === z && cS(be) === K.type) ? (K = b(K, J.props), Ru(K, J), K.return = Q, K) : (K = Kf(
        J.type,
        J.key,
        J.props,
        null,
        Q.mode,
        ce
      ), Ru(K, J), K.return = Q, K);
    }
    function ee(Q, K, J, ce) {
      return K === null || K.tag !== 4 || K.stateNode.containerInfo !== J.containerInfo || K.stateNode.implementation !== J.implementation ? (K = Dg(J, Q.mode, ce), K.return = Q, K) : (K = b(K, J.children || []), K.return = Q, K);
    }
    function ue(Q, K, J, ce, be) {
      return K === null || K.tag !== 7 ? (K = ya(
        J,
        Q.mode,
        ce,
        be
      ), K.return = Q, K) : (K = b(K, J), K.return = Q, K);
    }
    function fe(Q, K, J) {
      if (typeof K == "string" && K !== "" || typeof K == "number" || typeof K == "bigint")
        return K = Ng(
          "" + K,
          Q.mode,
          J
        ), K.return = Q, K;
      if (typeof K == "object" && K !== null) {
        switch (K.$$typeof) {
          case g:
            return J = Kf(
              K.type,
              K.key,
              K.props,
              null,
              Q.mode,
              J
            ), Ru(J, K), J.return = Q, J;
          case y:
            return K = Dg(
              K,
              Q.mode,
              J
            ), K.return = Q, K;
          case z:
            var ce = K._init;
            return K = ce(K._payload), fe(Q, K, J);
        }
        if (V(K) || U(K))
          return K = ya(
            K,
            Q.mode,
            J,
            null
          ), K.return = Q, K;
        if (typeof K.then == "function")
          return fe(Q, hd(K), J);
        if (K.$$typeof === k)
          return fe(
            Q,
            ed(Q, K),
            J
          );
        pd(Q, K);
      }
      return null;
    }
    function ne(Q, K, J, ce) {
      var be = K !== null ? K.key : null;
      if (typeof J == "string" && J !== "" || typeof J == "number" || typeof J == "bigint")
        return be !== null ? null : $(Q, K, "" + J, ce);
      if (typeof J == "object" && J !== null) {
        switch (J.$$typeof) {
          case g:
            return J.key === be ? X(Q, K, J, ce) : null;
          case y:
            return J.key === be ? ee(Q, K, J, ce) : null;
          case z:
            return be = J._init, J = be(J._payload), ne(Q, K, J, ce);
        }
        if (V(J) || U(J))
          return be !== null ? null : ue(Q, K, J, ce, null);
        if (typeof J.then == "function")
          return ne(
            Q,
            K,
            hd(J),
            ce
          );
        if (J.$$typeof === k)
          return ne(
            Q,
            K,
            ed(Q, J),
            ce
          );
        pd(Q, J);
      }
      return null;
    }
    function re(Q, K, J, ce, be) {
      if (typeof ce == "string" && ce !== "" || typeof ce == "number" || typeof ce == "bigint")
        return Q = Q.get(J) || null, $(K, Q, "" + ce, be);
      if (typeof ce == "object" && ce !== null) {
        switch (ce.$$typeof) {
          case g:
            return Q = Q.get(
              ce.key === null ? J : ce.key
            ) || null, X(K, Q, ce, be);
          case y:
            return Q = Q.get(
              ce.key === null ? J : ce.key
            ) || null, ee(K, Q, ce, be);
          case z:
            var Ue = ce._init;
            return ce = Ue(ce._payload), re(
              Q,
              K,
              J,
              ce,
              be
            );
        }
        if (V(ce) || U(ce))
          return Q = Q.get(J) || null, ue(K, Q, ce, be, null);
        if (typeof ce.then == "function")
          return re(
            Q,
            K,
            J,
            hd(ce),
            be
          );
        if (ce.$$typeof === k)
          return re(
            Q,
            K,
            J,
            ed(K, ce),
            be
          );
        pd(K, ce);
      }
      return null;
    }
    function Le(Q, K, J, ce) {
      for (var be = null, Ue = null, Se = K, Ie = K = 0, tn = null; Se !== null && Ie < J.length; Ie++) {
        Se.index > Ie ? (tn = Se, Se = null) : tn = Se.sibling;
        var tt = ne(
          Q,
          Se,
          J[Ie],
          ce
        );
        if (tt === null) {
          Se === null && (Se = tn);
          break;
        }
        i && Se && tt.alternate === null && l(Q, Se), K = C(tt, K, Ie), Ue === null ? be = tt : Ue.sibling = tt, Ue = tt, Se = tn;
      }
      if (Ie === J.length)
        return d(Q, Se), rt && ba(Q, Ie), be;
      if (Se === null) {
        for (; Ie < J.length; Ie++)
          Se = fe(Q, J[Ie], ce), Se !== null && (K = C(
            Se,
            K,
            Ie
          ), Ue === null ? be = Se : Ue.sibling = Se, Ue = Se);
        return rt && ba(Q, Ie), be;
      }
      for (Se = m(Se); Ie < J.length; Ie++)
        tn = re(
          Se,
          Q,
          Ie,
          J[Ie],
          ce
        ), tn !== null && (i && tn.alternate !== null && Se.delete(
          tn.key === null ? Ie : tn.key
        ), K = C(
          tn,
          K,
          Ie
        ), Ue === null ? be = tn : Ue.sibling = tn, Ue = tn);
      return i && Se.forEach(function(Hi) {
        return l(Q, Hi);
      }), rt && ba(Q, Ie), be;
    }
    function Pe(Q, K, J, ce) {
      if (J == null) throw Error(r(151));
      for (var be = null, Ue = null, Se = K, Ie = K = 0, tn = null, tt = J.next(); Se !== null && !tt.done; Ie++, tt = J.next()) {
        Se.index > Ie ? (tn = Se, Se = null) : tn = Se.sibling;
        var Hi = ne(Q, Se, tt.value, ce);
        if (Hi === null) {
          Se === null && (Se = tn);
          break;
        }
        i && Se && Hi.alternate === null && l(Q, Se), K = C(Hi, K, Ie), Ue === null ? be = Hi : Ue.sibling = Hi, Ue = Hi, Se = tn;
      }
      if (tt.done)
        return d(Q, Se), rt && ba(Q, Ie), be;
      if (Se === null) {
        for (; !tt.done; Ie++, tt = J.next())
          tt = fe(Q, tt.value, ce), tt !== null && (K = C(tt, K, Ie), Ue === null ? be = tt : Ue.sibling = tt, Ue = tt);
        return rt && ba(Q, Ie), be;
      }
      for (Se = m(Se); !tt.done; Ie++, tt = J.next())
        tt = re(Se, Q, Ie, tt.value, ce), tt !== null && (i && tt.alternate !== null && Se.delete(tt.key === null ? Ie : tt.key), K = C(tt, K, Ie), Ue === null ? be = tt : Ue.sibling = tt, Ue = tt);
      return i && Se.forEach(function(a6) {
        return l(Q, a6);
      }), rt && ba(Q, Ie), be;
    }
    function ht(Q, K, J, ce) {
      if (typeof J == "object" && J !== null && J.type === w && J.key === null && (J = J.props.children), typeof J == "object" && J !== null) {
        switch (J.$$typeof) {
          case g:
            e: {
              for (var be = J.key; K !== null; ) {
                if (K.key === be) {
                  if (be = J.type, be === w) {
                    if (K.tag === 7) {
                      d(
                        Q,
                        K.sibling
                      ), ce = b(
                        K,
                        J.props.children
                      ), ce.return = Q, Q = ce;
                      break e;
                    }
                  } else if (K.elementType === be || typeof be == "object" && be !== null && be.$$typeof === z && cS(be) === K.type) {
                    d(
                      Q,
                      K.sibling
                    ), ce = b(K, J.props), Ru(ce, J), ce.return = Q, Q = ce;
                    break e;
                  }
                  d(Q, K);
                  break;
                } else l(Q, K);
                K = K.sibling;
              }
              J.type === w ? (ce = ya(
                J.props.children,
                Q.mode,
                ce,
                J.key
              ), ce.return = Q, Q = ce) : (ce = Kf(
                J.type,
                J.key,
                J.props,
                null,
                Q.mode,
                ce
              ), Ru(ce, J), ce.return = Q, Q = ce);
            }
            return D(Q);
          case y:
            e: {
              for (be = J.key; K !== null; ) {
                if (K.key === be)
                  if (K.tag === 4 && K.stateNode.containerInfo === J.containerInfo && K.stateNode.implementation === J.implementation) {
                    d(
                      Q,
                      K.sibling
                    ), ce = b(K, J.children || []), ce.return = Q, Q = ce;
                    break e;
                  } else {
                    d(Q, K);
                    break;
                  }
                else l(Q, K);
                K = K.sibling;
              }
              ce = Dg(J, Q.mode, ce), ce.return = Q, Q = ce;
            }
            return D(Q);
          case z:
            return be = J._init, J = be(J._payload), ht(
              Q,
              K,
              J,
              ce
            );
        }
        if (V(J))
          return Le(
            Q,
            K,
            J,
            ce
          );
        if (U(J)) {
          if (be = U(J), typeof be != "function") throw Error(r(150));
          return J = be.call(J), Pe(
            Q,
            K,
            J,
            ce
          );
        }
        if (typeof J.then == "function")
          return ht(
            Q,
            K,
            hd(J),
            ce
          );
        if (J.$$typeof === k)
          return ht(
            Q,
            K,
            ed(Q, J),
            ce
          );
        pd(Q, J);
      }
      return typeof J == "string" && J !== "" || typeof J == "number" || typeof J == "bigint" ? (J = "" + J, K !== null && K.tag === 6 ? (d(Q, K.sibling), ce = b(K, J), ce.return = Q, Q = ce) : (d(Q, K), ce = Ng(J, Q.mode, ce), ce.return = Q, Q = ce), D(Q)) : d(Q, K);
    }
    return function(Q, K, J, ce) {
      try {
        Au = 0;
        var be = ht(
          Q,
          K,
          J,
          ce
        );
        return ks = null, be;
      } catch (Se) {
        if (Se === bu || Se === nd) throw Se;
        var Ue = Wn(29, Se, null, Q.mode);
        return Ue.lanes = ce, Ue.return = Q, Ue;
      } finally {
      }
    };
  }
  var Ts = fS(!0), dS = fS(!1), yr = Y(null), Wr = null;
  function Ti(i) {
    var l = i.alternate;
    L(Kt, Kt.current & 1), L(yr, i), Wr === null && (l === null || _s.current !== null || l.memoizedState !== null) && (Wr = i);
  }
  function hS(i) {
    if (i.tag === 22) {
      if (L(Kt, Kt.current), L(yr, i), Wr === null) {
        var l = i.alternate;
        l !== null && l.memoizedState !== null && (Wr = i);
      }
    } else Ai();
  }
  function Ai() {
    L(Kt, Kt.current), L(yr, yr.current);
  }
  function Lo(i) {
    Z(yr), Wr === i && (Wr = null), Z(Kt);
  }
  var Kt = Y(0);
  function md(i) {
    for (var l = i; l !== null; ) {
      if (l.tag === 13) {
        var d = l.memoizedState;
        if (d !== null && (d = d.dehydrated, d === null || d.data === "$?" || ty(d)))
          return l;
      } else if (l.tag === 19 && l.memoizedProps.revealOrder !== void 0) {
        if ((l.flags & 128) !== 0) return l;
      } else if (l.child !== null) {
        l.child.return = l, l = l.child;
        continue;
      }
      if (l === i) break;
      for (; l.sibling === null; ) {
        if (l.return === null || l.return === i) return null;
        l = l.return;
      }
      l.sibling.return = l.return, l = l.sibling;
    }
    return null;
  }
  function d0(i, l, d, m) {
    l = i.memoizedState, d = d(m, l), d = d == null ? l : h({}, l, d), i.memoizedState = d, i.lanes === 0 && (i.updateQueue.baseState = d);
  }
  var h0 = {
    enqueueSetState: function(i, l, d) {
      i = i._reactInternals;
      var m = Qn(), b = Ei(m);
      b.payload = l, d != null && (b.callback = d), l = Ci(i, b, m), l !== null && (Jn(l, i, m), wu(l, i, m));
    },
    enqueueReplaceState: function(i, l, d) {
      i = i._reactInternals;
      var m = Qn(), b = Ei(m);
      b.tag = 1, b.payload = l, d != null && (b.callback = d), l = Ci(i, b, m), l !== null && (Jn(l, i, m), wu(l, i, m));
    },
    enqueueForceUpdate: function(i, l) {
      i = i._reactInternals;
      var d = Qn(), m = Ei(d);
      m.tag = 2, l != null && (m.callback = l), l = Ci(i, m, d), l !== null && (Jn(l, i, d), wu(l, i, d));
    }
  };
  function pS(i, l, d, m, b, C, D) {
    return i = i.stateNode, typeof i.shouldComponentUpdate == "function" ? i.shouldComponentUpdate(m, C, D) : l.prototype && l.prototype.isPureReactComponent ? !fu(d, m) || !fu(b, C) : !0;
  }
  function mS(i, l, d, m) {
    i = l.state, typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps(d, m), typeof l.UNSAFE_componentWillReceiveProps == "function" && l.UNSAFE_componentWillReceiveProps(d, m), l.state !== i && h0.enqueueReplaceState(l, l.state, null);
  }
  function ka(i, l) {
    var d = l;
    if ("ref" in l) {
      d = {};
      for (var m in l)
        m !== "ref" && (d[m] = l[m]);
    }
    if (i = i.defaultProps) {
      d === l && (d = h({}, d));
      for (var b in i)
        d[b] === void 0 && (d[b] = i[b]);
    }
    return d;
  }
  var gd = typeof reportError == "function" ? reportError : function(i) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var l = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof i == "object" && i !== null && typeof i.message == "string" ? String(i.message) : String(i),
        error: i
      });
      if (!window.dispatchEvent(l)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", i);
      return;
    }
    console.error(i);
  };
  function gS(i) {
    gd(i);
  }
  function yS(i) {
    console.error(i);
  }
  function vS(i) {
    gd(i);
  }
  function yd(i, l) {
    try {
      var d = i.onUncaughtError;
      d(l.value, { componentStack: l.stack });
    } catch (m) {
      setTimeout(function() {
        throw m;
      });
    }
  }
  function bS(i, l, d) {
    try {
      var m = i.onCaughtError;
      m(d.value, {
        componentStack: d.stack,
        errorBoundary: l.tag === 1 ? l.stateNode : null
      });
    } catch (b) {
      setTimeout(function() {
        throw b;
      });
    }
  }
  function p0(i, l, d) {
    return d = Ei(d), d.tag = 3, d.payload = { element: null }, d.callback = function() {
      yd(i, l);
    }, d;
  }
  function xS(i) {
    return i = Ei(i), i.tag = 3, i;
  }
  function wS(i, l, d, m) {
    var b = d.type.getDerivedStateFromError;
    if (typeof b == "function") {
      var C = m.value;
      i.payload = function() {
        return b(C);
      }, i.callback = function() {
        bS(l, d, m);
      };
    }
    var D = d.stateNode;
    D !== null && typeof D.componentDidCatch == "function" && (i.callback = function() {
      bS(l, d, m), typeof b != "function" && (Pi === null ? Pi = /* @__PURE__ */ new Set([this]) : Pi.add(this));
      var $ = m.stack;
      this.componentDidCatch(m.value, {
        componentStack: $ !== null ? $ : ""
      });
    });
  }
  function aI(i, l, d, m, b) {
    if (d.flags |= 32768, m !== null && typeof m == "object" && typeof m.then == "function") {
      if (l = d.alternate, l !== null && gu(
        l,
        d,
        b,
        !0
      ), d = yr.current, d !== null) {
        switch (d.tag) {
          case 13:
            return Wr === null ? L0() : d.alternate === null && Ot === 0 && (Ot = 3), d.flags &= -257, d.flags |= 65536, d.lanes = b, m === Vg ? d.flags |= 16384 : (l = d.updateQueue, l === null ? d.updateQueue = /* @__PURE__ */ new Set([m]) : l.add(m), $0(i, m, b)), !1;
          case 22:
            return d.flags |= 65536, m === Vg ? d.flags |= 16384 : (l = d.updateQueue, l === null ? (l = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([m])
            }, d.updateQueue = l) : (d = l.retryQueue, d === null ? l.retryQueue = /* @__PURE__ */ new Set([m]) : d.add(m)), $0(i, m, b)), !1;
        }
        throw Error(r(435, d.tag));
      }
      return $0(i, m, b), L0(), !1;
    }
    if (rt)
      return l = yr.current, l !== null ? ((l.flags & 65536) === 0 && (l.flags |= 256), l.flags |= 65536, l.lanes = b, m !== Ig && (i = Error(r(422), { cause: m }), mu(hr(i, d)))) : (m !== Ig && (l = Error(r(423), {
        cause: m
      }), mu(
        hr(l, d)
      )), i = i.current.alternate, i.flags |= 65536, b &= -b, i.lanes |= b, m = hr(m, d), b = p0(
        i.stateNode,
        m,
        b
      ), Gg(i, b), Ot !== 4 && (Ot = 2)), !1;
    var C = Error(r(520), { cause: m });
    if (C = hr(C, d), Iu === null ? Iu = [C] : Iu.push(C), Ot !== 4 && (Ot = 2), l === null) return !0;
    m = hr(m, d), d = l;
    do {
      switch (d.tag) {
        case 3:
          return d.flags |= 65536, i = b & -b, d.lanes |= i, i = p0(d.stateNode, m, i), Gg(d, i), !1;
        case 1:
          if (l = d.type, C = d.stateNode, (d.flags & 128) === 0 && (typeof l.getDerivedStateFromError == "function" || C !== null && typeof C.componentDidCatch == "function" && (Pi === null || !Pi.has(C))))
            return d.flags |= 65536, b &= -b, d.lanes |= b, b = xS(b), wS(
              b,
              i,
              d,
              m
            ), Gg(d, b), !1;
      }
      d = d.return;
    } while (d !== null);
    return !1;
  }
  var _S = Error(r(461)), Jt = !1;
  function on(i, l, d, m) {
    l.child = i === null ? dS(l, null, d, m) : Ts(
      l,
      i.child,
      d,
      m
    );
  }
  function SS(i, l, d, m, b) {
    d = d.render;
    var C = l.ref;
    if ("ref" in m) {
      var D = {};
      for (var $ in m)
        $ !== "ref" && (D[$] = m[$]);
    } else D = m;
    return Sa(l), m = Zg(
      i,
      l,
      d,
      D,
      C,
      b
    ), $ = Qg(), i !== null && !Jt ? (Jg(i, l, b), Fo(i, l, b)) : (rt && $ && Pg(l), l.flags |= 1, on(i, l, m, b), l.child);
  }
  function ES(i, l, d, m, b) {
    if (i === null) {
      var C = d.type;
      return typeof C == "function" && !Og(C) && C.defaultProps === void 0 && d.compare === null ? (l.tag = 15, l.type = C, CS(
        i,
        l,
        C,
        m,
        b
      )) : (i = Kf(
        d.type,
        null,
        m,
        l,
        l.mode,
        b
      ), i.ref = l.ref, i.return = l, l.child = i);
    }
    if (C = i.child, !_0(i, b)) {
      var D = C.memoizedProps;
      if (d = d.compare, d = d !== null ? d : fu, d(D, m) && i.ref === l.ref)
        return Fo(i, l, b);
    }
    return l.flags |= 1, i = No(C, m), i.ref = l.ref, i.return = l, l.child = i;
  }
  function CS(i, l, d, m, b) {
    if (i !== null) {
      var C = i.memoizedProps;
      if (fu(C, m) && i.ref === l.ref)
        if (Jt = !1, l.pendingProps = m = C, _0(i, b))
          (i.flags & 131072) !== 0 && (Jt = !0);
        else
          return l.lanes = i.lanes, Fo(i, l, b);
    }
    return m0(
      i,
      l,
      d,
      m,
      b
    );
  }
  function kS(i, l, d) {
    var m = l.pendingProps, b = m.children, C = i !== null ? i.memoizedState : null;
    if (m.mode === "hidden") {
      if ((l.flags & 128) !== 0) {
        if (m = C !== null ? C.baseLanes | d : d, i !== null) {
          for (b = l.child = i.child, C = 0; b !== null; )
            C = C | b.lanes | b.childLanes, b = b.sibling;
          l.childLanes = C & ~m;
        } else l.childLanes = 0, l.child = null;
        return TS(
          i,
          l,
          m,
          d
        );
      }
      if ((d & 536870912) !== 0)
        l.memoizedState = { baseLanes: 0, cachePool: null }, i !== null && td(
          l,
          C !== null ? C.cachePool : null
        ), C !== null ? C_(l, C) : Wg(), hS(l);
      else
        return l.lanes = l.childLanes = 536870912, TS(
          i,
          l,
          C !== null ? C.baseLanes | d : d,
          d
        );
    } else
      C !== null ? (td(l, C.cachePool), C_(l, C), Ai(), l.memoizedState = null) : (i !== null && td(l, null), Wg(), Ai());
    return on(i, l, b, d), l.child;
  }
  function TS(i, l, d, m) {
    var b = Hg();
    return b = b === null ? null : { parent: Xt._currentValue, pool: b }, l.memoizedState = {
      baseLanes: d,
      cachePool: b
    }, i !== null && td(l, null), Wg(), hS(l), i !== null && gu(i, l, m, !0), null;
  }
  function vd(i, l) {
    var d = l.ref;
    if (d === null)
      i !== null && i.ref !== null && (l.flags |= 4194816);
    else {
      if (typeof d != "function" && typeof d != "object")
        throw Error(r(284));
      (i === null || i.ref !== d) && (l.flags |= 4194816);
    }
  }
  function m0(i, l, d, m, b) {
    return Sa(l), d = Zg(
      i,
      l,
      d,
      m,
      void 0,
      b
    ), m = Qg(), i !== null && !Jt ? (Jg(i, l, b), Fo(i, l, b)) : (rt && m && Pg(l), l.flags |= 1, on(i, l, d, b), l.child);
  }
  function AS(i, l, d, m, b, C) {
    return Sa(l), l.updateQueue = null, d = T_(
      l,
      m,
      d,
      b
    ), k_(i), m = Qg(), i !== null && !Jt ? (Jg(i, l, C), Fo(i, l, C)) : (rt && m && Pg(l), l.flags |= 1, on(i, l, d, C), l.child);
  }
  function RS(i, l, d, m, b) {
    if (Sa(l), l.stateNode === null) {
      var C = ys, D = d.contextType;
      typeof D == "object" && D !== null && (C = hn(D)), C = new d(m, C), l.memoizedState = C.state !== null && C.state !== void 0 ? C.state : null, C.updater = h0, l.stateNode = C, C._reactInternals = l, C = l.stateNode, C.props = m, C.state = l.memoizedState, C.refs = {}, Ug(l), D = d.contextType, C.context = typeof D == "object" && D !== null ? hn(D) : ys, C.state = l.memoizedState, D = d.getDerivedStateFromProps, typeof D == "function" && (d0(
        l,
        d,
        D,
        m
      ), C.state = l.memoizedState), typeof d.getDerivedStateFromProps == "function" || typeof C.getSnapshotBeforeUpdate == "function" || typeof C.UNSAFE_componentWillMount != "function" && typeof C.componentWillMount != "function" || (D = C.state, typeof C.componentWillMount == "function" && C.componentWillMount(), typeof C.UNSAFE_componentWillMount == "function" && C.UNSAFE_componentWillMount(), D !== C.state && h0.enqueueReplaceState(C, C.state, null), Su(l, m, C, b), _u(), C.state = l.memoizedState), typeof C.componentDidMount == "function" && (l.flags |= 4194308), m = !0;
    } else if (i === null) {
      C = l.stateNode;
      var $ = l.memoizedProps, X = ka(d, $);
      C.props = X;
      var ee = C.context, ue = d.contextType;
      D = ys, typeof ue == "object" && ue !== null && (D = hn(ue));
      var fe = d.getDerivedStateFromProps;
      ue = typeof fe == "function" || typeof C.getSnapshotBeforeUpdate == "function", $ = l.pendingProps !== $, ue || typeof C.UNSAFE_componentWillReceiveProps != "function" && typeof C.componentWillReceiveProps != "function" || ($ || ee !== D) && mS(
        l,
        C,
        m,
        D
      ), Si = !1;
      var ne = l.memoizedState;
      C.state = ne, Su(l, m, C, b), _u(), ee = l.memoizedState, $ || ne !== ee || Si ? (typeof fe == "function" && (d0(
        l,
        d,
        fe,
        m
      ), ee = l.memoizedState), (X = Si || pS(
        l,
        d,
        X,
        m,
        ne,
        ee,
        D
      )) ? (ue || typeof C.UNSAFE_componentWillMount != "function" && typeof C.componentWillMount != "function" || (typeof C.componentWillMount == "function" && C.componentWillMount(), typeof C.UNSAFE_componentWillMount == "function" && C.UNSAFE_componentWillMount()), typeof C.componentDidMount == "function" && (l.flags |= 4194308)) : (typeof C.componentDidMount == "function" && (l.flags |= 4194308), l.memoizedProps = m, l.memoizedState = ee), C.props = m, C.state = ee, C.context = D, m = X) : (typeof C.componentDidMount == "function" && (l.flags |= 4194308), m = !1);
    } else {
      C = l.stateNode, qg(i, l), D = l.memoizedProps, ue = ka(d, D), C.props = ue, fe = l.pendingProps, ne = C.context, ee = d.contextType, X = ys, typeof ee == "object" && ee !== null && (X = hn(ee)), $ = d.getDerivedStateFromProps, (ee = typeof $ == "function" || typeof C.getSnapshotBeforeUpdate == "function") || typeof C.UNSAFE_componentWillReceiveProps != "function" && typeof C.componentWillReceiveProps != "function" || (D !== fe || ne !== X) && mS(
        l,
        C,
        m,
        X
      ), Si = !1, ne = l.memoizedState, C.state = ne, Su(l, m, C, b), _u();
      var re = l.memoizedState;
      D !== fe || ne !== re || Si || i !== null && i.dependencies !== null && Jf(i.dependencies) ? (typeof $ == "function" && (d0(
        l,
        d,
        $,
        m
      ), re = l.memoizedState), (ue = Si || pS(
        l,
        d,
        ue,
        m,
        ne,
        re,
        X
      ) || i !== null && i.dependencies !== null && Jf(i.dependencies)) ? (ee || typeof C.UNSAFE_componentWillUpdate != "function" && typeof C.componentWillUpdate != "function" || (typeof C.componentWillUpdate == "function" && C.componentWillUpdate(m, re, X), typeof C.UNSAFE_componentWillUpdate == "function" && C.UNSAFE_componentWillUpdate(
        m,
        re,
        X
      )), typeof C.componentDidUpdate == "function" && (l.flags |= 4), typeof C.getSnapshotBeforeUpdate == "function" && (l.flags |= 1024)) : (typeof C.componentDidUpdate != "function" || D === i.memoizedProps && ne === i.memoizedState || (l.flags |= 4), typeof C.getSnapshotBeforeUpdate != "function" || D === i.memoizedProps && ne === i.memoizedState || (l.flags |= 1024), l.memoizedProps = m, l.memoizedState = re), C.props = m, C.state = re, C.context = X, m = ue) : (typeof C.componentDidUpdate != "function" || D === i.memoizedProps && ne === i.memoizedState || (l.flags |= 4), typeof C.getSnapshotBeforeUpdate != "function" || D === i.memoizedProps && ne === i.memoizedState || (l.flags |= 1024), m = !1);
    }
    return C = m, vd(i, l), m = (l.flags & 128) !== 0, C || m ? (C = l.stateNode, d = m && typeof d.getDerivedStateFromError != "function" ? null : C.render(), l.flags |= 1, i !== null && m ? (l.child = Ts(
      l,
      i.child,
      null,
      b
    ), l.child = Ts(
      l,
      null,
      d,
      b
    )) : on(i, l, d, b), l.memoizedState = C.state, i = l.child) : i = Fo(
      i,
      l,
      b
    ), i;
  }
  function MS(i, l, d, m) {
    return pu(), l.flags |= 256, on(i, l, d, m), l.child;
  }
  var g0 = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function y0(i) {
    return { baseLanes: i, cachePool: y_() };
  }
  function v0(i, l, d) {
    return i = i !== null ? i.childLanes & ~d : 0, l && (i |= vr), i;
  }
  function OS(i, l, d) {
    var m = l.pendingProps, b = !1, C = (l.flags & 128) !== 0, D;
    if ((D = C) || (D = i !== null && i.memoizedState === null ? !1 : (Kt.current & 2) !== 0), D && (b = !0, l.flags &= -129), D = (l.flags & 32) !== 0, l.flags &= -33, i === null) {
      if (rt) {
        if (b ? Ti(l) : Ai(), rt) {
          var $ = Mt, X;
          if (X = $) {
            e: {
              for (X = $, $ = Yr; X.nodeType !== 8; ) {
                if (!$) {
                  $ = null;
                  break e;
                }
                if (X = Nr(
                  X.nextSibling
                ), X === null) {
                  $ = null;
                  break e;
                }
              }
              $ = X;
            }
            $ !== null ? (l.memoizedState = {
              dehydrated: $,
              treeContext: va !== null ? { id: Do, overflow: Po } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, X = Wn(
              18,
              null,
              null,
              0
            ), X.stateNode = $, X.return = l, l.child = X, Sn = l, Mt = null, X = !0) : X = !1;
          }
          X || wa(l);
        }
        if ($ = l.memoizedState, $ !== null && ($ = $.dehydrated, $ !== null))
          return ty($) ? l.lanes = 32 : l.lanes = 536870912, null;
        Lo(l);
      }
      return $ = m.children, m = m.fallback, b ? (Ai(), b = l.mode, $ = bd(
        { mode: "hidden", children: $ },
        b
      ), m = ya(
        m,
        b,
        d,
        null
      ), $.return = l, m.return = l, $.sibling = m, l.child = $, b = l.child, b.memoizedState = y0(d), b.childLanes = v0(
        i,
        D,
        d
      ), l.memoizedState = g0, m) : (Ti(l), b0(l, $));
    }
    if (X = i.memoizedState, X !== null && ($ = X.dehydrated, $ !== null)) {
      if (C)
        l.flags & 256 ? (Ti(l), l.flags &= -257, l = x0(
          i,
          l,
          d
        )) : l.memoizedState !== null ? (Ai(), l.child = i.child, l.flags |= 128, l = null) : (Ai(), b = m.fallback, $ = l.mode, m = bd(
          { mode: "visible", children: m.children },
          $
        ), b = ya(
          b,
          $,
          d,
          null
        ), b.flags |= 2, m.return = l, b.return = l, m.sibling = b, l.child = m, Ts(
          l,
          i.child,
          null,
          d
        ), m = l.child, m.memoizedState = y0(d), m.childLanes = v0(
          i,
          D,
          d
        ), l.memoizedState = g0, l = b);
      else if (Ti(l), ty($)) {
        if (D = $.nextSibling && $.nextSibling.dataset, D) var ee = D.dgst;
        D = ee, m = Error(r(419)), m.stack = "", m.digest = D, mu({ value: m, source: null, stack: null }), l = x0(
          i,
          l,
          d
        );
      } else if (Jt || gu(i, l, d, !1), D = (d & i.childLanes) !== 0, Jt || D) {
        if (D = xt, D !== null && (m = d & -d, m = (m & 42) !== 0 ? 1 : Wl(m), m = (m & (D.suspendedLanes | d)) !== 0 ? 0 : m, m !== 0 && m !== X.retryLane))
          throw X.retryLane = m, gs(i, m), Jn(D, i, m), _S;
        $.data === "$?" || L0(), l = x0(
          i,
          l,
          d
        );
      } else
        $.data === "$?" ? (l.flags |= 192, l.child = i.child, l = null) : (i = X.treeContext, Mt = Nr(
          $.nextSibling
        ), Sn = l, rt = !0, xa = null, Yr = !1, i !== null && (mr[gr++] = Do, mr[gr++] = Po, mr[gr++] = va, Do = i.id, Po = i.overflow, va = l), l = b0(
          l,
          m.children
        ), l.flags |= 4096);
      return l;
    }
    return b ? (Ai(), b = m.fallback, $ = l.mode, X = i.child, ee = X.sibling, m = No(X, {
      mode: "hidden",
      children: m.children
    }), m.subtreeFlags = X.subtreeFlags & 65011712, ee !== null ? b = No(ee, b) : (b = ya(
      b,
      $,
      d,
      null
    ), b.flags |= 2), b.return = l, m.return = l, m.sibling = b, l.child = m, m = b, b = l.child, $ = i.child.memoizedState, $ === null ? $ = y0(d) : (X = $.cachePool, X !== null ? (ee = Xt._currentValue, X = X.parent !== ee ? { parent: ee, pool: ee } : X) : X = y_(), $ = {
      baseLanes: $.baseLanes | d,
      cachePool: X
    }), b.memoizedState = $, b.childLanes = v0(
      i,
      D,
      d
    ), l.memoizedState = g0, m) : (Ti(l), d = i.child, i = d.sibling, d = No(d, {
      mode: "visible",
      children: m.children
    }), d.return = l, d.sibling = null, i !== null && (D = l.deletions, D === null ? (l.deletions = [i], l.flags |= 16) : D.push(i)), l.child = d, l.memoizedState = null, d);
  }
  function b0(i, l) {
    return l = bd(
      { mode: "visible", children: l },
      i.mode
    ), l.return = i, i.child = l;
  }
  function bd(i, l) {
    return i = Wn(22, i, null, l), i.lanes = 0, i.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }, i;
  }
  function x0(i, l, d) {
    return Ts(l, i.child, null, d), i = b0(
      l,
      l.pendingProps.children
    ), i.flags |= 2, l.memoizedState = null, i;
  }
  function NS(i, l, d) {
    i.lanes |= l;
    var m = i.alternate;
    m !== null && (m.lanes |= l), Lg(i.return, l, d);
  }
  function w0(i, l, d, m, b) {
    var C = i.memoizedState;
    C === null ? i.memoizedState = {
      isBackwards: l,
      rendering: null,
      renderingStartTime: 0,
      last: m,
      tail: d,
      tailMode: b
    } : (C.isBackwards = l, C.rendering = null, C.renderingStartTime = 0, C.last = m, C.tail = d, C.tailMode = b);
  }
  function DS(i, l, d) {
    var m = l.pendingProps, b = m.revealOrder, C = m.tail;
    if (on(i, l, m.children, d), m = Kt.current, (m & 2) !== 0)
      m = m & 1 | 2, l.flags |= 128;
    else {
      if (i !== null && (i.flags & 128) !== 0)
        e: for (i = l.child; i !== null; ) {
          if (i.tag === 13)
            i.memoizedState !== null && NS(i, d, l);
          else if (i.tag === 19)
            NS(i, d, l);
          else if (i.child !== null) {
            i.child.return = i, i = i.child;
            continue;
          }
          if (i === l) break e;
          for (; i.sibling === null; ) {
            if (i.return === null || i.return === l)
              break e;
            i = i.return;
          }
          i.sibling.return = i.return, i = i.sibling;
        }
      m &= 1;
    }
    switch (L(Kt, m), b) {
      case "forwards":
        for (d = l.child, b = null; d !== null; )
          i = d.alternate, i !== null && md(i) === null && (b = d), d = d.sibling;
        d = b, d === null ? (b = l.child, l.child = null) : (b = d.sibling, d.sibling = null), w0(
          l,
          !1,
          b,
          d,
          C
        );
        break;
      case "backwards":
        for (d = null, b = l.child, l.child = null; b !== null; ) {
          if (i = b.alternate, i !== null && md(i) === null) {
            l.child = b;
            break;
          }
          i = b.sibling, b.sibling = d, d = b, b = i;
        }
        w0(
          l,
          !0,
          d,
          null,
          C
        );
        break;
      case "together":
        w0(l, !1, null, null, void 0);
        break;
      default:
        l.memoizedState = null;
    }
    return l.child;
  }
  function Fo(i, l, d) {
    if (i !== null && (l.dependencies = i.dependencies), Di |= l.lanes, (d & l.childLanes) === 0)
      if (i !== null) {
        if (gu(
          i,
          l,
          d,
          !1
        ), (d & l.childLanes) === 0)
          return null;
      } else return null;
    if (i !== null && l.child !== i.child)
      throw Error(r(153));
    if (l.child !== null) {
      for (i = l.child, d = No(i, i.pendingProps), l.child = d, d.return = l; i.sibling !== null; )
        i = i.sibling, d = d.sibling = No(i, i.pendingProps), d.return = l;
      d.sibling = null;
    }
    return l.child;
  }
  function _0(i, l) {
    return (i.lanes & l) !== 0 ? !0 : (i = i.dependencies, !!(i !== null && Jf(i)));
  }
  function sI(i, l, d) {
    switch (l.tag) {
      case 3:
        le(l, l.stateNode.containerInfo), _i(l, Xt, i.memoizedState.cache), pu();
        break;
      case 27:
      case 5:
        je(l);
        break;
      case 4:
        le(l, l.stateNode.containerInfo);
        break;
      case 10:
        _i(
          l,
          l.type,
          l.memoizedProps.value
        );
        break;
      case 13:
        var m = l.memoizedState;
        if (m !== null)
          return m.dehydrated !== null ? (Ti(l), l.flags |= 128, null) : (d & l.child.childLanes) !== 0 ? OS(i, l, d) : (Ti(l), i = Fo(
            i,
            l,
            d
          ), i !== null ? i.sibling : null);
        Ti(l);
        break;
      case 19:
        var b = (i.flags & 128) !== 0;
        if (m = (d & l.childLanes) !== 0, m || (gu(
          i,
          l,
          d,
          !1
        ), m = (d & l.childLanes) !== 0), b) {
          if (m)
            return DS(
              i,
              l,
              d
            );
          l.flags |= 128;
        }
        if (b = l.memoizedState, b !== null && (b.rendering = null, b.tail = null, b.lastEffect = null), L(Kt, Kt.current), m) break;
        return null;
      case 22:
      case 23:
        return l.lanes = 0, kS(i, l, d);
      case 24:
        _i(l, Xt, i.memoizedState.cache);
    }
    return Fo(i, l, d);
  }
  function PS(i, l, d) {
    if (i !== null)
      if (i.memoizedProps !== l.pendingProps)
        Jt = !0;
      else {
        if (!_0(i, d) && (l.flags & 128) === 0)
          return Jt = !1, sI(
            i,
            l,
            d
          );
        Jt = (i.flags & 131072) !== 0;
      }
    else
      Jt = !1, rt && (l.flags & 1048576) !== 0 && c_(l, Qf, l.index);
    switch (l.lanes = 0, l.tag) {
      case 16:
        e: {
          i = l.pendingProps;
          var m = l.elementType, b = m._init;
          if (m = b(m._payload), l.type = m, typeof m == "function")
            Og(m) ? (i = ka(m, i), l.tag = 1, l = RS(
              null,
              l,
              m,
              i,
              d
            )) : (l.tag = 0, l = m0(
              null,
              l,
              m,
              i,
              d
            ));
          else {
            if (m != null) {
              if (b = m.$$typeof, b === A) {
                l.tag = 11, l = SS(
                  null,
                  l,
                  m,
                  i,
                  d
                );
                break e;
              } else if (b === P) {
                l.tag = 14, l = ES(
                  null,
                  l,
                  m,
                  i,
                  d
                );
                break e;
              }
            }
            throw l = j(m) || m, Error(r(306, l, ""));
          }
        }
        return l;
      case 0:
        return m0(
          i,
          l,
          l.type,
          l.pendingProps,
          d
        );
      case 1:
        return m = l.type, b = ka(
          m,
          l.pendingProps
        ), RS(
          i,
          l,
          m,
          b,
          d
        );
      case 3:
        e: {
          if (le(
            l,
            l.stateNode.containerInfo
          ), i === null) throw Error(r(387));
          m = l.pendingProps;
          var C = l.memoizedState;
          b = C.element, qg(i, l), Su(l, m, null, d);
          var D = l.memoizedState;
          if (m = D.cache, _i(l, Xt, m), m !== C.cache && Fg(
            l,
            [Xt],
            d,
            !0
          ), _u(), m = D.element, C.isDehydrated)
            if (C = {
              element: m,
              isDehydrated: !1,
              cache: D.cache
            }, l.updateQueue.baseState = C, l.memoizedState = C, l.flags & 256) {
              l = MS(
                i,
                l,
                m,
                d
              );
              break e;
            } else if (m !== b) {
              b = hr(
                Error(r(424)),
                l
              ), mu(b), l = MS(
                i,
                l,
                m,
                d
              );
              break e;
            } else {
              switch (i = l.stateNode.containerInfo, i.nodeType) {
                case 9:
                  i = i.body;
                  break;
                default:
                  i = i.nodeName === "HTML" ? i.ownerDocument.body : i;
              }
              for (Mt = Nr(i.firstChild), Sn = l, rt = !0, xa = null, Yr = !0, d = dS(
                l,
                null,
                m,
                d
              ), l.child = d; d; )
                d.flags = d.flags & -3 | 4096, d = d.sibling;
            }
          else {
            if (pu(), m === b) {
              l = Fo(
                i,
                l,
                d
              );
              break e;
            }
            on(
              i,
              l,
              m,
              d
            );
          }
          l = l.child;
        }
        return l;
      case 26:
        return vd(i, l), i === null ? (d = LE(
          l.type,
          null,
          l.pendingProps,
          null
        )) ? l.memoizedState = d : rt || (d = l.type, i = l.pendingProps, m = Dd(
          oe.current
        ).createElement(d), m[Qt] = l, m[dn] = i, sn(m, d, i), Bt(m), l.stateNode = m) : l.memoizedState = LE(
          l.type,
          i.memoizedProps,
          l.pendingProps,
          i.memoizedState
        ), null;
      case 27:
        return je(l), i === null && rt && (m = l.stateNode = jE(
          l.type,
          l.pendingProps,
          oe.current
        ), Sn = l, Yr = !0, b = Mt, zi(l.type) ? (ny = b, Mt = Nr(
          m.firstChild
        )) : Mt = b), on(
          i,
          l,
          l.pendingProps.children,
          d
        ), vd(i, l), i === null && (l.flags |= 4194304), l.child;
      case 5:
        return i === null && rt && ((b = m = Mt) && (m = jI(
          m,
          l.type,
          l.pendingProps,
          Yr
        ), m !== null ? (l.stateNode = m, Sn = l, Mt = Nr(
          m.firstChild
        ), Yr = !1, b = !0) : b = !1), b || wa(l)), je(l), b = l.type, C = l.pendingProps, D = i !== null ? i.memoizedProps : null, m = C.children, Q0(b, C) ? m = null : D !== null && Q0(b, D) && (l.flags |= 32), l.memoizedState !== null && (b = Zg(
          i,
          l,
          Jj,
          null,
          null,
          d
        ), qu._currentValue = b), vd(i, l), on(i, l, m, d), l.child;
      case 6:
        return i === null && rt && ((i = d = Mt) && (d = II(
          d,
          l.pendingProps,
          Yr
        ), d !== null ? (l.stateNode = d, Sn = l, Mt = null, i = !0) : i = !1), i || wa(l)), null;
      case 13:
        return OS(i, l, d);
      case 4:
        return le(
          l,
          l.stateNode.containerInfo
        ), m = l.pendingProps, i === null ? l.child = Ts(
          l,
          null,
          m,
          d
        ) : on(
          i,
          l,
          m,
          d
        ), l.child;
      case 11:
        return SS(
          i,
          l,
          l.type,
          l.pendingProps,
          d
        );
      case 7:
        return on(
          i,
          l,
          l.pendingProps,
          d
        ), l.child;
      case 8:
        return on(
          i,
          l,
          l.pendingProps.children,
          d
        ), l.child;
      case 12:
        return on(
          i,
          l,
          l.pendingProps.children,
          d
        ), l.child;
      case 10:
        return m = l.pendingProps, _i(l, l.type, m.value), on(
          i,
          l,
          m.children,
          d
        ), l.child;
      case 9:
        return b = l.type._context, m = l.pendingProps.children, Sa(l), b = hn(b), m = m(b), l.flags |= 1, on(i, l, m, d), l.child;
      case 14:
        return ES(
          i,
          l,
          l.type,
          l.pendingProps,
          d
        );
      case 15:
        return CS(
          i,
          l,
          l.type,
          l.pendingProps,
          d
        );
      case 19:
        return DS(i, l, d);
      case 31:
        return m = l.pendingProps, d = l.mode, m = {
          mode: m.mode,
          children: m.children
        }, i === null ? (d = bd(
          m,
          d
        ), d.ref = l.ref, l.child = d, d.return = l, l = d) : (d = No(i.child, m), d.ref = l.ref, l.child = d, d.return = l, l = d), l;
      case 22:
        return kS(i, l, d);
      case 24:
        return Sa(l), m = hn(Xt), i === null ? (b = Hg(), b === null && (b = xt, C = $g(), b.pooledCache = C, C.refCount++, C !== null && (b.pooledCacheLanes |= d), b = C), l.memoizedState = {
          parent: m,
          cache: b
        }, Ug(l), _i(l, Xt, b)) : ((i.lanes & d) !== 0 && (qg(i, l), Su(l, null, null, d), _u()), b = i.memoizedState, C = l.memoizedState, b.parent !== m ? (b = { parent: m, cache: m }, l.memoizedState = b, l.lanes === 0 && (l.memoizedState = l.updateQueue.baseState = b), _i(l, Xt, m)) : (m = C.cache, _i(l, Xt, m), m !== b.cache && Fg(
          l,
          [Xt],
          d,
          !0
        ))), on(
          i,
          l,
          l.pendingProps.children,
          d
        ), l.child;
      case 29:
        throw l.pendingProps;
    }
    throw Error(r(156, l.tag));
  }
  function $o(i) {
    i.flags |= 4;
  }
  function jS(i, l) {
    if (l.type !== "stylesheet" || (l.state.loading & 4) !== 0)
      i.flags &= -16777217;
    else if (i.flags |= 16777216, !VE(l)) {
      if (l = yr.current, l !== null && ((Ze & 4194048) === Ze ? Wr !== null : (Ze & 62914560) !== Ze && (Ze & 536870912) === 0 || l !== Wr))
        throw xu = Vg, v_;
      i.flags |= 8192;
    }
  }
  function xd(i, l) {
    l !== null && (i.flags |= 4), i.flags & 16384 && (l = i.tag !== 22 ? Rf() : 536870912, i.lanes |= l, Os |= l);
  }
  function Mu(i, l) {
    if (!rt)
      switch (i.tailMode) {
        case "hidden":
          l = i.tail;
          for (var d = null; l !== null; )
            l.alternate !== null && (d = l), l = l.sibling;
          d === null ? i.tail = null : d.sibling = null;
          break;
        case "collapsed":
          d = i.tail;
          for (var m = null; d !== null; )
            d.alternate !== null && (m = d), d = d.sibling;
          m === null ? l || i.tail === null ? i.tail = null : i.tail.sibling = null : m.sibling = null;
      }
  }
  function Tt(i) {
    var l = i.alternate !== null && i.alternate.child === i.child, d = 0, m = 0;
    if (l)
      for (var b = i.child; b !== null; )
        d |= b.lanes | b.childLanes, m |= b.subtreeFlags & 65011712, m |= b.flags & 65011712, b.return = i, b = b.sibling;
    else
      for (b = i.child; b !== null; )
        d |= b.lanes | b.childLanes, m |= b.subtreeFlags, m |= b.flags, b.return = i, b = b.sibling;
    return i.subtreeFlags |= m, i.childLanes = d, l;
  }
  function lI(i, l, d) {
    var m = l.pendingProps;
    switch (jg(l), l.tag) {
      case 31:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Tt(l), null;
      case 1:
        return Tt(l), null;
      case 3:
        return d = l.stateNode, m = null, i !== null && (m = i.memoizedState.cache), l.memoizedState.cache !== m && (l.flags |= 2048), Io(Xt), ye(), d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null), (i === null || i.child === null) && (hu(l) ? $o(l) : i === null || i.memoizedState.isDehydrated && (l.flags & 256) === 0 || (l.flags |= 1024, h_())), Tt(l), null;
      case 26:
        return d = l.memoizedState, i === null ? ($o(l), d !== null ? (Tt(l), jS(l, d)) : (Tt(l), l.flags &= -16777217)) : d ? d !== i.memoizedState ? ($o(l), Tt(l), jS(l, d)) : (Tt(l), l.flags &= -16777217) : (i.memoizedProps !== m && $o(l), Tt(l), l.flags &= -16777217), null;
      case 27:
        Ne(l), d = oe.current;
        var b = l.type;
        if (i !== null && l.stateNode != null)
          i.memoizedProps !== m && $o(l);
        else {
          if (!m) {
            if (l.stateNode === null)
              throw Error(r(166));
            return Tt(l), null;
          }
          i = te.current, hu(l) ? f_(l) : (i = jE(b, m, d), l.stateNode = i, $o(l));
        }
        return Tt(l), null;
      case 5:
        if (Ne(l), d = l.type, i !== null && l.stateNode != null)
          i.memoizedProps !== m && $o(l);
        else {
          if (!m) {
            if (l.stateNode === null)
              throw Error(r(166));
            return Tt(l), null;
          }
          if (i = te.current, hu(l))
            f_(l);
          else {
            switch (b = Dd(
              oe.current
            ), i) {
              case 1:
                i = b.createElementNS(
                  "http://www.w3.org/2000/svg",
                  d
                );
                break;
              case 2:
                i = b.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  d
                );
                break;
              default:
                switch (d) {
                  case "svg":
                    i = b.createElementNS(
                      "http://www.w3.org/2000/svg",
                      d
                    );
                    break;
                  case "math":
                    i = b.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      d
                    );
                    break;
                  case "script":
                    i = b.createElement("div"), i.innerHTML = "<script><\/script>", i = i.removeChild(i.firstChild);
                    break;
                  case "select":
                    i = typeof m.is == "string" ? b.createElement("select", { is: m.is }) : b.createElement("select"), m.multiple ? i.multiple = !0 : m.size && (i.size = m.size);
                    break;
                  default:
                    i = typeof m.is == "string" ? b.createElement(d, { is: m.is }) : b.createElement(d);
                }
            }
            i[Qt] = l, i[dn] = m;
            e: for (b = l.child; b !== null; ) {
              if (b.tag === 5 || b.tag === 6)
                i.appendChild(b.stateNode);
              else if (b.tag !== 4 && b.tag !== 27 && b.child !== null) {
                b.child.return = b, b = b.child;
                continue;
              }
              if (b === l) break e;
              for (; b.sibling === null; ) {
                if (b.return === null || b.return === l)
                  break e;
                b = b.return;
              }
              b.sibling.return = b.return, b = b.sibling;
            }
            l.stateNode = i;
            e: switch (sn(i, d, m), d) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                i = !!m.autoFocus;
                break e;
              case "img":
                i = !0;
                break e;
              default:
                i = !1;
            }
            i && $o(l);
          }
        }
        return Tt(l), l.flags &= -16777217, null;
      case 6:
        if (i && l.stateNode != null)
          i.memoizedProps !== m && $o(l);
        else {
          if (typeof m != "string" && l.stateNode === null)
            throw Error(r(166));
          if (i = oe.current, hu(l)) {
            if (i = l.stateNode, d = l.memoizedProps, m = null, b = Sn, b !== null)
              switch (b.tag) {
                case 27:
                case 5:
                  m = b.memoizedProps;
              }
            i[Qt] = l, i = !!(i.nodeValue === d || m !== null && m.suppressHydrationWarning === !0 || AE(i.nodeValue, d)), i || wa(l);
          } else
            i = Dd(i).createTextNode(
              m
            ), i[Qt] = l, l.stateNode = i;
        }
        return Tt(l), null;
      case 13:
        if (m = l.memoizedState, i === null || i.memoizedState !== null && i.memoizedState.dehydrated !== null) {
          if (b = hu(l), m !== null && m.dehydrated !== null) {
            if (i === null) {
              if (!b) throw Error(r(318));
              if (b = l.memoizedState, b = b !== null ? b.dehydrated : null, !b) throw Error(r(317));
              b[Qt] = l;
            } else
              pu(), (l.flags & 128) === 0 && (l.memoizedState = null), l.flags |= 4;
            Tt(l), b = !1;
          } else
            b = h_(), i !== null && i.memoizedState !== null && (i.memoizedState.hydrationErrors = b), b = !0;
          if (!b)
            return l.flags & 256 ? (Lo(l), l) : (Lo(l), null);
        }
        if (Lo(l), (l.flags & 128) !== 0)
          return l.lanes = d, l;
        if (d = m !== null, i = i !== null && i.memoizedState !== null, d) {
          m = l.child, b = null, m.alternate !== null && m.alternate.memoizedState !== null && m.alternate.memoizedState.cachePool !== null && (b = m.alternate.memoizedState.cachePool.pool);
          var C = null;
          m.memoizedState !== null && m.memoizedState.cachePool !== null && (C = m.memoizedState.cachePool.pool), C !== b && (m.flags |= 2048);
        }
        return d !== i && d && (l.child.flags |= 8192), xd(l, l.updateQueue), Tt(l), null;
      case 4:
        return ye(), i === null && Y0(l.stateNode.containerInfo), Tt(l), null;
      case 10:
        return Io(l.type), Tt(l), null;
      case 19:
        if (Z(Kt), b = l.memoizedState, b === null) return Tt(l), null;
        if (m = (l.flags & 128) !== 0, C = b.rendering, C === null)
          if (m) Mu(b, !1);
          else {
            if (Ot !== 0 || i !== null && (i.flags & 128) !== 0)
              for (i = l.child; i !== null; ) {
                if (C = md(i), C !== null) {
                  for (l.flags |= 128, Mu(b, !1), i = C.updateQueue, l.updateQueue = i, xd(l, i), l.subtreeFlags = 0, i = d, d = l.child; d !== null; )
                    u_(d, i), d = d.sibling;
                  return L(
                    Kt,
                    Kt.current & 1 | 2
                  ), l.child;
                }
                i = i.sibling;
              }
            b.tail !== null && ct() > Sd && (l.flags |= 128, m = !0, Mu(b, !1), l.lanes = 4194304);
          }
        else {
          if (!m)
            if (i = md(C), i !== null) {
              if (l.flags |= 128, m = !0, i = i.updateQueue, l.updateQueue = i, xd(l, i), Mu(b, !0), b.tail === null && b.tailMode === "hidden" && !C.alternate && !rt)
                return Tt(l), null;
            } else
              2 * ct() - b.renderingStartTime > Sd && d !== 536870912 && (l.flags |= 128, m = !0, Mu(b, !1), l.lanes = 4194304);
          b.isBackwards ? (C.sibling = l.child, l.child = C) : (i = b.last, i !== null ? i.sibling = C : l.child = C, b.last = C);
        }
        return b.tail !== null ? (l = b.tail, b.rendering = l, b.tail = l.sibling, b.renderingStartTime = ct(), l.sibling = null, i = Kt.current, L(Kt, m ? i & 1 | 2 : i & 1), l) : (Tt(l), null);
      case 22:
      case 23:
        return Lo(l), Xg(), m = l.memoizedState !== null, i !== null ? i.memoizedState !== null !== m && (l.flags |= 8192) : m && (l.flags |= 8192), m ? (d & 536870912) !== 0 && (l.flags & 128) === 0 && (Tt(l), l.subtreeFlags & 6 && (l.flags |= 8192)) : Tt(l), d = l.updateQueue, d !== null && xd(l, d.retryQueue), d = null, i !== null && i.memoizedState !== null && i.memoizedState.cachePool !== null && (d = i.memoizedState.cachePool.pool), m = null, l.memoizedState !== null && l.memoizedState.cachePool !== null && (m = l.memoizedState.cachePool.pool), m !== d && (l.flags |= 2048), i !== null && Z(Ea), null;
      case 24:
        return d = null, i !== null && (d = i.memoizedState.cache), l.memoizedState.cache !== d && (l.flags |= 2048), Io(Xt), Tt(l), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(r(156, l.tag));
  }
  function uI(i, l) {
    switch (jg(l), l.tag) {
      case 1:
        return i = l.flags, i & 65536 ? (l.flags = i & -65537 | 128, l) : null;
      case 3:
        return Io(Xt), ye(), i = l.flags, (i & 65536) !== 0 && (i & 128) === 0 ? (l.flags = i & -65537 | 128, l) : null;
      case 26:
      case 27:
      case 5:
        return Ne(l), null;
      case 13:
        if (Lo(l), i = l.memoizedState, i !== null && i.dehydrated !== null) {
          if (l.alternate === null)
            throw Error(r(340));
          pu();
        }
        return i = l.flags, i & 65536 ? (l.flags = i & -65537 | 128, l) : null;
      case 19:
        return Z(Kt), null;
      case 4:
        return ye(), null;
      case 10:
        return Io(l.type), null;
      case 22:
      case 23:
        return Lo(l), Xg(), i !== null && Z(Ea), i = l.flags, i & 65536 ? (l.flags = i & -65537 | 128, l) : null;
      case 24:
        return Io(Xt), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function IS(i, l) {
    switch (jg(l), l.tag) {
      case 3:
        Io(Xt), ye();
        break;
      case 26:
      case 27:
      case 5:
        Ne(l);
        break;
      case 4:
        ye();
        break;
      case 13:
        Lo(l);
        break;
      case 19:
        Z(Kt);
        break;
      case 10:
        Io(l.type);
        break;
      case 22:
      case 23:
        Lo(l), Xg(), i !== null && Z(Ea);
        break;
      case 24:
        Io(Xt);
    }
  }
  function Ou(i, l) {
    try {
      var d = l.updateQueue, m = d !== null ? d.lastEffect : null;
      if (m !== null) {
        var b = m.next;
        d = b;
        do {
          if ((d.tag & i) === i) {
            m = void 0;
            var C = d.create, D = d.inst;
            m = C(), D.destroy = m;
          }
          d = d.next;
        } while (d !== b);
      }
    } catch ($) {
      mt(l, l.return, $);
    }
  }
  function Ri(i, l, d) {
    try {
      var m = l.updateQueue, b = m !== null ? m.lastEffect : null;
      if (b !== null) {
        var C = b.next;
        m = C;
        do {
          if ((m.tag & i) === i) {
            var D = m.inst, $ = D.destroy;
            if ($ !== void 0) {
              D.destroy = void 0, b = l;
              var X = d, ee = $;
              try {
                ee();
              } catch (ue) {
                mt(
                  b,
                  X,
                  ue
                );
              }
            }
          }
          m = m.next;
        } while (m !== C);
      }
    } catch (ue) {
      mt(l, l.return, ue);
    }
  }
  function zS(i) {
    var l = i.updateQueue;
    if (l !== null) {
      var d = i.stateNode;
      try {
        E_(l, d);
      } catch (m) {
        mt(i, i.return, m);
      }
    }
  }
  function LS(i, l, d) {
    d.props = ka(
      i.type,
      i.memoizedProps
    ), d.state = i.memoizedState;
    try {
      d.componentWillUnmount();
    } catch (m) {
      mt(i, l, m);
    }
  }
  function Nu(i, l) {
    try {
      var d = i.ref;
      if (d !== null) {
        switch (i.tag) {
          case 26:
          case 27:
          case 5:
            var m = i.stateNode;
            break;
          case 30:
            m = i.stateNode;
            break;
          default:
            m = i.stateNode;
        }
        typeof d == "function" ? i.refCleanup = d(m) : d.current = m;
      }
    } catch (b) {
      mt(i, l, b);
    }
  }
  function Xr(i, l) {
    var d = i.ref, m = i.refCleanup;
    if (d !== null)
      if (typeof m == "function")
        try {
          m();
        } catch (b) {
          mt(i, l, b);
        } finally {
          i.refCleanup = null, i = i.alternate, i != null && (i.refCleanup = null);
        }
      else if (typeof d == "function")
        try {
          d(null);
        } catch (b) {
          mt(i, l, b);
        }
      else d.current = null;
  }
  function FS(i) {
    var l = i.type, d = i.memoizedProps, m = i.stateNode;
    try {
      e: switch (l) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          d.autoFocus && m.focus();
          break e;
        case "img":
          d.src ? m.src = d.src : d.srcSet && (m.srcset = d.srcSet);
      }
    } catch (b) {
      mt(i, i.return, b);
    }
  }
  function S0(i, l, d) {
    try {
      var m = i.stateNode;
      MI(m, i.type, d, l), m[dn] = l;
    } catch (b) {
      mt(i, i.return, b);
    }
  }
  function $S(i) {
    return i.tag === 5 || i.tag === 3 || i.tag === 26 || i.tag === 27 && zi(i.type) || i.tag === 4;
  }
  function E0(i) {
    e: for (; ; ) {
      for (; i.sibling === null; ) {
        if (i.return === null || $S(i.return)) return null;
        i = i.return;
      }
      for (i.sibling.return = i.return, i = i.sibling; i.tag !== 5 && i.tag !== 6 && i.tag !== 18; ) {
        if (i.tag === 27 && zi(i.type) || i.flags & 2 || i.child === null || i.tag === 4) continue e;
        i.child.return = i, i = i.child;
      }
      if (!(i.flags & 2)) return i.stateNode;
    }
  }
  function C0(i, l, d) {
    var m = i.tag;
    if (m === 5 || m === 6)
      i = i.stateNode, l ? (d.nodeType === 9 ? d.body : d.nodeName === "HTML" ? d.ownerDocument.body : d).insertBefore(i, l) : (l = d.nodeType === 9 ? d.body : d.nodeName === "HTML" ? d.ownerDocument.body : d, l.appendChild(i), d = d._reactRootContainer, d != null || l.onclick !== null || (l.onclick = Nd));
    else if (m !== 4 && (m === 27 && zi(i.type) && (d = i.stateNode, l = null), i = i.child, i !== null))
      for (C0(i, l, d), i = i.sibling; i !== null; )
        C0(i, l, d), i = i.sibling;
  }
  function wd(i, l, d) {
    var m = i.tag;
    if (m === 5 || m === 6)
      i = i.stateNode, l ? d.insertBefore(i, l) : d.appendChild(i);
    else if (m !== 4 && (m === 27 && zi(i.type) && (d = i.stateNode), i = i.child, i !== null))
      for (wd(i, l, d), i = i.sibling; i !== null; )
        wd(i, l, d), i = i.sibling;
  }
  function BS(i) {
    var l = i.stateNode, d = i.memoizedProps;
    try {
      for (var m = i.type, b = l.attributes; b.length; )
        l.removeAttributeNode(b[0]);
      sn(l, m, d), l[Qt] = i, l[dn] = d;
    } catch (C) {
      mt(i, i.return, C);
    }
  }
  var Bo = !1, It = !1, k0 = !1, HS = typeof WeakSet == "function" ? WeakSet : Set, en = null;
  function cI(i, l) {
    if (i = i.containerInfo, K0 = Fd, i = Jw(i), Eg(i)) {
      if ("selectionStart" in i)
        var d = {
          start: i.selectionStart,
          end: i.selectionEnd
        };
      else
        e: {
          d = (d = i.ownerDocument) && d.defaultView || window;
          var m = d.getSelection && d.getSelection();
          if (m && m.rangeCount !== 0) {
            d = m.anchorNode;
            var b = m.anchorOffset, C = m.focusNode;
            m = m.focusOffset;
            try {
              d.nodeType, C.nodeType;
            } catch {
              d = null;
              break e;
            }
            var D = 0, $ = -1, X = -1, ee = 0, ue = 0, fe = i, ne = null;
            t: for (; ; ) {
              for (var re; fe !== d || b !== 0 && fe.nodeType !== 3 || ($ = D + b), fe !== C || m !== 0 && fe.nodeType !== 3 || (X = D + m), fe.nodeType === 3 && (D += fe.nodeValue.length), (re = fe.firstChild) !== null; )
                ne = fe, fe = re;
              for (; ; ) {
                if (fe === i) break t;
                if (ne === d && ++ee === b && ($ = D), ne === C && ++ue === m && (X = D), (re = fe.nextSibling) !== null) break;
                fe = ne, ne = fe.parentNode;
              }
              fe = re;
            }
            d = $ === -1 || X === -1 ? null : { start: $, end: X };
          } else d = null;
        }
      d = d || { start: 0, end: 0 };
    } else d = null;
    for (Z0 = { focusedElem: i, selectionRange: d }, Fd = !1, en = l; en !== null; )
      if (l = en, i = l.child, (l.subtreeFlags & 1024) !== 0 && i !== null)
        i.return = l, en = i;
      else
        for (; en !== null; ) {
          switch (l = en, C = l.alternate, i = l.flags, l.tag) {
            case 0:
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((i & 1024) !== 0 && C !== null) {
                i = void 0, d = l, b = C.memoizedProps, C = C.memoizedState, m = d.stateNode;
                try {
                  var Le = ka(
                    d.type,
                    b,
                    d.elementType === d.type
                  );
                  i = m.getSnapshotBeforeUpdate(
                    Le,
                    C
                  ), m.__reactInternalSnapshotBeforeUpdate = i;
                } catch (Pe) {
                  mt(
                    d,
                    d.return,
                    Pe
                  );
                }
              }
              break;
            case 3:
              if ((i & 1024) !== 0) {
                if (i = l.stateNode.containerInfo, d = i.nodeType, d === 9)
                  ey(i);
                else if (d === 1)
                  switch (i.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      ey(i);
                      break;
                    default:
                      i.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((i & 1024) !== 0) throw Error(r(163));
          }
          if (i = l.sibling, i !== null) {
            i.return = l.return, en = i;
            break;
          }
          en = l.return;
        }
  }
  function VS(i, l, d) {
    var m = d.flags;
    switch (d.tag) {
      case 0:
      case 11:
      case 15:
        Mi(i, d), m & 4 && Ou(5, d);
        break;
      case 1:
        if (Mi(i, d), m & 4)
          if (i = d.stateNode, l === null)
            try {
              i.componentDidMount();
            } catch (D) {
              mt(d, d.return, D);
            }
          else {
            var b = ka(
              d.type,
              l.memoizedProps
            );
            l = l.memoizedState;
            try {
              i.componentDidUpdate(
                b,
                l,
                i.__reactInternalSnapshotBeforeUpdate
              );
            } catch (D) {
              mt(
                d,
                d.return,
                D
              );
            }
          }
        m & 64 && zS(d), m & 512 && Nu(d, d.return);
        break;
      case 3:
        if (Mi(i, d), m & 64 && (i = d.updateQueue, i !== null)) {
          if (l = null, d.child !== null)
            switch (d.child.tag) {
              case 27:
              case 5:
                l = d.child.stateNode;
                break;
              case 1:
                l = d.child.stateNode;
            }
          try {
            E_(i, l);
          } catch (D) {
            mt(d, d.return, D);
          }
        }
        break;
      case 27:
        l === null && m & 4 && BS(d);
      case 26:
      case 5:
        Mi(i, d), l === null && m & 4 && FS(d), m & 512 && Nu(d, d.return);
        break;
      case 12:
        Mi(i, d);
        break;
      case 13:
        Mi(i, d), m & 4 && GS(i, d), m & 64 && (i = d.memoizedState, i !== null && (i = i.dehydrated, i !== null && (d = bI.bind(
          null,
          d
        ), zI(i, d))));
        break;
      case 22:
        if (m = d.memoizedState !== null || Bo, !m) {
          l = l !== null && l.memoizedState !== null || It, b = Bo;
          var C = It;
          Bo = m, (It = l) && !C ? Oi(
            i,
            d,
            (d.subtreeFlags & 8772) !== 0
          ) : Mi(i, d), Bo = b, It = C;
        }
        break;
      case 30:
        break;
      default:
        Mi(i, d);
    }
  }
  function US(i) {
    var l = i.alternate;
    l !== null && (i.alternate = null, US(l)), i.child = null, i.deletions = null, i.sibling = null, i.tag === 5 && (l = i.stateNode, l !== null && Zl(l)), i.stateNode = null, i.return = null, i.dependencies = null, i.memoizedProps = null, i.memoizedState = null, i.pendingProps = null, i.stateNode = null, i.updateQueue = null;
  }
  var Et = null, Pn = !1;
  function Ho(i, l, d) {
    for (d = d.child; d !== null; )
      qS(i, l, d), d = d.sibling;
  }
  function qS(i, l, d) {
    if (pe && typeof pe.onCommitFiberUnmount == "function")
      try {
        pe.onCommitFiberUnmount(ae, d);
      } catch {
      }
    switch (d.tag) {
      case 26:
        It || Xr(d, l), Ho(
          i,
          l,
          d
        ), d.memoizedState ? d.memoizedState.count-- : d.stateNode && (d = d.stateNode, d.parentNode.removeChild(d));
        break;
      case 27:
        It || Xr(d, l);
        var m = Et, b = Pn;
        zi(d.type) && (Et = d.stateNode, Pn = !1), Ho(
          i,
          l,
          d
        ), Bu(d.stateNode), Et = m, Pn = b;
        break;
      case 5:
        It || Xr(d, l);
      case 6:
        if (m = Et, b = Pn, Et = null, Ho(
          i,
          l,
          d
        ), Et = m, Pn = b, Et !== null)
          if (Pn)
            try {
              (Et.nodeType === 9 ? Et.body : Et.nodeName === "HTML" ? Et.ownerDocument.body : Et).removeChild(d.stateNode);
            } catch (C) {
              mt(
                d,
                l,
                C
              );
            }
          else
            try {
              Et.removeChild(d.stateNode);
            } catch (C) {
              mt(
                d,
                l,
                C
              );
            }
        break;
      case 18:
        Et !== null && (Pn ? (i = Et, DE(
          i.nodeType === 9 ? i.body : i.nodeName === "HTML" ? i.ownerDocument.body : i,
          d.stateNode
        ), Xu(i)) : DE(Et, d.stateNode));
        break;
      case 4:
        m = Et, b = Pn, Et = d.stateNode.containerInfo, Pn = !0, Ho(
          i,
          l,
          d
        ), Et = m, Pn = b;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        It || Ri(2, d, l), It || Ri(4, d, l), Ho(
          i,
          l,
          d
        );
        break;
      case 1:
        It || (Xr(d, l), m = d.stateNode, typeof m.componentWillUnmount == "function" && LS(
          d,
          l,
          m
        )), Ho(
          i,
          l,
          d
        );
        break;
      case 21:
        Ho(
          i,
          l,
          d
        );
        break;
      case 22:
        It = (m = It) || d.memoizedState !== null, Ho(
          i,
          l,
          d
        ), It = m;
        break;
      default:
        Ho(
          i,
          l,
          d
        );
    }
  }
  function GS(i, l) {
    if (l.memoizedState === null && (i = l.alternate, i !== null && (i = i.memoizedState, i !== null && (i = i.dehydrated, i !== null))))
      try {
        Xu(i);
      } catch (d) {
        mt(l, l.return, d);
      }
  }
  function fI(i) {
    switch (i.tag) {
      case 13:
      case 19:
        var l = i.stateNode;
        return l === null && (l = i.stateNode = new HS()), l;
      case 22:
        return i = i.stateNode, l = i._retryCache, l === null && (l = i._retryCache = new HS()), l;
      default:
        throw Error(r(435, i.tag));
    }
  }
  function T0(i, l) {
    var d = fI(i);
    l.forEach(function(m) {
      var b = xI.bind(null, i, m);
      d.has(m) || (d.add(m), m.then(b, b));
    });
  }
  function Xn(i, l) {
    var d = l.deletions;
    if (d !== null)
      for (var m = 0; m < d.length; m++) {
        var b = d[m], C = i, D = l, $ = D;
        e: for (; $ !== null; ) {
          switch ($.tag) {
            case 27:
              if (zi($.type)) {
                Et = $.stateNode, Pn = !1;
                break e;
              }
              break;
            case 5:
              Et = $.stateNode, Pn = !1;
              break e;
            case 3:
            case 4:
              Et = $.stateNode.containerInfo, Pn = !0;
              break e;
          }
          $ = $.return;
        }
        if (Et === null) throw Error(r(160));
        qS(C, D, b), Et = null, Pn = !1, C = b.alternate, C !== null && (C.return = null), b.return = null;
      }
    if (l.subtreeFlags & 13878)
      for (l = l.child; l !== null; )
        YS(l, i), l = l.sibling;
  }
  var Or = null;
  function YS(i, l) {
    var d = i.alternate, m = i.flags;
    switch (i.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Xn(l, i), Kn(i), m & 4 && (Ri(3, i, i.return), Ou(3, i), Ri(5, i, i.return));
        break;
      case 1:
        Xn(l, i), Kn(i), m & 512 && (It || d === null || Xr(d, d.return)), m & 64 && Bo && (i = i.updateQueue, i !== null && (m = i.callbacks, m !== null && (d = i.shared.hiddenCallbacks, i.shared.hiddenCallbacks = d === null ? m : d.concat(m))));
        break;
      case 26:
        var b = Or;
        if (Xn(l, i), Kn(i), m & 512 && (It || d === null || Xr(d, d.return)), m & 4) {
          var C = d !== null ? d.memoizedState : null;
          if (m = i.memoizedState, d === null)
            if (m === null)
              if (i.stateNode === null) {
                e: {
                  m = i.type, d = i.memoizedProps, b = b.ownerDocument || b;
                  t: switch (m) {
                    case "title":
                      C = b.getElementsByTagName("title")[0], (!C || C[da] || C[Qt] || C.namespaceURI === "http://www.w3.org/2000/svg" || C.hasAttribute("itemprop")) && (C = b.createElement(m), b.head.insertBefore(
                        C,
                        b.querySelector("head > title")
                      )), sn(C, m, d), C[Qt] = i, Bt(C), m = C;
                      break e;
                    case "link":
                      var D = BE(
                        "link",
                        "href",
                        b
                      ).get(m + (d.href || ""));
                      if (D) {
                        for (var $ = 0; $ < D.length; $++)
                          if (C = D[$], C.getAttribute("href") === (d.href == null || d.href === "" ? null : d.href) && C.getAttribute("rel") === (d.rel == null ? null : d.rel) && C.getAttribute("title") === (d.title == null ? null : d.title) && C.getAttribute("crossorigin") === (d.crossOrigin == null ? null : d.crossOrigin)) {
                            D.splice($, 1);
                            break t;
                          }
                      }
                      C = b.createElement(m), sn(C, m, d), b.head.appendChild(C);
                      break;
                    case "meta":
                      if (D = BE(
                        "meta",
                        "content",
                        b
                      ).get(m + (d.content || ""))) {
                        for ($ = 0; $ < D.length; $++)
                          if (C = D[$], C.getAttribute("content") === (d.content == null ? null : "" + d.content) && C.getAttribute("name") === (d.name == null ? null : d.name) && C.getAttribute("property") === (d.property == null ? null : d.property) && C.getAttribute("http-equiv") === (d.httpEquiv == null ? null : d.httpEquiv) && C.getAttribute("charset") === (d.charSet == null ? null : d.charSet)) {
                            D.splice($, 1);
                            break t;
                          }
                      }
                      C = b.createElement(m), sn(C, m, d), b.head.appendChild(C);
                      break;
                    default:
                      throw Error(r(468, m));
                  }
                  C[Qt] = i, Bt(C), m = C;
                }
                i.stateNode = m;
              } else
                HE(
                  b,
                  i.type,
                  i.stateNode
                );
            else
              i.stateNode = $E(
                b,
                m,
                i.memoizedProps
              );
          else
            C !== m ? (C === null ? d.stateNode !== null && (d = d.stateNode, d.parentNode.removeChild(d)) : C.count--, m === null ? HE(
              b,
              i.type,
              i.stateNode
            ) : $E(
              b,
              m,
              i.memoizedProps
            )) : m === null && i.stateNode !== null && S0(
              i,
              i.memoizedProps,
              d.memoizedProps
            );
        }
        break;
      case 27:
        Xn(l, i), Kn(i), m & 512 && (It || d === null || Xr(d, d.return)), d !== null && m & 4 && S0(
          i,
          i.memoizedProps,
          d.memoizedProps
        );
        break;
      case 5:
        if (Xn(l, i), Kn(i), m & 512 && (It || d === null || Xr(d, d.return)), i.flags & 32) {
          b = i.stateNode;
          try {
            us(b, "");
          } catch (re) {
            mt(i, i.return, re);
          }
        }
        m & 4 && i.stateNode != null && (b = i.memoizedProps, S0(
          i,
          b,
          d !== null ? d.memoizedProps : b
        )), m & 1024 && (k0 = !0);
        break;
      case 6:
        if (Xn(l, i), Kn(i), m & 4) {
          if (i.stateNode === null)
            throw Error(r(162));
          m = i.memoizedProps, d = i.stateNode;
          try {
            d.nodeValue = m;
          } catch (re) {
            mt(i, i.return, re);
          }
        }
        break;
      case 3:
        if (Id = null, b = Or, Or = Pd(l.containerInfo), Xn(l, i), Or = b, Kn(i), m & 4 && d !== null && d.memoizedState.isDehydrated)
          try {
            Xu(l.containerInfo);
          } catch (re) {
            mt(i, i.return, re);
          }
        k0 && (k0 = !1, WS(i));
        break;
      case 4:
        m = Or, Or = Pd(
          i.stateNode.containerInfo
        ), Xn(l, i), Kn(i), Or = m;
        break;
      case 12:
        Xn(l, i), Kn(i);
        break;
      case 13:
        Xn(l, i), Kn(i), i.child.flags & 8192 && i.memoizedState !== null != (d !== null && d.memoizedState !== null) && (D0 = ct()), m & 4 && (m = i.updateQueue, m !== null && (i.updateQueue = null, T0(i, m)));
        break;
      case 22:
        b = i.memoizedState !== null;
        var X = d !== null && d.memoizedState !== null, ee = Bo, ue = It;
        if (Bo = ee || b, It = ue || X, Xn(l, i), It = ue, Bo = ee, Kn(i), m & 8192)
          e: for (l = i.stateNode, l._visibility = b ? l._visibility & -2 : l._visibility | 1, b && (d === null || X || Bo || It || Ta(i)), d = null, l = i; ; ) {
            if (l.tag === 5 || l.tag === 26) {
              if (d === null) {
                X = d = l;
                try {
                  if (C = X.stateNode, b)
                    D = C.style, typeof D.setProperty == "function" ? D.setProperty("display", "none", "important") : D.display = "none";
                  else {
                    $ = X.stateNode;
                    var fe = X.memoizedProps.style, ne = fe != null && fe.hasOwnProperty("display") ? fe.display : null;
                    $.style.display = ne == null || typeof ne == "boolean" ? "" : ("" + ne).trim();
                  }
                } catch (re) {
                  mt(X, X.return, re);
                }
              }
            } else if (l.tag === 6) {
              if (d === null) {
                X = l;
                try {
                  X.stateNode.nodeValue = b ? "" : X.memoizedProps;
                } catch (re) {
                  mt(X, X.return, re);
                }
              }
            } else if ((l.tag !== 22 && l.tag !== 23 || l.memoizedState === null || l === i) && l.child !== null) {
              l.child.return = l, l = l.child;
              continue;
            }
            if (l === i) break e;
            for (; l.sibling === null; ) {
              if (l.return === null || l.return === i) break e;
              d === l && (d = null), l = l.return;
            }
            d === l && (d = null), l.sibling.return = l.return, l = l.sibling;
          }
        m & 4 && (m = i.updateQueue, m !== null && (d = m.retryQueue, d !== null && (m.retryQueue = null, T0(i, d))));
        break;
      case 19:
        Xn(l, i), Kn(i), m & 4 && (m = i.updateQueue, m !== null && (i.updateQueue = null, T0(i, m)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        Xn(l, i), Kn(i);
    }
  }
  function Kn(i) {
    var l = i.flags;
    if (l & 2) {
      try {
        for (var d, m = i.return; m !== null; ) {
          if ($S(m)) {
            d = m;
            break;
          }
          m = m.return;
        }
        if (d == null) throw Error(r(160));
        switch (d.tag) {
          case 27:
            var b = d.stateNode, C = E0(i);
            wd(i, C, b);
            break;
          case 5:
            var D = d.stateNode;
            d.flags & 32 && (us(D, ""), d.flags &= -33);
            var $ = E0(i);
            wd(i, $, D);
            break;
          case 3:
          case 4:
            var X = d.stateNode.containerInfo, ee = E0(i);
            C0(
              i,
              ee,
              X
            );
            break;
          default:
            throw Error(r(161));
        }
      } catch (ue) {
        mt(i, i.return, ue);
      }
      i.flags &= -3;
    }
    l & 4096 && (i.flags &= -4097);
  }
  function WS(i) {
    if (i.subtreeFlags & 1024)
      for (i = i.child; i !== null; ) {
        var l = i;
        WS(l), l.tag === 5 && l.flags & 1024 && l.stateNode.reset(), i = i.sibling;
      }
  }
  function Mi(i, l) {
    if (l.subtreeFlags & 8772)
      for (l = l.child; l !== null; )
        VS(i, l.alternate, l), l = l.sibling;
  }
  function Ta(i) {
    for (i = i.child; i !== null; ) {
      var l = i;
      switch (l.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Ri(4, l, l.return), Ta(l);
          break;
        case 1:
          Xr(l, l.return);
          var d = l.stateNode;
          typeof d.componentWillUnmount == "function" && LS(
            l,
            l.return,
            d
          ), Ta(l);
          break;
        case 27:
          Bu(l.stateNode);
        case 26:
        case 5:
          Xr(l, l.return), Ta(l);
          break;
        case 22:
          l.memoizedState === null && Ta(l);
          break;
        case 30:
          Ta(l);
          break;
        default:
          Ta(l);
      }
      i = i.sibling;
    }
  }
  function Oi(i, l, d) {
    for (d = d && (l.subtreeFlags & 8772) !== 0, l = l.child; l !== null; ) {
      var m = l.alternate, b = i, C = l, D = C.flags;
      switch (C.tag) {
        case 0:
        case 11:
        case 15:
          Oi(
            b,
            C,
            d
          ), Ou(4, C);
          break;
        case 1:
          if (Oi(
            b,
            C,
            d
          ), m = C, b = m.stateNode, typeof b.componentDidMount == "function")
            try {
              b.componentDidMount();
            } catch (ee) {
              mt(m, m.return, ee);
            }
          if (m = C, b = m.updateQueue, b !== null) {
            var $ = m.stateNode;
            try {
              var X = b.shared.hiddenCallbacks;
              if (X !== null)
                for (b.shared.hiddenCallbacks = null, b = 0; b < X.length; b++)
                  S_(X[b], $);
            } catch (ee) {
              mt(m, m.return, ee);
            }
          }
          d && D & 64 && zS(C), Nu(C, C.return);
          break;
        case 27:
          BS(C);
        case 26:
        case 5:
          Oi(
            b,
            C,
            d
          ), d && m === null && D & 4 && FS(C), Nu(C, C.return);
          break;
        case 12:
          Oi(
            b,
            C,
            d
          );
          break;
        case 13:
          Oi(
            b,
            C,
            d
          ), d && D & 4 && GS(b, C);
          break;
        case 22:
          C.memoizedState === null && Oi(
            b,
            C,
            d
          ), Nu(C, C.return);
          break;
        case 30:
          break;
        default:
          Oi(
            b,
            C,
            d
          );
      }
      l = l.sibling;
    }
  }
  function A0(i, l) {
    var d = null;
    i !== null && i.memoizedState !== null && i.memoizedState.cachePool !== null && (d = i.memoizedState.cachePool.pool), i = null, l.memoizedState !== null && l.memoizedState.cachePool !== null && (i = l.memoizedState.cachePool.pool), i !== d && (i != null && i.refCount++, d != null && yu(d));
  }
  function R0(i, l) {
    i = null, l.alternate !== null && (i = l.alternate.memoizedState.cache), l = l.memoizedState.cache, l !== i && (l.refCount++, i != null && yu(i));
  }
  function Kr(i, l, d, m) {
    if (l.subtreeFlags & 10256)
      for (l = l.child; l !== null; )
        XS(
          i,
          l,
          d,
          m
        ), l = l.sibling;
  }
  function XS(i, l, d, m) {
    var b = l.flags;
    switch (l.tag) {
      case 0:
      case 11:
      case 15:
        Kr(
          i,
          l,
          d,
          m
        ), b & 2048 && Ou(9, l);
        break;
      case 1:
        Kr(
          i,
          l,
          d,
          m
        );
        break;
      case 3:
        Kr(
          i,
          l,
          d,
          m
        ), b & 2048 && (i = null, l.alternate !== null && (i = l.alternate.memoizedState.cache), l = l.memoizedState.cache, l !== i && (l.refCount++, i != null && yu(i)));
        break;
      case 12:
        if (b & 2048) {
          Kr(
            i,
            l,
            d,
            m
          ), i = l.stateNode;
          try {
            var C = l.memoizedProps, D = C.id, $ = C.onPostCommit;
            typeof $ == "function" && $(
              D,
              l.alternate === null ? "mount" : "update",
              i.passiveEffectDuration,
              -0
            );
          } catch (X) {
            mt(l, l.return, X);
          }
        } else
          Kr(
            i,
            l,
            d,
            m
          );
        break;
      case 13:
        Kr(
          i,
          l,
          d,
          m
        );
        break;
      case 23:
        break;
      case 22:
        C = l.stateNode, D = l.alternate, l.memoizedState !== null ? C._visibility & 2 ? Kr(
          i,
          l,
          d,
          m
        ) : Du(i, l) : C._visibility & 2 ? Kr(
          i,
          l,
          d,
          m
        ) : (C._visibility |= 2, As(
          i,
          l,
          d,
          m,
          (l.subtreeFlags & 10256) !== 0
        )), b & 2048 && A0(D, l);
        break;
      case 24:
        Kr(
          i,
          l,
          d,
          m
        ), b & 2048 && R0(l.alternate, l);
        break;
      default:
        Kr(
          i,
          l,
          d,
          m
        );
    }
  }
  function As(i, l, d, m, b) {
    for (b = b && (l.subtreeFlags & 10256) !== 0, l = l.child; l !== null; ) {
      var C = i, D = l, $ = d, X = m, ee = D.flags;
      switch (D.tag) {
        case 0:
        case 11:
        case 15:
          As(
            C,
            D,
            $,
            X,
            b
          ), Ou(8, D);
          break;
        case 23:
          break;
        case 22:
          var ue = D.stateNode;
          D.memoizedState !== null ? ue._visibility & 2 ? As(
            C,
            D,
            $,
            X,
            b
          ) : Du(
            C,
            D
          ) : (ue._visibility |= 2, As(
            C,
            D,
            $,
            X,
            b
          )), b && ee & 2048 && A0(
            D.alternate,
            D
          );
          break;
        case 24:
          As(
            C,
            D,
            $,
            X,
            b
          ), b && ee & 2048 && R0(D.alternate, D);
          break;
        default:
          As(
            C,
            D,
            $,
            X,
            b
          );
      }
      l = l.sibling;
    }
  }
  function Du(i, l) {
    if (l.subtreeFlags & 10256)
      for (l = l.child; l !== null; ) {
        var d = i, m = l, b = m.flags;
        switch (m.tag) {
          case 22:
            Du(d, m), b & 2048 && A0(
              m.alternate,
              m
            );
            break;
          case 24:
            Du(d, m), b & 2048 && R0(m.alternate, m);
            break;
          default:
            Du(d, m);
        }
        l = l.sibling;
      }
  }
  var Pu = 8192;
  function Rs(i) {
    if (i.subtreeFlags & Pu)
      for (i = i.child; i !== null; )
        KS(i), i = i.sibling;
  }
  function KS(i) {
    switch (i.tag) {
      case 26:
        Rs(i), i.flags & Pu && i.memoizedState !== null && KI(
          Or,
          i.memoizedState,
          i.memoizedProps
        );
        break;
      case 5:
        Rs(i);
        break;
      case 3:
      case 4:
        var l = Or;
        Or = Pd(i.stateNode.containerInfo), Rs(i), Or = l;
        break;
      case 22:
        i.memoizedState === null && (l = i.alternate, l !== null && l.memoizedState !== null ? (l = Pu, Pu = 16777216, Rs(i), Pu = l) : Rs(i));
        break;
      default:
        Rs(i);
    }
  }
  function ZS(i) {
    var l = i.alternate;
    if (l !== null && (i = l.child, i !== null)) {
      l.child = null;
      do
        l = i.sibling, i.sibling = null, i = l;
      while (i !== null);
    }
  }
  function ju(i) {
    var l = i.deletions;
    if ((i.flags & 16) !== 0) {
      if (l !== null)
        for (var d = 0; d < l.length; d++) {
          var m = l[d];
          en = m, JS(
            m,
            i
          );
        }
      ZS(i);
    }
    if (i.subtreeFlags & 10256)
      for (i = i.child; i !== null; )
        QS(i), i = i.sibling;
  }
  function QS(i) {
    switch (i.tag) {
      case 0:
      case 11:
      case 15:
        ju(i), i.flags & 2048 && Ri(9, i, i.return);
        break;
      case 3:
        ju(i);
        break;
      case 12:
        ju(i);
        break;
      case 22:
        var l = i.stateNode;
        i.memoizedState !== null && l._visibility & 2 && (i.return === null || i.return.tag !== 13) ? (l._visibility &= -3, _d(i)) : ju(i);
        break;
      default:
        ju(i);
    }
  }
  function _d(i) {
    var l = i.deletions;
    if ((i.flags & 16) !== 0) {
      if (l !== null)
        for (var d = 0; d < l.length; d++) {
          var m = l[d];
          en = m, JS(
            m,
            i
          );
        }
      ZS(i);
    }
    for (i = i.child; i !== null; ) {
      switch (l = i, l.tag) {
        case 0:
        case 11:
        case 15:
          Ri(8, l, l.return), _d(l);
          break;
        case 22:
          d = l.stateNode, d._visibility & 2 && (d._visibility &= -3, _d(l));
          break;
        default:
          _d(l);
      }
      i = i.sibling;
    }
  }
  function JS(i, l) {
    for (; en !== null; ) {
      var d = en;
      switch (d.tag) {
        case 0:
        case 11:
        case 15:
          Ri(8, d, l);
          break;
        case 23:
        case 22:
          if (d.memoizedState !== null && d.memoizedState.cachePool !== null) {
            var m = d.memoizedState.cachePool.pool;
            m != null && m.refCount++;
          }
          break;
        case 24:
          yu(d.memoizedState.cache);
      }
      if (m = d.child, m !== null) m.return = d, en = m;
      else
        e: for (d = i; en !== null; ) {
          m = en;
          var b = m.sibling, C = m.return;
          if (US(m), m === d) {
            en = null;
            break e;
          }
          if (b !== null) {
            b.return = C, en = b;
            break e;
          }
          en = C;
        }
    }
  }
  var dI = {
    getCacheForType: function(i) {
      var l = hn(Xt), d = l.data.get(i);
      return d === void 0 && (d = i(), l.data.set(i, d)), d;
    }
  }, hI = typeof WeakMap == "function" ? WeakMap : Map, lt = 0, xt = null, Ge = null, Ze = 0, ut = 0, Zn = null, Ni = !1, Ms = !1, M0 = !1, Vo = 0, Ot = 0, Di = 0, Aa = 0, O0 = 0, vr = 0, Os = 0, Iu = null, jn = null, N0 = !1, D0 = 0, Sd = 1 / 0, Ed = null, Pi = null, an = 0, ji = null, Ns = null, Ds = 0, P0 = 0, j0 = null, eE = null, zu = 0, I0 = null;
  function Qn() {
    if ((lt & 2) !== 0 && Ze !== 0)
      return Ze & -Ze;
    if (I.T !== null) {
      var i = xs;
      return i !== 0 ? i : V0();
    }
    return Of();
  }
  function tE() {
    vr === 0 && (vr = (Ze & 536870912) === 0 || rt ? Af() : 536870912);
    var i = yr.current;
    return i !== null && (i.flags |= 32), vr;
  }
  function Jn(i, l, d) {
    (i === xt && (ut === 2 || ut === 9) || i.cancelPendingCommit !== null) && (Ps(i, 0), Ii(
      i,
      Ze,
      vr,
      !1
    )), fa(i, d), ((lt & 2) === 0 || i !== xt) && (i === xt && ((lt & 2) === 0 && (Aa |= d), Ot === 4 && Ii(
      i,
      Ze,
      vr,
      !1
    )), Zr(i));
  }
  function nE(i, l, d) {
    if ((lt & 6) !== 0) throw Error(r(327));
    var m = !d && (l & 124) === 0 && (l & i.expiredLanes) === 0 || Rn(i, l), b = m ? gI(i, l) : F0(i, l, !0), C = m;
    do {
      if (b === 0) {
        Ms && !m && Ii(i, l, 0, !1);
        break;
      } else {
        if (d = i.current.alternate, C && !pI(d)) {
          b = F0(i, l, !1), C = !1;
          continue;
        }
        if (b === 2) {
          if (C = l, i.errorRecoveryDisabledLanes & C)
            var D = 0;
          else
            D = i.pendingLanes & -536870913, D = D !== 0 ? D : D & 536870912 ? 536870912 : 0;
          if (D !== 0) {
            l = D;
            e: {
              var $ = i;
              b = Iu;
              var X = $.current.memoizedState.isDehydrated;
              if (X && (Ps($, D).flags |= 256), D = F0(
                $,
                D,
                !1
              ), D !== 2) {
                if (M0 && !X) {
                  $.errorRecoveryDisabledLanes |= C, Aa |= C, b = 4;
                  break e;
                }
                C = jn, jn = b, C !== null && (jn === null ? jn = C : jn.push.apply(
                  jn,
                  C
                ));
              }
              b = D;
            }
            if (C = !1, b !== 2) continue;
          }
        }
        if (b === 1) {
          Ps(i, 0), Ii(i, l, 0, !0);
          break;
        }
        e: {
          switch (m = i, C = b, C) {
            case 0:
            case 1:
              throw Error(r(345));
            case 4:
              if ((l & 4194048) !== l) break;
            case 6:
              Ii(
                m,
                l,
                vr,
                !Ni
              );
              break e;
            case 2:
              jn = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(r(329));
          }
          if ((l & 62914560) === l && (b = D0 + 300 - ct(), 10 < b)) {
            if (Ii(
              m,
              l,
              vr,
              !Ni
            ), $t(m, 0, !0) !== 0) break e;
            m.timeoutHandle = OE(
              rE.bind(
                null,
                m,
                d,
                jn,
                Ed,
                N0,
                l,
                vr,
                Aa,
                Os,
                Ni,
                C,
                2,
                -0,
                0
              ),
              b
            );
            break e;
          }
          rE(
            m,
            d,
            jn,
            Ed,
            N0,
            l,
            vr,
            Aa,
            Os,
            Ni,
            C,
            0,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    Zr(i);
  }
  function rE(i, l, d, m, b, C, D, $, X, ee, ue, fe, ne, re) {
    if (i.timeoutHandle = -1, fe = l.subtreeFlags, (fe & 8192 || (fe & 16785408) === 16785408) && (Uu = { stylesheets: null, count: 0, unsuspend: XI }, KS(l), fe = ZI(), fe !== null)) {
      i.cancelPendingCommit = fe(
        cE.bind(
          null,
          i,
          l,
          C,
          d,
          m,
          b,
          D,
          $,
          X,
          ue,
          1,
          ne,
          re
        )
      ), Ii(i, C, D, !ee);
      return;
    }
    cE(
      i,
      l,
      C,
      d,
      m,
      b,
      D,
      $,
      X
    );
  }
  function pI(i) {
    for (var l = i; ; ) {
      var d = l.tag;
      if ((d === 0 || d === 11 || d === 15) && l.flags & 16384 && (d = l.updateQueue, d !== null && (d = d.stores, d !== null)))
        for (var m = 0; m < d.length; m++) {
          var b = d[m], C = b.getSnapshot;
          b = b.value;
          try {
            if (!Yn(C(), b)) return !1;
          } catch {
            return !1;
          }
        }
      if (d = l.child, l.subtreeFlags & 16384 && d !== null)
        d.return = l, l = d;
      else {
        if (l === i) break;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === i) return !0;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
    }
    return !0;
  }
  function Ii(i, l, d, m) {
    l &= ~O0, l &= ~Aa, i.suspendedLanes |= l, i.pingedLanes &= ~l, m && (i.warmLanes |= l), m = i.expirationTimes;
    for (var b = l; 0 < b; ) {
      var C = 31 - De(b), D = 1 << C;
      m[C] = -1, b &= ~D;
    }
    d !== 0 && Mf(i, d, l);
  }
  function Cd() {
    return (lt & 6) === 0 ? (Lu(0), !1) : !0;
  }
  function z0() {
    if (Ge !== null) {
      if (ut === 0)
        var i = Ge.return;
      else
        i = Ge, jo = _a = null, e0(i), ks = null, Au = 0, i = Ge;
      for (; i !== null; )
        IS(i.alternate, i), i = i.return;
      Ge = null;
    }
  }
  function Ps(i, l) {
    var d = i.timeoutHandle;
    d !== -1 && (i.timeoutHandle = -1, NI(d)), d = i.cancelPendingCommit, d !== null && (i.cancelPendingCommit = null, d()), z0(), xt = i, Ge = d = No(i.current, null), Ze = l, ut = 0, Zn = null, Ni = !1, Ms = Rn(i, l), M0 = !1, Os = vr = O0 = Aa = Di = Ot = 0, jn = Iu = null, N0 = !1, (l & 8) !== 0 && (l |= l & 32);
    var m = i.entangledLanes;
    if (m !== 0)
      for (i = i.entanglements, m &= l; 0 < m; ) {
        var b = 31 - De(m), C = 1 << b;
        l |= i[b], m &= ~C;
      }
    return Vo = l, Yf(), d;
  }
  function oE(i, l) {
    He = null, I.H = dd, l === bu || l === nd ? (l = w_(), ut = 3) : l === v_ ? (l = w_(), ut = 4) : ut = l === _S ? 8 : l !== null && typeof l == "object" && typeof l.then == "function" ? 6 : 1, Zn = l, Ge === null && (Ot = 1, yd(
      i,
      hr(l, i.current)
    ));
  }
  function iE() {
    var i = I.H;
    return I.H = dd, i === null ? dd : i;
  }
  function aE() {
    var i = I.A;
    return I.A = dI, i;
  }
  function L0() {
    Ot = 4, Ni || (Ze & 4194048) !== Ze && yr.current !== null || (Ms = !0), (Di & 134217727) === 0 && (Aa & 134217727) === 0 || xt === null || Ii(
      xt,
      Ze,
      vr,
      !1
    );
  }
  function F0(i, l, d) {
    var m = lt;
    lt |= 2;
    var b = iE(), C = aE();
    (xt !== i || Ze !== l) && (Ed = null, Ps(i, l)), l = !1;
    var D = Ot;
    e: do
      try {
        if (ut !== 0 && Ge !== null) {
          var $ = Ge, X = Zn;
          switch (ut) {
            case 8:
              z0(), D = 6;
              break e;
            case 3:
            case 2:
            case 9:
            case 6:
              yr.current === null && (l = !0);
              var ee = ut;
              if (ut = 0, Zn = null, js(i, $, X, ee), d && Ms) {
                D = 0;
                break e;
              }
              break;
            default:
              ee = ut, ut = 0, Zn = null, js(i, $, X, ee);
          }
        }
        mI(), D = Ot;
        break;
      } catch (ue) {
        oE(i, ue);
      }
    while (!0);
    return l && i.shellSuspendCounter++, jo = _a = null, lt = m, I.H = b, I.A = C, Ge === null && (xt = null, Ze = 0, Yf()), D;
  }
  function mI() {
    for (; Ge !== null; ) sE(Ge);
  }
  function gI(i, l) {
    var d = lt;
    lt |= 2;
    var m = iE(), b = aE();
    xt !== i || Ze !== l ? (Ed = null, Sd = ct() + 500, Ps(i, l)) : Ms = Rn(
      i,
      l
    );
    e: do
      try {
        if (ut !== 0 && Ge !== null) {
          l = Ge;
          var C = Zn;
          t: switch (ut) {
            case 1:
              ut = 0, Zn = null, js(i, l, C, 1);
              break;
            case 2:
            case 9:
              if (b_(C)) {
                ut = 0, Zn = null, lE(l);
                break;
              }
              l = function() {
                ut !== 2 && ut !== 9 || xt !== i || (ut = 7), Zr(i);
              }, C.then(l, l);
              break e;
            case 3:
              ut = 7;
              break e;
            case 4:
              ut = 5;
              break e;
            case 7:
              b_(C) ? (ut = 0, Zn = null, lE(l)) : (ut = 0, Zn = null, js(i, l, C, 7));
              break;
            case 5:
              var D = null;
              switch (Ge.tag) {
                case 26:
                  D = Ge.memoizedState;
                case 5:
                case 27:
                  var $ = Ge;
                  if (!D || VE(D)) {
                    ut = 0, Zn = null;
                    var X = $.sibling;
                    if (X !== null) Ge = X;
                    else {
                      var ee = $.return;
                      ee !== null ? (Ge = ee, kd(ee)) : Ge = null;
                    }
                    break t;
                  }
              }
              ut = 0, Zn = null, js(i, l, C, 5);
              break;
            case 6:
              ut = 0, Zn = null, js(i, l, C, 6);
              break;
            case 8:
              z0(), Ot = 6;
              break e;
            default:
              throw Error(r(462));
          }
        }
        yI();
        break;
      } catch (ue) {
        oE(i, ue);
      }
    while (!0);
    return jo = _a = null, I.H = m, I.A = b, lt = d, Ge !== null ? 0 : (xt = null, Ze = 0, Yf(), Ot);
  }
  function yI() {
    for (; Ge !== null && !Xe(); )
      sE(Ge);
  }
  function sE(i) {
    var l = PS(i.alternate, i, Vo);
    i.memoizedProps = i.pendingProps, l === null ? kd(i) : Ge = l;
  }
  function lE(i) {
    var l = i, d = l.alternate;
    switch (l.tag) {
      case 15:
      case 0:
        l = AS(
          d,
          l,
          l.pendingProps,
          l.type,
          void 0,
          Ze
        );
        break;
      case 11:
        l = AS(
          d,
          l,
          l.pendingProps,
          l.type.render,
          l.ref,
          Ze
        );
        break;
      case 5:
        e0(l);
      default:
        IS(d, l), l = Ge = u_(l, Vo), l = PS(d, l, Vo);
    }
    i.memoizedProps = i.pendingProps, l === null ? kd(i) : Ge = l;
  }
  function js(i, l, d, m) {
    jo = _a = null, e0(l), ks = null, Au = 0;
    var b = l.return;
    try {
      if (aI(
        i,
        b,
        l,
        d,
        Ze
      )) {
        Ot = 1, yd(
          i,
          hr(d, i.current)
        ), Ge = null;
        return;
      }
    } catch (C) {
      if (b !== null) throw Ge = b, C;
      Ot = 1, yd(
        i,
        hr(d, i.current)
      ), Ge = null;
      return;
    }
    l.flags & 32768 ? (rt || m === 1 ? i = !0 : Ms || (Ze & 536870912) !== 0 ? i = !1 : (Ni = i = !0, (m === 2 || m === 9 || m === 3 || m === 6) && (m = yr.current, m !== null && m.tag === 13 && (m.flags |= 16384))), uE(l, i)) : kd(l);
  }
  function kd(i) {
    var l = i;
    do {
      if ((l.flags & 32768) !== 0) {
        uE(
          l,
          Ni
        );
        return;
      }
      i = l.return;
      var d = lI(
        l.alternate,
        l,
        Vo
      );
      if (d !== null) {
        Ge = d;
        return;
      }
      if (l = l.sibling, l !== null) {
        Ge = l;
        return;
      }
      Ge = l = i;
    } while (l !== null);
    Ot === 0 && (Ot = 5);
  }
  function uE(i, l) {
    do {
      var d = uI(i.alternate, i);
      if (d !== null) {
        d.flags &= 32767, Ge = d;
        return;
      }
      if (d = i.return, d !== null && (d.flags |= 32768, d.subtreeFlags = 0, d.deletions = null), !l && (i = i.sibling, i !== null)) {
        Ge = i;
        return;
      }
      Ge = i = d;
    } while (i !== null);
    Ot = 6, Ge = null;
  }
  function cE(i, l, d, m, b, C, D, $, X) {
    i.cancelPendingCommit = null;
    do
      Td();
    while (an !== 0);
    if ((lt & 6) !== 0) throw Error(r(327));
    if (l !== null) {
      if (l === i.current) throw Error(r(177));
      if (C = l.lanes | l.childLanes, C |= Rg, ng(
        i,
        d,
        C,
        D,
        $,
        X
      ), i === xt && (Ge = xt = null, Ze = 0), Ns = l, ji = i, Ds = d, P0 = C, j0 = b, eE = m, (l.subtreeFlags & 10256) !== 0 || (l.flags & 10256) !== 0 ? (i.callbackNode = null, i.callbackPriority = 0, wI(qn, function() {
        return mE(), null;
      })) : (i.callbackNode = null, i.callbackPriority = 0), m = (l.flags & 13878) !== 0, (l.subtreeFlags & 13878) !== 0 || m) {
        m = I.T, I.T = null, b = H.p, H.p = 2, D = lt, lt |= 4;
        try {
          cI(i, l, d);
        } finally {
          lt = D, H.p = b, I.T = m;
        }
      }
      an = 1, fE(), dE(), hE();
    }
  }
  function fE() {
    if (an === 1) {
      an = 0;
      var i = ji, l = Ns, d = (l.flags & 13878) !== 0;
      if ((l.subtreeFlags & 13878) !== 0 || d) {
        d = I.T, I.T = null;
        var m = H.p;
        H.p = 2;
        var b = lt;
        lt |= 4;
        try {
          YS(l, i);
          var C = Z0, D = Jw(i.containerInfo), $ = C.focusedElem, X = C.selectionRange;
          if (D !== $ && $ && $.ownerDocument && Qw(
            $.ownerDocument.documentElement,
            $
          )) {
            if (X !== null && Eg($)) {
              var ee = X.start, ue = X.end;
              if (ue === void 0 && (ue = ee), "selectionStart" in $)
                $.selectionStart = ee, $.selectionEnd = Math.min(
                  ue,
                  $.value.length
                );
              else {
                var fe = $.ownerDocument || document, ne = fe && fe.defaultView || window;
                if (ne.getSelection) {
                  var re = ne.getSelection(), Le = $.textContent.length, Pe = Math.min(X.start, Le), ht = X.end === void 0 ? Pe : Math.min(X.end, Le);
                  !re.extend && Pe > ht && (D = ht, ht = Pe, Pe = D);
                  var Q = Zw(
                    $,
                    Pe
                  ), K = Zw(
                    $,
                    ht
                  );
                  if (Q && K && (re.rangeCount !== 1 || re.anchorNode !== Q.node || re.anchorOffset !== Q.offset || re.focusNode !== K.node || re.focusOffset !== K.offset)) {
                    var J = fe.createRange();
                    J.setStart(Q.node, Q.offset), re.removeAllRanges(), Pe > ht ? (re.addRange(J), re.extend(K.node, K.offset)) : (J.setEnd(K.node, K.offset), re.addRange(J));
                  }
                }
              }
            }
            for (fe = [], re = $; re = re.parentNode; )
              re.nodeType === 1 && fe.push({
                element: re,
                left: re.scrollLeft,
                top: re.scrollTop
              });
            for (typeof $.focus == "function" && $.focus(), $ = 0; $ < fe.length; $++) {
              var ce = fe[$];
              ce.element.scrollLeft = ce.left, ce.element.scrollTop = ce.top;
            }
          }
          Fd = !!K0, Z0 = K0 = null;
        } finally {
          lt = b, H.p = m, I.T = d;
        }
      }
      i.current = l, an = 2;
    }
  }
  function dE() {
    if (an === 2) {
      an = 0;
      var i = ji, l = Ns, d = (l.flags & 8772) !== 0;
      if ((l.subtreeFlags & 8772) !== 0 || d) {
        d = I.T, I.T = null;
        var m = H.p;
        H.p = 2;
        var b = lt;
        lt |= 4;
        try {
          VS(i, l.alternate, l);
        } finally {
          lt = b, H.p = m, I.T = d;
        }
      }
      an = 3;
    }
  }
  function hE() {
    if (an === 4 || an === 3) {
      an = 0, St();
      var i = ji, l = Ns, d = Ds, m = eE;
      (l.subtreeFlags & 10256) !== 0 || (l.flags & 10256) !== 0 ? an = 5 : (an = 0, Ns = ji = null, pE(i, i.pendingLanes));
      var b = i.pendingLanes;
      if (b === 0 && (Pi = null), Xl(d), l = l.stateNode, pe && typeof pe.onCommitFiberRoot == "function")
        try {
          pe.onCommitFiberRoot(
            ae,
            l,
            void 0,
            (l.current.flags & 128) === 128
          );
        } catch {
        }
      if (m !== null) {
        l = I.T, b = H.p, H.p = 2, I.T = null;
        try {
          for (var C = i.onRecoverableError, D = 0; D < m.length; D++) {
            var $ = m[D];
            C($.value, {
              componentStack: $.stack
            });
          }
        } finally {
          I.T = l, H.p = b;
        }
      }
      (Ds & 3) !== 0 && Td(), Zr(i), b = i.pendingLanes, (d & 4194090) !== 0 && (b & 42) !== 0 ? i === I0 ? zu++ : (zu = 0, I0 = i) : zu = 0, Lu(0);
    }
  }
  function pE(i, l) {
    (i.pooledCacheLanes &= l) === 0 && (l = i.pooledCache, l != null && (i.pooledCache = null, yu(l)));
  }
  function Td(i) {
    return fE(), dE(), hE(), mE();
  }
  function mE() {
    if (an !== 5) return !1;
    var i = ji, l = P0;
    P0 = 0;
    var d = Xl(Ds), m = I.T, b = H.p;
    try {
      H.p = 32 > d ? 32 : d, I.T = null, d = j0, j0 = null;
      var C = ji, D = Ds;
      if (an = 0, Ns = ji = null, Ds = 0, (lt & 6) !== 0) throw Error(r(331));
      var $ = lt;
      if (lt |= 4, QS(C.current), XS(
        C,
        C.current,
        D,
        d
      ), lt = $, Lu(0, !1), pe && typeof pe.onPostCommitFiberRoot == "function")
        try {
          pe.onPostCommitFiberRoot(ae, C);
        } catch {
        }
      return !0;
    } finally {
      H.p = b, I.T = m, pE(i, l);
    }
  }
  function gE(i, l, d) {
    l = hr(d, l), l = p0(i.stateNode, l, 2), i = Ci(i, l, 2), i !== null && (fa(i, 2), Zr(i));
  }
  function mt(i, l, d) {
    if (i.tag === 3)
      gE(i, i, d);
    else
      for (; l !== null; ) {
        if (l.tag === 3) {
          gE(
            l,
            i,
            d
          );
          break;
        } else if (l.tag === 1) {
          var m = l.stateNode;
          if (typeof l.type.getDerivedStateFromError == "function" || typeof m.componentDidCatch == "function" && (Pi === null || !Pi.has(m))) {
            i = hr(d, i), d = xS(2), m = Ci(l, d, 2), m !== null && (wS(
              d,
              m,
              l,
              i
            ), fa(m, 2), Zr(m));
            break;
          }
        }
        l = l.return;
      }
  }
  function $0(i, l, d) {
    var m = i.pingCache;
    if (m === null) {
      m = i.pingCache = new hI();
      var b = /* @__PURE__ */ new Set();
      m.set(l, b);
    } else
      b = m.get(l), b === void 0 && (b = /* @__PURE__ */ new Set(), m.set(l, b));
    b.has(d) || (M0 = !0, b.add(d), i = vI.bind(null, i, l, d), l.then(i, i));
  }
  function vI(i, l, d) {
    var m = i.pingCache;
    m !== null && m.delete(l), i.pingedLanes |= i.suspendedLanes & d, i.warmLanes &= ~d, xt === i && (Ze & d) === d && (Ot === 4 || Ot === 3 && (Ze & 62914560) === Ze && 300 > ct() - D0 ? (lt & 2) === 0 && Ps(i, 0) : O0 |= d, Os === Ze && (Os = 0)), Zr(i);
  }
  function yE(i, l) {
    l === 0 && (l = Rf()), i = gs(i, l), i !== null && (fa(i, l), Zr(i));
  }
  function bI(i) {
    var l = i.memoizedState, d = 0;
    l !== null && (d = l.retryLane), yE(i, d);
  }
  function xI(i, l) {
    var d = 0;
    switch (i.tag) {
      case 13:
        var m = i.stateNode, b = i.memoizedState;
        b !== null && (d = b.retryLane);
        break;
      case 19:
        m = i.stateNode;
        break;
      case 22:
        m = i.stateNode._retryCache;
        break;
      default:
        throw Error(r(314));
    }
    m !== null && m.delete(l), yE(i, d);
  }
  function wI(i, l) {
    return Ee(i, l);
  }
  var Ad = null, Is = null, B0 = !1, Rd = !1, H0 = !1, Ra = 0;
  function Zr(i) {
    i !== Is && i.next === null && (Is === null ? Ad = Is = i : Is = Is.next = i), Rd = !0, B0 || (B0 = !0, SI());
  }
  function Lu(i, l) {
    if (!H0 && Rd) {
      H0 = !0;
      do
        for (var d = !1, m = Ad; m !== null; ) {
          if (i !== 0) {
            var b = m.pendingLanes;
            if (b === 0) var C = 0;
            else {
              var D = m.suspendedLanes, $ = m.pingedLanes;
              C = (1 << 31 - De(42 | i) + 1) - 1, C &= b & ~(D & ~$), C = C & 201326741 ? C & 201326741 | 1 : C ? C | 2 : 0;
            }
            C !== 0 && (d = !0, wE(m, C));
          } else
            C = Ze, C = $t(
              m,
              m === xt ? C : 0,
              m.cancelPendingCommit !== null || m.timeoutHandle !== -1
            ), (C & 3) === 0 || Rn(m, C) || (d = !0, wE(m, C));
          m = m.next;
        }
      while (d);
      H0 = !1;
    }
  }
  function _I() {
    vE();
  }
  function vE() {
    Rd = B0 = !1;
    var i = 0;
    Ra !== 0 && (OI() && (i = Ra), Ra = 0);
    for (var l = ct(), d = null, m = Ad; m !== null; ) {
      var b = m.next, C = bE(m, l);
      C === 0 ? (m.next = null, d === null ? Ad = b : d.next = b, b === null && (Is = d)) : (d = m, (i !== 0 || (C & 3) !== 0) && (Rd = !0)), m = b;
    }
    Lu(i);
  }
  function bE(i, l) {
    for (var d = i.suspendedLanes, m = i.pingedLanes, b = i.expirationTimes, C = i.pendingLanes & -62914561; 0 < C; ) {
      var D = 31 - De(C), $ = 1 << D, X = b[D];
      X === -1 ? (($ & d) === 0 || ($ & m) !== 0) && (b[D] = Gn($, l)) : X <= l && (i.expiredLanes |= $), C &= ~$;
    }
    if (l = xt, d = Ze, d = $t(
      i,
      i === l ? d : 0,
      i.cancelPendingCommit !== null || i.timeoutHandle !== -1
    ), m = i.callbackNode, d === 0 || i === l && (ut === 2 || ut === 9) || i.cancelPendingCommit !== null)
      return m !== null && m !== null && _e(m), i.callbackNode = null, i.callbackPriority = 0;
    if ((d & 3) === 0 || Rn(i, d)) {
      if (l = d & -d, l === i.callbackPriority) return l;
      switch (m !== null && _e(m), Xl(d)) {
        case 2:
        case 8:
          d = Un;
          break;
        case 32:
          d = qn;
          break;
        case 268435456:
          d = qr;
          break;
        default:
          d = qn;
      }
      return m = xE.bind(null, i), d = Ee(d, m), i.callbackPriority = l, i.callbackNode = d, l;
    }
    return m !== null && m !== null && _e(m), i.callbackPriority = 2, i.callbackNode = null, 2;
  }
  function xE(i, l) {
    if (an !== 0 && an !== 5)
      return i.callbackNode = null, i.callbackPriority = 0, null;
    var d = i.callbackNode;
    if (Td() && i.callbackNode !== d)
      return null;
    var m = Ze;
    return m = $t(
      i,
      i === xt ? m : 0,
      i.cancelPendingCommit !== null || i.timeoutHandle !== -1
    ), m === 0 ? null : (nE(i, m, l), bE(i, ct()), i.callbackNode != null && i.callbackNode === d ? xE.bind(null, i) : null);
  }
  function wE(i, l) {
    if (Td()) return null;
    nE(i, l, !0);
  }
  function SI() {
    DI(function() {
      (lt & 6) !== 0 ? Ee(
        fr,
        _I
      ) : vE();
    });
  }
  function V0() {
    return Ra === 0 && (Ra = Af()), Ra;
  }
  function _E(i) {
    return i == null || typeof i == "symbol" || typeof i == "boolean" ? null : typeof i == "function" ? i : $f("" + i);
  }
  function SE(i, l) {
    var d = l.ownerDocument.createElement("input");
    return d.name = l.name, d.value = l.value, i.id && d.setAttribute("form", i.id), l.parentNode.insertBefore(d, l), i = new FormData(i), d.parentNode.removeChild(d), i;
  }
  function EI(i, l, d, m, b) {
    if (l === "submit" && d && d.stateNode === b) {
      var C = _E(
        (b[dn] || null).action
      ), D = m.submitter;
      D && (l = (l = D[dn] || null) ? _E(l.formAction) : D.getAttribute("formAction"), l !== null && (C = l, D = null));
      var $ = new Uf(
        "action",
        "action",
        null,
        m,
        b
      );
      i.push({
        event: $,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (m.defaultPrevented) {
                if (Ra !== 0) {
                  var X = D ? SE(b, D) : new FormData(b);
                  u0(
                    d,
                    {
                      pending: !0,
                      data: X,
                      method: b.method,
                      action: C
                    },
                    null,
                    X
                  );
                }
              } else
                typeof C == "function" && ($.preventDefault(), X = D ? SE(b, D) : new FormData(b), u0(
                  d,
                  {
                    pending: !0,
                    data: X,
                    method: b.method,
                    action: C
                  },
                  C,
                  X
                ));
            },
            currentTarget: b
          }
        ]
      });
    }
  }
  for (var U0 = 0; U0 < Ag.length; U0++) {
    var q0 = Ag[U0], CI = q0.toLowerCase(), kI = q0[0].toUpperCase() + q0.slice(1);
    Mr(
      CI,
      "on" + kI
    );
  }
  Mr(n_, "onAnimationEnd"), Mr(r_, "onAnimationIteration"), Mr(o_, "onAnimationStart"), Mr("dblclick", "onDoubleClick"), Mr("focusin", "onFocus"), Mr("focusout", "onBlur"), Mr(Vj, "onTransitionRun"), Mr(Uj, "onTransitionStart"), Mr(qj, "onTransitionCancel"), Mr(i_, "onTransitionEnd"), xi("onMouseEnter", ["mouseout", "mouseover"]), xi("onMouseLeave", ["mouseout", "mouseover"]), xi("onPointerEnter", ["pointerout", "pointerover"]), xi("onPointerLeave", ["pointerout", "pointerover"]), Ao(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), Ao(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), Ao("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), Ao(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), Ao(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), Ao(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var Fu = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), TI = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Fu)
  );
  function EE(i, l) {
    l = (l & 4) !== 0;
    for (var d = 0; d < i.length; d++) {
      var m = i[d], b = m.event;
      m = m.listeners;
      e: {
        var C = void 0;
        if (l)
          for (var D = m.length - 1; 0 <= D; D--) {
            var $ = m[D], X = $.instance, ee = $.currentTarget;
            if ($ = $.listener, X !== C && b.isPropagationStopped())
              break e;
            C = $, b.currentTarget = ee;
            try {
              C(b);
            } catch (ue) {
              gd(ue);
            }
            b.currentTarget = null, C = X;
          }
        else
          for (D = 0; D < m.length; D++) {
            if ($ = m[D], X = $.instance, ee = $.currentTarget, $ = $.listener, X !== C && b.isPropagationStopped())
              break e;
            C = $, b.currentTarget = ee;
            try {
              C(b);
            } catch (ue) {
              gd(ue);
            }
            b.currentTarget = null, C = X;
          }
      }
    }
  }
  function Ye(i, l) {
    var d = l[Kl];
    d === void 0 && (d = l[Kl] = /* @__PURE__ */ new Set());
    var m = i + "__bubble";
    d.has(m) || (CE(l, i, 2, !1), d.add(m));
  }
  function G0(i, l, d) {
    var m = 0;
    l && (m |= 4), CE(
      d,
      i,
      m,
      l
    );
  }
  var Md = "_reactListening" + Math.random().toString(36).slice(2);
  function Y0(i) {
    if (!i[Md]) {
      i[Md] = !0, Df.forEach(function(d) {
        d !== "selectionchange" && (TI.has(d) || G0(d, !1, i), G0(d, !0, i));
      });
      var l = i.nodeType === 9 ? i : i.ownerDocument;
      l === null || l[Md] || (l[Md] = !0, G0("selectionchange", !1, l));
    }
  }
  function CE(i, l, d, m) {
    switch (XE(l)) {
      case 2:
        var b = e6;
        break;
      case 8:
        b = t6;
        break;
      default:
        b = sy;
    }
    d = b.bind(
      null,
      l,
      d,
      i
    ), b = void 0, !mg || l !== "touchstart" && l !== "touchmove" && l !== "wheel" || (b = !0), m ? b !== void 0 ? i.addEventListener(l, d, {
      capture: !0,
      passive: b
    }) : i.addEventListener(l, d, !0) : b !== void 0 ? i.addEventListener(l, d, {
      passive: b
    }) : i.addEventListener(l, d, !1);
  }
  function W0(i, l, d, m, b) {
    var C = m;
    if ((l & 1) === 0 && (l & 2) === 0 && m !== null)
      e: for (; ; ) {
        if (m === null) return;
        var D = m.tag;
        if (D === 3 || D === 4) {
          var $ = m.stateNode.containerInfo;
          if ($ === b) break;
          if (D === 4)
            for (D = m.return; D !== null; ) {
              var X = D.tag;
              if ((X === 3 || X === 4) && D.stateNode.containerInfo === b)
                return;
              D = D.return;
            }
          for (; $ !== null; ) {
            if (D = vi($), D === null) return;
            if (X = D.tag, X === 5 || X === 6 || X === 26 || X === 27) {
              m = C = D;
              continue e;
            }
            $ = $.parentNode;
          }
        }
        m = m.return;
      }
    Nw(function() {
      var ee = C, ue = hg(d), fe = [];
      e: {
        var ne = a_.get(i);
        if (ne !== void 0) {
          var re = Uf, Le = i;
          switch (i) {
            case "keypress":
              if (Hf(d) === 0) break e;
            case "keydown":
            case "keyup":
              re = wj;
              break;
            case "focusin":
              Le = "focus", re = bg;
              break;
            case "focusout":
              Le = "blur", re = bg;
              break;
            case "beforeblur":
            case "afterblur":
              re = bg;
              break;
            case "click":
              if (d.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              re = jw;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              re = uj;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              re = Ej;
              break;
            case n_:
            case r_:
            case o_:
              re = dj;
              break;
            case i_:
              re = kj;
              break;
            case "scroll":
            case "scrollend":
              re = sj;
              break;
            case "wheel":
              re = Aj;
              break;
            case "copy":
            case "cut":
            case "paste":
              re = pj;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              re = zw;
              break;
            case "toggle":
            case "beforetoggle":
              re = Mj;
          }
          var Pe = (l & 4) !== 0, ht = !Pe && (i === "scroll" || i === "scrollend"), Q = Pe ? ne !== null ? ne + "Capture" : null : ne;
          Pe = [];
          for (var K = ee, J; K !== null; ) {
            var ce = K;
            if (J = ce.stateNode, ce = ce.tag, ce !== 5 && ce !== 26 && ce !== 27 || J === null || Q === null || (ce = ou(K, Q), ce != null && Pe.push(
              $u(K, ce, J)
            )), ht) break;
            K = K.return;
          }
          0 < Pe.length && (ne = new re(
            ne,
            Le,
            null,
            d,
            ue
          ), fe.push({ event: ne, listeners: Pe }));
        }
      }
      if ((l & 7) === 0) {
        e: {
          if (ne = i === "mouseover" || i === "pointerover", re = i === "mouseout" || i === "pointerout", ne && d !== dg && (Le = d.relatedTarget || d.fromElement) && (vi(Le) || Le[yi]))
            break e;
          if ((re || ne) && (ne = ue.window === ue ? ue : (ne = ue.ownerDocument) ? ne.defaultView || ne.parentWindow : window, re ? (Le = d.relatedTarget || d.toElement, re = ee, Le = Le ? vi(Le) : null, Le !== null && (ht = a(Le), Pe = Le.tag, Le !== ht || Pe !== 5 && Pe !== 27 && Pe !== 6) && (Le = null)) : (re = null, Le = ee), re !== Le)) {
            if (Pe = jw, ce = "onMouseLeave", Q = "onMouseEnter", K = "mouse", (i === "pointerout" || i === "pointerover") && (Pe = zw, ce = "onPointerLeave", Q = "onPointerEnter", K = "pointer"), ht = re == null ? ne : bi(re), J = Le == null ? ne : bi(Le), ne = new Pe(
              ce,
              K + "leave",
              re,
              d,
              ue
            ), ne.target = ht, ne.relatedTarget = J, ce = null, vi(ue) === ee && (Pe = new Pe(
              Q,
              K + "enter",
              Le,
              d,
              ue
            ), Pe.target = J, Pe.relatedTarget = ht, ce = Pe), ht = ce, re && Le)
              t: {
                for (Pe = re, Q = Le, K = 0, J = Pe; J; J = zs(J))
                  K++;
                for (J = 0, ce = Q; ce; ce = zs(ce))
                  J++;
                for (; 0 < K - J; )
                  Pe = zs(Pe), K--;
                for (; 0 < J - K; )
                  Q = zs(Q), J--;
                for (; K--; ) {
                  if (Pe === Q || Q !== null && Pe === Q.alternate)
                    break t;
                  Pe = zs(Pe), Q = zs(Q);
                }
                Pe = null;
              }
            else Pe = null;
            re !== null && kE(
              fe,
              ne,
              re,
              Pe,
              !1
            ), Le !== null && ht !== null && kE(
              fe,
              ht,
              Le,
              Pe,
              !0
            );
          }
        }
        e: {
          if (ne = ee ? bi(ee) : window, re = ne.nodeName && ne.nodeName.toLowerCase(), re === "select" || re === "input" && ne.type === "file")
            var be = qw;
          else if (Vw(ne))
            if (Gw)
              be = $j;
            else {
              be = Lj;
              var Ue = zj;
            }
          else
            re = ne.nodeName, !re || re.toLowerCase() !== "input" || ne.type !== "checkbox" && ne.type !== "radio" ? ee && fg(ee.elementType) && (be = qw) : be = Fj;
          if (be && (be = be(i, ee))) {
            Uw(
              fe,
              be,
              d,
              ue
            );
            break e;
          }
          Ue && Ue(i, ne, ee), i === "focusout" && ee && ne.type === "number" && ee.memoizedProps.value != null && ru(ne, "number", ne.value);
        }
        switch (Ue = ee ? bi(ee) : window, i) {
          case "focusin":
            (Vw(Ue) || Ue.contentEditable === "true") && (hs = Ue, Cg = ee, du = null);
            break;
          case "focusout":
            du = Cg = hs = null;
            break;
          case "mousedown":
            kg = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            kg = !1, e_(fe, d, ue);
            break;
          case "selectionchange":
            if (Hj) break;
          case "keydown":
          case "keyup":
            e_(fe, d, ue);
        }
        var Se;
        if (wg)
          e: {
            switch (i) {
              case "compositionstart":
                var Ie = "onCompositionStart";
                break e;
              case "compositionend":
                Ie = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Ie = "onCompositionUpdate";
                break e;
            }
            Ie = void 0;
          }
        else
          ds ? Bw(i, d) && (Ie = "onCompositionEnd") : i === "keydown" && d.keyCode === 229 && (Ie = "onCompositionStart");
        Ie && (Lw && d.locale !== "ko" && (ds || Ie !== "onCompositionStart" ? Ie === "onCompositionEnd" && ds && (Se = Dw()) : (wi = ue, gg = "value" in wi ? wi.value : wi.textContent, ds = !0)), Ue = Od(ee, Ie), 0 < Ue.length && (Ie = new Iw(
          Ie,
          i,
          null,
          d,
          ue
        ), fe.push({ event: Ie, listeners: Ue }), Se ? Ie.data = Se : (Se = Hw(d), Se !== null && (Ie.data = Se)))), (Se = Nj ? Dj(i, d) : Pj(i, d)) && (Ie = Od(ee, "onBeforeInput"), 0 < Ie.length && (Ue = new Iw(
          "onBeforeInput",
          "beforeinput",
          null,
          d,
          ue
        ), fe.push({
          event: Ue,
          listeners: Ie
        }), Ue.data = Se)), EI(
          fe,
          i,
          ee,
          d,
          ue
        );
      }
      EE(fe, l);
    });
  }
  function $u(i, l, d) {
    return {
      instance: i,
      listener: l,
      currentTarget: d
    };
  }
  function Od(i, l) {
    for (var d = l + "Capture", m = []; i !== null; ) {
      var b = i, C = b.stateNode;
      if (b = b.tag, b !== 5 && b !== 26 && b !== 27 || C === null || (b = ou(i, d), b != null && m.unshift(
        $u(i, b, C)
      ), b = ou(i, l), b != null && m.push(
        $u(i, b, C)
      )), i.tag === 3) return m;
      i = i.return;
    }
    return [];
  }
  function zs(i) {
    if (i === null) return null;
    do
      i = i.return;
    while (i && i.tag !== 5 && i.tag !== 27);
    return i || null;
  }
  function kE(i, l, d, m, b) {
    for (var C = l._reactName, D = []; d !== null && d !== m; ) {
      var $ = d, X = $.alternate, ee = $.stateNode;
      if ($ = $.tag, X !== null && X === m) break;
      $ !== 5 && $ !== 26 && $ !== 27 || ee === null || (X = ee, b ? (ee = ou(d, C), ee != null && D.unshift(
        $u(d, ee, X)
      )) : b || (ee = ou(d, C), ee != null && D.push(
        $u(d, ee, X)
      ))), d = d.return;
    }
    D.length !== 0 && i.push({ event: l, listeners: D });
  }
  var AI = /\r\n?/g, RI = /\u0000|\uFFFD/g;
  function TE(i) {
    return (typeof i == "string" ? i : "" + i).replace(AI, `
`).replace(RI, "");
  }
  function AE(i, l) {
    return l = TE(l), TE(i) === l;
  }
  function Nd() {
  }
  function dt(i, l, d, m, b, C) {
    switch (d) {
      case "children":
        typeof m == "string" ? l === "body" || l === "textarea" && m === "" || us(i, m) : (typeof m == "number" || typeof m == "bigint") && l !== "body" && us(i, "" + m);
        break;
      case "className":
        as(i, "class", m);
        break;
      case "tabIndex":
        as(i, "tabindex", m);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        as(i, d, m);
        break;
      case "style":
        Mw(i, m, C);
        break;
      case "data":
        if (l !== "object") {
          as(i, "data", m);
          break;
        }
      case "src":
      case "href":
        if (m === "" && (l !== "a" || d !== "href")) {
          i.removeAttribute(d);
          break;
        }
        if (m == null || typeof m == "function" || typeof m == "symbol" || typeof m == "boolean") {
          i.removeAttribute(d);
          break;
        }
        m = $f("" + m), i.setAttribute(d, m);
        break;
      case "action":
      case "formAction":
        if (typeof m == "function") {
          i.setAttribute(
            d,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof C == "function" && (d === "formAction" ? (l !== "input" && dt(i, l, "name", b.name, b, null), dt(
            i,
            l,
            "formEncType",
            b.formEncType,
            b,
            null
          ), dt(
            i,
            l,
            "formMethod",
            b.formMethod,
            b,
            null
          ), dt(
            i,
            l,
            "formTarget",
            b.formTarget,
            b,
            null
          )) : (dt(i, l, "encType", b.encType, b, null), dt(i, l, "method", b.method, b, null), dt(i, l, "target", b.target, b, null)));
        if (m == null || typeof m == "symbol" || typeof m == "boolean") {
          i.removeAttribute(d);
          break;
        }
        m = $f("" + m), i.setAttribute(d, m);
        break;
      case "onClick":
        m != null && (i.onclick = Nd);
        break;
      case "onScroll":
        m != null && Ye("scroll", i);
        break;
      case "onScrollEnd":
        m != null && Ye("scrollend", i);
        break;
      case "dangerouslySetInnerHTML":
        if (m != null) {
          if (typeof m != "object" || !("__html" in m))
            throw Error(r(61));
          if (d = m.__html, d != null) {
            if (b.children != null) throw Error(r(60));
            i.innerHTML = d;
          }
        }
        break;
      case "multiple":
        i.multiple = m && typeof m != "function" && typeof m != "symbol";
        break;
      case "muted":
        i.muted = m && typeof m != "function" && typeof m != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (m == null || typeof m == "function" || typeof m == "boolean" || typeof m == "symbol") {
          i.removeAttribute("xlink:href");
          break;
        }
        d = $f("" + m), i.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          d
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        m != null && typeof m != "function" && typeof m != "symbol" ? i.setAttribute(d, "" + m) : i.removeAttribute(d);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        m && typeof m != "function" && typeof m != "symbol" ? i.setAttribute(d, "") : i.removeAttribute(d);
        break;
      case "capture":
      case "download":
        m === !0 ? i.setAttribute(d, "") : m !== !1 && m != null && typeof m != "function" && typeof m != "symbol" ? i.setAttribute(d, m) : i.removeAttribute(d);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        m != null && typeof m != "function" && typeof m != "symbol" && !isNaN(m) && 1 <= m ? i.setAttribute(d, m) : i.removeAttribute(d);
        break;
      case "rowSpan":
      case "start":
        m == null || typeof m == "function" || typeof m == "symbol" || isNaN(m) ? i.removeAttribute(d) : i.setAttribute(d, m);
        break;
      case "popover":
        Ye("beforetoggle", i), Ye("toggle", i), is(i, "popover", m);
        break;
      case "xlinkActuate":
        Rr(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          m
        );
        break;
      case "xlinkArcrole":
        Rr(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          m
        );
        break;
      case "xlinkRole":
        Rr(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          m
        );
        break;
      case "xlinkShow":
        Rr(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          m
        );
        break;
      case "xlinkTitle":
        Rr(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          m
        );
        break;
      case "xlinkType":
        Rr(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          m
        );
        break;
      case "xmlBase":
        Rr(
          i,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          m
        );
        break;
      case "xmlLang":
        Rr(
          i,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          m
        );
        break;
      case "xmlSpace":
        Rr(
          i,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          m
        );
        break;
      case "is":
        is(i, "is", m);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < d.length) || d[0] !== "o" && d[0] !== "O" || d[1] !== "n" && d[1] !== "N") && (d = ij.get(d) || d, is(i, d, m));
    }
  }
  function X0(i, l, d, m, b, C) {
    switch (d) {
      case "style":
        Mw(i, m, C);
        break;
      case "dangerouslySetInnerHTML":
        if (m != null) {
          if (typeof m != "object" || !("__html" in m))
            throw Error(r(61));
          if (d = m.__html, d != null) {
            if (b.children != null) throw Error(r(60));
            i.innerHTML = d;
          }
        }
        break;
      case "children":
        typeof m == "string" ? us(i, m) : (typeof m == "number" || typeof m == "bigint") && us(i, "" + m);
        break;
      case "onScroll":
        m != null && Ye("scroll", i);
        break;
      case "onScrollEnd":
        m != null && Ye("scrollend", i);
        break;
      case "onClick":
        m != null && (i.onclick = Nd);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!Pf.hasOwnProperty(d))
          e: {
            if (d[0] === "o" && d[1] === "n" && (b = d.endsWith("Capture"), l = d.slice(2, b ? d.length - 7 : void 0), C = i[dn] || null, C = C != null ? C[d] : null, typeof C == "function" && i.removeEventListener(l, C, b), typeof m == "function")) {
              typeof C != "function" && C !== null && (d in i ? i[d] = null : i.hasAttribute(d) && i.removeAttribute(d)), i.addEventListener(l, m, b);
              break e;
            }
            d in i ? i[d] = m : m === !0 ? i.setAttribute(d, "") : is(i, d, m);
          }
    }
  }
  function sn(i, l, d) {
    switch (l) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        Ye("error", i), Ye("load", i);
        var m = !1, b = !1, C;
        for (C in d)
          if (d.hasOwnProperty(C)) {
            var D = d[C];
            if (D != null)
              switch (C) {
                case "src":
                  m = !0;
                  break;
                case "srcSet":
                  b = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(r(137, l));
                default:
                  dt(i, l, C, D, d, null);
              }
          }
        b && dt(i, l, "srcSet", d.srcSet, d, null), m && dt(i, l, "src", d.src, d, null);
        return;
      case "input":
        Ye("invalid", i);
        var $ = C = D = b = null, X = null, ee = null;
        for (m in d)
          if (d.hasOwnProperty(m)) {
            var ue = d[m];
            if (ue != null)
              switch (m) {
                case "name":
                  b = ue;
                  break;
                case "type":
                  D = ue;
                  break;
                case "checked":
                  X = ue;
                  break;
                case "defaultChecked":
                  ee = ue;
                  break;
                case "value":
                  C = ue;
                  break;
                case "defaultValue":
                  $ = ue;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (ue != null)
                    throw Error(r(137, l));
                  break;
                default:
                  dt(i, l, m, ue, d, null);
              }
          }
        Ff(
          i,
          C,
          $,
          X,
          ee,
          D,
          b,
          !1
        ), ss(i);
        return;
      case "select":
        Ye("invalid", i), m = D = C = null;
        for (b in d)
          if (d.hasOwnProperty(b) && ($ = d[b], $ != null))
            switch (b) {
              case "value":
                C = $;
                break;
              case "defaultValue":
                D = $;
                break;
              case "multiple":
                m = $;
              default:
                dt(i, l, b, $, d, null);
            }
        l = C, d = D, i.multiple = !!m, l != null ? Mo(i, !!m, l, !1) : d != null && Mo(i, !!m, d, !0);
        return;
      case "textarea":
        Ye("invalid", i), C = b = m = null;
        for (D in d)
          if (d.hasOwnProperty(D) && ($ = d[D], $ != null))
            switch (D) {
              case "value":
                m = $;
                break;
              case "defaultValue":
                b = $;
                break;
              case "children":
                C = $;
                break;
              case "dangerouslySetInnerHTML":
                if ($ != null) throw Error(r(91));
                break;
              default:
                dt(i, l, D, $, d, null);
            }
        Aw(i, m, b, C), ss(i);
        return;
      case "option":
        for (X in d)
          if (d.hasOwnProperty(X) && (m = d[X], m != null))
            switch (X) {
              case "selected":
                i.selected = m && typeof m != "function" && typeof m != "symbol";
                break;
              default:
                dt(i, l, X, m, d, null);
            }
        return;
      case "dialog":
        Ye("beforetoggle", i), Ye("toggle", i), Ye("cancel", i), Ye("close", i);
        break;
      case "iframe":
      case "object":
        Ye("load", i);
        break;
      case "video":
      case "audio":
        for (m = 0; m < Fu.length; m++)
          Ye(Fu[m], i);
        break;
      case "image":
        Ye("error", i), Ye("load", i);
        break;
      case "details":
        Ye("toggle", i);
        break;
      case "embed":
      case "source":
      case "link":
        Ye("error", i), Ye("load", i);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (ee in d)
          if (d.hasOwnProperty(ee) && (m = d[ee], m != null))
            switch (ee) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(r(137, l));
              default:
                dt(i, l, ee, m, d, null);
            }
        return;
      default:
        if (fg(l)) {
          for (ue in d)
            d.hasOwnProperty(ue) && (m = d[ue], m !== void 0 && X0(
              i,
              l,
              ue,
              m,
              d,
              void 0
            ));
          return;
        }
    }
    for ($ in d)
      d.hasOwnProperty($) && (m = d[$], m != null && dt(i, l, $, m, d, null));
  }
  function MI(i, l, d, m) {
    switch (l) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var b = null, C = null, D = null, $ = null, X = null, ee = null, ue = null;
        for (re in d) {
          var fe = d[re];
          if (d.hasOwnProperty(re) && fe != null)
            switch (re) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                X = fe;
              default:
                m.hasOwnProperty(re) || dt(i, l, re, null, m, fe);
            }
        }
        for (var ne in m) {
          var re = m[ne];
          if (fe = d[ne], m.hasOwnProperty(ne) && (re != null || fe != null))
            switch (ne) {
              case "type":
                C = re;
                break;
              case "name":
                b = re;
                break;
              case "checked":
                ee = re;
                break;
              case "defaultChecked":
                ue = re;
                break;
              case "value":
                D = re;
                break;
              case "defaultValue":
                $ = re;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (re != null)
                  throw Error(r(137, l));
                break;
              default:
                re !== fe && dt(
                  i,
                  l,
                  ne,
                  re,
                  m,
                  fe
                );
            }
        }
        ha(
          i,
          D,
          $,
          X,
          ee,
          ue,
          C,
          b
        );
        return;
      case "select":
        re = D = $ = ne = null;
        for (C in d)
          if (X = d[C], d.hasOwnProperty(C) && X != null)
            switch (C) {
              case "value":
                break;
              case "multiple":
                re = X;
              default:
                m.hasOwnProperty(C) || dt(
                  i,
                  l,
                  C,
                  null,
                  m,
                  X
                );
            }
        for (b in m)
          if (C = m[b], X = d[b], m.hasOwnProperty(b) && (C != null || X != null))
            switch (b) {
              case "value":
                ne = C;
                break;
              case "defaultValue":
                $ = C;
                break;
              case "multiple":
                D = C;
              default:
                C !== X && dt(
                  i,
                  l,
                  b,
                  C,
                  m,
                  X
                );
            }
        l = $, d = D, m = re, ne != null ? Mo(i, !!d, ne, !1) : !!m != !!d && (l != null ? Mo(i, !!d, l, !0) : Mo(i, !!d, d ? [] : "", !1));
        return;
      case "textarea":
        re = ne = null;
        for ($ in d)
          if (b = d[$], d.hasOwnProperty($) && b != null && !m.hasOwnProperty($))
            switch ($) {
              case "value":
                break;
              case "children":
                break;
              default:
                dt(i, l, $, null, m, b);
            }
        for (D in m)
          if (b = m[D], C = d[D], m.hasOwnProperty(D) && (b != null || C != null))
            switch (D) {
              case "value":
                ne = b;
                break;
              case "defaultValue":
                re = b;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (b != null) throw Error(r(91));
                break;
              default:
                b !== C && dt(i, l, D, b, m, C);
            }
        Tw(i, ne, re);
        return;
      case "option":
        for (var Le in d)
          if (ne = d[Le], d.hasOwnProperty(Le) && ne != null && !m.hasOwnProperty(Le))
            switch (Le) {
              case "selected":
                i.selected = !1;
                break;
              default:
                dt(
                  i,
                  l,
                  Le,
                  null,
                  m,
                  ne
                );
            }
        for (X in m)
          if (ne = m[X], re = d[X], m.hasOwnProperty(X) && ne !== re && (ne != null || re != null))
            switch (X) {
              case "selected":
                i.selected = ne && typeof ne != "function" && typeof ne != "symbol";
                break;
              default:
                dt(
                  i,
                  l,
                  X,
                  ne,
                  m,
                  re
                );
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var Pe in d)
          ne = d[Pe], d.hasOwnProperty(Pe) && ne != null && !m.hasOwnProperty(Pe) && dt(i, l, Pe, null, m, ne);
        for (ee in m)
          if (ne = m[ee], re = d[ee], m.hasOwnProperty(ee) && ne !== re && (ne != null || re != null))
            switch (ee) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (ne != null)
                  throw Error(r(137, l));
                break;
              default:
                dt(
                  i,
                  l,
                  ee,
                  ne,
                  m,
                  re
                );
            }
        return;
      default:
        if (fg(l)) {
          for (var ht in d)
            ne = d[ht], d.hasOwnProperty(ht) && ne !== void 0 && !m.hasOwnProperty(ht) && X0(
              i,
              l,
              ht,
              void 0,
              m,
              ne
            );
          for (ue in m)
            ne = m[ue], re = d[ue], !m.hasOwnProperty(ue) || ne === re || ne === void 0 && re === void 0 || X0(
              i,
              l,
              ue,
              ne,
              m,
              re
            );
          return;
        }
    }
    for (var Q in d)
      ne = d[Q], d.hasOwnProperty(Q) && ne != null && !m.hasOwnProperty(Q) && dt(i, l, Q, null, m, ne);
    for (fe in m)
      ne = m[fe], re = d[fe], !m.hasOwnProperty(fe) || ne === re || ne == null && re == null || dt(i, l, fe, ne, m, re);
  }
  var K0 = null, Z0 = null;
  function Dd(i) {
    return i.nodeType === 9 ? i : i.ownerDocument;
  }
  function RE(i) {
    switch (i) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function ME(i, l) {
    if (i === 0)
      switch (l) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return i === 1 && l === "foreignObject" ? 0 : i;
  }
  function Q0(i, l) {
    return i === "textarea" || i === "noscript" || typeof l.children == "string" || typeof l.children == "number" || typeof l.children == "bigint" || typeof l.dangerouslySetInnerHTML == "object" && l.dangerouslySetInnerHTML !== null && l.dangerouslySetInnerHTML.__html != null;
  }
  var J0 = null;
  function OI() {
    var i = window.event;
    return i && i.type === "popstate" ? i === J0 ? !1 : (J0 = i, !0) : (J0 = null, !1);
  }
  var OE = typeof setTimeout == "function" ? setTimeout : void 0, NI = typeof clearTimeout == "function" ? clearTimeout : void 0, NE = typeof Promise == "function" ? Promise : void 0, DI = typeof queueMicrotask == "function" ? queueMicrotask : typeof NE < "u" ? function(i) {
    return NE.resolve(null).then(i).catch(PI);
  } : OE;
  function PI(i) {
    setTimeout(function() {
      throw i;
    });
  }
  function zi(i) {
    return i === "head";
  }
  function DE(i, l) {
    var d = l, m = 0, b = 0;
    do {
      var C = d.nextSibling;
      if (i.removeChild(d), C && C.nodeType === 8)
        if (d = C.data, d === "/$") {
          if (0 < m && 8 > m) {
            d = m;
            var D = i.ownerDocument;
            if (d & 1 && Bu(D.documentElement), d & 2 && Bu(D.body), d & 4)
              for (d = D.head, Bu(d), D = d.firstChild; D; ) {
                var $ = D.nextSibling, X = D.nodeName;
                D[da] || X === "SCRIPT" || X === "STYLE" || X === "LINK" && D.rel.toLowerCase() === "stylesheet" || d.removeChild(D), D = $;
              }
          }
          if (b === 0) {
            i.removeChild(C), Xu(l);
            return;
          }
          b--;
        } else
          d === "$" || d === "$?" || d === "$!" ? b++ : m = d.charCodeAt(0) - 48;
      else m = 0;
      d = C;
    } while (d);
    Xu(l);
  }
  function ey(i) {
    var l = i.firstChild;
    for (l && l.nodeType === 10 && (l = l.nextSibling); l; ) {
      var d = l;
      switch (l = l.nextSibling, d.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          ey(d), Zl(d);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (d.rel.toLowerCase() === "stylesheet") continue;
      }
      i.removeChild(d);
    }
  }
  function jI(i, l, d, m) {
    for (; i.nodeType === 1; ) {
      var b = d;
      if (i.nodeName.toLowerCase() !== l.toLowerCase()) {
        if (!m && (i.nodeName !== "INPUT" || i.type !== "hidden"))
          break;
      } else if (m) {
        if (!i[da])
          switch (l) {
            case "meta":
              if (!i.hasAttribute("itemprop")) break;
              return i;
            case "link":
              if (C = i.getAttribute("rel"), C === "stylesheet" && i.hasAttribute("data-precedence"))
                break;
              if (C !== b.rel || i.getAttribute("href") !== (b.href == null || b.href === "" ? null : b.href) || i.getAttribute("crossorigin") !== (b.crossOrigin == null ? null : b.crossOrigin) || i.getAttribute("title") !== (b.title == null ? null : b.title))
                break;
              return i;
            case "style":
              if (i.hasAttribute("data-precedence")) break;
              return i;
            case "script":
              if (C = i.getAttribute("src"), (C !== (b.src == null ? null : b.src) || i.getAttribute("type") !== (b.type == null ? null : b.type) || i.getAttribute("crossorigin") !== (b.crossOrigin == null ? null : b.crossOrigin)) && C && i.hasAttribute("async") && !i.hasAttribute("itemprop"))
                break;
              return i;
            default:
              return i;
          }
      } else if (l === "input" && i.type === "hidden") {
        var C = b.name == null ? null : "" + b.name;
        if (b.type === "hidden" && i.getAttribute("name") === C)
          return i;
      } else return i;
      if (i = Nr(i.nextSibling), i === null) break;
    }
    return null;
  }
  function II(i, l, d) {
    if (l === "") return null;
    for (; i.nodeType !== 3; )
      if ((i.nodeType !== 1 || i.nodeName !== "INPUT" || i.type !== "hidden") && !d || (i = Nr(i.nextSibling), i === null)) return null;
    return i;
  }
  function ty(i) {
    return i.data === "$!" || i.data === "$?" && i.ownerDocument.readyState === "complete";
  }
  function zI(i, l) {
    var d = i.ownerDocument;
    if (i.data !== "$?" || d.readyState === "complete")
      l();
    else {
      var m = function() {
        l(), d.removeEventListener("DOMContentLoaded", m);
      };
      d.addEventListener("DOMContentLoaded", m), i._reactRetry = m;
    }
  }
  function Nr(i) {
    for (; i != null; i = i.nextSibling) {
      var l = i.nodeType;
      if (l === 1 || l === 3) break;
      if (l === 8) {
        if (l = i.data, l === "$" || l === "$!" || l === "$?" || l === "F!" || l === "F")
          break;
        if (l === "/$") return null;
      }
    }
    return i;
  }
  var ny = null;
  function PE(i) {
    i = i.previousSibling;
    for (var l = 0; i; ) {
      if (i.nodeType === 8) {
        var d = i.data;
        if (d === "$" || d === "$!" || d === "$?") {
          if (l === 0) return i;
          l--;
        } else d === "/$" && l++;
      }
      i = i.previousSibling;
    }
    return null;
  }
  function jE(i, l, d) {
    switch (l = Dd(d), i) {
      case "html":
        if (i = l.documentElement, !i) throw Error(r(452));
        return i;
      case "head":
        if (i = l.head, !i) throw Error(r(453));
        return i;
      case "body":
        if (i = l.body, !i) throw Error(r(454));
        return i;
      default:
        throw Error(r(451));
    }
  }
  function Bu(i) {
    for (var l = i.attributes; l.length; )
      i.removeAttributeNode(l[0]);
    Zl(i);
  }
  var br = /* @__PURE__ */ new Map(), IE = /* @__PURE__ */ new Set();
  function Pd(i) {
    return typeof i.getRootNode == "function" ? i.getRootNode() : i.nodeType === 9 ? i : i.ownerDocument;
  }
  var Uo = H.d;
  H.d = {
    f: LI,
    r: FI,
    D: $I,
    C: BI,
    L: HI,
    m: VI,
    X: qI,
    S: UI,
    M: GI
  };
  function LI() {
    var i = Uo.f(), l = Cd();
    return i || l;
  }
  function FI(i) {
    var l = ko(i);
    l !== null && l.tag === 5 && l.type === "form" ? nS(l) : Uo.r(i);
  }
  var Ls = typeof document > "u" ? null : document;
  function zE(i, l, d) {
    var m = Ls;
    if (m && typeof l == "string" && l) {
      var b = On(l);
      b = 'link[rel="' + i + '"][href="' + b + '"]', typeof d == "string" && (b += '[crossorigin="' + d + '"]'), IE.has(b) || (IE.add(b), i = { rel: i, crossOrigin: d, href: l }, m.querySelector(b) === null && (l = m.createElement("link"), sn(l, "link", i), Bt(l), m.head.appendChild(l)));
    }
  }
  function $I(i) {
    Uo.D(i), zE("dns-prefetch", i, null);
  }
  function BI(i, l) {
    Uo.C(i, l), zE("preconnect", i, l);
  }
  function HI(i, l, d) {
    Uo.L(i, l, d);
    var m = Ls;
    if (m && i && l) {
      var b = 'link[rel="preload"][as="' + On(l) + '"]';
      l === "image" && d && d.imageSrcSet ? (b += '[imagesrcset="' + On(
        d.imageSrcSet
      ) + '"]', typeof d.imageSizes == "string" && (b += '[imagesizes="' + On(
        d.imageSizes
      ) + '"]')) : b += '[href="' + On(i) + '"]';
      var C = b;
      switch (l) {
        case "style":
          C = Fs(i);
          break;
        case "script":
          C = $s(i);
      }
      br.has(C) || (i = h(
        {
          rel: "preload",
          href: l === "image" && d && d.imageSrcSet ? void 0 : i,
          as: l
        },
        d
      ), br.set(C, i), m.querySelector(b) !== null || l === "style" && m.querySelector(Hu(C)) || l === "script" && m.querySelector(Vu(C)) || (l = m.createElement("link"), sn(l, "link", i), Bt(l), m.head.appendChild(l)));
    }
  }
  function VI(i, l) {
    Uo.m(i, l);
    var d = Ls;
    if (d && i) {
      var m = l && typeof l.as == "string" ? l.as : "script", b = 'link[rel="modulepreload"][as="' + On(m) + '"][href="' + On(i) + '"]', C = b;
      switch (m) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          C = $s(i);
      }
      if (!br.has(C) && (i = h({ rel: "modulepreload", href: i }, l), br.set(C, i), d.querySelector(b) === null)) {
        switch (m) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (d.querySelector(Vu(C)))
              return;
        }
        m = d.createElement("link"), sn(m, "link", i), Bt(m), d.head.appendChild(m);
      }
    }
  }
  function UI(i, l, d) {
    Uo.S(i, l, d);
    var m = Ls;
    if (m && i) {
      var b = To(m).hoistableStyles, C = Fs(i);
      l = l || "default";
      var D = b.get(C);
      if (!D) {
        var $ = { loading: 0, preload: null };
        if (D = m.querySelector(
          Hu(C)
        ))
          $.loading = 5;
        else {
          i = h(
            { rel: "stylesheet", href: i, "data-precedence": l },
            d
          ), (d = br.get(C)) && ry(i, d);
          var X = D = m.createElement("link");
          Bt(X), sn(X, "link", i), X._p = new Promise(function(ee, ue) {
            X.onload = ee, X.onerror = ue;
          }), X.addEventListener("load", function() {
            $.loading |= 1;
          }), X.addEventListener("error", function() {
            $.loading |= 2;
          }), $.loading |= 4, jd(D, l, m);
        }
        D = {
          type: "stylesheet",
          instance: D,
          count: 1,
          state: $
        }, b.set(C, D);
      }
    }
  }
  function qI(i, l) {
    Uo.X(i, l);
    var d = Ls;
    if (d && i) {
      var m = To(d).hoistableScripts, b = $s(i), C = m.get(b);
      C || (C = d.querySelector(Vu(b)), C || (i = h({ src: i, async: !0 }, l), (l = br.get(b)) && oy(i, l), C = d.createElement("script"), Bt(C), sn(C, "link", i), d.head.appendChild(C)), C = {
        type: "script",
        instance: C,
        count: 1,
        state: null
      }, m.set(b, C));
    }
  }
  function GI(i, l) {
    Uo.M(i, l);
    var d = Ls;
    if (d && i) {
      var m = To(d).hoistableScripts, b = $s(i), C = m.get(b);
      C || (C = d.querySelector(Vu(b)), C || (i = h({ src: i, async: !0, type: "module" }, l), (l = br.get(b)) && oy(i, l), C = d.createElement("script"), Bt(C), sn(C, "link", i), d.head.appendChild(C)), C = {
        type: "script",
        instance: C,
        count: 1,
        state: null
      }, m.set(b, C));
    }
  }
  function LE(i, l, d, m) {
    var b = (b = oe.current) ? Pd(b) : null;
    if (!b) throw Error(r(446));
    switch (i) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof d.precedence == "string" && typeof d.href == "string" ? (l = Fs(d.href), d = To(
          b
        ).hoistableStyles, m = d.get(l), m || (m = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, d.set(l, m)), m) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (d.rel === "stylesheet" && typeof d.href == "string" && typeof d.precedence == "string") {
          i = Fs(d.href);
          var C = To(
            b
          ).hoistableStyles, D = C.get(i);
          if (D || (b = b.ownerDocument || b, D = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, C.set(i, D), (C = b.querySelector(
            Hu(i)
          )) && !C._p && (D.instance = C, D.state.loading = 5), br.has(i) || (d = {
            rel: "preload",
            as: "style",
            href: d.href,
            crossOrigin: d.crossOrigin,
            integrity: d.integrity,
            media: d.media,
            hrefLang: d.hrefLang,
            referrerPolicy: d.referrerPolicy
          }, br.set(i, d), C || YI(
            b,
            i,
            d,
            D.state
          ))), l && m === null)
            throw Error(r(528, ""));
          return D;
        }
        if (l && m !== null)
          throw Error(r(529, ""));
        return null;
      case "script":
        return l = d.async, d = d.src, typeof d == "string" && l && typeof l != "function" && typeof l != "symbol" ? (l = $s(d), d = To(
          b
        ).hoistableScripts, m = d.get(l), m || (m = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, d.set(l, m)), m) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(r(444, i));
    }
  }
  function Fs(i) {
    return 'href="' + On(i) + '"';
  }
  function Hu(i) {
    return 'link[rel="stylesheet"][' + i + "]";
  }
  function FE(i) {
    return h({}, i, {
      "data-precedence": i.precedence,
      precedence: null
    });
  }
  function YI(i, l, d, m) {
    i.querySelector('link[rel="preload"][as="style"][' + l + "]") ? m.loading = 1 : (l = i.createElement("link"), m.preload = l, l.addEventListener("load", function() {
      return m.loading |= 1;
    }), l.addEventListener("error", function() {
      return m.loading |= 2;
    }), sn(l, "link", d), Bt(l), i.head.appendChild(l));
  }
  function $s(i) {
    return '[src="' + On(i) + '"]';
  }
  function Vu(i) {
    return "script[async]" + i;
  }
  function $E(i, l, d) {
    if (l.count++, l.instance === null)
      switch (l.type) {
        case "style":
          var m = i.querySelector(
            'style[data-href~="' + On(d.href) + '"]'
          );
          if (m)
            return l.instance = m, Bt(m), m;
          var b = h({}, d, {
            "data-href": d.href,
            "data-precedence": d.precedence,
            href: null,
            precedence: null
          });
          return m = (i.ownerDocument || i).createElement(
            "style"
          ), Bt(m), sn(m, "style", b), jd(m, d.precedence, i), l.instance = m;
        case "stylesheet":
          b = Fs(d.href);
          var C = i.querySelector(
            Hu(b)
          );
          if (C)
            return l.state.loading |= 4, l.instance = C, Bt(C), C;
          m = FE(d), (b = br.get(b)) && ry(m, b), C = (i.ownerDocument || i).createElement("link"), Bt(C);
          var D = C;
          return D._p = new Promise(function($, X) {
            D.onload = $, D.onerror = X;
          }), sn(C, "link", m), l.state.loading |= 4, jd(C, d.precedence, i), l.instance = C;
        case "script":
          return C = $s(d.src), (b = i.querySelector(
            Vu(C)
          )) ? (l.instance = b, Bt(b), b) : (m = d, (b = br.get(C)) && (m = h({}, d), oy(m, b)), i = i.ownerDocument || i, b = i.createElement("script"), Bt(b), sn(b, "link", m), i.head.appendChild(b), l.instance = b);
        case "void":
          return null;
        default:
          throw Error(r(443, l.type));
      }
    else
      l.type === "stylesheet" && (l.state.loading & 4) === 0 && (m = l.instance, l.state.loading |= 4, jd(m, d.precedence, i));
    return l.instance;
  }
  function jd(i, l, d) {
    for (var m = d.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), b = m.length ? m[m.length - 1] : null, C = b, D = 0; D < m.length; D++) {
      var $ = m[D];
      if ($.dataset.precedence === l) C = $;
      else if (C !== b) break;
    }
    C ? C.parentNode.insertBefore(i, C.nextSibling) : (l = d.nodeType === 9 ? d.head : d, l.insertBefore(i, l.firstChild));
  }
  function ry(i, l) {
    i.crossOrigin == null && (i.crossOrigin = l.crossOrigin), i.referrerPolicy == null && (i.referrerPolicy = l.referrerPolicy), i.title == null && (i.title = l.title);
  }
  function oy(i, l) {
    i.crossOrigin == null && (i.crossOrigin = l.crossOrigin), i.referrerPolicy == null && (i.referrerPolicy = l.referrerPolicy), i.integrity == null && (i.integrity = l.integrity);
  }
  var Id = null;
  function BE(i, l, d) {
    if (Id === null) {
      var m = /* @__PURE__ */ new Map(), b = Id = /* @__PURE__ */ new Map();
      b.set(d, m);
    } else
      b = Id, m = b.get(d), m || (m = /* @__PURE__ */ new Map(), b.set(d, m));
    if (m.has(i)) return m;
    for (m.set(i, null), d = d.getElementsByTagName(i), b = 0; b < d.length; b++) {
      var C = d[b];
      if (!(C[da] || C[Qt] || i === "link" && C.getAttribute("rel") === "stylesheet") && C.namespaceURI !== "http://www.w3.org/2000/svg") {
        var D = C.getAttribute(l) || "";
        D = i + D;
        var $ = m.get(D);
        $ ? $.push(C) : m.set(D, [C]);
      }
    }
    return m;
  }
  function HE(i, l, d) {
    i = i.ownerDocument || i, i.head.insertBefore(
      d,
      l === "title" ? i.querySelector("head > title") : null
    );
  }
  function WI(i, l, d) {
    if (d === 1 || l.itemProp != null) return !1;
    switch (i) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof l.precedence != "string" || typeof l.href != "string" || l.href === "")
          break;
        return !0;
      case "link":
        if (typeof l.rel != "string" || typeof l.href != "string" || l.href === "" || l.onLoad || l.onError)
          break;
        switch (l.rel) {
          case "stylesheet":
            return i = l.disabled, typeof l.precedence == "string" && i == null;
          default:
            return !0;
        }
      case "script":
        if (l.async && typeof l.async != "function" && typeof l.async != "symbol" && !l.onLoad && !l.onError && l.src && typeof l.src == "string")
          return !0;
    }
    return !1;
  }
  function VE(i) {
    return !(i.type === "stylesheet" && (i.state.loading & 3) === 0);
  }
  var Uu = null;
  function XI() {
  }
  function KI(i, l, d) {
    if (Uu === null) throw Error(r(475));
    var m = Uu;
    if (l.type === "stylesheet" && (typeof d.media != "string" || matchMedia(d.media).matches !== !1) && (l.state.loading & 4) === 0) {
      if (l.instance === null) {
        var b = Fs(d.href), C = i.querySelector(
          Hu(b)
        );
        if (C) {
          i = C._p, i !== null && typeof i == "object" && typeof i.then == "function" && (m.count++, m = zd.bind(m), i.then(m, m)), l.state.loading |= 4, l.instance = C, Bt(C);
          return;
        }
        C = i.ownerDocument || i, d = FE(d), (b = br.get(b)) && ry(d, b), C = C.createElement("link"), Bt(C);
        var D = C;
        D._p = new Promise(function($, X) {
          D.onload = $, D.onerror = X;
        }), sn(C, "link", d), l.instance = C;
      }
      m.stylesheets === null && (m.stylesheets = /* @__PURE__ */ new Map()), m.stylesheets.set(l, i), (i = l.state.preload) && (l.state.loading & 3) === 0 && (m.count++, l = zd.bind(m), i.addEventListener("load", l), i.addEventListener("error", l));
    }
  }
  function ZI() {
    if (Uu === null) throw Error(r(475));
    var i = Uu;
    return i.stylesheets && i.count === 0 && iy(i, i.stylesheets), 0 < i.count ? function(l) {
      var d = setTimeout(function() {
        if (i.stylesheets && iy(i, i.stylesheets), i.unsuspend) {
          var m = i.unsuspend;
          i.unsuspend = null, m();
        }
      }, 6e4);
      return i.unsuspend = l, function() {
        i.unsuspend = null, clearTimeout(d);
      };
    } : null;
  }
  function zd() {
    if (this.count--, this.count === 0) {
      if (this.stylesheets) iy(this, this.stylesheets);
      else if (this.unsuspend) {
        var i = this.unsuspend;
        this.unsuspend = null, i();
      }
    }
  }
  var Ld = null;
  function iy(i, l) {
    i.stylesheets = null, i.unsuspend !== null && (i.count++, Ld = /* @__PURE__ */ new Map(), l.forEach(QI, i), Ld = null, zd.call(i));
  }
  function QI(i, l) {
    if (!(l.state.loading & 4)) {
      var d = Ld.get(i);
      if (d) var m = d.get(null);
      else {
        d = /* @__PURE__ */ new Map(), Ld.set(i, d);
        for (var b = i.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), C = 0; C < b.length; C++) {
          var D = b[C];
          (D.nodeName === "LINK" || D.getAttribute("media") !== "not all") && (d.set(D.dataset.precedence, D), m = D);
        }
        m && d.set(null, m);
      }
      b = l.instance, D = b.getAttribute("data-precedence"), C = d.get(D) || m, C === m && d.set(null, b), d.set(D, b), this.count++, m = zd.bind(this), b.addEventListener("load", m), b.addEventListener("error", m), C ? C.parentNode.insertBefore(b, C.nextSibling) : (i = i.nodeType === 9 ? i.head : i, i.insertBefore(b, i.firstChild)), l.state.loading |= 4;
    }
  }
  var qu = {
    $$typeof: k,
    Provider: null,
    Consumer: null,
    _currentValue: q,
    _currentValue2: q,
    _threadCount: 0
  };
  function JI(i, l, d, m, b, C, D, $) {
    this.tag = 1, this.containerInfo = i, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Gl(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Gl(0), this.hiddenUpdates = Gl(null), this.identifierPrefix = m, this.onUncaughtError = b, this.onCaughtError = C, this.onRecoverableError = D, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = $, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function UE(i, l, d, m, b, C, D, $, X, ee, ue, fe) {
    return i = new JI(
      i,
      l,
      d,
      D,
      $,
      X,
      ee,
      fe
    ), l = 1, C === !0 && (l |= 24), C = Wn(3, null, null, l), i.current = C, C.stateNode = i, l = $g(), l.refCount++, i.pooledCache = l, l.refCount++, C.memoizedState = {
      element: m,
      isDehydrated: d,
      cache: l
    }, Ug(C), i;
  }
  function qE(i) {
    return i ? (i = ys, i) : ys;
  }
  function GE(i, l, d, m, b, C) {
    b = qE(b), m.context === null ? m.context = b : m.pendingContext = b, m = Ei(l), m.payload = { element: d }, C = C === void 0 ? null : C, C !== null && (m.callback = C), d = Ci(i, m, l), d !== null && (Jn(d, i, l), wu(d, i, l));
  }
  function YE(i, l) {
    if (i = i.memoizedState, i !== null && i.dehydrated !== null) {
      var d = i.retryLane;
      i.retryLane = d !== 0 && d < l ? d : l;
    }
  }
  function ay(i, l) {
    YE(i, l), (i = i.alternate) && YE(i, l);
  }
  function WE(i) {
    if (i.tag === 13) {
      var l = gs(i, 67108864);
      l !== null && Jn(l, i, 67108864), ay(i, 67108864);
    }
  }
  var Fd = !0;
  function e6(i, l, d, m) {
    var b = I.T;
    I.T = null;
    var C = H.p;
    try {
      H.p = 2, sy(i, l, d, m);
    } finally {
      H.p = C, I.T = b;
    }
  }
  function t6(i, l, d, m) {
    var b = I.T;
    I.T = null;
    var C = H.p;
    try {
      H.p = 8, sy(i, l, d, m);
    } finally {
      H.p = C, I.T = b;
    }
  }
  function sy(i, l, d, m) {
    if (Fd) {
      var b = ly(m);
      if (b === null)
        W0(
          i,
          l,
          m,
          $d,
          d
        ), KE(i, m);
      else if (r6(
        b,
        i,
        l,
        d,
        m
      ))
        m.stopPropagation();
      else if (KE(i, m), l & 4 && -1 < n6.indexOf(i)) {
        for (; b !== null; ) {
          var C = ko(b);
          if (C !== null)
            switch (C.tag) {
              case 3:
                if (C = C.stateNode, C.current.memoizedState.isDehydrated) {
                  var D = _n(C.pendingLanes);
                  if (D !== 0) {
                    var $ = C;
                    for ($.pendingLanes |= 2, $.entangledLanes |= 2; D; ) {
                      var X = 1 << 31 - De(D);
                      $.entanglements[1] |= X, D &= ~X;
                    }
                    Zr(C), (lt & 6) === 0 && (Sd = ct() + 500, Lu(0));
                  }
                }
                break;
              case 13:
                $ = gs(C, 2), $ !== null && Jn($, C, 2), Cd(), ay(C, 2);
            }
          if (C = ly(m), C === null && W0(
            i,
            l,
            m,
            $d,
            d
          ), C === b) break;
          b = C;
        }
        b !== null && m.stopPropagation();
      } else
        W0(
          i,
          l,
          m,
          null,
          d
        );
    }
  }
  function ly(i) {
    return i = hg(i), uy(i);
  }
  var $d = null;
  function uy(i) {
    if ($d = null, i = vi(i), i !== null) {
      var l = a(i);
      if (l === null) i = null;
      else {
        var d = l.tag;
        if (d === 13) {
          if (i = s(l), i !== null) return i;
          i = null;
        } else if (d === 3) {
          if (l.stateNode.current.memoizedState.isDehydrated)
            return l.tag === 3 ? l.stateNode.containerInfo : null;
          i = null;
        } else l !== i && (i = null);
      }
    }
    return $d = i, null;
  }
  function XE(i) {
    switch (i) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (cn()) {
          case fr:
            return 2;
          case Un:
            return 8;
          case qn:
          case ze:
            return 32;
          case qr:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var cy = !1, Li = null, Fi = null, $i = null, Gu = /* @__PURE__ */ new Map(), Yu = /* @__PURE__ */ new Map(), Bi = [], n6 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function KE(i, l) {
    switch (i) {
      case "focusin":
      case "focusout":
        Li = null;
        break;
      case "dragenter":
      case "dragleave":
        Fi = null;
        break;
      case "mouseover":
      case "mouseout":
        $i = null;
        break;
      case "pointerover":
      case "pointerout":
        Gu.delete(l.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Yu.delete(l.pointerId);
    }
  }
  function Wu(i, l, d, m, b, C) {
    return i === null || i.nativeEvent !== C ? (i = {
      blockedOn: l,
      domEventName: d,
      eventSystemFlags: m,
      nativeEvent: C,
      targetContainers: [b]
    }, l !== null && (l = ko(l), l !== null && WE(l)), i) : (i.eventSystemFlags |= m, l = i.targetContainers, b !== null && l.indexOf(b) === -1 && l.push(b), i);
  }
  function r6(i, l, d, m, b) {
    switch (l) {
      case "focusin":
        return Li = Wu(
          Li,
          i,
          l,
          d,
          m,
          b
        ), !0;
      case "dragenter":
        return Fi = Wu(
          Fi,
          i,
          l,
          d,
          m,
          b
        ), !0;
      case "mouseover":
        return $i = Wu(
          $i,
          i,
          l,
          d,
          m,
          b
        ), !0;
      case "pointerover":
        var C = b.pointerId;
        return Gu.set(
          C,
          Wu(
            Gu.get(C) || null,
            i,
            l,
            d,
            m,
            b
          )
        ), !0;
      case "gotpointercapture":
        return C = b.pointerId, Yu.set(
          C,
          Wu(
            Yu.get(C) || null,
            i,
            l,
            d,
            m,
            b
          )
        ), !0;
    }
    return !1;
  }
  function ZE(i) {
    var l = vi(i.target);
    if (l !== null) {
      var d = a(l);
      if (d !== null) {
        if (l = d.tag, l === 13) {
          if (l = s(d), l !== null) {
            i.blockedOn = l, rg(i.priority, function() {
              if (d.tag === 13) {
                var m = Qn();
                m = Wl(m);
                var b = gs(d, m);
                b !== null && Jn(b, d, m), ay(d, m);
              }
            });
            return;
          }
        } else if (l === 3 && d.stateNode.current.memoizedState.isDehydrated) {
          i.blockedOn = d.tag === 3 ? d.stateNode.containerInfo : null;
          return;
        }
      }
    }
    i.blockedOn = null;
  }
  function Bd(i) {
    if (i.blockedOn !== null) return !1;
    for (var l = i.targetContainers; 0 < l.length; ) {
      var d = ly(i.nativeEvent);
      if (d === null) {
        d = i.nativeEvent;
        var m = new d.constructor(
          d.type,
          d
        );
        dg = m, d.target.dispatchEvent(m), dg = null;
      } else
        return l = ko(d), l !== null && WE(l), i.blockedOn = d, !1;
      l.shift();
    }
    return !0;
  }
  function QE(i, l, d) {
    Bd(i) && d.delete(l);
  }
  function o6() {
    cy = !1, Li !== null && Bd(Li) && (Li = null), Fi !== null && Bd(Fi) && (Fi = null), $i !== null && Bd($i) && ($i = null), Gu.forEach(QE), Yu.forEach(QE);
  }
  function Hd(i, l) {
    i.blockedOn === l && (i.blockedOn = null, cy || (cy = !0, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      o6
    )));
  }
  var Vd = null;
  function JE(i) {
    Vd !== i && (Vd = i, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      function() {
        Vd === i && (Vd = null);
        for (var l = 0; l < i.length; l += 3) {
          var d = i[l], m = i[l + 1], b = i[l + 2];
          if (typeof m != "function") {
            if (uy(m || d) === null)
              continue;
            break;
          }
          var C = ko(d);
          C !== null && (i.splice(l, 3), l -= 3, u0(
            C,
            {
              pending: !0,
              data: b,
              method: d.method,
              action: m
            },
            m,
            b
          ));
        }
      }
    ));
  }
  function Xu(i) {
    function l(X) {
      return Hd(X, i);
    }
    Li !== null && Hd(Li, i), Fi !== null && Hd(Fi, i), $i !== null && Hd($i, i), Gu.forEach(l), Yu.forEach(l);
    for (var d = 0; d < Bi.length; d++) {
      var m = Bi[d];
      m.blockedOn === i && (m.blockedOn = null);
    }
    for (; 0 < Bi.length && (d = Bi[0], d.blockedOn === null); )
      ZE(d), d.blockedOn === null && Bi.shift();
    if (d = (i.ownerDocument || i).$$reactFormReplay, d != null)
      for (m = 0; m < d.length; m += 3) {
        var b = d[m], C = d[m + 1], D = b[dn] || null;
        if (typeof C == "function")
          D || JE(d);
        else if (D) {
          var $ = null;
          if (C && C.hasAttribute("formAction")) {
            if (b = C, D = C[dn] || null)
              $ = D.formAction;
            else if (uy(b) !== null) continue;
          } else $ = D.action;
          typeof $ == "function" ? d[m + 1] = $ : (d.splice(m, 3), m -= 3), JE(d);
        }
      }
  }
  function fy(i) {
    this._internalRoot = i;
  }
  Ud.prototype.render = fy.prototype.render = function(i) {
    var l = this._internalRoot;
    if (l === null) throw Error(r(409));
    var d = l.current, m = Qn();
    GE(d, m, i, l, null, null);
  }, Ud.prototype.unmount = fy.prototype.unmount = function() {
    var i = this._internalRoot;
    if (i !== null) {
      this._internalRoot = null;
      var l = i.containerInfo;
      GE(i.current, 2, null, i, null, null), Cd(), l[yi] = null;
    }
  };
  function Ud(i) {
    this._internalRoot = i;
  }
  Ud.prototype.unstable_scheduleHydration = function(i) {
    if (i) {
      var l = Of();
      i = { blockedOn: null, target: i, priority: l };
      for (var d = 0; d < Bi.length && l !== 0 && l < Bi[d].priority; d++) ;
      Bi.splice(d, 0, i), d === 0 && ZE(i);
    }
  };
  var eC = t.version;
  if (eC !== "19.1.0")
    throw Error(
      r(
        527,
        eC,
        "19.1.0"
      )
    );
  H.findDOMNode = function(i) {
    var l = i._reactInternals;
    if (l === void 0)
      throw typeof i.render == "function" ? Error(r(188)) : (i = Object.keys(i).join(","), Error(r(268, i)));
    return i = c(l), i = i !== null ? f(i) : null, i = i === null ? null : i.stateNode, i;
  };
  var i6 = {
    bundleType: 0,
    version: "19.1.0",
    rendererPackageName: "react-dom",
    currentDispatcherRef: I,
    reconcilerVersion: "19.1.0"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var qd = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!qd.isDisabled && qd.supportsFiber)
      try {
        ae = qd.inject(
          i6
        ), pe = qd;
      } catch {
      }
  }
  return Qu.createRoot = function(i, l) {
    if (!o(i)) throw Error(r(299));
    var d = !1, m = "", b = gS, C = yS, D = vS, $ = null;
    return l != null && (l.unstable_strictMode === !0 && (d = !0), l.identifierPrefix !== void 0 && (m = l.identifierPrefix), l.onUncaughtError !== void 0 && (b = l.onUncaughtError), l.onCaughtError !== void 0 && (C = l.onCaughtError), l.onRecoverableError !== void 0 && (D = l.onRecoverableError), l.unstable_transitionCallbacks !== void 0 && ($ = l.unstable_transitionCallbacks)), l = UE(
      i,
      1,
      !1,
      null,
      null,
      d,
      m,
      b,
      C,
      D,
      $,
      null
    ), i[yi] = l.current, Y0(i), new fy(l);
  }, Qu.hydrateRoot = function(i, l, d) {
    if (!o(i)) throw Error(r(299));
    var m = !1, b = "", C = gS, D = yS, $ = vS, X = null, ee = null;
    return d != null && (d.unstable_strictMode === !0 && (m = !0), d.identifierPrefix !== void 0 && (b = d.identifierPrefix), d.onUncaughtError !== void 0 && (C = d.onUncaughtError), d.onCaughtError !== void 0 && (D = d.onCaughtError), d.onRecoverableError !== void 0 && ($ = d.onRecoverableError), d.unstable_transitionCallbacks !== void 0 && (X = d.unstable_transitionCallbacks), d.formState !== void 0 && (ee = d.formState)), l = UE(
      i,
      1,
      !0,
      l,
      d ?? null,
      m,
      b,
      C,
      D,
      $,
      X,
      ee
    ), l.context = qE(null), d = l.current, m = Qn(), m = Wl(m), b = Ei(m), b.callback = null, Ci(d, b, m), d = m, l.current.lanes = d, fa(l, d), Zr(l), i[yi] = l.current, Y0(i), new Ud(l);
  }, Qu.version = "19.1.0", Qu;
}
var cC;
function v6() {
  if (cC) return hy.exports;
  cC = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), hy.exports = y6(), hy.exports;
}
var b6 = v6(), _ = Qc();
const nn = /* @__PURE__ */ Nl(_), gl = /* @__PURE__ */ u6({
  __proto__: null,
  default: nn
}, [_]), Zt = {
  /** Debug level - most verbose, for development debugging */
  DEBUG: 0,
  /** Info level - general information about application flow */
  INFO: 10,
  /** Warning level - concerning but non-critical issues */
  WARN: 20,
  /** Error level - critical problems requiring attention */
  ERROR: 30
}, x6 = Zt.DEBUG, JR = Zt.INFO, w6 = Zt.WARN, _6 = Zt.ERROR, fC = (e) => typeof e == "string" ? e : e === Zt.DEBUG ? "DEBUG" : e === Zt.INFO ? "INFO" : e === Zt.WARN ? "WARN" : e === Zt.ERROR ? "ERROR" : "UNKNOWN";
function S6() {
  const e = [];
  return function(t, n) {
    if (typeof n != "object" || n === null)
      return n;
    for (; e.length > 0 && e.at(-1) !== this; )
      e.pop();
    return e.includes(n) ? "[Circular]" : (e.push(n), n);
  };
}
const dC = (e) => {
  if (typeof e == "number") return e;
  const t = e.toLowerCase();
  if (t === "debug") return Zt.DEBUG;
  if (t === "info") return Zt.INFO;
  if (t === "warn" || t === "warning") return Zt.WARN;
  if (t === "error") return Zt.ERROR;
  throw new Error(`Unknown log level: ${e}`);
};
class s1 {
  /**
   * Create a new BaseLogger instance.
   *
   * @param {string} name - The name/identifier for this logger
   * @param {number | string} [level=LEVELS.INFO] - Initial log level
   * @param {boolean} [with_timestamp=true] - Whether to include timestamps
   * @example
   * ```typescript
   * const logger = new MyLogger("DatabaseService", "DEBUG", true);
   * ```
   */
  constructor(t, n = Zt.INFO, r = !0) {
    this.name = t, this.level = dC(n), this._level_name = fC(this.level), this.with_timestamp = r;
  }
  /**
   * Set the logging level for this logger instance.
   *
   * @param {number | string} level - The new log level (numeric or string)
   * @example
   * ```typescript
   * logger.set_level(DEBUG); // Enable debug logging
   * logger.set_level("debug"); // Same as above using string
   * ```
   */
  set_level(t) {
    typeof t == "string" && (t = dC(t)), this.level = t, this._level_name = fC(this.level);
  }
  /**
   * Get the string representation of the current log level.
   *
   * @returns {string} The current log level as a string
   * @example
   * ```typescript
   * logger.level_name // "INFO"
   * ```
   */
  get level_name() {
    return this._level_name;
  }
  /**
   * Format a log message with level, timestamp, and arguments.
   *
   * @param {string} levelstring - The log level string (DEBUG, INFO, etc.)
   * @param {string} message - The primary log message
   * @param {...any[]} args - Additional arguments to include
   * @returns {string} The formatted log message
   * @example
   * ```typescript
   * // Returns: "12/25/2023, 10:30:15 AM [MyApp] INFO: User logged in {userId: 123}"
   * logger.format_message("INFO", "User logged in", {userId: 123});
   * ```
   */
  format_message(t, n, ...r) {
    return `${this.with_timestamp ? (/* @__PURE__ */ new Date()).toLocaleString() : ""} [${this.name}] ${t}: ${n} ${r.map((a) => JSON.stringify(a, S6())).join(" ")}`.trim();
  }
  /**
   * Log a debug message if the current level allows it.
   *
   * @param {string} message - The primary log message
   * @param {...any[]} args - Additional context arguments
   */
  debug(t, ...n) {
    this.level <= Zt.DEBUG && this.out_debug(this.format_message("DEBUG", t, ...n));
  }
  /**
   * Log an info message if the current level allows it.
   *
   * @param {string} message - The primary log message
   * @param {...any[]} args - Additional context arguments
   */
  info(t, ...n) {
    this.level <= Zt.INFO && this.out_info(this.format_message("INFO", t, ...n));
  }
  /**
   * Log a warning message if the current level allows it.
   *
   * @param {string} message - The primary log message
   * @param {...any[]} args - Additional context arguments
   */
  warn(t, ...n) {
    this.level <= Zt.WARN && this.out_warn(this.format_message("WARN", t, ...n));
  }
  /**
   * Log an error message if the current level allows it.
   *
   * @param {string} message - The primary log message
   * @param {Error} [error] - Optional Error object for stack trace handling
   */
  error(t, n) {
    this.level <= Zt.ERROR && this.out_error(this.format_message("ERROR", t), n);
  }
}
class l1 extends s1 {
  /**
   * Create a new ConsoleLogger instance.
   *
   * @param {string} name - The name/identifier for this logger
   * @param {number | string} [level=LEVELS.INFO] - Initial log level
   * @example
   * ```typescript
   * const logger = new ConsoleLogger("API", "WARN");
   * ```
   */
  constructor(t, n = Zt.INFO) {
    super(t, n);
  }
  /**
   * Output debug message to console.debug.
   *
   * @protected
   * @param {string} formatted_message - The formatted message to output
   */
  out_debug(t) {
    console.debug(t);
  }
  /**
   * Output info message to console.info.
   *
   * @protected
   * @param {string} formatted_message - The formatted message to output
   */
  out_info(t) {
    console.info(t);
  }
  /**
   * Output warning message to console.warn.
   *
   * @protected
   * @param {string} formatted_message - The formatted message to output
   */
  out_warn(t) {
    console.warn(t);
  }
  /**
   * Output error message to console.error.
   *
   * @protected
   * @param {string} formatted_message - The formatted message to output
   * @param {Error | undefined} error - Optional Error object for stack trace handling
   */
  out_error(t, n) {
    console.error(t), n && console.error(n);
  }
}
function vy(e) {
  return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
class E6 extends s1 {
  /**
   * Create a new DivLogger instance.
   *
   * @param {HTMLDivElement} div - The HTML div element to append log messages to
   * @param {string} name - The name/identifier for this logger
   * @param {number | string} [level=LEVELS.INFO] - Initial log level
   * @example
   * ```typescript
   * const logContainer = document.createElement('div');
   * const logger = new DivLogger(logContainer, "WebWorker", "DEBUG");
   * ```
   */
  constructor(t, n, r = Zt.INFO) {
    super(n, r), this._div = t;
  }
  /**
   * Format a log message with HTML escaping for safe DOM insertion.
   *
   * Overrides the base implementation to automatically escape HTML content,
   * preventing XSS vulnerabilities when displaying logs in web interfaces.
   *
   * @param {string} levelstring - The log level string (DEBUG, INFO, etc.)
   * @param {string} message - The primary log message
   * @param {...any[]} args - Additional arguments to include
   * @returns {string} The formatted and HTML-escaped log message
   * @example
   * ```typescript
   * // Input: "User input: <script>alert('xss')<\/script>"
   * // Output: "12/25/2023, 10:30:15 AM [UI] INFO: User input: &lt;script&gt;alert('xss')&lt;/script&gt;"
   * ```
   */
  format_message(t, n, ...r) {
    return vy(super.format_message(t, n, ...r));
  }
  /**
   * Output debug message as HTML div with 'debug' class.
   *
   * @protected
   * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
   */
  out_debug(t) {
    this._div.innerHTML += `<div class="debug">${t}</div>`;
  }
  /**
   * Output info message as HTML div with 'info' class.
   *
   * @protected
   * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
   */
  out_info(t) {
    this._div.innerHTML += `<div class="info">${t}</div>`;
  }
  /**
   * Output warning message as HTML div with 'warn' class.
   *
   * @protected
   * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
   */
  out_warn(t) {
    this._div.innerHTML += `<div class="warn">${t}</div>`;
  }
  /**
   * Output error message as HTML div with 'error' class.
   *
   * @protected
   * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
   * @param {Error | undefined} error - Optional Error object for stack trace handling
   */
  out_error(t, n) {
    let r = t;
    if (n) {
      const o = n.stack ? vy(n.stack) : vy(n.message);
      r += `<br><pre>${o}</pre>`;
    }
    this._div.innerHTML += `<div class="error">${r}</div>`;
  }
}
function C6(e) {
  const t = window.atob(e), n = t.length, r = new Uint8Array(n);
  for (let o = 0; o < n; o++)
    r[o] = t.charCodeAt(o);
  return r;
}
function k6(e, t) {
  return new Blob([e], { type: t });
}
function T6(e, t) {
  return k6(C6(e), t);
}
function A6(e, t, n) {
  const r = T6(e, n), o = URL.createObjectURL(r), a = document.createElement("a");
  a.href = o, a.download = t, a.click(), URL.revokeObjectURL(o), a.remove();
}
function R6(e, t = !0) {
  return new Promise((n, r) => {
    const o = new FileReader();
    o.onload = () => {
      const a = o.result;
      n(t ? a.split(",")[1] : a);
    }, o.onerror = () => r(o.error), o.readAsDataURL(e);
  });
}
function M6(e) {
  return new Promise((t, n) => {
    const r = document.createElement("input");
    r.type = "file", r.accept = e, r.onchange = () => {
      const o = r.files?.[0];
      o ? t(o) : n(new Error("No file selected"));
    }, r.oncancel = () => {
      n(new Error("File selection cancelled"));
    }, r.click();
  });
}
function O6(e) {
  return M6(e).then(R6);
}
async function N6(e, t = !0) {
  try {
    const n = await fetch(e);
    if (!n.ok)
      throw new Error(
        `Failed to fetch from URL: ${n.status} ${n.statusText}`
      );
    const r = await n.blob();
    return await new Promise((a, s) => {
      const u = new FileReader();
      u.onload = () => {
        const c = u.result;
        typeof c != "string" && (s("Failed to convert URL to Base64: No result from FileReader"), s(u.error)), a(t ? c.split(",")[1] : c);
      }, u.onerror = () => s(u.error), u.readAsDataURL(r);
    });
  } catch (n) {
    throw console.error("Error converting URL to Base64:", n), n;
  }
}
function Ki(e) {
  if (Object.prototype.toString.call(e) !== "[object Object]")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t === null || t === Object.prototype;
}
function u1(e, t, n = /* @__PURE__ */ new WeakMap()) {
  if (e === t) return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  if (n.has(e))
    return n.get(e) === t;
  if (n.set(e, t), e.constructor !== t.constructor) return !1;
  if (e.constructor === Object || e.constructor === Array) {
    const r = Object.keys(e), o = Object.keys(t);
    if (r.length !== o.length) return !1;
    for (const a of r)
      if (!o.includes(a) || !u1(e[a], t[a], n)) return !1;
  }
  return e instanceof Date && t instanceof Date ? e.getTime() === t.getTime() : !0;
}
const Ha = (e, t) => {
  let n = !1;
  if (!Ki(e))
    throw new Error("Target must be a plain object not" + typeof e);
  if (!Ki(t))
    throw new Error("Source must be a plain object not" + typeof t);
  const r = { ...e };
  return Object.keys(t).forEach((o) => {
    const a = t[o], s = e[o];
    if (Ki(a) && Ki(s)) {
      const { new_obj: u, change: c } = Ha(
        s,
        a
      );
      c && (n = !0, r[o] = u);
    } else u1(s, a) || (n = !0, r[o] = a);
  }), { new_obj: r, change: n };
}, eM = (e, t) => {
  let n = !1;
  if (!Ki(e))
    throw new Error("Target must be a plain object");
  if (!Ki(t))
    throw new Error("Source must be a plain object");
  const r = { ...e };
  return Object.keys(t).forEach((o) => {
    const a = t[o], s = e[o];
    if (!(s === void 0 && a === void 0)) {
      if (s === void 0) {
        n = !0, r[o] = a;
        return;
      }
      if (Ki(a) && Ki(s)) {
        const { new_obj: u, change: c } = eM(
          s,
          a
        );
        c && (n = !0, r[o] = u);
      }
    }
  }), { new_obj: r, change: n };
}, c1 = (e, t = void 0) => {
  const n = JSON.stringify(e);
  return (r) => {
    let o = JSON.parse(n);
    return t !== void 0 && (o = t(o)), r === void 0 ? o : eM(r, o).new_obj;
  };
}, wr = (e, t) => t === void 0 ? [e, !1] : [t, e !== t];
function tM(e, t) {
  throw new Error("Unhandled case: " + e + " with: " + JSON.stringify(t));
}
const nl = (e, t) => {
  if (t === void 0) return [e, !1];
  if (e === void 0) return [t, t !== void 0];
  const { new_obj: n, change: r } = Ha(e, t);
  return [n, r];
}, D6 = ({ error: e }) => /* @__PURE__ */ x.jsxs("div", { className: "error-div", children: [
  /* @__PURE__ */ x.jsx("h1", { children: "Error" }),
  /* @__PURE__ */ x.jsx("p", { children: e.message })
] });
var Dl = QR();
const P6 = /* @__PURE__ */ Nl(Dl), zp = _.createContext(
  void 0
), Zi = _.forwardRef((e, t) => {
  const {
    asChild: n = !1,
    children: r,
    className: o,
    style: a,
    htime: s = 300,
    vtime: u = 300,
    hdelay: c = 0,
    vdelay: f = 200,
    zIndex: h = 9999,
    ...p
  } = e, [g, y] = _.useState(!1), [w, v] = _.useState({}), S = _.useRef(null), E = _.useRef(null);
  _.useImperativeHandle(t, () => S.current, []);
  const T = _.useMemo(
    () => ({
      horizontal: s,
      vertical: u,
      horizontalDelay: c,
      verticalDelay: f
    }),
    [s, u, c, f]
  ), k = _.useCallback(
    () => Math.max(
      T.horizontal + T.horizontalDelay,
      T.vertical + T.verticalDelay
    ),
    [T]
  ), A = _.useCallback(async () => {
    if (S.current)
      try {
        const F = S.current.getBoundingClientRect();
        E.current = F, v({
          position: "fixed",
          top: `${F.top}px`,
          left: `${F.left}px`,
          width: `${F.width}px`,
          height: `${F.height}px`,
          zIndex: h,
          transition: "none"
        }), y(!0), S.current.offsetHeight, v((U) => ({
          ...U,
          transition: [
            `width ${T.horizontal}ms ease-in-out ${T.horizontalDelay}ms`,
            `left ${T.horizontal}ms ease-in-out ${T.horizontalDelay}ms`,
            `height ${T.vertical}ms ease-in-out ${T.verticalDelay}ms`,
            `top ${T.vertical}ms ease-in-out ${T.verticalDelay}ms`
          ].join(", ")
        })), requestAnimationFrame(() => {
          v((U) => ({
            ...U,
            top: "0",
            left: "0",
            width: "100vw",
            height: "100vh"
          }));
        }), await new Promise((U) => setTimeout(U, k()));
      } catch (F) {
        console.warn("Error during expand animation:", F), y(!0);
      }
  }, [T, h, k]), M = _.useCallback(async () => {
    if (!S.current || !E.current) return;
    const F = E.current;
    v((U) => ({
      ...U,
      transition: [
        `width ${T.horizontal}ms ease-in-out ${T.verticalDelay}ms`,
        `left ${T.horizontal}ms ease-in-out ${T.verticalDelay}ms`,
        `height ${T.vertical}ms ease-in-out ${T.horizontalDelay}ms`,
        `top ${T.vertical}ms ease-in-out ${T.horizontalDelay}ms`
      ].join(", ")
    })), requestAnimationFrame(() => {
      v((U) => ({
        ...U,
        top: `${F.top}px`,
        left: `${F.left}px`,
        width: `${F.width}px`,
        height: `${F.height}px`
      }));
    }), await new Promise((U) => setTimeout(U, k())), v({}), y(!1), E.current = null;
  }, [T, k]), N = _.useCallback(async () => {
    g ? await M() : await A();
  }, [g, A, M]), P = _.useMemo(
    () => ({ isExpanded: g, toggleExpand: N }),
    [g, N]
  ), z = _.useMemo(
    () => ({ ...a, ...w }),
    [a, w]
  );
  let B;
  if (n && _.isValidElement(r)) {
    const F = r;
    B = _.cloneElement(F, {
      ref: S,
      className: [F.props.className, o].filter(Boolean).join(" "),
      style: { ...F.props.style, ...z },
      ...p
    });
  } else
    B = /* @__PURE__ */ x.jsx("div", { ref: S, className: o, style: z, ...p, children: r });
  const R = /* @__PURE__ */ x.jsx(zp.Provider, { value: P, children: B });
  return g ? Dl.createPortal(R, document.body) : R;
});
Zi.displayName = "SmoothExpand";
Zi.Trigger = function({
  children: t,
  className: n
}) {
  const r = _.useContext(zp);
  if (!r)
    throw new Error(
      "SmoothExpand.Trigger must be used within a SmoothExpand component"
    );
  return /* @__PURE__ */ x.jsx(
    "div",
    {
      className: n,
      style: { cursor: "pointer" },
      onClick: r.toggleExpand,
      role: "button",
      tabIndex: 0,
      onKeyDown: (o) => {
        (o.key === "Enter" || o.key === " ") && (o.preventDefault(), r.toggleExpand());
      },
      children: t
    }
  );
};
Zi.Expanded = function({
  children: t
}) {
  const n = _.useContext(zp);
  if (!n)
    throw new Error(
      "SmoothExpand.Expanded must be used within a SmoothExpand component"
    );
  return n.isExpanded ? /* @__PURE__ */ x.jsx(x.Fragment, { children: t }) : null;
};
Zi.Collapsed = function({
  children: t
}) {
  const n = _.useContext(zp);
  if (!n)
    throw new Error(
      "SmoothExpand.Collapsed must be used within a SmoothExpand component"
    );
  return n.isExpanded ? null : /* @__PURE__ */ x.jsx(x.Fragment, { children: t });
};
const Lp = _.createContext(
  void 0
), Wo = _.forwardRef((e, t) => {
  const { asChild: n = !1, children: r, className: o, style: a, ...s } = e, [u, c] = _.useState(!1), f = _.useRef(null);
  _.useImperativeHandle(t, () => f.current, []);
  const h = _.useCallback(async (S) => {
    const E = S;
    if (S.requestFullscreen)
      await S.requestFullscreen();
    else if (E.mozRequestFullScreen)
      await E.mozRequestFullScreen();
    else if (E.webkitRequestFullscreen)
      await E.webkitRequestFullscreen();
    else if (E.msRequestFullscreen)
      await E.msRequestFullscreen();
    else
      throw new Error("Fullscreen API is not supported in this browser");
  }, []), p = _.useCallback(async () => {
    const S = document;
    if (document.exitFullscreen)
      await document.exitFullscreen();
    else if (S.mozCancelFullScreen)
      await S.mozCancelFullScreen();
    else if (S.webkitExitFullscreen)
      await S.webkitExitFullscreen();
    else if (S.msExitFullscreen)
      await S.msExitFullscreen();
    else
      throw new Error("Exit fullscreen API is not supported in this browser");
  }, []), g = _.useCallback(async () => {
    try {
      const S = f.current;
      if (!S) {
        console.warn("FullScreen: No element reference available");
        return;
      }
      u ? await p() : await h(S);
    } catch (S) {
      console.error("FullScreen: Error toggling fullscreen mode", S);
    }
  }, [u, h, p]), y = _.useCallback(() => {
    const S = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
    c(S);
  }, []);
  _.useEffect(() => {
    const S = [
      "fullscreenchange",
      "webkitfullscreenchange",
      "mozfullscreenchange",
      "MSFullscreenChange"
    ];
    return S.forEach((E) => {
      document.addEventListener(E, y);
    }), () => {
      S.forEach((E) => {
        document.removeEventListener(E, y);
      });
    };
  }, [y]);
  const w = _.useMemo(
    () => ({ isFullScreen: u, toggleFullscreen: g }),
    [u, g]
  );
  let v;
  if (n && _.isValidElement(r)) {
    const S = r;
    v = _.cloneElement(S, {
      ref: f,
      className: [S.props.className, o].filter(Boolean).join(" "),
      style: { ...S.props.style, ...a },
      ...s
    });
  } else
    v = /* @__PURE__ */ x.jsx("div", { ref: f, className: o, style: a, ...s, children: r });
  return /* @__PURE__ */ x.jsx(Lp.Provider, { value: w, children: v });
});
Wo.displayName = "FullScreen";
Wo.Trigger = function({
  children: t,
  className: n
}) {
  const r = _.useContext(Lp);
  if (!r)
    throw new Error(
      "FullScreen.Trigger must be used within a FullScreen component"
    );
  return /* @__PURE__ */ x.jsx(
    "div",
    {
      className: n,
      style: { cursor: "pointer" },
      onClick: r.toggleFullscreen,
      role: "button",
      tabIndex: 0,
      onKeyDown: (o) => {
        (o.key === "Enter" || o.key === " ") && (o.preventDefault(), r.toggleFullscreen());
      },
      children: t
    }
  );
};
Wo.InFullScreen = function({
  children: t
}) {
  const n = _.useContext(Lp);
  if (!n)
    throw new Error(
      "FullScreen.InFullScreen must be used within a FullScreen component"
    );
  return n.isFullScreen ? /* @__PURE__ */ x.jsx(x.Fragment, { children: t }) : null;
};
Wo.OutFullScreen = function({
  children: t
}) {
  const n = _.useContext(Lp);
  if (!n)
    throw new Error(
      "FullScreen.OutFullScreen must be used within a FullScreen component"
    );
  return n.isFullScreen ? null : /* @__PURE__ */ x.jsx(x.Fragment, { children: t });
};
var by = { exports: {} }, xy, hC;
function j6() {
  if (hC) return xy;
  hC = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return xy = e, xy;
}
var wy, pC;
function I6() {
  if (pC) return wy;
  pC = 1;
  var e = /* @__PURE__ */ j6();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, wy = function() {
    function r(s, u, c, f, h, p) {
      if (p !== e) {
        var g = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw g.name = "Invariant Violation", g;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var a = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return a.PropTypes = a, a;
  }, wy;
}
var mC;
function z6() {
  return mC || (mC = 1, by.exports = /* @__PURE__ */ I6()()), by.exports;
}
var Ut = /* @__PURE__ */ z6();
const Ve = /* @__PURE__ */ Nl(Ut);
function nM(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (n = nM(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function zt() {
  for (var e, t, n = 0, r = "", o = arguments.length; n < o; n++) (e = arguments[n]) && (t = nM(e)) && (r && (r += " "), r += t);
  return r;
}
function li(e, t, n = void 0) {
  const r = {};
  for (const o in e) {
    const a = e[o];
    let s = "", u = !0;
    for (let c = 0; c < a.length; c += 1) {
      const f = a[c];
      f && (s += (u === !0 ? "" : " ") + t(f), u = !1, n && n[f] && (s += " " + n[f]));
    }
    r[o] = s;
  }
  return r;
}
const rM = /* @__PURE__ */ _.createContext();
function Va(e, ...t) {
  const n = new URL(`https://mui.com/production-error/?code=${e}`);
  return t.forEach((r) => n.searchParams.append("args[]", r)), `Minified MUI error #${e}; visit ${n} for the full message.`;
}
function kn(e) {
  if (typeof e != "string")
    throw new Error(Va(7));
  return e.charAt(0).toUpperCase() + e.slice(1);
}
var _y = { exports: {} }, pt = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var gC;
function L6() {
  if (gC) return pt;
  gC = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.consumer"), s = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), h = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), g = Symbol.for("react.view_transition"), y = Symbol.for("react.client.reference");
  function w(v) {
    if (typeof v == "object" && v !== null) {
      var S = v.$$typeof;
      switch (S) {
        case e:
          switch (v = v.type, v) {
            case n:
            case o:
            case r:
            case c:
            case f:
            case g:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case u:
                case p:
                case h:
                  return v;
                case a:
                  return v;
                default:
                  return S;
              }
          }
        case t:
          return S;
      }
    }
  }
  return pt.ContextConsumer = a, pt.ContextProvider = s, pt.Element = e, pt.ForwardRef = u, pt.Fragment = n, pt.Lazy = p, pt.Memo = h, pt.Portal = t, pt.Profiler = o, pt.StrictMode = r, pt.Suspense = c, pt.SuspenseList = f, pt.isContextConsumer = function(v) {
    return w(v) === a;
  }, pt.isContextProvider = function(v) {
    return w(v) === s;
  }, pt.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === e;
  }, pt.isForwardRef = function(v) {
    return w(v) === u;
  }, pt.isFragment = function(v) {
    return w(v) === n;
  }, pt.isLazy = function(v) {
    return w(v) === p;
  }, pt.isMemo = function(v) {
    return w(v) === h;
  }, pt.isPortal = function(v) {
    return w(v) === t;
  }, pt.isProfiler = function(v) {
    return w(v) === o;
  }, pt.isStrictMode = function(v) {
    return w(v) === r;
  }, pt.isSuspense = function(v) {
    return w(v) === c;
  }, pt.isSuspenseList = function(v) {
    return w(v) === f;
  }, pt.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === n || v === o || v === r || v === c || v === f || typeof v == "object" && v !== null && (v.$$typeof === p || v.$$typeof === h || v.$$typeof === s || v.$$typeof === a || v.$$typeof === u || v.$$typeof === y || v.getModuleId !== void 0);
  }, pt.typeOf = w, pt;
}
var yC;
function F6() {
  return yC || (yC = 1, _y.exports = /* @__PURE__ */ L6()), _y.exports;
}
var oM = /* @__PURE__ */ F6();
function Xo(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function iM(e) {
  if (/* @__PURE__ */ _.isValidElement(e) || oM.isValidElementType(e) || !Xo(e))
    return e;
  const t = {};
  return Object.keys(e).forEach((n) => {
    t[n] = iM(e[n]);
  }), t;
}
function or(e, t, n = {
  clone: !0
}) {
  const r = n.clone ? {
    ...e
  } : e;
  return Xo(e) && Xo(t) && Object.keys(t).forEach((o) => {
    /* @__PURE__ */ _.isValidElement(t[o]) || oM.isValidElementType(t[o]) ? r[o] = t[o] : Xo(t[o]) && // Avoid prototype pollution
    Object.prototype.hasOwnProperty.call(e, o) && Xo(e[o]) ? r[o] = or(e[o], t[o], n) : n.clone ? r[o] = Xo(t[o]) ? iM(t[o]) : t[o] : r[o] = t[o];
  }), r;
}
function gc(e, t) {
  return t ? or(e, t, {
    clone: !1
    // No need to clone deep, it's way faster.
  }) : e;
}
function vC(e, t) {
  if (!e.containerQueries)
    return t;
  const n = Object.keys(t).filter((r) => r.startsWith("@container")).sort((r, o) => {
    const a = /min-width:\s*([0-9.]+)/;
    return +(r.match(a)?.[1] || 0) - +(o.match(a)?.[1] || 0);
  });
  return n.length ? n.reduce((r, o) => {
    const a = t[o];
    return delete r[o], r[o] = a, r;
  }, {
    ...t
  }) : t;
}
function $6(e, t) {
  return t === "@" || t.startsWith("@") && (e.some((n) => t.startsWith(`@${n}`)) || !!t.match(/^@\d/));
}
function B6(e, t) {
  const n = t.match(/^@([^/]+)?\/?(.+)?$/);
  if (!n)
    return null;
  const [, r, o] = n, a = Number.isNaN(+r) ? r || 0 : +r;
  return e.containerQueries(o).up(a);
}
function H6(e) {
  const t = (a, s) => a.replace("@media", s ? `@container ${s}` : "@container");
  function n(a, s) {
    a.up = (...u) => t(e.breakpoints.up(...u), s), a.down = (...u) => t(e.breakpoints.down(...u), s), a.between = (...u) => t(e.breakpoints.between(...u), s), a.only = (...u) => t(e.breakpoints.only(...u), s), a.not = (...u) => {
      const c = t(e.breakpoints.not(...u), s);
      return c.includes("not all and") ? c.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or") : c;
    };
  }
  const r = {}, o = (a) => (n(r, a), r);
  return n(o), {
    ...e,
    containerQueries: o
  };
}
const Fp = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
}, bC = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (e) => `@media (min-width:${Fp[e]}px)`
}, V6 = {
  containerQueries: (e) => ({
    up: (t) => {
      let n = typeof t == "number" ? t : Fp[t] || t;
      return typeof n == "number" && (n = `${n}px`), e ? `@container ${e} (min-width:${n})` : `@container (min-width:${n})`;
    }
  })
};
function ti(e, t, n) {
  const r = e.theme || {};
  if (Array.isArray(t)) {
    const a = r.breakpoints || bC;
    return t.reduce((s, u, c) => (s[a.up(a.keys[c])] = n(t[c]), s), {});
  }
  if (typeof t == "object") {
    const a = r.breakpoints || bC;
    return Object.keys(t).reduce((s, u) => {
      if ($6(a.keys, u)) {
        const c = B6(r.containerQueries ? r : V6, u);
        c && (s[c] = n(t[u], u));
      } else if (Object.keys(a.values || Fp).includes(u)) {
        const c = a.up(u);
        s[c] = n(t[u], u);
      } else {
        const c = u;
        s[c] = t[c];
      }
      return s;
    }, {});
  }
  return n(t);
}
function U6(e = {}) {
  return e.keys?.reduce((n, r) => {
    const o = e.up(r);
    return n[o] = {}, n;
  }, {}) || {};
}
function xC(e, t) {
  return e.reduce((n, r) => {
    const o = n[r];
    return (!o || Object.keys(o).length === 0) && delete n[r], n;
  }, t);
}
function $p(e, t, n = !0) {
  if (!t || typeof t != "string")
    return null;
  if (e && e.vars && n) {
    const r = `vars.${t}`.split(".").reduce((o, a) => o && o[a] ? o[a] : null, e);
    if (r != null)
      return r;
  }
  return t.split(".").reduce((r, o) => r && r[o] != null ? r[o] : null, e);
}
function Wh(e, t, n, r = n) {
  let o;
  return typeof e == "function" ? o = e(n) : Array.isArray(e) ? o = e[n] || r : o = $p(e, n) || r, t && (o = t(o, r, e)), o;
}
function Ft(e) {
  const {
    prop: t,
    cssProperty: n = e.prop,
    themeKey: r,
    transform: o
  } = e, a = (s) => {
    if (s[t] == null)
      return null;
    const u = s[t], c = s.theme, f = $p(c, r) || {};
    return ti(s, u, (p) => {
      let g = Wh(f, o, p);
      return p === g && typeof p == "string" && (g = Wh(f, o, `${t}${p === "default" ? "" : kn(p)}`, p)), n === !1 ? g : {
        [n]: g
      };
    });
  };
  return a.propTypes = {}, a.filterProps = [t], a;
}
function q6(e) {
  const t = {};
  return (n) => (t[n] === void 0 && (t[n] = e(n)), t[n]);
}
const G6 = {
  m: "margin",
  p: "padding"
}, Y6 = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
}, wC = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
}, W6 = q6((e) => {
  if (e.length > 2)
    if (wC[e])
      e = wC[e];
    else
      return [e];
  const [t, n] = e.split(""), r = G6[t], o = Y6[n] || "";
  return Array.isArray(o) ? o.map((a) => r + a) : [r + o];
}), f1 = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], d1 = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...f1, ...d1];
function Jc(e, t, n, r) {
  const o = $p(e, t, !0) ?? n;
  return typeof o == "number" || typeof o == "string" ? (a) => typeof a == "string" ? a : typeof o == "string" ? o.startsWith("var(") && a === 0 ? 0 : o.startsWith("var(") && a === 1 ? o : `calc(${a} * ${o})` : o * a : Array.isArray(o) ? (a) => {
    if (typeof a == "string")
      return a;
    const s = Math.abs(a), u = o[s];
    return a >= 0 ? u : typeof u == "number" ? -u : typeof u == "string" && u.startsWith("var(") ? `calc(-1 * ${u})` : `-${u}`;
  } : typeof o == "function" ? o : () => {
  };
}
function h1(e) {
  return Jc(e, "spacing", 8);
}
function ef(e, t) {
  return typeof t == "string" || t == null ? t : e(t);
}
function X6(e, t) {
  return (n) => e.reduce((r, o) => (r[o] = ef(t, n), r), {});
}
function K6(e, t, n, r) {
  if (!t.includes(n))
    return null;
  const o = W6(n), a = X6(o, r), s = e[n];
  return ti(e, s, a);
}
function aM(e, t) {
  const n = h1(e.theme);
  return Object.keys(e).map((r) => K6(e, t, r, n)).reduce(gc, {});
}
function Nt(e) {
  return aM(e, f1);
}
Nt.propTypes = {};
Nt.filterProps = f1;
function Dt(e) {
  return aM(e, d1);
}
Dt.propTypes = {};
Dt.filterProps = d1;
function Bp(...e) {
  const t = e.reduce((r, o) => (o.filterProps.forEach((a) => {
    r[a] = o;
  }), r), {}), n = (r) => Object.keys(r).reduce((o, a) => t[a] ? gc(o, t[a](r)) : o, {});
  return n.propTypes = {}, n.filterProps = e.reduce((r, o) => r.concat(o.filterProps), []), n;
}
function _r(e) {
  return typeof e != "number" ? e : `${e}px solid`;
}
function kr(e, t) {
  return Ft({
    prop: e,
    themeKey: "borders",
    transform: t
  });
}
const Z6 = kr("border", _r), Q6 = kr("borderTop", _r), J6 = kr("borderRight", _r), ez = kr("borderBottom", _r), tz = kr("borderLeft", _r), nz = kr("borderColor"), rz = kr("borderTopColor"), oz = kr("borderRightColor"), iz = kr("borderBottomColor"), az = kr("borderLeftColor"), sz = kr("outline", _r), lz = kr("outlineColor"), Hp = (e) => {
  if (e.borderRadius !== void 0 && e.borderRadius !== null) {
    const t = Jc(e.theme, "shape.borderRadius", 4), n = (r) => ({
      borderRadius: ef(t, r)
    });
    return ti(e, e.borderRadius, n);
  }
  return null;
};
Hp.propTypes = {};
Hp.filterProps = ["borderRadius"];
Bp(Z6, Q6, J6, ez, tz, nz, rz, oz, iz, az, Hp, sz, lz);
const Vp = (e) => {
  if (e.gap !== void 0 && e.gap !== null) {
    const t = Jc(e.theme, "spacing", 8), n = (r) => ({
      gap: ef(t, r)
    });
    return ti(e, e.gap, n);
  }
  return null;
};
Vp.propTypes = {};
Vp.filterProps = ["gap"];
const Up = (e) => {
  if (e.columnGap !== void 0 && e.columnGap !== null) {
    const t = Jc(e.theme, "spacing", 8), n = (r) => ({
      columnGap: ef(t, r)
    });
    return ti(e, e.columnGap, n);
  }
  return null;
};
Up.propTypes = {};
Up.filterProps = ["columnGap"];
const qp = (e) => {
  if (e.rowGap !== void 0 && e.rowGap !== null) {
    const t = Jc(e.theme, "spacing", 8), n = (r) => ({
      rowGap: ef(t, r)
    });
    return ti(e, e.rowGap, n);
  }
  return null;
};
qp.propTypes = {};
qp.filterProps = ["rowGap"];
const uz = Ft({
  prop: "gridColumn"
}), cz = Ft({
  prop: "gridRow"
}), fz = Ft({
  prop: "gridAutoFlow"
}), dz = Ft({
  prop: "gridAutoColumns"
}), hz = Ft({
  prop: "gridAutoRows"
}), pz = Ft({
  prop: "gridTemplateColumns"
}), mz = Ft({
  prop: "gridTemplateRows"
}), gz = Ft({
  prop: "gridTemplateAreas"
}), yz = Ft({
  prop: "gridArea"
});
Bp(Vp, Up, qp, uz, cz, fz, dz, hz, pz, mz, gz, yz);
function al(e, t) {
  return t === "grey" ? t : e;
}
const vz = Ft({
  prop: "color",
  themeKey: "palette",
  transform: al
}), bz = Ft({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: al
}), xz = Ft({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: al
});
Bp(vz, bz, xz);
function nr(e) {
  return e <= 1 && e !== 0 ? `${e * 100}%` : e;
}
const wz = Ft({
  prop: "width",
  transform: nr
}), p1 = (e) => {
  if (e.maxWidth !== void 0 && e.maxWidth !== null) {
    const t = (n) => {
      const r = e.theme?.breakpoints?.values?.[n] || Fp[n];
      return r ? e.theme?.breakpoints?.unit !== "px" ? {
        maxWidth: `${r}${e.theme.breakpoints.unit}`
      } : {
        maxWidth: r
      } : {
        maxWidth: nr(n)
      };
    };
    return ti(e, e.maxWidth, t);
  }
  return null;
};
p1.filterProps = ["maxWidth"];
const _z = Ft({
  prop: "minWidth",
  transform: nr
}), Sz = Ft({
  prop: "height",
  transform: nr
}), Ez = Ft({
  prop: "maxHeight",
  transform: nr
}), Cz = Ft({
  prop: "minHeight",
  transform: nr
});
Ft({
  prop: "size",
  cssProperty: "width",
  transform: nr
});
Ft({
  prop: "size",
  cssProperty: "height",
  transform: nr
});
const kz = Ft({
  prop: "boxSizing"
});
Bp(wz, p1, _z, Sz, Ez, Cz, kz);
const Gp = {
  // borders
  border: {
    themeKey: "borders",
    transform: _r
  },
  borderTop: {
    themeKey: "borders",
    transform: _r
  },
  borderRight: {
    themeKey: "borders",
    transform: _r
  },
  borderBottom: {
    themeKey: "borders",
    transform: _r
  },
  borderLeft: {
    themeKey: "borders",
    transform: _r
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: _r
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: Hp
  },
  // palette
  color: {
    themeKey: "palette",
    transform: al
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: al
  },
  backgroundColor: {
    themeKey: "palette",
    transform: al
  },
  // spacing
  p: {
    style: Dt
  },
  pt: {
    style: Dt
  },
  pr: {
    style: Dt
  },
  pb: {
    style: Dt
  },
  pl: {
    style: Dt
  },
  px: {
    style: Dt
  },
  py: {
    style: Dt
  },
  padding: {
    style: Dt
  },
  paddingTop: {
    style: Dt
  },
  paddingRight: {
    style: Dt
  },
  paddingBottom: {
    style: Dt
  },
  paddingLeft: {
    style: Dt
  },
  paddingX: {
    style: Dt
  },
  paddingY: {
    style: Dt
  },
  paddingInline: {
    style: Dt
  },
  paddingInlineStart: {
    style: Dt
  },
  paddingInlineEnd: {
    style: Dt
  },
  paddingBlock: {
    style: Dt
  },
  paddingBlockStart: {
    style: Dt
  },
  paddingBlockEnd: {
    style: Dt
  },
  m: {
    style: Nt
  },
  mt: {
    style: Nt
  },
  mr: {
    style: Nt
  },
  mb: {
    style: Nt
  },
  ml: {
    style: Nt
  },
  mx: {
    style: Nt
  },
  my: {
    style: Nt
  },
  margin: {
    style: Nt
  },
  marginTop: {
    style: Nt
  },
  marginRight: {
    style: Nt
  },
  marginBottom: {
    style: Nt
  },
  marginLeft: {
    style: Nt
  },
  marginX: {
    style: Nt
  },
  marginY: {
    style: Nt
  },
  marginInline: {
    style: Nt
  },
  marginInlineStart: {
    style: Nt
  },
  marginInlineEnd: {
    style: Nt
  },
  marginBlock: {
    style: Nt
  },
  marginBlockStart: {
    style: Nt
  },
  marginBlockEnd: {
    style: Nt
  },
  // display
  displayPrint: {
    cssProperty: !1,
    transform: (e) => ({
      "@media print": {
        display: e
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: Vp
  },
  rowGap: {
    style: qp
  },
  columnGap: {
    style: Up
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: nr
  },
  maxWidth: {
    style: p1
  },
  minWidth: {
    transform: nr
  },
  height: {
    transform: nr
  },
  maxHeight: {
    transform: nr
  },
  minHeight: {
    transform: nr
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: "font"
  },
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: !1,
    themeKey: "typography"
  }
};
function Tz(...e) {
  const t = e.reduce((r, o) => r.concat(Object.keys(o)), []), n = new Set(t);
  return e.every((r) => n.size === Object.keys(r).length);
}
function Az(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Rz() {
  function e(n, r, o, a) {
    const s = {
      [n]: r,
      theme: o
    }, u = a[n];
    if (!u)
      return {
        [n]: r
      };
    const {
      cssProperty: c = n,
      themeKey: f,
      transform: h,
      style: p
    } = u;
    if (r == null)
      return null;
    if (f === "typography" && r === "inherit")
      return {
        [n]: r
      };
    const g = $p(o, f) || {};
    return p ? p(s) : ti(s, r, (w) => {
      let v = Wh(g, h, w);
      return w === v && typeof w == "string" && (v = Wh(g, h, `${n}${w === "default" ? "" : kn(w)}`, w)), c === !1 ? v : {
        [c]: v
      };
    });
  }
  function t(n) {
    const {
      sx: r,
      theme: o = {},
      nested: a
    } = n || {};
    if (!r)
      return null;
    const s = o.unstable_sxConfig ?? Gp;
    function u(c) {
      let f = c;
      if (typeof c == "function")
        f = c(o);
      else if (typeof c != "object")
        return c;
      if (!f)
        return null;
      const h = U6(o.breakpoints), p = Object.keys(h);
      let g = h;
      return Object.keys(f).forEach((y) => {
        const w = Az(f[y], o);
        if (w != null)
          if (typeof w == "object")
            if (s[y])
              g = gc(g, e(y, w, o, s));
            else {
              const v = ti({
                theme: o
              }, w, (S) => ({
                [y]: S
              }));
              Tz(v, w) ? g[y] = t({
                sx: w,
                theme: o,
                nested: !0
              }) : g = gc(g, v);
            }
          else
            g = gc(g, e(y, w, o, s));
      }), !a && o.modularCssLayers ? {
        "@layer sx": vC(o, xC(p, g))
      } : vC(o, xC(p, g));
    }
    return Array.isArray(r) ? r.map(u) : u(r);
  }
  return t;
}
const yl = Rz();
yl.filterProps = ["sx"];
function Re() {
  return Re = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Re.apply(null, arguments);
}
function Mz(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function Oz(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var Nz = /* @__PURE__ */ function() {
  function e(n) {
    var r = this;
    this._insertTag = function(o) {
      var a;
      r.tags.length === 0 ? r.insertionPoint ? a = r.insertionPoint.nextSibling : r.prepend ? a = r.container.firstChild : a = r.before : a = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(o, a), r.tags.push(o);
    }, this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(r) {
    r.forEach(this._insertTag);
  }, t.insert = function(r) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(Oz(this));
    var o = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var a = Mz(o);
      try {
        a.insertRule(r, a.cssRules.length);
      } catch {
      }
    } else
      o.appendChild(document.createTextNode(r));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(r) {
      var o;
      return (o = r.parentNode) == null ? void 0 : o.removeChild(r);
    }), this.tags = [], this.ctr = 0;
  }, e;
}(), mn = "-ms-", Xh = "-moz-", ot = "-webkit-", sM = "comm", m1 = "rule", g1 = "decl", Dz = "@import", lM = "@keyframes", Pz = "@layer", jz = Math.abs, Yp = String.fromCharCode, Iz = Object.assign;
function zz(e, t) {
  return un(e, 0) ^ 45 ? (((t << 2 ^ un(e, 0)) << 2 ^ un(e, 1)) << 2 ^ un(e, 2)) << 2 ^ un(e, 3) : 0;
}
function uM(e) {
  return e.trim();
}
function Lz(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function it(e, t, n) {
  return e.replace(t, n);
}
function Iv(e, t) {
  return e.indexOf(t);
}
function un(e, t) {
  return e.charCodeAt(t) | 0;
}
function kc(e, t, n) {
  return e.slice(t, n);
}
function ro(e) {
  return e.length;
}
function y1(e) {
  return e.length;
}
function Gd(e, t) {
  return t.push(e), e;
}
function Fz(e, t) {
  return e.map(t).join("");
}
var Wp = 1, vl = 1, cM = 0, Bn = 0, Yt = 0, Pl = "";
function Xp(e, t, n, r, o, a, s) {
  return { value: e, root: t, parent: n, type: r, props: o, children: a, line: Wp, column: vl, length: s, return: "" };
}
function Ju(e, t) {
  return Iz(Xp("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function $z() {
  return Yt;
}
function Bz() {
  return Yt = Bn > 0 ? un(Pl, --Bn) : 0, vl--, Yt === 10 && (vl = 1, Wp--), Yt;
}
function ir() {
  return Yt = Bn < cM ? un(Pl, Bn++) : 0, vl++, Yt === 10 && (vl = 1, Wp++), Yt;
}
function ho() {
  return un(Pl, Bn);
}
function kh() {
  return Bn;
}
function tf(e, t) {
  return kc(Pl, e, t);
}
function Tc(e) {
  switch (e) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function fM(e) {
  return Wp = vl = 1, cM = ro(Pl = e), Bn = 0, [];
}
function dM(e) {
  return Pl = "", e;
}
function Th(e) {
  return uM(tf(Bn - 1, zv(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function Hz(e) {
  for (; (Yt = ho()) && Yt < 33; )
    ir();
  return Tc(e) > 2 || Tc(Yt) > 3 ? "" : " ";
}
function Vz(e, t) {
  for (; --t && ir() && !(Yt < 48 || Yt > 102 || Yt > 57 && Yt < 65 || Yt > 70 && Yt < 97); )
    ;
  return tf(e, kh() + (t < 6 && ho() == 32 && ir() == 32));
}
function zv(e) {
  for (; ir(); )
    switch (Yt) {
      // ] ) " '
      case e:
        return Bn;
      // " '
      case 34:
      case 39:
        e !== 34 && e !== 39 && zv(Yt);
        break;
      // (
      case 40:
        e === 41 && zv(e);
        break;
      // \
      case 92:
        ir();
        break;
    }
  return Bn;
}
function Uz(e, t) {
  for (; ir() && e + Yt !== 57; )
    if (e + Yt === 84 && ho() === 47)
      break;
  return "/*" + tf(t, Bn - 1) + "*" + Yp(e === 47 ? e : ir());
}
function qz(e) {
  for (; !Tc(ho()); )
    ir();
  return tf(e, Bn);
}
function Gz(e) {
  return dM(Ah("", null, null, null, [""], e = fM(e), 0, [0], e));
}
function Ah(e, t, n, r, o, a, s, u, c) {
  for (var f = 0, h = 0, p = s, g = 0, y = 0, w = 0, v = 1, S = 1, E = 1, T = 0, k = "", A = o, M = a, N = r, P = k; S; )
    switch (w = T, T = ir()) {
      // (
      case 40:
        if (w != 108 && un(P, p - 1) == 58) {
          Iv(P += it(Th(T), "&", "&\f"), "&\f") != -1 && (E = -1);
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        P += Th(T);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        P += Hz(w);
        break;
      // \
      case 92:
        P += Vz(kh() - 1, 7);
        continue;
      // /
      case 47:
        switch (ho()) {
          case 42:
          case 47:
            Gd(Yz(Uz(ir(), kh()), t, n), c);
            break;
          default:
            P += "/";
        }
        break;
      // {
      case 123 * v:
        u[f++] = ro(P) * E;
      // } ; \0
      case 125 * v:
      case 59:
      case 0:
        switch (T) {
          // \0 }
          case 0:
          case 125:
            S = 0;
          // ;
          case 59 + h:
            E == -1 && (P = it(P, /\f/g, "")), y > 0 && ro(P) - p && Gd(y > 32 ? SC(P + ";", r, n, p - 1) : SC(it(P, " ", "") + ";", r, n, p - 2), c);
            break;
          // @ ;
          case 59:
            P += ";";
          // { rule/at-rule
          default:
            if (Gd(N = _C(P, t, n, f, h, o, u, k, A = [], M = [], p), a), T === 123)
              if (h === 0)
                Ah(P, t, N, N, A, a, p, u, M);
              else
                switch (g === 99 && un(P, 3) === 110 ? 100 : g) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Ah(e, N, N, r && Gd(_C(e, N, N, 0, 0, o, u, k, o, A = [], p), M), o, M, p, u, r ? A : M);
                    break;
                  default:
                    Ah(P, N, N, N, [""], M, 0, u, M);
                }
        }
        f = h = y = 0, v = E = 1, k = P = "", p = s;
        break;
      // :
      case 58:
        p = 1 + ro(P), y = w;
      default:
        if (v < 1) {
          if (T == 123)
            --v;
          else if (T == 125 && v++ == 0 && Bz() == 125)
            continue;
        }
        switch (P += Yp(T), T * v) {
          // &
          case 38:
            E = h > 0 ? 1 : (P += "\f", -1);
            break;
          // ,
          case 44:
            u[f++] = (ro(P) - 1) * E, E = 1;
            break;
          // @
          case 64:
            ho() === 45 && (P += Th(ir())), g = ho(), h = p = ro(k = P += qz(kh())), T++;
            break;
          // -
          case 45:
            w === 45 && ro(P) == 2 && (v = 0);
        }
    }
  return a;
}
function _C(e, t, n, r, o, a, s, u, c, f, h) {
  for (var p = o - 1, g = o === 0 ? a : [""], y = y1(g), w = 0, v = 0, S = 0; w < r; ++w)
    for (var E = 0, T = kc(e, p + 1, p = jz(v = s[w])), k = e; E < y; ++E)
      (k = uM(v > 0 ? g[E] + " " + T : it(T, /&\f/g, g[E]))) && (c[S++] = k);
  return Xp(e, t, n, o === 0 ? m1 : u, c, f, h);
}
function Yz(e, t, n) {
  return Xp(e, t, n, sM, Yp($z()), kc(e, 2, -2), 0);
}
function SC(e, t, n, r) {
  return Xp(e, t, n, g1, kc(e, 0, r), kc(e, r + 1, -1), r);
}
function sl(e, t) {
  for (var n = "", r = y1(e), o = 0; o < r; o++)
    n += t(e[o], o, e, t) || "";
  return n;
}
function Wz(e, t, n, r) {
  switch (e.type) {
    case Pz:
      if (e.children.length) break;
    case Dz:
    case g1:
      return e.return = e.return || e.value;
    case sM:
      return "";
    case lM:
      return e.return = e.value + "{" + sl(e.children, r) + "}";
    case m1:
      e.value = e.props.join(",");
  }
  return ro(n = sl(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
}
function Xz(e) {
  var t = y1(e);
  return function(n, r, o, a) {
    for (var s = "", u = 0; u < t; u++)
      s += e[u](n, r, o, a) || "";
    return s;
  };
}
function Kz(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function hM(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var Zz = function(t, n, r) {
  for (var o = 0, a = 0; o = a, a = ho(), o === 38 && a === 12 && (n[r] = 1), !Tc(a); )
    ir();
  return tf(t, Bn);
}, Qz = function(t, n) {
  var r = -1, o = 44;
  do
    switch (Tc(o)) {
      case 0:
        o === 38 && ho() === 12 && (n[r] = 1), t[r] += Zz(Bn - 1, n, r);
        break;
      case 2:
        t[r] += Th(o);
        break;
      case 4:
        if (o === 44) {
          t[++r] = ho() === 58 ? "&\f" : "", n[r] = t[r].length;
          break;
        }
      // fallthrough
      default:
        t[r] += Yp(o);
    }
  while (o = ir());
  return t;
}, Jz = function(t, n) {
  return dM(Qz(fM(t), n));
}, EC = /* @__PURE__ */ new WeakMap(), eL = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var n = t.value, r = t.parent, o = t.column === r.column && t.line === r.line; r.type !== "rule"; )
      if (r = r.parent, !r) return;
    if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !EC.get(r)) && !o) {
      EC.set(t, !0);
      for (var a = [], s = Jz(n, a), u = r.props, c = 0, f = 0; c < s.length; c++)
        for (var h = 0; h < u.length; h++, f++)
          t.props[f] = a[c] ? s[c].replace(/&\f/g, u[h]) : u[h] + " " + s[c];
    }
  }
}, tL = function(t) {
  if (t.type === "decl") {
    var n = t.value;
    // charcode for l
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
};
function pM(e, t) {
  switch (zz(e, t)) {
    // color-adjust
    case 5103:
      return ot + "print-" + e + e;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return ot + e + e;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return ot + e + Xh + e + mn + e + e;
    // flex, flex-direction
    case 6828:
    case 4268:
      return ot + e + mn + e + e;
    // order
    case 6165:
      return ot + e + mn + "flex-" + e + e;
    // align-items
    case 5187:
      return ot + e + it(e, /(\w+).+(:[^]+)/, ot + "box-$1$2" + mn + "flex-$1$2") + e;
    // align-self
    case 5443:
      return ot + e + mn + "flex-item-" + it(e, /flex-|-self/, "") + e;
    // align-content
    case 4675:
      return ot + e + mn + "flex-line-pack" + it(e, /align-content|flex-|-self/, "") + e;
    // flex-shrink
    case 5548:
      return ot + e + mn + it(e, "shrink", "negative") + e;
    // flex-basis
    case 5292:
      return ot + e + mn + it(e, "basis", "preferred-size") + e;
    // flex-grow
    case 6060:
      return ot + "box-" + it(e, "-grow", "") + ot + e + mn + it(e, "grow", "positive") + e;
    // transition
    case 4554:
      return ot + it(e, /([^-])(transform)/g, "$1" + ot + "$2") + e;
    // cursor
    case 6187:
      return it(it(it(e, /(zoom-|grab)/, ot + "$1"), /(image-set)/, ot + "$1"), e, "") + e;
    // background, background-image
    case 5495:
    case 3959:
      return it(e, /(image-set\([^]*)/, ot + "$1$`$1");
    // justify-content
    case 4968:
      return it(it(e, /(.+:)(flex-)?(.*)/, ot + "box-pack:$3" + mn + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + ot + e + e;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return it(e, /(.+)-inline(.+)/, ot + "$1$2") + e;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (ro(e) - 1 - t > 6) switch (un(e, t + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (un(e, t + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return it(e, /(.+:)(.+)-([^]+)/, "$1" + ot + "$2-$3$1" + Xh + (un(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        // (s)tretch
        case 115:
          return ~Iv(e, "stretch") ? pM(it(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    // position: sticky
    case 4949:
      if (un(e, t + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (un(e, ro(e) - 3 - (~Iv(e, "!important") && 10))) {
        // stic(k)y
        case 107:
          return it(e, ":", ":" + ot) + e;
        // (inline-)?fl(e)x
        case 101:
          return it(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + ot + (un(e, 14) === 45 ? "inline-" : "") + "box$3$1" + ot + "$2$3$1" + mn + "$2box$3") + e;
      }
      break;
    // writing-mode
    case 5936:
      switch (un(e, t + 11)) {
        // vertical-l(r)
        case 114:
          return ot + e + mn + it(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        // vertical-r(l)
        case 108:
          return ot + e + mn + it(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        // horizontal(-)tb
        case 45:
          return ot + e + mn + it(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return ot + e + mn + e + e;
  }
  return e;
}
var nL = function(t, n, r, o) {
  if (t.length > -1 && !t.return) switch (t.type) {
    case g1:
      t.return = pM(t.value, t.length);
      break;
    case lM:
      return sl([Ju(t, {
        value: it(t.value, "@", "@" + ot)
      })], o);
    case m1:
      if (t.length) return Fz(t.props, function(a) {
        switch (Lz(a, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ":read-only":
          case ":read-write":
            return sl([Ju(t, {
              props: [it(a, /:(read-\w+)/, ":" + Xh + "$1")]
            })], o);
          // :placeholder
          case "::placeholder":
            return sl([Ju(t, {
              props: [it(a, /:(plac\w+)/, ":" + ot + "input-$1")]
            }), Ju(t, {
              props: [it(a, /:(plac\w+)/, ":" + Xh + "$1")]
            }), Ju(t, {
              props: [it(a, /:(plac\w+)/, mn + "input-$1")]
            })], o);
        }
        return "";
      });
  }
}, rL = [nL], oL = function(t) {
  var n = t.key;
  if (n === "css") {
    var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(r, function(v) {
      var S = v.getAttribute("data-emotion");
      S.indexOf(" ") !== -1 && (document.head.appendChild(v), v.setAttribute("data-s", ""));
    });
  }
  var o = t.stylisPlugins || rL, a = {}, s, u = [];
  s = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(v) {
      for (var S = v.getAttribute("data-emotion").split(" "), E = 1; E < S.length; E++)
        a[S[E]] = !0;
      u.push(v);
    }
  );
  var c, f = [eL, tL];
  {
    var h, p = [Wz, Kz(function(v) {
      h.insert(v);
    })], g = Xz(f.concat(o, p)), y = function(S) {
      return sl(Gz(S), g);
    };
    c = function(S, E, T, k) {
      h = T, y(S ? S + "{" + E.styles + "}" : E.styles), k && (w.inserted[E.name] = !0);
    };
  }
  var w = {
    key: n,
    sheet: new Nz({
      key: n,
      container: s,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: a,
    registered: {},
    insert: c
  };
  return w.sheet.hydrate(u), w;
}, Sy = { exports: {} }, at = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var CC;
function iL() {
  if (CC) return at;
  CC = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, a = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, u = e ? Symbol.for("react.context") : 60110, c = e ? Symbol.for("react.async_mode") : 60111, f = e ? Symbol.for("react.concurrent_mode") : 60111, h = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, g = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, w = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, S = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, T = e ? Symbol.for("react.scope") : 60119;
  function k(M) {
    if (typeof M == "object" && M !== null) {
      var N = M.$$typeof;
      switch (N) {
        case t:
          switch (M = M.type, M) {
            case c:
            case f:
            case r:
            case a:
            case o:
            case p:
              return M;
            default:
              switch (M = M && M.$$typeof, M) {
                case u:
                case h:
                case w:
                case y:
                case s:
                  return M;
                default:
                  return N;
              }
          }
        case n:
          return N;
      }
    }
  }
  function A(M) {
    return k(M) === f;
  }
  return at.AsyncMode = c, at.ConcurrentMode = f, at.ContextConsumer = u, at.ContextProvider = s, at.Element = t, at.ForwardRef = h, at.Fragment = r, at.Lazy = w, at.Memo = y, at.Portal = n, at.Profiler = a, at.StrictMode = o, at.Suspense = p, at.isAsyncMode = function(M) {
    return A(M) || k(M) === c;
  }, at.isConcurrentMode = A, at.isContextConsumer = function(M) {
    return k(M) === u;
  }, at.isContextProvider = function(M) {
    return k(M) === s;
  }, at.isElement = function(M) {
    return typeof M == "object" && M !== null && M.$$typeof === t;
  }, at.isForwardRef = function(M) {
    return k(M) === h;
  }, at.isFragment = function(M) {
    return k(M) === r;
  }, at.isLazy = function(M) {
    return k(M) === w;
  }, at.isMemo = function(M) {
    return k(M) === y;
  }, at.isPortal = function(M) {
    return k(M) === n;
  }, at.isProfiler = function(M) {
    return k(M) === a;
  }, at.isStrictMode = function(M) {
    return k(M) === o;
  }, at.isSuspense = function(M) {
    return k(M) === p;
  }, at.isValidElementType = function(M) {
    return typeof M == "string" || typeof M == "function" || M === r || M === f || M === a || M === o || M === p || M === g || typeof M == "object" && M !== null && (M.$$typeof === w || M.$$typeof === y || M.$$typeof === s || M.$$typeof === u || M.$$typeof === h || M.$$typeof === S || M.$$typeof === E || M.$$typeof === T || M.$$typeof === v);
  }, at.typeOf = k, at;
}
var kC;
function aL() {
  return kC || (kC = 1, Sy.exports = iL()), Sy.exports;
}
var Ey, TC;
function sL() {
  if (TC) return Ey;
  TC = 1;
  var e = aL(), t = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0
  }, n = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0
  }, r = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
  }, o = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
  }, a = {};
  a[e.ForwardRef] = r, a[e.Memo] = o;
  function s(w) {
    return e.isMemo(w) ? o : a[w.$$typeof] || t;
  }
  var u = Object.defineProperty, c = Object.getOwnPropertyNames, f = Object.getOwnPropertySymbols, h = Object.getOwnPropertyDescriptor, p = Object.getPrototypeOf, g = Object.prototype;
  function y(w, v, S) {
    if (typeof v != "string") {
      if (g) {
        var E = p(v);
        E && E !== g && y(w, E, S);
      }
      var T = c(v);
      f && (T = T.concat(f(v)));
      for (var k = s(w), A = s(v), M = 0; M < T.length; ++M) {
        var N = T[M];
        if (!n[N] && !(S && S[N]) && !(A && A[N]) && !(k && k[N])) {
          var P = h(v, N);
          try {
            u(w, N, P);
          } catch {
          }
        }
      }
    }
    return w;
  }
  return Ey = y, Ey;
}
sL();
var lL = !0;
function mM(e, t, n) {
  var r = "";
  return n.split(" ").forEach(function(o) {
    e[o] !== void 0 ? t.push(e[o] + ";") : o && (r += o + " ");
  }), r;
}
var v1 = function(t, n, r) {
  var o = t.key + "-" + n.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (r === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  lL === !1) && t.registered[o] === void 0 && (t.registered[o] = n.styles);
}, gM = function(t, n, r) {
  v1(t, n, r);
  var o = t.key + "-" + n.name;
  if (t.inserted[n.name] === void 0) {
    var a = n;
    do
      t.insert(n === a ? "." + o : "", a, t.sheet, !0), a = a.next;
    while (a !== void 0);
  }
};
function uL(e) {
  for (var t = 0, n, r = 0, o = e.length; o >= 4; ++r, o -= 4)
    n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (o) {
    case 3:
      t ^= (e.charCodeAt(r + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(r + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var cL = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, fL = /[A-Z]|^ms/g, dL = /_EMO_([^_]+?)_([^]*?)_EMO_/g, yM = function(t) {
  return t.charCodeAt(1) === 45;
}, AC = function(t) {
  return t != null && typeof t != "boolean";
}, Cy = /* @__PURE__ */ hM(function(e) {
  return yM(e) ? e : e.replace(fL, "-$&").toLowerCase();
}), RC = function(t, n) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(dL, function(r, o, a) {
          return oo = {
            name: o,
            styles: a,
            next: oo
          }, o;
        });
  }
  return cL[t] !== 1 && !yM(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
};
function Ac(e, t, n) {
  if (n == null)
    return "";
  var r = n;
  if (r.__emotion_styles !== void 0)
    return r;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var o = n;
      if (o.anim === 1)
        return oo = {
          name: o.name,
          styles: o.styles,
          next: oo
        }, o.name;
      var a = n;
      if (a.styles !== void 0) {
        var s = a.next;
        if (s !== void 0)
          for (; s !== void 0; )
            oo = {
              name: s.name,
              styles: s.styles,
              next: oo
            }, s = s.next;
        var u = a.styles + ";";
        return u;
      }
      return hL(e, t, n);
    }
    case "function": {
      if (e !== void 0) {
        var c = oo, f = n(e);
        return oo = c, Ac(e, t, f);
      }
      break;
    }
  }
  var h = n;
  if (t == null)
    return h;
  var p = t[h];
  return p !== void 0 ? p : h;
}
function hL(e, t, n) {
  var r = "";
  if (Array.isArray(n))
    for (var o = 0; o < n.length; o++)
      r += Ac(e, t, n[o]) + ";";
  else
    for (var a in n) {
      var s = n[a];
      if (typeof s != "object") {
        var u = s;
        t != null && t[u] !== void 0 ? r += a + "{" + t[u] + "}" : AC(u) && (r += Cy(a) + ":" + RC(a, u) + ";");
      } else if (Array.isArray(s) && typeof s[0] == "string" && (t == null || t[s[0]] === void 0))
        for (var c = 0; c < s.length; c++)
          AC(s[c]) && (r += Cy(a) + ":" + RC(a, s[c]) + ";");
      else {
        var f = Ac(e, t, s);
        switch (a) {
          case "animation":
          case "animationName": {
            r += Cy(a) + ":" + f + ";";
            break;
          }
          default:
            r += a + "{" + f + "}";
        }
      }
    }
  return r;
}
var MC = /label:\s*([^\s;{]+)\s*(;|$)/g, oo;
function Kp(e, t, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var r = !0, o = "";
  oo = void 0;
  var a = e[0];
  if (a == null || a.raw === void 0)
    r = !1, o += Ac(n, t, a);
  else {
    var s = a;
    o += s[0];
  }
  for (var u = 1; u < e.length; u++)
    if (o += Ac(n, t, e[u]), r) {
      var c = a;
      o += c[u];
    }
  MC.lastIndex = 0;
  for (var f = "", h; (h = MC.exec(o)) !== null; )
    f += "-" + h[1];
  var p = uL(o) + f;
  return {
    name: p,
    styles: o,
    next: oo
  };
}
var pL = function(t) {
  return t();
}, mL = gl.useInsertionEffect ? gl.useInsertionEffect : !1, vM = mL || pL, bM = /* @__PURE__ */ _.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ oL({
    key: "css"
  }) : null
);
bM.Provider;
var xM = function(t) {
  return /* @__PURE__ */ _.forwardRef(function(n, r) {
    var o = _.useContext(bM);
    return t(n, o, r);
  });
}, wM = /* @__PURE__ */ _.createContext({}), b1 = {}.hasOwnProperty, Lv = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", gL = function(t, n) {
  var r = {};
  for (var o in n)
    b1.call(n, o) && (r[o] = n[o]);
  return r[Lv] = t, r;
}, yL = function(t) {
  var n = t.cache, r = t.serialized, o = t.isStringTag;
  return v1(n, r, o), vM(function() {
    return gM(n, r, o);
  }), null;
}, vL = /* @__PURE__ */ xM(function(e, t, n) {
  var r = e.css;
  typeof r == "string" && t.registered[r] !== void 0 && (r = t.registered[r]);
  var o = e[Lv], a = [r], s = "";
  typeof e.className == "string" ? s = mM(t.registered, a, e.className) : e.className != null && (s = e.className + " ");
  var u = Kp(a, void 0, _.useContext(wM));
  s += t.key + "-" + u.name;
  var c = {};
  for (var f in e)
    b1.call(e, f) && f !== "css" && f !== Lv && (c[f] = e[f]);
  return c.className = s, n && (c.ref = n), /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(yL, {
    cache: t,
    serialized: u,
    isStringTag: typeof o == "string"
  }), /* @__PURE__ */ _.createElement(o, c));
}), bL = vL, ke = function(t, n) {
  var r = arguments;
  if (n == null || !b1.call(n, "css"))
    return _.createElement.apply(void 0, r);
  var o = r.length, a = new Array(o);
  a[0] = bL, a[1] = gL(t, n);
  for (var s = 2; s < o; s++)
    a[s] = r[s];
  return _.createElement.apply(null, a);
};
(function(e) {
  var t;
  t || (t = e.JSX || (e.JSX = {}));
})(ke || (ke = {}));
function x1() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return Kp(t);
}
function Zp() {
  var e = x1.apply(void 0, arguments), t = "animation-" + e.name;
  return {
    name: t,
    styles: "@keyframes " + t + "{" + e.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
var xL = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, wL = /* @__PURE__ */ hM(
  function(e) {
    return xL.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
  }
  /* Z+1 */
), _L = wL, SL = function(t) {
  return t !== "theme";
}, OC = function(t) {
  return typeof t == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  t.charCodeAt(0) > 96 ? _L : SL;
}, NC = function(t, n, r) {
  var o;
  if (n) {
    var a = n.shouldForwardProp;
    o = t.__emotion_forwardProp && a ? function(s) {
      return t.__emotion_forwardProp(s) && a(s);
    } : a;
  }
  return typeof o != "function" && r && (o = t.__emotion_forwardProp), o;
}, EL = function(t) {
  var n = t.cache, r = t.serialized, o = t.isStringTag;
  return v1(n, r, o), vM(function() {
    return gM(n, r, o);
  }), null;
}, CL = function e(t, n) {
  var r = t.__emotion_real === t, o = r && t.__emotion_base || t, a, s;
  n !== void 0 && (a = n.label, s = n.target);
  var u = NC(t, n, r), c = u || OC(o), f = !c("as");
  return function() {
    var h = arguments, p = r && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
    if (a !== void 0 && p.push("label:" + a + ";"), h[0] == null || h[0].raw === void 0)
      p.push.apply(p, h);
    else {
      var g = h[0];
      p.push(g[0]);
      for (var y = h.length, w = 1; w < y; w++)
        p.push(h[w], g[w]);
    }
    var v = xM(function(S, E, T) {
      var k = f && S.as || o, A = "", M = [], N = S;
      if (S.theme == null) {
        N = {};
        for (var P in S)
          N[P] = S[P];
        N.theme = _.useContext(wM);
      }
      typeof S.className == "string" ? A = mM(E.registered, M, S.className) : S.className != null && (A = S.className + " ");
      var z = Kp(p.concat(M), E.registered, N);
      A += E.key + "-" + z.name, s !== void 0 && (A += " " + s);
      var B = f && u === void 0 ? OC(k) : c, R = {};
      for (var F in S)
        f && F === "as" || B(F) && (R[F] = S[F]);
      return R.className = A, T && (R.ref = T), /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(EL, {
        cache: E,
        serialized: z,
        isStringTag: typeof k == "string"
      }), /* @__PURE__ */ _.createElement(k, R));
    });
    return v.displayName = a !== void 0 ? a : "Styled(" + (typeof o == "string" ? o : o.displayName || o.name || "Component") + ")", v.defaultProps = t.defaultProps, v.__emotion_real = v, v.__emotion_base = o, v.__emotion_styles = p, v.__emotion_forwardProp = u, Object.defineProperty(v, "toString", {
      value: function() {
        return "." + s;
      }
    }), v.withComponent = function(S, E) {
      var T = e(S, Re({}, n, E, {
        shouldForwardProp: NC(v, E, !0)
      }));
      return T.apply(void 0, p);
    }, v;
  };
}, kL = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], Fv = CL.bind(null);
kL.forEach(function(e) {
  Fv[e] = Fv(e);
});
function TL(e, t) {
  return Fv(e, t);
}
function AL(e, t) {
  Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles));
}
const DC = [];
function La(e) {
  return DC[0] = e, Kp(DC);
}
const RL = (e) => {
  const t = Object.keys(e).map((n) => ({
    key: n,
    val: e[n]
  })) || [];
  return t.sort((n, r) => n.val - r.val), t.reduce((n, r) => ({
    ...n,
    [r.key]: r.val
  }), {});
};
function ML(e) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: t = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit: n = "px",
    step: r = 5,
    ...o
  } = e, a = RL(t), s = Object.keys(a);
  function u(g) {
    return `@media (min-width:${typeof t[g] == "number" ? t[g] : g}${n})`;
  }
  function c(g) {
    return `@media (max-width:${(typeof t[g] == "number" ? t[g] : g) - r / 100}${n})`;
  }
  function f(g, y) {
    const w = s.indexOf(y);
    return `@media (min-width:${typeof t[g] == "number" ? t[g] : g}${n}) and (max-width:${(w !== -1 && typeof t[s[w]] == "number" ? t[s[w]] : y) - r / 100}${n})`;
  }
  function h(g) {
    return s.indexOf(g) + 1 < s.length ? f(g, s[s.indexOf(g) + 1]) : u(g);
  }
  function p(g) {
    const y = s.indexOf(g);
    return y === 0 ? u(s[1]) : y === s.length - 1 ? c(s[y]) : f(g, s[s.indexOf(g) + 1]).replace("@media", "@media not all and");
  }
  return {
    keys: s,
    values: a,
    up: u,
    down: c,
    between: f,
    only: h,
    not: p,
    unit: n,
    ...o
  };
}
const OL = {
  borderRadius: 4
};
function _M(e = 8, t = h1({
  spacing: e
})) {
  if (e.mui)
    return e;
  const n = (...r) => (r.length === 0 ? [1] : r).map((a) => {
    const s = t(a);
    return typeof s == "number" ? `${s}px` : s;
  }).join(" ");
  return n.mui = !0, n;
}
function NL(e, t) {
  const n = this;
  if (n.vars) {
    if (!n.colorSchemes?.[e] || typeof n.getColorSchemeSelector != "function")
      return {};
    let r = n.getColorSchemeSelector(e);
    return r === "&" ? t : ((r.includes("data-") || r.includes(".")) && (r = `*:where(${r.replace(/\s*&$/, "")}) &`), {
      [r]: t
    });
  }
  return n.palette.mode === e ? t : {};
}
function SM(e = {}, ...t) {
  const {
    breakpoints: n = {},
    palette: r = {},
    spacing: o,
    shape: a = {},
    ...s
  } = e, u = ML(n), c = _M(o);
  let f = or({
    breakpoints: u,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: {
      mode: "light",
      ...r
    },
    spacing: c,
    shape: {
      ...OL,
      ...a
    }
  }, s);
  return f = H6(f), f.applyStyles = NL, f = t.reduce((h, p) => or(h, p), f), f.unstable_sxConfig = {
    ...Gp,
    ...s?.unstable_sxConfig
  }, f.unstable_sx = function(p) {
    return yl({
      sx: p,
      theme: this
    });
  }, f;
}
const PC = (e) => e, DL = () => {
  let e = PC;
  return {
    configure(t) {
      e = t;
    },
    generate(t) {
      return e(t);
    },
    reset() {
      e = PC;
    }
  };
}, PL = DL(), jL = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function bo(e, t, n = "Mui") {
  const r = jL[t];
  return r ? `${n}-${r}` : `${PL.generate(e)}-${t}`;
}
function xo(e, t, n = "Mui") {
  const r = {};
  return t.forEach((o) => {
    r[o] = bo(e, o, n);
  }), r;
}
function EM(e) {
  const {
    variants: t,
    ...n
  } = e, r = {
    variants: t,
    style: La(n),
    isProcessed: !0
  };
  return r.style === n || t && t.forEach((o) => {
    typeof o.style != "function" && (o.style = La(o.style));
  }), r;
}
const IL = SM();
function ky(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
function Da(e, t) {
  return t && e && typeof e == "object" && e.styles && !e.styles.startsWith("@layer") && (e.styles = `@layer ${t}{${String(e.styles)}}`), e;
}
function zL(e) {
  return e ? (t, n) => n[e] : null;
}
function LL(e, t, n) {
  e.theme = BL(e.theme) ? n : e.theme[t] || e.theme;
}
function Rh(e, t, n) {
  const r = typeof t == "function" ? t(e) : t;
  if (Array.isArray(r))
    return r.flatMap((o) => Rh(e, o, n));
  if (Array.isArray(r?.variants)) {
    let o;
    if (r.isProcessed)
      o = n ? Da(r.style, n) : r.style;
    else {
      const {
        variants: a,
        ...s
      } = r;
      o = n ? Da(La(s), n) : s;
    }
    return CM(e, r.variants, [o], n);
  }
  return r?.isProcessed ? n ? Da(La(r.style), n) : r.style : n ? Da(La(r), n) : r;
}
function CM(e, t, n = [], r = void 0) {
  let o;
  e: for (let a = 0; a < t.length; a += 1) {
    const s = t[a];
    if (typeof s.props == "function") {
      if (o ?? (o = {
        ...e,
        ...e.ownerState,
        ownerState: e.ownerState
      }), !s.props(o))
        continue;
    } else
      for (const u in s.props)
        if (e[u] !== s.props[u] && e.ownerState?.[u] !== s.props[u])
          continue e;
    typeof s.style == "function" ? (o ?? (o = {
      ...e,
      ...e.ownerState,
      ownerState: e.ownerState
    }), n.push(r ? Da(La(s.style(o)), r) : s.style(o))) : n.push(r ? Da(La(s.style), r) : s.style);
  }
  return n;
}
function FL(e = {}) {
  const {
    themeId: t,
    defaultTheme: n = IL,
    rootShouldForwardProp: r = ky,
    slotShouldForwardProp: o = ky
  } = e;
  function a(u) {
    LL(u, t, n);
  }
  return (u, c = {}) => {
    AL(u, (N) => N.filter((P) => P !== yl));
    const {
      name: f,
      slot: h,
      skipVariantsResolver: p,
      skipSx: g,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: y = zL(VL(h)),
      ...w
    } = c, v = f && f.startsWith("Mui") || h ? "components" : "custom", S = p !== void 0 ? p : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      h && h !== "Root" && h !== "root" || !1
    ), E = g || !1;
    let T = ky;
    h === "Root" || h === "root" ? T = r : h ? T = o : HL(u) && (T = void 0);
    const k = TL(u, {
      shouldForwardProp: T,
      label: $L(),
      ...w
    }), A = (N) => {
      if (N.__emotion_real === N)
        return N;
      if (typeof N == "function")
        return function(z) {
          return Rh(z, N, z.theme.modularCssLayers ? v : void 0);
        };
      if (Xo(N)) {
        const P = EM(N);
        return function(B) {
          return P.variants ? Rh(B, P, B.theme.modularCssLayers ? v : void 0) : B.theme.modularCssLayers ? Da(P.style, v) : P.style;
        };
      }
      return N;
    }, M = (...N) => {
      const P = [], z = N.map(A), B = [];
      if (P.push(a), f && y && B.push(function(W) {
        const V = W.theme.components?.[f]?.styleOverrides;
        if (!V)
          return null;
        const I = {};
        for (const H in V)
          I[H] = Rh(W, V[H], W.theme.modularCssLayers ? "theme" : void 0);
        return y(W, I);
      }), f && !S && B.push(function(W) {
        const V = W.theme?.components?.[f]?.variants;
        return V ? CM(W, V, [], W.theme.modularCssLayers ? "theme" : void 0) : null;
      }), E || B.push(yl), Array.isArray(z[0])) {
        const U = z.shift(), W = new Array(P.length).fill(""), j = new Array(B.length).fill("");
        let V;
        V = [...W, ...U, ...j], V.raw = [...W, ...U.raw, ...j], P.unshift(V);
      }
      const R = [...P, ...z, ...B], F = k(...R);
      return u.muiName && (F.muiName = u.muiName), F;
    };
    return k.withConfig && (M.withConfig = k.withConfig), M;
  };
}
function $L(e, t) {
  return void 0;
}
function BL(e) {
  for (const t in e)
    return !1;
  return !0;
}
function HL(e) {
  return typeof e == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  e.charCodeAt(0) > 96;
}
function VL(e) {
  return e && e.charAt(0).toLowerCase() + e.slice(1);
}
function $v(e, t, n = !1) {
  const r = {
    ...t
  };
  for (const o in e)
    if (Object.prototype.hasOwnProperty.call(e, o)) {
      const a = o;
      if (a === "components" || a === "slots")
        r[a] = {
          ...e[a],
          ...r[a]
        };
      else if (a === "componentsProps" || a === "slotProps") {
        const s = e[a], u = t[a];
        if (!u)
          r[a] = s || {};
        else if (!s)
          r[a] = u;
        else {
          r[a] = {
            ...u
          };
          for (const c in s)
            if (Object.prototype.hasOwnProperty.call(s, c)) {
              const f = c;
              r[a][f] = $v(s[f], u[f], n);
            }
        }
      } else a === "className" && n && t.className ? r.className = zt(e?.className, t?.className) : a === "style" && n && t.style ? r.style = {
        ...e?.style,
        ...t?.style
      } : r[a] === void 0 && (r[a] = e[a]);
    }
  return r;
}
const UL = typeof window < "u" ? _.useLayoutEffect : _.useEffect;
function qL(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
  return Math.max(t, Math.min(e, n));
}
function w1(e, t = 0, n = 1) {
  return qL(e, t, n);
}
function GL(e) {
  e = e.slice(1);
  const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, "g");
  let n = e.match(t);
  return n && n[0].length === 1 && (n = n.map((r) => r + r)), n ? `rgb${n.length === 4 ? "a" : ""}(${n.map((r, o) => o < 3 ? parseInt(r, 16) : Math.round(parseInt(r, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
}
function ea(e) {
  if (e.type)
    return e;
  if (e.charAt(0) === "#")
    return ea(GL(e));
  const t = e.indexOf("("), n = e.substring(0, t);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(n))
    throw new Error(Va(9, e));
  let r = e.substring(t + 1, e.length - 1), o;
  if (n === "color") {
    if (r = r.split(" "), o = r.shift(), r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)), !["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(o))
      throw new Error(Va(10, o));
  } else
    r = r.split(",");
  return r = r.map((a) => parseFloat(a)), {
    type: n,
    values: r,
    colorSpace: o
  };
}
const YL = (e) => {
  const t = ea(e);
  return t.values.slice(0, 3).map((n, r) => t.type.includes("hsl") && r !== 0 ? `${n}%` : n).join(" ");
}, uc = (e, t) => {
  try {
    return YL(e);
  } catch {
    return e;
  }
};
function Qp(e) {
  const {
    type: t,
    colorSpace: n
  } = e;
  let {
    values: r
  } = e;
  return t.includes("rgb") ? r = r.map((o, a) => a < 3 ? parseInt(o, 10) : o) : t.includes("hsl") && (r[1] = `${r[1]}%`, r[2] = `${r[2]}%`), t.includes("color") ? r = `${n} ${r.join(" ")}` : r = `${r.join(", ")}`, `${t}(${r})`;
}
function kM(e) {
  e = ea(e);
  const {
    values: t
  } = e, n = t[0], r = t[1] / 100, o = t[2] / 100, a = r * Math.min(o, 1 - o), s = (f, h = (f + n / 30) % 12) => o - a * Math.max(Math.min(h - 3, 9 - h, 1), -1);
  let u = "rgb";
  const c = [Math.round(s(0) * 255), Math.round(s(8) * 255), Math.round(s(4) * 255)];
  return e.type === "hsla" && (u += "a", c.push(t[3])), Qp({
    type: u,
    values: c
  });
}
function Bv(e) {
  e = ea(e);
  let t = e.type === "hsl" || e.type === "hsla" ? ea(kM(e)).values : e.values;
  return t = t.map((n) => (e.type !== "color" && (n /= 255), n <= 0.03928 ? n / 12.92 : ((n + 0.055) / 1.055) ** 2.4)), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3));
}
function WL(e, t) {
  const n = Bv(e), r = Bv(t);
  return (Math.max(n, r) + 0.05) / (Math.min(n, r) + 0.05);
}
function Rc(e, t) {
  return e = ea(e), t = w1(t), (e.type === "rgb" || e.type === "hsl") && (e.type += "a"), e.type === "color" ? e.values[3] = `/${t}` : e.values[3] = t, Qp(e);
}
function Yd(e, t, n) {
  try {
    return Rc(e, t);
  } catch {
    return e;
  }
}
function Jp(e, t) {
  if (e = ea(e), t = w1(t), e.type.includes("hsl"))
    e.values[2] *= 1 - t;
  else if (e.type.includes("rgb") || e.type.includes("color"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] *= 1 - t;
  return Qp(e);
}
function gt(e, t, n) {
  try {
    return Jp(e, t);
  } catch {
    return e;
  }
}
function em(e, t) {
  if (e = ea(e), t = w1(t), e.type.includes("hsl"))
    e.values[2] += (100 - e.values[2]) * t;
  else if (e.type.includes("rgb"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (255 - e.values[n]) * t;
  else if (e.type.includes("color"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (1 - e.values[n]) * t;
  return Qp(e);
}
function yt(e, t, n) {
  try {
    return em(e, t);
  } catch {
    return e;
  }
}
function XL(e, t = 0.15) {
  return Bv(e) > 0.5 ? Jp(e, t) : em(e, t);
}
function Wd(e, t, n) {
  try {
    return XL(e, t);
  } catch {
    return e;
  }
}
const KL = /* @__PURE__ */ _.createContext(void 0);
function ZL(e) {
  const {
    theme: t,
    name: n,
    props: r
  } = e;
  if (!t || !t.components || !t.components[n])
    return r;
  const o = t.components[n];
  return o.defaultProps ? $v(o.defaultProps, r, t.components.mergeClassNameAndStyle) : !o.styleOverrides && !o.variants ? $v(o, r, t.components.mergeClassNameAndStyle) : r;
}
function QL({
  props: e,
  name: t
}) {
  const n = _.useContext(KL);
  return ZL({
    props: e,
    name: t,
    theme: {
      components: n
    }
  });
}
const jC = {
  theme: void 0
};
function JL(e) {
  let t, n;
  return function(o) {
    let a = t;
    return (a === void 0 || o.theme !== n) && (jC.theme = o.theme, a = EM(e(jC)), t = a, n = o.theme), a;
  };
}
function eF(e = "") {
  function t(...r) {
    if (!r.length)
      return "";
    const o = r[0];
    return typeof o == "string" && !o.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/) ? `, var(--${e ? `${e}-` : ""}${o}${t(...r.slice(1))})` : `, ${o}`;
  }
  return (r, ...o) => `var(--${e ? `${e}-` : ""}${r}${t(...o)})`;
}
const IC = (e, t, n, r = []) => {
  let o = e;
  t.forEach((a, s) => {
    s === t.length - 1 ? Array.isArray(o) ? o[Number(a)] = n : o && typeof o == "object" && (o[a] = n) : o && typeof o == "object" && (o[a] || (o[a] = r.includes(a) ? [] : {}), o = o[a]);
  });
}, tF = (e, t, n) => {
  function r(o, a = [], s = []) {
    Object.entries(o).forEach(([u, c]) => {
      (!n || n && !n([...a, u])) && c != null && (typeof c == "object" && Object.keys(c).length > 0 ? r(c, [...a, u], Array.isArray(c) ? [...s, u] : s) : t([...a, u], c, s));
    });
  }
  r(e);
}, nF = (e, t) => typeof t == "number" ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((r) => e.includes(r)) || e[e.length - 1].toLowerCase().includes("opacity") ? t : `${t}px` : t;
function Ty(e, t) {
  const {
    prefix: n,
    shouldSkipGeneratingVar: r
  } = t || {}, o = {}, a = {}, s = {};
  return tF(
    e,
    (u, c, f) => {
      if ((typeof c == "string" || typeof c == "number") && (!r || !r(u, c))) {
        const h = `--${n ? `${n}-` : ""}${u.join("-")}`, p = nF(u, c);
        Object.assign(o, {
          [h]: p
        }), IC(a, u, `var(${h})`, f), IC(s, u, `var(${h}, ${p})`, f);
      }
    },
    (u) => u[0] === "vars"
    // skip 'vars/*' paths
  ), {
    css: o,
    vars: a,
    varsWithDefaults: s
  };
}
function rF(e, t = {}) {
  const {
    getSelector: n = S,
    disableCssColorScheme: r,
    colorSchemeSelector: o
  } = t, {
    colorSchemes: a = {},
    components: s,
    defaultColorScheme: u = "light",
    ...c
  } = e, {
    vars: f,
    css: h,
    varsWithDefaults: p
  } = Ty(c, t);
  let g = p;
  const y = {}, {
    [u]: w,
    ...v
  } = a;
  if (Object.entries(v || {}).forEach(([k, A]) => {
    const {
      vars: M,
      css: N,
      varsWithDefaults: P
    } = Ty(A, t);
    g = or(g, P), y[k] = {
      css: N,
      vars: M
    };
  }), w) {
    const {
      css: k,
      vars: A,
      varsWithDefaults: M
    } = Ty(w, t);
    g = or(g, M), y[u] = {
      css: k,
      vars: A
    };
  }
  function S(k, A) {
    let M = o;
    if (o === "class" && (M = ".%s"), o === "data" && (M = "[data-%s]"), o?.startsWith("data-") && !o.includes("%s") && (M = `[${o}="%s"]`), k) {
      if (M === "media")
        return e.defaultColorScheme === k ? ":root" : {
          [`@media (prefers-color-scheme: ${a[k]?.palette?.mode || k})`]: {
            ":root": A
          }
        };
      if (M)
        return e.defaultColorScheme === k ? `:root, ${M.replace("%s", String(k))}` : M.replace("%s", String(k));
    }
    return ":root";
  }
  return {
    vars: g,
    generateThemeVars: () => {
      let k = {
        ...f
      };
      return Object.entries(y).forEach(([, {
        vars: A
      }]) => {
        k = or(k, A);
      }), k;
    },
    generateStyleSheets: () => {
      const k = [], A = e.defaultColorScheme || "light";
      function M(z, B) {
        Object.keys(B).length && k.push(typeof z == "string" ? {
          [z]: {
            ...B
          }
        } : z);
      }
      M(n(void 0, {
        ...h
      }), h);
      const {
        [A]: N,
        ...P
      } = y;
      if (N) {
        const {
          css: z
        } = N, B = a[A]?.palette?.mode, R = !r && B ? {
          colorScheme: B,
          ...z
        } : {
          ...z
        };
        M(n(A, {
          ...R
        }), R);
      }
      return Object.entries(P).forEach(([z, {
        css: B
      }]) => {
        const R = a[z]?.palette?.mode, F = !r && R ? {
          colorScheme: R,
          ...B
        } : {
          ...B
        };
        M(n(z, {
          ...F
        }), F);
      }), k;
    }
  };
}
function oF(e) {
  return function(n) {
    return e === "media" ? `@media (prefers-color-scheme: ${n})` : e ? e.startsWith("data-") && !e.includes("%s") ? `[${e}="${n}"] &` : e === "class" ? `.${n} &` : e === "data" ? `[data-${n}] &` : `${e.replace("%s", n)} &` : "&";
  };
}
const Mc = {
  black: "#000",
  white: "#fff"
}, iF = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
}, Bs = {
  50: "#f3e5f5",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  700: "#7b1fa2"
}, Hs = {
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  700: "#d32f2f",
  800: "#c62828"
}, ec = {
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  700: "#f57c00",
  900: "#e65100"
}, Vs = {
  50: "#e3f2fd",
  200: "#90caf9",
  400: "#42a5f5",
  700: "#1976d2",
  800: "#1565c0"
}, Us = {
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  700: "#0288d1",
  900: "#01579b"
}, qs = {
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20"
};
function TM() {
  return {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: Mc.white,
      default: Mc.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
}
const aF = TM();
function AM() {
  return {
    text: {
      primary: Mc.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: Mc.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
}
const zC = AM();
function LC(e, t, n, r) {
  const o = r.light || r, a = r.dark || r * 1.5;
  e[t] || (e.hasOwnProperty(n) ? e[t] = e[n] : t === "light" ? e.light = em(e.main, o) : t === "dark" && (e.dark = Jp(e.main, a)));
}
function sF(e = "light") {
  return e === "dark" ? {
    main: Vs[200],
    light: Vs[50],
    dark: Vs[400]
  } : {
    main: Vs[700],
    light: Vs[400],
    dark: Vs[800]
  };
}
function lF(e = "light") {
  return e === "dark" ? {
    main: Bs[200],
    light: Bs[50],
    dark: Bs[400]
  } : {
    main: Bs[500],
    light: Bs[300],
    dark: Bs[700]
  };
}
function uF(e = "light") {
  return e === "dark" ? {
    main: Hs[500],
    light: Hs[300],
    dark: Hs[700]
  } : {
    main: Hs[700],
    light: Hs[400],
    dark: Hs[800]
  };
}
function cF(e = "light") {
  return e === "dark" ? {
    main: Us[400],
    light: Us[300],
    dark: Us[700]
  } : {
    main: Us[700],
    light: Us[500],
    dark: Us[900]
  };
}
function fF(e = "light") {
  return e === "dark" ? {
    main: qs[400],
    light: qs[300],
    dark: qs[700]
  } : {
    main: qs[800],
    light: qs[500],
    dark: qs[900]
  };
}
function dF(e = "light") {
  return e === "dark" ? {
    main: ec[400],
    light: ec[300],
    dark: ec[700]
  } : {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: ec[500],
    dark: ec[900]
  };
}
function _1(e) {
  const {
    mode: t = "light",
    contrastThreshold: n = 3,
    tonalOffset: r = 0.2,
    ...o
  } = e, a = e.primary || sF(t), s = e.secondary || lF(t), u = e.error || uF(t), c = e.info || cF(t), f = e.success || fF(t), h = e.warning || dF(t);
  function p(v) {
    return WL(v, zC.text.primary) >= n ? zC.text.primary : aF.text.primary;
  }
  const g = ({
    color: v,
    name: S,
    mainShade: E = 500,
    lightShade: T = 300,
    darkShade: k = 700
  }) => {
    if (v = {
      ...v
    }, !v.main && v[E] && (v.main = v[E]), !v.hasOwnProperty("main"))
      throw new Error(Va(11, S ? ` (${S})` : "", E));
    if (typeof v.main != "string")
      throw new Error(Va(12, S ? ` (${S})` : "", JSON.stringify(v.main)));
    return LC(v, "light", T, r), LC(v, "dark", k, r), v.contrastText || (v.contrastText = p(v.main)), v;
  };
  let y;
  return t === "light" ? y = TM() : t === "dark" && (y = AM()), or({
    // A collection of common colors.
    common: {
      ...Mc
    },
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode: t,
    // The colors used to represent primary interface elements for a user.
    primary: g({
      color: a,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: g({
      color: s,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: g({
      color: u,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: g({
      color: h,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: g({
      color: c,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: g({
      color: f,
      name: "success"
    }),
    // The grey colors.
    grey: iF,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold: n,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText: p,
    // Generate a rich color object.
    augmentColor: g,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset: r,
    // The light and dark mode object.
    ...y
  }, o);
}
function hF(e) {
  const t = {};
  return Object.entries(e).forEach((r) => {
    const [o, a] = r;
    typeof a == "object" && (t[o] = `${a.fontStyle ? `${a.fontStyle} ` : ""}${a.fontVariant ? `${a.fontVariant} ` : ""}${a.fontWeight ? `${a.fontWeight} ` : ""}${a.fontStretch ? `${a.fontStretch} ` : ""}${a.fontSize || ""}${a.lineHeight ? `/${a.lineHeight} ` : ""}${a.fontFamily || ""}`);
  }), t;
}
function pF(e, t) {
  return {
    toolbar: {
      minHeight: 56,
      [e.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [e.up("sm")]: {
        minHeight: 64
      }
    },
    ...t
  };
}
function mF(e) {
  return Math.round(e * 1e5) / 1e5;
}
const FC = {
  textTransform: "uppercase"
}, $C = '"Roboto", "Helvetica", "Arial", sans-serif';
function gF(e, t) {
  const {
    fontFamily: n = $C,
    // The default font size of the Material Specification.
    fontSize: r = 14,
    // px
    fontWeightLight: o = 300,
    fontWeightRegular: a = 400,
    fontWeightMedium: s = 500,
    fontWeightBold: u = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize: c = 16,
    // Apply the CSS properties to all the variants.
    allVariants: f,
    pxToRem: h,
    ...p
  } = typeof t == "function" ? t(e) : t, g = r / 14, y = h || ((S) => `${S / c * g}rem`), w = (S, E, T, k, A) => ({
    fontFamily: n,
    fontWeight: S,
    fontSize: y(E),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight: T,
    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
    // across font-families can cause issues with the kerning.
    ...n === $C ? {
      letterSpacing: `${mF(k / E)}em`
    } : {},
    ...A,
    ...f
  }), v = {
    h1: w(o, 96, 1.167, -1.5),
    h2: w(o, 60, 1.2, -0.5),
    h3: w(a, 48, 1.167, 0),
    h4: w(a, 34, 1.235, 0.25),
    h5: w(a, 24, 1.334, 0),
    h6: w(s, 20, 1.6, 0.15),
    subtitle1: w(a, 16, 1.75, 0.15),
    subtitle2: w(s, 14, 1.57, 0.1),
    body1: w(a, 16, 1.5, 0.15),
    body2: w(a, 14, 1.43, 0.15),
    button: w(s, 14, 1.75, 0.4, FC),
    caption: w(a, 12, 1.66, 0.4),
    overline: w(a, 12, 2.66, 1, FC),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return or({
    htmlFontSize: c,
    pxToRem: y,
    fontFamily: n,
    fontSize: r,
    fontWeightLight: o,
    fontWeightRegular: a,
    fontWeightMedium: s,
    fontWeightBold: u,
    ...v
  }, p, {
    clone: !1
    // No need to clone deep
  });
}
const yF = 0.2, vF = 0.14, bF = 0.12;
function Ct(...e) {
  return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${yF})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${vF})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${bF})`].join(",");
}
const xF = ["none", Ct(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), Ct(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), Ct(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), Ct(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), Ct(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), Ct(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), Ct(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), Ct(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), Ct(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), Ct(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), Ct(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), Ct(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), Ct(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), Ct(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), Ct(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), Ct(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), Ct(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), Ct(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), Ct(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), Ct(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), Ct(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), Ct(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), Ct(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), Ct(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], wF = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}, _F = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function BC(e) {
  return `${Math.round(e)}ms`;
}
function SF(e) {
  if (!e)
    return 0;
  const t = e / 36;
  return Math.min(Math.round((4 + 15 * t ** 0.25 + t / 5) * 10), 3e3);
}
function EF(e) {
  const t = {
    ...wF,
    ...e.easing
  }, n = {
    ..._F,
    ...e.duration
  };
  return {
    getAutoHeightDuration: SF,
    create: (o = ["all"], a = {}) => {
      const {
        duration: s = n.standard,
        easing: u = t.easeInOut,
        delay: c = 0,
        ...f
      } = a;
      return (Array.isArray(o) ? o : [o]).map((h) => `${h} ${typeof s == "string" ? s : BC(s)} ${u} ${typeof c == "string" ? c : BC(c)}`).join(",");
    },
    ...e,
    easing: t,
    duration: n
  };
}
const CF = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
function kF(e) {
  return Xo(e) || typeof e > "u" || typeof e == "string" || typeof e == "boolean" || typeof e == "number" || Array.isArray(e);
}
function RM(e = {}) {
  const t = {
    ...e
  };
  function n(r) {
    const o = Object.entries(r);
    for (let a = 0; a < o.length; a++) {
      const [s, u] = o[a];
      !kF(u) || s.startsWith("unstable_") ? delete r[s] : Xo(u) && (r[s] = {
        ...u
      }, n(r[s]));
    }
  }
  return n(t), `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(t, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}
function Hv(e = {}, ...t) {
  const {
    breakpoints: n,
    mixins: r = {},
    spacing: o,
    palette: a = {},
    transitions: s = {},
    typography: u = {},
    shape: c,
    ...f
  } = e;
  if (e.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
  // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
  e.generateThemeVars === void 0)
    throw new Error(Va(20));
  const h = _1(a), p = SM(e);
  let g = or(p, {
    mixins: pF(p.breakpoints, r),
    palette: h,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: xF.slice(),
    typography: gF(h, u),
    transitions: EF(s),
    zIndex: {
      ...CF
    }
  });
  return g = or(g, f), g = t.reduce((y, w) => or(y, w), g), g.unstable_sxConfig = {
    ...Gp,
    ...f?.unstable_sxConfig
  }, g.unstable_sx = function(w) {
    return yl({
      sx: w,
      theme: this
    });
  }, g.toRuntimeSource = RM, g;
}
function TF(e) {
  let t;
  return e < 1 ? t = 5.11916 * e ** 2 : t = 4.5 * Math.log(e + 1) + 2, Math.round(t * 10) / 1e3;
}
const AF = [...Array(25)].map((e, t) => {
  if (t === 0)
    return "none";
  const n = TF(t);
  return `linear-gradient(rgba(255 255 255 / ${n}), rgba(255 255 255 / ${n}))`;
});
function MM(e) {
  return {
    inputPlaceholder: e === "dark" ? 0.5 : 0.42,
    inputUnderline: e === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: e === "dark" ? 0.2 : 0.12,
    switchTrack: e === "dark" ? 0.3 : 0.38
  };
}
function OM(e) {
  return e === "dark" ? AF : [];
}
function RF(e) {
  const {
    palette: t = {
      mode: "light"
    },
    // need to cast to avoid module augmentation test
    opacity: n,
    overlays: r,
    ...o
  } = e, a = _1(t);
  return {
    palette: a,
    opacity: {
      ...MM(a.mode),
      ...n
    },
    overlays: r || OM(a.mode),
    ...o
  };
}
function MF(e) {
  return !!e[0].match(/(cssVarPrefix|colorSchemeSelector|modularCssLayers|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!e[0].match(/sxConfig$/) || // ends with sxConfig
  e[0] === "palette" && !!e[1]?.match(/(mode|contrastThreshold|tonalOffset)/);
}
const OF = (e) => [...[...Array(25)].map((t, n) => `--${e ? `${e}-` : ""}overlays-${n}`), `--${e ? `${e}-` : ""}palette-AppBar-darkBg`, `--${e ? `${e}-` : ""}palette-AppBar-darkColor`], NF = (e) => (t, n) => {
  const r = e.rootSelector || ":root", o = e.colorSchemeSelector;
  let a = o;
  if (o === "class" && (a = ".%s"), o === "data" && (a = "[data-%s]"), o?.startsWith("data-") && !o.includes("%s") && (a = `[${o}="%s"]`), e.defaultColorScheme === t) {
    if (t === "dark") {
      const s = {};
      return OF(e.cssVarPrefix).forEach((u) => {
        s[u] = n[u], delete n[u];
      }), a === "media" ? {
        [r]: n,
        "@media (prefers-color-scheme: dark)": {
          [r]: s
        }
      } : a ? {
        [a.replace("%s", t)]: s,
        [`${r}, ${a.replace("%s", t)}`]: n
      } : {
        [r]: {
          ...n,
          ...s
        }
      };
    }
    if (a && a !== "media")
      return `${r}, ${a.replace("%s", String(t))}`;
  } else if (t) {
    if (a === "media")
      return {
        [`@media (prefers-color-scheme: ${String(t)})`]: {
          [r]: n
        }
      };
    if (a)
      return a.replace("%s", String(t));
  }
  return r;
};
function DF(e, t) {
  t.forEach((n) => {
    e[n] || (e[n] = {});
  });
}
function se(e, t, n) {
  !e[t] && n && (e[t] = n);
}
function cc(e) {
  return typeof e != "string" || !e.startsWith("hsl") ? e : kM(e);
}
function qo(e, t) {
  `${t}Channel` in e || (e[`${t}Channel`] = uc(cc(e[t])));
}
function PF(e) {
  return typeof e == "number" ? `${e}px` : typeof e == "string" || typeof e == "function" || Array.isArray(e) ? e : "8px";
}
const Qr = (e) => {
  try {
    return e();
  } catch {
  }
}, jF = (e = "mui") => eF(e);
function Ay(e, t, n, r) {
  if (!t)
    return;
  t = t === !0 ? {} : t;
  const o = r === "dark" ? "dark" : "light";
  if (!n) {
    e[r] = RF({
      ...t,
      palette: {
        mode: o,
        ...t?.palette
      }
    });
    return;
  }
  const {
    palette: a,
    ...s
  } = Hv({
    ...n,
    palette: {
      mode: o,
      ...t?.palette
    }
  });
  return e[r] = {
    ...t,
    palette: a,
    opacity: {
      ...MM(o),
      ...t?.opacity
    },
    overlays: t?.overlays || OM(o)
  }, s;
}
function IF(e = {}, ...t) {
  const {
    colorSchemes: n = {
      light: !0
    },
    defaultColorScheme: r,
    disableCssColorScheme: o = !1,
    cssVarPrefix: a = "mui",
    shouldSkipGeneratingVar: s = MF,
    colorSchemeSelector: u = n.light && n.dark ? "media" : void 0,
    rootSelector: c = ":root",
    ...f
  } = e, h = Object.keys(n)[0], p = r || (n.light && h !== "light" ? "light" : h), g = jF(a), {
    [p]: y,
    light: w,
    dark: v,
    ...S
  } = n, E = {
    ...S
  };
  let T = y;
  if ((p === "dark" && !("dark" in n) || p === "light" && !("light" in n)) && (T = !0), !T)
    throw new Error(Va(21, p));
  const k = Ay(E, T, f, p);
  w && !E.light && Ay(E, w, void 0, "light"), v && !E.dark && Ay(E, v, void 0, "dark");
  let A = {
    defaultColorScheme: p,
    ...k,
    cssVarPrefix: a,
    colorSchemeSelector: u,
    rootSelector: c,
    getCssVar: g,
    colorSchemes: E,
    font: {
      ...hF(k.typography),
      ...k.font
    },
    spacing: PF(f.spacing)
  };
  Object.keys(A.colorSchemes).forEach((B) => {
    const R = A.colorSchemes[B].palette, F = (U) => {
      const W = U.split("-"), j = W[1], V = W[2];
      return g(U, R[j][V]);
    };
    if (R.mode === "light" && (se(R.common, "background", "#fff"), se(R.common, "onBackground", "#000")), R.mode === "dark" && (se(R.common, "background", "#000"), se(R.common, "onBackground", "#fff")), DF(R, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]), R.mode === "light") {
      se(R.Alert, "errorColor", gt(R.error.light, 0.6)), se(R.Alert, "infoColor", gt(R.info.light, 0.6)), se(R.Alert, "successColor", gt(R.success.light, 0.6)), se(R.Alert, "warningColor", gt(R.warning.light, 0.6)), se(R.Alert, "errorFilledBg", F("palette-error-main")), se(R.Alert, "infoFilledBg", F("palette-info-main")), se(R.Alert, "successFilledBg", F("palette-success-main")), se(R.Alert, "warningFilledBg", F("palette-warning-main")), se(R.Alert, "errorFilledColor", Qr(() => R.getContrastText(R.error.main))), se(R.Alert, "infoFilledColor", Qr(() => R.getContrastText(R.info.main))), se(R.Alert, "successFilledColor", Qr(() => R.getContrastText(R.success.main))), se(R.Alert, "warningFilledColor", Qr(() => R.getContrastText(R.warning.main))), se(R.Alert, "errorStandardBg", yt(R.error.light, 0.9)), se(R.Alert, "infoStandardBg", yt(R.info.light, 0.9)), se(R.Alert, "successStandardBg", yt(R.success.light, 0.9)), se(R.Alert, "warningStandardBg", yt(R.warning.light, 0.9)), se(R.Alert, "errorIconColor", F("palette-error-main")), se(R.Alert, "infoIconColor", F("palette-info-main")), se(R.Alert, "successIconColor", F("palette-success-main")), se(R.Alert, "warningIconColor", F("palette-warning-main")), se(R.AppBar, "defaultBg", F("palette-grey-100")), se(R.Avatar, "defaultBg", F("palette-grey-400")), se(R.Button, "inheritContainedBg", F("palette-grey-300")), se(R.Button, "inheritContainedHoverBg", F("palette-grey-A100")), se(R.Chip, "defaultBorder", F("palette-grey-400")), se(R.Chip, "defaultAvatarColor", F("palette-grey-700")), se(R.Chip, "defaultIconColor", F("palette-grey-700")), se(R.FilledInput, "bg", "rgba(0, 0, 0, 0.06)"), se(R.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)"), se(R.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)"), se(R.LinearProgress, "primaryBg", yt(R.primary.main, 0.62)), se(R.LinearProgress, "secondaryBg", yt(R.secondary.main, 0.62)), se(R.LinearProgress, "errorBg", yt(R.error.main, 0.62)), se(R.LinearProgress, "infoBg", yt(R.info.main, 0.62)), se(R.LinearProgress, "successBg", yt(R.success.main, 0.62)), se(R.LinearProgress, "warningBg", yt(R.warning.main, 0.62)), se(R.Skeleton, "bg", `rgba(${F("palette-text-primaryChannel")} / 0.11)`), se(R.Slider, "primaryTrack", yt(R.primary.main, 0.62)), se(R.Slider, "secondaryTrack", yt(R.secondary.main, 0.62)), se(R.Slider, "errorTrack", yt(R.error.main, 0.62)), se(R.Slider, "infoTrack", yt(R.info.main, 0.62)), se(R.Slider, "successTrack", yt(R.success.main, 0.62)), se(R.Slider, "warningTrack", yt(R.warning.main, 0.62));
      const U = Wd(R.background.default, 0.8);
      se(R.SnackbarContent, "bg", U), se(R.SnackbarContent, "color", Qr(() => R.getContrastText(U))), se(R.SpeedDialAction, "fabHoverBg", Wd(R.background.paper, 0.15)), se(R.StepConnector, "border", F("palette-grey-400")), se(R.StepContent, "border", F("palette-grey-400")), se(R.Switch, "defaultColor", F("palette-common-white")), se(R.Switch, "defaultDisabledColor", F("palette-grey-100")), se(R.Switch, "primaryDisabledColor", yt(R.primary.main, 0.62)), se(R.Switch, "secondaryDisabledColor", yt(R.secondary.main, 0.62)), se(R.Switch, "errorDisabledColor", yt(R.error.main, 0.62)), se(R.Switch, "infoDisabledColor", yt(R.info.main, 0.62)), se(R.Switch, "successDisabledColor", yt(R.success.main, 0.62)), se(R.Switch, "warningDisabledColor", yt(R.warning.main, 0.62)), se(R.TableCell, "border", yt(Yd(R.divider, 1), 0.88)), se(R.Tooltip, "bg", Yd(R.grey[700], 0.92));
    }
    if (R.mode === "dark") {
      se(R.Alert, "errorColor", yt(R.error.light, 0.6)), se(R.Alert, "infoColor", yt(R.info.light, 0.6)), se(R.Alert, "successColor", yt(R.success.light, 0.6)), se(R.Alert, "warningColor", yt(R.warning.light, 0.6)), se(R.Alert, "errorFilledBg", F("palette-error-dark")), se(R.Alert, "infoFilledBg", F("palette-info-dark")), se(R.Alert, "successFilledBg", F("palette-success-dark")), se(R.Alert, "warningFilledBg", F("palette-warning-dark")), se(R.Alert, "errorFilledColor", Qr(() => R.getContrastText(R.error.dark))), se(R.Alert, "infoFilledColor", Qr(() => R.getContrastText(R.info.dark))), se(R.Alert, "successFilledColor", Qr(() => R.getContrastText(R.success.dark))), se(R.Alert, "warningFilledColor", Qr(() => R.getContrastText(R.warning.dark))), se(R.Alert, "errorStandardBg", gt(R.error.light, 0.9)), se(R.Alert, "infoStandardBg", gt(R.info.light, 0.9)), se(R.Alert, "successStandardBg", gt(R.success.light, 0.9)), se(R.Alert, "warningStandardBg", gt(R.warning.light, 0.9)), se(R.Alert, "errorIconColor", F("palette-error-main")), se(R.Alert, "infoIconColor", F("palette-info-main")), se(R.Alert, "successIconColor", F("palette-success-main")), se(R.Alert, "warningIconColor", F("palette-warning-main")), se(R.AppBar, "defaultBg", F("palette-grey-900")), se(R.AppBar, "darkBg", F("palette-background-paper")), se(R.AppBar, "darkColor", F("palette-text-primary")), se(R.Avatar, "defaultBg", F("palette-grey-600")), se(R.Button, "inheritContainedBg", F("palette-grey-800")), se(R.Button, "inheritContainedHoverBg", F("palette-grey-700")), se(R.Chip, "defaultBorder", F("palette-grey-700")), se(R.Chip, "defaultAvatarColor", F("palette-grey-300")), se(R.Chip, "defaultIconColor", F("palette-grey-300")), se(R.FilledInput, "bg", "rgba(255, 255, 255, 0.09)"), se(R.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)"), se(R.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)"), se(R.LinearProgress, "primaryBg", gt(R.primary.main, 0.5)), se(R.LinearProgress, "secondaryBg", gt(R.secondary.main, 0.5)), se(R.LinearProgress, "errorBg", gt(R.error.main, 0.5)), se(R.LinearProgress, "infoBg", gt(R.info.main, 0.5)), se(R.LinearProgress, "successBg", gt(R.success.main, 0.5)), se(R.LinearProgress, "warningBg", gt(R.warning.main, 0.5)), se(R.Skeleton, "bg", `rgba(${F("palette-text-primaryChannel")} / 0.13)`), se(R.Slider, "primaryTrack", gt(R.primary.main, 0.5)), se(R.Slider, "secondaryTrack", gt(R.secondary.main, 0.5)), se(R.Slider, "errorTrack", gt(R.error.main, 0.5)), se(R.Slider, "infoTrack", gt(R.info.main, 0.5)), se(R.Slider, "successTrack", gt(R.success.main, 0.5)), se(R.Slider, "warningTrack", gt(R.warning.main, 0.5));
      const U = Wd(R.background.default, 0.98);
      se(R.SnackbarContent, "bg", U), se(R.SnackbarContent, "color", Qr(() => R.getContrastText(U))), se(R.SpeedDialAction, "fabHoverBg", Wd(R.background.paper, 0.15)), se(R.StepConnector, "border", F("palette-grey-600")), se(R.StepContent, "border", F("palette-grey-600")), se(R.Switch, "defaultColor", F("palette-grey-300")), se(R.Switch, "defaultDisabledColor", F("palette-grey-600")), se(R.Switch, "primaryDisabledColor", gt(R.primary.main, 0.55)), se(R.Switch, "secondaryDisabledColor", gt(R.secondary.main, 0.55)), se(R.Switch, "errorDisabledColor", gt(R.error.main, 0.55)), se(R.Switch, "infoDisabledColor", gt(R.info.main, 0.55)), se(R.Switch, "successDisabledColor", gt(R.success.main, 0.55)), se(R.Switch, "warningDisabledColor", gt(R.warning.main, 0.55)), se(R.TableCell, "border", gt(Yd(R.divider, 1), 0.68)), se(R.Tooltip, "bg", Yd(R.grey[700], 0.92));
    }
    qo(R.background, "default"), qo(R.background, "paper"), qo(R.common, "background"), qo(R.common, "onBackground"), qo(R, "divider"), Object.keys(R).forEach((U) => {
      const W = R[U];
      U !== "tonalOffset" && W && typeof W == "object" && (W.main && se(R[U], "mainChannel", uc(cc(W.main))), W.light && se(R[U], "lightChannel", uc(cc(W.light))), W.dark && se(R[U], "darkChannel", uc(cc(W.dark))), W.contrastText && se(R[U], "contrastTextChannel", uc(cc(W.contrastText))), U === "text" && (qo(R[U], "primary"), qo(R[U], "secondary")), U === "action" && (W.active && qo(R[U], "active"), W.selected && qo(R[U], "selected")));
    });
  }), A = t.reduce((B, R) => or(B, R), A);
  const M = {
    prefix: a,
    disableCssColorScheme: o,
    shouldSkipGeneratingVar: s,
    getSelector: NF(A)
  }, {
    vars: N,
    generateThemeVars: P,
    generateStyleSheets: z
  } = rF(A, M);
  return A.vars = N, Object.entries(A.colorSchemes[A.defaultColorScheme]).forEach(([B, R]) => {
    A[B] = R;
  }), A.generateThemeVars = P, A.generateStyleSheets = z, A.generateSpacing = function() {
    return _M(f.spacing, h1(this));
  }, A.getColorSchemeSelector = oF(u), A.spacing = A.generateSpacing(), A.shouldSkipGeneratingVar = s, A.unstable_sxConfig = {
    ...Gp,
    ...f?.unstable_sxConfig
  }, A.unstable_sx = function(R) {
    return yl({
      sx: R,
      theme: this
    });
  }, A.toRuntimeSource = RM, A;
}
function HC(e, t, n) {
  e.colorSchemes && n && (e.colorSchemes[t] = {
    ...n !== !0 && n,
    palette: _1({
      ...n === !0 ? {} : n.palette,
      mode: t
    })
    // cast type to skip module augmentation test
  });
}
function zF(e = {}, ...t) {
  const {
    palette: n,
    cssVariables: r = !1,
    colorSchemes: o = n ? void 0 : {
      light: !0
    },
    defaultColorScheme: a = n?.mode,
    ...s
  } = e, u = a || "light", c = o?.[u], f = {
    ...o,
    ...n ? {
      [u]: {
        ...typeof c != "boolean" && c,
        palette: n
      }
    } : void 0
  };
  if (r === !1) {
    if (!("colorSchemes" in e))
      return Hv(e, ...t);
    let h = n;
    "palette" in e || f[u] && (f[u] !== !0 ? h = f[u].palette : u === "dark" && (h = {
      mode: "dark"
    }));
    const p = Hv({
      ...e,
      palette: h
    }, ...t);
    return p.defaultColorScheme = u, p.colorSchemes = f, p.palette.mode === "light" && (p.colorSchemes.light = {
      ...f.light !== !0 && f.light,
      palette: p.palette
    }, HC(p, "dark", f.dark)), p.palette.mode === "dark" && (p.colorSchemes.dark = {
      ...f.dark !== !0 && f.dark,
      palette: p.palette
    }, HC(p, "light", f.light)), p;
  }
  return !n && !("light" in f) && u === "light" && (f.light = !0), IF({
    ...s,
    colorSchemes: f,
    defaultColorScheme: u,
    ...typeof r != "boolean" && r
  }, ...t);
}
const LF = zF(), FF = "$$material";
function $F(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
const BF = (e) => $F(e) && e !== "classes", Tr = FL({
  themeId: FF,
  defaultTheme: LF,
  rootShouldForwardProp: BF
}), jl = JL;
function wo(e) {
  return QL(e);
}
function HF(e) {
  return bo("MuiTable", e);
}
xo("MuiTable", ["root", "stickyHeader"]);
const VF = (e) => {
  const {
    classes: t,
    stickyHeader: n
  } = e;
  return li({
    root: ["root", n && "stickyHeader"]
  }, HF, t);
}, UF = Tr("table", {
  name: "MuiTable",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.stickyHeader && t.stickyHeader];
  }
})(jl(({
  theme: e
}) => ({
  display: "table",
  width: "100%",
  borderCollapse: "collapse",
  borderSpacing: 0,
  "& caption": {
    ...e.typography.body2,
    padding: e.spacing(2),
    color: (e.vars || e).palette.text.secondary,
    textAlign: "left",
    captionSide: "bottom"
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.stickyHeader,
    style: {
      borderCollapse: "separate"
    }
  }]
}))), VC = "table", qF = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = wo({
    props: t,
    name: "MuiTable"
  }), {
    className: o,
    component: a = VC,
    padding: s = "normal",
    size: u = "medium",
    stickyHeader: c = !1,
    ...f
  } = r, h = {
    ...r,
    component: a,
    padding: s,
    size: u,
    stickyHeader: c
  }, p = VF(h), g = _.useMemo(() => ({
    padding: s,
    size: u,
    stickyHeader: c
  }), [s, u, c]);
  return /* @__PURE__ */ x.jsx(rM.Provider, {
    value: g,
    children: /* @__PURE__ */ x.jsx(UF, {
      as: a,
      role: a === VC ? null : "table",
      ref: n,
      className: zt(p.root, o),
      ownerState: h,
      ...f
    })
  });
}), tm = /* @__PURE__ */ _.createContext();
function GF(e) {
  return bo("MuiTableBody", e);
}
xo("MuiTableBody", ["root"]);
const YF = (e) => {
  const {
    classes: t
  } = e;
  return li({
    root: ["root"]
  }, GF, t);
}, WF = Tr("tbody", {
  name: "MuiTableBody",
  slot: "Root"
})({
  display: "table-row-group"
}), XF = {
  variant: "body"
}, UC = "tbody", KF = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = wo({
    props: t,
    name: "MuiTableBody"
  }), {
    className: o,
    component: a = UC,
    ...s
  } = r, u = {
    ...r,
    component: a
  }, c = YF(u);
  return /* @__PURE__ */ x.jsx(tm.Provider, {
    value: XF,
    children: /* @__PURE__ */ x.jsx(WF, {
      className: zt(c.root, o),
      as: a,
      ref: n,
      role: a === UC ? null : "rowgroup",
      ownerState: u,
      ...s
    })
  });
});
function ZF(e) {
  return bo("MuiTableCell", e);
}
const QF = xo("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]), JF = (e) => {
  const {
    classes: t,
    variant: n,
    align: r,
    padding: o,
    size: a,
    stickyHeader: s
  } = e, u = {
    root: ["root", n, s && "stickyHeader", r !== "inherit" && `align${kn(r)}`, o !== "normal" && `padding${kn(o)}`, `size${kn(a)}`]
  };
  return li(u, ZF, t);
}, e9 = Tr("td", {
  name: "MuiTableCell",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], t[`size${kn(n.size)}`], n.padding !== "normal" && t[`padding${kn(n.padding)}`], n.align !== "inherit" && t[`align${kn(n.align)}`], n.stickyHeader && t.stickyHeader];
  }
})(jl(({
  theme: e
}) => ({
  ...e.typography.body2,
  display: "table-cell",
  verticalAlign: "inherit",
  // Workaround for a rendering bug with spanned columns in Chrome 62.0.
  // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
  borderBottom: e.vars ? `1px solid ${e.vars.palette.TableCell.border}` : `1px solid
    ${e.palette.mode === "light" ? em(Rc(e.palette.divider, 1), 0.88) : Jp(Rc(e.palette.divider, 1), 0.68)}`,
  textAlign: "left",
  padding: 16,
  variants: [{
    props: {
      variant: "head"
    },
    style: {
      color: (e.vars || e).palette.text.primary,
      lineHeight: e.typography.pxToRem(24),
      fontWeight: e.typography.fontWeightMedium
    }
  }, {
    props: {
      variant: "body"
    },
    style: {
      color: (e.vars || e).palette.text.primary
    }
  }, {
    props: {
      variant: "footer"
    },
    style: {
      color: (e.vars || e).palette.text.secondary,
      lineHeight: e.typography.pxToRem(21),
      fontSize: e.typography.pxToRem(12)
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      padding: "6px 16px",
      [`&.${QF.paddingCheckbox}`]: {
        width: 24,
        // prevent the checkbox column from growing
        padding: "0 12px 0 16px",
        "& > *": {
          padding: 0
        }
      }
    }
  }, {
    props: {
      padding: "checkbox"
    },
    style: {
      width: 48,
      // prevent the checkbox column from growing
      padding: "0 0 0 4px"
    }
  }, {
    props: {
      padding: "none"
    },
    style: {
      padding: 0
    }
  }, {
    props: {
      align: "left"
    },
    style: {
      textAlign: "left"
    }
  }, {
    props: {
      align: "center"
    },
    style: {
      textAlign: "center"
    }
  }, {
    props: {
      align: "right"
    },
    style: {
      textAlign: "right",
      flexDirection: "row-reverse"
    }
  }, {
    props: {
      align: "justify"
    },
    style: {
      textAlign: "justify"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.stickyHeader,
    style: {
      position: "sticky",
      top: 0,
      zIndex: 2,
      backgroundColor: (e.vars || e).palette.background.default
    }
  }]
}))), Xd = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = wo({
    props: t,
    name: "MuiTableCell"
  }), {
    align: o = "inherit",
    className: a,
    component: s,
    padding: u,
    scope: c,
    size: f,
    sortDirection: h,
    variant: p,
    ...g
  } = r, y = _.useContext(rM), w = _.useContext(tm), v = w && w.variant === "head";
  let S;
  s ? S = s : S = v ? "th" : "td";
  let E = c;
  S === "td" ? E = void 0 : !E && v && (E = "col");
  const T = p || w && w.variant, k = {
    ...r,
    align: o,
    component: S,
    padding: u || (y && y.padding ? y.padding : "normal"),
    size: f || (y && y.size ? y.size : "medium"),
    sortDirection: h,
    stickyHeader: T === "head" && y && y.stickyHeader,
    variant: T
  }, A = JF(k);
  let M = null;
  return h && (M = h === "asc" ? "ascending" : "descending"), /* @__PURE__ */ x.jsx(e9, {
    as: S,
    ref: n,
    className: zt(A.root, a),
    "aria-sort": M,
    scope: E,
    ownerState: k,
    ...g
  });
});
function t9(e) {
  return bo("MuiTableContainer", e);
}
xo("MuiTableContainer", ["root"]);
const n9 = (e) => {
  const {
    classes: t
  } = e;
  return li({
    root: ["root"]
  }, t9, t);
}, r9 = Tr("div", {
  name: "MuiTableContainer",
  slot: "Root"
})({
  width: "100%",
  overflowX: "auto"
}), o9 = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = wo({
    props: t,
    name: "MuiTableContainer"
  }), {
    className: o,
    component: a = "div",
    ...s
  } = r, u = {
    ...r,
    component: a
  }, c = n9(u);
  return /* @__PURE__ */ x.jsx(r9, {
    ref: n,
    as: a,
    className: zt(c.root, o),
    ownerState: u,
    ...s
  });
});
function i9(e) {
  return bo("MuiTableHead", e);
}
xo("MuiTableHead", ["root"]);
const a9 = (e) => {
  const {
    classes: t
  } = e;
  return li({
    root: ["root"]
  }, i9, t);
}, s9 = Tr("thead", {
  name: "MuiTableHead",
  slot: "Root"
})({
  display: "table-header-group"
}), l9 = {
  variant: "head"
}, qC = "thead", u9 = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = wo({
    props: t,
    name: "MuiTableHead"
  }), {
    className: o,
    component: a = qC,
    ...s
  } = r, u = {
    ...r,
    component: a
  }, c = a9(u);
  return /* @__PURE__ */ x.jsx(tm.Provider, {
    value: l9,
    children: /* @__PURE__ */ x.jsx(s9, {
      as: a,
      className: zt(c.root, o),
      ref: n,
      role: a === qC ? null : "rowgroup",
      ownerState: u,
      ...s
    })
  });
});
function c9(e) {
  return bo("MuiTableRow", e);
}
const GC = xo("MuiTableRow", ["root", "selected", "hover", "head", "footer"]), f9 = (e) => {
  const {
    classes: t,
    selected: n,
    hover: r,
    head: o,
    footer: a
  } = e;
  return li({
    root: ["root", n && "selected", r && "hover", o && "head", a && "footer"]
  }, c9, t);
}, d9 = Tr("tr", {
  name: "MuiTableRow",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.head && t.head, n.footer && t.footer];
  }
})(jl(({
  theme: e
}) => ({
  color: "inherit",
  display: "table-row",
  verticalAlign: "middle",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  [`&.${GC.hover}:hover`]: {
    backgroundColor: (e.vars || e).palette.action.hover
  },
  [`&.${GC.selected}`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : Rc(e.palette.primary.main, e.palette.action.selectedOpacity),
    "&:hover": {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : Rc(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity)
    }
  }
}))), YC = "tr", Kd = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = wo({
    props: t,
    name: "MuiTableRow"
  }), {
    className: o,
    component: a = YC,
    hover: s = !1,
    selected: u = !1,
    ...c
  } = r, f = _.useContext(tm), h = {
    ...r,
    component: a,
    hover: s,
    selected: u,
    head: f && f.variant === "head",
    footer: f && f.variant === "footer"
  }, p = f9(h);
  return /* @__PURE__ */ x.jsx(d9, {
    as: a,
    ref: n,
    className: zt(p.root, o),
    role: a === YC ? null : "row",
    ownerState: h,
    ...c
  });
});
function WC(e) {
  try {
    return e.matches(":focus-visible");
  } catch {
  }
  return !1;
}
function Vv(...e) {
  const t = _.useRef(void 0), n = _.useCallback((r) => {
    const o = e.map((a) => {
      if (a == null)
        return null;
      if (typeof a == "function") {
        const s = a, u = s(r);
        return typeof u == "function" ? u : () => {
          s(null);
        };
      }
      return a.current = r, () => {
        a.current = null;
      };
    });
    return () => {
      o.forEach((a) => a?.());
    };
  }, e);
  return _.useMemo(() => e.every((r) => r == null) ? null : (r) => {
    t.current && (t.current(), t.current = void 0), r != null && (t.current = n(r));
  }, e);
}
function Mh(e) {
  const t = _.useRef(e);
  return UL(() => {
    t.current = e;
  }), _.useRef((...n) => (
    // @ts-expect-error hide `this`
    (0, t.current)(...n)
  )).current;
}
const XC = {};
function NM(e, t) {
  const n = _.useRef(XC);
  return n.current === XC && (n.current = e(t)), n;
}
class Kh {
  constructor() {
    Ku(this, "mountEffect", () => {
      this.shouldMount && !this.didMount && this.ref.current !== null && (this.didMount = !0, this.mounted.resolve());
    });
    this.ref = {
      current: null
    }, this.mounted = null, this.didMount = !1, this.shouldMount = !1, this.setShouldMount = null;
  }
  /** React ref to the ripple instance */
  /** If the ripple component should be mounted */
  /** Promise that resolves when the ripple component is mounted */
  /** If the ripple component has been mounted */
  /** React state hook setter */
  static create() {
    return new Kh();
  }
  static use() {
    const t = NM(Kh.create).current, [n, r] = _.useState(!1);
    return t.shouldMount = n, t.setShouldMount = r, _.useEffect(t.mountEffect, [n]), t;
  }
  mount() {
    return this.mounted || (this.mounted = p9(), this.shouldMount = !0, this.setShouldMount(this.shouldMount)), this.mounted;
  }
  /* Ripple API */
  start(...t) {
    this.mount().then(() => this.ref.current?.start(...t));
  }
  stop(...t) {
    this.mount().then(() => this.ref.current?.stop(...t));
  }
  pulsate(...t) {
    this.mount().then(() => this.ref.current?.pulsate(...t));
  }
}
function h9() {
  return Kh.use();
}
function p9() {
  let e, t;
  const n = new Promise((r, o) => {
    e = r, t = o;
  });
  return n.resolve = e, n.reject = t, n;
}
function S1(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function Zh(e, t) {
  return Zh = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
    return n.__proto__ = r, n;
  }, Zh(e, t);
}
function DM(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Zh(e, t);
}
const KC = nn.createContext(null);
function PM(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function E1(e, t) {
  var n = function(a) {
    return t && _.isValidElement(a) ? t(a) : a;
  }, r = /* @__PURE__ */ Object.create(null);
  return e && _.Children.map(e, function(o) {
    return o;
  }).forEach(function(o) {
    r[o.key] = n(o);
  }), r;
}
function m9(e, t) {
  e = e || {}, t = t || {};
  function n(h) {
    return h in t ? t[h] : e[h];
  }
  var r = /* @__PURE__ */ Object.create(null), o = [];
  for (var a in e)
    a in t ? o.length && (r[a] = o, o = []) : o.push(a);
  var s, u = {};
  for (var c in t) {
    if (r[c])
      for (s = 0; s < r[c].length; s++) {
        var f = r[c][s];
        u[r[c][s]] = n(f);
      }
    u[c] = n(c);
  }
  for (s = 0; s < o.length; s++)
    u[o[s]] = n(o[s]);
  return u;
}
function Pa(e, t, n) {
  return n[t] != null ? n[t] : e.props[t];
}
function g9(e, t) {
  return E1(e.children, function(n) {
    return _.cloneElement(n, {
      onExited: t.bind(null, n),
      in: !0,
      appear: Pa(n, "appear", e),
      enter: Pa(n, "enter", e),
      exit: Pa(n, "exit", e)
    });
  });
}
function y9(e, t, n) {
  var r = E1(e.children), o = m9(t, r);
  return Object.keys(o).forEach(function(a) {
    var s = o[a];
    if (_.isValidElement(s)) {
      var u = a in t, c = a in r, f = t[a], h = _.isValidElement(f) && !f.props.in;
      c && (!u || h) ? o[a] = _.cloneElement(s, {
        onExited: n.bind(null, s),
        in: !0,
        exit: Pa(s, "exit", e),
        enter: Pa(s, "enter", e)
      }) : !c && u && !h ? o[a] = _.cloneElement(s, {
        in: !1
      }) : c && u && _.isValidElement(f) && (o[a] = _.cloneElement(s, {
        onExited: n.bind(null, s),
        in: f.props.in,
        exit: Pa(s, "exit", e),
        enter: Pa(s, "enter", e)
      }));
    }
  }), o;
}
var v9 = Object.values || function(e) {
  return Object.keys(e).map(function(t) {
    return e[t];
  });
}, b9 = {
  component: "div",
  childFactory: function(t) {
    return t;
  }
}, C1 = /* @__PURE__ */ function(e) {
  DM(t, e);
  function t(r, o) {
    var a;
    a = e.call(this, r, o) || this;
    var s = a.handleExited.bind(PM(a));
    return a.state = {
      contextValue: {
        isMounting: !0
      },
      handleExited: s,
      firstRender: !0
    }, a;
  }
  var n = t.prototype;
  return n.componentDidMount = function() {
    this.mounted = !0, this.setState({
      contextValue: {
        isMounting: !1
      }
    });
  }, n.componentWillUnmount = function() {
    this.mounted = !1;
  }, t.getDerivedStateFromProps = function(o, a) {
    var s = a.children, u = a.handleExited, c = a.firstRender;
    return {
      children: c ? g9(o, u) : y9(o, s, u),
      firstRender: !1
    };
  }, n.handleExited = function(o, a) {
    var s = E1(this.props.children);
    o.key in s || (o.props.onExited && o.props.onExited(a), this.mounted && this.setState(function(u) {
      var c = Re({}, u.children);
      return delete c[o.key], {
        children: c
      };
    }));
  }, n.render = function() {
    var o = this.props, a = o.component, s = o.childFactory, u = S1(o, ["component", "childFactory"]), c = this.state.contextValue, f = v9(this.state.children).map(s);
    return delete u.appear, delete u.enter, delete u.exit, a === null ? /* @__PURE__ */ nn.createElement(KC.Provider, {
      value: c
    }, f) : /* @__PURE__ */ nn.createElement(KC.Provider, {
      value: c
    }, /* @__PURE__ */ nn.createElement(a, u, f));
  }, t;
}(nn.Component);
C1.propTypes = {};
C1.defaultProps = b9;
const x9 = [];
function w9(e) {
  _.useEffect(e, x9);
}
class k1 {
  constructor() {
    Ku(this, "currentId", null);
    Ku(this, "clear", () => {
      this.currentId !== null && (clearTimeout(this.currentId), this.currentId = null);
    });
    Ku(this, "disposeEffect", () => this.clear);
  }
  static create() {
    return new k1();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(t, n) {
    this.clear(), this.currentId = setTimeout(() => {
      this.currentId = null, n();
    }, t);
  }
}
function _9() {
  const e = NM(k1.create).current;
  return w9(e.disposeEffect), e;
}
function S9(e) {
  const {
    className: t,
    classes: n,
    pulsate: r = !1,
    rippleX: o,
    rippleY: a,
    rippleSize: s,
    in: u,
    onExited: c,
    timeout: f
  } = e, [h, p] = _.useState(!1), g = zt(t, n.ripple, n.rippleVisible, r && n.ripplePulsate), y = {
    width: s,
    height: s,
    top: -(s / 2) + a,
    left: -(s / 2) + o
  }, w = zt(n.child, h && n.childLeaving, r && n.childPulsate);
  return !u && !h && p(!0), _.useEffect(() => {
    if (!u && c != null) {
      const v = setTimeout(c, f);
      return () => {
        clearTimeout(v);
      };
    }
  }, [c, u, f]), /* @__PURE__ */ x.jsx("span", {
    className: g,
    style: y,
    children: /* @__PURE__ */ x.jsx("span", {
      className: w
    })
  });
}
const xr = xo("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), Uv = 550, E9 = 80, C9 = Zp`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`, k9 = Zp`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`, T9 = Zp`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`, A9 = Tr("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
}), R9 = Tr(S9, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})`
  opacity: 0;
  position: absolute;

  &.${xr.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${C9};
    animation-duration: ${Uv}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  &.${xr.ripplePulsate} {
    animation-duration: ${({
  theme: e
}) => e.transitions.duration.shorter}ms;
  }

  & .${xr.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${xr.childLeaving} {
    opacity: 0;
    animation-name: ${k9};
    animation-duration: ${Uv}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  & .${xr.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${T9};
    animation-duration: 2500ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`, M9 = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = wo({
    props: t,
    name: "MuiTouchRipple"
  }), {
    center: o = !1,
    classes: a = {},
    className: s,
    ...u
  } = r, [c, f] = _.useState([]), h = _.useRef(0), p = _.useRef(null);
  _.useEffect(() => {
    p.current && (p.current(), p.current = null);
  }, [c]);
  const g = _.useRef(!1), y = _9(), w = _.useRef(null), v = _.useRef(null), S = _.useCallback((A) => {
    const {
      pulsate: M,
      rippleX: N,
      rippleY: P,
      rippleSize: z,
      cb: B
    } = A;
    f((R) => [...R, /* @__PURE__ */ x.jsx(R9, {
      classes: {
        ripple: zt(a.ripple, xr.ripple),
        rippleVisible: zt(a.rippleVisible, xr.rippleVisible),
        ripplePulsate: zt(a.ripplePulsate, xr.ripplePulsate),
        child: zt(a.child, xr.child),
        childLeaving: zt(a.childLeaving, xr.childLeaving),
        childPulsate: zt(a.childPulsate, xr.childPulsate)
      },
      timeout: Uv,
      pulsate: M,
      rippleX: N,
      rippleY: P,
      rippleSize: z
    }, h.current)]), h.current += 1, p.current = B;
  }, [a]), E = _.useCallback((A = {}, M = {}, N = () => {
  }) => {
    const {
      pulsate: P = !1,
      center: z = o || M.pulsate,
      fakeElement: B = !1
      // For test purposes
    } = M;
    if (A?.type === "mousedown" && g.current) {
      g.current = !1;
      return;
    }
    A?.type === "touchstart" && (g.current = !0);
    const R = B ? null : v.current, F = R ? R.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let U, W, j;
    if (z || A === void 0 || A.clientX === 0 && A.clientY === 0 || !A.clientX && !A.touches)
      U = Math.round(F.width / 2), W = Math.round(F.height / 2);
    else {
      const {
        clientX: V,
        clientY: I
      } = A.touches && A.touches.length > 0 ? A.touches[0] : A;
      U = Math.round(V - F.left), W = Math.round(I - F.top);
    }
    if (z)
      j = Math.sqrt((2 * F.width ** 2 + F.height ** 2) / 3), j % 2 === 0 && (j += 1);
    else {
      const V = Math.max(Math.abs((R ? R.clientWidth : 0) - U), U) * 2 + 2, I = Math.max(Math.abs((R ? R.clientHeight : 0) - W), W) * 2 + 2;
      j = Math.sqrt(V ** 2 + I ** 2);
    }
    A?.touches ? w.current === null && (w.current = () => {
      S({
        pulsate: P,
        rippleX: U,
        rippleY: W,
        rippleSize: j,
        cb: N
      });
    }, y.start(E9, () => {
      w.current && (w.current(), w.current = null);
    })) : S({
      pulsate: P,
      rippleX: U,
      rippleY: W,
      rippleSize: j,
      cb: N
    });
  }, [o, S, y]), T = _.useCallback(() => {
    E({}, {
      pulsate: !0
    });
  }, [E]), k = _.useCallback((A, M) => {
    if (y.clear(), A?.type === "touchend" && w.current) {
      w.current(), w.current = null, y.start(0, () => {
        k(A, M);
      });
      return;
    }
    w.current = null, f((N) => N.length > 0 ? N.slice(1) : N), p.current = M;
  }, [y]);
  return _.useImperativeHandle(n, () => ({
    pulsate: T,
    start: E,
    stop: k
  }), [T, E, k]), /* @__PURE__ */ x.jsx(A9, {
    className: zt(xr.root, a.root, s),
    ref: v,
    ...u,
    children: /* @__PURE__ */ x.jsx(C1, {
      component: null,
      exit: !0,
      children: c
    })
  });
});
function O9(e) {
  return bo("MuiButtonBase", e);
}
const N9 = xo("MuiButtonBase", ["root", "disabled", "focusVisible"]), D9 = (e) => {
  const {
    disabled: t,
    focusVisible: n,
    focusVisibleClassName: r,
    classes: o
  } = e, s = li({
    root: ["root", t && "disabled", n && "focusVisible"]
  }, O9, o);
  return n && r && (s.root += ` ${r}`), s;
}, P9 = Tr("button", {
  name: "MuiButtonBase",
  slot: "Root"
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${N9.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
}), j9 = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = wo({
    props: t,
    name: "MuiButtonBase"
  }), {
    action: o,
    centerRipple: a = !1,
    children: s,
    className: u,
    component: c = "button",
    disabled: f = !1,
    disableRipple: h = !1,
    disableTouchRipple: p = !1,
    focusRipple: g = !1,
    focusVisibleClassName: y,
    LinkComponent: w = "a",
    onBlur: v,
    onClick: S,
    onContextMenu: E,
    onDragLeave: T,
    onFocus: k,
    onFocusVisible: A,
    onKeyDown: M,
    onKeyUp: N,
    onMouseDown: P,
    onMouseLeave: z,
    onMouseUp: B,
    onTouchEnd: R,
    onTouchMove: F,
    onTouchStart: U,
    tabIndex: W = 0,
    TouchRippleProps: j,
    touchRippleRef: V,
    type: I,
    ...H
  } = r, q = _.useRef(null), G = h9(), O = Vv(G.ref, V), [Y, Z] = _.useState(!1);
  f && Y && Z(!1), _.useImperativeHandle(o, () => ({
    focusVisible: () => {
      Z(!0), q.current.focus();
    }
  }), []);
  const L = G.shouldMount && !h && !f;
  _.useEffect(() => {
    Y && g && !h && G.pulsate();
  }, [h, g, Y, G]);
  const te = Go(G, "start", P, p), he = Go(G, "stop", E, p), oe = Go(G, "stop", T, p), de = Go(G, "stop", B, p), le = Go(G, "stop", (ze) => {
    Y && ze.preventDefault(), z && z(ze);
  }, p), ye = Go(G, "start", U, p), je = Go(G, "stop", R, p), Ne = Go(G, "stop", F, p), we = Go(G, "stop", (ze) => {
    WC(ze.target) || Z(!1), v && v(ze);
  }, !1), Ee = Mh((ze) => {
    q.current || (q.current = ze.currentTarget), WC(ze.target) && (Z(!0), A && A(ze)), k && k(ze);
  }), _e = () => {
    const ze = q.current;
    return c && c !== "button" && !(ze.tagName === "A" && ze.href);
  }, Xe = Mh((ze) => {
    g && !ze.repeat && Y && ze.key === " " && G.stop(ze, () => {
      G.start(ze);
    }), ze.target === ze.currentTarget && _e() && ze.key === " " && ze.preventDefault(), M && M(ze), ze.target === ze.currentTarget && _e() && ze.key === "Enter" && !f && (ze.preventDefault(), S && S(ze));
  }), St = Mh((ze) => {
    g && ze.key === " " && Y && !ze.defaultPrevented && G.stop(ze, () => {
      G.pulsate(ze);
    }), N && N(ze), S && ze.target === ze.currentTarget && _e() && ze.key === " " && !ze.defaultPrevented && S(ze);
  });
  let ct = c;
  ct === "button" && (H.href || H.to) && (ct = w);
  const cn = {};
  ct === "button" ? (cn.type = I === void 0 ? "button" : I, cn.disabled = f) : (!H.href && !H.to && (cn.role = "button"), f && (cn["aria-disabled"] = f));
  const fr = Vv(n, q), Un = {
    ...r,
    centerRipple: a,
    component: c,
    disabled: f,
    disableRipple: h,
    disableTouchRipple: p,
    focusRipple: g,
    tabIndex: W,
    focusVisible: Y
  }, qn = D9(Un);
  return /* @__PURE__ */ x.jsxs(P9, {
    as: ct,
    className: zt(qn.root, u),
    ownerState: Un,
    onBlur: we,
    onClick: S,
    onContextMenu: he,
    onFocus: Ee,
    onKeyDown: Xe,
    onKeyUp: St,
    onMouseDown: te,
    onMouseLeave: le,
    onMouseUp: de,
    onDragLeave: oe,
    onTouchEnd: je,
    onTouchMove: Ne,
    onTouchStart: ye,
    ref: fr,
    tabIndex: f ? -1 : W,
    type: I,
    ...cn,
    ...H,
    children: [s, L ? /* @__PURE__ */ x.jsx(M9, {
      ref: O,
      center: a,
      ...j
    }) : null]
  });
});
function Go(e, t, n, r = !1) {
  return Mh((o) => (n && n(o), r || e[t](o), !0));
}
function I9(e) {
  return bo("MuiSvgIcon", e);
}
xo("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const z9 = (e) => {
  const {
    color: t,
    fontSize: n,
    classes: r
  } = e, o = {
    root: ["root", t !== "inherit" && `color${kn(t)}`, `fontSize${kn(n)}`]
  };
  return li(o, I9, r);
}, L9 = Tr("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.color !== "inherit" && t[`color${kn(n.color)}`], t[`fontSize${kn(n.fontSize)}`]];
  }
})(jl(({
  theme: e
}) => ({
  userSelect: "none",
  width: "1em",
  height: "1em",
  display: "inline-block",
  flexShrink: 0,
  transition: e.transitions?.create?.("fill", {
    duration: (e.vars ?? e).transitions?.duration?.shorter
  }),
  variants: [
    {
      props: (t) => !t.hasSvgAsChild,
      style: {
        // the <svg> will define the property that has `currentColor`
        // for example heroicons uses fill="none" and stroke="currentColor"
        fill: "currentColor"
      }
    },
    {
      props: {
        fontSize: "inherit"
      },
      style: {
        fontSize: "inherit"
      }
    },
    {
      props: {
        fontSize: "small"
      },
      style: {
        fontSize: e.typography?.pxToRem?.(20) || "1.25rem"
      }
    },
    {
      props: {
        fontSize: "medium"
      },
      style: {
        fontSize: e.typography?.pxToRem?.(24) || "1.5rem"
      }
    },
    {
      props: {
        fontSize: "large"
      },
      style: {
        fontSize: e.typography?.pxToRem?.(35) || "2.1875rem"
      }
    },
    // TODO v5 deprecate color prop, v6 remove for sx
    ...Object.entries((e.vars ?? e).palette).filter(([, t]) => t && t.main).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        color: (e.vars ?? e).palette?.[t]?.main
      }
    })),
    {
      props: {
        color: "action"
      },
      style: {
        color: (e.vars ?? e).palette?.action?.active
      }
    },
    {
      props: {
        color: "disabled"
      },
      style: {
        color: (e.vars ?? e).palette?.action?.disabled
      }
    },
    {
      props: {
        color: "inherit"
      },
      style: {
        color: void 0
      }
    }
  ]
}))), qv = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = wo({
    props: t,
    name: "MuiSvgIcon"
  }), {
    children: o,
    className: a,
    color: s = "inherit",
    component: u = "svg",
    fontSize: c = "medium",
    htmlColor: f,
    inheritViewBox: h = !1,
    titleAccess: p,
    viewBox: g = "0 0 24 24",
    ...y
  } = r, w = /* @__PURE__ */ _.isValidElement(o) && o.type === "svg", v = {
    ...r,
    color: s,
    component: u,
    fontSize: c,
    instanceFontSize: t.fontSize,
    inheritViewBox: h,
    viewBox: g,
    hasSvgAsChild: w
  }, S = {};
  h || (S.viewBox = g);
  const E = z9(v);
  return /* @__PURE__ */ x.jsxs(L9, {
    as: u,
    className: zt(E.root, a),
    focusable: "false",
    color: f,
    "aria-hidden": p ? void 0 : !0,
    role: p ? "img" : void 0,
    ref: n,
    ...S,
    ...y,
    ...w && o.props,
    ownerState: v,
    children: [w ? o.props.children : o, p ? /* @__PURE__ */ x.jsx("title", {
      children: p
    }) : null]
  });
});
qv.muiName = "SvgIcon";
function F9(e, t) {
  function n(r, o) {
    return /* @__PURE__ */ x.jsx(qv, {
      "data-testid": void 0,
      ref: o,
      ...r,
      children: e
    });
  }
  return n.muiName = qv.muiName, /* @__PURE__ */ _.memo(/* @__PURE__ */ _.forwardRef(n));
}
const $9 = F9(/* @__PURE__ */ x.jsx("path", {
  d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
}));
function B9(e) {
  return bo("MuiTableSortLabel", e);
}
const Ry = xo("MuiTableSortLabel", ["root", "active", "icon", "iconDirectionDesc", "iconDirectionAsc", "directionDesc", "directionAsc"]);
function H9(e) {
  return typeof e == "string";
}
function V9(e, t, n) {
  return e === void 0 || H9(e) ? t : {
    ...t,
    ownerState: {
      ...t.ownerState,
      ...n
    }
  };
}
function U9(e, t, n) {
  return typeof e == "function" ? e(t, n) : e;
}
function q9(e, t = []) {
  if (e === void 0)
    return {};
  const n = {};
  return Object.keys(e).filter((r) => r.match(/^on[A-Z]/) && typeof e[r] == "function" && !t.includes(r)).forEach((r) => {
    n[r] = e[r];
  }), n;
}
function ZC(e) {
  if (e === void 0)
    return {};
  const t = {};
  return Object.keys(e).filter((n) => !(n.match(/^on[A-Z]/) && typeof e[n] == "function")).forEach((n) => {
    t[n] = e[n];
  }), t;
}
function G9(e) {
  const {
    getSlotProps: t,
    additionalProps: n,
    externalSlotProps: r,
    externalForwardedProps: o,
    className: a
  } = e;
  if (!t) {
    const y = zt(n?.className, a, o?.className, r?.className), w = {
      ...n?.style,
      ...o?.style,
      ...r?.style
    }, v = {
      ...n,
      ...o,
      ...r
    };
    return y.length > 0 && (v.className = y), Object.keys(w).length > 0 && (v.style = w), {
      props: v,
      internalRef: void 0
    };
  }
  const s = q9({
    ...o,
    ...r
  }), u = ZC(r), c = ZC(o), f = t(s), h = zt(f?.className, n?.className, a, o?.className, r?.className), p = {
    ...f?.style,
    ...n?.style,
    ...o?.style,
    ...r?.style
  }, g = {
    ...f,
    ...n,
    ...c,
    ...u
  };
  return h.length > 0 && (g.className = h), Object.keys(p).length > 0 && (g.style = p), {
    props: g,
    internalRef: f.ref
  };
}
function QC(e, t) {
  const {
    className: n,
    elementType: r,
    ownerState: o,
    externalForwardedProps: a,
    internalForwardedProps: s,
    shouldForwardComponentProp: u = !1,
    ...c
  } = t, {
    component: f,
    slots: h = {
      [e]: void 0
    },
    slotProps: p = {
      [e]: void 0
    },
    ...g
  } = a, y = h[e] || r, w = U9(p[e], o), {
    props: {
      component: v,
      ...S
    },
    internalRef: E
  } = G9({
    className: n,
    ...c,
    externalForwardedProps: e === "root" ? g : void 0,
    externalSlotProps: w
  }), T = Vv(E, w?.ref, t.ref), k = e === "root" ? v || f : v, A = V9(y, {
    ...e === "root" && !f && !h[e] && s,
    ...e !== "root" && !h[e] && s,
    ...S,
    ...k && !u && {
      as: k
    },
    ...k && u && {
      component: k
    },
    ref: T
  }, o);
  return [y, A];
}
const Y9 = (e) => {
  const {
    classes: t,
    direction: n,
    active: r
  } = e, o = {
    root: ["root", r && "active", `direction${kn(n)}`],
    icon: ["icon", `iconDirection${kn(n)}`]
  };
  return li(o, B9, t);
}, W9 = Tr(j9, {
  name: "MuiTableSortLabel",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.active && t.active];
  }
})(jl(({
  theme: e
}) => ({
  cursor: "pointer",
  display: "inline-flex",
  justifyContent: "flex-start",
  flexDirection: "inherit",
  alignItems: "center",
  "&:focus": {
    color: (e.vars || e).palette.text.secondary
  },
  "&:hover": {
    color: (e.vars || e).palette.text.secondary,
    [`& .${Ry.icon}`]: {
      opacity: 0.5
    }
  },
  [`&.${Ry.active}`]: {
    color: (e.vars || e).palette.text.primary,
    [`& .${Ry.icon}`]: {
      opacity: 1,
      color: (e.vars || e).palette.text.secondary
    }
  }
}))), X9 = Tr("span", {
  name: "MuiTableSortLabel",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, t[`iconDirection${kn(n.direction)}`]];
  }
})(jl(({
  theme: e
}) => ({
  fontSize: 18,
  marginRight: 4,
  marginLeft: 4,
  opacity: 0,
  transition: e.transitions.create(["opacity", "transform"], {
    duration: e.transitions.duration.shorter
  }),
  userSelect: "none",
  variants: [{
    props: {
      direction: "desc"
    },
    style: {
      transform: "rotate(0deg)"
    }
  }, {
    props: {
      direction: "asc"
    },
    style: {
      transform: "rotate(180deg)"
    }
  }]
}))), K9 = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = wo({
    props: t,
    name: "MuiTableSortLabel"
  }), {
    active: o = !1,
    children: a,
    className: s,
    direction: u = "asc",
    hideSortIcon: c = !1,
    IconComponent: f = $9,
    slots: h = {},
    slotProps: p = {},
    ...g
  } = r, y = {
    ...r,
    active: o,
    direction: u,
    hideSortIcon: c,
    IconComponent: f
  }, w = Y9(y), v = {
    slots: h,
    slotProps: p
  }, [S, E] = QC("root", {
    elementType: W9,
    externalForwardedProps: v,
    ownerState: y,
    className: zt(w.root, s),
    ref: n
  }), [T, k] = QC("icon", {
    elementType: X9,
    externalForwardedProps: v,
    ownerState: y,
    className: w.icon
  });
  return /* @__PURE__ */ x.jsxs(S, {
    disableRipple: !0,
    component: "span",
    ...E,
    ...g,
    children: [a, c && !o ? null : /* @__PURE__ */ x.jsx(T, {
      as: f,
      ...k
    })]
  });
}), Z9 = (e) => {
  const t = [];
  if (e === void 0)
    return {
      header: [],
      rows: []
    };
  e.data === void 0 && (e.data = []), (e.columns === void 0 || e.columns.length === 0) && (e.data.length === 0 ? e.columns = [] : e.columns = e.data[0].map((r, o) => `col${o}`)), (e.index === void 0 || e.index.length === 0) && (e.index = e.data.map((r, o) => `row${o}`));
  const n = Math.max(e.index.length, e.data.length);
  for (let r = 0; r < n; r++) {
    const a = [r < e.index.length ? e.index[r] : `row${r}`];
    for (let s = 0; s < e.columns.length; s++)
      a.push(e.data[r] ? e.data[r][s] : void 0);
    t.push(a);
  }
  return {
    header: ["index", ...e.columns],
    rows: t
  };
}, Q9 = (e, t) => e === "desc" ? (n, r) => r[t] < n[t] ? -1 : r[t] > n[t] ? 1 : 0 : (n, r) => n[t] < r[t] ? -1 : n[t] > r[t] ? 1 : 0, Gv = (e, t) => {
  const n = e.map((r, o) => [
    r,
    o
  ]);
  return n.sort((r, o) => t(r[0], o[0])), n.map((r) => r[0]);
}, J9 = (e, t, n = 1e3) => {
  if (e.length <= n)
    return Gv(e, t);
  const r = [];
  for (let a = 0; a < e.length; a += n)
    r.push(e.slice(a, a + n));
  const o = r.map((a) => Gv(a, t));
  return e8(o, t);
}, e8 = (e, t) => {
  if (e.length === 1) return e[0];
  const n = [], r = new Array(e.length).fill(0);
  for (; r.some((o, a) => o < e[a].length); ) {
    let o = -1, a = null;
    for (let s = 0; s < e.length; s++)
      if (r[s] < e[s].length) {
        const u = e[s][r[s]];
        (a === null || t(u, a) < 0) && (a = u, o = s);
      }
    o !== -1 && a !== null && (n.push(a), r[o]++);
  }
  return n;
}, JC = (e, t, n) => {
  const r = Math.ceil(e / n);
  return {
    currentPage: r === 0 ? 1 : Math.min(Math.max(1, t), r),
    pageSize: n,
    totalPages: r,
    totalRows: e
  };
}, t8 = (e, t, n) => {
  const r = (t - 1) * n, o = r + n;
  return e.slice(r, o);
}, n8 = (e, t, n, r, o = 5) => {
  const a = Math.max(0, Math.floor(e / n) - o), s = Math.min(
    r - 1,
    Math.ceil((e + t) / n) + o
  );
  return { startIndex: a, endIndex: s };
}, r8 = (e, t) => {
  let n;
  return (...r) => {
    clearTimeout(n), n = setTimeout(() => e(...r), t);
  };
}, jM = ({
  tabledata: e,
  className: t = "",
  size: n = "small",
  onSortChange: r,
  enablePagination: o = void 0,
  pageSize: a = 50,
  enableVirtualScrolling: s = void 0,
  virtualScrollingHeight: u = 400,
  enableLazyLoading: c = void 0,
  onLoadMore: f
}) => {
  e || (e = {
    columns: [],
    index: [],
    data: []
  });
  const h = e.index.length;
  h > 1e4 && (c = c === void 0 ? !0 : c), h > 1e3 && (s = s === void 0 ? !0 : s), h > 2 * a && (o = o === void 0 ? !0 : o), c = c === void 0 ? !1 : c, s = s === void 0 ? !1 : s, o = o === void 0 ? !1 : o;
  const p = _.useMemo(
    () => Z9(e),
    [e]
  ), [g, y] = _.useState("asc"), [w, v] = _.useState("index"), [S, E] = _.useState(
    () => JC(p.rows.length, 1, a)
  ), [T, k] = _.useState(0), A = _.useRef(null), M = _.useMemo(() => {
    const q = p.header.indexOf(w);
    return q === -1 ? 0 : q;
  }, [p.header, w]), N = _.useMemo(
    () => r8((q, G) => {
      y(G), v(q), r?.(q, G);
    }, 150),
    [r]
  ), P = _.useCallback(
    (q) => {
      const O = w === q && g === "asc" ? "desc" : "asc";
      p.rows.length > 1e3 ? N(q, O) : (y(O), v(q), r?.(q, O));
    },
    [
      w,
      g,
      r,
      p.rows.length,
      N
    ]
  ), z = _.useMemo(
    () => Q9(g, M),
    [g, M]
  ), B = _.useMemo(() => p.rows.length > 1e3 ? J9(p.rows, z) : Gv(p.rows, z), [p.rows, z]), R = _.useMemo(() => o ? t8(B, S.currentPage, S.pageSize) : B, [
    B,
    o,
    S.currentPage,
    S.pageSize
  ]), F = {
    itemHeight: 48,
    // Approximate row height
    overscan: 5,
    containerHeight: u
  }, U = _.useMemo(() => s ? n8(
    T,
    F.containerHeight,
    F.itemHeight,
    R.length,
    F.overscan
  ) : { startIndex: 0, endIndex: R.length - 1 }, [
    T,
    s,
    R.length,
    F
  ]), W = _.useCallback(
    (q) => {
      s && k(q.currentTarget.scrollTop);
    },
    [s]
  ), j = _.useCallback((q) => {
    E((G) => ({
      ...G,
      currentPage: q
    }));
  }, []), V = _.useCallback(
    (q) => {
      if (!(!o || !(q.target.closest(".sortable-table-wrapper") === q.currentTarget)))
        switch (q.key) {
          case "ArrowLeft":
            S.currentPage > 1 && (q.preventDefault(), q.stopPropagation(), j(S.currentPage - 1));
            break;
          case "ArrowRight":
            S.currentPage < S.totalPages && (console.log(
              "ArrowRight",
              S.currentPage,
              S.totalPages
            ), q.preventDefault(), q.stopPropagation(), j(S.currentPage + 1));
            break;
          case "Home":
            S.currentPage > 1 && (q.preventDefault(), q.stopPropagation(), j(1));
            break;
          case "End":
            S.currentPage < S.totalPages && (q.preventDefault(), q.stopPropagation(), j(S.totalPages));
            break;
        }
    },
    [
      o,
      S.currentPage,
      S.totalPages,
      j
    ]
  );
  _.useEffect(() => {
    o && E((q) => JC(
      B.length,
      q.currentPage,
      // Use previous current page instead of hardcoding 1
      a
    ));
  }, [B.length, o, a]), _.useEffect(() => {
    c && f && S.currentPage >= S.totalPages - 1 && f(S.currentPage + 1);
  }, [
    c,
    f,
    S.currentPage,
    S.totalPages
  ]);
  const I = () => o ? /* @__PURE__ */ x.jsxs("div", { className: "sortable-table-pagination", children: [
    /* @__PURE__ */ x.jsx(
      "button",
      {
        onClick: () => j(S.currentPage - 1),
        disabled: S.currentPage <= 1,
        className: "pagination-button",
        children: "Previous"
      }
    ),
    /* @__PURE__ */ x.jsxs("span", { className: "pagination-info", children: [
      "Page ",
      S.currentPage,
      " of ",
      S.totalPages,
      "(",
      S.totalRows,
      " total rows)"
    ] }),
    /* @__PURE__ */ x.jsx(
      "button",
      {
        onClick: () => j(S.currentPage + 1),
        disabled: S.currentPage >= S.totalPages,
        className: "pagination-button",
        children: "Next"
      }
    )
  ] }) : null, H = () => {
    const q = s ? R.slice(
      U.startIndex,
      U.endIndex + 1
    ) : R;
    return /* @__PURE__ */ x.jsxs(KF, { children: [
      s && /* @__PURE__ */ x.jsx(
        Kd,
        {
          style: {
            height: U.startIndex * F.itemHeight
          },
          children: /* @__PURE__ */ x.jsx(Xd, { colSpan: p.header.length })
        }
      ),
      q.map((G, O) => {
        const Y = s ? U.startIndex + O : O;
        return /* @__PURE__ */ x.jsx(Kd, { children: G.map((Z, L) => /* @__PURE__ */ x.jsx(
          Xd,
          {
            className: L === 0 ? "sortable-table-index-cell" : "sortable-table-data-cell",
            children: Z
          },
          `${e.index?.[Y] || Y}-${L}`
        )) }, e.index?.[Y] || Y);
      }),
      s && /* @__PURE__ */ x.jsx(
        Kd,
        {
          style: {
            height: (R.length - U.endIndex - 1) * F.itemHeight
          },
          children: /* @__PURE__ */ x.jsx(Xd, { colSpan: p.header.length })
        }
      )
    ] });
  };
  return /* @__PURE__ */ x.jsxs(
    "div",
    {
      className: "sortable-table-wrapper",
      onKeyDown: V,
      tabIndex: o ? 0 : -1,
      role: o ? "application" : void 0,
      "aria-label": o ? "Sortable table with pagination" : void 0,
      children: [
        /* @__PURE__ */ x.jsx(
          o9,
          {
            className: `sortable-table-container ${t}`,
            ref: A,
            onScroll: W,
            style: s ? { height: u } : void 0,
            children: /* @__PURE__ */ x.jsxs(qF, { size: n, children: [
              /* @__PURE__ */ x.jsx(u9, { className: "sortable-table-head", children: /* @__PURE__ */ x.jsx(Kd, { className: "sortable-table-header-row", children: p.header.map((q) => /* @__PURE__ */ x.jsx(
                Xd,
                {
                  className: "sortable-table-header-cell",
                  "aria-label": `Sort by ${q}`,
                  children: /* @__PURE__ */ x.jsx(
                    K9,
                    {
                      active: w === q,
                      direction: w === q ? g : "asc",
                      onClick: () => P(q),
                      className: "sortable-table-sort-label",
                      sx: {
                        "& .MuiTableSortLabel-icon": {
                          color: "inherit !important"
                        }
                      },
                      children: q
                    }
                  )
                },
                q
              )) }) }),
              H()
            ] })
          }
        ),
        I()
      ]
    }
  );
};
jM.displayName = "SortableTable";
function xe(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(o) {
    if (e?.(o), n === !1 || !o.defaultPrevented)
      return t?.(o);
  };
}
function ek(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function nm(...e) {
  return (t) => {
    let n = !1;
    const r = e.map((o) => {
      const a = ek(o, t);
      return !n && typeof a == "function" && (n = !0), a;
    });
    if (n)
      return () => {
        for (let o = 0; o < r.length; o++) {
          const a = r[o];
          typeof a == "function" ? a() : ek(e[o], null);
        }
      };
  };
}
function bt(...e) {
  return _.useCallback(nm(...e), e);
}
function o8(e, t) {
  const n = _.createContext(t), r = (a) => {
    const { children: s, ...u } = a, c = _.useMemo(() => u, Object.values(u));
    return /* @__PURE__ */ x.jsx(n.Provider, { value: c, children: s });
  };
  r.displayName = e + "Provider";
  function o(a) {
    const s = _.useContext(n);
    if (s) return s;
    if (t !== void 0) return t;
    throw new Error(`\`${a}\` must be used within \`${e}\``);
  }
  return [r, o];
}
function _o(e, t = []) {
  let n = [];
  function r(a, s) {
    const u = _.createContext(s), c = n.length;
    n = [...n, s];
    const f = (p) => {
      const { scope: g, children: y, ...w } = p, v = g?.[e]?.[c] || u, S = _.useMemo(() => w, Object.values(w));
      return /* @__PURE__ */ x.jsx(v.Provider, { value: S, children: y });
    };
    f.displayName = a + "Provider";
    function h(p, g) {
      const y = g?.[e]?.[c] || u, w = _.useContext(y);
      if (w) return w;
      if (s !== void 0) return s;
      throw new Error(`\`${p}\` must be used within \`${a}\``);
    }
    return [f, h];
  }
  const o = () => {
    const a = n.map((s) => _.createContext(s));
    return function(u) {
      const c = u?.[e] || a;
      return _.useMemo(
        () => ({ [`__scope${e}`]: { ...u, [e]: c } }),
        [u, c]
      );
    };
  };
  return o.scopeName = e, [r, i8(o, ...t)];
}
function i8(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((o) => ({
      useScope: o(),
      scopeName: o.scopeName
    }));
    return function(a) {
      const s = r.reduce((u, { useScope: c, scopeName: f }) => {
        const p = c(a)[`__scope${f}`];
        return { ...u, ...p };
      }, {});
      return _.useMemo(() => ({ [`__scope${t.scopeName}`]: s }), [s]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
var ni = globalThis?.document ? _.useLayoutEffect : () => {
}, a8 = gl[" useId ".trim().toString()] || (() => {
}), s8 = 0;
function po(e) {
  const [t, n] = _.useState(a8());
  return ni(() => {
    n((r) => r ?? String(s8++));
  }, [e]), e || (t ? `radix-${t}` : "");
}
var l8 = gl[" useInsertionEffect ".trim().toString()] || ni;
function sa({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  },
  caller: r
}) {
  const [o, a, s] = u8({
    defaultProp: t,
    onChange: n
  }), u = e !== void 0, c = u ? e : o;
  {
    const h = _.useRef(e !== void 0);
    _.useEffect(() => {
      const p = h.current;
      p !== u && console.warn(
        `${r} is changing from ${p ? "controlled" : "uncontrolled"} to ${u ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      ), h.current = u;
    }, [u, r]);
  }
  const f = _.useCallback(
    (h) => {
      if (u) {
        const p = c8(h) ? h(e) : h;
        p !== e && s.current?.(p);
      } else
        a(h);
    },
    [u, e, a, s]
  );
  return [c, f];
}
function u8({
  defaultProp: e,
  onChange: t
}) {
  const [n, r] = _.useState(e), o = _.useRef(n), a = _.useRef(t);
  return l8(() => {
    a.current = t;
  }, [t]), _.useEffect(() => {
    o.current !== n && (a.current?.(n), o.current = n);
  }, [n, o]), [n, r, a];
}
function c8(e) {
  return typeof e == "function";
}
// @__NO_SIDE_EFFECTS__
function bl(e) {
  const t = /* @__PURE__ */ f8(e), n = _.forwardRef((r, o) => {
    const { children: a, ...s } = r, u = _.Children.toArray(a), c = u.find(h8);
    if (c) {
      const f = c.props.children, h = u.map((p) => p === c ? _.Children.count(f) > 1 ? _.Children.only(null) : _.isValidElement(f) ? f.props.children : null : p);
      return /* @__PURE__ */ x.jsx(t, { ...s, ref: o, children: _.isValidElement(f) ? _.cloneElement(f, void 0, h) : null });
    }
    return /* @__PURE__ */ x.jsx(t, { ...s, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function f8(e) {
  const t = _.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (_.isValidElement(o)) {
      const s = m8(o), u = p8(a, o.props);
      return o.type !== _.Fragment && (u.ref = r ? nm(r, s) : s), _.cloneElement(o, u);
    }
    return _.Children.count(o) > 1 ? _.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var d8 = Symbol("radix.slottable");
function h8(e) {
  return _.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === d8;
}
function p8(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...u) => {
      const c = a(...u);
      return o(...u), c;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function m8(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var g8 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], qe = g8.reduce((e, t) => {
  const n = /* @__PURE__ */ bl(`Primitive.${t}`), r = _.forwardRef((o, a) => {
    const { asChild: s, ...u } = o, c = s ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ x.jsx(c, { ...u, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {});
function T1(e, t) {
  e && Dl.flushSync(() => e.dispatchEvent(t));
}
function Hn(e) {
  const t = _.useRef(e);
  return _.useEffect(() => {
    t.current = e;
  }), _.useMemo(() => (...n) => t.current?.(...n), []);
}
function y8(e, t = globalThis?.document) {
  const n = Hn(e);
  _.useEffect(() => {
    const r = (o) => {
      o.key === "Escape" && n(o);
    };
    return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
  }, [n, t]);
}
var v8 = "DismissableLayer", Yv = "dismissableLayer.update", b8 = "dismissableLayer.pointerDownOutside", x8 = "dismissableLayer.focusOutside", tk, IM = _.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), nf = _.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: o,
      onFocusOutside: a,
      onInteractOutside: s,
      onDismiss: u,
      ...c
    } = e, f = _.useContext(IM), [h, p] = _.useState(null), g = h?.ownerDocument ?? globalThis?.document, [, y] = _.useState({}), w = bt(t, (P) => p(P)), v = Array.from(f.layers), [S] = [...f.layersWithOutsidePointerEventsDisabled].slice(-1), E = v.indexOf(S), T = h ? v.indexOf(h) : -1, k = f.layersWithOutsidePointerEventsDisabled.size > 0, A = T >= E, M = _8((P) => {
      const z = P.target, B = [...f.branches].some((R) => R.contains(z));
      !A || B || (o?.(P), s?.(P), P.defaultPrevented || u?.());
    }, g), N = S8((P) => {
      const z = P.target;
      [...f.branches].some((R) => R.contains(z)) || (a?.(P), s?.(P), P.defaultPrevented || u?.());
    }, g);
    return y8((P) => {
      T === f.layers.size - 1 && (r?.(P), !P.defaultPrevented && u && (P.preventDefault(), u()));
    }, g), _.useEffect(() => {
      if (h)
        return n && (f.layersWithOutsidePointerEventsDisabled.size === 0 && (tk = g.body.style.pointerEvents, g.body.style.pointerEvents = "none"), f.layersWithOutsidePointerEventsDisabled.add(h)), f.layers.add(h), nk(), () => {
          n && f.layersWithOutsidePointerEventsDisabled.size === 1 && (g.body.style.pointerEvents = tk);
        };
    }, [h, g, n, f]), _.useEffect(() => () => {
      h && (f.layers.delete(h), f.layersWithOutsidePointerEventsDisabled.delete(h), nk());
    }, [h, f]), _.useEffect(() => {
      const P = () => y({});
      return document.addEventListener(Yv, P), () => document.removeEventListener(Yv, P);
    }, []), /* @__PURE__ */ x.jsx(
      qe.div,
      {
        ...c,
        ref: w,
        style: {
          pointerEvents: k ? A ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: xe(e.onFocusCapture, N.onFocusCapture),
        onBlurCapture: xe(e.onBlurCapture, N.onBlurCapture),
        onPointerDownCapture: xe(
          e.onPointerDownCapture,
          M.onPointerDownCapture
        )
      }
    );
  }
);
nf.displayName = v8;
var w8 = "DismissableLayerBranch", zM = _.forwardRef((e, t) => {
  const n = _.useContext(IM), r = _.useRef(null), o = bt(t, r);
  return _.useEffect(() => {
    const a = r.current;
    if (a)
      return n.branches.add(a), () => {
        n.branches.delete(a);
      };
  }, [n.branches]), /* @__PURE__ */ x.jsx(qe.div, { ...e, ref: o });
});
zM.displayName = w8;
function _8(e, t = globalThis?.document) {
  const n = Hn(e), r = _.useRef(!1), o = _.useRef(() => {
  });
  return _.useEffect(() => {
    const a = (u) => {
      if (u.target && !r.current) {
        let c = function() {
          LM(
            b8,
            n,
            f,
            { discrete: !0 }
          );
        };
        const f = { originalEvent: u };
        u.pointerType === "touch" ? (t.removeEventListener("click", o.current), o.current = c, t.addEventListener("click", o.current, { once: !0 })) : c();
      } else
        t.removeEventListener("click", o.current);
      r.current = !1;
    }, s = window.setTimeout(() => {
      t.addEventListener("pointerdown", a);
    }, 0);
    return () => {
      window.clearTimeout(s), t.removeEventListener("pointerdown", a), t.removeEventListener("click", o.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function S8(e, t = globalThis?.document) {
  const n = Hn(e), r = _.useRef(!1);
  return _.useEffect(() => {
    const o = (a) => {
      a.target && !r.current && LM(x8, n, { originalEvent: a }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", o), () => t.removeEventListener("focusin", o);
  }, [t, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function nk() {
  const e = new CustomEvent(Yv);
  document.dispatchEvent(e);
}
function LM(e, t, n, { discrete: r }) {
  const o = n.originalEvent.target, a = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && o.addEventListener(e, t, { once: !0 }), r ? T1(o, a) : o.dispatchEvent(a);
}
var E8 = nf, C8 = zM, My = "focusScope.autoFocusOnMount", Oy = "focusScope.autoFocusOnUnmount", rk = { bubbles: !1, cancelable: !0 }, k8 = "FocusScope", rm = _.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: o,
    onUnmountAutoFocus: a,
    ...s
  } = e, [u, c] = _.useState(null), f = Hn(o), h = Hn(a), p = _.useRef(null), g = bt(t, (v) => c(v)), y = _.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  _.useEffect(() => {
    if (r) {
      let v = function(k) {
        if (y.paused || !u) return;
        const A = k.target;
        u.contains(A) ? p.current = A : Gi(p.current, { select: !0 });
      }, S = function(k) {
        if (y.paused || !u) return;
        const A = k.relatedTarget;
        A !== null && (u.contains(A) || Gi(p.current, { select: !0 }));
      }, E = function(k) {
        if (document.activeElement === document.body)
          for (const M of k)
            M.removedNodes.length > 0 && Gi(u);
      };
      document.addEventListener("focusin", v), document.addEventListener("focusout", S);
      const T = new MutationObserver(E);
      return u && T.observe(u, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", v), document.removeEventListener("focusout", S), T.disconnect();
      };
    }
  }, [r, u, y.paused]), _.useEffect(() => {
    if (u) {
      ik.add(y);
      const v = document.activeElement;
      if (!u.contains(v)) {
        const E = new CustomEvent(My, rk);
        u.addEventListener(My, f), u.dispatchEvent(E), E.defaultPrevented || (T8(N8(FM(u)), { select: !0 }), document.activeElement === v && Gi(u));
      }
      return () => {
        u.removeEventListener(My, f), setTimeout(() => {
          const E = new CustomEvent(Oy, rk);
          u.addEventListener(Oy, h), u.dispatchEvent(E), E.defaultPrevented || Gi(v ?? document.body, { select: !0 }), u.removeEventListener(Oy, h), ik.remove(y);
        }, 0);
      };
    }
  }, [u, f, h, y]);
  const w = _.useCallback(
    (v) => {
      if (!n && !r || y.paused) return;
      const S = v.key === "Tab" && !v.altKey && !v.ctrlKey && !v.metaKey, E = document.activeElement;
      if (S && E) {
        const T = v.currentTarget, [k, A] = A8(T);
        k && A ? !v.shiftKey && E === A ? (v.preventDefault(), n && Gi(k, { select: !0 })) : v.shiftKey && E === k && (v.preventDefault(), n && Gi(A, { select: !0 })) : E === T && v.preventDefault();
      }
    },
    [n, r, y.paused]
  );
  return /* @__PURE__ */ x.jsx(qe.div, { tabIndex: -1, ...s, ref: g, onKeyDown: w });
});
rm.displayName = k8;
function T8(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (Gi(r, { select: t }), document.activeElement !== n) return;
}
function A8(e) {
  const t = FM(e), n = ok(t, e), r = ok(t.reverse(), e);
  return [n, r];
}
function FM(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const o = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function ok(e, t) {
  for (const n of e)
    if (!R8(n, { upTo: t })) return n;
}
function R8(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function M8(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function Gi(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && M8(e) && t && e.select();
  }
}
var ik = O8();
function O8() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && n?.pause(), e = ak(e, t), e.unshift(t);
    },
    remove(t) {
      e = ak(e, t), e[0]?.resume();
    }
  };
}
function ak(e, t) {
  const n = [...e], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function N8(e) {
  return e.filter((t) => t.tagName !== "A");
}
var D8 = "Portal", om = _.forwardRef((e, t) => {
  const { container: n, ...r } = e, [o, a] = _.useState(!1);
  ni(() => a(!0), []);
  const s = n || o && globalThis?.document?.body;
  return s ? P6.createPortal(/* @__PURE__ */ x.jsx(qe.div, { ...r, ref: t }), s) : null;
});
om.displayName = D8;
function P8(e, t) {
  return _.useReducer((n, r) => t[n][r] ?? n, e);
}
var Br = (e) => {
  const { present: t, children: n } = e, r = j8(t), o = typeof n == "function" ? n({ present: r.isPresent }) : _.Children.only(n), a = bt(r.ref, I8(o));
  return typeof n == "function" || r.isPresent ? _.cloneElement(o, { ref: a }) : null;
};
Br.displayName = "Presence";
function j8(e) {
  const [t, n] = _.useState(), r = _.useRef(null), o = _.useRef(e), a = _.useRef("none"), s = e ? "mounted" : "unmounted", [u, c] = P8(s, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return _.useEffect(() => {
    const f = Zd(r.current);
    a.current = u === "mounted" ? f : "none";
  }, [u]), ni(() => {
    const f = r.current, h = o.current;
    if (h !== e) {
      const g = a.current, y = Zd(f);
      e ? c("MOUNT") : y === "none" || f?.display === "none" ? c("UNMOUNT") : c(h && g !== y ? "ANIMATION_OUT" : "UNMOUNT"), o.current = e;
    }
  }, [e, c]), ni(() => {
    if (t) {
      let f;
      const h = t.ownerDocument.defaultView ?? window, p = (y) => {
        const v = Zd(r.current).includes(y.animationName);
        if (y.target === t && v && (c("ANIMATION_END"), !o.current)) {
          const S = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", f = h.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = S);
          });
        }
      }, g = (y) => {
        y.target === t && (a.current = Zd(r.current));
      };
      return t.addEventListener("animationstart", g), t.addEventListener("animationcancel", p), t.addEventListener("animationend", p), () => {
        h.clearTimeout(f), t.removeEventListener("animationstart", g), t.removeEventListener("animationcancel", p), t.removeEventListener("animationend", p);
      };
    } else
      c("ANIMATION_END");
  }, [t, c]), {
    isPresent: ["mounted", "unmountSuspended"].includes(u),
    ref: _.useCallback((f) => {
      r.current = f ? getComputedStyle(f) : null, n(f);
    }, [])
  };
}
function Zd(e) {
  return e?.animationName || "none";
}
function I8(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var Ny = 0;
function A1() {
  _.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? sk()), document.body.insertAdjacentElement("beforeend", e[1] ?? sk()), Ny++, () => {
      Ny === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), Ny--;
    };
  }, []);
}
function sk() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var so = function() {
  return so = Object.assign || function(t) {
    for (var n, r = 1, o = arguments.length; r < o; r++) {
      n = arguments[r];
      for (var a in n) Object.prototype.hasOwnProperty.call(n, a) && (t[a] = n[a]);
    }
    return t;
  }, so.apply(this, arguments);
};
function $M(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
function Oh(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, o = t.length, a; r < o; r++)
    (a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), a[r] = t[r]);
  return e.concat(a || Array.prototype.slice.call(t));
}
var Nh = "right-scroll-bar-position", Dh = "width-before-scroll-bar", z8 = "with-scroll-bars-hidden", L8 = "--removed-body-scroll-bar-size";
function Dy(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function F8(e, t) {
  var n = _.useState(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var o = n.value;
          o !== r && (n.value = r, n.callback(r, o));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var $8 = typeof window < "u" ? _.useLayoutEffect : _.useEffect, lk = /* @__PURE__ */ new WeakMap();
function B8(e, t) {
  var n = F8(null, function(r) {
    return e.forEach(function(o) {
      return Dy(o, r);
    });
  });
  return $8(function() {
    var r = lk.get(n);
    if (r) {
      var o = new Set(r), a = new Set(e), s = n.current;
      o.forEach(function(u) {
        a.has(u) || Dy(u, null);
      }), a.forEach(function(u) {
        o.has(u) || Dy(u, s);
      });
    }
    lk.set(n, e);
  }, [e]), n;
}
function H8(e) {
  return e;
}
function V8(e, t) {
  t === void 0 && (t = H8);
  var n = [], r = !1, o = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(a) {
      var s = t(a, r);
      return n.push(s), function() {
        n = n.filter(function(u) {
          return u !== s;
        });
      };
    },
    assignSyncMedium: function(a) {
      for (r = !0; n.length; ) {
        var s = n;
        n = [], s.forEach(a);
      }
      n = {
        push: function(u) {
          return a(u);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(a) {
      r = !0;
      var s = [];
      if (n.length) {
        var u = n;
        n = [], u.forEach(a), s = n;
      }
      var c = function() {
        var h = s;
        s = [], h.forEach(a);
      }, f = function() {
        return Promise.resolve().then(c);
      };
      f(), n = {
        push: function(h) {
          s.push(h), f();
        },
        filter: function(h) {
          return s = s.filter(h), n;
        }
      };
    }
  };
  return o;
}
function U8(e) {
  e === void 0 && (e = {});
  var t = V8(null);
  return t.options = so({ async: !0, ssr: !1 }, e), t;
}
var BM = function(e) {
  var t = e.sideCar, n = $M(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return _.createElement(r, so({}, n));
};
BM.isSideCarExport = !0;
function q8(e, t) {
  return e.useMedium(t), BM;
}
var HM = U8(), Py = function() {
}, im = _.forwardRef(function(e, t) {
  var n = _.useRef(null), r = _.useState({
    onScrollCapture: Py,
    onWheelCapture: Py,
    onTouchMoveCapture: Py
  }), o = r[0], a = r[1], s = e.forwardProps, u = e.children, c = e.className, f = e.removeScrollBar, h = e.enabled, p = e.shards, g = e.sideCar, y = e.noRelative, w = e.noIsolation, v = e.inert, S = e.allowPinchZoom, E = e.as, T = E === void 0 ? "div" : E, k = e.gapMode, A = $M(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), M = g, N = B8([n, t]), P = so(so({}, A), o);
  return _.createElement(
    _.Fragment,
    null,
    h && _.createElement(M, { sideCar: HM, removeScrollBar: f, shards: p, noRelative: y, noIsolation: w, inert: v, setCallbacks: a, allowPinchZoom: !!S, lockRef: n, gapMode: k }),
    s ? _.cloneElement(_.Children.only(u), so(so({}, P), { ref: N })) : _.createElement(T, so({}, P, { className: c, ref: N }), u)
  );
});
im.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
im.classNames = {
  fullWidth: Dh,
  zeroRight: Nh
};
var G8 = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function Y8() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = G8();
  return t && e.setAttribute("nonce", t), e;
}
function W8(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function X8(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var K8 = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = Y8()) && (W8(t, n), X8(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, Z8 = function() {
  var e = K8();
  return function(t, n) {
    _.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, VM = function() {
  var e = Z8(), t = function(n) {
    var r = n.styles, o = n.dynamic;
    return e(r, o), null;
  };
  return t;
}, Q8 = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, jy = function(e) {
  return parseInt(e || "", 10) || 0;
}, J8 = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], o = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [jy(n), jy(r), jy(o)];
}, e$ = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return Q8;
  var t = J8(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, t$ = VM(), ll = "data-scroll-locked", n$ = function(e, t, n, r) {
  var o = e.left, a = e.top, s = e.right, u = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(z8, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(u, "px ").concat(r, `;
  }
  body[`).concat(ll, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(o, `px;
    padding-top: `).concat(a, `px;
    padding-right: `).concat(s, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(u, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(u, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(Nh, ` {
    right: `).concat(u, "px ").concat(r, `;
  }
  
  .`).concat(Dh, ` {
    margin-right: `).concat(u, "px ").concat(r, `;
  }
  
  .`).concat(Nh, " .").concat(Nh, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(Dh, " .").concat(Dh, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(ll, `] {
    `).concat(L8, ": ").concat(u, `px;
  }
`);
}, uk = function() {
  var e = parseInt(document.body.getAttribute(ll) || "0", 10);
  return isFinite(e) ? e : 0;
}, r$ = function() {
  _.useEffect(function() {
    return document.body.setAttribute(ll, (uk() + 1).toString()), function() {
      var e = uk() - 1;
      e <= 0 ? document.body.removeAttribute(ll) : document.body.setAttribute(ll, e.toString());
    };
  }, []);
}, o$ = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, o = r === void 0 ? "margin" : r;
  r$();
  var a = _.useMemo(function() {
    return e$(o);
  }, [o]);
  return _.createElement(t$, { styles: n$(a, !t, o, n ? "" : "!important") });
}, Wv = !1;
if (typeof window < "u")
  try {
    var Qd = Object.defineProperty({}, "passive", {
      get: function() {
        return Wv = !0, !0;
      }
    });
    window.addEventListener("test", Qd, Qd), window.removeEventListener("test", Qd, Qd);
  } catch {
    Wv = !1;
  }
var Gs = Wv ? { passive: !1 } : !1, i$ = function(e) {
  return e.tagName === "TEXTAREA";
}, UM = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !i$(e) && n[t] === "visible")
  );
}, a$ = function(e) {
  return UM(e, "overflowY");
}, s$ = function(e) {
  return UM(e, "overflowX");
}, ck = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var o = qM(e, r);
    if (o) {
      var a = GM(e, r), s = a[1], u = a[2];
      if (s > u)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, l$ = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, u$ = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, qM = function(e, t) {
  return e === "v" ? a$(t) : s$(t);
}, GM = function(e, t) {
  return e === "v" ? l$(t) : u$(t);
}, c$ = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, f$ = function(e, t, n, r, o) {
  var a = c$(e, window.getComputedStyle(t).direction), s = a * r, u = n.target, c = t.contains(u), f = !1, h = s > 0, p = 0, g = 0;
  do {
    if (!u)
      break;
    var y = GM(e, u), w = y[0], v = y[1], S = y[2], E = v - S - a * w;
    (w || E) && qM(e, u) && (p += E, g += w);
    var T = u.parentNode;
    u = T && T.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? T.host : T;
  } while (
    // portaled content
    !c && u !== document.body || // self content
    c && (t.contains(u) || t === u)
  );
  return (h && Math.abs(p) < 1 || !h && Math.abs(g) < 1) && (f = !0), f;
}, Jd = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, fk = function(e) {
  return [e.deltaX, e.deltaY];
}, dk = function(e) {
  return e && "current" in e ? e.current : e;
}, d$ = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, h$ = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, p$ = 0, Ys = [];
function m$(e) {
  var t = _.useRef([]), n = _.useRef([0, 0]), r = _.useRef(), o = _.useState(p$++)[0], a = _.useState(VM)[0], s = _.useRef(e);
  _.useEffect(function() {
    s.current = e;
  }, [e]), _.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(o));
      var v = Oh([e.lockRef.current], (e.shards || []).map(dk), !0).filter(Boolean);
      return v.forEach(function(S) {
        return S.classList.add("allow-interactivity-".concat(o));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(o)), v.forEach(function(S) {
          return S.classList.remove("allow-interactivity-".concat(o));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var u = _.useCallback(function(v, S) {
    if ("touches" in v && v.touches.length === 2 || v.type === "wheel" && v.ctrlKey)
      return !s.current.allowPinchZoom;
    var E = Jd(v), T = n.current, k = "deltaX" in v ? v.deltaX : T[0] - E[0], A = "deltaY" in v ? v.deltaY : T[1] - E[1], M, N = v.target, P = Math.abs(k) > Math.abs(A) ? "h" : "v";
    if ("touches" in v && P === "h" && N.type === "range")
      return !1;
    var z = ck(P, N);
    if (!z)
      return !0;
    if (z ? M = P : (M = P === "v" ? "h" : "v", z = ck(P, N)), !z)
      return !1;
    if (!r.current && "changedTouches" in v && (k || A) && (r.current = M), !M)
      return !0;
    var B = r.current || M;
    return f$(B, S, v, B === "h" ? k : A);
  }, []), c = _.useCallback(function(v) {
    var S = v;
    if (!(!Ys.length || Ys[Ys.length - 1] !== a)) {
      var E = "deltaY" in S ? fk(S) : Jd(S), T = t.current.filter(function(M) {
        return M.name === S.type && (M.target === S.target || S.target === M.shadowParent) && d$(M.delta, E);
      })[0];
      if (T && T.should) {
        S.cancelable && S.preventDefault();
        return;
      }
      if (!T) {
        var k = (s.current.shards || []).map(dk).filter(Boolean).filter(function(M) {
          return M.contains(S.target);
        }), A = k.length > 0 ? u(S, k[0]) : !s.current.noIsolation;
        A && S.cancelable && S.preventDefault();
      }
    }
  }, []), f = _.useCallback(function(v, S, E, T) {
    var k = { name: v, delta: S, target: E, should: T, shadowParent: g$(E) };
    t.current.push(k), setTimeout(function() {
      t.current = t.current.filter(function(A) {
        return A !== k;
      });
    }, 1);
  }, []), h = _.useCallback(function(v) {
    n.current = Jd(v), r.current = void 0;
  }, []), p = _.useCallback(function(v) {
    f(v.type, fk(v), v.target, u(v, e.lockRef.current));
  }, []), g = _.useCallback(function(v) {
    f(v.type, Jd(v), v.target, u(v, e.lockRef.current));
  }, []);
  _.useEffect(function() {
    return Ys.push(a), e.setCallbacks({
      onScrollCapture: p,
      onWheelCapture: p,
      onTouchMoveCapture: g
    }), document.addEventListener("wheel", c, Gs), document.addEventListener("touchmove", c, Gs), document.addEventListener("touchstart", h, Gs), function() {
      Ys = Ys.filter(function(v) {
        return v !== a;
      }), document.removeEventListener("wheel", c, Gs), document.removeEventListener("touchmove", c, Gs), document.removeEventListener("touchstart", h, Gs);
    };
  }, []);
  var y = e.removeScrollBar, w = e.inert;
  return _.createElement(
    _.Fragment,
    null,
    w ? _.createElement(a, { styles: h$(o) }) : null,
    y ? _.createElement(o$, { noRelative: e.noRelative, gapMode: e.gapMode }) : null
  );
}
function g$(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const y$ = q8(HM, m$);
var am = _.forwardRef(function(e, t) {
  return _.createElement(im, so({}, e, { ref: t, sideCar: y$ }));
});
am.classNames = im.classNames;
var v$ = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, Ws = /* @__PURE__ */ new WeakMap(), eh = /* @__PURE__ */ new WeakMap(), th = {}, Iy = 0, YM = function(e) {
  return e && (e.host || YM(e.parentNode));
}, b$ = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = YM(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, x$ = function(e, t, n, r) {
  var o = b$(t, Array.isArray(e) ? e : [e]);
  th[n] || (th[n] = /* @__PURE__ */ new WeakMap());
  var a = th[n], s = [], u = /* @__PURE__ */ new Set(), c = new Set(o), f = function(p) {
    !p || u.has(p) || (u.add(p), f(p.parentNode));
  };
  o.forEach(f);
  var h = function(p) {
    !p || c.has(p) || Array.prototype.forEach.call(p.children, function(g) {
      if (u.has(g))
        h(g);
      else
        try {
          var y = g.getAttribute(r), w = y !== null && y !== "false", v = (Ws.get(g) || 0) + 1, S = (a.get(g) || 0) + 1;
          Ws.set(g, v), a.set(g, S), s.push(g), v === 1 && w && eh.set(g, !0), S === 1 && g.setAttribute(n, "true"), w || g.setAttribute(r, "true");
        } catch (E) {
          console.error("aria-hidden: cannot operate on ", g, E);
        }
    });
  };
  return h(t), u.clear(), Iy++, function() {
    s.forEach(function(p) {
      var g = Ws.get(p) - 1, y = a.get(p) - 1;
      Ws.set(p, g), a.set(p, y), g || (eh.has(p) || p.removeAttribute(r), eh.delete(p)), y || p.removeAttribute(n);
    }), Iy--, Iy || (Ws = /* @__PURE__ */ new WeakMap(), Ws = /* @__PURE__ */ new WeakMap(), eh = /* @__PURE__ */ new WeakMap(), th = {});
  };
}, R1 = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), o = v$(e);
  return o ? (r.push.apply(r, Array.from(o.querySelectorAll("[aria-live], script"))), x$(r, o, n, "aria-hidden")) : function() {
    return null;
  };
}, sm = "Dialog", [WM, Upe] = _o(sm), [w$, Hr] = WM(sm), XM = (e) => {
  const {
    __scopeDialog: t,
    children: n,
    open: r,
    defaultOpen: o,
    onOpenChange: a,
    modal: s = !0
  } = e, u = _.useRef(null), c = _.useRef(null), [f, h] = sa({
    prop: r,
    defaultProp: o ?? !1,
    onChange: a,
    caller: sm
  });
  return /* @__PURE__ */ x.jsx(
    w$,
    {
      scope: t,
      triggerRef: u,
      contentRef: c,
      contentId: po(),
      titleId: po(),
      descriptionId: po(),
      open: f,
      onOpenChange: h,
      onOpenToggle: _.useCallback(() => h((p) => !p), [h]),
      modal: s,
      children: n
    }
  );
};
XM.displayName = sm;
var KM = "DialogTrigger", ZM = _.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = Hr(KM, n), a = bt(t, o.triggerRef);
    return /* @__PURE__ */ x.jsx(
      qe.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": o.open,
        "aria-controls": o.contentId,
        "data-state": N1(o.open),
        ...r,
        ref: a,
        onClick: xe(e.onClick, o.onOpenToggle)
      }
    );
  }
);
ZM.displayName = KM;
var M1 = "DialogPortal", [_$, QM] = WM(M1, {
  forceMount: void 0
}), JM = (e) => {
  const { __scopeDialog: t, forceMount: n, children: r, container: o } = e, a = Hr(M1, t);
  return /* @__PURE__ */ x.jsx(_$, { scope: t, forceMount: n, children: _.Children.map(r, (s) => /* @__PURE__ */ x.jsx(Br, { present: n || a.open, children: /* @__PURE__ */ x.jsx(om, { asChild: !0, container: o, children: s }) })) });
};
JM.displayName = M1;
var Qh = "DialogOverlay", eO = _.forwardRef(
  (e, t) => {
    const n = QM(Qh, e.__scopeDialog), { forceMount: r = n.forceMount, ...o } = e, a = Hr(Qh, e.__scopeDialog);
    return a.modal ? /* @__PURE__ */ x.jsx(Br, { present: r || a.open, children: /* @__PURE__ */ x.jsx(E$, { ...o, ref: t }) }) : null;
  }
);
eO.displayName = Qh;
var S$ = /* @__PURE__ */ bl("DialogOverlay.RemoveScroll"), E$ = _.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = Hr(Qh, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ x.jsx(am, { as: S$, allowPinchZoom: !0, shards: [o.contentRef], children: /* @__PURE__ */ x.jsx(
        qe.div,
        {
          "data-state": N1(o.open),
          ...r,
          ref: t,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), Ua = "DialogContent", tO = _.forwardRef(
  (e, t) => {
    const n = QM(Ua, e.__scopeDialog), { forceMount: r = n.forceMount, ...o } = e, a = Hr(Ua, e.__scopeDialog);
    return /* @__PURE__ */ x.jsx(Br, { present: r || a.open, children: a.modal ? /* @__PURE__ */ x.jsx(C$, { ...o, ref: t }) : /* @__PURE__ */ x.jsx(k$, { ...o, ref: t }) });
  }
);
tO.displayName = Ua;
var C$ = _.forwardRef(
  (e, t) => {
    const n = Hr(Ua, e.__scopeDialog), r = _.useRef(null), o = bt(t, n.contentRef, r);
    return _.useEffect(() => {
      const a = r.current;
      if (a) return R1(a);
    }, []), /* @__PURE__ */ x.jsx(
      nO,
      {
        ...e,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: xe(e.onCloseAutoFocus, (a) => {
          a.preventDefault(), n.triggerRef.current?.focus();
        }),
        onPointerDownOutside: xe(e.onPointerDownOutside, (a) => {
          const s = a.detail.originalEvent, u = s.button === 0 && s.ctrlKey === !0;
          (s.button === 2 || u) && a.preventDefault();
        }),
        onFocusOutside: xe(
          e.onFocusOutside,
          (a) => a.preventDefault()
        )
      }
    );
  }
), k$ = _.forwardRef(
  (e, t) => {
    const n = Hr(Ua, e.__scopeDialog), r = _.useRef(!1), o = _.useRef(!1);
    return /* @__PURE__ */ x.jsx(
      nO,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (a) => {
          e.onCloseAutoFocus?.(a), a.defaultPrevented || (r.current || n.triggerRef.current?.focus(), a.preventDefault()), r.current = !1, o.current = !1;
        },
        onInteractOutside: (a) => {
          e.onInteractOutside?.(a), a.defaultPrevented || (r.current = !0, a.detail.originalEvent.type === "pointerdown" && (o.current = !0));
          const s = a.target;
          n.triggerRef.current?.contains(s) && a.preventDefault(), a.detail.originalEvent.type === "focusin" && o.current && a.preventDefault();
        }
      }
    );
  }
), nO = _.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: o, onCloseAutoFocus: a, ...s } = e, u = Hr(Ua, n), c = _.useRef(null), f = bt(t, c);
    return A1(), /* @__PURE__ */ x.jsxs(x.Fragment, { children: [
      /* @__PURE__ */ x.jsx(
        rm,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: o,
          onUnmountAutoFocus: a,
          children: /* @__PURE__ */ x.jsx(
            nf,
            {
              role: "dialog",
              id: u.contentId,
              "aria-describedby": u.descriptionId,
              "aria-labelledby": u.titleId,
              "data-state": N1(u.open),
              ...s,
              ref: f,
              onDismiss: () => u.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ x.jsxs(x.Fragment, { children: [
        /* @__PURE__ */ x.jsx(T$, { titleId: u.titleId }),
        /* @__PURE__ */ x.jsx(R$, { contentRef: c, descriptionId: u.descriptionId })
      ] })
    ] });
  }
), O1 = "DialogTitle", rO = _.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = Hr(O1, n);
    return /* @__PURE__ */ x.jsx(qe.h2, { id: o.titleId, ...r, ref: t });
  }
);
rO.displayName = O1;
var oO = "DialogDescription", iO = _.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = Hr(oO, n);
    return /* @__PURE__ */ x.jsx(qe.p, { id: o.descriptionId, ...r, ref: t });
  }
);
iO.displayName = oO;
var aO = "DialogClose", sO = _.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = Hr(aO, n);
    return /* @__PURE__ */ x.jsx(
      qe.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: xe(e.onClick, () => o.onOpenChange(!1))
      }
    );
  }
);
sO.displayName = aO;
function N1(e) {
  return e ? "open" : "closed";
}
var lO = "DialogTitleWarning", [qpe, uO] = o8(lO, {
  contentName: Ua,
  titleName: O1,
  docsSlug: "dialog"
}), T$ = ({ titleId: e }) => {
  const t = uO(lO), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return _.useEffect(() => {
    e && (document.getElementById(e) || console.error(n));
  }, [n, e]), null;
}, A$ = "DialogDescriptionWarning", R$ = ({ contentRef: e, descriptionId: t }) => {
  const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${uO(A$).contentName}}.`;
  return _.useEffect(() => {
    const o = e.current?.getAttribute("aria-describedby");
    t && o && (document.getElementById(t) || console.warn(r));
  }, [r, e, t]), null;
}, M$ = XM, O$ = ZM, N$ = JM, D$ = eO, P$ = tO, j$ = rO, I$ = iO, cO = sO;
/*!
 * Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2025 Fonticons, Inc.
 */
function Xv(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function z$(e) {
  if (Array.isArray(e)) return e;
}
function L$(e) {
  if (Array.isArray(e)) return Xv(e);
}
function F$(e, t) {
  if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
}
function $$(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, fO(r.key), r);
  }
}
function B$(e, t, n) {
  return t && $$(e.prototype, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function Ph(e, t) {
  var n = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (!n) {
    if (Array.isArray(e) || (n = D1(e)) || t) {
      n && (e = n);
      var r = 0, o = function() {
      };
      return {
        s: o,
        n: function() {
          return r >= e.length ? {
            done: !0
          } : {
            done: !1,
            value: e[r++]
          };
        },
        e: function(c) {
          throw c;
        },
        f: o
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var a, s = !0, u = !1;
  return {
    s: function() {
      n = n.call(e);
    },
    n: function() {
      var c = n.next();
      return s = c.done, c;
    },
    e: function(c) {
      u = !0, a = c;
    },
    f: function() {
      try {
        s || n.return == null || n.return();
      } finally {
        if (u) throw a;
      }
    }
  };
}
function Ke(e, t, n) {
  return (t = fO(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function H$(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function V$(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r, o, a, s, u = [], c = !0, f = !1;
    try {
      if (a = (n = n.call(e)).next, t === 0) {
        if (Object(n) !== n) return;
        c = !1;
      } else for (; !(c = (r = a.call(n)).done) && (u.push(r.value), u.length !== t); c = !0) ;
    } catch (h) {
      f = !0, o = h;
    } finally {
      try {
        if (!c && n.return != null && (s = n.return(), Object(s) !== s)) return;
      } finally {
        if (f) throw o;
      }
    }
    return u;
  }
}
function U$() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function q$() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function hk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ge(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hk(Object(n), !0).forEach(function(r) {
      Ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function lm(e, t) {
  return z$(e) || V$(e, t) || D1(e, t) || U$();
}
function Lr(e) {
  return L$(e) || H$(e) || D1(e) || q$();
}
function G$(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function fO(e) {
  var t = G$(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function Jh(e) {
  "@babel/helpers - typeof";
  return Jh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Jh(e);
}
function D1(e, t) {
  if (e) {
    if (typeof e == "string") return Xv(e, t);
    var n = {}.toString.call(e).slice(8, -1);
    return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Xv(e, t) : void 0;
  }
}
var pk = function() {
}, P1 = {}, dO = {}, hO = null, pO = {
  mark: pk,
  measure: pk
};
try {
  typeof window < "u" && (P1 = window), typeof document < "u" && (dO = document), typeof MutationObserver < "u" && (hO = MutationObserver), typeof performance < "u" && (pO = performance);
} catch {
}
var Y$ = P1.navigator || {}, mk = Y$.userAgent, gk = mk === void 0 ? "" : mk, ta = P1, _t = dO, yk = hO, nh = pO;
ta.document;
var ui = !!_t.documentElement && !!_t.head && typeof _t.addEventListener == "function" && typeof _t.createElement == "function", mO = ~gk.indexOf("MSIE") || ~gk.indexOf("Trident/"), zy, W$ = /fa(k|kd|s|r|l|t|d|dr|dl|dt|b|slr|slpr|wsb|tl|ns|nds|es|jr|jfr|jdr|cr|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/, X$ = /Font ?Awesome ?([567 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit|Notdog Duo|Notdog|Chisel|Etch|Thumbprint|Jelly Fill|Jelly Duo|Jelly|Slab Press|Slab|Whiteboard)?.*/i, gO = {
  classic: {
    fa: "solid",
    fas: "solid",
    "fa-solid": "solid",
    far: "regular",
    "fa-regular": "regular",
    fal: "light",
    "fa-light": "light",
    fat: "thin",
    "fa-thin": "thin",
    fab: "brands",
    "fa-brands": "brands"
  },
  duotone: {
    fa: "solid",
    fad: "solid",
    "fa-solid": "solid",
    "fa-duotone": "solid",
    fadr: "regular",
    "fa-regular": "regular",
    fadl: "light",
    "fa-light": "light",
    fadt: "thin",
    "fa-thin": "thin"
  },
  sharp: {
    fa: "solid",
    fass: "solid",
    "fa-solid": "solid",
    fasr: "regular",
    "fa-regular": "regular",
    fasl: "light",
    "fa-light": "light",
    fast: "thin",
    "fa-thin": "thin"
  },
  "sharp-duotone": {
    fa: "solid",
    fasds: "solid",
    "fa-solid": "solid",
    fasdr: "regular",
    "fa-regular": "regular",
    fasdl: "light",
    "fa-light": "light",
    fasdt: "thin",
    "fa-thin": "thin"
  },
  slab: {
    "fa-regular": "regular",
    faslr: "regular"
  },
  "slab-press": {
    "fa-regular": "regular",
    faslpr: "regular"
  },
  thumbprint: {
    "fa-light": "light",
    fatl: "light"
  },
  whiteboard: {
    "fa-semibold": "semibold",
    fawsb: "semibold"
  },
  notdog: {
    "fa-solid": "solid",
    fans: "solid"
  },
  "notdog-duo": {
    "fa-solid": "solid",
    fands: "solid"
  },
  etch: {
    "fa-solid": "solid",
    faes: "solid"
  },
  jelly: {
    "fa-regular": "regular",
    fajr: "regular"
  },
  "jelly-fill": {
    "fa-regular": "regular",
    fajfr: "regular"
  },
  "jelly-duo": {
    "fa-regular": "regular",
    fajdr: "regular"
  },
  chisel: {
    "fa-regular": "regular",
    facr: "regular"
  }
}, K$ = {
  GROUP: "duotone-group",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, yO = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone", "fa-thumbprint", "fa-whiteboard", "fa-notdog", "fa-notdog-duo", "fa-chisel", "fa-etch", "fa-jelly", "fa-jelly-fill", "fa-jelly-duo", "fa-slab", "fa-slab-press"], bn = "classic", rf = "duotone", vO = "sharp", bO = "sharp-duotone", xO = "chisel", wO = "etch", _O = "jelly", SO = "jelly-duo", EO = "jelly-fill", CO = "notdog", kO = "notdog-duo", TO = "slab", AO = "slab-press", RO = "thumbprint", MO = "whiteboard", Z$ = "Classic", Q$ = "Duotone", J$ = "Sharp", e7 = "Sharp Duotone", t7 = "Chisel", n7 = "Etch", r7 = "Jelly", o7 = "Jelly Duo", i7 = "Jelly Fill", a7 = "Notdog", s7 = "Notdog Duo", l7 = "Slab", u7 = "Slab Press", c7 = "Thumbprint", f7 = "Whiteboard", OO = [bn, rf, vO, bO, xO, wO, _O, SO, EO, CO, kO, TO, AO, RO, MO];
zy = {}, Ke(Ke(Ke(Ke(Ke(Ke(Ke(Ke(Ke(Ke(zy, bn, Z$), rf, Q$), vO, J$), bO, e7), xO, t7), wO, n7), _O, r7), SO, o7), EO, i7), CO, a7), Ke(Ke(Ke(Ke(Ke(zy, kO, s7), TO, l7), AO, u7), RO, c7), MO, f7);
var d7 = {
  classic: {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  duotone: {
    900: "fad",
    400: "fadr",
    300: "fadl",
    100: "fadt"
  },
  sharp: {
    900: "fass",
    400: "fasr",
    300: "fasl",
    100: "fast"
  },
  "sharp-duotone": {
    900: "fasds",
    400: "fasdr",
    300: "fasdl",
    100: "fasdt"
  },
  slab: {
    400: "faslr"
  },
  "slab-press": {
    400: "faslpr"
  },
  whiteboard: {
    600: "fawsb"
  },
  thumbprint: {
    300: "fatl"
  },
  notdog: {
    900: "fans"
  },
  "notdog-duo": {
    900: "fands"
  },
  etch: {
    900: "faes"
  },
  chisel: {
    400: "facr"
  },
  jelly: {
    400: "fajr"
  },
  "jelly-fill": {
    400: "fajfr"
  },
  "jelly-duo": {
    400: "fajdr"
  }
}, h7 = {
  "Font Awesome 7 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 7 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  "Font Awesome 7 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 7 Duotone": {
    900: "fad",
    400: "fadr",
    normal: "fadr",
    300: "fadl",
    100: "fadt"
  },
  "Font Awesome 7 Sharp": {
    900: "fass",
    400: "fasr",
    normal: "fasr",
    300: "fasl",
    100: "fast"
  },
  "Font Awesome 7 Sharp Duotone": {
    900: "fasds",
    400: "fasdr",
    normal: "fasdr",
    300: "fasdl",
    100: "fasdt"
  },
  "Font Awesome 7 Jelly": {
    400: "fajr",
    normal: "fajr"
  },
  "Font Awesome 7 Jelly Fill": {
    400: "fajfr",
    normal: "fajfr"
  },
  "Font Awesome 7 Jelly Duo": {
    400: "fajdr",
    normal: "fajdr"
  },
  "Font Awesome 7 Slab": {
    400: "faslr",
    normal: "faslr"
  },
  "Font Awesome 7 Slab Press": {
    400: "faslpr",
    normal: "faslpr"
  },
  "Font Awesome 7 Thumbprint": {
    300: "fatl",
    normal: "fatl"
  },
  "Font Awesome 7 Notdog": {
    900: "fans",
    normal: "fans"
  },
  "Font Awesome 7 Notdog Duo": {
    900: "fands",
    normal: "fands"
  },
  "Font Awesome 7 Etch": {
    900: "faes",
    normal: "faes"
  },
  "Font Awesome 7 Chisel": {
    400: "facr",
    normal: "facr"
  },
  "Font Awesome 7 Whiteboard": {
    600: "fawsb",
    normal: "fawsb"
  }
}, p7 = /* @__PURE__ */ new Map([["classic", {
  defaultShortPrefixId: "fas",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin", "brands"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["duotone", {
  defaultShortPrefixId: "fad",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp", {
  defaultShortPrefixId: "fass",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp-duotone", {
  defaultShortPrefixId: "fasds",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["chisel", {
  defaultShortPrefixId: "facr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["etch", {
  defaultShortPrefixId: "faes",
  defaultStyleId: "solid",
  styleIds: ["solid"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["jelly", {
  defaultShortPrefixId: "fajr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["jelly-duo", {
  defaultShortPrefixId: "fajdr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["jelly-fill", {
  defaultShortPrefixId: "fajfr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["notdog", {
  defaultShortPrefixId: "fans",
  defaultStyleId: "solid",
  styleIds: ["solid"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["notdog-duo", {
  defaultShortPrefixId: "fands",
  defaultStyleId: "solid",
  styleIds: ["solid"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["slab", {
  defaultShortPrefixId: "faslr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["slab-press", {
  defaultShortPrefixId: "faslpr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["thumbprint", {
  defaultShortPrefixId: "fatl",
  defaultStyleId: "light",
  styleIds: ["light"],
  futureStyleIds: [],
  defaultFontWeight: 300
}], ["whiteboard", {
  defaultShortPrefixId: "fawsb",
  defaultStyleId: "semibold",
  styleIds: ["semibold"],
  futureStyleIds: [],
  defaultFontWeight: 600
}]]), m7 = {
  chisel: {
    regular: "facr"
  },
  classic: {
    brands: "fab",
    light: "fal",
    regular: "far",
    solid: "fas",
    thin: "fat"
  },
  duotone: {
    light: "fadl",
    regular: "fadr",
    solid: "fad",
    thin: "fadt"
  },
  etch: {
    solid: "faes"
  },
  jelly: {
    regular: "fajr"
  },
  "jelly-duo": {
    regular: "fajdr"
  },
  "jelly-fill": {
    regular: "fajfr"
  },
  notdog: {
    solid: "fans"
  },
  "notdog-duo": {
    solid: "fands"
  },
  sharp: {
    light: "fasl",
    regular: "fasr",
    solid: "fass",
    thin: "fast"
  },
  "sharp-duotone": {
    light: "fasdl",
    regular: "fasdr",
    solid: "fasds",
    thin: "fasdt"
  },
  slab: {
    regular: "faslr"
  },
  "slab-press": {
    regular: "faslpr"
  },
  thumbprint: {
    light: "fatl"
  },
  whiteboard: {
    semibold: "fawsb"
  }
}, NO = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], vk = {
  kit: {
    fak: "kit",
    "fa-kit": "kit"
  },
  "kit-duotone": {
    fakd: "kit-duotone",
    "fa-kit-duotone": "kit-duotone"
  }
}, g7 = ["kit"], y7 = "kit", v7 = "kit-duotone", b7 = "Kit", x7 = "Kit Duotone";
Ke(Ke({}, y7, b7), v7, x7);
var w7 = {
  kit: {
    "fa-kit": "fak"
  }
}, _7 = {
  "Font Awesome Kit": {
    400: "fak",
    normal: "fak"
  },
  "Font Awesome Kit Duotone": {
    400: "fakd",
    normal: "fakd"
  }
}, S7 = {
  kit: {
    fak: "fa-kit"
  }
}, bk = {
  kit: {
    kit: "fak"
  },
  "kit-duotone": {
    "kit-duotone": "fakd"
  }
}, Ly, rh = {
  GROUP: "duotone-group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, E7 = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone", "fa-thumbprint", "fa-whiteboard", "fa-notdog", "fa-notdog-duo", "fa-chisel", "fa-etch", "fa-jelly", "fa-jelly-fill", "fa-jelly-duo", "fa-slab", "fa-slab-press"], C7 = "classic", k7 = "duotone", T7 = "sharp", A7 = "sharp-duotone", R7 = "chisel", M7 = "etch", O7 = "jelly", N7 = "jelly-duo", D7 = "jelly-fill", P7 = "notdog", j7 = "notdog-duo", I7 = "slab", z7 = "slab-press", L7 = "thumbprint", F7 = "whiteboard", $7 = "Classic", B7 = "Duotone", H7 = "Sharp", V7 = "Sharp Duotone", U7 = "Chisel", q7 = "Etch", G7 = "Jelly", Y7 = "Jelly Duo", W7 = "Jelly Fill", X7 = "Notdog", K7 = "Notdog Duo", Z7 = "Slab", Q7 = "Slab Press", J7 = "Thumbprint", eB = "Whiteboard";
Ly = {}, Ke(Ke(Ke(Ke(Ke(Ke(Ke(Ke(Ke(Ke(Ly, C7, $7), k7, B7), T7, H7), A7, V7), R7, U7), M7, q7), O7, G7), N7, Y7), D7, W7), P7, X7), Ke(Ke(Ke(Ke(Ke(Ly, j7, K7), I7, Z7), z7, Q7), L7, J7), F7, eB);
var tB = "kit", nB = "kit-duotone", rB = "Kit", oB = "Kit Duotone";
Ke(Ke({}, tB, rB), nB, oB);
var iB = {
  classic: {
    "fa-brands": "fab",
    "fa-duotone": "fad",
    "fa-light": "fal",
    "fa-regular": "far",
    "fa-solid": "fas",
    "fa-thin": "fat"
  },
  duotone: {
    "fa-regular": "fadr",
    "fa-light": "fadl",
    "fa-thin": "fadt"
  },
  sharp: {
    "fa-solid": "fass",
    "fa-regular": "fasr",
    "fa-light": "fasl",
    "fa-thin": "fast"
  },
  "sharp-duotone": {
    "fa-solid": "fasds",
    "fa-regular": "fasdr",
    "fa-light": "fasdl",
    "fa-thin": "fasdt"
  },
  slab: {
    "fa-regular": "faslr"
  },
  "slab-press": {
    "fa-regular": "faslpr"
  },
  whiteboard: {
    "fa-semibold": "fawsb"
  },
  thumbprint: {
    "fa-light": "fatl"
  },
  notdog: {
    "fa-solid": "fans"
  },
  "notdog-duo": {
    "fa-solid": "fands"
  },
  etch: {
    "fa-solid": "faes"
  },
  jelly: {
    "fa-regular": "fajr"
  },
  "jelly-fill": {
    "fa-regular": "fajfr"
  },
  "jelly-duo": {
    "fa-regular": "fajdr"
  },
  chisel: {
    "fa-regular": "facr"
  }
}, aB = {
  classic: ["fas", "far", "fal", "fat", "fad"],
  duotone: ["fadr", "fadl", "fadt"],
  sharp: ["fass", "fasr", "fasl", "fast"],
  "sharp-duotone": ["fasds", "fasdr", "fasdl", "fasdt"],
  slab: ["faslr"],
  "slab-press": ["faslpr"],
  whiteboard: ["fawsb"],
  thumbprint: ["fatl"],
  notdog: ["fans"],
  "notdog-duo": ["fands"],
  etch: ["faes"],
  jelly: ["fajr"],
  "jelly-fill": ["fajfr"],
  "jelly-duo": ["fajdr"],
  chisel: ["facr"]
}, Kv = {
  classic: {
    fab: "fa-brands",
    fad: "fa-duotone",
    fal: "fa-light",
    far: "fa-regular",
    fas: "fa-solid",
    fat: "fa-thin"
  },
  duotone: {
    fadr: "fa-regular",
    fadl: "fa-light",
    fadt: "fa-thin"
  },
  sharp: {
    fass: "fa-solid",
    fasr: "fa-regular",
    fasl: "fa-light",
    fast: "fa-thin"
  },
  "sharp-duotone": {
    fasds: "fa-solid",
    fasdr: "fa-regular",
    fasdl: "fa-light",
    fasdt: "fa-thin"
  },
  slab: {
    faslr: "fa-regular"
  },
  "slab-press": {
    faslpr: "fa-regular"
  },
  whiteboard: {
    fawsb: "fa-semibold"
  },
  thumbprint: {
    fatl: "fa-light"
  },
  notdog: {
    fans: "fa-solid"
  },
  "notdog-duo": {
    fands: "fa-solid"
  },
  etch: {
    faes: "fa-solid"
  },
  jelly: {
    fajr: "fa-regular"
  },
  "jelly-fill": {
    fajfr: "fa-regular"
  },
  "jelly-duo": {
    fajdr: "fa-regular"
  },
  chisel: {
    facr: "fa-regular"
  }
}, sB = ["fa-solid", "fa-regular", "fa-light", "fa-thin", "fa-duotone", "fa-brands", "fa-semibold"], DO = ["fa", "fas", "far", "fal", "fat", "fad", "fadr", "fadl", "fadt", "fab", "fass", "fasr", "fasl", "fast", "fasds", "fasdr", "fasdl", "fasdt", "faslr", "faslpr", "fawsb", "fatl", "fans", "fands", "faes", "fajr", "fajfr", "fajdr", "facr"].concat(E7, sB), lB = ["solid", "regular", "light", "thin", "duotone", "brands", "semibold"], PO = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], uB = PO.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), cB = ["aw", "fw", "pull-left", "pull-right"], fB = [].concat(Lr(Object.keys(aB)), lB, cB, ["2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "inverse", "layers", "layers-bottom-left", "layers-bottom-right", "layers-counter", "layers-text", "layers-top-left", "layers-top-right", "li", "pull-end", "pull-start", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", "width-auto", "width-fixed", rh.GROUP, rh.SWAP_OPACITY, rh.PRIMARY, rh.SECONDARY]).concat(PO.map(function(e) {
  return "".concat(e, "x");
})).concat(uB.map(function(e) {
  return "w-".concat(e);
})), dB = {
  "Font Awesome 5 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 5 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal"
  },
  "Font Awesome 5 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 5 Duotone": {
    900: "fad"
  }
}, ri = "___FONT_AWESOME___", Zv = 16, jO = "fa", IO = "svg-inline--fa", qa = "data-fa-i2svg", Qv = "data-fa-pseudo-element", hB = "data-fa-pseudo-element-pending", j1 = "data-prefix", I1 = "data-icon", xk = "fontawesome-i2svg", pB = "async", mB = ["HTML", "HEAD", "STYLE", "SCRIPT"], zO = ["::before", "::after", ":before", ":after"], LO = function() {
  try {
    return !0;
  } catch {
    return !1;
  }
}();
function of(e) {
  return new Proxy(e, {
    get: function(n, r) {
      return r in n ? n[r] : n[bn];
    }
  });
}
var FO = ge({}, gO);
FO[bn] = ge(ge(ge(ge({}, {
  "fa-duotone": "duotone"
}), gO[bn]), vk.kit), vk["kit-duotone"]);
var gB = of(FO), Jv = ge({}, m7);
Jv[bn] = ge(ge(ge(ge({}, {
  duotone: "fad"
}), Jv[bn]), bk.kit), bk["kit-duotone"]);
var wk = of(Jv), eb = ge({}, Kv);
eb[bn] = ge(ge({}, eb[bn]), S7.kit);
var $O = of(eb), tb = ge({}, iB);
tb[bn] = ge(ge({}, tb[bn]), w7.kit);
of(tb);
var yB = W$, BO = "fa-layers-text", vB = X$, bB = ge({}, d7);
of(bB);
var xB = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"], Fy = K$, wB = [].concat(Lr(g7), Lr(fB)), yc = ta.FontAwesomeConfig || {};
function _B(e) {
  var t = _t.querySelector("script[" + e + "]");
  if (t)
    return t.getAttribute(e);
}
function SB(e) {
  return e === "" ? !0 : e === "false" ? !1 : e === "true" ? !0 : e;
}
if (_t && typeof _t.querySelector == "function") {
  var EB = [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-search-pseudo-elements-warnings", "searchPseudoElementsWarnings"], ["data-search-pseudo-elements-full-scan", "searchPseudoElementsFullScan"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
  EB.forEach(function(e) {
    var t = lm(e, 2), n = t[0], r = t[1], o = SB(_B(n));
    o != null && (yc[r] = o);
  });
}
var HO = {
  styleDefault: "solid",
  familyDefault: bn,
  cssPrefix: jO,
  replacementClass: IO,
  autoReplaceSvg: !0,
  autoAddCss: !0,
  searchPseudoElements: !1,
  searchPseudoElementsWarnings: !0,
  searchPseudoElementsFullScan: !1,
  observeMutations: !0,
  mutateApproach: "async",
  keepOriginalSource: !0,
  measurePerformance: !1,
  showMissingIcons: !0
};
yc.familyPrefix && (yc.cssPrefix = yc.familyPrefix);
var xl = ge(ge({}, HO), yc);
xl.autoReplaceSvg || (xl.observeMutations = !1);
var Ae = {};
Object.keys(HO).forEach(function(e) {
  Object.defineProperty(Ae, e, {
    enumerable: !0,
    set: function(n) {
      xl[e] = n, vc.forEach(function(r) {
        return r(Ae);
      });
    },
    get: function() {
      return xl[e];
    }
  });
});
Object.defineProperty(Ae, "familyPrefix", {
  enumerable: !0,
  set: function(t) {
    xl.cssPrefix = t, vc.forEach(function(n) {
      return n(Ae);
    });
  },
  get: function() {
    return xl.cssPrefix;
  }
});
ta.FontAwesomeConfig = Ae;
var vc = [];
function CB(e) {
  return vc.push(e), function() {
    vc.splice(vc.indexOf(e), 1);
  };
}
var Xs = Zv, lo = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: !1,
  flipY: !1
};
function kB(e) {
  if (!(!e || !ui)) {
    var t = _t.createElement("style");
    t.setAttribute("type", "text/css"), t.innerHTML = e;
    for (var n = _t.head.childNodes, r = null, o = n.length - 1; o > -1; o--) {
      var a = n[o], s = (a.tagName || "").toUpperCase();
      ["STYLE", "LINK"].indexOf(s) > -1 && (r = a);
    }
    return _t.head.insertBefore(t, r), e;
  }
}
var TB = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function _k() {
  for (var e = 12, t = ""; e-- > 0; )
    t += TB[Math.random() * 62 | 0];
  return t;
}
function Il(e) {
  for (var t = [], n = (e || []).length >>> 0; n--; )
    t[n] = e[n];
  return t;
}
function z1(e) {
  return e.classList ? Il(e.classList) : (e.getAttribute("class") || "").split(" ").filter(function(t) {
    return t;
  });
}
function VO(e) {
  return "".concat(e).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function AB(e) {
  return Object.keys(e || {}).reduce(function(t, n) {
    return t + "".concat(n, '="').concat(VO(e[n]), '" ');
  }, "").trim();
}
function um(e) {
  return Object.keys(e || {}).reduce(function(t, n) {
    return t + "".concat(n, ": ").concat(e[n].trim(), ";");
  }, "");
}
function L1(e) {
  return e.size !== lo.size || e.x !== lo.x || e.y !== lo.y || e.rotate !== lo.rotate || e.flipX || e.flipY;
}
function RB(e) {
  var t = e.transform, n = e.containerWidth, r = e.iconWidth, o = {
    transform: "translate(".concat(n / 2, " 256)")
  }, a = "translate(".concat(t.x * 32, ", ").concat(t.y * 32, ") "), s = "scale(".concat(t.size / 16 * (t.flipX ? -1 : 1), ", ").concat(t.size / 16 * (t.flipY ? -1 : 1), ") "), u = "rotate(".concat(t.rotate, " 0 0)"), c = {
    transform: "".concat(a, " ").concat(s, " ").concat(u)
  }, f = {
    transform: "translate(".concat(r / 2 * -1, " -256)")
  };
  return {
    outer: o,
    inner: c,
    path: f
  };
}
function MB(e) {
  var t = e.transform, n = e.width, r = n === void 0 ? Zv : n, o = e.height, a = o === void 0 ? Zv : o, s = "";
  return mO ? s += "translate(".concat(t.x / Xs - r / 2, "em, ").concat(t.y / Xs - a / 2, "em) ") : s += "translate(calc(-50% + ".concat(t.x / Xs, "em), calc(-50% + ").concat(t.y / Xs, "em)) "), s += "scale(".concat(t.size / Xs * (t.flipX ? -1 : 1), ", ").concat(t.size / Xs * (t.flipY ? -1 : 1), ") "), s += "rotate(".concat(t.rotate, "deg) "), s;
}
var OB = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 7 Free";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 7 Free";
  --fa-font-light: normal 300 1em/1 "Font Awesome 7 Pro";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 7 Pro";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-regular: normal 400 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-light: normal 300 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-thin: normal 100 1em/1 "Font Awesome 7 Duotone";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 7 Brands";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-regular: normal 400 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-light: normal 300 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-thin: normal 100 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-slab-regular: normal 400 1em/1 "Font Awesome 7 Slab";
  --fa-font-slab-press-regular: normal 400 1em/1 "Font Awesome 7 Slab Press";
  --fa-font-whiteboard-semibold: normal 600 1em/1 "Font Awesome 7 Whiteboard";
  --fa-font-thumbprint-light: normal 300 1em/1 "Font Awesome 7 Thumbprint";
  --fa-font-notdog-solid: normal 900 1em/1 "Font Awesome 7 Notdog";
  --fa-font-notdog-duo-solid: normal 900 1em/1 "Font Awesome 7 Notdog Duo";
  --fa-font-etch-solid: normal 900 1em/1 "Font Awesome 7 Etch";
  --fa-font-jelly-regular: normal 400 1em/1 "Font Awesome 7 Jelly";
  --fa-font-jelly-fill-regular: normal 400 1em/1 "Font Awesome 7 Jelly Fill";
  --fa-font-jelly-duo-regular: normal 400 1em/1 "Font Awesome 7 Jelly Duo";
  --fa-font-chisel-regular: normal 400 1em/1 "Font Awesome 7 Chisel";
}

.svg-inline--fa {
  box-sizing: content-box;
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
  width: var(--fa-width, 1.25em);
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285714em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left,
.svg-inline--fa .fa-pull-start {
  float: inline-start;
  margin-inline-end: var(--fa-pull-margin, 0.3em);
}
.svg-inline--fa.fa-pull-right,
.svg-inline--fa .fa-pull-end {
  float: inline-end;
  margin-inline-start: var(--fa-pull-margin, 0.3em);
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  inset-inline-start: calc(-1 * var(--fa-li-width, 2em));
  inset-block-start: 0.25em; /* syncing vertical alignment with Web Font rendering */
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: var(--fa-width, 1.25em);
}
.fa-layers .svg-inline--fa {
  inset: 0;
  margin: auto;
  position: absolute;
  transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-counter-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: calc(10 / 16 * 1em); /* converts a 10px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 10 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 10 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-xs {
  font-size: calc(12 / 16 * 1em); /* converts a 12px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 12 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 12 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-sm {
  font-size: calc(14 / 16 * 1em); /* converts a 14px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 14 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 14 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-lg {
  font-size: calc(20 / 16 * 1em); /* converts a 20px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 20 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 20 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-xl {
  font-size: calc(24 / 16 * 1em); /* converts a 24px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 24 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 24 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-2xl {
  font-size: calc(32 / 16 * 1em); /* converts a 32px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 32 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 32 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-width-auto {
  --fa-width: auto;
}

.fa-fw,
.fa-width-fixed {
  --fa-width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-inline-start: var(--fa-li-margin, 2.5em);
  padding-inline-start: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  inset-inline-start: calc(-1 * var(--fa-li-width, 2em));
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

/* Heads Up: Bordered Icons will not be supported in the future!
  - This feature will be deprecated in the next major release of Font Awesome (v8)!
  - You may continue to use it in this version *v7), but it will not be supported in Font Awesome v8.
*/
/* Notes:
* --@{v.$css-prefix}-border-width = 1/16 by default (to render as ~1px based on a 16px default font-size)
* --@{v.$css-prefix}-border-padding =
  ** 3/16 for vertical padding (to give ~2px of vertical whitespace around an icon considering it's vertical alignment)
  ** 4/16 for horizontal padding (to give ~4px of horizontal whitespace around an icon)
*/
.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.0625em);
  box-sizing: var(--fa-border-box-sizing, content-box);
  padding: var(--fa-border-padding, 0.1875em 0.25em);
}

.fa-pull-left,
.fa-pull-start {
  float: inline-start;
  margin-inline-end: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right,
.fa-pull-end {
  float: inline-end;
  margin-inline-start: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  animation-name: fa-beat;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  animation-name: fa-bounce;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  animation-name: fa-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  animation-name: fa-beat-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  animation-name: fa-flip;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  animation-name: fa-shake;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  animation-name: fa-spin;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 2s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  animation-name: fa-spin;
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
  .fa-bounce,
  .fa-fade,
  .fa-beat-fade,
  .fa-flip,
  .fa-pulse,
  .fa-shake,
  .fa-spin,
  .fa-spin-pulse {
    animation: none !important;
    transition: none !important;
  }
}
@keyframes fa-beat {
  0%, 90% {
    transform: scale(1);
  }
  45% {
    transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-bounce {
  0% {
    transform: scale(1, 1) translateY(0);
  }
  10% {
    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    transform: scale(1, 1) translateY(0);
  }
  100% {
    transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-flip {
  50% {
    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-shake {
  0% {
    transform: rotate(-15deg);
  }
  4% {
    transform: rotate(15deg);
  }
  8%, 24% {
    transform: rotate(-18deg);
  }
  12%, 28% {
    transform: rotate(18deg);
  }
  16% {
    transform: rotate(-22deg);
  }
  20% {
    transform: rotate(22deg);
  }
  32% {
    transform: rotate(-12deg);
  }
  36% {
    transform: rotate(12deg);
  }
  40%, 100% {
    transform: rotate(0deg);
  }
}
@keyframes fa-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  transform: rotate(90deg);
}

.fa-rotate-180 {
  transform: rotate(180deg);
}

.fa-rotate-270 {
  transform: rotate(270deg);
}

.fa-flip-horizontal {
  transform: scale(-1, 1);
}

.fa-flip-vertical {
  transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  transform: scale(-1, -1);
}

.fa-rotate-by {
  transform: rotate(var(--fa-rotate-angle, 0));
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}

.svg-inline--fa.fa-inverse {
  fill: var(--fa-inverse, #fff);
}

.fa-stack {
  display: inline-block;
  height: 2em;
  line-height: 2em;
  position: relative;
  vertical-align: middle;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
  z-index: var(--fa-stack-z-index, auto);
}`;
function UO() {
  var e = jO, t = IO, n = Ae.cssPrefix, r = Ae.replacementClass, o = OB;
  if (n !== e || r !== t) {
    var a = new RegExp("\\.".concat(e, "\\-"), "g"), s = new RegExp("\\--".concat(e, "\\-"), "g"), u = new RegExp("\\.".concat(t), "g");
    o = o.replace(a, ".".concat(n, "-")).replace(s, "--".concat(n, "-")).replace(u, ".".concat(r));
  }
  return o;
}
var Sk = !1;
function $y() {
  Ae.autoAddCss && !Sk && (kB(UO()), Sk = !0);
}
var NB = {
  mixout: function() {
    return {
      dom: {
        css: UO,
        insertCss: $y
      }
    };
  },
  hooks: function() {
    return {
      beforeDOMElementCreation: function() {
        $y();
      },
      beforeI2svg: function() {
        $y();
      }
    };
  }
}, oi = ta || {};
oi[ri] || (oi[ri] = {});
oi[ri].styles || (oi[ri].styles = {});
oi[ri].hooks || (oi[ri].hooks = {});
oi[ri].shims || (oi[ri].shims = []);
var jr = oi[ri], qO = [], GO = function() {
  _t.removeEventListener("DOMContentLoaded", GO), ep = 1, qO.map(function(t) {
    return t();
  });
}, ep = !1;
ui && (ep = (_t.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(_t.readyState), ep || _t.addEventListener("DOMContentLoaded", GO));
function DB(e) {
  ui && (ep ? setTimeout(e, 0) : qO.push(e));
}
function af(e) {
  var t = e.tag, n = e.attributes, r = n === void 0 ? {} : n, o = e.children, a = o === void 0 ? [] : o;
  return typeof e == "string" ? VO(e) : "<".concat(t, " ").concat(AB(r), ">").concat(a.map(af).join(""), "</").concat(t, ">");
}
function Ek(e, t, n) {
  if (e && e[t] && e[t][n])
    return {
      prefix: t,
      iconName: n,
      icon: e[t][n]
    };
}
var By = function(t, n, r, o) {
  var a = Object.keys(t), s = a.length, u = n, c, f, h;
  for (r === void 0 ? (c = 1, h = t[a[0]]) : (c = 0, h = r); c < s; c++)
    f = a[c], h = u(h, t[f], f, t);
  return h;
};
function YO(e) {
  return Lr(e).length !== 1 ? null : e.codePointAt(0).toString(16);
}
function Ck(e) {
  return Object.keys(e).reduce(function(t, n) {
    var r = e[n], o = !!r.icon;
    return o ? t[r.iconName] = r.icon : t[n] = r, t;
  }, {});
}
function WO(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = n.skipHooks, o = r === void 0 ? !1 : r, a = Ck(t);
  typeof jr.hooks.addPack == "function" && !o ? jr.hooks.addPack(e, Ck(t)) : jr.styles[e] = ge(ge({}, jr.styles[e] || {}), a), e === "fas" && WO("fa", t);
}
var Oc = jr.styles, PB = jr.shims, XO = Object.keys($O), jB = XO.reduce(function(e, t) {
  return e[t] = Object.keys($O[t]), e;
}, {}), F1 = null, KO = {}, ZO = {}, QO = {}, JO = {}, eN = {};
function IB(e) {
  return ~wB.indexOf(e);
}
function zB(e, t) {
  var n = t.split("-"), r = n[0], o = n.slice(1).join("-");
  return r === e && o !== "" && !IB(o) ? o : null;
}
var tN = function() {
  var t = function(a) {
    return By(Oc, function(s, u, c) {
      return s[c] = By(u, a, {}), s;
    }, {});
  };
  KO = t(function(o, a, s) {
    if (a[3] && (o[a[3]] = s), a[2]) {
      var u = a[2].filter(function(c) {
        return typeof c == "number";
      });
      u.forEach(function(c) {
        o[c.toString(16)] = s;
      });
    }
    return o;
  }), ZO = t(function(o, a, s) {
    if (o[s] = s, a[2]) {
      var u = a[2].filter(function(c) {
        return typeof c == "string";
      });
      u.forEach(function(c) {
        o[c] = s;
      });
    }
    return o;
  }), eN = t(function(o, a, s) {
    var u = a[2];
    return o[s] = s, u.forEach(function(c) {
      o[c] = s;
    }), o;
  });
  var n = "far" in Oc || Ae.autoFetchSvg, r = By(PB, function(o, a) {
    var s = a[0], u = a[1], c = a[2];
    return u === "far" && !n && (u = "fas"), typeof s == "string" && (o.names[s] = {
      prefix: u,
      iconName: c
    }), typeof s == "number" && (o.unicodes[s.toString(16)] = {
      prefix: u,
      iconName: c
    }), o;
  }, {
    names: {},
    unicodes: {}
  });
  QO = r.names, JO = r.unicodes, F1 = cm(Ae.styleDefault, {
    family: Ae.familyDefault
  });
};
CB(function(e) {
  F1 = cm(e.styleDefault, {
    family: Ae.familyDefault
  });
});
tN();
function $1(e, t) {
  return (KO[e] || {})[t];
}
function LB(e, t) {
  return (ZO[e] || {})[t];
}
function ja(e, t) {
  return (eN[e] || {})[t];
}
function nN(e) {
  return QO[e] || {
    prefix: null,
    iconName: null
  };
}
function FB(e) {
  var t = JO[e], n = $1("fas", e);
  return t || (n ? {
    prefix: "fas",
    iconName: n
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function na() {
  return F1;
}
var rN = function() {
  return {
    prefix: null,
    iconName: null,
    rest: []
  };
};
function $B(e) {
  var t = bn, n = XO.reduce(function(r, o) {
    return r[o] = "".concat(Ae.cssPrefix, "-").concat(o), r;
  }, {});
  return OO.forEach(function(r) {
    (e.includes(n[r]) || e.some(function(o) {
      return jB[r].includes(o);
    })) && (t = r);
  }), t;
}
function cm(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.family, r = n === void 0 ? bn : n, o = gB[r][e];
  if (r === rf && !e)
    return "fad";
  var a = wk[r][e] || wk[r][o], s = e in jr.styles ? e : null, u = a || s || null;
  return u;
}
function BB(e) {
  var t = [], n = null;
  return e.forEach(function(r) {
    var o = zB(Ae.cssPrefix, r);
    o ? n = o : r && t.push(r);
  }), {
    iconName: n,
    rest: t
  };
}
function kk(e) {
  return e.sort().filter(function(t, n, r) {
    return r.indexOf(t) === n;
  });
}
var Tk = DO.concat(NO);
function fm(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.skipLookups, r = n === void 0 ? !1 : n, o = null, a = kk(e.filter(function(y) {
    return Tk.includes(y);
  })), s = kk(e.filter(function(y) {
    return !Tk.includes(y);
  })), u = a.filter(function(y) {
    return o = y, !yO.includes(y);
  }), c = lm(u, 1), f = c[0], h = f === void 0 ? null : f, p = $B(a), g = ge(ge({}, BB(s)), {}, {
    prefix: cm(h, {
      family: p
    })
  });
  return ge(ge(ge({}, g), qB({
    values: e,
    family: p,
    styles: Oc,
    config: Ae,
    canonical: g,
    givenPrefix: o
  })), HB(r, o, g));
}
function HB(e, t, n) {
  var r = n.prefix, o = n.iconName;
  if (e || !r || !o)
    return {
      prefix: r,
      iconName: o
    };
  var a = t === "fa" ? nN(o) : {}, s = ja(r, o);
  return o = a.iconName || s || o, r = a.prefix || r, r === "far" && !Oc.far && Oc.fas && !Ae.autoFetchSvg && (r = "fas"), {
    prefix: r,
    iconName: o
  };
}
var VB = OO.filter(function(e) {
  return e !== bn || e !== rf;
}), UB = Object.keys(Kv).filter(function(e) {
  return e !== bn;
}).map(function(e) {
  return Object.keys(Kv[e]);
}).flat();
function qB(e) {
  var t = e.values, n = e.family, r = e.canonical, o = e.givenPrefix, a = o === void 0 ? "" : o, s = e.styles, u = s === void 0 ? {} : s, c = e.config, f = c === void 0 ? {} : c, h = n === rf, p = t.includes("fa-duotone") || t.includes("fad"), g = f.familyDefault === "duotone", y = r.prefix === "fad" || r.prefix === "fa-duotone";
  if (!h && (p || g || y) && (r.prefix = "fad"), (t.includes("fa-brands") || t.includes("fab")) && (r.prefix = "fab"), !r.prefix && VB.includes(n)) {
    var w = Object.keys(u).find(function(S) {
      return UB.includes(S);
    });
    if (w || f.autoFetchSvg) {
      var v = p7.get(n).defaultShortPrefixId;
      r.prefix = v, r.iconName = ja(r.prefix, r.iconName) || r.iconName;
    }
  }
  return (r.prefix === "fa" || a === "fa") && (r.prefix = na() || "fas"), r;
}
var GB = /* @__PURE__ */ function() {
  function e() {
    F$(this, e), this.definitions = {};
  }
  return B$(e, [{
    key: "add",
    value: function() {
      for (var n = this, r = arguments.length, o = new Array(r), a = 0; a < r; a++)
        o[a] = arguments[a];
      var s = o.reduce(this._pullDefinitions, {});
      Object.keys(s).forEach(function(u) {
        n.definitions[u] = ge(ge({}, n.definitions[u] || {}), s[u]), WO(u, s[u]), tN();
      });
    }
  }, {
    key: "reset",
    value: function() {
      this.definitions = {};
    }
  }, {
    key: "_pullDefinitions",
    value: function(n, r) {
      var o = r.prefix && r.iconName && r.icon ? {
        0: r
      } : r;
      return Object.keys(o).map(function(a) {
        var s = o[a], u = s.prefix, c = s.iconName, f = s.icon, h = f[2];
        n[u] || (n[u] = {}), h.length > 0 && h.forEach(function(p) {
          typeof p == "string" && (n[u][p] = f);
        }), n[u][c] = f;
      }), n;
    }
  }]);
}(), Ak = [], rl = {}, ul = {}, YB = Object.keys(ul);
function WB(e, t) {
  var n = t.mixoutsTo;
  return Ak = e, rl = {}, Object.keys(ul).forEach(function(r) {
    YB.indexOf(r) === -1 && delete ul[r];
  }), Ak.forEach(function(r) {
    var o = r.mixout ? r.mixout() : {};
    if (Object.keys(o).forEach(function(s) {
      typeof o[s] == "function" && (n[s] = o[s]), Jh(o[s]) === "object" && Object.keys(o[s]).forEach(function(u) {
        n[s] || (n[s] = {}), n[s][u] = o[s][u];
      });
    }), r.hooks) {
      var a = r.hooks();
      Object.keys(a).forEach(function(s) {
        rl[s] || (rl[s] = []), rl[s].push(a[s]);
      });
    }
    r.provides && r.provides(ul);
  }), n;
}
function nb(e, t) {
  for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++)
    r[o - 2] = arguments[o];
  var a = rl[e] || [];
  return a.forEach(function(s) {
    t = s.apply(null, [t].concat(r));
  }), t;
}
function Ga(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  var o = rl[e] || [];
  o.forEach(function(a) {
    a.apply(null, n);
  });
}
function ra() {
  var e = arguments[0], t = Array.prototype.slice.call(arguments, 1);
  return ul[e] ? ul[e].apply(null, t) : void 0;
}
function rb(e) {
  e.prefix === "fa" && (e.prefix = "fas");
  var t = e.iconName, n = e.prefix || na();
  if (t)
    return t = ja(n, t) || t, Ek(oN.definitions, n, t) || Ek(jr.styles, n, t);
}
var oN = new GB(), XB = function() {
  Ae.autoReplaceSvg = !1, Ae.observeMutations = !1, Ga("noAuto");
}, KB = {
  i2svg: function() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return ui ? (Ga("beforeI2svg", t), ra("pseudoElements2svg", t), ra("i2svg", t)) : Promise.reject(new Error("Operation requires a DOM of some kind."));
  },
  watch: function() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = t.autoReplaceSvgRoot;
    Ae.autoReplaceSvg === !1 && (Ae.autoReplaceSvg = !0), Ae.observeMutations = !0, DB(function() {
      QB({
        autoReplaceSvgRoot: n
      }), Ga("watch", t);
    });
  }
}, ZB = {
  icon: function(t) {
    if (t === null)
      return null;
    if (Jh(t) === "object" && t.prefix && t.iconName)
      return {
        prefix: t.prefix,
        iconName: ja(t.prefix, t.iconName) || t.iconName
      };
    if (Array.isArray(t) && t.length === 2) {
      var n = t[1].indexOf("fa-") === 0 ? t[1].slice(3) : t[1], r = cm(t[0]);
      return {
        prefix: r,
        iconName: ja(r, n) || n
      };
    }
    if (typeof t == "string" && (t.indexOf("".concat(Ae.cssPrefix, "-")) > -1 || t.match(yB))) {
      var o = fm(t.split(" "), {
        skipLookups: !0
      });
      return {
        prefix: o.prefix || na(),
        iconName: ja(o.prefix, o.iconName) || o.iconName
      };
    }
    if (typeof t == "string") {
      var a = na();
      return {
        prefix: a,
        iconName: ja(a, t) || t
      };
    }
  }
}, ur = {
  noAuto: XB,
  config: Ae,
  dom: KB,
  parse: ZB,
  library: oN,
  findIconDefinition: rb,
  toHtml: af
}, QB = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = t.autoReplaceSvgRoot, r = n === void 0 ? _t : n;
  (Object.keys(jr.styles).length > 0 || Ae.autoFetchSvg) && ui && Ae.autoReplaceSvg && ur.dom.i2svg({
    node: r
  });
};
function dm(e, t) {
  return Object.defineProperty(e, "abstract", {
    get: t
  }), Object.defineProperty(e, "html", {
    get: function() {
      return e.abstract.map(function(r) {
        return af(r);
      });
    }
  }), Object.defineProperty(e, "node", {
    get: function() {
      if (ui) {
        var r = _t.createElement("div");
        return r.innerHTML = e.html, r.children;
      }
    }
  }), e;
}
function JB(e) {
  var t = e.children, n = e.main, r = e.mask, o = e.attributes, a = e.styles, s = e.transform;
  if (L1(s) && n.found && !r.found) {
    var u = n.width, c = n.height, f = {
      x: u / c / 2,
      y: 0.5
    };
    o.style = um(ge(ge({}, a), {}, {
      "transform-origin": "".concat(f.x + s.x / 16, "em ").concat(f.y + s.y / 16, "em")
    }));
  }
  return [{
    tag: "svg",
    attributes: o,
    children: t
  }];
}
function eH(e) {
  var t = e.prefix, n = e.iconName, r = e.children, o = e.attributes, a = e.symbol, s = a === !0 ? "".concat(t, "-").concat(Ae.cssPrefix, "-").concat(n) : a;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: ge(ge({}, o), {}, {
        id: s
      }),
      children: r
    }]
  }];
}
function tH(e) {
  var t = ["aria-label", "aria-labelledby", "title", "role"];
  return t.some(function(n) {
    return n in e;
  });
}
function B1(e) {
  var t = e.icons, n = t.main, r = t.mask, o = e.prefix, a = e.iconName, s = e.transform, u = e.symbol, c = e.maskId, f = e.extra, h = e.watchable, p = h === void 0 ? !1 : h, g = r.found ? r : n, y = g.width, w = g.height, v = [Ae.replacementClass, a ? "".concat(Ae.cssPrefix, "-").concat(a) : ""].filter(function(M) {
    return f.classes.indexOf(M) === -1;
  }).filter(function(M) {
    return M !== "" || !!M;
  }).concat(f.classes).join(" "), S = {
    children: [],
    attributes: ge(ge({}, f.attributes), {}, {
      "data-prefix": o,
      "data-icon": a,
      class: v,
      role: f.attributes.role || "img",
      viewBox: "0 0 ".concat(y, " ").concat(w)
    })
  };
  !tH(f.attributes) && !f.attributes["aria-hidden"] && (S.attributes["aria-hidden"] = "true"), p && (S.attributes[qa] = "");
  var E = ge(ge({}, S), {}, {
    prefix: o,
    iconName: a,
    main: n,
    mask: r,
    maskId: c,
    transform: s,
    symbol: u,
    styles: ge({}, f.styles)
  }), T = r.found && n.found ? ra("generateAbstractMask", E) || {
    children: [],
    attributes: {}
  } : ra("generateAbstractIcon", E) || {
    children: [],
    attributes: {}
  }, k = T.children, A = T.attributes;
  return E.children = k, E.attributes = A, u ? eH(E) : JB(E);
}
function Rk(e) {
  var t = e.content, n = e.width, r = e.height, o = e.transform, a = e.extra, s = e.watchable, u = s === void 0 ? !1 : s, c = ge(ge({}, a.attributes), {}, {
    class: a.classes.join(" ")
  });
  u && (c[qa] = "");
  var f = ge({}, a.styles);
  L1(o) && (f.transform = MB({
    transform: o,
    width: n,
    height: r
  }), f["-webkit-transform"] = f.transform);
  var h = um(f);
  h.length > 0 && (c.style = h);
  var p = [];
  return p.push({
    tag: "span",
    attributes: c,
    children: [t]
  }), p;
}
function nH(e) {
  var t = e.content, n = e.extra, r = ge(ge({}, n.attributes), {}, {
    class: n.classes.join(" ")
  }), o = um(n.styles);
  o.length > 0 && (r.style = o);
  var a = [];
  return a.push({
    tag: "span",
    attributes: r,
    children: [t]
  }), a;
}
var Hy = jr.styles;
function ob(e) {
  var t = e[0], n = e[1], r = e.slice(4), o = lm(r, 1), a = o[0], s = null;
  return Array.isArray(a) ? s = {
    tag: "g",
    attributes: {
      class: "".concat(Ae.cssPrefix, "-").concat(Fy.GROUP)
    },
    children: [{
      tag: "path",
      attributes: {
        class: "".concat(Ae.cssPrefix, "-").concat(Fy.SECONDARY),
        fill: "currentColor",
        d: a[0]
      }
    }, {
      tag: "path",
      attributes: {
        class: "".concat(Ae.cssPrefix, "-").concat(Fy.PRIMARY),
        fill: "currentColor",
        d: a[1]
      }
    }]
  } : s = {
    tag: "path",
    attributes: {
      fill: "currentColor",
      d: a
    }
  }, {
    found: !0,
    width: t,
    height: n,
    icon: s
  };
}
var rH = {
  found: !1,
  width: 512,
  height: 512
};
function oH(e, t) {
  !LO && !Ae.showMissingIcons && e && console.error('Icon with name "'.concat(e, '" and prefix "').concat(t, '" is missing.'));
}
function ib(e, t) {
  var n = t;
  return t === "fa" && Ae.styleDefault !== null && (t = na()), new Promise(function(r, o) {
    if (n === "fa") {
      var a = nN(e) || {};
      e = a.iconName || e, t = a.prefix || t;
    }
    if (e && t && Hy[t] && Hy[t][e]) {
      var s = Hy[t][e];
      return r(ob(s));
    }
    oH(e, t), r(ge(ge({}, rH), {}, {
      icon: Ae.showMissingIcons && e ? ra("missingIconAbstract") || {} : {}
    }));
  });
}
var Mk = function() {
}, ab = Ae.measurePerformance && nh && nh.mark && nh.measure ? nh : {
  mark: Mk,
  measure: Mk
}, fc = 'FA "7.0.0"', iH = function(t) {
  return ab.mark("".concat(fc, " ").concat(t, " begins")), function() {
    return iN(t);
  };
}, iN = function(t) {
  ab.mark("".concat(fc, " ").concat(t, " ends")), ab.measure("".concat(fc, " ").concat(t), "".concat(fc, " ").concat(t, " begins"), "".concat(fc, " ").concat(t, " ends"));
}, H1 = {
  begin: iH,
  end: iN
}, jh = function() {
};
function Ok(e) {
  var t = e.getAttribute ? e.getAttribute(qa) : null;
  return typeof t == "string";
}
function aH(e) {
  var t = e.getAttribute ? e.getAttribute(j1) : null, n = e.getAttribute ? e.getAttribute(I1) : null;
  return t && n;
}
function sH(e) {
  return e && e.classList && e.classList.contains && e.classList.contains(Ae.replacementClass);
}
function lH() {
  if (Ae.autoReplaceSvg === !0)
    return Ih.replace;
  var e = Ih[Ae.autoReplaceSvg];
  return e || Ih.replace;
}
function uH(e) {
  return _t.createElementNS("http://www.w3.org/2000/svg", e);
}
function cH(e) {
  return _t.createElement(e);
}
function aN(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.ceFn, r = n === void 0 ? e.tag === "svg" ? uH : cH : n;
  if (typeof e == "string")
    return _t.createTextNode(e);
  var o = r(e.tag);
  Object.keys(e.attributes || []).forEach(function(s) {
    o.setAttribute(s, e.attributes[s]);
  });
  var a = e.children || [];
  return a.forEach(function(s) {
    o.appendChild(aN(s, {
      ceFn: r
    }));
  }), o;
}
function fH(e) {
  var t = " ".concat(e.outerHTML, " ");
  return t = "".concat(t, "Font Awesome fontawesome.com "), t;
}
var Ih = {
  replace: function(t) {
    var n = t[0];
    if (n.parentNode)
      if (t[1].forEach(function(o) {
        n.parentNode.insertBefore(aN(o), n);
      }), n.getAttribute(qa) === null && Ae.keepOriginalSource) {
        var r = _t.createComment(fH(n));
        n.parentNode.replaceChild(r, n);
      } else
        n.remove();
  },
  nest: function(t) {
    var n = t[0], r = t[1];
    if (~z1(n).indexOf(Ae.replacementClass))
      return Ih.replace(t);
    var o = new RegExp("".concat(Ae.cssPrefix, "-.*"));
    if (delete r[0].attributes.id, r[0].attributes.class) {
      var a = r[0].attributes.class.split(" ").reduce(function(u, c) {
        return c === Ae.replacementClass || c.match(o) ? u.toSvg.push(c) : u.toNode.push(c), u;
      }, {
        toNode: [],
        toSvg: []
      });
      r[0].attributes.class = a.toSvg.join(" "), a.toNode.length === 0 ? n.removeAttribute("class") : n.setAttribute("class", a.toNode.join(" "));
    }
    var s = r.map(function(u) {
      return af(u);
    }).join(`
`);
    n.setAttribute(qa, ""), n.innerHTML = s;
  }
};
function Nk(e) {
  e();
}
function sN(e, t) {
  var n = typeof t == "function" ? t : jh;
  if (e.length === 0)
    n();
  else {
    var r = Nk;
    Ae.mutateApproach === pB && (r = ta.requestAnimationFrame || Nk), r(function() {
      var o = lH(), a = H1.begin("mutate");
      e.map(o), a(), n();
    });
  }
}
var V1 = !1;
function lN() {
  V1 = !0;
}
function sb() {
  V1 = !1;
}
var tp = null;
function Dk(e) {
  if (yk && Ae.observeMutations) {
    var t = e.treeCallback, n = t === void 0 ? jh : t, r = e.nodeCallback, o = r === void 0 ? jh : r, a = e.pseudoElementsCallback, s = a === void 0 ? jh : a, u = e.observeMutationsRoot, c = u === void 0 ? _t : u;
    tp = new yk(function(f) {
      if (!V1) {
        var h = na();
        Il(f).forEach(function(p) {
          if (p.type === "childList" && p.addedNodes.length > 0 && !Ok(p.addedNodes[0]) && (Ae.searchPseudoElements && s(p.target), n(p.target)), p.type === "attributes" && p.target.parentNode && Ae.searchPseudoElements && s([p.target], !0), p.type === "attributes" && Ok(p.target) && ~xB.indexOf(p.attributeName))
            if (p.attributeName === "class" && aH(p.target)) {
              var g = fm(z1(p.target)), y = g.prefix, w = g.iconName;
              p.target.setAttribute(j1, y || h), w && p.target.setAttribute(I1, w);
            } else sH(p.target) && o(p.target);
        });
      }
    }), ui && tp.observe(c, {
      childList: !0,
      attributes: !0,
      characterData: !0,
      subtree: !0
    });
  }
}
function dH() {
  tp && tp.disconnect();
}
function hH(e) {
  var t = e.getAttribute("style"), n = [];
  return t && (n = t.split(";").reduce(function(r, o) {
    var a = o.split(":"), s = a[0], u = a.slice(1);
    return s && u.length > 0 && (r[s] = u.join(":").trim()), r;
  }, {})), n;
}
function pH(e) {
  var t = e.getAttribute("data-prefix"), n = e.getAttribute("data-icon"), r = e.innerText !== void 0 ? e.innerText.trim() : "", o = fm(z1(e));
  return o.prefix || (o.prefix = na()), t && n && (o.prefix = t, o.iconName = n), o.iconName && o.prefix || (o.prefix && r.length > 0 && (o.iconName = LB(o.prefix, e.innerText) || $1(o.prefix, YO(e.innerText))), !o.iconName && Ae.autoFetchSvg && e.firstChild && e.firstChild.nodeType === Node.TEXT_NODE && (o.iconName = e.firstChild.data)), o;
}
function mH(e) {
  var t = Il(e.attributes).reduce(function(n, r) {
    return n.name !== "class" && n.name !== "style" && (n[r.name] = r.value), n;
  }, {});
  return t;
}
function gH() {
  return {
    iconName: null,
    prefix: null,
    transform: lo,
    symbol: !1,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function Pk(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    styleParser: !0
  }, n = pH(e), r = n.iconName, o = n.prefix, a = n.rest, s = mH(e), u = nb("parseNodeAttributes", {}, e), c = t.styleParser ? hH(e) : [];
  return ge({
    iconName: r,
    prefix: o,
    transform: lo,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: !1,
    extra: {
      classes: a,
      styles: c,
      attributes: s
    }
  }, u);
}
var yH = jr.styles;
function uN(e) {
  var t = Ae.autoReplaceSvg === "nest" ? Pk(e, {
    styleParser: !1
  }) : Pk(e);
  return ~t.extra.classes.indexOf(BO) ? ra("generateLayersText", e, t) : ra("generateSvgReplacementMutation", e, t);
}
function vH() {
  return [].concat(Lr(NO), Lr(DO));
}
function jk(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!ui) return Promise.resolve();
  var n = _t.documentElement.classList, r = function(p) {
    return n.add("".concat(xk, "-").concat(p));
  }, o = function(p) {
    return n.remove("".concat(xk, "-").concat(p));
  }, a = Ae.autoFetchSvg ? vH() : yO.concat(Object.keys(yH));
  a.includes("fa") || a.push("fa");
  var s = [".".concat(BO, ":not([").concat(qa, "])")].concat(a.map(function(h) {
    return ".".concat(h, ":not([").concat(qa, "])");
  })).join(", ");
  if (s.length === 0)
    return Promise.resolve();
  var u = [];
  try {
    u = Il(e.querySelectorAll(s));
  } catch {
  }
  if (u.length > 0)
    r("pending"), o("complete");
  else
    return Promise.resolve();
  var c = H1.begin("onTree"), f = u.reduce(function(h, p) {
    try {
      var g = uN(p);
      g && h.push(g);
    } catch (y) {
      LO || y.name === "MissingIcon" && console.error(y);
    }
    return h;
  }, []);
  return new Promise(function(h, p) {
    Promise.all(f).then(function(g) {
      sN(g, function() {
        r("active"), r("complete"), o("pending"), typeof t == "function" && t(), c(), h();
      });
    }).catch(function(g) {
      c(), p(g);
    });
  });
}
function bH(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  uN(e).then(function(n) {
    n && sN([n], t);
  });
}
function xH(e) {
  return function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = (t || {}).icon ? t : rb(t || {}), o = n.mask;
    return o && (o = (o || {}).icon ? o : rb(o || {})), e(r, ge(ge({}, n), {}, {
      mask: o
    }));
  };
}
var wH = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = n.transform, o = r === void 0 ? lo : r, a = n.symbol, s = a === void 0 ? !1 : a, u = n.mask, c = u === void 0 ? null : u, f = n.maskId, h = f === void 0 ? null : f, p = n.classes, g = p === void 0 ? [] : p, y = n.attributes, w = y === void 0 ? {} : y, v = n.styles, S = v === void 0 ? {} : v;
  if (t) {
    var E = t.prefix, T = t.iconName, k = t.icon;
    return dm(ge({
      type: "icon"
    }, t), function() {
      return Ga("beforeDOMElementCreation", {
        iconDefinition: t,
        params: n
      }), B1({
        icons: {
          main: ob(k),
          mask: c ? ob(c.icon) : {
            found: !1,
            width: null,
            height: null,
            icon: {}
          }
        },
        prefix: E,
        iconName: T,
        transform: ge(ge({}, lo), o),
        symbol: s,
        maskId: h,
        extra: {
          attributes: w,
          styles: S,
          classes: g
        }
      });
    });
  }
}, _H = {
  mixout: function() {
    return {
      icon: xH(wH)
    };
  },
  hooks: function() {
    return {
      mutationObserverCallbacks: function(n) {
        return n.treeCallback = jk, n.nodeCallback = bH, n;
      }
    };
  },
  provides: function(t) {
    t.i2svg = function(n) {
      var r = n.node, o = r === void 0 ? _t : r, a = n.callback, s = a === void 0 ? function() {
      } : a;
      return jk(o, s);
    }, t.generateSvgReplacementMutation = function(n, r) {
      var o = r.iconName, a = r.prefix, s = r.transform, u = r.symbol, c = r.mask, f = r.maskId, h = r.extra;
      return new Promise(function(p, g) {
        Promise.all([ib(o, a), c.iconName ? ib(c.iconName, c.prefix) : Promise.resolve({
          found: !1,
          width: 512,
          height: 512,
          icon: {}
        })]).then(function(y) {
          var w = lm(y, 2), v = w[0], S = w[1];
          p([n, B1({
            icons: {
              main: v,
              mask: S
            },
            prefix: a,
            iconName: o,
            transform: s,
            symbol: u,
            maskId: f,
            extra: h,
            watchable: !0
          })]);
        }).catch(g);
      });
    }, t.generateAbstractIcon = function(n) {
      var r = n.children, o = n.attributes, a = n.main, s = n.transform, u = n.styles, c = um(u);
      c.length > 0 && (o.style = c);
      var f;
      return L1(s) && (f = ra("generateAbstractTransformGrouping", {
        main: a,
        transform: s,
        containerWidth: a.width,
        iconWidth: a.width
      })), r.push(f || a.icon), {
        children: r,
        attributes: o
      };
    };
  }
}, SH = {
  mixout: function() {
    return {
      layer: function(n) {
        var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o = r.classes, a = o === void 0 ? [] : o;
        return dm({
          type: "layer"
        }, function() {
          Ga("beforeDOMElementCreation", {
            assembler: n,
            params: r
          });
          var s = [];
          return n(function(u) {
            Array.isArray(u) ? u.map(function(c) {
              s = s.concat(c.abstract);
            }) : s = s.concat(u.abstract);
          }), [{
            tag: "span",
            attributes: {
              class: ["".concat(Ae.cssPrefix, "-layers")].concat(Lr(a)).join(" ")
            },
            children: s
          }];
        });
      }
    };
  }
}, EH = {
  mixout: function() {
    return {
      counter: function(n) {
        var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        r.title;
        var o = r.classes, a = o === void 0 ? [] : o, s = r.attributes, u = s === void 0 ? {} : s, c = r.styles, f = c === void 0 ? {} : c;
        return dm({
          type: "counter",
          content: n
        }, function() {
          return Ga("beforeDOMElementCreation", {
            content: n,
            params: r
          }), nH({
            content: n.toString(),
            extra: {
              attributes: u,
              styles: f,
              classes: ["".concat(Ae.cssPrefix, "-layers-counter")].concat(Lr(a))
            }
          });
        });
      }
    };
  }
}, CH = {
  mixout: function() {
    return {
      text: function(n) {
        var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o = r.transform, a = o === void 0 ? lo : o, s = r.classes, u = s === void 0 ? [] : s, c = r.attributes, f = c === void 0 ? {} : c, h = r.styles, p = h === void 0 ? {} : h;
        return dm({
          type: "text",
          content: n
        }, function() {
          return Ga("beforeDOMElementCreation", {
            content: n,
            params: r
          }), Rk({
            content: n,
            transform: ge(ge({}, lo), a),
            extra: {
              attributes: f,
              styles: p,
              classes: ["".concat(Ae.cssPrefix, "-layers-text")].concat(Lr(u))
            }
          });
        });
      }
    };
  },
  provides: function(t) {
    t.generateLayersText = function(n, r) {
      var o = r.transform, a = r.extra, s = null, u = null;
      if (mO) {
        var c = parseInt(getComputedStyle(n).fontSize, 10), f = n.getBoundingClientRect();
        s = f.width / c, u = f.height / c;
      }
      return Promise.resolve([n, Rk({
        content: n.innerHTML,
        width: s,
        height: u,
        transform: o,
        extra: a,
        watchable: !0
      })]);
    };
  }
}, cN = new RegExp('"', "ug"), Ik = [1105920, 1112319], zk = ge(ge(ge(ge({}, {
  FontAwesome: {
    normal: "fas",
    400: "fas"
  }
}), h7), dB), _7), lb = Object.keys(zk).reduce(function(e, t) {
  return e[t.toLowerCase()] = zk[t], e;
}, {}), kH = Object.keys(lb).reduce(function(e, t) {
  var n = lb[t];
  return e[t] = n[900] || Lr(Object.entries(n))[0][1], e;
}, {});
function TH(e) {
  var t = e.replace(cN, "");
  return YO(Lr(t)[0] || "");
}
function AH(e) {
  var t = e.getPropertyValue("font-feature-settings").includes("ss01"), n = e.getPropertyValue("content"), r = n.replace(cN, ""), o = r.codePointAt(0), a = o >= Ik[0] && o <= Ik[1], s = r.length === 2 ? r[0] === r[1] : !1;
  return a || s || t;
}
function RH(e, t) {
  var n = e.replace(/^['"]|['"]$/g, "").toLowerCase(), r = parseInt(t), o = isNaN(r) ? "normal" : r;
  return (lb[n] || {})[o] || kH[n];
}
function Lk(e, t) {
  var n = "".concat(hB).concat(t.replace(":", "-"));
  return new Promise(function(r, o) {
    if (e.getAttribute(n) !== null)
      return r();
    var a = Il(e.children), s = a.filter(function(N) {
      return N.getAttribute(Qv) === t;
    })[0], u = ta.getComputedStyle(e, t), c = u.getPropertyValue("font-family"), f = c.match(vB), h = u.getPropertyValue("font-weight"), p = u.getPropertyValue("content");
    if (s && !f)
      return e.removeChild(s), r();
    if (f && p !== "none" && p !== "") {
      var g = u.getPropertyValue("content"), y = RH(c, h), w = TH(g), v = f[0].startsWith("FontAwesome"), S = AH(u), E = $1(y, w), T = E;
      if (v) {
        var k = FB(w);
        k.iconName && k.prefix && (E = k.iconName, y = k.prefix);
      }
      if (E && !S && (!s || s.getAttribute(j1) !== y || s.getAttribute(I1) !== T)) {
        e.setAttribute(n, T), s && e.removeChild(s);
        var A = gH(), M = A.extra;
        M.attributes[Qv] = t, ib(E, y).then(function(N) {
          var P = B1(ge(ge({}, A), {}, {
            icons: {
              main: N,
              mask: rN()
            },
            prefix: y,
            iconName: T,
            extra: M,
            watchable: !0
          })), z = _t.createElementNS("http://www.w3.org/2000/svg", "svg");
          t === "::before" ? e.insertBefore(z, e.firstChild) : e.appendChild(z), z.outerHTML = P.map(function(B) {
            return af(B);
          }).join(`
`), e.removeAttribute(n), r();
        }).catch(o);
      } else
        r();
    } else
      r();
  });
}
function MH(e) {
  return Promise.all([Lk(e, "::before"), Lk(e, "::after")]);
}
function OH(e) {
  return e.parentNode !== document.head && !~mB.indexOf(e.tagName.toUpperCase()) && !e.getAttribute(Qv) && (!e.parentNode || e.parentNode.tagName !== "svg");
}
var NH = function(t) {
  return !!t && zO.some(function(n) {
    return t.includes(n);
  });
}, DH = function(t) {
  if (!t) return [];
  for (var n = /* @__PURE__ */ new Set(), r = [t], o = [/(?=\s:)/, /(?<=\)\)?[^,]*,)/], a = function() {
    var y = u[s];
    r = r.flatMap(function(w) {
      return w.split(y).map(function(v) {
        return v.replace(/,\s*$/, "").trim();
      });
    });
  }, s = 0, u = o; s < u.length; s++)
    a();
  r = r.flatMap(function(g) {
    return g.includes("(") ? g : g.split(",").map(function(y) {
      return y.trim();
    });
  });
  var c = Ph(r), f;
  try {
    for (c.s(); !(f = c.n()).done; ) {
      var h = f.value;
      if (NH(h)) {
        var p = zO.reduce(function(g, y) {
          return g.replace(y, "");
        }, h);
        p !== "" && p !== "*" && n.add(p);
      }
    }
  } catch (g) {
    c.e(g);
  } finally {
    c.f();
  }
  return n;
};
function Fk(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  if (ui) {
    var n;
    if (t)
      n = e;
    else if (Ae.searchPseudoElementsFullScan)
      n = e.querySelectorAll("*");
    else {
      var r = /* @__PURE__ */ new Set(), o = Ph(document.styleSheets), a;
      try {
        for (o.s(); !(a = o.n()).done; ) {
          var s = a.value;
          try {
            var u = Ph(s.cssRules), c;
            try {
              for (u.s(); !(c = u.n()).done; ) {
                var f = c.value, h = DH(f.selectorText), p = Ph(h), g;
                try {
                  for (p.s(); !(g = p.n()).done; ) {
                    var y = g.value;
                    r.add(y);
                  }
                } catch (v) {
                  p.e(v);
                } finally {
                  p.f();
                }
              }
            } catch (v) {
              u.e(v);
            } finally {
              u.f();
            }
          } catch (v) {
            Ae.searchPseudoElementsWarnings && console.warn("Font Awesome: cannot parse stylesheet: ".concat(s.href, " (").concat(v.message, `)
If it declares any Font Awesome CSS pseudo-elements, they will not be rendered as SVG icons. Add crossorigin="anonymous" to the <link>, enable searchPseudoElementsFullScan for slower but more thorough DOM parsing, or suppress this warning by setting searchPseudoElementsWarnings to false.`));
          }
        }
      } catch (v) {
        o.e(v);
      } finally {
        o.f();
      }
      if (!r.size) return;
      var w = Array.from(r).join(", ");
      try {
        n = e.querySelectorAll(w);
      } catch {
      }
    }
    return new Promise(function(v, S) {
      var E = Il(n).filter(OH).map(MH), T = H1.begin("searchPseudoElements");
      lN(), Promise.all(E).then(function() {
        T(), sb(), v();
      }).catch(function() {
        T(), sb(), S();
      });
    });
  }
}
var PH = {
  hooks: function() {
    return {
      mutationObserverCallbacks: function(n) {
        return n.pseudoElementsCallback = Fk, n;
      }
    };
  },
  provides: function(t) {
    t.pseudoElements2svg = function(n) {
      var r = n.node, o = r === void 0 ? _t : r;
      Ae.searchPseudoElements && Fk(o);
    };
  }
}, $k = !1, jH = {
  mixout: function() {
    return {
      dom: {
        unwatch: function() {
          lN(), $k = !0;
        }
      }
    };
  },
  hooks: function() {
    return {
      bootstrap: function() {
        Dk(nb("mutationObserverCallbacks", {}));
      },
      noAuto: function() {
        dH();
      },
      watch: function(n) {
        var r = n.observeMutationsRoot;
        $k ? sb() : Dk(nb("mutationObserverCallbacks", {
          observeMutationsRoot: r
        }));
      }
    };
  }
}, Bk = function(t) {
  var n = {
    size: 16,
    x: 0,
    y: 0,
    flipX: !1,
    flipY: !1,
    rotate: 0
  };
  return t.toLowerCase().split(" ").reduce(function(r, o) {
    var a = o.toLowerCase().split("-"), s = a[0], u = a.slice(1).join("-");
    if (s && u === "h")
      return r.flipX = !0, r;
    if (s && u === "v")
      return r.flipY = !0, r;
    if (u = parseFloat(u), isNaN(u))
      return r;
    switch (s) {
      case "grow":
        r.size = r.size + u;
        break;
      case "shrink":
        r.size = r.size - u;
        break;
      case "left":
        r.x = r.x - u;
        break;
      case "right":
        r.x = r.x + u;
        break;
      case "up":
        r.y = r.y - u;
        break;
      case "down":
        r.y = r.y + u;
        break;
      case "rotate":
        r.rotate = r.rotate + u;
        break;
    }
    return r;
  }, n);
}, IH = {
  mixout: function() {
    return {
      parse: {
        transform: function(n) {
          return Bk(n);
        }
      }
    };
  },
  hooks: function() {
    return {
      parseNodeAttributes: function(n, r) {
        var o = r.getAttribute("data-fa-transform");
        return o && (n.transform = Bk(o)), n;
      }
    };
  },
  provides: function(t) {
    t.generateAbstractTransformGrouping = function(n) {
      var r = n.main, o = n.transform, a = n.containerWidth, s = n.iconWidth, u = {
        transform: "translate(".concat(a / 2, " 256)")
      }, c = "translate(".concat(o.x * 32, ", ").concat(o.y * 32, ") "), f = "scale(".concat(o.size / 16 * (o.flipX ? -1 : 1), ", ").concat(o.size / 16 * (o.flipY ? -1 : 1), ") "), h = "rotate(".concat(o.rotate, " 0 0)"), p = {
        transform: "".concat(c, " ").concat(f, " ").concat(h)
      }, g = {
        transform: "translate(".concat(s / 2 * -1, " -256)")
      }, y = {
        outer: u,
        inner: p,
        path: g
      };
      return {
        tag: "g",
        attributes: ge({}, y.outer),
        children: [{
          tag: "g",
          attributes: ge({}, y.inner),
          children: [{
            tag: r.icon.tag,
            children: r.icon.children,
            attributes: ge(ge({}, r.icon.attributes), y.path)
          }]
        }]
      };
    };
  }
}, Vy = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function Hk(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return e.attributes && (e.attributes.fill || t) && (e.attributes.fill = "black"), e;
}
function zH(e) {
  return e.tag === "g" ? e.children : [e];
}
var LH = {
  hooks: function() {
    return {
      parseNodeAttributes: function(n, r) {
        var o = r.getAttribute("data-fa-mask"), a = o ? fm(o.split(" ").map(function(s) {
          return s.trim();
        })) : rN();
        return a.prefix || (a.prefix = na()), n.mask = a, n.maskId = r.getAttribute("data-fa-mask-id"), n;
      }
    };
  },
  provides: function(t) {
    t.generateAbstractMask = function(n) {
      var r = n.children, o = n.attributes, a = n.main, s = n.mask, u = n.maskId, c = n.transform, f = a.width, h = a.icon, p = s.width, g = s.icon, y = RB({
        transform: c,
        containerWidth: p,
        iconWidth: f
      }), w = {
        tag: "rect",
        attributes: ge(ge({}, Vy), {}, {
          fill: "white"
        })
      }, v = h.children ? {
        children: h.children.map(Hk)
      } : {}, S = {
        tag: "g",
        attributes: ge({}, y.inner),
        children: [Hk(ge({
          tag: h.tag,
          attributes: ge(ge({}, h.attributes), y.path)
        }, v))]
      }, E = {
        tag: "g",
        attributes: ge({}, y.outer),
        children: [S]
      }, T = "mask-".concat(u || _k()), k = "clip-".concat(u || _k()), A = {
        tag: "mask",
        attributes: ge(ge({}, Vy), {}, {
          id: T,
          maskUnits: "userSpaceOnUse",
          maskContentUnits: "userSpaceOnUse"
        }),
        children: [w, E]
      }, M = {
        tag: "defs",
        children: [{
          tag: "clipPath",
          attributes: {
            id: k
          },
          children: zH(g)
        }, A]
      };
      return r.push(M, {
        tag: "rect",
        attributes: ge({
          fill: "currentColor",
          "clip-path": "url(#".concat(k, ")"),
          mask: "url(#".concat(T, ")")
        }, Vy)
      }), {
        children: r,
        attributes: o
      };
    };
  }
}, FH = {
  provides: function(t) {
    var n = !1;
    ta.matchMedia && (n = ta.matchMedia("(prefers-reduced-motion: reduce)").matches), t.missingIconAbstract = function() {
      var r = [], o = {
        fill: "currentColor"
      }, a = {
        attributeType: "XML",
        repeatCount: "indefinite",
        dur: "2s"
      };
      r.push({
        tag: "path",
        attributes: ge(ge({}, o), {}, {
          d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
        })
      });
      var s = ge(ge({}, a), {}, {
        attributeName: "opacity"
      }), u = {
        tag: "circle",
        attributes: ge(ge({}, o), {}, {
          cx: "256",
          cy: "364",
          r: "28"
        }),
        children: []
      };
      return n || u.children.push({
        tag: "animate",
        attributes: ge(ge({}, a), {}, {
          attributeName: "r",
          values: "28;14;28;28;14;28;"
        })
      }, {
        tag: "animate",
        attributes: ge(ge({}, s), {}, {
          values: "1;0;1;1;0;1;"
        })
      }), r.push(u), r.push({
        tag: "path",
        attributes: ge(ge({}, o), {}, {
          opacity: "1",
          d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
        }),
        children: n ? [] : [{
          tag: "animate",
          attributes: ge(ge({}, s), {}, {
            values: "1;0;0;0;0;1;"
          })
        }]
      }), n || r.push({
        tag: "path",
        attributes: ge(ge({}, o), {}, {
          opacity: "0",
          d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
        }),
        children: [{
          tag: "animate",
          attributes: ge(ge({}, s), {}, {
            values: "0;0;1;1;0;0;"
          })
        }]
      }), {
        tag: "g",
        attributes: {
          class: "missing"
        },
        children: r
      };
    };
  }
}, $H = {
  hooks: function() {
    return {
      parseNodeAttributes: function(n, r) {
        var o = r.getAttribute("data-fa-symbol"), a = o === null ? !1 : o === "" ? !0 : o;
        return n.symbol = a, n;
      }
    };
  }
}, BH = [NB, _H, SH, EH, CH, PH, jH, IH, LH, FH, $H];
WB(BH, {
  mixoutsTo: ur
});
ur.noAuto;
var HH = ur.config;
ur.library;
ur.dom;
var ub = ur.parse;
ur.findIconDefinition;
ur.toHtml;
var VH = ur.icon;
ur.layer;
ur.text;
ur.counter;
function cb(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function UH(e) {
  if (Array.isArray(e)) return e;
}
function qH(e) {
  if (Array.isArray(e)) return cb(e);
}
function Yi(e, t, n) {
  return (t = JH(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function GH(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function YH(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r, o, a, s, u = [], c = !0, f = !1;
    try {
      if (a = (n = n.call(e)).next, t !== 0) for (; !(c = (r = a.call(n)).done) && (u.push(r.value), u.length !== t); c = !0) ;
    } catch (h) {
      f = !0, o = h;
    } finally {
      try {
        if (!c && n.return != null && (s = n.return(), Object(s) !== s)) return;
      } finally {
        if (f) throw o;
      }
    }
    return u;
  }
}
function WH() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function XH() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Vk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function io(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Vk(Object(n), !0).forEach(function(r) {
      Yi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Vk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function KH(e, t) {
  if (e == null) return {};
  var n, r, o = ZH(e, t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    for (r = 0; r < a.length; r++) n = a[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
function ZH(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function Uk(e, t) {
  return UH(e) || YH(e, t) || fN(e, t) || WH();
}
function fb(e) {
  return qH(e) || GH(e) || fN(e) || XH();
}
function QH(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function JH(e) {
  var t = QH(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function np(e) {
  "@babel/helpers - typeof";
  return np = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, np(e);
}
function fN(e, t) {
  if (e) {
    if (typeof e == "string") return cb(e, t);
    var n = {}.toString.call(e).slice(8, -1);
    return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? cb(e, t) : void 0;
  }
}
var eV = "7.0.0-alpha1", db;
try {
  var tV = require("@fortawesome/fontawesome-svg-core/package.json");
  db = tV.version;
} catch {
  db = "7.0.0";
}
function nV(e) {
  var t = e.beat, n = e.fade, r = e.beatFade, o = e.bounce, a = e.shake, s = e.flash, u = e.spin, c = e.spinPulse, f = e.spinReverse, h = e.pulse, p = e.fixedWidth, g = e.inverse, y = e.border, w = e.listItem, v = e.flip, S = e.size, E = e.rotation, T = e.pull, k = e.swapOpacity, A = e.rotateBy, M = e.widthAuto, N = rV(db, eV), P = Yi(Yi(Yi(Yi(Yi(Yi({
    "fa-beat": t,
    "fa-fade": n,
    "fa-beat-fade": r,
    "fa-bounce": o,
    "fa-shake": a,
    "fa-flash": s,
    "fa-spin": u,
    "fa-spin-reverse": f,
    "fa-spin-pulse": c,
    "fa-pulse": h,
    "fa-fw": p,
    "fa-inverse": g,
    "fa-border": y,
    "fa-li": w,
    "fa-flip": v === !0,
    "fa-flip-horizontal": v === "horizontal" || v === "both",
    "fa-flip-vertical": v === "vertical" || v === "both"
  }, "fa-".concat(S), typeof S < "u" && S !== null), "fa-rotate-".concat(E), typeof E < "u" && E !== null && E !== 0), "fa-pull-".concat(T), typeof T < "u" && T !== null), "fa-swap-opacity", k), "fa-rotate-by", N && A), "fa-width-auto", N && M);
  return Object.keys(P).map(function(z) {
    return P[z] ? z : null;
  }).filter(function(z) {
    return z;
  });
}
function rV(e, t) {
  for (var n = e.split("-"), r = Uk(n, 2), o = r[0], a = r[1], s = t.split("-"), u = Uk(s, 2), c = u[0], f = u[1], h = o.split("."), p = c.split("."), g = 0; g < Math.max(h.length, p.length); g++) {
    var y = h[g] || "0", w = p[g] || "0", v = parseInt(y, 10), S = parseInt(w, 10);
    if (v !== S)
      return v > S;
  }
  for (var E = 0; E < Math.max(h.length, p.length); E++) {
    var T = h[E] || "0", k = p[E] || "0";
    if (T !== k && T.length !== k.length)
      return T.length < k.length;
  }
  return !(a && !f);
}
function oV(e) {
  return e = e - 0, e === e;
}
function dN(e) {
  return oV(e) ? e : (e = e.replace(/[\-_\s]+(.)?/g, function(t, n) {
    return n ? n.toUpperCase() : "";
  }), e.substr(0, 1).toLowerCase() + e.substr(1));
}
var iV = ["style"];
function aV(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
function sV(e) {
  return e.split(";").map(function(t) {
    return t.trim();
  }).filter(function(t) {
    return t;
  }).reduce(function(t, n) {
    var r = n.indexOf(":"), o = dN(n.slice(0, r)), a = n.slice(r + 1).trim();
    return o.startsWith("webkit") ? t[aV(o)] = a : t[o] = a, t;
  }, {});
}
function hN(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof t == "string")
    return t;
  var r = (t.children || []).map(function(c) {
    return hN(e, c);
  }), o = Object.keys(t.attributes || {}).reduce(function(c, f) {
    var h = t.attributes[f];
    switch (f) {
      case "class":
        c.attrs.className = h, delete t.attributes.class;
        break;
      case "style":
        c.attrs.style = sV(h);
        break;
      default:
        f.indexOf("aria-") === 0 || f.indexOf("data-") === 0 ? c.attrs[f.toLowerCase()] = h : c.attrs[dN(f)] = h;
    }
    return c;
  }, {
    attrs: {}
  }), a = n.style, s = a === void 0 ? {} : a, u = KH(n, iV);
  return o.attrs.style = io(io({}, o.attrs.style), s), e.apply(void 0, [t.tag, io(io({}, o.attrs), u)].concat(fb(r)));
}
var pN = !1;
try {
  pN = !0;
} catch {
}
function lV() {
  if (!pN && console && typeof console.error == "function") {
    var e;
    (e = console).error.apply(e, arguments);
  }
}
function qk(e) {
  if (e && np(e) === "object" && e.prefix && e.iconName && e.icon)
    return e;
  if (ub.icon)
    return ub.icon(e);
  if (e === null)
    return null;
  if (e && np(e) === "object" && e.prefix && e.iconName)
    return e;
  if (Array.isArray(e) && e.length === 2)
    return {
      prefix: e[0],
      iconName: e[1]
    };
  if (typeof e == "string")
    return {
      prefix: "fas",
      iconName: e
    };
}
function Uy(e, t) {
  return Array.isArray(t) && t.length > 0 || !Array.isArray(t) && t ? Yi({}, e, t) : {};
}
var Gk = {
  border: !1,
  className: "",
  mask: null,
  maskId: null,
  // the fixedWidth property has been deprecated as of version 7
  fixedWidth: !1,
  inverse: !1,
  flip: !1,
  icon: null,
  listItem: !1,
  pull: null,
  pulse: !1,
  rotation: null,
  rotateBy: !1,
  size: null,
  spin: !1,
  spinPulse: !1,
  spinReverse: !1,
  beat: !1,
  fade: !1,
  beatFade: !1,
  bounce: !1,
  shake: !1,
  symbol: !1,
  title: "",
  titleId: null,
  transform: null,
  swapOpacity: !1,
  widthAuto: !1
}, U1 = /* @__PURE__ */ nn.forwardRef(function(e, t) {
  var n = io(io({}, Gk), e), r = n.icon, o = n.mask, a = n.symbol, s = n.className, u = n.title, c = n.titleId, f = n.maskId, h = qk(r), p = Uy("classes", [].concat(fb(nV(n)), fb((s || "").split(" ")))), g = Uy("transform", typeof n.transform == "string" ? ub.transform(n.transform) : n.transform), y = Uy("mask", qk(o)), w = VH(h, io(io(io(io({}, p), g), y), {}, {
    symbol: a,
    title: u,
    titleId: c,
    maskId: f
  }));
  if (!w)
    return lV("Could not find icon", h), null;
  var v = w.abstract, S = {
    ref: t
  };
  return Object.keys(n).forEach(function(E) {
    Gk.hasOwnProperty(E) || (S[E] = n[E]);
  }), uV(v[0], S);
});
U1.displayName = "FontAwesomeIcon";
U1.propTypes = {
  beat: Ve.bool,
  border: Ve.bool,
  beatFade: Ve.bool,
  bounce: Ve.bool,
  className: Ve.string,
  fade: Ve.bool,
  flash: Ve.bool,
  mask: Ve.oneOfType([Ve.object, Ve.array, Ve.string]),
  maskId: Ve.string,
  // the fixedWidth property has been deprecated as of version 7
  fixedWidth: Ve.bool,
  inverse: Ve.bool,
  flip: Ve.oneOf([!0, !1, "horizontal", "vertical", "both"]),
  icon: Ve.oneOfType([Ve.object, Ve.array, Ve.string]),
  listItem: Ve.bool,
  pull: Ve.oneOf(["right", "left"]),
  pulse: Ve.bool,
  rotation: Ve.oneOf([0, 90, 180, 270]),
  rotateBy: Ve.bool,
  shake: Ve.bool,
  size: Ve.oneOf(["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"]),
  spin: Ve.bool,
  spinPulse: Ve.bool,
  spinReverse: Ve.bool,
  symbol: Ve.oneOfType([Ve.bool, Ve.string]),
  title: Ve.string,
  titleId: Ve.string,
  transform: Ve.oneOfType([Ve.string, Ve.object]),
  swapOpacity: Ve.bool,
  widthAuto: Ve.bool
};
var uV = hN.bind(null, nn.createElement);
/*!
 * Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2025 Fonticons, Inc.
 */
var cV = {
  prefix: "fas",
  iconName: "magnifying-glass",
  icon: [512, 512, [128269, "search"], "f002", "M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376C296.3 401.1 253.9 416 208 416 93.1 416 0 322.9 0 208S93.1 0 208 0 416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"]
}, fV = {
  prefix: "fas",
  iconName: "chevron-up",
  icon: [448, 512, [], "f077", "M201.4 105.4c12.5-12.5 32.8-12.5 45.3 0l192 192c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L224 173.3 54.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l192-192z"]
}, dV = {
  prefix: "fas",
  iconName: "expand",
  icon: [448, 512, [], "f065", "M32 32C14.3 32 0 46.3 0 64l0 96c0 17.7 14.3 32 32 32s32-14.3 32-32l0-64 64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L32 32zM64 352c0-17.7-14.3-32-32-32S0 334.3 0 352l0 96c0 17.7 14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-64zM320 32c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0 0 64c0 17.7 14.3 32 32 32s32-14.3 32-32l0-96c0-17.7-14.3-32-32-32l-96 0zM448 352c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 64-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32l0-96z"]
}, hV = {
  prefix: "fas",
  iconName: "chevron-right",
  icon: [320, 512, [9002], "f054", "M311.1 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L243.2 256 73.9 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z"]
}, pV = {
  prefix: "fas",
  iconName: "circle-xmark",
  icon: [512, 512, [61532, "times-circle", "xmark-circle"], "f057", "M256 512a256 256 0 1 0 0-512 256 256 0 1 0 0 512zM167 167c9.4-9.4 24.6-9.4 33.9 0l55 55 55-55c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-55 55 55 55c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-55-55-55 55c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l55-55-55-55c-9.4-9.4-9.4-24.6 0-33.9z"]
}, mV = {
  prefix: "fas",
  iconName: "network-wired",
  icon: [576, 512, [], "f6ff", "M248 88l80 0 0 48-80 0 0-48zm-8-56c-26.5 0-48 21.5-48 48l0 64c0 26.5 21.5 48 48 48l16 0 0 32-224 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0 0 32-16 0c-26.5 0-48 21.5-48 48l0 64c0 26.5 21.5 48 48 48l96 0c26.5 0 48-21.5 48-48l0-64c0-26.5-21.5-48-48-48l-16 0 0-32 192 0 0 32-16 0c-26.5 0-48 21.5-48 48l0 64c0 26.5 21.5 48 48 48l96 0c26.5 0 48-21.5 48-48l0-64c0-26.5-21.5-48-48-48l-16 0 0-32 96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-224 0 0-32 16 0c26.5 0 48-21.5 48-48l0-64c0-26.5-21.5-48-48-48l-96 0zM448 376l8 0 0 48-80 0 0-48 72 0zm-256 0l8 0 0 48-80 0 0-48 72 0z"]
}, gV = {
  prefix: "fas",
  iconName: "gear",
  icon: [512, 512, [9881, "cog"], "f013", "M195.1 9.5C198.1-5.3 211.2-16 226.4-16l59.8 0c15.2 0 28.3 10.7 31.3 25.5L332 79.5c14.1 6 27.3 13.7 39.3 22.8l67.8-22.5c14.4-4.8 30.2 1.2 37.8 14.4l29.9 51.8c7.6 13.2 4.9 29.8-6.5 39.9L447 233.3c.9 7.4 1.3 15 1.3 22.7s-.5 15.3-1.3 22.7l53.4 47.5c11.4 10.1 14 26.8 6.5 39.9l-29.9 51.8c-7.6 13.1-23.4 19.2-37.8 14.4l-67.8-22.5c-12.1 9.1-25.3 16.7-39.3 22.8l-14.4 69.9c-3.1 14.9-16.2 25.5-31.3 25.5l-59.8 0c-15.2 0-28.3-10.7-31.3-25.5l-14.4-69.9c-14.1-6-27.2-13.7-39.3-22.8L73.5 432.3c-14.4 4.8-30.2-1.2-37.8-14.4L5.8 366.1c-7.6-13.2-4.9-29.8 6.5-39.9l53.4-47.5c-.9-7.4-1.3-15-1.3-22.7s.5-15.3 1.3-22.7L12.3 185.8c-11.4-10.1-14-26.8-6.5-39.9L35.7 94.1c7.6-13.2 23.4-19.2 37.8-14.4l67.8 22.5c12.1-9.1 25.3-16.7 39.3-22.8L195.1 9.5zM256.3 336a80 80 0 1 0 -.6-160 80 80 0 1 0 .6 160z"]
}, yV = {
  prefix: "fas",
  iconName: "up-right-and-down-left-from-center",
  icon: [512, 512, ["expand-alt"], "f424", "M344 0L488 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39-87 87c-9.4 9.4-24.6 9.4-33.9 0l-32-32c-9.4-9.4-9.4-24.6 0-33.9l87-87-39-39c-6.9-6.9-8.9-17.2-5.2-26.2S334.3 0 344 0zM168 512L24 512c-13.3 0-24-10.7-24-24L0 344c0-9.7 5.8-18.5 14.8-22.2S34.1 320.2 41 327l39 39 87-87c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2S177.7 512 168 512z"]
}, vV = {
  prefix: "fas",
  iconName: "xmark",
  icon: [384, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M55.1 73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L147.2 256 9.9 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192.5 301.3 329.9 438.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.8 256 375.1 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192.5 210.7 55.1 73.4z"]
}, bV = {
  prefix: "fas",
  iconName: "lock-open",
  icon: [576, 512, [], "f3c1", "M384 96c0-35.3 28.7-64 64-64s64 28.7 64 64l0 32c0 17.7 14.3 32 32 32s32-14.3 32-32l0-32c0-70.7-57.3-128-128-128S320 25.3 320 96l0 64-160 0c-35.3 0-64 28.7-64 64l0 224c0 35.3 28.7 64 64 64l256 0c35.3 0 64-28.7 64-64l0-224c0-35.3-28.7-64-64-64l-32 0 0-64z"]
}, xV = {
  prefix: "fas",
  iconName: "circle-check",
  icon: [512, 512, [61533, "check-circle"], "f058", "M256 512a256 256 0 1 0 0-512 256 256 0 1 0 0 512zm84.4-299.3l-80 128c-4.2 6.7-11.4 10.9-19.3 11.3s-15.5-3.2-20.2-9.6l-48-64c-8-10.6-5.8-25.6 4.8-33.6s25.6-5.8 33.6 4.8l27 36 61.4-98.3c7-11.2 21.8-14.7 33.1-7.6s14.7 21.8 7.6 33.1z"]
}, wV = {
  prefix: "fas",
  iconName: "circle-play",
  icon: [512, 512, [61469, "play-circle"], "f144", "M0 256a256 256 0 1 1 512 0 256 256 0 1 1 -512 0zM188.3 147.1c-7.6 4.2-12.3 12.3-12.3 20.9l0 176c0 8.7 4.7 16.7 12.3 20.9s16.8 4.1 24.3-.5l144-88c7.1-4.4 11.5-12.1 11.5-20.5s-4.4-16.1-11.5-20.5l-144-88c-7.4-4.5-16.7-4.7-24.3-.5z"]
}, _V = {
  prefix: "fas",
  iconName: "chevron-down",
  icon: [448, 512, [], "f078", "M201.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 338.7 54.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"]
}, SV = {
  prefix: "fas",
  iconName: "chevron-left",
  icon: [320, 512, [9001], "f053", "M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l192 192c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256 246.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192z"]
}, EV = {
  prefix: "fas",
  iconName: "lock",
  icon: [384, 512, [128274], "f023", "M128 96l0 64 128 0 0-64c0-35.3-28.7-64-64-64s-64 28.7-64 64zM64 160l0-64C64 25.3 121.3-32 192-32S320 25.3 320 96l0 64c35.3 0 64 28.7 64 64l0 224c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64L0 224c0-35.3 28.7-64 64-64z"]
}, CV = {
  prefix: "fas",
  iconName: "down-left-and-up-right-to-center",
  icon: [512, 512, ["compress-alt"], "f422", "M439.5 7c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2S450.2 240 440.5 240l-144 0c-13.3 0-24-10.7-24-24l0-144c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2l39 39 87-87zM72.5 272l144 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39-87 87c-9.4 9.4-24.6 9.4-33.9 0l-32-32c-9.4-9.4-9.4-24.6 0-33.9l87-87-39-39c-6.9-6.9-8.9-17.2-5.2-26.2S62.8 272 72.5 272z"]
}, kV = {
  prefix: "fas",
  iconName: "compress",
  icon: [448, 512, [], "f066", "M160 64c0-17.7-14.3-32-32-32S96 46.3 96 64l0 64-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32l0-96zM32 320c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0 0 64c0 17.7 14.3 32 32 32s32-14.3 32-32l0-96c0-17.7-14.3-32-32-32l-96 0zM352 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-64zM320 320c-17.7 0-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32s32-14.3 32-32l0-64 64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-96 0z"]
}, TV = {
  prefix: "fas",
  iconName: "bars",
  icon: [448, 512, ["navicon"], "f0c9", "M0 96C0 78.3 14.3 64 32 64l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 128C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 288c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32L32 448c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"]
};
HH.autoAddCss = !1;
const rn = (e) => {
  const { style: t, ...n } = e;
  return /* @__PURE__ */ x.jsx("span", { style: t, children: /* @__PURE__ */ x.jsx(U1, { ...n }) });
}, q1 = (e) => /* @__PURE__ */ x.jsx(rn, { ...e, icon: TV }), Nc = (e) => /* @__PURE__ */ x.jsx(rn, { ...e, icon: hV }), rp = (e) => /* @__PURE__ */ x.jsx(rn, { ...e, icon: SV }), mN = (e) => /* @__PURE__ */ x.jsx(rn, { ...e, icon: dV }), AV = (e) => /* @__PURE__ */ x.jsx(rn, { ...e, icon: kV }), RV = (e) => /* @__PURE__ */ x.jsx(rn, { ...e, icon: CV }), MV = (e) => /* @__PURE__ */ x.jsx(rn, { ...e, icon: yV }), op = (e) => /* @__PURE__ */ x.jsx(rn, { ...e, icon: _V }), Dc = (e) => /* @__PURE__ */ x.jsx(rn, { ...e, icon: fV }), sf = Dc, hm = (e) => /* @__PURE__ */ x.jsx(rn, { ...e, icon: vV }), OV = (e) => /* @__PURE__ */ x.jsx(rn, { ...e, icon: bV }), NV = (e) => /* @__PURE__ */ x.jsx(rn, { ...e, icon: EV }), DV = (e) => /* @__PURE__ */ x.jsx(rn, { ...e, icon: mV }), PV = (e) => /* @__PURE__ */ x.jsx(rn, { ...e, icon: wV }), jV = (e) => /* @__PURE__ */ x.jsx(rn, { ...e, icon: cV }), IV = (e) => /* @__PURE__ */ x.jsx(rn, { ...e, icon: gV }), zV = (e) => /* @__PURE__ */ x.jsx(rn, { ...e, icon: xV }), LV = (e) => /* @__PURE__ */ x.jsx(rn, { ...e, icon: pV }), gN = _.createContext(null), nt = () => {
  const e = _.useContext(gN);
  if (!e)
    throw new Error(
      "useFuncNodesContext must be used within a FuncNodesContext.Provider"
    );
  return e;
}, yN = _.createContext(
  void 0
), G1 = () => {
  const e = _.useContext(yN);
  if (!e)
    throw new Error("useKeyPress must be used within a KeyPressProvider");
  return e;
}, FV = ({
  children: e,
  preventDefault: t = !1,
  ignoredKeys: n = [],
  debug: r = !1,
  target: o
}) => {
  const [a, s] = _.useState(/* @__PURE__ */ new Set()), u = _.useMemo(
    () => new Set(n),
    [n]
  ), c = _.useRef(a);
  c.current = a;
  const f = _.useMemo(
    () => ({
      keys: a,
      isKeyPressed: (h) => a.has(h),
      areKeysPressed: (...h) => h.every((p) => a.has(p)),
      isAnyKeyPressed: (...h) => h.some((p) => a.has(p))
    }),
    [a]
  );
  return _.useEffect(() => {
    const h = o ?? window;
    if (!h) return;
    const p = (v) => {
      const S = v.key;
      u.has(S) || (t && v.preventDefault(), c.current.has(S) || (r && console.log(`[KeyPress] Key down: ${S}`), s((E) => {
        const T = new Set(E);
        return T.add(S), T;
      })));
    }, g = (v) => {
      const S = v.key;
      c.current.has(S) && (r && console.log(`[KeyPress] Key up: ${S}`), s((E) => {
        const T = new Set(E);
        return T.delete(S), T;
      }));
    }, y = () => {
      c.current.size > 0 && (r && console.log("[KeyPress] Window blur - clearing all keys"), s(/* @__PURE__ */ new Set()));
    }, w = () => {
      document.hidden && c.current.size > 0 && (r && console.log("[KeyPress] Tab hidden - clearing all keys"), s(/* @__PURE__ */ new Set()));
    };
    return h.addEventListener("keydown", p), h.addEventListener("keyup", g), h.addEventListener("blur", y), document.addEventListener("visibilitychange", w), () => {
      h.removeEventListener("keydown", p), h.removeEventListener("keyup", g), h.removeEventListener("blur", y), document.removeEventListener("visibilitychange", w);
    };
  }, [t, u, r, o]), /* @__PURE__ */ x.jsx(yN.Provider, { value: f, children: e });
}, vN = _.createContext({
  colorTheme: "classic",
  setColorTheme: () => {
  },
  previewColorTheme: () => {
  }
}), $V = ({
  available_themes: e,
  children: t,
  default_theme: n
}) => {
  const r = _.useMemo(
    () => new Set(e),
    [e]
  ), [o, a] = _.useState(
    n ?? e[0]
  ), s = _.useCallback(
    (f) => {
      if (!r.has(f))
        throw new Error(
          `Theme "${f}" is not in available_themes: [${Array.from(
            r
          ).join(", ")}]`
        );
      a(f);
      const h = {
        colorTheme: f
      };
      try {
        localStorage.setItem("theme", JSON.stringify(h));
      } catch (p) {
        console.warn("Failed to save theme to localStorage:", p);
      }
    },
    [r]
  ), u = _.useCallback(
    (f) => {
      if (!r.has(f))
        throw new Error(
          `Theme "${f}" is not in available_themes: [${Array.from(
            r
          ).join(", ")}]`
        );
      a(f);
    },
    [r]
  );
  _.useEffect(() => {
    document.documentElement.setAttribute("fn-data-color-theme", o);
  }, [o]), _.useEffect(() => {
    try {
      const f = localStorage.getItem("theme");
      if (!f) return;
      const h = JSON.parse(f);
      h.colorTheme && r.has(h.colorTheme) && a(h.colorTheme);
    } catch (f) {
      console.warn("Failed to load theme from localStorage:", f);
    }
  }, [r]), _.useEffect(() => {
    if (n && !r.has(n)) {
      const f = Array.from(r)[0];
      f && s(f);
    }
  }, [r, n, s]), _.useEffect(() => {
    if (!r.has(o)) {
      const f = Array.from(r)[0];
      f && s(f);
    }
  }, [o, r, s]);
  const c = _.useMemo(
    () => ({
      colorTheme: o,
      setColorTheme: s,
      previewColorTheme: u
    }),
    [o, s, u]
  );
  return /* @__PURE__ */ x.jsx(vN.Provider, { value: c, children: t });
}, bN = () => {
  const e = _.useContext(vN);
  if (!e)
    throw new Error("useTheme must be used within a ThemeProvider");
  return e;
}, xN = _.memo(({ button: e, index: t }) => {
  const n = _.useCallback(
    (o) => {
      o.preventDefault(), e.onClick(o);
    },
    [e]
  ), r = /* @__PURE__ */ x.jsx(
    "button",
    {
      className: `dialog-send-button ${e.className || ""}`,
      onClick: n,
      disabled: e.disabled,
      "aria-label": e.ariaLabel,
      type: "button",
      children: e.text
    }
  );
  return e.close !== !1 ? /* @__PURE__ */ x.jsx(cO, { asChild: !0, children: r }, t) : /* @__PURE__ */ x.jsx(_.Fragment, { children: r }, t);
});
xN.displayName = "DialogButton";
const ci = _.memo(
  ({
    trigger: e,
    title: t,
    description: n,
    children: r,
    closebutton: o = !0,
    onOpenChange: a,
    buttons: s = [],
    open: u,
    setOpen: c,
    modal: f = !0,
    dialogClassName: h = "default-dialog-content",
    ariaLabel: p,
    ariaDescription: g
  }) => {
    const w = nt().local_state((T) => T.funcnodescontainerRef), v = _.useMemo(
      () => `dialog-content funcnodescontainer ${h}`,
      [h]
    ), S = _.useCallback(
      (T) => {
        try {
          c?.(T), a?.(T);
        } catch (k) {
          console.error("Error in dialog open change handler:", k);
        }
      },
      [c, a]
    ), E = _.useMemo(
      () => s.map((T, k) => /* @__PURE__ */ x.jsx(
        xN,
        {
          button: T,
          index: k
        },
        `${T.text}-${k}`
      )),
      [s]
    );
    return /* @__PURE__ */ x.jsxs(M$, { open: u, onOpenChange: S, modal: f, children: [
      e && /* @__PURE__ */ x.jsx(O$, { asChild: !0, children: e }),
      /* @__PURE__ */ x.jsxs(N$, { container: w, children: [
        /* @__PURE__ */ x.jsx(D$, { className: "dialog-overlay funcnodescontainer" }),
        /* @__PURE__ */ x.jsx(P$, { asChild: !0, children: /* @__PURE__ */ x.jsxs(
          "div",
          {
            className: v,
            role: "dialog",
            "aria-label": p || t,
            "aria-description": g || (typeof n == "string" ? n : void 0),
            children: [
              t && /* @__PURE__ */ x.jsx(j$, { className: "dialog-title", id: "dialog-title", children: t }),
              n && /* @__PURE__ */ x.jsx(
                I$,
                {
                  className: "dialog-description",
                  id: "dialog-description",
                  children: n
                }
              ),
              /* @__PURE__ */ x.jsx("div", { className: "dialog-children", role: "main", children: r }),
              s.length > 0 && /* @__PURE__ */ x.jsx(
                "div",
                {
                  className: "dialog-buttons",
                  role: "group",
                  "aria-label": "Dialog actions",
                  children: E
                }
              ),
              o && /* @__PURE__ */ x.jsx(cO, { asChild: !0, children: /* @__PURE__ */ x.jsx(
                "button",
                {
                  className: "dialog-close-button",
                  "aria-label": "Close dialog",
                  type: "button",
                  children: /* @__PURE__ */ x.jsx(hm, {})
                }
              ) })
            ]
          }
        ) })
      ] })
    ] });
  }
);
ci.displayName = "CustomDialog";
const BV = ["top", "right", "bottom", "left"], oa = Math.min, tr = Math.max, ip = Math.round, oh = Math.floor, mo = (e) => ({
  x: e,
  y: e
}), HV = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, VV = {
  start: "end",
  end: "start"
};
function hb(e, t, n) {
  return tr(e, oa(t, n));
}
function ii(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function ai(e) {
  return e.split("-")[0];
}
function zl(e) {
  return e.split("-")[1];
}
function Y1(e) {
  return e === "x" ? "y" : "x";
}
function W1(e) {
  return e === "y" ? "height" : "width";
}
const UV = /* @__PURE__ */ new Set(["top", "bottom"]);
function uo(e) {
  return UV.has(ai(e)) ? "y" : "x";
}
function X1(e) {
  return Y1(uo(e));
}
function qV(e, t, n) {
  n === void 0 && (n = !1);
  const r = zl(e), o = X1(e), a = W1(o);
  let s = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[a] > t.floating[a] && (s = ap(s)), [s, ap(s)];
}
function GV(e) {
  const t = ap(e);
  return [pb(e), t, pb(t)];
}
function pb(e) {
  return e.replace(/start|end/g, (t) => VV[t]);
}
const Yk = ["left", "right"], Wk = ["right", "left"], YV = ["top", "bottom"], WV = ["bottom", "top"];
function XV(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? Wk : Yk : t ? Yk : Wk;
    case "left":
    case "right":
      return t ? YV : WV;
    default:
      return [];
  }
}
function KV(e, t, n, r) {
  const o = zl(e);
  let a = XV(ai(e), n === "start", r);
  return o && (a = a.map((s) => s + "-" + o), t && (a = a.concat(a.map(pb)))), a;
}
function ap(e) {
  return e.replace(/left|right|bottom|top/g, (t) => HV[t]);
}
function ZV(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function wN(e) {
  return typeof e != "number" ? ZV(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function sp(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: o
  } = e;
  return {
    width: r,
    height: o,
    top: n,
    left: t,
    right: t + r,
    bottom: n + o,
    x: t,
    y: n
  };
}
function Xk(e, t, n) {
  let {
    reference: r,
    floating: o
  } = e;
  const a = uo(t), s = X1(t), u = W1(s), c = ai(t), f = a === "y", h = r.x + r.width / 2 - o.width / 2, p = r.y + r.height / 2 - o.height / 2, g = r[u] / 2 - o[u] / 2;
  let y;
  switch (c) {
    case "top":
      y = {
        x: h,
        y: r.y - o.height
      };
      break;
    case "bottom":
      y = {
        x: h,
        y: r.y + r.height
      };
      break;
    case "right":
      y = {
        x: r.x + r.width,
        y: p
      };
      break;
    case "left":
      y = {
        x: r.x - o.width,
        y: p
      };
      break;
    default:
      y = {
        x: r.x,
        y: r.y
      };
  }
  switch (zl(t)) {
    case "start":
      y[s] -= g * (n && f ? -1 : 1);
      break;
    case "end":
      y[s] += g * (n && f ? -1 : 1);
      break;
  }
  return y;
}
const QV = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: o = "absolute",
    middleware: a = [],
    platform: s
  } = n, u = a.filter(Boolean), c = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let f = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: o
  }), {
    x: h,
    y: p
  } = Xk(f, r, c), g = r, y = {}, w = 0;
  for (let v = 0; v < u.length; v++) {
    const {
      name: S,
      fn: E
    } = u[v], {
      x: T,
      y: k,
      data: A,
      reset: M
    } = await E({
      x: h,
      y: p,
      initialPlacement: r,
      placement: g,
      strategy: o,
      middlewareData: y,
      rects: f,
      platform: s,
      elements: {
        reference: e,
        floating: t
      }
    });
    h = T ?? h, p = k ?? p, y = {
      ...y,
      [S]: {
        ...y[S],
        ...A
      }
    }, M && w <= 50 && (w++, typeof M == "object" && (M.placement && (g = M.placement), M.rects && (f = M.rects === !0 ? await s.getElementRects({
      reference: e,
      floating: t,
      strategy: o
    }) : M.rects), {
      x: h,
      y: p
    } = Xk(f, g, c)), v = -1);
  }
  return {
    x: h,
    y: p,
    placement: g,
    strategy: o,
    middlewareData: y
  };
};
async function Pc(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: o,
    platform: a,
    rects: s,
    elements: u,
    strategy: c
  } = e, {
    boundary: f = "clippingAncestors",
    rootBoundary: h = "viewport",
    elementContext: p = "floating",
    altBoundary: g = !1,
    padding: y = 0
  } = ii(t, e), w = wN(y), S = u[g ? p === "floating" ? "reference" : "floating" : p], E = sp(await a.getClippingRect({
    element: (n = await (a.isElement == null ? void 0 : a.isElement(S))) == null || n ? S : S.contextElement || await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(u.floating)),
    boundary: f,
    rootBoundary: h,
    strategy: c
  })), T = p === "floating" ? {
    x: r,
    y: o,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, k = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(u.floating)), A = await (a.isElement == null ? void 0 : a.isElement(k)) ? await (a.getScale == null ? void 0 : a.getScale(k)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, M = sp(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: u,
    rect: T,
    offsetParent: k,
    strategy: c
  }) : T);
  return {
    top: (E.top - M.top + w.top) / A.y,
    bottom: (M.bottom - E.bottom + w.bottom) / A.y,
    left: (E.left - M.left + w.left) / A.x,
    right: (M.right - E.right + w.right) / A.x
  };
}
const JV = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: o,
      rects: a,
      platform: s,
      elements: u,
      middlewareData: c
    } = t, {
      element: f,
      padding: h = 0
    } = ii(e, t) || {};
    if (f == null)
      return {};
    const p = wN(h), g = {
      x: n,
      y: r
    }, y = X1(o), w = W1(y), v = await s.getDimensions(f), S = y === "y", E = S ? "top" : "left", T = S ? "bottom" : "right", k = S ? "clientHeight" : "clientWidth", A = a.reference[w] + a.reference[y] - g[y] - a.floating[w], M = g[y] - a.reference[y], N = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(f));
    let P = N ? N[k] : 0;
    (!P || !await (s.isElement == null ? void 0 : s.isElement(N))) && (P = u.floating[k] || a.floating[w]);
    const z = A / 2 - M / 2, B = P / 2 - v[w] / 2 - 1, R = oa(p[E], B), F = oa(p[T], B), U = R, W = P - v[w] - F, j = P / 2 - v[w] / 2 + z, V = hb(U, j, W), I = !c.arrow && zl(o) != null && j !== V && a.reference[w] / 2 - (j < U ? R : F) - v[w] / 2 < 0, H = I ? j < U ? j - U : j - W : 0;
    return {
      [y]: g[y] + H,
      data: {
        [y]: V,
        centerOffset: j - V - H,
        ...I && {
          alignmentOffset: H
        }
      },
      reset: I
    };
  }
}), eU = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: o,
        middlewareData: a,
        rects: s,
        initialPlacement: u,
        platform: c,
        elements: f
      } = t, {
        mainAxis: h = !0,
        crossAxis: p = !0,
        fallbackPlacements: g,
        fallbackStrategy: y = "bestFit",
        fallbackAxisSideDirection: w = "none",
        flipAlignment: v = !0,
        ...S
      } = ii(e, t);
      if ((n = a.arrow) != null && n.alignmentOffset)
        return {};
      const E = ai(o), T = uo(u), k = ai(u) === u, A = await (c.isRTL == null ? void 0 : c.isRTL(f.floating)), M = g || (k || !v ? [ap(u)] : GV(u)), N = w !== "none";
      !g && N && M.push(...KV(u, v, w, A));
      const P = [u, ...M], z = await Pc(t, S), B = [];
      let R = ((r = a.flip) == null ? void 0 : r.overflows) || [];
      if (h && B.push(z[E]), p) {
        const j = qV(o, s, A);
        B.push(z[j[0]], z[j[1]]);
      }
      if (R = [...R, {
        placement: o,
        overflows: B
      }], !B.every((j) => j <= 0)) {
        var F, U;
        const j = (((F = a.flip) == null ? void 0 : F.index) || 0) + 1, V = P[j];
        if (V && (!(p === "alignment" ? T !== uo(V) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        R.every((q) => q.overflows[0] > 0 && uo(q.placement) === T)))
          return {
            data: {
              index: j,
              overflows: R
            },
            reset: {
              placement: V
            }
          };
        let I = (U = R.filter((H) => H.overflows[0] <= 0).sort((H, q) => H.overflows[1] - q.overflows[1])[0]) == null ? void 0 : U.placement;
        if (!I)
          switch (y) {
            case "bestFit": {
              var W;
              const H = (W = R.filter((q) => {
                if (N) {
                  const G = uo(q.placement);
                  return G === T || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  G === "y";
                }
                return !0;
              }).map((q) => [q.placement, q.overflows.filter((G) => G > 0).reduce((G, O) => G + O, 0)]).sort((q, G) => q[1] - G[1])[0]) == null ? void 0 : W[0];
              H && (I = H);
              break;
            }
            case "initialPlacement":
              I = u;
              break;
          }
        if (o !== I)
          return {
            reset: {
              placement: I
            }
          };
      }
      return {};
    }
  };
};
function Kk(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function Zk(e) {
  return BV.some((t) => e[t] >= 0);
}
const tU = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: r = "referenceHidden",
        ...o
      } = ii(e, t);
      switch (r) {
        case "referenceHidden": {
          const a = await Pc(t, {
            ...o,
            elementContext: "reference"
          }), s = Kk(a, n.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: Zk(s)
            }
          };
        }
        case "escaped": {
          const a = await Pc(t, {
            ...o,
            altBoundary: !0
          }), s = Kk(a, n.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: Zk(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, _N = /* @__PURE__ */ new Set(["left", "top"]);
async function nU(e, t) {
  const {
    placement: n,
    platform: r,
    elements: o
  } = e, a = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)), s = ai(n), u = zl(n), c = uo(n) === "y", f = _N.has(s) ? -1 : 1, h = a && c ? -1 : 1, p = ii(t, e);
  let {
    mainAxis: g,
    crossAxis: y,
    alignmentAxis: w
  } = typeof p == "number" ? {
    mainAxis: p,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: p.mainAxis || 0,
    crossAxis: p.crossAxis || 0,
    alignmentAxis: p.alignmentAxis
  };
  return u && typeof w == "number" && (y = u === "end" ? w * -1 : w), c ? {
    x: y * h,
    y: g * f
  } : {
    x: g * f,
    y: y * h
  };
}
const rU = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: o,
        y: a,
        placement: s,
        middlewareData: u
      } = t, c = await nU(t, e);
      return s === ((n = u.offset) == null ? void 0 : n.placement) && (r = u.arrow) != null && r.alignmentOffset ? {} : {
        x: o + c.x,
        y: a + c.y,
        data: {
          ...c,
          placement: s
        }
      };
    }
  };
}, oU = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: o
      } = t, {
        mainAxis: a = !0,
        crossAxis: s = !1,
        limiter: u = {
          fn: (S) => {
            let {
              x: E,
              y: T
            } = S;
            return {
              x: E,
              y: T
            };
          }
        },
        ...c
      } = ii(e, t), f = {
        x: n,
        y: r
      }, h = await Pc(t, c), p = uo(ai(o)), g = Y1(p);
      let y = f[g], w = f[p];
      if (a) {
        const S = g === "y" ? "top" : "left", E = g === "y" ? "bottom" : "right", T = y + h[S], k = y - h[E];
        y = hb(T, y, k);
      }
      if (s) {
        const S = p === "y" ? "top" : "left", E = p === "y" ? "bottom" : "right", T = w + h[S], k = w - h[E];
        w = hb(T, w, k);
      }
      const v = u.fn({
        ...t,
        [g]: y,
        [p]: w
      });
      return {
        ...v,
        data: {
          x: v.x - n,
          y: v.y - r,
          enabled: {
            [g]: a,
            [p]: s
          }
        }
      };
    }
  };
}, iU = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: r,
        placement: o,
        rects: a,
        middlewareData: s
      } = t, {
        offset: u = 0,
        mainAxis: c = !0,
        crossAxis: f = !0
      } = ii(e, t), h = {
        x: n,
        y: r
      }, p = uo(o), g = Y1(p);
      let y = h[g], w = h[p];
      const v = ii(u, t), S = typeof v == "number" ? {
        mainAxis: v,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...v
      };
      if (c) {
        const k = g === "y" ? "height" : "width", A = a.reference[g] - a.floating[k] + S.mainAxis, M = a.reference[g] + a.reference[k] - S.mainAxis;
        y < A ? y = A : y > M && (y = M);
      }
      if (f) {
        var E, T;
        const k = g === "y" ? "width" : "height", A = _N.has(ai(o)), M = a.reference[p] - a.floating[k] + (A && ((E = s.offset) == null ? void 0 : E[p]) || 0) + (A ? 0 : S.crossAxis), N = a.reference[p] + a.reference[k] + (A ? 0 : ((T = s.offset) == null ? void 0 : T[p]) || 0) - (A ? S.crossAxis : 0);
        w < M ? w = M : w > N && (w = N);
      }
      return {
        [g]: y,
        [p]: w
      };
    }
  };
}, aU = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: o,
        rects: a,
        platform: s,
        elements: u
      } = t, {
        apply: c = () => {
        },
        ...f
      } = ii(e, t), h = await Pc(t, f), p = ai(o), g = zl(o), y = uo(o) === "y", {
        width: w,
        height: v
      } = a.floating;
      let S, E;
      p === "top" || p === "bottom" ? (S = p, E = g === (await (s.isRTL == null ? void 0 : s.isRTL(u.floating)) ? "start" : "end") ? "left" : "right") : (E = p, S = g === "end" ? "top" : "bottom");
      const T = v - h.top - h.bottom, k = w - h.left - h.right, A = oa(v - h[S], T), M = oa(w - h[E], k), N = !t.middlewareData.shift;
      let P = A, z = M;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (z = k), (r = t.middlewareData.shift) != null && r.enabled.y && (P = T), N && !g) {
        const R = tr(h.left, 0), F = tr(h.right, 0), U = tr(h.top, 0), W = tr(h.bottom, 0);
        y ? z = w - 2 * (R !== 0 || F !== 0 ? R + F : tr(h.left, h.right)) : P = v - 2 * (U !== 0 || W !== 0 ? U + W : tr(h.top, h.bottom));
      }
      await c({
        ...t,
        availableWidth: z,
        availableHeight: P
      });
      const B = await s.getDimensions(u.floating);
      return w !== B.width || v !== B.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function pm() {
  return typeof window < "u";
}
function Ll(e) {
  return SN(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function ar(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function So(e) {
  var t;
  return (t = (SN(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function SN(e) {
  return pm() ? e instanceof Node || e instanceof ar(e).Node : !1;
}
function Fr(e) {
  return pm() ? e instanceof Element || e instanceof ar(e).Element : !1;
}
function yo(e) {
  return pm() ? e instanceof HTMLElement || e instanceof ar(e).HTMLElement : !1;
}
function Qk(e) {
  return !pm() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof ar(e).ShadowRoot;
}
const sU = /* @__PURE__ */ new Set(["inline", "contents"]);
function lf(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: o
  } = $r(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !sU.has(o);
}
const lU = /* @__PURE__ */ new Set(["table", "td", "th"]);
function uU(e) {
  return lU.has(Ll(e));
}
const cU = [":popover-open", ":modal"];
function mm(e) {
  return cU.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const fU = ["transform", "translate", "scale", "rotate", "perspective"], dU = ["transform", "translate", "scale", "rotate", "perspective", "filter"], hU = ["paint", "layout", "strict", "content"];
function K1(e) {
  const t = Z1(), n = Fr(e) ? $r(e) : e;
  return fU.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || dU.some((r) => (n.willChange || "").includes(r)) || hU.some((r) => (n.contain || "").includes(r));
}
function pU(e) {
  let t = ia(e);
  for (; yo(t) && !wl(t); ) {
    if (K1(t))
      return t;
    if (mm(t))
      return null;
    t = ia(t);
  }
  return null;
}
function Z1() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const mU = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function wl(e) {
  return mU.has(Ll(e));
}
function $r(e) {
  return ar(e).getComputedStyle(e);
}
function gm(e) {
  return Fr(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function ia(e) {
  if (Ll(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Qk(e) && e.host || // Fallback.
    So(e)
  );
  return Qk(t) ? t.host : t;
}
function EN(e) {
  const t = ia(e);
  return wl(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : yo(t) && lf(t) ? t : EN(t);
}
function jc(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const o = EN(e), a = o === ((r = e.ownerDocument) == null ? void 0 : r.body), s = ar(o);
  if (a) {
    const u = mb(s);
    return t.concat(s, s.visualViewport || [], lf(o) ? o : [], u && n ? jc(u) : []);
  }
  return t.concat(o, jc(o, [], n));
}
function mb(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function CN(e) {
  const t = $r(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const o = yo(e), a = o ? e.offsetWidth : n, s = o ? e.offsetHeight : r, u = ip(n) !== a || ip(r) !== s;
  return u && (n = a, r = s), {
    width: n,
    height: r,
    $: u
  };
}
function Q1(e) {
  return Fr(e) ? e : e.contextElement;
}
function cl(e) {
  const t = Q1(e);
  if (!yo(t))
    return mo(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: o,
    $: a
  } = CN(t);
  let s = (a ? ip(n.width) : n.width) / r, u = (a ? ip(n.height) : n.height) / o;
  return (!s || !Number.isFinite(s)) && (s = 1), (!u || !Number.isFinite(u)) && (u = 1), {
    x: s,
    y: u
  };
}
const gU = /* @__PURE__ */ mo(0);
function kN(e) {
  const t = ar(e);
  return !Z1() || !t.visualViewport ? gU : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function yU(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== ar(e) ? !1 : t;
}
function Ya(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const o = e.getBoundingClientRect(), a = Q1(e);
  let s = mo(1);
  t && (r ? Fr(r) && (s = cl(r)) : s = cl(e));
  const u = yU(a, n, r) ? kN(a) : mo(0);
  let c = (o.left + u.x) / s.x, f = (o.top + u.y) / s.y, h = o.width / s.x, p = o.height / s.y;
  if (a) {
    const g = ar(a), y = r && Fr(r) ? ar(r) : r;
    let w = g, v = mb(w);
    for (; v && r && y !== w; ) {
      const S = cl(v), E = v.getBoundingClientRect(), T = $r(v), k = E.left + (v.clientLeft + parseFloat(T.paddingLeft)) * S.x, A = E.top + (v.clientTop + parseFloat(T.paddingTop)) * S.y;
      c *= S.x, f *= S.y, h *= S.x, p *= S.y, c += k, f += A, w = ar(v), v = mb(w);
    }
  }
  return sp({
    width: h,
    height: p,
    x: c,
    y: f
  });
}
function J1(e, t) {
  const n = gm(e).scrollLeft;
  return t ? t.left + n : Ya(So(e)).left + n;
}
function TN(e, t, n) {
  n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), o = r.left + t.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    J1(e, r)
  )), a = r.top + t.scrollTop;
  return {
    x: o,
    y: a
  };
}
function vU(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: o
  } = e;
  const a = o === "fixed", s = So(r), u = t ? mm(t.floating) : !1;
  if (r === s || u && a)
    return n;
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  }, f = mo(1);
  const h = mo(0), p = yo(r);
  if ((p || !p && !a) && ((Ll(r) !== "body" || lf(s)) && (c = gm(r)), yo(r))) {
    const y = Ya(r);
    f = cl(r), h.x = y.x + r.clientLeft, h.y = y.y + r.clientTop;
  }
  const g = s && !p && !a ? TN(s, c, !0) : mo(0);
  return {
    width: n.width * f.x,
    height: n.height * f.y,
    x: n.x * f.x - c.scrollLeft * f.x + h.x + g.x,
    y: n.y * f.y - c.scrollTop * f.y + h.y + g.y
  };
}
function bU(e) {
  return Array.from(e.getClientRects());
}
function xU(e) {
  const t = So(e), n = gm(e), r = e.ownerDocument.body, o = tr(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), a = tr(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -n.scrollLeft + J1(e);
  const u = -n.scrollTop;
  return $r(r).direction === "rtl" && (s += tr(t.clientWidth, r.clientWidth) - o), {
    width: o,
    height: a,
    x: s,
    y: u
  };
}
function wU(e, t) {
  const n = ar(e), r = So(e), o = n.visualViewport;
  let a = r.clientWidth, s = r.clientHeight, u = 0, c = 0;
  if (o) {
    a = o.width, s = o.height;
    const f = Z1();
    (!f || f && t === "fixed") && (u = o.offsetLeft, c = o.offsetTop);
  }
  return {
    width: a,
    height: s,
    x: u,
    y: c
  };
}
const _U = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function SU(e, t) {
  const n = Ya(e, !0, t === "fixed"), r = n.top + e.clientTop, o = n.left + e.clientLeft, a = yo(e) ? cl(e) : mo(1), s = e.clientWidth * a.x, u = e.clientHeight * a.y, c = o * a.x, f = r * a.y;
  return {
    width: s,
    height: u,
    x: c,
    y: f
  };
}
function Jk(e, t, n) {
  let r;
  if (t === "viewport")
    r = wU(e, n);
  else if (t === "document")
    r = xU(So(e));
  else if (Fr(t))
    r = SU(t, n);
  else {
    const o = kN(e);
    r = {
      x: t.x - o.x,
      y: t.y - o.y,
      width: t.width,
      height: t.height
    };
  }
  return sp(r);
}
function AN(e, t) {
  const n = ia(e);
  return n === t || !Fr(n) || wl(n) ? !1 : $r(n).position === "fixed" || AN(n, t);
}
function EU(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = jc(e, [], !1).filter((u) => Fr(u) && Ll(u) !== "body"), o = null;
  const a = $r(e).position === "fixed";
  let s = a ? ia(e) : e;
  for (; Fr(s) && !wl(s); ) {
    const u = $r(s), c = K1(s);
    !c && u.position === "fixed" && (o = null), (a ? !c && !o : !c && u.position === "static" && !!o && _U.has(o.position) || lf(s) && !c && AN(e, s)) ? r = r.filter((h) => h !== s) : o = u, s = ia(s);
  }
  return t.set(e, r), r;
}
function CU(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: o
  } = e;
  const s = [...n === "clippingAncestors" ? mm(t) ? [] : EU(t, this._c) : [].concat(n), r], u = s[0], c = s.reduce((f, h) => {
    const p = Jk(t, h, o);
    return f.top = tr(p.top, f.top), f.right = oa(p.right, f.right), f.bottom = oa(p.bottom, f.bottom), f.left = tr(p.left, f.left), f;
  }, Jk(t, u, o));
  return {
    width: c.right - c.left,
    height: c.bottom - c.top,
    x: c.left,
    y: c.top
  };
}
function kU(e) {
  const {
    width: t,
    height: n
  } = CN(e);
  return {
    width: t,
    height: n
  };
}
function TU(e, t, n) {
  const r = yo(t), o = So(t), a = n === "fixed", s = Ya(e, !0, a, t);
  let u = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const c = mo(0);
  function f() {
    c.x = J1(o);
  }
  if (r || !r && !a)
    if ((Ll(t) !== "body" || lf(o)) && (u = gm(t)), r) {
      const y = Ya(t, !0, a, t);
      c.x = y.x + t.clientLeft, c.y = y.y + t.clientTop;
    } else o && f();
  a && !r && o && f();
  const h = o && !r && !a ? TN(o, u) : mo(0), p = s.left + u.scrollLeft - c.x - h.x, g = s.top + u.scrollTop - c.y - h.y;
  return {
    x: p,
    y: g,
    width: s.width,
    height: s.height
  };
}
function qy(e) {
  return $r(e).position === "static";
}
function eT(e, t) {
  if (!yo(e) || $r(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return So(e) === n && (n = n.ownerDocument.body), n;
}
function RN(e, t) {
  const n = ar(e);
  if (mm(e))
    return n;
  if (!yo(e)) {
    let o = ia(e);
    for (; o && !wl(o); ) {
      if (Fr(o) && !qy(o))
        return o;
      o = ia(o);
    }
    return n;
  }
  let r = eT(e, t);
  for (; r && uU(r) && qy(r); )
    r = eT(r, t);
  return r && wl(r) && qy(r) && !K1(r) ? n : r || pU(e) || n;
}
const AU = async function(e) {
  const t = this.getOffsetParent || RN, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: TU(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function RU(e) {
  return $r(e).direction === "rtl";
}
const MU = {
  convertOffsetParentRelativeRectToViewportRelativeRect: vU,
  getDocumentElement: So,
  getClippingRect: CU,
  getOffsetParent: RN,
  getElementRects: AU,
  getClientRects: bU,
  getDimensions: kU,
  getScale: cl,
  isElement: Fr,
  isRTL: RU
};
function MN(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function OU(e, t) {
  let n = null, r;
  const o = So(e);
  function a() {
    var u;
    clearTimeout(r), (u = n) == null || u.disconnect(), n = null;
  }
  function s(u, c) {
    u === void 0 && (u = !1), c === void 0 && (c = 1), a();
    const f = e.getBoundingClientRect(), {
      left: h,
      top: p,
      width: g,
      height: y
    } = f;
    if (u || t(), !g || !y)
      return;
    const w = oh(p), v = oh(o.clientWidth - (h + g)), S = oh(o.clientHeight - (p + y)), E = oh(h), k = {
      rootMargin: -w + "px " + -v + "px " + -S + "px " + -E + "px",
      threshold: tr(0, oa(1, c)) || 1
    };
    let A = !0;
    function M(N) {
      const P = N[0].intersectionRatio;
      if (P !== c) {
        if (!A)
          return s();
        P ? s(!1, P) : r = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      P === 1 && !MN(f, e.getBoundingClientRect()) && s(), A = !1;
    }
    try {
      n = new IntersectionObserver(M, {
        ...k,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(M, k);
    }
    n.observe(e);
  }
  return s(!0), a;
}
function ON(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: a = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: u = typeof IntersectionObserver == "function",
    animationFrame: c = !1
  } = r, f = Q1(e), h = o || a ? [...f ? jc(f) : [], ...jc(t)] : [];
  h.forEach((E) => {
    o && E.addEventListener("scroll", n, {
      passive: !0
    }), a && E.addEventListener("resize", n);
  });
  const p = f && u ? OU(f, n) : null;
  let g = -1, y = null;
  s && (y = new ResizeObserver((E) => {
    let [T] = E;
    T && T.target === f && y && (y.unobserve(t), cancelAnimationFrame(g), g = requestAnimationFrame(() => {
      var k;
      (k = y) == null || k.observe(t);
    })), n();
  }), f && !c && y.observe(f), y.observe(t));
  let w, v = c ? Ya(e) : null;
  c && S();
  function S() {
    const E = Ya(e);
    v && !MN(v, E) && n(), v = E, w = requestAnimationFrame(S);
  }
  return n(), () => {
    var E;
    h.forEach((T) => {
      o && T.removeEventListener("scroll", n), a && T.removeEventListener("resize", n);
    }), p?.(), (E = y) == null || E.disconnect(), y = null, c && cancelAnimationFrame(w);
  };
}
const NU = rU, DU = oU, PU = eU, jU = aU, IU = tU, tT = JV, zU = iU, LU = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), o = {
    platform: MU,
    ...n
  }, a = {
    ...o.platform,
    _c: r
  };
  return QV(e, t, {
    ...o,
    platform: a
  });
};
var FU = typeof document < "u", $U = function() {
}, zh = FU ? _.useLayoutEffect : $U;
function lp(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, o;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!lp(e[r], t[r]))
          return !1;
      return !0;
    }
    if (o = Object.keys(e), n = o.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, o[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const a = o[r];
      if (!(a === "_owner" && e.$$typeof) && !lp(e[a], t[a]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function NN(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function nT(e, t) {
  const n = NN(e);
  return Math.round(t * n) / n;
}
function Gy(e) {
  const t = _.useRef(e);
  return zh(() => {
    t.current = e;
  }), t;
}
function BU(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: o,
    elements: {
      reference: a,
      floating: s
    } = {},
    transform: u = !0,
    whileElementsMounted: c,
    open: f
  } = e, [h, p] = _.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [g, y] = _.useState(r);
  lp(g, r) || y(r);
  const [w, v] = _.useState(null), [S, E] = _.useState(null), T = _.useCallback((q) => {
    q !== N.current && (N.current = q, v(q));
  }, []), k = _.useCallback((q) => {
    q !== P.current && (P.current = q, E(q));
  }, []), A = a || w, M = s || S, N = _.useRef(null), P = _.useRef(null), z = _.useRef(h), B = c != null, R = Gy(c), F = Gy(o), U = Gy(f), W = _.useCallback(() => {
    if (!N.current || !P.current)
      return;
    const q = {
      placement: t,
      strategy: n,
      middleware: g
    };
    F.current && (q.platform = F.current), LU(N.current, P.current, q).then((G) => {
      const O = {
        ...G,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: U.current !== !1
      };
      j.current && !lp(z.current, O) && (z.current = O, Dl.flushSync(() => {
        p(O);
      }));
    });
  }, [g, t, n, F, U]);
  zh(() => {
    f === !1 && z.current.isPositioned && (z.current.isPositioned = !1, p((q) => ({
      ...q,
      isPositioned: !1
    })));
  }, [f]);
  const j = _.useRef(!1);
  zh(() => (j.current = !0, () => {
    j.current = !1;
  }), []), zh(() => {
    if (A && (N.current = A), M && (P.current = M), A && M) {
      if (R.current)
        return R.current(A, M, W);
      W();
    }
  }, [A, M, W, R, B]);
  const V = _.useMemo(() => ({
    reference: N,
    floating: P,
    setReference: T,
    setFloating: k
  }), [T, k]), I = _.useMemo(() => ({
    reference: A,
    floating: M
  }), [A, M]), H = _.useMemo(() => {
    const q = {
      position: n,
      left: 0,
      top: 0
    };
    if (!I.floating)
      return q;
    const G = nT(I.floating, h.x), O = nT(I.floating, h.y);
    return u ? {
      ...q,
      transform: "translate(" + G + "px, " + O + "px)",
      ...NN(I.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: G,
      top: O
    };
  }, [n, u, I.floating, h.x, h.y]);
  return _.useMemo(() => ({
    ...h,
    update: W,
    refs: V,
    elements: I,
    floatingStyles: H
  }), [h, W, V, I, H]);
}
const HU = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: r,
        padding: o
      } = typeof e == "function" ? e(n) : e;
      return r && t(r) ? r.current != null ? tT({
        element: r.current,
        padding: o
      }).fn(n) : {} : r ? tT({
        element: r,
        padding: o
      }).fn(n) : {};
    }
  };
}, VU = (e, t) => ({
  ...NU(e),
  options: [e, t]
}), UU = (e, t) => ({
  ...DU(e),
  options: [e, t]
}), qU = (e, t) => ({
  ...zU(e),
  options: [e, t]
}), GU = (e, t) => ({
  ...PU(e),
  options: [e, t]
}), YU = (e, t) => ({
  ...jU(e),
  options: [e, t]
}), WU = (e, t) => ({
  ...IU(e),
  options: [e, t]
}), XU = (e, t) => ({
  ...HU(e),
  options: [e, t]
});
var KU = "Arrow", DN = _.forwardRef((e, t) => {
  const { children: n, width: r = 10, height: o = 5, ...a } = e;
  return /* @__PURE__ */ x.jsx(
    qe.svg,
    {
      ...a,
      ref: t,
      width: r,
      height: o,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : /* @__PURE__ */ x.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
DN.displayName = KU;
var ZU = DN;
function PN(e) {
  const [t, n] = _.useState(void 0);
  return ni(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const r = new ResizeObserver((o) => {
        if (!Array.isArray(o) || !o.length)
          return;
        const a = o[0];
        let s, u;
        if ("borderBoxSize" in a) {
          const c = a.borderBoxSize, f = Array.isArray(c) ? c[0] : c;
          s = f.inlineSize, u = f.blockSize;
        } else
          s = e.offsetWidth, u = e.offsetHeight;
        n({ width: s, height: u });
      });
      return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
var ex = "Popper", [jN, ym] = _o(ex), [QU, IN] = jN(ex), zN = (e) => {
  const { __scopePopper: t, children: n } = e, [r, o] = _.useState(null);
  return /* @__PURE__ */ x.jsx(QU, { scope: t, anchor: r, onAnchorChange: o, children: n });
};
zN.displayName = ex;
var LN = "PopperAnchor", FN = _.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: r, ...o } = e, a = IN(LN, n), s = _.useRef(null), u = bt(t, s);
    return _.useEffect(() => {
      a.onAnchorChange(r?.current || s.current);
    }), r ? null : /* @__PURE__ */ x.jsx(qe.div, { ...o, ref: u });
  }
);
FN.displayName = LN;
var tx = "PopperContent", [JU, eq] = jN(tx), $N = _.forwardRef(
  (e, t) => {
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: o = 0,
      align: a = "center",
      alignOffset: s = 0,
      arrowPadding: u = 0,
      avoidCollisions: c = !0,
      collisionBoundary: f = [],
      collisionPadding: h = 0,
      sticky: p = "partial",
      hideWhenDetached: g = !1,
      updatePositionStrategy: y = "optimized",
      onPlaced: w,
      ...v
    } = e, S = IN(tx, n), [E, T] = _.useState(null), k = bt(t, (de) => T(de)), [A, M] = _.useState(null), N = PN(A), P = N?.width ?? 0, z = N?.height ?? 0, B = r + (a !== "center" ? "-" + a : ""), R = typeof h == "number" ? h : { top: 0, right: 0, bottom: 0, left: 0, ...h }, F = Array.isArray(f) ? f : [f], U = F.length > 0, W = {
      padding: R,
      boundary: F.filter(nq),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: U
    }, { refs: j, floatingStyles: V, placement: I, isPositioned: H, middlewareData: q } = BU({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: B,
      whileElementsMounted: (...de) => ON(...de, {
        animationFrame: y === "always"
      }),
      elements: {
        reference: S.anchor
      },
      middleware: [
        VU({ mainAxis: o + z, alignmentAxis: s }),
        c && UU({
          mainAxis: !0,
          crossAxis: !1,
          limiter: p === "partial" ? qU() : void 0,
          ...W
        }),
        c && GU({ ...W }),
        YU({
          ...W,
          apply: ({ elements: de, rects: le, availableWidth: ye, availableHeight: je }) => {
            const { width: Ne, height: we } = le.reference, Ee = de.floating.style;
            Ee.setProperty("--radix-popper-available-width", `${ye}px`), Ee.setProperty("--radix-popper-available-height", `${je}px`), Ee.setProperty("--radix-popper-anchor-width", `${Ne}px`), Ee.setProperty("--radix-popper-anchor-height", `${we}px`);
          }
        }),
        A && XU({ element: A, padding: u }),
        rq({ arrowWidth: P, arrowHeight: z }),
        g && WU({ strategy: "referenceHidden", ...W })
      ]
    }), [G, O] = VN(I), Y = Hn(w);
    ni(() => {
      H && Y?.();
    }, [H, Y]);
    const Z = q.arrow?.x, L = q.arrow?.y, te = q.arrow?.centerOffset !== 0, [he, oe] = _.useState();
    return ni(() => {
      E && oe(window.getComputedStyle(E).zIndex);
    }, [E]), /* @__PURE__ */ x.jsx(
      "div",
      {
        ref: j.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...V,
          transform: H ? V.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: he,
          "--radix-popper-transform-origin": [
            q.transformOrigin?.x,
            q.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...q.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ x.jsx(
          JU,
          {
            scope: n,
            placedSide: G,
            onArrowChange: M,
            arrowX: Z,
            arrowY: L,
            shouldHideArrow: te,
            children: /* @__PURE__ */ x.jsx(
              qe.div,
              {
                "data-side": G,
                "data-align": O,
                ...v,
                ref: k,
                style: {
                  ...v.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: H ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
$N.displayName = tx;
var BN = "PopperArrow", tq = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, HN = _.forwardRef(function(t, n) {
  const { __scopePopper: r, ...o } = t, a = eq(BN, r), s = tq[a.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ x.jsx(
      "span",
      {
        ref: a.onArrowChange,
        style: {
          position: "absolute",
          left: a.arrowX,
          top: a.arrowY,
          [s]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[a.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[a.placedSide],
          visibility: a.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ x.jsx(
          ZU,
          {
            ...o,
            ref: n,
            style: {
              ...o.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
HN.displayName = BN;
function nq(e) {
  return e !== null;
}
var rq = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    const { placement: n, rects: r, middlewareData: o } = t, s = o.arrow?.centerOffset !== 0, u = s ? 0 : e.arrowWidth, c = s ? 0 : e.arrowHeight, [f, h] = VN(n), p = { start: "0%", center: "50%", end: "100%" }[h], g = (o.arrow?.x ?? 0) + u / 2, y = (o.arrow?.y ?? 0) + c / 2;
    let w = "", v = "";
    return f === "bottom" ? (w = s ? p : `${g}px`, v = `${-c}px`) : f === "top" ? (w = s ? p : `${g}px`, v = `${r.floating.height + c}px`) : f === "right" ? (w = `${-c}px`, v = s ? p : `${y}px`) : f === "left" && (w = `${r.floating.width + c}px`, v = s ? p : `${y}px`), { data: { x: w, y: v } };
  }
});
function VN(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var nx = zN, rx = FN, UN = $N, qN = HN, vm = "Popover", [GN, Gpe] = _o(vm, [
  ym
]), uf = ym(), [oq, la] = GN(vm), YN = (e) => {
  const {
    __scopePopover: t,
    children: n,
    open: r,
    defaultOpen: o,
    onOpenChange: a,
    modal: s = !1
  } = e, u = uf(t), c = _.useRef(null), [f, h] = _.useState(!1), [p, g] = sa({
    prop: r,
    defaultProp: o ?? !1,
    onChange: a,
    caller: vm
  });
  return /* @__PURE__ */ x.jsx(nx, { ...u, children: /* @__PURE__ */ x.jsx(
    oq,
    {
      scope: t,
      contentId: po(),
      triggerRef: c,
      open: p,
      onOpenChange: g,
      onOpenToggle: _.useCallback(() => g((y) => !y), [g]),
      hasCustomAnchor: f,
      onCustomAnchorAdd: _.useCallback(() => h(!0), []),
      onCustomAnchorRemove: _.useCallback(() => h(!1), []),
      modal: s,
      children: n
    }
  ) });
};
YN.displayName = vm;
var WN = "PopoverAnchor", iq = _.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, o = la(WN, n), a = uf(n), { onCustomAnchorAdd: s, onCustomAnchorRemove: u } = o;
    return _.useEffect(() => (s(), () => u()), [s, u]), /* @__PURE__ */ x.jsx(rx, { ...a, ...r, ref: t });
  }
);
iq.displayName = WN;
var XN = "PopoverTrigger", KN = _.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, o = la(XN, n), a = uf(n), s = bt(t, o.triggerRef), u = /* @__PURE__ */ x.jsx(
      qe.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": o.open,
        "aria-controls": o.contentId,
        "data-state": n2(o.open),
        ...r,
        ref: s,
        onClick: xe(e.onClick, o.onOpenToggle)
      }
    );
    return o.hasCustomAnchor ? u : /* @__PURE__ */ x.jsx(rx, { asChild: !0, ...a, children: u });
  }
);
KN.displayName = XN;
var ox = "PopoverPortal", [aq, sq] = GN(ox, {
  forceMount: void 0
}), ZN = (e) => {
  const { __scopePopover: t, forceMount: n, children: r, container: o } = e, a = la(ox, t);
  return /* @__PURE__ */ x.jsx(aq, { scope: t, forceMount: n, children: /* @__PURE__ */ x.jsx(Br, { present: n || a.open, children: /* @__PURE__ */ x.jsx(om, { asChild: !0, container: o, children: r }) }) });
};
ZN.displayName = ox;
var _l = "PopoverContent", QN = _.forwardRef(
  (e, t) => {
    const n = sq(_l, e.__scopePopover), { forceMount: r = n.forceMount, ...o } = e, a = la(_l, e.__scopePopover);
    return /* @__PURE__ */ x.jsx(Br, { present: r || a.open, children: a.modal ? /* @__PURE__ */ x.jsx(uq, { ...o, ref: t }) : /* @__PURE__ */ x.jsx(cq, { ...o, ref: t }) });
  }
);
QN.displayName = _l;
var lq = /* @__PURE__ */ bl("PopoverContent.RemoveScroll"), uq = _.forwardRef(
  (e, t) => {
    const n = la(_l, e.__scopePopover), r = _.useRef(null), o = bt(t, r), a = _.useRef(!1);
    return _.useEffect(() => {
      const s = r.current;
      if (s) return R1(s);
    }, []), /* @__PURE__ */ x.jsx(am, { as: lq, allowPinchZoom: !0, children: /* @__PURE__ */ x.jsx(
      JN,
      {
        ...e,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: xe(e.onCloseAutoFocus, (s) => {
          s.preventDefault(), a.current || n.triggerRef.current?.focus();
        }),
        onPointerDownOutside: xe(
          e.onPointerDownOutside,
          (s) => {
            const u = s.detail.originalEvent, c = u.button === 0 && u.ctrlKey === !0, f = u.button === 2 || c;
            a.current = f;
          },
          { checkForDefaultPrevented: !1 }
        ),
        onFocusOutside: xe(
          e.onFocusOutside,
          (s) => s.preventDefault(),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
), cq = _.forwardRef(
  (e, t) => {
    const n = la(_l, e.__scopePopover), r = _.useRef(!1), o = _.useRef(!1);
    return /* @__PURE__ */ x.jsx(
      JN,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (a) => {
          e.onCloseAutoFocus?.(a), a.defaultPrevented || (r.current || n.triggerRef.current?.focus(), a.preventDefault()), r.current = !1, o.current = !1;
        },
        onInteractOutside: (a) => {
          e.onInteractOutside?.(a), a.defaultPrevented || (r.current = !0, a.detail.originalEvent.type === "pointerdown" && (o.current = !0));
          const s = a.target;
          n.triggerRef.current?.contains(s) && a.preventDefault(), a.detail.originalEvent.type === "focusin" && o.current && a.preventDefault();
        }
      }
    );
  }
), JN = _.forwardRef(
  (e, t) => {
    const {
      __scopePopover: n,
      trapFocus: r,
      onOpenAutoFocus: o,
      onCloseAutoFocus: a,
      disableOutsidePointerEvents: s,
      onEscapeKeyDown: u,
      onPointerDownOutside: c,
      onFocusOutside: f,
      onInteractOutside: h,
      ...p
    } = e, g = la(_l, n), y = uf(n);
    return A1(), /* @__PURE__ */ x.jsx(
      rm,
      {
        asChild: !0,
        loop: !0,
        trapped: r,
        onMountAutoFocus: o,
        onUnmountAutoFocus: a,
        children: /* @__PURE__ */ x.jsx(
          nf,
          {
            asChild: !0,
            disableOutsidePointerEvents: s,
            onInteractOutside: h,
            onEscapeKeyDown: u,
            onPointerDownOutside: c,
            onFocusOutside: f,
            onDismiss: () => g.onOpenChange(!1),
            children: /* @__PURE__ */ x.jsx(
              UN,
              {
                "data-state": n2(g.open),
                role: "dialog",
                id: g.contentId,
                ...y,
                ...p,
                ref: t,
                style: {
                  ...p.style,
                  "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                }
              }
            )
          }
        )
      }
    );
  }
), e2 = "PopoverClose", fq = _.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, o = la(e2, n);
    return /* @__PURE__ */ x.jsx(
      qe.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: xe(e.onClick, () => o.onOpenChange(!1))
      }
    );
  }
);
fq.displayName = e2;
var dq = "PopoverArrow", t2 = _.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, o = uf(n);
    return /* @__PURE__ */ x.jsx(qN, { ...o, ...r, ref: t });
  }
);
t2.displayName = dq;
function n2(e) {
  return e ? "open" : "closed";
}
var r2 = YN, o2 = KN, i2 = ZN, a2 = QN, hq = t2;
const Ic = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
}, s2 = {};
for (const e of Object.keys(Ic))
  s2[Ic[e]] = e;
const ve = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  oklab: { channels: 3, labels: ["okl", "oka", "okb"] },
  lch: { channels: 3, labels: "lch" },
  oklch: { channels: 3, labels: ["okl", "okc", "okh"] },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] }
}, Jo = (6 / 29) ** 3;
function fl(e) {
  const t = e > 31308e-7 ? 1.055 * e ** 0.4166666666666667 - 0.055 : e * 12.92;
  return Math.min(Math.max(0, t), 1);
}
function dl(e) {
  return e > 0.04045 ? ((e + 0.055) / 1.055) ** 2.4 : e / 12.92;
}
for (const e of Object.keys(ve)) {
  if (!("channels" in ve[e]))
    throw new Error("missing channels property: " + e);
  if (!("labels" in ve[e]))
    throw new Error("missing channel labels property: " + e);
  if (ve[e].labels.length !== ve[e].channels)
    throw new Error("channel and label counts mismatch: " + e);
  const { channels: t, labels: n } = ve[e];
  delete ve[e].channels, delete ve[e].labels, Object.defineProperty(ve[e], "channels", { value: t }), Object.defineProperty(ve[e], "labels", { value: n });
}
ve.rgb.hsl = function(e) {
  const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.min(t, n, r), a = Math.max(t, n, r), s = a - o;
  let u, c;
  switch (a) {
    case o: {
      u = 0;
      break;
    }
    case t: {
      u = (n - r) / s;
      break;
    }
    case n: {
      u = 2 + (r - t) / s;
      break;
    }
    case r: {
      u = 4 + (t - n) / s;
      break;
    }
  }
  u = Math.min(u * 60, 360), u < 0 && (u += 360);
  const f = (o + a) / 2;
  return a === o ? c = 0 : f <= 0.5 ? c = s / (a + o) : c = s / (2 - a - o), [u, c * 100, f * 100];
};
ve.rgb.hsv = function(e) {
  let t, n, r, o, a;
  const s = e[0] / 255, u = e[1] / 255, c = e[2] / 255, f = Math.max(s, u, c), h = f - Math.min(s, u, c), p = function(g) {
    return (f - g) / 6 / h + 1 / 2;
  };
  if (h === 0)
    o = 0, a = 0;
  else {
    switch (a = h / f, t = p(s), n = p(u), r = p(c), f) {
      case s: {
        o = r - n;
        break;
      }
      case u: {
        o = 1 / 3 + t - r;
        break;
      }
      case c: {
        o = 2 / 3 + n - t;
        break;
      }
    }
    o < 0 ? o += 1 : o > 1 && (o -= 1);
  }
  return [
    o * 360,
    a * 100,
    f * 100
  ];
};
ve.rgb.hwb = function(e) {
  const t = e[0], n = e[1];
  let r = e[2];
  const o = ve.rgb.hsl(e)[0], a = 1 / 255 * Math.min(t, Math.min(n, r));
  return r = 1 - 1 / 255 * Math.max(t, Math.max(n, r)), [o, a * 100, r * 100];
};
ve.rgb.oklab = function(e) {
  const t = dl(e[0] / 255), n = dl(e[1] / 255), r = dl(e[2] / 255), o = Math.cbrt(0.4122214708 * t + 0.5363325363 * n + 0.0514459929 * r), a = Math.cbrt(0.2119034982 * t + 0.6806995451 * n + 0.1073969566 * r), s = Math.cbrt(0.0883024619 * t + 0.2817188376 * n + 0.6299787005 * r), u = 0.2104542553 * o + 0.793617785 * a - 0.0040720468 * s, c = 1.9779984951 * o - 2.428592205 * a + 0.4505937099 * s, f = 0.0259040371 * o + 0.7827717662 * a - 0.808675766 * s;
  return [u * 100, c * 100, f * 100];
};
ve.rgb.cmyk = function(e) {
  const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.min(1 - t, 1 - n, 1 - r), a = (1 - t - o) / (1 - o) || 0, s = (1 - n - o) / (1 - o) || 0, u = (1 - r - o) / (1 - o) || 0;
  return [a * 100, s * 100, u * 100, o * 100];
};
function pq(e, t) {
  return (e[0] - t[0]) ** 2 + (e[1] - t[1]) ** 2 + (e[2] - t[2]) ** 2;
}
ve.rgb.keyword = function(e) {
  const t = s2[e];
  if (t)
    return t;
  let n = Number.POSITIVE_INFINITY, r;
  for (const o of Object.keys(Ic)) {
    const a = Ic[o], s = pq(e, a);
    s < n && (n = s, r = o);
  }
  return r;
};
ve.keyword.rgb = function(e) {
  return Ic[e];
};
ve.rgb.xyz = function(e) {
  const t = dl(e[0] / 255), n = dl(e[1] / 255), r = dl(e[2] / 255), o = t * 0.4124564 + n * 0.3575761 + r * 0.1804375, a = t * 0.2126729 + n * 0.7151522 + r * 0.072175, s = t * 0.0193339 + n * 0.119192 + r * 0.9503041;
  return [o * 100, a * 100, s * 100];
};
ve.rgb.lab = function(e) {
  const t = ve.rgb.xyz(e);
  let n = t[0], r = t[1], o = t[2];
  n /= 95.047, r /= 100, o /= 108.883, n = n > Jo ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > Jo ? r ** (1 / 3) : 7.787 * r + 16 / 116, o = o > Jo ? o ** (1 / 3) : 7.787 * o + 16 / 116;
  const a = 116 * r - 16, s = 500 * (n - r), u = 200 * (r - o);
  return [a, s, u];
};
ve.hsl.rgb = function(e) {
  const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
  let o, a;
  if (n === 0)
    return a = r * 255, [a, a, a];
  const s = r < 0.5 ? r * (1 + n) : r + n - r * n, u = 2 * r - s, c = [0, 0, 0];
  for (let f = 0; f < 3; f++)
    o = t + 1 / 3 * -(f - 1), o < 0 && o++, o > 1 && o--, 6 * o < 1 ? a = u + (s - u) * 6 * o : 2 * o < 1 ? a = s : 3 * o < 2 ? a = u + (s - u) * (2 / 3 - o) * 6 : a = u, c[f] = a * 255;
  return c;
};
ve.hsl.hsv = function(e) {
  const t = e[0];
  let n = e[1] / 100, r = e[2] / 100, o = n;
  const a = Math.max(r, 0.01);
  r *= 2, n *= r <= 1 ? r : 2 - r, o *= a <= 1 ? a : 2 - a;
  const s = (r + n) / 2, u = r === 0 ? 2 * o / (a + o) : 2 * n / (r + n);
  return [t, u * 100, s * 100];
};
ve.hsv.rgb = function(e) {
  const t = e[0] / 60, n = e[1] / 100;
  let r = e[2] / 100;
  const o = Math.floor(t) % 6, a = t - Math.floor(t), s = 255 * r * (1 - n), u = 255 * r * (1 - n * a), c = 255 * r * (1 - n * (1 - a));
  switch (r *= 255, o) {
    case 0:
      return [r, c, s];
    case 1:
      return [u, r, s];
    case 2:
      return [s, r, c];
    case 3:
      return [s, u, r];
    case 4:
      return [c, s, r];
    case 5:
      return [r, s, u];
  }
};
ve.hsv.hsl = function(e) {
  const t = e[0], n = e[1] / 100, r = e[2] / 100, o = Math.max(r, 0.01);
  let a, s;
  s = (2 - n) * r;
  const u = (2 - n) * o;
  return a = n * o, a /= u <= 1 ? u : 2 - u, a = a || 0, s /= 2, [t, a * 100, s * 100];
};
ve.hwb.rgb = function(e) {
  const t = e[0] / 360;
  let n = e[1] / 100, r = e[2] / 100;
  const o = n + r;
  let a;
  o > 1 && (n /= o, r /= o);
  const s = Math.floor(6 * t), u = 1 - r;
  a = 6 * t - s, (s & 1) !== 0 && (a = 1 - a);
  const c = n + a * (u - n);
  let f, h, p;
  switch (s) {
    default:
    case 6:
    case 0: {
      f = u, h = c, p = n;
      break;
    }
    case 1: {
      f = c, h = u, p = n;
      break;
    }
    case 2: {
      f = n, h = u, p = c;
      break;
    }
    case 3: {
      f = n, h = c, p = u;
      break;
    }
    case 4: {
      f = c, h = n, p = u;
      break;
    }
    case 5: {
      f = u, h = n, p = c;
      break;
    }
  }
  return [f * 255, h * 255, p * 255];
};
ve.cmyk.rgb = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = e[3] / 100, a = 1 - Math.min(1, t * (1 - o) + o), s = 1 - Math.min(1, n * (1 - o) + o), u = 1 - Math.min(1, r * (1 - o) + o);
  return [a * 255, s * 255, u * 255];
};
ve.xyz.rgb = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100;
  let o, a, s;
  return o = t * 3.2404542 + n * -1.5371385 + r * -0.4985314, a = t * -0.969266 + n * 1.8760108 + r * 0.041556, s = t * 0.0556434 + n * -0.2040259 + r * 1.0572252, o = fl(o), a = fl(a), s = fl(s), [o * 255, a * 255, s * 255];
};
ve.xyz.lab = function(e) {
  let t = e[0], n = e[1], r = e[2];
  t /= 95.047, n /= 100, r /= 108.883, t = t > Jo ? t ** (1 / 3) : 7.787 * t + 16 / 116, n = n > Jo ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > Jo ? r ** (1 / 3) : 7.787 * r + 16 / 116;
  const o = 116 * n - 16, a = 500 * (t - n), s = 200 * (n - r);
  return [o, a, s];
};
ve.xyz.oklab = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = Math.cbrt(0.8189330101 * t + 0.3618667424 * n - 0.1288597137 * r), a = Math.cbrt(0.0329845436 * t + 0.9293118715 * n + 0.0361456387 * r), s = Math.cbrt(0.0482003018 * t + 0.2643662691 * n + 0.633851707 * r), u = 0.2104542553 * o + 0.793617785 * a - 0.0040720468 * s, c = 1.9779984951 * o - 2.428592205 * a + 0.4505937099 * s, f = 0.0259040371 * o + 0.7827717662 * a - 0.808675766 * s;
  return [u * 100, c * 100, f * 100];
};
ve.oklab.oklch = function(e) {
  return ve.lab.lch(e);
};
ve.oklab.xyz = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = (0.999999998 * t + 0.396337792 * n + 0.215803758 * r) ** 3, a = (1.000000008 * t - 0.105561342 * n - 0.063854175 * r) ** 3, s = (1.000000055 * t - 0.089484182 * n - 1.291485538 * r) ** 3, u = 1.227013851 * o - 0.55779998 * a + 0.281256149 * s, c = -0.040580178 * o + 1.11225687 * a - 0.071676679 * s, f = -0.076381285 * o - 0.421481978 * a + 1.58616322 * s;
  return [u * 100, c * 100, f * 100];
};
ve.oklab.rgb = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = (t + 0.3963377774 * n + 0.2158037573 * r) ** 3, a = (t - 0.1055613458 * n - 0.0638541728 * r) ** 3, s = (t - 0.0894841775 * n - 1.291485548 * r) ** 3, u = fl(4.0767416621 * o - 3.3077115913 * a + 0.2309699292 * s), c = fl(-1.2684380046 * o + 2.6097574011 * a - 0.3413193965 * s), f = fl(-0.0041960863 * o - 0.7034186147 * a + 1.707614701 * s);
  return [u * 255, c * 255, f * 255];
};
ve.oklch.oklab = function(e) {
  return ve.lch.lab(e);
};
ve.lab.xyz = function(e) {
  const t = e[0], n = e[1], r = e[2];
  let o, a, s;
  a = (t + 16) / 116, o = n / 500 + a, s = a - r / 200;
  const u = a ** 3, c = o ** 3, f = s ** 3;
  return a = u > Jo ? u : (a - 16 / 116) / 7.787, o = c > Jo ? c : (o - 16 / 116) / 7.787, s = f > Jo ? f : (s - 16 / 116) / 7.787, o *= 95.047, a *= 100, s *= 108.883, [o, a, s];
};
ve.lab.lch = function(e) {
  const t = e[0], n = e[1], r = e[2];
  let o;
  o = Math.atan2(r, n) * 360 / 2 / Math.PI, o < 0 && (o += 360);
  const s = Math.sqrt(n * n + r * r);
  return [t, s, o];
};
ve.lch.lab = function(e) {
  const t = e[0], n = e[1], o = e[2] / 360 * 2 * Math.PI, a = n * Math.cos(o), s = n * Math.sin(o);
  return [t, a, s];
};
ve.rgb.ansi16 = function(e, t = null) {
  const [n, r, o] = e;
  let a = t === null ? ve.rgb.hsv(e)[2] : t;
  if (a = Math.round(a / 50), a === 0)
    return 30;
  let s = 30 + (Math.round(o / 255) << 2 | Math.round(r / 255) << 1 | Math.round(n / 255));
  return a === 2 && (s += 60), s;
};
ve.hsv.ansi16 = function(e) {
  return ve.rgb.ansi16(ve.hsv.rgb(e), e[2]);
};
ve.rgb.ansi256 = function(e) {
  const t = e[0], n = e[1], r = e[2];
  return t >> 4 === n >> 4 && n >> 4 === r >> 4 ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(r / 255 * 5);
};
ve.ansi16.rgb = function(e) {
  e = e[0];
  let t = e % 10;
  if (t === 0 || t === 7)
    return e > 50 && (t += 3.5), t = t / 10.5 * 255, [t, t, t];
  const n = (Math.trunc(e > 50) + 1) * 0.5, r = (t & 1) * n * 255, o = (t >> 1 & 1) * n * 255, a = (t >> 2 & 1) * n * 255;
  return [r, o, a];
};
ve.ansi256.rgb = function(e) {
  if (e = e[0], e >= 232) {
    const a = (e - 232) * 10 + 8;
    return [a, a, a];
  }
  e -= 16;
  let t;
  const n = Math.floor(e / 36) / 5 * 255, r = Math.floor((t = e % 36) / 6) / 5 * 255, o = t % 6 / 5 * 255;
  return [n, r, o];
};
ve.rgb.hex = function(e) {
  const n = (((Math.round(e[0]) & 255) << 16) + ((Math.round(e[1]) & 255) << 8) + (Math.round(e[2]) & 255)).toString(16).toUpperCase();
  return "000000".slice(n.length) + n;
};
ve.hex.rgb = function(e) {
  const t = e.toString(16).match(/[a-f\d]{6}|[a-f\d]{3}/i);
  if (!t)
    return [0, 0, 0];
  let n = t[0];
  t[0].length === 3 && (n = [...n].map((u) => u + u).join(""));
  const r = Number.parseInt(n, 16), o = r >> 16 & 255, a = r >> 8 & 255, s = r & 255;
  return [o, a, s];
};
ve.rgb.hcg = function(e) {
  const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.max(Math.max(t, n), r), a = Math.min(Math.min(t, n), r), s = o - a;
  let u;
  const c = s < 1 ? a / (1 - s) : 0;
  return s <= 0 ? u = 0 : o === t ? u = (n - r) / s % 6 : o === n ? u = 2 + (r - t) / s : u = 4 + (t - n) / s, u /= 6, u %= 1, [u * 360, s * 100, c * 100];
};
ve.hsl.hcg = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = n < 0.5 ? 2 * t * n : 2 * t * (1 - n);
  let o = 0;
  return r < 1 && (o = (n - 0.5 * r) / (1 - r)), [e[0], r * 100, o * 100];
};
ve.hsv.hcg = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = t * n;
  let o = 0;
  return r < 1 && (o = (n - r) / (1 - r)), [e[0], r * 100, o * 100];
};
ve.hcg.rgb = function(e) {
  const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
  if (n === 0)
    return [r * 255, r * 255, r * 255];
  const o = [0, 0, 0], a = t % 1 * 6, s = a % 1, u = 1 - s;
  let c = 0;
  switch (Math.floor(a)) {
    case 0: {
      o[0] = 1, o[1] = s, o[2] = 0;
      break;
    }
    case 1: {
      o[0] = u, o[1] = 1, o[2] = 0;
      break;
    }
    case 2: {
      o[0] = 0, o[1] = 1, o[2] = s;
      break;
    }
    case 3: {
      o[0] = 0, o[1] = u, o[2] = 1;
      break;
    }
    case 4: {
      o[0] = s, o[1] = 0, o[2] = 1;
      break;
    }
    default:
      o[0] = 1, o[1] = 0, o[2] = u;
  }
  return c = (1 - n) * r, [
    (n * o[0] + c) * 255,
    (n * o[1] + c) * 255,
    (n * o[2] + c) * 255
  ];
};
ve.hcg.hsv = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = t + n * (1 - t);
  let o = 0;
  return r > 0 && (o = t / r), [e[0], o * 100, r * 100];
};
ve.hcg.hsl = function(e) {
  const t = e[1] / 100, r = e[2] / 100 * (1 - t) + 0.5 * t;
  let o = 0;
  return r > 0 && r < 0.5 ? o = t / (2 * r) : r >= 0.5 && r < 1 && (o = t / (2 * (1 - r))), [e[0], o * 100, r * 100];
};
ve.hcg.hwb = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = t + n * (1 - t);
  return [e[0], (r - t) * 100, (1 - r) * 100];
};
ve.hwb.hcg = function(e) {
  const t = e[1] / 100, r = 1 - e[2] / 100, o = r - t;
  let a = 0;
  return o < 1 && (a = (r - o) / (1 - o)), [e[0], o * 100, a * 100];
};
ve.apple.rgb = function(e) {
  return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255];
};
ve.rgb.apple = function(e) {
  return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535];
};
ve.gray.rgb = function(e) {
  return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255];
};
ve.gray.hsl = function(e) {
  return [0, 0, e[0]];
};
ve.gray.hsv = ve.gray.hsl;
ve.gray.hwb = function(e) {
  return [0, 100, e[0]];
};
ve.gray.cmyk = function(e) {
  return [0, 0, 0, e[0]];
};
ve.gray.lab = function(e) {
  return [e[0], 0, 0];
};
ve.gray.hex = function(e) {
  const t = Math.round(e[0] / 100 * 255) & 255, r = ((t << 16) + (t << 8) + t).toString(16).toUpperCase();
  return "000000".slice(r.length) + r;
};
ve.rgb.gray = function(e) {
  return [(e[0] + e[1] + e[2]) / 3 / 255 * 100];
};
function mq() {
  const e = {}, t = Object.keys(ve);
  for (let { length: n } = t, r = 0; r < n; r++)
    e[t[r]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  return e;
}
function gq(e) {
  const t = mq(), n = [e];
  for (t[e].distance = 0; n.length > 0; ) {
    const r = n.pop(), o = Object.keys(ve[r]);
    for (let { length: a } = o, s = 0; s < a; s++) {
      const u = o[s], c = t[u];
      c.distance === -1 && (c.distance = t[r].distance + 1, c.parent = r, n.unshift(u));
    }
  }
  return t;
}
function yq(e, t) {
  return function(n) {
    return t(e(n));
  };
}
function vq(e, t) {
  const n = [t[e].parent, e];
  let r = ve[t[e].parent][e], o = t[e].parent;
  for (; t[o].parent; )
    n.unshift(t[o].parent), r = yq(ve[t[o].parent][o], r), o = t[o].parent;
  return r.conversion = n, r;
}
function bq(e) {
  const t = gq(e), n = {}, r = Object.keys(t);
  for (let { length: o } = r, a = 0; a < o; a++) {
    const s = r[a];
    t[s].parent !== null && (n[s] = vq(s, t));
  }
  return n;
}
const Na = {}, xq = Object.keys(ve);
function wq(e) {
  const t = function(...n) {
    const r = n[0];
    return r == null ? r : (r.length > 1 && (n = r), e(n));
  };
  return "conversion" in e && (t.conversion = e.conversion), t;
}
function _q(e) {
  const t = function(...n) {
    const r = n[0];
    if (r == null)
      return r;
    r.length > 1 && (n = r);
    const o = e(n);
    if (typeof o == "object")
      for (let { length: a } = o, s = 0; s < a; s++)
        o[s] = Math.round(o[s]);
    return o;
  };
  return "conversion" in e && (t.conversion = e.conversion), t;
}
for (const e of xq) {
  Na[e] = {}, Object.defineProperty(Na[e], "channels", { value: ve[e].channels }), Object.defineProperty(Na[e], "labels", { value: ve[e].labels });
  const t = bq(e), n = Object.keys(t);
  for (const r of n) {
    const o = t[r];
    Na[e][r] = _q(o), Na[e][r].raw = wq(o);
  }
}
const Sq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Na
}, Symbol.toStringTag, { value: "Module" })), gn = (e, t) => {
  const n = Array.isArray(t) ? t : [t];
  if (n[0] === void 0 || n[0] === null)
    return gn("rgb", [0, 0, 0]);
  const r = Na[e];
  if (!r)
    throw new Error(
      `Unsupported color type: ${e} allowed are ${Object.keys(Sq).join(
        ", "
      )}`
    );
  r[e] = () => n;
  const o = (s) => {
    const u = s(...n);
    return Array.isArray(u) ? u[0] != null : u;
  };
  if (!o(r.rgb) || !o(r.hsl))
    return gn("rgb", [0, 0, 0]);
  const a = {};
  return Object.keys(r).forEach((s) => {
    const u = r[s];
    typeof u == "function" && (a[s] = () => s === e ? n : u(...n));
  }), a;
}, Eq = ({
  onChange: e,
  colorconverter: t,
  allow_null: n = !1
}) => {
  if (t === null && !n)
    throw new Error("Color converter is null");
  const [r, o] = _.useState(t), [a, s] = _.useState([0, 0, 0]), [u, c] = _.useState([0, 0, 0]), [f, h] = _.useState([0, 0, 0]), [p, g] = _.useState("000");
  _.useEffect(() => {
    if (!r) {
      if (!n) throw new Error("Color converter is null");
      c([0, 0, 0]), s([0, 0, 0]), h([0, 0, 0]), g("");
      return;
    }
    s(r.hsl()), c(r.rgb()), h(r.hsv()), g(r.hex());
  }, [r]);
  const y = {
    backgroundColor: `hsl(${a[0]}, ${a[1]}%, ${a[2]}%)`,
    padding: "10px",
    margin: "10px 0"
  };
  return /* @__PURE__ */ x.jsxs("div", { style: { backgroundColor: "white" }, children: [
    /* @__PURE__ */ x.jsx("div", { style: y, children: "Color Preview" }),
    /* @__PURE__ */ x.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ x.jsx("div", { className: "colorspace_title", children: "RGB" }),
      /* @__PURE__ */ x.jsx("div", {}),
      /* @__PURE__ */ x.jsx("label", { children: "Red" }),
      /* @__PURE__ */ x.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "255",
          value: u[0],
          onChange: (w) => {
            const v = [parseInt(w.target.value), u[1], u[2]], S = gn("rgb", v);
            o(S), e(S);
          },
          style: { background: "linear-gradient(to right, #000, #f00)" }
        }
      ),
      /* @__PURE__ */ x.jsx("label", { children: "Green" }),
      /* @__PURE__ */ x.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "255",
          value: u[1],
          onChange: (w) => {
            const v = [u[0], parseInt(w.target.value), u[2]], S = gn("rgb", v);
            o(S), e(S);
          },
          style: { background: "linear-gradient(to right, #000, #0f0)" }
        }
      ),
      /* @__PURE__ */ x.jsx("label", { children: "Blue" }),
      /* @__PURE__ */ x.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "255",
          value: u[2],
          onChange: (w) => {
            const v = [u[0], u[1], parseInt(w.target.value)], S = gn("rgb", v);
            o(S), e(S);
          },
          style: { background: "linear-gradient(to right, #000, #00f)" }
        }
      )
    ] }),
    /* @__PURE__ */ x.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ x.jsx("div", { className: "colorspace_title", children: "HSL" }),
      /* @__PURE__ */ x.jsx("div", {}),
      /* @__PURE__ */ x.jsx("label", { children: "Hue" }),
      /* @__PURE__ */ x.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "360",
          value: a[0],
          onChange: (w) => {
            const v = [parseInt(w.target.value), a[1], a[2]], S = gn("hsl", v);
            o(S), e(S);
          },
          style: {
            background: "linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)"
          }
        }
      ),
      /* @__PURE__ */ x.jsx("label", { children: "Saturation" }),
      /* @__PURE__ */ x.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: a[1],
          onChange: (w) => {
            const v = [a[0], parseInt(w.target.value), a[2]], S = gn("hsl", v);
            o(S), e(S);
          },
          style: {
            background: `linear-gradient(to right, #fff, hsl(${a[0]}, 100%, 50%))`
          }
        }
      ),
      /* @__PURE__ */ x.jsx("label", { children: "Lightness" }),
      /* @__PURE__ */ x.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: a[2],
          onChange: (w) => {
            const v = [a[0], a[1], parseInt(w.target.value)], S = gn("hsl", v);
            o(S), e(S);
          },
          style: {
            background: `linear-gradient(to right, #000, hsl(${a[0]}, 100%, 50%), #fff)`
          }
        }
      )
    ] }),
    /* @__PURE__ */ x.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ x.jsx("div", { className: "colorspace_title", children: "HSV" }),
      /* @__PURE__ */ x.jsx("div", {}),
      /* @__PURE__ */ x.jsx("label", { children: "Hue" }),
      /* @__PURE__ */ x.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "360",
          value: f[0],
          onChange: (w) => {
            const v = [parseInt(w.target.value), f[1], f[2]], S = gn("hsv", v);
            o(S), e(S);
          },
          style: {
            background: "linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)"
          }
        }
      ),
      /* @__PURE__ */ x.jsx("label", { children: "Saturation" }),
      /* @__PURE__ */ x.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: f[1],
          onChange: (w) => {
            const v = [f[0], parseInt(w.target.value), f[2]], S = gn("hsv", v);
            o(S), e(S);
          },
          style: {
            background: `linear-gradient(to right, #fff, hsl(${a[0]}, 100%, 50%))`
          }
        }
      ),
      /* @__PURE__ */ x.jsx("label", { children: "Value" }),
      /* @__PURE__ */ x.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: f[2],
          onChange: (w) => {
            const v = [f[0], f[1], parseInt(w.target.value)], S = gn("hsv", v);
            o(S), e(S);
          },
          style: {
            background: `linear-gradient(to right, #000, hsl(${a[0]}, 100%, 50%))`
          }
        }
      )
    ] }),
    /* @__PURE__ */ x.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ x.jsx("div", { className: "colorspace_title", children: "HEX" }),
      /* @__PURE__ */ x.jsx("div", {}),
      /* @__PURE__ */ x.jsx(
        "input",
        {
          type: "text",
          value: p,
          onChange: (w) => {
            const v = w.target.value === "" ? null : gn("hex", [w.target.value]);
            o(v), e(v);
          }
        }
      )
    ] })
  ] });
}, Cq = ({
  inicolordata: e,
  inicolorspace: t,
  allow_null: n = !1,
  delay: r = 1e3,
  onChange: o,
  portalContainer: a
}) => {
  const s = e !== void 0 ? e : [0, 0, 0], u = e === void 0 ? "rgb" : t || "hex", c = Array.isArray(s) ? s : [s], f = _.useMemo(() => {
    let v = gn(u, c);
    return v.rgb() === void 0 && (v = gn("rgb", [0, 0, 0])), v;
  }, [u, c]), [h, p] = _.useState(f);
  _.useEffect(() => {
    const v = e !== void 0 ? e : [0, 0, 0], S = e === void 0 ? "rgb" : t || "hex", E = Array.isArray(v) ? v : [v];
    let T = gn(S, E);
    T.rgb() === void 0 && (T = gn("rgb", [0, 0, 0])), p(T);
  }, [JSON.stringify(e), t]);
  const g = _.useRef(null), y = _.useCallback(
    (v) => {
      if (v === null && !n)
        throw new Error("Color is null");
      v !== null && p(v), g.current && clearTimeout(g.current), o && (g.current = setTimeout(() => {
        o(v), g.current = null;
      }, r));
    },
    [n, o, r]
  );
  _.useEffect(() => () => {
    g.current && clearTimeout(g.current);
  }, []);
  const w = _.useMemo(
    () => ({
      background: "#" + h.hex(),
      borderRadius: "0.3rem",
      width: "2rem",
      height: "1rem"
    }),
    [h]
  );
  return /* @__PURE__ */ x.jsxs(r2, { children: [
    /* @__PURE__ */ x.jsx(o2, { asChild: !0, children: /* @__PURE__ */ x.jsx("button", { style: w }) }),
    /* @__PURE__ */ x.jsx(i2, { container: a, children: /* @__PURE__ */ x.jsx(a2, { side: "left", className: "iotooltipcontent", children: /* @__PURE__ */ x.jsx(
      Eq,
      {
        onChange: y,
        colorconverter: h,
        allow_null: n
      }
    ) }) })
  ] });
};
function Wa(e) {
  "@babel/helpers - typeof";
  return Wa = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Wa(e);
}
function kq(e, t) {
  if (Wa(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Wa(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function l2(e) {
  var t = kq(e, "string");
  return Wa(t) == "symbol" ? t : t + "";
}
function dc(e, t, n) {
  return (t = l2(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function rT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Me(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rT(Object(n), !0).forEach(function(r) {
      dc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Tq(e) {
  if (Array.isArray(e)) return e;
}
function Aq(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r, o, a, s, u = [], c = !0, f = !1;
    try {
      if (a = (n = n.call(e)).next, t === 0) {
        if (Object(n) !== n) return;
        c = !1;
      } else for (; !(c = (r = a.call(n)).done) && (u.push(r.value), u.length !== t); c = !0) ;
    } catch (h) {
      f = !0, o = h;
    } finally {
      try {
        if (!c && n.return != null && (s = n.return(), Object(s) !== s)) return;
      } finally {
        if (f) throw o;
      }
    }
    return u;
  }
}
function gb(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function u2(e, t) {
  if (e) {
    if (typeof e == "string") return gb(e, t);
    var n = {}.toString.call(e).slice(8, -1);
    return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? gb(e, t) : void 0;
  }
}
function Rq() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ei(e, t) {
  return Tq(e) || Aq(e, t) || u2(e, t) || Rq();
}
function fi(e, t) {
  if (e == null) return {};
  var n, r, o = S1(e, t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    for (r = 0; r < a.length; r++) n = a[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var Mq = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function Oq(e) {
  var t = e.defaultInputValue, n = t === void 0 ? "" : t, r = e.defaultMenuIsOpen, o = r === void 0 ? !1 : r, a = e.defaultValue, s = a === void 0 ? null : a, u = e.inputValue, c = e.menuIsOpen, f = e.onChange, h = e.onInputChange, p = e.onMenuClose, g = e.onMenuOpen, y = e.value, w = fi(e, Mq), v = _.useState(u !== void 0 ? u : n), S = ei(v, 2), E = S[0], T = S[1], k = _.useState(c !== void 0 ? c : o), A = ei(k, 2), M = A[0], N = A[1], P = _.useState(y !== void 0 ? y : s), z = ei(P, 2), B = z[0], R = z[1], F = _.useCallback(function(q, G) {
    typeof f == "function" && f(q, G), R(q);
  }, [f]), U = _.useCallback(function(q, G) {
    var O;
    typeof h == "function" && (O = h(q, G)), T(O !== void 0 ? O : q);
  }, [h]), W = _.useCallback(function() {
    typeof g == "function" && g(), N(!0);
  }, [g]), j = _.useCallback(function() {
    typeof p == "function" && p(), N(!1);
  }, [p]), V = u !== void 0 ? u : E, I = c !== void 0 ? c : M, H = y !== void 0 ? y : B;
  return Me(Me({}, w), {}, {
    inputValue: V,
    menuIsOpen: I,
    onChange: F,
    onInputChange: U,
    onMenuClose: j,
    onMenuOpen: W,
    value: H
  });
}
function Nq(e, t) {
  if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
}
function oT(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, l2(r.key), r);
  }
}
function Dq(e, t, n) {
  return t && oT(e.prototype, t), n && oT(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function Pq(e, t) {
  if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && Zh(e, t);
}
function up(e) {
  return up = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, up(e);
}
function c2() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (c2 = function() {
    return !!e;
  })();
}
function jq(e, t) {
  if (t && (Wa(t) == "object" || typeof t == "function")) return t;
  if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return PM(e);
}
function Iq(e) {
  var t = c2();
  return function() {
    var n, r = up(e);
    if (t) {
      var o = up(this).constructor;
      n = Reflect.construct(r, arguments, o);
    } else n = r.apply(this, arguments);
    return jq(this, n);
  };
}
function zq(e) {
  if (Array.isArray(e)) return gb(e);
}
function Lq(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function Fq() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ix(e) {
  return zq(e) || Lq(e) || u2(e) || Fq();
}
function $q(e, t) {
  return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {
    raw: {
      value: Object.freeze(t)
    }
  }));
}
var yb = _.useLayoutEffect, Bq = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"], cp = function() {
};
function Hq(e, t) {
  return t ? t[0] === "-" ? e + t : e + "__" + t : e;
}
function Vq(e, t) {
  for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++)
    r[o - 2] = arguments[o];
  var a = [].concat(r);
  if (t && e)
    for (var s in t)
      t.hasOwnProperty(s) && t[s] && a.push("".concat(Hq(e, s)));
  return a.filter(function(u) {
    return u;
  }).map(function(u) {
    return String(u).trim();
  }).join(" ");
}
var iT = function(t) {
  return Qq(t) ? t.filter(Boolean) : Wa(t) === "object" && t !== null ? [t] : [];
}, f2 = function(t) {
  t.className, t.clearValue, t.cx, t.getStyles, t.getClassNames, t.getValue, t.hasValue, t.isMulti, t.isRtl, t.options, t.selectOption, t.selectProps, t.setValue, t.theme;
  var n = fi(t, Bq);
  return Me({}, n);
}, Pt = function(t, n, r) {
  var o = t.cx, a = t.getStyles, s = t.getClassNames, u = t.className;
  return {
    css: a(n, t),
    className: o(r ?? {}, s(n, t), u)
  };
};
function bm(e) {
  return [document.documentElement, document.body, window].indexOf(e) > -1;
}
function Uq(e) {
  return bm(e) ? window.innerHeight : e.clientHeight;
}
function d2(e) {
  return bm(e) ? window.pageYOffset : e.scrollTop;
}
function fp(e, t) {
  if (bm(e)) {
    window.scrollTo(0, t);
    return;
  }
  e.scrollTop = t;
}
function qq(e) {
  var t = getComputedStyle(e), n = t.position === "absolute", r = /(auto|scroll)/;
  if (t.position === "fixed") return document.documentElement;
  for (var o = e; o = o.parentElement; )
    if (t = getComputedStyle(o), !(n && t.position === "static") && r.test(t.overflow + t.overflowY + t.overflowX))
      return o;
  return document.documentElement;
}
function Gq(e, t, n, r) {
  return n * ((e = e / r - 1) * e * e + 1) + t;
}
function ih(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : cp, o = d2(e), a = t - o, s = 10, u = 0;
  function c() {
    u += s;
    var f = Gq(u, o, a, n);
    fp(e, f), u < n ? window.requestAnimationFrame(c) : r(e);
  }
  c();
}
function aT(e, t) {
  var n = e.getBoundingClientRect(), r = t.getBoundingClientRect(), o = t.offsetHeight / 3;
  r.bottom + o > n.bottom ? fp(e, Math.min(t.offsetTop + t.clientHeight - e.offsetHeight + o, e.scrollHeight)) : r.top - o < n.top && fp(e, Math.max(t.offsetTop - o, 0));
}
function Yq(e) {
  var t = e.getBoundingClientRect();
  return {
    bottom: t.bottom,
    height: t.height,
    left: t.left,
    right: t.right,
    top: t.top,
    width: t.width
  };
}
function sT() {
  try {
    return document.createEvent("TouchEvent"), !0;
  } catch {
    return !1;
  }
}
function Wq() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch {
    return !1;
  }
}
var h2 = !1, Xq = {
  get passive() {
    return h2 = !0;
  }
}, ah = typeof window < "u" ? window : {};
ah.addEventListener && ah.removeEventListener && (ah.addEventListener("p", cp, Xq), ah.removeEventListener("p", cp, !1));
var Kq = h2;
function Zq(e) {
  return e != null;
}
function Qq(e) {
  return Array.isArray(e);
}
function sh(e, t, n) {
  return e ? t : n;
}
var Jq = function(t) {
  for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)
    r[o - 1] = arguments[o];
  var a = Object.entries(t).filter(function(s) {
    var u = ei(s, 1), c = u[0];
    return !r.includes(c);
  });
  return a.reduce(function(s, u) {
    var c = ei(u, 2), f = c[0], h = c[1];
    return s[f] = h, s;
  }, {});
}, eG = ["children", "innerProps"], tG = ["children", "innerProps"];
function nG(e) {
  var t = e.maxHeight, n = e.menuEl, r = e.minHeight, o = e.placement, a = e.shouldScroll, s = e.isFixedPosition, u = e.controlHeight, c = qq(n), f = {
    placement: "bottom",
    maxHeight: t
  };
  if (!n || !n.offsetParent) return f;
  var h = c.getBoundingClientRect(), p = h.height, g = n.getBoundingClientRect(), y = g.bottom, w = g.height, v = g.top, S = n.offsetParent.getBoundingClientRect(), E = S.top, T = s ? window.innerHeight : Uq(c), k = d2(c), A = parseInt(getComputedStyle(n).marginBottom, 10), M = parseInt(getComputedStyle(n).marginTop, 10), N = E - M, P = T - v, z = N + k, B = p - k - v, R = y - T + k + A, F = k + v - M, U = 160;
  switch (o) {
    case "auto":
    case "bottom":
      if (P >= w)
        return {
          placement: "bottom",
          maxHeight: t
        };
      if (B >= w && !s)
        return a && ih(c, R, U), {
          placement: "bottom",
          maxHeight: t
        };
      if (!s && B >= r || s && P >= r) {
        a && ih(c, R, U);
        var W = s ? P - A : B - A;
        return {
          placement: "bottom",
          maxHeight: W
        };
      }
      if (o === "auto" || s) {
        var j = t, V = s ? N : z;
        return V >= r && (j = Math.min(V - A - u, t)), {
          placement: "top",
          maxHeight: j
        };
      }
      if (o === "bottom")
        return a && fp(c, R), {
          placement: "bottom",
          maxHeight: t
        };
      break;
    case "top":
      if (N >= w)
        return {
          placement: "top",
          maxHeight: t
        };
      if (z >= w && !s)
        return a && ih(c, F, U), {
          placement: "top",
          maxHeight: t
        };
      if (!s && z >= r || s && N >= r) {
        var I = t;
        return (!s && z >= r || s && N >= r) && (I = s ? N - M : z - M), a && ih(c, F, U), {
          placement: "top",
          maxHeight: I
        };
      }
      return {
        placement: "bottom",
        maxHeight: t
      };
    default:
      throw new Error('Invalid placement provided "'.concat(o, '".'));
  }
  return f;
}
function rG(e) {
  var t = {
    bottom: "top",
    top: "bottom"
  };
  return e ? t[e] : "bottom";
}
var p2 = function(t) {
  return t === "auto" ? "bottom" : t;
}, oG = function(t, n) {
  var r, o = t.placement, a = t.theme, s = a.borderRadius, u = a.spacing, c = a.colors;
  return Me((r = {
    label: "menu"
  }, dc(r, rG(o), "100%"), dc(r, "position", "absolute"), dc(r, "width", "100%"), dc(r, "zIndex", 1), r), n ? {} : {
    backgroundColor: c.neutral0,
    borderRadius: s,
    boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
    marginBottom: u.menuGutter,
    marginTop: u.menuGutter
  });
}, m2 = /* @__PURE__ */ _.createContext(null), iG = function(t) {
  var n = t.children, r = t.minMenuHeight, o = t.maxMenuHeight, a = t.menuPlacement, s = t.menuPosition, u = t.menuShouldScrollIntoView, c = t.theme, f = _.useContext(m2) || {}, h = f.setPortalPlacement, p = _.useRef(null), g = _.useState(o), y = ei(g, 2), w = y[0], v = y[1], S = _.useState(null), E = ei(S, 2), T = E[0], k = E[1], A = c.spacing.controlHeight;
  return yb(function() {
    var M = p.current;
    if (M) {
      var N = s === "fixed", P = u && !N, z = nG({
        maxHeight: o,
        menuEl: M,
        minHeight: r,
        placement: a,
        shouldScroll: P,
        isFixedPosition: N,
        controlHeight: A
      });
      v(z.maxHeight), k(z.placement), h?.(z.placement);
    }
  }, [o, a, s, u, r, h, A]), n({
    ref: p,
    placerProps: Me(Me({}, t), {}, {
      placement: T || p2(a),
      maxHeight: w
    })
  });
}, aG = function(t) {
  var n = t.children, r = t.innerRef, o = t.innerProps;
  return ke("div", Re({}, Pt(t, "menu", {
    menu: !0
  }), {
    ref: r
  }, o), n);
}, sG = aG, lG = function(t, n) {
  var r = t.maxHeight, o = t.theme.spacing.baseUnit;
  return Me({
    maxHeight: r,
    overflowY: "auto",
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }, n ? {} : {
    paddingBottom: o,
    paddingTop: o
  });
}, uG = function(t) {
  var n = t.children, r = t.innerProps, o = t.innerRef, a = t.isMulti;
  return ke("div", Re({}, Pt(t, "menuList", {
    "menu-list": !0,
    "menu-list--is-multi": a
  }), {
    ref: o
  }, r), n);
}, g2 = function(t, n) {
  var r = t.theme, o = r.spacing.baseUnit, a = r.colors;
  return Me({
    textAlign: "center"
  }, n ? {} : {
    color: a.neutral40,
    padding: "".concat(o * 2, "px ").concat(o * 3, "px")
  });
}, cG = g2, fG = g2, dG = function(t) {
  var n = t.children, r = n === void 0 ? "No options" : n, o = t.innerProps, a = fi(t, eG);
  return ke("div", Re({}, Pt(Me(Me({}, a), {}, {
    children: r,
    innerProps: o
  }), "noOptionsMessage", {
    "menu-notice": !0,
    "menu-notice--no-options": !0
  }), o), r);
}, hG = function(t) {
  var n = t.children, r = n === void 0 ? "Loading..." : n, o = t.innerProps, a = fi(t, tG);
  return ke("div", Re({}, Pt(Me(Me({}, a), {}, {
    children: r,
    innerProps: o
  }), "loadingMessage", {
    "menu-notice": !0,
    "menu-notice--loading": !0
  }), o), r);
}, pG = function(t) {
  var n = t.rect, r = t.offset, o = t.position;
  return {
    left: n.left,
    position: o,
    top: r,
    width: n.width,
    zIndex: 1
  };
}, mG = function(t) {
  var n = t.appendTo, r = t.children, o = t.controlElement, a = t.innerProps, s = t.menuPlacement, u = t.menuPosition, c = _.useRef(null), f = _.useRef(null), h = _.useState(p2(s)), p = ei(h, 2), g = p[0], y = p[1], w = _.useMemo(function() {
    return {
      setPortalPlacement: y
    };
  }, []), v = _.useState(null), S = ei(v, 2), E = S[0], T = S[1], k = _.useCallback(function() {
    if (o) {
      var P = Yq(o), z = u === "fixed" ? 0 : window.pageYOffset, B = P[g] + z;
      (B !== E?.offset || P.left !== E?.rect.left || P.width !== E?.rect.width) && T({
        offset: B,
        rect: P
      });
    }
  }, [o, u, g, E?.offset, E?.rect.left, E?.rect.width]);
  yb(function() {
    k();
  }, [k]);
  var A = _.useCallback(function() {
    typeof f.current == "function" && (f.current(), f.current = null), o && c.current && (f.current = ON(o, c.current, k, {
      elementResize: "ResizeObserver" in window
    }));
  }, [o, k]);
  yb(function() {
    A();
  }, [A]);
  var M = _.useCallback(function(P) {
    c.current = P, A();
  }, [A]);
  if (!n && u !== "fixed" || !E) return null;
  var N = ke("div", Re({
    ref: M
  }, Pt(Me(Me({}, t), {}, {
    offset: E.offset,
    position: u,
    rect: E.rect
  }), "menuPortal", {
    "menu-portal": !0
  }), a), r);
  return ke(m2.Provider, {
    value: w
  }, n ? /* @__PURE__ */ Dl.createPortal(N, n) : N);
}, gG = function(t) {
  var n = t.isDisabled, r = t.isRtl;
  return {
    label: "container",
    direction: r ? "rtl" : void 0,
    pointerEvents: n ? "none" : void 0,
    // cancel mouse events when disabled
    position: "relative"
  };
}, yG = function(t) {
  var n = t.children, r = t.innerProps, o = t.isDisabled, a = t.isRtl;
  return ke("div", Re({}, Pt(t, "container", {
    "--is-disabled": o,
    "--is-rtl": a
  }), r), n);
}, vG = function(t, n) {
  var r = t.theme.spacing, o = t.isMulti, a = t.hasValue, s = t.selectProps.controlShouldRenderValue;
  return Me({
    alignItems: "center",
    display: o && a && s ? "flex" : "grid",
    flex: 1,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, n ? {} : {
    padding: "".concat(r.baseUnit / 2, "px ").concat(r.baseUnit * 2, "px")
  });
}, bG = function(t) {
  var n = t.children, r = t.innerProps, o = t.isMulti, a = t.hasValue;
  return ke("div", Re({}, Pt(t, "valueContainer", {
    "value-container": !0,
    "value-container--is-multi": o,
    "value-container--has-value": a
  }), r), n);
}, xG = function() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
}, wG = function(t) {
  var n = t.children, r = t.innerProps;
  return ke("div", Re({}, Pt(t, "indicatorsContainer", {
    indicators: !0
  }), r), n);
}, lT, _G = ["size"], SG = ["innerProps", "isRtl", "size"], EG = {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
}, y2 = function(t) {
  var n = t.size, r = fi(t, _G);
  return ke("svg", Re({
    height: n,
    width: n,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: EG
  }, r));
}, ax = function(t) {
  return ke(y2, Re({
    size: 20
  }, t), ke("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
}, v2 = function(t) {
  return ke(y2, Re({
    size: 20
  }, t), ke("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
}, b2 = function(t, n) {
  var r = t.isFocused, o = t.theme, a = o.spacing.baseUnit, s = o.colors;
  return Me({
    label: "indicatorContainer",
    display: "flex",
    transition: "color 150ms"
  }, n ? {} : {
    color: r ? s.neutral60 : s.neutral20,
    padding: a * 2,
    ":hover": {
      color: r ? s.neutral80 : s.neutral40
    }
  });
}, CG = b2, kG = function(t) {
  var n = t.children, r = t.innerProps;
  return ke("div", Re({}, Pt(t, "dropdownIndicator", {
    indicator: !0,
    "dropdown-indicator": !0
  }), r), n || ke(v2, null));
}, TG = b2, AG = function(t) {
  var n = t.children, r = t.innerProps;
  return ke("div", Re({}, Pt(t, "clearIndicator", {
    indicator: !0,
    "clear-indicator": !0
  }), r), n || ke(ax, null));
}, RG = function(t, n) {
  var r = t.isDisabled, o = t.theme, a = o.spacing.baseUnit, s = o.colors;
  return Me({
    label: "indicatorSeparator",
    alignSelf: "stretch",
    width: 1
  }, n ? {} : {
    backgroundColor: r ? s.neutral10 : s.neutral20,
    marginBottom: a * 2,
    marginTop: a * 2
  });
}, MG = function(t) {
  var n = t.innerProps;
  return ke("span", Re({}, n, Pt(t, "indicatorSeparator", {
    "indicator-separator": !0
  })));
}, OG = Zp(lT || (lT = $q([`
  0%, 80%, 100% { opacity: 0; }
  40% { opacity: 1; }
`]))), NG = function(t, n) {
  var r = t.isFocused, o = t.size, a = t.theme, s = a.colors, u = a.spacing.baseUnit;
  return Me({
    label: "loadingIndicator",
    display: "flex",
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: o,
    lineHeight: 1,
    marginRight: o,
    textAlign: "center",
    verticalAlign: "middle"
  }, n ? {} : {
    color: r ? s.neutral60 : s.neutral20,
    padding: u * 2
  });
}, Yy = function(t) {
  var n = t.delay, r = t.offset;
  return ke("span", {
    css: /* @__PURE__ */ x1({
      animation: "".concat(OG, " 1s ease-in-out ").concat(n, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: r ? "1em" : void 0,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, "", "")
  });
}, DG = function(t) {
  var n = t.innerProps, r = t.isRtl, o = t.size, a = o === void 0 ? 4 : o, s = fi(t, SG);
  return ke("div", Re({}, Pt(Me(Me({}, s), {}, {
    innerProps: n,
    isRtl: r,
    size: a
  }), "loadingIndicator", {
    indicator: !0,
    "loading-indicator": !0
  }), n), ke(Yy, {
    delay: 0,
    offset: r
  }), ke(Yy, {
    delay: 160,
    offset: !0
  }), ke(Yy, {
    delay: 320,
    offset: !r
  }));
}, PG = function(t, n) {
  var r = t.isDisabled, o = t.isFocused, a = t.theme, s = a.colors, u = a.borderRadius, c = a.spacing;
  return Me({
    label: "control",
    alignItems: "center",
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: c.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms"
  }, n ? {} : {
    backgroundColor: r ? s.neutral5 : s.neutral0,
    borderColor: r ? s.neutral10 : o ? s.primary : s.neutral20,
    borderRadius: u,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: o ? "0 0 0 1px ".concat(s.primary) : void 0,
    "&:hover": {
      borderColor: o ? s.primary : s.neutral30
    }
  });
}, jG = function(t) {
  var n = t.children, r = t.isDisabled, o = t.isFocused, a = t.innerRef, s = t.innerProps, u = t.menuIsOpen;
  return ke("div", Re({
    ref: a
  }, Pt(t, "control", {
    control: !0,
    "control--is-disabled": r,
    "control--is-focused": o,
    "control--menu-is-open": u
  }), s, {
    "aria-disabled": r || void 0
  }), n);
}, IG = jG, zG = ["data"], LG = function(t, n) {
  var r = t.theme.spacing;
  return n ? {} : {
    paddingBottom: r.baseUnit * 2,
    paddingTop: r.baseUnit * 2
  };
}, FG = function(t) {
  var n = t.children, r = t.cx, o = t.getStyles, a = t.getClassNames, s = t.Heading, u = t.headingProps, c = t.innerProps, f = t.label, h = t.theme, p = t.selectProps;
  return ke("div", Re({}, Pt(t, "group", {
    group: !0
  }), c), ke(s, Re({}, u, {
    selectProps: p,
    theme: h,
    getStyles: o,
    getClassNames: a,
    cx: r
  }), f), ke("div", null, n));
}, $G = function(t, n) {
  var r = t.theme, o = r.colors, a = r.spacing;
  return Me({
    label: "group",
    cursor: "default",
    display: "block"
  }, n ? {} : {
    color: o.neutral40,
    fontSize: "75%",
    fontWeight: 500,
    marginBottom: "0.25em",
    paddingLeft: a.baseUnit * 3,
    paddingRight: a.baseUnit * 3,
    textTransform: "uppercase"
  });
}, BG = function(t) {
  var n = f2(t);
  n.data;
  var r = fi(n, zG);
  return ke("div", Re({}, Pt(t, "groupHeading", {
    "group-heading": !0
  }), r));
}, HG = FG, VG = ["innerRef", "isDisabled", "isHidden", "inputClassName"], UG = function(t, n) {
  var r = t.isDisabled, o = t.value, a = t.theme, s = a.spacing, u = a.colors;
  return Me(Me({
    visibility: r ? "hidden" : "visible",
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: o ? "translateZ(0)" : ""
  }, qG), n ? {} : {
    margin: s.baseUnit / 2,
    paddingBottom: s.baseUnit / 2,
    paddingTop: s.baseUnit / 2,
    color: u.neutral80
  });
}, x2 = {
  gridArea: "1 / 2",
  font: "inherit",
  minWidth: "2px",
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
}, qG = {
  flex: "1 1 auto",
  display: "inline-grid",
  gridArea: "1 / 1 / 2 / 3",
  gridTemplateColumns: "0 min-content",
  "&:after": Me({
    content: 'attr(data-value) " "',
    visibility: "hidden",
    whiteSpace: "pre"
  }, x2)
}, GG = function(t) {
  return Me({
    label: "input",
    color: "inherit",
    background: 0,
    opacity: t ? 0 : 1,
    width: "100%"
  }, x2);
}, YG = function(t) {
  var n = t.cx, r = t.value, o = f2(t), a = o.innerRef, s = o.isDisabled, u = o.isHidden, c = o.inputClassName, f = fi(o, VG);
  return ke("div", Re({}, Pt(t, "input", {
    "input-container": !0
  }), {
    "data-value": r || ""
  }), ke("input", Re({
    className: n({
      input: !0
    }, c),
    ref: a,
    style: GG(u),
    disabled: s
  }, f)));
}, WG = YG, XG = function(t, n) {
  var r = t.theme, o = r.spacing, a = r.borderRadius, s = r.colors;
  return Me({
    label: "multiValue",
    display: "flex",
    minWidth: 0
  }, n ? {} : {
    backgroundColor: s.neutral10,
    borderRadius: a / 2,
    margin: o.baseUnit / 2
  });
}, KG = function(t, n) {
  var r = t.theme, o = r.borderRadius, a = r.colors, s = t.cropWithEllipsis;
  return Me({
    overflow: "hidden",
    textOverflow: s || s === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, n ? {} : {
    borderRadius: o / 2,
    color: a.neutral80,
    fontSize: "85%",
    padding: 3,
    paddingLeft: 6
  });
}, ZG = function(t, n) {
  var r = t.theme, o = r.spacing, a = r.borderRadius, s = r.colors, u = t.isFocused;
  return Me({
    alignItems: "center",
    display: "flex"
  }, n ? {} : {
    borderRadius: a / 2,
    backgroundColor: u ? s.dangerLight : void 0,
    paddingLeft: o.baseUnit,
    paddingRight: o.baseUnit,
    ":hover": {
      backgroundColor: s.dangerLight,
      color: s.danger
    }
  });
}, w2 = function(t) {
  var n = t.children, r = t.innerProps;
  return ke("div", r, n);
}, QG = w2, JG = w2;
function eY(e) {
  var t = e.children, n = e.innerProps;
  return ke("div", Re({
    role: "button"
  }, n), t || ke(ax, {
    size: 14
  }));
}
var tY = function(t) {
  var n = t.children, r = t.components, o = t.data, a = t.innerProps, s = t.isDisabled, u = t.removeProps, c = t.selectProps, f = r.Container, h = r.Label, p = r.Remove;
  return ke(f, {
    data: o,
    innerProps: Me(Me({}, Pt(t, "multiValue", {
      "multi-value": !0,
      "multi-value--is-disabled": s
    })), a),
    selectProps: c
  }, ke(h, {
    data: o,
    innerProps: Me({}, Pt(t, "multiValueLabel", {
      "multi-value__label": !0
    })),
    selectProps: c
  }, n), ke(p, {
    data: o,
    innerProps: Me(Me({}, Pt(t, "multiValueRemove", {
      "multi-value__remove": !0
    })), {}, {
      "aria-label": "Remove ".concat(n || "option")
    }, u),
    selectProps: c
  }));
}, nY = tY, rY = function(t, n) {
  var r = t.isDisabled, o = t.isFocused, a = t.isSelected, s = t.theme, u = s.spacing, c = s.colors;
  return Me({
    label: "option",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
  }, n ? {} : {
    backgroundColor: a ? c.primary : o ? c.primary25 : "transparent",
    color: r ? c.neutral20 : a ? c.neutral0 : "inherit",
    padding: "".concat(u.baseUnit * 2, "px ").concat(u.baseUnit * 3, "px"),
    // provide some affordance on touch devices
    ":active": {
      backgroundColor: r ? void 0 : a ? c.primary : c.primary50
    }
  });
}, oY = function(t) {
  var n = t.children, r = t.isDisabled, o = t.isFocused, a = t.isSelected, s = t.innerRef, u = t.innerProps;
  return ke("div", Re({}, Pt(t, "option", {
    option: !0,
    "option--is-disabled": r,
    "option--is-focused": o,
    "option--is-selected": a
  }), {
    ref: s,
    "aria-disabled": r
  }, u), n);
}, iY = oY, aY = function(t, n) {
  var r = t.theme, o = r.spacing, a = r.colors;
  return Me({
    label: "placeholder",
    gridArea: "1 / 1 / 2 / 3"
  }, n ? {} : {
    color: a.neutral50,
    marginLeft: o.baseUnit / 2,
    marginRight: o.baseUnit / 2
  });
}, sY = function(t) {
  var n = t.children, r = t.innerProps;
  return ke("div", Re({}, Pt(t, "placeholder", {
    placeholder: !0
  }), r), n);
}, lY = sY, uY = function(t, n) {
  var r = t.isDisabled, o = t.theme, a = o.spacing, s = o.colors;
  return Me({
    label: "singleValue",
    gridArea: "1 / 1 / 2 / 3",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, n ? {} : {
    color: r ? s.neutral40 : s.neutral80,
    marginLeft: a.baseUnit / 2,
    marginRight: a.baseUnit / 2
  });
}, cY = function(t) {
  var n = t.children, r = t.isDisabled, o = t.innerProps;
  return ke("div", Re({}, Pt(t, "singleValue", {
    "single-value": !0,
    "single-value--is-disabled": r
  }), o), n);
}, fY = cY, dY = {
  ClearIndicator: AG,
  Control: IG,
  DropdownIndicator: kG,
  DownChevron: v2,
  CrossIcon: ax,
  Group: HG,
  GroupHeading: BG,
  IndicatorsContainer: wG,
  IndicatorSeparator: MG,
  Input: WG,
  LoadingIndicator: DG,
  Menu: sG,
  MenuList: uG,
  MenuPortal: mG,
  LoadingMessage: hG,
  NoOptionsMessage: dG,
  MultiValue: nY,
  MultiValueContainer: QG,
  MultiValueLabel: JG,
  MultiValueRemove: eY,
  Option: iY,
  Placeholder: lY,
  SelectContainer: yG,
  SingleValue: fY,
  ValueContainer: bG
}, hY = function(t) {
  return Me(Me({}, dY), t.components);
}, uT = Number.isNaN || function(t) {
  return typeof t == "number" && t !== t;
};
function pY(e, t) {
  return !!(e === t || uT(e) && uT(t));
}
function mY(e, t) {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++)
    if (!pY(e[n], t[n]))
      return !1;
  return !0;
}
function gY(e, t) {
  t === void 0 && (t = mY);
  var n = null;
  function r() {
    for (var o = [], a = 0; a < arguments.length; a++)
      o[a] = arguments[a];
    if (n && n.lastThis === this && t(o, n.lastArgs))
      return n.lastResult;
    var s = e.apply(this, o);
    return n = {
      lastResult: s,
      lastArgs: o,
      lastThis: this
    }, s;
  }
  return r.clear = function() {
    n = null;
  }, r;
}
var yY = {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
}, vY = function(t) {
  return ke("span", Re({
    css: yY
  }, t));
}, cT = vY, bY = {
  guidance: function(t) {
    var n = t.isSearchable, r = t.isMulti, o = t.tabSelectsValue, a = t.context, s = t.isInitialFocus;
    switch (a) {
      case "menu":
        return "Use Up and Down to choose options, press Enter to select the currently focused option, press Escape to exit the menu".concat(o ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return s ? "".concat(t["aria-label"] || "Select", " is focused ").concat(n ? ",type to refine list" : "", ", press Down to open the menu, ").concat(r ? " press left to focus selected values" : "") : "";
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  },
  onChange: function(t) {
    var n = t.action, r = t.label, o = r === void 0 ? "" : r, a = t.labels, s = t.isDisabled;
    switch (n) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(o, ", deselected.");
      case "clear":
        return "All selected options have been cleared.";
      case "initial-input-focus":
        return "option".concat(a.length > 1 ? "s" : "", " ").concat(a.join(","), ", selected.");
      case "select-option":
        return s ? "option ".concat(o, " is disabled. Select another option.") : "option ".concat(o, ", selected.");
      default:
        return "";
    }
  },
  onFocus: function(t) {
    var n = t.context, r = t.focused, o = t.options, a = t.label, s = a === void 0 ? "" : a, u = t.selectValue, c = t.isDisabled, f = t.isSelected, h = t.isAppleDevice, p = function(v, S) {
      return v && v.length ? "".concat(v.indexOf(S) + 1, " of ").concat(v.length) : "";
    };
    if (n === "value" && u)
      return "value ".concat(s, " focused, ").concat(p(u, r), ".");
    if (n === "menu" && h) {
      var g = c ? " disabled" : "", y = "".concat(f ? " selected" : "").concat(g);
      return "".concat(s).concat(y, ", ").concat(p(o, r), ".");
    }
    return "";
  },
  onFilter: function(t) {
    var n = t.inputValue, r = t.resultsMessage;
    return "".concat(r).concat(n ? " for search term " + n : "", ".");
  }
}, xY = function(t) {
  var n = t.ariaSelection, r = t.focusedOption, o = t.focusedValue, a = t.focusableOptions, s = t.isFocused, u = t.selectValue, c = t.selectProps, f = t.id, h = t.isAppleDevice, p = c.ariaLiveMessages, g = c.getOptionLabel, y = c.inputValue, w = c.isMulti, v = c.isOptionDisabled, S = c.isSearchable, E = c.menuIsOpen, T = c.options, k = c.screenReaderStatus, A = c.tabSelectsValue, M = c.isLoading, N = c["aria-label"], P = c["aria-live"], z = _.useMemo(function() {
    return Me(Me({}, bY), p || {});
  }, [p]), B = _.useMemo(function() {
    var V = "";
    if (n && z.onChange) {
      var I = n.option, H = n.options, q = n.removedValue, G = n.removedValues, O = n.value, Y = function(le) {
        return Array.isArray(le) ? null : le;
      }, Z = q || I || Y(O), L = Z ? g(Z) : "", te = H || G || void 0, he = te ? te.map(g) : [], oe = Me({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: Z && v(Z, u),
        label: L,
        labels: he
      }, n);
      V = z.onChange(oe);
    }
    return V;
  }, [n, z, v, u, g]), R = _.useMemo(function() {
    var V = "", I = r || o, H = !!(r && u && u.includes(r));
    if (I && z.onFocus) {
      var q = {
        focused: I,
        label: g(I),
        isDisabled: v(I, u),
        isSelected: H,
        options: a,
        context: I === r ? "menu" : "value",
        selectValue: u,
        isAppleDevice: h
      };
      V = z.onFocus(q);
    }
    return V;
  }, [r, o, g, v, z, a, u, h]), F = _.useMemo(function() {
    var V = "";
    if (E && T.length && !M && z.onFilter) {
      var I = k({
        count: a.length
      });
      V = z.onFilter({
        inputValue: y,
        resultsMessage: I
      });
    }
    return V;
  }, [a, y, E, z, T, k, M]), U = n?.action === "initial-input-focus", W = _.useMemo(function() {
    var V = "";
    if (z.guidance) {
      var I = o ? "value" : E ? "menu" : "input";
      V = z.guidance({
        "aria-label": N,
        context: I,
        isDisabled: r && v(r, u),
        isMulti: w,
        isSearchable: S,
        tabSelectsValue: A,
        isInitialFocus: U
      });
    }
    return V;
  }, [N, r, o, w, v, S, E, z, u, A, U]), j = ke(_.Fragment, null, ke("span", {
    id: "aria-selection"
  }, B), ke("span", {
    id: "aria-focused"
  }, R), ke("span", {
    id: "aria-results"
  }, F), ke("span", {
    id: "aria-guidance"
  }, W));
  return ke(_.Fragment, null, ke(cT, {
    id: f
  }, U && j), ke(cT, {
    "aria-live": P,
    "aria-atomic": "false",
    "aria-relevant": "additions text",
    role: "log"
  }, s && !U && j));
}, wY = xY, vb = [{
  base: "A",
  letters: "A"
}, {
  base: "AA",
  letters: ""
}, {
  base: "AE",
  letters: ""
}, {
  base: "AO",
  letters: ""
}, {
  base: "AU",
  letters: ""
}, {
  base: "AV",
  letters: ""
}, {
  base: "AY",
  letters: ""
}, {
  base: "B",
  letters: "B"
}, {
  base: "C",
  letters: "C"
}, {
  base: "D",
  letters: "D"
}, {
  base: "DZ",
  letters: ""
}, {
  base: "Dz",
  letters: ""
}, {
  base: "E",
  letters: "E"
}, {
  base: "F",
  letters: "F"
}, {
  base: "G",
  letters: "G"
}, {
  base: "H",
  letters: "H"
}, {
  base: "I",
  letters: "I"
}, {
  base: "J",
  letters: "J"
}, {
  base: "K",
  letters: "K"
}, {
  base: "L",
  letters: "L"
}, {
  base: "LJ",
  letters: ""
}, {
  base: "Lj",
  letters: ""
}, {
  base: "M",
  letters: "M"
}, {
  base: "N",
  letters: "N"
}, {
  base: "NJ",
  letters: ""
}, {
  base: "Nj",
  letters: ""
}, {
  base: "O",
  letters: "O"
}, {
  base: "OI",
  letters: ""
}, {
  base: "OO",
  letters: ""
}, {
  base: "OU",
  letters: ""
}, {
  base: "P",
  letters: "P"
}, {
  base: "Q",
  letters: "Q"
}, {
  base: "R",
  letters: "R"
}, {
  base: "S",
  letters: "S"
}, {
  base: "T",
  letters: "T"
}, {
  base: "TZ",
  letters: ""
}, {
  base: "U",
  letters: "U"
}, {
  base: "V",
  letters: "V"
}, {
  base: "VY",
  letters: ""
}, {
  base: "W",
  letters: "W"
}, {
  base: "X",
  letters: "X"
}, {
  base: "Y",
  letters: "Y"
}, {
  base: "Z",
  letters: "Z"
}, {
  base: "a",
  letters: "a"
}, {
  base: "aa",
  letters: ""
}, {
  base: "ae",
  letters: ""
}, {
  base: "ao",
  letters: ""
}, {
  base: "au",
  letters: ""
}, {
  base: "av",
  letters: ""
}, {
  base: "ay",
  letters: ""
}, {
  base: "b",
  letters: "b"
}, {
  base: "c",
  letters: "c"
}, {
  base: "d",
  letters: "d"
}, {
  base: "dz",
  letters: ""
}, {
  base: "e",
  letters: "e"
}, {
  base: "f",
  letters: "f"
}, {
  base: "g",
  letters: "g"
}, {
  base: "h",
  letters: "h"
}, {
  base: "hv",
  letters: ""
}, {
  base: "i",
  letters: "i"
}, {
  base: "j",
  letters: "j"
}, {
  base: "k",
  letters: "k"
}, {
  base: "l",
  letters: "l"
}, {
  base: "lj",
  letters: ""
}, {
  base: "m",
  letters: "m"
}, {
  base: "n",
  letters: "n"
}, {
  base: "nj",
  letters: ""
}, {
  base: "o",
  letters: "o"
}, {
  base: "oi",
  letters: ""
}, {
  base: "ou",
  letters: ""
}, {
  base: "oo",
  letters: ""
}, {
  base: "p",
  letters: "p"
}, {
  base: "q",
  letters: "q"
}, {
  base: "r",
  letters: "r"
}, {
  base: "s",
  letters: "s"
}, {
  base: "t",
  letters: "t"
}, {
  base: "tz",
  letters: ""
}, {
  base: "u",
  letters: "u"
}, {
  base: "v",
  letters: "v"
}, {
  base: "vy",
  letters: ""
}, {
  base: "w",
  letters: "w"
}, {
  base: "x",
  letters: "x"
}, {
  base: "y",
  letters: "y"
}, {
  base: "z",
  letters: "z"
}], _Y = new RegExp("[" + vb.map(function(e) {
  return e.letters;
}).join("") + "]", "g"), _2 = {};
for (var Wy = 0; Wy < vb.length; Wy++)
  for (var Xy = vb[Wy], Ky = 0; Ky < Xy.letters.length; Ky++)
    _2[Xy.letters[Ky]] = Xy.base;
var S2 = function(t) {
  return t.replace(_Y, function(n) {
    return _2[n];
  });
}, SY = gY(S2), fT = function(t) {
  return t.replace(/^\s+|\s+$/g, "");
}, EY = function(t) {
  return "".concat(t.label, " ").concat(t.value);
}, CY = function(t) {
  return function(n, r) {
    if (n.data.__isNew__) return !0;
    var o = Me({
      ignoreCase: !0,
      ignoreAccents: !0,
      stringify: EY,
      trim: !0,
      matchFrom: "any"
    }, t), a = o.ignoreCase, s = o.ignoreAccents, u = o.stringify, c = o.trim, f = o.matchFrom, h = c ? fT(r) : r, p = c ? fT(u(n)) : u(n);
    return a && (h = h.toLowerCase(), p = p.toLowerCase()), s && (h = SY(h), p = S2(p)), f === "start" ? p.substr(0, h.length) === h : p.indexOf(h) > -1;
  };
}, kY = ["innerRef"];
function TY(e) {
  var t = e.innerRef, n = fi(e, kY), r = Jq(n, "onExited", "in", "enter", "exit", "appear");
  return ke("input", Re({
    ref: t
  }, r, {
    css: /* @__PURE__ */ x1({
      label: "dummyInput",
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: "transparent",
      fontSize: "inherit",
      gridArea: "1 / 1 / 2 / 3",
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: "transparent",
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(.01)"
    }, "", "")
  }));
}
var AY = function(t) {
  t.cancelable && t.preventDefault(), t.stopPropagation();
};
function RY(e) {
  var t = e.isEnabled, n = e.onBottomArrive, r = e.onBottomLeave, o = e.onTopArrive, a = e.onTopLeave, s = _.useRef(!1), u = _.useRef(!1), c = _.useRef(0), f = _.useRef(null), h = _.useCallback(function(S, E) {
    if (f.current !== null) {
      var T = f.current, k = T.scrollTop, A = T.scrollHeight, M = T.clientHeight, N = f.current, P = E > 0, z = A - M - k, B = !1;
      z > E && s.current && (r && r(S), s.current = !1), P && u.current && (a && a(S), u.current = !1), P && E > z ? (n && !s.current && n(S), N.scrollTop = A, B = !0, s.current = !0) : !P && -E > k && (o && !u.current && o(S), N.scrollTop = 0, B = !0, u.current = !0), B && AY(S);
    }
  }, [n, r, o, a]), p = _.useCallback(function(S) {
    h(S, S.deltaY);
  }, [h]), g = _.useCallback(function(S) {
    c.current = S.changedTouches[0].clientY;
  }, []), y = _.useCallback(function(S) {
    var E = c.current - S.changedTouches[0].clientY;
    h(S, E);
  }, [h]), w = _.useCallback(function(S) {
    if (S) {
      var E = Kq ? {
        passive: !1
      } : !1;
      S.addEventListener("wheel", p, E), S.addEventListener("touchstart", g, E), S.addEventListener("touchmove", y, E);
    }
  }, [y, g, p]), v = _.useCallback(function(S) {
    S && (S.removeEventListener("wheel", p, !1), S.removeEventListener("touchstart", g, !1), S.removeEventListener("touchmove", y, !1));
  }, [y, g, p]);
  return _.useEffect(function() {
    if (t) {
      var S = f.current;
      return w(S), function() {
        v(S);
      };
    }
  }, [t, w, v]), function(S) {
    f.current = S;
  };
}
var dT = ["boxSizing", "height", "overflow", "paddingRight", "position"], hT = {
  boxSizing: "border-box",
  // account for possible declaration `width: 100%;` on body
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function pT(e) {
  e.cancelable && e.preventDefault();
}
function mT(e) {
  e.stopPropagation();
}
function gT() {
  var e = this.scrollTop, t = this.scrollHeight, n = e + this.offsetHeight;
  e === 0 ? this.scrollTop = 1 : n === t && (this.scrollTop = e - 1);
}
function yT() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
var vT = !!(typeof window < "u" && window.document && window.document.createElement), tc = 0, Ks = {
  capture: !1,
  passive: !1
};
function MY(e) {
  var t = e.isEnabled, n = e.accountForScrollbars, r = n === void 0 ? !0 : n, o = _.useRef({}), a = _.useRef(null), s = _.useCallback(function(c) {
    if (vT) {
      var f = document.body, h = f && f.style;
      if (r && dT.forEach(function(w) {
        var v = h && h[w];
        o.current[w] = v;
      }), r && tc < 1) {
        var p = parseInt(o.current.paddingRight, 10) || 0, g = document.body ? document.body.clientWidth : 0, y = window.innerWidth - g + p || 0;
        Object.keys(hT).forEach(function(w) {
          var v = hT[w];
          h && (h[w] = v);
        }), h && (h.paddingRight = "".concat(y, "px"));
      }
      f && yT() && (f.addEventListener("touchmove", pT, Ks), c && (c.addEventListener("touchstart", gT, Ks), c.addEventListener("touchmove", mT, Ks))), tc += 1;
    }
  }, [r]), u = _.useCallback(function(c) {
    if (vT) {
      var f = document.body, h = f && f.style;
      tc = Math.max(tc - 1, 0), r && tc < 1 && dT.forEach(function(p) {
        var g = o.current[p];
        h && (h[p] = g);
      }), f && yT() && (f.removeEventListener("touchmove", pT, Ks), c && (c.removeEventListener("touchstart", gT, Ks), c.removeEventListener("touchmove", mT, Ks)));
    }
  }, [r]);
  return _.useEffect(function() {
    if (t) {
      var c = a.current;
      return s(c), function() {
        u(c);
      };
    }
  }, [t, s, u]), function(c) {
    a.current = c;
  };
}
var OY = function(t) {
  var n = t.target;
  return n.ownerDocument.activeElement && n.ownerDocument.activeElement.blur();
}, NY = {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
};
function DY(e) {
  var t = e.children, n = e.lockEnabled, r = e.captureEnabled, o = r === void 0 ? !0 : r, a = e.onBottomArrive, s = e.onBottomLeave, u = e.onTopArrive, c = e.onTopLeave, f = RY({
    isEnabled: o,
    onBottomArrive: a,
    onBottomLeave: s,
    onTopArrive: u,
    onTopLeave: c
  }), h = MY({
    isEnabled: n
  }), p = function(y) {
    f(y), h(y);
  };
  return ke(_.Fragment, null, n && ke("div", {
    onClick: OY,
    css: NY
  }), t(p));
}
var PY = {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
}, jY = function(t) {
  var n = t.name, r = t.onFocus;
  return ke("input", {
    required: !0,
    name: n,
    tabIndex: -1,
    "aria-hidden": "true",
    onFocus: r,
    css: PY,
    value: "",
    onChange: function() {
    }
  });
}, IY = jY;
function sx(e) {
  var t;
  return typeof window < "u" && window.navigator != null ? e.test(((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.platform) || window.navigator.platform) : !1;
}
function zY() {
  return sx(/^iPhone/i);
}
function E2() {
  return sx(/^Mac/i);
}
function LY() {
  return sx(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  E2() && navigator.maxTouchPoints > 1;
}
function FY() {
  return zY() || LY();
}
function $Y() {
  return E2() || FY();
}
var BY = function(t) {
  return t.label;
}, HY = function(t) {
  return t.label;
}, VY = function(t) {
  return t.value;
}, UY = function(t) {
  return !!t.isDisabled;
}, qY = {
  clearIndicator: TG,
  container: gG,
  control: PG,
  dropdownIndicator: CG,
  group: LG,
  groupHeading: $G,
  indicatorsContainer: xG,
  indicatorSeparator: RG,
  input: UG,
  loadingIndicator: NG,
  loadingMessage: fG,
  menu: oG,
  menuList: lG,
  menuPortal: pG,
  multiValue: XG,
  multiValueLabel: KG,
  multiValueRemove: ZG,
  noOptionsMessage: cG,
  option: rY,
  placeholder: aY,
  singleValue: uY,
  valueContainer: vG
}, GY = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
}, YY = 4, C2 = 4, WY = 38, XY = C2 * 2, KY = {
  baseUnit: C2,
  controlHeight: WY,
  menuGutter: XY
}, Zy = {
  borderRadius: YY,
  colors: GY,
  spacing: KY
}, ZY = {
  "aria-live": "polite",
  backspaceRemovesValue: !0,
  blurInputOnSelect: sT(),
  captureMenuScroll: !sT(),
  classNames: {},
  closeMenuOnSelect: !0,
  closeMenuOnScroll: !1,
  components: {},
  controlShouldRenderValue: !0,
  escapeClearsValue: !1,
  filterOption: CY(),
  formatGroupLabel: BY,
  getOptionLabel: HY,
  getOptionValue: VY,
  isDisabled: !1,
  isLoading: !1,
  isMulti: !1,
  isRtl: !1,
  isSearchable: !0,
  isOptionDisabled: UY,
  loadingMessage: function() {
    return "Loading...";
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: !1,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: !1,
  menuShouldScrollIntoView: !Wq(),
  noOptionsMessage: function() {
    return "No options";
  },
  openMenuOnFocus: !1,
  openMenuOnClick: !0,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: function(t) {
    var n = t.count;
    return "".concat(n, " result").concat(n !== 1 ? "s" : "", " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: !0,
  unstyled: !1
};
function bT(e, t, n, r) {
  var o = A2(e, t, n), a = R2(e, t, n), s = T2(e, t), u = dp(e, t);
  return {
    type: "option",
    data: t,
    isDisabled: o,
    isSelected: a,
    label: s,
    value: u,
    index: r
  };
}
function Lh(e, t) {
  return e.options.map(function(n, r) {
    if ("options" in n) {
      var o = n.options.map(function(s, u) {
        return bT(e, s, t, u);
      }).filter(function(s) {
        return wT(e, s);
      });
      return o.length > 0 ? {
        type: "group",
        data: n,
        options: o,
        index: r
      } : void 0;
    }
    var a = bT(e, n, t, r);
    return wT(e, a) ? a : void 0;
  }).filter(Zq);
}
function k2(e) {
  return e.reduce(function(t, n) {
    return n.type === "group" ? t.push.apply(t, ix(n.options.map(function(r) {
      return r.data;
    }))) : t.push(n.data), t;
  }, []);
}
function xT(e, t) {
  return e.reduce(function(n, r) {
    return r.type === "group" ? n.push.apply(n, ix(r.options.map(function(o) {
      return {
        data: o.data,
        id: "".concat(t, "-").concat(r.index, "-").concat(o.index)
      };
    }))) : n.push({
      data: r.data,
      id: "".concat(t, "-").concat(r.index)
    }), n;
  }, []);
}
function QY(e, t) {
  return k2(Lh(e, t));
}
function wT(e, t) {
  var n = e.inputValue, r = n === void 0 ? "" : n, o = t.data, a = t.isSelected, s = t.label, u = t.value;
  return (!O2(e) || !a) && M2(e, {
    label: s,
    value: u,
    data: o
  }, r);
}
function JY(e, t) {
  var n = e.focusedValue, r = e.selectValue, o = r.indexOf(n);
  if (o > -1) {
    var a = t.indexOf(n);
    if (a > -1)
      return n;
    if (o < t.length)
      return t[o];
  }
  return null;
}
function eW(e, t) {
  var n = e.focusedOption;
  return n && t.indexOf(n) > -1 ? n : t[0];
}
var Qy = function(t, n) {
  var r, o = (r = t.find(function(a) {
    return a.data === n;
  })) === null || r === void 0 ? void 0 : r.id;
  return o || null;
}, T2 = function(t, n) {
  return t.getOptionLabel(n);
}, dp = function(t, n) {
  return t.getOptionValue(n);
};
function A2(e, t, n) {
  return typeof e.isOptionDisabled == "function" ? e.isOptionDisabled(t, n) : !1;
}
function R2(e, t, n) {
  if (n.indexOf(t) > -1) return !0;
  if (typeof e.isOptionSelected == "function")
    return e.isOptionSelected(t, n);
  var r = dp(e, t);
  return n.some(function(o) {
    return dp(e, o) === r;
  });
}
function M2(e, t, n) {
  return e.filterOption ? e.filterOption(t, n) : !0;
}
var O2 = function(t) {
  var n = t.hideSelectedOptions, r = t.isMulti;
  return n === void 0 ? r : n;
}, tW = 1, N2 = /* @__PURE__ */ function(e) {
  Pq(n, e);
  var t = Iq(n);
  function n(r) {
    var o;
    if (Nq(this, n), o = t.call(this, r), o.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedOptionId: null,
      focusableOptionsWithIds: [],
      focusedValue: null,
      inputIsHidden: !1,
      isFocused: !1,
      selectValue: [],
      clearFocusValueOnUpdate: !1,
      prevWasFocused: !1,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0,
      instancePrefix: "",
      isAppleDevice: !1
    }, o.blockOptionHover = !1, o.isComposing = !1, o.commonProps = void 0, o.initialTouchX = 0, o.initialTouchY = 0, o.openAfterFocus = !1, o.scrollToFocusedOptionOnUpdate = !1, o.userIsDragging = void 0, o.controlRef = null, o.getControlRef = function(c) {
      o.controlRef = c;
    }, o.focusedOptionRef = null, o.getFocusedOptionRef = function(c) {
      o.focusedOptionRef = c;
    }, o.menuListRef = null, o.getMenuListRef = function(c) {
      o.menuListRef = c;
    }, o.inputRef = null, o.getInputRef = function(c) {
      o.inputRef = c;
    }, o.focus = o.focusInput, o.blur = o.blurInput, o.onChange = function(c, f) {
      var h = o.props, p = h.onChange, g = h.name;
      f.name = g, o.ariaOnChange(c, f), p(c, f);
    }, o.setValue = function(c, f, h) {
      var p = o.props, g = p.closeMenuOnSelect, y = p.isMulti, w = p.inputValue;
      o.onInputChange("", {
        action: "set-value",
        prevInputValue: w
      }), g && (o.setState({
        inputIsHiddenAfterUpdate: !y
      }), o.onMenuClose()), o.setState({
        clearFocusValueOnUpdate: !0
      }), o.onChange(c, {
        action: f,
        option: h
      });
    }, o.selectOption = function(c) {
      var f = o.props, h = f.blurInputOnSelect, p = f.isMulti, g = f.name, y = o.state.selectValue, w = p && o.isOptionSelected(c, y), v = o.isOptionDisabled(c, y);
      if (w) {
        var S = o.getOptionValue(c);
        o.setValue(y.filter(function(E) {
          return o.getOptionValue(E) !== S;
        }), "deselect-option", c);
      } else if (!v)
        p ? o.setValue([].concat(ix(y), [c]), "select-option", c) : o.setValue(c, "select-option");
      else {
        o.ariaOnChange(c, {
          action: "select-option",
          option: c,
          name: g
        });
        return;
      }
      h && o.blurInput();
    }, o.removeValue = function(c) {
      var f = o.props.isMulti, h = o.state.selectValue, p = o.getOptionValue(c), g = h.filter(function(w) {
        return o.getOptionValue(w) !== p;
      }), y = sh(f, g, g[0] || null);
      o.onChange(y, {
        action: "remove-value",
        removedValue: c
      }), o.focusInput();
    }, o.clearValue = function() {
      var c = o.state.selectValue;
      o.onChange(sh(o.props.isMulti, [], null), {
        action: "clear",
        removedValues: c
      });
    }, o.popValue = function() {
      var c = o.props.isMulti, f = o.state.selectValue, h = f[f.length - 1], p = f.slice(0, f.length - 1), g = sh(c, p, p[0] || null);
      h && o.onChange(g, {
        action: "pop-value",
        removedValue: h
      });
    }, o.getFocusedOptionId = function(c) {
      return Qy(o.state.focusableOptionsWithIds, c);
    }, o.getFocusableOptionsWithIds = function() {
      return xT(Lh(o.props, o.state.selectValue), o.getElementId("option"));
    }, o.getValue = function() {
      return o.state.selectValue;
    }, o.cx = function() {
      for (var c = arguments.length, f = new Array(c), h = 0; h < c; h++)
        f[h] = arguments[h];
      return Vq.apply(void 0, [o.props.classNamePrefix].concat(f));
    }, o.getOptionLabel = function(c) {
      return T2(o.props, c);
    }, o.getOptionValue = function(c) {
      return dp(o.props, c);
    }, o.getStyles = function(c, f) {
      var h = o.props.unstyled, p = qY[c](f, h);
      p.boxSizing = "border-box";
      var g = o.props.styles[c];
      return g ? g(p, f) : p;
    }, o.getClassNames = function(c, f) {
      var h, p;
      return (h = (p = o.props.classNames)[c]) === null || h === void 0 ? void 0 : h.call(p, f);
    }, o.getElementId = function(c) {
      return "".concat(o.state.instancePrefix, "-").concat(c);
    }, o.getComponents = function() {
      return hY(o.props);
    }, o.buildCategorizedOptions = function() {
      return Lh(o.props, o.state.selectValue);
    }, o.getCategorizedOptions = function() {
      return o.props.menuIsOpen ? o.buildCategorizedOptions() : [];
    }, o.buildFocusableOptions = function() {
      return k2(o.buildCategorizedOptions());
    }, o.getFocusableOptions = function() {
      return o.props.menuIsOpen ? o.buildFocusableOptions() : [];
    }, o.ariaOnChange = function(c, f) {
      o.setState({
        ariaSelection: Me({
          value: c
        }, f)
      });
    }, o.onMenuMouseDown = function(c) {
      c.button === 0 && (c.stopPropagation(), c.preventDefault(), o.focusInput());
    }, o.onMenuMouseMove = function(c) {
      o.blockOptionHover = !1;
    }, o.onControlMouseDown = function(c) {
      if (!c.defaultPrevented) {
        var f = o.props.openMenuOnClick;
        o.state.isFocused ? o.props.menuIsOpen ? c.target.tagName !== "INPUT" && c.target.tagName !== "TEXTAREA" && o.onMenuClose() : f && o.openMenu("first") : (f && (o.openAfterFocus = !0), o.focusInput()), c.target.tagName !== "INPUT" && c.target.tagName !== "TEXTAREA" && c.preventDefault();
      }
    }, o.onDropdownIndicatorMouseDown = function(c) {
      if (!(c && c.type === "mousedown" && c.button !== 0) && !o.props.isDisabled) {
        var f = o.props, h = f.isMulti, p = f.menuIsOpen;
        o.focusInput(), p ? (o.setState({
          inputIsHiddenAfterUpdate: !h
        }), o.onMenuClose()) : o.openMenu("first"), c.preventDefault();
      }
    }, o.onClearIndicatorMouseDown = function(c) {
      c && c.type === "mousedown" && c.button !== 0 || (o.clearValue(), c.preventDefault(), o.openAfterFocus = !1, c.type === "touchend" ? o.focusInput() : setTimeout(function() {
        return o.focusInput();
      }));
    }, o.onScroll = function(c) {
      typeof o.props.closeMenuOnScroll == "boolean" ? c.target instanceof HTMLElement && bm(c.target) && o.props.onMenuClose() : typeof o.props.closeMenuOnScroll == "function" && o.props.closeMenuOnScroll(c) && o.props.onMenuClose();
    }, o.onCompositionStart = function() {
      o.isComposing = !0;
    }, o.onCompositionEnd = function() {
      o.isComposing = !1;
    }, o.onTouchStart = function(c) {
      var f = c.touches, h = f && f.item(0);
      h && (o.initialTouchX = h.clientX, o.initialTouchY = h.clientY, o.userIsDragging = !1);
    }, o.onTouchMove = function(c) {
      var f = c.touches, h = f && f.item(0);
      if (h) {
        var p = Math.abs(h.clientX - o.initialTouchX), g = Math.abs(h.clientY - o.initialTouchY), y = 5;
        o.userIsDragging = p > y || g > y;
      }
    }, o.onTouchEnd = function(c) {
      o.userIsDragging || (o.controlRef && !o.controlRef.contains(c.target) && o.menuListRef && !o.menuListRef.contains(c.target) && o.blurInput(), o.initialTouchX = 0, o.initialTouchY = 0);
    }, o.onControlTouchEnd = function(c) {
      o.userIsDragging || o.onControlMouseDown(c);
    }, o.onClearIndicatorTouchEnd = function(c) {
      o.userIsDragging || o.onClearIndicatorMouseDown(c);
    }, o.onDropdownIndicatorTouchEnd = function(c) {
      o.userIsDragging || o.onDropdownIndicatorMouseDown(c);
    }, o.handleInputChange = function(c) {
      var f = o.props.inputValue, h = c.currentTarget.value;
      o.setState({
        inputIsHiddenAfterUpdate: !1
      }), o.onInputChange(h, {
        action: "input-change",
        prevInputValue: f
      }), o.props.menuIsOpen || o.onMenuOpen();
    }, o.onInputFocus = function(c) {
      o.props.onFocus && o.props.onFocus(c), o.setState({
        inputIsHiddenAfterUpdate: !1,
        isFocused: !0
      }), (o.openAfterFocus || o.props.openMenuOnFocus) && o.openMenu("first"), o.openAfterFocus = !1;
    }, o.onInputBlur = function(c) {
      var f = o.props.inputValue;
      if (o.menuListRef && o.menuListRef.contains(document.activeElement)) {
        o.inputRef.focus();
        return;
      }
      o.props.onBlur && o.props.onBlur(c), o.onInputChange("", {
        action: "input-blur",
        prevInputValue: f
      }), o.onMenuClose(), o.setState({
        focusedValue: null,
        isFocused: !1
      });
    }, o.onOptionHover = function(c) {
      if (!(o.blockOptionHover || o.state.focusedOption === c)) {
        var f = o.getFocusableOptions(), h = f.indexOf(c);
        o.setState({
          focusedOption: c,
          focusedOptionId: h > -1 ? o.getFocusedOptionId(c) : null
        });
      }
    }, o.shouldHideSelectedOptions = function() {
      return O2(o.props);
    }, o.onValueInputFocus = function(c) {
      c.preventDefault(), c.stopPropagation(), o.focus();
    }, o.onKeyDown = function(c) {
      var f = o.props, h = f.isMulti, p = f.backspaceRemovesValue, g = f.escapeClearsValue, y = f.inputValue, w = f.isClearable, v = f.isDisabled, S = f.menuIsOpen, E = f.onKeyDown, T = f.tabSelectsValue, k = f.openMenuOnFocus, A = o.state, M = A.focusedOption, N = A.focusedValue, P = A.selectValue;
      if (!v && !(typeof E == "function" && (E(c), c.defaultPrevented))) {
        switch (o.blockOptionHover = !0, c.key) {
          case "ArrowLeft":
            if (!h || y) return;
            o.focusValue("previous");
            break;
          case "ArrowRight":
            if (!h || y) return;
            o.focusValue("next");
            break;
          case "Delete":
          case "Backspace":
            if (y) return;
            if (N)
              o.removeValue(N);
            else {
              if (!p) return;
              h ? o.popValue() : w && o.clearValue();
            }
            break;
          case "Tab":
            if (o.isComposing || c.shiftKey || !S || !T || !M || // don't capture the event if the menu opens on focus and the focused
            // option is already selected; it breaks the flow of navigation
            k && o.isOptionSelected(M, P))
              return;
            o.selectOption(M);
            break;
          case "Enter":
            if (c.keyCode === 229)
              break;
            if (S) {
              if (!M || o.isComposing) return;
              o.selectOption(M);
              break;
            }
            return;
          case "Escape":
            S ? (o.setState({
              inputIsHiddenAfterUpdate: !1
            }), o.onInputChange("", {
              action: "menu-close",
              prevInputValue: y
            }), o.onMenuClose()) : w && g && o.clearValue();
            break;
          case " ":
            if (y)
              return;
            if (!S) {
              o.openMenu("first");
              break;
            }
            if (!M) return;
            o.selectOption(M);
            break;
          case "ArrowUp":
            S ? o.focusOption("up") : o.openMenu("last");
            break;
          case "ArrowDown":
            S ? o.focusOption("down") : o.openMenu("first");
            break;
          case "PageUp":
            if (!S) return;
            o.focusOption("pageup");
            break;
          case "PageDown":
            if (!S) return;
            o.focusOption("pagedown");
            break;
          case "Home":
            if (!S) return;
            o.focusOption("first");
            break;
          case "End":
            if (!S) return;
            o.focusOption("last");
            break;
          default:
            return;
        }
        c.preventDefault();
      }
    }, o.state.instancePrefix = "react-select-" + (o.props.instanceId || ++tW), o.state.selectValue = iT(r.value), r.menuIsOpen && o.state.selectValue.length) {
      var a = o.getFocusableOptionsWithIds(), s = o.buildFocusableOptions(), u = s.indexOf(o.state.selectValue[0]);
      o.state.focusableOptionsWithIds = a, o.state.focusedOption = s[u], o.state.focusedOptionId = Qy(a, s[u]);
    }
    return o;
  }
  return Dq(n, [{
    key: "componentDidMount",
    value: function() {
      this.startListeningComposition(), this.startListeningToTouch(), this.props.closeMenuOnScroll && document && document.addEventListener && document.addEventListener("scroll", this.onScroll, !0), this.props.autoFocus && this.focusInput(), this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef && aT(this.menuListRef, this.focusedOptionRef), $Y() && this.setState({
        isAppleDevice: !0
      });
    }
  }, {
    key: "componentDidUpdate",
    value: function(o) {
      var a = this.props, s = a.isDisabled, u = a.menuIsOpen, c = this.state.isFocused;
      // ensure focus is restored correctly when the control becomes enabled
      (c && !s && o.isDisabled || // ensure focus is on the Input when the menu opens
      c && u && !o.menuIsOpen) && this.focusInput(), c && s && !o.isDisabled ? this.setState({
        isFocused: !1
      }, this.onMenuClose) : !c && !s && o.isDisabled && this.inputRef === document.activeElement && this.setState({
        isFocused: !0
      }), this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate && (aT(this.menuListRef, this.focusedOptionRef), this.scrollToFocusedOptionOnUpdate = !1);
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.stopListeningComposition(), this.stopListeningToTouch(), document.removeEventListener("scroll", this.onScroll, !0);
    }
    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function() {
      this.onInputChange("", {
        action: "menu-close",
        prevInputValue: this.props.inputValue
      }), this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function(o, a) {
      this.props.onInputChange(o, a);
    }
    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function() {
      this.inputRef && this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function() {
      this.inputRef && this.inputRef.blur();
    }
    // aliased for consumers
  }, {
    key: "openMenu",
    value: function(o) {
      var a = this, s = this.state, u = s.selectValue, c = s.isFocused, f = this.buildFocusableOptions(), h = o === "first" ? 0 : f.length - 1;
      if (!this.props.isMulti) {
        var p = f.indexOf(u[0]);
        p > -1 && (h = p);
      }
      this.scrollToFocusedOptionOnUpdate = !(c && this.menuListRef), this.setState({
        inputIsHiddenAfterUpdate: !1,
        focusedValue: null,
        focusedOption: f[h],
        focusedOptionId: this.getFocusedOptionId(f[h])
      }, function() {
        return a.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function(o) {
      var a = this.state, s = a.selectValue, u = a.focusedValue;
      if (this.props.isMulti) {
        this.setState({
          focusedOption: null
        });
        var c = s.indexOf(u);
        u || (c = -1);
        var f = s.length - 1, h = -1;
        if (s.length) {
          switch (o) {
            case "previous":
              c === 0 ? h = 0 : c === -1 ? h = f : h = c - 1;
              break;
            case "next":
              c > -1 && c < f && (h = c + 1);
              break;
          }
          this.setState({
            inputIsHidden: h !== -1,
            focusedValue: s[h]
          });
        }
      }
    }
  }, {
    key: "focusOption",
    value: function() {
      var o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first", a = this.props.pageSize, s = this.state.focusedOption, u = this.getFocusableOptions();
      if (u.length) {
        var c = 0, f = u.indexOf(s);
        s || (f = -1), o === "up" ? c = f > 0 ? f - 1 : u.length - 1 : o === "down" ? c = (f + 1) % u.length : o === "pageup" ? (c = f - a, c < 0 && (c = 0)) : o === "pagedown" ? (c = f + a, c > u.length - 1 && (c = u.length - 1)) : o === "last" && (c = u.length - 1), this.scrollToFocusedOptionOnUpdate = !0, this.setState({
          focusedOption: u[c],
          focusedValue: null,
          focusedOptionId: this.getFocusedOptionId(u[c])
        });
      }
    }
  }, {
    key: "getTheme",
    value: (
      // ==============================
      // Getters
      // ==============================
      function() {
        return this.props.theme ? typeof this.props.theme == "function" ? this.props.theme(Zy) : Me(Me({}, Zy), this.props.theme) : Zy;
      }
    )
  }, {
    key: "getCommonProps",
    value: function() {
      var o = this.clearValue, a = this.cx, s = this.getStyles, u = this.getClassNames, c = this.getValue, f = this.selectOption, h = this.setValue, p = this.props, g = p.isMulti, y = p.isRtl, w = p.options, v = this.hasValue();
      return {
        clearValue: o,
        cx: a,
        getStyles: s,
        getClassNames: u,
        getValue: c,
        hasValue: v,
        isMulti: g,
        isRtl: y,
        options: w,
        selectOption: f,
        selectProps: p,
        setValue: h,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function() {
      var o = this.state.selectValue;
      return o.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function() {
      var o = this.props, a = o.isClearable, s = o.isMulti;
      return a === void 0 ? s : a;
    }
  }, {
    key: "isOptionDisabled",
    value: function(o, a) {
      return A2(this.props, o, a);
    }
  }, {
    key: "isOptionSelected",
    value: function(o, a) {
      return R2(this.props, o, a);
    }
  }, {
    key: "filterOption",
    value: function(o, a) {
      return M2(this.props, o, a);
    }
  }, {
    key: "formatOptionLabel",
    value: function(o, a) {
      if (typeof this.props.formatOptionLabel == "function") {
        var s = this.props.inputValue, u = this.state.selectValue;
        return this.props.formatOptionLabel(o, {
          context: a,
          inputValue: s,
          selectValue: u
        });
      } else
        return this.getOptionLabel(o);
    }
  }, {
    key: "formatGroupLabel",
    value: function(o) {
      return this.props.formatGroupLabel(o);
    }
    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value: (
      // ==============================
      // Composition Handlers
      // ==============================
      function() {
        document && document.addEventListener && (document.addEventListener("compositionstart", this.onCompositionStart, !1), document.addEventListener("compositionend", this.onCompositionEnd, !1));
      }
    )
  }, {
    key: "stopListeningComposition",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("compositionstart", this.onCompositionStart), document.removeEventListener("compositionend", this.onCompositionEnd));
    }
  }, {
    key: "startListeningToTouch",
    value: (
      // ==============================
      // Touch Handlers
      // ==============================
      function() {
        document && document.addEventListener && (document.addEventListener("touchstart", this.onTouchStart, !1), document.addEventListener("touchmove", this.onTouchMove, !1), document.addEventListener("touchend", this.onTouchEnd, !1));
      }
    )
  }, {
    key: "stopListeningToTouch",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("touchstart", this.onTouchStart), document.removeEventListener("touchmove", this.onTouchMove), document.removeEventListener("touchend", this.onTouchEnd));
    }
  }, {
    key: "renderInput",
    value: (
      // ==============================
      // Renderers
      // ==============================
      function() {
        var o = this.props, a = o.isDisabled, s = o.isSearchable, u = o.inputId, c = o.inputValue, f = o.tabIndex, h = o.form, p = o.menuIsOpen, g = o.required, y = this.getComponents(), w = y.Input, v = this.state, S = v.inputIsHidden, E = v.ariaSelection, T = this.commonProps, k = u || this.getElementId("input"), A = Me(Me(Me({
          "aria-autocomplete": "list",
          "aria-expanded": p,
          "aria-haspopup": !0,
          "aria-errormessage": this.props["aria-errormessage"],
          "aria-invalid": this.props["aria-invalid"],
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-required": g,
          role: "combobox",
          "aria-activedescendant": this.state.isAppleDevice ? void 0 : this.state.focusedOptionId || ""
        }, p && {
          "aria-controls": this.getElementId("listbox")
        }), !s && {
          "aria-readonly": !0
        }), this.hasValue() ? E?.action === "initial-input-focus" && {
          "aria-describedby": this.getElementId("live-region")
        } : {
          "aria-describedby": this.getElementId("placeholder")
        });
        return s ? /* @__PURE__ */ _.createElement(w, Re({}, T, {
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id: k,
          innerRef: this.getInputRef,
          isDisabled: a,
          isHidden: S,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex: f,
          form: h,
          type: "text",
          value: c
        }, A)) : /* @__PURE__ */ _.createElement(TY, Re({
          id: k,
          innerRef: this.getInputRef,
          onBlur: this.onInputBlur,
          onChange: cp,
          onFocus: this.onInputFocus,
          disabled: a,
          tabIndex: f,
          inputMode: "none",
          form: h,
          value: ""
        }, A));
      }
    )
  }, {
    key: "renderPlaceholderOrValue",
    value: function() {
      var o = this, a = this.getComponents(), s = a.MultiValue, u = a.MultiValueContainer, c = a.MultiValueLabel, f = a.MultiValueRemove, h = a.SingleValue, p = a.Placeholder, g = this.commonProps, y = this.props, w = y.controlShouldRenderValue, v = y.isDisabled, S = y.isMulti, E = y.inputValue, T = y.placeholder, k = this.state, A = k.selectValue, M = k.focusedValue, N = k.isFocused;
      if (!this.hasValue() || !w)
        return E ? null : /* @__PURE__ */ _.createElement(p, Re({}, g, {
          key: "placeholder",
          isDisabled: v,
          isFocused: N,
          innerProps: {
            id: this.getElementId("placeholder")
          }
        }), T);
      if (S)
        return A.map(function(z, B) {
          var R = z === M, F = "".concat(o.getOptionLabel(z), "-").concat(o.getOptionValue(z));
          return /* @__PURE__ */ _.createElement(s, Re({}, g, {
            components: {
              Container: u,
              Label: c,
              Remove: f
            },
            isFocused: R,
            isDisabled: v,
            key: F,
            index: B,
            removeProps: {
              onClick: function() {
                return o.removeValue(z);
              },
              onTouchEnd: function() {
                return o.removeValue(z);
              },
              onMouseDown: function(W) {
                W.preventDefault();
              }
            },
            data: z
          }), o.formatOptionLabel(z, "value"));
        });
      if (E)
        return null;
      var P = A[0];
      return /* @__PURE__ */ _.createElement(h, Re({}, g, {
        data: P,
        isDisabled: v
      }), this.formatOptionLabel(P, "value"));
    }
  }, {
    key: "renderClearIndicator",
    value: function() {
      var o = this.getComponents(), a = o.ClearIndicator, s = this.commonProps, u = this.props, c = u.isDisabled, f = u.isLoading, h = this.state.isFocused;
      if (!this.isClearable() || !a || c || !this.hasValue() || f)
        return null;
      var p = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ _.createElement(a, Re({}, s, {
        innerProps: p,
        isFocused: h
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function() {
      var o = this.getComponents(), a = o.LoadingIndicator, s = this.commonProps, u = this.props, c = u.isDisabled, f = u.isLoading, h = this.state.isFocused;
      if (!a || !f) return null;
      var p = {
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ _.createElement(a, Re({}, s, {
        innerProps: p,
        isDisabled: c,
        isFocused: h
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function() {
      var o = this.getComponents(), a = o.DropdownIndicator, s = o.IndicatorSeparator;
      if (!a || !s) return null;
      var u = this.commonProps, c = this.props.isDisabled, f = this.state.isFocused;
      return /* @__PURE__ */ _.createElement(s, Re({}, u, {
        isDisabled: c,
        isFocused: f
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function() {
      var o = this.getComponents(), a = o.DropdownIndicator;
      if (!a) return null;
      var s = this.commonProps, u = this.props.isDisabled, c = this.state.isFocused, f = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ _.createElement(a, Re({}, s, {
        innerProps: f,
        isDisabled: u,
        isFocused: c
      }));
    }
  }, {
    key: "renderMenu",
    value: function() {
      var o = this, a = this.getComponents(), s = a.Group, u = a.GroupHeading, c = a.Menu, f = a.MenuList, h = a.MenuPortal, p = a.LoadingMessage, g = a.NoOptionsMessage, y = a.Option, w = this.commonProps, v = this.state.focusedOption, S = this.props, E = S.captureMenuScroll, T = S.inputValue, k = S.isLoading, A = S.loadingMessage, M = S.minMenuHeight, N = S.maxMenuHeight, P = S.menuIsOpen, z = S.menuPlacement, B = S.menuPosition, R = S.menuPortalTarget, F = S.menuShouldBlockScroll, U = S.menuShouldScrollIntoView, W = S.noOptionsMessage, j = S.onMenuScrollToTop, V = S.onMenuScrollToBottom;
      if (!P) return null;
      var I = function(L, te) {
        var he = L.type, oe = L.data, de = L.isDisabled, le = L.isSelected, ye = L.label, je = L.value, Ne = v === oe, we = de ? void 0 : function() {
          return o.onOptionHover(oe);
        }, Ee = de ? void 0 : function() {
          return o.selectOption(oe);
        }, _e = "".concat(o.getElementId("option"), "-").concat(te), Xe = {
          id: _e,
          onClick: Ee,
          onMouseMove: we,
          onMouseOver: we,
          tabIndex: -1,
          role: "option",
          "aria-selected": o.state.isAppleDevice ? void 0 : le
          // is not supported on Apple devices
        };
        return /* @__PURE__ */ _.createElement(y, Re({}, w, {
          innerProps: Xe,
          data: oe,
          isDisabled: de,
          isSelected: le,
          key: _e,
          label: ye,
          type: he,
          value: je,
          isFocused: Ne,
          innerRef: Ne ? o.getFocusedOptionRef : void 0
        }), o.formatOptionLabel(L.data, "menu"));
      }, H;
      if (this.hasOptions())
        H = this.getCategorizedOptions().map(function(Z) {
          if (Z.type === "group") {
            var L = Z.data, te = Z.options, he = Z.index, oe = "".concat(o.getElementId("group"), "-").concat(he), de = "".concat(oe, "-heading");
            return /* @__PURE__ */ _.createElement(s, Re({}, w, {
              key: oe,
              data: L,
              options: te,
              Heading: u,
              headingProps: {
                id: de,
                data: Z.data
              },
              label: o.formatGroupLabel(Z.data)
            }), Z.options.map(function(le) {
              return I(le, "".concat(he, "-").concat(le.index));
            }));
          } else if (Z.type === "option")
            return I(Z, "".concat(Z.index));
        });
      else if (k) {
        var q = A({
          inputValue: T
        });
        if (q === null) return null;
        H = /* @__PURE__ */ _.createElement(p, w, q);
      } else {
        var G = W({
          inputValue: T
        });
        if (G === null) return null;
        H = /* @__PURE__ */ _.createElement(g, w, G);
      }
      var O = {
        minMenuHeight: M,
        maxMenuHeight: N,
        menuPlacement: z,
        menuPosition: B,
        menuShouldScrollIntoView: U
      }, Y = /* @__PURE__ */ _.createElement(iG, Re({}, w, O), function(Z) {
        var L = Z.ref, te = Z.placerProps, he = te.placement, oe = te.maxHeight;
        return /* @__PURE__ */ _.createElement(c, Re({}, w, O, {
          innerRef: L,
          innerProps: {
            onMouseDown: o.onMenuMouseDown,
            onMouseMove: o.onMenuMouseMove
          },
          isLoading: k,
          placement: he
        }), /* @__PURE__ */ _.createElement(DY, {
          captureEnabled: E,
          onTopArrive: j,
          onBottomArrive: V,
          lockEnabled: F
        }, function(de) {
          return /* @__PURE__ */ _.createElement(f, Re({}, w, {
            innerRef: function(ye) {
              o.getMenuListRef(ye), de(ye);
            },
            innerProps: {
              role: "listbox",
              "aria-multiselectable": w.isMulti,
              id: o.getElementId("listbox")
            },
            isLoading: k,
            maxHeight: oe,
            focusedOption: v
          }), H);
        }));
      });
      return R || B === "fixed" ? /* @__PURE__ */ _.createElement(h, Re({}, w, {
        appendTo: R,
        controlElement: this.controlRef,
        menuPlacement: z,
        menuPosition: B
      }), Y) : Y;
    }
  }, {
    key: "renderFormField",
    value: function() {
      var o = this, a = this.props, s = a.delimiter, u = a.isDisabled, c = a.isMulti, f = a.name, h = a.required, p = this.state.selectValue;
      if (h && !this.hasValue() && !u)
        return /* @__PURE__ */ _.createElement(IY, {
          name: f,
          onFocus: this.onValueInputFocus
        });
      if (!(!f || u))
        if (c)
          if (s) {
            var g = p.map(function(v) {
              return o.getOptionValue(v);
            }).join(s);
            return /* @__PURE__ */ _.createElement("input", {
              name: f,
              type: "hidden",
              value: g
            });
          } else {
            var y = p.length > 0 ? p.map(function(v, S) {
              return /* @__PURE__ */ _.createElement("input", {
                key: "i-".concat(S),
                name: f,
                type: "hidden",
                value: o.getOptionValue(v)
              });
            }) : /* @__PURE__ */ _.createElement("input", {
              name: f,
              type: "hidden",
              value: ""
            });
            return /* @__PURE__ */ _.createElement("div", null, y);
          }
        else {
          var w = p[0] ? this.getOptionValue(p[0]) : "";
          return /* @__PURE__ */ _.createElement("input", {
            name: f,
            type: "hidden",
            value: w
          });
        }
    }
  }, {
    key: "renderLiveRegion",
    value: function() {
      var o = this.commonProps, a = this.state, s = a.ariaSelection, u = a.focusedOption, c = a.focusedValue, f = a.isFocused, h = a.selectValue, p = this.getFocusableOptions();
      return /* @__PURE__ */ _.createElement(wY, Re({}, o, {
        id: this.getElementId("live-region"),
        ariaSelection: s,
        focusedOption: u,
        focusedValue: c,
        isFocused: f,
        selectValue: h,
        focusableOptions: p,
        isAppleDevice: this.state.isAppleDevice
      }));
    }
  }, {
    key: "render",
    value: function() {
      var o = this.getComponents(), a = o.Control, s = o.IndicatorsContainer, u = o.SelectContainer, c = o.ValueContainer, f = this.props, h = f.className, p = f.id, g = f.isDisabled, y = f.menuIsOpen, w = this.state.isFocused, v = this.commonProps = this.getCommonProps();
      return /* @__PURE__ */ _.createElement(u, Re({}, v, {
        className: h,
        innerProps: {
          id: p,
          onKeyDown: this.onKeyDown
        },
        isDisabled: g,
        isFocused: w
      }), this.renderLiveRegion(), /* @__PURE__ */ _.createElement(a, Re({}, v, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled: g,
        isFocused: w,
        menuIsOpen: y
      }), /* @__PURE__ */ _.createElement(c, Re({}, v, {
        isDisabled: g
      }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ _.createElement(s, Re({}, v, {
        isDisabled: g
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(o, a) {
      var s = a.prevProps, u = a.clearFocusValueOnUpdate, c = a.inputIsHiddenAfterUpdate, f = a.ariaSelection, h = a.isFocused, p = a.prevWasFocused, g = a.instancePrefix, y = o.options, w = o.value, v = o.menuIsOpen, S = o.inputValue, E = o.isMulti, T = iT(w), k = {};
      if (s && (w !== s.value || y !== s.options || v !== s.menuIsOpen || S !== s.inputValue)) {
        var A = v ? QY(o, T) : [], M = v ? xT(Lh(o, T), "".concat(g, "-option")) : [], N = u ? JY(a, T) : null, P = eW(a, A), z = Qy(M, P);
        k = {
          selectValue: T,
          focusedOption: P,
          focusedOptionId: z,
          focusableOptionsWithIds: M,
          focusedValue: N,
          clearFocusValueOnUpdate: !1
        };
      }
      var B = c != null && o !== s ? {
        inputIsHidden: c,
        inputIsHiddenAfterUpdate: void 0
      } : {}, R = f, F = h && p;
      return h && !F && (R = {
        value: sh(E, T, T[0] || null),
        options: T,
        action: "initial-input-focus"
      }, F = !p), f?.action === "initial-input-focus" && (R = null), Me(Me(Me({}, k), B), {}, {
        prevProps: o,
        ariaSelection: R,
        prevWasFocused: F
      });
    }
  }]), n;
}(_.Component);
N2.defaultProps = ZY;
var nW = /* @__PURE__ */ _.forwardRef(function(e, t) {
  var n = Oq(e);
  return /* @__PURE__ */ _.createElement(N2, Re({
    ref: t
  }, n));
}), rW = nW;
const oW = ({
  options: e,
  items_per_page: t,
  className: n,
  defaultValue: r,
  onChange: o
}) => {
  const [a, s] = _.useState(""), [u, c] = _.useState(0), f = (y) => {
    s(y.toLowerCase()), c(0);
  }, h = e.filter((y) => y.label.toLowerCase().includes(a) || y.value.toLowerCase().includes(a));
  var p;
  t !== void 0 ? p = h.slice(
    u * t,
    (u + 1) * t
  ) : p = h;
  const g = {
    control: (y) => ({
      ...y,
      minHeight: void 0
    })
  };
  return /* @__PURE__ */ x.jsx(
    rW,
    {
      options: p,
      onInputChange: f,
      onChange: o,
      inputValue: a,
      isSearchable: !0,
      placeholder: "Select an option...",
      className: n,
      unstyled: !0,
      styles: g,
      classNamePrefix: "styled-select",
      defaultValue: r,
      value: r
    }
  );
}, iW = (e) => typeof e == "boolean" || e instanceof Boolean, aW = (e) => typeof e == "number" || e instanceof Number, sW = (e) => typeof e == "bigint" || e instanceof BigInt, D2 = (e) => !!e && e instanceof Date, lW = (e) => typeof e == "string" || e instanceof String, uW = (e) => Array.isArray(e), cW = (e) => typeof e == "object" && e !== null, P2 = (e) => !!e && e instanceof Object && typeof e == "function";
function hp(e, t) {
  return t === void 0 && (t = !1), !e || t ? `"${e}"` : e;
}
function fW(e, t, n) {
  return n ? JSON.stringify(e) : t ? `"${e}"` : e;
}
function j2(e) {
  let {
    field: t,
    value: n,
    data: r,
    lastElement: o,
    openBracket: a,
    closeBracket: s,
    level: u,
    style: c,
    shouldExpandNode: f,
    clickToExpandNode: h,
    outerRef: p,
    beforeExpandChange: g
  } = e;
  const y = _.useRef(!1), [w, v] = _.useState(() => f(u, n, t)), S = _.useRef(null);
  _.useEffect(() => {
    y.current ? v(f(u, n, t)) : y.current = !0;
  }, [f]);
  const E = _.useId();
  if (r.length === 0)
    return dW({
      field: t,
      openBracket: a,
      closeBracket: s,
      lastElement: o,
      style: c
    });
  const T = w ? c.collapseIcon : c.expandIcon, k = w ? c.ariaLables.collapseJson : c.ariaLables.expandJson, A = u + 1, M = r.length - 1, N = (B) => {
    w !== B && (!g || g({
      level: u,
      value: n,
      field: t,
      newExpandValue: B
    })) && v(B);
  }, P = (B) => {
    if (B.key === "ArrowRight" || B.key === "ArrowLeft")
      B.preventDefault(), N(B.key === "ArrowRight");
    else if (B.key === "ArrowUp" || B.key === "ArrowDown") {
      B.preventDefault();
      const R = B.key === "ArrowUp" ? -1 : 1;
      if (!p.current) return;
      const F = p.current.querySelectorAll("[role=button]");
      let U = -1;
      for (let j = 0; j < F.length; j++)
        if (F[j].tabIndex === 0) {
          U = j;
          break;
        }
      if (U < 0)
        return;
      const W = (U + R + F.length) % F.length;
      F[U].tabIndex = -1, F[W].tabIndex = 0, F[W].focus();
    }
  }, z = () => {
    var B;
    N(!w);
    const R = S.current;
    if (!R) return;
    const F = (B = p.current) === null || B === void 0 ? void 0 : B.querySelector('[role=button][tabindex="0"]');
    F && (F.tabIndex = -1), R.tabIndex = 0, R.focus();
  };
  return /* @__PURE__ */ _.createElement("div", {
    className: c.basicChildStyle,
    role: "treeitem",
    "aria-expanded": w,
    "aria-selected": void 0
  }, /* @__PURE__ */ _.createElement("span", {
    className: T,
    onClick: z,
    onKeyDown: P,
    role: "button",
    "aria-label": k,
    "aria-expanded": w,
    "aria-controls": w ? E : void 0,
    ref: S,
    tabIndex: u === 0 ? 0 : -1
  }), (t || t === "") && (h ? /* @__PURE__ */ _.createElement("span", {
    className: c.clickableLabel,
    onClick: z,
    onKeyDown: P
  }, hp(t, c.quotesForFieldNames), ":") : /* @__PURE__ */ _.createElement("span", {
    className: c.label
  }, hp(t, c.quotesForFieldNames), ":")), /* @__PURE__ */ _.createElement("span", {
    className: c.punctuation
  }, a), w ? /* @__PURE__ */ _.createElement("ul", {
    id: E,
    role: "group",
    className: c.childFieldsContainer
  }, r.map((B, R) => /* @__PURE__ */ _.createElement(I2, {
    key: B[0] || R,
    field: B[0],
    value: B[1],
    style: c,
    lastElement: R === M,
    level: A,
    shouldExpandNode: f,
    clickToExpandNode: h,
    outerRef: p
  }))) : /* @__PURE__ */ _.createElement("span", {
    className: c.collapsedContent,
    onClick: z,
    onKeyDown: P
  }), /* @__PURE__ */ _.createElement("span", {
    className: c.punctuation
  }, s), !o && /* @__PURE__ */ _.createElement("span", {
    className: c.punctuation
  }, ","));
}
function dW(e) {
  let {
    field: t,
    openBracket: n,
    closeBracket: r,
    lastElement: o,
    style: a
  } = e;
  return /* @__PURE__ */ _.createElement("div", {
    className: a.basicChildStyle,
    role: "treeitem",
    "aria-selected": void 0
  }, (t || t === "") && /* @__PURE__ */ _.createElement("span", {
    className: a.label
  }, hp(t, a.quotesForFieldNames), ":"), /* @__PURE__ */ _.createElement("span", {
    className: a.punctuation
  }, n), /* @__PURE__ */ _.createElement("span", {
    className: a.punctuation
  }, r), !o && /* @__PURE__ */ _.createElement("span", {
    className: a.punctuation
  }, ","));
}
function hW(e) {
  let {
    field: t,
    value: n,
    style: r,
    lastElement: o,
    shouldExpandNode: a,
    clickToExpandNode: s,
    level: u,
    outerRef: c,
    beforeExpandChange: f
  } = e;
  return j2({
    field: t,
    value: n,
    lastElement: o || !1,
    level: u,
    openBracket: "{",
    closeBracket: "}",
    style: r,
    shouldExpandNode: a,
    clickToExpandNode: s,
    data: Object.keys(n).map((h) => [h, n[h]]),
    outerRef: c,
    beforeExpandChange: f
  });
}
function pW(e) {
  let {
    field: t,
    value: n,
    style: r,
    lastElement: o,
    level: a,
    shouldExpandNode: s,
    clickToExpandNode: u,
    outerRef: c,
    beforeExpandChange: f
  } = e;
  return j2({
    field: t,
    value: n,
    lastElement: o || !1,
    level: a,
    openBracket: "[",
    closeBracket: "]",
    style: r,
    shouldExpandNode: s,
    clickToExpandNode: u,
    data: n.map((h) => [void 0, h]),
    outerRef: c,
    beforeExpandChange: f
  });
}
function mW(e) {
  let {
    field: t,
    value: n,
    style: r,
    lastElement: o
  } = e, a, s = r.otherValue;
  return n === null ? (a = "null", s = r.nullValue) : n === void 0 ? (a = "undefined", s = r.undefinedValue) : lW(n) ? (a = fW(n, !r.noQuotesForStringValues, r.stringifyStringValues), s = r.stringValue) : iW(n) ? (a = n ? "true" : "false", s = r.booleanValue) : aW(n) ? (a = n.toString(), s = r.numberValue) : sW(n) ? (a = `${n.toString()}n`, s = r.numberValue) : D2(n) ? a = n.toISOString() : P2(n) ? a = "function() { }" : a = n.toString(), /* @__PURE__ */ _.createElement("div", {
    className: r.basicChildStyle,
    role: "treeitem",
    "aria-selected": void 0
  }, (t || t === "") && /* @__PURE__ */ _.createElement("span", {
    className: r.label
  }, hp(t, r.quotesForFieldNames), ":"), /* @__PURE__ */ _.createElement("span", {
    className: s
  }, a), !o && /* @__PURE__ */ _.createElement("span", {
    className: r.punctuation
  }, ","));
}
function I2(e) {
  const t = e.value;
  return uW(t) ? /* @__PURE__ */ _.createElement(pW, Object.assign({}, e)) : cW(t) && !D2(t) && !P2(t) ? /* @__PURE__ */ _.createElement(hW, Object.assign({}, e)) : /* @__PURE__ */ _.createElement(mW, Object.assign({}, e));
}
var st = { "container-light": "_2IvMF _GzYRV", "basic-element-style": "_2bkNM", "child-fields-container": "_1BXBN", "label-light": "_1MGIk", "clickable-label-light": "_2YKJg _1MGIk _1MFti", "punctuation-light": "_3uHL6 _3eOF8", "value-null-light": "_2T6PJ", "value-undefined-light": "_1Gho6", "value-string-light": "_vGjyY", "value-number-light": "_1bQdo", "value-boolean-light": "_3zQKs", "value-other-light": "_1xvuR", "collapse-icon-light": "_oLqym _f10Tu _1MFti _1LId0", "expand-icon-light": "_2AXVT _f10Tu _1MFti _1UmXx", "collapsed-content-light": "_2KJWg _1pNG9 _1MFti", "container-dark": "_11RoI _GzYRV", "expand-icon-dark": "_17H2C _f10Tu _1MFti _1UmXx", "collapse-icon-dark": "_3QHg2 _f10Tu _1MFti _1LId0", "collapsed-content-dark": "_3fDAz _1pNG9 _1MFti", "label-dark": "_2bSDX", "clickable-label-dark": "_1RQEj _2bSDX _1MFti", "punctuation-dark": "_gsbQL _3eOF8", "value-null-dark": "_LaAZe", "value-undefined-dark": "_GTKgm", "value-string-dark": "_Chy1W", "value-number-dark": "_2bveF", "value-boolean-dark": "_2vRm-", "value-other-dark": "_1prJR" };
const z2 = {
  collapseJson: "collapse JSON",
  expandJson: "expand JSON"
}, _T = {
  container: st["container-light"],
  basicChildStyle: st["basic-element-style"],
  childFieldsContainer: st["child-fields-container"],
  label: st["label-light"],
  clickableLabel: st["clickable-label-light"],
  nullValue: st["value-null-light"],
  undefinedValue: st["value-undefined-light"],
  stringValue: st["value-string-light"],
  booleanValue: st["value-boolean-light"],
  numberValue: st["value-number-light"],
  otherValue: st["value-other-light"],
  punctuation: st["punctuation-light"],
  collapseIcon: st["collapse-icon-light"],
  expandIcon: st["expand-icon-light"],
  collapsedContent: st["collapsed-content-light"],
  noQuotesForStringValues: !1,
  quotesForFieldNames: !1,
  ariaLables: z2,
  stringifyStringValues: !1
}, gW = {
  container: st["container-dark"],
  basicChildStyle: st["basic-element-style"],
  childFieldsContainer: st["child-fields-container"],
  label: st["label-dark"],
  clickableLabel: st["clickable-label-dark"],
  nullValue: st["value-null-dark"],
  undefinedValue: st["value-undefined-dark"],
  stringValue: st["value-string-dark"],
  booleanValue: st["value-boolean-dark"],
  numberValue: st["value-number-dark"],
  otherValue: st["value-other-dark"],
  punctuation: st["punctuation-dark"],
  collapseIcon: st["collapse-icon-dark"],
  expandIcon: st["expand-icon-dark"],
  collapsedContent: st["collapsed-content-dark"],
  noQuotesForStringValues: !1,
  quotesForFieldNames: !1,
  ariaLables: z2,
  stringifyStringValues: !1
}, yW = () => !0, vW = (e) => e < 1, bW = (e) => {
  let {
    data: t,
    style: n = _T,
    shouldExpandNode: r = yW,
    clickToExpandNode: o = !1,
    beforeExpandChange: a,
    ...s
  } = e;
  const u = _.useRef(null);
  return /* @__PURE__ */ _.createElement("div", Object.assign({
    "aria-label": "JSON view"
  }, s, {
    className: n.container,
    ref: u,
    role: "tree"
  }), /* @__PURE__ */ _.createElement(I2, {
    value: t,
    style: {
      ..._T,
      ...n
    },
    lastElement: !0,
    level: 0,
    shouldExpandNode: r,
    clickToExpandNode: o,
    outerRef: u,
    beforeExpandChange: a
  }));
};
function xW(e) {
  for (const t in e)
    if (Object.hasOwn(e, t))
      return !1;
  return !0;
}
function wW(e) {
  if (e == null || typeof e != "object")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t !== null && t !== Object.prototype ? !1 : xW(e);
}
const _W = ({
  data: e,
  className: t = "json-display"
}) => /* @__PURE__ */ x.jsx("div", { className: t, children: /* @__PURE__ */ x.jsx(
  bW,
  {
    data: wW(e) ? "" : e,
    style: gW,
    shouldExpandNode: vW
  }
) });
function SW(e, t, n = {}) {
  const {
    maxFontSize: r = 100,
    // default maximum font size
    minFontSize: o = 6,
    // default minimum font size
    decrementFactor: a = 0.9
    // font size decrement step
  } = n;
  if (!e || !t)
    return;
  if (a >= 1 || a <= 0)
    throw new Error("decrementFactor must be between 0 and 1");
  const s = e.getBoundingClientRect(), u = s.width, c = s.height;
  let f = r;
  t.style.whiteSpace = "nowrap", t.style.display = "inline-block", t.style.fontSize = f + "px";
  let h = t.getBoundingClientRect();
  for (; (h.width > u || h.height > c) && f > o; )
    f *= a, t.style.fontSize = f + "px", h = t.getBoundingClientRect();
}
function EW(e = {
  n: 0,
  elapsed: 0,
  ascii: !1,
  unit: "it",
  unit_scale: !1,
  unit_divisor: 1e3
}) {
  let t = e.total ?? null;
  const {
    n = 0,
    unit_scale: r = !1,
    elapsed: o = 0,
    // ascii,
    unit: a = "it",
    unit_divisor: s = 1e3,
    // ncols = undefined,
    prefix: u = "",
    rate: c = void 0,
    // bar_format = undefined,
    postfix: f = null,
    initial: h = 0
    // colour = undefined,
  } = e;
  t !== null && n >= t + 0.5 && (t = null);
  let p = n, g = t, y = c;
  r && r !== !0 && r !== 1 && (t !== null && (g = t * r), p = n * r, c !== void 0 && (y = c * r));
  const w = ST(o);
  y === void 0 && o > 0 && (y = (p - h) / o);
  const v = y ? 1 / y : void 0, [S, E] = y ? lh(y, s) : [void 0, ""], [T, k] = v ? lh(v, 1e3) : [void 0, ""], A = (S || "?") + `${E}${a}/s`, M = T ? `${T}${k}s/` + a : "?", N = v && v > 1 ? M : A, P = r ? lh(p, s).join("") : p.toString(), z = r && g !== null ? lh(g, s).join("") : g?.toString() ?? "?", B = y && g !== null ? (g - p) / y : 0, R = y ? ST(B) : "?", F = u ? `${u}: ` : "";
  if (t !== null) {
    const U = p / t * 100, W = ` ${P}/${z} [${w} < ${R}, ${N}${f ?? ""}]`;
    return `${F}${U.toFixed(0)}%${W}`;
  }
  return `${F}${P}${a} [${w}, ${N}${f ?? ""}]`;
}
function ST(e) {
  const t = Math.floor(e / 60), n = Math.floor(e % 60);
  return `${t}:${n.toString().padStart(2, "0")}`;
}
function lh(e, t) {
  const n = ["", "K", "M", "G", "T"];
  let r = 0;
  for (; e >= t && r < n.length - 1; )
    e /= t, r++;
  return [e.toFixed(2), n[r]];
}
const CW = ({ state: e, className: t = "reacttqdm", ...n }) => {
  const r = _.useRef(null), o = _.useRef(null);
  _.useEffect(() => {
    const s = () => {
      !r.current || !o.current || SW(r.current, o.current, {
        maxFontSize: 12,
        decrementFactor: 0.9
      });
    };
    return s(), window.addEventListener("resize", s), () => {
      window.removeEventListener("resize", s);
    };
  }, [e]);
  const a = e.total ? (e.n ?? 0) / e.total * 100 : 0;
  return /* @__PURE__ */ x.jsx("div", { ref: r, className: t, ...n, children: /* @__PURE__ */ x.jsxs(
    "div",
    {
      style: {
        position: "relative",
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center"
      },
      children: [
        /* @__PURE__ */ x.jsx(
          "div",
          {
            className: t + "-bar",
            style: {
              position: "absolute",
              width: "100%",
              height: "100%",
              // Adjust height if needed
              overflow: "hidden"
            },
            children: /* @__PURE__ */ x.jsx(
              "div",
              {
                className: t + "-progress",
                style: {
                  width: `${a}%`,
                  height: "100%"
                }
              }
            )
          }
        ),
        /* @__PURE__ */ x.jsx("div", { className: t + "-text", ref: o, children: EW(e) })
      ]
    }
  ) });
};
var uh = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var ET;
function kW() {
  if (ET) return uh;
  ET = 1;
  var e = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, t = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, n = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, r = /\\([\u000b\u0020-\u00ff])/g, o = /([\\"])/g, a = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  uh.format = s, uh.parse = u;
  function s(p) {
    if (!p || typeof p != "object")
      throw new TypeError("argument obj is required");
    var g = p.parameters, y = p.type;
    if (!y || !a.test(y))
      throw new TypeError("invalid type");
    var w = y;
    if (g && typeof g == "object")
      for (var v, S = Object.keys(g).sort(), E = 0; E < S.length; E++) {
        if (v = S[E], !n.test(v))
          throw new TypeError("invalid parameter name");
        w += "; " + v + "=" + f(g[v]);
      }
    return w;
  }
  function u(p) {
    if (!p)
      throw new TypeError("argument string is required");
    var g = typeof p == "object" ? c(p) : p;
    if (typeof g != "string")
      throw new TypeError("argument string is required to be a string");
    var y = g.indexOf(";"), w = y !== -1 ? g.slice(0, y).trim() : g.trim();
    if (!a.test(w))
      throw new TypeError("invalid media type");
    var v = new h(w.toLowerCase());
    if (y !== -1) {
      var S, E, T;
      for (e.lastIndex = y; E = e.exec(g); ) {
        if (E.index !== y)
          throw new TypeError("invalid parameter format");
        y += E[0].length, S = E[1].toLowerCase(), T = E[2], T.charCodeAt(0) === 34 && (T = T.slice(1, -1), T.indexOf("\\") !== -1 && (T = T.replace(r, "$1"))), v.parameters[S] = T;
      }
      if (y !== g.length)
        throw new TypeError("invalid parameter format");
    }
    return v;
  }
  function c(p) {
    var g;
    if (typeof p.getHeader == "function" ? g = p.getHeader("content-type") : typeof p.headers == "object" && (g = p.headers && p.headers["content-type"]), typeof g != "string")
      throw new TypeError("content-type header is missing from object");
    return g;
  }
  function f(p) {
    var g = String(p);
    if (n.test(g))
      return g;
    if (g.length > 0 && !t.test(g))
      throw new TypeError("invalid parameter value");
    return '"' + g.replace(o, "\\$1") + '"';
  }
  function h(p) {
    this.parameters = /* @__PURE__ */ Object.create(null), this.type = p;
  }
  return uh;
}
var TW = kW(), el = /* @__PURE__ */ new Map(), L2 = function(t) {
  return t.cloneNode(!0);
}, CT = function() {
  return window.location.protocol === "file:";
}, F2 = function(t, n, r) {
  var o = new XMLHttpRequest();
  o.onreadystatechange = function() {
    try {
      if (!/\.svg/i.test(t) && o.readyState === 2) {
        var a = o.getResponseHeader("Content-Type");
        if (!a)
          throw new Error("Content type not found");
        var s = TW.parse(a).type;
        if (!(s === "image/svg+xml" || s === "text/plain"))
          throw new Error("Invalid content type: ".concat(s));
      }
      if (o.readyState === 4) {
        if (o.status === 404 || o.responseXML === null)
          throw new Error(CT() ? "Note: SVG injection ajax calls do not work locally without adjusting security settings in your browser. Or consider using a local webserver." : "Unable to load SVG file: " + t);
        if (o.status === 200 || CT() && o.status === 0)
          r(null, o);
        else
          throw new Error("There was a problem injecting the SVG: " + o.status + " " + o.statusText);
      }
    } catch (u) {
      if (o.abort(), u instanceof Error)
        r(u, o);
      else
        throw u;
    }
  }, o.open("GET", t), o.withCredentials = n, o.overrideMimeType && o.overrideMimeType("text/xml"), o.send();
}, Wi = {}, kT = function(t, n) {
  Wi[t] = Wi[t] || [], Wi[t].push(n);
}, AW = function(t) {
  for (var n = function(s, u) {
    setTimeout(function() {
      if (Array.isArray(Wi[t])) {
        var c = el.get(t), f = Wi[t][s];
        c instanceof SVGSVGElement && f(null, L2(c)), c instanceof Error && f(c), s === Wi[t].length - 1 && delete Wi[t];
      }
    }, 0);
  }, r = 0, o = Wi[t].length; r < o; r++)
    n(r);
}, RW = function(t, n, r) {
  if (el.has(t)) {
    var o = el.get(t);
    if (o === void 0) {
      kT(t, r);
      return;
    }
    if (o instanceof SVGSVGElement) {
      r(null, L2(o));
      return;
    }
  }
  el.set(t, void 0), kT(t, r), F2(t, n, function(a, s) {
    var u;
    a ? el.set(t, a) : ((u = s.responseXML) === null || u === void 0 ? void 0 : u.documentElement) instanceof SVGSVGElement && el.set(t, s.responseXML.documentElement), AW(t);
  });
}, MW = function(t, n, r) {
  F2(t, n, function(o, a) {
    var s;
    o ? r(o) : ((s = a.responseXML) === null || s === void 0 ? void 0 : s.documentElement) instanceof SVGSVGElement && r(null, a.responseXML.documentElement);
  });
}, OW = 0, NW = function() {
  return ++OW;
}, Jr = [], TT = {}, DW = "http://www.w3.org/2000/svg", Jy = "http://www.w3.org/1999/xlink", AT = function(t, n, r, o, a, s, u) {
  var c = t.getAttribute("data-src") || t.getAttribute("src");
  if (!c) {
    u(new Error("Invalid data-src or src attribute"));
    return;
  }
  if (Jr.indexOf(t) !== -1) {
    Jr.splice(Jr.indexOf(t), 1), t = null;
    return;
  }
  Jr.push(t), t.setAttribute("src", "");
  var f = o ? RW : MW;
  f(c, a, function(h, p) {
    if (!p) {
      Jr.splice(Jr.indexOf(t), 1), t = null, u(h);
      return;
    }
    var g = t.getAttribute("id");
    g && p.setAttribute("id", g);
    var y = t.getAttribute("title");
    y && p.setAttribute("title", y);
    var w = t.getAttribute("width");
    w && p.setAttribute("width", w);
    var v = t.getAttribute("height");
    v && p.setAttribute("height", v);
    var S = Array.from(new Set(Oh(Oh(Oh([], (p.getAttribute("class") || "").split(" "), !0), ["injected-svg"], !1), (t.getAttribute("class") || "").split(" "), !0))).join(" ").trim();
    p.setAttribute("class", S);
    var E = t.getAttribute("style");
    E && p.setAttribute("style", E), p.setAttribute("data-src", c);
    var T = [].filter.call(t.attributes, function(q) {
      return /^data-\w[\w-]*$/.test(q.name);
    });
    if (Array.prototype.forEach.call(T, function(q) {
      q.name && q.value && p.setAttribute(q.name, q.value);
    }), r) {
      var k = {
        clipPath: ["clip-path"],
        "color-profile": ["color-profile"],
        cursor: ["cursor"],
        filter: ["filter"],
        linearGradient: ["fill", "stroke"],
        marker: ["marker", "marker-start", "marker-mid", "marker-end"],
        mask: ["mask"],
        path: [],
        pattern: ["fill", "stroke"],
        radialGradient: ["fill", "stroke"]
      }, A, M, N, P, z;
      Object.keys(k).forEach(function(q) {
        A = q, N = k[q], M = p.querySelectorAll(A + "[id]");
        for (var G = function(L, te) {
          P = M[L].id, z = P + "-" + NW();
          var he;
          Array.prototype.forEach.call(N, function(Ee) {
            he = p.querySelectorAll("[" + Ee + '*="' + P + '"]');
            for (var _e = 0, Xe = he.length; _e < Xe; _e++) {
              var St = he[_e].getAttribute(Ee);
              St && !St.match(new RegExp('url\\("?#' + P + '"?\\)')) || he[_e].setAttribute(Ee, "url(#" + z + ")");
            }
          });
          for (var oe = p.querySelectorAll("[*|href]"), de = [], le = 0, ye = oe.length; le < ye; le++) {
            var je = oe[le].getAttributeNS(Jy, "href");
            je && je.toString() === "#" + M[L].id && de.push(oe[le]);
          }
          for (var Ne = 0, we = de.length; Ne < we; Ne++)
            de[Ne].setAttributeNS(Jy, "href", "#" + z);
          M[L].id = z;
        }, O = 0, Y = M.length; O < Y; O++)
          G(O);
      });
    }
    p.removeAttribute("xmlns:a");
    for (var B = p.querySelectorAll("script"), R = [], F, U, W = 0, j = B.length; W < j; W++)
      U = B[W].getAttribute("type"), (!U || U === "application/ecmascript" || U === "application/javascript" || U === "text/javascript") && (F = B[W].innerText || B[W].textContent, F && R.push(F), p.removeChild(B[W]));
    if (R.length > 0 && (n === "always" || n === "once" && !TT[c])) {
      for (var V = 0, I = R.length; V < I; V++)
        new Function(R[V])(window);
      TT[c] = !0;
    }
    var H = p.querySelectorAll("style");
    if (Array.prototype.forEach.call(H, function(q) {
      q.textContent += "";
    }), p.setAttribute("xmlns", DW), p.setAttribute("xmlns:xlink", Jy), s(p), !t.parentNode) {
      Jr.splice(Jr.indexOf(t), 1), t = null, u(new Error("Parent node is null"));
      return;
    }
    t.parentNode.replaceChild(p, t), Jr.splice(Jr.indexOf(t), 1), t = null, u(null, p);
  });
}, PW = function(t, n) {
  var r = n === void 0 ? {} : n, o = r.afterAll, a = o === void 0 ? function() {
  } : o, s = r.afterEach, u = s === void 0 ? function() {
  } : s, c = r.beforeEach, f = c === void 0 ? function() {
  } : c, h = r.cacheRequests, p = h === void 0 ? !0 : h, g = r.evalScripts, y = g === void 0 ? "never" : g, w = r.httpRequestWithCredentials, v = w === void 0 ? !1 : w, S = r.renumerateIRIElements, E = S === void 0 ? !0 : S;
  if (t && "length" in t)
    for (var T = 0, k = 0, A = t.length; k < A; k++)
      AT(t[k], y, E, p, v, f, function(M, N) {
        u(M, N), t && "length" in t && t.length === ++T && a(T);
      });
  else t ? AT(t, y, E, p, v, f, function(M, N) {
    u(M, N), a(1), t = null;
  }) : a(0);
}, jW = function(t) {
  var n = t?.ownerDocument || document;
  return n.defaultView || window;
}, IW = function(t, n) {
  for (var r in t)
    if (!(r in n))
      return !0;
  for (var o in n)
    if (t[o] !== n[o])
      return !0;
  return !1;
}, zW = ["afterInjection", "beforeInjection", "desc", "evalScripts", "fallback", "httpRequestWithCredentials", "loading", "renumerateIRIElements", "src", "title", "useRequestCache", "wrapper"], ch = "http://www.w3.org/2000/svg", RT = "http://www.w3.org/1999/xlink", lx = /* @__PURE__ */ function(e) {
  function t() {
    for (var r, o = arguments.length, a = new Array(o), s = 0; s < o; s++)
      a[s] = arguments[s];
    return r = e.call.apply(e, [this].concat(a)) || this, r.initialState = {
      hasError: !1,
      isLoading: !0
    }, r.state = r.initialState, r._isMounted = !1, r.reactWrapper = void 0, r.nonReactWrapper = void 0, r.refCallback = function(u) {
      r.reactWrapper = u;
    }, r;
  }
  DM(t, e);
  var n = t.prototype;
  return n.renderSVG = function() {
    var o = this;
    if (this.reactWrapper instanceof jW(this.reactWrapper).Node) {
      var a = this.props, s = a.desc, u = a.evalScripts, c = a.httpRequestWithCredentials, f = a.renumerateIRIElements, h = a.src, p = a.title, g = a.useRequestCache, y = this.props.onError, w = this.props.beforeInjection, v = this.props.afterInjection, S = this.props.wrapper, E, T;
      S === "svg" ? (E = document.createElementNS(ch, S), E.setAttribute("xmlns", ch), E.setAttribute("xmlns:xlink", RT), T = document.createElementNS(ch, S)) : (E = document.createElement(S), T = document.createElement(S)), E.appendChild(T), T.dataset.src = h, this.nonReactWrapper = this.reactWrapper.appendChild(E);
      var k = function(P) {
        if (o.removeSVG(), !o._isMounted) {
          y(P);
          return;
        }
        o.setState(function() {
          return {
            hasError: !0,
            isLoading: !1
          };
        }, function() {
          y(P);
        });
      }, A = function(P, z) {
        if (P) {
          k(P);
          return;
        }
        o._isMounted && o.setState(function() {
          return {
            isLoading: !1
          };
        }, function() {
          try {
            v(z);
          } catch (B) {
            k(B);
          }
        });
      }, M = function(P) {
        if (P.setAttribute("role", "img"), s) {
          var z = P.querySelector(":scope > desc");
          z && P.removeChild(z);
          var B = document.createElement("desc");
          B.innerHTML = s, P.prepend(B);
        }
        if (p) {
          var R = P.querySelector(":scope > title");
          R && P.removeChild(R);
          var F = document.createElement("title");
          F.innerHTML = p, P.prepend(F);
        }
        try {
          w(P);
        } catch (U) {
          k(U);
        }
      };
      PW(T, {
        afterEach: A,
        beforeEach: M,
        cacheRequests: g,
        evalScripts: u,
        httpRequestWithCredentials: c,
        renumerateIRIElements: f
      });
    }
  }, n.removeSVG = function() {
    var o;
    (o = this.nonReactWrapper) != null && o.parentNode && (this.nonReactWrapper.parentNode.removeChild(this.nonReactWrapper), this.nonReactWrapper = null);
  }, n.componentDidMount = function() {
    this._isMounted = !0, this.renderSVG();
  }, n.componentDidUpdate = function(o) {
    var a = this;
    IW(Re({}, o), this.props) && this.setState(function() {
      return a.initialState;
    }, function() {
      a.removeSVG(), a.renderSVG();
    });
  }, n.componentWillUnmount = function() {
    this._isMounted = !1, this.removeSVG();
  }, n.render = function() {
    var o = this.props;
    o.afterInjection, o.beforeInjection, o.desc, o.evalScripts;
    var a = o.fallback;
    o.httpRequestWithCredentials;
    var s = o.loading;
    o.renumerateIRIElements, o.src, o.title, o.useRequestCache;
    var u = o.wrapper, c = S1(o, zW), f = u;
    return /* @__PURE__ */ _.createElement(f, Re({}, c, {
      ref: this.refCallback
    }, u === "svg" ? {
      xmlns: ch,
      xmlnsXlink: RT
    } : {}), this.state.isLoading && s && /* @__PURE__ */ _.createElement(s, null), this.state.hasError && a && /* @__PURE__ */ _.createElement(a, null));
  }, t;
}(_.Component);
lx.defaultProps = {
  afterInjection: function() {
  },
  beforeInjection: function() {
  },
  desc: "",
  evalScripts: "never",
  fallback: null,
  httpRequestWithCredentials: !1,
  loading: null,
  onError: function() {
  },
  renumerateIRIElements: !0,
  title: "",
  useRequestCache: !0,
  wrapper: "div"
};
lx.propTypes = {
  afterInjection: Ut.func,
  beforeInjection: Ut.func,
  desc: Ut.string,
  evalScripts: Ut.oneOf(["always", "once", "never"]),
  fallback: Ut.oneOfType([Ut.func, Ut.object, Ut.string]),
  httpRequestWithCredentials: Ut.bool,
  loading: Ut.oneOfType([Ut.func, Ut.object, Ut.string]),
  onError: Ut.func,
  renumerateIRIElements: Ut.bool,
  src: Ut.string.isRequired,
  title: Ut.string,
  useRequestCache: Ut.bool,
  wrapper: Ut.oneOf(["div", "span", "svg"])
};
const ux = ({
  text: e = "No image data provided"
}) => /* @__PURE__ */ x.jsx(
  "div",
  {
    style: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      minHeight: "100px",
      border: "1px dashed #ccc",
      color: "#666"
    },
    children: e
  }
), LW = _.memo(
  ({
    value: e,
    format: t = "jpeg",
    alt: n = "Base64 image",
    onError: r,
    onLoad: o,
    ...a
  }) => {
    const [s, u] = _.useState(!1), [c, f] = _.useState(!0), h = _.useRef(null), p = _.useMemo(() => {
      if (typeof e == "string")
        return e;
      if (e && typeof e == "object" && "data" in e) {
        const v = e.data;
        if (v instanceof ArrayBuffer) {
          const S = new Uint8Array(v);
          let E = "";
          for (let T = 0; T < S.byteLength; T++)
            E += String.fromCharCode(S[T]);
          return btoa(E);
        }
      }
      return "";
    }, [e]), g = _.useMemo(() => p ? `data:image/${t};base64,${p}` : "", [p, t]), y = _.useCallback(
      (v) => {
        u(!0), f(!1), r?.(v);
      },
      [r]
    ), w = _.useCallback(() => {
      f(!1), u(!1), o?.();
    }, [o]);
    return _.useEffect(() => {
      const v = h.current;
      if (v)
        return v.addEventListener("error", y), v.addEventListener("load", w), () => {
          v.removeEventListener("error", y), v.removeEventListener("load", w);
        };
    }, [y, w, e]), _.useEffect(() => {
      u(!1), f(!0);
    }, [e]), p ? s ? /* @__PURE__ */ x.jsx(
      "div",
      {
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          minHeight: "100px",
          border: "1px dashed #ccc",
          color: "#666"
        },
        children: "Failed to load base64 image"
      }
    ) : /* @__PURE__ */ x.jsx(
      "img",
      {
        ref: h,
        src: g,
        alt: n,
        className: `base64-image-renderer ${a.className || ""} ${c ? " loading" : ""}`,
        ...a
      }
    ) : /* @__PURE__ */ x.jsx(ux, {});
  }
), FW = _.memo(
  ({
    value: e,
    alt: t = "SVG image",
    onError: n,
    onLoad: r,
    ...o
  }) => {
    const [a, s] = _.useState(!1), u = _.useMemo(() => {
      if (!e) return "";
      try {
        return `data:image/svg+xml;base64,${btoa(e)}`;
      } catch (f) {
        return console.error("Failed to encode SVG to base64:", f), "";
      }
    }, [e]);
    _.useEffect(() => {
      s(!1);
    }, [e]);
    const c = _.useCallback(
      (f) => {
        s(!0), n?.(f);
      },
      [n]
    );
    return e ? a || !u ? /* @__PURE__ */ x.jsx(
      "div",
      {
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          minHeight: "100px",
          border: "1px dashed #ccc",
          color: "#666"
        },
        children: "Failed to load SVG"
      }
    ) : /* @__PURE__ */ x.jsx(
      lx,
      {
        src: u,
        className: `svg-renderer ${o.className || ""}`,
        style: {
          maxWidth: "100%",
          maxHeight: "100%",
          ...o.style
        },
        beforeInjection: (f) => {
          f.classList.add("svg-renderer"), f.setAttribute("style", "max-width: 100%; max-height: 100%;"), f.setAttribute("width", "100%"), f.setAttribute("height", "100%"), f.setAttribute("aria-label", t);
          const h = () => {
            s(!1), r?.();
          }, p = (g) => {
            s(!0), n?.(g);
          };
          try {
            f.addEventListener("load", h), f.addEventListener("error", p);
          } catch {
            h();
          }
        },
        onError: c
      }
    ) : /* @__PURE__ */ x.jsx(ux, {});
  }
), $W = _.memo(
  ({
    src: e,
    alt: t = "Streaming image",
    onError: n,
    onLoad: r,
    ...o
  }) => {
    const a = _.useRef(null), [s, u] = _.useState(!1), [c, f] = _.useState(!0);
    _.useEffect(() => {
      a.current && e && (f(!0), u(!1), a.current.src = e);
    }, [e]);
    const h = _.useCallback(
      (g) => {
        u(!0), f(!1), n?.(g);
      },
      [n]
    ), p = _.useCallback(() => {
      f(!1), u(!1), r?.();
    }, [r]);
    return _.useEffect(() => {
      const g = a.current;
      if (g)
        return g.addEventListener("error", h), g.addEventListener("load", p), () => {
          g.removeEventListener("error", h), g.removeEventListener("load", p);
        };
    }, [h, p]), s ? /* @__PURE__ */ x.jsx(ux, { text: "Failed to load image" }) : /* @__PURE__ */ x.jsx(
      "img",
      {
        ref: a,
        className: `streaming-image ${o.className || ""} ${c ? " loading" : ""}`,
        alt: t,
        ...o
      }
    );
  }
);
function xm(e) {
  const t = e + "CollectionProvider", [n, r] = _o(t), [o, a] = n(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), s = (v) => {
    const { scope: S, children: E } = v, T = nn.useRef(null), k = nn.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ x.jsx(o, { scope: S, itemMap: k, collectionRef: T, children: E });
  };
  s.displayName = t;
  const u = e + "CollectionSlot", c = /* @__PURE__ */ bl(u), f = nn.forwardRef(
    (v, S) => {
      const { scope: E, children: T } = v, k = a(u, E), A = bt(S, k.collectionRef);
      return /* @__PURE__ */ x.jsx(c, { ref: A, children: T });
    }
  );
  f.displayName = u;
  const h = e + "CollectionItemSlot", p = "data-radix-collection-item", g = /* @__PURE__ */ bl(h), y = nn.forwardRef(
    (v, S) => {
      const { scope: E, children: T, ...k } = v, A = nn.useRef(null), M = bt(S, A), N = a(h, E);
      return nn.useEffect(() => (N.itemMap.set(A, { ref: A, ...k }), () => void N.itemMap.delete(A))), /* @__PURE__ */ x.jsx(g, { [p]: "", ref: M, children: T });
    }
  );
  y.displayName = h;
  function w(v) {
    const S = a(e + "CollectionConsumer", v);
    return nn.useCallback(() => {
      const T = S.collectionRef.current;
      if (!T) return [];
      const k = Array.from(T.querySelectorAll(`[${p}]`));
      return Array.from(S.itemMap.values()).sort(
        (N, P) => k.indexOf(N.ref.current) - k.indexOf(P.ref.current)
      );
    }, [S.collectionRef, S.itemMap]);
  }
  return [
    { Provider: s, Slot: f, ItemSlot: y },
    w,
    r
  ];
}
var BW = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
}), HW = "VisuallyHidden", cx = _.forwardRef(
  (e, t) => /* @__PURE__ */ x.jsx(
    qe.span,
    {
      ...e,
      ref: t,
      style: { ...BW, ...e.style }
    }
  )
);
cx.displayName = HW;
var fx = "ToastProvider", [dx, VW, UW] = xm("Toast"), [$2, Ype] = _o("Toast", [UW]), [qW, wm] = $2(fx), B2 = (e) => {
  const {
    __scopeToast: t,
    label: n = "Notification",
    duration: r = 5e3,
    swipeDirection: o = "right",
    swipeThreshold: a = 50,
    children: s
  } = e, [u, c] = _.useState(null), [f, h] = _.useState(0), p = _.useRef(!1), g = _.useRef(!1);
  return n.trim() || console.error(
    `Invalid prop \`label\` supplied to \`${fx}\`. Expected non-empty \`string\`.`
  ), /* @__PURE__ */ x.jsx(dx.Provider, { scope: t, children: /* @__PURE__ */ x.jsx(
    qW,
    {
      scope: t,
      label: n,
      duration: r,
      swipeDirection: o,
      swipeThreshold: a,
      toastCount: f,
      viewport: u,
      onViewportChange: c,
      onToastAdd: _.useCallback(() => h((y) => y + 1), []),
      onToastRemove: _.useCallback(() => h((y) => y - 1), []),
      isFocusedToastEscapeKeyDownRef: p,
      isClosePausedRef: g,
      children: s
    }
  ) });
};
B2.displayName = fx;
var H2 = "ToastViewport", GW = ["F8"], bb = "toast.viewportPause", xb = "toast.viewportResume", V2 = _.forwardRef(
  (e, t) => {
    const {
      __scopeToast: n,
      hotkey: r = GW,
      label: o = "Notifications ({hotkey})",
      ...a
    } = e, s = wm(H2, n), u = VW(n), c = _.useRef(null), f = _.useRef(null), h = _.useRef(null), p = _.useRef(null), g = bt(t, p, s.onViewportChange), y = r.join("+").replace(/Key/g, "").replace(/Digit/g, ""), w = s.toastCount > 0;
    _.useEffect(() => {
      const S = (E) => {
        r.length !== 0 && r.every((k) => E[k] || E.code === k) && p.current?.focus();
      };
      return document.addEventListener("keydown", S), () => document.removeEventListener("keydown", S);
    }, [r]), _.useEffect(() => {
      const S = c.current, E = p.current;
      if (w && S && E) {
        const T = () => {
          if (!s.isClosePausedRef.current) {
            const N = new CustomEvent(bb);
            E.dispatchEvent(N), s.isClosePausedRef.current = !0;
          }
        }, k = () => {
          if (s.isClosePausedRef.current) {
            const N = new CustomEvent(xb);
            E.dispatchEvent(N), s.isClosePausedRef.current = !1;
          }
        }, A = (N) => {
          !S.contains(N.relatedTarget) && k();
        }, M = () => {
          S.contains(document.activeElement) || k();
        };
        return S.addEventListener("focusin", T), S.addEventListener("focusout", A), S.addEventListener("pointermove", T), S.addEventListener("pointerleave", M), window.addEventListener("blur", T), window.addEventListener("focus", k), () => {
          S.removeEventListener("focusin", T), S.removeEventListener("focusout", A), S.removeEventListener("pointermove", T), S.removeEventListener("pointerleave", M), window.removeEventListener("blur", T), window.removeEventListener("focus", k);
        };
      }
    }, [w, s.isClosePausedRef]);
    const v = _.useCallback(
      ({ tabbingDirection: S }) => {
        const T = u().map((k) => {
          const A = k.ref.current, M = [A, ...iX(A)];
          return S === "forwards" ? M : M.reverse();
        });
        return (S === "forwards" ? T.reverse() : T).flat();
      },
      [u]
    );
    return _.useEffect(() => {
      const S = p.current;
      if (S) {
        const E = (T) => {
          const k = T.altKey || T.ctrlKey || T.metaKey;
          if (T.key === "Tab" && !k) {
            const M = document.activeElement, N = T.shiftKey;
            if (T.target === S && N) {
              f.current?.focus();
              return;
            }
            const B = v({ tabbingDirection: N ? "backwards" : "forwards" }), R = B.findIndex((F) => F === M);
            ev(B.slice(R + 1)) ? T.preventDefault() : N ? f.current?.focus() : h.current?.focus();
          }
        };
        return S.addEventListener("keydown", E), () => S.removeEventListener("keydown", E);
      }
    }, [u, v]), /* @__PURE__ */ x.jsxs(
      C8,
      {
        ref: c,
        role: "region",
        "aria-label": o.replace("{hotkey}", y),
        tabIndex: -1,
        style: { pointerEvents: w ? void 0 : "none" },
        children: [
          w && /* @__PURE__ */ x.jsx(
            wb,
            {
              ref: f,
              onFocusFromOutsideViewport: () => {
                const S = v({
                  tabbingDirection: "forwards"
                });
                ev(S);
              }
            }
          ),
          /* @__PURE__ */ x.jsx(dx.Slot, { scope: n, children: /* @__PURE__ */ x.jsx(qe.ol, { tabIndex: -1, ...a, ref: g }) }),
          w && /* @__PURE__ */ x.jsx(
            wb,
            {
              ref: h,
              onFocusFromOutsideViewport: () => {
                const S = v({
                  tabbingDirection: "backwards"
                });
                ev(S);
              }
            }
          )
        ]
      }
    );
  }
);
V2.displayName = H2;
var U2 = "ToastFocusProxy", wb = _.forwardRef(
  (e, t) => {
    const { __scopeToast: n, onFocusFromOutsideViewport: r, ...o } = e, a = wm(U2, n);
    return /* @__PURE__ */ x.jsx(
      cx,
      {
        "aria-hidden": !0,
        tabIndex: 0,
        ...o,
        ref: t,
        style: { position: "fixed" },
        onFocus: (s) => {
          const u = s.relatedTarget;
          !a.viewport?.contains(u) && r();
        }
      }
    );
  }
);
wb.displayName = U2;
var cf = "Toast", YW = "toast.swipeStart", WW = "toast.swipeMove", XW = "toast.swipeCancel", KW = "toast.swipeEnd", q2 = _.forwardRef(
  (e, t) => {
    const { forceMount: n, open: r, defaultOpen: o, onOpenChange: a, ...s } = e, [u, c] = sa({
      prop: r,
      defaultProp: o ?? !0,
      onChange: a,
      caller: cf
    });
    return /* @__PURE__ */ x.jsx(Br, { present: n || u, children: /* @__PURE__ */ x.jsx(
      JW,
      {
        open: u,
        ...s,
        ref: t,
        onClose: () => c(!1),
        onPause: Hn(e.onPause),
        onResume: Hn(e.onResume),
        onSwipeStart: xe(e.onSwipeStart, (f) => {
          f.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: xe(e.onSwipeMove, (f) => {
          const { x: h, y: p } = f.detail.delta;
          f.currentTarget.setAttribute("data-swipe", "move"), f.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${h}px`), f.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${p}px`);
        }),
        onSwipeCancel: xe(e.onSwipeCancel, (f) => {
          f.currentTarget.setAttribute("data-swipe", "cancel"), f.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), f.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), f.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), f.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: xe(e.onSwipeEnd, (f) => {
          const { x: h, y: p } = f.detail.delta;
          f.currentTarget.setAttribute("data-swipe", "end"), f.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), f.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), f.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${h}px`), f.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${p}px`), c(!1);
        })
      }
    ) });
  }
);
q2.displayName = cf;
var [ZW, QW] = $2(cf, {
  onClose() {
  }
}), JW = _.forwardRef(
  (e, t) => {
    const {
      __scopeToast: n,
      type: r = "foreground",
      duration: o,
      open: a,
      onClose: s,
      onEscapeKeyDown: u,
      onPause: c,
      onResume: f,
      onSwipeStart: h,
      onSwipeMove: p,
      onSwipeCancel: g,
      onSwipeEnd: y,
      ...w
    } = e, v = wm(cf, n), [S, E] = _.useState(null), T = bt(t, (j) => E(j)), k = _.useRef(null), A = _.useRef(null), M = o || v.duration, N = _.useRef(0), P = _.useRef(M), z = _.useRef(0), { onToastAdd: B, onToastRemove: R } = v, F = Hn(() => {
      S?.contains(document.activeElement) && v.viewport?.focus(), s();
    }), U = _.useCallback(
      (j) => {
        !j || j === 1 / 0 || (window.clearTimeout(z.current), N.current = (/* @__PURE__ */ new Date()).getTime(), z.current = window.setTimeout(F, j));
      },
      [F]
    );
    _.useEffect(() => {
      const j = v.viewport;
      if (j) {
        const V = () => {
          U(P.current), f?.();
        }, I = () => {
          const H = (/* @__PURE__ */ new Date()).getTime() - N.current;
          P.current = P.current - H, window.clearTimeout(z.current), c?.();
        };
        return j.addEventListener(bb, I), j.addEventListener(xb, V), () => {
          j.removeEventListener(bb, I), j.removeEventListener(xb, V);
        };
      }
    }, [v.viewport, M, c, f, U]), _.useEffect(() => {
      a && !v.isClosePausedRef.current && U(M);
    }, [a, M, v.isClosePausedRef, U]), _.useEffect(() => (B(), () => R()), [B, R]);
    const W = _.useMemo(() => S ? Q2(S) : null, [S]);
    return v.viewport ? /* @__PURE__ */ x.jsxs(x.Fragment, { children: [
      W && /* @__PURE__ */ x.jsx(
        eX,
        {
          __scopeToast: n,
          role: "status",
          "aria-live": r === "foreground" ? "assertive" : "polite",
          "aria-atomic": !0,
          children: W
        }
      ),
      /* @__PURE__ */ x.jsx(ZW, { scope: n, onClose: F, children: Dl.createPortal(
        /* @__PURE__ */ x.jsx(dx.ItemSlot, { scope: n, children: /* @__PURE__ */ x.jsx(
          E8,
          {
            asChild: !0,
            onEscapeKeyDown: xe(u, () => {
              v.isFocusedToastEscapeKeyDownRef.current || F(), v.isFocusedToastEscapeKeyDownRef.current = !1;
            }),
            children: /* @__PURE__ */ x.jsx(
              qe.li,
              {
                role: "status",
                "aria-live": "off",
                "aria-atomic": !0,
                tabIndex: 0,
                "data-state": a ? "open" : "closed",
                "data-swipe-direction": v.swipeDirection,
                ...w,
                ref: T,
                style: { userSelect: "none", touchAction: "none", ...e.style },
                onKeyDown: xe(e.onKeyDown, (j) => {
                  j.key === "Escape" && (u?.(j.nativeEvent), j.nativeEvent.defaultPrevented || (v.isFocusedToastEscapeKeyDownRef.current = !0, F()));
                }),
                onPointerDown: xe(e.onPointerDown, (j) => {
                  j.button === 0 && (k.current = { x: j.clientX, y: j.clientY });
                }),
                onPointerMove: xe(e.onPointerMove, (j) => {
                  if (!k.current) return;
                  const V = j.clientX - k.current.x, I = j.clientY - k.current.y, H = !!A.current, q = ["left", "right"].includes(v.swipeDirection), G = ["left", "up"].includes(v.swipeDirection) ? Math.min : Math.max, O = q ? G(0, V) : 0, Y = q ? 0 : G(0, I), Z = j.pointerType === "touch" ? 10 : 2, L = { x: O, y: Y }, te = { originalEvent: j, delta: L };
                  H ? (A.current = L, fh(WW, p, te, {
                    discrete: !1
                  })) : MT(L, v.swipeDirection, Z) ? (A.current = L, fh(YW, h, te, {
                    discrete: !1
                  }), j.target.setPointerCapture(j.pointerId)) : (Math.abs(V) > Z || Math.abs(I) > Z) && (k.current = null);
                }),
                onPointerUp: xe(e.onPointerUp, (j) => {
                  const V = A.current, I = j.target;
                  if (I.hasPointerCapture(j.pointerId) && I.releasePointerCapture(j.pointerId), A.current = null, k.current = null, V) {
                    const H = j.currentTarget, q = { originalEvent: j, delta: V };
                    MT(V, v.swipeDirection, v.swipeThreshold) ? fh(KW, y, q, {
                      discrete: !0
                    }) : fh(
                      XW,
                      g,
                      q,
                      {
                        discrete: !0
                      }
                    ), H.addEventListener("click", (G) => G.preventDefault(), {
                      once: !0
                    });
                  }
                })
              }
            )
          }
        ) }),
        v.viewport
      ) })
    ] }) : null;
  }
), eX = (e) => {
  const { __scopeToast: t, children: n, ...r } = e, o = wm(cf, t), [a, s] = _.useState(!1), [u, c] = _.useState(!1);
  return rX(() => s(!0)), _.useEffect(() => {
    const f = window.setTimeout(() => c(!0), 1e3);
    return () => window.clearTimeout(f);
  }, []), u ? null : /* @__PURE__ */ x.jsx(om, { asChild: !0, children: /* @__PURE__ */ x.jsx(cx, { ...r, children: a && /* @__PURE__ */ x.jsxs(x.Fragment, { children: [
    o.label,
    " ",
    n
  ] }) }) });
}, tX = "ToastTitle", G2 = _.forwardRef(
  (e, t) => {
    const { __scopeToast: n, ...r } = e;
    return /* @__PURE__ */ x.jsx(qe.div, { ...r, ref: t });
  }
);
G2.displayName = tX;
var nX = "ToastDescription", Y2 = _.forwardRef(
  (e, t) => {
    const { __scopeToast: n, ...r } = e;
    return /* @__PURE__ */ x.jsx(qe.div, { ...r, ref: t });
  }
);
Y2.displayName = nX;
var W2 = "ToastAction", X2 = _.forwardRef(
  (e, t) => {
    const { altText: n, ...r } = e;
    return n.trim() ? /* @__PURE__ */ x.jsx(Z2, { altText: n, asChild: !0, children: /* @__PURE__ */ x.jsx(hx, { ...r, ref: t }) }) : (console.error(
      `Invalid prop \`altText\` supplied to \`${W2}\`. Expected non-empty \`string\`.`
    ), null);
  }
);
X2.displayName = W2;
var K2 = "ToastClose", hx = _.forwardRef(
  (e, t) => {
    const { __scopeToast: n, ...r } = e, o = QW(K2, n);
    return /* @__PURE__ */ x.jsx(Z2, { asChild: !0, children: /* @__PURE__ */ x.jsx(
      qe.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: xe(e.onClick, o.onClose)
      }
    ) });
  }
);
hx.displayName = K2;
var Z2 = _.forwardRef((e, t) => {
  const { __scopeToast: n, altText: r, ...o } = e;
  return /* @__PURE__ */ x.jsx(
    qe.div,
    {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": r || void 0,
      ...o,
      ref: t
    }
  );
});
function Q2(e) {
  const t = [];
  return Array.from(e.childNodes).forEach((r) => {
    if (r.nodeType === r.TEXT_NODE && r.textContent && t.push(r.textContent), oX(r)) {
      const o = r.ariaHidden || r.hidden || r.style.display === "none", a = r.dataset.radixToastAnnounceExclude === "";
      if (!o)
        if (a) {
          const s = r.dataset.radixToastAnnounceAlt;
          s && t.push(s);
        } else
          t.push(...Q2(r));
    }
  }), t;
}
function fh(e, t, n, { discrete: r }) {
  const o = n.originalEvent.currentTarget, a = new CustomEvent(e, { bubbles: !0, cancelable: !0, detail: n });
  t && o.addEventListener(e, t, { once: !0 }), r ? T1(o, a) : o.dispatchEvent(a);
}
var MT = (e, t, n = 0) => {
  const r = Math.abs(e.x), o = Math.abs(e.y), a = r > o;
  return t === "left" || t === "right" ? a && r > n : !a && o > n;
};
function rX(e = () => {
}) {
  const t = Hn(e);
  ni(() => {
    let n = 0, r = 0;
    return n = window.requestAnimationFrame(() => r = window.requestAnimationFrame(t)), () => {
      window.cancelAnimationFrame(n), window.cancelAnimationFrame(r);
    };
  }, [t]);
}
function oX(e) {
  return e.nodeType === e.ELEMENT_NODE;
}
function iX(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const o = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function ev(e) {
  const t = document.activeElement;
  return e.some((n) => n === t ? !0 : (n.focus(), document.activeElement !== t));
}
var aX = B2, sX = V2, lX = q2, uX = G2, cX = Y2, fX = X2, dX = hx;
const ln = [];
for (let e = 0; e < 256; ++e)
  ln.push((e + 256).toString(16).slice(1));
function hX(e, t = 0) {
  return (ln[e[t + 0]] + ln[e[t + 1]] + ln[e[t + 2]] + ln[e[t + 3]] + "-" + ln[e[t + 4]] + ln[e[t + 5]] + "-" + ln[e[t + 6]] + ln[e[t + 7]] + "-" + ln[e[t + 8]] + ln[e[t + 9]] + "-" + ln[e[t + 10]] + ln[e[t + 11]] + ln[e[t + 12]] + ln[e[t + 13]] + ln[e[t + 14]] + ln[e[t + 15]]).toLowerCase();
}
let tv;
const pX = new Uint8Array(16);
function mX() {
  if (!tv) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    tv = crypto.getRandomValues.bind(crypto);
  }
  return tv(pX);
}
const gX = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), OT = { randomUUID: gX };
function px(e, t, n) {
  if (OT.randomUUID && !e)
    return OT.randomUUID();
  e = e || {};
  const r = e.random ?? e.rng?.() ?? mX();
  if (r.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, hX(r);
}
const J2 = _.createContext(
  void 0
), e3 = _.createContext(
  void 0
), yX = 350, vX = ({ children: e, fixedHeight: t, duration: n = 5e3, maxVisible: r = 3, ...o }) => {
  const [a, s] = _.useState(/* @__PURE__ */ new Map()), u = _.useRef(/* @__PURE__ */ new Map()), c = _.useRef(null), f = _.useRef(!0), h = _.useCallback(() => {
    const E = Array.from(u.current).reverse();
    if (t) {
      const T = t;
      E.forEach(([, k], A) => {
        if (!k) return;
        k.setAttribute("data-front", String(A === 0)), k.setAttribute("data-hidden", String(A >= r)), k.style.setProperty("--index", String(A)), k.style.setProperty("--height", `${t}px`), k.style.setProperty("--front-height", `${T}px`);
        const M = t * A;
        k.style.setProperty("--hover-offset-y", `-${M}px`);
      });
    } else {
      const T = E.map(([, A]) => {
        if (!A) return 0;
        const M = A.querySelector(
          ".ToastInner"
        );
        if (!M) return A.clientHeight;
        const N = M.style.height;
        M.style.height = "auto";
        const P = A.clientHeight;
        return M.style.height = N, P;
      }), k = T[0] || 0;
      E.forEach(([, A], M) => {
        if (!A) return;
        const N = T[M];
        A.setAttribute("data-front", String(M === 0)), A.setAttribute("data-hidden", String(M >= r)), A.style.setProperty("--index", String(M)), A.style.setProperty("--height", `${N}px`), A.style.setProperty("--front-height", `${k}px`);
        const P = T.slice(0, M).reduce((z, B) => z + B, 0);
        A.style.setProperty("--hover-offset-y", `-${P}px`);
      });
    }
  }, [t, r]), p = _.useCallback(
    (E) => {
      s((T) => {
        const k = new Map(T);
        return k.set(px(), {
          ...E,
          duration: E.duration || n,
          open: !0
        }), k;
      });
    },
    [n]
  ), g = _.useCallback((E) => {
    f.current && s((T) => {
      const k = new Map(T);
      return k.delete(E), k;
    });
  }, []), y = _.useCallback(
    (E) => p({ ...E, status: E.status || "default" }),
    [p]
  ), w = _.useCallback(
    (E) => p({ ...E, status: "success" }),
    [p]
  ), v = _.useCallback(
    (E) => p({ ...E, status: "error" }),
    [p]
  );
  _.useEffect(() => (f.current = !0, () => {
    f.current = !1;
  }), []), _.useEffect(() => {
    const E = c.current;
    if (E) {
      const T = () => {
        u.current.forEach((M) => {
          M.setAttribute("data-hovering", "true");
        });
      }, k = (M) => {
        (!E.contains(M.target) || E === M.target) && u.current.forEach((N) => {
          N.setAttribute("data-hovering", "false");
        });
      }, A = () => {
        u.current.forEach((M) => {
          M.setAttribute("data-hovering", "false");
        });
      };
      return E.addEventListener("pointermove", T), E.addEventListener("pointerleave", A), E.addEventListener("focusin", T), E.addEventListener("focusout", k), () => {
        E.removeEventListener("pointermove", T), E.removeEventListener("pointerleave", A), E.removeEventListener("focusin", T), E.removeEventListener("focusout", k);
      };
    }
  }, []);
  const S = _.useMemo(
    () => Object.assign(y, {
      success: w,
      error: v
    }),
    [y, w, v]
  );
  return /* @__PURE__ */ x.jsx(J2.Provider, { value: S, children: /* @__PURE__ */ x.jsx(
    e3.Provider,
    {
      value: _.useMemo(
        () => ({
          toastElementsMapRef: u,
          sortToasts: h
        }),
        [h]
      ),
      children: /* @__PURE__ */ x.jsxs(aX, { ...o, children: [
        e,
        Array.from(a).map(([E, T]) => /* @__PURE__ */ x.jsx(
          wX,
          {
            id: E,
            toast: T,
            onOpenChange: (k) => {
              k || (u.current.delete(E), h(), s((A) => {
                const M = new Map(A), N = M.get(E);
                return N && M.set(E, { ...N, open: !1 }), M;
              }), setTimeout(() => {
                g(E);
              }, yX));
            }
          },
          E
        )),
        /* @__PURE__ */ x.jsx(
          sX,
          {
            ref: c,
            className: "ToastViewport",
            style: t ? {
              "--fixed-toast-height": `${t}px`
            } : void 0
          }
        )
      ] })
    }
  ) });
}, bX = () => {
  const e = _.useContext(J2);
  if (e) return e;
  throw new Error("useToast must be used within Toasts");
}, xX = () => {
  const e = _.useContext(e3);
  if (e) return e;
  throw new Error("useToastContext must be used within Toasts");
}, wX = ({
  onOpenChange: e,
  toast: t,
  id: n,
  ...r
}) => {
  const o = _.useRef(null), a = xX(), { sortToasts: s, toastElementsMapRef: u } = a, c = u.current;
  return _.useLayoutEffect(() => (o.current && (c.set(n, o.current), s()), () => {
    c.delete(n), s();
  }), [n, s, c]), /* @__PURE__ */ x.jsx(
    lX,
    {
      ...r,
      ref: o,
      type: t.type,
      duration: t.duration,
      className: "ToastRoot",
      onOpenChange: e,
      open: t.open,
      children: /* @__PURE__ */ x.jsxs("div", { className: "ToastInner", "data-status": t.status, children: [
        /* @__PURE__ */ x.jsx(_X, { status: t.status }),
        t.title && /* @__PURE__ */ x.jsx(uX, { className: "ToastTitle", children: t.title }),
        /* @__PURE__ */ x.jsx(cX, { className: "ToastDescription", children: t.description }),
        t.action && /* @__PURE__ */ x.jsx(
          fX,
          {
            className: "ToastAction Button small green",
            altText: t.action.altText,
            onClick: t.action.onClick,
            asChild: !0,
            children: /* @__PURE__ */ x.jsx("button", { children: t.action.label })
          }
        ),
        /* @__PURE__ */ x.jsx(dX, { "aria-label": "Close", className: "ToastClose", children: /* @__PURE__ */ x.jsx(hm, { style: { fontSize: "12px" } }) })
      ] })
    }
  );
}, _X = ({ status: e }) => e !== "default" && e ? /* @__PURE__ */ x.jsxs("div", { style: { gridArea: "icon", alignSelf: "start" }, children: [
  e === "success" && /* @__PURE__ */ x.jsx(zV, { style: { color: "#61d345", fontSize: "20px" } }),
  e === "error" && /* @__PURE__ */ x.jsx(LV, { style: { color: "#ff4b4b", fontSize: "20px" } })
] }) : null, SX = {}, NT = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), r = (h, p) => {
    const g = typeof h == "function" ? h(t) : h;
    if (!Object.is(g, t)) {
      const y = t;
      t = p ?? (typeof g != "object" || g === null) ? g : Object.assign({}, t, g), n.forEach((w) => w(t, y));
    }
  }, o = () => t, c = { setState: r, getState: o, getInitialState: () => f, subscribe: (h) => (n.add(h), () => n.delete(h)), destroy: () => {
    (SX ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), n.clear();
  } }, f = t = e(r, o, c);
  return c;
}, t3 = (e) => e ? NT(e) : NT;
var nv = { exports: {} }, rv = {}, ov = { exports: {} }, iv = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var DT;
function EX() {
  if (DT) return iv;
  DT = 1;
  var e = Qc();
  function t(p, g) {
    return p === g && (p !== 0 || 1 / p === 1 / g) || p !== p && g !== g;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, o = e.useEffect, a = e.useLayoutEffect, s = e.useDebugValue;
  function u(p, g) {
    var y = g(), w = r({ inst: { value: y, getSnapshot: g } }), v = w[0].inst, S = w[1];
    return a(
      function() {
        v.value = y, v.getSnapshot = g, c(v) && S({ inst: v });
      },
      [p, y, g]
    ), o(
      function() {
        return c(v) && S({ inst: v }), p(function() {
          c(v) && S({ inst: v });
        });
      },
      [p]
    ), s(y), y;
  }
  function c(p) {
    var g = p.getSnapshot;
    p = p.value;
    try {
      var y = g();
      return !n(p, y);
    } catch {
      return !0;
    }
  }
  function f(p, g) {
    return g();
  }
  var h = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? f : u;
  return iv.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : h, iv;
}
var PT;
function CX() {
  return PT || (PT = 1, ov.exports = EX()), ov.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var jT;
function kX() {
  if (jT) return rv;
  jT = 1;
  var e = Qc(), t = CX();
  function n(f, h) {
    return f === h && (f !== 0 || 1 / f === 1 / h) || f !== f && h !== h;
  }
  var r = typeof Object.is == "function" ? Object.is : n, o = t.useSyncExternalStore, a = e.useRef, s = e.useEffect, u = e.useMemo, c = e.useDebugValue;
  return rv.useSyncExternalStoreWithSelector = function(f, h, p, g, y) {
    var w = a(null);
    if (w.current === null) {
      var v = { hasValue: !1, value: null };
      w.current = v;
    } else v = w.current;
    w = u(
      function() {
        function E(N) {
          if (!T) {
            if (T = !0, k = N, N = g(N), y !== void 0 && v.hasValue) {
              var P = v.value;
              if (y(P, N))
                return A = P;
            }
            return A = N;
          }
          if (P = A, r(k, N)) return P;
          var z = g(N);
          return y !== void 0 && y(P, z) ? (k = N, P) : (k = N, A = z);
        }
        var T = !1, k, A, M = p === void 0 ? null : p;
        return [
          function() {
            return E(h());
          },
          M === null ? void 0 : function() {
            return E(M());
          }
        ];
      },
      [h, p, g, y]
    );
    var S = o(f, w[0], w[1]);
    return s(
      function() {
        v.hasValue = !0, v.value = S;
      },
      [S]
    ), c(S), S;
  }, rv;
}
var IT;
function TX() {
  return IT || (IT = 1, nv.exports = kX()), nv.exports;
}
var AX = TX();
const n3 = /* @__PURE__ */ Nl(AX), r3 = {}, { useDebugValue: RX } = nn, { useSyncExternalStoreWithSelector: MX } = n3;
let zT = !1;
const OX = (e) => e;
function NX(e, t = OX, n) {
  (r3 ? "production" : void 0) !== "production" && n && !zT && (console.warn(
    "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
  ), zT = !0);
  const r = MX(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return RX(r), r;
}
const LT = (e) => {
  (r3 ? "production" : void 0) !== "production" && typeof e != "function" && console.warn(
    "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
  );
  const t = typeof e == "function" ? t3(e) : e, n = (r, o) => NX(t, r, o);
  return Object.assign(n, t), n;
}, Er = (e) => e ? LT(e) : LT;
class di {
  constructor(t) {
    this.context = t;
  }
  get communicationManager() {
    return this.context.worker.getCommunicationManager();
  }
  get eventManager() {
    return this.context.worker.getEventManager();
  }
  get hookManager() {
    return this.context.worker.getHookManager();
  }
  get nodeManager() {
    return this.context.worker.getNodeManager();
  }
  get syncManager() {
    return this.context.worker.getSyncManager();
  }
  get connectionHealthManager() {
    return this.context.worker.getConnectionHealthManager();
  }
  get edgeManager() {
    return this.context.worker.getEdgeManager();
  }
  get groupManager() {
    return this.context.worker.getGroupManager();
  }
  get libraryManager() {
    return this.context.worker.getLibraryManager();
  }
}
const dh = 2e3;
class DX extends di {
  constructor(t) {
    super(t), this._responsive = !1, this._last_pong = 0, this._last_pong = Date.now() - dh * 100;
  }
  start() {
    this.stop(), this.pingInterval = setInterval(() => {
      this.context.worker.is_open && this.context.worker.send({ type: "ping" });
    }, dh), this.responsivenessCheckInterval = setInterval(() => {
      this._responsive = Date.now() - this._last_pong <= dh * 3;
    }, dh * 2);
  }
  stop() {
    this.pingInterval && clearInterval(this.pingInterval), this.responsivenessCheckInterval && clearInterval(this.responsivenessCheckInterval);
  }
  receivePong() {
    this._last_pong = Date.now(), this._responsive = !0;
  }
  isResponsive() {
    return this._responsive;
  }
}
const FT = (e, t) => {
  e.properties = e.properties || {}, t.pos && (e.properties["frontend:pos"] = t.pos), t.size && (e.properties["frontend:size"] = t.size), t.collapsed !== void 0 && (e.properties["frontend:collapsed"] = !!t.collapsed);
}, $T = 2e3, BT = 2e3;
class PX extends di {
  constructor(t) {
    super(t), this._local_nodeupdates = /* @__PURE__ */ new Map(), this._local_groupupdates = /* @__PURE__ */ new Map(), this.on_sync_complete = t.on_sync_complete || (async () => {
    });
  }
  start() {
    this._nodeupdatetimer = setTimeout(() => {
      this.sync_local_node_updates();
    }, $T), this._groupupdatetimer = setTimeout(() => {
      this.sync_local_group_updates();
    }, BT);
  }
  stop() {
    this._nodeupdatetimer && clearTimeout(this._nodeupdatetimer), this._groupupdatetimer && clearTimeout(this._groupupdatetimer);
  }
  async stepwise_fullsync() {
    this.context.worker._zustand && this.context.worker.is_open && (await this.sync_lib(), await this.sync_external_worker(), await this.sync_funcnodes_plugins(), await this.sync_nodespace(), await this.sync_view_state(), await this.on_sync_complete(this.context.worker));
  }
  async sync_lib() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    const t = await this.communicationManager._send_cmd({
      cmd: "get_library",
      wait_for_response: !0,
      retries: 2,
      unique: !0
    });
    this.context.worker._zustand.lib.libstate.getState().set({
      lib: t
    });
  }
  async sync_external_worker() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    const t = await this.communicationManager._send_cmd({
      cmd: "get_worker_dependencies",
      wait_for_response: !0,
      unique: !0
    });
    this.context.worker._zustand.lib.libstate.getState().set({
      external_worker: t
    });
  }
  async sync_funcnodes_plugins() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    const t = await this.context.worker.getCommunicationManager()._send_cmd({
      cmd: "get_plugin_keys",
      wait_for_response: !0,
      unique: !0,
      kwargs: { type: "react" }
    });
    for (const n of t) {
      const r = await this.context.worker.getCommunicationManager()._send_cmd({
        cmd: "get_plugin",
        wait_for_response: !0,
        kwargs: { key: n, type: "react" },
        unique: !0
      });
      this.context.worker._zustand.add_packed_plugin(n, r);
    }
  }
  async sync_view_state() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    const t = await this.context.worker.getCommunicationManager()._send_cmd({
      cmd: "view_state",
      wait_for_response: !0,
      unique: !0
    });
    t.renderoptions && this.context.worker._zustand.update_render_options(t.renderoptions);
    const n = t.nodes;
    if (n)
      for (const r in n) {
        const o = {};
        FT(o, n[r]), this.context.worker._zustand.on_node_action({
          type: "update",
          node: o,
          id: r,
          from_remote: !0
        });
      }
  }
  async sync_nodespace() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    const t = await this.context.worker.getCommunicationManager()._send_cmd({
      cmd: "get_nodes",
      kwargs: { with_frontend: !0 },
      wait_for_response: !0,
      unique: !0
    });
    for (const o of t)
      this.eventManager._receive_node_added(o);
    const n = await this.context.worker.getCommunicationManager()._send_cmd({
      cmd: "get_edges",
      wait_for_response: !0,
      unique: !0
    });
    for (const o of n)
      this.eventManager._receive_edge_added(...o);
    const r = await this.context.worker.getCommunicationManager()._send_cmd({
      cmd: "get_groups",
      kwargs: {},
      wait_for_response: !0,
      unique: !0
    });
    this.eventManager._receive_groups(r);
  }
  async fullsync() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    let t;
    for (; ; )
      try {
        t = await this.communicationManager._send_cmd({
          cmd: "full_state",
          unique: !0
        });
        break;
      } catch (o) {
        o instanceof Error ? this.context.worker._zustand.logger.error("Error in fullsync", o) : this.context.worker._zustand.logger.error(
          "Error in fullsync",
          new Error(JSON.stringify(o))
        );
      }
    this.context.worker._zustand.logger.debug("Full state", t), this.context.worker._zustand.lib.libstate.getState().set({
      lib: t.backend.lib,
      external_worker: t.worker_dependencies
    }), t.view.renderoptions && this.context.worker._zustand.update_render_options(
      t.view.renderoptions
    );
    const n = t.view.nodes;
    for (const o of t.backend.nodes) {
      const a = n[o.id];
      a !== void 0 && FT(o, a), this.eventManager._receive_node_added(o);
    }
    for (const o of t.backend.edges)
      this.eventManager._receive_edge_added(...o);
    const r = t.backend.groups;
    r && this.eventManager._receive_groups(r);
  }
  sync_local_node_updates() {
    clearTimeout(this._nodeupdatetimer), this._local_nodeupdates.forEach(async (t, n) => {
      const r = await this.context.worker.getCommunicationManager()._send_cmd({
        cmd: "update_node",
        kwargs: { nid: n, data: t },
        wait_for_response: !0
      });
      this.context.worker._zustand && Object.keys(r).length > 0 && this.context.worker._zustand.on_node_action({
        type: "update",
        node: r,
        id: n,
        from_remote: !0
      });
    }), this._local_nodeupdates.clear(), this._nodeupdatetimer = setTimeout(() => {
      this.sync_local_node_updates();
    }, $T);
  }
  sync_local_group_updates() {
    clearTimeout(this._groupupdatetimer), this._local_groupupdates.forEach(async (t, n) => {
      const r = await this.communicationManager._send_cmd({
        cmd: "update_group",
        kwargs: { gid: n, data: t },
        wait_for_response: !0
      });
      this.context.worker._zustand && this.context.worker._zustand.on_group_action({
        type: "update",
        group: r,
        id: n,
        from_remote: !0
      });
    }), this._local_groupupdates.clear(), this._groupupdatetimer = setTimeout(() => {
      this.sync_local_group_updates();
    }, BT);
  }
  locally_update_node(t) {
    const n = this._local_nodeupdates.get(t.id);
    if (n) {
      const { new_obj: r, change: o } = Ha(n, t.node);
      o && this._local_nodeupdates.set(t.id, r);
    } else
      this._local_nodeupdates.set(t.id, t.node);
    t.immediate && this.sync_local_node_updates();
  }
  locally_update_group(t) {
    const n = this._local_groupupdates.get(t.id);
    if (n) {
      const { new_obj: r, change: o } = Ha(n, t.group);
      o && this._local_groupupdates.set(t.id, r);
    } else
      this._local_groupupdates.set(t.id, t.group);
    t.immediate && this.sync_local_group_updates();
  }
}
class co {
  /**
   * Creates a new DataStructure instance.
   *
   * @param props - Configuration object containing data and MIME type
   */
  constructor({ data: t, mime: n }) {
    this._data = t, this._mime = n;
  }
  /**
   * Gets the raw wrapped data.
   *
   * @returns The original data in its native type
   */
  get data() {
    return this._data;
  }
  /**
   * Gets the data cast to the expected return type.
   * This is a type assertion and should be overridden in subclasses for proper type conversion.
   *
   * @returns The data cast to type R
   */
  get value() {
    return this._data;
  }
  /**
   * Gets the MIME type of the wrapped data.
   *
   * @returns The MIME type string
   */
  get mime() {
    return this._mime;
  }
  /**
   * Returns a string representation of the DataStructure.
   * The format varies based on the data type:
   * - ArrayBuffer: shows byte length
   * - Blob: shows size
   * - String/Array: shows length
   * - Object: shows number of keys
   * - Other types: shows only MIME type
   *
   * @returns String representation in format "DataStructure(size,mime)" or "DataStructure(mime)"
   */
  toString() {
    return this._data instanceof ArrayBuffer ? `DataStructure(${this._data.byteLength},${this._mime})` : this._data instanceof Blob ? `DataStructure(${this._data.size},${this._mime})` : this._data instanceof String ? `DataStructure(${this._data.length},${this._mime})` : this._data instanceof Array ? `DataStructure(${this._data.length},${this._mime})` : this._data instanceof Object ? `DataStructure(${Object.keys(this._data).length},${this._mime})` : `DataStructure(${this._mime})`;
  }
  /**
   * Returns the JSON representation of this DataStructure.
   * Currently delegates to toString() method.
   *
   * @returns JSON string representation
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Cleans up resources associated with this DataStructure.
   * Base implementation does nothing, but subclasses may override to release resources.
   */
  dispose() {
  }
}
class o3 extends co {
  get objectUrl() {
    if (this._objectUrl)
      return this._objectUrl;
    const t = this.data instanceof Blob ? this.data : new Blob([this.data], { type: this.mime });
    return this._objectUrl = URL.createObjectURL(t), this._objectUrl;
  }
  dispose() {
    this._objectUrl && URL.revokeObjectURL(this._objectUrl), super.dispose();
  }
  get value() {
    return this.objectUrl;
  }
}
const qt = (e) => e.buffer ? e.buffer : e, jX = {
  x: (e, t) => null,
  //  pad byte 	no value 	(7 )
  c: (e, t) => new DataView(qt(e)).getInt8(0),
  //  char 	bytes of length 1 	1 	b 	signed char 	integer 	1 	(1 ), (2 )
  B: (e, t) => new DataView(qt(e)).getUint8(0),
  //  unsigned char 	integer 	1 	(2 )
  "?": (e, t) => new DataView(qt(e)).getInt8(0) === 1,
  //  _Bool 	bool 	1 	(1 )
  h: (e, t) => new DataView(qt(e)).getInt16(0, t),
  //  short 	integer 	2 	(2 )
  H: (e, t) => new DataView(qt(e)).getUint16(0, t),
  //  unsigned short 	integer 	2 	(2 )
  i: (e, t) => new DataView(qt(e)).getInt32(0, t),
  //  int 	integer 	4 	(2 )
  I: (e, t) => new DataView(qt(e)).getUint32(0, t),
  //  unsigned int 	integer 	4 	(2 )
  l: (e, t) => new DataView(qt(e)).getInt32(0, t),
  //  long 	integer 	4 	(2 )
  L: (e, t) => new DataView(qt(e)).getUint32(0, t),
  //  unsigned long 	integer 	4 	(2 )
  q: (e, t) => Number(
    new DataView(qt(e)).getBigInt64(0, t)
  ),
  //  long long 	integer 	8 	(2 )
  Q: (e, t) => Number(
    new DataView(qt(e)).getBigUint64(0, t)
  ),
  //  unsigned long long 	integer 	8 	(2 )
  n: (e, t) => Number(
    new DataView(qt(e)).getBigInt64(0, t)
  ),
  //  ssize_t 	integer 	(3 )
  N: (e, t) => Number(
    new DataView(qt(e)).getBigUint64(0, t)
  ),
  //  size_t 	integer 	(3 )
  // "e":(data:ArrayBufferLike)=>{return new DataView(to_arraybuffer(data)).getFloat16(0)}, //  (6 ) float 	2 	(4 )
  f: (e, t) => new DataView(qt(e)).getFloat32(0, t),
  //  float 	float 	4 	(4 )
  d: (e, t) => new DataView(qt(e)).getFloat64(0, t),
  //  double 	float 	8 	(4 )
  s: (e, t) => new TextDecoder().decode(qt(e)),
  //  char[] 	bytes 	(9 )
  p: (e, t) => new TextDecoder().decode(qt(e)),
  //  char[] 	bytes 	(8 )
  P: (e, t) => Number(
    new DataView(qt(e)).getBigUint64(0, t)
  )
  //  void* 	int
};
class i3 extends co {
  constructor({ data: t, mime: n }) {
    super({ data: t, mime: n }), this._cType = n.split("application/fn.struct.")[1], this._value = null, this.parse_value();
  }
  parse_value() {
    let t = !0, n = this._cType;
    return n.startsWith("<") && (t = !0, n = n.slice(1)), n.startsWith(">") && (t = !1, n = n.slice(1)), n.startsWith("!") && (t = !1, n = n.slice(1)), n.startsWith("@") && (t = !1, n = n.slice(1)), n.startsWith("=") && (t = !1, n = n.slice(1)), this._value = jX[n](this.data, t), this._value;
  }
  get value() {
    return this._value;
  }
  toString() {
    return this._value === null ? "null" : this._value.toString();
  }
}
class Qi extends co {
  constructor({ data: t, mime: n }) {
    super({ data: t, mime: n }), t.length === 0 ? this._json = void 0 : (this._json = JSON.parse(new TextDecoder().decode(qt(t))), this._json === "<NoValue>" && (this._json = void 0));
  }
  get value() {
    return this._json;
  }
  static fromObject(t) {
    const n = t === "<NoValue>" ? new Uint8Array(0) : new TextEncoder().encode(JSON.stringify(t));
    return new Qi({ data: n, mime: "application/json" });
  }
  toString() {
    return typeof this._json == "string" ? this._json : JSON.stringify(this._json);
  }
}
class a3 extends co {
  constructor({ data: t, mime: n }) {
    super({ data: t, mime: n }), this._value = new TextDecoder().decode(qt(t));
  }
  get value() {
    return this._value;
  }
  toString() {
    return this._value;
  }
}
const s3 = ({
  data: e,
  mime: t
}) => e instanceof ArrayBuffer || e instanceof Uint8Array ? t.startsWith("application/fn.struct.") ? new i3({ data: e, mime: t }) : t.startsWith("application/json") ? new Qi({ data: e, mime: t }) : t === "text" || t.startsWith("text/") ? new a3({ data: e, mime: t }) : new o3({ data: e, mime: t }) : new co({ data: e, mime: t });
class IX extends di {
  constructor(t) {
    super(t), this.CHUNK_TIMEOUT = 1e4, this._unique_cmd_outs = {}, this.blobChunks = {}, this.cleanupChunks = () => {
      const n = Date.now();
      for (const r in this.blobChunks)
        n - this.blobChunks[r].timestamp > this.CHUNK_TIMEOUT && delete this.blobChunks[r];
    }, this.messagePromises = /* @__PURE__ */ new Map();
  }
  start() {
    this._chunk_cleanup_timer = setInterval(
      this.cleanupChunks.bind(this),
      this.CHUNK_TIMEOUT / 2
    );
  }
  stop() {
    this._chunk_cleanup_timer && clearInterval(this._chunk_cleanup_timer);
  }
  send(t) {
    this.context.worker.send(t);
  }
  async _send_cmd({
    cmd: t,
    kwargs: n,
    as_bytes: r = !1,
    wait_for_response: o = !0,
    response_timeout: a = 5e3,
    retries: s = 2,
    unique: u = !1
  }) {
    const c = {
      type: "cmd",
      as_bytes: r,
      cmd: t,
      kwargs: n || {}
    };
    if (await new Promise(async (f) => {
      if (this.context.worker.is_responsive) return f();
      const h = setInterval(() => {
        this.context.worker.is_responsive && (clearInterval(h), f());
      }, 100);
    }), o) {
      if (u && this._unique_cmd_outs[c.cmd] !== void 0)
        return this._unique_cmd_outs[c.cmd];
      s < 0 && (s = 0);
      const h = (async () => {
        let p;
        for (; s >= 0; ) {
          const g = c.id || px();
          c.id = g;
          const y = new Promise((w, v) => {
            const S = setTimeout(() => {
              v("Timeout@wait_for_response for " + t);
            }, a);
            this.messagePromises.set(g, {
              resolve: (E) => {
                clearTimeout(S), w(E), this.messagePromises.delete(g);
              },
              reject: (E) => {
                clearTimeout(S), v(E), this.messagePromises.delete(g);
              }
            });
          });
          await this.send(c);
          try {
            p = await y;
            break;
          } catch (w) {
            if (s === 0)
              throw delete this._unique_cmd_outs[c.cmd], w;
            s -= 1;
            continue;
          }
        }
        return delete this._unique_cmd_outs[c.cmd], p;
      })();
      return u && (this._unique_cmd_outs[c.cmd] = h), h;
    }
    return this.send(c);
  }
  async receive(t) {
    let n;
    switch (this.connectionHealthManager.receivePong(), t.type) {
      case "pong":
        return this.connectionHealthManager.receivePong();
      case "nsevent":
        return await this.context.worker.getEventManager().receive_nodespace_event(t);
      case "result":
        if (n = t.id && this.messagePromises.get(t.id), n)
          return n.resolve(t.result);
        break;
      case "error":
        if (this.context.worker.on_error(t.tb + `
` + t.error), n = t.id && this.messagePromises.get(t.id), n)
          return n.reject(t.error);
        break;
      case "progress":
        if (!this.context.worker._zustand) return;
        this.context.worker._zustand.set_progress(t);
        break;
      case "workerevent":
        return await this.context.worker.getEventManager().receive_workerevent(t);
      case "large_message":
        return await this.context.worker.handle_large_message_hint(t);
      default:
        console.warn("Unhandled message", t);
        break;
    }
  }
  async recieve_bytes(t, n) {
    const { type: r } = t;
    if (r === "io_value") {
      if (!this.context.worker._zustand) return;
      const { node: o, io: a, preview: s, mime: u } = t, c = s ? "value" : "fullvalue";
      (!o || !a) && console.error("Invalid io_value message", t);
      const f = s3({
        data: n,
        mime: u || "application/octet-stream"
      });
      this.context.worker._zustand.on_node_action({
        type: "update",
        node: {
          id: o,
          io: {
            [a]: {
              [c]: f
            }
          }
        },
        id: o,
        from_remote: !0
      });
    } else if (r == "result") {
      const o = t.id && this.messagePromises.get(t.id);
      o && o.resolve({ bytes: n, header: t });
    } else
      console.warn("Unhandled bytes message", t);
  }
  async onbytes(t) {
    try {
      const n = new TextDecoder("utf-8").decode(t), r = n.indexOf(`\r
\r
`);
      if (r === -1) {
        console.error(`Header terminator not found for:
`, n);
        return;
      }
      const o = n.substring(0, r + 4), a = t.slice(r + 4), s = o.split(";"), u = {};
      if (s.forEach((p) => {
        const [g, y] = p.split("=");
        u[g.trim()] = y.trim();
      }), !u.chunk || !u.msgid) {
        console.error(
          "Header missing required fields chunk or msgid",
          u
        );
        return;
      }
      const [c, f] = u.chunk.split("/"), h = u.msgid;
      if (c === "1" && f === "1")
        return this.recieve_bytes(u, a);
      if (this.blobChunks[h] || (this.blobChunks[h] = {
        chunks: Array.from({ length: parseInt(f) }, () => null),
        timestamp: Date.now()
      }), this.blobChunks[h].chunks.length !== parseInt(f)) {
        console.error("Total chunks mismatch");
        return;
      }
      if (this.blobChunks[h].chunks[parseInt(c) - 1] = t, this.blobChunks[h].chunks.every((p) => p !== null)) {
        const p = new Uint8Array(
          this.blobChunks[h].chunks.reduce((g, y) => g.concat(Array.from(y)), [])
        );
        this.recieve_bytes(u, p), delete this.blobChunks[h];
      }
    } catch (n) {
      console.error("Websocketworker: onbytes error", n, t);
      return;
    }
  }
}
class zX extends di {
  constructor() {
    super(...arguments), this._ns_event_intercepts = /* @__PURE__ */ new Map();
  }
  start() {
  }
  stop() {
  }
  async _receive_edge_added(t, n, r, o) {
    this.context.worker._zustand && this.context.worker._zustand.on_edge_action({
      type: "add",
      from_remote: !0,
      src_nid: t,
      src_ioid: n,
      trg_nid: r,
      trg_ioid: o
    });
  }
  async _receive_groups(t) {
    this.context.worker._zustand && this.context.worker._zustand.on_group_action({
      type: "set",
      groups: t
    });
  }
  async _receive_node_added(t) {
    if (this.context.worker._zustand)
      return this.context.worker._zustand.on_node_action({
        type: "add",
        node: t,
        id: t.id,
        from_remote: !0
      });
  }
  async receive_workerevent({ event: t, data: n }) {
    switch (t) {
      case "worker_error":
        return this.context.worker._zustand ? this.context.worker._zustand.logger.error(n.error) : void 0;
      case "update_worker_dependencies":
        return this.context.worker._zustand ? this.context.worker._zustand.lib.libstate.getState().set({
          external_worker: n.worker_dependencies
        }) : void 0;
      case "lib_update":
        await this.context.worker.getSyncManager().sync_lib();
        return;
      case "fullsync":
        await this.context.worker.getSyncManager().stepwise_fullsync();
        return;
      case "external_worker_update":
        await this.context.worker.getSyncManager().sync_lib(), await this.context.worker.getSyncManager().sync_external_worker();
        return;
      case "starting":
        this.hookManager.call_hooks("starting");
        return;
      case "stopping":
        this.hookManager.call_hooks("stopping");
        return;
      default:
        console.warn("Unhandled worker event", t, n);
        break;
    }
  }
  async intercept_ns_event(t) {
    let n = t;
    for (const r of this._ns_event_intercepts.get(t.event) || [])
      n = await r(n);
    return n;
  }
  async receive_nodespace_event(t) {
    const { event: n, data: r } = await this.intercept_ns_event(t);
    switch (n) {
      case "after_set_value":
        return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            io: {
              [r.io]: {
                value: r.result
              }
            }
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "after_update_value_options":
        return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            io: {
              [r.io]: {
                value_options: r.result
              }
            }
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "triggerstart":
        return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            in_trigger: !0
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "triggerdone":
        return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            in_trigger: !1
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "triggerfast":
        if (!this.context.worker._zustand) return;
        this.context.worker._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            in_trigger: !0
          },
          id: r.node,
          from_remote: !0
        }), setTimeout(() => {
          this.context.worker._zustand && this.context.worker._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              in_trigger: !1
            },
            id: r.node,
            from_remote: !0
          });
        }, 50);
        return;
      case "node_trigger_error":
        return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
          type: "error",
          errortype: "trigger",
          error: r.error,
          id: r.node,
          tb: r.tb,
          from_remote: !0
        }) : void 0;
      case "node_removed":
        if (!this.context.worker._zustand) return;
        this.context.worker._zustand.on_node_action({
          type: "delete",
          id: r.node,
          from_remote: !0
        }), this.hookManager.call_hooks("node_removed", {
          node: r.node
        });
        return;
      case "node_added":
        this._receive_node_added(r.node);
        return;
      case "after_disconnect":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.on_edge_action({
          type: "delete",
          from_remote: !0,
          src_nid: r.result[0],
          src_ioid: r.result[1],
          trg_nid: r.result[2],
          trg_ioid: r.result[3]
        });
      case "after_unforward":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.on_edge_action({
          type: "delete",
          from_remote: !0,
          src_nid: r.result[0],
          src_ioid: r.result[1],
          trg_nid: r.result[2],
          trg_ioid: r.result[3]
        });
      case "after_connect":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 ? void 0 : this._receive_edge_added(
          ...r.result
        );
      case "after_forward":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 ? void 0 : this._receive_edge_added(
          ...r.result
        );
      case "after_add_shelf":
        return !r.result || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.lib.libstate.getState().set({
          lib: r.result
        });
      case "after_remove_shelf":
        return !r.result || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.lib.libstate.getState().set({
          lib: r.result
        });
      case "progress":
        if (!this.context.worker._zustand) return;
        if (r.node)
          return this.context.worker._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              progress: r.info
            },
            id: r.node,
            from_remote: !0
          });
        console.warn("Unhandled nodepsace event", n, r);
        break;
      default:
        if (["after_set_nodespace"].includes(n)) return;
        console.warn("Unhandled nodepsace event", n, r);
        break;
    }
  }
  add_ns_event_intercept(t, n) {
    const r = this._ns_event_intercepts.get(t) || [];
    return r.push(n), this._ns_event_intercepts.set(t, r), () => {
      const a = this._ns_event_intercepts.get(t) || [], s = a.indexOf(n);
      s >= 0 && a.splice(s, 1);
    };
  }
}
class LX extends di {
  constructor() {
    super(...arguments), this._hooks = /* @__PURE__ */ new Map();
  }
  start() {
  }
  stop() {
  }
  add_hook(t, n) {
    const r = this._hooks.get(t) || [];
    return r.push(n), this._hooks.set(t, r), () => {
      const a = this._hooks.get(t) || [], s = a.indexOf(n);
      s >= 0 && a.splice(s, 1);
    };
  }
  async call_hooks(t, n) {
    const r = [];
    for (const o of this._hooks.get(t) || []) {
      const a = o({ worker: this.context.worker, data: n });
      a instanceof Promise && r.push(a);
    }
    await Promise.all(r);
  }
}
class FX extends di {
  start() {
  }
  stop() {
  }
  async trigger_node(t) {
    await this.communicationManager._send_cmd({
      cmd: "trigger_node",
      kwargs: { nid: t },
      wait_for_response: !1
    });
  }
  async add_node(t) {
    const n = await this.communicationManager._send_cmd({
      cmd: "add_node",
      kwargs: { id: t }
    });
    return this.eventManager._receive_node_added(n);
  }
  async remove_node(t) {
    await this.communicationManager._send_cmd({
      cmd: "remove_node",
      kwargs: { id: t }
    });
  }
  locally_update_node(t) {
    this.syncManager.locally_update_node(t);
  }
  set_io_value({
    nid: t,
    ioid: n,
    value: r,
    set_default: o = !1
  }) {
    return this.communicationManager._send_cmd({
      cmd: "set_io_value",
      kwargs: { nid: t, ioid: n, value: r, set_default: o },
      wait_for_response: !0
    });
  }
  set_io_value_options({
    nid: t,
    ioid: n,
    values: r,
    keys: o,
    nullable: a
  }) {
    return this.communicationManager._send_cmd({
      cmd: "update_io_value_options",
      kwargs: {
        nid: t,
        ioid: n,
        options: {
          options: {
            type: "enum",
            values: r,
            keys: o,
            nullable: a
          }
        }
      }
    });
  }
  async get_io_value({ nid: t, ioid: n }) {
    const r = await this.communicationManager._send_cmd({
      cmd: "get_io_value",
      kwargs: { nid: t, ioid: n },
      wait_for_response: !0
    });
    return this.context.worker._zustand && this.context.worker._zustand.on_node_action({
      type: "update",
      node: {
        io: {
          [n]: {
            value: r
          }
        }
      },
      id: t,
      from_remote: !0
    }), r;
  }
  async get_ios_values({ nid: t }) {
    const n = await this.communicationManager._send_cmd({
      cmd: "get_ios_values",
      kwargs: { nid: t },
      wait_for_response: !0
    });
    if (!this.context.worker._zustand) return n;
    const r = {};
    for (const o in n)
      r[o] = { value: n[o] };
    return this.context.worker._zustand.on_node_action({
      type: "update",
      node: {
        io: r
      },
      id: t,
      from_remote: !0
    }), n;
  }
  async get_io_full_value({ nid: t, ioid: n }) {
    const r = await this.communicationManager._send_cmd({
      cmd: "get_io_full_value",
      kwargs: { nid: t, ioid: n },
      wait_for_response: !0,
      as_bytes: !0
    }), { header: o, bytes: a } = r, { mime: s } = o, u = s3({
      data: a,
      mime: s || "application/octet-stream"
    });
    return this.context.worker._zustand?.on_node_action?.({
      type: "update",
      node: {
        id: t,
        io: {
          [n]: {
            fullvalue: u
          }
        }
      },
      id: t,
      from_remote: !0
    }), u;
  }
  async update_io_options({
    nid: t,
    ioid: n,
    options: r
  }) {
    const o = await this.communicationManager._send_cmd({
      cmd: "update_io_options",
      kwargs: { nid: t, ioid: n, ...r },
      wait_for_response: !0
    });
    if (!this.context.worker._zustand) return o;
    this.context.worker._zustand.on_node_action({
      type: "update",
      node: {
        io: {
          [n]: {
            ...r
          }
        }
      },
      id: t,
      from_remote: !0
    });
  }
  async get_node_status(t) {
    return await this.communicationManager._send_cmd({
      cmd: "get_node_state",
      kwargs: { nid: t },
      wait_for_response: !0
    });
  }
  async get_remote_node_state(t) {
    const n = await this.communicationManager._send_cmd({
      cmd: "get_node_state",
      kwargs: { nid: t },
      wait_for_response: !0
    });
    this.context.worker._zustand && this.context.worker._zustand.on_node_action({
      type: "update",
      node: n,
      id: n.id,
      from_remote: !0
    });
  }
}
class $X extends di {
  start() {
  }
  stop() {
  }
  add_edge({
    src_nid: t,
    src_ioid: n,
    trg_nid: r,
    trg_ioid: o,
    replace: a = !1
  }) {
    return this.communicationManager._send_cmd({
      cmd: "add_edge",
      kwargs: { src_nid: t, src_ioid: n, trg_nid: r, trg_ioid: o, replace: a }
    });
  }
  remove_edge({
    src_nid: t,
    src_ioid: n,
    trg_nid: r,
    trg_ioid: o
  }) {
    return this.communicationManager._send_cmd({
      cmd: "remove_edge",
      kwargs: { src_nid: t, src_ioid: n, trg_nid: r, trg_ioid: o }
    });
  }
}
class BX extends di {
  start() {
  }
  stop() {
  }
  async group_nodes(t, n) {
    const r = await this.communicationManager._send_cmd({
      cmd: "group_nodes",
      kwargs: { node_ids: t, group_ids: n },
      wait_for_response: !0
    });
    return this.eventManager._receive_groups(r), r;
  }
  async remove_group(t) {
    await this.communicationManager._send_cmd({
      cmd: "remove_group",
      kwargs: { gid: t },
      wait_for_response: !0
    }), await this.syncManager.sync_nodespace();
  }
  locally_update_group(t) {
    this.syncManager.locally_update_group(t);
  }
}
class HX extends di {
  start() {
  }
  stop() {
  }
  async add_external_worker({
    module: t,
    cls_module: n,
    cls_name: r
  }) {
    return await this.communicationManager._send_cmd({
      cmd: "add_external_worker",
      kwargs: { module: t, cls_module: n, cls_name: r }
    });
  }
  async add_lib(t, n) {
    return await this.communicationManager._send_cmd({
      cmd: "add_package_dependency",
      kwargs: { name: t, version: n },
      wait_for_response: !1
    });
  }
  async remove_lib(t) {
    return await this.communicationManager._send_cmd({
      cmd: "remove_package_dependency",
      kwargs: { name: t },
      wait_for_response: !1
    });
  }
  async get_available_modules() {
    return await this.communicationManager._send_cmd({
      cmd: "get_available_modules",
      wait_for_response: !0,
      unique: !0
    });
  }
  async remove_external_worker(t, n) {
    return await this.communicationManager._send_cmd({
      cmd: "remove_external_worker",
      kwargs: { worker_id: t, class_id: n },
      wait_for_response: !0
    });
  }
}
class VX {
  // Public getter for handlers to access eventManager
  getEventManager() {
    return this._eventManager;
  }
  getSyncManager() {
    return this._syncManager;
  }
  getCommunicationManager() {
    return this._communicationManager;
  }
  getConnectionHealthManager() {
    return this._connectionhealthManager;
  }
  getHookManager() {
    return this._hookManager;
  }
  getNodeManager() {
    return this._nodeManager;
  }
  getEdgeManager() {
    return this._edgeManager;
  }
  getGroupManager() {
    return this._groupManager;
  }
  getLibraryManager() {
    return this._libraryManager;
  }
  constructor(t) {
    this.uuid = t.uuid, this.on_error = t.on_error || ((r) => {
      this._zustand?.logger.error(r);
    }), this.state = Er((r, o) => ({
      is_open: !1
    }));
    const n = { worker: this };
    this._connectionhealthManager = new DX(
      n
    ), this._communicationManager = new IX(n), this._eventManager = new zX({
      ...n
    }), this._syncManager = new PX({
      ...n,
      on_sync_complete: t.on_sync_complete
    }), this._hookManager = new LX(n), this._nodeManager = new FX(n), this._edgeManager = new $X(n), this._groupManager = new BX(n), this._libraryManager = new HX(n), this._communicationManager.start(), this._connectionhealthManager.start(), this._syncManager.start(), this._eventManager.start(), this._hookManager.start(), this._nodeManager.start(), this._edgeManager.start(), this._groupManager.start(), this._libraryManager.start(), t.zustand && this.set_zustand(t.zustand), this.api = {
      node: this._nodeManager,
      group: this._groupManager,
      edge: this._edgeManager,
      hooks: this._hookManager,
      lib: this._libraryManager
    };
  }
  set_zustand(t) {
    t !== this._zustand && (this._zustand = t, t.set_worker(this), this._zustand.auto_progress(), this._syncManager.stepwise_fullsync());
  }
  get is_open() {
    return this.state.getState().is_open;
  }
  set is_open(t) {
    this.state.setState({ is_open: t });
  }
  get is_responsive() {
    return this._connectionhealthManager.isResponsive();
  }
  clear() {
    return this._communicationManager._send_cmd({ cmd: "clear", unique: !0 });
  }
  save() {
    return this._communicationManager._send_cmd({
      cmd: "save",
      wait_for_response: !0,
      unique: !0
    });
  }
  load(t) {
    return this._communicationManager._send_cmd({
      cmd: "load_data",
      kwargs: { data: t },
      wait_for_response: !0
    }).then(() => {
      this._syncManager.stepwise_fullsync();
    });
  }
  async get_runstate() {
    return await this._communicationManager._send_cmd({
      cmd: "get_runstate",
      wait_for_response: !0,
      unique: !0
    });
  }
  async send(t) {
    throw new Error("async send(data: any)  not implemented");
  }
  async upload_file(t) {
    throw new Error("upload_file not implemented ");
  }
  async handle_large_message_hint({}) {
    throw new Error(
      "async handle_large_message_hint({}: LargeMessageHint) not implemented "
    );
  }
  disconnect() {
  }
  onclose() {
    this.is_open = !1, this._zustand && this._zustand.auto_progress();
  }
  async reconnect() {
  }
  async stop() {
    await this._communicationManager._send_cmd({
      cmd: "stop_worker",
      wait_for_response: !1
    });
    const t = this.onclose.bind(this);
    this.onclose = () => {
      t(), this._zustand && (this._zustand.worker === this && this._zustand.clear_all(), this.onclose = t);
    };
  }
  async update_external_worker(t, n, r) {
    return await this._communicationManager._send_cmd({
      cmd: "update_external_worker",
      kwargs: { worker_id: t, class_id: n, ...r },
      wait_for_response: !0
    });
  }
  async export({ withFiles: t = !1 }) {
    return await this._communicationManager._send_cmd({
      cmd: "export_worker",
      wait_for_response: !0,
      kwargs: { with_files: t }
    });
  }
  async update_from_export(t) {
    const n = this._hookManager.add_hook("node_added", async ({}) => {
      this._zustand?.center_all();
    });
    try {
      const r = await this._communicationManager._send_cmd({
        cmd: "update_from_export",
        kwargs: { data: t },
        wait_for_response: !0,
        response_timeout: 6e5,
        // 10 minutes
        unique: !0
      });
      return await new Promise((o) => {
        setTimeout(() => {
          o();
        }, 1e3);
      }), await this._syncManager.stepwise_fullsync(), r;
    } finally {
      n();
    }
  }
  /**
   * @deprecated This method is deprecated. Use the API or getCommunicationManager()._send_cmd directly instead.
   */
  _send_cmd(t) {
    return this._communicationManager._send_cmd(t);
  }
  /**
   * @deprecated This method is deprecated. Use the API or getNodeManager().set_io_value directly instead.
   */
  set_io_value(t) {
    return this._nodeManager.set_io_value(t);
  }
  /**
   * @deprecated This method is deprecated. Use the API or getNodeManager().get_io_value directly instead.
   */
  get_io_value(t) {
    return this._nodeManager.get_io_value(t);
  }
}
function l3(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: UX } = Object.prototype, { getPrototypeOf: mx } = Object, { iterator: _m, toStringTag: u3 } = Symbol, Sm = /* @__PURE__ */ ((e) => (t) => {
  const n = UX.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Vr = (e) => (e = e.toLowerCase(), (t) => Sm(t) === e), Em = (e) => (t) => typeof t === e, { isArray: Fl } = Array, zc = Em("undefined");
function ff(e) {
  return e !== null && !zc(e) && e.constructor !== null && !zc(e.constructor) && Fn(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const c3 = Vr("ArrayBuffer");
function qX(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && c3(e.buffer), t;
}
const GX = Em("string"), Fn = Em("function"), f3 = Em("number"), df = (e) => e !== null && typeof e == "object", YX = (e) => e === !0 || e === !1, Fh = (e) => {
  if (Sm(e) !== "object")
    return !1;
  const t = mx(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(u3 in e) && !(_m in e);
}, WX = (e) => {
  if (!df(e) || ff(e))
    return !1;
  try {
    return Object.keys(e).length === 0 && Object.getPrototypeOf(e) === Object.prototype;
  } catch {
    return !1;
  }
}, XX = Vr("Date"), KX = Vr("File"), ZX = Vr("Blob"), QX = Vr("FileList"), JX = (e) => df(e) && Fn(e.pipe), eK = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || Fn(e.append) && ((t = Sm(e)) === "formdata" || // detect form-data instance
  t === "object" && Fn(e.toString) && e.toString() === "[object FormData]"));
}, tK = Vr("URLSearchParams"), [nK, rK, oK, iK] = ["ReadableStream", "Request", "Response", "Headers"].map(Vr), aK = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function hf(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let r, o;
  if (typeof e != "object" && (e = [e]), Fl(e))
    for (r = 0, o = e.length; r < o; r++)
      t.call(null, e[r], r, e);
  else {
    if (ff(e))
      return;
    const a = n ? Object.getOwnPropertyNames(e) : Object.keys(e), s = a.length;
    let u;
    for (r = 0; r < s; r++)
      u = a[r], t.call(null, e[u], u, e);
  }
}
function d3(e, t) {
  if (ff(e))
    return null;
  t = t.toLowerCase();
  const n = Object.keys(e);
  let r = n.length, o;
  for (; r-- > 0; )
    if (o = n[r], t === o.toLowerCase())
      return o;
  return null;
}
const Ia = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : window, h3 = (e) => !zc(e) && e !== Ia;
function _b() {
  const { caseless: e } = h3(this) && this || {}, t = {}, n = (r, o) => {
    const a = e && d3(t, o) || o;
    Fh(t[a]) && Fh(r) ? t[a] = _b(t[a], r) : Fh(r) ? t[a] = _b({}, r) : Fl(r) ? t[a] = r.slice() : t[a] = r;
  };
  for (let r = 0, o = arguments.length; r < o; r++)
    arguments[r] && hf(arguments[r], n);
  return t;
}
const sK = (e, t, n, { allOwnKeys: r } = {}) => (hf(t, (o, a) => {
  n && Fn(o) ? e[a] = l3(o, n) : e[a] = o;
}, { allOwnKeys: r }), e), lK = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), uK = (e, t, n, r) => {
  e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, cK = (e, t, n, r) => {
  let o, a, s;
  const u = {};
  if (t = t || {}, e == null) return t;
  do {
    for (o = Object.getOwnPropertyNames(e), a = o.length; a-- > 0; )
      s = o[a], (!r || r(s, e, t)) && !u[s] && (t[s] = e[s], u[s] = !0);
    e = n !== !1 && mx(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, fK = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const r = e.indexOf(t, n);
  return r !== -1 && r === n;
}, dK = (e) => {
  if (!e) return null;
  if (Fl(e)) return e;
  let t = e.length;
  if (!f3(t)) return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, hK = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && mx(Uint8Array)), pK = (e, t) => {
  const r = (e && e[_m]).call(e);
  let o;
  for (; (o = r.next()) && !o.done; ) {
    const a = o.value;
    t.call(e, a[0], a[1]);
  }
}, mK = (e, t) => {
  let n;
  const r = [];
  for (; (n = e.exec(t)) !== null; )
    r.push(n);
  return r;
}, gK = Vr("HTMLFormElement"), yK = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, r, o) {
    return r.toUpperCase() + o;
  }
), HT = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), vK = Vr("RegExp"), p3 = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), r = {};
  hf(n, (o, a) => {
    let s;
    (s = t(o, a, e)) !== !1 && (r[a] = s || o);
  }), Object.defineProperties(e, r);
}, bK = (e) => {
  p3(e, (t, n) => {
    if (Fn(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = e[n];
    if (Fn(r)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, xK = (e, t) => {
  const n = {}, r = (o) => {
    o.forEach((a) => {
      n[a] = !0;
    });
  };
  return Fl(e) ? r(e) : r(String(e).split(t)), n;
}, wK = () => {
}, _K = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
function SK(e) {
  return !!(e && Fn(e.append) && e[u3] === "FormData" && e[_m]);
}
const EK = (e) => {
  const t = new Array(10), n = (r, o) => {
    if (df(r)) {
      if (t.indexOf(r) >= 0)
        return;
      if (ff(r))
        return r;
      if (!("toJSON" in r)) {
        t[o] = r;
        const a = Fl(r) ? [] : {};
        return hf(r, (s, u) => {
          const c = n(s, o + 1);
          !zc(c) && (a[u] = c);
        }), t[o] = void 0, a;
      }
    }
    return r;
  };
  return n(e, 0);
}, CK = Vr("AsyncFunction"), kK = (e) => e && (df(e) || Fn(e)) && Fn(e.then) && Fn(e.catch), m3 = ((e, t) => e ? setImmediate : t ? ((n, r) => (Ia.addEventListener("message", ({ source: o, data: a }) => {
  o === Ia && a === n && r.length && r.shift()();
}, !1), (o) => {
  r.push(o), Ia.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  Fn(Ia.postMessage)
), TK = typeof queueMicrotask < "u" ? queueMicrotask.bind(Ia) : typeof process < "u" && process.nextTick || m3, AK = (e) => e != null && Fn(e[_m]), ie = {
  isArray: Fl,
  isArrayBuffer: c3,
  isBuffer: ff,
  isFormData: eK,
  isArrayBufferView: qX,
  isString: GX,
  isNumber: f3,
  isBoolean: YX,
  isObject: df,
  isPlainObject: Fh,
  isEmptyObject: WX,
  isReadableStream: nK,
  isRequest: rK,
  isResponse: oK,
  isHeaders: iK,
  isUndefined: zc,
  isDate: XX,
  isFile: KX,
  isBlob: ZX,
  isRegExp: vK,
  isFunction: Fn,
  isStream: JX,
  isURLSearchParams: tK,
  isTypedArray: hK,
  isFileList: QX,
  forEach: hf,
  merge: _b,
  extend: sK,
  trim: aK,
  stripBOM: lK,
  inherits: uK,
  toFlatObject: cK,
  kindOf: Sm,
  kindOfTest: Vr,
  endsWith: fK,
  toArray: dK,
  forEachEntry: pK,
  matchAll: mK,
  isHTMLForm: gK,
  hasOwnProperty: HT,
  hasOwnProp: HT,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: p3,
  freezeMethods: bK,
  toObjectSet: xK,
  toCamelCase: yK,
  noop: wK,
  toFiniteNumber: _K,
  findKey: d3,
  global: Ia,
  isContextDefined: h3,
  isSpecCompliantForm: SK,
  toJSONObject: EK,
  isAsyncFn: CK,
  isThenable: kK,
  setImmediate: m3,
  asap: TK,
  isIterable: AK
};
function Fe(e, t, n, r, o) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), o && (this.response = o, this.status = o.status ? o.status : null);
}
ie.inherits(Fe, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: ie.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const g3 = Fe.prototype, y3 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  y3[e] = { value: e };
});
Object.defineProperties(Fe, y3);
Object.defineProperty(g3, "isAxiosError", { value: !0 });
Fe.from = (e, t, n, r, o, a) => {
  const s = Object.create(g3);
  return ie.toFlatObject(e, s, function(c) {
    return c !== Error.prototype;
  }, (u) => u !== "isAxiosError"), Fe.call(s, e.message, t, n, r, o), s.cause = e, s.name = e.name, a && Object.assign(s, a), s;
};
const RK = null;
function Sb(e) {
  return ie.isPlainObject(e) || ie.isArray(e);
}
function v3(e) {
  return ie.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function VT(e, t, n) {
  return e ? e.concat(t).map(function(o, a) {
    return o = v3(o), !n && a ? "[" + o + "]" : o;
  }).join(n ? "." : "") : t;
}
function MK(e) {
  return ie.isArray(e) && !e.some(Sb);
}
const OK = ie.toFlatObject(ie, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function Cm(e, t, n) {
  if (!ie.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), n = ie.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(v, S) {
    return !ie.isUndefined(S[v]);
  });
  const r = n.metaTokens, o = n.visitor || h, a = n.dots, s = n.indexes, c = (n.Blob || typeof Blob < "u" && Blob) && ie.isSpecCompliantForm(t);
  if (!ie.isFunction(o))
    throw new TypeError("visitor must be a function");
  function f(w) {
    if (w === null) return "";
    if (ie.isDate(w))
      return w.toISOString();
    if (ie.isBoolean(w))
      return w.toString();
    if (!c && ie.isBlob(w))
      throw new Fe("Blob is not supported. Use a Buffer instead.");
    return ie.isArrayBuffer(w) || ie.isTypedArray(w) ? c && typeof Blob == "function" ? new Blob([w]) : Buffer.from(w) : w;
  }
  function h(w, v, S) {
    let E = w;
    if (w && !S && typeof w == "object") {
      if (ie.endsWith(v, "{}"))
        v = r ? v : v.slice(0, -2), w = JSON.stringify(w);
      else if (ie.isArray(w) && MK(w) || (ie.isFileList(w) || ie.endsWith(v, "[]")) && (E = ie.toArray(w)))
        return v = v3(v), E.forEach(function(k, A) {
          !(ie.isUndefined(k) || k === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            s === !0 ? VT([v], A, a) : s === null ? v : v + "[]",
            f(k)
          );
        }), !1;
    }
    return Sb(w) ? !0 : (t.append(VT(S, v, a), f(w)), !1);
  }
  const p = [], g = Object.assign(OK, {
    defaultVisitor: h,
    convertValue: f,
    isVisitable: Sb
  });
  function y(w, v) {
    if (!ie.isUndefined(w)) {
      if (p.indexOf(w) !== -1)
        throw Error("Circular reference detected in " + v.join("."));
      p.push(w), ie.forEach(w, function(E, T) {
        (!(ie.isUndefined(E) || E === null) && o.call(
          t,
          E,
          ie.isString(T) ? T.trim() : T,
          v,
          g
        )) === !0 && y(E, v ? v.concat(T) : [T]);
      }), p.pop();
    }
  }
  if (!ie.isObject(e))
    throw new TypeError("data must be an object");
  return y(e), t;
}
function UT(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
    return t[r];
  });
}
function gx(e, t) {
  this._pairs = [], e && Cm(e, this, t);
}
const b3 = gx.prototype;
b3.append = function(t, n) {
  this._pairs.push([t, n]);
};
b3.toString = function(t) {
  const n = t ? function(r) {
    return t.call(this, r, UT);
  } : UT;
  return this._pairs.map(function(o) {
    return n(o[0]) + "=" + n(o[1]);
  }, "").join("&");
};
function NK(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function x3(e, t, n) {
  if (!t)
    return e;
  const r = n && n.encode || NK;
  ie.isFunction(n) && (n = {
    serialize: n
  });
  const o = n && n.serialize;
  let a;
  if (o ? a = o(t, n) : a = ie.isURLSearchParams(t) ? t.toString() : new gx(t, n).toString(r), a) {
    const s = e.indexOf("#");
    s !== -1 && (e = e.slice(0, s)), e += (e.indexOf("?") === -1 ? "?" : "&") + a;
  }
  return e;
}
class qT {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, r) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    ie.forEach(this.handlers, function(r) {
      r !== null && t(r);
    });
  }
}
const w3 = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, DK = typeof URLSearchParams < "u" ? URLSearchParams : gx, PK = typeof FormData < "u" ? FormData : null, jK = typeof Blob < "u" ? Blob : null, IK = {
  isBrowser: !0,
  classes: {
    URLSearchParams: DK,
    FormData: PK,
    Blob: jK
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, yx = typeof window < "u" && typeof document < "u", Eb = typeof navigator == "object" && navigator || void 0, zK = yx && (!Eb || ["ReactNative", "NativeScript", "NS"].indexOf(Eb.product) < 0), LK = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", FK = yx && window.location.href || "http://localhost", $K = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: yx,
  hasStandardBrowserEnv: zK,
  hasStandardBrowserWebWorkerEnv: LK,
  navigator: Eb,
  origin: FK
}, Symbol.toStringTag, { value: "Module" })), yn = {
  ...$K,
  ...IK
};
function BK(e, t) {
  return Cm(e, new yn.classes.URLSearchParams(), {
    visitor: function(n, r, o, a) {
      return yn.isNode && ie.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : a.defaultVisitor.apply(this, arguments);
    },
    ...t
  });
}
function HK(e) {
  return ie.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function VK(e) {
  const t = {}, n = Object.keys(e);
  let r;
  const o = n.length;
  let a;
  for (r = 0; r < o; r++)
    a = n[r], t[a] = e[a];
  return t;
}
function _3(e) {
  function t(n, r, o, a) {
    let s = n[a++];
    if (s === "__proto__") return !0;
    const u = Number.isFinite(+s), c = a >= n.length;
    return s = !s && ie.isArray(o) ? o.length : s, c ? (ie.hasOwnProp(o, s) ? o[s] = [o[s], r] : o[s] = r, !u) : ((!o[s] || !ie.isObject(o[s])) && (o[s] = []), t(n, r, o[s], a) && ie.isArray(o[s]) && (o[s] = VK(o[s])), !u);
  }
  if (ie.isFormData(e) && ie.isFunction(e.entries)) {
    const n = {};
    return ie.forEachEntry(e, (r, o) => {
      t(HK(r), o, n, 0);
    }), n;
  }
  return null;
}
function UK(e, t, n) {
  if (ie.isString(e))
    try {
      return (t || JSON.parse)(e), ie.trim(e);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(e);
}
const pf = {
  transitional: w3,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, n) {
    const r = n.getContentType() || "", o = r.indexOf("application/json") > -1, a = ie.isObject(t);
    if (a && ie.isHTMLForm(t) && (t = new FormData(t)), ie.isFormData(t))
      return o ? JSON.stringify(_3(t)) : t;
    if (ie.isArrayBuffer(t) || ie.isBuffer(t) || ie.isStream(t) || ie.isFile(t) || ie.isBlob(t) || ie.isReadableStream(t))
      return t;
    if (ie.isArrayBufferView(t))
      return t.buffer;
    if (ie.isURLSearchParams(t))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let u;
    if (a) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return BK(t, this.formSerializer).toString();
      if ((u = ie.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
        const c = this.env && this.env.FormData;
        return Cm(
          u ? { "files[]": t } : t,
          c && new c(),
          this.formSerializer
        );
      }
    }
    return a || o ? (n.setContentType("application/json", !1), UK(t)) : t;
  }],
  transformResponse: [function(t) {
    const n = this.transitional || pf.transitional, r = n && n.forcedJSONParsing, o = this.responseType === "json";
    if (ie.isResponse(t) || ie.isReadableStream(t))
      return t;
    if (t && ie.isString(t) && (r && !this.responseType || o)) {
      const s = !(n && n.silentJSONParsing) && o;
      try {
        return JSON.parse(t);
      } catch (u) {
        if (s)
          throw u.name === "SyntaxError" ? Fe.from(u, Fe.ERR_BAD_RESPONSE, this, null, this.response) : u;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: yn.classes.FormData,
    Blob: yn.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
ie.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  pf.headers[e] = {};
});
const qK = ie.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), GK = (e) => {
  const t = {};
  let n, r, o;
  return e && e.split(`
`).forEach(function(s) {
    o = s.indexOf(":"), n = s.substring(0, o).trim().toLowerCase(), r = s.substring(o + 1).trim(), !(!n || t[n] && qK[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
  }), t;
}, GT = Symbol("internals");
function nc(e) {
  return e && String(e).trim().toLowerCase();
}
function $h(e) {
  return e === !1 || e == null ? e : ie.isArray(e) ? e.map($h) : String(e);
}
function YK(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(e); )
    t[r[1]] = r[2];
  return t;
}
const WK = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function av(e, t, n, r, o) {
  if (ie.isFunction(r))
    return r.call(this, t, n);
  if (o && (t = n), !!ie.isString(t)) {
    if (ie.isString(r))
      return t.indexOf(r) !== -1;
    if (ie.isRegExp(r))
      return r.test(t);
  }
}
function XK(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
}
function KK(e, t) {
  const n = ie.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(e, r + n, {
      value: function(o, a, s) {
        return this[r].call(this, t, o, a, s);
      },
      configurable: !0
    });
  });
}
let $n = class {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, r) {
    const o = this;
    function a(u, c, f) {
      const h = nc(c);
      if (!h)
        throw new Error("header name must be a non-empty string");
      const p = ie.findKey(o, h);
      (!p || o[p] === void 0 || f === !0 || f === void 0 && o[p] !== !1) && (o[p || c] = $h(u));
    }
    const s = (u, c) => ie.forEach(u, (f, h) => a(f, h, c));
    if (ie.isPlainObject(t) || t instanceof this.constructor)
      s(t, n);
    else if (ie.isString(t) && (t = t.trim()) && !WK(t))
      s(GK(t), n);
    else if (ie.isObject(t) && ie.isIterable(t)) {
      let u = {}, c, f;
      for (const h of t) {
        if (!ie.isArray(h))
          throw TypeError("Object iterator must return a key-value pair");
        u[f = h[0]] = (c = u[f]) ? ie.isArray(c) ? [...c, h[1]] : [c, h[1]] : h[1];
      }
      s(u, n);
    } else
      t != null && a(n, t, r);
    return this;
  }
  get(t, n) {
    if (t = nc(t), t) {
      const r = ie.findKey(this, t);
      if (r) {
        const o = this[r];
        if (!n)
          return o;
        if (n === !0)
          return YK(o);
        if (ie.isFunction(n))
          return n.call(this, o, r);
        if (ie.isRegExp(n))
          return n.exec(o);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, n) {
    if (t = nc(t), t) {
      const r = ie.findKey(this, t);
      return !!(r && this[r] !== void 0 && (!n || av(this, this[r], r, n)));
    }
    return !1;
  }
  delete(t, n) {
    const r = this;
    let o = !1;
    function a(s) {
      if (s = nc(s), s) {
        const u = ie.findKey(r, s);
        u && (!n || av(r, r[u], u, n)) && (delete r[u], o = !0);
      }
    }
    return ie.isArray(t) ? t.forEach(a) : a(t), o;
  }
  clear(t) {
    const n = Object.keys(this);
    let r = n.length, o = !1;
    for (; r--; ) {
      const a = n[r];
      (!t || av(this, this[a], a, t, !0)) && (delete this[a], o = !0);
    }
    return o;
  }
  normalize(t) {
    const n = this, r = {};
    return ie.forEach(this, (o, a) => {
      const s = ie.findKey(r, a);
      if (s) {
        n[s] = $h(o), delete n[a];
        return;
      }
      const u = t ? XK(a) : String(a).trim();
      u !== a && delete n[a], n[u] = $h(o), r[u] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const n = /* @__PURE__ */ Object.create(null);
    return ie.forEach(this, (r, o) => {
      r != null && r !== !1 && (n[o] = t && ie.isArray(r) ? r.join(", ") : r);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...n) {
    const r = new this(t);
    return n.forEach((o) => r.set(o)), r;
  }
  static accessor(t) {
    const r = (this[GT] = this[GT] = {
      accessors: {}
    }).accessors, o = this.prototype;
    function a(s) {
      const u = nc(s);
      r[u] || (KK(o, s), r[u] = !0);
    }
    return ie.isArray(t) ? t.forEach(a) : a(t), this;
  }
};
$n.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
ie.reduceDescriptors($n.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(r) {
      this[n] = r;
    }
  };
});
ie.freezeMethods($n);
function sv(e, t) {
  const n = this || pf, r = t || n, o = $n.from(r.headers);
  let a = r.data;
  return ie.forEach(e, function(u) {
    a = u.call(n, a, o.normalize(), t ? t.status : void 0);
  }), o.normalize(), a;
}
function S3(e) {
  return !!(e && e.__CANCEL__);
}
function $l(e, t, n) {
  Fe.call(this, e ?? "canceled", Fe.ERR_CANCELED, t, n), this.name = "CanceledError";
}
ie.inherits($l, Fe, {
  __CANCEL__: !0
});
function E3(e, t, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? e(n) : t(new Fe(
    "Request failed with status code " + n.status,
    [Fe.ERR_BAD_REQUEST, Fe.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function ZK(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function QK(e, t) {
  e = e || 10;
  const n = new Array(e), r = new Array(e);
  let o = 0, a = 0, s;
  return t = t !== void 0 ? t : 1e3, function(c) {
    const f = Date.now(), h = r[a];
    s || (s = f), n[o] = c, r[o] = f;
    let p = a, g = 0;
    for (; p !== o; )
      g += n[p++], p = p % e;
    if (o = (o + 1) % e, o === a && (a = (a + 1) % e), f - s < t)
      return;
    const y = h && f - h;
    return y ? Math.round(g * 1e3 / y) : void 0;
  };
}
function JK(e, t) {
  let n = 0, r = 1e3 / t, o, a;
  const s = (f, h = Date.now()) => {
    n = h, o = null, a && (clearTimeout(a), a = null), e(...f);
  };
  return [(...f) => {
    const h = Date.now(), p = h - n;
    p >= r ? s(f, h) : (o = f, a || (a = setTimeout(() => {
      a = null, s(o);
    }, r - p)));
  }, () => o && s(o)];
}
const pp = (e, t, n = 3) => {
  let r = 0;
  const o = QK(50, 250);
  return JK((a) => {
    const s = a.loaded, u = a.lengthComputable ? a.total : void 0, c = s - r, f = o(c), h = s <= u;
    r = s;
    const p = {
      loaded: s,
      total: u,
      progress: u ? s / u : void 0,
      bytes: c,
      rate: f || void 0,
      estimated: f && u && h ? (u - s) / f : void 0,
      event: a,
      lengthComputable: u != null,
      [t ? "download" : "upload"]: !0
    };
    e(p);
  }, n);
}, YT = (e, t) => {
  const n = e != null;
  return [(r) => t[0]({
    lengthComputable: n,
    total: e,
    loaded: r
  }), t[1]];
}, WT = (e) => (...t) => ie.asap(() => e(...t)), eZ = yn.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t) => (n) => (n = new URL(n, yn.origin), e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(
  new URL(yn.origin),
  yn.navigator && /(msie|trident)/i.test(yn.navigator.userAgent)
) : () => !0, tZ = yn.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, n, r, o, a) {
      const s = [e + "=" + encodeURIComponent(t)];
      ie.isNumber(n) && s.push("expires=" + new Date(n).toGMTString()), ie.isString(r) && s.push("path=" + r), ie.isString(o) && s.push("domain=" + o), a === !0 && s.push("secure"), document.cookie = s.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function nZ(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function rZ(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function C3(e, t, n) {
  let r = !nZ(t);
  return e && (r || n == !1) ? rZ(e, t) : t;
}
const XT = (e) => e instanceof $n ? { ...e } : e;
function Xa(e, t) {
  t = t || {};
  const n = {};
  function r(f, h, p, g) {
    return ie.isPlainObject(f) && ie.isPlainObject(h) ? ie.merge.call({ caseless: g }, f, h) : ie.isPlainObject(h) ? ie.merge({}, h) : ie.isArray(h) ? h.slice() : h;
  }
  function o(f, h, p, g) {
    if (ie.isUndefined(h)) {
      if (!ie.isUndefined(f))
        return r(void 0, f, p, g);
    } else return r(f, h, p, g);
  }
  function a(f, h) {
    if (!ie.isUndefined(h))
      return r(void 0, h);
  }
  function s(f, h) {
    if (ie.isUndefined(h)) {
      if (!ie.isUndefined(f))
        return r(void 0, f);
    } else return r(void 0, h);
  }
  function u(f, h, p) {
    if (p in t)
      return r(f, h);
    if (p in e)
      return r(void 0, f);
  }
  const c = {
    url: a,
    method: a,
    data: a,
    baseURL: s,
    transformRequest: s,
    transformResponse: s,
    paramsSerializer: s,
    timeout: s,
    timeoutMessage: s,
    withCredentials: s,
    withXSRFToken: s,
    adapter: s,
    responseType: s,
    xsrfCookieName: s,
    xsrfHeaderName: s,
    onUploadProgress: s,
    onDownloadProgress: s,
    decompress: s,
    maxContentLength: s,
    maxBodyLength: s,
    beforeRedirect: s,
    transport: s,
    httpAgent: s,
    httpsAgent: s,
    cancelToken: s,
    socketPath: s,
    responseEncoding: s,
    validateStatus: u,
    headers: (f, h, p) => o(XT(f), XT(h), p, !0)
  };
  return ie.forEach(Object.keys({ ...e, ...t }), function(h) {
    const p = c[h] || o, g = p(e[h], t[h], h);
    ie.isUndefined(g) && p !== u || (n[h] = g);
  }), n;
}
const k3 = (e) => {
  const t = Xa({}, e);
  let { data: n, withXSRFToken: r, xsrfHeaderName: o, xsrfCookieName: a, headers: s, auth: u } = t;
  t.headers = s = $n.from(s), t.url = x3(C3(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), u && s.set(
    "Authorization",
    "Basic " + btoa((u.username || "") + ":" + (u.password ? unescape(encodeURIComponent(u.password)) : ""))
  );
  let c;
  if (ie.isFormData(n)) {
    if (yn.hasStandardBrowserEnv || yn.hasStandardBrowserWebWorkerEnv)
      s.setContentType(void 0);
    else if ((c = s.getContentType()) !== !1) {
      const [f, ...h] = c ? c.split(";").map((p) => p.trim()).filter(Boolean) : [];
      s.setContentType([f || "multipart/form-data", ...h].join("; "));
    }
  }
  if (yn.hasStandardBrowserEnv && (r && ie.isFunction(r) && (r = r(t)), r || r !== !1 && eZ(t.url))) {
    const f = o && a && tZ.read(a);
    f && s.set(o, f);
  }
  return t;
}, oZ = typeof XMLHttpRequest < "u", iZ = oZ && function(e) {
  return new Promise(function(n, r) {
    const o = k3(e);
    let a = o.data;
    const s = $n.from(o.headers).normalize();
    let { responseType: u, onUploadProgress: c, onDownloadProgress: f } = o, h, p, g, y, w;
    function v() {
      y && y(), w && w(), o.cancelToken && o.cancelToken.unsubscribe(h), o.signal && o.signal.removeEventListener("abort", h);
    }
    let S = new XMLHttpRequest();
    S.open(o.method.toUpperCase(), o.url, !0), S.timeout = o.timeout;
    function E() {
      if (!S)
        return;
      const k = $n.from(
        "getAllResponseHeaders" in S && S.getAllResponseHeaders()
      ), M = {
        data: !u || u === "text" || u === "json" ? S.responseText : S.response,
        status: S.status,
        statusText: S.statusText,
        headers: k,
        config: e,
        request: S
      };
      E3(function(P) {
        n(P), v();
      }, function(P) {
        r(P), v();
      }, M), S = null;
    }
    "onloadend" in S ? S.onloadend = E : S.onreadystatechange = function() {
      !S || S.readyState !== 4 || S.status === 0 && !(S.responseURL && S.responseURL.indexOf("file:") === 0) || setTimeout(E);
    }, S.onabort = function() {
      S && (r(new Fe("Request aborted", Fe.ECONNABORTED, e, S)), S = null);
    }, S.onerror = function() {
      r(new Fe("Network Error", Fe.ERR_NETWORK, e, S)), S = null;
    }, S.ontimeout = function() {
      let A = o.timeout ? "timeout of " + o.timeout + "ms exceeded" : "timeout exceeded";
      const M = o.transitional || w3;
      o.timeoutErrorMessage && (A = o.timeoutErrorMessage), r(new Fe(
        A,
        M.clarifyTimeoutError ? Fe.ETIMEDOUT : Fe.ECONNABORTED,
        e,
        S
      )), S = null;
    }, a === void 0 && s.setContentType(null), "setRequestHeader" in S && ie.forEach(s.toJSON(), function(A, M) {
      S.setRequestHeader(M, A);
    }), ie.isUndefined(o.withCredentials) || (S.withCredentials = !!o.withCredentials), u && u !== "json" && (S.responseType = o.responseType), f && ([g, w] = pp(f, !0), S.addEventListener("progress", g)), c && S.upload && ([p, y] = pp(c), S.upload.addEventListener("progress", p), S.upload.addEventListener("loadend", y)), (o.cancelToken || o.signal) && (h = (k) => {
      S && (r(!k || k.type ? new $l(null, e, S) : k), S.abort(), S = null);
    }, o.cancelToken && o.cancelToken.subscribe(h), o.signal && (o.signal.aborted ? h() : o.signal.addEventListener("abort", h)));
    const T = ZK(o.url);
    if (T && yn.protocols.indexOf(T) === -1) {
      r(new Fe("Unsupported protocol " + T + ":", Fe.ERR_BAD_REQUEST, e));
      return;
    }
    S.send(a || null);
  });
}, aZ = (e, t) => {
  const { length: n } = e = e ? e.filter(Boolean) : [];
  if (t || n) {
    let r = new AbortController(), o;
    const a = function(f) {
      if (!o) {
        o = !0, u();
        const h = f instanceof Error ? f : this.reason;
        r.abort(h instanceof Fe ? h : new $l(h instanceof Error ? h.message : h));
      }
    };
    let s = t && setTimeout(() => {
      s = null, a(new Fe(`timeout ${t} of ms exceeded`, Fe.ETIMEDOUT));
    }, t);
    const u = () => {
      e && (s && clearTimeout(s), s = null, e.forEach((f) => {
        f.unsubscribe ? f.unsubscribe(a) : f.removeEventListener("abort", a);
      }), e = null);
    };
    e.forEach((f) => f.addEventListener("abort", a));
    const { signal: c } = r;
    return c.unsubscribe = () => ie.asap(u), c;
  }
}, sZ = function* (e, t) {
  let n = e.byteLength;
  if (n < t) {
    yield e;
    return;
  }
  let r = 0, o;
  for (; r < n; )
    o = r + t, yield e.slice(r, o), r = o;
}, lZ = async function* (e, t) {
  for await (const n of uZ(e))
    yield* sZ(n, t);
}, uZ = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: n, value: r } = await t.read();
      if (n)
        break;
      yield r;
    }
  } finally {
    await t.cancel();
  }
}, KT = (e, t, n, r) => {
  const o = lZ(e, t);
  let a = 0, s, u = (c) => {
    s || (s = !0, r && r(c));
  };
  return new ReadableStream({
    async pull(c) {
      try {
        const { done: f, value: h } = await o.next();
        if (f) {
          u(), c.close();
          return;
        }
        let p = h.byteLength;
        if (n) {
          let g = a += p;
          n(g);
        }
        c.enqueue(new Uint8Array(h));
      } catch (f) {
        throw u(f), f;
      }
    },
    cancel(c) {
      return u(c), o.return();
    }
  }, {
    highWaterMark: 2
  });
}, km = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", T3 = km && typeof ReadableStream == "function", cZ = km && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), A3 = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
}, fZ = T3 && A3(() => {
  let e = !1;
  const t = new Request(yn.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
}), ZT = 64 * 1024, Cb = T3 && A3(() => ie.isReadableStream(new Response("").body)), mp = {
  stream: Cb && ((e) => e.body)
};
km && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !mp[t] && (mp[t] = ie.isFunction(e[t]) ? (n) => n[t]() : (n, r) => {
      throw new Fe(`Response type '${t}' is not supported`, Fe.ERR_NOT_SUPPORT, r);
    });
  });
})(new Response());
const dZ = async (e) => {
  if (e == null)
    return 0;
  if (ie.isBlob(e))
    return e.size;
  if (ie.isSpecCompliantForm(e))
    return (await new Request(yn.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (ie.isArrayBufferView(e) || ie.isArrayBuffer(e))
    return e.byteLength;
  if (ie.isURLSearchParams(e) && (e = e + ""), ie.isString(e))
    return (await cZ(e)).byteLength;
}, hZ = async (e, t) => {
  const n = ie.toFiniteNumber(e.getContentLength());
  return n ?? dZ(t);
}, pZ = km && (async (e) => {
  let {
    url: t,
    method: n,
    data: r,
    signal: o,
    cancelToken: a,
    timeout: s,
    onDownloadProgress: u,
    onUploadProgress: c,
    responseType: f,
    headers: h,
    withCredentials: p = "same-origin",
    fetchOptions: g
  } = k3(e);
  f = f ? (f + "").toLowerCase() : "text";
  let y = aZ([o, a && a.toAbortSignal()], s), w;
  const v = y && y.unsubscribe && (() => {
    y.unsubscribe();
  });
  let S;
  try {
    if (c && fZ && n !== "get" && n !== "head" && (S = await hZ(h, r)) !== 0) {
      let M = new Request(t, {
        method: "POST",
        body: r,
        duplex: "half"
      }), N;
      if (ie.isFormData(r) && (N = M.headers.get("content-type")) && h.setContentType(N), M.body) {
        const [P, z] = YT(
          S,
          pp(WT(c))
        );
        r = KT(M.body, ZT, P, z);
      }
    }
    ie.isString(p) || (p = p ? "include" : "omit");
    const E = "credentials" in Request.prototype;
    w = new Request(t, {
      ...g,
      signal: y,
      method: n.toUpperCase(),
      headers: h.normalize().toJSON(),
      body: r,
      duplex: "half",
      credentials: E ? p : void 0
    });
    let T = await fetch(w, g);
    const k = Cb && (f === "stream" || f === "response");
    if (Cb && (u || k && v)) {
      const M = {};
      ["status", "statusText", "headers"].forEach((B) => {
        M[B] = T[B];
      });
      const N = ie.toFiniteNumber(T.headers.get("content-length")), [P, z] = u && YT(
        N,
        pp(WT(u), !0)
      ) || [];
      T = new Response(
        KT(T.body, ZT, P, () => {
          z && z(), v && v();
        }),
        M
      );
    }
    f = f || "text";
    let A = await mp[ie.findKey(mp, f) || "text"](T, e);
    return !k && v && v(), await new Promise((M, N) => {
      E3(M, N, {
        data: A,
        headers: $n.from(T.headers),
        status: T.status,
        statusText: T.statusText,
        config: e,
        request: w
      });
    });
  } catch (E) {
    throw v && v(), E && E.name === "TypeError" && /Load failed|fetch/i.test(E.message) ? Object.assign(
      new Fe("Network Error", Fe.ERR_NETWORK, e, w),
      {
        cause: E.cause || E
      }
    ) : Fe.from(E, E && E.code, e, w);
  }
}), kb = {
  http: RK,
  xhr: iZ,
  fetch: pZ
};
ie.forEach(kb, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const QT = (e) => `- ${e}`, mZ = (e) => ie.isFunction(e) || e === null || e === !1, R3 = {
  getAdapter: (e) => {
    e = ie.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, r;
    const o = {};
    for (let a = 0; a < t; a++) {
      n = e[a];
      let s;
      if (r = n, !mZ(n) && (r = kb[(s = String(n)).toLowerCase()], r === void 0))
        throw new Fe(`Unknown adapter '${s}'`);
      if (r)
        break;
      o[s || "#" + a] = r;
    }
    if (!r) {
      const a = Object.entries(o).map(
        ([u, c]) => `adapter ${u} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let s = t ? a.length > 1 ? `since :
` + a.map(QT).join(`
`) : " " + QT(a[0]) : "as no adapter specified";
      throw new Fe(
        "There is no suitable adapter to dispatch the request " + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return r;
  },
  adapters: kb
};
function lv(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new $l(null, e);
}
function JT(e) {
  return lv(e), e.headers = $n.from(e.headers), e.data = sv.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), R3.getAdapter(e.adapter || pf.adapter)(e).then(function(r) {
    return lv(e), r.data = sv.call(
      e,
      e.transformResponse,
      r
    ), r.headers = $n.from(r.headers), r;
  }, function(r) {
    return S3(r) || (lv(e), r && r.response && (r.response.data = sv.call(
      e,
      e.transformResponse,
      r.response
    ), r.response.headers = $n.from(r.response.headers))), Promise.reject(r);
  });
}
const M3 = "1.11.0", Tm = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  Tm[e] = function(r) {
    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const eA = {};
Tm.transitional = function(t, n, r) {
  function o(a, s) {
    return "[Axios v" + M3 + "] Transitional option '" + a + "'" + s + (r ? ". " + r : "");
  }
  return (a, s, u) => {
    if (t === !1)
      throw new Fe(
        o(s, " has been removed" + (n ? " in " + n : "")),
        Fe.ERR_DEPRECATED
      );
    return n && !eA[s] && (eA[s] = !0, console.warn(
      o(
        s,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), t ? t(a, s, u) : !0;
  };
};
Tm.spelling = function(t) {
  return (n, r) => (console.warn(`${r} is likely a misspelling of ${t}`), !0);
};
function gZ(e, t, n) {
  if (typeof e != "object")
    throw new Fe("options must be an object", Fe.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(e);
  let o = r.length;
  for (; o-- > 0; ) {
    const a = r[o], s = t[a];
    if (s) {
      const u = e[a], c = u === void 0 || s(u, a, e);
      if (c !== !0)
        throw new Fe("option " + a + " must be " + c, Fe.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new Fe("Unknown option " + a, Fe.ERR_BAD_OPTION);
  }
}
const Bh = {
  assertOptions: gZ,
  validators: Tm
}, eo = Bh.validators;
let Fa = class {
  constructor(t) {
    this.defaults = t || {}, this.interceptors = {
      request: new qT(),
      response: new qT()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, n) {
    try {
      return await this._request(t, n);
    } catch (r) {
      if (r instanceof Error) {
        let o = {};
        Error.captureStackTrace ? Error.captureStackTrace(o) : o = new Error();
        const a = o.stack ? o.stack.replace(/^.+\n/, "") : "";
        try {
          r.stack ? a && !String(r.stack).endsWith(a.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + a) : r.stack = a;
        } catch {
        }
      }
      throw r;
    }
  }
  _request(t, n) {
    typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = Xa(this.defaults, n);
    const { transitional: r, paramsSerializer: o, headers: a } = n;
    r !== void 0 && Bh.assertOptions(r, {
      silentJSONParsing: eo.transitional(eo.boolean),
      forcedJSONParsing: eo.transitional(eo.boolean),
      clarifyTimeoutError: eo.transitional(eo.boolean)
    }, !1), o != null && (ie.isFunction(o) ? n.paramsSerializer = {
      serialize: o
    } : Bh.assertOptions(o, {
      encode: eo.function,
      serialize: eo.function
    }, !0)), n.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? n.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : n.allowAbsoluteUrls = !0), Bh.assertOptions(n, {
      baseUrl: eo.spelling("baseURL"),
      withXsrfToken: eo.spelling("withXSRFToken")
    }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let s = a && ie.merge(
      a.common,
      a[n.method]
    );
    a && ie.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (w) => {
        delete a[w];
      }
    ), n.headers = $n.concat(s, a);
    const u = [];
    let c = !0;
    this.interceptors.request.forEach(function(v) {
      typeof v.runWhen == "function" && v.runWhen(n) === !1 || (c = c && v.synchronous, u.unshift(v.fulfilled, v.rejected));
    });
    const f = [];
    this.interceptors.response.forEach(function(v) {
      f.push(v.fulfilled, v.rejected);
    });
    let h, p = 0, g;
    if (!c) {
      const w = [JT.bind(this), void 0];
      for (w.unshift(...u), w.push(...f), g = w.length, h = Promise.resolve(n); p < g; )
        h = h.then(w[p++], w[p++]);
      return h;
    }
    g = u.length;
    let y = n;
    for (p = 0; p < g; ) {
      const w = u[p++], v = u[p++];
      try {
        y = w(y);
      } catch (S) {
        v.call(this, S);
        break;
      }
    }
    try {
      h = JT.call(this, y);
    } catch (w) {
      return Promise.reject(w);
    }
    for (p = 0, g = f.length; p < g; )
      h = h.then(f[p++], f[p++]);
    return h;
  }
  getUri(t) {
    t = Xa(this.defaults, t);
    const n = C3(t.baseURL, t.url, t.allowAbsoluteUrls);
    return x3(n, t.params, t.paramsSerializer);
  }
};
ie.forEach(["delete", "get", "head", "options"], function(t) {
  Fa.prototype[t] = function(n, r) {
    return this.request(Xa(r || {}, {
      method: t,
      url: n,
      data: (r || {}).data
    }));
  };
});
ie.forEach(["post", "put", "patch"], function(t) {
  function n(r) {
    return function(a, s, u) {
      return this.request(Xa(u || {}, {
        method: t,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: a,
        data: s
      }));
    };
  }
  Fa.prototype[t] = n(), Fa.prototype[t + "Form"] = n(!0);
});
let yZ = class O3 {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(a) {
      n = a;
    });
    const r = this;
    this.promise.then((o) => {
      if (!r._listeners) return;
      let a = r._listeners.length;
      for (; a-- > 0; )
        r._listeners[a](o);
      r._listeners = null;
    }), this.promise.then = (o) => {
      let a;
      const s = new Promise((u) => {
        r.subscribe(u), a = u;
      }).then(o);
      return s.cancel = function() {
        r.unsubscribe(a);
      }, s;
    }, t(function(a, s, u) {
      r.reason || (r.reason = new $l(a, s, u), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), n = (r) => {
      t.abort(r);
    };
    return this.subscribe(n), t.signal.unsubscribe = () => this.unsubscribe(n), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new O3(function(o) {
        t = o;
      }),
      cancel: t
    };
  }
};
function vZ(e) {
  return function(n) {
    return e.apply(null, n);
  };
}
function bZ(e) {
  return ie.isObject(e) && e.isAxiosError === !0;
}
const Tb = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Tb).forEach(([e, t]) => {
  Tb[t] = e;
});
function N3(e) {
  const t = new Fa(e), n = l3(Fa.prototype.request, t);
  return ie.extend(n, Fa.prototype, t, { allOwnKeys: !0 }), ie.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(o) {
    return N3(Xa(e, o));
  }, n;
}
const Lt = N3(pf);
Lt.Axios = Fa;
Lt.CanceledError = $l;
Lt.CancelToken = yZ;
Lt.isCancel = S3;
Lt.VERSION = M3;
Lt.toFormData = Cm;
Lt.AxiosError = Fe;
Lt.Cancel = Lt.CanceledError;
Lt.all = function(t) {
  return Promise.all(t);
};
Lt.spread = vZ;
Lt.isAxiosError = bZ;
Lt.mergeConfig = Xa;
Lt.AxiosHeaders = $n;
Lt.formToJSON = (e) => _3(ie.isHTMLForm(e) ? new FormData(e) : e);
Lt.getAdapter = R3.getAdapter;
Lt.HttpStatusCode = Tb;
Lt.default = Lt;
const {
  Axios: Kpe,
  AxiosError: Zpe,
  CanceledError: Qpe,
  isCancel: Jpe,
  CancelToken: eme,
  VERSION: tme,
  all: nme,
  Cancel: rme,
  isAxiosError: ome,
  spread: ime,
  toFormData: ame,
  AxiosHeaders: sme,
  HttpStatusCode: lme,
  formToJSON: ume,
  getAdapter: cme,
  mergeConfig: fme
} = Lt;
class D3 extends VX {
  constructor(t) {
    super(t), this._websocket = null, this.reconnectAttempts = 0, this.maxReconnectAttempts = 999, this.initialTimeout = 200, this.maxTimeout = 5e3, this._reconnect = !0, this._reconnect_timeout = void 0, this._url = t.url, this._reconnect_timeout = setTimeout(() => {
      this.connect();
    }, 200), this._zustand && this._zustand.auto_progress();
  }
  connect() {
    this._zustand?.logger.info("Connecting to websocket"), this.is_open = !1, this._websocket = new WebSocket(this._url), this._websocket.onopen = () => {
      this.onopen();
    }, this._websocket.onclose = () => {
      this.onclose();
    }, this._websocket.onerror = () => {
      this.on_ws_error();
    }, this._websocket.onmessage = (t) => {
      typeof t.data == "string" ? this.onmessage(t.data) : t.data instanceof Blob && t.data.arrayBuffer().then((n) => {
        const r = new Uint8Array(n);
        this.getCommunicationManager().onbytes(r);
      });
    };
  }
  calculateReconnectTimeout() {
    return Math.min(
      this.initialTimeout * Math.pow(2, this.reconnectAttempts),
      this.maxTimeout
    );
  }
  auto_reconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      let t = this.calculateReconnectTimeout();
      this._zustand?.logger.info(`Attempting to reconnect in ${t} ms`), this._reconnect_timeout = setTimeout(() => {
        this._websocket && this._websocket.readyState === WebSocket.OPEN || (this.reconnectAttempts++, this.connect());
      }, t);
    } else
      this._zustand?.logger.warn(
        "Maximum reconnect attempts reached. Giving up."
      );
  }
  async onmessage(t) {
    try {
      const n = JSON.parse(t);
      this._zustand?.logger.debug(
        `Recieved data of length: ${t.length} and data"`,
        n
      ), await this.getCommunicationManager().receive(n);
    } catch (n) {
      console.error("Websocketworker: onmessage JSON.parse error", n, t);
      return;
    }
  }
  get http_protocol() {
    return this.secure_url ? "https" : "http";
  }
  get secure_url() {
    return this._url.startsWith("wss");
  }
  get url_wo_protocol() {
    return this._url.substring(this.secure_url ? 6 : 5);
  }
  get http_url() {
    var t = this.http_protocol + "://" + this.url_wo_protocol;
    return t[t.length - 1] !== "/" && (t += "/"), t;
  }
  get_io_subscription_url({
    node_id: t,
    io_id: n,
    stream: r
  }) {
    let o = this.http_url + `node/${t}/io/${n}/value`;
    return r && (o += "/stream"), o;
  }
  async upload_file({
    files: t,
    onProgressCallback: n,
    root: r
  }) {
    const o = `${this.http_url}upload/`, a = new FormData(), s = Array.isArray(t) ? t : Array.from(t);
    for (const u of s) {
      const c = u.webkitRelativePath || u.name, f = r ? `${r}/${c}` : c;
      a.append("file", u, f);
    }
    try {
      return (await Lt.post(o, a, {
        headers: {
          "Content-Type": "multipart/form-data"
        },
        onUploadProgress: (c) => {
          n && n(c.loaded, c.total);
        }
      })).data.file;
    } catch {
      throw new Error("Failed to upload file");
    }
  }
  async handle_large_message_hint({ msg_id: t }) {
    const n = this.http_url + "message/" + t, o = await (await fetch(n, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*"
      }
    })).json();
    this.getCommunicationManager().receive(o);
  }
  onopen() {
    this._zustand?.logger.info("Websocket opened"), this.is_open = !0, this._zustand && this._zustand.auto_progress(), this.reconnectAttempts = 0, this.getSyncManager().stepwise_fullsync();
  }
  onclose() {
    this._zustand?.logger.info("Websocket closed"), super.onclose(), this._reconnect && (this._zustand?.logger.info("Websocket closed,reconnecting"), this.auto_reconnect());
  }
  on_ws_error() {
    this._zustand?.logger.warn("Websocket error"), this._websocket ? this._websocket.close() : this.auto_reconnect();
  }
  async send_large_message(t) {
    const n = `${this.http_url}message/`;
    await fetch(n, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: t
    });
  }
  async send(t) {
    if (!this._websocket || this._websocket.readyState !== WebSocket.OPEN) {
      this._zustand?.logger.warn("Websocket not connected");
      return;
    }
    const n = JSON.stringify(t);
    if (new Blob([n]).size > 1e6)
      return this._zustand?.logger.info("Data too large, sending via http"), await this.send_large_message(n);
    this._zustand?.logger.debug("Sending data", t), this._websocket.send(n);
  }
  async stop() {
    await super.stop(), this._reconnect = !1;
  }
  close() {
    this._websocket && this._websocket.close();
  }
  disconnect() {
    super.disconnect(), this._reconnect = !1, this._reconnect_timeout && (clearTimeout(this._reconnect_timeout), this._reconnect_timeout = void 0), this.close();
  }
  async reconnect() {
    if (await super.reconnect(), this._reconnect = !0, this._websocket && (this._zustand?.logger.info("Reconnecting"), (this._websocket.readyState === WebSocket.OPEN || this._websocket.readyState === WebSocket.CONNECTING) && (this._websocket.readyState === WebSocket.CONNECTING && await new Promise((t, n) => {
      if (this._websocket === null) return;
      let r = setTimeout(() => {
        n("Timeout@reconnect");
      }, 2e3);
      this._websocket.addEventListener(
        "open",
        () => {
          clearTimeout(r), t(null);
        },
        { once: !0 }
      ), this._websocket.readyState === WebSocket.OPEN && (clearTimeout(r), t(null));
    }), this._websocket.readyState === WebSocket.OPEN))) {
      this.getSyncManager().stepwise_fullsync();
      return;
    }
    this.connect();
  }
}
class xZ {
  constructor(t, n) {
    this.ws = null, this.reconnectAttempts = 0, this.maxReconnectAttempts = 999, this.initialTimeout = 200, this.maxTimeout = 2e3, this._wsuri = t, this.zustand = n, this.workers = {}, this.on_setWorker = (r) => {
      this.zustand.set_worker(r);
    }, this.connectionTimeout = setTimeout(() => {
      this.connect();
    }, 200);
  }
  get wsuri() {
    return this._wsuri;
  }
  get open() {
    return this.ws?.readyState === WebSocket.OPEN;
  }
  connect() {
    this.zustand.set_progress({
      progress: 0,
      message: "connecting to worker manager",
      status: "info",
      blocking: !0
    }), this.zustand.logger.info("Connecting to websocket:", this._wsuri), this.ws = new WebSocket(this._wsuri), this.ws.onopen = () => {
      this.onopen();
    }, this.ws.onclose = () => {
      this.onclose();
    }, this.ws.onerror = () => {
      this.on_ws_error();
    }, this.ws.onmessage = (t) => {
      typeof t.data == "string" ? this.onmessage(t.data) : console.error(
        "WorkerManager: onmessage event.data is not a string",
        typeof t.data
      );
    }, this.connectionTimeout = setTimeout(() => {
      this.ws?.readyState !== WebSocket.OPEN && this.on_ws_error();
    }, 5e3);
  }
  on_ws_error() {
    console.warn("Websocket error"), this.ws ? this.ws.close() : this.reconnect();
  }
  onopen() {
    this.connectionTimeout && (clearTimeout(this.connectionTimeout), this.connectionTimeout = void 0), this.zustand.auto_progress(), this.ws && this.ws.send("worker_status");
    const t = window.localStorage.getItem(
      "funcnodes__active_worker"
    );
    t && this.set_active(t);
  }
  onmessage(t) {
    try {
      let n = JSON.parse(t);
      if (n.type === "worker_status") {
        const r = {};
        for (let o of n.active)
          o.active = !0, r[o.uuid] = o;
        for (let o of n.inactive)
          o.active = !1, r[o.uuid] = o;
        this.zustand.workers.setState(r);
        return;
      } else if (n.type === "set_worker") {
        if (n.data.type === "WSWorker") {
          let r = "ws" + (n.data.ssl ? "s" : "") + "://" + n.data.host + ":" + n.data.port;
          this.setWorker(
            this.workers[n.data.uuid] || new D3({
              url: r,
              zustand: this.zustand,
              uuid: n.data.uuid,
              on_sync_complete: this.zustand.options.on_sync_complete
            })
          );
        } else
          this.zustand.logger.error("WorkerManager: unknown worker type", n);
        return;
      } else if (n.type === "progress") {
        this.zustand.set_progress(n);
        return;
      }
      this.zustand.logger.error("WorkerManager: unknown message", n);
    } catch (n) {
      console.error("WorkerManager: onmessage JSON.parse error", n, t);
      return;
    }
  }
  setWorker(t) {
    for (let n in this.workers)
      n !== t?.uuid && this.workers[n].disconnect();
    t !== void 0 && (this.workers[t.uuid] = t, t.reconnect()), t?.uuid && window.localStorage.setItem("funcnodes__active_worker", t?.uuid), this.zustand.worker !== void 0 && this.zustand.clear_all(), this.zustand.set_worker(t), this.on_setWorker(t);
  }
  async restart_worker(t) {
    this.ws?.send(JSON.stringify({ type: "restart_worker", workerid: t }));
  }
  calculateReconnectTimeout() {
    return Math.min(
      this.initialTimeout * Math.pow(2, this.reconnectAttempts),
      this.maxTimeout
    );
  }
  reconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      let t = this.calculateReconnectTimeout();
      this.zustand.logger.info(`Attempting to reconnect in ${t} ms`), setTimeout(() => {
        this.ws && this.ws.readyState === WebSocket.OPEN || (this.reconnectAttempts++, this.connect());
      }, t);
    } else
      this.zustand.logger.warn(
        "Maximum reconnect attempts reached. Giving up."
      );
  }
  onclose() {
    this.zustand.logger.warn("WorkerManager: onclose"), this.reconnect();
  }
  set_active(t) {
    this.ws && this.ws.send(JSON.stringify({ type: "set_active", workerid: t }));
  }
  new_worker({
    name: t,
    reference: n,
    copyLib: r,
    copyNS: o,
    in_venv: a
  }) {
    t || (t = void 0), r || (r = !1), o || (o = !1), n || (n = void 0, r = !1, o = !1), this.ws && this.ws.send(
      JSON.stringify({
        type: "new_worker",
        kwargs: {
          name: t,
          reference: n,
          copyLib: r,
          copyNS: o,
          in_venv: a
        }
      })
    );
  }
  remove() {
    for (let t in this.workers)
      this.workers[t].disconnect();
    this.connectionTimeout && (clearTimeout(this.connectionTimeout), this.connectionTimeout = void 0), this.ws && (this.ws.onclose = () => {
    }, this.ws.onerror = () => {
    }, this.ws.onmessage = () => {
    }, this.ws.onopen = () => {
    }, this.ws.close());
  }
}
const Tn = () => {
  const e = nt();
  return e.worker ? {
    ...e.worker.api,
    worker: e.worker
  } : {
    node: void 0,
    group: void 0,
    edge: void 0,
    hooks: void 0,
    lib: void 0,
    worker: e.worker
  };
}, wZ = {
  show: !0
}, _Z = {
  show: !0,
  showmenu: !0
}, SZ = {
  minimap: !0,
  static: !1,
  minZoom: 0.1,
  maxZoom: 5,
  allowFullScreen: !0,
  allowExpand: !0,
  showNodeSettings: !0
}, EZ = {
  id: "",
  // required
  debug: !1,
  useWorkerManager: !0,
  show_library: !0,
  header: _Z,
  flow: SZ,
  library: wZ
}, P3 = [
  "classic",
  "metal",
  "light",
  "solarized",
  "midnight",
  "forest",
  "scientific",
  "neon",
  "ocean",
  "sunset"
];
function Wt(e) {
  if (typeof e == "string" || typeof e == "number") return "" + e;
  let t = "";
  if (Array.isArray(e))
    for (let n = 0, r; n < e.length; n++)
      (r = Wt(e[n])) !== "" && (t += (t && " ") + r);
  else
    for (let n in e)
      e[n] && (t += (t && " ") + n);
  return t;
}
var CZ = { value: () => {
} };
function Am() {
  for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {
    if (!(r = arguments[e] + "") || r in n || /[\s.]/.test(r)) throw new Error("illegal type: " + r);
    n[r] = [];
  }
  return new Hh(n);
}
function Hh(e) {
  this._ = e;
}
function kZ(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var r = "", o = n.indexOf(".");
    if (o >= 0 && (r = n.slice(o + 1), n = n.slice(0, o)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
    return { type: n, name: r };
  });
}
Hh.prototype = Am.prototype = {
  constructor: Hh,
  on: function(e, t) {
    var n = this._, r = kZ(e + "", n), o, a = -1, s = r.length;
    if (arguments.length < 2) {
      for (; ++a < s; ) if ((o = (e = r[a]).type) && (o = TZ(n[o], e.name))) return o;
      return;
    }
    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
    for (; ++a < s; )
      if (o = (e = r[a]).type) n[o] = tA(n[o], e.name, t);
      else if (t == null) for (o in n) n[o] = tA(n[o], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t) e[n] = t[n].slice();
    return new Hh(e);
  },
  call: function(e, t) {
    if ((o = arguments.length - 2) > 0) for (var n = new Array(o), r = 0, o, a; r < o; ++r) n[r] = arguments[r + 2];
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (a = this._[e], r = 0, o = a.length; r < o; ++r) a[r].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (var r = this._[e], o = 0, a = r.length; o < a; ++o) r[o].value.apply(t, n);
  }
};
function TZ(e, t) {
  for (var n = 0, r = e.length, o; n < r; ++n)
    if ((o = e[n]).name === t)
      return o.value;
}
function tA(e, t, n) {
  for (var r = 0, o = e.length; r < o; ++r)
    if (e[r].name === t) {
      e[r] = CZ, e = e.slice(0, r).concat(e.slice(r + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var Ab = "http://www.w3.org/1999/xhtml";
const nA = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Ab,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function Rm(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), nA.hasOwnProperty(t) ? { space: nA[t], local: e } : e;
}
function AZ(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === Ab && t.documentElement.namespaceURI === Ab ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function RZ(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function j3(e) {
  var t = Rm(e);
  return (t.local ? RZ : AZ)(t);
}
function MZ() {
}
function vx(e) {
  return e == null ? MZ : function() {
    return this.querySelector(e);
  };
}
function OZ(e) {
  typeof e != "function" && (e = vx(e));
  for (var t = this._groups, n = t.length, r = new Array(n), o = 0; o < n; ++o)
    for (var a = t[o], s = a.length, u = r[o] = new Array(s), c, f, h = 0; h < s; ++h)
      (c = a[h]) && (f = e.call(c, c.__data__, h, a)) && ("__data__" in c && (f.__data__ = c.__data__), u[h] = f);
  return new lr(r, this._parents);
}
function NZ(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function DZ() {
  return [];
}
function I3(e) {
  return e == null ? DZ : function() {
    return this.querySelectorAll(e);
  };
}
function PZ(e) {
  return function() {
    return NZ(e.apply(this, arguments));
  };
}
function jZ(e) {
  typeof e == "function" ? e = PZ(e) : e = I3(e);
  for (var t = this._groups, n = t.length, r = [], o = [], a = 0; a < n; ++a)
    for (var s = t[a], u = s.length, c, f = 0; f < u; ++f)
      (c = s[f]) && (r.push(e.call(c, c.__data__, f, s)), o.push(c));
  return new lr(r, o);
}
function z3(e) {
  return function() {
    return this.matches(e);
  };
}
function L3(e) {
  return function(t) {
    return t.matches(e);
  };
}
var IZ = Array.prototype.find;
function zZ(e) {
  return function() {
    return IZ.call(this.children, e);
  };
}
function LZ() {
  return this.firstElementChild;
}
function FZ(e) {
  return this.select(e == null ? LZ : zZ(typeof e == "function" ? e : L3(e)));
}
var $Z = Array.prototype.filter;
function BZ() {
  return Array.from(this.children);
}
function HZ(e) {
  return function() {
    return $Z.call(this.children, e);
  };
}
function VZ(e) {
  return this.selectAll(e == null ? BZ : HZ(typeof e == "function" ? e : L3(e)));
}
function UZ(e) {
  typeof e != "function" && (e = z3(e));
  for (var t = this._groups, n = t.length, r = new Array(n), o = 0; o < n; ++o)
    for (var a = t[o], s = a.length, u = r[o] = [], c, f = 0; f < s; ++f)
      (c = a[f]) && e.call(c, c.__data__, f, a) && u.push(c);
  return new lr(r, this._parents);
}
function F3(e) {
  return new Array(e.length);
}
function qZ() {
  return new lr(this._enter || this._groups.map(F3), this._parents);
}
function gp(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
gp.prototype = {
  constructor: gp,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function GZ(e) {
  return function() {
    return e;
  };
}
function YZ(e, t, n, r, o, a) {
  for (var s = 0, u, c = t.length, f = a.length; s < f; ++s)
    (u = t[s]) ? (u.__data__ = a[s], r[s] = u) : n[s] = new gp(e, a[s]);
  for (; s < c; ++s)
    (u = t[s]) && (o[s] = u);
}
function WZ(e, t, n, r, o, a, s) {
  var u, c, f = /* @__PURE__ */ new Map(), h = t.length, p = a.length, g = new Array(h), y;
  for (u = 0; u < h; ++u)
    (c = t[u]) && (g[u] = y = s.call(c, c.__data__, u, t) + "", f.has(y) ? o[u] = c : f.set(y, c));
  for (u = 0; u < p; ++u)
    y = s.call(e, a[u], u, a) + "", (c = f.get(y)) ? (r[u] = c, c.__data__ = a[u], f.delete(y)) : n[u] = new gp(e, a[u]);
  for (u = 0; u < h; ++u)
    (c = t[u]) && f.get(g[u]) === c && (o[u] = c);
}
function XZ(e) {
  return e.__data__;
}
function KZ(e, t) {
  if (!arguments.length) return Array.from(this, XZ);
  var n = t ? WZ : YZ, r = this._parents, o = this._groups;
  typeof e != "function" && (e = GZ(e));
  for (var a = o.length, s = new Array(a), u = new Array(a), c = new Array(a), f = 0; f < a; ++f) {
    var h = r[f], p = o[f], g = p.length, y = ZZ(e.call(h, h && h.__data__, f, r)), w = y.length, v = u[f] = new Array(w), S = s[f] = new Array(w), E = c[f] = new Array(g);
    n(h, p, v, S, E, y, t);
    for (var T = 0, k = 0, A, M; T < w; ++T)
      if (A = v[T]) {
        for (T >= k && (k = T + 1); !(M = S[k]) && ++k < w; ) ;
        A._next = M || null;
      }
  }
  return s = new lr(s, r), s._enter = u, s._exit = c, s;
}
function ZZ(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function QZ() {
  return new lr(this._exit || this._groups.map(F3), this._parents);
}
function JZ(e, t, n) {
  var r = this.enter(), o = this, a = this.exit();
  return typeof e == "function" ? (r = e(r), r && (r = r.selection())) : r = r.append(e + ""), t != null && (o = t(o), o && (o = o.selection())), n == null ? a.remove() : n(a), r && o ? r.merge(o).order() : o;
}
function eQ(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, r = t._groups, o = n.length, a = r.length, s = Math.min(o, a), u = new Array(o), c = 0; c < s; ++c)
    for (var f = n[c], h = r[c], p = f.length, g = u[c] = new Array(p), y, w = 0; w < p; ++w)
      (y = f[w] || h[w]) && (g[w] = y);
  for (; c < o; ++c)
    u[c] = n[c];
  return new lr(u, this._parents);
}
function tQ() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var r = e[t], o = r.length - 1, a = r[o], s; --o >= 0; )
      (s = r[o]) && (a && s.compareDocumentPosition(a) ^ 4 && a.parentNode.insertBefore(s, a), a = s);
  return this;
}
function nQ(e) {
  e || (e = rQ);
  function t(p, g) {
    return p && g ? e(p.__data__, g.__data__) : !p - !g;
  }
  for (var n = this._groups, r = n.length, o = new Array(r), a = 0; a < r; ++a) {
    for (var s = n[a], u = s.length, c = o[a] = new Array(u), f, h = 0; h < u; ++h)
      (f = s[h]) && (c[h] = f);
    c.sort(t);
  }
  return new lr(o, this._parents).order();
}
function rQ(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function oQ() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function iQ() {
  return Array.from(this);
}
function aQ() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], o = 0, a = r.length; o < a; ++o) {
      var s = r[o];
      if (s) return s;
    }
  return null;
}
function sQ() {
  let e = 0;
  for (const t of this) ++e;
  return e;
}
function lQ() {
  return !this.node();
}
function uQ(e) {
  for (var t = this._groups, n = 0, r = t.length; n < r; ++n)
    for (var o = t[n], a = 0, s = o.length, u; a < s; ++a)
      (u = o[a]) && e.call(u, u.__data__, a, o);
  return this;
}
function cQ(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function fQ(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function dQ(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function hQ(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function pQ(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function mQ(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function gQ(e, t) {
  var n = Rm(e);
  if (arguments.length < 2) {
    var r = this.node();
    return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);
  }
  return this.each((t == null ? n.local ? fQ : cQ : typeof t == "function" ? n.local ? mQ : pQ : n.local ? hQ : dQ)(n, t));
}
function $3(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function yQ(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function vQ(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function bQ(e, t, n) {
  return function() {
    var r = t.apply(this, arguments);
    r == null ? this.style.removeProperty(e) : this.style.setProperty(e, r, n);
  };
}
function xQ(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? yQ : typeof t == "function" ? bQ : vQ)(e, t, n ?? "")) : Sl(this.node(), e);
}
function Sl(e, t) {
  return e.style.getPropertyValue(t) || $3(e).getComputedStyle(e, null).getPropertyValue(t);
}
function wQ(e) {
  return function() {
    delete this[e];
  };
}
function _Q(e, t) {
  return function() {
    this[e] = t;
  };
}
function SQ(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function EQ(e, t) {
  return arguments.length > 1 ? this.each((t == null ? wQ : typeof t == "function" ? SQ : _Q)(e, t)) : this.node()[e];
}
function B3(e) {
  return e.trim().split(/^|\s+/);
}
function bx(e) {
  return e.classList || new H3(e);
}
function H3(e) {
  this._node = e, this._names = B3(e.getAttribute("class") || "");
}
H3.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function V3(e, t) {
  for (var n = bx(e), r = -1, o = t.length; ++r < o; ) n.add(t[r]);
}
function U3(e, t) {
  for (var n = bx(e), r = -1, o = t.length; ++r < o; ) n.remove(t[r]);
}
function CQ(e) {
  return function() {
    V3(this, e);
  };
}
function kQ(e) {
  return function() {
    U3(this, e);
  };
}
function TQ(e, t) {
  return function() {
    (t.apply(this, arguments) ? V3 : U3)(this, e);
  };
}
function AQ(e, t) {
  var n = B3(e + "");
  if (arguments.length < 2) {
    for (var r = bx(this.node()), o = -1, a = n.length; ++o < a; ) if (!r.contains(n[o])) return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? TQ : t ? CQ : kQ)(n, t));
}
function RQ() {
  this.textContent = "";
}
function MQ(e) {
  return function() {
    this.textContent = e;
  };
}
function OQ(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function NQ(e) {
  return arguments.length ? this.each(e == null ? RQ : (typeof e == "function" ? OQ : MQ)(e)) : this.node().textContent;
}
function DQ() {
  this.innerHTML = "";
}
function PQ(e) {
  return function() {
    this.innerHTML = e;
  };
}
function jQ(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function IQ(e) {
  return arguments.length ? this.each(e == null ? DQ : (typeof e == "function" ? jQ : PQ)(e)) : this.node().innerHTML;
}
function zQ() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function LQ() {
  return this.each(zQ);
}
function FQ() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function $Q() {
  return this.each(FQ);
}
function BQ(e) {
  var t = typeof e == "function" ? e : j3(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function HQ() {
  return null;
}
function VQ(e, t) {
  var n = typeof e == "function" ? e : j3(e), r = t == null ? HQ : typeof t == "function" ? t : vx(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null);
  });
}
function UQ() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function qQ() {
  return this.each(UQ);
}
function GQ() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function YQ() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function WQ(e) {
  return this.select(e ? YQ : GQ);
}
function XQ(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function KQ(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function ZQ(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", r = t.indexOf(".");
    return r >= 0 && (n = t.slice(r + 1), t = t.slice(0, r)), { type: t, name: n };
  });
}
function QQ(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, r = -1, o = t.length, a; n < o; ++n)
        a = t[n], (!e.type || a.type === e.type) && a.name === e.name ? this.removeEventListener(a.type, a.listener, a.options) : t[++r] = a;
      ++r ? t.length = r : delete this.__on;
    }
  };
}
function JQ(e, t, n) {
  return function() {
    var r = this.__on, o, a = KQ(t);
    if (r) {
      for (var s = 0, u = r.length; s < u; ++s)
        if ((o = r[s]).type === e.type && o.name === e.name) {
          this.removeEventListener(o.type, o.listener, o.options), this.addEventListener(o.type, o.listener = a, o.options = n), o.value = t;
          return;
        }
    }
    this.addEventListener(e.type, a, n), o = { type: e.type, name: e.name, value: t, listener: a, options: n }, r ? r.push(o) : this.__on = [o];
  };
}
function eJ(e, t, n) {
  var r = ZQ(e + ""), o, a = r.length, s;
  if (arguments.length < 2) {
    var u = this.node().__on;
    if (u) {
      for (var c = 0, f = u.length, h; c < f; ++c)
        for (o = 0, h = u[c]; o < a; ++o)
          if ((s = r[o]).type === h.type && s.name === h.name)
            return h.value;
    }
    return;
  }
  for (u = t ? JQ : QQ, o = 0; o < a; ++o) this.each(u(r[o], t, n));
  return this;
}
function q3(e, t, n) {
  var r = $3(e), o = r.CustomEvent;
  typeof o == "function" ? o = new o(t, n) : (o = r.document.createEvent("Event"), n ? (o.initEvent(t, n.bubbles, n.cancelable), o.detail = n.detail) : o.initEvent(t, !1, !1)), e.dispatchEvent(o);
}
function tJ(e, t) {
  return function() {
    return q3(this, e, t);
  };
}
function nJ(e, t) {
  return function() {
    return q3(this, e, t.apply(this, arguments));
  };
}
function rJ(e, t) {
  return this.each((typeof t == "function" ? nJ : tJ)(e, t));
}
function* oJ() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], o = 0, a = r.length, s; o < a; ++o)
      (s = r[o]) && (yield s);
}
var G3 = [null];
function lr(e, t) {
  this._groups = e, this._parents = t;
}
function mf() {
  return new lr([[document.documentElement]], G3);
}
function iJ() {
  return this;
}
lr.prototype = mf.prototype = {
  constructor: lr,
  select: OZ,
  selectAll: jZ,
  selectChild: FZ,
  selectChildren: VZ,
  filter: UZ,
  data: KZ,
  enter: qZ,
  exit: QZ,
  join: JZ,
  merge: eQ,
  selection: iJ,
  order: tQ,
  sort: nQ,
  call: oQ,
  nodes: iQ,
  node: aQ,
  size: sQ,
  empty: lQ,
  each: uQ,
  attr: gQ,
  style: xQ,
  property: EQ,
  classed: AQ,
  text: NQ,
  html: IQ,
  raise: LQ,
  lower: $Q,
  append: BQ,
  insert: VQ,
  remove: qQ,
  clone: WQ,
  datum: XQ,
  on: eJ,
  dispatch: rJ,
  [Symbol.iterator]: oJ
};
function rr(e) {
  return typeof e == "string" ? new lr([[document.querySelector(e)]], [document.documentElement]) : new lr([[e]], G3);
}
function aJ(e) {
  let t;
  for (; t = e.sourceEvent; ) e = t;
  return e;
}
function Dr(e, t) {
  if (e = aJ(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var r = n.createSVGPoint();
      return r.x = e.clientX, r.y = e.clientY, r = r.matrixTransform(t.getScreenCTM().inverse()), [r.x, r.y];
    }
    if (t.getBoundingClientRect) {
      var o = t.getBoundingClientRect();
      return [e.clientX - o.left - t.clientLeft, e.clientY - o.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
const sJ = { passive: !1 }, Lc = { capture: !0, passive: !1 };
function uv(e) {
  e.stopImmediatePropagation();
}
function hl(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function Y3(e) {
  var t = e.document.documentElement, n = rr(e).on("dragstart.drag", hl, Lc);
  "onselectstart" in t ? n.on("selectstart.drag", hl, Lc) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function W3(e, t) {
  var n = e.document.documentElement, r = rr(e).on("dragstart.drag", null);
  t && (r.on("click.drag", hl, Lc), setTimeout(function() {
    r.on("click.drag", null);
  }, 0)), "onselectstart" in n ? r.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
}
const hh = (e) => () => e;
function Rb(e, {
  sourceEvent: t,
  subject: n,
  target: r,
  identifier: o,
  active: a,
  x: s,
  y: u,
  dx: c,
  dy: f,
  dispatch: h
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    subject: { value: n, enumerable: !0, configurable: !0 },
    target: { value: r, enumerable: !0, configurable: !0 },
    identifier: { value: o, enumerable: !0, configurable: !0 },
    active: { value: a, enumerable: !0, configurable: !0 },
    x: { value: s, enumerable: !0, configurable: !0 },
    y: { value: u, enumerable: !0, configurable: !0 },
    dx: { value: c, enumerable: !0, configurable: !0 },
    dy: { value: f, enumerable: !0, configurable: !0 },
    _: { value: h }
  });
}
Rb.prototype.on = function() {
  var e = this._.on.apply(this._, arguments);
  return e === this._ ? this : e;
};
function lJ(e) {
  return !e.ctrlKey && !e.button;
}
function uJ() {
  return this.parentNode;
}
function cJ(e, t) {
  return t ?? { x: e.x, y: e.y };
}
function fJ() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function X3() {
  var e = lJ, t = uJ, n = cJ, r = fJ, o = {}, a = Am("start", "drag", "end"), s = 0, u, c, f, h, p = 0;
  function g(A) {
    A.on("mousedown.drag", y).filter(r).on("touchstart.drag", S).on("touchmove.drag", E, sJ).on("touchend.drag touchcancel.drag", T).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function y(A, M) {
    if (!(h || !e.call(this, A, M))) {
      var N = k(this, t.call(this, A, M), A, M, "mouse");
      N && (rr(A.view).on("mousemove.drag", w, Lc).on("mouseup.drag", v, Lc), Y3(A.view), uv(A), f = !1, u = A.clientX, c = A.clientY, N("start", A));
    }
  }
  function w(A) {
    if (hl(A), !f) {
      var M = A.clientX - u, N = A.clientY - c;
      f = M * M + N * N > p;
    }
    o.mouse("drag", A);
  }
  function v(A) {
    rr(A.view).on("mousemove.drag mouseup.drag", null), W3(A.view, f), hl(A), o.mouse("end", A);
  }
  function S(A, M) {
    if (e.call(this, A, M)) {
      var N = A.changedTouches, P = t.call(this, A, M), z = N.length, B, R;
      for (B = 0; B < z; ++B)
        (R = k(this, P, A, M, N[B].identifier, N[B])) && (uv(A), R("start", A, N[B]));
    }
  }
  function E(A) {
    var M = A.changedTouches, N = M.length, P, z;
    for (P = 0; P < N; ++P)
      (z = o[M[P].identifier]) && (hl(A), z("drag", A, M[P]));
  }
  function T(A) {
    var M = A.changedTouches, N = M.length, P, z;
    for (h && clearTimeout(h), h = setTimeout(function() {
      h = null;
    }, 500), P = 0; P < N; ++P)
      (z = o[M[P].identifier]) && (uv(A), z("end", A, M[P]));
  }
  function k(A, M, N, P, z, B) {
    var R = a.copy(), F = Dr(B || N, M), U, W, j;
    if ((j = n.call(A, new Rb("beforestart", {
      sourceEvent: N,
      target: g,
      identifier: z,
      active: s,
      x: F[0],
      y: F[1],
      dx: 0,
      dy: 0,
      dispatch: R
    }), P)) != null)
      return U = j.x - F[0] || 0, W = j.y - F[1] || 0, function V(I, H, q) {
        var G = F, O;
        switch (I) {
          case "start":
            o[z] = V, O = s++;
            break;
          case "end":
            delete o[z], --s;
          // falls through
          case "drag":
            F = Dr(q || H, M), O = s;
            break;
        }
        R.call(
          I,
          A,
          new Rb(I, {
            sourceEvent: H,
            subject: j,
            target: g,
            identifier: z,
            active: O,
            x: F[0] + U,
            y: F[1] + W,
            dx: F[0] - G[0],
            dy: F[1] - G[1],
            dispatch: R
          }),
          P
        );
      };
  }
  return g.filter = function(A) {
    return arguments.length ? (e = typeof A == "function" ? A : hh(!!A), g) : e;
  }, g.container = function(A) {
    return arguments.length ? (t = typeof A == "function" ? A : hh(A), g) : t;
  }, g.subject = function(A) {
    return arguments.length ? (n = typeof A == "function" ? A : hh(A), g) : n;
  }, g.touchable = function(A) {
    return arguments.length ? (r = typeof A == "function" ? A : hh(!!A), g) : r;
  }, g.on = function() {
    var A = a.on.apply(a, arguments);
    return A === a ? g : A;
  }, g.clickDistance = function(A) {
    return arguments.length ? (p = (A = +A) * A, g) : Math.sqrt(p);
  }, g;
}
function xx(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function K3(e, t) {
  var n = Object.create(e.prototype);
  for (var r in t) n[r] = t[r];
  return n;
}
function gf() {
}
var Fc = 0.7, yp = 1 / Fc, pl = "\\s*([+-]?\\d+)\\s*", $c = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", go = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", dJ = /^#([0-9a-f]{3,8})$/, hJ = new RegExp(`^rgb\\(${pl},${pl},${pl}\\)$`), pJ = new RegExp(`^rgb\\(${go},${go},${go}\\)$`), mJ = new RegExp(`^rgba\\(${pl},${pl},${pl},${$c}\\)$`), gJ = new RegExp(`^rgba\\(${go},${go},${go},${$c}\\)$`), yJ = new RegExp(`^hsl\\(${$c},${go},${go}\\)$`), vJ = new RegExp(`^hsla\\(${$c},${go},${go},${$c}\\)$`), rA = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
xx(gf, Ka, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: oA,
  // Deprecated! Use color.formatHex.
  formatHex: oA,
  formatHex8: bJ,
  formatHsl: xJ,
  formatRgb: iA,
  toString: iA
});
function oA() {
  return this.rgb().formatHex();
}
function bJ() {
  return this.rgb().formatHex8();
}
function xJ() {
  return Z3(this).formatHsl();
}
function iA() {
  return this.rgb().formatRgb();
}
function Ka(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = dJ.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? aA(t) : n === 3 ? new Ln(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? ph(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? ph(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = hJ.exec(e)) ? new Ln(t[1], t[2], t[3], 1) : (t = pJ.exec(e)) ? new Ln(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = mJ.exec(e)) ? ph(t[1], t[2], t[3], t[4]) : (t = gJ.exec(e)) ? ph(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = yJ.exec(e)) ? uA(t[1], t[2] / 100, t[3] / 100, 1) : (t = vJ.exec(e)) ? uA(t[1], t[2] / 100, t[3] / 100, t[4]) : rA.hasOwnProperty(e) ? aA(rA[e]) : e === "transparent" ? new Ln(NaN, NaN, NaN, 0) : null;
}
function aA(e) {
  return new Ln(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function ph(e, t, n, r) {
  return r <= 0 && (e = t = n = NaN), new Ln(e, t, n, r);
}
function wJ(e) {
  return e instanceof gf || (e = Ka(e)), e ? (e = e.rgb(), new Ln(e.r, e.g, e.b, e.opacity)) : new Ln();
}
function Mb(e, t, n, r) {
  return arguments.length === 1 ? wJ(e) : new Ln(e, t, n, r ?? 1);
}
function Ln(e, t, n, r) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;
}
xx(Ln, Mb, K3(gf, {
  brighter(e) {
    return e = e == null ? yp : Math.pow(yp, e), new Ln(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Fc : Math.pow(Fc, e), new Ln(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Ln($a(this.r), $a(this.g), $a(this.b), vp(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: sA,
  // Deprecated! Use color.formatHex.
  formatHex: sA,
  formatHex8: _J,
  formatRgb: lA,
  toString: lA
}));
function sA() {
  return `#${za(this.r)}${za(this.g)}${za(this.b)}`;
}
function _J() {
  return `#${za(this.r)}${za(this.g)}${za(this.b)}${za((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function lA() {
  const e = vp(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${$a(this.r)}, ${$a(this.g)}, ${$a(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function vp(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function $a(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function za(e) {
  return e = $a(e), (e < 16 ? "0" : "") + e.toString(16);
}
function uA(e, t, n, r) {
  return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new Pr(e, t, n, r);
}
function Z3(e) {
  if (e instanceof Pr) return new Pr(e.h, e.s, e.l, e.opacity);
  if (e instanceof gf || (e = Ka(e)), !e) return new Pr();
  if (e instanceof Pr) return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, r = e.b / 255, o = Math.min(t, n, r), a = Math.max(t, n, r), s = NaN, u = a - o, c = (a + o) / 2;
  return u ? (t === a ? s = (n - r) / u + (n < r) * 6 : n === a ? s = (r - t) / u + 2 : s = (t - n) / u + 4, u /= c < 0.5 ? a + o : 2 - a - o, s *= 60) : u = c > 0 && c < 1 ? 0 : s, new Pr(s, u, c, e.opacity);
}
function SJ(e, t, n, r) {
  return arguments.length === 1 ? Z3(e) : new Pr(e, t, n, r ?? 1);
}
function Pr(e, t, n, r) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
}
xx(Pr, SJ, K3(gf, {
  brighter(e) {
    return e = e == null ? yp : Math.pow(yp, e), new Pr(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Fc : Math.pow(Fc, e), new Pr(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * t, o = 2 * n - r;
    return new Ln(
      cv(e >= 240 ? e - 240 : e + 120, o, r),
      cv(e, o, r),
      cv(e < 120 ? e + 240 : e - 120, o, r),
      this.opacity
    );
  },
  clamp() {
    return new Pr(cA(this.h), mh(this.s), mh(this.l), vp(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = vp(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${cA(this.h)}, ${mh(this.s) * 100}%, ${mh(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function cA(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function mh(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function cv(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const wx = (e) => () => e;
function EJ(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function CJ(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(r) {
    return Math.pow(e + r * t, n);
  };
}
function kJ(e) {
  return (e = +e) == 1 ? Q3 : function(t, n) {
    return n - t ? CJ(t, n, e) : wx(isNaN(t) ? n : t);
  };
}
function Q3(e, t) {
  var n = t - e;
  return n ? EJ(e, n) : wx(isNaN(e) ? t : e);
}
const bp = function e(t) {
  var n = kJ(t);
  function r(o, a) {
    var s = n((o = Mb(o)).r, (a = Mb(a)).r), u = n(o.g, a.g), c = n(o.b, a.b), f = Q3(o.opacity, a.opacity);
    return function(h) {
      return o.r = s(h), o.g = u(h), o.b = c(h), o.opacity = f(h), o + "";
    };
  }
  return r.gamma = e, r;
}(1);
function TJ(e, t) {
  t || (t = []);
  var n = e ? Math.min(t.length, e.length) : 0, r = t.slice(), o;
  return function(a) {
    for (o = 0; o < n; ++o) r[o] = e[o] * (1 - a) + t[o] * a;
    return r;
  };
}
function AJ(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function RJ(e, t) {
  var n = t ? t.length : 0, r = e ? Math.min(n, e.length) : 0, o = new Array(r), a = new Array(n), s;
  for (s = 0; s < r; ++s) o[s] = bc(e[s], t[s]);
  for (; s < n; ++s) a[s] = t[s];
  return function(u) {
    for (s = 0; s < r; ++s) a[s] = o[s](u);
    return a;
  };
}
function MJ(e, t) {
  var n = /* @__PURE__ */ new Date();
  return e = +e, t = +t, function(r) {
    return n.setTime(e * (1 - r) + t * r), n;
  };
}
function ao(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
function OJ(e, t) {
  var n = {}, r = {}, o;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (o in t)
    o in e ? n[o] = bc(e[o], t[o]) : r[o] = t[o];
  return function(a) {
    for (o in n) r[o] = n[o](a);
    return r;
  };
}
var Ob = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, fv = new RegExp(Ob.source, "g");
function NJ(e) {
  return function() {
    return e;
  };
}
function DJ(e) {
  return function(t) {
    return e(t) + "";
  };
}
function J3(e, t) {
  var n = Ob.lastIndex = fv.lastIndex = 0, r, o, a, s = -1, u = [], c = [];
  for (e = e + "", t = t + ""; (r = Ob.exec(e)) && (o = fv.exec(t)); )
    (a = o.index) > n && (a = t.slice(n, a), u[s] ? u[s] += a : u[++s] = a), (r = r[0]) === (o = o[0]) ? u[s] ? u[s] += o : u[++s] = o : (u[++s] = null, c.push({ i: s, x: ao(r, o) })), n = fv.lastIndex;
  return n < t.length && (a = t.slice(n), u[s] ? u[s] += a : u[++s] = a), u.length < 2 ? c[0] ? DJ(c[0].x) : NJ(t) : (t = c.length, function(f) {
    for (var h = 0, p; h < t; ++h) u[(p = c[h]).i] = p.x(f);
    return u.join("");
  });
}
function bc(e, t) {
  var n = typeof t, r;
  return t == null || n === "boolean" ? wx(t) : (n === "number" ? ao : n === "string" ? (r = Ka(t)) ? (t = r, bp) : J3 : t instanceof Ka ? bp : t instanceof Date ? MJ : AJ(t) ? TJ : Array.isArray(t) ? RJ : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? OJ : ao)(e, t);
}
var fA = 180 / Math.PI, Nb = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function e5(e, t, n, r, o, a) {
  var s, u, c;
  return (s = Math.sqrt(e * e + t * t)) && (e /= s, t /= s), (c = e * n + t * r) && (n -= e * c, r -= t * c), (u = Math.sqrt(n * n + r * r)) && (n /= u, r /= u, c /= u), e * r < t * n && (e = -e, t = -t, c = -c, s = -s), {
    translateX: o,
    translateY: a,
    rotate: Math.atan2(t, e) * fA,
    skewX: Math.atan(c) * fA,
    scaleX: s,
    scaleY: u
  };
}
var gh;
function PJ(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? Nb : e5(t.a, t.b, t.c, t.d, t.e, t.f);
}
function jJ(e) {
  return e == null || (gh || (gh = document.createElementNS("http://www.w3.org/2000/svg", "g")), gh.setAttribute("transform", e), !(e = gh.transform.baseVal.consolidate())) ? Nb : (e = e.matrix, e5(e.a, e.b, e.c, e.d, e.e, e.f));
}
function t5(e, t, n, r) {
  function o(f) {
    return f.length ? f.pop() + " " : "";
  }
  function a(f, h, p, g, y, w) {
    if (f !== p || h !== g) {
      var v = y.push("translate(", null, t, null, n);
      w.push({ i: v - 4, x: ao(f, p) }, { i: v - 2, x: ao(h, g) });
    } else (p || g) && y.push("translate(" + p + t + g + n);
  }
  function s(f, h, p, g) {
    f !== h ? (f - h > 180 ? h += 360 : h - f > 180 && (f += 360), g.push({ i: p.push(o(p) + "rotate(", null, r) - 2, x: ao(f, h) })) : h && p.push(o(p) + "rotate(" + h + r);
  }
  function u(f, h, p, g) {
    f !== h ? g.push({ i: p.push(o(p) + "skewX(", null, r) - 2, x: ao(f, h) }) : h && p.push(o(p) + "skewX(" + h + r);
  }
  function c(f, h, p, g, y, w) {
    if (f !== p || h !== g) {
      var v = y.push(o(y) + "scale(", null, ",", null, ")");
      w.push({ i: v - 4, x: ao(f, p) }, { i: v - 2, x: ao(h, g) });
    } else (p !== 1 || g !== 1) && y.push(o(y) + "scale(" + p + "," + g + ")");
  }
  return function(f, h) {
    var p = [], g = [];
    return f = e(f), h = e(h), a(f.translateX, f.translateY, h.translateX, h.translateY, p, g), s(f.rotate, h.rotate, p, g), u(f.skewX, h.skewX, p, g), c(f.scaleX, f.scaleY, h.scaleX, h.scaleY, p, g), f = h = null, function(y) {
      for (var w = -1, v = g.length, S; ++w < v; ) p[(S = g[w]).i] = S.x(y);
      return p.join("");
    };
  };
}
var IJ = t5(PJ, "px, ", "px)", "deg)"), zJ = t5(jJ, ", ", ")", ")"), LJ = 1e-12;
function dA(e) {
  return ((e = Math.exp(e)) + 1 / e) / 2;
}
function FJ(e) {
  return ((e = Math.exp(e)) - 1 / e) / 2;
}
function $J(e) {
  return ((e = Math.exp(2 * e)) - 1) / (e + 1);
}
const Vh = function e(t, n, r) {
  function o(a, s) {
    var u = a[0], c = a[1], f = a[2], h = s[0], p = s[1], g = s[2], y = h - u, w = p - c, v = y * y + w * w, S, E;
    if (v < LJ)
      E = Math.log(g / f) / t, S = function(P) {
        return [
          u + P * y,
          c + P * w,
          f * Math.exp(t * P * E)
        ];
      };
    else {
      var T = Math.sqrt(v), k = (g * g - f * f + r * v) / (2 * f * n * T), A = (g * g - f * f - r * v) / (2 * g * n * T), M = Math.log(Math.sqrt(k * k + 1) - k), N = Math.log(Math.sqrt(A * A + 1) - A);
      E = (N - M) / t, S = function(P) {
        var z = P * E, B = dA(M), R = f / (n * T) * (B * $J(t * z + M) - FJ(M));
        return [
          u + R * y,
          c + R * w,
          f * B / dA(t * z + M)
        ];
      };
    }
    return S.duration = E * 1e3 * t / Math.SQRT2, S;
  }
  return o.rho = function(a) {
    var s = Math.max(1e-3, +a), u = s * s, c = u * u;
    return e(s, u, c);
  }, o;
}(Math.SQRT2, 2, 4);
var El = 0, hc = 0, rc = 0, n5 = 1e3, xp, pc, wp = 0, Za = 0, Mm = 0, Bc = typeof performance == "object" && performance.now ? performance : Date, r5 = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function _x() {
  return Za || (r5(BJ), Za = Bc.now() + Mm);
}
function BJ() {
  Za = 0;
}
function _p() {
  this._call = this._time = this._next = null;
}
_p.prototype = o5.prototype = {
  constructor: _p,
  restart: function(e, t, n) {
    if (typeof e != "function") throw new TypeError("callback is not a function");
    n = (n == null ? _x() : +n) + (t == null ? 0 : +t), !this._next && pc !== this && (pc ? pc._next = this : xp = this, pc = this), this._call = e, this._time = n, Db();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, Db());
  }
};
function o5(e, t, n) {
  var r = new _p();
  return r.restart(e, t, n), r;
}
function HJ() {
  _x(), ++El;
  for (var e = xp, t; e; )
    (t = Za - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --El;
}
function hA() {
  Za = (wp = Bc.now()) + Mm, El = hc = 0;
  try {
    HJ();
  } finally {
    El = 0, UJ(), Za = 0;
  }
}
function VJ() {
  var e = Bc.now(), t = e - wp;
  t > n5 && (Mm -= t, wp = e);
}
function UJ() {
  for (var e, t = xp, n, r = 1 / 0; t; )
    t._call ? (r > t._time && (r = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : xp = n);
  pc = e, Db(r);
}
function Db(e) {
  if (!El) {
    hc && (hc = clearTimeout(hc));
    var t = e - Za;
    t > 24 ? (e < 1 / 0 && (hc = setTimeout(hA, e - Bc.now() - Mm)), rc && (rc = clearInterval(rc))) : (rc || (wp = Bc.now(), rc = setInterval(VJ, n5)), El = 1, r5(hA));
  }
}
function pA(e, t, n) {
  var r = new _p();
  return t = t == null ? 0 : +t, r.restart((o) => {
    r.stop(), e(o + t);
  }, t, n), r;
}
var qJ = Am("start", "end", "cancel", "interrupt"), GJ = [], i5 = 0, mA = 1, Pb = 2, Uh = 3, gA = 4, jb = 5, qh = 6;
function Om(e, t, n, r, o, a) {
  var s = e.__transition;
  if (!s) e.__transition = {};
  else if (n in s) return;
  YJ(e, n, {
    name: t,
    index: r,
    // For context during callback.
    group: o,
    // For context during callback.
    on: qJ,
    tween: GJ,
    time: a.time,
    delay: a.delay,
    duration: a.duration,
    ease: a.ease,
    timer: null,
    state: i5
  });
}
function Sx(e, t) {
  var n = Ur(e, t);
  if (n.state > i5) throw new Error("too late; already scheduled");
  return n;
}
function Eo(e, t) {
  var n = Ur(e, t);
  if (n.state > Uh) throw new Error("too late; already running");
  return n;
}
function Ur(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t])) throw new Error("transition not found");
  return n;
}
function YJ(e, t, n) {
  var r = e.__transition, o;
  r[t] = n, n.timer = o5(a, 0, n.time);
  function a(f) {
    n.state = mA, n.timer.restart(s, n.delay, n.time), n.delay <= f && s(f - n.delay);
  }
  function s(f) {
    var h, p, g, y;
    if (n.state !== mA) return c();
    for (h in r)
      if (y = r[h], y.name === n.name) {
        if (y.state === Uh) return pA(s);
        y.state === gA ? (y.state = qh, y.timer.stop(), y.on.call("interrupt", e, e.__data__, y.index, y.group), delete r[h]) : +h < t && (y.state = qh, y.timer.stop(), y.on.call("cancel", e, e.__data__, y.index, y.group), delete r[h]);
      }
    if (pA(function() {
      n.state === Uh && (n.state = gA, n.timer.restart(u, n.delay, n.time), u(f));
    }), n.state = Pb, n.on.call("start", e, e.__data__, n.index, n.group), n.state === Pb) {
      for (n.state = Uh, o = new Array(g = n.tween.length), h = 0, p = -1; h < g; ++h)
        (y = n.tween[h].value.call(e, e.__data__, n.index, n.group)) && (o[++p] = y);
      o.length = p + 1;
    }
  }
  function u(f) {
    for (var h = f < n.duration ? n.ease.call(null, f / n.duration) : (n.timer.restart(c), n.state = jb, 1), p = -1, g = o.length; ++p < g; )
      o[p].call(e, h);
    n.state === jb && (n.on.call("end", e, e.__data__, n.index, n.group), c());
  }
  function c() {
    n.state = qh, n.timer.stop(), delete r[t];
    for (var f in r) return;
    delete e.__transition;
  }
}
function Gh(e, t) {
  var n = e.__transition, r, o, a = !0, s;
  if (n) {
    t = t == null ? null : t + "";
    for (s in n) {
      if ((r = n[s]).name !== t) {
        a = !1;
        continue;
      }
      o = r.state > Pb && r.state < jb, r.state = qh, r.timer.stop(), r.on.call(o ? "interrupt" : "cancel", e, e.__data__, r.index, r.group), delete n[s];
    }
    a && delete e.__transition;
  }
}
function WJ(e) {
  return this.each(function() {
    Gh(this, e);
  });
}
function XJ(e, t) {
  var n, r;
  return function() {
    var o = Eo(this, e), a = o.tween;
    if (a !== n) {
      r = n = a;
      for (var s = 0, u = r.length; s < u; ++s)
        if (r[s].name === t) {
          r = r.slice(), r.splice(s, 1);
          break;
        }
    }
    o.tween = r;
  };
}
function KJ(e, t, n) {
  var r, o;
  if (typeof n != "function") throw new Error();
  return function() {
    var a = Eo(this, e), s = a.tween;
    if (s !== r) {
      o = (r = s).slice();
      for (var u = { name: t, value: n }, c = 0, f = o.length; c < f; ++c)
        if (o[c].name === t) {
          o[c] = u;
          break;
        }
      c === f && o.push(u);
    }
    a.tween = o;
  };
}
function ZJ(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var r = Ur(this.node(), n).tween, o = 0, a = r.length, s; o < a; ++o)
      if ((s = r[o]).name === e)
        return s.value;
    return null;
  }
  return this.each((t == null ? XJ : KJ)(n, e, t));
}
function Ex(e, t, n) {
  var r = e._id;
  return e.each(function() {
    var o = Eo(this, r);
    (o.value || (o.value = {}))[t] = n.apply(this, arguments);
  }), function(o) {
    return Ur(o, r).value[t];
  };
}
function a5(e, t) {
  var n;
  return (typeof t == "number" ? ao : t instanceof Ka ? bp : (n = Ka(t)) ? (t = n, bp) : J3)(e, t);
}
function QJ(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function JJ(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function eee(e, t, n) {
  var r, o = n + "", a;
  return function() {
    var s = this.getAttribute(e);
    return s === o ? null : s === r ? a : a = t(r = s, n);
  };
}
function tee(e, t, n) {
  var r, o = n + "", a;
  return function() {
    var s = this.getAttributeNS(e.space, e.local);
    return s === o ? null : s === r ? a : a = t(r = s, n);
  };
}
function nee(e, t, n) {
  var r, o, a;
  return function() {
    var s, u = n(this), c;
    return u == null ? void this.removeAttribute(e) : (s = this.getAttribute(e), c = u + "", s === c ? null : s === r && c === o ? a : (o = c, a = t(r = s, u)));
  };
}
function ree(e, t, n) {
  var r, o, a;
  return function() {
    var s, u = n(this), c;
    return u == null ? void this.removeAttributeNS(e.space, e.local) : (s = this.getAttributeNS(e.space, e.local), c = u + "", s === c ? null : s === r && c === o ? a : (o = c, a = t(r = s, u)));
  };
}
function oee(e, t) {
  var n = Rm(e), r = n === "transform" ? zJ : a5;
  return this.attrTween(e, typeof t == "function" ? (n.local ? ree : nee)(n, r, Ex(this, "attr." + e, t)) : t == null ? (n.local ? JJ : QJ)(n) : (n.local ? tee : eee)(n, r, t));
}
function iee(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function aee(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function see(e, t) {
  var n, r;
  function o() {
    var a = t.apply(this, arguments);
    return a !== r && (n = (r = a) && aee(e, a)), n;
  }
  return o._value = t, o;
}
function lee(e, t) {
  var n, r;
  function o() {
    var a = t.apply(this, arguments);
    return a !== r && (n = (r = a) && iee(e, a)), n;
  }
  return o._value = t, o;
}
function uee(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (t == null) return this.tween(n, null);
  if (typeof t != "function") throw new Error();
  var r = Rm(e);
  return this.tween(n, (r.local ? see : lee)(r, t));
}
function cee(e, t) {
  return function() {
    Sx(this, e).delay = +t.apply(this, arguments);
  };
}
function fee(e, t) {
  return t = +t, function() {
    Sx(this, e).delay = t;
  };
}
function dee(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? cee : fee)(t, e)) : Ur(this.node(), t).delay;
}
function hee(e, t) {
  return function() {
    Eo(this, e).duration = +t.apply(this, arguments);
  };
}
function pee(e, t) {
  return t = +t, function() {
    Eo(this, e).duration = t;
  };
}
function mee(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? hee : pee)(t, e)) : Ur(this.node(), t).duration;
}
function gee(e, t) {
  if (typeof t != "function") throw new Error();
  return function() {
    Eo(this, e).ease = t;
  };
}
function yee(e) {
  var t = this._id;
  return arguments.length ? this.each(gee(t, e)) : Ur(this.node(), t).ease;
}
function vee(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function") throw new Error();
    Eo(this, e).ease = n;
  };
}
function bee(e) {
  if (typeof e != "function") throw new Error();
  return this.each(vee(this._id, e));
}
function xee(e) {
  typeof e != "function" && (e = z3(e));
  for (var t = this._groups, n = t.length, r = new Array(n), o = 0; o < n; ++o)
    for (var a = t[o], s = a.length, u = r[o] = [], c, f = 0; f < s; ++f)
      (c = a[f]) && e.call(c, c.__data__, f, a) && u.push(c);
  return new si(r, this._parents, this._name, this._id);
}
function wee(e) {
  if (e._id !== this._id) throw new Error();
  for (var t = this._groups, n = e._groups, r = t.length, o = n.length, a = Math.min(r, o), s = new Array(r), u = 0; u < a; ++u)
    for (var c = t[u], f = n[u], h = c.length, p = s[u] = new Array(h), g, y = 0; y < h; ++y)
      (g = c[y] || f[y]) && (p[y] = g);
  for (; u < r; ++u)
    s[u] = t[u];
  return new si(s, this._parents, this._name, this._id);
}
function _ee(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function See(e, t, n) {
  var r, o, a = _ee(t) ? Sx : Eo;
  return function() {
    var s = a(this, e), u = s.on;
    u !== r && (o = (r = u).copy()).on(t, n), s.on = o;
  };
}
function Eee(e, t) {
  var n = this._id;
  return arguments.length < 2 ? Ur(this.node(), n).on.on(e) : this.each(See(n, e, t));
}
function Cee(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition) if (+n !== e) return;
    t && t.removeChild(this);
  };
}
function kee() {
  return this.on("end.remove", Cee(this._id));
}
function Tee(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = vx(e));
  for (var r = this._groups, o = r.length, a = new Array(o), s = 0; s < o; ++s)
    for (var u = r[s], c = u.length, f = a[s] = new Array(c), h, p, g = 0; g < c; ++g)
      (h = u[g]) && (p = e.call(h, h.__data__, g, u)) && ("__data__" in h && (p.__data__ = h.__data__), f[g] = p, Om(f[g], t, n, g, f, Ur(h, n)));
  return new si(a, this._parents, t, n);
}
function Aee(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = I3(e));
  for (var r = this._groups, o = r.length, a = [], s = [], u = 0; u < o; ++u)
    for (var c = r[u], f = c.length, h, p = 0; p < f; ++p)
      if (h = c[p]) {
        for (var g = e.call(h, h.__data__, p, c), y, w = Ur(h, n), v = 0, S = g.length; v < S; ++v)
          (y = g[v]) && Om(y, t, n, v, g, w);
        a.push(g), s.push(h);
      }
  return new si(a, s, t, n);
}
var Ree = mf.prototype.constructor;
function Mee() {
  return new Ree(this._groups, this._parents);
}
function Oee(e, t) {
  var n, r, o;
  return function() {
    var a = Sl(this, e), s = (this.style.removeProperty(e), Sl(this, e));
    return a === s ? null : a === n && s === r ? o : o = t(n = a, r = s);
  };
}
function s5(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function Nee(e, t, n) {
  var r, o = n + "", a;
  return function() {
    var s = Sl(this, e);
    return s === o ? null : s === r ? a : a = t(r = s, n);
  };
}
function Dee(e, t, n) {
  var r, o, a;
  return function() {
    var s = Sl(this, e), u = n(this), c = u + "";
    return u == null && (c = u = (this.style.removeProperty(e), Sl(this, e))), s === c ? null : s === r && c === o ? a : (o = c, a = t(r = s, u));
  };
}
function Pee(e, t) {
  var n, r, o, a = "style." + t, s = "end." + a, u;
  return function() {
    var c = Eo(this, e), f = c.on, h = c.value[a] == null ? u || (u = s5(t)) : void 0;
    (f !== n || o !== h) && (r = (n = f).copy()).on(s, o = h), c.on = r;
  };
}
function jee(e, t, n) {
  var r = (e += "") == "transform" ? IJ : a5;
  return t == null ? this.styleTween(e, Oee(e, r)).on("end.style." + e, s5(e)) : typeof t == "function" ? this.styleTween(e, Dee(e, r, Ex(this, "style." + e, t))).each(Pee(this._id, e)) : this.styleTween(e, Nee(e, r, t), n).on("end.style." + e, null);
}
function Iee(e, t, n) {
  return function(r) {
    this.style.setProperty(e, t.call(this, r), n);
  };
}
function zee(e, t, n) {
  var r, o;
  function a() {
    var s = t.apply(this, arguments);
    return s !== o && (r = (o = s) && Iee(e, s, n)), r;
  }
  return a._value = t, a;
}
function Lee(e, t, n) {
  var r = "style." + (e += "");
  if (arguments.length < 2) return (r = this.tween(r)) && r._value;
  if (t == null) return this.tween(r, null);
  if (typeof t != "function") throw new Error();
  return this.tween(r, zee(e, t, n ?? ""));
}
function Fee(e) {
  return function() {
    this.textContent = e;
  };
}
function $ee(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function Bee(e) {
  return this.tween("text", typeof e == "function" ? $ee(Ex(this, "text", e)) : Fee(e == null ? "" : e + ""));
}
function Hee(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function Vee(e) {
  var t, n;
  function r() {
    var o = e.apply(this, arguments);
    return o !== n && (t = (n = o) && Hee(o)), t;
  }
  return r._value = e, r;
}
function Uee(e) {
  var t = "text";
  if (arguments.length < 1) return (t = this.tween(t)) && t._value;
  if (e == null) return this.tween(t, null);
  if (typeof e != "function") throw new Error();
  return this.tween(t, Vee(e));
}
function qee() {
  for (var e = this._name, t = this._id, n = l5(), r = this._groups, o = r.length, a = 0; a < o; ++a)
    for (var s = r[a], u = s.length, c, f = 0; f < u; ++f)
      if (c = s[f]) {
        var h = Ur(c, t);
        Om(c, e, n, f, s, {
          time: h.time + h.delay + h.duration,
          delay: 0,
          duration: h.duration,
          ease: h.ease
        });
      }
  return new si(r, this._parents, e, n);
}
function Gee() {
  var e, t, n = this, r = n._id, o = n.size();
  return new Promise(function(a, s) {
    var u = { value: s }, c = { value: function() {
      --o === 0 && a();
    } };
    n.each(function() {
      var f = Eo(this, r), h = f.on;
      h !== e && (t = (e = h).copy(), t._.cancel.push(u), t._.interrupt.push(u), t._.end.push(c)), f.on = t;
    }), o === 0 && a();
  });
}
var Yee = 0;
function si(e, t, n, r) {
  this._groups = e, this._parents = t, this._name = n, this._id = r;
}
function l5() {
  return ++Yee;
}
var Yo = mf.prototype;
si.prototype = {
  constructor: si,
  select: Tee,
  selectAll: Aee,
  selectChild: Yo.selectChild,
  selectChildren: Yo.selectChildren,
  filter: xee,
  merge: wee,
  selection: Mee,
  transition: qee,
  call: Yo.call,
  nodes: Yo.nodes,
  node: Yo.node,
  size: Yo.size,
  empty: Yo.empty,
  each: Yo.each,
  on: Eee,
  attr: oee,
  attrTween: uee,
  style: jee,
  styleTween: Lee,
  text: Bee,
  textTween: Uee,
  remove: kee,
  tween: ZJ,
  delay: dee,
  duration: mee,
  ease: yee,
  easeVarying: bee,
  end: Gee,
  [Symbol.iterator]: Yo[Symbol.iterator]
};
function Wee(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var Xee = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: Wee
};
function Kee(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function Zee(e) {
  var t, n;
  e instanceof si ? (t = e._id, e = e._name) : (t = l5(), (n = Xee).time = _x(), e = e == null ? null : e + "");
  for (var r = this._groups, o = r.length, a = 0; a < o; ++a)
    for (var s = r[a], u = s.length, c, f = 0; f < u; ++f)
      (c = s[f]) && Om(c, e, t, f, s, n || Kee(c, t));
  return new si(r, this._parents, e, t);
}
mf.prototype.interrupt = WJ;
mf.prototype.transition = Zee;
const yh = (e) => () => e;
function Qee(e, {
  sourceEvent: t,
  target: n,
  transform: r,
  dispatch: o
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    transform: { value: r, enumerable: !0, configurable: !0 },
    _: { value: o }
  });
}
function Zo(e, t, n) {
  this.k = e, this.x = t, this.y = n;
}
Zo.prototype = {
  constructor: Zo,
  scale: function(e) {
    return e === 1 ? this : new Zo(this.k * e, this.x, this.y);
  },
  translate: function(e, t) {
    return e === 0 & t === 0 ? this : new Zo(this.k, this.x + this.k * e, this.y + this.k * t);
  },
  apply: function(e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y];
  },
  applyX: function(e) {
    return e * this.k + this.x;
  },
  applyY: function(e) {
    return e * this.k + this.y;
  },
  invert: function(e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
  },
  invertX: function(e) {
    return (e - this.x) / this.k;
  },
  invertY: function(e) {
    return (e - this.y) / this.k;
  },
  rescaleX: function(e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
  },
  rescaleY: function(e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var Nm = new Zo(1, 0, 0);
u5.prototype = Zo.prototype;
function u5(e) {
  for (; !e.__zoom; ) if (!(e = e.parentNode)) return Nm;
  return e.__zoom;
}
function dv(e) {
  e.stopImmediatePropagation();
}
function oc(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function Jee(e) {
  return (!e.ctrlKey || e.type === "wheel") && !e.button;
}
function ete() {
  var e = this;
  return e instanceof SVGElement ? (e = e.ownerSVGElement || e, e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]]) : [[0, 0], [e.clientWidth, e.clientHeight]];
}
function yA() {
  return this.__zoom || Nm;
}
function tte(e) {
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * (e.ctrlKey ? 10 : 1);
}
function nte() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function rte(e, t, n) {
  var r = e.invertX(t[0][0]) - n[0][0], o = e.invertX(t[1][0]) - n[1][0], a = e.invertY(t[0][1]) - n[0][1], s = e.invertY(t[1][1]) - n[1][1];
  return e.translate(
    o > r ? (r + o) / 2 : Math.min(0, r) || Math.max(0, o),
    s > a ? (a + s) / 2 : Math.min(0, a) || Math.max(0, s)
  );
}
function c5() {
  var e = Jee, t = ete, n = rte, r = tte, o = nte, a = [0, 1 / 0], s = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], u = 250, c = Vh, f = Am("start", "zoom", "end"), h, p, g, y = 500, w = 150, v = 0, S = 10;
  function E(j) {
    j.property("__zoom", yA).on("wheel.zoom", z, { passive: !1 }).on("mousedown.zoom", B).on("dblclick.zoom", R).filter(o).on("touchstart.zoom", F).on("touchmove.zoom", U).on("touchend.zoom touchcancel.zoom", W).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  E.transform = function(j, V, I, H) {
    var q = j.selection ? j.selection() : j;
    q.property("__zoom", yA), j !== q ? M(j, V, I, H) : q.interrupt().each(function() {
      N(this, arguments).event(H).start().zoom(null, typeof V == "function" ? V.apply(this, arguments) : V).end();
    });
  }, E.scaleBy = function(j, V, I, H) {
    E.scaleTo(j, function() {
      var q = this.__zoom.k, G = typeof V == "function" ? V.apply(this, arguments) : V;
      return q * G;
    }, I, H);
  }, E.scaleTo = function(j, V, I, H) {
    E.transform(j, function() {
      var q = t.apply(this, arguments), G = this.__zoom, O = I == null ? A(q) : typeof I == "function" ? I.apply(this, arguments) : I, Y = G.invert(O), Z = typeof V == "function" ? V.apply(this, arguments) : V;
      return n(k(T(G, Z), O, Y), q, s);
    }, I, H);
  }, E.translateBy = function(j, V, I, H) {
    E.transform(j, function() {
      return n(this.__zoom.translate(
        typeof V == "function" ? V.apply(this, arguments) : V,
        typeof I == "function" ? I.apply(this, arguments) : I
      ), t.apply(this, arguments), s);
    }, null, H);
  }, E.translateTo = function(j, V, I, H, q) {
    E.transform(j, function() {
      var G = t.apply(this, arguments), O = this.__zoom, Y = H == null ? A(G) : typeof H == "function" ? H.apply(this, arguments) : H;
      return n(Nm.translate(Y[0], Y[1]).scale(O.k).translate(
        typeof V == "function" ? -V.apply(this, arguments) : -V,
        typeof I == "function" ? -I.apply(this, arguments) : -I
      ), G, s);
    }, H, q);
  };
  function T(j, V) {
    return V = Math.max(a[0], Math.min(a[1], V)), V === j.k ? j : new Zo(V, j.x, j.y);
  }
  function k(j, V, I) {
    var H = V[0] - I[0] * j.k, q = V[1] - I[1] * j.k;
    return H === j.x && q === j.y ? j : new Zo(j.k, H, q);
  }
  function A(j) {
    return [(+j[0][0] + +j[1][0]) / 2, (+j[0][1] + +j[1][1]) / 2];
  }
  function M(j, V, I, H) {
    j.on("start.zoom", function() {
      N(this, arguments).event(H).start();
    }).on("interrupt.zoom end.zoom", function() {
      N(this, arguments).event(H).end();
    }).tween("zoom", function() {
      var q = this, G = arguments, O = N(q, G).event(H), Y = t.apply(q, G), Z = I == null ? A(Y) : typeof I == "function" ? I.apply(q, G) : I, L = Math.max(Y[1][0] - Y[0][0], Y[1][1] - Y[0][1]), te = q.__zoom, he = typeof V == "function" ? V.apply(q, G) : V, oe = c(te.invert(Z).concat(L / te.k), he.invert(Z).concat(L / he.k));
      return function(de) {
        if (de === 1) de = he;
        else {
          var le = oe(de), ye = L / le[2];
          de = new Zo(ye, Z[0] - le[0] * ye, Z[1] - le[1] * ye);
        }
        O.zoom(null, de);
      };
    });
  }
  function N(j, V, I) {
    return !I && j.__zooming || new P(j, V);
  }
  function P(j, V) {
    this.that = j, this.args = V, this.active = 0, this.sourceEvent = null, this.extent = t.apply(j, V), this.taps = 0;
  }
  P.prototype = {
    event: function(j) {
      return j && (this.sourceEvent = j), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(j, V) {
      return this.mouse && j !== "mouse" && (this.mouse[1] = V.invert(this.mouse[0])), this.touch0 && j !== "touch" && (this.touch0[1] = V.invert(this.touch0[0])), this.touch1 && j !== "touch" && (this.touch1[1] = V.invert(this.touch1[0])), this.that.__zoom = V, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(j) {
      var V = rr(this.that).datum();
      f.call(
        j,
        this.that,
        new Qee(j, {
          sourceEvent: this.sourceEvent,
          target: E,
          transform: this.that.__zoom,
          dispatch: f
        }),
        V
      );
    }
  };
  function z(j, ...V) {
    if (!e.apply(this, arguments)) return;
    var I = N(this, V).event(j), H = this.__zoom, q = Math.max(a[0], Math.min(a[1], H.k * Math.pow(2, r.apply(this, arguments)))), G = Dr(j);
    if (I.wheel)
      (I.mouse[0][0] !== G[0] || I.mouse[0][1] !== G[1]) && (I.mouse[1] = H.invert(I.mouse[0] = G)), clearTimeout(I.wheel);
    else {
      if (H.k === q) return;
      I.mouse = [G, H.invert(G)], Gh(this), I.start();
    }
    oc(j), I.wheel = setTimeout(O, w), I.zoom("mouse", n(k(T(H, q), I.mouse[0], I.mouse[1]), I.extent, s));
    function O() {
      I.wheel = null, I.end();
    }
  }
  function B(j, ...V) {
    if (g || !e.apply(this, arguments)) return;
    var I = j.currentTarget, H = N(this, V, !0).event(j), q = rr(j.view).on("mousemove.zoom", Z, !0).on("mouseup.zoom", L, !0), G = Dr(j, I), O = j.clientX, Y = j.clientY;
    Y3(j.view), dv(j), H.mouse = [G, this.__zoom.invert(G)], Gh(this), H.start();
    function Z(te) {
      if (oc(te), !H.moved) {
        var he = te.clientX - O, oe = te.clientY - Y;
        H.moved = he * he + oe * oe > v;
      }
      H.event(te).zoom("mouse", n(k(H.that.__zoom, H.mouse[0] = Dr(te, I), H.mouse[1]), H.extent, s));
    }
    function L(te) {
      q.on("mousemove.zoom mouseup.zoom", null), W3(te.view, H.moved), oc(te), H.event(te).end();
    }
  }
  function R(j, ...V) {
    if (e.apply(this, arguments)) {
      var I = this.__zoom, H = Dr(j.changedTouches ? j.changedTouches[0] : j, this), q = I.invert(H), G = I.k * (j.shiftKey ? 0.5 : 2), O = n(k(T(I, G), H, q), t.apply(this, V), s);
      oc(j), u > 0 ? rr(this).transition().duration(u).call(M, O, H, j) : rr(this).call(E.transform, O, H, j);
    }
  }
  function F(j, ...V) {
    if (e.apply(this, arguments)) {
      var I = j.touches, H = I.length, q = N(this, V, j.changedTouches.length === H).event(j), G, O, Y, Z;
      for (dv(j), O = 0; O < H; ++O)
        Y = I[O], Z = Dr(Y, this), Z = [Z, this.__zoom.invert(Z), Y.identifier], q.touch0 ? !q.touch1 && q.touch0[2] !== Z[2] && (q.touch1 = Z, q.taps = 0) : (q.touch0 = Z, G = !0, q.taps = 1 + !!h);
      h && (h = clearTimeout(h)), G && (q.taps < 2 && (p = Z[0], h = setTimeout(function() {
        h = null;
      }, y)), Gh(this), q.start());
    }
  }
  function U(j, ...V) {
    if (this.__zooming) {
      var I = N(this, V).event(j), H = j.changedTouches, q = H.length, G, O, Y, Z;
      for (oc(j), G = 0; G < q; ++G)
        O = H[G], Y = Dr(O, this), I.touch0 && I.touch0[2] === O.identifier ? I.touch0[0] = Y : I.touch1 && I.touch1[2] === O.identifier && (I.touch1[0] = Y);
      if (O = I.that.__zoom, I.touch1) {
        var L = I.touch0[0], te = I.touch0[1], he = I.touch1[0], oe = I.touch1[1], de = (de = he[0] - L[0]) * de + (de = he[1] - L[1]) * de, le = (le = oe[0] - te[0]) * le + (le = oe[1] - te[1]) * le;
        O = T(O, Math.sqrt(de / le)), Y = [(L[0] + he[0]) / 2, (L[1] + he[1]) / 2], Z = [(te[0] + oe[0]) / 2, (te[1] + oe[1]) / 2];
      } else if (I.touch0) Y = I.touch0[0], Z = I.touch0[1];
      else return;
      I.zoom("touch", n(k(O, Y, Z), I.extent, s));
    }
  }
  function W(j, ...V) {
    if (this.__zooming) {
      var I = N(this, V).event(j), H = j.changedTouches, q = H.length, G, O;
      for (dv(j), g && clearTimeout(g), g = setTimeout(function() {
        g = null;
      }, y), G = 0; G < q; ++G)
        O = H[G], I.touch0 && I.touch0[2] === O.identifier ? delete I.touch0 : I.touch1 && I.touch1[2] === O.identifier && delete I.touch1;
      if (I.touch1 && !I.touch0 && (I.touch0 = I.touch1, delete I.touch1), I.touch0) I.touch0[1] = this.__zoom.invert(I.touch0[0]);
      else if (I.end(), I.taps === 2 && (O = Dr(O, this), Math.hypot(p[0] - O[0], p[1] - O[1]) < S)) {
        var Y = rr(this).on("dblclick.zoom");
        Y && Y.apply(this, arguments);
      }
    }
  }
  return E.wheelDelta = function(j) {
    return arguments.length ? (r = typeof j == "function" ? j : yh(+j), E) : r;
  }, E.filter = function(j) {
    return arguments.length ? (e = typeof j == "function" ? j : yh(!!j), E) : e;
  }, E.touchable = function(j) {
    return arguments.length ? (o = typeof j == "function" ? j : yh(!!j), E) : o;
  }, E.extent = function(j) {
    return arguments.length ? (t = typeof j == "function" ? j : yh([[+j[0][0], +j[0][1]], [+j[1][0], +j[1][1]]]), E) : t;
  }, E.scaleExtent = function(j) {
    return arguments.length ? (a[0] = +j[0], a[1] = +j[1], E) : [a[0], a[1]];
  }, E.translateExtent = function(j) {
    return arguments.length ? (s[0][0] = +j[0][0], s[1][0] = +j[1][0], s[0][1] = +j[0][1], s[1][1] = +j[1][1], E) : [[s[0][0], s[0][1]], [s[1][0], s[1][1]]];
  }, E.constrain = function(j) {
    return arguments.length ? (n = j, E) : n;
  }, E.duration = function(j) {
    return arguments.length ? (u = +j, E) : u;
  }, E.interpolate = function(j) {
    return arguments.length ? (c = j, E) : c;
  }, E.on = function() {
    var j = f.on.apply(f, arguments);
    return j === f ? E : j;
  }, E.clickDistance = function(j) {
    return arguments.length ? (v = (j = +j) * j, E) : Math.sqrt(v);
  }, E.tapDistance = function(j) {
    return arguments.length ? (S = +j, E) : S;
  }, E;
}
const vo = {
  error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
  error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
  error003: (e) => `Node type "${e}" not found. Using fallback type "default".`,
  error004: () => "The React Flow parent container needs a width and a height to render the graph.",
  error005: () => "Only child nodes can use a parent extent.",
  error006: () => "Can't create edge. An edge needs a source and a target.",
  error007: (e) => `The old edge with id=${e} does not exist.`,
  error009: (e) => `Marker type "${e}" doesn't exist.`,
  error008: (e, { id: t, sourceHandle: n, targetHandle: r }) => `Couldn't create edge for ${e} handle id: "${e === "source" ? n : r}", edge id: ${t}.`,
  error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
  error011: (e) => `Edge type "${e}" not found. Using fallback type "default".`,
  error012: (e) => `Node with id "${e}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
  error013: (e = "react") => `It seems that you haven't loaded the styles. Please import '@xyflow/${e}/dist/style.css' or base.css to make sure everything is working properly.`,
  error014: () => "useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.",
  error015: () => "It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs."
}, Hc = [
  [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
  [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
], f5 = ["Enter", " ", "Escape"], d5 = {
  "node.a11yDescription.default": "Press enter or space to select a node. Press delete to remove it and escape to cancel.",
  "node.a11yDescription.keyboardDisabled": "Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.",
  "node.a11yDescription.ariaLiveMessage": ({ direction: e, x: t, y: n }) => `Moved selected node ${e}. New position, x: ${t}, y: ${n}`,
  "edge.a11yDescription.default": "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.",
  // Control elements
  "controls.ariaLabel": "Control Panel",
  "controls.zoomIn.ariaLabel": "Zoom In",
  "controls.zoomOut.ariaLabel": "Zoom Out",
  "controls.fitView.ariaLabel": "Fit View",
  "controls.interactive.ariaLabel": "Toggle Interactivity",
  // Mini map
  "minimap.ariaLabel": "Mini Map",
  // Handle
  "handle.ariaLabel": "Handle"
};
var Cl;
(function(e) {
  e.Strict = "strict", e.Loose = "loose";
})(Cl || (Cl = {}));
var Ba;
(function(e) {
  e.Free = "free", e.Vertical = "vertical", e.Horizontal = "horizontal";
})(Ba || (Ba = {}));
var Vc;
(function(e) {
  e.Partial = "partial", e.Full = "full";
})(Vc || (Vc = {}));
const h5 = {
  inProgress: !1,
  isValid: null,
  from: null,
  fromHandle: null,
  fromPosition: null,
  fromNode: null,
  to: null,
  toHandle: null,
  toPosition: null,
  toNode: null
};
var Xi;
(function(e) {
  e.Bezier = "default", e.Straight = "straight", e.Step = "step", e.SmoothStep = "smoothstep", e.SimpleBezier = "simplebezier";
})(Xi || (Xi = {}));
var Sp;
(function(e) {
  e.Arrow = "arrow", e.ArrowClosed = "arrowclosed";
})(Sp || (Sp = {}));
var Te;
(function(e) {
  e.Left = "left", e.Top = "top", e.Right = "right", e.Bottom = "bottom";
})(Te || (Te = {}));
const vA = {
  [Te.Left]: Te.Right,
  [Te.Right]: Te.Left,
  [Te.Top]: Te.Bottom,
  [Te.Bottom]: Te.Top
};
function p5(e) {
  return e === null ? null : e ? "valid" : "invalid";
}
const m5 = (e) => "id" in e && "source" in e && "target" in e, ote = (e) => "id" in e && "position" in e && !("source" in e) && !("target" in e), Cx = (e) => "id" in e && "internals" in e && !("source" in e) && !("target" in e), yf = (e, t = [0, 0]) => {
  const { width: n, height: r } = hi(e), o = e.origin ?? t, a = n * o[0], s = r * o[1];
  return {
    x: e.position.x - a,
    y: e.position.y - s
  };
}, ite = (e, t = { nodeOrigin: [0, 0] }) => {
  if (e.length === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  const n = e.reduce((r, o) => {
    const a = typeof o == "string";
    let s = !t.nodeLookup && !a ? o : void 0;
    t.nodeLookup && (s = a ? t.nodeLookup.get(o) : Cx(o) ? o : t.nodeLookup.get(o.id));
    const u = s ? Ep(s, t.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };
    return Dm(r, u);
  }, { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 });
  return Pm(n);
}, vf = (e, t = {}) => {
  if (e.size === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  let n = { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 };
  return e.forEach((r) => {
    if (t.filter === void 0 || t.filter(r)) {
      const o = Ep(r);
      n = Dm(n, o);
    }
  }), Pm(n);
}, kx = (e, t, [n, r, o] = [0, 0, 1], a = !1, s = !1) => {
  const u = {
    ...bf(t, [n, r, o]),
    width: t.width / o,
    height: t.height / o
  }, c = [];
  for (const f of e.values()) {
    const { measured: h, selectable: p = !0, hidden: g = !1 } = f;
    if (s && !p || g)
      continue;
    const y = h.width ?? f.width ?? f.initialWidth ?? null, w = h.height ?? f.height ?? f.initialHeight ?? null, v = Uc(u, Tl(f)), S = (y ?? 0) * (w ?? 0), E = a && v > 0;
    (!f.internals.handleBounds || E || v >= S || f.dragging) && c.push(f);
  }
  return c;
}, ate = (e, t) => {
  const n = /* @__PURE__ */ new Set();
  return e.forEach((r) => {
    n.add(r.id);
  }), t.filter((r) => n.has(r.source) || n.has(r.target));
};
function ste(e, t) {
  const n = /* @__PURE__ */ new Map(), r = t?.nodes ? new Set(t.nodes.map((o) => o.id)) : null;
  return e.forEach((o) => {
    o.measured.width && o.measured.height && (t?.includeHiddenNodes || !o.hidden) && (!r || r.has(o.id)) && n.set(o.id, o);
  }), n;
}
async function lte({ nodes: e, width: t, height: n, panZoom: r, minZoom: o, maxZoom: a }, s) {
  if (e.size === 0)
    return Promise.resolve(!0);
  const u = ste(e, s), c = vf(u), f = Tx(c, t, n, s?.minZoom ?? o, s?.maxZoom ?? a, s?.padding ?? 0.1);
  return await r.setViewport(f, {
    duration: s?.duration,
    ease: s?.ease,
    interpolate: s?.interpolate
  }), Promise.resolve(!0);
}
function g5({ nodeId: e, nextPosition: t, nodeLookup: n, nodeOrigin: r = [0, 0], nodeExtent: o, onError: a }) {
  const s = n.get(e), u = s.parentId ? n.get(s.parentId) : void 0, { x: c, y: f } = u ? u.internals.positionAbsolute : { x: 0, y: 0 }, h = s.origin ?? r;
  let p = s.extent || o;
  if (s.extent === "parent" && !s.expandParent)
    if (!u)
      a?.("005", vo.error005());
    else {
      const y = u.measured.width, w = u.measured.height;
      y && w && (p = [
        [c, f],
        [c + y, f + w]
      ]);
    }
  else u && Al(s.extent) && (p = [
    [s.extent[0][0] + c, s.extent[0][1] + f],
    [s.extent[1][0] + c, s.extent[1][1] + f]
  ]);
  const g = Al(p) ? Qa(t, p, s.measured) : t;
  return (s.measured.width === void 0 || s.measured.height === void 0) && a?.("015", vo.error015()), {
    position: {
      x: g.x - c + (s.measured.width ?? 0) * h[0],
      y: g.y - f + (s.measured.height ?? 0) * h[1]
    },
    positionAbsolute: g
  };
}
async function ute({ nodesToRemove: e = [], edgesToRemove: t = [], nodes: n, edges: r, onBeforeDelete: o }) {
  const a = new Set(e.map((g) => g.id)), s = [];
  for (const g of n) {
    if (g.deletable === !1)
      continue;
    const y = a.has(g.id), w = !y && g.parentId && s.find((v) => v.id === g.parentId);
    (y || w) && s.push(g);
  }
  const u = new Set(t.map((g) => g.id)), c = r.filter((g) => g.deletable !== !1), h = ate(s, c);
  for (const g of c)
    u.has(g.id) && !h.find((w) => w.id === g.id) && h.push(g);
  if (!o)
    return {
      edges: h,
      nodes: s
    };
  const p = await o({
    nodes: s,
    edges: h
  });
  return typeof p == "boolean" ? p ? { edges: h, nodes: s } : { edges: [], nodes: [] } : p;
}
const kl = (e, t = 0, n = 1) => Math.min(Math.max(e, t), n), Qa = (e = { x: 0, y: 0 }, t, n) => ({
  x: kl(e.x, t[0][0], t[1][0] - (n?.width ?? 0)),
  y: kl(e.y, t[0][1], t[1][1] - (n?.height ?? 0))
});
function y5(e, t, n) {
  const { width: r, height: o } = hi(n), { x: a, y: s } = n.internals.positionAbsolute;
  return Qa(e, [
    [a, s],
    [a + r, s + o]
  ], t);
}
const bA = (e, t, n) => e < t ? kl(Math.abs(e - t), 1, t) / t : e > n ? -kl(Math.abs(e - n), 1, t) / t : 0, v5 = (e, t, n = 15, r = 40) => {
  const o = bA(e.x, r, t.width - r) * n, a = bA(e.y, r, t.height - r) * n;
  return [o, a];
}, Dm = (e, t) => ({
  x: Math.min(e.x, t.x),
  y: Math.min(e.y, t.y),
  x2: Math.max(e.x2, t.x2),
  y2: Math.max(e.y2, t.y2)
}), Ib = ({ x: e, y: t, width: n, height: r }) => ({
  x: e,
  y: t,
  x2: e + n,
  y2: t + r
}), Pm = ({ x: e, y: t, x2: n, y2: r }) => ({
  x: e,
  y: t,
  width: n - e,
  height: r - t
}), Tl = (e, t = [0, 0]) => {
  const { x: n, y: r } = Cx(e) ? e.internals.positionAbsolute : yf(e, t);
  return {
    x: n,
    y: r,
    width: e.measured?.width ?? e.width ?? e.initialWidth ?? 0,
    height: e.measured?.height ?? e.height ?? e.initialHeight ?? 0
  };
}, Ep = (e, t = [0, 0]) => {
  const { x: n, y: r } = Cx(e) ? e.internals.positionAbsolute : yf(e, t);
  return {
    x: n,
    y: r,
    x2: n + (e.measured?.width ?? e.width ?? e.initialWidth ?? 0),
    y2: r + (e.measured?.height ?? e.height ?? e.initialHeight ?? 0)
  };
}, b5 = (e, t) => Pm(Dm(Ib(e), Ib(t))), Uc = (e, t) => {
  const n = Math.max(0, Math.min(e.x + e.width, t.x + t.width) - Math.max(e.x, t.x)), r = Math.max(0, Math.min(e.y + e.height, t.y + t.height) - Math.max(e.y, t.y));
  return Math.ceil(n * r);
}, xA = (e) => Ir(e.width) && Ir(e.height) && Ir(e.x) && Ir(e.y), Ir = (e) => !isNaN(e) && isFinite(e), cte = (e, t) => {
}, jm = (e, t = [1, 1]) => ({
  x: t[0] * Math.round(e.x / t[0]),
  y: t[1] * Math.round(e.y / t[1])
}), bf = ({ x: e, y: t }, [n, r, o], a = !1, s = [1, 1]) => {
  const u = {
    x: (e - n) / o,
    y: (t - r) / o
  };
  return a ? jm(u, s) : u;
}, Cp = ({ x: e, y: t }, [n, r, o]) => ({
  x: e * o + n,
  y: t * o + r
});
function Zs(e, t) {
  if (typeof e == "number")
    return Math.floor((t - t / (1 + e)) * 0.5);
  if (typeof e == "string" && e.endsWith("px")) {
    const n = parseFloat(e);
    if (!Number.isNaN(n))
      return Math.floor(n);
  }
  if (typeof e == "string" && e.endsWith("%")) {
    const n = parseFloat(e);
    if (!Number.isNaN(n))
      return Math.floor(t * n * 0.01);
  }
  return console.error(`[React Flow] The padding value "${e}" is invalid. Please provide a number or a string with a valid unit (px or %).`), 0;
}
function fte(e, t, n) {
  if (typeof e == "string" || typeof e == "number") {
    const r = Zs(e, n), o = Zs(e, t);
    return {
      top: r,
      right: o,
      bottom: r,
      left: o,
      x: o * 2,
      y: r * 2
    };
  }
  if (typeof e == "object") {
    const r = Zs(e.top ?? e.y ?? 0, n), o = Zs(e.bottom ?? e.y ?? 0, n), a = Zs(e.left ?? e.x ?? 0, t), s = Zs(e.right ?? e.x ?? 0, t);
    return { top: r, right: s, bottom: o, left: a, x: a + s, y: r + o };
  }
  return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 };
}
function dte(e, t, n, r, o, a) {
  const { x: s, y: u } = Cp(e, [t, n, r]), { x: c, y: f } = Cp({ x: e.x + e.width, y: e.y + e.height }, [t, n, r]), h = o - c, p = a - f;
  return {
    left: Math.floor(s),
    top: Math.floor(u),
    right: Math.floor(h),
    bottom: Math.floor(p)
  };
}
const Tx = (e, t, n, r, o, a) => {
  const s = fte(a, t, n), u = (t - s.x) / e.width, c = (n - s.y) / e.height, f = Math.min(u, c), h = kl(f, r, o), p = e.x + e.width / 2, g = e.y + e.height / 2, y = t / 2 - p * h, w = n / 2 - g * h, v = dte(e, y, w, h, t, n), S = {
    left: Math.min(v.left - s.left, 0),
    top: Math.min(v.top - s.top, 0),
    right: Math.min(v.right - s.right, 0),
    bottom: Math.min(v.bottom - s.bottom, 0)
  };
  return {
    x: y - S.left + S.right,
    y: w - S.top + S.bottom,
    zoom: h
  };
}, kp = () => typeof navigator < "u" && navigator?.userAgent?.indexOf("Mac") >= 0;
function Al(e) {
  return e !== void 0 && e !== "parent";
}
function hi(e) {
  return {
    width: e.measured?.width ?? e.width ?? e.initialWidth ?? 0,
    height: e.measured?.height ?? e.height ?? e.initialHeight ?? 0
  };
}
function x5(e) {
  return (e.measured?.width ?? e.width ?? e.initialWidth) !== void 0 && (e.measured?.height ?? e.height ?? e.initialHeight) !== void 0;
}
function w5(e, t = { width: 0, height: 0 }, n, r, o) {
  const a = { ...e }, s = r.get(n);
  if (s) {
    const u = s.origin || o;
    a.x += s.internals.positionAbsolute.x - (t.width ?? 0) * u[0], a.y += s.internals.positionAbsolute.y - (t.height ?? 0) * u[1];
  }
  return a;
}
function wA(e, t) {
  if (e.size !== t.size)
    return !1;
  for (const n of e)
    if (!t.has(n))
      return !1;
  return !0;
}
function hte() {
  let e, t;
  return { promise: new Promise((r, o) => {
    e = r, t = o;
  }), resolve: e, reject: t };
}
function pte(e) {
  return { ...d5, ...e || {} };
}
function xc(e, { snapGrid: t = [0, 0], snapToGrid: n = !1, transform: r, containerBounds: o }) {
  const { x: a, y: s } = fo(e), u = bf({ x: a - (o?.left ?? 0), y: s - (o?.top ?? 0) }, r), { x: c, y: f } = n ? jm(u, t) : u;
  return {
    xSnapped: c,
    ySnapped: f,
    ...u
  };
}
const Ax = (e) => ({
  width: e.offsetWidth,
  height: e.offsetHeight
}), _5 = (e) => e?.getRootNode?.() || window?.document, mte = ["INPUT", "SELECT", "TEXTAREA"];
function S5(e) {
  const t = e.composedPath?.()?.[0] || e.target;
  return t?.nodeType !== 1 ? !1 : mte.includes(t.nodeName) || t.hasAttribute("contenteditable") || !!t.closest(".nokey");
}
const E5 = (e) => "clientX" in e, fo = (e, t) => {
  const n = E5(e), r = n ? e.clientX : e.touches?.[0].clientX, o = n ? e.clientY : e.touches?.[0].clientY;
  return {
    x: r - (t?.left ?? 0),
    y: o - (t?.top ?? 0)
  };
}, _A = (e, t, n, r, o) => {
  const a = t.querySelectorAll(`.${e}`);
  return !a || !a.length ? null : Array.from(a).map((s) => {
    const u = s.getBoundingClientRect();
    return {
      id: s.getAttribute("data-handleid"),
      type: e,
      nodeId: o,
      position: s.getAttribute("data-handlepos"),
      x: (u.left - n.left) / r,
      y: (u.top - n.top) / r,
      ...Ax(s)
    };
  });
};
function C5({ sourceX: e, sourceY: t, targetX: n, targetY: r, sourceControlX: o, sourceControlY: a, targetControlX: s, targetControlY: u }) {
  const c = e * 0.125 + o * 0.375 + s * 0.375 + n * 0.125, f = t * 0.125 + a * 0.375 + u * 0.375 + r * 0.125, h = Math.abs(c - e), p = Math.abs(f - t);
  return [c, f, h, p];
}
function vh(e, t) {
  return e >= 0 ? 0.5 * e : t * 25 * Math.sqrt(-e);
}
function SA({ pos: e, x1: t, y1: n, x2: r, y2: o, c: a }) {
  switch (e) {
    case Te.Left:
      return [t - vh(t - r, a), n];
    case Te.Right:
      return [t + vh(r - t, a), n];
    case Te.Top:
      return [t, n - vh(n - o, a)];
    case Te.Bottom:
      return [t, n + vh(o - n, a)];
  }
}
function Rx({ sourceX: e, sourceY: t, sourcePosition: n = Te.Bottom, targetX: r, targetY: o, targetPosition: a = Te.Top, curvature: s = 0.25 }) {
  const [u, c] = SA({
    pos: n,
    x1: e,
    y1: t,
    x2: r,
    y2: o,
    c: s
  }), [f, h] = SA({
    pos: a,
    x1: r,
    y1: o,
    x2: e,
    y2: t,
    c: s
  }), [p, g, y, w] = C5({
    sourceX: e,
    sourceY: t,
    targetX: r,
    targetY: o,
    sourceControlX: u,
    sourceControlY: c,
    targetControlX: f,
    targetControlY: h
  });
  return [
    `M${e},${t} C${u},${c} ${f},${h} ${r},${o}`,
    p,
    g,
    y,
    w
  ];
}
function k5({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
  const o = Math.abs(n - e) / 2, a = n < e ? n + o : n - o, s = Math.abs(r - t) / 2, u = r < t ? r + s : r - s;
  return [a, u, o, s];
}
function gte({ sourceNode: e, targetNode: t, selected: n = !1, zIndex: r, elevateOnSelect: o = !1 }) {
  if (r !== void 0)
    return r;
  const a = o && n ? 1e3 : 0, s = Math.max(e.parentId ? e.internals.z : 0, t.parentId ? t.internals.z : 0);
  return a + s;
}
function yte({ sourceNode: e, targetNode: t, width: n, height: r, transform: o }) {
  const a = Dm(Ep(e), Ep(t));
  a.x === a.x2 && (a.x2 += 1), a.y === a.y2 && (a.y2 += 1);
  const s = {
    x: -o[0] / o[2],
    y: -o[1] / o[2],
    width: n / o[2],
    height: r / o[2]
  };
  return Uc(s, Pm(a)) > 0;
}
const vte = ({ source: e, sourceHandle: t, target: n, targetHandle: r }) => `xy-edge__${e}${t || ""}-${n}${r || ""}`, bte = (e, t) => t.some((n) => n.source === e.source && n.target === e.target && (n.sourceHandle === e.sourceHandle || !n.sourceHandle && !e.sourceHandle) && (n.targetHandle === e.targetHandle || !n.targetHandle && !e.targetHandle)), xte = (e, t) => {
  if (!e.source || !e.target)
    return t;
  let n;
  return m5(e) ? n = { ...e } : n = {
    ...e,
    id: vte(e)
  }, bte(n, t) ? t : (n.sourceHandle === null && delete n.sourceHandle, n.targetHandle === null && delete n.targetHandle, t.concat(n));
};
function T5({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
  const [o, a, s, u] = k5({
    sourceX: e,
    sourceY: t,
    targetX: n,
    targetY: r
  });
  return [`M ${e},${t}L ${n},${r}`, o, a, s, u];
}
const EA = {
  [Te.Left]: { x: -1, y: 0 },
  [Te.Right]: { x: 1, y: 0 },
  [Te.Top]: { x: 0, y: -1 },
  [Te.Bottom]: { x: 0, y: 1 }
}, wte = ({ source: e, sourcePosition: t = Te.Bottom, target: n }) => t === Te.Left || t === Te.Right ? e.x < n.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : e.y < n.y ? { x: 0, y: 1 } : { x: 0, y: -1 }, CA = (e, t) => Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
function _te({ source: e, sourcePosition: t = Te.Bottom, target: n, targetPosition: r = Te.Top, center: o, offset: a, stepPosition: s }) {
  const u = EA[t], c = EA[r], f = { x: e.x + u.x * a, y: e.y + u.y * a }, h = { x: n.x + c.x * a, y: n.y + c.y * a }, p = wte({
    source: f,
    sourcePosition: t,
    target: h
  }), g = p.x !== 0 ? "x" : "y", y = p[g];
  let w = [], v, S;
  const E = { x: 0, y: 0 }, T = { x: 0, y: 0 }, [, , k, A] = k5({
    sourceX: e.x,
    sourceY: e.y,
    targetX: n.x,
    targetY: n.y
  });
  if (u[g] * c[g] === -1) {
    g === "x" ? (v = o.x ?? f.x + (h.x - f.x) * s, S = o.y ?? (f.y + h.y) / 2) : (v = o.x ?? (f.x + h.x) / 2, S = o.y ?? f.y + (h.y - f.y) * s);
    const N = [
      { x: v, y: f.y },
      { x: v, y: h.y }
    ], P = [
      { x: f.x, y: S },
      { x: h.x, y: S }
    ];
    u[g] === y ? w = g === "x" ? N : P : w = g === "x" ? P : N;
  } else {
    const N = [{ x: f.x, y: h.y }], P = [{ x: h.x, y: f.y }];
    if (g === "x" ? w = u.x === y ? P : N : w = u.y === y ? N : P, t === r) {
      const U = Math.abs(e[g] - n[g]);
      if (U <= a) {
        const W = Math.min(a - 1, a - U);
        u[g] === y ? E[g] = (f[g] > e[g] ? -1 : 1) * W : T[g] = (h[g] > n[g] ? -1 : 1) * W;
      }
    }
    if (t !== r) {
      const U = g === "x" ? "y" : "x", W = u[g] === c[U], j = f[U] > h[U], V = f[U] < h[U];
      (u[g] === 1 && (!W && j || W && V) || u[g] !== 1 && (!W && V || W && j)) && (w = g === "x" ? N : P);
    }
    const z = { x: f.x + E.x, y: f.y + E.y }, B = { x: h.x + T.x, y: h.y + T.y }, R = Math.max(Math.abs(z.x - w[0].x), Math.abs(B.x - w[0].x)), F = Math.max(Math.abs(z.y - w[0].y), Math.abs(B.y - w[0].y));
    R >= F ? (v = (z.x + B.x) / 2, S = w[0].y) : (v = w[0].x, S = (z.y + B.y) / 2);
  }
  return [[
    e,
    { x: f.x + E.x, y: f.y + E.y },
    ...w,
    { x: h.x + T.x, y: h.y + T.y },
    n
  ], v, S, k, A];
}
function Ste(e, t, n, r) {
  const o = Math.min(CA(e, t) / 2, CA(t, n) / 2, r), { x: a, y: s } = t;
  if (e.x === a && a === n.x || e.y === s && s === n.y)
    return `L${a} ${s}`;
  if (e.y === s) {
    const f = e.x < n.x ? -1 : 1, h = e.y < n.y ? 1 : -1;
    return `L ${a + o * f},${s}Q ${a},${s} ${a},${s + o * h}`;
  }
  const u = e.x < n.x ? 1 : -1, c = e.y < n.y ? -1 : 1;
  return `L ${a},${s + o * c}Q ${a},${s} ${a + o * u},${s}`;
}
function zb({ sourceX: e, sourceY: t, sourcePosition: n = Te.Bottom, targetX: r, targetY: o, targetPosition: a = Te.Top, borderRadius: s = 5, centerX: u, centerY: c, offset: f = 20, stepPosition: h = 0.5 }) {
  const [p, g, y, w, v] = _te({
    source: { x: e, y: t },
    sourcePosition: n,
    target: { x: r, y: o },
    targetPosition: a,
    center: { x: u, y: c },
    offset: f,
    stepPosition: h
  });
  return [p.reduce((E, T, k) => {
    let A = "";
    return k > 0 && k < p.length - 1 ? A = Ste(p[k - 1], T, p[k + 1], s) : A = `${k === 0 ? "M" : "L"}${T.x} ${T.y}`, E += A, E;
  }, ""), g, y, w, v];
}
function kA(e) {
  return e && !!(e.internals.handleBounds || e.handles?.length) && !!(e.measured.width || e.width || e.initialWidth);
}
function Ete(e) {
  const { sourceNode: t, targetNode: n } = e;
  if (!kA(t) || !kA(n))
    return null;
  const r = t.internals.handleBounds || TA(t.handles), o = n.internals.handleBounds || TA(n.handles), a = AA(r?.source ?? [], e.sourceHandle), s = AA(
    // when connection type is loose we can define all handles as sources and connect source -> source
    e.connectionMode === Cl.Strict ? o?.target ?? [] : (o?.target ?? []).concat(o?.source ?? []),
    e.targetHandle
  );
  if (!a || !s)
    return e.onError?.("008", vo.error008(a ? "target" : "source", {
      id: e.id,
      sourceHandle: e.sourceHandle,
      targetHandle: e.targetHandle
    })), null;
  const u = a?.position || Te.Bottom, c = s?.position || Te.Top, f = qc(t, a, u), h = qc(n, s, c);
  return {
    sourceX: f.x,
    sourceY: f.y,
    targetX: h.x,
    targetY: h.y,
    sourcePosition: u,
    targetPosition: c
  };
}
function TA(e) {
  if (!e)
    return null;
  const t = [], n = [];
  for (const r of e)
    r.width = r.width ?? 1, r.height = r.height ?? 1, r.type === "source" ? t.push(r) : r.type === "target" && n.push(r);
  return {
    source: t,
    target: n
  };
}
function qc(e, t, n = Te.Left, r = !1) {
  const o = (t?.x ?? 0) + e.internals.positionAbsolute.x, a = (t?.y ?? 0) + e.internals.positionAbsolute.y, { width: s, height: u } = t ?? hi(e);
  if (r)
    return { x: o + s / 2, y: a + u / 2 };
  switch (t?.position ?? n) {
    case Te.Top:
      return { x: o + s / 2, y: a };
    case Te.Right:
      return { x: o + s, y: a + u / 2 };
    case Te.Bottom:
      return { x: o + s / 2, y: a + u };
    case Te.Left:
      return { x: o, y: a + u / 2 };
  }
}
function AA(e, t) {
  return e && (t ? e.find((n) => n.id === t) : e[0]) || null;
}
function Lb(e, t) {
  return e ? typeof e == "string" ? e : `${t ? `${t}__` : ""}${Object.keys(e).sort().map((r) => `${r}=${e[r]}`).join("&")}` : "";
}
function Cte(e, { id: t, defaultColor: n, defaultMarkerStart: r, defaultMarkerEnd: o }) {
  const a = /* @__PURE__ */ new Set();
  return e.reduce((s, u) => ([u.markerStart || r, u.markerEnd || o].forEach((c) => {
    if (c && typeof c == "object") {
      const f = Lb(c, t);
      a.has(f) || (s.push({ id: f, color: c.color || n, ...c }), a.add(f));
    }
  }), s), []).sort((s, u) => s.id.localeCompare(u.id));
}
const Mx = {
  nodeOrigin: [0, 0],
  nodeExtent: Hc,
  elevateNodesOnSelect: !0,
  defaults: {}
}, kte = {
  ...Mx,
  checkEquality: !0
};
function Ox(e, t) {
  const n = { ...e };
  for (const r in t)
    t[r] !== void 0 && (n[r] = t[r]);
  return n;
}
function Tte(e, t, n) {
  const r = Ox(Mx, n);
  for (const o of e.values())
    if (o.parentId)
      Nx(o, e, t, r);
    else {
      const a = yf(o, r.nodeOrigin), s = Al(o.extent) ? o.extent : r.nodeExtent, u = Qa(a, s, hi(o));
      o.internals.positionAbsolute = u;
    }
}
function Fb(e, t, n, r) {
  const o = Ox(kte, r);
  let a = e.length > 0;
  const s = new Map(t), u = o?.elevateNodesOnSelect ? 1e3 : 0;
  t.clear(), n.clear();
  for (const c of e) {
    let f = s.get(c.id);
    if (o.checkEquality && c === f?.internals.userNode)
      t.set(c.id, f);
    else {
      const h = yf(c, o.nodeOrigin), p = Al(c.extent) ? c.extent : o.nodeExtent, g = Qa(h, p, hi(c));
      f = {
        ...o.defaults,
        ...c,
        measured: {
          width: c.measured?.width,
          height: c.measured?.height
        },
        internals: {
          positionAbsolute: g,
          // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured
          handleBounds: c.measured ? f?.internals.handleBounds : void 0,
          z: A5(c, u),
          userNode: c
        }
      }, t.set(c.id, f);
    }
    (f.measured === void 0 || f.measured.width === void 0 || f.measured.height === void 0) && !f.hidden && (a = !1), c.parentId && Nx(f, t, n, r);
  }
  return a;
}
function Ate(e, t) {
  if (!e.parentId)
    return;
  const n = t.get(e.parentId);
  n ? n.set(e.id, e) : t.set(e.parentId, /* @__PURE__ */ new Map([[e.id, e]]));
}
function Nx(e, t, n, r) {
  const { elevateNodesOnSelect: o, nodeOrigin: a, nodeExtent: s } = Ox(Mx, r), u = e.parentId, c = t.get(u);
  if (!c) {
    console.warn(`Parent node ${u} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);
    return;
  }
  Ate(e, n);
  const f = o ? 1e3 : 0, { x: h, y: p, z: g } = Rte(e, c, a, s, f), { positionAbsolute: y } = e.internals, w = h !== y.x || p !== y.y;
  (w || g !== e.internals.z) && t.set(e.id, {
    ...e,
    internals: {
      ...e.internals,
      positionAbsolute: w ? { x: h, y: p } : y,
      z: g
    }
  });
}
function A5(e, t) {
  return (Ir(e.zIndex) ? e.zIndex : 0) + (e.selected ? t : 0);
}
function Rte(e, t, n, r, o) {
  const { x: a, y: s } = t.internals.positionAbsolute, u = hi(e), c = yf(e, n), f = Al(e.extent) ? Qa(c, e.extent, u) : c;
  let h = Qa({ x: a + f.x, y: s + f.y }, r, u);
  e.extent === "parent" && (h = y5(h, u, t));
  const p = A5(e, o), g = t.internals.z ?? 0;
  return {
    x: h.x,
    y: h.y,
    z: g >= p ? g + 1 : p
  };
}
function Dx(e, t, n, r = [0, 0]) {
  const o = [], a = /* @__PURE__ */ new Map();
  for (const s of e) {
    const u = t.get(s.parentId);
    if (!u)
      continue;
    const c = a.get(s.parentId)?.expandedRect ?? Tl(u), f = b5(c, s.rect);
    a.set(s.parentId, { expandedRect: f, parent: u });
  }
  return a.size > 0 && a.forEach(({ expandedRect: s, parent: u }, c) => {
    const f = u.internals.positionAbsolute, h = hi(u), p = u.origin ?? r, g = s.x < f.x ? Math.round(Math.abs(f.x - s.x)) : 0, y = s.y < f.y ? Math.round(Math.abs(f.y - s.y)) : 0, w = Math.max(h.width, Math.round(s.width)), v = Math.max(h.height, Math.round(s.height)), S = (w - h.width) * p[0], E = (v - h.height) * p[1];
    (g > 0 || y > 0 || S || E) && (o.push({
      id: c,
      type: "position",
      position: {
        x: u.position.x - g + S,
        y: u.position.y - y + E
      }
    }), n.get(c)?.forEach((T) => {
      e.some((k) => k.id === T.id) || o.push({
        id: T.id,
        type: "position",
        position: {
          x: T.position.x + g,
          y: T.position.y + y
        }
      });
    })), (h.width < s.width || h.height < s.height || g || y) && o.push({
      id: c,
      type: "dimensions",
      setAttributes: !0,
      dimensions: {
        width: w + (g ? p[0] * g - S : 0),
        height: v + (y ? p[1] * y - E : 0)
      }
    });
  }), o;
}
function Mte(e, t, n, r, o, a) {
  const s = r?.querySelector(".xyflow__viewport");
  let u = !1;
  if (!s)
    return { changes: [], updatedInternals: u };
  const c = [], f = window.getComputedStyle(s), { m22: h } = new window.DOMMatrixReadOnly(f.transform), p = [];
  for (const g of e.values()) {
    const y = t.get(g.id);
    if (!y)
      continue;
    if (y.hidden) {
      t.set(y.id, {
        ...y,
        internals: {
          ...y.internals,
          handleBounds: void 0
        }
      }), u = !0;
      continue;
    }
    const w = Ax(g.nodeElement), v = y.measured.width !== w.width || y.measured.height !== w.height;
    if (!!(w.width && w.height && (v || !y.internals.handleBounds || g.force))) {
      const E = g.nodeElement.getBoundingClientRect(), T = Al(y.extent) ? y.extent : a;
      let { positionAbsolute: k } = y.internals;
      y.parentId && y.extent === "parent" ? k = y5(k, w, t.get(y.parentId)) : T && (k = Qa(k, T, w));
      const A = {
        ...y,
        measured: w,
        internals: {
          ...y.internals,
          positionAbsolute: k,
          handleBounds: {
            source: _A("source", g.nodeElement, E, h, y.id),
            target: _A("target", g.nodeElement, E, h, y.id)
          }
        }
      };
      t.set(y.id, A), y.parentId && Nx(A, t, n, { nodeOrigin: o }), u = !0, v && (c.push({
        id: y.id,
        type: "dimensions",
        dimensions: w
      }), y.expandParent && y.parentId && p.push({
        id: y.id,
        parentId: y.parentId,
        rect: Tl(A, o)
      }));
    }
  }
  if (p.length > 0) {
    const g = Dx(p, t, n, o);
    c.push(...g);
  }
  return { changes: c, updatedInternals: u };
}
async function Ote({ delta: e, panZoom: t, transform: n, translateExtent: r, width: o, height: a }) {
  if (!t || !e.x && !e.y)
    return Promise.resolve(!1);
  const s = await t.setViewportConstrained({
    x: n[0] + e.x,
    y: n[1] + e.y,
    zoom: n[2]
  }, [
    [0, 0],
    [o, a]
  ], r), u = !!s && (s.x !== n[0] || s.y !== n[1] || s.k !== n[2]);
  return Promise.resolve(u);
}
function RA(e, t, n, r, o, a) {
  let s = o;
  const u = r.get(s) || /* @__PURE__ */ new Map();
  r.set(s, u.set(n, t)), s = `${o}-${e}`;
  const c = r.get(s) || /* @__PURE__ */ new Map();
  if (r.set(s, c.set(n, t)), a) {
    s = `${o}-${e}-${a}`;
    const f = r.get(s) || /* @__PURE__ */ new Map();
    r.set(s, f.set(n, t));
  }
}
function R5(e, t, n) {
  e.clear(), t.clear();
  for (const r of n) {
    const { source: o, target: a, sourceHandle: s = null, targetHandle: u = null } = r, c = { edgeId: r.id, source: o, target: a, sourceHandle: s, targetHandle: u }, f = `${o}-${s}--${a}-${u}`, h = `${a}-${u}--${o}-${s}`;
    RA("source", c, h, e, o, s), RA("target", c, f, e, a, u), t.set(r.id, r);
  }
}
function M5(e, t) {
  if (!e.parentId)
    return !1;
  const n = t.get(e.parentId);
  return n ? n.selected ? !0 : M5(n, t) : !1;
}
function MA(e, t, n) {
  let r = e;
  do {
    if (r?.matches?.(t))
      return !0;
    if (r === n)
      return !1;
    r = r?.parentElement;
  } while (r);
  return !1;
}
function Nte(e, t, n, r) {
  const o = /* @__PURE__ */ new Map();
  for (const [a, s] of e)
    if ((s.selected || s.id === r) && (!s.parentId || !M5(s, e)) && (s.draggable || t && typeof s.draggable > "u")) {
      const u = e.get(a);
      u && o.set(a, {
        id: a,
        position: u.position || { x: 0, y: 0 },
        distance: {
          x: n.x - u.internals.positionAbsolute.x,
          y: n.y - u.internals.positionAbsolute.y
        },
        extent: u.extent,
        parentId: u.parentId,
        origin: u.origin,
        expandParent: u.expandParent,
        internals: {
          positionAbsolute: u.internals.positionAbsolute || { x: 0, y: 0 }
        },
        measured: {
          width: u.measured.width ?? 0,
          height: u.measured.height ?? 0
        }
      });
    }
  return o;
}
function hv({ nodeId: e, dragItems: t, nodeLookup: n, dragging: r = !0 }) {
  const o = [];
  for (const [s, u] of t) {
    const c = n.get(s)?.internals.userNode;
    c && o.push({
      ...c,
      position: u.position,
      dragging: r
    });
  }
  if (!e)
    return [o[0], o];
  const a = n.get(e)?.internals.userNode;
  return [
    a ? {
      ...a,
      position: t.get(e)?.position || a.position,
      dragging: r
    } : o[0],
    o
  ];
}
function Dte({ onNodeMouseDown: e, getStoreItems: t, onDragStart: n, onDrag: r, onDragStop: o }) {
  let a = { x: null, y: null }, s = 0, u = /* @__PURE__ */ new Map(), c = !1, f = { x: 0, y: 0 }, h = null, p = !1, g = null, y = !1, w = !1;
  function v({ noDragClassName: E, handleSelector: T, domNode: k, isSelectable: A, nodeId: M, nodeClickDistance: N = 0 }) {
    g = rr(k);
    function P({ x: F, y: U }, W) {
      const { nodeLookup: j, nodeExtent: V, snapGrid: I, snapToGrid: H, nodeOrigin: q, onNodeDrag: G, onSelectionDrag: O, onError: Y, updateNodePositions: Z } = t();
      a = { x: F, y: U };
      let L = !1, te = { x: 0, y: 0, x2: 0, y2: 0 };
      if (u.size > 1 && V) {
        const he = vf(u);
        te = Ib(he);
      }
      for (const [he, oe] of u) {
        if (!j.has(he))
          continue;
        let de = { x: F - oe.distance.x, y: U - oe.distance.y };
        H && (de = jm(de, I));
        let le = [
          [V[0][0], V[0][1]],
          [V[1][0], V[1][1]]
        ];
        if (u.size > 1 && V && !oe.extent) {
          const { positionAbsolute: Ne } = oe.internals, we = Ne.x - te.x + V[0][0], Ee = Ne.x + oe.measured.width - te.x2 + V[1][0], _e = Ne.y - te.y + V[0][1], Xe = Ne.y + oe.measured.height - te.y2 + V[1][1];
          le = [
            [we, _e],
            [Ee, Xe]
          ];
        }
        const { position: ye, positionAbsolute: je } = g5({
          nodeId: he,
          nextPosition: de,
          nodeLookup: j,
          nodeExtent: le,
          nodeOrigin: q,
          onError: Y
        });
        L = L || oe.position.x !== ye.x || oe.position.y !== ye.y, oe.position = ye, oe.internals.positionAbsolute = je;
      }
      if (w = w || L, !!L && (Z(u, !0), W && (r || G || !M && O))) {
        const [he, oe] = hv({
          nodeId: M,
          dragItems: u,
          nodeLookup: j
        });
        r?.(W, u, he, oe), G?.(W, he, oe), M || O?.(W, oe);
      }
    }
    async function z() {
      if (!h)
        return;
      const { transform: F, panBy: U, autoPanSpeed: W, autoPanOnNodeDrag: j } = t();
      if (!j) {
        c = !1, cancelAnimationFrame(s);
        return;
      }
      const [V, I] = v5(f, h, W);
      (V !== 0 || I !== 0) && (a.x = (a.x ?? 0) - V / F[2], a.y = (a.y ?? 0) - I / F[2], await U({ x: V, y: I }) && P(a, null)), s = requestAnimationFrame(z);
    }
    function B(F) {
      const { nodeLookup: U, multiSelectionActive: W, nodesDraggable: j, transform: V, snapGrid: I, snapToGrid: H, selectNodesOnDrag: q, onNodeDragStart: G, onSelectionDragStart: O, unselectNodesAndEdges: Y } = t();
      p = !0, (!q || !A) && !W && M && (U.get(M)?.selected || Y()), A && q && M && e?.(M);
      const Z = xc(F.sourceEvent, { transform: V, snapGrid: I, snapToGrid: H, containerBounds: h });
      if (a = Z, u = Nte(U, j, Z, M), u.size > 0 && (n || G || !M && O)) {
        const [L, te] = hv({
          nodeId: M,
          dragItems: u,
          nodeLookup: U
        });
        n?.(F.sourceEvent, u, L, te), G?.(F.sourceEvent, L, te), M || O?.(F.sourceEvent, te);
      }
    }
    const R = X3().clickDistance(N).on("start", (F) => {
      const { domNode: U, nodeDragThreshold: W, transform: j, snapGrid: V, snapToGrid: I } = t();
      h = U?.getBoundingClientRect() || null, y = !1, w = !1, W === 0 && B(F), a = xc(F.sourceEvent, { transform: j, snapGrid: V, snapToGrid: I, containerBounds: h }), f = fo(F.sourceEvent, h);
    }).on("drag", (F) => {
      const { autoPanOnNodeDrag: U, transform: W, snapGrid: j, snapToGrid: V, nodeDragThreshold: I, nodeLookup: H } = t(), q = xc(F.sourceEvent, { transform: W, snapGrid: j, snapToGrid: V, containerBounds: h });
      if ((F.sourceEvent.type === "touchmove" && F.sourceEvent.touches.length > 1 || // if user deletes a node while dragging, we need to abort the drag to prevent errors
      M && !H.has(M)) && (y = !0), !y) {
        if (!c && U && p && (c = !0, z()), !p) {
          const G = q.xSnapped - (a.x ?? 0), O = q.ySnapped - (a.y ?? 0);
          Math.sqrt(G * G + O * O) > I && B(F);
        }
        (a.x !== q.xSnapped || a.y !== q.ySnapped) && u && p && (f = fo(F.sourceEvent, h), P(q, F.sourceEvent));
      }
    }).on("end", (F) => {
      if (!(!p || y) && (c = !1, p = !1, cancelAnimationFrame(s), u.size > 0)) {
        const { nodeLookup: U, updateNodePositions: W, onNodeDragStop: j, onSelectionDragStop: V } = t();
        if (w && (W(u, !1), w = !1), o || j || !M && V) {
          const [I, H] = hv({
            nodeId: M,
            dragItems: u,
            nodeLookup: U,
            dragging: !1
          });
          o?.(F.sourceEvent, u, I, H), j?.(F.sourceEvent, I, H), M || V?.(F.sourceEvent, H);
        }
      }
    }).filter((F) => {
      const U = F.target;
      return !F.button && (!E || !MA(U, `.${E}`, k)) && (!T || MA(U, T, k));
    });
    g.call(R);
  }
  function S() {
    g?.on(".drag", null);
  }
  return {
    update: v,
    destroy: S
  };
}
function Pte(e, t, n) {
  const r = [], o = {
    x: e.x - n,
    y: e.y - n,
    width: n * 2,
    height: n * 2
  };
  for (const a of t.values())
    Uc(o, Tl(a)) > 0 && r.push(a);
  return r;
}
const jte = 250;
function Ite(e, t, n, r) {
  let o = [], a = 1 / 0;
  const s = Pte(e, n, t + jte);
  for (const u of s) {
    const c = [...u.internals.handleBounds?.source ?? [], ...u.internals.handleBounds?.target ?? []];
    for (const f of c) {
      if (r.nodeId === f.nodeId && r.type === f.type && r.id === f.id)
        continue;
      const { x: h, y: p } = qc(u, f, f.position, !0), g = Math.sqrt(Math.pow(h - e.x, 2) + Math.pow(p - e.y, 2));
      g > t || (g < a ? (o = [{ ...f, x: h, y: p }], a = g) : g === a && o.push({ ...f, x: h, y: p }));
    }
  }
  if (!o.length)
    return null;
  if (o.length > 1) {
    const u = r.type === "source" ? "target" : "source";
    return o.find((c) => c.type === u) ?? o[0];
  }
  return o[0];
}
function O5(e, t, n, r, o, a = !1) {
  const s = r.get(e);
  if (!s)
    return null;
  const u = o === "strict" ? s.internals.handleBounds?.[t] : [...s.internals.handleBounds?.source ?? [], ...s.internals.handleBounds?.target ?? []], c = (n ? u?.find((f) => f.id === n) : u?.[0]) ?? null;
  return c && a ? { ...c, ...qc(s, c, c.position, !0) } : c;
}
function N5(e, t) {
  return e || (t?.classList.contains("target") ? "target" : t?.classList.contains("source") ? "source" : null);
}
function zte(e, t) {
  let n = null;
  return t ? n = !0 : e && !t && (n = !1), n;
}
const D5 = () => !0;
function Lte(e, { connectionMode: t, connectionRadius: n, handleId: r, nodeId: o, edgeUpdaterType: a, isTarget: s, domNode: u, nodeLookup: c, lib: f, autoPanOnConnect: h, flowId: p, panBy: g, cancelConnection: y, onConnectStart: w, onConnect: v, onConnectEnd: S, isValidConnection: E = D5, onReconnectEnd: T, updateConnection: k, getTransform: A, getFromHandle: M, autoPanSpeed: N, dragThreshold: P = 1 }) {
  const z = _5(e.target);
  let B = 0, R;
  const { x: F, y: U } = fo(e), W = z?.elementFromPoint(F, U), j = N5(a, W), V = u?.getBoundingClientRect();
  let I = !1;
  if (!V || !j)
    return;
  const H = O5(o, j, r, c, t);
  if (!H)
    return;
  let q = fo(e, V), G = !1, O = null, Y = !1, Z = null;
  function L() {
    if (!h || !V)
      return;
    const [Ne, we] = v5(q, V, N);
    g({ x: Ne, y: we }), B = requestAnimationFrame(L);
  }
  const te = {
    ...H,
    nodeId: o,
    type: j,
    position: H.position
  }, he = c.get(o);
  let de = {
    inProgress: !0,
    isValid: null,
    from: qc(he, te, Te.Left, !0),
    fromHandle: te,
    fromPosition: te.position,
    fromNode: he,
    to: q,
    toHandle: null,
    toPosition: vA[te.position],
    toNode: null
  };
  function le() {
    I = !0, k(de), w?.(e, { nodeId: o, handleId: r, handleType: j });
  }
  P === 0 && le();
  function ye(Ne) {
    if (!I) {
      const { x: Xe, y: St } = fo(Ne), ct = Xe - F, cn = St - U;
      if (!(ct * ct + cn * cn > P * P))
        return;
      le();
    }
    if (!M() || !te) {
      je(Ne);
      return;
    }
    const we = A();
    q = fo(Ne, V), R = Ite(bf(q, we, !1, [1, 1]), n, c, te), G || (L(), G = !0);
    const Ee = P5(Ne, {
      handle: R,
      connectionMode: t,
      fromNodeId: o,
      fromHandleId: r,
      fromType: s ? "target" : "source",
      isValidConnection: E,
      doc: z,
      lib: f,
      flowId: p,
      nodeLookup: c
    });
    Z = Ee.handleDomNode, O = Ee.connection, Y = zte(!!R, Ee.isValid);
    const _e = {
      // from stays the same
      ...de,
      isValid: Y,
      to: Ee.toHandle && Y ? Cp({ x: Ee.toHandle.x, y: Ee.toHandle.y }, we) : q,
      toHandle: Ee.toHandle,
      toPosition: Y && Ee.toHandle ? Ee.toHandle.position : vA[te.position],
      toNode: Ee.toHandle ? c.get(Ee.toHandle.nodeId) : null
    };
    Y && R && de.toHandle && _e.toHandle && de.toHandle.type === _e.toHandle.type && de.toHandle.nodeId === _e.toHandle.nodeId && de.toHandle.id === _e.toHandle.id && de.to.x === _e.to.x && de.to.y === _e.to.y || (k(_e), de = _e);
  }
  function je(Ne) {
    if (I) {
      (R || Z) && O && Y && v?.(O);
      const { inProgress: we, ...Ee } = de, _e = {
        ...Ee,
        toPosition: de.toHandle ? de.toPosition : null
      };
      S?.(Ne, _e), a && T?.(Ne, _e);
    }
    y(), cancelAnimationFrame(B), G = !1, Y = !1, O = null, Z = null, z.removeEventListener("mousemove", ye), z.removeEventListener("mouseup", je), z.removeEventListener("touchmove", ye), z.removeEventListener("touchend", je);
  }
  z.addEventListener("mousemove", ye), z.addEventListener("mouseup", je), z.addEventListener("touchmove", ye), z.addEventListener("touchend", je);
}
function P5(e, { handle: t, connectionMode: n, fromNodeId: r, fromHandleId: o, fromType: a, doc: s, lib: u, flowId: c, isValidConnection: f = D5, nodeLookup: h }) {
  const p = a === "target", g = t ? s.querySelector(`.${u}-flow__handle[data-id="${c}-${t?.nodeId}-${t?.id}-${t?.type}"]`) : null, { x: y, y: w } = fo(e), v = s.elementFromPoint(y, w), S = v?.classList.contains(`${u}-flow__handle`) ? v : g, E = {
    handleDomNode: S,
    isValid: !1,
    connection: null,
    toHandle: null
  };
  if (S) {
    const T = N5(void 0, S), k = S.getAttribute("data-nodeid"), A = S.getAttribute("data-handleid"), M = S.classList.contains("connectable"), N = S.classList.contains("connectableend");
    if (!k || !T)
      return E;
    const P = {
      source: p ? k : r,
      sourceHandle: p ? A : o,
      target: p ? r : k,
      targetHandle: p ? o : A
    };
    E.connection = P;
    const B = M && N && (n === Cl.Strict ? p && T === "source" || !p && T === "target" : k !== r || A !== o);
    E.isValid = B && f(P), E.toHandle = O5(k, T, A, h, n, !0);
  }
  return E;
}
const $b = {
  onPointerDown: Lte,
  isValid: P5
};
function Fte({ domNode: e, panZoom: t, getTransform: n, getViewScale: r }) {
  const o = rr(e);
  function a({ translateExtent: u, width: c, height: f, zoomStep: h = 10, pannable: p = !0, zoomable: g = !0, inversePan: y = !1 }) {
    const w = (k) => {
      const A = n();
      if (k.sourceEvent.type !== "wheel" || !t)
        return;
      const M = -k.sourceEvent.deltaY * (k.sourceEvent.deltaMode === 1 ? 0.05 : k.sourceEvent.deltaMode ? 1 : 2e-3) * h, N = A[2] * Math.pow(2, M);
      t.scaleTo(N);
    };
    let v = [0, 0];
    const S = (k) => {
      (k.sourceEvent.type === "mousedown" || k.sourceEvent.type === "touchstart") && (v = [
        k.sourceEvent.clientX ?? k.sourceEvent.touches[0].clientX,
        k.sourceEvent.clientY ?? k.sourceEvent.touches[0].clientY
      ]);
    }, E = (k) => {
      const A = n();
      if (k.sourceEvent.type !== "mousemove" && k.sourceEvent.type !== "touchmove" || !t)
        return;
      const M = [
        k.sourceEvent.clientX ?? k.sourceEvent.touches[0].clientX,
        k.sourceEvent.clientY ?? k.sourceEvent.touches[0].clientY
      ], N = [M[0] - v[0], M[1] - v[1]];
      v = M;
      const P = r() * Math.max(A[2], Math.log(A[2])) * (y ? -1 : 1), z = {
        x: A[0] - N[0] * P,
        y: A[1] - N[1] * P
      }, B = [
        [0, 0],
        [c, f]
      ];
      t.setViewportConstrained({
        x: z.x,
        y: z.y,
        zoom: A[2]
      }, B, u);
    }, T = c5().on("start", S).on("zoom", p ? E : null).on("zoom.wheel", g ? w : null);
    o.call(T, {});
  }
  function s() {
    o.on("zoom", null);
  }
  return {
    update: a,
    destroy: s,
    pointer: Dr
  };
}
const $te = (e, t) => e.x !== t.x || e.y !== t.y || e.zoom !== t.k, Im = (e) => ({
  x: e.x,
  y: e.y,
  zoom: e.k
}), pv = ({ x: e, y: t, zoom: n }) => Nm.translate(e, t).scale(n), ol = (e, t) => e.target.closest(`.${t}`), j5 = (e, t) => t === 2 && Array.isArray(e) && e.includes(2), Bte = (e) => ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2, mv = (e, t = 0, n = Bte, r = () => {
}) => {
  const o = typeof t == "number" && t > 0;
  return o || r(), o ? e.transition().duration(t).ease(n).on("end", r) : e;
}, I5 = (e) => {
  const t = e.ctrlKey && kp() ? 10 : 1;
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * t;
};
function Hte({ zoomPanValues: e, noWheelClassName: t, d3Selection: n, d3Zoom: r, panOnScrollMode: o, panOnScrollSpeed: a, zoomOnPinch: s, onPanZoomStart: u, onPanZoom: c, onPanZoomEnd: f }) {
  return (h) => {
    if (ol(h, t))
      return !1;
    h.preventDefault(), h.stopImmediatePropagation();
    const p = n.property("__zoom").k || 1;
    if (h.ctrlKey && s) {
      const S = Dr(h), E = I5(h), T = p * Math.pow(2, E);
      r.scaleTo(n, T, S, h);
      return;
    }
    const g = h.deltaMode === 1 ? 20 : 1;
    let y = o === Ba.Vertical ? 0 : h.deltaX * g, w = o === Ba.Horizontal ? 0 : h.deltaY * g;
    !kp() && h.shiftKey && o !== Ba.Vertical && (y = h.deltaY * g, w = 0), r.translateBy(
      n,
      -(y / p) * a,
      -(w / p) * a,
      // @ts-ignore
      { internal: !0 }
    );
    const v = Im(n.property("__zoom"));
    clearTimeout(e.panScrollTimeout), e.isPanScrolling || (e.isPanScrolling = !0, u?.(h, v)), e.isPanScrolling && (c?.(h, v), e.panScrollTimeout = setTimeout(() => {
      f?.(h, v), e.isPanScrolling = !1;
    }, 150));
  };
}
function Vte({ noWheelClassName: e, preventScrolling: t, d3ZoomHandler: n }) {
  return function(r, o) {
    const a = r.type === "wheel", s = !t && a && !r.ctrlKey, u = ol(r, e);
    if (r.ctrlKey && a && u && r.preventDefault(), s || u)
      return null;
    r.preventDefault(), n.call(this, r, o);
  };
}
function Ute({ zoomPanValues: e, onDraggingChange: t, onPanZoomStart: n }) {
  return (r) => {
    if (r.sourceEvent?.internal)
      return;
    const o = Im(r.transform);
    e.mouseButton = r.sourceEvent?.button || 0, e.isZoomingOrPanning = !0, e.prevViewport = o, r.sourceEvent?.type === "mousedown" && t(!0), n && n?.(r.sourceEvent, o);
  };
}
function qte({ zoomPanValues: e, panOnDrag: t, onPaneContextMenu: n, onTransformChange: r, onPanZoom: o }) {
  return (a) => {
    e.usedRightMouseButton = !!(n && j5(t, e.mouseButton ?? 0)), a.sourceEvent?.sync || r([a.transform.x, a.transform.y, a.transform.k]), o && !a.sourceEvent?.internal && o?.(a.sourceEvent, Im(a.transform));
  };
}
function Gte({ zoomPanValues: e, panOnDrag: t, panOnScroll: n, onDraggingChange: r, onPanZoomEnd: o, onPaneContextMenu: a }) {
  return (s) => {
    if (!s.sourceEvent?.internal && (e.isZoomingOrPanning = !1, a && j5(t, e.mouseButton ?? 0) && !e.usedRightMouseButton && s.sourceEvent && a(s.sourceEvent), e.usedRightMouseButton = !1, r(!1), o && $te(e.prevViewport, s.transform))) {
      const u = Im(s.transform);
      e.prevViewport = u, clearTimeout(e.timerId), e.timerId = setTimeout(
        () => {
          o?.(s.sourceEvent, u);
        },
        // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
        n ? 150 : 0
      );
    }
  };
}
function Yte({ zoomActivationKeyPressed: e, zoomOnScroll: t, zoomOnPinch: n, panOnDrag: r, panOnScroll: o, zoomOnDoubleClick: a, userSelectionActive: s, noWheelClassName: u, noPanClassName: c, lib: f }) {
  return (h) => {
    const p = e || t, g = n && h.ctrlKey;
    if (h.button === 1 && h.type === "mousedown" && (ol(h, `${f}-flow__node`) || ol(h, `${f}-flow__edge`)))
      return !0;
    if (!r && !p && !o && !a && !n || s || ol(h, u) && h.type === "wheel" || ol(h, c) && (h.type !== "wheel" || o && h.type === "wheel" && !e) || !n && h.ctrlKey && h.type === "wheel")
      return !1;
    if (!n && h.type === "touchstart" && h.touches?.length > 1)
      return h.preventDefault(), !1;
    if (!p && !o && !g && h.type === "wheel" || !r && (h.type === "mousedown" || h.type === "touchstart") || Array.isArray(r) && !r.includes(h.button) && h.type === "mousedown")
      return !1;
    const y = Array.isArray(r) && r.includes(h.button) || !h.button || h.button <= 1;
    return (!h.ctrlKey || h.type === "wheel") && y;
  };
}
function Wte({ domNode: e, minZoom: t, maxZoom: n, paneClickDistance: r, translateExtent: o, viewport: a, onPanZoom: s, onPanZoomStart: u, onPanZoomEnd: c, onDraggingChange: f }) {
  const h = {
    isZoomingOrPanning: !1,
    usedRightMouseButton: !1,
    prevViewport: { x: 0, y: 0, zoom: 0 },
    mouseButton: 0,
    timerId: void 0,
    panScrollTimeout: void 0,
    isPanScrolling: !1
  }, p = e.getBoundingClientRect(), g = c5().clickDistance(!Ir(r) || r < 0 ? 0 : r).scaleExtent([t, n]).translateExtent(o), y = rr(e).call(g);
  k({
    x: a.x,
    y: a.y,
    zoom: kl(a.zoom, t, n)
  }, [
    [0, 0],
    [p.width, p.height]
  ], o);
  const w = y.on("wheel.zoom"), v = y.on("dblclick.zoom");
  g.wheelDelta(I5);
  function S(U, W) {
    return y ? new Promise((j) => {
      g?.interpolate(W?.interpolate === "linear" ? bc : Vh).transform(mv(y, W?.duration, W?.ease, () => j(!0)), U);
    }) : Promise.resolve(!1);
  }
  function E({ noWheelClassName: U, noPanClassName: W, onPaneContextMenu: j, userSelectionActive: V, panOnScroll: I, panOnDrag: H, panOnScrollMode: q, panOnScrollSpeed: G, preventScrolling: O, zoomOnPinch: Y, zoomOnScroll: Z, zoomOnDoubleClick: L, zoomActivationKeyPressed: te, lib: he, onTransformChange: oe }) {
    V && !h.isZoomingOrPanning && T();
    const le = I && !te && !V ? Hte({
      zoomPanValues: h,
      noWheelClassName: U,
      d3Selection: y,
      d3Zoom: g,
      panOnScrollMode: q,
      panOnScrollSpeed: G,
      zoomOnPinch: Y,
      onPanZoomStart: u,
      onPanZoom: s,
      onPanZoomEnd: c
    }) : Vte({
      noWheelClassName: U,
      preventScrolling: O,
      d3ZoomHandler: w
    });
    if (y.on("wheel.zoom", le, { passive: !1 }), !V) {
      const je = Ute({
        zoomPanValues: h,
        onDraggingChange: f,
        onPanZoomStart: u
      });
      g.on("start", je);
      const Ne = qte({
        zoomPanValues: h,
        panOnDrag: H,
        onPaneContextMenu: !!j,
        onPanZoom: s,
        onTransformChange: oe
      });
      g.on("zoom", Ne);
      const we = Gte({
        zoomPanValues: h,
        panOnDrag: H,
        panOnScroll: I,
        onPaneContextMenu: j,
        onPanZoomEnd: c,
        onDraggingChange: f
      });
      g.on("end", we);
    }
    const ye = Yte({
      zoomActivationKeyPressed: te,
      panOnDrag: H,
      zoomOnScroll: Z,
      panOnScroll: I,
      zoomOnDoubleClick: L,
      zoomOnPinch: Y,
      userSelectionActive: V,
      noPanClassName: W,
      noWheelClassName: U,
      lib: he
    });
    g.filter(ye), L ? y.on("dblclick.zoom", v) : y.on("dblclick.zoom", null);
  }
  function T() {
    g.on("zoom", null);
  }
  async function k(U, W, j) {
    const V = pv(U), I = g?.constrain()(V, W, j);
    return I && await S(I), new Promise((H) => H(I));
  }
  async function A(U, W) {
    const j = pv(U);
    return await S(j, W), new Promise((V) => V(j));
  }
  function M(U) {
    if (y) {
      const W = pv(U), j = y.property("__zoom");
      (j.k !== U.zoom || j.x !== U.x || j.y !== U.y) && g?.transform(y, W, null, { sync: !0 });
    }
  }
  function N() {
    const U = y ? u5(y.node()) : { x: 0, y: 0, k: 1 };
    return { x: U.x, y: U.y, zoom: U.k };
  }
  function P(U, W) {
    return y ? new Promise((j) => {
      g?.interpolate(W?.interpolate === "linear" ? bc : Vh).scaleTo(mv(y, W?.duration, W?.ease, () => j(!0)), U);
    }) : Promise.resolve(!1);
  }
  function z(U, W) {
    return y ? new Promise((j) => {
      g?.interpolate(W?.interpolate === "linear" ? bc : Vh).scaleBy(mv(y, W?.duration, W?.ease, () => j(!0)), U);
    }) : Promise.resolve(!1);
  }
  function B(U) {
    g?.scaleExtent(U);
  }
  function R(U) {
    g?.translateExtent(U);
  }
  function F(U) {
    const W = !Ir(U) || U < 0 ? 0 : U;
    g?.clickDistance(W);
  }
  return {
    update: E,
    destroy: T,
    setViewport: A,
    setViewportConstrained: k,
    getViewport: N,
    scaleTo: P,
    scaleBy: z,
    setScaleExtent: B,
    setTranslateExtent: R,
    syncViewport: M,
    setClickDistance: F
  };
}
var Rl;
(function(e) {
  e.Line = "line", e.Handle = "handle";
})(Rl || (Rl = {}));
function Xte({ width: e, prevWidth: t, height: n, prevHeight: r, affectsX: o, affectsY: a }) {
  const s = e - t, u = n - r, c = [s > 0 ? 1 : s < 0 ? -1 : 0, u > 0 ? 1 : u < 0 ? -1 : 0];
  return s && o && (c[0] = c[0] * -1), u && a && (c[1] = c[1] * -1), c;
}
function Kte(e) {
  const t = e.includes("right") || e.includes("left"), n = e.includes("bottom") || e.includes("top"), r = e.includes("left"), o = e.includes("top");
  return {
    isHorizontal: t,
    isVertical: n,
    affectsX: r,
    affectsY: o
  };
}
function Vi(e, t) {
  return Math.max(0, t - e);
}
function Ui(e, t) {
  return Math.max(0, e - t);
}
function bh(e, t, n) {
  return Math.max(0, t - e, e - n);
}
function OA(e, t) {
  return e ? !t : t;
}
function Zte(e, t, n, r, o, a, s, u) {
  let { affectsX: c, affectsY: f } = t;
  const { isHorizontal: h, isVertical: p } = t, g = h && p, { xSnapped: y, ySnapped: w } = n, { minWidth: v, maxWidth: S, minHeight: E, maxHeight: T } = r, { x: k, y: A, width: M, height: N, aspectRatio: P } = e;
  let z = Math.floor(h ? y - e.pointerX : 0), B = Math.floor(p ? w - e.pointerY : 0);
  const R = M + (c ? -z : z), F = N + (f ? -B : B), U = -a[0] * M, W = -a[1] * N;
  let j = bh(R, v, S), V = bh(F, E, T);
  if (s) {
    let q = 0, G = 0;
    c && z < 0 ? q = Vi(k + z + U, s[0][0]) : !c && z > 0 && (q = Ui(k + R + U, s[1][0])), f && B < 0 ? G = Vi(A + B + W, s[0][1]) : !f && B > 0 && (G = Ui(A + F + W, s[1][1])), j = Math.max(j, q), V = Math.max(V, G);
  }
  if (u) {
    let q = 0, G = 0;
    c && z > 0 ? q = Ui(k + z, u[0][0]) : !c && z < 0 && (q = Vi(k + R, u[1][0])), f && B > 0 ? G = Ui(A + B, u[0][1]) : !f && B < 0 && (G = Vi(A + F, u[1][1])), j = Math.max(j, q), V = Math.max(V, G);
  }
  if (o) {
    if (h) {
      const q = bh(R / P, E, T) * P;
      if (j = Math.max(j, q), s) {
        let G = 0;
        !c && !f || c && !f && g ? G = Ui(A + W + R / P, s[1][1]) * P : G = Vi(A + W + (c ? z : -z) / P, s[0][1]) * P, j = Math.max(j, G);
      }
      if (u) {
        let G = 0;
        !c && !f || c && !f && g ? G = Vi(A + R / P, u[1][1]) * P : G = Ui(A + (c ? z : -z) / P, u[0][1]) * P, j = Math.max(j, G);
      }
    }
    if (p) {
      const q = bh(F * P, v, S) / P;
      if (V = Math.max(V, q), s) {
        let G = 0;
        !c && !f || f && !c && g ? G = Ui(k + F * P + U, s[1][0]) / P : G = Vi(k + (f ? B : -B) * P + U, s[0][0]) / P, V = Math.max(V, G);
      }
      if (u) {
        let G = 0;
        !c && !f || f && !c && g ? G = Vi(k + F * P, u[1][0]) / P : G = Ui(k + (f ? B : -B) * P, u[0][0]) / P, V = Math.max(V, G);
      }
    }
  }
  B = B + (B < 0 ? V : -V), z = z + (z < 0 ? j : -j), o && (g ? R > F * P ? B = (OA(c, f) ? -z : z) / P : z = (OA(c, f) ? -B : B) * P : h ? (B = z / P, f = c) : (z = B * P, c = f));
  const I = c ? k + z : k, H = f ? A + B : A;
  return {
    width: M + (c ? -z : z),
    height: N + (f ? -B : B),
    x: a[0] * z * (c ? -1 : 1) + I,
    y: a[1] * B * (f ? -1 : 1) + H
  };
}
const z5 = { width: 0, height: 0, x: 0, y: 0 }, Qte = {
  ...z5,
  pointerX: 0,
  pointerY: 0,
  aspectRatio: 1
};
function Jte(e) {
  return [
    [0, 0],
    [e.measured.width, e.measured.height]
  ];
}
function ene(e, t, n) {
  const r = t.position.x + e.position.x, o = t.position.y + e.position.y, a = e.measured.width ?? 0, s = e.measured.height ?? 0, u = n[0] * a, c = n[1] * s;
  return [
    [r - u, o - c],
    [r + a - u, o + s - c]
  ];
}
function tne({ domNode: e, nodeId: t, getStoreItems: n, onChange: r, onEnd: o }) {
  const a = rr(e);
  function s({ controlPosition: c, boundaries: f, keepAspectRatio: h, resizeDirection: p, onResizeStart: g, onResize: y, onResizeEnd: w, shouldResize: v }) {
    let S = { ...z5 }, E = { ...Qte };
    const T = Kte(c);
    let k, A = null, M = [], N, P, z;
    const B = X3().on("start", (R) => {
      const { nodeLookup: F, transform: U, snapGrid: W, snapToGrid: j, nodeOrigin: V, paneDomNode: I } = n();
      if (k = F.get(t), !k)
        return;
      A = I?.getBoundingClientRect() ?? null;
      const { xSnapped: H, ySnapped: q } = xc(R.sourceEvent, {
        transform: U,
        snapGrid: W,
        snapToGrid: j,
        containerBounds: A
      });
      S = {
        width: k.measured.width ?? 0,
        height: k.measured.height ?? 0,
        x: k.position.x ?? 0,
        y: k.position.y ?? 0
      }, E = {
        ...S,
        pointerX: H,
        pointerY: q,
        aspectRatio: S.width / S.height
      }, N = void 0, k.parentId && (k.extent === "parent" || k.expandParent) && (N = F.get(k.parentId), P = N && k.extent === "parent" ? Jte(N) : void 0), M = [], z = void 0;
      for (const [G, O] of F)
        if (O.parentId === t && (M.push({
          id: G,
          position: { ...O.position },
          extent: O.extent
        }), O.extent === "parent" || O.expandParent)) {
          const Y = ene(O, k, O.origin ?? V);
          z ? z = [
            [Math.min(Y[0][0], z[0][0]), Math.min(Y[0][1], z[0][1])],
            [Math.max(Y[1][0], z[1][0]), Math.max(Y[1][1], z[1][1])]
          ] : z = Y;
        }
      g?.(R, { ...S });
    }).on("drag", (R) => {
      const { transform: F, snapGrid: U, snapToGrid: W, nodeOrigin: j } = n(), V = xc(R.sourceEvent, {
        transform: F,
        snapGrid: U,
        snapToGrid: W,
        containerBounds: A
      }), I = [];
      if (!k)
        return;
      const { x: H, y: q, width: G, height: O } = S, Y = {}, Z = k.origin ?? j, { width: L, height: te, x: he, y: oe } = Zte(E, T, V, f, h, Z, P, z), de = L !== G, le = te !== O, ye = he !== H && de, je = oe !== q && le;
      if (!ye && !je && !de && !le)
        return;
      if ((ye || je || Z[0] === 1 || Z[1] === 1) && (Y.x = ye ? he : S.x, Y.y = je ? oe : S.y, S.x = Y.x, S.y = Y.y, M.length > 0)) {
        const _e = he - H, Xe = oe - q;
        for (const St of M)
          St.position = {
            x: St.position.x - _e + Z[0] * (L - G),
            y: St.position.y - Xe + Z[1] * (te - O)
          }, I.push(St);
      }
      if ((de || le) && (Y.width = de && (!p || p === "horizontal") ? L : S.width, Y.height = le && (!p || p === "vertical") ? te : S.height, S.width = Y.width, S.height = Y.height), N && k.expandParent) {
        const _e = Z[0] * (Y.width ?? 0);
        Y.x && Y.x < _e && (S.x = _e, E.x = E.x - (Y.x - _e));
        const Xe = Z[1] * (Y.height ?? 0);
        Y.y && Y.y < Xe && (S.y = Xe, E.y = E.y - (Y.y - Xe));
      }
      const Ne = Xte({
        width: S.width,
        prevWidth: G,
        height: S.height,
        prevHeight: O,
        affectsX: T.affectsX,
        affectsY: T.affectsY
      }), we = { ...S, direction: Ne };
      v?.(R, we) !== !1 && (y?.(R, we), r(Y, I));
    }).on("end", (R) => {
      w?.(R, { ...S }), o?.({ ...S });
    });
    a.call(B);
  }
  function u() {
    a.on(".drag", null);
  }
  return {
    update: s,
    destroy: u
  };
}
const { useDebugValue: nne } = nn, { useSyncExternalStoreWithSelector: rne } = n3, one = (e) => e;
function L5(e, t = one, n) {
  const r = rne(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return nne(r), r;
}
const NA = (e, t) => {
  const n = t3(e), r = (o, a = t) => L5(n, o, a);
  return Object.assign(r, n), r;
}, ine = (e, t) => e ? NA(e, t) : NA;
function At(e, t) {
  if (Object.is(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  if (e instanceof Map && t instanceof Map) {
    if (e.size !== t.size) return !1;
    for (const [r, o] of e)
      if (!Object.is(o, t.get(r)))
        return !1;
    return !0;
  }
  if (e instanceof Set && t instanceof Set) {
    if (e.size !== t.size) return !1;
    for (const r of e)
      if (!t.has(r))
        return !1;
    return !0;
  }
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
    return !1;
  for (const r of n)
    if (!Object.prototype.hasOwnProperty.call(t, r) || !Object.is(e[r], t[r]))
      return !1;
  return !0;
}
const zm = _.createContext(null), ane = zm.Provider, F5 = vo.error001();
function Je(e, t) {
  const n = _.useContext(zm);
  if (n === null)
    throw new Error(F5);
  return L5(n, e, t);
}
function kt() {
  const e = _.useContext(zm);
  if (e === null)
    throw new Error(F5);
  return _.useMemo(() => ({
    getState: e.getState,
    setState: e.setState,
    subscribe: e.subscribe
  }), [e]);
}
const DA = { display: "none" }, sne = {
  position: "absolute",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0px, 0px, 0px, 0px)",
  clipPath: "inset(100%)"
}, $5 = "react-flow__node-desc", B5 = "react-flow__edge-desc", lne = "react-flow__aria-live", une = (e) => e.ariaLiveMessage, cne = (e) => e.ariaLabelConfig;
function fne({ rfId: e }) {
  const t = Je(une);
  return x.jsx("div", { id: `${lne}-${e}`, "aria-live": "assertive", "aria-atomic": "true", style: sne, children: t });
}
function dne({ rfId: e, disableKeyboardA11y: t }) {
  const n = Je(cne);
  return x.jsxs(x.Fragment, { children: [x.jsx("div", { id: `${$5}-${e}`, style: DA, children: t ? n["node.a11yDescription.default"] : n["node.a11yDescription.keyboardDisabled"] }), x.jsx("div", { id: `${B5}-${e}`, style: DA, children: n["edge.a11yDescription.default"] }), !t && x.jsx(fne, { rfId: e })] });
}
const Lm = _.forwardRef(({ position: e = "top-left", children: t, className: n, style: r, ...o }, a) => {
  const s = `${e}`.split("-");
  return x.jsx("div", { className: Wt(["react-flow__panel", n, ...s]), style: r, ref: a, ...o, children: t });
});
Lm.displayName = "Panel";
function hne({ proOptions: e, position: t = "bottom-right" }) {
  return e?.hideAttribution ? null : x.jsx(Lm, { position: t, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev", children: x.jsx("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution", children: "React Flow" }) });
}
const pne = (e) => {
  const t = [], n = [];
  for (const [, r] of e.nodeLookup)
    r.selected && t.push(r.internals.userNode);
  for (const [, r] of e.edgeLookup)
    r.selected && n.push(r);
  return { selectedNodes: t, selectedEdges: n };
}, xh = (e) => e.id;
function mne(e, t) {
  return At(e.selectedNodes.map(xh), t.selectedNodes.map(xh)) && At(e.selectedEdges.map(xh), t.selectedEdges.map(xh));
}
function gne({ onSelectionChange: e }) {
  const t = kt(), { selectedNodes: n, selectedEdges: r } = Je(pne, mne);
  return _.useEffect(() => {
    const o = { nodes: n, edges: r };
    e?.(o), t.getState().onSelectionChangeHandlers.forEach((a) => a(o));
  }, [n, r, e]), null;
}
const yne = (e) => !!e.onSelectionChangeHandlers;
function vne({ onSelectionChange: e }) {
  const t = Je(yne);
  return e || t ? x.jsx(gne, { onSelectionChange: e }) : null;
}
const H5 = [0, 0], bne = { x: 0, y: 0, zoom: 1 }, xne = [
  "nodes",
  "edges",
  "defaultNodes",
  "defaultEdges",
  "onConnect",
  "onConnectStart",
  "onConnectEnd",
  "onClickConnectStart",
  "onClickConnectEnd",
  "nodesDraggable",
  "autoPanOnNodeFocus",
  "nodesConnectable",
  "nodesFocusable",
  "edgesFocusable",
  "edgesReconnectable",
  "elevateNodesOnSelect",
  "elevateEdgesOnSelect",
  "minZoom",
  "maxZoom",
  "nodeExtent",
  "onNodesChange",
  "onEdgesChange",
  "elementsSelectable",
  "connectionMode",
  "snapGrid",
  "snapToGrid",
  "translateExtent",
  "connectOnClick",
  "defaultEdgeOptions",
  "fitView",
  "fitViewOptions",
  "onNodesDelete",
  "onEdgesDelete",
  "onDelete",
  "onNodeDrag",
  "onNodeDragStart",
  "onNodeDragStop",
  "onSelectionDrag",
  "onSelectionDragStart",
  "onSelectionDragStop",
  "onMoveStart",
  "onMove",
  "onMoveEnd",
  "noPanClassName",
  "nodeOrigin",
  "autoPanOnConnect",
  "autoPanOnNodeDrag",
  "onError",
  "connectionRadius",
  "isValidConnection",
  "selectNodesOnDrag",
  "nodeDragThreshold",
  "connectionDragThreshold",
  "onBeforeDelete",
  "debug",
  "autoPanSpeed",
  "paneClickDistance",
  "ariaLabelConfig"
], PA = [...xne, "rfId"], wne = (e) => ({
  setNodes: e.setNodes,
  setEdges: e.setEdges,
  setMinZoom: e.setMinZoom,
  setMaxZoom: e.setMaxZoom,
  setTranslateExtent: e.setTranslateExtent,
  setNodeExtent: e.setNodeExtent,
  reset: e.reset,
  setDefaultNodesAndEdges: e.setDefaultNodesAndEdges,
  setPaneClickDistance: e.setPaneClickDistance
}), jA = {
  /*
   * these are values that are also passed directly to other components
   * than the StoreUpdater. We can reduce the number of setStore calls
   * by setting the same values here as prev fields.
   */
  translateExtent: Hc,
  nodeOrigin: H5,
  minZoom: 0.5,
  maxZoom: 2,
  elementsSelectable: !0,
  noPanClassName: "nopan",
  rfId: "1",
  paneClickDistance: 0
};
function _ne(e) {
  const { setNodes: t, setEdges: n, setMinZoom: r, setMaxZoom: o, setTranslateExtent: a, setNodeExtent: s, reset: u, setDefaultNodesAndEdges: c, setPaneClickDistance: f } = Je(wne, At), h = kt();
  _.useEffect(() => (c(e.defaultNodes, e.defaultEdges), () => {
    p.current = jA, u();
  }), []);
  const p = _.useRef(jA);
  return _.useEffect(
    () => {
      for (const g of PA) {
        const y = e[g], w = p.current[g];
        y !== w && (typeof e[g] > "u" || (g === "nodes" ? t(y) : g === "edges" ? n(y) : g === "minZoom" ? r(y) : g === "maxZoom" ? o(y) : g === "translateExtent" ? a(y) : g === "nodeExtent" ? s(y) : g === "paneClickDistance" ? f(y) : g === "ariaLabelConfig" ? h.setState({ ariaLabelConfig: pte(y) }) : g === "fitView" ? h.setState({ fitViewQueued: y }) : g === "fitViewOptions" ? h.setState({ fitViewOptions: y }) : h.setState({ [g]: y })));
      }
      p.current = e;
    },
    // Only re-run the effect if one of the fields we track changes
    PA.map((g) => e[g])
  ), null;
}
function IA() {
  return typeof window > "u" || !window.matchMedia ? null : window.matchMedia("(prefers-color-scheme: dark)");
}
function Sne(e) {
  const [t, n] = _.useState(e === "system" ? null : e);
  return _.useEffect(() => {
    if (e !== "system") {
      n(e);
      return;
    }
    const r = IA(), o = () => n(r?.matches ? "dark" : "light");
    return o(), r?.addEventListener("change", o), () => {
      r?.removeEventListener("change", o);
    };
  }, [e]), t !== null ? t : IA()?.matches ? "dark" : "light";
}
const zA = typeof document < "u" ? document : null;
function Qo(e = null, t = { target: zA, actInsideInputWithModifier: !0 }) {
  const [n, r] = _.useState(!1), o = _.useRef(!1), a = _.useRef(/* @__PURE__ */ new Set([])), [s, u] = _.useMemo(() => {
    if (e !== null) {
      const f = (Array.isArray(e) ? e : [e]).filter((p) => typeof p == "string").map((p) => p.replace("+", `
`).replace(`

`, `
+`).split(`
`)), h = f.reduce((p, g) => p.concat(...g), []);
      return [f, h];
    }
    return [[], []];
  }, [e]);
  return _.useEffect(() => {
    const c = t?.target ?? zA, f = t?.actInsideInputWithModifier ?? !0;
    if (e !== null) {
      const h = (y) => {
        if (o.current = y.ctrlKey || y.metaKey || y.shiftKey || y.altKey, (!o.current || o.current && !f) && S5(y))
          return !1;
        const v = FA(y.code, u);
        if (a.current.add(y[v]), LA(s, a.current, !1)) {
          const S = y.composedPath?.()?.[0] || y.target, E = S?.nodeName === "BUTTON" || S?.nodeName === "A";
          t.preventDefault !== !1 && (o.current || !E) && y.preventDefault(), r(!0);
        }
      }, p = (y) => {
        const w = FA(y.code, u);
        LA(s, a.current, !0) ? (r(!1), a.current.clear()) : a.current.delete(y[w]), y.key === "Meta" && a.current.clear(), o.current = !1;
      }, g = () => {
        a.current.clear(), r(!1);
      };
      return c?.addEventListener("keydown", h), c?.addEventListener("keyup", p), window.addEventListener("blur", g), window.addEventListener("contextmenu", g), () => {
        c?.removeEventListener("keydown", h), c?.removeEventListener("keyup", p), window.removeEventListener("blur", g), window.removeEventListener("contextmenu", g);
      };
    }
  }, [e, r]), n;
}
function LA(e, t, n) {
  return e.filter((r) => n || r.length === t.size).some((r) => r.every((o) => t.has(o)));
}
function FA(e, t) {
  return t.includes(e) ? "code" : "key";
}
const Ene = () => {
  const e = kt();
  return _.useMemo(() => ({
    zoomIn: (t) => {
      const { panZoom: n } = e.getState();
      return n ? n.scaleBy(1.2, { duration: t?.duration }) : Promise.resolve(!1);
    },
    zoomOut: (t) => {
      const { panZoom: n } = e.getState();
      return n ? n.scaleBy(1 / 1.2, { duration: t?.duration }) : Promise.resolve(!1);
    },
    zoomTo: (t, n) => {
      const { panZoom: r } = e.getState();
      return r ? r.scaleTo(t, { duration: n?.duration }) : Promise.resolve(!1);
    },
    getZoom: () => e.getState().transform[2],
    setViewport: async (t, n) => {
      const { transform: [r, o, a], panZoom: s } = e.getState();
      return s ? (await s.setViewport({
        x: t.x ?? r,
        y: t.y ?? o,
        zoom: t.zoom ?? a
      }, n), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    getViewport: () => {
      const [t, n, r] = e.getState().transform;
      return { x: t, y: n, zoom: r };
    },
    setCenter: async (t, n, r) => e.getState().setCenter(t, n, r),
    fitBounds: async (t, n) => {
      const { width: r, height: o, minZoom: a, maxZoom: s, panZoom: u } = e.getState(), c = Tx(t, r, o, a, s, n?.padding ?? 0.1);
      return u ? (await u.setViewport(c, {
        duration: n?.duration,
        ease: n?.ease,
        interpolate: n?.interpolate
      }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    screenToFlowPosition: (t, n = {}) => {
      const { transform: r, snapGrid: o, snapToGrid: a, domNode: s } = e.getState();
      if (!s)
        return t;
      const { x: u, y: c } = s.getBoundingClientRect(), f = {
        x: t.x - u,
        y: t.y - c
      }, h = n.snapGrid ?? o, p = n.snapToGrid ?? a;
      return bf(f, r, p, h);
    },
    flowToScreenPosition: (t) => {
      const { transform: n, domNode: r } = e.getState();
      if (!r)
        return t;
      const { x: o, y: a } = r.getBoundingClientRect(), s = Cp(t, n);
      return {
        x: s.x + o,
        y: s.y + a
      };
    }
  }), []);
};
function V5(e, t) {
  const n = [], r = /* @__PURE__ */ new Map(), o = [];
  for (const a of e)
    if (a.type === "add") {
      o.push(a);
      continue;
    } else if (a.type === "remove" || a.type === "replace")
      r.set(a.id, [a]);
    else {
      const s = r.get(a.id);
      s ? s.push(a) : r.set(a.id, [a]);
    }
  for (const a of t) {
    const s = r.get(a.id);
    if (!s) {
      n.push(a);
      continue;
    }
    if (s[0].type === "remove")
      continue;
    if (s[0].type === "replace") {
      n.push({ ...s[0].item });
      continue;
    }
    const u = { ...a };
    for (const c of s)
      Cne(c, u);
    n.push(u);
  }
  return o.length && o.forEach((a) => {
    a.index !== void 0 ? n.splice(a.index, 0, { ...a.item }) : n.push({ ...a.item });
  }), n;
}
function Cne(e, t) {
  switch (e.type) {
    case "select": {
      t.selected = e.selected;
      break;
    }
    case "position": {
      typeof e.position < "u" && (t.position = e.position), typeof e.dragging < "u" && (t.dragging = e.dragging);
      break;
    }
    case "dimensions": {
      typeof e.dimensions < "u" && (t.measured ?? (t.measured = {}), t.measured.width = e.dimensions.width, t.measured.height = e.dimensions.height, e.setAttributes && ((e.setAttributes === !0 || e.setAttributes === "width") && (t.width = e.dimensions.width), (e.setAttributes === !0 || e.setAttributes === "height") && (t.height = e.dimensions.height))), typeof e.resizing == "boolean" && (t.resizing = e.resizing);
      break;
    }
  }
}
function Px(e, t) {
  return V5(e, t);
}
function U5(e, t) {
  return V5(e, t);
}
function Oa(e, t) {
  return {
    id: e,
    type: "select",
    selected: t
  };
}
function il(e, t = /* @__PURE__ */ new Set(), n = !1) {
  const r = [];
  for (const [o, a] of e) {
    const s = t.has(o);
    !(a.selected === void 0 && !s) && a.selected !== s && (n && (a.selected = s), r.push(Oa(a.id, s)));
  }
  return r;
}
function $A({ items: e = [], lookup: t }) {
  const n = [], r = new Map(e.map((o) => [o.id, o]));
  for (const [o, a] of e.entries()) {
    const s = t.get(a.id), u = s?.internals?.userNode ?? s;
    u !== void 0 && u !== a && n.push({ id: a.id, item: a, type: "replace" }), u === void 0 && n.push({ item: a, type: "add", index: o });
  }
  for (const [o] of t)
    r.get(o) === void 0 && n.push({ id: o, type: "remove" });
  return n;
}
function BA(e) {
  return {
    id: e.id,
    type: "remove"
  };
}
const HA = (e) => ote(e), kne = (e) => m5(e);
function q5(e) {
  return _.forwardRef(e);
}
const Tne = typeof window < "u" ? _.useLayoutEffect : _.useEffect;
function VA(e) {
  const [t, n] = _.useState(BigInt(0)), [r] = _.useState(() => Ane(() => n((o) => o + BigInt(1))));
  return Tne(() => {
    const o = r.get();
    o.length && (e(o), r.reset());
  }, [t]), r;
}
function Ane(e) {
  let t = [];
  return {
    get: () => t,
    reset: () => {
      t = [];
    },
    push: (n) => {
      t.push(n), e();
    }
  };
}
const G5 = _.createContext(null);
function Rne({ children: e }) {
  const t = kt(), n = _.useCallback((u) => {
    const { nodes: c = [], setNodes: f, hasDefaultNodes: h, onNodesChange: p, nodeLookup: g, fitViewQueued: y } = t.getState();
    let w = c;
    for (const S of u)
      w = typeof S == "function" ? S(w) : S;
    const v = $A({
      items: w,
      lookup: g
    });
    h && f(w), v.length > 0 ? p?.(v) : y && window.requestAnimationFrame(() => {
      const { fitViewQueued: S, nodes: E, setNodes: T } = t.getState();
      S && T(E);
    });
  }, []), r = VA(n), o = _.useCallback((u) => {
    const { edges: c = [], setEdges: f, hasDefaultEdges: h, onEdgesChange: p, edgeLookup: g } = t.getState();
    let y = c;
    for (const w of u)
      y = typeof w == "function" ? w(y) : w;
    h ? f(y) : p && p($A({
      items: y,
      lookup: g
    }));
  }, []), a = VA(o), s = _.useMemo(() => ({ nodeQueue: r, edgeQueue: a }), []);
  return x.jsx(G5.Provider, { value: s, children: e });
}
function Mne() {
  const e = _.useContext(G5);
  if (!e)
    throw new Error("useBatchContext must be used within a BatchProvider");
  return e;
}
const One = (e) => !!e.panZoom;
function es() {
  const e = Ene(), t = kt(), n = Mne(), r = Je(One), o = _.useMemo(() => {
    const a = (p) => t.getState().nodeLookup.get(p), s = (p) => {
      n.nodeQueue.push(p);
    }, u = (p) => {
      n.edgeQueue.push(p);
    }, c = (p) => {
      const { nodeLookup: g, nodeOrigin: y } = t.getState(), w = HA(p) ? p : g.get(p.id), v = w.parentId ? w5(w.position, w.measured, w.parentId, g, y) : w.position, S = {
        ...w,
        position: v,
        width: w.measured?.width ?? w.width,
        height: w.measured?.height ?? w.height
      };
      return Tl(S);
    }, f = (p, g, y = { replace: !1 }) => {
      s((w) => w.map((v) => {
        if (v.id === p) {
          const S = typeof g == "function" ? g(v) : g;
          return y.replace && HA(S) ? S : { ...v, ...S };
        }
        return v;
      }));
    }, h = (p, g, y = { replace: !1 }) => {
      u((w) => w.map((v) => {
        if (v.id === p) {
          const S = typeof g == "function" ? g(v) : g;
          return y.replace && kne(S) ? S : { ...v, ...S };
        }
        return v;
      }));
    };
    return {
      getNodes: () => t.getState().nodes.map((p) => ({ ...p })),
      getNode: (p) => a(p)?.internals.userNode,
      getInternalNode: a,
      getEdges: () => {
        const { edges: p = [] } = t.getState();
        return p.map((g) => ({ ...g }));
      },
      getEdge: (p) => t.getState().edgeLookup.get(p),
      setNodes: s,
      setEdges: u,
      addNodes: (p) => {
        const g = Array.isArray(p) ? p : [p];
        n.nodeQueue.push((y) => [...y, ...g]);
      },
      addEdges: (p) => {
        const g = Array.isArray(p) ? p : [p];
        n.edgeQueue.push((y) => [...y, ...g]);
      },
      toObject: () => {
        const { nodes: p = [], edges: g = [], transform: y } = t.getState(), [w, v, S] = y;
        return {
          nodes: p.map((E) => ({ ...E })),
          edges: g.map((E) => ({ ...E })),
          viewport: {
            x: w,
            y: v,
            zoom: S
          }
        };
      },
      deleteElements: async ({ nodes: p = [], edges: g = [] }) => {
        const { nodes: y, edges: w, onNodesDelete: v, onEdgesDelete: S, triggerNodeChanges: E, triggerEdgeChanges: T, onDelete: k, onBeforeDelete: A } = t.getState(), { nodes: M, edges: N } = await ute({
          nodesToRemove: p,
          edgesToRemove: g,
          nodes: y,
          edges: w,
          onBeforeDelete: A
        }), P = N.length > 0, z = M.length > 0;
        if (P) {
          const B = N.map(BA);
          S?.(N), T(B);
        }
        if (z) {
          const B = M.map(BA);
          v?.(M), E(B);
        }
        return (z || P) && k?.({ nodes: M, edges: N }), { deletedNodes: M, deletedEdges: N };
      },
      getIntersectingNodes: (p, g = !0, y) => {
        const w = xA(p), v = w ? p : c(p), S = y !== void 0;
        return v ? (y || t.getState().nodes).filter((E) => {
          const T = t.getState().nodeLookup.get(E.id);
          if (T && !w && (E.id === p.id || !T.internals.positionAbsolute))
            return !1;
          const k = Tl(S ? E : T), A = Uc(k, v);
          return g && A > 0 || A >= k.width * k.height || A >= v.width * v.height;
        }) : [];
      },
      isNodeIntersecting: (p, g, y = !0) => {
        const v = xA(p) ? p : c(p);
        if (!v)
          return !1;
        const S = Uc(v, g);
        return y && S > 0 || S >= v.width * v.height;
      },
      updateNode: f,
      updateNodeData: (p, g, y = { replace: !1 }) => {
        f(p, (w) => {
          const v = typeof g == "function" ? g(w) : g;
          return y.replace ? { ...w, data: v } : { ...w, data: { ...w.data, ...v } };
        }, y);
      },
      updateEdge: h,
      updateEdgeData: (p, g, y = { replace: !1 }) => {
        h(p, (w) => {
          const v = typeof g == "function" ? g(w) : g;
          return y.replace ? { ...w, data: v } : { ...w, data: { ...w.data, ...v } };
        }, y);
      },
      getNodesBounds: (p) => {
        const { nodeLookup: g, nodeOrigin: y } = t.getState();
        return ite(p, { nodeLookup: g, nodeOrigin: y });
      },
      getHandleConnections: ({ type: p, id: g, nodeId: y }) => Array.from(t.getState().connectionLookup.get(`${y}-${p}${g ? `-${g}` : ""}`)?.values() ?? []),
      getNodeConnections: ({ type: p, handleId: g, nodeId: y }) => Array.from(t.getState().connectionLookup.get(`${y}${p ? g ? `-${p}-${g}` : `-${p}` : ""}`)?.values() ?? []),
      fitView: async (p) => {
        const g = t.getState().fitViewResolver ?? hte();
        return t.setState({ fitViewQueued: !0, fitViewOptions: p, fitViewResolver: g }), n.nodeQueue.push((y) => [...y]), g.promise;
      }
    };
  }, []);
  return _.useMemo(() => ({
    ...o,
    ...e,
    viewportInitialized: r
  }), [r]);
}
const UA = (e) => e.selected, Nne = typeof window < "u" ? window : void 0;
function Dne({ deleteKeyCode: e, multiSelectionKeyCode: t }) {
  const n = kt(), { deleteElements: r } = es(), o = Qo(e, { actInsideInputWithModifier: !1 }), a = Qo(t, { target: Nne });
  _.useEffect(() => {
    if (o) {
      const { edges: s, nodes: u } = n.getState();
      r({ nodes: u.filter(UA), edges: s.filter(UA) }), n.setState({ nodesSelectionActive: !1 });
    }
  }, [o]), _.useEffect(() => {
    n.setState({ multiSelectionActive: a });
  }, [a]);
}
function Pne(e) {
  const t = kt();
  _.useEffect(() => {
    const n = () => {
      if (!e.current)
        return !1;
      const r = Ax(e.current);
      (r.height === 0 || r.width === 0) && t.getState().onError?.("004", vo.error004()), t.setState({ width: r.width || 500, height: r.height || 500 });
    };
    if (e.current) {
      n(), window.addEventListener("resize", n);
      const r = new ResizeObserver(() => n());
      return r.observe(e.current), () => {
        window.removeEventListener("resize", n), r && e.current && r.unobserve(e.current);
      };
    }
  }, []);
}
const Fm = {
  position: "absolute",
  width: "100%",
  height: "100%",
  top: 0,
  left: 0
}, jne = (e) => ({
  userSelectionActive: e.userSelectionActive,
  lib: e.lib
});
function Ine({ onPaneContextMenu: e, zoomOnScroll: t = !0, zoomOnPinch: n = !0, panOnScroll: r = !1, panOnScrollSpeed: o = 0.5, panOnScrollMode: a = Ba.Free, zoomOnDoubleClick: s = !0, panOnDrag: u = !0, defaultViewport: c, translateExtent: f, minZoom: h, maxZoom: p, zoomActivationKeyCode: g, preventScrolling: y = !0, children: w, noWheelClassName: v, noPanClassName: S, onViewportChange: E, isControlledViewport: T, paneClickDistance: k }) {
  const A = kt(), M = _.useRef(null), { userSelectionActive: N, lib: P } = Je(jne, At), z = Qo(g), B = _.useRef();
  Pne(M);
  const R = _.useCallback((F) => {
    E?.({ x: F[0], y: F[1], zoom: F[2] }), T || A.setState({ transform: F });
  }, [E, T]);
  return _.useEffect(() => {
    if (M.current) {
      B.current = Wte({
        domNode: M.current,
        minZoom: h,
        maxZoom: p,
        translateExtent: f,
        viewport: c,
        paneClickDistance: k,
        onDraggingChange: (j) => A.setState({ paneDragging: j }),
        onPanZoomStart: (j, V) => {
          const { onViewportChangeStart: I, onMoveStart: H } = A.getState();
          H?.(j, V), I?.(V);
        },
        onPanZoom: (j, V) => {
          const { onViewportChange: I, onMove: H } = A.getState();
          H?.(j, V), I?.(V);
        },
        onPanZoomEnd: (j, V) => {
          const { onViewportChangeEnd: I, onMoveEnd: H } = A.getState();
          H?.(j, V), I?.(V);
        }
      });
      const { x: F, y: U, zoom: W } = B.current.getViewport();
      return A.setState({
        panZoom: B.current,
        transform: [F, U, W],
        domNode: M.current.closest(".react-flow")
      }), () => {
        B.current?.destroy();
      };
    }
  }, []), _.useEffect(() => {
    B.current?.update({
      onPaneContextMenu: e,
      zoomOnScroll: t,
      zoomOnPinch: n,
      panOnScroll: r,
      panOnScrollSpeed: o,
      panOnScrollMode: a,
      zoomOnDoubleClick: s,
      panOnDrag: u,
      zoomActivationKeyPressed: z,
      preventScrolling: y,
      noPanClassName: S,
      userSelectionActive: N,
      noWheelClassName: v,
      lib: P,
      onTransformChange: R
    });
  }, [
    e,
    t,
    n,
    r,
    o,
    a,
    s,
    u,
    z,
    y,
    S,
    N,
    v,
    P,
    R
  ]), x.jsx("div", { className: "react-flow__renderer", ref: M, style: Fm, children: w });
}
const zne = (e) => ({
  userSelectionActive: e.userSelectionActive,
  userSelectionRect: e.userSelectionRect
});
function Lne() {
  const { userSelectionActive: e, userSelectionRect: t } = Je(zne, At);
  return e && t ? x.jsx("div", { className: "react-flow__selection react-flow__container", style: {
    width: t.width,
    height: t.height,
    transform: `translate(${t.x}px, ${t.y}px)`
  } }) : null;
}
const gv = (e, t) => (n) => {
  n.target === t.current && e?.(n);
}, Fne = (e) => ({
  userSelectionActive: e.userSelectionActive,
  elementsSelectable: e.elementsSelectable,
  connectionInProgress: e.connection.inProgress,
  dragging: e.paneDragging
});
function $ne({ isSelecting: e, selectionKeyPressed: t, selectionMode: n = Vc.Full, panOnDrag: r, selectionOnDrag: o, onSelectionStart: a, onSelectionEnd: s, onPaneClick: u, onPaneContextMenu: c, onPaneScroll: f, onPaneMouseEnter: h, onPaneMouseMove: p, onPaneMouseLeave: g, children: y }) {
  const w = kt(), { userSelectionActive: v, elementsSelectable: S, dragging: E, connectionInProgress: T } = Je(Fne, At), k = S && (e || v), A = _.useRef(null), M = _.useRef(), N = _.useRef(/* @__PURE__ */ new Set()), P = _.useRef(/* @__PURE__ */ new Set()), z = _.useRef(!1), B = _.useRef(!1), R = (H) => {
    if (z.current || T) {
      z.current = !1;
      return;
    }
    u?.(H), w.getState().resetSelectedElements(), w.setState({ nodesSelectionActive: !1 });
  }, F = (H) => {
    if (Array.isArray(r) && r?.includes(2)) {
      H.preventDefault();
      return;
    }
    c?.(H);
  }, U = f ? (H) => f(H) : void 0, W = (H) => {
    const { resetSelectedElements: q, domNode: G } = w.getState();
    if (M.current = G?.getBoundingClientRect(), !S || !e || H.button !== 0 || H.target !== A.current || !M.current)
      return;
    H.target?.setPointerCapture?.(H.pointerId), B.current = !0, z.current = !1;
    const { x: O, y: Y } = fo(H.nativeEvent, M.current);
    q(), w.setState({
      userSelectionRect: {
        width: 0,
        height: 0,
        startX: O,
        startY: Y,
        x: O,
        y: Y
      }
    }), a?.(H);
  }, j = (H) => {
    const { userSelectionRect: q, transform: G, nodeLookup: O, edgeLookup: Y, connectionLookup: Z, triggerNodeChanges: L, triggerEdgeChanges: te, defaultEdgeOptions: he } = w.getState();
    if (!M.current || !q)
      return;
    z.current = !0;
    const { x: oe, y: de } = fo(H.nativeEvent, M.current), { startX: le, startY: ye } = q, je = {
      startX: le,
      startY: ye,
      x: oe < le ? oe : le,
      y: de < ye ? de : ye,
      width: Math.abs(oe - le),
      height: Math.abs(de - ye)
    }, Ne = N.current, we = P.current;
    N.current = new Set(kx(O, je, G, n === Vc.Partial, !0).map((_e) => _e.id)), P.current = /* @__PURE__ */ new Set();
    const Ee = he?.selectable ?? !0;
    for (const _e of N.current) {
      const Xe = Z.get(_e);
      if (Xe)
        for (const { edgeId: St } of Xe.values()) {
          const ct = Y.get(St);
          ct && (ct.selectable ?? Ee) && P.current.add(St);
        }
    }
    if (!wA(Ne, N.current)) {
      const _e = il(O, N.current, !0);
      L(_e);
    }
    if (!wA(we, P.current)) {
      const _e = il(Y, P.current);
      te(_e);
    }
    w.setState({
      userSelectionRect: je,
      userSelectionActive: !0,
      nodesSelectionActive: !1
    });
  }, V = (H) => {
    if (H.button !== 0 || !B.current)
      return;
    H.target?.releasePointerCapture?.(H.pointerId);
    const { userSelectionRect: q } = w.getState();
    !v && q && H.target === A.current && R?.(H), w.setState({
      userSelectionActive: !1,
      userSelectionRect: null,
      nodesSelectionActive: N.current.size > 0
    }), s?.(H), (t || o) && (z.current = !1), B.current = !1;
  }, I = r === !0 || Array.isArray(r) && r.includes(0);
  return x.jsxs("div", { className: Wt(["react-flow__pane", { draggable: I, dragging: E, selection: e }]), onClick: k ? void 0 : gv(R, A), onContextMenu: gv(F, A), onWheel: gv(U, A), onPointerEnter: k ? void 0 : h, onPointerDown: k ? W : p, onPointerMove: k ? j : p, onPointerUp: k ? V : void 0, onPointerLeave: g, ref: A, style: Fm, children: [y, x.jsx(Lne, {})] });
}
function Bb({ id: e, store: t, unselect: n = !1, nodeRef: r }) {
  const { addSelectedNodes: o, unselectNodesAndEdges: a, multiSelectionActive: s, nodeLookup: u, onError: c } = t.getState(), f = u.get(e);
  if (!f) {
    c?.("012", vo.error012(e));
    return;
  }
  t.setState({ nodesSelectionActive: !1 }), f.selected ? (n || f.selected && s) && (a({ nodes: [f], edges: [] }), requestAnimationFrame(() => r?.current?.blur())) : o([e]);
}
function Y5({ nodeRef: e, disabled: t = !1, noDragClassName: n, handleSelector: r, nodeId: o, isSelectable: a, nodeClickDistance: s }) {
  const u = kt(), [c, f] = _.useState(!1), h = _.useRef();
  return _.useEffect(() => {
    h.current = Dte({
      getStoreItems: () => u.getState(),
      onNodeMouseDown: (p) => {
        Bb({
          id: p,
          store: u,
          nodeRef: e
        });
      },
      onDragStart: () => {
        f(!0);
      },
      onDragStop: () => {
        f(!1);
      }
    });
  }, []), _.useEffect(() => {
    if (t)
      h.current?.destroy();
    else if (e.current)
      return h.current?.update({
        noDragClassName: n,
        handleSelector: r,
        domNode: e.current,
        isSelectable: a,
        nodeId: o,
        nodeClickDistance: s
      }), () => {
        h.current?.destroy();
      };
  }, [n, r, t, a, e, o]), c;
}
const Bne = (e) => (t) => t.selected && (t.draggable || e && typeof t.draggable > "u");
function W5() {
  const e = kt();
  return _.useCallback((n) => {
    const { nodeExtent: r, snapToGrid: o, snapGrid: a, nodesDraggable: s, onError: u, updateNodePositions: c, nodeLookup: f, nodeOrigin: h } = e.getState(), p = /* @__PURE__ */ new Map(), g = Bne(s), y = o ? a[0] : 5, w = o ? a[1] : 5, v = n.direction.x * y * n.factor, S = n.direction.y * w * n.factor;
    for (const [, E] of f) {
      if (!g(E))
        continue;
      let T = {
        x: E.internals.positionAbsolute.x + v,
        y: E.internals.positionAbsolute.y + S
      };
      o && (T = jm(T, a));
      const { position: k, positionAbsolute: A } = g5({
        nodeId: E.id,
        nextPosition: T,
        nodeLookup: f,
        nodeExtent: r,
        nodeOrigin: h,
        onError: u
      });
      E.position = k, E.internals.positionAbsolute = A, p.set(E.id, E);
    }
    c(p);
  }, []);
}
const jx = _.createContext(null), Hne = jx.Provider;
jx.Consumer;
const X5 = () => _.useContext(jx), Vne = (e) => ({
  connectOnClick: e.connectOnClick,
  noPanClassName: e.noPanClassName,
  rfId: e.rfId
}), Une = (e, t, n) => (r) => {
  const { connectionClickStartHandle: o, connectionMode: a, connection: s } = r, { fromHandle: u, toHandle: c, isValid: f } = s, h = c?.nodeId === e && c?.id === t && c?.type === n;
  return {
    connectingFrom: u?.nodeId === e && u?.id === t && u?.type === n,
    connectingTo: h,
    clickConnecting: o?.nodeId === e && o?.id === t && o?.type === n,
    isPossibleEndHandle: a === Cl.Strict ? u?.type !== n : e !== u?.nodeId || t !== u?.id,
    connectionInProcess: !!u,
    clickConnectionInProcess: !!o,
    valid: h && f
  };
};
function qne({ type: e = "source", position: t = Te.Top, isValidConnection: n, isConnectable: r = !0, isConnectableStart: o = !0, isConnectableEnd: a = !0, id: s, onConnect: u, children: c, className: f, onMouseDown: h, onTouchStart: p, ...g }, y) {
  const w = s || null, v = e === "target", S = kt(), E = X5(), { connectOnClick: T, noPanClassName: k, rfId: A } = Je(Vne, At), { connectingFrom: M, connectingTo: N, clickConnecting: P, isPossibleEndHandle: z, connectionInProcess: B, clickConnectionInProcess: R, valid: F } = Je(Une(E, w, e), At);
  E || S.getState().onError?.("010", vo.error010());
  const U = (V) => {
    const { defaultEdgeOptions: I, onConnect: H, hasDefaultEdges: q } = S.getState(), G = {
      ...I,
      ...V
    };
    if (q) {
      const { edges: O, setEdges: Y } = S.getState();
      Y(xte(G, O));
    }
    H?.(G), u?.(G);
  }, W = (V) => {
    if (!E)
      return;
    const I = E5(V.nativeEvent);
    if (o && (I && V.button === 0 || !I)) {
      const H = S.getState();
      $b.onPointerDown(V.nativeEvent, {
        autoPanOnConnect: H.autoPanOnConnect,
        connectionMode: H.connectionMode,
        connectionRadius: H.connectionRadius,
        domNode: H.domNode,
        nodeLookup: H.nodeLookup,
        lib: H.lib,
        isTarget: v,
        handleId: w,
        nodeId: E,
        flowId: H.rfId,
        panBy: H.panBy,
        cancelConnection: H.cancelConnection,
        onConnectStart: H.onConnectStart,
        onConnectEnd: H.onConnectEnd,
        updateConnection: H.updateConnection,
        onConnect: U,
        isValidConnection: n || H.isValidConnection,
        getTransform: () => S.getState().transform,
        getFromHandle: () => S.getState().connection.fromHandle,
        autoPanSpeed: H.autoPanSpeed,
        dragThreshold: H.connectionDragThreshold
      });
    }
    I ? h?.(V) : p?.(V);
  }, j = (V) => {
    const { onClickConnectStart: I, onClickConnectEnd: H, connectionClickStartHandle: q, connectionMode: G, isValidConnection: O, lib: Y, rfId: Z, nodeLookup: L, connection: te } = S.getState();
    if (!E || !q && !o)
      return;
    if (!q) {
      I?.(V.nativeEvent, { nodeId: E, handleId: w, handleType: e }), S.setState({ connectionClickStartHandle: { nodeId: E, type: e, id: w } });
      return;
    }
    const he = _5(V.target), oe = n || O, { connection: de, isValid: le } = $b.isValid(V.nativeEvent, {
      handle: {
        nodeId: E,
        id: w,
        type: e
      },
      connectionMode: G,
      fromNodeId: q.nodeId,
      fromHandleId: q.id || null,
      fromType: q.type,
      isValidConnection: oe,
      flowId: Z,
      doc: he,
      lib: Y,
      nodeLookup: L
    });
    le && de && U(de);
    const ye = structuredClone(te);
    delete ye.inProgress, ye.toPosition = ye.toHandle ? ye.toHandle.position : null, H?.(V, ye), S.setState({ connectionClickStartHandle: null });
  };
  return x.jsx("div", { "data-handleid": w, "data-nodeid": E, "data-handlepos": t, "data-id": `${A}-${E}-${w}-${e}`, className: Wt([
    "react-flow__handle",
    `react-flow__handle-${t}`,
    "nodrag",
    k,
    f,
    {
      source: !v,
      target: v,
      connectable: r,
      connectablestart: o,
      connectableend: a,
      clickconnecting: P,
      connectingfrom: M,
      connectingto: N,
      valid: F,
      /*
       * shows where you can start a connection from
       * and where you can end it while connecting
       */
      connectionindicator: r && (!B || z) && (B || R ? a : o)
    }
  ]), onMouseDown: W, onTouchStart: W, onClick: T ? j : void 0, ref: y, ...g, children: c });
}
const Gc = _.memo(q5(qne));
function Gne({ data: e, isConnectable: t, sourcePosition: n = Te.Bottom }) {
  return x.jsxs(x.Fragment, { children: [e?.label, x.jsx(Gc, { type: "source", position: n, isConnectable: t })] });
}
function Yne({ data: e, isConnectable: t, targetPosition: n = Te.Top, sourcePosition: r = Te.Bottom }) {
  return x.jsxs(x.Fragment, { children: [x.jsx(Gc, { type: "target", position: n, isConnectable: t }), e?.label, x.jsx(Gc, { type: "source", position: r, isConnectable: t })] });
}
function Wne() {
  return null;
}
function Xne({ data: e, isConnectable: t, targetPosition: n = Te.Top }) {
  return x.jsxs(x.Fragment, { children: [x.jsx(Gc, { type: "target", position: n, isConnectable: t }), e?.label] });
}
const Tp = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
}, qA = {
  input: Gne,
  default: Yne,
  output: Xne,
  group: Wne
};
function Kne(e) {
  return e.internals.handleBounds === void 0 ? {
    width: e.width ?? e.initialWidth ?? e.style?.width,
    height: e.height ?? e.initialHeight ?? e.style?.height
  } : {
    width: e.width ?? e.style?.width,
    height: e.height ?? e.style?.height
  };
}
const Zne = (e) => {
  const { width: t, height: n, x: r, y: o } = vf(e.nodeLookup, {
    filter: (a) => !!a.selected
  });
  return {
    width: Ir(t) ? t : null,
    height: Ir(n) ? n : null,
    userSelectionActive: e.userSelectionActive,
    transformString: `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]}) translate(${r}px,${o}px)`
  };
};
function Qne({ onSelectionContextMenu: e, noPanClassName: t, disableKeyboardA11y: n }) {
  const r = kt(), { width: o, height: a, transformString: s, userSelectionActive: u } = Je(Zne, At), c = W5(), f = _.useRef(null);
  if (_.useEffect(() => {
    n || f.current?.focus({
      preventScroll: !0
    });
  }, [n]), Y5({
    nodeRef: f
  }), u || !o || !a)
    return null;
  const h = e ? (g) => {
    const y = r.getState().nodes.filter((w) => w.selected);
    e(g, y);
  } : void 0, p = (g) => {
    Object.prototype.hasOwnProperty.call(Tp, g.key) && (g.preventDefault(), c({
      direction: Tp[g.key],
      factor: g.shiftKey ? 4 : 1
    }));
  };
  return x.jsx("div", { className: Wt(["react-flow__nodesselection", "react-flow__container", t]), style: {
    transform: s
  }, children: x.jsx("div", { ref: f, className: "react-flow__nodesselection-rect", onContextMenu: h, tabIndex: n ? void 0 : -1, onKeyDown: n ? void 0 : p, style: {
    width: o,
    height: a
  } }) });
}
const GA = typeof window < "u" ? window : void 0, Jne = (e) => ({ nodesSelectionActive: e.nodesSelectionActive, userSelectionActive: e.userSelectionActive });
function K5({ children: e, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: o, onPaneContextMenu: a, onPaneScroll: s, paneClickDistance: u, deleteKeyCode: c, selectionKeyCode: f, selectionOnDrag: h, selectionMode: p, onSelectionStart: g, onSelectionEnd: y, multiSelectionKeyCode: w, panActivationKeyCode: v, zoomActivationKeyCode: S, elementsSelectable: E, zoomOnScroll: T, zoomOnPinch: k, panOnScroll: A, panOnScrollSpeed: M, panOnScrollMode: N, zoomOnDoubleClick: P, panOnDrag: z, defaultViewport: B, translateExtent: R, minZoom: F, maxZoom: U, preventScrolling: W, onSelectionContextMenu: j, noWheelClassName: V, noPanClassName: I, disableKeyboardA11y: H, onViewportChange: q, isControlledViewport: G }) {
  const { nodesSelectionActive: O, userSelectionActive: Y } = Je(Jne), Z = Qo(f, { target: GA }), L = Qo(v, { target: GA }), te = L || z, he = L || A, oe = h && te !== !0, de = Z || Y || oe;
  return Dne({ deleteKeyCode: c, multiSelectionKeyCode: w }), x.jsx(Ine, { onPaneContextMenu: a, elementsSelectable: E, zoomOnScroll: T, zoomOnPinch: k, panOnScroll: he, panOnScrollSpeed: M, panOnScrollMode: N, zoomOnDoubleClick: P, panOnDrag: !Z && te, defaultViewport: B, translateExtent: R, minZoom: F, maxZoom: U, zoomActivationKeyCode: S, preventScrolling: W, noWheelClassName: V, noPanClassName: I, onViewportChange: q, isControlledViewport: G, paneClickDistance: u, children: x.jsxs($ne, { onSelectionStart: g, onSelectionEnd: y, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: o, onPaneContextMenu: a, onPaneScroll: s, panOnDrag: te, isSelecting: !!de, selectionMode: p, selectionKeyPressed: Z, selectionOnDrag: oe, children: [e, O && x.jsx(Qne, { onSelectionContextMenu: j, noPanClassName: I, disableKeyboardA11y: H })] }) });
}
K5.displayName = "FlowRenderer";
const ere = _.memo(K5), tre = (e) => (t) => e ? kx(t.nodeLookup, { x: 0, y: 0, width: t.width, height: t.height }, t.transform, !0).map((n) => n.id) : Array.from(t.nodeLookup.keys());
function nre(e) {
  return Je(_.useCallback(tre(e), [e]), At);
}
const rre = (e) => e.updateNodeInternals;
function ore() {
  const e = Je(rre), [t] = _.useState(() => typeof ResizeObserver > "u" ? null : new ResizeObserver((n) => {
    const r = /* @__PURE__ */ new Map();
    n.forEach((o) => {
      const a = o.target.getAttribute("data-id");
      r.set(a, {
        id: a,
        nodeElement: o.target,
        force: !0
      });
    }), e(r);
  }));
  return _.useEffect(() => () => {
    t?.disconnect();
  }, [t]), t;
}
function ire({ node: e, nodeType: t, hasDimensions: n, resizeObserver: r }) {
  const o = kt(), a = _.useRef(null), s = _.useRef(null), u = _.useRef(e.sourcePosition), c = _.useRef(e.targetPosition), f = _.useRef(t), h = n && !!e.internals.handleBounds;
  return _.useEffect(() => {
    a.current && !e.hidden && (!h || s.current !== a.current) && (s.current && r?.unobserve(s.current), r?.observe(a.current), s.current = a.current);
  }, [h, e.hidden]), _.useEffect(() => () => {
    s.current && (r?.unobserve(s.current), s.current = null);
  }, []), _.useEffect(() => {
    if (a.current) {
      const p = f.current !== t, g = u.current !== e.sourcePosition, y = c.current !== e.targetPosition;
      (p || g || y) && (f.current = t, u.current = e.sourcePosition, c.current = e.targetPosition, o.getState().updateNodeInternals(/* @__PURE__ */ new Map([[e.id, { id: e.id, nodeElement: a.current, force: !0 }]])));
    }
  }, [e.id, t, e.sourcePosition, e.targetPosition]), a;
}
function are({ id: e, onClick: t, onMouseEnter: n, onMouseMove: r, onMouseLeave: o, onContextMenu: a, onDoubleClick: s, nodesDraggable: u, elementsSelectable: c, nodesConnectable: f, nodesFocusable: h, resizeObserver: p, noDragClassName: g, noPanClassName: y, disableKeyboardA11y: w, rfId: v, nodeTypes: S, nodeClickDistance: E, onError: T }) {
  const { node: k, internals: A, isParent: M } = Je((le) => {
    const ye = le.nodeLookup.get(e), je = le.parentLookup.has(e);
    return {
      node: ye,
      internals: ye.internals,
      isParent: je
    };
  }, At);
  let N = k.type || "default", P = S?.[N] || qA[N];
  P === void 0 && (T?.("003", vo.error003(N)), N = "default", P = S?.default || qA.default);
  const z = !!(k.draggable || u && typeof k.draggable > "u"), B = !!(k.selectable || c && typeof k.selectable > "u"), R = !!(k.connectable || f && typeof k.connectable > "u"), F = !!(k.focusable || h && typeof k.focusable > "u"), U = kt(), W = x5(k), j = ire({ node: k, nodeType: N, hasDimensions: W, resizeObserver: p }), V = Y5({
    nodeRef: j,
    disabled: k.hidden || !z,
    noDragClassName: g,
    handleSelector: k.dragHandle,
    nodeId: e,
    isSelectable: B,
    nodeClickDistance: E
  }), I = W5();
  if (k.hidden)
    return null;
  const H = hi(k), q = Kne(k), G = B || z || t || n || r || o, O = n ? (le) => n(le, { ...A.userNode }) : void 0, Y = r ? (le) => r(le, { ...A.userNode }) : void 0, Z = o ? (le) => o(le, { ...A.userNode }) : void 0, L = a ? (le) => a(le, { ...A.userNode }) : void 0, te = s ? (le) => s(le, { ...A.userNode }) : void 0, he = (le) => {
    const { selectNodesOnDrag: ye, nodeDragThreshold: je } = U.getState();
    B && (!ye || !z || je > 0) && Bb({
      id: e,
      store: U,
      nodeRef: j
    }), t && t(le, { ...A.userNode });
  }, oe = (le) => {
    if (!(S5(le.nativeEvent) || w)) {
      if (f5.includes(le.key) && B) {
        const ye = le.key === "Escape";
        Bb({
          id: e,
          store: U,
          unselect: ye,
          nodeRef: j
        });
      } else if (z && k.selected && Object.prototype.hasOwnProperty.call(Tp, le.key)) {
        le.preventDefault();
        const { ariaLabelConfig: ye } = U.getState();
        U.setState({
          ariaLiveMessage: ye["node.a11yDescription.ariaLiveMessage"]({
            direction: le.key.replace("Arrow", "").toLowerCase(),
            x: ~~A.positionAbsolute.x,
            y: ~~A.positionAbsolute.y
          })
        }), I({
          direction: Tp[le.key],
          factor: le.shiftKey ? 4 : 1
        });
      }
    }
  }, de = () => {
    if (w || !j.current?.matches(":focus-visible"))
      return;
    const { transform: le, width: ye, height: je, autoPanOnNodeFocus: Ne, setCenter: we } = U.getState();
    if (!Ne)
      return;
    kx(/* @__PURE__ */ new Map([[e, k]]), { x: 0, y: 0, width: ye, height: je }, le, !0).length > 0 || we(k.position.x + H.width / 2, k.position.y + H.height / 2, {
      zoom: le[2]
    });
  };
  return x.jsx("div", { className: Wt([
    "react-flow__node",
    `react-flow__node-${N}`,
    {
      // this is overwritable by passing `nopan` as a class name
      [y]: z
    },
    k.className,
    {
      selected: k.selected,
      selectable: B,
      parent: M,
      draggable: z,
      dragging: V
    }
  ]), ref: j, style: {
    zIndex: A.z,
    transform: `translate(${A.positionAbsolute.x}px,${A.positionAbsolute.y}px)`,
    pointerEvents: G ? "all" : "none",
    visibility: W ? "visible" : "hidden",
    ...k.style,
    ...q
  }, "data-id": e, "data-testid": `rf__node-${e}`, onMouseEnter: O, onMouseMove: Y, onMouseLeave: Z, onContextMenu: L, onClick: he, onDoubleClick: te, onKeyDown: F ? oe : void 0, tabIndex: F ? 0 : void 0, onFocus: F ? de : void 0, role: k.ariaRole ?? (F ? "group" : void 0), "aria-roledescription": "node", "aria-describedby": w ? void 0 : `${$5}-${v}`, "aria-label": k.ariaLabel, ...k.domAttributes, children: x.jsx(Hne, { value: e, children: x.jsx(P, { id: e, data: k.data, type: N, positionAbsoluteX: A.positionAbsolute.x, positionAbsoluteY: A.positionAbsolute.y, selected: k.selected ?? !1, selectable: B, draggable: z, deletable: k.deletable ?? !0, isConnectable: R, sourcePosition: k.sourcePosition, targetPosition: k.targetPosition, dragging: V, dragHandle: k.dragHandle, zIndex: A.z, parentId: k.parentId, ...H }) }) });
}
const sre = (e) => ({
  nodesDraggable: e.nodesDraggable,
  nodesConnectable: e.nodesConnectable,
  nodesFocusable: e.nodesFocusable,
  elementsSelectable: e.elementsSelectable,
  onError: e.onError
});
function Z5(e) {
  const { nodesDraggable: t, nodesConnectable: n, nodesFocusable: r, elementsSelectable: o, onError: a } = Je(sre, At), s = nre(e.onlyRenderVisibleElements), u = ore();
  return x.jsx("div", { className: "react-flow__nodes", style: Fm, children: s.map((c) => (
    /*
     * The split of responsibilities between NodeRenderer and
     * NodeComponentWrapper may appear weird. However, its designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For example, when youre dragging a single node, that node gets
     * updated multiple times per second. If `NodeRenderer` were to update
     * every time, it would have to re-run the `nodes.map()` loop every
     * time. This gets pricey with hundreds of nodes, especially if every
     * loop cycle does more than just rendering a JSX element!
     *
     * As a result of this choice, we took the following implementation
     * decisions:
     * - NodeRenderer subscribes *only* to node IDs  and therefore
     *   rerender *only* when visible nodes are added or removed.
     * - NodeRenderer performs all operations the result of which can be
     *   shared between nodes (such as creating the `ResizeObserver`
     *   instance, or subscribing to `selector`). This means extra prop
     *   drilling into `NodeComponentWrapper`, but it means we need to run
     *   these operations only once  instead of once per node.
     * - Any operations that youd normally write inside `nodes.map` are
     *   moved into `NodeComponentWrapper`. This ensures they are
     *   memorized  so if `NodeRenderer` *has* to rerender, it only
     *   needs to regenerate the list of nodes, nothing else.
     */
    x.jsx(are, { id: c, nodeTypes: e.nodeTypes, nodeExtent: e.nodeExtent, onClick: e.onNodeClick, onMouseEnter: e.onNodeMouseEnter, onMouseMove: e.onNodeMouseMove, onMouseLeave: e.onNodeMouseLeave, onContextMenu: e.onNodeContextMenu, onDoubleClick: e.onNodeDoubleClick, noDragClassName: e.noDragClassName, noPanClassName: e.noPanClassName, rfId: e.rfId, disableKeyboardA11y: e.disableKeyboardA11y, resizeObserver: u, nodesDraggable: t, nodesConnectable: n, nodesFocusable: r, elementsSelectable: o, nodeClickDistance: e.nodeClickDistance, onError: a }, c)
  )) });
}
Z5.displayName = "NodeRenderer";
const lre = _.memo(Z5);
function ure(e) {
  return Je(_.useCallback((n) => {
    if (!e)
      return n.edges.map((o) => o.id);
    const r = [];
    if (n.width && n.height)
      for (const o of n.edges) {
        const a = n.nodeLookup.get(o.source), s = n.nodeLookup.get(o.target);
        a && s && yte({
          sourceNode: a,
          targetNode: s,
          width: n.width,
          height: n.height,
          transform: n.transform
        }) && r.push(o.id);
      }
    return r;
  }, [e]), At);
}
const cre = ({ color: e = "none", strokeWidth: t = 1 }) => x.jsx("polyline", { style: {
  stroke: e,
  strokeWidth: t
}, strokeLinecap: "round", strokeLinejoin: "round", fill: "none", points: "-5,-4 0,0 -5,4" }), fre = ({ color: e = "none", strokeWidth: t = 1 }) => x.jsx("polyline", { style: {
  stroke: e,
  fill: e,
  strokeWidth: t
}, strokeLinecap: "round", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4 -5,-4" }), YA = {
  [Sp.Arrow]: cre,
  [Sp.ArrowClosed]: fre
};
function dre(e) {
  const t = kt();
  return _.useMemo(() => Object.prototype.hasOwnProperty.call(YA, e) ? YA[e] : (t.getState().onError?.("009", vo.error009(e)), null), [e]);
}
const hre = ({ id: e, type: t, color: n, width: r = 12.5, height: o = 12.5, markerUnits: a = "strokeWidth", strokeWidth: s, orient: u = "auto-start-reverse" }) => {
  const c = dre(t);
  return c ? x.jsx("marker", { className: "react-flow__arrowhead", id: e, markerWidth: `${r}`, markerHeight: `${o}`, viewBox: "-10 -10 20 20", markerUnits: a, orient: u, refX: "0", refY: "0", children: x.jsx(c, { color: n, strokeWidth: s }) }) : null;
}, Q5 = ({ defaultColor: e, rfId: t }) => {
  const n = Je((a) => a.edges), r = Je((a) => a.defaultEdgeOptions), o = _.useMemo(() => Cte(n, {
    id: t,
    defaultColor: e,
    defaultMarkerStart: r?.markerStart,
    defaultMarkerEnd: r?.markerEnd
  }), [n, r, t, e]);
  return o.length ? x.jsx("svg", { className: "react-flow__marker", "aria-hidden": "true", children: x.jsx("defs", { children: o.map((a) => x.jsx(hre, { id: a.id, type: a.type, color: a.color, width: a.width, height: a.height, markerUnits: a.markerUnits, strokeWidth: a.strokeWidth, orient: a.orient }, a.id)) }) }) : null;
};
Q5.displayName = "MarkerDefinitions";
var pre = _.memo(Q5);
function J5({ x: e, y: t, label: n, labelStyle: r, labelShowBg: o = !0, labelBgStyle: a, labelBgPadding: s = [2, 4], labelBgBorderRadius: u = 2, children: c, className: f, ...h }) {
  const [p, g] = _.useState({ x: 1, y: 0, width: 0, height: 0 }), y = Wt(["react-flow__edge-textwrapper", f]), w = _.useRef(null);
  return _.useEffect(() => {
    if (w.current) {
      const v = w.current.getBBox();
      g({
        x: v.x,
        y: v.y,
        width: v.width,
        height: v.height
      });
    }
  }, [n]), n ? x.jsxs("g", { transform: `translate(${e - p.width / 2} ${t - p.height / 2})`, className: y, visibility: p.width ? "visible" : "hidden", ...h, children: [o && x.jsx("rect", { width: p.width + 2 * s[0], x: -s[0], y: -s[1], height: p.height + 2 * s[1], className: "react-flow__edge-textbg", style: a, rx: u, ry: u }), x.jsx("text", { className: "react-flow__edge-text", y: p.height / 2, dy: "0.3em", ref: w, style: r, children: n }), c] }) : null;
}
J5.displayName = "EdgeText";
const mre = _.memo(J5);
function xf({ path: e, labelX: t, labelY: n, label: r, labelStyle: o, labelShowBg: a, labelBgStyle: s, labelBgPadding: u, labelBgBorderRadius: c, interactionWidth: f = 20, ...h }) {
  return x.jsxs(x.Fragment, { children: [x.jsx("path", { ...h, d: e, fill: "none", className: Wt(["react-flow__edge-path", h.className]) }), f && x.jsx("path", { d: e, fill: "none", strokeOpacity: 0, strokeWidth: f, className: "react-flow__edge-interaction" }), r && Ir(t) && Ir(n) ? x.jsx(mre, { x: t, y: n, label: r, labelStyle: o, labelShowBg: a, labelBgStyle: s, labelBgPadding: u, labelBgBorderRadius: c }) : null] });
}
function WA({ pos: e, x1: t, y1: n, x2: r, y2: o }) {
  return e === Te.Left || e === Te.Right ? [0.5 * (t + r), n] : [t, 0.5 * (n + o)];
}
function e4({ sourceX: e, sourceY: t, sourcePosition: n = Te.Bottom, targetX: r, targetY: o, targetPosition: a = Te.Top }) {
  const [s, u] = WA({
    pos: n,
    x1: e,
    y1: t,
    x2: r,
    y2: o
  }), [c, f] = WA({
    pos: a,
    x1: r,
    y1: o,
    x2: e,
    y2: t
  }), [h, p, g, y] = C5({
    sourceX: e,
    sourceY: t,
    targetX: r,
    targetY: o,
    sourceControlX: s,
    sourceControlY: u,
    targetControlX: c,
    targetControlY: f
  });
  return [
    `M${e},${t} C${s},${u} ${c},${f} ${r},${o}`,
    h,
    p,
    g,
    y
  ];
}
function t4(e) {
  return _.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: a, sourcePosition: s, targetPosition: u, label: c, labelStyle: f, labelShowBg: h, labelBgStyle: p, labelBgPadding: g, labelBgBorderRadius: y, style: w, markerEnd: v, markerStart: S, interactionWidth: E }) => {
    const [T, k, A] = e4({
      sourceX: n,
      sourceY: r,
      sourcePosition: s,
      targetX: o,
      targetY: a,
      targetPosition: u
    }), M = e.isInternal ? void 0 : t;
    return x.jsx(xf, { id: M, path: T, labelX: k, labelY: A, label: c, labelStyle: f, labelShowBg: h, labelBgStyle: p, labelBgPadding: g, labelBgBorderRadius: y, style: w, markerEnd: v, markerStart: S, interactionWidth: E });
  });
}
const gre = t4({ isInternal: !1 }), n4 = t4({ isInternal: !0 });
gre.displayName = "SimpleBezierEdge";
n4.displayName = "SimpleBezierEdgeInternal";
function r4(e) {
  return _.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: a, label: s, labelStyle: u, labelShowBg: c, labelBgStyle: f, labelBgPadding: h, labelBgBorderRadius: p, style: g, sourcePosition: y = Te.Bottom, targetPosition: w = Te.Top, markerEnd: v, markerStart: S, pathOptions: E, interactionWidth: T }) => {
    const [k, A, M] = zb({
      sourceX: n,
      sourceY: r,
      sourcePosition: y,
      targetX: o,
      targetY: a,
      targetPosition: w,
      borderRadius: E?.borderRadius,
      offset: E?.offset,
      stepPosition: E?.stepPosition
    }), N = e.isInternal ? void 0 : t;
    return x.jsx(xf, { id: N, path: k, labelX: A, labelY: M, label: s, labelStyle: u, labelShowBg: c, labelBgStyle: f, labelBgPadding: h, labelBgBorderRadius: p, style: g, markerEnd: v, markerStart: S, interactionWidth: T });
  });
}
const o4 = r4({ isInternal: !1 }), i4 = r4({ isInternal: !0 });
o4.displayName = "SmoothStepEdge";
i4.displayName = "SmoothStepEdgeInternal";
function a4(e) {
  return _.memo(({ id: t, ...n }) => {
    const r = e.isInternal ? void 0 : t;
    return x.jsx(o4, { ...n, id: r, pathOptions: _.useMemo(() => ({ borderRadius: 0, offset: n.pathOptions?.offset }), [n.pathOptions?.offset]) });
  });
}
const yre = a4({ isInternal: !1 }), s4 = a4({ isInternal: !0 });
yre.displayName = "StepEdge";
s4.displayName = "StepEdgeInternal";
function l4(e) {
  return _.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: a, label: s, labelStyle: u, labelShowBg: c, labelBgStyle: f, labelBgPadding: h, labelBgBorderRadius: p, style: g, markerEnd: y, markerStart: w, interactionWidth: v }) => {
    const [S, E, T] = T5({ sourceX: n, sourceY: r, targetX: o, targetY: a }), k = e.isInternal ? void 0 : t;
    return x.jsx(xf, { id: k, path: S, labelX: E, labelY: T, label: s, labelStyle: u, labelShowBg: c, labelBgStyle: f, labelBgPadding: h, labelBgBorderRadius: p, style: g, markerEnd: y, markerStart: w, interactionWidth: v });
  });
}
const vre = l4({ isInternal: !1 }), u4 = l4({ isInternal: !0 });
vre.displayName = "StraightEdge";
u4.displayName = "StraightEdgeInternal";
function c4(e) {
  return _.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: a, sourcePosition: s = Te.Bottom, targetPosition: u = Te.Top, label: c, labelStyle: f, labelShowBg: h, labelBgStyle: p, labelBgPadding: g, labelBgBorderRadius: y, style: w, markerEnd: v, markerStart: S, pathOptions: E, interactionWidth: T }) => {
    const [k, A, M] = Rx({
      sourceX: n,
      sourceY: r,
      sourcePosition: s,
      targetX: o,
      targetY: a,
      targetPosition: u,
      curvature: E?.curvature
    }), N = e.isInternal ? void 0 : t;
    return x.jsx(xf, { id: N, path: k, labelX: A, labelY: M, label: c, labelStyle: f, labelShowBg: h, labelBgStyle: p, labelBgPadding: g, labelBgBorderRadius: y, style: w, markerEnd: v, markerStart: S, interactionWidth: T });
  });
}
const bre = c4({ isInternal: !1 }), f4 = c4({ isInternal: !0 });
bre.displayName = "BezierEdge";
f4.displayName = "BezierEdgeInternal";
const XA = {
  default: f4,
  straight: u4,
  step: s4,
  smoothstep: i4,
  simplebezier: n4
}, KA = {
  sourceX: null,
  sourceY: null,
  targetX: null,
  targetY: null,
  sourcePosition: null,
  targetPosition: null
}, xre = (e, t, n) => n === Te.Left ? e - t : n === Te.Right ? e + t : e, wre = (e, t, n) => n === Te.Top ? e - t : n === Te.Bottom ? e + t : e, ZA = "react-flow__edgeupdater";
function QA({ position: e, centerX: t, centerY: n, radius: r = 10, onMouseDown: o, onMouseEnter: a, onMouseOut: s, type: u }) {
  return x.jsx("circle", { onMouseDown: o, onMouseEnter: a, onMouseOut: s, className: Wt([ZA, `${ZA}-${u}`]), cx: xre(t, r, e), cy: wre(n, r, e), r, stroke: "transparent", fill: "transparent" });
}
function _re({ isReconnectable: e, reconnectRadius: t, edge: n, sourceX: r, sourceY: o, targetX: a, targetY: s, sourcePosition: u, targetPosition: c, onReconnect: f, onReconnectStart: h, onReconnectEnd: p, setReconnecting: g, setUpdateHover: y }) {
  const w = kt(), v = (A, M) => {
    if (A.button !== 0)
      return;
    const { autoPanOnConnect: N, domNode: P, isValidConnection: z, connectionMode: B, connectionRadius: R, lib: F, onConnectStart: U, onConnectEnd: W, cancelConnection: j, nodeLookup: V, rfId: I, panBy: H, updateConnection: q } = w.getState(), G = M.type === "target", O = (L, te) => {
      g(!1), p?.(L, n, M.type, te);
    }, Y = (L) => f?.(n, L), Z = (L, te) => {
      g(!0), h?.(A, n, M.type), U?.(L, te);
    };
    $b.onPointerDown(A.nativeEvent, {
      autoPanOnConnect: N,
      connectionMode: B,
      connectionRadius: R,
      domNode: P,
      handleId: M.id,
      nodeId: M.nodeId,
      nodeLookup: V,
      isTarget: G,
      edgeUpdaterType: M.type,
      lib: F,
      flowId: I,
      cancelConnection: j,
      panBy: H,
      isValidConnection: z,
      onConnect: Y,
      onConnectStart: Z,
      onConnectEnd: W,
      onReconnectEnd: O,
      updateConnection: q,
      getTransform: () => w.getState().transform,
      getFromHandle: () => w.getState().connection.fromHandle,
      dragThreshold: w.getState().connectionDragThreshold
    });
  }, S = (A) => v(A, { nodeId: n.target, id: n.targetHandle ?? null, type: "target" }), E = (A) => v(A, { nodeId: n.source, id: n.sourceHandle ?? null, type: "source" }), T = () => y(!0), k = () => y(!1);
  return x.jsxs(x.Fragment, { children: [(e === !0 || e === "source") && x.jsx(QA, { position: u, centerX: r, centerY: o, radius: t, onMouseDown: S, onMouseEnter: T, onMouseOut: k, type: "source" }), (e === !0 || e === "target") && x.jsx(QA, { position: c, centerX: a, centerY: s, radius: t, onMouseDown: E, onMouseEnter: T, onMouseOut: k, type: "target" })] });
}
function Sre({ id: e, edgesFocusable: t, edgesReconnectable: n, elementsSelectable: r, onClick: o, onDoubleClick: a, onContextMenu: s, onMouseEnter: u, onMouseMove: c, onMouseLeave: f, reconnectRadius: h, onReconnect: p, onReconnectStart: g, onReconnectEnd: y, rfId: w, edgeTypes: v, noPanClassName: S, onError: E, disableKeyboardA11y: T }) {
  let k = Je((we) => we.edgeLookup.get(e));
  const A = Je((we) => we.defaultEdgeOptions);
  k = A ? { ...A, ...k } : k;
  let M = k.type || "default", N = v?.[M] || XA[M];
  N === void 0 && (E?.("011", vo.error011(M)), M = "default", N = v?.default || XA.default);
  const P = !!(k.focusable || t && typeof k.focusable > "u"), z = typeof p < "u" && (k.reconnectable || n && typeof k.reconnectable > "u"), B = !!(k.selectable || r && typeof k.selectable > "u"), R = _.useRef(null), [F, U] = _.useState(!1), [W, j] = _.useState(!1), V = kt(), { zIndex: I, sourceX: H, sourceY: q, targetX: G, targetY: O, sourcePosition: Y, targetPosition: Z } = Je(_.useCallback((we) => {
    const Ee = we.nodeLookup.get(k.source), _e = we.nodeLookup.get(k.target);
    if (!Ee || !_e)
      return {
        zIndex: k.zIndex,
        ...KA
      };
    const Xe = Ete({
      id: e,
      sourceNode: Ee,
      targetNode: _e,
      sourceHandle: k.sourceHandle || null,
      targetHandle: k.targetHandle || null,
      connectionMode: we.connectionMode,
      onError: E
    });
    return {
      zIndex: gte({
        selected: k.selected,
        zIndex: k.zIndex,
        sourceNode: Ee,
        targetNode: _e,
        elevateOnSelect: we.elevateEdgesOnSelect
      }),
      ...Xe || KA
    };
  }, [k.source, k.target, k.sourceHandle, k.targetHandle, k.selected, k.zIndex]), At), L = _.useMemo(() => k.markerStart ? `url('#${Lb(k.markerStart, w)}')` : void 0, [k.markerStart, w]), te = _.useMemo(() => k.markerEnd ? `url('#${Lb(k.markerEnd, w)}')` : void 0, [k.markerEnd, w]);
  if (k.hidden || H === null || q === null || G === null || O === null)
    return null;
  const he = (we) => {
    const { addSelectedEdges: Ee, unselectNodesAndEdges: _e, multiSelectionActive: Xe } = V.getState();
    B && (V.setState({ nodesSelectionActive: !1 }), k.selected && Xe ? (_e({ nodes: [], edges: [k] }), R.current?.blur()) : Ee([e])), o && o(we, k);
  }, oe = a ? (we) => {
    a(we, { ...k });
  } : void 0, de = s ? (we) => {
    s(we, { ...k });
  } : void 0, le = u ? (we) => {
    u(we, { ...k });
  } : void 0, ye = c ? (we) => {
    c(we, { ...k });
  } : void 0, je = f ? (we) => {
    f(we, { ...k });
  } : void 0, Ne = (we) => {
    if (!T && f5.includes(we.key) && B) {
      const { unselectNodesAndEdges: Ee, addSelectedEdges: _e } = V.getState();
      we.key === "Escape" ? (R.current?.blur(), Ee({ edges: [k] })) : _e([e]);
    }
  };
  return x.jsx("svg", { style: { zIndex: I }, children: x.jsxs("g", { className: Wt([
    "react-flow__edge",
    `react-flow__edge-${M}`,
    k.className,
    S,
    {
      selected: k.selected,
      animated: k.animated,
      inactive: !B && !o,
      updating: F,
      selectable: B
    }
  ]), onClick: he, onDoubleClick: oe, onContextMenu: de, onMouseEnter: le, onMouseMove: ye, onMouseLeave: je, onKeyDown: P ? Ne : void 0, tabIndex: P ? 0 : void 0, role: k.ariaRole ?? (P ? "group" : "img"), "aria-roledescription": "edge", "data-id": e, "data-testid": `rf__edge-${e}`, "aria-label": k.ariaLabel === null ? void 0 : k.ariaLabel || `Edge from ${k.source} to ${k.target}`, "aria-describedby": P ? `${B5}-${w}` : void 0, ref: R, ...k.domAttributes, children: [!W && x.jsx(N, { id: e, source: k.source, target: k.target, type: k.type, selected: k.selected, animated: k.animated, selectable: B, deletable: k.deletable ?? !0, label: k.label, labelStyle: k.labelStyle, labelShowBg: k.labelShowBg, labelBgStyle: k.labelBgStyle, labelBgPadding: k.labelBgPadding, labelBgBorderRadius: k.labelBgBorderRadius, sourceX: H, sourceY: q, targetX: G, targetY: O, sourcePosition: Y, targetPosition: Z, data: k.data, style: k.style, sourceHandleId: k.sourceHandle, targetHandleId: k.targetHandle, markerStart: L, markerEnd: te, pathOptions: "pathOptions" in k ? k.pathOptions : void 0, interactionWidth: k.interactionWidth }), z && x.jsx(_re, { edge: k, isReconnectable: z, reconnectRadius: h, onReconnect: p, onReconnectStart: g, onReconnectEnd: y, sourceX: H, sourceY: q, targetX: G, targetY: O, sourcePosition: Y, targetPosition: Z, setUpdateHover: U, setReconnecting: j })] }) });
}
const Ere = (e) => ({
  edgesFocusable: e.edgesFocusable,
  edgesReconnectable: e.edgesReconnectable,
  elementsSelectable: e.elementsSelectable,
  connectionMode: e.connectionMode,
  onError: e.onError
});
function d4({ defaultMarkerColor: e, onlyRenderVisibleElements: t, rfId: n, edgeTypes: r, noPanClassName: o, onReconnect: a, onEdgeContextMenu: s, onEdgeMouseEnter: u, onEdgeMouseMove: c, onEdgeMouseLeave: f, onEdgeClick: h, reconnectRadius: p, onEdgeDoubleClick: g, onReconnectStart: y, onReconnectEnd: w, disableKeyboardA11y: v }) {
  const { edgesFocusable: S, edgesReconnectable: E, elementsSelectable: T, onError: k } = Je(Ere, At), A = ure(t);
  return x.jsxs("div", { className: "react-flow__edges", children: [x.jsx(pre, { defaultColor: e, rfId: n }), A.map((M) => x.jsx(Sre, { id: M, edgesFocusable: S, edgesReconnectable: E, elementsSelectable: T, noPanClassName: o, onReconnect: a, onContextMenu: s, onMouseEnter: u, onMouseMove: c, onMouseLeave: f, onClick: h, reconnectRadius: p, onDoubleClick: g, onReconnectStart: y, onReconnectEnd: w, rfId: n, onError: k, edgeTypes: r, disableKeyboardA11y: v }, M))] });
}
d4.displayName = "EdgeRenderer";
const Cre = _.memo(d4), kre = (e) => `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]})`;
function Tre({ children: e }) {
  const t = Je(kre);
  return x.jsx("div", { className: "react-flow__viewport xyflow__viewport react-flow__container", style: { transform: t }, children: e });
}
function Are(e) {
  const t = es(), n = _.useRef(!1);
  _.useEffect(() => {
    !n.current && t.viewportInitialized && e && (setTimeout(() => e(t), 1), n.current = !0);
  }, [e, t.viewportInitialized]);
}
const Rre = (e) => e.panZoom?.syncViewport;
function Mre(e) {
  const t = Je(Rre), n = kt();
  return _.useEffect(() => {
    e && (t?.(e), n.setState({ transform: [e.x, e.y, e.zoom] }));
  }, [e, t]), null;
}
function Ore(e) {
  return e.connection.inProgress ? { ...e.connection, to: bf(e.connection.to, e.transform) } : { ...e.connection };
}
function Nre(e) {
  return Ore;
}
function Dre(e) {
  const t = Nre();
  return Je(t, At);
}
const Pre = (e) => ({
  nodesConnectable: e.nodesConnectable,
  isValid: e.connection.isValid,
  inProgress: e.connection.inProgress,
  width: e.width,
  height: e.height
});
function jre({ containerStyle: e, style: t, type: n, component: r }) {
  const { nodesConnectable: o, width: a, height: s, isValid: u, inProgress: c } = Je(Pre, At);
  return !(a && o && c) ? null : x.jsx("svg", { style: e, width: a, height: s, className: "react-flow__connectionline react-flow__container", children: x.jsx("g", { className: Wt(["react-flow__connection", p5(u)]), children: x.jsx(h4, { style: t, type: n, CustomComponent: r, isValid: u }) }) });
}
const h4 = ({ style: e, type: t = Xi.Bezier, CustomComponent: n, isValid: r }) => {
  const { inProgress: o, from: a, fromNode: s, fromHandle: u, fromPosition: c, to: f, toNode: h, toHandle: p, toPosition: g } = Dre();
  if (!o)
    return;
  if (n)
    return x.jsx(n, { connectionLineType: t, connectionLineStyle: e, fromNode: s, fromHandle: u, fromX: a.x, fromY: a.y, toX: f.x, toY: f.y, fromPosition: c, toPosition: g, connectionStatus: p5(r), toNode: h, toHandle: p });
  let y = "";
  const w = {
    sourceX: a.x,
    sourceY: a.y,
    sourcePosition: c,
    targetX: f.x,
    targetY: f.y,
    targetPosition: g
  };
  switch (t) {
    case Xi.Bezier:
      [y] = Rx(w);
      break;
    case Xi.SimpleBezier:
      [y] = e4(w);
      break;
    case Xi.Step:
      [y] = zb({
        ...w,
        borderRadius: 0
      });
      break;
    case Xi.SmoothStep:
      [y] = zb(w);
      break;
    default:
      [y] = T5(w);
  }
  return x.jsx("path", { d: y, fill: "none", className: "react-flow__connection-path", style: e });
};
h4.displayName = "ConnectionLine";
const Ire = {};
function JA(e = Ire) {
  _.useRef(e), kt(), _.useEffect(() => {
  }, [e]);
}
function zre() {
  kt(), _.useRef(!1), _.useEffect(() => {
  }, []);
}
function p4({ nodeTypes: e, edgeTypes: t, onInit: n, onNodeClick: r, onEdgeClick: o, onNodeDoubleClick: a, onEdgeDoubleClick: s, onNodeMouseEnter: u, onNodeMouseMove: c, onNodeMouseLeave: f, onNodeContextMenu: h, onSelectionContextMenu: p, onSelectionStart: g, onSelectionEnd: y, connectionLineType: w, connectionLineStyle: v, connectionLineComponent: S, connectionLineContainerStyle: E, selectionKeyCode: T, selectionOnDrag: k, selectionMode: A, multiSelectionKeyCode: M, panActivationKeyCode: N, zoomActivationKeyCode: P, deleteKeyCode: z, onlyRenderVisibleElements: B, elementsSelectable: R, defaultViewport: F, translateExtent: U, minZoom: W, maxZoom: j, preventScrolling: V, defaultMarkerColor: I, zoomOnScroll: H, zoomOnPinch: q, panOnScroll: G, panOnScrollSpeed: O, panOnScrollMode: Y, zoomOnDoubleClick: Z, panOnDrag: L, onPaneClick: te, onPaneMouseEnter: he, onPaneMouseMove: oe, onPaneMouseLeave: de, onPaneScroll: le, onPaneContextMenu: ye, paneClickDistance: je, nodeClickDistance: Ne, onEdgeContextMenu: we, onEdgeMouseEnter: Ee, onEdgeMouseMove: _e, onEdgeMouseLeave: Xe, reconnectRadius: St, onReconnect: ct, onReconnectStart: cn, onReconnectEnd: fr, noDragClassName: Un, noWheelClassName: qn, noPanClassName: ze, disableKeyboardA11y: qr, nodeExtent: ca, rfId: gi, viewport: ae, onViewportChange: pe }) {
  return JA(e), JA(t), zre(), Are(n), Mre(ae), x.jsx(ere, { onPaneClick: te, onPaneMouseEnter: he, onPaneMouseMove: oe, onPaneMouseLeave: de, onPaneContextMenu: ye, onPaneScroll: le, paneClickDistance: je, deleteKeyCode: z, selectionKeyCode: T, selectionOnDrag: k, selectionMode: A, onSelectionStart: g, onSelectionEnd: y, multiSelectionKeyCode: M, panActivationKeyCode: N, zoomActivationKeyCode: P, elementsSelectable: R, zoomOnScroll: H, zoomOnPinch: q, zoomOnDoubleClick: Z, panOnScroll: G, panOnScrollSpeed: O, panOnScrollMode: Y, panOnDrag: L, defaultViewport: F, translateExtent: U, minZoom: W, maxZoom: j, onSelectionContextMenu: p, preventScrolling: V, noDragClassName: Un, noWheelClassName: qn, noPanClassName: ze, disableKeyboardA11y: qr, onViewportChange: pe, isControlledViewport: !!ae, children: x.jsxs(Tre, { children: [x.jsx(Cre, { edgeTypes: t, onEdgeClick: o, onEdgeDoubleClick: s, onReconnect: ct, onReconnectStart: cn, onReconnectEnd: fr, onlyRenderVisibleElements: B, onEdgeContextMenu: we, onEdgeMouseEnter: Ee, onEdgeMouseMove: _e, onEdgeMouseLeave: Xe, reconnectRadius: St, defaultMarkerColor: I, noPanClassName: ze, disableKeyboardA11y: qr, rfId: gi }), x.jsx(jre, { style: v, type: w, component: S, containerStyle: E }), x.jsx("div", { className: "react-flow__edgelabel-renderer" }), x.jsx(lre, { nodeTypes: e, onNodeClick: r, onNodeDoubleClick: a, onNodeMouseEnter: u, onNodeMouseMove: c, onNodeMouseLeave: f, onNodeContextMenu: h, nodeClickDistance: Ne, onlyRenderVisibleElements: B, noPanClassName: ze, noDragClassName: Un, disableKeyboardA11y: qr, nodeExtent: ca, rfId: gi }), x.jsx("div", { className: "react-flow__viewport-portal" })] }) });
}
p4.displayName = "GraphView";
const Lre = _.memo(p4), eR = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, width: o, height: a, fitView: s, fitViewOptions: u, minZoom: c = 0.5, maxZoom: f = 2, nodeOrigin: h, nodeExtent: p } = {}) => {
  const g = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Map(), w = /* @__PURE__ */ new Map(), v = /* @__PURE__ */ new Map(), S = r ?? t ?? [], E = n ?? e ?? [], T = h ?? [0, 0], k = p ?? Hc;
  R5(w, v, S);
  const A = Fb(E, g, y, {
    nodeOrigin: T,
    nodeExtent: k,
    elevateNodesOnSelect: !1
  });
  let M = [0, 0, 1];
  if (s && o && a) {
    const N = vf(g, {
      filter: (R) => !!((R.width || R.initialWidth) && (R.height || R.initialHeight))
    }), { x: P, y: z, zoom: B } = Tx(N, o, a, c, f, u?.padding ?? 0.1);
    M = [P, z, B];
  }
  return {
    rfId: "1",
    width: 0,
    height: 0,
    transform: M,
    nodes: E,
    nodesInitialized: A,
    nodeLookup: g,
    parentLookup: y,
    edges: S,
    edgeLookup: v,
    connectionLookup: w,
    onNodesChange: null,
    onEdgesChange: null,
    hasDefaultNodes: n !== void 0,
    hasDefaultEdges: r !== void 0,
    panZoom: null,
    minZoom: c,
    maxZoom: f,
    translateExtent: Hc,
    nodeExtent: k,
    nodesSelectionActive: !1,
    userSelectionActive: !1,
    userSelectionRect: null,
    connectionMode: Cl.Strict,
    domNode: null,
    paneDragging: !1,
    noPanClassName: "nopan",
    nodeOrigin: T,
    nodeDragThreshold: 1,
    connectionDragThreshold: 1,
    snapGrid: [15, 15],
    snapToGrid: !1,
    nodesDraggable: !0,
    nodesConnectable: !0,
    nodesFocusable: !0,
    edgesFocusable: !0,
    edgesReconnectable: !0,
    elementsSelectable: !0,
    elevateNodesOnSelect: !0,
    elevateEdgesOnSelect: !1,
    selectNodesOnDrag: !0,
    multiSelectionActive: !1,
    fitViewQueued: s ?? !1,
    fitViewOptions: u,
    fitViewResolver: null,
    connection: { ...h5 },
    connectionClickStartHandle: null,
    connectOnClick: !0,
    ariaLiveMessage: "",
    autoPanOnConnect: !0,
    autoPanOnNodeDrag: !0,
    autoPanOnNodeFocus: !0,
    autoPanSpeed: 15,
    connectionRadius: 20,
    onError: cte,
    isValidConnection: void 0,
    onSelectionChangeHandlers: [],
    lib: "react",
    debug: !1,
    ariaLabelConfig: d5
  };
}, Fre = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, width: o, height: a, fitView: s, fitViewOptions: u, minZoom: c, maxZoom: f, nodeOrigin: h, nodeExtent: p }) => ine((g, y) => {
  async function w() {
    const { nodeLookup: v, panZoom: S, fitViewOptions: E, fitViewResolver: T, width: k, height: A, minZoom: M, maxZoom: N } = y();
    S && (await lte({
      nodes: v,
      width: k,
      height: A,
      panZoom: S,
      minZoom: M,
      maxZoom: N
    }, E), T?.resolve(!0), g({ fitViewResolver: null }));
  }
  return {
    ...eR({
      nodes: e,
      edges: t,
      width: o,
      height: a,
      fitView: s,
      fitViewOptions: u,
      minZoom: c,
      maxZoom: f,
      nodeOrigin: h,
      nodeExtent: p,
      defaultNodes: n,
      defaultEdges: r
    }),
    setNodes: (v) => {
      const { nodeLookup: S, parentLookup: E, nodeOrigin: T, elevateNodesOnSelect: k, fitViewQueued: A } = y(), M = Fb(v, S, E, {
        nodeOrigin: T,
        nodeExtent: p,
        elevateNodesOnSelect: k,
        checkEquality: !0
      });
      A && M ? (w(), g({ nodes: v, nodesInitialized: M, fitViewQueued: !1, fitViewOptions: void 0 })) : g({ nodes: v, nodesInitialized: M });
    },
    setEdges: (v) => {
      const { connectionLookup: S, edgeLookup: E } = y();
      R5(S, E, v), g({ edges: v });
    },
    setDefaultNodesAndEdges: (v, S) => {
      if (v) {
        const { setNodes: E } = y();
        E(v), g({ hasDefaultNodes: !0 });
      }
      if (S) {
        const { setEdges: E } = y();
        E(S), g({ hasDefaultEdges: !0 });
      }
    },
    /*
     * Every node gets registerd at a ResizeObserver. Whenever a node
     * changes its dimensions, this function is called to measure the
     * new dimensions and update the nodes.
     */
    updateNodeInternals: (v) => {
      const { triggerNodeChanges: S, nodeLookup: E, parentLookup: T, domNode: k, nodeOrigin: A, nodeExtent: M, debug: N, fitViewQueued: P } = y(), { changes: z, updatedInternals: B } = Mte(v, E, T, k, A, M);
      B && (Tte(E, T, { nodeOrigin: A, nodeExtent: M }), P ? (w(), g({ fitViewQueued: !1, fitViewOptions: void 0 })) : g({}), z?.length > 0 && (N && console.log("React Flow: trigger node changes", z), S?.(z)));
    },
    updateNodePositions: (v, S = !1) => {
      const E = [], T = [], { nodeLookup: k, triggerNodeChanges: A } = y();
      for (const [M, N] of v) {
        const P = k.get(M), z = !!(P?.expandParent && P?.parentId && N?.position), B = {
          id: M,
          type: "position",
          position: z ? {
            x: Math.max(0, N.position.x),
            y: Math.max(0, N.position.y)
          } : N.position,
          dragging: S
        };
        z && P.parentId && E.push({
          id: M,
          parentId: P.parentId,
          rect: {
            ...N.internals.positionAbsolute,
            width: N.measured.width ?? 0,
            height: N.measured.height ?? 0
          }
        }), T.push(B);
      }
      if (E.length > 0) {
        const { parentLookup: M, nodeOrigin: N } = y(), P = Dx(E, k, M, N);
        T.push(...P);
      }
      A(T);
    },
    triggerNodeChanges: (v) => {
      const { onNodesChange: S, setNodes: E, nodes: T, hasDefaultNodes: k, debug: A } = y();
      if (v?.length) {
        if (k) {
          const M = Px(v, T);
          E(M);
        }
        A && console.log("React Flow: trigger node changes", v), S?.(v);
      }
    },
    triggerEdgeChanges: (v) => {
      const { onEdgesChange: S, setEdges: E, edges: T, hasDefaultEdges: k, debug: A } = y();
      if (v?.length) {
        if (k) {
          const M = U5(v, T);
          E(M);
        }
        A && console.log("React Flow: trigger edge changes", v), S?.(v);
      }
    },
    addSelectedNodes: (v) => {
      const { multiSelectionActive: S, edgeLookup: E, nodeLookup: T, triggerNodeChanges: k, triggerEdgeChanges: A } = y();
      if (S) {
        const M = v.map((N) => Oa(N, !0));
        k(M);
        return;
      }
      k(il(T, /* @__PURE__ */ new Set([...v]), !0)), A(il(E));
    },
    addSelectedEdges: (v) => {
      const { multiSelectionActive: S, edgeLookup: E, nodeLookup: T, triggerNodeChanges: k, triggerEdgeChanges: A } = y();
      if (S) {
        const M = v.map((N) => Oa(N, !0));
        A(M);
        return;
      }
      A(il(E, /* @__PURE__ */ new Set([...v]))), k(il(T, /* @__PURE__ */ new Set(), !0));
    },
    unselectNodesAndEdges: ({ nodes: v, edges: S } = {}) => {
      const { edges: E, nodes: T, nodeLookup: k, triggerNodeChanges: A, triggerEdgeChanges: M } = y(), N = v || T, P = S || E, z = N.map((R) => {
        const F = k.get(R.id);
        return F && (F.selected = !1), Oa(R.id, !1);
      }), B = P.map((R) => Oa(R.id, !1));
      A(z), M(B);
    },
    setMinZoom: (v) => {
      const { panZoom: S, maxZoom: E } = y();
      S?.setScaleExtent([v, E]), g({ minZoom: v });
    },
    setMaxZoom: (v) => {
      const { panZoom: S, minZoom: E } = y();
      S?.setScaleExtent([E, v]), g({ maxZoom: v });
    },
    setTranslateExtent: (v) => {
      y().panZoom?.setTranslateExtent(v), g({ translateExtent: v });
    },
    setPaneClickDistance: (v) => {
      y().panZoom?.setClickDistance(v);
    },
    resetSelectedElements: () => {
      const { edges: v, nodes: S, triggerNodeChanges: E, triggerEdgeChanges: T, elementsSelectable: k } = y();
      if (!k)
        return;
      const A = S.reduce((N, P) => P.selected ? [...N, Oa(P.id, !1)] : N, []), M = v.reduce((N, P) => P.selected ? [...N, Oa(P.id, !1)] : N, []);
      E(A), T(M);
    },
    setNodeExtent: (v) => {
      const { nodes: S, nodeLookup: E, parentLookup: T, nodeOrigin: k, elevateNodesOnSelect: A, nodeExtent: M } = y();
      v[0][0] === M[0][0] && v[0][1] === M[0][1] && v[1][0] === M[1][0] && v[1][1] === M[1][1] || (Fb(S, E, T, {
        nodeOrigin: k,
        nodeExtent: v,
        elevateNodesOnSelect: A,
        checkEquality: !1
      }), g({ nodeExtent: v }));
    },
    panBy: (v) => {
      const { transform: S, width: E, height: T, panZoom: k, translateExtent: A } = y();
      return Ote({ delta: v, panZoom: k, transform: S, translateExtent: A, width: E, height: T });
    },
    setCenter: async (v, S, E) => {
      const { width: T, height: k, maxZoom: A, panZoom: M } = y();
      if (!M)
        return Promise.resolve(!1);
      const N = typeof E?.zoom < "u" ? E.zoom : A;
      return await M.setViewport({
        x: T / 2 - v * N,
        y: k / 2 - S * N,
        zoom: N
      }, { duration: E?.duration, ease: E?.ease, interpolate: E?.interpolate }), Promise.resolve(!0);
    },
    cancelConnection: () => {
      g({
        connection: { ...h5 }
      });
    },
    updateConnection: (v) => {
      g({ connection: v });
    },
    reset: () => g({ ...eR() })
  };
}, Object.is);
function $re({ initialNodes: e, initialEdges: t, defaultNodes: n, defaultEdges: r, initialWidth: o, initialHeight: a, initialMinZoom: s, initialMaxZoom: u, initialFitViewOptions: c, fitView: f, nodeOrigin: h, nodeExtent: p, children: g }) {
  const [y] = _.useState(() => Fre({
    nodes: e,
    edges: t,
    defaultNodes: n,
    defaultEdges: r,
    width: o,
    height: a,
    fitView: f,
    minZoom: s,
    maxZoom: u,
    fitViewOptions: c,
    nodeOrigin: h,
    nodeExtent: p
  }));
  return x.jsx(ane, { value: y, children: x.jsx(Rne, { children: g }) });
}
function Bre({ children: e, nodes: t, edges: n, defaultNodes: r, defaultEdges: o, width: a, height: s, fitView: u, fitViewOptions: c, minZoom: f, maxZoom: h, nodeOrigin: p, nodeExtent: g }) {
  return _.useContext(zm) ? x.jsx(x.Fragment, { children: e }) : x.jsx($re, { initialNodes: t, initialEdges: n, defaultNodes: r, defaultEdges: o, initialWidth: a, initialHeight: s, fitView: u, initialFitViewOptions: c, initialMinZoom: f, initialMaxZoom: h, nodeOrigin: p, nodeExtent: g, children: e });
}
const Hre = {
  width: "100%",
  height: "100%",
  overflow: "hidden",
  position: "relative",
  zIndex: 0
};
function Vre({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, className: o, nodeTypes: a, edgeTypes: s, onNodeClick: u, onEdgeClick: c, onInit: f, onMove: h, onMoveStart: p, onMoveEnd: g, onConnect: y, onConnectStart: w, onConnectEnd: v, onClickConnectStart: S, onClickConnectEnd: E, onNodeMouseEnter: T, onNodeMouseMove: k, onNodeMouseLeave: A, onNodeContextMenu: M, onNodeDoubleClick: N, onNodeDragStart: P, onNodeDrag: z, onNodeDragStop: B, onNodesDelete: R, onEdgesDelete: F, onDelete: U, onSelectionChange: W, onSelectionDragStart: j, onSelectionDrag: V, onSelectionDragStop: I, onSelectionContextMenu: H, onSelectionStart: q, onSelectionEnd: G, onBeforeDelete: O, connectionMode: Y, connectionLineType: Z = Xi.Bezier, connectionLineStyle: L, connectionLineComponent: te, connectionLineContainerStyle: he, deleteKeyCode: oe = "Backspace", selectionKeyCode: de = "Shift", selectionOnDrag: le = !1, selectionMode: ye = Vc.Full, panActivationKeyCode: je = "Space", multiSelectionKeyCode: Ne = kp() ? "Meta" : "Control", zoomActivationKeyCode: we = kp() ? "Meta" : "Control", snapToGrid: Ee, snapGrid: _e, onlyRenderVisibleElements: Xe = !1, selectNodesOnDrag: St, nodesDraggable: ct, autoPanOnNodeFocus: cn, nodesConnectable: fr, nodesFocusable: Un, nodeOrigin: qn = H5, edgesFocusable: ze, edgesReconnectable: qr, elementsSelectable: ca = !0, defaultViewport: gi = bne, minZoom: ae = 0.5, maxZoom: pe = 2, translateExtent: Ce = Hc, preventScrolling: De = !0, nodeExtent: et, defaultMarkerColor: wn = "#b1b1b7", zoomOnScroll: Ar = !0, zoomOnPinch: fn = !0, panOnScroll: dr = !1, panOnScrollSpeed: _n = 0.5, panOnScrollMode: $t = Ba.Free, zoomOnDoubleClick: Rn = !0, panOnDrag: Gn = !0, onPaneClick: Af, onPaneMouseEnter: Rf, onPaneMouseMove: Gl, onPaneMouseLeave: fa, onPaneScroll: ng, onPaneContextMenu: Mf, paneClickDistance: Yl = 0, nodeClickDistance: Wl = 0, children: Xl, onReconnect: Of, onReconnectStart: rg, onReconnectEnd: Gr, onEdgeContextMenu: Qt, onEdgeDoubleClick: dn, onEdgeMouseEnter: yi, onEdgeMouseMove: Kl, onEdgeMouseLeave: og, reconnectRadius: ig = 10, onNodesChange: Nf, onEdgesChange: da, noDragClassName: Zl = "nodrag", noWheelClassName: vi = "nowheel", noPanClassName: ko = "nopan", fitView: bi, fitViewOptions: To, connectOnClick: Bt, attributionPosition: Df, proOptions: Pf, defaultEdgeOptions: Ao, elevateNodesOnSelect: xi, elevateEdgesOnSelect: ag, disableKeyboardA11y: Ql = !1, autoPanOnConnect: jf, autoPanOnNodeDrag: sg, autoPanSpeed: is, connectionRadius: as, isValidConnection: Rr, onError: Jl, style: If, id: Ro, nodeDragThreshold: eu, connectionDragThreshold: tu, viewport: lg, onViewportChange: zf, width: Mn, height: Lf, colorMode: ug = "light", debug: ss, onScroll: nu, ariaLabelConfig: ls, ...cg }, On) {
  const ha = Ro || "1", Ff = Sne(ug), ru = _.useCallback((Mo) => {
    Mo.currentTarget.scrollTo({ top: 0, left: 0, behavior: "instant" }), nu?.(Mo);
  }, [nu]);
  return x.jsx("div", { "data-testid": "rf__wrapper", ...cg, onScroll: ru, style: { ...If, ...Hre }, ref: On, className: Wt(["react-flow", o, Ff]), id: Ro, role: "application", children: x.jsxs(Bre, { nodes: e, edges: t, width: Mn, height: Lf, fitView: bi, fitViewOptions: To, minZoom: ae, maxZoom: pe, nodeOrigin: qn, nodeExtent: et, children: [x.jsx(Lre, { onInit: f, onNodeClick: u, onEdgeClick: c, onNodeMouseEnter: T, onNodeMouseMove: k, onNodeMouseLeave: A, onNodeContextMenu: M, onNodeDoubleClick: N, nodeTypes: a, edgeTypes: s, connectionLineType: Z, connectionLineStyle: L, connectionLineComponent: te, connectionLineContainerStyle: he, selectionKeyCode: de, selectionOnDrag: le, selectionMode: ye, deleteKeyCode: oe, multiSelectionKeyCode: Ne, panActivationKeyCode: je, zoomActivationKeyCode: we, onlyRenderVisibleElements: Xe, defaultViewport: gi, translateExtent: Ce, minZoom: ae, maxZoom: pe, preventScrolling: De, zoomOnScroll: Ar, zoomOnPinch: fn, zoomOnDoubleClick: Rn, panOnScroll: dr, panOnScrollSpeed: _n, panOnScrollMode: $t, panOnDrag: Gn, onPaneClick: Af, onPaneMouseEnter: Rf, onPaneMouseMove: Gl, onPaneMouseLeave: fa, onPaneScroll: ng, onPaneContextMenu: Mf, paneClickDistance: Yl, nodeClickDistance: Wl, onSelectionContextMenu: H, onSelectionStart: q, onSelectionEnd: G, onReconnect: Of, onReconnectStart: rg, onReconnectEnd: Gr, onEdgeContextMenu: Qt, onEdgeDoubleClick: dn, onEdgeMouseEnter: yi, onEdgeMouseMove: Kl, onEdgeMouseLeave: og, reconnectRadius: ig, defaultMarkerColor: wn, noDragClassName: Zl, noWheelClassName: vi, noPanClassName: ko, rfId: ha, disableKeyboardA11y: Ql, nodeExtent: et, viewport: lg, onViewportChange: zf }), x.jsx(_ne, { nodes: e, edges: t, defaultNodes: n, defaultEdges: r, onConnect: y, onConnectStart: w, onConnectEnd: v, onClickConnectStart: S, onClickConnectEnd: E, nodesDraggable: ct, autoPanOnNodeFocus: cn, nodesConnectable: fr, nodesFocusable: Un, edgesFocusable: ze, edgesReconnectable: qr, elementsSelectable: ca, elevateNodesOnSelect: xi, elevateEdgesOnSelect: ag, minZoom: ae, maxZoom: pe, nodeExtent: et, onNodesChange: Nf, onEdgesChange: da, snapToGrid: Ee, snapGrid: _e, connectionMode: Y, translateExtent: Ce, connectOnClick: Bt, defaultEdgeOptions: Ao, fitView: bi, fitViewOptions: To, onNodesDelete: R, onEdgesDelete: F, onDelete: U, onNodeDragStart: P, onNodeDrag: z, onNodeDragStop: B, onSelectionDrag: V, onSelectionDragStart: j, onSelectionDragStop: I, onMove: h, onMoveStart: p, onMoveEnd: g, noPanClassName: ko, nodeOrigin: qn, rfId: ha, autoPanOnConnect: jf, autoPanOnNodeDrag: sg, autoPanSpeed: is, onError: Jl, connectionRadius: as, isValidConnection: Rr, selectNodesOnDrag: St, nodeDragThreshold: eu, connectionDragThreshold: tu, onBeforeDelete: O, paneClickDistance: Yl, debug: ss, ariaLabelConfig: ls }), x.jsx(vne, { onSelectionChange: W }), Xl, x.jsx(hne, { proOptions: Pf, position: Df }), x.jsx(dne, { rfId: ha, disableKeyboardA11y: Ql })] }) });
}
var Ure = q5(Vre);
function qre({ dimensions: e, lineWidth: t, variant: n, className: r }) {
  return x.jsx("path", { strokeWidth: t, d: `M${e[0] / 2} 0 V${e[1]} M0 ${e[1] / 2} H${e[0]}`, className: Wt(["react-flow__background-pattern", n, r]) });
}
function Gre({ radius: e, className: t }) {
  return x.jsx("circle", { cx: e, cy: e, r: e, className: Wt(["react-flow__background-pattern", "dots", t]) });
}
var En;
(function(e) {
  e.Lines = "lines", e.Dots = "dots", e.Cross = "cross";
})(En || (En = {}));
const Yre = {
  [En.Dots]: 1,
  [En.Lines]: 1,
  [En.Cross]: 6
}, Wre = (e) => ({ transform: e.transform, patternId: `pattern-${e.rfId}` });
function m4({
  id: e,
  variant: t = En.Dots,
  // only used for dots and cross
  gap: n = 20,
  // only used for lines and cross
  size: r,
  lineWidth: o = 1,
  offset: a = 0,
  color: s,
  bgColor: u,
  style: c,
  className: f,
  patternClassName: h
}) {
  const p = _.useRef(null), { transform: g, patternId: y } = Je(Wre, At), w = r || Yre[t], v = t === En.Dots, S = t === En.Cross, E = Array.isArray(n) ? n : [n, n], T = [E[0] * g[2] || 1, E[1] * g[2] || 1], k = w * g[2], A = Array.isArray(a) ? a : [a, a], M = S ? [k, k] : T, N = [
    A[0] * g[2] || 1 + M[0] / 2,
    A[1] * g[2] || 1 + M[1] / 2
  ], P = `${y}${e || ""}`;
  return x.jsxs("svg", { className: Wt(["react-flow__background", f]), style: {
    ...c,
    ...Fm,
    "--xy-background-color-props": u,
    "--xy-background-pattern-color-props": s
  }, ref: p, "data-testid": "rf__background", children: [x.jsx("pattern", { id: P, x: g[0] % T[0], y: g[1] % T[1], width: T[0], height: T[1], patternUnits: "userSpaceOnUse", patternTransform: `translate(-${N[0]},-${N[1]})`, children: v ? x.jsx(Gre, { radius: k / 2, className: h }) : x.jsx(qre, { dimensions: M, lineWidth: o, variant: t, className: h }) }), x.jsx("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: `url(#${P})` })] });
}
m4.displayName = "Background";
const Xre = _.memo(m4);
function Kre() {
  return x.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", children: x.jsx("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" }) });
}
function Zre() {
  return x.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 5", children: x.jsx("path", { d: "M0 0h32v4.2H0z" }) });
}
function Qre() {
  return x.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 30", children: x.jsx("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" }) });
}
function Jre() {
  return x.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: x.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" }) });
}
function eoe() {
  return x.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: x.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z" }) });
}
function wh({ children: e, className: t, ...n }) {
  return x.jsx("button", { type: "button", className: Wt(["react-flow__controls-button", t]), ...n, children: e });
}
const toe = (e) => ({
  isInteractive: e.nodesDraggable || e.nodesConnectable || e.elementsSelectable,
  minZoomReached: e.transform[2] <= e.minZoom,
  maxZoomReached: e.transform[2] >= e.maxZoom,
  ariaLabelConfig: e.ariaLabelConfig
});
function g4({ style: e, showZoom: t = !0, showFitView: n = !0, showInteractive: r = !0, fitViewOptions: o, onZoomIn: a, onZoomOut: s, onFitView: u, onInteractiveChange: c, className: f, children: h, position: p = "bottom-left", orientation: g = "vertical", "aria-label": y }) {
  const w = kt(), { isInteractive: v, minZoomReached: S, maxZoomReached: E, ariaLabelConfig: T } = Je(toe, At), { zoomIn: k, zoomOut: A, fitView: M } = es(), N = () => {
    k(), a?.();
  }, P = () => {
    A(), s?.();
  }, z = () => {
    M(o), u?.();
  }, B = () => {
    w.setState({
      nodesDraggable: !v,
      nodesConnectable: !v,
      elementsSelectable: !v
    }), c?.(!v);
  }, R = g === "horizontal" ? "horizontal" : "vertical";
  return x.jsxs(Lm, { className: Wt(["react-flow__controls", R, f]), position: p, style: e, "data-testid": "rf__controls", "aria-label": y ?? T["controls.ariaLabel"], children: [t && x.jsxs(x.Fragment, { children: [x.jsx(wh, { onClick: N, className: "react-flow__controls-zoomin", title: T["controls.zoomIn.ariaLabel"], "aria-label": T["controls.zoomIn.ariaLabel"], disabled: E, children: x.jsx(Kre, {}) }), x.jsx(wh, { onClick: P, className: "react-flow__controls-zoomout", title: T["controls.zoomOut.ariaLabel"], "aria-label": T["controls.zoomOut.ariaLabel"], disabled: S, children: x.jsx(Zre, {}) })] }), n && x.jsx(wh, { className: "react-flow__controls-fitview", onClick: z, title: T["controls.fitView.ariaLabel"], "aria-label": T["controls.fitView.ariaLabel"], children: x.jsx(Qre, {}) }), r && x.jsx(wh, { className: "react-flow__controls-interactive", onClick: B, title: T["controls.interactive.ariaLabel"], "aria-label": T["controls.interactive.ariaLabel"], children: v ? x.jsx(eoe, {}) : x.jsx(Jre, {}) }), h] });
}
g4.displayName = "Controls";
_.memo(g4);
function noe({ id: e, x: t, y: n, width: r, height: o, style: a, color: s, strokeColor: u, strokeWidth: c, className: f, borderRadius: h, shapeRendering: p, selected: g, onClick: y }) {
  const { background: w, backgroundColor: v } = a || {}, S = s || w || v;
  return x.jsx("rect", { className: Wt(["react-flow__minimap-node", { selected: g }, f]), x: t, y: n, rx: h, ry: h, width: r, height: o, style: {
    fill: S,
    stroke: u,
    strokeWidth: c
  }, shapeRendering: p, onClick: y ? (E) => y(E, e) : void 0 });
}
const roe = _.memo(noe), ooe = (e) => e.nodes.map((t) => t.id), yv = (e) => e instanceof Function ? e : () => e;
function ioe({
  nodeStrokeColor: e,
  nodeColor: t,
  nodeClassName: n = "",
  nodeBorderRadius: r = 5,
  nodeStrokeWidth: o,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent: a = roe,
  onClick: s
}) {
  const u = Je(ooe, At), c = yv(t), f = yv(e), h = yv(n), p = typeof window > "u" || window.chrome ? "crispEdges" : "geometricPrecision";
  return x.jsx(x.Fragment, { children: u.map((g) => (
    /*
     * The split of responsibilities between MiniMapNodes and
     * NodeComponentWrapper may appear weird. However, its designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For more details, see a similar commit in `NodeRenderer/index.tsx`.
     */
    x.jsx(soe, { id: g, nodeColorFunc: c, nodeStrokeColorFunc: f, nodeClassNameFunc: h, nodeBorderRadius: r, nodeStrokeWidth: o, NodeComponent: a, onClick: s, shapeRendering: p }, g)
  )) });
}
function aoe({ id: e, nodeColorFunc: t, nodeStrokeColorFunc: n, nodeClassNameFunc: r, nodeBorderRadius: o, nodeStrokeWidth: a, shapeRendering: s, NodeComponent: u, onClick: c }) {
  const { node: f, x: h, y: p, width: g, height: y } = Je((w) => {
    const { internals: v } = w.nodeLookup.get(e), S = v.userNode, { x: E, y: T } = v.positionAbsolute, { width: k, height: A } = hi(S);
    return {
      node: S,
      x: E,
      y: T,
      width: k,
      height: A
    };
  }, At);
  return !f || f.hidden || !x5(f) ? null : x.jsx(u, { x: h, y: p, width: g, height: y, style: f.style, selected: !!f.selected, className: r(f), color: t(f), borderRadius: o, strokeColor: n(f), strokeWidth: a, shapeRendering: s, onClick: c, id: f.id });
}
const soe = _.memo(aoe);
var loe = _.memo(ioe);
const uoe = 200, coe = 150, foe = (e) => !e.hidden, doe = (e) => {
  const t = {
    x: -e.transform[0] / e.transform[2],
    y: -e.transform[1] / e.transform[2],
    width: e.width / e.transform[2],
    height: e.height / e.transform[2]
  };
  return {
    viewBB: t,
    boundingRect: e.nodeLookup.size > 0 ? b5(vf(e.nodeLookup, { filter: foe }), t) : t,
    rfId: e.rfId,
    panZoom: e.panZoom,
    translateExtent: e.translateExtent,
    flowWidth: e.width,
    flowHeight: e.height,
    ariaLabelConfig: e.ariaLabelConfig
  };
}, hoe = "react-flow__minimap-desc";
function y4({
  style: e,
  className: t,
  nodeStrokeColor: n,
  nodeColor: r,
  nodeClassName: o = "",
  nodeBorderRadius: a = 5,
  nodeStrokeWidth: s,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent: u,
  bgColor: c,
  maskColor: f,
  maskStrokeColor: h,
  maskStrokeWidth: p,
  position: g = "bottom-right",
  onClick: y,
  onNodeClick: w,
  pannable: v = !1,
  zoomable: S = !1,
  ariaLabel: E,
  inversePan: T,
  zoomStep: k = 10,
  offsetScale: A = 5
}) {
  const M = kt(), N = _.useRef(null), { boundingRect: P, viewBB: z, rfId: B, panZoom: R, translateExtent: F, flowWidth: U, flowHeight: W, ariaLabelConfig: j } = Je(doe, At), V = e?.width ?? uoe, I = e?.height ?? coe, H = P.width / V, q = P.height / I, G = Math.max(H, q), O = G * V, Y = G * I, Z = A * G, L = P.x - (O - P.width) / 2 - Z, te = P.y - (Y - P.height) / 2 - Z, he = O + Z * 2, oe = Y + Z * 2, de = `${hoe}-${B}`, le = _.useRef(0), ye = _.useRef();
  le.current = G, _.useEffect(() => {
    if (N.current && R)
      return ye.current = Fte({
        domNode: N.current,
        panZoom: R,
        getTransform: () => M.getState().transform,
        getViewScale: () => le.current
      }), () => {
        ye.current?.destroy();
      };
  }, [R]), _.useEffect(() => {
    ye.current?.update({
      translateExtent: F,
      width: U,
      height: W,
      inversePan: T,
      pannable: v,
      zoomStep: k,
      zoomable: S
    });
  }, [v, S, T, k, F, U, W]);
  const je = y ? (Ee) => {
    const [_e, Xe] = ye.current?.pointer(Ee) || [0, 0];
    y(Ee, { x: _e, y: Xe });
  } : void 0, Ne = w ? _.useCallback((Ee, _e) => {
    const Xe = M.getState().nodeLookup.get(_e).internals.userNode;
    w(Ee, Xe);
  }, []) : void 0, we = E ?? j["minimap.ariaLabel"];
  return x.jsx(Lm, { position: g, style: {
    ...e,
    "--xy-minimap-background-color-props": typeof c == "string" ? c : void 0,
    "--xy-minimap-mask-background-color-props": typeof f == "string" ? f : void 0,
    "--xy-minimap-mask-stroke-color-props": typeof h == "string" ? h : void 0,
    "--xy-minimap-mask-stroke-width-props": typeof p == "number" ? p * G : void 0,
    "--xy-minimap-node-background-color-props": typeof r == "string" ? r : void 0,
    "--xy-minimap-node-stroke-color-props": typeof n == "string" ? n : void 0,
    "--xy-minimap-node-stroke-width-props": typeof s == "number" ? s : void 0
  }, className: Wt(["react-flow__minimap", t]), "data-testid": "rf__minimap", children: x.jsxs("svg", { width: V, height: I, viewBox: `${L} ${te} ${he} ${oe}`, className: "react-flow__minimap-svg", role: "img", "aria-labelledby": de, ref: N, onClick: je, children: [we && x.jsx("title", { id: de, children: we }), x.jsx(loe, { onClick: Ne, nodeColor: r, nodeStrokeColor: n, nodeBorderRadius: a, nodeClassName: o, nodeStrokeWidth: s, nodeComponent: u }), x.jsx("path", { className: "react-flow__minimap-mask", d: `M${L - Z},${te - Z}h${he + Z * 2}v${oe + Z * 2}h${-he - Z * 2}z
        M${z.x},${z.y}h${z.width}v${z.height}h${-z.width}z`, fillRule: "evenodd", pointerEvents: "none" })] }) });
}
y4.displayName = "MiniMap";
const poe = _.memo(y4), moe = (e) => (t) => e ? `${Math.max(1 / t.transform[2], 1)}` : void 0, goe = {
  [Rl.Line]: "right",
  [Rl.Handle]: "bottom-right"
};
function yoe({ nodeId: e, position: t, variant: n = Rl.Handle, className: r, style: o = void 0, children: a, color: s, minWidth: u = 10, minHeight: c = 10, maxWidth: f = Number.MAX_VALUE, maxHeight: h = Number.MAX_VALUE, keepAspectRatio: p = !1, resizeDirection: g, autoScale: y = !0, shouldResize: w, onResizeStart: v, onResize: S, onResizeEnd: E }) {
  const T = X5(), k = typeof e == "string" ? e : T, A = kt(), M = _.useRef(null), N = n === Rl.Handle, P = Je(_.useCallback(moe(N && y), [N, y]), At), z = _.useRef(null), B = t ?? goe[n];
  _.useEffect(() => {
    if (!(!M.current || !k))
      return z.current || (z.current = tne({
        domNode: M.current,
        nodeId: k,
        getStoreItems: () => {
          const { nodeLookup: F, transform: U, snapGrid: W, snapToGrid: j, nodeOrigin: V, domNode: I } = A.getState();
          return {
            nodeLookup: F,
            transform: U,
            snapGrid: W,
            snapToGrid: j,
            nodeOrigin: V,
            paneDomNode: I
          };
        },
        onChange: (F, U) => {
          const { triggerNodeChanges: W, nodeLookup: j, parentLookup: V, nodeOrigin: I } = A.getState(), H = [], q = { x: F.x, y: F.y }, G = j.get(k);
          if (G && G.expandParent && G.parentId) {
            const O = G.origin ?? I, Y = F.width ?? G.measured.width ?? 0, Z = F.height ?? G.measured.height ?? 0, L = {
              id: G.id,
              parentId: G.parentId,
              rect: {
                width: Y,
                height: Z,
                ...w5({
                  x: F.x ?? G.position.x,
                  y: F.y ?? G.position.y
                }, { width: Y, height: Z }, G.parentId, j, O)
              }
            }, te = Dx([L], j, V, I);
            H.push(...te), q.x = F.x ? Math.max(O[0] * Y, F.x) : void 0, q.y = F.y ? Math.max(O[1] * Z, F.y) : void 0;
          }
          if (q.x !== void 0 && q.y !== void 0) {
            const O = {
              id: k,
              type: "position",
              position: { ...q }
            };
            H.push(O);
          }
          if (F.width !== void 0 && F.height !== void 0) {
            const Y = {
              id: k,
              type: "dimensions",
              resizing: !0,
              setAttributes: g ? g === "horizontal" ? "width" : "height" : !0,
              dimensions: {
                width: F.width,
                height: F.height
              }
            };
            H.push(Y);
          }
          for (const O of U) {
            const Y = {
              ...O,
              type: "position"
            };
            H.push(Y);
          }
          W(H);
        },
        onEnd: ({ width: F, height: U }) => {
          const W = {
            id: k,
            type: "dimensions",
            resizing: !1,
            dimensions: {
              width: F,
              height: U
            }
          };
          A.getState().triggerNodeChanges([W]);
        }
      })), z.current.update({
        controlPosition: B,
        boundaries: {
          minWidth: u,
          minHeight: c,
          maxWidth: f,
          maxHeight: h
        },
        keepAspectRatio: p,
        resizeDirection: g,
        onResizeStart: v,
        onResize: S,
        onResizeEnd: E,
        shouldResize: w
      }), () => {
        z.current?.destroy();
      };
  }, [
    B,
    u,
    c,
    f,
    h,
    p,
    v,
    S,
    E,
    w
  ]);
  const R = B.split("-");
  return x.jsx("div", { className: Wt(["react-flow__resize-control", "nodrag", ...R, n, r]), ref: M, style: {
    ...o,
    scale: P,
    ...s && { [N ? "backgroundColor" : "borderColor"]: s }
  }, children: a });
}
_.memo(yoe);
function voe(e, t) {
  if (Object.is(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  if (e instanceof Map && t instanceof Map) {
    if (e.size !== t.size) return !1;
    for (const [r, o] of e)
      if (!Object.is(o, t.get(r)))
        return !1;
    return !0;
  }
  if (e instanceof Set && t instanceof Set) {
    if (e.size !== t.size) return !1;
    for (const r of e)
      if (!t.has(r))
        return !1;
    return !0;
  }
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
    return !1;
  for (const r of n)
    if (!Object.prototype.hasOwnProperty.call(t, r) || !Object.is(e[r], t[r]))
      return !1;
  return !0;
}
const { useRef: boe } = nn;
function Ix(e) {
  const t = boe();
  return (n) => {
    const r = e(n);
    return voe(t.current, r) ? t.current : t.current = r;
  };
}
const xoe = () => {
  const { group: e } = Tn();
  return async (t, n) => {
    if (e)
      return await e.group_nodes(t, n);
  };
}, woe = () => {
  const { group: e } = Tn();
  return async (t) => {
    if (e)
      for (const n of t)
        await e.remove_group(n);
  };
}, _oe = ({ data: e }) => {
  const t = e?.group?.id || e?.id, n = woe(), r = _.useCallback(
    (o) => {
      o.stopPropagation(), t && n([t]);
    },
    [t, n]
  );
  return /* @__PURE__ */ x.jsxs("div", { className: "fn-group", children: [
    /* @__PURE__ */ x.jsx(
      "button",
      {
        className: "fn-group-remove",
        title: "Remove group",
        onClick: r,
        children: /* @__PURE__ */ x.jsx(hm, {})
      }
    ),
    "Group"
  ] });
}, zx = _.memo(
  ({ value: e }) => {
    const t = e?.toString() ?? "", n = Math.round(3 * t.length / 4);
    return /* @__PURE__ */ x.jsx("div", { children: /* @__PURE__ */ x.jsxs("pre", { children: [
      "Bytes(",
      n,
      ")"
    ] }) });
  }
), v4 = _.memo(
  ({ value: e }) => typeof e != "string" ? /* @__PURE__ */ x.jsx("div", { children: "Invalid SVG" }) : /* @__PURE__ */ x.jsx(FW, { value: e })
), b4 = ({
  value: e,
  preValue: t,
  onLoaded: n
}) => {
  const [r, o] = _.useState(
    t?.toString() || e?.toString()
  );
  return _.useEffect(() => {
    if (e === t || e == null) return;
    const s = new Image(), u = e.toString();
    return s.onload = () => {
      n?.(), o(u);
    }, s.src = u, () => {
      s.onload = null;
    };
  }, [e, t, n]), r === void 0 ? /* @__PURE__ */ x.jsx(x.Fragment, {}) : typeof r != "string" ? (console.error("ImageRenderer: value is not a string", r), /* @__PURE__ */ x.jsx(x.Fragment, {})) : r.startsWith("data:") || r.startsWith("blob:") ? /* @__PURE__ */ x.jsx($W, { src: r }) : /* @__PURE__ */ x.jsx(LW, { value: r, format: "jpeg" });
}, Soe = _.memo(
  ({ value: e }) => {
    let t = "";
    try {
      t = JSON.stringify(e);
    } catch {
    }
    return /* @__PURE__ */ x.jsx("div", { children: /* @__PURE__ */ x.jsx("pre", { children: t }) });
  }
), $m = ({
  value: e
}) => /* @__PURE__ */ x.jsx(_W, { data: e }), x4 = _.memo(
  ({ value: e }) => {
    if (typeof e != "object" || e == null)
      return /* @__PURE__ */ x.jsx("div", { children: "Invalid Table" });
    if (!("columns" in e && "index" in e && "data" in e))
      return /* @__PURE__ */ x.jsx("div", { children: "Invalid Table" });
    if (!Array.isArray(e.columns) || !Array.isArray(e.index) || !Array.isArray(e.data) || !e.data.every((n) => Array.isArray(n)))
      return /* @__PURE__ */ x.jsx("div", { children: "Invalid Table" });
    const t = {
      columns: e.columns || [],
      index: e.index || [],
      data: e.data || []
    };
    return /* @__PURE__ */ x.jsx(jM, { tabledata: t });
  }
), Ap = (e) => /* @__PURE__ */ x.jsx(Soe, { ...e }), Rp = $m, Lx = {
  string: Ap,
  str: Ap,
  table: x4,
  image: b4,
  svg: v4,
  dict: $m,
  bytes: zx
}, Eoe = () => {
  const e = Rt(), { full: t, preview: n } = e.valuestore(), r = JSON.stringify(t?.value || n?.value) || "";
  return `Bytes(${Math.round(3 * r.length / 4)})`;
}, Coe = {
  bytes: Eoe
}, Bm = (e) => ({ value: t, preValue: n, onLoaded: r }) => /* @__PURE__ */ x.jsx(e, { value: t, preValue: n, onLoaded: r }), zn = (e, t = void 0, n = {}) => ({}) => {
  const r = Rt(), { full: o, preview: a } = r.valuestore(), u = (o === void 0 ? a : o)?.value || t;
  return /* @__PURE__ */ x.jsx(e, { value: u, ...n });
}, w4 = (e) => ({}) => /* @__PURE__ */ x.jsx(e, {}), _4 = (e, t = void 0) => ({}) => {
  const n = Rt(), { full: r, preview: o } = n.valuestore(), s = (r === void 0 ? o : r)?.value || t;
  return /* @__PURE__ */ x.jsx(e, { value: s });
}, koe = {
  ...Object.fromEntries(
    Object.entries(Lx).map(([e, t]) => [
      e,
      t ? Bm(t) : void 0
    ])
  )
}, tR = Bm($m), S4 = {
  ...Object.fromEntries(
    Object.entries(Lx).map(([e, t]) => [
      e,
      t ? zn(t) : void 0
    ])
  ),
  string: zn(Ap),
  str: zn(Ap),
  table: zn(x4, void 0, {
    pageSize: 10
  }),
  image: zn(b4),
  svg: zn(v4, ""),
  dict: zn($m, "{}"),
  bytes: zn(zx, "")
}, Toe = {
  ...Object.fromEntries(
    Object.entries(S4).map(([e, t]) => [
      e,
      t ? w4(t) : void 0
    ])
  )
}, Aoe = () => {
  const e = Rt(), { preview: t, full: n } = e.valuestore();
  let r = (JSON.stringify(n || t) || "").replace(/\\n/g, `
`);
  return r.length > 63 && (r = r.slice(0, 60) + "..."), /* @__PURE__ */ x.jsx("div", { children: r });
}, Roe = {}, Moe = ({ inputconverter: e }) => {
  const t = Rt(), { preview: n } = t.valuestore(), r = t.use(), o = n?.value === void 0, a = _.useRef(null), s = Hl(r);
  _.useEffect(() => {
    a.current && (a.current.indeterminate = o);
  }, [a, o]);
  const u = _.useCallback(
    (c) => {
      let f = c.target.checked;
      try {
        f = e[0](c.target.checked);
      } catch {
      }
      s(f);
    },
    [s, e]
  );
  return /* @__PURE__ */ x.jsx(
    "input",
    {
      ref: a,
      type: "checkbox",
      className: "styledcheckbox booleaninput",
      checked: !!e[1](n?.value),
      onChange: u,
      disabled: r.connected
    }
  );
}, Ooe = ({}) => {
  const e = Rt(), t = nt(), n = e.use(), { preview: r, full: o } = e.valuestore(), a = o === void 0 ? r?.value : o.value, s = Hl(n), u = typeof a == "string" || Array.isArray(a) && a.every((g) => typeof g == "number") ? a : void 0, c = n.value_options?.colorspace || "hex", f = _.useCallback(
    (g) => {
      let y = "<NoValue>";
      g && (g[c] ? y = g[c]() : y = g.hex()), g === null && (y = null);
      try {
        y = y;
      } catch {
      }
      s(y);
    },
    [s, c]
  );
  let h = !1;
  typeof n.type != "string" && "anyOf" in n.type && n.type.anyOf !== void 0 && (h = n.type.anyOf.some((g) => g === "None"));
  const p = t.local_state(() => t.reactflowRef);
  return /* @__PURE__ */ x.jsx(
    Cq,
    {
      onChange: f,
      inicolordata: u,
      allow_null: h,
      inicolorspace: c,
      portalContainer: p
    }
  );
};
function E4(e, [t, n]) {
  return Math.min(n, Math.max(t, e));
}
var Noe = _.createContext(void 0);
function Hm(e) {
  const t = _.useContext(Noe);
  return e || t || "ltr";
}
function Doe(e) {
  const t = _.useRef({ value: e, previous: e });
  return _.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]);
}
var C4 = ["PageUp", "PageDown"], k4 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], T4 = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
}, Bl = "Slider", [Hb, Poe, joe] = xm(Bl), [A4, dme] = _o(Bl, [
  joe
]), [Ioe, Vm] = A4(Bl), R4 = _.forwardRef(
  (e, t) => {
    const {
      name: n,
      min: r = 0,
      max: o = 100,
      step: a = 1,
      orientation: s = "horizontal",
      disabled: u = !1,
      minStepsBetweenThumbs: c = 0,
      defaultValue: f = [r],
      value: h,
      onValueChange: p = () => {
      },
      onValueCommit: g = () => {
      },
      inverted: y = !1,
      form: w,
      ...v
    } = e, S = _.useRef(/* @__PURE__ */ new Set()), E = _.useRef(0), k = s === "horizontal" ? zoe : Loe, [A = [], M] = sa({
      prop: h,
      defaultProp: f,
      onChange: (F) => {
        [...S.current][E.current]?.focus(), p(F);
      }
    }), N = _.useRef(A);
    function P(F) {
      const U = Voe(A, F);
      R(F, U);
    }
    function z(F) {
      R(F, E.current);
    }
    function B() {
      const F = N.current[E.current];
      A[E.current] !== F && g(A);
    }
    function R(F, U, { commit: W } = { commit: !1 }) {
      const j = Yoe(a), V = Woe(Math.round((F - r) / a) * a + r, j), I = E4(V, [r, o]);
      M((H = []) => {
        const q = Boe(H, I, U);
        if (Goe(q, c * a)) {
          E.current = q.indexOf(I);
          const G = String(q) !== String(H);
          return G && W && g(q), G ? q : H;
        } else
          return H;
      });
    }
    return /* @__PURE__ */ x.jsx(
      Ioe,
      {
        scope: e.__scopeSlider,
        name: n,
        disabled: u,
        min: r,
        max: o,
        valueIndexToChangeRef: E,
        thumbs: S.current,
        values: A,
        orientation: s,
        form: w,
        children: /* @__PURE__ */ x.jsx(Hb.Provider, { scope: e.__scopeSlider, children: /* @__PURE__ */ x.jsx(Hb.Slot, { scope: e.__scopeSlider, children: /* @__PURE__ */ x.jsx(
          k,
          {
            "aria-disabled": u,
            "data-disabled": u ? "" : void 0,
            ...v,
            ref: t,
            onPointerDown: xe(v.onPointerDown, () => {
              u || (N.current = A);
            }),
            min: r,
            max: o,
            inverted: y,
            onSlideStart: u ? void 0 : P,
            onSlideMove: u ? void 0 : z,
            onSlideEnd: u ? void 0 : B,
            onHomeKeyDown: () => !u && R(r, 0, { commit: !0 }),
            onEndKeyDown: () => !u && R(o, A.length - 1, { commit: !0 }),
            onStepKeyDown: ({ event: F, direction: U }) => {
              if (!u) {
                const V = C4.includes(F.key) || F.shiftKey && k4.includes(F.key) ? 10 : 1, I = E.current, H = A[I], q = a * V * U;
                R(H + q, I, { commit: !0 });
              }
            }
          }
        ) }) })
      }
    );
  }
);
R4.displayName = Bl;
var [M4, O4] = A4(Bl, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
}), zoe = _.forwardRef(
  (e, t) => {
    const {
      min: n,
      max: r,
      dir: o,
      inverted: a,
      onSlideStart: s,
      onSlideMove: u,
      onSlideEnd: c,
      onStepKeyDown: f,
      ...h
    } = e, [p, g] = _.useState(null), y = bt(t, (k) => g(k)), w = _.useRef(void 0), v = Hm(o), S = v === "ltr", E = S && !a || !S && a;
    function T(k) {
      const A = w.current || p.getBoundingClientRect(), M = [0, A.width], P = Fx(M, E ? [n, r] : [r, n]);
      return w.current = A, P(k - A.left);
    }
    return /* @__PURE__ */ x.jsx(
      M4,
      {
        scope: e.__scopeSlider,
        startEdge: E ? "left" : "right",
        endEdge: E ? "right" : "left",
        direction: E ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ x.jsx(
          N4,
          {
            dir: v,
            "data-orientation": "horizontal",
            ...h,
            ref: y,
            style: {
              ...h.style,
              "--radix-slider-thumb-transform": "translateX(-50%)"
            },
            onSlideStart: (k) => {
              const A = T(k.clientX);
              s?.(A);
            },
            onSlideMove: (k) => {
              const A = T(k.clientX);
              u?.(A);
            },
            onSlideEnd: () => {
              w.current = void 0, c?.();
            },
            onStepKeyDown: (k) => {
              const M = T4[E ? "from-left" : "from-right"].includes(k.key);
              f?.({ event: k, direction: M ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), Loe = _.forwardRef(
  (e, t) => {
    const {
      min: n,
      max: r,
      inverted: o,
      onSlideStart: a,
      onSlideMove: s,
      onSlideEnd: u,
      onStepKeyDown: c,
      ...f
    } = e, h = _.useRef(null), p = bt(t, h), g = _.useRef(void 0), y = !o;
    function w(v) {
      const S = g.current || h.current.getBoundingClientRect(), E = [0, S.height], k = Fx(E, y ? [r, n] : [n, r]);
      return g.current = S, k(v - S.top);
    }
    return /* @__PURE__ */ x.jsx(
      M4,
      {
        scope: e.__scopeSlider,
        startEdge: y ? "bottom" : "top",
        endEdge: y ? "top" : "bottom",
        size: "height",
        direction: y ? 1 : -1,
        children: /* @__PURE__ */ x.jsx(
          N4,
          {
            "data-orientation": "vertical",
            ...f,
            ref: p,
            style: {
              ...f.style,
              "--radix-slider-thumb-transform": "translateY(50%)"
            },
            onSlideStart: (v) => {
              const S = w(v.clientY);
              a?.(S);
            },
            onSlideMove: (v) => {
              const S = w(v.clientY);
              s?.(S);
            },
            onSlideEnd: () => {
              g.current = void 0, u?.();
            },
            onStepKeyDown: (v) => {
              const E = T4[y ? "from-bottom" : "from-top"].includes(v.key);
              c?.({ event: v, direction: E ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), N4 = _.forwardRef(
  (e, t) => {
    const {
      __scopeSlider: n,
      onSlideStart: r,
      onSlideMove: o,
      onSlideEnd: a,
      onHomeKeyDown: s,
      onEndKeyDown: u,
      onStepKeyDown: c,
      ...f
    } = e, h = Vm(Bl, n);
    return /* @__PURE__ */ x.jsx(
      qe.span,
      {
        ...f,
        ref: t,
        onKeyDown: xe(e.onKeyDown, (p) => {
          p.key === "Home" ? (s(p), p.preventDefault()) : p.key === "End" ? (u(p), p.preventDefault()) : C4.concat(k4).includes(p.key) && (c(p), p.preventDefault());
        }),
        onPointerDown: xe(e.onPointerDown, (p) => {
          const g = p.target;
          g.setPointerCapture(p.pointerId), p.preventDefault(), h.thumbs.has(g) ? g.focus() : r(p);
        }),
        onPointerMove: xe(e.onPointerMove, (p) => {
          p.target.hasPointerCapture(p.pointerId) && o(p);
        }),
        onPointerUp: xe(e.onPointerUp, (p) => {
          const g = p.target;
          g.hasPointerCapture(p.pointerId) && (g.releasePointerCapture(p.pointerId), a(p));
        })
      }
    );
  }
), D4 = "SliderTrack", P4 = _.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, ...r } = e, o = Vm(D4, n);
    return /* @__PURE__ */ x.jsx(
      qe.span,
      {
        "data-disabled": o.disabled ? "" : void 0,
        "data-orientation": o.orientation,
        ...r,
        ref: t
      }
    );
  }
);
P4.displayName = D4;
var Vb = "SliderRange", j4 = _.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, ...r } = e, o = Vm(Vb, n), a = O4(Vb, n), s = _.useRef(null), u = bt(t, s), c = o.values.length, f = o.values.map(
      (g) => L4(g, o.min, o.max)
    ), h = c > 1 ? Math.min(...f) : 0, p = 100 - Math.max(...f);
    return /* @__PURE__ */ x.jsx(
      qe.span,
      {
        "data-orientation": o.orientation,
        "data-disabled": o.disabled ? "" : void 0,
        ...r,
        ref: u,
        style: {
          ...e.style,
          [a.startEdge]: h + "%",
          [a.endEdge]: p + "%"
        }
      }
    );
  }
);
j4.displayName = Vb;
var Ub = "SliderThumb", I4 = _.forwardRef(
  (e, t) => {
    const n = Poe(e.__scopeSlider), [r, o] = _.useState(null), a = bt(t, (u) => o(u)), s = _.useMemo(
      () => r ? n().findIndex((u) => u.ref.current === r) : -1,
      [n, r]
    );
    return /* @__PURE__ */ x.jsx(Foe, { ...e, ref: a, index: s });
  }
), Foe = _.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, index: r, name: o, ...a } = e, s = Vm(Ub, n), u = O4(Ub, n), [c, f] = _.useState(null), h = bt(t, (T) => f(T)), p = c ? s.form || !!c.closest("form") : !0, g = PN(c), y = s.values[r], w = y === void 0 ? 0 : L4(y, s.min, s.max), v = Hoe(r, s.values.length), S = g?.[u.size], E = S ? Uoe(S, w, u.direction) : 0;
    return _.useEffect(() => {
      if (c)
        return s.thumbs.add(c), () => {
          s.thumbs.delete(c);
        };
    }, [c, s.thumbs]), /* @__PURE__ */ x.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [u.startEdge]: `calc(${w}% + ${E}px)`
        },
        children: [
          /* @__PURE__ */ x.jsx(Hb.ItemSlot, { scope: e.__scopeSlider, children: /* @__PURE__ */ x.jsx(
            qe.span,
            {
              role: "slider",
              "aria-label": e["aria-label"] || v,
              "aria-valuemin": s.min,
              "aria-valuenow": y,
              "aria-valuemax": s.max,
              "aria-orientation": s.orientation,
              "data-orientation": s.orientation,
              "data-disabled": s.disabled ? "" : void 0,
              tabIndex: s.disabled ? void 0 : 0,
              ...a,
              ref: h,
              style: y === void 0 ? { display: "none" } : e.style,
              onFocus: xe(e.onFocus, () => {
                s.valueIndexToChangeRef.current = r;
              })
            }
          ) }),
          p && /* @__PURE__ */ x.jsx(
            z4,
            {
              name: o ?? (s.name ? s.name + (s.values.length > 1 ? "[]" : "") : void 0),
              form: s.form,
              value: y
            },
            r
          )
        ]
      }
    );
  }
);
I4.displayName = Ub;
var $oe = "RadioBubbleInput", z4 = _.forwardRef(
  ({ __scopeSlider: e, value: t, ...n }, r) => {
    const o = _.useRef(null), a = bt(o, r), s = Doe(t);
    return _.useEffect(() => {
      const u = o.current;
      if (!u) return;
      const c = window.HTMLInputElement.prototype, h = Object.getOwnPropertyDescriptor(c, "value").set;
      if (s !== t && h) {
        const p = new Event("input", { bubbles: !0 });
        h.call(u, t), u.dispatchEvent(p);
      }
    }, [s, t]), /* @__PURE__ */ x.jsx(
      qe.input,
      {
        style: { display: "none" },
        ...n,
        ref: a,
        defaultValue: t
      }
    );
  }
);
z4.displayName = $oe;
function Boe(e = [], t, n) {
  const r = [...e];
  return r[n] = t, r.sort((o, a) => o - a);
}
function L4(e, t, n) {
  const a = 100 / (n - t) * (e - t);
  return E4(a, [0, 100]);
}
function Hoe(e, t) {
  return t > 2 ? `Value ${e + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][e] : void 0;
}
function Voe(e, t) {
  if (e.length === 1) return 0;
  const n = e.map((o) => Math.abs(o - t)), r = Math.min(...n);
  return n.indexOf(r);
}
function Uoe(e, t, n) {
  const r = e / 2, a = Fx([0, 50], [0, r]);
  return (r - a(t) * n) * n;
}
function qoe(e) {
  return e.slice(0, -1).map((t, n) => e[n + 1] - t);
}
function Goe(e, t) {
  if (t > 0) {
    const n = qoe(e);
    return Math.min(...n) >= t;
  }
  return !0;
}
function Fx(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const r = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + r * (n - e[0]);
  };
}
function Yoe(e) {
  return (String(e).split(".")[1] || "").length;
}
function Woe(e, t) {
  const n = Math.pow(10, t);
  return Math.round(e * n) / n;
}
var Xoe = R4, Koe = P4, Zoe = j4, Qoe = I4;
function Joe(e) {
  return e === 0 ? 0 : Math.abs(e) < 1e-12 ? e : Number(e.toPrecision(12));
}
const F4 = ({
  inputconverter: e,
  parser: t = (n) => parseFloat(n)
}) => {
  const n = Rt(), { preview: r } = n.valuestore(), o = n.use(), a = Hl(o), [s, u] = _.useState(
    e[1](r?.value)
  );
  _.useEffect(() => {
    u(e[1](r?.value));
  }, [r]);
  const c = _.useCallback(
    (y) => {
      y = t(
        parseFloat(y.toString()).toString()
        // parse float first for e notation
      ), isNaN(y) ? (y = "<NoValue>", u("")) : (o.value_options?.min !== void 0 && y < o.value_options.min && (y = o.value_options.min), o.value_options?.max !== void 0 && y > o.value_options.max && (y = o.value_options.max), y = Joe(y), u(y.toString()));
      try {
        y = e[0](y);
      } catch {
      }
      y !== r?.value && a(y);
    },
    [o, e, a]
  ), f = _.useCallback(
    (y) => {
      c(y.target.value);
    },
    [c]
  );
  let h = o.connected ? e[1](r?.value) : s;
  h === void 0 && (h = o.value_options?.min), h === void 0 && (h = o.value_options?.max), h === void 0 && (h = ""), h === null && (h = "");
  let p = null, g = 1;
  return o.value_options?.step !== void 0 ? g = o.value_options.step : o.value_options?.max !== void 0 && o.value_options?.min !== void 0 && (g = (o.value_options?.max - o.value_options?.min) / 1e3), o.value_options?.max !== void 0 && o.value_options?.min !== void 0 && !o.connected && (p = /* @__PURE__ */ x.jsx("div", { style: { minWidth: "6.25rem" }, className: "SliderContainer", children: /* @__PURE__ */ x.jsxs(
    Xoe,
    {
      className: "SliderRoot",
      value: [h === void 0 ? o.value_options?.min : h],
      min: o.value_options?.min,
      max: o.value_options?.max,
      step: g,
      disabled: o.connected,
      onValueCommit: (y) => {
        isNaN(y[0]) || c(y[0]);
      },
      onValueChange: (y) => {
        isNaN(y[0]) || u(y[0].toString());
      },
      onKeyDown: (y) => {
        ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(
          y.key
        ) && y.stopPropagation();
      },
      children: [
        /* @__PURE__ */ x.jsx(Koe, { className: "SliderTrack", children: /* @__PURE__ */ x.jsx(Zoe, { className: "SliderRange" }) }),
        /* @__PURE__ */ x.jsx(Qoe, { className: "SliderThumb" })
      ]
    }
  ) })), /* @__PURE__ */ x.jsxs(x.Fragment, { children: [
    p,
    /* @__PURE__ */ x.jsx(
      "input",
      {
        type: "text",
        className: "nodedatainput styledinput numberinput",
        value: h,
        onChange: (y) => u(y.target.value),
        onBlur: f,
        step: g,
        onKeyDown: (y) => {
          if (!(y.ctrlKey || y.metaKey)) {
            if (y.key === "ArrowUp") {
              y.shiftKey && (g *= 10);
              let w = (parseFloat(h) || 0) + g;
              c(w);
              return;
            }
            if (y.key === "ArrowDown") {
              y.shiftKey && (g *= 10);
              let w = (parseFloat(h) || 0) - g;
              c(w);
              return;
            }
            !/^[0-9.eE+-]$/.test(y.key) && !["Backspace", "ArrowLeft", "ArrowRight", "Delete", "Tab"].includes(
              y.key
            ) && y.preventDefault();
          }
        },
        disabled: o.connected,
        min: o.value_options?.min,
        max: o.value_options?.max
      }
    )
  ] });
}, eie = ({ inputconverter: e }) => F4({ inputconverter: e, parser: parseFloat }), tie = ({ inputconverter: e }) => F4({ inputconverter: e, parser: parseInt }), nie = (e) => e, rie = (e) => parseFloat(e), oie = (e) => !!e, iie = (e) => e === "null" ? null : e, aie = (e) => e === "nuinputconvertermber" ? rie : e === "boolean" ? oie : e === "undefined" ? iie : nie, Yc = ({
  inputconverter: e,
  parser: t
}) => {
  const n = Rt(), r = n.use(), { preview: o, full: a } = n.valuestore(), s = a === void 0 ? o?.value : a.value, u = Hl(r);
  let c = r.value_options?.options || [];
  Array.isArray(c) && (c = {
    type: "enum",
    values: c,
    keys: c.map((v) => v === null ? "None" : v.toString()),
    nullable: !1
  }), c.type !== "enum" && (c = {
    type: "enum",
    values: Object.values(c),
    keys: Object.keys(c),
    nullable: !1
  }), c = c, c.nullable && !c.values.includes(null) && !c.keys.includes("None") && (c.values.unshift(null), c.keys.unshift("None"));
  const f = [];
  for (let v = 0; v < c.values.length; v++) {
    const S = c.values[v] === null || c.values[v] === void 0 ? "undefined" : typeof c.values[v];
    let E = c.values[v];
    E === null && (E = "null"), E === void 0 && (E = "undefined"), f.push([c.keys[v], E.toString(), S]);
  }
  const h = _.useCallback(
    ({
      value: v,
      // label
      datatype: S
    }) => {
      let T = (t || aie(S))(v);
      try {
        T = e[0](v);
      } catch {
      }
      u(T);
    },
    [r, e, u]
  );
  let p = s;
  p === null && (p = "null"), p === void 0 && (p = "undefined");
  const g = f.find((v) => v[1] === p.toString());
  let y;
  g !== void 0 && (y = {
    value: g[1],
    label: g[0],
    datatype: g[2]
  });
  const w = f.map(
    (v) => ({
      value: v[1],
      label: v[0],
      datatype: v[2]
    })
  );
  return (
    // <Suspense fallback={<select disabled={true}></select>}>
    /* @__PURE__ */ x.jsx(
      oW,
      {
        className: "nodedatainput styleddropdown",
        options: w,
        defaultValue: y,
        onChange: (v) => {
          if (v === null) {
            h({
              value: "<NoValue>",
              datatype: "string"
            });
            return;
          }
          h(v);
        }
      }
    )
  );
}, nR = ({ inputconverter: e }) => {
  const t = Rt(), { preview: n, full: r } = t.valuestore(), o = t.use(), a = r === void 0 ? n?.value : r?.value, s = Hl(o), [u, c] = _.useState(e[1](a));
  _.useEffect(() => {
    c(e[1](a));
  }, [a]);
  const f = _.useCallback(
    (y) => {
      let w = y.target.value;
      w || (w = "<NoValue>");
      try {
        w = e[0](w);
      } catch {
      }
      w !== a && s(w);
    },
    [s, e, a]
  );
  let h = o.connected ? e[1](a) : u;
  h == null && (h = ""), h = h.toString();
  const p = (h.toString().match(/\n/g) || []).length, g = Math.max(...h.split(`
`).map((y) => y.length), 0);
  return /* @__PURE__ */ x.jsx(
    "textarea",
    {
      className: "nodedatainput styledinput stringinput",
      value: h,
      onChange: (y) => c(y.target.value),
      onBlur: (y) => {
        f(y);
      },
      disabled: o.connected,
      rows: p + 1,
      cols: g + 1
    }
  );
}, sie = {
  float: eie,
  int: tie,
  bool: Moe,
  string: nR,
  str: nR,
  color: Ooe,
  select: Yc,
  enum: Yc,
  bytes: _4(zx, "")
}, lie = {}, uie = {}, to = {
  Inputrenderer: sie,
  Outputrenderer: Roe,
  HandlePreviewRenderer: Toe,
  DataOverlayRenderer: koe,
  DataPreviewViewRenderer: S4,
  DataViewRenderer: Lx,
  InLineRenderer: Coe,
  NodeRenderer: lie,
  NodeHooks: uie
}, cie = (e, t) => {
  const n = t.options || {}, r = n.overwrite === void 0 ? !0 : n.overwrite;
  switch (t.type) {
    case "EXTEND_INPUT_RENDER":
      return !r && e.Inputrenderer[t.payload.type] ? e : {
        ...e,
        Inputrenderer: {
          ...e.Inputrenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_FROM_PLUGIN": {
      let s = !1;
      const u = [
        [t.payload.plugin.input_renderers || {}, e.Inputrenderer],
        [t.payload.plugin.output_renderers || {}, e.Outputrenderer],
        [
          t.payload.plugin.handle_preview_renderers || {},
          e.HandlePreviewRenderer
        ],
        [
          t.payload.plugin.data_overlay_renderers || {},
          e.DataOverlayRenderer
        ],
        [
          t.payload.plugin.data_preview_renderers || {},
          e.DataPreviewViewRenderer
        ],
        [
          t.payload.plugin.data_view_renderers || {},
          e.DataViewRenderer
        ],
        [t.payload.plugin.node_renderers || {}, e.NodeRenderer],
        [t.payload.plugin.node_hooks || {}, e.NodeHooks]
      ];
      for (const [f, h] of u) {
        if (Object.keys(f).length > 0) {
          if (r)
            s = !0;
          else
            for (const p in f)
              if (!h[p]) {
                s = !0;
                break;
              }
        }
        if (s) break;
      }
      if (!s)
        return e;
      const c = { ...e };
      return u.forEach(([f, h]) => {
        Object.assign(h, f);
      }), c;
    }
    default:
      const a = {
        EXTEND_OUTPUT_RENDER: "Outputrenderer",
        EXTEND_HANDLE_PREVIEW_RENDER: "HandlePreviewRenderer",
        EXTEND_DATA_OVERLAY_RENDER: "DataOverlayRenderer",
        EXTEND_DATA_PREVIEW_RENDER: "DataPreviewViewRenderer",
        EXTEND_DATA_VIEW_RENDER: "DataViewRenderer",
        EXTEND_NODE_CONTEXT_EXTENDER: "NodeContextExtenders",
        EXTEND_NODE_RENDERER: "NodeRenderer",
        EXTEND_NODE_HOOKS: "NodeHooks"
      }[t.type];
      if (a) {
        const s = e[a];
        return !r && s[t.payload.type] ? e : {
          ...e,
          [a]: {
            ...s,
            [t.payload.type]: t.payload.component
          }
        };
      }
      return e;
  }
}, fie = ({
  children: e,
  plugins: t,
  fnrf_zst: n
}) => {
  const [r, o] = _.useReducer(
    cie,
    to
  ), a = (w, v, S) => {
    o({
      type: "EXTEND_INPUT_RENDER",
      payload: { type: w, component: v },
      options: S
    });
  }, s = (w, v, S) => {
    o({
      type: "EXTEND_OUTPUT_RENDER",
      payload: { type: w, component: v },
      options: S
    });
  }, u = (w, v, S) => {
    o({
      type: "EXTEND_HANDLE_PREVIEW_RENDER",
      payload: { type: w, component: v },
      options: S
    });
  }, c = (w, v, S) => {
    o({
      type: "EXTEND_DATA_OVERLAY_RENDER",
      payload: { type: w, component: v },
      options: S
    });
  }, f = (w, v, S) => {
    o({
      type: "EXTEND_DATA_PREVIEW_RENDER",
      payload: { type: w, component: v },
      options: S
    });
  }, h = (w, v, S) => {
    o({
      type: "EXTEND_DATA_VIEW_RENDER",
      payload: { type: w, component: v },
      options: S
    });
  }, p = (w, v, S) => {
    o({
      type: "EXTEND_NODE_RENDERER",
      payload: { type: w, component: v },
      options: S
    });
  }, g = (w, v, S) => {
    o({
      type: "EXTEND_NODE_HOOKS",
      payload: { type: w, component: v },
      options: S
    });
  }, y = (w, v) => {
    o({
      type: "EXTEND_FROM_PLUGIN",
      payload: { plugin: w },
      options: v
    });
  };
  return _.useEffect(() => {
    for (const w in t) {
      const v = t[w];
      if (!v) continue;
      const S = v.renderpluginfactory;
      S && y(S({ React: gl, fnrf_zst: n, NodeContext: Um }));
    }
  }, [t]), /* @__PURE__ */ x.jsx(
    pi.Provider,
    {
      value: {
        Inputrenderer: r.Inputrenderer,
        Outputrenderer: r.Outputrenderer,
        HandlePreviewRenderer: r.HandlePreviewRenderer,
        DataOverlayRenderer: r.DataOverlayRenderer,
        DataPreviewViewRenderer: r.DataPreviewViewRenderer,
        DataViewRenderer: r.DataViewRenderer,
        InLineRenderer: r.InLineRenderer,
        NodeRenderer: r.NodeRenderer,
        NodeHooks: r.NodeHooks,
        extendNodeRenderer: p,
        extendInputRenderMapping: a,
        extendOutputRenderMapping: s,
        extendHandlePreviewRenderMapping: u,
        extendDataOverlayRenderMapping: c,
        extendDataPreviewRenderMapping: f,
        extendDataViewRenderMapping: h,
        extendNodeHooks: g,
        extendFromPlugin: y
      },
      children: e
    }
  );
}, pi = _.createContext({
  Inputrenderer: to.Inputrenderer,
  Outputrenderer: to.Outputrenderer,
  HandlePreviewRenderer: to.HandlePreviewRenderer,
  DataOverlayRenderer: to.DataOverlayRenderer,
  DataPreviewViewRenderer: to.DataPreviewViewRenderer,
  DataViewRenderer: to.DataViewRenderer,
  InLineRenderer: to.InLineRenderer,
  NodeRenderer: to.NodeRenderer,
  NodeHooks: to.NodeHooks,
  extendInputRenderMapping: (e, t, n) => {
  },
  extendOutputRenderMapping: (e, t, n) => {
  },
  extendHandlePreviewRenderMapping: (e, t, n) => {
  },
  extendDataOverlayRenderMapping: (e, t, n) => {
  },
  extendDataPreviewRenderMapping: (e, t, n) => {
  },
  extendDataViewRenderMapping: (e, t, n) => {
  },
  extendNodeRenderer: (e, t, n) => {
  },
  extendNodeHooks: (e, t, n) => {
  },
  extendFromPlugin: (e, t) => {
  }
}), $4 = (e) => {
  const t = nt(), { DataOverlayRenderer: n, DataViewRenderer: r } = _.useContext(pi);
  if (e === void 0) return;
  const o = t.render_options(), [a] = ts(e, o.typemap || {});
  return a ? n[a] ? n[a] : r[a] ? Bm(r[a]) : tR : tR;
}, die = (e) => {
  const t = nt(), n = $4(e), { DataPreviewViewRenderer: r, DataViewRenderer: o } = _.useContext(pi), a = t.render_options();
  if (e === void 0) return [void 0, n];
  const [s] = ts(e, a.typemap || {});
  return s ? r[s] ? [r[s], n] : o[s] ? [
    zn(o[s]),
    n
  ] : [
    zn(Rp),
    n
  ] : [
    zn(Rp),
    n
  ];
}, hie = (e) => {
  const n = nt().render_options(), { HandlePreviewRenderer: r, DataPreviewViewRenderer: o } = _.useContext(pi), a = $4(e);
  let s;
  if (e) {
    const [u] = ts(e, n.typemap || {});
    u ? r[u] ? s = r[u] : o[u] ? s = o[u] : s = zn(
      Rp
    ) : s = zn(
      Rp
    );
  }
  return [s, a];
}, pie = (e) => {
  const [t, n] = _.useState(!1), r = e.use((o) => o.in_trigger);
  return _.useEffect(() => {
    let o;
    return r && !t ? n(!0) : t && (o = setTimeout(() => n(!1), 200)), () => clearTimeout(o);
  }, [r, t]), { visualTrigger: t, nodestore: e };
}, Um = _.createContext({}), cr = () => _.useContext(Um), aa = _.createContext(void 0);
function Rt(e) {
  if (e)
    return cr().io_stores.get(e);
  {
    const t = _.useContext(aa);
    if (!t)
      throw new Error("IOContext not set");
    return t;
  }
}
function Hl(e) {
  const { node: t } = Tn();
  if (e || (e = Rt().use()), typeof e == "string" && (e = Rt(e)?.use(), !e))
    throw new Error(`No IO found for ${e}`);
  if (!e)
    throw new Error("No IO found");
  return _.useCallback(
    (r, o) => {
      console.log("io value set", r), t?.set_io_value({
        nid: e.node,
        ioid: e.id,
        value: r,
        set_default: o ?? e.render_options.set_default
      });
    },
    [e, t]
  );
}
function mie(e) {
  const { node: t } = Tn();
  let n, r;
  if (!e) {
    const s = Rt().useShallow((u) => ({
      io_id: u.id,
      node_id: u.node
    }));
    n = s.io_id, r = s.node_id;
  }
  if (typeof e == "string") {
    const a = Rt(e);
    if (!a)
      throw new Error(`No IO found for ${e}`);
    const s = a.useShallow((u) => ({
      io_id: u.id,
      node_id: u.node
    }));
    n = s.io_id, r = s.node_id;
  } else {
    if (!e)
      throw new Error("No IO found");
    n = e.id, r = e.node;
  }
  return _.useCallback(
    (a) => {
      t?.set_io_value_options({
        nid: r,
        ioid: n,
        values: a.values ?? a.keys,
        keys: a.keys,
        nullable: a.nullable ?? !1
      });
    },
    [t, n, r]
  );
}
function gie(e) {
  return Rt(e)?.valuestore();
}
function qm(e) {
  const t = Rt(e);
  if (!t) return;
  const { node: n, id: r } = t.useShallow((s) => ({
    node: s.node,
    id: s.id
  })), { node: o } = Tn();
  return _.useCallback(() => o?.get_io_full_value({ nid: n, ioid: r }), [o, n, r]);
}
function $x(e) {
  const t = Rt(e);
  if (!t) return;
  const { node: n, id: r } = t.useShallow((s) => ({
    node: s.node,
    id: s.id
  })), { node: o } = Tn();
  return _.useCallback(
    (s) => {
      o?.update_io_options({
        nid: n,
        ioid: r,
        options: { hidden: s }
      });
    },
    [o, n, r]
  );
}
const B4 = ({
  iostore: e,
  Component: t
}) => {
  const [n, r] = _.useState(void 0), [o, a] = _.useState(void 0), { full: s } = e.valuestore(), u = qm();
  _.useEffect(() => {
    s === void 0 ? u?.() : a(s.value);
  }, [s, u]);
  const c = () => {
    o !== void 0 && r(o);
  };
  return /* @__PURE__ */ x.jsx(
    t,
    {
      value: o,
      preValue: n,
      onLoaded: c
    }
  );
}, H4 = ({
  Component: e
}) => /* @__PURE__ */ x.jsx(e, {}), ts = (e, t) => V4(e.render_options?.type ?? "any", t), V4 = (e, t) => {
  if (typeof e == "string")
    return e in t ? [t[e], e] : [e, e];
  if ("allOf" in e && e.allOf !== void 0)
    return [void 0, void 0];
  if ("anyOf" in e && e.anyOf !== void 0) {
    const n = e.anyOf.map(
      (r) => V4(r || "any", t)
    );
    for (const r of n)
      switch (r[0]) {
        case "bool":
          return ["bool", r[1]];
        case "enum":
          return ["enum", r[1]];
        case "float":
          return ["float", r[1]];
        case "int":
          return ["int", r[1]];
        case "string":
          return ["string", r[1]];
        case "str":
          return ["string", r[1]];
      }
    return [void 0, void 0];
  }
  return !("type" in e) || e.type === void 0 ? [void 0, void 0] : e.type === "enum" ? ["enum", "enum"] : [void 0, void 0];
}, qb = ({
  typestring: e,
  preview: t,
  ...n
}) => {
  const [r, o] = _.useState(!1), [a, s] = _.useState(!1), u = nt(), c = Rt(), f = c.use(), h = qm(), [p, g] = hie(f), y = u.local_state(() => u.reactflowRef);
  return (
    // <Tooltip.Provider>
    /* @__PURE__ */ x.jsxs(r2, { open: r || a, onOpenChange: s, children: [
      /* @__PURE__ */ x.jsx(o2, { asChild: !0, children: /* @__PURE__ */ x.jsx(Gc, { id: f.id, "data-type": e, ...n }) }),
      /* @__PURE__ */ x.jsx(i2, { container: y, children: /* @__PURE__ */ x.jsxs(
        a2,
        {
          className: "iotooltipcontent",
          sideOffset: 5,
          avoidCollisions: !0,
          collisionBoundary: y,
          collisionPadding: 10,
          onOpenAutoFocus: (w) => w.preventDefault(),
          onCloseAutoFocus: (w) => w.preventDefault(),
          children: [
            /* @__PURE__ */ x.jsxs("div", { className: "iotooltip_container", children: [
              /* @__PURE__ */ x.jsxs("div", { className: "iotooltip_header", children: [
                r ? /* @__PURE__ */ x.jsx(NV, { onClick: () => o(!1) }) : /* @__PURE__ */ x.jsx(OV, { onClick: () => o(!0) }),
                g && /* @__PURE__ */ x.jsx(
                  ci,
                  {
                    title: f.full_id,
                    trigger: /* @__PURE__ */ x.jsx(mN, {}),
                    onOpenChange: (w) => {
                      w && h?.(), o(w);
                    },
                    children: /* @__PURE__ */ x.jsx(
                      B4,
                      {
                        Component: g,
                        iostore: c
                      }
                    )
                  }
                )
              ] }),
              p ? /* @__PURE__ */ x.jsx(H4, { Component: p }) : `no preview available for "${e}"`
            ] }),
            /* @__PURE__ */ x.jsx(hq, { className: "iotooltipcontentarrow" })
          ]
        }
      ) })
    ] })
  );
}, Ml = {
  "": [(e) => e, (e) => e],
  str_to_json: [
    (e) => JSON.parse(e),
    (e) => typeof e == "string" ? e : JSON.stringify(e)
  ],
  str_to_list: [
    (e) => {
      try {
        const t = JSON.parse(e);
        return Array.isArray(t) ? t : [t];
      } catch {
        try {
          return JSON.parse("[" + e + "]");
        } catch {
        }
      }
      throw new Error("Invalid list");
    },
    (e) => JSON.stringify(e)
  ]
}, yie = ({
  setNodeSettingsPath: e,
  setShowSettings: t
}) => {
  const r = nt().render_options(), a = Rt().use(), [s, u] = ts(a, r.typemap || {}), { Inputrenderer: c } = _.useContext(pi), f = s ? a.value_options?.options ? Yc : c[s] : void 0, h = Ml[(u && r.inputconverter?.[u]) ?? ""] || Ml[""], { keys: p } = G1(), g = (y) => {
    p.has("s") && (e && e("inputs/" + a.id), t && t(!0), y.stopPropagation());
  };
  return a.hidden ? null : /* @__PURE__ */ x.jsxs(
    "div",
    {
      className: "nodeinput",
      "data-type": s,
      onClick: g,
      children: [
        /* @__PURE__ */ x.jsx(
          qb,
          {
            typestring: s,
            position: Te.Left,
            type: "target"
          }
        ),
        /* @__PURE__ */ x.jsxs("div", { className: "inner_nodeio", children: [
          f && /* @__PURE__ */ x.jsx("div", { className: "iovaluefield nodrag", "data-type": s, children: /* @__PURE__ */ x.jsx(f, { inputconverter: h }) }),
          /* @__PURE__ */ x.jsx("div", { className: "ioname", children: a.name })
        ] }),
        /* @__PURE__ */ x.jsx(
          qb,
          {
            typestring: s,
            position: Te.Right,
            type: "source"
          }
        )
      ]
    }
  );
}, vie = ({
  setNodeSettingsPath: e,
  setShowSettings: t
}) => {
  const r = nt().render_options(), a = Rt().use(), [s] = ts(a, r.typemap || {}), { Outputrenderer: u } = _.useContext(pi), { keys: c } = G1(), f = s ? u[s] : void 0, h = (p) => {
    c.has("s") && (e && e("outputs/" + a.id), t && t(!0), p.stopPropagation());
  };
  return a.hidden ? null : /* @__PURE__ */ x.jsxs(
    "div",
    {
      className: "nodeoutput",
      "data-type": s,
      onClick: h,
      children: [
        /* @__PURE__ */ x.jsx(
          qb,
          {
            typestring: s,
            position: Te.Right,
            type: "source"
          }
        ),
        /* @__PURE__ */ x.jsxs("div", { className: "inner_nodeio", children: [
          /* @__PURE__ */ x.jsx("div", { className: "ioname", children: a.name }),
          f ? /* @__PURE__ */ x.jsx("div", { className: "iovaluefield nodrag", children: /* @__PURE__ */ x.jsx(f, {}) }) : /* @__PURE__ */ x.jsx("div", { className: "iovaluefield", children: /* @__PURE__ */ x.jsx(Aoe, {}) })
        ] })
      ]
    }
  );
}, bie = () => {
  const t = nt().render_options(), r = Rt().use(), o = $x(), [a, s] = ts(r, t.typemap || {}), { Inputrenderer: u } = _.useContext(pi), c = a ? r.value_options?.options ? Yc : u[a] : void 0, f = Ml[(s && t.inputconverter?.[s]) ?? ""] || Ml[""];
  return /* @__PURE__ */ x.jsxs("div", { className: "nodesettings_component", children: [
    /* @__PURE__ */ x.jsx("div", { children: r.name }),
    c && /* @__PURE__ */ x.jsx(c, { inputconverter: f }),
    /* @__PURE__ */ x.jsx("div", { children: /* @__PURE__ */ x.jsxs("label", { children: [
      "hidden:",
      /* @__PURE__ */ x.jsx(
        "input",
        {
          className: "styledcheckbox",
          type: "checkbox",
          disabled: r.connected,
          onChange: (h) => {
            o?.(h.target.checked);
          },
          checked: r.hidden
        }
      )
    ] }) })
  ] });
}, xie = () => {
  const t = Rt().use(), n = $x();
  return /* @__PURE__ */ x.jsxs("div", { className: "nodesettings_component", children: [
    /* @__PURE__ */ x.jsx("div", { children: t.name }),
    /* @__PURE__ */ x.jsx("div", { children: /* @__PURE__ */ x.jsxs("label", { children: [
      "hidden:",
      /* @__PURE__ */ x.jsx(
        "input",
        {
          className: "styledcheckbox",
          type: "checkbox",
          disabled: t.connected,
          onChange: (r) => {
            n?.(r.target.checked);
          },
          checked: t.hidden
        }
      )
    ] }) })
  ] });
}, U4 = ({}) => {
  const e = nt(), { node: t } = Tn(), r = Rt().use(), o = e.render_options(), a = $x(), [s, u] = _.useState(r.name);
  _.useEffect(() => u(r.name), [r.name]);
  const c = _.useCallback(
    (v) => u(v.target.value),
    []
  ), f = _.useCallback(() => {
    s !== r.name && t?.update_io_options({
      nid: r.node,
      ioid: r.id,
      options: { name: s }
    });
  }, [r, t, s]), [h, p] = ts(
    r,
    o.typemap || {}
  ), g = Ml[(p && o.inputconverter?.[p]) ?? ""] || Ml[""], { Inputrenderer: y } = _.useContext(pi), w = h ? r.value_options?.options ? Yc : y[h] : void 0;
  return /* @__PURE__ */ x.jsxs("div", { className: "nodesettings-io-entry funcnodes-control-group", children: [
    /* @__PURE__ */ x.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ x.jsx("label", { htmlFor: `io-name-${r.id}`, children: "Name:" }),
      /* @__PURE__ */ x.jsx(
        "input",
        {
          id: `io-name-${r.id}`,
          type: "text",
          value: s,
          onChange: c,
          onBlur: f,
          className: "styledinput"
        }
      )
    ] }),
    /* @__PURE__ */ x.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ x.jsx("label", { children: "ID:" }),
      /* @__PURE__ */ x.jsx("span", { children: r.id })
    ] }),
    /* @__PURE__ */ x.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ x.jsx("label", { children: "Value:" }),
      w && /* @__PURE__ */ x.jsx(w, { inputconverter: g })
    ] }),
    /* @__PURE__ */ x.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ x.jsx("label", { children: "Type:" }),
      /* @__PURE__ */ x.jsx("pre", { children: JSON.stringify(r.type, null, 2) })
    ] }),
    /* @__PURE__ */ x.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ x.jsx("label", { htmlFor: `io-hidden-${r.id}`, children: "Hidden:" }),
      /* @__PURE__ */ x.jsx(
        "input",
        {
          id: `io-hidden-${r.id}`,
          type: "checkbox",
          checked: r.hidden,
          onChange: (v) => a?.(v.target.checked),
          className: "styledcheckbox",
          disabled: r.connected && r.is_input
        }
      )
    ] }),
    /* @__PURE__ */ x.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ x.jsx("label", { children: "Value Options:" }),
      /* @__PURE__ */ x.jsx("pre", { children: JSON.stringify(r.value_options, null, 2) })
    ] }),
    /* @__PURE__ */ x.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ x.jsx("label", { children: "Render Options:" }),
      /* @__PURE__ */ x.jsx("pre", { className: "code-display", children: JSON.stringify(r.render_options, null, 2) })
    ] }),
    r.is_input && /* @__PURE__ */ x.jsxs(x.Fragment, { children: [
      /* @__PURE__ */ x.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ x.jsx("label", { children: "Does Trigger:" }),
        /* @__PURE__ */ x.jsx("span", { children: String(r.does_trigger) })
      ] }),
      /* @__PURE__ */ x.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ x.jsx("label", { children: "Required:" }),
        /* @__PURE__ */ x.jsx("span", { children: String(r.required) })
      ] })
    ] }),
    /* @__PURE__ */ x.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ x.jsx("label", { children: "Emit Value Set:" }),
      /* @__PURE__ */ x.jsx("span", { children: String(r.emit_value_set) })
    ] }),
    /* @__PURE__ */ x.jsx("hr", {})
  ] });
}, Gb = {
  xxs: 0,
  xs: 320,
  s: 480,
  m: 768,
  l: 960,
  xl: 1280,
  xxl: 1920
}, wie = Object.entries(Gb).sort(
  ([, e], [, t]) => t - e
), q4 = _.createContext(void 0), _ie = (e, t) => {
  let n;
  return (...r) => {
    clearTimeout(n), n = setTimeout(() => e(...r), t);
  };
}, Sie = (e) => {
  for (const [t, n] of wie)
    if (e >= n)
      return t;
  return "xxs";
}, G4 = _.memo(
  _.forwardRef(
    (e, t) => {
      const { className: n, children: r, ...o } = e, [a, s] = _.useState(
        {
          wKey: "m",
          w: 0,
          h: 0
        }
      ), u = _.useRef(null);
      _.useImperativeHandle(
        t,
        () => u.current,
        []
      );
      const c = _.useCallback((h) => {
        const p = h.width, g = h.height, y = Sie(p);
        s((w) => w.wKey === y && w.w === p && w.h === g ? w : { wKey: y, w: p, h: g });
      }, []), f = _.useMemo(
        () => _ie(c, 16),
        [c]
      );
      return _.useEffect(() => {
        const h = u.current;
        if (!h)
          return;
        const p = new ResizeObserver((g) => {
          const y = g[0];
          y && f(y.contentRect);
        });
        return c(h.getBoundingClientRect()), p.observe(h), () => {
          p.disconnect();
        };
      }, [c, f]), /* @__PURE__ */ x.jsx(q4.Provider, { value: a, children: /* @__PURE__ */ x.jsx(
        "div",
        {
          ref: u,
          className: `size-context w-${a.wKey} ${n || ""}`.trim(),
          ...o,
          children: r
        }
      ) });
    }
  )
);
G4.displayName = "SizeContextContainer";
const Eie = () => {
  const e = _.useContext(q4);
  if (!e)
    throw new Error(
      "useSizeContext must be used within a SizeContextContainerContext"
    );
  return e;
}, Cie = (e, t) => e === t ? !1 : e === "" ? !0 : Gb[e] < Gb[t], kie = (e) => {
  const { wKey: t } = Eie();
  return Cie(t, e);
}, rR = (e, t, n = "", r = "") => {
  const o = [];
  return typeof e == "string" ? o.push(`${t}-${e}`) : typeof e == "boolean" ? o.push(e ? n : r) : e && typeof e == "object" && Object.entries(e).forEach(([a, s]) => {
    if (typeof s == "string")
      o.push(
        a === "" ? `${t}-${s}` : `${a}-${t}-${s}`
      );
    else if (typeof s == "boolean") {
      const u = s ? n : r;
      u && o.push(a === "" ? u : `${a}-${u}`);
    }
  }), o.filter(Boolean).join(" ");
}, Ji = _.memo(
  ({
    direction: e,
    className: t = "",
    children: n,
    wrap: r = !1,
    grow: o = !1,
    ...a
  }) => {
    const s = "float-container", u = rR(e, "direction"), c = rR(o, "", "grow", "no-grow"), h = [
      s,
      u,
      c,
      typeof r == "boolean" && r ? "flex-wrap" : "",
      t
    ].filter(Boolean).join(" ");
    return /* @__PURE__ */ x.jsx("div", { className: h, ...a, children: n });
  }
);
Ji.displayName = "FloatContainer";
const Tie = {
  up: (e) => /* @__PURE__ */ x.jsx(x.Fragment, { children: "" }),
  down: (e) => /* @__PURE__ */ x.jsx(x.Fragment, { children: "" }),
  left: (e) => /* @__PURE__ */ x.jsx(x.Fragment, { children: "" }),
  right: (e) => /* @__PURE__ */ x.jsx(x.Fragment, { children: "" })
}, Aie = {
  up: (e) => /* @__PURE__ */ x.jsx(x.Fragment, { children: "" }),
  down: (e) => /* @__PURE__ */ x.jsx(x.Fragment, { children: "" }),
  left: (e) => /* @__PURE__ */ x.jsx(x.Fragment, { children: "" }),
  right: (e) => /* @__PURE__ */ x.jsx(x.Fragment, { children: "" })
}, Bx = _.memo(
  ({
    direction: e,
    expanded: t = !0,
    children: n,
    className: r,
    maxSize: o = "18.75rem",
    expanderSize: a = "2rem",
    containerStyle: s,
    style: u,
    containerClassName: c,
    expandIcons: f,
    collapseIcons: h,
    onExpandChange: p,
    ...g
  }) => {
    const [y, w] = _.useState(t);
    _.useEffect(() => {
      w(t);
    }, [t]);
    const v = _.useCallback(() => {
      w((R) => {
        const F = !R;
        return p?.(F), F;
      });
    }, [p]), S = _.useCallback(
      (R) => {
        (R.key === "Enter" || R.key === " ") && (R.preventDefault(), v());
      },
      [v]
    ), E = e === "right" || e === "left", T = e === "left" || e === "up", k = y ? h?.[e] || Aie[e] : f?.[e] || Tie[e], A = `${e} ${y ? "expanded" : "collapsed"}`, M = _.useMemo(
      () => ({
        [E ? "width" : "height"]: y ? o : a
      }),
      [E, y, o, a]
    ), N = _.useMemo(
      () => ({
        [E ? "width" : "height"]: y ? o : 0
      }),
      [E, y, o]
    ), P = _.useMemo(
      () => ({
        [E ? "width" : "height"]: a
      }),
      [E, a]
    ), z = /* @__PURE__ */ x.jsx(
      "div",
      {
        className: `expanding_container_content ${A} ${r || ""}`.trim(),
        style: { ...u, ...N },
        ...g,
        children: n
      }
    ), B = /* @__PURE__ */ x.jsx(
      "div",
      {
        className: `expanding_container_expander ${A}`,
        onClick: v,
        onKeyDown: S,
        style: P,
        role: "button",
        tabIndex: 0,
        "aria-label": `${y ? "Collapse" : "Expand"} ${e}`,
        children: /* @__PURE__ */ x.jsx(k, {})
      }
    );
    return /* @__PURE__ */ x.jsxs(
      "div",
      {
        className: `expanding_container ${A} ${c || ""}`,
        style: { ...s, ...M },
        children: [
          T ? B : z,
          T ? z : B
        ]
      }
    );
  }
);
Bx.displayName = "ExpandingContainer";
const Rie = ({ nodestore: e }) => {
  const t = e.use();
  return /* @__PURE__ */ x.jsx(Um.Provider, { value: e, children: /* @__PURE__ */ x.jsxs("div", { className: "nodesettings_content", children: [
    /* @__PURE__ */ x.jsx("div", { className: "nodesettings_section", children: /* @__PURE__ */ x.jsxs("div", { className: "nodesettings_component", children: [
      /* @__PURE__ */ x.jsx("div", { children: "Name" }),
      /* @__PURE__ */ x.jsx("div", { children: /* @__PURE__ */ x.jsx(qx, {}) })
    ] }) }),
    /* @__PURE__ */ x.jsxs("div", { className: "nodesettings_section", children: [
      /* @__PURE__ */ x.jsx("div", { children: "Inputs" }),
      t.inputs.map((n) => {
        const r = e.io_stores.get(n);
        if (r)
          return /* @__PURE__ */ x.jsx(aa.Provider, { value: r, children: /* @__PURE__ */ x.jsx(bie, {}) }, n);
      })
    ] }),
    /* @__PURE__ */ x.jsxs("div", { className: "nodesettings_section", children: [
      /* @__PURE__ */ x.jsx("div", { children: "Outputs" }),
      t.outputs.map((n) => {
        const r = e.io_stores.get(n);
        if (r)
          return /* @__PURE__ */ x.jsx(aa.Provider, { value: r, children: /* @__PURE__ */ x.jsx(xie, {}) }, n);
      })
    ] })
  ] }) });
}, Mie = () => {
  const e = nt(), t = e.local_state((r) => r.selected_nodes);
  if (t.length === 0)
    return /* @__PURE__ */ x.jsx("div", { children: "Node Settings" });
  if (t.length > 1)
    return /* @__PURE__ */ x.jsx("div", { children: "Multiple Nodes Selected" });
  const n = e.nodespace.get_node(t[0]);
  return n ? /* @__PURE__ */ x.jsx(Rie, { nodestore: n }) : /* @__PURE__ */ x.jsx("div", { children: "Node not found" });
}, Oie = () => {
  const e = nt(), t = e.local_settings(
    (r) => r.view_settings.expand_node_props
  ), n = (r) => {
    e.update_view_settings({ expand_node_props: r });
  };
  return /* @__PURE__ */ x.jsx(
    Bx,
    {
      direction: "left",
      expanded: t === void 0 ? !1 : t,
      containerClassName: "pos-right pos-top bg1 h-12",
      className: "nodesettings_content",
      onExpandChange: n,
      collapseIcons: {
        up: op,
        down: Dc,
        left: Nc,
        right: rp
      },
      expandIcons: {
        up: Dc,
        down: op,
        left: rp,
        right: Nc
      },
      children: /* @__PURE__ */ x.jsx(Mie, {})
    }
  );
};
var vv = "rovingFocusGroup.onEntryFocus", Nie = { bubbles: !1, cancelable: !0 }, wf = "RovingFocusGroup", [Yb, Y4, Die] = xm(wf), [Pie, Gm] = _o(
  wf,
  [Die]
), [jie, Iie] = Pie(wf), W4 = _.forwardRef(
  (e, t) => /* @__PURE__ */ x.jsx(Yb.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ x.jsx(Yb.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ x.jsx(zie, { ...e, ref: t }) }) })
);
W4.displayName = wf;
var zie = _.forwardRef((e, t) => {
  const {
    __scopeRovingFocusGroup: n,
    orientation: r,
    loop: o = !1,
    dir: a,
    currentTabStopId: s,
    defaultCurrentTabStopId: u,
    onCurrentTabStopIdChange: c,
    onEntryFocus: f,
    preventScrollOnEntryFocus: h = !1,
    ...p
  } = e, g = _.useRef(null), y = bt(t, g), w = Hm(a), [v, S] = sa({
    prop: s,
    defaultProp: u ?? null,
    onChange: c,
    caller: wf
  }), [E, T] = _.useState(!1), k = Hn(f), A = Y4(n), M = _.useRef(!1), [N, P] = _.useState(0);
  return _.useEffect(() => {
    const z = g.current;
    if (z)
      return z.addEventListener(vv, k), () => z.removeEventListener(vv, k);
  }, [k]), /* @__PURE__ */ x.jsx(
    jie,
    {
      scope: n,
      orientation: r,
      dir: w,
      loop: o,
      currentTabStopId: v,
      onItemFocus: _.useCallback(
        (z) => S(z),
        [S]
      ),
      onItemShiftTab: _.useCallback(() => T(!0), []),
      onFocusableItemAdd: _.useCallback(
        () => P((z) => z + 1),
        []
      ),
      onFocusableItemRemove: _.useCallback(
        () => P((z) => z - 1),
        []
      ),
      children: /* @__PURE__ */ x.jsx(
        qe.div,
        {
          tabIndex: E || N === 0 ? -1 : 0,
          "data-orientation": r,
          ...p,
          ref: y,
          style: { outline: "none", ...e.style },
          onMouseDown: xe(e.onMouseDown, () => {
            M.current = !0;
          }),
          onFocus: xe(e.onFocus, (z) => {
            const B = !M.current;
            if (z.target === z.currentTarget && B && !E) {
              const R = new CustomEvent(vv, Nie);
              if (z.currentTarget.dispatchEvent(R), !R.defaultPrevented) {
                const F = A().filter((I) => I.focusable), U = F.find((I) => I.active), W = F.find((I) => I.id === v), V = [U, W, ...F].filter(
                  Boolean
                ).map((I) => I.ref.current);
                Z4(V, h);
              }
            }
            M.current = !1;
          }),
          onBlur: xe(e.onBlur, () => T(!1))
        }
      )
    }
  );
}), X4 = "RovingFocusGroupItem", K4 = _.forwardRef(
  (e, t) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: r = !0,
      active: o = !1,
      tabStopId: a,
      children: s,
      ...u
    } = e, c = po(), f = a || c, h = Iie(X4, n), p = h.currentTabStopId === f, g = Y4(n), { onFocusableItemAdd: y, onFocusableItemRemove: w, currentTabStopId: v } = h;
    return _.useEffect(() => {
      if (r)
        return y(), () => w();
    }, [r, y, w]), /* @__PURE__ */ x.jsx(
      Yb.ItemSlot,
      {
        scope: n,
        id: f,
        focusable: r,
        active: o,
        children: /* @__PURE__ */ x.jsx(
          qe.span,
          {
            tabIndex: p ? 0 : -1,
            "data-orientation": h.orientation,
            ...u,
            ref: t,
            onMouseDown: xe(e.onMouseDown, (S) => {
              r ? h.onItemFocus(f) : S.preventDefault();
            }),
            onFocus: xe(e.onFocus, () => h.onItemFocus(f)),
            onKeyDown: xe(e.onKeyDown, (S) => {
              if (S.key === "Tab" && S.shiftKey) {
                h.onItemShiftTab();
                return;
              }
              if (S.target !== S.currentTarget) return;
              const E = $ie(S, h.orientation, h.dir);
              if (E !== void 0) {
                if (S.metaKey || S.ctrlKey || S.altKey || S.shiftKey) return;
                S.preventDefault();
                let k = g().filter((A) => A.focusable).map((A) => A.ref.current);
                if (E === "last") k.reverse();
                else if (E === "prev" || E === "next") {
                  E === "prev" && k.reverse();
                  const A = k.indexOf(S.currentTarget);
                  k = h.loop ? Bie(k, A + 1) : k.slice(A + 1);
                }
                setTimeout(() => Z4(k));
              }
            }),
            children: typeof s == "function" ? s({ isCurrentTabStop: p, hasTabStop: v != null }) : s
          }
        )
      }
    );
  }
);
K4.displayName = X4;
var Lie = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function Fie(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function $ie(e, t, n) {
  const r = Fie(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return Lie[r];
}
function Z4(e, t = !1) {
  const n = document.activeElement;
  for (const r of e)
    if (r === n || (r.focus({ preventScroll: t }), document.activeElement !== n)) return;
}
function Bie(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var Q4 = W4, J4 = K4, Ym = "Tabs", [Hie, hme] = _o(Ym, [
  Gm
]), eD = Gm(), [Vie, Hx] = Hie(Ym), tD = _.forwardRef(
  (e, t) => {
    const {
      __scopeTabs: n,
      value: r,
      onValueChange: o,
      defaultValue: a,
      orientation: s = "horizontal",
      dir: u,
      activationMode: c = "automatic",
      ...f
    } = e, h = Hm(u), [p, g] = sa({
      prop: r,
      onChange: o,
      defaultProp: a ?? "",
      caller: Ym
    });
    return /* @__PURE__ */ x.jsx(
      Vie,
      {
        scope: n,
        baseId: po(),
        value: p,
        onValueChange: g,
        orientation: s,
        dir: h,
        activationMode: c,
        children: /* @__PURE__ */ x.jsx(
          qe.div,
          {
            dir: h,
            "data-orientation": s,
            ...f,
            ref: t
          }
        )
      }
    );
  }
);
tD.displayName = Ym;
var nD = "TabsList", rD = _.forwardRef(
  (e, t) => {
    const { __scopeTabs: n, loop: r = !0, ...o } = e, a = Hx(nD, n), s = eD(n);
    return /* @__PURE__ */ x.jsx(
      Q4,
      {
        asChild: !0,
        ...s,
        orientation: a.orientation,
        dir: a.dir,
        loop: r,
        children: /* @__PURE__ */ x.jsx(
          qe.div,
          {
            role: "tablist",
            "aria-orientation": a.orientation,
            ...o,
            ref: t
          }
        )
      }
    );
  }
);
rD.displayName = nD;
var oD = "TabsTrigger", iD = _.forwardRef(
  (e, t) => {
    const { __scopeTabs: n, value: r, disabled: o = !1, ...a } = e, s = Hx(oD, n), u = eD(n), c = lD(s.baseId, r), f = uD(s.baseId, r), h = r === s.value;
    return /* @__PURE__ */ x.jsx(
      J4,
      {
        asChild: !0,
        ...u,
        focusable: !o,
        active: h,
        children: /* @__PURE__ */ x.jsx(
          qe.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": h,
            "aria-controls": f,
            "data-state": h ? "active" : "inactive",
            "data-disabled": o ? "" : void 0,
            disabled: o,
            id: c,
            ...a,
            ref: t,
            onMouseDown: xe(e.onMouseDown, (p) => {
              !o && p.button === 0 && p.ctrlKey === !1 ? s.onValueChange(r) : p.preventDefault();
            }),
            onKeyDown: xe(e.onKeyDown, (p) => {
              [" ", "Enter"].includes(p.key) && s.onValueChange(r);
            }),
            onFocus: xe(e.onFocus, () => {
              const p = s.activationMode !== "manual";
              !h && !o && p && s.onValueChange(r);
            })
          }
        )
      }
    );
  }
);
iD.displayName = oD;
var aD = "TabsContent", sD = _.forwardRef(
  (e, t) => {
    const { __scopeTabs: n, value: r, forceMount: o, children: a, ...s } = e, u = Hx(aD, n), c = lD(u.baseId, r), f = uD(u.baseId, r), h = r === u.value, p = _.useRef(h);
    return _.useEffect(() => {
      const g = requestAnimationFrame(() => p.current = !1);
      return () => cancelAnimationFrame(g);
    }, []), /* @__PURE__ */ x.jsx(Br, { present: o || h, children: ({ present: g }) => /* @__PURE__ */ x.jsx(
      qe.div,
      {
        "data-state": h ? "active" : "inactive",
        "data-orientation": u.orientation,
        role: "tabpanel",
        "aria-labelledby": c,
        hidden: !g,
        id: f,
        tabIndex: 0,
        ...s,
        ref: t,
        style: {
          ...e.style,
          animationDuration: p.current ? "0s" : void 0
        },
        children: g && a
      }
    ) });
  }
);
sD.displayName = aD;
function lD(e, t) {
  return `${e}-trigger-${t}`;
}
function uD(e, t) {
  return `${e}-content-${t}`;
}
var Vx = tD, Ux = rD, wc = iD, _c = sD;
const Uie = ({}) => {
  const e = nt(), t = cr(), { description: n, id: r, node_id: o, node_name: a, reset_inputs_on_trigger: s } = t.useShallow((p) => ({
    description: p.description,
    id: p.id,
    node_id: p.node_id,
    node_name: p.node_name,
    reset_inputs_on_trigger: p.reset_inputs_on_trigger
  })), [u, c] = _.useState(
    n || ""
  );
  _.useEffect(() => c(n || ""), [n]);
  const f = (p) => c(p.target.value), h = () => {
    u !== (n || "") && e.on_node_action({
      type: "update",
      from_remote: !1,
      id: r,
      node: { description: u }
    });
  };
  return /* @__PURE__ */ x.jsxs("div", { className: "nodesettings-section funcnodes-control-group", children: [
    /* @__PURE__ */ x.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ x.jsx("label", { htmlFor: `node-name-${r}`, children: "Name:" }),
      /* @__PURE__ */ x.jsx(qx, {})
    ] }),
    /* @__PURE__ */ x.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ x.jsx("label", { children: "Instance ID:" }),
      /* @__PURE__ */ x.jsx("span", { children: r })
    ] }),
    /* @__PURE__ */ x.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ x.jsx("label", { children: "Node Type ID:" }),
      /* @__PURE__ */ x.jsx("span", { children: o })
    ] }),
    /* @__PURE__ */ x.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ x.jsx("label", { children: "Node Type Name:" }),
      /* @__PURE__ */ x.jsx("span", { children: a })
    ] }),
    /* @__PURE__ */ x.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ x.jsx("label", { htmlFor: `node-desc-${r}`, children: "Description:" }),
      /* @__PURE__ */ x.jsx(
        "textarea",
        {
          id: `node-desc-${r}`,
          value: u,
          onChange: f,
          onBlur: h,
          className: "styledinput",
          rows: 3
        }
      )
    ] }),
    /* @__PURE__ */ x.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ x.jsx("label", { children: "Reset Inputs on Trigger:" }),
      /* @__PURE__ */ x.jsx(
        "input",
        {
          type: "checkbox",
          checked: s,
          onChange: (p) => {
            e.on_node_action({
              type: "update",
              from_remote: !1,
              id: r,
              node: { reset_inputs_on_trigger: p.target.checked }
            });
          },
          className: "styledcheckbox"
        }
      )
    ] })
  ] });
}, qie = ({ splitnodesettingsPath: e = [] }) => {
  const t = cr(), n = t.use((r) => r.inputs);
  return /* @__PURE__ */ x.jsxs(
    Vx,
    {
      defaultValue: e[0] || n[0],
      className: "nodesettings-tabs funcnodes-control-root",
      children: [
        /* @__PURE__ */ x.jsx(
          Ux,
          {
            className: "nodesettings-tabs-list",
            "aria-label": "Manage node inputs",
            children: n.map((r) => /* @__PURE__ */ x.jsx(
              wc,
              {
                value: r,
                className: "nodesettings-tabs-trigger",
                children: r
              },
              r
            ))
          }
        ),
        n.map((r) => {
          const o = t.io_stores.get(r);
          return /* @__PURE__ */ x.jsx(
            _c,
            {
              value: r,
              className: "nodesettings-tabs-content nodesettings-io-list",
              children: o && /* @__PURE__ */ x.jsx(aa.Provider, { value: o, children: /* @__PURE__ */ x.jsx(U4, {}) })
            },
            r
          );
        })
      ]
    }
  );
}, Gie = ({ splitnodesettingsPath: e = [] }) => {
  const t = cr(), n = t.use((r) => r.outputs);
  return /* @__PURE__ */ x.jsxs(
    Vx,
    {
      defaultValue: e[0] || n[0],
      className: "nodesettings-tabs funcnodes-control-root",
      children: [
        /* @__PURE__ */ x.jsx(
          Ux,
          {
            className: "nodesettings-tabs-list",
            "aria-label": "Manage node outputs",
            children: n.map((r) => /* @__PURE__ */ x.jsx(
              wc,
              {
                value: r,
                className: "nodesettings-tabs-trigger",
                children: r
              },
              r
            ))
          }
        ),
        n.map((r) => {
          const o = t.io_stores.get(r);
          return /* @__PURE__ */ x.jsx(
            _c,
            {
              value: r,
              className: "nodesettings-tabs-content nodesettings-io-list",
              children: o && /* @__PURE__ */ x.jsx(aa.Provider, { value: o, children: /* @__PURE__ */ x.jsx(U4, {}) })
            },
            r
          );
        })
      ]
    }
  );
}, Yie = ({
  nodeSettingsPath: e
}) => {
  const t = e.split("/") || ["general"];
  return /* @__PURE__ */ x.jsxs(
    Vx,
    {
      defaultValue: t[0] || "general",
      className: "nodesettings-tabs funcnodes-control-root",
      children: [
        /* @__PURE__ */ x.jsxs(
          Ux,
          {
            className: "nodesettings-tabs-list",
            "aria-label": "Manage node settings",
            children: [
              /* @__PURE__ */ x.jsx(wc, { value: "general", className: "nodesettings-tabs-trigger", children: "General" }),
              /* @__PURE__ */ x.jsx(wc, { value: "inputs", className: "nodesettings-tabs-trigger", children: "Inputs" }),
              /* @__PURE__ */ x.jsx(wc, { value: "outputs", className: "nodesettings-tabs-trigger", children: "Outputs" })
            ]
          }
        ),
        /* @__PURE__ */ x.jsx(_c, { value: "general", className: "nodesettings-tabs-content", children: /* @__PURE__ */ x.jsx(Uie, {}) }),
        /* @__PURE__ */ x.jsx(
          _c,
          {
            value: "inputs",
            className: "nodesettings-tabs-content nodesettings-io-list",
            children: /* @__PURE__ */ x.jsx(
              qie,
              {
                splitnodesettingsPath: (
                  // all but first element
                  t.slice(1)
                )
              }
            )
          }
        ),
        /* @__PURE__ */ x.jsx(
          _c,
          {
            value: "outputs",
            className: "nodesettings-tabs-content nodesettings-io-list",
            children: /* @__PURE__ */ x.jsx(
              Gie,
              {
                splitnodesettingsPath: (
                  // all but first element
                  t.slice(1)
                )
              }
            )
          }
        )
      ]
    }
  );
}, Wie = _.memo(
  ({ isOpen: e, onOpenChange: t, nodeSettingsPath: n }) => {
    const o = cr().use((a) => a.id);
    return /* @__PURE__ */ x.jsx(
      ci,
      {
        title: `Node Settings: ${o}`,
        open: e,
        onOpenChange: t,
        dialogClassName: "nodesettings-dialog",
        children: /* @__PURE__ */ x.jsx(Yie, { nodeSettingsPath: n })
      }
    );
  }
), Xie = _.memo(({ toogleShowSettings: e }) => {
  const t = nt(), { node: n } = Tn(), r = cr(), { id: o, description: a, node_name: s } = r.useShallow((c) => ({
    id: c.id,
    description: c.description,
    node_name: c.node_name
  })), u = _.useCallback(() => {
    t.on_node_action({
      type: "trigger",
      from_remote: !1,
      id: o
    });
  }, [t, o]);
  return /* @__PURE__ */ x.jsxs("div", { className: "nodeheader", title: a || s, children: [
    /* @__PURE__ */ x.jsxs("div", { className: "nodeheader_element", children: [
      /* @__PURE__ */ x.jsx(
        PV,
        {
          fontSize: "inherit",
          className: "triggerbutton nodeheaderbutton ",
          onClick: u
        }
      ),
      /* @__PURE__ */ x.jsx(
        DV,
        {
          fontSize: "inherit",
          className: "nodestatusbutton nodeheaderbutton",
          onClick: async () => {
            n && console.log("nodestatus", await n.get_node_status(o));
          }
        }
      ),
      /* @__PURE__ */ x.jsx(
        IV,
        {
          fontSize: "inherit",
          className: "nodesettingsbutton nodeheaderbutton",
          onClick: () => {
            e?.();
          }
        }
      )
    ] }),
    /* @__PURE__ */ x.jsx("div", { className: "nodeheader_element nodeheader_title", children: /* @__PURE__ */ x.jsx("div", { className: "nodeheader_title_text", children: s }) }),
    /* @__PURE__ */ x.jsx("div", { className: "nodeheader_element", children: /* @__PURE__ */ x.jsx(sf, { fontSize: "inherit" }) })
  ] });
}), Kie = _.memo(({ iostore: e }) => {
  const t = e.use(), r = cr().use((u) => u.render_options), o = qm(t.id), [a, s] = die(t);
  return /* @__PURE__ */ x.jsx(
    "div",
    {
      className: "nodrag nodedatabody",
      "data-src": r?.data?.src || "",
      children: a && t && /* @__PURE__ */ x.jsx(aa.Provider, { value: e, children: /* @__PURE__ */ x.jsx(
        ci,
        {
          title: t.full_id,
          trigger: /* @__PURE__ */ x.jsx("div", { className: "nodedatabutton", children: /* @__PURE__ */ x.jsx(H4, { Component: a }) }),
          onOpenChange: (u) => {
            u && o?.();
          },
          children: s && /* @__PURE__ */ x.jsx(B4, { Component: s, iostore: e })
        }
      ) })
    }
  );
}), Zie = _.memo(
  ({ setShowSettings: e, setNodeSettingsPath: t }) => {
    const n = cr(), { render_options: r, outputs: o, inputs: a } = n.useShallow(
      (u) => ({
        render_options: u.render_options,
        outputs: u.outputs,
        inputs: u.inputs
      })
    ), s = r?.data?.src ? n.io_stores.get(r?.data?.src) : void 0;
    return /* @__PURE__ */ x.jsxs("div", { className: "nodebody nowheel ", children: [
      o.map((u) => {
        const c = n.io_stores.get(u);
        if (c)
          return /* @__PURE__ */ x.jsx(aa.Provider, { value: c, children: /* @__PURE__ */ x.jsx(
            vie,
            {
              setNodeSettingsPath: t,
              setShowSettings: e
            }
          ) }, u);
      }),
      s && /* @__PURE__ */ x.jsx(Kie, { iostore: s }),
      a.map((u) => {
        const c = n.io_stores.get(u);
        if (c)
          return /* @__PURE__ */ x.jsx(aa.Provider, { value: c, children: /* @__PURE__ */ x.jsx(
            yie,
            {
              setNodeSettingsPath: t,
              setShowSettings: e
            }
          ) }, u);
      })
    ] });
  }
), qx = () => {
  const e = cr(), { original_name: t, id: n } = e.useShallow((c) => ({
    original_name: c.name,
    id: c.id
  })), [r, o] = _.useState(t);
  _.useEffect(() => {
    o(t);
  }, [t]);
  const a = nt(), s = (c) => {
    o(c.target.value);
  }, u = (c) => {
    const f = c.target.value;
    f !== t && a.on_node_action({
      type: "update",
      from_remote: !1,
      id: n,
      node: { name: f }
    });
  };
  return /* @__PURE__ */ x.jsx(
    "input",
    {
      className: "nodename_input",
      value: r,
      onChange: s,
      onBlur: u
    }
  );
}, Qie = () => {
  const t = cr().use((n) => n.progress);
  return t ? /* @__PURE__ */ x.jsx(
    CW,
    {
      state: t,
      className: "nodeprogress"
    }
  ) : null;
}, Jie = _.memo(() => {
  const t = cr().use((n) => n.error);
  return /* @__PURE__ */ x.jsxs("div", { className: "nodefooter", children: [
    t && /* @__PURE__ */ x.jsx("div", { className: "nodeerror", children: t }),
    /* @__PURE__ */ x.jsx(Qie, {})
  ] });
}), eae = () => {
  const e = cr(), { collapsed: t, error: n, node_id: r } = e.useShallow((w) => ({
    collapsed: w.properties["frontend:collapsed"] || !1,
    error: w.error,
    node_id: w.node_id
  })), { visualTrigger: o } = pie(e), [a, s] = _.useState(!1), [u, c] = _.useState(""), { keys: f } = G1(), p = _.useContext(pi).NodeHooks[r] ?? [], g = _.useCallback(() => {
    s((w) => !w);
  }, []), y = (w) => {
    f.has("s") && !a && (c(""), s(!0), w.stopPropagation());
  };
  return /* @__PURE__ */ x.jsxs(
    "div",
    {
      className: "innernode" + (o ? " intrigger" : "") + (n ? " error" : ""),
      onClick: y,
      children: [
        /* @__PURE__ */ x.jsx(Xie, { toogleShowSettings: g }),
        /* @__PURE__ */ x.jsx(qx, {}),
        t ? null : /* @__PURE__ */ x.jsx(
          Zie,
          {
            setNodeSettingsPath: c,
            setShowSettings: s
          }
        ),
        /* @__PURE__ */ x.jsx(Jie, {}),
        /* @__PURE__ */ x.jsx(
          Wie,
          {
            isOpen: a,
            onOpenChange: s,
            nodeSettingsPath: u
          }
        ),
        p.map((w, v) => /* @__PURE__ */ x.jsx(_.Fragment, { children: /* @__PURE__ */ x.jsx(w, {}) }, v))
      ]
    }
  );
}, tae = _.memo(
  ({ data: e }) => /* @__PURE__ */ x.jsx(Um.Provider, { value: e.nodestore, children: /* @__PURE__ */ x.jsx(eae, {}) }),
  (e, t) => e.data.nodestore === t.data.nodestore
), nae = ({
  id: e,
  sourceX: t,
  sourceY: n,
  targetX: r,
  targetY: o,
  sourcePosition: a,
  targetPosition: s,
  data: u,
  ...c
}) => {
  const [f] = Rx({
    sourceX: t,
    sourceY: n,
    sourcePosition: a,
    targetX: r,
    targetY: o,
    targetPosition: s
  });
  return /* @__PURE__ */ x.jsx(x.Fragment, { children: /* @__PURE__ */ x.jsx(xf, { id: e, path: f, ...c }) });
}, rae = {
  default: tae,
  group: _oe
}, oae = {
  default: nae
}, iae = (e) => ({
  nodes: e.getNodes(),
  edges: e.getEdges(),
  onNodesChange: e.onNodesChange,
  onEdgesChange: e.onEdgesChange,
  onConnect: e.onConnect
}), Gx = (e) => {
  const t = /* @__PURE__ */ new Set(), n = e.filter(
    (o) => o.type === "group"
  );
  n.forEach((o) => {
    t.add(o.id);
  });
  const r = e.filter(
    (o) => !t.has(o.id)
  );
  return { group_nodes: n, default_nodes: r };
};
function Yx(e) {
  const t = new Map(e.map((s) => [s.id, s])), n = /* @__PURE__ */ new Map(), r = [];
  for (const s of e)
    if (n.has(s.id) || n.set(s.id, []), s.parentId && t.has(s.parentId)) {
      const u = t.get(s.parentId);
      if (u) {
        const c = n.get(u.id) || [];
        c.push(s), n.set(u.id, c);
      } else
        r.push(s);
    } else
      r.push(s);
  const o = [];
  function a(s) {
    o.push(s);
    const u = n.get(s.id) || [];
    for (const c of u)
      a(c);
  }
  for (const s of r)
    a(s);
  if (o.length !== e.length) {
    console.warn(
      "Sorting mismatch: Not all nodes could be placed. Check for circular dependencies or missing parents."
    );
    const s = new Set(o.map((u) => u.id));
    e.forEach((u) => {
      s.has(u.id) || o.push(u);
    });
  }
  return o;
}
const cD = () => {
  const { getNodes: e } = es();
  return {
    getNodes: e,
    getSelectedNodes: (o) => (o === void 0 && (o = e()), o.filter((a) => a.selected)),
    getSplitNodes: (o) => {
      o === void 0 && (o = e());
      const { group_nodes: a, default_nodes: s } = Gx(o);
      return { group_nodes: a, default_nodes: s };
    },
    getSortedNodes: (o) => (o === void 0 && (o = e()), Yx(o))
  };
}, fD = (e, t) => {
  const n = e.getState(), { new_obj: r, change: o } = Ha(n, t);
  o && e.setState(r);
}, dD = (e) => Er(e);
function oR(e) {
  return e != null && typeof e == "object" && "id" in e && typeof e.id == "string";
}
const hD = (e) => {
  let t = e.io ?? {}, n = e.io_order, r = [];
  const o = {};
  if (n === void 0)
    if (Array.isArray(t)) {
      const a = t.filter(oR);
      r = a.map((s) => s.id);
      for (const s of a)
        o[s.id] = s;
    } else {
      r = Object.keys(t);
      for (const a in t)
        t[a] !== void 0 && (o[a] = t[a]);
    }
  else if (r = n, Array.isArray(t)) {
    const a = t.filter(oR);
    for (const s of a)
      o[s.id] = s, r.includes(s.id) || r.push(s.id);
  } else
    for (const a in t)
      t[a] !== void 0 && (o[a] = t[a]), r.includes(a) || r.push(a);
  return { ...e, io_order: r, io: o };
}, aae = {
  id: "dummy",
  node_id: "dummy",
  node_name: "dummy",
  properties: {
    "frontend:size": [200, 100],
    "frontend:pos": [NaN, NaN],
    "frontend:collapsed": !1
  },
  io: {},
  io_order: [],
  name: "dummy",
  in_trigger: !1,
  reset_inputs_on_trigger: !1,
  progress: {
    ascii: !1,
    elapsed: 0,
    initial: 0,
    n: 0,
    prefix: "idle",
    unit: "it",
    unit_divisor: 1e3,
    unit_scale: !1
  }
}, sae = {
  id: "dummy",
  name: "dummy",
  node: "dummy",
  full_id: "dummy",
  type: "any",
  value: void 0,
  is_input: !1,
  connected: !1,
  does_trigger: !0,
  fullvalue: void 0,
  render_options: {
    set_default: !0,
    type: "any"
  },
  hidden: !1,
  emit_value_set: !0,
  required: !1
}, lae = c1(aae), uae = c1(sae), cae = (e) => {
  const t = e.io_order;
  if (t === void 0)
    throw new Error("Node must have io_order");
  return {
    ...e,
    inputs: Object.keys(e.io).filter((r) => e.io[r].is_input),
    outputs: Object.keys(e.io).filter((r) => !e.io[r].is_input),
    io_order: t
  };
}, fae = (e) => (e.value === "<NoValue>" && (e.value = void 0), e.fullvalue === "<NoValue>" && (e.fullvalue = void 0), e.hidden === void 0 && (e.hidden = !1), [{
  ...e
}, e.value, e.fullvalue]), dae = (e) => {
  if (!e.id)
    throw new Error("Node must have an id");
  const t = lae(e);
  return cae(t);
}, hae = (e, t) => {
  const n = e.getState(), r = {}, o = hD(t), a = Object.keys(o);
  for (const s of a)
    switch (s) {
      case "id": {
        const [u, c] = wr(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      case "node_id": {
        const [u, c] = wr(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      case "node_name": {
        const [u, c] = wr(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      case "name": {
        const [u, c] = wr(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      case "in_trigger": {
        const [u, c] = wr(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      case "error": {
        o[s] !== n[s] && (r[s] = o[s]);
        break;
      }
      case "render_options": {
        const [u, c] = nl(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      case "io_order": {
        const [u, c] = ((f, h) => h === void 0 ? [f, !1] : [h, !u1(f, h)])(n[s], o[s]);
        c && (r[s] = u.filter((f) => f !== void 0));
        break;
      }
      case "io": {
        const u = o[s];
        if (u === void 0) break;
        for (const c in u) {
          const f = e.io_stores.get(c);
          if (!f) {
            console.error("io key not found in oldvalue:", c);
            continue;
          }
          f.update(u[c]);
        }
        break;
      }
      case "progress": {
        const [u, c] = nl(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      case "description": {
        r[s] = o[s];
        break;
      }
      case "properties": {
        const [u, c] = nl(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      case "status": {
        const [u, c] = nl(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      case "reset_inputs_on_trigger": {
        const [u, c] = wr(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      default:
        try {
          tM(s, o[s]);
        } catch (u) {
          console.error(u);
        }
    }
  Object.keys(r).length > 0 && e.setState(r);
}, pae = (e, t) => {
  const n = e.getState(), r = {}, o = {}, a = Object.keys(t);
  for (const s of a)
    switch (s) {
      case "name": {
        const [u, c] = wr(
          n[s],
          t[s]
        );
        c && (r[s] = u);
        break;
      }
      case "id": {
        const [u, c] = wr(
          n[s],
          t[s]
        );
        c && (r[s] = u);
        break;
      }
      case "connected": {
        const [u, c] = wr(
          n[s],
          t[s]
        );
        c && (r[s] = u);
        break;
      }
      case "does_trigger": {
        const [u, c] = wr(
          n[s],
          t[s]
        );
        c && (r[s] = u);
        break;
      }
      case "hidden": {
        const [u, c] = wr(
          n[s],
          t[s]
        );
        c && (r[s] = u);
        break;
      }
      case "full_id": {
        const [u, c] = wr(
          n[s],
          t[s]
        );
        c && (r[s] = u);
        break;
      }
      case "is_input":
        break;
      case "node":
        break;
      case "type":
        break;
      case "value": {
        o.preview = t[s];
        break;
      }
      case "fullvalue": {
        o.full = t[s];
        break;
      }
      case "render_options": {
        const [u, c] = nl(
          n[s],
          t[s]
        );
        c && (r[s] = u);
        break;
      }
      case "value_options": {
        const [u, c] = nl(
          n[s],
          t[s]
        );
        c && (r[s] = u);
        break;
      }
      case "valuepreview_type": {
        r[s] = t[s];
        break;
      }
      case "emit_value_set": {
        r[s] = t[s];
        break;
      }
      case "default": {
        r[s] = t[s];
        break;
      }
      case "required": {
        r[s] = t[s];
        break;
      }
      default:
        try {
          tM(s, t[s]);
        } catch (u) {
          console.error(u);
        }
    }
  Object.keys(o).length > 0 && e.updateValueStore(o), Object.keys(r).length > 0 && e.setState(r);
}, mae = (e) => {
  if (!e.id)
    throw new Error(
      "IO must have an id but is missing for " + JSON.stringify(e)
    );
  e.name === void 0 && (e.name = e.id);
  const t = uae(e);
  return (t.render_options.type === "any" || t.render_options.type === void 0) && (t.render_options.type = t.type), fae(t);
}, gae = (e, t) => {
  let n;
  const [r, o, a] = mae(t);
  return n = {
    io_state: dD((s, u) => r),
    use: (s) => s ? n.io_state(s) : n.io_state(),
    useShallow: (s) => n.io_state(Ix(s)),
    getState: () => n.io_state.getState(),
    setState: (s) => {
      n.io_state.setState(s);
    },
    update: (s) => {
      pae(n, s);
    },
    valuestore: Er((s, u) => {
      let c = o;
      c === "<NoValue>" && (c = void 0), !(c instanceof co) && c !== void 0 && (c = Qi.fromObject(c));
      let f = a;
      return f === "<NoValue>" && (f = void 0), !(f instanceof co) && f !== void 0 && (f = Qi.fromObject(f)), {
        preview: c,
        full: f
      };
    }),
    updateValueStore: (s) => {
      n.valuestore.setState((u) => (u.preview && typeof u.preview.dispose == "function" && u.preview.dispose(), u.full && typeof u.full.dispose == "function" && u.full.dispose(), s.preview !== void 0 && s.full === void 0 && (s.full = void 0, u.full = void 0), s.preview !== void 0 && !(s.preview instanceof co) && (s.preview = Qi.fromObject(s.preview)), s.full !== void 0 && !(s.full instanceof co) && (s.full = Qi.fromObject(s.full)), { ...u, ...s }));
    },
    node: e,
    serialize: () => {
      const s = n.io_state.getState(), u = n.valuestore.getState();
      return {
        ...s,
        value: u.preview,
        fullvalue: u.full,
        render_options: s.render_options,
        valuepreview_type: s.valuepreview_type,
        emit_value_set: s.emit_value_set
      };
    }
  }, n;
}, yae = (e) => {
  const t = {
    use: (a) => a ? r.node_state(a) : r.node_state(),
    useShallow: (a) => r.node_state(Ix(a)),
    io_stores: /* @__PURE__ */ new Map(),
    getState: () => r.node_state.getState(),
    setState: (a) => {
      r.node_state.setState(a);
    },
    update: (a) => {
      hae(r, a);
    },
    serialize: () => ({
      ...r.node_state.getState(),
      io: Object.fromEntries(
        Array.from(r.io_stores.entries()).map(([u, c]) => [
          u,
          c.serialize()
        ])
      )
    })
  }, n = hD(e), r = {
    ...t,
    node_state: dD((a, s) => dae(n))
  }, o = n.io;
  return Object.entries(o).forEach(([a, s]) => {
    s !== void 0 && r.io_stores.set(a, gae(n.id, s));
  }), r;
}, vae = () => {
  const e = nt();
  return {
    onSelectionChange: _.useCallback(
      ({ nodes: n, edges: r }) => {
        const { group_nodes: o, default_nodes: a } = Gx(n), s = e.local_state.getState();
        e.local_state.setState({
          ...s,
          selected_nodes: a.map((u) => u.id),
          selected_edges: r.map((u) => u.id),
          selected_groups: o.map((u) => u.id)
        });
      },
      [e]
    )
  };
}, bae = () => {
  const e = es(), t = nt();
  return t.rf_instance = e, /* @__PURE__ */ x.jsx(x.Fragment, {});
}, xae = () => {
  const e = nt(), { getEdges: t } = es(), { getSelectedNodes: n } = cD();
  return {
    copySelectedNodes: _.useCallback(() => {
      const o = t(), a = n();
      if (a.length === 0) return;
      const s = { nodes: [], edges: [] };
      for (const f of a) {
        const h = e.nodespace.get_node(f.id, !1);
        h && s.nodes.push(h.serialize());
      }
      const u = new Set(a.map((f) => f.id)), c = o.filter(
        (f) => u.has(f.source) && u.has(f.target)
      );
      for (const f of c)
        !f.sourceHandle || !f.targetHandle || s.edges.push({
          src_nid: f.source,
          src_ioid: f.sourceHandle,
          trg_nid: f.target,
          trg_ioid: f.targetHandle
        });
      navigator.clipboard.writeText(JSON.stringify(s));
    }, [n, t, e])
  };
}, wae = () => {
  const e = Qo("Delete"), t = Qo(["Meta+c", "Control+c", "Strg+c"]), n = Qo(["Control+g", "Meta+g"]), r = Qo(["Control+Alt+g", "Meta+Alt+g"]), o = xoe(), { getEdges: a } = es(), { getNodes: s, getSelectedNodes: u, getSplitNodes: c } = cD(), { copySelectedNodes: f } = xae(), { node: h, group: p, edge: g } = Tn();
  return _.useEffect(() => {
    if (e) {
      const y = a().filter((E) => E.selected);
      for (const E of y)
        !E.source || !E.target || !E.sourceHandle || !E.targetHandle || g?.remove_edge({
          src_nid: E.source,
          src_ioid: E.sourceHandle,
          trg_nid: E.target,
          trg_ioid: E.targetHandle
        });
      const w = u(), { group_nodes: v, default_nodes: S } = c(w);
      for (const E of S)
        h?.remove_node(E.id);
      for (const E of v)
        p?.remove_group(E.id);
    }
  }, [e, s, a, h, p, g]), _.useEffect(() => {
    t && f();
  }, [t, f]), _.useEffect(() => {
    if (n) {
      const y = u(), { group_nodes: w, default_nodes: v } = c(y);
      y.length > 0 && o(
        v.map((S) => S.id),
        w.map((S) => S.id)
      );
    }
  }, [n, s]), _.useEffect(() => {
    if (r) {
      console.log("ungroupPressed");
      const y = u(), { group_nodes: w } = c(y);
      w.forEach((v) => {
        p?.remove_group(v.id);
      });
    }
  }, [r, s]), /* @__PURE__ */ x.jsx(x.Fragment, {});
}, _ae = () => {
  const { node: e, edge: t } = Tn(), n = nt();
  return _.useCallback(
    async (o, a) => {
      try {
        if (!o || !e || !t) return;
        const s = JSON.parse(o);
        if (!s || !n.worker || !s.nodes) return;
        const u = [0, 0];
        for (const f of s.nodes)
          u[0] += f.properties["frontend:pos"][0], u[1] += f.properties["frontend:pos"][1];
        u[0] /= s.nodes.length, u[1] /= s.nodes.length;
        const c = [];
        for (const f of s.nodes) {
          const h = {
            id: f.node_id,
            src_id: f.id,
            position: [
              f.properties["frontend:pos"][0] - u[0],
              f.properties["frontend:pos"][1] - u[1]
            ]
          };
          c.push(h);
        }
        for (const f of c) {
          const h = await e.add_node(f.id);
          !h || !n.nodespace.get_node(h.id, !1) || (f.new_id = h.id, a([
            {
              id: h.id,
              type: "position",
              position: {
                x: f.position[0] + h.properties["frontend:pos"][0],
                y: f.position[1] + h.properties["frontend:pos"][1]
              }
            }
          ]));
        }
        for (const f of s.edges) {
          const h = c.find(
            (g) => g.src_id === f.src_nid
          ), p = c.find(
            (g) => g.src_id === f.trg_nid
          );
          !h || !p || !h.new_id || !p.new_id || t.add_edge({
            src_nid: h.new_id,
            src_ioid: f.src_ioid,
            trg_nid: p.new_id,
            trg_ioid: f.trg_ioid
          });
        }
      } catch (s) {
        console.error("Failed to process pasted data:", s);
      }
    },
    [e, t, n]
  );
}, Sae = (e, t) => {
  const n = e.properties || {};
  n["frontend:size"] || (n["frontend:size"] = [200, 100]);
  const r = n["frontend:pos"];
  if (!r || r.length !== 2 || isNaN(r[0]) || r[0] === null || isNaN(r[1]) || r[1] === null)
    if (!t || !t.rf_instance || t.reactflowRef === null)
      n["frontend:pos"] = [0, 0];
    else {
      const a = t.reactflowRef.getBoundingClientRect(), s = a.left + a.width / 2, u = a.top + a.height / 2, c = t.rf_instance.screenToFlowPosition({
        x: s,
        y: u
      });
      n["frontend:pos"] = [
        c.x - n["frontend:size"][0] / 2,
        c.y - n["frontend:size"][0] / 2
      ];
    }
  n["frontend:collapsed"] || (n["frontend:collapsed"] = !1), e.properties = n;
}, Eae = (e, t) => {
  const n = e.getState();
  if (Sae(n, t), n.id === void 0)
    throw new Error("Node must have an id");
  const r = {
    nodestore: e
  };
  return {
    position: {
      x: n.properties["frontend:pos"][0],
      y: n.properties["frontend:pos"][1]
    },
    data: r,
    type: "default",
    zIndex: 1003,
    // expandParent: true,
    ...n
  };
}, iR = {
  default: En.Dots,
  metal: En.Cross,
  light: En.Dots,
  solarized: En.Dots,
  midnight: En.Dots,
  forest: En.Dots,
  scientific: En.Lines
}, Cae = (e) => {
  const t = nt(), n = _.useRef(null), { colorTheme: r } = bN(), { onSelectionChange: o } = vae(), a = bX();
  _.useEffect(() => {
    t.getStateManager().toaster = a;
  }, []), _.useEffect(() => {
    t.reactflowRef = n.current;
  }, [n]);
  const { nodes: s, edges: u, onNodesChange: c, onEdgesChange: f, onConnect: h } = t.useReactFlowStore(Ix(iae)), p = _ae(), g = _.useCallback(
    (y) => {
      const w = n.current;
      if (!w) return;
      let v = y.target, S = 0;
      for (; v && v.parentElement && v !== w; )
        S++, v = v.parentElement;
      t.logger.debug(`onPasteCapture: ${S} steps to reactflow`), S <= 2 && p(
        y.clipboardData.getData("text/plain"),
        c
      );
    },
    [p, c, t.logger]
  );
  return /* @__PURE__ */ x.jsx("div", { className: "reactflowlayer", children: /* @__PURE__ */ x.jsxs(
    Ure,
    {
      onPasteCapture: g,
      nodes: s,
      edges: u,
      onNodesChange: c,
      onEdgesChange: f,
      onConnect: h,
      nodeTypes: rae,
      edgeTypes: oae,
      minZoom: e.minZoom,
      maxZoom: e.maxZoom,
      fitView: !0,
      onSelectionChange: o,
      ref: n,
      panOnDrag: !e.static,
      children: [
        /* @__PURE__ */ x.jsx(bae, {}),
        /* @__PURE__ */ x.jsx(wae, {}),
        /* @__PURE__ */ x.jsx(
          Xre,
          {
            color: "#888",
            gap: 24,
            size: 2,
            variant: iR[r] || iR.default,
            patternClassName: "fn-background-pattern"
          }
        ),
        e.minimap && /* @__PURE__ */ x.jsx(
          poe,
          {
            nodeStrokeWidth: 3,
            pannable: !e.static,
            zoomable: !e.static,
            zoomStep: 3
          }
        )
      ]
    }
  ) });
}, kae = ({
  on_node_change: e,
  on_edge_change: t,
  on_connect: n
}) => {
  const r = e || ((u) => {
  }), o = t || ((u) => {
  }), a = n || ((u) => {
  });
  return Er((u, c) => ({
    _nodes: [],
    _edges: [],
    _nodes_map: /* @__PURE__ */ new Map(),
    update_nodes: (f) => {
      f = Yx(f), u({
        _nodes: f,
        _nodes_map: new Map(f.map((h) => [h.id, h]))
      });
    },
    partial_update_nodes: (f) => {
      const h = c(), p = h._nodes, g = new Map(
        p.map((y) => [y.id, y])
      );
      for (const y of f)
        g.set(y.id, y);
      h.update_nodes(Array.from(g.values()));
    },
    update_edges: (f) => {
      u({
        _edges: f
      });
    },
    onNodesChange: (f) => {
      const h = c();
      h.update_nodes(Px(f, h._nodes)), r(f);
    },
    onEdgesChange: (f) => {
      u({
        _edges: U5(f, c()._edges)
      }), o(f);
    },
    onConnect: (f) => {
      f.source == null || f.target == null || a(f);
    },
    getNode: (f) => c()._nodes_map.get(f),
    getNodes: () => c()._nodes,
    getEdges: () => c()._edges
  }));
}, Tae = () => {
  const t = nt().progress_state();
  return /* @__PURE__ */ x.jsxs("div", { className: "statusbar", children: [
    /* @__PURE__ */ x.jsx(
      "span",
      {
        className: "statusbar-progressbar",
        style: { width: Math.min(100, 100 * t.progress) + "%" }
      }
    ),
    /* @__PURE__ */ x.jsx("span", { className: "statusbar-message", children: t.message })
  ] });
}, Mp = !1;
var Wb = ["Enter", " "], Aae = ["ArrowDown", "PageUp", "Home"], pD = ["ArrowUp", "PageDown", "End"], Rae = [...Aae, ...pD], Mae = {
  ltr: [...Wb, "ArrowRight"],
  rtl: [...Wb, "ArrowLeft"]
}, Oae = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, _f = "Menu", [Wc, Nae, Dae] = xm(_f), [ns, mD] = _o(_f, [
  Dae,
  ym,
  Gm
]), Sf = ym(), gD = Gm(), [yD, rs] = ns(_f), [Pae, Ef] = ns(_f), vD = (e) => {
  const { __scopeMenu: t, open: n = !1, children: r, dir: o, onOpenChange: a, modal: s = !0 } = e, u = Sf(t), [c, f] = _.useState(null), h = _.useRef(!1), p = Hn(a), g = Hm(o);
  return _.useEffect(() => {
    const y = () => {
      h.current = !0, document.addEventListener("pointerdown", w, { capture: !0, once: !0 }), document.addEventListener("pointermove", w, { capture: !0, once: !0 });
    }, w = () => h.current = !1;
    return document.addEventListener("keydown", y, { capture: !0 }), () => {
      document.removeEventListener("keydown", y, { capture: !0 }), document.removeEventListener("pointerdown", w, { capture: !0 }), document.removeEventListener("pointermove", w, { capture: !0 });
    };
  }, []), /* @__PURE__ */ x.jsx(nx, { ...u, children: /* @__PURE__ */ x.jsx(
    yD,
    {
      scope: t,
      open: n,
      onOpenChange: p,
      content: c,
      onContentChange: f,
      children: /* @__PURE__ */ x.jsx(
        Pae,
        {
          scope: t,
          onClose: _.useCallback(() => p(!1), [p]),
          isUsingKeyboardRef: h,
          dir: g,
          modal: s,
          children: r
        }
      )
    }
  ) });
};
vD.displayName = _f;
var jae = "MenuAnchor", Wx = _.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, o = Sf(n);
    return /* @__PURE__ */ x.jsx(rx, { ...o, ...r, ref: t });
  }
);
Wx.displayName = jae;
var Iae = "MenuPortal", [pme, bD] = ns(Iae, {
  forceMount: void 0
}), Cr = "MenuContent", [zae, Xx] = ns(Cr), xD = _.forwardRef(
  (e, t) => {
    const n = bD(Cr, e.__scopeMenu), { forceMount: r = n.forceMount, ...o } = e, a = rs(Cr, e.__scopeMenu), s = Ef(Cr, e.__scopeMenu);
    return /* @__PURE__ */ x.jsx(Wc.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ x.jsx(Br, { present: r || a.open, children: /* @__PURE__ */ x.jsx(Wc.Slot, { scope: e.__scopeMenu, children: s.modal ? /* @__PURE__ */ x.jsx(Lae, { ...o, ref: t }) : /* @__PURE__ */ x.jsx(Fae, { ...o, ref: t }) }) }) });
  }
), Lae = _.forwardRef(
  (e, t) => {
    const n = rs(Cr, e.__scopeMenu), r = _.useRef(null), o = bt(t, r);
    return _.useEffect(() => {
      const a = r.current;
      if (a) return R1(a);
    }, []), /* @__PURE__ */ x.jsx(
      Kx,
      {
        ...e,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: xe(
          e.onFocusOutside,
          (a) => a.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }
), Fae = _.forwardRef((e, t) => {
  const n = rs(Cr, e.__scopeMenu);
  return /* @__PURE__ */ x.jsx(
    Kx,
    {
      ...e,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1)
    }
  );
}), $ae = /* @__PURE__ */ bl("MenuContent.ScrollLock"), Kx = _.forwardRef(
  (e, t) => {
    const {
      __scopeMenu: n,
      loop: r = !1,
      trapFocus: o,
      onOpenAutoFocus: a,
      onCloseAutoFocus: s,
      disableOutsidePointerEvents: u,
      onEntryFocus: c,
      onEscapeKeyDown: f,
      onPointerDownOutside: h,
      onFocusOutside: p,
      onInteractOutside: g,
      onDismiss: y,
      disableOutsideScroll: w,
      ...v
    } = e, S = rs(Cr, n), E = Ef(Cr, n), T = Sf(n), k = gD(n), A = Nae(n), [M, N] = _.useState(null), P = _.useRef(null), z = bt(t, P, S.onContentChange), B = _.useRef(0), R = _.useRef(""), F = _.useRef(0), U = _.useRef(null), W = _.useRef("right"), j = _.useRef(0), V = w ? am : _.Fragment, I = w ? { as: $ae, allowPinchZoom: !0 } : void 0, H = (G) => {
      const O = R.current + G, Y = A().filter((de) => !de.disabled), Z = document.activeElement, L = Y.find((de) => de.ref.current === Z)?.textValue, te = Y.map((de) => de.textValue), he = Qae(te, O, L), oe = Y.find((de) => de.textValue === he)?.ref.current;
      (function de(le) {
        R.current = le, window.clearTimeout(B.current), le !== "" && (B.current = window.setTimeout(() => de(""), 1e3));
      })(O), oe && setTimeout(() => oe.focus());
    };
    _.useEffect(() => () => window.clearTimeout(B.current), []), A1();
    const q = _.useCallback((G) => W.current === U.current?.side && ese(G, U.current?.area), []);
    return /* @__PURE__ */ x.jsx(
      zae,
      {
        scope: n,
        searchRef: R,
        onItemEnter: _.useCallback(
          (G) => {
            q(G) && G.preventDefault();
          },
          [q]
        ),
        onItemLeave: _.useCallback(
          (G) => {
            q(G) || (P.current?.focus(), N(null));
          },
          [q]
        ),
        onTriggerLeave: _.useCallback(
          (G) => {
            q(G) && G.preventDefault();
          },
          [q]
        ),
        pointerGraceTimerRef: F,
        onPointerGraceIntentChange: _.useCallback((G) => {
          U.current = G;
        }, []),
        children: /* @__PURE__ */ x.jsx(V, { ...I, children: /* @__PURE__ */ x.jsx(
          rm,
          {
            asChild: !0,
            trapped: o,
            onMountAutoFocus: xe(a, (G) => {
              G.preventDefault(), P.current?.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: s,
            children: /* @__PURE__ */ x.jsx(
              nf,
              {
                asChild: !0,
                disableOutsidePointerEvents: u,
                onEscapeKeyDown: f,
                onPointerDownOutside: h,
                onFocusOutside: p,
                onInteractOutside: g,
                onDismiss: y,
                children: /* @__PURE__ */ x.jsx(
                  Q4,
                  {
                    asChild: !0,
                    ...k,
                    dir: E.dir,
                    orientation: "vertical",
                    loop: r,
                    currentTabStopId: M,
                    onCurrentTabStopIdChange: N,
                    onEntryFocus: xe(c, (G) => {
                      E.isUsingKeyboardRef.current || G.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ x.jsx(
                      UN,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": zD(S.open),
                        "data-radix-menu-content": "",
                        dir: E.dir,
                        ...T,
                        ...v,
                        ref: z,
                        style: { outline: "none", ...v.style },
                        onKeyDown: xe(v.onKeyDown, (G) => {
                          const Y = G.target.closest("[data-radix-menu-content]") === G.currentTarget, Z = G.ctrlKey || G.altKey || G.metaKey, L = G.key.length === 1;
                          Y && (G.key === "Tab" && G.preventDefault(), !Z && L && H(G.key));
                          const te = P.current;
                          if (G.target !== te || !Rae.includes(G.key)) return;
                          G.preventDefault();
                          const oe = A().filter((de) => !de.disabled).map((de) => de.ref.current);
                          pD.includes(G.key) && oe.reverse(), Kae(oe);
                        }),
                        onBlur: xe(e.onBlur, (G) => {
                          G.currentTarget.contains(G.target) || (window.clearTimeout(B.current), R.current = "");
                        }),
                        onPointerMove: xe(
                          e.onPointerMove,
                          Xc((G) => {
                            const O = G.target, Y = j.current !== G.clientX;
                            if (G.currentTarget.contains(O) && Y) {
                              const Z = G.clientX > j.current ? "right" : "left";
                              W.current = Z, j.current = G.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
xD.displayName = Cr;
var Bae = "MenuGroup", Zx = _.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ x.jsx(qe.div, { role: "group", ...r, ref: t });
  }
);
Zx.displayName = Bae;
var Hae = "MenuLabel", wD = _.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ x.jsx(qe.div, { ...r, ref: t });
  }
);
wD.displayName = Hae;
var Op = "MenuItem", aR = "menu.itemSelect", Wm = _.forwardRef(
  (e, t) => {
    const { disabled: n = !1, onSelect: r, ...o } = e, a = _.useRef(null), s = Ef(Op, e.__scopeMenu), u = Xx(Op, e.__scopeMenu), c = bt(t, a), f = _.useRef(!1), h = () => {
      const p = a.current;
      if (!n && p) {
        const g = new CustomEvent(aR, { bubbles: !0, cancelable: !0 });
        p.addEventListener(aR, (y) => r?.(y), { once: !0 }), T1(p, g), g.defaultPrevented ? f.current = !1 : s.onClose();
      }
    };
    return /* @__PURE__ */ x.jsx(
      _D,
      {
        ...o,
        ref: c,
        disabled: n,
        onClick: xe(e.onClick, h),
        onPointerDown: (p) => {
          e.onPointerDown?.(p), f.current = !0;
        },
        onPointerUp: xe(e.onPointerUp, (p) => {
          f.current || p.currentTarget?.click();
        }),
        onKeyDown: xe(e.onKeyDown, (p) => {
          const g = u.searchRef.current !== "";
          n || g && p.key === " " || Wb.includes(p.key) && (p.currentTarget.click(), p.preventDefault());
        })
      }
    );
  }
);
Wm.displayName = Op;
var _D = _.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, disabled: r = !1, textValue: o, ...a } = e, s = Xx(Op, n), u = gD(n), c = _.useRef(null), f = bt(t, c), [h, p] = _.useState(!1), [g, y] = _.useState("");
    return _.useEffect(() => {
      const w = c.current;
      w && y((w.textContent ?? "").trim());
    }, [a.children]), /* @__PURE__ */ x.jsx(
      Wc.ItemSlot,
      {
        scope: n,
        disabled: r,
        textValue: o ?? g,
        children: /* @__PURE__ */ x.jsx(J4, { asChild: !0, ...u, focusable: !r, children: /* @__PURE__ */ x.jsx(
          qe.div,
          {
            role: "menuitem",
            "data-highlighted": h ? "" : void 0,
            "aria-disabled": r || void 0,
            "data-disabled": r ? "" : void 0,
            ...a,
            ref: f,
            onPointerMove: xe(
              e.onPointerMove,
              Xc((w) => {
                r ? s.onItemLeave(w) : (s.onItemEnter(w), w.defaultPrevented || w.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: xe(
              e.onPointerLeave,
              Xc((w) => s.onItemLeave(w))
            ),
            onFocus: xe(e.onFocus, () => p(!0)),
            onBlur: xe(e.onBlur, () => p(!1))
          }
        ) })
      }
    );
  }
), Vae = "MenuCheckboxItem", SD = _.forwardRef(
  (e, t) => {
    const { checked: n = !1, onCheckedChange: r, ...o } = e;
    return /* @__PURE__ */ x.jsx(AD, { scope: e.__scopeMenu, checked: n, children: /* @__PURE__ */ x.jsx(
      Wm,
      {
        role: "menuitemcheckbox",
        "aria-checked": Np(n) ? "mixed" : n,
        ...o,
        ref: t,
        "data-state": ew(n),
        onSelect: xe(
          o.onSelect,
          () => r?.(Np(n) ? !0 : !n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
SD.displayName = Vae;
var ED = "MenuRadioGroup", [Uae, qae] = ns(
  ED,
  { value: void 0, onValueChange: () => {
  } }
), CD = _.forwardRef(
  (e, t) => {
    const { value: n, onValueChange: r, ...o } = e, a = Hn(r);
    return /* @__PURE__ */ x.jsx(Uae, { scope: e.__scopeMenu, value: n, onValueChange: a, children: /* @__PURE__ */ x.jsx(Zx, { ...o, ref: t }) });
  }
);
CD.displayName = ED;
var kD = "MenuRadioItem", TD = _.forwardRef(
  (e, t) => {
    const { value: n, ...r } = e, o = qae(kD, e.__scopeMenu), a = n === o.value;
    return /* @__PURE__ */ x.jsx(AD, { scope: e.__scopeMenu, checked: a, children: /* @__PURE__ */ x.jsx(
      Wm,
      {
        role: "menuitemradio",
        "aria-checked": a,
        ...r,
        ref: t,
        "data-state": ew(a),
        onSelect: xe(
          r.onSelect,
          () => o.onValueChange?.(n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
TD.displayName = kD;
var Qx = "MenuItemIndicator", [AD, Gae] = ns(
  Qx,
  { checked: !1 }
), RD = _.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, forceMount: r, ...o } = e, a = Gae(Qx, n);
    return /* @__PURE__ */ x.jsx(
      Br,
      {
        present: r || Np(a.checked) || a.checked === !0,
        children: /* @__PURE__ */ x.jsx(
          qe.span,
          {
            ...o,
            ref: t,
            "data-state": ew(a.checked)
          }
        )
      }
    );
  }
);
RD.displayName = Qx;
var Yae = "MenuSeparator", MD = _.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ x.jsx(
      qe.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: t
      }
    );
  }
);
MD.displayName = Yae;
var Wae = "MenuArrow", OD = _.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, o = Sf(n);
    return /* @__PURE__ */ x.jsx(qN, { ...o, ...r, ref: t });
  }
);
OD.displayName = Wae;
var Jx = "MenuSub", [Xae, ND] = ns(Jx), DD = (e) => {
  const { __scopeMenu: t, children: n, open: r = !1, onOpenChange: o } = e, a = rs(Jx, t), s = Sf(t), [u, c] = _.useState(null), [f, h] = _.useState(null), p = Hn(o);
  return _.useEffect(() => (a.open === !1 && p(!1), () => p(!1)), [a.open, p]), /* @__PURE__ */ x.jsx(nx, { ...s, children: /* @__PURE__ */ x.jsx(
    yD,
    {
      scope: t,
      open: r,
      onOpenChange: p,
      content: f,
      onContentChange: h,
      children: /* @__PURE__ */ x.jsx(
        Xae,
        {
          scope: t,
          contentId: po(),
          triggerId: po(),
          trigger: u,
          onTriggerChange: c,
          children: n
        }
      )
    }
  ) });
};
DD.displayName = Jx;
var mc = "MenuSubTrigger", PD = _.forwardRef(
  (e, t) => {
    const n = rs(mc, e.__scopeMenu), r = Ef(mc, e.__scopeMenu), o = ND(mc, e.__scopeMenu), a = Xx(mc, e.__scopeMenu), s = _.useRef(null), { pointerGraceTimerRef: u, onPointerGraceIntentChange: c } = a, f = { __scopeMenu: e.__scopeMenu }, h = _.useCallback(() => {
      s.current && window.clearTimeout(s.current), s.current = null;
    }, []);
    return _.useEffect(() => h, [h]), _.useEffect(() => {
      const p = u.current;
      return () => {
        window.clearTimeout(p), c(null);
      };
    }, [u, c]), /* @__PURE__ */ x.jsx(Wx, { asChild: !0, ...f, children: /* @__PURE__ */ x.jsx(
      _D,
      {
        id: o.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": n.open,
        "aria-controls": o.contentId,
        "data-state": zD(n.open),
        ...e,
        ref: nm(t, o.onTriggerChange),
        onClick: (p) => {
          e.onClick?.(p), !(e.disabled || p.defaultPrevented) && (p.currentTarget.focus(), n.open || n.onOpenChange(!0));
        },
        onPointerMove: xe(
          e.onPointerMove,
          Xc((p) => {
            a.onItemEnter(p), !p.defaultPrevented && !e.disabled && !n.open && !s.current && (a.onPointerGraceIntentChange(null), s.current = window.setTimeout(() => {
              n.onOpenChange(!0), h();
            }, 100));
          })
        ),
        onPointerLeave: xe(
          e.onPointerLeave,
          Xc((p) => {
            h();
            const g = n.content?.getBoundingClientRect();
            if (g) {
              const y = n.content?.dataset.side, w = y === "right", v = w ? -5 : 5, S = g[w ? "left" : "right"], E = g[w ? "right" : "left"];
              a.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: p.clientX + v, y: p.clientY },
                  { x: S, y: g.top },
                  { x: E, y: g.top },
                  { x: E, y: g.bottom },
                  { x: S, y: g.bottom }
                ],
                side: y
              }), window.clearTimeout(u.current), u.current = window.setTimeout(
                () => a.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (a.onTriggerLeave(p), p.defaultPrevented) return;
              a.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: xe(e.onKeyDown, (p) => {
          const g = a.searchRef.current !== "";
          e.disabled || g && p.key === " " || Mae[r.dir].includes(p.key) && (n.onOpenChange(!0), n.content?.focus(), p.preventDefault());
        })
      }
    ) });
  }
);
PD.displayName = mc;
var jD = "MenuSubContent", ID = _.forwardRef(
  (e, t) => {
    const n = bD(Cr, e.__scopeMenu), { forceMount: r = n.forceMount, ...o } = e, a = rs(Cr, e.__scopeMenu), s = Ef(Cr, e.__scopeMenu), u = ND(jD, e.__scopeMenu), c = _.useRef(null), f = bt(t, c);
    return /* @__PURE__ */ x.jsx(Wc.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ x.jsx(Br, { present: r || a.open, children: /* @__PURE__ */ x.jsx(Wc.Slot, { scope: e.__scopeMenu, children: /* @__PURE__ */ x.jsx(
      Kx,
      {
        id: u.contentId,
        "aria-labelledby": u.triggerId,
        ...o,
        ref: f,
        align: "start",
        side: s.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (h) => {
          s.isUsingKeyboardRef.current && c.current?.focus(), h.preventDefault();
        },
        onCloseAutoFocus: (h) => h.preventDefault(),
        onFocusOutside: xe(e.onFocusOutside, (h) => {
          h.target !== u.trigger && a.onOpenChange(!1);
        }),
        onEscapeKeyDown: xe(e.onEscapeKeyDown, (h) => {
          s.onClose(), h.preventDefault();
        }),
        onKeyDown: xe(e.onKeyDown, (h) => {
          const p = h.currentTarget.contains(h.target), g = Oae[s.dir].includes(h.key);
          p && g && (a.onOpenChange(!1), u.trigger?.focus(), h.preventDefault());
        })
      }
    ) }) }) });
  }
);
ID.displayName = jD;
function zD(e) {
  return e ? "open" : "closed";
}
function Np(e) {
  return e === "indeterminate";
}
function ew(e) {
  return Np(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function Kae(e) {
  const t = document.activeElement;
  for (const n of e)
    if (n === t || (n.focus(), document.activeElement !== t)) return;
}
function Zae(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
function Qae(e, t, n) {
  const o = t.length > 1 && Array.from(t).every((f) => f === t[0]) ? t[0] : t, a = n ? e.indexOf(n) : -1;
  let s = Zae(e, Math.max(a, 0));
  o.length === 1 && (s = s.filter((f) => f !== n));
  const c = s.find(
    (f) => f.toLowerCase().startsWith(o.toLowerCase())
  );
  return c !== n ? c : void 0;
}
function Jae(e, t) {
  const { x: n, y: r } = e;
  let o = !1;
  for (let a = 0, s = t.length - 1; a < t.length; s = a++) {
    const u = t[a], c = t[s], f = u.x, h = u.y, p = c.x, g = c.y;
    h > r != g > r && n < (p - f) * (r - h) / (g - h) + f && (o = !o);
  }
  return o;
}
function ese(e, t) {
  if (!t) return !1;
  const n = { x: e.clientX, y: e.clientY };
  return Jae(n, t);
}
function Xc(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
var tse = vD, nse = Wx, rse = xD, ose = Zx, ise = wD, ase = Wm, sse = SD, lse = CD, use = TD, cse = RD, fse = MD, dse = OD, hse = DD, pse = PD, mse = ID, Xm = "DropdownMenu", [gse, mme] = _o(
  Xm,
  [mD]
), An = mD(), [yse, LD] = gse(Xm), FD = (e) => {
  const {
    __scopeDropdownMenu: t,
    children: n,
    dir: r,
    open: o,
    defaultOpen: a,
    onOpenChange: s,
    modal: u = !0
  } = e, c = An(t), f = _.useRef(null), [h, p] = sa({
    prop: o,
    defaultProp: a ?? !1,
    onChange: s,
    caller: Xm
  });
  return /* @__PURE__ */ x.jsx(
    yse,
    {
      scope: t,
      triggerId: po(),
      triggerRef: f,
      contentId: po(),
      open: h,
      onOpenChange: p,
      onOpenToggle: _.useCallback(() => p((g) => !g), [p]),
      modal: u,
      children: /* @__PURE__ */ x.jsx(tse, { ...c, open: h, onOpenChange: p, dir: r, modal: u, children: n })
    }
  );
};
FD.displayName = Xm;
var $D = "DropdownMenuTrigger", BD = _.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, disabled: r = !1, ...o } = e, a = LD($D, n), s = An(n);
    return /* @__PURE__ */ x.jsx(nse, { asChild: !0, ...s, children: /* @__PURE__ */ x.jsx(
      qe.button,
      {
        type: "button",
        id: a.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": a.open,
        "aria-controls": a.open ? a.contentId : void 0,
        "data-state": a.open ? "open" : "closed",
        "data-disabled": r ? "" : void 0,
        disabled: r,
        ...o,
        ref: nm(t, a.triggerRef),
        onPointerDown: xe(e.onPointerDown, (u) => {
          !r && u.button === 0 && u.ctrlKey === !1 && (a.onOpenToggle(), a.open || u.preventDefault());
        }),
        onKeyDown: xe(e.onKeyDown, (u) => {
          r || (["Enter", " "].includes(u.key) && a.onOpenToggle(), u.key === "ArrowDown" && a.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(u.key) && u.preventDefault());
        })
      }
    ) });
  }
);
BD.displayName = $D;
var HD = "DropdownMenuContent", VD = _.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = LD(HD, n), a = An(n), s = _.useRef(!1);
    return /* @__PURE__ */ x.jsx(
      rse,
      {
        id: o.contentId,
        "aria-labelledby": o.triggerId,
        ...a,
        ...r,
        ref: t,
        onCloseAutoFocus: xe(e.onCloseAutoFocus, (u) => {
          s.current || o.triggerRef.current?.focus(), s.current = !1, u.preventDefault();
        }),
        onInteractOutside: xe(e.onInteractOutside, (u) => {
          const c = u.detail.originalEvent, f = c.button === 0 && c.ctrlKey === !0, h = c.button === 2 || f;
          (!o.modal || h) && (s.current = !0);
        }),
        style: {
          ...e.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
VD.displayName = HD;
var vse = "DropdownMenuGroup", UD = _.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = An(n);
    return /* @__PURE__ */ x.jsx(ose, { ...o, ...r, ref: t });
  }
);
UD.displayName = vse;
var bse = "DropdownMenuLabel", xse = _.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = An(n);
    return /* @__PURE__ */ x.jsx(ise, { ...o, ...r, ref: t });
  }
);
xse.displayName = bse;
var wse = "DropdownMenuItem", qD = _.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = An(n);
    return /* @__PURE__ */ x.jsx(ase, { ...o, ...r, ref: t });
  }
);
qD.displayName = wse;
var _se = "DropdownMenuCheckboxItem", Sse = _.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = An(n);
  return /* @__PURE__ */ x.jsx(sse, { ...o, ...r, ref: t });
});
Sse.displayName = _se;
var Ese = "DropdownMenuRadioGroup", GD = _.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = An(n);
  return /* @__PURE__ */ x.jsx(lse, { ...o, ...r, ref: t });
});
GD.displayName = Ese;
var Cse = "DropdownMenuRadioItem", YD = _.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = An(n);
  return /* @__PURE__ */ x.jsx(use, { ...o, ...r, ref: t });
});
YD.displayName = Cse;
var kse = "DropdownMenuItemIndicator", Tse = _.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = An(n);
  return /* @__PURE__ */ x.jsx(cse, { ...o, ...r, ref: t });
});
Tse.displayName = kse;
var Ase = "DropdownMenuSeparator", Rse = _.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = An(n);
  return /* @__PURE__ */ x.jsx(fse, { ...o, ...r, ref: t });
});
Rse.displayName = Ase;
var Mse = "DropdownMenuArrow", Ose = _.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = An(n);
    return /* @__PURE__ */ x.jsx(dse, { ...o, ...r, ref: t });
  }
);
Ose.displayName = Mse;
var Nse = (e) => {
  const { __scopeDropdownMenu: t, children: n, open: r, onOpenChange: o, defaultOpen: a } = e, s = An(t), [u, c] = sa({
    prop: r,
    defaultProp: a ?? !1,
    onChange: o,
    caller: "DropdownMenuSub"
  });
  return /* @__PURE__ */ x.jsx(hse, { ...s, open: u, onOpenChange: c, children: n });
}, Dse = "DropdownMenuSubTrigger", WD = _.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = An(n);
  return /* @__PURE__ */ x.jsx(pse, { ...o, ...r, ref: t });
});
WD.displayName = Dse;
var Pse = "DropdownMenuSubContent", XD = _.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = An(n);
  return /* @__PURE__ */ x.jsx(
    mse,
    {
      ...o,
      ...r,
      ref: t,
      style: {
        ...e.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
XD.displayName = Pse;
var tw = FD, nw = BD, rw = VD, ow = UD, Ko = qD, jse = GD, Ise = YD, zse = Nse, Lse = WD, Fse = XD;
const $se = ({
  trigger: e,
  setOpen: t,
  open: n
}) => {
  const [r, o] = _.useState(""), [a, s] = _.useState(!0), u = nt();
  return u.options.useWorkerManager ? /* @__PURE__ */ x.jsxs(
    ci,
    {
      setOpen: t,
      open: n,
      trigger: e,
      title: "New Worker",
      description: "Create a new worker",
      children: [
        /* @__PURE__ */ x.jsxs("div", { children: [
          "Name:",
          /* @__PURE__ */ x.jsx("br", {}),
          /* @__PURE__ */ x.jsx(
            "input",
            {
              className: "styledinput",
              onChange: (c) => {
                o(c.currentTarget.value);
              },
              value: r
            }
          ),
          /* @__PURE__ */ x.jsxs("div", { style: { marginTop: 8 }, children: [
            /* @__PURE__ */ x.jsx(
              "input",
              {
                type: "checkbox",
                id: "inVenvCheckbox",
                checked: a,
                onChange: (c) => s(c.currentTarget.checked)
              }
            ),
            /* @__PURE__ */ x.jsx("label", { htmlFor: "inVenvCheckbox", style: { marginLeft: 4 }, children: "Create in new virtual environment" })
          ] })
        ] }),
        /* @__PURE__ */ x.jsx("div", { children: r && /* @__PURE__ */ x.jsx("div", { children: /* @__PURE__ */ x.jsx(
          "button",
          {
            className: "styledbtn",
            onClick: () => {
              u.workermanager?.new_worker({
                name: r,
                in_venv: a
                // reference: reference.uuid,
                // copyLib,
                // copyNS,
              }), t(!1);
            },
            children: "Create"
          }
        ) }) })
      ]
    }
  ) : null;
}, Bse = ({
  trigger: e,
  setOpen: t,
  open: n
}) => {
  const r = nt(), [o, a] = _.useState(!1), s = r.workers(), u = r.worker?.uuid, c = (u ? s[u]?.name : void 0) || u || "worker", f = async () => {
    if (!r.worker) return;
    const h = await r.worker.export({ withFiles: o });
    A6(h, c + ".fnw", "application/zip"), t(!1);
  };
  return /* @__PURE__ */ x.jsx(
    ci,
    {
      setOpen: t,
      open: n,
      trigger: e,
      title: "Export Worker",
      description: "Export the worker as a .fnw file",
      children: /* @__PURE__ */ x.jsxs("div", { children: [
        /* @__PURE__ */ x.jsxs("div", { children: [
          /* @__PURE__ */ x.jsx(
            "input",
            {
              type: "checkbox",
              className: "styledcheckbox",
              checked: o,
              onChange: (h) => {
                a(h.currentTarget.checked);
              }
            }
          ),
          "Include Files"
        ] }),
        /* @__PURE__ */ x.jsx("button", { className: "styledbtn", onClick: f, children: "Export" })
      ] })
    }
  );
}, Hse = () => {
  const e = nt(), t = e.workers(), [n, r] = _.useState(!1), [o, a] = _.useState(!1), s = (y) => {
    y !== "__select__" && e.workers && e.workermanager && t[y] && (!t[y].active && !window.confirm(
      "this is an inactive worker, selecting it will start it, continue?"
    ) || e.workermanager.set_active(y));
  }, u = async () => {
    if (!e.worker || !window.confirm(
      "Updateing the worker might replace the current nodespace, continue?"
    )) return;
    const w = await O6(".fnw");
    e.worker.update_from_export(w);
  }, c = e.options.useWorkerManager && e.workermanager && e.workermanager.open || Mp, f = c && Object.keys(t).length > 0, h = e.worker && e.worker.is_open, p = h && c;
  return c || h ? /* @__PURE__ */ x.jsxs(x.Fragment, { children: [
    /* @__PURE__ */ x.jsxs(tw, { children: [
      /* @__PURE__ */ x.jsx(nw, { asChild: !0, children: /* @__PURE__ */ x.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ x.jsxs(Ji, { direction: "row", children: [
        "Worker ",
        /* @__PURE__ */ x.jsx(q1, { className: "m-x-s" })
      ] }) }) }),
      /* @__PURE__ */ x.jsx(rw, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ x.jsxs(ow, { children: [
        f && /* @__PURE__ */ x.jsxs(zse, { children: [
          /* @__PURE__ */ x.jsx(Lse, { className: "headermenuitem submenuitem", children: /* @__PURE__ */ x.jsxs(Ji, { direction: "row", children: [
            "Select",
            /* @__PURE__ */ x.jsx(Nc, {})
          ] }) }),
          /* @__PURE__ */ x.jsx(
            Fse,
            {
              className: "headermenucontent funcnodescontainer",
              sideOffset: 2,
              alignOffset: -5,
              children: /* @__PURE__ */ x.jsx(
                jse,
                {
                  value: e.worker?.uuid,
                  onValueChange: (y) => {
                    s(y);
                  },
                  children: Object.keys(t).sort((y, w) => {
                    if (t[y].active && !t[w].active)
                      return -1;
                    if (!t[y].active && t[w].active)
                      return 1;
                    const v = t[y].name || y, S = t[w].name || w;
                    return v.localeCompare(S);
                  }).map((y) => /* @__PURE__ */ x.jsx(
                    Ise,
                    {
                      className: "headermenuitem workerselectoption" + (t[y]?.active ? " active" : " inactive") + " headermenuitem",
                      value: y,
                      disabled: y === e.worker?.uuid,
                      children: t[y]?.name || y
                    },
                    y
                  ))
                }
              )
            }
          )
        ] }),
        h && /* @__PURE__ */ x.jsxs(x.Fragment, { children: [
          p && /* @__PURE__ */ x.jsx(
            Ko,
            {
              className: "headermenuitem",
              onClick: () => {
                if (e.worker) {
                  if (!e.workermanager)
                    return e.logger.error("no workermanager");
                  e.workermanager?.restart_worker(
                    e.worker.uuid
                  );
                }
              },
              children: "Restart"
            }
          ),
          /* @__PURE__ */ x.jsx(
            Ko,
            {
              className: "headermenuitem",
              onClick: () => {
                e.worker && e.worker.stop();
              },
              children: "Stop"
            }
          ),
          /* @__PURE__ */ x.jsx(
            Ko,
            {
              className: "headermenuitem",
              onClick: () => a(!0),
              children: "Export"
            }
          ),
          /* @__PURE__ */ x.jsx(
            Ko,
            {
              className: "headermenuitem",
              onClick: u,
              children: "Update"
            }
          )
        ] }),
        c && /* @__PURE__ */ x.jsx(x.Fragment, { children: /* @__PURE__ */ x.jsx(
          Ko,
          {
            className: "headermenuitem",
            onClick: () => r(!0),
            children: "New"
          }
        ) })
      ] }) })
    ] }),
    /* @__PURE__ */ x.jsx(
      $se,
      {
        open: n,
        setOpen: r
      }
    ),
    /* @__PURE__ */ x.jsx(
      Bse,
      {
        open: o,
        setOpen: a
      }
    )
  ] }) : null;
}, Vse = () => {
  const e = nt(), t = () => {
    window.confirm("Are you sure you want to start a new flow?") && e.worker?.clear();
  }, n = async () => {
    const o = await e.worker?.save();
    if (!o) return;
    const a = new Blob([JSON.stringify(o)], {
      type: "application/json"
    }), s = URL.createObjectURL(a), u = document.createElement("a");
    u.href = s, u.download = "flow.json", u.click(), URL.revokeObjectURL(s), u.remove();
  }, r = async () => {
    const o = document.createElement("input");
    o.type = "file", o.accept = ".json", o.onchange = async (a) => {
      const s = a.target.files?.[0];
      if (!s) return;
      const u = new FileReader();
      u.onload = async (c) => {
        const f = c.target?.result;
        if (!f) return;
        const h = JSON.parse(f);
        await e.worker?.load(h);
      }, u.readAsText(s);
    }, o.click();
  };
  return /* @__PURE__ */ x.jsx(x.Fragment, { children: /* @__PURE__ */ x.jsxs(tw, { children: [
    /* @__PURE__ */ x.jsx(nw, { asChild: !0, children: /* @__PURE__ */ x.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ x.jsxs(Ji, { direction: "row", children: [
      "Nodespace ",
      /* @__PURE__ */ x.jsx(q1, { className: "m-x-s" })
    ] }) }) }),
    /* @__PURE__ */ x.jsx(rw, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ x.jsxs(ow, { children: [
      /* @__PURE__ */ x.jsx(Ko, { className: "headermenuitem", onClick: t, children: "New" }),
      /* @__PURE__ */ x.jsx(Ko, { className: "headermenuitem", onClick: n, children: "Save" }),
      /* @__PURE__ */ x.jsx(Ko, { className: "headermenuitem", onClick: r, children: "Load" })
    ] }) })
  ] }) });
}, Use = ({ theme: e, selected: t }) => /* @__PURE__ */ x.jsxs(
  "div",
  {
    style: {
      width: 80,
      height: 54,
      borderRadius: "var(--fn-border-radius-s, 8px)",
      border: t ? "2.5px solid #1976d2" : "1.5px solid #bbb",
      boxShadow: t ? "0 0 0 2px #1976d2" : "0 1px 4px #0002",
      background: "var(--fn-app-background)",
      display: "flex",
      flexDirection: "column",
      alignItems: "stretch",
      justifyContent: "flex-start",
      position: "relative",
      overflow: "hidden",
      transition: "border 0.2s, box-shadow 0.2s"
    },
    "fn-data-color-theme": e,
    children: [
      /* @__PURE__ */ x.jsx(
        "div",
        {
          style: {
            height: 10,
            background: "var(--fn-primary-color)",
            borderBottom: "1px solid var(--fn-neutral-element-border)"
          }
        }
      ),
      /* @__PURE__ */ x.jsxs("div", { style: { display: "flex", flex: 1 }, children: [
        /* @__PURE__ */ x.jsx(
          "div",
          {
            style: {
              width: 12,
              background: "var(--fn-surface-elevation-low, var(--fn-container-background))",
              borderRight: "1px solid var(--fn-neutral-element-border)"
            }
          }
        ),
        /* @__PURE__ */ x.jsx(
          "div",
          {
            style: {
              flex: 1,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              background: "var(--fn-container-background)"
            },
            children: /* @__PURE__ */ x.jsxs(
              "div",
              {
                style: {
                  width: 22,
                  height: 14,
                  borderRadius: "var(--fn-border-radius-xs, 4px)",
                  background: "var(--fn-node-background)",
                  border: "1px solid var(--fn-node-header-color)",
                  boxShadow: "0 1px 2px #0002",
                  display: "flex",
                  flexDirection: "column"
                },
                children: [
                  /* @__PURE__ */ x.jsx(
                    "div",
                    {
                      style: {
                        height: 5,
                        background: "var(--fn-node-header-color)",
                        borderTopLeftRadius: "var(--fn-border-radius-xs, 4px)",
                        borderTopRightRadius: "var(--fn-border-radius-xs, 4px)"
                      }
                    }
                  ),
                  /* @__PURE__ */ x.jsx(
                    "div",
                    {
                      style: {
                        flex: 1,
                        background: "transparent"
                      }
                    }
                  )
                ]
              }
            )
          }
        )
      ] }),
      /* @__PURE__ */ x.jsx(
        "span",
        {
          style: {
            position: "absolute",
            bottom: 2,
            right: 4,
            fontSize: 9,
            color: "var(--fn-text-color-neutral)",
            opacity: 0.7,
            textTransform: "capitalize",
            fontWeight: 600,
            pointerEvents: "none"
          },
          children: e
        }
      ),
      t && /* @__PURE__ */ x.jsx(
        "span",
        {
          style: {
            position: "absolute",
            top: 2,
            left: 6,
            fontSize: 14,
            color: "#1976d2",
            fontWeight: 900,
            pointerEvents: "none"
          },
          "aria-label": "Selected",
          children: ""
        }
      )
    ]
  }
), qse = () => {
  const { colorTheme: e, setColorTheme: t } = bN(), [n, r] = _.useState(null), [o, a] = _.useState(null), s = (c) => {
    c !== e && (a(e), t(c), r(c));
  }, u = (c) => {
    n === c && o && o !== c && t(o), r(null), a(null);
  };
  return /* @__PURE__ */ x.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "1em" }, children: [
    /* @__PURE__ */ x.jsx("div", { style: { marginBottom: 8, fontWeight: 500 }, children: "Theme:" }),
    /* @__PURE__ */ x.jsx("div", { style: {
      display: "grid",
      gridTemplateColumns: "repeat(auto-fill, minmax(80px, 1fr))",
      gap: 16,
      justifyItems: "center"
    }, children: P3.map((c) => /* @__PURE__ */ x.jsx(
      "button",
      {
        onClick: () => {
          t(c), r(null), a(null);
        },
        onMouseEnter: () => s(c),
        onMouseLeave: () => u(c),
        style: {
          background: "none",
          border: "none",
          padding: 0,
          cursor: "pointer",
          outline: "none",
          borderRadius: 8
        },
        "aria-label": `Select ${c} theme`,
        children: /* @__PURE__ */ x.jsx(
          Use,
          {
            theme: c,
            selected: e === c
          }
        )
      },
      c
    )) })
  ] });
}, Gse = () => {
  const [e, t] = _.useState(!1), n = () => {
    t(!0);
  };
  return /* @__PURE__ */ x.jsxs(x.Fragment, { children: [
    /* @__PURE__ */ x.jsxs(tw, { children: [
      /* @__PURE__ */ x.jsx(nw, { asChild: !0, children: /* @__PURE__ */ x.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ x.jsxs(Ji, { direction: "row", children: [
        "Settings ",
        /* @__PURE__ */ x.jsx(q1, { className: "m-x-s" })
      ] }) }) }),
      /* @__PURE__ */ x.jsx(rw, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ x.jsx(ow, { children: /* @__PURE__ */ x.jsx(
        Ko,
        {
          className: "headermenuitem",
          onClick: n,
          children: "Appearance"
        }
      ) }) })
    ] }),
    /* @__PURE__ */ x.jsx(
      ci,
      {
        open: e,
        setOpen: t,
        title: "Appearance",
        description: "Change the color theme.",
        closebutton: !0,
        children: /* @__PURE__ */ x.jsx(qse, {})
      }
    )
  ] });
}, Yse = ({
  ...e
}) => {
  const t = nt(), n = t.workerstate();
  return Object.keys(e).length > 0 && t.logger.debug("headerprops", e), /* @__PURE__ */ x.jsxs(Ji, { className: "funcnodesreactflowheader", direction: "row", wrap: !0, children: [
    /* @__PURE__ */ x.jsx(
      Ji,
      {
        className: "headerelement m-w-6",
        grow: {
          "": !0,
          m: !1
        },
        children: /* @__PURE__ */ x.jsx(Tae, {})
      }
    ),
    (e.showmenu || Mp) && /* @__PURE__ */ x.jsxs(Ji, { direction: "row", wrap: !0, children: [
      /* @__PURE__ */ x.jsx("div", { className: "headerelement", children: /* @__PURE__ */ x.jsx(Hse, {}) }),
      (t.worker && n.is_open || Mp) && /* @__PURE__ */ x.jsx("div", { className: "headerelement", children: /* @__PURE__ */ x.jsx(Vse, {}) }),
      /* @__PURE__ */ x.jsx("div", { className: "headerelement", children: /* @__PURE__ */ x.jsx(Gse, {}) })
    ] })
  ] });
}, KD = ({ item: e }) => {
  const { node: t } = Tn(), n = _.useCallback(() => {
    t?.add_node(e.node_id);
  }, [e.node_id, t]), r = _.useCallback(
    (o) => {
      o.detail === 2 && n();
    },
    [n]
  );
  return /* @__PURE__ */ x.jsx("div", { className: "libnodeentry", onClick: r, title: e.description, children: e.node_name || e.node_id });
}, ZD = (e, t) => {
  const n = e.nodes?.some(
    (o) => o.node_id.toLowerCase().includes(t.toLowerCase())
  ) ?? !1, r = e.subshelves?.some((o) => ZD(o, t)) ?? !1;
  return n || r;
}, iw = ({
  item: e,
  filter: t,
  parentkey: n
}) => {
  const [r, o] = _.useState(!1), a = () => o(!r), s = e.nodes?.filter(
    (c) => c.node_id.toLowerCase().includes(t.toLowerCase())
  ), u = r || t.length > 0;
  return ZD(e, t) ? /* @__PURE__ */ x.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ x.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: a,
        style: { cursor: "pointer" },
        title: e.description,
        children: [
          /* @__PURE__ */ x.jsx("div", { className: "shelftitle_text", children: e.name }),
          /* @__PURE__ */ x.jsx("div", { className: "expandicon " + (u ? "open" : "close"), children: /* @__PURE__ */ x.jsx(sf, {}) })
        ]
      }
    ),
    /* @__PURE__ */ x.jsx("div", { className: "libnodecontainer " + (u ? "open" : "close"), children: /* @__PURE__ */ x.jsxs("div", { className: "libnodecontainer_inner", children: [
      s && /* @__PURE__ */ x.jsx(x.Fragment, { children: s.map((c) => /* @__PURE__ */ x.jsx(KD, { item: c }, c.node_id)) }),
      e.subshelves && /* @__PURE__ */ x.jsx(x.Fragment, { children: e.subshelves.map((c) => /* @__PURE__ */ x.jsx(
        iw,
        {
          item: c,
          filter: t,
          parentkey: n + c.name
        },
        n + c.name
      )) })
    ] }) }),
    /* @__PURE__ */ x.jsx("hr", {})
  ] }) : /* @__PURE__ */ x.jsx(x.Fragment, {});
}, Wse = ({
  filter: e,
  setFilter: t
}) => /* @__PURE__ */ x.jsxs("div", { className: "libfilter", children: [
  /* @__PURE__ */ x.jsx(jV, { fontSize: "inherit" }),
  /* @__PURE__ */ x.jsx(
    "input",
    {
      type: "text",
      placeholder: "Filter",
      value: e,
      onChange: (n) => {
        t(n.target.value);
      }
    }
  ),
  e && /* @__PURE__ */ x.jsx(
    hm,
    {
      fontSize: "inherit",
      onClick: () => {
        t("");
      }
    }
  )
] }), Xse = ({
  children: e
}) => {
  const [t, n] = _.useState(""), r = nt(), [o, a] = _.useState(!0), [s, u] = _.useState(!0), [c, f] = _.useState(!0), [h, p] = _.useState({
    installed: [],
    available: [],
    active: []
  }), [g, y] = _.useState(!1), { lib: w } = Tn(), v = (z) => {
    z && (r.worker === void 0 || !r.worker.is_open || w?.get_available_modules().then((B) => {
      p(B);
    }));
  };
  if (!r.worker)
    return /* @__PURE__ */ x.jsx(x.Fragment, {});
  const S = _.useCallback(
    (z, B) => {
      y(!1), w?.add_lib(z.name, B);
    },
    [w]
  ), E = _.useCallback(
    (z, B) => {
      y(!1), w?.add_lib(z.name, B);
    },
    [w]
  ), T = _.useCallback(
    (z) => {
      y(!1), w?.remove_lib(z.name);
    },
    [w]
  ), k = _.useCallback(
    (z, B) => {
      y(!1), w?.add_lib(z.name, B);
    },
    [w]
  ), A = _.useCallback(
    (z) => z.filter(
      (B) => B.name.toLowerCase().includes(t.toLowerCase()) || B.description.toLowerCase().includes(t.toLowerCase())
    ),
    [t]
  ), M = A(h.available), N = A(h.installed), P = A(h.active);
  return /* @__PURE__ */ x.jsxs(
    ci,
    {
      title: "Manage Library",
      trigger: e,
      description: "Add or remove libraries to the current worker.",
      onOpenChange: v,
      open: g,
      setOpen: y,
      children: [
        /* @__PURE__ */ x.jsx(
          "input",
          {
            className: "filter-input styledinput",
            type: "text",
            placeholder: "Filter modules...",
            value: t,
            onChange: (z) => n(z.target.value)
          }
        ),
        /* @__PURE__ */ x.jsxs(
          "div",
          {
            className: "packagelist",
            style: { maxHeight: "70%", overflow: "auto" },
            children: [
              N.length > 0 && /* @__PURE__ */ x.jsx(
                "h3",
                {
                  onClick: () => {
                    f(!c);
                  },
                  children: "Installed"
                }
              ),
              c && N.map((z) => /* @__PURE__ */ x.jsx(
                wpe,
                {
                  availableModule: z,
                  on_add: S
                },
                z.name + z.source
              )),
              M.length > 0 && /* @__PURE__ */ x.jsx(
                "h3",
                {
                  onClick: () => {
                    u(!s);
                  },
                  children: "Available"
                }
              ),
              s && M.map((z) => /* @__PURE__ */ x.jsx(
                _pe,
                {
                  availableModule: z,
                  on_add: E
                },
                z.name + z.source
              )),
              P.length > 0 && /* @__PURE__ */ x.jsx(
                "h3",
                {
                  onClick: () => {
                    a(!o);
                  },
                  children: "Active"
                }
              ),
              o && P.map((z) => /* @__PURE__ */ x.jsx(
                xpe,
                {
                  availableModule: z,
                  on_remove: T,
                  on_update: k
                },
                z.name + z.source
              ))
            ]
          }
        )
      ]
    }
  );
}, aw = ({
  availableModule: e
}) => /* @__PURE__ */ x.jsxs("div", { className: "module-links", children: [
  e.homepage && /* @__PURE__ */ x.jsx(x.Fragment, { children: /* @__PURE__ */ x.jsx(
    "a",
    {
      href: e.homepage,
      target: "_blank",
      rel: "noopener noreferrer",
      children: "Homepage"
    }
  ) }),
  e.source && e.homepage && " | ",
  e.source && /* @__PURE__ */ x.jsx(x.Fragment, { children: /* @__PURE__ */ x.jsx(
    "a",
    {
      href: e.source,
      target: "_blank",
      rel: "noopener noreferrer",
      children: "Source"
    }
  ) })
] });
function Kse(e, t) {
  const n = {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const Zse = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, Qse = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, Jse = {};
function sR(e, t) {
  return (Jse.jsx ? Qse : Zse).test(e);
}
const ele = /[ \t\n\f\r]/g;
function tle(e) {
  return typeof e == "object" ? e.type === "text" ? lR(e.value) : !1 : lR(e);
}
function lR(e) {
  return e.replace(ele, "") === "";
}
class Cf {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(t, n, r) {
    this.normal = n, this.property = t, r && (this.space = r);
  }
}
Cf.prototype.normal = {};
Cf.prototype.property = {};
Cf.prototype.space = void 0;
function QD(e, t) {
  const n = {}, r = {};
  for (const o of e)
    Object.assign(n, o.property), Object.assign(r, o.normal);
  return new Cf(n, r, t);
}
function Xb(e) {
  return e.toLowerCase();
}
class Vn {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(t, n) {
    this.attribute = n, this.property = t;
  }
}
Vn.prototype.attribute = "";
Vn.prototype.booleanish = !1;
Vn.prototype.boolean = !1;
Vn.prototype.commaOrSpaceSeparated = !1;
Vn.prototype.commaSeparated = !1;
Vn.prototype.defined = !1;
Vn.prototype.mustUseProperty = !1;
Vn.prototype.number = !1;
Vn.prototype.overloadedBoolean = !1;
Vn.prototype.property = "";
Vn.prototype.spaceSeparated = !1;
Vn.prototype.space = void 0;
let nle = 0;
const Be = os(), Gt = os(), Kb = os(), me = os(), wt = os(), ml = os(), er = os();
function os() {
  return 2 ** ++nle;
}
const Zb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Be,
  booleanish: Gt,
  commaOrSpaceSeparated: er,
  commaSeparated: ml,
  number: me,
  overloadedBoolean: Kb,
  spaceSeparated: wt
}, Symbol.toStringTag, { value: "Module" })), bv = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(Zb)
);
class sw extends Vn {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(t, n, r, o) {
    let a = -1;
    if (super(t, n), uR(this, "space", o), typeof r == "number")
      for (; ++a < bv.length; ) {
        const s = bv[a];
        uR(this, bv[a], (r & Zb[s]) === Zb[s]);
      }
  }
}
sw.prototype.defined = !0;
function uR(e, t, n) {
  n && (e[t] = n);
}
function Vl(e) {
  const t = {}, n = {};
  for (const [r, o] of Object.entries(e.properties)) {
    const a = new sw(
      r,
      e.transform(e.attributes || {}, r),
      o,
      e.space
    );
    e.mustUseProperty && e.mustUseProperty.includes(r) && (a.mustUseProperty = !0), t[r] = a, n[Xb(r)] = r, n[Xb(a.attribute)] = r;
  }
  return new Cf(t, n, e.space);
}
const JD = Vl({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: Gt,
    ariaAutoComplete: null,
    ariaBusy: Gt,
    ariaChecked: Gt,
    ariaColCount: me,
    ariaColIndex: me,
    ariaColSpan: me,
    ariaControls: wt,
    ariaCurrent: null,
    ariaDescribedBy: wt,
    ariaDetails: null,
    ariaDisabled: Gt,
    ariaDropEffect: wt,
    ariaErrorMessage: null,
    ariaExpanded: Gt,
    ariaFlowTo: wt,
    ariaGrabbed: Gt,
    ariaHasPopup: null,
    ariaHidden: Gt,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: wt,
    ariaLevel: me,
    ariaLive: null,
    ariaModal: Gt,
    ariaMultiLine: Gt,
    ariaMultiSelectable: Gt,
    ariaOrientation: null,
    ariaOwns: wt,
    ariaPlaceholder: null,
    ariaPosInSet: me,
    ariaPressed: Gt,
    ariaReadOnly: Gt,
    ariaRelevant: null,
    ariaRequired: Gt,
    ariaRoleDescription: wt,
    ariaRowCount: me,
    ariaRowIndex: me,
    ariaRowSpan: me,
    ariaSelected: Gt,
    ariaSetSize: me,
    ariaSort: null,
    ariaValueMax: me,
    ariaValueMin: me,
    ariaValueNow: me,
    ariaValueText: null,
    role: null
  },
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  }
});
function eP(e, t) {
  return t in e ? e[t] : t;
}
function tP(e, t) {
  return eP(e, t.toLowerCase());
}
const rle = Vl({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: ml,
    acceptCharset: wt,
    accessKey: wt,
    action: null,
    allow: null,
    allowFullScreen: Be,
    allowPaymentRequest: Be,
    allowUserMedia: Be,
    alt: null,
    as: null,
    async: Be,
    autoCapitalize: null,
    autoComplete: wt,
    autoFocus: Be,
    autoPlay: Be,
    blocking: wt,
    capture: null,
    charSet: null,
    checked: Be,
    cite: null,
    className: wt,
    cols: me,
    colSpan: null,
    content: null,
    contentEditable: Gt,
    controls: Be,
    controlsList: wt,
    coords: me | ml,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Be,
    defer: Be,
    dir: null,
    dirName: null,
    disabled: Be,
    download: Kb,
    draggable: Gt,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Be,
    formTarget: null,
    headers: wt,
    height: me,
    hidden: Kb,
    high: me,
    href: null,
    hrefLang: null,
    htmlFor: wt,
    httpEquiv: wt,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: Be,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Be,
    itemId: null,
    itemProp: wt,
    itemRef: wt,
    itemScope: Be,
    itemType: wt,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Be,
    low: me,
    manifest: null,
    max: null,
    maxLength: me,
    media: null,
    method: null,
    min: null,
    minLength: me,
    multiple: Be,
    muted: Be,
    name: null,
    nonce: null,
    noModule: Be,
    noValidate: Be,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Be,
    optimum: me,
    pattern: null,
    ping: wt,
    placeholder: null,
    playsInline: Be,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: Be,
    referrerPolicy: null,
    rel: wt,
    required: Be,
    reversed: Be,
    rows: me,
    rowSpan: me,
    sandbox: wt,
    scope: null,
    scoped: Be,
    seamless: Be,
    selected: Be,
    shadowRootClonable: Be,
    shadowRootDelegatesFocus: Be,
    shadowRootMode: null,
    shape: null,
    size: me,
    sizes: null,
    slot: null,
    span: me,
    spellCheck: Gt,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: me,
    step: null,
    style: null,
    tabIndex: me,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Be,
    useMap: null,
    value: Gt,
    width: me,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: wt,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: me,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: me,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Be,
    // Lists. Use CSS to reduce space between items instead
    declare: Be,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: me,
    // `<img>` and `<object>`
    leftMargin: me,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: me,
    // `<body>`
    marginWidth: me,
    // `<body>`
    noResize: Be,
    // `<frame>`
    noHref: Be,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Be,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Be,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: me,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: Gt,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: me,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: me,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Be,
    disableRemotePlayback: Be,
    prefix: null,
    property: null,
    results: me,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: tP
}), ole = Vl({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: er,
    accentHeight: me,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: me,
    amplitude: me,
    arabicForm: null,
    ascent: me,
    attributeName: null,
    attributeType: null,
    azimuth: me,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: me,
    by: null,
    calcMode: null,
    capHeight: me,
    className: wt,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: me,
    diffuseConstant: me,
    direction: null,
    display: null,
    dur: null,
    divisor: me,
    dominantBaseline: null,
    download: Be,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: me,
    enableBackground: null,
    end: null,
    event: null,
    exponent: me,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: me,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: ml,
    g2: ml,
    glyphName: ml,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: me,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: me,
    horizOriginX: me,
    horizOriginY: me,
    id: null,
    ideographic: me,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: me,
    k: me,
    k1: me,
    k2: me,
    k3: me,
    k4: me,
    kernelMatrix: er,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: me,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: me,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: me,
    overlineThickness: me,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: me,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: wt,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: me,
    pointsAtY: me,
    pointsAtZ: me,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: er,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: er,
    rev: er,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: er,
    requiredFeatures: er,
    requiredFonts: er,
    requiredFormats: er,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: me,
    specularExponent: me,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: me,
    strikethroughThickness: me,
    string: null,
    stroke: null,
    strokeDashArray: er,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: me,
    strokeOpacity: me,
    strokeWidth: null,
    style: null,
    surfaceScale: me,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: er,
    tabIndex: me,
    tableValues: null,
    target: null,
    targetX: me,
    targetY: me,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: er,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: me,
    underlineThickness: me,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: me,
    values: null,
    vAlphabetic: me,
    vMathematical: me,
    vectorEffect: null,
    vHanging: me,
    vIdeographic: me,
    version: null,
    vertAdvY: me,
    vertOriginX: me,
    vertOriginY: me,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: me,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: eP
}), nP = Vl({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  }
}), rP = Vl({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: tP
}), oP = Vl({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  }
}), ile = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, ale = /[A-Z]/g, cR = /-[a-z]/g, sle = /^data[-\w.:]+$/i;
function lle(e, t) {
  const n = Xb(t);
  let r = t, o = Vn;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && sle.test(t)) {
    if (t.charAt(4) === "-") {
      const a = t.slice(5).replace(cR, cle);
      r = "data" + a.charAt(0).toUpperCase() + a.slice(1);
    } else {
      const a = t.slice(4);
      if (!cR.test(a)) {
        let s = a.replace(ale, ule);
        s.charAt(0) !== "-" && (s = "-" + s), t = "data" + s;
      }
    }
    o = sw;
  }
  return new o(r, t);
}
function ule(e) {
  return "-" + e.toLowerCase();
}
function cle(e) {
  return e.charAt(1).toUpperCase();
}
const fle = QD([JD, rle, nP, rP, oP], "html"), lw = QD([JD, ole, nP, rP, oP], "svg");
function dle(e) {
  return e.join(" ").trim();
}
var Qs = {}, xv, fR;
function hle() {
  if (fR) return xv;
  fR = 1;
  var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, t = /\n/g, n = /^\s*/, r = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, o = /^:\s*/, a = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, s = /^[;\s]*/, u = /^\s+|\s+$/g, c = `
`, f = "/", h = "*", p = "", g = "comment", y = "declaration";
  xv = function(v, S) {
    if (typeof v != "string")
      throw new TypeError("First argument must be a string");
    if (!v) return [];
    S = S || {};
    var E = 1, T = 1;
    function k(W) {
      var j = W.match(t);
      j && (E += j.length);
      var V = W.lastIndexOf(c);
      T = ~V ? W.length - V : T + W.length;
    }
    function A() {
      var W = { line: E, column: T };
      return function(j) {
        return j.position = new M(W), z(), j;
      };
    }
    function M(W) {
      this.start = W, this.end = { line: E, column: T }, this.source = S.source;
    }
    M.prototype.content = v;
    function N(W) {
      var j = new Error(
        S.source + ":" + E + ":" + T + ": " + W
      );
      if (j.reason = W, j.filename = S.source, j.line = E, j.column = T, j.source = v, !S.silent) throw j;
    }
    function P(W) {
      var j = W.exec(v);
      if (j) {
        var V = j[0];
        return k(V), v = v.slice(V.length), j;
      }
    }
    function z() {
      P(n);
    }
    function B(W) {
      var j;
      for (W = W || []; j = R(); )
        j !== !1 && W.push(j);
      return W;
    }
    function R() {
      var W = A();
      if (!(f != v.charAt(0) || h != v.charAt(1))) {
        for (var j = 2; p != v.charAt(j) && (h != v.charAt(j) || f != v.charAt(j + 1)); )
          ++j;
        if (j += 2, p === v.charAt(j - 1))
          return N("End of comment missing");
        var V = v.slice(2, j - 2);
        return T += 2, k(V), v = v.slice(j), T += 2, W({
          type: g,
          comment: V
        });
      }
    }
    function F() {
      var W = A(), j = P(r);
      if (j) {
        if (R(), !P(o)) return N("property missing ':'");
        var V = P(a), I = W({
          type: y,
          property: w(j[0].replace(e, p)),
          value: V ? w(V[0].replace(e, p)) : p
        });
        return P(s), I;
      }
    }
    function U() {
      var W = [];
      B(W);
      for (var j; j = F(); )
        j !== !1 && (W.push(j), B(W));
      return W;
    }
    return z(), U();
  };
  function w(v) {
    return v ? v.replace(u, p) : p;
  }
  return xv;
}
var dR;
function ple() {
  if (dR) return Qs;
  dR = 1;
  var e = Qs && Qs.__importDefault || function(r) {
    return r && r.__esModule ? r : { default: r };
  };
  Object.defineProperty(Qs, "__esModule", { value: !0 }), Qs.default = n;
  var t = e(hle());
  function n(r, o) {
    var a = null;
    if (!r || typeof r != "string")
      return a;
    var s = (0, t.default)(r), u = typeof o == "function";
    return s.forEach(function(c) {
      if (c.type === "declaration") {
        var f = c.property, h = c.value;
        u ? o(f, h, c) : h && (a = a || {}, a[f] = h);
      }
    }), a;
  }
  return Qs;
}
var ic = {}, hR;
function mle() {
  if (hR) return ic;
  hR = 1, Object.defineProperty(ic, "__esModule", { value: !0 }), ic.camelCase = void 0;
  var e = /^--[a-zA-Z0-9_-]+$/, t = /-([a-z])/g, n = /^[^-]+$/, r = /^-(webkit|moz|ms|o|khtml)-/, o = /^-(ms)-/, a = function(f) {
    return !f || n.test(f) || e.test(f);
  }, s = function(f, h) {
    return h.toUpperCase();
  }, u = function(f, h) {
    return "".concat(h, "-");
  }, c = function(f, h) {
    return h === void 0 && (h = {}), a(f) ? f : (f = f.toLowerCase(), h.reactCompat ? f = f.replace(o, u) : f = f.replace(r, u), f.replace(t, s));
  };
  return ic.camelCase = c, ic;
}
var ac, pR;
function gle() {
  if (pR) return ac;
  pR = 1;
  var e = ac && ac.__importDefault || function(o) {
    return o && o.__esModule ? o : { default: o };
  }, t = e(ple()), n = mle();
  function r(o, a) {
    var s = {};
    return !o || typeof o != "string" || (0, t.default)(o, function(u, c) {
      u && c && (s[(0, n.camelCase)(u, a)] = c);
    }), s;
  }
  return r.default = r, ac = r, ac;
}
var yle = gle();
const vle = /* @__PURE__ */ Nl(yle), iP = aP("end"), uw = aP("start");
function aP(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function ble(e) {
  const t = uw(e), n = iP(e);
  if (t && n)
    return { start: t, end: n };
}
function Sc(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? mR(e.position) : "start" in e || "end" in e ? mR(e) : "line" in e || "column" in e ? Qb(e) : "";
}
function Qb(e) {
  return gR(e && e.line) + ":" + gR(e && e.column);
}
function mR(e) {
  return Qb(e && e.start) + "-" + Qb(e && e.end);
}
function gR(e) {
  return e && typeof e == "number" ? e : 1;
}
class xn extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let o = "", a = {}, s = !1;
    if (n && ("line" in n && "column" in n ? a = { place: n } : "start" in n && "end" in n ? a = { place: n } : "type" in n ? a = {
      ancestors: [n],
      place: n.position
    } : a = { ...n }), typeof t == "string" ? o = t : !a.cause && t && (s = !0, o = t.message, a.cause = t), !a.ruleId && !a.source && typeof r == "string") {
      const c = r.indexOf(":");
      c === -1 ? a.ruleId = r : (a.source = r.slice(0, c), a.ruleId = r.slice(c + 1));
    }
    if (!a.place && a.ancestors && a.ancestors) {
      const c = a.ancestors[a.ancestors.length - 1];
      c && (a.place = c.position);
    }
    const u = a.place && "start" in a.place ? a.place.start : a.place;
    this.ancestors = a.ancestors || void 0, this.cause = a.cause || void 0, this.column = u ? u.column : void 0, this.fatal = void 0, this.file, this.message = o, this.line = u ? u.line : void 0, this.name = Sc(a.place) || "1:1", this.place = a.place || void 0, this.reason = this.message, this.ruleId = a.ruleId || void 0, this.source = a.source || void 0, this.stack = s && a.cause && typeof a.cause.stack == "string" ? a.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
xn.prototype.file = "";
xn.prototype.name = "";
xn.prototype.reason = "";
xn.prototype.message = "";
xn.prototype.stack = "";
xn.prototype.column = void 0;
xn.prototype.line = void 0;
xn.prototype.ancestors = void 0;
xn.prototype.cause = void 0;
xn.prototype.fatal = void 0;
xn.prototype.place = void 0;
xn.prototype.ruleId = void 0;
xn.prototype.source = void 0;
const cw = {}.hasOwnProperty, xle = /* @__PURE__ */ new Map(), wle = /[A-Z]/g, _le = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), Sle = /* @__PURE__ */ new Set(["td", "th"]), sP = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function Ele(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = Nle(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = Ole(n, t.jsx, t.jsxs);
  }
  const o = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? lw : fle,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, a = lP(o, e, void 0);
  return a && typeof a != "string" ? a : o.create(
    e,
    o.Fragment,
    { children: a || void 0 },
    void 0
  );
}
function lP(e, t, n) {
  if (t.type === "element")
    return Cle(e, t, n);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return kle(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return Ale(e, t, n);
  if (t.type === "mdxjsEsm")
    return Tle(e, t);
  if (t.type === "root")
    return Rle(e, t, n);
  if (t.type === "text")
    return Mle(e, t);
}
function Cle(e, t, n) {
  const r = e.schema;
  let o = r;
  t.tagName.toLowerCase() === "svg" && r.space === "html" && (o = lw, e.schema = o), e.ancestors.push(t);
  const a = cP(e, t.tagName, !1), s = Dle(e, t);
  let u = dw(e, t);
  return _le.has(t.tagName) && (u = u.filter(function(c) {
    return typeof c == "string" ? !tle(c) : !0;
  })), uP(e, s, a, t), fw(s, u), e.ancestors.pop(), e.schema = r, e.create(t, a, s, n);
}
function kle(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const r = t.data.estree.body[0];
    return r.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(r.expression);
  }
  Kc(e, t.position);
}
function Tle(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  Kc(e, t.position);
}
function Ale(e, t, n) {
  const r = e.schema;
  let o = r;
  t.name === "svg" && r.space === "html" && (o = lw, e.schema = o), e.ancestors.push(t);
  const a = t.name === null ? e.Fragment : cP(e, t.name, !0), s = Ple(e, t), u = dw(e, t);
  return uP(e, s, a, t), fw(s, u), e.ancestors.pop(), e.schema = r, e.create(t, a, s, n);
}
function Rle(e, t, n) {
  const r = {};
  return fw(r, dw(e, t)), e.create(t, e.Fragment, r, n);
}
function Mle(e, t) {
  return t.value;
}
function uP(e, t, n, r) {
  typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
}
function fw(e, t) {
  if (t.length > 0) {
    const n = t.length > 1 ? t : t[0];
    n && (e.children = n);
  }
}
function Ole(e, t, n) {
  return r;
  function r(o, a, s, u) {
    const f = Array.isArray(s.children) ? n : t;
    return u ? f(a, s, u) : f(a, s);
  }
}
function Nle(e, t) {
  return n;
  function n(r, o, a, s) {
    const u = Array.isArray(a.children), c = uw(r);
    return t(
      o,
      a,
      s,
      u,
      {
        columnNumber: c ? c.column - 1 : void 0,
        fileName: e,
        lineNumber: c ? c.line : void 0
      },
      void 0
    );
  }
}
function Dle(e, t) {
  const n = {};
  let r, o;
  for (o in t.properties)
    if (o !== "children" && cw.call(t.properties, o)) {
      const a = jle(e, o, t.properties[o]);
      if (a) {
        const [s, u] = a;
        e.tableCellAlignToStyle && s === "align" && typeof u == "string" && Sle.has(t.tagName) ? r = u : n[s] = u;
      }
    }
  if (r) {
    const a = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    a[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n;
}
function Ple(e, t) {
  const n = {};
  for (const r of t.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && e.evaluater) {
        const a = r.data.estree.body[0];
        a.type;
        const s = a.expression;
        s.type;
        const u = s.properties[0];
        u.type, Object.assign(
          n,
          e.evaluater.evaluateExpression(u.argument)
        );
      } else
        Kc(e, t.position);
    else {
      const o = r.name;
      let a;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && e.evaluater) {
          const u = r.value.data.estree.body[0];
          u.type, a = e.evaluater.evaluateExpression(u.expression);
        } else
          Kc(e, t.position);
      else
        a = r.value === null ? !0 : r.value;
      n[o] = /** @type {Props[keyof Props]} */
      a;
    }
  return n;
}
function dw(e, t) {
  const n = [];
  let r = -1;
  const o = e.passKeys ? /* @__PURE__ */ new Map() : xle;
  for (; ++r < t.children.length; ) {
    const a = t.children[r];
    let s;
    if (e.passKeys) {
      const c = a.type === "element" ? a.tagName : a.type === "mdxJsxFlowElement" || a.type === "mdxJsxTextElement" ? a.name : void 0;
      if (c) {
        const f = o.get(c) || 0;
        s = c + "-" + f, o.set(c, f + 1);
      }
    }
    const u = lP(e, a, s);
    u !== void 0 && n.push(u);
  }
  return n;
}
function jle(e, t, n) {
  const r = lle(e.schema, t);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r.commaSeparated ? Kse(n) : dle(n)), r.property === "style") {
      let o = typeof n == "object" ? n : Ile(e, String(n));
      return e.stylePropertyNameCase === "css" && (o = zle(o)), ["style", o];
    }
    return [
      e.elementAttributeNameCase === "react" && r.space ? ile[r.property] || r.property : r.attribute,
      n
    ];
  }
}
function Ile(e, t) {
  try {
    return vle(t, { reactCompat: !0 });
  } catch (n) {
    if (e.ignoreInvalidStyle)
      return {};
    const r = (
      /** @type {Error} */
      n
    ), o = new xn("Cannot parse `style` attribute", {
      ancestors: e.ancestors,
      cause: r,
      ruleId: "style",
      source: "hast-util-to-jsx-runtime"
    });
    throw o.file = e.filePath || void 0, o.url = sP + "#cannot-parse-style-attribute", o;
  }
}
function cP(e, t, n) {
  let r;
  if (!n)
    r = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const o = t.split(".");
    let a = -1, s;
    for (; ++a < o.length; ) {
      const u = sR(o[a]) ? { type: "Identifier", name: o[a] } : { type: "Literal", value: o[a] };
      s = s ? {
        type: "MemberExpression",
        object: s,
        property: u,
        computed: !!(a && u.type === "Literal"),
        optional: !1
      } : u;
    }
    r = s;
  } else
    r = sR(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (r.type === "Literal") {
    const o = (
      /** @type {string | number} */
      r.value
    );
    return cw.call(e.components, o) ? e.components[o] : o;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(r);
  Kc(e);
}
function Kc(e, t) {
  const n = new xn(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = e.filePath || void 0, n.url = sP + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function zle(e) {
  const t = {};
  let n;
  for (n in e)
    cw.call(e, n) && (t[Lle(n)] = e[n]);
  return t;
}
function Lle(e) {
  let t = e.replace(wle, Fle);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function Fle(e) {
  return "-" + e.toLowerCase();
}
const wv = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, $le = {};
function hw(e, t) {
  const n = $le, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, o = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return fP(e, r, o);
}
function fP(e, t, n) {
  if (Ble(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return yR(e.children, t, n);
  }
  return Array.isArray(e) ? yR(e, t, n) : "";
}
function yR(e, t, n) {
  const r = [];
  let o = -1;
  for (; ++o < e.length; )
    r[o] = fP(e[o], t, n);
  return r.join("");
}
function Ble(e) {
  return !!(e && typeof e == "object");
}
const vR = document.createElement("i");
function pw(e) {
  const t = "&" + e + ";";
  vR.innerHTML = t;
  const n = vR.textContent;
  return (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n
  );
}
function sr(e, t, n, r) {
  const o = e.length;
  let a = 0, s;
  if (t < 0 ? t = -t > o ? 0 : o + t : t = t > o ? o : t, n = n > 0 ? n : 0, r.length < 1e4)
    s = Array.from(r), s.unshift(t, n), e.splice(...s);
  else
    for (n && e.splice(t, n); a < r.length; )
      s = r.slice(a, a + 1e4), s.unshift(t, 0), e.splice(...s), a += 1e4, t += 1e4;
}
function Sr(e, t) {
  return e.length > 0 ? (sr(e, e.length, 0, t), e) : t;
}
const bR = {}.hasOwnProperty;
function dP(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    Hle(t, e[n]);
  return t;
}
function Hle(e, t) {
  let n;
  for (n in t) {
    const o = (bR.call(e, n) ? e[n] : void 0) || (e[n] = {}), a = t[n];
    let s;
    if (a)
      for (s in a) {
        bR.call(o, s) || (o[s] = []);
        const u = a[s];
        Vle(
          // @ts-expect-error Looks like a list.
          o[s],
          Array.isArray(u) ? u : u ? [u] : []
        );
      }
  }
}
function Vle(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  sr(e, 0, 0, r);
}
function hP(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "" : String.fromCodePoint(n)
  );
}
function zr(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const Cn = ua(/[A-Za-z]/), vn = ua(/[\dA-Za-z]/), Ule = ua(/[#-'*+\--9=?A-Z^-~]/);
function Dp(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const Jb = ua(/\d/), qle = ua(/[\dA-Fa-f]/), Gle = ua(/[!-/:-@[-`{-~]/);
function Oe(e) {
  return e !== null && e < -2;
}
function vt(e) {
  return e !== null && (e < 0 || e === 32);
}
function We(e) {
  return e === -2 || e === -1 || e === 32;
}
const Km = ua(/\p{P}|\p{S}/u), Ja = ua(/\s/);
function ua(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function Ul(e) {
  const t = [];
  let n = -1, r = 0, o = 0;
  for (; ++n < e.length; ) {
    const a = e.charCodeAt(n);
    let s = "";
    if (a === 37 && vn(e.charCodeAt(n + 1)) && vn(e.charCodeAt(n + 2)))
      o = 2;
    else if (a < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(a)) || (s = String.fromCharCode(a));
    else if (a > 55295 && a < 57344) {
      const u = e.charCodeAt(n + 1);
      a < 56320 && u > 56319 && u < 57344 ? (s = String.fromCharCode(a, u), o = 1) : s = "";
    } else
      s = String.fromCharCode(a);
    s && (t.push(e.slice(r, n), encodeURIComponent(s)), r = n + o + 1, s = ""), o && (n += o, o = 0);
  }
  return t.join("") + e.slice(r);
}
function Qe(e, t, n, r) {
  const o = r ? r - 1 : Number.POSITIVE_INFINITY;
  let a = 0;
  return s;
  function s(c) {
    return We(c) ? (e.enter(n), u(c)) : t(c);
  }
  function u(c) {
    return We(c) && a++ < o ? (e.consume(c), u) : (e.exit(n), t(c));
  }
}
const Yle = {
  tokenize: Wle
};
function Wle(e) {
  const t = e.attempt(this.parser.constructs.contentInitial, r, o);
  let n;
  return t;
  function r(u) {
    if (u === null) {
      e.consume(u);
      return;
    }
    return e.enter("lineEnding"), e.consume(u), e.exit("lineEnding"), Qe(e, t, "linePrefix");
  }
  function o(u) {
    return e.enter("paragraph"), a(u);
  }
  function a(u) {
    const c = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = c), n = c, s(u);
  }
  function s(u) {
    if (u === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(u);
      return;
    }
    return Oe(u) ? (e.consume(u), e.exit("chunkText"), a) : (e.consume(u), s);
  }
}
const Xle = {
  tokenize: Kle
}, xR = {
  tokenize: Zle
};
function Kle(e) {
  const t = this, n = [];
  let r = 0, o, a, s;
  return u;
  function u(k) {
    if (r < n.length) {
      const A = n[r];
      return t.containerState = A[1], e.attempt(A[0].continuation, c, f)(k);
    }
    return f(k);
  }
  function c(k) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, o && T();
      const A = t.events.length;
      let M = A, N;
      for (; M--; )
        if (t.events[M][0] === "exit" && t.events[M][1].type === "chunkFlow") {
          N = t.events[M][1].end;
          break;
        }
      E(r);
      let P = A;
      for (; P < t.events.length; )
        t.events[P][1].end = {
          ...N
        }, P++;
      return sr(t.events, M + 1, 0, t.events.slice(A)), t.events.length = P, f(k);
    }
    return u(k);
  }
  function f(k) {
    if (r === n.length) {
      if (!o)
        return g(k);
      if (o.currentConstruct && o.currentConstruct.concrete)
        return w(k);
      t.interrupt = !!(o.currentConstruct && !o._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(xR, h, p)(k);
  }
  function h(k) {
    return o && T(), E(r), g(k);
  }
  function p(k) {
    return t.parser.lazy[t.now().line] = r !== n.length, s = t.now().offset, w(k);
  }
  function g(k) {
    return t.containerState = {}, e.attempt(xR, y, w)(k);
  }
  function y(k) {
    return r++, n.push([t.currentConstruct, t.containerState]), g(k);
  }
  function w(k) {
    if (k === null) {
      o && T(), E(0), e.consume(k);
      return;
    }
    return o = o || t.parser.flow(t.now()), e.enter("chunkFlow", {
      _tokenizer: o,
      contentType: "flow",
      previous: a
    }), v(k);
  }
  function v(k) {
    if (k === null) {
      S(e.exit("chunkFlow"), !0), E(0), e.consume(k);
      return;
    }
    return Oe(k) ? (e.consume(k), S(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, u) : (e.consume(k), v);
  }
  function S(k, A) {
    const M = t.sliceStream(k);
    if (A && M.push(null), k.previous = a, a && (a.next = k), a = k, o.defineSkip(k.start), o.write(M), t.parser.lazy[k.start.line]) {
      let N = o.events.length;
      for (; N--; )
        if (
          // The token starts before the line ending
          o.events[N][1].start.offset < s && // and either is not ended yet
          (!o.events[N][1].end || // or ends after it.
          o.events[N][1].end.offset > s)
        )
          return;
      const P = t.events.length;
      let z = P, B, R;
      for (; z--; )
        if (t.events[z][0] === "exit" && t.events[z][1].type === "chunkFlow") {
          if (B) {
            R = t.events[z][1].end;
            break;
          }
          B = !0;
        }
      for (E(r), N = P; N < t.events.length; )
        t.events[N][1].end = {
          ...R
        }, N++;
      sr(t.events, z + 1, 0, t.events.slice(P)), t.events.length = N;
    }
  }
  function E(k) {
    let A = n.length;
    for (; A-- > k; ) {
      const M = n[A];
      t.containerState = M[1], M[0].exit.call(t, e);
    }
    n.length = k;
  }
  function T() {
    o.write([null]), a = void 0, o = void 0, t.containerState._closeFlow = void 0;
  }
}
function Zle(e, t, n) {
  return Qe(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function Ol(e) {
  if (e === null || vt(e) || Ja(e))
    return 1;
  if (Km(e))
    return 2;
}
function Zm(e, t, n) {
  const r = [];
  let o = -1;
  for (; ++o < e.length; ) {
    const a = e[o].resolveAll;
    a && !r.includes(a) && (t = a(t, n), r.push(a));
  }
  return t;
}
const e1 = {
  name: "attention",
  resolveAll: Qle,
  tokenize: Jle
};
function Qle(e, t) {
  let n = -1, r, o, a, s, u, c, f, h;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          c = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const p = {
            ...e[r][1].end
          }, g = {
            ...e[n][1].start
          };
          wR(p, -c), wR(g, c), s = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: p,
            end: {
              ...e[r][1].end
            }
          }, u = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...e[n][1].start
            },
            end: g
          }, a = {
            type: c > 1 ? "strongText" : "emphasisText",
            start: {
              ...e[r][1].end
            },
            end: {
              ...e[n][1].start
            }
          }, o = {
            type: c > 1 ? "strong" : "emphasis",
            start: {
              ...s.start
            },
            end: {
              ...u.end
            }
          }, e[r][1].end = {
            ...s.start
          }, e[n][1].start = {
            ...u.end
          }, f = [], e[r][1].end.offset - e[r][1].start.offset && (f = Sr(f, [["enter", e[r][1], t], ["exit", e[r][1], t]])), f = Sr(f, [["enter", o, t], ["enter", s, t], ["exit", s, t], ["enter", a, t]]), f = Sr(f, Zm(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), f = Sr(f, [["exit", a, t], ["enter", u, t], ["exit", u, t], ["exit", o, t]]), e[n][1].end.offset - e[n][1].start.offset ? (h = 2, f = Sr(f, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : h = 0, sr(e, r - 1, n - r + 3, f), n = r + f.length - h - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function Jle(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, o = Ol(r);
  let a;
  return s;
  function s(c) {
    return a = c, e.enter("attentionSequence"), u(c);
  }
  function u(c) {
    if (c === a)
      return e.consume(c), u;
    const f = e.exit("attentionSequence"), h = Ol(c), p = !h || h === 2 && o || n.includes(c), g = !o || o === 2 && h || n.includes(r);
    return f._open = !!(a === 42 ? p : p && (o || !g)), f._close = !!(a === 42 ? g : g && (h || !p)), t(c);
  }
}
function wR(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const eue = {
  name: "autolink",
  tokenize: tue
};
function tue(e, t, n) {
  let r = 0;
  return o;
  function o(y) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), a;
  }
  function a(y) {
    return Cn(y) ? (e.consume(y), s) : y === 64 ? n(y) : f(y);
  }
  function s(y) {
    return y === 43 || y === 45 || y === 46 || vn(y) ? (r = 1, u(y)) : f(y);
  }
  function u(y) {
    return y === 58 ? (e.consume(y), r = 0, c) : (y === 43 || y === 45 || y === 46 || vn(y)) && r++ < 32 ? (e.consume(y), u) : (r = 0, f(y));
  }
  function c(y) {
    return y === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.exit("autolink"), t) : y === null || y === 32 || y === 60 || Dp(y) ? n(y) : (e.consume(y), c);
  }
  function f(y) {
    return y === 64 ? (e.consume(y), h) : Ule(y) ? (e.consume(y), f) : n(y);
  }
  function h(y) {
    return vn(y) ? p(y) : n(y);
  }
  function p(y) {
    return y === 46 ? (e.consume(y), r = 0, h) : y === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.exit("autolink"), t) : g(y);
  }
  function g(y) {
    if ((y === 45 || vn(y)) && r++ < 63) {
      const w = y === 45 ? g : p;
      return e.consume(y), w;
    }
    return n(y);
  }
}
const kf = {
  partial: !0,
  tokenize: nue
};
function nue(e, t, n) {
  return r;
  function r(a) {
    return We(a) ? Qe(e, o, "linePrefix")(a) : o(a);
  }
  function o(a) {
    return a === null || Oe(a) ? t(a) : n(a);
  }
}
const pP = {
  continuation: {
    tokenize: oue
  },
  exit: iue,
  name: "blockQuote",
  tokenize: rue
};
function rue(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    if (s === 62) {
      const u = r.containerState;
      return u.open || (e.enter("blockQuote", {
        _container: !0
      }), u.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(s), e.exit("blockQuoteMarker"), a;
    }
    return n(s);
  }
  function a(s) {
    return We(s) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(s), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(s));
  }
}
function oue(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return We(s) ? Qe(e, a, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s) : a(s);
  }
  function a(s) {
    return e.attempt(pP, t, n)(s);
  }
}
function iue(e) {
  e.exit("blockQuote");
}
const mP = {
  name: "characterEscape",
  tokenize: aue
};
function aue(e, t, n) {
  return r;
  function r(a) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(a), e.exit("escapeMarker"), o;
  }
  function o(a) {
    return Gle(a) ? (e.enter("characterEscapeValue"), e.consume(a), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(a);
  }
}
const gP = {
  name: "characterReference",
  tokenize: sue
};
function sue(e, t, n) {
  const r = this;
  let o = 0, a, s;
  return u;
  function u(p) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(p), e.exit("characterReferenceMarker"), c;
  }
  function c(p) {
    return p === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(p), e.exit("characterReferenceMarkerNumeric"), f) : (e.enter("characterReferenceValue"), a = 31, s = vn, h(p));
  }
  function f(p) {
    return p === 88 || p === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(p), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), a = 6, s = qle, h) : (e.enter("characterReferenceValue"), a = 7, s = Jb, h(p));
  }
  function h(p) {
    if (p === 59 && o) {
      const g = e.exit("characterReferenceValue");
      return s === vn && !pw(r.sliceSerialize(g)) ? n(p) : (e.enter("characterReferenceMarker"), e.consume(p), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return s(p) && o++ < a ? (e.consume(p), h) : n(p);
  }
}
const _R = {
  partial: !0,
  tokenize: uue
}, SR = {
  concrete: !0,
  name: "codeFenced",
  tokenize: lue
};
function lue(e, t, n) {
  const r = this, o = {
    partial: !0,
    tokenize: M
  };
  let a = 0, s = 0, u;
  return c;
  function c(N) {
    return f(N);
  }
  function f(N) {
    const P = r.events[r.events.length - 1];
    return a = P && P[1].type === "linePrefix" ? P[2].sliceSerialize(P[1], !0).length : 0, u = N, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), h(N);
  }
  function h(N) {
    return N === u ? (s++, e.consume(N), h) : s < 3 ? n(N) : (e.exit("codeFencedFenceSequence"), We(N) ? Qe(e, p, "whitespace")(N) : p(N));
  }
  function p(N) {
    return N === null || Oe(N) ? (e.exit("codeFencedFence"), r.interrupt ? t(N) : e.check(_R, v, A)(N)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), g(N));
  }
  function g(N) {
    return N === null || Oe(N) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), p(N)) : We(N) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), Qe(e, y, "whitespace")(N)) : N === 96 && N === u ? n(N) : (e.consume(N), g);
  }
  function y(N) {
    return N === null || Oe(N) ? p(N) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), w(N));
  }
  function w(N) {
    return N === null || Oe(N) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), p(N)) : N === 96 && N === u ? n(N) : (e.consume(N), w);
  }
  function v(N) {
    return e.attempt(o, A, S)(N);
  }
  function S(N) {
    return e.enter("lineEnding"), e.consume(N), e.exit("lineEnding"), E;
  }
  function E(N) {
    return a > 0 && We(N) ? Qe(e, T, "linePrefix", a + 1)(N) : T(N);
  }
  function T(N) {
    return N === null || Oe(N) ? e.check(_R, v, A)(N) : (e.enter("codeFlowValue"), k(N));
  }
  function k(N) {
    return N === null || Oe(N) ? (e.exit("codeFlowValue"), T(N)) : (e.consume(N), k);
  }
  function A(N) {
    return e.exit("codeFenced"), t(N);
  }
  function M(N, P, z) {
    let B = 0;
    return R;
    function R(V) {
      return N.enter("lineEnding"), N.consume(V), N.exit("lineEnding"), F;
    }
    function F(V) {
      return N.enter("codeFencedFence"), We(V) ? Qe(N, U, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(V) : U(V);
    }
    function U(V) {
      return V === u ? (N.enter("codeFencedFenceSequence"), W(V)) : z(V);
    }
    function W(V) {
      return V === u ? (B++, N.consume(V), W) : B >= s ? (N.exit("codeFencedFenceSequence"), We(V) ? Qe(N, j, "whitespace")(V) : j(V)) : z(V);
    }
    function j(V) {
      return V === null || Oe(V) ? (N.exit("codeFencedFence"), P(V)) : z(V);
    }
  }
}
function uue(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return s === null ? n(s) : (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), a);
  }
  function a(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
const _v = {
  name: "codeIndented",
  tokenize: fue
}, cue = {
  partial: !0,
  tokenize: due
};
function fue(e, t, n) {
  const r = this;
  return o;
  function o(f) {
    return e.enter("codeIndented"), Qe(e, a, "linePrefix", 5)(f);
  }
  function a(f) {
    const h = r.events[r.events.length - 1];
    return h && h[1].type === "linePrefix" && h[2].sliceSerialize(h[1], !0).length >= 4 ? s(f) : n(f);
  }
  function s(f) {
    return f === null ? c(f) : Oe(f) ? e.attempt(cue, s, c)(f) : (e.enter("codeFlowValue"), u(f));
  }
  function u(f) {
    return f === null || Oe(f) ? (e.exit("codeFlowValue"), s(f)) : (e.consume(f), u);
  }
  function c(f) {
    return e.exit("codeIndented"), t(f);
  }
}
function due(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return r.parser.lazy[r.now().line] ? n(s) : Oe(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), o) : Qe(e, a, "linePrefix", 5)(s);
  }
  function a(s) {
    const u = r.events[r.events.length - 1];
    return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? t(s) : Oe(s) ? o(s) : n(s);
  }
}
const hue = {
  name: "codeText",
  previous: mue,
  resolve: pue,
  tokenize: gue
};
function pue(e) {
  let t = e.length - 4, n = 3, r, o;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    o === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (o = r) : (r === t || e[r][1].type === "lineEnding") && (e[o][1].type = "codeTextData", r !== o + 2 && (e[o][1].end = e[r - 1][1].end, e.splice(o + 2, r - o - 2), t -= r - o - 2, r = o + 2), o = void 0);
  return e;
}
function mue(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function gue(e, t, n) {
  let r = 0, o, a;
  return s;
  function s(p) {
    return e.enter("codeText"), e.enter("codeTextSequence"), u(p);
  }
  function u(p) {
    return p === 96 ? (e.consume(p), r++, u) : (e.exit("codeTextSequence"), c(p));
  }
  function c(p) {
    return p === null ? n(p) : p === 32 ? (e.enter("space"), e.consume(p), e.exit("space"), c) : p === 96 ? (a = e.enter("codeTextSequence"), o = 0, h(p)) : Oe(p) ? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), c) : (e.enter("codeTextData"), f(p));
  }
  function f(p) {
    return p === null || p === 32 || p === 96 || Oe(p) ? (e.exit("codeTextData"), c(p)) : (e.consume(p), f);
  }
  function h(p) {
    return p === 96 ? (e.consume(p), o++, h) : o === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(p)) : (a.type = "codeTextData", f(p));
  }
}
class yue {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, n, r) {
    const o = n || 0;
    this.setCursor(Math.trunc(t));
    const a = this.right.splice(this.right.length - o, Number.POSITIVE_INFINITY);
    return r && sc(this.left, r), a.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), sc(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), sc(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const n = this.left.splice(t, Number.POSITIVE_INFINITY);
        sc(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        sc(this.left, n.reverse());
      }
  }
}
function sc(e, t) {
  let n = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; n < t.length; )
      e.push(...t.slice(n, n + 1e4)), n += 1e4;
}
function yP(e) {
  const t = {};
  let n = -1, r, o, a, s, u, c, f;
  const h = new yue(e);
  for (; ++n < h.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = h.get(n), n && r[1].type === "chunkFlow" && h.get(n - 1)[1].type === "listItemPrefix" && (c = r[1]._tokenizer.events, a = 0, a < c.length && c[a][1].type === "lineEndingBlank" && (a += 2), a < c.length && c[a][1].type === "content"))
      for (; ++a < c.length && c[a][1].type !== "content"; )
        c[a][1].type === "chunkText" && (c[a][1]._isInFirstContentOfListItem = !0, a++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, vue(h, n)), n = t[n], f = !0);
    else if (r[1]._container) {
      for (a = n, o = void 0; a--; )
        if (s = h.get(a), s[1].type === "lineEnding" || s[1].type === "lineEndingBlank")
          s[0] === "enter" && (o && (h.get(o)[1].type = "lineEndingBlank"), s[1].type = "lineEnding", o = a);
        else if (!(s[1].type === "linePrefix" || s[1].type === "listItemIndent")) break;
      o && (r[1].end = {
        ...h.get(o)[1].start
      }, u = h.slice(o, n), u.unshift(r), h.splice(o, n - o + 1, u));
    }
  }
  return sr(e, 0, Number.POSITIVE_INFINITY, h.slice(0)), !f;
}
function vue(e, t) {
  const n = e.get(t)[1], r = e.get(t)[2];
  let o = t - 1;
  const a = [];
  let s = n._tokenizer;
  s || (s = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (s._contentTypeTextTrailing = !0));
  const u = s.events, c = [], f = {};
  let h, p, g = -1, y = n, w = 0, v = 0;
  const S = [v];
  for (; y; ) {
    for (; e.get(++o)[1] !== y; )
      ;
    a.push(o), y._tokenizer || (h = r.sliceStream(y), y.next || h.push(null), p && s.defineSkip(y.start), y._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = !0), s.write(h), y._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = void 0)), p = y, y = y.next;
  }
  for (y = n; ++g < u.length; )
    // Find a void token that includes a break.
    u[g][0] === "exit" && u[g - 1][0] === "enter" && u[g][1].type === u[g - 1][1].type && u[g][1].start.line !== u[g][1].end.line && (v = g + 1, S.push(v), y._tokenizer = void 0, y.previous = void 0, y = y.next);
  for (s.events = [], y ? (y._tokenizer = void 0, y.previous = void 0) : S.pop(), g = S.length; g--; ) {
    const E = u.slice(S[g], S[g + 1]), T = a.pop();
    c.push([T, T + E.length - 1]), e.splice(T, 2, E);
  }
  for (c.reverse(), g = -1; ++g < c.length; )
    f[w + c[g][0]] = w + c[g][1], w += c[g][1] - c[g][0] - 1;
  return f;
}
const bue = {
  resolve: wue,
  tokenize: _ue
}, xue = {
  partial: !0,
  tokenize: Sue
};
function wue(e) {
  return yP(e), e;
}
function _ue(e, t) {
  let n;
  return r;
  function r(u) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), o(u);
  }
  function o(u) {
    return u === null ? a(u) : Oe(u) ? e.check(xue, s, a)(u) : (e.consume(u), o);
  }
  function a(u) {
    return e.exit("chunkContent"), e.exit("content"), t(u);
  }
  function s(u) {
    return e.consume(u), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, o;
  }
}
function Sue(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), Qe(e, a, "linePrefix");
  }
  function a(s) {
    if (s === null || Oe(s))
      return n(s);
    const u = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? t(s) : e.interrupt(r.parser.constructs.flow, n, t)(s);
  }
}
function vP(e, t, n, r, o, a, s, u, c) {
  const f = c || Number.POSITIVE_INFINITY;
  let h = 0;
  return p;
  function p(E) {
    return E === 60 ? (e.enter(r), e.enter(o), e.enter(a), e.consume(E), e.exit(a), g) : E === null || E === 32 || E === 41 || Dp(E) ? n(E) : (e.enter(r), e.enter(s), e.enter(u), e.enter("chunkString", {
      contentType: "string"
    }), v(E));
  }
  function g(E) {
    return E === 62 ? (e.enter(a), e.consume(E), e.exit(a), e.exit(o), e.exit(r), t) : (e.enter(u), e.enter("chunkString", {
      contentType: "string"
    }), y(E));
  }
  function y(E) {
    return E === 62 ? (e.exit("chunkString"), e.exit(u), g(E)) : E === null || E === 60 || Oe(E) ? n(E) : (e.consume(E), E === 92 ? w : y);
  }
  function w(E) {
    return E === 60 || E === 62 || E === 92 ? (e.consume(E), y) : y(E);
  }
  function v(E) {
    return !h && (E === null || E === 41 || vt(E)) ? (e.exit("chunkString"), e.exit(u), e.exit(s), e.exit(r), t(E)) : h < f && E === 40 ? (e.consume(E), h++, v) : E === 41 ? (e.consume(E), h--, v) : E === null || E === 32 || E === 40 || Dp(E) ? n(E) : (e.consume(E), E === 92 ? S : v);
  }
  function S(E) {
    return E === 40 || E === 41 || E === 92 ? (e.consume(E), v) : v(E);
  }
}
function bP(e, t, n, r, o, a) {
  const s = this;
  let u = 0, c;
  return f;
  function f(y) {
    return e.enter(r), e.enter(o), e.consume(y), e.exit(o), e.enter(a), h;
  }
  function h(y) {
    return u > 999 || y === null || y === 91 || y === 93 && !c || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    y === 94 && !u && "_hiddenFootnoteSupport" in s.parser.constructs ? n(y) : y === 93 ? (e.exit(a), e.enter(o), e.consume(y), e.exit(o), e.exit(r), t) : Oe(y) ? (e.enter("lineEnding"), e.consume(y), e.exit("lineEnding"), h) : (e.enter("chunkString", {
      contentType: "string"
    }), p(y));
  }
  function p(y) {
    return y === null || y === 91 || y === 93 || Oe(y) || u++ > 999 ? (e.exit("chunkString"), h(y)) : (e.consume(y), c || (c = !We(y)), y === 92 ? g : p);
  }
  function g(y) {
    return y === 91 || y === 92 || y === 93 ? (e.consume(y), u++, p) : p(y);
  }
}
function xP(e, t, n, r, o, a) {
  let s;
  return u;
  function u(g) {
    return g === 34 || g === 39 || g === 40 ? (e.enter(r), e.enter(o), e.consume(g), e.exit(o), s = g === 40 ? 41 : g, c) : n(g);
  }
  function c(g) {
    return g === s ? (e.enter(o), e.consume(g), e.exit(o), e.exit(r), t) : (e.enter(a), f(g));
  }
  function f(g) {
    return g === s ? (e.exit(a), c(s)) : g === null ? n(g) : Oe(g) ? (e.enter("lineEnding"), e.consume(g), e.exit("lineEnding"), Qe(e, f, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), h(g));
  }
  function h(g) {
    return g === s || g === null || Oe(g) ? (e.exit("chunkString"), f(g)) : (e.consume(g), g === 92 ? p : h);
  }
  function p(g) {
    return g === s || g === 92 ? (e.consume(g), h) : h(g);
  }
}
function Ec(e, t) {
  let n;
  return r;
  function r(o) {
    return Oe(o) ? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), n = !0, r) : We(o) ? Qe(e, r, n ? "linePrefix" : "lineSuffix")(o) : t(o);
  }
}
const Eue = {
  name: "definition",
  tokenize: kue
}, Cue = {
  partial: !0,
  tokenize: Tue
};
function kue(e, t, n) {
  const r = this;
  let o;
  return a;
  function a(y) {
    return e.enter("definition"), s(y);
  }
  function s(y) {
    return bP.call(
      r,
      e,
      u,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(y);
  }
  function u(y) {
    return o = zr(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), y === 58 ? (e.enter("definitionMarker"), e.consume(y), e.exit("definitionMarker"), c) : n(y);
  }
  function c(y) {
    return vt(y) ? Ec(e, f)(y) : f(y);
  }
  function f(y) {
    return vP(
      e,
      h,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(y);
  }
  function h(y) {
    return e.attempt(Cue, p, p)(y);
  }
  function p(y) {
    return We(y) ? Qe(e, g, "whitespace")(y) : g(y);
  }
  function g(y) {
    return y === null || Oe(y) ? (e.exit("definition"), r.parser.defined.push(o), t(y)) : n(y);
  }
}
function Tue(e, t, n) {
  return r;
  function r(u) {
    return vt(u) ? Ec(e, o)(u) : n(u);
  }
  function o(u) {
    return xP(e, a, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(u);
  }
  function a(u) {
    return We(u) ? Qe(e, s, "whitespace")(u) : s(u);
  }
  function s(u) {
    return u === null || Oe(u) ? t(u) : n(u);
  }
}
const Aue = {
  name: "hardBreakEscape",
  tokenize: Rue
};
function Rue(e, t, n) {
  return r;
  function r(a) {
    return e.enter("hardBreakEscape"), e.consume(a), o;
  }
  function o(a) {
    return Oe(a) ? (e.exit("hardBreakEscape"), t(a)) : n(a);
  }
}
const Mue = {
  name: "headingAtx",
  resolve: Oue,
  tokenize: Nue
};
function Oue(e, t) {
  let n = e.length - 2, r = 3, o, a;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (o = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, a = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, sr(e, r, n - r + 1, [["enter", o, t], ["enter", a, t], ["exit", a, t], ["exit", o, t]])), e;
}
function Nue(e, t, n) {
  let r = 0;
  return o;
  function o(h) {
    return e.enter("atxHeading"), a(h);
  }
  function a(h) {
    return e.enter("atxHeadingSequence"), s(h);
  }
  function s(h) {
    return h === 35 && r++ < 6 ? (e.consume(h), s) : h === null || vt(h) ? (e.exit("atxHeadingSequence"), u(h)) : n(h);
  }
  function u(h) {
    return h === 35 ? (e.enter("atxHeadingSequence"), c(h)) : h === null || Oe(h) ? (e.exit("atxHeading"), t(h)) : We(h) ? Qe(e, u, "whitespace")(h) : (e.enter("atxHeadingText"), f(h));
  }
  function c(h) {
    return h === 35 ? (e.consume(h), c) : (e.exit("atxHeadingSequence"), u(h));
  }
  function f(h) {
    return h === null || h === 35 || vt(h) ? (e.exit("atxHeadingText"), u(h)) : (e.consume(h), f);
  }
}
const Due = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], ER = ["pre", "script", "style", "textarea"], Pue = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: zue,
  tokenize: Lue
}, jue = {
  partial: !0,
  tokenize: $ue
}, Iue = {
  partial: !0,
  tokenize: Fue
};
function zue(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function Lue(e, t, n) {
  const r = this;
  let o, a, s, u, c;
  return f;
  function f(L) {
    return h(L);
  }
  function h(L) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(L), p;
  }
  function p(L) {
    return L === 33 ? (e.consume(L), g) : L === 47 ? (e.consume(L), a = !0, v) : L === 63 ? (e.consume(L), o = 3, r.interrupt ? t : O) : Cn(L) ? (e.consume(L), s = String.fromCharCode(L), S) : n(L);
  }
  function g(L) {
    return L === 45 ? (e.consume(L), o = 2, y) : L === 91 ? (e.consume(L), o = 5, u = 0, w) : Cn(L) ? (e.consume(L), o = 4, r.interrupt ? t : O) : n(L);
  }
  function y(L) {
    return L === 45 ? (e.consume(L), r.interrupt ? t : O) : n(L);
  }
  function w(L) {
    const te = "CDATA[";
    return L === te.charCodeAt(u++) ? (e.consume(L), u === te.length ? r.interrupt ? t : U : w) : n(L);
  }
  function v(L) {
    return Cn(L) ? (e.consume(L), s = String.fromCharCode(L), S) : n(L);
  }
  function S(L) {
    if (L === null || L === 47 || L === 62 || vt(L)) {
      const te = L === 47, he = s.toLowerCase();
      return !te && !a && ER.includes(he) ? (o = 1, r.interrupt ? t(L) : U(L)) : Due.includes(s.toLowerCase()) ? (o = 6, te ? (e.consume(L), E) : r.interrupt ? t(L) : U(L)) : (o = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(L) : a ? T(L) : k(L));
    }
    return L === 45 || vn(L) ? (e.consume(L), s += String.fromCharCode(L), S) : n(L);
  }
  function E(L) {
    return L === 62 ? (e.consume(L), r.interrupt ? t : U) : n(L);
  }
  function T(L) {
    return We(L) ? (e.consume(L), T) : R(L);
  }
  function k(L) {
    return L === 47 ? (e.consume(L), R) : L === 58 || L === 95 || Cn(L) ? (e.consume(L), A) : We(L) ? (e.consume(L), k) : R(L);
  }
  function A(L) {
    return L === 45 || L === 46 || L === 58 || L === 95 || vn(L) ? (e.consume(L), A) : M(L);
  }
  function M(L) {
    return L === 61 ? (e.consume(L), N) : We(L) ? (e.consume(L), M) : k(L);
  }
  function N(L) {
    return L === null || L === 60 || L === 61 || L === 62 || L === 96 ? n(L) : L === 34 || L === 39 ? (e.consume(L), c = L, P) : We(L) ? (e.consume(L), N) : z(L);
  }
  function P(L) {
    return L === c ? (e.consume(L), c = null, B) : L === null || Oe(L) ? n(L) : (e.consume(L), P);
  }
  function z(L) {
    return L === null || L === 34 || L === 39 || L === 47 || L === 60 || L === 61 || L === 62 || L === 96 || vt(L) ? M(L) : (e.consume(L), z);
  }
  function B(L) {
    return L === 47 || L === 62 || We(L) ? k(L) : n(L);
  }
  function R(L) {
    return L === 62 ? (e.consume(L), F) : n(L);
  }
  function F(L) {
    return L === null || Oe(L) ? U(L) : We(L) ? (e.consume(L), F) : n(L);
  }
  function U(L) {
    return L === 45 && o === 2 ? (e.consume(L), I) : L === 60 && o === 1 ? (e.consume(L), H) : L === 62 && o === 4 ? (e.consume(L), Y) : L === 63 && o === 3 ? (e.consume(L), O) : L === 93 && o === 5 ? (e.consume(L), G) : Oe(L) && (o === 6 || o === 7) ? (e.exit("htmlFlowData"), e.check(jue, Z, W)(L)) : L === null || Oe(L) ? (e.exit("htmlFlowData"), W(L)) : (e.consume(L), U);
  }
  function W(L) {
    return e.check(Iue, j, Z)(L);
  }
  function j(L) {
    return e.enter("lineEnding"), e.consume(L), e.exit("lineEnding"), V;
  }
  function V(L) {
    return L === null || Oe(L) ? W(L) : (e.enter("htmlFlowData"), U(L));
  }
  function I(L) {
    return L === 45 ? (e.consume(L), O) : U(L);
  }
  function H(L) {
    return L === 47 ? (e.consume(L), s = "", q) : U(L);
  }
  function q(L) {
    if (L === 62) {
      const te = s.toLowerCase();
      return ER.includes(te) ? (e.consume(L), Y) : U(L);
    }
    return Cn(L) && s.length < 8 ? (e.consume(L), s += String.fromCharCode(L), q) : U(L);
  }
  function G(L) {
    return L === 93 ? (e.consume(L), O) : U(L);
  }
  function O(L) {
    return L === 62 ? (e.consume(L), Y) : L === 45 && o === 2 ? (e.consume(L), O) : U(L);
  }
  function Y(L) {
    return L === null || Oe(L) ? (e.exit("htmlFlowData"), Z(L)) : (e.consume(L), Y);
  }
  function Z(L) {
    return e.exit("htmlFlow"), t(L);
  }
}
function Fue(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return Oe(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), a) : n(s);
  }
  function a(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
function $ue(e, t, n) {
  return r;
  function r(o) {
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), e.attempt(kf, t, n);
  }
}
const Bue = {
  name: "htmlText",
  tokenize: Hue
};
function Hue(e, t, n) {
  const r = this;
  let o, a, s;
  return u;
  function u(O) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(O), c;
  }
  function c(O) {
    return O === 33 ? (e.consume(O), f) : O === 47 ? (e.consume(O), M) : O === 63 ? (e.consume(O), k) : Cn(O) ? (e.consume(O), z) : n(O);
  }
  function f(O) {
    return O === 45 ? (e.consume(O), h) : O === 91 ? (e.consume(O), a = 0, w) : Cn(O) ? (e.consume(O), T) : n(O);
  }
  function h(O) {
    return O === 45 ? (e.consume(O), y) : n(O);
  }
  function p(O) {
    return O === null ? n(O) : O === 45 ? (e.consume(O), g) : Oe(O) ? (s = p, H(O)) : (e.consume(O), p);
  }
  function g(O) {
    return O === 45 ? (e.consume(O), y) : p(O);
  }
  function y(O) {
    return O === 62 ? I(O) : O === 45 ? g(O) : p(O);
  }
  function w(O) {
    const Y = "CDATA[";
    return O === Y.charCodeAt(a++) ? (e.consume(O), a === Y.length ? v : w) : n(O);
  }
  function v(O) {
    return O === null ? n(O) : O === 93 ? (e.consume(O), S) : Oe(O) ? (s = v, H(O)) : (e.consume(O), v);
  }
  function S(O) {
    return O === 93 ? (e.consume(O), E) : v(O);
  }
  function E(O) {
    return O === 62 ? I(O) : O === 93 ? (e.consume(O), E) : v(O);
  }
  function T(O) {
    return O === null || O === 62 ? I(O) : Oe(O) ? (s = T, H(O)) : (e.consume(O), T);
  }
  function k(O) {
    return O === null ? n(O) : O === 63 ? (e.consume(O), A) : Oe(O) ? (s = k, H(O)) : (e.consume(O), k);
  }
  function A(O) {
    return O === 62 ? I(O) : k(O);
  }
  function M(O) {
    return Cn(O) ? (e.consume(O), N) : n(O);
  }
  function N(O) {
    return O === 45 || vn(O) ? (e.consume(O), N) : P(O);
  }
  function P(O) {
    return Oe(O) ? (s = P, H(O)) : We(O) ? (e.consume(O), P) : I(O);
  }
  function z(O) {
    return O === 45 || vn(O) ? (e.consume(O), z) : O === 47 || O === 62 || vt(O) ? B(O) : n(O);
  }
  function B(O) {
    return O === 47 ? (e.consume(O), I) : O === 58 || O === 95 || Cn(O) ? (e.consume(O), R) : Oe(O) ? (s = B, H(O)) : We(O) ? (e.consume(O), B) : I(O);
  }
  function R(O) {
    return O === 45 || O === 46 || O === 58 || O === 95 || vn(O) ? (e.consume(O), R) : F(O);
  }
  function F(O) {
    return O === 61 ? (e.consume(O), U) : Oe(O) ? (s = F, H(O)) : We(O) ? (e.consume(O), F) : B(O);
  }
  function U(O) {
    return O === null || O === 60 || O === 61 || O === 62 || O === 96 ? n(O) : O === 34 || O === 39 ? (e.consume(O), o = O, W) : Oe(O) ? (s = U, H(O)) : We(O) ? (e.consume(O), U) : (e.consume(O), j);
  }
  function W(O) {
    return O === o ? (e.consume(O), o = void 0, V) : O === null ? n(O) : Oe(O) ? (s = W, H(O)) : (e.consume(O), W);
  }
  function j(O) {
    return O === null || O === 34 || O === 39 || O === 60 || O === 61 || O === 96 ? n(O) : O === 47 || O === 62 || vt(O) ? B(O) : (e.consume(O), j);
  }
  function V(O) {
    return O === 47 || O === 62 || vt(O) ? B(O) : n(O);
  }
  function I(O) {
    return O === 62 ? (e.consume(O), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(O);
  }
  function H(O) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(O), e.exit("lineEnding"), q;
  }
  function q(O) {
    return We(O) ? Qe(e, G, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(O) : G(O);
  }
  function G(O) {
    return e.enter("htmlTextData"), s(O);
  }
}
const mw = {
  name: "labelEnd",
  resolveAll: Gue,
  resolveTo: Yue,
  tokenize: Wue
}, Vue = {
  tokenize: Xue
}, Uue = {
  tokenize: Kue
}, que = {
  tokenize: Zue
};
function Gue(e) {
  let t = -1;
  const n = [];
  for (; ++t < e.length; ) {
    const r = e[t][1];
    if (n.push(e[t]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
      const o = r.type === "labelImage" ? 4 : 2;
      r.type = "data", t += o;
    }
  }
  return e.length !== n.length && sr(e, 0, e.length, n), e;
}
function Yue(e, t) {
  let n = e.length, r = 0, o, a, s, u;
  for (; n--; )
    if (o = e[n][1], a) {
      if (o.type === "link" || o.type === "labelLink" && o._inactive)
        break;
      e[n][0] === "enter" && o.type === "labelLink" && (o._inactive = !0);
    } else if (s) {
      if (e[n][0] === "enter" && (o.type === "labelImage" || o.type === "labelLink") && !o._balanced && (a = n, o.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else o.type === "labelEnd" && (s = n);
  const c = {
    type: e[a][1].type === "labelLink" ? "link" : "image",
    start: {
      ...e[a][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  }, f = {
    type: "label",
    start: {
      ...e[a][1].start
    },
    end: {
      ...e[s][1].end
    }
  }, h = {
    type: "labelText",
    start: {
      ...e[a + r + 2][1].end
    },
    end: {
      ...e[s - 2][1].start
    }
  };
  return u = [["enter", c, t], ["enter", f, t]], u = Sr(u, e.slice(a + 1, a + r + 3)), u = Sr(u, [["enter", h, t]]), u = Sr(u, Zm(t.parser.constructs.insideSpan.null, e.slice(a + r + 4, s - 3), t)), u = Sr(u, [["exit", h, t], e[s - 2], e[s - 1], ["exit", f, t]]), u = Sr(u, e.slice(s + 1)), u = Sr(u, [["exit", c, t]]), sr(e, a, e.length, u), e;
}
function Wue(e, t, n) {
  const r = this;
  let o = r.events.length, a, s;
  for (; o--; )
    if ((r.events[o][1].type === "labelImage" || r.events[o][1].type === "labelLink") && !r.events[o][1]._balanced) {
      a = r.events[o][1];
      break;
    }
  return u;
  function u(g) {
    return a ? a._inactive ? p(g) : (s = r.parser.defined.includes(zr(r.sliceSerialize({
      start: a.end,
      end: r.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(g), e.exit("labelMarker"), e.exit("labelEnd"), c) : n(g);
  }
  function c(g) {
    return g === 40 ? e.attempt(Vue, h, s ? h : p)(g) : g === 91 ? e.attempt(Uue, h, s ? f : p)(g) : s ? h(g) : p(g);
  }
  function f(g) {
    return e.attempt(que, h, p)(g);
  }
  function h(g) {
    return t(g);
  }
  function p(g) {
    return a._balanced = !0, n(g);
  }
}
function Xue(e, t, n) {
  return r;
  function r(p) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(p), e.exit("resourceMarker"), o;
  }
  function o(p) {
    return vt(p) ? Ec(e, a)(p) : a(p);
  }
  function a(p) {
    return p === 41 ? h(p) : vP(e, s, u, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(p);
  }
  function s(p) {
    return vt(p) ? Ec(e, c)(p) : h(p);
  }
  function u(p) {
    return n(p);
  }
  function c(p) {
    return p === 34 || p === 39 || p === 40 ? xP(e, f, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(p) : h(p);
  }
  function f(p) {
    return vt(p) ? Ec(e, h)(p) : h(p);
  }
  function h(p) {
    return p === 41 ? (e.enter("resourceMarker"), e.consume(p), e.exit("resourceMarker"), e.exit("resource"), t) : n(p);
  }
}
function Kue(e, t, n) {
  const r = this;
  return o;
  function o(u) {
    return bP.call(r, e, a, s, "reference", "referenceMarker", "referenceString")(u);
  }
  function a(u) {
    return r.parser.defined.includes(zr(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(u) : n(u);
  }
  function s(u) {
    return n(u);
  }
}
function Zue(e, t, n) {
  return r;
  function r(a) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), o;
  }
  function o(a) {
    return a === 93 ? (e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), e.exit("reference"), t) : n(a);
  }
}
const Que = {
  name: "labelStartImage",
  resolveAll: mw.resolveAll,
  tokenize: Jue
};
function Jue(e, t, n) {
  const r = this;
  return o;
  function o(u) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(u), e.exit("labelImageMarker"), a;
  }
  function a(u) {
    return u === 91 ? (e.enter("labelMarker"), e.consume(u), e.exit("labelMarker"), e.exit("labelImage"), s) : n(u);
  }
  function s(u) {
    return u === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(u) : t(u);
  }
}
const ece = {
  name: "labelStartLink",
  resolveAll: mw.resolveAll,
  tokenize: tce
};
function tce(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelLink"), a;
  }
  function a(s) {
    return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s);
  }
}
const Sv = {
  name: "lineEnding",
  tokenize: nce
};
function nce(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), Qe(e, t, "linePrefix");
  }
}
const Yh = {
  name: "thematicBreak",
  tokenize: rce
};
function rce(e, t, n) {
  let r = 0, o;
  return a;
  function a(f) {
    return e.enter("thematicBreak"), s(f);
  }
  function s(f) {
    return o = f, u(f);
  }
  function u(f) {
    return f === o ? (e.enter("thematicBreakSequence"), c(f)) : r >= 3 && (f === null || Oe(f)) ? (e.exit("thematicBreak"), t(f)) : n(f);
  }
  function c(f) {
    return f === o ? (e.consume(f), r++, c) : (e.exit("thematicBreakSequence"), We(f) ? Qe(e, u, "whitespace")(f) : u(f));
  }
}
const In = {
  continuation: {
    tokenize: sce
  },
  exit: uce,
  name: "list",
  tokenize: ace
}, oce = {
  partial: !0,
  tokenize: cce
}, ice = {
  partial: !0,
  tokenize: lce
};
function ace(e, t, n) {
  const r = this, o = r.events[r.events.length - 1];
  let a = o && o[1].type === "linePrefix" ? o[2].sliceSerialize(o[1], !0).length : 0, s = 0;
  return u;
  function u(y) {
    const w = r.containerState.type || (y === 42 || y === 43 || y === 45 ? "listUnordered" : "listOrdered");
    if (w === "listUnordered" ? !r.containerState.marker || y === r.containerState.marker : Jb(y)) {
      if (r.containerState.type || (r.containerState.type = w, e.enter(w, {
        _container: !0
      })), w === "listUnordered")
        return e.enter("listItemPrefix"), y === 42 || y === 45 ? e.check(Yh, n, f)(y) : f(y);
      if (!r.interrupt || y === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), c(y);
    }
    return n(y);
  }
  function c(y) {
    return Jb(y) && ++s < 10 ? (e.consume(y), c) : (!r.interrupt || s < 2) && (r.containerState.marker ? y === r.containerState.marker : y === 41 || y === 46) ? (e.exit("listItemValue"), f(y)) : n(y);
  }
  function f(y) {
    return e.enter("listItemMarker"), e.consume(y), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || y, e.check(
      kf,
      // Cant be empty when interrupting.
      r.interrupt ? n : h,
      e.attempt(oce, g, p)
    );
  }
  function h(y) {
    return r.containerState.initialBlankLine = !0, a++, g(y);
  }
  function p(y) {
    return We(y) ? (e.enter("listItemPrefixWhitespace"), e.consume(y), e.exit("listItemPrefixWhitespace"), g) : n(y);
  }
  function g(y) {
    return r.containerState.size = a + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(y);
  }
}
function sce(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(kf, o, a);
  function o(u) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, Qe(e, t, "listItemIndent", r.containerState.size + 1)(u);
  }
  function a(u) {
    return r.containerState.furtherBlankLines || !We(u) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, s(u)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(ice, t, s)(u));
  }
  function s(u) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, Qe(e, e.attempt(In, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(u);
  }
}
function lce(e, t, n) {
  const r = this;
  return Qe(e, o, "listItemIndent", r.containerState.size + 1);
  function o(a) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "listItemIndent" && s[2].sliceSerialize(s[1], !0).length === r.containerState.size ? t(a) : n(a);
  }
}
function uce(e) {
  e.exit(this.containerState.type);
}
function cce(e, t, n) {
  const r = this;
  return Qe(e, o, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function o(a) {
    const s = r.events[r.events.length - 1];
    return !We(a) && s && s[1].type === "listItemPrefixWhitespace" ? t(a) : n(a);
  }
}
const CR = {
  name: "setextUnderline",
  resolveTo: fce,
  tokenize: dce
};
function fce(e, t) {
  let n = e.length, r, o, a;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (o = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !a && e[n][1].type === "definition" && (a = n);
  const s = {
    type: "setextHeading",
    start: {
      ...e[r][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  };
  return e[o][1].type = "setextHeadingText", a ? (e.splice(o, 0, ["enter", s, t]), e.splice(a + 1, 0, ["exit", e[r][1], t]), e[r][1].end = {
    ...e[a][1].end
  }) : e[r][1] = s, e.push(["exit", s, t]), e;
}
function dce(e, t, n) {
  const r = this;
  let o;
  return a;
  function a(f) {
    let h = r.events.length, p;
    for (; h--; )
      if (r.events[h][1].type !== "lineEnding" && r.events[h][1].type !== "linePrefix" && r.events[h][1].type !== "content") {
        p = r.events[h][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || p) ? (e.enter("setextHeadingLine"), o = f, s(f)) : n(f);
  }
  function s(f) {
    return e.enter("setextHeadingLineSequence"), u(f);
  }
  function u(f) {
    return f === o ? (e.consume(f), u) : (e.exit("setextHeadingLineSequence"), We(f) ? Qe(e, c, "lineSuffix")(f) : c(f));
  }
  function c(f) {
    return f === null || Oe(f) ? (e.exit("setextHeadingLine"), t(f)) : n(f);
  }
}
const hce = {
  tokenize: pce
};
function pce(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    kf,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(this.parser.constructs.flowInitial, o, Qe(e, e.attempt(this.parser.constructs.flow, o, e.attempt(bue, o)), "linePrefix"))
  );
  return n;
  function r(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(a), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function o(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const mce = {
  resolveAll: _P()
}, gce = wP("string"), yce = wP("text");
function wP(e) {
  return {
    resolveAll: _P(e === "text" ? vce : void 0),
    tokenize: t
  };
  function t(n) {
    const r = this, o = this.parser.constructs[e], a = n.attempt(o, s, u);
    return s;
    function s(h) {
      return f(h) ? a(h) : u(h);
    }
    function u(h) {
      if (h === null) {
        n.consume(h);
        return;
      }
      return n.enter("data"), n.consume(h), c;
    }
    function c(h) {
      return f(h) ? (n.exit("data"), a(h)) : (n.consume(h), c);
    }
    function f(h) {
      if (h === null)
        return !0;
      const p = o[h];
      let g = -1;
      if (p)
        for (; ++g < p.length; ) {
          const y = p[g];
          if (!y.previous || y.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function _P(e) {
  return t;
  function t(n, r) {
    let o = -1, a;
    for (; ++o <= n.length; )
      a === void 0 ? n[o] && n[o][1].type === "data" && (a = o, o++) : (!n[o] || n[o][1].type !== "data") && (o !== a + 2 && (n[a][1].end = n[o - 1][1].end, n.splice(a + 2, o - a - 2), o = a + 2), a = void 0);
    return e ? e(n, r) : n;
  }
}
function vce(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], o = t.sliceStream(r);
      let a = o.length, s = -1, u = 0, c;
      for (; a--; ) {
        const f = o[a];
        if (typeof f == "string") {
          for (s = f.length; f.charCodeAt(s - 1) === 32; )
            u++, s--;
          if (s) break;
          s = -1;
        } else if (f === -2)
          c = !0, u++;
        else if (f !== -1) {
          a++;
          break;
        }
      }
      if (t._contentTypeTextTrailing && n === e.length && (u = 0), u) {
        const f = {
          type: n === e.length || c || u < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: a ? s : r.start._bufferIndex + s,
            _index: r.start._index + a,
            line: r.end.line,
            column: r.end.column - u,
            offset: r.end.offset - u
          },
          end: {
            ...r.end
          }
        };
        r.end = {
          ...f.start
        }, r.start.offset === r.end.offset ? Object.assign(r, f) : (e.splice(n, 0, ["enter", f, t], ["exit", f, t]), n += 2);
      }
      n++;
    }
  return e;
}
const bce = {
  42: In,
  43: In,
  45: In,
  48: In,
  49: In,
  50: In,
  51: In,
  52: In,
  53: In,
  54: In,
  55: In,
  56: In,
  57: In,
  62: pP
}, xce = {
  91: Eue
}, wce = {
  [-2]: _v,
  [-1]: _v,
  32: _v
}, _ce = {
  35: Mue,
  42: Yh,
  45: [CR, Yh],
  60: Pue,
  61: CR,
  95: Yh,
  96: SR,
  126: SR
}, Sce = {
  38: gP,
  92: mP
}, Ece = {
  [-5]: Sv,
  [-4]: Sv,
  [-3]: Sv,
  33: Que,
  38: gP,
  42: e1,
  60: [eue, Bue],
  91: ece,
  92: [Aue, mP],
  93: mw,
  95: e1,
  96: hue
}, Cce = {
  null: [e1, mce]
}, kce = {
  null: [42, 95]
}, Tce = {
  null: []
}, Ace = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: kce,
  contentInitial: xce,
  disable: Tce,
  document: bce,
  flow: _ce,
  flowInitial: wce,
  insideSpan: Cce,
  string: Sce,
  text: Ece
}, Symbol.toStringTag, { value: "Module" }));
function Rce(e, t, n) {
  let r = {
    _bufferIndex: -1,
    _index: 0,
    line: n && n.line || 1,
    column: n && n.column || 1,
    offset: n && n.offset || 0
  };
  const o = {}, a = [];
  let s = [], u = [];
  const c = {
    attempt: P(M),
    check: P(N),
    consume: T,
    enter: k,
    exit: A,
    interrupt: P(N, {
      interrupt: !0
    })
  }, f = {
    code: null,
    containerState: {},
    defineSkip: v,
    events: [],
    now: w,
    parser: e,
    previous: null,
    sliceSerialize: g,
    sliceStream: y,
    write: p
  };
  let h = t.tokenize.call(f, c);
  return t.resolveAll && a.push(t), f;
  function p(F) {
    return s = Sr(s, F), S(), s[s.length - 1] !== null ? [] : (z(t, 0), f.events = Zm(a, f.events, f), f.events);
  }
  function g(F, U) {
    return Oce(y(F), U);
  }
  function y(F) {
    return Mce(s, F);
  }
  function w() {
    const {
      _bufferIndex: F,
      _index: U,
      line: W,
      column: j,
      offset: V
    } = r;
    return {
      _bufferIndex: F,
      _index: U,
      line: W,
      column: j,
      offset: V
    };
  }
  function v(F) {
    o[F.line] = F.column, R();
  }
  function S() {
    let F;
    for (; r._index < s.length; ) {
      const U = s[r._index];
      if (typeof U == "string")
        for (F = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === F && r._bufferIndex < U.length; )
          E(U.charCodeAt(r._bufferIndex));
      else
        E(U);
    }
  }
  function E(F) {
    h = h(F);
  }
  function T(F) {
    Oe(F) ? (r.line++, r.column = 1, r.offset += F === -3 ? 2 : 1, R()) : F !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    s[r._index].length && (r._bufferIndex = -1, r._index++)), f.previous = F;
  }
  function k(F, U) {
    const W = U || {};
    return W.type = F, W.start = w(), f.events.push(["enter", W, f]), u.push(W), W;
  }
  function A(F) {
    const U = u.pop();
    return U.end = w(), f.events.push(["exit", U, f]), U;
  }
  function M(F, U) {
    z(F, U.from);
  }
  function N(F, U) {
    U.restore();
  }
  function P(F, U) {
    return W;
    function W(j, V, I) {
      let H, q, G, O;
      return Array.isArray(j) ? (
        /* c8 ignore next 1 */
        Z(j)
      ) : "tokenize" in j ? (
        // Looks like a construct.
        Z([
          /** @type {Construct} */
          j
        ])
      ) : Y(j);
      function Y(oe) {
        return de;
        function de(le) {
          const ye = le !== null && oe[le], je = le !== null && oe.null, Ne = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(ye) ? ye : ye ? [ye] : [],
            ...Array.isArray(je) ? je : je ? [je] : []
          ];
          return Z(Ne)(le);
        }
      }
      function Z(oe) {
        return H = oe, q = 0, oe.length === 0 ? I : L(oe[q]);
      }
      function L(oe) {
        return de;
        function de(le) {
          return O = B(), G = oe, oe.partial || (f.currentConstruct = oe), oe.name && f.parser.constructs.disable.null.includes(oe.name) ? he() : oe.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            U ? Object.assign(Object.create(f), U) : f,
            c,
            te,
            he
          )(le);
        }
      }
      function te(oe) {
        return F(G, O), V;
      }
      function he(oe) {
        return O.restore(), ++q < H.length ? L(H[q]) : I;
      }
    }
  }
  function z(F, U) {
    F.resolveAll && !a.includes(F) && a.push(F), F.resolve && sr(f.events, U, f.events.length - U, F.resolve(f.events.slice(U), f)), F.resolveTo && (f.events = F.resolveTo(f.events, f));
  }
  function B() {
    const F = w(), U = f.previous, W = f.currentConstruct, j = f.events.length, V = Array.from(u);
    return {
      from: j,
      restore: I
    };
    function I() {
      r = F, f.previous = U, f.currentConstruct = W, f.events.length = j, u = V, R();
    }
  }
  function R() {
    r.line in o && r.column < 2 && (r.column = o[r.line], r.offset += o[r.line] - 1);
  }
}
function Mce(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, o = t.end._index, a = t.end._bufferIndex;
  let s;
  if (n === o)
    s = [e[n].slice(r, a)];
  else {
    if (s = e.slice(n, o), r > -1) {
      const u = s[0];
      typeof u == "string" ? s[0] = u.slice(r) : s.shift();
    }
    a > 0 && s.push(e[o].slice(0, a));
  }
  return s;
}
function Oce(e, t) {
  let n = -1;
  const r = [];
  let o;
  for (; ++n < e.length; ) {
    const a = e[n];
    let s;
    if (typeof a == "string")
      s = a;
    else switch (a) {
      case -5: {
        s = "\r";
        break;
      }
      case -4: {
        s = `
`;
        break;
      }
      case -3: {
        s = `\r
`;
        break;
      }
      case -2: {
        s = t ? " " : "	";
        break;
      }
      case -1: {
        if (!t && o) continue;
        s = " ";
        break;
      }
      default:
        s = String.fromCharCode(a);
    }
    o = a === -2, r.push(s);
  }
  return r.join("");
}
function Nce(e) {
  const r = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      dP([Ace, ...(e || {}).extensions || []])
    ),
    content: o(Yle),
    defined: [],
    document: o(Xle),
    flow: o(hce),
    lazy: {},
    string: o(gce),
    text: o(yce)
  };
  return r;
  function o(a) {
    return s;
    function s(u) {
      return Rce(r, a, u);
    }
  }
}
function Dce(e) {
  for (; !yP(e); )
    ;
  return e;
}
const kR = /[\0\t\n\r]/g;
function Pce() {
  let e = 1, t = "", n = !0, r;
  return o;
  function o(a, s, u) {
    const c = [];
    let f, h, p, g, y;
    for (a = t + (typeof a == "string" ? a.toString() : new TextDecoder(s || void 0).decode(a)), p = 0, t = "", n && (a.charCodeAt(0) === 65279 && p++, n = void 0); p < a.length; ) {
      if (kR.lastIndex = p, f = kR.exec(a), g = f && f.index !== void 0 ? f.index : a.length, y = a.charCodeAt(g), !f) {
        t = a.slice(p);
        break;
      }
      if (y === 10 && p === g && r)
        c.push(-3), r = void 0;
      else
        switch (r && (c.push(-5), r = void 0), p < g && (c.push(a.slice(p, g)), e += g - p), y) {
          case 0: {
            c.push(65533), e++;
            break;
          }
          case 9: {
            for (h = Math.ceil(e / 4) * 4, c.push(-2); e++ < h; ) c.push(-1);
            break;
          }
          case 10: {
            c.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      p = g + 1;
    }
    return u && (r && c.push(-5), t && c.push(t), c.push(null)), c;
  }
}
const jce = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function Ice(e) {
  return e.replace(jce, zce);
}
function zce(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const o = n.charCodeAt(1), a = o === 120 || o === 88;
    return hP(n.slice(a ? 2 : 1), a ? 16 : 10);
  }
  return pw(n) || e;
}
const SP = {}.hasOwnProperty;
function Lce(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), Fce(n)(Dce(Nce(n).document().write(Pce()(e, t, !0))));
}
function Fce(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: a(fr),
      autolinkProtocol: B,
      autolinkEmail: B,
      atxHeading: a(Xe),
      blockQuote: a(je),
      characterEscape: B,
      characterReference: B,
      codeFenced: a(Ne),
      codeFencedFenceInfo: s,
      codeFencedFenceMeta: s,
      codeIndented: a(Ne, s),
      codeText: a(we, s),
      codeTextData: B,
      data: B,
      codeFlowValue: B,
      definition: a(Ee),
      definitionDestinationString: s,
      definitionLabelString: s,
      definitionTitleString: s,
      emphasis: a(_e),
      hardBreakEscape: a(St),
      hardBreakTrailing: a(St),
      htmlFlow: a(ct, s),
      htmlFlowData: B,
      htmlText: a(ct, s),
      htmlTextData: B,
      image: a(cn),
      label: s,
      link: a(fr),
      listItem: a(qn),
      listItemValue: g,
      listOrdered: a(Un, p),
      listUnordered: a(Un),
      paragraph: a(ze),
      reference: L,
      referenceString: s,
      resourceDestinationString: s,
      resourceTitleString: s,
      setextHeading: a(Xe),
      strong: a(qr),
      thematicBreak: a(gi)
    },
    exit: {
      atxHeading: c(),
      atxHeadingSequence: M,
      autolink: c(),
      autolinkEmail: ye,
      autolinkProtocol: le,
      blockQuote: c(),
      characterEscapeValue: R,
      characterReferenceMarkerHexadecimal: he,
      characterReferenceMarkerNumeric: he,
      characterReferenceValue: oe,
      characterReference: de,
      codeFenced: c(S),
      codeFencedFence: v,
      codeFencedFenceInfo: y,
      codeFencedFenceMeta: w,
      codeFlowValue: R,
      codeIndented: c(E),
      codeText: c(V),
      codeTextData: R,
      data: R,
      definition: c(),
      definitionDestinationString: A,
      definitionLabelString: T,
      definitionTitleString: k,
      emphasis: c(),
      hardBreakEscape: c(U),
      hardBreakTrailing: c(U),
      htmlFlow: c(W),
      htmlFlowData: R,
      htmlText: c(j),
      htmlTextData: R,
      image: c(H),
      label: G,
      labelText: q,
      lineEnding: F,
      link: c(I),
      listItem: c(),
      listOrdered: c(),
      listUnordered: c(),
      paragraph: c(),
      referenceString: te,
      resourceDestinationString: O,
      resourceTitleString: Y,
      resource: Z,
      setextHeading: c(z),
      setextHeadingLineSequence: P,
      setextHeadingText: N,
      strong: c(),
      thematicBreak: c()
    }
  };
  EP(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(ae) {
    let pe = {
      type: "root",
      children: []
    };
    const Ce = {
      stack: [pe],
      tokenStack: [],
      config: t,
      enter: u,
      exit: f,
      buffer: s,
      resume: h,
      data: n
    }, De = [];
    let et = -1;
    for (; ++et < ae.length; )
      if (ae[et][1].type === "listOrdered" || ae[et][1].type === "listUnordered")
        if (ae[et][0] === "enter")
          De.push(et);
        else {
          const wn = De.pop();
          et = o(ae, wn, et);
        }
    for (et = -1; ++et < ae.length; ) {
      const wn = t[ae[et][0]];
      SP.call(wn, ae[et][1].type) && wn[ae[et][1].type].call(Object.assign({
        sliceSerialize: ae[et][2].sliceSerialize
      }, Ce), ae[et][1]);
    }
    if (Ce.tokenStack.length > 0) {
      const wn = Ce.tokenStack[Ce.tokenStack.length - 1];
      (wn[1] || TR).call(Ce, void 0, wn[0]);
    }
    for (pe.position = {
      start: qi(ae.length > 0 ? ae[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: qi(ae.length > 0 ? ae[ae.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, et = -1; ++et < t.transforms.length; )
      pe = t.transforms[et](pe) || pe;
    return pe;
  }
  function o(ae, pe, Ce) {
    let De = pe - 1, et = -1, wn = !1, Ar, fn, dr, _n;
    for (; ++De <= Ce; ) {
      const $t = ae[De];
      switch ($t[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          $t[0] === "enter" ? et++ : et--, _n = void 0;
          break;
        }
        case "lineEndingBlank": {
          $t[0] === "enter" && (Ar && !_n && !et && !dr && (dr = De), _n = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          _n = void 0;
      }
      if (!et && $t[0] === "enter" && $t[1].type === "listItemPrefix" || et === -1 && $t[0] === "exit" && ($t[1].type === "listUnordered" || $t[1].type === "listOrdered")) {
        if (Ar) {
          let Rn = De;
          for (fn = void 0; Rn--; ) {
            const Gn = ae[Rn];
            if (Gn[1].type === "lineEnding" || Gn[1].type === "lineEndingBlank") {
              if (Gn[0] === "exit") continue;
              fn && (ae[fn][1].type = "lineEndingBlank", wn = !0), Gn[1].type = "lineEnding", fn = Rn;
            } else if (!(Gn[1].type === "linePrefix" || Gn[1].type === "blockQuotePrefix" || Gn[1].type === "blockQuotePrefixWhitespace" || Gn[1].type === "blockQuoteMarker" || Gn[1].type === "listItemIndent")) break;
          }
          dr && (!fn || dr < fn) && (Ar._spread = !0), Ar.end = Object.assign({}, fn ? ae[fn][1].start : $t[1].end), ae.splice(fn || De, 0, ["exit", Ar, $t[2]]), De++, Ce++;
        }
        if ($t[1].type === "listItemPrefix") {
          const Rn = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, $t[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          Ar = Rn, ae.splice(De, 0, ["enter", Rn, $t[2]]), De++, Ce++, dr = void 0, _n = !0;
        }
      }
    }
    return ae[pe][1]._spread = wn, Ce;
  }
  function a(ae, pe) {
    return Ce;
    function Ce(De) {
      u.call(this, ae(De), De), pe && pe.call(this, De);
    }
  }
  function s() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function u(ae, pe, Ce) {
    this.stack[this.stack.length - 1].children.push(ae), this.stack.push(ae), this.tokenStack.push([pe, Ce || void 0]), ae.position = {
      start: qi(pe.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function c(ae) {
    return pe;
    function pe(Ce) {
      ae && ae.call(this, Ce), f.call(this, Ce);
    }
  }
  function f(ae, pe) {
    const Ce = this.stack.pop(), De = this.tokenStack.pop();
    if (De)
      De[0].type !== ae.type && (pe ? pe.call(this, ae, De[0]) : (De[1] || TR).call(this, ae, De[0]));
    else throw new Error("Cannot close `" + ae.type + "` (" + Sc({
      start: ae.start,
      end: ae.end
    }) + "): its not open");
    Ce.position.end = qi(ae.end);
  }
  function h() {
    return hw(this.stack.pop());
  }
  function p() {
    this.data.expectingFirstListItemValue = !0;
  }
  function g(ae) {
    if (this.data.expectingFirstListItemValue) {
      const pe = this.stack[this.stack.length - 2];
      pe.start = Number.parseInt(this.sliceSerialize(ae), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function y() {
    const ae = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.lang = ae;
  }
  function w() {
    const ae = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.meta = ae;
  }
  function v() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function S() {
    const ae = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.value = ae.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function E() {
    const ae = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.value = ae.replace(/(\r?\n|\r)$/g, "");
  }
  function T(ae) {
    const pe = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.label = pe, Ce.identifier = zr(this.sliceSerialize(ae)).toLowerCase();
  }
  function k() {
    const ae = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.title = ae;
  }
  function A() {
    const ae = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.url = ae;
  }
  function M(ae) {
    const pe = this.stack[this.stack.length - 1];
    if (!pe.depth) {
      const Ce = this.sliceSerialize(ae).length;
      pe.depth = Ce;
    }
  }
  function N() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function P(ae) {
    const pe = this.stack[this.stack.length - 1];
    pe.depth = this.sliceSerialize(ae).codePointAt(0) === 61 ? 1 : 2;
  }
  function z() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function B(ae) {
    const Ce = this.stack[this.stack.length - 1].children;
    let De = Ce[Ce.length - 1];
    (!De || De.type !== "text") && (De = ca(), De.position = {
      start: qi(ae.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, Ce.push(De)), this.stack.push(De);
  }
  function R(ae) {
    const pe = this.stack.pop();
    pe.value += this.sliceSerialize(ae), pe.position.end = qi(ae.end);
  }
  function F(ae) {
    const pe = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const Ce = pe.children[pe.children.length - 1];
      Ce.position.end = qi(ae.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(pe.type) && (B.call(this, ae), R.call(this, ae));
  }
  function U() {
    this.data.atHardBreak = !0;
  }
  function W() {
    const ae = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.value = ae;
  }
  function j() {
    const ae = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.value = ae;
  }
  function V() {
    const ae = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.value = ae;
  }
  function I() {
    const ae = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const pe = this.data.referenceType || "shortcut";
      ae.type += "Reference", ae.referenceType = pe, delete ae.url, delete ae.title;
    } else
      delete ae.identifier, delete ae.label;
    this.data.referenceType = void 0;
  }
  function H() {
    const ae = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const pe = this.data.referenceType || "shortcut";
      ae.type += "Reference", ae.referenceType = pe, delete ae.url, delete ae.title;
    } else
      delete ae.identifier, delete ae.label;
    this.data.referenceType = void 0;
  }
  function q(ae) {
    const pe = this.sliceSerialize(ae), Ce = this.stack[this.stack.length - 2];
    Ce.label = Ice(pe), Ce.identifier = zr(pe).toLowerCase();
  }
  function G() {
    const ae = this.stack[this.stack.length - 1], pe = this.resume(), Ce = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, Ce.type === "link") {
      const De = ae.children;
      Ce.children = De;
    } else
      Ce.alt = pe;
  }
  function O() {
    const ae = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.url = ae;
  }
  function Y() {
    const ae = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.title = ae;
  }
  function Z() {
    this.data.inReference = void 0;
  }
  function L() {
    this.data.referenceType = "collapsed";
  }
  function te(ae) {
    const pe = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.label = pe, Ce.identifier = zr(this.sliceSerialize(ae)).toLowerCase(), this.data.referenceType = "full";
  }
  function he(ae) {
    this.data.characterReferenceType = ae.type;
  }
  function oe(ae) {
    const pe = this.sliceSerialize(ae), Ce = this.data.characterReferenceType;
    let De;
    Ce ? (De = hP(pe, Ce === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : De = pw(pe);
    const et = this.stack[this.stack.length - 1];
    et.value += De;
  }
  function de(ae) {
    const pe = this.stack.pop();
    pe.position.end = qi(ae.end);
  }
  function le(ae) {
    R.call(this, ae);
    const pe = this.stack[this.stack.length - 1];
    pe.url = this.sliceSerialize(ae);
  }
  function ye(ae) {
    R.call(this, ae);
    const pe = this.stack[this.stack.length - 1];
    pe.url = "mailto:" + this.sliceSerialize(ae);
  }
  function je() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function Ne() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function we() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function Ee() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function _e() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Xe() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function St() {
    return {
      type: "break"
    };
  }
  function ct() {
    return {
      type: "html",
      value: ""
    };
  }
  function cn() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function fr() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function Un(ae) {
    return {
      type: "list",
      ordered: ae.type === "listOrdered",
      start: null,
      spread: ae._spread,
      children: []
    };
  }
  function qn(ae) {
    return {
      type: "listItem",
      spread: ae._spread,
      checked: null,
      children: []
    };
  }
  function ze() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function qr() {
    return {
      type: "strong",
      children: []
    };
  }
  function ca() {
    return {
      type: "text",
      value: ""
    };
  }
  function gi() {
    return {
      type: "thematicBreak"
    };
  }
}
function qi(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function EP(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? EP(e, r) : $ce(e, r);
  }
}
function $ce(e, t) {
  let n;
  for (n in t)
    if (SP.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function TR(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + Sc({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + Sc({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + Sc({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function Bce(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return Lce(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function Hce(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Vce(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function Uce(e, t) {
  const n = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let o = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (o.data = { meta: t.meta }), e.patch(t, o), o = e.applyData(t, o), o = { type: "element", tagName: "pre", properties: {}, children: [o] }, e.patch(t, o), o;
}
function qce(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Gce(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Yce(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), o = Ul(r.toLowerCase()), a = e.footnoteOrder.indexOf(r);
  let s, u = e.footnoteCounts.get(r);
  u === void 0 ? (u = 0, e.footnoteOrder.push(r), s = e.footnoteOrder.length) : s = a + 1, u += 1, e.footnoteCounts.set(r, u);
  const c = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + o,
      id: n + "fnref-" + o + (u > 1 ? "-" + u : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(s) }]
  };
  e.patch(t, c);
  const f = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [c]
  };
  return e.patch(t, f), e.applyData(t, f);
}
function Wce(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Xce(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function CP(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const o = e.all(t), a = o[0];
  a && a.type === "text" ? a.value = "[" + a.value : o.unshift({ type: "text", value: "[" });
  const s = o[o.length - 1];
  return s && s.type === "text" ? s.value += r : o.push({ type: "text", value: r }), o;
}
function Kce(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return CP(e, t);
  const o = { src: Ul(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (o.title = r.title);
  const a = { type: "element", tagName: "img", properties: o, children: [] };
  return e.patch(t, a), e.applyData(t, a);
}
function Zce(e, t) {
  const n = { src: Ul(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function Qce(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function Jce(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return CP(e, t);
  const o = { href: Ul(r.url || "") };
  r.title !== null && r.title !== void 0 && (o.title = r.title);
  const a = {
    type: "element",
    tagName: "a",
    properties: o,
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function efe(e, t) {
  const n = { href: Ul(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function tfe(e, t, n) {
  const r = e.all(t), o = n ? nfe(n) : kP(t), a = {}, s = [];
  if (typeof t.checked == "boolean") {
    const h = r[0];
    let p;
    h && h.type === "element" && h.tagName === "p" ? p = h : (p = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(p)), p.children.length > 0 && p.children.unshift({ type: "text", value: " " }), p.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), a.className = ["task-list-item"];
  }
  let u = -1;
  for (; ++u < r.length; ) {
    const h = r[u];
    (o || u !== 0 || h.type !== "element" || h.tagName !== "p") && s.push({ type: "text", value: `
` }), h.type === "element" && h.tagName === "p" && !o ? s.push(...h.children) : s.push(h);
  }
  const c = r[r.length - 1];
  c && (o || c.type !== "element" || c.tagName !== "p") && s.push({ type: "text", value: `
` });
  const f = { type: "element", tagName: "li", properties: a, children: s };
  return e.patch(t, f), e.applyData(t, f);
}
function nfe(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = kP(n[r]);
  }
  return t;
}
function kP(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function rfe(e, t) {
  const n = {}, r = e.all(t);
  let o = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++o < r.length; ) {
    const s = r[o];
    if (s.type === "element" && s.tagName === "li" && s.properties && Array.isArray(s.properties.className) && s.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const a = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function ofe(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function ife(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function afe(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function sfe(e, t) {
  const n = e.all(t), r = n.shift(), o = [];
  if (r) {
    const s = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], s), o.push(s);
  }
  if (n.length > 0) {
    const s = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, u = uw(t.children[1]), c = iP(t.children[t.children.length - 1]);
    u && c && (s.position = { start: u, end: c }), o.push(s);
  }
  const a = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(o, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function lfe(e, t, n) {
  const r = n ? n.children : void 0, a = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", s = n && n.type === "table" ? n.align : void 0, u = s ? s.length : t.children.length;
  let c = -1;
  const f = [];
  for (; ++c < u; ) {
    const p = t.children[c], g = {}, y = s ? s[c] : void 0;
    y && (g.align = y);
    let w = { type: "element", tagName: a, properties: g, children: [] };
    p && (w.children = e.all(p), e.patch(p, w), w = e.applyData(p, w)), f.push(w);
  }
  const h = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(f, !0)
  };
  return e.patch(t, h), e.applyData(t, h);
}
function ufe(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const AR = 9, RR = 32;
function cfe(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), o = 0;
  const a = [];
  for (; r; )
    a.push(
      MR(t.slice(o, r.index), o > 0, !0),
      r[0]
    ), o = r.index + r[0].length, r = n.exec(t);
  return a.push(MR(t.slice(o), o > 0, !1)), a.join("");
}
function MR(e, t, n) {
  let r = 0, o = e.length;
  if (t) {
    let a = e.codePointAt(r);
    for (; a === AR || a === RR; )
      r++, a = e.codePointAt(r);
  }
  if (n) {
    let a = e.codePointAt(o - 1);
    for (; a === AR || a === RR; )
      o--, a = e.codePointAt(o - 1);
  }
  return o > r ? e.slice(r, o) : "";
}
function ffe(e, t) {
  const n = { type: "text", value: cfe(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function dfe(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const hfe = {
  blockquote: Hce,
  break: Vce,
  code: Uce,
  delete: qce,
  emphasis: Gce,
  footnoteReference: Yce,
  heading: Wce,
  html: Xce,
  imageReference: Kce,
  image: Zce,
  inlineCode: Qce,
  linkReference: Jce,
  link: efe,
  listItem: tfe,
  list: rfe,
  paragraph: ofe,
  // @ts-expect-error: root is different, but hard to type.
  root: ife,
  strong: afe,
  table: sfe,
  tableCell: ufe,
  tableRow: lfe,
  text: ffe,
  thematicBreak: dfe,
  toml: _h,
  yaml: _h,
  definition: _h,
  footnoteDefinition: _h
};
function _h() {
}
const TP = -1, Qm = 0, Cc = 1, Pp = 2, gw = 3, yw = 4, vw = 5, bw = 6, AP = 7, RP = 8, OR = typeof self == "object" ? self : globalThis, pfe = (e, t) => {
  const n = (o, a) => (e.set(a, o), o), r = (o) => {
    if (e.has(o))
      return e.get(o);
    const [a, s] = t[o];
    switch (a) {
      case Qm:
      case TP:
        return n(s, o);
      case Cc: {
        const u = n([], o);
        for (const c of s)
          u.push(r(c));
        return u;
      }
      case Pp: {
        const u = n({}, o);
        for (const [c, f] of s)
          u[r(c)] = r(f);
        return u;
      }
      case gw:
        return n(new Date(s), o);
      case yw: {
        const { source: u, flags: c } = s;
        return n(new RegExp(u, c), o);
      }
      case vw: {
        const u = n(/* @__PURE__ */ new Map(), o);
        for (const [c, f] of s)
          u.set(r(c), r(f));
        return u;
      }
      case bw: {
        const u = n(/* @__PURE__ */ new Set(), o);
        for (const c of s)
          u.add(r(c));
        return u;
      }
      case AP: {
        const { name: u, message: c } = s;
        return n(new OR[u](c), o);
      }
      case RP:
        return n(BigInt(s), o);
      case "BigInt":
        return n(Object(BigInt(s)), o);
      case "ArrayBuffer":
        return n(new Uint8Array(s).buffer, s);
      case "DataView": {
        const { buffer: u } = new Uint8Array(s);
        return n(new DataView(u), s);
      }
    }
    return n(new OR[a](s), o);
  };
  return r;
}, NR = (e) => pfe(/* @__PURE__ */ new Map(), e)(0), Js = "", { toString: mfe } = {}, { keys: gfe } = Object, lc = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [Qm, t];
  const n = mfe.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [Cc, Js];
    case "Object":
      return [Pp, Js];
    case "Date":
      return [gw, Js];
    case "RegExp":
      return [yw, Js];
    case "Map":
      return [vw, Js];
    case "Set":
      return [bw, Js];
    case "DataView":
      return [Cc, n];
  }
  return n.includes("Array") ? [Cc, n] : n.includes("Error") ? [AP, n] : [Pp, n];
}, Sh = ([e, t]) => e === Qm && (t === "function" || t === "symbol"), yfe = (e, t, n, r) => {
  const o = (s, u) => {
    const c = r.push(s) - 1;
    return n.set(u, c), c;
  }, a = (s) => {
    if (n.has(s))
      return n.get(s);
    let [u, c] = lc(s);
    switch (u) {
      case Qm: {
        let h = s;
        switch (c) {
          case "bigint":
            u = RP, h = s.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + c);
            h = null;
            break;
          case "undefined":
            return o([TP], s);
        }
        return o([u, h], s);
      }
      case Cc: {
        if (c) {
          let g = s;
          return c === "DataView" ? g = new Uint8Array(s.buffer) : c === "ArrayBuffer" && (g = new Uint8Array(s)), o([c, [...g]], s);
        }
        const h = [], p = o([u, h], s);
        for (const g of s)
          h.push(a(g));
        return p;
      }
      case Pp: {
        if (c)
          switch (c) {
            case "BigInt":
              return o([c, s.toString()], s);
            case "Boolean":
            case "Number":
            case "String":
              return o([c, s.valueOf()], s);
          }
        if (t && "toJSON" in s)
          return a(s.toJSON());
        const h = [], p = o([u, h], s);
        for (const g of gfe(s))
          (e || !Sh(lc(s[g]))) && h.push([a(g), a(s[g])]);
        return p;
      }
      case gw:
        return o([u, s.toISOString()], s);
      case yw: {
        const { source: h, flags: p } = s;
        return o([u, { source: h, flags: p }], s);
      }
      case vw: {
        const h = [], p = o([u, h], s);
        for (const [g, y] of s)
          (e || !(Sh(lc(g)) || Sh(lc(y)))) && h.push([a(g), a(y)]);
        return p;
      }
      case bw: {
        const h = [], p = o([u, h], s);
        for (const g of s)
          (e || !Sh(lc(g))) && h.push(a(g));
        return p;
      }
    }
    const { message: f } = s;
    return o([u, { name: c, message: f }], s);
  };
  return a;
}, DR = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return yfe(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, jp = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? NR(DR(e, t)) : structuredClone(e)
) : (e, t) => NR(DR(e, t));
function vfe(e, t) {
  const n = [{ type: "text", value: "" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function bfe(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function xfe(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || vfe, r = e.options.footnoteBackLabel || bfe, o = e.options.footnoteLabel || "Footnotes", a = e.options.footnoteLabelTagName || "h2", s = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, u = [];
  let c = -1;
  for (; ++c < e.footnoteOrder.length; ) {
    const f = e.footnoteById.get(
      e.footnoteOrder[c]
    );
    if (!f)
      continue;
    const h = e.all(f), p = String(f.identifier).toUpperCase(), g = Ul(p.toLowerCase());
    let y = 0;
    const w = [], v = e.footnoteCounts.get(p);
    for (; v !== void 0 && ++y <= v; ) {
      w.length > 0 && w.push({ type: "text", value: " " });
      let T = typeof n == "string" ? n : n(c, y);
      typeof T == "string" && (T = { type: "text", value: T }), w.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + g + (y > 1 ? "-" + y : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(c, y),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(T) ? T : [T]
      });
    }
    const S = h[h.length - 1];
    if (S && S.type === "element" && S.tagName === "p") {
      const T = S.children[S.children.length - 1];
      T && T.type === "text" ? T.value += " " : S.children.push({ type: "text", value: " " }), S.children.push(...w);
    } else
      h.push(...w);
    const E = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + g },
      children: e.wrap(h, !0)
    };
    e.patch(f, E), u.push(E);
  }
  if (u.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: a,
          properties: {
            ...jp(s),
            id: "footnote-label"
          },
          children: [{ type: "text", value: o }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(u, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const Jm = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return Efe;
    if (typeof e == "function")
      return eg(e);
    if (typeof e == "object")
      return Array.isArray(e) ? wfe(e) : _fe(e);
    if (typeof e == "string")
      return Sfe(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function wfe(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = Jm(e[n]);
  return eg(r);
  function r(...o) {
    let a = -1;
    for (; ++a < t.length; )
      if (t[a].apply(this, o)) return !0;
    return !1;
  }
}
function _fe(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return eg(n);
  function n(r) {
    const o = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let a;
    for (a in e)
      if (o[a] !== t[a]) return !1;
    return !0;
  }
}
function Sfe(e) {
  return eg(t);
  function t(n) {
    return n && n.type === e;
  }
}
function eg(e) {
  return t;
  function t(n, r, o) {
    return !!(Cfe(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      o || void 0
    ));
  }
}
function Efe() {
  return !0;
}
function Cfe(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const MP = [], kfe = !0, t1 = !1, Tfe = "skip";
function OP(e, t, n, r) {
  let o;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : o = t;
  const a = Jm(o), s = r ? -1 : 1;
  u(e, void 0, [])();
  function u(c, f, h) {
    const p = (
      /** @type {Record<string, unknown>} */
      c && typeof c == "object" ? c : {}
    );
    if (typeof p.type == "string") {
      const y = (
        // `hast`
        typeof p.tagName == "string" ? p.tagName : (
          // `xast`
          typeof p.name == "string" ? p.name : void 0
        )
      );
      Object.defineProperty(g, "name", {
        value: "node (" + (c.type + (y ? "<" + y + ">" : "")) + ")"
      });
    }
    return g;
    function g() {
      let y = MP, w, v, S;
      if ((!t || a(c, f, h[h.length - 1] || void 0)) && (y = Afe(n(c, h)), y[0] === t1))
        return y;
      if ("children" in c && c.children) {
        const E = (
          /** @type {UnistParent} */
          c
        );
        if (E.children && y[0] !== Tfe)
          for (v = (r ? E.children.length : -1) + s, S = h.concat(E); v > -1 && v < E.children.length; ) {
            const T = E.children[v];
            if (w = u(T, v, S)(), w[0] === t1)
              return w;
            v = typeof w[1] == "number" ? w[1] : v + s;
          }
      }
      return y;
    }
  }
}
function Afe(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [kfe, e] : e == null ? MP : [e];
}
function xw(e, t, n, r) {
  let o, a, s;
  typeof t == "function" && typeof n != "function" ? (a = void 0, s = t, o = n) : (a = t, s = n, o = r), OP(e, a, u, o);
  function u(c, f) {
    const h = f[f.length - 1], p = h ? h.children.indexOf(c) : void 0;
    return s(c, p, h);
  }
}
const n1 = {}.hasOwnProperty, Rfe = {};
function Mfe(e, t) {
  const n = t || Rfe, r = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), s = { ...hfe, ...n.handlers }, u = {
    all: f,
    applyData: Nfe,
    definitionById: r,
    footnoteById: o,
    footnoteCounts: a,
    footnoteOrder: [],
    handlers: s,
    one: c,
    options: n,
    patch: Ofe,
    wrap: Pfe
  };
  return xw(e, function(h) {
    if (h.type === "definition" || h.type === "footnoteDefinition") {
      const p = h.type === "definition" ? r : o, g = String(h.identifier).toUpperCase();
      p.has(g) || p.set(g, h);
    }
  }), u;
  function c(h, p) {
    const g = h.type, y = u.handlers[g];
    if (n1.call(u.handlers, g) && y)
      return y(u, h, p);
    if (u.options.passThrough && u.options.passThrough.includes(g)) {
      if ("children" in h) {
        const { children: v, ...S } = h, E = jp(S);
        return E.children = u.all(h), E;
      }
      return jp(h);
    }
    return (u.options.unknownHandler || Dfe)(u, h, p);
  }
  function f(h) {
    const p = [];
    if ("children" in h) {
      const g = h.children;
      let y = -1;
      for (; ++y < g.length; ) {
        const w = u.one(g[y], h);
        if (w) {
          if (y && g[y - 1].type === "break" && (!Array.isArray(w) && w.type === "text" && (w.value = PR(w.value)), !Array.isArray(w) && w.type === "element")) {
            const v = w.children[0];
            v && v.type === "text" && (v.value = PR(v.value));
          }
          Array.isArray(w) ? p.push(...w) : p.push(w);
        }
      }
    }
    return p;
  }
}
function Ofe(e, t) {
  e.position && (t.position = ble(e));
}
function Nfe(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, o = e.data.hChildren, a = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const s = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: s };
      }
    n.type === "element" && a && Object.assign(n.properties, jp(a)), "children" in n && n.children && o !== null && o !== void 0 && (n.children = o);
  }
  return n;
}
function Dfe(e, t) {
  const n = t.data || {}, r = "value" in t && !(n1.call(n, "hProperties") || n1.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function Pfe(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function PR(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function jR(e, t) {
  const n = Mfe(e, t), r = n.one(e, void 0), o = xfe(n), a = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return o && a.children.push({ type: "text", value: `
` }, o), a;
}
function jfe(e, t) {
  return e && "run" in e ? async function(n, r) {
    const o = (
      /** @type {HastRoot} */
      jR(n, { file: r, ...t })
    );
    await e.run(o, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      jR(n, { file: r, ...e || t })
    );
  };
}
function IR(e) {
  if (e)
    throw e;
}
var Ev, zR;
function Ife() {
  if (zR) return Ev;
  zR = 1;
  var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString, n = Object.defineProperty, r = Object.getOwnPropertyDescriptor, o = function(f) {
    return typeof Array.isArray == "function" ? Array.isArray(f) : t.call(f) === "[object Array]";
  }, a = function(f) {
    if (!f || t.call(f) !== "[object Object]")
      return !1;
    var h = e.call(f, "constructor"), p = f.constructor && f.constructor.prototype && e.call(f.constructor.prototype, "isPrototypeOf");
    if (f.constructor && !h && !p)
      return !1;
    var g;
    for (g in f)
      ;
    return typeof g > "u" || e.call(f, g);
  }, s = function(f, h) {
    n && h.name === "__proto__" ? n(f, h.name, {
      enumerable: !0,
      configurable: !0,
      value: h.newValue,
      writable: !0
    }) : f[h.name] = h.newValue;
  }, u = function(f, h) {
    if (h === "__proto__")
      if (e.call(f, h)) {
        if (r)
          return r(f, h).value;
      } else return;
    return f[h];
  };
  return Ev = function c() {
    var f, h, p, g, y, w, v = arguments[0], S = 1, E = arguments.length, T = !1;
    for (typeof v == "boolean" && (T = v, v = arguments[1] || {}, S = 2), (v == null || typeof v != "object" && typeof v != "function") && (v = {}); S < E; ++S)
      if (f = arguments[S], f != null)
        for (h in f)
          p = u(v, h), g = u(f, h), v !== g && (T && g && (a(g) || (y = o(g))) ? (y ? (y = !1, w = p && o(p) ? p : []) : w = p && a(p) ? p : {}, s(v, { name: h, newValue: c(T, w, g) })) : typeof g < "u" && s(v, { name: h, newValue: g }));
    return v;
  }, Ev;
}
var zfe = Ife();
const Cv = /* @__PURE__ */ Nl(zfe);
function r1(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function Lfe() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...o) {
    let a = -1;
    const s = o.pop();
    if (typeof s != "function")
      throw new TypeError("Expected function as last argument, not " + s);
    u(null, ...o);
    function u(c, ...f) {
      const h = e[++a];
      let p = -1;
      if (c) {
        s(c);
        return;
      }
      for (; ++p < o.length; )
        (f[p] === null || f[p] === void 0) && (f[p] = o[p]);
      o = f, h ? Ffe(h, u)(...f) : s(null, ...f);
    }
  }
  function r(o) {
    if (typeof o != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + o
      );
    return e.push(o), t;
  }
}
function Ffe(e, t) {
  let n;
  return r;
  function r(...s) {
    const u = e.length > s.length;
    let c;
    u && s.push(o);
    try {
      c = e.apply(this, s);
    } catch (f) {
      const h = (
        /** @type {Error} */
        f
      );
      if (u && n)
        throw h;
      return o(h);
    }
    u || (c && c.then && typeof c.then == "function" ? c.then(a, o) : c instanceof Error ? o(c) : a(c));
  }
  function o(s, ...u) {
    n || (n = !0, t(s, ...u));
  }
  function a(s) {
    o(null, s);
  }
}
const no = { basename: $fe, dirname: Bfe, extname: Hfe, join: Vfe, sep: "/" };
function $fe(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  Tf(e);
  let n = 0, r = -1, o = e.length, a;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; o--; )
      if (e.codePointAt(o) === 47) {
        if (a) {
          n = o + 1;
          break;
        }
      } else r < 0 && (a = !0, r = o + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let s = -1, u = t.length - 1;
  for (; o--; )
    if (e.codePointAt(o) === 47) {
      if (a) {
        n = o + 1;
        break;
      }
    } else
      s < 0 && (a = !0, s = o + 1), u > -1 && (e.codePointAt(o) === t.codePointAt(u--) ? u < 0 && (r = o) : (u = -1, r = s));
  return n === r ? r = s : r < 0 && (r = e.length), e.slice(n, r);
}
function Bfe(e) {
  if (Tf(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function Hfe(e) {
  Tf(e);
  let t = e.length, n = -1, r = 0, o = -1, a = 0, s;
  for (; t--; ) {
    const u = e.codePointAt(t);
    if (u === 47) {
      if (s) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (s = !0, n = t + 1), u === 46 ? o < 0 ? o = t : a !== 1 && (a = 1) : o > -1 && (a = -1);
  }
  return o < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  a === 0 || // The (right-most) trimmed path component is exactly `..`.
  a === 1 && o === n - 1 && o === r + 1 ? "" : e.slice(o, n);
}
function Vfe(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    Tf(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : Ufe(n);
}
function Ufe(e) {
  Tf(e);
  const t = e.codePointAt(0) === 47;
  let n = qfe(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function qfe(e, t) {
  let n = "", r = 0, o = -1, a = 0, s = -1, u, c;
  for (; ++s <= e.length; ) {
    if (s < e.length)
      u = e.codePointAt(s);
    else {
      if (u === 47)
        break;
      u = 47;
    }
    if (u === 47) {
      if (!(o === s - 1 || a === 1)) if (o !== s - 1 && a === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (c = n.lastIndexOf("/"), c !== n.length - 1) {
              c < 0 ? (n = "", r = 0) : (n = n.slice(0, c), r = n.length - 1 - n.lastIndexOf("/")), o = s, a = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, o = s, a = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(o + 1, s) : n = e.slice(o + 1, s), r = s - o - 1;
      o = s, a = 0;
    } else u === 46 && a > -1 ? a++ : a = -1;
  }
  return n;
}
function Tf(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const Gfe = { cwd: Yfe };
function Yfe() {
  return "/";
}
function o1(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function Wfe(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!o1(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return Xfe(e);
}
function Xfe(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const o = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw o.code = "ERR_INVALID_FILE_URL_PATH", o;
      }
    }
  return decodeURIComponent(t);
}
const kv = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class NP {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? o1(t) ? n = { path: t } : typeof t == "string" || Kfe(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : Gfe.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < kv.length; ) {
      const a = kv[r];
      a in n && n[a] !== void 0 && n[a] !== null && (this[a] = a === "history" ? [...n[a]] : n[a]);
    }
    let o;
    for (o in n)
      kv.includes(o) || (this[o] = n[o]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? no.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    Av(t, "basename"), Tv(t, "basename"), this.path = no.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? no.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    LR(this.basename, "dirname"), this.path = no.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? no.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (Tv(t, "extname"), LR(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = no.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    o1(t) && (t = Wfe(t)), Av(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? no.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    Av(t, "stem"), Tv(t, "stem"), this.path = no.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const o = this.message(t, n, r);
    throw o.fatal = !0, o;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const o = this.message(t, n, r);
    return o.fatal = void 0, o;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const o = new xn(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (o.name = this.path + ":" + o.name, o.file = this.path), o.fatal = !1, this.messages.push(o), o;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function Tv(e, t) {
  if (e && e.includes(no.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + no.sep + "`"
    );
}
function Av(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function LR(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function Kfe(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const Zfe = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), o = r[e], a = function() {
      return o.apply(a, arguments);
    };
    return Object.setPrototypeOf(a, r), a;
  }
), Qfe = {}.hasOwnProperty;
class ww extends Zfe {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = Lfe();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new ww()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(Cv(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (Ov("data", this.frozen), this.namespace[t] = n, this) : Qfe.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (Ov("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const o = n.call(t, ...r);
      typeof o == "function" && this.transformers.use(o);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = Eh(t), r = this.parser || this.Parser;
    return Rv("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), Rv("process", this.parser || this.Parser), Mv("process", this.compiler || this.Compiler), n ? o(void 0, n) : new Promise(o);
    function o(a, s) {
      const u = Eh(t), c = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(u)
      );
      r.run(c, u, function(h, p, g) {
        if (h || !p || !g)
          return f(h);
        const y = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          p
        ), w = r.stringify(y, g);
        tde(w) ? g.value = w : g.result = w, f(
          h,
          /** @type {VFileWithOutput<CompileResult>} */
          g
        );
      });
      function f(h, p) {
        h || !p ? s(h) : a ? a(p) : n(void 0, p);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), Rv("processSync", this.parser || this.Parser), Mv("processSync", this.compiler || this.Compiler), this.process(t, o), $R("processSync", "process", n), r;
    function o(a, s) {
      n = !0, IR(a), r = s;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    FR(t), this.freeze();
    const o = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? a(void 0, r) : new Promise(a);
    function a(s, u) {
      const c = Eh(n);
      o.run(t, c, f);
      function f(h, p, g) {
        const y = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          p || t
        );
        h ? u(h) : s ? s(y) : r(void 0, y, g);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, o;
    return this.run(t, n, a), $R("runSync", "run", r), o;
    function a(s, u) {
      IR(s), o = u, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = Eh(n), o = this.compiler || this.Compiler;
    return Mv("stringify", o), FR(t), o(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, o = this.namespace;
    if (Ov("use", this.frozen), t != null) if (typeof t == "function")
      c(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? u(t) : s(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function a(f) {
      if (typeof f == "function")
        c(f, []);
      else if (typeof f == "object")
        if (Array.isArray(f)) {
          const [h, ...p] = (
            /** @type {PluginTuple<Array<unknown>>} */
            f
          );
          c(h, p);
        } else
          s(f);
      else
        throw new TypeError("Expected usable value, not `" + f + "`");
    }
    function s(f) {
      if (!("plugins" in f) && !("settings" in f))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      u(f.plugins), f.settings && (o.settings = Cv(!0, o.settings, f.settings));
    }
    function u(f) {
      let h = -1;
      if (f != null) if (Array.isArray(f))
        for (; ++h < f.length; ) {
          const p = f[h];
          a(p);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + f + "`");
    }
    function c(f, h) {
      let p = -1, g = -1;
      for (; ++p < r.length; )
        if (r[p][0] === f) {
          g = p;
          break;
        }
      if (g === -1)
        r.push([f, ...h]);
      else if (h.length > 0) {
        let [y, ...w] = h;
        const v = r[g][1];
        r1(v) && r1(y) && (y = Cv(!0, v, y)), r[g] = [f, y, ...w];
      }
    }
  }
}
const Jfe = new ww().freeze();
function Rv(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function Mv(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function Ov(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function FR(e) {
  if (!r1(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function $R(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function Eh(e) {
  return ede(e) ? e : new NP(e);
}
function ede(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function tde(e) {
  return typeof e == "string" || nde(e);
}
function nde(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const rde = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", BR = [], HR = { allowDangerousHtml: !0 }, ode = /^(https?|ircs?|mailto|xmpp)$/i, ide = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  { from: "className", id: "remove-classname" },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function ade(e) {
  const t = sde(e), n = lde(e);
  return ude(t.runSync(t.parse(n), n), e);
}
function sde(e) {
  const t = e.rehypePlugins || BR, n = e.remarkPlugins || BR, r = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...HR } : HR;
  return Jfe().use(Bce).use(n).use(jfe, r).use(t);
}
function lde(e) {
  const t = e.children || "", n = new NP();
  return typeof t == "string" && (n.value = t), n;
}
function ude(e, t) {
  const n = t.allowedElements, r = t.allowElement, o = t.components, a = t.disallowedElements, s = t.skipHtml, u = t.unwrapDisallowed, c = t.urlTransform || cde;
  for (const h of ide)
    Object.hasOwn(t, h.from) && ("" + h.from + (h.to ? "use `" + h.to + "` instead" : "remove it") + rde + h.id, void 0);
  return xw(e, f), Ele(e, {
    Fragment: x.Fragment,
    components: o,
    ignoreInvalidStyle: !0,
    jsx: x.jsx,
    jsxs: x.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function f(h, p, g) {
    if (h.type === "raw" && g && typeof p == "number")
      return s ? g.children.splice(p, 1) : g.children[p] = { type: "text", value: h.value }, p;
    if (h.type === "element") {
      let y;
      for (y in wv)
        if (Object.hasOwn(wv, y) && Object.hasOwn(h.properties, y)) {
          const w = h.properties[y], v = wv[y];
          (v === null || v.includes(h.tagName)) && (h.properties[y] = c(String(w || ""), y, h));
        }
    }
    if (h.type === "element") {
      let y = n ? !n.includes(h.tagName) : a ? a.includes(h.tagName) : !1;
      if (!y && r && typeof p == "number" && (y = !r(h, p, g)), y && g && typeof p == "number")
        return u && h.children ? g.children.splice(p, 1, ...h.children) : g.children.splice(p, 1), p;
    }
  }
}
function cde(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), o = e.indexOf("/");
  return (
    // If there is no protocol, its relative.
    t === -1 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    o !== -1 && t > o || n !== -1 && t > n || r !== -1 && t > r || // It is a protocol, it should be allowed.
    ode.test(e.slice(0, t)) ? e : ""
  );
}
function VR(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, o = n.indexOf(t);
  for (; o !== -1; )
    r++, o = n.indexOf(t, o + t.length);
  return r;
}
function fde(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function dde(e, t, n) {
  const o = Jm((n || {}).ignore || []), a = hde(t);
  let s = -1;
  for (; ++s < a.length; )
    OP(e, "text", u);
  function u(f, h) {
    let p = -1, g;
    for (; ++p < h.length; ) {
      const y = h[p], w = g ? g.children : void 0;
      if (o(
        y,
        w ? w.indexOf(y) : void 0,
        g
      ))
        return;
      g = y;
    }
    if (g)
      return c(f, h);
  }
  function c(f, h) {
    const p = h[h.length - 1], g = a[s][0], y = a[s][1];
    let w = 0;
    const S = p.children.indexOf(f);
    let E = !1, T = [];
    g.lastIndex = 0;
    let k = g.exec(f.value);
    for (; k; ) {
      const A = k.index, M = {
        index: k.index,
        input: k.input,
        stack: [...h, f]
      };
      let N = y(...k, M);
      if (typeof N == "string" && (N = N.length > 0 ? { type: "text", value: N } : void 0), N === !1 ? g.lastIndex = A + 1 : (w !== A && T.push({
        type: "text",
        value: f.value.slice(w, A)
      }), Array.isArray(N) ? T.push(...N) : N && T.push(N), w = A + k[0].length, E = !0), !g.global)
        break;
      k = g.exec(f.value);
    }
    return E ? (w < f.value.length && T.push({ type: "text", value: f.value.slice(w) }), p.children.splice(S, 1, ...T)) : T = [f], S + T.length;
  }
}
function hde(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const o = n[r];
    t.push([pde(o[0]), mde(o[1])]);
  }
  return t;
}
function pde(e) {
  return typeof e == "string" ? new RegExp(fde(e), "g") : e;
}
function mde(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const Nv = "phrasing", Dv = ["autolink", "link", "image", "label"];
function gde() {
  return {
    transforms: [Sde],
    enter: {
      literalAutolink: vde,
      literalAutolinkEmail: Pv,
      literalAutolinkHttp: Pv,
      literalAutolinkWww: Pv
    },
    exit: {
      literalAutolink: _de,
      literalAutolinkEmail: wde,
      literalAutolinkHttp: bde,
      literalAutolinkWww: xde
    }
  };
}
function yde() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: Nv,
        notInConstruct: Dv
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: Nv,
        notInConstruct: Dv
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: Nv,
        notInConstruct: Dv
      }
    ]
  };
}
function vde(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function Pv(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function bde(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function xde(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function wde(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function _de(e) {
  this.exit(e);
}
function Sde(e) {
  dde(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, Ede],
      [/(?<=^|\s|\p{P}|\p{S})([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/gu, Cde]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function Ede(e, t, n, r, o) {
  let a = "";
  if (!DP(o) || (/^w/i.test(t) && (n = t + n, t = "", a = "http://"), !kde(n)))
    return !1;
  const s = Tde(n + r);
  if (!s[0]) return !1;
  const u = {
    type: "link",
    title: null,
    url: a + t + s[0],
    children: [{ type: "text", value: t + s[0] }]
  };
  return s[1] ? [u, { type: "text", value: s[1] }] : u;
}
function Cde(e, t, n, r) {
  return (
    // Not an expected previous character.
    !DP(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function kde(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function Tde(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const o = VR(e, "(");
  let a = VR(e, ")");
  for (; r !== -1 && o > a; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), a++;
  return [e, n];
}
function DP(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || Ja(n) || Km(n)) && // If its an email, the previous character should not be a slash.
  (!t || n !== 47);
}
PP.peek = Ide;
function Ade() {
  this.buffer();
}
function Rde(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function Mde() {
  this.buffer();
}
function Ode(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function Nde(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = zr(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function Dde(e) {
  this.exit(e);
}
function Pde(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = zr(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function jde(e) {
  this.exit(e);
}
function Ide() {
  return "[";
}
function PP(e, t, n, r) {
  const o = n.createTracker(r);
  let a = o.move("[^");
  const s = n.enter("footnoteReference"), u = n.enter("reference");
  return a += o.move(
    n.safe(n.associationId(e), { after: "]", before: a })
  ), u(), s(), a += o.move("]"), a;
}
function zde() {
  return {
    enter: {
      gfmFootnoteCallString: Ade,
      gfmFootnoteCall: Rde,
      gfmFootnoteDefinitionLabelString: Mde,
      gfmFootnoteDefinition: Ode
    },
    exit: {
      gfmFootnoteCallString: Nde,
      gfmFootnoteCall: Dde,
      gfmFootnoteDefinitionLabelString: Pde,
      gfmFootnoteDefinition: jde
    }
  };
}
function Lde(e) {
  let t = !1;
  return e && e.firstLineBlank && (t = !0), {
    handlers: { footnoteDefinition: n, footnoteReference: PP },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function n(r, o, a, s) {
    const u = a.createTracker(s);
    let c = u.move("[^");
    const f = a.enter("footnoteDefinition"), h = a.enter("label");
    return c += u.move(
      a.safe(a.associationId(r), { before: c, after: "]" })
    ), h(), c += u.move("]:"), r.children && r.children.length > 0 && (u.shift(4), c += u.move(
      (t ? `
` : " ") + a.indentLines(
        a.containerFlow(r, u.current()),
        t ? jP : Fde
      )
    )), f(), c;
  }
}
function Fde(e, t, n) {
  return t === 0 ? e : jP(e, t, n);
}
function jP(e, t, n) {
  return (n ? "" : "    ") + e;
}
const $de = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
IP.peek = qde;
function Bde() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: Vde },
    exit: { strikethrough: Ude }
  };
}
function Hde() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: $de
      }
    ],
    handlers: { delete: IP }
  };
}
function Vde(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function Ude(e) {
  this.exit(e);
}
function IP(e, t, n, r) {
  const o = n.createTracker(r), a = n.enter("strikethrough");
  let s = o.move("~~");
  return s += n.containerPhrasing(e, {
    ...o.current(),
    before: s,
    after: "~"
  }), s += o.move("~~"), a(), s;
}
function qde() {
  return "~";
}
function Gde(e) {
  return e.length;
}
function Yde(e, t) {
  const n = t || {}, r = (n.align || []).concat(), o = n.stringLength || Gde, a = [], s = [], u = [], c = [];
  let f = 0, h = -1;
  for (; ++h < e.length; ) {
    const v = [], S = [];
    let E = -1;
    for (e[h].length > f && (f = e[h].length); ++E < e[h].length; ) {
      const T = Wde(e[h][E]);
      if (n.alignDelimiters !== !1) {
        const k = o(T);
        S[E] = k, (c[E] === void 0 || k > c[E]) && (c[E] = k);
      }
      v.push(T);
    }
    s[h] = v, u[h] = S;
  }
  let p = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++p < f; )
      a[p] = UR(r[p]);
  else {
    const v = UR(r);
    for (; ++p < f; )
      a[p] = v;
  }
  p = -1;
  const g = [], y = [];
  for (; ++p < f; ) {
    const v = a[p];
    let S = "", E = "";
    v === 99 ? (S = ":", E = ":") : v === 108 ? S = ":" : v === 114 && (E = ":");
    let T = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      c[p] - S.length - E.length
    );
    const k = S + "-".repeat(T) + E;
    n.alignDelimiters !== !1 && (T = S.length + T + E.length, T > c[p] && (c[p] = T), y[p] = T), g[p] = k;
  }
  s.splice(1, 0, g), u.splice(1, 0, y), h = -1;
  const w = [];
  for (; ++h < s.length; ) {
    const v = s[h], S = u[h];
    p = -1;
    const E = [];
    for (; ++p < f; ) {
      const T = v[p] || "";
      let k = "", A = "";
      if (n.alignDelimiters !== !1) {
        const M = c[p] - (S[p] || 0), N = a[p];
        N === 114 ? k = " ".repeat(M) : N === 99 ? M % 2 ? (k = " ".repeat(M / 2 + 0.5), A = " ".repeat(M / 2 - 0.5)) : (k = " ".repeat(M / 2), A = k) : A = " ".repeat(M);
      }
      n.delimiterStart !== !1 && !p && E.push("|"), n.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && T === "") && (n.delimiterStart !== !1 || p) && E.push(" "), n.alignDelimiters !== !1 && E.push(k), E.push(T), n.alignDelimiters !== !1 && E.push(A), n.padding !== !1 && E.push(" "), (n.delimiterEnd !== !1 || p !== f - 1) && E.push("|");
    }
    w.push(
      n.delimiterEnd === !1 ? E.join("").replace(/ +$/, "") : E.join("")
    );
  }
  return w.join(`
`);
}
function Wde(e) {
  return e == null ? "" : String(e);
}
function UR(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function Xde(e, t, n, r) {
  const o = n.enter("blockquote"), a = n.createTracker(r);
  a.move("> "), a.shift(2);
  const s = n.indentLines(
    n.containerFlow(e, a.current()),
    Kde
  );
  return o(), s;
}
function Kde(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function Zde(e, t) {
  return qR(e, t.inConstruct, !0) && !qR(e, t.notInConstruct, !1);
}
function qR(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function GR(e, t, n, r) {
  let o = -1;
  for (; ++o < n.unsafe.length; )
    if (n.unsafe[o].character === `
` && Zde(n.stack, n.unsafe[o]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function Qde(e, t) {
  const n = String(e);
  let r = n.indexOf(t), o = r, a = 0, s = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === o ? ++a > s && (s = a) : a = 1, o = r + t.length, r = n.indexOf(t, o);
  return s;
}
function Jde(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function ehe(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function the(e, t, n, r) {
  const o = ehe(n), a = e.value || "", s = o === "`" ? "GraveAccent" : "Tilde";
  if (Jde(e, n)) {
    const p = n.enter("codeIndented"), g = n.indentLines(a, nhe);
    return p(), g;
  }
  const u = n.createTracker(r), c = o.repeat(Math.max(Qde(a, o) + 1, 3)), f = n.enter("codeFenced");
  let h = u.move(c);
  if (e.lang) {
    const p = n.enter(`codeFencedLang${s}`);
    h += u.move(
      n.safe(e.lang, {
        before: h,
        after: " ",
        encode: ["`"],
        ...u.current()
      })
    ), p();
  }
  if (e.lang && e.meta) {
    const p = n.enter(`codeFencedMeta${s}`);
    h += u.move(" "), h += u.move(
      n.safe(e.meta, {
        before: h,
        after: `
`,
        encode: ["`"],
        ...u.current()
      })
    ), p();
  }
  return h += u.move(`
`), a && (h += u.move(a + `
`)), h += u.move(c), f(), h;
}
function nhe(e, t, n) {
  return (n ? "" : "    ") + e;
}
function _w(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function rhe(e, t, n, r) {
  const o = _w(n), a = o === '"' ? "Quote" : "Apostrophe", s = n.enter("definition");
  let u = n.enter("label");
  const c = n.createTracker(r);
  let f = c.move("[");
  return f += c.move(
    n.safe(n.associationId(e), {
      before: f,
      after: "]",
      ...c.current()
    })
  ), f += c.move("]: "), u(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (u = n.enter("destinationLiteral"), f += c.move("<"), f += c.move(
    n.safe(e.url, { before: f, after: ">", ...c.current() })
  ), f += c.move(">")) : (u = n.enter("destinationRaw"), f += c.move(
    n.safe(e.url, {
      before: f,
      after: e.title ? " " : `
`,
      ...c.current()
    })
  )), u(), e.title && (u = n.enter(`title${a}`), f += c.move(" " + o), f += c.move(
    n.safe(e.title, {
      before: f,
      after: o,
      ...c.current()
    })
  ), f += c.move(o), u()), s(), f;
}
function ohe(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function Zc(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function Ip(e, t, n) {
  const r = Ol(e), o = Ol(t);
  return r === void 0 ? o === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : o === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? o === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : o === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : o === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : o === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
zP.peek = ihe;
function zP(e, t, n, r) {
  const o = ohe(n), a = n.enter("emphasis"), s = n.createTracker(r), u = s.move(o);
  let c = s.move(
    n.containerPhrasing(e, {
      after: o,
      before: u,
      ...s.current()
    })
  );
  const f = c.charCodeAt(0), h = Ip(
    r.before.charCodeAt(r.before.length - 1),
    f,
    o
  );
  h.inside && (c = Zc(f) + c.slice(1));
  const p = c.charCodeAt(c.length - 1), g = Ip(r.after.charCodeAt(0), p, o);
  g.inside && (c = c.slice(0, -1) + Zc(p));
  const y = s.move(o);
  return a(), n.attentionEncodeSurroundingInfo = {
    after: g.outside,
    before: h.outside
  }, u + c + y;
}
function ihe(e, t, n) {
  return n.options.emphasis || "*";
}
function ahe(e, t) {
  let n = !1;
  return xw(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, t1;
  }), !!((!e.depth || e.depth < 3) && hw(e) && (t.options.setext || n));
}
function she(e, t, n, r) {
  const o = Math.max(Math.min(6, e.depth || 1), 1), a = n.createTracker(r);
  if (ahe(e, n)) {
    const h = n.enter("headingSetext"), p = n.enter("phrasing"), g = n.containerPhrasing(e, {
      ...a.current(),
      before: `
`,
      after: `
`
    });
    return p(), h(), g + `
` + (o === 1 ? "=" : "-").repeat(
      // The whole size
      g.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(g.lastIndexOf("\r"), g.lastIndexOf(`
`)) + 1)
    );
  }
  const s = "#".repeat(o), u = n.enter("headingAtx"), c = n.enter("phrasing");
  a.move(s + " ");
  let f = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...a.current()
  });
  return /^[\t ]/.test(f) && (f = Zc(f.charCodeAt(0)) + f.slice(1)), f = f ? s + " " + f : s, n.options.closeAtx && (f += " " + s), c(), u(), f;
}
LP.peek = lhe;
function LP(e) {
  return e.value || "";
}
function lhe() {
  return "<";
}
FP.peek = uhe;
function FP(e, t, n, r) {
  const o = _w(n), a = o === '"' ? "Quote" : "Apostrophe", s = n.enter("image");
  let u = n.enter("label");
  const c = n.createTracker(r);
  let f = c.move("![");
  return f += c.move(
    n.safe(e.alt, { before: f, after: "]", ...c.current() })
  ), f += c.move("]("), u(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (u = n.enter("destinationLiteral"), f += c.move("<"), f += c.move(
    n.safe(e.url, { before: f, after: ">", ...c.current() })
  ), f += c.move(">")) : (u = n.enter("destinationRaw"), f += c.move(
    n.safe(e.url, {
      before: f,
      after: e.title ? " " : ")",
      ...c.current()
    })
  )), u(), e.title && (u = n.enter(`title${a}`), f += c.move(" " + o), f += c.move(
    n.safe(e.title, {
      before: f,
      after: o,
      ...c.current()
    })
  ), f += c.move(o), u()), f += c.move(")"), s(), f;
}
function uhe() {
  return "!";
}
$P.peek = che;
function $P(e, t, n, r) {
  const o = e.referenceType, a = n.enter("imageReference");
  let s = n.enter("label");
  const u = n.createTracker(r);
  let c = u.move("![");
  const f = n.safe(e.alt, {
    before: c,
    after: "]",
    ...u.current()
  });
  c += u.move(f + "]["), s();
  const h = n.stack;
  n.stack = [], s = n.enter("reference");
  const p = n.safe(n.associationId(e), {
    before: c,
    after: "]",
    ...u.current()
  });
  return s(), n.stack = h, a(), o === "full" || !f || f !== p ? c += u.move(p + "]") : o === "shortcut" ? c = c.slice(0, -1) : c += u.move("]"), c;
}
function che() {
  return "!";
}
BP.peek = fhe;
function BP(e, t, n) {
  let r = e.value || "", o = "`", a = -1;
  for (; new RegExp("(^|[^`])" + o + "([^`]|$)").test(r); )
    o += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++a < n.unsafe.length; ) {
    const s = n.unsafe[a], u = n.compilePattern(s);
    let c;
    if (s.atBreak)
      for (; c = u.exec(r); ) {
        let f = c.index;
        r.charCodeAt(f) === 10 && r.charCodeAt(f - 1) === 13 && f--, r = r.slice(0, f) + " " + r.slice(c.index + 1);
      }
  }
  return o + r + o;
}
function fhe() {
  return "`";
}
function HP(e, t) {
  const n = hw(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
VP.peek = dhe;
function VP(e, t, n, r) {
  const o = _w(n), a = o === '"' ? "Quote" : "Apostrophe", s = n.createTracker(r);
  let u, c;
  if (HP(e, n)) {
    const h = n.stack;
    n.stack = [], u = n.enter("autolink");
    let p = s.move("<");
    return p += s.move(
      n.containerPhrasing(e, {
        before: p,
        after: ">",
        ...s.current()
      })
    ), p += s.move(">"), u(), n.stack = h, p;
  }
  u = n.enter("link"), c = n.enter("label");
  let f = s.move("[");
  return f += s.move(
    n.containerPhrasing(e, {
      before: f,
      after: "](",
      ...s.current()
    })
  ), f += s.move("]("), c(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (c = n.enter("destinationLiteral"), f += s.move("<"), f += s.move(
    n.safe(e.url, { before: f, after: ">", ...s.current() })
  ), f += s.move(">")) : (c = n.enter("destinationRaw"), f += s.move(
    n.safe(e.url, {
      before: f,
      after: e.title ? " " : ")",
      ...s.current()
    })
  )), c(), e.title && (c = n.enter(`title${a}`), f += s.move(" " + o), f += s.move(
    n.safe(e.title, {
      before: f,
      after: o,
      ...s.current()
    })
  ), f += s.move(o), c()), f += s.move(")"), u(), f;
}
function dhe(e, t, n) {
  return HP(e, n) ? "<" : "[";
}
UP.peek = hhe;
function UP(e, t, n, r) {
  const o = e.referenceType, a = n.enter("linkReference");
  let s = n.enter("label");
  const u = n.createTracker(r);
  let c = u.move("[");
  const f = n.containerPhrasing(e, {
    before: c,
    after: "]",
    ...u.current()
  });
  c += u.move(f + "]["), s();
  const h = n.stack;
  n.stack = [], s = n.enter("reference");
  const p = n.safe(n.associationId(e), {
    before: c,
    after: "]",
    ...u.current()
  });
  return s(), n.stack = h, a(), o === "full" || !f || f !== p ? c += u.move(p + "]") : o === "shortcut" ? c = c.slice(0, -1) : c += u.move("]"), c;
}
function hhe() {
  return "[";
}
function Sw(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function phe(e) {
  const t = Sw(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function mhe(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function qP(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function ghe(e, t, n, r) {
  const o = n.enter("list"), a = n.bulletCurrent;
  let s = e.ordered ? mhe(n) : Sw(n);
  const u = e.ordered ? s === "." ? ")" : "." : phe(n);
  let c = t && n.bulletLastUsed ? s === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const h = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (s === "*" || s === "-") && // Empty first list item:
      h && (!h.children || !h.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (c = !0), qP(n) === s && h
    ) {
      let p = -1;
      for (; ++p < e.children.length; ) {
        const g = e.children[p];
        if (g && g.type === "listItem" && g.children && g.children[0] && g.children[0].type === "thematicBreak") {
          c = !0;
          break;
        }
      }
    }
  }
  c && (s = u), n.bulletCurrent = s;
  const f = n.containerFlow(e, r);
  return n.bulletLastUsed = s, n.bulletCurrent = a, o(), f;
}
function yhe(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function vhe(e, t, n, r) {
  const o = yhe(n);
  let a = n.bulletCurrent || Sw(n);
  t && t.type === "list" && t.ordered && (a = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + a);
  let s = a.length + 1;
  (o === "tab" || o === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (s = Math.ceil(s / 4) * 4);
  const u = n.createTracker(r);
  u.move(a + " ".repeat(s - a.length)), u.shift(s);
  const c = n.enter("listItem"), f = n.indentLines(
    n.containerFlow(e, u.current()),
    h
  );
  return c(), f;
  function h(p, g, y) {
    return g ? (y ? "" : " ".repeat(s)) + p : (y ? a : a + " ".repeat(s - a.length)) + p;
  }
}
function bhe(e, t, n, r) {
  const o = n.enter("paragraph"), a = n.enter("phrasing"), s = n.containerPhrasing(e, r);
  return a(), o(), s;
}
const xhe = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  Jm([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function whe(e, t, n, r) {
  return (e.children.some(function(s) {
    return xhe(s);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function _he(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
GP.peek = She;
function GP(e, t, n, r) {
  const o = _he(n), a = n.enter("strong"), s = n.createTracker(r), u = s.move(o + o);
  let c = s.move(
    n.containerPhrasing(e, {
      after: o,
      before: u,
      ...s.current()
    })
  );
  const f = c.charCodeAt(0), h = Ip(
    r.before.charCodeAt(r.before.length - 1),
    f,
    o
  );
  h.inside && (c = Zc(f) + c.slice(1));
  const p = c.charCodeAt(c.length - 1), g = Ip(r.after.charCodeAt(0), p, o);
  g.inside && (c = c.slice(0, -1) + Zc(p));
  const y = s.move(o + o);
  return a(), n.attentionEncodeSurroundingInfo = {
    after: g.outside,
    before: h.outside
  }, u + c + y;
}
function She(e, t, n) {
  return n.options.strong || "*";
}
function Ehe(e, t, n, r) {
  return n.safe(e.value, r);
}
function Che(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function khe(e, t, n) {
  const r = (qP(n) + (n.options.ruleSpaces ? " " : "")).repeat(Che(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const YP = {
  blockquote: Xde,
  break: GR,
  code: the,
  definition: rhe,
  emphasis: zP,
  hardBreak: GR,
  heading: she,
  html: LP,
  image: FP,
  imageReference: $P,
  inlineCode: BP,
  link: VP,
  linkReference: UP,
  list: ghe,
  listItem: vhe,
  paragraph: bhe,
  root: whe,
  strong: GP,
  text: Ehe,
  thematicBreak: khe
};
function The() {
  return {
    enter: {
      table: Ahe,
      tableData: YR,
      tableHeader: YR,
      tableRow: Mhe
    },
    exit: {
      codeText: Ohe,
      table: Rhe,
      tableData: jv,
      tableHeader: jv,
      tableRow: jv
    }
  };
}
function Ahe(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function Rhe(e) {
  this.exit(e), this.data.inTable = void 0;
}
function Mhe(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function jv(e) {
  this.exit(e);
}
function YR(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function Ohe(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, Nhe));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function Nhe(e, t) {
  return t === "|" ? t : e;
}
function Dhe(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, o = t.stringLength, a = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: g,
      table: s,
      tableCell: c,
      tableRow: u
    }
  };
  function s(y, w, v, S) {
    return f(h(y, v, S), y.align);
  }
  function u(y, w, v, S) {
    const E = p(y, v, S), T = f([E]);
    return T.slice(0, T.indexOf(`
`));
  }
  function c(y, w, v, S) {
    const E = v.enter("tableCell"), T = v.enter("phrasing"), k = v.containerPhrasing(y, {
      ...S,
      before: a,
      after: a
    });
    return T(), E(), k;
  }
  function f(y, w) {
    return Yde(y, {
      align: w,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: o
    });
  }
  function h(y, w, v) {
    const S = y.children;
    let E = -1;
    const T = [], k = w.enter("table");
    for (; ++E < S.length; )
      T[E] = p(S[E], w, v);
    return k(), T;
  }
  function p(y, w, v) {
    const S = y.children;
    let E = -1;
    const T = [], k = w.enter("tableRow");
    for (; ++E < S.length; )
      T[E] = c(S[E], y, w, v);
    return k(), T;
  }
  function g(y, w, v) {
    let S = YP.inlineCode(y, w, v);
    return v.stack.includes("tableCell") && (S = S.replace(/\|/g, "\\$&")), S;
  }
}
function Phe() {
  return {
    exit: {
      taskListCheckValueChecked: WR,
      taskListCheckValueUnchecked: WR,
      paragraph: Ihe
    }
  };
}
function jhe() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: zhe }
  };
}
function WR(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function Ihe(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const o = t.children;
      let a = -1, s;
      for (; ++a < o.length; ) {
        const u = o[a];
        if (u.type === "paragraph") {
          s = u;
          break;
        }
      }
      s === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function zhe(e, t, n, r) {
  const o = e.children[0], a = typeof e.checked == "boolean" && o && o.type === "paragraph", s = "[" + (e.checked ? "x" : " ") + "] ", u = n.createTracker(r);
  a && u.move(s);
  let c = YP.listItem(e, t, n, {
    ...r,
    ...u.current()
  });
  return a && (c = c.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, f)), c;
  function f(h) {
    return h + s;
  }
}
function Lhe() {
  return [
    gde(),
    zde(),
    Bde(),
    The(),
    Phe()
  ];
}
function Fhe(e) {
  return {
    extensions: [
      yde(),
      Lde(e),
      Hde(),
      Dhe(e),
      jhe()
    ]
  };
}
const $he = {
  tokenize: Ghe,
  partial: !0
}, WP = {
  tokenize: Yhe,
  partial: !0
}, XP = {
  tokenize: Whe,
  partial: !0
}, KP = {
  tokenize: Xhe,
  partial: !0
}, Bhe = {
  tokenize: Khe,
  partial: !0
}, ZP = {
  name: "wwwAutolink",
  tokenize: Uhe,
  previous: JP
}, QP = {
  name: "protocolAutolink",
  tokenize: qhe,
  previous: ej
}, mi = {
  name: "emailAutolink",
  tokenize: Vhe,
  previous: tj
}, Co = {};
function Hhe() {
  return {
    text: Co
  };
}
let Ma = 48;
for (; Ma < 123; )
  Co[Ma] = mi, Ma++, Ma === 58 ? Ma = 65 : Ma === 91 && (Ma = 97);
Co[43] = mi;
Co[45] = mi;
Co[46] = mi;
Co[95] = mi;
Co[72] = [mi, QP];
Co[104] = [mi, QP];
Co[87] = [mi, ZP];
Co[119] = [mi, ZP];
function Vhe(e, t, n) {
  const r = this;
  let o, a;
  return s;
  function s(p) {
    return !i1(p) || !tj.call(r, r.previous) || Ew(r.events) ? n(p) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), u(p));
  }
  function u(p) {
    return i1(p) ? (e.consume(p), u) : p === 64 ? (e.consume(p), c) : n(p);
  }
  function c(p) {
    return p === 46 ? e.check(Bhe, h, f)(p) : p === 45 || p === 95 || vn(p) ? (a = !0, e.consume(p), c) : h(p);
  }
  function f(p) {
    return e.consume(p), o = !0, c;
  }
  function h(p) {
    return a && o && Cn(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(p)) : n(p);
  }
}
function Uhe(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return s !== 87 && s !== 119 || !JP.call(r, r.previous) || Ew(r.events) ? n(s) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check($he, e.attempt(WP, e.attempt(XP, a), n), n)(s));
  }
  function a(s) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(s);
  }
}
function qhe(e, t, n) {
  const r = this;
  let o = "", a = !1;
  return s;
  function s(p) {
    return (p === 72 || p === 104) && ej.call(r, r.previous) && !Ew(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), o += String.fromCodePoint(p), e.consume(p), u) : n(p);
  }
  function u(p) {
    if (Cn(p) && o.length < 5)
      return o += String.fromCodePoint(p), e.consume(p), u;
    if (p === 58) {
      const g = o.toLowerCase();
      if (g === "http" || g === "https")
        return e.consume(p), c;
    }
    return n(p);
  }
  function c(p) {
    return p === 47 ? (e.consume(p), a ? f : (a = !0, c)) : n(p);
  }
  function f(p) {
    return p === null || Dp(p) || vt(p) || Ja(p) || Km(p) ? n(p) : e.attempt(WP, e.attempt(XP, h), n)(p);
  }
  function h(p) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(p);
  }
}
function Ghe(e, t, n) {
  let r = 0;
  return o;
  function o(s) {
    return (s === 87 || s === 119) && r < 3 ? (r++, e.consume(s), o) : s === 46 && r === 3 ? (e.consume(s), a) : n(s);
  }
  function a(s) {
    return s === null ? n(s) : t(s);
  }
}
function Yhe(e, t, n) {
  let r, o, a;
  return s;
  function s(f) {
    return f === 46 || f === 95 ? e.check(KP, c, u)(f) : f === null || vt(f) || Ja(f) || f !== 45 && Km(f) ? c(f) : (a = !0, e.consume(f), s);
  }
  function u(f) {
    return f === 95 ? r = !0 : (o = r, r = void 0), e.consume(f), s;
  }
  function c(f) {
    return o || r || !a ? n(f) : t(f);
  }
}
function Whe(e, t) {
  let n = 0, r = 0;
  return o;
  function o(s) {
    return s === 40 ? (n++, e.consume(s), o) : s === 41 && r < n ? a(s) : s === 33 || s === 34 || s === 38 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 60 || s === 63 || s === 93 || s === 95 || s === 126 ? e.check(KP, t, a)(s) : s === null || vt(s) || Ja(s) ? t(s) : (e.consume(s), o);
  }
  function a(s) {
    return s === 41 && r++, e.consume(s), o;
  }
}
function Xhe(e, t, n) {
  return r;
  function r(u) {
    return u === 33 || u === 34 || u === 39 || u === 41 || u === 42 || u === 44 || u === 46 || u === 58 || u === 59 || u === 63 || u === 95 || u === 126 ? (e.consume(u), r) : u === 38 ? (e.consume(u), a) : u === 93 ? (e.consume(u), o) : (
      // `<` is an end.
      u === 60 || // So is whitespace.
      u === null || vt(u) || Ja(u) ? t(u) : n(u)
    );
  }
  function o(u) {
    return u === null || u === 40 || u === 91 || vt(u) || Ja(u) ? t(u) : r(u);
  }
  function a(u) {
    return Cn(u) ? s(u) : n(u);
  }
  function s(u) {
    return u === 59 ? (e.consume(u), r) : Cn(u) ? (e.consume(u), s) : n(u);
  }
}
function Khe(e, t, n) {
  return r;
  function r(a) {
    return e.consume(a), o;
  }
  function o(a) {
    return vn(a) ? n(a) : t(a);
  }
}
function JP(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || vt(e);
}
function ej(e) {
  return !Cn(e);
}
function tj(e) {
  return !(e === 47 || i1(e));
}
function i1(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || vn(e);
}
function Ew(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
const Zhe = {
  tokenize: ipe,
  partial: !0
};
function Qhe() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: npe,
        continuation: {
          tokenize: rpe
        },
        exit: ope
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: tpe
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: Jhe,
        resolveTo: epe
      }
    }
  };
}
function Jhe(e, t, n) {
  const r = this;
  let o = r.events.length;
  const a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s;
  for (; o--; ) {
    const c = r.events[o][1];
    if (c.type === "labelImage") {
      s = c;
      break;
    }
    if (c.type === "gfmFootnoteCall" || c.type === "labelLink" || c.type === "label" || c.type === "image" || c.type === "link")
      break;
  }
  return u;
  function u(c) {
    if (!s || !s._balanced)
      return n(c);
    const f = zr(r.sliceSerialize({
      start: s.end,
      end: r.now()
    }));
    return f.codePointAt(0) !== 94 || !a.includes(f.slice(1)) ? n(c) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(c), e.exit("gfmFootnoteCallLabelMarker"), t(c));
  }
}
function epe(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, o = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  o.end.column++, o.end.offset++, o.end._bufferIndex++;
  const a = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, o.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, s = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, a.start),
    end: Object.assign({}, a.end)
  }, u = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", o, t],
    ["exit", o, t],
    // Everything in between.
    ["enter", a, t],
    ["enter", s, t],
    ["exit", s, t],
    ["exit", a, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...u), e;
}
function tpe(e, t, n) {
  const r = this, o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a = 0, s;
  return u;
  function u(p) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), c;
  }
  function c(p) {
    return p !== 94 ? n(p) : (e.enter("gfmFootnoteCallMarker"), e.consume(p), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", f);
  }
  function f(p) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      p === 93 && !s || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      p === null || p === 91 || vt(p)
    )
      return n(p);
    if (p === 93) {
      e.exit("chunkString");
      const g = e.exit("gfmFootnoteCallString");
      return o.includes(zr(r.sliceSerialize(g))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(p);
    }
    return vt(p) || (s = !0), a++, e.consume(p), p === 92 ? h : f;
  }
  function h(p) {
    return p === 91 || p === 92 || p === 93 ? (e.consume(p), a++, f) : f(p);
  }
}
function npe(e, t, n) {
  const r = this, o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a, s = 0, u;
  return c;
  function c(w) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(w), e.exit("gfmFootnoteDefinitionLabelMarker"), f;
  }
  function f(w) {
    return w === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(w), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", h) : n(w);
  }
  function h(w) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      w === 93 && !u || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      w === null || w === 91 || vt(w)
    )
      return n(w);
    if (w === 93) {
      e.exit("chunkString");
      const v = e.exit("gfmFootnoteDefinitionLabelString");
      return a = zr(r.sliceSerialize(v)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(w), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), g;
    }
    return vt(w) || (u = !0), s++, e.consume(w), w === 92 ? p : h;
  }
  function p(w) {
    return w === 91 || w === 92 || w === 93 ? (e.consume(w), s++, h) : h(w);
  }
  function g(w) {
    return w === 58 ? (e.enter("definitionMarker"), e.consume(w), e.exit("definitionMarker"), o.includes(a) || o.push(a), Qe(e, y, "gfmFootnoteDefinitionWhitespace")) : n(w);
  }
  function y(w) {
    return t(w);
  }
}
function rpe(e, t, n) {
  return e.check(kf, t, e.attempt(Zhe, t, n));
}
function ope(e) {
  e.exit("gfmFootnoteDefinition");
}
function ipe(e, t, n) {
  const r = this;
  return Qe(e, o, "gfmFootnoteDefinitionIndent", 5);
  function o(a) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "gfmFootnoteDefinitionIndent" && s[2].sliceSerialize(s[1], !0).length === 4 ? t(a) : n(a);
  }
}
function ape(e) {
  let n = (e || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: a,
    resolveAll: o
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function o(s, u) {
    let c = -1;
    for (; ++c < s.length; )
      if (s[c][0] === "enter" && s[c][1].type === "strikethroughSequenceTemporary" && s[c][1]._close) {
        let f = c;
        for (; f--; )
          if (s[f][0] === "exit" && s[f][1].type === "strikethroughSequenceTemporary" && s[f][1]._open && // If the sizes are the same:
          s[c][1].end.offset - s[c][1].start.offset === s[f][1].end.offset - s[f][1].start.offset) {
            s[c][1].type = "strikethroughSequence", s[f][1].type = "strikethroughSequence";
            const h = {
              type: "strikethrough",
              start: Object.assign({}, s[f][1].start),
              end: Object.assign({}, s[c][1].end)
            }, p = {
              type: "strikethroughText",
              start: Object.assign({}, s[f][1].end),
              end: Object.assign({}, s[c][1].start)
            }, g = [["enter", h, u], ["enter", s[f][1], u], ["exit", s[f][1], u], ["enter", p, u]], y = u.parser.constructs.insideSpan.null;
            y && sr(g, g.length, 0, Zm(y, s.slice(f + 1, c), u)), sr(g, g.length, 0, [["exit", p, u], ["enter", s[c][1], u], ["exit", s[c][1], u], ["exit", h, u]]), sr(s, f - 1, c - f + 3, g), c = f + g.length - 2;
            break;
          }
      }
    for (c = -1; ++c < s.length; )
      s[c][1].type === "strikethroughSequenceTemporary" && (s[c][1].type = "data");
    return s;
  }
  function a(s, u, c) {
    const f = this.previous, h = this.events;
    let p = 0;
    return g;
    function g(w) {
      return f === 126 && h[h.length - 1][1].type !== "characterEscape" ? c(w) : (s.enter("strikethroughSequenceTemporary"), y(w));
    }
    function y(w) {
      const v = Ol(f);
      if (w === 126)
        return p > 1 ? c(w) : (s.consume(w), p++, y);
      if (p < 2 && !n) return c(w);
      const S = s.exit("strikethroughSequenceTemporary"), E = Ol(w);
      return S._open = !E || E === 2 && !!v, S._close = !v || v === 2 && !!E, u(w);
    }
  }
}
class spe {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    lpe(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(a, s) {
      return a[0] - s[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
    r.push(t.slice()), t.length = 0;
    let o = r.pop();
    for (; o; ) {
      for (const a of o)
        t.push(a);
      o = r.pop();
    }
    this.map.length = 0;
  }
}
function lpe(e, t, n, r) {
  let o = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; o < e.map.length; ) {
      if (e.map[o][0] === t) {
        e.map[o][1] += n, e.map[o][2].push(...r);
        return;
      }
      o += 1;
    }
    e.map.push([t, n, r]);
  }
}
function upe(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const o = e[t];
    if (n) {
      if (o[0] === "enter")
        o[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (o[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const a = r.length - 1;
          r[a] = r[a] === "left" ? "center" : "right";
        }
      } else if (o[1].type === "tableDelimiterRow")
        break;
    } else o[0] === "enter" && o[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function cpe() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: fpe,
        resolveAll: dpe
      }
    }
  };
}
function fpe(e, t, n) {
  const r = this;
  let o = 0, a = 0, s;
  return u;
  function u(R) {
    let F = r.events.length - 1;
    for (; F > -1; ) {
      const j = r.events[F][1].type;
      if (j === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      j === "linePrefix") F--;
      else break;
    }
    const U = F > -1 ? r.events[F][1].type : null, W = U === "tableHead" || U === "tableRow" ? N : c;
    return W === N && r.parser.lazy[r.now().line] ? n(R) : W(R);
  }
  function c(R) {
    return e.enter("tableHead"), e.enter("tableRow"), f(R);
  }
  function f(R) {
    return R === 124 || (s = !0, a += 1), h(R);
  }
  function h(R) {
    return R === null ? n(R) : Oe(R) ? a > 1 ? (a = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(R), e.exit("lineEnding"), y) : n(R) : We(R) ? Qe(e, h, "whitespace")(R) : (a += 1, s && (s = !1, o += 1), R === 124 ? (e.enter("tableCellDivider"), e.consume(R), e.exit("tableCellDivider"), s = !0, h) : (e.enter("data"), p(R)));
  }
  function p(R) {
    return R === null || R === 124 || vt(R) ? (e.exit("data"), h(R)) : (e.consume(R), R === 92 ? g : p);
  }
  function g(R) {
    return R === 92 || R === 124 ? (e.consume(R), p) : p(R);
  }
  function y(R) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(R) : (e.enter("tableDelimiterRow"), s = !1, We(R) ? Qe(e, w, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(R) : w(R));
  }
  function w(R) {
    return R === 45 || R === 58 ? S(R) : R === 124 ? (s = !0, e.enter("tableCellDivider"), e.consume(R), e.exit("tableCellDivider"), v) : M(R);
  }
  function v(R) {
    return We(R) ? Qe(e, S, "whitespace")(R) : S(R);
  }
  function S(R) {
    return R === 58 ? (a += 1, s = !0, e.enter("tableDelimiterMarker"), e.consume(R), e.exit("tableDelimiterMarker"), E) : R === 45 ? (a += 1, E(R)) : R === null || Oe(R) ? A(R) : M(R);
  }
  function E(R) {
    return R === 45 ? (e.enter("tableDelimiterFiller"), T(R)) : M(R);
  }
  function T(R) {
    return R === 45 ? (e.consume(R), T) : R === 58 ? (s = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(R), e.exit("tableDelimiterMarker"), k) : (e.exit("tableDelimiterFiller"), k(R));
  }
  function k(R) {
    return We(R) ? Qe(e, A, "whitespace")(R) : A(R);
  }
  function A(R) {
    return R === 124 ? w(R) : R === null || Oe(R) ? !s || o !== a ? M(R) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(R)) : M(R);
  }
  function M(R) {
    return n(R);
  }
  function N(R) {
    return e.enter("tableRow"), P(R);
  }
  function P(R) {
    return R === 124 ? (e.enter("tableCellDivider"), e.consume(R), e.exit("tableCellDivider"), P) : R === null || Oe(R) ? (e.exit("tableRow"), t(R)) : We(R) ? Qe(e, P, "whitespace")(R) : (e.enter("data"), z(R));
  }
  function z(R) {
    return R === null || R === 124 || vt(R) ? (e.exit("data"), P(R)) : (e.consume(R), R === 92 ? B : z);
  }
  function B(R) {
    return R === 92 || R === 124 ? (e.consume(R), z) : z(R);
  }
}
function dpe(e, t) {
  let n = -1, r = !0, o = 0, a = [0, 0, 0, 0], s = [0, 0, 0, 0], u = !1, c = 0, f, h, p;
  const g = new spe();
  for (; ++n < e.length; ) {
    const y = e[n], w = y[1];
    y[0] === "enter" ? w.type === "tableHead" ? (u = !1, c !== 0 && (XR(g, t, c, f, h), h = void 0, c = 0), f = {
      type: "table",
      start: Object.assign({}, w.start),
      // Note: correct end is set later.
      end: Object.assign({}, w.end)
    }, g.add(n, 0, [["enter", f, t]])) : w.type === "tableRow" || w.type === "tableDelimiterRow" ? (r = !0, p = void 0, a = [0, 0, 0, 0], s = [0, n + 1, 0, 0], u && (u = !1, h = {
      type: "tableBody",
      start: Object.assign({}, w.start),
      // Note: correct end is set later.
      end: Object.assign({}, w.end)
    }, g.add(n, 0, [["enter", h, t]])), o = w.type === "tableDelimiterRow" ? 2 : h ? 3 : 1) : o && (w.type === "data" || w.type === "tableDelimiterMarker" || w.type === "tableDelimiterFiller") ? (r = !1, s[2] === 0 && (a[1] !== 0 && (s[0] = s[1], p = Ch(g, t, a, o, void 0, p), a = [0, 0, 0, 0]), s[2] = n)) : w.type === "tableCellDivider" && (r ? r = !1 : (a[1] !== 0 && (s[0] = s[1], p = Ch(g, t, a, o, void 0, p)), a = s, s = [a[1], n, 0, 0])) : w.type === "tableHead" ? (u = !0, c = n) : w.type === "tableRow" || w.type === "tableDelimiterRow" ? (c = n, a[1] !== 0 ? (s[0] = s[1], p = Ch(g, t, a, o, n, p)) : s[1] !== 0 && (p = Ch(g, t, s, o, n, p)), o = 0) : o && (w.type === "data" || w.type === "tableDelimiterMarker" || w.type === "tableDelimiterFiller") && (s[3] = n);
  }
  for (c !== 0 && XR(g, t, c, f, h), g.consume(t.events), n = -1; ++n < t.events.length; ) {
    const y = t.events[n];
    y[0] === "enter" && y[1].type === "table" && (y[1]._align = upe(t.events, n));
  }
  return e;
}
function Ch(e, t, n, r, o, a) {
  const s = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", u = "tableContent";
  n[0] !== 0 && (a.end = Object.assign({}, tl(t.events, n[0])), e.add(n[0], 0, [["exit", a, t]]));
  const c = tl(t.events, n[1]);
  if (a = {
    type: s,
    start: Object.assign({}, c),
    // Note: correct end is set later.
    end: Object.assign({}, c)
  }, e.add(n[1], 0, [["enter", a, t]]), n[2] !== 0) {
    const f = tl(t.events, n[2]), h = tl(t.events, n[3]), p = {
      type: u,
      start: Object.assign({}, f),
      end: Object.assign({}, h)
    };
    if (e.add(n[2], 0, [["enter", p, t]]), r !== 2) {
      const g = t.events[n[2]], y = t.events[n[3]];
      if (g[1].end = Object.assign({}, y[1].end), g[1].type = "chunkText", g[1].contentType = "text", n[3] > n[2] + 1) {
        const w = n[2] + 1, v = n[3] - n[2] - 1;
        e.add(w, v, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", p, t]]);
  }
  return o !== void 0 && (a.end = Object.assign({}, tl(t.events, o)), e.add(o, 0, [["exit", a, t]]), a = void 0), a;
}
function XR(e, t, n, r, o) {
  const a = [], s = tl(t.events, n);
  o && (o.end = Object.assign({}, s), a.push(["exit", o, t])), r.end = Object.assign({}, s), a.push(["exit", r, t]), e.add(n + 1, 0, a);
}
function tl(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const hpe = {
  name: "tasklistCheck",
  tokenize: mpe
};
function ppe() {
  return {
    text: {
      91: hpe
    }
  };
}
function mpe(e, t, n) {
  const r = this;
  return o;
  function o(c) {
    return (
      // Exit if theres stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(c) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), a)
    );
  }
  function a(c) {
    return vt(c) ? (e.enter("taskListCheckValueUnchecked"), e.consume(c), e.exit("taskListCheckValueUnchecked"), s) : c === 88 || c === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(c), e.exit("taskListCheckValueChecked"), s) : n(c);
  }
  function s(c) {
    return c === 93 ? (e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), u) : n(c);
  }
  function u(c) {
    return Oe(c) ? t(c) : We(c) ? e.check({
      tokenize: gpe
    }, t, n)(c) : n(c);
  }
}
function gpe(e, t, n) {
  return Qe(e, r, "whitespace");
  function r(o) {
    return o === null ? n(o) : t(o);
  }
}
function ype(e) {
  return dP([
    Hhe(),
    Qhe(),
    ape(e),
    cpe(),
    ppe()
  ]);
}
const vpe = {};
function bpe(e) {
  const t = (
    /** @type {Processor<Root>} */
    this
  ), n = e || vpe, r = t.data(), o = r.micromarkExtensions || (r.micromarkExtensions = []), a = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), s = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  o.push(ype(n)), a.push(Lhe()), s.push(Fhe(n));
}
const Cw = ({
  availableModule: e
}) => {
  const [t, n] = _.useState(!1), r = () => n(!t), o = 150, a = e.description.length > o ? e.description.substring(0, o) + "..." : e.description;
  return /* @__PURE__ */ x.jsxs("div", { className: "module-description", children: [
    /* @__PURE__ */ x.jsx(ade, { remarkPlugins: [bpe], children: t ? e.description.replace(/\\n/g, `  
`) : a.replace(/\\n/g, `  
`) }),
    e.description.length > o && /* @__PURE__ */ x.jsx("button", { onClick: r, className: "toggle-description", children: t ? "Show less" : "Show more" })
  ] });
}, KR = [
  ">=",
  "==",
  "<=",
  "<",
  ">"
], tg = ">=", kw = ({
  availableModule: e,
  on_change: t
}) => {
  const [n, r] = _.useState(
    e.version || "latest"
  ), [o, a] = _.useState(tg), s = (c) => {
    const f = c.target.value;
    r(f), t(f !== "latest" ? o + f : f);
  }, u = (c) => {
    c.target.value !== o && KR.includes(c.target.value) && (a(c.target.value), n !== "latest" && t(c.target.value + n));
  };
  return e.releases && !e.releases.includes(n) && e.releases.unshift(n), /* @__PURE__ */ x.jsxs(x.Fragment, { children: [
    /* @__PURE__ */ x.jsx("select", { value: o, onChange: u, children: KR.map((c) => /* @__PURE__ */ x.jsx("option", { value: c, children: c }, c)) }),
    /* @__PURE__ */ x.jsx("select", { onChange: s, value: n, children: e.releases && e.releases.map((c) => /* @__PURE__ */ x.jsx("option", { value: c, children: c }, c)) })
  ] });
}, xpe = ({
  availableModule: e,
  on_remove: t,
  on_update: n
}) => {
  const [r, o] = _.useState(
    tg + e.version || "latest"
  );
  return /* @__PURE__ */ x.jsxs("div", { className: "addable-module", children: [
    /* @__PURE__ */ x.jsx("div", { className: "module-name", children: e.name + (e.version ? ` (${e.version})` : "") }),
    /* @__PURE__ */ x.jsx(aw, { availableModule: e }),
    /* @__PURE__ */ x.jsx(Cw, { availableModule: e }),
    /* @__PURE__ */ x.jsxs("div", { children: [
      /* @__PURE__ */ x.jsx(
        kw,
        {
          availableModule: e,
          on_change: o
        }
      ),
      /* @__PURE__ */ x.jsx(
        "button",
        {
          className: "update-button",
          disabled: r === e.version,
          onClick: () => {
            n(e, r);
          },
          children: "Update"
        }
      ),
      /* @__PURE__ */ x.jsx(
        "button",
        {
          className: "remove-button",
          onClick: () => {
            t(e);
          },
          children: "Remove"
        }
      )
    ] })
  ] });
}, wpe = ({
  availableModule: e,
  on_add: t
}) => {
  const [n, r] = _.useState(
    tg + e.version || "latest"
  );
  return /* @__PURE__ */ x.jsxs("div", { className: "addable-module", children: [
    /* @__PURE__ */ x.jsx("div", { className: "module-name", children: e.name + (e.version ? ` (${e.version})` : "") }),
    /* @__PURE__ */ x.jsx(aw, { availableModule: e }),
    /* @__PURE__ */ x.jsx(Cw, { availableModule: e }),
    /* @__PURE__ */ x.jsxs("div", { children: [
      /* @__PURE__ */ x.jsx(
        kw,
        {
          availableModule: e,
          on_change: r
        }
      ),
      /* @__PURE__ */ x.jsx(
        "button",
        {
          className: "add-button",
          onClick: () => {
            t(e, n);
          },
          children: "Add"
        }
      )
    ] })
  ] });
}, _pe = ({
  availableModule: e,
  on_add: t
}) => {
  const [n, r] = _.useState(
    tg + e.version || "latest"
  );
  return /* @__PURE__ */ x.jsxs("div", { className: "addable-module", children: [
    /* @__PURE__ */ x.jsx("div", { className: "module-name", children: e.name }),
    /* @__PURE__ */ x.jsx(aw, { availableModule: e }),
    /* @__PURE__ */ x.jsx(Cw, { availableModule: e }),
    /* @__PURE__ */ x.jsxs("div", { children: [
      /* @__PURE__ */ x.jsx(
        kw,
        {
          availableModule: e,
          on_change: r
        }
      ),
      /* @__PURE__ */ x.jsx(
        "button",
        {
          className: "add-button",
          onClick: () => {
            t(e, n);
          },
          children: "Add"
        }
      )
    ] })
  ] });
}, Spe = ({
  ins: e
}) => {
  const [t, n] = _.useState(e.name), r = nt(), { lib: o } = Tn(), a = () => {
    r.worker && o?.remove_external_worker(e.uuid, e.nodeclassid);
  }, s = () => {
    r.worker && (r.worker.update_external_worker(e.uuid, e.nodeclassid, {
      name: t
    }), e.name = t);
  };
  return /* @__PURE__ */ x.jsx(x.Fragment, { children: /* @__PURE__ */ x.jsx(
    ci,
    {
      title: e.name,
      description: "Settings for" + e.name,
      trigger: /* @__PURE__ */ x.jsx("div", { children: "Settings" }),
      buttons: [
        {
          text: "Save",
          onClick: s,
          close: !0
        },
        {
          text: "Delete",
          onClick: a,
          close: !0
        }
      ],
      children: /* @__PURE__ */ x.jsx("div", { children: /* @__PURE__ */ x.jsxs("div", { children: [
        /* @__PURE__ */ x.jsx("label", { htmlFor: "name", children: "Name: " }),
        /* @__PURE__ */ x.jsx(
          "input",
          {
            type: "text",
            name: "name",
            value: t,
            onChange: (u) => n(u.target.value),
            className: "styledinput"
          }
        )
      ] }) })
    }
  ) });
}, Epe = ({
  ins: e,
  lib: t,
  filter: n = "",
  parentkey: r
}) => {
  const [o, a] = _.useState(!1), s = () => a(!o), u = t?.nodes?.filter(
    (c) => c.node_id.toLowerCase().includes(n.toLowerCase())
  );
  return /* @__PURE__ */ x.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ x.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: s,
        style: { cursor: "pointer" },
        title: e.name,
        children: [
          /* @__PURE__ */ x.jsx("div", { className: "shelftitle_text", children: e.name }),
          /* @__PURE__ */ x.jsx("div", { className: "expandicon " + (o ? "open" : "close"), children: /* @__PURE__ */ x.jsx(sf, {}) })
        ]
      }
    ),
    /* @__PURE__ */ x.jsx("div", { className: "libnodecontainer " + (o ? "open" : "close"), children: /* @__PURE__ */ x.jsx("div", { className: "libnodecontainer_inner", children: o && /* @__PURE__ */ x.jsxs(x.Fragment, { children: [
      /* @__PURE__ */ x.jsx("div", { className: "libnodeentry", title: e.uuid, children: /* @__PURE__ */ x.jsx(Spe, { ins: e }) }),
      t && /* @__PURE__ */ x.jsxs(x.Fragment, { children: [
        u && /* @__PURE__ */ x.jsx(x.Fragment, { children: u.map((c) => /* @__PURE__ */ x.jsx(
          KD,
          {
            item: c
          },
          r + c.node_id
        )) }),
        t.subshelves.map((c) => /* @__PURE__ */ x.jsx(
          iw,
          {
            item: c,
            filter: n,
            parentkey: r + c.name
          },
          r + c.name
        ))
      ] })
    ] }) }) })
  ] });
}, Cpe = ({
  item: e,
  mod: t,
  lib: n
}) => {
  const { lib: r } = Tn(), [o, a] = _.useState(!1), s = () => a(!o), u = _.useCallback(() => {
    r?.add_external_worker({
      module: t,
      cls_module: e.module,
      cls_name: e.class_name
    });
  }, [r, t, e]), c = (h) => {
    h.detail === 2 && u();
  }, f = e.name || e.module + "." + e.class_name;
  return /* @__PURE__ */ x.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ x.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: s,
        style: { cursor: "pointer" },
        title: f,
        children: [
          /* @__PURE__ */ x.jsx("div", { className: "shelftitle_text", children: f }),
          /* @__PURE__ */ x.jsx("div", { className: "expandicon " + (o ? "open" : "close"), children: /* @__PURE__ */ x.jsx(sf, {}) })
        ]
      }
    ),
    /* @__PURE__ */ x.jsx("div", { className: "libnodecontainer " + (o ? "open" : "close"), children: /* @__PURE__ */ x.jsx("div", { className: "libnodecontainer_inner", children: o && /* @__PURE__ */ x.jsxs(x.Fragment, { children: [
      /* @__PURE__ */ x.jsx(
        "div",
        {
          className: "libnodeentry",
          onClick: c,
          title: e.name,
          children: "New Instance"
        }
      ),
      e.instances.map((h) => /* @__PURE__ */ x.jsx(
        Epe,
        {
          ins: h,
          lib: n?.subshelves.find(
            (p) => p.name === h.uuid
          ),
          parentkey: h.uuid
        },
        h.uuid
      ))
    ] }) }) })
  ] });
}, kpe = ({
  externalworkermod: e,
  lib: t
}) => {
  const [n, r] = _.useState(!1), o = () => r(!n), a = n;
  return /* @__PURE__ */ x.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ x.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: o,
        style: { cursor: "pointer" },
        title: e.module,
        children: [
          /* @__PURE__ */ x.jsx("div", { className: "shelftitle_text", children: e.module }),
          /* @__PURE__ */ x.jsx("div", { className: "expandicon " + (a ? "open" : "close"), children: /* @__PURE__ */ x.jsx(sf, {}) })
        ]
      }
    ),
    /* @__PURE__ */ x.jsx("div", { className: "libnodecontainer " + (a ? "open" : "close"), children: /* @__PURE__ */ x.jsx("div", { className: "libnodecontainer_inner", children: e.worker_classes.map((s) => /* @__PURE__ */ x.jsx(
      Cpe,
      {
        item: s,
        mod: e.module,
        lib: t
      },
      s.module + s.class_name
    )) }) }),
    /* @__PURE__ */ x.jsx("hr", {})
  ] });
}, Tpe = () => {
  const e = nt(), t = e.lib.libstate(), n = nt(), r = n.local_settings(
    (f) => f.view_settings.expand_lib
  ), o = (f) => {
    n.update_view_settings({ expand_lib: f });
  }, a = kie("m"), [s, u] = _.useState(""), c = e.worker?.state((f) => f.is_open) ?? !1;
  return /* @__PURE__ */ x.jsx(
    Bx,
    {
      maxSize: a ? "100%" : "18.75rem",
      direction: a ? "down" : "right",
      containerClassName: "pos-left pos-top bg1 h-12",
      onExpandChange: o,
      expanded: r === void 0 ? !0 : r,
      collapseIcons: {
        up: op,
        down: Dc,
        left: Nc,
        right: rp
      },
      expandIcons: {
        up: Dc,
        down: op,
        left: rp,
        right: Nc
      },
      children: /* @__PURE__ */ x.jsxs("div", { className: "libcontainer", children: [
        /* @__PURE__ */ x.jsxs("div", { className: "library", children: [
          /* @__PURE__ */ x.jsx("div", { className: "libtitle", children: "Lib" }),
          /* @__PURE__ */ x.jsx("hr", { className: "hr_prominent" }),
          /* @__PURE__ */ x.jsx(Wse, { filter: s, setFilter: u }),
          /* @__PURE__ */ x.jsx("div", { className: "vscrollcontainer", children: t.lib.shelves.filter((f) => f.name !== "_external_worker").map((f) => /* @__PURE__ */ x.jsx(
            iw,
            {
              item: f,
              filter: s,
              parentkey: f.name
            },
            f.name
          )) }),
          /* @__PURE__ */ x.jsx("hr", {}),
          /* @__PURE__ */ x.jsx("div", { className: "libtitle", children: "External Worker" }),
          /* @__PURE__ */ x.jsx("hr", { className: "hr_prominent" }),
          /* @__PURE__ */ x.jsx("div", { className: "vscrollcontainer", children: t.external_worker?.map((f) => /* @__PURE__ */ x.jsx(
            kpe,
            {
              externalworkermod: f,
              lib: t.lib.shelves.find(
                (h) => h.name === "_external_worker"
              )
            },
            f.module
          )) }),
          /* @__PURE__ */ x.jsx("hr", {})
        ] }),
        c && /* @__PURE__ */ x.jsx("div", { className: "addlib", children: /* @__PURE__ */ x.jsx(Xse, { children: /* @__PURE__ */ x.jsx("button", { children: "Manage Libraries" }) }) })
      ] })
    }
  );
}, Ape = ({
  fnrf_zst: e,
  header: t,
  flow: n,
  library: r
}) => {
  const [o, a] = _.useState(
    e.options.worker
  ), s = _.useRef(null);
  e.workermanager && (e.workermanager.on_setWorker = a), e.set_worker(o), _.useEffect(() => {
    e.auto_progress();
  }, []), _.useEffect(() => {
    e.local_state.setState({ funcnodescontainerRef: s.current });
  }, [s]);
  const u = e.plugins();
  return /* @__PURE__ */ x.jsx(fie, { plugins: u, fnrf_zst: e, children: /* @__PURE__ */ x.jsx(FV, { children: /* @__PURE__ */ x.jsx(gN.Provider, { value: e, children: /* @__PURE__ */ x.jsx(Zi, { asChild: !0, children: /* @__PURE__ */ x.jsx(Wo, { asChild: !0, children: /* @__PURE__ */ x.jsx(
    G4,
    {
      style: {
        height: "100%",
        width: "100%",
        display: "flex",
        flexDirection: "column",
        flex: 1
      },
      children: /* @__PURE__ */ x.jsxs(
        "div",
        {
          ref: s,
          className: "funcnodesreactflowcontainer funcnodescontainer",
          children: [
            t.show && /* @__PURE__ */ x.jsx(Yse, { ...t }),
            /* @__PURE__ */ x.jsxs("div", { className: "funcnodesreactflowbody", children: [
              /* @__PURE__ */ x.jsx(Cae, { ...n }),
              o && r.show && /* @__PURE__ */ x.jsx(Tpe, {}),
              o && n.showNodeSettings && /* @__PURE__ */ x.jsx(Oie, {})
            ] }),
            /* @__PURE__ */ x.jsxs("div", { className: "funcnodesflaotingmenu", children: [
              /* @__PURE__ */ x.jsx(Wo.OutFullScreen, { children: n.allowExpand && /* @__PURE__ */ x.jsxs(Zi.Trigger, { children: [
                /* @__PURE__ */ x.jsx(Zi.Expanded, { children: /* @__PURE__ */ x.jsx(
                  RV,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) }),
                /* @__PURE__ */ x.jsx(Zi.Collapsed, { children: /* @__PURE__ */ x.jsx(
                  MV,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) })
              ] }) }),
              n.allowFullScreen && /* @__PURE__ */ x.jsxs(Wo.Trigger, { children: [
                /* @__PURE__ */ x.jsx(Wo.OutFullScreen, { children: /* @__PURE__ */ x.jsx(
                  mN,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) }),
                /* @__PURE__ */ x.jsx(Wo.InFullScreen, { children: /* @__PURE__ */ x.jsx(
                  AV,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) })
              ] })
            ] })
          ]
        }
      )
    }
  ) }) }) }) }) });
};
class ql {
  constructor(t) {
    this.context = t;
  }
  get nodespaceManager() {
    return this.context.rf.getNodespaceManager();
  }
  get libManager() {
    return this.context.rf.getLibManager();
  }
  get workerManager() {
    return this.context.rf.getWorkerManager();
  }
  get stateManager() {
    return this.context.rf.getStateManager();
  }
  get pluginManager() {
    return this.context.rf.getPluginManager();
  }
  get reactFlowManager() {
    return this.context.rf.getReactFlowManager();
  }
}
const ZR = ({
  src_nid: e,
  src_ioid: t,
  trg_nid: n,
  trg_ioid: r
}) => [`${e}:${t}`, `${n}:${r}`].sort().join("--"), Rpe = ({}) => {
  const e = /* @__PURE__ */ new Map();
  return {
    nodesstates: e,
    get_node: (t, n = !0) => {
      const r = e.get(t);
      if (!r && n) {
        const o = e.keys();
        throw new Error(
          `Node ${t} not found, available nodes: ${Array.from(o)}`
        );
      }
      return r;
    }
  };
};
class Mpe extends ql {
  constructor(t) {
    super(t), this.on_node_action = (n) => {
      switch (n.type) {
        case "add":
          return this._add_node(n);
        case "update":
          return this._update_node(n);
        case "delete":
          return this._delete_node(n);
        case "error":
          return this._error_action(n);
        case "trigger":
          return this._trigger_action(n);
        default:
          this.context.rf.logger.error("Unknown node action", n);
          return;
      }
    }, this.on_edge_action = (n) => {
      const r = this.reactFlowManager.useReactFlowStore.getState();
      switch (n.type) {
        case "add":
          if (n.from_remote) {
            const o = r.getEdges(), a = ZR(n);
            if (o.some((u) => u.id === a))
              return;
            const s = {
              id: a,
              source: n.src_nid,
              target: n.trg_nid,
              sourceHandle: n.src_ioid,
              targetHandle: n.trg_ioid,
              className: "funcnodes-edge animated",
              zIndex: 1003
              // just above elevated groups
            };
            this.context.rf.logger.info("Adding edge", s), r.update_edges([...o, s]), this.workerManager.worker?.api.node.get_remote_node_state(
              n.src_nid
            ), this.workerManager.worker?.api.node.get_remote_node_state(
              n.trg_nid
            );
          }
          break;
        case "delete":
          if (n.from_remote) {
            const o = r.getEdges(), a = ZR(n);
            this.context.rf.logger.info("Deleting edge", a);
            const s = o.filter((u) => u.id !== a);
            r.update_edges(s), this.workerManager.worker?.api.node.get_remote_node_state(
              n.src_nid
            ), this.workerManager.worker?.api.node.get_remote_node_state(
              n.trg_nid
            );
          }
          break;
        default:
          this.context.rf.logger.error("Unknown edge action", n);
      }
    }, this.on_group_action = (n) => {
      switch (n.type) {
        case "set":
          return this._set_groups(n.groups);
        case "update":
          return this._update_group(n);
        default:
          this.context.rf.logger.error("Unknown group action", n);
      }
    }, this.clear_all = () => {
      this.workerManager.worker?.disconnect(), this.workerManager.set_worker(void 0), this.workerManager.workermanager?.setWorker(void 0), this.libManager.lib.libstate.getState().set({ lib: { shelves: [] }, external_worker: [] }), this.nodespace.nodesstates.clear(), this.reactFlowManager.useReactFlowStore.getState().update_nodes([]), this.reactFlowManager.useReactFlowStore.getState().update_edges([]), this.stateManager.auto_progress();
    }, this.center_node = (n) => {
      if (!this.reactFlowManager.rf_instance)
        return;
      n = Array.isArray(n) ? n : [n];
      const r = this.reactFlowManager.useReactFlowStore.getState().getNodes().filter((o) => n.includes(o.id));
      r.length > 0 && this.reactFlowManager.rf_instance?.fitView({ padding: 0.2, nodes: r });
    }, this.auto_resize_group = (n) => {
      const r = this.reactFlowManager.useReactFlowStore.getState(), o = r.getNode(n);
      if (o === void 0 || o.type !== "group")
        return;
      const a = o.data.group.node_ids.map((h) => r.getNode(h)).filter((h) => h !== void 0), s = o.data.group.child_groups.map((h) => r.getNode(h)).filter((h) => h !== void 0), u = [...a, ...s], c = this.reactFlowManager.rf_instance?.getNodesBounds(u);
      if (c === void 0)
        return;
      const f = {
        ...o,
        position: {
          x: c.x,
          y: c.y
        },
        height: c.height,
        width: c.width
      };
      f.data.group.position = [c.x, c.y], r.partial_update_nodes([f]);
    }, this.change_group_position = (n) => {
      if (n.position === void 0)
        return;
      const r = this.reactFlowManager.useReactFlowStore.getState(), o = r.getNode(n.id);
      if (o === void 0 || o.type !== "group")
        return;
      const a = [
        ...o.data.group.node_ids,
        ...o.data.group.child_groups
      ], s = this.reactFlowManager.rf_instance?.getNodesBounds(a);
      if (s === void 0)
        return;
      const u = n.position.x - s?.x, c = n.position.y - s?.y, f = [];
      for (const h of a) {
        const p = r.getNode(h);
        p !== void 0 && f.push({
          id: h,
          type: "position",
          position: {
            x: p.position.x + u,
            y: p.position.y + c
          }
        });
      }
      r.onNodesChange(f);
    }, this.change_fn_node_position = (n) => {
      n.position !== void 0 && this.on_node_action({
        type: "update",
        id: n.id,
        node: {
          properties: {
            "frontend:pos": [n.position.x, n.position.y]
          }
        },
        from_remote: !1
      });
    }, this.change_group_dimensions = (n) => {
      if (n.dimensions === void 0)
        return;
      const o = this.reactFlowManager.useReactFlowStore.getState().getNode(n.id);
      o !== void 0 && this.reactFlowManager.useReactFlowStore.getState().partial_update_nodes(Px([n], [o]));
    }, this.change_fn_node_dimensions = (n) => {
      n.dimensions !== void 0 && this.on_node_action({
        type: "update",
        id: n.id,
        node: {
          properties: {
            "frontend:size": [n.dimensions.width, n.dimensions.height]
          }
        },
        from_remote: !1
      });
    }, this._update_group = (n) => {
      if (n.from_remote) {
        const r = this.reactFlowManager.useReactFlowStore.getState(), o = r.getNode(n.id);
        if (o === void 0 || o.type !== "group")
          return;
        const { new_obj: a, change: s } = Ha(o.data.group, n.group);
        s && (o.data.group = a), r.partial_update_nodes([o]);
      } else
        this.workerManager.worker && this.workerManager.worker.api.group.locally_update_group(n);
    }, this._set_groups = (n) => {
      const r = this.reactFlowManager.useReactFlowStore.getState(), { default_nodes: o } = Gx(r.getNodes()), a = [...o], s = {};
      for (const c in n) {
        const f = n[c];
        for (const p of f.node_ids)
          s[p] = c;
        for (const p of f.child_groups)
          s[p] = c;
        f.position === void 0 && (f.position = [0, 0]);
        const h = {
          id: c,
          type: "group",
          data: { group: n[c], id: c },
          position: { x: f.position[0], y: f.position[1] },
          zIndex: 2
        };
        f.parent_group && (h.data.groupID = f.parent_group), a.push(h);
      }
      for (const c of a)
        c.id in s ? c.data.groupID = s[c.id] : c.data.groupID = void 0;
      const u = Yx(a);
      r.update_nodes(u);
      for (const c of u.reverse())
        c.type === "group" && this.auto_resize_group(c.id);
    }, this._add_node = (n) => {
      this.context.rf.logger.info("add node", n);
      const r = this.reactFlowManager.useReactFlowStore.getState();
      if (n.from_remote) {
        let o = this.nodespace.get_node(n.node.id, !1);
        if (o)
          return;
        if (!o)
          try {
            o = yae(n.node), this.nodespace.nodesstates.set(n.node.id, o);
          } catch (c) {
            this.context.rf.logger.error(`Failed to create node store ${c}`);
            return;
          }
        const a = o.getState();
        this.context.rf.logger.info("Add node", a.id, a.name);
        const s = Eae(o, this.context.rf), u = [...r.getNodes(), s];
        this.reactFlowManager.useReactFlowStore.getState().update_nodes(u);
        for (const c of s.io_order)
          this.workerManager.worker?.api.node.get_io_value({
            nid: s.id,
            ioid: c
          });
        return setTimeout(() => {
          this.workerManager.worker?.api.hooks.call_hooks("node_added", {
            node: a.id
          });
        }, 0), a;
      }
    }, this._update_node = (n) => {
      if (Object.keys(n.node).length === 0) {
        this.context.rf.logger.error(
          "Node update is empty",
          new Error(JSON.stringify(n))
        );
        return;
      }
      if (n.node.in_trigger && (n.node.error = void 0), n.from_remote) {
        const r = this.nodespace.get_node(n.id, !1);
        if (!r) {
          console.error("Node not found to update", n.id);
          return;
        }
        return r.update(n.node), r.getState();
      } else
        this.workerManager.worker && this.workerManager.worker.api.node.locally_update_node(n);
    }, this._delete_node = (n) => {
      this.context.rf.logger.info("Deleting node", n.id), n.from_remote ? this.reactFlowManager.useReactFlowStore.getState().onNodesChange([
        {
          type: "remove",
          id: n.id
        }
      ]) : this.workerManager.worker?.api.node.remove_node(n.id);
    }, this._error_action = (n) => (this.context.rf.logger.error("Error", new Error(JSON.stringify(n))), this.on_node_action({
      type: "update",
      id: n.id,
      node: {
        in_trigger: !1,
        error: n.error
      },
      from_remote: !0
    })), this._trigger_action = (n) => {
      if (n.from_remote)
        return this.on_node_action({
          type: "update",
          id: n.id,
          node: {
            in_trigger: !0,
            error: void 0
          },
          from_remote: !0
        });
      this.workerManager.worker?.api.node.trigger_node(n.id);
    }, this.nodespace = Rpe({});
  }
  center_all() {
    this.reactFlowManager.rf_instance?.fitView({ padding: 0.2 });
  }
}
const Ope = () => ({
  libstate: Er((e, t) => ({
    lib: {
      shelves: []
    },
    external_worker: [],
    set: (n) => e((r) => ({ ...r, ...n })),
    get_lib: () => t().lib,
    get_external_worker: () => t().external_worker
  }))
});
class Npe extends ql {
  constructor(t) {
    super(t), this.lib = Ope();
  }
}
class Dpe extends ql {
  constructor(t) {
    super(t), this.workers = Er((n, r) => ({})), this.workerstate = Er((n, r) => ({
      is_open: !1
    }));
  }
  set_worker(t) {
    t !== this.worker && (this._unsubscribeFromWorker && (this._unsubscribeFromWorker(), this._unsubscribeFromWorker = void 0), t && (this._unsubscribeFromWorker = t.state.subscribe((n) => {
      this.workerstate.setState(n);
    }), this.workerstate.setState(t.state.getState())), this.worker = t, t?.set_zustand(this.context.rf));
  }
}
class Ppe extends ql {
  constructor(t) {
    super(t), this.progress_state = Er((n, r) => ({
      message: "please select worker",
      status: "info",
      progress: 0,
      blocking: !1
    })), this.local_settings = Er(
      (n, r) => ({
        view_settings: {
          expand_node_props: !1,
          expand_lib: !1
        }
      })
    ), this.local_state = Er((n, r) => ({
      selected_nodes: [],
      selected_edges: [],
      selected_groups: [],
      funcnodescontainerRef: null
    }));
  }
  set_progress(t) {
    if (t.message === "")
      return this.auto_progress();
    const n = this.progress_state.getState(), { new_obj: r, change: o } = Ha(n, t);
    o && this.progress_state.setState(r);
  }
  auto_progress() {
    const t = this.workerManager.workermanager, n = this.workerManager.worker;
    if (t !== void 0 && !t.open)
      return this.set_progress({
        progress: 0,
        message: "connecting to worker manager",
        status: "error",
        blocking: !1
      });
    if (n === void 0)
      return this.set_progress({
        progress: 0,
        message: "please select worker",
        status: "error",
        blocking: !1
      });
    if (!n.is_open)
      return this.set_progress({
        progress: 0,
        message: "connecting to worker",
        status: "info",
        blocking: !0
      });
    this.set_progress({
      progress: 1,
      message: "running",
      status: "info",
      blocking: !1
    });
  }
  update_view_settings(t) {
    fD(this.local_settings, { view_settings: t });
  }
}
const nj = "1.0.0", jpe = ["1"], Ipe = (e) => {
  if (!e.v.toString().includes(".") || // old polugin version without "."
  !jpe.includes(e.v.toString().split(".")[0]))
    throw new Error(`Unsupported version: ${e.v}`);
  return { ...e, v: nj };
};
class zpe extends ql {
  constructor(t) {
    super(t), this.plugins = Er((n, r) => ({})), this.render_options = Er((n, r) => ({}));
  }
  add_plugin(t, n) {
    if (console.log("add_plugin", t, n), n !== void 0)
      try {
        const r = Ipe(n);
        this.plugins.setState((o) => ({ ...o, [t]: r }));
      } catch (r) {
        r instanceof Error ? this.context.rf.logger.error(`Error loading plugin ${t}`, r) : this.context.rf.logger.error(
          `Error loading plugin ${t}`,
          new Error(String(r))
        ), this.stateManager.toaster?.error({
          title: "Error",
          description: `Error loading plugin ${t}: ${r instanceof Error ? r.message : String(r)}`,
          duration: 5e3
        });
      }
  }
  update_render_options(t) {
    fD(this.render_options, t);
  }
  async add_packed_plugin(t, n) {
    if (n.js)
      for (const r of n.js) {
        const o = document.createElement("script");
        o.text = atob(r), document.body.appendChild(o);
      }
    if (n.css)
      for (const r of n.css) {
        const o = document.createElement("style");
        o.innerHTML = atob(r), document.head.appendChild(o);
      }
    if (n.module !== void 0) {
      const r = atob(n.module);
      try {
        const a = await new Function(
          "React",
          "FuncNodesReactFlow",
          `
          return (async () => {
            ${r}
            return FuncNodesPlugin;
          })();
        `
        )(gl, c6);
        this.add_plugin(t, a);
      } catch (o) {
        o instanceof Error ? this.context.rf.logger.error(`Error building plugin ${t}`, o) : this.context.rf.logger.error(
          `Error building plugin ${t}`,
          new Error(String(o))
        ), this.stateManager.toaster?.error({
          title: "Error",
          description: `Error building plugin ${t}: ${o}`,
          duration: 5e3
        });
      }
    }
  }
}
class Lpe extends ql {
  constructor(t) {
    super(t), this.on_rf_node_change = (n) => {
      const r = this.useReactFlowStore.getState();
      for (const o of n)
        switch (o.type) {
          case "position":
            if (o.position) {
              const a = r.getNode(o.id);
              if (a === void 0)
                continue;
              a.type === "group" ? this.nodespaceManager.change_group_position(o) : this.nodespaceManager.change_fn_node_position(o), a.data.groupID && this.nodespaceManager.auto_resize_group(a.data.groupID);
            }
            break;
          case "dimensions":
            if (o.dimensions) {
              const a = r.getNode(o.id);
              if (a === void 0)
                continue;
              a.type === "group" ? this.nodespaceManager.change_group_dimensions(o) : this.nodespaceManager.change_fn_node_dimensions(o), a.data.groupID && this.nodespaceManager.auto_resize_group(
                a.data.groupID
              );
            }
            break;
        }
    }, this.on_rf_edge_change = (n) => {
    }, this.on_connect = (n) => {
      n.source === null || n.target === null || n.sourceHandle === null || n.targetHandle === null || !this.workerManager.worker || this.workerManager.worker.api.edge.add_edge({
        src_nid: n.source,
        src_ioid: n.sourceHandle,
        trg_nid: n.target,
        trg_ioid: n.targetHandle,
        replace: !0
      });
    }, this.useReactFlowStore = kae({
      on_node_change: this.on_rf_node_change.bind(this),
      on_edge_change: this.on_rf_edge_change.bind(this),
      on_connect: this.on_connect.bind(this)
    });
  }
}
let Fpe = class {
  constructor(t) {
    this.reactflowRef = null, this.dev_settings = {
      debug: Mp
    }, this.options = t, this.logger = t.logger ?? new l1("fn", JR);
    const n = { rf: this };
    this._nodespaceManager = new Mpe(n), this._libManager = new Npe(n), this._workerManager = new Dpe(n), this._stateManager = new Ppe(n), this._pluginManager = new zpe(n), this._reactFlowManager = new Lpe(n);
  }
  // #region handlers
  getNodespaceManager() {
    return this._nodespaceManager;
  }
  getLibManager() {
    return this._libManager;
  }
  getWorkerManager() {
    return this._workerManager;
  }
  getStateManager() {
    return this._stateManager;
  }
  getPluginManager() {
    return this._pluginManager;
  }
  getReactFlowManager() {
    return this._reactFlowManager;
  }
  // #endregion handlers
  // #region nodespace manager
  get nodespace() {
    return this._nodespaceManager.nodespace;
  }
  get on_node_action() {
    return this._nodespaceManager.on_node_action.bind(this._nodespaceManager);
  }
  get on_edge_action() {
    return this._nodespaceManager.on_edge_action.bind(this._nodespaceManager);
  }
  get on_group_action() {
    return this._nodespaceManager.on_group_action.bind(this._nodespaceManager);
  }
  get clear_all() {
    return this._nodespaceManager.clear_all.bind(this._nodespaceManager);
  }
  get center_node() {
    return this._nodespaceManager.center_node.bind(this._nodespaceManager);
  }
  get center_all() {
    return this._nodespaceManager.center_all.bind(this._nodespaceManager);
  }
  // #endregion nodespace manager
  // #region lib manager
  get lib() {
    return this._libManager.lib;
  }
  // #endregion lib manager
  // #region worker manager
  get set_worker() {
    return this._workerManager.set_worker.bind(this._workerManager);
  }
  get workermanager() {
    return this._workerManager.workermanager;
  }
  set workermanager(t) {
    this._workerManager.workermanager = t;
  }
  get worker() {
    return this._workerManager.worker;
  }
  get workers() {
    return this._workerManager.workers;
  }
  get workerstate() {
    return this._workerManager.workerstate;
  }
  get _unsubscribeFromWorker() {
    return this._workerManager._unsubscribeFromWorker?.bind(
      this._workerManager
    );
  }
  // #endregion worker manager
  // #region statemanager
  get set_progress() {
    return this._stateManager.set_progress.bind(this._stateManager);
  }
  get auto_progress() {
    return this._stateManager.auto_progress.bind(this._stateManager);
  }
  get progress_state() {
    return this._stateManager.progress_state;
  }
  get local_settings() {
    return this._stateManager.local_settings;
  }
  get local_state() {
    return this._stateManager.local_state;
  }
  update_view_settings(t) {
    this._stateManager.update_view_settings(t);
  }
  // #endregion statemanager
  // #region plugis
  get plugins() {
    return this._pluginManager.plugins.bind(this._pluginManager);
  }
  get add_plugin() {
    return this._pluginManager.add_plugin.bind(this._pluginManager);
  }
  get add_packed_plugin() {
    return this._pluginManager.add_packed_plugin.bind(this._pluginManager);
  }
  get render_options() {
    return this._pluginManager.render_options.bind(this._pluginManager);
  }
  get update_render_options() {
    return this._pluginManager.update_render_options.bind(this._pluginManager);
  }
  // #endregion plugis
  // #region reactflow
  get useReactFlowStore() {
    return this._reactFlowManager.useReactFlowStore.bind(
      this._reactFlowManager
    );
  }
  get rf_instance() {
    return this._reactFlowManager.rf_instance;
  }
  set rf_instance(t) {
    this._reactFlowManager.rf_instance = t;
  }
  // #endregion reactflow
};
const $pe = c1(
  EZ,
  (e) => (e.id = px(), e)
), Bpe = (e) => {
  if (!e.useWorkerManager && e.worker === void 0)
    throw new Error(
      "If you don't use a worker manager, you must provide a default worker."
    );
  if (e.useWorkerManager && e.workermanager_url === void 0)
    throw new Error(
      "Error: If you use a worker manager, you must provide a worker managerurl."
    );
}, a1 = {};
window.fnrf_zst === void 0 && (window.fnrf_zst = a1);
const Hpe = (e) => {
  const [t, n] = _.useState(void 0), [r, o] = _.useState(
    void 0
  ), [a, s] = _.useState(!1);
  if (_.useEffect(() => {
    const u = $pe(e);
    u.logger = u.logger || new l1("FuncNodes", u.debug ? "debug" : "info"), u.logger.debug("Initializing FuncNodes with props:", u), n(u), s(!1);
  }, [e]), _.useEffect(() => {
    if (!t) return;
    t.logger?.debug("Initializing/Getting Zustand store");
    const u = a1[t.id];
    if (u === void 0) {
      const c = new Fpe(t);
      a1[t.id] = c, o(c);
    } else
      o(u), u.options.debug = t.debug;
  }, [t?.id, t?.debug]), _.useEffect(() => {
    if (!(!t || !r) && !(t.useWorkerManager || !t.worker_url))
      if (t.logger?.debug("Worker effect running"), t.worker) {
        t.worker.set_zustand(r);
        return;
      } else {
        t.logger?.debug("Creating WebSocket worker");
        const u = new D3({
          url: t.worker_url,
          uuid: t.id,
          on_sync_complete: t.on_sync_complete
        });
        return u.set_zustand(r), n(
          (c) => c && { ...c, worker: u, useWorkerManager: !1 }
        ), () => {
          t.logger?.debug("Disconnecting worker"), u.disconnect(), n((c) => c && { ...c, worker: void 0 });
        };
      }
  }, [
    t?.worker_url,
    t?.id,
    t?.useWorkerManager,
    r,
    t?.on_sync_complete
  ]), _.useEffect(() => {
    if (!t?.fnw_url || !t.worker) return;
    t.logger?.debug("Loading fnw_url data");
    let u = !1;
    const c = t.worker.getSyncManager().on_sync_complete;
    return (async () => {
      try {
        const h = await N6(t.fnw_url);
        !u && t.worker && (t.worker.getSyncManager().on_sync_complete = async (p) => {
          await p.update_from_export(h), t.worker.getSyncManager().on_sync_complete = c, c && c(p);
        });
      } catch (h) {
        h instanceof Error ? t.logger?.error("Failed to load fnw_url:", h) : t.logger?.error(
          "Failed to load fnw_url:",
          new Error(String(h))
        );
      }
    })(), () => {
      u = !0, t.worker && (t.worker.getSyncManager().on_sync_complete = c);
    };
  }, [t?.fnw_url, t?.worker]), _.useEffect(() => {
    if (!t || !r || !t.useWorkerManager) return;
    if (!t.workermanager_url)
      throw new Error(
        "Error: If you use a worker manager, you must provide a worker manager url."
      );
    r.logger.info("Worker manager effect running");
    const u = !r.workermanager, c = r.workermanager && r.workermanager.wsuri !== t.workermanager_url;
    if (u || c) {
      r.workermanager && (r.logger.info("Removing existing worker manager"), r.workermanager.remove(), r.workermanager = void 0), r.logger.info("Creating new worker manager");
      const f = new xZ(
        t.workermanager_url,
        r
      );
      return r.workermanager = f, n((h) => h && { ...h, workermanager: f }), () => {
        r.logger.info("Worker manager cleanup running"), r.workermanager === f ? (r.logger.info("Removing worker manager instance"), f.remove(), r.workermanager = void 0) : r.logger.info(
          "Worker manager instance mismatch, skipping cleanup"
        );
      };
    } else {
      r.logger.info(
        "Worker manager already initialized with correct URL"
      );
      return;
    }
  }, [
    t?.useWorkerManager,
    t?.workermanager_url,
    t?.id,
    r
  ]), _.useEffect(() => {
    if (!t || !r || a) return;
    (t.useWorkerManager ? r.workermanager !== void 0 : t.worker !== void 0) && t.on_ready && typeof t.on_ready == "function" && (t.logger?.debug("Firing on_ready callback"), t.on_ready({ fnrf_zst: r }), s(!0));
  }, [
    t,
    r,
    a,
    t?.useWorkerManager,
    r?.workermanager,
    t?.worker
  ]), t === void 0 || r === void 0)
    return /* @__PURE__ */ x.jsx("div", { children: "Loading..." });
  try {
    Bpe(t);
  } catch (u) {
    return /* @__PURE__ */ x.jsx(D6, { error: u });
  }
  return /* @__PURE__ */ x.jsx("div", { className: "FuncnodesApp", children: /* @__PURE__ */ x.jsx($V, { available_themes: P3, children: /* @__PURE__ */ x.jsx(vX, { duration: 5e3, children: /* @__PURE__ */ x.jsx(
    Ape,
    {
      fnrf_zst: r,
      header: t.header,
      library: t.library,
      flow: t.flow
    }
  ) }) }) });
}, rj = (e, t) => {
  t === void 0 && (t = {});
  const { element: n, eleid: r } = typeof e == "string" ? {
    element: document.getElementById(e),
    eleid: e
  } : { element: e, eleid: e.id };
  b6.createRoot(n).render(
    /* @__PURE__ */ x.jsx(_.StrictMode, { children: /* @__PURE__ */ x.jsx(Hpe, { ...t, id: t.id || r }) })
  );
};
window.FuncNodes = rj;
window.FuncNodes.version = "1.0.0";
window.FuncNodes.utils = {
  logger: {
    ConsoleLogger: l1,
    DivLogger: E6,
    BaseLogger: s1,
    DEBUG: x6,
    INFO: JR,
    WARN: w6,
    ERROR: _6
  }
};
