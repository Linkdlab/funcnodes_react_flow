var RP = Object.defineProperty;
var OP = (e, t, n) => t in e ? RP(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var Ru = (e, t, n) => OP(e, typeof t != "symbol" ? t + "" : t, n);
function NP(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in e)) {
          const a = Object.getOwnPropertyDescriptor(r, i);
          a && Object.defineProperty(e, i, a.get ? a : {
            enumerable: !0,
            get: () => r[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
(function() {
  const t = document.createElement("link").relList;
  if (t && t.supports && t.supports("modulepreload"))
    return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
    r(i);
  new MutationObserver((i) => {
    for (const a of i)
      if (a.type === "childList")
        for (const s of a.addedNodes)
          s.tagName === "LINK" && s.rel === "modulepreload" && r(s);
  }).observe(document, { childList: !0, subtree: !0 });
  function n(i) {
    const a = {};
    return i.integrity && (a.integrity = i.integrity), i.referrerPolicy && (a.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? a.credentials = "include" : i.crossOrigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin", a;
  }
  function r(i) {
    if (i.ep)
      return;
    i.ep = !0;
    const a = n(i);
    fetch(i.href, a);
  }
})();
function pl(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var x0 = { exports: {} }, Ou = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var j_;
function MP() {
  if (j_) return Ou;
  j_ = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.fragment");
  function n(r, i, a) {
    var s = null;
    if (a !== void 0 && (s = "" + a), i.key !== void 0 && (s = "" + i.key), "key" in i) {
      a = {};
      for (var u in i)
        u !== "key" && (a[u] = i[u]);
    } else a = i;
    return i = a.ref, {
      $$typeof: e,
      type: r,
      key: s,
      ref: i !== void 0 ? i : null,
      props: a
    };
  }
  return Ou.Fragment = t, Ou.jsx = n, Ou.jsxs = n, Ou;
}
var I_;
function DP() {
  return I_ || (I_ = 1, x0.exports = MP()), x0.exports;
}
var _ = DP(), w0 = { exports: {} }, $e = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var L_;
function PP() {
  if (L_) return $e;
  L_ = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.consumer"), s = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), f = Symbol.for("react.suspense"), d = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), p = Symbol.iterator;
  function g(O) {
    return O === null || typeof O != "object" ? null : (O = p && O[p] || O["@@iterator"], typeof O == "function" ? O : null);
  }
  var y = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, b = Object.assign, x = {};
  function E(O, W, Z) {
    this.props = O, this.context = W, this.refs = x, this.updater = Z || y;
  }
  E.prototype.isReactComponent = {}, E.prototype.setState = function(O, W) {
    if (typeof O != "object" && typeof O != "function" && O != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, O, W, "setState");
  }, E.prototype.forceUpdate = function(O) {
    this.updater.enqueueForceUpdate(this, O, "forceUpdate");
  };
  function S() {
  }
  S.prototype = E.prototype;
  function A(O, W, Z) {
    this.props = O, this.context = W, this.refs = x, this.updater = Z || y;
  }
  var k = A.prototype = new S();
  k.constructor = A, b(k, E.prototype), k.isPureReactComponent = !0;
  var R = Array.isArray, N = { H: null, A: null, T: null, S: null, V: null }, D = Object.prototype.hasOwnProperty;
  function P(O, W, Z, I, ie, fe) {
    return Z = fe.ref, {
      $$typeof: e,
      type: O,
      key: W,
      ref: Z !== void 0 ? Z : null,
      props: fe
    };
  }
  function F(O, W) {
    return P(
      O.type,
      W,
      void 0,
      void 0,
      void 0,
      O.props
    );
  }
  function V(O) {
    return typeof O == "object" && O !== null && O.$$typeof === e;
  }
  function T(O) {
    var W = { "=": "=0", ":": "=2" };
    return "$" + O.replace(/[=:]/g, function(Z) {
      return W[Z];
    });
  }
  var $ = /\/+/g;
  function H(O, W) {
    return typeof O == "object" && O !== null && O.key != null ? T("" + O.key) : W.toString(36);
  }
  function G() {
  }
  function j(O) {
    switch (O.status) {
      case "fulfilled":
        return O.value;
      case "rejected":
        throw O.reason;
      default:
        switch (typeof O.status == "string" ? O.then(G, G) : (O.status = "pending", O.then(
          function(W) {
            O.status === "pending" && (O.status = "fulfilled", O.value = W);
          },
          function(W) {
            O.status === "pending" && (O.status = "rejected", O.reason = W);
          }
        )), O.status) {
          case "fulfilled":
            return O.value;
          case "rejected":
            throw O.reason;
        }
    }
    throw O;
  }
  function U(O, W, Z, I, ie) {
    var fe = typeof O;
    (fe === "undefined" || fe === "boolean") && (O = null);
    var re = !1;
    if (O === null) re = !0;
    else
      switch (fe) {
        case "bigint":
        case "string":
        case "number":
          re = !0;
          break;
        case "object":
          switch (O.$$typeof) {
            case e:
            case t:
              re = !0;
              break;
            case h:
              return re = O._init, U(
                re(O._payload),
                W,
                Z,
                I,
                ie
              );
          }
      }
    if (re)
      return ie = ie(O), re = I === "" ? "." + H(O, 0) : I, R(ie) ? (Z = "", re != null && (Z = re.replace($, "$&/") + "/"), U(ie, W, Z, "", function(ye) {
        return ye;
      })) : ie != null && (V(ie) && (ie = F(
        ie,
        Z + (ie.key == null || O && O.key === ie.key ? "" : ("" + ie.key).replace(
          $,
          "$&/"
        ) + "/") + re
      )), W.push(ie)), 1;
    re = 0;
    var le = I === "" ? "." : I + ":";
    if (R(O))
      for (var he = 0; he < O.length; he++)
        I = O[he], fe = le + H(I, he), re += U(
          I,
          W,
          Z,
          fe,
          ie
        );
    else if (he = g(O), typeof he == "function")
      for (O = he.call(O), he = 0; !(I = O.next()).done; )
        I = I.value, fe = le + H(I, he++), re += U(
          I,
          W,
          Z,
          fe,
          ie
        );
    else if (fe === "object") {
      if (typeof O.then == "function")
        return U(
          j(O),
          W,
          Z,
          I,
          ie
        );
      throw W = String(O), Error(
        "Objects are not valid as a React child (found: " + (W === "[object Object]" ? "object with keys {" + Object.keys(O).join(", ") + "}" : W) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return re;
  }
  function z(O, W, Z) {
    if (O == null) return O;
    var I = [], ie = 0;
    return U(O, I, "", "", function(fe) {
      return W.call(Z, fe, ie++);
    }), I;
  }
  function B(O) {
    if (O._status === -1) {
      var W = O._result;
      W = W(), W.then(
        function(Z) {
          (O._status === 0 || O._status === -1) && (O._status = 1, O._result = Z);
        },
        function(Z) {
          (O._status === 0 || O._status === -1) && (O._status = 2, O._result = Z);
        }
      ), O._status === -1 && (O._status = 0, O._result = W);
    }
    if (O._status === 1) return O._result.default;
    throw O._result;
  }
  var q = typeof reportError == "function" ? reportError : function(O) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var W = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof O == "object" && O !== null && typeof O.message == "string" ? String(O.message) : String(O),
        error: O
      });
      if (!window.dispatchEvent(W)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", O);
      return;
    }
    console.error(O);
  };
  function Y() {
  }
  return $e.Children = {
    map: z,
    forEach: function(O, W, Z) {
      z(
        O,
        function() {
          W.apply(this, arguments);
        },
        Z
      );
    },
    count: function(O) {
      var W = 0;
      return z(O, function() {
        W++;
      }), W;
    },
    toArray: function(O) {
      return z(O, function(W) {
        return W;
      }) || [];
    },
    only: function(O) {
      if (!V(O))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return O;
    }
  }, $e.Component = E, $e.Fragment = n, $e.Profiler = i, $e.PureComponent = A, $e.StrictMode = r, $e.Suspense = f, $e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = N, $e.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(O) {
      return N.H.useMemoCache(O);
    }
  }, $e.cache = function(O) {
    return function() {
      return O.apply(null, arguments);
    };
  }, $e.cloneElement = function(O, W, Z) {
    if (O == null)
      throw Error(
        "The argument must be a React element, but you passed " + O + "."
      );
    var I = b({}, O.props), ie = O.key, fe = void 0;
    if (W != null)
      for (re in W.ref !== void 0 && (fe = void 0), W.key !== void 0 && (ie = "" + W.key), W)
        !D.call(W, re) || re === "key" || re === "__self" || re === "__source" || re === "ref" && W.ref === void 0 || (I[re] = W[re]);
    var re = arguments.length - 2;
    if (re === 1) I.children = Z;
    else if (1 < re) {
      for (var le = Array(re), he = 0; he < re; he++)
        le[he] = arguments[he + 2];
      I.children = le;
    }
    return P(O.type, ie, void 0, void 0, fe, I);
  }, $e.createContext = function(O) {
    return O = {
      $$typeof: s,
      _currentValue: O,
      _currentValue2: O,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, O.Provider = O, O.Consumer = {
      $$typeof: a,
      _context: O
    }, O;
  }, $e.createElement = function(O, W, Z) {
    var I, ie = {}, fe = null;
    if (W != null)
      for (I in W.key !== void 0 && (fe = "" + W.key), W)
        D.call(W, I) && I !== "key" && I !== "__self" && I !== "__source" && (ie[I] = W[I]);
    var re = arguments.length - 2;
    if (re === 1) ie.children = Z;
    else if (1 < re) {
      for (var le = Array(re), he = 0; he < re; he++)
        le[he] = arguments[he + 2];
      ie.children = le;
    }
    if (O && O.defaultProps)
      for (I in re = O.defaultProps, re)
        ie[I] === void 0 && (ie[I] = re[I]);
    return P(O, fe, void 0, void 0, null, ie);
  }, $e.createRef = function() {
    return { current: null };
  }, $e.forwardRef = function(O) {
    return { $$typeof: u, render: O };
  }, $e.isValidElement = V, $e.lazy = function(O) {
    return {
      $$typeof: h,
      _payload: { _status: -1, _result: O },
      _init: B
    };
  }, $e.memo = function(O, W) {
    return {
      $$typeof: d,
      type: O,
      compare: W === void 0 ? null : W
    };
  }, $e.startTransition = function(O) {
    var W = N.T, Z = {};
    N.T = Z;
    try {
      var I = O(), ie = N.S;
      ie !== null && ie(Z, I), typeof I == "object" && I !== null && typeof I.then == "function" && I.then(Y, q);
    } catch (fe) {
      q(fe);
    } finally {
      N.T = W;
    }
  }, $e.unstable_useCacheRefresh = function() {
    return N.H.useCacheRefresh();
  }, $e.use = function(O) {
    return N.H.use(O);
  }, $e.useActionState = function(O, W, Z) {
    return N.H.useActionState(O, W, Z);
  }, $e.useCallback = function(O, W) {
    return N.H.useCallback(O, W);
  }, $e.useContext = function(O) {
    return N.H.useContext(O);
  }, $e.useDebugValue = function() {
  }, $e.useDeferredValue = function(O, W) {
    return N.H.useDeferredValue(O, W);
  }, $e.useEffect = function(O, W, Z) {
    var I = N.H;
    if (typeof Z == "function")
      throw Error(
        "useEffect CRUD overload is not enabled in this build of React."
      );
    return I.useEffect(O, W);
  }, $e.useId = function() {
    return N.H.useId();
  }, $e.useImperativeHandle = function(O, W, Z) {
    return N.H.useImperativeHandle(O, W, Z);
  }, $e.useInsertionEffect = function(O, W) {
    return N.H.useInsertionEffect(O, W);
  }, $e.useLayoutEffect = function(O, W) {
    return N.H.useLayoutEffect(O, W);
  }, $e.useMemo = function(O, W) {
    return N.H.useMemo(O, W);
  }, $e.useOptimistic = function(O, W) {
    return N.H.useOptimistic(O, W);
  }, $e.useReducer = function(O, W, Z) {
    return N.H.useReducer(O, W, Z);
  }, $e.useRef = function(O) {
    return N.H.useRef(O);
  }, $e.useState = function(O) {
    return N.H.useState(O);
  }, $e.useSyncExternalStore = function(O, W, Z) {
    return N.H.useSyncExternalStore(
      O,
      W,
      Z
    );
  }, $e.useTransition = function() {
    return N.H.useTransition();
  }, $e.version = "19.1.0", $e;
}
var F_;
function Tc() {
  return F_ || (F_ = 1, w0.exports = PP()), w0.exports;
}
var C = Tc();
const Qt = /* @__PURE__ */ pl(C), gh = /* @__PURE__ */ NP({
  __proto__: null,
  default: Qt
}, [C]), zP = {}, B_ = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), r = (h, p) => {
    const g = typeof h == "function" ? h(t) : h;
    if (!Object.is(g, t)) {
      const y = t;
      t = p ?? (typeof g != "object" || g === null) ? g : Object.assign({}, t, g), n.forEach((b) => b(t, y));
    }
  }, i = () => t, f = { setState: r, getState: i, getInitialState: () => d, subscribe: (h) => (n.add(h), () => n.delete(h)), destroy: () => {
    (zP ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), n.clear();
  } }, d = t = e(r, i, f);
  return f;
}, CT = (e) => e ? B_(e) : B_;
var S0 = { exports: {} }, _0 = {}, E0 = { exports: {} }, C0 = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $_;
function jP() {
  if ($_) return C0;
  $_ = 1;
  var e = Tc();
  function t(p, g) {
    return p === g && (p !== 0 || 1 / p === 1 / g) || p !== p && g !== g;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, i = e.useEffect, a = e.useLayoutEffect, s = e.useDebugValue;
  function u(p, g) {
    var y = g(), b = r({ inst: { value: y, getSnapshot: g } }), x = b[0].inst, E = b[1];
    return a(
      function() {
        x.value = y, x.getSnapshot = g, f(x) && E({ inst: x });
      },
      [p, y, g]
    ), i(
      function() {
        return f(x) && E({ inst: x }), p(function() {
          f(x) && E({ inst: x });
        });
      },
      [p]
    ), s(y), y;
  }
  function f(p) {
    var g = p.getSnapshot;
    p = p.value;
    try {
      var y = g();
      return !n(p, y);
    } catch {
      return !0;
    }
  }
  function d(p, g) {
    return g();
  }
  var h = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? d : u;
  return C0.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : h, C0;
}
var H_;
function IP() {
  return H_ || (H_ = 1, E0.exports = jP()), E0.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var V_;
function LP() {
  if (V_) return _0;
  V_ = 1;
  var e = Tc(), t = IP();
  function n(d, h) {
    return d === h && (d !== 0 || 1 / d === 1 / h) || d !== d && h !== h;
  }
  var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, a = e.useRef, s = e.useEffect, u = e.useMemo, f = e.useDebugValue;
  return _0.useSyncExternalStoreWithSelector = function(d, h, p, g, y) {
    var b = a(null);
    if (b.current === null) {
      var x = { hasValue: !1, value: null };
      b.current = x;
    } else x = b.current;
    b = u(
      function() {
        function S(D) {
          if (!A) {
            if (A = !0, k = D, D = g(D), y !== void 0 && x.hasValue) {
              var P = x.value;
              if (y(P, D))
                return R = P;
            }
            return R = D;
          }
          if (P = R, r(k, D)) return P;
          var F = g(D);
          return y !== void 0 && y(P, F) ? (k = D, P) : (k = D, R = F);
        }
        var A = !1, k, R, N = p === void 0 ? null : p;
        return [
          function() {
            return S(h());
          },
          N === null ? void 0 : function() {
            return S(N());
          }
        ];
      },
      [h, p, g, y]
    );
    var E = i(d, b[0], b[1]);
    return s(
      function() {
        x.hasValue = !0, x.value = E;
      },
      [E]
    ), f(E), E;
  }, _0;
}
var U_;
function FP() {
  return U_ || (U_ = 1, S0.exports = LP()), S0.exports;
}
var BP = FP();
const kT = /* @__PURE__ */ pl(BP), AT = {}, { useDebugValue: $P } = Qt, { useSyncExternalStoreWithSelector: HP } = kT;
let q_ = !1;
const VP = (e) => e;
function UP(e, t = VP, n) {
  (AT ? "production" : void 0) !== "production" && n && !q_ && (console.warn(
    "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
  ), q_ = !0);
  const r = HP(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return $P(r), r;
}
const Y_ = (e) => {
  (AT ? "production" : void 0) !== "production" && typeof e != "function" && console.warn(
    "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
  );
  const t = typeof e == "function" ? CT(e) : e, n = (r, i) => UP(t, r, i);
  return Object.assign(n, t), n;
}, bn = (e) => e ? Y_(e) : Y_, qP = () => ({
  libstate: bn((e, t) => ({
    lib: {
      shelves: []
    },
    external_worker: [],
    set: (n) => e((r) => ({ ...r, ...n })),
    get_lib: () => t().lib,
    get_external_worker: () => t().external_worker
  }))
}), YP = ({}) => {
  const e = /* @__PURE__ */ new Map();
  return {
    nodesstates: e,
    get_node: (t, n = !0) => {
      const r = e.get(t);
      if (!r && n) {
        const i = e.keys();
        throw new Error(
          `Node ${t} not found, available nodes: ${Array.from(i)}`
        );
      }
      return r;
    }
  };
};
function Lo(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function cb(e, t) {
  if (e === t) return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null || e.constructor !== t.constructor) return !1;
  if (e.constructor === Object || e.constructor === Array) {
    const n = Object.keys(e), r = Object.keys(t);
    if (n.length !== r.length) return !1;
    for (const i of n)
      if (!r.includes(i) || !cb(e[i], t[i])) return !1;
  }
  return e instanceof Date && t instanceof Date ? e.getTime() === t.getTime() : !0;
}
const Or = (e, t) => {
  let n = !1;
  if (!Lo(e))
    throw new Error("Target must be a plain object not" + typeof e);
  if (!Lo(t))
    throw new Error("Source must be a plain object not" + typeof t);
  const r = { ...e };
  return Object.keys(t).forEach((i) => {
    const a = t[i], s = e[i];
    if (Lo(a) && Lo(s)) {
      const { new_obj: u, change: f } = Or(
        s,
        a
      );
      f && (n = !0, r[i] = u);
    } else cb(s, a) || (n = !0, r[i] = a);
  }), { new_obj: r, change: n };
}, np = (e, t) => {
  let n = !1;
  if (!Lo(e))
    throw new Error("Target must be a plain object");
  if (!Lo(t))
    throw new Error("Source must be a plain object");
  const r = { ...e };
  return Object.keys(t).forEach((i) => {
    const a = t[i], s = e[i];
    if (!(s === void 0 && a === void 0)) {
      if (s === void 0) {
        n = !0, r[i] = a;
        return;
      }
      if (Lo(a) && Lo(s)) {
        const { new_obj: u, change: f } = np(
          s,
          a
        );
        f && (n = !0, r[i] = u);
      }
    }
  }), { new_obj: r, change: n };
}, Wr = (e, t) => t === void 0 ? [e, !1] : [t, e !== t];
function TT(e, t) {
  throw new Error("Unhandled case: " + e + " with: " + JSON.stringify(t));
}
const RT = (e) => {
  e.io === void 0 && (e.io = {});
  let t = e.io, n = e.io_order;
  if (n === void 0)
    if (Array.isArray(t)) {
      n = t.map((i) => i.id);
      const r = {};
      for (const i of t)
        r[i.id] = i;
      t = r;
    } else
      n = Object.keys(e.io);
  else if (Array.isArray(t)) {
    const r = {};
    for (const i of t)
      r[i.id] = i, n.includes(i.id) || n.push(i.id);
    t = r;
  } else
    for (const r in t)
      n.includes(r) || n.push(r);
  return { ...e, io_order: n, io: t };
}, GP = (e, t) => {
  const n = e.getState(), r = {}, i = RT(t), a = Object.keys(
    i
  );
  for (const s of a)
    switch (s) {
      case "id": {
        const [u, f] = Wr(
          n[s],
          i[s]
        );
        f && (r[s] = u);
        break;
      }
      case "node_id": {
        const [u, f] = Wr(
          n[s],
          i[s]
        );
        f && (r[s] = u);
        break;
      }
      case "node_name": {
        const [u, f] = Wr(
          n[s],
          i[s]
        );
        f && (r[s] = u);
        break;
      }
      case "name": {
        const [u, f] = Wr(
          n[s],
          i[s]
        );
        f && (r[s] = u);
        break;
      }
      case "in_trigger": {
        n[s].setState(!!i[s]);
        break;
      }
      case "error": {
        i[s] !== n[s] && (r[s] = i[s]);
        break;
      }
      case "render_options": {
        const [u, f] = ((d, h) => {
          if (h === void 0) return [d, !1];
          if (d === void 0) return [h, h !== void 0];
          const { new_obj: p, change: g } = Or(d, h);
          return [p, g];
        })(n[s], i[s]);
        f && (r[s] = u);
        break;
      }
      case "io_order": {
        const [u, f] = ((d, h) => h === void 0 ? [d, !1] : [h, !cb(d, h)])(n[s], i[s]);
        f && (r[s] = u);
        break;
      }
      case "io": {
        const u = n[s], f = i[s];
        if (f === void 0 || u === void 0) break;
        for (const d in f) {
          if (u[d] === void 0) {
            console.error(
              "io key not found in oldvalue:",
              d,
              "allowed:",
              u,
              "for update:",
              i
            );
            continue;
          }
          u[d].update(f[d]);
        }
        break;
      }
      case "progress": {
        const [u, f] = ((d, h) => {
          if (h === void 0) return [d, !1];
          if (d === void 0) return [h, h !== void 0];
          const { new_obj: p, change: g } = Or(d, h);
          return [p, g];
        })(n[s].getState(), i[s]);
        f && n[s].setState(u);
        break;
      }
      case "description": {
        r[s] = i[s];
        break;
      }
      case "properties": {
        const [u, f] = ((d, h) => {
          if (h === void 0) return [d, !1];
          if (d === void 0) return [h, h !== void 0];
          const { new_obj: p, change: g } = Or(d, h);
          return [p, g];
        })(n[s], i[s]);
        f && (r[s] = u);
        break;
      }
      case "status": {
        const [u, f] = ((d, h) => {
          if (h === void 0) return [d, !1];
          if (d === void 0) return [h, h !== void 0];
          const { new_obj: p, change: g } = Or(d, h);
          return [p, g];
        })(n[s], i[s]);
        f && (r[s] = u);
        break;
      }
      default:
        try {
          TT(s, i[s]);
        } catch (u) {
          console.error(u);
        }
    }
  Object.keys(r).length > 0 && e.setState(r);
}, G_ = (e, t) => {
  e.properties = e.properties || {}, t.pos && (e.properties["frontend:pos"] = t.pos), t.size && (e.properties["frontend:size"] = t.size), t.collapsed !== void 0 && (e.properties["frontend:collapsed"] = !!t.collapsed);
}, XP = (e, t) => {
  const n = e.getState(), r = {}, i = {}, a = Object.keys(t);
  for (const s of a)
    switch (s) {
      case "name": {
        const [u, f] = Wr(
          n[s],
          t[s]
        );
        f && (r[s] = u);
        break;
      }
      case "id": {
        const [u, f] = Wr(
          n[s],
          t[s]
        );
        f && (r[s] = u);
        break;
      }
      case "connected": {
        const [u, f] = Wr(
          n[s],
          t[s]
        );
        f && (r[s] = u);
        break;
      }
      case "does_trigger": {
        const [u, f] = Wr(
          n[s],
          t[s]
        );
        f && (r[s] = u);
        break;
      }
      case "hidden": {
        const [u, f] = Wr(
          n[s],
          t[s]
        );
        f && (r[s] = u);
        break;
      }
      case "full_id": {
        const [u, f] = Wr(
          n[s],
          t[s]
        );
        f && (r[s] = u);
        break;
      }
      case "is_input":
        break;
      case "node":
        break;
      case "type":
        break;
      case "value": {
        i.preview = t[s];
        break;
      }
      case "fullvalue": {
        i.full = t[s];
        break;
      }
      case "render_options": {
        const [u, f] = ((d, h) => {
          if (h === void 0) return [d, !1];
          if (d === void 0) return [h, h !== void 0];
          const { new_obj: p, change: g } = Or(d, h);
          return [p, g];
        })(n[s], t[s]);
        f && (r[s] = u);
        break;
      }
      case "value_options": {
        const [u, f] = ((d, h) => {
          if (h === void 0) return [d, !1];
          if (d === void 0) return [h, h !== void 0];
          const { new_obj: p, change: g } = Or(d, h);
          return [p, g];
        })(n[s], t[s]);
        f && (r[s] = u);
        break;
      }
      case "valuepreview_type": {
        r[s] = t[s];
        break;
      }
      case "emit_value_set": {
        r[s] = t[s];
        break;
      }
      case "default": {
        r[s] = t[s];
        break;
      }
      case "required": {
        r[s] = t[s];
        break;
      }
      default:
        try {
          TT(s, t[s]);
        } catch (u) {
          console.error(u);
        }
    }
  Object.keys(i).length > 0 && e.updateValueStore(i), Object.keys(r).length > 0 && e.setState(r);
};
class zi {
  constructor({ data: t, mime: n }) {
    this._data = t, this._mime = n;
  }
  get data() {
    return this._data;
  }
  get value() {
    return this._data;
  }
  get mime() {
    return this._mime;
  }
  toString() {
    return this._data instanceof ArrayBuffer ? `DataStructure(${this._data.byteLength},${this._mime})` : this._data instanceof Blob ? `DataStructure(${this._data.size},${this._mime})` : this._data instanceof String ? `DataStructure(${this._data.length},${this._mime})` : this._data instanceof Array ? `DataStructure(${this._data.length},${this._mime})` : this._data instanceof Object ? `DataStructure(${Object.keys(this._data).length},${this._mime})` : `DataStructure(${this._mime})`;
  }
  toJSON() {
    return this.toString();
  }
  dispose() {
  }
}
class WP extends zi {
  get objectUrl() {
    if (this._objectUrl)
      return this._objectUrl;
    const t = this.data instanceof Blob ? this.data : new Blob([this.data], { type: this.mime });
    return this._objectUrl = URL.createObjectURL(t), this._objectUrl;
  }
  dispose() {
    this._objectUrl && URL.revokeObjectURL(this._objectUrl), super.dispose();
  }
  get value() {
    return this.objectUrl;
  }
}
const $t = (e) => e.buffer ? e.buffer : e, KP = {
  x: (e, t) => null,
  //  pad byte 	no value 	(7 )
  c: (e, t) => new DataView($t(e)).getInt8(0),
  //  char 	bytes of length 1 	1 	b 	signed char 	integer 	1 	(1 ), (2 )
  B: (e, t) => new DataView($t(e)).getUint8(0),
  //  unsigned char 	integer 	1 	(2 )
  "?": (e, t) => new DataView($t(e)).getInt8(0) === 1,
  //  _Bool 	bool 	1 	(1 )
  h: (e, t) => new DataView($t(e)).getInt16(0, t),
  //  short 	integer 	2 	(2 )
  H: (e, t) => new DataView($t(e)).getUint16(0, t),
  //  unsigned short 	integer 	2 	(2 )
  i: (e, t) => new DataView($t(e)).getInt32(0, t),
  //  int 	integer 	4 	(2 )
  I: (e, t) => new DataView($t(e)).getUint32(0, t),
  //  unsigned int 	integer 	4 	(2 )
  l: (e, t) => new DataView($t(e)).getInt32(0, t),
  //  long 	integer 	4 	(2 )
  L: (e, t) => new DataView($t(e)).getUint32(0, t),
  //  unsigned long 	integer 	4 	(2 )
  q: (e, t) => Number(
    new DataView($t(e)).getBigInt64(0, t)
  ),
  //  long long 	integer 	8 	(2 )
  Q: (e, t) => Number(
    new DataView($t(e)).getBigUint64(0, t)
  ),
  //  unsigned long long 	integer 	8 	(2 )
  n: (e, t) => Number(
    new DataView($t(e)).getBigInt64(0, t)
  ),
  //  ssize_t 	integer 	(3 )
  N: (e, t) => Number(
    new DataView($t(e)).getBigUint64(0, t)
  ),
  //  size_t 	integer 	(3 )
  // "e":(data:ArrayBufferLike)=>{return new DataView(to_arraybuffer(data)).getFloat16(0)}, //  (6 ) float 	2 	(4 )
  f: (e, t) => new DataView($t(e)).getFloat32(0, t),
  //  float 	float 	4 	(4 )
  d: (e, t) => new DataView($t(e)).getFloat64(0, t),
  //  double 	float 	8 	(4 )
  s: (e, t) => new TextDecoder().decode($t(e)),
  //  char[] 	bytes 	(9 )
  p: (e, t) => new TextDecoder().decode($t(e)),
  //  char[] 	bytes 	(8 )
  P: (e, t) => Number(
    new DataView($t(e)).getBigUint64(0, t)
  )
  //  void* 	int
};
class ZP extends zi {
  constructor({ data: t, mime: n }) {
    super({ data: t, mime: n }), this._cType = n.split("application/fn.struct.")[1], this._value = null, this.parse_value();
  }
  parse_value() {
    let t = !0, n = this._cType;
    return n.startsWith("<") && (t = !0, n = n.slice(1)), n.startsWith(">") && (t = !1, n = n.slice(1)), n.startsWith("!") && (t = !1, n = n.slice(1)), n.startsWith("@") && (t = !1, n = n.slice(1)), n.startsWith("=") && (t = !1, n = n.slice(1)), this._value = KP[n](this.data, t), this._value;
  }
  get value() {
    return this._value;
  }
  toString() {
    return this._value === null ? "null" : this._value.toString();
  }
}
class ba extends zi {
  constructor({ data: t, mime: n }) {
    super({ data: t, mime: n }), t.length === 0 ? this._json = void 0 : (this._json = JSON.parse(new TextDecoder().decode($t(t))), this._json === "<NoValue>" && (this._json = void 0));
  }
  get value() {
    return this._json;
  }
  static fromObject(t) {
    const n = t === "<NoValue>" ? new Uint8Array(0) : new TextEncoder().encode(JSON.stringify(t));
    return new ba({ data: n, mime: "application/json" });
  }
  toString() {
    return JSON.stringify(this._json);
  }
}
class QP extends zi {
  constructor({ data: t, mime: n }) {
    super({ data: t, mime: n }), this._value = new TextDecoder().decode($t(t));
  }
  get value() {
    return this._value;
  }
  toString() {
    return this._value;
  }
}
const X_ = ({
  data: e,
  mime: t
}) => e instanceof ArrayBuffer || e instanceof Uint8Array ? t.startsWith("application/fn.struct.") ? new ZP({ data: e, mime: t }) : t.startsWith("application/json") ? new ba({ data: e, mime: t }) : t === "text" || t.startsWith("text/") ? new QP({ data: e, mime: t }) : new WP({ data: e, mime: t }) : new zi({ data: e, mime: t }), JP = {
  id: "dummy",
  node_id: "dummy",
  node_name: "dummy",
  properties: {
    "frontend:size": [200, 100],
    "frontend:pos": [NaN, NaN],
    "frontend:collapsed": !1
  },
  io: {},
  name: "dummy",
  in_trigger: !1,
  progress: {
    ascii: !1,
    elapsed: 0,
    initial: 0,
    n: 0,
    prefix: "idle",
    unit: "it",
    unit_divisor: 1e3,
    unit_scale: !1
  }
}, e6 = {
  id: "dummy",
  name: "dummy",
  node: "dummy",
  full_id: "dummy",
  type: "any",
  value: void 0,
  is_input: !1,
  connected: !1,
  does_trigger: !0,
  fullvalue: void 0,
  render_options: {
    set_default: !0,
    type: "any"
  },
  hidden: !1,
  emit_value_set: !0,
  required: !1
}, t6 = (e, t) => {
  const n = () => {
    t.node === void 0 || t.id === void 0 || e.worker?.get_io_full_value({ nid: t.node, ioid: t.id });
  };
  return t.value === "<NoValue>" && (t.value = void 0), t.fullvalue === "<NoValue>" && (t.fullvalue = void 0), t.hidden === void 0 && (t.hidden = !1), {
    ...t,
    try_get_full_value: n,
    set_hidden: (a) => {
      t.node === void 0 || t.id === void 0 || e.worker?.update_io_options({
        nid: t.node,
        ioid: t.id,
        options: { hidden: a }
      });
    }
  };
}, n6 = (e, t) => {
  if (!t.id)
    throw new Error(
      "IO must have an id but is missing for " + JSON.stringify(t)
    );
  t.name === void 0 && (t.name = t.id);
  const { new_obj: n } = np(t, e6);
  return (n.render_options.type === "any" || n.render_options.type === void 0) && (n.render_options.type = n.type), t6(e, n);
}, r6 = (e, t, n) => {
  let r;
  if (e === void 0)
    throw new Error("nodestore is undefined");
  return r = {
    _state: bn(
      (i, a) => n6(t, n)
    ),
    use: () => r._state(),
    getState: () => r._state.getState(),
    setState: (i) => {
      r._state.setState(i);
    },
    update: (i) => {
      XP(r, i);
    },
    valuestore: bn((i, a) => {
      let s = n.value;
      s === "<NoValue>" && (s = void 0), !(s instanceof zi) && s !== void 0 && (s = ba.fromObject(s));
      let u = n.fullvalue;
      return u === "<NoValue>" && (u = void 0), !(u instanceof zi) && u !== void 0 && (u = ba.fromObject(u)), {
        preview: s,
        full: u
      };
    }),
    updateValueStore: (i) => {
      r.valuestore.setState((a) => (a.preview && typeof a.preview.dispose == "function" && a.preview.dispose(), a.full && typeof a.full.dispose == "function" && a.full.dispose(), i.preview !== void 0 && i.full === void 0 && (i.full = void 0, a.full = void 0), i.preview !== void 0 && !(i.preview instanceof zi) && (i.preview = ba.fromObject(i.preview)), i.full !== void 0 && !(i.full instanceof zi) && (i.full = ba.fromObject(i.full)), { ...a, ...i }));
    },
    node: e
  }, r;
}, i6 = (e, t, n) => {
  const r = n.io_order;
  if (r === void 0)
    throw new Error("Node must have io_order");
  return {
    ...n,
    in_trigger: bn(() => !1),
    inputs: Object.keys(n.io).filter((a) => n.io[a].is_input),
    outputs: Object.keys(n.io).filter((a) => !n.io[a].is_input),
    io: Object.fromEntries(
      Object.entries(n.io).map(([a, s]) => [
        a,
        r6(e, t, s)
      ])
    ),
    io_order: r,
    progress: bn(() => n.progress)
  };
}, o6 = (e, t, n) => {
  if (!n.id)
    throw new Error("Node must have an id");
  const { new_obj: r } = np(
    n,
    JP
  );
  return i6(
    e,
    t,
    r
  );
}, a6 = (e, t) => {
  const r = {
    use: () => r._state(),
    getState: () => r._state.getState(),
    setState: (i) => {
      r._state.setState(i);
    },
    update: (i) => {
      GP(r._state, i);
    }
  };
  return r._state = bn((i, a) => o6(r, e, RT(t))), r;
};
function qt(e) {
  if (typeof e == "string" || typeof e == "number") return "" + e;
  let t = "";
  if (Array.isArray(e))
    for (let n = 0, r; n < e.length; n++)
      (r = qt(e[n])) !== "" && (t += (t && " ") + r);
  else
    for (let n in e)
      e[n] && (t += (t && " ") + n);
  return t;
}
var s6 = { value: () => {
} };
function rp() {
  for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {
    if (!(r = arguments[e] + "") || r in n || /[\s.]/.test(r)) throw new Error("illegal type: " + r);
    n[r] = [];
  }
  return new Kd(n);
}
function Kd(e) {
  this._ = e;
}
function l6(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var r = "", i = n.indexOf(".");
    if (i >= 0 && (r = n.slice(i + 1), n = n.slice(0, i)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
    return { type: n, name: r };
  });
}
Kd.prototype = rp.prototype = {
  constructor: Kd,
  on: function(e, t) {
    var n = this._, r = l6(e + "", n), i, a = -1, s = r.length;
    if (arguments.length < 2) {
      for (; ++a < s; ) if ((i = (e = r[a]).type) && (i = u6(n[i], e.name))) return i;
      return;
    }
    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
    for (; ++a < s; )
      if (i = (e = r[a]).type) n[i] = W_(n[i], e.name, t);
      else if (t == null) for (i in n) n[i] = W_(n[i], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t) e[n] = t[n].slice();
    return new Kd(e);
  },
  call: function(e, t) {
    if ((i = arguments.length - 2) > 0) for (var n = new Array(i), r = 0, i, a; r < i; ++r) n[r] = arguments[r + 2];
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (a = this._[e], r = 0, i = a.length; r < i; ++r) a[r].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (var r = this._[e], i = 0, a = r.length; i < a; ++i) r[i].value.apply(t, n);
  }
};
function u6(e, t) {
  for (var n = 0, r = e.length, i; n < r; ++n)
    if ((i = e[n]).name === t)
      return i.value;
}
function W_(e, t, n) {
  for (var r = 0, i = e.length; r < i; ++r)
    if (e[r].name === t) {
      e[r] = s6, e = e.slice(0, r).concat(e.slice(r + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var By = "http://www.w3.org/1999/xhtml";
const K_ = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: By,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function ip(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), K_.hasOwnProperty(t) ? { space: K_[t], local: e } : e;
}
function c6(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === By && t.documentElement.namespaceURI === By ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function f6(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function OT(e) {
  var t = ip(e);
  return (t.local ? f6 : c6)(t);
}
function d6() {
}
function fb(e) {
  return e == null ? d6 : function() {
    return this.querySelector(e);
  };
}
function h6(e) {
  typeof e != "function" && (e = fb(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var a = t[i], s = a.length, u = r[i] = new Array(s), f, d, h = 0; h < s; ++h)
      (f = a[h]) && (d = e.call(f, f.__data__, h, a)) && ("__data__" in f && (d.__data__ = f.__data__), u[h] = d);
  return new nr(r, this._parents);
}
function p6(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function m6() {
  return [];
}
function NT(e) {
  return e == null ? m6 : function() {
    return this.querySelectorAll(e);
  };
}
function g6(e) {
  return function() {
    return p6(e.apply(this, arguments));
  };
}
function y6(e) {
  typeof e == "function" ? e = g6(e) : e = NT(e);
  for (var t = this._groups, n = t.length, r = [], i = [], a = 0; a < n; ++a)
    for (var s = t[a], u = s.length, f, d = 0; d < u; ++d)
      (f = s[d]) && (r.push(e.call(f, f.__data__, d, s)), i.push(f));
  return new nr(r, i);
}
function MT(e) {
  return function() {
    return this.matches(e);
  };
}
function DT(e) {
  return function(t) {
    return t.matches(e);
  };
}
var v6 = Array.prototype.find;
function b6(e) {
  return function() {
    return v6.call(this.children, e);
  };
}
function x6() {
  return this.firstElementChild;
}
function w6(e) {
  return this.select(e == null ? x6 : b6(typeof e == "function" ? e : DT(e)));
}
var S6 = Array.prototype.filter;
function _6() {
  return Array.from(this.children);
}
function E6(e) {
  return function() {
    return S6.call(this.children, e);
  };
}
function C6(e) {
  return this.selectAll(e == null ? _6 : E6(typeof e == "function" ? e : DT(e)));
}
function k6(e) {
  typeof e != "function" && (e = MT(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var a = t[i], s = a.length, u = r[i] = [], f, d = 0; d < s; ++d)
      (f = a[d]) && e.call(f, f.__data__, d, a) && u.push(f);
  return new nr(r, this._parents);
}
function PT(e) {
  return new Array(e.length);
}
function A6() {
  return new nr(this._enter || this._groups.map(PT), this._parents);
}
function yh(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
yh.prototype = {
  constructor: yh,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function T6(e) {
  return function() {
    return e;
  };
}
function R6(e, t, n, r, i, a) {
  for (var s = 0, u, f = t.length, d = a.length; s < d; ++s)
    (u = t[s]) ? (u.__data__ = a[s], r[s] = u) : n[s] = new yh(e, a[s]);
  for (; s < f; ++s)
    (u = t[s]) && (i[s] = u);
}
function O6(e, t, n, r, i, a, s) {
  var u, f, d = /* @__PURE__ */ new Map(), h = t.length, p = a.length, g = new Array(h), y;
  for (u = 0; u < h; ++u)
    (f = t[u]) && (g[u] = y = s.call(f, f.__data__, u, t) + "", d.has(y) ? i[u] = f : d.set(y, f));
  for (u = 0; u < p; ++u)
    y = s.call(e, a[u], u, a) + "", (f = d.get(y)) ? (r[u] = f, f.__data__ = a[u], d.delete(y)) : n[u] = new yh(e, a[u]);
  for (u = 0; u < h; ++u)
    (f = t[u]) && d.get(g[u]) === f && (i[u] = f);
}
function N6(e) {
  return e.__data__;
}
function M6(e, t) {
  if (!arguments.length) return Array.from(this, N6);
  var n = t ? O6 : R6, r = this._parents, i = this._groups;
  typeof e != "function" && (e = T6(e));
  for (var a = i.length, s = new Array(a), u = new Array(a), f = new Array(a), d = 0; d < a; ++d) {
    var h = r[d], p = i[d], g = p.length, y = D6(e.call(h, h && h.__data__, d, r)), b = y.length, x = u[d] = new Array(b), E = s[d] = new Array(b), S = f[d] = new Array(g);
    n(h, p, x, E, S, y, t);
    for (var A = 0, k = 0, R, N; A < b; ++A)
      if (R = x[A]) {
        for (A >= k && (k = A + 1); !(N = E[k]) && ++k < b; ) ;
        R._next = N || null;
      }
  }
  return s = new nr(s, r), s._enter = u, s._exit = f, s;
}
function D6(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function P6() {
  return new nr(this._exit || this._groups.map(PT), this._parents);
}
function z6(e, t, n) {
  var r = this.enter(), i = this, a = this.exit();
  return typeof e == "function" ? (r = e(r), r && (r = r.selection())) : r = r.append(e + ""), t != null && (i = t(i), i && (i = i.selection())), n == null ? a.remove() : n(a), r && i ? r.merge(i).order() : i;
}
function j6(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, r = t._groups, i = n.length, a = r.length, s = Math.min(i, a), u = new Array(i), f = 0; f < s; ++f)
    for (var d = n[f], h = r[f], p = d.length, g = u[f] = new Array(p), y, b = 0; b < p; ++b)
      (y = d[b] || h[b]) && (g[b] = y);
  for (; f < i; ++f)
    u[f] = n[f];
  return new nr(u, this._parents);
}
function I6() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var r = e[t], i = r.length - 1, a = r[i], s; --i >= 0; )
      (s = r[i]) && (a && s.compareDocumentPosition(a) ^ 4 && a.parentNode.insertBefore(s, a), a = s);
  return this;
}
function L6(e) {
  e || (e = F6);
  function t(p, g) {
    return p && g ? e(p.__data__, g.__data__) : !p - !g;
  }
  for (var n = this._groups, r = n.length, i = new Array(r), a = 0; a < r; ++a) {
    for (var s = n[a], u = s.length, f = i[a] = new Array(u), d, h = 0; h < u; ++h)
      (d = s[h]) && (f[h] = d);
    f.sort(t);
  }
  return new nr(i, this._parents).order();
}
function F6(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function B6() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function $6() {
  return Array.from(this);
}
function H6() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], i = 0, a = r.length; i < a; ++i) {
      var s = r[i];
      if (s) return s;
    }
  return null;
}
function V6() {
  let e = 0;
  for (const t of this) ++e;
  return e;
}
function U6() {
  return !this.node();
}
function q6(e) {
  for (var t = this._groups, n = 0, r = t.length; n < r; ++n)
    for (var i = t[n], a = 0, s = i.length, u; a < s; ++a)
      (u = i[a]) && e.call(u, u.__data__, a, i);
  return this;
}
function Y6(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function G6(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function X6(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function W6(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function K6(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function Z6(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function Q6(e, t) {
  var n = ip(e);
  if (arguments.length < 2) {
    var r = this.node();
    return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);
  }
  return this.each((t == null ? n.local ? G6 : Y6 : typeof t == "function" ? n.local ? Z6 : K6 : n.local ? W6 : X6)(n, t));
}
function zT(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function J6(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function ez(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function tz(e, t, n) {
  return function() {
    var r = t.apply(this, arguments);
    r == null ? this.style.removeProperty(e) : this.style.setProperty(e, r, n);
  };
}
function nz(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? J6 : typeof t == "function" ? tz : ez)(e, t, n ?? "")) : el(this.node(), e);
}
function el(e, t) {
  return e.style.getPropertyValue(t) || zT(e).getComputedStyle(e, null).getPropertyValue(t);
}
function rz(e) {
  return function() {
    delete this[e];
  };
}
function iz(e, t) {
  return function() {
    this[e] = t;
  };
}
function oz(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function az(e, t) {
  return arguments.length > 1 ? this.each((t == null ? rz : typeof t == "function" ? oz : iz)(e, t)) : this.node()[e];
}
function jT(e) {
  return e.trim().split(/^|\s+/);
}
function db(e) {
  return e.classList || new IT(e);
}
function IT(e) {
  this._node = e, this._names = jT(e.getAttribute("class") || "");
}
IT.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function LT(e, t) {
  for (var n = db(e), r = -1, i = t.length; ++r < i; ) n.add(t[r]);
}
function FT(e, t) {
  for (var n = db(e), r = -1, i = t.length; ++r < i; ) n.remove(t[r]);
}
function sz(e) {
  return function() {
    LT(this, e);
  };
}
function lz(e) {
  return function() {
    FT(this, e);
  };
}
function uz(e, t) {
  return function() {
    (t.apply(this, arguments) ? LT : FT)(this, e);
  };
}
function cz(e, t) {
  var n = jT(e + "");
  if (arguments.length < 2) {
    for (var r = db(this.node()), i = -1, a = n.length; ++i < a; ) if (!r.contains(n[i])) return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? uz : t ? sz : lz)(n, t));
}
function fz() {
  this.textContent = "";
}
function dz(e) {
  return function() {
    this.textContent = e;
  };
}
function hz(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function pz(e) {
  return arguments.length ? this.each(e == null ? fz : (typeof e == "function" ? hz : dz)(e)) : this.node().textContent;
}
function mz() {
  this.innerHTML = "";
}
function gz(e) {
  return function() {
    this.innerHTML = e;
  };
}
function yz(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function vz(e) {
  return arguments.length ? this.each(e == null ? mz : (typeof e == "function" ? yz : gz)(e)) : this.node().innerHTML;
}
function bz() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function xz() {
  return this.each(bz);
}
function wz() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function Sz() {
  return this.each(wz);
}
function _z(e) {
  var t = typeof e == "function" ? e : OT(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function Ez() {
  return null;
}
function Cz(e, t) {
  var n = typeof e == "function" ? e : OT(e), r = t == null ? Ez : typeof t == "function" ? t : fb(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null);
  });
}
function kz() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function Az() {
  return this.each(kz);
}
function Tz() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function Rz() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function Oz(e) {
  return this.select(e ? Rz : Tz);
}
function Nz(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function Mz(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function Dz(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", r = t.indexOf(".");
    return r >= 0 && (n = t.slice(r + 1), t = t.slice(0, r)), { type: t, name: n };
  });
}
function Pz(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, r = -1, i = t.length, a; n < i; ++n)
        a = t[n], (!e.type || a.type === e.type) && a.name === e.name ? this.removeEventListener(a.type, a.listener, a.options) : t[++r] = a;
      ++r ? t.length = r : delete this.__on;
    }
  };
}
function zz(e, t, n) {
  return function() {
    var r = this.__on, i, a = Mz(t);
    if (r) {
      for (var s = 0, u = r.length; s < u; ++s)
        if ((i = r[s]).type === e.type && i.name === e.name) {
          this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = a, i.options = n), i.value = t;
          return;
        }
    }
    this.addEventListener(e.type, a, n), i = { type: e.type, name: e.name, value: t, listener: a, options: n }, r ? r.push(i) : this.__on = [i];
  };
}
function jz(e, t, n) {
  var r = Dz(e + ""), i, a = r.length, s;
  if (arguments.length < 2) {
    var u = this.node().__on;
    if (u) {
      for (var f = 0, d = u.length, h; f < d; ++f)
        for (i = 0, h = u[f]; i < a; ++i)
          if ((s = r[i]).type === h.type && s.name === h.name)
            return h.value;
    }
    return;
  }
  for (u = t ? zz : Pz, i = 0; i < a; ++i) this.each(u(r[i], t, n));
  return this;
}
function BT(e, t, n) {
  var r = zT(e), i = r.CustomEvent;
  typeof i == "function" ? i = new i(t, n) : (i = r.document.createEvent("Event"), n ? (i.initEvent(t, n.bubbles, n.cancelable), i.detail = n.detail) : i.initEvent(t, !1, !1)), e.dispatchEvent(i);
}
function Iz(e, t) {
  return function() {
    return BT(this, e, t);
  };
}
function Lz(e, t) {
  return function() {
    return BT(this, e, t.apply(this, arguments));
  };
}
function Fz(e, t) {
  return this.each((typeof t == "function" ? Lz : Iz)(e, t));
}
function* Bz() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], i = 0, a = r.length, s; i < a; ++i)
      (s = r[i]) && (yield s);
}
var $T = [null];
function nr(e, t) {
  this._groups = e, this._parents = t;
}
function Rc() {
  return new nr([[document.documentElement]], $T);
}
function $z() {
  return this;
}
nr.prototype = Rc.prototype = {
  constructor: nr,
  select: h6,
  selectAll: y6,
  selectChild: w6,
  selectChildren: C6,
  filter: k6,
  data: M6,
  enter: A6,
  exit: P6,
  join: z6,
  merge: j6,
  selection: $z,
  order: I6,
  sort: L6,
  call: B6,
  nodes: $6,
  node: H6,
  size: V6,
  empty: U6,
  each: q6,
  attr: Q6,
  style: nz,
  property: az,
  classed: cz,
  text: pz,
  html: vz,
  raise: xz,
  lower: Sz,
  append: _z,
  insert: Cz,
  remove: Az,
  clone: Oz,
  datum: Nz,
  on: jz,
  dispatch: Fz,
  [Symbol.iterator]: Bz
};
function Wn(e) {
  return typeof e == "string" ? new nr([[document.querySelector(e)]], [document.documentElement]) : new nr([[e]], $T);
}
function Hz(e) {
  let t;
  for (; t = e.sourceEvent; ) e = t;
  return e;
}
function Ar(e, t) {
  if (e = Hz(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var r = n.createSVGPoint();
      return r.x = e.clientX, r.y = e.clientY, r = r.matrixTransform(t.getScreenCTM().inverse()), [r.x, r.y];
    }
    if (t.getBoundingClientRect) {
      var i = t.getBoundingClientRect();
      return [e.clientX - i.left - t.clientLeft, e.clientY - i.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
const Vz = { passive: !1 }, rc = { capture: !0, passive: !1 };
function k0(e) {
  e.stopImmediatePropagation();
}
function qs(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function HT(e) {
  var t = e.document.documentElement, n = Wn(e).on("dragstart.drag", qs, rc);
  "onselectstart" in t ? n.on("selectstart.drag", qs, rc) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function VT(e, t) {
  var n = e.document.documentElement, r = Wn(e).on("dragstart.drag", null);
  t && (r.on("click.drag", qs, rc), setTimeout(function() {
    r.on("click.drag", null);
  }, 0)), "onselectstart" in n ? r.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
}
const xd = (e) => () => e;
function $y(e, {
  sourceEvent: t,
  subject: n,
  target: r,
  identifier: i,
  active: a,
  x: s,
  y: u,
  dx: f,
  dy: d,
  dispatch: h
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    subject: { value: n, enumerable: !0, configurable: !0 },
    target: { value: r, enumerable: !0, configurable: !0 },
    identifier: { value: i, enumerable: !0, configurable: !0 },
    active: { value: a, enumerable: !0, configurable: !0 },
    x: { value: s, enumerable: !0, configurable: !0 },
    y: { value: u, enumerable: !0, configurable: !0 },
    dx: { value: f, enumerable: !0, configurable: !0 },
    dy: { value: d, enumerable: !0, configurable: !0 },
    _: { value: h }
  });
}
$y.prototype.on = function() {
  var e = this._.on.apply(this._, arguments);
  return e === this._ ? this : e;
};
function Uz(e) {
  return !e.ctrlKey && !e.button;
}
function qz() {
  return this.parentNode;
}
function Yz(e, t) {
  return t ?? { x: e.x, y: e.y };
}
function Gz() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function UT() {
  var e = Uz, t = qz, n = Yz, r = Gz, i = {}, a = rp("start", "drag", "end"), s = 0, u, f, d, h, p = 0;
  function g(R) {
    R.on("mousedown.drag", y).filter(r).on("touchstart.drag", E).on("touchmove.drag", S, Vz).on("touchend.drag touchcancel.drag", A).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function y(R, N) {
    if (!(h || !e.call(this, R, N))) {
      var D = k(this, t.call(this, R, N), R, N, "mouse");
      D && (Wn(R.view).on("mousemove.drag", b, rc).on("mouseup.drag", x, rc), HT(R.view), k0(R), d = !1, u = R.clientX, f = R.clientY, D("start", R));
    }
  }
  function b(R) {
    if (qs(R), !d) {
      var N = R.clientX - u, D = R.clientY - f;
      d = N * N + D * D > p;
    }
    i.mouse("drag", R);
  }
  function x(R) {
    Wn(R.view).on("mousemove.drag mouseup.drag", null), VT(R.view, d), qs(R), i.mouse("end", R);
  }
  function E(R, N) {
    if (e.call(this, R, N)) {
      var D = R.changedTouches, P = t.call(this, R, N), F = D.length, V, T;
      for (V = 0; V < F; ++V)
        (T = k(this, P, R, N, D[V].identifier, D[V])) && (k0(R), T("start", R, D[V]));
    }
  }
  function S(R) {
    var N = R.changedTouches, D = N.length, P, F;
    for (P = 0; P < D; ++P)
      (F = i[N[P].identifier]) && (qs(R), F("drag", R, N[P]));
  }
  function A(R) {
    var N = R.changedTouches, D = N.length, P, F;
    for (h && clearTimeout(h), h = setTimeout(function() {
      h = null;
    }, 500), P = 0; P < D; ++P)
      (F = i[N[P].identifier]) && (k0(R), F("end", R, N[P]));
  }
  function k(R, N, D, P, F, V) {
    var T = a.copy(), $ = Ar(V || D, N), H, G, j;
    if ((j = n.call(R, new $y("beforestart", {
      sourceEvent: D,
      target: g,
      identifier: F,
      active: s,
      x: $[0],
      y: $[1],
      dx: 0,
      dy: 0,
      dispatch: T
    }), P)) != null)
      return H = j.x - $[0] || 0, G = j.y - $[1] || 0, function U(z, B, q) {
        var Y = $, O;
        switch (z) {
          case "start":
            i[F] = U, O = s++;
            break;
          case "end":
            delete i[F], --s;
          // falls through
          case "drag":
            $ = Ar(q || B, N), O = s;
            break;
        }
        T.call(
          z,
          R,
          new $y(z, {
            sourceEvent: B,
            subject: j,
            target: g,
            identifier: F,
            active: O,
            x: $[0] + H,
            y: $[1] + G,
            dx: $[0] - Y[0],
            dy: $[1] - Y[1],
            dispatch: T
          }),
          P
        );
      };
  }
  return g.filter = function(R) {
    return arguments.length ? (e = typeof R == "function" ? R : xd(!!R), g) : e;
  }, g.container = function(R) {
    return arguments.length ? (t = typeof R == "function" ? R : xd(R), g) : t;
  }, g.subject = function(R) {
    return arguments.length ? (n = typeof R == "function" ? R : xd(R), g) : n;
  }, g.touchable = function(R) {
    return arguments.length ? (r = typeof R == "function" ? R : xd(!!R), g) : r;
  }, g.on = function() {
    var R = a.on.apply(a, arguments);
    return R === a ? g : R;
  }, g.clickDistance = function(R) {
    return arguments.length ? (p = (R = +R) * R, g) : Math.sqrt(p);
  }, g;
}
function hb(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function qT(e, t) {
  var n = Object.create(e.prototype);
  for (var r in t) n[r] = t[r];
  return n;
}
function Oc() {
}
var ic = 0.7, vh = 1 / ic, Ys = "\\s*([+-]?\\d+)\\s*", oc = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", ni = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", Xz = /^#([0-9a-f]{3,8})$/, Wz = new RegExp(`^rgb\\(${Ys},${Ys},${Ys}\\)$`), Kz = new RegExp(`^rgb\\(${ni},${ni},${ni}\\)$`), Zz = new RegExp(`^rgba\\(${Ys},${Ys},${Ys},${oc}\\)$`), Qz = new RegExp(`^rgba\\(${ni},${ni},${ni},${oc}\\)$`), Jz = new RegExp(`^hsl\\(${oc},${ni},${ni}\\)$`), ej = new RegExp(`^hsla\\(${oc},${ni},${ni},${oc}\\)$`), Z_ = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
hb(Oc, ac, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Q_,
  // Deprecated! Use color.formatHex.
  formatHex: Q_,
  formatHex8: tj,
  formatHsl: nj,
  formatRgb: J_,
  toString: J_
});
function Q_() {
  return this.rgb().formatHex();
}
function tj() {
  return this.rgb().formatHex8();
}
function nj() {
  return YT(this).formatHsl();
}
function J_() {
  return this.rgb().formatRgb();
}
function ac(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = Xz.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? eE(t) : n === 3 ? new Pn(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? wd(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? wd(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = Wz.exec(e)) ? new Pn(t[1], t[2], t[3], 1) : (t = Kz.exec(e)) ? new Pn(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = Zz.exec(e)) ? wd(t[1], t[2], t[3], t[4]) : (t = Qz.exec(e)) ? wd(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = Jz.exec(e)) ? rE(t[1], t[2] / 100, t[3] / 100, 1) : (t = ej.exec(e)) ? rE(t[1], t[2] / 100, t[3] / 100, t[4]) : Z_.hasOwnProperty(e) ? eE(Z_[e]) : e === "transparent" ? new Pn(NaN, NaN, NaN, 0) : null;
}
function eE(e) {
  return new Pn(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function wd(e, t, n, r) {
  return r <= 0 && (e = t = n = NaN), new Pn(e, t, n, r);
}
function rj(e) {
  return e instanceof Oc || (e = ac(e)), e ? (e = e.rgb(), new Pn(e.r, e.g, e.b, e.opacity)) : new Pn();
}
function Hy(e, t, n, r) {
  return arguments.length === 1 ? rj(e) : new Pn(e, t, n, r ?? 1);
}
function Pn(e, t, n, r) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;
}
hb(Pn, Hy, qT(Oc, {
  brighter(e) {
    return e = e == null ? vh : Math.pow(vh, e), new Pn(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? ic : Math.pow(ic, e), new Pn(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Pn(Ca(this.r), Ca(this.g), Ca(this.b), bh(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: tE,
  // Deprecated! Use color.formatHex.
  formatHex: tE,
  formatHex8: ij,
  formatRgb: nE,
  toString: nE
}));
function tE() {
  return `#${xa(this.r)}${xa(this.g)}${xa(this.b)}`;
}
function ij() {
  return `#${xa(this.r)}${xa(this.g)}${xa(this.b)}${xa((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function nE() {
  const e = bh(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${Ca(this.r)}, ${Ca(this.g)}, ${Ca(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function bh(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function Ca(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function xa(e) {
  return e = Ca(e), (e < 16 ? "0" : "") + e.toString(16);
}
function rE(e, t, n, r) {
  return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new Rr(e, t, n, r);
}
function YT(e) {
  if (e instanceof Rr) return new Rr(e.h, e.s, e.l, e.opacity);
  if (e instanceof Oc || (e = ac(e)), !e) return new Rr();
  if (e instanceof Rr) return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, r = e.b / 255, i = Math.min(t, n, r), a = Math.max(t, n, r), s = NaN, u = a - i, f = (a + i) / 2;
  return u ? (t === a ? s = (n - r) / u + (n < r) * 6 : n === a ? s = (r - t) / u + 2 : s = (t - n) / u + 4, u /= f < 0.5 ? a + i : 2 - a - i, s *= 60) : u = f > 0 && f < 1 ? 0 : s, new Rr(s, u, f, e.opacity);
}
function oj(e, t, n, r) {
  return arguments.length === 1 ? YT(e) : new Rr(e, t, n, r ?? 1);
}
function Rr(e, t, n, r) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
}
hb(Rr, oj, qT(Oc, {
  brighter(e) {
    return e = e == null ? vh : Math.pow(vh, e), new Rr(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? ic : Math.pow(ic, e), new Rr(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * t, i = 2 * n - r;
    return new Pn(
      A0(e >= 240 ? e - 240 : e + 120, i, r),
      A0(e, i, r),
      A0(e < 120 ? e + 240 : e - 120, i, r),
      this.opacity
    );
  },
  clamp() {
    return new Rr(iE(this.h), Sd(this.s), Sd(this.l), bh(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = bh(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${iE(this.h)}, ${Sd(this.s) * 100}%, ${Sd(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function iE(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function Sd(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function A0(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const GT = (e) => () => e;
function aj(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function sj(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(r) {
    return Math.pow(e + r * t, n);
  };
}
function lj(e) {
  return (e = +e) == 1 ? XT : function(t, n) {
    return n - t ? sj(t, n, e) : GT(isNaN(t) ? n : t);
  };
}
function XT(e, t) {
  var n = t - e;
  return n ? aj(e, n) : GT(isNaN(e) ? t : e);
}
const oE = function e(t) {
  var n = lj(t);
  function r(i, a) {
    var s = n((i = Hy(i)).r, (a = Hy(a)).r), u = n(i.g, a.g), f = n(i.b, a.b), d = XT(i.opacity, a.opacity);
    return function(h) {
      return i.r = s(h), i.g = u(h), i.b = f(h), i.opacity = d(h), i + "";
    };
  }
  return r.gamma = e, r;
}(1);
function Do(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
var Vy = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, T0 = new RegExp(Vy.source, "g");
function uj(e) {
  return function() {
    return e;
  };
}
function cj(e) {
  return function(t) {
    return e(t) + "";
  };
}
function fj(e, t) {
  var n = Vy.lastIndex = T0.lastIndex = 0, r, i, a, s = -1, u = [], f = [];
  for (e = e + "", t = t + ""; (r = Vy.exec(e)) && (i = T0.exec(t)); )
    (a = i.index) > n && (a = t.slice(n, a), u[s] ? u[s] += a : u[++s] = a), (r = r[0]) === (i = i[0]) ? u[s] ? u[s] += i : u[++s] = i : (u[++s] = null, f.push({ i: s, x: Do(r, i) })), n = T0.lastIndex;
  return n < t.length && (a = t.slice(n), u[s] ? u[s] += a : u[++s] = a), u.length < 2 ? f[0] ? cj(f[0].x) : uj(t) : (t = f.length, function(d) {
    for (var h = 0, p; h < t; ++h) u[(p = f[h]).i] = p.x(d);
    return u.join("");
  });
}
var aE = 180 / Math.PI, Uy = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function WT(e, t, n, r, i, a) {
  var s, u, f;
  return (s = Math.sqrt(e * e + t * t)) && (e /= s, t /= s), (f = e * n + t * r) && (n -= e * f, r -= t * f), (u = Math.sqrt(n * n + r * r)) && (n /= u, r /= u, f /= u), e * r < t * n && (e = -e, t = -t, f = -f, s = -s), {
    translateX: i,
    translateY: a,
    rotate: Math.atan2(t, e) * aE,
    skewX: Math.atan(f) * aE,
    scaleX: s,
    scaleY: u
  };
}
var _d;
function dj(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? Uy : WT(t.a, t.b, t.c, t.d, t.e, t.f);
}
function hj(e) {
  return e == null || (_d || (_d = document.createElementNS("http://www.w3.org/2000/svg", "g")), _d.setAttribute("transform", e), !(e = _d.transform.baseVal.consolidate())) ? Uy : (e = e.matrix, WT(e.a, e.b, e.c, e.d, e.e, e.f));
}
function KT(e, t, n, r) {
  function i(d) {
    return d.length ? d.pop() + " " : "";
  }
  function a(d, h, p, g, y, b) {
    if (d !== p || h !== g) {
      var x = y.push("translate(", null, t, null, n);
      b.push({ i: x - 4, x: Do(d, p) }, { i: x - 2, x: Do(h, g) });
    } else (p || g) && y.push("translate(" + p + t + g + n);
  }
  function s(d, h, p, g) {
    d !== h ? (d - h > 180 ? h += 360 : h - d > 180 && (d += 360), g.push({ i: p.push(i(p) + "rotate(", null, r) - 2, x: Do(d, h) })) : h && p.push(i(p) + "rotate(" + h + r);
  }
  function u(d, h, p, g) {
    d !== h ? g.push({ i: p.push(i(p) + "skewX(", null, r) - 2, x: Do(d, h) }) : h && p.push(i(p) + "skewX(" + h + r);
  }
  function f(d, h, p, g, y, b) {
    if (d !== p || h !== g) {
      var x = y.push(i(y) + "scale(", null, ",", null, ")");
      b.push({ i: x - 4, x: Do(d, p) }, { i: x - 2, x: Do(h, g) });
    } else (p !== 1 || g !== 1) && y.push(i(y) + "scale(" + p + "," + g + ")");
  }
  return function(d, h) {
    var p = [], g = [];
    return d = e(d), h = e(h), a(d.translateX, d.translateY, h.translateX, h.translateY, p, g), s(d.rotate, h.rotate, p, g), u(d.skewX, h.skewX, p, g), f(d.scaleX, d.scaleY, h.scaleX, h.scaleY, p, g), d = h = null, function(y) {
      for (var b = -1, x = g.length, E; ++b < x; ) p[(E = g[b]).i] = E.x(y);
      return p.join("");
    };
  };
}
var pj = KT(dj, "px, ", "px)", "deg)"), mj = KT(hj, ", ", ")", ")"), gj = 1e-12;
function sE(e) {
  return ((e = Math.exp(e)) + 1 / e) / 2;
}
function yj(e) {
  return ((e = Math.exp(e)) - 1 / e) / 2;
}
function vj(e) {
  return ((e = Math.exp(2 * e)) - 1) / (e + 1);
}
const bj = function e(t, n, r) {
  function i(a, s) {
    var u = a[0], f = a[1], d = a[2], h = s[0], p = s[1], g = s[2], y = h - u, b = p - f, x = y * y + b * b, E, S;
    if (x < gj)
      S = Math.log(g / d) / t, E = function(P) {
        return [
          u + P * y,
          f + P * b,
          d * Math.exp(t * P * S)
        ];
      };
    else {
      var A = Math.sqrt(x), k = (g * g - d * d + r * x) / (2 * d * n * A), R = (g * g - d * d - r * x) / (2 * g * n * A), N = Math.log(Math.sqrt(k * k + 1) - k), D = Math.log(Math.sqrt(R * R + 1) - R);
      S = (D - N) / t, E = function(P) {
        var F = P * S, V = sE(N), T = d / (n * A) * (V * vj(t * F + N) - yj(N));
        return [
          u + T * y,
          f + T * b,
          d * V / sE(t * F + N)
        ];
      };
    }
    return E.duration = S * 1e3 * t / Math.SQRT2, E;
  }
  return i.rho = function(a) {
    var s = Math.max(1e-3, +a), u = s * s, f = u * u;
    return e(s, u, f);
  }, i;
}(Math.SQRT2, 2, 4);
var tl = 0, Hu = 0, Nu = 0, ZT = 1e3, xh, Vu, wh = 0, Ta = 0, op = 0, sc = typeof performance == "object" && performance.now ? performance : Date, QT = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function pb() {
  return Ta || (QT(xj), Ta = sc.now() + op);
}
function xj() {
  Ta = 0;
}
function Sh() {
  this._call = this._time = this._next = null;
}
Sh.prototype = JT.prototype = {
  constructor: Sh,
  restart: function(e, t, n) {
    if (typeof e != "function") throw new TypeError("callback is not a function");
    n = (n == null ? pb() : +n) + (t == null ? 0 : +t), !this._next && Vu !== this && (Vu ? Vu._next = this : xh = this, Vu = this), this._call = e, this._time = n, qy();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, qy());
  }
};
function JT(e, t, n) {
  var r = new Sh();
  return r.restart(e, t, n), r;
}
function wj() {
  pb(), ++tl;
  for (var e = xh, t; e; )
    (t = Ta - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --tl;
}
function lE() {
  Ta = (wh = sc.now()) + op, tl = Hu = 0;
  try {
    wj();
  } finally {
    tl = 0, _j(), Ta = 0;
  }
}
function Sj() {
  var e = sc.now(), t = e - wh;
  t > ZT && (op -= t, wh = e);
}
function _j() {
  for (var e, t = xh, n, r = 1 / 0; t; )
    t._call ? (r > t._time && (r = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : xh = n);
  Vu = e, qy(r);
}
function qy(e) {
  if (!tl) {
    Hu && (Hu = clearTimeout(Hu));
    var t = e - Ta;
    t > 24 ? (e < 1 / 0 && (Hu = setTimeout(lE, e - sc.now() - op)), Nu && (Nu = clearInterval(Nu))) : (Nu || (wh = sc.now(), Nu = setInterval(Sj, ZT)), tl = 1, QT(lE));
  }
}
function uE(e, t, n) {
  var r = new Sh();
  return t = t == null ? 0 : +t, r.restart((i) => {
    r.stop(), e(i + t);
  }, t, n), r;
}
var Ej = rp("start", "end", "cancel", "interrupt"), Cj = [], eR = 0, cE = 1, Yy = 2, Zd = 3, fE = 4, Gy = 5, Qd = 6;
function ap(e, t, n, r, i, a) {
  var s = e.__transition;
  if (!s) e.__transition = {};
  else if (n in s) return;
  kj(e, n, {
    name: t,
    index: r,
    // For context during callback.
    group: i,
    // For context during callback.
    on: Ej,
    tween: Cj,
    time: a.time,
    delay: a.delay,
    duration: a.duration,
    ease: a.ease,
    timer: null,
    state: eR
  });
}
function mb(e, t) {
  var n = zr(e, t);
  if (n.state > eR) throw new Error("too late; already scheduled");
  return n;
}
function si(e, t) {
  var n = zr(e, t);
  if (n.state > Zd) throw new Error("too late; already running");
  return n;
}
function zr(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t])) throw new Error("transition not found");
  return n;
}
function kj(e, t, n) {
  var r = e.__transition, i;
  r[t] = n, n.timer = JT(a, 0, n.time);
  function a(d) {
    n.state = cE, n.timer.restart(s, n.delay, n.time), n.delay <= d && s(d - n.delay);
  }
  function s(d) {
    var h, p, g, y;
    if (n.state !== cE) return f();
    for (h in r)
      if (y = r[h], y.name === n.name) {
        if (y.state === Zd) return uE(s);
        y.state === fE ? (y.state = Qd, y.timer.stop(), y.on.call("interrupt", e, e.__data__, y.index, y.group), delete r[h]) : +h < t && (y.state = Qd, y.timer.stop(), y.on.call("cancel", e, e.__data__, y.index, y.group), delete r[h]);
      }
    if (uE(function() {
      n.state === Zd && (n.state = fE, n.timer.restart(u, n.delay, n.time), u(d));
    }), n.state = Yy, n.on.call("start", e, e.__data__, n.index, n.group), n.state === Yy) {
      for (n.state = Zd, i = new Array(g = n.tween.length), h = 0, p = -1; h < g; ++h)
        (y = n.tween[h].value.call(e, e.__data__, n.index, n.group)) && (i[++p] = y);
      i.length = p + 1;
    }
  }
  function u(d) {
    for (var h = d < n.duration ? n.ease.call(null, d / n.duration) : (n.timer.restart(f), n.state = Gy, 1), p = -1, g = i.length; ++p < g; )
      i[p].call(e, h);
    n.state === Gy && (n.on.call("end", e, e.__data__, n.index, n.group), f());
  }
  function f() {
    n.state = Qd, n.timer.stop(), delete r[t];
    for (var d in r) return;
    delete e.__transition;
  }
}
function Jd(e, t) {
  var n = e.__transition, r, i, a = !0, s;
  if (n) {
    t = t == null ? null : t + "";
    for (s in n) {
      if ((r = n[s]).name !== t) {
        a = !1;
        continue;
      }
      i = r.state > Yy && r.state < Gy, r.state = Qd, r.timer.stop(), r.on.call(i ? "interrupt" : "cancel", e, e.__data__, r.index, r.group), delete n[s];
    }
    a && delete e.__transition;
  }
}
function Aj(e) {
  return this.each(function() {
    Jd(this, e);
  });
}
function Tj(e, t) {
  var n, r;
  return function() {
    var i = si(this, e), a = i.tween;
    if (a !== n) {
      r = n = a;
      for (var s = 0, u = r.length; s < u; ++s)
        if (r[s].name === t) {
          r = r.slice(), r.splice(s, 1);
          break;
        }
    }
    i.tween = r;
  };
}
function Rj(e, t, n) {
  var r, i;
  if (typeof n != "function") throw new Error();
  return function() {
    var a = si(this, e), s = a.tween;
    if (s !== r) {
      i = (r = s).slice();
      for (var u = { name: t, value: n }, f = 0, d = i.length; f < d; ++f)
        if (i[f].name === t) {
          i[f] = u;
          break;
        }
      f === d && i.push(u);
    }
    a.tween = i;
  };
}
function Oj(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var r = zr(this.node(), n).tween, i = 0, a = r.length, s; i < a; ++i)
      if ((s = r[i]).name === e)
        return s.value;
    return null;
  }
  return this.each((t == null ? Tj : Rj)(n, e, t));
}
function gb(e, t, n) {
  var r = e._id;
  return e.each(function() {
    var i = si(this, r);
    (i.value || (i.value = {}))[t] = n.apply(this, arguments);
  }), function(i) {
    return zr(i, r).value[t];
  };
}
function tR(e, t) {
  var n;
  return (typeof t == "number" ? Do : t instanceof ac ? oE : (n = ac(t)) ? (t = n, oE) : fj)(e, t);
}
function Nj(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function Mj(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function Dj(e, t, n) {
  var r, i = n + "", a;
  return function() {
    var s = this.getAttribute(e);
    return s === i ? null : s === r ? a : a = t(r = s, n);
  };
}
function Pj(e, t, n) {
  var r, i = n + "", a;
  return function() {
    var s = this.getAttributeNS(e.space, e.local);
    return s === i ? null : s === r ? a : a = t(r = s, n);
  };
}
function zj(e, t, n) {
  var r, i, a;
  return function() {
    var s, u = n(this), f;
    return u == null ? void this.removeAttribute(e) : (s = this.getAttribute(e), f = u + "", s === f ? null : s === r && f === i ? a : (i = f, a = t(r = s, u)));
  };
}
function jj(e, t, n) {
  var r, i, a;
  return function() {
    var s, u = n(this), f;
    return u == null ? void this.removeAttributeNS(e.space, e.local) : (s = this.getAttributeNS(e.space, e.local), f = u + "", s === f ? null : s === r && f === i ? a : (i = f, a = t(r = s, u)));
  };
}
function Ij(e, t) {
  var n = ip(e), r = n === "transform" ? mj : tR;
  return this.attrTween(e, typeof t == "function" ? (n.local ? jj : zj)(n, r, gb(this, "attr." + e, t)) : t == null ? (n.local ? Mj : Nj)(n) : (n.local ? Pj : Dj)(n, r, t));
}
function Lj(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function Fj(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function Bj(e, t) {
  var n, r;
  function i() {
    var a = t.apply(this, arguments);
    return a !== r && (n = (r = a) && Fj(e, a)), n;
  }
  return i._value = t, i;
}
function $j(e, t) {
  var n, r;
  function i() {
    var a = t.apply(this, arguments);
    return a !== r && (n = (r = a) && Lj(e, a)), n;
  }
  return i._value = t, i;
}
function Hj(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (t == null) return this.tween(n, null);
  if (typeof t != "function") throw new Error();
  var r = ip(e);
  return this.tween(n, (r.local ? Bj : $j)(r, t));
}
function Vj(e, t) {
  return function() {
    mb(this, e).delay = +t.apply(this, arguments);
  };
}
function Uj(e, t) {
  return t = +t, function() {
    mb(this, e).delay = t;
  };
}
function qj(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? Vj : Uj)(t, e)) : zr(this.node(), t).delay;
}
function Yj(e, t) {
  return function() {
    si(this, e).duration = +t.apply(this, arguments);
  };
}
function Gj(e, t) {
  return t = +t, function() {
    si(this, e).duration = t;
  };
}
function Xj(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? Yj : Gj)(t, e)) : zr(this.node(), t).duration;
}
function Wj(e, t) {
  if (typeof t != "function") throw new Error();
  return function() {
    si(this, e).ease = t;
  };
}
function Kj(e) {
  var t = this._id;
  return arguments.length ? this.each(Wj(t, e)) : zr(this.node(), t).ease;
}
function Zj(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function") throw new Error();
    si(this, e).ease = n;
  };
}
function Qj(e) {
  if (typeof e != "function") throw new Error();
  return this.each(Zj(this._id, e));
}
function Jj(e) {
  typeof e != "function" && (e = MT(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var a = t[i], s = a.length, u = r[i] = [], f, d = 0; d < s; ++d)
      (f = a[d]) && e.call(f, f.__data__, d, a) && u.push(f);
  return new $i(r, this._parents, this._name, this._id);
}
function eI(e) {
  if (e._id !== this._id) throw new Error();
  for (var t = this._groups, n = e._groups, r = t.length, i = n.length, a = Math.min(r, i), s = new Array(r), u = 0; u < a; ++u)
    for (var f = t[u], d = n[u], h = f.length, p = s[u] = new Array(h), g, y = 0; y < h; ++y)
      (g = f[y] || d[y]) && (p[y] = g);
  for (; u < r; ++u)
    s[u] = t[u];
  return new $i(s, this._parents, this._name, this._id);
}
function tI(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function nI(e, t, n) {
  var r, i, a = tI(t) ? mb : si;
  return function() {
    var s = a(this, e), u = s.on;
    u !== r && (i = (r = u).copy()).on(t, n), s.on = i;
  };
}
function rI(e, t) {
  var n = this._id;
  return arguments.length < 2 ? zr(this.node(), n).on.on(e) : this.each(nI(n, e, t));
}
function iI(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition) if (+n !== e) return;
    t && t.removeChild(this);
  };
}
function oI() {
  return this.on("end.remove", iI(this._id));
}
function aI(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = fb(e));
  for (var r = this._groups, i = r.length, a = new Array(i), s = 0; s < i; ++s)
    for (var u = r[s], f = u.length, d = a[s] = new Array(f), h, p, g = 0; g < f; ++g)
      (h = u[g]) && (p = e.call(h, h.__data__, g, u)) && ("__data__" in h && (p.__data__ = h.__data__), d[g] = p, ap(d[g], t, n, g, d, zr(h, n)));
  return new $i(a, this._parents, t, n);
}
function sI(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = NT(e));
  for (var r = this._groups, i = r.length, a = [], s = [], u = 0; u < i; ++u)
    for (var f = r[u], d = f.length, h, p = 0; p < d; ++p)
      if (h = f[p]) {
        for (var g = e.call(h, h.__data__, p, f), y, b = zr(h, n), x = 0, E = g.length; x < E; ++x)
          (y = g[x]) && ap(y, t, n, x, g, b);
        a.push(g), s.push(h);
      }
  return new $i(a, s, t, n);
}
var lI = Rc.prototype.constructor;
function uI() {
  return new lI(this._groups, this._parents);
}
function cI(e, t) {
  var n, r, i;
  return function() {
    var a = el(this, e), s = (this.style.removeProperty(e), el(this, e));
    return a === s ? null : a === n && s === r ? i : i = t(n = a, r = s);
  };
}
function nR(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function fI(e, t, n) {
  var r, i = n + "", a;
  return function() {
    var s = el(this, e);
    return s === i ? null : s === r ? a : a = t(r = s, n);
  };
}
function dI(e, t, n) {
  var r, i, a;
  return function() {
    var s = el(this, e), u = n(this), f = u + "";
    return u == null && (f = u = (this.style.removeProperty(e), el(this, e))), s === f ? null : s === r && f === i ? a : (i = f, a = t(r = s, u));
  };
}
function hI(e, t) {
  var n, r, i, a = "style." + t, s = "end." + a, u;
  return function() {
    var f = si(this, e), d = f.on, h = f.value[a] == null ? u || (u = nR(t)) : void 0;
    (d !== n || i !== h) && (r = (n = d).copy()).on(s, i = h), f.on = r;
  };
}
function pI(e, t, n) {
  var r = (e += "") == "transform" ? pj : tR;
  return t == null ? this.styleTween(e, cI(e, r)).on("end.style." + e, nR(e)) : typeof t == "function" ? this.styleTween(e, dI(e, r, gb(this, "style." + e, t))).each(hI(this._id, e)) : this.styleTween(e, fI(e, r, t), n).on("end.style." + e, null);
}
function mI(e, t, n) {
  return function(r) {
    this.style.setProperty(e, t.call(this, r), n);
  };
}
function gI(e, t, n) {
  var r, i;
  function a() {
    var s = t.apply(this, arguments);
    return s !== i && (r = (i = s) && mI(e, s, n)), r;
  }
  return a._value = t, a;
}
function yI(e, t, n) {
  var r = "style." + (e += "");
  if (arguments.length < 2) return (r = this.tween(r)) && r._value;
  if (t == null) return this.tween(r, null);
  if (typeof t != "function") throw new Error();
  return this.tween(r, gI(e, t, n ?? ""));
}
function vI(e) {
  return function() {
    this.textContent = e;
  };
}
function bI(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function xI(e) {
  return this.tween("text", typeof e == "function" ? bI(gb(this, "text", e)) : vI(e == null ? "" : e + ""));
}
function wI(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function SI(e) {
  var t, n;
  function r() {
    var i = e.apply(this, arguments);
    return i !== n && (t = (n = i) && wI(i)), t;
  }
  return r._value = e, r;
}
function _I(e) {
  var t = "text";
  if (arguments.length < 1) return (t = this.tween(t)) && t._value;
  if (e == null) return this.tween(t, null);
  if (typeof e != "function") throw new Error();
  return this.tween(t, SI(e));
}
function EI() {
  for (var e = this._name, t = this._id, n = rR(), r = this._groups, i = r.length, a = 0; a < i; ++a)
    for (var s = r[a], u = s.length, f, d = 0; d < u; ++d)
      if (f = s[d]) {
        var h = zr(f, t);
        ap(f, e, n, d, s, {
          time: h.time + h.delay + h.duration,
          delay: 0,
          duration: h.duration,
          ease: h.ease
        });
      }
  return new $i(r, this._parents, e, n);
}
function CI() {
  var e, t, n = this, r = n._id, i = n.size();
  return new Promise(function(a, s) {
    var u = { value: s }, f = { value: function() {
      --i === 0 && a();
    } };
    n.each(function() {
      var d = si(this, r), h = d.on;
      h !== e && (t = (e = h).copy(), t._.cancel.push(u), t._.interrupt.push(u), t._.end.push(f)), d.on = t;
    }), i === 0 && a();
  });
}
var kI = 0;
function $i(e, t, n, r) {
  this._groups = e, this._parents = t, this._name = n, this._id = r;
}
function rR() {
  return ++kI;
}
var Ni = Rc.prototype;
$i.prototype = {
  constructor: $i,
  select: aI,
  selectAll: sI,
  selectChild: Ni.selectChild,
  selectChildren: Ni.selectChildren,
  filter: Jj,
  merge: eI,
  selection: uI,
  transition: EI,
  call: Ni.call,
  nodes: Ni.nodes,
  node: Ni.node,
  size: Ni.size,
  empty: Ni.empty,
  each: Ni.each,
  on: rI,
  attr: Ij,
  attrTween: Hj,
  style: pI,
  styleTween: yI,
  text: xI,
  textTween: _I,
  remove: oI,
  tween: Oj,
  delay: qj,
  duration: Xj,
  ease: Kj,
  easeVarying: Qj,
  end: CI,
  [Symbol.iterator]: Ni[Symbol.iterator]
};
function AI(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var TI = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: AI
};
function RI(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function OI(e) {
  var t, n;
  e instanceof $i ? (t = e._id, e = e._name) : (t = rR(), (n = TI).time = pb(), e = e == null ? null : e + "");
  for (var r = this._groups, i = r.length, a = 0; a < i; ++a)
    for (var s = r[a], u = s.length, f, d = 0; d < u; ++d)
      (f = s[d]) && ap(f, e, t, d, s, n || RI(f, t));
  return new $i(r, this._parents, e, t);
}
Rc.prototype.interrupt = Aj;
Rc.prototype.transition = OI;
const Ed = (e) => () => e;
function NI(e, {
  sourceEvent: t,
  target: n,
  transform: r,
  dispatch: i
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    transform: { value: r, enumerable: !0, configurable: !0 },
    _: { value: i }
  });
}
function ji(e, t, n) {
  this.k = e, this.x = t, this.y = n;
}
ji.prototype = {
  constructor: ji,
  scale: function(e) {
    return e === 1 ? this : new ji(this.k * e, this.x, this.y);
  },
  translate: function(e, t) {
    return e === 0 & t === 0 ? this : new ji(this.k, this.x + this.k * e, this.y + this.k * t);
  },
  apply: function(e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y];
  },
  applyX: function(e) {
    return e * this.k + this.x;
  },
  applyY: function(e) {
    return e * this.k + this.y;
  },
  invert: function(e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
  },
  invertX: function(e) {
    return (e - this.x) / this.k;
  },
  invertY: function(e) {
    return (e - this.y) / this.k;
  },
  rescaleX: function(e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
  },
  rescaleY: function(e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var sp = new ji(1, 0, 0);
iR.prototype = ji.prototype;
function iR(e) {
  for (; !e.__zoom; ) if (!(e = e.parentNode)) return sp;
  return e.__zoom;
}
function R0(e) {
  e.stopImmediatePropagation();
}
function Mu(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function MI(e) {
  return (!e.ctrlKey || e.type === "wheel") && !e.button;
}
function DI() {
  var e = this;
  return e instanceof SVGElement ? (e = e.ownerSVGElement || e, e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]]) : [[0, 0], [e.clientWidth, e.clientHeight]];
}
function dE() {
  return this.__zoom || sp;
}
function PI(e) {
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * (e.ctrlKey ? 10 : 1);
}
function zI() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function jI(e, t, n) {
  var r = e.invertX(t[0][0]) - n[0][0], i = e.invertX(t[1][0]) - n[1][0], a = e.invertY(t[0][1]) - n[0][1], s = e.invertY(t[1][1]) - n[1][1];
  return e.translate(
    i > r ? (r + i) / 2 : Math.min(0, r) || Math.max(0, i),
    s > a ? (a + s) / 2 : Math.min(0, a) || Math.max(0, s)
  );
}
function oR() {
  var e = MI, t = DI, n = jI, r = PI, i = zI, a = [0, 1 / 0], s = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], u = 250, f = bj, d = rp("start", "zoom", "end"), h, p, g, y = 500, b = 150, x = 0, E = 10;
  function S(j) {
    j.property("__zoom", dE).on("wheel.zoom", F, { passive: !1 }).on("mousedown.zoom", V).on("dblclick.zoom", T).filter(i).on("touchstart.zoom", $).on("touchmove.zoom", H).on("touchend.zoom touchcancel.zoom", G).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  S.transform = function(j, U, z, B) {
    var q = j.selection ? j.selection() : j;
    q.property("__zoom", dE), j !== q ? N(j, U, z, B) : q.interrupt().each(function() {
      D(this, arguments).event(B).start().zoom(null, typeof U == "function" ? U.apply(this, arguments) : U).end();
    });
  }, S.scaleBy = function(j, U, z, B) {
    S.scaleTo(j, function() {
      var q = this.__zoom.k, Y = typeof U == "function" ? U.apply(this, arguments) : U;
      return q * Y;
    }, z, B);
  }, S.scaleTo = function(j, U, z, B) {
    S.transform(j, function() {
      var q = t.apply(this, arguments), Y = this.__zoom, O = z == null ? R(q) : typeof z == "function" ? z.apply(this, arguments) : z, W = Y.invert(O), Z = typeof U == "function" ? U.apply(this, arguments) : U;
      return n(k(A(Y, Z), O, W), q, s);
    }, z, B);
  }, S.translateBy = function(j, U, z, B) {
    S.transform(j, function() {
      return n(this.__zoom.translate(
        typeof U == "function" ? U.apply(this, arguments) : U,
        typeof z == "function" ? z.apply(this, arguments) : z
      ), t.apply(this, arguments), s);
    }, null, B);
  }, S.translateTo = function(j, U, z, B, q) {
    S.transform(j, function() {
      var Y = t.apply(this, arguments), O = this.__zoom, W = B == null ? R(Y) : typeof B == "function" ? B.apply(this, arguments) : B;
      return n(sp.translate(W[0], W[1]).scale(O.k).translate(
        typeof U == "function" ? -U.apply(this, arguments) : -U,
        typeof z == "function" ? -z.apply(this, arguments) : -z
      ), Y, s);
    }, B, q);
  };
  function A(j, U) {
    return U = Math.max(a[0], Math.min(a[1], U)), U === j.k ? j : new ji(U, j.x, j.y);
  }
  function k(j, U, z) {
    var B = U[0] - z[0] * j.k, q = U[1] - z[1] * j.k;
    return B === j.x && q === j.y ? j : new ji(j.k, B, q);
  }
  function R(j) {
    return [(+j[0][0] + +j[1][0]) / 2, (+j[0][1] + +j[1][1]) / 2];
  }
  function N(j, U, z, B) {
    j.on("start.zoom", function() {
      D(this, arguments).event(B).start();
    }).on("interrupt.zoom end.zoom", function() {
      D(this, arguments).event(B).end();
    }).tween("zoom", function() {
      var q = this, Y = arguments, O = D(q, Y).event(B), W = t.apply(q, Y), Z = z == null ? R(W) : typeof z == "function" ? z.apply(q, Y) : z, I = Math.max(W[1][0] - W[0][0], W[1][1] - W[0][1]), ie = q.__zoom, fe = typeof U == "function" ? U.apply(q, Y) : U, re = f(ie.invert(Z).concat(I / ie.k), fe.invert(Z).concat(I / fe.k));
      return function(le) {
        if (le === 1) le = fe;
        else {
          var he = re(le), ye = I / he[2];
          le = new ji(ye, Z[0] - he[0] * ye, Z[1] - he[1] * ye);
        }
        O.zoom(null, le);
      };
    });
  }
  function D(j, U, z) {
    return !z && j.__zooming || new P(j, U);
  }
  function P(j, U) {
    this.that = j, this.args = U, this.active = 0, this.sourceEvent = null, this.extent = t.apply(j, U), this.taps = 0;
  }
  P.prototype = {
    event: function(j) {
      return j && (this.sourceEvent = j), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(j, U) {
      return this.mouse && j !== "mouse" && (this.mouse[1] = U.invert(this.mouse[0])), this.touch0 && j !== "touch" && (this.touch0[1] = U.invert(this.touch0[0])), this.touch1 && j !== "touch" && (this.touch1[1] = U.invert(this.touch1[0])), this.that.__zoom = U, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(j) {
      var U = Wn(this.that).datum();
      d.call(
        j,
        this.that,
        new NI(j, {
          sourceEvent: this.sourceEvent,
          target: S,
          transform: this.that.__zoom,
          dispatch: d
        }),
        U
      );
    }
  };
  function F(j, ...U) {
    if (!e.apply(this, arguments)) return;
    var z = D(this, U).event(j), B = this.__zoom, q = Math.max(a[0], Math.min(a[1], B.k * Math.pow(2, r.apply(this, arguments)))), Y = Ar(j);
    if (z.wheel)
      (z.mouse[0][0] !== Y[0] || z.mouse[0][1] !== Y[1]) && (z.mouse[1] = B.invert(z.mouse[0] = Y)), clearTimeout(z.wheel);
    else {
      if (B.k === q) return;
      z.mouse = [Y, B.invert(Y)], Jd(this), z.start();
    }
    Mu(j), z.wheel = setTimeout(O, b), z.zoom("mouse", n(k(A(B, q), z.mouse[0], z.mouse[1]), z.extent, s));
    function O() {
      z.wheel = null, z.end();
    }
  }
  function V(j, ...U) {
    if (g || !e.apply(this, arguments)) return;
    var z = j.currentTarget, B = D(this, U, !0).event(j), q = Wn(j.view).on("mousemove.zoom", Z, !0).on("mouseup.zoom", I, !0), Y = Ar(j, z), O = j.clientX, W = j.clientY;
    HT(j.view), R0(j), B.mouse = [Y, this.__zoom.invert(Y)], Jd(this), B.start();
    function Z(ie) {
      if (Mu(ie), !B.moved) {
        var fe = ie.clientX - O, re = ie.clientY - W;
        B.moved = fe * fe + re * re > x;
      }
      B.event(ie).zoom("mouse", n(k(B.that.__zoom, B.mouse[0] = Ar(ie, z), B.mouse[1]), B.extent, s));
    }
    function I(ie) {
      q.on("mousemove.zoom mouseup.zoom", null), VT(ie.view, B.moved), Mu(ie), B.event(ie).end();
    }
  }
  function T(j, ...U) {
    if (e.apply(this, arguments)) {
      var z = this.__zoom, B = Ar(j.changedTouches ? j.changedTouches[0] : j, this), q = z.invert(B), Y = z.k * (j.shiftKey ? 0.5 : 2), O = n(k(A(z, Y), B, q), t.apply(this, U), s);
      Mu(j), u > 0 ? Wn(this).transition().duration(u).call(N, O, B, j) : Wn(this).call(S.transform, O, B, j);
    }
  }
  function $(j, ...U) {
    if (e.apply(this, arguments)) {
      var z = j.touches, B = z.length, q = D(this, U, j.changedTouches.length === B).event(j), Y, O, W, Z;
      for (R0(j), O = 0; O < B; ++O)
        W = z[O], Z = Ar(W, this), Z = [Z, this.__zoom.invert(Z), W.identifier], q.touch0 ? !q.touch1 && q.touch0[2] !== Z[2] && (q.touch1 = Z, q.taps = 0) : (q.touch0 = Z, Y = !0, q.taps = 1 + !!h);
      h && (h = clearTimeout(h)), Y && (q.taps < 2 && (p = Z[0], h = setTimeout(function() {
        h = null;
      }, y)), Jd(this), q.start());
    }
  }
  function H(j, ...U) {
    if (this.__zooming) {
      var z = D(this, U).event(j), B = j.changedTouches, q = B.length, Y, O, W, Z;
      for (Mu(j), Y = 0; Y < q; ++Y)
        O = B[Y], W = Ar(O, this), z.touch0 && z.touch0[2] === O.identifier ? z.touch0[0] = W : z.touch1 && z.touch1[2] === O.identifier && (z.touch1[0] = W);
      if (O = z.that.__zoom, z.touch1) {
        var I = z.touch0[0], ie = z.touch0[1], fe = z.touch1[0], re = z.touch1[1], le = (le = fe[0] - I[0]) * le + (le = fe[1] - I[1]) * le, he = (he = re[0] - ie[0]) * he + (he = re[1] - ie[1]) * he;
        O = A(O, Math.sqrt(le / he)), W = [(I[0] + fe[0]) / 2, (I[1] + fe[1]) / 2], Z = [(ie[0] + re[0]) / 2, (ie[1] + re[1]) / 2];
      } else if (z.touch0) W = z.touch0[0], Z = z.touch0[1];
      else return;
      z.zoom("touch", n(k(O, W, Z), z.extent, s));
    }
  }
  function G(j, ...U) {
    if (this.__zooming) {
      var z = D(this, U).event(j), B = j.changedTouches, q = B.length, Y, O;
      for (R0(j), g && clearTimeout(g), g = setTimeout(function() {
        g = null;
      }, y), Y = 0; Y < q; ++Y)
        O = B[Y], z.touch0 && z.touch0[2] === O.identifier ? delete z.touch0 : z.touch1 && z.touch1[2] === O.identifier && delete z.touch1;
      if (z.touch1 && !z.touch0 && (z.touch0 = z.touch1, delete z.touch1), z.touch0) z.touch0[1] = this.__zoom.invert(z.touch0[0]);
      else if (z.end(), z.taps === 2 && (O = Ar(O, this), Math.hypot(p[0] - O[0], p[1] - O[1]) < E)) {
        var W = Wn(this).on("dblclick.zoom");
        W && W.apply(this, arguments);
      }
    }
  }
  return S.wheelDelta = function(j) {
    return arguments.length ? (r = typeof j == "function" ? j : Ed(+j), S) : r;
  }, S.filter = function(j) {
    return arguments.length ? (e = typeof j == "function" ? j : Ed(!!j), S) : e;
  }, S.touchable = function(j) {
    return arguments.length ? (i = typeof j == "function" ? j : Ed(!!j), S) : i;
  }, S.extent = function(j) {
    return arguments.length ? (t = typeof j == "function" ? j : Ed([[+j[0][0], +j[0][1]], [+j[1][0], +j[1][1]]]), S) : t;
  }, S.scaleExtent = function(j) {
    return arguments.length ? (a[0] = +j[0], a[1] = +j[1], S) : [a[0], a[1]];
  }, S.translateExtent = function(j) {
    return arguments.length ? (s[0][0] = +j[0][0], s[1][0] = +j[1][0], s[0][1] = +j[0][1], s[1][1] = +j[1][1], S) : [[s[0][0], s[0][1]], [s[1][0], s[1][1]]];
  }, S.constrain = function(j) {
    return arguments.length ? (n = j, S) : n;
  }, S.duration = function(j) {
    return arguments.length ? (u = +j, S) : u;
  }, S.interpolate = function(j) {
    return arguments.length ? (f = j, S) : f;
  }, S.on = function() {
    var j = d.on.apply(d, arguments);
    return j === d ? S : j;
  }, S.clickDistance = function(j) {
    return arguments.length ? (x = (j = +j) * j, S) : Math.sqrt(x);
  }, S.tapDistance = function(j) {
    return arguments.length ? (E = +j, S) : E;
  }, S;
}
const oi = {
  error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
  error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
  error003: (e) => `Node type "${e}" not found. Using fallback type "default".`,
  error004: () => "The React Flow parent container needs a width and a height to render the graph.",
  error005: () => "Only child nodes can use a parent extent.",
  error006: () => "Can't create edge. An edge needs a source and a target.",
  error007: (e) => `The old edge with id=${e} does not exist.`,
  error009: (e) => `Marker type "${e}" doesn't exist.`,
  error008: (e, { id: t, sourceHandle: n, targetHandle: r }) => `Couldn't create edge for ${e} handle id: "${e === "source" ? n : r}", edge id: ${t}.`,
  error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
  error011: (e) => `Edge type "${e}" not found. Using fallback type "default".`,
  error012: (e) => `Node with id "${e}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
  error013: (e = "react") => `It seems that you haven't loaded the styles. Please import '@xyflow/${e}/dist/style.css' or base.css to make sure everything is working properly.`,
  error014: () => "useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.",
  error015: () => "It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs."
}, lc = [
  [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
  [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
], aR = ["Enter", " ", "Escape"];
var nl;
(function(e) {
  e.Strict = "strict", e.Loose = "loose";
})(nl || (nl = {}));
var ka;
(function(e) {
  e.Free = "free", e.Vertical = "vertical", e.Horizontal = "horizontal";
})(ka || (ka = {}));
var uc;
(function(e) {
  e.Partial = "partial", e.Full = "full";
})(uc || (uc = {}));
const sR = {
  inProgress: !1,
  isValid: null,
  from: null,
  fromHandle: null,
  fromPosition: null,
  fromNode: null,
  to: null,
  toHandle: null,
  toPosition: null,
  toNode: null
};
var Po;
(function(e) {
  e.Bezier = "default", e.Straight = "straight", e.Step = "step", e.SmoothStep = "smoothstep", e.SimpleBezier = "simplebezier";
})(Po || (Po = {}));
var _h;
(function(e) {
  e.Arrow = "arrow", e.ArrowClosed = "arrowclosed";
})(_h || (_h = {}));
var _e;
(function(e) {
  e.Left = "left", e.Top = "top", e.Right = "right", e.Bottom = "bottom";
})(_e || (_e = {}));
const hE = {
  [_e.Left]: _e.Right,
  [_e.Right]: _e.Left,
  [_e.Top]: _e.Bottom,
  [_e.Bottom]: _e.Top
};
function lR(e) {
  return e === null ? null : e ? "valid" : "invalid";
}
const uR = (e) => "id" in e && "source" in e && "target" in e, II = (e) => "id" in e && "position" in e && !("source" in e) && !("target" in e), yb = (e) => "id" in e && "internals" in e && !("source" in e) && !("target" in e), Nc = (e, t = [0, 0]) => {
  const { width: n, height: r } = Gi(e), i = e.origin ?? t, a = n * i[0], s = r * i[1];
  return {
    x: e.position.x - a,
    y: e.position.y - s
  };
}, LI = (e, t = { nodeOrigin: [0, 0] }) => {
  if (e.length === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  const n = e.reduce((r, i) => {
    const a = typeof i == "string";
    let s = !t.nodeLookup && !a ? i : void 0;
    t.nodeLookup && (s = a ? t.nodeLookup.get(i) : yb(i) ? i : t.nodeLookup.get(i.id));
    const u = s ? Eh(s, t.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };
    return lp(r, u);
  }, { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 });
  return up(n);
}, Mc = (e, t = {}) => {
  if (e.size === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  let n = { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 };
  return e.forEach((r) => {
    if (t.filter === void 0 || t.filter(r)) {
      const i = Eh(r);
      n = lp(n, i);
    }
  }), up(n);
}, cR = (e, t, [n, r, i] = [0, 0, 1], a = !1, s = !1) => {
  const u = {
    ...Dc(t, [n, r, i]),
    width: t.width / i,
    height: t.height / i
  }, f = [];
  for (const d of e.values()) {
    const { measured: h, selectable: p = !0, hidden: g = !1 } = d;
    if (s && !p || g)
      continue;
    const y = h.width ?? d.width ?? d.initialWidth ?? null, b = h.height ?? d.height ?? d.initialHeight ?? null, x = cc(u, il(d)), E = (y ?? 0) * (b ?? 0), S = a && x > 0;
    (!d.internals.handleBounds || S || x >= E || d.dragging) && f.push(d);
  }
  return f;
}, FI = (e, t) => {
  const n = /* @__PURE__ */ new Set();
  return e.forEach((r) => {
    n.add(r.id);
  }), t.filter((r) => n.has(r.source) || n.has(r.target));
};
function BI(e, t) {
  const n = /* @__PURE__ */ new Map(), r = t?.nodes ? new Set(t.nodes.map((i) => i.id)) : null;
  return e.forEach((i) => {
    i.measured.width && i.measured.height && (t?.includeHiddenNodes || !i.hidden) && (!r || r.has(i.id)) && n.set(i.id, i);
  }), n;
}
async function $I({ nodes: e, width: t, height: n, panZoom: r, minZoom: i, maxZoom: a }, s) {
  if (e.size === 0)
    return Promise.resolve(!0);
  const u = BI(e, s), f = Mc(u), d = vb(f, t, n, s?.minZoom ?? i, s?.maxZoom ?? a, s?.padding ?? 0.1);
  return await r.setViewport(d, { duration: s?.duration }), Promise.resolve(!0);
}
function fR({ nodeId: e, nextPosition: t, nodeLookup: n, nodeOrigin: r = [0, 0], nodeExtent: i, onError: a }) {
  const s = n.get(e), u = s.parentId ? n.get(s.parentId) : void 0, { x: f, y: d } = u ? u.internals.positionAbsolute : { x: 0, y: 0 }, h = s.origin ?? r;
  let p = i;
  if (s.extent === "parent" && !s.expandParent)
    if (!u)
      a?.("005", oi.error005());
    else {
      const y = u.measured.width, b = u.measured.height;
      y && b && (p = [
        [f, d],
        [f + y, d + b]
      ]);
    }
  else u && ol(s.extent) && (p = [
    [s.extent[0][0] + f, s.extent[0][1] + d],
    [s.extent[1][0] + f, s.extent[1][1] + d]
  ]);
  const g = ol(p) ? Ra(t, p, s.measured) : t;
  return (s.measured.width === void 0 || s.measured.height === void 0) && a?.("015", oi.error015()), {
    position: {
      x: g.x - f + (s.measured.width ?? 0) * h[0],
      y: g.y - d + (s.measured.height ?? 0) * h[1]
    },
    positionAbsolute: g
  };
}
async function HI({ nodesToRemove: e = [], edgesToRemove: t = [], nodes: n, edges: r, onBeforeDelete: i }) {
  const a = new Set(e.map((g) => g.id)), s = [];
  for (const g of n) {
    if (g.deletable === !1)
      continue;
    const y = a.has(g.id), b = !y && g.parentId && s.find((x) => x.id === g.parentId);
    (y || b) && s.push(g);
  }
  const u = new Set(t.map((g) => g.id)), f = r.filter((g) => g.deletable !== !1), h = FI(s, f);
  for (const g of f)
    u.has(g.id) && !h.find((b) => b.id === g.id) && h.push(g);
  if (!i)
    return {
      edges: h,
      nodes: s
    };
  const p = await i({
    nodes: s,
    edges: h
  });
  return typeof p == "boolean" ? p ? { edges: h, nodes: s } : { edges: [], nodes: [] } : p;
}
const rl = (e, t = 0, n = 1) => Math.min(Math.max(e, t), n), Ra = (e = { x: 0, y: 0 }, t, n) => ({
  x: rl(e.x, t[0][0], t[1][0] - (n?.width ?? 0)),
  y: rl(e.y, t[0][1], t[1][1] - (n?.height ?? 0))
});
function dR(e, t, n) {
  const { width: r, height: i } = Gi(n), { x: a, y: s } = n.internals.positionAbsolute;
  return Ra(e, [
    [a, s],
    [a + r, s + i]
  ], t);
}
const pE = (e, t, n) => e < t ? rl(Math.abs(e - t), 1, t) / t : e > n ? -rl(Math.abs(e - n), 1, t) / t : 0, hR = (e, t, n = 15, r = 40) => {
  const i = pE(e.x, r, t.width - r) * n, a = pE(e.y, r, t.height - r) * n;
  return [i, a];
}, lp = (e, t) => ({
  x: Math.min(e.x, t.x),
  y: Math.min(e.y, t.y),
  x2: Math.max(e.x2, t.x2),
  y2: Math.max(e.y2, t.y2)
}), Xy = ({ x: e, y: t, width: n, height: r }) => ({
  x: e,
  y: t,
  x2: e + n,
  y2: t + r
}), up = ({ x: e, y: t, x2: n, y2: r }) => ({
  x: e,
  y: t,
  width: n - e,
  height: r - t
}), il = (e, t = [0, 0]) => {
  const { x: n, y: r } = yb(e) ? e.internals.positionAbsolute : Nc(e, t);
  return {
    x: n,
    y: r,
    width: e.measured?.width ?? e.width ?? e.initialWidth ?? 0,
    height: e.measured?.height ?? e.height ?? e.initialHeight ?? 0
  };
}, Eh = (e, t = [0, 0]) => {
  const { x: n, y: r } = yb(e) ? e.internals.positionAbsolute : Nc(e, t);
  return {
    x: n,
    y: r,
    x2: n + (e.measured?.width ?? e.width ?? e.initialWidth ?? 0),
    y2: r + (e.measured?.height ?? e.height ?? e.initialHeight ?? 0)
  };
}, pR = (e, t) => up(lp(Xy(e), Xy(t))), cc = (e, t) => {
  const n = Math.max(0, Math.min(e.x + e.width, t.x + t.width) - Math.max(e.x, t.x)), r = Math.max(0, Math.min(e.y + e.height, t.y + t.height) - Math.max(e.y, t.y));
  return Math.ceil(n * r);
}, mE = (e) => Nr(e.width) && Nr(e.height) && Nr(e.x) && Nr(e.y), Nr = (e) => !isNaN(e) && isFinite(e), VI = (e, t) => {
}, cp = (e, t = [1, 1]) => ({
  x: t[0] * Math.round(e.x / t[0]),
  y: t[1] * Math.round(e.y / t[1])
}), Dc = ({ x: e, y: t }, [n, r, i], a = !1, s = [1, 1]) => {
  const u = {
    x: (e - n) / i,
    y: (t - r) / i
  };
  return a ? cp(u, s) : u;
}, Ch = ({ x: e, y: t }, [n, r, i]) => ({
  x: e * i + n,
  y: t * i + r
});
function ks(e, t) {
  if (typeof e == "number")
    return Math.floor(t - t / (1 + e));
  if (typeof e == "string" && e.endsWith("px")) {
    const n = parseFloat(e);
    if (!Number.isNaN(n))
      return Math.floor(n);
  }
  if (typeof e == "string" && e.endsWith("%")) {
    const n = parseFloat(e);
    if (!Number.isNaN(n))
      return Math.floor(t * n * 0.01);
  }
  return console.error(`[React Flow] The padding value "${e}" is invalid. Please provide a number or a string with a valid unit (px or %).`), 0;
}
function UI(e, t, n) {
  if (typeof e == "string" || typeof e == "number") {
    const r = ks(e, n), i = ks(e, t);
    return {
      top: r,
      right: i,
      bottom: r,
      left: i,
      x: i * 2,
      y: r * 2
    };
  }
  if (typeof e == "object") {
    const r = ks(e.top ?? e.y ?? 0, n), i = ks(e.bottom ?? e.y ?? 0, n), a = ks(e.left ?? e.x ?? 0, t), s = ks(e.right ?? e.x ?? 0, t);
    return { top: r, right: s, bottom: i, left: a, x: a + s, y: r + i };
  }
  return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 };
}
function qI(e, t, n, r, i, a) {
  const { x: s, y: u } = Ch(e, [t, n, r]), { x: f, y: d } = Ch({ x: e.x + e.width, y: e.y + e.height }, [t, n, r]), h = i - f, p = a - d;
  return {
    left: Math.floor(s),
    top: Math.floor(u),
    right: Math.floor(h),
    bottom: Math.floor(p)
  };
}
const vb = (e, t, n, r, i, a) => {
  const s = UI(a, t, n), u = (t - s.x) / e.width, f = (n - s.y) / e.height, d = Math.min(u, f), h = rl(d, r, i), p = e.x + e.width / 2, g = e.y + e.height / 2, y = t / 2 - p * h, b = n / 2 - g * h, x = qI(e, y, b, h, t, n), E = {
    left: Math.min(x.left - s.left, 0),
    top: Math.min(x.top - s.top, 0),
    right: Math.min(x.right - s.right, 0),
    bottom: Math.min(x.bottom - s.bottom, 0)
  };
  return {
    x: y - E.left + E.right,
    y: b - E.top + E.bottom,
    zoom: h
  };
}, kh = () => typeof navigator < "u" && navigator?.userAgent?.indexOf("Mac") >= 0;
function ol(e) {
  return e !== void 0 && e !== "parent";
}
function Gi(e) {
  return {
    width: e.measured?.width ?? e.width ?? e.initialWidth ?? 0,
    height: e.measured?.height ?? e.height ?? e.initialHeight ?? 0
  };
}
function mR(e) {
  return (e.measured?.width ?? e.width ?? e.initialWidth) !== void 0 && (e.measured?.height ?? e.height ?? e.initialHeight) !== void 0;
}
function gR(e, t = { width: 0, height: 0 }, n, r, i) {
  const a = { ...e }, s = r.get(n);
  if (s) {
    const u = s.origin || i;
    a.x += s.internals.positionAbsolute.x - (t.width ?? 0) * u[0], a.y += s.internals.positionAbsolute.y - (t.height ?? 0) * u[1];
  }
  return a;
}
function gE(e, t) {
  if (e.size !== t.size)
    return !1;
  for (const n of e)
    if (!t.has(n))
      return !1;
  return !0;
}
function Wu(e, { snapGrid: t = [0, 0], snapToGrid: n = !1, transform: r, containerBounds: i }) {
  const { x: a, y: s } = Ii(e), u = Dc({ x: a - (i?.left ?? 0), y: s - (i?.top ?? 0) }, r), { x: f, y: d } = n ? cp(u, t) : u;
  return {
    xSnapped: f,
    ySnapped: d,
    ...u
  };
}
const bb = (e) => ({
  width: e.offsetWidth,
  height: e.offsetHeight
}), yR = (e) => e?.getRootNode?.() || window?.document, YI = ["INPUT", "SELECT", "TEXTAREA"];
function vR(e) {
  const t = e.composedPath?.()?.[0] || e.target;
  return t?.nodeType !== 1 ? !1 : YI.includes(t.nodeName) || t.hasAttribute("contenteditable") || !!t.closest(".nokey");
}
const bR = (e) => "clientX" in e, Ii = (e, t) => {
  const n = bR(e), r = n ? e.clientX : e.touches?.[0].clientX, i = n ? e.clientY : e.touches?.[0].clientY;
  return {
    x: r - (t?.left ?? 0),
    y: i - (t?.top ?? 0)
  };
}, yE = (e, t, n, r, i) => {
  const a = t.querySelectorAll(`.${e}`);
  return !a || !a.length ? null : Array.from(a).map((s) => {
    const u = s.getBoundingClientRect();
    return {
      id: s.getAttribute("data-handleid"),
      type: e,
      nodeId: i,
      position: s.getAttribute("data-handlepos"),
      x: (u.left - n.left) / r,
      y: (u.top - n.top) / r,
      ...bb(s)
    };
  });
};
function xR({ sourceX: e, sourceY: t, targetX: n, targetY: r, sourceControlX: i, sourceControlY: a, targetControlX: s, targetControlY: u }) {
  const f = e * 0.125 + i * 0.375 + s * 0.375 + n * 0.125, d = t * 0.125 + a * 0.375 + u * 0.375 + r * 0.125, h = Math.abs(f - e), p = Math.abs(d - t);
  return [f, d, h, p];
}
function Cd(e, t) {
  return e >= 0 ? 0.5 * e : t * 25 * Math.sqrt(-e);
}
function vE({ pos: e, x1: t, y1: n, x2: r, y2: i, c: a }) {
  switch (e) {
    case _e.Left:
      return [t - Cd(t - r, a), n];
    case _e.Right:
      return [t + Cd(r - t, a), n];
    case _e.Top:
      return [t, n - Cd(n - i, a)];
    case _e.Bottom:
      return [t, n + Cd(i - n, a)];
  }
}
function xb({ sourceX: e, sourceY: t, sourcePosition: n = _e.Bottom, targetX: r, targetY: i, targetPosition: a = _e.Top, curvature: s = 0.25 }) {
  const [u, f] = vE({
    pos: n,
    x1: e,
    y1: t,
    x2: r,
    y2: i,
    c: s
  }), [d, h] = vE({
    pos: a,
    x1: r,
    y1: i,
    x2: e,
    y2: t,
    c: s
  }), [p, g, y, b] = xR({
    sourceX: e,
    sourceY: t,
    targetX: r,
    targetY: i,
    sourceControlX: u,
    sourceControlY: f,
    targetControlX: d,
    targetControlY: h
  });
  return [
    `M${e},${t} C${u},${f} ${d},${h} ${r},${i}`,
    p,
    g,
    y,
    b
  ];
}
function wR({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
  const i = Math.abs(n - e) / 2, a = n < e ? n + i : n - i, s = Math.abs(r - t) / 2, u = r < t ? r + s : r - s;
  return [a, u, i, s];
}
function GI({ sourceNode: e, targetNode: t, selected: n = !1, zIndex: r = 0, elevateOnSelect: i = !1 }) {
  if (!i)
    return r;
  const a = n || t.selected || e.selected, s = Math.max(e.internals.z || 0, t.internals.z || 0, 1e3);
  return r + (a ? s : 0);
}
function XI({ sourceNode: e, targetNode: t, width: n, height: r, transform: i }) {
  const a = lp(Eh(e), Eh(t));
  a.x === a.x2 && (a.x2 += 1), a.y === a.y2 && (a.y2 += 1);
  const s = {
    x: -i[0] / i[2],
    y: -i[1] / i[2],
    width: n / i[2],
    height: r / i[2]
  };
  return cc(s, up(a)) > 0;
}
const WI = ({ source: e, sourceHandle: t, target: n, targetHandle: r }) => `xy-edge__${e}${t || ""}-${n}${r || ""}`, KI = (e, t) => t.some((n) => n.source === e.source && n.target === e.target && (n.sourceHandle === e.sourceHandle || !n.sourceHandle && !e.sourceHandle) && (n.targetHandle === e.targetHandle || !n.targetHandle && !e.targetHandle)), ZI = (e, t) => {
  if (!e.source || !e.target)
    return t;
  let n;
  return uR(e) ? n = { ...e } : n = {
    ...e,
    id: WI(e)
  }, KI(n, t) ? t : (n.sourceHandle === null && delete n.sourceHandle, n.targetHandle === null && delete n.targetHandle, t.concat(n));
};
function SR({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
  const [i, a, s, u] = wR({
    sourceX: e,
    sourceY: t,
    targetX: n,
    targetY: r
  });
  return [`M ${e},${t}L ${n},${r}`, i, a, s, u];
}
const bE = {
  [_e.Left]: { x: -1, y: 0 },
  [_e.Right]: { x: 1, y: 0 },
  [_e.Top]: { x: 0, y: -1 },
  [_e.Bottom]: { x: 0, y: 1 }
}, QI = ({ source: e, sourcePosition: t = _e.Bottom, target: n }) => t === _e.Left || t === _e.Right ? e.x < n.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : e.y < n.y ? { x: 0, y: 1 } : { x: 0, y: -1 }, xE = (e, t) => Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
function JI({ source: e, sourcePosition: t = _e.Bottom, target: n, targetPosition: r = _e.Top, center: i, offset: a }) {
  const s = bE[t], u = bE[r], f = { x: e.x + s.x * a, y: e.y + s.y * a }, d = { x: n.x + u.x * a, y: n.y + u.y * a }, h = QI({
    source: f,
    sourcePosition: t,
    target: d
  }), p = h.x !== 0 ? "x" : "y", g = h[p];
  let y = [], b, x;
  const E = { x: 0, y: 0 }, S = { x: 0, y: 0 }, [A, k, R, N] = wR({
    sourceX: e.x,
    sourceY: e.y,
    targetX: n.x,
    targetY: n.y
  });
  if (s[p] * u[p] === -1) {
    b = i.x ?? A, x = i.y ?? k;
    const P = [
      { x: b, y: f.y },
      { x: b, y: d.y }
    ], F = [
      { x: f.x, y: x },
      { x: d.x, y: x }
    ];
    s[p] === g ? y = p === "x" ? P : F : y = p === "x" ? F : P;
  } else {
    const P = [{ x: f.x, y: d.y }], F = [{ x: d.x, y: f.y }];
    if (p === "x" ? y = s.x === g ? F : P : y = s.y === g ? P : F, t === r) {
      const G = Math.abs(e[p] - n[p]);
      if (G <= a) {
        const j = Math.min(a - 1, a - G);
        s[p] === g ? E[p] = (f[p] > e[p] ? -1 : 1) * j : S[p] = (d[p] > n[p] ? -1 : 1) * j;
      }
    }
    if (t !== r) {
      const G = p === "x" ? "y" : "x", j = s[p] === u[G], U = f[G] > d[G], z = f[G] < d[G];
      (s[p] === 1 && (!j && U || j && z) || s[p] !== 1 && (!j && z || j && U)) && (y = p === "x" ? P : F);
    }
    const V = { x: f.x + E.x, y: f.y + E.y }, T = { x: d.x + S.x, y: d.y + S.y }, $ = Math.max(Math.abs(V.x - y[0].x), Math.abs(T.x - y[0].x)), H = Math.max(Math.abs(V.y - y[0].y), Math.abs(T.y - y[0].y));
    $ >= H ? (b = (V.x + T.x) / 2, x = y[0].y) : (b = y[0].x, x = (V.y + T.y) / 2);
  }
  return [[
    e,
    { x: f.x + E.x, y: f.y + E.y },
    ...y,
    { x: d.x + S.x, y: d.y + S.y },
    n
  ], b, x, R, N];
}
function eL(e, t, n, r) {
  const i = Math.min(xE(e, t) / 2, xE(t, n) / 2, r), { x: a, y: s } = t;
  if (e.x === a && a === n.x || e.y === s && s === n.y)
    return `L${a} ${s}`;
  if (e.y === s) {
    const d = e.x < n.x ? -1 : 1, h = e.y < n.y ? 1 : -1;
    return `L ${a + i * d},${s}Q ${a},${s} ${a},${s + i * h}`;
  }
  const u = e.x < n.x ? 1 : -1, f = e.y < n.y ? -1 : 1;
  return `L ${a},${s + i * f}Q ${a},${s} ${a + i * u},${s}`;
}
function Wy({ sourceX: e, sourceY: t, sourcePosition: n = _e.Bottom, targetX: r, targetY: i, targetPosition: a = _e.Top, borderRadius: s = 5, centerX: u, centerY: f, offset: d = 20 }) {
  const [h, p, g, y, b] = JI({
    source: { x: e, y: t },
    sourcePosition: n,
    target: { x: r, y: i },
    targetPosition: a,
    center: { x: u, y: f },
    offset: d
  });
  return [h.reduce((E, S, A) => {
    let k = "";
    return A > 0 && A < h.length - 1 ? k = eL(h[A - 1], S, h[A + 1], s) : k = `${A === 0 ? "M" : "L"}${S.x} ${S.y}`, E += k, E;
  }, ""), p, g, y, b];
}
function wE(e) {
  return e && !!(e.internals.handleBounds || e.handles?.length) && !!(e.measured.width || e.width || e.initialWidth);
}
function tL(e) {
  const { sourceNode: t, targetNode: n } = e;
  if (!wE(t) || !wE(n))
    return null;
  const r = t.internals.handleBounds || SE(t.handles), i = n.internals.handleBounds || SE(n.handles), a = _E(r?.source ?? [], e.sourceHandle), s = _E(
    // when connection type is loose we can define all handles as sources and connect source -> source
    e.connectionMode === nl.Strict ? i?.target ?? [] : (i?.target ?? []).concat(i?.source ?? []),
    e.targetHandle
  );
  if (!a || !s)
    return e.onError?.("008", oi.error008(a ? "target" : "source", {
      id: e.id,
      sourceHandle: e.sourceHandle,
      targetHandle: e.targetHandle
    })), null;
  const u = a?.position || _e.Bottom, f = s?.position || _e.Top, d = fc(t, a, u), h = fc(n, s, f);
  return {
    sourceX: d.x,
    sourceY: d.y,
    targetX: h.x,
    targetY: h.y,
    sourcePosition: u,
    targetPosition: f
  };
}
function SE(e) {
  if (!e)
    return null;
  const t = [], n = [];
  for (const r of e)
    r.width = r.width ?? 1, r.height = r.height ?? 1, r.type === "source" ? t.push(r) : r.type === "target" && n.push(r);
  return {
    source: t,
    target: n
  };
}
function fc(e, t, n = _e.Left, r = !1) {
  const i = (t?.x ?? 0) + e.internals.positionAbsolute.x, a = (t?.y ?? 0) + e.internals.positionAbsolute.y, { width: s, height: u } = t ?? Gi(e);
  if (r)
    return { x: i + s / 2, y: a + u / 2 };
  switch (t?.position ?? n) {
    case _e.Top:
      return { x: i + s / 2, y: a };
    case _e.Right:
      return { x: i + s, y: a + u / 2 };
    case _e.Bottom:
      return { x: i + s / 2, y: a + u };
    case _e.Left:
      return { x: i, y: a + u / 2 };
  }
}
function _E(e, t) {
  return e && (t ? e.find((n) => n.id === t) : e[0]) || null;
}
function Ky(e, t) {
  return e ? typeof e == "string" ? e : `${t ? `${t}__` : ""}${Object.keys(e).sort().map((r) => `${r}=${e[r]}`).join("&")}` : "";
}
function nL(e, { id: t, defaultColor: n, defaultMarkerStart: r, defaultMarkerEnd: i }) {
  const a = /* @__PURE__ */ new Set();
  return e.reduce((s, u) => ([u.markerStart || r, u.markerEnd || i].forEach((f) => {
    if (f && typeof f == "object") {
      const d = Ky(f, t);
      a.has(d) || (s.push({ id: d, color: f.color || n, ...f }), a.add(d));
    }
  }), s), []).sort((s, u) => s.id.localeCompare(u.id));
}
const wb = {
  nodeOrigin: [0, 0],
  nodeExtent: lc,
  elevateNodesOnSelect: !0,
  defaults: {}
}, rL = {
  ...wb,
  checkEquality: !0
};
function Sb(e, t) {
  const n = { ...e };
  for (const r in t)
    t[r] !== void 0 && (n[r] = t[r]);
  return n;
}
function iL(e, t, n) {
  const r = Sb(wb, n);
  for (const i of e.values())
    if (i.parentId)
      _b(i, e, t, r);
    else {
      const a = Nc(i, r.nodeOrigin), s = ol(i.extent) ? i.extent : r.nodeExtent, u = Ra(a, s, Gi(i));
      i.internals.positionAbsolute = u;
    }
}
function Zy(e, t, n, r) {
  const i = Sb(rL, r);
  let a = !0;
  const s = new Map(t), u = i?.elevateNodesOnSelect ? 1e3 : 0;
  t.clear(), n.clear();
  for (const f of e) {
    let d = s.get(f.id);
    if (i.checkEquality && f === d?.internals.userNode)
      t.set(f.id, d);
    else {
      const h = Nc(f, i.nodeOrigin), p = ol(f.extent) ? f.extent : i.nodeExtent, g = Ra(h, p, Gi(f));
      d = {
        ...i.defaults,
        ...f,
        measured: {
          width: f.measured?.width,
          height: f.measured?.height
        },
        internals: {
          positionAbsolute: g,
          // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured
          handleBounds: f.measured ? d?.internals.handleBounds : void 0,
          z: _R(f, u),
          userNode: f
        }
      }, t.set(f.id, d);
    }
    (!d.measured || !d.measured.width || !d.measured.height) && !d.hidden && (a = !1), f.parentId && _b(d, t, n, r);
  }
  return a;
}
function oL(e, t) {
  if (!e.parentId)
    return;
  const n = t.get(e.parentId);
  n ? n.set(e.id, e) : t.set(e.parentId, /* @__PURE__ */ new Map([[e.id, e]]));
}
function _b(e, t, n, r) {
  const { elevateNodesOnSelect: i, nodeOrigin: a, nodeExtent: s } = Sb(wb, r), u = e.parentId, f = t.get(u);
  if (!f) {
    console.warn(`Parent node ${u} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);
    return;
  }
  oL(e, n);
  const d = i ? 1e3 : 0, { x: h, y: p, z: g } = aL(e, f, a, s, d), { positionAbsolute: y } = e.internals, b = h !== y.x || p !== y.y;
  (b || g !== e.internals.z) && t.set(e.id, {
    ...e,
    internals: {
      ...e.internals,
      positionAbsolute: b ? { x: h, y: p } : y,
      z: g
    }
  });
}
function _R(e, t) {
  return (Nr(e.zIndex) ? e.zIndex : 0) + (e.selected ? t : 0);
}
function aL(e, t, n, r, i) {
  const { x: a, y: s } = t.internals.positionAbsolute, u = Gi(e), f = Nc(e, n), d = ol(e.extent) ? Ra(f, e.extent, u) : f;
  let h = Ra({ x: a + d.x, y: s + d.y }, r, u);
  e.extent === "parent" && (h = dR(h, u, t));
  const p = _R(e, i), g = t.internals.z ?? 0;
  return {
    x: h.x,
    y: h.y,
    z: g > p ? g : p
  };
}
function Eb(e, t, n, r = [0, 0]) {
  const i = [], a = /* @__PURE__ */ new Map();
  for (const s of e) {
    const u = t.get(s.parentId);
    if (!u)
      continue;
    const f = a.get(s.parentId)?.expandedRect ?? il(u), d = pR(f, s.rect);
    a.set(s.parentId, { expandedRect: d, parent: u });
  }
  return a.size > 0 && a.forEach(({ expandedRect: s, parent: u }, f) => {
    const d = u.internals.positionAbsolute, h = Gi(u), p = u.origin ?? r, g = s.x < d.x ? Math.round(Math.abs(d.x - s.x)) : 0, y = s.y < d.y ? Math.round(Math.abs(d.y - s.y)) : 0, b = Math.max(h.width, Math.round(s.width)), x = Math.max(h.height, Math.round(s.height)), E = (b - h.width) * p[0], S = (x - h.height) * p[1];
    (g > 0 || y > 0 || E || S) && (i.push({
      id: f,
      type: "position",
      position: {
        x: u.position.x - g + E,
        y: u.position.y - y + S
      }
    }), n.get(f)?.forEach((A) => {
      e.some((k) => k.id === A.id) || i.push({
        id: A.id,
        type: "position",
        position: {
          x: A.position.x + g,
          y: A.position.y + y
        }
      });
    })), (h.width < s.width || h.height < s.height || g || y) && i.push({
      id: f,
      type: "dimensions",
      setAttributes: !0,
      dimensions: {
        width: b + (g ? p[0] * g - E : 0),
        height: x + (y ? p[1] * y - S : 0)
      }
    });
  }), i;
}
function sL(e, t, n, r, i, a) {
  const s = r?.querySelector(".xyflow__viewport");
  let u = !1;
  if (!s)
    return { changes: [], updatedInternals: u };
  const f = [], d = window.getComputedStyle(s), { m22: h } = new window.DOMMatrixReadOnly(d.transform), p = [];
  for (const g of e.values()) {
    const y = t.get(g.id);
    if (!y)
      continue;
    if (y.hidden) {
      t.set(y.id, {
        ...y,
        internals: {
          ...y.internals,
          handleBounds: void 0
        }
      }), u = !0;
      continue;
    }
    const b = bb(g.nodeElement), x = y.measured.width !== b.width || y.measured.height !== b.height;
    if (!!(b.width && b.height && (x || !y.internals.handleBounds || g.force))) {
      const S = g.nodeElement.getBoundingClientRect(), A = ol(y.extent) ? y.extent : a;
      let { positionAbsolute: k } = y.internals;
      y.parentId && y.extent === "parent" ? k = dR(k, b, t.get(y.parentId)) : A && (k = Ra(k, A, b));
      const R = {
        ...y,
        measured: b,
        internals: {
          ...y.internals,
          positionAbsolute: k,
          handleBounds: {
            source: yE("source", g.nodeElement, S, h, y.id),
            target: yE("target", g.nodeElement, S, h, y.id)
          }
        }
      };
      t.set(y.id, R), y.parentId && _b(R, t, n, { nodeOrigin: i }), u = !0, x && (f.push({
        id: y.id,
        type: "dimensions",
        dimensions: b
      }), y.expandParent && y.parentId && p.push({
        id: y.id,
        parentId: y.parentId,
        rect: il(R, i)
      }));
    }
  }
  if (p.length > 0) {
    const g = Eb(p, t, n, i);
    f.push(...g);
  }
  return { changes: f, updatedInternals: u };
}
async function lL({ delta: e, panZoom: t, transform: n, translateExtent: r, width: i, height: a }) {
  if (!t || !e.x && !e.y)
    return Promise.resolve(!1);
  const s = await t.setViewportConstrained({
    x: n[0] + e.x,
    y: n[1] + e.y,
    zoom: n[2]
  }, [
    [0, 0],
    [i, a]
  ], r), u = !!s && (s.x !== n[0] || s.y !== n[1] || s.k !== n[2]);
  return Promise.resolve(u);
}
function EE(e, t, n, r, i, a) {
  let s = i;
  const u = r.get(s) || /* @__PURE__ */ new Map();
  r.set(s, u.set(n, t)), s = `${i}-${e}`;
  const f = r.get(s) || /* @__PURE__ */ new Map();
  if (r.set(s, f.set(n, t)), a) {
    s = `${i}-${e}-${a}`;
    const d = r.get(s) || /* @__PURE__ */ new Map();
    r.set(s, d.set(n, t));
  }
}
function ER(e, t, n) {
  e.clear(), t.clear();
  for (const r of n) {
    const { source: i, target: a, sourceHandle: s = null, targetHandle: u = null } = r, f = { edgeId: r.id, source: i, target: a, sourceHandle: s, targetHandle: u }, d = `${i}-${s}--${a}-${u}`, h = `${a}-${u}--${i}-${s}`;
    EE("source", f, h, e, i, s), EE("target", f, d, e, a, u), t.set(r.id, r);
  }
}
function CR(e, t) {
  if (!e.parentId)
    return !1;
  const n = t.get(e.parentId);
  return n ? n.selected ? !0 : CR(n, t) : !1;
}
function CE(e, t, n) {
  let r = e;
  do {
    if (r?.matches?.(t))
      return !0;
    if (r === n)
      return !1;
    r = r?.parentElement;
  } while (r);
  return !1;
}
function uL(e, t, n, r) {
  const i = /* @__PURE__ */ new Map();
  for (const [a, s] of e)
    if ((s.selected || s.id === r) && (!s.parentId || !CR(s, e)) && (s.draggable || t && typeof s.draggable > "u")) {
      const u = e.get(a);
      u && i.set(a, {
        id: a,
        position: u.position || { x: 0, y: 0 },
        distance: {
          x: n.x - u.internals.positionAbsolute.x,
          y: n.y - u.internals.positionAbsolute.y
        },
        extent: u.extent,
        parentId: u.parentId,
        origin: u.origin,
        expandParent: u.expandParent,
        internals: {
          positionAbsolute: u.internals.positionAbsolute || { x: 0, y: 0 }
        },
        measured: {
          width: u.measured.width ?? 0,
          height: u.measured.height ?? 0
        }
      });
    }
  return i;
}
function O0({ nodeId: e, dragItems: t, nodeLookup: n, dragging: r = !0 }) {
  const i = [];
  for (const [s, u] of t) {
    const f = n.get(s)?.internals.userNode;
    f && i.push({
      ...f,
      position: u.position,
      dragging: r
    });
  }
  if (!e)
    return [i[0], i];
  const a = n.get(e)?.internals.userNode;
  return [
    a ? {
      ...a,
      position: t.get(e)?.position || a.position,
      dragging: r
    } : i[0],
    i
  ];
}
function cL({ onNodeMouseDown: e, getStoreItems: t, onDragStart: n, onDrag: r, onDragStop: i }) {
  let a = { x: null, y: null }, s = 0, u = /* @__PURE__ */ new Map(), f = !1, d = { x: 0, y: 0 }, h = null, p = !1, g = null, y = !1;
  function b({ noDragClassName: E, handleSelector: S, domNode: A, isSelectable: k, nodeId: R, nodeClickDistance: N = 0 }) {
    g = Wn(A);
    function D({ x: T, y: $ }, H) {
      const { nodeLookup: G, nodeExtent: j, snapGrid: U, snapToGrid: z, nodeOrigin: B, onNodeDrag: q, onSelectionDrag: Y, onError: O, updateNodePositions: W } = t();
      a = { x: T, y: $ };
      let Z = !1, I = { x: 0, y: 0, x2: 0, y2: 0 };
      if (u.size > 1 && j) {
        const ie = Mc(u);
        I = Xy(ie);
      }
      for (const [ie, fe] of u) {
        if (!G.has(ie))
          continue;
        let re = { x: T - fe.distance.x, y: $ - fe.distance.y };
        z && (re = cp(re, U));
        let le = [
          [j[0][0], j[0][1]],
          [j[1][0], j[1][1]]
        ];
        if (u.size > 1 && j && !fe.extent) {
          const { positionAbsolute: je } = fe.internals, Oe = je.x - I.x + j[0][0], be = je.x + fe.measured.width - I.x2 + j[1][0], Le = je.y - I.y + j[0][1], Ie = je.y + fe.measured.height - I.y2 + j[1][1];
          le = [
            [Oe, Le],
            [be, Ie]
          ];
        }
        const { position: he, positionAbsolute: ye } = fR({
          nodeId: ie,
          nextPosition: re,
          nodeLookup: G,
          nodeExtent: le,
          nodeOrigin: B,
          onError: O
        });
        Z = Z || fe.position.x !== he.x || fe.position.y !== he.y, fe.position = he, fe.internals.positionAbsolute = ye;
      }
      if (Z && (W(u, !0), H && (r || q || !R && Y))) {
        const [ie, fe] = O0({
          nodeId: R,
          dragItems: u,
          nodeLookup: G
        });
        r?.(H, u, ie, fe), q?.(H, ie, fe), R || Y?.(H, fe);
      }
    }
    async function P() {
      if (!h)
        return;
      const { transform: T, panBy: $, autoPanSpeed: H, autoPanOnNodeDrag: G } = t();
      if (!G) {
        f = !1, cancelAnimationFrame(s);
        return;
      }
      const [j, U] = hR(d, h, H);
      (j !== 0 || U !== 0) && (a.x = (a.x ?? 0) - j / T[2], a.y = (a.y ?? 0) - U / T[2], await $({ x: j, y: U }) && D(a, null)), s = requestAnimationFrame(P);
    }
    function F(T) {
      const { nodeLookup: $, multiSelectionActive: H, nodesDraggable: G, transform: j, snapGrid: U, snapToGrid: z, selectNodesOnDrag: B, onNodeDragStart: q, onSelectionDragStart: Y, unselectNodesAndEdges: O } = t();
      p = !0, (!B || !k) && !H && R && ($.get(R)?.selected || O()), k && B && R && e?.(R);
      const W = Wu(T.sourceEvent, { transform: j, snapGrid: U, snapToGrid: z, containerBounds: h });
      if (a = W, u = uL($, G, W, R), u.size > 0 && (n || q || !R && Y)) {
        const [Z, I] = O0({
          nodeId: R,
          dragItems: u,
          nodeLookup: $
        });
        n?.(T.sourceEvent, u, Z, I), q?.(T.sourceEvent, Z, I), R || Y?.(T.sourceEvent, I);
      }
    }
    const V = UT().clickDistance(N).on("start", (T) => {
      const { domNode: $, nodeDragThreshold: H, transform: G, snapGrid: j, snapToGrid: U } = t();
      h = $?.getBoundingClientRect() || null, y = !1, H === 0 && F(T), a = Wu(T.sourceEvent, { transform: G, snapGrid: j, snapToGrid: U, containerBounds: h }), d = Ii(T.sourceEvent, h);
    }).on("drag", (T) => {
      const { autoPanOnNodeDrag: $, transform: H, snapGrid: G, snapToGrid: j, nodeDragThreshold: U, nodeLookup: z } = t(), B = Wu(T.sourceEvent, { transform: H, snapGrid: G, snapToGrid: j, containerBounds: h });
      if ((T.sourceEvent.type === "touchmove" && T.sourceEvent.touches.length > 1 || // if user deletes a node while dragging, we need to abort the drag to prevent errors
      R && !z.has(R)) && (y = !0), !y) {
        if (!f && $ && p && (f = !0, P()), !p) {
          const q = B.xSnapped - (a.x ?? 0), Y = B.ySnapped - (a.y ?? 0);
          Math.sqrt(q * q + Y * Y) > U && F(T);
        }
        (a.x !== B.xSnapped || a.y !== B.ySnapped) && u && p && (d = Ii(T.sourceEvent, h), D(B, T.sourceEvent));
      }
    }).on("end", (T) => {
      if (!(!p || y) && (f = !1, p = !1, cancelAnimationFrame(s), u.size > 0)) {
        const { nodeLookup: $, updateNodePositions: H, onNodeDragStop: G, onSelectionDragStop: j } = t();
        if (H(u, !1), i || G || !R && j) {
          const [U, z] = O0({
            nodeId: R,
            dragItems: u,
            nodeLookup: $,
            dragging: !1
          });
          i?.(T.sourceEvent, u, U, z), G?.(T.sourceEvent, U, z), R || j?.(T.sourceEvent, z);
        }
      }
    }).filter((T) => {
      const $ = T.target;
      return !T.button && (!E || !CE($, `.${E}`, A)) && (!S || CE($, S, A));
    });
    g.call(V);
  }
  function x() {
    g?.on(".drag", null);
  }
  return {
    update: b,
    destroy: x
  };
}
function fL(e, t, n) {
  const r = [], i = {
    x: e.x - n,
    y: e.y - n,
    width: n * 2,
    height: n * 2
  };
  for (const a of t.values())
    cc(i, il(a)) > 0 && r.push(a);
  return r;
}
const dL = 250;
function hL(e, t, n, r) {
  let i = [], a = 1 / 0;
  const s = fL(e, n, t + dL);
  for (const u of s) {
    const f = [...u.internals.handleBounds?.source ?? [], ...u.internals.handleBounds?.target ?? []];
    for (const d of f) {
      if (r.nodeId === d.nodeId && r.type === d.type && r.id === d.id)
        continue;
      const { x: h, y: p } = fc(u, d, d.position, !0), g = Math.sqrt(Math.pow(h - e.x, 2) + Math.pow(p - e.y, 2));
      g > t || (g < a ? (i = [{ ...d, x: h, y: p }], a = g) : g === a && i.push({ ...d, x: h, y: p }));
    }
  }
  if (!i.length)
    return null;
  if (i.length > 1) {
    const u = r.type === "source" ? "target" : "source";
    return i.find((f) => f.type === u) ?? i[0];
  }
  return i[0];
}
function kR(e, t, n, r, i, a = !1) {
  const s = r.get(e);
  if (!s)
    return null;
  const u = i === "strict" ? s.internals.handleBounds?.[t] : [...s.internals.handleBounds?.source ?? [], ...s.internals.handleBounds?.target ?? []], f = (n ? u?.find((d) => d.id === n) : u?.[0]) ?? null;
  return f && a ? { ...f, ...fc(s, f, f.position, !0) } : f;
}
function AR(e, t) {
  return e || (t?.classList.contains("target") ? "target" : t?.classList.contains("source") ? "source" : null);
}
function pL(e, t) {
  let n = null;
  return t ? n = !0 : e && !t && (n = !1), n;
}
const TR = () => !0;
function mL(e, { connectionMode: t, connectionRadius: n, handleId: r, nodeId: i, edgeUpdaterType: a, isTarget: s, domNode: u, nodeLookup: f, lib: d, autoPanOnConnect: h, flowId: p, panBy: g, cancelConnection: y, onConnectStart: b, onConnect: x, onConnectEnd: E, isValidConnection: S = TR, onReconnectEnd: A, updateConnection: k, getTransform: R, getFromHandle: N, autoPanSpeed: D }) {
  const P = yR(e.target);
  let F = 0, V;
  const { x: T, y: $ } = Ii(e), H = P?.elementFromPoint(T, $), G = AR(a, H), j = u?.getBoundingClientRect();
  if (!j || !G)
    return;
  const U = kR(i, G, r, f, t);
  if (!U)
    return;
  let z = Ii(e, j), B = !1, q = null, Y = !1, O = null;
  function W() {
    if (!h || !j)
      return;
    const [ye, je] = hR(z, j, D);
    g({ x: ye, y: je }), F = requestAnimationFrame(W);
  }
  const Z = {
    ...U,
    nodeId: i,
    type: G,
    position: U.position
  }, I = f.get(i), fe = {
    inProgress: !0,
    isValid: null,
    from: fc(I, Z, _e.Left, !0),
    fromHandle: Z,
    fromPosition: Z.position,
    fromNode: I,
    to: z,
    toHandle: null,
    toPosition: hE[Z.position],
    toNode: null
  };
  k(fe);
  let re = fe;
  b?.(e, { nodeId: i, handleId: r, handleType: G });
  function le(ye) {
    if (!N() || !Z) {
      he(ye);
      return;
    }
    const je = R();
    z = Ii(ye, j), V = hL(Dc(z, je, !1, [1, 1]), n, f, Z), B || (W(), B = !0);
    const Oe = RR(ye, {
      handle: V,
      connectionMode: t,
      fromNodeId: i,
      fromHandleId: r,
      fromType: s ? "target" : "source",
      isValidConnection: S,
      doc: P,
      lib: d,
      flowId: p,
      nodeLookup: f
    });
    O = Oe.handleDomNode, q = Oe.connection, Y = pL(!!V, Oe.isValid);
    const be = {
      // from stays the same
      ...re,
      isValid: Y,
      to: V && Y ? Ch({ x: V.x, y: V.y }, je) : z,
      toHandle: Oe.toHandle,
      toPosition: Y && Oe.toHandle ? Oe.toHandle.position : hE[Z.position],
      toNode: Oe.toHandle ? f.get(Oe.toHandle.nodeId) : null
    };
    Y && V && re.toHandle && be.toHandle && re.toHandle.type === be.toHandle.type && re.toHandle.nodeId === be.toHandle.nodeId && re.toHandle.id === be.toHandle.id && re.to.x === be.to.x && re.to.y === be.to.y || (k(be), re = be);
  }
  function he(ye) {
    (V || O) && q && Y && x?.(q);
    const { inProgress: je, ...Oe } = re, be = {
      ...Oe,
      toPosition: re.toHandle ? re.toPosition : null
    };
    E?.(ye, be), a && A?.(ye, be), y(), cancelAnimationFrame(F), B = !1, Y = !1, q = null, O = null, P.removeEventListener("mousemove", le), P.removeEventListener("mouseup", he), P.removeEventListener("touchmove", le), P.removeEventListener("touchend", he);
  }
  P.addEventListener("mousemove", le), P.addEventListener("mouseup", he), P.addEventListener("touchmove", le), P.addEventListener("touchend", he);
}
function RR(e, { handle: t, connectionMode: n, fromNodeId: r, fromHandleId: i, fromType: a, doc: s, lib: u, flowId: f, isValidConnection: d = TR, nodeLookup: h }) {
  const p = a === "target", g = t ? s.querySelector(`.${u}-flow__handle[data-id="${f}-${t?.nodeId}-${t?.id}-${t?.type}"]`) : null, { x: y, y: b } = Ii(e), x = s.elementFromPoint(y, b), E = x?.classList.contains(`${u}-flow__handle`) ? x : g, S = {
    handleDomNode: E,
    isValid: !1,
    connection: null,
    toHandle: null
  };
  if (E) {
    const A = AR(void 0, E), k = E.getAttribute("data-nodeid"), R = E.getAttribute("data-handleid"), N = E.classList.contains("connectable"), D = E.classList.contains("connectableend");
    if (!k || !A)
      return S;
    const P = {
      source: p ? k : r,
      sourceHandle: p ? R : i,
      target: p ? r : k,
      targetHandle: p ? i : R
    };
    S.connection = P;
    const V = N && D && (n === nl.Strict ? p && A === "source" || !p && A === "target" : k !== r || R !== i);
    S.isValid = V && d(P), S.toHandle = kR(k, A, R, h, n, !1);
  }
  return S;
}
const Qy = {
  onPointerDown: mL,
  isValid: RR
};
function gL({ domNode: e, panZoom: t, getTransform: n, getViewScale: r }) {
  const i = Wn(e);
  function a({ translateExtent: u, width: f, height: d, zoomStep: h = 10, pannable: p = !0, zoomable: g = !0, inversePan: y = !1 }) {
    const b = (k) => {
      const R = n();
      if (k.sourceEvent.type !== "wheel" || !t)
        return;
      const N = -k.sourceEvent.deltaY * (k.sourceEvent.deltaMode === 1 ? 0.05 : k.sourceEvent.deltaMode ? 1 : 2e-3) * h, D = R[2] * Math.pow(2, N);
      t.scaleTo(D);
    };
    let x = [0, 0];
    const E = (k) => {
      (k.sourceEvent.type === "mousedown" || k.sourceEvent.type === "touchstart") && (x = [
        k.sourceEvent.clientX ?? k.sourceEvent.touches[0].clientX,
        k.sourceEvent.clientY ?? k.sourceEvent.touches[0].clientY
      ]);
    }, S = (k) => {
      const R = n();
      if (k.sourceEvent.type !== "mousemove" && k.sourceEvent.type !== "touchmove" || !t)
        return;
      const N = [
        k.sourceEvent.clientX ?? k.sourceEvent.touches[0].clientX,
        k.sourceEvent.clientY ?? k.sourceEvent.touches[0].clientY
      ], D = [N[0] - x[0], N[1] - x[1]];
      x = N;
      const P = r() * Math.max(R[2], Math.log(R[2])) * (y ? -1 : 1), F = {
        x: R[0] - D[0] * P,
        y: R[1] - D[1] * P
      }, V = [
        [0, 0],
        [f, d]
      ];
      t.setViewportConstrained({
        x: F.x,
        y: F.y,
        zoom: R[2]
      }, V, u);
    }, A = oR().on("start", E).on("zoom", p ? S : null).on("zoom.wheel", g ? b : null);
    i.call(A, {});
  }
  function s() {
    i.on("zoom", null);
  }
  return {
    update: a,
    destroy: s,
    pointer: Ar
  };
}
const yL = (e, t) => e.x !== t.x || e.y !== t.y || e.zoom !== t.k, fp = (e) => ({
  x: e.x,
  y: e.y,
  zoom: e.k
}), N0 = ({ x: e, y: t, zoom: n }) => sp.translate(e, t).scale(n), $s = (e, t) => e.target.closest(`.${t}`), OR = (e, t) => t === 2 && Array.isArray(e) && e.includes(2), M0 = (e, t = 0, n = () => {
}) => {
  const r = typeof t == "number" && t > 0;
  return r || n(), r ? e.transition().duration(t).on("end", n) : e;
}, NR = (e) => {
  const t = e.ctrlKey && kh() ? 10 : 1;
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * t;
};
function vL({ zoomPanValues: e, noWheelClassName: t, d3Selection: n, d3Zoom: r, panOnScrollMode: i, panOnScrollSpeed: a, zoomOnPinch: s, onPanZoomStart: u, onPanZoom: f, onPanZoomEnd: d }) {
  return (h) => {
    if ($s(h, t))
      return !1;
    h.preventDefault(), h.stopImmediatePropagation();
    const p = n.property("__zoom").k || 1;
    if (h.ctrlKey && s) {
      const E = Ar(h), S = NR(h), A = p * Math.pow(2, S);
      r.scaleTo(n, A, E, h);
      return;
    }
    const g = h.deltaMode === 1 ? 20 : 1;
    let y = i === ka.Vertical ? 0 : h.deltaX * g, b = i === ka.Horizontal ? 0 : h.deltaY * g;
    !kh() && h.shiftKey && i !== ka.Vertical && (y = h.deltaY * g, b = 0), r.translateBy(
      n,
      -(y / p) * a,
      -(b / p) * a,
      // @ts-ignore
      { internal: !0 }
    );
    const x = fp(n.property("__zoom"));
    clearTimeout(e.panScrollTimeout), e.isPanScrolling || (e.isPanScrolling = !0, u?.(h, x)), e.isPanScrolling && (f?.(h, x), e.panScrollTimeout = setTimeout(() => {
      d?.(h, x), e.isPanScrolling = !1;
    }, 150));
  };
}
function bL({ noWheelClassName: e, preventScrolling: t, d3ZoomHandler: n }) {
  return function(r, i) {
    const a = r.type === "wheel", s = !t && a && !r.ctrlKey, u = $s(r, e);
    if (r.ctrlKey && a && u && r.preventDefault(), s || u)
      return null;
    r.preventDefault(), n.call(this, r, i);
  };
}
function xL({ zoomPanValues: e, onDraggingChange: t, onPanZoomStart: n }) {
  return (r) => {
    if (r.sourceEvent?.internal)
      return;
    const i = fp(r.transform);
    e.mouseButton = r.sourceEvent?.button || 0, e.isZoomingOrPanning = !0, e.prevViewport = i, r.sourceEvent?.type === "mousedown" && t(!0), n && n?.(r.sourceEvent, i);
  };
}
function wL({ zoomPanValues: e, panOnDrag: t, onPaneContextMenu: n, onTransformChange: r, onPanZoom: i }) {
  return (a) => {
    e.usedRightMouseButton = !!(n && OR(t, e.mouseButton ?? 0)), a.sourceEvent?.sync || r([a.transform.x, a.transform.y, a.transform.k]), i && !a.sourceEvent?.internal && i?.(a.sourceEvent, fp(a.transform));
  };
}
function SL({ zoomPanValues: e, panOnDrag: t, panOnScroll: n, onDraggingChange: r, onPanZoomEnd: i, onPaneContextMenu: a }) {
  return (s) => {
    if (!s.sourceEvent?.internal && (e.isZoomingOrPanning = !1, a && OR(t, e.mouseButton ?? 0) && !e.usedRightMouseButton && s.sourceEvent && a(s.sourceEvent), e.usedRightMouseButton = !1, r(!1), i && yL(e.prevViewport, s.transform))) {
      const u = fp(s.transform);
      e.prevViewport = u, clearTimeout(e.timerId), e.timerId = setTimeout(
        () => {
          i?.(s.sourceEvent, u);
        },
        // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
        n ? 150 : 0
      );
    }
  };
}
function _L({ zoomActivationKeyPressed: e, zoomOnScroll: t, zoomOnPinch: n, panOnDrag: r, panOnScroll: i, zoomOnDoubleClick: a, userSelectionActive: s, noWheelClassName: u, noPanClassName: f, lib: d }) {
  return (h) => {
    const p = e || t, g = n && h.ctrlKey;
    if (h.button === 1 && h.type === "mousedown" && ($s(h, `${d}-flow__node`) || $s(h, `${d}-flow__edge`)))
      return !0;
    if (!r && !p && !i && !a && !n || s || $s(h, u) && h.type === "wheel" || $s(h, f) && (h.type !== "wheel" || i && h.type === "wheel" && !e) || !n && h.ctrlKey && h.type === "wheel")
      return !1;
    if (!n && h.type === "touchstart" && h.touches?.length > 1)
      return h.preventDefault(), !1;
    if (!p && !i && !g && h.type === "wheel" || !r && (h.type === "mousedown" || h.type === "touchstart") || Array.isArray(r) && !r.includes(h.button) && h.type === "mousedown")
      return !1;
    const y = Array.isArray(r) && r.includes(h.button) || !h.button || h.button <= 1;
    return (!h.ctrlKey || h.type === "wheel") && y;
  };
}
function EL({ domNode: e, minZoom: t, maxZoom: n, paneClickDistance: r, translateExtent: i, viewport: a, onPanZoom: s, onPanZoomStart: u, onPanZoomEnd: f, onDraggingChange: d }) {
  const h = {
    isZoomingOrPanning: !1,
    usedRightMouseButton: !1,
    prevViewport: { x: 0, y: 0, zoom: 0 },
    mouseButton: 0,
    timerId: void 0,
    panScrollTimeout: void 0,
    isPanScrolling: !1
  }, p = e.getBoundingClientRect(), g = oR().clickDistance(!Nr(r) || r < 0 ? 0 : r).scaleExtent([t, n]).translateExtent(i), y = Wn(e).call(g);
  k({
    x: a.x,
    y: a.y,
    zoom: rl(a.zoom, t, n)
  }, [
    [0, 0],
    [p.width, p.height]
  ], i);
  const b = y.on("wheel.zoom"), x = y.on("dblclick.zoom");
  g.wheelDelta(NR);
  function E(H, G) {
    return y ? new Promise((j) => {
      g?.transform(M0(y, G?.duration, () => j(!0)), H);
    }) : Promise.resolve(!1);
  }
  function S({ noWheelClassName: H, noPanClassName: G, onPaneContextMenu: j, userSelectionActive: U, panOnScroll: z, panOnDrag: B, panOnScrollMode: q, panOnScrollSpeed: Y, preventScrolling: O, zoomOnPinch: W, zoomOnScroll: Z, zoomOnDoubleClick: I, zoomActivationKeyPressed: ie, lib: fe, onTransformChange: re }) {
    U && !h.isZoomingOrPanning && A();
    const he = z && !ie && !U ? vL({
      zoomPanValues: h,
      noWheelClassName: H,
      d3Selection: y,
      d3Zoom: g,
      panOnScrollMode: q,
      panOnScrollSpeed: Y,
      zoomOnPinch: W,
      onPanZoomStart: u,
      onPanZoom: s,
      onPanZoomEnd: f
    }) : bL({
      noWheelClassName: H,
      preventScrolling: O,
      d3ZoomHandler: b
    });
    if (y.on("wheel.zoom", he, { passive: !1 }), !U) {
      const je = xL({
        zoomPanValues: h,
        onDraggingChange: d,
        onPanZoomStart: u
      });
      g.on("start", je);
      const Oe = wL({
        zoomPanValues: h,
        panOnDrag: B,
        onPaneContextMenu: !!j,
        onPanZoom: s,
        onTransformChange: re
      });
      g.on("zoom", Oe);
      const be = SL({
        zoomPanValues: h,
        panOnDrag: B,
        panOnScroll: z,
        onPaneContextMenu: j,
        onPanZoomEnd: f,
        onDraggingChange: d
      });
      g.on("end", be);
    }
    const ye = _L({
      zoomActivationKeyPressed: ie,
      panOnDrag: B,
      zoomOnScroll: Z,
      panOnScroll: z,
      zoomOnDoubleClick: I,
      zoomOnPinch: W,
      userSelectionActive: U,
      noPanClassName: G,
      noWheelClassName: H,
      lib: fe
    });
    g.filter(ye), I ? y.on("dblclick.zoom", x) : y.on("dblclick.zoom", null);
  }
  function A() {
    g.on("zoom", null);
  }
  async function k(H, G, j) {
    const U = N0(H), z = g?.constrain()(U, G, j);
    return z && await E(z), new Promise((B) => B(z));
  }
  async function R(H, G) {
    const j = N0(H);
    return await E(j, G), new Promise((U) => U(j));
  }
  function N(H) {
    if (y) {
      const G = N0(H), j = y.property("__zoom");
      (j.k !== H.zoom || j.x !== H.x || j.y !== H.y) && g?.transform(y, G, null, { sync: !0 });
    }
  }
  function D() {
    const H = y ? iR(y.node()) : { x: 0, y: 0, k: 1 };
    return { x: H.x, y: H.y, zoom: H.k };
  }
  function P(H, G) {
    return y ? new Promise((j) => {
      g?.scaleTo(M0(y, G?.duration, () => j(!0)), H);
    }) : Promise.resolve(!1);
  }
  function F(H, G) {
    return y ? new Promise((j) => {
      g?.scaleBy(M0(y, G?.duration, () => j(!0)), H);
    }) : Promise.resolve(!1);
  }
  function V(H) {
    g?.scaleExtent(H);
  }
  function T(H) {
    g?.translateExtent(H);
  }
  function $(H) {
    const G = !Nr(H) || H < 0 ? 0 : H;
    g?.clickDistance(G);
  }
  return {
    update: S,
    destroy: A,
    setViewport: R,
    setViewportConstrained: k,
    getViewport: D,
    scaleTo: P,
    scaleBy: F,
    setScaleExtent: V,
    setTranslateExtent: T,
    syncViewport: N,
    setClickDistance: $
  };
}
var Ku;
(function(e) {
  e.Line = "line", e.Handle = "handle";
})(Ku || (Ku = {}));
function CL({ width: e, prevWidth: t, height: n, prevHeight: r, affectsX: i, affectsY: a }) {
  const s = e - t, u = n - r, f = [s > 0 ? 1 : s < 0 ? -1 : 0, u > 0 ? 1 : u < 0 ? -1 : 0];
  return s && i && (f[0] = f[0] * -1), u && a && (f[1] = f[1] * -1), f;
}
function kL(e) {
  const t = e.includes("right") || e.includes("left"), n = e.includes("bottom") || e.includes("top"), r = e.includes("left"), i = e.includes("top");
  return {
    isHorizontal: t,
    isVertical: n,
    affectsX: r,
    affectsY: i
  };
}
function To(e, t) {
  return Math.max(0, t - e);
}
function Ro(e, t) {
  return Math.max(0, e - t);
}
function kd(e, t, n) {
  return Math.max(0, t - e, e - n);
}
function kE(e, t) {
  return e ? !t : t;
}
function AL(e, t, n, r, i, a, s, u) {
  let { affectsX: f, affectsY: d } = t;
  const { isHorizontal: h, isVertical: p } = t, g = h && p, { xSnapped: y, ySnapped: b } = n, { minWidth: x, maxWidth: E, minHeight: S, maxHeight: A } = r, { x: k, y: R, width: N, height: D, aspectRatio: P } = e;
  let F = Math.floor(h ? y - e.pointerX : 0), V = Math.floor(p ? b - e.pointerY : 0);
  const T = N + (f ? -F : F), $ = D + (d ? -V : V), H = -a[0] * N, G = -a[1] * D;
  let j = kd(T, x, E), U = kd($, S, A);
  if (s) {
    let q = 0, Y = 0;
    f && F < 0 ? q = To(k + F + H, s[0][0]) : !f && F > 0 && (q = Ro(k + T + H, s[1][0])), d && V < 0 ? Y = To(R + V + G, s[0][1]) : !d && V > 0 && (Y = Ro(R + $ + G, s[1][1])), j = Math.max(j, q), U = Math.max(U, Y);
  }
  if (u) {
    let q = 0, Y = 0;
    f && F > 0 ? q = Ro(k + F, u[0][0]) : !f && F < 0 && (q = To(k + T, u[1][0])), d && V > 0 ? Y = Ro(R + V, u[0][1]) : !d && V < 0 && (Y = To(R + $, u[1][1])), j = Math.max(j, q), U = Math.max(U, Y);
  }
  if (i) {
    if (h) {
      const q = kd(T / P, S, A) * P;
      if (j = Math.max(j, q), s) {
        let Y = 0;
        !f && !d || f && !d && g ? Y = Ro(R + G + T / P, s[1][1]) * P : Y = To(R + G + (f ? F : -F) / P, s[0][1]) * P, j = Math.max(j, Y);
      }
      if (u) {
        let Y = 0;
        !f && !d || f && !d && g ? Y = To(R + T / P, u[1][1]) * P : Y = Ro(R + (f ? F : -F) / P, u[0][1]) * P, j = Math.max(j, Y);
      }
    }
    if (p) {
      const q = kd($ * P, x, E) / P;
      if (U = Math.max(U, q), s) {
        let Y = 0;
        !f && !d || d && !f && g ? Y = Ro(k + $ * P + H, s[1][0]) / P : Y = To(k + (d ? V : -V) * P + H, s[0][0]) / P, U = Math.max(U, Y);
      }
      if (u) {
        let Y = 0;
        !f && !d || d && !f && g ? Y = To(k + $ * P, u[1][0]) / P : Y = Ro(k + (d ? V : -V) * P, u[0][0]) / P, U = Math.max(U, Y);
      }
    }
  }
  V = V + (V < 0 ? U : -U), F = F + (F < 0 ? j : -j), i && (g ? T > $ * P ? V = (kE(f, d) ? -F : F) / P : F = (kE(f, d) ? -V : V) * P : h ? (V = F / P, d = f) : (F = V * P, f = d));
  const z = f ? k + F : k, B = d ? R + V : R;
  return {
    width: N + (f ? -F : F),
    height: D + (d ? -V : V),
    x: a[0] * F * (f ? -1 : 1) + z,
    y: a[1] * V * (d ? -1 : 1) + B
  };
}
const MR = { width: 0, height: 0, x: 0, y: 0 }, TL = {
  ...MR,
  pointerX: 0,
  pointerY: 0,
  aspectRatio: 1
};
function RL(e) {
  return [
    [0, 0],
    [e.measured.width, e.measured.height]
  ];
}
function OL(e, t, n) {
  const r = t.position.x + e.position.x, i = t.position.y + e.position.y, a = e.measured.width ?? 0, s = e.measured.height ?? 0, u = n[0] * a, f = n[1] * s;
  return [
    [r - u, i - f],
    [r + a - u, i + s - f]
  ];
}
function NL({ domNode: e, nodeId: t, getStoreItems: n, onChange: r, onEnd: i }) {
  const a = Wn(e);
  function s({ controlPosition: f, boundaries: d, keepAspectRatio: h, onResizeStart: p, onResize: g, onResizeEnd: y, shouldResize: b }) {
    let x = { ...MR }, E = { ...TL };
    const S = kL(f);
    let A, k = null, R = [], N, D, P;
    const F = UT().on("start", (V) => {
      const { nodeLookup: T, transform: $, snapGrid: H, snapToGrid: G, nodeOrigin: j, paneDomNode: U } = n();
      if (A = T.get(t), !A)
        return;
      k = U?.getBoundingClientRect() ?? null;
      const { xSnapped: z, ySnapped: B } = Wu(V.sourceEvent, {
        transform: $,
        snapGrid: H,
        snapToGrid: G,
        containerBounds: k
      });
      x = {
        width: A.measured.width ?? 0,
        height: A.measured.height ?? 0,
        x: A.position.x ?? 0,
        y: A.position.y ?? 0
      }, E = {
        ...x,
        pointerX: z,
        pointerY: B,
        aspectRatio: x.width / x.height
      }, N = void 0, A.parentId && (A.extent === "parent" || A.expandParent) && (N = T.get(A.parentId), D = N && A.extent === "parent" ? RL(N) : void 0), R = [], P = void 0;
      for (const [q, Y] of T)
        if (Y.parentId === t && (R.push({
          id: q,
          position: { ...Y.position },
          extent: Y.extent
        }), Y.extent === "parent" || Y.expandParent)) {
          const O = OL(Y, A, Y.origin ?? j);
          P ? P = [
            [Math.min(O[0][0], P[0][0]), Math.min(O[0][1], P[0][1])],
            [Math.max(O[1][0], P[1][0]), Math.max(O[1][1], P[1][1])]
          ] : P = O;
        }
      p?.(V, { ...x });
    }).on("drag", (V) => {
      const { transform: T, snapGrid: $, snapToGrid: H, nodeOrigin: G } = n(), j = Wu(V.sourceEvent, {
        transform: T,
        snapGrid: $,
        snapToGrid: H,
        containerBounds: k
      }), U = [];
      if (!A)
        return;
      const { x: z, y: B, width: q, height: Y } = x, O = {}, W = A.origin ?? G, { width: Z, height: I, x: ie, y: fe } = AL(E, S, j, d, h, W, D, P), re = Z !== q, le = I !== Y, he = ie !== z && re, ye = fe !== B && le;
      if (!he && !ye && !re && !le)
        return;
      if ((he || ye || W[0] === 1 || W[1] === 1) && (O.x = he ? ie : x.x, O.y = ye ? fe : x.y, x.x = O.x, x.y = O.y, R.length > 0)) {
        const Le = ie - z, Ie = fe - B;
        for (const ft of R)
          ft.position = {
            x: ft.position.x - Le + W[0] * (Z - q),
            y: ft.position.y - Ie + W[1] * (I - Y)
          }, U.push(ft);
      }
      if ((re || le) && (O.width = re ? Z : x.width, O.height = le ? I : x.height, x.width = O.width, x.height = O.height), N && A.expandParent) {
        const Le = W[0] * (O.width ?? 0);
        O.x && O.x < Le && (x.x = Le, E.x = E.x - (O.x - Le));
        const Ie = W[1] * (O.height ?? 0);
        O.y && O.y < Ie && (x.y = Ie, E.y = E.y - (O.y - Ie));
      }
      const je = CL({
        width: x.width,
        prevWidth: q,
        height: x.height,
        prevHeight: Y,
        affectsX: S.affectsX,
        affectsY: S.affectsY
      }), Oe = { ...x, direction: je };
      b?.(V, Oe) !== !1 && (g?.(V, Oe), r(O, U));
    }).on("end", (V) => {
      y?.(V, { ...x }), i?.({ ...x });
    });
    a.call(F);
  }
  function u() {
    a.on(".drag", null);
  }
  return {
    update: s,
    destroy: u
  };
}
const { useDebugValue: ML } = Qt, { useSyncExternalStoreWithSelector: DL } = kT, PL = (e) => e;
function DR(e, t = PL, n) {
  const r = DL(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return ML(r), r;
}
const AE = (e, t) => {
  const n = CT(e), r = (i, a = t) => DR(n, i, a);
  return Object.assign(r, n), r;
}, zL = (e, t) => e ? AE(e, t) : AE;
function _t(e, t) {
  if (Object.is(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  if (e instanceof Map && t instanceof Map) {
    if (e.size !== t.size) return !1;
    for (const [r, i] of e)
      if (!Object.is(i, t.get(r)))
        return !1;
    return !0;
  }
  if (e instanceof Set && t instanceof Set) {
    if (e.size !== t.size) return !1;
    for (const r of e)
      if (!t.has(r))
        return !1;
    return !0;
  }
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
    return !1;
  for (const r of n)
    if (!Object.prototype.hasOwnProperty.call(t, r) || !Object.is(e[r], t[r]))
      return !1;
  return !0;
}
var D0 = { exports: {} }, un = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var TE;
function jL() {
  if (TE) return un;
  TE = 1;
  var e = Tc();
  function t(f) {
    var d = "https://react.dev/errors/" + f;
    if (1 < arguments.length) {
      d += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var h = 2; h < arguments.length; h++)
        d += "&args[]=" + encodeURIComponent(arguments[h]);
    }
    return "Minified React error #" + f + "; visit " + d + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function n() {
  }
  var r = {
    d: {
      f: n,
      r: function() {
        throw Error(t(522));
      },
      D: n,
      C: n,
      L: n,
      m: n,
      X: n,
      S: n,
      M: n
    },
    p: 0,
    findDOMNode: null
  }, i = Symbol.for("react.portal");
  function a(f, d, h) {
    var p = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: i,
      key: p == null ? null : "" + p,
      children: f,
      containerInfo: d,
      implementation: h
    };
  }
  var s = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function u(f, d) {
    if (f === "font") return "";
    if (typeof d == "string")
      return d === "use-credentials" ? d : "";
  }
  return un.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r, un.createPortal = function(f, d) {
    var h = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!d || d.nodeType !== 1 && d.nodeType !== 9 && d.nodeType !== 11)
      throw Error(t(299));
    return a(f, d, null, h);
  }, un.flushSync = function(f) {
    var d = s.T, h = r.p;
    try {
      if (s.T = null, r.p = 2, f) return f();
    } finally {
      s.T = d, r.p = h, r.d.f();
    }
  }, un.preconnect = function(f, d) {
    typeof f == "string" && (d ? (d = d.crossOrigin, d = typeof d == "string" ? d === "use-credentials" ? d : "" : void 0) : d = null, r.d.C(f, d));
  }, un.prefetchDNS = function(f) {
    typeof f == "string" && r.d.D(f);
  }, un.preinit = function(f, d) {
    if (typeof f == "string" && d && typeof d.as == "string") {
      var h = d.as, p = u(h, d.crossOrigin), g = typeof d.integrity == "string" ? d.integrity : void 0, y = typeof d.fetchPriority == "string" ? d.fetchPriority : void 0;
      h === "style" ? r.d.S(
        f,
        typeof d.precedence == "string" ? d.precedence : void 0,
        {
          crossOrigin: p,
          integrity: g,
          fetchPriority: y
        }
      ) : h === "script" && r.d.X(f, {
        crossOrigin: p,
        integrity: g,
        fetchPriority: y,
        nonce: typeof d.nonce == "string" ? d.nonce : void 0
      });
    }
  }, un.preinitModule = function(f, d) {
    if (typeof f == "string")
      if (typeof d == "object" && d !== null) {
        if (d.as == null || d.as === "script") {
          var h = u(
            d.as,
            d.crossOrigin
          );
          r.d.M(f, {
            crossOrigin: h,
            integrity: typeof d.integrity == "string" ? d.integrity : void 0,
            nonce: typeof d.nonce == "string" ? d.nonce : void 0
          });
        }
      } else d == null && r.d.M(f);
  }, un.preload = function(f, d) {
    if (typeof f == "string" && typeof d == "object" && d !== null && typeof d.as == "string") {
      var h = d.as, p = u(h, d.crossOrigin);
      r.d.L(f, h, {
        crossOrigin: p,
        integrity: typeof d.integrity == "string" ? d.integrity : void 0,
        nonce: typeof d.nonce == "string" ? d.nonce : void 0,
        type: typeof d.type == "string" ? d.type : void 0,
        fetchPriority: typeof d.fetchPriority == "string" ? d.fetchPriority : void 0,
        referrerPolicy: typeof d.referrerPolicy == "string" ? d.referrerPolicy : void 0,
        imageSrcSet: typeof d.imageSrcSet == "string" ? d.imageSrcSet : void 0,
        imageSizes: typeof d.imageSizes == "string" ? d.imageSizes : void 0,
        media: typeof d.media == "string" ? d.media : void 0
      });
    }
  }, un.preloadModule = function(f, d) {
    if (typeof f == "string")
      if (d) {
        var h = u(d.as, d.crossOrigin);
        r.d.m(f, {
          as: typeof d.as == "string" && d.as !== "script" ? d.as : void 0,
          crossOrigin: h,
          integrity: typeof d.integrity == "string" ? d.integrity : void 0
        });
      } else r.d.m(f);
  }, un.requestFormReset = function(f) {
    r.d.r(f);
  }, un.unstable_batchedUpdates = function(f, d) {
    return f(d);
  }, un.useFormState = function(f, d, h) {
    return s.H.useFormState(f, d, h);
  }, un.useFormStatus = function() {
    return s.H.useHostTransitionStatus();
  }, un.version = "19.1.0", un;
}
var RE;
function PR() {
  if (RE) return D0.exports;
  RE = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), D0.exports = jL(), D0.exports;
}
var Pc = PR();
const IL = /* @__PURE__ */ pl(Pc), dp = C.createContext(null), LL = dp.Provider, zR = oi.error001();
function We(e, t) {
  const n = C.useContext(dp);
  if (n === null)
    throw new Error(zR);
  return DR(n, e, t);
}
function Ct() {
  const e = C.useContext(dp);
  if (e === null)
    throw new Error(zR);
  return C.useMemo(() => ({
    getState: e.getState,
    setState: e.setState,
    subscribe: e.subscribe
  }), [e]);
}
const OE = { display: "none" }, FL = {
  position: "absolute",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0px, 0px, 0px, 0px)",
  clipPath: "inset(100%)"
}, jR = "react-flow__node-desc", IR = "react-flow__edge-desc", BL = "react-flow__aria-live", $L = (e) => e.ariaLiveMessage;
function HL({ rfId: e }) {
  const t = We($L);
  return _.jsx("div", { id: `${BL}-${e}`, "aria-live": "assertive", "aria-atomic": "true", style: FL, children: t });
}
function VL({ rfId: e, disableKeyboardA11y: t }) {
  return _.jsxs(_.Fragment, { children: [_.jsxs("div", { id: `${jR}-${e}`, style: OE, children: ["Press enter or space to select a node.", !t && "You can then use the arrow keys to move the node around.", " Press delete to remove it and escape to cancel.", " "] }), _.jsx("div", { id: `${IR}-${e}`, style: OE, children: "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel." }), !t && _.jsx(HL, { rfId: e })] });
}
const UL = (e) => e.userSelectionActive ? "none" : "all", hp = C.forwardRef(({ position: e = "top-left", children: t, className: n, style: r, ...i }, a) => {
  const s = We(UL), u = `${e}`.split("-");
  return _.jsx("div", { className: qt(["react-flow__panel", n, ...u]), style: { ...r, pointerEvents: s }, ref: a, ...i, children: t });
});
hp.displayName = "Panel";
function qL({ proOptions: e, position: t = "bottom-right" }) {
  return e?.hideAttribution ? null : _.jsx(hp, { position: t, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev", children: _.jsx("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution", children: "React Flow" }) });
}
const YL = (e) => {
  const t = [], n = [];
  for (const [, r] of e.nodeLookup)
    r.selected && t.push(r.internals.userNode);
  for (const [, r] of e.edgeLookup)
    r.selected && n.push(r);
  return { selectedNodes: t, selectedEdges: n };
}, Ad = (e) => e.id;
function GL(e, t) {
  return _t(e.selectedNodes.map(Ad), t.selectedNodes.map(Ad)) && _t(e.selectedEdges.map(Ad), t.selectedEdges.map(Ad));
}
function XL({ onSelectionChange: e }) {
  const t = Ct(), { selectedNodes: n, selectedEdges: r } = We(YL, GL);
  return C.useEffect(() => {
    const i = { nodes: n, edges: r };
    e?.(i), t.getState().onSelectionChangeHandlers.forEach((a) => a(i));
  }, [n, r, e]), null;
}
const WL = (e) => !!e.onSelectionChangeHandlers;
function KL({ onSelectionChange: e }) {
  const t = We(WL);
  return e || t ? _.jsx(XL, { onSelectionChange: e }) : null;
}
const LR = [0, 0], ZL = { x: 0, y: 0, zoom: 1 }, QL = [
  "nodes",
  "edges",
  "defaultNodes",
  "defaultEdges",
  "onConnect",
  "onConnectStart",
  "onConnectEnd",
  "onClickConnectStart",
  "onClickConnectEnd",
  "nodesDraggable",
  "nodesConnectable",
  "nodesFocusable",
  "edgesFocusable",
  "edgesReconnectable",
  "elevateNodesOnSelect",
  "elevateEdgesOnSelect",
  "minZoom",
  "maxZoom",
  "nodeExtent",
  "onNodesChange",
  "onEdgesChange",
  "elementsSelectable",
  "connectionMode",
  "snapGrid",
  "snapToGrid",
  "translateExtent",
  "connectOnClick",
  "defaultEdgeOptions",
  "fitView",
  "fitViewOptions",
  "onNodesDelete",
  "onEdgesDelete",
  "onDelete",
  "onNodeDrag",
  "onNodeDragStart",
  "onNodeDragStop",
  "onSelectionDrag",
  "onSelectionDragStart",
  "onSelectionDragStop",
  "onMoveStart",
  "onMove",
  "onMoveEnd",
  "noPanClassName",
  "nodeOrigin",
  "autoPanOnConnect",
  "autoPanOnNodeDrag",
  "onError",
  "connectionRadius",
  "isValidConnection",
  "selectNodesOnDrag",
  "nodeDragThreshold",
  "onBeforeDelete",
  "debug",
  "autoPanSpeed",
  "paneClickDistance"
], NE = [...QL, "rfId"], JL = (e) => ({
  setNodes: e.setNodes,
  setEdges: e.setEdges,
  setMinZoom: e.setMinZoom,
  setMaxZoom: e.setMaxZoom,
  setTranslateExtent: e.setTranslateExtent,
  setNodeExtent: e.setNodeExtent,
  reset: e.reset,
  setDefaultNodesAndEdges: e.setDefaultNodesAndEdges,
  setPaneClickDistance: e.setPaneClickDistance
}), ME = {
  /*
   * these are values that are also passed directly to other components
   * than the StoreUpdater. We can reduce the number of setStore calls
   * by setting the same values here as prev fields.
   */
  translateExtent: lc,
  nodeOrigin: LR,
  minZoom: 0.5,
  maxZoom: 2,
  elementsSelectable: !0,
  noPanClassName: "nopan",
  rfId: "1",
  paneClickDistance: 0
};
function e8(e) {
  const { setNodes: t, setEdges: n, setMinZoom: r, setMaxZoom: i, setTranslateExtent: a, setNodeExtent: s, reset: u, setDefaultNodesAndEdges: f, setPaneClickDistance: d } = We(JL, _t), h = Ct();
  C.useEffect(() => (f(e.defaultNodes, e.defaultEdges), () => {
    p.current = ME, u();
  }), []);
  const p = C.useRef(ME);
  return C.useEffect(
    () => {
      for (const g of NE) {
        const y = e[g], b = p.current[g];
        y !== b && (typeof e[g] > "u" || (g === "nodes" ? t(y) : g === "edges" ? n(y) : g === "minZoom" ? r(y) : g === "maxZoom" ? i(y) : g === "translateExtent" ? a(y) : g === "nodeExtent" ? s(y) : g === "paneClickDistance" ? d(y) : g === "fitView" ? h.setState({ fitViewQueued: y }) : g === "fitViewOptions" ? h.setState({ fitViewOptions: y }) : h.setState({ [g]: y })));
      }
      p.current = e;
    },
    // Only re-run the effect if one of the fields we track changes
    NE.map((g) => e[g])
  ), null;
}
function DE() {
  return typeof window > "u" || !window.matchMedia ? null : window.matchMedia("(prefers-color-scheme: dark)");
}
function t8(e) {
  const [t, n] = C.useState(e === "system" ? null : e);
  return C.useEffect(() => {
    if (e !== "system") {
      n(e);
      return;
    }
    const r = DE(), i = () => n(r?.matches ? "dark" : "light");
    return i(), r?.addEventListener("change", i), () => {
      r?.removeEventListener("change", i);
    };
  }, [e]), t !== null ? t : DE()?.matches ? "dark" : "light";
}
const PE = typeof document < "u" ? document : null;
function al(e = null, t = { target: PE, actInsideInputWithModifier: !0 }) {
  const [n, r] = C.useState(!1), i = C.useRef(!1), a = C.useRef(/* @__PURE__ */ new Set([])), [s, u] = C.useMemo(() => {
    if (e !== null) {
      const d = (Array.isArray(e) ? e : [e]).filter((p) => typeof p == "string").map((p) => p.replace("+", `
`).replace(`

`, `
+`).split(`
`)), h = d.reduce((p, g) => p.concat(...g), []);
      return [d, h];
    }
    return [[], []];
  }, [e]);
  return C.useEffect(() => {
    const f = t?.target || PE;
    if (e !== null) {
      const d = (g) => {
        if (i.current = g.ctrlKey || g.metaKey || g.shiftKey || g.altKey, (!i.current || i.current && !t.actInsideInputWithModifier) && vR(g))
          return !1;
        const b = jE(g.code, u);
        if (a.current.add(g[b]), zE(s, a.current, !1)) {
          const x = g.composedPath?.()?.[0] || g.target, E = x?.nodeName === "BUTTON" || x?.nodeName === "A";
          t.preventDefault !== !1 && (i.current || !E) && g.preventDefault(), r(!0);
        }
      }, h = (g) => {
        const y = jE(g.code, u);
        zE(s, a.current, !0) ? (r(!1), a.current.clear()) : a.current.delete(g[y]), g.key === "Meta" && a.current.clear(), i.current = !1;
      }, p = () => {
        a.current.clear(), r(!1);
      };
      return f?.addEventListener("keydown", d), f?.addEventListener("keyup", h), window.addEventListener("blur", p), window.addEventListener("contextmenu", p), () => {
        f?.removeEventListener("keydown", d), f?.removeEventListener("keyup", h), window.removeEventListener("blur", p), window.removeEventListener("contextmenu", p);
      };
    }
  }, [e, r]), n;
}
function zE(e, t, n) {
  return e.filter((r) => n || r.length === t.size).some((r) => r.every((i) => t.has(i)));
}
function jE(e, t) {
  return t.includes(e) ? "code" : "key";
}
const n8 = () => {
  const e = Ct();
  return C.useMemo(() => ({
    zoomIn: (t) => {
      const { panZoom: n } = e.getState();
      return n ? n.scaleBy(1.2, { duration: t?.duration }) : Promise.resolve(!1);
    },
    zoomOut: (t) => {
      const { panZoom: n } = e.getState();
      return n ? n.scaleBy(1 / 1.2, { duration: t?.duration }) : Promise.resolve(!1);
    },
    zoomTo: (t, n) => {
      const { panZoom: r } = e.getState();
      return r ? r.scaleTo(t, { duration: n?.duration }) : Promise.resolve(!1);
    },
    getZoom: () => e.getState().transform[2],
    setViewport: async (t, n) => {
      const { transform: [r, i, a], panZoom: s } = e.getState();
      return s ? (await s.setViewport({
        x: t.x ?? r,
        y: t.y ?? i,
        zoom: t.zoom ?? a
      }, { duration: n?.duration }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    getViewport: () => {
      const [t, n, r] = e.getState().transform;
      return { x: t, y: n, zoom: r };
    },
    setCenter: async (t, n, r) => {
      const { width: i, height: a, maxZoom: s, panZoom: u } = e.getState(), f = typeof r?.zoom < "u" ? r.zoom : s, d = i / 2 - t * f, h = a / 2 - n * f;
      return u ? (await u.setViewport({
        x: d,
        y: h,
        zoom: f
      }, { duration: r?.duration }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    fitBounds: async (t, n) => {
      const { width: r, height: i, minZoom: a, maxZoom: s, panZoom: u } = e.getState(), f = vb(t, r, i, a, s, n?.padding ?? 0.1);
      return u ? (await u.setViewport(f, { duration: n?.duration }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    screenToFlowPosition: (t, n = {}) => {
      const { transform: r, snapGrid: i, snapToGrid: a, domNode: s } = e.getState();
      if (!s)
        return t;
      const { x: u, y: f } = s.getBoundingClientRect(), d = {
        x: t.x - u,
        y: t.y - f
      }, h = n.snapGrid ?? i, p = n.snapToGrid ?? a;
      return Dc(d, r, p, h);
    },
    flowToScreenPosition: (t) => {
      const { transform: n, domNode: r } = e.getState();
      if (!r)
        return t;
      const { x: i, y: a } = r.getBoundingClientRect(), s = Ch(t, n);
      return {
        x: s.x + i,
        y: s.y + a
      };
    }
  }), []);
};
function FR(e, t) {
  const n = [], r = /* @__PURE__ */ new Map(), i = [];
  for (const a of e)
    if (a.type === "add") {
      i.push(a);
      continue;
    } else if (a.type === "remove" || a.type === "replace")
      r.set(a.id, [a]);
    else {
      const s = r.get(a.id);
      s ? s.push(a) : r.set(a.id, [a]);
    }
  for (const a of t) {
    const s = r.get(a.id);
    if (!s) {
      n.push(a);
      continue;
    }
    if (s[0].type === "remove")
      continue;
    if (s[0].type === "replace") {
      n.push({ ...s[0].item });
      continue;
    }
    const u = { ...a };
    for (const f of s)
      r8(f, u);
    n.push(u);
  }
  return i.length && i.forEach((a) => {
    a.index !== void 0 ? n.splice(a.index, 0, { ...a.item }) : n.push({ ...a.item });
  }), n;
}
function r8(e, t) {
  switch (e.type) {
    case "select": {
      t.selected = e.selected;
      break;
    }
    case "position": {
      typeof e.position < "u" && (t.position = e.position), typeof e.dragging < "u" && (t.dragging = e.dragging);
      break;
    }
    case "dimensions": {
      typeof e.dimensions < "u" && (t.measured ?? (t.measured = {}), t.measured.width = e.dimensions.width, t.measured.height = e.dimensions.height, e.setAttributes && (t.width = e.dimensions.width, t.height = e.dimensions.height)), typeof e.resizing == "boolean" && (t.resizing = e.resizing);
      break;
    }
  }
}
function BR(e, t) {
  return FR(e, t);
}
function $R(e, t) {
  return FR(e, t);
}
function ya(e, t) {
  return {
    id: e,
    type: "select",
    selected: t
  };
}
function Hs(e, t = /* @__PURE__ */ new Set(), n = !1) {
  const r = [];
  for (const [i, a] of e) {
    const s = t.has(i);
    !(a.selected === void 0 && !s) && a.selected !== s && (n && (a.selected = s), r.push(ya(a.id, s)));
  }
  return r;
}
function IE({ items: e = [], lookup: t }) {
  const n = [], r = new Map(e.map((i) => [i.id, i]));
  for (const [i, a] of e.entries()) {
    const s = t.get(a.id), u = s?.internals?.userNode ?? s;
    u !== void 0 && u !== a && n.push({ id: a.id, item: a, type: "replace" }), u === void 0 && n.push({ item: a, type: "add", index: i });
  }
  for (const [i] of t)
    r.get(i) === void 0 && n.push({ id: i, type: "remove" });
  return n;
}
function LE(e) {
  return {
    id: e.id,
    type: "remove"
  };
}
const FE = (e) => II(e), i8 = (e) => uR(e);
function HR(e) {
  return C.forwardRef(e);
}
const o8 = typeof window < "u" ? C.useLayoutEffect : C.useEffect;
function BE(e) {
  const [t, n] = C.useState(BigInt(0)), [r] = C.useState(() => a8(() => n((i) => i + BigInt(1))));
  return o8(() => {
    const i = r.get();
    i.length && (e(i), r.reset());
  }, [t]), r;
}
function a8(e) {
  let t = [];
  return {
    get: () => t,
    reset: () => {
      t = [];
    },
    push: (n) => {
      t.push(n), e();
    }
  };
}
const VR = C.createContext(null);
function s8({ children: e }) {
  const t = Ct(), n = C.useCallback((u) => {
    const { nodes: f = [], setNodes: d, hasDefaultNodes: h, onNodesChange: p, nodeLookup: g, fitViewQueued: y } = t.getState();
    let b = f;
    for (const x of u)
      b = typeof x == "function" ? x(b) : x;
    if (h)
      d(b);
    else {
      const x = IE({
        items: b,
        lookup: g
      });
      x.length > 0 ? p?.(x) : y && window.requestAnimationFrame(() => {
        const { fitViewQueued: E, nodes: S, setNodes: A } = t.getState();
        E && A(S);
      });
    }
  }, []), r = BE(n), i = C.useCallback((u) => {
    const { edges: f = [], setEdges: d, hasDefaultEdges: h, onEdgesChange: p, edgeLookup: g } = t.getState();
    let y = f;
    for (const b of u)
      y = typeof b == "function" ? b(y) : b;
    h ? d(y) : p && p(IE({
      items: y,
      lookup: g
    }));
  }, []), a = BE(i), s = C.useMemo(() => ({ nodeQueue: r, edgeQueue: a }), []);
  return _.jsx(VR.Provider, { value: s, children: e });
}
function l8() {
  const e = C.useContext(VR);
  if (!e)
    throw new Error("useBatchContext must be used within a BatchProvider");
  return e;
}
const u8 = (e) => !!e.panZoom;
function zc() {
  const e = n8(), t = Ct(), n = l8(), r = We(u8), i = C.useMemo(() => {
    const a = (p) => t.getState().nodeLookup.get(p), s = (p) => {
      n.nodeQueue.push(p);
    }, u = (p) => {
      n.edgeQueue.push(p);
    }, f = (p) => {
      const { nodeLookup: g, nodeOrigin: y } = t.getState(), b = FE(p) ? p : g.get(p.id), x = b.parentId ? gR(b.position, b.measured, b.parentId, g, y) : b.position, E = {
        ...b,
        position: x,
        width: b.measured?.width ?? b.width,
        height: b.measured?.height ?? b.height
      };
      return il(E);
    }, d = (p, g, y = { replace: !1 }) => {
      s((b) => b.map((x) => {
        if (x.id === p) {
          const E = typeof g == "function" ? g(x) : g;
          return y.replace && FE(E) ? E : { ...x, ...E };
        }
        return x;
      }));
    }, h = (p, g, y = { replace: !1 }) => {
      u((b) => b.map((x) => {
        if (x.id === p) {
          const E = typeof g == "function" ? g(x) : g;
          return y.replace && i8(E) ? E : { ...x, ...E };
        }
        return x;
      }));
    };
    return {
      getNodes: () => t.getState().nodes.map((p) => ({ ...p })),
      getNode: (p) => a(p)?.internals.userNode,
      getInternalNode: a,
      getEdges: () => {
        const { edges: p = [] } = t.getState();
        return p.map((g) => ({ ...g }));
      },
      getEdge: (p) => t.getState().edgeLookup.get(p),
      setNodes: s,
      setEdges: u,
      addNodes: (p) => {
        const g = Array.isArray(p) ? p : [p];
        n.nodeQueue.push((y) => [...y, ...g]);
      },
      addEdges: (p) => {
        const g = Array.isArray(p) ? p : [p];
        n.edgeQueue.push((y) => [...y, ...g]);
      },
      toObject: () => {
        const { nodes: p = [], edges: g = [], transform: y } = t.getState(), [b, x, E] = y;
        return {
          nodes: p.map((S) => ({ ...S })),
          edges: g.map((S) => ({ ...S })),
          viewport: {
            x: b,
            y: x,
            zoom: E
          }
        };
      },
      deleteElements: async ({ nodes: p = [], edges: g = [] }) => {
        const { nodes: y, edges: b, onNodesDelete: x, onEdgesDelete: E, triggerNodeChanges: S, triggerEdgeChanges: A, onDelete: k, onBeforeDelete: R } = t.getState(), { nodes: N, edges: D } = await HI({
          nodesToRemove: p,
          edgesToRemove: g,
          nodes: y,
          edges: b,
          onBeforeDelete: R
        }), P = D.length > 0, F = N.length > 0;
        if (P) {
          const V = D.map(LE);
          E?.(D), A(V);
        }
        if (F) {
          const V = N.map(LE);
          x?.(N), S(V);
        }
        return (F || P) && k?.({ nodes: N, edges: D }), { deletedNodes: N, deletedEdges: D };
      },
      getIntersectingNodes: (p, g = !0, y) => {
        const b = mE(p), x = b ? p : f(p), E = y !== void 0;
        return x ? (y || t.getState().nodes).filter((S) => {
          const A = t.getState().nodeLookup.get(S.id);
          if (A && !b && (S.id === p.id || !A.internals.positionAbsolute))
            return !1;
          const k = il(E ? S : A), R = cc(k, x);
          return g && R > 0 || R >= x.width * x.height;
        }) : [];
      },
      isNodeIntersecting: (p, g, y = !0) => {
        const x = mE(p) ? p : f(p);
        if (!x)
          return !1;
        const E = cc(x, g);
        return y && E > 0 || E >= x.width * x.height;
      },
      updateNode: d,
      updateNodeData: (p, g, y = { replace: !1 }) => {
        d(p, (b) => {
          const x = typeof g == "function" ? g(b) : g;
          return y.replace ? { ...b, data: x } : { ...b, data: { ...b.data, ...x } };
        }, y);
      },
      updateEdge: h,
      updateEdgeData: (p, g, y = { replace: !1 }) => {
        h(p, (b) => {
          const x = typeof g == "function" ? g(b) : g;
          return y.replace ? { ...b, data: x } : { ...b, data: { ...b.data, ...x } };
        }, y);
      },
      getNodesBounds: (p) => {
        const { nodeLookup: g, nodeOrigin: y } = t.getState();
        return LI(p, { nodeLookup: g, nodeOrigin: y });
      },
      getHandleConnections: ({ type: p, id: g, nodeId: y }) => Array.from(t.getState().connectionLookup.get(`${y}-${p}${g ? `-${g}` : ""}`)?.values() ?? []),
      getNodeConnections: ({ type: p, handleId: g, nodeId: y }) => Array.from(t.getState().connectionLookup.get(`${y}${p ? g ? `-${p}-${g}` : `-${p}` : ""}`)?.values() ?? []),
      fitView: async (p) => {
        const g = t.getState().fitViewResolver ?? Promise.withResolvers();
        return t.setState({ fitViewQueued: !0, fitViewOptions: p, fitViewResolver: g }), n.nodeQueue.push((y) => [...y]), g.promise;
      }
    };
  }, []);
  return C.useMemo(() => ({
    ...i,
    ...e,
    viewportInitialized: r
  }), [r]);
}
const $E = (e) => e.selected, c8 = { actInsideInputWithModifier: !1 }, f8 = typeof window < "u" ? window : void 0;
function d8({ deleteKeyCode: e, multiSelectionKeyCode: t }) {
  const n = Ct(), { deleteElements: r } = zc(), i = al(e, c8), a = al(t, { target: f8 });
  C.useEffect(() => {
    if (i) {
      const { edges: s, nodes: u } = n.getState();
      r({ nodes: u.filter($E), edges: s.filter($E) }), n.setState({ nodesSelectionActive: !1 });
    }
  }, [i]), C.useEffect(() => {
    n.setState({ multiSelectionActive: a });
  }, [a]);
}
function h8(e) {
  const t = Ct();
  C.useEffect(() => {
    const n = () => {
      if (!e.current)
        return !1;
      const r = bb(e.current);
      (r.height === 0 || r.width === 0) && t.getState().onError?.("004", oi.error004()), t.setState({ width: r.width || 500, height: r.height || 500 });
    };
    if (e.current) {
      n(), window.addEventListener("resize", n);
      const r = new ResizeObserver(() => n());
      return r.observe(e.current), () => {
        window.removeEventListener("resize", n), r && e.current && r.unobserve(e.current);
      };
    }
  }, []);
}
const pp = {
  position: "absolute",
  width: "100%",
  height: "100%",
  top: 0,
  left: 0
}, p8 = (e) => ({
  userSelectionActive: e.userSelectionActive,
  lib: e.lib
});
function m8({ onPaneContextMenu: e, zoomOnScroll: t = !0, zoomOnPinch: n = !0, panOnScroll: r = !1, panOnScrollSpeed: i = 0.5, panOnScrollMode: a = ka.Free, zoomOnDoubleClick: s = !0, panOnDrag: u = !0, defaultViewport: f, translateExtent: d, minZoom: h, maxZoom: p, zoomActivationKeyCode: g, preventScrolling: y = !0, children: b, noWheelClassName: x, noPanClassName: E, onViewportChange: S, isControlledViewport: A, paneClickDistance: k }) {
  const R = Ct(), N = C.useRef(null), { userSelectionActive: D, lib: P } = We(p8, _t), F = al(g), V = C.useRef();
  h8(N);
  const T = C.useCallback(($) => {
    S?.({ x: $[0], y: $[1], zoom: $[2] }), A || R.setState({ transform: $ });
  }, [S, A]);
  return C.useEffect(() => {
    if (N.current) {
      V.current = EL({
        domNode: N.current,
        minZoom: h,
        maxZoom: p,
        translateExtent: d,
        viewport: f,
        paneClickDistance: k,
        onDraggingChange: (j) => R.setState({ paneDragging: j }),
        onPanZoomStart: (j, U) => {
          const { onViewportChangeStart: z, onMoveStart: B } = R.getState();
          B?.(j, U), z?.(U);
        },
        onPanZoom: (j, U) => {
          const { onViewportChange: z, onMove: B } = R.getState();
          B?.(j, U), z?.(U);
        },
        onPanZoomEnd: (j, U) => {
          const { onViewportChangeEnd: z, onMoveEnd: B } = R.getState();
          B?.(j, U), z?.(U);
        }
      });
      const { x: $, y: H, zoom: G } = V.current.getViewport();
      return R.setState({
        panZoom: V.current,
        transform: [$, H, G],
        domNode: N.current.closest(".react-flow")
      }), () => {
        V.current?.destroy();
      };
    }
  }, []), C.useEffect(() => {
    V.current?.update({
      onPaneContextMenu: e,
      zoomOnScroll: t,
      zoomOnPinch: n,
      panOnScroll: r,
      panOnScrollSpeed: i,
      panOnScrollMode: a,
      zoomOnDoubleClick: s,
      panOnDrag: u,
      zoomActivationKeyPressed: F,
      preventScrolling: y,
      noPanClassName: E,
      userSelectionActive: D,
      noWheelClassName: x,
      lib: P,
      onTransformChange: T
    });
  }, [
    e,
    t,
    n,
    r,
    i,
    a,
    s,
    u,
    F,
    y,
    E,
    D,
    x,
    P,
    T
  ]), _.jsx("div", { className: "react-flow__renderer", ref: N, style: pp, children: b });
}
const g8 = (e) => ({
  userSelectionActive: e.userSelectionActive,
  userSelectionRect: e.userSelectionRect
});
function y8() {
  const { userSelectionActive: e, userSelectionRect: t } = We(g8, _t);
  return e && t ? _.jsx("div", { className: "react-flow__selection react-flow__container", style: {
    width: t.width,
    height: t.height,
    transform: `translate(${t.x}px, ${t.y}px)`
  } }) : null;
}
const P0 = (e, t) => (n) => {
  n.target === t.current && e?.(n);
}, v8 = (e) => ({
  userSelectionActive: e.userSelectionActive,
  elementsSelectable: e.elementsSelectable,
  connectionInProgress: e.connection.inProgress,
  dragging: e.paneDragging
});
function b8({ isSelecting: e, selectionKeyPressed: t, selectionMode: n = uc.Full, panOnDrag: r, selectionOnDrag: i, onSelectionStart: a, onSelectionEnd: s, onPaneClick: u, onPaneContextMenu: f, onPaneScroll: d, onPaneMouseEnter: h, onPaneMouseMove: p, onPaneMouseLeave: g, children: y }) {
  const b = Ct(), { userSelectionActive: x, elementsSelectable: E, dragging: S, connectionInProgress: A } = We(v8, _t), k = E && (e || x), R = C.useRef(null), N = C.useRef(), D = C.useRef(/* @__PURE__ */ new Set()), P = C.useRef(/* @__PURE__ */ new Set()), F = C.useRef(!1), V = C.useRef(!1), T = (B) => {
    if (F.current || A) {
      F.current = !1;
      return;
    }
    u?.(B), b.getState().resetSelectedElements(), b.setState({ nodesSelectionActive: !1 });
  }, $ = (B) => {
    if (Array.isArray(r) && r?.includes(2)) {
      B.preventDefault();
      return;
    }
    f?.(B);
  }, H = d ? (B) => d(B) : void 0, G = (B) => {
    const { resetSelectedElements: q, domNode: Y } = b.getState();
    if (N.current = Y?.getBoundingClientRect(), !E || !e || B.button !== 0 || B.target !== R.current || !N.current)
      return;
    B.target?.setPointerCapture?.(B.pointerId), V.current = !0, F.current = !1;
    const { x: O, y: W } = Ii(B.nativeEvent, N.current);
    q(), b.setState({
      userSelectionRect: {
        width: 0,
        height: 0,
        startX: O,
        startY: W,
        x: O,
        y: W
      }
    }), a?.(B);
  }, j = (B) => {
    const { userSelectionRect: q, transform: Y, nodeLookup: O, edgeLookup: W, connectionLookup: Z, triggerNodeChanges: I, triggerEdgeChanges: ie, defaultEdgeOptions: fe } = b.getState();
    if (!N.current || !q)
      return;
    F.current = !0;
    const { x: re, y: le } = Ii(B.nativeEvent, N.current), { startX: he, startY: ye } = q, je = {
      startX: he,
      startY: ye,
      x: re < he ? re : he,
      y: le < ye ? le : ye,
      width: Math.abs(re - he),
      height: Math.abs(le - ye)
    }, Oe = D.current, be = P.current;
    D.current = new Set(cR(O, je, Y, n === uc.Partial, !0).map((Ie) => Ie.id)), P.current = /* @__PURE__ */ new Set();
    const Le = fe?.selectable ?? !0;
    for (const Ie of D.current) {
      const ft = Z.get(Ie);
      if (ft)
        for (const { edgeId: Jt } of ft.values()) {
          const bt = W.get(Jt);
          bt && (bt.selectable ?? Le) && P.current.add(Jt);
        }
    }
    if (!gE(Oe, D.current)) {
      const Ie = Hs(O, D.current, !0);
      I(Ie);
    }
    if (!gE(be, P.current)) {
      const Ie = Hs(W, P.current);
      ie(Ie);
    }
    b.setState({
      userSelectionRect: je,
      userSelectionActive: !0,
      nodesSelectionActive: !1
    });
  }, U = (B) => {
    if (B.button !== 0 || !V.current)
      return;
    B.target?.releasePointerCapture?.(B.pointerId);
    const { userSelectionRect: q } = b.getState();
    !x && q && B.target === R.current && T?.(B), b.setState({
      userSelectionActive: !1,
      userSelectionRect: null,
      nodesSelectionActive: D.current.size > 0
    }), s?.(B), (t || i) && (F.current = !1), V.current = !1;
  }, z = r === !0 || Array.isArray(r) && r.includes(0);
  return _.jsxs("div", { className: qt(["react-flow__pane", { draggable: z, dragging: S, selection: e }]), onClick: k ? void 0 : P0(T, R), onContextMenu: P0($, R), onWheel: P0(H, R), onPointerEnter: k ? void 0 : h, onPointerDown: k ? G : p, onPointerMove: k ? j : p, onPointerUp: k ? U : void 0, onPointerLeave: g, ref: R, style: pp, children: [y, _.jsx(y8, {})] });
}
function Jy({ id: e, store: t, unselect: n = !1, nodeRef: r }) {
  const { addSelectedNodes: i, unselectNodesAndEdges: a, multiSelectionActive: s, nodeLookup: u, onError: f } = t.getState(), d = u.get(e);
  if (!d) {
    f?.("012", oi.error012(e));
    return;
  }
  t.setState({ nodesSelectionActive: !1 }), d.selected ? (n || d.selected && s) && (a({ nodes: [d], edges: [] }), requestAnimationFrame(() => r?.current?.blur())) : i([e]);
}
function UR({ nodeRef: e, disabled: t = !1, noDragClassName: n, handleSelector: r, nodeId: i, isSelectable: a, nodeClickDistance: s }) {
  const u = Ct(), [f, d] = C.useState(!1), h = C.useRef();
  return C.useEffect(() => {
    h.current = cL({
      getStoreItems: () => u.getState(),
      onNodeMouseDown: (p) => {
        Jy({
          id: p,
          store: u,
          nodeRef: e
        });
      },
      onDragStart: () => {
        d(!0);
      },
      onDragStop: () => {
        d(!1);
      }
    });
  }, []), C.useEffect(() => {
    if (t)
      h.current?.destroy();
    else if (e.current)
      return h.current?.update({
        noDragClassName: n,
        handleSelector: r,
        domNode: e.current,
        isSelectable: a,
        nodeId: i,
        nodeClickDistance: s
      }), () => {
        h.current?.destroy();
      };
  }, [n, r, t, a, e, i]), f;
}
const x8 = (e) => (t) => t.selected && (t.draggable || e && typeof t.draggable > "u");
function qR() {
  const e = Ct();
  return C.useCallback((n) => {
    const { nodeExtent: r, snapToGrid: i, snapGrid: a, nodesDraggable: s, onError: u, updateNodePositions: f, nodeLookup: d, nodeOrigin: h } = e.getState(), p = /* @__PURE__ */ new Map(), g = x8(s), y = i ? a[0] : 5, b = i ? a[1] : 5, x = n.direction.x * y * n.factor, E = n.direction.y * b * n.factor;
    for (const [, S] of d) {
      if (!g(S))
        continue;
      let A = {
        x: S.internals.positionAbsolute.x + x,
        y: S.internals.positionAbsolute.y + E
      };
      i && (A = cp(A, a));
      const { position: k, positionAbsolute: R } = fR({
        nodeId: S.id,
        nextPosition: A,
        nodeLookup: d,
        nodeExtent: r,
        nodeOrigin: h,
        onError: u
      });
      S.position = k, S.internals.positionAbsolute = R, p.set(S.id, S);
    }
    f(p);
  }, []);
}
const Cb = C.createContext(null), w8 = Cb.Provider;
Cb.Consumer;
const YR = () => C.useContext(Cb), S8 = (e) => ({
  connectOnClick: e.connectOnClick,
  noPanClassName: e.noPanClassName,
  rfId: e.rfId
}), _8 = (e, t, n) => (r) => {
  const { connectionClickStartHandle: i, connectionMode: a, connection: s } = r, { fromHandle: u, toHandle: f, isValid: d } = s, h = f?.nodeId === e && f?.id === t && f?.type === n;
  return {
    connectingFrom: u?.nodeId === e && u?.id === t && u?.type === n,
    connectingTo: h,
    clickConnecting: i?.nodeId === e && i?.id === t && i?.type === n,
    isPossibleEndHandle: a === nl.Strict ? u?.type !== n : e !== u?.nodeId || t !== u?.id,
    connectionInProcess: !!u,
    clickConnectionInProcess: !!i,
    valid: h && d
  };
};
function E8({ type: e = "source", position: t = _e.Top, isValidConnection: n, isConnectable: r = !0, isConnectableStart: i = !0, isConnectableEnd: a = !0, id: s, onConnect: u, children: f, className: d, onMouseDown: h, onTouchStart: p, ...g }, y) {
  const b = s || null, x = e === "target", E = Ct(), S = YR(), { connectOnClick: A, noPanClassName: k, rfId: R } = We(S8, _t), { connectingFrom: N, connectingTo: D, clickConnecting: P, isPossibleEndHandle: F, connectionInProcess: V, clickConnectionInProcess: T, valid: $ } = We(_8(S, b, e), _t);
  S || E.getState().onError?.("010", oi.error010());
  const H = (U) => {
    const { defaultEdgeOptions: z, onConnect: B, hasDefaultEdges: q } = E.getState(), Y = {
      ...z,
      ...U
    };
    if (q) {
      const { edges: O, setEdges: W } = E.getState();
      W(ZI(Y, O));
    }
    B?.(Y), u?.(Y);
  }, G = (U) => {
    if (!S)
      return;
    const z = bR(U.nativeEvent);
    if (i && (z && U.button === 0 || !z)) {
      const B = E.getState();
      Qy.onPointerDown(U.nativeEvent, {
        autoPanOnConnect: B.autoPanOnConnect,
        connectionMode: B.connectionMode,
        connectionRadius: B.connectionRadius,
        domNode: B.domNode,
        nodeLookup: B.nodeLookup,
        lib: B.lib,
        isTarget: x,
        handleId: b,
        nodeId: S,
        flowId: B.rfId,
        panBy: B.panBy,
        cancelConnection: B.cancelConnection,
        onConnectStart: B.onConnectStart,
        onConnectEnd: B.onConnectEnd,
        updateConnection: B.updateConnection,
        onConnect: H,
        isValidConnection: n || B.isValidConnection,
        getTransform: () => E.getState().transform,
        getFromHandle: () => E.getState().connection.fromHandle,
        autoPanSpeed: B.autoPanSpeed
      });
    }
    z ? h?.(U) : p?.(U);
  }, j = (U) => {
    const { onClickConnectStart: z, onClickConnectEnd: B, connectionClickStartHandle: q, connectionMode: Y, isValidConnection: O, lib: W, rfId: Z, nodeLookup: I, connection: ie } = E.getState();
    if (!S || !q && !i)
      return;
    if (!q) {
      z?.(U.nativeEvent, { nodeId: S, handleId: b, handleType: e }), E.setState({ connectionClickStartHandle: { nodeId: S, type: e, id: b } });
      return;
    }
    const fe = yR(U.target), re = n || O, { connection: le, isValid: he } = Qy.isValid(U.nativeEvent, {
      handle: {
        nodeId: S,
        id: b,
        type: e
      },
      connectionMode: Y,
      fromNodeId: q.nodeId,
      fromHandleId: q.id || null,
      fromType: q.type,
      isValidConnection: re,
      flowId: Z,
      doc: fe,
      lib: W,
      nodeLookup: I
    });
    he && le && H(le);
    const ye = structuredClone(ie);
    delete ye.inProgress, ye.toPosition = ye.toHandle ? ye.toHandle.position : null, B?.(U, ye), E.setState({ connectionClickStartHandle: null });
  };
  return _.jsx("div", { "data-handleid": b, "data-nodeid": S, "data-handlepos": t, "data-id": `${R}-${S}-${b}-${e}`, className: qt([
    "react-flow__handle",
    `react-flow__handle-${t}`,
    "nodrag",
    k,
    d,
    {
      source: !x,
      target: x,
      connectable: r,
      connectablestart: i,
      connectableend: a,
      clickconnecting: P,
      connectingfrom: N,
      connectingto: D,
      valid: $,
      /*
       * shows where you can start a connection from
       * and where you can end it while connecting
       */
      connectionindicator: r && (!V || F) && (V || T ? a : i)
    }
  ]), onMouseDown: G, onTouchStart: G, onClick: A ? j : void 0, ref: y, ...g, children: f });
}
const dc = C.memo(HR(E8));
function C8({ data: e, isConnectable: t, sourcePosition: n = _e.Bottom }) {
  return _.jsxs(_.Fragment, { children: [e?.label, _.jsx(dc, { type: "source", position: n, isConnectable: t })] });
}
function k8({ data: e, isConnectable: t, targetPosition: n = _e.Top, sourcePosition: r = _e.Bottom }) {
  return _.jsxs(_.Fragment, { children: [_.jsx(dc, { type: "target", position: n, isConnectable: t }), e?.label, _.jsx(dc, { type: "source", position: r, isConnectable: t })] });
}
function A8() {
  return null;
}
function T8({ data: e, isConnectable: t, targetPosition: n = _e.Top }) {
  return _.jsxs(_.Fragment, { children: [_.jsx(dc, { type: "target", position: n, isConnectable: t }), e?.label] });
}
const Ah = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
}, HE = {
  input: C8,
  default: k8,
  output: T8,
  group: A8
};
function R8(e) {
  return e.internals.handleBounds === void 0 ? {
    width: e.width ?? e.initialWidth ?? e.style?.width,
    height: e.height ?? e.initialHeight ?? e.style?.height
  } : {
    width: e.width ?? e.style?.width,
    height: e.height ?? e.style?.height
  };
}
const O8 = (e) => {
  const { width: t, height: n, x: r, y: i } = Mc(e.nodeLookup, {
    filter: (a) => !!a.selected
  });
  return {
    width: Nr(t) ? t : null,
    height: Nr(n) ? n : null,
    userSelectionActive: e.userSelectionActive,
    transformString: `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]}) translate(${r}px,${i}px)`
  };
};
function N8({ onSelectionContextMenu: e, noPanClassName: t, disableKeyboardA11y: n }) {
  const r = Ct(), { width: i, height: a, transformString: s, userSelectionActive: u } = We(O8, _t), f = qR(), d = C.useRef(null);
  if (C.useEffect(() => {
    n || d.current?.focus({
      preventScroll: !0
    });
  }, [n]), UR({
    nodeRef: d
  }), u || !i || !a)
    return null;
  const h = e ? (g) => {
    const y = r.getState().nodes.filter((b) => b.selected);
    e(g, y);
  } : void 0, p = (g) => {
    Object.prototype.hasOwnProperty.call(Ah, g.key) && (g.preventDefault(), f({
      direction: Ah[g.key],
      factor: g.shiftKey ? 4 : 1
    }));
  };
  return _.jsx("div", { className: qt(["react-flow__nodesselection", "react-flow__container", t]), style: {
    transform: s
  }, children: _.jsx("div", { ref: d, className: "react-flow__nodesselection-rect", onContextMenu: h, tabIndex: n ? void 0 : -1, onKeyDown: n ? void 0 : p, style: {
    width: i,
    height: a
  } }) });
}
const VE = typeof window < "u" ? window : void 0, M8 = (e) => ({ nodesSelectionActive: e.nodesSelectionActive, userSelectionActive: e.userSelectionActive });
function GR({ children: e, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: i, onPaneContextMenu: a, onPaneScroll: s, paneClickDistance: u, deleteKeyCode: f, selectionKeyCode: d, selectionOnDrag: h, selectionMode: p, onSelectionStart: g, onSelectionEnd: y, multiSelectionKeyCode: b, panActivationKeyCode: x, zoomActivationKeyCode: E, elementsSelectable: S, zoomOnScroll: A, zoomOnPinch: k, panOnScroll: R, panOnScrollSpeed: N, panOnScrollMode: D, zoomOnDoubleClick: P, panOnDrag: F, defaultViewport: V, translateExtent: T, minZoom: $, maxZoom: H, preventScrolling: G, onSelectionContextMenu: j, noWheelClassName: U, noPanClassName: z, disableKeyboardA11y: B, onViewportChange: q, isControlledViewport: Y }) {
  const { nodesSelectionActive: O, userSelectionActive: W } = We(M8), Z = al(d, { target: VE }), I = al(x, { target: VE }), ie = I || F, fe = I || R, re = h && ie !== !0, le = Z || W || re;
  return d8({ deleteKeyCode: f, multiSelectionKeyCode: b }), _.jsx(m8, { onPaneContextMenu: a, elementsSelectable: S, zoomOnScroll: A, zoomOnPinch: k, panOnScroll: fe, panOnScrollSpeed: N, panOnScrollMode: D, zoomOnDoubleClick: P, panOnDrag: !Z && ie, defaultViewport: V, translateExtent: T, minZoom: $, maxZoom: H, zoomActivationKeyCode: E, preventScrolling: G, noWheelClassName: U, noPanClassName: z, onViewportChange: q, isControlledViewport: Y, paneClickDistance: u, children: _.jsxs(b8, { onSelectionStart: g, onSelectionEnd: y, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: i, onPaneContextMenu: a, onPaneScroll: s, panOnDrag: ie, isSelecting: !!le, selectionMode: p, selectionKeyPressed: Z, selectionOnDrag: re, children: [e, O && _.jsx(N8, { onSelectionContextMenu: j, noPanClassName: z, disableKeyboardA11y: B })] }) });
}
GR.displayName = "FlowRenderer";
const D8 = C.memo(GR), P8 = (e) => (t) => e ? cR(t.nodeLookup, { x: 0, y: 0, width: t.width, height: t.height }, t.transform, !0).map((n) => n.id) : Array.from(t.nodeLookup.keys());
function z8(e) {
  return We(C.useCallback(P8(e), [e]), _t);
}
const j8 = (e) => e.updateNodeInternals;
function I8() {
  const e = We(j8), [t] = C.useState(() => typeof ResizeObserver > "u" ? null : new ResizeObserver((n) => {
    const r = /* @__PURE__ */ new Map();
    n.forEach((i) => {
      const a = i.target.getAttribute("data-id");
      r.set(a, {
        id: a,
        nodeElement: i.target,
        force: !0
      });
    }), e(r);
  }));
  return C.useEffect(() => () => {
    t?.disconnect();
  }, [t]), t;
}
function L8({ node: e, nodeType: t, hasDimensions: n, resizeObserver: r }) {
  const i = Ct(), a = C.useRef(null), s = C.useRef(null), u = C.useRef(e.sourcePosition), f = C.useRef(e.targetPosition), d = C.useRef(t), h = n && !!e.internals.handleBounds;
  return C.useEffect(() => {
    a.current && !e.hidden && (!h || s.current !== a.current) && (s.current && r?.unobserve(s.current), r?.observe(a.current), s.current = a.current);
  }, [h, e.hidden]), C.useEffect(() => () => {
    s.current && (r?.unobserve(s.current), s.current = null);
  }, []), C.useEffect(() => {
    if (a.current) {
      const p = d.current !== t, g = u.current !== e.sourcePosition, y = f.current !== e.targetPosition;
      (p || g || y) && (d.current = t, u.current = e.sourcePosition, f.current = e.targetPosition, i.getState().updateNodeInternals(/* @__PURE__ */ new Map([[e.id, { id: e.id, nodeElement: a.current, force: !0 }]])));
    }
  }, [e.id, t, e.sourcePosition, e.targetPosition]), a;
}
function F8({ id: e, onClick: t, onMouseEnter: n, onMouseMove: r, onMouseLeave: i, onContextMenu: a, onDoubleClick: s, nodesDraggable: u, elementsSelectable: f, nodesConnectable: d, nodesFocusable: h, resizeObserver: p, noDragClassName: g, noPanClassName: y, disableKeyboardA11y: b, rfId: x, nodeTypes: E, nodeClickDistance: S, onError: A }) {
  const { node: k, internals: R, isParent: N } = We((le) => {
    const he = le.nodeLookup.get(e), ye = le.parentLookup.has(e);
    return {
      node: he,
      internals: he.internals,
      isParent: ye
    };
  }, _t);
  let D = k.type || "default", P = E?.[D] || HE[D];
  P === void 0 && (A?.("003", oi.error003(D)), D = "default", P = HE.default);
  const F = !!(k.draggable || u && typeof k.draggable > "u"), V = !!(k.selectable || f && typeof k.selectable > "u"), T = !!(k.connectable || d && typeof k.connectable > "u"), $ = !!(k.focusable || h && typeof k.focusable > "u"), H = Ct(), G = mR(k), j = L8({ node: k, nodeType: D, hasDimensions: G, resizeObserver: p }), U = UR({
    nodeRef: j,
    disabled: k.hidden || !F,
    noDragClassName: g,
    handleSelector: k.dragHandle,
    nodeId: e,
    isSelectable: V,
    nodeClickDistance: S
  }), z = qR();
  if (k.hidden)
    return null;
  const B = Gi(k), q = R8(k), Y = V || F || t || n || r || i, O = n ? (le) => n(le, { ...R.userNode }) : void 0, W = r ? (le) => r(le, { ...R.userNode }) : void 0, Z = i ? (le) => i(le, { ...R.userNode }) : void 0, I = a ? (le) => a(le, { ...R.userNode }) : void 0, ie = s ? (le) => s(le, { ...R.userNode }) : void 0, fe = (le) => {
    const { selectNodesOnDrag: he, nodeDragThreshold: ye } = H.getState();
    V && (!he || !F || ye > 0) && Jy({
      id: e,
      store: H,
      nodeRef: j
    }), t && t(le, { ...R.userNode });
  }, re = (le) => {
    if (!(vR(le.nativeEvent) || b))
      if (aR.includes(le.key) && V) {
        const he = le.key === "Escape";
        Jy({
          id: e,
          store: H,
          unselect: he,
          nodeRef: j
        });
      } else F && k.selected && Object.prototype.hasOwnProperty.call(Ah, le.key) && (le.preventDefault(), H.setState({
        ariaLiveMessage: `Moved selected node ${le.key.replace("Arrow", "").toLowerCase()}. New position, x: ${~~R.positionAbsolute.x}, y: ${~~R.positionAbsolute.y}`
      }), z({
        direction: Ah[le.key],
        factor: le.shiftKey ? 4 : 1
      }));
  };
  return _.jsx("div", { className: qt([
    "react-flow__node",
    `react-flow__node-${D}`,
    {
      // this is overwritable by passing `nopan` as a class name
      [y]: F
    },
    k.className,
    {
      selected: k.selected,
      selectable: V,
      parent: N,
      draggable: F,
      dragging: U
    }
  ]), ref: j, style: {
    zIndex: R.z,
    transform: `translate(${R.positionAbsolute.x}px,${R.positionAbsolute.y}px)`,
    pointerEvents: Y ? "all" : "none",
    visibility: G ? "visible" : "hidden",
    ...k.style,
    ...q
  }, "data-id": e, "data-testid": `rf__node-${e}`, onMouseEnter: O, onMouseMove: W, onMouseLeave: Z, onContextMenu: I, onClick: fe, onDoubleClick: ie, onKeyDown: $ ? re : void 0, tabIndex: $ ? 0 : void 0, role: $ ? "button" : void 0, "aria-describedby": b ? void 0 : `${jR}-${x}`, "aria-label": k.ariaLabel, children: _.jsx(w8, { value: e, children: _.jsx(P, { id: e, data: k.data, type: D, positionAbsoluteX: R.positionAbsolute.x, positionAbsoluteY: R.positionAbsolute.y, selected: k.selected ?? !1, selectable: V, draggable: F, deletable: k.deletable ?? !0, isConnectable: T, sourcePosition: k.sourcePosition, targetPosition: k.targetPosition, dragging: U, dragHandle: k.dragHandle, zIndex: R.z, parentId: k.parentId, ...B }) }) });
}
const B8 = (e) => ({
  nodesDraggable: e.nodesDraggable,
  nodesConnectable: e.nodesConnectable,
  nodesFocusable: e.nodesFocusable,
  elementsSelectable: e.elementsSelectable,
  onError: e.onError
});
function XR(e) {
  const { nodesDraggable: t, nodesConnectable: n, nodesFocusable: r, elementsSelectable: i, onError: a } = We(B8, _t), s = z8(e.onlyRenderVisibleElements), u = I8();
  return _.jsx("div", { className: "react-flow__nodes", style: pp, children: s.map((f) => (
    /*
     * The split of responsibilities between NodeRenderer and
     * NodeComponentWrapper may appear weird. However, its designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For example, when youre dragging a single node, that node gets
     * updated multiple times per second. If `NodeRenderer` were to update
     * every time, it would have to re-run the `nodes.map()` loop every
     * time. This gets pricey with hundreds of nodes, especially if every
     * loop cycle does more than just rendering a JSX element!
     *
     * As a result of this choice, we took the following implementation
     * decisions:
     * - NodeRenderer subscribes *only* to node IDs  and therefore
     *   rerender *only* when visible nodes are added or removed.
     * - NodeRenderer performs all operations the result of which can be
     *   shared between nodes (such as creating the `ResizeObserver`
     *   instance, or subscribing to `selector`). This means extra prop
     *   drilling into `NodeComponentWrapper`, but it means we need to run
     *   these operations only once  instead of once per node.
     * - Any operations that youd normally write inside `nodes.map` are
     *   moved into `NodeComponentWrapper`. This ensures they are
     *   memorized  so if `NodeRenderer` *has* to rerender, it only
     *   needs to regenerate the list of nodes, nothing else.
     */
    _.jsx(F8, { id: f, nodeTypes: e.nodeTypes, nodeExtent: e.nodeExtent, onClick: e.onNodeClick, onMouseEnter: e.onNodeMouseEnter, onMouseMove: e.onNodeMouseMove, onMouseLeave: e.onNodeMouseLeave, onContextMenu: e.onNodeContextMenu, onDoubleClick: e.onNodeDoubleClick, noDragClassName: e.noDragClassName, noPanClassName: e.noPanClassName, rfId: e.rfId, disableKeyboardA11y: e.disableKeyboardA11y, resizeObserver: u, nodesDraggable: t, nodesConnectable: n, nodesFocusable: r, elementsSelectable: i, nodeClickDistance: e.nodeClickDistance, onError: a }, f)
  )) });
}
XR.displayName = "NodeRenderer";
const $8 = C.memo(XR);
function H8(e) {
  return We(C.useCallback((n) => {
    if (!e)
      return n.edges.map((i) => i.id);
    const r = [];
    if (n.width && n.height)
      for (const i of n.edges) {
        const a = n.nodeLookup.get(i.source), s = n.nodeLookup.get(i.target);
        a && s && XI({
          sourceNode: a,
          targetNode: s,
          width: n.width,
          height: n.height,
          transform: n.transform
        }) && r.push(i.id);
      }
    return r;
  }, [e]), _t);
}
const V8 = ({ color: e = "none", strokeWidth: t = 1 }) => _.jsx("polyline", { style: {
  stroke: e,
  strokeWidth: t
}, strokeLinecap: "round", strokeLinejoin: "round", fill: "none", points: "-5,-4 0,0 -5,4" }), U8 = ({ color: e = "none", strokeWidth: t = 1 }) => _.jsx("polyline", { style: {
  stroke: e,
  fill: e,
  strokeWidth: t
}, strokeLinecap: "round", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4 -5,-4" }), UE = {
  [_h.Arrow]: V8,
  [_h.ArrowClosed]: U8
};
function q8(e) {
  const t = Ct();
  return C.useMemo(() => Object.prototype.hasOwnProperty.call(UE, e) ? UE[e] : (t.getState().onError?.("009", oi.error009(e)), null), [e]);
}
const Y8 = ({ id: e, type: t, color: n, width: r = 12.5, height: i = 12.5, markerUnits: a = "strokeWidth", strokeWidth: s, orient: u = "auto-start-reverse" }) => {
  const f = q8(t);
  return f ? _.jsx("marker", { className: "react-flow__arrowhead", id: e, markerWidth: `${r}`, markerHeight: `${i}`, viewBox: "-10 -10 20 20", markerUnits: a, orient: u, refX: "0", refY: "0", children: _.jsx(f, { color: n, strokeWidth: s }) }) : null;
}, WR = ({ defaultColor: e, rfId: t }) => {
  const n = We((a) => a.edges), r = We((a) => a.defaultEdgeOptions), i = C.useMemo(() => nL(n, {
    id: t,
    defaultColor: e,
    defaultMarkerStart: r?.markerStart,
    defaultMarkerEnd: r?.markerEnd
  }), [n, r, t, e]);
  return i.length ? _.jsx("svg", { className: "react-flow__marker", children: _.jsx("defs", { children: i.map((a) => _.jsx(Y8, { id: a.id, type: a.type, color: a.color, width: a.width, height: a.height, markerUnits: a.markerUnits, strokeWidth: a.strokeWidth, orient: a.orient }, a.id)) }) }) : null;
};
WR.displayName = "MarkerDefinitions";
var G8 = C.memo(WR);
function KR({ x: e, y: t, label: n, labelStyle: r, labelShowBg: i = !0, labelBgStyle: a, labelBgPadding: s = [2, 4], labelBgBorderRadius: u = 2, children: f, className: d, ...h }) {
  const [p, g] = C.useState({ x: 1, y: 0, width: 0, height: 0 }), y = qt(["react-flow__edge-textwrapper", d]), b = C.useRef(null);
  return C.useEffect(() => {
    if (b.current) {
      const x = b.current.getBBox();
      g({
        x: x.x,
        y: x.y,
        width: x.width,
        height: x.height
      });
    }
  }, [n]), n ? _.jsxs("g", { transform: `translate(${e - p.width / 2} ${t - p.height / 2})`, className: y, visibility: p.width ? "visible" : "hidden", ...h, children: [i && _.jsx("rect", { width: p.width + 2 * s[0], x: -s[0], y: -s[1], height: p.height + 2 * s[1], className: "react-flow__edge-textbg", style: a, rx: u, ry: u }), _.jsx("text", { className: "react-flow__edge-text", y: p.height / 2, dy: "0.3em", ref: b, style: r, children: n }), f] }) : null;
}
KR.displayName = "EdgeText";
const X8 = C.memo(KR);
function jc({ path: e, labelX: t, labelY: n, label: r, labelStyle: i, labelShowBg: a, labelBgStyle: s, labelBgPadding: u, labelBgBorderRadius: f, interactionWidth: d = 20, ...h }) {
  return _.jsxs(_.Fragment, { children: [_.jsx("path", { ...h, d: e, fill: "none", className: qt(["react-flow__edge-path", h.className]) }), d && _.jsx("path", { d: e, fill: "none", strokeOpacity: 0, strokeWidth: d, className: "react-flow__edge-interaction" }), r && Nr(t) && Nr(n) ? _.jsx(X8, { x: t, y: n, label: r, labelStyle: i, labelShowBg: a, labelBgStyle: s, labelBgPadding: u, labelBgBorderRadius: f }) : null] });
}
function qE({ pos: e, x1: t, y1: n, x2: r, y2: i }) {
  return e === _e.Left || e === _e.Right ? [0.5 * (t + r), n] : [t, 0.5 * (n + i)];
}
function ZR({ sourceX: e, sourceY: t, sourcePosition: n = _e.Bottom, targetX: r, targetY: i, targetPosition: a = _e.Top }) {
  const [s, u] = qE({
    pos: n,
    x1: e,
    y1: t,
    x2: r,
    y2: i
  }), [f, d] = qE({
    pos: a,
    x1: r,
    y1: i,
    x2: e,
    y2: t
  }), [h, p, g, y] = xR({
    sourceX: e,
    sourceY: t,
    targetX: r,
    targetY: i,
    sourceControlX: s,
    sourceControlY: u,
    targetControlX: f,
    targetControlY: d
  });
  return [
    `M${e},${t} C${s},${u} ${f},${d} ${r},${i}`,
    h,
    p,
    g,
    y
  ];
}
function QR(e) {
  return C.memo(({ id: t, sourceX: n, sourceY: r, targetX: i, targetY: a, sourcePosition: s, targetPosition: u, label: f, labelStyle: d, labelShowBg: h, labelBgStyle: p, labelBgPadding: g, labelBgBorderRadius: y, style: b, markerEnd: x, markerStart: E, interactionWidth: S }) => {
    const [A, k, R] = ZR({
      sourceX: n,
      sourceY: r,
      sourcePosition: s,
      targetX: i,
      targetY: a,
      targetPosition: u
    }), N = e.isInternal ? void 0 : t;
    return _.jsx(jc, { id: N, path: A, labelX: k, labelY: R, label: f, labelStyle: d, labelShowBg: h, labelBgStyle: p, labelBgPadding: g, labelBgBorderRadius: y, style: b, markerEnd: x, markerStart: E, interactionWidth: S });
  });
}
const W8 = QR({ isInternal: !1 }), JR = QR({ isInternal: !0 });
W8.displayName = "SimpleBezierEdge";
JR.displayName = "SimpleBezierEdgeInternal";
function eO(e) {
  return C.memo(({ id: t, sourceX: n, sourceY: r, targetX: i, targetY: a, label: s, labelStyle: u, labelShowBg: f, labelBgStyle: d, labelBgPadding: h, labelBgBorderRadius: p, style: g, sourcePosition: y = _e.Bottom, targetPosition: b = _e.Top, markerEnd: x, markerStart: E, pathOptions: S, interactionWidth: A }) => {
    const [k, R, N] = Wy({
      sourceX: n,
      sourceY: r,
      sourcePosition: y,
      targetX: i,
      targetY: a,
      targetPosition: b,
      borderRadius: S?.borderRadius,
      offset: S?.offset
    }), D = e.isInternal ? void 0 : t;
    return _.jsx(jc, { id: D, path: k, labelX: R, labelY: N, label: s, labelStyle: u, labelShowBg: f, labelBgStyle: d, labelBgPadding: h, labelBgBorderRadius: p, style: g, markerEnd: x, markerStart: E, interactionWidth: A });
  });
}
const tO = eO({ isInternal: !1 }), nO = eO({ isInternal: !0 });
tO.displayName = "SmoothStepEdge";
nO.displayName = "SmoothStepEdgeInternal";
function rO(e) {
  return C.memo(({ id: t, ...n }) => {
    const r = e.isInternal ? void 0 : t;
    return _.jsx(tO, { ...n, id: r, pathOptions: C.useMemo(() => ({ borderRadius: 0, offset: n.pathOptions?.offset }), [n.pathOptions?.offset]) });
  });
}
const K8 = rO({ isInternal: !1 }), iO = rO({ isInternal: !0 });
K8.displayName = "StepEdge";
iO.displayName = "StepEdgeInternal";
function oO(e) {
  return C.memo(({ id: t, sourceX: n, sourceY: r, targetX: i, targetY: a, label: s, labelStyle: u, labelShowBg: f, labelBgStyle: d, labelBgPadding: h, labelBgBorderRadius: p, style: g, markerEnd: y, markerStart: b, interactionWidth: x }) => {
    const [E, S, A] = SR({ sourceX: n, sourceY: r, targetX: i, targetY: a }), k = e.isInternal ? void 0 : t;
    return _.jsx(jc, { id: k, path: E, labelX: S, labelY: A, label: s, labelStyle: u, labelShowBg: f, labelBgStyle: d, labelBgPadding: h, labelBgBorderRadius: p, style: g, markerEnd: y, markerStart: b, interactionWidth: x });
  });
}
const Z8 = oO({ isInternal: !1 }), aO = oO({ isInternal: !0 });
Z8.displayName = "StraightEdge";
aO.displayName = "StraightEdgeInternal";
function sO(e) {
  return C.memo(({ id: t, sourceX: n, sourceY: r, targetX: i, targetY: a, sourcePosition: s = _e.Bottom, targetPosition: u = _e.Top, label: f, labelStyle: d, labelShowBg: h, labelBgStyle: p, labelBgPadding: g, labelBgBorderRadius: y, style: b, markerEnd: x, markerStart: E, pathOptions: S, interactionWidth: A }) => {
    const [k, R, N] = xb({
      sourceX: n,
      sourceY: r,
      sourcePosition: s,
      targetX: i,
      targetY: a,
      targetPosition: u,
      curvature: S?.curvature
    }), D = e.isInternal ? void 0 : t;
    return _.jsx(jc, { id: D, path: k, labelX: R, labelY: N, label: f, labelStyle: d, labelShowBg: h, labelBgStyle: p, labelBgPadding: g, labelBgBorderRadius: y, style: b, markerEnd: x, markerStart: E, interactionWidth: A });
  });
}
const Q8 = sO({ isInternal: !1 }), lO = sO({ isInternal: !0 });
Q8.displayName = "BezierEdge";
lO.displayName = "BezierEdgeInternal";
const YE = {
  default: lO,
  straight: aO,
  step: iO,
  smoothstep: nO,
  simplebezier: JR
}, GE = {
  sourceX: null,
  sourceY: null,
  targetX: null,
  targetY: null,
  sourcePosition: null,
  targetPosition: null
}, J8 = (e, t, n) => n === _e.Left ? e - t : n === _e.Right ? e + t : e, e9 = (e, t, n) => n === _e.Top ? e - t : n === _e.Bottom ? e + t : e, XE = "react-flow__edgeupdater";
function WE({ position: e, centerX: t, centerY: n, radius: r = 10, onMouseDown: i, onMouseEnter: a, onMouseOut: s, type: u }) {
  return _.jsx("circle", { onMouseDown: i, onMouseEnter: a, onMouseOut: s, className: qt([XE, `${XE}-${u}`]), cx: J8(t, r, e), cy: e9(n, r, e), r, stroke: "transparent", fill: "transparent" });
}
function t9({ isReconnectable: e, reconnectRadius: t, edge: n, sourceX: r, sourceY: i, targetX: a, targetY: s, sourcePosition: u, targetPosition: f, onReconnect: d, onReconnectStart: h, onReconnectEnd: p, setReconnecting: g, setUpdateHover: y }) {
  const b = Ct(), x = (R, N) => {
    if (R.button !== 0)
      return;
    const { autoPanOnConnect: D, domNode: P, isValidConnection: F, connectionMode: V, connectionRadius: T, lib: $, onConnectStart: H, onConnectEnd: G, cancelConnection: j, nodeLookup: U, rfId: z, panBy: B, updateConnection: q } = b.getState(), Y = N.type === "target";
    g(!0), h?.(R, n, N.type);
    const O = (Z, I) => {
      g(!1), p?.(Z, n, N.type, I);
    }, W = (Z) => d?.(n, Z);
    Qy.onPointerDown(R.nativeEvent, {
      autoPanOnConnect: D,
      connectionMode: V,
      connectionRadius: T,
      domNode: P,
      handleId: N.id,
      nodeId: N.nodeId,
      nodeLookup: U,
      isTarget: Y,
      edgeUpdaterType: N.type,
      lib: $,
      flowId: z,
      cancelConnection: j,
      panBy: B,
      isValidConnection: F,
      onConnect: W,
      onConnectStart: H,
      onConnectEnd: G,
      onReconnectEnd: O,
      updateConnection: q,
      getTransform: () => b.getState().transform,
      getFromHandle: () => b.getState().connection.fromHandle
    });
  }, E = (R) => x(R, { nodeId: n.target, id: n.targetHandle ?? null, type: "target" }), S = (R) => x(R, { nodeId: n.source, id: n.sourceHandle ?? null, type: "source" }), A = () => y(!0), k = () => y(!1);
  return _.jsxs(_.Fragment, { children: [(e === !0 || e === "source") && _.jsx(WE, { position: u, centerX: r, centerY: i, radius: t, onMouseDown: E, onMouseEnter: A, onMouseOut: k, type: "source" }), (e === !0 || e === "target") && _.jsx(WE, { position: f, centerX: a, centerY: s, radius: t, onMouseDown: S, onMouseEnter: A, onMouseOut: k, type: "target" })] });
}
function n9({ id: e, edgesFocusable: t, edgesReconnectable: n, elementsSelectable: r, onClick: i, onDoubleClick: a, onContextMenu: s, onMouseEnter: u, onMouseMove: f, onMouseLeave: d, reconnectRadius: h, onReconnect: p, onReconnectStart: g, onReconnectEnd: y, rfId: b, edgeTypes: x, noPanClassName: E, onError: S, disableKeyboardA11y: A }) {
  let k = We((be) => be.edgeLookup.get(e));
  const R = We((be) => be.defaultEdgeOptions);
  k = R ? { ...R, ...k } : k;
  let N = k.type || "default", D = x?.[N] || YE[N];
  D === void 0 && (S?.("011", oi.error011(N)), N = "default", D = YE.default);
  const P = !!(k.focusable || t && typeof k.focusable > "u"), F = typeof p < "u" && (k.reconnectable || n && typeof k.reconnectable > "u"), V = !!(k.selectable || r && typeof k.selectable > "u"), T = C.useRef(null), [$, H] = C.useState(!1), [G, j] = C.useState(!1), U = Ct(), { zIndex: z, sourceX: B, sourceY: q, targetX: Y, targetY: O, sourcePosition: W, targetPosition: Z } = We(C.useCallback((be) => {
    const Le = be.nodeLookup.get(k.source), Ie = be.nodeLookup.get(k.target);
    if (!Le || !Ie)
      return {
        zIndex: k.zIndex,
        ...GE
      };
    const ft = tL({
      id: e,
      sourceNode: Le,
      targetNode: Ie,
      sourceHandle: k.sourceHandle || null,
      targetHandle: k.targetHandle || null,
      connectionMode: be.connectionMode,
      onError: S
    });
    return {
      zIndex: GI({
        selected: k.selected,
        zIndex: k.zIndex,
        sourceNode: Le,
        targetNode: Ie,
        elevateOnSelect: be.elevateEdgesOnSelect
      }),
      ...ft || GE
    };
  }, [k.source, k.target, k.sourceHandle, k.targetHandle, k.selected, k.zIndex]), _t), I = C.useMemo(() => k.markerStart ? `url('#${Ky(k.markerStart, b)}')` : void 0, [k.markerStart, b]), ie = C.useMemo(() => k.markerEnd ? `url('#${Ky(k.markerEnd, b)}')` : void 0, [k.markerEnd, b]);
  if (k.hidden || B === null || q === null || Y === null || O === null)
    return null;
  const fe = (be) => {
    const { addSelectedEdges: Le, unselectNodesAndEdges: Ie, multiSelectionActive: ft } = U.getState();
    V && (U.setState({ nodesSelectionActive: !1 }), k.selected && ft ? (Ie({ nodes: [], edges: [k] }), T.current?.blur()) : Le([e])), i && i(be, k);
  }, re = a ? (be) => {
    a(be, { ...k });
  } : void 0, le = s ? (be) => {
    s(be, { ...k });
  } : void 0, he = u ? (be) => {
    u(be, { ...k });
  } : void 0, ye = f ? (be) => {
    f(be, { ...k });
  } : void 0, je = d ? (be) => {
    d(be, { ...k });
  } : void 0, Oe = (be) => {
    if (!A && aR.includes(be.key) && V) {
      const { unselectNodesAndEdges: Le, addSelectedEdges: Ie } = U.getState();
      be.key === "Escape" ? (T.current?.blur(), Le({ edges: [k] })) : Ie([e]);
    }
  };
  return _.jsx("svg", { style: { zIndex: z }, children: _.jsxs("g", { className: qt([
    "react-flow__edge",
    `react-flow__edge-${N}`,
    k.className,
    E,
    {
      selected: k.selected,
      animated: k.animated,
      inactive: !V && !i,
      updating: $,
      selectable: V
    }
  ]), onClick: fe, onDoubleClick: re, onContextMenu: le, onMouseEnter: he, onMouseMove: ye, onMouseLeave: je, onKeyDown: P ? Oe : void 0, tabIndex: P ? 0 : void 0, role: P ? "button" : "img", "data-id": e, "data-testid": `rf__edge-${e}`, "aria-label": k.ariaLabel === null ? void 0 : k.ariaLabel || `Edge from ${k.source} to ${k.target}`, "aria-describedby": P ? `${IR}-${b}` : void 0, ref: T, children: [!G && _.jsx(D, { id: e, source: k.source, target: k.target, type: k.type, selected: k.selected, animated: k.animated, selectable: V, deletable: k.deletable ?? !0, label: k.label, labelStyle: k.labelStyle, labelShowBg: k.labelShowBg, labelBgStyle: k.labelBgStyle, labelBgPadding: k.labelBgPadding, labelBgBorderRadius: k.labelBgBorderRadius, sourceX: B, sourceY: q, targetX: Y, targetY: O, sourcePosition: W, targetPosition: Z, data: k.data, style: k.style, sourceHandleId: k.sourceHandle, targetHandleId: k.targetHandle, markerStart: I, markerEnd: ie, pathOptions: "pathOptions" in k ? k.pathOptions : void 0, interactionWidth: k.interactionWidth }), F && _.jsx(t9, { edge: k, isReconnectable: F, reconnectRadius: h, onReconnect: p, onReconnectStart: g, onReconnectEnd: y, sourceX: B, sourceY: q, targetX: Y, targetY: O, sourcePosition: W, targetPosition: Z, setUpdateHover: H, setReconnecting: j })] }) });
}
const r9 = (e) => ({
  edgesFocusable: e.edgesFocusable,
  edgesReconnectable: e.edgesReconnectable,
  elementsSelectable: e.elementsSelectable,
  connectionMode: e.connectionMode,
  onError: e.onError
});
function uO({ defaultMarkerColor: e, onlyRenderVisibleElements: t, rfId: n, edgeTypes: r, noPanClassName: i, onReconnect: a, onEdgeContextMenu: s, onEdgeMouseEnter: u, onEdgeMouseMove: f, onEdgeMouseLeave: d, onEdgeClick: h, reconnectRadius: p, onEdgeDoubleClick: g, onReconnectStart: y, onReconnectEnd: b, disableKeyboardA11y: x }) {
  const { edgesFocusable: E, edgesReconnectable: S, elementsSelectable: A, onError: k } = We(r9, _t), R = H8(t);
  return _.jsxs("div", { className: "react-flow__edges", children: [_.jsx(G8, { defaultColor: e, rfId: n }), R.map((N) => _.jsx(n9, { id: N, edgesFocusable: E, edgesReconnectable: S, elementsSelectable: A, noPanClassName: i, onReconnect: a, onContextMenu: s, onMouseEnter: u, onMouseMove: f, onMouseLeave: d, onClick: h, reconnectRadius: p, onDoubleClick: g, onReconnectStart: y, onReconnectEnd: b, rfId: n, onError: k, edgeTypes: r, disableKeyboardA11y: x }, N))] });
}
uO.displayName = "EdgeRenderer";
const i9 = C.memo(uO), o9 = (e) => `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]})`;
function a9({ children: e }) {
  const t = We(o9);
  return _.jsx("div", { className: "react-flow__viewport xyflow__viewport react-flow__container", style: { transform: t }, children: e });
}
function s9(e) {
  const t = zc(), n = C.useRef(!1);
  C.useEffect(() => {
    !n.current && t.viewportInitialized && e && (setTimeout(() => e(t), 1), n.current = !0);
  }, [e, t.viewportInitialized]);
}
const l9 = (e) => e.panZoom?.syncViewport;
function u9(e) {
  const t = We(l9), n = Ct();
  return C.useEffect(() => {
    e && (t?.(e), n.setState({ transform: [e.x, e.y, e.zoom] }));
  }, [e, t]), null;
}
function c9(e) {
  return e.connection.inProgress ? { ...e.connection, to: Dc(e.connection.to, e.transform) } : { ...e.connection };
}
function f9(e) {
  return c9;
}
function d9(e) {
  const t = f9();
  return We(t, _t);
}
const h9 = (e) => ({
  nodesConnectable: e.nodesConnectable,
  isValid: e.connection.isValid,
  inProgress: e.connection.inProgress,
  width: e.width,
  height: e.height
});
function p9({ containerStyle: e, style: t, type: n, component: r }) {
  const { nodesConnectable: i, width: a, height: s, isValid: u, inProgress: f } = We(h9, _t);
  return !(a && i && f) ? null : _.jsx("svg", { style: e, width: a, height: s, className: "react-flow__connectionline react-flow__container", children: _.jsx("g", { className: qt(["react-flow__connection", lR(u)]), children: _.jsx(cO, { style: t, type: n, CustomComponent: r, isValid: u }) }) });
}
const cO = ({ style: e, type: t = Po.Bezier, CustomComponent: n, isValid: r }) => {
  const { inProgress: i, from: a, fromNode: s, fromHandle: u, fromPosition: f, to: d, toNode: h, toHandle: p, toPosition: g } = d9();
  if (!i)
    return;
  if (n)
    return _.jsx(n, { connectionLineType: t, connectionLineStyle: e, fromNode: s, fromHandle: u, fromX: a.x, fromY: a.y, toX: d.x, toY: d.y, fromPosition: f, toPosition: g, connectionStatus: lR(r), toNode: h, toHandle: p });
  let y = "";
  const b = {
    sourceX: a.x,
    sourceY: a.y,
    sourcePosition: f,
    targetX: d.x,
    targetY: d.y,
    targetPosition: g
  };
  switch (t) {
    case Po.Bezier:
      [y] = xb(b);
      break;
    case Po.SimpleBezier:
      [y] = ZR(b);
      break;
    case Po.Step:
      [y] = Wy({
        ...b,
        borderRadius: 0
      });
      break;
    case Po.SmoothStep:
      [y] = Wy(b);
      break;
    default:
      [y] = SR(b);
  }
  return _.jsx("path", { d: y, fill: "none", className: "react-flow__connection-path", style: e });
};
cO.displayName = "ConnectionLine";
const m9 = {};
function KE(e = m9) {
  C.useRef(e), Ct(), C.useEffect(() => {
  }, [e]);
}
function g9() {
  Ct(), C.useRef(!1), C.useEffect(() => {
  }, []);
}
function fO({ nodeTypes: e, edgeTypes: t, onInit: n, onNodeClick: r, onEdgeClick: i, onNodeDoubleClick: a, onEdgeDoubleClick: s, onNodeMouseEnter: u, onNodeMouseMove: f, onNodeMouseLeave: d, onNodeContextMenu: h, onSelectionContextMenu: p, onSelectionStart: g, onSelectionEnd: y, connectionLineType: b, connectionLineStyle: x, connectionLineComponent: E, connectionLineContainerStyle: S, selectionKeyCode: A, selectionOnDrag: k, selectionMode: R, multiSelectionKeyCode: N, panActivationKeyCode: D, zoomActivationKeyCode: P, deleteKeyCode: F, onlyRenderVisibleElements: V, elementsSelectable: T, defaultViewport: $, translateExtent: H, minZoom: G, maxZoom: j, preventScrolling: U, defaultMarkerColor: z, zoomOnScroll: B, zoomOnPinch: q, panOnScroll: Y, panOnScrollSpeed: O, panOnScrollMode: W, zoomOnDoubleClick: Z, panOnDrag: I, onPaneClick: ie, onPaneMouseEnter: fe, onPaneMouseMove: re, onPaneMouseLeave: le, onPaneScroll: he, onPaneContextMenu: ye, paneClickDistance: je, nodeClickDistance: Oe, onEdgeContextMenu: be, onEdgeMouseEnter: Le, onEdgeMouseMove: Ie, onEdgeMouseLeave: ft, reconnectRadius: Jt, onReconnect: bt, onReconnectStart: Ln, onReconnectEnd: xr, noDragClassName: En, noWheelClassName: ir, noPanClassName: Pe, disableKeyboardA11y: Lr, nodeExtent: Ko, rfId: hi, viewport: ae, onViewportChange: pe }) {
  return KE(e), KE(t), g9(), s9(n), u9(ae), _.jsx(D8, { onPaneClick: ie, onPaneMouseEnter: fe, onPaneMouseMove: re, onPaneMouseLeave: le, onPaneContextMenu: ye, onPaneScroll: he, paneClickDistance: je, deleteKeyCode: F, selectionKeyCode: A, selectionOnDrag: k, selectionMode: R, onSelectionStart: g, onSelectionEnd: y, multiSelectionKeyCode: N, panActivationKeyCode: D, zoomActivationKeyCode: P, elementsSelectable: T, zoomOnScroll: B, zoomOnPinch: q, zoomOnDoubleClick: Z, panOnScroll: Y, panOnScrollSpeed: O, panOnScrollMode: W, panOnDrag: I, defaultViewport: $, translateExtent: H, minZoom: G, maxZoom: j, onSelectionContextMenu: p, preventScrolling: U, noDragClassName: En, noWheelClassName: ir, noPanClassName: Pe, disableKeyboardA11y: Lr, onViewportChange: pe, isControlledViewport: !!ae, children: _.jsxs(a9, { children: [_.jsx(i9, { edgeTypes: t, onEdgeClick: i, onEdgeDoubleClick: s, onReconnect: bt, onReconnectStart: Ln, onReconnectEnd: xr, onlyRenderVisibleElements: V, onEdgeContextMenu: be, onEdgeMouseEnter: Le, onEdgeMouseMove: Ie, onEdgeMouseLeave: ft, reconnectRadius: Jt, defaultMarkerColor: z, noPanClassName: Pe, disableKeyboardA11y: Lr, rfId: hi }), _.jsx(p9, { style: x, type: b, component: E, containerStyle: S }), _.jsx("div", { className: "react-flow__edgelabel-renderer" }), _.jsx($8, { nodeTypes: e, onNodeClick: r, onNodeDoubleClick: a, onNodeMouseEnter: u, onNodeMouseMove: f, onNodeMouseLeave: d, onNodeContextMenu: h, nodeClickDistance: Oe, onlyRenderVisibleElements: V, noPanClassName: Pe, noDragClassName: En, disableKeyboardA11y: Lr, nodeExtent: Ko, rfId: hi }), _.jsx("div", { className: "react-flow__viewport-portal" })] }) });
}
fO.displayName = "GraphView";
const y9 = C.memo(fO), ZE = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, width: i, height: a, fitView: s, nodeOrigin: u, nodeExtent: f } = {}) => {
  const d = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Map(), p = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new Map(), y = r ?? t ?? [], b = n ?? e ?? [], x = u ?? [0, 0], E = f ?? lc;
  ER(p, g, y), Zy(b, d, h, {
    nodeOrigin: x,
    nodeExtent: E,
    elevateNodesOnSelect: !1
  });
  let S = [0, 0, 1];
  if (s && i && a) {
    const A = Mc(d, {
      filter: (D) => !!((D.width || D.initialWidth) && (D.height || D.initialHeight))
    }), { x: k, y: R, zoom: N } = vb(A, i, a, 0.5, 2, 0.1);
    S = [k, R, N];
  }
  return {
    rfId: "1",
    width: 0,
    height: 0,
    transform: S,
    nodes: b,
    nodeLookup: d,
    parentLookup: h,
    edges: y,
    edgeLookup: g,
    connectionLookup: p,
    onNodesChange: null,
    onEdgesChange: null,
    hasDefaultNodes: n !== void 0,
    hasDefaultEdges: r !== void 0,
    panZoom: null,
    minZoom: 0.5,
    maxZoom: 2,
    translateExtent: lc,
    nodeExtent: E,
    nodesSelectionActive: !1,
    userSelectionActive: !1,
    userSelectionRect: null,
    connectionMode: nl.Strict,
    domNode: null,
    paneDragging: !1,
    noPanClassName: "nopan",
    nodeOrigin: x,
    nodeDragThreshold: 1,
    snapGrid: [15, 15],
    snapToGrid: !1,
    nodesDraggable: !0,
    nodesConnectable: !0,
    nodesFocusable: !0,
    edgesFocusable: !0,
    edgesReconnectable: !0,
    elementsSelectable: !0,
    elevateNodesOnSelect: !0,
    elevateEdgesOnSelect: !1,
    selectNodesOnDrag: !0,
    multiSelectionActive: !1,
    fitViewQueued: s ?? !1,
    fitViewOptions: void 0,
    fitViewResolver: null,
    connection: { ...sR },
    connectionClickStartHandle: null,
    connectOnClick: !0,
    ariaLiveMessage: "",
    autoPanOnConnect: !0,
    autoPanOnNodeDrag: !0,
    autoPanSpeed: 15,
    connectionRadius: 20,
    onError: VI,
    isValidConnection: void 0,
    onSelectionChangeHandlers: [],
    lib: "react",
    debug: !1
  };
}, v9 = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, width: i, height: a, fitView: s, nodeOrigin: u, nodeExtent: f }) => zL((d, h) => {
  async function p() {
    const { nodeLookup: g, panZoom: y, fitViewOptions: b, fitViewResolver: x, width: E, height: S, minZoom: A, maxZoom: k } = h();
    y && (await $I({
      nodes: g,
      width: E,
      height: S,
      panZoom: y,
      minZoom: A,
      maxZoom: k
    }, b), x?.resolve(!0), d({ fitViewResolver: null }));
  }
  return {
    ...ZE({ nodes: e, edges: t, width: i, height: a, fitView: s, nodeOrigin: u, nodeExtent: f, defaultNodes: n, defaultEdges: r }),
    setNodes: (g) => {
      const { nodeLookup: y, parentLookup: b, nodeOrigin: x, elevateNodesOnSelect: E, fitViewQueued: S } = h(), A = Zy(g, y, b, {
        nodeOrigin: x,
        nodeExtent: f,
        elevateNodesOnSelect: E,
        checkEquality: !0
      });
      S && A ? (p(), d({ nodes: g, fitViewQueued: !1, fitViewOptions: void 0 })) : d({ nodes: g });
    },
    setEdges: (g) => {
      const { connectionLookup: y, edgeLookup: b } = h();
      ER(y, b, g), d({ edges: g });
    },
    setDefaultNodesAndEdges: (g, y) => {
      if (g) {
        const { setNodes: b } = h();
        b(g), d({ hasDefaultNodes: !0 });
      }
      if (y) {
        const { setEdges: b } = h();
        b(y), d({ hasDefaultEdges: !0 });
      }
    },
    /*
     * Every node gets registerd at a ResizeObserver. Whenever a node
     * changes its dimensions, this function is called to measure the
     * new dimensions and update the nodes.
     */
    updateNodeInternals: (g) => {
      const { triggerNodeChanges: y, nodeLookup: b, parentLookup: x, domNode: E, nodeOrigin: S, nodeExtent: A, debug: k, fitViewQueued: R } = h(), { changes: N, updatedInternals: D } = sL(g, b, x, E, S, A);
      D && (iL(b, x, { nodeOrigin: S, nodeExtent: A }), R ? (p(), d({ fitViewQueued: !1, fitViewOptions: void 0 })) : d({}), N?.length > 0 && (k && console.log("React Flow: trigger node changes", N), y?.(N)));
    },
    updateNodePositions: (g, y = !1) => {
      const b = [], x = [], { nodeLookup: E, triggerNodeChanges: S } = h();
      for (const [A, k] of g) {
        const R = E.get(A), N = !!(R?.expandParent && R?.parentId && k?.position), D = {
          id: A,
          type: "position",
          position: N ? {
            x: Math.max(0, k.position.x),
            y: Math.max(0, k.position.y)
          } : k.position,
          dragging: y
        };
        N && R.parentId && b.push({
          id: A,
          parentId: R.parentId,
          rect: {
            ...k.internals.positionAbsolute,
            width: k.measured.width ?? 0,
            height: k.measured.height ?? 0
          }
        }), x.push(D);
      }
      if (b.length > 0) {
        const { parentLookup: A, nodeOrigin: k } = h(), R = Eb(b, E, A, k);
        x.push(...R);
      }
      S(x);
    },
    triggerNodeChanges: (g) => {
      const { onNodesChange: y, setNodes: b, nodes: x, hasDefaultNodes: E, debug: S } = h();
      if (g?.length) {
        if (E) {
          const A = BR(g, x);
          b(A);
        }
        S && console.log("React Flow: trigger node changes", g), y?.(g);
      }
    },
    triggerEdgeChanges: (g) => {
      const { onEdgesChange: y, setEdges: b, edges: x, hasDefaultEdges: E, debug: S } = h();
      if (g?.length) {
        if (E) {
          const A = $R(g, x);
          b(A);
        }
        S && console.log("React Flow: trigger edge changes", g), y?.(g);
      }
    },
    addSelectedNodes: (g) => {
      const { multiSelectionActive: y, edgeLookup: b, nodeLookup: x, triggerNodeChanges: E, triggerEdgeChanges: S } = h();
      if (y) {
        const A = g.map((k) => ya(k, !0));
        E(A);
        return;
      }
      E(Hs(x, /* @__PURE__ */ new Set([...g]), !0)), S(Hs(b));
    },
    addSelectedEdges: (g) => {
      const { multiSelectionActive: y, edgeLookup: b, nodeLookup: x, triggerNodeChanges: E, triggerEdgeChanges: S } = h();
      if (y) {
        const A = g.map((k) => ya(k, !0));
        S(A);
        return;
      }
      S(Hs(b, /* @__PURE__ */ new Set([...g]))), E(Hs(x, /* @__PURE__ */ new Set(), !0));
    },
    unselectNodesAndEdges: ({ nodes: g, edges: y } = {}) => {
      const { edges: b, nodes: x, nodeLookup: E, triggerNodeChanges: S, triggerEdgeChanges: A } = h(), k = g || x, R = y || b, N = k.map((P) => {
        const F = E.get(P.id);
        return F && (F.selected = !1), ya(P.id, !1);
      }), D = R.map((P) => ya(P.id, !1));
      S(N), A(D);
    },
    setMinZoom: (g) => {
      const { panZoom: y, maxZoom: b } = h();
      y?.setScaleExtent([g, b]), d({ minZoom: g });
    },
    setMaxZoom: (g) => {
      const { panZoom: y, minZoom: b } = h();
      y?.setScaleExtent([b, g]), d({ maxZoom: g });
    },
    setTranslateExtent: (g) => {
      h().panZoom?.setTranslateExtent(g), d({ translateExtent: g });
    },
    setPaneClickDistance: (g) => {
      h().panZoom?.setClickDistance(g);
    },
    resetSelectedElements: () => {
      const { edges: g, nodes: y, triggerNodeChanges: b, triggerEdgeChanges: x } = h(), E = y.reduce((A, k) => k.selected ? [...A, ya(k.id, !1)] : A, []), S = g.reduce((A, k) => k.selected ? [...A, ya(k.id, !1)] : A, []);
      b(E), x(S);
    },
    setNodeExtent: (g) => {
      const { nodes: y, nodeLookup: b, parentLookup: x, nodeOrigin: E, elevateNodesOnSelect: S, nodeExtent: A } = h();
      g[0][0] === A[0][0] && g[0][1] === A[0][1] && g[1][0] === A[1][0] && g[1][1] === A[1][1] || (Zy(y, b, x, {
        nodeOrigin: E,
        nodeExtent: g,
        elevateNodesOnSelect: S,
        checkEquality: !1
      }), d({ nodeExtent: g }));
    },
    panBy: (g) => {
      const { transform: y, width: b, height: x, panZoom: E, translateExtent: S } = h();
      return lL({ delta: g, panZoom: E, transform: y, translateExtent: S, width: b, height: x });
    },
    cancelConnection: () => {
      d({
        connection: { ...sR }
      });
    },
    updateConnection: (g) => {
      d({ connection: g });
    },
    reset: () => d({ ...ZE() })
  };
}, Object.is);
function b9({ initialNodes: e, initialEdges: t, defaultNodes: n, defaultEdges: r, initialWidth: i, initialHeight: a, fitView: s, nodeOrigin: u, nodeExtent: f, children: d }) {
  const [h] = C.useState(() => v9({
    nodes: e,
    edges: t,
    defaultNodes: n,
    defaultEdges: r,
    width: i,
    height: a,
    fitView: s,
    nodeOrigin: u,
    nodeExtent: f
  }));
  return _.jsx(LL, { value: h, children: _.jsx(s8, { children: d }) });
}
function x9({ children: e, nodes: t, edges: n, defaultNodes: r, defaultEdges: i, width: a, height: s, fitView: u, nodeOrigin: f, nodeExtent: d }) {
  return C.useContext(dp) ? _.jsx(_.Fragment, { children: e }) : _.jsx(b9, { initialNodes: t, initialEdges: n, defaultNodes: r, defaultEdges: i, initialWidth: a, initialHeight: s, fitView: u, nodeOrigin: f, nodeExtent: d, children: e });
}
const w9 = {
  width: "100%",
  height: "100%",
  overflow: "hidden",
  position: "relative",
  zIndex: 0
};
function S9({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, className: i, nodeTypes: a, edgeTypes: s, onNodeClick: u, onEdgeClick: f, onInit: d, onMove: h, onMoveStart: p, onMoveEnd: g, onConnect: y, onConnectStart: b, onConnectEnd: x, onClickConnectStart: E, onClickConnectEnd: S, onNodeMouseEnter: A, onNodeMouseMove: k, onNodeMouseLeave: R, onNodeContextMenu: N, onNodeDoubleClick: D, onNodeDragStart: P, onNodeDrag: F, onNodeDragStop: V, onNodesDelete: T, onEdgesDelete: $, onDelete: H, onSelectionChange: G, onSelectionDragStart: j, onSelectionDrag: U, onSelectionDragStop: z, onSelectionContextMenu: B, onSelectionStart: q, onSelectionEnd: Y, onBeforeDelete: O, connectionMode: W, connectionLineType: Z = Po.Bezier, connectionLineStyle: I, connectionLineComponent: ie, connectionLineContainerStyle: fe, deleteKeyCode: re = "Backspace", selectionKeyCode: le = "Shift", selectionOnDrag: he = !1, selectionMode: ye = uc.Full, panActivationKeyCode: je = "Space", multiSelectionKeyCode: Oe = kh() ? "Meta" : "Control", zoomActivationKeyCode: be = kh() ? "Meta" : "Control", snapToGrid: Le, snapGrid: Ie, onlyRenderVisibleElements: ft = !1, selectNodesOnDrag: Jt, nodesDraggable: bt, nodesConnectable: Ln, nodesFocusable: xr, nodeOrigin: En = LR, edgesFocusable: ir, edgesReconnectable: Pe, elementsSelectable: Lr = !0, defaultViewport: Ko = ZL, minZoom: hi = 0.5, maxZoom: ae = 2, translateExtent: pe = lc, preventScrolling: Ce = !0, nodeExtent: Ae, defaultMarkerColor: Je = "#b1b1b7", zoomOnScroll: gn = !0, zoomOnPinch: wr = !0, panOnScroll: an = !1, panOnScrollSpeed: or = 0.5, panOnScrollMode: yn = ka.Free, zoomOnDoubleClick: jt = !0, panOnDrag: Cn = !0, onPaneClick: Fn, onPaneMouseEnter: Jc, onPaneMouseMove: ef, onPaneMouseLeave: Al, onPaneScroll: Zo, onPaneContextMenu: fm, paneClickDistance: Tl = 0, nodeClickDistance: tf = 0, children: Rl, onReconnect: Ol, onReconnectStart: nf, onReconnectEnd: dm, onEdgeContextMenu: Fr, onEdgeDoubleClick: Xt, onEdgeMouseEnter: sn, onEdgeMouseMove: eo, onEdgeMouseLeave: Nl, reconnectRadius: hm = 10, onNodesChange: pm, onEdgesChange: rf, noDragClassName: Qo = "nodrag", noWheelClassName: Ml = "nowheel", noPanClassName: pi = "nopan", fitView: mi, fitViewOptions: Jo, connectOnClick: to, attributionPosition: It, proOptions: of, defaultEdgeOptions: af, elevateNodesOnSelect: gi, elevateEdgesOnSelect: no, disableKeyboardA11y: sf = !1, autoPanOnConnect: lf, autoPanOnNodeDrag: uf, autoPanSpeed: mm, connectionRadius: Va, isValidConnection: Ua, onError: Sr, style: Dl, id: Pl, nodeDragThreshold: ro, viewport: zl, onViewportChange: jl, width: gm, height: cf, colorMode: kn = "light", debug: ff, onScroll: df, ...qa }, hf) {
  const io = Pl || "1", ym = t8(kn), An = C.useCallback((Ya) => {
    Ya.currentTarget.scrollTo({ top: 0, left: 0, behavior: "instant" }), df?.(Ya);
  }, [df]);
  return _.jsx("div", { "data-testid": "rf__wrapper", ...qa, onScroll: An, style: { ...Dl, ...w9 }, ref: hf, className: qt(["react-flow", i, ym]), id: Pl, children: _.jsxs(x9, { nodes: e, edges: t, width: gm, height: cf, fitView: mi, nodeOrigin: En, nodeExtent: Ae, children: [_.jsx(y9, { onInit: d, onNodeClick: u, onEdgeClick: f, onNodeMouseEnter: A, onNodeMouseMove: k, onNodeMouseLeave: R, onNodeContextMenu: N, onNodeDoubleClick: D, nodeTypes: a, edgeTypes: s, connectionLineType: Z, connectionLineStyle: I, connectionLineComponent: ie, connectionLineContainerStyle: fe, selectionKeyCode: le, selectionOnDrag: he, selectionMode: ye, deleteKeyCode: re, multiSelectionKeyCode: Oe, panActivationKeyCode: je, zoomActivationKeyCode: be, onlyRenderVisibleElements: ft, defaultViewport: Ko, translateExtent: pe, minZoom: hi, maxZoom: ae, preventScrolling: Ce, zoomOnScroll: gn, zoomOnPinch: wr, zoomOnDoubleClick: jt, panOnScroll: an, panOnScrollSpeed: or, panOnScrollMode: yn, panOnDrag: Cn, onPaneClick: Fn, onPaneMouseEnter: Jc, onPaneMouseMove: ef, onPaneMouseLeave: Al, onPaneScroll: Zo, onPaneContextMenu: fm, paneClickDistance: Tl, nodeClickDistance: tf, onSelectionContextMenu: B, onSelectionStart: q, onSelectionEnd: Y, onReconnect: Ol, onReconnectStart: nf, onReconnectEnd: dm, onEdgeContextMenu: Fr, onEdgeDoubleClick: Xt, onEdgeMouseEnter: sn, onEdgeMouseMove: eo, onEdgeMouseLeave: Nl, reconnectRadius: hm, defaultMarkerColor: Je, noDragClassName: Qo, noWheelClassName: Ml, noPanClassName: pi, rfId: io, disableKeyboardA11y: sf, nodeExtent: Ae, viewport: zl, onViewportChange: jl }), _.jsx(e8, { nodes: e, edges: t, defaultNodes: n, defaultEdges: r, onConnect: y, onConnectStart: b, onConnectEnd: x, onClickConnectStart: E, onClickConnectEnd: S, nodesDraggable: bt, nodesConnectable: Ln, nodesFocusable: xr, edgesFocusable: ir, edgesReconnectable: Pe, elementsSelectable: Lr, elevateNodesOnSelect: gi, elevateEdgesOnSelect: no, minZoom: hi, maxZoom: ae, nodeExtent: Ae, onNodesChange: pm, onEdgesChange: rf, snapToGrid: Le, snapGrid: Ie, connectionMode: W, translateExtent: pe, connectOnClick: to, defaultEdgeOptions: af, fitView: mi, fitViewOptions: Jo, onNodesDelete: T, onEdgesDelete: $, onDelete: H, onNodeDragStart: P, onNodeDrag: F, onNodeDragStop: V, onSelectionDrag: U, onSelectionDragStart: j, onSelectionDragStop: z, onMove: h, onMoveStart: p, onMoveEnd: g, noPanClassName: pi, nodeOrigin: En, rfId: io, autoPanOnConnect: lf, autoPanOnNodeDrag: uf, autoPanSpeed: mm, onError: Sr, connectionRadius: Va, isValidConnection: Ua, selectNodesOnDrag: Jt, nodeDragThreshold: ro, onBeforeDelete: O, paneClickDistance: Tl, debug: ff }), _.jsx(KL, { onSelectionChange: G }), Rl, _.jsx(qL, { proOptions: of, position: It }), _.jsx(VL, { rfId: io, disableKeyboardA11y: sf })] }) });
}
var _9 = HR(S9);
const E9 = (e) => e.nodes;
function C9() {
  return We(E9, _t);
}
const k9 = (e) => e.edges;
function A9() {
  return We(k9, _t);
}
function T9({ dimensions: e, lineWidth: t, variant: n, className: r }) {
  return _.jsx("path", { strokeWidth: t, d: `M${e[0] / 2} 0 V${e[1]} M0 ${e[1] / 2} H${e[0]}`, className: qt(["react-flow__background-pattern", n, r]) });
}
function R9({ radius: e, className: t }) {
  return _.jsx("circle", { cx: e, cy: e, r: e, className: qt(["react-flow__background-pattern", "dots", t]) });
}
var Fo;
(function(e) {
  e.Lines = "lines", e.Dots = "dots", e.Cross = "cross";
})(Fo || (Fo = {}));
const O9 = {
  [Fo.Dots]: 1,
  [Fo.Lines]: 1,
  [Fo.Cross]: 6
}, N9 = (e) => ({ transform: e.transform, patternId: `pattern-${e.rfId}` });
function dO({
  id: e,
  variant: t = Fo.Dots,
  // only used for dots and cross
  gap: n = 20,
  // only used for lines and cross
  size: r,
  lineWidth: i = 1,
  offset: a = 0,
  color: s,
  bgColor: u,
  style: f,
  className: d,
  patternClassName: h
}) {
  const p = C.useRef(null), { transform: g, patternId: y } = We(N9, _t), b = r || O9[t], x = t === Fo.Dots, E = t === Fo.Cross, S = Array.isArray(n) ? n : [n, n], A = [S[0] * g[2] || 1, S[1] * g[2] || 1], k = b * g[2], R = Array.isArray(a) ? a : [a, a], N = E ? [k, k] : A, D = [
    R[0] * g[2] || 1 + N[0] / 2,
    R[1] * g[2] || 1 + N[1] / 2
  ], P = `${y}${e || ""}`;
  return _.jsxs("svg", { className: qt(["react-flow__background", d]), style: {
    ...f,
    ...pp,
    "--xy-background-color-props": u,
    "--xy-background-pattern-color-props": s
  }, ref: p, "data-testid": "rf__background", children: [_.jsx("pattern", { id: P, x: g[0] % A[0], y: g[1] % A[1], width: A[0], height: A[1], patternUnits: "userSpaceOnUse", patternTransform: `translate(-${D[0]},-${D[1]})`, children: x ? _.jsx(R9, { radius: k / 2, className: h }) : _.jsx(T9, { dimensions: N, lineWidth: i, variant: t, className: h }) }), _.jsx("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: `url(#${P})` })] });
}
dO.displayName = "Background";
const M9 = C.memo(dO);
function D9() {
  return _.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", children: _.jsx("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" }) });
}
function P9() {
  return _.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 5", children: _.jsx("path", { d: "M0 0h32v4.2H0z" }) });
}
function z9() {
  return _.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 30", children: _.jsx("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" }) });
}
function j9() {
  return _.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: _.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" }) });
}
function I9() {
  return _.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: _.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z" }) });
}
function Td({ children: e, className: t, ...n }) {
  return _.jsx("button", { type: "button", className: qt(["react-flow__controls-button", t]), ...n, children: e });
}
const L9 = (e) => ({
  isInteractive: e.nodesDraggable || e.nodesConnectable || e.elementsSelectable,
  minZoomReached: e.transform[2] <= e.minZoom,
  maxZoomReached: e.transform[2] >= e.maxZoom
});
function hO({ style: e, showZoom: t = !0, showFitView: n = !0, showInteractive: r = !0, fitViewOptions: i, onZoomIn: a, onZoomOut: s, onFitView: u, onInteractiveChange: f, className: d, children: h, position: p = "bottom-left", orientation: g = "vertical", "aria-label": y = "React Flow controls" }) {
  const b = Ct(), { isInteractive: x, minZoomReached: E, maxZoomReached: S } = We(L9, _t), { zoomIn: A, zoomOut: k, fitView: R } = zc(), N = () => {
    A(), a?.();
  }, D = () => {
    k(), s?.();
  }, P = () => {
    R(i), u?.();
  }, F = () => {
    b.setState({
      nodesDraggable: !x,
      nodesConnectable: !x,
      elementsSelectable: !x
    }), f?.(!x);
  }, V = g === "horizontal" ? "horizontal" : "vertical";
  return _.jsxs(hp, { className: qt(["react-flow__controls", V, d]), position: p, style: e, "data-testid": "rf__controls", "aria-label": y, children: [t && _.jsxs(_.Fragment, { children: [_.jsx(Td, { onClick: N, className: "react-flow__controls-zoomin", title: "zoom in", "aria-label": "zoom in", disabled: S, children: _.jsx(D9, {}) }), _.jsx(Td, { onClick: D, className: "react-flow__controls-zoomout", title: "zoom out", "aria-label": "zoom out", disabled: E, children: _.jsx(P9, {}) })] }), n && _.jsx(Td, { className: "react-flow__controls-fitview", onClick: P, title: "fit view", "aria-label": "fit view", children: _.jsx(z9, {}) }), r && _.jsx(Td, { className: "react-flow__controls-interactive", onClick: F, title: "toggle interactivity", "aria-label": "toggle interactivity", children: x ? _.jsx(I9, {}) : _.jsx(j9, {}) }), h] });
}
hO.displayName = "Controls";
C.memo(hO);
function F9({ id: e, x: t, y: n, width: r, height: i, style: a, color: s, strokeColor: u, strokeWidth: f, className: d, borderRadius: h, shapeRendering: p, selected: g, onClick: y }) {
  const { background: b, backgroundColor: x } = a || {}, E = s || b || x;
  return _.jsx("rect", { className: qt(["react-flow__minimap-node", { selected: g }, d]), x: t, y: n, rx: h, ry: h, width: r, height: i, style: {
    fill: E,
    stroke: u,
    strokeWidth: f
  }, shapeRendering: p, onClick: y ? (S) => y(S, e) : void 0 });
}
const B9 = C.memo(F9), $9 = (e) => e.nodes.map((t) => t.id), z0 = (e) => e instanceof Function ? e : () => e;
function H9({
  nodeStrokeColor: e,
  nodeColor: t,
  nodeClassName: n = "",
  nodeBorderRadius: r = 5,
  nodeStrokeWidth: i,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent: a = B9,
  onClick: s
}) {
  const u = We($9, _t), f = z0(t), d = z0(e), h = z0(n), p = typeof window > "u" || window.chrome ? "crispEdges" : "geometricPrecision";
  return _.jsx(_.Fragment, { children: u.map((g) => (
    /*
     * The split of responsibilities between MiniMapNodes and
     * NodeComponentWrapper may appear weird. However, its designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For more details, see a similar commit in `NodeRenderer/index.tsx`.
     */
    _.jsx(U9, { id: g, nodeColorFunc: f, nodeStrokeColorFunc: d, nodeClassNameFunc: h, nodeBorderRadius: r, nodeStrokeWidth: i, NodeComponent: a, onClick: s, shapeRendering: p }, g)
  )) });
}
function V9({ id: e, nodeColorFunc: t, nodeStrokeColorFunc: n, nodeClassNameFunc: r, nodeBorderRadius: i, nodeStrokeWidth: a, shapeRendering: s, NodeComponent: u, onClick: f }) {
  const { node: d, x: h, y: p, width: g, height: y } = We((b) => {
    const { internals: x } = b.nodeLookup.get(e), E = x.userNode, { x: S, y: A } = x.positionAbsolute, { width: k, height: R } = Gi(E);
    return {
      node: E,
      x: S,
      y: A,
      width: k,
      height: R
    };
  }, _t);
  return !d || d.hidden || !mR(d) ? null : _.jsx(u, { x: h, y: p, width: g, height: y, style: d.style, selected: !!d.selected, className: r(d), color: t(d), borderRadius: i, strokeColor: n(d), strokeWidth: a, shapeRendering: s, onClick: f, id: d.id });
}
const U9 = C.memo(V9);
var q9 = C.memo(H9);
const Y9 = 200, G9 = 150, X9 = (e) => !e.hidden, W9 = (e) => {
  const t = {
    x: -e.transform[0] / e.transform[2],
    y: -e.transform[1] / e.transform[2],
    width: e.width / e.transform[2],
    height: e.height / e.transform[2]
  };
  return {
    viewBB: t,
    boundingRect: e.nodeLookup.size > 0 ? pR(Mc(e.nodeLookup, { filter: X9 }), t) : t,
    rfId: e.rfId,
    panZoom: e.panZoom,
    translateExtent: e.translateExtent,
    flowWidth: e.width,
    flowHeight: e.height
  };
}, K9 = "react-flow__minimap-desc";
function pO({
  style: e,
  className: t,
  nodeStrokeColor: n,
  nodeColor: r,
  nodeClassName: i = "",
  nodeBorderRadius: a = 5,
  nodeStrokeWidth: s,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent: u,
  bgColor: f,
  maskColor: d,
  maskStrokeColor: h,
  maskStrokeWidth: p,
  position: g = "bottom-right",
  onClick: y,
  onNodeClick: b,
  pannable: x = !1,
  zoomable: E = !1,
  ariaLabel: S = "React Flow mini map",
  inversePan: A,
  zoomStep: k = 10,
  offsetScale: R = 5
}) {
  const N = Ct(), D = C.useRef(null), { boundingRect: P, viewBB: F, rfId: V, panZoom: T, translateExtent: $, flowWidth: H, flowHeight: G } = We(W9, _t), j = e?.width ?? Y9, U = e?.height ?? G9, z = P.width / j, B = P.height / U, q = Math.max(z, B), Y = q * j, O = q * U, W = R * q, Z = P.x - (Y - P.width) / 2 - W, I = P.y - (O - P.height) / 2 - W, ie = Y + W * 2, fe = O + W * 2, re = `${K9}-${V}`, le = C.useRef(0), he = C.useRef();
  le.current = q, C.useEffect(() => {
    if (D.current && T)
      return he.current = gL({
        domNode: D.current,
        panZoom: T,
        getTransform: () => N.getState().transform,
        getViewScale: () => le.current
      }), () => {
        he.current?.destroy();
      };
  }, [T]), C.useEffect(() => {
    he.current?.update({
      translateExtent: $,
      width: H,
      height: G,
      inversePan: A,
      pannable: x,
      zoomStep: k,
      zoomable: E
    });
  }, [x, E, A, k, $, H, G]);
  const ye = y ? (Oe) => {
    const [be, Le] = he.current?.pointer(Oe) || [0, 0];
    y(Oe, { x: be, y: Le });
  } : void 0, je = b ? C.useCallback((Oe, be) => {
    const Le = N.getState().nodeLookup.get(be).internals.userNode;
    b(Oe, Le);
  }, []) : void 0;
  return _.jsx(hp, { position: g, style: {
    ...e,
    "--xy-minimap-background-color-props": typeof f == "string" ? f : void 0,
    "--xy-minimap-mask-background-color-props": typeof d == "string" ? d : void 0,
    "--xy-minimap-mask-stroke-color-props": typeof h == "string" ? h : void 0,
    "--xy-minimap-mask-stroke-width-props": typeof p == "number" ? p * q : void 0,
    "--xy-minimap-node-background-color-props": typeof r == "string" ? r : void 0,
    "--xy-minimap-node-stroke-color-props": typeof n == "string" ? n : void 0,
    "--xy-minimap-node-stroke-width-props": typeof s == "number" ? s : void 0
  }, className: qt(["react-flow__minimap", t]), "data-testid": "rf__minimap", children: _.jsxs("svg", { width: j, height: U, viewBox: `${Z} ${I} ${ie} ${fe}`, className: "react-flow__minimap-svg", role: "img", "aria-labelledby": re, ref: D, onClick: ye, children: [S && _.jsx("title", { id: re, children: S }), _.jsx(q9, { onClick: je, nodeColor: r, nodeStrokeColor: n, nodeBorderRadius: a, nodeClassName: i, nodeStrokeWidth: s, nodeComponent: u }), _.jsx("path", { className: "react-flow__minimap-mask", d: `M${Z - W},${I - W}h${ie + W * 2}v${fe + W * 2}h${-ie - W * 2}z
        M${F.x},${F.y}h${F.width}v${F.height}h${-F.width}z`, fillRule: "evenodd", pointerEvents: "none" })] }) });
}
pO.displayName = "MiniMap";
const Z9 = C.memo(pO);
function Q9({ nodeId: e, position: t, variant: n = Ku.Handle, className: r, style: i = {}, children: a, color: s, minWidth: u = 10, minHeight: f = 10, maxWidth: d = Number.MAX_VALUE, maxHeight: h = Number.MAX_VALUE, keepAspectRatio: p = !1, shouldResize: g, onResizeStart: y, onResize: b, onResizeEnd: x }) {
  const E = YR(), S = typeof e == "string" ? e : E, A = Ct(), k = C.useRef(null), R = n === Ku.Line ? "right" : "bottom-right", N = t ?? R, D = C.useRef(null);
  C.useEffect(() => {
    if (!(!k.current || !S))
      return D.current || (D.current = NL({
        domNode: k.current,
        nodeId: S,
        getStoreItems: () => {
          const { nodeLookup: T, transform: $, snapGrid: H, snapToGrid: G, nodeOrigin: j, domNode: U } = A.getState();
          return {
            nodeLookup: T,
            transform: $,
            snapGrid: H,
            snapToGrid: G,
            nodeOrigin: j,
            paneDomNode: U
          };
        },
        onChange: (T, $) => {
          const { triggerNodeChanges: H, nodeLookup: G, parentLookup: j, nodeOrigin: U } = A.getState(), z = [], B = { x: T.x, y: T.y }, q = G.get(S);
          if (q && q.expandParent && q.parentId) {
            const Y = q.origin ?? U, O = T.width ?? q.measured.width ?? 0, W = T.height ?? q.measured.height ?? 0, Z = {
              id: q.id,
              parentId: q.parentId,
              rect: {
                width: O,
                height: W,
                ...gR({
                  x: T.x ?? q.position.x,
                  y: T.y ?? q.position.y
                }, { width: O, height: W }, q.parentId, G, Y)
              }
            }, I = Eb([Z], G, j, U);
            z.push(...I), B.x = T.x ? Math.max(Y[0] * O, T.x) : void 0, B.y = T.y ? Math.max(Y[1] * W, T.y) : void 0;
          }
          if (B.x !== void 0 && B.y !== void 0) {
            const Y = {
              id: S,
              type: "position",
              position: { ...B }
            };
            z.push(Y);
          }
          if (T.width !== void 0 && T.height !== void 0) {
            const Y = {
              id: S,
              type: "dimensions",
              resizing: !0,
              setAttributes: !0,
              dimensions: {
                width: T.width,
                height: T.height
              }
            };
            z.push(Y);
          }
          for (const Y of $) {
            const O = {
              ...Y,
              type: "position"
            };
            z.push(O);
          }
          H(z);
        },
        onEnd: ({ width: T, height: $ }) => {
          const H = {
            id: S,
            type: "dimensions",
            resizing: !1,
            dimensions: {
              width: T,
              height: $
            }
          };
          A.getState().triggerNodeChanges([H]);
        }
      })), D.current.update({
        controlPosition: N,
        boundaries: {
          minWidth: u,
          minHeight: f,
          maxWidth: d,
          maxHeight: h
        },
        keepAspectRatio: p,
        onResizeStart: y,
        onResize: b,
        onResizeEnd: x,
        shouldResize: g
      }), () => {
        D.current?.destroy();
      };
  }, [
    N,
    u,
    f,
    d,
    h,
    p,
    y,
    b,
    x,
    g
  ]);
  const P = N.split("-"), F = n === Ku.Line ? "borderColor" : "backgroundColor", V = s ? { ...i, [F]: s } : i;
  return _.jsx("div", { className: qt(["react-flow__resize-control", "nodrag", ...P, n, r]), ref: k, style: V, children: a });
}
C.memo(Q9);
const J9 = ({
  on_node_change: e,
  on_edge_change: t,
  on_connect: n
}) => {
  const r = e || ((s) => {
  }), i = n || ((s) => {
  });
  return bn((s, u) => ({
    nodes: [],
    edges: [],
    onNodesChange: (f) => {
      s({
        nodes: BR(f, u().nodes)
      }), r(f);
    },
    onEdgesChange: (f) => {
      s({
        edges: $R(f, u().edges)
      });
    },
    onConnect: (f) => {
      f.source == null || f.target == null || i(f);
    }
  }));
}, QE = ({
  src_nid: e,
  src_ioid: t,
  trg_nid: n,
  trg_ioid: r
}) => [`${e}:${t}`, `${n}:${r}`].sort().join("--");
function eF(e) {
  console.error("Unhandled case: " + e);
}
const tF = (e) => {
  const t = e.v ? Number(e.v) : 0;
  if (t > 0) throw new Error("Plugin version is too new");
  return e;
};
class nF {
  constructor(t) {
    this.iostore = t;
  }
  get connected() {
    return this.iostore.getState().connected;
  }
  set connected(t) {
    this.iostore.setState({ connected: t });
  }
  get does_trigger() {
    return this.iostore.getState().does_trigger;
  }
  set does_trigger(t) {
    this.iostore.setState({ does_trigger: t });
  }
  get full_id() {
    return this.iostore.getState().full_id;
  }
  set full_id(t) {
    this.iostore.setState({ full_id: t });
  }
  get id() {
    return this.iostore.getState().id;
  }
  set id(t) {
    this.iostore.setState({ id: t });
  }
  get is_input() {
    return this.iostore.getState().is_input;
  }
  set is_input(t) {
    this.iostore.setState({ is_input: t });
  }
  get name() {
    return this.iostore.getState().name;
  }
  set name(t) {
    this.iostore.setState({ name: t });
  }
  get node() {
    return this.iostore.getState().node;
  }
  set node(t) {
    this.iostore.setState({ node: t });
  }
  get type() {
    return this.iostore.getState().type;
  }
  set type(t) {
    this.iostore.setState({ type: t });
  }
  get value() {
    return this.iostore.valuestore.getState().preview;
  }
  set value(t) {
    this.iostore.updateValueStore({ preview: t });
  }
  get fullvalue() {
    return this.iostore.valuestore.getState().full;
  }
  set fullvalue(t) {
    this.iostore.updateValueStore({ full: t });
  }
  get render_options() {
    return this.iostore.getState().render_options;
  }
  set render_options(t) {
    this.iostore.setState({ render_options: t });
  }
  get hidden() {
    return this.iostore.getState().hidden;
  }
  set hidden(t) {
    this.iostore.setState({ hidden: t });
  }
  get try_get_full_value() {
    return this.iostore.getState().try_get_full_value;
  }
  get set_hidden() {
    return this.iostore.getState().set_hidden;
  }
}
const As = (e) => (t) => {
  const { iostore: n, ...r } = t, i = new nF(n);
  return e({ ...r, io: i });
}, rF = (e) => {
  const t = e.v ? Number(e.v) : 0;
  if (t > 1) throw new Error("Plugin version is too new");
  if (t === 1) return e;
  const n = tF(e);
  return { ...n, renderpluginfactory: (i) => {
    const a = n.renderpluginfactory?.(i) || {}, s = n.RendererPlugin || {}, u = Object.keys({ ...s, ...a }), f = {};
    for (const d of u)
      switch (d) {
        case "input_renderers":
          const h = {};
          for (const [E, S] of Object.entries(s.input_renderers || {}))
            S !== void 0 && (h[E] = As(S));
          f.input_renderers = h;
          break;
        case "output_renderers":
          const p = {};
          for (const [E, S] of Object.entries(
            s.output_renderers || {}
          ))
            S !== void 0 && (p[E] = As(S));
          f.output_renderers = p;
          break;
        case "handle_preview_renderers":
          const g = {};
          for (const [E, S] of Object.entries(
            s.handle_preview_renderers || {}
          ))
            S !== void 0 && (g[E] = As(S));
          f.handle_preview_renderers = g;
          break;
        case "data_overlay_renderers":
          const y = {};
          for (const [E, S] of Object.entries(
            s.data_overlay_renderers || {}
          ))
            S !== void 0 && (y[E] = As(S));
          f.data_overlay_renderers = y;
          break;
        case "data_preview_renderers":
          const b = {};
          for (const [E, S] of Object.entries(
            s.data_preview_renderers || {}
          ))
            S !== void 0 && (b[E] = As(S));
          f.data_preview_renderers = b;
          break;
        case "data_view_renderers":
          const x = {};
          for (const [E, S] of Object.entries(
            s.data_view_renderers || {}
          ))
            S !== void 0 && (x[E] = As(S));
          f.data_view_renderers = x;
          break;
        default:
          eF(d);
      }
    return f;
  }, v: 1 };
}, iF = (e) => rF(e), Dn = {
  DEBUG: 0,
  INFO: 10,
  WARN: 20,
  ERROR: 30
}, oF = Dn.INFO, JE = (e) => typeof e == "string" ? e : e === Dn.DEBUG ? "DEBUG" : e === Dn.INFO ? "INFO" : e === Dn.WARN ? "WARN" : e === Dn.ERROR ? "ERROR" : "UNKNOWN";
function aF() {
  const e = [];
  return function(t, n) {
    if (typeof n != "object" || n === null)
      return n;
    for (; e.length > 0 && e.at(-1) !== this; )
      e.pop();
    return e.includes(n) ? "[Circular]" : (e.push(n), n);
  };
}
const sF = (e) => {
  if (typeof e == "number") return e;
  const t = e.toLowerCase();
  if (t === "debug") return Dn.DEBUG;
  if (t === "info") return Dn.INFO;
  if (t === "warn" || t === "warning") return Dn.WARN;
  if (t === "error") return Dn.ERROR;
  throw new Error(`Unknown log level: ${e}`);
};
class mO {
  constructor(t, n = Dn.INFO) {
    this.name = t, this.level = sF(n), this._level_name = JE(n);
  }
  set_level(t) {
    this.level = t, this._level_name = JE(t);
  }
  _fomat_message(t, ...n) {
    return `[${this.name}] ${this._level_name}: ${t} ${n.map((r) => JSON.stringify(r, aF())).join(" ")}`;
  }
  debug(t, ...n) {
    this.level <= Dn.DEBUG && console.debug(this._fomat_message(t, ...n));
  }
  info(t, ...n) {
    this.level <= Dn.INFO && console.info(this._fomat_message(t, ...n));
  }
  warn(t, ...n) {
    this.level <= Dn.WARN && console.warn(this._fomat_message(t, ...n));
  }
  error(t, ...n) {
    this.level <= Dn.ERROR && console.error(this._fomat_message(t, ...n));
  }
}
const ev = !1, lF = (e, t) => {
  const n = e.properties || {};
  n["frontend:size"] || (n["frontend:size"] = [200, 100]);
  const r = n["frontend:pos"];
  if (!r || r.length !== 2 || isNaN(r[0]) || r[0] === null || isNaN(r[1]) || r[1] === null)
    if (!t || !t.rf_instance || t.reactflowRef === null)
      n["frontend:pos"] = [0, 0];
    else {
      const a = t.reactflowRef.getBoundingClientRect(), s = a.left + a.width / 2, u = a.top + a.height / 2, f = t.rf_instance.screenToFlowPosition({
        x: s,
        y: u
      });
      n["frontend:pos"] = [
        f.x - n["frontend:size"][0] / 2,
        f.y - n["frontend:size"][0] / 2
      ];
    }
  n["frontend:collapsed"] || (n["frontend:collapsed"] = !1), e.properties = n;
}, uF = (e, t) => {
  const n = e.getState();
  if (lF(n, t), n.id === void 0)
    throw new Error("Node must have an id");
  const r = {
    nodestore: e
  };
  return {
    position: {
      x: n.properties["frontend:pos"][0],
      y: n.properties["frontend:pos"][1]
    },
    data: r,
    type: "default",
    ...n
  };
}, gO = (e) => {
  const t = {
    ...e
  }, n = (A) => {
    const k = g.getState();
    if (A.from_remote) {
      let R = y.get_node(A.node.id, !1);
      if (R)
        return;
      if (!R)
        try {
          R = a6(S, A.node), y.nodesstates.set(A.node.id, R);
        } catch (P) {
          S.logger.error(`Failed to create node store ${P}`);
          return;
        }
      const N = R.getState();
      S.logger.info("Add node", N.id, N.name);
      const D = [...k.nodes, uF(R, S)];
      g.setState({ nodes: D });
      for (const P in A.node.io) {
        const F = A.node.io[P].id;
        F !== void 0 && S.worker?.get_io_value({ nid: A.node.id, ioid: F });
      }
      setTimeout(() => {
        S.worker?.call_hooks("node_added", { node: N.id });
      }, 0);
    }
  }, r = (A) => {
    if (A.node.in_trigger && (A.node.error = void 0), A.from_remote) {
      const k = y.get_node(A.id, !1);
      if (!k) {
        console.error("Node not found to update", A.id);
        return;
      }
      k.update(A.node);
    } else
      S.worker && S.worker.locally_update_node(A);
  }, i = (A) => {
    S.logger.info("Deleting node", A.id), A.from_remote ? g.getState().onNodesChange([
      {
        type: "remove",
        id: A.id
      }
    ]) : S.worker?.remove_node(A.id);
  }, a = (A) => {
    S.logger.error("Error", A), u({
      type: "update",
      id: A.id,
      node: {
        in_trigger: !1,
        error: A.error
      },
      from_remote: !0
    });
  }, s = (A) => {
    A.from_remote ? u({
      type: "update",
      id: A.id,
      node: {
        in_trigger: !0,
        error: void 0
      },
      from_remote: !0
    }) : S.worker?.trigger_node(A.id);
  }, u = (A) => {
    switch (A.type) {
      case "add":
        n(A);
        break;
      case "update":
        r(A);
        break;
      case "delete":
        i(A);
        break;
      case "error":
        a(A);
        break;
      case "trigger":
        s(A);
        break;
      default:
        S.logger.error("Unknown node action", A);
    }
  }, f = (A) => {
    const k = g.getState();
    switch (A.type) {
      case "add":
        if (A.from_remote) {
          const R = k.edges, N = QE(A);
          if (R.some((P) => P.id === N))
            return;
          const D = {
            id: N,
            source: A.src_nid,
            target: A.trg_nid,
            sourceHandle: A.src_ioid,
            targetHandle: A.trg_ioid,
            className: "funcnodes-edge animated"
          };
          S.logger.info("Adding edge", D), g.setState({ edges: [...R, D] }), S.worker?.get_remote_node_state(A.src_nid), S.worker?.get_remote_node_state(A.trg_nid);
        }
        break;
      case "delete":
        if (A.from_remote) {
          const R = k.edges, N = QE(A);
          S.logger.info("Deleting edge", N);
          const D = R.filter((P) => P.id !== N);
          g.setState({ edges: D }), S.worker?.get_remote_node_state(A.src_nid), S.worker?.get_remote_node_state(A.trg_nid);
        }
        break;
      default:
        S.logger.error("Unknown edge action", A);
    }
  }, g = J9({
    on_node_change: (A) => {
      for (const k of A)
        switch (k.type) {
          case "position":
            k.position && u({
              type: "update",
              id: k.id,
              node: {
                properties: {
                  "frontend:pos": [k.position.x, k.position.y]
                }
              },
              from_remote: !1
            });
            break;
          case "dimensions":
            k.dimensions && u({
              type: "update",
              id: k.id,
              node: {
                properties: {
                  "frontend:size": [
                    k.dimensions.width,
                    k.dimensions.height
                  ]
                }
              },
              from_remote: !1
            });
            break;
        }
    },
    on_edge_change: (A) => {
    },
    on_connect: (A) => {
      A.source === null || A.target === null || A.sourceHandle === null || A.targetHandle === null || !S.worker || S.worker.add_edge({
        src_nid: A.source,
        src_ioid: A.sourceHandle,
        trg_nid: A.target,
        trg_ioid: A.targetHandle,
        replace: !0
      });
    }
  }), y = YP({}), b = qP(), x = () => {
    S.worker?.disconnect(), S.set_worker(void 0), S.workermanager?.setWorker(void 0), S.lib.libstate.getState().set({ lib: { shelves: [] }, external_worker: [] }), S.nodespace.nodesstates.clear(), S.useReactFlowStore.setState({ nodes: [], edges: [] }), S.auto_progress();
  }, E = (A) => {
    if (!S.rf_instance)
      return;
    A = Array.isArray(A) ? A : [A];
    const k = S.useReactFlowStore.getState().nodes.filter((R) => A.includes(R.id));
    k.length > 0 && S.rf_instance?.fitView({ padding: 0.2, nodes: k });
  }, S = {
    local_settings: bn((A, k) => ({
      view_settings: {},
      update_view_settings: (R) => {
        const N = S.local_settings.getState().view_settings, { new_obj: D, change: P } = Or(N, R);
        P && S.local_settings.setState((F) => ({
          ...F,
          view_settings: D
        }));
      }
    })),
    local_state: bn((A, k) => ({
      selected_nodes: [],
      selected_edges: [],
      funcnodescontainerRef: null
    })),
    options: t,
    lib: b,
    workermanager: void 0,
    workers: bn((A, k) => ({})),
    workerstate: bn((A, k) => ({
      is_open: !1
    })),
    render_options: bn((A, k) => ({})),
    progress_state: bn((A, k) => ({
      message: "please select worker",
      status: "info",
      progress: 0,
      blocking: !1
    })),
    update_render_options: (A) => {
      const k = S.render_options.getState(), { new_obj: R, change: N } = Or(k, A);
      N && S.render_options.setState(R);
    },
    worker: void 0,
    _unsubscribeFromWorker: void 0,
    set_worker: (A) => {
      A !== S.worker && (S._unsubscribeFromWorker && (S._unsubscribeFromWorker(), S._unsubscribeFromWorker = void 0), A && (S._unsubscribeFromWorker = A.state.subscribe((k) => {
        S.workerstate.setState(k);
      }), S.workerstate.setState(A.state.getState())), S.worker = A, A?.set_zustand(S));
    },
    nodespace: y,
    useReactFlowStore: g,
    on_node_action: u,
    on_edge_action: f,
    reactflowRef: null,
    clear_all: x,
    center_node: E,
    center_all: () => {
      console.log("center all", S.rf_instance), S.rf_instance?.fitView({ padding: 0.2 });
    },
    set_progress: (A) => {
      if (A.message === "")
        return S.auto_progress();
      const k = S.progress_state.getState(), { new_obj: R, change: N } = Or(
        k,
        A
      );
      N && S.progress_state.setState(R);
    },
    auto_progress: () => {
      if (S.workermanager !== void 0 && !S.workermanager.open)
        return S.set_progress({
          progress: 0,
          message: "connecting to worker manager",
          status: "error",
          blocking: !1
        });
      if (S.worker === void 0)
        return S.set_progress({
          progress: 0,
          message: "please select worker",
          status: "error",
          blocking: !1
        });
      if (!S.worker.is_open)
        return S.set_progress({
          progress: 0,
          message: "connecting to worker",
          status: "info",
          blocking: !0
        });
      S.set_progress({
        progress: 1,
        message: "running",
        status: "info",
        blocking: !1
      });
    },
    plugins: bn((A, k) => ({})),
    add_plugin: (A, k) => {
      if (k === void 0) return;
      const R = iF(k);
      S.plugins.setState((N) => ({ ...N, [A]: R }));
    },
    dev_settings: {
      debug: !0
    },
    logger: new mO("fn", oF)
  };
  return S;
};
function yO(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: cF } = Object.prototype, { getPrototypeOf: kb } = Object, mp = /* @__PURE__ */ ((e) => (t) => {
  const n = cF.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), jr = (e) => (e = e.toLowerCase(), (t) => mp(t) === e), gp = (e) => (t) => typeof t === e, { isArray: ml } = Array, hc = gp("undefined");
function fF(e) {
  return e !== null && !hc(e) && e.constructor !== null && !hc(e.constructor) && Zn(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const vO = jr("ArrayBuffer");
function dF(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && vO(e.buffer), t;
}
const hF = gp("string"), Zn = gp("function"), bO = gp("number"), yp = (e) => e !== null && typeof e == "object", pF = (e) => e === !0 || e === !1, eh = (e) => {
  if (mp(e) !== "object")
    return !1;
  const t = kb(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, mF = jr("Date"), gF = jr("File"), yF = jr("Blob"), vF = jr("FileList"), bF = (e) => yp(e) && Zn(e.pipe), xF = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || Zn(e.append) && ((t = mp(e)) === "formdata" || // detect form-data instance
  t === "object" && Zn(e.toString) && e.toString() === "[object FormData]"));
}, wF = jr("URLSearchParams"), [SF, _F, EF, CF] = ["ReadableStream", "Request", "Response", "Headers"].map(jr), kF = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Ic(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let r, i;
  if (typeof e != "object" && (e = [e]), ml(e))
    for (r = 0, i = e.length; r < i; r++)
      t.call(null, e[r], r, e);
  else {
    const a = n ? Object.getOwnPropertyNames(e) : Object.keys(e), s = a.length;
    let u;
    for (r = 0; r < s; r++)
      u = a[r], t.call(null, e[u], u, e);
  }
}
function xO(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let r = n.length, i;
  for (; r-- > 0; )
    if (i = n[r], t === i.toLowerCase())
      return i;
  return null;
}
const wa = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : window, wO = (e) => !hc(e) && e !== wa;
function tv() {
  const { caseless: e } = wO(this) && this || {}, t = {}, n = (r, i) => {
    const a = e && xO(t, i) || i;
    eh(t[a]) && eh(r) ? t[a] = tv(t[a], r) : eh(r) ? t[a] = tv({}, r) : ml(r) ? t[a] = r.slice() : t[a] = r;
  };
  for (let r = 0, i = arguments.length; r < i; r++)
    arguments[r] && Ic(arguments[r], n);
  return t;
}
const AF = (e, t, n, { allOwnKeys: r } = {}) => (Ic(t, (i, a) => {
  n && Zn(i) ? e[a] = yO(i, n) : e[a] = i;
}, { allOwnKeys: r }), e), TF = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), RF = (e, t, n, r) => {
  e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, OF = (e, t, n, r) => {
  let i, a, s;
  const u = {};
  if (t = t || {}, e == null) return t;
  do {
    for (i = Object.getOwnPropertyNames(e), a = i.length; a-- > 0; )
      s = i[a], (!r || r(s, e, t)) && !u[s] && (t[s] = e[s], u[s] = !0);
    e = n !== !1 && kb(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, NF = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const r = e.indexOf(t, n);
  return r !== -1 && r === n;
}, MF = (e) => {
  if (!e) return null;
  if (ml(e)) return e;
  let t = e.length;
  if (!bO(t)) return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, DF = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && kb(Uint8Array)), PF = (e, t) => {
  const r = (e && e[Symbol.iterator]).call(e);
  let i;
  for (; (i = r.next()) && !i.done; ) {
    const a = i.value;
    t.call(e, a[0], a[1]);
  }
}, zF = (e, t) => {
  let n;
  const r = [];
  for (; (n = e.exec(t)) !== null; )
    r.push(n);
  return r;
}, jF = jr("HTMLFormElement"), IF = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, r, i) {
    return r.toUpperCase() + i;
  }
), eC = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), LF = jr("RegExp"), SO = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), r = {};
  Ic(n, (i, a) => {
    let s;
    (s = t(i, a, e)) !== !1 && (r[a] = s || i);
  }), Object.defineProperties(e, r);
}, FF = (e) => {
  SO(e, (t, n) => {
    if (Zn(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = e[n];
    if (Zn(r)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, BF = (e, t) => {
  const n = {}, r = (i) => {
    i.forEach((a) => {
      n[a] = !0;
    });
  };
  return ml(e) ? r(e) : r(String(e).split(t)), n;
}, $F = () => {
}, HF = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
function VF(e) {
  return !!(e && Zn(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const UF = (e) => {
  const t = new Array(10), n = (r, i) => {
    if (yp(r)) {
      if (t.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        t[i] = r;
        const a = ml(r) ? [] : {};
        return Ic(r, (s, u) => {
          const f = n(s, i + 1);
          !hc(f) && (a[u] = f);
        }), t[i] = void 0, a;
      }
    }
    return r;
  };
  return n(e, 0);
}, qF = jr("AsyncFunction"), YF = (e) => e && (yp(e) || Zn(e)) && Zn(e.then) && Zn(e.catch), _O = ((e, t) => e ? setImmediate : t ? ((n, r) => (wa.addEventListener("message", ({ source: i, data: a }) => {
  i === wa && a === n && r.length && r.shift()();
}, !1), (i) => {
  r.push(i), wa.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  Zn(wa.postMessage)
), GF = typeof queueMicrotask < "u" ? queueMicrotask.bind(wa) : typeof process < "u" && process.nextTick || _O, oe = {
  isArray: ml,
  isArrayBuffer: vO,
  isBuffer: fF,
  isFormData: xF,
  isArrayBufferView: dF,
  isString: hF,
  isNumber: bO,
  isBoolean: pF,
  isObject: yp,
  isPlainObject: eh,
  isReadableStream: SF,
  isRequest: _F,
  isResponse: EF,
  isHeaders: CF,
  isUndefined: hc,
  isDate: mF,
  isFile: gF,
  isBlob: yF,
  isRegExp: LF,
  isFunction: Zn,
  isStream: bF,
  isURLSearchParams: wF,
  isTypedArray: DF,
  isFileList: vF,
  forEach: Ic,
  merge: tv,
  extend: AF,
  trim: kF,
  stripBOM: TF,
  inherits: RF,
  toFlatObject: OF,
  kindOf: mp,
  kindOfTest: jr,
  endsWith: NF,
  toArray: MF,
  forEachEntry: PF,
  matchAll: zF,
  isHTMLForm: jF,
  hasOwnProperty: eC,
  hasOwnProp: eC,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: SO,
  freezeMethods: FF,
  toObjectSet: BF,
  toCamelCase: IF,
  noop: $F,
  toFiniteNumber: HF,
  findKey: xO,
  global: wa,
  isContextDefined: wO,
  isSpecCompliantForm: VF,
  toJSONObject: UF,
  isAsyncFn: qF,
  isThenable: YF,
  setImmediate: _O,
  asap: GF
};
function Be(e, t, n, r, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), i && (this.response = i, this.status = i.status ? i.status : null);
}
oe.inherits(Be, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: oe.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const EO = Be.prototype, CO = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  CO[e] = { value: e };
});
Object.defineProperties(Be, CO);
Object.defineProperty(EO, "isAxiosError", { value: !0 });
Be.from = (e, t, n, r, i, a) => {
  const s = Object.create(EO);
  return oe.toFlatObject(e, s, function(f) {
    return f !== Error.prototype;
  }, (u) => u !== "isAxiosError"), Be.call(s, e.message, t, n, r, i), s.cause = e, s.name = e.name, a && Object.assign(s, a), s;
};
const XF = null;
function nv(e) {
  return oe.isPlainObject(e) || oe.isArray(e);
}
function kO(e) {
  return oe.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function tC(e, t, n) {
  return e ? e.concat(t).map(function(i, a) {
    return i = kO(i), !n && a ? "[" + i + "]" : i;
  }).join(n ? "." : "") : t;
}
function WF(e) {
  return oe.isArray(e) && !e.some(nv);
}
const KF = oe.toFlatObject(oe, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function vp(e, t, n) {
  if (!oe.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), n = oe.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(x, E) {
    return !oe.isUndefined(E[x]);
  });
  const r = n.metaTokens, i = n.visitor || h, a = n.dots, s = n.indexes, f = (n.Blob || typeof Blob < "u" && Blob) && oe.isSpecCompliantForm(t);
  if (!oe.isFunction(i))
    throw new TypeError("visitor must be a function");
  function d(b) {
    if (b === null) return "";
    if (oe.isDate(b))
      return b.toISOString();
    if (!f && oe.isBlob(b))
      throw new Be("Blob is not supported. Use a Buffer instead.");
    return oe.isArrayBuffer(b) || oe.isTypedArray(b) ? f && typeof Blob == "function" ? new Blob([b]) : Buffer.from(b) : b;
  }
  function h(b, x, E) {
    let S = b;
    if (b && !E && typeof b == "object") {
      if (oe.endsWith(x, "{}"))
        x = r ? x : x.slice(0, -2), b = JSON.stringify(b);
      else if (oe.isArray(b) && WF(b) || (oe.isFileList(b) || oe.endsWith(x, "[]")) && (S = oe.toArray(b)))
        return x = kO(x), S.forEach(function(k, R) {
          !(oe.isUndefined(k) || k === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            s === !0 ? tC([x], R, a) : s === null ? x : x + "[]",
            d(k)
          );
        }), !1;
    }
    return nv(b) ? !0 : (t.append(tC(E, x, a), d(b)), !1);
  }
  const p = [], g = Object.assign(KF, {
    defaultVisitor: h,
    convertValue: d,
    isVisitable: nv
  });
  function y(b, x) {
    if (!oe.isUndefined(b)) {
      if (p.indexOf(b) !== -1)
        throw Error("Circular reference detected in " + x.join("."));
      p.push(b), oe.forEach(b, function(S, A) {
        (!(oe.isUndefined(S) || S === null) && i.call(
          t,
          S,
          oe.isString(A) ? A.trim() : A,
          x,
          g
        )) === !0 && y(S, x ? x.concat(A) : [A]);
      }), p.pop();
    }
  }
  if (!oe.isObject(e))
    throw new TypeError("data must be an object");
  return y(e), t;
}
function nC(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
    return t[r];
  });
}
function Ab(e, t) {
  this._pairs = [], e && vp(e, this, t);
}
const AO = Ab.prototype;
AO.append = function(t, n) {
  this._pairs.push([t, n]);
};
AO.toString = function(t) {
  const n = t ? function(r) {
    return t.call(this, r, nC);
  } : nC;
  return this._pairs.map(function(i) {
    return n(i[0]) + "=" + n(i[1]);
  }, "").join("&");
};
function ZF(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function TO(e, t, n) {
  if (!t)
    return e;
  const r = n && n.encode || ZF;
  oe.isFunction(n) && (n = {
    serialize: n
  });
  const i = n && n.serialize;
  let a;
  if (i ? a = i(t, n) : a = oe.isURLSearchParams(t) ? t.toString() : new Ab(t, n).toString(r), a) {
    const s = e.indexOf("#");
    s !== -1 && (e = e.slice(0, s)), e += (e.indexOf("?") === -1 ? "?" : "&") + a;
  }
  return e;
}
class rC {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, r) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    oe.forEach(this.handlers, function(r) {
      r !== null && t(r);
    });
  }
}
const RO = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, QF = typeof URLSearchParams < "u" ? URLSearchParams : Ab, JF = typeof FormData < "u" ? FormData : null, eB = typeof Blob < "u" ? Blob : null, tB = {
  isBrowser: !0,
  classes: {
    URLSearchParams: QF,
    FormData: JF,
    Blob: eB
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, Tb = typeof window < "u" && typeof document < "u", rv = typeof navigator == "object" && navigator || void 0, nB = Tb && (!rv || ["ReactNative", "NativeScript", "NS"].indexOf(rv.product) < 0), rB = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", iB = Tb && window.location.href || "http://localhost", oB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: Tb,
  hasStandardBrowserEnv: nB,
  hasStandardBrowserWebWorkerEnv: rB,
  navigator: rv,
  origin: iB
}, Symbol.toStringTag, { value: "Module" })), dn = {
  ...oB,
  ...tB
};
function aB(e, t) {
  return vp(e, new dn.classes.URLSearchParams(), Object.assign({
    visitor: function(n, r, i, a) {
      return dn.isNode && oe.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : a.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function sB(e) {
  return oe.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function lB(e) {
  const t = {}, n = Object.keys(e);
  let r;
  const i = n.length;
  let a;
  for (r = 0; r < i; r++)
    a = n[r], t[a] = e[a];
  return t;
}
function OO(e) {
  function t(n, r, i, a) {
    let s = n[a++];
    if (s === "__proto__") return !0;
    const u = Number.isFinite(+s), f = a >= n.length;
    return s = !s && oe.isArray(i) ? i.length : s, f ? (oe.hasOwnProp(i, s) ? i[s] = [i[s], r] : i[s] = r, !u) : ((!i[s] || !oe.isObject(i[s])) && (i[s] = []), t(n, r, i[s], a) && oe.isArray(i[s]) && (i[s] = lB(i[s])), !u);
  }
  if (oe.isFormData(e) && oe.isFunction(e.entries)) {
    const n = {};
    return oe.forEachEntry(e, (r, i) => {
      t(sB(r), i, n, 0);
    }), n;
  }
  return null;
}
function uB(e, t, n) {
  if (oe.isString(e))
    try {
      return (t || JSON.parse)(e), oe.trim(e);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(e);
}
const Lc = {
  transitional: RO,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, n) {
    const r = n.getContentType() || "", i = r.indexOf("application/json") > -1, a = oe.isObject(t);
    if (a && oe.isHTMLForm(t) && (t = new FormData(t)), oe.isFormData(t))
      return i ? JSON.stringify(OO(t)) : t;
    if (oe.isArrayBuffer(t) || oe.isBuffer(t) || oe.isStream(t) || oe.isFile(t) || oe.isBlob(t) || oe.isReadableStream(t))
      return t;
    if (oe.isArrayBufferView(t))
      return t.buffer;
    if (oe.isURLSearchParams(t))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let u;
    if (a) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return aB(t, this.formSerializer).toString();
      if ((u = oe.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
        const f = this.env && this.env.FormData;
        return vp(
          u ? { "files[]": t } : t,
          f && new f(),
          this.formSerializer
        );
      }
    }
    return a || i ? (n.setContentType("application/json", !1), uB(t)) : t;
  }],
  transformResponse: [function(t) {
    const n = this.transitional || Lc.transitional, r = n && n.forcedJSONParsing, i = this.responseType === "json";
    if (oe.isResponse(t) || oe.isReadableStream(t))
      return t;
    if (t && oe.isString(t) && (r && !this.responseType || i)) {
      const s = !(n && n.silentJSONParsing) && i;
      try {
        return JSON.parse(t);
      } catch (u) {
        if (s)
          throw u.name === "SyntaxError" ? Be.from(u, Be.ERR_BAD_RESPONSE, this, null, this.response) : u;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: dn.classes.FormData,
    Blob: dn.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
oe.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  Lc.headers[e] = {};
});
const cB = oe.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), fB = (e) => {
  const t = {};
  let n, r, i;
  return e && e.split(`
`).forEach(function(s) {
    i = s.indexOf(":"), n = s.substring(0, i).trim().toLowerCase(), r = s.substring(i + 1).trim(), !(!n || t[n] && cB[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
  }), t;
}, iC = Symbol("internals");
function Du(e) {
  return e && String(e).trim().toLowerCase();
}
function th(e) {
  return e === !1 || e == null ? e : oe.isArray(e) ? e.map(th) : String(e);
}
function dB(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(e); )
    t[r[1]] = r[2];
  return t;
}
const hB = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function j0(e, t, n, r, i) {
  if (oe.isFunction(r))
    return r.call(this, t, n);
  if (i && (t = n), !!oe.isString(t)) {
    if (oe.isString(r))
      return t.indexOf(r) !== -1;
    if (oe.isRegExp(r))
      return r.test(t);
  }
}
function pB(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
}
function mB(e, t) {
  const n = oe.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(e, r + n, {
      value: function(i, a, s) {
        return this[r].call(this, t, i, a, s);
      },
      configurable: !0
    });
  });
}
let zn = class {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, r) {
    const i = this;
    function a(u, f, d) {
      const h = Du(f);
      if (!h)
        throw new Error("header name must be a non-empty string");
      const p = oe.findKey(i, h);
      (!p || i[p] === void 0 || d === !0 || d === void 0 && i[p] !== !1) && (i[p || f] = th(u));
    }
    const s = (u, f) => oe.forEach(u, (d, h) => a(d, h, f));
    if (oe.isPlainObject(t) || t instanceof this.constructor)
      s(t, n);
    else if (oe.isString(t) && (t = t.trim()) && !hB(t))
      s(fB(t), n);
    else if (oe.isHeaders(t))
      for (const [u, f] of t.entries())
        a(f, u, r);
    else
      t != null && a(n, t, r);
    return this;
  }
  get(t, n) {
    if (t = Du(t), t) {
      const r = oe.findKey(this, t);
      if (r) {
        const i = this[r];
        if (!n)
          return i;
        if (n === !0)
          return dB(i);
        if (oe.isFunction(n))
          return n.call(this, i, r);
        if (oe.isRegExp(n))
          return n.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, n) {
    if (t = Du(t), t) {
      const r = oe.findKey(this, t);
      return !!(r && this[r] !== void 0 && (!n || j0(this, this[r], r, n)));
    }
    return !1;
  }
  delete(t, n) {
    const r = this;
    let i = !1;
    function a(s) {
      if (s = Du(s), s) {
        const u = oe.findKey(r, s);
        u && (!n || j0(r, r[u], u, n)) && (delete r[u], i = !0);
      }
    }
    return oe.isArray(t) ? t.forEach(a) : a(t), i;
  }
  clear(t) {
    const n = Object.keys(this);
    let r = n.length, i = !1;
    for (; r--; ) {
      const a = n[r];
      (!t || j0(this, this[a], a, t, !0)) && (delete this[a], i = !0);
    }
    return i;
  }
  normalize(t) {
    const n = this, r = {};
    return oe.forEach(this, (i, a) => {
      const s = oe.findKey(r, a);
      if (s) {
        n[s] = th(i), delete n[a];
        return;
      }
      const u = t ? pB(a) : String(a).trim();
      u !== a && delete n[a], n[u] = th(i), r[u] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const n = /* @__PURE__ */ Object.create(null);
    return oe.forEach(this, (r, i) => {
      r != null && r !== !1 && (n[i] = t && oe.isArray(r) ? r.join(", ") : r);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...n) {
    const r = new this(t);
    return n.forEach((i) => r.set(i)), r;
  }
  static accessor(t) {
    const r = (this[iC] = this[iC] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function a(s) {
      const u = Du(s);
      r[u] || (mB(i, s), r[u] = !0);
    }
    return oe.isArray(t) ? t.forEach(a) : a(t), this;
  }
};
zn.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
oe.reduceDescriptors(zn.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(r) {
      this[n] = r;
    }
  };
});
oe.freezeMethods(zn);
function I0(e, t) {
  const n = this || Lc, r = t || n, i = zn.from(r.headers);
  let a = r.data;
  return oe.forEach(e, function(u) {
    a = u.call(n, a, i.normalize(), t ? t.status : void 0);
  }), i.normalize(), a;
}
function NO(e) {
  return !!(e && e.__CANCEL__);
}
function gl(e, t, n) {
  Be.call(this, e ?? "canceled", Be.ERR_CANCELED, t, n), this.name = "CanceledError";
}
oe.inherits(gl, Be, {
  __CANCEL__: !0
});
function MO(e, t, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? e(n) : t(new Be(
    "Request failed with status code " + n.status,
    [Be.ERR_BAD_REQUEST, Be.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function gB(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function yB(e, t) {
  e = e || 10;
  const n = new Array(e), r = new Array(e);
  let i = 0, a = 0, s;
  return t = t !== void 0 ? t : 1e3, function(f) {
    const d = Date.now(), h = r[a];
    s || (s = d), n[i] = f, r[i] = d;
    let p = a, g = 0;
    for (; p !== i; )
      g += n[p++], p = p % e;
    if (i = (i + 1) % e, i === a && (a = (a + 1) % e), d - s < t)
      return;
    const y = h && d - h;
    return y ? Math.round(g * 1e3 / y) : void 0;
  };
}
function vB(e, t) {
  let n = 0, r = 1e3 / t, i, a;
  const s = (d, h = Date.now()) => {
    n = h, i = null, a && (clearTimeout(a), a = null), e.apply(null, d);
  };
  return [(...d) => {
    const h = Date.now(), p = h - n;
    p >= r ? s(d, h) : (i = d, a || (a = setTimeout(() => {
      a = null, s(i);
    }, r - p)));
  }, () => i && s(i)];
}
const Th = (e, t, n = 3) => {
  let r = 0;
  const i = yB(50, 250);
  return vB((a) => {
    const s = a.loaded, u = a.lengthComputable ? a.total : void 0, f = s - r, d = i(f), h = s <= u;
    r = s;
    const p = {
      loaded: s,
      total: u,
      progress: u ? s / u : void 0,
      bytes: f,
      rate: d || void 0,
      estimated: d && u && h ? (u - s) / d : void 0,
      event: a,
      lengthComputable: u != null,
      [t ? "download" : "upload"]: !0
    };
    e(p);
  }, n);
}, oC = (e, t) => {
  const n = e != null;
  return [(r) => t[0]({
    lengthComputable: n,
    total: e,
    loaded: r
  }), t[1]];
}, aC = (e) => (...t) => oe.asap(() => e(...t)), bB = dn.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t) => (n) => (n = new URL(n, dn.origin), e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(
  new URL(dn.origin),
  dn.navigator && /(msie|trident)/i.test(dn.navigator.userAgent)
) : () => !0, xB = dn.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, n, r, i, a) {
      const s = [e + "=" + encodeURIComponent(t)];
      oe.isNumber(n) && s.push("expires=" + new Date(n).toGMTString()), oe.isString(r) && s.push("path=" + r), oe.isString(i) && s.push("domain=" + i), a === !0 && s.push("secure"), document.cookie = s.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function wB(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function SB(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function DO(e, t, n) {
  let r = !wB(t);
  return e && (r || n == !1) ? SB(e, t) : t;
}
const sC = (e) => e instanceof zn ? { ...e } : e;
function Oa(e, t) {
  t = t || {};
  const n = {};
  function r(d, h, p, g) {
    return oe.isPlainObject(d) && oe.isPlainObject(h) ? oe.merge.call({ caseless: g }, d, h) : oe.isPlainObject(h) ? oe.merge({}, h) : oe.isArray(h) ? h.slice() : h;
  }
  function i(d, h, p, g) {
    if (oe.isUndefined(h)) {
      if (!oe.isUndefined(d))
        return r(void 0, d, p, g);
    } else return r(d, h, p, g);
  }
  function a(d, h) {
    if (!oe.isUndefined(h))
      return r(void 0, h);
  }
  function s(d, h) {
    if (oe.isUndefined(h)) {
      if (!oe.isUndefined(d))
        return r(void 0, d);
    } else return r(void 0, h);
  }
  function u(d, h, p) {
    if (p in t)
      return r(d, h);
    if (p in e)
      return r(void 0, d);
  }
  const f = {
    url: a,
    method: a,
    data: a,
    baseURL: s,
    transformRequest: s,
    transformResponse: s,
    paramsSerializer: s,
    timeout: s,
    timeoutMessage: s,
    withCredentials: s,
    withXSRFToken: s,
    adapter: s,
    responseType: s,
    xsrfCookieName: s,
    xsrfHeaderName: s,
    onUploadProgress: s,
    onDownloadProgress: s,
    decompress: s,
    maxContentLength: s,
    maxBodyLength: s,
    beforeRedirect: s,
    transport: s,
    httpAgent: s,
    httpsAgent: s,
    cancelToken: s,
    socketPath: s,
    responseEncoding: s,
    validateStatus: u,
    headers: (d, h, p) => i(sC(d), sC(h), p, !0)
  };
  return oe.forEach(Object.keys(Object.assign({}, e, t)), function(h) {
    const p = f[h] || i, g = p(e[h], t[h], h);
    oe.isUndefined(g) && p !== u || (n[h] = g);
  }), n;
}
const PO = (e) => {
  const t = Oa({}, e);
  let { data: n, withXSRFToken: r, xsrfHeaderName: i, xsrfCookieName: a, headers: s, auth: u } = t;
  t.headers = s = zn.from(s), t.url = TO(DO(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), u && s.set(
    "Authorization",
    "Basic " + btoa((u.username || "") + ":" + (u.password ? unescape(encodeURIComponent(u.password)) : ""))
  );
  let f;
  if (oe.isFormData(n)) {
    if (dn.hasStandardBrowserEnv || dn.hasStandardBrowserWebWorkerEnv)
      s.setContentType(void 0);
    else if ((f = s.getContentType()) !== !1) {
      const [d, ...h] = f ? f.split(";").map((p) => p.trim()).filter(Boolean) : [];
      s.setContentType([d || "multipart/form-data", ...h].join("; "));
    }
  }
  if (dn.hasStandardBrowserEnv && (r && oe.isFunction(r) && (r = r(t)), r || r !== !1 && bB(t.url))) {
    const d = i && a && xB.read(a);
    d && s.set(i, d);
  }
  return t;
}, _B = typeof XMLHttpRequest < "u", EB = _B && function(e) {
  return new Promise(function(n, r) {
    const i = PO(e);
    let a = i.data;
    const s = zn.from(i.headers).normalize();
    let { responseType: u, onUploadProgress: f, onDownloadProgress: d } = i, h, p, g, y, b;
    function x() {
      y && y(), b && b(), i.cancelToken && i.cancelToken.unsubscribe(h), i.signal && i.signal.removeEventListener("abort", h);
    }
    let E = new XMLHttpRequest();
    E.open(i.method.toUpperCase(), i.url, !0), E.timeout = i.timeout;
    function S() {
      if (!E)
        return;
      const k = zn.from(
        "getAllResponseHeaders" in E && E.getAllResponseHeaders()
      ), N = {
        data: !u || u === "text" || u === "json" ? E.responseText : E.response,
        status: E.status,
        statusText: E.statusText,
        headers: k,
        config: e,
        request: E
      };
      MO(function(P) {
        n(P), x();
      }, function(P) {
        r(P), x();
      }, N), E = null;
    }
    "onloadend" in E ? E.onloadend = S : E.onreadystatechange = function() {
      !E || E.readyState !== 4 || E.status === 0 && !(E.responseURL && E.responseURL.indexOf("file:") === 0) || setTimeout(S);
    }, E.onabort = function() {
      E && (r(new Be("Request aborted", Be.ECONNABORTED, e, E)), E = null);
    }, E.onerror = function() {
      r(new Be("Network Error", Be.ERR_NETWORK, e, E)), E = null;
    }, E.ontimeout = function() {
      let R = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
      const N = i.transitional || RO;
      i.timeoutErrorMessage && (R = i.timeoutErrorMessage), r(new Be(
        R,
        N.clarifyTimeoutError ? Be.ETIMEDOUT : Be.ECONNABORTED,
        e,
        E
      )), E = null;
    }, a === void 0 && s.setContentType(null), "setRequestHeader" in E && oe.forEach(s.toJSON(), function(R, N) {
      E.setRequestHeader(N, R);
    }), oe.isUndefined(i.withCredentials) || (E.withCredentials = !!i.withCredentials), u && u !== "json" && (E.responseType = i.responseType), d && ([g, b] = Th(d, !0), E.addEventListener("progress", g)), f && E.upload && ([p, y] = Th(f), E.upload.addEventListener("progress", p), E.upload.addEventListener("loadend", y)), (i.cancelToken || i.signal) && (h = (k) => {
      E && (r(!k || k.type ? new gl(null, e, E) : k), E.abort(), E = null);
    }, i.cancelToken && i.cancelToken.subscribe(h), i.signal && (i.signal.aborted ? h() : i.signal.addEventListener("abort", h)));
    const A = gB(i.url);
    if (A && dn.protocols.indexOf(A) === -1) {
      r(new Be("Unsupported protocol " + A + ":", Be.ERR_BAD_REQUEST, e));
      return;
    }
    E.send(a || null);
  });
}, CB = (e, t) => {
  const { length: n } = e = e ? e.filter(Boolean) : [];
  if (t || n) {
    let r = new AbortController(), i;
    const a = function(d) {
      if (!i) {
        i = !0, u();
        const h = d instanceof Error ? d : this.reason;
        r.abort(h instanceof Be ? h : new gl(h instanceof Error ? h.message : h));
      }
    };
    let s = t && setTimeout(() => {
      s = null, a(new Be(`timeout ${t} of ms exceeded`, Be.ETIMEDOUT));
    }, t);
    const u = () => {
      e && (s && clearTimeout(s), s = null, e.forEach((d) => {
        d.unsubscribe ? d.unsubscribe(a) : d.removeEventListener("abort", a);
      }), e = null);
    };
    e.forEach((d) => d.addEventListener("abort", a));
    const { signal: f } = r;
    return f.unsubscribe = () => oe.asap(u), f;
  }
}, kB = function* (e, t) {
  let n = e.byteLength;
  if (n < t) {
    yield e;
    return;
  }
  let r = 0, i;
  for (; r < n; )
    i = r + t, yield e.slice(r, i), r = i;
}, AB = async function* (e, t) {
  for await (const n of TB(e))
    yield* kB(n, t);
}, TB = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: n, value: r } = await t.read();
      if (n)
        break;
      yield r;
    }
  } finally {
    await t.cancel();
  }
}, lC = (e, t, n, r) => {
  const i = AB(e, t);
  let a = 0, s, u = (f) => {
    s || (s = !0, r && r(f));
  };
  return new ReadableStream({
    async pull(f) {
      try {
        const { done: d, value: h } = await i.next();
        if (d) {
          u(), f.close();
          return;
        }
        let p = h.byteLength;
        if (n) {
          let g = a += p;
          n(g);
        }
        f.enqueue(new Uint8Array(h));
      } catch (d) {
        throw u(d), d;
      }
    },
    cancel(f) {
      return u(f), i.return();
    }
  }, {
    highWaterMark: 2
  });
}, bp = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", zO = bp && typeof ReadableStream == "function", RB = bp && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), jO = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
}, OB = zO && jO(() => {
  let e = !1;
  const t = new Request(dn.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
}), uC = 64 * 1024, iv = zO && jO(() => oe.isReadableStream(new Response("").body)), Rh = {
  stream: iv && ((e) => e.body)
};
bp && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !Rh[t] && (Rh[t] = oe.isFunction(e[t]) ? (n) => n[t]() : (n, r) => {
      throw new Be(`Response type '${t}' is not supported`, Be.ERR_NOT_SUPPORT, r);
    });
  });
})(new Response());
const NB = async (e) => {
  if (e == null)
    return 0;
  if (oe.isBlob(e))
    return e.size;
  if (oe.isSpecCompliantForm(e))
    return (await new Request(dn.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (oe.isArrayBufferView(e) || oe.isArrayBuffer(e))
    return e.byteLength;
  if (oe.isURLSearchParams(e) && (e = e + ""), oe.isString(e))
    return (await RB(e)).byteLength;
}, MB = async (e, t) => {
  const n = oe.toFiniteNumber(e.getContentLength());
  return n ?? NB(t);
}, DB = bp && (async (e) => {
  let {
    url: t,
    method: n,
    data: r,
    signal: i,
    cancelToken: a,
    timeout: s,
    onDownloadProgress: u,
    onUploadProgress: f,
    responseType: d,
    headers: h,
    withCredentials: p = "same-origin",
    fetchOptions: g
  } = PO(e);
  d = d ? (d + "").toLowerCase() : "text";
  let y = CB([i, a && a.toAbortSignal()], s), b;
  const x = y && y.unsubscribe && (() => {
    y.unsubscribe();
  });
  let E;
  try {
    if (f && OB && n !== "get" && n !== "head" && (E = await MB(h, r)) !== 0) {
      let N = new Request(t, {
        method: "POST",
        body: r,
        duplex: "half"
      }), D;
      if (oe.isFormData(r) && (D = N.headers.get("content-type")) && h.setContentType(D), N.body) {
        const [P, F] = oC(
          E,
          Th(aC(f))
        );
        r = lC(N.body, uC, P, F);
      }
    }
    oe.isString(p) || (p = p ? "include" : "omit");
    const S = "credentials" in Request.prototype;
    b = new Request(t, {
      ...g,
      signal: y,
      method: n.toUpperCase(),
      headers: h.normalize().toJSON(),
      body: r,
      duplex: "half",
      credentials: S ? p : void 0
    });
    let A = await fetch(b);
    const k = iv && (d === "stream" || d === "response");
    if (iv && (u || k && x)) {
      const N = {};
      ["status", "statusText", "headers"].forEach((V) => {
        N[V] = A[V];
      });
      const D = oe.toFiniteNumber(A.headers.get("content-length")), [P, F] = u && oC(
        D,
        Th(aC(u), !0)
      ) || [];
      A = new Response(
        lC(A.body, uC, P, () => {
          F && F(), x && x();
        }),
        N
      );
    }
    d = d || "text";
    let R = await Rh[oe.findKey(Rh, d) || "text"](A, e);
    return !k && x && x(), await new Promise((N, D) => {
      MO(N, D, {
        data: R,
        headers: zn.from(A.headers),
        status: A.status,
        statusText: A.statusText,
        config: e,
        request: b
      });
    });
  } catch (S) {
    throw x && x(), S && S.name === "TypeError" && /fetch/i.test(S.message) ? Object.assign(
      new Be("Network Error", Be.ERR_NETWORK, e, b),
      {
        cause: S.cause || S
      }
    ) : Be.from(S, S && S.code, e, b);
  }
}), ov = {
  http: XF,
  xhr: EB,
  fetch: DB
};
oe.forEach(ov, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const cC = (e) => `- ${e}`, PB = (e) => oe.isFunction(e) || e === null || e === !1, IO = {
  getAdapter: (e) => {
    e = oe.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, r;
    const i = {};
    for (let a = 0; a < t; a++) {
      n = e[a];
      let s;
      if (r = n, !PB(n) && (r = ov[(s = String(n)).toLowerCase()], r === void 0))
        throw new Be(`Unknown adapter '${s}'`);
      if (r)
        break;
      i[s || "#" + a] = r;
    }
    if (!r) {
      const a = Object.entries(i).map(
        ([u, f]) => `adapter ${u} ` + (f === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let s = t ? a.length > 1 ? `since :
` + a.map(cC).join(`
`) : " " + cC(a[0]) : "as no adapter specified";
      throw new Be(
        "There is no suitable adapter to dispatch the request " + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return r;
  },
  adapters: ov
};
function L0(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new gl(null, e);
}
function fC(e) {
  return L0(e), e.headers = zn.from(e.headers), e.data = I0.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), IO.getAdapter(e.adapter || Lc.adapter)(e).then(function(r) {
    return L0(e), r.data = I0.call(
      e,
      e.transformResponse,
      r
    ), r.headers = zn.from(r.headers), r;
  }, function(r) {
    return NO(r) || (L0(e), r && r.response && (r.response.data = I0.call(
      e,
      e.transformResponse,
      r.response
    ), r.response.headers = zn.from(r.response.headers))), Promise.reject(r);
  });
}
const LO = "1.8.4", xp = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  xp[e] = function(r) {
    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const dC = {};
xp.transitional = function(t, n, r) {
  function i(a, s) {
    return "[Axios v" + LO + "] Transitional option '" + a + "'" + s + (r ? ". " + r : "");
  }
  return (a, s, u) => {
    if (t === !1)
      throw new Be(
        i(s, " has been removed" + (n ? " in " + n : "")),
        Be.ERR_DEPRECATED
      );
    return n && !dC[s] && (dC[s] = !0, console.warn(
      i(
        s,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), t ? t(a, s, u) : !0;
  };
};
xp.spelling = function(t) {
  return (n, r) => (console.warn(`${r} is likely a misspelling of ${t}`), !0);
};
function zB(e, t, n) {
  if (typeof e != "object")
    throw new Be("options must be an object", Be.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(e);
  let i = r.length;
  for (; i-- > 0; ) {
    const a = r[i], s = t[a];
    if (s) {
      const u = e[a], f = u === void 0 || s(u, a, e);
      if (f !== !0)
        throw new Be("option " + a + " must be " + f, Be.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new Be("Unknown option " + a, Be.ERR_BAD_OPTION);
  }
}
const nh = {
  assertOptions: zB,
  validators: xp
}, qr = nh.validators;
let Aa = class {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new rC(),
      response: new rC()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, n) {
    try {
      return await this._request(t, n);
    } catch (r) {
      if (r instanceof Error) {
        let i = {};
        Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error();
        const a = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        try {
          r.stack ? a && !String(r.stack).endsWith(a.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + a) : r.stack = a;
        } catch {
        }
      }
      throw r;
    }
  }
  _request(t, n) {
    typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = Oa(this.defaults, n);
    const { transitional: r, paramsSerializer: i, headers: a } = n;
    r !== void 0 && nh.assertOptions(r, {
      silentJSONParsing: qr.transitional(qr.boolean),
      forcedJSONParsing: qr.transitional(qr.boolean),
      clarifyTimeoutError: qr.transitional(qr.boolean)
    }, !1), i != null && (oe.isFunction(i) ? n.paramsSerializer = {
      serialize: i
    } : nh.assertOptions(i, {
      encode: qr.function,
      serialize: qr.function
    }, !0)), n.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? n.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : n.allowAbsoluteUrls = !0), nh.assertOptions(n, {
      baseUrl: qr.spelling("baseURL"),
      withXsrfToken: qr.spelling("withXSRFToken")
    }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let s = a && oe.merge(
      a.common,
      a[n.method]
    );
    a && oe.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (b) => {
        delete a[b];
      }
    ), n.headers = zn.concat(s, a);
    const u = [];
    let f = !0;
    this.interceptors.request.forEach(function(x) {
      typeof x.runWhen == "function" && x.runWhen(n) === !1 || (f = f && x.synchronous, u.unshift(x.fulfilled, x.rejected));
    });
    const d = [];
    this.interceptors.response.forEach(function(x) {
      d.push(x.fulfilled, x.rejected);
    });
    let h, p = 0, g;
    if (!f) {
      const b = [fC.bind(this), void 0];
      for (b.unshift.apply(b, u), b.push.apply(b, d), g = b.length, h = Promise.resolve(n); p < g; )
        h = h.then(b[p++], b[p++]);
      return h;
    }
    g = u.length;
    let y = n;
    for (p = 0; p < g; ) {
      const b = u[p++], x = u[p++];
      try {
        y = b(y);
      } catch (E) {
        x.call(this, E);
        break;
      }
    }
    try {
      h = fC.call(this, y);
    } catch (b) {
      return Promise.reject(b);
    }
    for (p = 0, g = d.length; p < g; )
      h = h.then(d[p++], d[p++]);
    return h;
  }
  getUri(t) {
    t = Oa(this.defaults, t);
    const n = DO(t.baseURL, t.url, t.allowAbsoluteUrls);
    return TO(n, t.params, t.paramsSerializer);
  }
};
oe.forEach(["delete", "get", "head", "options"], function(t) {
  Aa.prototype[t] = function(n, r) {
    return this.request(Oa(r || {}, {
      method: t,
      url: n,
      data: (r || {}).data
    }));
  };
});
oe.forEach(["post", "put", "patch"], function(t) {
  function n(r) {
    return function(a, s, u) {
      return this.request(Oa(u || {}, {
        method: t,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: a,
        data: s
      }));
    };
  }
  Aa.prototype[t] = n(), Aa.prototype[t + "Form"] = n(!0);
});
let jB = class FO {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(a) {
      n = a;
    });
    const r = this;
    this.promise.then((i) => {
      if (!r._listeners) return;
      let a = r._listeners.length;
      for (; a-- > 0; )
        r._listeners[a](i);
      r._listeners = null;
    }), this.promise.then = (i) => {
      let a;
      const s = new Promise((u) => {
        r.subscribe(u), a = u;
      }).then(i);
      return s.cancel = function() {
        r.unsubscribe(a);
      }, s;
    }, t(function(a, s, u) {
      r.reason || (r.reason = new gl(a, s, u), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), n = (r) => {
      t.abort(r);
    };
    return this.subscribe(n), t.signal.unsubscribe = () => this.unsubscribe(n), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new FO(function(i) {
        t = i;
      }),
      cancel: t
    };
  }
};
function IB(e) {
  return function(n) {
    return e.apply(null, n);
  };
}
function LB(e) {
  return oe.isObject(e) && e.isAxiosError === !0;
}
const av = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(av).forEach(([e, t]) => {
  av[t] = e;
});
function BO(e) {
  const t = new Aa(e), n = yO(Aa.prototype.request, t);
  return oe.extend(n, Aa.prototype, t, { allOwnKeys: !0 }), oe.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(i) {
    return BO(Oa(e, i));
  }, n;
}
const Pt = BO(Lc);
Pt.Axios = Aa;
Pt.CanceledError = gl;
Pt.CancelToken = jB;
Pt.isCancel = NO;
Pt.VERSION = LO;
Pt.toFormData = vp;
Pt.AxiosError = Be;
Pt.Cancel = Pt.CanceledError;
Pt.all = function(t) {
  return Promise.all(t);
};
Pt.spread = IB;
Pt.isAxiosError = LB;
Pt.mergeConfig = Oa;
Pt.AxiosHeaders = zn;
Pt.formToJSON = (e) => OO(oe.isHTMLForm(e) ? new FormData(e) : e);
Pt.getAdapter = IO.getAdapter;
Pt.HttpStatusCode = av;
Pt.default = Pt;
const {
  Axios: due,
  AxiosError: hue,
  CanceledError: pue,
  isCancel: mue,
  CancelToken: gue,
  VERSION: yue,
  all: vue,
  Cancel: bue,
  isAxiosError: xue,
  spread: wue,
  toFormData: Sue,
  AxiosHeaders: _ue,
  HttpStatusCode: Eue,
  formToJSON: Cue,
  getAdapter: kue,
  mergeConfig: Aue
} = Pt, rn = [];
for (let e = 0; e < 256; ++e)
  rn.push((e + 256).toString(16).slice(1));
function FB(e, t = 0) {
  return (rn[e[t + 0]] + rn[e[t + 1]] + rn[e[t + 2]] + rn[e[t + 3]] + "-" + rn[e[t + 4]] + rn[e[t + 5]] + "-" + rn[e[t + 6]] + rn[e[t + 7]] + "-" + rn[e[t + 8]] + rn[e[t + 9]] + "-" + rn[e[t + 10]] + rn[e[t + 11]] + rn[e[t + 12]] + rn[e[t + 13]] + rn[e[t + 14]] + rn[e[t + 15]]).toLowerCase();
}
let F0;
const BB = new Uint8Array(16);
function $B() {
  if (!F0) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    F0 = crypto.getRandomValues.bind(crypto);
  }
  return F0(BB);
}
const HB = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), hC = { randomUUID: HB };
function $O(e, t, n) {
  if (hC.randomUUID && !e)
    return hC.randomUUID();
  e = e || {};
  const r = e.random ?? e.rng?.() ?? $B();
  if (r.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, FB(r);
}
class VB {
  constructor(t) {
    this.CHUNK_TIMEOUT = 1e4, this.PONGDELAY = 2e3, this.blobChunks = {}, this._hooks = /* @__PURE__ */ new Map(), this._ns_event_intercepts = /* @__PURE__ */ new Map(), this._unique_cmd_outs = {}, this.uuid = t.uuid, this.on_error = t.on_error || ((r) => {
      this._zustand?.logger.error(r);
    }), this.messagePromises = /* @__PURE__ */ new Map(), this._local_nodeupdates = /* @__PURE__ */ new Map(), this._nodeupdatetimer = setTimeout(() => {
      this.sync_local_node_updates();
    }, 5e3), this.state = bn((r, i) => ({
      is_open: !1
    })), t.zustand && this.set_zustand(t.zustand), t.on_sync_complete ? this.on_sync_complete = t.on_sync_complete : this.on_sync_complete = async () => {
    }, this._responsive = !1, this._last_pong = Date.now() - this.PONGDELAY * 100, setInterval(() => {
      this.is_open && this.send({ type: "ping" });
    }, this.PONGDELAY), setInterval(() => {
      Date.now() - this._last_pong > this.PONGDELAY * 3 ? this._responsive = !1 : this._responsive = !0;
    }, this.PONGDELAY * 2), setInterval(() => {
      const r = Date.now();
      for (const i in this.blobChunks)
        r - this.blobChunks[i].timestamp > this.CHUNK_TIMEOUT && delete this.blobChunks[i];
    }, this.CHUNK_TIMEOUT / 2);
  }
  _receive_pong() {
    this._last_pong = Date.now(), this._responsive = !0;
  }
  set_zustand(t) {
    t !== this._zustand && (this._zustand = t, t.set_worker(this), this._zustand.auto_progress(), this.stepwise_fullsync());
  }
  add_hook(t, n) {
    const r = this._hooks.get(t) || [];
    return r.push(n), this._hooks.set(t, r), () => {
      const a = this._hooks.get(t) || [], s = a.indexOf(n);
      s >= 0 && a.splice(s, 1);
    };
  }
  async call_hooks(t, n) {
    const r = [];
    for (const i of this._hooks.get(t) || []) {
      const a = i({ worker: this, data: n });
      a instanceof Promise && r.push(a);
    }
    await Promise.all(r);
  }
  add_ns_event_intercept(t, n) {
    const r = this._ns_event_intercepts.get(t) || [];
    return r.push(n), this._ns_event_intercepts.set(t, r), () => {
      const a = this._ns_event_intercepts.get(t) || [], s = a.indexOf(n);
      s >= 0 && a.splice(s, 1);
    };
  }
  async intercept_ns_event(t) {
    let n = t;
    for (const r of this._ns_event_intercepts.get(t.event) || [])
      n = await r(n);
    return n;
  }
  get is_open() {
    return this.state.getState().is_open;
  }
  set is_open(t) {
    this.state.setState({ is_open: t });
  }
  async stepwise_fullsync() {
    this._zustand && this.is_open && (await this.sync_lib(), await this.sync_external_worker(), await this.sync_funcnodes_plugins(), await this.sync_nodespace(), await this.sync_view_state(), await this.on_sync_complete(this));
  }
  async sync_lib() {
    if (!this._zustand || !this.is_open) return;
    const t = await this._send_cmd({
      cmd: "get_library",
      wait_for_response: !0,
      retries: 2,
      unique: !0
    });
    this._zustand.lib.libstate.getState().set({
      lib: t
    });
  }
  async sync_external_worker() {
    if (!this._zustand || !this.is_open) return;
    const t = await this._send_cmd({
      cmd: "get_worker_dependencies",
      wait_for_response: !0,
      unique: !0
    });
    this._zustand.lib.libstate.getState().set({
      external_worker: t
    });
  }
  async sync_funcnodes_plugins() {
    if (!this._zustand || !this.is_open) return;
    const t = await this._send_cmd({
      cmd: "get_plugin_keys",
      wait_for_response: !0,
      unique: !0,
      kwargs: { type: "react" }
    });
    for (const n of t) {
      const r = await this._send_cmd({
        cmd: "get_plugin",
        wait_for_response: !0,
        kwargs: { key: n, type: "react" },
        unique: !0
      });
      if (r.js)
        for (const i of r.js) {
          const a = document.createElement("script");
          a.text = atob(i), document.body.appendChild(a);
        }
      if (r.css)
        for (const i of r.css) {
          const a = document.createElement("style");
          a.innerHTML = atob(i), document.head.appendChild(a);
        }
      if (r.module !== void 0) {
        const i = atob(r.module), a = i.length, s = new Uint8Array(a);
        for (let h = 0; h < a; h++)
          s[h] = i.charCodeAt(h);
        const u = new Blob([s], { type: "application/javascript" }), f = URL.createObjectURL(u), d = await import(
          /* @vite-ignore */
          f
        );
        URL.revokeObjectURL(f), this._zustand.add_plugin(n, d.default);
      }
    }
  }
  async sync_view_state() {
    if (!this._zustand || !this.is_open) return;
    const t = await this._send_cmd({
      cmd: "view_state",
      wait_for_response: !0,
      unique: !0
    });
    t.renderoptions && this._zustand.update_render_options(t.renderoptions);
    const n = t.nodes;
    if (n)
      for (const r in n) {
        const i = {};
        G_(i, n[r]), this._zustand.on_node_action({
          type: "update",
          node: i,
          id: r,
          from_remote: !0
        });
      }
  }
  async sync_nodespace() {
    if (!this._zustand || !this.is_open) return;
    const t = await this._send_cmd({
      cmd: "get_nodes",
      kwargs: { with_frontend: !0 },
      wait_for_response: !0,
      unique: !0
    });
    for (const r of t)
      this._receive_node_added(r);
    const n = await this._send_cmd({
      cmd: "get_edges",
      wait_for_response: !0,
      unique: !0
    });
    for (const r of n)
      this._receive_edge_added(...r);
  }
  async fullsync() {
    if (!this._zustand || !this.is_open) return;
    let t;
    for (; ; )
      try {
        t = await this._send_cmd({
          cmd: "full_state",
          unique: !0
        });
        break;
      } catch (r) {
        this._zustand.logger.error("Error in fullsync", r);
      }
    this._zustand.logger.debug("Full state", t), this._zustand.lib.libstate.getState().set({
      lib: t.backend.lib,
      external_worker: t.worker_dependencies
    }), t.view.renderoptions && this._zustand.update_render_options(t.view.renderoptions);
    const n = t.view.nodes;
    for (const r of t.backend.nodes) {
      const i = n[r.id];
      i !== void 0 && G_(r, i), this._receive_node_added(r);
    }
    for (const r of t.backend.edges)
      this._receive_edge_added(...r);
  }
  async _receive_edge_added(t, n, r, i) {
    this._zustand && this._zustand.on_edge_action({
      type: "add",
      from_remote: !0,
      src_nid: t,
      src_ioid: n,
      trg_nid: r,
      trg_ioid: i
    });
  }
  async trigger_node(t) {
    await this._send_cmd({
      cmd: "trigger_node",
      kwargs: { nid: t },
      wait_for_response: !1
    });
  }
  async add_node(t) {
    const n = await this._send_cmd({
      cmd: "add_node",
      kwargs: { id: t }
    });
    this._receive_node_added(n);
  }
  async remove_node(t) {
    await this._send_cmd({
      cmd: "remove_node",
      kwargs: { id: t }
    });
  }
  async _receive_node_added(t) {
    this._zustand && this._zustand.on_node_action({
      type: "add",
      node: t,
      id: t.id,
      from_remote: !0
    });
  }
  add_edge({
    src_nid: t,
    src_ioid: n,
    trg_nid: r,
    trg_ioid: i,
    replace: a = !1
  }) {
    return this._send_cmd({
      cmd: "add_edge",
      kwargs: { src_nid: t, src_ioid: n, trg_nid: r, trg_ioid: i, replace: a }
    });
  }
  remove_edge({
    src_nid: t,
    src_ioid: n,
    trg_nid: r,
    trg_ioid: i
  }) {
    return this._send_cmd({
      cmd: "remove_edge",
      kwargs: { src_nid: t, src_ioid: n, trg_nid: r, trg_ioid: i }
    });
  }
  async add_external_worker({
    module: t,
    cls_module: n,
    cls_name: r
  }) {
    return await this._send_cmd({
      cmd: "add_external_worker",
      kwargs: { module: t, cls_module: n, cls_name: r }
    });
  }
  sync_local_node_updates() {
    clearTimeout(this._nodeupdatetimer), this._local_nodeupdates.forEach(async (t, n) => {
      const r = await this._send_cmd({
        cmd: "update_node",
        kwargs: { nid: n, data: t },
        wait_for_response: !0
      });
      this._zustand && this._zustand.on_node_action({
        type: "update",
        node: r,
        id: n,
        from_remote: !0
      });
    }), this._local_nodeupdates.clear(), this._nodeupdatetimer = setTimeout(() => {
      this.sync_local_node_updates();
    }, 200);
  }
  locally_update_node(t) {
    const n = this._local_nodeupdates.get(t.id);
    if (n) {
      const { new_obj: r, change: i } = Or(n, t.node);
      i && this._local_nodeupdates.set(t.id, r);
    } else
      this._local_nodeupdates.set(t.id, t.node);
    t.immediate && this.sync_local_node_updates();
  }
  async get_remote_node_state(t) {
    const n = await this._send_cmd({
      cmd: "get_node_state",
      kwargs: { nid: t },
      wait_for_response: !0
    });
    this._zustand && this._zustand.on_node_action({
      type: "update",
      node: n,
      id: n.id,
      from_remote: !0
    });
  }
  set_io_value({
    nid: t,
    ioid: n,
    value: r,
    set_default: i = !1
  }) {
    return this._send_cmd({
      cmd: "set_io_value",
      kwargs: { nid: t, ioid: n, value: r, set_default: i },
      wait_for_response: !0
    });
  }
  clear() {
    return this._send_cmd({ cmd: "clear", unique: !0 });
  }
  save() {
    return this._send_cmd({
      cmd: "save",
      wait_for_response: !0,
      unique: !0
    });
  }
  load(t) {
    return this._send_cmd({
      cmd: "load_data",
      kwargs: { data: t },
      wait_for_response: !0
    }).then(() => {
      this.stepwise_fullsync();
    });
  }
  async get_io_value({ nid: t, ioid: n }) {
    const r = await this._send_cmd({
      cmd: "get_io_value",
      kwargs: { nid: t, ioid: n },
      wait_for_response: !0
    });
    return this._zustand && this._zustand.on_node_action({
      type: "update",
      node: {
        io: {
          [n]: {
            value: r
          }
        }
      },
      id: t,
      from_remote: !0
    }), r;
  }
  async get_ios_values({ nid: t }) {
    const n = await this._send_cmd({
      cmd: "get_ios_values",
      kwargs: { nid: t },
      wait_for_response: !0
    });
    if (!this._zustand) return n;
    const r = {};
    for (const i in n)
      r[i] = { value: n[i] };
    return this._zustand.on_node_action({
      type: "update",
      node: {
        io: r
      },
      id: t,
      from_remote: !0
    }), n;
  }
  async get_runstate() {
    return await this._send_cmd({
      cmd: "get_runstate",
      wait_for_response: !0,
      unique: !0
    });
  }
  async _send_cmd({
    cmd: t,
    kwargs: n,
    as_bytes: r = !1,
    wait_for_response: i = !0,
    response_timeout: a = 5e3,
    retries: s = 2,
    unique: u = !1
  }) {
    const f = {
      type: "cmd",
      as_bytes: r,
      cmd: t,
      kwargs: n || {}
    };
    if (await new Promise(async (d) => {
      if (this._responsive) return d();
      const h = setInterval(() => {
        this._responsive && (clearInterval(h), d());
      }, 100);
    }), i) {
      if (u && this._unique_cmd_outs[f.cmd] !== void 0)
        return this._unique_cmd_outs[f.cmd];
      s < 0 && (s = 0);
      const h = (async () => {
        let p;
        for (; s >= 0; ) {
          const g = f.id || $O();
          f.id = g;
          const y = new Promise((b, x) => {
            const E = setTimeout(() => {
              x("Timeout@wait_for_response for " + t);
            }, a);
            this.messagePromises.set(g, {
              resolve: (S) => {
                clearTimeout(E), b(S), this.messagePromises.delete(g);
              },
              reject: (S) => {
                clearTimeout(E), x(S), this.messagePromises.delete(g);
              }
            });
          });
          await this.send(f);
          try {
            p = await y;
            break;
          } catch (b) {
            if (s === 0)
              throw delete this._unique_cmd_outs[f.cmd], b;
            s -= 1;
            continue;
          }
        }
        return delete this._unique_cmd_outs[f.cmd], p;
      })();
      return u && (this._unique_cmd_outs[f.cmd] = h), h;
    }
    return this.send(f);
  }
  async send(t) {
    throw new Error("async send(data: any)  not implemented");
  }
  async upload_file({
    files: t,
    onProgressCallback: n,
    root: r
  }) {
    throw new Error("upload_file not implemented ");
  }
  async handle_large_message_hint({}) {
    throw new Error(
      "async handle_large_message_hint({}: LargeMessageHint) not implemented "
    );
  }
  async receive_workerevent({ event: t, data: n }) {
    switch (t) {
      case "worker_error":
        return this._zustand ? this._zustand.logger.error(n.error) : void 0;
      case "update_worker_dependencies":
        return this._zustand ? this._zustand.lib.libstate.getState().set({
          external_worker: n.worker_dependencies
        }) : void 0;
      case "lib_update":
        await this.sync_lib();
        return;
      case "fullsync":
        await this.stepwise_fullsync();
        return;
      case "external_worker_update":
        await this.sync_lib(), await this.sync_external_worker();
        return;
      case "starting":
        this.call_hooks("starting");
        return;
      case "stopping":
        this.call_hooks("stopping");
        return;
      default:
        console.warn("Unhandled worker event", t, n);
        break;
    }
  }
  async receive_nodespace_event(t) {
    const { event: n, data: r } = await this.intercept_ns_event(t);
    switch (n) {
      case "after_set_value":
        return this._zustand ? this._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            io: {
              [r.io]: {
                value: r.result
              }
            }
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "after_update_value_options":
        return this._zustand ? this._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            io: {
              [r.io]: {
                value_options: r.result
              }
            }
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "triggerstart":
        return this._zustand ? this._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            in_trigger: !0
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "triggerdone":
        return this._zustand ? this._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            in_trigger: !1
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "triggerfast":
        if (!this._zustand) return;
        this._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            in_trigger: !0
          },
          id: r.node,
          from_remote: !0
        }), setTimeout(() => {
          this._zustand && this._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              in_trigger: !1
            },
            id: r.node,
            from_remote: !0
          });
        }, 50);
        return;
      case "node_trigger_error":
        return this._zustand ? this._zustand.on_node_action({
          type: "error",
          errortype: "trigger",
          error: r.error,
          id: r.node,
          tb: r.tb,
          from_remote: !0
        }) : void 0;
      case "node_removed":
        if (!this._zustand) return;
        this._zustand.on_node_action({
          type: "delete",
          id: r.node,
          from_remote: !0
        }), this.call_hooks("node_removed", { node: r.node });
        return;
      case "node_added":
        this._receive_node_added(r.node);
        return;
      case "after_disconnect":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 || !this._zustand ? void 0 : this._zustand.on_edge_action({
          type: "delete",
          from_remote: !0,
          src_nid: r.result[0],
          src_ioid: r.result[1],
          trg_nid: r.result[2],
          trg_ioid: r.result[3]
        });
      case "after_unforward":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 || !this._zustand ? void 0 : this._zustand.on_edge_action({
          type: "delete",
          from_remote: !0,
          src_nid: r.result[0],
          src_ioid: r.result[1],
          trg_nid: r.result[2],
          trg_ioid: r.result[3]
        });
      case "after_connect":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 ? void 0 : this._receive_edge_added(
          ...r.result
        );
      case "after_forward":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 ? void 0 : this._receive_edge_added(
          ...r.result
        );
      case "after_add_shelf":
        return !r.result || !this._zustand ? void 0 : this._zustand.lib.libstate.getState().set({
          lib: r.result
        });
      case "after_remove_shelf":
        return !r.result || !this._zustand ? void 0 : this._zustand.lib.libstate.getState().set({
          lib: r.result
        });
      case "progress":
        if (!this._zustand) return;
        if (r.node)
          return this._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              progress: r.info
            },
            id: r.node,
            from_remote: !0
          });
        console.warn("Unhandled nodepsace event", n, r);
        break;
      default:
        if (["after_set_nodespace"].includes(n)) return;
        console.warn("Unhandled nodepsace event", n, r);
        break;
    }
  }
  async add_lib(t, n) {
    return await this._send_cmd({
      cmd: "add_package_dependency",
      kwargs: { name: t, version: n },
      wait_for_response: !1
    });
  }
  async remove_lib(t) {
    return await this._send_cmd({
      cmd: "remove_package_dependency",
      kwargs: { name: t },
      wait_for_response: !1
    });
  }
  async receive(t) {
    let n;
    switch (this._last_pong = Date.now(), this._responsive = !0, t.type) {
      case "pong":
        this._receive_pong();
        return;
      case "nsevent":
        return await this.receive_nodespace_event(t);
      case "result":
        if (n = t.id && this.messagePromises.get(t.id), n)
          return n.resolve(t.result);
        break;
      case "error":
        if (this.on_error(t.tb + `
` + t.error), n = t.id && this.messagePromises.get(t.id), n)
          return n.reject(t.error);
        break;
      case "progress":
        if (!this._zustand) return;
        this._zustand.set_progress(t);
        break;
      case "workerevent":
        return await this.receive_workerevent(t);
      case "large_message":
        return await this.handle_large_message_hint(t);
      default:
        console.warn("Unhandled message", t);
        break;
    }
  }
  async onbytes(t) {
    try {
      const n = new TextDecoder("utf-8").decode(t), r = n.indexOf(`\r
\r
`);
      if (r === -1) {
        console.error(`Header terminator not found for:
`, n);
        return;
      }
      const i = n.substring(0, r + 4), a = t.slice(r + 4), s = i.split(";"), u = {};
      if (s.forEach((p) => {
        const [g, y] = p.split("=");
        u[g.trim()] = y.trim();
      }), !u.chunk || !u.msgid) {
        console.error(
          "Header missing required fields chunk or msgid",
          u
        );
        return;
      }
      const [f, d] = u.chunk.split("/"), h = u.msgid;
      if (f === "1" && d === "1")
        return this.recieve_bytes(u, a);
      if (this.blobChunks[h] || (this.blobChunks[h] = {
        chunks: Array.from({ length: parseInt(d) }, () => null),
        timestamp: Date.now()
      }), this.blobChunks[h].chunks.length !== parseInt(d)) {
        console.error("Total chunks mismatch");
        return;
      }
      if (this.blobChunks[h].chunks[parseInt(f) - 1] = t, this.blobChunks[h].chunks.every((p) => p !== null)) {
        const p = new Uint8Array(
          this.blobChunks[h].chunks.reduce((g, y) => g.concat(Array.from(y)), [])
        );
        this.recieve_bytes(u, p), delete this.blobChunks[h];
      }
    } catch (n) {
      console.error("Websocketworker: onbytes error", n, t);
      return;
    }
  }
  async recieve_bytes(t, n) {
    const { type: r } = t;
    if (r === "io_value") {
      if (!this._zustand) return;
      const { node: i, io: a, preview: s, mime: u } = t, f = s ? "value" : "fullvalue";
      (!i || !a) && console.error("Invalid io_value message", t);
      const d = X_({
        data: n,
        mime: u || "application/octet-stream"
      });
      this._zustand.on_node_action({
        type: "update",
        node: {
          id: i,
          io: {
            [a]: {
              [f]: d
            }
          }
        },
        id: i,
        from_remote: !0
      });
    } else if (r == "result") {
      const i = t.id && this.messagePromises.get(t.id);
      i && i.resolve({ bytes: n, header: t });
    } else
      console.warn("Unhandled bytes message", t);
  }
  disconnect() {
  }
  onclose() {
    this.is_open = !1, this._zustand && this._zustand.auto_progress();
  }
  async reconnect() {
  }
  async stop() {
    await this._send_cmd({ cmd: "stop_worker", wait_for_response: !1 });
    const t = this.onclose.bind(this);
    this.onclose = () => {
      t(), this._zustand && (this._zustand.worker === this && this._zustand.clear_all(), this.onclose = t);
    };
  }
  async get_io_full_value({ nid: t, ioid: n }) {
    const r = await this._send_cmd({
      cmd: "get_io_full_value",
      kwargs: { nid: t, ioid: n },
      wait_for_response: !0,
      as_bytes: !0
    });
    if (!this._zustand) return r;
    if (!this._zustand) return;
    const { header: i, bytes: a } = r, { mime: s } = i, u = X_({
      data: a,
      mime: s || "application/octet-stream"
    });
    return this._zustand.on_node_action({
      type: "update",
      node: {
        id: t,
        io: {
          [n]: {
            fullvalue: u
          }
        }
      },
      id: t,
      from_remote: !0
    }), r;
  }
  async update_io_options({
    nid: t,
    ioid: n,
    options: r
  }) {
    const i = await this._send_cmd({
      cmd: "update_io_options",
      kwargs: { nid: t, ioid: n, ...r },
      wait_for_response: !0
    });
    if (!this._zustand) return i;
    this._zustand.on_node_action({
      type: "update",
      node: {
        io: {
          [n]: {
            ...r
          }
        }
      },
      id: t,
      from_remote: !0
    });
  }
  async get_node_status(t) {
    return await this._send_cmd({
      cmd: "get_node_state",
      kwargs: { nid: t },
      wait_for_response: !0
    });
  }
  async get_available_modules() {
    return await this._send_cmd({
      cmd: "get_available_modules",
      wait_for_response: !0,
      unique: !0
    });
  }
  async update_external_worker(t, n, r) {
    return await this._send_cmd({
      cmd: "update_external_worker",
      kwargs: { worker_id: t, class_id: n, ...r },
      wait_for_response: !0
    });
  }
  async remove_external_worker(t, n) {
    return await this._send_cmd({
      cmd: "remove_external_worker",
      kwargs: { worker_id: t, class_id: n },
      wait_for_response: !0
    });
  }
  async export({ withFiles: t = !1 }) {
    return await this._send_cmd({
      cmd: "export_worker",
      wait_for_response: !0,
      kwargs: { with_files: t }
    });
  }
  async update_from_export(t) {
    const n = this.add_hook("node_added", async ({}) => {
      this._zustand?.center_all();
    });
    try {
      const r = await this._send_cmd({
        cmd: "update_from_export",
        kwargs: { data: t },
        wait_for_response: !0,
        response_timeout: 6e5,
        // 10 minutes
        unique: !0
      });
      return await new Promise((i) => {
        setTimeout(() => {
          i();
        }, 1e3);
      }), await this.stepwise_fullsync(), r;
    } finally {
      n();
    }
  }
}
class HO extends VB {
  constructor(t) {
    super(t), this._websocket = null, this.reconnectAttempts = 0, this.maxReconnectAttempts = 999, this.initialTimeout = 200, this.maxTimeout = 5e3, this._reconnect = !0, this._reconnect_timeout = void 0, this._url = t.url, this._reconnect_timeout = setTimeout(() => {
      this.connect();
    }, 200), this._zustand && this._zustand.auto_progress();
  }
  connect() {
    this._zustand?.logger.info("Connecting to websocket"), this.is_open = !1, this._websocket = new WebSocket(this._url), this._websocket.onopen = () => {
      this.onopen();
    }, this._websocket.onclose = () => {
      this.onclose();
    }, this._websocket.onerror = () => {
      this.on_ws_error();
    }, this._websocket.onmessage = (t) => {
      typeof t.data == "string" ? this.onmessage(t.data) : t.data instanceof Blob && t.data.arrayBuffer().then((n) => {
        const r = new Uint8Array(n);
        this.onbytes(r);
      });
    };
  }
  calculateReconnectTimeout() {
    return Math.min(
      this.initialTimeout * Math.pow(2, this.reconnectAttempts),
      this.maxTimeout
    );
  }
  auto_reconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      let t = this.calculateReconnectTimeout();
      this._zustand?.logger.info(`Attempting to reconnect in ${t} ms`), this._reconnect_timeout = setTimeout(() => {
        this._websocket && this._websocket.readyState === WebSocket.OPEN || (this.reconnectAttempts++, this.connect());
      }, t);
    } else
      this._zustand?.logger.warn(
        "Maximum reconnect attempts reached. Giving up."
      );
  }
  async onmessage(t) {
    try {
      const n = JSON.parse(t);
      this._zustand?.logger.debug(
        `Recieved data of length: ${t.length} and data"`,
        n
      ), await this.receive(n);
    } catch (n) {
      console.error("Websocketworker: onmessage JSON.parse error", n, t);
      return;
    }
  }
  get http_protocol() {
    return this.secure_url ? "https" : "http";
  }
  get secure_url() {
    return this._url.startsWith("wss");
  }
  get url_wo_protocol() {
    return this._url.substring(this.secure_url ? 6 : 5);
  }
  get http_url() {
    var t = this.http_protocol + "://" + this.url_wo_protocol;
    return t[t.length - 1] !== "/" && (t += "/"), t;
  }
  get_io_subscription_url({
    node_id: t,
    io_id: n,
    stream: r
  }) {
    let i = this.http_url + `node/${t}/io/${n}/value`;
    return r && (i += "/stream"), i;
  }
  async upload_file({
    files: t,
    onProgressCallback: n,
    root: r
  }) {
    const i = `${this.http_url}upload/`, a = new FormData(), s = Array.isArray(t) ? t : Array.from(t);
    for (const u of s) {
      const f = u.webkitRelativePath || u.name, d = r ? `${r}/${f}` : f;
      a.append("file", u, d);
    }
    try {
      return (await Pt.post(i, a, {
        headers: {
          "Content-Type": "multipart/form-data"
        },
        onUploadProgress: (f) => {
          n && n(f.loaded, f.total);
        }
      })).data.file;
    } catch {
      throw new Error("Failed to upload file");
    }
  }
  async handle_large_message_hint({ msg_id: t }) {
    const n = this.http_url + "message/" + t, i = await (await fetch(n, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*"
      }
    })).json();
    this.receive(i);
  }
  onopen() {
    this._zustand?.logger.info("Websocket opened"), this.is_open = !0, this._zustand && this._zustand.auto_progress(), this.reconnectAttempts = 0, this.stepwise_fullsync();
  }
  onclose() {
    this._zustand?.logger.info("Websocket closed"), super.onclose(), this._reconnect && (this._zustand?.logger.info("Websocket closed,reconnecting"), this.auto_reconnect());
  }
  on_ws_error() {
    this._zustand?.logger.warn("Websocket error"), this._websocket ? this._websocket.close() : this.auto_reconnect();
  }
  async send_large_message(t) {
    const n = `${this.http_url}message/`;
    await fetch(n, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: t
    });
  }
  async send(t) {
    if (!this._websocket || this._websocket.readyState !== WebSocket.OPEN) {
      this._zustand?.logger.warn("Websocket not connected");
      return;
    }
    const n = JSON.stringify(t);
    if (new Blob([n]).size > 1e6)
      return this._zustand?.logger.info("Data too large, sending via http"), await this.send_large_message(n);
    this._zustand?.logger.debug("Sending data", t), this._websocket.send(n);
  }
  async stop() {
    await super.stop(), this._reconnect = !1;
  }
  close() {
    this._websocket && this._websocket.close();
  }
  disconnect() {
    super.disconnect(), this._reconnect = !1, this._reconnect_timeout && (clearTimeout(this._reconnect_timeout), this._reconnect_timeout = void 0), this.close();
  }
  async reconnect() {
    if (await super.reconnect(), this._reconnect = !0, this._websocket && (this._zustand?.logger.info("Reconnecting"), (this._websocket.readyState === WebSocket.OPEN || this._websocket.readyState === WebSocket.CONNECTING) && (this._websocket.readyState === WebSocket.CONNECTING && await new Promise((t, n) => {
      if (this._websocket === null) return;
      let r = setTimeout(() => {
        n("Timeout@reconnect");
      }, 2e3);
      this._websocket.addEventListener(
        "open",
        () => {
          clearTimeout(r), t(null);
        },
        { once: !0 }
      ), this._websocket.readyState === WebSocket.OPEN && (clearTimeout(r), t(null));
    }), this._websocket.readyState === WebSocket.OPEN))) {
      this.stepwise_fullsync();
      return;
    }
    this.connect();
  }
}
class UB {
  constructor(t, n) {
    this.ws = null, this.reconnectAttempts = 0, this.maxReconnectAttempts = 999, this.initialTimeout = 200, this.maxTimeout = 2e3, this.wsuri = t, this.zustand = n, this.workers = {}, this.on_setWorker = (r) => {
      this.zustand.set_worker(r);
    }, this.connectionTimeout = setTimeout(() => {
      this.connect();
    }, 200);
  }
  get open() {
    return this.ws?.readyState === WebSocket.OPEN;
  }
  connect() {
    this.zustand.set_progress({
      progress: 0,
      message: "connecting to worker manager",
      status: "info",
      blocking: !0
    }), this.zustand.logger.info("Connecting to websocket:", this.wsuri), this.ws = new WebSocket(this.wsuri), this.ws.onopen = () => {
      this.onopen();
    }, this.ws.onclose = () => {
      this.onclose();
    }, this.ws.onerror = () => {
      this.on_ws_error();
    }, this.ws.onmessage = (t) => {
      typeof t.data == "string" ? this.onmessage(t.data) : console.error(
        "WorkerManager: onmessage event.data is not a string",
        typeof t.data
      );
    }, this.connectionTimeout = setTimeout(() => {
      this.ws?.readyState !== WebSocket.OPEN && this.on_ws_error();
    }, 5e3);
  }
  on_ws_error() {
    console.warn("Websocket error"), this.ws ? this.ws.close() : this.reconnect();
  }
  onopen() {
    this.connectionTimeout && (clearTimeout(this.connectionTimeout), this.connectionTimeout = void 0), this.zustand.auto_progress(), this.ws && this.ws.send("worker_status");
    const t = window.localStorage.getItem(
      "funcnodes__active_worker"
    );
    t && this.set_active(t);
  }
  onmessage(t) {
    try {
      let n = JSON.parse(t);
      if (n.type === "worker_status") {
        const r = {};
        for (let i of n.active)
          i.active = !0, r[i.uuid] = i;
        for (let i of n.inactive)
          i.active = !1, r[i.uuid] = i;
        this.zustand.workers.setState(r);
        return;
      } else if (n.type === "set_worker") {
        if (n.data.type === "WSWorker") {
          let r = "ws" + (n.data.ssl ? "s" : "") + "://" + n.data.host + ":" + n.data.port;
          this.setWorker(
            this.workers[n.data.uuid] || new HO({
              url: r,
              zustand: this.zustand,
              uuid: n.data.uuid,
              on_sync_complete: this.zustand.options.on_sync_complete
            })
          );
        } else
          this.zustand.logger.error("WorkerManager: unknown worker type", n);
        return;
      } else if (n.type === "progress") {
        this.zustand.set_progress(n);
        return;
      }
      this.zustand.logger.error("WorkerManager: unknown message", n);
    } catch (n) {
      console.error("WorkerManager: onmessage JSON.parse error", n, t);
      return;
    }
  }
  setWorker(t) {
    for (let n in this.workers)
      n !== t?.uuid && this.workers[n].disconnect();
    t !== void 0 && (this.workers[t.uuid] = t, t.reconnect()), t?.uuid && window.localStorage.setItem("funcnodes__active_worker", t?.uuid), this.zustand.worker !== void 0 && this.zustand.clear_all(), this.zustand.set_worker(t), this.on_setWorker(t);
  }
  async restart_worker(t) {
    this.ws?.send(JSON.stringify({ type: "restart_worker", workerid: t }));
  }
  calculateReconnectTimeout() {
    return Math.min(
      this.initialTimeout * Math.pow(2, this.reconnectAttempts),
      this.maxTimeout
    );
  }
  reconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      let t = this.calculateReconnectTimeout();
      this.zustand.logger.info(`Attempting to reconnect in ${t} ms`), setTimeout(() => {
        this.ws && this.ws.readyState === WebSocket.OPEN || (this.reconnectAttempts++, this.connect());
      }, t);
    } else
      this.zustand.logger.warn(
        "Maximum reconnect attempts reached. Giving up."
      );
  }
  onclose() {
    this.zustand.logger.warn("WorkerManager: onclose"), this.reconnect();
  }
  set_active(t) {
    this.ws && this.ws.send(JSON.stringify({ type: "set_active", workerid: t }));
  }
  new_worker({
    name: t,
    reference: n,
    copyLib: r,
    copyNS: i
  }) {
    t || (t = void 0), r || (r = !1), i || (i = !1), n || (n = void 0, r = !1, i = !1), this.ws && this.ws.send(
      JSON.stringify({
        type: "new_worker",
        kwargs: {
          name: t,
          reference: n,
          copyLib: r,
          copyNS: i
        }
      })
    );
  }
  remove() {
    for (let t in this.workers)
      this.workers[t].disconnect();
    this.connectionTimeout && (clearTimeout(this.connectionTimeout), this.connectionTimeout = void 0), this.ws && (this.ws.onclose = () => {
    }, this.ws.onerror = () => {
    }, this.ws.onmessage = () => {
    }, this.ws.onopen = () => {
    }, this.ws.close());
  }
}
function qB(e) {
  const t = window.atob(e), n = t.length, r = new Uint8Array(n);
  for (let i = 0; i < n; i++)
    r[i] = t.charCodeAt(i);
  return r;
}
function YB(e, t) {
  return new Blob([e], { type: t });
}
function GB(e, t) {
  return YB(qB(e), t);
}
function XB(e, t, n) {
  const r = GB(e, n), i = URL.createObjectURL(r), a = document.createElement("a");
  a.href = i, a.download = t, a.click(), URL.revokeObjectURL(i), a.remove();
}
function WB(e, t = !0) {
  return new Promise((n) => {
    const r = new FileReader();
    r.onload = () => {
      const i = r.result;
      t && n(i.split(",")[1]), n(i);
    }, r.readAsDataURL(e);
  });
}
function KB(e) {
  return new Promise((t) => {
    const n = document.createElement("input");
    n.type = "file", n.accept = e, n.onchange = () => {
      const r = n.files?.[0];
      r && t(r);
    }, n.click();
  });
}
function ZB(e) {
  return KB(e).then(WB);
}
async function QB(e, t = !0) {
  try {
    const n = await fetch(e);
    if (!n.ok)
      throw new Error(
        `Failed to fetch from URL: ${n.status} ${n.statusText}`
      );
    const r = await n.blob();
    return await new Promise((a, s) => {
      const u = new FileReader();
      u.onload = () => {
        const f = u.result;
        typeof f != "string" && (s("Failed to convert URL to Base64: No result from FileReader"), s(u.error)), a(t ? f.split(",")[1] : f);
      }, u.onerror = () => s(u.error), u.readAsDataURL(r);
    });
  } catch (n) {
    throw console.error("Error converting URL to Base64:", n), n;
  }
}
function De(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (e?.(i), n === !1 || !i.defaultPrevented)
      return t?.(i);
  };
}
function pC(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function wp(...e) {
  return (t) => {
    let n = !1;
    const r = e.map((i) => {
      const a = pC(i, t);
      return !n && typeof a == "function" && (n = !0), a;
    });
    if (n)
      return () => {
        for (let i = 0; i < r.length; i++) {
          const a = r[i];
          typeof a == "function" ? a() : pC(e[i], null);
        }
      };
  };
}
function Et(...e) {
  return C.useCallback(wp(...e), e);
}
function JB(e, t) {
  const n = C.createContext(t), r = (a) => {
    const { children: s, ...u } = a, f = C.useMemo(() => u, Object.values(u));
    return /* @__PURE__ */ _.jsx(n.Provider, { value: f, children: s });
  };
  r.displayName = e + "Provider";
  function i(a) {
    const s = C.useContext(n);
    if (s) return s;
    if (t !== void 0) return t;
    throw new Error(`\`${a}\` must be used within \`${e}\``);
  }
  return [r, i];
}
function Go(e, t = []) {
  let n = [];
  function r(a, s) {
    const u = C.createContext(s), f = n.length;
    n = [...n, s];
    const d = (p) => {
      const { scope: g, children: y, ...b } = p, x = g?.[e]?.[f] || u, E = C.useMemo(() => b, Object.values(b));
      return /* @__PURE__ */ _.jsx(x.Provider, { value: E, children: y });
    };
    d.displayName = a + "Provider";
    function h(p, g) {
      const y = g?.[e]?.[f] || u, b = C.useContext(y);
      if (b) return b;
      if (s !== void 0) return s;
      throw new Error(`\`${p}\` must be used within \`${a}\``);
    }
    return [d, h];
  }
  const i = () => {
    const a = n.map((s) => C.createContext(s));
    return function(u) {
      const f = u?.[e] || a;
      return C.useMemo(
        () => ({ [`__scope${e}`]: { ...u, [e]: f } }),
        [u, f]
      );
    };
  };
  return i.scopeName = e, [r, e7(i, ...t)];
}
function e7(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(a) {
      const s = r.reduce((u, { useScope: f, scopeName: d }) => {
        const p = f(a)[`__scope${d}`];
        return { ...u, ...p };
      }, {});
      return C.useMemo(() => ({ [`__scope${t.scopeName}`]: s }), [s]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
var Na = globalThis?.document ? C.useLayoutEffect : () => {
}, t7 = gh[" useId ".trim().toString()] || (() => {
}), n7 = 0;
function Li(e) {
  const [t, n] = C.useState(t7());
  return Na(() => {
    n((r) => r ?? String(n7++));
  }, [e]), e || (t ? `radix-${t}` : "");
}
function yr(e) {
  const t = C.useRef(e);
  return C.useEffect(() => {
    t.current = e;
  }), C.useMemo(() => (...n) => t.current?.(...n), []);
}
function yl({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  }
}) {
  const [r, i] = r7({ defaultProp: t, onChange: n }), a = e !== void 0, s = a ? e : r, u = yr(n), f = C.useCallback(
    (d) => {
      if (a) {
        const p = typeof d == "function" ? d(e) : d;
        p !== e && u(p);
      } else
        i(d);
    },
    [a, e, i, u]
  );
  return [s, f];
}
function r7({
  defaultProp: e,
  onChange: t
}) {
  const n = C.useState(e), [r] = n, i = C.useRef(r), a = yr(t);
  return C.useEffect(() => {
    i.current !== r && (a(r), i.current = r);
  }, [r, i, a]), n;
}
// @__NO_SIDE_EFFECTS__
function sl(e) {
  const t = /* @__PURE__ */ i7(e), n = C.forwardRef((r, i) => {
    const { children: a, ...s } = r, u = C.Children.toArray(a), f = u.find(a7);
    if (f) {
      const d = f.props.children, h = u.map((p) => p === f ? C.Children.count(d) > 1 ? C.Children.only(null) : C.isValidElement(d) ? d.props.children : null : p);
      return /* @__PURE__ */ _.jsx(t, { ...s, ref: i, children: C.isValidElement(d) ? C.cloneElement(d, void 0, h) : null });
    }
    return /* @__PURE__ */ _.jsx(t, { ...s, ref: i, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function i7(e) {
  const t = C.forwardRef((n, r) => {
    const { children: i, ...a } = n;
    if (C.isValidElement(i)) {
      const s = l7(i), u = s7(a, i.props);
      return i.type !== C.Fragment && (u.ref = r ? wp(r, s) : s), C.cloneElement(i, u);
    }
    return C.Children.count(i) > 1 ? C.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var o7 = Symbol("radix.slottable");
function a7(e) {
  return C.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === o7;
}
function s7(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? i && a ? n[r] = (...u) => {
      a(...u), i(...u);
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...a } : r === "className" && (n[r] = [i, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function l7(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var u7 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], vt = u7.reduce((e, t) => {
  const n = /* @__PURE__ */ sl(`Primitive.${t}`), r = C.forwardRef((i, a) => {
    const { asChild: s, ...u } = i, f = s ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ _.jsx(f, { ...u, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {});
function VO(e, t) {
  e && Pc.flushSync(() => e.dispatchEvent(t));
}
function c7(e, t = globalThis?.document) {
  const n = yr(e);
  C.useEffect(() => {
    const r = (i) => {
      i.key === "Escape" && n(i);
    };
    return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
  }, [n, t]);
}
var f7 = "DismissableLayer", sv = "dismissableLayer.update", d7 = "dismissableLayer.pointerDownOutside", h7 = "dismissableLayer.focusOutside", mC, UO = C.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), Sp = C.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: i,
      onFocusOutside: a,
      onInteractOutside: s,
      onDismiss: u,
      ...f
    } = e, d = C.useContext(UO), [h, p] = C.useState(null), g = h?.ownerDocument ?? globalThis?.document, [, y] = C.useState({}), b = Et(t, (P) => p(P)), x = Array.from(d.layers), [E] = [...d.layersWithOutsidePointerEventsDisabled].slice(-1), S = x.indexOf(E), A = h ? x.indexOf(h) : -1, k = d.layersWithOutsidePointerEventsDisabled.size > 0, R = A >= S, N = g7((P) => {
      const F = P.target, V = [...d.branches].some((T) => T.contains(F));
      !R || V || (i?.(P), s?.(P), P.defaultPrevented || u?.());
    }, g), D = y7((P) => {
      const F = P.target;
      [...d.branches].some((T) => T.contains(F)) || (a?.(P), s?.(P), P.defaultPrevented || u?.());
    }, g);
    return c7((P) => {
      A === d.layers.size - 1 && (r?.(P), !P.defaultPrevented && u && (P.preventDefault(), u()));
    }, g), C.useEffect(() => {
      if (h)
        return n && (d.layersWithOutsidePointerEventsDisabled.size === 0 && (mC = g.body.style.pointerEvents, g.body.style.pointerEvents = "none"), d.layersWithOutsidePointerEventsDisabled.add(h)), d.layers.add(h), gC(), () => {
          n && d.layersWithOutsidePointerEventsDisabled.size === 1 && (g.body.style.pointerEvents = mC);
        };
    }, [h, g, n, d]), C.useEffect(() => () => {
      h && (d.layers.delete(h), d.layersWithOutsidePointerEventsDisabled.delete(h), gC());
    }, [h, d]), C.useEffect(() => {
      const P = () => y({});
      return document.addEventListener(sv, P), () => document.removeEventListener(sv, P);
    }, []), /* @__PURE__ */ _.jsx(
      vt.div,
      {
        ...f,
        ref: b,
        style: {
          pointerEvents: k ? R ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: De(e.onFocusCapture, D.onFocusCapture),
        onBlurCapture: De(e.onBlurCapture, D.onBlurCapture),
        onPointerDownCapture: De(
          e.onPointerDownCapture,
          N.onPointerDownCapture
        )
      }
    );
  }
);
Sp.displayName = f7;
var p7 = "DismissableLayerBranch", m7 = C.forwardRef((e, t) => {
  const n = C.useContext(UO), r = C.useRef(null), i = Et(t, r);
  return C.useEffect(() => {
    const a = r.current;
    if (a)
      return n.branches.add(a), () => {
        n.branches.delete(a);
      };
  }, [n.branches]), /* @__PURE__ */ _.jsx(vt.div, { ...e, ref: i });
});
m7.displayName = p7;
function g7(e, t = globalThis?.document) {
  const n = yr(e), r = C.useRef(!1), i = C.useRef(() => {
  });
  return C.useEffect(() => {
    const a = (u) => {
      if (u.target && !r.current) {
        let f = function() {
          qO(
            d7,
            n,
            d,
            { discrete: !0 }
          );
        };
        const d = { originalEvent: u };
        u.pointerType === "touch" ? (t.removeEventListener("click", i.current), i.current = f, t.addEventListener("click", i.current, { once: !0 })) : f();
      } else
        t.removeEventListener("click", i.current);
      r.current = !1;
    }, s = window.setTimeout(() => {
      t.addEventListener("pointerdown", a);
    }, 0);
    return () => {
      window.clearTimeout(s), t.removeEventListener("pointerdown", a), t.removeEventListener("click", i.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function y7(e, t = globalThis?.document) {
  const n = yr(e), r = C.useRef(!1);
  return C.useEffect(() => {
    const i = (a) => {
      a.target && !r.current && qO(h7, n, { originalEvent: a }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", i), () => t.removeEventListener("focusin", i);
  }, [t, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function gC() {
  const e = new CustomEvent(sv);
  document.dispatchEvent(e);
}
function qO(e, t, n, { discrete: r }) {
  const i = n.originalEvent.target, a = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && i.addEventListener(e, t, { once: !0 }), r ? VO(i, a) : i.dispatchEvent(a);
}
var B0 = "focusScope.autoFocusOnMount", $0 = "focusScope.autoFocusOnUnmount", yC = { bubbles: !1, cancelable: !0 }, v7 = "FocusScope", _p = C.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: i,
    onUnmountAutoFocus: a,
    ...s
  } = e, [u, f] = C.useState(null), d = yr(i), h = yr(a), p = C.useRef(null), g = Et(t, (x) => f(x)), y = C.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  C.useEffect(() => {
    if (r) {
      let x = function(k) {
        if (y.paused || !u) return;
        const R = k.target;
        u.contains(R) ? p.current = R : Mo(p.current, { select: !0 });
      }, E = function(k) {
        if (y.paused || !u) return;
        const R = k.relatedTarget;
        R !== null && (u.contains(R) || Mo(p.current, { select: !0 }));
      }, S = function(k) {
        if (document.activeElement === document.body)
          for (const N of k)
            N.removedNodes.length > 0 && Mo(u);
      };
      document.addEventListener("focusin", x), document.addEventListener("focusout", E);
      const A = new MutationObserver(S);
      return u && A.observe(u, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", x), document.removeEventListener("focusout", E), A.disconnect();
      };
    }
  }, [r, u, y.paused]), C.useEffect(() => {
    if (u) {
      bC.add(y);
      const x = document.activeElement;
      if (!u.contains(x)) {
        const S = new CustomEvent(B0, yC);
        u.addEventListener(B0, d), u.dispatchEvent(S), S.defaultPrevented || (b7(E7(YO(u)), { select: !0 }), document.activeElement === x && Mo(u));
      }
      return () => {
        u.removeEventListener(B0, d), setTimeout(() => {
          const S = new CustomEvent($0, yC);
          u.addEventListener($0, h), u.dispatchEvent(S), S.defaultPrevented || Mo(x ?? document.body, { select: !0 }), u.removeEventListener($0, h), bC.remove(y);
        }, 0);
      };
    }
  }, [u, d, h, y]);
  const b = C.useCallback(
    (x) => {
      if (!n && !r || y.paused) return;
      const E = x.key === "Tab" && !x.altKey && !x.ctrlKey && !x.metaKey, S = document.activeElement;
      if (E && S) {
        const A = x.currentTarget, [k, R] = x7(A);
        k && R ? !x.shiftKey && S === R ? (x.preventDefault(), n && Mo(k, { select: !0 })) : x.shiftKey && S === k && (x.preventDefault(), n && Mo(R, { select: !0 })) : S === A && x.preventDefault();
      }
    },
    [n, r, y.paused]
  );
  return /* @__PURE__ */ _.jsx(vt.div, { tabIndex: -1, ...s, ref: g, onKeyDown: b });
});
_p.displayName = v7;
function b7(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (Mo(r, { select: t }), document.activeElement !== n) return;
}
function x7(e) {
  const t = YO(e), n = vC(t, e), r = vC(t.reverse(), e);
  return [n, r];
}
function YO(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function vC(e, t) {
  for (const n of e)
    if (!w7(n, { upTo: t })) return n;
}
function w7(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function S7(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function Mo(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && S7(e) && t && e.select();
  }
}
var bC = _7();
function _7() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && n?.pause(), e = xC(e, t), e.unshift(t);
    },
    remove(t) {
      e = xC(e, t), e[0]?.resume();
    }
  };
}
function xC(e, t) {
  const n = [...e], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function E7(e) {
  return e.filter((t) => t.tagName !== "A");
}
var C7 = "Portal", Rb = C.forwardRef((e, t) => {
  const { container: n, ...r } = e, [i, a] = C.useState(!1);
  Na(() => a(!0), []);
  const s = n || i && globalThis?.document?.body;
  return s ? IL.createPortal(/* @__PURE__ */ _.jsx(vt.div, { ...r, ref: t }), s) : null;
});
Rb.displayName = C7;
function k7(e, t) {
  return C.useReducer((n, r) => t[n][r] ?? n, e);
}
var Xi = (e) => {
  const { present: t, children: n } = e, r = A7(t), i = typeof n == "function" ? n({ present: r.isPresent }) : C.Children.only(n), a = Et(r.ref, T7(i));
  return typeof n == "function" || r.isPresent ? C.cloneElement(i, { ref: a }) : null;
};
Xi.displayName = "Presence";
function A7(e) {
  const [t, n] = C.useState(), r = C.useRef({}), i = C.useRef(e), a = C.useRef("none"), s = e ? "mounted" : "unmounted", [u, f] = k7(s, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return C.useEffect(() => {
    const d = Rd(r.current);
    a.current = u === "mounted" ? d : "none";
  }, [u]), Na(() => {
    const d = r.current, h = i.current;
    if (h !== e) {
      const g = a.current, y = Rd(d);
      e ? f("MOUNT") : y === "none" || d?.display === "none" ? f("UNMOUNT") : f(h && g !== y ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e;
    }
  }, [e, f]), Na(() => {
    if (t) {
      let d;
      const h = t.ownerDocument.defaultView ?? window, p = (y) => {
        const x = Rd(r.current).includes(y.animationName);
        if (y.target === t && x && (f("ANIMATION_END"), !i.current)) {
          const E = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", d = h.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = E);
          });
        }
      }, g = (y) => {
        y.target === t && (a.current = Rd(r.current));
      };
      return t.addEventListener("animationstart", g), t.addEventListener("animationcancel", p), t.addEventListener("animationend", p), () => {
        h.clearTimeout(d), t.removeEventListener("animationstart", g), t.removeEventListener("animationcancel", p), t.removeEventListener("animationend", p);
      };
    } else
      f("ANIMATION_END");
  }, [t, f]), {
    isPresent: ["mounted", "unmountSuspended"].includes(u),
    ref: C.useCallback((d) => {
      d && (r.current = getComputedStyle(d)), n(d);
    }, [])
  };
}
function Rd(e) {
  return e?.animationName || "none";
}
function T7(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var H0 = 0;
function Ob() {
  C.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? wC()), document.body.insertAdjacentElement("beforeend", e[1] ?? wC()), H0++, () => {
      H0 === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), H0--;
    };
  }, []);
}
function wC() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var Jr = function() {
  return Jr = Object.assign || function(t) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var a in n) Object.prototype.hasOwnProperty.call(n, a) && (t[a] = n[a]);
    }
    return t;
  }, Jr.apply(this, arguments);
};
function GO(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
}
function rh(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, i = t.length, a; r < i; r++)
    (a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), a[r] = t[r]);
  return e.concat(a || Array.prototype.slice.call(t));
}
var ih = "right-scroll-bar-position", oh = "width-before-scroll-bar", R7 = "with-scroll-bars-hidden", O7 = "--removed-body-scroll-bar-size";
function V0(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function N7(e, t) {
  var n = C.useState(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var i = n.value;
          i !== r && (n.value = r, n.callback(r, i));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var M7 = typeof window < "u" ? C.useLayoutEffect : C.useEffect, SC = /* @__PURE__ */ new WeakMap();
function D7(e, t) {
  var n = N7(null, function(r) {
    return e.forEach(function(i) {
      return V0(i, r);
    });
  });
  return M7(function() {
    var r = SC.get(n);
    if (r) {
      var i = new Set(r), a = new Set(e), s = n.current;
      i.forEach(function(u) {
        a.has(u) || V0(u, null);
      }), a.forEach(function(u) {
        i.has(u) || V0(u, s);
      });
    }
    SC.set(n, e);
  }, [e]), n;
}
function P7(e) {
  return e;
}
function z7(e, t) {
  t === void 0 && (t = P7);
  var n = [], r = !1, i = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(a) {
      var s = t(a, r);
      return n.push(s), function() {
        n = n.filter(function(u) {
          return u !== s;
        });
      };
    },
    assignSyncMedium: function(a) {
      for (r = !0; n.length; ) {
        var s = n;
        n = [], s.forEach(a);
      }
      n = {
        push: function(u) {
          return a(u);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(a) {
      r = !0;
      var s = [];
      if (n.length) {
        var u = n;
        n = [], u.forEach(a), s = n;
      }
      var f = function() {
        var h = s;
        s = [], h.forEach(a);
      }, d = function() {
        return Promise.resolve().then(f);
      };
      d(), n = {
        push: function(h) {
          s.push(h), d();
        },
        filter: function(h) {
          return s = s.filter(h), n;
        }
      };
    }
  };
  return i;
}
function j7(e) {
  e === void 0 && (e = {});
  var t = z7(null);
  return t.options = Jr({ async: !0, ssr: !1 }, e), t;
}
var XO = function(e) {
  var t = e.sideCar, n = GO(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return C.createElement(r, Jr({}, n));
};
XO.isSideCarExport = !0;
function I7(e, t) {
  return e.useMedium(t), XO;
}
var WO = j7(), U0 = function() {
}, Ep = C.forwardRef(function(e, t) {
  var n = C.useRef(null), r = C.useState({
    onScrollCapture: U0,
    onWheelCapture: U0,
    onTouchMoveCapture: U0
  }), i = r[0], a = r[1], s = e.forwardProps, u = e.children, f = e.className, d = e.removeScrollBar, h = e.enabled, p = e.shards, g = e.sideCar, y = e.noIsolation, b = e.inert, x = e.allowPinchZoom, E = e.as, S = E === void 0 ? "div" : E, A = e.gapMode, k = GO(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), R = g, N = D7([n, t]), D = Jr(Jr({}, k), i);
  return C.createElement(
    C.Fragment,
    null,
    h && C.createElement(R, { sideCar: WO, removeScrollBar: d, shards: p, noIsolation: y, inert: b, setCallbacks: a, allowPinchZoom: !!x, lockRef: n, gapMode: A }),
    s ? C.cloneElement(C.Children.only(u), Jr(Jr({}, D), { ref: N })) : C.createElement(S, Jr({}, D, { className: f, ref: N }), u)
  );
});
Ep.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
Ep.classNames = {
  fullWidth: oh,
  zeroRight: ih
};
var L7 = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function F7() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = L7();
  return t && e.setAttribute("nonce", t), e;
}
function B7(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function $7(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var H7 = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = F7()) && (B7(t, n), $7(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, V7 = function() {
  var e = H7();
  return function(t, n) {
    C.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, KO = function() {
  var e = V7(), t = function(n) {
    var r = n.styles, i = n.dynamic;
    return e(r, i), null;
  };
  return t;
}, U7 = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, q0 = function(e) {
  return parseInt(e || "", 10) || 0;
}, q7 = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], i = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [q0(n), q0(r), q0(i)];
}, Y7 = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return U7;
  var t = q7(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, G7 = KO(), Gs = "data-scroll-locked", X7 = function(e, t, n, r) {
  var i = e.left, a = e.top, s = e.right, u = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(R7, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(u, "px ").concat(r, `;
  }
  body[`).concat(Gs, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(a, `px;
    padding-right: `).concat(s, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(u, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(u, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(ih, ` {
    right: `).concat(u, "px ").concat(r, `;
  }
  
  .`).concat(oh, ` {
    margin-right: `).concat(u, "px ").concat(r, `;
  }
  
  .`).concat(ih, " .").concat(ih, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(oh, " .").concat(oh, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(Gs, `] {
    `).concat(O7, ": ").concat(u, `px;
  }
`);
}, _C = function() {
  var e = parseInt(document.body.getAttribute(Gs) || "0", 10);
  return isFinite(e) ? e : 0;
}, W7 = function() {
  C.useEffect(function() {
    return document.body.setAttribute(Gs, (_C() + 1).toString()), function() {
      var e = _C() - 1;
      e <= 0 ? document.body.removeAttribute(Gs) : document.body.setAttribute(Gs, e.toString());
    };
  }, []);
}, K7 = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, i = r === void 0 ? "margin" : r;
  W7();
  var a = C.useMemo(function() {
    return Y7(i);
  }, [i]);
  return C.createElement(G7, { styles: X7(a, !t, i, n ? "" : "!important") });
}, lv = !1;
if (typeof window < "u")
  try {
    var Od = Object.defineProperty({}, "passive", {
      get: function() {
        return lv = !0, !0;
      }
    });
    window.addEventListener("test", Od, Od), window.removeEventListener("test", Od, Od);
  } catch {
    lv = !1;
  }
var Ts = lv ? { passive: !1 } : !1, Z7 = function(e) {
  return e.tagName === "TEXTAREA";
}, ZO = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !Z7(e) && n[t] === "visible")
  );
}, Q7 = function(e) {
  return ZO(e, "overflowY");
}, J7 = function(e) {
  return ZO(e, "overflowX");
}, EC = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var i = QO(e, r);
    if (i) {
      var a = JO(e, r), s = a[1], u = a[2];
      if (s > u)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, e$ = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, t$ = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, QO = function(e, t) {
  return e === "v" ? Q7(t) : J7(t);
}, JO = function(e, t) {
  return e === "v" ? e$(t) : t$(t);
}, n$ = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, r$ = function(e, t, n, r, i) {
  var a = n$(e, window.getComputedStyle(t).direction), s = a * r, u = n.target, f = t.contains(u), d = !1, h = s > 0, p = 0, g = 0;
  do {
    var y = JO(e, u), b = y[0], x = y[1], E = y[2], S = x - E - a * b;
    (b || S) && QO(e, u) && (p += S, g += b), u instanceof ShadowRoot ? u = u.host : u = u.parentNode;
  } while (
    // portaled content
    !f && u !== document.body || // self content
    f && (t.contains(u) || t === u)
  );
  return (h && Math.abs(p) < 1 || !h && Math.abs(g) < 1) && (d = !0), d;
}, Nd = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, CC = function(e) {
  return [e.deltaX, e.deltaY];
}, kC = function(e) {
  return e && "current" in e ? e.current : e;
}, i$ = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, o$ = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, a$ = 0, Rs = [];
function s$(e) {
  var t = C.useRef([]), n = C.useRef([0, 0]), r = C.useRef(), i = C.useState(a$++)[0], a = C.useState(KO)[0], s = C.useRef(e);
  C.useEffect(function() {
    s.current = e;
  }, [e]), C.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var x = rh([e.lockRef.current], (e.shards || []).map(kC), !0).filter(Boolean);
      return x.forEach(function(E) {
        return E.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), x.forEach(function(E) {
          return E.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var u = C.useCallback(function(x, E) {
    if ("touches" in x && x.touches.length === 2 || x.type === "wheel" && x.ctrlKey)
      return !s.current.allowPinchZoom;
    var S = Nd(x), A = n.current, k = "deltaX" in x ? x.deltaX : A[0] - S[0], R = "deltaY" in x ? x.deltaY : A[1] - S[1], N, D = x.target, P = Math.abs(k) > Math.abs(R) ? "h" : "v";
    if ("touches" in x && P === "h" && D.type === "range")
      return !1;
    var F = EC(P, D);
    if (!F)
      return !0;
    if (F ? N = P : (N = P === "v" ? "h" : "v", F = EC(P, D)), !F)
      return !1;
    if (!r.current && "changedTouches" in x && (k || R) && (r.current = N), !N)
      return !0;
    var V = r.current || N;
    return r$(V, E, x, V === "h" ? k : R);
  }, []), f = C.useCallback(function(x) {
    var E = x;
    if (!(!Rs.length || Rs[Rs.length - 1] !== a)) {
      var S = "deltaY" in E ? CC(E) : Nd(E), A = t.current.filter(function(N) {
        return N.name === E.type && (N.target === E.target || E.target === N.shadowParent) && i$(N.delta, S);
      })[0];
      if (A && A.should) {
        E.cancelable && E.preventDefault();
        return;
      }
      if (!A) {
        var k = (s.current.shards || []).map(kC).filter(Boolean).filter(function(N) {
          return N.contains(E.target);
        }), R = k.length > 0 ? u(E, k[0]) : !s.current.noIsolation;
        R && E.cancelable && E.preventDefault();
      }
    }
  }, []), d = C.useCallback(function(x, E, S, A) {
    var k = { name: x, delta: E, target: S, should: A, shadowParent: l$(S) };
    t.current.push(k), setTimeout(function() {
      t.current = t.current.filter(function(R) {
        return R !== k;
      });
    }, 1);
  }, []), h = C.useCallback(function(x) {
    n.current = Nd(x), r.current = void 0;
  }, []), p = C.useCallback(function(x) {
    d(x.type, CC(x), x.target, u(x, e.lockRef.current));
  }, []), g = C.useCallback(function(x) {
    d(x.type, Nd(x), x.target, u(x, e.lockRef.current));
  }, []);
  C.useEffect(function() {
    return Rs.push(a), e.setCallbacks({
      onScrollCapture: p,
      onWheelCapture: p,
      onTouchMoveCapture: g
    }), document.addEventListener("wheel", f, Ts), document.addEventListener("touchmove", f, Ts), document.addEventListener("touchstart", h, Ts), function() {
      Rs = Rs.filter(function(x) {
        return x !== a;
      }), document.removeEventListener("wheel", f, Ts), document.removeEventListener("touchmove", f, Ts), document.removeEventListener("touchstart", h, Ts);
    };
  }, []);
  var y = e.removeScrollBar, b = e.inert;
  return C.createElement(
    C.Fragment,
    null,
    b ? C.createElement(a, { styles: o$(i) }) : null,
    y ? C.createElement(K7, { gapMode: e.gapMode }) : null
  );
}
function l$(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const u$ = I7(WO, s$);
var Cp = C.forwardRef(function(e, t) {
  return C.createElement(Ep, Jr({}, e, { ref: t, sideCar: u$ }));
});
Cp.classNames = Ep.classNames;
var c$ = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, Os = /* @__PURE__ */ new WeakMap(), Md = /* @__PURE__ */ new WeakMap(), Dd = {}, Y0 = 0, eN = function(e) {
  return e && (e.host || eN(e.parentNode));
}, f$ = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = eN(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, d$ = function(e, t, n, r) {
  var i = f$(t, Array.isArray(e) ? e : [e]);
  Dd[n] || (Dd[n] = /* @__PURE__ */ new WeakMap());
  var a = Dd[n], s = [], u = /* @__PURE__ */ new Set(), f = new Set(i), d = function(p) {
    !p || u.has(p) || (u.add(p), d(p.parentNode));
  };
  i.forEach(d);
  var h = function(p) {
    !p || f.has(p) || Array.prototype.forEach.call(p.children, function(g) {
      if (u.has(g))
        h(g);
      else
        try {
          var y = g.getAttribute(r), b = y !== null && y !== "false", x = (Os.get(g) || 0) + 1, E = (a.get(g) || 0) + 1;
          Os.set(g, x), a.set(g, E), s.push(g), x === 1 && b && Md.set(g, !0), E === 1 && g.setAttribute(n, "true"), b || g.setAttribute(r, "true");
        } catch (S) {
          console.error("aria-hidden: cannot operate on ", g, S);
        }
    });
  };
  return h(t), u.clear(), Y0++, function() {
    s.forEach(function(p) {
      var g = Os.get(p) - 1, y = a.get(p) - 1;
      Os.set(p, g), a.set(p, y), g || (Md.has(p) || p.removeAttribute(r), Md.delete(p)), y || p.removeAttribute(n);
    }), Y0--, Y0 || (Os = /* @__PURE__ */ new WeakMap(), Os = /* @__PURE__ */ new WeakMap(), Md = /* @__PURE__ */ new WeakMap(), Dd = {});
  };
}, Nb = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), i = c$(e);
  return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live]"))), d$(r, i, n, "aria-hidden")) : function() {
    return null;
  };
}, Mb = "Dialog", [tN, Tue] = Go(Mb), [h$, Ir] = tN(Mb), nN = (e) => {
  const {
    __scopeDialog: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: a,
    modal: s = !0
  } = e, u = C.useRef(null), f = C.useRef(null), [d = !1, h] = yl({
    prop: r,
    defaultProp: i,
    onChange: a
  });
  return /* @__PURE__ */ _.jsx(
    h$,
    {
      scope: t,
      triggerRef: u,
      contentRef: f,
      contentId: Li(),
      titleId: Li(),
      descriptionId: Li(),
      open: d,
      onOpenChange: h,
      onOpenToggle: C.useCallback(() => h((p) => !p), [h]),
      modal: s,
      children: n
    }
  );
};
nN.displayName = Mb;
var rN = "DialogTrigger", iN = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Ir(rN, n), a = Et(t, i.triggerRef);
    return /* @__PURE__ */ _.jsx(
      vt.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": zb(i.open),
        ...r,
        ref: a,
        onClick: De(e.onClick, i.onOpenToggle)
      }
    );
  }
);
iN.displayName = rN;
var Db = "DialogPortal", [p$, oN] = tN(Db, {
  forceMount: void 0
}), aN = (e) => {
  const { __scopeDialog: t, forceMount: n, children: r, container: i } = e, a = Ir(Db, t);
  return /* @__PURE__ */ _.jsx(p$, { scope: t, forceMount: n, children: C.Children.map(r, (s) => /* @__PURE__ */ _.jsx(Xi, { present: n || a.open, children: /* @__PURE__ */ _.jsx(Rb, { asChild: !0, container: i, children: s }) })) });
};
aN.displayName = Db;
var Oh = "DialogOverlay", sN = C.forwardRef(
  (e, t) => {
    const n = oN(Oh, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, a = Ir(Oh, e.__scopeDialog);
    return a.modal ? /* @__PURE__ */ _.jsx(Xi, { present: r || a.open, children: /* @__PURE__ */ _.jsx(g$, { ...i, ref: t }) }) : null;
  }
);
sN.displayName = Oh;
var m$ = /* @__PURE__ */ sl("DialogOverlay.RemoveScroll"), g$ = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Ir(Oh, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ _.jsx(Cp, { as: m$, allowPinchZoom: !0, shards: [i.contentRef], children: /* @__PURE__ */ _.jsx(
        vt.div,
        {
          "data-state": zb(i.open),
          ...r,
          ref: t,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), Ma = "DialogContent", lN = C.forwardRef(
  (e, t) => {
    const n = oN(Ma, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, a = Ir(Ma, e.__scopeDialog);
    return /* @__PURE__ */ _.jsx(Xi, { present: r || a.open, children: a.modal ? /* @__PURE__ */ _.jsx(y$, { ...i, ref: t }) : /* @__PURE__ */ _.jsx(v$, { ...i, ref: t }) });
  }
);
lN.displayName = Ma;
var y$ = C.forwardRef(
  (e, t) => {
    const n = Ir(Ma, e.__scopeDialog), r = C.useRef(null), i = Et(t, n.contentRef, r);
    return C.useEffect(() => {
      const a = r.current;
      if (a) return Nb(a);
    }, []), /* @__PURE__ */ _.jsx(
      uN,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: De(e.onCloseAutoFocus, (a) => {
          a.preventDefault(), n.triggerRef.current?.focus();
        }),
        onPointerDownOutside: De(e.onPointerDownOutside, (a) => {
          const s = a.detail.originalEvent, u = s.button === 0 && s.ctrlKey === !0;
          (s.button === 2 || u) && a.preventDefault();
        }),
        onFocusOutside: De(
          e.onFocusOutside,
          (a) => a.preventDefault()
        )
      }
    );
  }
), v$ = C.forwardRef(
  (e, t) => {
    const n = Ir(Ma, e.__scopeDialog), r = C.useRef(!1), i = C.useRef(!1);
    return /* @__PURE__ */ _.jsx(
      uN,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (a) => {
          e.onCloseAutoFocus?.(a), a.defaultPrevented || (r.current || n.triggerRef.current?.focus(), a.preventDefault()), r.current = !1, i.current = !1;
        },
        onInteractOutside: (a) => {
          e.onInteractOutside?.(a), a.defaultPrevented || (r.current = !0, a.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const s = a.target;
          n.triggerRef.current?.contains(s) && a.preventDefault(), a.detail.originalEvent.type === "focusin" && i.current && a.preventDefault();
        }
      }
    );
  }
), uN = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: a, ...s } = e, u = Ir(Ma, n), f = C.useRef(null), d = Et(t, f);
    return Ob(), /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
      /* @__PURE__ */ _.jsx(
        _p,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: i,
          onUnmountAutoFocus: a,
          children: /* @__PURE__ */ _.jsx(
            Sp,
            {
              role: "dialog",
              id: u.contentId,
              "aria-describedby": u.descriptionId,
              "aria-labelledby": u.titleId,
              "data-state": zb(u.open),
              ...s,
              ref: d,
              onDismiss: () => u.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
        /* @__PURE__ */ _.jsx(b$, { titleId: u.titleId }),
        /* @__PURE__ */ _.jsx(w$, { contentRef: f, descriptionId: u.descriptionId })
      ] })
    ] });
  }
), Pb = "DialogTitle", cN = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Ir(Pb, n);
    return /* @__PURE__ */ _.jsx(vt.h2, { id: i.titleId, ...r, ref: t });
  }
);
cN.displayName = Pb;
var fN = "DialogDescription", dN = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Ir(fN, n);
    return /* @__PURE__ */ _.jsx(vt.p, { id: i.descriptionId, ...r, ref: t });
  }
);
dN.displayName = fN;
var hN = "DialogClose", pN = C.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Ir(hN, n);
    return /* @__PURE__ */ _.jsx(
      vt.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: De(e.onClick, () => i.onOpenChange(!1))
      }
    );
  }
);
pN.displayName = hN;
function zb(e) {
  return e ? "open" : "closed";
}
var mN = "DialogTitleWarning", [Rue, gN] = JB(mN, {
  contentName: Ma,
  titleName: Pb,
  docsSlug: "dialog"
}), b$ = ({ titleId: e }) => {
  const t = gN(mN), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return C.useEffect(() => {
    e && (document.getElementById(e) || console.error(n));
  }, [n, e]), null;
}, x$ = "DialogDescriptionWarning", w$ = ({ contentRef: e, descriptionId: t }) => {
  const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${gN(x$).contentName}}.`;
  return C.useEffect(() => {
    const i = e.current?.getAttribute("aria-describedby");
    t && i && (document.getElementById(t) || console.warn(r));
  }, [r, e, t]), null;
}, S$ = nN, _$ = iN, E$ = aN, C$ = sN, k$ = lN, A$ = cN, T$ = dN, AC = pN;
/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */
function R$(e, t, n) {
  return (t = N$(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function TC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function me(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TC(Object(n), !0).forEach(function(r) {
      R$(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function O$(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function N$(e) {
  var t = O$(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
const RC = () => {
};
let jb = {}, yN = {}, vN = null, bN = {
  mark: RC,
  measure: RC
};
try {
  typeof window < "u" && (jb = window), typeof document < "u" && (yN = document), typeof MutationObserver < "u" && (vN = MutationObserver), typeof performance < "u" && (bN = performance);
} catch {
}
const {
  userAgent: OC = ""
} = jb.navigator || {}, Bo = jb, xt = yN, NC = vN, Pd = bN;
Bo.document;
const Wi = !!xt.documentElement && !!xt.head && typeof xt.addEventListener == "function" && typeof xt.createElement == "function", xN = ~OC.indexOf("MSIE") || ~OC.indexOf("Trident/");
var M$ = /fa(s|r|l|t|d|dr|dl|dt|b|k|kd|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/, D$ = /Font ?Awesome ?([56 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit)?.*/i, wN = {
  classic: {
    fa: "solid",
    fas: "solid",
    "fa-solid": "solid",
    far: "regular",
    "fa-regular": "regular",
    fal: "light",
    "fa-light": "light",
    fat: "thin",
    "fa-thin": "thin",
    fab: "brands",
    "fa-brands": "brands"
  },
  duotone: {
    fa: "solid",
    fad: "solid",
    "fa-solid": "solid",
    "fa-duotone": "solid",
    fadr: "regular",
    "fa-regular": "regular",
    fadl: "light",
    "fa-light": "light",
    fadt: "thin",
    "fa-thin": "thin"
  },
  sharp: {
    fa: "solid",
    fass: "solid",
    "fa-solid": "solid",
    fasr: "regular",
    "fa-regular": "regular",
    fasl: "light",
    "fa-light": "light",
    fast: "thin",
    "fa-thin": "thin"
  },
  "sharp-duotone": {
    fa: "solid",
    fasds: "solid",
    "fa-solid": "solid",
    fasdr: "regular",
    "fa-regular": "regular",
    fasdl: "light",
    "fa-light": "light",
    fasdt: "thin",
    "fa-thin": "thin"
  }
}, P$ = {
  GROUP: "duotone-group",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, SN = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"], pn = "classic", kp = "duotone", z$ = "sharp", j$ = "sharp-duotone", _N = [pn, kp, z$, j$], I$ = {
  classic: {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  duotone: {
    900: "fad",
    400: "fadr",
    300: "fadl",
    100: "fadt"
  },
  sharp: {
    900: "fass",
    400: "fasr",
    300: "fasl",
    100: "fast"
  },
  "sharp-duotone": {
    900: "fasds",
    400: "fasdr",
    300: "fasdl",
    100: "fasdt"
  }
}, L$ = {
  "Font Awesome 6 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 6 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  "Font Awesome 6 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 6 Duotone": {
    900: "fad",
    400: "fadr",
    normal: "fadr",
    300: "fadl",
    100: "fadt"
  },
  "Font Awesome 6 Sharp": {
    900: "fass",
    400: "fasr",
    normal: "fasr",
    300: "fasl",
    100: "fast"
  },
  "Font Awesome 6 Sharp Duotone": {
    900: "fasds",
    400: "fasdr",
    normal: "fasdr",
    300: "fasdl",
    100: "fasdt"
  }
}, F$ = /* @__PURE__ */ new Map([["classic", {
  defaultShortPrefixId: "fas",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin", "brands"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp", {
  defaultShortPrefixId: "fass",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["duotone", {
  defaultShortPrefixId: "fad",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp-duotone", {
  defaultShortPrefixId: "fasds",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}]]), B$ = {
  classic: {
    solid: "fas",
    regular: "far",
    light: "fal",
    thin: "fat",
    brands: "fab"
  },
  duotone: {
    solid: "fad",
    regular: "fadr",
    light: "fadl",
    thin: "fadt"
  },
  sharp: {
    solid: "fass",
    regular: "fasr",
    light: "fasl",
    thin: "fast"
  },
  "sharp-duotone": {
    solid: "fasds",
    regular: "fasdr",
    light: "fasdl",
    thin: "fasdt"
  }
}, $$ = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], MC = {
  kit: {
    fak: "kit",
    "fa-kit": "kit"
  },
  "kit-duotone": {
    fakd: "kit-duotone",
    "fa-kit-duotone": "kit-duotone"
  }
}, H$ = ["kit"], V$ = {
  kit: {
    "fa-kit": "fak"
  }
}, U$ = ["fak", "fakd"], q$ = {
  kit: {
    fak: "fa-kit"
  }
}, DC = {
  kit: {
    kit: "fak"
  },
  "kit-duotone": {
    "kit-duotone": "fakd"
  }
}, zd = {
  GROUP: "duotone-group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, Y$ = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone"], G$ = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], X$ = {
  "Font Awesome Kit": {
    400: "fak",
    normal: "fak"
  },
  "Font Awesome Kit Duotone": {
    400: "fakd",
    normal: "fakd"
  }
}, W$ = {
  classic: {
    "fa-brands": "fab",
    "fa-duotone": "fad",
    "fa-light": "fal",
    "fa-regular": "far",
    "fa-solid": "fas",
    "fa-thin": "fat"
  },
  duotone: {
    "fa-regular": "fadr",
    "fa-light": "fadl",
    "fa-thin": "fadt"
  },
  sharp: {
    "fa-solid": "fass",
    "fa-regular": "fasr",
    "fa-light": "fasl",
    "fa-thin": "fast"
  },
  "sharp-duotone": {
    "fa-solid": "fasds",
    "fa-regular": "fasdr",
    "fa-light": "fasdl",
    "fa-thin": "fasdt"
  }
}, K$ = {
  classic: ["fas", "far", "fal", "fat", "fad"],
  duotone: ["fadr", "fadl", "fadt"],
  sharp: ["fass", "fasr", "fasl", "fast"],
  "sharp-duotone": ["fasds", "fasdr", "fasdl", "fasdt"]
}, uv = {
  classic: {
    fab: "fa-brands",
    fad: "fa-duotone",
    fal: "fa-light",
    far: "fa-regular",
    fas: "fa-solid",
    fat: "fa-thin"
  },
  duotone: {
    fadr: "fa-regular",
    fadl: "fa-light",
    fadt: "fa-thin"
  },
  sharp: {
    fass: "fa-solid",
    fasr: "fa-regular",
    fasl: "fa-light",
    fast: "fa-thin"
  },
  "sharp-duotone": {
    fasds: "fa-solid",
    fasdr: "fa-regular",
    fasdl: "fa-light",
    fasdt: "fa-thin"
  }
}, Z$ = ["fa-solid", "fa-regular", "fa-light", "fa-thin", "fa-duotone", "fa-brands"], cv = ["fa", "fas", "far", "fal", "fat", "fad", "fadr", "fadl", "fadt", "fab", "fass", "fasr", "fasl", "fast", "fasds", "fasdr", "fasdl", "fasdt", ...Y$, ...Z$], Q$ = ["solid", "regular", "light", "thin", "duotone", "brands"], EN = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], J$ = EN.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), eH = [...Object.keys(K$), ...Q$, "2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "fw", "inverse", "layers-counter", "layers-text", "layers", "li", "pull-left", "pull-right", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", zd.GROUP, zd.SWAP_OPACITY, zd.PRIMARY, zd.SECONDARY].concat(EN.map((e) => "".concat(e, "x"))).concat(J$.map((e) => "w-".concat(e))), tH = {
  "Font Awesome 5 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 5 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal"
  },
  "Font Awesome 5 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 5 Duotone": {
    900: "fad"
  }
};
const Hi = "___FONT_AWESOME___", fv = 16, CN = "fa", kN = "svg-inline--fa", Da = "data-fa-i2svg", dv = "data-fa-pseudo-element", nH = "data-fa-pseudo-element-pending", Ib = "data-prefix", Lb = "data-icon", PC = "fontawesome-i2svg", rH = "async", iH = ["HTML", "HEAD", "STYLE", "SCRIPT"], AN = (() => {
  try {
    return !0;
  } catch {
    return !1;
  }
})();
function Fc(e) {
  return new Proxy(e, {
    get(t, n) {
      return n in t ? t[n] : t[pn];
    }
  });
}
const TN = me({}, wN);
TN[pn] = me(me(me(me({}, {
  "fa-duotone": "duotone"
}), wN[pn]), MC.kit), MC["kit-duotone"]);
const oH = Fc(TN), hv = me({}, B$);
hv[pn] = me(me(me(me({}, {
  duotone: "fad"
}), hv[pn]), DC.kit), DC["kit-duotone"]);
const zC = Fc(hv), pv = me({}, uv);
pv[pn] = me(me({}, pv[pn]), q$.kit);
const Fb = Fc(pv), mv = me({}, W$);
mv[pn] = me(me({}, mv[pn]), V$.kit);
Fc(mv);
const aH = M$, RN = "fa-layers-text", sH = D$, lH = me({}, I$);
Fc(lH);
const uH = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"], G0 = P$, cH = [...H$, ...eH], Zu = Bo.FontAwesomeConfig || {};
function fH(e) {
  var t = xt.querySelector("script[" + e + "]");
  if (t)
    return t.getAttribute(e);
}
function dH(e) {
  return e === "" ? !0 : e === "false" ? !1 : e === "true" ? !0 : e;
}
xt && typeof xt.querySelector == "function" && [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-auto-a11y", "autoA11y"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]].forEach((t) => {
  let [n, r] = t;
  const i = dH(fH(n));
  i != null && (Zu[r] = i);
});
const ON = {
  styleDefault: "solid",
  familyDefault: pn,
  cssPrefix: CN,
  replacementClass: kN,
  autoReplaceSvg: !0,
  autoAddCss: !0,
  autoA11y: !0,
  searchPseudoElements: !1,
  observeMutations: !0,
  mutateApproach: "async",
  keepOriginalSource: !0,
  measurePerformance: !1,
  showMissingIcons: !0
};
Zu.familyPrefix && (Zu.cssPrefix = Zu.familyPrefix);
const ll = me(me({}, ON), Zu);
ll.autoReplaceSvg || (ll.observeMutations = !1);
const we = {};
Object.keys(ON).forEach((e) => {
  Object.defineProperty(we, e, {
    enumerable: !0,
    set: function(t) {
      ll[e] = t, Qu.forEach((n) => n(we));
    },
    get: function() {
      return ll[e];
    }
  });
});
Object.defineProperty(we, "familyPrefix", {
  enumerable: !0,
  set: function(e) {
    ll.cssPrefix = e, Qu.forEach((t) => t(we));
  },
  get: function() {
    return ll.cssPrefix;
  }
});
Bo.FontAwesomeConfig = we;
const Qu = [];
function hH(e) {
  return Qu.push(e), () => {
    Qu.splice(Qu.indexOf(e), 1);
  };
}
const Oo = fv, ei = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: !1,
  flipY: !1
};
function pH(e) {
  if (!e || !Wi)
    return;
  const t = xt.createElement("style");
  t.setAttribute("type", "text/css"), t.innerHTML = e;
  const n = xt.head.childNodes;
  let r = null;
  for (let i = n.length - 1; i > -1; i--) {
    const a = n[i], s = (a.tagName || "").toUpperCase();
    ["STYLE", "LINK"].indexOf(s) > -1 && (r = a);
  }
  return xt.head.insertBefore(t, r), e;
}
const mH = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function pc() {
  let e = 12, t = "";
  for (; e-- > 0; )
    t += mH[Math.random() * 62 | 0];
  return t;
}
function vl(e) {
  const t = [];
  for (let n = (e || []).length >>> 0; n--; )
    t[n] = e[n];
  return t;
}
function Bb(e) {
  return e.classList ? vl(e.classList) : (e.getAttribute("class") || "").split(" ").filter((t) => t);
}
function NN(e) {
  return "".concat(e).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function gH(e) {
  return Object.keys(e || {}).reduce((t, n) => t + "".concat(n, '="').concat(NN(e[n]), '" '), "").trim();
}
function Ap(e) {
  return Object.keys(e || {}).reduce((t, n) => t + "".concat(n, ": ").concat(e[n].trim(), ";"), "");
}
function $b(e) {
  return e.size !== ei.size || e.x !== ei.x || e.y !== ei.y || e.rotate !== ei.rotate || e.flipX || e.flipY;
}
function yH(e) {
  let {
    transform: t,
    containerWidth: n,
    iconWidth: r
  } = e;
  const i = {
    transform: "translate(".concat(n / 2, " 256)")
  }, a = "translate(".concat(t.x * 32, ", ").concat(t.y * 32, ") "), s = "scale(".concat(t.size / 16 * (t.flipX ? -1 : 1), ", ").concat(t.size / 16 * (t.flipY ? -1 : 1), ") "), u = "rotate(".concat(t.rotate, " 0 0)"), f = {
    transform: "".concat(a, " ").concat(s, " ").concat(u)
  }, d = {
    transform: "translate(".concat(r / 2 * -1, " -256)")
  };
  return {
    outer: i,
    inner: f,
    path: d
  };
}
function vH(e) {
  let {
    transform: t,
    width: n = fv,
    height: r = fv,
    startCentered: i = !1
  } = e, a = "";
  return i && xN ? a += "translate(".concat(t.x / Oo - n / 2, "em, ").concat(t.y / Oo - r / 2, "em) ") : i ? a += "translate(calc(-50% + ".concat(t.x / Oo, "em), calc(-50% + ").concat(t.y / Oo, "em)) ") : a += "translate(".concat(t.x / Oo, "em, ").concat(t.y / Oo, "em) "), a += "scale(".concat(t.size / Oo * (t.flipX ? -1 : 1), ", ").concat(t.size / Oo * (t.flipY ? -1 : 1), ") "), a += "rotate(".concat(t.rotate, "deg) "), a;
}
var bH = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Free";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Free";
  --fa-font-light: normal 300 1em/1 "Font Awesome 6 Pro";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 6 Pro";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-regular: normal 400 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-light: normal 300 1em/1 "Font Awesome 6 Duotone";
  --fa-font-duotone-thin: normal 100 1em/1 "Font Awesome 6 Duotone";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 6 Sharp";
  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-regular: normal 400 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-light: normal 300 1em/1 "Font Awesome 6 Sharp Duotone";
  --fa-font-sharp-duotone-thin: normal 100 1em/1 "Font Awesome 6 Sharp Duotone";
}

svg:not(:root).svg-inline--fa, svg:not(:host).svg-inline--fa {
  overflow: visible;
  box-sizing: content-box;
}

.svg-inline--fa {
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285705em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left {
  margin-right: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-pull-right {
  margin-left: var(--fa-pull-margin, 0.3em);
  width: auto;
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  top: 0.25em;
}
.svg-inline--fa.fa-fw {
  width: var(--fa-fw-width, 1.25em);
}

.fa-layers svg.svg-inline--fa {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: 1em;
}
.fa-layers svg.svg-inline--fa {
  transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-counter-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: 0.625em;
  line-height: 0.1em;
  vertical-align: 0.225em;
}

.fa-xs {
  font-size: 0.75em;
  line-height: 0.0833333337em;
  vertical-align: 0.125em;
}

.fa-sm {
  font-size: 0.875em;
  line-height: 0.0714285718em;
  vertical-align: 0.0535714295em;
}

.fa-lg {
  font-size: 1.25em;
  line-height: 0.05em;
  vertical-align: -0.075em;
}

.fa-xl {
  font-size: 1.5em;
  line-height: 0.0416666682em;
  vertical-align: -0.125em;
}

.fa-2xl {
  font-size: 2em;
  line-height: 0.03125em;
  vertical-align: -0.1875em;
}

.fa-fw {
  text-align: center;
  width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-left: var(--fa-li-margin, 2.5em);
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  left: calc(-1 * var(--fa-li-width, 2em));
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.08em);
  padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);
}

.fa-pull-left {
  float: left;
  margin-right: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right {
  float: right;
  margin-left: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  animation-name: fa-beat;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  animation-name: fa-bounce;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  animation-name: fa-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  animation-name: fa-beat-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  animation-name: fa-flip;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  animation-name: fa-shake;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  animation-name: fa-spin;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 2s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  animation-name: fa-spin;
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
.fa-bounce,
.fa-fade,
.fa-beat-fade,
.fa-flip,
.fa-pulse,
.fa-shake,
.fa-spin,
.fa-spin-pulse {
    animation-delay: -1ms;
    animation-duration: 1ms;
    animation-iteration-count: 1;
    transition-delay: 0s;
    transition-duration: 0s;
  }
}
@keyframes fa-beat {
  0%, 90% {
    transform: scale(1);
  }
  45% {
    transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-bounce {
  0% {
    transform: scale(1, 1) translateY(0);
  }
  10% {
    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    transform: scale(1, 1) translateY(0);
  }
  100% {
    transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-flip {
  50% {
    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-shake {
  0% {
    transform: rotate(-15deg);
  }
  4% {
    transform: rotate(15deg);
  }
  8%, 24% {
    transform: rotate(-18deg);
  }
  12%, 28% {
    transform: rotate(18deg);
  }
  16% {
    transform: rotate(-22deg);
  }
  20% {
    transform: rotate(22deg);
  }
  32% {
    transform: rotate(-12deg);
  }
  36% {
    transform: rotate(12deg);
  }
  40%, 100% {
    transform: rotate(0deg);
  }
}
@keyframes fa-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  transform: rotate(90deg);
}

.fa-rotate-180 {
  transform: rotate(180deg);
}

.fa-rotate-270 {
  transform: rotate(270deg);
}

.fa-flip-horizontal {
  transform: scale(-1, 1);
}

.fa-flip-vertical {
  transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  transform: scale(-1, -1);
}

.fa-rotate-by {
  transform: rotate(var(--fa-rotate-angle, 0));
}

.fa-stack {
  display: inline-block;
  vertical-align: middle;
  height: 2em;
  position: relative;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
  z-index: var(--fa-stack-z-index, auto);
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.sr-only,
.fa-sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.sr-only-focusable:not(:focus),
.fa-sr-only-focusable:not(:focus) {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}`;
function MN() {
  const e = CN, t = kN, n = we.cssPrefix, r = we.replacementClass;
  let i = bH;
  if (n !== e || r !== t) {
    const a = new RegExp("\\.".concat(e, "\\-"), "g"), s = new RegExp("\\--".concat(e, "\\-"), "g"), u = new RegExp("\\.".concat(t), "g");
    i = i.replace(a, ".".concat(n, "-")).replace(s, "--".concat(n, "-")).replace(u, ".".concat(r));
  }
  return i;
}
let jC = !1;
function X0() {
  we.autoAddCss && !jC && (pH(MN()), jC = !0);
}
var xH = {
  mixout() {
    return {
      dom: {
        css: MN,
        insertCss: X0
      }
    };
  },
  hooks() {
    return {
      beforeDOMElementCreation() {
        X0();
      },
      beforeI2svg() {
        X0();
      }
    };
  }
};
const Vi = Bo || {};
Vi[Hi] || (Vi[Hi] = {});
Vi[Hi].styles || (Vi[Hi].styles = {});
Vi[Hi].hooks || (Vi[Hi].hooks = {});
Vi[Hi].shims || (Vi[Hi].shims = []);
var ti = Vi[Hi];
const DN = [], PN = function() {
  xt.removeEventListener("DOMContentLoaded", PN), Nh = 1, DN.map((e) => e());
};
let Nh = !1;
Wi && (Nh = (xt.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(xt.readyState), Nh || xt.addEventListener("DOMContentLoaded", PN));
function wH(e) {
  Wi && (Nh ? setTimeout(e, 0) : DN.push(e));
}
function Bc(e) {
  const {
    tag: t,
    attributes: n = {},
    children: r = []
  } = e;
  return typeof e == "string" ? NN(e) : "<".concat(t, " ").concat(gH(n), ">").concat(r.map(Bc).join(""), "</").concat(t, ">");
}
function IC(e, t, n) {
  if (e && e[t] && e[t][n])
    return {
      prefix: t,
      iconName: n,
      icon: e[t][n]
    };
}
var W0 = function(t, n, r, i) {
  var a = Object.keys(t), s = a.length, u = n, f, d, h;
  for (r === void 0 ? (f = 1, h = t[a[0]]) : (f = 0, h = r); f < s; f++)
    d = a[f], h = u(h, t[d], d, t);
  return h;
};
function SH(e) {
  const t = [];
  let n = 0;
  const r = e.length;
  for (; n < r; ) {
    const i = e.charCodeAt(n++);
    if (i >= 55296 && i <= 56319 && n < r) {
      const a = e.charCodeAt(n++);
      (a & 64512) == 56320 ? t.push(((i & 1023) << 10) + (a & 1023) + 65536) : (t.push(i), n--);
    } else
      t.push(i);
  }
  return t;
}
function gv(e) {
  const t = SH(e);
  return t.length === 1 ? t[0].toString(16) : null;
}
function _H(e, t) {
  const n = e.length;
  let r = e.charCodeAt(t), i;
  return r >= 55296 && r <= 56319 && n > t + 1 && (i = e.charCodeAt(t + 1), i >= 56320 && i <= 57343) ? (r - 55296) * 1024 + i - 56320 + 65536 : r;
}
function LC(e) {
  return Object.keys(e).reduce((t, n) => {
    const r = e[n];
    return !!r.icon ? t[r.iconName] = r.icon : t[n] = r, t;
  }, {});
}
function yv(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    skipHooks: r = !1
  } = n, i = LC(t);
  typeof ti.hooks.addPack == "function" && !r ? ti.hooks.addPack(e, LC(t)) : ti.styles[e] = me(me({}, ti.styles[e] || {}), i), e === "fas" && yv("fa", t);
}
const {
  styles: mc,
  shims: EH
} = ti, zN = Object.keys(Fb), CH = zN.reduce((e, t) => (e[t] = Object.keys(Fb[t]), e), {});
let Hb = null, jN = {}, IN = {}, LN = {}, FN = {}, BN = {};
function kH(e) {
  return ~cH.indexOf(e);
}
function AH(e, t) {
  const n = t.split("-"), r = n[0], i = n.slice(1).join("-");
  return r === e && i !== "" && !kH(i) ? i : null;
}
const $N = () => {
  const e = (r) => W0(mc, (i, a, s) => (i[s] = W0(a, r, {}), i), {});
  jN = e((r, i, a) => (i[3] && (r[i[3]] = a), i[2] && i[2].filter((u) => typeof u == "number").forEach((u) => {
    r[u.toString(16)] = a;
  }), r)), IN = e((r, i, a) => (r[a] = a, i[2] && i[2].filter((u) => typeof u == "string").forEach((u) => {
    r[u] = a;
  }), r)), BN = e((r, i, a) => {
    const s = i[2];
    return r[a] = a, s.forEach((u) => {
      r[u] = a;
    }), r;
  });
  const t = "far" in mc || we.autoFetchSvg, n = W0(EH, (r, i) => {
    const a = i[0];
    let s = i[1];
    const u = i[2];
    return s === "far" && !t && (s = "fas"), typeof a == "string" && (r.names[a] = {
      prefix: s,
      iconName: u
    }), typeof a == "number" && (r.unicodes[a.toString(16)] = {
      prefix: s,
      iconName: u
    }), r;
  }, {
    names: {},
    unicodes: {}
  });
  LN = n.names, FN = n.unicodes, Hb = Tp(we.styleDefault, {
    family: we.familyDefault
  });
};
hH((e) => {
  Hb = Tp(e.styleDefault, {
    family: we.familyDefault
  });
});
$N();
function Vb(e, t) {
  return (jN[e] || {})[t];
}
function TH(e, t) {
  return (IN[e] || {})[t];
}
function Sa(e, t) {
  return (BN[e] || {})[t];
}
function HN(e) {
  return LN[e] || {
    prefix: null,
    iconName: null
  };
}
function RH(e) {
  const t = FN[e], n = Vb("fas", e);
  return t || (n ? {
    prefix: "fas",
    iconName: n
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function $o() {
  return Hb;
}
const VN = () => ({
  prefix: null,
  iconName: null,
  rest: []
});
function OH(e) {
  let t = pn;
  const n = zN.reduce((r, i) => (r[i] = "".concat(we.cssPrefix, "-").concat(i), r), {});
  return _N.forEach((r) => {
    (e.includes(n[r]) || e.some((i) => CH[r].includes(i))) && (t = r);
  }), t;
}
function Tp(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    family: n = pn
  } = t, r = oH[n][e];
  if (n === kp && !e)
    return "fad";
  const i = zC[n][e] || zC[n][r], a = e in ti.styles ? e : null;
  return i || a || null;
}
function NH(e) {
  let t = [], n = null;
  return e.forEach((r) => {
    const i = AH(we.cssPrefix, r);
    i ? n = i : r && t.push(r);
  }), {
    iconName: n,
    rest: t
  };
}
function FC(e) {
  return e.sort().filter((t, n, r) => r.indexOf(t) === n);
}
function Rp(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    skipLookups: n = !1
  } = t;
  let r = null;
  const i = cv.concat(G$), a = FC(e.filter((p) => i.includes(p))), s = FC(e.filter((p) => !cv.includes(p))), u = a.filter((p) => (r = p, !SN.includes(p))), [f = null] = u, d = OH(a), h = me(me({}, NH(s)), {}, {
    prefix: Tp(f, {
      family: d
    })
  });
  return me(me(me({}, h), zH({
    values: e,
    family: d,
    styles: mc,
    config: we,
    canonical: h,
    givenPrefix: r
  })), MH(n, r, h));
}
function MH(e, t, n) {
  let {
    prefix: r,
    iconName: i
  } = n;
  if (e || !r || !i)
    return {
      prefix: r,
      iconName: i
    };
  const a = t === "fa" ? HN(i) : {}, s = Sa(r, i);
  return i = a.iconName || s || i, r = a.prefix || r, r === "far" && !mc.far && mc.fas && !we.autoFetchSvg && (r = "fas"), {
    prefix: r,
    iconName: i
  };
}
const DH = _N.filter((e) => e !== pn || e !== kp), PH = Object.keys(uv).filter((e) => e !== pn).map((e) => Object.keys(uv[e])).flat();
function zH(e) {
  const {
    values: t,
    family: n,
    canonical: r,
    givenPrefix: i = "",
    styles: a = {},
    config: s = {}
  } = e, u = n === kp, f = t.includes("fa-duotone") || t.includes("fad"), d = s.familyDefault === "duotone", h = r.prefix === "fad" || r.prefix === "fa-duotone";
  if (!u && (f || d || h) && (r.prefix = "fad"), (t.includes("fa-brands") || t.includes("fab")) && (r.prefix = "fab"), !r.prefix && DH.includes(n) && (Object.keys(a).find((g) => PH.includes(g)) || s.autoFetchSvg)) {
    const g = F$.get(n).defaultShortPrefixId;
    r.prefix = g, r.iconName = Sa(r.prefix, r.iconName) || r.iconName;
  }
  return (r.prefix === "fa" || i === "fa") && (r.prefix = $o() || "fas"), r;
}
let jH = class {
  constructor() {
    this.definitions = {};
  }
  add() {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
      n[r] = arguments[r];
    const i = n.reduce(this._pullDefinitions, {});
    Object.keys(i).forEach((a) => {
      this.definitions[a] = me(me({}, this.definitions[a] || {}), i[a]), yv(a, i[a]);
      const s = Fb[pn][a];
      s && yv(s, i[a]), $N();
    });
  }
  reset() {
    this.definitions = {};
  }
  _pullDefinitions(t, n) {
    const r = n.prefix && n.iconName && n.icon ? {
      0: n
    } : n;
    return Object.keys(r).map((i) => {
      const {
        prefix: a,
        iconName: s,
        icon: u
      } = r[i], f = u[2];
      t[a] || (t[a] = {}), f.length > 0 && f.forEach((d) => {
        typeof d == "string" && (t[a][d] = u);
      }), t[a][s] = u;
    }), t;
  }
}, BC = [], Vs = {};
const Xs = {}, IH = Object.keys(Xs);
function LH(e, t) {
  let {
    mixoutsTo: n
  } = t;
  return BC = e, Vs = {}, Object.keys(Xs).forEach((r) => {
    IH.indexOf(r) === -1 && delete Xs[r];
  }), BC.forEach((r) => {
    const i = r.mixout ? r.mixout() : {};
    if (Object.keys(i).forEach((a) => {
      typeof i[a] == "function" && (n[a] = i[a]), typeof i[a] == "object" && Object.keys(i[a]).forEach((s) => {
        n[a] || (n[a] = {}), n[a][s] = i[a][s];
      });
    }), r.hooks) {
      const a = r.hooks();
      Object.keys(a).forEach((s) => {
        Vs[s] || (Vs[s] = []), Vs[s].push(a[s]);
      });
    }
    r.provides && r.provides(Xs);
  }), n;
}
function vv(e, t) {
  for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++)
    r[i - 2] = arguments[i];
  return (Vs[e] || []).forEach((s) => {
    t = s.apply(null, [t, ...r]);
  }), t;
}
function Pa(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  (Vs[e] || []).forEach((a) => {
    a.apply(null, n);
  });
}
function Ho() {
  const e = arguments[0], t = Array.prototype.slice.call(arguments, 1);
  return Xs[e] ? Xs[e].apply(null, t) : void 0;
}
function bv(e) {
  e.prefix === "fa" && (e.prefix = "fas");
  let {
    iconName: t
  } = e;
  const n = e.prefix || $o();
  if (t)
    return t = Sa(n, t) || t, IC(UN.definitions, n, t) || IC(ti.styles, n, t);
}
const UN = new jH(), FH = () => {
  we.autoReplaceSvg = !1, we.observeMutations = !1, Pa("noAuto");
}, BH = {
  i2svg: function() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Wi ? (Pa("beforeI2svg", e), Ho("pseudoElements2svg", e), Ho("i2svg", e)) : Promise.reject(new Error("Operation requires a DOM of some kind."));
  },
  watch: function() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      autoReplaceSvgRoot: t
    } = e;
    we.autoReplaceSvg === !1 && (we.autoReplaceSvg = !0), we.observeMutations = !0, wH(() => {
      HH({
        autoReplaceSvgRoot: t
      }), Pa("watch", e);
    });
  }
}, $H = {
  icon: (e) => {
    if (e === null)
      return null;
    if (typeof e == "object" && e.prefix && e.iconName)
      return {
        prefix: e.prefix,
        iconName: Sa(e.prefix, e.iconName) || e.iconName
      };
    if (Array.isArray(e) && e.length === 2) {
      const t = e[1].indexOf("fa-") === 0 ? e[1].slice(3) : e[1], n = Tp(e[0]);
      return {
        prefix: n,
        iconName: Sa(n, t) || t
      };
    }
    if (typeof e == "string" && (e.indexOf("".concat(we.cssPrefix, "-")) > -1 || e.match(aH))) {
      const t = Rp(e.split(" "), {
        skipLookups: !0
      });
      return {
        prefix: t.prefix || $o(),
        iconName: Sa(t.prefix, t.iconName) || t.iconName
      };
    }
    if (typeof e == "string") {
      const t = $o();
      return {
        prefix: t,
        iconName: Sa(t, e) || e
      };
    }
  }
}, rr = {
  noAuto: FH,
  config: we,
  dom: BH,
  parse: $H,
  library: UN,
  findIconDefinition: bv,
  toHtml: Bc
}, HH = function() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    autoReplaceSvgRoot: t = xt
  } = e;
  (Object.keys(ti.styles).length > 0 || we.autoFetchSvg) && Wi && we.autoReplaceSvg && rr.dom.i2svg({
    node: t
  });
};
function Op(e, t) {
  return Object.defineProperty(e, "abstract", {
    get: t
  }), Object.defineProperty(e, "html", {
    get: function() {
      return e.abstract.map((n) => Bc(n));
    }
  }), Object.defineProperty(e, "node", {
    get: function() {
      if (!Wi) return;
      const n = xt.createElement("div");
      return n.innerHTML = e.html, n.children;
    }
  }), e;
}
function VH(e) {
  let {
    children: t,
    main: n,
    mask: r,
    attributes: i,
    styles: a,
    transform: s
  } = e;
  if ($b(s) && n.found && !r.found) {
    const {
      width: u,
      height: f
    } = n, d = {
      x: u / f / 2,
      y: 0.5
    };
    i.style = Ap(me(me({}, a), {}, {
      "transform-origin": "".concat(d.x + s.x / 16, "em ").concat(d.y + s.y / 16, "em")
    }));
  }
  return [{
    tag: "svg",
    attributes: i,
    children: t
  }];
}
function UH(e) {
  let {
    prefix: t,
    iconName: n,
    children: r,
    attributes: i,
    symbol: a
  } = e;
  const s = a === !0 ? "".concat(t, "-").concat(we.cssPrefix, "-").concat(n) : a;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: me(me({}, i), {}, {
        id: s
      }),
      children: r
    }]
  }];
}
function Ub(e) {
  const {
    icons: {
      main: t,
      mask: n
    },
    prefix: r,
    iconName: i,
    transform: a,
    symbol: s,
    title: u,
    maskId: f,
    titleId: d,
    extra: h,
    watchable: p = !1
  } = e, {
    width: g,
    height: y
  } = n.found ? n : t, b = U$.includes(r), x = [we.replacementClass, i ? "".concat(we.cssPrefix, "-").concat(i) : ""].filter((N) => h.classes.indexOf(N) === -1).filter((N) => N !== "" || !!N).concat(h.classes).join(" ");
  let E = {
    children: [],
    attributes: me(me({}, h.attributes), {}, {
      "data-prefix": r,
      "data-icon": i,
      class: x,
      role: h.attributes.role || "img",
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 ".concat(g, " ").concat(y)
    })
  };
  const S = b && !~h.classes.indexOf("fa-fw") ? {
    width: "".concat(g / y * 16 * 0.0625, "em")
  } : {};
  p && (E.attributes[Da] = ""), u && (E.children.push({
    tag: "title",
    attributes: {
      id: E.attributes["aria-labelledby"] || "title-".concat(d || pc())
    },
    children: [u]
  }), delete E.attributes.title);
  const A = me(me({}, E), {}, {
    prefix: r,
    iconName: i,
    main: t,
    mask: n,
    maskId: f,
    transform: a,
    symbol: s,
    styles: me(me({}, S), h.styles)
  }), {
    children: k,
    attributes: R
  } = n.found && t.found ? Ho("generateAbstractMask", A) || {
    children: [],
    attributes: {}
  } : Ho("generateAbstractIcon", A) || {
    children: [],
    attributes: {}
  };
  return A.children = k, A.attributes = R, s ? UH(A) : VH(A);
}
function $C(e) {
  const {
    content: t,
    width: n,
    height: r,
    transform: i,
    title: a,
    extra: s,
    watchable: u = !1
  } = e, f = me(me(me({}, s.attributes), a ? {
    title: a
  } : {}), {}, {
    class: s.classes.join(" ")
  });
  u && (f[Da] = "");
  const d = me({}, s.styles);
  $b(i) && (d.transform = vH({
    transform: i,
    startCentered: !0,
    width: n,
    height: r
  }), d["-webkit-transform"] = d.transform);
  const h = Ap(d);
  h.length > 0 && (f.style = h);
  const p = [];
  return p.push({
    tag: "span",
    attributes: f,
    children: [t]
  }), a && p.push({
    tag: "span",
    attributes: {
      class: "sr-only"
    },
    children: [a]
  }), p;
}
function qH(e) {
  const {
    content: t,
    title: n,
    extra: r
  } = e, i = me(me(me({}, r.attributes), n ? {
    title: n
  } : {}), {}, {
    class: r.classes.join(" ")
  }), a = Ap(r.styles);
  a.length > 0 && (i.style = a);
  const s = [];
  return s.push({
    tag: "span",
    attributes: i,
    children: [t]
  }), n && s.push({
    tag: "span",
    attributes: {
      class: "sr-only"
    },
    children: [n]
  }), s;
}
const {
  styles: K0
} = ti;
function xv(e) {
  const t = e[0], n = e[1], [r] = e.slice(4);
  let i = null;
  return Array.isArray(r) ? i = {
    tag: "g",
    attributes: {
      class: "".concat(we.cssPrefix, "-").concat(G0.GROUP)
    },
    children: [{
      tag: "path",
      attributes: {
        class: "".concat(we.cssPrefix, "-").concat(G0.SECONDARY),
        fill: "currentColor",
        d: r[0]
      }
    }, {
      tag: "path",
      attributes: {
        class: "".concat(we.cssPrefix, "-").concat(G0.PRIMARY),
        fill: "currentColor",
        d: r[1]
      }
    }]
  } : i = {
    tag: "path",
    attributes: {
      fill: "currentColor",
      d: r
    }
  }, {
    found: !0,
    width: t,
    height: n,
    icon: i
  };
}
const YH = {
  found: !1,
  width: 512,
  height: 512
};
function GH(e, t) {
  !AN && !we.showMissingIcons && e && console.error('Icon with name "'.concat(e, '" and prefix "').concat(t, '" is missing.'));
}
function wv(e, t) {
  let n = t;
  return t === "fa" && we.styleDefault !== null && (t = $o()), new Promise((r, i) => {
    if (n === "fa") {
      const a = HN(e) || {};
      e = a.iconName || e, t = a.prefix || t;
    }
    if (e && t && K0[t] && K0[t][e]) {
      const a = K0[t][e];
      return r(xv(a));
    }
    GH(e, t), r(me(me({}, YH), {}, {
      icon: we.showMissingIcons && e ? Ho("missingIconAbstract") || {} : {}
    }));
  });
}
const HC = () => {
}, Sv = we.measurePerformance && Pd && Pd.mark && Pd.measure ? Pd : {
  mark: HC,
  measure: HC
}, Uu = 'FA "6.7.2"', XH = (e) => (Sv.mark("".concat(Uu, " ").concat(e, " begins")), () => qN(e)), qN = (e) => {
  Sv.mark("".concat(Uu, " ").concat(e, " ends")), Sv.measure("".concat(Uu, " ").concat(e), "".concat(Uu, " ").concat(e, " begins"), "".concat(Uu, " ").concat(e, " ends"));
};
var qb = {
  begin: XH,
  end: qN
};
const ah = () => {
};
function VC(e) {
  return typeof (e.getAttribute ? e.getAttribute(Da) : null) == "string";
}
function WH(e) {
  const t = e.getAttribute ? e.getAttribute(Ib) : null, n = e.getAttribute ? e.getAttribute(Lb) : null;
  return t && n;
}
function KH(e) {
  return e && e.classList && e.classList.contains && e.classList.contains(we.replacementClass);
}
function ZH() {
  return we.autoReplaceSvg === !0 ? sh.replace : sh[we.autoReplaceSvg] || sh.replace;
}
function QH(e) {
  return xt.createElementNS("http://www.w3.org/2000/svg", e);
}
function JH(e) {
  return xt.createElement(e);
}
function YN(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    ceFn: n = e.tag === "svg" ? QH : JH
  } = t;
  if (typeof e == "string")
    return xt.createTextNode(e);
  const r = n(e.tag);
  return Object.keys(e.attributes || []).forEach(function(a) {
    r.setAttribute(a, e.attributes[a]);
  }), (e.children || []).forEach(function(a) {
    r.appendChild(YN(a, {
      ceFn: n
    }));
  }), r;
}
function eV(e) {
  let t = " ".concat(e.outerHTML, " ");
  return t = "".concat(t, "Font Awesome fontawesome.com "), t;
}
const sh = {
  replace: function(e) {
    const t = e[0];
    if (t.parentNode)
      if (e[1].forEach((n) => {
        t.parentNode.insertBefore(YN(n), t);
      }), t.getAttribute(Da) === null && we.keepOriginalSource) {
        let n = xt.createComment(eV(t));
        t.parentNode.replaceChild(n, t);
      } else
        t.remove();
  },
  nest: function(e) {
    const t = e[0], n = e[1];
    if (~Bb(t).indexOf(we.replacementClass))
      return sh.replace(e);
    const r = new RegExp("".concat(we.cssPrefix, "-.*"));
    if (delete n[0].attributes.id, n[0].attributes.class) {
      const a = n[0].attributes.class.split(" ").reduce((s, u) => (u === we.replacementClass || u.match(r) ? s.toSvg.push(u) : s.toNode.push(u), s), {
        toNode: [],
        toSvg: []
      });
      n[0].attributes.class = a.toSvg.join(" "), a.toNode.length === 0 ? t.removeAttribute("class") : t.setAttribute("class", a.toNode.join(" "));
    }
    const i = n.map((a) => Bc(a)).join(`
`);
    t.setAttribute(Da, ""), t.innerHTML = i;
  }
};
function UC(e) {
  e();
}
function GN(e, t) {
  const n = typeof t == "function" ? t : ah;
  if (e.length === 0)
    n();
  else {
    let r = UC;
    we.mutateApproach === rH && (r = Bo.requestAnimationFrame || UC), r(() => {
      const i = ZH(), a = qb.begin("mutate");
      e.map(i), a(), n();
    });
  }
}
let Yb = !1;
function XN() {
  Yb = !0;
}
function _v() {
  Yb = !1;
}
let Mh = null;
function qC(e) {
  if (!NC || !we.observeMutations)
    return;
  const {
    treeCallback: t = ah,
    nodeCallback: n = ah,
    pseudoElementsCallback: r = ah,
    observeMutationsRoot: i = xt
  } = e;
  Mh = new NC((a) => {
    if (Yb) return;
    const s = $o();
    vl(a).forEach((u) => {
      if (u.type === "childList" && u.addedNodes.length > 0 && !VC(u.addedNodes[0]) && (we.searchPseudoElements && r(u.target), t(u.target)), u.type === "attributes" && u.target.parentNode && we.searchPseudoElements && r(u.target.parentNode), u.type === "attributes" && VC(u.target) && ~uH.indexOf(u.attributeName))
        if (u.attributeName === "class" && WH(u.target)) {
          const {
            prefix: f,
            iconName: d
          } = Rp(Bb(u.target));
          u.target.setAttribute(Ib, f || s), d && u.target.setAttribute(Lb, d);
        } else KH(u.target) && n(u.target);
    });
  }), Wi && Mh.observe(i, {
    childList: !0,
    attributes: !0,
    characterData: !0,
    subtree: !0
  });
}
function tV() {
  Mh && Mh.disconnect();
}
function nV(e) {
  const t = e.getAttribute("style");
  let n = [];
  return t && (n = t.split(";").reduce((r, i) => {
    const a = i.split(":"), s = a[0], u = a.slice(1);
    return s && u.length > 0 && (r[s] = u.join(":").trim()), r;
  }, {})), n;
}
function rV(e) {
  const t = e.getAttribute("data-prefix"), n = e.getAttribute("data-icon"), r = e.innerText !== void 0 ? e.innerText.trim() : "";
  let i = Rp(Bb(e));
  return i.prefix || (i.prefix = $o()), t && n && (i.prefix = t, i.iconName = n), i.iconName && i.prefix || (i.prefix && r.length > 0 && (i.iconName = TH(i.prefix, e.innerText) || Vb(i.prefix, gv(e.innerText))), !i.iconName && we.autoFetchSvg && e.firstChild && e.firstChild.nodeType === Node.TEXT_NODE && (i.iconName = e.firstChild.data)), i;
}
function iV(e) {
  const t = vl(e.attributes).reduce((i, a) => (i.name !== "class" && i.name !== "style" && (i[a.name] = a.value), i), {}), n = e.getAttribute("title"), r = e.getAttribute("data-fa-title-id");
  return we.autoA11y && (n ? t["aria-labelledby"] = "".concat(we.replacementClass, "-title-").concat(r || pc()) : (t["aria-hidden"] = "true", t.focusable = "false")), t;
}
function oV() {
  return {
    iconName: null,
    title: null,
    titleId: null,
    prefix: null,
    transform: ei,
    symbol: !1,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function YC(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    styleParser: !0
  };
  const {
    iconName: n,
    prefix: r,
    rest: i
  } = rV(e), a = iV(e), s = vv("parseNodeAttributes", {}, e);
  let u = t.styleParser ? nV(e) : [];
  return me({
    iconName: n,
    title: e.getAttribute("title"),
    titleId: e.getAttribute("data-fa-title-id"),
    prefix: r,
    transform: ei,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: !1,
    extra: {
      classes: i,
      styles: u,
      attributes: a
    }
  }, s);
}
const {
  styles: aV
} = ti;
function WN(e) {
  const t = we.autoReplaceSvg === "nest" ? YC(e, {
    styleParser: !1
  }) : YC(e);
  return ~t.extra.classes.indexOf(RN) ? Ho("generateLayersText", e, t) : Ho("generateSvgReplacementMutation", e, t);
}
function sV() {
  return [...$$, ...cv];
}
function GC(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!Wi) return Promise.resolve();
  const n = xt.documentElement.classList, r = (h) => n.add("".concat(PC, "-").concat(h)), i = (h) => n.remove("".concat(PC, "-").concat(h)), a = we.autoFetchSvg ? sV() : SN.concat(Object.keys(aV));
  a.includes("fa") || a.push("fa");
  const s = [".".concat(RN, ":not([").concat(Da, "])")].concat(a.map((h) => ".".concat(h, ":not([").concat(Da, "])"))).join(", ");
  if (s.length === 0)
    return Promise.resolve();
  let u = [];
  try {
    u = vl(e.querySelectorAll(s));
  } catch {
  }
  if (u.length > 0)
    r("pending"), i("complete");
  else
    return Promise.resolve();
  const f = qb.begin("onTree"), d = u.reduce((h, p) => {
    try {
      const g = WN(p);
      g && h.push(g);
    } catch (g) {
      AN || g.name === "MissingIcon" && console.error(g);
    }
    return h;
  }, []);
  return new Promise((h, p) => {
    Promise.all(d).then((g) => {
      GN(g, () => {
        r("active"), r("complete"), i("pending"), typeof t == "function" && t(), f(), h();
      });
    }).catch((g) => {
      f(), p(g);
    });
  });
}
function lV(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  WN(e).then((n) => {
    n && GN([n], t);
  });
}
function uV(e) {
  return function(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const r = (t || {}).icon ? t : bv(t || {});
    let {
      mask: i
    } = n;
    return i && (i = (i || {}).icon ? i : bv(i || {})), e(r, me(me({}, n), {}, {
      mask: i
    }));
  };
}
const cV = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    transform: n = ei,
    symbol: r = !1,
    mask: i = null,
    maskId: a = null,
    title: s = null,
    titleId: u = null,
    classes: f = [],
    attributes: d = {},
    styles: h = {}
  } = t;
  if (!e) return;
  const {
    prefix: p,
    iconName: g,
    icon: y
  } = e;
  return Op(me({
    type: "icon"
  }, e), () => (Pa("beforeDOMElementCreation", {
    iconDefinition: e,
    params: t
  }), we.autoA11y && (s ? d["aria-labelledby"] = "".concat(we.replacementClass, "-title-").concat(u || pc()) : (d["aria-hidden"] = "true", d.focusable = "false")), Ub({
    icons: {
      main: xv(y),
      mask: i ? xv(i.icon) : {
        found: !1,
        width: null,
        height: null,
        icon: {}
      }
    },
    prefix: p,
    iconName: g,
    transform: me(me({}, ei), n),
    symbol: r,
    title: s,
    maskId: a,
    titleId: u,
    extra: {
      attributes: d,
      styles: h,
      classes: f
    }
  })));
};
var fV = {
  mixout() {
    return {
      icon: uV(cV)
    };
  },
  hooks() {
    return {
      mutationObserverCallbacks(e) {
        return e.treeCallback = GC, e.nodeCallback = lV, e;
      }
    };
  },
  provides(e) {
    e.i2svg = function(t) {
      const {
        node: n = xt,
        callback: r = () => {
        }
      } = t;
      return GC(n, r);
    }, e.generateSvgReplacementMutation = function(t, n) {
      const {
        iconName: r,
        title: i,
        titleId: a,
        prefix: s,
        transform: u,
        symbol: f,
        mask: d,
        maskId: h,
        extra: p
      } = n;
      return new Promise((g, y) => {
        Promise.all([wv(r, s), d.iconName ? wv(d.iconName, d.prefix) : Promise.resolve({
          found: !1,
          width: 512,
          height: 512,
          icon: {}
        })]).then((b) => {
          let [x, E] = b;
          g([t, Ub({
            icons: {
              main: x,
              mask: E
            },
            prefix: s,
            iconName: r,
            transform: u,
            symbol: f,
            maskId: h,
            title: i,
            titleId: a,
            extra: p,
            watchable: !0
          })]);
        }).catch(y);
      });
    }, e.generateAbstractIcon = function(t) {
      let {
        children: n,
        attributes: r,
        main: i,
        transform: a,
        styles: s
      } = t;
      const u = Ap(s);
      u.length > 0 && (r.style = u);
      let f;
      return $b(a) && (f = Ho("generateAbstractTransformGrouping", {
        main: i,
        transform: a,
        containerWidth: i.width,
        iconWidth: i.width
      })), n.push(f || i.icon), {
        children: n,
        attributes: r
      };
    };
  }
}, dV = {
  mixout() {
    return {
      layer(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          classes: n = []
        } = t;
        return Op({
          type: "layer"
        }, () => {
          Pa("beforeDOMElementCreation", {
            assembler: e,
            params: t
          });
          let r = [];
          return e((i) => {
            Array.isArray(i) ? i.map((a) => {
              r = r.concat(a.abstract);
            }) : r = r.concat(i.abstract);
          }), [{
            tag: "span",
            attributes: {
              class: ["".concat(we.cssPrefix, "-layers"), ...n].join(" ")
            },
            children: r
          }];
        });
      }
    };
  }
}, hV = {
  mixout() {
    return {
      counter(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          title: n = null,
          classes: r = [],
          attributes: i = {},
          styles: a = {}
        } = t;
        return Op({
          type: "counter",
          content: e
        }, () => (Pa("beforeDOMElementCreation", {
          content: e,
          params: t
        }), qH({
          content: e.toString(),
          title: n,
          extra: {
            attributes: i,
            styles: a,
            classes: ["".concat(we.cssPrefix, "-layers-counter"), ...r]
          }
        })));
      }
    };
  }
}, pV = {
  mixout() {
    return {
      text(e) {
        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          transform: n = ei,
          title: r = null,
          classes: i = [],
          attributes: a = {},
          styles: s = {}
        } = t;
        return Op({
          type: "text",
          content: e
        }, () => (Pa("beforeDOMElementCreation", {
          content: e,
          params: t
        }), $C({
          content: e,
          transform: me(me({}, ei), n),
          title: r,
          extra: {
            attributes: a,
            styles: s,
            classes: ["".concat(we.cssPrefix, "-layers-text"), ...i]
          }
        })));
      }
    };
  },
  provides(e) {
    e.generateLayersText = function(t, n) {
      const {
        title: r,
        transform: i,
        extra: a
      } = n;
      let s = null, u = null;
      if (xN) {
        const f = parseInt(getComputedStyle(t).fontSize, 10), d = t.getBoundingClientRect();
        s = d.width / f, u = d.height / f;
      }
      return we.autoA11y && !r && (a.attributes["aria-hidden"] = "true"), Promise.resolve([t, $C({
        content: t.innerHTML,
        width: s,
        height: u,
        transform: i,
        title: r,
        extra: a,
        watchable: !0
      })]);
    };
  }
};
const mV = new RegExp('"', "ug"), XC = [1105920, 1112319], WC = me(me(me(me({}, {
  FontAwesome: {
    normal: "fas",
    400: "fas"
  }
}), L$), tH), X$), Ev = Object.keys(WC).reduce((e, t) => (e[t.toLowerCase()] = WC[t], e), {}), gV = Object.keys(Ev).reduce((e, t) => {
  const n = Ev[t];
  return e[t] = n[900] || [...Object.entries(n)][0][1], e;
}, {});
function yV(e) {
  const t = e.replace(mV, ""), n = _H(t, 0), r = n >= XC[0] && n <= XC[1], i = t.length === 2 ? t[0] === t[1] : !1;
  return {
    value: gv(i ? t[0] : t),
    isSecondary: r || i
  };
}
function vV(e, t) {
  const n = e.replace(/^['"]|['"]$/g, "").toLowerCase(), r = parseInt(t), i = isNaN(r) ? "normal" : r;
  return (Ev[n] || {})[i] || gV[n];
}
function KC(e, t) {
  const n = "".concat(nH).concat(t.replace(":", "-"));
  return new Promise((r, i) => {
    if (e.getAttribute(n) !== null)
      return r();
    const s = vl(e.children).filter((g) => g.getAttribute(dv) === t)[0], u = Bo.getComputedStyle(e, t), f = u.getPropertyValue("font-family"), d = f.match(sH), h = u.getPropertyValue("font-weight"), p = u.getPropertyValue("content");
    if (s && !d)
      return e.removeChild(s), r();
    if (d && p !== "none" && p !== "") {
      const g = u.getPropertyValue("content");
      let y = vV(f, h);
      const {
        value: b,
        isSecondary: x
      } = yV(g), E = d[0].startsWith("FontAwesome");
      let S = Vb(y, b), A = S;
      if (E) {
        const k = RH(b);
        k.iconName && k.prefix && (S = k.iconName, y = k.prefix);
      }
      if (S && !x && (!s || s.getAttribute(Ib) !== y || s.getAttribute(Lb) !== A)) {
        e.setAttribute(n, A), s && e.removeChild(s);
        const k = oV(), {
          extra: R
        } = k;
        R.attributes[dv] = t, wv(S, y).then((N) => {
          const D = Ub(me(me({}, k), {}, {
            icons: {
              main: N,
              mask: VN()
            },
            prefix: y,
            iconName: A,
            extra: R,
            watchable: !0
          })), P = xt.createElementNS("http://www.w3.org/2000/svg", "svg");
          t === "::before" ? e.insertBefore(P, e.firstChild) : e.appendChild(P), P.outerHTML = D.map((F) => Bc(F)).join(`
`), e.removeAttribute(n), r();
        }).catch(i);
      } else
        r();
    } else
      r();
  });
}
function bV(e) {
  return Promise.all([KC(e, "::before"), KC(e, "::after")]);
}
function xV(e) {
  return e.parentNode !== document.head && !~iH.indexOf(e.tagName.toUpperCase()) && !e.getAttribute(dv) && (!e.parentNode || e.parentNode.tagName !== "svg");
}
function ZC(e) {
  if (Wi)
    return new Promise((t, n) => {
      const r = vl(e.querySelectorAll("*")).filter(xV).map(bV), i = qb.begin("searchPseudoElements");
      XN(), Promise.all(r).then(() => {
        i(), _v(), t();
      }).catch(() => {
        i(), _v(), n();
      });
    });
}
var wV = {
  hooks() {
    return {
      mutationObserverCallbacks(e) {
        return e.pseudoElementsCallback = ZC, e;
      }
    };
  },
  provides(e) {
    e.pseudoElements2svg = function(t) {
      const {
        node: n = xt
      } = t;
      we.searchPseudoElements && ZC(n);
    };
  }
};
let QC = !1;
var SV = {
  mixout() {
    return {
      dom: {
        unwatch() {
          XN(), QC = !0;
        }
      }
    };
  },
  hooks() {
    return {
      bootstrap() {
        qC(vv("mutationObserverCallbacks", {}));
      },
      noAuto() {
        tV();
      },
      watch(e) {
        const {
          observeMutationsRoot: t
        } = e;
        QC ? _v() : qC(vv("mutationObserverCallbacks", {
          observeMutationsRoot: t
        }));
      }
    };
  }
};
const JC = (e) => {
  let t = {
    size: 16,
    x: 0,
    y: 0,
    flipX: !1,
    flipY: !1,
    rotate: 0
  };
  return e.toLowerCase().split(" ").reduce((n, r) => {
    const i = r.toLowerCase().split("-"), a = i[0];
    let s = i.slice(1).join("-");
    if (a && s === "h")
      return n.flipX = !0, n;
    if (a && s === "v")
      return n.flipY = !0, n;
    if (s = parseFloat(s), isNaN(s))
      return n;
    switch (a) {
      case "grow":
        n.size = n.size + s;
        break;
      case "shrink":
        n.size = n.size - s;
        break;
      case "left":
        n.x = n.x - s;
        break;
      case "right":
        n.x = n.x + s;
        break;
      case "up":
        n.y = n.y - s;
        break;
      case "down":
        n.y = n.y + s;
        break;
      case "rotate":
        n.rotate = n.rotate + s;
        break;
    }
    return n;
  }, t);
};
var _V = {
  mixout() {
    return {
      parse: {
        transform: (e) => JC(e)
      }
    };
  },
  hooks() {
    return {
      parseNodeAttributes(e, t) {
        const n = t.getAttribute("data-fa-transform");
        return n && (e.transform = JC(n)), e;
      }
    };
  },
  provides(e) {
    e.generateAbstractTransformGrouping = function(t) {
      let {
        main: n,
        transform: r,
        containerWidth: i,
        iconWidth: a
      } = t;
      const s = {
        transform: "translate(".concat(i / 2, " 256)")
      }, u = "translate(".concat(r.x * 32, ", ").concat(r.y * 32, ") "), f = "scale(".concat(r.size / 16 * (r.flipX ? -1 : 1), ", ").concat(r.size / 16 * (r.flipY ? -1 : 1), ") "), d = "rotate(".concat(r.rotate, " 0 0)"), h = {
        transform: "".concat(u, " ").concat(f, " ").concat(d)
      }, p = {
        transform: "translate(".concat(a / 2 * -1, " -256)")
      }, g = {
        outer: s,
        inner: h,
        path: p
      };
      return {
        tag: "g",
        attributes: me({}, g.outer),
        children: [{
          tag: "g",
          attributes: me({}, g.inner),
          children: [{
            tag: n.icon.tag,
            children: n.icon.children,
            attributes: me(me({}, n.icon.attributes), g.path)
          }]
        }]
      };
    };
  }
};
const Z0 = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function ek(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return e.attributes && (e.attributes.fill || t) && (e.attributes.fill = "black"), e;
}
function EV(e) {
  return e.tag === "g" ? e.children : [e];
}
var CV = {
  hooks() {
    return {
      parseNodeAttributes(e, t) {
        const n = t.getAttribute("data-fa-mask"), r = n ? Rp(n.split(" ").map((i) => i.trim())) : VN();
        return r.prefix || (r.prefix = $o()), e.mask = r, e.maskId = t.getAttribute("data-fa-mask-id"), e;
      }
    };
  },
  provides(e) {
    e.generateAbstractMask = function(t) {
      let {
        children: n,
        attributes: r,
        main: i,
        mask: a,
        maskId: s,
        transform: u
      } = t;
      const {
        width: f,
        icon: d
      } = i, {
        width: h,
        icon: p
      } = a, g = yH({
        transform: u,
        containerWidth: h,
        iconWidth: f
      }), y = {
        tag: "rect",
        attributes: me(me({}, Z0), {}, {
          fill: "white"
        })
      }, b = d.children ? {
        children: d.children.map(ek)
      } : {}, x = {
        tag: "g",
        attributes: me({}, g.inner),
        children: [ek(me({
          tag: d.tag,
          attributes: me(me({}, d.attributes), g.path)
        }, b))]
      }, E = {
        tag: "g",
        attributes: me({}, g.outer),
        children: [x]
      }, S = "mask-".concat(s || pc()), A = "clip-".concat(s || pc()), k = {
        tag: "mask",
        attributes: me(me({}, Z0), {}, {
          id: S,
          maskUnits: "userSpaceOnUse",
          maskContentUnits: "userSpaceOnUse"
        }),
        children: [y, E]
      }, R = {
        tag: "defs",
        children: [{
          tag: "clipPath",
          attributes: {
            id: A
          },
          children: EV(p)
        }, k]
      };
      return n.push(R, {
        tag: "rect",
        attributes: me({
          fill: "currentColor",
          "clip-path": "url(#".concat(A, ")"),
          mask: "url(#".concat(S, ")")
        }, Z0)
      }), {
        children: n,
        attributes: r
      };
    };
  }
}, kV = {
  provides(e) {
    let t = !1;
    Bo.matchMedia && (t = Bo.matchMedia("(prefers-reduced-motion: reduce)").matches), e.missingIconAbstract = function() {
      const n = [], r = {
        fill: "currentColor"
      }, i = {
        attributeType: "XML",
        repeatCount: "indefinite",
        dur: "2s"
      };
      n.push({
        tag: "path",
        attributes: me(me({}, r), {}, {
          d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
        })
      });
      const a = me(me({}, i), {}, {
        attributeName: "opacity"
      }), s = {
        tag: "circle",
        attributes: me(me({}, r), {}, {
          cx: "256",
          cy: "364",
          r: "28"
        }),
        children: []
      };
      return t || s.children.push({
        tag: "animate",
        attributes: me(me({}, i), {}, {
          attributeName: "r",
          values: "28;14;28;28;14;28;"
        })
      }, {
        tag: "animate",
        attributes: me(me({}, a), {}, {
          values: "1;0;1;1;0;1;"
        })
      }), n.push(s), n.push({
        tag: "path",
        attributes: me(me({}, r), {}, {
          opacity: "1",
          d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
        }),
        children: t ? [] : [{
          tag: "animate",
          attributes: me(me({}, a), {}, {
            values: "1;0;0;0;0;1;"
          })
        }]
      }), t || n.push({
        tag: "path",
        attributes: me(me({}, r), {}, {
          opacity: "0",
          d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
        }),
        children: [{
          tag: "animate",
          attributes: me(me({}, a), {}, {
            values: "0;0;1;1;0;0;"
          })
        }]
      }), {
        tag: "g",
        attributes: {
          class: "missing"
        },
        children: n
      };
    };
  }
}, AV = {
  hooks() {
    return {
      parseNodeAttributes(e, t) {
        const n = t.getAttribute("data-fa-symbol"), r = n === null ? !1 : n === "" ? !0 : n;
        return e.symbol = r, e;
      }
    };
  }
}, TV = [xH, fV, dV, hV, pV, wV, SV, _V, CV, kV, AV];
LH(TV, {
  mixoutsTo: rr
});
rr.noAuto;
const RV = rr.config;
rr.library;
rr.dom;
const Cv = rr.parse;
rr.findIconDefinition;
rr.toHtml;
const OV = rr.icon;
rr.layer;
rr.text;
rr.counter;
var Q0 = { exports: {} }, J0, tk;
function NV() {
  if (tk) return J0;
  tk = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return J0 = e, J0;
}
var ey, nk;
function MV() {
  if (nk) return ey;
  nk = 1;
  var e = /* @__PURE__ */ NV();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, ey = function() {
    function r(s, u, f, d, h, p) {
      if (p !== e) {
        var g = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw g.name = "Invariant Violation", g;
      }
    }
    r.isRequired = r;
    function i() {
      return r;
    }
    var a = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: i,
      element: r,
      elementType: r,
      instanceOf: i,
      node: r,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return a.PropTypes = a, a;
  }, ey;
}
var rk;
function DV() {
  return rk || (rk = 1, Q0.exports = /* @__PURE__ */ MV()()), Q0.exports;
}
var Bt = /* @__PURE__ */ DV();
const Ye = /* @__PURE__ */ pl(Bt);
function ik(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Kr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ik(Object(n), !0).forEach(function(r) {
      Us(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ik(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Dh(e) {
  "@babel/helpers - typeof";
  return Dh = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Dh(e);
}
function Us(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function PV(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), i, a;
  for (a = 0; a < r.length; a++)
    i = r[a], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function zV(e, t) {
  if (e == null) return {};
  var n = PV(e, t), r, i;
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    for (i = 0; i < a.length; i++)
      r = a[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function kv(e) {
  return jV(e) || IV(e) || LV(e) || FV();
}
function jV(e) {
  if (Array.isArray(e)) return Av(e);
}
function IV(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function LV(e, t) {
  if (e) {
    if (typeof e == "string") return Av(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Av(e, t);
  }
}
function Av(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function FV() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function BV(e) {
  var t, n = e.beat, r = e.fade, i = e.beatFade, a = e.bounce, s = e.shake, u = e.flash, f = e.spin, d = e.spinPulse, h = e.spinReverse, p = e.pulse, g = e.fixedWidth, y = e.inverse, b = e.border, x = e.listItem, E = e.flip, S = e.size, A = e.rotation, k = e.pull, R = (t = {
    "fa-beat": n,
    "fa-fade": r,
    "fa-beat-fade": i,
    "fa-bounce": a,
    "fa-shake": s,
    "fa-flash": u,
    "fa-spin": f,
    "fa-spin-reverse": h,
    "fa-spin-pulse": d,
    "fa-pulse": p,
    "fa-fw": g,
    "fa-inverse": y,
    "fa-border": b,
    "fa-li": x,
    "fa-flip": E === !0,
    "fa-flip-horizontal": E === "horizontal" || E === "both",
    "fa-flip-vertical": E === "vertical" || E === "both"
  }, Us(t, "fa-".concat(S), typeof S < "u" && S !== null), Us(t, "fa-rotate-".concat(A), typeof A < "u" && A !== null && A !== 0), Us(t, "fa-pull-".concat(k), typeof k < "u" && k !== null), Us(t, "fa-swap-opacity", e.swapOpacity), t);
  return Object.keys(R).map(function(N) {
    return R[N] ? N : null;
  }).filter(function(N) {
    return N;
  });
}
function $V(e) {
  return e = e - 0, e === e;
}
function KN(e) {
  return $V(e) ? e : (e = e.replace(/[\-_\s]+(.)?/g, function(t, n) {
    return n ? n.toUpperCase() : "";
  }), e.substr(0, 1).toLowerCase() + e.substr(1));
}
var HV = ["style"];
function VV(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
function UV(e) {
  return e.split(";").map(function(t) {
    return t.trim();
  }).filter(function(t) {
    return t;
  }).reduce(function(t, n) {
    var r = n.indexOf(":"), i = KN(n.slice(0, r)), a = n.slice(r + 1).trim();
    return i.startsWith("webkit") ? t[VV(i)] = a : t[i] = a, t;
  }, {});
}
function ZN(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof t == "string")
    return t;
  var r = (t.children || []).map(function(f) {
    return ZN(e, f);
  }), i = Object.keys(t.attributes || {}).reduce(function(f, d) {
    var h = t.attributes[d];
    switch (d) {
      case "class":
        f.attrs.className = h, delete t.attributes.class;
        break;
      case "style":
        f.attrs.style = UV(h);
        break;
      default:
        d.indexOf("aria-") === 0 || d.indexOf("data-") === 0 ? f.attrs[d.toLowerCase()] = h : f.attrs[KN(d)] = h;
    }
    return f;
  }, {
    attrs: {}
  }), a = n.style, s = a === void 0 ? {} : a, u = zV(n, HV);
  return i.attrs.style = Kr(Kr({}, i.attrs.style), s), e.apply(void 0, [t.tag, Kr(Kr({}, i.attrs), u)].concat(kv(r)));
}
var QN = !1;
try {
  QN = !0;
} catch {
}
function qV() {
  if (!QN && console && typeof console.error == "function") {
    var e;
    (e = console).error.apply(e, arguments);
  }
}
function ok(e) {
  if (e && Dh(e) === "object" && e.prefix && e.iconName && e.icon)
    return e;
  if (Cv.icon)
    return Cv.icon(e);
  if (e === null)
    return null;
  if (e && Dh(e) === "object" && e.prefix && e.iconName)
    return e;
  if (Array.isArray(e) && e.length === 2)
    return {
      prefix: e[0],
      iconName: e[1]
    };
  if (typeof e == "string")
    return {
      prefix: "fas",
      iconName: e
    };
}
function ty(e, t) {
  return Array.isArray(t) && t.length > 0 || !Array.isArray(t) && t ? Us({}, e, t) : {};
}
var ak = {
  border: !1,
  className: "",
  mask: null,
  maskId: null,
  fixedWidth: !1,
  inverse: !1,
  flip: !1,
  icon: null,
  listItem: !1,
  pull: null,
  pulse: !1,
  rotation: null,
  size: null,
  spin: !1,
  spinPulse: !1,
  spinReverse: !1,
  beat: !1,
  fade: !1,
  beatFade: !1,
  bounce: !1,
  shake: !1,
  symbol: !1,
  title: "",
  titleId: null,
  transform: null,
  swapOpacity: !1
}, Gb = /* @__PURE__ */ Qt.forwardRef(function(e, t) {
  var n = Kr(Kr({}, ak), e), r = n.icon, i = n.mask, a = n.symbol, s = n.className, u = n.title, f = n.titleId, d = n.maskId, h = ok(r), p = ty("classes", [].concat(kv(BV(n)), kv((s || "").split(" ")))), g = ty("transform", typeof n.transform == "string" ? Cv.transform(n.transform) : n.transform), y = ty("mask", ok(i)), b = OV(h, Kr(Kr(Kr(Kr({}, p), g), y), {}, {
    symbol: a,
    title: u,
    titleId: f,
    maskId: d
  }));
  if (!b)
    return qV("Could not find icon", h), null;
  var x = b.abstract, E = {
    ref: t
  };
  return Object.keys(n).forEach(function(S) {
    ak.hasOwnProperty(S) || (E[S] = n[S]);
  }), YV(x[0], E);
});
Gb.displayName = "FontAwesomeIcon";
Gb.propTypes = {
  beat: Ye.bool,
  border: Ye.bool,
  beatFade: Ye.bool,
  bounce: Ye.bool,
  className: Ye.string,
  fade: Ye.bool,
  flash: Ye.bool,
  mask: Ye.oneOfType([Ye.object, Ye.array, Ye.string]),
  maskId: Ye.string,
  fixedWidth: Ye.bool,
  inverse: Ye.bool,
  flip: Ye.oneOf([!0, !1, "horizontal", "vertical", "both"]),
  icon: Ye.oneOfType([Ye.object, Ye.array, Ye.string]),
  listItem: Ye.bool,
  pull: Ye.oneOf(["right", "left"]),
  pulse: Ye.bool,
  rotation: Ye.oneOf([0, 90, 180, 270]),
  shake: Ye.bool,
  size: Ye.oneOf(["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"]),
  spin: Ye.bool,
  spinPulse: Ye.bool,
  spinReverse: Ye.bool,
  symbol: Ye.oneOfType([Ye.bool, Ye.string]),
  title: Ye.string,
  titleId: Ye.string,
  transform: Ye.oneOfType([Ye.string, Ye.object]),
  swapOpacity: Ye.bool
};
var YV = ZN.bind(null, Qt.createElement);
/*!
 * Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2024 Fonticons, Inc.
 */
const GV = {
  prefix: "fas",
  iconName: "down-left-and-up-right-to-center",
  icon: [512, 512, ["compress-alt"], "f422", "M439 7c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2s-12.5 14.8-22.2 14.8l-144 0c-13.3 0-24-10.7-24-24l0-144c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2l39 39L439 7zM72 272l144 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39L73 505c-9.4 9.4-24.6 9.4-33.9 0L7 473c-9.4-9.4-9.4-24.6 0-33.9l87-87L55 313c-6.9-6.9-8.9-17.2-5.2-26.2s12.5-14.8 22.2-14.8z"]
}, XV = {
  prefix: "fas",
  iconName: "bars",
  icon: [448, 512, ["navicon"], "f0c9", "M0 96C0 78.3 14.3 64 32 64l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 128C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 288c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32L32 448c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"]
}, WV = {
  prefix: "fas",
  iconName: "compress",
  icon: [448, 512, [], "f066", "M160 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 64-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32l0-96zM32 320c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0 0 64c0 17.7 14.3 32 32 32s32-14.3 32-32l0-96c0-17.7-14.3-32-32-32l-96 0zM352 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-64zM320 320c-17.7 0-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32s32-14.3 32-32l0-64 64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-96 0z"]
}, KV = {
  prefix: "fas",
  iconName: "lock",
  icon: [448, 512, [128274], "f023", "M144 144l0 48 160 0 0-48c0-44.2-35.8-80-80-80s-80 35.8-80 80zM80 192l0-48C80 64.5 144.5 0 224 0s144 64.5 144 144l0 48 16 0c35.3 0 64 28.7 64 64l0 192c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64L0 256c0-35.3 28.7-64 64-64l16 0z"]
}, ZV = {
  prefix: "fas",
  iconName: "chevron-up",
  icon: [512, 512, [], "f077", "M233.4 105.4c12.5-12.5 32.8-12.5 45.3 0l192 192c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L256 173.3 86.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l192-192z"]
}, QV = {
  prefix: "fas",
  iconName: "circle-play",
  icon: [512, 512, [61469, "play-circle"], "f144", "M0 256a256 256 0 1 1 512 0A256 256 0 1 1 0 256zM188.3 147.1c-7.6 4.2-12.3 12.3-12.3 20.9l0 176c0 8.7 4.7 16.7 12.3 20.9s16.8 4.1 24.3-.5l144-88c7.1-4.4 11.5-12.1 11.5-20.5s-4.4-16.1-11.5-20.5l-144-88c-7.4-4.5-16.7-4.7-24.3-.5z"]
}, JV = {
  prefix: "fas",
  iconName: "lock-open",
  icon: [576, 512, [], "f3c1", "M352 144c0-44.2 35.8-80 80-80s80 35.8 80 80l0 48c0 17.7 14.3 32 32 32s32-14.3 32-32l0-48C576 64.5 511.5 0 432 0S288 64.5 288 144l0 48L64 192c-35.3 0-64 28.7-64 64L0 448c0 35.3 28.7 64 64 64l320 0c35.3 0 64-28.7 64-64l0-192c0-35.3-28.7-64-64-64l-32 0 0-48z"]
}, eU = {
  prefix: "fas",
  iconName: "network-wired",
  icon: [640, 512, [], "f6ff", "M256 64l128 0 0 64-128 0 0-64zM240 0c-26.5 0-48 21.5-48 48l0 96c0 26.5 21.5 48 48 48l48 0 0 32L32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0 0 32-48 0c-26.5 0-48 21.5-48 48l0 96c0 26.5 21.5 48 48 48l160 0c26.5 0 48-21.5 48-48l0-96c0-26.5-21.5-48-48-48l-48 0 0-32 256 0 0 32-48 0c-26.5 0-48 21.5-48 48l0 96c0 26.5 21.5 48 48 48l160 0c26.5 0 48-21.5 48-48l0-96c0-26.5-21.5-48-48-48l-48 0 0-32 96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-256 0 0-32 48 0c26.5 0 48-21.5 48-48l0-96c0-26.5-21.5-48-48-48L240 0zM96 448l0-64 128 0 0 64L96 448zm320-64l128 0 0 64-128 0 0-64z"]
}, tU = {
  prefix: "fas",
  iconName: "magnifying-glass",
  icon: [512, 512, [128269, "search"], "f002", "M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"]
}, nU = {
  prefix: "fas",
  iconName: "chevron-down",
  icon: [512, 512, [], "f078", "M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"]
}, rU = {
  prefix: "fas",
  iconName: "expand",
  icon: [448, 512, [], "f065", "M32 32C14.3 32 0 46.3 0 64l0 96c0 17.7 14.3 32 32 32s32-14.3 32-32l0-64 64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L32 32zM64 352c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-64zM320 32c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0 0 64c0 17.7 14.3 32 32 32s32-14.3 32-32l0-96c0-17.7-14.3-32-32-32l-96 0zM448 352c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 64-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32l0-96z"]
}, iU = {
  prefix: "fas",
  iconName: "xmark",
  icon: [384, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"]
}, oU = {
  prefix: "fas",
  iconName: "chevron-left",
  icon: [320, 512, [9001], "f053", "M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l192 192c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256 246.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192z"]
}, aU = {
  prefix: "fas",
  iconName: "chevron-right",
  icon: [320, 512, [9002], "f054", "M310.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L242.7 256 73.4 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z"]
}, sU = {
  prefix: "fas",
  iconName: "up-right-and-down-left-from-center",
  icon: [512, 512, ["expand-alt"], "f424", "M344 0L488 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39-87 87c-9.4 9.4-24.6 9.4-33.9 0l-32-32c-9.4-9.4-9.4-24.6 0-33.9l87-87L327 41c-6.9-6.9-8.9-17.2-5.2-26.2S334.3 0 344 0zM168 512L24 512c-13.3 0-24-10.7-24-24L0 344c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2l39 39 87-87c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2s-12.5 14.8-22.2 14.8z"]
};
RV.autoAddCss = !1;
const Sn = (e) => {
  const { style: t, ...n } = e;
  return /* @__PURE__ */ _.jsx("span", { style: { marginLeft: "5px", ...t }, children: /* @__PURE__ */ _.jsx(Gb, { ...n }) });
}, JN = (e) => /* @__PURE__ */ _.jsx(Sn, { ...e, icon: XV }), Tv = (e) => /* @__PURE__ */ _.jsx(Sn, { ...e, icon: aU }), sk = (e) => /* @__PURE__ */ _.jsx(Sn, { ...e, icon: oU }), e2 = (e) => /* @__PURE__ */ _.jsx(Sn, { ...e, icon: rU }), lU = (e) => /* @__PURE__ */ _.jsx(Sn, { ...e, icon: WV }), uU = (e) => /* @__PURE__ */ _.jsx(Sn, { ...e, icon: GV }), cU = (e) => /* @__PURE__ */ _.jsx(Sn, { ...e, icon: sU }), lk = (e) => /* @__PURE__ */ _.jsx(Sn, { ...e, icon: nU }), Rv = (e) => /* @__PURE__ */ _.jsx(Sn, { ...e, icon: ZV }), $c = Rv, t2 = (e) => /* @__PURE__ */ _.jsx(Sn, { ...e, icon: iU }), fU = (e) => /* @__PURE__ */ _.jsx(Sn, { ...e, icon: JV }), dU = (e) => /* @__PURE__ */ _.jsx(Sn, { ...e, icon: KV }), hU = (e) => /* @__PURE__ */ _.jsx(Sn, { ...e, icon: eU }), pU = (e) => /* @__PURE__ */ _.jsx(Sn, { ...e, icon: QV }), mU = (e) => /* @__PURE__ */ _.jsx(Sn, { ...e, icon: tU }), bl = ({
  trigger: e,
  title: t,
  description: n,
  children: r,
  closebutton: i = !0,
  onOpenChange: a,
  buttons: s = [],
  open: u,
  setOpen: f,
  modal: d = !0
}) => {
  const h = (b) => {
    f && f(b), a && a(b);
  }, g = C.useContext(Xe).local_state((b) => b.funcnodescontainerRef), y = /* @__PURE__ */ _.jsx(k$, { asChild: !0, children: /* @__PURE__ */ _.jsxs("div", { className: "dialogconent funcnodescontainer", children: [
    t && /* @__PURE__ */ _.jsx(A$, { className: "dialogtitle", children: t }),
    /* @__PURE__ */ _.jsx(T$, { className: "dialogdescription", children: n }),
    /* @__PURE__ */ _.jsx("div", { className: "dialogchildren", children: r }),
    /* @__PURE__ */ _.jsx(
      "div",
      {
        style: {
          display: "flex",
          marginTop: 25,
          justifyContent: "flex-end"
        },
        children: (s || []).map((b, x) => /* @__PURE__ */ _.jsx(AC, { asChild: !0, children: /* @__PURE__ */ _.jsx("button", { className: "dialogsendbutton", onClick: b.onClick, children: b.text }) }, x))
      }
    ),
    i && /* @__PURE__ */ _.jsx(AC, { asChild: !0, children: /* @__PURE__ */ _.jsx("button", { className: "dialogclosebutton", "aria-label": "Close", children: /* @__PURE__ */ _.jsx(t2, {}) }) })
  ] }) });
  return /* @__PURE__ */ _.jsxs(S$, { open: u, onOpenChange: h, modal: d, children: [
    e && /* @__PURE__ */ _.jsx(_$, { asChild: !0, children: e }),
    /* @__PURE__ */ _.jsxs(E$, { container: g, children: [
      /* @__PURE__ */ _.jsx(C$, { className: "dialogoverlay funcnodescontainer" }),
      y
    ] })
  ] });
};
function Xb(e) {
  const t = e + "CollectionProvider", [n, r] = Go(t), [i, a] = n(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), s = (x) => {
    const { scope: E, children: S } = x, A = Qt.useRef(null), k = Qt.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ _.jsx(i, { scope: E, itemMap: k, collectionRef: A, children: S });
  };
  s.displayName = t;
  const u = e + "CollectionSlot", f = /* @__PURE__ */ sl(u), d = Qt.forwardRef(
    (x, E) => {
      const { scope: S, children: A } = x, k = a(u, S), R = Et(E, k.collectionRef);
      return /* @__PURE__ */ _.jsx(f, { ref: R, children: A });
    }
  );
  d.displayName = u;
  const h = e + "CollectionItemSlot", p = "data-radix-collection-item", g = /* @__PURE__ */ sl(h), y = Qt.forwardRef(
    (x, E) => {
      const { scope: S, children: A, ...k } = x, R = Qt.useRef(null), N = Et(E, R), D = a(h, S);
      return Qt.useEffect(() => (D.itemMap.set(R, { ref: R, ...k }), () => void D.itemMap.delete(R))), /* @__PURE__ */ _.jsx(g, { [p]: "", ref: N, children: A });
    }
  );
  y.displayName = h;
  function b(x) {
    const E = a(e + "CollectionConsumer", x);
    return Qt.useCallback(() => {
      const A = E.collectionRef.current;
      if (!A) return [];
      const k = Array.from(A.querySelectorAll(`[${p}]`));
      return Array.from(E.itemMap.values()).sort(
        (D, P) => k.indexOf(D.ref.current) - k.indexOf(P.ref.current)
      );
    }, [E.collectionRef, E.itemMap]);
  }
  return [
    { Provider: s, Slot: d, ItemSlot: y },
    b,
    r
  ];
}
var gU = C.createContext(void 0);
function Wb(e) {
  const t = C.useContext(gU);
  return e || t || "ltr";
}
const yU = ["top", "right", "bottom", "left"], Vo = Math.min, Xn = Math.max, Ph = Math.round, jd = Math.floor, ri = (e) => ({
  x: e,
  y: e
}), vU = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, bU = {
  start: "end",
  end: "start"
};
function Ov(e, t, n) {
  return Xn(e, Vo(t, n));
}
function Ui(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function qi(e) {
  return e.split("-")[0];
}
function xl(e) {
  return e.split("-")[1];
}
function Kb(e) {
  return e === "x" ? "y" : "x";
}
function Zb(e) {
  return e === "y" ? "height" : "width";
}
function Uo(e) {
  return ["top", "bottom"].includes(qi(e)) ? "y" : "x";
}
function Qb(e) {
  return Kb(Uo(e));
}
function xU(e, t, n) {
  n === void 0 && (n = !1);
  const r = xl(e), i = Qb(e), a = Zb(i);
  let s = i === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[a] > t.floating[a] && (s = zh(s)), [s, zh(s)];
}
function wU(e) {
  const t = zh(e);
  return [Nv(e), t, Nv(t)];
}
function Nv(e) {
  return e.replace(/start|end/g, (t) => bU[t]);
}
function SU(e, t, n) {
  const r = ["left", "right"], i = ["right", "left"], a = ["top", "bottom"], s = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? i : r : t ? r : i;
    case "left":
    case "right":
      return t ? a : s;
    default:
      return [];
  }
}
function _U(e, t, n, r) {
  const i = xl(e);
  let a = SU(qi(e), n === "start", r);
  return i && (a = a.map((s) => s + "-" + i), t && (a = a.concat(a.map(Nv)))), a;
}
function zh(e) {
  return e.replace(/left|right|bottom|top/g, (t) => vU[t]);
}
function EU(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function n2(e) {
  return typeof e != "number" ? EU(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function jh(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: i
  } = e;
  return {
    width: r,
    height: i,
    top: n,
    left: t,
    right: t + r,
    bottom: n + i,
    x: t,
    y: n
  };
}
function uk(e, t, n) {
  let {
    reference: r,
    floating: i
  } = e;
  const a = Uo(t), s = Qb(t), u = Zb(s), f = qi(t), d = a === "y", h = r.x + r.width / 2 - i.width / 2, p = r.y + r.height / 2 - i.height / 2, g = r[u] / 2 - i[u] / 2;
  let y;
  switch (f) {
    case "top":
      y = {
        x: h,
        y: r.y - i.height
      };
      break;
    case "bottom":
      y = {
        x: h,
        y: r.y + r.height
      };
      break;
    case "right":
      y = {
        x: r.x + r.width,
        y: p
      };
      break;
    case "left":
      y = {
        x: r.x - i.width,
        y: p
      };
      break;
    default:
      y = {
        x: r.x,
        y: r.y
      };
  }
  switch (xl(t)) {
    case "start":
      y[s] -= g * (n && d ? -1 : 1);
      break;
    case "end":
      y[s] += g * (n && d ? -1 : 1);
      break;
  }
  return y;
}
const CU = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: a = [],
    platform: s
  } = n, u = a.filter(Boolean), f = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let d = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: i
  }), {
    x: h,
    y: p
  } = uk(d, r, f), g = r, y = {}, b = 0;
  for (let x = 0; x < u.length; x++) {
    const {
      name: E,
      fn: S
    } = u[x], {
      x: A,
      y: k,
      data: R,
      reset: N
    } = await S({
      x: h,
      y: p,
      initialPlacement: r,
      placement: g,
      strategy: i,
      middlewareData: y,
      rects: d,
      platform: s,
      elements: {
        reference: e,
        floating: t
      }
    });
    h = A ?? h, p = k ?? p, y = {
      ...y,
      [E]: {
        ...y[E],
        ...R
      }
    }, N && b <= 50 && (b++, typeof N == "object" && (N.placement && (g = N.placement), N.rects && (d = N.rects === !0 ? await s.getElementRects({
      reference: e,
      floating: t,
      strategy: i
    }) : N.rects), {
      x: h,
      y: p
    } = uk(d, g, f)), x = -1);
  }
  return {
    x: h,
    y: p,
    placement: g,
    strategy: i,
    middlewareData: y
  };
};
async function gc(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: i,
    platform: a,
    rects: s,
    elements: u,
    strategy: f
  } = e, {
    boundary: d = "clippingAncestors",
    rootBoundary: h = "viewport",
    elementContext: p = "floating",
    altBoundary: g = !1,
    padding: y = 0
  } = Ui(t, e), b = n2(y), E = u[g ? p === "floating" ? "reference" : "floating" : p], S = jh(await a.getClippingRect({
    element: (n = await (a.isElement == null ? void 0 : a.isElement(E))) == null || n ? E : E.contextElement || await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(u.floating)),
    boundary: d,
    rootBoundary: h,
    strategy: f
  })), A = p === "floating" ? {
    x: r,
    y: i,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, k = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(u.floating)), R = await (a.isElement == null ? void 0 : a.isElement(k)) ? await (a.getScale == null ? void 0 : a.getScale(k)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, N = jh(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: u,
    rect: A,
    offsetParent: k,
    strategy: f
  }) : A);
  return {
    top: (S.top - N.top + b.top) / R.y,
    bottom: (N.bottom - S.bottom + b.bottom) / R.y,
    left: (S.left - N.left + b.left) / R.x,
    right: (N.right - S.right + b.right) / R.x
  };
}
const kU = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: i,
      rects: a,
      platform: s,
      elements: u,
      middlewareData: f
    } = t, {
      element: d,
      padding: h = 0
    } = Ui(e, t) || {};
    if (d == null)
      return {};
    const p = n2(h), g = {
      x: n,
      y: r
    }, y = Qb(i), b = Zb(y), x = await s.getDimensions(d), E = y === "y", S = E ? "top" : "left", A = E ? "bottom" : "right", k = E ? "clientHeight" : "clientWidth", R = a.reference[b] + a.reference[y] - g[y] - a.floating[b], N = g[y] - a.reference[y], D = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(d));
    let P = D ? D[k] : 0;
    (!P || !await (s.isElement == null ? void 0 : s.isElement(D))) && (P = u.floating[k] || a.floating[b]);
    const F = R / 2 - N / 2, V = P / 2 - x[b] / 2 - 1, T = Vo(p[S], V), $ = Vo(p[A], V), H = T, G = P - x[b] - $, j = P / 2 - x[b] / 2 + F, U = Ov(H, j, G), z = !f.arrow && xl(i) != null && j !== U && a.reference[b] / 2 - (j < H ? T : $) - x[b] / 2 < 0, B = z ? j < H ? j - H : j - G : 0;
    return {
      [y]: g[y] + B,
      data: {
        [y]: U,
        centerOffset: j - U - B,
        ...z && {
          alignmentOffset: B
        }
      },
      reset: z
    };
  }
}), AU = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: i,
        middlewareData: a,
        rects: s,
        initialPlacement: u,
        platform: f,
        elements: d
      } = t, {
        mainAxis: h = !0,
        crossAxis: p = !0,
        fallbackPlacements: g,
        fallbackStrategy: y = "bestFit",
        fallbackAxisSideDirection: b = "none",
        flipAlignment: x = !0,
        ...E
      } = Ui(e, t);
      if ((n = a.arrow) != null && n.alignmentOffset)
        return {};
      const S = qi(i), A = Uo(u), k = qi(u) === u, R = await (f.isRTL == null ? void 0 : f.isRTL(d.floating)), N = g || (k || !x ? [zh(u)] : wU(u)), D = b !== "none";
      !g && D && N.push(..._U(u, x, b, R));
      const P = [u, ...N], F = await gc(t, E), V = [];
      let T = ((r = a.flip) == null ? void 0 : r.overflows) || [];
      if (h && V.push(F[S]), p) {
        const j = xU(i, s, R);
        V.push(F[j[0]], F[j[1]]);
      }
      if (T = [...T, {
        placement: i,
        overflows: V
      }], !V.every((j) => j <= 0)) {
        var $, H;
        const j = ((($ = a.flip) == null ? void 0 : $.index) || 0) + 1, U = P[j];
        if (U)
          return {
            data: {
              index: j,
              overflows: T
            },
            reset: {
              placement: U
            }
          };
        let z = (H = T.filter((B) => B.overflows[0] <= 0).sort((B, q) => B.overflows[1] - q.overflows[1])[0]) == null ? void 0 : H.placement;
        if (!z)
          switch (y) {
            case "bestFit": {
              var G;
              const B = (G = T.filter((q) => {
                if (D) {
                  const Y = Uo(q.placement);
                  return Y === A || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  Y === "y";
                }
                return !0;
              }).map((q) => [q.placement, q.overflows.filter((Y) => Y > 0).reduce((Y, O) => Y + O, 0)]).sort((q, Y) => q[1] - Y[1])[0]) == null ? void 0 : G[0];
              B && (z = B);
              break;
            }
            case "initialPlacement":
              z = u;
              break;
          }
        if (i !== z)
          return {
            reset: {
              placement: z
            }
          };
      }
      return {};
    }
  };
};
function ck(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function fk(e) {
  return yU.some((t) => e[t] >= 0);
}
const TU = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: r = "referenceHidden",
        ...i
      } = Ui(e, t);
      switch (r) {
        case "referenceHidden": {
          const a = await gc(t, {
            ...i,
            elementContext: "reference"
          }), s = ck(a, n.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: fk(s)
            }
          };
        }
        case "escaped": {
          const a = await gc(t, {
            ...i,
            altBoundary: !0
          }), s = ck(a, n.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: fk(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function RU(e, t) {
  const {
    placement: n,
    platform: r,
    elements: i
  } = e, a = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), s = qi(n), u = xl(n), f = Uo(n) === "y", d = ["left", "top"].includes(s) ? -1 : 1, h = a && f ? -1 : 1, p = Ui(t, e);
  let {
    mainAxis: g,
    crossAxis: y,
    alignmentAxis: b
  } = typeof p == "number" ? {
    mainAxis: p,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: p.mainAxis || 0,
    crossAxis: p.crossAxis || 0,
    alignmentAxis: p.alignmentAxis
  };
  return u && typeof b == "number" && (y = u === "end" ? b * -1 : b), f ? {
    x: y * h,
    y: g * d
  } : {
    x: g * d,
    y: y * h
  };
}
const OU = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: i,
        y: a,
        placement: s,
        middlewareData: u
      } = t, f = await RU(t, e);
      return s === ((n = u.offset) == null ? void 0 : n.placement) && (r = u.arrow) != null && r.alignmentOffset ? {} : {
        x: i + f.x,
        y: a + f.y,
        data: {
          ...f,
          placement: s
        }
      };
    }
  };
}, NU = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: i
      } = t, {
        mainAxis: a = !0,
        crossAxis: s = !1,
        limiter: u = {
          fn: (E) => {
            let {
              x: S,
              y: A
            } = E;
            return {
              x: S,
              y: A
            };
          }
        },
        ...f
      } = Ui(e, t), d = {
        x: n,
        y: r
      }, h = await gc(t, f), p = Uo(qi(i)), g = Kb(p);
      let y = d[g], b = d[p];
      if (a) {
        const E = g === "y" ? "top" : "left", S = g === "y" ? "bottom" : "right", A = y + h[E], k = y - h[S];
        y = Ov(A, y, k);
      }
      if (s) {
        const E = p === "y" ? "top" : "left", S = p === "y" ? "bottom" : "right", A = b + h[E], k = b - h[S];
        b = Ov(A, b, k);
      }
      const x = u.fn({
        ...t,
        [g]: y,
        [p]: b
      });
      return {
        ...x,
        data: {
          x: x.x - n,
          y: x.y - r,
          enabled: {
            [g]: a,
            [p]: s
          }
        }
      };
    }
  };
}, MU = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: r,
        placement: i,
        rects: a,
        middlewareData: s
      } = t, {
        offset: u = 0,
        mainAxis: f = !0,
        crossAxis: d = !0
      } = Ui(e, t), h = {
        x: n,
        y: r
      }, p = Uo(i), g = Kb(p);
      let y = h[g], b = h[p];
      const x = Ui(u, t), E = typeof x == "number" ? {
        mainAxis: x,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...x
      };
      if (f) {
        const k = g === "y" ? "height" : "width", R = a.reference[g] - a.floating[k] + E.mainAxis, N = a.reference[g] + a.reference[k] - E.mainAxis;
        y < R ? y = R : y > N && (y = N);
      }
      if (d) {
        var S, A;
        const k = g === "y" ? "width" : "height", R = ["top", "left"].includes(qi(i)), N = a.reference[p] - a.floating[k] + (R && ((S = s.offset) == null ? void 0 : S[p]) || 0) + (R ? 0 : E.crossAxis), D = a.reference[p] + a.reference[k] + (R ? 0 : ((A = s.offset) == null ? void 0 : A[p]) || 0) - (R ? E.crossAxis : 0);
        b < N ? b = N : b > D && (b = D);
      }
      return {
        [g]: y,
        [p]: b
      };
    }
  };
}, DU = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: i,
        rects: a,
        platform: s,
        elements: u
      } = t, {
        apply: f = () => {
        },
        ...d
      } = Ui(e, t), h = await gc(t, d), p = qi(i), g = xl(i), y = Uo(i) === "y", {
        width: b,
        height: x
      } = a.floating;
      let E, S;
      p === "top" || p === "bottom" ? (E = p, S = g === (await (s.isRTL == null ? void 0 : s.isRTL(u.floating)) ? "start" : "end") ? "left" : "right") : (S = p, E = g === "end" ? "top" : "bottom");
      const A = x - h.top - h.bottom, k = b - h.left - h.right, R = Vo(x - h[E], A), N = Vo(b - h[S], k), D = !t.middlewareData.shift;
      let P = R, F = N;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (F = k), (r = t.middlewareData.shift) != null && r.enabled.y && (P = A), D && !g) {
        const T = Xn(h.left, 0), $ = Xn(h.right, 0), H = Xn(h.top, 0), G = Xn(h.bottom, 0);
        y ? F = b - 2 * (T !== 0 || $ !== 0 ? T + $ : Xn(h.left, h.right)) : P = x - 2 * (H !== 0 || G !== 0 ? H + G : Xn(h.top, h.bottom));
      }
      await f({
        ...t,
        availableWidth: F,
        availableHeight: P
      });
      const V = await s.getDimensions(u.floating);
      return b !== V.width || x !== V.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Np() {
  return typeof window < "u";
}
function wl(e) {
  return r2(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function Qn(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function li(e) {
  var t;
  return (t = (r2(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function r2(e) {
  return Np() ? e instanceof Node || e instanceof Qn(e).Node : !1;
}
function Dr(e) {
  return Np() ? e instanceof Element || e instanceof Qn(e).Element : !1;
}
function ai(e) {
  return Np() ? e instanceof HTMLElement || e instanceof Qn(e).HTMLElement : !1;
}
function dk(e) {
  return !Np() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof Qn(e).ShadowRoot;
}
function Hc(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: i
  } = Pr(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(i);
}
function PU(e) {
  return ["table", "td", "th"].includes(wl(e));
}
function Mp(e) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
function Jb(e) {
  const t = e1(), n = Dr(e) ? Pr(e) : e;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function zU(e) {
  let t = qo(e);
  for (; ai(t) && !ul(t); ) {
    if (Jb(t))
      return t;
    if (Mp(t))
      return null;
    t = qo(t);
  }
  return null;
}
function e1() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function ul(e) {
  return ["html", "body", "#document"].includes(wl(e));
}
function Pr(e) {
  return Qn(e).getComputedStyle(e);
}
function Dp(e) {
  return Dr(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function qo(e) {
  if (wl(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    dk(e) && e.host || // Fallback.
    li(e)
  );
  return dk(t) ? t.host : t;
}
function i2(e) {
  const t = qo(e);
  return ul(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : ai(t) && Hc(t) ? t : i2(t);
}
function yc(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const i = i2(e), a = i === ((r = e.ownerDocument) == null ? void 0 : r.body), s = Qn(i);
  if (a) {
    const u = Mv(s);
    return t.concat(s, s.visualViewport || [], Hc(i) ? i : [], u && n ? yc(u) : []);
  }
  return t.concat(i, yc(i, [], n));
}
function Mv(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function o2(e) {
  const t = Pr(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const i = ai(e), a = i ? e.offsetWidth : n, s = i ? e.offsetHeight : r, u = Ph(n) !== a || Ph(r) !== s;
  return u && (n = a, r = s), {
    width: n,
    height: r,
    $: u
  };
}
function t1(e) {
  return Dr(e) ? e : e.contextElement;
}
function Ws(e) {
  const t = t1(e);
  if (!ai(t))
    return ri(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: i,
    $: a
  } = o2(t);
  let s = (a ? Ph(n.width) : n.width) / r, u = (a ? Ph(n.height) : n.height) / i;
  return (!s || !Number.isFinite(s)) && (s = 1), (!u || !Number.isFinite(u)) && (u = 1), {
    x: s,
    y: u
  };
}
const jU = /* @__PURE__ */ ri(0);
function a2(e) {
  const t = Qn(e);
  return !e1() || !t.visualViewport ? jU : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function IU(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== Qn(e) ? !1 : t;
}
function za(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const i = e.getBoundingClientRect(), a = t1(e);
  let s = ri(1);
  t && (r ? Dr(r) && (s = Ws(r)) : s = Ws(e));
  const u = IU(a, n, r) ? a2(a) : ri(0);
  let f = (i.left + u.x) / s.x, d = (i.top + u.y) / s.y, h = i.width / s.x, p = i.height / s.y;
  if (a) {
    const g = Qn(a), y = r && Dr(r) ? Qn(r) : r;
    let b = g, x = Mv(b);
    for (; x && r && y !== b; ) {
      const E = Ws(x), S = x.getBoundingClientRect(), A = Pr(x), k = S.left + (x.clientLeft + parseFloat(A.paddingLeft)) * E.x, R = S.top + (x.clientTop + parseFloat(A.paddingTop)) * E.y;
      f *= E.x, d *= E.y, h *= E.x, p *= E.y, f += k, d += R, b = Qn(x), x = Mv(b);
    }
  }
  return jh({
    width: h,
    height: p,
    x: f,
    y: d
  });
}
function n1(e, t) {
  const n = Dp(e).scrollLeft;
  return t ? t.left + n : za(li(e)).left + n;
}
function s2(e, t, n) {
  n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), i = r.left + t.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    n1(e, r)
  )), a = r.top + t.scrollTop;
  return {
    x: i,
    y: a
  };
}
function LU(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: i
  } = e;
  const a = i === "fixed", s = li(r), u = t ? Mp(t.floating) : !1;
  if (r === s || u && a)
    return n;
  let f = {
    scrollLeft: 0,
    scrollTop: 0
  }, d = ri(1);
  const h = ri(0), p = ai(r);
  if ((p || !p && !a) && ((wl(r) !== "body" || Hc(s)) && (f = Dp(r)), ai(r))) {
    const y = za(r);
    d = Ws(r), h.x = y.x + r.clientLeft, h.y = y.y + r.clientTop;
  }
  const g = s && !p && !a ? s2(s, f, !0) : ri(0);
  return {
    width: n.width * d.x,
    height: n.height * d.y,
    x: n.x * d.x - f.scrollLeft * d.x + h.x + g.x,
    y: n.y * d.y - f.scrollTop * d.y + h.y + g.y
  };
}
function FU(e) {
  return Array.from(e.getClientRects());
}
function BU(e) {
  const t = li(e), n = Dp(e), r = e.ownerDocument.body, i = Xn(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), a = Xn(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -n.scrollLeft + n1(e);
  const u = -n.scrollTop;
  return Pr(r).direction === "rtl" && (s += Xn(t.clientWidth, r.clientWidth) - i), {
    width: i,
    height: a,
    x: s,
    y: u
  };
}
function $U(e, t) {
  const n = Qn(e), r = li(e), i = n.visualViewport;
  let a = r.clientWidth, s = r.clientHeight, u = 0, f = 0;
  if (i) {
    a = i.width, s = i.height;
    const d = e1();
    (!d || d && t === "fixed") && (u = i.offsetLeft, f = i.offsetTop);
  }
  return {
    width: a,
    height: s,
    x: u,
    y: f
  };
}
function HU(e, t) {
  const n = za(e, !0, t === "fixed"), r = n.top + e.clientTop, i = n.left + e.clientLeft, a = ai(e) ? Ws(e) : ri(1), s = e.clientWidth * a.x, u = e.clientHeight * a.y, f = i * a.x, d = r * a.y;
  return {
    width: s,
    height: u,
    x: f,
    y: d
  };
}
function hk(e, t, n) {
  let r;
  if (t === "viewport")
    r = $U(e, n);
  else if (t === "document")
    r = BU(li(e));
  else if (Dr(t))
    r = HU(t, n);
  else {
    const i = a2(e);
    r = {
      x: t.x - i.x,
      y: t.y - i.y,
      width: t.width,
      height: t.height
    };
  }
  return jh(r);
}
function l2(e, t) {
  const n = qo(e);
  return n === t || !Dr(n) || ul(n) ? !1 : Pr(n).position === "fixed" || l2(n, t);
}
function VU(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = yc(e, [], !1).filter((u) => Dr(u) && wl(u) !== "body"), i = null;
  const a = Pr(e).position === "fixed";
  let s = a ? qo(e) : e;
  for (; Dr(s) && !ul(s); ) {
    const u = Pr(s), f = Jb(s);
    !f && u.position === "fixed" && (i = null), (a ? !f && !i : !f && u.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || Hc(s) && !f && l2(e, s)) ? r = r.filter((h) => h !== s) : i = u, s = qo(s);
  }
  return t.set(e, r), r;
}
function UU(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: i
  } = e;
  const s = [...n === "clippingAncestors" ? Mp(t) ? [] : VU(t, this._c) : [].concat(n), r], u = s[0], f = s.reduce((d, h) => {
    const p = hk(t, h, i);
    return d.top = Xn(p.top, d.top), d.right = Vo(p.right, d.right), d.bottom = Vo(p.bottom, d.bottom), d.left = Xn(p.left, d.left), d;
  }, hk(t, u, i));
  return {
    width: f.right - f.left,
    height: f.bottom - f.top,
    x: f.left,
    y: f.top
  };
}
function qU(e) {
  const {
    width: t,
    height: n
  } = o2(e);
  return {
    width: t,
    height: n
  };
}
function YU(e, t, n) {
  const r = ai(t), i = li(t), a = n === "fixed", s = za(e, !0, a, t);
  let u = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const f = ri(0);
  if (r || !r && !a)
    if ((wl(t) !== "body" || Hc(i)) && (u = Dp(t)), r) {
      const g = za(t, !0, a, t);
      f.x = g.x + t.clientLeft, f.y = g.y + t.clientTop;
    } else i && (f.x = n1(i));
  const d = i && !r && !a ? s2(i, u) : ri(0), h = s.left + u.scrollLeft - f.x - d.x, p = s.top + u.scrollTop - f.y - d.y;
  return {
    x: h,
    y: p,
    width: s.width,
    height: s.height
  };
}
function ny(e) {
  return Pr(e).position === "static";
}
function pk(e, t) {
  if (!ai(e) || Pr(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return li(e) === n && (n = n.ownerDocument.body), n;
}
function u2(e, t) {
  const n = Qn(e);
  if (Mp(e))
    return n;
  if (!ai(e)) {
    let i = qo(e);
    for (; i && !ul(i); ) {
      if (Dr(i) && !ny(i))
        return i;
      i = qo(i);
    }
    return n;
  }
  let r = pk(e, t);
  for (; r && PU(r) && ny(r); )
    r = pk(r, t);
  return r && ul(r) && ny(r) && !Jb(r) ? n : r || zU(e) || n;
}
const GU = async function(e) {
  const t = this.getOffsetParent || u2, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: YU(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function XU(e) {
  return Pr(e).direction === "rtl";
}
const WU = {
  convertOffsetParentRelativeRectToViewportRelativeRect: LU,
  getDocumentElement: li,
  getClippingRect: UU,
  getOffsetParent: u2,
  getElementRects: GU,
  getClientRects: FU,
  getDimensions: qU,
  getScale: Ws,
  isElement: Dr,
  isRTL: XU
};
function c2(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function KU(e, t) {
  let n = null, r;
  const i = li(e);
  function a() {
    var u;
    clearTimeout(r), (u = n) == null || u.disconnect(), n = null;
  }
  function s(u, f) {
    u === void 0 && (u = !1), f === void 0 && (f = 1), a();
    const d = e.getBoundingClientRect(), {
      left: h,
      top: p,
      width: g,
      height: y
    } = d;
    if (u || t(), !g || !y)
      return;
    const b = jd(p), x = jd(i.clientWidth - (h + g)), E = jd(i.clientHeight - (p + y)), S = jd(h), k = {
      rootMargin: -b + "px " + -x + "px " + -E + "px " + -S + "px",
      threshold: Xn(0, Vo(1, f)) || 1
    };
    let R = !0;
    function N(D) {
      const P = D[0].intersectionRatio;
      if (P !== f) {
        if (!R)
          return s();
        P ? s(!1, P) : r = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      P === 1 && !c2(d, e.getBoundingClientRect()) && s(), R = !1;
    }
    try {
      n = new IntersectionObserver(N, {
        ...k,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(N, k);
    }
    n.observe(e);
  }
  return s(!0), a;
}
function f2(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: a = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: u = typeof IntersectionObserver == "function",
    animationFrame: f = !1
  } = r, d = t1(e), h = i || a ? [...d ? yc(d) : [], ...yc(t)] : [];
  h.forEach((S) => {
    i && S.addEventListener("scroll", n, {
      passive: !0
    }), a && S.addEventListener("resize", n);
  });
  const p = d && u ? KU(d, n) : null;
  let g = -1, y = null;
  s && (y = new ResizeObserver((S) => {
    let [A] = S;
    A && A.target === d && y && (y.unobserve(t), cancelAnimationFrame(g), g = requestAnimationFrame(() => {
      var k;
      (k = y) == null || k.observe(t);
    })), n();
  }), d && !f && y.observe(d), y.observe(t));
  let b, x = f ? za(e) : null;
  f && E();
  function E() {
    const S = za(e);
    x && !c2(x, S) && n(), x = S, b = requestAnimationFrame(E);
  }
  return n(), () => {
    var S;
    h.forEach((A) => {
      i && A.removeEventListener("scroll", n), a && A.removeEventListener("resize", n);
    }), p?.(), (S = y) == null || S.disconnect(), y = null, f && cancelAnimationFrame(b);
  };
}
const ZU = OU, QU = NU, JU = AU, eq = DU, tq = TU, mk = kU, nq = MU, rq = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: WU,
    ...n
  }, a = {
    ...i.platform,
    _c: r
  };
  return CU(e, t, {
    ...i,
    platform: a
  });
};
var lh = typeof document < "u" ? C.useLayoutEffect : C.useEffect;
function Ih(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, i;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!Ih(e[r], t[r]))
          return !1;
      return !0;
    }
    if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, i[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const a = i[r];
      if (!(a === "_owner" && e.$$typeof) && !Ih(e[a], t[a]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function d2(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function gk(e, t) {
  const n = d2(e);
  return Math.round(t * n) / n;
}
function ry(e) {
  const t = C.useRef(e);
  return lh(() => {
    t.current = e;
  }), t;
}
function iq(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: i,
    elements: {
      reference: a,
      floating: s
    } = {},
    transform: u = !0,
    whileElementsMounted: f,
    open: d
  } = e, [h, p] = C.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [g, y] = C.useState(r);
  Ih(g, r) || y(r);
  const [b, x] = C.useState(null), [E, S] = C.useState(null), A = C.useCallback((q) => {
    q !== D.current && (D.current = q, x(q));
  }, []), k = C.useCallback((q) => {
    q !== P.current && (P.current = q, S(q));
  }, []), R = a || b, N = s || E, D = C.useRef(null), P = C.useRef(null), F = C.useRef(h), V = f != null, T = ry(f), $ = ry(i), H = ry(d), G = C.useCallback(() => {
    if (!D.current || !P.current)
      return;
    const q = {
      placement: t,
      strategy: n,
      middleware: g
    };
    $.current && (q.platform = $.current), rq(D.current, P.current, q).then((Y) => {
      const O = {
        ...Y,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: H.current !== !1
      };
      j.current && !Ih(F.current, O) && (F.current = O, Pc.flushSync(() => {
        p(O);
      }));
    });
  }, [g, t, n, $, H]);
  lh(() => {
    d === !1 && F.current.isPositioned && (F.current.isPositioned = !1, p((q) => ({
      ...q,
      isPositioned: !1
    })));
  }, [d]);
  const j = C.useRef(!1);
  lh(() => (j.current = !0, () => {
    j.current = !1;
  }), []), lh(() => {
    if (R && (D.current = R), N && (P.current = N), R && N) {
      if (T.current)
        return T.current(R, N, G);
      G();
    }
  }, [R, N, G, T, V]);
  const U = C.useMemo(() => ({
    reference: D,
    floating: P,
    setReference: A,
    setFloating: k
  }), [A, k]), z = C.useMemo(() => ({
    reference: R,
    floating: N
  }), [R, N]), B = C.useMemo(() => {
    const q = {
      position: n,
      left: 0,
      top: 0
    };
    if (!z.floating)
      return q;
    const Y = gk(z.floating, h.x), O = gk(z.floating, h.y);
    return u ? {
      ...q,
      transform: "translate(" + Y + "px, " + O + "px)",
      ...d2(z.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: Y,
      top: O
    };
  }, [n, u, z.floating, h.x, h.y]);
  return C.useMemo(() => ({
    ...h,
    update: G,
    refs: U,
    elements: z,
    floatingStyles: B
  }), [h, G, U, z, B]);
}
const oq = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: r,
        padding: i
      } = typeof e == "function" ? e(n) : e;
      return r && t(r) ? r.current != null ? mk({
        element: r.current,
        padding: i
      }).fn(n) : {} : r ? mk({
        element: r,
        padding: i
      }).fn(n) : {};
    }
  };
}, aq = (e, t) => ({
  ...ZU(e),
  options: [e, t]
}), sq = (e, t) => ({
  ...QU(e),
  options: [e, t]
}), lq = (e, t) => ({
  ...nq(e),
  options: [e, t]
}), uq = (e, t) => ({
  ...JU(e),
  options: [e, t]
}), cq = (e, t) => ({
  ...eq(e),
  options: [e, t]
}), fq = (e, t) => ({
  ...tq(e),
  options: [e, t]
}), dq = (e, t) => ({
  ...oq(e),
  options: [e, t]
});
var hq = "Arrow", h2 = C.forwardRef((e, t) => {
  const { children: n, width: r = 10, height: i = 5, ...a } = e;
  return /* @__PURE__ */ _.jsx(
    vt.svg,
    {
      ...a,
      ref: t,
      width: r,
      height: i,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : /* @__PURE__ */ _.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
h2.displayName = hq;
var pq = h2;
function p2(e) {
  const [t, n] = C.useState(void 0);
  return Na(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const r = new ResizeObserver((i) => {
        if (!Array.isArray(i) || !i.length)
          return;
        const a = i[0];
        let s, u;
        if ("borderBoxSize" in a) {
          const f = a.borderBoxSize, d = Array.isArray(f) ? f[0] : f;
          s = d.inlineSize, u = d.blockSize;
        } else
          s = e.offsetWidth, u = e.offsetHeight;
        n({ width: s, height: u });
      });
      return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
var r1 = "Popper", [m2, Pp] = Go(r1), [mq, g2] = m2(r1), y2 = (e) => {
  const { __scopePopper: t, children: n } = e, [r, i] = C.useState(null);
  return /* @__PURE__ */ _.jsx(mq, { scope: t, anchor: r, onAnchorChange: i, children: n });
};
y2.displayName = r1;
var v2 = "PopperAnchor", b2 = C.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: r, ...i } = e, a = g2(v2, n), s = C.useRef(null), u = Et(t, s);
    return C.useEffect(() => {
      a.onAnchorChange(r?.current || s.current);
    }), r ? null : /* @__PURE__ */ _.jsx(vt.div, { ...i, ref: u });
  }
);
b2.displayName = v2;
var i1 = "PopperContent", [gq, yq] = m2(i1), x2 = C.forwardRef(
  (e, t) => {
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: i = 0,
      align: a = "center",
      alignOffset: s = 0,
      arrowPadding: u = 0,
      avoidCollisions: f = !0,
      collisionBoundary: d = [],
      collisionPadding: h = 0,
      sticky: p = "partial",
      hideWhenDetached: g = !1,
      updatePositionStrategy: y = "optimized",
      onPlaced: b,
      ...x
    } = e, E = g2(i1, n), [S, A] = C.useState(null), k = Et(t, (le) => A(le)), [R, N] = C.useState(null), D = p2(R), P = D?.width ?? 0, F = D?.height ?? 0, V = r + (a !== "center" ? "-" + a : ""), T = typeof h == "number" ? h : { top: 0, right: 0, bottom: 0, left: 0, ...h }, $ = Array.isArray(d) ? d : [d], H = $.length > 0, G = {
      padding: T,
      boundary: $.filter(bq),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: H
    }, { refs: j, floatingStyles: U, placement: z, isPositioned: B, middlewareData: q } = iq({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: V,
      whileElementsMounted: (...le) => f2(...le, {
        animationFrame: y === "always"
      }),
      elements: {
        reference: E.anchor
      },
      middleware: [
        aq({ mainAxis: i + F, alignmentAxis: s }),
        f && sq({
          mainAxis: !0,
          crossAxis: !1,
          limiter: p === "partial" ? lq() : void 0,
          ...G
        }),
        f && uq({ ...G }),
        cq({
          ...G,
          apply: ({ elements: le, rects: he, availableWidth: ye, availableHeight: je }) => {
            const { width: Oe, height: be } = he.reference, Le = le.floating.style;
            Le.setProperty("--radix-popper-available-width", `${ye}px`), Le.setProperty("--radix-popper-available-height", `${je}px`), Le.setProperty("--radix-popper-anchor-width", `${Oe}px`), Le.setProperty("--radix-popper-anchor-height", `${be}px`);
          }
        }),
        R && dq({ element: R, padding: u }),
        xq({ arrowWidth: P, arrowHeight: F }),
        g && fq({ strategy: "referenceHidden", ...G })
      ]
    }), [Y, O] = _2(z), W = yr(b);
    Na(() => {
      B && W?.();
    }, [B, W]);
    const Z = q.arrow?.x, I = q.arrow?.y, ie = q.arrow?.centerOffset !== 0, [fe, re] = C.useState();
    return Na(() => {
      S && re(window.getComputedStyle(S).zIndex);
    }, [S]), /* @__PURE__ */ _.jsx(
      "div",
      {
        ref: j.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...U,
          transform: B ? U.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: fe,
          "--radix-popper-transform-origin": [
            q.transformOrigin?.x,
            q.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...q.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ _.jsx(
          gq,
          {
            scope: n,
            placedSide: Y,
            onArrowChange: N,
            arrowX: Z,
            arrowY: I,
            shouldHideArrow: ie,
            children: /* @__PURE__ */ _.jsx(
              vt.div,
              {
                "data-side": Y,
                "data-align": O,
                ...x,
                ref: k,
                style: {
                  ...x.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: B ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
x2.displayName = i1;
var w2 = "PopperArrow", vq = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, S2 = C.forwardRef(function(t, n) {
  const { __scopePopper: r, ...i } = t, a = yq(w2, r), s = vq[a.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ _.jsx(
      "span",
      {
        ref: a.onArrowChange,
        style: {
          position: "absolute",
          left: a.arrowX,
          top: a.arrowY,
          [s]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[a.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[a.placedSide],
          visibility: a.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ _.jsx(
          pq,
          {
            ...i,
            ref: n,
            style: {
              ...i.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
S2.displayName = w2;
function bq(e) {
  return e !== null;
}
var xq = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    const { placement: n, rects: r, middlewareData: i } = t, s = i.arrow?.centerOffset !== 0, u = s ? 0 : e.arrowWidth, f = s ? 0 : e.arrowHeight, [d, h] = _2(n), p = { start: "0%", center: "50%", end: "100%" }[h], g = (i.arrow?.x ?? 0) + u / 2, y = (i.arrow?.y ?? 0) + f / 2;
    let b = "", x = "";
    return d === "bottom" ? (b = s ? p : `${g}px`, x = `${-f}px`) : d === "top" ? (b = s ? p : `${g}px`, x = `${r.floating.height + f}px`) : d === "right" ? (b = `${-f}px`, x = s ? p : `${y}px`) : d === "left" && (b = `${r.floating.width + f}px`, x = s ? p : `${y}px`), { data: { x: b, y: x } };
  }
});
function _2(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var o1 = y2, a1 = b2, E2 = x2, C2 = S2, iy = "rovingFocusGroup.onEntryFocus", wq = { bubbles: !1, cancelable: !0 }, zp = "RovingFocusGroup", [Dv, k2, Sq] = Xb(zp), [_q, A2] = Go(
  zp,
  [Sq]
), [Eq, Cq] = _q(zp), T2 = C.forwardRef(
  (e, t) => /* @__PURE__ */ _.jsx(Dv.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ _.jsx(Dv.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ _.jsx(kq, { ...e, ref: t }) }) })
);
T2.displayName = zp;
var kq = C.forwardRef((e, t) => {
  const {
    __scopeRovingFocusGroup: n,
    orientation: r,
    loop: i = !1,
    dir: a,
    currentTabStopId: s,
    defaultCurrentTabStopId: u,
    onCurrentTabStopIdChange: f,
    onEntryFocus: d,
    preventScrollOnEntryFocus: h = !1,
    ...p
  } = e, g = C.useRef(null), y = Et(t, g), b = Wb(a), [x = null, E] = yl({
    prop: s,
    defaultProp: u,
    onChange: f
  }), [S, A] = C.useState(!1), k = yr(d), R = k2(n), N = C.useRef(!1), [D, P] = C.useState(0);
  return C.useEffect(() => {
    const F = g.current;
    if (F)
      return F.addEventListener(iy, k), () => F.removeEventListener(iy, k);
  }, [k]), /* @__PURE__ */ _.jsx(
    Eq,
    {
      scope: n,
      orientation: r,
      dir: b,
      loop: i,
      currentTabStopId: x,
      onItemFocus: C.useCallback(
        (F) => E(F),
        [E]
      ),
      onItemShiftTab: C.useCallback(() => A(!0), []),
      onFocusableItemAdd: C.useCallback(
        () => P((F) => F + 1),
        []
      ),
      onFocusableItemRemove: C.useCallback(
        () => P((F) => F - 1),
        []
      ),
      children: /* @__PURE__ */ _.jsx(
        vt.div,
        {
          tabIndex: S || D === 0 ? -1 : 0,
          "data-orientation": r,
          ...p,
          ref: y,
          style: { outline: "none", ...e.style },
          onMouseDown: De(e.onMouseDown, () => {
            N.current = !0;
          }),
          onFocus: De(e.onFocus, (F) => {
            const V = !N.current;
            if (F.target === F.currentTarget && V && !S) {
              const T = new CustomEvent(iy, wq);
              if (F.currentTarget.dispatchEvent(T), !T.defaultPrevented) {
                const $ = R().filter((z) => z.focusable), H = $.find((z) => z.active), G = $.find((z) => z.id === x), U = [H, G, ...$].filter(
                  Boolean
                ).map((z) => z.ref.current);
                N2(U, h);
              }
            }
            N.current = !1;
          }),
          onBlur: De(e.onBlur, () => A(!1))
        }
      )
    }
  );
}), R2 = "RovingFocusGroupItem", O2 = C.forwardRef(
  (e, t) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: r = !0,
      active: i = !1,
      tabStopId: a,
      ...s
    } = e, u = Li(), f = a || u, d = Cq(R2, n), h = d.currentTabStopId === f, p = k2(n), { onFocusableItemAdd: g, onFocusableItemRemove: y } = d;
    return C.useEffect(() => {
      if (r)
        return g(), () => y();
    }, [r, g, y]), /* @__PURE__ */ _.jsx(
      Dv.ItemSlot,
      {
        scope: n,
        id: f,
        focusable: r,
        active: i,
        children: /* @__PURE__ */ _.jsx(
          vt.span,
          {
            tabIndex: h ? 0 : -1,
            "data-orientation": d.orientation,
            ...s,
            ref: t,
            onMouseDown: De(e.onMouseDown, (b) => {
              r ? d.onItemFocus(f) : b.preventDefault();
            }),
            onFocus: De(e.onFocus, () => d.onItemFocus(f)),
            onKeyDown: De(e.onKeyDown, (b) => {
              if (b.key === "Tab" && b.shiftKey) {
                d.onItemShiftTab();
                return;
              }
              if (b.target !== b.currentTarget) return;
              const x = Rq(b, d.orientation, d.dir);
              if (x !== void 0) {
                if (b.metaKey || b.ctrlKey || b.altKey || b.shiftKey) return;
                b.preventDefault();
                let S = p().filter((A) => A.focusable).map((A) => A.ref.current);
                if (x === "last") S.reverse();
                else if (x === "prev" || x === "next") {
                  x === "prev" && S.reverse();
                  const A = S.indexOf(b.currentTarget);
                  S = d.loop ? Oq(S, A + 1) : S.slice(A + 1);
                }
                setTimeout(() => N2(S));
              }
            })
          }
        )
      }
    );
  }
);
O2.displayName = R2;
var Aq = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function Tq(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function Rq(e, t, n) {
  const r = Tq(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return Aq[r];
}
function N2(e, t = !1) {
  const n = document.activeElement;
  for (const r of e)
    if (r === n || (r.focus({ preventScroll: t }), document.activeElement !== n)) return;
}
function Oq(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var Nq = T2, Mq = O2, Pv = ["Enter", " "], Dq = ["ArrowDown", "PageUp", "Home"], M2 = ["ArrowUp", "PageDown", "End"], Pq = [...Dq, ...M2], zq = {
  ltr: [...Pv, "ArrowRight"],
  rtl: [...Pv, "ArrowLeft"]
}, jq = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, Vc = "Menu", [vc, Iq, Lq] = Xb(Vc), [Fa, D2] = Go(Vc, [
  Lq,
  Pp,
  A2
]), Uc = Pp(), P2 = A2(), [z2, Ba] = Fa(Vc), [Fq, qc] = Fa(Vc), j2 = (e) => {
  const { __scopeMenu: t, open: n = !1, children: r, dir: i, onOpenChange: a, modal: s = !0 } = e, u = Uc(t), [f, d] = C.useState(null), h = C.useRef(!1), p = yr(a), g = Wb(i);
  return C.useEffect(() => {
    const y = () => {
      h.current = !0, document.addEventListener("pointerdown", b, { capture: !0, once: !0 }), document.addEventListener("pointermove", b, { capture: !0, once: !0 });
    }, b = () => h.current = !1;
    return document.addEventListener("keydown", y, { capture: !0 }), () => {
      document.removeEventListener("keydown", y, { capture: !0 }), document.removeEventListener("pointerdown", b, { capture: !0 }), document.removeEventListener("pointermove", b, { capture: !0 });
    };
  }, []), /* @__PURE__ */ _.jsx(o1, { ...u, children: /* @__PURE__ */ _.jsx(
    z2,
    {
      scope: t,
      open: n,
      onOpenChange: p,
      content: f,
      onContentChange: d,
      children: /* @__PURE__ */ _.jsx(
        Fq,
        {
          scope: t,
          onClose: C.useCallback(() => p(!1), [p]),
          isUsingKeyboardRef: h,
          dir: g,
          modal: s,
          children: r
        }
      )
    }
  ) });
};
j2.displayName = Vc;
var Bq = "MenuAnchor", s1 = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, i = Uc(n);
    return /* @__PURE__ */ _.jsx(a1, { ...i, ...r, ref: t });
  }
);
s1.displayName = Bq;
var $q = "MenuPortal", [Nue, I2] = Fa($q, {
  forceMount: void 0
}), gr = "MenuContent", [Hq, l1] = Fa(gr), L2 = C.forwardRef(
  (e, t) => {
    const n = I2(gr, e.__scopeMenu), { forceMount: r = n.forceMount, ...i } = e, a = Ba(gr, e.__scopeMenu), s = qc(gr, e.__scopeMenu);
    return /* @__PURE__ */ _.jsx(vc.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ _.jsx(Xi, { present: r || a.open, children: /* @__PURE__ */ _.jsx(vc.Slot, { scope: e.__scopeMenu, children: s.modal ? /* @__PURE__ */ _.jsx(Vq, { ...i, ref: t }) : /* @__PURE__ */ _.jsx(Uq, { ...i, ref: t }) }) }) });
  }
), Vq = C.forwardRef(
  (e, t) => {
    const n = Ba(gr, e.__scopeMenu), r = C.useRef(null), i = Et(t, r);
    return C.useEffect(() => {
      const a = r.current;
      if (a) return Nb(a);
    }, []), /* @__PURE__ */ _.jsx(
      u1,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: De(
          e.onFocusOutside,
          (a) => a.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }
), Uq = C.forwardRef((e, t) => {
  const n = Ba(gr, e.__scopeMenu);
  return /* @__PURE__ */ _.jsx(
    u1,
    {
      ...e,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1)
    }
  );
}), qq = /* @__PURE__ */ sl("MenuContent.ScrollLock"), u1 = C.forwardRef(
  (e, t) => {
    const {
      __scopeMenu: n,
      loop: r = !1,
      trapFocus: i,
      onOpenAutoFocus: a,
      onCloseAutoFocus: s,
      disableOutsidePointerEvents: u,
      onEntryFocus: f,
      onEscapeKeyDown: d,
      onPointerDownOutside: h,
      onFocusOutside: p,
      onInteractOutside: g,
      onDismiss: y,
      disableOutsideScroll: b,
      ...x
    } = e, E = Ba(gr, n), S = qc(gr, n), A = Uc(n), k = P2(n), R = Iq(n), [N, D] = C.useState(null), P = C.useRef(null), F = Et(t, P, E.onContentChange), V = C.useRef(0), T = C.useRef(""), $ = C.useRef(0), H = C.useRef(null), G = C.useRef("right"), j = C.useRef(0), U = b ? Cp : C.Fragment, z = b ? { as: qq, allowPinchZoom: !0 } : void 0, B = (Y) => {
      const O = T.current + Y, W = R().filter((le) => !le.disabled), Z = document.activeElement, I = W.find((le) => le.ref.current === Z)?.textValue, ie = W.map((le) => le.textValue), fe = rY(ie, O, I), re = W.find((le) => le.textValue === fe)?.ref.current;
      (function le(he) {
        T.current = he, window.clearTimeout(V.current), he !== "" && (V.current = window.setTimeout(() => le(""), 1e3));
      })(O), re && setTimeout(() => re.focus());
    };
    C.useEffect(() => () => window.clearTimeout(V.current), []), Ob();
    const q = C.useCallback((Y) => G.current === H.current?.side && oY(Y, H.current?.area), []);
    return /* @__PURE__ */ _.jsx(
      Hq,
      {
        scope: n,
        searchRef: T,
        onItemEnter: C.useCallback(
          (Y) => {
            q(Y) && Y.preventDefault();
          },
          [q]
        ),
        onItemLeave: C.useCallback(
          (Y) => {
            q(Y) || (P.current?.focus(), D(null));
          },
          [q]
        ),
        onTriggerLeave: C.useCallback(
          (Y) => {
            q(Y) && Y.preventDefault();
          },
          [q]
        ),
        pointerGraceTimerRef: $,
        onPointerGraceIntentChange: C.useCallback((Y) => {
          H.current = Y;
        }, []),
        children: /* @__PURE__ */ _.jsx(U, { ...z, children: /* @__PURE__ */ _.jsx(
          _p,
          {
            asChild: !0,
            trapped: i,
            onMountAutoFocus: De(a, (Y) => {
              Y.preventDefault(), P.current?.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: s,
            children: /* @__PURE__ */ _.jsx(
              Sp,
              {
                asChild: !0,
                disableOutsidePointerEvents: u,
                onEscapeKeyDown: d,
                onPointerDownOutside: h,
                onFocusOutside: p,
                onInteractOutside: g,
                onDismiss: y,
                children: /* @__PURE__ */ _.jsx(
                  Nq,
                  {
                    asChild: !0,
                    ...k,
                    dir: S.dir,
                    orientation: "vertical",
                    loop: r,
                    currentTabStopId: N,
                    onCurrentTabStopIdChange: D,
                    onEntryFocus: De(f, (Y) => {
                      S.isUsingKeyboardRef.current || Y.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ _.jsx(
                      E2,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": tM(E.open),
                        "data-radix-menu-content": "",
                        dir: S.dir,
                        ...A,
                        ...x,
                        ref: F,
                        style: { outline: "none", ...x.style },
                        onKeyDown: De(x.onKeyDown, (Y) => {
                          const W = Y.target.closest("[data-radix-menu-content]") === Y.currentTarget, Z = Y.ctrlKey || Y.altKey || Y.metaKey, I = Y.key.length === 1;
                          W && (Y.key === "Tab" && Y.preventDefault(), !Z && I && B(Y.key));
                          const ie = P.current;
                          if (Y.target !== ie || !Pq.includes(Y.key)) return;
                          Y.preventDefault();
                          const re = R().filter((le) => !le.disabled).map((le) => le.ref.current);
                          M2.includes(Y.key) && re.reverse(), tY(re);
                        }),
                        onBlur: De(e.onBlur, (Y) => {
                          Y.currentTarget.contains(Y.target) || (window.clearTimeout(V.current), T.current = "");
                        }),
                        onPointerMove: De(
                          e.onPointerMove,
                          bc((Y) => {
                            const O = Y.target, W = j.current !== Y.clientX;
                            if (Y.currentTarget.contains(O) && W) {
                              const Z = Y.clientX > j.current ? "right" : "left";
                              G.current = Z, j.current = Y.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
L2.displayName = gr;
var Yq = "MenuGroup", c1 = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ _.jsx(vt.div, { role: "group", ...r, ref: t });
  }
);
c1.displayName = Yq;
var Gq = "MenuLabel", F2 = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ _.jsx(vt.div, { ...r, ref: t });
  }
);
F2.displayName = Gq;
var Lh = "MenuItem", yk = "menu.itemSelect", jp = C.forwardRef(
  (e, t) => {
    const { disabled: n = !1, onSelect: r, ...i } = e, a = C.useRef(null), s = qc(Lh, e.__scopeMenu), u = l1(Lh, e.__scopeMenu), f = Et(t, a), d = C.useRef(!1), h = () => {
      const p = a.current;
      if (!n && p) {
        const g = new CustomEvent(yk, { bubbles: !0, cancelable: !0 });
        p.addEventListener(yk, (y) => r?.(y), { once: !0 }), VO(p, g), g.defaultPrevented ? d.current = !1 : s.onClose();
      }
    };
    return /* @__PURE__ */ _.jsx(
      B2,
      {
        ...i,
        ref: f,
        disabled: n,
        onClick: De(e.onClick, h),
        onPointerDown: (p) => {
          e.onPointerDown?.(p), d.current = !0;
        },
        onPointerUp: De(e.onPointerUp, (p) => {
          d.current || p.currentTarget?.click();
        }),
        onKeyDown: De(e.onKeyDown, (p) => {
          const g = u.searchRef.current !== "";
          n || g && p.key === " " || Pv.includes(p.key) && (p.currentTarget.click(), p.preventDefault());
        })
      }
    );
  }
);
jp.displayName = Lh;
var B2 = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, disabled: r = !1, textValue: i, ...a } = e, s = l1(Lh, n), u = P2(n), f = C.useRef(null), d = Et(t, f), [h, p] = C.useState(!1), [g, y] = C.useState("");
    return C.useEffect(() => {
      const b = f.current;
      b && y((b.textContent ?? "").trim());
    }, [a.children]), /* @__PURE__ */ _.jsx(
      vc.ItemSlot,
      {
        scope: n,
        disabled: r,
        textValue: i ?? g,
        children: /* @__PURE__ */ _.jsx(Mq, { asChild: !0, ...u, focusable: !r, children: /* @__PURE__ */ _.jsx(
          vt.div,
          {
            role: "menuitem",
            "data-highlighted": h ? "" : void 0,
            "aria-disabled": r || void 0,
            "data-disabled": r ? "" : void 0,
            ...a,
            ref: d,
            onPointerMove: De(
              e.onPointerMove,
              bc((b) => {
                r ? s.onItemLeave(b) : (s.onItemEnter(b), b.defaultPrevented || b.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: De(
              e.onPointerLeave,
              bc((b) => s.onItemLeave(b))
            ),
            onFocus: De(e.onFocus, () => p(!0)),
            onBlur: De(e.onBlur, () => p(!1))
          }
        ) })
      }
    );
  }
), Xq = "MenuCheckboxItem", $2 = C.forwardRef(
  (e, t) => {
    const { checked: n = !1, onCheckedChange: r, ...i } = e;
    return /* @__PURE__ */ _.jsx(Y2, { scope: e.__scopeMenu, checked: n, children: /* @__PURE__ */ _.jsx(
      jp,
      {
        role: "menuitemcheckbox",
        "aria-checked": Fh(n) ? "mixed" : n,
        ...i,
        ref: t,
        "data-state": h1(n),
        onSelect: De(
          i.onSelect,
          () => r?.(Fh(n) ? !0 : !n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
$2.displayName = Xq;
var H2 = "MenuRadioGroup", [Wq, Kq] = Fa(
  H2,
  { value: void 0, onValueChange: () => {
  } }
), V2 = C.forwardRef(
  (e, t) => {
    const { value: n, onValueChange: r, ...i } = e, a = yr(r);
    return /* @__PURE__ */ _.jsx(Wq, { scope: e.__scopeMenu, value: n, onValueChange: a, children: /* @__PURE__ */ _.jsx(c1, { ...i, ref: t }) });
  }
);
V2.displayName = H2;
var U2 = "MenuRadioItem", q2 = C.forwardRef(
  (e, t) => {
    const { value: n, ...r } = e, i = Kq(U2, e.__scopeMenu), a = n === i.value;
    return /* @__PURE__ */ _.jsx(Y2, { scope: e.__scopeMenu, checked: a, children: /* @__PURE__ */ _.jsx(
      jp,
      {
        role: "menuitemradio",
        "aria-checked": a,
        ...r,
        ref: t,
        "data-state": h1(a),
        onSelect: De(
          r.onSelect,
          () => i.onValueChange?.(n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
q2.displayName = U2;
var f1 = "MenuItemIndicator", [Y2, Zq] = Fa(
  f1,
  { checked: !1 }
), G2 = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, forceMount: r, ...i } = e, a = Zq(f1, n);
    return /* @__PURE__ */ _.jsx(
      Xi,
      {
        present: r || Fh(a.checked) || a.checked === !0,
        children: /* @__PURE__ */ _.jsx(
          vt.span,
          {
            ...i,
            ref: t,
            "data-state": h1(a.checked)
          }
        )
      }
    );
  }
);
G2.displayName = f1;
var Qq = "MenuSeparator", X2 = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ _.jsx(
      vt.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: t
      }
    );
  }
);
X2.displayName = Qq;
var Jq = "MenuArrow", W2 = C.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, i = Uc(n);
    return /* @__PURE__ */ _.jsx(C2, { ...i, ...r, ref: t });
  }
);
W2.displayName = Jq;
var d1 = "MenuSub", [eY, K2] = Fa(d1), Z2 = (e) => {
  const { __scopeMenu: t, children: n, open: r = !1, onOpenChange: i } = e, a = Ba(d1, t), s = Uc(t), [u, f] = C.useState(null), [d, h] = C.useState(null), p = yr(i);
  return C.useEffect(() => (a.open === !1 && p(!1), () => p(!1)), [a.open, p]), /* @__PURE__ */ _.jsx(o1, { ...s, children: /* @__PURE__ */ _.jsx(
    z2,
    {
      scope: t,
      open: r,
      onOpenChange: p,
      content: d,
      onContentChange: h,
      children: /* @__PURE__ */ _.jsx(
        eY,
        {
          scope: t,
          contentId: Li(),
          triggerId: Li(),
          trigger: u,
          onTriggerChange: f,
          children: n
        }
      )
    }
  ) });
};
Z2.displayName = d1;
var qu = "MenuSubTrigger", Q2 = C.forwardRef(
  (e, t) => {
    const n = Ba(qu, e.__scopeMenu), r = qc(qu, e.__scopeMenu), i = K2(qu, e.__scopeMenu), a = l1(qu, e.__scopeMenu), s = C.useRef(null), { pointerGraceTimerRef: u, onPointerGraceIntentChange: f } = a, d = { __scopeMenu: e.__scopeMenu }, h = C.useCallback(() => {
      s.current && window.clearTimeout(s.current), s.current = null;
    }, []);
    return C.useEffect(() => h, [h]), C.useEffect(() => {
      const p = u.current;
      return () => {
        window.clearTimeout(p), f(null);
      };
    }, [u, f]), /* @__PURE__ */ _.jsx(s1, { asChild: !0, ...d, children: /* @__PURE__ */ _.jsx(
      B2,
      {
        id: i.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": n.open,
        "aria-controls": i.contentId,
        "data-state": tM(n.open),
        ...e,
        ref: wp(t, i.onTriggerChange),
        onClick: (p) => {
          e.onClick?.(p), !(e.disabled || p.defaultPrevented) && (p.currentTarget.focus(), n.open || n.onOpenChange(!0));
        },
        onPointerMove: De(
          e.onPointerMove,
          bc((p) => {
            a.onItemEnter(p), !p.defaultPrevented && !e.disabled && !n.open && !s.current && (a.onPointerGraceIntentChange(null), s.current = window.setTimeout(() => {
              n.onOpenChange(!0), h();
            }, 100));
          })
        ),
        onPointerLeave: De(
          e.onPointerLeave,
          bc((p) => {
            h();
            const g = n.content?.getBoundingClientRect();
            if (g) {
              const y = n.content?.dataset.side, b = y === "right", x = b ? -5 : 5, E = g[b ? "left" : "right"], S = g[b ? "right" : "left"];
              a.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: p.clientX + x, y: p.clientY },
                  { x: E, y: g.top },
                  { x: S, y: g.top },
                  { x: S, y: g.bottom },
                  { x: E, y: g.bottom }
                ],
                side: y
              }), window.clearTimeout(u.current), u.current = window.setTimeout(
                () => a.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (a.onTriggerLeave(p), p.defaultPrevented) return;
              a.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: De(e.onKeyDown, (p) => {
          const g = a.searchRef.current !== "";
          e.disabled || g && p.key === " " || zq[r.dir].includes(p.key) && (n.onOpenChange(!0), n.content?.focus(), p.preventDefault());
        })
      }
    ) });
  }
);
Q2.displayName = qu;
var J2 = "MenuSubContent", eM = C.forwardRef(
  (e, t) => {
    const n = I2(gr, e.__scopeMenu), { forceMount: r = n.forceMount, ...i } = e, a = Ba(gr, e.__scopeMenu), s = qc(gr, e.__scopeMenu), u = K2(J2, e.__scopeMenu), f = C.useRef(null), d = Et(t, f);
    return /* @__PURE__ */ _.jsx(vc.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ _.jsx(Xi, { present: r || a.open, children: /* @__PURE__ */ _.jsx(vc.Slot, { scope: e.__scopeMenu, children: /* @__PURE__ */ _.jsx(
      u1,
      {
        id: u.contentId,
        "aria-labelledby": u.triggerId,
        ...i,
        ref: d,
        align: "start",
        side: s.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (h) => {
          s.isUsingKeyboardRef.current && f.current?.focus(), h.preventDefault();
        },
        onCloseAutoFocus: (h) => h.preventDefault(),
        onFocusOutside: De(e.onFocusOutside, (h) => {
          h.target !== u.trigger && a.onOpenChange(!1);
        }),
        onEscapeKeyDown: De(e.onEscapeKeyDown, (h) => {
          s.onClose(), h.preventDefault();
        }),
        onKeyDown: De(e.onKeyDown, (h) => {
          const p = h.currentTarget.contains(h.target), g = jq[s.dir].includes(h.key);
          p && g && (a.onOpenChange(!1), u.trigger?.focus(), h.preventDefault());
        })
      }
    ) }) }) });
  }
);
eM.displayName = J2;
function tM(e) {
  return e ? "open" : "closed";
}
function Fh(e) {
  return e === "indeterminate";
}
function h1(e) {
  return Fh(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function tY(e) {
  const t = document.activeElement;
  for (const n of e)
    if (n === t || (n.focus(), document.activeElement !== t)) return;
}
function nY(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
function rY(e, t, n) {
  const i = t.length > 1 && Array.from(t).every((d) => d === t[0]) ? t[0] : t, a = n ? e.indexOf(n) : -1;
  let s = nY(e, Math.max(a, 0));
  i.length === 1 && (s = s.filter((d) => d !== n));
  const f = s.find(
    (d) => d.toLowerCase().startsWith(i.toLowerCase())
  );
  return f !== n ? f : void 0;
}
function iY(e, t) {
  const { x: n, y: r } = e;
  let i = !1;
  for (let a = 0, s = t.length - 1; a < t.length; s = a++) {
    const u = t[a].x, f = t[a].y, d = t[s].x, h = t[s].y;
    f > r != h > r && n < (d - u) * (r - f) / (h - f) + u && (i = !i);
  }
  return i;
}
function oY(e, t) {
  if (!t) return !1;
  const n = { x: e.clientX, y: e.clientY };
  return iY(n, t);
}
function bc(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
var aY = j2, sY = s1, lY = L2, uY = c1, cY = F2, fY = jp, dY = $2, hY = V2, pY = q2, mY = G2, gY = X2, yY = W2, vY = Z2, bY = Q2, xY = eM, p1 = "DropdownMenu", [wY, Mue] = Go(
  p1,
  [D2]
), _n = D2(), [SY, nM] = wY(p1), rM = (e) => {
  const {
    __scopeDropdownMenu: t,
    children: n,
    dir: r,
    open: i,
    defaultOpen: a,
    onOpenChange: s,
    modal: u = !0
  } = e, f = _n(t), d = C.useRef(null), [h = !1, p] = yl({
    prop: i,
    defaultProp: a,
    onChange: s
  });
  return /* @__PURE__ */ _.jsx(
    SY,
    {
      scope: t,
      triggerId: Li(),
      triggerRef: d,
      contentId: Li(),
      open: h,
      onOpenChange: p,
      onOpenToggle: C.useCallback(() => p((g) => !g), [p]),
      modal: u,
      children: /* @__PURE__ */ _.jsx(aY, { ...f, open: h, onOpenChange: p, dir: r, modal: u, children: n })
    }
  );
};
rM.displayName = p1;
var iM = "DropdownMenuTrigger", oM = C.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, disabled: r = !1, ...i } = e, a = nM(iM, n), s = _n(n);
    return /* @__PURE__ */ _.jsx(sY, { asChild: !0, ...s, children: /* @__PURE__ */ _.jsx(
      vt.button,
      {
        type: "button",
        id: a.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": a.open,
        "aria-controls": a.open ? a.contentId : void 0,
        "data-state": a.open ? "open" : "closed",
        "data-disabled": r ? "" : void 0,
        disabled: r,
        ...i,
        ref: wp(t, a.triggerRef),
        onPointerDown: De(e.onPointerDown, (u) => {
          !r && u.button === 0 && u.ctrlKey === !1 && (a.onOpenToggle(), a.open || u.preventDefault());
        }),
        onKeyDown: De(e.onKeyDown, (u) => {
          r || (["Enter", " "].includes(u.key) && a.onOpenToggle(), u.key === "ArrowDown" && a.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(u.key) && u.preventDefault());
        })
      }
    ) });
  }
);
oM.displayName = iM;
var aM = "DropdownMenuContent", sM = C.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = nM(aM, n), a = _n(n), s = C.useRef(!1);
    return /* @__PURE__ */ _.jsx(
      lY,
      {
        id: i.contentId,
        "aria-labelledby": i.triggerId,
        ...a,
        ...r,
        ref: t,
        onCloseAutoFocus: De(e.onCloseAutoFocus, (u) => {
          s.current || i.triggerRef.current?.focus(), s.current = !1, u.preventDefault();
        }),
        onInteractOutside: De(e.onInteractOutside, (u) => {
          const f = u.detail.originalEvent, d = f.button === 0 && f.ctrlKey === !0, h = f.button === 2 || d;
          (!i.modal || h) && (s.current = !0);
        }),
        style: {
          ...e.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
sM.displayName = aM;
var _Y = "DropdownMenuGroup", lM = C.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = _n(n);
    return /* @__PURE__ */ _.jsx(uY, { ...i, ...r, ref: t });
  }
);
lM.displayName = _Y;
var EY = "DropdownMenuLabel", CY = C.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = _n(n);
    return /* @__PURE__ */ _.jsx(cY, { ...i, ...r, ref: t });
  }
);
CY.displayName = EY;
var kY = "DropdownMenuItem", uM = C.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = _n(n);
    return /* @__PURE__ */ _.jsx(fY, { ...i, ...r, ref: t });
  }
);
uM.displayName = kY;
var AY = "DropdownMenuCheckboxItem", TY = C.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = _n(n);
  return /* @__PURE__ */ _.jsx(dY, { ...i, ...r, ref: t });
});
TY.displayName = AY;
var RY = "DropdownMenuRadioGroup", cM = C.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = _n(n);
  return /* @__PURE__ */ _.jsx(hY, { ...i, ...r, ref: t });
});
cM.displayName = RY;
var OY = "DropdownMenuRadioItem", fM = C.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = _n(n);
  return /* @__PURE__ */ _.jsx(pY, { ...i, ...r, ref: t });
});
fM.displayName = OY;
var NY = "DropdownMenuItemIndicator", MY = C.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = _n(n);
  return /* @__PURE__ */ _.jsx(mY, { ...i, ...r, ref: t });
});
MY.displayName = NY;
var DY = "DropdownMenuSeparator", PY = C.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = _n(n);
  return /* @__PURE__ */ _.jsx(gY, { ...i, ...r, ref: t });
});
PY.displayName = DY;
var zY = "DropdownMenuArrow", jY = C.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, i = _n(n);
    return /* @__PURE__ */ _.jsx(yY, { ...i, ...r, ref: t });
  }
);
jY.displayName = zY;
var IY = (e) => {
  const { __scopeDropdownMenu: t, children: n, open: r, onOpenChange: i, defaultOpen: a } = e, s = _n(t), [u = !1, f] = yl({
    prop: r,
    defaultProp: a,
    onChange: i
  });
  return /* @__PURE__ */ _.jsx(vY, { ...s, open: u, onOpenChange: f, children: n });
}, LY = "DropdownMenuSubTrigger", dM = C.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = _n(n);
  return /* @__PURE__ */ _.jsx(bY, { ...i, ...r, ref: t });
});
dM.displayName = LY;
var FY = "DropdownMenuSubContent", hM = C.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, i = _n(n);
  return /* @__PURE__ */ _.jsx(
    xY,
    {
      ...i,
      ...r,
      ref: t,
      style: {
        ...e.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
hM.displayName = FY;
var pM = rM, mM = oM, gM = sM, yM = lM, zo = uM, BY = cM, $Y = fM, HY = IY, VY = dM, UY = hM;
const zv = {
  xxs: 0,
  xs: 320,
  s: 480,
  m: 768,
  l: 960,
  xl: 1280,
  xxl: 1920
}, vM = C.createContext(void 0), qY = C.forwardRef((e, t) => {
  const { className: n, children: r, ...i } = e, [a, s] = C.useState("m"), [u, f] = C.useState(0), [d, h] = C.useState(0), p = C.useRef(null);
  C.useImperativeHandle(
    t,
    () => p.current,
    []
  );
  const g = C.useCallback((y) => {
    const b = y.width, x = y.height;
    let E = "xxs";
    Object.entries(zv).forEach(([S, A]) => {
      b >= A && (E = S);
    }), s((S) => S !== E ? E : S), f(b), h(x);
  }, []);
  return C.useEffect(() => {
    const y = p.current;
    if (!y)
      return;
    const b = new ResizeObserver((x) => {
      for (let E of x)
        g(E.contentRect);
    });
    return b.observe(y), g(y.getBoundingClientRect()), () => {
      b.disconnect();
    };
  }, []), /* @__PURE__ */ _.jsx(vM.Provider, { value: { wKey: a, w: u, h: d }, children: /* @__PURE__ */ _.jsx(
    "div",
    {
      ref: p,
      className: `size-context w-${a} ${n || ""}`.trim(),
      ...i,
      children: r
    }
  ) });
}), YY = () => {
  const e = C.useContext(vM);
  if (!e)
    throw new Error(
      "useSizeContext must be used within a SizeContextContainerContext"
    );
  return e;
}, GY = (e, t) => e == t ? !1 : e == "" ? !0 : zv[e] < zv[t], XY = (e) => GY(YY().wKey, e), Ks = ({
  direction: e,
  className: t = "",
  children: n,
  wrap: r = !1,
  grow: i = !1,
  ...a
}) => {
  const s = "float-container";
  let u = "";
  typeof e == "string" ? u = `direction-${e} ` : typeof e == "object" && e !== null && Object.entries(e).forEach(([h, p]) => {
    h === "" ? u += `direction-${p} ` : u += `${h}-direction-${p} `;
  });
  let f = "";
  typeof i == "boolean" ? f = i ? "grow " : "" : typeof i == "object" && i !== null && Object.entries(i).forEach(([h, p]) => {
    h === "" ? f += p ? "grow " : "no-grow" : f += p ? `${h}-grow ` : `${h}-no-grow`;
  }), u += f, r && (u += "flex-wrap "), u = u.trim();
  const d = `${s} ${u} ${t}`.trim();
  return /* @__PURE__ */ _.jsx("div", { className: d, ...a, children: n });
}, bM = ({
  direction: e,
  expanded: t = !0,
  children: n,
  className: r,
  maxSize: i = "18.75rem",
  expanderSize: a = "2rem",
  containerStyle: s,
  style: u,
  containerClassName: f,
  onExpandChange: d,
  ...h
}) => {
  const p = {
    up: Rv,
    down: lk,
    left: sk,
    right: Tv
  }[e], g = {
    up: lk,
    down: Rv,
    left: Tv,
    right: sk
  }[e], [y, b] = C.useState(t), x = (F) => {
    y !== F && (b(F), d && d(F));
  }, E = `${e} ${y ? "expanded" : "collapsed"}`, S = e === "right" || e === "left" ? { width: y ? i : a } : { height: y ? i : a }, A = e === "right" || e === "left" ? { width: y ? i : 0 } : { height: y ? i : 0 }, k = e === "right" || e === "left" ? { width: a } : { height: a }, R = /* @__PURE__ */ _.jsx(
    "div",
    {
      className: `expanding_container_content ${E} ${r || ""}`.trim(),
      style: { ...u, ...A },
      ...h,
      children: n
    }
  ), N = /* @__PURE__ */ _.jsx(
    "div",
    {
      className: `expanding_container_expander ${E}`,
      onClick: () => x(!y),
      style: k,
      children: y ? /* @__PURE__ */ _.jsx(g, {}) : /* @__PURE__ */ _.jsx(p, {})
    }
  ), D = e === "right" || e === "down" ? R : N, P = e === "left" || e === "up" ? R : N;
  return /* @__PURE__ */ _.jsxs(
    "div",
    {
      className: `expanding_container ${E} ${f || ""}`,
      style: { ...s, ...S },
      children: [
        D,
        P
      ]
    }
  );
}, WY = ({
  trigger: e,
  setOpen: t,
  open: n
}) => {
  const [r, i] = C.useState(""), a = C.useContext(Xe);
  return a.options.useWorkerManager ? /* @__PURE__ */ _.jsxs(
    bl,
    {
      setOpen: t,
      open: n,
      trigger: e,
      title: "New Worker",
      description: "Create a new worker",
      children: [
        /* @__PURE__ */ _.jsxs("div", { children: [
          "Name:",
          /* @__PURE__ */ _.jsx("br", {}),
          /* @__PURE__ */ _.jsx(
            "input",
            {
              className: "styledinput",
              onChange: (s) => {
                i(s.currentTarget.value);
              },
              value: r
            }
          )
        ] }),
        /* @__PURE__ */ _.jsx("div", { children: r && /* @__PURE__ */ _.jsx("div", { children: /* @__PURE__ */ _.jsx(
          "button",
          {
            className: "styledbtn",
            onClick: () => {
              a.workermanager?.new_worker({
                name: r
                // reference: reference.uuid,
                // copyLib,
                // copyNS,
              }), t(!1);
            },
            children: "Create"
          }
        ) }) })
      ]
    }
  ) : null;
}, KY = ({
  trigger: e,
  setOpen: t,
  open: n
}) => {
  const r = C.useContext(Xe), [i, a] = C.useState(!1), s = r.workers(), u = r.worker?.uuid, f = (u ? s[u]?.name : void 0) || u || "worker", d = async () => {
    if (!r.worker) return;
    const h = await r.worker.export({ withFiles: i });
    XB(h, f + ".fnw", "application/zip"), t(!1);
  };
  return /* @__PURE__ */ _.jsx(
    bl,
    {
      setOpen: t,
      open: n,
      trigger: e,
      title: "Export Worker",
      description: "Export the worker as a .fnw file",
      children: /* @__PURE__ */ _.jsxs("div", { children: [
        /* @__PURE__ */ _.jsxs("div", { children: [
          /* @__PURE__ */ _.jsx(
            "input",
            {
              type: "checkbox",
              className: "styledcheckbox",
              checked: i,
              onChange: (h) => {
                a(h.currentTarget.checked);
              }
            }
          ),
          "Include Files"
        ] }),
        /* @__PURE__ */ _.jsx("button", { className: "styledbtn", onClick: d, children: "Export" })
      ] })
    }
  );
}, ZY = () => {
  const t = C.useContext(Xe).progress_state();
  return /* @__PURE__ */ _.jsxs("div", { className: "statusbar", children: [
    /* @__PURE__ */ _.jsx(
      "span",
      {
        className: "statusbar-progressbar",
        style: { width: Math.min(100, 100 * t.progress) + "%" }
      }
    ),
    /* @__PURE__ */ _.jsx("span", { className: "statusbar-message", children: t.message })
  ] });
}, QY = () => {
  const e = C.useContext(Xe), t = e.workers(), [n, r] = C.useState(!1), [i, a] = C.useState(!1), s = (y) => {
    y !== "__select__" && e.workers && e.workermanager && t[y] && (!t[y].active && !window.confirm(
      "this is an inactive worker, selecting it will start it, continue?"
    ) || e.workermanager.set_active(y));
  }, u = async () => {
    if (!e.worker || !window.confirm(
      "Updateing the worker might replace the current nodespace, continue?"
    )) return;
    const b = await ZB(".fnw");
    e.worker.update_from_export(b);
  }, f = e.options.useWorkerManager && e.workermanager && e.workermanager.open || ev, d = f && Object.keys(t).length > 0, h = e.worker && e.worker.is_open, p = h && f;
  return f || h ? /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
    /* @__PURE__ */ _.jsxs(pM, { children: [
      /* @__PURE__ */ _.jsx(mM, { asChild: !0, children: /* @__PURE__ */ _.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ _.jsxs(Ks, { direction: "row", children: [
        "Worker ",
        /* @__PURE__ */ _.jsx(JN, {})
      ] }) }) }),
      /* @__PURE__ */ _.jsx(gM, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ _.jsxs(yM, { children: [
        d && /* @__PURE__ */ _.jsxs(HY, { children: [
          /* @__PURE__ */ _.jsx(VY, { className: "headermenuitem submenuitem", children: /* @__PURE__ */ _.jsxs(Ks, { direction: "row", children: [
            "Select",
            /* @__PURE__ */ _.jsx(Tv, {})
          ] }) }),
          /* @__PURE__ */ _.jsx(
            UY,
            {
              className: "headermenucontent funcnodescontainer",
              sideOffset: 2,
              alignOffset: -5,
              children: /* @__PURE__ */ _.jsx(
                BY,
                {
                  value: e.worker?.uuid,
                  onValueChange: (y) => {
                    s(y);
                  },
                  children: Object.keys(t).sort((y, b) => {
                    if (t[y].active && !t[b].active)
                      return -1;
                    if (!t[y].active && t[b].active)
                      return 1;
                    const x = t[y].name || y, E = t[b].name || b;
                    return x.localeCompare(E);
                  }).map((y) => /* @__PURE__ */ _.jsx(
                    $Y,
                    {
                      className: "headermenuitem workerselectoption" + (t[y]?.active ? " active" : " inactive") + " headermenuitem",
                      value: y,
                      disabled: y === e.worker?.uuid,
                      children: t[y]?.name || y
                    },
                    y
                  ))
                }
              )
            }
          )
        ] }),
        h && /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
          p && /* @__PURE__ */ _.jsx(
            zo,
            {
              className: "headermenuitem",
              onClick: () => {
                if (e.worker) {
                  if (!e.workermanager)
                    return e.logger.error("no workermanager");
                  e.workermanager?.restart_worker(
                    e.worker.uuid
                  );
                }
              },
              children: "Restart"
            }
          ),
          /* @__PURE__ */ _.jsx(
            zo,
            {
              className: "headermenuitem",
              onClick: () => {
                e.worker && e.worker.stop();
              },
              children: "Stop"
            }
          ),
          /* @__PURE__ */ _.jsx(
            zo,
            {
              className: "headermenuitem",
              onClick: () => a(!0),
              children: "Export"
            }
          ),
          /* @__PURE__ */ _.jsx(
            zo,
            {
              className: "headermenuitem",
              onClick: u,
              children: "Update"
            }
          )
        ] }),
        f && /* @__PURE__ */ _.jsx(_.Fragment, { children: /* @__PURE__ */ _.jsx(
          zo,
          {
            className: "headermenuitem",
            onClick: () => r(!0),
            children: "New"
          }
        ) })
      ] }) })
    ] }),
    /* @__PURE__ */ _.jsx(
      WY,
      {
        open: n,
        setOpen: r
      }
    ),
    /* @__PURE__ */ _.jsx(
      KY,
      {
        open: i,
        setOpen: a
      }
    )
  ] }) : null;
}, JY = () => {
  const e = C.useContext(Xe), t = () => {
    window.confirm("Are you sure you want to start a new flow?") && e.worker?.clear();
  }, n = async () => {
    const i = await e.worker?.save();
    if (!i) return;
    const a = new Blob([JSON.stringify(i)], {
      type: "application/json"
    }), s = URL.createObjectURL(a), u = document.createElement("a");
    u.href = s, u.download = "flow.json", u.click(), URL.revokeObjectURL(s), u.remove();
  }, r = async () => {
    const i = document.createElement("input");
    i.type = "file", i.accept = ".json", i.onchange = async (a) => {
      const s = a.target.files?.[0];
      if (!s) return;
      const u = new FileReader();
      u.onload = async (f) => {
        const d = f.target?.result;
        if (!d) return;
        const h = JSON.parse(d);
        await e.worker?.load(h);
      }, u.readAsText(s);
    }, i.click();
  };
  return /* @__PURE__ */ _.jsx(_.Fragment, { children: /* @__PURE__ */ _.jsxs(pM, { children: [
    /* @__PURE__ */ _.jsx(mM, { asChild: !0, children: /* @__PURE__ */ _.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ _.jsxs(Ks, { direction: "row", children: [
      "Nodespace ",
      /* @__PURE__ */ _.jsx(JN, {})
    ] }) }) }),
    /* @__PURE__ */ _.jsx(gM, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ _.jsxs(yM, { children: [
      /* @__PURE__ */ _.jsx(zo, { className: "headermenuitem", onClick: t, children: "New" }),
      /* @__PURE__ */ _.jsx(zo, { className: "headermenuitem", onClick: n, children: "Save" }),
      /* @__PURE__ */ _.jsx(zo, { className: "headermenuitem", onClick: r, children: "Load" })
    ] }) })
  ] }) });
}, eG = ({ ...e }) => {
  const t = C.useContext(Xe), n = t.workerstate();
  return Object.keys(e).length > 0 && t.logger.debug("headerprops", e), /* @__PURE__ */ _.jsxs(Ks, { className: "funcnodesreactflowheader", direction: "row", wrap: !0, children: [
    /* @__PURE__ */ _.jsx(
      Ks,
      {
        className: "headerelement m-w-6",
        grow: {
          "": !0,
          m: !1
        },
        children: /* @__PURE__ */ _.jsx(ZY, {})
      }
    ),
    (e.showmenu || ev) && /* @__PURE__ */ _.jsxs(Ks, { direction: "row", wrap: !0, children: [
      /* @__PURE__ */ _.jsx("div", { className: "headerelement", children: /* @__PURE__ */ _.jsx(QY, {}) }),
      (t.worker && n.is_open || ev) && /* @__PURE__ */ _.jsx("div", { className: "headerelement", children: /* @__PURE__ */ _.jsx(JY, {}) })
    ] })
  ] });
};
function tG(e, t) {
  const n = {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const nG = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, rG = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, iG = {};
function vk(e, t) {
  return (iG.jsx ? rG : nG).test(e);
}
const oG = /[ \t\n\f\r]/g;
function aG(e) {
  return typeof e == "object" ? e.type === "text" ? bk(e.value) : !1 : bk(e);
}
function bk(e) {
  return e.replace(oG, "") === "";
}
class Yc {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(t, n, r) {
    this.normal = n, this.property = t, r && (this.space = r);
  }
}
Yc.prototype.normal = {};
Yc.prototype.property = {};
Yc.prototype.space = void 0;
function xM(e, t) {
  const n = {}, r = {};
  for (const i of e)
    Object.assign(n, i.property), Object.assign(r, i.normal);
  return new Yc(n, r, t);
}
function jv(e) {
  return e.toLowerCase();
}
class In {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(t, n) {
    this.attribute = n, this.property = t;
  }
}
In.prototype.attribute = "";
In.prototype.booleanish = !1;
In.prototype.boolean = !1;
In.prototype.commaOrSpaceSeparated = !1;
In.prototype.commaSeparated = !1;
In.prototype.defined = !1;
In.prototype.mustUseProperty = !1;
In.prototype.number = !1;
In.prototype.overloadedBoolean = !1;
In.prototype.property = "";
In.prototype.spaceSeparated = !1;
In.prototype.space = void 0;
let sG = 0;
const Fe = $a(), Ht = $a(), wM = $a(), ge = $a(), yt = $a(), Zs = $a(), Gn = $a();
function $a() {
  return 2 ** ++sG;
}
const Iv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Fe,
  booleanish: Ht,
  commaOrSpaceSeparated: Gn,
  commaSeparated: Zs,
  number: ge,
  overloadedBoolean: wM,
  spaceSeparated: yt
}, Symbol.toStringTag, { value: "Module" })), oy = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(Iv)
);
class m1 extends In {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(t, n, r, i) {
    let a = -1;
    if (super(t, n), xk(this, "space", i), typeof r == "number")
      for (; ++a < oy.length; ) {
        const s = oy[a];
        xk(this, oy[a], (r & Iv[s]) === Iv[s]);
      }
  }
}
m1.prototype.defined = !0;
function xk(e, t, n) {
  n && (e[t] = n);
}
function Sl(e) {
  const t = {}, n = {};
  for (const [r, i] of Object.entries(e.properties)) {
    const a = new m1(
      r,
      e.transform(e.attributes || {}, r),
      i,
      e.space
    );
    e.mustUseProperty && e.mustUseProperty.includes(r) && (a.mustUseProperty = !0), t[r] = a, n[jv(r)] = r, n[jv(a.attribute)] = r;
  }
  return new Yc(t, n, e.space);
}
const SM = Sl({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: Ht,
    ariaAutoComplete: null,
    ariaBusy: Ht,
    ariaChecked: Ht,
    ariaColCount: ge,
    ariaColIndex: ge,
    ariaColSpan: ge,
    ariaControls: yt,
    ariaCurrent: null,
    ariaDescribedBy: yt,
    ariaDetails: null,
    ariaDisabled: Ht,
    ariaDropEffect: yt,
    ariaErrorMessage: null,
    ariaExpanded: Ht,
    ariaFlowTo: yt,
    ariaGrabbed: Ht,
    ariaHasPopup: null,
    ariaHidden: Ht,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: yt,
    ariaLevel: ge,
    ariaLive: null,
    ariaModal: Ht,
    ariaMultiLine: Ht,
    ariaMultiSelectable: Ht,
    ariaOrientation: null,
    ariaOwns: yt,
    ariaPlaceholder: null,
    ariaPosInSet: ge,
    ariaPressed: Ht,
    ariaReadOnly: Ht,
    ariaRelevant: null,
    ariaRequired: Ht,
    ariaRoleDescription: yt,
    ariaRowCount: ge,
    ariaRowIndex: ge,
    ariaRowSpan: ge,
    ariaSelected: Ht,
    ariaSetSize: ge,
    ariaSort: null,
    ariaValueMax: ge,
    ariaValueMin: ge,
    ariaValueNow: ge,
    ariaValueText: null,
    role: null
  },
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  }
});
function _M(e, t) {
  return t in e ? e[t] : t;
}
function EM(e, t) {
  return _M(e, t.toLowerCase());
}
const lG = Sl({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Zs,
    acceptCharset: yt,
    accessKey: yt,
    action: null,
    allow: null,
    allowFullScreen: Fe,
    allowPaymentRequest: Fe,
    allowUserMedia: Fe,
    alt: null,
    as: null,
    async: Fe,
    autoCapitalize: null,
    autoComplete: yt,
    autoFocus: Fe,
    autoPlay: Fe,
    blocking: yt,
    capture: null,
    charSet: null,
    checked: Fe,
    cite: null,
    className: yt,
    cols: ge,
    colSpan: null,
    content: null,
    contentEditable: Ht,
    controls: Fe,
    controlsList: yt,
    coords: ge | Zs,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Fe,
    defer: Fe,
    dir: null,
    dirName: null,
    disabled: Fe,
    download: wM,
    draggable: Ht,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Fe,
    formTarget: null,
    headers: yt,
    height: ge,
    hidden: Fe,
    high: ge,
    href: null,
    hrefLang: null,
    htmlFor: yt,
    httpEquiv: yt,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: Fe,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Fe,
    itemId: null,
    itemProp: yt,
    itemRef: yt,
    itemScope: Fe,
    itemType: yt,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Fe,
    low: ge,
    manifest: null,
    max: null,
    maxLength: ge,
    media: null,
    method: null,
    min: null,
    minLength: ge,
    multiple: Fe,
    muted: Fe,
    name: null,
    nonce: null,
    noModule: Fe,
    noValidate: Fe,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Fe,
    optimum: ge,
    pattern: null,
    ping: yt,
    placeholder: null,
    playsInline: Fe,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: Fe,
    referrerPolicy: null,
    rel: yt,
    required: Fe,
    reversed: Fe,
    rows: ge,
    rowSpan: ge,
    sandbox: yt,
    scope: null,
    scoped: Fe,
    seamless: Fe,
    selected: Fe,
    shadowRootClonable: Fe,
    shadowRootDelegatesFocus: Fe,
    shadowRootMode: null,
    shape: null,
    size: ge,
    sizes: null,
    slot: null,
    span: ge,
    spellCheck: Ht,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: ge,
    step: null,
    style: null,
    tabIndex: ge,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Fe,
    useMap: null,
    value: Ht,
    width: ge,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: yt,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: ge,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: ge,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Fe,
    // Lists. Use CSS to reduce space between items instead
    declare: Fe,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: ge,
    // `<img>` and `<object>`
    leftMargin: ge,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: ge,
    // `<body>`
    marginWidth: ge,
    // `<body>`
    noResize: Fe,
    // `<frame>`
    noHref: Fe,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Fe,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Fe,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: ge,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: Ht,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: ge,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: ge,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Fe,
    disableRemotePlayback: Fe,
    prefix: null,
    property: null,
    results: ge,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: EM
}), uG = Sl({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: Gn,
    accentHeight: ge,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: ge,
    amplitude: ge,
    arabicForm: null,
    ascent: ge,
    attributeName: null,
    attributeType: null,
    azimuth: ge,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: ge,
    by: null,
    calcMode: null,
    capHeight: ge,
    className: yt,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: ge,
    diffuseConstant: ge,
    direction: null,
    display: null,
    dur: null,
    divisor: ge,
    dominantBaseline: null,
    download: Fe,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: ge,
    enableBackground: null,
    end: null,
    event: null,
    exponent: ge,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: ge,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Zs,
    g2: Zs,
    glyphName: Zs,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: ge,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: ge,
    horizOriginX: ge,
    horizOriginY: ge,
    id: null,
    ideographic: ge,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: ge,
    k: ge,
    k1: ge,
    k2: ge,
    k3: ge,
    k4: ge,
    kernelMatrix: Gn,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: ge,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: ge,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: ge,
    overlineThickness: ge,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: ge,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: yt,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: ge,
    pointsAtY: ge,
    pointsAtZ: ge,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Gn,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Gn,
    rev: Gn,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Gn,
    requiredFeatures: Gn,
    requiredFonts: Gn,
    requiredFormats: Gn,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: ge,
    specularExponent: ge,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: ge,
    strikethroughThickness: ge,
    string: null,
    stroke: null,
    strokeDashArray: Gn,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: ge,
    strokeOpacity: ge,
    strokeWidth: null,
    style: null,
    surfaceScale: ge,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Gn,
    tabIndex: ge,
    tableValues: null,
    target: null,
    targetX: ge,
    targetY: ge,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Gn,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: ge,
    underlineThickness: ge,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: ge,
    values: null,
    vAlphabetic: ge,
    vMathematical: ge,
    vectorEffect: null,
    vHanging: ge,
    vIdeographic: ge,
    version: null,
    vertAdvY: ge,
    vertOriginX: ge,
    vertOriginY: ge,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: ge,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: _M
}), CM = Sl({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  }
}), kM = Sl({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: EM
}), AM = Sl({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  }
}), cG = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, fG = /[A-Z]/g, wk = /-[a-z]/g, dG = /^data[-\w.:]+$/i;
function hG(e, t) {
  const n = jv(t);
  let r = t, i = In;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && dG.test(t)) {
    if (t.charAt(4) === "-") {
      const a = t.slice(5).replace(wk, mG);
      r = "data" + a.charAt(0).toUpperCase() + a.slice(1);
    } else {
      const a = t.slice(4);
      if (!wk.test(a)) {
        let s = a.replace(fG, pG);
        s.charAt(0) !== "-" && (s = "-" + s), t = "data" + s;
      }
    }
    i = m1;
  }
  return new i(r, t);
}
function pG(e) {
  return "-" + e.toLowerCase();
}
function mG(e) {
  return e.charAt(1).toUpperCase();
}
const gG = xM([SM, lG, CM, kM, AM], "html"), g1 = xM([SM, uG, CM, kM, AM], "svg");
function yG(e) {
  return e.join(" ").trim();
}
var Ns = {}, ay, Sk;
function vG() {
  if (Sk) return ay;
  Sk = 1;
  var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, t = /\n/g, n = /^\s*/, r = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, i = /^:\s*/, a = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, s = /^[;\s]*/, u = /^\s+|\s+$/g, f = `
`, d = "/", h = "*", p = "", g = "comment", y = "declaration";
  ay = function(x, E) {
    if (typeof x != "string")
      throw new TypeError("First argument must be a string");
    if (!x) return [];
    E = E || {};
    var S = 1, A = 1;
    function k(G) {
      var j = G.match(t);
      j && (S += j.length);
      var U = G.lastIndexOf(f);
      A = ~U ? G.length - U : A + G.length;
    }
    function R() {
      var G = { line: S, column: A };
      return function(j) {
        return j.position = new N(G), F(), j;
      };
    }
    function N(G) {
      this.start = G, this.end = { line: S, column: A }, this.source = E.source;
    }
    N.prototype.content = x;
    function D(G) {
      var j = new Error(
        E.source + ":" + S + ":" + A + ": " + G
      );
      if (j.reason = G, j.filename = E.source, j.line = S, j.column = A, j.source = x, !E.silent) throw j;
    }
    function P(G) {
      var j = G.exec(x);
      if (j) {
        var U = j[0];
        return k(U), x = x.slice(U.length), j;
      }
    }
    function F() {
      P(n);
    }
    function V(G) {
      var j;
      for (G = G || []; j = T(); )
        j !== !1 && G.push(j);
      return G;
    }
    function T() {
      var G = R();
      if (!(d != x.charAt(0) || h != x.charAt(1))) {
        for (var j = 2; p != x.charAt(j) && (h != x.charAt(j) || d != x.charAt(j + 1)); )
          ++j;
        if (j += 2, p === x.charAt(j - 1))
          return D("End of comment missing");
        var U = x.slice(2, j - 2);
        return A += 2, k(U), x = x.slice(j), A += 2, G({
          type: g,
          comment: U
        });
      }
    }
    function $() {
      var G = R(), j = P(r);
      if (j) {
        if (T(), !P(i)) return D("property missing ':'");
        var U = P(a), z = G({
          type: y,
          property: b(j[0].replace(e, p)),
          value: U ? b(U[0].replace(e, p)) : p
        });
        return P(s), z;
      }
    }
    function H() {
      var G = [];
      V(G);
      for (var j; j = $(); )
        j !== !1 && (G.push(j), V(G));
      return G;
    }
    return F(), H();
  };
  function b(x) {
    return x ? x.replace(u, p) : p;
  }
  return ay;
}
var _k;
function bG() {
  if (_k) return Ns;
  _k = 1;
  var e = Ns && Ns.__importDefault || function(r) {
    return r && r.__esModule ? r : { default: r };
  };
  Object.defineProperty(Ns, "__esModule", { value: !0 }), Ns.default = n;
  var t = e(vG());
  function n(r, i) {
    var a = null;
    if (!r || typeof r != "string")
      return a;
    var s = (0, t.default)(r), u = typeof i == "function";
    return s.forEach(function(f) {
      if (f.type === "declaration") {
        var d = f.property, h = f.value;
        u ? i(d, h, f) : h && (a = a || {}, a[d] = h);
      }
    }), a;
  }
  return Ns;
}
var Pu = {}, Ek;
function xG() {
  if (Ek) return Pu;
  Ek = 1, Object.defineProperty(Pu, "__esModule", { value: !0 }), Pu.camelCase = void 0;
  var e = /^--[a-zA-Z0-9_-]+$/, t = /-([a-z])/g, n = /^[^-]+$/, r = /^-(webkit|moz|ms|o|khtml)-/, i = /^-(ms)-/, a = function(d) {
    return !d || n.test(d) || e.test(d);
  }, s = function(d, h) {
    return h.toUpperCase();
  }, u = function(d, h) {
    return "".concat(h, "-");
  }, f = function(d, h) {
    return h === void 0 && (h = {}), a(d) ? d : (d = d.toLowerCase(), h.reactCompat ? d = d.replace(i, u) : d = d.replace(r, u), d.replace(t, s));
  };
  return Pu.camelCase = f, Pu;
}
var zu, Ck;
function wG() {
  if (Ck) return zu;
  Ck = 1;
  var e = zu && zu.__importDefault || function(i) {
    return i && i.__esModule ? i : { default: i };
  }, t = e(bG()), n = xG();
  function r(i, a) {
    var s = {};
    return !i || typeof i != "string" || (0, t.default)(i, function(u, f) {
      u && f && (s[(0, n.camelCase)(u, a)] = f);
    }), s;
  }
  return r.default = r, zu = r, zu;
}
var SG = wG();
const _G = /* @__PURE__ */ pl(SG), TM = RM("end"), y1 = RM("start");
function RM(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function EG(e) {
  const t = y1(e), n = TM(e);
  if (t && n)
    return { start: t, end: n };
}
function Ju(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? kk(e.position) : "start" in e || "end" in e ? kk(e) : "line" in e || "column" in e ? Lv(e) : "";
}
function Lv(e) {
  return Ak(e && e.line) + ":" + Ak(e && e.column);
}
function kk(e) {
  return Lv(e && e.start) + "-" + Lv(e && e.end);
}
function Ak(e) {
  return e && typeof e == "number" ? e : 1;
}
class mn extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let i = "", a = {}, s = !1;
    if (n && ("line" in n && "column" in n ? a = { place: n } : "start" in n && "end" in n ? a = { place: n } : "type" in n ? a = {
      ancestors: [n],
      place: n.position
    } : a = { ...n }), typeof t == "string" ? i = t : !a.cause && t && (s = !0, i = t.message, a.cause = t), !a.ruleId && !a.source && typeof r == "string") {
      const f = r.indexOf(":");
      f === -1 ? a.ruleId = r : (a.source = r.slice(0, f), a.ruleId = r.slice(f + 1));
    }
    if (!a.place && a.ancestors && a.ancestors) {
      const f = a.ancestors[a.ancestors.length - 1];
      f && (a.place = f.position);
    }
    const u = a.place && "start" in a.place ? a.place.start : a.place;
    this.ancestors = a.ancestors || void 0, this.cause = a.cause || void 0, this.column = u ? u.column : void 0, this.fatal = void 0, this.file, this.message = i, this.line = u ? u.line : void 0, this.name = Ju(a.place) || "1:1", this.place = a.place || void 0, this.reason = this.message, this.ruleId = a.ruleId || void 0, this.source = a.source || void 0, this.stack = s && a.cause && typeof a.cause.stack == "string" ? a.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
mn.prototype.file = "";
mn.prototype.name = "";
mn.prototype.reason = "";
mn.prototype.message = "";
mn.prototype.stack = "";
mn.prototype.column = void 0;
mn.prototype.line = void 0;
mn.prototype.ancestors = void 0;
mn.prototype.cause = void 0;
mn.prototype.fatal = void 0;
mn.prototype.place = void 0;
mn.prototype.ruleId = void 0;
mn.prototype.source = void 0;
const v1 = {}.hasOwnProperty, CG = /* @__PURE__ */ new Map(), kG = /[A-Z]/g, AG = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), TG = /* @__PURE__ */ new Set(["td", "th"]), OM = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function RG(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = IG(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = jG(n, t.jsx, t.jsxs);
  }
  const i = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? g1 : gG,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, a = NM(i, e, void 0);
  return a && typeof a != "string" ? a : i.create(
    e,
    i.Fragment,
    { children: a || void 0 },
    void 0
  );
}
function NM(e, t, n) {
  if (t.type === "element")
    return OG(e, t, n);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return NG(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return DG(e, t, n);
  if (t.type === "mdxjsEsm")
    return MG(e, t);
  if (t.type === "root")
    return PG(e, t, n);
  if (t.type === "text")
    return zG(e, t);
}
function OG(e, t, n) {
  const r = e.schema;
  let i = r;
  t.tagName.toLowerCase() === "svg" && r.space === "html" && (i = g1, e.schema = i), e.ancestors.push(t);
  const a = DM(e, t.tagName, !1), s = LG(e, t);
  let u = x1(e, t);
  return AG.has(t.tagName) && (u = u.filter(function(f) {
    return typeof f == "string" ? !aG(f) : !0;
  })), MM(e, s, a, t), b1(s, u), e.ancestors.pop(), e.schema = r, e.create(t, a, s, n);
}
function NG(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const r = t.data.estree.body[0];
    return r.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(r.expression);
  }
  xc(e, t.position);
}
function MG(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  xc(e, t.position);
}
function DG(e, t, n) {
  const r = e.schema;
  let i = r;
  t.name === "svg" && r.space === "html" && (i = g1, e.schema = i), e.ancestors.push(t);
  const a = t.name === null ? e.Fragment : DM(e, t.name, !0), s = FG(e, t), u = x1(e, t);
  return MM(e, s, a, t), b1(s, u), e.ancestors.pop(), e.schema = r, e.create(t, a, s, n);
}
function PG(e, t, n) {
  const r = {};
  return b1(r, x1(e, t)), e.create(t, e.Fragment, r, n);
}
function zG(e, t) {
  return t.value;
}
function MM(e, t, n, r) {
  typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
}
function b1(e, t) {
  if (t.length > 0) {
    const n = t.length > 1 ? t : t[0];
    n && (e.children = n);
  }
}
function jG(e, t, n) {
  return r;
  function r(i, a, s, u) {
    const d = Array.isArray(s.children) ? n : t;
    return u ? d(a, s, u) : d(a, s);
  }
}
function IG(e, t) {
  return n;
  function n(r, i, a, s) {
    const u = Array.isArray(a.children), f = y1(r);
    return t(
      i,
      a,
      s,
      u,
      {
        columnNumber: f ? f.column - 1 : void 0,
        fileName: e,
        lineNumber: f ? f.line : void 0
      },
      void 0
    );
  }
}
function LG(e, t) {
  const n = {};
  let r, i;
  for (i in t.properties)
    if (i !== "children" && v1.call(t.properties, i)) {
      const a = BG(e, i, t.properties[i]);
      if (a) {
        const [s, u] = a;
        e.tableCellAlignToStyle && s === "align" && typeof u == "string" && TG.has(t.tagName) ? r = u : n[s] = u;
      }
    }
  if (r) {
    const a = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    a[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n;
}
function FG(e, t) {
  const n = {};
  for (const r of t.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && e.evaluater) {
        const a = r.data.estree.body[0];
        a.type;
        const s = a.expression;
        s.type;
        const u = s.properties[0];
        u.type, Object.assign(
          n,
          e.evaluater.evaluateExpression(u.argument)
        );
      } else
        xc(e, t.position);
    else {
      const i = r.name;
      let a;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && e.evaluater) {
          const u = r.value.data.estree.body[0];
          u.type, a = e.evaluater.evaluateExpression(u.expression);
        } else
          xc(e, t.position);
      else
        a = r.value === null ? !0 : r.value;
      n[i] = /** @type {Props[keyof Props]} */
      a;
    }
  return n;
}
function x1(e, t) {
  const n = [];
  let r = -1;
  const i = e.passKeys ? /* @__PURE__ */ new Map() : CG;
  for (; ++r < t.children.length; ) {
    const a = t.children[r];
    let s;
    if (e.passKeys) {
      const f = a.type === "element" ? a.tagName : a.type === "mdxJsxFlowElement" || a.type === "mdxJsxTextElement" ? a.name : void 0;
      if (f) {
        const d = i.get(f) || 0;
        s = f + "-" + d, i.set(f, d + 1);
      }
    }
    const u = NM(e, a, s);
    u !== void 0 && n.push(u);
  }
  return n;
}
function BG(e, t, n) {
  const r = hG(e.schema, t);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r.commaSeparated ? tG(n) : yG(n)), r.property === "style") {
      let i = typeof n == "object" ? n : $G(e, String(n));
      return e.stylePropertyNameCase === "css" && (i = HG(i)), ["style", i];
    }
    return [
      e.elementAttributeNameCase === "react" && r.space ? cG[r.property] || r.property : r.attribute,
      n
    ];
  }
}
function $G(e, t) {
  try {
    return _G(t, { reactCompat: !0 });
  } catch (n) {
    if (e.ignoreInvalidStyle)
      return {};
    const r = (
      /** @type {Error} */
      n
    ), i = new mn("Cannot parse `style` attribute", {
      ancestors: e.ancestors,
      cause: r,
      ruleId: "style",
      source: "hast-util-to-jsx-runtime"
    });
    throw i.file = e.filePath || void 0, i.url = OM + "#cannot-parse-style-attribute", i;
  }
}
function DM(e, t, n) {
  let r;
  if (!n)
    r = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const i = t.split(".");
    let a = -1, s;
    for (; ++a < i.length; ) {
      const u = vk(i[a]) ? { type: "Identifier", name: i[a] } : { type: "Literal", value: i[a] };
      s = s ? {
        type: "MemberExpression",
        object: s,
        property: u,
        computed: !!(a && u.type === "Literal"),
        optional: !1
      } : u;
    }
    r = s;
  } else
    r = vk(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (r.type === "Literal") {
    const i = (
      /** @type {string | number} */
      r.value
    );
    return v1.call(e.components, i) ? e.components[i] : i;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(r);
  xc(e);
}
function xc(e, t) {
  const n = new mn(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = e.filePath || void 0, n.url = OM + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function HG(e) {
  const t = {};
  let n;
  for (n in e)
    v1.call(e, n) && (t[VG(n)] = e[n]);
  return t;
}
function VG(e) {
  let t = e.replace(kG, UG);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function UG(e) {
  return "-" + e.toLowerCase();
}
const sy = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, qG = {};
function w1(e, t) {
  const n = qG, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return PM(e, r, i);
}
function PM(e, t, n) {
  if (YG(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return Tk(e.children, t, n);
  }
  return Array.isArray(e) ? Tk(e, t, n) : "";
}
function Tk(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; )
    r[i] = PM(e[i], t, n);
  return r.join("");
}
function YG(e) {
  return !!(e && typeof e == "object");
}
const Rk = document.createElement("i");
function S1(e) {
  const t = "&" + e + ";";
  Rk.innerHTML = t;
  const n = Rk.textContent;
  return (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n
  );
}
function Jn(e, t, n, r) {
  const i = e.length;
  let a = 0, s;
  if (t < 0 ? t = -t > i ? 0 : i + t : t = t > i ? i : t, n = n > 0 ? n : 0, r.length < 1e4)
    s = Array.from(r), s.unshift(t, n), e.splice(...s);
  else
    for (n && e.splice(t, n); a < r.length; )
      s = r.slice(a, a + 1e4), s.unshift(t, 0), e.splice(...s), a += 1e4, t += 1e4;
}
function pr(e, t) {
  return e.length > 0 ? (Jn(e, e.length, 0, t), e) : t;
}
const Ok = {}.hasOwnProperty;
function zM(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    GG(t, e[n]);
  return t;
}
function GG(e, t) {
  let n;
  for (n in t) {
    const i = (Ok.call(e, n) ? e[n] : void 0) || (e[n] = {}), a = t[n];
    let s;
    if (a)
      for (s in a) {
        Ok.call(i, s) || (i[s] = []);
        const u = a[s];
        XG(
          // @ts-expect-error Looks like a list.
          i[s],
          Array.isArray(u) ? u : u ? [u] : []
        );
      }
  }
}
function XG(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  Jn(e, 0, 0, r);
}
function jM(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "" : String.fromCodePoint(n)
  );
}
function Mr(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const xn = Xo(/[A-Za-z]/), hn = Xo(/[\dA-Za-z]/), WG = Xo(/[#-'*+\--9=?A-Z^-~]/);
function Bh(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const Fv = Xo(/\d/), KG = Xo(/[\dA-Fa-f]/), ZG = Xo(/[!-/:-@[-`{-~]/);
function Te(e) {
  return e !== null && e < -2;
}
function mt(e) {
  return e !== null && (e < 0 || e === 32);
}
function Ge(e) {
  return e === -2 || e === -1 || e === 32;
}
const Ip = Xo(/\p{P}|\p{S}/u), ja = Xo(/\s/);
function Xo(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function _l(e) {
  const t = [];
  let n = -1, r = 0, i = 0;
  for (; ++n < e.length; ) {
    const a = e.charCodeAt(n);
    let s = "";
    if (a === 37 && hn(e.charCodeAt(n + 1)) && hn(e.charCodeAt(n + 2)))
      i = 2;
    else if (a < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(a)) || (s = String.fromCharCode(a));
    else if (a > 55295 && a < 57344) {
      const u = e.charCodeAt(n + 1);
      a < 56320 && u > 56319 && u < 57344 ? (s = String.fromCharCode(a, u), i = 1) : s = "";
    } else
      s = String.fromCharCode(a);
    s && (t.push(e.slice(r, n), encodeURIComponent(s)), r = n + i + 1, s = ""), i && (n += i, i = 0);
  }
  return t.join("") + e.slice(r);
}
function Ze(e, t, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let a = 0;
  return s;
  function s(f) {
    return Ge(f) ? (e.enter(n), u(f)) : t(f);
  }
  function u(f) {
    return Ge(f) && a++ < i ? (e.consume(f), u) : (e.exit(n), t(f));
  }
}
const QG = {
  tokenize: JG
};
function JG(e) {
  const t = e.attempt(this.parser.constructs.contentInitial, r, i);
  let n;
  return t;
  function r(u) {
    if (u === null) {
      e.consume(u);
      return;
    }
    return e.enter("lineEnding"), e.consume(u), e.exit("lineEnding"), Ze(e, t, "linePrefix");
  }
  function i(u) {
    return e.enter("paragraph"), a(u);
  }
  function a(u) {
    const f = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = f), n = f, s(u);
  }
  function s(u) {
    if (u === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(u);
      return;
    }
    return Te(u) ? (e.consume(u), e.exit("chunkText"), a) : (e.consume(u), s);
  }
}
const eX = {
  tokenize: tX
}, Nk = {
  tokenize: nX
};
function tX(e) {
  const t = this, n = [];
  let r = 0, i, a, s;
  return u;
  function u(k) {
    if (r < n.length) {
      const R = n[r];
      return t.containerState = R[1], e.attempt(R[0].continuation, f, d)(k);
    }
    return d(k);
  }
  function f(k) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, i && A();
      const R = t.events.length;
      let N = R, D;
      for (; N--; )
        if (t.events[N][0] === "exit" && t.events[N][1].type === "chunkFlow") {
          D = t.events[N][1].end;
          break;
        }
      S(r);
      let P = R;
      for (; P < t.events.length; )
        t.events[P][1].end = {
          ...D
        }, P++;
      return Jn(t.events, N + 1, 0, t.events.slice(R)), t.events.length = P, d(k);
    }
    return u(k);
  }
  function d(k) {
    if (r === n.length) {
      if (!i)
        return g(k);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return b(k);
      t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(Nk, h, p)(k);
  }
  function h(k) {
    return i && A(), S(r), g(k);
  }
  function p(k) {
    return t.parser.lazy[t.now().line] = r !== n.length, s = t.now().offset, b(k);
  }
  function g(k) {
    return t.containerState = {}, e.attempt(Nk, y, b)(k);
  }
  function y(k) {
    return r++, n.push([t.currentConstruct, t.containerState]), g(k);
  }
  function b(k) {
    if (k === null) {
      i && A(), S(0), e.consume(k);
      return;
    }
    return i = i || t.parser.flow(t.now()), e.enter("chunkFlow", {
      _tokenizer: i,
      contentType: "flow",
      previous: a
    }), x(k);
  }
  function x(k) {
    if (k === null) {
      E(e.exit("chunkFlow"), !0), S(0), e.consume(k);
      return;
    }
    return Te(k) ? (e.consume(k), E(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, u) : (e.consume(k), x);
  }
  function E(k, R) {
    const N = t.sliceStream(k);
    if (R && N.push(null), k.previous = a, a && (a.next = k), a = k, i.defineSkip(k.start), i.write(N), t.parser.lazy[k.start.line]) {
      let D = i.events.length;
      for (; D--; )
        if (
          // The token starts before the line ending
          i.events[D][1].start.offset < s && // and either is not ended yet
          (!i.events[D][1].end || // or ends after it.
          i.events[D][1].end.offset > s)
        )
          return;
      const P = t.events.length;
      let F = P, V, T;
      for (; F--; )
        if (t.events[F][0] === "exit" && t.events[F][1].type === "chunkFlow") {
          if (V) {
            T = t.events[F][1].end;
            break;
          }
          V = !0;
        }
      for (S(r), D = P; D < t.events.length; )
        t.events[D][1].end = {
          ...T
        }, D++;
      Jn(t.events, F + 1, 0, t.events.slice(P)), t.events.length = D;
    }
  }
  function S(k) {
    let R = n.length;
    for (; R-- > k; ) {
      const N = n[R];
      t.containerState = N[1], N[0].exit.call(t, e);
    }
    n.length = k;
  }
  function A() {
    i.write([null]), a = void 0, i = void 0, t.containerState._closeFlow = void 0;
  }
}
function nX(e, t, n) {
  return Ze(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function cl(e) {
  if (e === null || mt(e) || ja(e))
    return 1;
  if (Ip(e))
    return 2;
}
function Lp(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; ) {
    const a = e[i].resolveAll;
    a && !r.includes(a) && (t = a(t, n), r.push(a));
  }
  return t;
}
const Bv = {
  name: "attention",
  resolveAll: rX,
  tokenize: iX
};
function rX(e, t) {
  let n = -1, r, i, a, s, u, f, d, h;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          f = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const p = {
            ...e[r][1].end
          }, g = {
            ...e[n][1].start
          };
          Mk(p, -f), Mk(g, f), s = {
            type: f > 1 ? "strongSequence" : "emphasisSequence",
            start: p,
            end: {
              ...e[r][1].end
            }
          }, u = {
            type: f > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...e[n][1].start
            },
            end: g
          }, a = {
            type: f > 1 ? "strongText" : "emphasisText",
            start: {
              ...e[r][1].end
            },
            end: {
              ...e[n][1].start
            }
          }, i = {
            type: f > 1 ? "strong" : "emphasis",
            start: {
              ...s.start
            },
            end: {
              ...u.end
            }
          }, e[r][1].end = {
            ...s.start
          }, e[n][1].start = {
            ...u.end
          }, d = [], e[r][1].end.offset - e[r][1].start.offset && (d = pr(d, [["enter", e[r][1], t], ["exit", e[r][1], t]])), d = pr(d, [["enter", i, t], ["enter", s, t], ["exit", s, t], ["enter", a, t]]), d = pr(d, Lp(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), d = pr(d, [["exit", a, t], ["enter", u, t], ["exit", u, t], ["exit", i, t]]), e[n][1].end.offset - e[n][1].start.offset ? (h = 2, d = pr(d, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : h = 0, Jn(e, r - 1, n - r + 3, d), n = r + d.length - h - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function iX(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, i = cl(r);
  let a;
  return s;
  function s(f) {
    return a = f, e.enter("attentionSequence"), u(f);
  }
  function u(f) {
    if (f === a)
      return e.consume(f), u;
    const d = e.exit("attentionSequence"), h = cl(f), p = !h || h === 2 && i || n.includes(f), g = !i || i === 2 && h || n.includes(r);
    return d._open = !!(a === 42 ? p : p && (i || !g)), d._close = !!(a === 42 ? g : g && (h || !p)), t(f);
  }
}
function Mk(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const oX = {
  name: "autolink",
  tokenize: aX
};
function aX(e, t, n) {
  let r = 0;
  return i;
  function i(y) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), a;
  }
  function a(y) {
    return xn(y) ? (e.consume(y), s) : y === 64 ? n(y) : d(y);
  }
  function s(y) {
    return y === 43 || y === 45 || y === 46 || hn(y) ? (r = 1, u(y)) : d(y);
  }
  function u(y) {
    return y === 58 ? (e.consume(y), r = 0, f) : (y === 43 || y === 45 || y === 46 || hn(y)) && r++ < 32 ? (e.consume(y), u) : (r = 0, d(y));
  }
  function f(y) {
    return y === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.exit("autolink"), t) : y === null || y === 32 || y === 60 || Bh(y) ? n(y) : (e.consume(y), f);
  }
  function d(y) {
    return y === 64 ? (e.consume(y), h) : WG(y) ? (e.consume(y), d) : n(y);
  }
  function h(y) {
    return hn(y) ? p(y) : n(y);
  }
  function p(y) {
    return y === 46 ? (e.consume(y), r = 0, h) : y === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.exit("autolink"), t) : g(y);
  }
  function g(y) {
    if ((y === 45 || hn(y)) && r++ < 63) {
      const b = y === 45 ? g : p;
      return e.consume(y), b;
    }
    return n(y);
  }
}
const Gc = {
  partial: !0,
  tokenize: sX
};
function sX(e, t, n) {
  return r;
  function r(a) {
    return Ge(a) ? Ze(e, i, "linePrefix")(a) : i(a);
  }
  function i(a) {
    return a === null || Te(a) ? t(a) : n(a);
  }
}
const IM = {
  continuation: {
    tokenize: uX
  },
  exit: cX,
  name: "blockQuote",
  tokenize: lX
};
function lX(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    if (s === 62) {
      const u = r.containerState;
      return u.open || (e.enter("blockQuote", {
        _container: !0
      }), u.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(s), e.exit("blockQuoteMarker"), a;
    }
    return n(s);
  }
  function a(s) {
    return Ge(s) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(s), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(s));
  }
}
function uX(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return Ge(s) ? Ze(e, a, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s) : a(s);
  }
  function a(s) {
    return e.attempt(IM, t, n)(s);
  }
}
function cX(e) {
  e.exit("blockQuote");
}
const LM = {
  name: "characterEscape",
  tokenize: fX
};
function fX(e, t, n) {
  return r;
  function r(a) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(a), e.exit("escapeMarker"), i;
  }
  function i(a) {
    return ZG(a) ? (e.enter("characterEscapeValue"), e.consume(a), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(a);
  }
}
const FM = {
  name: "characterReference",
  tokenize: dX
};
function dX(e, t, n) {
  const r = this;
  let i = 0, a, s;
  return u;
  function u(p) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(p), e.exit("characterReferenceMarker"), f;
  }
  function f(p) {
    return p === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(p), e.exit("characterReferenceMarkerNumeric"), d) : (e.enter("characterReferenceValue"), a = 31, s = hn, h(p));
  }
  function d(p) {
    return p === 88 || p === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(p), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), a = 6, s = KG, h) : (e.enter("characterReferenceValue"), a = 7, s = Fv, h(p));
  }
  function h(p) {
    if (p === 59 && i) {
      const g = e.exit("characterReferenceValue");
      return s === hn && !S1(r.sliceSerialize(g)) ? n(p) : (e.enter("characterReferenceMarker"), e.consume(p), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return s(p) && i++ < a ? (e.consume(p), h) : n(p);
  }
}
const Dk = {
  partial: !0,
  tokenize: pX
}, Pk = {
  concrete: !0,
  name: "codeFenced",
  tokenize: hX
};
function hX(e, t, n) {
  const r = this, i = {
    partial: !0,
    tokenize: N
  };
  let a = 0, s = 0, u;
  return f;
  function f(D) {
    return d(D);
  }
  function d(D) {
    const P = r.events[r.events.length - 1];
    return a = P && P[1].type === "linePrefix" ? P[2].sliceSerialize(P[1], !0).length : 0, u = D, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), h(D);
  }
  function h(D) {
    return D === u ? (s++, e.consume(D), h) : s < 3 ? n(D) : (e.exit("codeFencedFenceSequence"), Ge(D) ? Ze(e, p, "whitespace")(D) : p(D));
  }
  function p(D) {
    return D === null || Te(D) ? (e.exit("codeFencedFence"), r.interrupt ? t(D) : e.check(Dk, x, R)(D)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), g(D));
  }
  function g(D) {
    return D === null || Te(D) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), p(D)) : Ge(D) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), Ze(e, y, "whitespace")(D)) : D === 96 && D === u ? n(D) : (e.consume(D), g);
  }
  function y(D) {
    return D === null || Te(D) ? p(D) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), b(D));
  }
  function b(D) {
    return D === null || Te(D) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), p(D)) : D === 96 && D === u ? n(D) : (e.consume(D), b);
  }
  function x(D) {
    return e.attempt(i, R, E)(D);
  }
  function E(D) {
    return e.enter("lineEnding"), e.consume(D), e.exit("lineEnding"), S;
  }
  function S(D) {
    return a > 0 && Ge(D) ? Ze(e, A, "linePrefix", a + 1)(D) : A(D);
  }
  function A(D) {
    return D === null || Te(D) ? e.check(Dk, x, R)(D) : (e.enter("codeFlowValue"), k(D));
  }
  function k(D) {
    return D === null || Te(D) ? (e.exit("codeFlowValue"), A(D)) : (e.consume(D), k);
  }
  function R(D) {
    return e.exit("codeFenced"), t(D);
  }
  function N(D, P, F) {
    let V = 0;
    return T;
    function T(U) {
      return D.enter("lineEnding"), D.consume(U), D.exit("lineEnding"), $;
    }
    function $(U) {
      return D.enter("codeFencedFence"), Ge(U) ? Ze(D, H, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(U) : H(U);
    }
    function H(U) {
      return U === u ? (D.enter("codeFencedFenceSequence"), G(U)) : F(U);
    }
    function G(U) {
      return U === u ? (V++, D.consume(U), G) : V >= s ? (D.exit("codeFencedFenceSequence"), Ge(U) ? Ze(D, j, "whitespace")(U) : j(U)) : F(U);
    }
    function j(U) {
      return U === null || Te(U) ? (D.exit("codeFencedFence"), P(U)) : F(U);
    }
  }
}
function pX(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return s === null ? n(s) : (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), a);
  }
  function a(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
const ly = {
  name: "codeIndented",
  tokenize: gX
}, mX = {
  partial: !0,
  tokenize: yX
};
function gX(e, t, n) {
  const r = this;
  return i;
  function i(d) {
    return e.enter("codeIndented"), Ze(e, a, "linePrefix", 5)(d);
  }
  function a(d) {
    const h = r.events[r.events.length - 1];
    return h && h[1].type === "linePrefix" && h[2].sliceSerialize(h[1], !0).length >= 4 ? s(d) : n(d);
  }
  function s(d) {
    return d === null ? f(d) : Te(d) ? e.attempt(mX, s, f)(d) : (e.enter("codeFlowValue"), u(d));
  }
  function u(d) {
    return d === null || Te(d) ? (e.exit("codeFlowValue"), s(d)) : (e.consume(d), u);
  }
  function f(d) {
    return e.exit("codeIndented"), t(d);
  }
}
function yX(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return r.parser.lazy[r.now().line] ? n(s) : Te(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), i) : Ze(e, a, "linePrefix", 5)(s);
  }
  function a(s) {
    const u = r.events[r.events.length - 1];
    return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? t(s) : Te(s) ? i(s) : n(s);
  }
}
const vX = {
  name: "codeText",
  previous: xX,
  resolve: bX,
  tokenize: wX
};
function bX(e) {
  let t = e.length - 4, n = 3, r, i;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    i === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (i = r) : (r === t || e[r][1].type === "lineEnding") && (e[i][1].type = "codeTextData", r !== i + 2 && (e[i][1].end = e[r - 1][1].end, e.splice(i + 2, r - i - 2), t -= r - i - 2, r = i + 2), i = void 0);
  return e;
}
function xX(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function wX(e, t, n) {
  let r = 0, i, a;
  return s;
  function s(p) {
    return e.enter("codeText"), e.enter("codeTextSequence"), u(p);
  }
  function u(p) {
    return p === 96 ? (e.consume(p), r++, u) : (e.exit("codeTextSequence"), f(p));
  }
  function f(p) {
    return p === null ? n(p) : p === 32 ? (e.enter("space"), e.consume(p), e.exit("space"), f) : p === 96 ? (a = e.enter("codeTextSequence"), i = 0, h(p)) : Te(p) ? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), f) : (e.enter("codeTextData"), d(p));
  }
  function d(p) {
    return p === null || p === 32 || p === 96 || Te(p) ? (e.exit("codeTextData"), f(p)) : (e.consume(p), d);
  }
  function h(p) {
    return p === 96 ? (e.consume(p), i++, h) : i === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(p)) : (a.type = "codeTextData", d(p));
  }
}
class SX {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, n, r) {
    const i = n || 0;
    this.setCursor(Math.trunc(t));
    const a = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return r && ju(this.left, r), a.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), ju(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), ju(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const n = this.left.splice(t, Number.POSITIVE_INFINITY);
        ju(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        ju(this.left, n.reverse());
      }
  }
}
function ju(e, t) {
  let n = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; n < t.length; )
      e.push(...t.slice(n, n + 1e4)), n += 1e4;
}
function BM(e) {
  const t = {};
  let n = -1, r, i, a, s, u, f, d;
  const h = new SX(e);
  for (; ++n < h.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = h.get(n), n && r[1].type === "chunkFlow" && h.get(n - 1)[1].type === "listItemPrefix" && (f = r[1]._tokenizer.events, a = 0, a < f.length && f[a][1].type === "lineEndingBlank" && (a += 2), a < f.length && f[a][1].type === "content"))
      for (; ++a < f.length && f[a][1].type !== "content"; )
        f[a][1].type === "chunkText" && (f[a][1]._isInFirstContentOfListItem = !0, a++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, _X(h, n)), n = t[n], d = !0);
    else if (r[1]._container) {
      for (a = n, i = void 0; a--; )
        if (s = h.get(a), s[1].type === "lineEnding" || s[1].type === "lineEndingBlank")
          s[0] === "enter" && (i && (h.get(i)[1].type = "lineEndingBlank"), s[1].type = "lineEnding", i = a);
        else if (!(s[1].type === "linePrefix" || s[1].type === "listItemIndent")) break;
      i && (r[1].end = {
        ...h.get(i)[1].start
      }, u = h.slice(i, n), u.unshift(r), h.splice(i, n - i + 1, u));
    }
  }
  return Jn(e, 0, Number.POSITIVE_INFINITY, h.slice(0)), !d;
}
function _X(e, t) {
  const n = e.get(t)[1], r = e.get(t)[2];
  let i = t - 1;
  const a = [];
  let s = n._tokenizer;
  s || (s = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (s._contentTypeTextTrailing = !0));
  const u = s.events, f = [], d = {};
  let h, p, g = -1, y = n, b = 0, x = 0;
  const E = [x];
  for (; y; ) {
    for (; e.get(++i)[1] !== y; )
      ;
    a.push(i), y._tokenizer || (h = r.sliceStream(y), y.next || h.push(null), p && s.defineSkip(y.start), y._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = !0), s.write(h), y._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = void 0)), p = y, y = y.next;
  }
  for (y = n; ++g < u.length; )
    // Find a void token that includes a break.
    u[g][0] === "exit" && u[g - 1][0] === "enter" && u[g][1].type === u[g - 1][1].type && u[g][1].start.line !== u[g][1].end.line && (x = g + 1, E.push(x), y._tokenizer = void 0, y.previous = void 0, y = y.next);
  for (s.events = [], y ? (y._tokenizer = void 0, y.previous = void 0) : E.pop(), g = E.length; g--; ) {
    const S = u.slice(E[g], E[g + 1]), A = a.pop();
    f.push([A, A + S.length - 1]), e.splice(A, 2, S);
  }
  for (f.reverse(), g = -1; ++g < f.length; )
    d[b + f[g][0]] = b + f[g][1], b += f[g][1] - f[g][0] - 1;
  return d;
}
const EX = {
  resolve: kX,
  tokenize: AX
}, CX = {
  partial: !0,
  tokenize: TX
};
function kX(e) {
  return BM(e), e;
}
function AX(e, t) {
  let n;
  return r;
  function r(u) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), i(u);
  }
  function i(u) {
    return u === null ? a(u) : Te(u) ? e.check(CX, s, a)(u) : (e.consume(u), i);
  }
  function a(u) {
    return e.exit("chunkContent"), e.exit("content"), t(u);
  }
  function s(u) {
    return e.consume(u), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, i;
  }
}
function TX(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), Ze(e, a, "linePrefix");
  }
  function a(s) {
    if (s === null || Te(s))
      return n(s);
    const u = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? t(s) : e.interrupt(r.parser.constructs.flow, n, t)(s);
  }
}
function $M(e, t, n, r, i, a, s, u, f) {
  const d = f || Number.POSITIVE_INFINITY;
  let h = 0;
  return p;
  function p(S) {
    return S === 60 ? (e.enter(r), e.enter(i), e.enter(a), e.consume(S), e.exit(a), g) : S === null || S === 32 || S === 41 || Bh(S) ? n(S) : (e.enter(r), e.enter(s), e.enter(u), e.enter("chunkString", {
      contentType: "string"
    }), x(S));
  }
  function g(S) {
    return S === 62 ? (e.enter(a), e.consume(S), e.exit(a), e.exit(i), e.exit(r), t) : (e.enter(u), e.enter("chunkString", {
      contentType: "string"
    }), y(S));
  }
  function y(S) {
    return S === 62 ? (e.exit("chunkString"), e.exit(u), g(S)) : S === null || S === 60 || Te(S) ? n(S) : (e.consume(S), S === 92 ? b : y);
  }
  function b(S) {
    return S === 60 || S === 62 || S === 92 ? (e.consume(S), y) : y(S);
  }
  function x(S) {
    return !h && (S === null || S === 41 || mt(S)) ? (e.exit("chunkString"), e.exit(u), e.exit(s), e.exit(r), t(S)) : h < d && S === 40 ? (e.consume(S), h++, x) : S === 41 ? (e.consume(S), h--, x) : S === null || S === 32 || S === 40 || Bh(S) ? n(S) : (e.consume(S), S === 92 ? E : x);
  }
  function E(S) {
    return S === 40 || S === 41 || S === 92 ? (e.consume(S), x) : x(S);
  }
}
function HM(e, t, n, r, i, a) {
  const s = this;
  let u = 0, f;
  return d;
  function d(y) {
    return e.enter(r), e.enter(i), e.consume(y), e.exit(i), e.enter(a), h;
  }
  function h(y) {
    return u > 999 || y === null || y === 91 || y === 93 && !f || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    y === 94 && !u && "_hiddenFootnoteSupport" in s.parser.constructs ? n(y) : y === 93 ? (e.exit(a), e.enter(i), e.consume(y), e.exit(i), e.exit(r), t) : Te(y) ? (e.enter("lineEnding"), e.consume(y), e.exit("lineEnding"), h) : (e.enter("chunkString", {
      contentType: "string"
    }), p(y));
  }
  function p(y) {
    return y === null || y === 91 || y === 93 || Te(y) || u++ > 999 ? (e.exit("chunkString"), h(y)) : (e.consume(y), f || (f = !Ge(y)), y === 92 ? g : p);
  }
  function g(y) {
    return y === 91 || y === 92 || y === 93 ? (e.consume(y), u++, p) : p(y);
  }
}
function VM(e, t, n, r, i, a) {
  let s;
  return u;
  function u(g) {
    return g === 34 || g === 39 || g === 40 ? (e.enter(r), e.enter(i), e.consume(g), e.exit(i), s = g === 40 ? 41 : g, f) : n(g);
  }
  function f(g) {
    return g === s ? (e.enter(i), e.consume(g), e.exit(i), e.exit(r), t) : (e.enter(a), d(g));
  }
  function d(g) {
    return g === s ? (e.exit(a), f(s)) : g === null ? n(g) : Te(g) ? (e.enter("lineEnding"), e.consume(g), e.exit("lineEnding"), Ze(e, d, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), h(g));
  }
  function h(g) {
    return g === s || g === null || Te(g) ? (e.exit("chunkString"), d(g)) : (e.consume(g), g === 92 ? p : h);
  }
  function p(g) {
    return g === s || g === 92 ? (e.consume(g), h) : h(g);
  }
}
function ec(e, t) {
  let n;
  return r;
  function r(i) {
    return Te(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), n = !0, r) : Ge(i) ? Ze(e, r, n ? "linePrefix" : "lineSuffix")(i) : t(i);
  }
}
const RX = {
  name: "definition",
  tokenize: NX
}, OX = {
  partial: !0,
  tokenize: MX
};
function NX(e, t, n) {
  const r = this;
  let i;
  return a;
  function a(y) {
    return e.enter("definition"), s(y);
  }
  function s(y) {
    return HM.call(
      r,
      e,
      u,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(y);
  }
  function u(y) {
    return i = Mr(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), y === 58 ? (e.enter("definitionMarker"), e.consume(y), e.exit("definitionMarker"), f) : n(y);
  }
  function f(y) {
    return mt(y) ? ec(e, d)(y) : d(y);
  }
  function d(y) {
    return $M(
      e,
      h,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(y);
  }
  function h(y) {
    return e.attempt(OX, p, p)(y);
  }
  function p(y) {
    return Ge(y) ? Ze(e, g, "whitespace")(y) : g(y);
  }
  function g(y) {
    return y === null || Te(y) ? (e.exit("definition"), r.parser.defined.push(i), t(y)) : n(y);
  }
}
function MX(e, t, n) {
  return r;
  function r(u) {
    return mt(u) ? ec(e, i)(u) : n(u);
  }
  function i(u) {
    return VM(e, a, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(u);
  }
  function a(u) {
    return Ge(u) ? Ze(e, s, "whitespace")(u) : s(u);
  }
  function s(u) {
    return u === null || Te(u) ? t(u) : n(u);
  }
}
const DX = {
  name: "hardBreakEscape",
  tokenize: PX
};
function PX(e, t, n) {
  return r;
  function r(a) {
    return e.enter("hardBreakEscape"), e.consume(a), i;
  }
  function i(a) {
    return Te(a) ? (e.exit("hardBreakEscape"), t(a)) : n(a);
  }
}
const zX = {
  name: "headingAtx",
  resolve: jX,
  tokenize: IX
};
function jX(e, t) {
  let n = e.length - 2, r = 3, i, a;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (i = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, a = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, Jn(e, r, n - r + 1, [["enter", i, t], ["enter", a, t], ["exit", a, t], ["exit", i, t]])), e;
}
function IX(e, t, n) {
  let r = 0;
  return i;
  function i(h) {
    return e.enter("atxHeading"), a(h);
  }
  function a(h) {
    return e.enter("atxHeadingSequence"), s(h);
  }
  function s(h) {
    return h === 35 && r++ < 6 ? (e.consume(h), s) : h === null || mt(h) ? (e.exit("atxHeadingSequence"), u(h)) : n(h);
  }
  function u(h) {
    return h === 35 ? (e.enter("atxHeadingSequence"), f(h)) : h === null || Te(h) ? (e.exit("atxHeading"), t(h)) : Ge(h) ? Ze(e, u, "whitespace")(h) : (e.enter("atxHeadingText"), d(h));
  }
  function f(h) {
    return h === 35 ? (e.consume(h), f) : (e.exit("atxHeadingSequence"), u(h));
  }
  function d(h) {
    return h === null || h === 35 || mt(h) ? (e.exit("atxHeadingText"), u(h)) : (e.consume(h), d);
  }
}
const LX = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], zk = ["pre", "script", "style", "textarea"], FX = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: HX,
  tokenize: VX
}, BX = {
  partial: !0,
  tokenize: qX
}, $X = {
  partial: !0,
  tokenize: UX
};
function HX(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function VX(e, t, n) {
  const r = this;
  let i, a, s, u, f;
  return d;
  function d(I) {
    return h(I);
  }
  function h(I) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(I), p;
  }
  function p(I) {
    return I === 33 ? (e.consume(I), g) : I === 47 ? (e.consume(I), a = !0, x) : I === 63 ? (e.consume(I), i = 3, r.interrupt ? t : O) : xn(I) ? (e.consume(I), s = String.fromCharCode(I), E) : n(I);
  }
  function g(I) {
    return I === 45 ? (e.consume(I), i = 2, y) : I === 91 ? (e.consume(I), i = 5, u = 0, b) : xn(I) ? (e.consume(I), i = 4, r.interrupt ? t : O) : n(I);
  }
  function y(I) {
    return I === 45 ? (e.consume(I), r.interrupt ? t : O) : n(I);
  }
  function b(I) {
    const ie = "CDATA[";
    return I === ie.charCodeAt(u++) ? (e.consume(I), u === ie.length ? r.interrupt ? t : H : b) : n(I);
  }
  function x(I) {
    return xn(I) ? (e.consume(I), s = String.fromCharCode(I), E) : n(I);
  }
  function E(I) {
    if (I === null || I === 47 || I === 62 || mt(I)) {
      const ie = I === 47, fe = s.toLowerCase();
      return !ie && !a && zk.includes(fe) ? (i = 1, r.interrupt ? t(I) : H(I)) : LX.includes(s.toLowerCase()) ? (i = 6, ie ? (e.consume(I), S) : r.interrupt ? t(I) : H(I)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(I) : a ? A(I) : k(I));
    }
    return I === 45 || hn(I) ? (e.consume(I), s += String.fromCharCode(I), E) : n(I);
  }
  function S(I) {
    return I === 62 ? (e.consume(I), r.interrupt ? t : H) : n(I);
  }
  function A(I) {
    return Ge(I) ? (e.consume(I), A) : T(I);
  }
  function k(I) {
    return I === 47 ? (e.consume(I), T) : I === 58 || I === 95 || xn(I) ? (e.consume(I), R) : Ge(I) ? (e.consume(I), k) : T(I);
  }
  function R(I) {
    return I === 45 || I === 46 || I === 58 || I === 95 || hn(I) ? (e.consume(I), R) : N(I);
  }
  function N(I) {
    return I === 61 ? (e.consume(I), D) : Ge(I) ? (e.consume(I), N) : k(I);
  }
  function D(I) {
    return I === null || I === 60 || I === 61 || I === 62 || I === 96 ? n(I) : I === 34 || I === 39 ? (e.consume(I), f = I, P) : Ge(I) ? (e.consume(I), D) : F(I);
  }
  function P(I) {
    return I === f ? (e.consume(I), f = null, V) : I === null || Te(I) ? n(I) : (e.consume(I), P);
  }
  function F(I) {
    return I === null || I === 34 || I === 39 || I === 47 || I === 60 || I === 61 || I === 62 || I === 96 || mt(I) ? N(I) : (e.consume(I), F);
  }
  function V(I) {
    return I === 47 || I === 62 || Ge(I) ? k(I) : n(I);
  }
  function T(I) {
    return I === 62 ? (e.consume(I), $) : n(I);
  }
  function $(I) {
    return I === null || Te(I) ? H(I) : Ge(I) ? (e.consume(I), $) : n(I);
  }
  function H(I) {
    return I === 45 && i === 2 ? (e.consume(I), z) : I === 60 && i === 1 ? (e.consume(I), B) : I === 62 && i === 4 ? (e.consume(I), W) : I === 63 && i === 3 ? (e.consume(I), O) : I === 93 && i === 5 ? (e.consume(I), Y) : Te(I) && (i === 6 || i === 7) ? (e.exit("htmlFlowData"), e.check(BX, Z, G)(I)) : I === null || Te(I) ? (e.exit("htmlFlowData"), G(I)) : (e.consume(I), H);
  }
  function G(I) {
    return e.check($X, j, Z)(I);
  }
  function j(I) {
    return e.enter("lineEnding"), e.consume(I), e.exit("lineEnding"), U;
  }
  function U(I) {
    return I === null || Te(I) ? G(I) : (e.enter("htmlFlowData"), H(I));
  }
  function z(I) {
    return I === 45 ? (e.consume(I), O) : H(I);
  }
  function B(I) {
    return I === 47 ? (e.consume(I), s = "", q) : H(I);
  }
  function q(I) {
    if (I === 62) {
      const ie = s.toLowerCase();
      return zk.includes(ie) ? (e.consume(I), W) : H(I);
    }
    return xn(I) && s.length < 8 ? (e.consume(I), s += String.fromCharCode(I), q) : H(I);
  }
  function Y(I) {
    return I === 93 ? (e.consume(I), O) : H(I);
  }
  function O(I) {
    return I === 62 ? (e.consume(I), W) : I === 45 && i === 2 ? (e.consume(I), O) : H(I);
  }
  function W(I) {
    return I === null || Te(I) ? (e.exit("htmlFlowData"), Z(I)) : (e.consume(I), W);
  }
  function Z(I) {
    return e.exit("htmlFlow"), t(I);
  }
}
function UX(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return Te(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), a) : n(s);
  }
  function a(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
function qX(e, t, n) {
  return r;
  function r(i) {
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), e.attempt(Gc, t, n);
  }
}
const YX = {
  name: "htmlText",
  tokenize: GX
};
function GX(e, t, n) {
  const r = this;
  let i, a, s;
  return u;
  function u(O) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(O), f;
  }
  function f(O) {
    return O === 33 ? (e.consume(O), d) : O === 47 ? (e.consume(O), N) : O === 63 ? (e.consume(O), k) : xn(O) ? (e.consume(O), F) : n(O);
  }
  function d(O) {
    return O === 45 ? (e.consume(O), h) : O === 91 ? (e.consume(O), a = 0, b) : xn(O) ? (e.consume(O), A) : n(O);
  }
  function h(O) {
    return O === 45 ? (e.consume(O), y) : n(O);
  }
  function p(O) {
    return O === null ? n(O) : O === 45 ? (e.consume(O), g) : Te(O) ? (s = p, B(O)) : (e.consume(O), p);
  }
  function g(O) {
    return O === 45 ? (e.consume(O), y) : p(O);
  }
  function y(O) {
    return O === 62 ? z(O) : O === 45 ? g(O) : p(O);
  }
  function b(O) {
    const W = "CDATA[";
    return O === W.charCodeAt(a++) ? (e.consume(O), a === W.length ? x : b) : n(O);
  }
  function x(O) {
    return O === null ? n(O) : O === 93 ? (e.consume(O), E) : Te(O) ? (s = x, B(O)) : (e.consume(O), x);
  }
  function E(O) {
    return O === 93 ? (e.consume(O), S) : x(O);
  }
  function S(O) {
    return O === 62 ? z(O) : O === 93 ? (e.consume(O), S) : x(O);
  }
  function A(O) {
    return O === null || O === 62 ? z(O) : Te(O) ? (s = A, B(O)) : (e.consume(O), A);
  }
  function k(O) {
    return O === null ? n(O) : O === 63 ? (e.consume(O), R) : Te(O) ? (s = k, B(O)) : (e.consume(O), k);
  }
  function R(O) {
    return O === 62 ? z(O) : k(O);
  }
  function N(O) {
    return xn(O) ? (e.consume(O), D) : n(O);
  }
  function D(O) {
    return O === 45 || hn(O) ? (e.consume(O), D) : P(O);
  }
  function P(O) {
    return Te(O) ? (s = P, B(O)) : Ge(O) ? (e.consume(O), P) : z(O);
  }
  function F(O) {
    return O === 45 || hn(O) ? (e.consume(O), F) : O === 47 || O === 62 || mt(O) ? V(O) : n(O);
  }
  function V(O) {
    return O === 47 ? (e.consume(O), z) : O === 58 || O === 95 || xn(O) ? (e.consume(O), T) : Te(O) ? (s = V, B(O)) : Ge(O) ? (e.consume(O), V) : z(O);
  }
  function T(O) {
    return O === 45 || O === 46 || O === 58 || O === 95 || hn(O) ? (e.consume(O), T) : $(O);
  }
  function $(O) {
    return O === 61 ? (e.consume(O), H) : Te(O) ? (s = $, B(O)) : Ge(O) ? (e.consume(O), $) : V(O);
  }
  function H(O) {
    return O === null || O === 60 || O === 61 || O === 62 || O === 96 ? n(O) : O === 34 || O === 39 ? (e.consume(O), i = O, G) : Te(O) ? (s = H, B(O)) : Ge(O) ? (e.consume(O), H) : (e.consume(O), j);
  }
  function G(O) {
    return O === i ? (e.consume(O), i = void 0, U) : O === null ? n(O) : Te(O) ? (s = G, B(O)) : (e.consume(O), G);
  }
  function j(O) {
    return O === null || O === 34 || O === 39 || O === 60 || O === 61 || O === 96 ? n(O) : O === 47 || O === 62 || mt(O) ? V(O) : (e.consume(O), j);
  }
  function U(O) {
    return O === 47 || O === 62 || mt(O) ? V(O) : n(O);
  }
  function z(O) {
    return O === 62 ? (e.consume(O), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(O);
  }
  function B(O) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(O), e.exit("lineEnding"), q;
  }
  function q(O) {
    return Ge(O) ? Ze(e, Y, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(O) : Y(O);
  }
  function Y(O) {
    return e.enter("htmlTextData"), s(O);
  }
}
const _1 = {
  name: "labelEnd",
  resolveAll: ZX,
  resolveTo: QX,
  tokenize: JX
}, XX = {
  tokenize: eW
}, WX = {
  tokenize: tW
}, KX = {
  tokenize: nW
};
function ZX(e) {
  let t = -1;
  const n = [];
  for (; ++t < e.length; ) {
    const r = e[t][1];
    if (n.push(e[t]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
      const i = r.type === "labelImage" ? 4 : 2;
      r.type = "data", t += i;
    }
  }
  return e.length !== n.length && Jn(e, 0, e.length, n), e;
}
function QX(e, t) {
  let n = e.length, r = 0, i, a, s, u;
  for (; n--; )
    if (i = e[n][1], a) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      e[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (s) {
      if (e[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (a = n, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else i.type === "labelEnd" && (s = n);
  const f = {
    type: e[a][1].type === "labelLink" ? "link" : "image",
    start: {
      ...e[a][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  }, d = {
    type: "label",
    start: {
      ...e[a][1].start
    },
    end: {
      ...e[s][1].end
    }
  }, h = {
    type: "labelText",
    start: {
      ...e[a + r + 2][1].end
    },
    end: {
      ...e[s - 2][1].start
    }
  };
  return u = [["enter", f, t], ["enter", d, t]], u = pr(u, e.slice(a + 1, a + r + 3)), u = pr(u, [["enter", h, t]]), u = pr(u, Lp(t.parser.constructs.insideSpan.null, e.slice(a + r + 4, s - 3), t)), u = pr(u, [["exit", h, t], e[s - 2], e[s - 1], ["exit", d, t]]), u = pr(u, e.slice(s + 1)), u = pr(u, [["exit", f, t]]), Jn(e, a, e.length, u), e;
}
function JX(e, t, n) {
  const r = this;
  let i = r.events.length, a, s;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      a = r.events[i][1];
      break;
    }
  return u;
  function u(g) {
    return a ? a._inactive ? p(g) : (s = r.parser.defined.includes(Mr(r.sliceSerialize({
      start: a.end,
      end: r.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(g), e.exit("labelMarker"), e.exit("labelEnd"), f) : n(g);
  }
  function f(g) {
    return g === 40 ? e.attempt(XX, h, s ? h : p)(g) : g === 91 ? e.attempt(WX, h, s ? d : p)(g) : s ? h(g) : p(g);
  }
  function d(g) {
    return e.attempt(KX, h, p)(g);
  }
  function h(g) {
    return t(g);
  }
  function p(g) {
    return a._balanced = !0, n(g);
  }
}
function eW(e, t, n) {
  return r;
  function r(p) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(p), e.exit("resourceMarker"), i;
  }
  function i(p) {
    return mt(p) ? ec(e, a)(p) : a(p);
  }
  function a(p) {
    return p === 41 ? h(p) : $M(e, s, u, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(p);
  }
  function s(p) {
    return mt(p) ? ec(e, f)(p) : h(p);
  }
  function u(p) {
    return n(p);
  }
  function f(p) {
    return p === 34 || p === 39 || p === 40 ? VM(e, d, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(p) : h(p);
  }
  function d(p) {
    return mt(p) ? ec(e, h)(p) : h(p);
  }
  function h(p) {
    return p === 41 ? (e.enter("resourceMarker"), e.consume(p), e.exit("resourceMarker"), e.exit("resource"), t) : n(p);
  }
}
function tW(e, t, n) {
  const r = this;
  return i;
  function i(u) {
    return HM.call(r, e, a, s, "reference", "referenceMarker", "referenceString")(u);
  }
  function a(u) {
    return r.parser.defined.includes(Mr(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(u) : n(u);
  }
  function s(u) {
    return n(u);
  }
}
function nW(e, t, n) {
  return r;
  function r(a) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), i;
  }
  function i(a) {
    return a === 93 ? (e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), e.exit("reference"), t) : n(a);
  }
}
const rW = {
  name: "labelStartImage",
  resolveAll: _1.resolveAll,
  tokenize: iW
};
function iW(e, t, n) {
  const r = this;
  return i;
  function i(u) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(u), e.exit("labelImageMarker"), a;
  }
  function a(u) {
    return u === 91 ? (e.enter("labelMarker"), e.consume(u), e.exit("labelMarker"), e.exit("labelImage"), s) : n(u);
  }
  function s(u) {
    return u === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(u) : t(u);
  }
}
const oW = {
  name: "labelStartLink",
  resolveAll: _1.resolveAll,
  tokenize: aW
};
function aW(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelLink"), a;
  }
  function a(s) {
    return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s);
  }
}
const uy = {
  name: "lineEnding",
  tokenize: sW
};
function sW(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), Ze(e, t, "linePrefix");
  }
}
const uh = {
  name: "thematicBreak",
  tokenize: lW
};
function lW(e, t, n) {
  let r = 0, i;
  return a;
  function a(d) {
    return e.enter("thematicBreak"), s(d);
  }
  function s(d) {
    return i = d, u(d);
  }
  function u(d) {
    return d === i ? (e.enter("thematicBreakSequence"), f(d)) : r >= 3 && (d === null || Te(d)) ? (e.exit("thematicBreak"), t(d)) : n(d);
  }
  function f(d) {
    return d === i ? (e.consume(d), r++, f) : (e.exit("thematicBreakSequence"), Ge(d) ? Ze(e, u, "whitespace")(d) : u(d));
  }
}
const Mn = {
  continuation: {
    tokenize: dW
  },
  exit: pW,
  name: "list",
  tokenize: fW
}, uW = {
  partial: !0,
  tokenize: mW
}, cW = {
  partial: !0,
  tokenize: hW
};
function fW(e, t, n) {
  const r = this, i = r.events[r.events.length - 1];
  let a = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, s = 0;
  return u;
  function u(y) {
    const b = r.containerState.type || (y === 42 || y === 43 || y === 45 ? "listUnordered" : "listOrdered");
    if (b === "listUnordered" ? !r.containerState.marker || y === r.containerState.marker : Fv(y)) {
      if (r.containerState.type || (r.containerState.type = b, e.enter(b, {
        _container: !0
      })), b === "listUnordered")
        return e.enter("listItemPrefix"), y === 42 || y === 45 ? e.check(uh, n, d)(y) : d(y);
      if (!r.interrupt || y === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), f(y);
    }
    return n(y);
  }
  function f(y) {
    return Fv(y) && ++s < 10 ? (e.consume(y), f) : (!r.interrupt || s < 2) && (r.containerState.marker ? y === r.containerState.marker : y === 41 || y === 46) ? (e.exit("listItemValue"), d(y)) : n(y);
  }
  function d(y) {
    return e.enter("listItemMarker"), e.consume(y), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || y, e.check(
      Gc,
      // Cant be empty when interrupting.
      r.interrupt ? n : h,
      e.attempt(uW, g, p)
    );
  }
  function h(y) {
    return r.containerState.initialBlankLine = !0, a++, g(y);
  }
  function p(y) {
    return Ge(y) ? (e.enter("listItemPrefixWhitespace"), e.consume(y), e.exit("listItemPrefixWhitespace"), g) : n(y);
  }
  function g(y) {
    return r.containerState.size = a + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(y);
  }
}
function dW(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(Gc, i, a);
  function i(u) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, Ze(e, t, "listItemIndent", r.containerState.size + 1)(u);
  }
  function a(u) {
    return r.containerState.furtherBlankLines || !Ge(u) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, s(u)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(cW, t, s)(u));
  }
  function s(u) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, Ze(e, e.attempt(Mn, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(u);
  }
}
function hW(e, t, n) {
  const r = this;
  return Ze(e, i, "listItemIndent", r.containerState.size + 1);
  function i(a) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "listItemIndent" && s[2].sliceSerialize(s[1], !0).length === r.containerState.size ? t(a) : n(a);
  }
}
function pW(e) {
  e.exit(this.containerState.type);
}
function mW(e, t, n) {
  const r = this;
  return Ze(e, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function i(a) {
    const s = r.events[r.events.length - 1];
    return !Ge(a) && s && s[1].type === "listItemPrefixWhitespace" ? t(a) : n(a);
  }
}
const jk = {
  name: "setextUnderline",
  resolveTo: gW,
  tokenize: yW
};
function gW(e, t) {
  let n = e.length, r, i, a;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (i = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !a && e[n][1].type === "definition" && (a = n);
  const s = {
    type: "setextHeading",
    start: {
      ...e[r][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  };
  return e[i][1].type = "setextHeadingText", a ? (e.splice(i, 0, ["enter", s, t]), e.splice(a + 1, 0, ["exit", e[r][1], t]), e[r][1].end = {
    ...e[a][1].end
  }) : e[r][1] = s, e.push(["exit", s, t]), e;
}
function yW(e, t, n) {
  const r = this;
  let i;
  return a;
  function a(d) {
    let h = r.events.length, p;
    for (; h--; )
      if (r.events[h][1].type !== "lineEnding" && r.events[h][1].type !== "linePrefix" && r.events[h][1].type !== "content") {
        p = r.events[h][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || p) ? (e.enter("setextHeadingLine"), i = d, s(d)) : n(d);
  }
  function s(d) {
    return e.enter("setextHeadingLineSequence"), u(d);
  }
  function u(d) {
    return d === i ? (e.consume(d), u) : (e.exit("setextHeadingLineSequence"), Ge(d) ? Ze(e, f, "lineSuffix")(d) : f(d));
  }
  function f(d) {
    return d === null || Te(d) ? (e.exit("setextHeadingLine"), t(d)) : n(d);
  }
}
const vW = {
  tokenize: bW
};
function bW(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    Gc,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(this.parser.constructs.flowInitial, i, Ze(e, e.attempt(this.parser.constructs.flow, i, e.attempt(EX, i)), "linePrefix"))
  );
  return n;
  function r(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(a), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function i(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const xW = {
  resolveAll: qM()
}, wW = UM("string"), SW = UM("text");
function UM(e) {
  return {
    resolveAll: qM(e === "text" ? _W : void 0),
    tokenize: t
  };
  function t(n) {
    const r = this, i = this.parser.constructs[e], a = n.attempt(i, s, u);
    return s;
    function s(h) {
      return d(h) ? a(h) : u(h);
    }
    function u(h) {
      if (h === null) {
        n.consume(h);
        return;
      }
      return n.enter("data"), n.consume(h), f;
    }
    function f(h) {
      return d(h) ? (n.exit("data"), a(h)) : (n.consume(h), f);
    }
    function d(h) {
      if (h === null)
        return !0;
      const p = i[h];
      let g = -1;
      if (p)
        for (; ++g < p.length; ) {
          const y = p[g];
          if (!y.previous || y.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function qM(e) {
  return t;
  function t(n, r) {
    let i = -1, a;
    for (; ++i <= n.length; )
      a === void 0 ? n[i] && n[i][1].type === "data" && (a = i, i++) : (!n[i] || n[i][1].type !== "data") && (i !== a + 2 && (n[a][1].end = n[i - 1][1].end, n.splice(a + 2, i - a - 2), i = a + 2), a = void 0);
    return e ? e(n, r) : n;
  }
}
function _W(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], i = t.sliceStream(r);
      let a = i.length, s = -1, u = 0, f;
      for (; a--; ) {
        const d = i[a];
        if (typeof d == "string") {
          for (s = d.length; d.charCodeAt(s - 1) === 32; )
            u++, s--;
          if (s) break;
          s = -1;
        } else if (d === -2)
          f = !0, u++;
        else if (d !== -1) {
          a++;
          break;
        }
      }
      if (t._contentTypeTextTrailing && n === e.length && (u = 0), u) {
        const d = {
          type: n === e.length || f || u < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: a ? s : r.start._bufferIndex + s,
            _index: r.start._index + a,
            line: r.end.line,
            column: r.end.column - u,
            offset: r.end.offset - u
          },
          end: {
            ...r.end
          }
        };
        r.end = {
          ...d.start
        }, r.start.offset === r.end.offset ? Object.assign(r, d) : (e.splice(n, 0, ["enter", d, t], ["exit", d, t]), n += 2);
      }
      n++;
    }
  return e;
}
const EW = {
  42: Mn,
  43: Mn,
  45: Mn,
  48: Mn,
  49: Mn,
  50: Mn,
  51: Mn,
  52: Mn,
  53: Mn,
  54: Mn,
  55: Mn,
  56: Mn,
  57: Mn,
  62: IM
}, CW = {
  91: RX
}, kW = {
  [-2]: ly,
  [-1]: ly,
  32: ly
}, AW = {
  35: zX,
  42: uh,
  45: [jk, uh],
  60: FX,
  61: jk,
  95: uh,
  96: Pk,
  126: Pk
}, TW = {
  38: FM,
  92: LM
}, RW = {
  [-5]: uy,
  [-4]: uy,
  [-3]: uy,
  33: rW,
  38: FM,
  42: Bv,
  60: [oX, YX],
  91: oW,
  92: [DX, LM],
  93: _1,
  95: Bv,
  96: vX
}, OW = {
  null: [Bv, xW]
}, NW = {
  null: [42, 95]
}, MW = {
  null: []
}, DW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: NW,
  contentInitial: CW,
  disable: MW,
  document: EW,
  flow: AW,
  flowInitial: kW,
  insideSpan: OW,
  string: TW,
  text: RW
}, Symbol.toStringTag, { value: "Module" }));
function PW(e, t, n) {
  let r = {
    _bufferIndex: -1,
    _index: 0,
    line: n && n.line || 1,
    column: n && n.column || 1,
    offset: n && n.offset || 0
  };
  const i = {}, a = [];
  let s = [], u = [];
  const f = {
    attempt: P(N),
    check: P(D),
    consume: A,
    enter: k,
    exit: R,
    interrupt: P(D, {
      interrupt: !0
    })
  }, d = {
    code: null,
    containerState: {},
    defineSkip: x,
    events: [],
    now: b,
    parser: e,
    previous: null,
    sliceSerialize: g,
    sliceStream: y,
    write: p
  };
  let h = t.tokenize.call(d, f);
  return t.resolveAll && a.push(t), d;
  function p($) {
    return s = pr(s, $), E(), s[s.length - 1] !== null ? [] : (F(t, 0), d.events = Lp(a, d.events, d), d.events);
  }
  function g($, H) {
    return jW(y($), H);
  }
  function y($) {
    return zW(s, $);
  }
  function b() {
    const {
      _bufferIndex: $,
      _index: H,
      line: G,
      column: j,
      offset: U
    } = r;
    return {
      _bufferIndex: $,
      _index: H,
      line: G,
      column: j,
      offset: U
    };
  }
  function x($) {
    i[$.line] = $.column, T();
  }
  function E() {
    let $;
    for (; r._index < s.length; ) {
      const H = s[r._index];
      if (typeof H == "string")
        for ($ = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === $ && r._bufferIndex < H.length; )
          S(H.charCodeAt(r._bufferIndex));
      else
        S(H);
    }
  }
  function S($) {
    h = h($);
  }
  function A($) {
    Te($) ? (r.line++, r.column = 1, r.offset += $ === -3 ? 2 : 1, T()) : $ !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    s[r._index].length && (r._bufferIndex = -1, r._index++)), d.previous = $;
  }
  function k($, H) {
    const G = H || {};
    return G.type = $, G.start = b(), d.events.push(["enter", G, d]), u.push(G), G;
  }
  function R($) {
    const H = u.pop();
    return H.end = b(), d.events.push(["exit", H, d]), H;
  }
  function N($, H) {
    F($, H.from);
  }
  function D($, H) {
    H.restore();
  }
  function P($, H) {
    return G;
    function G(j, U, z) {
      let B, q, Y, O;
      return Array.isArray(j) ? (
        /* c8 ignore next 1 */
        Z(j)
      ) : "tokenize" in j ? (
        // Looks like a construct.
        Z([
          /** @type {Construct} */
          j
        ])
      ) : W(j);
      function W(re) {
        return le;
        function le(he) {
          const ye = he !== null && re[he], je = he !== null && re.null, Oe = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(ye) ? ye : ye ? [ye] : [],
            ...Array.isArray(je) ? je : je ? [je] : []
          ];
          return Z(Oe)(he);
        }
      }
      function Z(re) {
        return B = re, q = 0, re.length === 0 ? z : I(re[q]);
      }
      function I(re) {
        return le;
        function le(he) {
          return O = V(), Y = re, re.partial || (d.currentConstruct = re), re.name && d.parser.constructs.disable.null.includes(re.name) ? fe() : re.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            H ? Object.assign(Object.create(d), H) : d,
            f,
            ie,
            fe
          )(he);
        }
      }
      function ie(re) {
        return $(Y, O), U;
      }
      function fe(re) {
        return O.restore(), ++q < B.length ? I(B[q]) : z;
      }
    }
  }
  function F($, H) {
    $.resolveAll && !a.includes($) && a.push($), $.resolve && Jn(d.events, H, d.events.length - H, $.resolve(d.events.slice(H), d)), $.resolveTo && (d.events = $.resolveTo(d.events, d));
  }
  function V() {
    const $ = b(), H = d.previous, G = d.currentConstruct, j = d.events.length, U = Array.from(u);
    return {
      from: j,
      restore: z
    };
    function z() {
      r = $, d.previous = H, d.currentConstruct = G, d.events.length = j, u = U, T();
    }
  }
  function T() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function zW(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, i = t.end._index, a = t.end._bufferIndex;
  let s;
  if (n === i)
    s = [e[n].slice(r, a)];
  else {
    if (s = e.slice(n, i), r > -1) {
      const u = s[0];
      typeof u == "string" ? s[0] = u.slice(r) : s.shift();
    }
    a > 0 && s.push(e[i].slice(0, a));
  }
  return s;
}
function jW(e, t) {
  let n = -1;
  const r = [];
  let i;
  for (; ++n < e.length; ) {
    const a = e[n];
    let s;
    if (typeof a == "string")
      s = a;
    else switch (a) {
      case -5: {
        s = "\r";
        break;
      }
      case -4: {
        s = `
`;
        break;
      }
      case -3: {
        s = `\r
`;
        break;
      }
      case -2: {
        s = t ? " " : "	";
        break;
      }
      case -1: {
        if (!t && i) continue;
        s = " ";
        break;
      }
      default:
        s = String.fromCharCode(a);
    }
    i = a === -2, r.push(s);
  }
  return r.join("");
}
function IW(e) {
  const r = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      zM([DW, ...(e || {}).extensions || []])
    ),
    content: i(QG),
    defined: [],
    document: i(eX),
    flow: i(vW),
    lazy: {},
    string: i(wW),
    text: i(SW)
  };
  return r;
  function i(a) {
    return s;
    function s(u) {
      return PW(r, a, u);
    }
  }
}
function LW(e) {
  for (; !BM(e); )
    ;
  return e;
}
const Ik = /[\0\t\n\r]/g;
function FW() {
  let e = 1, t = "", n = !0, r;
  return i;
  function i(a, s, u) {
    const f = [];
    let d, h, p, g, y;
    for (a = t + (typeof a == "string" ? a.toString() : new TextDecoder(s || void 0).decode(a)), p = 0, t = "", n && (a.charCodeAt(0) === 65279 && p++, n = void 0); p < a.length; ) {
      if (Ik.lastIndex = p, d = Ik.exec(a), g = d && d.index !== void 0 ? d.index : a.length, y = a.charCodeAt(g), !d) {
        t = a.slice(p);
        break;
      }
      if (y === 10 && p === g && r)
        f.push(-3), r = void 0;
      else
        switch (r && (f.push(-5), r = void 0), p < g && (f.push(a.slice(p, g)), e += g - p), y) {
          case 0: {
            f.push(65533), e++;
            break;
          }
          case 9: {
            for (h = Math.ceil(e / 4) * 4, f.push(-2); e++ < h; ) f.push(-1);
            break;
          }
          case 10: {
            f.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      p = g + 1;
    }
    return u && (r && f.push(-5), t && f.push(t), f.push(null)), f;
  }
}
const BW = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function $W(e) {
  return e.replace(BW, HW);
}
function HW(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const i = n.charCodeAt(1), a = i === 120 || i === 88;
    return jM(n.slice(a ? 2 : 1), a ? 16 : 10);
  }
  return S1(n) || e;
}
const YM = {}.hasOwnProperty;
function VW(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), UW(n)(LW(IW(n).document().write(FW()(e, t, !0))));
}
function UW(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: a(xr),
      autolinkProtocol: V,
      autolinkEmail: V,
      atxHeading: a(ft),
      blockQuote: a(je),
      characterEscape: V,
      characterReference: V,
      codeFenced: a(Oe),
      codeFencedFenceInfo: s,
      codeFencedFenceMeta: s,
      codeIndented: a(Oe, s),
      codeText: a(be, s),
      codeTextData: V,
      data: V,
      codeFlowValue: V,
      definition: a(Le),
      definitionDestinationString: s,
      definitionLabelString: s,
      definitionTitleString: s,
      emphasis: a(Ie),
      hardBreakEscape: a(Jt),
      hardBreakTrailing: a(Jt),
      htmlFlow: a(bt, s),
      htmlFlowData: V,
      htmlText: a(bt, s),
      htmlTextData: V,
      image: a(Ln),
      label: s,
      link: a(xr),
      listItem: a(ir),
      listItemValue: g,
      listOrdered: a(En, p),
      listUnordered: a(En),
      paragraph: a(Pe),
      reference: I,
      referenceString: s,
      resourceDestinationString: s,
      resourceTitleString: s,
      setextHeading: a(ft),
      strong: a(Lr),
      thematicBreak: a(hi)
    },
    exit: {
      atxHeading: f(),
      atxHeadingSequence: N,
      autolink: f(),
      autolinkEmail: ye,
      autolinkProtocol: he,
      blockQuote: f(),
      characterEscapeValue: T,
      characterReferenceMarkerHexadecimal: fe,
      characterReferenceMarkerNumeric: fe,
      characterReferenceValue: re,
      characterReference: le,
      codeFenced: f(E),
      codeFencedFence: x,
      codeFencedFenceInfo: y,
      codeFencedFenceMeta: b,
      codeFlowValue: T,
      codeIndented: f(S),
      codeText: f(U),
      codeTextData: T,
      data: T,
      definition: f(),
      definitionDestinationString: R,
      definitionLabelString: A,
      definitionTitleString: k,
      emphasis: f(),
      hardBreakEscape: f(H),
      hardBreakTrailing: f(H),
      htmlFlow: f(G),
      htmlFlowData: T,
      htmlText: f(j),
      htmlTextData: T,
      image: f(B),
      label: Y,
      labelText: q,
      lineEnding: $,
      link: f(z),
      listItem: f(),
      listOrdered: f(),
      listUnordered: f(),
      paragraph: f(),
      referenceString: ie,
      resourceDestinationString: O,
      resourceTitleString: W,
      resource: Z,
      setextHeading: f(F),
      setextHeadingLineSequence: P,
      setextHeadingText: D,
      strong: f(),
      thematicBreak: f()
    }
  };
  GM(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(ae) {
    let pe = {
      type: "root",
      children: []
    };
    const Ce = {
      stack: [pe],
      tokenStack: [],
      config: t,
      enter: u,
      exit: d,
      buffer: s,
      resume: h,
      data: n
    }, Ae = [];
    let Je = -1;
    for (; ++Je < ae.length; )
      if (ae[Je][1].type === "listOrdered" || ae[Je][1].type === "listUnordered")
        if (ae[Je][0] === "enter")
          Ae.push(Je);
        else {
          const gn = Ae.pop();
          Je = i(ae, gn, Je);
        }
    for (Je = -1; ++Je < ae.length; ) {
      const gn = t[ae[Je][0]];
      YM.call(gn, ae[Je][1].type) && gn[ae[Je][1].type].call(Object.assign({
        sliceSerialize: ae[Je][2].sliceSerialize
      }, Ce), ae[Je][1]);
    }
    if (Ce.tokenStack.length > 0) {
      const gn = Ce.tokenStack[Ce.tokenStack.length - 1];
      (gn[1] || Lk).call(Ce, void 0, gn[0]);
    }
    for (pe.position = {
      start: No(ae.length > 0 ? ae[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: No(ae.length > 0 ? ae[ae.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, Je = -1; ++Je < t.transforms.length; )
      pe = t.transforms[Je](pe) || pe;
    return pe;
  }
  function i(ae, pe, Ce) {
    let Ae = pe - 1, Je = -1, gn = !1, wr, an, or, yn;
    for (; ++Ae <= Ce; ) {
      const jt = ae[Ae];
      switch (jt[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          jt[0] === "enter" ? Je++ : Je--, yn = void 0;
          break;
        }
        case "lineEndingBlank": {
          jt[0] === "enter" && (wr && !yn && !Je && !or && (or = Ae), yn = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          yn = void 0;
      }
      if (!Je && jt[0] === "enter" && jt[1].type === "listItemPrefix" || Je === -1 && jt[0] === "exit" && (jt[1].type === "listUnordered" || jt[1].type === "listOrdered")) {
        if (wr) {
          let Cn = Ae;
          for (an = void 0; Cn--; ) {
            const Fn = ae[Cn];
            if (Fn[1].type === "lineEnding" || Fn[1].type === "lineEndingBlank") {
              if (Fn[0] === "exit") continue;
              an && (ae[an][1].type = "lineEndingBlank", gn = !0), Fn[1].type = "lineEnding", an = Cn;
            } else if (!(Fn[1].type === "linePrefix" || Fn[1].type === "blockQuotePrefix" || Fn[1].type === "blockQuotePrefixWhitespace" || Fn[1].type === "blockQuoteMarker" || Fn[1].type === "listItemIndent")) break;
          }
          or && (!an || or < an) && (wr._spread = !0), wr.end = Object.assign({}, an ? ae[an][1].start : jt[1].end), ae.splice(an || Ae, 0, ["exit", wr, jt[2]]), Ae++, Ce++;
        }
        if (jt[1].type === "listItemPrefix") {
          const Cn = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, jt[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          wr = Cn, ae.splice(Ae, 0, ["enter", Cn, jt[2]]), Ae++, Ce++, or = void 0, yn = !0;
        }
      }
    }
    return ae[pe][1]._spread = gn, Ce;
  }
  function a(ae, pe) {
    return Ce;
    function Ce(Ae) {
      u.call(this, ae(Ae), Ae), pe && pe.call(this, Ae);
    }
  }
  function s() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function u(ae, pe, Ce) {
    this.stack[this.stack.length - 1].children.push(ae), this.stack.push(ae), this.tokenStack.push([pe, Ce || void 0]), ae.position = {
      start: No(pe.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function f(ae) {
    return pe;
    function pe(Ce) {
      ae && ae.call(this, Ce), d.call(this, Ce);
    }
  }
  function d(ae, pe) {
    const Ce = this.stack.pop(), Ae = this.tokenStack.pop();
    if (Ae)
      Ae[0].type !== ae.type && (pe ? pe.call(this, ae, Ae[0]) : (Ae[1] || Lk).call(this, ae, Ae[0]));
    else throw new Error("Cannot close `" + ae.type + "` (" + Ju({
      start: ae.start,
      end: ae.end
    }) + "): its not open");
    Ce.position.end = No(ae.end);
  }
  function h() {
    return w1(this.stack.pop());
  }
  function p() {
    this.data.expectingFirstListItemValue = !0;
  }
  function g(ae) {
    if (this.data.expectingFirstListItemValue) {
      const pe = this.stack[this.stack.length - 2];
      pe.start = Number.parseInt(this.sliceSerialize(ae), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function y() {
    const ae = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.lang = ae;
  }
  function b() {
    const ae = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.meta = ae;
  }
  function x() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function E() {
    const ae = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.value = ae.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function S() {
    const ae = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.value = ae.replace(/(\r?\n|\r)$/g, "");
  }
  function A(ae) {
    const pe = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.label = pe, Ce.identifier = Mr(this.sliceSerialize(ae)).toLowerCase();
  }
  function k() {
    const ae = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.title = ae;
  }
  function R() {
    const ae = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.url = ae;
  }
  function N(ae) {
    const pe = this.stack[this.stack.length - 1];
    if (!pe.depth) {
      const Ce = this.sliceSerialize(ae).length;
      pe.depth = Ce;
    }
  }
  function D() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function P(ae) {
    const pe = this.stack[this.stack.length - 1];
    pe.depth = this.sliceSerialize(ae).codePointAt(0) === 61 ? 1 : 2;
  }
  function F() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function V(ae) {
    const Ce = this.stack[this.stack.length - 1].children;
    let Ae = Ce[Ce.length - 1];
    (!Ae || Ae.type !== "text") && (Ae = Ko(), Ae.position = {
      start: No(ae.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, Ce.push(Ae)), this.stack.push(Ae);
  }
  function T(ae) {
    const pe = this.stack.pop();
    pe.value += this.sliceSerialize(ae), pe.position.end = No(ae.end);
  }
  function $(ae) {
    const pe = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const Ce = pe.children[pe.children.length - 1];
      Ce.position.end = No(ae.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(pe.type) && (V.call(this, ae), T.call(this, ae));
  }
  function H() {
    this.data.atHardBreak = !0;
  }
  function G() {
    const ae = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.value = ae;
  }
  function j() {
    const ae = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.value = ae;
  }
  function U() {
    const ae = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.value = ae;
  }
  function z() {
    const ae = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const pe = this.data.referenceType || "shortcut";
      ae.type += "Reference", ae.referenceType = pe, delete ae.url, delete ae.title;
    } else
      delete ae.identifier, delete ae.label;
    this.data.referenceType = void 0;
  }
  function B() {
    const ae = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const pe = this.data.referenceType || "shortcut";
      ae.type += "Reference", ae.referenceType = pe, delete ae.url, delete ae.title;
    } else
      delete ae.identifier, delete ae.label;
    this.data.referenceType = void 0;
  }
  function q(ae) {
    const pe = this.sliceSerialize(ae), Ce = this.stack[this.stack.length - 2];
    Ce.label = $W(pe), Ce.identifier = Mr(pe).toLowerCase();
  }
  function Y() {
    const ae = this.stack[this.stack.length - 1], pe = this.resume(), Ce = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, Ce.type === "link") {
      const Ae = ae.children;
      Ce.children = Ae;
    } else
      Ce.alt = pe;
  }
  function O() {
    const ae = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.url = ae;
  }
  function W() {
    const ae = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.title = ae;
  }
  function Z() {
    this.data.inReference = void 0;
  }
  function I() {
    this.data.referenceType = "collapsed";
  }
  function ie(ae) {
    const pe = this.resume(), Ce = this.stack[this.stack.length - 1];
    Ce.label = pe, Ce.identifier = Mr(this.sliceSerialize(ae)).toLowerCase(), this.data.referenceType = "full";
  }
  function fe(ae) {
    this.data.characterReferenceType = ae.type;
  }
  function re(ae) {
    const pe = this.sliceSerialize(ae), Ce = this.data.characterReferenceType;
    let Ae;
    Ce ? (Ae = jM(pe, Ce === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Ae = S1(pe);
    const Je = this.stack[this.stack.length - 1];
    Je.value += Ae;
  }
  function le(ae) {
    const pe = this.stack.pop();
    pe.position.end = No(ae.end);
  }
  function he(ae) {
    T.call(this, ae);
    const pe = this.stack[this.stack.length - 1];
    pe.url = this.sliceSerialize(ae);
  }
  function ye(ae) {
    T.call(this, ae);
    const pe = this.stack[this.stack.length - 1];
    pe.url = "mailto:" + this.sliceSerialize(ae);
  }
  function je() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function Oe() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function be() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function Le() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function Ie() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function ft() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function Jt() {
    return {
      type: "break"
    };
  }
  function bt() {
    return {
      type: "html",
      value: ""
    };
  }
  function Ln() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function xr() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function En(ae) {
    return {
      type: "list",
      ordered: ae.type === "listOrdered",
      start: null,
      spread: ae._spread,
      children: []
    };
  }
  function ir(ae) {
    return {
      type: "listItem",
      spread: ae._spread,
      checked: null,
      children: []
    };
  }
  function Pe() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function Lr() {
    return {
      type: "strong",
      children: []
    };
  }
  function Ko() {
    return {
      type: "text",
      value: ""
    };
  }
  function hi() {
    return {
      type: "thematicBreak"
    };
  }
}
function No(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function GM(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? GM(e, r) : qW(e, r);
  }
}
function qW(e, t) {
  let n;
  for (n in t)
    if (YM.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function Lk(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + Ju({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + Ju({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + Ju({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function YW(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return VW(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function GW(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function XW(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function WW(e, t) {
  const n = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let i = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (i.data = { meta: t.meta }), e.patch(t, i), i = e.applyData(t, i), i = { type: "element", tagName: "pre", properties: {}, children: [i] }, e.patch(t, i), i;
}
function KW(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function ZW(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function QW(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), i = _l(r.toLowerCase()), a = e.footnoteOrder.indexOf(r);
  let s, u = e.footnoteCounts.get(r);
  u === void 0 ? (u = 0, e.footnoteOrder.push(r), s = e.footnoteOrder.length) : s = a + 1, u += 1, e.footnoteCounts.set(r, u);
  const f = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + i,
      id: n + "fnref-" + i + (u > 1 ? "-" + u : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(s) }]
  };
  e.patch(t, f);
  const d = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [f]
  };
  return e.patch(t, d), e.applyData(t, d);
}
function JW(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function eK(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function XM(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const i = e.all(t), a = i[0];
  a && a.type === "text" ? a.value = "[" + a.value : i.unshift({ type: "text", value: "[" });
  const s = i[i.length - 1];
  return s && s.type === "text" ? s.value += r : i.push({ type: "text", value: r }), i;
}
function tK(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return XM(e, t);
  const i = { src: _l(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const a = { type: "element", tagName: "img", properties: i, children: [] };
  return e.patch(t, a), e.applyData(t, a);
}
function nK(e, t) {
  const n = { src: _l(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function rK(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function iK(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return XM(e, t);
  const i = { href: _l(r.url || "") };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const a = {
    type: "element",
    tagName: "a",
    properties: i,
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function oK(e, t) {
  const n = { href: _l(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function aK(e, t, n) {
  const r = e.all(t), i = n ? sK(n) : WM(t), a = {}, s = [];
  if (typeof t.checked == "boolean") {
    const h = r[0];
    let p;
    h && h.type === "element" && h.tagName === "p" ? p = h : (p = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(p)), p.children.length > 0 && p.children.unshift({ type: "text", value: " " }), p.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), a.className = ["task-list-item"];
  }
  let u = -1;
  for (; ++u < r.length; ) {
    const h = r[u];
    (i || u !== 0 || h.type !== "element" || h.tagName !== "p") && s.push({ type: "text", value: `
` }), h.type === "element" && h.tagName === "p" && !i ? s.push(...h.children) : s.push(h);
  }
  const f = r[r.length - 1];
  f && (i || f.type !== "element" || f.tagName !== "p") && s.push({ type: "text", value: `
` });
  const d = { type: "element", tagName: "li", properties: a, children: s };
  return e.patch(t, d), e.applyData(t, d);
}
function sK(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = WM(n[r]);
  }
  return t;
}
function WM(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function lK(e, t) {
  const n = {}, r = e.all(t);
  let i = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++i < r.length; ) {
    const s = r[i];
    if (s.type === "element" && s.tagName === "li" && s.properties && Array.isArray(s.properties.className) && s.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const a = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function uK(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function cK(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function fK(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function dK(e, t) {
  const n = e.all(t), r = n.shift(), i = [];
  if (r) {
    const s = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], s), i.push(s);
  }
  if (n.length > 0) {
    const s = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, u = y1(t.children[1]), f = TM(t.children[t.children.length - 1]);
    u && f && (s.position = { start: u, end: f }), i.push(s);
  }
  const a = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(i, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function hK(e, t, n) {
  const r = n ? n.children : void 0, a = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", s = n && n.type === "table" ? n.align : void 0, u = s ? s.length : t.children.length;
  let f = -1;
  const d = [];
  for (; ++f < u; ) {
    const p = t.children[f], g = {}, y = s ? s[f] : void 0;
    y && (g.align = y);
    let b = { type: "element", tagName: a, properties: g, children: [] };
    p && (b.children = e.all(p), e.patch(p, b), b = e.applyData(p, b)), d.push(b);
  }
  const h = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(d, !0)
  };
  return e.patch(t, h), e.applyData(t, h);
}
function pK(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const Fk = 9, Bk = 32;
function mK(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), i = 0;
  const a = [];
  for (; r; )
    a.push(
      $k(t.slice(i, r.index), i > 0, !0),
      r[0]
    ), i = r.index + r[0].length, r = n.exec(t);
  return a.push($k(t.slice(i), i > 0, !1)), a.join("");
}
function $k(e, t, n) {
  let r = 0, i = e.length;
  if (t) {
    let a = e.codePointAt(r);
    for (; a === Fk || a === Bk; )
      r++, a = e.codePointAt(r);
  }
  if (n) {
    let a = e.codePointAt(i - 1);
    for (; a === Fk || a === Bk; )
      i--, a = e.codePointAt(i - 1);
  }
  return i > r ? e.slice(r, i) : "";
}
function gK(e, t) {
  const n = { type: "text", value: mK(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function yK(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const vK = {
  blockquote: GW,
  break: XW,
  code: WW,
  delete: KW,
  emphasis: ZW,
  footnoteReference: QW,
  heading: JW,
  html: eK,
  imageReference: tK,
  image: nK,
  inlineCode: rK,
  linkReference: iK,
  link: oK,
  listItem: aK,
  list: lK,
  paragraph: uK,
  // @ts-expect-error: root is different, but hard to type.
  root: cK,
  strong: fK,
  table: dK,
  tableCell: pK,
  tableRow: hK,
  text: gK,
  thematicBreak: yK,
  toml: Id,
  yaml: Id,
  definition: Id,
  footnoteDefinition: Id
};
function Id() {
}
const KM = -1, Fp = 0, tc = 1, $h = 2, E1 = 3, C1 = 4, k1 = 5, A1 = 6, ZM = 7, QM = 8, Hk = typeof self == "object" ? self : globalThis, bK = (e, t) => {
  const n = (i, a) => (e.set(a, i), i), r = (i) => {
    if (e.has(i))
      return e.get(i);
    const [a, s] = t[i];
    switch (a) {
      case Fp:
      case KM:
        return n(s, i);
      case tc: {
        const u = n([], i);
        for (const f of s)
          u.push(r(f));
        return u;
      }
      case $h: {
        const u = n({}, i);
        for (const [f, d] of s)
          u[r(f)] = r(d);
        return u;
      }
      case E1:
        return n(new Date(s), i);
      case C1: {
        const { source: u, flags: f } = s;
        return n(new RegExp(u, f), i);
      }
      case k1: {
        const u = n(/* @__PURE__ */ new Map(), i);
        for (const [f, d] of s)
          u.set(r(f), r(d));
        return u;
      }
      case A1: {
        const u = n(/* @__PURE__ */ new Set(), i);
        for (const f of s)
          u.add(r(f));
        return u;
      }
      case ZM: {
        const { name: u, message: f } = s;
        return n(new Hk[u](f), i);
      }
      case QM:
        return n(BigInt(s), i);
      case "BigInt":
        return n(Object(BigInt(s)), i);
      case "ArrayBuffer":
        return n(new Uint8Array(s).buffer, s);
      case "DataView": {
        const { buffer: u } = new Uint8Array(s);
        return n(new DataView(u), s);
      }
    }
    return n(new Hk[a](s), i);
  };
  return r;
}, Vk = (e) => bK(/* @__PURE__ */ new Map(), e)(0), Ms = "", { toString: xK } = {}, { keys: wK } = Object, Iu = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [Fp, t];
  const n = xK.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [tc, Ms];
    case "Object":
      return [$h, Ms];
    case "Date":
      return [E1, Ms];
    case "RegExp":
      return [C1, Ms];
    case "Map":
      return [k1, Ms];
    case "Set":
      return [A1, Ms];
    case "DataView":
      return [tc, n];
  }
  return n.includes("Array") ? [tc, n] : n.includes("Error") ? [ZM, n] : [$h, n];
}, Ld = ([e, t]) => e === Fp && (t === "function" || t === "symbol"), SK = (e, t, n, r) => {
  const i = (s, u) => {
    const f = r.push(s) - 1;
    return n.set(u, f), f;
  }, a = (s) => {
    if (n.has(s))
      return n.get(s);
    let [u, f] = Iu(s);
    switch (u) {
      case Fp: {
        let h = s;
        switch (f) {
          case "bigint":
            u = QM, h = s.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + f);
            h = null;
            break;
          case "undefined":
            return i([KM], s);
        }
        return i([u, h], s);
      }
      case tc: {
        if (f) {
          let g = s;
          return f === "DataView" ? g = new Uint8Array(s.buffer) : f === "ArrayBuffer" && (g = new Uint8Array(s)), i([f, [...g]], s);
        }
        const h = [], p = i([u, h], s);
        for (const g of s)
          h.push(a(g));
        return p;
      }
      case $h: {
        if (f)
          switch (f) {
            case "BigInt":
              return i([f, s.toString()], s);
            case "Boolean":
            case "Number":
            case "String":
              return i([f, s.valueOf()], s);
          }
        if (t && "toJSON" in s)
          return a(s.toJSON());
        const h = [], p = i([u, h], s);
        for (const g of wK(s))
          (e || !Ld(Iu(s[g]))) && h.push([a(g), a(s[g])]);
        return p;
      }
      case E1:
        return i([u, s.toISOString()], s);
      case C1: {
        const { source: h, flags: p } = s;
        return i([u, { source: h, flags: p }], s);
      }
      case k1: {
        const h = [], p = i([u, h], s);
        for (const [g, y] of s)
          (e || !(Ld(Iu(g)) || Ld(Iu(y)))) && h.push([a(g), a(y)]);
        return p;
      }
      case A1: {
        const h = [], p = i([u, h], s);
        for (const g of s)
          (e || !Ld(Iu(g))) && h.push(a(g));
        return p;
      }
    }
    const { message: d } = s;
    return i([u, { name: f, message: d }], s);
  };
  return a;
}, Uk = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return SK(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, Hh = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? Vk(Uk(e, t)) : structuredClone(e)
) : (e, t) => Vk(Uk(e, t));
function _K(e, t) {
  const n = [{ type: "text", value: "" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function EK(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function CK(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || _K, r = e.options.footnoteBackLabel || EK, i = e.options.footnoteLabel || "Footnotes", a = e.options.footnoteLabelTagName || "h2", s = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, u = [];
  let f = -1;
  for (; ++f < e.footnoteOrder.length; ) {
    const d = e.footnoteById.get(
      e.footnoteOrder[f]
    );
    if (!d)
      continue;
    const h = e.all(d), p = String(d.identifier).toUpperCase(), g = _l(p.toLowerCase());
    let y = 0;
    const b = [], x = e.footnoteCounts.get(p);
    for (; x !== void 0 && ++y <= x; ) {
      b.length > 0 && b.push({ type: "text", value: " " });
      let A = typeof n == "string" ? n : n(f, y);
      typeof A == "string" && (A = { type: "text", value: A }), b.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + g + (y > 1 ? "-" + y : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(f, y),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(A) ? A : [A]
      });
    }
    const E = h[h.length - 1];
    if (E && E.type === "element" && E.tagName === "p") {
      const A = E.children[E.children.length - 1];
      A && A.type === "text" ? A.value += " " : E.children.push({ type: "text", value: " " }), E.children.push(...b);
    } else
      h.push(...b);
    const S = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + g },
      children: e.wrap(h, !0)
    };
    e.patch(d, S), u.push(S);
  }
  if (u.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: a,
          properties: {
            ...Hh(s),
            id: "footnote-label"
          },
          children: [{ type: "text", value: i }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(u, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const Bp = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return RK;
    if (typeof e == "function")
      return $p(e);
    if (typeof e == "object")
      return Array.isArray(e) ? kK(e) : AK(e);
    if (typeof e == "string")
      return TK(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function kK(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = Bp(e[n]);
  return $p(r);
  function r(...i) {
    let a = -1;
    for (; ++a < t.length; )
      if (t[a].apply(this, i)) return !0;
    return !1;
  }
}
function AK(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return $p(n);
  function n(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let a;
    for (a in e)
      if (i[a] !== t[a]) return !1;
    return !0;
  }
}
function TK(e) {
  return $p(t);
  function t(n) {
    return n && n.type === e;
  }
}
function $p(e) {
  return t;
  function t(n, r, i) {
    return !!(OK(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function RK() {
  return !0;
}
function OK(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const JM = [], NK = !0, $v = !1, MK = "skip";
function e3(e, t, n, r) {
  let i;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : i = t;
  const a = Bp(i), s = r ? -1 : 1;
  u(e, void 0, [])();
  function u(f, d, h) {
    const p = (
      /** @type {Record<string, unknown>} */
      f && typeof f == "object" ? f : {}
    );
    if (typeof p.type == "string") {
      const y = (
        // `hast`
        typeof p.tagName == "string" ? p.tagName : (
          // `xast`
          typeof p.name == "string" ? p.name : void 0
        )
      );
      Object.defineProperty(g, "name", {
        value: "node (" + (f.type + (y ? "<" + y + ">" : "")) + ")"
      });
    }
    return g;
    function g() {
      let y = JM, b, x, E;
      if ((!t || a(f, d, h[h.length - 1] || void 0)) && (y = DK(n(f, h)), y[0] === $v))
        return y;
      if ("children" in f && f.children) {
        const S = (
          /** @type {UnistParent} */
          f
        );
        if (S.children && y[0] !== MK)
          for (x = (r ? S.children.length : -1) + s, E = h.concat(S); x > -1 && x < S.children.length; ) {
            const A = S.children[x];
            if (b = u(A, x, E)(), b[0] === $v)
              return b;
            x = typeof b[1] == "number" ? b[1] : x + s;
          }
      }
      return y;
    }
  }
}
function DK(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [NK, e] : e == null ? JM : [e];
}
function T1(e, t, n, r) {
  let i, a, s;
  typeof t == "function" ? (a = void 0, s = t, i = n) : (a = t, s = n, i = r), e3(e, a, u, i);
  function u(f, d) {
    const h = d[d.length - 1], p = h ? h.children.indexOf(f) : void 0;
    return s(f, p, h);
  }
}
const Hv = {}.hasOwnProperty, PK = {};
function zK(e, t) {
  const n = t || PK, r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), s = { ...vK, ...n.handlers }, u = {
    all: d,
    applyData: IK,
    definitionById: r,
    footnoteById: i,
    footnoteCounts: a,
    footnoteOrder: [],
    handlers: s,
    one: f,
    options: n,
    patch: jK,
    wrap: FK
  };
  return T1(e, function(h) {
    if (h.type === "definition" || h.type === "footnoteDefinition") {
      const p = h.type === "definition" ? r : i, g = String(h.identifier).toUpperCase();
      p.has(g) || p.set(g, h);
    }
  }), u;
  function f(h, p) {
    const g = h.type, y = u.handlers[g];
    if (Hv.call(u.handlers, g) && y)
      return y(u, h, p);
    if (u.options.passThrough && u.options.passThrough.includes(g)) {
      if ("children" in h) {
        const { children: x, ...E } = h, S = Hh(E);
        return S.children = u.all(h), S;
      }
      return Hh(h);
    }
    return (u.options.unknownHandler || LK)(u, h, p);
  }
  function d(h) {
    const p = [];
    if ("children" in h) {
      const g = h.children;
      let y = -1;
      for (; ++y < g.length; ) {
        const b = u.one(g[y], h);
        if (b) {
          if (y && g[y - 1].type === "break" && (!Array.isArray(b) && b.type === "text" && (b.value = qk(b.value)), !Array.isArray(b) && b.type === "element")) {
            const x = b.children[0];
            x && x.type === "text" && (x.value = qk(x.value));
          }
          Array.isArray(b) ? p.push(...b) : p.push(b);
        }
      }
    }
    return p;
  }
}
function jK(e, t) {
  e.position && (t.position = EG(e));
}
function IK(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, i = e.data.hChildren, a = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const s = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: s };
      }
    n.type === "element" && a && Object.assign(n.properties, Hh(a)), "children" in n && n.children && i !== null && i !== void 0 && (n.children = i);
  }
  return n;
}
function LK(e, t) {
  const n = t.data || {}, r = "value" in t && !(Hv.call(n, "hProperties") || Hv.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function FK(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function qk(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function Yk(e, t) {
  const n = zK(e, t), r = n.one(e, void 0), i = CK(n), a = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return i && a.children.push({ type: "text", value: `
` }, i), a;
}
function BK(e, t) {
  return e && "run" in e ? async function(n, r) {
    const i = (
      /** @type {HastRoot} */
      Yk(n, { file: r, ...t })
    );
    await e.run(i, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      Yk(n, { file: r, ...e || t })
    );
  };
}
function Gk(e) {
  if (e)
    throw e;
}
var cy, Xk;
function $K() {
  if (Xk) return cy;
  Xk = 1;
  var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString, n = Object.defineProperty, r = Object.getOwnPropertyDescriptor, i = function(d) {
    return typeof Array.isArray == "function" ? Array.isArray(d) : t.call(d) === "[object Array]";
  }, a = function(d) {
    if (!d || t.call(d) !== "[object Object]")
      return !1;
    var h = e.call(d, "constructor"), p = d.constructor && d.constructor.prototype && e.call(d.constructor.prototype, "isPrototypeOf");
    if (d.constructor && !h && !p)
      return !1;
    var g;
    for (g in d)
      ;
    return typeof g > "u" || e.call(d, g);
  }, s = function(d, h) {
    n && h.name === "__proto__" ? n(d, h.name, {
      enumerable: !0,
      configurable: !0,
      value: h.newValue,
      writable: !0
    }) : d[h.name] = h.newValue;
  }, u = function(d, h) {
    if (h === "__proto__")
      if (e.call(d, h)) {
        if (r)
          return r(d, h).value;
      } else return;
    return d[h];
  };
  return cy = function f() {
    var d, h, p, g, y, b, x = arguments[0], E = 1, S = arguments.length, A = !1;
    for (typeof x == "boolean" && (A = x, x = arguments[1] || {}, E = 2), (x == null || typeof x != "object" && typeof x != "function") && (x = {}); E < S; ++E)
      if (d = arguments[E], d != null)
        for (h in d)
          p = u(x, h), g = u(d, h), x !== g && (A && g && (a(g) || (y = i(g))) ? (y ? (y = !1, b = p && i(p) ? p : []) : b = p && a(p) ? p : {}, s(x, { name: h, newValue: f(A, b, g) })) : typeof g < "u" && s(x, { name: h, newValue: g }));
    return x;
  }, cy;
}
var HK = $K();
const fy = /* @__PURE__ */ pl(HK);
function Vv(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function VK() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...i) {
    let a = -1;
    const s = i.pop();
    if (typeof s != "function")
      throw new TypeError("Expected function as last argument, not " + s);
    u(null, ...i);
    function u(f, ...d) {
      const h = e[++a];
      let p = -1;
      if (f) {
        s(f);
        return;
      }
      for (; ++p < i.length; )
        (d[p] === null || d[p] === void 0) && (d[p] = i[p]);
      i = d, h ? UK(h, u)(...d) : s(null, ...d);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return e.push(i), t;
  }
}
function UK(e, t) {
  let n;
  return r;
  function r(...s) {
    const u = e.length > s.length;
    let f;
    u && s.push(i);
    try {
      f = e.apply(this, s);
    } catch (d) {
      const h = (
        /** @type {Error} */
        d
      );
      if (u && n)
        throw h;
      return i(h);
    }
    u || (f && f.then && typeof f.then == "function" ? f.then(a, i) : f instanceof Error ? i(f) : a(f));
  }
  function i(s, ...u) {
    n || (n = !0, t(s, ...u));
  }
  function a(s) {
    i(null, s);
  }
}
const Xr = { basename: qK, dirname: YK, extname: GK, join: XK, sep: "/" };
function qK(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  Xc(e);
  let n = 0, r = -1, i = e.length, a;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; i--; )
      if (e.codePointAt(i) === 47) {
        if (a) {
          n = i + 1;
          break;
        }
      } else r < 0 && (a = !0, r = i + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let s = -1, u = t.length - 1;
  for (; i--; )
    if (e.codePointAt(i) === 47) {
      if (a) {
        n = i + 1;
        break;
      }
    } else
      s < 0 && (a = !0, s = i + 1), u > -1 && (e.codePointAt(i) === t.codePointAt(u--) ? u < 0 && (r = i) : (u = -1, r = s));
  return n === r ? r = s : r < 0 && (r = e.length), e.slice(n, r);
}
function YK(e) {
  if (Xc(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function GK(e) {
  Xc(e);
  let t = e.length, n = -1, r = 0, i = -1, a = 0, s;
  for (; t--; ) {
    const u = e.codePointAt(t);
    if (u === 47) {
      if (s) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (s = !0, n = t + 1), u === 46 ? i < 0 ? i = t : a !== 1 && (a = 1) : i > -1 && (a = -1);
  }
  return i < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  a === 0 || // The (right-most) trimmed path component is exactly `..`.
  a === 1 && i === n - 1 && i === r + 1 ? "" : e.slice(i, n);
}
function XK(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    Xc(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : WK(n);
}
function WK(e) {
  Xc(e);
  const t = e.codePointAt(0) === 47;
  let n = KK(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function KK(e, t) {
  let n = "", r = 0, i = -1, a = 0, s = -1, u, f;
  for (; ++s <= e.length; ) {
    if (s < e.length)
      u = e.codePointAt(s);
    else {
      if (u === 47)
        break;
      u = 47;
    }
    if (u === 47) {
      if (!(i === s - 1 || a === 1)) if (i !== s - 1 && a === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (f = n.lastIndexOf("/"), f !== n.length - 1) {
              f < 0 ? (n = "", r = 0) : (n = n.slice(0, f), r = n.length - 1 - n.lastIndexOf("/")), i = s, a = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, i = s, a = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(i + 1, s) : n = e.slice(i + 1, s), r = s - i - 1;
      i = s, a = 0;
    } else u === 46 && a > -1 ? a++ : a = -1;
  }
  return n;
}
function Xc(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const ZK = { cwd: QK };
function QK() {
  return "/";
}
function Uv(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function JK(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!Uv(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return eZ(e);
}
function eZ(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(t);
}
const dy = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class t3 {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? Uv(t) ? n = { path: t } : typeof t == "string" || tZ(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : ZK.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < dy.length; ) {
      const a = dy[r];
      a in n && n[a] !== void 0 && n[a] !== null && (this[a] = a === "history" ? [...n[a]] : n[a]);
    }
    let i;
    for (i in n)
      dy.includes(i) || (this[i] = n[i]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? Xr.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    py(t, "basename"), hy(t, "basename"), this.path = Xr.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? Xr.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    Wk(this.basename, "dirname"), this.path = Xr.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? Xr.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (hy(t, "extname"), Wk(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Xr.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    Uv(t) && (t = JK(t)), py(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? Xr.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    py(t, "stem"), hy(t, "stem"), this.path = Xr.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const i = this.message(t, n, r);
    throw i.fatal = !0, i;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const i = this.message(t, n, r);
    return i.fatal = void 0, i;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const i = new mn(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function hy(e, t) {
  if (e && e.includes(Xr.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + Xr.sep + "`"
    );
}
function py(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function Wk(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function tZ(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const nZ = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = r[e], a = function() {
      return i.apply(a, arguments);
    };
    return Object.setPrototypeOf(a, r), a;
  }
), rZ = {}.hasOwnProperty;
class R1 extends nZ {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = VK();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new R1()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(fy(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (yy("data", this.frozen), this.namespace[t] = n, this) : rZ.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (yy("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const i = n.call(t, ...r);
      typeof i == "function" && this.transformers.use(i);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = Fd(t), r = this.parser || this.Parser;
    return my("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), my("process", this.parser || this.Parser), gy("process", this.compiler || this.Compiler), n ? i(void 0, n) : new Promise(i);
    function i(a, s) {
      const u = Fd(t), f = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(u)
      );
      r.run(f, u, function(h, p, g) {
        if (h || !p || !g)
          return d(h);
        const y = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          p
        ), b = r.stringify(y, g);
        aZ(b) ? g.value = b : g.result = b, d(
          h,
          /** @type {VFileWithOutput<CompileResult>} */
          g
        );
      });
      function d(h, p) {
        h || !p ? s(h) : a ? a(p) : n(void 0, p);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), my("processSync", this.parser || this.Parser), gy("processSync", this.compiler || this.Compiler), this.process(t, i), Zk("processSync", "process", n), r;
    function i(a, s) {
      n = !0, Gk(a), r = s;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    Kk(t), this.freeze();
    const i = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? a(void 0, r) : new Promise(a);
    function a(s, u) {
      const f = Fd(n);
      i.run(t, f, d);
      function d(h, p, g) {
        const y = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          p || t
        );
        h ? u(h) : s ? s(y) : r(void 0, y, g);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, i;
    return this.run(t, n, a), Zk("runSync", "run", r), i;
    function a(s, u) {
      Gk(s), i = u, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = Fd(n), i = this.compiler || this.Compiler;
    return gy("stringify", i), Kk(t), i(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, i = this.namespace;
    if (yy("use", this.frozen), t != null) if (typeof t == "function")
      f(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? u(t) : s(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function a(d) {
      if (typeof d == "function")
        f(d, []);
      else if (typeof d == "object")
        if (Array.isArray(d)) {
          const [h, ...p] = (
            /** @type {PluginTuple<Array<unknown>>} */
            d
          );
          f(h, p);
        } else
          s(d);
      else
        throw new TypeError("Expected usable value, not `" + d + "`");
    }
    function s(d) {
      if (!("plugins" in d) && !("settings" in d))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      u(d.plugins), d.settings && (i.settings = fy(!0, i.settings, d.settings));
    }
    function u(d) {
      let h = -1;
      if (d != null) if (Array.isArray(d))
        for (; ++h < d.length; ) {
          const p = d[h];
          a(p);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + d + "`");
    }
    function f(d, h) {
      let p = -1, g = -1;
      for (; ++p < r.length; )
        if (r[p][0] === d) {
          g = p;
          break;
        }
      if (g === -1)
        r.push([d, ...h]);
      else if (h.length > 0) {
        let [y, ...b] = h;
        const x = r[g][1];
        Vv(x) && Vv(y) && (y = fy(!0, x, y)), r[g] = [d, y, ...b];
      }
    }
  }
}
const iZ = new R1().freeze();
function my(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function gy(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function yy(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function Kk(e) {
  if (!Vv(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function Zk(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function Fd(e) {
  return oZ(e) ? e : new t3(e);
}
function oZ(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function aZ(e) {
  return typeof e == "string" || sZ(e);
}
function sZ(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const lZ = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", Qk = [], Jk = { allowDangerousHtml: !0 }, uZ = /^(https?|ircs?|mailto|xmpp)$/i, cZ = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  { from: "className", id: "remove-classname" },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function fZ(e) {
  const t = dZ(e), n = hZ(e);
  return pZ(t.runSync(t.parse(n), n), e);
}
function dZ(e) {
  const t = e.rehypePlugins || Qk, n = e.remarkPlugins || Qk, r = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...Jk } : Jk;
  return iZ().use(YW).use(n).use(BK, r).use(t);
}
function hZ(e) {
  const t = e.children || "", n = new t3();
  return typeof t == "string" && (n.value = t), n;
}
function pZ(e, t) {
  const n = t.allowedElements, r = t.allowElement, i = t.components, a = t.disallowedElements, s = t.skipHtml, u = t.unwrapDisallowed, f = t.urlTransform || mZ;
  for (const h of cZ)
    Object.hasOwn(t, h.from) && ("" + h.from + (h.to ? "use `" + h.to + "` instead" : "remove it") + lZ + h.id, void 0);
  return T1(e, d), RG(e, {
    Fragment: _.Fragment,
    components: i,
    ignoreInvalidStyle: !0,
    jsx: _.jsx,
    jsxs: _.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function d(h, p, g) {
    if (h.type === "raw" && g && typeof p == "number")
      return s ? g.children.splice(p, 1) : g.children[p] = { type: "text", value: h.value }, p;
    if (h.type === "element") {
      let y;
      for (y in sy)
        if (Object.hasOwn(sy, y) && Object.hasOwn(h.properties, y)) {
          const b = h.properties[y], x = sy[y];
          (x === null || x.includes(h.tagName)) && (h.properties[y] = f(String(b || ""), y, h));
        }
    }
    if (h.type === "element") {
      let y = n ? !n.includes(h.tagName) : a ? a.includes(h.tagName) : !1;
      if (!y && r && typeof p == "number" && (y = !r(h, p, g)), y && g && typeof p == "number")
        return u && h.children ? g.children.splice(p, 1, ...h.children) : g.children.splice(p, 1), p;
    }
  }
}
function mZ(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), i = e.indexOf("/");
  return (
    // If there is no protocol, its relative.
    t === -1 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    i !== -1 && t > i || n !== -1 && t > n || r !== -1 && t > r || // It is a protocol, it should be allowed.
    uZ.test(e.slice(0, t)) ? e : ""
  );
}
function eA(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, i = n.indexOf(t);
  for (; i !== -1; )
    r++, i = n.indexOf(t, i + t.length);
  return r;
}
function gZ(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function yZ(e, t, n) {
  const i = Bp((n || {}).ignore || []), a = vZ(t);
  let s = -1;
  for (; ++s < a.length; )
    e3(e, "text", u);
  function u(d, h) {
    let p = -1, g;
    for (; ++p < h.length; ) {
      const y = h[p], b = g ? g.children : void 0;
      if (i(
        y,
        b ? b.indexOf(y) : void 0,
        g
      ))
        return;
      g = y;
    }
    if (g)
      return f(d, h);
  }
  function f(d, h) {
    const p = h[h.length - 1], g = a[s][0], y = a[s][1];
    let b = 0;
    const E = p.children.indexOf(d);
    let S = !1, A = [];
    g.lastIndex = 0;
    let k = g.exec(d.value);
    for (; k; ) {
      const R = k.index, N = {
        index: k.index,
        input: k.input,
        stack: [...h, d]
      };
      let D = y(...k, N);
      if (typeof D == "string" && (D = D.length > 0 ? { type: "text", value: D } : void 0), D === !1 ? g.lastIndex = R + 1 : (b !== R && A.push({
        type: "text",
        value: d.value.slice(b, R)
      }), Array.isArray(D) ? A.push(...D) : D && A.push(D), b = R + k[0].length, S = !0), !g.global)
        break;
      k = g.exec(d.value);
    }
    return S ? (b < d.value.length && A.push({ type: "text", value: d.value.slice(b) }), p.children.splice(E, 1, ...A)) : A = [d], E + A.length;
  }
}
function vZ(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const i = n[r];
    t.push([bZ(i[0]), xZ(i[1])]);
  }
  return t;
}
function bZ(e) {
  return typeof e == "string" ? new RegExp(gZ(e), "g") : e;
}
function xZ(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const vy = "phrasing", by = ["autolink", "link", "image", "label"];
function wZ() {
  return {
    transforms: [TZ],
    enter: {
      literalAutolink: _Z,
      literalAutolinkEmail: xy,
      literalAutolinkHttp: xy,
      literalAutolinkWww: xy
    },
    exit: {
      literalAutolink: AZ,
      literalAutolinkEmail: kZ,
      literalAutolinkHttp: EZ,
      literalAutolinkWww: CZ
    }
  };
}
function SZ() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: vy,
        notInConstruct: by
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: vy,
        notInConstruct: by
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: vy,
        notInConstruct: by
      }
    ]
  };
}
function _Z(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function xy(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function EZ(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function CZ(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function kZ(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function AZ(e) {
  this.exit(e);
}
function TZ(e) {
  yZ(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, RZ],
      [/(?<=^|\s|\p{P}|\p{S})([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/gu, OZ]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function RZ(e, t, n, r, i) {
  let a = "";
  if (!n3(i) || (/^w/i.test(t) && (n = t + n, t = "", a = "http://"), !NZ(n)))
    return !1;
  const s = MZ(n + r);
  if (!s[0]) return !1;
  const u = {
    type: "link",
    title: null,
    url: a + t + s[0],
    children: [{ type: "text", value: t + s[0] }]
  };
  return s[1] ? [u, { type: "text", value: s[1] }] : u;
}
function OZ(e, t, n, r) {
  return (
    // Not an expected previous character.
    !n3(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function NZ(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function MZ(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const i = eA(e, "(");
  let a = eA(e, ")");
  for (; r !== -1 && i > a; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), a++;
  return [e, n];
}
function n3(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || ja(n) || Ip(n)) && // If its an email, the previous character should not be a slash.
  (!t || n !== 47);
}
r3.peek = $Z;
function DZ() {
  this.buffer();
}
function PZ(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function zZ() {
  this.buffer();
}
function jZ(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function IZ(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = Mr(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function LZ(e) {
  this.exit(e);
}
function FZ(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = Mr(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function BZ(e) {
  this.exit(e);
}
function $Z() {
  return "[";
}
function r3(e, t, n, r) {
  const i = n.createTracker(r);
  let a = i.move("[^");
  const s = n.enter("footnoteReference"), u = n.enter("reference");
  return a += i.move(
    n.safe(n.associationId(e), { after: "]", before: a })
  ), u(), s(), a += i.move("]"), a;
}
function HZ() {
  return {
    enter: {
      gfmFootnoteCallString: DZ,
      gfmFootnoteCall: PZ,
      gfmFootnoteDefinitionLabelString: zZ,
      gfmFootnoteDefinition: jZ
    },
    exit: {
      gfmFootnoteCallString: IZ,
      gfmFootnoteCall: LZ,
      gfmFootnoteDefinitionLabelString: FZ,
      gfmFootnoteDefinition: BZ
    }
  };
}
function VZ(e) {
  let t = !1;
  return e && e.firstLineBlank && (t = !0), {
    handlers: { footnoteDefinition: n, footnoteReference: r3 },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function n(r, i, a, s) {
    const u = a.createTracker(s);
    let f = u.move("[^");
    const d = a.enter("footnoteDefinition"), h = a.enter("label");
    return f += u.move(
      a.safe(a.associationId(r), { before: f, after: "]" })
    ), h(), f += u.move("]:"), r.children && r.children.length > 0 && (u.shift(4), f += u.move(
      (t ? `
` : " ") + a.indentLines(
        a.containerFlow(r, u.current()),
        t ? i3 : UZ
      )
    )), d(), f;
  }
}
function UZ(e, t, n) {
  return t === 0 ? e : i3(e, t, n);
}
function i3(e, t, n) {
  return (n ? "" : "    ") + e;
}
const qZ = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
o3.peek = KZ;
function YZ() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: XZ },
    exit: { strikethrough: WZ }
  };
}
function GZ() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: qZ
      }
    ],
    handlers: { delete: o3 }
  };
}
function XZ(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function WZ(e) {
  this.exit(e);
}
function o3(e, t, n, r) {
  const i = n.createTracker(r), a = n.enter("strikethrough");
  let s = i.move("~~");
  return s += n.containerPhrasing(e, {
    ...i.current(),
    before: s,
    after: "~"
  }), s += i.move("~~"), a(), s;
}
function KZ() {
  return "~";
}
function ZZ(e) {
  return e.length;
}
function QZ(e, t) {
  const n = t || {}, r = (n.align || []).concat(), i = n.stringLength || ZZ, a = [], s = [], u = [], f = [];
  let d = 0, h = -1;
  for (; ++h < e.length; ) {
    const x = [], E = [];
    let S = -1;
    for (e[h].length > d && (d = e[h].length); ++S < e[h].length; ) {
      const A = JZ(e[h][S]);
      if (n.alignDelimiters !== !1) {
        const k = i(A);
        E[S] = k, (f[S] === void 0 || k > f[S]) && (f[S] = k);
      }
      x.push(A);
    }
    s[h] = x, u[h] = E;
  }
  let p = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++p < d; )
      a[p] = tA(r[p]);
  else {
    const x = tA(r);
    for (; ++p < d; )
      a[p] = x;
  }
  p = -1;
  const g = [], y = [];
  for (; ++p < d; ) {
    const x = a[p];
    let E = "", S = "";
    x === 99 ? (E = ":", S = ":") : x === 108 ? E = ":" : x === 114 && (S = ":");
    let A = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      f[p] - E.length - S.length
    );
    const k = E + "-".repeat(A) + S;
    n.alignDelimiters !== !1 && (A = E.length + A + S.length, A > f[p] && (f[p] = A), y[p] = A), g[p] = k;
  }
  s.splice(1, 0, g), u.splice(1, 0, y), h = -1;
  const b = [];
  for (; ++h < s.length; ) {
    const x = s[h], E = u[h];
    p = -1;
    const S = [];
    for (; ++p < d; ) {
      const A = x[p] || "";
      let k = "", R = "";
      if (n.alignDelimiters !== !1) {
        const N = f[p] - (E[p] || 0), D = a[p];
        D === 114 ? k = " ".repeat(N) : D === 99 ? N % 2 ? (k = " ".repeat(N / 2 + 0.5), R = " ".repeat(N / 2 - 0.5)) : (k = " ".repeat(N / 2), R = k) : R = " ".repeat(N);
      }
      n.delimiterStart !== !1 && !p && S.push("|"), n.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && A === "") && (n.delimiterStart !== !1 || p) && S.push(" "), n.alignDelimiters !== !1 && S.push(k), S.push(A), n.alignDelimiters !== !1 && S.push(R), n.padding !== !1 && S.push(" "), (n.delimiterEnd !== !1 || p !== d - 1) && S.push("|");
    }
    b.push(
      n.delimiterEnd === !1 ? S.join("").replace(/ +$/, "") : S.join("")
    );
  }
  return b.join(`
`);
}
function JZ(e) {
  return e == null ? "" : String(e);
}
function tA(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function eQ(e, t, n, r) {
  const i = n.enter("blockquote"), a = n.createTracker(r);
  a.move("> "), a.shift(2);
  const s = n.indentLines(
    n.containerFlow(e, a.current()),
    tQ
  );
  return i(), s;
}
function tQ(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function nQ(e, t) {
  return nA(e, t.inConstruct, !0) && !nA(e, t.notInConstruct, !1);
}
function nA(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function rA(e, t, n, r) {
  let i = -1;
  for (; ++i < n.unsafe.length; )
    if (n.unsafe[i].character === `
` && nQ(n.stack, n.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function rQ(e, t) {
  const n = String(e);
  let r = n.indexOf(t), i = r, a = 0, s = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === i ? ++a > s && (s = a) : a = 1, i = r + t.length, r = n.indexOf(t, i);
  return s;
}
function iQ(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function oQ(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function aQ(e, t, n, r) {
  const i = oQ(n), a = e.value || "", s = i === "`" ? "GraveAccent" : "Tilde";
  if (iQ(e, n)) {
    const p = n.enter("codeIndented"), g = n.indentLines(a, sQ);
    return p(), g;
  }
  const u = n.createTracker(r), f = i.repeat(Math.max(rQ(a, i) + 1, 3)), d = n.enter("codeFenced");
  let h = u.move(f);
  if (e.lang) {
    const p = n.enter(`codeFencedLang${s}`);
    h += u.move(
      n.safe(e.lang, {
        before: h,
        after: " ",
        encode: ["`"],
        ...u.current()
      })
    ), p();
  }
  if (e.lang && e.meta) {
    const p = n.enter(`codeFencedMeta${s}`);
    h += u.move(" "), h += u.move(
      n.safe(e.meta, {
        before: h,
        after: `
`,
        encode: ["`"],
        ...u.current()
      })
    ), p();
  }
  return h += u.move(`
`), a && (h += u.move(a + `
`)), h += u.move(f), d(), h;
}
function sQ(e, t, n) {
  return (n ? "" : "    ") + e;
}
function O1(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function lQ(e, t, n, r) {
  const i = O1(n), a = i === '"' ? "Quote" : "Apostrophe", s = n.enter("definition");
  let u = n.enter("label");
  const f = n.createTracker(r);
  let d = f.move("[");
  return d += f.move(
    n.safe(n.associationId(e), {
      before: d,
      after: "]",
      ...f.current()
    })
  ), d += f.move("]: "), u(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (u = n.enter("destinationLiteral"), d += f.move("<"), d += f.move(
    n.safe(e.url, { before: d, after: ">", ...f.current() })
  ), d += f.move(">")) : (u = n.enter("destinationRaw"), d += f.move(
    n.safe(e.url, {
      before: d,
      after: e.title ? " " : `
`,
      ...f.current()
    })
  )), u(), e.title && (u = n.enter(`title${a}`), d += f.move(" " + i), d += f.move(
    n.safe(e.title, {
      before: d,
      after: i,
      ...f.current()
    })
  ), d += f.move(i), u()), s(), d;
}
function uQ(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function wc(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function Vh(e, t, n) {
  const r = cl(e), i = cl(t);
  return r === void 0 ? i === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
a3.peek = cQ;
function a3(e, t, n, r) {
  const i = uQ(n), a = n.enter("emphasis"), s = n.createTracker(r), u = s.move(i);
  let f = s.move(
    n.containerPhrasing(e, {
      after: i,
      before: u,
      ...s.current()
    })
  );
  const d = f.charCodeAt(0), h = Vh(
    r.before.charCodeAt(r.before.length - 1),
    d,
    i
  );
  h.inside && (f = wc(d) + f.slice(1));
  const p = f.charCodeAt(f.length - 1), g = Vh(r.after.charCodeAt(0), p, i);
  g.inside && (f = f.slice(0, -1) + wc(p));
  const y = s.move(i);
  return a(), n.attentionEncodeSurroundingInfo = {
    after: g.outside,
    before: h.outside
  }, u + f + y;
}
function cQ(e, t, n) {
  return n.options.emphasis || "*";
}
function fQ(e, t) {
  let n = !1;
  return T1(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, $v;
  }), !!((!e.depth || e.depth < 3) && w1(e) && (t.options.setext || n));
}
function dQ(e, t, n, r) {
  const i = Math.max(Math.min(6, e.depth || 1), 1), a = n.createTracker(r);
  if (fQ(e, n)) {
    const h = n.enter("headingSetext"), p = n.enter("phrasing"), g = n.containerPhrasing(e, {
      ...a.current(),
      before: `
`,
      after: `
`
    });
    return p(), h(), g + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size
      g.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(g.lastIndexOf("\r"), g.lastIndexOf(`
`)) + 1)
    );
  }
  const s = "#".repeat(i), u = n.enter("headingAtx"), f = n.enter("phrasing");
  a.move(s + " ");
  let d = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...a.current()
  });
  return /^[\t ]/.test(d) && (d = wc(d.charCodeAt(0)) + d.slice(1)), d = d ? s + " " + d : s, n.options.closeAtx && (d += " " + s), f(), u(), d;
}
s3.peek = hQ;
function s3(e) {
  return e.value || "";
}
function hQ() {
  return "<";
}
l3.peek = pQ;
function l3(e, t, n, r) {
  const i = O1(n), a = i === '"' ? "Quote" : "Apostrophe", s = n.enter("image");
  let u = n.enter("label");
  const f = n.createTracker(r);
  let d = f.move("![");
  return d += f.move(
    n.safe(e.alt, { before: d, after: "]", ...f.current() })
  ), d += f.move("]("), u(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (u = n.enter("destinationLiteral"), d += f.move("<"), d += f.move(
    n.safe(e.url, { before: d, after: ">", ...f.current() })
  ), d += f.move(">")) : (u = n.enter("destinationRaw"), d += f.move(
    n.safe(e.url, {
      before: d,
      after: e.title ? " " : ")",
      ...f.current()
    })
  )), u(), e.title && (u = n.enter(`title${a}`), d += f.move(" " + i), d += f.move(
    n.safe(e.title, {
      before: d,
      after: i,
      ...f.current()
    })
  ), d += f.move(i), u()), d += f.move(")"), s(), d;
}
function pQ() {
  return "!";
}
u3.peek = mQ;
function u3(e, t, n, r) {
  const i = e.referenceType, a = n.enter("imageReference");
  let s = n.enter("label");
  const u = n.createTracker(r);
  let f = u.move("![");
  const d = n.safe(e.alt, {
    before: f,
    after: "]",
    ...u.current()
  });
  f += u.move(d + "]["), s();
  const h = n.stack;
  n.stack = [], s = n.enter("reference");
  const p = n.safe(n.associationId(e), {
    before: f,
    after: "]",
    ...u.current()
  });
  return s(), n.stack = h, a(), i === "full" || !d || d !== p ? f += u.move(p + "]") : i === "shortcut" ? f = f.slice(0, -1) : f += u.move("]"), f;
}
function mQ() {
  return "!";
}
c3.peek = gQ;
function c3(e, t, n) {
  let r = e.value || "", i = "`", a = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++a < n.unsafe.length; ) {
    const s = n.unsafe[a], u = n.compilePattern(s);
    let f;
    if (s.atBreak)
      for (; f = u.exec(r); ) {
        let d = f.index;
        r.charCodeAt(d) === 10 && r.charCodeAt(d - 1) === 13 && d--, r = r.slice(0, d) + " " + r.slice(f.index + 1);
      }
  }
  return i + r + i;
}
function gQ() {
  return "`";
}
function f3(e, t) {
  const n = w1(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
d3.peek = yQ;
function d3(e, t, n, r) {
  const i = O1(n), a = i === '"' ? "Quote" : "Apostrophe", s = n.createTracker(r);
  let u, f;
  if (f3(e, n)) {
    const h = n.stack;
    n.stack = [], u = n.enter("autolink");
    let p = s.move("<");
    return p += s.move(
      n.containerPhrasing(e, {
        before: p,
        after: ">",
        ...s.current()
      })
    ), p += s.move(">"), u(), n.stack = h, p;
  }
  u = n.enter("link"), f = n.enter("label");
  let d = s.move("[");
  return d += s.move(
    n.containerPhrasing(e, {
      before: d,
      after: "](",
      ...s.current()
    })
  ), d += s.move("]("), f(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (f = n.enter("destinationLiteral"), d += s.move("<"), d += s.move(
    n.safe(e.url, { before: d, after: ">", ...s.current() })
  ), d += s.move(">")) : (f = n.enter("destinationRaw"), d += s.move(
    n.safe(e.url, {
      before: d,
      after: e.title ? " " : ")",
      ...s.current()
    })
  )), f(), e.title && (f = n.enter(`title${a}`), d += s.move(" " + i), d += s.move(
    n.safe(e.title, {
      before: d,
      after: i,
      ...s.current()
    })
  ), d += s.move(i), f()), d += s.move(")"), u(), d;
}
function yQ(e, t, n) {
  return f3(e, n) ? "<" : "[";
}
h3.peek = vQ;
function h3(e, t, n, r) {
  const i = e.referenceType, a = n.enter("linkReference");
  let s = n.enter("label");
  const u = n.createTracker(r);
  let f = u.move("[");
  const d = n.containerPhrasing(e, {
    before: f,
    after: "]",
    ...u.current()
  });
  f += u.move(d + "]["), s();
  const h = n.stack;
  n.stack = [], s = n.enter("reference");
  const p = n.safe(n.associationId(e), {
    before: f,
    after: "]",
    ...u.current()
  });
  return s(), n.stack = h, a(), i === "full" || !d || d !== p ? f += u.move(p + "]") : i === "shortcut" ? f = f.slice(0, -1) : f += u.move("]"), f;
}
function vQ() {
  return "[";
}
function N1(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function bQ(e) {
  const t = N1(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function xQ(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function p3(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function wQ(e, t, n, r) {
  const i = n.enter("list"), a = n.bulletCurrent;
  let s = e.ordered ? xQ(n) : N1(n);
  const u = e.ordered ? s === "." ? ")" : "." : bQ(n);
  let f = t && n.bulletLastUsed ? s === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const h = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (s === "*" || s === "-") && // Empty first list item:
      h && (!h.children || !h.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (f = !0), p3(n) === s && h
    ) {
      let p = -1;
      for (; ++p < e.children.length; ) {
        const g = e.children[p];
        if (g && g.type === "listItem" && g.children && g.children[0] && g.children[0].type === "thematicBreak") {
          f = !0;
          break;
        }
      }
    }
  }
  f && (s = u), n.bulletCurrent = s;
  const d = n.containerFlow(e, r);
  return n.bulletLastUsed = s, n.bulletCurrent = a, i(), d;
}
function SQ(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function _Q(e, t, n, r) {
  const i = SQ(n);
  let a = n.bulletCurrent || N1(n);
  t && t.type === "list" && t.ordered && (a = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + a);
  let s = a.length + 1;
  (i === "tab" || i === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (s = Math.ceil(s / 4) * 4);
  const u = n.createTracker(r);
  u.move(a + " ".repeat(s - a.length)), u.shift(s);
  const f = n.enter("listItem"), d = n.indentLines(
    n.containerFlow(e, u.current()),
    h
  );
  return f(), d;
  function h(p, g, y) {
    return g ? (y ? "" : " ".repeat(s)) + p : (y ? a : a + " ".repeat(s - a.length)) + p;
  }
}
function EQ(e, t, n, r) {
  const i = n.enter("paragraph"), a = n.enter("phrasing"), s = n.containerPhrasing(e, r);
  return a(), i(), s;
}
const CQ = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  Bp([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function kQ(e, t, n, r) {
  return (e.children.some(function(s) {
    return CQ(s);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function AQ(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
m3.peek = TQ;
function m3(e, t, n, r) {
  const i = AQ(n), a = n.enter("strong"), s = n.createTracker(r), u = s.move(i + i);
  let f = s.move(
    n.containerPhrasing(e, {
      after: i,
      before: u,
      ...s.current()
    })
  );
  const d = f.charCodeAt(0), h = Vh(
    r.before.charCodeAt(r.before.length - 1),
    d,
    i
  );
  h.inside && (f = wc(d) + f.slice(1));
  const p = f.charCodeAt(f.length - 1), g = Vh(r.after.charCodeAt(0), p, i);
  g.inside && (f = f.slice(0, -1) + wc(p));
  const y = s.move(i + i);
  return a(), n.attentionEncodeSurroundingInfo = {
    after: g.outside,
    before: h.outside
  }, u + f + y;
}
function TQ(e, t, n) {
  return n.options.strong || "*";
}
function RQ(e, t, n, r) {
  return n.safe(e.value, r);
}
function OQ(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function NQ(e, t, n) {
  const r = (p3(n) + (n.options.ruleSpaces ? " " : "")).repeat(OQ(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const g3 = {
  blockquote: eQ,
  break: rA,
  code: aQ,
  definition: lQ,
  emphasis: a3,
  hardBreak: rA,
  heading: dQ,
  html: s3,
  image: l3,
  imageReference: u3,
  inlineCode: c3,
  link: d3,
  linkReference: h3,
  list: wQ,
  listItem: _Q,
  paragraph: EQ,
  root: kQ,
  strong: m3,
  text: RQ,
  thematicBreak: NQ
};
function MQ() {
  return {
    enter: {
      table: DQ,
      tableData: iA,
      tableHeader: iA,
      tableRow: zQ
    },
    exit: {
      codeText: jQ,
      table: PQ,
      tableData: wy,
      tableHeader: wy,
      tableRow: wy
    }
  };
}
function DQ(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function PQ(e) {
  this.exit(e), this.data.inTable = void 0;
}
function zQ(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function wy(e) {
  this.exit(e);
}
function iA(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function jQ(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, IQ));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function IQ(e, t) {
  return t === "|" ? t : e;
}
function LQ(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, i = t.stringLength, a = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: g,
      table: s,
      tableCell: f,
      tableRow: u
    }
  };
  function s(y, b, x, E) {
    return d(h(y, x, E), y.align);
  }
  function u(y, b, x, E) {
    const S = p(y, x, E), A = d([S]);
    return A.slice(0, A.indexOf(`
`));
  }
  function f(y, b, x, E) {
    const S = x.enter("tableCell"), A = x.enter("phrasing"), k = x.containerPhrasing(y, {
      ...E,
      before: a,
      after: a
    });
    return A(), S(), k;
  }
  function d(y, b) {
    return QZ(y, {
      align: b,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function h(y, b, x) {
    const E = y.children;
    let S = -1;
    const A = [], k = b.enter("table");
    for (; ++S < E.length; )
      A[S] = p(E[S], b, x);
    return k(), A;
  }
  function p(y, b, x) {
    const E = y.children;
    let S = -1;
    const A = [], k = b.enter("tableRow");
    for (; ++S < E.length; )
      A[S] = f(E[S], y, b, x);
    return k(), A;
  }
  function g(y, b, x) {
    let E = g3.inlineCode(y, b, x);
    return x.stack.includes("tableCell") && (E = E.replace(/\|/g, "\\$&")), E;
  }
}
function FQ() {
  return {
    exit: {
      taskListCheckValueChecked: oA,
      taskListCheckValueUnchecked: oA,
      paragraph: $Q
    }
  };
}
function BQ() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: HQ }
  };
}
function oA(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function $Q(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const i = t.children;
      let a = -1, s;
      for (; ++a < i.length; ) {
        const u = i[a];
        if (u.type === "paragraph") {
          s = u;
          break;
        }
      }
      s === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function HQ(e, t, n, r) {
  const i = e.children[0], a = typeof e.checked == "boolean" && i && i.type === "paragraph", s = "[" + (e.checked ? "x" : " ") + "] ", u = n.createTracker(r);
  a && u.move(s);
  let f = g3.listItem(e, t, n, {
    ...r,
    ...u.current()
  });
  return a && (f = f.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, d)), f;
  function d(h) {
    return h + s;
  }
}
function VQ() {
  return [
    wZ(),
    HZ(),
    YZ(),
    MQ(),
    FQ()
  ];
}
function UQ(e) {
  return {
    extensions: [
      SZ(),
      VZ(e),
      GZ(),
      LQ(e),
      BQ()
    ]
  };
}
const qQ = {
  tokenize: ZQ,
  partial: !0
}, y3 = {
  tokenize: QQ,
  partial: !0
}, v3 = {
  tokenize: JQ,
  partial: !0
}, b3 = {
  tokenize: eJ,
  partial: !0
}, YQ = {
  tokenize: tJ,
  partial: !0
}, x3 = {
  name: "wwwAutolink",
  tokenize: WQ,
  previous: S3
}, w3 = {
  name: "protocolAutolink",
  tokenize: KQ,
  previous: _3
}, Ki = {
  name: "emailAutolink",
  tokenize: XQ,
  previous: E3
}, ui = {};
function GQ() {
  return {
    text: ui
  };
}
let ga = 48;
for (; ga < 123; )
  ui[ga] = Ki, ga++, ga === 58 ? ga = 65 : ga === 91 && (ga = 97);
ui[43] = Ki;
ui[45] = Ki;
ui[46] = Ki;
ui[95] = Ki;
ui[72] = [Ki, w3];
ui[104] = [Ki, w3];
ui[87] = [Ki, x3];
ui[119] = [Ki, x3];
function XQ(e, t, n) {
  const r = this;
  let i, a;
  return s;
  function s(p) {
    return !qv(p) || !E3.call(r, r.previous) || M1(r.events) ? n(p) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), u(p));
  }
  function u(p) {
    return qv(p) ? (e.consume(p), u) : p === 64 ? (e.consume(p), f) : n(p);
  }
  function f(p) {
    return p === 46 ? e.check(YQ, h, d)(p) : p === 45 || p === 95 || hn(p) ? (a = !0, e.consume(p), f) : h(p);
  }
  function d(p) {
    return e.consume(p), i = !0, f;
  }
  function h(p) {
    return a && i && xn(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(p)) : n(p);
  }
}
function WQ(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return s !== 87 && s !== 119 || !S3.call(r, r.previous) || M1(r.events) ? n(s) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(qQ, e.attempt(y3, e.attempt(v3, a), n), n)(s));
  }
  function a(s) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(s);
  }
}
function KQ(e, t, n) {
  const r = this;
  let i = "", a = !1;
  return s;
  function s(p) {
    return (p === 72 || p === 104) && _3.call(r, r.previous) && !M1(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), i += String.fromCodePoint(p), e.consume(p), u) : n(p);
  }
  function u(p) {
    if (xn(p) && i.length < 5)
      return i += String.fromCodePoint(p), e.consume(p), u;
    if (p === 58) {
      const g = i.toLowerCase();
      if (g === "http" || g === "https")
        return e.consume(p), f;
    }
    return n(p);
  }
  function f(p) {
    return p === 47 ? (e.consume(p), a ? d : (a = !0, f)) : n(p);
  }
  function d(p) {
    return p === null || Bh(p) || mt(p) || ja(p) || Ip(p) ? n(p) : e.attempt(y3, e.attempt(v3, h), n)(p);
  }
  function h(p) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(p);
  }
}
function ZQ(e, t, n) {
  let r = 0;
  return i;
  function i(s) {
    return (s === 87 || s === 119) && r < 3 ? (r++, e.consume(s), i) : s === 46 && r === 3 ? (e.consume(s), a) : n(s);
  }
  function a(s) {
    return s === null ? n(s) : t(s);
  }
}
function QQ(e, t, n) {
  let r, i, a;
  return s;
  function s(d) {
    return d === 46 || d === 95 ? e.check(b3, f, u)(d) : d === null || mt(d) || ja(d) || d !== 45 && Ip(d) ? f(d) : (a = !0, e.consume(d), s);
  }
  function u(d) {
    return d === 95 ? r = !0 : (i = r, r = void 0), e.consume(d), s;
  }
  function f(d) {
    return i || r || !a ? n(d) : t(d);
  }
}
function JQ(e, t) {
  let n = 0, r = 0;
  return i;
  function i(s) {
    return s === 40 ? (n++, e.consume(s), i) : s === 41 && r < n ? a(s) : s === 33 || s === 34 || s === 38 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 60 || s === 63 || s === 93 || s === 95 || s === 126 ? e.check(b3, t, a)(s) : s === null || mt(s) || ja(s) ? t(s) : (e.consume(s), i);
  }
  function a(s) {
    return s === 41 && r++, e.consume(s), i;
  }
}
function eJ(e, t, n) {
  return r;
  function r(u) {
    return u === 33 || u === 34 || u === 39 || u === 41 || u === 42 || u === 44 || u === 46 || u === 58 || u === 59 || u === 63 || u === 95 || u === 126 ? (e.consume(u), r) : u === 38 ? (e.consume(u), a) : u === 93 ? (e.consume(u), i) : (
      // `<` is an end.
      u === 60 || // So is whitespace.
      u === null || mt(u) || ja(u) ? t(u) : n(u)
    );
  }
  function i(u) {
    return u === null || u === 40 || u === 91 || mt(u) || ja(u) ? t(u) : r(u);
  }
  function a(u) {
    return xn(u) ? s(u) : n(u);
  }
  function s(u) {
    return u === 59 ? (e.consume(u), r) : xn(u) ? (e.consume(u), s) : n(u);
  }
}
function tJ(e, t, n) {
  return r;
  function r(a) {
    return e.consume(a), i;
  }
  function i(a) {
    return hn(a) ? n(a) : t(a);
  }
}
function S3(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || mt(e);
}
function _3(e) {
  return !xn(e);
}
function E3(e) {
  return !(e === 47 || qv(e));
}
function qv(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || hn(e);
}
function M1(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
const nJ = {
  tokenize: cJ,
  partial: !0
};
function rJ() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: sJ,
        continuation: {
          tokenize: lJ
        },
        exit: uJ
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: aJ
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: iJ,
        resolveTo: oJ
      }
    }
  };
}
function iJ(e, t, n) {
  const r = this;
  let i = r.events.length;
  const a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s;
  for (; i--; ) {
    const f = r.events[i][1];
    if (f.type === "labelImage") {
      s = f;
      break;
    }
    if (f.type === "gfmFootnoteCall" || f.type === "labelLink" || f.type === "label" || f.type === "image" || f.type === "link")
      break;
  }
  return u;
  function u(f) {
    if (!s || !s._balanced)
      return n(f);
    const d = Mr(r.sliceSerialize({
      start: s.end,
      end: r.now()
    }));
    return d.codePointAt(0) !== 94 || !a.includes(d.slice(1)) ? n(f) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(f), e.exit("gfmFootnoteCallLabelMarker"), t(f));
  }
}
function oJ(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const a = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, s = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, a.start),
    end: Object.assign({}, a.end)
  }, u = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", i, t],
    ["exit", i, t],
    // Everything in between.
    ["enter", a, t],
    ["enter", s, t],
    ["exit", s, t],
    ["exit", a, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...u), e;
}
function aJ(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a = 0, s;
  return u;
  function u(p) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), f;
  }
  function f(p) {
    return p !== 94 ? n(p) : (e.enter("gfmFootnoteCallMarker"), e.consume(p), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", d);
  }
  function d(p) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      p === 93 && !s || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      p === null || p === 91 || mt(p)
    )
      return n(p);
    if (p === 93) {
      e.exit("chunkString");
      const g = e.exit("gfmFootnoteCallString");
      return i.includes(Mr(r.sliceSerialize(g))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(p);
    }
    return mt(p) || (s = !0), a++, e.consume(p), p === 92 ? h : d;
  }
  function h(p) {
    return p === 91 || p === 92 || p === 93 ? (e.consume(p), a++, d) : d(p);
  }
}
function sJ(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a, s = 0, u;
  return f;
  function f(b) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(b), e.exit("gfmFootnoteDefinitionLabelMarker"), d;
  }
  function d(b) {
    return b === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(b), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", h) : n(b);
  }
  function h(b) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      b === 93 && !u || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      b === null || b === 91 || mt(b)
    )
      return n(b);
    if (b === 93) {
      e.exit("chunkString");
      const x = e.exit("gfmFootnoteDefinitionLabelString");
      return a = Mr(r.sliceSerialize(x)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(b), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), g;
    }
    return mt(b) || (u = !0), s++, e.consume(b), b === 92 ? p : h;
  }
  function p(b) {
    return b === 91 || b === 92 || b === 93 ? (e.consume(b), s++, h) : h(b);
  }
  function g(b) {
    return b === 58 ? (e.enter("definitionMarker"), e.consume(b), e.exit("definitionMarker"), i.includes(a) || i.push(a), Ze(e, y, "gfmFootnoteDefinitionWhitespace")) : n(b);
  }
  function y(b) {
    return t(b);
  }
}
function lJ(e, t, n) {
  return e.check(Gc, t, e.attempt(nJ, t, n));
}
function uJ(e) {
  e.exit("gfmFootnoteDefinition");
}
function cJ(e, t, n) {
  const r = this;
  return Ze(e, i, "gfmFootnoteDefinitionIndent", 5);
  function i(a) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "gfmFootnoteDefinitionIndent" && s[2].sliceSerialize(s[1], !0).length === 4 ? t(a) : n(a);
  }
}
function fJ(e) {
  let n = (e || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: a,
    resolveAll: i
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(s, u) {
    let f = -1;
    for (; ++f < s.length; )
      if (s[f][0] === "enter" && s[f][1].type === "strikethroughSequenceTemporary" && s[f][1]._close) {
        let d = f;
        for (; d--; )
          if (s[d][0] === "exit" && s[d][1].type === "strikethroughSequenceTemporary" && s[d][1]._open && // If the sizes are the same:
          s[f][1].end.offset - s[f][1].start.offset === s[d][1].end.offset - s[d][1].start.offset) {
            s[f][1].type = "strikethroughSequence", s[d][1].type = "strikethroughSequence";
            const h = {
              type: "strikethrough",
              start: Object.assign({}, s[d][1].start),
              end: Object.assign({}, s[f][1].end)
            }, p = {
              type: "strikethroughText",
              start: Object.assign({}, s[d][1].end),
              end: Object.assign({}, s[f][1].start)
            }, g = [["enter", h, u], ["enter", s[d][1], u], ["exit", s[d][1], u], ["enter", p, u]], y = u.parser.constructs.insideSpan.null;
            y && Jn(g, g.length, 0, Lp(y, s.slice(d + 1, f), u)), Jn(g, g.length, 0, [["exit", p, u], ["enter", s[f][1], u], ["exit", s[f][1], u], ["exit", h, u]]), Jn(s, d - 1, f - d + 3, g), f = d + g.length - 2;
            break;
          }
      }
    for (f = -1; ++f < s.length; )
      s[f][1].type === "strikethroughSequenceTemporary" && (s[f][1].type = "data");
    return s;
  }
  function a(s, u, f) {
    const d = this.previous, h = this.events;
    let p = 0;
    return g;
    function g(b) {
      return d === 126 && h[h.length - 1][1].type !== "characterEscape" ? f(b) : (s.enter("strikethroughSequenceTemporary"), y(b));
    }
    function y(b) {
      const x = cl(d);
      if (b === 126)
        return p > 1 ? f(b) : (s.consume(b), p++, y);
      if (p < 2 && !n) return f(b);
      const E = s.exit("strikethroughSequenceTemporary"), S = cl(b);
      return E._open = !S || S === 2 && !!x, E._close = !x || x === 2 && !!S, u(b);
    }
  }
}
class dJ {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    hJ(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(a, s) {
      return a[0] - s[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
    r.push(t.slice()), t.length = 0;
    let i = r.pop();
    for (; i; ) {
      for (const a of i)
        t.push(a);
      i = r.pop();
    }
    this.map.length = 0;
  }
}
function hJ(e, t, n, r) {
  let i = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; i < e.map.length; ) {
      if (e.map[i][0] === t) {
        e.map[i][1] += n, e.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    e.map.push([t, n, r]);
  }
}
function pJ(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const i = e[t];
    if (n) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const a = r.length - 1;
          r[a] = r[a] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function mJ() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: gJ,
        resolveAll: yJ
      }
    }
  };
}
function gJ(e, t, n) {
  const r = this;
  let i = 0, a = 0, s;
  return u;
  function u(T) {
    let $ = r.events.length - 1;
    for (; $ > -1; ) {
      const j = r.events[$][1].type;
      if (j === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      j === "linePrefix") $--;
      else break;
    }
    const H = $ > -1 ? r.events[$][1].type : null, G = H === "tableHead" || H === "tableRow" ? D : f;
    return G === D && r.parser.lazy[r.now().line] ? n(T) : G(T);
  }
  function f(T) {
    return e.enter("tableHead"), e.enter("tableRow"), d(T);
  }
  function d(T) {
    return T === 124 || (s = !0, a += 1), h(T);
  }
  function h(T) {
    return T === null ? n(T) : Te(T) ? a > 1 ? (a = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(T), e.exit("lineEnding"), y) : n(T) : Ge(T) ? Ze(e, h, "whitespace")(T) : (a += 1, s && (s = !1, i += 1), T === 124 ? (e.enter("tableCellDivider"), e.consume(T), e.exit("tableCellDivider"), s = !0, h) : (e.enter("data"), p(T)));
  }
  function p(T) {
    return T === null || T === 124 || mt(T) ? (e.exit("data"), h(T)) : (e.consume(T), T === 92 ? g : p);
  }
  function g(T) {
    return T === 92 || T === 124 ? (e.consume(T), p) : p(T);
  }
  function y(T) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(T) : (e.enter("tableDelimiterRow"), s = !1, Ge(T) ? Ze(e, b, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(T) : b(T));
  }
  function b(T) {
    return T === 45 || T === 58 ? E(T) : T === 124 ? (s = !0, e.enter("tableCellDivider"), e.consume(T), e.exit("tableCellDivider"), x) : N(T);
  }
  function x(T) {
    return Ge(T) ? Ze(e, E, "whitespace")(T) : E(T);
  }
  function E(T) {
    return T === 58 ? (a += 1, s = !0, e.enter("tableDelimiterMarker"), e.consume(T), e.exit("tableDelimiterMarker"), S) : T === 45 ? (a += 1, S(T)) : T === null || Te(T) ? R(T) : N(T);
  }
  function S(T) {
    return T === 45 ? (e.enter("tableDelimiterFiller"), A(T)) : N(T);
  }
  function A(T) {
    return T === 45 ? (e.consume(T), A) : T === 58 ? (s = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(T), e.exit("tableDelimiterMarker"), k) : (e.exit("tableDelimiterFiller"), k(T));
  }
  function k(T) {
    return Ge(T) ? Ze(e, R, "whitespace")(T) : R(T);
  }
  function R(T) {
    return T === 124 ? b(T) : T === null || Te(T) ? !s || i !== a ? N(T) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(T)) : N(T);
  }
  function N(T) {
    return n(T);
  }
  function D(T) {
    return e.enter("tableRow"), P(T);
  }
  function P(T) {
    return T === 124 ? (e.enter("tableCellDivider"), e.consume(T), e.exit("tableCellDivider"), P) : T === null || Te(T) ? (e.exit("tableRow"), t(T)) : Ge(T) ? Ze(e, P, "whitespace")(T) : (e.enter("data"), F(T));
  }
  function F(T) {
    return T === null || T === 124 || mt(T) ? (e.exit("data"), P(T)) : (e.consume(T), T === 92 ? V : F);
  }
  function V(T) {
    return T === 92 || T === 124 ? (e.consume(T), F) : F(T);
  }
}
function yJ(e, t) {
  let n = -1, r = !0, i = 0, a = [0, 0, 0, 0], s = [0, 0, 0, 0], u = !1, f = 0, d, h, p;
  const g = new dJ();
  for (; ++n < e.length; ) {
    const y = e[n], b = y[1];
    y[0] === "enter" ? b.type === "tableHead" ? (u = !1, f !== 0 && (aA(g, t, f, d, h), h = void 0, f = 0), d = {
      type: "table",
      start: Object.assign({}, b.start),
      // Note: correct end is set later.
      end: Object.assign({}, b.end)
    }, g.add(n, 0, [["enter", d, t]])) : b.type === "tableRow" || b.type === "tableDelimiterRow" ? (r = !0, p = void 0, a = [0, 0, 0, 0], s = [0, n + 1, 0, 0], u && (u = !1, h = {
      type: "tableBody",
      start: Object.assign({}, b.start),
      // Note: correct end is set later.
      end: Object.assign({}, b.end)
    }, g.add(n, 0, [["enter", h, t]])), i = b.type === "tableDelimiterRow" ? 2 : h ? 3 : 1) : i && (b.type === "data" || b.type === "tableDelimiterMarker" || b.type === "tableDelimiterFiller") ? (r = !1, s[2] === 0 && (a[1] !== 0 && (s[0] = s[1], p = Bd(g, t, a, i, void 0, p), a = [0, 0, 0, 0]), s[2] = n)) : b.type === "tableCellDivider" && (r ? r = !1 : (a[1] !== 0 && (s[0] = s[1], p = Bd(g, t, a, i, void 0, p)), a = s, s = [a[1], n, 0, 0])) : b.type === "tableHead" ? (u = !0, f = n) : b.type === "tableRow" || b.type === "tableDelimiterRow" ? (f = n, a[1] !== 0 ? (s[0] = s[1], p = Bd(g, t, a, i, n, p)) : s[1] !== 0 && (p = Bd(g, t, s, i, n, p)), i = 0) : i && (b.type === "data" || b.type === "tableDelimiterMarker" || b.type === "tableDelimiterFiller") && (s[3] = n);
  }
  for (f !== 0 && aA(g, t, f, d, h), g.consume(t.events), n = -1; ++n < t.events.length; ) {
    const y = t.events[n];
    y[0] === "enter" && y[1].type === "table" && (y[1]._align = pJ(t.events, n));
  }
  return e;
}
function Bd(e, t, n, r, i, a) {
  const s = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", u = "tableContent";
  n[0] !== 0 && (a.end = Object.assign({}, Fs(t.events, n[0])), e.add(n[0], 0, [["exit", a, t]]));
  const f = Fs(t.events, n[1]);
  if (a = {
    type: s,
    start: Object.assign({}, f),
    // Note: correct end is set later.
    end: Object.assign({}, f)
  }, e.add(n[1], 0, [["enter", a, t]]), n[2] !== 0) {
    const d = Fs(t.events, n[2]), h = Fs(t.events, n[3]), p = {
      type: u,
      start: Object.assign({}, d),
      end: Object.assign({}, h)
    };
    if (e.add(n[2], 0, [["enter", p, t]]), r !== 2) {
      const g = t.events[n[2]], y = t.events[n[3]];
      if (g[1].end = Object.assign({}, y[1].end), g[1].type = "chunkText", g[1].contentType = "text", n[3] > n[2] + 1) {
        const b = n[2] + 1, x = n[3] - n[2] - 1;
        e.add(b, x, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", p, t]]);
  }
  return i !== void 0 && (a.end = Object.assign({}, Fs(t.events, i)), e.add(i, 0, [["exit", a, t]]), a = void 0), a;
}
function aA(e, t, n, r, i) {
  const a = [], s = Fs(t.events, n);
  i && (i.end = Object.assign({}, s), a.push(["exit", i, t])), r.end = Object.assign({}, s), a.push(["exit", r, t]), e.add(n + 1, 0, a);
}
function Fs(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const vJ = {
  name: "tasklistCheck",
  tokenize: xJ
};
function bJ() {
  return {
    text: {
      91: vJ
    }
  };
}
function xJ(e, t, n) {
  const r = this;
  return i;
  function i(f) {
    return (
      // Exit if theres stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(f) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(f), e.exit("taskListCheckMarker"), a)
    );
  }
  function a(f) {
    return mt(f) ? (e.enter("taskListCheckValueUnchecked"), e.consume(f), e.exit("taskListCheckValueUnchecked"), s) : f === 88 || f === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(f), e.exit("taskListCheckValueChecked"), s) : n(f);
  }
  function s(f) {
    return f === 93 ? (e.enter("taskListCheckMarker"), e.consume(f), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), u) : n(f);
  }
  function u(f) {
    return Te(f) ? t(f) : Ge(f) ? e.check({
      tokenize: wJ
    }, t, n)(f) : n(f);
  }
}
function wJ(e, t, n) {
  return Ze(e, r, "whitespace");
  function r(i) {
    return i === null ? n(i) : t(i);
  }
}
function SJ(e) {
  return zM([
    GQ(),
    rJ(),
    fJ(e),
    mJ(),
    bJ()
  ]);
}
const _J = {};
function EJ(e) {
  const t = (
    /** @type {Processor<Root>} */
    this
  ), n = e || _J, r = t.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), a = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), s = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(SJ(n)), a.push(VQ()), s.push(UQ(n));
}
const C3 = ({ item: e }) => {
  const t = C.useContext(Xe), n = () => {
    t.worker?.add_node(e.node_id);
  }, r = (i) => {
    i.detail === 2 && n();
  };
  return /* @__PURE__ */ _.jsx("div", { className: "libnodeentry", onClick: r, title: e.description, children: e.node_name || e.node_id });
}, k3 = (e, t) => {
  const n = e.nodes?.some(
    (i) => i.node_id.toLowerCase().includes(t.toLowerCase())
  ) ?? !1, r = e.subshelves?.some((i) => k3(i, t)) ?? !1;
  return n || r;
}, D1 = ({
  item: e,
  filter: t,
  parentkey: n
}) => {
  const [r, i] = C.useState(!1), a = () => i(!r), s = e.nodes?.filter(
    (f) => f.node_id.toLowerCase().includes(t.toLowerCase())
  ), u = r || t.length > 0;
  return k3(e, t) ? /* @__PURE__ */ _.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ _.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: a,
        style: { cursor: "pointer" },
        title: e.description,
        children: [
          /* @__PURE__ */ _.jsx("div", { className: "shelftitle_text", children: e.name }),
          /* @__PURE__ */ _.jsx("div", { className: "expandicon " + (u ? "open" : "close"), children: /* @__PURE__ */ _.jsx($c, {}) })
        ]
      }
    ),
    /* @__PURE__ */ _.jsx("div", { className: "libnodecontainer " + (u ? "open" : "close"), children: /* @__PURE__ */ _.jsxs("div", { className: "libnodecontainer_inner", children: [
      s && /* @__PURE__ */ _.jsx(_.Fragment, { children: s.map((f) => /* @__PURE__ */ _.jsx(C3, { item: f }, f.node_id)) }),
      e.subshelves && /* @__PURE__ */ _.jsx(_.Fragment, { children: e.subshelves.map((f) => /* @__PURE__ */ _.jsx(
        D1,
        {
          item: f,
          filter: t,
          parentkey: n + f.name
        },
        n + f.name
      )) })
    ] }) }),
    /* @__PURE__ */ _.jsx("hr", {})
  ] }) : /* @__PURE__ */ _.jsx(_.Fragment, {});
}, CJ = ({
  filter: e,
  setFilter: t
}) => /* @__PURE__ */ _.jsxs("div", { className: "libfilter", children: [
  /* @__PURE__ */ _.jsx(mU, { fontSize: "inherit" }),
  /* @__PURE__ */ _.jsx(
    "input",
    {
      type: "text",
      placeholder: "Filter",
      value: e,
      onChange: (n) => {
        t(n.target.value);
      }
    }
  ),
  e && /* @__PURE__ */ _.jsx(
    t2,
    {
      fontSize: "inherit",
      onClick: () => {
        t("");
      }
    }
  )
] }), sA = [">=", "==", "<=", "<", ">"], Hp = ">=", P1 = ({
  availableModule: e
}) => /* @__PURE__ */ _.jsxs("div", { className: "module-links", children: [
  e.homepage && /* @__PURE__ */ _.jsx(_.Fragment, { children: /* @__PURE__ */ _.jsx(
    "a",
    {
      href: e.homepage,
      target: "_blank",
      rel: "noopener noreferrer",
      children: "Homepage"
    }
  ) }),
  e.source && e.homepage && " | ",
  e.source && /* @__PURE__ */ _.jsx(_.Fragment, { children: /* @__PURE__ */ _.jsx(
    "a",
    {
      href: e.source,
      target: "_blank",
      rel: "noopener noreferrer",
      children: "Source"
    }
  ) })
] }), z1 = ({
  availableModule: e
}) => {
  const [t, n] = C.useState(!1), r = () => n(!t), i = 150, a = e.description.length > i ? e.description.substring(0, i) + "..." : e.description;
  return /* @__PURE__ */ _.jsxs("div", { className: "module-description", children: [
    /* @__PURE__ */ _.jsx(fZ, { remarkPlugins: [EJ], children: t ? e.description.replace(/\\n/g, `  
`) : a.replace(/\\n/g, `  
`) }),
    e.description.length > i && /* @__PURE__ */ _.jsx("button", { onClick: r, className: "toggle-description", children: t ? "Show less" : "Show more" })
  ] });
}, j1 = ({
  availableModule: e,
  on_change: t
}) => {
  const [n, r] = C.useState(
    e.version || "latest"
  ), [i, a] = C.useState(Hp), s = (f) => {
    const d = f.target.value;
    r(d), t(d !== "latest" ? i + d : d);
  }, u = (f) => {
    f.target.value !== i && sA.includes(f.target.value) && (a(f.target.value), n !== "latest" && t(f.target.value + n));
  };
  return e.releases && !e.releases.includes(n) && e.releases.unshift(n), /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
    /* @__PURE__ */ _.jsx("select", { value: i, onChange: u, children: sA.map((f) => /* @__PURE__ */ _.jsx("option", { value: f, children: f }, f)) }),
    /* @__PURE__ */ _.jsx("select", { onChange: s, value: n, children: e.releases && e.releases.map((f) => /* @__PURE__ */ _.jsx("option", { value: f, children: f }, f)) })
  ] });
}, kJ = ({
  availableModule: e,
  on_remove: t,
  on_update: n
}) => {
  const [r, i] = C.useState(
    Hp + e.version || "latest"
  );
  return /* @__PURE__ */ _.jsxs("div", { className: "addable-module", children: [
    /* @__PURE__ */ _.jsx("div", { className: "module-name", children: e.name + (e.version ? ` (${e.version})` : "") }),
    /* @__PURE__ */ _.jsx(P1, { availableModule: e }),
    /* @__PURE__ */ _.jsx(z1, { availableModule: e }),
    /* @__PURE__ */ _.jsxs("div", { children: [
      /* @__PURE__ */ _.jsx(
        j1,
        {
          availableModule: e,
          on_change: i
        }
      ),
      /* @__PURE__ */ _.jsx(
        "button",
        {
          className: "update-button",
          disabled: r === e.version,
          onClick: () => {
            n(e, r);
          },
          children: "Update"
        }
      ),
      /* @__PURE__ */ _.jsx(
        "button",
        {
          className: "remove-button",
          onClick: () => {
            t(e);
          },
          children: "Remove"
        }
      )
    ] })
  ] });
}, AJ = ({
  availableModule: e,
  on_add: t
}) => {
  const [n, r] = C.useState(
    Hp + e.version || "latest"
  );
  return /* @__PURE__ */ _.jsxs("div", { className: "addable-module", children: [
    /* @__PURE__ */ _.jsx("div", { className: "module-name", children: e.name + (e.version ? ` (${e.version})` : "") }),
    /* @__PURE__ */ _.jsx(P1, { availableModule: e }),
    /* @__PURE__ */ _.jsx(z1, { availableModule: e }),
    /* @__PURE__ */ _.jsxs("div", { children: [
      /* @__PURE__ */ _.jsx(
        j1,
        {
          availableModule: e,
          on_change: r
        }
      ),
      /* @__PURE__ */ _.jsx(
        "button",
        {
          className: "add-button",
          onClick: () => {
            t(e, n);
          },
          children: "Add"
        }
      )
    ] })
  ] });
}, TJ = ({
  availableModule: e,
  on_add: t
}) => {
  const [n, r] = C.useState(
    Hp + e.version || "latest"
  );
  return /* @__PURE__ */ _.jsxs("div", { className: "addable-module", children: [
    /* @__PURE__ */ _.jsx("div", { className: "module-name", children: e.name }),
    /* @__PURE__ */ _.jsx(P1, { availableModule: e }),
    /* @__PURE__ */ _.jsx(z1, { availableModule: e }),
    /* @__PURE__ */ _.jsxs("div", { children: [
      /* @__PURE__ */ _.jsx(
        j1,
        {
          availableModule: e,
          on_change: r
        }
      ),
      /* @__PURE__ */ _.jsx(
        "button",
        {
          className: "add-button",
          onClick: () => {
            t(e, n);
          },
          children: "Add"
        }
      )
    ] })
  ] });
}, RJ = ({ children: e }) => {
  const [t, n] = C.useState(""), r = C.useContext(Xe), [i, a] = C.useState(!0), [s, u] = C.useState(!0), [f, d] = C.useState(!0), [h, p] = C.useState({
    installed: [],
    available: [],
    active: []
  }), [g, y] = C.useState(!1), b = (P) => {
    P && (r.worker === void 0 || !r.worker.is_open || r.worker.get_available_modules().then((F) => {
      p(F);
    }));
  };
  if (!r.worker)
    return /* @__PURE__ */ _.jsx(_.Fragment, {});
  const x = (P, F) => {
    y(!1), r.worker !== void 0 && r.worker.add_lib(P.name, F);
  }, E = (P, F) => {
    y(!1), r.worker !== void 0 && r.worker.add_lib(P.name, F);
  }, S = (P) => {
    y(!1), r.worker !== void 0 && r.worker.remove_lib(P.name);
  }, A = (P, F) => {
    y(!1), r.worker !== void 0 && r.worker.add_lib(P.name, F);
  }, k = (P) => P.filter(
    (F) => F.name.toLowerCase().includes(t.toLowerCase()) || F.description.toLowerCase().includes(t.toLowerCase())
  ), R = k(h.available), N = k(h.installed), D = k(h.active);
  return /* @__PURE__ */ _.jsxs(
    bl,
    {
      title: "Manage Library",
      trigger: e,
      description: "Add or remove libraries to the current worker.",
      onOpenChange: b,
      open: g,
      setOpen: y,
      children: [
        /* @__PURE__ */ _.jsx(
          "input",
          {
            className: "filter-input styledinput",
            type: "text",
            placeholder: "Filter modules...",
            value: t,
            onChange: (P) => n(P.target.value)
          }
        ),
        /* @__PURE__ */ _.jsxs(
          "div",
          {
            className: "packagelist",
            style: { maxHeight: "70%", overflow: "auto" },
            children: [
              N.length > 0 && /* @__PURE__ */ _.jsx(
                "h3",
                {
                  onClick: () => {
                    d(!f);
                  },
                  children: "Installed"
                }
              ),
              f && N.map((P) => /* @__PURE__ */ _.jsx(
                AJ,
                {
                  availableModule: P,
                  on_add: x
                },
                P.name + P.source
              )),
              R.length > 0 && /* @__PURE__ */ _.jsx(
                "h3",
                {
                  onClick: () => {
                    u(!s);
                  },
                  children: "Available"
                }
              ),
              s && R.map((P) => /* @__PURE__ */ _.jsx(
                TJ,
                {
                  availableModule: P,
                  on_add: E
                },
                P.name + P.source
              )),
              D.length > 0 && /* @__PURE__ */ _.jsx(
                "h3",
                {
                  onClick: () => {
                    a(!i);
                  },
                  children: "Active"
                }
              ),
              i && D.map((P) => /* @__PURE__ */ _.jsx(
                kJ,
                {
                  availableModule: P,
                  on_remove: S,
                  on_update: A
                },
                P.name + P.source
              ))
            ]
          }
        )
      ]
    }
  );
}, OJ = ({
  ins: e
}) => {
  const [t, n] = C.useState(e.name), r = C.useContext(Xe), i = () => {
    r.worker && r.worker.remove_external_worker(e.uuid, e.nodeclassid);
  }, a = () => {
    r.worker && (r.worker.update_external_worker(e.uuid, e.nodeclassid, {
      name: t
    }), e.name = t);
  };
  return /* @__PURE__ */ _.jsx(_.Fragment, { children: /* @__PURE__ */ _.jsx(
    bl,
    {
      title: e.name,
      description: "Settings for" + e.name,
      trigger: /* @__PURE__ */ _.jsx("div", { children: "Settings" }),
      buttons: [
        {
          text: "Save",
          onClick: a,
          close: !0
        },
        {
          text: "Delete",
          onClick: i,
          close: !0
        }
      ],
      children: /* @__PURE__ */ _.jsx("div", { children: /* @__PURE__ */ _.jsxs("div", { children: [
        /* @__PURE__ */ _.jsx("label", { htmlFor: "name", children: "Name: " }),
        /* @__PURE__ */ _.jsx(
          "input",
          {
            type: "text",
            name: "name",
            value: t,
            onChange: (s) => n(s.target.value),
            className: "styledinput"
          }
        )
      ] }) })
    }
  ) });
}, NJ = ({
  ins: e,
  lib: t,
  filter: n = "",
  parentkey: r
}) => {
  const [i, a] = C.useState(!1), s = () => a(!i), u = t?.nodes?.filter(
    (f) => f.node_id.toLowerCase().includes(n.toLowerCase())
  );
  return /* @__PURE__ */ _.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ _.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: s,
        style: { cursor: "pointer" },
        title: e.name,
        children: [
          /* @__PURE__ */ _.jsx("div", { className: "shelftitle_text", children: e.name }),
          /* @__PURE__ */ _.jsx("div", { className: "expandicon " + (i ? "open" : "close"), children: /* @__PURE__ */ _.jsx($c, {}) })
        ]
      }
    ),
    /* @__PURE__ */ _.jsx("div", { className: "libnodecontainer " + (i ? "open" : "close"), children: /* @__PURE__ */ _.jsx("div", { className: "libnodecontainer_inner", children: i && /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
      /* @__PURE__ */ _.jsx("div", { className: "libnodeentry", title: e.uuid, children: /* @__PURE__ */ _.jsx(OJ, { ins: e }) }),
      t && /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
        u && /* @__PURE__ */ _.jsx(_.Fragment, { children: u.map((f) => /* @__PURE__ */ _.jsx(
          C3,
          {
            item: f
          },
          r + f.node_id
        )) }),
        t.subshelves.map((f) => /* @__PURE__ */ _.jsx(
          D1,
          {
            item: f,
            filter: n,
            parentkey: r + f.name
          },
          r + f.name
        ))
      ] })
    ] }) }) })
  ] });
}, MJ = ({
  item: e,
  mod: t,
  lib: n
}) => {
  const r = C.useContext(Xe), [i, a] = C.useState(!1), s = () => a(!i), u = () => {
    r.worker?.add_external_worker({
      module: t,
      cls_module: e.module,
      cls_name: e.class_name
    });
  }, f = (h) => {
    h.detail === 2 && u();
  }, d = e.name || e.module + "." + e.class_name;
  return /* @__PURE__ */ _.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ _.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: s,
        style: { cursor: "pointer" },
        title: d,
        children: [
          /* @__PURE__ */ _.jsx("div", { className: "shelftitle_text", children: d }),
          /* @__PURE__ */ _.jsx("div", { className: "expandicon " + (i ? "open" : "close"), children: /* @__PURE__ */ _.jsx($c, {}) })
        ]
      }
    ),
    /* @__PURE__ */ _.jsx("div", { className: "libnodecontainer " + (i ? "open" : "close"), children: /* @__PURE__ */ _.jsx("div", { className: "libnodecontainer_inner", children: i && /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
      /* @__PURE__ */ _.jsx(
        "div",
        {
          className: "libnodeentry",
          onClick: f,
          title: e.name,
          children: "New Instance"
        }
      ),
      e.instances.map((h) => /* @__PURE__ */ _.jsx(
        NJ,
        {
          ins: h,
          lib: n?.subshelves.find(
            (p) => p.name === h.uuid
          ),
          parentkey: h.uuid
        },
        h.uuid
      ))
    ] }) }) })
  ] });
}, DJ = ({
  externalworkermod: e,
  lib: t
}) => {
  const [n, r] = C.useState(!1), i = () => r(!n), a = n;
  return /* @__PURE__ */ _.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ _.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: i,
        style: { cursor: "pointer" },
        title: e.module,
        children: [
          /* @__PURE__ */ _.jsx("div", { className: "shelftitle_text", children: e.module }),
          /* @__PURE__ */ _.jsx("div", { className: "expandicon " + (a ? "open" : "close"), children: /* @__PURE__ */ _.jsx($c, {}) })
        ]
      }
    ),
    /* @__PURE__ */ _.jsx("div", { className: "libnodecontainer " + (a ? "open" : "close"), children: /* @__PURE__ */ _.jsx("div", { className: "libnodecontainer_inner", children: e.worker_classes.map((s) => /* @__PURE__ */ _.jsx(
      MJ,
      {
        item: s,
        mod: e.module,
        lib: t
      },
      s.module + s.class_name
    )) }) }),
    /* @__PURE__ */ _.jsx("hr", {})
  ] });
}, PJ = () => {
  const e = C.useContext(Xe), t = e.lib.libstate(), n = C.useContext(Xe), r = n.local_settings(
    (h) => h.view_settings.expand_lib
  ), i = n.local_settings(
    (h) => h.update_view_settings
  ), a = (h) => {
    i({ expand_lib: h });
  }, s = XY("m"), [u, f] = C.useState(""), d = e.worker?.state((h) => h.is_open) ?? !1;
  return /* @__PURE__ */ _.jsx(
    bM,
    {
      maxSize: s ? "100%" : "18.75rem",
      direction: s ? "down" : "right",
      containerClassName: "pos-left pos-top bg1 h-12",
      onExpandChange: a,
      expanded: r === void 0 ? !0 : r,
      children: /* @__PURE__ */ _.jsxs("div", { className: "libcontainer", children: [
        /* @__PURE__ */ _.jsxs("div", { className: "library", children: [
          /* @__PURE__ */ _.jsx("div", { className: "libtitle", children: "Lib" }),
          /* @__PURE__ */ _.jsx("hr", { className: "hr_prominent" }),
          /* @__PURE__ */ _.jsx(CJ, { filter: u, setFilter: f }),
          /* @__PURE__ */ _.jsx("div", { className: "vscrollcontainer", children: t.lib.shelves.filter((h) => h.name !== "_external_worker").map((h) => /* @__PURE__ */ _.jsx(
            D1,
            {
              item: h,
              filter: u,
              parentkey: h.name
            },
            h.name
          )) }),
          /* @__PURE__ */ _.jsx("hr", {}),
          /* @__PURE__ */ _.jsx("div", { className: "libtitle", children: "External Worker" }),
          /* @__PURE__ */ _.jsx("hr", { className: "hr_prominent" }),
          /* @__PURE__ */ _.jsx("div", { className: "vscrollcontainer", children: t.external_worker?.map((h) => /* @__PURE__ */ _.jsx(
            DJ,
            {
              externalworkermod: h,
              lib: t.lib.shelves.find(
                (p) => p.name === "_external_worker"
              )
            },
            h.module
          )) }),
          /* @__PURE__ */ _.jsx("hr", {})
        ] }),
        /* @__PURE__ */ _.jsx("div", { style: { paddingTop: "0.5rem" } }),
        d && /* @__PURE__ */ _.jsx("div", { className: "addlib", children: /* @__PURE__ */ _.jsx(RJ, { children: /* @__PURE__ */ _.jsx("button", { children: "Manage Libraries" }) }) })
      ] })
    }
  );
};
function zJ(e, t) {
  if (Object.is(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  if (e instanceof Map && t instanceof Map) {
    if (e.size !== t.size) return !1;
    for (const [r, i] of e)
      if (!Object.is(i, t.get(r)))
        return !1;
    return !0;
  }
  if (e instanceof Set && t instanceof Set) {
    if (e.size !== t.size) return !1;
    for (const r of e)
      if (!t.has(r))
        return !1;
    return !0;
  }
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
    return !1;
  for (const r of n)
    if (!Object.prototype.hasOwnProperty.call(t, r) || !Object.is(e[r], t[r]))
      return !1;
  return !0;
}
const { useRef: jJ } = Qt;
function IJ(e) {
  const t = jJ();
  return (n) => {
    const r = e(n);
    return zJ(t.current, r) ? t.current : t.current = r;
  };
}
var I1 = "Popover", [A3, Due] = Go(I1, [
  Pp
]), Wc = Pp(), [LJ, Wo] = A3(I1), T3 = (e) => {
  const {
    __scopePopover: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: a,
    modal: s = !1
  } = e, u = Wc(t), f = C.useRef(null), [d, h] = C.useState(!1), [p = !1, g] = yl({
    prop: r,
    defaultProp: i,
    onChange: a
  });
  return /* @__PURE__ */ _.jsx(o1, { ...u, children: /* @__PURE__ */ _.jsx(
    LJ,
    {
      scope: t,
      contentId: Li(),
      triggerRef: f,
      open: p,
      onOpenChange: g,
      onOpenToggle: C.useCallback(() => g((y) => !y), [g]),
      hasCustomAnchor: d,
      onCustomAnchorAdd: C.useCallback(() => h(!0), []),
      onCustomAnchorRemove: C.useCallback(() => h(!1), []),
      modal: s,
      children: n
    }
  ) });
};
T3.displayName = I1;
var R3 = "PopoverAnchor", FJ = C.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, i = Wo(R3, n), a = Wc(n), { onCustomAnchorAdd: s, onCustomAnchorRemove: u } = i;
    return C.useEffect(() => (s(), () => u()), [s, u]), /* @__PURE__ */ _.jsx(a1, { ...a, ...r, ref: t });
  }
);
FJ.displayName = R3;
var O3 = "PopoverTrigger", N3 = C.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, i = Wo(O3, n), a = Wc(n), s = Et(t, i.triggerRef), u = /* @__PURE__ */ _.jsx(
      vt.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": I3(i.open),
        ...r,
        ref: s,
        onClick: De(e.onClick, i.onOpenToggle)
      }
    );
    return i.hasCustomAnchor ? u : /* @__PURE__ */ _.jsx(a1, { asChild: !0, ...a, children: u });
  }
);
N3.displayName = O3;
var L1 = "PopoverPortal", [BJ, $J] = A3(L1, {
  forceMount: void 0
}), M3 = (e) => {
  const { __scopePopover: t, forceMount: n, children: r, container: i } = e, a = Wo(L1, t);
  return /* @__PURE__ */ _.jsx(BJ, { scope: t, forceMount: n, children: /* @__PURE__ */ _.jsx(Xi, { present: n || a.open, children: /* @__PURE__ */ _.jsx(Rb, { asChild: !0, container: i, children: r }) }) });
};
M3.displayName = L1;
var fl = "PopoverContent", D3 = C.forwardRef(
  (e, t) => {
    const n = $J(fl, e.__scopePopover), { forceMount: r = n.forceMount, ...i } = e, a = Wo(fl, e.__scopePopover);
    return /* @__PURE__ */ _.jsx(Xi, { present: r || a.open, children: a.modal ? /* @__PURE__ */ _.jsx(VJ, { ...i, ref: t }) : /* @__PURE__ */ _.jsx(UJ, { ...i, ref: t }) });
  }
);
D3.displayName = fl;
var HJ = /* @__PURE__ */ sl("PopoverContent.RemoveScroll"), VJ = C.forwardRef(
  (e, t) => {
    const n = Wo(fl, e.__scopePopover), r = C.useRef(null), i = Et(t, r), a = C.useRef(!1);
    return C.useEffect(() => {
      const s = r.current;
      if (s) return Nb(s);
    }, []), /* @__PURE__ */ _.jsx(Cp, { as: HJ, allowPinchZoom: !0, children: /* @__PURE__ */ _.jsx(
      P3,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: De(e.onCloseAutoFocus, (s) => {
          s.preventDefault(), a.current || n.triggerRef.current?.focus();
        }),
        onPointerDownOutside: De(
          e.onPointerDownOutside,
          (s) => {
            const u = s.detail.originalEvent, f = u.button === 0 && u.ctrlKey === !0, d = u.button === 2 || f;
            a.current = d;
          },
          { checkForDefaultPrevented: !1 }
        ),
        onFocusOutside: De(
          e.onFocusOutside,
          (s) => s.preventDefault(),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
), UJ = C.forwardRef(
  (e, t) => {
    const n = Wo(fl, e.__scopePopover), r = C.useRef(!1), i = C.useRef(!1);
    return /* @__PURE__ */ _.jsx(
      P3,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (a) => {
          e.onCloseAutoFocus?.(a), a.defaultPrevented || (r.current || n.triggerRef.current?.focus(), a.preventDefault()), r.current = !1, i.current = !1;
        },
        onInteractOutside: (a) => {
          e.onInteractOutside?.(a), a.defaultPrevented || (r.current = !0, a.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const s = a.target;
          n.triggerRef.current?.contains(s) && a.preventDefault(), a.detail.originalEvent.type === "focusin" && i.current && a.preventDefault();
        }
      }
    );
  }
), P3 = C.forwardRef(
  (e, t) => {
    const {
      __scopePopover: n,
      trapFocus: r,
      onOpenAutoFocus: i,
      onCloseAutoFocus: a,
      disableOutsidePointerEvents: s,
      onEscapeKeyDown: u,
      onPointerDownOutside: f,
      onFocusOutside: d,
      onInteractOutside: h,
      ...p
    } = e, g = Wo(fl, n), y = Wc(n);
    return Ob(), /* @__PURE__ */ _.jsx(
      _p,
      {
        asChild: !0,
        loop: !0,
        trapped: r,
        onMountAutoFocus: i,
        onUnmountAutoFocus: a,
        children: /* @__PURE__ */ _.jsx(
          Sp,
          {
            asChild: !0,
            disableOutsidePointerEvents: s,
            onInteractOutside: h,
            onEscapeKeyDown: u,
            onPointerDownOutside: f,
            onFocusOutside: d,
            onDismiss: () => g.onOpenChange(!1),
            children: /* @__PURE__ */ _.jsx(
              E2,
              {
                "data-state": I3(g.open),
                role: "dialog",
                id: g.contentId,
                ...y,
                ...p,
                ref: t,
                style: {
                  ...p.style,
                  "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                }
              }
            )
          }
        )
      }
    );
  }
), z3 = "PopoverClose", qJ = C.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, i = Wo(z3, n);
    return /* @__PURE__ */ _.jsx(
      vt.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: De(e.onClick, () => i.onOpenChange(!1))
      }
    );
  }
);
qJ.displayName = z3;
var YJ = "PopoverArrow", j3 = C.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, i = Wc(n);
    return /* @__PURE__ */ _.jsx(C2, { ...i, ...r, ref: t });
  }
);
j3.displayName = YJ;
function I3(e) {
  return e ? "open" : "closed";
}
var L3 = T3, F3 = N3, B3 = M3, $3 = D3, GJ = j3;
const XJ = ({
  iostore: e
}) => {
  const { full: t, preview: n } = e.valuestore(), r = JSON.stringify(t?.value || n?.value) || "";
  return `Bytes(${Math.round(3 * r.length / 4)})`;
}, WJ = {
  bytes: XJ
}, KJ = (e) => typeof e == "boolean" || e instanceof Boolean, ZJ = (e) => typeof e == "number" || e instanceof Number, QJ = (e) => typeof e == "bigint" || e instanceof BigInt, H3 = (e) => !!e && e instanceof Date, JJ = (e) => typeof e == "string" || e instanceof String, eee = (e) => Array.isArray(e), tee = (e) => typeof e == "object" && e !== null, V3 = (e) => !!e && e instanceof Object && typeof e == "function";
function Uh(e, t) {
  return t === void 0 && (t = !1), !e || t ? `"${e}"` : e;
}
function nee(e, t, n) {
  return n ? JSON.stringify(e) : t ? `"${e}"` : e;
}
function U3(e) {
  let {
    field: t,
    value: n,
    data: r,
    lastElement: i,
    openBracket: a,
    closeBracket: s,
    level: u,
    style: f,
    shouldExpandNode: d,
    clickToExpandNode: h,
    outerRef: p,
    beforeExpandChange: g
  } = e;
  const y = C.useRef(!1), [b, x] = C.useState(() => d(u, n, t)), E = C.useRef(null);
  C.useEffect(() => {
    y.current ? x(d(u, n, t)) : y.current = !0;
  }, [d]);
  const S = C.useId();
  if (r.length === 0)
    return ree({
      field: t,
      openBracket: a,
      closeBracket: s,
      lastElement: i,
      style: f
    });
  const A = b ? f.collapseIcon : f.expandIcon, k = b ? f.ariaLables.collapseJson : f.ariaLables.expandJson, R = u + 1, N = r.length - 1, D = (V) => {
    b !== V && (!g || g({
      level: u,
      value: n,
      field: t,
      newExpandValue: V
    })) && x(V);
  }, P = (V) => {
    if (V.key === "ArrowRight" || V.key === "ArrowLeft")
      V.preventDefault(), D(V.key === "ArrowRight");
    else if (V.key === "ArrowUp" || V.key === "ArrowDown") {
      V.preventDefault();
      const T = V.key === "ArrowUp" ? -1 : 1;
      if (!p.current) return;
      const $ = p.current.querySelectorAll("[role=button]");
      let H = -1;
      for (let j = 0; j < $.length; j++)
        if ($[j].tabIndex === 0) {
          H = j;
          break;
        }
      if (H < 0)
        return;
      const G = (H + T + $.length) % $.length;
      $[H].tabIndex = -1, $[G].tabIndex = 0, $[G].focus();
    }
  }, F = () => {
    var V;
    D(!b);
    const T = E.current;
    if (!T) return;
    const $ = (V = p.current) === null || V === void 0 ? void 0 : V.querySelector('[role=button][tabindex="0"]');
    $ && ($.tabIndex = -1), T.tabIndex = 0, T.focus();
  };
  return /* @__PURE__ */ C.createElement("div", {
    className: f.basicChildStyle,
    role: "treeitem",
    "aria-expanded": b,
    "aria-selected": void 0
  }, /* @__PURE__ */ C.createElement("span", {
    className: A,
    onClick: F,
    onKeyDown: P,
    role: "button",
    "aria-label": k,
    "aria-expanded": b,
    "aria-controls": b ? S : void 0,
    ref: E,
    tabIndex: u === 0 ? 0 : -1
  }), (t || t === "") && (h ? /* @__PURE__ */ C.createElement("span", {
    className: f.clickableLabel,
    onClick: F,
    onKeyDown: P
  }, Uh(t, f.quotesForFieldNames), ":") : /* @__PURE__ */ C.createElement("span", {
    className: f.label
  }, Uh(t, f.quotesForFieldNames), ":")), /* @__PURE__ */ C.createElement("span", {
    className: f.punctuation
  }, a), b ? /* @__PURE__ */ C.createElement("ul", {
    id: S,
    role: "group",
    className: f.childFieldsContainer
  }, r.map((V, T) => /* @__PURE__ */ C.createElement(q3, {
    key: V[0] || T,
    field: V[0],
    value: V[1],
    style: f,
    lastElement: T === N,
    level: R,
    shouldExpandNode: d,
    clickToExpandNode: h,
    outerRef: p
  }))) : /* @__PURE__ */ C.createElement("span", {
    className: f.collapsedContent,
    onClick: F,
    onKeyDown: P
  }), /* @__PURE__ */ C.createElement("span", {
    className: f.punctuation
  }, s), !i && /* @__PURE__ */ C.createElement("span", {
    className: f.punctuation
  }, ","));
}
function ree(e) {
  let {
    field: t,
    openBracket: n,
    closeBracket: r,
    lastElement: i,
    style: a
  } = e;
  return /* @__PURE__ */ C.createElement("div", {
    className: a.basicChildStyle,
    role: "treeitem",
    "aria-selected": void 0
  }, (t || t === "") && /* @__PURE__ */ C.createElement("span", {
    className: a.label
  }, Uh(t, a.quotesForFieldNames), ":"), /* @__PURE__ */ C.createElement("span", {
    className: a.punctuation
  }, n), /* @__PURE__ */ C.createElement("span", {
    className: a.punctuation
  }, r), !i && /* @__PURE__ */ C.createElement("span", {
    className: a.punctuation
  }, ","));
}
function iee(e) {
  let {
    field: t,
    value: n,
    style: r,
    lastElement: i,
    shouldExpandNode: a,
    clickToExpandNode: s,
    level: u,
    outerRef: f,
    beforeExpandChange: d
  } = e;
  return U3({
    field: t,
    value: n,
    lastElement: i || !1,
    level: u,
    openBracket: "{",
    closeBracket: "}",
    style: r,
    shouldExpandNode: a,
    clickToExpandNode: s,
    data: Object.keys(n).map((h) => [h, n[h]]),
    outerRef: f,
    beforeExpandChange: d
  });
}
function oee(e) {
  let {
    field: t,
    value: n,
    style: r,
    lastElement: i,
    level: a,
    shouldExpandNode: s,
    clickToExpandNode: u,
    outerRef: f,
    beforeExpandChange: d
  } = e;
  return U3({
    field: t,
    value: n,
    lastElement: i || !1,
    level: a,
    openBracket: "[",
    closeBracket: "]",
    style: r,
    shouldExpandNode: s,
    clickToExpandNode: u,
    data: n.map((h) => [void 0, h]),
    outerRef: f,
    beforeExpandChange: d
  });
}
function aee(e) {
  let {
    field: t,
    value: n,
    style: r,
    lastElement: i
  } = e, a, s = r.otherValue;
  return n === null ? (a = "null", s = r.nullValue) : n === void 0 ? (a = "undefined", s = r.undefinedValue) : JJ(n) ? (a = nee(n, !r.noQuotesForStringValues, r.stringifyStringValues), s = r.stringValue) : KJ(n) ? (a = n ? "true" : "false", s = r.booleanValue) : ZJ(n) ? (a = n.toString(), s = r.numberValue) : QJ(n) ? (a = `${n.toString()}n`, s = r.numberValue) : H3(n) ? a = n.toISOString() : V3(n) ? a = "function() { }" : a = n.toString(), /* @__PURE__ */ C.createElement("div", {
    className: r.basicChildStyle,
    role: "treeitem",
    "aria-selected": void 0
  }, (t || t === "") && /* @__PURE__ */ C.createElement("span", {
    className: r.label
  }, Uh(t, r.quotesForFieldNames), ":"), /* @__PURE__ */ C.createElement("span", {
    className: s
  }, a), !i && /* @__PURE__ */ C.createElement("span", {
    className: r.punctuation
  }, ","));
}
function q3(e) {
  const t = e.value;
  return eee(t) ? /* @__PURE__ */ C.createElement(oee, Object.assign({}, e)) : tee(t) && !H3(t) && !V3(t) ? /* @__PURE__ */ C.createElement(iee, Object.assign({}, e)) : /* @__PURE__ */ C.createElement(aee, Object.assign({}, e));
}
var it = { "container-light": "_2IvMF _GzYRV", "basic-element-style": "_2bkNM", "child-fields-container": "_1BXBN", "label-light": "_1MGIk", "clickable-label-light": "_2YKJg _1MGIk _1MFti", "punctuation-light": "_3uHL6 _3eOF8", "value-null-light": "_2T6PJ", "value-undefined-light": "_1Gho6", "value-string-light": "_vGjyY", "value-number-light": "_1bQdo", "value-boolean-light": "_3zQKs", "value-other-light": "_1xvuR", "collapse-icon-light": "_oLqym _f10Tu _1MFti _1LId0", "expand-icon-light": "_2AXVT _f10Tu _1MFti _1UmXx", "collapsed-content-light": "_2KJWg _1pNG9 _1MFti", "container-dark": "_11RoI _GzYRV", "expand-icon-dark": "_17H2C _f10Tu _1MFti _1UmXx", "collapse-icon-dark": "_3QHg2 _f10Tu _1MFti _1LId0", "collapsed-content-dark": "_3fDAz _1pNG9 _1MFti", "label-dark": "_2bSDX", "clickable-label-dark": "_1RQEj _2bSDX _1MFti", "punctuation-dark": "_gsbQL _3eOF8", "value-null-dark": "_LaAZe", "value-undefined-dark": "_GTKgm", "value-string-dark": "_Chy1W", "value-number-dark": "_2bveF", "value-boolean-dark": "_2vRm-", "value-other-dark": "_1prJR" };
const Y3 = {
  collapseJson: "collapse JSON",
  expandJson: "expand JSON"
}, lA = {
  container: it["container-light"],
  basicChildStyle: it["basic-element-style"],
  childFieldsContainer: it["child-fields-container"],
  label: it["label-light"],
  clickableLabel: it["clickable-label-light"],
  nullValue: it["value-null-light"],
  undefinedValue: it["value-undefined-light"],
  stringValue: it["value-string-light"],
  booleanValue: it["value-boolean-light"],
  numberValue: it["value-number-light"],
  otherValue: it["value-other-light"],
  punctuation: it["punctuation-light"],
  collapseIcon: it["collapse-icon-light"],
  expandIcon: it["expand-icon-light"],
  collapsedContent: it["collapsed-content-light"],
  noQuotesForStringValues: !1,
  quotesForFieldNames: !1,
  ariaLables: Y3,
  stringifyStringValues: !1
}, see = {
  container: it["container-dark"],
  basicChildStyle: it["basic-element-style"],
  childFieldsContainer: it["child-fields-container"],
  label: it["label-dark"],
  clickableLabel: it["clickable-label-dark"],
  nullValue: it["value-null-dark"],
  undefinedValue: it["value-undefined-dark"],
  stringValue: it["value-string-dark"],
  booleanValue: it["value-boolean-dark"],
  numberValue: it["value-number-dark"],
  otherValue: it["value-other-dark"],
  punctuation: it["punctuation-dark"],
  collapseIcon: it["collapse-icon-dark"],
  expandIcon: it["expand-icon-dark"],
  collapsedContent: it["collapsed-content-dark"],
  noQuotesForStringValues: !1,
  quotesForFieldNames: !1,
  ariaLables: Y3,
  stringifyStringValues: !1
}, lee = () => !0, uee = (e) => e < 1, cee = (e) => {
  let {
    data: t,
    style: n = lA,
    shouldExpandNode: r = lee,
    clickToExpandNode: i = !1,
    beforeExpandChange: a,
    ...s
  } = e;
  const u = C.useRef(null);
  return /* @__PURE__ */ C.createElement("div", Object.assign({
    "aria-label": "JSON view"
  }, s, {
    className: n.container,
    ref: u,
    role: "tree"
  }), /* @__PURE__ */ C.createElement(q3, {
    value: t,
    style: {
      ...lA,
      ...n
    },
    lastElement: !0,
    level: 0,
    shouldExpandNode: r,
    clickToExpandNode: i,
    outerRef: u,
    beforeExpandChange: a
  }));
};
function fee(e) {
  for (const t in e)
    if (Object.hasOwn(e, t))
      return !1;
  return !0;
}
function dee(e) {
  if (e == null || typeof e != "object")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t !== null && t !== Object.prototype ? !1 : fee(e);
}
const hee = ({ data: e }) => /* @__PURE__ */ _.jsx(
  cee,
  {
    data: dee(e) ? "" : e,
    style: see,
    shouldExpandNode: uee
  }
);
function G3(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (n = G3(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function Vt() {
  for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++) (e = arguments[n]) && (t = G3(e)) && (r && (r += " "), r += t);
  return r;
}
function Zi(e, t, n = void 0) {
  const r = {};
  for (const i in e) {
    const a = e[i];
    let s = "", u = !0;
    for (let f = 0; f < a.length; f += 1) {
      const d = a[f];
      d && (s += (u === !0 ? "" : " ") + t(d), u = !1, n && n[d] && (s += " " + n[d]));
    }
    r[i] = s;
  }
  return r;
}
const X3 = /* @__PURE__ */ C.createContext();
function Ia(e, ...t) {
  const n = new URL(`https://mui.com/production-error/?code=${e}`);
  return t.forEach((r) => n.searchParams.append("args[]", r)), `Minified MUI error #${e}; visit ${n} for the full message.`;
}
function wn(e) {
  if (typeof e != "string")
    throw new Error(Ia(7));
  return e.charAt(0).toUpperCase() + e.slice(1);
}
var Sy = { exports: {} }, ct = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uA;
function pee() {
  if (uA) return ct;
  uA = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.consumer"), s = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), f = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), h = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), g = Symbol.for("react.view_transition"), y = Symbol.for("react.client.reference");
  function b(x) {
    if (typeof x == "object" && x !== null) {
      var E = x.$$typeof;
      switch (E) {
        case e:
          switch (x = x.type, x) {
            case n:
            case i:
            case r:
            case f:
            case d:
            case g:
              return x;
            default:
              switch (x = x && x.$$typeof, x) {
                case s:
                case u:
                case p:
                case h:
                  return x;
                case a:
                  return x;
                default:
                  return E;
              }
          }
        case t:
          return E;
      }
    }
  }
  return ct.ContextConsumer = a, ct.ContextProvider = s, ct.Element = e, ct.ForwardRef = u, ct.Fragment = n, ct.Lazy = p, ct.Memo = h, ct.Portal = t, ct.Profiler = i, ct.StrictMode = r, ct.Suspense = f, ct.SuspenseList = d, ct.isContextConsumer = function(x) {
    return b(x) === a;
  }, ct.isContextProvider = function(x) {
    return b(x) === s;
  }, ct.isElement = function(x) {
    return typeof x == "object" && x !== null && x.$$typeof === e;
  }, ct.isForwardRef = function(x) {
    return b(x) === u;
  }, ct.isFragment = function(x) {
    return b(x) === n;
  }, ct.isLazy = function(x) {
    return b(x) === p;
  }, ct.isMemo = function(x) {
    return b(x) === h;
  }, ct.isPortal = function(x) {
    return b(x) === t;
  }, ct.isProfiler = function(x) {
    return b(x) === i;
  }, ct.isStrictMode = function(x) {
    return b(x) === r;
  }, ct.isSuspense = function(x) {
    return b(x) === f;
  }, ct.isSuspenseList = function(x) {
    return b(x) === d;
  }, ct.isValidElementType = function(x) {
    return typeof x == "string" || typeof x == "function" || x === n || x === i || x === r || x === f || x === d || typeof x == "object" && x !== null && (x.$$typeof === p || x.$$typeof === h || x.$$typeof === s || x.$$typeof === a || x.$$typeof === u || x.$$typeof === y || x.getModuleId !== void 0);
  }, ct.typeOf = b, ct;
}
var cA;
function mee() {
  return cA || (cA = 1, Sy.exports = /* @__PURE__ */ pee()), Sy.exports;
}
var W3 = /* @__PURE__ */ mee();
function Pi(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function K3(e) {
  if (/* @__PURE__ */ C.isValidElement(e) || W3.isValidElementType(e) || !Pi(e))
    return e;
  const t = {};
  return Object.keys(e).forEach((n) => {
    t[n] = K3(e[n]);
  }), t;
}
function er(e, t, n = {
  clone: !0
}) {
  const r = n.clone ? {
    ...e
  } : e;
  return Pi(e) && Pi(t) && Object.keys(t).forEach((i) => {
    /* @__PURE__ */ C.isValidElement(t[i]) || W3.isValidElementType(t[i]) ? r[i] = t[i] : Pi(t[i]) && // Avoid prototype pollution
    Object.prototype.hasOwnProperty.call(e, i) && Pi(e[i]) ? r[i] = er(e[i], t[i], n) : n.clone ? r[i] = Pi(t[i]) ? K3(t[i]) : t[i] : r[i] = t[i];
  }), r;
}
function nc(e, t) {
  return t ? er(e, t, {
    clone: !1
    // No need to clone deep, it's way faster.
  }) : e;
}
function gee(e, t) {
  if (!e.containerQueries)
    return t;
  const n = Object.keys(t).filter((r) => r.startsWith("@container")).sort((r, i) => {
    const a = /min-width:\s*([0-9.]+)/;
    return +(r.match(a)?.[1] || 0) - +(i.match(a)?.[1] || 0);
  });
  return n.length ? n.reduce((r, i) => {
    const a = t[i];
    return delete r[i], r[i] = a, r;
  }, {
    ...t
  }) : t;
}
function yee(e, t) {
  return t === "@" || t.startsWith("@") && (e.some((n) => t.startsWith(`@${n}`)) || !!t.match(/^@\d/));
}
function vee(e, t) {
  const n = t.match(/^@([^/]+)?\/?(.+)?$/);
  if (!n)
    return null;
  const [, r, i] = n, a = Number.isNaN(+r) ? r || 0 : +r;
  return e.containerQueries(i).up(a);
}
function bee(e) {
  const t = (a, s) => a.replace("@media", s ? `@container ${s}` : "@container");
  function n(a, s) {
    a.up = (...u) => t(e.breakpoints.up(...u), s), a.down = (...u) => t(e.breakpoints.down(...u), s), a.between = (...u) => t(e.breakpoints.between(...u), s), a.only = (...u) => t(e.breakpoints.only(...u), s), a.not = (...u) => {
      const f = t(e.breakpoints.not(...u), s);
      return f.includes("not all and") ? f.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or") : f;
    };
  }
  const r = {}, i = (a) => (n(r, a), r);
  return n(i), {
    ...e,
    containerQueries: i
  };
}
const Vp = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
}, fA = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (e) => `@media (min-width:${Vp[e]}px)`
}, xee = {
  containerQueries: (e) => ({
    up: (t) => {
      let n = typeof t == "number" ? t : Vp[t] || t;
      return typeof n == "number" && (n = `${n}px`), e ? `@container ${e} (min-width:${n})` : `@container (min-width:${n})`;
    }
  })
};
function Yi(e, t, n) {
  const r = e.theme || {};
  if (Array.isArray(t)) {
    const a = r.breakpoints || fA;
    return t.reduce((s, u, f) => (s[a.up(a.keys[f])] = n(t[f]), s), {});
  }
  if (typeof t == "object") {
    const a = r.breakpoints || fA;
    return Object.keys(t).reduce((s, u) => {
      if (yee(a.keys, u)) {
        const f = vee(r.containerQueries ? r : xee, u);
        f && (s[f] = n(t[u], u));
      } else if (Object.keys(a.values || Vp).includes(u)) {
        const f = a.up(u);
        s[f] = n(t[u], u);
      } else {
        const f = u;
        s[f] = t[f];
      }
      return s;
    }, {});
  }
  return n(t);
}
function wee(e = {}) {
  return e.keys?.reduce((n, r) => {
    const i = e.up(r);
    return n[i] = {}, n;
  }, {}) || {};
}
function See(e, t) {
  return e.reduce((n, r) => {
    const i = n[r];
    return (!i || Object.keys(i).length === 0) && delete n[r], n;
  }, t);
}
function Up(e, t, n = !0) {
  if (!t || typeof t != "string")
    return null;
  if (e && e.vars && n) {
    const r = `vars.${t}`.split(".").reduce((i, a) => i && i[a] ? i[a] : null, e);
    if (r != null)
      return r;
  }
  return t.split(".").reduce((r, i) => r && r[i] != null ? r[i] : null, e);
}
function qh(e, t, n, r = n) {
  let i;
  return typeof e == "function" ? i = e(n) : Array.isArray(e) ? i = e[n] || r : i = Up(e, n) || r, t && (i = t(i, r, e)), i;
}
function zt(e) {
  const {
    prop: t,
    cssProperty: n = e.prop,
    themeKey: r,
    transform: i
  } = e, a = (s) => {
    if (s[t] == null)
      return null;
    const u = s[t], f = s.theme, d = Up(f, r) || {};
    return Yi(s, u, (p) => {
      let g = qh(d, i, p);
      return p === g && typeof p == "string" && (g = qh(d, i, `${t}${p === "default" ? "" : wn(p)}`, p)), n === !1 ? g : {
        [n]: g
      };
    });
  };
  return a.propTypes = {}, a.filterProps = [t], a;
}
function _ee(e) {
  const t = {};
  return (n) => (t[n] === void 0 && (t[n] = e(n)), t[n]);
}
const Eee = {
  m: "margin",
  p: "padding"
}, Cee = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
}, dA = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
}, kee = _ee((e) => {
  if (e.length > 2)
    if (dA[e])
      e = dA[e];
    else
      return [e];
  const [t, n] = e.split(""), r = Eee[t], i = Cee[n] || "";
  return Array.isArray(i) ? i.map((a) => r + a) : [r + i];
}), F1 = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], B1 = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...F1, ...B1];
function Kc(e, t, n, r) {
  const i = Up(e, t, !0) ?? n;
  return typeof i == "number" || typeof i == "string" ? (a) => typeof a == "string" ? a : typeof i == "string" ? i.startsWith("var(") && a === 0 ? 0 : i.startsWith("var(") && a === 1 ? i : `calc(${a} * ${i})` : i * a : Array.isArray(i) ? (a) => {
    if (typeof a == "string")
      return a;
    const s = Math.abs(a), u = i[s];
    return a >= 0 ? u : typeof u == "number" ? -u : typeof u == "string" && u.startsWith("var(") ? `calc(-1 * ${u})` : `-${u}`;
  } : typeof i == "function" ? i : () => {
  };
}
function $1(e) {
  return Kc(e, "spacing", 8);
}
function Zc(e, t) {
  return typeof t == "string" || t == null ? t : e(t);
}
function Aee(e, t) {
  return (n) => e.reduce((r, i) => (r[i] = Zc(t, n), r), {});
}
function Tee(e, t, n, r) {
  if (!t.includes(n))
    return null;
  const i = kee(n), a = Aee(i, r), s = e[n];
  return Yi(e, s, a);
}
function Z3(e, t) {
  const n = $1(e.theme);
  return Object.keys(e).map((r) => Tee(e, t, r, n)).reduce(nc, {});
}
function Rt(e) {
  return Z3(e, F1);
}
Rt.propTypes = {};
Rt.filterProps = F1;
function Ot(e) {
  return Z3(e, B1);
}
Ot.propTypes = {};
Ot.filterProps = B1;
function qp(...e) {
  const t = e.reduce((r, i) => (i.filterProps.forEach((a) => {
    r[a] = i;
  }), r), {}), n = (r) => Object.keys(r).reduce((i, a) => t[a] ? nc(i, t[a](r)) : i, {});
  return n.propTypes = {}, n.filterProps = e.reduce((r, i) => r.concat(i.filterProps), []), n;
}
function mr(e) {
  return typeof e != "number" ? e : `${e}px solid`;
}
function vr(e, t) {
  return zt({
    prop: e,
    themeKey: "borders",
    transform: t
  });
}
const Ree = vr("border", mr), Oee = vr("borderTop", mr), Nee = vr("borderRight", mr), Mee = vr("borderBottom", mr), Dee = vr("borderLeft", mr), Pee = vr("borderColor"), zee = vr("borderTopColor"), jee = vr("borderRightColor"), Iee = vr("borderBottomColor"), Lee = vr("borderLeftColor"), Fee = vr("outline", mr), Bee = vr("outlineColor"), Yp = (e) => {
  if (e.borderRadius !== void 0 && e.borderRadius !== null) {
    const t = Kc(e.theme, "shape.borderRadius", 4), n = (r) => ({
      borderRadius: Zc(t, r)
    });
    return Yi(e, e.borderRadius, n);
  }
  return null;
};
Yp.propTypes = {};
Yp.filterProps = ["borderRadius"];
qp(Ree, Oee, Nee, Mee, Dee, Pee, zee, jee, Iee, Lee, Yp, Fee, Bee);
const Gp = (e) => {
  if (e.gap !== void 0 && e.gap !== null) {
    const t = Kc(e.theme, "spacing", 8), n = (r) => ({
      gap: Zc(t, r)
    });
    return Yi(e, e.gap, n);
  }
  return null;
};
Gp.propTypes = {};
Gp.filterProps = ["gap"];
const Xp = (e) => {
  if (e.columnGap !== void 0 && e.columnGap !== null) {
    const t = Kc(e.theme, "spacing", 8), n = (r) => ({
      columnGap: Zc(t, r)
    });
    return Yi(e, e.columnGap, n);
  }
  return null;
};
Xp.propTypes = {};
Xp.filterProps = ["columnGap"];
const Wp = (e) => {
  if (e.rowGap !== void 0 && e.rowGap !== null) {
    const t = Kc(e.theme, "spacing", 8), n = (r) => ({
      rowGap: Zc(t, r)
    });
    return Yi(e, e.rowGap, n);
  }
  return null;
};
Wp.propTypes = {};
Wp.filterProps = ["rowGap"];
const $ee = zt({
  prop: "gridColumn"
}), Hee = zt({
  prop: "gridRow"
}), Vee = zt({
  prop: "gridAutoFlow"
}), Uee = zt({
  prop: "gridAutoColumns"
}), qee = zt({
  prop: "gridAutoRows"
}), Yee = zt({
  prop: "gridTemplateColumns"
}), Gee = zt({
  prop: "gridTemplateRows"
}), Xee = zt({
  prop: "gridTemplateAreas"
}), Wee = zt({
  prop: "gridArea"
});
qp(Gp, Xp, Wp, $ee, Hee, Vee, Uee, qee, Yee, Gee, Xee, Wee);
function Qs(e, t) {
  return t === "grey" ? t : e;
}
const Kee = zt({
  prop: "color",
  themeKey: "palette",
  transform: Qs
}), Zee = zt({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: Qs
}), Qee = zt({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: Qs
});
qp(Kee, Zee, Qee);
function Kn(e) {
  return e <= 1 && e !== 0 ? `${e * 100}%` : e;
}
const Jee = zt({
  prop: "width",
  transform: Kn
}), H1 = (e) => {
  if (e.maxWidth !== void 0 && e.maxWidth !== null) {
    const t = (n) => {
      const r = e.theme?.breakpoints?.values?.[n] || Vp[n];
      return r ? e.theme?.breakpoints?.unit !== "px" ? {
        maxWidth: `${r}${e.theme.breakpoints.unit}`
      } : {
        maxWidth: r
      } : {
        maxWidth: Kn(n)
      };
    };
    return Yi(e, e.maxWidth, t);
  }
  return null;
};
H1.filterProps = ["maxWidth"];
const ete = zt({
  prop: "minWidth",
  transform: Kn
}), tte = zt({
  prop: "height",
  transform: Kn
}), nte = zt({
  prop: "maxHeight",
  transform: Kn
}), rte = zt({
  prop: "minHeight",
  transform: Kn
});
zt({
  prop: "size",
  cssProperty: "width",
  transform: Kn
});
zt({
  prop: "size",
  cssProperty: "height",
  transform: Kn
});
const ite = zt({
  prop: "boxSizing"
});
qp(Jee, H1, ete, tte, nte, rte, ite);
const Kp = {
  // borders
  border: {
    themeKey: "borders",
    transform: mr
  },
  borderTop: {
    themeKey: "borders",
    transform: mr
  },
  borderRight: {
    themeKey: "borders",
    transform: mr
  },
  borderBottom: {
    themeKey: "borders",
    transform: mr
  },
  borderLeft: {
    themeKey: "borders",
    transform: mr
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: mr
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: Yp
  },
  // palette
  color: {
    themeKey: "palette",
    transform: Qs
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: Qs
  },
  backgroundColor: {
    themeKey: "palette",
    transform: Qs
  },
  // spacing
  p: {
    style: Ot
  },
  pt: {
    style: Ot
  },
  pr: {
    style: Ot
  },
  pb: {
    style: Ot
  },
  pl: {
    style: Ot
  },
  px: {
    style: Ot
  },
  py: {
    style: Ot
  },
  padding: {
    style: Ot
  },
  paddingTop: {
    style: Ot
  },
  paddingRight: {
    style: Ot
  },
  paddingBottom: {
    style: Ot
  },
  paddingLeft: {
    style: Ot
  },
  paddingX: {
    style: Ot
  },
  paddingY: {
    style: Ot
  },
  paddingInline: {
    style: Ot
  },
  paddingInlineStart: {
    style: Ot
  },
  paddingInlineEnd: {
    style: Ot
  },
  paddingBlock: {
    style: Ot
  },
  paddingBlockStart: {
    style: Ot
  },
  paddingBlockEnd: {
    style: Ot
  },
  m: {
    style: Rt
  },
  mt: {
    style: Rt
  },
  mr: {
    style: Rt
  },
  mb: {
    style: Rt
  },
  ml: {
    style: Rt
  },
  mx: {
    style: Rt
  },
  my: {
    style: Rt
  },
  margin: {
    style: Rt
  },
  marginTop: {
    style: Rt
  },
  marginRight: {
    style: Rt
  },
  marginBottom: {
    style: Rt
  },
  marginLeft: {
    style: Rt
  },
  marginX: {
    style: Rt
  },
  marginY: {
    style: Rt
  },
  marginInline: {
    style: Rt
  },
  marginInlineStart: {
    style: Rt
  },
  marginInlineEnd: {
    style: Rt
  },
  marginBlock: {
    style: Rt
  },
  marginBlockStart: {
    style: Rt
  },
  marginBlockEnd: {
    style: Rt
  },
  // display
  displayPrint: {
    cssProperty: !1,
    transform: (e) => ({
      "@media print": {
        display: e
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: Gp
  },
  rowGap: {
    style: Wp
  },
  columnGap: {
    style: Xp
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: Kn
  },
  maxWidth: {
    style: H1
  },
  minWidth: {
    transform: Kn
  },
  height: {
    transform: Kn
  },
  maxHeight: {
    transform: Kn
  },
  minHeight: {
    transform: Kn
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: "font"
  },
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: !1,
    themeKey: "typography"
  }
};
function ote(...e) {
  const t = e.reduce((r, i) => r.concat(Object.keys(i)), []), n = new Set(t);
  return e.every((r) => n.size === Object.keys(r).length);
}
function ate(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function ste() {
  function e(n, r, i, a) {
    const s = {
      [n]: r,
      theme: i
    }, u = a[n];
    if (!u)
      return {
        [n]: r
      };
    const {
      cssProperty: f = n,
      themeKey: d,
      transform: h,
      style: p
    } = u;
    if (r == null)
      return null;
    if (d === "typography" && r === "inherit")
      return {
        [n]: r
      };
    const g = Up(i, d) || {};
    return p ? p(s) : Yi(s, r, (b) => {
      let x = qh(g, h, b);
      return b === x && typeof b == "string" && (x = qh(g, h, `${n}${b === "default" ? "" : wn(b)}`, b)), f === !1 ? x : {
        [f]: x
      };
    });
  }
  function t(n) {
    const {
      sx: r,
      theme: i = {}
    } = n || {};
    if (!r)
      return null;
    const a = i.unstable_sxConfig ?? Kp;
    function s(u) {
      let f = u;
      if (typeof u == "function")
        f = u(i);
      else if (typeof u != "object")
        return u;
      if (!f)
        return null;
      const d = wee(i.breakpoints), h = Object.keys(d);
      let p = d;
      return Object.keys(f).forEach((g) => {
        const y = ate(f[g], i);
        if (y != null)
          if (typeof y == "object")
            if (a[g])
              p = nc(p, e(g, y, i, a));
            else {
              const b = Yi({
                theme: i
              }, y, (x) => ({
                [g]: x
              }));
              ote(b, y) ? p[g] = t({
                sx: y,
                theme: i
              }) : p = nc(p, b);
            }
          else
            p = nc(p, e(g, y, i, a));
      }), gee(i, See(h, p));
    }
    return Array.isArray(r) ? r.map(s) : s(r);
  }
  return t;
}
const dl = ste();
dl.filterProps = ["sx"];
function ke() {
  return ke = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, ke.apply(null, arguments);
}
function lte(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function ute(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var cte = /* @__PURE__ */ function() {
  function e(n) {
    var r = this;
    this._insertTag = function(i) {
      var a;
      r.tags.length === 0 ? r.insertionPoint ? a = r.insertionPoint.nextSibling : r.prepend ? a = r.container.firstChild : a = r.before : a = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(i, a), r.tags.push(i);
    }, this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(r) {
    r.forEach(this._insertTag);
  }, t.insert = function(r) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(ute(this));
    var i = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var a = lte(i);
      try {
        a.insertRule(r, a.cssRules.length);
      } catch {
      }
    } else
      i.appendChild(document.createTextNode(r));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(r) {
      var i;
      return (i = r.parentNode) == null ? void 0 : i.removeChild(r);
    }), this.tags = [], this.ctr = 0;
  }, e;
}(), cn = "-ms-", Yh = "-moz-", tt = "-webkit-", Q3 = "comm", V1 = "rule", U1 = "decl", fte = "@import", J3 = "@keyframes", dte = "@layer", hte = Math.abs, Zp = String.fromCharCode, pte = Object.assign;
function mte(e, t) {
  return on(e, 0) ^ 45 ? (((t << 2 ^ on(e, 0)) << 2 ^ on(e, 1)) << 2 ^ on(e, 2)) << 2 ^ on(e, 3) : 0;
}
function e5(e) {
  return e.trim();
}
function gte(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function nt(e, t, n) {
  return e.replace(t, n);
}
function Yv(e, t) {
  return e.indexOf(t);
}
function on(e, t) {
  return e.charCodeAt(t) | 0;
}
function Sc(e, t, n) {
  return e.slice(t, n);
}
function Zr(e) {
  return e.length;
}
function q1(e) {
  return e.length;
}
function $d(e, t) {
  return t.push(e), e;
}
function yte(e, t) {
  return e.map(t).join("");
}
var Qp = 1, hl = 1, t5 = 0, jn = 0, Ut = 0, El = "";
function Jp(e, t, n, r, i, a, s) {
  return { value: e, root: t, parent: n, type: r, props: i, children: a, line: Qp, column: hl, length: s, return: "" };
}
function Lu(e, t) {
  return pte(Jp("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function vte() {
  return Ut;
}
function bte() {
  return Ut = jn > 0 ? on(El, --jn) : 0, hl--, Ut === 10 && (hl = 1, Qp--), Ut;
}
function tr() {
  return Ut = jn < t5 ? on(El, jn++) : 0, hl++, Ut === 10 && (hl = 1, Qp++), Ut;
}
function ii() {
  return on(El, jn);
}
function ch() {
  return jn;
}
function Qc(e, t) {
  return Sc(El, e, t);
}
function _c(e) {
  switch (e) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function n5(e) {
  return Qp = hl = 1, t5 = Zr(El = e), jn = 0, [];
}
function r5(e) {
  return El = "", e;
}
function fh(e) {
  return e5(Qc(jn - 1, Gv(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function xte(e) {
  for (; (Ut = ii()) && Ut < 33; )
    tr();
  return _c(e) > 2 || _c(Ut) > 3 ? "" : " ";
}
function wte(e, t) {
  for (; --t && tr() && !(Ut < 48 || Ut > 102 || Ut > 57 && Ut < 65 || Ut > 70 && Ut < 97); )
    ;
  return Qc(e, ch() + (t < 6 && ii() == 32 && tr() == 32));
}
function Gv(e) {
  for (; tr(); )
    switch (Ut) {
      // ] ) " '
      case e:
        return jn;
      // " '
      case 34:
      case 39:
        e !== 34 && e !== 39 && Gv(Ut);
        break;
      // (
      case 40:
        e === 41 && Gv(e);
        break;
      // \
      case 92:
        tr();
        break;
    }
  return jn;
}
function Ste(e, t) {
  for (; tr() && e + Ut !== 57; )
    if (e + Ut === 84 && ii() === 47)
      break;
  return "/*" + Qc(t, jn - 1) + "*" + Zp(e === 47 ? e : tr());
}
function _te(e) {
  for (; !_c(ii()); )
    tr();
  return Qc(e, jn);
}
function Ete(e) {
  return r5(dh("", null, null, null, [""], e = n5(e), 0, [0], e));
}
function dh(e, t, n, r, i, a, s, u, f) {
  for (var d = 0, h = 0, p = s, g = 0, y = 0, b = 0, x = 1, E = 1, S = 1, A = 0, k = "", R = i, N = a, D = r, P = k; E; )
    switch (b = A, A = tr()) {
      // (
      case 40:
        if (b != 108 && on(P, p - 1) == 58) {
          Yv(P += nt(fh(A), "&", "&\f"), "&\f") != -1 && (S = -1);
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        P += fh(A);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        P += xte(b);
        break;
      // \
      case 92:
        P += wte(ch() - 1, 7);
        continue;
      // /
      case 47:
        switch (ii()) {
          case 42:
          case 47:
            $d(Cte(Ste(tr(), ch()), t, n), f);
            break;
          default:
            P += "/";
        }
        break;
      // {
      case 123 * x:
        u[d++] = Zr(P) * S;
      // } ; \0
      case 125 * x:
      case 59:
      case 0:
        switch (A) {
          // \0 }
          case 0:
          case 125:
            E = 0;
          // ;
          case 59 + h:
            S == -1 && (P = nt(P, /\f/g, "")), y > 0 && Zr(P) - p && $d(y > 32 ? pA(P + ";", r, n, p - 1) : pA(nt(P, " ", "") + ";", r, n, p - 2), f);
            break;
          // @ ;
          case 59:
            P += ";";
          // { rule/at-rule
          default:
            if ($d(D = hA(P, t, n, d, h, i, u, k, R = [], N = [], p), a), A === 123)
              if (h === 0)
                dh(P, t, D, D, R, a, p, u, N);
              else
                switch (g === 99 && on(P, 3) === 110 ? 100 : g) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    dh(e, D, D, r && $d(hA(e, D, D, 0, 0, i, u, k, i, R = [], p), N), i, N, p, u, r ? R : N);
                    break;
                  default:
                    dh(P, D, D, D, [""], N, 0, u, N);
                }
        }
        d = h = y = 0, x = S = 1, k = P = "", p = s;
        break;
      // :
      case 58:
        p = 1 + Zr(P), y = b;
      default:
        if (x < 1) {
          if (A == 123)
            --x;
          else if (A == 125 && x++ == 0 && bte() == 125)
            continue;
        }
        switch (P += Zp(A), A * x) {
          // &
          case 38:
            S = h > 0 ? 1 : (P += "\f", -1);
            break;
          // ,
          case 44:
            u[d++] = (Zr(P) - 1) * S, S = 1;
            break;
          // @
          case 64:
            ii() === 45 && (P += fh(tr())), g = ii(), h = p = Zr(k = P += _te(ch())), A++;
            break;
          // -
          case 45:
            b === 45 && Zr(P) == 2 && (x = 0);
        }
    }
  return a;
}
function hA(e, t, n, r, i, a, s, u, f, d, h) {
  for (var p = i - 1, g = i === 0 ? a : [""], y = q1(g), b = 0, x = 0, E = 0; b < r; ++b)
    for (var S = 0, A = Sc(e, p + 1, p = hte(x = s[b])), k = e; S < y; ++S)
      (k = e5(x > 0 ? g[S] + " " + A : nt(A, /&\f/g, g[S]))) && (f[E++] = k);
  return Jp(e, t, n, i === 0 ? V1 : u, f, d, h);
}
function Cte(e, t, n) {
  return Jp(e, t, n, Q3, Zp(vte()), Sc(e, 2, -2), 0);
}
function pA(e, t, n, r) {
  return Jp(e, t, n, U1, Sc(e, 0, r), Sc(e, r + 1, -1), r);
}
function Js(e, t) {
  for (var n = "", r = q1(e), i = 0; i < r; i++)
    n += t(e[i], i, e, t) || "";
  return n;
}
function kte(e, t, n, r) {
  switch (e.type) {
    case dte:
      if (e.children.length) break;
    case fte:
    case U1:
      return e.return = e.return || e.value;
    case Q3:
      return "";
    case J3:
      return e.return = e.value + "{" + Js(e.children, r) + "}";
    case V1:
      e.value = e.props.join(",");
  }
  return Zr(n = Js(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
}
function Ate(e) {
  var t = q1(e);
  return function(n, r, i, a) {
    for (var s = "", u = 0; u < t; u++)
      s += e[u](n, r, i, a) || "";
    return s;
  };
}
function Tte(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function i5(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var Rte = function(t, n, r) {
  for (var i = 0, a = 0; i = a, a = ii(), i === 38 && a === 12 && (n[r] = 1), !_c(a); )
    tr();
  return Qc(t, jn);
}, Ote = function(t, n) {
  var r = -1, i = 44;
  do
    switch (_c(i)) {
      case 0:
        i === 38 && ii() === 12 && (n[r] = 1), t[r] += Rte(jn - 1, n, r);
        break;
      case 2:
        t[r] += fh(i);
        break;
      case 4:
        if (i === 44) {
          t[++r] = ii() === 58 ? "&\f" : "", n[r] = t[r].length;
          break;
        }
      // fallthrough
      default:
        t[r] += Zp(i);
    }
  while (i = tr());
  return t;
}, Nte = function(t, n) {
  return r5(Ote(n5(t), n));
}, mA = /* @__PURE__ */ new WeakMap(), Mte = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var n = t.value, r = t.parent, i = t.column === r.column && t.line === r.line; r.type !== "rule"; )
      if (r = r.parent, !r) return;
    if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !mA.get(r)) && !i) {
      mA.set(t, !0);
      for (var a = [], s = Nte(n, a), u = r.props, f = 0, d = 0; f < s.length; f++)
        for (var h = 0; h < u.length; h++, d++)
          t.props[d] = a[f] ? s[f].replace(/&\f/g, u[h]) : u[h] + " " + s[f];
    }
  }
}, Dte = function(t) {
  if (t.type === "decl") {
    var n = t.value;
    // charcode for l
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
};
function o5(e, t) {
  switch (mte(e, t)) {
    // color-adjust
    case 5103:
      return tt + "print-" + e + e;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return tt + e + e;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return tt + e + Yh + e + cn + e + e;
    // flex, flex-direction
    case 6828:
    case 4268:
      return tt + e + cn + e + e;
    // order
    case 6165:
      return tt + e + cn + "flex-" + e + e;
    // align-items
    case 5187:
      return tt + e + nt(e, /(\w+).+(:[^]+)/, tt + "box-$1$2" + cn + "flex-$1$2") + e;
    // align-self
    case 5443:
      return tt + e + cn + "flex-item-" + nt(e, /flex-|-self/, "") + e;
    // align-content
    case 4675:
      return tt + e + cn + "flex-line-pack" + nt(e, /align-content|flex-|-self/, "") + e;
    // flex-shrink
    case 5548:
      return tt + e + cn + nt(e, "shrink", "negative") + e;
    // flex-basis
    case 5292:
      return tt + e + cn + nt(e, "basis", "preferred-size") + e;
    // flex-grow
    case 6060:
      return tt + "box-" + nt(e, "-grow", "") + tt + e + cn + nt(e, "grow", "positive") + e;
    // transition
    case 4554:
      return tt + nt(e, /([^-])(transform)/g, "$1" + tt + "$2") + e;
    // cursor
    case 6187:
      return nt(nt(nt(e, /(zoom-|grab)/, tt + "$1"), /(image-set)/, tt + "$1"), e, "") + e;
    // background, background-image
    case 5495:
    case 3959:
      return nt(e, /(image-set\([^]*)/, tt + "$1$`$1");
    // justify-content
    case 4968:
      return nt(nt(e, /(.+:)(flex-)?(.*)/, tt + "box-pack:$3" + cn + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + tt + e + e;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return nt(e, /(.+)-inline(.+)/, tt + "$1$2") + e;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Zr(e) - 1 - t > 6) switch (on(e, t + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (on(e, t + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return nt(e, /(.+:)(.+)-([^]+)/, "$1" + tt + "$2-$3$1" + Yh + (on(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        // (s)tretch
        case 115:
          return ~Yv(e, "stretch") ? o5(nt(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    // position: sticky
    case 4949:
      if (on(e, t + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (on(e, Zr(e) - 3 - (~Yv(e, "!important") && 10))) {
        // stic(k)y
        case 107:
          return nt(e, ":", ":" + tt) + e;
        // (inline-)?fl(e)x
        case 101:
          return nt(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + tt + (on(e, 14) === 45 ? "inline-" : "") + "box$3$1" + tt + "$2$3$1" + cn + "$2box$3") + e;
      }
      break;
    // writing-mode
    case 5936:
      switch (on(e, t + 11)) {
        // vertical-l(r)
        case 114:
          return tt + e + cn + nt(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        // vertical-r(l)
        case 108:
          return tt + e + cn + nt(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        // horizontal(-)tb
        case 45:
          return tt + e + cn + nt(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return tt + e + cn + e + e;
  }
  return e;
}
var Pte = function(t, n, r, i) {
  if (t.length > -1 && !t.return) switch (t.type) {
    case U1:
      t.return = o5(t.value, t.length);
      break;
    case J3:
      return Js([Lu(t, {
        value: nt(t.value, "@", "@" + tt)
      })], i);
    case V1:
      if (t.length) return yte(t.props, function(a) {
        switch (gte(a, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ":read-only":
          case ":read-write":
            return Js([Lu(t, {
              props: [nt(a, /:(read-\w+)/, ":" + Yh + "$1")]
            })], i);
          // :placeholder
          case "::placeholder":
            return Js([Lu(t, {
              props: [nt(a, /:(plac\w+)/, ":" + tt + "input-$1")]
            }), Lu(t, {
              props: [nt(a, /:(plac\w+)/, ":" + Yh + "$1")]
            }), Lu(t, {
              props: [nt(a, /:(plac\w+)/, cn + "input-$1")]
            })], i);
        }
        return "";
      });
  }
}, zte = [Pte], jte = function(t) {
  var n = t.key;
  if (n === "css") {
    var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(r, function(x) {
      var E = x.getAttribute("data-emotion");
      E.indexOf(" ") !== -1 && (document.head.appendChild(x), x.setAttribute("data-s", ""));
    });
  }
  var i = t.stylisPlugins || zte, a = {}, s, u = [];
  s = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(x) {
      for (var E = x.getAttribute("data-emotion").split(" "), S = 1; S < E.length; S++)
        a[E[S]] = !0;
      u.push(x);
    }
  );
  var f, d = [Mte, Dte];
  {
    var h, p = [kte, Tte(function(x) {
      h.insert(x);
    })], g = Ate(d.concat(i, p)), y = function(E) {
      return Js(Ete(E), g);
    };
    f = function(E, S, A, k) {
      h = A, y(E ? E + "{" + S.styles + "}" : S.styles), k && (b.inserted[S.name] = !0);
    };
  }
  var b = {
    key: n,
    sheet: new cte({
      key: n,
      container: s,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: a,
    registered: {},
    insert: f
  };
  return b.sheet.hydrate(u), b;
}, _y = { exports: {} }, rt = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var gA;
function Ite() {
  if (gA) return rt;
  gA = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, a = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, u = e ? Symbol.for("react.context") : 60110, f = e ? Symbol.for("react.async_mode") : 60111, d = e ? Symbol.for("react.concurrent_mode") : 60111, h = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, g = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, b = e ? Symbol.for("react.lazy") : 60116, x = e ? Symbol.for("react.block") : 60121, E = e ? Symbol.for("react.fundamental") : 60117, S = e ? Symbol.for("react.responder") : 60118, A = e ? Symbol.for("react.scope") : 60119;
  function k(N) {
    if (typeof N == "object" && N !== null) {
      var D = N.$$typeof;
      switch (D) {
        case t:
          switch (N = N.type, N) {
            case f:
            case d:
            case r:
            case a:
            case i:
            case p:
              return N;
            default:
              switch (N = N && N.$$typeof, N) {
                case u:
                case h:
                case b:
                case y:
                case s:
                  return N;
                default:
                  return D;
              }
          }
        case n:
          return D;
      }
    }
  }
  function R(N) {
    return k(N) === d;
  }
  return rt.AsyncMode = f, rt.ConcurrentMode = d, rt.ContextConsumer = u, rt.ContextProvider = s, rt.Element = t, rt.ForwardRef = h, rt.Fragment = r, rt.Lazy = b, rt.Memo = y, rt.Portal = n, rt.Profiler = a, rt.StrictMode = i, rt.Suspense = p, rt.isAsyncMode = function(N) {
    return R(N) || k(N) === f;
  }, rt.isConcurrentMode = R, rt.isContextConsumer = function(N) {
    return k(N) === u;
  }, rt.isContextProvider = function(N) {
    return k(N) === s;
  }, rt.isElement = function(N) {
    return typeof N == "object" && N !== null && N.$$typeof === t;
  }, rt.isForwardRef = function(N) {
    return k(N) === h;
  }, rt.isFragment = function(N) {
    return k(N) === r;
  }, rt.isLazy = function(N) {
    return k(N) === b;
  }, rt.isMemo = function(N) {
    return k(N) === y;
  }, rt.isPortal = function(N) {
    return k(N) === n;
  }, rt.isProfiler = function(N) {
    return k(N) === a;
  }, rt.isStrictMode = function(N) {
    return k(N) === i;
  }, rt.isSuspense = function(N) {
    return k(N) === p;
  }, rt.isValidElementType = function(N) {
    return typeof N == "string" || typeof N == "function" || N === r || N === d || N === a || N === i || N === p || N === g || typeof N == "object" && N !== null && (N.$$typeof === b || N.$$typeof === y || N.$$typeof === s || N.$$typeof === u || N.$$typeof === h || N.$$typeof === E || N.$$typeof === S || N.$$typeof === A || N.$$typeof === x);
  }, rt.typeOf = k, rt;
}
var yA;
function Lte() {
  return yA || (yA = 1, _y.exports = Ite()), _y.exports;
}
var Ey, vA;
function Fte() {
  if (vA) return Ey;
  vA = 1;
  var e = Lte(), t = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0
  }, n = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0
  }, r = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
  }, i = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
  }, a = {};
  a[e.ForwardRef] = r, a[e.Memo] = i;
  function s(b) {
    return e.isMemo(b) ? i : a[b.$$typeof] || t;
  }
  var u = Object.defineProperty, f = Object.getOwnPropertyNames, d = Object.getOwnPropertySymbols, h = Object.getOwnPropertyDescriptor, p = Object.getPrototypeOf, g = Object.prototype;
  function y(b, x, E) {
    if (typeof x != "string") {
      if (g) {
        var S = p(x);
        S && S !== g && y(b, S, E);
      }
      var A = f(x);
      d && (A = A.concat(d(x)));
      for (var k = s(b), R = s(x), N = 0; N < A.length; ++N) {
        var D = A[N];
        if (!n[D] && !(E && E[D]) && !(R && R[D]) && !(k && k[D])) {
          var P = h(x, D);
          try {
            u(b, D, P);
          } catch {
          }
        }
      }
    }
    return b;
  }
  return Ey = y, Ey;
}
Fte();
var Bte = !0;
function a5(e, t, n) {
  var r = "";
  return n.split(" ").forEach(function(i) {
    e[i] !== void 0 ? t.push(e[i] + ";") : i && (r += i + " ");
  }), r;
}
var Y1 = function(t, n, r) {
  var i = t.key + "-" + n.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (r === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  Bte === !1) && t.registered[i] === void 0 && (t.registered[i] = n.styles);
}, s5 = function(t, n, r) {
  Y1(t, n, r);
  var i = t.key + "-" + n.name;
  if (t.inserted[n.name] === void 0) {
    var a = n;
    do
      t.insert(n === a ? "." + i : "", a, t.sheet, !0), a = a.next;
    while (a !== void 0);
  }
};
function $te(e) {
  for (var t = 0, n, r = 0, i = e.length; i >= 4; ++r, i -= 4)
    n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (i) {
    case 3:
      t ^= (e.charCodeAt(r + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(r + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var Hte = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, Vte = /[A-Z]|^ms/g, Ute = /_EMO_([^_]+?)_([^]*?)_EMO_/g, l5 = function(t) {
  return t.charCodeAt(1) === 45;
}, bA = function(t) {
  return t != null && typeof t != "boolean";
}, Cy = /* @__PURE__ */ i5(function(e) {
  return l5(e) ? e : e.replace(Vte, "-$&").toLowerCase();
}), xA = function(t, n) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(Ute, function(r, i, a) {
          return Qr = {
            name: i,
            styles: a,
            next: Qr
          }, i;
        });
  }
  return Hte[t] !== 1 && !l5(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
};
function Ec(e, t, n) {
  if (n == null)
    return "";
  var r = n;
  if (r.__emotion_styles !== void 0)
    return r;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var i = n;
      if (i.anim === 1)
        return Qr = {
          name: i.name,
          styles: i.styles,
          next: Qr
        }, i.name;
      var a = n;
      if (a.styles !== void 0) {
        var s = a.next;
        if (s !== void 0)
          for (; s !== void 0; )
            Qr = {
              name: s.name,
              styles: s.styles,
              next: Qr
            }, s = s.next;
        var u = a.styles + ";";
        return u;
      }
      return qte(e, t, n);
    }
    case "function": {
      if (e !== void 0) {
        var f = Qr, d = n(e);
        return Qr = f, Ec(e, t, d);
      }
      break;
    }
  }
  var h = n;
  if (t == null)
    return h;
  var p = t[h];
  return p !== void 0 ? p : h;
}
function qte(e, t, n) {
  var r = "";
  if (Array.isArray(n))
    for (var i = 0; i < n.length; i++)
      r += Ec(e, t, n[i]) + ";";
  else
    for (var a in n) {
      var s = n[a];
      if (typeof s != "object") {
        var u = s;
        t != null && t[u] !== void 0 ? r += a + "{" + t[u] + "}" : bA(u) && (r += Cy(a) + ":" + xA(a, u) + ";");
      } else if (Array.isArray(s) && typeof s[0] == "string" && (t == null || t[s[0]] === void 0))
        for (var f = 0; f < s.length; f++)
          bA(s[f]) && (r += Cy(a) + ":" + xA(a, s[f]) + ";");
      else {
        var d = Ec(e, t, s);
        switch (a) {
          case "animation":
          case "animationName": {
            r += Cy(a) + ":" + d + ";";
            break;
          }
          default:
            r += a + "{" + d + "}";
        }
      }
    }
  return r;
}
var wA = /label:\s*([^\s;{]+)\s*(;|$)/g, Qr;
function em(e, t, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var r = !0, i = "";
  Qr = void 0;
  var a = e[0];
  if (a == null || a.raw === void 0)
    r = !1, i += Ec(n, t, a);
  else {
    var s = a;
    i += s[0];
  }
  for (var u = 1; u < e.length; u++)
    if (i += Ec(n, t, e[u]), r) {
      var f = a;
      i += f[u];
    }
  wA.lastIndex = 0;
  for (var d = "", h; (h = wA.exec(i)) !== null; )
    d += "-" + h[1];
  var p = $te(i) + d;
  return {
    name: p,
    styles: i,
    next: Qr
  };
}
var Yte = function(t) {
  return t();
}, Gte = gh.useInsertionEffect ? gh.useInsertionEffect : !1, u5 = Gte || Yte, c5 = /* @__PURE__ */ C.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ jte({
    key: "css"
  }) : null
);
c5.Provider;
var f5 = function(t) {
  return /* @__PURE__ */ C.forwardRef(function(n, r) {
    var i = C.useContext(c5);
    return t(n, i, r);
  });
}, d5 = /* @__PURE__ */ C.createContext({}), G1 = {}.hasOwnProperty, Xv = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", Xte = function(t, n) {
  var r = {};
  for (var i in n)
    G1.call(n, i) && (r[i] = n[i]);
  return r[Xv] = t, r;
}, Wte = function(t) {
  var n = t.cache, r = t.serialized, i = t.isStringTag;
  return Y1(n, r, i), u5(function() {
    return s5(n, r, i);
  }), null;
}, Kte = /* @__PURE__ */ f5(function(e, t, n) {
  var r = e.css;
  typeof r == "string" && t.registered[r] !== void 0 && (r = t.registered[r]);
  var i = e[Xv], a = [r], s = "";
  typeof e.className == "string" ? s = a5(t.registered, a, e.className) : e.className != null && (s = e.className + " ");
  var u = em(a, void 0, C.useContext(d5));
  s += t.key + "-" + u.name;
  var f = {};
  for (var d in e)
    G1.call(e, d) && d !== "css" && d !== Xv && (f[d] = e[d]);
  return f.className = s, n && (f.ref = n), /* @__PURE__ */ C.createElement(C.Fragment, null, /* @__PURE__ */ C.createElement(Wte, {
    cache: t,
    serialized: u,
    isStringTag: typeof i == "string"
  }), /* @__PURE__ */ C.createElement(i, f));
}), Zte = Kte, Ee = function(t, n) {
  var r = arguments;
  if (n == null || !G1.call(n, "css"))
    return C.createElement.apply(void 0, r);
  var i = r.length, a = new Array(i);
  a[0] = Zte, a[1] = Xte(t, n);
  for (var s = 2; s < i; s++)
    a[s] = r[s];
  return C.createElement.apply(null, a);
};
(function(e) {
  var t;
  t || (t = e.JSX || (e.JSX = {}));
})(Ee || (Ee = {}));
function X1() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return em(t);
}
function tm() {
  var e = X1.apply(void 0, arguments), t = "animation-" + e.name;
  return {
    name: t,
    styles: "@keyframes " + t + "{" + e.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
var Qte = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, Jte = /* @__PURE__ */ i5(
  function(e) {
    return Qte.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
  }
  /* Z+1 */
), ene = Jte, tne = function(t) {
  return t !== "theme";
}, SA = function(t) {
  return typeof t == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  t.charCodeAt(0) > 96 ? ene : tne;
}, _A = function(t, n, r) {
  var i;
  if (n) {
    var a = n.shouldForwardProp;
    i = t.__emotion_forwardProp && a ? function(s) {
      return t.__emotion_forwardProp(s) && a(s);
    } : a;
  }
  return typeof i != "function" && r && (i = t.__emotion_forwardProp), i;
}, nne = function(t) {
  var n = t.cache, r = t.serialized, i = t.isStringTag;
  return Y1(n, r, i), u5(function() {
    return s5(n, r, i);
  }), null;
}, rne = function e(t, n) {
  var r = t.__emotion_real === t, i = r && t.__emotion_base || t, a, s;
  n !== void 0 && (a = n.label, s = n.target);
  var u = _A(t, n, r), f = u || SA(i), d = !f("as");
  return function() {
    var h = arguments, p = r && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
    if (a !== void 0 && p.push("label:" + a + ";"), h[0] == null || h[0].raw === void 0)
      p.push.apply(p, h);
    else {
      var g = h[0];
      p.push(g[0]);
      for (var y = h.length, b = 1; b < y; b++)
        p.push(h[b], g[b]);
    }
    var x = f5(function(E, S, A) {
      var k = d && E.as || i, R = "", N = [], D = E;
      if (E.theme == null) {
        D = {};
        for (var P in E)
          D[P] = E[P];
        D.theme = C.useContext(d5);
      }
      typeof E.className == "string" ? R = a5(S.registered, N, E.className) : E.className != null && (R = E.className + " ");
      var F = em(p.concat(N), S.registered, D);
      R += S.key + "-" + F.name, s !== void 0 && (R += " " + s);
      var V = d && u === void 0 ? SA(k) : f, T = {};
      for (var $ in E)
        d && $ === "as" || V($) && (T[$] = E[$]);
      return T.className = R, A && (T.ref = A), /* @__PURE__ */ C.createElement(C.Fragment, null, /* @__PURE__ */ C.createElement(nne, {
        cache: S,
        serialized: F,
        isStringTag: typeof k == "string"
      }), /* @__PURE__ */ C.createElement(k, T));
    });
    return x.displayName = a !== void 0 ? a : "Styled(" + (typeof i == "string" ? i : i.displayName || i.name || "Component") + ")", x.defaultProps = t.defaultProps, x.__emotion_real = x, x.__emotion_base = i, x.__emotion_styles = p, x.__emotion_forwardProp = u, Object.defineProperty(x, "toString", {
      value: function() {
        return "." + s;
      }
    }), x.withComponent = function(E, S) {
      var A = e(E, ke({}, n, S, {
        shouldForwardProp: _A(x, S, !0)
      }));
      return A.apply(void 0, p);
    }, x;
  };
}, ine = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], Wv = rne.bind(null);
ine.forEach(function(e) {
  Wv[e] = Wv(e);
});
function one(e, t) {
  return Wv(e, t);
}
function ane(e, t) {
  Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles));
}
const EA = [];
function CA(e) {
  return EA[0] = e, em(EA);
}
const sne = (e) => {
  const t = Object.keys(e).map((n) => ({
    key: n,
    val: e[n]
  })) || [];
  return t.sort((n, r) => n.val - r.val), t.reduce((n, r) => ({
    ...n,
    [r.key]: r.val
  }), {});
};
function lne(e) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: t = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit: n = "px",
    step: r = 5,
    ...i
  } = e, a = sne(t), s = Object.keys(a);
  function u(g) {
    return `@media (min-width:${typeof t[g] == "number" ? t[g] : g}${n})`;
  }
  function f(g) {
    return `@media (max-width:${(typeof t[g] == "number" ? t[g] : g) - r / 100}${n})`;
  }
  function d(g, y) {
    const b = s.indexOf(y);
    return `@media (min-width:${typeof t[g] == "number" ? t[g] : g}${n}) and (max-width:${(b !== -1 && typeof t[s[b]] == "number" ? t[s[b]] : y) - r / 100}${n})`;
  }
  function h(g) {
    return s.indexOf(g) + 1 < s.length ? d(g, s[s.indexOf(g) + 1]) : u(g);
  }
  function p(g) {
    const y = s.indexOf(g);
    return y === 0 ? u(s[1]) : y === s.length - 1 ? f(s[y]) : d(g, s[s.indexOf(g) + 1]).replace("@media", "@media not all and");
  }
  return {
    keys: s,
    values: a,
    up: u,
    down: f,
    between: d,
    only: h,
    not: p,
    unit: n,
    ...i
  };
}
const une = {
  borderRadius: 4
};
function h5(e = 8, t = $1({
  spacing: e
})) {
  if (e.mui)
    return e;
  const n = (...r) => (r.length === 0 ? [1] : r).map((a) => {
    const s = t(a);
    return typeof s == "number" ? `${s}px` : s;
  }).join(" ");
  return n.mui = !0, n;
}
function cne(e, t) {
  const n = this;
  if (n.vars) {
    if (!n.colorSchemes?.[e] || typeof n.getColorSchemeSelector != "function")
      return {};
    let r = n.getColorSchemeSelector(e);
    return r === "&" ? t : ((r.includes("data-") || r.includes(".")) && (r = `*:where(${r.replace(/\s*&$/, "")}) &`), {
      [r]: t
    });
  }
  return n.palette.mode === e ? t : {};
}
function p5(e = {}, ...t) {
  const {
    breakpoints: n = {},
    palette: r = {},
    spacing: i,
    shape: a = {},
    ...s
  } = e, u = lne(n), f = h5(i);
  let d = er({
    breakpoints: u,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: {
      mode: "light",
      ...r
    },
    spacing: f,
    shape: {
      ...une,
      ...a
    }
  }, s);
  return d = bee(d), d.applyStyles = cne, d = t.reduce((h, p) => er(h, p), d), d.unstable_sxConfig = {
    ...Kp,
    ...s?.unstable_sxConfig
  }, d.unstable_sx = function(p) {
    return dl({
      sx: p,
      theme: this
    });
  }, d;
}
const kA = (e) => e, fne = () => {
  let e = kA;
  return {
    configure(t) {
      e = t;
    },
    generate(t) {
      return e(t);
    },
    reset() {
      e = kA;
    }
  };
}, dne = fne(), hne = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function ci(e, t, n = "Mui") {
  const r = hne[t];
  return r ? `${n}-${r}` : `${dne.generate(e)}-${t}`;
}
function fi(e, t, n = "Mui") {
  const r = {};
  return t.forEach((i) => {
    r[i] = ci(e, i, n);
  }), r;
}
function m5(e) {
  const {
    variants: t,
    ...n
  } = e, r = {
    variants: t,
    style: CA(n),
    isProcessed: !0
  };
  return r.style === n || t && t.forEach((i) => {
    typeof i.style != "function" && (i.style = CA(i.style));
  }), r;
}
const pne = p5();
function ky(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
function mne(e) {
  return e ? (t, n) => n[e] : null;
}
function gne(e, t, n) {
  e.theme = bne(e.theme) ? n : e.theme[t] || e.theme;
}
function hh(e, t) {
  const n = typeof t == "function" ? t(e) : t;
  if (Array.isArray(n))
    return n.flatMap((r) => hh(e, r));
  if (Array.isArray(n?.variants)) {
    let r;
    if (n.isProcessed)
      r = n.style;
    else {
      const {
        variants: i,
        ...a
      } = n;
      r = a;
    }
    return g5(e, n.variants, [r]);
  }
  return n?.isProcessed ? n.style : n;
}
function g5(e, t, n = []) {
  let r;
  e: for (let i = 0; i < t.length; i += 1) {
    const a = t[i];
    if (typeof a.props == "function") {
      if (r ?? (r = {
        ...e,
        ...e.ownerState,
        ownerState: e.ownerState
      }), !a.props(r))
        continue;
    } else
      for (const s in a.props)
        if (e[s] !== a.props[s] && e.ownerState?.[s] !== a.props[s])
          continue e;
    typeof a.style == "function" ? (r ?? (r = {
      ...e,
      ...e.ownerState,
      ownerState: e.ownerState
    }), n.push(a.style(r))) : n.push(a.style);
  }
  return n;
}
function yne(e = {}) {
  const {
    themeId: t,
    defaultTheme: n = pne,
    rootShouldForwardProp: r = ky,
    slotShouldForwardProp: i = ky
  } = e;
  function a(u) {
    gne(u, t, n);
  }
  return (u, f = {}) => {
    ane(u, (N) => N.filter((D) => D !== dl));
    const {
      name: d,
      slot: h,
      skipVariantsResolver: p,
      skipSx: g,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: y = mne(wne(h)),
      ...b
    } = f, x = p !== void 0 ? p : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      h && h !== "Root" && h !== "root" || !1
    ), E = g || !1;
    let S = ky;
    h === "Root" || h === "root" ? S = r : h ? S = i : xne(u) && (S = void 0);
    const A = one(u, {
      shouldForwardProp: S,
      label: vne(),
      ...b
    }), k = (N) => {
      if (typeof N == "function" && N.__emotion_real !== N)
        return function(P) {
          return hh(P, N);
        };
      if (Pi(N)) {
        const D = m5(N);
        return D.variants ? function(F) {
          return hh(F, D);
        } : D.style;
      }
      return N;
    }, R = (...N) => {
      const D = [], P = N.map(k), F = [];
      if (D.push(a), d && y && F.push(function(H) {
        const j = H.theme.components?.[d]?.styleOverrides;
        if (!j)
          return null;
        const U = {};
        for (const z in j)
          U[z] = hh(H, j[z]);
        return y(H, U);
      }), d && !x && F.push(function(H) {
        const j = H.theme?.components?.[d]?.variants;
        return j ? g5(H, j) : null;
      }), E || F.push(dl), Array.isArray(P[0])) {
        const $ = P.shift(), H = new Array(D.length).fill(""), G = new Array(F.length).fill("");
        let j;
        j = [...H, ...$, ...G], j.raw = [...H, ...$.raw, ...G], D.unshift(j);
      }
      const V = [...D, ...P, ...F], T = A(...V);
      return u.muiName && (T.muiName = u.muiName), T;
    };
    return A.withConfig && (R.withConfig = A.withConfig), R;
  };
}
function vne(e, t) {
  return void 0;
}
function bne(e) {
  for (const t in e)
    return !1;
  return !0;
}
function xne(e) {
  return typeof e == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  e.charCodeAt(0) > 96;
}
function wne(e) {
  return e && e.charAt(0).toLowerCase() + e.slice(1);
}
function Kv(e, t) {
  const n = {
    ...t
  };
  for (const r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      const i = r;
      if (i === "components" || i === "slots")
        n[i] = {
          ...e[i],
          ...n[i]
        };
      else if (i === "componentsProps" || i === "slotProps") {
        const a = e[i], s = t[i];
        if (!s)
          n[i] = a || {};
        else if (!a)
          n[i] = s;
        else {
          n[i] = {
            ...s
          };
          for (const u in a)
            if (Object.prototype.hasOwnProperty.call(a, u)) {
              const f = u;
              n[i][f] = Kv(a[f], s[f]);
            }
        }
      } else n[i] === void 0 && (n[i] = e[i]);
    }
  return n;
}
const Sne = typeof window < "u" ? C.useLayoutEffect : C.useEffect;
function _ne(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
  return Math.max(t, Math.min(e, n));
}
function W1(e, t = 0, n = 1) {
  return _ne(e, t, n);
}
function Ene(e) {
  e = e.slice(1);
  const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, "g");
  let n = e.match(t);
  return n && n[0].length === 1 && (n = n.map((r) => r + r)), n ? `rgb${n.length === 4 ? "a" : ""}(${n.map((r, i) => i < 3 ? parseInt(r, 16) : Math.round(parseInt(r, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
}
function Yo(e) {
  if (e.type)
    return e;
  if (e.charAt(0) === "#")
    return Yo(Ene(e));
  const t = e.indexOf("("), n = e.substring(0, t);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(n))
    throw new Error(Ia(9, e));
  let r = e.substring(t + 1, e.length - 1), i;
  if (n === "color") {
    if (r = r.split(" "), i = r.shift(), r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)), !["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(i))
      throw new Error(Ia(10, i));
  } else
    r = r.split(",");
  return r = r.map((a) => parseFloat(a)), {
    type: n,
    values: r,
    colorSpace: i
  };
}
const Cne = (e) => {
  const t = Yo(e);
  return t.values.slice(0, 3).map((n, r) => t.type.includes("hsl") && r !== 0 ? `${n}%` : n).join(" ");
}, Yu = (e, t) => {
  try {
    return Cne(e);
  } catch {
    return e;
  }
};
function nm(e) {
  const {
    type: t,
    colorSpace: n
  } = e;
  let {
    values: r
  } = e;
  return t.includes("rgb") ? r = r.map((i, a) => a < 3 ? parseInt(i, 10) : i) : t.includes("hsl") && (r[1] = `${r[1]}%`, r[2] = `${r[2]}%`), t.includes("color") ? r = `${n} ${r.join(" ")}` : r = `${r.join(", ")}`, `${t}(${r})`;
}
function y5(e) {
  e = Yo(e);
  const {
    values: t
  } = e, n = t[0], r = t[1] / 100, i = t[2] / 100, a = r * Math.min(i, 1 - i), s = (d, h = (d + n / 30) % 12) => i - a * Math.max(Math.min(h - 3, 9 - h, 1), -1);
  let u = "rgb";
  const f = [Math.round(s(0) * 255), Math.round(s(8) * 255), Math.round(s(4) * 255)];
  return e.type === "hsla" && (u += "a", f.push(t[3])), nm({
    type: u,
    values: f
  });
}
function Zv(e) {
  e = Yo(e);
  let t = e.type === "hsl" || e.type === "hsla" ? Yo(y5(e)).values : e.values;
  return t = t.map((n) => (e.type !== "color" && (n /= 255), n <= 0.03928 ? n / 12.92 : ((n + 0.055) / 1.055) ** 2.4)), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3));
}
function kne(e, t) {
  const n = Zv(e), r = Zv(t);
  return (Math.max(n, r) + 0.05) / (Math.min(n, r) + 0.05);
}
function Cc(e, t) {
  return e = Yo(e), t = W1(t), (e.type === "rgb" || e.type === "hsl") && (e.type += "a"), e.type === "color" ? e.values[3] = `/${t}` : e.values[3] = t, nm(e);
}
function Hd(e, t, n) {
  try {
    return Cc(e, t);
  } catch {
    return e;
  }
}
function rm(e, t) {
  if (e = Yo(e), t = W1(t), e.type.includes("hsl"))
    e.values[2] *= 1 - t;
  else if (e.type.includes("rgb") || e.type.includes("color"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] *= 1 - t;
  return nm(e);
}
function ht(e, t, n) {
  try {
    return rm(e, t);
  } catch {
    return e;
  }
}
function im(e, t) {
  if (e = Yo(e), t = W1(t), e.type.includes("hsl"))
    e.values[2] += (100 - e.values[2]) * t;
  else if (e.type.includes("rgb"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (255 - e.values[n]) * t;
  else if (e.type.includes("color"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (1 - e.values[n]) * t;
  return nm(e);
}
function pt(e, t, n) {
  try {
    return im(e, t);
  } catch {
    return e;
  }
}
function Ane(e, t = 0.15) {
  return Zv(e) > 0.5 ? rm(e, t) : im(e, t);
}
function Vd(e, t, n) {
  try {
    return Ane(e, t);
  } catch {
    return e;
  }
}
function ph(e) {
  const t = C.useRef(e);
  return Sne(() => {
    t.current = e;
  }), C.useRef((...n) => (
    // @ts-expect-error hide `this`
    (0, t.current)(...n)
  )).current;
}
function Qv(...e) {
  const t = C.useRef(void 0), n = C.useCallback((r) => {
    const i = e.map((a) => {
      if (a == null)
        return null;
      if (typeof a == "function") {
        const s = a, u = s(r);
        return typeof u == "function" ? u : () => {
          s(null);
        };
      }
      return a.current = r, () => {
        a.current = null;
      };
    });
    return () => {
      i.forEach((a) => a?.());
    };
  }, e);
  return C.useMemo(() => e.every((r) => r == null) ? null : (r) => {
    t.current && (t.current(), t.current = void 0), r != null && (t.current = n(r));
  }, e);
}
const AA = {};
function v5(e, t) {
  const n = C.useRef(AA);
  return n.current === AA && (n.current = e(t)), n;
}
const Tne = [];
function Rne(e) {
  C.useEffect(e, Tne);
}
class K1 {
  constructor() {
    Ru(this, "currentId", null);
    Ru(this, "clear", () => {
      this.currentId !== null && (clearTimeout(this.currentId), this.currentId = null);
    });
    Ru(this, "disposeEffect", () => this.clear);
  }
  static create() {
    return new K1();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(t, n) {
    this.clear(), this.currentId = setTimeout(() => {
      this.currentId = null, n();
    }, t);
  }
}
function One() {
  const e = v5(K1.create).current;
  return Rne(e.disposeEffect), e;
}
function TA(e) {
  try {
    return e.matches(":focus-visible");
  } catch {
  }
  return !1;
}
function Nne(e) {
  return typeof e == "string";
}
function Mne(e, t, n) {
  return e === void 0 || Nne(e) ? t : {
    ...t,
    ownerState: {
      ...t.ownerState,
      ...n
    }
  };
}
function Dne(e, t = []) {
  if (e === void 0)
    return {};
  const n = {};
  return Object.keys(e).filter((r) => r.match(/^on[A-Z]/) && typeof e[r] == "function" && !t.includes(r)).forEach((r) => {
    n[r] = e[r];
  }), n;
}
function RA(e) {
  if (e === void 0)
    return {};
  const t = {};
  return Object.keys(e).filter((n) => !(n.match(/^on[A-Z]/) && typeof e[n] == "function")).forEach((n) => {
    t[n] = e[n];
  }), t;
}
function Pne(e) {
  const {
    getSlotProps: t,
    additionalProps: n,
    externalSlotProps: r,
    externalForwardedProps: i,
    className: a
  } = e;
  if (!t) {
    const y = Vt(n?.className, a, i?.className, r?.className), b = {
      ...n?.style,
      ...i?.style,
      ...r?.style
    }, x = {
      ...n,
      ...i,
      ...r
    };
    return y.length > 0 && (x.className = y), Object.keys(b).length > 0 && (x.style = b), {
      props: x,
      internalRef: void 0
    };
  }
  const s = Dne({
    ...i,
    ...r
  }), u = RA(r), f = RA(i), d = t(s), h = Vt(d?.className, n?.className, a, i?.className, r?.className), p = {
    ...d?.style,
    ...n?.style,
    ...i?.style,
    ...r?.style
  }, g = {
    ...d,
    ...n,
    ...f,
    ...u
  };
  return h.length > 0 && (g.className = h), Object.keys(p).length > 0 && (g.style = p), {
    props: g,
    internalRef: d.ref
  };
}
function zne(e, t, n) {
  return typeof e == "function" ? e(t, n) : e;
}
const jne = /* @__PURE__ */ C.createContext(void 0);
function Ine(e) {
  const {
    theme: t,
    name: n,
    props: r
  } = e;
  if (!t || !t.components || !t.components[n])
    return r;
  const i = t.components[n];
  return i.defaultProps ? Kv(i.defaultProps, r) : !i.styleOverrides && !i.variants ? Kv(i, r) : r;
}
function Lne({
  props: e,
  name: t
}) {
  const n = C.useContext(jne);
  return Ine({
    props: e,
    name: t,
    theme: {
      components: n
    }
  });
}
const OA = {
  theme: void 0
};
function Fne(e) {
  let t, n;
  return function(i) {
    let a = t;
    return (a === void 0 || i.theme !== n) && (OA.theme = i.theme, a = m5(e(OA)), t = a, n = i.theme), a;
  };
}
function Bne(e = "") {
  function t(...r) {
    if (!r.length)
      return "";
    const i = r[0];
    return typeof i == "string" && !i.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/) ? `, var(--${e ? `${e}-` : ""}${i}${t(...r.slice(1))})` : `, ${i}`;
  }
  return (r, ...i) => `var(--${e ? `${e}-` : ""}${r}${t(...i)})`;
}
const NA = (e, t, n, r = []) => {
  let i = e;
  t.forEach((a, s) => {
    s === t.length - 1 ? Array.isArray(i) ? i[Number(a)] = n : i && typeof i == "object" && (i[a] = n) : i && typeof i == "object" && (i[a] || (i[a] = r.includes(a) ? [] : {}), i = i[a]);
  });
}, $ne = (e, t, n) => {
  function r(i, a = [], s = []) {
    Object.entries(i).forEach(([u, f]) => {
      (!n || n && !n([...a, u])) && f != null && (typeof f == "object" && Object.keys(f).length > 0 ? r(f, [...a, u], Array.isArray(f) ? [...s, u] : s) : t([...a, u], f, s));
    });
  }
  r(e);
}, Hne = (e, t) => typeof t == "number" ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((r) => e.includes(r)) || e[e.length - 1].toLowerCase().includes("opacity") ? t : `${t}px` : t;
function Ay(e, t) {
  const {
    prefix: n,
    shouldSkipGeneratingVar: r
  } = t || {}, i = {}, a = {}, s = {};
  return $ne(
    e,
    (u, f, d) => {
      if ((typeof f == "string" || typeof f == "number") && (!r || !r(u, f))) {
        const h = `--${n ? `${n}-` : ""}${u.join("-")}`, p = Hne(u, f);
        Object.assign(i, {
          [h]: p
        }), NA(a, u, `var(${h})`, d), NA(s, u, `var(${h}, ${p})`, d);
      }
    },
    (u) => u[0] === "vars"
    // skip 'vars/*' paths
  ), {
    css: i,
    vars: a,
    varsWithDefaults: s
  };
}
function Vne(e, t = {}) {
  const {
    getSelector: n = E,
    disableCssColorScheme: r,
    colorSchemeSelector: i
  } = t, {
    colorSchemes: a = {},
    components: s,
    defaultColorScheme: u = "light",
    ...f
  } = e, {
    vars: d,
    css: h,
    varsWithDefaults: p
  } = Ay(f, t);
  let g = p;
  const y = {}, {
    [u]: b,
    ...x
  } = a;
  if (Object.entries(x || {}).forEach(([k, R]) => {
    const {
      vars: N,
      css: D,
      varsWithDefaults: P
    } = Ay(R, t);
    g = er(g, P), y[k] = {
      css: D,
      vars: N
    };
  }), b) {
    const {
      css: k,
      vars: R,
      varsWithDefaults: N
    } = Ay(b, t);
    g = er(g, N), y[u] = {
      css: k,
      vars: R
    };
  }
  function E(k, R) {
    let N = i;
    if (i === "class" && (N = ".%s"), i === "data" && (N = "[data-%s]"), i?.startsWith("data-") && !i.includes("%s") && (N = `[${i}="%s"]`), k) {
      if (N === "media")
        return e.defaultColorScheme === k ? ":root" : {
          [`@media (prefers-color-scheme: ${a[k]?.palette?.mode || k})`]: {
            ":root": R
          }
        };
      if (N)
        return e.defaultColorScheme === k ? `:root, ${N.replace("%s", String(k))}` : N.replace("%s", String(k));
    }
    return ":root";
  }
  return {
    vars: g,
    generateThemeVars: () => {
      let k = {
        ...d
      };
      return Object.entries(y).forEach(([, {
        vars: R
      }]) => {
        k = er(k, R);
      }), k;
    },
    generateStyleSheets: () => {
      const k = [], R = e.defaultColorScheme || "light";
      function N(F, V) {
        Object.keys(V).length && k.push(typeof F == "string" ? {
          [F]: {
            ...V
          }
        } : F);
      }
      N(n(void 0, {
        ...h
      }), h);
      const {
        [R]: D,
        ...P
      } = y;
      if (D) {
        const {
          css: F
        } = D, V = a[R]?.palette?.mode, T = !r && V ? {
          colorScheme: V,
          ...F
        } : {
          ...F
        };
        N(n(R, {
          ...T
        }), T);
      }
      return Object.entries(P).forEach(([F, {
        css: V
      }]) => {
        const T = a[F]?.palette?.mode, $ = !r && T ? {
          colorScheme: T,
          ...V
        } : {
          ...V
        };
        N(n(F, {
          ...$
        }), $);
      }), k;
    }
  };
}
function Une(e) {
  return function(n) {
    return e === "media" ? `@media (prefers-color-scheme: ${n})` : e ? e.startsWith("data-") && !e.includes("%s") ? `[${e}="${n}"] &` : e === "class" ? `.${n} &` : e === "data" ? `[data-${n}] &` : `${e.replace("%s", n)} &` : "&";
  };
}
const kc = {
  black: "#000",
  white: "#fff"
}, qne = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
}, Ds = {
  50: "#f3e5f5",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  700: "#7b1fa2"
}, Ps = {
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  700: "#d32f2f",
  800: "#c62828"
}, Fu = {
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  700: "#f57c00",
  900: "#e65100"
}, zs = {
  50: "#e3f2fd",
  200: "#90caf9",
  400: "#42a5f5",
  700: "#1976d2",
  800: "#1565c0"
}, js = {
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  700: "#0288d1",
  900: "#01579b"
}, Is = {
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20"
};
function b5() {
  return {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: kc.white,
      default: kc.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
}
const Yne = b5();
function x5() {
  return {
    text: {
      primary: kc.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: kc.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
}
const MA = x5();
function DA(e, t, n, r) {
  const i = r.light || r, a = r.dark || r * 1.5;
  e[t] || (e.hasOwnProperty(n) ? e[t] = e[n] : t === "light" ? e.light = im(e.main, i) : t === "dark" && (e.dark = rm(e.main, a)));
}
function Gne(e = "light") {
  return e === "dark" ? {
    main: zs[200],
    light: zs[50],
    dark: zs[400]
  } : {
    main: zs[700],
    light: zs[400],
    dark: zs[800]
  };
}
function Xne(e = "light") {
  return e === "dark" ? {
    main: Ds[200],
    light: Ds[50],
    dark: Ds[400]
  } : {
    main: Ds[500],
    light: Ds[300],
    dark: Ds[700]
  };
}
function Wne(e = "light") {
  return e === "dark" ? {
    main: Ps[500],
    light: Ps[300],
    dark: Ps[700]
  } : {
    main: Ps[700],
    light: Ps[400],
    dark: Ps[800]
  };
}
function Kne(e = "light") {
  return e === "dark" ? {
    main: js[400],
    light: js[300],
    dark: js[700]
  } : {
    main: js[700],
    light: js[500],
    dark: js[900]
  };
}
function Zne(e = "light") {
  return e === "dark" ? {
    main: Is[400],
    light: Is[300],
    dark: Is[700]
  } : {
    main: Is[800],
    light: Is[500],
    dark: Is[900]
  };
}
function Qne(e = "light") {
  return e === "dark" ? {
    main: Fu[400],
    light: Fu[300],
    dark: Fu[700]
  } : {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: Fu[500],
    dark: Fu[900]
  };
}
function Z1(e) {
  const {
    mode: t = "light",
    contrastThreshold: n = 3,
    tonalOffset: r = 0.2,
    ...i
  } = e, a = e.primary || Gne(t), s = e.secondary || Xne(t), u = e.error || Wne(t), f = e.info || Kne(t), d = e.success || Zne(t), h = e.warning || Qne(t);
  function p(x) {
    return kne(x, MA.text.primary) >= n ? MA.text.primary : Yne.text.primary;
  }
  const g = ({
    color: x,
    name: E,
    mainShade: S = 500,
    lightShade: A = 300,
    darkShade: k = 700
  }) => {
    if (x = {
      ...x
    }, !x.main && x[S] && (x.main = x[S]), !x.hasOwnProperty("main"))
      throw new Error(Ia(11, E ? ` (${E})` : "", S));
    if (typeof x.main != "string")
      throw new Error(Ia(12, E ? ` (${E})` : "", JSON.stringify(x.main)));
    return DA(x, "light", A, r), DA(x, "dark", k, r), x.contrastText || (x.contrastText = p(x.main)), x;
  };
  let y;
  return t === "light" ? y = b5() : t === "dark" && (y = x5()), er({
    // A collection of common colors.
    common: {
      ...kc
    },
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode: t,
    // The colors used to represent primary interface elements for a user.
    primary: g({
      color: a,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: g({
      color: s,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: g({
      color: u,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: g({
      color: h,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: g({
      color: f,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: g({
      color: d,
      name: "success"
    }),
    // The grey colors.
    grey: qne,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold: n,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText: p,
    // Generate a rich color object.
    augmentColor: g,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset: r,
    // The light and dark mode object.
    ...y
  }, i);
}
function Jne(e) {
  const t = {};
  return Object.entries(e).forEach((r) => {
    const [i, a] = r;
    typeof a == "object" && (t[i] = `${a.fontStyle ? `${a.fontStyle} ` : ""}${a.fontVariant ? `${a.fontVariant} ` : ""}${a.fontWeight ? `${a.fontWeight} ` : ""}${a.fontStretch ? `${a.fontStretch} ` : ""}${a.fontSize || ""}${a.lineHeight ? `/${a.lineHeight} ` : ""}${a.fontFamily || ""}`);
  }), t;
}
function ere(e, t) {
  return {
    toolbar: {
      minHeight: 56,
      [e.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [e.up("sm")]: {
        minHeight: 64
      }
    },
    ...t
  };
}
function tre(e) {
  return Math.round(e * 1e5) / 1e5;
}
const PA = {
  textTransform: "uppercase"
}, zA = '"Roboto", "Helvetica", "Arial", sans-serif';
function nre(e, t) {
  const {
    fontFamily: n = zA,
    // The default font size of the Material Specification.
    fontSize: r = 14,
    // px
    fontWeightLight: i = 300,
    fontWeightRegular: a = 400,
    fontWeightMedium: s = 500,
    fontWeightBold: u = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize: f = 16,
    // Apply the CSS properties to all the variants.
    allVariants: d,
    pxToRem: h,
    ...p
  } = typeof t == "function" ? t(e) : t, g = r / 14, y = h || ((E) => `${E / f * g}rem`), b = (E, S, A, k, R) => ({
    fontFamily: n,
    fontWeight: E,
    fontSize: y(S),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight: A,
    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
    // across font-families can cause issues with the kerning.
    ...n === zA ? {
      letterSpacing: `${tre(k / S)}em`
    } : {},
    ...R,
    ...d
  }), x = {
    h1: b(i, 96, 1.167, -1.5),
    h2: b(i, 60, 1.2, -0.5),
    h3: b(a, 48, 1.167, 0),
    h4: b(a, 34, 1.235, 0.25),
    h5: b(a, 24, 1.334, 0),
    h6: b(s, 20, 1.6, 0.15),
    subtitle1: b(a, 16, 1.75, 0.15),
    subtitle2: b(s, 14, 1.57, 0.1),
    body1: b(a, 16, 1.5, 0.15),
    body2: b(a, 14, 1.43, 0.15),
    button: b(s, 14, 1.75, 0.4, PA),
    caption: b(a, 12, 1.66, 0.4),
    overline: b(a, 12, 2.66, 1, PA),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return er({
    htmlFontSize: f,
    pxToRem: y,
    fontFamily: n,
    fontSize: r,
    fontWeightLight: i,
    fontWeightRegular: a,
    fontWeightMedium: s,
    fontWeightBold: u,
    ...x
  }, p, {
    clone: !1
    // No need to clone deep
  });
}
const rre = 0.2, ire = 0.14, ore = 0.12;
function St(...e) {
  return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${rre})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${ire})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${ore})`].join(",");
}
const are = ["none", St(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), St(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), St(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), St(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), St(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), St(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), St(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), St(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), St(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), St(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), St(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), St(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), St(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), St(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), St(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), St(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), St(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), St(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), St(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), St(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), St(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), St(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), St(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), St(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], sre = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}, lre = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function jA(e) {
  return `${Math.round(e)}ms`;
}
function ure(e) {
  if (!e)
    return 0;
  const t = e / 36;
  return Math.min(Math.round((4 + 15 * t ** 0.25 + t / 5) * 10), 3e3);
}
function cre(e) {
  const t = {
    ...sre,
    ...e.easing
  }, n = {
    ...lre,
    ...e.duration
  };
  return {
    getAutoHeightDuration: ure,
    create: (i = ["all"], a = {}) => {
      const {
        duration: s = n.standard,
        easing: u = t.easeInOut,
        delay: f = 0,
        ...d
      } = a;
      return (Array.isArray(i) ? i : [i]).map((h) => `${h} ${typeof s == "string" ? s : jA(s)} ${u} ${typeof f == "string" ? f : jA(f)}`).join(",");
    },
    ...e,
    easing: t,
    duration: n
  };
}
const fre = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
function dre(e) {
  return Pi(e) || typeof e > "u" || typeof e == "string" || typeof e == "boolean" || typeof e == "number" || Array.isArray(e);
}
function w5(e = {}) {
  const t = {
    ...e
  };
  function n(r) {
    const i = Object.entries(r);
    for (let a = 0; a < i.length; a++) {
      const [s, u] = i[a];
      !dre(u) || s.startsWith("unstable_") ? delete r[s] : Pi(u) && (r[s] = {
        ...u
      }, n(r[s]));
    }
  }
  return n(t), `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(t, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}
function Jv(e = {}, ...t) {
  const {
    breakpoints: n,
    mixins: r = {},
    spacing: i,
    palette: a = {},
    transitions: s = {},
    typography: u = {},
    shape: f,
    ...d
  } = e;
  if (e.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
  // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
  e.generateThemeVars === void 0)
    throw new Error(Ia(20));
  const h = Z1(a), p = p5(e);
  let g = er(p, {
    mixins: ere(p.breakpoints, r),
    palette: h,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: are.slice(),
    typography: nre(h, u),
    transitions: cre(s),
    zIndex: {
      ...fre
    }
  });
  return g = er(g, d), g = t.reduce((y, b) => er(y, b), g), g.unstable_sxConfig = {
    ...Kp,
    ...d?.unstable_sxConfig
  }, g.unstable_sx = function(b) {
    return dl({
      sx: b,
      theme: this
    });
  }, g.toRuntimeSource = w5, g;
}
function hre(e) {
  let t;
  return e < 1 ? t = 5.11916 * e ** 2 : t = 4.5 * Math.log(e + 1) + 2, Math.round(t * 10) / 1e3;
}
const pre = [...Array(25)].map((e, t) => {
  if (t === 0)
    return "none";
  const n = hre(t);
  return `linear-gradient(rgba(255 255 255 / ${n}), rgba(255 255 255 / ${n}))`;
});
function S5(e) {
  return {
    inputPlaceholder: e === "dark" ? 0.5 : 0.42,
    inputUnderline: e === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: e === "dark" ? 0.2 : 0.12,
    switchTrack: e === "dark" ? 0.3 : 0.38
  };
}
function _5(e) {
  return e === "dark" ? pre : [];
}
function mre(e) {
  const {
    palette: t = {
      mode: "light"
    },
    // need to cast to avoid module augmentation test
    opacity: n,
    overlays: r,
    ...i
  } = e, a = Z1(t);
  return {
    palette: a,
    opacity: {
      ...S5(a.mode),
      ...n
    },
    overlays: r || _5(a.mode),
    ...i
  };
}
function gre(e) {
  return !!e[0].match(/(cssVarPrefix|colorSchemeSelector|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!e[0].match(/sxConfig$/) || // ends with sxConfig
  e[0] === "palette" && !!e[1]?.match(/(mode|contrastThreshold|tonalOffset)/);
}
const yre = (e) => [...[...Array(25)].map((t, n) => `--${e ? `${e}-` : ""}overlays-${n}`), `--${e ? `${e}-` : ""}palette-AppBar-darkBg`, `--${e ? `${e}-` : ""}palette-AppBar-darkColor`], vre = (e) => (t, n) => {
  const r = e.rootSelector || ":root", i = e.colorSchemeSelector;
  let a = i;
  if (i === "class" && (a = ".%s"), i === "data" && (a = "[data-%s]"), i?.startsWith("data-") && !i.includes("%s") && (a = `[${i}="%s"]`), e.defaultColorScheme === t) {
    if (t === "dark") {
      const s = {};
      return yre(e.cssVarPrefix).forEach((u) => {
        s[u] = n[u], delete n[u];
      }), a === "media" ? {
        [r]: n,
        "@media (prefers-color-scheme: dark)": {
          [r]: s
        }
      } : a ? {
        [a.replace("%s", t)]: s,
        [`${r}, ${a.replace("%s", t)}`]: n
      } : {
        [r]: {
          ...n,
          ...s
        }
      };
    }
    if (a && a !== "media")
      return `${r}, ${a.replace("%s", String(t))}`;
  } else if (t) {
    if (a === "media")
      return {
        [`@media (prefers-color-scheme: ${String(t)})`]: {
          [r]: n
        }
      };
    if (a)
      return a.replace("%s", String(t));
  }
  return r;
};
function bre(e, t) {
  t.forEach((n) => {
    e[n] || (e[n] = {});
  });
}
function se(e, t, n) {
  !e[t] && n && (e[t] = n);
}
function Gu(e) {
  return typeof e != "string" || !e.startsWith("hsl") ? e : y5(e);
}
function Mi(e, t) {
  `${t}Channel` in e || (e[`${t}Channel`] = Yu(Gu(e[t])));
}
function xre(e) {
  return typeof e == "number" ? `${e}px` : typeof e == "string" || typeof e == "function" || Array.isArray(e) ? e : "8px";
}
const Yr = (e) => {
  try {
    return e();
  } catch {
  }
}, wre = (e = "mui") => Bne(e);
function Ty(e, t, n, r) {
  if (!t)
    return;
  t = t === !0 ? {} : t;
  const i = r === "dark" ? "dark" : "light";
  if (!n) {
    e[r] = mre({
      ...t,
      palette: {
        mode: i,
        ...t?.palette
      }
    });
    return;
  }
  const {
    palette: a,
    ...s
  } = Jv({
    ...n,
    palette: {
      mode: i,
      ...t?.palette
    }
  });
  return e[r] = {
    ...t,
    palette: a,
    opacity: {
      ...S5(i),
      ...t?.opacity
    },
    overlays: t?.overlays || _5(i)
  }, s;
}
function Sre(e = {}, ...t) {
  const {
    colorSchemes: n = {
      light: !0
    },
    defaultColorScheme: r,
    disableCssColorScheme: i = !1,
    cssVarPrefix: a = "mui",
    shouldSkipGeneratingVar: s = gre,
    colorSchemeSelector: u = n.light && n.dark ? "media" : void 0,
    rootSelector: f = ":root",
    ...d
  } = e, h = Object.keys(n)[0], p = r || (n.light && h !== "light" ? "light" : h), g = wre(a), {
    [p]: y,
    light: b,
    dark: x,
    ...E
  } = n, S = {
    ...E
  };
  let A = y;
  if ((p === "dark" && !("dark" in n) || p === "light" && !("light" in n)) && (A = !0), !A)
    throw new Error(Ia(21, p));
  const k = Ty(S, A, d, p);
  b && !S.light && Ty(S, b, void 0, "light"), x && !S.dark && Ty(S, x, void 0, "dark");
  let R = {
    defaultColorScheme: p,
    ...k,
    cssVarPrefix: a,
    colorSchemeSelector: u,
    rootSelector: f,
    getCssVar: g,
    colorSchemes: S,
    font: {
      ...Jne(k.typography),
      ...k.font
    },
    spacing: xre(d.spacing)
  };
  Object.keys(R.colorSchemes).forEach((V) => {
    const T = R.colorSchemes[V].palette, $ = (H) => {
      const G = H.split("-"), j = G[1], U = G[2];
      return g(H, T[j][U]);
    };
    if (T.mode === "light" && (se(T.common, "background", "#fff"), se(T.common, "onBackground", "#000")), T.mode === "dark" && (se(T.common, "background", "#000"), se(T.common, "onBackground", "#fff")), bre(T, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]), T.mode === "light") {
      se(T.Alert, "errorColor", ht(T.error.light, 0.6)), se(T.Alert, "infoColor", ht(T.info.light, 0.6)), se(T.Alert, "successColor", ht(T.success.light, 0.6)), se(T.Alert, "warningColor", ht(T.warning.light, 0.6)), se(T.Alert, "errorFilledBg", $("palette-error-main")), se(T.Alert, "infoFilledBg", $("palette-info-main")), se(T.Alert, "successFilledBg", $("palette-success-main")), se(T.Alert, "warningFilledBg", $("palette-warning-main")), se(T.Alert, "errorFilledColor", Yr(() => T.getContrastText(T.error.main))), se(T.Alert, "infoFilledColor", Yr(() => T.getContrastText(T.info.main))), se(T.Alert, "successFilledColor", Yr(() => T.getContrastText(T.success.main))), se(T.Alert, "warningFilledColor", Yr(() => T.getContrastText(T.warning.main))), se(T.Alert, "errorStandardBg", pt(T.error.light, 0.9)), se(T.Alert, "infoStandardBg", pt(T.info.light, 0.9)), se(T.Alert, "successStandardBg", pt(T.success.light, 0.9)), se(T.Alert, "warningStandardBg", pt(T.warning.light, 0.9)), se(T.Alert, "errorIconColor", $("palette-error-main")), se(T.Alert, "infoIconColor", $("palette-info-main")), se(T.Alert, "successIconColor", $("palette-success-main")), se(T.Alert, "warningIconColor", $("palette-warning-main")), se(T.AppBar, "defaultBg", $("palette-grey-100")), se(T.Avatar, "defaultBg", $("palette-grey-400")), se(T.Button, "inheritContainedBg", $("palette-grey-300")), se(T.Button, "inheritContainedHoverBg", $("palette-grey-A100")), se(T.Chip, "defaultBorder", $("palette-grey-400")), se(T.Chip, "defaultAvatarColor", $("palette-grey-700")), se(T.Chip, "defaultIconColor", $("palette-grey-700")), se(T.FilledInput, "bg", "rgba(0, 0, 0, 0.06)"), se(T.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)"), se(T.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)"), se(T.LinearProgress, "primaryBg", pt(T.primary.main, 0.62)), se(T.LinearProgress, "secondaryBg", pt(T.secondary.main, 0.62)), se(T.LinearProgress, "errorBg", pt(T.error.main, 0.62)), se(T.LinearProgress, "infoBg", pt(T.info.main, 0.62)), se(T.LinearProgress, "successBg", pt(T.success.main, 0.62)), se(T.LinearProgress, "warningBg", pt(T.warning.main, 0.62)), se(T.Skeleton, "bg", `rgba(${$("palette-text-primaryChannel")} / 0.11)`), se(T.Slider, "primaryTrack", pt(T.primary.main, 0.62)), se(T.Slider, "secondaryTrack", pt(T.secondary.main, 0.62)), se(T.Slider, "errorTrack", pt(T.error.main, 0.62)), se(T.Slider, "infoTrack", pt(T.info.main, 0.62)), se(T.Slider, "successTrack", pt(T.success.main, 0.62)), se(T.Slider, "warningTrack", pt(T.warning.main, 0.62));
      const H = Vd(T.background.default, 0.8);
      se(T.SnackbarContent, "bg", H), se(T.SnackbarContent, "color", Yr(() => T.getContrastText(H))), se(T.SpeedDialAction, "fabHoverBg", Vd(T.background.paper, 0.15)), se(T.StepConnector, "border", $("palette-grey-400")), se(T.StepContent, "border", $("palette-grey-400")), se(T.Switch, "defaultColor", $("palette-common-white")), se(T.Switch, "defaultDisabledColor", $("palette-grey-100")), se(T.Switch, "primaryDisabledColor", pt(T.primary.main, 0.62)), se(T.Switch, "secondaryDisabledColor", pt(T.secondary.main, 0.62)), se(T.Switch, "errorDisabledColor", pt(T.error.main, 0.62)), se(T.Switch, "infoDisabledColor", pt(T.info.main, 0.62)), se(T.Switch, "successDisabledColor", pt(T.success.main, 0.62)), se(T.Switch, "warningDisabledColor", pt(T.warning.main, 0.62)), se(T.TableCell, "border", pt(Hd(T.divider, 1), 0.88)), se(T.Tooltip, "bg", Hd(T.grey[700], 0.92));
    }
    if (T.mode === "dark") {
      se(T.Alert, "errorColor", pt(T.error.light, 0.6)), se(T.Alert, "infoColor", pt(T.info.light, 0.6)), se(T.Alert, "successColor", pt(T.success.light, 0.6)), se(T.Alert, "warningColor", pt(T.warning.light, 0.6)), se(T.Alert, "errorFilledBg", $("palette-error-dark")), se(T.Alert, "infoFilledBg", $("palette-info-dark")), se(T.Alert, "successFilledBg", $("palette-success-dark")), se(T.Alert, "warningFilledBg", $("palette-warning-dark")), se(T.Alert, "errorFilledColor", Yr(() => T.getContrastText(T.error.dark))), se(T.Alert, "infoFilledColor", Yr(() => T.getContrastText(T.info.dark))), se(T.Alert, "successFilledColor", Yr(() => T.getContrastText(T.success.dark))), se(T.Alert, "warningFilledColor", Yr(() => T.getContrastText(T.warning.dark))), se(T.Alert, "errorStandardBg", ht(T.error.light, 0.9)), se(T.Alert, "infoStandardBg", ht(T.info.light, 0.9)), se(T.Alert, "successStandardBg", ht(T.success.light, 0.9)), se(T.Alert, "warningStandardBg", ht(T.warning.light, 0.9)), se(T.Alert, "errorIconColor", $("palette-error-main")), se(T.Alert, "infoIconColor", $("palette-info-main")), se(T.Alert, "successIconColor", $("palette-success-main")), se(T.Alert, "warningIconColor", $("palette-warning-main")), se(T.AppBar, "defaultBg", $("palette-grey-900")), se(T.AppBar, "darkBg", $("palette-background-paper")), se(T.AppBar, "darkColor", $("palette-text-primary")), se(T.Avatar, "defaultBg", $("palette-grey-600")), se(T.Button, "inheritContainedBg", $("palette-grey-800")), se(T.Button, "inheritContainedHoverBg", $("palette-grey-700")), se(T.Chip, "defaultBorder", $("palette-grey-700")), se(T.Chip, "defaultAvatarColor", $("palette-grey-300")), se(T.Chip, "defaultIconColor", $("palette-grey-300")), se(T.FilledInput, "bg", "rgba(255, 255, 255, 0.09)"), se(T.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)"), se(T.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)"), se(T.LinearProgress, "primaryBg", ht(T.primary.main, 0.5)), se(T.LinearProgress, "secondaryBg", ht(T.secondary.main, 0.5)), se(T.LinearProgress, "errorBg", ht(T.error.main, 0.5)), se(T.LinearProgress, "infoBg", ht(T.info.main, 0.5)), se(T.LinearProgress, "successBg", ht(T.success.main, 0.5)), se(T.LinearProgress, "warningBg", ht(T.warning.main, 0.5)), se(T.Skeleton, "bg", `rgba(${$("palette-text-primaryChannel")} / 0.13)`), se(T.Slider, "primaryTrack", ht(T.primary.main, 0.5)), se(T.Slider, "secondaryTrack", ht(T.secondary.main, 0.5)), se(T.Slider, "errorTrack", ht(T.error.main, 0.5)), se(T.Slider, "infoTrack", ht(T.info.main, 0.5)), se(T.Slider, "successTrack", ht(T.success.main, 0.5)), se(T.Slider, "warningTrack", ht(T.warning.main, 0.5));
      const H = Vd(T.background.default, 0.98);
      se(T.SnackbarContent, "bg", H), se(T.SnackbarContent, "color", Yr(() => T.getContrastText(H))), se(T.SpeedDialAction, "fabHoverBg", Vd(T.background.paper, 0.15)), se(T.StepConnector, "border", $("palette-grey-600")), se(T.StepContent, "border", $("palette-grey-600")), se(T.Switch, "defaultColor", $("palette-grey-300")), se(T.Switch, "defaultDisabledColor", $("palette-grey-600")), se(T.Switch, "primaryDisabledColor", ht(T.primary.main, 0.55)), se(T.Switch, "secondaryDisabledColor", ht(T.secondary.main, 0.55)), se(T.Switch, "errorDisabledColor", ht(T.error.main, 0.55)), se(T.Switch, "infoDisabledColor", ht(T.info.main, 0.55)), se(T.Switch, "successDisabledColor", ht(T.success.main, 0.55)), se(T.Switch, "warningDisabledColor", ht(T.warning.main, 0.55)), se(T.TableCell, "border", ht(Hd(T.divider, 1), 0.68)), se(T.Tooltip, "bg", Hd(T.grey[700], 0.92));
    }
    Mi(T.background, "default"), Mi(T.background, "paper"), Mi(T.common, "background"), Mi(T.common, "onBackground"), Mi(T, "divider"), Object.keys(T).forEach((H) => {
      const G = T[H];
      H !== "tonalOffset" && G && typeof G == "object" && (G.main && se(T[H], "mainChannel", Yu(Gu(G.main))), G.light && se(T[H], "lightChannel", Yu(Gu(G.light))), G.dark && se(T[H], "darkChannel", Yu(Gu(G.dark))), G.contrastText && se(T[H], "contrastTextChannel", Yu(Gu(G.contrastText))), H === "text" && (Mi(T[H], "primary"), Mi(T[H], "secondary")), H === "action" && (G.active && Mi(T[H], "active"), G.selected && Mi(T[H], "selected")));
    });
  }), R = t.reduce((V, T) => er(V, T), R);
  const N = {
    prefix: a,
    disableCssColorScheme: i,
    shouldSkipGeneratingVar: s,
    getSelector: vre(R)
  }, {
    vars: D,
    generateThemeVars: P,
    generateStyleSheets: F
  } = Vne(R, N);
  return R.vars = D, Object.entries(R.colorSchemes[R.defaultColorScheme]).forEach(([V, T]) => {
    R[V] = T;
  }), R.generateThemeVars = P, R.generateStyleSheets = F, R.generateSpacing = function() {
    return h5(d.spacing, $1(this));
  }, R.getColorSchemeSelector = Une(u), R.spacing = R.generateSpacing(), R.shouldSkipGeneratingVar = s, R.unstable_sxConfig = {
    ...Kp,
    ...d?.unstable_sxConfig
  }, R.unstable_sx = function(T) {
    return dl({
      sx: T,
      theme: this
    });
  }, R.toRuntimeSource = w5, R;
}
function IA(e, t, n) {
  e.colorSchemes && n && (e.colorSchemes[t] = {
    ...n !== !0 && n,
    palette: Z1({
      ...n === !0 ? {} : n.palette,
      mode: t
    })
    // cast type to skip module augmentation test
  });
}
function _re(e = {}, ...t) {
  const {
    palette: n,
    cssVariables: r = !1,
    colorSchemes: i = n ? void 0 : {
      light: !0
    },
    defaultColorScheme: a = n?.mode,
    ...s
  } = e, u = a || "light", f = i?.[u], d = {
    ...i,
    ...n ? {
      [u]: {
        ...typeof f != "boolean" && f,
        palette: n
      }
    } : void 0
  };
  if (r === !1) {
    if (!("colorSchemes" in e))
      return Jv(e, ...t);
    let h = n;
    "palette" in e || d[u] && (d[u] !== !0 ? h = d[u].palette : u === "dark" && (h = {
      mode: "dark"
    }));
    const p = Jv({
      ...e,
      palette: h
    }, ...t);
    return p.defaultColorScheme = u, p.colorSchemes = d, p.palette.mode === "light" && (p.colorSchemes.light = {
      ...d.light !== !0 && d.light,
      palette: p.palette
    }, IA(p, "dark", d.dark)), p.palette.mode === "dark" && (p.colorSchemes.dark = {
      ...d.dark !== !0 && d.dark,
      palette: p.palette
    }, IA(p, "light", d.light)), p;
  }
  return !n && !("light" in d) && u === "light" && (d.light = !0), Sre({
    ...s,
    colorSchemes: d,
    defaultColorScheme: u,
    ...typeof r != "boolean" && r
  }, ...t);
}
const Ere = _re(), Cre = "$$material";
function kre(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
const Are = (e) => kre(e) && e !== "classes", br = yne({
  themeId: Cre,
  defaultTheme: Ere,
  rootShouldForwardProp: Are
}), Cl = Fne;
function di(e) {
  return Lne(e);
}
function Tre(e) {
  return ci("MuiTable", e);
}
fi("MuiTable", ["root", "stickyHeader"]);
const Rre = (e) => {
  const {
    classes: t,
    stickyHeader: n
  } = e;
  return Zi({
    root: ["root", n && "stickyHeader"]
  }, Tre, t);
}, Ore = br("table", {
  name: "MuiTable",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.stickyHeader && t.stickyHeader];
  }
})(Cl(({
  theme: e
}) => ({
  display: "table",
  width: "100%",
  borderCollapse: "collapse",
  borderSpacing: 0,
  "& caption": {
    ...e.typography.body2,
    padding: e.spacing(2),
    color: (e.vars || e).palette.text.secondary,
    textAlign: "left",
    captionSide: "bottom"
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.stickyHeader,
    style: {
      borderCollapse: "separate"
    }
  }]
}))), LA = "table", Nre = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = di({
    props: t,
    name: "MuiTable"
  }), {
    className: i,
    component: a = LA,
    padding: s = "normal",
    size: u = "medium",
    stickyHeader: f = !1,
    ...d
  } = r, h = {
    ...r,
    component: a,
    padding: s,
    size: u,
    stickyHeader: f
  }, p = Rre(h), g = C.useMemo(() => ({
    padding: s,
    size: u,
    stickyHeader: f
  }), [s, u, f]);
  return /* @__PURE__ */ _.jsx(X3.Provider, {
    value: g,
    children: /* @__PURE__ */ _.jsx(Ore, {
      as: a,
      role: a === LA ? null : "table",
      ref: n,
      className: Vt(p.root, i),
      ownerState: h,
      ...d
    })
  });
}), om = /* @__PURE__ */ C.createContext();
function Mre(e) {
  return ci("MuiTableBody", e);
}
fi("MuiTableBody", ["root"]);
const Dre = (e) => {
  const {
    classes: t
  } = e;
  return Zi({
    root: ["root"]
  }, Mre, t);
}, Pre = br("tbody", {
  name: "MuiTableBody",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "table-row-group"
}), zre = {
  variant: "body"
}, FA = "tbody", jre = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = di({
    props: t,
    name: "MuiTableBody"
  }), {
    className: i,
    component: a = FA,
    ...s
  } = r, u = {
    ...r,
    component: a
  }, f = Dre(u);
  return /* @__PURE__ */ _.jsx(om.Provider, {
    value: zre,
    children: /* @__PURE__ */ _.jsx(Pre, {
      className: Vt(f.root, i),
      as: a,
      ref: n,
      role: a === FA ? null : "rowgroup",
      ownerState: u,
      ...s
    })
  });
});
function Ire(e) {
  return ci("MuiTableCell", e);
}
const Lre = fi("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]), Fre = (e) => {
  const {
    classes: t,
    variant: n,
    align: r,
    padding: i,
    size: a,
    stickyHeader: s
  } = e, u = {
    root: ["root", n, s && "stickyHeader", r !== "inherit" && `align${wn(r)}`, i !== "normal" && `padding${wn(i)}`, `size${wn(a)}`]
  };
  return Zi(u, Ire, t);
}, Bre = br("td", {
  name: "MuiTableCell",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], t[`size${wn(n.size)}`], n.padding !== "normal" && t[`padding${wn(n.padding)}`], n.align !== "inherit" && t[`align${wn(n.align)}`], n.stickyHeader && t.stickyHeader];
  }
})(Cl(({
  theme: e
}) => ({
  ...e.typography.body2,
  display: "table-cell",
  verticalAlign: "inherit",
  // Workaround for a rendering bug with spanned columns in Chrome 62.0.
  // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
  borderBottom: e.vars ? `1px solid ${e.vars.palette.TableCell.border}` : `1px solid
    ${e.palette.mode === "light" ? im(Cc(e.palette.divider, 1), 0.88) : rm(Cc(e.palette.divider, 1), 0.68)}`,
  textAlign: "left",
  padding: 16,
  variants: [{
    props: {
      variant: "head"
    },
    style: {
      color: (e.vars || e).palette.text.primary,
      lineHeight: e.typography.pxToRem(24),
      fontWeight: e.typography.fontWeightMedium
    }
  }, {
    props: {
      variant: "body"
    },
    style: {
      color: (e.vars || e).palette.text.primary
    }
  }, {
    props: {
      variant: "footer"
    },
    style: {
      color: (e.vars || e).palette.text.secondary,
      lineHeight: e.typography.pxToRem(21),
      fontSize: e.typography.pxToRem(12)
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      padding: "6px 16px",
      [`&.${Lre.paddingCheckbox}`]: {
        width: 24,
        // prevent the checkbox column from growing
        padding: "0 12px 0 16px",
        "& > *": {
          padding: 0
        }
      }
    }
  }, {
    props: {
      padding: "checkbox"
    },
    style: {
      width: 48,
      // prevent the checkbox column from growing
      padding: "0 0 0 4px"
    }
  }, {
    props: {
      padding: "none"
    },
    style: {
      padding: 0
    }
  }, {
    props: {
      align: "left"
    },
    style: {
      textAlign: "left"
    }
  }, {
    props: {
      align: "center"
    },
    style: {
      textAlign: "center"
    }
  }, {
    props: {
      align: "right"
    },
    style: {
      textAlign: "right",
      flexDirection: "row-reverse"
    }
  }, {
    props: {
      align: "justify"
    },
    style: {
      textAlign: "justify"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.stickyHeader,
    style: {
      position: "sticky",
      top: 0,
      zIndex: 2,
      backgroundColor: (e.vars || e).palette.background.default
    }
  }]
}))), BA = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = di({
    props: t,
    name: "MuiTableCell"
  }), {
    align: i = "inherit",
    className: a,
    component: s,
    padding: u,
    scope: f,
    size: d,
    sortDirection: h,
    variant: p,
    ...g
  } = r, y = C.useContext(X3), b = C.useContext(om), x = b && b.variant === "head";
  let E;
  s ? E = s : E = x ? "th" : "td";
  let S = f;
  E === "td" ? S = void 0 : !S && x && (S = "col");
  const A = p || b && b.variant, k = {
    ...r,
    align: i,
    component: E,
    padding: u || (y && y.padding ? y.padding : "normal"),
    size: d || (y && y.size ? y.size : "medium"),
    sortDirection: h,
    stickyHeader: A === "head" && y && y.stickyHeader,
    variant: A
  }, R = Fre(k);
  let N = null;
  return h && (N = h === "asc" ? "ascending" : "descending"), /* @__PURE__ */ _.jsx(Bre, {
    as: E,
    ref: n,
    className: Vt(R.root, a),
    "aria-sort": N,
    scope: S,
    ownerState: k,
    ...g
  });
});
function $re(e) {
  return ci("MuiTableContainer", e);
}
fi("MuiTableContainer", ["root"]);
const Hre = (e) => {
  const {
    classes: t
  } = e;
  return Zi({
    root: ["root"]
  }, $re, t);
}, Vre = br("div", {
  name: "MuiTableContainer",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  width: "100%",
  overflowX: "auto"
}), Ure = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = di({
    props: t,
    name: "MuiTableContainer"
  }), {
    className: i,
    component: a = "div",
    ...s
  } = r, u = {
    ...r,
    component: a
  }, f = Hre(u);
  return /* @__PURE__ */ _.jsx(Vre, {
    ref: n,
    as: a,
    className: Vt(f.root, i),
    ownerState: u,
    ...s
  });
});
function qre(e) {
  return ci("MuiTableHead", e);
}
fi("MuiTableHead", ["root"]);
const Yre = (e) => {
  const {
    classes: t
  } = e;
  return Zi({
    root: ["root"]
  }, qre, t);
}, Gre = br("thead", {
  name: "MuiTableHead",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "table-header-group"
}), Xre = {
  variant: "head"
}, $A = "thead", Wre = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = di({
    props: t,
    name: "MuiTableHead"
  }), {
    className: i,
    component: a = $A,
    ...s
  } = r, u = {
    ...r,
    component: a
  }, f = Yre(u);
  return /* @__PURE__ */ _.jsx(om.Provider, {
    value: Xre,
    children: /* @__PURE__ */ _.jsx(Gre, {
      as: a,
      className: Vt(f.root, i),
      ref: n,
      role: a === $A ? null : "rowgroup",
      ownerState: u,
      ...s
    })
  });
});
function Kre(e) {
  return ci("MuiTableRow", e);
}
const HA = fi("MuiTableRow", ["root", "selected", "hover", "head", "footer"]), Zre = (e) => {
  const {
    classes: t,
    selected: n,
    hover: r,
    head: i,
    footer: a
  } = e;
  return Zi({
    root: ["root", n && "selected", r && "hover", i && "head", a && "footer"]
  }, Kre, t);
}, Qre = br("tr", {
  name: "MuiTableRow",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.head && t.head, n.footer && t.footer];
  }
})(Cl(({
  theme: e
}) => ({
  color: "inherit",
  display: "table-row",
  verticalAlign: "middle",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  [`&.${HA.hover}:hover`]: {
    backgroundColor: (e.vars || e).palette.action.hover
  },
  [`&.${HA.selected}`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : Cc(e.palette.primary.main, e.palette.action.selectedOpacity),
    "&:hover": {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : Cc(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity)
    }
  }
}))), VA = "tr", UA = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = di({
    props: t,
    name: "MuiTableRow"
  }), {
    className: i,
    component: a = VA,
    hover: s = !1,
    selected: u = !1,
    ...f
  } = r, d = C.useContext(om), h = {
    ...r,
    component: a,
    hover: s,
    selected: u,
    head: d && d.variant === "head",
    footer: d && d.variant === "footer"
  }, p = Zre(h);
  return /* @__PURE__ */ _.jsx(Qre, {
    as: a,
    ref: n,
    className: Vt(p.root, i),
    role: a === VA ? null : "row",
    ownerState: h,
    ...f
  });
});
class Gh {
  constructor() {
    Ru(this, "mountEffect", () => {
      this.shouldMount && !this.didMount && this.ref.current !== null && (this.didMount = !0, this.mounted.resolve());
    });
    this.ref = {
      current: null
    }, this.mounted = null, this.didMount = !1, this.shouldMount = !1, this.setShouldMount = null;
  }
  /** React ref to the ripple instance */
  /** If the ripple component should be mounted */
  /** Promise that resolves when the ripple component is mounted */
  /** If the ripple component has been mounted */
  /** React state hook setter */
  static create() {
    return new Gh();
  }
  static use() {
    const t = v5(Gh.create).current, [n, r] = C.useState(!1);
    return t.shouldMount = n, t.setShouldMount = r, C.useEffect(t.mountEffect, [n]), t;
  }
  mount() {
    return this.mounted || (this.mounted = eie(), this.shouldMount = !0, this.setShouldMount(this.shouldMount)), this.mounted;
  }
  /* Ripple API */
  start(...t) {
    this.mount().then(() => this.ref.current?.start(...t));
  }
  stop(...t) {
    this.mount().then(() => this.ref.current?.stop(...t));
  }
  pulsate(...t) {
    this.mount().then(() => this.ref.current?.pulsate(...t));
  }
}
function Jre() {
  return Gh.use();
}
function eie() {
  let e, t;
  const n = new Promise((r, i) => {
    e = r, t = i;
  });
  return n.resolve = e, n.reject = t, n;
}
function Q1(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function Xh(e, t) {
  return Xh = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
    return n.__proto__ = r, n;
  }, Xh(e, t);
}
function E5(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Xh(e, t);
}
const qA = Qt.createContext(null);
function C5(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function J1(e, t) {
  var n = function(a) {
    return t && C.isValidElement(a) ? t(a) : a;
  }, r = /* @__PURE__ */ Object.create(null);
  return e && C.Children.map(e, function(i) {
    return i;
  }).forEach(function(i) {
    r[i.key] = n(i);
  }), r;
}
function tie(e, t) {
  e = e || {}, t = t || {};
  function n(h) {
    return h in t ? t[h] : e[h];
  }
  var r = /* @__PURE__ */ Object.create(null), i = [];
  for (var a in e)
    a in t ? i.length && (r[a] = i, i = []) : i.push(a);
  var s, u = {};
  for (var f in t) {
    if (r[f])
      for (s = 0; s < r[f].length; s++) {
        var d = r[f][s];
        u[r[f][s]] = n(d);
      }
    u[f] = n(f);
  }
  for (s = 0; s < i.length; s++)
    u[i[s]] = n(i[s]);
  return u;
}
function _a(e, t, n) {
  return n[t] != null ? n[t] : e.props[t];
}
function nie(e, t) {
  return J1(e.children, function(n) {
    return C.cloneElement(n, {
      onExited: t.bind(null, n),
      in: !0,
      appear: _a(n, "appear", e),
      enter: _a(n, "enter", e),
      exit: _a(n, "exit", e)
    });
  });
}
function rie(e, t, n) {
  var r = J1(e.children), i = tie(t, r);
  return Object.keys(i).forEach(function(a) {
    var s = i[a];
    if (C.isValidElement(s)) {
      var u = a in t, f = a in r, d = t[a], h = C.isValidElement(d) && !d.props.in;
      f && (!u || h) ? i[a] = C.cloneElement(s, {
        onExited: n.bind(null, s),
        in: !0,
        exit: _a(s, "exit", e),
        enter: _a(s, "enter", e)
      }) : !f && u && !h ? i[a] = C.cloneElement(s, {
        in: !1
      }) : f && u && C.isValidElement(d) && (i[a] = C.cloneElement(s, {
        onExited: n.bind(null, s),
        in: d.props.in,
        exit: _a(s, "exit", e),
        enter: _a(s, "enter", e)
      }));
    }
  }), i;
}
var iie = Object.values || function(e) {
  return Object.keys(e).map(function(t) {
    return e[t];
  });
}, oie = {
  component: "div",
  childFactory: function(t) {
    return t;
  }
}, ex = /* @__PURE__ */ function(e) {
  E5(t, e);
  function t(r, i) {
    var a;
    a = e.call(this, r, i) || this;
    var s = a.handleExited.bind(C5(a));
    return a.state = {
      contextValue: {
        isMounting: !0
      },
      handleExited: s,
      firstRender: !0
    }, a;
  }
  var n = t.prototype;
  return n.componentDidMount = function() {
    this.mounted = !0, this.setState({
      contextValue: {
        isMounting: !1
      }
    });
  }, n.componentWillUnmount = function() {
    this.mounted = !1;
  }, t.getDerivedStateFromProps = function(i, a) {
    var s = a.children, u = a.handleExited, f = a.firstRender;
    return {
      children: f ? nie(i, u) : rie(i, s, u),
      firstRender: !1
    };
  }, n.handleExited = function(i, a) {
    var s = J1(this.props.children);
    i.key in s || (i.props.onExited && i.props.onExited(a), this.mounted && this.setState(function(u) {
      var f = ke({}, u.children);
      return delete f[i.key], {
        children: f
      };
    }));
  }, n.render = function() {
    var i = this.props, a = i.component, s = i.childFactory, u = Q1(i, ["component", "childFactory"]), f = this.state.contextValue, d = iie(this.state.children).map(s);
    return delete u.appear, delete u.enter, delete u.exit, a === null ? /* @__PURE__ */ Qt.createElement(qA.Provider, {
      value: f
    }, d) : /* @__PURE__ */ Qt.createElement(qA.Provider, {
      value: f
    }, /* @__PURE__ */ Qt.createElement(a, u, d));
  }, t;
}(Qt.Component);
ex.propTypes = {};
ex.defaultProps = oie;
function aie(e) {
  const {
    className: t,
    classes: n,
    pulsate: r = !1,
    rippleX: i,
    rippleY: a,
    rippleSize: s,
    in: u,
    onExited: f,
    timeout: d
  } = e, [h, p] = C.useState(!1), g = Vt(t, n.ripple, n.rippleVisible, r && n.ripplePulsate), y = {
    width: s,
    height: s,
    top: -(s / 2) + a,
    left: -(s / 2) + i
  }, b = Vt(n.child, h && n.childLeaving, r && n.childPulsate);
  return !u && !h && p(!0), C.useEffect(() => {
    if (!u && f != null) {
      const x = setTimeout(f, d);
      return () => {
        clearTimeout(x);
      };
    }
  }, [f, u, d]), /* @__PURE__ */ _.jsx("span", {
    className: g,
    style: y,
    children: /* @__PURE__ */ _.jsx("span", {
      className: b
    })
  });
}
const hr = fi("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), eb = 550, sie = 80, lie = tm`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`, uie = tm`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`, cie = tm`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`, fie = br("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
}), die = br(aie, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})`
  opacity: 0;
  position: absolute;

  &.${hr.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${lie};
    animation-duration: ${eb}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  &.${hr.ripplePulsate} {
    animation-duration: ${({
  theme: e
}) => e.transitions.duration.shorter}ms;
  }

  & .${hr.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${hr.childLeaving} {
    opacity: 0;
    animation-name: ${uie};
    animation-duration: ${eb}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  & .${hr.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${cie};
    animation-duration: 2500ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`, hie = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = di({
    props: t,
    name: "MuiTouchRipple"
  }), {
    center: i = !1,
    classes: a = {},
    className: s,
    ...u
  } = r, [f, d] = C.useState([]), h = C.useRef(0), p = C.useRef(null);
  C.useEffect(() => {
    p.current && (p.current(), p.current = null);
  }, [f]);
  const g = C.useRef(!1), y = One(), b = C.useRef(null), x = C.useRef(null), E = C.useCallback((R) => {
    const {
      pulsate: N,
      rippleX: D,
      rippleY: P,
      rippleSize: F,
      cb: V
    } = R;
    d((T) => [...T, /* @__PURE__ */ _.jsx(die, {
      classes: {
        ripple: Vt(a.ripple, hr.ripple),
        rippleVisible: Vt(a.rippleVisible, hr.rippleVisible),
        ripplePulsate: Vt(a.ripplePulsate, hr.ripplePulsate),
        child: Vt(a.child, hr.child),
        childLeaving: Vt(a.childLeaving, hr.childLeaving),
        childPulsate: Vt(a.childPulsate, hr.childPulsate)
      },
      timeout: eb,
      pulsate: N,
      rippleX: D,
      rippleY: P,
      rippleSize: F
    }, h.current)]), h.current += 1, p.current = V;
  }, [a]), S = C.useCallback((R = {}, N = {}, D = () => {
  }) => {
    const {
      pulsate: P = !1,
      center: F = i || N.pulsate,
      fakeElement: V = !1
      // For test purposes
    } = N;
    if (R?.type === "mousedown" && g.current) {
      g.current = !1;
      return;
    }
    R?.type === "touchstart" && (g.current = !0);
    const T = V ? null : x.current, $ = T ? T.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let H, G, j;
    if (F || R === void 0 || R.clientX === 0 && R.clientY === 0 || !R.clientX && !R.touches)
      H = Math.round($.width / 2), G = Math.round($.height / 2);
    else {
      const {
        clientX: U,
        clientY: z
      } = R.touches && R.touches.length > 0 ? R.touches[0] : R;
      H = Math.round(U - $.left), G = Math.round(z - $.top);
    }
    if (F)
      j = Math.sqrt((2 * $.width ** 2 + $.height ** 2) / 3), j % 2 === 0 && (j += 1);
    else {
      const U = Math.max(Math.abs((T ? T.clientWidth : 0) - H), H) * 2 + 2, z = Math.max(Math.abs((T ? T.clientHeight : 0) - G), G) * 2 + 2;
      j = Math.sqrt(U ** 2 + z ** 2);
    }
    R?.touches ? b.current === null && (b.current = () => {
      E({
        pulsate: P,
        rippleX: H,
        rippleY: G,
        rippleSize: j,
        cb: D
      });
    }, y.start(sie, () => {
      b.current && (b.current(), b.current = null);
    })) : E({
      pulsate: P,
      rippleX: H,
      rippleY: G,
      rippleSize: j,
      cb: D
    });
  }, [i, E, y]), A = C.useCallback(() => {
    S({}, {
      pulsate: !0
    });
  }, [S]), k = C.useCallback((R, N) => {
    if (y.clear(), R?.type === "touchend" && b.current) {
      b.current(), b.current = null, y.start(0, () => {
        k(R, N);
      });
      return;
    }
    b.current = null, d((D) => D.length > 0 ? D.slice(1) : D), p.current = N;
  }, [y]);
  return C.useImperativeHandle(n, () => ({
    pulsate: A,
    start: S,
    stop: k
  }), [A, S, k]), /* @__PURE__ */ _.jsx(fie, {
    className: Vt(hr.root, a.root, s),
    ref: x,
    ...u,
    children: /* @__PURE__ */ _.jsx(ex, {
      component: null,
      exit: !0,
      children: f
    })
  });
});
function pie(e) {
  return ci("MuiButtonBase", e);
}
const mie = fi("MuiButtonBase", ["root", "disabled", "focusVisible"]), gie = (e) => {
  const {
    disabled: t,
    focusVisible: n,
    focusVisibleClassName: r,
    classes: i
  } = e, s = Zi({
    root: ["root", t && "disabled", n && "focusVisible"]
  }, pie, i);
  return n && r && (s.root += ` ${r}`), s;
}, yie = br("button", {
  name: "MuiButtonBase",
  slot: "Root",
  overridesResolver: (e, t) => t.root
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${mie.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
}), vie = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = di({
    props: t,
    name: "MuiButtonBase"
  }), {
    action: i,
    centerRipple: a = !1,
    children: s,
    className: u,
    component: f = "button",
    disabled: d = !1,
    disableRipple: h = !1,
    disableTouchRipple: p = !1,
    focusRipple: g = !1,
    focusVisibleClassName: y,
    LinkComponent: b = "a",
    onBlur: x,
    onClick: E,
    onContextMenu: S,
    onDragLeave: A,
    onFocus: k,
    onFocusVisible: R,
    onKeyDown: N,
    onKeyUp: D,
    onMouseDown: P,
    onMouseLeave: F,
    onMouseUp: V,
    onTouchEnd: T,
    onTouchMove: $,
    onTouchStart: H,
    tabIndex: G = 0,
    TouchRippleProps: j,
    touchRippleRef: U,
    type: z,
    ...B
  } = r, q = C.useRef(null), Y = Jre(), O = Qv(Y.ref, U), [W, Z] = C.useState(!1);
  d && W && Z(!1), C.useImperativeHandle(i, () => ({
    focusVisible: () => {
      Z(!0), q.current.focus();
    }
  }), []);
  const I = Y.shouldMount && !h && !d;
  C.useEffect(() => {
    W && g && !h && Y.pulsate();
  }, [h, g, W, Y]);
  const ie = Di(Y, "start", P, p), fe = Di(Y, "stop", S, p), re = Di(Y, "stop", A, p), le = Di(Y, "stop", V, p), he = Di(Y, "stop", (Pe) => {
    W && Pe.preventDefault(), F && F(Pe);
  }, p), ye = Di(Y, "start", H, p), je = Di(Y, "stop", T, p), Oe = Di(Y, "stop", $, p), be = Di(Y, "stop", (Pe) => {
    TA(Pe.target) || Z(!1), x && x(Pe);
  }, !1), Le = ph((Pe) => {
    q.current || (q.current = Pe.currentTarget), TA(Pe.target) && (Z(!0), R && R(Pe)), k && k(Pe);
  }), Ie = () => {
    const Pe = q.current;
    return f && f !== "button" && !(Pe.tagName === "A" && Pe.href);
  }, ft = ph((Pe) => {
    g && !Pe.repeat && W && Pe.key === " " && Y.stop(Pe, () => {
      Y.start(Pe);
    }), Pe.target === Pe.currentTarget && Ie() && Pe.key === " " && Pe.preventDefault(), N && N(Pe), Pe.target === Pe.currentTarget && Ie() && Pe.key === "Enter" && !d && (Pe.preventDefault(), E && E(Pe));
  }), Jt = ph((Pe) => {
    g && Pe.key === " " && W && !Pe.defaultPrevented && Y.stop(Pe, () => {
      Y.pulsate(Pe);
    }), D && D(Pe), E && Pe.target === Pe.currentTarget && Ie() && Pe.key === " " && !Pe.defaultPrevented && E(Pe);
  });
  let bt = f;
  bt === "button" && (B.href || B.to) && (bt = b);
  const Ln = {};
  bt === "button" ? (Ln.type = z === void 0 ? "button" : z, Ln.disabled = d) : (!B.href && !B.to && (Ln.role = "button"), d && (Ln["aria-disabled"] = d));
  const xr = Qv(n, q), En = {
    ...r,
    centerRipple: a,
    component: f,
    disabled: d,
    disableRipple: h,
    disableTouchRipple: p,
    focusRipple: g,
    tabIndex: G,
    focusVisible: W
  }, ir = gie(En);
  return /* @__PURE__ */ _.jsxs(yie, {
    as: bt,
    className: Vt(ir.root, u),
    ownerState: En,
    onBlur: be,
    onClick: E,
    onContextMenu: fe,
    onFocus: Le,
    onKeyDown: ft,
    onKeyUp: Jt,
    onMouseDown: ie,
    onMouseLeave: he,
    onMouseUp: le,
    onDragLeave: re,
    onTouchEnd: je,
    onTouchMove: Oe,
    onTouchStart: ye,
    ref: xr,
    tabIndex: d ? -1 : G,
    type: z,
    ...Ln,
    ...B,
    children: [s, I ? /* @__PURE__ */ _.jsx(hie, {
      ref: O,
      center: a,
      ...j
    }) : null]
  });
});
function Di(e, t, n, r = !1) {
  return ph((i) => (n && n(i), r || e[t](i), !0));
}
function bie(e) {
  return ci("MuiSvgIcon", e);
}
fi("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const xie = (e) => {
  const {
    color: t,
    fontSize: n,
    classes: r
  } = e, i = {
    root: ["root", t !== "inherit" && `color${wn(t)}`, `fontSize${wn(n)}`]
  };
  return Zi(i, bie, r);
}, wie = br("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.color !== "inherit" && t[`color${wn(n.color)}`], t[`fontSize${wn(n.fontSize)}`]];
  }
})(Cl(({
  theme: e
}) => ({
  userSelect: "none",
  width: "1em",
  height: "1em",
  display: "inline-block",
  flexShrink: 0,
  transition: e.transitions?.create?.("fill", {
    duration: (e.vars ?? e).transitions?.duration?.shorter
  }),
  variants: [
    {
      props: (t) => !t.hasSvgAsChild,
      style: {
        // the <svg> will define the property that has `currentColor`
        // for example heroicons uses fill="none" and stroke="currentColor"
        fill: "currentColor"
      }
    },
    {
      props: {
        fontSize: "inherit"
      },
      style: {
        fontSize: "inherit"
      }
    },
    {
      props: {
        fontSize: "small"
      },
      style: {
        fontSize: e.typography?.pxToRem?.(20) || "1.25rem"
      }
    },
    {
      props: {
        fontSize: "medium"
      },
      style: {
        fontSize: e.typography?.pxToRem?.(24) || "1.5rem"
      }
    },
    {
      props: {
        fontSize: "large"
      },
      style: {
        fontSize: e.typography?.pxToRem?.(35) || "2.1875rem"
      }
    },
    // TODO v5 deprecate color prop, v6 remove for sx
    ...Object.entries((e.vars ?? e).palette).filter(([, t]) => t && t.main).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        color: (e.vars ?? e).palette?.[t]?.main
      }
    })),
    {
      props: {
        color: "action"
      },
      style: {
        color: (e.vars ?? e).palette?.action?.active
      }
    },
    {
      props: {
        color: "disabled"
      },
      style: {
        color: (e.vars ?? e).palette?.action?.disabled
      }
    },
    {
      props: {
        color: "inherit"
      },
      style: {
        color: void 0
      }
    }
  ]
}))), tb = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = di({
    props: t,
    name: "MuiSvgIcon"
  }), {
    children: i,
    className: a,
    color: s = "inherit",
    component: u = "svg",
    fontSize: f = "medium",
    htmlColor: d,
    inheritViewBox: h = !1,
    titleAccess: p,
    viewBox: g = "0 0 24 24",
    ...y
  } = r, b = /* @__PURE__ */ C.isValidElement(i) && i.type === "svg", x = {
    ...r,
    color: s,
    component: u,
    fontSize: f,
    instanceFontSize: t.fontSize,
    inheritViewBox: h,
    viewBox: g,
    hasSvgAsChild: b
  }, E = {};
  h || (E.viewBox = g);
  const S = xie(x);
  return /* @__PURE__ */ _.jsxs(wie, {
    as: u,
    className: Vt(S.root, a),
    focusable: "false",
    color: d,
    "aria-hidden": p ? void 0 : !0,
    role: p ? "img" : void 0,
    ref: n,
    ...E,
    ...y,
    ...b && i.props,
    ownerState: x,
    children: [b ? i.props.children : i, p ? /* @__PURE__ */ _.jsx("title", {
      children: p
    }) : null]
  });
});
tb.muiName = "SvgIcon";
function Sie(e, t) {
  function n(r, i) {
    return /* @__PURE__ */ _.jsx(tb, {
      "data-testid": void 0,
      ref: i,
      ...r,
      children: e
    });
  }
  return n.muiName = tb.muiName, /* @__PURE__ */ C.memo(/* @__PURE__ */ C.forwardRef(n));
}
const _ie = Sie(/* @__PURE__ */ _.jsx("path", {
  d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
}));
function Eie(e) {
  return ci("MuiTableSortLabel", e);
}
const Ry = fi("MuiTableSortLabel", ["root", "active", "icon", "iconDirectionDesc", "iconDirectionAsc", "directionDesc", "directionAsc"]);
function YA(e, t) {
  const {
    className: n,
    elementType: r,
    ownerState: i,
    externalForwardedProps: a,
    internalForwardedProps: s,
    shouldForwardComponentProp: u = !1,
    ...f
  } = t, {
    component: d,
    slots: h = {
      [e]: void 0
    },
    slotProps: p = {
      [e]: void 0
    },
    ...g
  } = a, y = h[e] || r, b = zne(p[e], i), {
    props: {
      component: x,
      ...E
    },
    internalRef: S
  } = Pne({
    className: n,
    ...f,
    externalForwardedProps: e === "root" ? g : void 0,
    externalSlotProps: b
  }), A = Qv(S, b?.ref, t.ref), k = e === "root" ? x || d : x, R = Mne(y, {
    ...e === "root" && !d && !h[e] && s,
    ...e !== "root" && !h[e] && s,
    ...E,
    ...k && !u && {
      as: k
    },
    ...k && u && {
      component: k
    },
    ref: A
  }, i);
  return [y, R];
}
const Cie = (e) => {
  const {
    classes: t,
    direction: n,
    active: r
  } = e, i = {
    root: ["root", r && "active", `direction${wn(n)}`],
    icon: ["icon", `iconDirection${wn(n)}`]
  };
  return Zi(i, Eie, t);
}, kie = br(vie, {
  name: "MuiTableSortLabel",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.active && t.active];
  }
})(Cl(({
  theme: e
}) => ({
  cursor: "pointer",
  display: "inline-flex",
  justifyContent: "flex-start",
  flexDirection: "inherit",
  alignItems: "center",
  "&:focus": {
    color: (e.vars || e).palette.text.secondary
  },
  "&:hover": {
    color: (e.vars || e).palette.text.secondary,
    [`& .${Ry.icon}`]: {
      opacity: 0.5
    }
  },
  [`&.${Ry.active}`]: {
    color: (e.vars || e).palette.text.primary,
    [`& .${Ry.icon}`]: {
      opacity: 1,
      color: (e.vars || e).palette.text.secondary
    }
  }
}))), Aie = br("span", {
  name: "MuiTableSortLabel",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, t[`iconDirection${wn(n.direction)}`]];
  }
})(Cl(({
  theme: e
}) => ({
  fontSize: 18,
  marginRight: 4,
  marginLeft: 4,
  opacity: 0,
  transition: e.transitions.create(["opacity", "transform"], {
    duration: e.transitions.duration.shorter
  }),
  userSelect: "none",
  variants: [{
    props: {
      direction: "desc"
    },
    style: {
      transform: "rotate(0deg)"
    }
  }, {
    props: {
      direction: "asc"
    },
    style: {
      transform: "rotate(180deg)"
    }
  }]
}))), Tie = /* @__PURE__ */ C.forwardRef(function(t, n) {
  const r = di({
    props: t,
    name: "MuiTableSortLabel"
  }), {
    active: i = !1,
    children: a,
    className: s,
    direction: u = "asc",
    hideSortIcon: f = !1,
    IconComponent: d = _ie,
    slots: h = {},
    slotProps: p = {},
    ...g
  } = r, y = {
    ...r,
    active: i,
    direction: u,
    hideSortIcon: f,
    IconComponent: d
  }, b = Cie(y), x = {
    slots: h,
    slotProps: p
  }, [E, S] = YA("root", {
    elementType: kie,
    externalForwardedProps: x,
    ownerState: y,
    className: Vt(b.root, s),
    ref: n
  }), [A, k] = YA("icon", {
    elementType: Aie,
    externalForwardedProps: x,
    ownerState: y,
    className: b.icon
  });
  return /* @__PURE__ */ _.jsxs(E, {
    disableRipple: !0,
    component: "span",
    ...S,
    ...g,
    children: [a, f && !i ? null : /* @__PURE__ */ _.jsx(A, {
      as: d,
      ...k
    })]
  });
}), Rie = (e) => {
  const t = [];
  if (e === void 0)
    return {
      header: [],
      rows: []
    };
  e.data === void 0 && (e.data = []), e.columns === void 0 && (e.data.length === 0 ? e.columns = [] : e.columns = e.data[0].map((n, r) => `col${r}`)), e.index === void 0 && (e.index = e.data.map((n, r) => `row${r}`));
  for (let n = 0; n < e.index.length; n++) {
    const r = [e.index[n]];
    for (let i = 0; i < e.columns.length; i++)
      r.push(e.data[n][i]);
    t.push(r);
  }
  return {
    header: ["index", ...e.columns],
    rows: t
  };
}, Oie = ({ tabledata: e }) => {
  const t = C.useMemo(
    () => Rie(e),
    [e]
  ), [n, r] = C.useState("asc"), [i, a] = C.useState("index");
  let s = t.header.indexOf(i);
  s === -1 && (s = 0);
  const u = (p) => {
    r(i === p && n === "asc" ? "desc" : "asc"), a(p);
  }, f = (p, g) => {
    const y = p.map((b, x) => [
      b,
      x
    ]);
    return y.sort((b, x) => g(b[0], x[0])), y.map((b) => b[0]);
  }, d = (p, g) => p === "desc" ? (y, b) => b[s] < y[s] ? -1 : 1 : (y, b) => y[s] < b[s] ? -1 : 1, h = f(
    t.rows,
    d(n)
  );
  return /* @__PURE__ */ _.jsx(Ure, { className: "tablecontainer", children: /* @__PURE__ */ _.jsxs(Nre, { size: "small", children: [
    /* @__PURE__ */ _.jsx(Wre, { className: "tableHead", children: /* @__PURE__ */ _.jsx(UA, { className: "tableheadercolor", children: t.header.map((p) => /* @__PURE__ */ _.jsx(
      BA,
      {
        sortDirection: i === p ? n : !1,
        className: "tableheadercolor",
        children: /* @__PURE__ */ _.jsx(
          Tie,
          {
            active: i === p,
            direction: i === p ? n : "asc",
            onClick: () => u(p),
            className: "tableheadercolor",
            sx: {
              "& .MuiTableSortLabel-icon": {
                color: "inherit !important"
              }
            },
            children: p
          }
        )
      },
      p
    )) }) }),
    /* @__PURE__ */ _.jsx(jre, { children: h.map((p, g) => /* @__PURE__ */ _.jsx(UA, { children: p.map((y, b) => /* @__PURE__ */ _.jsx(BA, { className: b == 0 ? "indexcol" : "datacol", children: y }, b)) }, e.index[g])) })
  ] }) });
};
var Ud = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var GA;
function Nie() {
  if (GA) return Ud;
  GA = 1;
  var e = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, t = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, n = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, r = /\\([\u000b\u0020-\u00ff])/g, i = /([\\"])/g, a = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  Ud.format = s, Ud.parse = u;
  function s(p) {
    if (!p || typeof p != "object")
      throw new TypeError("argument obj is required");
    var g = p.parameters, y = p.type;
    if (!y || !a.test(y))
      throw new TypeError("invalid type");
    var b = y;
    if (g && typeof g == "object")
      for (var x, E = Object.keys(g).sort(), S = 0; S < E.length; S++) {
        if (x = E[S], !n.test(x))
          throw new TypeError("invalid parameter name");
        b += "; " + x + "=" + d(g[x]);
      }
    return b;
  }
  function u(p) {
    if (!p)
      throw new TypeError("argument string is required");
    var g = typeof p == "object" ? f(p) : p;
    if (typeof g != "string")
      throw new TypeError("argument string is required to be a string");
    var y = g.indexOf(";"), b = y !== -1 ? g.slice(0, y).trim() : g.trim();
    if (!a.test(b))
      throw new TypeError("invalid media type");
    var x = new h(b.toLowerCase());
    if (y !== -1) {
      var E, S, A;
      for (e.lastIndex = y; S = e.exec(g); ) {
        if (S.index !== y)
          throw new TypeError("invalid parameter format");
        y += S[0].length, E = S[1].toLowerCase(), A = S[2], A.charCodeAt(0) === 34 && (A = A.slice(1, -1), A.indexOf("\\") !== -1 && (A = A.replace(r, "$1"))), x.parameters[E] = A;
      }
      if (y !== g.length)
        throw new TypeError("invalid parameter format");
    }
    return x;
  }
  function f(p) {
    var g;
    if (typeof p.getHeader == "function" ? g = p.getHeader("content-type") : typeof p.headers == "object" && (g = p.headers && p.headers["content-type"]), typeof g != "string")
      throw new TypeError("content-type header is missing from object");
    return g;
  }
  function d(p) {
    var g = String(p);
    if (n.test(g))
      return g;
    if (g.length > 0 && !t.test(g))
      throw new TypeError("invalid parameter value");
    return '"' + g.replace(i, "\\$1") + '"';
  }
  function h(p) {
    this.parameters = /* @__PURE__ */ Object.create(null), this.type = p;
  }
  return Ud;
}
var Mie = Nie(), Bs = /* @__PURE__ */ new Map(), k5 = function(t) {
  return t.cloneNode(!0);
}, XA = function() {
  return window.location.protocol === "file:";
}, A5 = function(t, n, r) {
  var i = new XMLHttpRequest();
  i.onreadystatechange = function() {
    try {
      if (!/\.svg/i.test(t) && i.readyState === 2) {
        var a = i.getResponseHeader("Content-Type");
        if (!a)
          throw new Error("Content type not found");
        var s = Mie.parse(a).type;
        if (!(s === "image/svg+xml" || s === "text/plain"))
          throw new Error("Invalid content type: ".concat(s));
      }
      if (i.readyState === 4) {
        if (i.status === 404 || i.responseXML === null)
          throw new Error(XA() ? "Note: SVG injection ajax calls do not work locally without adjusting security settings in your browser. Or consider using a local webserver." : "Unable to load SVG file: " + t);
        if (i.status === 200 || XA() && i.status === 0)
          r(null, i);
        else
          throw new Error("There was a problem injecting the SVG: " + i.status + " " + i.statusText);
      }
    } catch (u) {
      if (i.abort(), u instanceof Error)
        r(u, i);
      else
        throw u;
    }
  }, i.open("GET", t), i.withCredentials = n, i.overrideMimeType && i.overrideMimeType("text/xml"), i.send();
}, jo = {}, WA = function(t, n) {
  jo[t] = jo[t] || [], jo[t].push(n);
}, Die = function(t) {
  for (var n = function(s, u) {
    setTimeout(function() {
      if (Array.isArray(jo[t])) {
        var f = Bs.get(t), d = jo[t][s];
        f instanceof SVGSVGElement && d(null, k5(f)), f instanceof Error && d(f), s === jo[t].length - 1 && delete jo[t];
      }
    }, 0);
  }, r = 0, i = jo[t].length; r < i; r++)
    n(r);
}, Pie = function(t, n, r) {
  if (Bs.has(t)) {
    var i = Bs.get(t);
    if (i === void 0) {
      WA(t, r);
      return;
    }
    if (i instanceof SVGSVGElement) {
      r(null, k5(i));
      return;
    }
  }
  Bs.set(t, void 0), WA(t, r), A5(t, n, function(a, s) {
    var u;
    a ? Bs.set(t, a) : ((u = s.responseXML) === null || u === void 0 ? void 0 : u.documentElement) instanceof SVGSVGElement && Bs.set(t, s.responseXML.documentElement), Die(t);
  });
}, zie = function(t, n, r) {
  A5(t, n, function(i, a) {
    var s;
    i ? r(i) : ((s = a.responseXML) === null || s === void 0 ? void 0 : s.documentElement) instanceof SVGSVGElement && r(null, a.responseXML.documentElement);
  });
}, jie = 0, Iie = function() {
  return ++jie;
}, Gr = [], KA = {}, Lie = "http://www.w3.org/2000/svg", Oy = "http://www.w3.org/1999/xlink", ZA = function(t, n, r, i, a, s, u) {
  var f = t.getAttribute("data-src") || t.getAttribute("src");
  if (!f) {
    u(new Error("Invalid data-src or src attribute"));
    return;
  }
  if (Gr.indexOf(t) !== -1) {
    Gr.splice(Gr.indexOf(t), 1), t = null;
    return;
  }
  Gr.push(t), t.setAttribute("src", "");
  var d = i ? Pie : zie;
  d(f, a, function(h, p) {
    if (!p) {
      Gr.splice(Gr.indexOf(t), 1), t = null, u(h);
      return;
    }
    var g = t.getAttribute("id");
    g && p.setAttribute("id", g);
    var y = t.getAttribute("title");
    y && p.setAttribute("title", y);
    var b = t.getAttribute("width");
    b && p.setAttribute("width", b);
    var x = t.getAttribute("height");
    x && p.setAttribute("height", x);
    var E = Array.from(new Set(rh(rh(rh([], (p.getAttribute("class") || "").split(" "), !0), ["injected-svg"], !1), (t.getAttribute("class") || "").split(" "), !0))).join(" ").trim();
    p.setAttribute("class", E);
    var S = t.getAttribute("style");
    S && p.setAttribute("style", S), p.setAttribute("data-src", f);
    var A = [].filter.call(t.attributes, function(q) {
      return /^data-\w[\w-]*$/.test(q.name);
    });
    if (Array.prototype.forEach.call(A, function(q) {
      q.name && q.value && p.setAttribute(q.name, q.value);
    }), r) {
      var k = {
        clipPath: ["clip-path"],
        "color-profile": ["color-profile"],
        cursor: ["cursor"],
        filter: ["filter"],
        linearGradient: ["fill", "stroke"],
        marker: ["marker", "marker-start", "marker-mid", "marker-end"],
        mask: ["mask"],
        path: [],
        pattern: ["fill", "stroke"],
        radialGradient: ["fill", "stroke"]
      }, R, N, D, P, F;
      Object.keys(k).forEach(function(q) {
        R = q, D = k[q], N = p.querySelectorAll(R + "[id]");
        for (var Y = function(I, ie) {
          P = N[I].id, F = P + "-" + Iie();
          var fe;
          Array.prototype.forEach.call(D, function(Le) {
            fe = p.querySelectorAll("[" + Le + '*="' + P + '"]');
            for (var Ie = 0, ft = fe.length; Ie < ft; Ie++) {
              var Jt = fe[Ie].getAttribute(Le);
              Jt && !Jt.match(new RegExp('url\\("?#' + P + '"?\\)')) || fe[Ie].setAttribute(Le, "url(#" + F + ")");
            }
          });
          for (var re = p.querySelectorAll("[*|href]"), le = [], he = 0, ye = re.length; he < ye; he++) {
            var je = re[he].getAttributeNS(Oy, "href");
            je && je.toString() === "#" + N[I].id && le.push(re[he]);
          }
          for (var Oe = 0, be = le.length; Oe < be; Oe++)
            le[Oe].setAttributeNS(Oy, "href", "#" + F);
          N[I].id = F;
        }, O = 0, W = N.length; O < W; O++)
          Y(O);
      });
    }
    p.removeAttribute("xmlns:a");
    for (var V = p.querySelectorAll("script"), T = [], $, H, G = 0, j = V.length; G < j; G++)
      H = V[G].getAttribute("type"), (!H || H === "application/ecmascript" || H === "application/javascript" || H === "text/javascript") && ($ = V[G].innerText || V[G].textContent, $ && T.push($), p.removeChild(V[G]));
    if (T.length > 0 && (n === "always" || n === "once" && !KA[f])) {
      for (var U = 0, z = T.length; U < z; U++)
        new Function(T[U])(window);
      KA[f] = !0;
    }
    var B = p.querySelectorAll("style");
    if (Array.prototype.forEach.call(B, function(q) {
      q.textContent += "";
    }), p.setAttribute("xmlns", Lie), p.setAttribute("xmlns:xlink", Oy), s(p), !t.parentNode) {
      Gr.splice(Gr.indexOf(t), 1), t = null, u(new Error("Parent node is null"));
      return;
    }
    t.parentNode.replaceChild(p, t), Gr.splice(Gr.indexOf(t), 1), t = null, u(null, p);
  });
}, Fie = function(t, n) {
  var r = n === void 0 ? {} : n, i = r.afterAll, a = i === void 0 ? function() {
  } : i, s = r.afterEach, u = s === void 0 ? function() {
  } : s, f = r.beforeEach, d = f === void 0 ? function() {
  } : f, h = r.cacheRequests, p = h === void 0 ? !0 : h, g = r.evalScripts, y = g === void 0 ? "never" : g, b = r.httpRequestWithCredentials, x = b === void 0 ? !1 : b, E = r.renumerateIRIElements, S = E === void 0 ? !0 : E;
  if (t && "length" in t)
    for (var A = 0, k = 0, R = t.length; k < R; k++)
      ZA(t[k], y, S, p, x, d, function(N, D) {
        u(N, D), t && "length" in t && t.length === ++A && a(A);
      });
  else t ? ZA(t, y, S, p, x, d, function(N, D) {
    u(N, D), a(1), t = null;
  }) : a(0);
}, Bie = function(t) {
  var n = t?.ownerDocument || document;
  return n.defaultView || window;
}, $ie = function(t, n) {
  for (var r in t)
    if (!(r in n))
      return !0;
  for (var i in n)
    if (t[i] !== n[i])
      return !0;
  return !1;
}, Hie = ["afterInjection", "beforeInjection", "desc", "evalScripts", "fallback", "httpRequestWithCredentials", "loading", "renumerateIRIElements", "src", "title", "useRequestCache", "wrapper"], qd = "http://www.w3.org/2000/svg", QA = "http://www.w3.org/1999/xlink", tx = /* @__PURE__ */ function(e) {
  function t() {
    for (var r, i = arguments.length, a = new Array(i), s = 0; s < i; s++)
      a[s] = arguments[s];
    return r = e.call.apply(e, [this].concat(a)) || this, r.initialState = {
      hasError: !1,
      isLoading: !0
    }, r.state = r.initialState, r._isMounted = !1, r.reactWrapper = void 0, r.nonReactWrapper = void 0, r.refCallback = function(u) {
      r.reactWrapper = u;
    }, r;
  }
  E5(t, e);
  var n = t.prototype;
  return n.renderSVG = function() {
    var i = this;
    if (this.reactWrapper instanceof Bie(this.reactWrapper).Node) {
      var a = this.props, s = a.desc, u = a.evalScripts, f = a.httpRequestWithCredentials, d = a.renumerateIRIElements, h = a.src, p = a.title, g = a.useRequestCache, y = this.props.onError, b = this.props.beforeInjection, x = this.props.afterInjection, E = this.props.wrapper, S, A;
      E === "svg" ? (S = document.createElementNS(qd, E), S.setAttribute("xmlns", qd), S.setAttribute("xmlns:xlink", QA), A = document.createElementNS(qd, E)) : (S = document.createElement(E), A = document.createElement(E)), S.appendChild(A), A.dataset.src = h, this.nonReactWrapper = this.reactWrapper.appendChild(S);
      var k = function(P) {
        if (i.removeSVG(), !i._isMounted) {
          y(P);
          return;
        }
        i.setState(function() {
          return {
            hasError: !0,
            isLoading: !1
          };
        }, function() {
          y(P);
        });
      }, R = function(P, F) {
        if (P) {
          k(P);
          return;
        }
        i._isMounted && i.setState(function() {
          return {
            isLoading: !1
          };
        }, function() {
          try {
            x(F);
          } catch (V) {
            k(V);
          }
        });
      }, N = function(P) {
        if (P.setAttribute("role", "img"), s) {
          var F = P.querySelector(":scope > desc");
          F && P.removeChild(F);
          var V = document.createElement("desc");
          V.innerHTML = s, P.prepend(V);
        }
        if (p) {
          var T = P.querySelector(":scope > title");
          T && P.removeChild(T);
          var $ = document.createElement("title");
          $.innerHTML = p, P.prepend($);
        }
        try {
          b(P);
        } catch (H) {
          k(H);
        }
      };
      Fie(A, {
        afterEach: R,
        beforeEach: N,
        cacheRequests: g,
        evalScripts: u,
        httpRequestWithCredentials: f,
        renumerateIRIElements: d
      });
    }
  }, n.removeSVG = function() {
    var i;
    (i = this.nonReactWrapper) != null && i.parentNode && (this.nonReactWrapper.parentNode.removeChild(this.nonReactWrapper), this.nonReactWrapper = null);
  }, n.componentDidMount = function() {
    this._isMounted = !0, this.renderSVG();
  }, n.componentDidUpdate = function(i) {
    var a = this;
    $ie(ke({}, i), this.props) && this.setState(function() {
      return a.initialState;
    }, function() {
      a.removeSVG(), a.renderSVG();
    });
  }, n.componentWillUnmount = function() {
    this._isMounted = !1, this.removeSVG();
  }, n.render = function() {
    var i = this.props;
    i.afterInjection, i.beforeInjection, i.desc, i.evalScripts;
    var a = i.fallback;
    i.httpRequestWithCredentials;
    var s = i.loading;
    i.renumerateIRIElements, i.src, i.title, i.useRequestCache;
    var u = i.wrapper, f = Q1(i, Hie), d = u;
    return /* @__PURE__ */ C.createElement(d, ke({}, f, {
      ref: this.refCallback
    }, u === "svg" ? {
      xmlns: qd,
      xmlnsXlink: QA
    } : {}), this.state.isLoading && s && /* @__PURE__ */ C.createElement(s, null), this.state.hasError && a && /* @__PURE__ */ C.createElement(a, null));
  }, t;
}(C.Component);
tx.defaultProps = {
  afterInjection: function() {
  },
  beforeInjection: function() {
  },
  desc: "",
  evalScripts: "never",
  fallback: null,
  httpRequestWithCredentials: !1,
  loading: null,
  onError: function() {
  },
  renumerateIRIElements: !0,
  title: "",
  useRequestCache: !0,
  wrapper: "div"
};
tx.propTypes = {
  afterInjection: Bt.func,
  beforeInjection: Bt.func,
  desc: Bt.string,
  evalScripts: Bt.oneOf(["always", "once", "never"]),
  fallback: Bt.oneOfType([Bt.func, Bt.object, Bt.string]),
  httpRequestWithCredentials: Bt.bool,
  loading: Bt.oneOfType([Bt.func, Bt.object, Bt.string]),
  onError: Bt.func,
  renumerateIRIElements: Bt.bool,
  src: Bt.string.isRequired,
  title: Bt.string,
  useRequestCache: Bt.bool,
  wrapper: Bt.oneOf(["div", "span", "svg"])
};
const Vie = ({ value: e }) => /* @__PURE__ */ _.jsx(
  tx,
  {
    src: `data:image/svg+xml;base64,${btoa(e)}`,
    style: {
      maxWidth: "100%",
      maxHeight: "100%"
    },
    beforeInjection: (t) => {
      t.classList.add("svg-class-name"), t.setAttribute("style", "max-width: 100%; max-height: 100%;"), t.setAttribute("width", "100%"), t.setAttribute("height", "100%");
    }
  }
), T5 = ({
  value: e,
  preValue: t,
  onLoaded: n
}) => {
  const [r, i] = C.useState(t || e);
  if (C.useEffect(() => {
    if (e === t) return;
    const u = new Image();
    return u.onload = () => {
      n?.(), i(e);
    }, u.src = e, () => {
      u.onload = null;
    };
  }, [e, t, n]), r === void 0)
    return /* @__PURE__ */ _.jsx(_.Fragment, {});
  if (typeof r != "string")
    return console.error("ImageRenderer: value is not a string", r), /* @__PURE__ */ _.jsx(_.Fragment, {});
  const a = r.startsWith("data:") || r.startsWith("blob:");
  let s = r;
  return a || (s = "data:image/jpeg;base64," + r), /* @__PURE__ */ _.jsx("img", { src: s, style: { maxWidth: "100%", maxHeight: "100%" } });
}, R5 = ({
  value: e
}) => /* @__PURE__ */ _.jsx(Vie, { value: e }), O5 = ({
  value: e
}) => {
  let t = "";
  try {
    t = JSON.stringify(e);
  } catch {
  }
  return /* @__PURE__ */ _.jsx("div", { children: /* @__PURE__ */ _.jsx("pre", { children: t }) });
}, nx = ({
  value: e
}) => {
  if (typeof e != "string" || e.length % 4 !== 0)
    return /* @__PURE__ */ _.jsx("div", { children: e });
  const t = Math.round(3 * e.length / 4);
  return /* @__PURE__ */ _.jsx("div", { children: /* @__PURE__ */ _.jsxs("pre", { children: [
    "Bytes(",
    t,
    ")"
  ] }) });
}, N5 = ({
  value: e
}) => /* @__PURE__ */ _.jsx(
  Oie,
  {
    tabledata: e || {
      columns: [],
      index: [],
      data: []
    }
  }
), am = ({
  value: e
}) => /* @__PURE__ */ _.jsx(hee, { data: e }), Wh = am, Uie = {
  string: O5,
  table: N5,
  image: T5,
  svg: R5,
  dict: am,
  bytes: nx
};
function M5(e, [t, n]) {
  return Math.min(n, Math.max(t, e));
}
function qie(e) {
  const t = C.useRef({ value: e, previous: e });
  return C.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]);
}
var D5 = ["PageUp", "PageDown"], P5 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], z5 = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
}, kl = "Slider", [nb, Yie, Gie] = Xb(kl), [j5, Pue] = Go(kl, [
  Gie
]), [Xie, sm] = j5(kl), I5 = C.forwardRef(
  (e, t) => {
    const {
      name: n,
      min: r = 0,
      max: i = 100,
      step: a = 1,
      orientation: s = "horizontal",
      disabled: u = !1,
      minStepsBetweenThumbs: f = 0,
      defaultValue: d = [r],
      value: h,
      onValueChange: p = () => {
      },
      onValueCommit: g = () => {
      },
      inverted: y = !1,
      form: b,
      ...x
    } = e, E = C.useRef(/* @__PURE__ */ new Set()), S = C.useRef(0), k = s === "horizontal" ? Wie : Kie, [R = [], N] = yl({
      prop: h,
      defaultProp: d,
      onChange: ($) => {
        [...E.current][S.current]?.focus(), p($);
      }
    }), D = C.useRef(R);
    function P($) {
      const H = toe(R, $);
      T($, H);
    }
    function F($) {
      T($, S.current);
    }
    function V() {
      const $ = D.current[S.current];
      R[S.current] !== $ && g(R);
    }
    function T($, H, { commit: G } = { commit: !1 }) {
      const j = ooe(a), U = aoe(Math.round(($ - r) / a) * a + r, j), z = M5(U, [r, i]);
      N((B = []) => {
        const q = Jie(B, z, H);
        if (ioe(q, f * a)) {
          S.current = q.indexOf(z);
          const Y = String(q) !== String(B);
          return Y && G && g(q), Y ? q : B;
        } else
          return B;
      });
    }
    return /* @__PURE__ */ _.jsx(
      Xie,
      {
        scope: e.__scopeSlider,
        name: n,
        disabled: u,
        min: r,
        max: i,
        valueIndexToChangeRef: S,
        thumbs: E.current,
        values: R,
        orientation: s,
        form: b,
        children: /* @__PURE__ */ _.jsx(nb.Provider, { scope: e.__scopeSlider, children: /* @__PURE__ */ _.jsx(nb.Slot, { scope: e.__scopeSlider, children: /* @__PURE__ */ _.jsx(
          k,
          {
            "aria-disabled": u,
            "data-disabled": u ? "" : void 0,
            ...x,
            ref: t,
            onPointerDown: De(x.onPointerDown, () => {
              u || (D.current = R);
            }),
            min: r,
            max: i,
            inverted: y,
            onSlideStart: u ? void 0 : P,
            onSlideMove: u ? void 0 : F,
            onSlideEnd: u ? void 0 : V,
            onHomeKeyDown: () => !u && T(r, 0, { commit: !0 }),
            onEndKeyDown: () => !u && T(i, R.length - 1, { commit: !0 }),
            onStepKeyDown: ({ event: $, direction: H }) => {
              if (!u) {
                const U = D5.includes($.key) || $.shiftKey && P5.includes($.key) ? 10 : 1, z = S.current, B = R[z], q = a * U * H;
                T(B + q, z, { commit: !0 });
              }
            }
          }
        ) }) })
      }
    );
  }
);
I5.displayName = kl;
var [L5, F5] = j5(kl, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
}), Wie = C.forwardRef(
  (e, t) => {
    const {
      min: n,
      max: r,
      dir: i,
      inverted: a,
      onSlideStart: s,
      onSlideMove: u,
      onSlideEnd: f,
      onStepKeyDown: d,
      ...h
    } = e, [p, g] = C.useState(null), y = Et(t, (k) => g(k)), b = C.useRef(void 0), x = Wb(i), E = x === "ltr", S = E && !a || !E && a;
    function A(k) {
      const R = b.current || p.getBoundingClientRect(), N = [0, R.width], P = rx(N, S ? [n, r] : [r, n]);
      return b.current = R, P(k - R.left);
    }
    return /* @__PURE__ */ _.jsx(
      L5,
      {
        scope: e.__scopeSlider,
        startEdge: S ? "left" : "right",
        endEdge: S ? "right" : "left",
        direction: S ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ _.jsx(
          B5,
          {
            dir: x,
            "data-orientation": "horizontal",
            ...h,
            ref: y,
            style: {
              ...h.style,
              "--radix-slider-thumb-transform": "translateX(-50%)"
            },
            onSlideStart: (k) => {
              const R = A(k.clientX);
              s?.(R);
            },
            onSlideMove: (k) => {
              const R = A(k.clientX);
              u?.(R);
            },
            onSlideEnd: () => {
              b.current = void 0, f?.();
            },
            onStepKeyDown: (k) => {
              const N = z5[S ? "from-left" : "from-right"].includes(k.key);
              d?.({ event: k, direction: N ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), Kie = C.forwardRef(
  (e, t) => {
    const {
      min: n,
      max: r,
      inverted: i,
      onSlideStart: a,
      onSlideMove: s,
      onSlideEnd: u,
      onStepKeyDown: f,
      ...d
    } = e, h = C.useRef(null), p = Et(t, h), g = C.useRef(void 0), y = !i;
    function b(x) {
      const E = g.current || h.current.getBoundingClientRect(), S = [0, E.height], k = rx(S, y ? [r, n] : [n, r]);
      return g.current = E, k(x - E.top);
    }
    return /* @__PURE__ */ _.jsx(
      L5,
      {
        scope: e.__scopeSlider,
        startEdge: y ? "bottom" : "top",
        endEdge: y ? "top" : "bottom",
        size: "height",
        direction: y ? 1 : -1,
        children: /* @__PURE__ */ _.jsx(
          B5,
          {
            "data-orientation": "vertical",
            ...d,
            ref: p,
            style: {
              ...d.style,
              "--radix-slider-thumb-transform": "translateY(50%)"
            },
            onSlideStart: (x) => {
              const E = b(x.clientY);
              a?.(E);
            },
            onSlideMove: (x) => {
              const E = b(x.clientY);
              s?.(E);
            },
            onSlideEnd: () => {
              g.current = void 0, u?.();
            },
            onStepKeyDown: (x) => {
              const S = z5[y ? "from-bottom" : "from-top"].includes(x.key);
              f?.({ event: x, direction: S ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), B5 = C.forwardRef(
  (e, t) => {
    const {
      __scopeSlider: n,
      onSlideStart: r,
      onSlideMove: i,
      onSlideEnd: a,
      onHomeKeyDown: s,
      onEndKeyDown: u,
      onStepKeyDown: f,
      ...d
    } = e, h = sm(kl, n);
    return /* @__PURE__ */ _.jsx(
      vt.span,
      {
        ...d,
        ref: t,
        onKeyDown: De(e.onKeyDown, (p) => {
          p.key === "Home" ? (s(p), p.preventDefault()) : p.key === "End" ? (u(p), p.preventDefault()) : D5.concat(P5).includes(p.key) && (f(p), p.preventDefault());
        }),
        onPointerDown: De(e.onPointerDown, (p) => {
          const g = p.target;
          g.setPointerCapture(p.pointerId), p.preventDefault(), h.thumbs.has(g) ? g.focus() : r(p);
        }),
        onPointerMove: De(e.onPointerMove, (p) => {
          p.target.hasPointerCapture(p.pointerId) && i(p);
        }),
        onPointerUp: De(e.onPointerUp, (p) => {
          const g = p.target;
          g.hasPointerCapture(p.pointerId) && (g.releasePointerCapture(p.pointerId), a(p));
        })
      }
    );
  }
), $5 = "SliderTrack", H5 = C.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, ...r } = e, i = sm($5, n);
    return /* @__PURE__ */ _.jsx(
      vt.span,
      {
        "data-disabled": i.disabled ? "" : void 0,
        "data-orientation": i.orientation,
        ...r,
        ref: t
      }
    );
  }
);
H5.displayName = $5;
var rb = "SliderRange", V5 = C.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, ...r } = e, i = sm(rb, n), a = F5(rb, n), s = C.useRef(null), u = Et(t, s), f = i.values.length, d = i.values.map(
      (g) => q5(g, i.min, i.max)
    ), h = f > 1 ? Math.min(...d) : 0, p = 100 - Math.max(...d);
    return /* @__PURE__ */ _.jsx(
      vt.span,
      {
        "data-orientation": i.orientation,
        "data-disabled": i.disabled ? "" : void 0,
        ...r,
        ref: u,
        style: {
          ...e.style,
          [a.startEdge]: h + "%",
          [a.endEdge]: p + "%"
        }
      }
    );
  }
);
V5.displayName = rb;
var ib = "SliderThumb", U5 = C.forwardRef(
  (e, t) => {
    const n = Yie(e.__scopeSlider), [r, i] = C.useState(null), a = Et(t, (u) => i(u)), s = C.useMemo(
      () => r ? n().findIndex((u) => u.ref.current === r) : -1,
      [n, r]
    );
    return /* @__PURE__ */ _.jsx(Zie, { ...e, ref: a, index: s });
  }
), Zie = C.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, index: r, name: i, ...a } = e, s = sm(ib, n), u = F5(ib, n), [f, d] = C.useState(null), h = Et(t, (A) => d(A)), p = f ? s.form || !!f.closest("form") : !0, g = p2(f), y = s.values[r], b = y === void 0 ? 0 : q5(y, s.min, s.max), x = eoe(r, s.values.length), E = g?.[u.size], S = E ? noe(E, b, u.direction) : 0;
    return C.useEffect(() => {
      if (f)
        return s.thumbs.add(f), () => {
          s.thumbs.delete(f);
        };
    }, [f, s.thumbs]), /* @__PURE__ */ _.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [u.startEdge]: `calc(${b}% + ${S}px)`
        },
        children: [
          /* @__PURE__ */ _.jsx(nb.ItemSlot, { scope: e.__scopeSlider, children: /* @__PURE__ */ _.jsx(
            vt.span,
            {
              role: "slider",
              "aria-label": e["aria-label"] || x,
              "aria-valuemin": s.min,
              "aria-valuenow": y,
              "aria-valuemax": s.max,
              "aria-orientation": s.orientation,
              "data-orientation": s.orientation,
              "data-disabled": s.disabled ? "" : void 0,
              tabIndex: s.disabled ? void 0 : 0,
              ...a,
              ref: h,
              style: y === void 0 ? { display: "none" } : e.style,
              onFocus: De(e.onFocus, () => {
                s.valueIndexToChangeRef.current = r;
              })
            }
          ) }),
          p && /* @__PURE__ */ _.jsx(
            Qie,
            {
              name: i ?? (s.name ? s.name + (s.values.length > 1 ? "[]" : "") : void 0),
              form: s.form,
              value: y
            },
            r
          )
        ]
      }
    );
  }
);
U5.displayName = ib;
var Qie = (e) => {
  const { value: t, ...n } = e, r = C.useRef(null), i = qie(t);
  return C.useEffect(() => {
    const a = r.current, s = window.HTMLInputElement.prototype, f = Object.getOwnPropertyDescriptor(s, "value").set;
    if (i !== t && f) {
      const d = new Event("input", { bubbles: !0 });
      f.call(a, t), a.dispatchEvent(d);
    }
  }, [i, t]), /* @__PURE__ */ _.jsx("input", { style: { display: "none" }, ...n, ref: r, defaultValue: t });
};
function Jie(e = [], t, n) {
  const r = [...e];
  return r[n] = t, r.sort((i, a) => i - a);
}
function q5(e, t, n) {
  const a = 100 / (n - t) * (e - t);
  return M5(a, [0, 100]);
}
function eoe(e, t) {
  return t > 2 ? `Value ${e + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][e] : void 0;
}
function toe(e, t) {
  if (e.length === 1) return 0;
  const n = e.map((i) => Math.abs(i - t)), r = Math.min(...n);
  return n.indexOf(r);
}
function noe(e, t, n) {
  const r = e / 2, a = rx([0, 50], [0, r]);
  return (r - a(t) * n) * n;
}
function roe(e) {
  return e.slice(0, -1).map((t, n) => e[n + 1] - t);
}
function ioe(e, t) {
  if (t > 0) {
    const n = roe(e);
    return Math.min(...n) >= t;
  }
  return !0;
}
function rx(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const r = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + r * (n - e[0]);
  };
}
function ooe(e) {
  return (String(e).split(".")[1] || "").length;
}
function aoe(e, t) {
  const n = Math.pow(10, t);
  return Math.round(e * n) / n;
}
var soe = I5, loe = H5, uoe = V5, coe = U5;
const Ac = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
}, Y5 = {};
for (const e of Object.keys(Ac))
  Y5[Ac[e]] = e;
const ve = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  lch: { channels: 3, labels: "lch" },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] }
}, Fi = (6 / 29) ** 3;
for (const e of Object.keys(ve)) {
  if (!("channels" in ve[e]))
    throw new Error("missing channels property: " + e);
  if (!("labels" in ve[e]))
    throw new Error("missing channel labels property: " + e);
  if (ve[e].labels.length !== ve[e].channels)
    throw new Error("channel and label counts mismatch: " + e);
  const { channels: t, labels: n } = ve[e];
  delete ve[e].channels, delete ve[e].labels, Object.defineProperty(ve[e], "channels", { value: t }), Object.defineProperty(ve[e], "labels", { value: n });
}
ve.rgb.hsl = function(e) {
  const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, i = Math.min(t, n, r), a = Math.max(t, n, r), s = a - i;
  let u, f;
  switch (a) {
    case i: {
      u = 0;
      break;
    }
    case t: {
      u = (n - r) / s;
      break;
    }
    case n: {
      u = 2 + (r - t) / s;
      break;
    }
    case r: {
      u = 4 + (t - n) / s;
      break;
    }
  }
  u = Math.min(u * 60, 360), u < 0 && (u += 360);
  const d = (i + a) / 2;
  return a === i ? f = 0 : d <= 0.5 ? f = s / (a + i) : f = s / (2 - a - i), [u, f * 100, d * 100];
};
ve.rgb.hsv = function(e) {
  let t, n, r, i, a;
  const s = e[0] / 255, u = e[1] / 255, f = e[2] / 255, d = Math.max(s, u, f), h = d - Math.min(s, u, f), p = function(g) {
    return (d - g) / 6 / h + 1 / 2;
  };
  if (h === 0)
    i = 0, a = 0;
  else {
    switch (a = h / d, t = p(s), n = p(u), r = p(f), d) {
      case s: {
        i = r - n;
        break;
      }
      case u: {
        i = 1 / 3 + t - r;
        break;
      }
      case f: {
        i = 2 / 3 + n - t;
        break;
      }
    }
    i < 0 ? i += 1 : i > 1 && (i -= 1);
  }
  return [
    i * 360,
    a * 100,
    d * 100
  ];
};
ve.rgb.hwb = function(e) {
  const t = e[0], n = e[1];
  let r = e[2];
  const i = ve.rgb.hsl(e)[0], a = 1 / 255 * Math.min(t, Math.min(n, r));
  return r = 1 - 1 / 255 * Math.max(t, Math.max(n, r)), [i, a * 100, r * 100];
};
ve.rgb.cmyk = function(e) {
  const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, i = Math.min(1 - t, 1 - n, 1 - r), a = (1 - t - i) / (1 - i) || 0, s = (1 - n - i) / (1 - i) || 0, u = (1 - r - i) / (1 - i) || 0;
  return [a * 100, s * 100, u * 100, i * 100];
};
function foe(e, t) {
  return (e[0] - t[0]) ** 2 + (e[1] - t[1]) ** 2 + (e[2] - t[2]) ** 2;
}
ve.rgb.keyword = function(e) {
  const t = Y5[e];
  if (t)
    return t;
  let n = Number.POSITIVE_INFINITY, r;
  for (const i of Object.keys(Ac)) {
    const a = Ac[i], s = foe(e, a);
    s < n && (n = s, r = i);
  }
  return r;
};
ve.keyword.rgb = function(e) {
  return Ac[e];
};
ve.rgb.xyz = function(e) {
  let t = e[0] / 255, n = e[1] / 255, r = e[2] / 255;
  t = t > 0.04045 ? ((t + 0.055) / 1.055) ** 2.4 : t / 12.92, n = n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92, r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
  const i = t * 0.4124564 + n * 0.3575761 + r * 0.1804375, a = t * 0.2126729 + n * 0.7151522 + r * 0.072175, s = t * 0.0193339 + n * 0.119192 + r * 0.9503041;
  return [i * 100, a * 100, s * 100];
};
ve.rgb.lab = function(e) {
  const t = ve.rgb.xyz(e);
  let n = t[0], r = t[1], i = t[2];
  n /= 95.047, r /= 100, i /= 108.883, n = n > Fi ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > Fi ? r ** (1 / 3) : 7.787 * r + 16 / 116, i = i > Fi ? i ** (1 / 3) : 7.787 * i + 16 / 116;
  const a = 116 * r - 16, s = 500 * (n - r), u = 200 * (r - i);
  return [a, s, u];
};
ve.hsl.rgb = function(e) {
  const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
  let i, a;
  if (n === 0)
    return a = r * 255, [a, a, a];
  const s = r < 0.5 ? r * (1 + n) : r + n - r * n, u = 2 * r - s, f = [0, 0, 0];
  for (let d = 0; d < 3; d++)
    i = t + 1 / 3 * -(d - 1), i < 0 && i++, i > 1 && i--, 6 * i < 1 ? a = u + (s - u) * 6 * i : 2 * i < 1 ? a = s : 3 * i < 2 ? a = u + (s - u) * (2 / 3 - i) * 6 : a = u, f[d] = a * 255;
  return f;
};
ve.hsl.hsv = function(e) {
  const t = e[0];
  let n = e[1] / 100, r = e[2] / 100, i = n;
  const a = Math.max(r, 0.01);
  r *= 2, n *= r <= 1 ? r : 2 - r, i *= a <= 1 ? a : 2 - a;
  const s = (r + n) / 2, u = r === 0 ? 2 * i / (a + i) : 2 * n / (r + n);
  return [t, u * 100, s * 100];
};
ve.hsv.rgb = function(e) {
  const t = e[0] / 60, n = e[1] / 100;
  let r = e[2] / 100;
  const i = Math.floor(t) % 6, a = t - Math.floor(t), s = 255 * r * (1 - n), u = 255 * r * (1 - n * a), f = 255 * r * (1 - n * (1 - a));
  switch (r *= 255, i) {
    case 0:
      return [r, f, s];
    case 1:
      return [u, r, s];
    case 2:
      return [s, r, f];
    case 3:
      return [s, u, r];
    case 4:
      return [f, s, r];
    case 5:
      return [r, s, u];
  }
};
ve.hsv.hsl = function(e) {
  const t = e[0], n = e[1] / 100, r = e[2] / 100, i = Math.max(r, 0.01);
  let a, s;
  s = (2 - n) * r;
  const u = (2 - n) * i;
  return a = n * i, a /= u <= 1 ? u : 2 - u, a = a || 0, s /= 2, [t, a * 100, s * 100];
};
ve.hwb.rgb = function(e) {
  const t = e[0] / 360;
  let n = e[1] / 100, r = e[2] / 100;
  const i = n + r;
  let a;
  i > 1 && (n /= i, r /= i);
  const s = Math.floor(6 * t), u = 1 - r;
  a = 6 * t - s, (s & 1) !== 0 && (a = 1 - a);
  const f = n + a * (u - n);
  let d, h, p;
  switch (s) {
    default:
    case 6:
    case 0: {
      d = u, h = f, p = n;
      break;
    }
    case 1: {
      d = f, h = u, p = n;
      break;
    }
    case 2: {
      d = n, h = u, p = f;
      break;
    }
    case 3: {
      d = n, h = f, p = u;
      break;
    }
    case 4: {
      d = f, h = n, p = u;
      break;
    }
    case 5: {
      d = u, h = n, p = f;
      break;
    }
  }
  return [d * 255, h * 255, p * 255];
};
ve.cmyk.rgb = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, i = e[3] / 100, a = 1 - Math.min(1, t * (1 - i) + i), s = 1 - Math.min(1, n * (1 - i) + i), u = 1 - Math.min(1, r * (1 - i) + i);
  return [a * 255, s * 255, u * 255];
};
ve.xyz.rgb = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100;
  let i, a, s;
  return i = t * 3.2404542 + n * -1.5371385 + r * -0.4985314, a = t * -0.969266 + n * 1.8760108 + r * 0.041556, s = t * 0.0556434 + n * -0.2040259 + r * 1.0572252, i = i > 31308e-7 ? 1.055 * i ** (1 / 2.4) - 0.055 : i * 12.92, a = a > 31308e-7 ? 1.055 * a ** (1 / 2.4) - 0.055 : a * 12.92, s = s > 31308e-7 ? 1.055 * s ** (1 / 2.4) - 0.055 : s * 12.92, i = Math.min(Math.max(0, i), 1), a = Math.min(Math.max(0, a), 1), s = Math.min(Math.max(0, s), 1), [i * 255, a * 255, s * 255];
};
ve.xyz.lab = function(e) {
  let t = e[0], n = e[1], r = e[2];
  t /= 95.047, n /= 100, r /= 108.883, t = t > Fi ? t ** (1 / 3) : 7.787 * t + 16 / 116, n = n > Fi ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > Fi ? r ** (1 / 3) : 7.787 * r + 16 / 116;
  const i = 116 * n - 16, a = 500 * (t - n), s = 200 * (n - r);
  return [i, a, s];
};
ve.lab.xyz = function(e) {
  const t = e[0], n = e[1], r = e[2];
  let i, a, s;
  a = (t + 16) / 116, i = n / 500 + a, s = a - r / 200;
  const u = a ** 3, f = i ** 3, d = s ** 3;
  return a = u > Fi ? u : (a - 16 / 116) / 7.787, i = f > Fi ? f : (i - 16 / 116) / 7.787, s = d > Fi ? d : (s - 16 / 116) / 7.787, i *= 95.047, a *= 100, s *= 108.883, [i, a, s];
};
ve.lab.lch = function(e) {
  const t = e[0], n = e[1], r = e[2];
  let i;
  i = Math.atan2(r, n) * 360 / 2 / Math.PI, i < 0 && (i += 360);
  const s = Math.sqrt(n * n + r * r);
  return [t, s, i];
};
ve.lch.lab = function(e) {
  const t = e[0], n = e[1], i = e[2] / 360 * 2 * Math.PI, a = n * Math.cos(i), s = n * Math.sin(i);
  return [t, a, s];
};
ve.rgb.ansi16 = function(e, t = null) {
  const [n, r, i] = e;
  let a = t === null ? ve.rgb.hsv(e)[2] : t;
  if (a = Math.round(a / 50), a === 0)
    return 30;
  let s = 30 + (Math.round(i / 255) << 2 | Math.round(r / 255) << 1 | Math.round(n / 255));
  return a === 2 && (s += 60), s;
};
ve.hsv.ansi16 = function(e) {
  return ve.rgb.ansi16(ve.hsv.rgb(e), e[2]);
};
ve.rgb.ansi256 = function(e) {
  const t = e[0], n = e[1], r = e[2];
  return t >> 4 === n >> 4 && n >> 4 === r >> 4 ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(r / 255 * 5);
};
ve.ansi16.rgb = function(e) {
  e = e[0];
  let t = e % 10;
  if (t === 0 || t === 7)
    return e > 50 && (t += 3.5), t = t / 10.5 * 255, [t, t, t];
  const n = (Math.trunc(e > 50) + 1) * 0.5, r = (t & 1) * n * 255, i = (t >> 1 & 1) * n * 255, a = (t >> 2 & 1) * n * 255;
  return [r, i, a];
};
ve.ansi256.rgb = function(e) {
  if (e = e[0], e >= 232) {
    const a = (e - 232) * 10 + 8;
    return [a, a, a];
  }
  e -= 16;
  let t;
  const n = Math.floor(e / 36) / 5 * 255, r = Math.floor((t = e % 36) / 6) / 5 * 255, i = t % 6 / 5 * 255;
  return [n, r, i];
};
ve.rgb.hex = function(e) {
  const n = (((Math.round(e[0]) & 255) << 16) + ((Math.round(e[1]) & 255) << 8) + (Math.round(e[2]) & 255)).toString(16).toUpperCase();
  return "000000".slice(n.length) + n;
};
ve.hex.rgb = function(e) {
  const t = e.toString(16).match(/[a-f\d]{6}|[a-f\d]{3}/i);
  if (!t)
    return [0, 0, 0];
  let n = t[0];
  t[0].length === 3 && (n = [...n].map((u) => u + u).join(""));
  const r = Number.parseInt(n, 16), i = r >> 16 & 255, a = r >> 8 & 255, s = r & 255;
  return [i, a, s];
};
ve.rgb.hcg = function(e) {
  const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, i = Math.max(Math.max(t, n), r), a = Math.min(Math.min(t, n), r), s = i - a;
  let u;
  const f = s < 1 ? a / (1 - s) : 0;
  return s <= 0 ? u = 0 : i === t ? u = (n - r) / s % 6 : i === n ? u = 2 + (r - t) / s : u = 4 + (t - n) / s, u /= 6, u %= 1, [u * 360, s * 100, f * 100];
};
ve.hsl.hcg = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = n < 0.5 ? 2 * t * n : 2 * t * (1 - n);
  let i = 0;
  return r < 1 && (i = (n - 0.5 * r) / (1 - r)), [e[0], r * 100, i * 100];
};
ve.hsv.hcg = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = t * n;
  let i = 0;
  return r < 1 && (i = (n - r) / (1 - r)), [e[0], r * 100, i * 100];
};
ve.hcg.rgb = function(e) {
  const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
  if (n === 0)
    return [r * 255, r * 255, r * 255];
  const i = [0, 0, 0], a = t % 1 * 6, s = a % 1, u = 1 - s;
  let f = 0;
  switch (Math.floor(a)) {
    case 0: {
      i[0] = 1, i[1] = s, i[2] = 0;
      break;
    }
    case 1: {
      i[0] = u, i[1] = 1, i[2] = 0;
      break;
    }
    case 2: {
      i[0] = 0, i[1] = 1, i[2] = s;
      break;
    }
    case 3: {
      i[0] = 0, i[1] = u, i[2] = 1;
      break;
    }
    case 4: {
      i[0] = s, i[1] = 0, i[2] = 1;
      break;
    }
    default:
      i[0] = 1, i[1] = 0, i[2] = u;
  }
  return f = (1 - n) * r, [
    (n * i[0] + f) * 255,
    (n * i[1] + f) * 255,
    (n * i[2] + f) * 255
  ];
};
ve.hcg.hsv = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = t + n * (1 - t);
  let i = 0;
  return r > 0 && (i = t / r), [e[0], i * 100, r * 100];
};
ve.hcg.hsl = function(e) {
  const t = e[1] / 100, r = e[2] / 100 * (1 - t) + 0.5 * t;
  let i = 0;
  return r > 0 && r < 0.5 ? i = t / (2 * r) : r >= 0.5 && r < 1 && (i = t / (2 * (1 - r))), [e[0], i * 100, r * 100];
};
ve.hcg.hwb = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = t + n * (1 - t);
  return [e[0], (r - t) * 100, (1 - r) * 100];
};
ve.hwb.hcg = function(e) {
  const t = e[1] / 100, r = 1 - e[2] / 100, i = r - t;
  let a = 0;
  return i < 1 && (a = (r - i) / (1 - i)), [e[0], i * 100, a * 100];
};
ve.apple.rgb = function(e) {
  return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255];
};
ve.rgb.apple = function(e) {
  return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535];
};
ve.gray.rgb = function(e) {
  return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255];
};
ve.gray.hsl = function(e) {
  return [0, 0, e[0]];
};
ve.gray.hsv = ve.gray.hsl;
ve.gray.hwb = function(e) {
  return [0, 100, e[0]];
};
ve.gray.cmyk = function(e) {
  return [0, 0, 0, e[0]];
};
ve.gray.lab = function(e) {
  return [e[0], 0, 0];
};
ve.gray.hex = function(e) {
  const t = Math.round(e[0] / 100 * 255) & 255, r = ((t << 16) + (t << 8) + t).toString(16).toUpperCase();
  return "000000".slice(r.length) + r;
};
ve.rgb.gray = function(e) {
  return [(e[0] + e[1] + e[2]) / 3 / 255 * 100];
};
function doe() {
  const e = {}, t = Object.keys(ve);
  for (let { length: n } = t, r = 0; r < n; r++)
    e[t[r]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  return e;
}
function hoe(e) {
  const t = doe(), n = [e];
  for (t[e].distance = 0; n.length > 0; ) {
    const r = n.pop(), i = Object.keys(ve[r]);
    for (let { length: a } = i, s = 0; s < a; s++) {
      const u = i[s], f = t[u];
      f.distance === -1 && (f.distance = t[r].distance + 1, f.parent = r, n.unshift(u));
    }
  }
  return t;
}
function poe(e, t) {
  return function(n) {
    return t(e(n));
  };
}
function moe(e, t) {
  const n = [t[e].parent, e];
  let r = ve[t[e].parent][e], i = t[e].parent;
  for (; t[i].parent; )
    n.unshift(t[i].parent), r = poe(ve[t[i].parent][i], r), i = t[i].parent;
  return r.conversion = n, r;
}
function goe(e) {
  const t = hoe(e), n = {}, r = Object.keys(t);
  for (let { length: i } = r, a = 0; a < i; a++) {
    const s = r[a];
    t[s].parent !== null && (n[s] = moe(s, t));
  }
  return n;
}
const va = {}, yoe = Object.keys(ve);
function voe(e) {
  const t = function(...n) {
    const r = n[0];
    return r == null ? r : (r.length > 1 && (n = r), e(n));
  };
  return "conversion" in e && (t.conversion = e.conversion), t;
}
function boe(e) {
  const t = function(...n) {
    const r = n[0];
    if (r == null)
      return r;
    r.length > 1 && (n = r);
    const i = e(n);
    if (typeof i == "object")
      for (let { length: a } = i, s = 0; s < a; s++)
        i[s] = Math.round(i[s]);
    return i;
  };
  return "conversion" in e && (t.conversion = e.conversion), t;
}
for (const e of yoe) {
  va[e] = {}, Object.defineProperty(va[e], "channels", { value: ve[e].channels }), Object.defineProperty(va[e], "labels", { value: ve[e].labels });
  const t = goe(e), n = Object.keys(t);
  for (const r of n) {
    const i = t[r];
    va[e][r] = boe(i), va[e][r].raw = voe(i);
  }
}
const xoe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: va
}, Symbol.toStringTag, { value: "Module" })), fn = (e, t) => {
  const n = Array.isArray(t) ? t : [t];
  if (n[0] === void 0 || n[0] === null)
    return fn("rgb", [0, 0, 0]);
  const r = va[e];
  if (!r)
    throw new Error(
      `Unsupported color type: ${e} allowed are ${Object.keys(xoe).join(
        ", "
      )}`
    );
  r[e] = () => n;
  const i = (s) => {
    const u = s(...n);
    return Array.isArray(u) ? u[0] != null : u;
  };
  if (!i(r.rgb) || !i(r.hsl))
    return fn("rgb", [0, 0, 0]);
  const a = {};
  return Object.keys(r).forEach((s) => {
    const u = r[s];
    typeof u == "function" && (a[s] = () => s === e ? n : u(...n));
  }), a;
}, woe = ({
  onChange: e,
  colorconverter: t,
  allow_null: n = !1
}) => {
  if (t === null && !n)
    throw new Error("Color converter is null");
  const [r, i] = C.useState(t), [a, s] = C.useState([0, 0, 0]), [u, f] = C.useState([0, 0, 0]), [d, h] = C.useState([0, 0, 0]), [p, g] = C.useState("000");
  C.useEffect(() => {
    if (!r) {
      if (!n) throw new Error("Color converter is null");
      f([0, 0, 0]), s([0, 0, 0]), h([0, 0, 0]), g("");
      return;
    }
    s(r.hsl()), f(r.rgb()), h(r.hsv()), g(r.hex());
  }, [r]);
  const y = {
    backgroundColor: `hsl(${a[0]}, ${a[1]}%, ${a[2]}%)`,
    padding: "10px",
    margin: "10px 0"
  };
  return /* @__PURE__ */ _.jsxs("div", { style: { backgroundColor: "white" }, children: [
    /* @__PURE__ */ _.jsx("div", { style: y, children: "Color Preview" }),
    /* @__PURE__ */ _.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ _.jsx("div", { className: "colorspace_title", children: "RGB" }),
      /* @__PURE__ */ _.jsx("div", {}),
      /* @__PURE__ */ _.jsx("label", { children: "Red" }),
      /* @__PURE__ */ _.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "255",
          value: u[0],
          onChange: (b) => {
            const x = [parseInt(b.target.value), u[1], u[2]], E = fn("rgb", x);
            i(E), e(E);
          },
          style: { background: "linear-gradient(to right, #000, #f00)" }
        }
      ),
      /* @__PURE__ */ _.jsx("label", { children: "Green" }),
      /* @__PURE__ */ _.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "255",
          value: u[1],
          onChange: (b) => {
            const x = [u[0], parseInt(b.target.value), u[2]], E = fn("rgb", x);
            i(E), e(E);
          },
          style: { background: "linear-gradient(to right, #000, #0f0)" }
        }
      ),
      /* @__PURE__ */ _.jsx("label", { children: "Blue" }),
      /* @__PURE__ */ _.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "255",
          value: u[2],
          onChange: (b) => {
            const x = [u[0], u[1], parseInt(b.target.value)], E = fn("rgb", x);
            i(E), e(E);
          },
          style: { background: "linear-gradient(to right, #000, #00f)" }
        }
      )
    ] }),
    /* @__PURE__ */ _.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ _.jsx("div", { className: "colorspace_title", children: "HSL" }),
      /* @__PURE__ */ _.jsx("div", {}),
      /* @__PURE__ */ _.jsx("label", { children: "Hue" }),
      /* @__PURE__ */ _.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "360",
          value: a[0],
          onChange: (b) => {
            const x = [parseInt(b.target.value), a[1], a[2]], E = fn("hsl", x);
            i(E), e(E);
          },
          style: {
            background: "linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)"
          }
        }
      ),
      /* @__PURE__ */ _.jsx("label", { children: "Saturation" }),
      /* @__PURE__ */ _.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: a[1],
          onChange: (b) => {
            const x = [a[0], parseInt(b.target.value), a[2]], E = fn("hsl", x);
            i(E), e(E);
          },
          style: {
            background: `linear-gradient(to right, #fff, hsl(${a[0]}, 100%, 50%))`
          }
        }
      ),
      /* @__PURE__ */ _.jsx("label", { children: "Lightness" }),
      /* @__PURE__ */ _.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: a[2],
          onChange: (b) => {
            const x = [a[0], a[1], parseInt(b.target.value)], E = fn("hsl", x);
            i(E), e(E);
          },
          style: {
            background: `linear-gradient(to right, #000, hsl(${a[0]}, 100%, 50%), #fff)`
          }
        }
      )
    ] }),
    /* @__PURE__ */ _.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ _.jsx("div", { className: "colorspace_title", children: "HSV" }),
      /* @__PURE__ */ _.jsx("div", {}),
      /* @__PURE__ */ _.jsx("label", { children: "Hue" }),
      /* @__PURE__ */ _.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "360",
          value: d[0],
          onChange: (b) => {
            const x = [parseInt(b.target.value), d[1], d[2]], E = fn("hsv", x);
            i(E), e(E);
          },
          style: {
            background: "linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)"
          }
        }
      ),
      /* @__PURE__ */ _.jsx("label", { children: "Saturation" }),
      /* @__PURE__ */ _.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: d[1],
          onChange: (b) => {
            const x = [d[0], parseInt(b.target.value), d[2]], E = fn("hsv", x);
            i(E), e(E);
          },
          style: {
            background: `linear-gradient(to right, #fff, hsl(${a[0]}, 100%, 50%))`
          }
        }
      ),
      /* @__PURE__ */ _.jsx("label", { children: "Value" }),
      /* @__PURE__ */ _.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: d[2],
          onChange: (b) => {
            const x = [d[0], d[1], parseInt(b.target.value)], E = fn("hsv", x);
            i(E), e(E);
          },
          style: {
            background: `linear-gradient(to right, #000, hsl(${a[0]}, 100%, 50%))`
          }
        }
      )
    ] }),
    /* @__PURE__ */ _.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ _.jsx("div", { className: "colorspace_title", children: "HEX" }),
      /* @__PURE__ */ _.jsx("div", {}),
      /* @__PURE__ */ _.jsx(
        "input",
        {
          type: "text",
          value: p,
          onChange: (b) => {
            const x = b.target.value === "" ? null : fn("hex", [b.target.value]);
            i(x), e(x);
          }
        }
      )
    ] })
  ] });
}, Soe = ({
  inicolordata: e,
  inicolorspace: t,
  allow_null: n = !1,
  delay: r = 1e3,
  onChange: i
}) => {
  const a = e !== void 0 ? e : [0, 0, 0], s = e === void 0 ? "rgb" : t || "hex", u = Array.isArray(a) ? a : [a], f = C.useMemo(() => {
    let E = fn(s, u);
    return E.rgb() === void 0 && (E = fn("rgb", [0, 0, 0])), E;
  }, [s, u]), [d, h] = C.useState(f);
  C.useEffect(() => {
    const E = e !== void 0 ? e : [0, 0, 0], S = e === void 0 ? "rgb" : t || "hex", A = Array.isArray(E) ? E : [E];
    let k = fn(S, A);
    k.rgb() === void 0 && (k = fn("rgb", [0, 0, 0])), h(k);
  }, [JSON.stringify(e), t]);
  const p = C.useContext(Xe), g = p.local_state(() => p.reactflowRef), y = C.useRef(null), b = C.useCallback(
    (E) => {
      if (E === null && !n)
        throw new Error("Color is null");
      E !== null && h(E), y.current && clearTimeout(y.current), i && (y.current = setTimeout(() => {
        i(E), y.current = null;
      }, r));
    },
    [n, i, r]
  );
  C.useEffect(() => () => {
    y.current && clearTimeout(y.current);
  }, []);
  const x = C.useMemo(
    () => ({
      background: "#" + d.hex(),
      borderRadius: "0.3rem",
      width: "2rem",
      height: "1rem"
    }),
    [d]
  );
  return /* @__PURE__ */ _.jsxs(L3, { children: [
    /* @__PURE__ */ _.jsx(F3, { asChild: !0, children: /* @__PURE__ */ _.jsx("button", { style: x }) }),
    /* @__PURE__ */ _.jsx(B3, { container: g, children: /* @__PURE__ */ _.jsx($3, { side: "left", className: "iotooltipcontent", children: /* @__PURE__ */ _.jsx(
      woe,
      {
        onChange: b,
        colorconverter: d,
        allow_null: n
      }
    ) }) })
  ] });
};
function La(e) {
  "@babel/helpers - typeof";
  return La = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, La(e);
}
function _oe(e, t) {
  if (La(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (La(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function G5(e) {
  var t = _oe(e, "string");
  return La(t) == "symbol" ? t : t + "";
}
function Xu(e, t, n) {
  return (t = G5(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function JA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Re(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? JA(Object(n), !0).forEach(function(r) {
      Xu(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : JA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Eoe(e) {
  if (Array.isArray(e)) return e;
}
function Coe(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r, i, a, s, u = [], f = !0, d = !1;
    try {
      if (a = (n = n.call(e)).next, t === 0) {
        if (Object(n) !== n) return;
        f = !1;
      } else for (; !(f = (r = a.call(n)).done) && (u.push(r.value), u.length !== t); f = !0) ;
    } catch (h) {
      d = !0, i = h;
    } finally {
      try {
        if (!f && n.return != null && (s = n.return(), Object(s) !== s)) return;
      } finally {
        if (d) throw i;
      }
    }
    return u;
  }
}
function ob(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function X5(e, t) {
  if (e) {
    if (typeof e == "string") return ob(e, t);
    var n = {}.toString.call(e).slice(8, -1);
    return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? ob(e, t) : void 0;
  }
}
function koe() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Bi(e, t) {
  return Eoe(e) || Coe(e, t) || X5(e, t) || koe();
}
function Qi(e, t) {
  if (e == null) return {};
  var n, r, i = Q1(e, t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    for (r = 0; r < a.length; r++) n = a[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (i[n] = e[n]);
  }
  return i;
}
var Aoe = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function Toe(e) {
  var t = e.defaultInputValue, n = t === void 0 ? "" : t, r = e.defaultMenuIsOpen, i = r === void 0 ? !1 : r, a = e.defaultValue, s = a === void 0 ? null : a, u = e.inputValue, f = e.menuIsOpen, d = e.onChange, h = e.onInputChange, p = e.onMenuClose, g = e.onMenuOpen, y = e.value, b = Qi(e, Aoe), x = C.useState(u !== void 0 ? u : n), E = Bi(x, 2), S = E[0], A = E[1], k = C.useState(f !== void 0 ? f : i), R = Bi(k, 2), N = R[0], D = R[1], P = C.useState(y !== void 0 ? y : s), F = Bi(P, 2), V = F[0], T = F[1], $ = C.useCallback(function(q, Y) {
    typeof d == "function" && d(q, Y), T(q);
  }, [d]), H = C.useCallback(function(q, Y) {
    var O;
    typeof h == "function" && (O = h(q, Y)), A(O !== void 0 ? O : q);
  }, [h]), G = C.useCallback(function() {
    typeof g == "function" && g(), D(!0);
  }, [g]), j = C.useCallback(function() {
    typeof p == "function" && p(), D(!1);
  }, [p]), U = u !== void 0 ? u : S, z = f !== void 0 ? f : N, B = y !== void 0 ? y : V;
  return Re(Re({}, b), {}, {
    inputValue: U,
    menuIsOpen: z,
    onChange: $,
    onInputChange: H,
    onMenuClose: j,
    onMenuOpen: G,
    value: B
  });
}
function Roe(e, t) {
  if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
}
function eT(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, G5(r.key), r);
  }
}
function Ooe(e, t, n) {
  return t && eT(e.prototype, t), n && eT(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function Noe(e, t) {
  if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && Xh(e, t);
}
function Kh(e) {
  return Kh = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Kh(e);
}
function W5() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (W5 = function() {
    return !!e;
  })();
}
function Moe(e, t) {
  if (t && (La(t) == "object" || typeof t == "function")) return t;
  if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return C5(e);
}
function Doe(e) {
  var t = W5();
  return function() {
    var n, r = Kh(e);
    if (t) {
      var i = Kh(this).constructor;
      n = Reflect.construct(r, arguments, i);
    } else n = r.apply(this, arguments);
    return Moe(this, n);
  };
}
function Poe(e) {
  if (Array.isArray(e)) return ob(e);
}
function zoe(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function joe() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ix(e) {
  return Poe(e) || zoe(e) || X5(e) || joe();
}
function Ioe(e, t) {
  return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {
    raw: {
      value: Object.freeze(t)
    }
  }));
}
var ab = C.useLayoutEffect, Loe = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"], Zh = function() {
};
function Foe(e, t) {
  return t ? t[0] === "-" ? e + t : e + "__" + t : e;
}
function Boe(e, t) {
  for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), i = 2; i < n; i++)
    r[i - 2] = arguments[i];
  var a = [].concat(r);
  if (t && e)
    for (var s in t)
      t.hasOwnProperty(s) && t[s] && a.push("".concat(Foe(e, s)));
  return a.filter(function(u) {
    return u;
  }).map(function(u) {
    return String(u).trim();
  }).join(" ");
}
var tT = function(t) {
  return Woe(t) ? t.filter(Boolean) : La(t) === "object" && t !== null ? [t] : [];
}, K5 = function(t) {
  t.className, t.clearValue, t.cx, t.getStyles, t.getClassNames, t.getValue, t.hasValue, t.isMulti, t.isRtl, t.options, t.selectOption, t.selectProps, t.setValue, t.theme;
  var n = Qi(t, Loe);
  return Re({}, n);
}, Nt = function(t, n, r) {
  var i = t.cx, a = t.getStyles, s = t.getClassNames, u = t.className;
  return {
    css: a(n, t),
    className: i(r ?? {}, s(n, t), u)
  };
};
function lm(e) {
  return [document.documentElement, document.body, window].indexOf(e) > -1;
}
function $oe(e) {
  return lm(e) ? window.innerHeight : e.clientHeight;
}
function Z5(e) {
  return lm(e) ? window.pageYOffset : e.scrollTop;
}
function Qh(e, t) {
  if (lm(e)) {
    window.scrollTo(0, t);
    return;
  }
  e.scrollTop = t;
}
function Hoe(e) {
  var t = getComputedStyle(e), n = t.position === "absolute", r = /(auto|scroll)/;
  if (t.position === "fixed") return document.documentElement;
  for (var i = e; i = i.parentElement; )
    if (t = getComputedStyle(i), !(n && t.position === "static") && r.test(t.overflow + t.overflowY + t.overflowX))
      return i;
  return document.documentElement;
}
function Voe(e, t, n, r) {
  return n * ((e = e / r - 1) * e * e + 1) + t;
}
function Yd(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Zh, i = Z5(e), a = t - i, s = 10, u = 0;
  function f() {
    u += s;
    var d = Voe(u, i, a, n);
    Qh(e, d), u < n ? window.requestAnimationFrame(f) : r(e);
  }
  f();
}
function nT(e, t) {
  var n = e.getBoundingClientRect(), r = t.getBoundingClientRect(), i = t.offsetHeight / 3;
  r.bottom + i > n.bottom ? Qh(e, Math.min(t.offsetTop + t.clientHeight - e.offsetHeight + i, e.scrollHeight)) : r.top - i < n.top && Qh(e, Math.max(t.offsetTop - i, 0));
}
function Uoe(e) {
  var t = e.getBoundingClientRect();
  return {
    bottom: t.bottom,
    height: t.height,
    left: t.left,
    right: t.right,
    top: t.top,
    width: t.width
  };
}
function rT() {
  try {
    return document.createEvent("TouchEvent"), !0;
  } catch {
    return !1;
  }
}
function qoe() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch {
    return !1;
  }
}
var Q5 = !1, Yoe = {
  get passive() {
    return Q5 = !0;
  }
}, Gd = typeof window < "u" ? window : {};
Gd.addEventListener && Gd.removeEventListener && (Gd.addEventListener("p", Zh, Yoe), Gd.removeEventListener("p", Zh, !1));
var Goe = Q5;
function Xoe(e) {
  return e != null;
}
function Woe(e) {
  return Array.isArray(e);
}
function Xd(e, t, n) {
  return e ? t : n;
}
var Koe = function(t) {
  for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)
    r[i - 1] = arguments[i];
  var a = Object.entries(t).filter(function(s) {
    var u = Bi(s, 1), f = u[0];
    return !r.includes(f);
  });
  return a.reduce(function(s, u) {
    var f = Bi(u, 2), d = f[0], h = f[1];
    return s[d] = h, s;
  }, {});
}, Zoe = ["children", "innerProps"], Qoe = ["children", "innerProps"];
function Joe(e) {
  var t = e.maxHeight, n = e.menuEl, r = e.minHeight, i = e.placement, a = e.shouldScroll, s = e.isFixedPosition, u = e.controlHeight, f = Hoe(n), d = {
    placement: "bottom",
    maxHeight: t
  };
  if (!n || !n.offsetParent) return d;
  var h = f.getBoundingClientRect(), p = h.height, g = n.getBoundingClientRect(), y = g.bottom, b = g.height, x = g.top, E = n.offsetParent.getBoundingClientRect(), S = E.top, A = s ? window.innerHeight : $oe(f), k = Z5(f), R = parseInt(getComputedStyle(n).marginBottom, 10), N = parseInt(getComputedStyle(n).marginTop, 10), D = S - N, P = A - x, F = D + k, V = p - k - x, T = y - A + k + R, $ = k + x - N, H = 160;
  switch (i) {
    case "auto":
    case "bottom":
      if (P >= b)
        return {
          placement: "bottom",
          maxHeight: t
        };
      if (V >= b && !s)
        return a && Yd(f, T, H), {
          placement: "bottom",
          maxHeight: t
        };
      if (!s && V >= r || s && P >= r) {
        a && Yd(f, T, H);
        var G = s ? P - R : V - R;
        return {
          placement: "bottom",
          maxHeight: G
        };
      }
      if (i === "auto" || s) {
        var j = t, U = s ? D : F;
        return U >= r && (j = Math.min(U - R - u, t)), {
          placement: "top",
          maxHeight: j
        };
      }
      if (i === "bottom")
        return a && Qh(f, T), {
          placement: "bottom",
          maxHeight: t
        };
      break;
    case "top":
      if (D >= b)
        return {
          placement: "top",
          maxHeight: t
        };
      if (F >= b && !s)
        return a && Yd(f, $, H), {
          placement: "top",
          maxHeight: t
        };
      if (!s && F >= r || s && D >= r) {
        var z = t;
        return (!s && F >= r || s && D >= r) && (z = s ? D - N : F - N), a && Yd(f, $, H), {
          placement: "top",
          maxHeight: z
        };
      }
      return {
        placement: "bottom",
        maxHeight: t
      };
    default:
      throw new Error('Invalid placement provided "'.concat(i, '".'));
  }
  return d;
}
function eae(e) {
  var t = {
    bottom: "top",
    top: "bottom"
  };
  return e ? t[e] : "bottom";
}
var J5 = function(t) {
  return t === "auto" ? "bottom" : t;
}, tae = function(t, n) {
  var r, i = t.placement, a = t.theme, s = a.borderRadius, u = a.spacing, f = a.colors;
  return Re((r = {
    label: "menu"
  }, Xu(r, eae(i), "100%"), Xu(r, "position", "absolute"), Xu(r, "width", "100%"), Xu(r, "zIndex", 1), r), n ? {} : {
    backgroundColor: f.neutral0,
    borderRadius: s,
    boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
    marginBottom: u.menuGutter,
    marginTop: u.menuGutter
  });
}, e4 = /* @__PURE__ */ C.createContext(null), nae = function(t) {
  var n = t.children, r = t.minMenuHeight, i = t.maxMenuHeight, a = t.menuPlacement, s = t.menuPosition, u = t.menuShouldScrollIntoView, f = t.theme, d = C.useContext(e4) || {}, h = d.setPortalPlacement, p = C.useRef(null), g = C.useState(i), y = Bi(g, 2), b = y[0], x = y[1], E = C.useState(null), S = Bi(E, 2), A = S[0], k = S[1], R = f.spacing.controlHeight;
  return ab(function() {
    var N = p.current;
    if (N) {
      var D = s === "fixed", P = u && !D, F = Joe({
        maxHeight: i,
        menuEl: N,
        minHeight: r,
        placement: a,
        shouldScroll: P,
        isFixedPosition: D,
        controlHeight: R
      });
      x(F.maxHeight), k(F.placement), h?.(F.placement);
    }
  }, [i, a, s, u, r, h, R]), n({
    ref: p,
    placerProps: Re(Re({}, t), {}, {
      placement: A || J5(a),
      maxHeight: b
    })
  });
}, rae = function(t) {
  var n = t.children, r = t.innerRef, i = t.innerProps;
  return Ee("div", ke({}, Nt(t, "menu", {
    menu: !0
  }), {
    ref: r
  }, i), n);
}, iae = rae, oae = function(t, n) {
  var r = t.maxHeight, i = t.theme.spacing.baseUnit;
  return Re({
    maxHeight: r,
    overflowY: "auto",
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }, n ? {} : {
    paddingBottom: i,
    paddingTop: i
  });
}, aae = function(t) {
  var n = t.children, r = t.innerProps, i = t.innerRef, a = t.isMulti;
  return Ee("div", ke({}, Nt(t, "menuList", {
    "menu-list": !0,
    "menu-list--is-multi": a
  }), {
    ref: i
  }, r), n);
}, t4 = function(t, n) {
  var r = t.theme, i = r.spacing.baseUnit, a = r.colors;
  return Re({
    textAlign: "center"
  }, n ? {} : {
    color: a.neutral40,
    padding: "".concat(i * 2, "px ").concat(i * 3, "px")
  });
}, sae = t4, lae = t4, uae = function(t) {
  var n = t.children, r = n === void 0 ? "No options" : n, i = t.innerProps, a = Qi(t, Zoe);
  return Ee("div", ke({}, Nt(Re(Re({}, a), {}, {
    children: r,
    innerProps: i
  }), "noOptionsMessage", {
    "menu-notice": !0,
    "menu-notice--no-options": !0
  }), i), r);
}, cae = function(t) {
  var n = t.children, r = n === void 0 ? "Loading..." : n, i = t.innerProps, a = Qi(t, Qoe);
  return Ee("div", ke({}, Nt(Re(Re({}, a), {}, {
    children: r,
    innerProps: i
  }), "loadingMessage", {
    "menu-notice": !0,
    "menu-notice--loading": !0
  }), i), r);
}, fae = function(t) {
  var n = t.rect, r = t.offset, i = t.position;
  return {
    left: n.left,
    position: i,
    top: r,
    width: n.width,
    zIndex: 1
  };
}, dae = function(t) {
  var n = t.appendTo, r = t.children, i = t.controlElement, a = t.innerProps, s = t.menuPlacement, u = t.menuPosition, f = C.useRef(null), d = C.useRef(null), h = C.useState(J5(s)), p = Bi(h, 2), g = p[0], y = p[1], b = C.useMemo(function() {
    return {
      setPortalPlacement: y
    };
  }, []), x = C.useState(null), E = Bi(x, 2), S = E[0], A = E[1], k = C.useCallback(function() {
    if (i) {
      var P = Uoe(i), F = u === "fixed" ? 0 : window.pageYOffset, V = P[g] + F;
      (V !== S?.offset || P.left !== S?.rect.left || P.width !== S?.rect.width) && A({
        offset: V,
        rect: P
      });
    }
  }, [i, u, g, S?.offset, S?.rect.left, S?.rect.width]);
  ab(function() {
    k();
  }, [k]);
  var R = C.useCallback(function() {
    typeof d.current == "function" && (d.current(), d.current = null), i && f.current && (d.current = f2(i, f.current, k, {
      elementResize: "ResizeObserver" in window
    }));
  }, [i, k]);
  ab(function() {
    R();
  }, [R]);
  var N = C.useCallback(function(P) {
    f.current = P, R();
  }, [R]);
  if (!n && u !== "fixed" || !S) return null;
  var D = Ee("div", ke({
    ref: N
  }, Nt(Re(Re({}, t), {}, {
    offset: S.offset,
    position: u,
    rect: S.rect
  }), "menuPortal", {
    "menu-portal": !0
  }), a), r);
  return Ee(e4.Provider, {
    value: b
  }, n ? /* @__PURE__ */ Pc.createPortal(D, n) : D);
}, hae = function(t) {
  var n = t.isDisabled, r = t.isRtl;
  return {
    label: "container",
    direction: r ? "rtl" : void 0,
    pointerEvents: n ? "none" : void 0,
    // cancel mouse events when disabled
    position: "relative"
  };
}, pae = function(t) {
  var n = t.children, r = t.innerProps, i = t.isDisabled, a = t.isRtl;
  return Ee("div", ke({}, Nt(t, "container", {
    "--is-disabled": i,
    "--is-rtl": a
  }), r), n);
}, mae = function(t, n) {
  var r = t.theme.spacing, i = t.isMulti, a = t.hasValue, s = t.selectProps.controlShouldRenderValue;
  return Re({
    alignItems: "center",
    display: i && a && s ? "flex" : "grid",
    flex: 1,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, n ? {} : {
    padding: "".concat(r.baseUnit / 2, "px ").concat(r.baseUnit * 2, "px")
  });
}, gae = function(t) {
  var n = t.children, r = t.innerProps, i = t.isMulti, a = t.hasValue;
  return Ee("div", ke({}, Nt(t, "valueContainer", {
    "value-container": !0,
    "value-container--is-multi": i,
    "value-container--has-value": a
  }), r), n);
}, yae = function() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
}, vae = function(t) {
  var n = t.children, r = t.innerProps;
  return Ee("div", ke({}, Nt(t, "indicatorsContainer", {
    indicators: !0
  }), r), n);
}, iT, bae = ["size"], xae = ["innerProps", "isRtl", "size"], wae = {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
}, n4 = function(t) {
  var n = t.size, r = Qi(t, bae);
  return Ee("svg", ke({
    height: n,
    width: n,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: wae
  }, r));
}, ox = function(t) {
  return Ee(n4, ke({
    size: 20
  }, t), Ee("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
}, r4 = function(t) {
  return Ee(n4, ke({
    size: 20
  }, t), Ee("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
}, i4 = function(t, n) {
  var r = t.isFocused, i = t.theme, a = i.spacing.baseUnit, s = i.colors;
  return Re({
    label: "indicatorContainer",
    display: "flex",
    transition: "color 150ms"
  }, n ? {} : {
    color: r ? s.neutral60 : s.neutral20,
    padding: a * 2,
    ":hover": {
      color: r ? s.neutral80 : s.neutral40
    }
  });
}, Sae = i4, _ae = function(t) {
  var n = t.children, r = t.innerProps;
  return Ee("div", ke({}, Nt(t, "dropdownIndicator", {
    indicator: !0,
    "dropdown-indicator": !0
  }), r), n || Ee(r4, null));
}, Eae = i4, Cae = function(t) {
  var n = t.children, r = t.innerProps;
  return Ee("div", ke({}, Nt(t, "clearIndicator", {
    indicator: !0,
    "clear-indicator": !0
  }), r), n || Ee(ox, null));
}, kae = function(t, n) {
  var r = t.isDisabled, i = t.theme, a = i.spacing.baseUnit, s = i.colors;
  return Re({
    label: "indicatorSeparator",
    alignSelf: "stretch",
    width: 1
  }, n ? {} : {
    backgroundColor: r ? s.neutral10 : s.neutral20,
    marginBottom: a * 2,
    marginTop: a * 2
  });
}, Aae = function(t) {
  var n = t.innerProps;
  return Ee("span", ke({}, n, Nt(t, "indicatorSeparator", {
    "indicator-separator": !0
  })));
}, Tae = tm(iT || (iT = Ioe([`
  0%, 80%, 100% { opacity: 0; }
  40% { opacity: 1; }
`]))), Rae = function(t, n) {
  var r = t.isFocused, i = t.size, a = t.theme, s = a.colors, u = a.spacing.baseUnit;
  return Re({
    label: "loadingIndicator",
    display: "flex",
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: i,
    lineHeight: 1,
    marginRight: i,
    textAlign: "center",
    verticalAlign: "middle"
  }, n ? {} : {
    color: r ? s.neutral60 : s.neutral20,
    padding: u * 2
  });
}, Ny = function(t) {
  var n = t.delay, r = t.offset;
  return Ee("span", {
    css: /* @__PURE__ */ X1({
      animation: "".concat(Tae, " 1s ease-in-out ").concat(n, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: r ? "1em" : void 0,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, "", "")
  });
}, Oae = function(t) {
  var n = t.innerProps, r = t.isRtl, i = t.size, a = i === void 0 ? 4 : i, s = Qi(t, xae);
  return Ee("div", ke({}, Nt(Re(Re({}, s), {}, {
    innerProps: n,
    isRtl: r,
    size: a
  }), "loadingIndicator", {
    indicator: !0,
    "loading-indicator": !0
  }), n), Ee(Ny, {
    delay: 0,
    offset: r
  }), Ee(Ny, {
    delay: 160,
    offset: !0
  }), Ee(Ny, {
    delay: 320,
    offset: !r
  }));
}, Nae = function(t, n) {
  var r = t.isDisabled, i = t.isFocused, a = t.theme, s = a.colors, u = a.borderRadius, f = a.spacing;
  return Re({
    label: "control",
    alignItems: "center",
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: f.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms"
  }, n ? {} : {
    backgroundColor: r ? s.neutral5 : s.neutral0,
    borderColor: r ? s.neutral10 : i ? s.primary : s.neutral20,
    borderRadius: u,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: i ? "0 0 0 1px ".concat(s.primary) : void 0,
    "&:hover": {
      borderColor: i ? s.primary : s.neutral30
    }
  });
}, Mae = function(t) {
  var n = t.children, r = t.isDisabled, i = t.isFocused, a = t.innerRef, s = t.innerProps, u = t.menuIsOpen;
  return Ee("div", ke({
    ref: a
  }, Nt(t, "control", {
    control: !0,
    "control--is-disabled": r,
    "control--is-focused": i,
    "control--menu-is-open": u
  }), s, {
    "aria-disabled": r || void 0
  }), n);
}, Dae = Mae, Pae = ["data"], zae = function(t, n) {
  var r = t.theme.spacing;
  return n ? {} : {
    paddingBottom: r.baseUnit * 2,
    paddingTop: r.baseUnit * 2
  };
}, jae = function(t) {
  var n = t.children, r = t.cx, i = t.getStyles, a = t.getClassNames, s = t.Heading, u = t.headingProps, f = t.innerProps, d = t.label, h = t.theme, p = t.selectProps;
  return Ee("div", ke({}, Nt(t, "group", {
    group: !0
  }), f), Ee(s, ke({}, u, {
    selectProps: p,
    theme: h,
    getStyles: i,
    getClassNames: a,
    cx: r
  }), d), Ee("div", null, n));
}, Iae = function(t, n) {
  var r = t.theme, i = r.colors, a = r.spacing;
  return Re({
    label: "group",
    cursor: "default",
    display: "block"
  }, n ? {} : {
    color: i.neutral40,
    fontSize: "75%",
    fontWeight: 500,
    marginBottom: "0.25em",
    paddingLeft: a.baseUnit * 3,
    paddingRight: a.baseUnit * 3,
    textTransform: "uppercase"
  });
}, Lae = function(t) {
  var n = K5(t);
  n.data;
  var r = Qi(n, Pae);
  return Ee("div", ke({}, Nt(t, "groupHeading", {
    "group-heading": !0
  }), r));
}, Fae = jae, Bae = ["innerRef", "isDisabled", "isHidden", "inputClassName"], $ae = function(t, n) {
  var r = t.isDisabled, i = t.value, a = t.theme, s = a.spacing, u = a.colors;
  return Re(Re({
    visibility: r ? "hidden" : "visible",
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: i ? "translateZ(0)" : ""
  }, Hae), n ? {} : {
    margin: s.baseUnit / 2,
    paddingBottom: s.baseUnit / 2,
    paddingTop: s.baseUnit / 2,
    color: u.neutral80
  });
}, o4 = {
  gridArea: "1 / 2",
  font: "inherit",
  minWidth: "2px",
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
}, Hae = {
  flex: "1 1 auto",
  display: "inline-grid",
  gridArea: "1 / 1 / 2 / 3",
  gridTemplateColumns: "0 min-content",
  "&:after": Re({
    content: 'attr(data-value) " "',
    visibility: "hidden",
    whiteSpace: "pre"
  }, o4)
}, Vae = function(t) {
  return Re({
    label: "input",
    color: "inherit",
    background: 0,
    opacity: t ? 0 : 1,
    width: "100%"
  }, o4);
}, Uae = function(t) {
  var n = t.cx, r = t.value, i = K5(t), a = i.innerRef, s = i.isDisabled, u = i.isHidden, f = i.inputClassName, d = Qi(i, Bae);
  return Ee("div", ke({}, Nt(t, "input", {
    "input-container": !0
  }), {
    "data-value": r || ""
  }), Ee("input", ke({
    className: n({
      input: !0
    }, f),
    ref: a,
    style: Vae(u),
    disabled: s
  }, d)));
}, qae = Uae, Yae = function(t, n) {
  var r = t.theme, i = r.spacing, a = r.borderRadius, s = r.colors;
  return Re({
    label: "multiValue",
    display: "flex",
    minWidth: 0
  }, n ? {} : {
    backgroundColor: s.neutral10,
    borderRadius: a / 2,
    margin: i.baseUnit / 2
  });
}, Gae = function(t, n) {
  var r = t.theme, i = r.borderRadius, a = r.colors, s = t.cropWithEllipsis;
  return Re({
    overflow: "hidden",
    textOverflow: s || s === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, n ? {} : {
    borderRadius: i / 2,
    color: a.neutral80,
    fontSize: "85%",
    padding: 3,
    paddingLeft: 6
  });
}, Xae = function(t, n) {
  var r = t.theme, i = r.spacing, a = r.borderRadius, s = r.colors, u = t.isFocused;
  return Re({
    alignItems: "center",
    display: "flex"
  }, n ? {} : {
    borderRadius: a / 2,
    backgroundColor: u ? s.dangerLight : void 0,
    paddingLeft: i.baseUnit,
    paddingRight: i.baseUnit,
    ":hover": {
      backgroundColor: s.dangerLight,
      color: s.danger
    }
  });
}, a4 = function(t) {
  var n = t.children, r = t.innerProps;
  return Ee("div", r, n);
}, Wae = a4, Kae = a4;
function Zae(e) {
  var t = e.children, n = e.innerProps;
  return Ee("div", ke({
    role: "button"
  }, n), t || Ee(ox, {
    size: 14
  }));
}
var Qae = function(t) {
  var n = t.children, r = t.components, i = t.data, a = t.innerProps, s = t.isDisabled, u = t.removeProps, f = t.selectProps, d = r.Container, h = r.Label, p = r.Remove;
  return Ee(d, {
    data: i,
    innerProps: Re(Re({}, Nt(t, "multiValue", {
      "multi-value": !0,
      "multi-value--is-disabled": s
    })), a),
    selectProps: f
  }, Ee(h, {
    data: i,
    innerProps: Re({}, Nt(t, "multiValueLabel", {
      "multi-value__label": !0
    })),
    selectProps: f
  }, n), Ee(p, {
    data: i,
    innerProps: Re(Re({}, Nt(t, "multiValueRemove", {
      "multi-value__remove": !0
    })), {}, {
      "aria-label": "Remove ".concat(n || "option")
    }, u),
    selectProps: f
  }));
}, Jae = Qae, ese = function(t, n) {
  var r = t.isDisabled, i = t.isFocused, a = t.isSelected, s = t.theme, u = s.spacing, f = s.colors;
  return Re({
    label: "option",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
  }, n ? {} : {
    backgroundColor: a ? f.primary : i ? f.primary25 : "transparent",
    color: r ? f.neutral20 : a ? f.neutral0 : "inherit",
    padding: "".concat(u.baseUnit * 2, "px ").concat(u.baseUnit * 3, "px"),
    // provide some affordance on touch devices
    ":active": {
      backgroundColor: r ? void 0 : a ? f.primary : f.primary50
    }
  });
}, tse = function(t) {
  var n = t.children, r = t.isDisabled, i = t.isFocused, a = t.isSelected, s = t.innerRef, u = t.innerProps;
  return Ee("div", ke({}, Nt(t, "option", {
    option: !0,
    "option--is-disabled": r,
    "option--is-focused": i,
    "option--is-selected": a
  }), {
    ref: s,
    "aria-disabled": r
  }, u), n);
}, nse = tse, rse = function(t, n) {
  var r = t.theme, i = r.spacing, a = r.colors;
  return Re({
    label: "placeholder",
    gridArea: "1 / 1 / 2 / 3"
  }, n ? {} : {
    color: a.neutral50,
    marginLeft: i.baseUnit / 2,
    marginRight: i.baseUnit / 2
  });
}, ise = function(t) {
  var n = t.children, r = t.innerProps;
  return Ee("div", ke({}, Nt(t, "placeholder", {
    placeholder: !0
  }), r), n);
}, ose = ise, ase = function(t, n) {
  var r = t.isDisabled, i = t.theme, a = i.spacing, s = i.colors;
  return Re({
    label: "singleValue",
    gridArea: "1 / 1 / 2 / 3",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, n ? {} : {
    color: r ? s.neutral40 : s.neutral80,
    marginLeft: a.baseUnit / 2,
    marginRight: a.baseUnit / 2
  });
}, sse = function(t) {
  var n = t.children, r = t.isDisabled, i = t.innerProps;
  return Ee("div", ke({}, Nt(t, "singleValue", {
    "single-value": !0,
    "single-value--is-disabled": r
  }), i), n);
}, lse = sse, use = {
  ClearIndicator: Cae,
  Control: Dae,
  DropdownIndicator: _ae,
  DownChevron: r4,
  CrossIcon: ox,
  Group: Fae,
  GroupHeading: Lae,
  IndicatorsContainer: vae,
  IndicatorSeparator: Aae,
  Input: qae,
  LoadingIndicator: Oae,
  Menu: iae,
  MenuList: aae,
  MenuPortal: dae,
  LoadingMessage: cae,
  NoOptionsMessage: uae,
  MultiValue: Jae,
  MultiValueContainer: Wae,
  MultiValueLabel: Kae,
  MultiValueRemove: Zae,
  Option: nse,
  Placeholder: ose,
  SelectContainer: pae,
  SingleValue: lse,
  ValueContainer: gae
}, cse = function(t) {
  return Re(Re({}, use), t.components);
}, oT = Number.isNaN || function(t) {
  return typeof t == "number" && t !== t;
};
function fse(e, t) {
  return !!(e === t || oT(e) && oT(t));
}
function dse(e, t) {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++)
    if (!fse(e[n], t[n]))
      return !1;
  return !0;
}
function hse(e, t) {
  t === void 0 && (t = dse);
  var n = null;
  function r() {
    for (var i = [], a = 0; a < arguments.length; a++)
      i[a] = arguments[a];
    if (n && n.lastThis === this && t(i, n.lastArgs))
      return n.lastResult;
    var s = e.apply(this, i);
    return n = {
      lastResult: s,
      lastArgs: i,
      lastThis: this
    }, s;
  }
  return r.clear = function() {
    n = null;
  }, r;
}
var pse = {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
}, mse = function(t) {
  return Ee("span", ke({
    css: pse
  }, t));
}, aT = mse, gse = {
  guidance: function(t) {
    var n = t.isSearchable, r = t.isMulti, i = t.tabSelectsValue, a = t.context, s = t.isInitialFocus;
    switch (a) {
      case "menu":
        return "Use Up and Down to choose options, press Enter to select the currently focused option, press Escape to exit the menu".concat(i ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return s ? "".concat(t["aria-label"] || "Select", " is focused ").concat(n ? ",type to refine list" : "", ", press Down to open the menu, ").concat(r ? " press left to focus selected values" : "") : "";
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  },
  onChange: function(t) {
    var n = t.action, r = t.label, i = r === void 0 ? "" : r, a = t.labels, s = t.isDisabled;
    switch (n) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(i, ", deselected.");
      case "clear":
        return "All selected options have been cleared.";
      case "initial-input-focus":
        return "option".concat(a.length > 1 ? "s" : "", " ").concat(a.join(","), ", selected.");
      case "select-option":
        return s ? "option ".concat(i, " is disabled. Select another option.") : "option ".concat(i, ", selected.");
      default:
        return "";
    }
  },
  onFocus: function(t) {
    var n = t.context, r = t.focused, i = t.options, a = t.label, s = a === void 0 ? "" : a, u = t.selectValue, f = t.isDisabled, d = t.isSelected, h = t.isAppleDevice, p = function(x, E) {
      return x && x.length ? "".concat(x.indexOf(E) + 1, " of ").concat(x.length) : "";
    };
    if (n === "value" && u)
      return "value ".concat(s, " focused, ").concat(p(u, r), ".");
    if (n === "menu" && h) {
      var g = f ? " disabled" : "", y = "".concat(d ? " selected" : "").concat(g);
      return "".concat(s).concat(y, ", ").concat(p(i, r), ".");
    }
    return "";
  },
  onFilter: function(t) {
    var n = t.inputValue, r = t.resultsMessage;
    return "".concat(r).concat(n ? " for search term " + n : "", ".");
  }
}, yse = function(t) {
  var n = t.ariaSelection, r = t.focusedOption, i = t.focusedValue, a = t.focusableOptions, s = t.isFocused, u = t.selectValue, f = t.selectProps, d = t.id, h = t.isAppleDevice, p = f.ariaLiveMessages, g = f.getOptionLabel, y = f.inputValue, b = f.isMulti, x = f.isOptionDisabled, E = f.isSearchable, S = f.menuIsOpen, A = f.options, k = f.screenReaderStatus, R = f.tabSelectsValue, N = f.isLoading, D = f["aria-label"], P = f["aria-live"], F = C.useMemo(function() {
    return Re(Re({}, gse), p || {});
  }, [p]), V = C.useMemo(function() {
    var U = "";
    if (n && F.onChange) {
      var z = n.option, B = n.options, q = n.removedValue, Y = n.removedValues, O = n.value, W = function(he) {
        return Array.isArray(he) ? null : he;
      }, Z = q || z || W(O), I = Z ? g(Z) : "", ie = B || Y || void 0, fe = ie ? ie.map(g) : [], re = Re({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: Z && x(Z, u),
        label: I,
        labels: fe
      }, n);
      U = F.onChange(re);
    }
    return U;
  }, [n, F, x, u, g]), T = C.useMemo(function() {
    var U = "", z = r || i, B = !!(r && u && u.includes(r));
    if (z && F.onFocus) {
      var q = {
        focused: z,
        label: g(z),
        isDisabled: x(z, u),
        isSelected: B,
        options: a,
        context: z === r ? "menu" : "value",
        selectValue: u,
        isAppleDevice: h
      };
      U = F.onFocus(q);
    }
    return U;
  }, [r, i, g, x, F, a, u, h]), $ = C.useMemo(function() {
    var U = "";
    if (S && A.length && !N && F.onFilter) {
      var z = k({
        count: a.length
      });
      U = F.onFilter({
        inputValue: y,
        resultsMessage: z
      });
    }
    return U;
  }, [a, y, S, F, A, k, N]), H = n?.action === "initial-input-focus", G = C.useMemo(function() {
    var U = "";
    if (F.guidance) {
      var z = i ? "value" : S ? "menu" : "input";
      U = F.guidance({
        "aria-label": D,
        context: z,
        isDisabled: r && x(r, u),
        isMulti: b,
        isSearchable: E,
        tabSelectsValue: R,
        isInitialFocus: H
      });
    }
    return U;
  }, [D, r, i, b, x, E, S, F, u, R, H]), j = Ee(C.Fragment, null, Ee("span", {
    id: "aria-selection"
  }, V), Ee("span", {
    id: "aria-focused"
  }, T), Ee("span", {
    id: "aria-results"
  }, $), Ee("span", {
    id: "aria-guidance"
  }, G));
  return Ee(C.Fragment, null, Ee(aT, {
    id: d
  }, H && j), Ee(aT, {
    "aria-live": P,
    "aria-atomic": "false",
    "aria-relevant": "additions text",
    role: "log"
  }, s && !H && j));
}, vse = yse, sb = [{
  base: "A",
  letters: "A"
}, {
  base: "AA",
  letters: ""
}, {
  base: "AE",
  letters: ""
}, {
  base: "AO",
  letters: ""
}, {
  base: "AU",
  letters: ""
}, {
  base: "AV",
  letters: ""
}, {
  base: "AY",
  letters: ""
}, {
  base: "B",
  letters: "B"
}, {
  base: "C",
  letters: "C"
}, {
  base: "D",
  letters: "D"
}, {
  base: "DZ",
  letters: ""
}, {
  base: "Dz",
  letters: ""
}, {
  base: "E",
  letters: "E"
}, {
  base: "F",
  letters: "F"
}, {
  base: "G",
  letters: "G"
}, {
  base: "H",
  letters: "H"
}, {
  base: "I",
  letters: "I"
}, {
  base: "J",
  letters: "J"
}, {
  base: "K",
  letters: "K"
}, {
  base: "L",
  letters: "L"
}, {
  base: "LJ",
  letters: ""
}, {
  base: "Lj",
  letters: ""
}, {
  base: "M",
  letters: "M"
}, {
  base: "N",
  letters: "N"
}, {
  base: "NJ",
  letters: ""
}, {
  base: "Nj",
  letters: ""
}, {
  base: "O",
  letters: "O"
}, {
  base: "OI",
  letters: ""
}, {
  base: "OO",
  letters: ""
}, {
  base: "OU",
  letters: ""
}, {
  base: "P",
  letters: "P"
}, {
  base: "Q",
  letters: "Q"
}, {
  base: "R",
  letters: "R"
}, {
  base: "S",
  letters: "S"
}, {
  base: "T",
  letters: "T"
}, {
  base: "TZ",
  letters: ""
}, {
  base: "U",
  letters: "U"
}, {
  base: "V",
  letters: "V"
}, {
  base: "VY",
  letters: ""
}, {
  base: "W",
  letters: "W"
}, {
  base: "X",
  letters: "X"
}, {
  base: "Y",
  letters: "Y"
}, {
  base: "Z",
  letters: "Z"
}, {
  base: "a",
  letters: "a"
}, {
  base: "aa",
  letters: ""
}, {
  base: "ae",
  letters: ""
}, {
  base: "ao",
  letters: ""
}, {
  base: "au",
  letters: ""
}, {
  base: "av",
  letters: ""
}, {
  base: "ay",
  letters: ""
}, {
  base: "b",
  letters: "b"
}, {
  base: "c",
  letters: "c"
}, {
  base: "d",
  letters: "d"
}, {
  base: "dz",
  letters: ""
}, {
  base: "e",
  letters: "e"
}, {
  base: "f",
  letters: "f"
}, {
  base: "g",
  letters: "g"
}, {
  base: "h",
  letters: "h"
}, {
  base: "hv",
  letters: ""
}, {
  base: "i",
  letters: "i"
}, {
  base: "j",
  letters: "j"
}, {
  base: "k",
  letters: "k"
}, {
  base: "l",
  letters: "l"
}, {
  base: "lj",
  letters: ""
}, {
  base: "m",
  letters: "m"
}, {
  base: "n",
  letters: "n"
}, {
  base: "nj",
  letters: ""
}, {
  base: "o",
  letters: "o"
}, {
  base: "oi",
  letters: ""
}, {
  base: "ou",
  letters: ""
}, {
  base: "oo",
  letters: ""
}, {
  base: "p",
  letters: "p"
}, {
  base: "q",
  letters: "q"
}, {
  base: "r",
  letters: "r"
}, {
  base: "s",
  letters: "s"
}, {
  base: "t",
  letters: "t"
}, {
  base: "tz",
  letters: ""
}, {
  base: "u",
  letters: "u"
}, {
  base: "v",
  letters: "v"
}, {
  base: "vy",
  letters: ""
}, {
  base: "w",
  letters: "w"
}, {
  base: "x",
  letters: "x"
}, {
  base: "y",
  letters: "y"
}, {
  base: "z",
  letters: "z"
}], bse = new RegExp("[" + sb.map(function(e) {
  return e.letters;
}).join("") + "]", "g"), s4 = {};
for (var My = 0; My < sb.length; My++)
  for (var Dy = sb[My], Py = 0; Py < Dy.letters.length; Py++)
    s4[Dy.letters[Py]] = Dy.base;
var l4 = function(t) {
  return t.replace(bse, function(n) {
    return s4[n];
  });
}, xse = hse(l4), sT = function(t) {
  return t.replace(/^\s+|\s+$/g, "");
}, wse = function(t) {
  return "".concat(t.label, " ").concat(t.value);
}, Sse = function(t) {
  return function(n, r) {
    if (n.data.__isNew__) return !0;
    var i = Re({
      ignoreCase: !0,
      ignoreAccents: !0,
      stringify: wse,
      trim: !0,
      matchFrom: "any"
    }, t), a = i.ignoreCase, s = i.ignoreAccents, u = i.stringify, f = i.trim, d = i.matchFrom, h = f ? sT(r) : r, p = f ? sT(u(n)) : u(n);
    return a && (h = h.toLowerCase(), p = p.toLowerCase()), s && (h = xse(h), p = l4(p)), d === "start" ? p.substr(0, h.length) === h : p.indexOf(h) > -1;
  };
}, _se = ["innerRef"];
function Ese(e) {
  var t = e.innerRef, n = Qi(e, _se), r = Koe(n, "onExited", "in", "enter", "exit", "appear");
  return Ee("input", ke({
    ref: t
  }, r, {
    css: /* @__PURE__ */ X1({
      label: "dummyInput",
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: "transparent",
      fontSize: "inherit",
      gridArea: "1 / 1 / 2 / 3",
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: "transparent",
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(.01)"
    }, "", "")
  }));
}
var Cse = function(t) {
  t.cancelable && t.preventDefault(), t.stopPropagation();
};
function kse(e) {
  var t = e.isEnabled, n = e.onBottomArrive, r = e.onBottomLeave, i = e.onTopArrive, a = e.onTopLeave, s = C.useRef(!1), u = C.useRef(!1), f = C.useRef(0), d = C.useRef(null), h = C.useCallback(function(E, S) {
    if (d.current !== null) {
      var A = d.current, k = A.scrollTop, R = A.scrollHeight, N = A.clientHeight, D = d.current, P = S > 0, F = R - N - k, V = !1;
      F > S && s.current && (r && r(E), s.current = !1), P && u.current && (a && a(E), u.current = !1), P && S > F ? (n && !s.current && n(E), D.scrollTop = R, V = !0, s.current = !0) : !P && -S > k && (i && !u.current && i(E), D.scrollTop = 0, V = !0, u.current = !0), V && Cse(E);
    }
  }, [n, r, i, a]), p = C.useCallback(function(E) {
    h(E, E.deltaY);
  }, [h]), g = C.useCallback(function(E) {
    f.current = E.changedTouches[0].clientY;
  }, []), y = C.useCallback(function(E) {
    var S = f.current - E.changedTouches[0].clientY;
    h(E, S);
  }, [h]), b = C.useCallback(function(E) {
    if (E) {
      var S = Goe ? {
        passive: !1
      } : !1;
      E.addEventListener("wheel", p, S), E.addEventListener("touchstart", g, S), E.addEventListener("touchmove", y, S);
    }
  }, [y, g, p]), x = C.useCallback(function(E) {
    E && (E.removeEventListener("wheel", p, !1), E.removeEventListener("touchstart", g, !1), E.removeEventListener("touchmove", y, !1));
  }, [y, g, p]);
  return C.useEffect(function() {
    if (t) {
      var E = d.current;
      return b(E), function() {
        x(E);
      };
    }
  }, [t, b, x]), function(E) {
    d.current = E;
  };
}
var lT = ["boxSizing", "height", "overflow", "paddingRight", "position"], uT = {
  boxSizing: "border-box",
  // account for possible declaration `width: 100%;` on body
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function cT(e) {
  e.cancelable && e.preventDefault();
}
function fT(e) {
  e.stopPropagation();
}
function dT() {
  var e = this.scrollTop, t = this.scrollHeight, n = e + this.offsetHeight;
  e === 0 ? this.scrollTop = 1 : n === t && (this.scrollTop = e - 1);
}
function hT() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
var pT = !!(typeof window < "u" && window.document && window.document.createElement), Bu = 0, Ls = {
  capture: !1,
  passive: !1
};
function Ase(e) {
  var t = e.isEnabled, n = e.accountForScrollbars, r = n === void 0 ? !0 : n, i = C.useRef({}), a = C.useRef(null), s = C.useCallback(function(f) {
    if (pT) {
      var d = document.body, h = d && d.style;
      if (r && lT.forEach(function(b) {
        var x = h && h[b];
        i.current[b] = x;
      }), r && Bu < 1) {
        var p = parseInt(i.current.paddingRight, 10) || 0, g = document.body ? document.body.clientWidth : 0, y = window.innerWidth - g + p || 0;
        Object.keys(uT).forEach(function(b) {
          var x = uT[b];
          h && (h[b] = x);
        }), h && (h.paddingRight = "".concat(y, "px"));
      }
      d && hT() && (d.addEventListener("touchmove", cT, Ls), f && (f.addEventListener("touchstart", dT, Ls), f.addEventListener("touchmove", fT, Ls))), Bu += 1;
    }
  }, [r]), u = C.useCallback(function(f) {
    if (pT) {
      var d = document.body, h = d && d.style;
      Bu = Math.max(Bu - 1, 0), r && Bu < 1 && lT.forEach(function(p) {
        var g = i.current[p];
        h && (h[p] = g);
      }), d && hT() && (d.removeEventListener("touchmove", cT, Ls), f && (f.removeEventListener("touchstart", dT, Ls), f.removeEventListener("touchmove", fT, Ls)));
    }
  }, [r]);
  return C.useEffect(function() {
    if (t) {
      var f = a.current;
      return s(f), function() {
        u(f);
      };
    }
  }, [t, s, u]), function(f) {
    a.current = f;
  };
}
var Tse = function(t) {
  var n = t.target;
  return n.ownerDocument.activeElement && n.ownerDocument.activeElement.blur();
}, Rse = {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
};
function Ose(e) {
  var t = e.children, n = e.lockEnabled, r = e.captureEnabled, i = r === void 0 ? !0 : r, a = e.onBottomArrive, s = e.onBottomLeave, u = e.onTopArrive, f = e.onTopLeave, d = kse({
    isEnabled: i,
    onBottomArrive: a,
    onBottomLeave: s,
    onTopArrive: u,
    onTopLeave: f
  }), h = Ase({
    isEnabled: n
  }), p = function(y) {
    d(y), h(y);
  };
  return Ee(C.Fragment, null, n && Ee("div", {
    onClick: Tse,
    css: Rse
  }), t(p));
}
var Nse = {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
}, Mse = function(t) {
  var n = t.name, r = t.onFocus;
  return Ee("input", {
    required: !0,
    name: n,
    tabIndex: -1,
    "aria-hidden": "true",
    onFocus: r,
    css: Nse,
    value: "",
    onChange: function() {
    }
  });
}, Dse = Mse;
function ax(e) {
  var t;
  return typeof window < "u" && window.navigator != null ? e.test(((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.platform) || window.navigator.platform) : !1;
}
function Pse() {
  return ax(/^iPhone/i);
}
function u4() {
  return ax(/^Mac/i);
}
function zse() {
  return ax(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  u4() && navigator.maxTouchPoints > 1;
}
function jse() {
  return Pse() || zse();
}
function Ise() {
  return u4() || jse();
}
var Lse = function(t) {
  return t.label;
}, Fse = function(t) {
  return t.label;
}, Bse = function(t) {
  return t.value;
}, $se = function(t) {
  return !!t.isDisabled;
}, Hse = {
  clearIndicator: Eae,
  container: hae,
  control: Nae,
  dropdownIndicator: Sae,
  group: zae,
  groupHeading: Iae,
  indicatorsContainer: yae,
  indicatorSeparator: kae,
  input: $ae,
  loadingIndicator: Rae,
  loadingMessage: lae,
  menu: tae,
  menuList: oae,
  menuPortal: fae,
  multiValue: Yae,
  multiValueLabel: Gae,
  multiValueRemove: Xae,
  noOptionsMessage: sae,
  option: ese,
  placeholder: rse,
  singleValue: ase,
  valueContainer: mae
}, Vse = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
}, Use = 4, c4 = 4, qse = 38, Yse = c4 * 2, Gse = {
  baseUnit: c4,
  controlHeight: qse,
  menuGutter: Yse
}, zy = {
  borderRadius: Use,
  colors: Vse,
  spacing: Gse
}, Xse = {
  "aria-live": "polite",
  backspaceRemovesValue: !0,
  blurInputOnSelect: rT(),
  captureMenuScroll: !rT(),
  classNames: {},
  closeMenuOnSelect: !0,
  closeMenuOnScroll: !1,
  components: {},
  controlShouldRenderValue: !0,
  escapeClearsValue: !1,
  filterOption: Sse(),
  formatGroupLabel: Lse,
  getOptionLabel: Fse,
  getOptionValue: Bse,
  isDisabled: !1,
  isLoading: !1,
  isMulti: !1,
  isRtl: !1,
  isSearchable: !0,
  isOptionDisabled: $se,
  loadingMessage: function() {
    return "Loading...";
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: !1,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: !1,
  menuShouldScrollIntoView: !qoe(),
  noOptionsMessage: function() {
    return "No options";
  },
  openMenuOnFocus: !1,
  openMenuOnClick: !0,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: function(t) {
    var n = t.count;
    return "".concat(n, " result").concat(n !== 1 ? "s" : "", " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: !0,
  unstyled: !1
};
function mT(e, t, n, r) {
  var i = h4(e, t, n), a = p4(e, t, n), s = d4(e, t), u = Jh(e, t);
  return {
    type: "option",
    data: t,
    isDisabled: i,
    isSelected: a,
    label: s,
    value: u,
    index: r
  };
}
function mh(e, t) {
  return e.options.map(function(n, r) {
    if ("options" in n) {
      var i = n.options.map(function(s, u) {
        return mT(e, s, t, u);
      }).filter(function(s) {
        return yT(e, s);
      });
      return i.length > 0 ? {
        type: "group",
        data: n,
        options: i,
        index: r
      } : void 0;
    }
    var a = mT(e, n, t, r);
    return yT(e, a) ? a : void 0;
  }).filter(Xoe);
}
function f4(e) {
  return e.reduce(function(t, n) {
    return n.type === "group" ? t.push.apply(t, ix(n.options.map(function(r) {
      return r.data;
    }))) : t.push(n.data), t;
  }, []);
}
function gT(e, t) {
  return e.reduce(function(n, r) {
    return r.type === "group" ? n.push.apply(n, ix(r.options.map(function(i) {
      return {
        data: i.data,
        id: "".concat(t, "-").concat(r.index, "-").concat(i.index)
      };
    }))) : n.push({
      data: r.data,
      id: "".concat(t, "-").concat(r.index)
    }), n;
  }, []);
}
function Wse(e, t) {
  return f4(mh(e, t));
}
function yT(e, t) {
  var n = e.inputValue, r = n === void 0 ? "" : n, i = t.data, a = t.isSelected, s = t.label, u = t.value;
  return (!g4(e) || !a) && m4(e, {
    label: s,
    value: u,
    data: i
  }, r);
}
function Kse(e, t) {
  var n = e.focusedValue, r = e.selectValue, i = r.indexOf(n);
  if (i > -1) {
    var a = t.indexOf(n);
    if (a > -1)
      return n;
    if (i < t.length)
      return t[i];
  }
  return null;
}
function Zse(e, t) {
  var n = e.focusedOption;
  return n && t.indexOf(n) > -1 ? n : t[0];
}
var jy = function(t, n) {
  var r, i = (r = t.find(function(a) {
    return a.data === n;
  })) === null || r === void 0 ? void 0 : r.id;
  return i || null;
}, d4 = function(t, n) {
  return t.getOptionLabel(n);
}, Jh = function(t, n) {
  return t.getOptionValue(n);
};
function h4(e, t, n) {
  return typeof e.isOptionDisabled == "function" ? e.isOptionDisabled(t, n) : !1;
}
function p4(e, t, n) {
  if (n.indexOf(t) > -1) return !0;
  if (typeof e.isOptionSelected == "function")
    return e.isOptionSelected(t, n);
  var r = Jh(e, t);
  return n.some(function(i) {
    return Jh(e, i) === r;
  });
}
function m4(e, t, n) {
  return e.filterOption ? e.filterOption(t, n) : !0;
}
var g4 = function(t) {
  var n = t.hideSelectedOptions, r = t.isMulti;
  return n === void 0 ? r : n;
}, Qse = 1, y4 = /* @__PURE__ */ function(e) {
  Noe(n, e);
  var t = Doe(n);
  function n(r) {
    var i;
    if (Roe(this, n), i = t.call(this, r), i.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedOptionId: null,
      focusableOptionsWithIds: [],
      focusedValue: null,
      inputIsHidden: !1,
      isFocused: !1,
      selectValue: [],
      clearFocusValueOnUpdate: !1,
      prevWasFocused: !1,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0,
      instancePrefix: ""
    }, i.blockOptionHover = !1, i.isComposing = !1, i.commonProps = void 0, i.initialTouchX = 0, i.initialTouchY = 0, i.openAfterFocus = !1, i.scrollToFocusedOptionOnUpdate = !1, i.userIsDragging = void 0, i.isAppleDevice = Ise(), i.controlRef = null, i.getControlRef = function(f) {
      i.controlRef = f;
    }, i.focusedOptionRef = null, i.getFocusedOptionRef = function(f) {
      i.focusedOptionRef = f;
    }, i.menuListRef = null, i.getMenuListRef = function(f) {
      i.menuListRef = f;
    }, i.inputRef = null, i.getInputRef = function(f) {
      i.inputRef = f;
    }, i.focus = i.focusInput, i.blur = i.blurInput, i.onChange = function(f, d) {
      var h = i.props, p = h.onChange, g = h.name;
      d.name = g, i.ariaOnChange(f, d), p(f, d);
    }, i.setValue = function(f, d, h) {
      var p = i.props, g = p.closeMenuOnSelect, y = p.isMulti, b = p.inputValue;
      i.onInputChange("", {
        action: "set-value",
        prevInputValue: b
      }), g && (i.setState({
        inputIsHiddenAfterUpdate: !y
      }), i.onMenuClose()), i.setState({
        clearFocusValueOnUpdate: !0
      }), i.onChange(f, {
        action: d,
        option: h
      });
    }, i.selectOption = function(f) {
      var d = i.props, h = d.blurInputOnSelect, p = d.isMulti, g = d.name, y = i.state.selectValue, b = p && i.isOptionSelected(f, y), x = i.isOptionDisabled(f, y);
      if (b) {
        var E = i.getOptionValue(f);
        i.setValue(y.filter(function(S) {
          return i.getOptionValue(S) !== E;
        }), "deselect-option", f);
      } else if (!x)
        p ? i.setValue([].concat(ix(y), [f]), "select-option", f) : i.setValue(f, "select-option");
      else {
        i.ariaOnChange(f, {
          action: "select-option",
          option: f,
          name: g
        });
        return;
      }
      h && i.blurInput();
    }, i.removeValue = function(f) {
      var d = i.props.isMulti, h = i.state.selectValue, p = i.getOptionValue(f), g = h.filter(function(b) {
        return i.getOptionValue(b) !== p;
      }), y = Xd(d, g, g[0] || null);
      i.onChange(y, {
        action: "remove-value",
        removedValue: f
      }), i.focusInput();
    }, i.clearValue = function() {
      var f = i.state.selectValue;
      i.onChange(Xd(i.props.isMulti, [], null), {
        action: "clear",
        removedValues: f
      });
    }, i.popValue = function() {
      var f = i.props.isMulti, d = i.state.selectValue, h = d[d.length - 1], p = d.slice(0, d.length - 1), g = Xd(f, p, p[0] || null);
      h && i.onChange(g, {
        action: "pop-value",
        removedValue: h
      });
    }, i.getFocusedOptionId = function(f) {
      return jy(i.state.focusableOptionsWithIds, f);
    }, i.getFocusableOptionsWithIds = function() {
      return gT(mh(i.props, i.state.selectValue), i.getElementId("option"));
    }, i.getValue = function() {
      return i.state.selectValue;
    }, i.cx = function() {
      for (var f = arguments.length, d = new Array(f), h = 0; h < f; h++)
        d[h] = arguments[h];
      return Boe.apply(void 0, [i.props.classNamePrefix].concat(d));
    }, i.getOptionLabel = function(f) {
      return d4(i.props, f);
    }, i.getOptionValue = function(f) {
      return Jh(i.props, f);
    }, i.getStyles = function(f, d) {
      var h = i.props.unstyled, p = Hse[f](d, h);
      p.boxSizing = "border-box";
      var g = i.props.styles[f];
      return g ? g(p, d) : p;
    }, i.getClassNames = function(f, d) {
      var h, p;
      return (h = (p = i.props.classNames)[f]) === null || h === void 0 ? void 0 : h.call(p, d);
    }, i.getElementId = function(f) {
      return "".concat(i.state.instancePrefix, "-").concat(f);
    }, i.getComponents = function() {
      return cse(i.props);
    }, i.buildCategorizedOptions = function() {
      return mh(i.props, i.state.selectValue);
    }, i.getCategorizedOptions = function() {
      return i.props.menuIsOpen ? i.buildCategorizedOptions() : [];
    }, i.buildFocusableOptions = function() {
      return f4(i.buildCategorizedOptions());
    }, i.getFocusableOptions = function() {
      return i.props.menuIsOpen ? i.buildFocusableOptions() : [];
    }, i.ariaOnChange = function(f, d) {
      i.setState({
        ariaSelection: Re({
          value: f
        }, d)
      });
    }, i.onMenuMouseDown = function(f) {
      f.button === 0 && (f.stopPropagation(), f.preventDefault(), i.focusInput());
    }, i.onMenuMouseMove = function(f) {
      i.blockOptionHover = !1;
    }, i.onControlMouseDown = function(f) {
      if (!f.defaultPrevented) {
        var d = i.props.openMenuOnClick;
        i.state.isFocused ? i.props.menuIsOpen ? f.target.tagName !== "INPUT" && f.target.tagName !== "TEXTAREA" && i.onMenuClose() : d && i.openMenu("first") : (d && (i.openAfterFocus = !0), i.focusInput()), f.target.tagName !== "INPUT" && f.target.tagName !== "TEXTAREA" && f.preventDefault();
      }
    }, i.onDropdownIndicatorMouseDown = function(f) {
      if (!(f && f.type === "mousedown" && f.button !== 0) && !i.props.isDisabled) {
        var d = i.props, h = d.isMulti, p = d.menuIsOpen;
        i.focusInput(), p ? (i.setState({
          inputIsHiddenAfterUpdate: !h
        }), i.onMenuClose()) : i.openMenu("first"), f.preventDefault();
      }
    }, i.onClearIndicatorMouseDown = function(f) {
      f && f.type === "mousedown" && f.button !== 0 || (i.clearValue(), f.preventDefault(), i.openAfterFocus = !1, f.type === "touchend" ? i.focusInput() : setTimeout(function() {
        return i.focusInput();
      }));
    }, i.onScroll = function(f) {
      typeof i.props.closeMenuOnScroll == "boolean" ? f.target instanceof HTMLElement && lm(f.target) && i.props.onMenuClose() : typeof i.props.closeMenuOnScroll == "function" && i.props.closeMenuOnScroll(f) && i.props.onMenuClose();
    }, i.onCompositionStart = function() {
      i.isComposing = !0;
    }, i.onCompositionEnd = function() {
      i.isComposing = !1;
    }, i.onTouchStart = function(f) {
      var d = f.touches, h = d && d.item(0);
      h && (i.initialTouchX = h.clientX, i.initialTouchY = h.clientY, i.userIsDragging = !1);
    }, i.onTouchMove = function(f) {
      var d = f.touches, h = d && d.item(0);
      if (h) {
        var p = Math.abs(h.clientX - i.initialTouchX), g = Math.abs(h.clientY - i.initialTouchY), y = 5;
        i.userIsDragging = p > y || g > y;
      }
    }, i.onTouchEnd = function(f) {
      i.userIsDragging || (i.controlRef && !i.controlRef.contains(f.target) && i.menuListRef && !i.menuListRef.contains(f.target) && i.blurInput(), i.initialTouchX = 0, i.initialTouchY = 0);
    }, i.onControlTouchEnd = function(f) {
      i.userIsDragging || i.onControlMouseDown(f);
    }, i.onClearIndicatorTouchEnd = function(f) {
      i.userIsDragging || i.onClearIndicatorMouseDown(f);
    }, i.onDropdownIndicatorTouchEnd = function(f) {
      i.userIsDragging || i.onDropdownIndicatorMouseDown(f);
    }, i.handleInputChange = function(f) {
      var d = i.props.inputValue, h = f.currentTarget.value;
      i.setState({
        inputIsHiddenAfterUpdate: !1
      }), i.onInputChange(h, {
        action: "input-change",
        prevInputValue: d
      }), i.props.menuIsOpen || i.onMenuOpen();
    }, i.onInputFocus = function(f) {
      i.props.onFocus && i.props.onFocus(f), i.setState({
        inputIsHiddenAfterUpdate: !1,
        isFocused: !0
      }), (i.openAfterFocus || i.props.openMenuOnFocus) && i.openMenu("first"), i.openAfterFocus = !1;
    }, i.onInputBlur = function(f) {
      var d = i.props.inputValue;
      if (i.menuListRef && i.menuListRef.contains(document.activeElement)) {
        i.inputRef.focus();
        return;
      }
      i.props.onBlur && i.props.onBlur(f), i.onInputChange("", {
        action: "input-blur",
        prevInputValue: d
      }), i.onMenuClose(), i.setState({
        focusedValue: null,
        isFocused: !1
      });
    }, i.onOptionHover = function(f) {
      if (!(i.blockOptionHover || i.state.focusedOption === f)) {
        var d = i.getFocusableOptions(), h = d.indexOf(f);
        i.setState({
          focusedOption: f,
          focusedOptionId: h > -1 ? i.getFocusedOptionId(f) : null
        });
      }
    }, i.shouldHideSelectedOptions = function() {
      return g4(i.props);
    }, i.onValueInputFocus = function(f) {
      f.preventDefault(), f.stopPropagation(), i.focus();
    }, i.onKeyDown = function(f) {
      var d = i.props, h = d.isMulti, p = d.backspaceRemovesValue, g = d.escapeClearsValue, y = d.inputValue, b = d.isClearable, x = d.isDisabled, E = d.menuIsOpen, S = d.onKeyDown, A = d.tabSelectsValue, k = d.openMenuOnFocus, R = i.state, N = R.focusedOption, D = R.focusedValue, P = R.selectValue;
      if (!x && !(typeof S == "function" && (S(f), f.defaultPrevented))) {
        switch (i.blockOptionHover = !0, f.key) {
          case "ArrowLeft":
            if (!h || y) return;
            i.focusValue("previous");
            break;
          case "ArrowRight":
            if (!h || y) return;
            i.focusValue("next");
            break;
          case "Delete":
          case "Backspace":
            if (y) return;
            if (D)
              i.removeValue(D);
            else {
              if (!p) return;
              h ? i.popValue() : b && i.clearValue();
            }
            break;
          case "Tab":
            if (i.isComposing || f.shiftKey || !E || !A || !N || // don't capture the event if the menu opens on focus and the focused
            // option is already selected; it breaks the flow of navigation
            k && i.isOptionSelected(N, P))
              return;
            i.selectOption(N);
            break;
          case "Enter":
            if (f.keyCode === 229)
              break;
            if (E) {
              if (!N || i.isComposing) return;
              i.selectOption(N);
              break;
            }
            return;
          case "Escape":
            E ? (i.setState({
              inputIsHiddenAfterUpdate: !1
            }), i.onInputChange("", {
              action: "menu-close",
              prevInputValue: y
            }), i.onMenuClose()) : b && g && i.clearValue();
            break;
          case " ":
            if (y)
              return;
            if (!E) {
              i.openMenu("first");
              break;
            }
            if (!N) return;
            i.selectOption(N);
            break;
          case "ArrowUp":
            E ? i.focusOption("up") : i.openMenu("last");
            break;
          case "ArrowDown":
            E ? i.focusOption("down") : i.openMenu("first");
            break;
          case "PageUp":
            if (!E) return;
            i.focusOption("pageup");
            break;
          case "PageDown":
            if (!E) return;
            i.focusOption("pagedown");
            break;
          case "Home":
            if (!E) return;
            i.focusOption("first");
            break;
          case "End":
            if (!E) return;
            i.focusOption("last");
            break;
          default:
            return;
        }
        f.preventDefault();
      }
    }, i.state.instancePrefix = "react-select-" + (i.props.instanceId || ++Qse), i.state.selectValue = tT(r.value), r.menuIsOpen && i.state.selectValue.length) {
      var a = i.getFocusableOptionsWithIds(), s = i.buildFocusableOptions(), u = s.indexOf(i.state.selectValue[0]);
      i.state.focusableOptionsWithIds = a, i.state.focusedOption = s[u], i.state.focusedOptionId = jy(a, s[u]);
    }
    return i;
  }
  return Ooe(n, [{
    key: "componentDidMount",
    value: function() {
      this.startListeningComposition(), this.startListeningToTouch(), this.props.closeMenuOnScroll && document && document.addEventListener && document.addEventListener("scroll", this.onScroll, !0), this.props.autoFocus && this.focusInput(), this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef && nT(this.menuListRef, this.focusedOptionRef);
    }
  }, {
    key: "componentDidUpdate",
    value: function(i) {
      var a = this.props, s = a.isDisabled, u = a.menuIsOpen, f = this.state.isFocused;
      // ensure focus is restored correctly when the control becomes enabled
      (f && !s && i.isDisabled || // ensure focus is on the Input when the menu opens
      f && u && !i.menuIsOpen) && this.focusInput(), f && s && !i.isDisabled ? this.setState({
        isFocused: !1
      }, this.onMenuClose) : !f && !s && i.isDisabled && this.inputRef === document.activeElement && this.setState({
        isFocused: !0
      }), this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate && (nT(this.menuListRef, this.focusedOptionRef), this.scrollToFocusedOptionOnUpdate = !1);
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.stopListeningComposition(), this.stopListeningToTouch(), document.removeEventListener("scroll", this.onScroll, !0);
    }
    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function() {
      this.onInputChange("", {
        action: "menu-close",
        prevInputValue: this.props.inputValue
      }), this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function(i, a) {
      this.props.onInputChange(i, a);
    }
    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function() {
      this.inputRef && this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function() {
      this.inputRef && this.inputRef.blur();
    }
    // aliased for consumers
  }, {
    key: "openMenu",
    value: function(i) {
      var a = this, s = this.state, u = s.selectValue, f = s.isFocused, d = this.buildFocusableOptions(), h = i === "first" ? 0 : d.length - 1;
      if (!this.props.isMulti) {
        var p = d.indexOf(u[0]);
        p > -1 && (h = p);
      }
      this.scrollToFocusedOptionOnUpdate = !(f && this.menuListRef), this.setState({
        inputIsHiddenAfterUpdate: !1,
        focusedValue: null,
        focusedOption: d[h],
        focusedOptionId: this.getFocusedOptionId(d[h])
      }, function() {
        return a.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function(i) {
      var a = this.state, s = a.selectValue, u = a.focusedValue;
      if (this.props.isMulti) {
        this.setState({
          focusedOption: null
        });
        var f = s.indexOf(u);
        u || (f = -1);
        var d = s.length - 1, h = -1;
        if (s.length) {
          switch (i) {
            case "previous":
              f === 0 ? h = 0 : f === -1 ? h = d : h = f - 1;
              break;
            case "next":
              f > -1 && f < d && (h = f + 1);
              break;
          }
          this.setState({
            inputIsHidden: h !== -1,
            focusedValue: s[h]
          });
        }
      }
    }
  }, {
    key: "focusOption",
    value: function() {
      var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first", a = this.props.pageSize, s = this.state.focusedOption, u = this.getFocusableOptions();
      if (u.length) {
        var f = 0, d = u.indexOf(s);
        s || (d = -1), i === "up" ? f = d > 0 ? d - 1 : u.length - 1 : i === "down" ? f = (d + 1) % u.length : i === "pageup" ? (f = d - a, f < 0 && (f = 0)) : i === "pagedown" ? (f = d + a, f > u.length - 1 && (f = u.length - 1)) : i === "last" && (f = u.length - 1), this.scrollToFocusedOptionOnUpdate = !0, this.setState({
          focusedOption: u[f],
          focusedValue: null,
          focusedOptionId: this.getFocusedOptionId(u[f])
        });
      }
    }
  }, {
    key: "getTheme",
    value: (
      // ==============================
      // Getters
      // ==============================
      function() {
        return this.props.theme ? typeof this.props.theme == "function" ? this.props.theme(zy) : Re(Re({}, zy), this.props.theme) : zy;
      }
    )
  }, {
    key: "getCommonProps",
    value: function() {
      var i = this.clearValue, a = this.cx, s = this.getStyles, u = this.getClassNames, f = this.getValue, d = this.selectOption, h = this.setValue, p = this.props, g = p.isMulti, y = p.isRtl, b = p.options, x = this.hasValue();
      return {
        clearValue: i,
        cx: a,
        getStyles: s,
        getClassNames: u,
        getValue: f,
        hasValue: x,
        isMulti: g,
        isRtl: y,
        options: b,
        selectOption: d,
        selectProps: p,
        setValue: h,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function() {
      var i = this.state.selectValue;
      return i.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function() {
      var i = this.props, a = i.isClearable, s = i.isMulti;
      return a === void 0 ? s : a;
    }
  }, {
    key: "isOptionDisabled",
    value: function(i, a) {
      return h4(this.props, i, a);
    }
  }, {
    key: "isOptionSelected",
    value: function(i, a) {
      return p4(this.props, i, a);
    }
  }, {
    key: "filterOption",
    value: function(i, a) {
      return m4(this.props, i, a);
    }
  }, {
    key: "formatOptionLabel",
    value: function(i, a) {
      if (typeof this.props.formatOptionLabel == "function") {
        var s = this.props.inputValue, u = this.state.selectValue;
        return this.props.formatOptionLabel(i, {
          context: a,
          inputValue: s,
          selectValue: u
        });
      } else
        return this.getOptionLabel(i);
    }
  }, {
    key: "formatGroupLabel",
    value: function(i) {
      return this.props.formatGroupLabel(i);
    }
    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value: (
      // ==============================
      // Composition Handlers
      // ==============================
      function() {
        document && document.addEventListener && (document.addEventListener("compositionstart", this.onCompositionStart, !1), document.addEventListener("compositionend", this.onCompositionEnd, !1));
      }
    )
  }, {
    key: "stopListeningComposition",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("compositionstart", this.onCompositionStart), document.removeEventListener("compositionend", this.onCompositionEnd));
    }
  }, {
    key: "startListeningToTouch",
    value: (
      // ==============================
      // Touch Handlers
      // ==============================
      function() {
        document && document.addEventListener && (document.addEventListener("touchstart", this.onTouchStart, !1), document.addEventListener("touchmove", this.onTouchMove, !1), document.addEventListener("touchend", this.onTouchEnd, !1));
      }
    )
  }, {
    key: "stopListeningToTouch",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("touchstart", this.onTouchStart), document.removeEventListener("touchmove", this.onTouchMove), document.removeEventListener("touchend", this.onTouchEnd));
    }
  }, {
    key: "renderInput",
    value: (
      // ==============================
      // Renderers
      // ==============================
      function() {
        var i = this.props, a = i.isDisabled, s = i.isSearchable, u = i.inputId, f = i.inputValue, d = i.tabIndex, h = i.form, p = i.menuIsOpen, g = i.required, y = this.getComponents(), b = y.Input, x = this.state, E = x.inputIsHidden, S = x.ariaSelection, A = this.commonProps, k = u || this.getElementId("input"), R = Re(Re(Re({
          "aria-autocomplete": "list",
          "aria-expanded": p,
          "aria-haspopup": !0,
          "aria-errormessage": this.props["aria-errormessage"],
          "aria-invalid": this.props["aria-invalid"],
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-required": g,
          role: "combobox",
          "aria-activedescendant": this.isAppleDevice ? void 0 : this.state.focusedOptionId || ""
        }, p && {
          "aria-controls": this.getElementId("listbox")
        }), !s && {
          "aria-readonly": !0
        }), this.hasValue() ? S?.action === "initial-input-focus" && {
          "aria-describedby": this.getElementId("live-region")
        } : {
          "aria-describedby": this.getElementId("placeholder")
        });
        return s ? /* @__PURE__ */ C.createElement(b, ke({}, A, {
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id: k,
          innerRef: this.getInputRef,
          isDisabled: a,
          isHidden: E,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex: d,
          form: h,
          type: "text",
          value: f
        }, R)) : /* @__PURE__ */ C.createElement(Ese, ke({
          id: k,
          innerRef: this.getInputRef,
          onBlur: this.onInputBlur,
          onChange: Zh,
          onFocus: this.onInputFocus,
          disabled: a,
          tabIndex: d,
          inputMode: "none",
          form: h,
          value: ""
        }, R));
      }
    )
  }, {
    key: "renderPlaceholderOrValue",
    value: function() {
      var i = this, a = this.getComponents(), s = a.MultiValue, u = a.MultiValueContainer, f = a.MultiValueLabel, d = a.MultiValueRemove, h = a.SingleValue, p = a.Placeholder, g = this.commonProps, y = this.props, b = y.controlShouldRenderValue, x = y.isDisabled, E = y.isMulti, S = y.inputValue, A = y.placeholder, k = this.state, R = k.selectValue, N = k.focusedValue, D = k.isFocused;
      if (!this.hasValue() || !b)
        return S ? null : /* @__PURE__ */ C.createElement(p, ke({}, g, {
          key: "placeholder",
          isDisabled: x,
          isFocused: D,
          innerProps: {
            id: this.getElementId("placeholder")
          }
        }), A);
      if (E)
        return R.map(function(F, V) {
          var T = F === N, $ = "".concat(i.getOptionLabel(F), "-").concat(i.getOptionValue(F));
          return /* @__PURE__ */ C.createElement(s, ke({}, g, {
            components: {
              Container: u,
              Label: f,
              Remove: d
            },
            isFocused: T,
            isDisabled: x,
            key: $,
            index: V,
            removeProps: {
              onClick: function() {
                return i.removeValue(F);
              },
              onTouchEnd: function() {
                return i.removeValue(F);
              },
              onMouseDown: function(G) {
                G.preventDefault();
              }
            },
            data: F
          }), i.formatOptionLabel(F, "value"));
        });
      if (S)
        return null;
      var P = R[0];
      return /* @__PURE__ */ C.createElement(h, ke({}, g, {
        data: P,
        isDisabled: x
      }), this.formatOptionLabel(P, "value"));
    }
  }, {
    key: "renderClearIndicator",
    value: function() {
      var i = this.getComponents(), a = i.ClearIndicator, s = this.commonProps, u = this.props, f = u.isDisabled, d = u.isLoading, h = this.state.isFocused;
      if (!this.isClearable() || !a || f || !this.hasValue() || d)
        return null;
      var p = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ C.createElement(a, ke({}, s, {
        innerProps: p,
        isFocused: h
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function() {
      var i = this.getComponents(), a = i.LoadingIndicator, s = this.commonProps, u = this.props, f = u.isDisabled, d = u.isLoading, h = this.state.isFocused;
      if (!a || !d) return null;
      var p = {
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ C.createElement(a, ke({}, s, {
        innerProps: p,
        isDisabled: f,
        isFocused: h
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function() {
      var i = this.getComponents(), a = i.DropdownIndicator, s = i.IndicatorSeparator;
      if (!a || !s) return null;
      var u = this.commonProps, f = this.props.isDisabled, d = this.state.isFocused;
      return /* @__PURE__ */ C.createElement(s, ke({}, u, {
        isDisabled: f,
        isFocused: d
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function() {
      var i = this.getComponents(), a = i.DropdownIndicator;
      if (!a) return null;
      var s = this.commonProps, u = this.props.isDisabled, f = this.state.isFocused, d = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ C.createElement(a, ke({}, s, {
        innerProps: d,
        isDisabled: u,
        isFocused: f
      }));
    }
  }, {
    key: "renderMenu",
    value: function() {
      var i = this, a = this.getComponents(), s = a.Group, u = a.GroupHeading, f = a.Menu, d = a.MenuList, h = a.MenuPortal, p = a.LoadingMessage, g = a.NoOptionsMessage, y = a.Option, b = this.commonProps, x = this.state.focusedOption, E = this.props, S = E.captureMenuScroll, A = E.inputValue, k = E.isLoading, R = E.loadingMessage, N = E.minMenuHeight, D = E.maxMenuHeight, P = E.menuIsOpen, F = E.menuPlacement, V = E.menuPosition, T = E.menuPortalTarget, $ = E.menuShouldBlockScroll, H = E.menuShouldScrollIntoView, G = E.noOptionsMessage, j = E.onMenuScrollToTop, U = E.onMenuScrollToBottom;
      if (!P) return null;
      var z = function(I, ie) {
        var fe = I.type, re = I.data, le = I.isDisabled, he = I.isSelected, ye = I.label, je = I.value, Oe = x === re, be = le ? void 0 : function() {
          return i.onOptionHover(re);
        }, Le = le ? void 0 : function() {
          return i.selectOption(re);
        }, Ie = "".concat(i.getElementId("option"), "-").concat(ie), ft = {
          id: Ie,
          onClick: Le,
          onMouseMove: be,
          onMouseOver: be,
          tabIndex: -1,
          role: "option",
          "aria-selected": i.isAppleDevice ? void 0 : he
          // is not supported on Apple devices
        };
        return /* @__PURE__ */ C.createElement(y, ke({}, b, {
          innerProps: ft,
          data: re,
          isDisabled: le,
          isSelected: he,
          key: Ie,
          label: ye,
          type: fe,
          value: je,
          isFocused: Oe,
          innerRef: Oe ? i.getFocusedOptionRef : void 0
        }), i.formatOptionLabel(I.data, "menu"));
      }, B;
      if (this.hasOptions())
        B = this.getCategorizedOptions().map(function(Z) {
          if (Z.type === "group") {
            var I = Z.data, ie = Z.options, fe = Z.index, re = "".concat(i.getElementId("group"), "-").concat(fe), le = "".concat(re, "-heading");
            return /* @__PURE__ */ C.createElement(s, ke({}, b, {
              key: re,
              data: I,
              options: ie,
              Heading: u,
              headingProps: {
                id: le,
                data: Z.data
              },
              label: i.formatGroupLabel(Z.data)
            }), Z.options.map(function(he) {
              return z(he, "".concat(fe, "-").concat(he.index));
            }));
          } else if (Z.type === "option")
            return z(Z, "".concat(Z.index));
        });
      else if (k) {
        var q = R({
          inputValue: A
        });
        if (q === null) return null;
        B = /* @__PURE__ */ C.createElement(p, b, q);
      } else {
        var Y = G({
          inputValue: A
        });
        if (Y === null) return null;
        B = /* @__PURE__ */ C.createElement(g, b, Y);
      }
      var O = {
        minMenuHeight: N,
        maxMenuHeight: D,
        menuPlacement: F,
        menuPosition: V,
        menuShouldScrollIntoView: H
      }, W = /* @__PURE__ */ C.createElement(nae, ke({}, b, O), function(Z) {
        var I = Z.ref, ie = Z.placerProps, fe = ie.placement, re = ie.maxHeight;
        return /* @__PURE__ */ C.createElement(f, ke({}, b, O, {
          innerRef: I,
          innerProps: {
            onMouseDown: i.onMenuMouseDown,
            onMouseMove: i.onMenuMouseMove
          },
          isLoading: k,
          placement: fe
        }), /* @__PURE__ */ C.createElement(Ose, {
          captureEnabled: S,
          onTopArrive: j,
          onBottomArrive: U,
          lockEnabled: $
        }, function(le) {
          return /* @__PURE__ */ C.createElement(d, ke({}, b, {
            innerRef: function(ye) {
              i.getMenuListRef(ye), le(ye);
            },
            innerProps: {
              role: "listbox",
              "aria-multiselectable": b.isMulti,
              id: i.getElementId("listbox")
            },
            isLoading: k,
            maxHeight: re,
            focusedOption: x
          }), B);
        }));
      });
      return T || V === "fixed" ? /* @__PURE__ */ C.createElement(h, ke({}, b, {
        appendTo: T,
        controlElement: this.controlRef,
        menuPlacement: F,
        menuPosition: V
      }), W) : W;
    }
  }, {
    key: "renderFormField",
    value: function() {
      var i = this, a = this.props, s = a.delimiter, u = a.isDisabled, f = a.isMulti, d = a.name, h = a.required, p = this.state.selectValue;
      if (h && !this.hasValue() && !u)
        return /* @__PURE__ */ C.createElement(Dse, {
          name: d,
          onFocus: this.onValueInputFocus
        });
      if (!(!d || u))
        if (f)
          if (s) {
            var g = p.map(function(x) {
              return i.getOptionValue(x);
            }).join(s);
            return /* @__PURE__ */ C.createElement("input", {
              name: d,
              type: "hidden",
              value: g
            });
          } else {
            var y = p.length > 0 ? p.map(function(x, E) {
              return /* @__PURE__ */ C.createElement("input", {
                key: "i-".concat(E),
                name: d,
                type: "hidden",
                value: i.getOptionValue(x)
              });
            }) : /* @__PURE__ */ C.createElement("input", {
              name: d,
              type: "hidden",
              value: ""
            });
            return /* @__PURE__ */ C.createElement("div", null, y);
          }
        else {
          var b = p[0] ? this.getOptionValue(p[0]) : "";
          return /* @__PURE__ */ C.createElement("input", {
            name: d,
            type: "hidden",
            value: b
          });
        }
    }
  }, {
    key: "renderLiveRegion",
    value: function() {
      var i = this.commonProps, a = this.state, s = a.ariaSelection, u = a.focusedOption, f = a.focusedValue, d = a.isFocused, h = a.selectValue, p = this.getFocusableOptions();
      return /* @__PURE__ */ C.createElement(vse, ke({}, i, {
        id: this.getElementId("live-region"),
        ariaSelection: s,
        focusedOption: u,
        focusedValue: f,
        isFocused: d,
        selectValue: h,
        focusableOptions: p,
        isAppleDevice: this.isAppleDevice
      }));
    }
  }, {
    key: "render",
    value: function() {
      var i = this.getComponents(), a = i.Control, s = i.IndicatorsContainer, u = i.SelectContainer, f = i.ValueContainer, d = this.props, h = d.className, p = d.id, g = d.isDisabled, y = d.menuIsOpen, b = this.state.isFocused, x = this.commonProps = this.getCommonProps();
      return /* @__PURE__ */ C.createElement(u, ke({}, x, {
        className: h,
        innerProps: {
          id: p,
          onKeyDown: this.onKeyDown
        },
        isDisabled: g,
        isFocused: b
      }), this.renderLiveRegion(), /* @__PURE__ */ C.createElement(a, ke({}, x, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled: g,
        isFocused: b,
        menuIsOpen: y
      }), /* @__PURE__ */ C.createElement(f, ke({}, x, {
        isDisabled: g
      }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ C.createElement(s, ke({}, x, {
        isDisabled: g
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(i, a) {
      var s = a.prevProps, u = a.clearFocusValueOnUpdate, f = a.inputIsHiddenAfterUpdate, d = a.ariaSelection, h = a.isFocused, p = a.prevWasFocused, g = a.instancePrefix, y = i.options, b = i.value, x = i.menuIsOpen, E = i.inputValue, S = i.isMulti, A = tT(b), k = {};
      if (s && (b !== s.value || y !== s.options || x !== s.menuIsOpen || E !== s.inputValue)) {
        var R = x ? Wse(i, A) : [], N = x ? gT(mh(i, A), "".concat(g, "-option")) : [], D = u ? Kse(a, A) : null, P = Zse(a, R), F = jy(N, P);
        k = {
          selectValue: A,
          focusedOption: P,
          focusedOptionId: F,
          focusableOptionsWithIds: N,
          focusedValue: D,
          clearFocusValueOnUpdate: !1
        };
      }
      var V = f != null && i !== s ? {
        inputIsHidden: f,
        inputIsHiddenAfterUpdate: void 0
      } : {}, T = d, $ = h && p;
      return h && !$ && (T = {
        value: Xd(S, A, A[0] || null),
        options: A,
        action: "initial-input-focus"
      }, $ = !p), d?.action === "initial-input-focus" && (T = null), Re(Re(Re({}, k), V), {}, {
        prevProps: i,
        ariaSelection: T,
        prevWasFocused: $
      });
    }
  }]), n;
}(C.Component);
y4.defaultProps = Xse;
var Jse = /* @__PURE__ */ C.forwardRef(function(e, t) {
  var n = Toe(e);
  return /* @__PURE__ */ C.createElement(y4, ke({
    ref: t
  }, n));
}), ele = Jse;
const tle = ({
  options: e,
  items_per_page: t,
  className: n,
  defaultValue: r,
  onChange: i
}) => {
  const [a, s] = C.useState(""), [u, f] = C.useState(0), d = (y) => {
    s(y.toLowerCase()), f(0);
  }, h = e.filter((y) => y.label.toLowerCase().includes(a) || y.value.toLowerCase().includes(a));
  var p;
  t !== void 0 ? p = h.slice(
    u * t,
    (u + 1) * t
  ) : p = h;
  const g = {
    control: (y) => ({
      ...y,
      minHeight: void 0
    })
  };
  return /* @__PURE__ */ _.jsx(
    ele,
    {
      options: p,
      onInputChange: d,
      onChange: i,
      inputValue: a,
      isSearchable: !0,
      placeholder: "Select an option...",
      className: n,
      unstyled: !0,
      styles: g,
      classNamePrefix: "styled-select",
      defaultValue: r,
      value: r
    }
  );
};
function nle(e) {
  return e === 0 ? 0 : Math.abs(e) < 1e-12 ? e : Number(e.toPrecision(12));
}
const v4 = ({
  iostore: e,
  inputconverter: t,
  parser: n = (r) => parseFloat(r)
}) => {
  const r = C.useContext(Xe), { preview: i } = e.valuestore(), a = e.use(), [s, u] = C.useState(
    t[1](i?.value)
  );
  C.useEffect(() => {
    u(t[1](i?.value));
  }, [i]);
  const f = (y) => {
    y = n(
      parseFloat(y.toString()).toString()
      // parse float first for e notation
    ), isNaN(y) ? (y = "<NoValue>", u("")) : (a.value_options?.min !== void 0 && y < a.value_options.min && (y = a.value_options.min), a.value_options?.max !== void 0 && y > a.value_options.max && (y = a.value_options.max), y = nle(y), u(y.toString()));
    try {
      y = t[0](y);
    } catch {
    }
    r.worker?.set_io_value({
      nid: a.node,
      ioid: a.id,
      value: y,
      set_default: a.render_options.set_default
    });
  }, d = (y) => {
    f(y.target.value);
  };
  let h = a.connected ? t[1](i?.value) : s;
  h === void 0 && (h = a.value_options?.min), h === void 0 && (h = a.value_options?.max), h === void 0 && (h = ""), h === null && (h = "");
  let p = null, g = 1;
  return a.value_options?.step !== void 0 ? g = a.value_options.step : a.value_options?.max !== void 0 && a.value_options?.min !== void 0 && (g = (a.value_options?.max - a.value_options?.min) / 1e3), a.value_options?.max !== void 0 && a.value_options?.min !== void 0 && !a.connected && (p = /* @__PURE__ */ _.jsx("div", { style: { minWidth: "6.25rem" }, className: "SliderContainer", children: /* @__PURE__ */ _.jsxs(
    soe,
    {
      className: "SliderRoot",
      value: [h === void 0 ? a.value_options?.min : h],
      min: a.value_options?.min,
      max: a.value_options?.max,
      step: g,
      disabled: a.connected,
      onValueCommit: (y) => {
        isNaN(y[0]) || f(y[0]);
      },
      onValueChange: (y) => {
        isNaN(y[0]) || u(y[0].toString());
      },
      onKeyDown: (y) => {
        ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(
          y.key
        ) && y.stopPropagation();
      },
      children: [
        /* @__PURE__ */ _.jsx(loe, { className: "SliderTrack", children: /* @__PURE__ */ _.jsx(uoe, { className: "SliderRange" }) }),
        /* @__PURE__ */ _.jsx(coe, { className: "SliderThumb" })
      ]
    }
  ) })), /* @__PURE__ */ _.jsxs(_.Fragment, { children: [
    p,
    /* @__PURE__ */ _.jsx(
      "input",
      {
        type: "text",
        className: "nodedatainput styledinput numberinput",
        value: h,
        onChange: (y) => u(y.target.value),
        onBlur: d,
        step: g,
        onKeyDown: (y) => {
          if (!(y.ctrlKey || y.metaKey)) {
            if (y.key === "ArrowUp") {
              y.shiftKey && (g *= 10);
              let b = (parseFloat(h) || 0) + g;
              f(b);
              return;
            }
            if (y.key === "ArrowDown") {
              y.shiftKey && (g *= 10);
              let b = (parseFloat(h) || 0) - g;
              f(b);
              return;
            }
            !/^[0-9.eE+-]$/.test(y.key) && !["Backspace", "ArrowLeft", "ArrowRight", "Delete", "Tab"].includes(
              y.key
            ) && y.preventDefault();
          }
        },
        disabled: a.connected,
        min: a.value_options?.min,
        max: a.value_options?.max
      }
    )
  ] });
}, rle = ({
  iostore: e,
  inputconverter: t
}) => v4({ iostore: e, inputconverter: t, parser: parseFloat }), ile = ({
  iostore: e,
  inputconverter: t
}) => v4({ iostore: e, inputconverter: t, parser: parseInt }), ole = ({
  iostore: e,
  inputconverter: t
}) => {
  const n = C.useContext(Xe), { preview: r } = e.valuestore(), i = e.use(), a = r?.value === void 0, s = C.useRef(null);
  C.useEffect(() => {
    s.current && (s.current.indeterminate = a);
  }, [s, a]);
  const u = (f) => {
    let d = f.target.checked;
    try {
      d = t[0](f.target.checked);
    } catch {
    }
    n.worker?.set_io_value({
      nid: i.node,
      ioid: i.id,
      value: d,
      set_default: i.render_options.set_default
    });
  };
  return /* @__PURE__ */ _.jsx(
    "input",
    {
      ref: s,
      type: "checkbox",
      className: "styledcheckbox booleaninput",
      checked: !!t[1](r?.value),
      onChange: u,
      disabled: i.connected
    }
  );
}, vT = ({
  iostore: e,
  inputconverter: t
}) => {
  const n = C.useContext(Xe), { preview: r, full: i } = e.valuestore(), a = e.use(), s = i === void 0 ? r?.value : i?.value, [u, f] = C.useState(t[1](s));
  C.useEffect(() => {
    f(t[1](s));
  }, [s]);
  const d = (p) => {
    let g = p.target.value;
    g || (g = "<NoValue>");
    try {
      g = t[0](g);
    } catch {
    }
    n.worker?.set_io_value({
      nid: a.node,
      ioid: a.id,
      value: g,
      set_default: a.render_options.set_default
    });
  };
  let h = a.connected ? t[1](s) : u;
  return h == null && (h = ""), /* @__PURE__ */ _.jsx(
    "input",
    {
      className: "nodedatainput styledinput stringinput",
      value: h,
      onChange: (p) => f(p.target.value),
      onBlur: d,
      disabled: a.connected
    }
  );
}, ale = ({ iostore: e }) => {
  const t = C.useContext(Xe), n = e.use(), { preview: r, full: i } = e.valuestore(), a = i === void 0 ? r?.value : i.value, s = n.value_options?.colorspace || "hex", u = (d) => {
    let h = "<NoValue>";
    d && (d[s] ? h = d[s]() : h = d.hex()), d === null && (h = null);
    try {
      h = h;
    } catch {
    }
    t.worker?.set_io_value({
      nid: n.node,
      ioid: n.id,
      value: h,
      set_default: n.render_options.set_default
    });
  };
  let f = !1;
  return typeof n.type != "string" && "anyOf" in n.type && n.type.anyOf !== void 0 && (f = n.type.anyOf.some((d) => d === "None")), /* @__PURE__ */ _.jsx(
    Soe,
    {
      onChange: u,
      inicolordata: a,
      allow_null: f,
      inicolorspace: s
    }
  );
}, sle = (e) => e, lle = (e) => parseFloat(e), ule = (e) => !!e, cle = (e) => e === "null" ? null : e, fle = (e) => e === "nuinputconvertermber" ? lle : e === "boolean" ? ule : e === "undefined" ? cle : sle, ep = ({
  iostore: e,
  inputconverter: t,
  parser: n
}) => {
  const r = e.use(), { preview: i, full: a } = e.valuestore(), s = a === void 0 ? i?.value : a.value;
  let u = r.value_options?.options || [];
  Array.isArray(u) && (u = {
    type: "enum",
    values: u,
    keys: u.map((x) => x === null ? "None" : x.toString()),
    nullable: !1
  }), u.type !== "enum" && (u = {
    type: "enum",
    values: Object.values(u),
    keys: Object.keys(u),
    nullable: !1
  }), u = u, u.nullable && !u.values.includes(null) && !u.keys.includes("None") && (u.values.unshift(null), u.keys.unshift("None"));
  const f = [];
  for (let x = 0; x < u.values.length; x++) {
    const E = u.values[x] === null || u.values[x] === void 0 ? "undefined" : typeof u.values[x];
    let S = u.values[x];
    S === null && (S = "null"), S === void 0 && (S = "undefined"), f.push([u.keys[x], S.toString(), E]);
  }
  const d = C.useContext(Xe), h = ({
    value: x,
    // label
    datatype: E
  }) => {
    let A = (n || fle(E))(x);
    try {
      A = t[0](x);
    } catch {
    }
    d.worker?.set_io_value({
      nid: r.node,
      ioid: r.id,
      value: A,
      set_default: r.render_options.set_default
    });
  };
  let p = s;
  p === null && (p = "null"), p === void 0 && (p = "undefined");
  const g = f.find((x) => x[1] === p.toString());
  let y;
  g !== void 0 && (y = {
    value: g[1],
    label: g[0],
    datatype: g[2]
  });
  const b = f.map(
    (x) => ({
      value: x[1],
      label: x[0],
      datatype: x[2]
    })
  );
  return (
    // <Suspense fallback={<select disabled={true}></select>}>
    /* @__PURE__ */ _.jsx(
      tle,
      {
        className: "nodedatainput styleddropdown",
        options: b,
        defaultValue: y,
        onChange: (x) => {
          if (x === null) {
            h({
              value: "<NoValue>",
              datatype: "string"
            });
            return;
          }
          h(x);
        }
      }
    )
  );
}, dle = (e, t = void 0) => ({ iostore: n }) => {
  const { full: r, preview: i } = n.valuestore(), s = (r === void 0 ? i : r)?.value || t;
  return /* @__PURE__ */ _.jsx(e, { iostore: n, value: s });
}, hle = {
  float: rle,
  int: ile,
  bool: ole,
  string: vT,
  str: vT,
  color: ale,
  select: ep,
  enum: ep,
  bytes: dle(nx, "")
}, ple = ({
  iostore: e,
  typestring: t
}) => {
  const { InLineRenderer: n } = C.useContext(Ji), { preview: r, full: i } = e.valuestore();
  if (t && n[t])
    return /* @__PURE__ */ _.jsx("div", { children: n[t]({ iostore: e }) });
  let a = (JSON.stringify(i || r) || "").replace(/\\n/g, `
`);
  return a.length > 63 && (a = a.slice(0, 60) + "..."), /* @__PURE__ */ _.jsx("div", { children: a });
}, mle = {}, Tr = (e, t = void 0) => ({ iostore: n }) => {
  const { full: r, preview: i } = n.valuestore(), s = (r === void 0 ? i : r)?.value || t;
  return /* @__PURE__ */ _.jsx(e, { iostore: n, value: s });
}, gle = {
  string: Tr(O5),
  table: Tr(N5),
  image: Tr(T5),
  svg: Tr(R5, ""),
  dict: Tr(am, "{}"),
  bytes: Tr(nx, "")
}, yle = {}, b4 = (e) => ({
  iostore: t,
  value: n,
  preValue: r,
  onLoaded: i
}) => /* @__PURE__ */ _.jsx(
  e,
  {
    iostore: t,
    value: n,
    preValue: r,
    onLoaded: i
  }
), bT = b4(am), vle = {
  // image: Base64FullImageOutput,
}, ble = {}, xle = {}, wle = {}, kr = {
  Inputrenderer: hle,
  Outputrenderer: mle,
  HandlePreviewRenderer: yle,
  DataOverlayRenderer: vle,
  DataPreviewViewRenderer: gle,
  DataViewRenderer: Uie,
  InLineRenderer: WJ,
  NodeContextExtenders: wle,
  NodeRenderer: ble,
  NodeHooks: xle
}, Sle = (e, t) => {
  const n = t.options || {}, r = n.overwrite === void 0 ? !0 : n.overwrite;
  switch (t.type) {
    case "EXTEND_INPUT_RENDER":
      return !r && e.Inputrenderer[t.payload.type] ? e : {
        ...e,
        Inputrenderer: {
          ...e.Inputrenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_OUTPUT_RENDER":
      return !r && e.Outputrenderer[t.payload.type] ? e : {
        ...e,
        Outputrenderer: {
          ...e.Outputrenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_HANDLE_PREVIEW_RENDER":
      return !r && e.HandlePreviewRenderer[t.payload.type] ? e : {
        ...e,
        HandlePreviewRenderer: {
          ...e.HandlePreviewRenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_DATA_OVERLAY_RENDER":
      return !r && e.DataOverlayRenderer[t.payload.type] ? e : {
        ...e,
        DataOverlayRenderer: {
          ...e.DataOverlayRenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_DATA_PREVIEW_RENDER":
      return !r && e.DataPreviewViewRenderer[t.payload.type] ? e : {
        ...e,
        DataPreviewViewRenderer: {
          ...e.DataPreviewViewRenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_DATA_VIEW_RENDER":
      return !r && e.DataViewRenderer[t.payload.type] ? e : {
        ...e,
        DataViewRenderer: {
          ...e.DataViewRenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_NODE_CONTEXT_EXTENDER":
      return !r && e.NodeContextExtenders[t.payload.type] ? e : {
        ...e,
        NodeContextExtenders: {
          ...e.NodeContextExtenders,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_NODE_RENDERER":
      return !r && e.NodeRenderer[t.payload.type] ? e : {
        ...e,
        NodeRenderer: {
          ...e.NodeRenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_NODE_HOOKS":
      return !r && e.NodeHooks[t.payload.type] ? e : {
        ...e,
        NodeHooks: {
          ...e.NodeHooks,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_FROM_PLUGIN":
      let i = !1;
      const a = [
        [t.payload.plugin.input_renderers || {}, e.Inputrenderer],
        [t.payload.plugin.output_renderers || {}, e.Outputrenderer],
        [
          t.payload.plugin.handle_preview_renderers || {},
          e.HandlePreviewRenderer
        ],
        [
          t.payload.plugin.data_overlay_renderers || {},
          e.DataOverlayRenderer
        ],
        [
          t.payload.plugin.data_preview_renderers || {},
          e.DataPreviewViewRenderer
        ],
        [
          t.payload.plugin.data_view_renderers || {},
          e.DataViewRenderer
        ],
        [
          t.payload.plugin.node_context_extenders || {},
          e.NodeContextExtenders
        ],
        [t.payload.plugin.node_renderers || {}, e.NodeRenderer],
        [t.payload.plugin.node_hooks || {}, e.NodeHooks]
      ];
      for (const [u, f] of a) {
        if (Object.keys(u).length > 0) {
          if (r)
            i = !0;
          else
            for (const d in u)
              if (!f[d]) {
                i = !0;
                break;
              }
        }
        if (i) break;
      }
      if (!i)
        return e;
      for (const [u, f] of a)
        for (const d in u)
          (r || !f[d]) && (f[d] = u[d]);
      return { ...e };
    default:
      return e;
  }
}, _le = ({
  children: e,
  plugins: t,
  fnrf_zst: n
}) => {
  const [r, i] = C.useReducer(
    Sle,
    kr
  ), a = (x, E, S) => {
    i({
      type: "EXTEND_INPUT_RENDER",
      payload: { type: x, component: E },
      options: S
    });
  }, s = (x, E, S) => {
    i({
      type: "EXTEND_OUTPUT_RENDER",
      payload: { type: x, component: E },
      options: S
    });
  }, u = (x, E, S) => {
    i({
      type: "EXTEND_HANDLE_PREVIEW_RENDER",
      payload: { type: x, component: E },
      options: S
    });
  }, f = (x, E, S) => {
    i({
      type: "EXTEND_DATA_OVERLAY_RENDER",
      payload: { type: x, component: E },
      options: S
    });
  }, d = (x, E, S) => {
    i({
      type: "EXTEND_DATA_PREVIEW_RENDER",
      payload: { type: x, component: E },
      options: S
    });
  }, h = (x, E, S) => {
    i({
      type: "EXTEND_DATA_VIEW_RENDER",
      payload: { type: x, component: E },
      options: S
    });
  }, p = (x, E, S) => {
    i({
      type: "EXTEND_NODE_CONTEXT_EXTENDER",
      payload: { type: x, component: E },
      options: S
    });
  }, g = (x, E, S) => {
    i({
      type: "EXTEND_NODE_RENDERER",
      payload: { type: x, component: E },
      options: S
    });
  }, y = (x, E, S) => {
    i({
      type: "EXTEND_NODE_HOOKS",
      payload: { type: x, component: E },
      options: S
    });
  }, b = (x, E) => {
    i({
      type: "EXTEND_FROM_PLUGIN",
      payload: { plugin: x },
      options: E
    });
  };
  return C.useEffect(() => {
    for (const x in t) {
      const E = t[x];
      if (!E) continue;
      const S = E.renderpluginfactory;
      S && b(S({ React: gh, fnrf_zst: n, NodeContext: E4 }));
    }
  }, [t]), /* @__PURE__ */ _.jsx(
    Ji.Provider,
    {
      value: {
        Inputrenderer: r.Inputrenderer,
        Outputrenderer: r.Outputrenderer,
        HandlePreviewRenderer: r.HandlePreviewRenderer,
        DataOverlayRenderer: r.DataOverlayRenderer,
        DataPreviewViewRenderer: r.DataPreviewViewRenderer,
        DataViewRenderer: r.DataViewRenderer,
        InLineRenderer: r.InLineRenderer,
        NodeContextExtenders: r.NodeContextExtenders,
        NodeRenderer: r.NodeRenderer,
        NodeHooks: r.NodeHooks,
        extendInputRenderMapping: a,
        extendOutputRenderMapping: s,
        extendHandlePreviewRenderMapping: u,
        extendDataOverlayRenderMapping: f,
        extendDataPreviewRenderMapping: d,
        extendDataViewRenderMapping: h,
        extendNodeContextExtender: p,
        extendNodeRenderer: g,
        extendNodeHooks: y,
        extendFromPlugin: b
      },
      children: e
    }
  );
}, Ji = C.createContext({
  Inputrenderer: kr.Inputrenderer,
  Outputrenderer: kr.Outputrenderer,
  HandlePreviewRenderer: kr.HandlePreviewRenderer,
  DataOverlayRenderer: kr.DataOverlayRenderer,
  DataPreviewViewRenderer: kr.DataPreviewViewRenderer,
  DataViewRenderer: kr.DataViewRenderer,
  InLineRenderer: kr.InLineRenderer,
  NodeContextExtenders: kr.NodeContextExtenders,
  NodeRenderer: kr.NodeRenderer,
  NodeHooks: kr.NodeHooks,
  extendInputRenderMapping: (e, t, n) => {
  },
  extendOutputRenderMapping: (e, t, n) => {
  },
  extendHandlePreviewRenderMapping: (e, t, n) => {
  },
  extendDataOverlayRenderMapping: (e, t, n) => {
  },
  extendDataPreviewRenderMapping: (e, t, n) => {
  },
  extendDataViewRenderMapping: (e, t, n) => {
  },
  extendNodeContextExtender: (e, t, n) => {
  },
  extendNodeRenderer: (e, t, n) => {
  },
  extendNodeHooks: (e, t, n) => {
  },
  extendFromPlugin: (e, t) => {
  }
}), x4 = (e) => {
  const t = C.useContext(Xe), { DataOverlayRenderer: n, DataViewRenderer: r } = C.useContext(Ji);
  if (e === void 0) return;
  const i = t.render_options(), [a] = Ha(e.type, i.typemap || {});
  return a ? n[a] ? n[a] : r[a] ? b4(r[a]) : bT : bT;
}, Ele = (e) => {
  const n = C.useContext(Xe).render_options(), { HandlePreviewRenderer: r, DataPreviewViewRenderer: i } = C.useContext(Ji), a = x4(e);
  let s;
  if (e) {
    const [u] = Ha(e.type, n.typemap || {});
    u ? r[u] ? s = r[u] : i[u] ? s = i[u] : s = Tr(Wh) : s = Tr(Wh);
  }
  return [s, a];
}, w4 = ({
  iostore: e,
  Component: t
}) => {
  const [n, r] = C.useState(void 0), [i, a] = C.useState(void 0), { full: s } = e.valuestore();
  C.useEffect(() => {
    s === void 0 ? e.getState().try_get_full_value() : a(s.value);
  }, [s]);
  const u = () => {
    i !== void 0 && r(i);
  };
  return /* @__PURE__ */ _.jsx(
    t,
    {
      iostore: e,
      value: i,
      preValue: n,
      onLoaded: u
    }
  );
}, S4 = ({
  iostore: e,
  Component: t
}) => /* @__PURE__ */ _.jsx(t, { iostore: e }), Ha = (e, t) => {
  if (typeof e == "string")
    return e in t ? [t[e], e] : [e, e];
  if ("allOf" in e && e.allOf !== void 0)
    return [void 0, void 0];
  if ("anyOf" in e && e.anyOf !== void 0) {
    const n = e.anyOf.map((r) => Ha(r, t));
    for (const r of n)
      switch (r[0]) {
        case "bool":
          return ["bool", r[1]];
        case "enum":
          return ["enum", r[1]];
        case "float":
          return ["float", r[1]];
        case "int":
          return ["int", r[1]];
        case "string":
          return ["string", r[1]];
        case "str":
          return ["string", r[1]];
      }
    return [void 0, void 0];
  }
  return !("type" in e) || e.type === void 0 ? [void 0, void 0] : e.type === "enum" ? ["enum", "enum"] : [void 0, void 0];
}, lb = ({
  iostore: e,
  typestring: t,
  preview: n,
  ...r
}) => {
  const [i, a] = C.useState(!1), [s, u] = C.useState(!1), f = C.useContext(Xe), d = e.use(), [h, p] = Ele(d), g = f.local_state(() => f.reactflowRef);
  return (
    // <Tooltip.Provider>
    /* @__PURE__ */ _.jsxs(L3, { open: i || s, onOpenChange: u, children: [
      /* @__PURE__ */ _.jsx(F3, { asChild: !0, children: /* @__PURE__ */ _.jsx(dc, { id: d.id, "data-type": t, ...r }) }),
      /* @__PURE__ */ _.jsx(B3, { container: g, children: /* @__PURE__ */ _.jsxs($3, { className: "iotooltipcontent", sideOffset: 5, children: [
        /* @__PURE__ */ _.jsxs("div", { className: "iotooltip_container", children: [
          /* @__PURE__ */ _.jsxs("div", { className: "iotooltip_header", children: [
            i ? /* @__PURE__ */ _.jsx(dU, { onClick: () => a(!1) }) : /* @__PURE__ */ _.jsx(fU, { onClick: () => a(!0) }),
            p && /* @__PURE__ */ _.jsx(
              bl,
              {
                title: d.full_id,
                trigger: /* @__PURE__ */ _.jsx(e2, {}),
                onOpenChange: (y) => {
                  y && d.try_get_full_value && d.try_get_full_value(), a(y);
                },
                children: /* @__PURE__ */ _.jsx(
                  w4,
                  {
                    Component: p,
                    iostore: e
                  }
                )
              }
            )
          ] }),
          h ? /* @__PURE__ */ _.jsx(S4, { Component: h, iostore: e }) : `no preview available for "${t}"`
        ] }),
        /* @__PURE__ */ _.jsx(GJ, { className: "iotooltipcontentarrow" })
      ] }) })
    ] })
  );
}, tp = {
  "": [(e) => e, (e) => e],
  str_to_json: [
    (e) => JSON.parse(e),
    (e) => typeof e == "string" ? e : JSON.stringify(e)
  ],
  str_to_list: [
    (e) => {
      try {
        const t = JSON.parse(e);
        return Array.isArray(t) ? t : [t];
      } catch {
        try {
          return JSON.parse("[" + e + "]");
        } catch {
        }
      }
      throw new Error("Invalid list");
    },
    (e) => JSON.stringify(e)
  ]
}, Cle = ({ iostore: e }) => {
  const n = C.useContext(Xe).render_options(), r = e.use(), [i, a] = Ha(
    r.render_options.type,
    n.typemap || {}
  ), { Inputrenderer: s } = C.useContext(Ji), u = i ? r.value_options?.options ? ep : s[i] : void 0, f = tp[(a && n.inputconverter?.[a]) ?? ""] || tp[""];
  return r.hidden ? null : /* @__PURE__ */ _.jsxs("div", { className: "nodeinput", "data-type": i, children: [
    /* @__PURE__ */ _.jsx(
      lb,
      {
        iostore: e,
        typestring: i,
        position: _e.Left,
        type: "target"
      }
    ),
    u && /* @__PURE__ */ _.jsx("div", { className: "iovaluefield nodrag", "data-type": i, children: /* @__PURE__ */ _.jsx(u, { iostore: e, inputconverter: f }) }),
    /* @__PURE__ */ _.jsx("div", { className: "ioname", children: r.name }),
    /* @__PURE__ */ _.jsx(
      lb,
      {
        iostore: e,
        typestring: i,
        position: _e.Right,
        type: "source"
      }
    )
  ] });
}, kle = ({ iostore: e }) => {
  const n = C.useContext(Xe).render_options(), r = e.use(), [i] = Ha(r.type, n.typemap || {}), { Outputrenderer: a } = C.useContext(Ji), s = i ? a[i] : void 0;
  return r.hidden ? null : /* @__PURE__ */ _.jsxs("div", { className: "nodeoutput", "data-type": i, children: [
    /* @__PURE__ */ _.jsx(
      lb,
      {
        iostore: e,
        typestring: i,
        position: _e.Right,
        type: "source"
      }
    ),
    /* @__PURE__ */ _.jsx("div", { className: "ioname", children: r.name }),
    s ? /* @__PURE__ */ _.jsx("div", { className: "iovaluefield nodrag", children: /* @__PURE__ */ _.jsx(s, { iostore: e }) }) : /* @__PURE__ */ _.jsx("div", { className: "iovaluefield", children: /* @__PURE__ */ _.jsx(ple, { iostore: e, typestring: i }) })
  ] });
}, Ale = (e) => {
  const t = C.useContext(Xe), n = x4(e), { DataPreviewViewRenderer: r, DataViewRenderer: i } = C.useContext(Ji), a = t.render_options();
  if (e === void 0) return [void 0, n];
  const [s] = Ha(e.type, a.typemap || {});
  return s ? r[s] ? [r[s], n] : i[s] ? [
    Tr(i[s]),
    n
  ] : [
    Tr(Wh),
    n
  ] : [
    Tr(Wh),
    n
  ];
};
function Tle(e, t, n = {}) {
  const {
    maxFontSize: r = 100,
    // default maximum font size
    minFontSize: i = 6,
    // default minimum font size
    decrementFactor: a = 0.9
    // font size decrement step
  } = n;
  if (!e || !t)
    return;
  if (a >= 1 || a <= 0)
    throw new Error("decrementFactor must be between 0 and 1");
  const s = e.getBoundingClientRect(), u = s.width, f = s.height;
  let d = r;
  t.style.whiteSpace = "nowrap", t.style.display = "inline-block", t.style.fontSize = d + "px";
  let h = t.getBoundingClientRect();
  for (; (h.width > u || h.height > f) && d > i; )
    d *= a, t.style.fontSize = d + "px", h = t.getBoundingClientRect();
}
function Rle(e = {
  n: 0,
  elapsed: 0,
  ascii: !1,
  unit: "it",
  unit_scale: !1,
  unit_divisor: 1e3
}) {
  let t = e.total ?? null;
  const {
    n,
    unit_scale: r,
    elapsed: i,
    // ascii,
    unit: a,
    unit_divisor: s,
    // ncols = undefined,
    prefix: u = "",
    rate: f = void 0,
    // bar_format = undefined,
    postfix: d = null,
    initial: h = 0
    // colour = undefined,
  } = e;
  t !== null && n >= t + 0.5 && (t = null);
  let p = n, g = t, y = f;
  r && r !== !0 && r !== 1 && (t !== null && (g = t * r), p = n * r, f !== void 0 && (y = f * r));
  const b = xT(i);
  y === void 0 && i > 0 && (y = (p - h) / i);
  const x = y ? 1 / y : void 0, [E, S] = y ? Wd(y, s) : [void 0, ""], [A, k] = x ? Wd(x, 1e3) : [void 0, ""], R = (E || "?") + `${S}${a}/s`, N = A ? `${A}${k}s/` + a : "?", D = x && x > 1 ? N : R, P = r ? Wd(p, s).join("") : p.toString(), F = r && g !== null ? Wd(g, s).join("") : g?.toString() ?? "?", V = y && g !== null ? (g - p) / y : 0, T = y ? xT(V) : "?", $ = u ? `${u}: ` : "";
  if (t !== null) {
    const H = p / t * 100, G = ` ${P}/${F} [${b} < ${T}, ${D}${d ?? ""}]`;
    return `${$}${H.toFixed(0)}%${G}`;
  }
  return `${$}${P}${a} [${b}, ${D}${d ?? ""}]`;
}
function xT(e) {
  const t = Math.floor(e / 60), n = Math.floor(e % 60);
  return `${t}:${n.toString().padStart(2, "0")}`;
}
function Wd(e, t) {
  const n = ["", "K", "M", "G", "T"];
  let r = 0;
  for (; e >= t && r < n.length - 1; )
    e /= t, r++;
  return [e.toFixed(2), n[r]];
}
const Ole = ({ state: e, className: t = "reacttqdm", ...n }) => {
  const r = C.useRef(null), i = C.useRef(null);
  C.useEffect(() => {
    const s = () => {
      !r.current || !i.current || Tle(r.current, i.current, {
        maxFontSize: 12,
        decrementFactor: 0.9
      });
    };
    return s(), window.addEventListener("resize", s), () => {
      window.removeEventListener("resize", s);
    };
  }, [e]);
  const a = e.total ? e.n / e.total * 100 : 0;
  return /* @__PURE__ */ _.jsx("div", { ref: r, className: t, ...n, children: /* @__PURE__ */ _.jsxs(
    "div",
    {
      style: {
        position: "relative",
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center"
      },
      children: [
        /* @__PURE__ */ _.jsx(
          "div",
          {
            className: t + "-bar",
            style: {
              position: "absolute",
              width: "100%",
              height: "100%",
              // Adjust height if needed
              overflow: "hidden"
            },
            children: /* @__PURE__ */ _.jsx(
              "div",
              {
                className: t + "-progress",
                style: {
                  width: `${a}%`,
                  height: "100%"
                }
              }
            )
          }
        ),
        /* @__PURE__ */ _.jsx("div", { className: t + "-text", ref: i, children: Rle(e) })
      ]
    }
  ) });
}, Nle = C.memo(({ node_data: e }) => {
  const t = C.useContext(Xe), n = () => {
    t.on_node_action({
      type: "trigger",
      from_remote: !1,
      id: e.id
    });
  };
  return /* @__PURE__ */ _.jsxs(
    "div",
    {
      className: "nodeheader",
      title: e.description || e.node_name,
      children: [
        /* @__PURE__ */ _.jsxs("div", { className: "nodeheader_element", children: [
          /* @__PURE__ */ _.jsx(
            pU,
            {
              fontSize: "inherit",
              className: "triggerbutton",
              onClick: n
            }
          ),
          /* @__PURE__ */ _.jsx(
            hU,
            {
              fontSize: "inherit",
              onClick: async () => {
                console.log(
                  "nodestatus",
                  await t.worker?.get_node_status(e.id)
                );
              }
            }
          )
        ] }),
        /* @__PURE__ */ _.jsx("div", { className: "nodeheader_element nodeheader_title", children: /* @__PURE__ */ _.jsx("div", { className: "nodeheader_title_text", children: e.node_name }) }),
        /* @__PURE__ */ _.jsx("div", { className: "nodeheader_element", children: /* @__PURE__ */ _.jsx($c, { fontSize: "inherit" }) })
      ]
    }
  );
}), Mle = ({
  iostore: e,
  node_data: t
}) => {
  const n = e.use(), [r, i] = Ale(n);
  return /* @__PURE__ */ _.jsx(
    "div",
    {
      className: "nodrag nodedatabody",
      "data-src": t.render_options?.data?.src || "",
      children: r && n && /* @__PURE__ */ _.jsx(
        bl,
        {
          title: n.full_id,
          trigger: /* @__PURE__ */ _.jsx("div", { className: "nodedatabutton", children: /* @__PURE__ */ _.jsx(S4, { Component: r, iostore: e }) }),
          onOpenChange: (a) => {
            a && n?.try_get_full_value && n?.try_get_full_value();
          },
          children: i && /* @__PURE__ */ _.jsx(w4, { Component: i, iostore: e })
        }
      )
    }
  );
}, Dle = C.memo(({ node_data: e }) => {
  const t = e.render_options?.data?.src ? e.io[e.render_options?.data?.src] : void 0;
  return /* @__PURE__ */ _.jsxs("div", { className: "nodebody", children: [
    e.outputs.map((n) => /* @__PURE__ */ _.jsx(kle, { iostore: e.io[n] }, n)),
    t && /* @__PURE__ */ _.jsx(Mle, { node_data: e, iostore: t }),
    e.inputs.map((n) => /* @__PURE__ */ _.jsx(Cle, { iostore: e.io[n] }, n))
  ] });
}), _4 = C.memo(({ node_data: e }) => {
  const [t, n] = C.useState(e.name);
  C.useEffect(() => {
    n(e.name);
  }, [e]);
  const r = C.useContext(Xe), i = (s) => {
    n(s.target.value);
  }, a = (s) => {
    const u = s.target.value;
    r.on_node_action({
      type: "update",
      from_remote: !1,
      id: e.id,
      node: { name: u }
    });
  };
  return /* @__PURE__ */ _.jsx(
    "input",
    {
      className: "nodename_input",
      value: t,
      onChange: i,
      onBlur: a
    }
  );
}), Ple = ({ node_data: e }) => {
  if (!e.progress) return null;
  const t = e.progress();
  return /* @__PURE__ */ _.jsx(
    Ole,
    {
      state: t,
      className: "nodeprogress"
    }
  );
}, zle = C.memo(
  ({ node_data: e }) => /* @__PURE__ */ _.jsxs("div", { className: "nodefooter", children: [
    e.error && /* @__PURE__ */ _.jsx("div", { className: "nodeerror", children: e.error }),
    /* @__PURE__ */ _.jsx(Ple, { node_data: e })
  ] })
), jle = (e) => {
  const t = C.useContext(Xe), [n, r] = C.useState(!1), i = e.in_trigger(), a = C.useContext(Ji), s = a.NodeContextExtenders[e.node_id], u = C.useMemo(
    () => s?.({ node_data: e }) || {},
    [s, e]
  ), f = C.useMemo(
    () => ({ ...u, node_data: e }),
    [u, e]
  ), d = a.NodeHooks[e.node_id];
  for (const h of d || [])
    h({ nodecontext: f });
  return C.useEffect(() => {
    t.worker?.call_hooks("node_mounted", e.id);
  }, [t.worker, e.id]), C.useEffect(() => {
    let h;
    return i && !n ? r(!0) : n && (h = setTimeout(() => r(!1), 200)), () => clearTimeout(h);
  }, [i, n]), { visualTrigger: n, nodecontext: f };
}, E4 = C.createContext(null), Ile = ({ data: e }) => {
  const t = e.nodestore.use(), n = t.properties["frontend:collapsed"] || !1, { visualTrigger: r, nodecontext: i } = jle(t);
  return /* @__PURE__ */ _.jsx(E4.Provider, { value: i, children: /* @__PURE__ */ _.jsxs(
    "div",
    {
      className: "innernode" + (r ? " intrigger" : "") + (t.error ? " error" : ""),
      children: [
        /* @__PURE__ */ _.jsx(Nle, { node_data: t }),
        /* @__PURE__ */ _.jsx(_4, { node_data: t }),
        n ? null : /* @__PURE__ */ _.jsx(Dle, { node_data: t }),
        /* @__PURE__ */ _.jsx(zle, { node_data: t })
      ]
    }
  ) });
}, Lle = ({ iostore: e }) => {
  const n = C.useContext(Xe).render_options(), r = e.use(), [i, a] = Ha(
    r.render_options.type,
    n.typemap || {}
  ), { Inputrenderer: s } = C.useContext(Ji), u = i ? r.value_options?.options ? ep : s[i] : void 0, f = tp[(a && n.inputconverter?.[a]) ?? ""] || tp[""];
  return /* @__PURE__ */ _.jsxs("div", { className: "nodesettings_component", children: [
    /* @__PURE__ */ _.jsx("div", { children: r.name }),
    u && /* @__PURE__ */ _.jsx(u, { iostore: e, inputconverter: f }),
    /* @__PURE__ */ _.jsx("div", { children: /* @__PURE__ */ _.jsxs("label", { children: [
      "hidden:",
      /* @__PURE__ */ _.jsx(
        "input",
        {
          className: "styledcheckbox",
          type: "checkbox",
          disabled: r.connected,
          onChange: (d) => {
            r.set_hidden?.(d.target.checked);
          },
          checked: r.hidden
        }
      )
    ] }) })
  ] });
}, Fle = ({ iostore: e }) => {
  const t = e.use();
  return /* @__PURE__ */ _.jsxs("div", { className: "nodesettings_component", children: [
    /* @__PURE__ */ _.jsx("div", { children: t.name }),
    /* @__PURE__ */ _.jsx("div", { children: /* @__PURE__ */ _.jsxs("label", { children: [
      "hidden:",
      /* @__PURE__ */ _.jsx(
        "input",
        {
          className: "styledcheckbox",
          type: "checkbox",
          disabled: t.connected,
          onChange: (n) => {
            t.set_hidden?.(n.target.checked);
          },
          checked: t.hidden
        }
      )
    ] }) })
  ] });
}, Ble = ({
  nodestore: e
}) => {
  const t = e.use();
  return /* @__PURE__ */ _.jsxs("div", { className: "nodesettings_content", children: [
    /* @__PURE__ */ _.jsx("div", { className: "nodesettings_section", children: /* @__PURE__ */ _.jsxs("div", { className: "nodesettings_component", children: [
      /* @__PURE__ */ _.jsx("div", { children: "Name" }),
      /* @__PURE__ */ _.jsx("div", { children: /* @__PURE__ */ _.jsx(_4, { node_data: t }) })
    ] }) }),
    /* @__PURE__ */ _.jsxs("div", { className: "nodesettings_section", children: [
      /* @__PURE__ */ _.jsx("div", { children: "Inputs" }),
      t.inputs.map((n) => /* @__PURE__ */ _.jsx(Lle, { iostore: t.io[n] }, n))
    ] }),
    /* @__PURE__ */ _.jsxs("div", { className: "nodesettings_section", children: [
      /* @__PURE__ */ _.jsx("div", { children: "Outputs" }),
      t.outputs.map((n) => /* @__PURE__ */ _.jsx(Fle, { iostore: t.io[n] }, n))
    ] })
  ] });
}, $le = () => {
  const e = C.useContext(Xe), t = e.local_state((r) => r.selected_nodes);
  if (t.length === 0)
    return /* @__PURE__ */ _.jsx("div", { children: "Node Settings" });
  if (t.length > 1)
    return /* @__PURE__ */ _.jsx("div", { children: "Multiple Nodes Selected" });
  const n = e.nodespace.get_node(t[0]);
  return n ? /* @__PURE__ */ _.jsx(Ble, { nodestore: n }) : /* @__PURE__ */ _.jsx("div", { children: "Node not found" });
}, Hle = () => {
  const e = C.useContext(Xe), t = e.local_settings(
    (i) => i.view_settings.expand_node_props
  ), n = e.local_settings(
    (i) => i.update_view_settings
  ), r = (i) => {
    n({ expand_node_props: i });
  };
  return /* @__PURE__ */ _.jsx(
    bM,
    {
      direction: "left",
      expanded: t === void 0 ? !1 : t,
      containerClassName: "pos-right pos-top bg1 h-12",
      className: "nodesettings_content",
      onExpandChange: r,
      children: /* @__PURE__ */ _.jsx($le, {})
    }
  );
}, Vle = ({
  id: e,
  sourceX: t,
  sourceY: n,
  targetX: r,
  targetY: i,
  sourcePosition: a,
  targetPosition: s,
  data: u,
  ...f
}) => {
  const [d] = xb({
    sourceX: t,
    sourceY: n,
    sourcePosition: a,
    targetX: r,
    targetY: i,
    targetPosition: s
  });
  return /* @__PURE__ */ _.jsx(_.Fragment, { children: /* @__PURE__ */ _.jsx(jc, { id: e, path: d, ...f }) });
}, Ule = (e) => ({
  nodes: e.nodes,
  edges: e.edges,
  onNodesChange: e.onNodesChange,
  onEdgesChange: e.onEdgesChange,
  onConnect: e.onConnect
}), qle = { default: Ile }, Yle = {
  default: Vle
}, Gle = () => {
  const e = zc(), t = C.useContext(Xe);
  return t.rf_instance = e, /* @__PURE__ */ _.jsx(_.Fragment, {});
}, Xle = () => {
  const e = C.useContext(Xe), t = al("Delete"), n = A9(), r = C9();
  if (t) {
    for (const i of n)
      if (i.selected) {
        if (!e.worker) return /* @__PURE__ */ _.jsx(_.Fragment, {});
        if (!i.source || !i.target) return /* @__PURE__ */ _.jsx(_.Fragment, {});
        if (!i.sourceHandle || !i.targetHandle) return /* @__PURE__ */ _.jsx(_.Fragment, {});
        e.worker.remove_edge({
          src_nid: i.source,
          src_ioid: i.sourceHandle,
          trg_nid: i.target,
          trg_ioid: i.targetHandle
        });
      }
    for (const i of r)
      if (i.selected) {
        if (!e.worker) return /* @__PURE__ */ _.jsx(_.Fragment, {});
        e.worker.remove_node(i.id);
      }
  }
  return /* @__PURE__ */ _.jsx(_.Fragment, {});
}, Wle = ({
  id: e,
  top: t,
  left: n,
  right: r,
  bottom: i,
  ...a
}) => {
  const { getNode: s, setNodes: u, addNodes: f, setEdges: d } = zc(), h = C.useContext(Xe), p = C.useCallback(() => {
    const x = s(e);
    if (!x) return;
    const E = {
      x: x.position.x + 50,
      y: x.position.y + 50
    };
    f({ ...x, id: `${x.id}-copy`, position: E });
  }, [e, s, f]), g = C.useCallback(() => {
    h.on_node_action({ type: "delete", id: e, from_remote: !1 });
  }, [e, u, d]), y = h.nodespace.get_node(e, !1);
  if (!y) return /* @__PURE__ */ _.jsx(_.Fragment, { children: " " });
  const b = y.use();
  return /* @__PURE__ */ _.jsxs(
    "div",
    {
      style: { top: t, left: n, right: r, bottom: i },
      className: "context-menu",
      ...a,
      children: [
        /* @__PURE__ */ _.jsx("p", { style: { fontWeight: "bold" }, children: /* @__PURE__ */ _.jsx("small", { children: b.name }) }),
        /* @__PURE__ */ _.jsx("button", { onClick: p, children: "duplicate" }),
        /* @__PURE__ */ _.jsx("button", { onClick: g, children: "delete" })
      ]
    }
  );
}, Kle = (e) => {
  const t = C.useContext(Xe), n = C.useRef(null);
  C.useEffect(() => {
    t.reactflowRef = n.current;
  }, [n]);
  const [r, i] = C.useState(null), a = ({
    nodes: g,
    edges: y
  }) => {
    const b = t.local_state.getState();
    t.local_state.setState({
      ...b,
      selected_nodes: g.map((x) => x.id),
      selected_edges: y.map((x) => x.id)
    });
  }, s = C.useCallback(() => i(null), [i]), { nodes: u, edges: f, onNodesChange: d, onEdgesChange: h, onConnect: p } = t.useReactFlowStore(IJ(Ule));
  return /* @__PURE__ */ _.jsx("div", { className: "reactflowlayer", children: /* @__PURE__ */ _.jsxs(
    _9,
    {
      nodes: u,
      edges: f,
      onNodesChange: d,
      onEdgesChange: h,
      onConnect: p,
      nodeTypes: qle,
      edgeTypes: Yle,
      minZoom: e.minZoom,
      maxZoom: e.maxZoom,
      fitView: !0,
      onSelectionChange: a,
      ref: n,
      onPaneClick: s,
      panOnDrag: !e.static,
      children: [
        /* @__PURE__ */ _.jsx(Gle, {}),
        /* @__PURE__ */ _.jsx(Xle, {}),
        /* @__PURE__ */ _.jsx(
          M9,
          {
            color: "#888",
            gap: 16,
            size: 1
          }
        ),
        e.minimap && /* @__PURE__ */ _.jsx(
          Z9,
          {
            nodeStrokeWidth: 3,
            pannable: !e.static,
            zoomable: !e.static,
            zoomStep: 3
          }
        ),
        r && /* @__PURE__ */ _.jsx(Wle, { onClick: s, ...r })
      ]
    }
  ) });
}, um = C.createContext(
  void 0
), Ea = C.forwardRef((e, t) => {
  const { asChild: n, children: r, className: i, style: a, ...s } = e, [u, f] = C.useState(!1), d = C.useRef(null), [h, p] = C.useState(null), [g, y] = C.useState({}), b = e.htime || 300, x = e.vtime || 300, E = e.hdelay || 0, S = e.vdelay || 200;
  C.useImperativeHandle(t, () => d.current, []);
  const A = async () => {
    if (!d.current) return;
    d.current.style.transition = "none", d.current.style.position = "", d.current.style.top = "", d.current.style.left = "", d.current.style.width = "", d.current.style.height = "";
    const P = d.current.getBoundingClientRect();
    p([P.left, P.top, P.width, P.height]), d.current.style.transition = "none", y({
      position: "absolute",
      top: `${P.top}px`,
      left: `${P.left}px`,
      width: `${P.width}px`,
      height: `${P.height}px`
    }), y((H) => ({
      ...H,
      transitionProperty: "width, left, height, top",
      transitionDuration: `${b}ms, ${b}ms, ${x}ms, ${x}ms`
    })), f(!0);
    const F = new Promise((H) => {
      setTimeout(() => {
        y((G) => ({
          ...G,
          left: "0px",
          width: "100vw"
        })), H();
      }, E);
    }), V = new Promise((H) => {
      setTimeout(() => {
        y((G) => ({
          ...G,
          top: "0px",
          height: "100vh"
        })), H();
      }, S);
    }), T = Math.max(b + E, x + S), $ = new Promise((H) => {
      setTimeout(() => {
        H();
      }, T);
    });
    await Promise.all([F, V, $]);
  }, k = async () => {
    if (!d.current || !h) return;
    const P = {
      transitionProperty: "width, left, height, top",
      transitionDuration: `${b}ms, ${b}ms, ${x}ms, ${x}ms`
    };
    y((z) => ({
      ...z,
      ...P
    }));
    const [F, V, T, $] = h, H = new Promise((z) => {
      setTimeout(() => {
        y((B) => ({
          ...B,
          left: `${F}px`,
          width: `${T}px`
        })), z();
      }, S);
    }), G = new Promise((z) => {
      setTimeout(() => {
        y((B) => ({
          ...B,
          top: `${V}px`,
          height: `${$}px`
        })), z();
      }, E);
    }), j = Math.max(b + E, x + S), U = new Promise((z) => {
      setTimeout(() => {
        z();
      }, j);
    });
    await Promise.all([H, G, U]), d.current.style.transition = "", y({}), f(!1);
  }, R = async () => {
    d.current && (u ? await k() : await A());
  };
  let N;
  if (n && C.isValidElement(r)) {
    const P = r, F = [
      P.props.className,
      i,
      "smooth-expand",
      u ? "smooth-expand-expanded" : ""
    ].filter(Boolean).join(" "), V = {
      ...P.props.style,
      ...a,
      ...g
    };
    N = C.cloneElement(P, {
      ref: d,
      className: F,
      style: V,
      ...s
    });
  } else
    N = /* @__PURE__ */ _.jsx(
      "div",
      {
        ref: d,
        ...s,
        className: `smooth-expand ${u ? "smooth-expand-expanded" : ""} ${i || ""}`,
        style: { ...a, ...g },
        children: r
      }
    );
  const D = /* @__PURE__ */ _.jsx(um.Provider, { value: { isExpanded: u, toggleExpand: R }, children: N });
  return u ? Pc.createPortal(D, document.body) : D;
});
Ea.Trigger = function({
  children: e
}) {
  const t = C.useContext(um);
  if (!t)
    throw new Error(
      "SmoothExpandComponent.Trigger must be used within a SmoothExpandComponent"
    );
  return /* @__PURE__ */ _.jsx("div", { style: { cursor: "pointer" }, onClick: t.toggleExpand, children: e });
};
Ea.Expanded = function({
  children: e
}) {
  const t = C.useContext(um);
  if (!t)
    throw new Error(
      "SmoothExpandComponent.Expanded must be used within a SmoothExpandComponent"
    );
  return t.isExpanded ? /* @__PURE__ */ _.jsx(_.Fragment, { children: e }) : null;
};
Ea.Collapsed = function({
  children: e
}) {
  const t = C.useContext(um);
  if (!t)
    throw new Error(
      "SmoothExpandComponent.Collapsed must be used within a SmoothExpandComponent"
    );
  return t.isExpanded ? null : /* @__PURE__ */ _.jsx(_.Fragment, { children: e });
};
const cm = C.createContext(void 0), Io = C.forwardRef((e, t) => {
  const { asChild: n, children: r, className: i, style: a, ...s } = e, u = C.useRef(null);
  C.useImperativeHandle(
    t,
    () => u.current,
    []
  );
  const [f, d] = C.useState(!1), h = C.useCallback(async () => {
    try {
      const g = u.current;
      if (!g) return;
      if (!f)
        g.requestFullscreen ? await g.requestFullscreen() : g.mozRequestFullScreen ? await g.mozRequestFullScreen() : g.webkitRequestFullscreen ? await g.webkitRequestFullscreen() : g.msRequestFullscreen && await g.msRequestFullscreen(), d(!0);
      else {
        const y = document;
        y.exitFullscreen ? await y.exitFullscreen() : y.mozCancelFullScreen ? await y.mozCancelFullScreen() : y.webkitExitFullscreen ? await y.webkitExitFullscreen() : y.msExitFullscreen && await y.msExitFullscreen(), d(!1);
      }
    } catch (g) {
      console.error("Error toggling fullscreen", g);
    }
  }, [f]);
  C.useEffect(() => {
    const g = () => {
      const y = document.fullscreenElement;
      d(!!y);
    };
    return document.addEventListener("fullscreenchange", g), document.addEventListener("webkitfullscreenchange", g), document.addEventListener("mozfullscreenchange", g), document.addEventListener("MSFullscreenChange", g), () => {
      document.removeEventListener("fullscreenchange", g), document.removeEventListener(
        "webkitfullscreenchange",
        g
      ), document.removeEventListener(
        "mozfullscreenchange",
        g
      ), document.removeEventListener(
        "MSFullscreenChange",
        g
      );
    };
  }, []);
  let p;
  if (n && C.isValidElement(r)) {
    const g = r, y = [g.props.className, i].filter(Boolean).join(" "), b = { ...g.props.style, ...a };
    p = C.cloneElement(g, {
      ref: u,
      className: y,
      style: b,
      ...s
    });
  } else
    p = /* @__PURE__ */ _.jsx("div", { ref: u, ...s, className: i, style: a, children: r });
  return /* @__PURE__ */ _.jsx(cm.Provider, { value: { isFullScreen: f, toggleFullscreen: h }, children: p });
});
Io.Trigger = function({
  children: e
}) {
  const t = C.useContext(cm);
  if (!t)
    throw new Error(
      "FullScreenComponent.Trigger must be used within a FullScreenComponent"
    );
  return /* @__PURE__ */ _.jsx("div", { style: { cursor: "pointer" }, onClick: t.toggleFullscreen, children: e });
};
Io.InFullScreen = function({
  children: e
}) {
  const t = C.useContext(cm);
  if (!t)
    throw new Error(
      "FullScreenComponent.Expanded must be used within a FullScreenComponent"
    );
  return t.isFullScreen ? /* @__PURE__ */ _.jsx(_.Fragment, { children: e }) : null;
};
Io.OutFullScreen = function({
  children: e
}) {
  const t = C.useContext(cm);
  if (!t)
    throw new Error(
      "FullScreenComponent.Collapsed must be used within a FullScreenComponent"
    );
  return t.isFullScreen ? null : /* @__PURE__ */ _.jsx(_.Fragment, { children: e });
};
const Zle = ({
  fnrf_zst: e,
  header: t,
  flow: n,
  library: r
}) => {
  const [i, a] = C.useState(
    e.options.worker
  ), s = C.useRef(null);
  e.workermanager && (e.workermanager.on_setWorker = a), e.set_worker(i), C.useEffect(() => {
    e.auto_progress();
  }, []), C.useEffect(() => {
    e.local_state.setState({ funcnodescontainerRef: s.current });
  }, [s]);
  const u = e.plugins();
  return /* @__PURE__ */ _.jsx(_le, { plugins: u, fnrf_zst: e, children: /* @__PURE__ */ _.jsx(Xe.Provider, { value: e, children: /* @__PURE__ */ _.jsx(Ea, { asChild: !0, children: /* @__PURE__ */ _.jsx(Io, { asChild: !0, children: /* @__PURE__ */ _.jsx(
    qY,
    {
      style: {
        height: "100%",
        width: "100%",
        display: "flex",
        flexDirection: "column",
        flex: 1
      },
      children: /* @__PURE__ */ _.jsxs(
        "div",
        {
          ref: s,
          className: "funcnodesreactflowcontainer funcnodescontainer",
          children: [
            t.show && /* @__PURE__ */ _.jsx(eG, { ...t }),
            /* @__PURE__ */ _.jsxs("div", { className: "funcnodesreactflowbody", children: [
              /* @__PURE__ */ _.jsx(Kle, { ...n }),
              i && r.show && /* @__PURE__ */ _.jsx(PJ, {}),
              i && n.showNodeSettings && /* @__PURE__ */ _.jsx(Hle, {})
            ] }),
            /* @__PURE__ */ _.jsxs("div", { className: "funcnodesflaotingmenu", children: [
              /* @__PURE__ */ _.jsx(Io.OutFullScreen, { children: n.allowExpand && /* @__PURE__ */ _.jsxs(Ea.Trigger, { children: [
                /* @__PURE__ */ _.jsx(Ea.Expanded, { children: /* @__PURE__ */ _.jsx(
                  uU,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) }),
                /* @__PURE__ */ _.jsx(Ea.Collapsed, { children: /* @__PURE__ */ _.jsx(
                  cU,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) })
              ] }) }),
              n.allowFullScreen && /* @__PURE__ */ _.jsxs(Io.Trigger, { children: [
                /* @__PURE__ */ _.jsx(Io.OutFullScreen, { children: /* @__PURE__ */ _.jsx(e2, { size: "xl", style: { padding: "4px" } }) }),
                /* @__PURE__ */ _.jsx(Io.InFullScreen, { children: /* @__PURE__ */ _.jsx(
                  lU,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) })
              ] })
            ] })
          ]
        }
      )
    }
  ) }) }) }) });
}, ub = {};
window.fnrf_zst === void 0 && (window.fnrf_zst = ub);
const Qle = {
  show: !0
}, Jle = {
  show: !0,
  showmenu: !0
}, eue = {
  minimap: !0,
  static: !1,
  minZoom: 0.1,
  maxZoom: 5,
  allowFullScreen: !0,
  allowExpand: !0,
  showNodeSettings: !0
}, C4 = {
  id: "",
  // required
  debug: !1,
  useWorkerManager: !0,
  show_library: !0,
  header: Jle,
  flow: eue,
  library: Qle
}, Xe = C.createContext(
  gO(C4)
), tue = (e) => {
  let t = np(e, {
    ...C4,
    id: $O()
  }).new_obj;
  if (!t.useWorkerManager && t.worker === void 0)
    return /* @__PURE__ */ _.jsx("div", { children: "Error: If you don't use a worker manager, you must provide a default worker." });
  if (e.useWorkerManager && e.workermanager_url === void 0)
    return /* @__PURE__ */ _.jsx("div", { children: "Error: If you use a worker manager, you must provide a worker manager url." });
  let n = ub[t.id];
  n === void 0 && (n = gO(t), ub[t.id] = n), n.options.debug = t.debug;
  const [r, i] = C.useState(t);
  return C.useEffect(() => {
    const a = [];
    if (r.worker === void 0 && r.worker_url !== void 0) {
      r.useWorkerManager = !1;
      const s = new HO({
        url: r.worker_url,
        uuid: r.id,
        on_sync_complete: r.on_sync_complete
      });
      r.worker = s, a.push(() => {
        s.disconnect();
      });
    }
    if (r.fnw_url !== void 0) {
      if (r.worker === void 0)
        throw new Error("defining fnw_url requires a worker to be defined");
      const s = QB(r.fnw_url), u = r.worker.on_sync_complete, f = async (d) => {
        const h = await s;
        d.on_sync_complete = u, await d.update_from_export(h);
      };
      r.worker.on_sync_complete = f;
    }
    if (r.worker !== void 0 && r.worker.set_zustand(n), t.useWorkerManager) {
      const s = new UB(
        t.workermanager_url,
        n
      );
      n.workermanager = s, a.push(() => {
        s.remove();
      });
    }
    return i({ ...r }), r.on_ready && typeof r.on_ready == "function" && r.on_ready({ fnrf_zst: n }), () => {
      for (const s of a)
        s();
    };
  }, []), /* @__PURE__ */ _.jsx(
    Zle,
    {
      fnrf_zst: n,
      header: r.header,
      library: r.library,
      flow: r.flow
    }
  );
}, nue = (e) => (new mO("FuncNodes", e.debug ? "debug" : "info").debug("Initalizing FuncNodes with props:", e), /* @__PURE__ */ _.jsx("div", { className: "FuncnodesApp", children: /* @__PURE__ */ _.jsx(tue, { ...e }) }));
var Iy = { exports: {} }, $u = {}, Ly = { exports: {} }, Fy = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wT;
function rue() {
  return wT || (wT = 1, function(e) {
    function t(z, B) {
      var q = z.length;
      z.push(B);
      e: for (; 0 < q; ) {
        var Y = q - 1 >>> 1, O = z[Y];
        if (0 < i(O, B))
          z[Y] = B, z[q] = O, q = Y;
        else break e;
      }
    }
    function n(z) {
      return z.length === 0 ? null : z[0];
    }
    function r(z) {
      if (z.length === 0) return null;
      var B = z[0], q = z.pop();
      if (q !== B) {
        z[0] = q;
        e: for (var Y = 0, O = z.length, W = O >>> 1; Y < W; ) {
          var Z = 2 * (Y + 1) - 1, I = z[Z], ie = Z + 1, fe = z[ie];
          if (0 > i(I, q))
            ie < O && 0 > i(fe, I) ? (z[Y] = fe, z[ie] = q, Y = ie) : (z[Y] = I, z[Z] = q, Y = Z);
          else if (ie < O && 0 > i(fe, q))
            z[Y] = fe, z[ie] = q, Y = ie;
          else break e;
        }
      }
      return B;
    }
    function i(z, B) {
      var q = z.sortIndex - B.sortIndex;
      return q !== 0 ? q : z.id - B.id;
    }
    if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var a = performance;
      e.unstable_now = function() {
        return a.now();
      };
    } else {
      var s = Date, u = s.now();
      e.unstable_now = function() {
        return s.now() - u;
      };
    }
    var f = [], d = [], h = 1, p = null, g = 3, y = !1, b = !1, x = !1, E = !1, S = typeof setTimeout == "function" ? setTimeout : null, A = typeof clearTimeout == "function" ? clearTimeout : null, k = typeof setImmediate < "u" ? setImmediate : null;
    function R(z) {
      for (var B = n(d); B !== null; ) {
        if (B.callback === null) r(d);
        else if (B.startTime <= z)
          r(d), B.sortIndex = B.expirationTime, t(f, B);
        else break;
        B = n(d);
      }
    }
    function N(z) {
      if (x = !1, R(z), !b)
        if (n(f) !== null)
          b = !0, D || (D = !0, H());
        else {
          var B = n(d);
          B !== null && U(N, B.startTime - z);
        }
    }
    var D = !1, P = -1, F = 5, V = -1;
    function T() {
      return E ? !0 : !(e.unstable_now() - V < F);
    }
    function $() {
      if (E = !1, D) {
        var z = e.unstable_now();
        V = z;
        var B = !0;
        try {
          e: {
            b = !1, x && (x = !1, A(P), P = -1), y = !0;
            var q = g;
            try {
              t: {
                for (R(z), p = n(f); p !== null && !(p.expirationTime > z && T()); ) {
                  var Y = p.callback;
                  if (typeof Y == "function") {
                    p.callback = null, g = p.priorityLevel;
                    var O = Y(
                      p.expirationTime <= z
                    );
                    if (z = e.unstable_now(), typeof O == "function") {
                      p.callback = O, R(z), B = !0;
                      break t;
                    }
                    p === n(f) && r(f), R(z);
                  } else r(f);
                  p = n(f);
                }
                if (p !== null) B = !0;
                else {
                  var W = n(d);
                  W !== null && U(
                    N,
                    W.startTime - z
                  ), B = !1;
                }
              }
              break e;
            } finally {
              p = null, g = q, y = !1;
            }
            B = void 0;
          }
        } finally {
          B ? H() : D = !1;
        }
      }
    }
    var H;
    if (typeof k == "function")
      H = function() {
        k($);
      };
    else if (typeof MessageChannel < "u") {
      var G = new MessageChannel(), j = G.port2;
      G.port1.onmessage = $, H = function() {
        j.postMessage(null);
      };
    } else
      H = function() {
        S($, 0);
      };
    function U(z, B) {
      P = S(function() {
        z(e.unstable_now());
      }, B);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(z) {
      z.callback = null;
    }, e.unstable_forceFrameRate = function(z) {
      0 > z || 125 < z ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : F = 0 < z ? Math.floor(1e3 / z) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return g;
    }, e.unstable_next = function(z) {
      switch (g) {
        case 1:
        case 2:
        case 3:
          var B = 3;
          break;
        default:
          B = g;
      }
      var q = g;
      g = B;
      try {
        return z();
      } finally {
        g = q;
      }
    }, e.unstable_requestPaint = function() {
      E = !0;
    }, e.unstable_runWithPriority = function(z, B) {
      switch (z) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          z = 3;
      }
      var q = g;
      g = z;
      try {
        return B();
      } finally {
        g = q;
      }
    }, e.unstable_scheduleCallback = function(z, B, q) {
      var Y = e.unstable_now();
      switch (typeof q == "object" && q !== null ? (q = q.delay, q = typeof q == "number" && 0 < q ? Y + q : Y) : q = Y, z) {
        case 1:
          var O = -1;
          break;
        case 2:
          O = 250;
          break;
        case 5:
          O = 1073741823;
          break;
        case 4:
          O = 1e4;
          break;
        default:
          O = 5e3;
      }
      return O = q + O, z = {
        id: h++,
        callback: B,
        priorityLevel: z,
        startTime: q,
        expirationTime: O,
        sortIndex: -1
      }, q > Y ? (z.sortIndex = q, t(d, z), n(f) === null && z === n(d) && (x ? (A(P), P = -1) : x = !0, U(N, q - Y))) : (z.sortIndex = O, t(f, z), b || y || (b = !0, D || (D = !0, H()))), z;
    }, e.unstable_shouldYield = T, e.unstable_wrapCallback = function(z) {
      var B = g;
      return function() {
        var q = g;
        g = B;
        try {
          return z.apply(this, arguments);
        } finally {
          g = q;
        }
      };
    };
  }(Fy)), Fy;
}
var ST;
function iue() {
  return ST || (ST = 1, Ly.exports = rue()), Ly.exports;
}
var _T;
function oue() {
  if (_T) return $u;
  _T = 1;
  /**
   * @license React
   * react-dom-client.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var e = iue(), t = Tc(), n = PR();
  function r(o) {
    var l = "https://react.dev/errors/" + o;
    if (1 < arguments.length) {
      l += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var c = 2; c < arguments.length; c++)
        l += "&args[]=" + encodeURIComponent(arguments[c]);
    }
    return "Minified React error #" + o + "; visit " + l + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function i(o) {
    return !(!o || o.nodeType !== 1 && o.nodeType !== 9 && o.nodeType !== 11);
  }
  function a(o) {
    var l = o, c = o;
    if (o.alternate) for (; l.return; ) l = l.return;
    else {
      o = l;
      do
        l = o, (l.flags & 4098) !== 0 && (c = l.return), o = l.return;
      while (o);
    }
    return l.tag === 3 ? c : null;
  }
  function s(o) {
    if (o.tag === 13) {
      var l = o.memoizedState;
      if (l === null && (o = o.alternate, o !== null && (l = o.memoizedState)), l !== null) return l.dehydrated;
    }
    return null;
  }
  function u(o) {
    if (a(o) !== o)
      throw Error(r(188));
  }
  function f(o) {
    var l = o.alternate;
    if (!l) {
      if (l = a(o), l === null) throw Error(r(188));
      return l !== o ? null : o;
    }
    for (var c = o, m = l; ; ) {
      var v = c.return;
      if (v === null) break;
      var w = v.alternate;
      if (w === null) {
        if (m = v.return, m !== null) {
          c = m;
          continue;
        }
        break;
      }
      if (v.child === w.child) {
        for (w = v.child; w; ) {
          if (w === c) return u(v), o;
          if (w === m) return u(v), l;
          w = w.sibling;
        }
        throw Error(r(188));
      }
      if (c.return !== m.return) c = v, m = w;
      else {
        for (var M = !1, L = v.child; L; ) {
          if (L === c) {
            M = !0, c = v, m = w;
            break;
          }
          if (L === m) {
            M = !0, m = v, c = w;
            break;
          }
          L = L.sibling;
        }
        if (!M) {
          for (L = w.child; L; ) {
            if (L === c) {
              M = !0, c = w, m = v;
              break;
            }
            if (L === m) {
              M = !0, m = w, c = v;
              break;
            }
            L = L.sibling;
          }
          if (!M) throw Error(r(189));
        }
      }
      if (c.alternate !== m) throw Error(r(190));
    }
    if (c.tag !== 3) throw Error(r(188));
    return c.stateNode.current === c ? o : l;
  }
  function d(o) {
    var l = o.tag;
    if (l === 5 || l === 26 || l === 27 || l === 6) return o;
    for (o = o.child; o !== null; ) {
      if (l = d(o), l !== null) return l;
      o = o.sibling;
    }
    return null;
  }
  var h = Object.assign, p = Symbol.for("react.element"), g = Symbol.for("react.transitional.element"), y = Symbol.for("react.portal"), b = Symbol.for("react.fragment"), x = Symbol.for("react.strict_mode"), E = Symbol.for("react.profiler"), S = Symbol.for("react.provider"), A = Symbol.for("react.consumer"), k = Symbol.for("react.context"), R = Symbol.for("react.forward_ref"), N = Symbol.for("react.suspense"), D = Symbol.for("react.suspense_list"), P = Symbol.for("react.memo"), F = Symbol.for("react.lazy"), V = Symbol.for("react.activity"), T = Symbol.for("react.memo_cache_sentinel"), $ = Symbol.iterator;
  function H(o) {
    return o === null || typeof o != "object" ? null : (o = $ && o[$] || o["@@iterator"], typeof o == "function" ? o : null);
  }
  var G = Symbol.for("react.client.reference");
  function j(o) {
    if (o == null) return null;
    if (typeof o == "function")
      return o.$$typeof === G ? null : o.displayName || o.name || null;
    if (typeof o == "string") return o;
    switch (o) {
      case b:
        return "Fragment";
      case E:
        return "Profiler";
      case x:
        return "StrictMode";
      case N:
        return "Suspense";
      case D:
        return "SuspenseList";
      case V:
        return "Activity";
    }
    if (typeof o == "object")
      switch (o.$$typeof) {
        case y:
          return "Portal";
        case k:
          return (o.displayName || "Context") + ".Provider";
        case A:
          return (o._context.displayName || "Context") + ".Consumer";
        case R:
          var l = o.render;
          return o = o.displayName, o || (o = l.displayName || l.name || "", o = o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef"), o;
        case P:
          return l = o.displayName || null, l !== null ? l : j(o.type) || "Memo";
        case F:
          l = o._payload, o = o._init;
          try {
            return j(o(l));
          } catch {
          }
      }
    return null;
  }
  var U = Array.isArray, z = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, B = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, q = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, Y = [], O = -1;
  function W(o) {
    return { current: o };
  }
  function Z(o) {
    0 > O || (o.current = Y[O], Y[O] = null, O--);
  }
  function I(o, l) {
    O++, Y[O] = o.current, o.current = l;
  }
  var ie = W(null), fe = W(null), re = W(null), le = W(null);
  function he(o, l) {
    switch (I(re, l), I(fe, o), I(ie, null), l.nodeType) {
      case 9:
      case 11:
        o = (o = l.documentElement) && (o = o.namespaceURI) ? c_(o) : 0;
        break;
      default:
        if (o = l.tagName, l = l.namespaceURI)
          l = c_(l), o = f_(l, o);
        else
          switch (o) {
            case "svg":
              o = 1;
              break;
            case "math":
              o = 2;
              break;
            default:
              o = 0;
          }
    }
    Z(ie), I(ie, o);
  }
  function ye() {
    Z(ie), Z(fe), Z(re);
  }
  function je(o) {
    o.memoizedState !== null && I(le, o);
    var l = ie.current, c = f_(l, o.type);
    l !== c && (I(fe, o), I(ie, c));
  }
  function Oe(o) {
    fe.current === o && (Z(ie), Z(fe)), le.current === o && (Z(le), Eu._currentValue = q);
  }
  var be = Object.prototype.hasOwnProperty, Le = e.unstable_scheduleCallback, Ie = e.unstable_cancelCallback, ft = e.unstable_shouldYield, Jt = e.unstable_requestPaint, bt = e.unstable_now, Ln = e.unstable_getCurrentPriorityLevel, xr = e.unstable_ImmediatePriority, En = e.unstable_UserBlockingPriority, ir = e.unstable_NormalPriority, Pe = e.unstable_LowPriority, Lr = e.unstable_IdlePriority, Ko = e.log, hi = e.unstable_setDisableYieldValue, ae = null, pe = null;
  function Ce(o) {
    if (typeof Ko == "function" && hi(o), pe && typeof pe.setStrictMode == "function")
      try {
        pe.setStrictMode(ae, o);
      } catch {
      }
  }
  var Ae = Math.clz32 ? Math.clz32 : wr, Je = Math.log, gn = Math.LN2;
  function wr(o) {
    return o >>>= 0, o === 0 ? 32 : 31 - (Je(o) / gn | 0) | 0;
  }
  var an = 256, or = 4194304;
  function yn(o) {
    var l = o & 42;
    if (l !== 0) return l;
    switch (o & -o) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return o & 4194048;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return o & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return o;
    }
  }
  function jt(o, l, c) {
    var m = o.pendingLanes;
    if (m === 0) return 0;
    var v = 0, w = o.suspendedLanes, M = o.pingedLanes;
    o = o.warmLanes;
    var L = m & 134217727;
    return L !== 0 ? (m = L & ~w, m !== 0 ? v = yn(m) : (M &= L, M !== 0 ? v = yn(M) : c || (c = L & ~o, c !== 0 && (v = yn(c))))) : (L = m & ~w, L !== 0 ? v = yn(L) : M !== 0 ? v = yn(M) : c || (c = m & ~o, c !== 0 && (v = yn(c)))), v === 0 ? 0 : l !== 0 && l !== v && (l & w) === 0 && (w = v & -v, c = l & -l, w >= c || w === 32 && (c & 4194048) !== 0) ? l : v;
  }
  function Cn(o, l) {
    return (o.pendingLanes & ~(o.suspendedLanes & ~o.pingedLanes) & l) === 0;
  }
  function Fn(o, l) {
    switch (o) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return l + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Jc() {
    var o = an;
    return an <<= 1, (an & 4194048) === 0 && (an = 256), o;
  }
  function ef() {
    var o = or;
    return or <<= 1, (or & 62914560) === 0 && (or = 4194304), o;
  }
  function Al(o) {
    for (var l = [], c = 0; 31 > c; c++) l.push(o);
    return l;
  }
  function Zo(o, l) {
    o.pendingLanes |= l, l !== 268435456 && (o.suspendedLanes = 0, o.pingedLanes = 0, o.warmLanes = 0);
  }
  function fm(o, l, c, m, v, w) {
    var M = o.pendingLanes;
    o.pendingLanes = c, o.suspendedLanes = 0, o.pingedLanes = 0, o.warmLanes = 0, o.expiredLanes &= c, o.entangledLanes &= c, o.errorRecoveryDisabledLanes &= c, o.shellSuspendCounter = 0;
    var L = o.entanglements, X = o.expirationTimes, ee = o.hiddenUpdates;
    for (c = M & ~c; 0 < c; ) {
      var ue = 31 - Ae(c), de = 1 << ue;
      L[ue] = 0, X[ue] = -1;
      var te = ee[ue];
      if (te !== null)
        for (ee[ue] = null, ue = 0; ue < te.length; ue++) {
          var ne = te[ue];
          ne !== null && (ne.lane &= -536870913);
        }
      c &= ~de;
    }
    m !== 0 && Tl(o, m, 0), w !== 0 && v === 0 && o.tag !== 0 && (o.suspendedLanes |= w & ~(M & ~l));
  }
  function Tl(o, l, c) {
    o.pendingLanes |= l, o.suspendedLanes &= ~l;
    var m = 31 - Ae(l);
    o.entangledLanes |= l, o.entanglements[m] = o.entanglements[m] | 1073741824 | c & 4194090;
  }
  function tf(o, l) {
    var c = o.entangledLanes |= l;
    for (o = o.entanglements; c; ) {
      var m = 31 - Ae(c), v = 1 << m;
      v & l | o[m] & l && (o[m] |= l), c &= ~v;
    }
  }
  function Rl(o) {
    switch (o) {
      case 2:
        o = 1;
        break;
      case 8:
        o = 4;
        break;
      case 32:
        o = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        o = 128;
        break;
      case 268435456:
        o = 134217728;
        break;
      default:
        o = 0;
    }
    return o;
  }
  function Ol(o) {
    return o &= -o, 2 < o ? 8 < o ? (o & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function nf() {
    var o = B.p;
    return o !== 0 ? o : (o = window.event, o === void 0 ? 32 : O_(o.type));
  }
  function dm(o, l) {
    var c = B.p;
    try {
      return B.p = o, l();
    } finally {
      B.p = c;
    }
  }
  var Fr = Math.random().toString(36).slice(2), Xt = "__reactFiber$" + Fr, sn = "__reactProps$" + Fr, eo = "__reactContainer$" + Fr, Nl = "__reactEvents$" + Fr, hm = "__reactListeners$" + Fr, pm = "__reactHandles$" + Fr, rf = "__reactResources$" + Fr, Qo = "__reactMarker$" + Fr;
  function Ml(o) {
    delete o[Xt], delete o[sn], delete o[Nl], delete o[hm], delete o[pm];
  }
  function pi(o) {
    var l = o[Xt];
    if (l) return l;
    for (var c = o.parentNode; c; ) {
      if (l = c[eo] || c[Xt]) {
        if (c = l.alternate, l.child !== null || c !== null && c.child !== null)
          for (o = m_(o); o !== null; ) {
            if (c = o[Xt]) return c;
            o = m_(o);
          }
        return l;
      }
      o = c, c = o.parentNode;
    }
    return null;
  }
  function mi(o) {
    if (o = o[Xt] || o[eo]) {
      var l = o.tag;
      if (l === 5 || l === 6 || l === 13 || l === 26 || l === 27 || l === 3)
        return o;
    }
    return null;
  }
  function Jo(o) {
    var l = o.tag;
    if (l === 5 || l === 26 || l === 27 || l === 6) return o.stateNode;
    throw Error(r(33));
  }
  function to(o) {
    var l = o[rf];
    return l || (l = o[rf] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), l;
  }
  function It(o) {
    o[Qo] = !0;
  }
  var of = /* @__PURE__ */ new Set(), af = {};
  function gi(o, l) {
    no(o, l), no(o + "Capture", l);
  }
  function no(o, l) {
    for (af[o] = l, o = 0; o < l.length; o++)
      of.add(l[o]);
  }
  var sf = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), lf = {}, uf = {};
  function mm(o) {
    return be.call(uf, o) ? !0 : be.call(lf, o) ? !1 : sf.test(o) ? uf[o] = !0 : (lf[o] = !0, !1);
  }
  function Va(o, l, c) {
    if (mm(l))
      if (c === null) o.removeAttribute(l);
      else {
        switch (typeof c) {
          case "undefined":
          case "function":
          case "symbol":
            o.removeAttribute(l);
            return;
          case "boolean":
            var m = l.toLowerCase().slice(0, 5);
            if (m !== "data-" && m !== "aria-") {
              o.removeAttribute(l);
              return;
            }
        }
        o.setAttribute(l, "" + c);
      }
  }
  function Ua(o, l, c) {
    if (c === null) o.removeAttribute(l);
    else {
      switch (typeof c) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          o.removeAttribute(l);
          return;
      }
      o.setAttribute(l, "" + c);
    }
  }
  function Sr(o, l, c, m) {
    if (m === null) o.removeAttribute(c);
    else {
      switch (typeof m) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          o.removeAttribute(c);
          return;
      }
      o.setAttributeNS(l, c, "" + m);
    }
  }
  var Dl, Pl;
  function ro(o) {
    if (Dl === void 0)
      try {
        throw Error();
      } catch (c) {
        var l = c.stack.trim().match(/\n( *(at )?)/);
        Dl = l && l[1] || "", Pl = -1 < c.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < c.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + Dl + o + Pl;
  }
  var zl = !1;
  function jl(o, l) {
    if (!o || zl) return "";
    zl = !0;
    var c = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var m = {
        DetermineComponentFrameRoot: function() {
          try {
            if (l) {
              var de = function() {
                throw Error();
              };
              if (Object.defineProperty(de.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(de, []);
                } catch (ne) {
                  var te = ne;
                }
                Reflect.construct(o, [], de);
              } else {
                try {
                  de.call();
                } catch (ne) {
                  te = ne;
                }
                o.call(de.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (ne) {
                te = ne;
              }
              (de = o()) && typeof de.catch == "function" && de.catch(function() {
              });
            }
          } catch (ne) {
            if (ne && te && typeof ne.stack == "string")
              return [ne.stack, te.stack];
          }
          return [null, null];
        }
      };
      m.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var v = Object.getOwnPropertyDescriptor(
        m.DetermineComponentFrameRoot,
        "name"
      );
      v && v.configurable && Object.defineProperty(
        m.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var w = m.DetermineComponentFrameRoot(), M = w[0], L = w[1];
      if (M && L) {
        var X = M.split(`
`), ee = L.split(`
`);
        for (v = m = 0; m < X.length && !X[m].includes("DetermineComponentFrameRoot"); )
          m++;
        for (; v < ee.length && !ee[v].includes(
          "DetermineComponentFrameRoot"
        ); )
          v++;
        if (m === X.length || v === ee.length)
          for (m = X.length - 1, v = ee.length - 1; 1 <= m && 0 <= v && X[m] !== ee[v]; )
            v--;
        for (; 1 <= m && 0 <= v; m--, v--)
          if (X[m] !== ee[v]) {
            if (m !== 1 || v !== 1)
              do
                if (m--, v--, 0 > v || X[m] !== ee[v]) {
                  var ue = `
` + X[m].replace(" at new ", " at ");
                  return o.displayName && ue.includes("<anonymous>") && (ue = ue.replace("<anonymous>", o.displayName)), ue;
                }
              while (1 <= m && 0 <= v);
            break;
          }
      }
    } finally {
      zl = !1, Error.prepareStackTrace = c;
    }
    return (c = o ? o.displayName || o.name : "") ? ro(c) : "";
  }
  function gm(o) {
    switch (o.tag) {
      case 26:
      case 27:
      case 5:
        return ro(o.type);
      case 16:
        return ro("Lazy");
      case 13:
        return ro("Suspense");
      case 19:
        return ro("SuspenseList");
      case 0:
      case 15:
        return jl(o.type, !1);
      case 11:
        return jl(o.type.render, !1);
      case 1:
        return jl(o.type, !0);
      case 31:
        return ro("Activity");
      default:
        return "";
    }
  }
  function cf(o) {
    try {
      var l = "";
      do
        l += gm(o), o = o.return;
      while (o);
      return l;
    } catch (c) {
      return `
Error generating stack: ` + c.message + `
` + c.stack;
    }
  }
  function kn(o) {
    switch (typeof o) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return o;
      case "object":
        return o;
      default:
        return "";
    }
  }
  function ff(o) {
    var l = o.type;
    return (o = o.nodeName) && o.toLowerCase() === "input" && (l === "checkbox" || l === "radio");
  }
  function df(o) {
    var l = ff(o) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(
      o.constructor.prototype,
      l
    ), m = "" + o[l];
    if (!o.hasOwnProperty(l) && typeof c < "u" && typeof c.get == "function" && typeof c.set == "function") {
      var v = c.get, w = c.set;
      return Object.defineProperty(o, l, {
        configurable: !0,
        get: function() {
          return v.call(this);
        },
        set: function(M) {
          m = "" + M, w.call(this, M);
        }
      }), Object.defineProperty(o, l, {
        enumerable: c.enumerable
      }), {
        getValue: function() {
          return m;
        },
        setValue: function(M) {
          m = "" + M;
        },
        stopTracking: function() {
          o._valueTracker = null, delete o[l];
        }
      };
    }
  }
  function qa(o) {
    o._valueTracker || (o._valueTracker = df(o));
  }
  function hf(o) {
    if (!o) return !1;
    var l = o._valueTracker;
    if (!l) return !0;
    var c = l.getValue(), m = "";
    return o && (m = ff(o) ? o.checked ? "true" : "false" : o.value), o = m, o !== c ? (l.setValue(o), !0) : !1;
  }
  function io(o) {
    if (o = o || (typeof document < "u" ? document : void 0), typeof o > "u") return null;
    try {
      return o.activeElement || o.body;
    } catch {
      return o.body;
    }
  }
  var ym = /[\n"\\]/g;
  function An(o) {
    return o.replace(
      ym,
      function(l) {
        return "\\" + l.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function Ya(o, l, c, m, v, w, M, L) {
    o.name = "", M != null && typeof M != "function" && typeof M != "symbol" && typeof M != "boolean" ? o.type = M : o.removeAttribute("type"), l != null ? M === "number" ? (l === 0 && o.value === "" || o.value != l) && (o.value = "" + kn(l)) : o.value !== "" + kn(l) && (o.value = "" + kn(l)) : M !== "submit" && M !== "reset" || o.removeAttribute("value"), l != null ? vm(o, M, kn(l)) : c != null ? vm(o, M, kn(c)) : m != null && o.removeAttribute("value"), v == null && w != null && (o.defaultChecked = !!w), v != null && (o.checked = v && typeof v != "function" && typeof v != "symbol"), L != null && typeof L != "function" && typeof L != "symbol" && typeof L != "boolean" ? o.name = "" + kn(L) : o.removeAttribute("name");
  }
  function sx(o, l, c, m, v, w, M, L) {
    if (w != null && typeof w != "function" && typeof w != "symbol" && typeof w != "boolean" && (o.type = w), l != null || c != null) {
      if (!(w !== "submit" && w !== "reset" || l != null))
        return;
      c = c != null ? "" + kn(c) : "", l = l != null ? "" + kn(l) : c, L || l === o.value || (o.value = l), o.defaultValue = l;
    }
    m = m ?? v, m = typeof m != "function" && typeof m != "symbol" && !!m, o.checked = L ? o.checked : !!m, o.defaultChecked = !!m, M != null && typeof M != "function" && typeof M != "symbol" && typeof M != "boolean" && (o.name = M);
  }
  function vm(o, l, c) {
    l === "number" && io(o.ownerDocument) === o || o.defaultValue === "" + c || (o.defaultValue = "" + c);
  }
  function Ga(o, l, c, m) {
    if (o = o.options, l) {
      l = {};
      for (var v = 0; v < c.length; v++)
        l["$" + c[v]] = !0;
      for (c = 0; c < o.length; c++)
        v = l.hasOwnProperty("$" + o[c].value), o[c].selected !== v && (o[c].selected = v), v && m && (o[c].defaultSelected = !0);
    } else {
      for (c = "" + kn(c), l = null, v = 0; v < o.length; v++) {
        if (o[v].value === c) {
          o[v].selected = !0, m && (o[v].defaultSelected = !0);
          return;
        }
        l !== null || o[v].disabled || (l = o[v]);
      }
      l !== null && (l.selected = !0);
    }
  }
  function lx(o, l, c) {
    if (l != null && (l = "" + kn(l), l !== o.value && (o.value = l), c == null)) {
      o.defaultValue !== l && (o.defaultValue = l);
      return;
    }
    o.defaultValue = c != null ? "" + kn(c) : "";
  }
  function ux(o, l, c, m) {
    if (l == null) {
      if (m != null) {
        if (c != null) throw Error(r(92));
        if (U(m)) {
          if (1 < m.length) throw Error(r(93));
          m = m[0];
        }
        c = m;
      }
      c == null && (c = ""), l = c;
    }
    c = kn(l), o.defaultValue = c, m = o.textContent, m === c && m !== "" && m !== null && (o.value = m);
  }
  function Xa(o, l) {
    if (l) {
      var c = o.firstChild;
      if (c && c === o.lastChild && c.nodeType === 3) {
        c.nodeValue = l;
        return;
      }
    }
    o.textContent = l;
  }
  var k4 = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function cx(o, l, c) {
    var m = l.indexOf("--") === 0;
    c == null || typeof c == "boolean" || c === "" ? m ? o.setProperty(l, "") : l === "float" ? o.cssFloat = "" : o[l] = "" : m ? o.setProperty(l, c) : typeof c != "number" || c === 0 || k4.has(l) ? l === "float" ? o.cssFloat = c : o[l] = ("" + c).trim() : o[l] = c + "px";
  }
  function fx(o, l, c) {
    if (l != null && typeof l != "object")
      throw Error(r(62));
    if (o = o.style, c != null) {
      for (var m in c)
        !c.hasOwnProperty(m) || l != null && l.hasOwnProperty(m) || (m.indexOf("--") === 0 ? o.setProperty(m, "") : m === "float" ? o.cssFloat = "" : o[m] = "");
      for (var v in l)
        m = l[v], l.hasOwnProperty(v) && c[v] !== m && cx(o, v, m);
    } else
      for (var w in l)
        l.hasOwnProperty(w) && cx(o, w, l[w]);
  }
  function bm(o) {
    if (o.indexOf("-") === -1) return !1;
    switch (o) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var A4 = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), T4 = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function pf(o) {
    return T4.test("" + o) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : o;
  }
  var xm = null;
  function wm(o) {
    return o = o.target || o.srcElement || window, o.correspondingUseElement && (o = o.correspondingUseElement), o.nodeType === 3 ? o.parentNode : o;
  }
  var Wa = null, Ka = null;
  function dx(o) {
    var l = mi(o);
    if (l && (o = l.stateNode)) {
      var c = o[sn] || null;
      e: switch (o = l.stateNode, l.type) {
        case "input":
          if (Ya(
            o,
            c.value,
            c.defaultValue,
            c.defaultValue,
            c.checked,
            c.defaultChecked,
            c.type,
            c.name
          ), l = c.name, c.type === "radio" && l != null) {
            for (c = o; c.parentNode; ) c = c.parentNode;
            for (c = c.querySelectorAll(
              'input[name="' + An(
                "" + l
              ) + '"][type="radio"]'
            ), l = 0; l < c.length; l++) {
              var m = c[l];
              if (m !== o && m.form === o.form) {
                var v = m[sn] || null;
                if (!v) throw Error(r(90));
                Ya(
                  m,
                  v.value,
                  v.defaultValue,
                  v.defaultValue,
                  v.checked,
                  v.defaultChecked,
                  v.type,
                  v.name
                );
              }
            }
            for (l = 0; l < c.length; l++)
              m = c[l], m.form === o.form && hf(m);
          }
          break e;
        case "textarea":
          lx(o, c.value, c.defaultValue);
          break e;
        case "select":
          l = c.value, l != null && Ga(o, !!c.multiple, l, !1);
      }
    }
  }
  var Sm = !1;
  function hx(o, l, c) {
    if (Sm) return o(l, c);
    Sm = !0;
    try {
      var m = o(l);
      return m;
    } finally {
      if (Sm = !1, (Wa !== null || Ka !== null) && (Jf(), Wa && (l = Wa, o = Ka, Ka = Wa = null, dx(l), o)))
        for (l = 0; l < o.length; l++) dx(o[l]);
    }
  }
  function Il(o, l) {
    var c = o.stateNode;
    if (c === null) return null;
    var m = c[sn] || null;
    if (m === null) return null;
    c = m[l];
    e: switch (l) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (m = !m.disabled) || (o = o.type, m = !(o === "button" || o === "input" || o === "select" || o === "textarea")), o = !m;
        break e;
      default:
        o = !1;
    }
    if (o) return null;
    if (c && typeof c != "function")
      throw Error(
        r(231, l, typeof c)
      );
    return c;
  }
  var yi = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), _m = !1;
  if (yi)
    try {
      var Ll = {};
      Object.defineProperty(Ll, "passive", {
        get: function() {
          _m = !0;
        }
      }), window.addEventListener("test", Ll, Ll), window.removeEventListener("test", Ll, Ll);
    } catch {
      _m = !1;
    }
  var oo = null, Em = null, mf = null;
  function px() {
    if (mf) return mf;
    var o, l = Em, c = l.length, m, v = "value" in oo ? oo.value : oo.textContent, w = v.length;
    for (o = 0; o < c && l[o] === v[o]; o++) ;
    var M = c - o;
    for (m = 1; m <= M && l[c - m] === v[w - m]; m++) ;
    return mf = v.slice(o, 1 < m ? 1 - m : void 0);
  }
  function gf(o) {
    var l = o.keyCode;
    return "charCode" in o ? (o = o.charCode, o === 0 && l === 13 && (o = 13)) : o = l, o === 10 && (o = 13), 32 <= o || o === 13 ? o : 0;
  }
  function yf() {
    return !0;
  }
  function mx() {
    return !1;
  }
  function Tn(o) {
    function l(c, m, v, w, M) {
      this._reactName = c, this._targetInst = v, this.type = m, this.nativeEvent = w, this.target = M, this.currentTarget = null;
      for (var L in o)
        o.hasOwnProperty(L) && (c = o[L], this[L] = c ? c(w) : w[L]);
      return this.isDefaultPrevented = (w.defaultPrevented != null ? w.defaultPrevented : w.returnValue === !1) ? yf : mx, this.isPropagationStopped = mx, this;
    }
    return h(l.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var c = this.nativeEvent;
        c && (c.preventDefault ? c.preventDefault() : typeof c.returnValue != "unknown" && (c.returnValue = !1), this.isDefaultPrevented = yf);
      },
      stopPropagation: function() {
        var c = this.nativeEvent;
        c && (c.stopPropagation ? c.stopPropagation() : typeof c.cancelBubble != "unknown" && (c.cancelBubble = !0), this.isPropagationStopped = yf);
      },
      persist: function() {
      },
      isPersistent: yf
    }), l;
  }
  var ea = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(o) {
      return o.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, vf = Tn(ea), Fl = h({}, ea, { view: 0, detail: 0 }), R4 = Tn(Fl), Cm, km, Bl, bf = h({}, Fl, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: Tm,
    button: 0,
    buttons: 0,
    relatedTarget: function(o) {
      return o.relatedTarget === void 0 ? o.fromElement === o.srcElement ? o.toElement : o.fromElement : o.relatedTarget;
    },
    movementX: function(o) {
      return "movementX" in o ? o.movementX : (o !== Bl && (Bl && o.type === "mousemove" ? (Cm = o.screenX - Bl.screenX, km = o.screenY - Bl.screenY) : km = Cm = 0, Bl = o), Cm);
    },
    movementY: function(o) {
      return "movementY" in o ? o.movementY : km;
    }
  }), gx = Tn(bf), O4 = h({}, bf, { dataTransfer: 0 }), N4 = Tn(O4), M4 = h({}, Fl, { relatedTarget: 0 }), Am = Tn(M4), D4 = h({}, ea, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), P4 = Tn(D4), z4 = h({}, ea, {
    clipboardData: function(o) {
      return "clipboardData" in o ? o.clipboardData : window.clipboardData;
    }
  }), j4 = Tn(z4), I4 = h({}, ea, { data: 0 }), yx = Tn(I4), L4 = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, F4 = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, B4 = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function $4(o) {
    var l = this.nativeEvent;
    return l.getModifierState ? l.getModifierState(o) : (o = B4[o]) ? !!l[o] : !1;
  }
  function Tm() {
    return $4;
  }
  var H4 = h({}, Fl, {
    key: function(o) {
      if (o.key) {
        var l = L4[o.key] || o.key;
        if (l !== "Unidentified") return l;
      }
      return o.type === "keypress" ? (o = gf(o), o === 13 ? "Enter" : String.fromCharCode(o)) : o.type === "keydown" || o.type === "keyup" ? F4[o.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: Tm,
    charCode: function(o) {
      return o.type === "keypress" ? gf(o) : 0;
    },
    keyCode: function(o) {
      return o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
    },
    which: function(o) {
      return o.type === "keypress" ? gf(o) : o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
    }
  }), V4 = Tn(H4), U4 = h({}, bf, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), vx = Tn(U4), q4 = h({}, Fl, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: Tm
  }), Y4 = Tn(q4), G4 = h({}, ea, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), X4 = Tn(G4), W4 = h({}, bf, {
    deltaX: function(o) {
      return "deltaX" in o ? o.deltaX : "wheelDeltaX" in o ? -o.wheelDeltaX : 0;
    },
    deltaY: function(o) {
      return "deltaY" in o ? o.deltaY : "wheelDeltaY" in o ? -o.wheelDeltaY : "wheelDelta" in o ? -o.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), K4 = Tn(W4), Z4 = h({}, ea, {
    newState: 0,
    oldState: 0
  }), Q4 = Tn(Z4), J4 = [9, 13, 27, 32], Rm = yi && "CompositionEvent" in window, $l = null;
  yi && "documentMode" in document && ($l = document.documentMode);
  var eD = yi && "TextEvent" in window && !$l, bx = yi && (!Rm || $l && 8 < $l && 11 >= $l), xx = " ", wx = !1;
  function Sx(o, l) {
    switch (o) {
      case "keyup":
        return J4.indexOf(l.keyCode) !== -1;
      case "keydown":
        return l.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function _x(o) {
    return o = o.detail, typeof o == "object" && "data" in o ? o.data : null;
  }
  var Za = !1;
  function tD(o, l) {
    switch (o) {
      case "compositionend":
        return _x(l);
      case "keypress":
        return l.which !== 32 ? null : (wx = !0, xx);
      case "textInput":
        return o = l.data, o === xx && wx ? null : o;
      default:
        return null;
    }
  }
  function nD(o, l) {
    if (Za)
      return o === "compositionend" || !Rm && Sx(o, l) ? (o = px(), mf = Em = oo = null, Za = !1, o) : null;
    switch (o) {
      case "paste":
        return null;
      case "keypress":
        if (!(l.ctrlKey || l.altKey || l.metaKey) || l.ctrlKey && l.altKey) {
          if (l.char && 1 < l.char.length)
            return l.char;
          if (l.which) return String.fromCharCode(l.which);
        }
        return null;
      case "compositionend":
        return bx && l.locale !== "ko" ? null : l.data;
      default:
        return null;
    }
  }
  var rD = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function Ex(o) {
    var l = o && o.nodeName && o.nodeName.toLowerCase();
    return l === "input" ? !!rD[o.type] : l === "textarea";
  }
  function Cx(o, l, c, m) {
    Wa ? Ka ? Ka.push(m) : Ka = [m] : Wa = m, l = od(l, "onChange"), 0 < l.length && (c = new vf(
      "onChange",
      "change",
      null,
      c,
      m
    ), o.push({ event: c, listeners: l }));
  }
  var Hl = null, Vl = null;
  function iD(o) {
    o_(o, 0);
  }
  function xf(o) {
    var l = Jo(o);
    if (hf(l)) return o;
  }
  function kx(o, l) {
    if (o === "change") return l;
  }
  var Ax = !1;
  if (yi) {
    var Om;
    if (yi) {
      var Nm = "oninput" in document;
      if (!Nm) {
        var Tx = document.createElement("div");
        Tx.setAttribute("oninput", "return;"), Nm = typeof Tx.oninput == "function";
      }
      Om = Nm;
    } else Om = !1;
    Ax = Om && (!document.documentMode || 9 < document.documentMode);
  }
  function Rx() {
    Hl && (Hl.detachEvent("onpropertychange", Ox), Vl = Hl = null);
  }
  function Ox(o) {
    if (o.propertyName === "value" && xf(Vl)) {
      var l = [];
      Cx(
        l,
        Vl,
        o,
        wm(o)
      ), hx(iD, l);
    }
  }
  function oD(o, l, c) {
    o === "focusin" ? (Rx(), Hl = l, Vl = c, Hl.attachEvent("onpropertychange", Ox)) : o === "focusout" && Rx();
  }
  function aD(o) {
    if (o === "selectionchange" || o === "keyup" || o === "keydown")
      return xf(Vl);
  }
  function sD(o, l) {
    if (o === "click") return xf(l);
  }
  function lD(o, l) {
    if (o === "input" || o === "change")
      return xf(l);
  }
  function uD(o, l) {
    return o === l && (o !== 0 || 1 / o === 1 / l) || o !== o && l !== l;
  }
  var Bn = typeof Object.is == "function" ? Object.is : uD;
  function Ul(o, l) {
    if (Bn(o, l)) return !0;
    if (typeof o != "object" || o === null || typeof l != "object" || l === null)
      return !1;
    var c = Object.keys(o), m = Object.keys(l);
    if (c.length !== m.length) return !1;
    for (m = 0; m < c.length; m++) {
      var v = c[m];
      if (!be.call(l, v) || !Bn(o[v], l[v]))
        return !1;
    }
    return !0;
  }
  function Nx(o) {
    for (; o && o.firstChild; ) o = o.firstChild;
    return o;
  }
  function Mx(o, l) {
    var c = Nx(o);
    o = 0;
    for (var m; c; ) {
      if (c.nodeType === 3) {
        if (m = o + c.textContent.length, o <= l && m >= l)
          return { node: c, offset: l - o };
        o = m;
      }
      e: {
        for (; c; ) {
          if (c.nextSibling) {
            c = c.nextSibling;
            break e;
          }
          c = c.parentNode;
        }
        c = void 0;
      }
      c = Nx(c);
    }
  }
  function Dx(o, l) {
    return o && l ? o === l ? !0 : o && o.nodeType === 3 ? !1 : l && l.nodeType === 3 ? Dx(o, l.parentNode) : "contains" in o ? o.contains(l) : o.compareDocumentPosition ? !!(o.compareDocumentPosition(l) & 16) : !1 : !1;
  }
  function Px(o) {
    o = o != null && o.ownerDocument != null && o.ownerDocument.defaultView != null ? o.ownerDocument.defaultView : window;
    for (var l = io(o.document); l instanceof o.HTMLIFrameElement; ) {
      try {
        var c = typeof l.contentWindow.location.href == "string";
      } catch {
        c = !1;
      }
      if (c) o = l.contentWindow;
      else break;
      l = io(o.document);
    }
    return l;
  }
  function Mm(o) {
    var l = o && o.nodeName && o.nodeName.toLowerCase();
    return l && (l === "input" && (o.type === "text" || o.type === "search" || o.type === "tel" || o.type === "url" || o.type === "password") || l === "textarea" || o.contentEditable === "true");
  }
  var cD = yi && "documentMode" in document && 11 >= document.documentMode, Qa = null, Dm = null, ql = null, Pm = !1;
  function zx(o, l, c) {
    var m = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
    Pm || Qa == null || Qa !== io(m) || (m = Qa, "selectionStart" in m && Mm(m) ? m = { start: m.selectionStart, end: m.selectionEnd } : (m = (m.ownerDocument && m.ownerDocument.defaultView || window).getSelection(), m = {
      anchorNode: m.anchorNode,
      anchorOffset: m.anchorOffset,
      focusNode: m.focusNode,
      focusOffset: m.focusOffset
    }), ql && Ul(ql, m) || (ql = m, m = od(Dm, "onSelect"), 0 < m.length && (l = new vf(
      "onSelect",
      "select",
      null,
      l,
      c
    ), o.push({ event: l, listeners: m }), l.target = Qa)));
  }
  function ta(o, l) {
    var c = {};
    return c[o.toLowerCase()] = l.toLowerCase(), c["Webkit" + o] = "webkit" + l, c["Moz" + o] = "moz" + l, c;
  }
  var Ja = {
    animationend: ta("Animation", "AnimationEnd"),
    animationiteration: ta("Animation", "AnimationIteration"),
    animationstart: ta("Animation", "AnimationStart"),
    transitionrun: ta("Transition", "TransitionRun"),
    transitionstart: ta("Transition", "TransitionStart"),
    transitioncancel: ta("Transition", "TransitionCancel"),
    transitionend: ta("Transition", "TransitionEnd")
  }, zm = {}, jx = {};
  yi && (jx = document.createElement("div").style, "AnimationEvent" in window || (delete Ja.animationend.animation, delete Ja.animationiteration.animation, delete Ja.animationstart.animation), "TransitionEvent" in window || delete Ja.transitionend.transition);
  function na(o) {
    if (zm[o]) return zm[o];
    if (!Ja[o]) return o;
    var l = Ja[o], c;
    for (c in l)
      if (l.hasOwnProperty(c) && c in jx)
        return zm[o] = l[c];
    return o;
  }
  var Ix = na("animationend"), Lx = na("animationiteration"), Fx = na("animationstart"), fD = na("transitionrun"), dD = na("transitionstart"), hD = na("transitioncancel"), Bx = na("transitionend"), $x = /* @__PURE__ */ new Map(), jm = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  jm.push("scrollEnd");
  function _r(o, l) {
    $x.set(o, l), gi(l, [o]);
  }
  var Hx = /* @__PURE__ */ new WeakMap();
  function ar(o, l) {
    if (typeof o == "object" && o !== null) {
      var c = Hx.get(o);
      return c !== void 0 ? c : (l = {
        value: o,
        source: l,
        stack: cf(l)
      }, Hx.set(o, l), l);
    }
    return {
      value: o,
      source: l,
      stack: cf(l)
    };
  }
  var sr = [], es = 0, Im = 0;
  function wf() {
    for (var o = es, l = Im = es = 0; l < o; ) {
      var c = sr[l];
      sr[l++] = null;
      var m = sr[l];
      sr[l++] = null;
      var v = sr[l];
      sr[l++] = null;
      var w = sr[l];
      if (sr[l++] = null, m !== null && v !== null) {
        var M = m.pending;
        M === null ? v.next = v : (v.next = M.next, M.next = v), m.pending = v;
      }
      w !== 0 && Vx(c, v, w);
    }
  }
  function Sf(o, l, c, m) {
    sr[es++] = o, sr[es++] = l, sr[es++] = c, sr[es++] = m, Im |= m, o.lanes |= m, o = o.alternate, o !== null && (o.lanes |= m);
  }
  function Lm(o, l, c, m) {
    return Sf(o, l, c, m), _f(o);
  }
  function ts(o, l) {
    return Sf(o, null, null, l), _f(o);
  }
  function Vx(o, l, c) {
    o.lanes |= c;
    var m = o.alternate;
    m !== null && (m.lanes |= c);
    for (var v = !1, w = o.return; w !== null; )
      w.childLanes |= c, m = w.alternate, m !== null && (m.childLanes |= c), w.tag === 22 && (o = w.stateNode, o === null || o._visibility & 1 || (v = !0)), o = w, w = w.return;
    return o.tag === 3 ? (w = o.stateNode, v && l !== null && (v = 31 - Ae(c), o = w.hiddenUpdates, m = o[v], m === null ? o[v] = [l] : m.push(l), l.lane = c | 536870912), w) : null;
  }
  function _f(o) {
    if (50 < gu)
      throw gu = 0, Ug = null, Error(r(185));
    for (var l = o.return; l !== null; )
      o = l, l = o.return;
    return o.tag === 3 ? o.stateNode : null;
  }
  var ns = {};
  function pD(o, l, c, m) {
    this.tag = o, this.key = c, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = l, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = m, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function $n(o, l, c, m) {
    return new pD(o, l, c, m);
  }
  function Fm(o) {
    return o = o.prototype, !(!o || !o.isReactComponent);
  }
  function vi(o, l) {
    var c = o.alternate;
    return c === null ? (c = $n(
      o.tag,
      l,
      o.key,
      o.mode
    ), c.elementType = o.elementType, c.type = o.type, c.stateNode = o.stateNode, c.alternate = o, o.alternate = c) : (c.pendingProps = l, c.type = o.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null), c.flags = o.flags & 65011712, c.childLanes = o.childLanes, c.lanes = o.lanes, c.child = o.child, c.memoizedProps = o.memoizedProps, c.memoizedState = o.memoizedState, c.updateQueue = o.updateQueue, l = o.dependencies, c.dependencies = l === null ? null : { lanes: l.lanes, firstContext: l.firstContext }, c.sibling = o.sibling, c.index = o.index, c.ref = o.ref, c.refCleanup = o.refCleanup, c;
  }
  function Ux(o, l) {
    o.flags &= 65011714;
    var c = o.alternate;
    return c === null ? (o.childLanes = 0, o.lanes = l, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = c.childLanes, o.lanes = c.lanes, o.child = c.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = c.memoizedProps, o.memoizedState = c.memoizedState, o.updateQueue = c.updateQueue, o.type = c.type, l = c.dependencies, o.dependencies = l === null ? null : {
      lanes: l.lanes,
      firstContext: l.firstContext
    }), o;
  }
  function Ef(o, l, c, m, v, w) {
    var M = 0;
    if (m = o, typeof o == "function") Fm(o) && (M = 1);
    else if (typeof o == "string")
      M = gP(
        o,
        c,
        ie.current
      ) ? 26 : o === "html" || o === "head" || o === "body" ? 27 : 5;
    else
      e: switch (o) {
        case V:
          return o = $n(31, c, l, v), o.elementType = V, o.lanes = w, o;
        case b:
          return ra(c.children, v, w, l);
        case x:
          M = 8, v |= 24;
          break;
        case E:
          return o = $n(12, c, l, v | 2), o.elementType = E, o.lanes = w, o;
        case N:
          return o = $n(13, c, l, v), o.elementType = N, o.lanes = w, o;
        case D:
          return o = $n(19, c, l, v), o.elementType = D, o.lanes = w, o;
        default:
          if (typeof o == "object" && o !== null)
            switch (o.$$typeof) {
              case S:
              case k:
                M = 10;
                break e;
              case A:
                M = 9;
                break e;
              case R:
                M = 11;
                break e;
              case P:
                M = 14;
                break e;
              case F:
                M = 16, m = null;
                break e;
            }
          M = 29, c = Error(
            r(130, o === null ? "null" : typeof o, "")
          ), m = null;
      }
    return l = $n(M, c, l, v), l.elementType = o, l.type = m, l.lanes = w, l;
  }
  function ra(o, l, c, m) {
    return o = $n(7, o, m, l), o.lanes = c, o;
  }
  function Bm(o, l, c) {
    return o = $n(6, o, null, l), o.lanes = c, o;
  }
  function $m(o, l, c) {
    return l = $n(
      4,
      o.children !== null ? o.children : [],
      o.key,
      l
    ), l.lanes = c, l.stateNode = {
      containerInfo: o.containerInfo,
      pendingChildren: null,
      implementation: o.implementation
    }, l;
  }
  var rs = [], is = 0, Cf = null, kf = 0, lr = [], ur = 0, ia = null, bi = 1, xi = "";
  function oa(o, l) {
    rs[is++] = kf, rs[is++] = Cf, Cf = o, kf = l;
  }
  function qx(o, l, c) {
    lr[ur++] = bi, lr[ur++] = xi, lr[ur++] = ia, ia = o;
    var m = bi;
    o = xi;
    var v = 32 - Ae(m) - 1;
    m &= ~(1 << v), c += 1;
    var w = 32 - Ae(l) + v;
    if (30 < w) {
      var M = v - v % 5;
      w = (m & (1 << M) - 1).toString(32), m >>= M, v -= M, bi = 1 << 32 - Ae(l) + v | c << v | m, xi = w + o;
    } else
      bi = 1 << w | c << v | m, xi = o;
  }
  function Hm(o) {
    o.return !== null && (oa(o, 1), qx(o, 1, 0));
  }
  function Vm(o) {
    for (; o === Cf; )
      Cf = rs[--is], rs[is] = null, kf = rs[--is], rs[is] = null;
    for (; o === ia; )
      ia = lr[--ur], lr[ur] = null, xi = lr[--ur], lr[ur] = null, bi = lr[--ur], lr[ur] = null;
  }
  var vn = null, At = null, et = !1, aa = null, Br = !1, Um = Error(r(519));
  function sa(o) {
    var l = Error(r(418, ""));
    throw Xl(ar(l, o)), Um;
  }
  function Yx(o) {
    var l = o.stateNode, c = o.type, m = o.memoizedProps;
    switch (l[Xt] = o, l[sn] = m, c) {
      case "dialog":
        qe("cancel", l), qe("close", l);
        break;
      case "iframe":
      case "object":
      case "embed":
        qe("load", l);
        break;
      case "video":
      case "audio":
        for (c = 0; c < vu.length; c++)
          qe(vu[c], l);
        break;
      case "source":
        qe("error", l);
        break;
      case "img":
      case "image":
      case "link":
        qe("error", l), qe("load", l);
        break;
      case "details":
        qe("toggle", l);
        break;
      case "input":
        qe("invalid", l), sx(
          l,
          m.value,
          m.defaultValue,
          m.checked,
          m.defaultChecked,
          m.type,
          m.name,
          !0
        ), qa(l);
        break;
      case "select":
        qe("invalid", l);
        break;
      case "textarea":
        qe("invalid", l), ux(l, m.value, m.defaultValue, m.children), qa(l);
    }
    c = m.children, typeof c != "string" && typeof c != "number" && typeof c != "bigint" || l.textContent === "" + c || m.suppressHydrationWarning === !0 || u_(l.textContent, c) ? (m.popover != null && (qe("beforetoggle", l), qe("toggle", l)), m.onScroll != null && qe("scroll", l), m.onScrollEnd != null && qe("scrollend", l), m.onClick != null && (l.onclick = ad), l = !0) : l = !1, l || sa(o);
  }
  function Gx(o) {
    for (vn = o.return; vn; )
      switch (vn.tag) {
        case 5:
        case 13:
          Br = !1;
          return;
        case 27:
        case 3:
          Br = !0;
          return;
        default:
          vn = vn.return;
      }
  }
  function Yl(o) {
    if (o !== vn) return !1;
    if (!et) return Gx(o), et = !0, !1;
    var l = o.tag, c;
    if ((c = l !== 3 && l !== 27) && ((c = l === 5) && (c = o.type, c = !(c !== "form" && c !== "button") || a0(o.type, o.memoizedProps)), c = !c), c && At && sa(o), Gx(o), l === 13) {
      if (o = o.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(r(317));
      e: {
        for (o = o.nextSibling, l = 0; o; ) {
          if (o.nodeType === 8)
            if (c = o.data, c === "/$") {
              if (l === 0) {
                At = Cr(o.nextSibling);
                break e;
              }
              l--;
            } else
              c !== "$" && c !== "$!" && c !== "$?" || l++;
          o = o.nextSibling;
        }
        At = null;
      }
    } else
      l === 27 ? (l = At, So(o.type) ? (o = c0, c0 = null, At = o) : At = l) : At = vn ? Cr(o.stateNode.nextSibling) : null;
    return !0;
  }
  function Gl() {
    At = vn = null, et = !1;
  }
  function Xx() {
    var o = aa;
    return o !== null && (Nn === null ? Nn = o : Nn.push.apply(
      Nn,
      o
    ), aa = null), o;
  }
  function Xl(o) {
    aa === null ? aa = [o] : aa.push(o);
  }
  var qm = W(null), la = null, wi = null;
  function ao(o, l, c) {
    I(qm, l._currentValue), l._currentValue = c;
  }
  function Si(o) {
    o._currentValue = qm.current, Z(qm);
  }
  function Ym(o, l, c) {
    for (; o !== null; ) {
      var m = o.alternate;
      if ((o.childLanes & l) !== l ? (o.childLanes |= l, m !== null && (m.childLanes |= l)) : m !== null && (m.childLanes & l) !== l && (m.childLanes |= l), o === c) break;
      o = o.return;
    }
  }
  function Gm(o, l, c, m) {
    var v = o.child;
    for (v !== null && (v.return = o); v !== null; ) {
      var w = v.dependencies;
      if (w !== null) {
        var M = v.child;
        w = w.firstContext;
        e: for (; w !== null; ) {
          var L = w;
          w = v;
          for (var X = 0; X < l.length; X++)
            if (L.context === l[X]) {
              w.lanes |= c, L = w.alternate, L !== null && (L.lanes |= c), Ym(
                w.return,
                c,
                o
              ), m || (M = null);
              break e;
            }
          w = L.next;
        }
      } else if (v.tag === 18) {
        if (M = v.return, M === null) throw Error(r(341));
        M.lanes |= c, w = M.alternate, w !== null && (w.lanes |= c), Ym(M, c, o), M = null;
      } else M = v.child;
      if (M !== null) M.return = v;
      else
        for (M = v; M !== null; ) {
          if (M === o) {
            M = null;
            break;
          }
          if (v = M.sibling, v !== null) {
            v.return = M.return, M = v;
            break;
          }
          M = M.return;
        }
      v = M;
    }
  }
  function Wl(o, l, c, m) {
    o = null;
    for (var v = l, w = !1; v !== null; ) {
      if (!w) {
        if ((v.flags & 524288) !== 0) w = !0;
        else if ((v.flags & 262144) !== 0) break;
      }
      if (v.tag === 10) {
        var M = v.alternate;
        if (M === null) throw Error(r(387));
        if (M = M.memoizedProps, M !== null) {
          var L = v.type;
          Bn(v.pendingProps.value, M.value) || (o !== null ? o.push(L) : o = [L]);
        }
      } else if (v === le.current) {
        if (M = v.alternate, M === null) throw Error(r(387));
        M.memoizedState.memoizedState !== v.memoizedState.memoizedState && (o !== null ? o.push(Eu) : o = [Eu]);
      }
      v = v.return;
    }
    o !== null && Gm(
      l,
      o,
      c,
      m
    ), l.flags |= 262144;
  }
  function Af(o) {
    for (o = o.firstContext; o !== null; ) {
      if (!Bn(
        o.context._currentValue,
        o.memoizedValue
      ))
        return !0;
      o = o.next;
    }
    return !1;
  }
  function ua(o) {
    la = o, wi = null, o = o.dependencies, o !== null && (o.firstContext = null);
  }
  function ln(o) {
    return Wx(la, o);
  }
  function Tf(o, l) {
    return la === null && ua(o), Wx(o, l);
  }
  function Wx(o, l) {
    var c = l._currentValue;
    if (l = { context: l, memoizedValue: c, next: null }, wi === null) {
      if (o === null) throw Error(r(308));
      wi = l, o.dependencies = { lanes: 0, firstContext: l }, o.flags |= 524288;
    } else wi = wi.next = l;
    return c;
  }
  var mD = typeof AbortController < "u" ? AbortController : function() {
    var o = [], l = this.signal = {
      aborted: !1,
      addEventListener: function(c, m) {
        o.push(m);
      }
    };
    this.abort = function() {
      l.aborted = !0, o.forEach(function(c) {
        return c();
      });
    };
  }, gD = e.unstable_scheduleCallback, yD = e.unstable_NormalPriority, Yt = {
    $$typeof: k,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function Xm() {
    return {
      controller: new mD(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function Kl(o) {
    o.refCount--, o.refCount === 0 && gD(yD, function() {
      o.controller.abort();
    });
  }
  var Zl = null, Wm = 0, os = 0, as = null;
  function vD(o, l) {
    if (Zl === null) {
      var c = Zl = [];
      Wm = 0, os = Zg(), as = {
        status: "pending",
        value: void 0,
        then: function(m) {
          c.push(m);
        }
      };
    }
    return Wm++, l.then(Kx, Kx), l;
  }
  function Kx() {
    if (--Wm === 0 && Zl !== null) {
      as !== null && (as.status = "fulfilled");
      var o = Zl;
      Zl = null, os = 0, as = null;
      for (var l = 0; l < o.length; l++) (0, o[l])();
    }
  }
  function bD(o, l) {
    var c = [], m = {
      status: "pending",
      value: null,
      reason: null,
      then: function(v) {
        c.push(v);
      }
    };
    return o.then(
      function() {
        m.status = "fulfilled", m.value = l;
        for (var v = 0; v < c.length; v++) (0, c[v])(l);
      },
      function(v) {
        for (m.status = "rejected", m.reason = v, v = 0; v < c.length; v++)
          (0, c[v])(void 0);
      }
    ), m;
  }
  var Zx = z.S;
  z.S = function(o, l) {
    typeof l == "object" && l !== null && typeof l.then == "function" && vD(o, l), Zx !== null && Zx(o, l);
  };
  var ca = W(null);
  function Km() {
    var o = ca.current;
    return o !== null ? o : gt.pooledCache;
  }
  function Rf(o, l) {
    l === null ? I(ca, ca.current) : I(ca, l.pool);
  }
  function Qx() {
    var o = Km();
    return o === null ? null : { parent: Yt._currentValue, pool: o };
  }
  var Ql = Error(r(460)), Jx = Error(r(474)), Of = Error(r(542)), Zm = { then: function() {
  } };
  function ew(o) {
    return o = o.status, o === "fulfilled" || o === "rejected";
  }
  function Nf() {
  }
  function tw(o, l, c) {
    switch (c = o[c], c === void 0 ? o.push(l) : c !== l && (l.then(Nf, Nf), l = c), l.status) {
      case "fulfilled":
        return l.value;
      case "rejected":
        throw o = l.reason, rw(o), o;
      default:
        if (typeof l.status == "string") l.then(Nf, Nf);
        else {
          if (o = gt, o !== null && 100 < o.shellSuspendCounter)
            throw Error(r(482));
          o = l, o.status = "pending", o.then(
            function(m) {
              if (l.status === "pending") {
                var v = l;
                v.status = "fulfilled", v.value = m;
              }
            },
            function(m) {
              if (l.status === "pending") {
                var v = l;
                v.status = "rejected", v.reason = m;
              }
            }
          );
        }
        switch (l.status) {
          case "fulfilled":
            return l.value;
          case "rejected":
            throw o = l.reason, rw(o), o;
        }
        throw Jl = l, Ql;
    }
  }
  var Jl = null;
  function nw() {
    if (Jl === null) throw Error(r(459));
    var o = Jl;
    return Jl = null, o;
  }
  function rw(o) {
    if (o === Ql || o === Of)
      throw Error(r(483));
  }
  var so = !1;
  function Qm(o) {
    o.updateQueue = {
      baseState: o.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function Jm(o, l) {
    o = o.updateQueue, l.updateQueue === o && (l.updateQueue = {
      baseState: o.baseState,
      firstBaseUpdate: o.firstBaseUpdate,
      lastBaseUpdate: o.lastBaseUpdate,
      shared: o.shared,
      callbacks: null
    });
  }
  function lo(o) {
    return { lane: o, tag: 0, payload: null, callback: null, next: null };
  }
  function uo(o, l, c) {
    var m = o.updateQueue;
    if (m === null) return null;
    if (m = m.shared, (ot & 2) !== 0) {
      var v = m.pending;
      return v === null ? l.next = l : (l.next = v.next, v.next = l), m.pending = l, l = _f(o), Vx(o, null, c), l;
    }
    return Sf(o, m, l, c), _f(o);
  }
  function eu(o, l, c) {
    if (l = l.updateQueue, l !== null && (l = l.shared, (c & 4194048) !== 0)) {
      var m = l.lanes;
      m &= o.pendingLanes, c |= m, l.lanes = c, tf(o, c);
    }
  }
  function eg(o, l) {
    var c = o.updateQueue, m = o.alternate;
    if (m !== null && (m = m.updateQueue, c === m)) {
      var v = null, w = null;
      if (c = c.firstBaseUpdate, c !== null) {
        do {
          var M = {
            lane: c.lane,
            tag: c.tag,
            payload: c.payload,
            callback: null,
            next: null
          };
          w === null ? v = w = M : w = w.next = M, c = c.next;
        } while (c !== null);
        w === null ? v = w = l : w = w.next = l;
      } else v = w = l;
      c = {
        baseState: m.baseState,
        firstBaseUpdate: v,
        lastBaseUpdate: w,
        shared: m.shared,
        callbacks: m.callbacks
      }, o.updateQueue = c;
      return;
    }
    o = c.lastBaseUpdate, o === null ? c.firstBaseUpdate = l : o.next = l, c.lastBaseUpdate = l;
  }
  var tg = !1;
  function tu() {
    if (tg) {
      var o = as;
      if (o !== null) throw o;
    }
  }
  function nu(o, l, c, m) {
    tg = !1;
    var v = o.updateQueue;
    so = !1;
    var w = v.firstBaseUpdate, M = v.lastBaseUpdate, L = v.shared.pending;
    if (L !== null) {
      v.shared.pending = null;
      var X = L, ee = X.next;
      X.next = null, M === null ? w = ee : M.next = ee, M = X;
      var ue = o.alternate;
      ue !== null && (ue = ue.updateQueue, L = ue.lastBaseUpdate, L !== M && (L === null ? ue.firstBaseUpdate = ee : L.next = ee, ue.lastBaseUpdate = X));
    }
    if (w !== null) {
      var de = v.baseState;
      M = 0, ue = ee = X = null, L = w;
      do {
        var te = L.lane & -536870913, ne = te !== L.lane;
        if (ne ? (Ke & te) === te : (m & te) === te) {
          te !== 0 && te === os && (tg = !0), ue !== null && (ue = ue.next = {
            lane: 0,
            tag: L.tag,
            payload: L.payload,
            callback: null,
            next: null
          });
          e: {
            var ze = o, Ne = L;
            te = l;
            var ut = c;
            switch (Ne.tag) {
              case 1:
                if (ze = Ne.payload, typeof ze == "function") {
                  de = ze.call(ut, de, te);
                  break e;
                }
                de = ze;
                break e;
              case 3:
                ze.flags = ze.flags & -65537 | 128;
              case 0:
                if (ze = Ne.payload, te = typeof ze == "function" ? ze.call(ut, de, te) : ze, te == null) break e;
                de = h({}, de, te);
                break e;
              case 2:
                so = !0;
            }
          }
          te = L.callback, te !== null && (o.flags |= 64, ne && (o.flags |= 8192), ne = v.callbacks, ne === null ? v.callbacks = [te] : ne.push(te));
        } else
          ne = {
            lane: te,
            tag: L.tag,
            payload: L.payload,
            callback: L.callback,
            next: null
          }, ue === null ? (ee = ue = ne, X = de) : ue = ue.next = ne, M |= te;
        if (L = L.next, L === null) {
          if (L = v.shared.pending, L === null)
            break;
          ne = L, L = ne.next, ne.next = null, v.lastBaseUpdate = ne, v.shared.pending = null;
        }
      } while (!0);
      ue === null && (X = de), v.baseState = X, v.firstBaseUpdate = ee, v.lastBaseUpdate = ue, w === null && (v.shared.lanes = 0), vo |= M, o.lanes = M, o.memoizedState = de;
    }
  }
  function iw(o, l) {
    if (typeof o != "function")
      throw Error(r(191, o));
    o.call(l);
  }
  function ow(o, l) {
    var c = o.callbacks;
    if (c !== null)
      for (o.callbacks = null, o = 0; o < c.length; o++)
        iw(c[o], l);
  }
  var ss = W(null), Mf = W(0);
  function aw(o, l) {
    o = Ri, I(Mf, o), I(ss, l), Ri = o | l.baseLanes;
  }
  function ng() {
    I(Mf, Ri), I(ss, ss.current);
  }
  function rg() {
    Ri = Mf.current, Z(ss), Z(Mf);
  }
  var co = 0, He = null, st = null, Lt = null, Df = !1, ls = !1, fa = !1, Pf = 0, ru = 0, us = null, xD = 0;
  function Mt() {
    throw Error(r(321));
  }
  function ig(o, l) {
    if (l === null) return !1;
    for (var c = 0; c < l.length && c < o.length; c++)
      if (!Bn(o[c], l[c])) return !1;
    return !0;
  }
  function og(o, l, c, m, v, w) {
    return co = w, He = l, l.memoizedState = null, l.updateQueue = null, l.lanes = 0, z.H = o === null || o.memoizedState === null ? Vw : Uw, fa = !1, w = c(m, v), fa = !1, ls && (w = lw(
      l,
      c,
      m,
      v
    )), sw(o), w;
  }
  function sw(o) {
    z.H = Bf;
    var l = st !== null && st.next !== null;
    if (co = 0, Lt = st = He = null, Df = !1, ru = 0, us = null, l) throw Error(r(300));
    o === null || Wt || (o = o.dependencies, o !== null && Af(o) && (Wt = !0));
  }
  function lw(o, l, c, m) {
    He = o;
    var v = 0;
    do {
      if (ls && (us = null), ru = 0, ls = !1, 25 <= v) throw Error(r(301));
      if (v += 1, Lt = st = null, o.updateQueue != null) {
        var w = o.updateQueue;
        w.lastEffect = null, w.events = null, w.stores = null, w.memoCache != null && (w.memoCache.index = 0);
      }
      z.H = AD, w = l(c, m);
    } while (ls);
    return w;
  }
  function wD() {
    var o = z.H, l = o.useState()[0];
    return l = typeof l.then == "function" ? iu(l) : l, o = o.useState()[0], (st !== null ? st.memoizedState : null) !== o && (He.flags |= 1024), l;
  }
  function ag() {
    var o = Pf !== 0;
    return Pf = 0, o;
  }
  function sg(o, l, c) {
    l.updateQueue = o.updateQueue, l.flags &= -2053, o.lanes &= ~c;
  }
  function lg(o) {
    if (Df) {
      for (o = o.memoizedState; o !== null; ) {
        var l = o.queue;
        l !== null && (l.pending = null), o = o.next;
      }
      Df = !1;
    }
    co = 0, Lt = st = He = null, ls = !1, ru = Pf = 0, us = null;
  }
  function Rn() {
    var o = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return Lt === null ? He.memoizedState = Lt = o : Lt = Lt.next = o, Lt;
  }
  function Ft() {
    if (st === null) {
      var o = He.alternate;
      o = o !== null ? o.memoizedState : null;
    } else o = st.next;
    var l = Lt === null ? He.memoizedState : Lt.next;
    if (l !== null)
      Lt = l, st = o;
    else {
      if (o === null)
        throw He.alternate === null ? Error(r(467)) : Error(r(310));
      st = o, o = {
        memoizedState: st.memoizedState,
        baseState: st.baseState,
        baseQueue: st.baseQueue,
        queue: st.queue,
        next: null
      }, Lt === null ? He.memoizedState = Lt = o : Lt = Lt.next = o;
    }
    return Lt;
  }
  function ug() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function iu(o) {
    var l = ru;
    return ru += 1, us === null && (us = []), o = tw(us, o, l), l = He, (Lt === null ? l.memoizedState : Lt.next) === null && (l = l.alternate, z.H = l === null || l.memoizedState === null ? Vw : Uw), o;
  }
  function zf(o) {
    if (o !== null && typeof o == "object") {
      if (typeof o.then == "function") return iu(o);
      if (o.$$typeof === k) return ln(o);
    }
    throw Error(r(438, String(o)));
  }
  function cg(o) {
    var l = null, c = He.updateQueue;
    if (c !== null && (l = c.memoCache), l == null) {
      var m = He.alternate;
      m !== null && (m = m.updateQueue, m !== null && (m = m.memoCache, m != null && (l = {
        data: m.data.map(function(v) {
          return v.slice();
        }),
        index: 0
      })));
    }
    if (l == null && (l = { data: [], index: 0 }), c === null && (c = ug(), He.updateQueue = c), c.memoCache = l, c = l.data[l.index], c === void 0)
      for (c = l.data[l.index] = Array(o), m = 0; m < o; m++)
        c[m] = T;
    return l.index++, c;
  }
  function _i(o, l) {
    return typeof l == "function" ? l(o) : l;
  }
  function jf(o) {
    var l = Ft();
    return fg(l, st, o);
  }
  function fg(o, l, c) {
    var m = o.queue;
    if (m === null) throw Error(r(311));
    m.lastRenderedReducer = c;
    var v = o.baseQueue, w = m.pending;
    if (w !== null) {
      if (v !== null) {
        var M = v.next;
        v.next = w.next, w.next = M;
      }
      l.baseQueue = v = w, m.pending = null;
    }
    if (w = o.baseState, v === null) o.memoizedState = w;
    else {
      l = v.next;
      var L = M = null, X = null, ee = l, ue = !1;
      do {
        var de = ee.lane & -536870913;
        if (de !== ee.lane ? (Ke & de) === de : (co & de) === de) {
          var te = ee.revertLane;
          if (te === 0)
            X !== null && (X = X.next = {
              lane: 0,
              revertLane: 0,
              action: ee.action,
              hasEagerState: ee.hasEagerState,
              eagerState: ee.eagerState,
              next: null
            }), de === os && (ue = !0);
          else if ((co & te) === te) {
            ee = ee.next, te === os && (ue = !0);
            continue;
          } else
            de = {
              lane: 0,
              revertLane: ee.revertLane,
              action: ee.action,
              hasEagerState: ee.hasEagerState,
              eagerState: ee.eagerState,
              next: null
            }, X === null ? (L = X = de, M = w) : X = X.next = de, He.lanes |= te, vo |= te;
          de = ee.action, fa && c(w, de), w = ee.hasEagerState ? ee.eagerState : c(w, de);
        } else
          te = {
            lane: de,
            revertLane: ee.revertLane,
            action: ee.action,
            hasEagerState: ee.hasEagerState,
            eagerState: ee.eagerState,
            next: null
          }, X === null ? (L = X = te, M = w) : X = X.next = te, He.lanes |= de, vo |= de;
        ee = ee.next;
      } while (ee !== null && ee !== l);
      if (X === null ? M = w : X.next = L, !Bn(w, o.memoizedState) && (Wt = !0, ue && (c = as, c !== null)))
        throw c;
      o.memoizedState = w, o.baseState = M, o.baseQueue = X, m.lastRenderedState = w;
    }
    return v === null && (m.lanes = 0), [o.memoizedState, m.dispatch];
  }
  function dg(o) {
    var l = Ft(), c = l.queue;
    if (c === null) throw Error(r(311));
    c.lastRenderedReducer = o;
    var m = c.dispatch, v = c.pending, w = l.memoizedState;
    if (v !== null) {
      c.pending = null;
      var M = v = v.next;
      do
        w = o(w, M.action), M = M.next;
      while (M !== v);
      Bn(w, l.memoizedState) || (Wt = !0), l.memoizedState = w, l.baseQueue === null && (l.baseState = w), c.lastRenderedState = w;
    }
    return [w, m];
  }
  function uw(o, l, c) {
    var m = He, v = Ft(), w = et;
    if (w) {
      if (c === void 0) throw Error(r(407));
      c = c();
    } else c = l();
    var M = !Bn(
      (st || v).memoizedState,
      c
    );
    M && (v.memoizedState = c, Wt = !0), v = v.queue;
    var L = dw.bind(null, m, v, o);
    if (ou(2048, 8, L, [o]), v.getSnapshot !== l || M || Lt !== null && Lt.memoizedState.tag & 1) {
      if (m.flags |= 2048, cs(
        9,
        If(),
        fw.bind(
          null,
          m,
          v,
          c,
          l
        ),
        null
      ), gt === null) throw Error(r(349));
      w || (co & 124) !== 0 || cw(m, l, c);
    }
    return c;
  }
  function cw(o, l, c) {
    o.flags |= 16384, o = { getSnapshot: l, value: c }, l = He.updateQueue, l === null ? (l = ug(), He.updateQueue = l, l.stores = [o]) : (c = l.stores, c === null ? l.stores = [o] : c.push(o));
  }
  function fw(o, l, c, m) {
    l.value = c, l.getSnapshot = m, hw(l) && pw(o);
  }
  function dw(o, l, c) {
    return c(function() {
      hw(l) && pw(o);
    });
  }
  function hw(o) {
    var l = o.getSnapshot;
    o = o.value;
    try {
      var c = l();
      return !Bn(o, c);
    } catch {
      return !0;
    }
  }
  function pw(o) {
    var l = ts(o, 2);
    l !== null && Yn(l, o, 2);
  }
  function hg(o) {
    var l = Rn();
    if (typeof o == "function") {
      var c = o;
      if (o = c(), fa) {
        Ce(!0);
        try {
          c();
        } finally {
          Ce(!1);
        }
      }
    }
    return l.memoizedState = l.baseState = o, l.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: _i,
      lastRenderedState: o
    }, l;
  }
  function mw(o, l, c, m) {
    return o.baseState = c, fg(
      o,
      st,
      typeof m == "function" ? m : _i
    );
  }
  function SD(o, l, c, m, v) {
    if (Ff(o)) throw Error(r(485));
    if (o = l.action, o !== null) {
      var w = {
        payload: v,
        action: o,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(M) {
          w.listeners.push(M);
        }
      };
      z.T !== null ? c(!0) : w.isTransition = !1, m(w), c = l.pending, c === null ? (w.next = l.pending = w, gw(l, w)) : (w.next = c.next, l.pending = c.next = w);
    }
  }
  function gw(o, l) {
    var c = l.action, m = l.payload, v = o.state;
    if (l.isTransition) {
      var w = z.T, M = {};
      z.T = M;
      try {
        var L = c(v, m), X = z.S;
        X !== null && X(M, L), yw(o, l, L);
      } catch (ee) {
        pg(o, l, ee);
      } finally {
        z.T = w;
      }
    } else
      try {
        w = c(v, m), yw(o, l, w);
      } catch (ee) {
        pg(o, l, ee);
      }
  }
  function yw(o, l, c) {
    c !== null && typeof c == "object" && typeof c.then == "function" ? c.then(
      function(m) {
        vw(o, l, m);
      },
      function(m) {
        return pg(o, l, m);
      }
    ) : vw(o, l, c);
  }
  function vw(o, l, c) {
    l.status = "fulfilled", l.value = c, bw(l), o.state = c, l = o.pending, l !== null && (c = l.next, c === l ? o.pending = null : (c = c.next, l.next = c, gw(o, c)));
  }
  function pg(o, l, c) {
    var m = o.pending;
    if (o.pending = null, m !== null) {
      m = m.next;
      do
        l.status = "rejected", l.reason = c, bw(l), l = l.next;
      while (l !== m);
    }
    o.action = null;
  }
  function bw(o) {
    o = o.listeners;
    for (var l = 0; l < o.length; l++) (0, o[l])();
  }
  function xw(o, l) {
    return l;
  }
  function ww(o, l) {
    if (et) {
      var c = gt.formState;
      if (c !== null) {
        e: {
          var m = He;
          if (et) {
            if (At) {
              t: {
                for (var v = At, w = Br; v.nodeType !== 8; ) {
                  if (!w) {
                    v = null;
                    break t;
                  }
                  if (v = Cr(
                    v.nextSibling
                  ), v === null) {
                    v = null;
                    break t;
                  }
                }
                w = v.data, v = w === "F!" || w === "F" ? v : null;
              }
              if (v) {
                At = Cr(
                  v.nextSibling
                ), m = v.data === "F!";
                break e;
              }
            }
            sa(m);
          }
          m = !1;
        }
        m && (l = c[0]);
      }
    }
    return c = Rn(), c.memoizedState = c.baseState = l, m = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: xw,
      lastRenderedState: l
    }, c.queue = m, c = Bw.bind(
      null,
      He,
      m
    ), m.dispatch = c, m = hg(!1), w = bg.bind(
      null,
      He,
      !1,
      m.queue
    ), m = Rn(), v = {
      state: l,
      dispatch: null,
      action: o,
      pending: null
    }, m.queue = v, c = SD.bind(
      null,
      He,
      v,
      w,
      c
    ), v.dispatch = c, m.memoizedState = o, [l, c, !1];
  }
  function Sw(o) {
    var l = Ft();
    return _w(l, st, o);
  }
  function _w(o, l, c) {
    if (l = fg(
      o,
      l,
      xw
    )[0], o = jf(_i)[0], typeof l == "object" && l !== null && typeof l.then == "function")
      try {
        var m = iu(l);
      } catch (M) {
        throw M === Ql ? Of : M;
      }
    else m = l;
    l = Ft();
    var v = l.queue, w = v.dispatch;
    return c !== l.memoizedState && (He.flags |= 2048, cs(
      9,
      If(),
      _D.bind(null, v, c),
      null
    )), [m, w, o];
  }
  function _D(o, l) {
    o.action = l;
  }
  function Ew(o) {
    var l = Ft(), c = st;
    if (c !== null)
      return _w(l, c, o);
    Ft(), l = l.memoizedState, c = Ft();
    var m = c.queue.dispatch;
    return c.memoizedState = o, [l, m, !1];
  }
  function cs(o, l, c, m) {
    return o = { tag: o, create: c, deps: m, inst: l, next: null }, l = He.updateQueue, l === null && (l = ug(), He.updateQueue = l), c = l.lastEffect, c === null ? l.lastEffect = o.next = o : (m = c.next, c.next = o, o.next = m, l.lastEffect = o), o;
  }
  function If() {
    return { destroy: void 0, resource: void 0 };
  }
  function Cw() {
    return Ft().memoizedState;
  }
  function Lf(o, l, c, m) {
    var v = Rn();
    m = m === void 0 ? null : m, He.flags |= o, v.memoizedState = cs(
      1 | l,
      If(),
      c,
      m
    );
  }
  function ou(o, l, c, m) {
    var v = Ft();
    m = m === void 0 ? null : m;
    var w = v.memoizedState.inst;
    st !== null && m !== null && ig(m, st.memoizedState.deps) ? v.memoizedState = cs(l, w, c, m) : (He.flags |= o, v.memoizedState = cs(
      1 | l,
      w,
      c,
      m
    ));
  }
  function kw(o, l) {
    Lf(8390656, 8, o, l);
  }
  function Aw(o, l) {
    ou(2048, 8, o, l);
  }
  function Tw(o, l) {
    return ou(4, 2, o, l);
  }
  function Rw(o, l) {
    return ou(4, 4, o, l);
  }
  function Ow(o, l) {
    if (typeof l == "function") {
      o = o();
      var c = l(o);
      return function() {
        typeof c == "function" ? c() : l(null);
      };
    }
    if (l != null)
      return o = o(), l.current = o, function() {
        l.current = null;
      };
  }
  function Nw(o, l, c) {
    c = c != null ? c.concat([o]) : null, ou(4, 4, Ow.bind(null, l, o), c);
  }
  function mg() {
  }
  function Mw(o, l) {
    var c = Ft();
    l = l === void 0 ? null : l;
    var m = c.memoizedState;
    return l !== null && ig(l, m[1]) ? m[0] : (c.memoizedState = [o, l], o);
  }
  function Dw(o, l) {
    var c = Ft();
    l = l === void 0 ? null : l;
    var m = c.memoizedState;
    if (l !== null && ig(l, m[1]))
      return m[0];
    if (m = o(), fa) {
      Ce(!0);
      try {
        o();
      } finally {
        Ce(!1);
      }
    }
    return c.memoizedState = [m, l], m;
  }
  function gg(o, l, c) {
    return c === void 0 || (co & 1073741824) !== 0 ? o.memoizedState = l : (o.memoizedState = c, o = jS(), He.lanes |= o, vo |= o, c);
  }
  function Pw(o, l, c, m) {
    return Bn(c, l) ? c : ss.current !== null ? (o = gg(o, c, m), Bn(o, l) || (Wt = !0), o) : (co & 42) === 0 ? (Wt = !0, o.memoizedState = c) : (o = jS(), He.lanes |= o, vo |= o, l);
  }
  function zw(o, l, c, m, v) {
    var w = B.p;
    B.p = w !== 0 && 8 > w ? w : 8;
    var M = z.T, L = {};
    z.T = L, bg(o, !1, l, c);
    try {
      var X = v(), ee = z.S;
      if (ee !== null && ee(L, X), X !== null && typeof X == "object" && typeof X.then == "function") {
        var ue = bD(
          X,
          m
        );
        au(
          o,
          l,
          ue,
          qn(o)
        );
      } else
        au(
          o,
          l,
          m,
          qn(o)
        );
    } catch (de) {
      au(
        o,
        l,
        { then: function() {
        }, status: "rejected", reason: de },
        qn()
      );
    } finally {
      B.p = w, z.T = M;
    }
  }
  function ED() {
  }
  function yg(o, l, c, m) {
    if (o.tag !== 5) throw Error(r(476));
    var v = jw(o).queue;
    zw(
      o,
      v,
      l,
      q,
      c === null ? ED : function() {
        return Iw(o), c(m);
      }
    );
  }
  function jw(o) {
    var l = o.memoizedState;
    if (l !== null) return l;
    l = {
      memoizedState: q,
      baseState: q,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: _i,
        lastRenderedState: q
      },
      next: null
    };
    var c = {};
    return l.next = {
      memoizedState: c,
      baseState: c,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: _i,
        lastRenderedState: c
      },
      next: null
    }, o.memoizedState = l, o = o.alternate, o !== null && (o.memoizedState = l), l;
  }
  function Iw(o) {
    var l = jw(o).next.queue;
    au(o, l, {}, qn());
  }
  function vg() {
    return ln(Eu);
  }
  function Lw() {
    return Ft().memoizedState;
  }
  function Fw() {
    return Ft().memoizedState;
  }
  function CD(o) {
    for (var l = o.return; l !== null; ) {
      switch (l.tag) {
        case 24:
        case 3:
          var c = qn();
          o = lo(c);
          var m = uo(l, o, c);
          m !== null && (Yn(m, l, c), eu(m, l, c)), l = { cache: Xm() }, o.payload = l;
          return;
      }
      l = l.return;
    }
  }
  function kD(o, l, c) {
    var m = qn();
    c = {
      lane: m,
      revertLane: 0,
      action: c,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Ff(o) ? $w(l, c) : (c = Lm(o, l, c, m), c !== null && (Yn(c, o, m), Hw(c, l, m)));
  }
  function Bw(o, l, c) {
    var m = qn();
    au(o, l, c, m);
  }
  function au(o, l, c, m) {
    var v = {
      lane: m,
      revertLane: 0,
      action: c,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (Ff(o)) $w(l, v);
    else {
      var w = o.alternate;
      if (o.lanes === 0 && (w === null || w.lanes === 0) && (w = l.lastRenderedReducer, w !== null))
        try {
          var M = l.lastRenderedState, L = w(M, c);
          if (v.hasEagerState = !0, v.eagerState = L, Bn(L, M))
            return Sf(o, l, v, 0), gt === null && wf(), !1;
        } catch {
        } finally {
        }
      if (c = Lm(o, l, v, m), c !== null)
        return Yn(c, o, m), Hw(c, l, m), !0;
    }
    return !1;
  }
  function bg(o, l, c, m) {
    if (m = {
      lane: 2,
      revertLane: Zg(),
      action: m,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, Ff(o)) {
      if (l) throw Error(r(479));
    } else
      l = Lm(
        o,
        c,
        m,
        2
      ), l !== null && Yn(l, o, 2);
  }
  function Ff(o) {
    var l = o.alternate;
    return o === He || l !== null && l === He;
  }
  function $w(o, l) {
    ls = Df = !0;
    var c = o.pending;
    c === null ? l.next = l : (l.next = c.next, c.next = l), o.pending = l;
  }
  function Hw(o, l, c) {
    if ((c & 4194048) !== 0) {
      var m = l.lanes;
      m &= o.pendingLanes, c |= m, l.lanes = c, tf(o, c);
    }
  }
  var Bf = {
    readContext: ln,
    use: zf,
    useCallback: Mt,
    useContext: Mt,
    useEffect: Mt,
    useImperativeHandle: Mt,
    useLayoutEffect: Mt,
    useInsertionEffect: Mt,
    useMemo: Mt,
    useReducer: Mt,
    useRef: Mt,
    useState: Mt,
    useDebugValue: Mt,
    useDeferredValue: Mt,
    useTransition: Mt,
    useSyncExternalStore: Mt,
    useId: Mt,
    useHostTransitionStatus: Mt,
    useFormState: Mt,
    useActionState: Mt,
    useOptimistic: Mt,
    useMemoCache: Mt,
    useCacheRefresh: Mt
  }, Vw = {
    readContext: ln,
    use: zf,
    useCallback: function(o, l) {
      return Rn().memoizedState = [
        o,
        l === void 0 ? null : l
      ], o;
    },
    useContext: ln,
    useEffect: kw,
    useImperativeHandle: function(o, l, c) {
      c = c != null ? c.concat([o]) : null, Lf(
        4194308,
        4,
        Ow.bind(null, l, o),
        c
      );
    },
    useLayoutEffect: function(o, l) {
      return Lf(4194308, 4, o, l);
    },
    useInsertionEffect: function(o, l) {
      Lf(4, 2, o, l);
    },
    useMemo: function(o, l) {
      var c = Rn();
      l = l === void 0 ? null : l;
      var m = o();
      if (fa) {
        Ce(!0);
        try {
          o();
        } finally {
          Ce(!1);
        }
      }
      return c.memoizedState = [m, l], m;
    },
    useReducer: function(o, l, c) {
      var m = Rn();
      if (c !== void 0) {
        var v = c(l);
        if (fa) {
          Ce(!0);
          try {
            c(l);
          } finally {
            Ce(!1);
          }
        }
      } else v = l;
      return m.memoizedState = m.baseState = v, o = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: o,
        lastRenderedState: v
      }, m.queue = o, o = o.dispatch = kD.bind(
        null,
        He,
        o
      ), [m.memoizedState, o];
    },
    useRef: function(o) {
      var l = Rn();
      return o = { current: o }, l.memoizedState = o;
    },
    useState: function(o) {
      o = hg(o);
      var l = o.queue, c = Bw.bind(null, He, l);
      return l.dispatch = c, [o.memoizedState, c];
    },
    useDebugValue: mg,
    useDeferredValue: function(o, l) {
      var c = Rn();
      return gg(c, o, l);
    },
    useTransition: function() {
      var o = hg(!1);
      return o = zw.bind(
        null,
        He,
        o.queue,
        !0,
        !1
      ), Rn().memoizedState = o, [!1, o];
    },
    useSyncExternalStore: function(o, l, c) {
      var m = He, v = Rn();
      if (et) {
        if (c === void 0)
          throw Error(r(407));
        c = c();
      } else {
        if (c = l(), gt === null)
          throw Error(r(349));
        (Ke & 124) !== 0 || cw(m, l, c);
      }
      v.memoizedState = c;
      var w = { value: c, getSnapshot: l };
      return v.queue = w, kw(dw.bind(null, m, w, o), [
        o
      ]), m.flags |= 2048, cs(
        9,
        If(),
        fw.bind(
          null,
          m,
          w,
          c,
          l
        ),
        null
      ), c;
    },
    useId: function() {
      var o = Rn(), l = gt.identifierPrefix;
      if (et) {
        var c = xi, m = bi;
        c = (m & ~(1 << 32 - Ae(m) - 1)).toString(32) + c, l = "" + l + "R" + c, c = Pf++, 0 < c && (l += "H" + c.toString(32)), l += "";
      } else
        c = xD++, l = "" + l + "r" + c.toString(32) + "";
      return o.memoizedState = l;
    },
    useHostTransitionStatus: vg,
    useFormState: ww,
    useActionState: ww,
    useOptimistic: function(o) {
      var l = Rn();
      l.memoizedState = l.baseState = o;
      var c = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return l.queue = c, l = bg.bind(
        null,
        He,
        !0,
        c
      ), c.dispatch = l, [o, l];
    },
    useMemoCache: cg,
    useCacheRefresh: function() {
      return Rn().memoizedState = CD.bind(
        null,
        He
      );
    }
  }, Uw = {
    readContext: ln,
    use: zf,
    useCallback: Mw,
    useContext: ln,
    useEffect: Aw,
    useImperativeHandle: Nw,
    useInsertionEffect: Tw,
    useLayoutEffect: Rw,
    useMemo: Dw,
    useReducer: jf,
    useRef: Cw,
    useState: function() {
      return jf(_i);
    },
    useDebugValue: mg,
    useDeferredValue: function(o, l) {
      var c = Ft();
      return Pw(
        c,
        st.memoizedState,
        o,
        l
      );
    },
    useTransition: function() {
      var o = jf(_i)[0], l = Ft().memoizedState;
      return [
        typeof o == "boolean" ? o : iu(o),
        l
      ];
    },
    useSyncExternalStore: uw,
    useId: Lw,
    useHostTransitionStatus: vg,
    useFormState: Sw,
    useActionState: Sw,
    useOptimistic: function(o, l) {
      var c = Ft();
      return mw(c, st, o, l);
    },
    useMemoCache: cg,
    useCacheRefresh: Fw
  }, AD = {
    readContext: ln,
    use: zf,
    useCallback: Mw,
    useContext: ln,
    useEffect: Aw,
    useImperativeHandle: Nw,
    useInsertionEffect: Tw,
    useLayoutEffect: Rw,
    useMemo: Dw,
    useReducer: dg,
    useRef: Cw,
    useState: function() {
      return dg(_i);
    },
    useDebugValue: mg,
    useDeferredValue: function(o, l) {
      var c = Ft();
      return st === null ? gg(c, o, l) : Pw(
        c,
        st.memoizedState,
        o,
        l
      );
    },
    useTransition: function() {
      var o = dg(_i)[0], l = Ft().memoizedState;
      return [
        typeof o == "boolean" ? o : iu(o),
        l
      ];
    },
    useSyncExternalStore: uw,
    useId: Lw,
    useHostTransitionStatus: vg,
    useFormState: Ew,
    useActionState: Ew,
    useOptimistic: function(o, l) {
      var c = Ft();
      return st !== null ? mw(c, st, o, l) : (c.baseState = o, [o, c.queue.dispatch]);
    },
    useMemoCache: cg,
    useCacheRefresh: Fw
  }, fs = null, su = 0;
  function $f(o) {
    var l = su;
    return su += 1, fs === null && (fs = []), tw(fs, o, l);
  }
  function lu(o, l) {
    l = l.props.ref, o.ref = l !== void 0 ? l : null;
  }
  function Hf(o, l) {
    throw l.$$typeof === p ? Error(r(525)) : (o = Object.prototype.toString.call(l), Error(
      r(
        31,
        o === "[object Object]" ? "object with keys {" + Object.keys(l).join(", ") + "}" : o
      )
    ));
  }
  function qw(o) {
    var l = o._init;
    return l(o._payload);
  }
  function Yw(o) {
    function l(Q, K) {
      if (o) {
        var J = Q.deletions;
        J === null ? (Q.deletions = [K], Q.flags |= 16) : J.push(K);
      }
    }
    function c(Q, K) {
      if (!o) return null;
      for (; K !== null; )
        l(Q, K), K = K.sibling;
      return null;
    }
    function m(Q) {
      for (var K = /* @__PURE__ */ new Map(); Q !== null; )
        Q.key !== null ? K.set(Q.key, Q) : K.set(Q.index, Q), Q = Q.sibling;
      return K;
    }
    function v(Q, K) {
      return Q = vi(Q, K), Q.index = 0, Q.sibling = null, Q;
    }
    function w(Q, K, J) {
      return Q.index = J, o ? (J = Q.alternate, J !== null ? (J = J.index, J < K ? (Q.flags |= 67108866, K) : J) : (Q.flags |= 67108866, K)) : (Q.flags |= 1048576, K);
    }
    function M(Q) {
      return o && Q.alternate === null && (Q.flags |= 67108866), Q;
    }
    function L(Q, K, J, ce) {
      return K === null || K.tag !== 6 ? (K = Bm(J, Q.mode, ce), K.return = Q, K) : (K = v(K, J), K.return = Q, K);
    }
    function X(Q, K, J, ce) {
      var xe = J.type;
      return xe === b ? ue(
        Q,
        K,
        J.props.children,
        ce,
        J.key
      ) : K !== null && (K.elementType === xe || typeof xe == "object" && xe !== null && xe.$$typeof === F && qw(xe) === K.type) ? (K = v(K, J.props), lu(K, J), K.return = Q, K) : (K = Ef(
        J.type,
        J.key,
        J.props,
        null,
        Q.mode,
        ce
      ), lu(K, J), K.return = Q, K);
    }
    function ee(Q, K, J, ce) {
      return K === null || K.tag !== 4 || K.stateNode.containerInfo !== J.containerInfo || K.stateNode.implementation !== J.implementation ? (K = $m(J, Q.mode, ce), K.return = Q, K) : (K = v(K, J.children || []), K.return = Q, K);
    }
    function ue(Q, K, J, ce, xe) {
      return K === null || K.tag !== 7 ? (K = ra(
        J,
        Q.mode,
        ce,
        xe
      ), K.return = Q, K) : (K = v(K, J), K.return = Q, K);
    }
    function de(Q, K, J) {
      if (typeof K == "string" && K !== "" || typeof K == "number" || typeof K == "bigint")
        return K = Bm(
          "" + K,
          Q.mode,
          J
        ), K.return = Q, K;
      if (typeof K == "object" && K !== null) {
        switch (K.$$typeof) {
          case g:
            return J = Ef(
              K.type,
              K.key,
              K.props,
              null,
              Q.mode,
              J
            ), lu(J, K), J.return = Q, J;
          case y:
            return K = $m(
              K,
              Q.mode,
              J
            ), K.return = Q, K;
          case F:
            var ce = K._init;
            return K = ce(K._payload), de(Q, K, J);
        }
        if (U(K) || H(K))
          return K = ra(
            K,
            Q.mode,
            J,
            null
          ), K.return = Q, K;
        if (typeof K.then == "function")
          return de(Q, $f(K), J);
        if (K.$$typeof === k)
          return de(
            Q,
            Tf(Q, K),
            J
          );
        Hf(Q, K);
      }
      return null;
    }
    function te(Q, K, J, ce) {
      var xe = K !== null ? K.key : null;
      if (typeof J == "string" && J !== "" || typeof J == "number" || typeof J == "bigint")
        return xe !== null ? null : L(Q, K, "" + J, ce);
      if (typeof J == "object" && J !== null) {
        switch (J.$$typeof) {
          case g:
            return J.key === xe ? X(Q, K, J, ce) : null;
          case y:
            return J.key === xe ? ee(Q, K, J, ce) : null;
          case F:
            return xe = J._init, J = xe(J._payload), te(Q, K, J, ce);
        }
        if (U(J) || H(J))
          return xe !== null ? null : ue(Q, K, J, ce, null);
        if (typeof J.then == "function")
          return te(
            Q,
            K,
            $f(J),
            ce
          );
        if (J.$$typeof === k)
          return te(
            Q,
            K,
            Tf(Q, J),
            ce
          );
        Hf(Q, J);
      }
      return null;
    }
    function ne(Q, K, J, ce, xe) {
      if (typeof ce == "string" && ce !== "" || typeof ce == "number" || typeof ce == "bigint")
        return Q = Q.get(J) || null, L(K, Q, "" + ce, xe);
      if (typeof ce == "object" && ce !== null) {
        switch (ce.$$typeof) {
          case g:
            return Q = Q.get(
              ce.key === null ? J : ce.key
            ) || null, X(K, Q, ce, xe);
          case y:
            return Q = Q.get(
              ce.key === null ? J : ce.key
            ) || null, ee(K, Q, ce, xe);
          case F:
            var Ve = ce._init;
            return ce = Ve(ce._payload), ne(
              Q,
              K,
              J,
              ce,
              xe
            );
        }
        if (U(ce) || H(ce))
          return Q = Q.get(J) || null, ue(K, Q, ce, xe, null);
        if (typeof ce.then == "function")
          return ne(
            Q,
            K,
            J,
            $f(ce),
            xe
          );
        if (ce.$$typeof === k)
          return ne(
            Q,
            K,
            J,
            Tf(K, ce),
            xe
          );
        Hf(K, ce);
      }
      return null;
    }
    function ze(Q, K, J, ce) {
      for (var xe = null, Ve = null, Se = K, Me = K = 0, Zt = null; Se !== null && Me < J.length; Me++) {
        Se.index > Me ? (Zt = Se, Se = null) : Zt = Se.sibling;
        var Qe = te(
          Q,
          Se,
          J[Me],
          ce
        );
        if (Qe === null) {
          Se === null && (Se = Zt);
          break;
        }
        o && Se && Qe.alternate === null && l(Q, Se), K = w(Qe, K, Me), Ve === null ? xe = Qe : Ve.sibling = Qe, Ve = Qe, Se = Zt;
      }
      if (Me === J.length)
        return c(Q, Se), et && oa(Q, Me), xe;
      if (Se === null) {
        for (; Me < J.length; Me++)
          Se = de(Q, J[Me], ce), Se !== null && (K = w(
            Se,
            K,
            Me
          ), Ve === null ? xe = Se : Ve.sibling = Se, Ve = Se);
        return et && oa(Q, Me), xe;
      }
      for (Se = m(Se); Me < J.length; Me++)
        Zt = ne(
          Se,
          Q,
          Me,
          J[Me],
          ce
        ), Zt !== null && (o && Zt.alternate !== null && Se.delete(
          Zt.key === null ? Me : Zt.key
        ), K = w(
          Zt,
          K,
          Me
        ), Ve === null ? xe = Zt : Ve.sibling = Zt, Ve = Zt);
      return o && Se.forEach(function(Ao) {
        return l(Q, Ao);
      }), et && oa(Q, Me), xe;
    }
    function Ne(Q, K, J, ce) {
      if (J == null) throw Error(r(151));
      for (var xe = null, Ve = null, Se = K, Me = K = 0, Zt = null, Qe = J.next(); Se !== null && !Qe.done; Me++, Qe = J.next()) {
        Se.index > Me ? (Zt = Se, Se = null) : Zt = Se.sibling;
        var Ao = te(Q, Se, Qe.value, ce);
        if (Ao === null) {
          Se === null && (Se = Zt);
          break;
        }
        o && Se && Ao.alternate === null && l(Q, Se), K = w(Ao, K, Me), Ve === null ? xe = Ao : Ve.sibling = Ao, Ve = Ao, Se = Zt;
      }
      if (Qe.done)
        return c(Q, Se), et && oa(Q, Me), xe;
      if (Se === null) {
        for (; !Qe.done; Me++, Qe = J.next())
          Qe = de(Q, Qe.value, ce), Qe !== null && (K = w(Qe, K, Me), Ve === null ? xe = Qe : Ve.sibling = Qe, Ve = Qe);
        return et && oa(Q, Me), xe;
      }
      for (Se = m(Se); !Qe.done; Me++, Qe = J.next())
        Qe = ne(Se, Q, Me, Qe.value, ce), Qe !== null && (o && Qe.alternate !== null && Se.delete(Qe.key === null ? Me : Qe.key), K = w(Qe, K, Me), Ve === null ? xe = Qe : Ve.sibling = Qe, Ve = Qe);
      return o && Se.forEach(function(TP) {
        return l(Q, TP);
      }), et && oa(Q, Me), xe;
    }
    function ut(Q, K, J, ce) {
      if (typeof J == "object" && J !== null && J.type === b && J.key === null && (J = J.props.children), typeof J == "object" && J !== null) {
        switch (J.$$typeof) {
          case g:
            e: {
              for (var xe = J.key; K !== null; ) {
                if (K.key === xe) {
                  if (xe = J.type, xe === b) {
                    if (K.tag === 7) {
                      c(
                        Q,
                        K.sibling
                      ), ce = v(
                        K,
                        J.props.children
                      ), ce.return = Q, Q = ce;
                      break e;
                    }
                  } else if (K.elementType === xe || typeof xe == "object" && xe !== null && xe.$$typeof === F && qw(xe) === K.type) {
                    c(
                      Q,
                      K.sibling
                    ), ce = v(K, J.props), lu(ce, J), ce.return = Q, Q = ce;
                    break e;
                  }
                  c(Q, K);
                  break;
                } else l(Q, K);
                K = K.sibling;
              }
              J.type === b ? (ce = ra(
                J.props.children,
                Q.mode,
                ce,
                J.key
              ), ce.return = Q, Q = ce) : (ce = Ef(
                J.type,
                J.key,
                J.props,
                null,
                Q.mode,
                ce
              ), lu(ce, J), ce.return = Q, Q = ce);
            }
            return M(Q);
          case y:
            e: {
              for (xe = J.key; K !== null; ) {
                if (K.key === xe)
                  if (K.tag === 4 && K.stateNode.containerInfo === J.containerInfo && K.stateNode.implementation === J.implementation) {
                    c(
                      Q,
                      K.sibling
                    ), ce = v(K, J.children || []), ce.return = Q, Q = ce;
                    break e;
                  } else {
                    c(Q, K);
                    break;
                  }
                else l(Q, K);
                K = K.sibling;
              }
              ce = $m(J, Q.mode, ce), ce.return = Q, Q = ce;
            }
            return M(Q);
          case F:
            return xe = J._init, J = xe(J._payload), ut(
              Q,
              K,
              J,
              ce
            );
        }
        if (U(J))
          return ze(
            Q,
            K,
            J,
            ce
          );
        if (H(J)) {
          if (xe = H(J), typeof xe != "function") throw Error(r(150));
          return J = xe.call(J), Ne(
            Q,
            K,
            J,
            ce
          );
        }
        if (typeof J.then == "function")
          return ut(
            Q,
            K,
            $f(J),
            ce
          );
        if (J.$$typeof === k)
          return ut(
            Q,
            K,
            Tf(Q, J),
            ce
          );
        Hf(Q, J);
      }
      return typeof J == "string" && J !== "" || typeof J == "number" || typeof J == "bigint" ? (J = "" + J, K !== null && K.tag === 6 ? (c(Q, K.sibling), ce = v(K, J), ce.return = Q, Q = ce) : (c(Q, K), ce = Bm(J, Q.mode, ce), ce.return = Q, Q = ce), M(Q)) : c(Q, K);
    }
    return function(Q, K, J, ce) {
      try {
        su = 0;
        var xe = ut(
          Q,
          K,
          J,
          ce
        );
        return fs = null, xe;
      } catch (Se) {
        if (Se === Ql || Se === Of) throw Se;
        var Ve = $n(29, Se, null, Q.mode);
        return Ve.lanes = ce, Ve.return = Q, Ve;
      } finally {
      }
    };
  }
  var ds = Yw(!0), Gw = Yw(!1), cr = W(null), $r = null;
  function fo(o) {
    var l = o.alternate;
    I(Gt, Gt.current & 1), I(cr, o), $r === null && (l === null || ss.current !== null || l.memoizedState !== null) && ($r = o);
  }
  function Xw(o) {
    if (o.tag === 22) {
      if (I(Gt, Gt.current), I(cr, o), $r === null) {
        var l = o.alternate;
        l !== null && l.memoizedState !== null && ($r = o);
      }
    } else ho();
  }
  function ho() {
    I(Gt, Gt.current), I(cr, cr.current);
  }
  function Ei(o) {
    Z(cr), $r === o && ($r = null), Z(Gt);
  }
  var Gt = W(0);
  function Vf(o) {
    for (var l = o; l !== null; ) {
      if (l.tag === 13) {
        var c = l.memoizedState;
        if (c !== null && (c = c.dehydrated, c === null || c.data === "$?" || u0(c)))
          return l;
      } else if (l.tag === 19 && l.memoizedProps.revealOrder !== void 0) {
        if ((l.flags & 128) !== 0) return l;
      } else if (l.child !== null) {
        l.child.return = l, l = l.child;
        continue;
      }
      if (l === o) break;
      for (; l.sibling === null; ) {
        if (l.return === null || l.return === o) return null;
        l = l.return;
      }
      l.sibling.return = l.return, l = l.sibling;
    }
    return null;
  }
  function xg(o, l, c, m) {
    l = o.memoizedState, c = c(m, l), c = c == null ? l : h({}, l, c), o.memoizedState = c, o.lanes === 0 && (o.updateQueue.baseState = c);
  }
  var wg = {
    enqueueSetState: function(o, l, c) {
      o = o._reactInternals;
      var m = qn(), v = lo(m);
      v.payload = l, c != null && (v.callback = c), l = uo(o, v, m), l !== null && (Yn(l, o, m), eu(l, o, m));
    },
    enqueueReplaceState: function(o, l, c) {
      o = o._reactInternals;
      var m = qn(), v = lo(m);
      v.tag = 1, v.payload = l, c != null && (v.callback = c), l = uo(o, v, m), l !== null && (Yn(l, o, m), eu(l, o, m));
    },
    enqueueForceUpdate: function(o, l) {
      o = o._reactInternals;
      var c = qn(), m = lo(c);
      m.tag = 2, l != null && (m.callback = l), l = uo(o, m, c), l !== null && (Yn(l, o, c), eu(l, o, c));
    }
  };
  function Ww(o, l, c, m, v, w, M) {
    return o = o.stateNode, typeof o.shouldComponentUpdate == "function" ? o.shouldComponentUpdate(m, w, M) : l.prototype && l.prototype.isPureReactComponent ? !Ul(c, m) || !Ul(v, w) : !0;
  }
  function Kw(o, l, c, m) {
    o = l.state, typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps(c, m), typeof l.UNSAFE_componentWillReceiveProps == "function" && l.UNSAFE_componentWillReceiveProps(c, m), l.state !== o && wg.enqueueReplaceState(l, l.state, null);
  }
  function da(o, l) {
    var c = l;
    if ("ref" in l) {
      c = {};
      for (var m in l)
        m !== "ref" && (c[m] = l[m]);
    }
    if (o = o.defaultProps) {
      c === l && (c = h({}, c));
      for (var v in o)
        c[v] === void 0 && (c[v] = o[v]);
    }
    return c;
  }
  var Uf = typeof reportError == "function" ? reportError : function(o) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var l = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof o == "object" && o !== null && typeof o.message == "string" ? String(o.message) : String(o),
        error: o
      });
      if (!window.dispatchEvent(l)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", o);
      return;
    }
    console.error(o);
  };
  function Zw(o) {
    Uf(o);
  }
  function Qw(o) {
    console.error(o);
  }
  function Jw(o) {
    Uf(o);
  }
  function qf(o, l) {
    try {
      var c = o.onUncaughtError;
      c(l.value, { componentStack: l.stack });
    } catch (m) {
      setTimeout(function() {
        throw m;
      });
    }
  }
  function eS(o, l, c) {
    try {
      var m = o.onCaughtError;
      m(c.value, {
        componentStack: c.stack,
        errorBoundary: l.tag === 1 ? l.stateNode : null
      });
    } catch (v) {
      setTimeout(function() {
        throw v;
      });
    }
  }
  function Sg(o, l, c) {
    return c = lo(c), c.tag = 3, c.payload = { element: null }, c.callback = function() {
      qf(o, l);
    }, c;
  }
  function tS(o) {
    return o = lo(o), o.tag = 3, o;
  }
  function nS(o, l, c, m) {
    var v = c.type.getDerivedStateFromError;
    if (typeof v == "function") {
      var w = m.value;
      o.payload = function() {
        return v(w);
      }, o.callback = function() {
        eS(l, c, m);
      };
    }
    var M = c.stateNode;
    M !== null && typeof M.componentDidCatch == "function" && (o.callback = function() {
      eS(l, c, m), typeof v != "function" && (bo === null ? bo = /* @__PURE__ */ new Set([this]) : bo.add(this));
      var L = m.stack;
      this.componentDidCatch(m.value, {
        componentStack: L !== null ? L : ""
      });
    });
  }
  function TD(o, l, c, m, v) {
    if (c.flags |= 32768, m !== null && typeof m == "object" && typeof m.then == "function") {
      if (l = c.alternate, l !== null && Wl(
        l,
        c,
        v,
        !0
      ), c = cr.current, c !== null) {
        switch (c.tag) {
          case 13:
            return $r === null ? Yg() : c.alternate === null && Tt === 0 && (Tt = 3), c.flags &= -257, c.flags |= 65536, c.lanes = v, m === Zm ? c.flags |= 16384 : (l = c.updateQueue, l === null ? c.updateQueue = /* @__PURE__ */ new Set([m]) : l.add(m), Xg(o, m, v)), !1;
          case 22:
            return c.flags |= 65536, m === Zm ? c.flags |= 16384 : (l = c.updateQueue, l === null ? (l = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([m])
            }, c.updateQueue = l) : (c = l.retryQueue, c === null ? l.retryQueue = /* @__PURE__ */ new Set([m]) : c.add(m)), Xg(o, m, v)), !1;
        }
        throw Error(r(435, c.tag));
      }
      return Xg(o, m, v), Yg(), !1;
    }
    if (et)
      return l = cr.current, l !== null ? ((l.flags & 65536) === 0 && (l.flags |= 256), l.flags |= 65536, l.lanes = v, m !== Um && (o = Error(r(422), { cause: m }), Xl(ar(o, c)))) : (m !== Um && (l = Error(r(423), {
        cause: m
      }), Xl(
        ar(l, c)
      )), o = o.current.alternate, o.flags |= 65536, v &= -v, o.lanes |= v, m = ar(m, c), v = Sg(
        o.stateNode,
        m,
        v
      ), eg(o, v), Tt !== 4 && (Tt = 2)), !1;
    var w = Error(r(520), { cause: m });
    if (w = ar(w, c), mu === null ? mu = [w] : mu.push(w), Tt !== 4 && (Tt = 2), l === null) return !0;
    m = ar(m, c), c = l;
    do {
      switch (c.tag) {
        case 3:
          return c.flags |= 65536, o = v & -v, c.lanes |= o, o = Sg(c.stateNode, m, o), eg(c, o), !1;
        case 1:
          if (l = c.type, w = c.stateNode, (c.flags & 128) === 0 && (typeof l.getDerivedStateFromError == "function" || w !== null && typeof w.componentDidCatch == "function" && (bo === null || !bo.has(w))))
            return c.flags |= 65536, v &= -v, c.lanes |= v, v = tS(v), nS(
              v,
              o,
              c,
              m
            ), eg(c, v), !1;
      }
      c = c.return;
    } while (c !== null);
    return !1;
  }
  var rS = Error(r(461)), Wt = !1;
  function en(o, l, c, m) {
    l.child = o === null ? Gw(l, null, c, m) : ds(
      l,
      o.child,
      c,
      m
    );
  }
  function iS(o, l, c, m, v) {
    c = c.render;
    var w = l.ref;
    if ("ref" in m) {
      var M = {};
      for (var L in m)
        L !== "ref" && (M[L] = m[L]);
    } else M = m;
    return ua(l), m = og(
      o,
      l,
      c,
      M,
      w,
      v
    ), L = ag(), o !== null && !Wt ? (sg(o, l, v), Ci(o, l, v)) : (et && L && Hm(l), l.flags |= 1, en(o, l, m, v), l.child);
  }
  function oS(o, l, c, m, v) {
    if (o === null) {
      var w = c.type;
      return typeof w == "function" && !Fm(w) && w.defaultProps === void 0 && c.compare === null ? (l.tag = 15, l.type = w, aS(
        o,
        l,
        w,
        m,
        v
      )) : (o = Ef(
        c.type,
        null,
        m,
        l,
        l.mode,
        v
      ), o.ref = l.ref, o.return = l, l.child = o);
    }
    if (w = o.child, !Og(o, v)) {
      var M = w.memoizedProps;
      if (c = c.compare, c = c !== null ? c : Ul, c(M, m) && o.ref === l.ref)
        return Ci(o, l, v);
    }
    return l.flags |= 1, o = vi(w, m), o.ref = l.ref, o.return = l, l.child = o;
  }
  function aS(o, l, c, m, v) {
    if (o !== null) {
      var w = o.memoizedProps;
      if (Ul(w, m) && o.ref === l.ref)
        if (Wt = !1, l.pendingProps = m = w, Og(o, v))
          (o.flags & 131072) !== 0 && (Wt = !0);
        else
          return l.lanes = o.lanes, Ci(o, l, v);
    }
    return _g(
      o,
      l,
      c,
      m,
      v
    );
  }
  function sS(o, l, c) {
    var m = l.pendingProps, v = m.children, w = o !== null ? o.memoizedState : null;
    if (m.mode === "hidden") {
      if ((l.flags & 128) !== 0) {
        if (m = w !== null ? w.baseLanes | c : c, o !== null) {
          for (v = l.child = o.child, w = 0; v !== null; )
            w = w | v.lanes | v.childLanes, v = v.sibling;
          l.childLanes = w & ~m;
        } else l.childLanes = 0, l.child = null;
        return lS(
          o,
          l,
          m,
          c
        );
      }
      if ((c & 536870912) !== 0)
        l.memoizedState = { baseLanes: 0, cachePool: null }, o !== null && Rf(
          l,
          w !== null ? w.cachePool : null
        ), w !== null ? aw(l, w) : ng(), Xw(l);
      else
        return l.lanes = l.childLanes = 536870912, lS(
          o,
          l,
          w !== null ? w.baseLanes | c : c,
          c
        );
    } else
      w !== null ? (Rf(l, w.cachePool), aw(l, w), ho(), l.memoizedState = null) : (o !== null && Rf(l, null), ng(), ho());
    return en(o, l, v, c), l.child;
  }
  function lS(o, l, c, m) {
    var v = Km();
    return v = v === null ? null : { parent: Yt._currentValue, pool: v }, l.memoizedState = {
      baseLanes: c,
      cachePool: v
    }, o !== null && Rf(l, null), ng(), Xw(l), o !== null && Wl(o, l, m, !0), null;
  }
  function Yf(o, l) {
    var c = l.ref;
    if (c === null)
      o !== null && o.ref !== null && (l.flags |= 4194816);
    else {
      if (typeof c != "function" && typeof c != "object")
        throw Error(r(284));
      (o === null || o.ref !== c) && (l.flags |= 4194816);
    }
  }
  function _g(o, l, c, m, v) {
    return ua(l), c = og(
      o,
      l,
      c,
      m,
      void 0,
      v
    ), m = ag(), o !== null && !Wt ? (sg(o, l, v), Ci(o, l, v)) : (et && m && Hm(l), l.flags |= 1, en(o, l, c, v), l.child);
  }
  function uS(o, l, c, m, v, w) {
    return ua(l), l.updateQueue = null, c = lw(
      l,
      m,
      c,
      v
    ), sw(o), m = ag(), o !== null && !Wt ? (sg(o, l, w), Ci(o, l, w)) : (et && m && Hm(l), l.flags |= 1, en(o, l, c, w), l.child);
  }
  function cS(o, l, c, m, v) {
    if (ua(l), l.stateNode === null) {
      var w = ns, M = c.contextType;
      typeof M == "object" && M !== null && (w = ln(M)), w = new c(m, w), l.memoizedState = w.state !== null && w.state !== void 0 ? w.state : null, w.updater = wg, l.stateNode = w, w._reactInternals = l, w = l.stateNode, w.props = m, w.state = l.memoizedState, w.refs = {}, Qm(l), M = c.contextType, w.context = typeof M == "object" && M !== null ? ln(M) : ns, w.state = l.memoizedState, M = c.getDerivedStateFromProps, typeof M == "function" && (xg(
        l,
        c,
        M,
        m
      ), w.state = l.memoizedState), typeof c.getDerivedStateFromProps == "function" || typeof w.getSnapshotBeforeUpdate == "function" || typeof w.UNSAFE_componentWillMount != "function" && typeof w.componentWillMount != "function" || (M = w.state, typeof w.componentWillMount == "function" && w.componentWillMount(), typeof w.UNSAFE_componentWillMount == "function" && w.UNSAFE_componentWillMount(), M !== w.state && wg.enqueueReplaceState(w, w.state, null), nu(l, m, w, v), tu(), w.state = l.memoizedState), typeof w.componentDidMount == "function" && (l.flags |= 4194308), m = !0;
    } else if (o === null) {
      w = l.stateNode;
      var L = l.memoizedProps, X = da(c, L);
      w.props = X;
      var ee = w.context, ue = c.contextType;
      M = ns, typeof ue == "object" && ue !== null && (M = ln(ue));
      var de = c.getDerivedStateFromProps;
      ue = typeof de == "function" || typeof w.getSnapshotBeforeUpdate == "function", L = l.pendingProps !== L, ue || typeof w.UNSAFE_componentWillReceiveProps != "function" && typeof w.componentWillReceiveProps != "function" || (L || ee !== M) && Kw(
        l,
        w,
        m,
        M
      ), so = !1;
      var te = l.memoizedState;
      w.state = te, nu(l, m, w, v), tu(), ee = l.memoizedState, L || te !== ee || so ? (typeof de == "function" && (xg(
        l,
        c,
        de,
        m
      ), ee = l.memoizedState), (X = so || Ww(
        l,
        c,
        X,
        m,
        te,
        ee,
        M
      )) ? (ue || typeof w.UNSAFE_componentWillMount != "function" && typeof w.componentWillMount != "function" || (typeof w.componentWillMount == "function" && w.componentWillMount(), typeof w.UNSAFE_componentWillMount == "function" && w.UNSAFE_componentWillMount()), typeof w.componentDidMount == "function" && (l.flags |= 4194308)) : (typeof w.componentDidMount == "function" && (l.flags |= 4194308), l.memoizedProps = m, l.memoizedState = ee), w.props = m, w.state = ee, w.context = M, m = X) : (typeof w.componentDidMount == "function" && (l.flags |= 4194308), m = !1);
    } else {
      w = l.stateNode, Jm(o, l), M = l.memoizedProps, ue = da(c, M), w.props = ue, de = l.pendingProps, te = w.context, ee = c.contextType, X = ns, typeof ee == "object" && ee !== null && (X = ln(ee)), L = c.getDerivedStateFromProps, (ee = typeof L == "function" || typeof w.getSnapshotBeforeUpdate == "function") || typeof w.UNSAFE_componentWillReceiveProps != "function" && typeof w.componentWillReceiveProps != "function" || (M !== de || te !== X) && Kw(
        l,
        w,
        m,
        X
      ), so = !1, te = l.memoizedState, w.state = te, nu(l, m, w, v), tu();
      var ne = l.memoizedState;
      M !== de || te !== ne || so || o !== null && o.dependencies !== null && Af(o.dependencies) ? (typeof L == "function" && (xg(
        l,
        c,
        L,
        m
      ), ne = l.memoizedState), (ue = so || Ww(
        l,
        c,
        ue,
        m,
        te,
        ne,
        X
      ) || o !== null && o.dependencies !== null && Af(o.dependencies)) ? (ee || typeof w.UNSAFE_componentWillUpdate != "function" && typeof w.componentWillUpdate != "function" || (typeof w.componentWillUpdate == "function" && w.componentWillUpdate(m, ne, X), typeof w.UNSAFE_componentWillUpdate == "function" && w.UNSAFE_componentWillUpdate(
        m,
        ne,
        X
      )), typeof w.componentDidUpdate == "function" && (l.flags |= 4), typeof w.getSnapshotBeforeUpdate == "function" && (l.flags |= 1024)) : (typeof w.componentDidUpdate != "function" || M === o.memoizedProps && te === o.memoizedState || (l.flags |= 4), typeof w.getSnapshotBeforeUpdate != "function" || M === o.memoizedProps && te === o.memoizedState || (l.flags |= 1024), l.memoizedProps = m, l.memoizedState = ne), w.props = m, w.state = ne, w.context = X, m = ue) : (typeof w.componentDidUpdate != "function" || M === o.memoizedProps && te === o.memoizedState || (l.flags |= 4), typeof w.getSnapshotBeforeUpdate != "function" || M === o.memoizedProps && te === o.memoizedState || (l.flags |= 1024), m = !1);
    }
    return w = m, Yf(o, l), m = (l.flags & 128) !== 0, w || m ? (w = l.stateNode, c = m && typeof c.getDerivedStateFromError != "function" ? null : w.render(), l.flags |= 1, o !== null && m ? (l.child = ds(
      l,
      o.child,
      null,
      v
    ), l.child = ds(
      l,
      null,
      c,
      v
    )) : en(o, l, c, v), l.memoizedState = w.state, o = l.child) : o = Ci(
      o,
      l,
      v
    ), o;
  }
  function fS(o, l, c, m) {
    return Gl(), l.flags |= 256, en(o, l, c, m), l.child;
  }
  var Eg = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function Cg(o) {
    return { baseLanes: o, cachePool: Qx() };
  }
  function kg(o, l, c) {
    return o = o !== null ? o.childLanes & ~c : 0, l && (o |= fr), o;
  }
  function dS(o, l, c) {
    var m = l.pendingProps, v = !1, w = (l.flags & 128) !== 0, M;
    if ((M = w) || (M = o !== null && o.memoizedState === null ? !1 : (Gt.current & 2) !== 0), M && (v = !0, l.flags &= -129), M = (l.flags & 32) !== 0, l.flags &= -33, o === null) {
      if (et) {
        if (v ? fo(l) : ho(), et) {
          var L = At, X;
          if (X = L) {
            e: {
              for (X = L, L = Br; X.nodeType !== 8; ) {
                if (!L) {
                  L = null;
                  break e;
                }
                if (X = Cr(
                  X.nextSibling
                ), X === null) {
                  L = null;
                  break e;
                }
              }
              L = X;
            }
            L !== null ? (l.memoizedState = {
              dehydrated: L,
              treeContext: ia !== null ? { id: bi, overflow: xi } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, X = $n(
              18,
              null,
              null,
              0
            ), X.stateNode = L, X.return = l, l.child = X, vn = l, At = null, X = !0) : X = !1;
          }
          X || sa(l);
        }
        if (L = l.memoizedState, L !== null && (L = L.dehydrated, L !== null))
          return u0(L) ? l.lanes = 32 : l.lanes = 536870912, null;
        Ei(l);
      }
      return L = m.children, m = m.fallback, v ? (ho(), v = l.mode, L = Gf(
        { mode: "hidden", children: L },
        v
      ), m = ra(
        m,
        v,
        c,
        null
      ), L.return = l, m.return = l, L.sibling = m, l.child = L, v = l.child, v.memoizedState = Cg(c), v.childLanes = kg(
        o,
        M,
        c
      ), l.memoizedState = Eg, m) : (fo(l), Ag(l, L));
    }
    if (X = o.memoizedState, X !== null && (L = X.dehydrated, L !== null)) {
      if (w)
        l.flags & 256 ? (fo(l), l.flags &= -257, l = Tg(
          o,
          l,
          c
        )) : l.memoizedState !== null ? (ho(), l.child = o.child, l.flags |= 128, l = null) : (ho(), v = m.fallback, L = l.mode, m = Gf(
          { mode: "visible", children: m.children },
          L
        ), v = ra(
          v,
          L,
          c,
          null
        ), v.flags |= 2, m.return = l, v.return = l, m.sibling = v, l.child = m, ds(
          l,
          o.child,
          null,
          c
        ), m = l.child, m.memoizedState = Cg(c), m.childLanes = kg(
          o,
          M,
          c
        ), l.memoizedState = Eg, l = v);
      else if (fo(l), u0(L)) {
        if (M = L.nextSibling && L.nextSibling.dataset, M) var ee = M.dgst;
        M = ee, m = Error(r(419)), m.stack = "", m.digest = M, Xl({ value: m, source: null, stack: null }), l = Tg(
          o,
          l,
          c
        );
      } else if (Wt || Wl(o, l, c, !1), M = (c & o.childLanes) !== 0, Wt || M) {
        if (M = gt, M !== null && (m = c & -c, m = (m & 42) !== 0 ? 1 : Rl(m), m = (m & (M.suspendedLanes | c)) !== 0 ? 0 : m, m !== 0 && m !== X.retryLane))
          throw X.retryLane = m, ts(o, m), Yn(M, o, m), rS;
        L.data === "$?" || Yg(), l = Tg(
          o,
          l,
          c
        );
      } else
        L.data === "$?" ? (l.flags |= 192, l.child = o.child, l = null) : (o = X.treeContext, At = Cr(
          L.nextSibling
        ), vn = l, et = !0, aa = null, Br = !1, o !== null && (lr[ur++] = bi, lr[ur++] = xi, lr[ur++] = ia, bi = o.id, xi = o.overflow, ia = l), l = Ag(
          l,
          m.children
        ), l.flags |= 4096);
      return l;
    }
    return v ? (ho(), v = m.fallback, L = l.mode, X = o.child, ee = X.sibling, m = vi(X, {
      mode: "hidden",
      children: m.children
    }), m.subtreeFlags = X.subtreeFlags & 65011712, ee !== null ? v = vi(ee, v) : (v = ra(
      v,
      L,
      c,
      null
    ), v.flags |= 2), v.return = l, m.return = l, m.sibling = v, l.child = m, m = v, v = l.child, L = o.child.memoizedState, L === null ? L = Cg(c) : (X = L.cachePool, X !== null ? (ee = Yt._currentValue, X = X.parent !== ee ? { parent: ee, pool: ee } : X) : X = Qx(), L = {
      baseLanes: L.baseLanes | c,
      cachePool: X
    }), v.memoizedState = L, v.childLanes = kg(
      o,
      M,
      c
    ), l.memoizedState = Eg, m) : (fo(l), c = o.child, o = c.sibling, c = vi(c, {
      mode: "visible",
      children: m.children
    }), c.return = l, c.sibling = null, o !== null && (M = l.deletions, M === null ? (l.deletions = [o], l.flags |= 16) : M.push(o)), l.child = c, l.memoizedState = null, c);
  }
  function Ag(o, l) {
    return l = Gf(
      { mode: "visible", children: l },
      o.mode
    ), l.return = o, o.child = l;
  }
  function Gf(o, l) {
    return o = $n(22, o, null, l), o.lanes = 0, o.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }, o;
  }
  function Tg(o, l, c) {
    return ds(l, o.child, null, c), o = Ag(
      l,
      l.pendingProps.children
    ), o.flags |= 2, l.memoizedState = null, o;
  }
  function hS(o, l, c) {
    o.lanes |= l;
    var m = o.alternate;
    m !== null && (m.lanes |= l), Ym(o.return, l, c);
  }
  function Rg(o, l, c, m, v) {
    var w = o.memoizedState;
    w === null ? o.memoizedState = {
      isBackwards: l,
      rendering: null,
      renderingStartTime: 0,
      last: m,
      tail: c,
      tailMode: v
    } : (w.isBackwards = l, w.rendering = null, w.renderingStartTime = 0, w.last = m, w.tail = c, w.tailMode = v);
  }
  function pS(o, l, c) {
    var m = l.pendingProps, v = m.revealOrder, w = m.tail;
    if (en(o, l, m.children, c), m = Gt.current, (m & 2) !== 0)
      m = m & 1 | 2, l.flags |= 128;
    else {
      if (o !== null && (o.flags & 128) !== 0)
        e: for (o = l.child; o !== null; ) {
          if (o.tag === 13)
            o.memoizedState !== null && hS(o, c, l);
          else if (o.tag === 19)
            hS(o, c, l);
          else if (o.child !== null) {
            o.child.return = o, o = o.child;
            continue;
          }
          if (o === l) break e;
          for (; o.sibling === null; ) {
            if (o.return === null || o.return === l)
              break e;
            o = o.return;
          }
          o.sibling.return = o.return, o = o.sibling;
        }
      m &= 1;
    }
    switch (I(Gt, m), v) {
      case "forwards":
        for (c = l.child, v = null; c !== null; )
          o = c.alternate, o !== null && Vf(o) === null && (v = c), c = c.sibling;
        c = v, c === null ? (v = l.child, l.child = null) : (v = c.sibling, c.sibling = null), Rg(
          l,
          !1,
          v,
          c,
          w
        );
        break;
      case "backwards":
        for (c = null, v = l.child, l.child = null; v !== null; ) {
          if (o = v.alternate, o !== null && Vf(o) === null) {
            l.child = v;
            break;
          }
          o = v.sibling, v.sibling = c, c = v, v = o;
        }
        Rg(
          l,
          !0,
          c,
          null,
          w
        );
        break;
      case "together":
        Rg(l, !1, null, null, void 0);
        break;
      default:
        l.memoizedState = null;
    }
    return l.child;
  }
  function Ci(o, l, c) {
    if (o !== null && (l.dependencies = o.dependencies), vo |= l.lanes, (c & l.childLanes) === 0)
      if (o !== null) {
        if (Wl(
          o,
          l,
          c,
          !1
        ), (c & l.childLanes) === 0)
          return null;
      } else return null;
    if (o !== null && l.child !== o.child)
      throw Error(r(153));
    if (l.child !== null) {
      for (o = l.child, c = vi(o, o.pendingProps), l.child = c, c.return = l; o.sibling !== null; )
        o = o.sibling, c = c.sibling = vi(o, o.pendingProps), c.return = l;
      c.sibling = null;
    }
    return l.child;
  }
  function Og(o, l) {
    return (o.lanes & l) !== 0 ? !0 : (o = o.dependencies, !!(o !== null && Af(o)));
  }
  function RD(o, l, c) {
    switch (l.tag) {
      case 3:
        he(l, l.stateNode.containerInfo), ao(l, Yt, o.memoizedState.cache), Gl();
        break;
      case 27:
      case 5:
        je(l);
        break;
      case 4:
        he(l, l.stateNode.containerInfo);
        break;
      case 10:
        ao(
          l,
          l.type,
          l.memoizedProps.value
        );
        break;
      case 13:
        var m = l.memoizedState;
        if (m !== null)
          return m.dehydrated !== null ? (fo(l), l.flags |= 128, null) : (c & l.child.childLanes) !== 0 ? dS(o, l, c) : (fo(l), o = Ci(
            o,
            l,
            c
          ), o !== null ? o.sibling : null);
        fo(l);
        break;
      case 19:
        var v = (o.flags & 128) !== 0;
        if (m = (c & l.childLanes) !== 0, m || (Wl(
          o,
          l,
          c,
          !1
        ), m = (c & l.childLanes) !== 0), v) {
          if (m)
            return pS(
              o,
              l,
              c
            );
          l.flags |= 128;
        }
        if (v = l.memoizedState, v !== null && (v.rendering = null, v.tail = null, v.lastEffect = null), I(Gt, Gt.current), m) break;
        return null;
      case 22:
      case 23:
        return l.lanes = 0, sS(o, l, c);
      case 24:
        ao(l, Yt, o.memoizedState.cache);
    }
    return Ci(o, l, c);
  }
  function mS(o, l, c) {
    if (o !== null)
      if (o.memoizedProps !== l.pendingProps)
        Wt = !0;
      else {
        if (!Og(o, c) && (l.flags & 128) === 0)
          return Wt = !1, RD(
            o,
            l,
            c
          );
        Wt = (o.flags & 131072) !== 0;
      }
    else
      Wt = !1, et && (l.flags & 1048576) !== 0 && qx(l, kf, l.index);
    switch (l.lanes = 0, l.tag) {
      case 16:
        e: {
          o = l.pendingProps;
          var m = l.elementType, v = m._init;
          if (m = v(m._payload), l.type = m, typeof m == "function")
            Fm(m) ? (o = da(m, o), l.tag = 1, l = cS(
              null,
              l,
              m,
              o,
              c
            )) : (l.tag = 0, l = _g(
              null,
              l,
              m,
              o,
              c
            ));
          else {
            if (m != null) {
              if (v = m.$$typeof, v === R) {
                l.tag = 11, l = iS(
                  null,
                  l,
                  m,
                  o,
                  c
                );
                break e;
              } else if (v === P) {
                l.tag = 14, l = oS(
                  null,
                  l,
                  m,
                  o,
                  c
                );
                break e;
              }
            }
            throw l = j(m) || m, Error(r(306, l, ""));
          }
        }
        return l;
      case 0:
        return _g(
          o,
          l,
          l.type,
          l.pendingProps,
          c
        );
      case 1:
        return m = l.type, v = da(
          m,
          l.pendingProps
        ), cS(
          o,
          l,
          m,
          v,
          c
        );
      case 3:
        e: {
          if (he(
            l,
            l.stateNode.containerInfo
          ), o === null) throw Error(r(387));
          m = l.pendingProps;
          var w = l.memoizedState;
          v = w.element, Jm(o, l), nu(l, m, null, c);
          var M = l.memoizedState;
          if (m = M.cache, ao(l, Yt, m), m !== w.cache && Gm(
            l,
            [Yt],
            c,
            !0
          ), tu(), m = M.element, w.isDehydrated)
            if (w = {
              element: m,
              isDehydrated: !1,
              cache: M.cache
            }, l.updateQueue.baseState = w, l.memoizedState = w, l.flags & 256) {
              l = fS(
                o,
                l,
                m,
                c
              );
              break e;
            } else if (m !== v) {
              v = ar(
                Error(r(424)),
                l
              ), Xl(v), l = fS(
                o,
                l,
                m,
                c
              );
              break e;
            } else {
              switch (o = l.stateNode.containerInfo, o.nodeType) {
                case 9:
                  o = o.body;
                  break;
                default:
                  o = o.nodeName === "HTML" ? o.ownerDocument.body : o;
              }
              for (At = Cr(o.firstChild), vn = l, et = !0, aa = null, Br = !0, c = Gw(
                l,
                null,
                m,
                c
              ), l.child = c; c; )
                c.flags = c.flags & -3 | 4096, c = c.sibling;
            }
          else {
            if (Gl(), m === v) {
              l = Ci(
                o,
                l,
                c
              );
              break e;
            }
            en(
              o,
              l,
              m,
              c
            );
          }
          l = l.child;
        }
        return l;
      case 26:
        return Yf(o, l), o === null ? (c = b_(
          l.type,
          null,
          l.pendingProps,
          null
        )) ? l.memoizedState = c : et || (c = l.type, o = l.pendingProps, m = sd(
          re.current
        ).createElement(c), m[Xt] = l, m[sn] = o, nn(m, c, o), It(m), l.stateNode = m) : l.memoizedState = b_(
          l.type,
          o.memoizedProps,
          l.pendingProps,
          o.memoizedState
        ), null;
      case 27:
        return je(l), o === null && et && (m = l.stateNode = g_(
          l.type,
          l.pendingProps,
          re.current
        ), vn = l, Br = !0, v = At, So(l.type) ? (c0 = v, At = Cr(
          m.firstChild
        )) : At = v), en(
          o,
          l,
          l.pendingProps.children,
          c
        ), Yf(o, l), o === null && (l.flags |= 4194304), l.child;
      case 5:
        return o === null && et && ((v = m = At) && (m = rP(
          m,
          l.type,
          l.pendingProps,
          Br
        ), m !== null ? (l.stateNode = m, vn = l, At = Cr(
          m.firstChild
        ), Br = !1, v = !0) : v = !1), v || sa(l)), je(l), v = l.type, w = l.pendingProps, M = o !== null ? o.memoizedProps : null, m = w.children, a0(v, w) ? m = null : M !== null && a0(v, M) && (l.flags |= 32), l.memoizedState !== null && (v = og(
          o,
          l,
          wD,
          null,
          null,
          c
        ), Eu._currentValue = v), Yf(o, l), en(o, l, m, c), l.child;
      case 6:
        return o === null && et && ((o = c = At) && (c = iP(
          c,
          l.pendingProps,
          Br
        ), c !== null ? (l.stateNode = c, vn = l, At = null, o = !0) : o = !1), o || sa(l)), null;
      case 13:
        return dS(o, l, c);
      case 4:
        return he(
          l,
          l.stateNode.containerInfo
        ), m = l.pendingProps, o === null ? l.child = ds(
          l,
          null,
          m,
          c
        ) : en(
          o,
          l,
          m,
          c
        ), l.child;
      case 11:
        return iS(
          o,
          l,
          l.type,
          l.pendingProps,
          c
        );
      case 7:
        return en(
          o,
          l,
          l.pendingProps,
          c
        ), l.child;
      case 8:
        return en(
          o,
          l,
          l.pendingProps.children,
          c
        ), l.child;
      case 12:
        return en(
          o,
          l,
          l.pendingProps.children,
          c
        ), l.child;
      case 10:
        return m = l.pendingProps, ao(l, l.type, m.value), en(
          o,
          l,
          m.children,
          c
        ), l.child;
      case 9:
        return v = l.type._context, m = l.pendingProps.children, ua(l), v = ln(v), m = m(v), l.flags |= 1, en(o, l, m, c), l.child;
      case 14:
        return oS(
          o,
          l,
          l.type,
          l.pendingProps,
          c
        );
      case 15:
        return aS(
          o,
          l,
          l.type,
          l.pendingProps,
          c
        );
      case 19:
        return pS(o, l, c);
      case 31:
        return m = l.pendingProps, c = l.mode, m = {
          mode: m.mode,
          children: m.children
        }, o === null ? (c = Gf(
          m,
          c
        ), c.ref = l.ref, l.child = c, c.return = l, l = c) : (c = vi(o.child, m), c.ref = l.ref, l.child = c, c.return = l, l = c), l;
      case 22:
        return sS(o, l, c);
      case 24:
        return ua(l), m = ln(Yt), o === null ? (v = Km(), v === null && (v = gt, w = Xm(), v.pooledCache = w, w.refCount++, w !== null && (v.pooledCacheLanes |= c), v = w), l.memoizedState = {
          parent: m,
          cache: v
        }, Qm(l), ao(l, Yt, v)) : ((o.lanes & c) !== 0 && (Jm(o, l), nu(l, null, null, c), tu()), v = o.memoizedState, w = l.memoizedState, v.parent !== m ? (v = { parent: m, cache: m }, l.memoizedState = v, l.lanes === 0 && (l.memoizedState = l.updateQueue.baseState = v), ao(l, Yt, m)) : (m = w.cache, ao(l, Yt, m), m !== v.cache && Gm(
          l,
          [Yt],
          c,
          !0
        ))), en(
          o,
          l,
          l.pendingProps.children,
          c
        ), l.child;
      case 29:
        throw l.pendingProps;
    }
    throw Error(r(156, l.tag));
  }
  function ki(o) {
    o.flags |= 4;
  }
  function gS(o, l) {
    if (l.type !== "stylesheet" || (l.state.loading & 4) !== 0)
      o.flags &= -16777217;
    else if (o.flags |= 16777216, !E_(l)) {
      if (l = cr.current, l !== null && ((Ke & 4194048) === Ke ? $r !== null : (Ke & 62914560) !== Ke && (Ke & 536870912) === 0 || l !== $r))
        throw Jl = Zm, Jx;
      o.flags |= 8192;
    }
  }
  function Xf(o, l) {
    l !== null && (o.flags |= 4), o.flags & 16384 && (l = o.tag !== 22 ? ef() : 536870912, o.lanes |= l, gs |= l);
  }
  function uu(o, l) {
    if (!et)
      switch (o.tailMode) {
        case "hidden":
          l = o.tail;
          for (var c = null; l !== null; )
            l.alternate !== null && (c = l), l = l.sibling;
          c === null ? o.tail = null : c.sibling = null;
          break;
        case "collapsed":
          c = o.tail;
          for (var m = null; c !== null; )
            c.alternate !== null && (m = c), c = c.sibling;
          m === null ? l || o.tail === null ? o.tail = null : o.tail.sibling = null : m.sibling = null;
      }
  }
  function kt(o) {
    var l = o.alternate !== null && o.alternate.child === o.child, c = 0, m = 0;
    if (l)
      for (var v = o.child; v !== null; )
        c |= v.lanes | v.childLanes, m |= v.subtreeFlags & 65011712, m |= v.flags & 65011712, v.return = o, v = v.sibling;
    else
      for (v = o.child; v !== null; )
        c |= v.lanes | v.childLanes, m |= v.subtreeFlags, m |= v.flags, v.return = o, v = v.sibling;
    return o.subtreeFlags |= m, o.childLanes = c, l;
  }
  function OD(o, l, c) {
    var m = l.pendingProps;
    switch (Vm(l), l.tag) {
      case 31:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return kt(l), null;
      case 1:
        return kt(l), null;
      case 3:
        return c = l.stateNode, m = null, o !== null && (m = o.memoizedState.cache), l.memoizedState.cache !== m && (l.flags |= 2048), Si(Yt), ye(), c.pendingContext && (c.context = c.pendingContext, c.pendingContext = null), (o === null || o.child === null) && (Yl(l) ? ki(l) : o === null || o.memoizedState.isDehydrated && (l.flags & 256) === 0 || (l.flags |= 1024, Xx())), kt(l), null;
      case 26:
        return c = l.memoizedState, o === null ? (ki(l), c !== null ? (kt(l), gS(l, c)) : (kt(l), l.flags &= -16777217)) : c ? c !== o.memoizedState ? (ki(l), kt(l), gS(l, c)) : (kt(l), l.flags &= -16777217) : (o.memoizedProps !== m && ki(l), kt(l), l.flags &= -16777217), null;
      case 27:
        Oe(l), c = re.current;
        var v = l.type;
        if (o !== null && l.stateNode != null)
          o.memoizedProps !== m && ki(l);
        else {
          if (!m) {
            if (l.stateNode === null)
              throw Error(r(166));
            return kt(l), null;
          }
          o = ie.current, Yl(l) ? Yx(l) : (o = g_(v, m, c), l.stateNode = o, ki(l));
        }
        return kt(l), null;
      case 5:
        if (Oe(l), c = l.type, o !== null && l.stateNode != null)
          o.memoizedProps !== m && ki(l);
        else {
          if (!m) {
            if (l.stateNode === null)
              throw Error(r(166));
            return kt(l), null;
          }
          if (o = ie.current, Yl(l))
            Yx(l);
          else {
            switch (v = sd(
              re.current
            ), o) {
              case 1:
                o = v.createElementNS(
                  "http://www.w3.org/2000/svg",
                  c
                );
                break;
              case 2:
                o = v.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  c
                );
                break;
              default:
                switch (c) {
                  case "svg":
                    o = v.createElementNS(
                      "http://www.w3.org/2000/svg",
                      c
                    );
                    break;
                  case "math":
                    o = v.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      c
                    );
                    break;
                  case "script":
                    o = v.createElement("div"), o.innerHTML = "<script><\/script>", o = o.removeChild(o.firstChild);
                    break;
                  case "select":
                    o = typeof m.is == "string" ? v.createElement("select", { is: m.is }) : v.createElement("select"), m.multiple ? o.multiple = !0 : m.size && (o.size = m.size);
                    break;
                  default:
                    o = typeof m.is == "string" ? v.createElement(c, { is: m.is }) : v.createElement(c);
                }
            }
            o[Xt] = l, o[sn] = m;
            e: for (v = l.child; v !== null; ) {
              if (v.tag === 5 || v.tag === 6)
                o.appendChild(v.stateNode);
              else if (v.tag !== 4 && v.tag !== 27 && v.child !== null) {
                v.child.return = v, v = v.child;
                continue;
              }
              if (v === l) break e;
              for (; v.sibling === null; ) {
                if (v.return === null || v.return === l)
                  break e;
                v = v.return;
              }
              v.sibling.return = v.return, v = v.sibling;
            }
            l.stateNode = o;
            e: switch (nn(o, c, m), c) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                o = !!m.autoFocus;
                break e;
              case "img":
                o = !0;
                break e;
              default:
                o = !1;
            }
            o && ki(l);
          }
        }
        return kt(l), l.flags &= -16777217, null;
      case 6:
        if (o && l.stateNode != null)
          o.memoizedProps !== m && ki(l);
        else {
          if (typeof m != "string" && l.stateNode === null)
            throw Error(r(166));
          if (o = re.current, Yl(l)) {
            if (o = l.stateNode, c = l.memoizedProps, m = null, v = vn, v !== null)
              switch (v.tag) {
                case 27:
                case 5:
                  m = v.memoizedProps;
              }
            o[Xt] = l, o = !!(o.nodeValue === c || m !== null && m.suppressHydrationWarning === !0 || u_(o.nodeValue, c)), o || sa(l);
          } else
            o = sd(o).createTextNode(
              m
            ), o[Xt] = l, l.stateNode = o;
        }
        return kt(l), null;
      case 13:
        if (m = l.memoizedState, o === null || o.memoizedState !== null && o.memoizedState.dehydrated !== null) {
          if (v = Yl(l), m !== null && m.dehydrated !== null) {
            if (o === null) {
              if (!v) throw Error(r(318));
              if (v = l.memoizedState, v = v !== null ? v.dehydrated : null, !v) throw Error(r(317));
              v[Xt] = l;
            } else
              Gl(), (l.flags & 128) === 0 && (l.memoizedState = null), l.flags |= 4;
            kt(l), v = !1;
          } else
            v = Xx(), o !== null && o.memoizedState !== null && (o.memoizedState.hydrationErrors = v), v = !0;
          if (!v)
            return l.flags & 256 ? (Ei(l), l) : (Ei(l), null);
        }
        if (Ei(l), (l.flags & 128) !== 0)
          return l.lanes = c, l;
        if (c = m !== null, o = o !== null && o.memoizedState !== null, c) {
          m = l.child, v = null, m.alternate !== null && m.alternate.memoizedState !== null && m.alternate.memoizedState.cachePool !== null && (v = m.alternate.memoizedState.cachePool.pool);
          var w = null;
          m.memoizedState !== null && m.memoizedState.cachePool !== null && (w = m.memoizedState.cachePool.pool), w !== v && (m.flags |= 2048);
        }
        return c !== o && c && (l.child.flags |= 8192), Xf(l, l.updateQueue), kt(l), null;
      case 4:
        return ye(), o === null && t0(l.stateNode.containerInfo), kt(l), null;
      case 10:
        return Si(l.type), kt(l), null;
      case 19:
        if (Z(Gt), v = l.memoizedState, v === null) return kt(l), null;
        if (m = (l.flags & 128) !== 0, w = v.rendering, w === null)
          if (m) uu(v, !1);
          else {
            if (Tt !== 0 || o !== null && (o.flags & 128) !== 0)
              for (o = l.child; o !== null; ) {
                if (w = Vf(o), w !== null) {
                  for (l.flags |= 128, uu(v, !1), o = w.updateQueue, l.updateQueue = o, Xf(l, o), l.subtreeFlags = 0, o = c, c = l.child; c !== null; )
                    Ux(c, o), c = c.sibling;
                  return I(
                    Gt,
                    Gt.current & 1 | 2
                  ), l.child;
                }
                o = o.sibling;
              }
            v.tail !== null && bt() > Zf && (l.flags |= 128, m = !0, uu(v, !1), l.lanes = 4194304);
          }
        else {
          if (!m)
            if (o = Vf(w), o !== null) {
              if (l.flags |= 128, m = !0, o = o.updateQueue, l.updateQueue = o, Xf(l, o), uu(v, !0), v.tail === null && v.tailMode === "hidden" && !w.alternate && !et)
                return kt(l), null;
            } else
              2 * bt() - v.renderingStartTime > Zf && c !== 536870912 && (l.flags |= 128, m = !0, uu(v, !1), l.lanes = 4194304);
          v.isBackwards ? (w.sibling = l.child, l.child = w) : (o = v.last, o !== null ? o.sibling = w : l.child = w, v.last = w);
        }
        return v.tail !== null ? (l = v.tail, v.rendering = l, v.tail = l.sibling, v.renderingStartTime = bt(), l.sibling = null, o = Gt.current, I(Gt, m ? o & 1 | 2 : o & 1), l) : (kt(l), null);
      case 22:
      case 23:
        return Ei(l), rg(), m = l.memoizedState !== null, o !== null ? o.memoizedState !== null !== m && (l.flags |= 8192) : m && (l.flags |= 8192), m ? (c & 536870912) !== 0 && (l.flags & 128) === 0 && (kt(l), l.subtreeFlags & 6 && (l.flags |= 8192)) : kt(l), c = l.updateQueue, c !== null && Xf(l, c.retryQueue), c = null, o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (c = o.memoizedState.cachePool.pool), m = null, l.memoizedState !== null && l.memoizedState.cachePool !== null && (m = l.memoizedState.cachePool.pool), m !== c && (l.flags |= 2048), o !== null && Z(ca), null;
      case 24:
        return c = null, o !== null && (c = o.memoizedState.cache), l.memoizedState.cache !== c && (l.flags |= 2048), Si(Yt), kt(l), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(r(156, l.tag));
  }
  function ND(o, l) {
    switch (Vm(l), l.tag) {
      case 1:
        return o = l.flags, o & 65536 ? (l.flags = o & -65537 | 128, l) : null;
      case 3:
        return Si(Yt), ye(), o = l.flags, (o & 65536) !== 0 && (o & 128) === 0 ? (l.flags = o & -65537 | 128, l) : null;
      case 26:
      case 27:
      case 5:
        return Oe(l), null;
      case 13:
        if (Ei(l), o = l.memoizedState, o !== null && o.dehydrated !== null) {
          if (l.alternate === null)
            throw Error(r(340));
          Gl();
        }
        return o = l.flags, o & 65536 ? (l.flags = o & -65537 | 128, l) : null;
      case 19:
        return Z(Gt), null;
      case 4:
        return ye(), null;
      case 10:
        return Si(l.type), null;
      case 22:
      case 23:
        return Ei(l), rg(), o !== null && Z(ca), o = l.flags, o & 65536 ? (l.flags = o & -65537 | 128, l) : null;
      case 24:
        return Si(Yt), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function yS(o, l) {
    switch (Vm(l), l.tag) {
      case 3:
        Si(Yt), ye();
        break;
      case 26:
      case 27:
      case 5:
        Oe(l);
        break;
      case 4:
        ye();
        break;
      case 13:
        Ei(l);
        break;
      case 19:
        Z(Gt);
        break;
      case 10:
        Si(l.type);
        break;
      case 22:
      case 23:
        Ei(l), rg(), o !== null && Z(ca);
        break;
      case 24:
        Si(Yt);
    }
  }
  function cu(o, l) {
    try {
      var c = l.updateQueue, m = c !== null ? c.lastEffect : null;
      if (m !== null) {
        var v = m.next;
        c = v;
        do {
          if ((c.tag & o) === o) {
            m = void 0;
            var w = c.create, M = c.inst;
            m = w(), M.destroy = m;
          }
          c = c.next;
        } while (c !== v);
      }
    } catch (L) {
      dt(l, l.return, L);
    }
  }
  function po(o, l, c) {
    try {
      var m = l.updateQueue, v = m !== null ? m.lastEffect : null;
      if (v !== null) {
        var w = v.next;
        m = w;
        do {
          if ((m.tag & o) === o) {
            var M = m.inst, L = M.destroy;
            if (L !== void 0) {
              M.destroy = void 0, v = l;
              var X = c, ee = L;
              try {
                ee();
              } catch (ue) {
                dt(
                  v,
                  X,
                  ue
                );
              }
            }
          }
          m = m.next;
        } while (m !== w);
      }
    } catch (ue) {
      dt(l, l.return, ue);
    }
  }
  function vS(o) {
    var l = o.updateQueue;
    if (l !== null) {
      var c = o.stateNode;
      try {
        ow(l, c);
      } catch (m) {
        dt(o, o.return, m);
      }
    }
  }
  function bS(o, l, c) {
    c.props = da(
      o.type,
      o.memoizedProps
    ), c.state = o.memoizedState;
    try {
      c.componentWillUnmount();
    } catch (m) {
      dt(o, l, m);
    }
  }
  function fu(o, l) {
    try {
      var c = o.ref;
      if (c !== null) {
        switch (o.tag) {
          case 26:
          case 27:
          case 5:
            var m = o.stateNode;
            break;
          case 30:
            m = o.stateNode;
            break;
          default:
            m = o.stateNode;
        }
        typeof c == "function" ? o.refCleanup = c(m) : c.current = m;
      }
    } catch (v) {
      dt(o, l, v);
    }
  }
  function Hr(o, l) {
    var c = o.ref, m = o.refCleanup;
    if (c !== null)
      if (typeof m == "function")
        try {
          m();
        } catch (v) {
          dt(o, l, v);
        } finally {
          o.refCleanup = null, o = o.alternate, o != null && (o.refCleanup = null);
        }
      else if (typeof c == "function")
        try {
          c(null);
        } catch (v) {
          dt(o, l, v);
        }
      else c.current = null;
  }
  function xS(o) {
    var l = o.type, c = o.memoizedProps, m = o.stateNode;
    try {
      e: switch (l) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          c.autoFocus && m.focus();
          break e;
        case "img":
          c.src ? m.src = c.src : c.srcSet && (m.srcset = c.srcSet);
      }
    } catch (v) {
      dt(o, o.return, v);
    }
  }
  function Ng(o, l, c) {
    try {
      var m = o.stateNode;
      QD(m, o.type, c, l), m[sn] = l;
    } catch (v) {
      dt(o, o.return, v);
    }
  }
  function wS(o) {
    return o.tag === 5 || o.tag === 3 || o.tag === 26 || o.tag === 27 && So(o.type) || o.tag === 4;
  }
  function Mg(o) {
    e: for (; ; ) {
      for (; o.sibling === null; ) {
        if (o.return === null || wS(o.return)) return null;
        o = o.return;
      }
      for (o.sibling.return = o.return, o = o.sibling; o.tag !== 5 && o.tag !== 6 && o.tag !== 18; ) {
        if (o.tag === 27 && So(o.type) || o.flags & 2 || o.child === null || o.tag === 4) continue e;
        o.child.return = o, o = o.child;
      }
      if (!(o.flags & 2)) return o.stateNode;
    }
  }
  function Dg(o, l, c) {
    var m = o.tag;
    if (m === 5 || m === 6)
      o = o.stateNode, l ? (c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c).insertBefore(o, l) : (l = c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c, l.appendChild(o), c = c._reactRootContainer, c != null || l.onclick !== null || (l.onclick = ad));
    else if (m !== 4 && (m === 27 && So(o.type) && (c = o.stateNode, l = null), o = o.child, o !== null))
      for (Dg(o, l, c), o = o.sibling; o !== null; )
        Dg(o, l, c), o = o.sibling;
  }
  function Wf(o, l, c) {
    var m = o.tag;
    if (m === 5 || m === 6)
      o = o.stateNode, l ? c.insertBefore(o, l) : c.appendChild(o);
    else if (m !== 4 && (m === 27 && So(o.type) && (c = o.stateNode), o = o.child, o !== null))
      for (Wf(o, l, c), o = o.sibling; o !== null; )
        Wf(o, l, c), o = o.sibling;
  }
  function SS(o) {
    var l = o.stateNode, c = o.memoizedProps;
    try {
      for (var m = o.type, v = l.attributes; v.length; )
        l.removeAttributeNode(v[0]);
      nn(l, m, c), l[Xt] = o, l[sn] = c;
    } catch (w) {
      dt(o, o.return, w);
    }
  }
  var Ai = !1, Dt = !1, Pg = !1, _S = typeof WeakSet == "function" ? WeakSet : Set, Kt = null;
  function MD(o, l) {
    if (o = o.containerInfo, i0 = hd, o = Px(o), Mm(o)) {
      if ("selectionStart" in o)
        var c = {
          start: o.selectionStart,
          end: o.selectionEnd
        };
      else
        e: {
          c = (c = o.ownerDocument) && c.defaultView || window;
          var m = c.getSelection && c.getSelection();
          if (m && m.rangeCount !== 0) {
            c = m.anchorNode;
            var v = m.anchorOffset, w = m.focusNode;
            m = m.focusOffset;
            try {
              c.nodeType, w.nodeType;
            } catch {
              c = null;
              break e;
            }
            var M = 0, L = -1, X = -1, ee = 0, ue = 0, de = o, te = null;
            t: for (; ; ) {
              for (var ne; de !== c || v !== 0 && de.nodeType !== 3 || (L = M + v), de !== w || m !== 0 && de.nodeType !== 3 || (X = M + m), de.nodeType === 3 && (M += de.nodeValue.length), (ne = de.firstChild) !== null; )
                te = de, de = ne;
              for (; ; ) {
                if (de === o) break t;
                if (te === c && ++ee === v && (L = M), te === w && ++ue === m && (X = M), (ne = de.nextSibling) !== null) break;
                de = te, te = de.parentNode;
              }
              de = ne;
            }
            c = L === -1 || X === -1 ? null : { start: L, end: X };
          } else c = null;
        }
      c = c || { start: 0, end: 0 };
    } else c = null;
    for (o0 = { focusedElem: o, selectionRange: c }, hd = !1, Kt = l; Kt !== null; )
      if (l = Kt, o = l.child, (l.subtreeFlags & 1024) !== 0 && o !== null)
        o.return = l, Kt = o;
      else
        for (; Kt !== null; ) {
          switch (l = Kt, w = l.alternate, o = l.flags, l.tag) {
            case 0:
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((o & 1024) !== 0 && w !== null) {
                o = void 0, c = l, v = w.memoizedProps, w = w.memoizedState, m = c.stateNode;
                try {
                  var ze = da(
                    c.type,
                    v,
                    c.elementType === c.type
                  );
                  o = m.getSnapshotBeforeUpdate(
                    ze,
                    w
                  ), m.__reactInternalSnapshotBeforeUpdate = o;
                } catch (Ne) {
                  dt(
                    c,
                    c.return,
                    Ne
                  );
                }
              }
              break;
            case 3:
              if ((o & 1024) !== 0) {
                if (o = l.stateNode.containerInfo, c = o.nodeType, c === 9)
                  l0(o);
                else if (c === 1)
                  switch (o.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      l0(o);
                      break;
                    default:
                      o.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((o & 1024) !== 0) throw Error(r(163));
          }
          if (o = l.sibling, o !== null) {
            o.return = l.return, Kt = o;
            break;
          }
          Kt = l.return;
        }
  }
  function ES(o, l, c) {
    var m = c.flags;
    switch (c.tag) {
      case 0:
      case 11:
      case 15:
        mo(o, c), m & 4 && cu(5, c);
        break;
      case 1:
        if (mo(o, c), m & 4)
          if (o = c.stateNode, l === null)
            try {
              o.componentDidMount();
            } catch (M) {
              dt(c, c.return, M);
            }
          else {
            var v = da(
              c.type,
              l.memoizedProps
            );
            l = l.memoizedState;
            try {
              o.componentDidUpdate(
                v,
                l,
                o.__reactInternalSnapshotBeforeUpdate
              );
            } catch (M) {
              dt(
                c,
                c.return,
                M
              );
            }
          }
        m & 64 && vS(c), m & 512 && fu(c, c.return);
        break;
      case 3:
        if (mo(o, c), m & 64 && (o = c.updateQueue, o !== null)) {
          if (l = null, c.child !== null)
            switch (c.child.tag) {
              case 27:
              case 5:
                l = c.child.stateNode;
                break;
              case 1:
                l = c.child.stateNode;
            }
          try {
            ow(o, l);
          } catch (M) {
            dt(c, c.return, M);
          }
        }
        break;
      case 27:
        l === null && m & 4 && SS(c);
      case 26:
      case 5:
        mo(o, c), l === null && m & 4 && xS(c), m & 512 && fu(c, c.return);
        break;
      case 12:
        mo(o, c);
        break;
      case 13:
        mo(o, c), m & 4 && AS(o, c), m & 64 && (o = c.memoizedState, o !== null && (o = o.dehydrated, o !== null && (c = $D.bind(
          null,
          c
        ), oP(o, c))));
        break;
      case 22:
        if (m = c.memoizedState !== null || Ai, !m) {
          l = l !== null && l.memoizedState !== null || Dt, v = Ai;
          var w = Dt;
          Ai = m, (Dt = l) && !w ? go(
            o,
            c,
            (c.subtreeFlags & 8772) !== 0
          ) : mo(o, c), Ai = v, Dt = w;
        }
        break;
      case 30:
        break;
      default:
        mo(o, c);
    }
  }
  function CS(o) {
    var l = o.alternate;
    l !== null && (o.alternate = null, CS(l)), o.child = null, o.deletions = null, o.sibling = null, o.tag === 5 && (l = o.stateNode, l !== null && Ml(l)), o.stateNode = null, o.return = null, o.dependencies = null, o.memoizedProps = null, o.memoizedState = null, o.pendingProps = null, o.stateNode = null, o.updateQueue = null;
  }
  var wt = null, On = !1;
  function Ti(o, l, c) {
    for (c = c.child; c !== null; )
      kS(o, l, c), c = c.sibling;
  }
  function kS(o, l, c) {
    if (pe && typeof pe.onCommitFiberUnmount == "function")
      try {
        pe.onCommitFiberUnmount(ae, c);
      } catch {
      }
    switch (c.tag) {
      case 26:
        Dt || Hr(c, l), Ti(
          o,
          l,
          c
        ), c.memoizedState ? c.memoizedState.count-- : c.stateNode && (c = c.stateNode, c.parentNode.removeChild(c));
        break;
      case 27:
        Dt || Hr(c, l);
        var m = wt, v = On;
        So(c.type) && (wt = c.stateNode, On = !1), Ti(
          o,
          l,
          c
        ), xu(c.stateNode), wt = m, On = v;
        break;
      case 5:
        Dt || Hr(c, l);
      case 6:
        if (m = wt, v = On, wt = null, Ti(
          o,
          l,
          c
        ), wt = m, On = v, wt !== null)
          if (On)
            try {
              (wt.nodeType === 9 ? wt.body : wt.nodeName === "HTML" ? wt.ownerDocument.body : wt).removeChild(c.stateNode);
            } catch (w) {
              dt(
                c,
                l,
                w
              );
            }
          else
            try {
              wt.removeChild(c.stateNode);
            } catch (w) {
              dt(
                c,
                l,
                w
              );
            }
        break;
      case 18:
        wt !== null && (On ? (o = wt, p_(
          o.nodeType === 9 ? o.body : o.nodeName === "HTML" ? o.ownerDocument.body : o,
          c.stateNode
        ), Tu(o)) : p_(wt, c.stateNode));
        break;
      case 4:
        m = wt, v = On, wt = c.stateNode.containerInfo, On = !0, Ti(
          o,
          l,
          c
        ), wt = m, On = v;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        Dt || po(2, c, l), Dt || po(4, c, l), Ti(
          o,
          l,
          c
        );
        break;
      case 1:
        Dt || (Hr(c, l), m = c.stateNode, typeof m.componentWillUnmount == "function" && bS(
          c,
          l,
          m
        )), Ti(
          o,
          l,
          c
        );
        break;
      case 21:
        Ti(
          o,
          l,
          c
        );
        break;
      case 22:
        Dt = (m = Dt) || c.memoizedState !== null, Ti(
          o,
          l,
          c
        ), Dt = m;
        break;
      default:
        Ti(
          o,
          l,
          c
        );
    }
  }
  function AS(o, l) {
    if (l.memoizedState === null && (o = l.alternate, o !== null && (o = o.memoizedState, o !== null && (o = o.dehydrated, o !== null))))
      try {
        Tu(o);
      } catch (c) {
        dt(l, l.return, c);
      }
  }
  function DD(o) {
    switch (o.tag) {
      case 13:
      case 19:
        var l = o.stateNode;
        return l === null && (l = o.stateNode = new _S()), l;
      case 22:
        return o = o.stateNode, l = o._retryCache, l === null && (l = o._retryCache = new _S()), l;
      default:
        throw Error(r(435, o.tag));
    }
  }
  function zg(o, l) {
    var c = DD(o);
    l.forEach(function(m) {
      var v = HD.bind(null, o, m);
      c.has(m) || (c.add(m), m.then(v, v));
    });
  }
  function Hn(o, l) {
    var c = l.deletions;
    if (c !== null)
      for (var m = 0; m < c.length; m++) {
        var v = c[m], w = o, M = l, L = M;
        e: for (; L !== null; ) {
          switch (L.tag) {
            case 27:
              if (So(L.type)) {
                wt = L.stateNode, On = !1;
                break e;
              }
              break;
            case 5:
              wt = L.stateNode, On = !1;
              break e;
            case 3:
            case 4:
              wt = L.stateNode.containerInfo, On = !0;
              break e;
          }
          L = L.return;
        }
        if (wt === null) throw Error(r(160));
        kS(w, M, v), wt = null, On = !1, w = v.alternate, w !== null && (w.return = null), v.return = null;
      }
    if (l.subtreeFlags & 13878)
      for (l = l.child; l !== null; )
        TS(l, o), l = l.sibling;
  }
  var Er = null;
  function TS(o, l) {
    var c = o.alternate, m = o.flags;
    switch (o.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Hn(l, o), Vn(o), m & 4 && (po(3, o, o.return), cu(3, o), po(5, o, o.return));
        break;
      case 1:
        Hn(l, o), Vn(o), m & 512 && (Dt || c === null || Hr(c, c.return)), m & 64 && Ai && (o = o.updateQueue, o !== null && (m = o.callbacks, m !== null && (c = o.shared.hiddenCallbacks, o.shared.hiddenCallbacks = c === null ? m : c.concat(m))));
        break;
      case 26:
        var v = Er;
        if (Hn(l, o), Vn(o), m & 512 && (Dt || c === null || Hr(c, c.return)), m & 4) {
          var w = c !== null ? c.memoizedState : null;
          if (m = o.memoizedState, c === null)
            if (m === null)
              if (o.stateNode === null) {
                e: {
                  m = o.type, c = o.memoizedProps, v = v.ownerDocument || v;
                  t: switch (m) {
                    case "title":
                      w = v.getElementsByTagName("title")[0], (!w || w[Qo] || w[Xt] || w.namespaceURI === "http://www.w3.org/2000/svg" || w.hasAttribute("itemprop")) && (w = v.createElement(m), v.head.insertBefore(
                        w,
                        v.querySelector("head > title")
                      )), nn(w, m, c), w[Xt] = o, It(w), m = w;
                      break e;
                    case "link":
                      var M = S_(
                        "link",
                        "href",
                        v
                      ).get(m + (c.href || ""));
                      if (M) {
                        for (var L = 0; L < M.length; L++)
                          if (w = M[L], w.getAttribute("href") === (c.href == null || c.href === "" ? null : c.href) && w.getAttribute("rel") === (c.rel == null ? null : c.rel) && w.getAttribute("title") === (c.title == null ? null : c.title) && w.getAttribute("crossorigin") === (c.crossOrigin == null ? null : c.crossOrigin)) {
                            M.splice(L, 1);
                            break t;
                          }
                      }
                      w = v.createElement(m), nn(w, m, c), v.head.appendChild(w);
                      break;
                    case "meta":
                      if (M = S_(
                        "meta",
                        "content",
                        v
                      ).get(m + (c.content || ""))) {
                        for (L = 0; L < M.length; L++)
                          if (w = M[L], w.getAttribute("content") === (c.content == null ? null : "" + c.content) && w.getAttribute("name") === (c.name == null ? null : c.name) && w.getAttribute("property") === (c.property == null ? null : c.property) && w.getAttribute("http-equiv") === (c.httpEquiv == null ? null : c.httpEquiv) && w.getAttribute("charset") === (c.charSet == null ? null : c.charSet)) {
                            M.splice(L, 1);
                            break t;
                          }
                      }
                      w = v.createElement(m), nn(w, m, c), v.head.appendChild(w);
                      break;
                    default:
                      throw Error(r(468, m));
                  }
                  w[Xt] = o, It(w), m = w;
                }
                o.stateNode = m;
              } else
                __(
                  v,
                  o.type,
                  o.stateNode
                );
            else
              o.stateNode = w_(
                v,
                m,
                o.memoizedProps
              );
          else
            w !== m ? (w === null ? c.stateNode !== null && (c = c.stateNode, c.parentNode.removeChild(c)) : w.count--, m === null ? __(
              v,
              o.type,
              o.stateNode
            ) : w_(
              v,
              m,
              o.memoizedProps
            )) : m === null && o.stateNode !== null && Ng(
              o,
              o.memoizedProps,
              c.memoizedProps
            );
        }
        break;
      case 27:
        Hn(l, o), Vn(o), m & 512 && (Dt || c === null || Hr(c, c.return)), c !== null && m & 4 && Ng(
          o,
          o.memoizedProps,
          c.memoizedProps
        );
        break;
      case 5:
        if (Hn(l, o), Vn(o), m & 512 && (Dt || c === null || Hr(c, c.return)), o.flags & 32) {
          v = o.stateNode;
          try {
            Xa(v, "");
          } catch (ne) {
            dt(o, o.return, ne);
          }
        }
        m & 4 && o.stateNode != null && (v = o.memoizedProps, Ng(
          o,
          v,
          c !== null ? c.memoizedProps : v
        )), m & 1024 && (Pg = !0);
        break;
      case 6:
        if (Hn(l, o), Vn(o), m & 4) {
          if (o.stateNode === null)
            throw Error(r(162));
          m = o.memoizedProps, c = o.stateNode;
          try {
            c.nodeValue = m;
          } catch (ne) {
            dt(o, o.return, ne);
          }
        }
        break;
      case 3:
        if (cd = null, v = Er, Er = ld(l.containerInfo), Hn(l, o), Er = v, Vn(o), m & 4 && c !== null && c.memoizedState.isDehydrated)
          try {
            Tu(l.containerInfo);
          } catch (ne) {
            dt(o, o.return, ne);
          }
        Pg && (Pg = !1, RS(o));
        break;
      case 4:
        m = Er, Er = ld(
          o.stateNode.containerInfo
        ), Hn(l, o), Vn(o), Er = m;
        break;
      case 12:
        Hn(l, o), Vn(o);
        break;
      case 13:
        Hn(l, o), Vn(o), o.child.flags & 8192 && o.memoizedState !== null != (c !== null && c.memoizedState !== null) && ($g = bt()), m & 4 && (m = o.updateQueue, m !== null && (o.updateQueue = null, zg(o, m)));
        break;
      case 22:
        v = o.memoizedState !== null;
        var X = c !== null && c.memoizedState !== null, ee = Ai, ue = Dt;
        if (Ai = ee || v, Dt = ue || X, Hn(l, o), Dt = ue, Ai = ee, Vn(o), m & 8192)
          e: for (l = o.stateNode, l._visibility = v ? l._visibility & -2 : l._visibility | 1, v && (c === null || X || Ai || Dt || ha(o)), c = null, l = o; ; ) {
            if (l.tag === 5 || l.tag === 26) {
              if (c === null) {
                X = c = l;
                try {
                  if (w = X.stateNode, v)
                    M = w.style, typeof M.setProperty == "function" ? M.setProperty("display", "none", "important") : M.display = "none";
                  else {
                    L = X.stateNode;
                    var de = X.memoizedProps.style, te = de != null && de.hasOwnProperty("display") ? de.display : null;
                    L.style.display = te == null || typeof te == "boolean" ? "" : ("" + te).trim();
                  }
                } catch (ne) {
                  dt(X, X.return, ne);
                }
              }
            } else if (l.tag === 6) {
              if (c === null) {
                X = l;
                try {
                  X.stateNode.nodeValue = v ? "" : X.memoizedProps;
                } catch (ne) {
                  dt(X, X.return, ne);
                }
              }
            } else if ((l.tag !== 22 && l.tag !== 23 || l.memoizedState === null || l === o) && l.child !== null) {
              l.child.return = l, l = l.child;
              continue;
            }
            if (l === o) break e;
            for (; l.sibling === null; ) {
              if (l.return === null || l.return === o) break e;
              c === l && (c = null), l = l.return;
            }
            c === l && (c = null), l.sibling.return = l.return, l = l.sibling;
          }
        m & 4 && (m = o.updateQueue, m !== null && (c = m.retryQueue, c !== null && (m.retryQueue = null, zg(o, c))));
        break;
      case 19:
        Hn(l, o), Vn(o), m & 4 && (m = o.updateQueue, m !== null && (o.updateQueue = null, zg(o, m)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        Hn(l, o), Vn(o);
    }
  }
  function Vn(o) {
    var l = o.flags;
    if (l & 2) {
      try {
        for (var c, m = o.return; m !== null; ) {
          if (wS(m)) {
            c = m;
            break;
          }
          m = m.return;
        }
        if (c == null) throw Error(r(160));
        switch (c.tag) {
          case 27:
            var v = c.stateNode, w = Mg(o);
            Wf(o, w, v);
            break;
          case 5:
            var M = c.stateNode;
            c.flags & 32 && (Xa(M, ""), c.flags &= -33);
            var L = Mg(o);
            Wf(o, L, M);
            break;
          case 3:
          case 4:
            var X = c.stateNode.containerInfo, ee = Mg(o);
            Dg(
              o,
              ee,
              X
            );
            break;
          default:
            throw Error(r(161));
        }
      } catch (ue) {
        dt(o, o.return, ue);
      }
      o.flags &= -3;
    }
    l & 4096 && (o.flags &= -4097);
  }
  function RS(o) {
    if (o.subtreeFlags & 1024)
      for (o = o.child; o !== null; ) {
        var l = o;
        RS(l), l.tag === 5 && l.flags & 1024 && l.stateNode.reset(), o = o.sibling;
      }
  }
  function mo(o, l) {
    if (l.subtreeFlags & 8772)
      for (l = l.child; l !== null; )
        ES(o, l.alternate, l), l = l.sibling;
  }
  function ha(o) {
    for (o = o.child; o !== null; ) {
      var l = o;
      switch (l.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          po(4, l, l.return), ha(l);
          break;
        case 1:
          Hr(l, l.return);
          var c = l.stateNode;
          typeof c.componentWillUnmount == "function" && bS(
            l,
            l.return,
            c
          ), ha(l);
          break;
        case 27:
          xu(l.stateNode);
        case 26:
        case 5:
          Hr(l, l.return), ha(l);
          break;
        case 22:
          l.memoizedState === null && ha(l);
          break;
        case 30:
          ha(l);
          break;
        default:
          ha(l);
      }
      o = o.sibling;
    }
  }
  function go(o, l, c) {
    for (c = c && (l.subtreeFlags & 8772) !== 0, l = l.child; l !== null; ) {
      var m = l.alternate, v = o, w = l, M = w.flags;
      switch (w.tag) {
        case 0:
        case 11:
        case 15:
          go(
            v,
            w,
            c
          ), cu(4, w);
          break;
        case 1:
          if (go(
            v,
            w,
            c
          ), m = w, v = m.stateNode, typeof v.componentDidMount == "function")
            try {
              v.componentDidMount();
            } catch (ee) {
              dt(m, m.return, ee);
            }
          if (m = w, v = m.updateQueue, v !== null) {
            var L = m.stateNode;
            try {
              var X = v.shared.hiddenCallbacks;
              if (X !== null)
                for (v.shared.hiddenCallbacks = null, v = 0; v < X.length; v++)
                  iw(X[v], L);
            } catch (ee) {
              dt(m, m.return, ee);
            }
          }
          c && M & 64 && vS(w), fu(w, w.return);
          break;
        case 27:
          SS(w);
        case 26:
        case 5:
          go(
            v,
            w,
            c
          ), c && m === null && M & 4 && xS(w), fu(w, w.return);
          break;
        case 12:
          go(
            v,
            w,
            c
          );
          break;
        case 13:
          go(
            v,
            w,
            c
          ), c && M & 4 && AS(v, w);
          break;
        case 22:
          w.memoizedState === null && go(
            v,
            w,
            c
          ), fu(w, w.return);
          break;
        case 30:
          break;
        default:
          go(
            v,
            w,
            c
          );
      }
      l = l.sibling;
    }
  }
  function jg(o, l) {
    var c = null;
    o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (c = o.memoizedState.cachePool.pool), o = null, l.memoizedState !== null && l.memoizedState.cachePool !== null && (o = l.memoizedState.cachePool.pool), o !== c && (o != null && o.refCount++, c != null && Kl(c));
  }
  function Ig(o, l) {
    o = null, l.alternate !== null && (o = l.alternate.memoizedState.cache), l = l.memoizedState.cache, l !== o && (l.refCount++, o != null && Kl(o));
  }
  function Vr(o, l, c, m) {
    if (l.subtreeFlags & 10256)
      for (l = l.child; l !== null; )
        OS(
          o,
          l,
          c,
          m
        ), l = l.sibling;
  }
  function OS(o, l, c, m) {
    var v = l.flags;
    switch (l.tag) {
      case 0:
      case 11:
      case 15:
        Vr(
          o,
          l,
          c,
          m
        ), v & 2048 && cu(9, l);
        break;
      case 1:
        Vr(
          o,
          l,
          c,
          m
        );
        break;
      case 3:
        Vr(
          o,
          l,
          c,
          m
        ), v & 2048 && (o = null, l.alternate !== null && (o = l.alternate.memoizedState.cache), l = l.memoizedState.cache, l !== o && (l.refCount++, o != null && Kl(o)));
        break;
      case 12:
        if (v & 2048) {
          Vr(
            o,
            l,
            c,
            m
          ), o = l.stateNode;
          try {
            var w = l.memoizedProps, M = w.id, L = w.onPostCommit;
            typeof L == "function" && L(
              M,
              l.alternate === null ? "mount" : "update",
              o.passiveEffectDuration,
              -0
            );
          } catch (X) {
            dt(l, l.return, X);
          }
        } else
          Vr(
            o,
            l,
            c,
            m
          );
        break;
      case 13:
        Vr(
          o,
          l,
          c,
          m
        );
        break;
      case 23:
        break;
      case 22:
        w = l.stateNode, M = l.alternate, l.memoizedState !== null ? w._visibility & 2 ? Vr(
          o,
          l,
          c,
          m
        ) : du(o, l) : w._visibility & 2 ? Vr(
          o,
          l,
          c,
          m
        ) : (w._visibility |= 2, hs(
          o,
          l,
          c,
          m,
          (l.subtreeFlags & 10256) !== 0
        )), v & 2048 && jg(M, l);
        break;
      case 24:
        Vr(
          o,
          l,
          c,
          m
        ), v & 2048 && Ig(l.alternate, l);
        break;
      default:
        Vr(
          o,
          l,
          c,
          m
        );
    }
  }
  function hs(o, l, c, m, v) {
    for (v = v && (l.subtreeFlags & 10256) !== 0, l = l.child; l !== null; ) {
      var w = o, M = l, L = c, X = m, ee = M.flags;
      switch (M.tag) {
        case 0:
        case 11:
        case 15:
          hs(
            w,
            M,
            L,
            X,
            v
          ), cu(8, M);
          break;
        case 23:
          break;
        case 22:
          var ue = M.stateNode;
          M.memoizedState !== null ? ue._visibility & 2 ? hs(
            w,
            M,
            L,
            X,
            v
          ) : du(
            w,
            M
          ) : (ue._visibility |= 2, hs(
            w,
            M,
            L,
            X,
            v
          )), v && ee & 2048 && jg(
            M.alternate,
            M
          );
          break;
        case 24:
          hs(
            w,
            M,
            L,
            X,
            v
          ), v && ee & 2048 && Ig(M.alternate, M);
          break;
        default:
          hs(
            w,
            M,
            L,
            X,
            v
          );
      }
      l = l.sibling;
    }
  }
  function du(o, l) {
    if (l.subtreeFlags & 10256)
      for (l = l.child; l !== null; ) {
        var c = o, m = l, v = m.flags;
        switch (m.tag) {
          case 22:
            du(c, m), v & 2048 && jg(
              m.alternate,
              m
            );
            break;
          case 24:
            du(c, m), v & 2048 && Ig(m.alternate, m);
            break;
          default:
            du(c, m);
        }
        l = l.sibling;
      }
  }
  var hu = 8192;
  function ps(o) {
    if (o.subtreeFlags & hu)
      for (o = o.child; o !== null; )
        NS(o), o = o.sibling;
  }
  function NS(o) {
    switch (o.tag) {
      case 26:
        ps(o), o.flags & hu && o.memoizedState !== null && vP(
          Er,
          o.memoizedState,
          o.memoizedProps
        );
        break;
      case 5:
        ps(o);
        break;
      case 3:
      case 4:
        var l = Er;
        Er = ld(o.stateNode.containerInfo), ps(o), Er = l;
        break;
      case 22:
        o.memoizedState === null && (l = o.alternate, l !== null && l.memoizedState !== null ? (l = hu, hu = 16777216, ps(o), hu = l) : ps(o));
        break;
      default:
        ps(o);
    }
  }
  function MS(o) {
    var l = o.alternate;
    if (l !== null && (o = l.child, o !== null)) {
      l.child = null;
      do
        l = o.sibling, o.sibling = null, o = l;
      while (o !== null);
    }
  }
  function pu(o) {
    var l = o.deletions;
    if ((o.flags & 16) !== 0) {
      if (l !== null)
        for (var c = 0; c < l.length; c++) {
          var m = l[c];
          Kt = m, PS(
            m,
            o
          );
        }
      MS(o);
    }
    if (o.subtreeFlags & 10256)
      for (o = o.child; o !== null; )
        DS(o), o = o.sibling;
  }
  function DS(o) {
    switch (o.tag) {
      case 0:
      case 11:
      case 15:
        pu(o), o.flags & 2048 && po(9, o, o.return);
        break;
      case 3:
        pu(o);
        break;
      case 12:
        pu(o);
        break;
      case 22:
        var l = o.stateNode;
        o.memoizedState !== null && l._visibility & 2 && (o.return === null || o.return.tag !== 13) ? (l._visibility &= -3, Kf(o)) : pu(o);
        break;
      default:
        pu(o);
    }
  }
  function Kf(o) {
    var l = o.deletions;
    if ((o.flags & 16) !== 0) {
      if (l !== null)
        for (var c = 0; c < l.length; c++) {
          var m = l[c];
          Kt = m, PS(
            m,
            o
          );
        }
      MS(o);
    }
    for (o = o.child; o !== null; ) {
      switch (l = o, l.tag) {
        case 0:
        case 11:
        case 15:
          po(8, l, l.return), Kf(l);
          break;
        case 22:
          c = l.stateNode, c._visibility & 2 && (c._visibility &= -3, Kf(l));
          break;
        default:
          Kf(l);
      }
      o = o.sibling;
    }
  }
  function PS(o, l) {
    for (; Kt !== null; ) {
      var c = Kt;
      switch (c.tag) {
        case 0:
        case 11:
        case 15:
          po(8, c, l);
          break;
        case 23:
        case 22:
          if (c.memoizedState !== null && c.memoizedState.cachePool !== null) {
            var m = c.memoizedState.cachePool.pool;
            m != null && m.refCount++;
          }
          break;
        case 24:
          Kl(c.memoizedState.cache);
      }
      if (m = c.child, m !== null) m.return = c, Kt = m;
      else
        e: for (c = o; Kt !== null; ) {
          m = Kt;
          var v = m.sibling, w = m.return;
          if (CS(m), m === c) {
            Kt = null;
            break e;
          }
          if (v !== null) {
            v.return = w, Kt = v;
            break e;
          }
          Kt = w;
        }
    }
  }
  var PD = {
    getCacheForType: function(o) {
      var l = ln(Yt), c = l.data.get(o);
      return c === void 0 && (c = o(), l.data.set(o, c)), c;
    }
  }, zD = typeof WeakMap == "function" ? WeakMap : Map, ot = 0, gt = null, Ue = null, Ke = 0, at = 0, Un = null, yo = !1, ms = !1, Lg = !1, Ri = 0, Tt = 0, vo = 0, pa = 0, Fg = 0, fr = 0, gs = 0, mu = null, Nn = null, Bg = !1, $g = 0, Zf = 1 / 0, Qf = null, bo = null, tn = 0, xo = null, ys = null, vs = 0, Hg = 0, Vg = null, zS = null, gu = 0, Ug = null;
  function qn() {
    if ((ot & 2) !== 0 && Ke !== 0)
      return Ke & -Ke;
    if (z.T !== null) {
      var o = os;
      return o !== 0 ? o : Zg();
    }
    return nf();
  }
  function jS() {
    fr === 0 && (fr = (Ke & 536870912) === 0 || et ? Jc() : 536870912);
    var o = cr.current;
    return o !== null && (o.flags |= 32), fr;
  }
  function Yn(o, l, c) {
    (o === gt && (at === 2 || at === 9) || o.cancelPendingCommit !== null) && (bs(o, 0), wo(
      o,
      Ke,
      fr,
      !1
    )), Zo(o, c), ((ot & 2) === 0 || o !== gt) && (o === gt && ((ot & 2) === 0 && (pa |= c), Tt === 4 && wo(
      o,
      Ke,
      fr,
      !1
    )), Ur(o));
  }
  function IS(o, l, c) {
    if ((ot & 6) !== 0) throw Error(r(327));
    var m = !c && (l & 124) === 0 && (l & o.expiredLanes) === 0 || Cn(o, l), v = m ? LD(o, l) : Gg(o, l, !0), w = m;
    do {
      if (v === 0) {
        ms && !m && wo(o, l, 0, !1);
        break;
      } else {
        if (c = o.current.alternate, w && !jD(c)) {
          v = Gg(o, l, !1), w = !1;
          continue;
        }
        if (v === 2) {
          if (w = l, o.errorRecoveryDisabledLanes & w)
            var M = 0;
          else
            M = o.pendingLanes & -536870913, M = M !== 0 ? M : M & 536870912 ? 536870912 : 0;
          if (M !== 0) {
            l = M;
            e: {
              var L = o;
              v = mu;
              var X = L.current.memoizedState.isDehydrated;
              if (X && (bs(L, M).flags |= 256), M = Gg(
                L,
                M,
                !1
              ), M !== 2) {
                if (Lg && !X) {
                  L.errorRecoveryDisabledLanes |= w, pa |= w, v = 4;
                  break e;
                }
                w = Nn, Nn = v, w !== null && (Nn === null ? Nn = w : Nn.push.apply(
                  Nn,
                  w
                ));
              }
              v = M;
            }
            if (w = !1, v !== 2) continue;
          }
        }
        if (v === 1) {
          bs(o, 0), wo(o, l, 0, !0);
          break;
        }
        e: {
          switch (m = o, w = v, w) {
            case 0:
            case 1:
              throw Error(r(345));
            case 4:
              if ((l & 4194048) !== l) break;
            case 6:
              wo(
                m,
                l,
                fr,
                !yo
              );
              break e;
            case 2:
              Nn = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(r(329));
          }
          if ((l & 62914560) === l && (v = $g + 300 - bt(), 10 < v)) {
            if (wo(
              m,
              l,
              fr,
              !yo
            ), jt(m, 0, !0) !== 0) break e;
            m.timeoutHandle = d_(
              LS.bind(
                null,
                m,
                c,
                Nn,
                Qf,
                Bg,
                l,
                fr,
                pa,
                gs,
                yo,
                w,
                2,
                -0,
                0
              ),
              v
            );
            break e;
          }
          LS(
            m,
            c,
            Nn,
            Qf,
            Bg,
            l,
            fr,
            pa,
            gs,
            yo,
            w,
            0,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    Ur(o);
  }
  function LS(o, l, c, m, v, w, M, L, X, ee, ue, de, te, ne) {
    if (o.timeoutHandle = -1, de = l.subtreeFlags, (de & 8192 || (de & 16785408) === 16785408) && (_u = { stylesheets: null, count: 0, unsuspend: yP }, NS(l), de = bP(), de !== null)) {
      o.cancelPendingCommit = de(
        qS.bind(
          null,
          o,
          l,
          w,
          c,
          m,
          v,
          M,
          L,
          X,
          ue,
          1,
          te,
          ne
        )
      ), wo(o, w, M, !ee);
      return;
    }
    qS(
      o,
      l,
      w,
      c,
      m,
      v,
      M,
      L,
      X
    );
  }
  function jD(o) {
    for (var l = o; ; ) {
      var c = l.tag;
      if ((c === 0 || c === 11 || c === 15) && l.flags & 16384 && (c = l.updateQueue, c !== null && (c = c.stores, c !== null)))
        for (var m = 0; m < c.length; m++) {
          var v = c[m], w = v.getSnapshot;
          v = v.value;
          try {
            if (!Bn(w(), v)) return !1;
          } catch {
            return !1;
          }
        }
      if (c = l.child, l.subtreeFlags & 16384 && c !== null)
        c.return = l, l = c;
      else {
        if (l === o) break;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === o) return !0;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
    }
    return !0;
  }
  function wo(o, l, c, m) {
    l &= ~Fg, l &= ~pa, o.suspendedLanes |= l, o.pingedLanes &= ~l, m && (o.warmLanes |= l), m = o.expirationTimes;
    for (var v = l; 0 < v; ) {
      var w = 31 - Ae(v), M = 1 << w;
      m[w] = -1, v &= ~M;
    }
    c !== 0 && Tl(o, c, l);
  }
  function Jf() {
    return (ot & 6) === 0 ? (yu(0), !1) : !0;
  }
  function qg() {
    if (Ue !== null) {
      if (at === 0)
        var o = Ue.return;
      else
        o = Ue, wi = la = null, lg(o), fs = null, su = 0, o = Ue;
      for (; o !== null; )
        yS(o.alternate, o), o = o.return;
      Ue = null;
    }
  }
  function bs(o, l) {
    var c = o.timeoutHandle;
    c !== -1 && (o.timeoutHandle = -1, eP(c)), c = o.cancelPendingCommit, c !== null && (o.cancelPendingCommit = null, c()), qg(), gt = o, Ue = c = vi(o.current, null), Ke = l, at = 0, Un = null, yo = !1, ms = Cn(o, l), Lg = !1, gs = fr = Fg = pa = vo = Tt = 0, Nn = mu = null, Bg = !1, (l & 8) !== 0 && (l |= l & 32);
    var m = o.entangledLanes;
    if (m !== 0)
      for (o = o.entanglements, m &= l; 0 < m; ) {
        var v = 31 - Ae(m), w = 1 << v;
        l |= o[v], m &= ~w;
      }
    return Ri = l, wf(), c;
  }
  function FS(o, l) {
    He = null, z.H = Bf, l === Ql || l === Of ? (l = nw(), at = 3) : l === Jx ? (l = nw(), at = 4) : at = l === rS ? 8 : l !== null && typeof l == "object" && typeof l.then == "function" ? 6 : 1, Un = l, Ue === null && (Tt = 1, qf(
      o,
      ar(l, o.current)
    ));
  }
  function BS() {
    var o = z.H;
    return z.H = Bf, o === null ? Bf : o;
  }
  function $S() {
    var o = z.A;
    return z.A = PD, o;
  }
  function Yg() {
    Tt = 4, yo || (Ke & 4194048) !== Ke && cr.current !== null || (ms = !0), (vo & 134217727) === 0 && (pa & 134217727) === 0 || gt === null || wo(
      gt,
      Ke,
      fr,
      !1
    );
  }
  function Gg(o, l, c) {
    var m = ot;
    ot |= 2;
    var v = BS(), w = $S();
    (gt !== o || Ke !== l) && (Qf = null, bs(o, l)), l = !1;
    var M = Tt;
    e: do
      try {
        if (at !== 0 && Ue !== null) {
          var L = Ue, X = Un;
          switch (at) {
            case 8:
              qg(), M = 6;
              break e;
            case 3:
            case 2:
            case 9:
            case 6:
              cr.current === null && (l = !0);
              var ee = at;
              if (at = 0, Un = null, xs(o, L, X, ee), c && ms) {
                M = 0;
                break e;
              }
              break;
            default:
              ee = at, at = 0, Un = null, xs(o, L, X, ee);
          }
        }
        ID(), M = Tt;
        break;
      } catch (ue) {
        FS(o, ue);
      }
    while (!0);
    return l && o.shellSuspendCounter++, wi = la = null, ot = m, z.H = v, z.A = w, Ue === null && (gt = null, Ke = 0, wf()), M;
  }
  function ID() {
    for (; Ue !== null; ) HS(Ue);
  }
  function LD(o, l) {
    var c = ot;
    ot |= 2;
    var m = BS(), v = $S();
    gt !== o || Ke !== l ? (Qf = null, Zf = bt() + 500, bs(o, l)) : ms = Cn(
      o,
      l
    );
    e: do
      try {
        if (at !== 0 && Ue !== null) {
          l = Ue;
          var w = Un;
          t: switch (at) {
            case 1:
              at = 0, Un = null, xs(o, l, w, 1);
              break;
            case 2:
            case 9:
              if (ew(w)) {
                at = 0, Un = null, VS(l);
                break;
              }
              l = function() {
                at !== 2 && at !== 9 || gt !== o || (at = 7), Ur(o);
              }, w.then(l, l);
              break e;
            case 3:
              at = 7;
              break e;
            case 4:
              at = 5;
              break e;
            case 7:
              ew(w) ? (at = 0, Un = null, VS(l)) : (at = 0, Un = null, xs(o, l, w, 7));
              break;
            case 5:
              var M = null;
              switch (Ue.tag) {
                case 26:
                  M = Ue.memoizedState;
                case 5:
                case 27:
                  var L = Ue;
                  if (!M || E_(M)) {
                    at = 0, Un = null;
                    var X = L.sibling;
                    if (X !== null) Ue = X;
                    else {
                      var ee = L.return;
                      ee !== null ? (Ue = ee, ed(ee)) : Ue = null;
                    }
                    break t;
                  }
              }
              at = 0, Un = null, xs(o, l, w, 5);
              break;
            case 6:
              at = 0, Un = null, xs(o, l, w, 6);
              break;
            case 8:
              qg(), Tt = 6;
              break e;
            default:
              throw Error(r(462));
          }
        }
        FD();
        break;
      } catch (ue) {
        FS(o, ue);
      }
    while (!0);
    return wi = la = null, z.H = m, z.A = v, ot = c, Ue !== null ? 0 : (gt = null, Ke = 0, wf(), Tt);
  }
  function FD() {
    for (; Ue !== null && !ft(); )
      HS(Ue);
  }
  function HS(o) {
    var l = mS(o.alternate, o, Ri);
    o.memoizedProps = o.pendingProps, l === null ? ed(o) : Ue = l;
  }
  function VS(o) {
    var l = o, c = l.alternate;
    switch (l.tag) {
      case 15:
      case 0:
        l = uS(
          c,
          l,
          l.pendingProps,
          l.type,
          void 0,
          Ke
        );
        break;
      case 11:
        l = uS(
          c,
          l,
          l.pendingProps,
          l.type.render,
          l.ref,
          Ke
        );
        break;
      case 5:
        lg(l);
      default:
        yS(c, l), l = Ue = Ux(l, Ri), l = mS(c, l, Ri);
    }
    o.memoizedProps = o.pendingProps, l === null ? ed(o) : Ue = l;
  }
  function xs(o, l, c, m) {
    wi = la = null, lg(l), fs = null, su = 0;
    var v = l.return;
    try {
      if (TD(
        o,
        v,
        l,
        c,
        Ke
      )) {
        Tt = 1, qf(
          o,
          ar(c, o.current)
        ), Ue = null;
        return;
      }
    } catch (w) {
      if (v !== null) throw Ue = v, w;
      Tt = 1, qf(
        o,
        ar(c, o.current)
      ), Ue = null;
      return;
    }
    l.flags & 32768 ? (et || m === 1 ? o = !0 : ms || (Ke & 536870912) !== 0 ? o = !1 : (yo = o = !0, (m === 2 || m === 9 || m === 3 || m === 6) && (m = cr.current, m !== null && m.tag === 13 && (m.flags |= 16384))), US(l, o)) : ed(l);
  }
  function ed(o) {
    var l = o;
    do {
      if ((l.flags & 32768) !== 0) {
        US(
          l,
          yo
        );
        return;
      }
      o = l.return;
      var c = OD(
        l.alternate,
        l,
        Ri
      );
      if (c !== null) {
        Ue = c;
        return;
      }
      if (l = l.sibling, l !== null) {
        Ue = l;
        return;
      }
      Ue = l = o;
    } while (l !== null);
    Tt === 0 && (Tt = 5);
  }
  function US(o, l) {
    do {
      var c = ND(o.alternate, o);
      if (c !== null) {
        c.flags &= 32767, Ue = c;
        return;
      }
      if (c = o.return, c !== null && (c.flags |= 32768, c.subtreeFlags = 0, c.deletions = null), !l && (o = o.sibling, o !== null)) {
        Ue = o;
        return;
      }
      Ue = o = c;
    } while (o !== null);
    Tt = 6, Ue = null;
  }
  function qS(o, l, c, m, v, w, M, L, X) {
    o.cancelPendingCommit = null;
    do
      td();
    while (tn !== 0);
    if ((ot & 6) !== 0) throw Error(r(327));
    if (l !== null) {
      if (l === o.current) throw Error(r(177));
      if (w = l.lanes | l.childLanes, w |= Im, fm(
        o,
        c,
        w,
        M,
        L,
        X
      ), o === gt && (Ue = gt = null, Ke = 0), ys = l, xo = o, vs = c, Hg = w, Vg = v, zS = m, (l.subtreeFlags & 10256) !== 0 || (l.flags & 10256) !== 0 ? (o.callbackNode = null, o.callbackPriority = 0, VD(ir, function() {
        return KS(), null;
      })) : (o.callbackNode = null, o.callbackPriority = 0), m = (l.flags & 13878) !== 0, (l.subtreeFlags & 13878) !== 0 || m) {
        m = z.T, z.T = null, v = B.p, B.p = 2, M = ot, ot |= 4;
        try {
          MD(o, l, c);
        } finally {
          ot = M, B.p = v, z.T = m;
        }
      }
      tn = 1, YS(), GS(), XS();
    }
  }
  function YS() {
    if (tn === 1) {
      tn = 0;
      var o = xo, l = ys, c = (l.flags & 13878) !== 0;
      if ((l.subtreeFlags & 13878) !== 0 || c) {
        c = z.T, z.T = null;
        var m = B.p;
        B.p = 2;
        var v = ot;
        ot |= 4;
        try {
          TS(l, o);
          var w = o0, M = Px(o.containerInfo), L = w.focusedElem, X = w.selectionRange;
          if (M !== L && L && L.ownerDocument && Dx(
            L.ownerDocument.documentElement,
            L
          )) {
            if (X !== null && Mm(L)) {
              var ee = X.start, ue = X.end;
              if (ue === void 0 && (ue = ee), "selectionStart" in L)
                L.selectionStart = ee, L.selectionEnd = Math.min(
                  ue,
                  L.value.length
                );
              else {
                var de = L.ownerDocument || document, te = de && de.defaultView || window;
                if (te.getSelection) {
                  var ne = te.getSelection(), ze = L.textContent.length, Ne = Math.min(X.start, ze), ut = X.end === void 0 ? Ne : Math.min(X.end, ze);
                  !ne.extend && Ne > ut && (M = ut, ut = Ne, Ne = M);
                  var Q = Mx(
                    L,
                    Ne
                  ), K = Mx(
                    L,
                    ut
                  );
                  if (Q && K && (ne.rangeCount !== 1 || ne.anchorNode !== Q.node || ne.anchorOffset !== Q.offset || ne.focusNode !== K.node || ne.focusOffset !== K.offset)) {
                    var J = de.createRange();
                    J.setStart(Q.node, Q.offset), ne.removeAllRanges(), Ne > ut ? (ne.addRange(J), ne.extend(K.node, K.offset)) : (J.setEnd(K.node, K.offset), ne.addRange(J));
                  }
                }
              }
            }
            for (de = [], ne = L; ne = ne.parentNode; )
              ne.nodeType === 1 && de.push({
                element: ne,
                left: ne.scrollLeft,
                top: ne.scrollTop
              });
            for (typeof L.focus == "function" && L.focus(), L = 0; L < de.length; L++) {
              var ce = de[L];
              ce.element.scrollLeft = ce.left, ce.element.scrollTop = ce.top;
            }
          }
          hd = !!i0, o0 = i0 = null;
        } finally {
          ot = v, B.p = m, z.T = c;
        }
      }
      o.current = l, tn = 2;
    }
  }
  function GS() {
    if (tn === 2) {
      tn = 0;
      var o = xo, l = ys, c = (l.flags & 8772) !== 0;
      if ((l.subtreeFlags & 8772) !== 0 || c) {
        c = z.T, z.T = null;
        var m = B.p;
        B.p = 2;
        var v = ot;
        ot |= 4;
        try {
          ES(o, l.alternate, l);
        } finally {
          ot = v, B.p = m, z.T = c;
        }
      }
      tn = 3;
    }
  }
  function XS() {
    if (tn === 4 || tn === 3) {
      tn = 0, Jt();
      var o = xo, l = ys, c = vs, m = zS;
      (l.subtreeFlags & 10256) !== 0 || (l.flags & 10256) !== 0 ? tn = 5 : (tn = 0, ys = xo = null, WS(o, o.pendingLanes));
      var v = o.pendingLanes;
      if (v === 0 && (bo = null), Ol(c), l = l.stateNode, pe && typeof pe.onCommitFiberRoot == "function")
        try {
          pe.onCommitFiberRoot(
            ae,
            l,
            void 0,
            (l.current.flags & 128) === 128
          );
        } catch {
        }
      if (m !== null) {
        l = z.T, v = B.p, B.p = 2, z.T = null;
        try {
          for (var w = o.onRecoverableError, M = 0; M < m.length; M++) {
            var L = m[M];
            w(L.value, {
              componentStack: L.stack
            });
          }
        } finally {
          z.T = l, B.p = v;
        }
      }
      (vs & 3) !== 0 && td(), Ur(o), v = o.pendingLanes, (c & 4194090) !== 0 && (v & 42) !== 0 ? o === Ug ? gu++ : (gu = 0, Ug = o) : gu = 0, yu(0);
    }
  }
  function WS(o, l) {
    (o.pooledCacheLanes &= l) === 0 && (l = o.pooledCache, l != null && (o.pooledCache = null, Kl(l)));
  }
  function td(o) {
    return YS(), GS(), XS(), KS();
  }
  function KS() {
    if (tn !== 5) return !1;
    var o = xo, l = Hg;
    Hg = 0;
    var c = Ol(vs), m = z.T, v = B.p;
    try {
      B.p = 32 > c ? 32 : c, z.T = null, c = Vg, Vg = null;
      var w = xo, M = vs;
      if (tn = 0, ys = xo = null, vs = 0, (ot & 6) !== 0) throw Error(r(331));
      var L = ot;
      if (ot |= 4, DS(w.current), OS(
        w,
        w.current,
        M,
        c
      ), ot = L, yu(0, !1), pe && typeof pe.onPostCommitFiberRoot == "function")
        try {
          pe.onPostCommitFiberRoot(ae, w);
        } catch {
        }
      return !0;
    } finally {
      B.p = v, z.T = m, WS(o, l);
    }
  }
  function ZS(o, l, c) {
    l = ar(c, l), l = Sg(o.stateNode, l, 2), o = uo(o, l, 2), o !== null && (Zo(o, 2), Ur(o));
  }
  function dt(o, l, c) {
    if (o.tag === 3)
      ZS(o, o, c);
    else
      for (; l !== null; ) {
        if (l.tag === 3) {
          ZS(
            l,
            o,
            c
          );
          break;
        } else if (l.tag === 1) {
          var m = l.stateNode;
          if (typeof l.type.getDerivedStateFromError == "function" || typeof m.componentDidCatch == "function" && (bo === null || !bo.has(m))) {
            o = ar(c, o), c = tS(2), m = uo(l, c, 2), m !== null && (nS(
              c,
              m,
              l,
              o
            ), Zo(m, 2), Ur(m));
            break;
          }
        }
        l = l.return;
      }
  }
  function Xg(o, l, c) {
    var m = o.pingCache;
    if (m === null) {
      m = o.pingCache = new zD();
      var v = /* @__PURE__ */ new Set();
      m.set(l, v);
    } else
      v = m.get(l), v === void 0 && (v = /* @__PURE__ */ new Set(), m.set(l, v));
    v.has(c) || (Lg = !0, v.add(c), o = BD.bind(null, o, l, c), l.then(o, o));
  }
  function BD(o, l, c) {
    var m = o.pingCache;
    m !== null && m.delete(l), o.pingedLanes |= o.suspendedLanes & c, o.warmLanes &= ~c, gt === o && (Ke & c) === c && (Tt === 4 || Tt === 3 && (Ke & 62914560) === Ke && 300 > bt() - $g ? (ot & 2) === 0 && bs(o, 0) : Fg |= c, gs === Ke && (gs = 0)), Ur(o);
  }
  function QS(o, l) {
    l === 0 && (l = ef()), o = ts(o, l), o !== null && (Zo(o, l), Ur(o));
  }
  function $D(o) {
    var l = o.memoizedState, c = 0;
    l !== null && (c = l.retryLane), QS(o, c);
  }
  function HD(o, l) {
    var c = 0;
    switch (o.tag) {
      case 13:
        var m = o.stateNode, v = o.memoizedState;
        v !== null && (c = v.retryLane);
        break;
      case 19:
        m = o.stateNode;
        break;
      case 22:
        m = o.stateNode._retryCache;
        break;
      default:
        throw Error(r(314));
    }
    m !== null && m.delete(l), QS(o, c);
  }
  function VD(o, l) {
    return Le(o, l);
  }
  var nd = null, ws = null, Wg = !1, rd = !1, Kg = !1, ma = 0;
  function Ur(o) {
    o !== ws && o.next === null && (ws === null ? nd = ws = o : ws = ws.next = o), rd = !0, Wg || (Wg = !0, qD());
  }
  function yu(o, l) {
    if (!Kg && rd) {
      Kg = !0;
      do
        for (var c = !1, m = nd; m !== null; ) {
          if (o !== 0) {
            var v = m.pendingLanes;
            if (v === 0) var w = 0;
            else {
              var M = m.suspendedLanes, L = m.pingedLanes;
              w = (1 << 31 - Ae(42 | o) + 1) - 1, w &= v & ~(M & ~L), w = w & 201326741 ? w & 201326741 | 1 : w ? w | 2 : 0;
            }
            w !== 0 && (c = !0, n_(m, w));
          } else
            w = Ke, w = jt(
              m,
              m === gt ? w : 0,
              m.cancelPendingCommit !== null || m.timeoutHandle !== -1
            ), (w & 3) === 0 || Cn(m, w) || (c = !0, n_(m, w));
          m = m.next;
        }
      while (c);
      Kg = !1;
    }
  }
  function UD() {
    JS();
  }
  function JS() {
    rd = Wg = !1;
    var o = 0;
    ma !== 0 && (JD() && (o = ma), ma = 0);
    for (var l = bt(), c = null, m = nd; m !== null; ) {
      var v = m.next, w = e_(m, l);
      w === 0 ? (m.next = null, c === null ? nd = v : c.next = v, v === null && (ws = c)) : (c = m, (o !== 0 || (w & 3) !== 0) && (rd = !0)), m = v;
    }
    yu(o);
  }
  function e_(o, l) {
    for (var c = o.suspendedLanes, m = o.pingedLanes, v = o.expirationTimes, w = o.pendingLanes & -62914561; 0 < w; ) {
      var M = 31 - Ae(w), L = 1 << M, X = v[M];
      X === -1 ? ((L & c) === 0 || (L & m) !== 0) && (v[M] = Fn(L, l)) : X <= l && (o.expiredLanes |= L), w &= ~L;
    }
    if (l = gt, c = Ke, c = jt(
      o,
      o === l ? c : 0,
      o.cancelPendingCommit !== null || o.timeoutHandle !== -1
    ), m = o.callbackNode, c === 0 || o === l && (at === 2 || at === 9) || o.cancelPendingCommit !== null)
      return m !== null && m !== null && Ie(m), o.callbackNode = null, o.callbackPriority = 0;
    if ((c & 3) === 0 || Cn(o, c)) {
      if (l = c & -c, l === o.callbackPriority) return l;
      switch (m !== null && Ie(m), Ol(c)) {
        case 2:
        case 8:
          c = En;
          break;
        case 32:
          c = ir;
          break;
        case 268435456:
          c = Lr;
          break;
        default:
          c = ir;
      }
      return m = t_.bind(null, o), c = Le(c, m), o.callbackPriority = l, o.callbackNode = c, l;
    }
    return m !== null && m !== null && Ie(m), o.callbackPriority = 2, o.callbackNode = null, 2;
  }
  function t_(o, l) {
    if (tn !== 0 && tn !== 5)
      return o.callbackNode = null, o.callbackPriority = 0, null;
    var c = o.callbackNode;
    if (td() && o.callbackNode !== c)
      return null;
    var m = Ke;
    return m = jt(
      o,
      o === gt ? m : 0,
      o.cancelPendingCommit !== null || o.timeoutHandle !== -1
    ), m === 0 ? null : (IS(o, m, l), e_(o, bt()), o.callbackNode != null && o.callbackNode === c ? t_.bind(null, o) : null);
  }
  function n_(o, l) {
    if (td()) return null;
    IS(o, l, !0);
  }
  function qD() {
    tP(function() {
      (ot & 6) !== 0 ? Le(
        xr,
        UD
      ) : JS();
    });
  }
  function Zg() {
    return ma === 0 && (ma = Jc()), ma;
  }
  function r_(o) {
    return o == null || typeof o == "symbol" || typeof o == "boolean" ? null : typeof o == "function" ? o : pf("" + o);
  }
  function i_(o, l) {
    var c = l.ownerDocument.createElement("input");
    return c.name = l.name, c.value = l.value, o.id && c.setAttribute("form", o.id), l.parentNode.insertBefore(c, l), o = new FormData(o), c.parentNode.removeChild(c), o;
  }
  function YD(o, l, c, m, v) {
    if (l === "submit" && c && c.stateNode === v) {
      var w = r_(
        (v[sn] || null).action
      ), M = m.submitter;
      M && (l = (l = M[sn] || null) ? r_(l.formAction) : M.getAttribute("formAction"), l !== null && (w = l, M = null));
      var L = new vf(
        "action",
        "action",
        null,
        m,
        v
      );
      o.push({
        event: L,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (m.defaultPrevented) {
                if (ma !== 0) {
                  var X = M ? i_(v, M) : new FormData(v);
                  yg(
                    c,
                    {
                      pending: !0,
                      data: X,
                      method: v.method,
                      action: w
                    },
                    null,
                    X
                  );
                }
              } else
                typeof w == "function" && (L.preventDefault(), X = M ? i_(v, M) : new FormData(v), yg(
                  c,
                  {
                    pending: !0,
                    data: X,
                    method: v.method,
                    action: w
                  },
                  w,
                  X
                ));
            },
            currentTarget: v
          }
        ]
      });
    }
  }
  for (var Qg = 0; Qg < jm.length; Qg++) {
    var Jg = jm[Qg], GD = Jg.toLowerCase(), XD = Jg[0].toUpperCase() + Jg.slice(1);
    _r(
      GD,
      "on" + XD
    );
  }
  _r(Ix, "onAnimationEnd"), _r(Lx, "onAnimationIteration"), _r(Fx, "onAnimationStart"), _r("dblclick", "onDoubleClick"), _r("focusin", "onFocus"), _r("focusout", "onBlur"), _r(fD, "onTransitionRun"), _r(dD, "onTransitionStart"), _r(hD, "onTransitionCancel"), _r(Bx, "onTransitionEnd"), no("onMouseEnter", ["mouseout", "mouseover"]), no("onMouseLeave", ["mouseout", "mouseover"]), no("onPointerEnter", ["pointerout", "pointerover"]), no("onPointerLeave", ["pointerout", "pointerover"]), gi(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), gi(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), gi("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), gi(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), gi(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), gi(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var vu = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), WD = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(vu)
  );
  function o_(o, l) {
    l = (l & 4) !== 0;
    for (var c = 0; c < o.length; c++) {
      var m = o[c], v = m.event;
      m = m.listeners;
      e: {
        var w = void 0;
        if (l)
          for (var M = m.length - 1; 0 <= M; M--) {
            var L = m[M], X = L.instance, ee = L.currentTarget;
            if (L = L.listener, X !== w && v.isPropagationStopped())
              break e;
            w = L, v.currentTarget = ee;
            try {
              w(v);
            } catch (ue) {
              Uf(ue);
            }
            v.currentTarget = null, w = X;
          }
        else
          for (M = 0; M < m.length; M++) {
            if (L = m[M], X = L.instance, ee = L.currentTarget, L = L.listener, X !== w && v.isPropagationStopped())
              break e;
            w = L, v.currentTarget = ee;
            try {
              w(v);
            } catch (ue) {
              Uf(ue);
            }
            v.currentTarget = null, w = X;
          }
      }
    }
  }
  function qe(o, l) {
    var c = l[Nl];
    c === void 0 && (c = l[Nl] = /* @__PURE__ */ new Set());
    var m = o + "__bubble";
    c.has(m) || (a_(l, o, 2, !1), c.add(m));
  }
  function e0(o, l, c) {
    var m = 0;
    l && (m |= 4), a_(
      c,
      o,
      m,
      l
    );
  }
  var id = "_reactListening" + Math.random().toString(36).slice(2);
  function t0(o) {
    if (!o[id]) {
      o[id] = !0, of.forEach(function(c) {
        c !== "selectionchange" && (WD.has(c) || e0(c, !1, o), e0(c, !0, o));
      });
      var l = o.nodeType === 9 ? o : o.ownerDocument;
      l === null || l[id] || (l[id] = !0, e0("selectionchange", !1, l));
    }
  }
  function a_(o, l, c, m) {
    switch (O_(l)) {
      case 2:
        var v = SP;
        break;
      case 8:
        v = _P;
        break;
      default:
        v = m0;
    }
    c = v.bind(
      null,
      l,
      c,
      o
    ), v = void 0, !_m || l !== "touchstart" && l !== "touchmove" && l !== "wheel" || (v = !0), m ? v !== void 0 ? o.addEventListener(l, c, {
      capture: !0,
      passive: v
    }) : o.addEventListener(l, c, !0) : v !== void 0 ? o.addEventListener(l, c, {
      passive: v
    }) : o.addEventListener(l, c, !1);
  }
  function n0(o, l, c, m, v) {
    var w = m;
    if ((l & 1) === 0 && (l & 2) === 0 && m !== null)
      e: for (; ; ) {
        if (m === null) return;
        var M = m.tag;
        if (M === 3 || M === 4) {
          var L = m.stateNode.containerInfo;
          if (L === v) break;
          if (M === 4)
            for (M = m.return; M !== null; ) {
              var X = M.tag;
              if ((X === 3 || X === 4) && M.stateNode.containerInfo === v)
                return;
              M = M.return;
            }
          for (; L !== null; ) {
            if (M = pi(L), M === null) return;
            if (X = M.tag, X === 5 || X === 6 || X === 26 || X === 27) {
              m = w = M;
              continue e;
            }
            L = L.parentNode;
          }
        }
        m = m.return;
      }
    hx(function() {
      var ee = w, ue = wm(c), de = [];
      e: {
        var te = $x.get(o);
        if (te !== void 0) {
          var ne = vf, ze = o;
          switch (o) {
            case "keypress":
              if (gf(c) === 0) break e;
            case "keydown":
            case "keyup":
              ne = V4;
              break;
            case "focusin":
              ze = "focus", ne = Am;
              break;
            case "focusout":
              ze = "blur", ne = Am;
              break;
            case "beforeblur":
            case "afterblur":
              ne = Am;
              break;
            case "click":
              if (c.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              ne = gx;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              ne = N4;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              ne = Y4;
              break;
            case Ix:
            case Lx:
            case Fx:
              ne = P4;
              break;
            case Bx:
              ne = X4;
              break;
            case "scroll":
            case "scrollend":
              ne = R4;
              break;
            case "wheel":
              ne = K4;
              break;
            case "copy":
            case "cut":
            case "paste":
              ne = j4;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              ne = vx;
              break;
            case "toggle":
            case "beforetoggle":
              ne = Q4;
          }
          var Ne = (l & 4) !== 0, ut = !Ne && (o === "scroll" || o === "scrollend"), Q = Ne ? te !== null ? te + "Capture" : null : te;
          Ne = [];
          for (var K = ee, J; K !== null; ) {
            var ce = K;
            if (J = ce.stateNode, ce = ce.tag, ce !== 5 && ce !== 26 && ce !== 27 || J === null || Q === null || (ce = Il(K, Q), ce != null && Ne.push(
              bu(K, ce, J)
            )), ut) break;
            K = K.return;
          }
          0 < Ne.length && (te = new ne(
            te,
            ze,
            null,
            c,
            ue
          ), de.push({ event: te, listeners: Ne }));
        }
      }
      if ((l & 7) === 0) {
        e: {
          if (te = o === "mouseover" || o === "pointerover", ne = o === "mouseout" || o === "pointerout", te && c !== xm && (ze = c.relatedTarget || c.fromElement) && (pi(ze) || ze[eo]))
            break e;
          if ((ne || te) && (te = ue.window === ue ? ue : (te = ue.ownerDocument) ? te.defaultView || te.parentWindow : window, ne ? (ze = c.relatedTarget || c.toElement, ne = ee, ze = ze ? pi(ze) : null, ze !== null && (ut = a(ze), Ne = ze.tag, ze !== ut || Ne !== 5 && Ne !== 27 && Ne !== 6) && (ze = null)) : (ne = null, ze = ee), ne !== ze)) {
            if (Ne = gx, ce = "onMouseLeave", Q = "onMouseEnter", K = "mouse", (o === "pointerout" || o === "pointerover") && (Ne = vx, ce = "onPointerLeave", Q = "onPointerEnter", K = "pointer"), ut = ne == null ? te : Jo(ne), J = ze == null ? te : Jo(ze), te = new Ne(
              ce,
              K + "leave",
              ne,
              c,
              ue
            ), te.target = ut, te.relatedTarget = J, ce = null, pi(ue) === ee && (Ne = new Ne(
              Q,
              K + "enter",
              ze,
              c,
              ue
            ), Ne.target = J, Ne.relatedTarget = ut, ce = Ne), ut = ce, ne && ze)
              t: {
                for (Ne = ne, Q = ze, K = 0, J = Ne; J; J = Ss(J))
                  K++;
                for (J = 0, ce = Q; ce; ce = Ss(ce))
                  J++;
                for (; 0 < K - J; )
                  Ne = Ss(Ne), K--;
                for (; 0 < J - K; )
                  Q = Ss(Q), J--;
                for (; K--; ) {
                  if (Ne === Q || Q !== null && Ne === Q.alternate)
                    break t;
                  Ne = Ss(Ne), Q = Ss(Q);
                }
                Ne = null;
              }
            else Ne = null;
            ne !== null && s_(
              de,
              te,
              ne,
              Ne,
              !1
            ), ze !== null && ut !== null && s_(
              de,
              ut,
              ze,
              Ne,
              !0
            );
          }
        }
        e: {
          if (te = ee ? Jo(ee) : window, ne = te.nodeName && te.nodeName.toLowerCase(), ne === "select" || ne === "input" && te.type === "file")
            var xe = kx;
          else if (Ex(te))
            if (Ax)
              xe = lD;
            else {
              xe = aD;
              var Ve = oD;
            }
          else
            ne = te.nodeName, !ne || ne.toLowerCase() !== "input" || te.type !== "checkbox" && te.type !== "radio" ? ee && bm(ee.elementType) && (xe = kx) : xe = sD;
          if (xe && (xe = xe(o, ee))) {
            Cx(
              de,
              xe,
              c,
              ue
            );
            break e;
          }
          Ve && Ve(o, te, ee), o === "focusout" && ee && te.type === "number" && ee.memoizedProps.value != null && vm(te, "number", te.value);
        }
        switch (Ve = ee ? Jo(ee) : window, o) {
          case "focusin":
            (Ex(Ve) || Ve.contentEditable === "true") && (Qa = Ve, Dm = ee, ql = null);
            break;
          case "focusout":
            ql = Dm = Qa = null;
            break;
          case "mousedown":
            Pm = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Pm = !1, zx(de, c, ue);
            break;
          case "selectionchange":
            if (cD) break;
          case "keydown":
          case "keyup":
            zx(de, c, ue);
        }
        var Se;
        if (Rm)
          e: {
            switch (o) {
              case "compositionstart":
                var Me = "onCompositionStart";
                break e;
              case "compositionend":
                Me = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Me = "onCompositionUpdate";
                break e;
            }
            Me = void 0;
          }
        else
          Za ? Sx(o, c) && (Me = "onCompositionEnd") : o === "keydown" && c.keyCode === 229 && (Me = "onCompositionStart");
        Me && (bx && c.locale !== "ko" && (Za || Me !== "onCompositionStart" ? Me === "onCompositionEnd" && Za && (Se = px()) : (oo = ue, Em = "value" in oo ? oo.value : oo.textContent, Za = !0)), Ve = od(ee, Me), 0 < Ve.length && (Me = new yx(
          Me,
          o,
          null,
          c,
          ue
        ), de.push({ event: Me, listeners: Ve }), Se ? Me.data = Se : (Se = _x(c), Se !== null && (Me.data = Se)))), (Se = eD ? tD(o, c) : nD(o, c)) && (Me = od(ee, "onBeforeInput"), 0 < Me.length && (Ve = new yx(
          "onBeforeInput",
          "beforeinput",
          null,
          c,
          ue
        ), de.push({
          event: Ve,
          listeners: Me
        }), Ve.data = Se)), YD(
          de,
          o,
          ee,
          c,
          ue
        );
      }
      o_(de, l);
    });
  }
  function bu(o, l, c) {
    return {
      instance: o,
      listener: l,
      currentTarget: c
    };
  }
  function od(o, l) {
    for (var c = l + "Capture", m = []; o !== null; ) {
      var v = o, w = v.stateNode;
      if (v = v.tag, v !== 5 && v !== 26 && v !== 27 || w === null || (v = Il(o, c), v != null && m.unshift(
        bu(o, v, w)
      ), v = Il(o, l), v != null && m.push(
        bu(o, v, w)
      )), o.tag === 3) return m;
      o = o.return;
    }
    return [];
  }
  function Ss(o) {
    if (o === null) return null;
    do
      o = o.return;
    while (o && o.tag !== 5 && o.tag !== 27);
    return o || null;
  }
  function s_(o, l, c, m, v) {
    for (var w = l._reactName, M = []; c !== null && c !== m; ) {
      var L = c, X = L.alternate, ee = L.stateNode;
      if (L = L.tag, X !== null && X === m) break;
      L !== 5 && L !== 26 && L !== 27 || ee === null || (X = ee, v ? (ee = Il(c, w), ee != null && M.unshift(
        bu(c, ee, X)
      )) : v || (ee = Il(c, w), ee != null && M.push(
        bu(c, ee, X)
      ))), c = c.return;
    }
    M.length !== 0 && o.push({ event: l, listeners: M });
  }
  var KD = /\r\n?/g, ZD = /\u0000|\uFFFD/g;
  function l_(o) {
    return (typeof o == "string" ? o : "" + o).replace(KD, `
`).replace(ZD, "");
  }
  function u_(o, l) {
    return l = l_(l), l_(o) === l;
  }
  function ad() {
  }
  function lt(o, l, c, m, v, w) {
    switch (c) {
      case "children":
        typeof m == "string" ? l === "body" || l === "textarea" && m === "" || Xa(o, m) : (typeof m == "number" || typeof m == "bigint") && l !== "body" && Xa(o, "" + m);
        break;
      case "className":
        Ua(o, "class", m);
        break;
      case "tabIndex":
        Ua(o, "tabindex", m);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        Ua(o, c, m);
        break;
      case "style":
        fx(o, m, w);
        break;
      case "data":
        if (l !== "object") {
          Ua(o, "data", m);
          break;
        }
      case "src":
      case "href":
        if (m === "" && (l !== "a" || c !== "href")) {
          o.removeAttribute(c);
          break;
        }
        if (m == null || typeof m == "function" || typeof m == "symbol" || typeof m == "boolean") {
          o.removeAttribute(c);
          break;
        }
        m = pf("" + m), o.setAttribute(c, m);
        break;
      case "action":
      case "formAction":
        if (typeof m == "function") {
          o.setAttribute(
            c,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof w == "function" && (c === "formAction" ? (l !== "input" && lt(o, l, "name", v.name, v, null), lt(
            o,
            l,
            "formEncType",
            v.formEncType,
            v,
            null
          ), lt(
            o,
            l,
            "formMethod",
            v.formMethod,
            v,
            null
          ), lt(
            o,
            l,
            "formTarget",
            v.formTarget,
            v,
            null
          )) : (lt(o, l, "encType", v.encType, v, null), lt(o, l, "method", v.method, v, null), lt(o, l, "target", v.target, v, null)));
        if (m == null || typeof m == "symbol" || typeof m == "boolean") {
          o.removeAttribute(c);
          break;
        }
        m = pf("" + m), o.setAttribute(c, m);
        break;
      case "onClick":
        m != null && (o.onclick = ad);
        break;
      case "onScroll":
        m != null && qe("scroll", o);
        break;
      case "onScrollEnd":
        m != null && qe("scrollend", o);
        break;
      case "dangerouslySetInnerHTML":
        if (m != null) {
          if (typeof m != "object" || !("__html" in m))
            throw Error(r(61));
          if (c = m.__html, c != null) {
            if (v.children != null) throw Error(r(60));
            o.innerHTML = c;
          }
        }
        break;
      case "multiple":
        o.multiple = m && typeof m != "function" && typeof m != "symbol";
        break;
      case "muted":
        o.muted = m && typeof m != "function" && typeof m != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (m == null || typeof m == "function" || typeof m == "boolean" || typeof m == "symbol") {
          o.removeAttribute("xlink:href");
          break;
        }
        c = pf("" + m), o.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          c
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        m != null && typeof m != "function" && typeof m != "symbol" ? o.setAttribute(c, "" + m) : o.removeAttribute(c);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        m && typeof m != "function" && typeof m != "symbol" ? o.setAttribute(c, "") : o.removeAttribute(c);
        break;
      case "capture":
      case "download":
        m === !0 ? o.setAttribute(c, "") : m !== !1 && m != null && typeof m != "function" && typeof m != "symbol" ? o.setAttribute(c, m) : o.removeAttribute(c);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        m != null && typeof m != "function" && typeof m != "symbol" && !isNaN(m) && 1 <= m ? o.setAttribute(c, m) : o.removeAttribute(c);
        break;
      case "rowSpan":
      case "start":
        m == null || typeof m == "function" || typeof m == "symbol" || isNaN(m) ? o.removeAttribute(c) : o.setAttribute(c, m);
        break;
      case "popover":
        qe("beforetoggle", o), qe("toggle", o), Va(o, "popover", m);
        break;
      case "xlinkActuate":
        Sr(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          m
        );
        break;
      case "xlinkArcrole":
        Sr(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          m
        );
        break;
      case "xlinkRole":
        Sr(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          m
        );
        break;
      case "xlinkShow":
        Sr(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          m
        );
        break;
      case "xlinkTitle":
        Sr(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          m
        );
        break;
      case "xlinkType":
        Sr(
          o,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          m
        );
        break;
      case "xmlBase":
        Sr(
          o,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          m
        );
        break;
      case "xmlLang":
        Sr(
          o,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          m
        );
        break;
      case "xmlSpace":
        Sr(
          o,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          m
        );
        break;
      case "is":
        Va(o, "is", m);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < c.length) || c[0] !== "o" && c[0] !== "O" || c[1] !== "n" && c[1] !== "N") && (c = A4.get(c) || c, Va(o, c, m));
    }
  }
  function r0(o, l, c, m, v, w) {
    switch (c) {
      case "style":
        fx(o, m, w);
        break;
      case "dangerouslySetInnerHTML":
        if (m != null) {
          if (typeof m != "object" || !("__html" in m))
            throw Error(r(61));
          if (c = m.__html, c != null) {
            if (v.children != null) throw Error(r(60));
            o.innerHTML = c;
          }
        }
        break;
      case "children":
        typeof m == "string" ? Xa(o, m) : (typeof m == "number" || typeof m == "bigint") && Xa(o, "" + m);
        break;
      case "onScroll":
        m != null && qe("scroll", o);
        break;
      case "onScrollEnd":
        m != null && qe("scrollend", o);
        break;
      case "onClick":
        m != null && (o.onclick = ad);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!af.hasOwnProperty(c))
          e: {
            if (c[0] === "o" && c[1] === "n" && (v = c.endsWith("Capture"), l = c.slice(2, v ? c.length - 7 : void 0), w = o[sn] || null, w = w != null ? w[c] : null, typeof w == "function" && o.removeEventListener(l, w, v), typeof m == "function")) {
              typeof w != "function" && w !== null && (c in o ? o[c] = null : o.hasAttribute(c) && o.removeAttribute(c)), o.addEventListener(l, m, v);
              break e;
            }
            c in o ? o[c] = m : m === !0 ? o.setAttribute(c, "") : Va(o, c, m);
          }
    }
  }
  function nn(o, l, c) {
    switch (l) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        qe("error", o), qe("load", o);
        var m = !1, v = !1, w;
        for (w in c)
          if (c.hasOwnProperty(w)) {
            var M = c[w];
            if (M != null)
              switch (w) {
                case "src":
                  m = !0;
                  break;
                case "srcSet":
                  v = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(r(137, l));
                default:
                  lt(o, l, w, M, c, null);
              }
          }
        v && lt(o, l, "srcSet", c.srcSet, c, null), m && lt(o, l, "src", c.src, c, null);
        return;
      case "input":
        qe("invalid", o);
        var L = w = M = v = null, X = null, ee = null;
        for (m in c)
          if (c.hasOwnProperty(m)) {
            var ue = c[m];
            if (ue != null)
              switch (m) {
                case "name":
                  v = ue;
                  break;
                case "type":
                  M = ue;
                  break;
                case "checked":
                  X = ue;
                  break;
                case "defaultChecked":
                  ee = ue;
                  break;
                case "value":
                  w = ue;
                  break;
                case "defaultValue":
                  L = ue;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (ue != null)
                    throw Error(r(137, l));
                  break;
                default:
                  lt(o, l, m, ue, c, null);
              }
          }
        sx(
          o,
          w,
          L,
          X,
          ee,
          M,
          v,
          !1
        ), qa(o);
        return;
      case "select":
        qe("invalid", o), m = M = w = null;
        for (v in c)
          if (c.hasOwnProperty(v) && (L = c[v], L != null))
            switch (v) {
              case "value":
                w = L;
                break;
              case "defaultValue":
                M = L;
                break;
              case "multiple":
                m = L;
              default:
                lt(o, l, v, L, c, null);
            }
        l = w, c = M, o.multiple = !!m, l != null ? Ga(o, !!m, l, !1) : c != null && Ga(o, !!m, c, !0);
        return;
      case "textarea":
        qe("invalid", o), w = v = m = null;
        for (M in c)
          if (c.hasOwnProperty(M) && (L = c[M], L != null))
            switch (M) {
              case "value":
                m = L;
                break;
              case "defaultValue":
                v = L;
                break;
              case "children":
                w = L;
                break;
              case "dangerouslySetInnerHTML":
                if (L != null) throw Error(r(91));
                break;
              default:
                lt(o, l, M, L, c, null);
            }
        ux(o, m, v, w), qa(o);
        return;
      case "option":
        for (X in c)
          if (c.hasOwnProperty(X) && (m = c[X], m != null))
            switch (X) {
              case "selected":
                o.selected = m && typeof m != "function" && typeof m != "symbol";
                break;
              default:
                lt(o, l, X, m, c, null);
            }
        return;
      case "dialog":
        qe("beforetoggle", o), qe("toggle", o), qe("cancel", o), qe("close", o);
        break;
      case "iframe":
      case "object":
        qe("load", o);
        break;
      case "video":
      case "audio":
        for (m = 0; m < vu.length; m++)
          qe(vu[m], o);
        break;
      case "image":
        qe("error", o), qe("load", o);
        break;
      case "details":
        qe("toggle", o);
        break;
      case "embed":
      case "source":
      case "link":
        qe("error", o), qe("load", o);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (ee in c)
          if (c.hasOwnProperty(ee) && (m = c[ee], m != null))
            switch (ee) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(r(137, l));
              default:
                lt(o, l, ee, m, c, null);
            }
        return;
      default:
        if (bm(l)) {
          for (ue in c)
            c.hasOwnProperty(ue) && (m = c[ue], m !== void 0 && r0(
              o,
              l,
              ue,
              m,
              c,
              void 0
            ));
          return;
        }
    }
    for (L in c)
      c.hasOwnProperty(L) && (m = c[L], m != null && lt(o, l, L, m, c, null));
  }
  function QD(o, l, c, m) {
    switch (l) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var v = null, w = null, M = null, L = null, X = null, ee = null, ue = null;
        for (ne in c) {
          var de = c[ne];
          if (c.hasOwnProperty(ne) && de != null)
            switch (ne) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                X = de;
              default:
                m.hasOwnProperty(ne) || lt(o, l, ne, null, m, de);
            }
        }
        for (var te in m) {
          var ne = m[te];
          if (de = c[te], m.hasOwnProperty(te) && (ne != null || de != null))
            switch (te) {
              case "type":
                w = ne;
                break;
              case "name":
                v = ne;
                break;
              case "checked":
                ee = ne;
                break;
              case "defaultChecked":
                ue = ne;
                break;
              case "value":
                M = ne;
                break;
              case "defaultValue":
                L = ne;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (ne != null)
                  throw Error(r(137, l));
                break;
              default:
                ne !== de && lt(
                  o,
                  l,
                  te,
                  ne,
                  m,
                  de
                );
            }
        }
        Ya(
          o,
          M,
          L,
          X,
          ee,
          ue,
          w,
          v
        );
        return;
      case "select":
        ne = M = L = te = null;
        for (w in c)
          if (X = c[w], c.hasOwnProperty(w) && X != null)
            switch (w) {
              case "value":
                break;
              case "multiple":
                ne = X;
              default:
                m.hasOwnProperty(w) || lt(
                  o,
                  l,
                  w,
                  null,
                  m,
                  X
                );
            }
        for (v in m)
          if (w = m[v], X = c[v], m.hasOwnProperty(v) && (w != null || X != null))
            switch (v) {
              case "value":
                te = w;
                break;
              case "defaultValue":
                L = w;
                break;
              case "multiple":
                M = w;
              default:
                w !== X && lt(
                  o,
                  l,
                  v,
                  w,
                  m,
                  X
                );
            }
        l = L, c = M, m = ne, te != null ? Ga(o, !!c, te, !1) : !!m != !!c && (l != null ? Ga(o, !!c, l, !0) : Ga(o, !!c, c ? [] : "", !1));
        return;
      case "textarea":
        ne = te = null;
        for (L in c)
          if (v = c[L], c.hasOwnProperty(L) && v != null && !m.hasOwnProperty(L))
            switch (L) {
              case "value":
                break;
              case "children":
                break;
              default:
                lt(o, l, L, null, m, v);
            }
        for (M in m)
          if (v = m[M], w = c[M], m.hasOwnProperty(M) && (v != null || w != null))
            switch (M) {
              case "value":
                te = v;
                break;
              case "defaultValue":
                ne = v;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (v != null) throw Error(r(91));
                break;
              default:
                v !== w && lt(o, l, M, v, m, w);
            }
        lx(o, te, ne);
        return;
      case "option":
        for (var ze in c)
          if (te = c[ze], c.hasOwnProperty(ze) && te != null && !m.hasOwnProperty(ze))
            switch (ze) {
              case "selected":
                o.selected = !1;
                break;
              default:
                lt(
                  o,
                  l,
                  ze,
                  null,
                  m,
                  te
                );
            }
        for (X in m)
          if (te = m[X], ne = c[X], m.hasOwnProperty(X) && te !== ne && (te != null || ne != null))
            switch (X) {
              case "selected":
                o.selected = te && typeof te != "function" && typeof te != "symbol";
                break;
              default:
                lt(
                  o,
                  l,
                  X,
                  te,
                  m,
                  ne
                );
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var Ne in c)
          te = c[Ne], c.hasOwnProperty(Ne) && te != null && !m.hasOwnProperty(Ne) && lt(o, l, Ne, null, m, te);
        for (ee in m)
          if (te = m[ee], ne = c[ee], m.hasOwnProperty(ee) && te !== ne && (te != null || ne != null))
            switch (ee) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (te != null)
                  throw Error(r(137, l));
                break;
              default:
                lt(
                  o,
                  l,
                  ee,
                  te,
                  m,
                  ne
                );
            }
        return;
      default:
        if (bm(l)) {
          for (var ut in c)
            te = c[ut], c.hasOwnProperty(ut) && te !== void 0 && !m.hasOwnProperty(ut) && r0(
              o,
              l,
              ut,
              void 0,
              m,
              te
            );
          for (ue in m)
            te = m[ue], ne = c[ue], !m.hasOwnProperty(ue) || te === ne || te === void 0 && ne === void 0 || r0(
              o,
              l,
              ue,
              te,
              m,
              ne
            );
          return;
        }
    }
    for (var Q in c)
      te = c[Q], c.hasOwnProperty(Q) && te != null && !m.hasOwnProperty(Q) && lt(o, l, Q, null, m, te);
    for (de in m)
      te = m[de], ne = c[de], !m.hasOwnProperty(de) || te === ne || te == null && ne == null || lt(o, l, de, te, m, ne);
  }
  var i0 = null, o0 = null;
  function sd(o) {
    return o.nodeType === 9 ? o : o.ownerDocument;
  }
  function c_(o) {
    switch (o) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function f_(o, l) {
    if (o === 0)
      switch (l) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return o === 1 && l === "foreignObject" ? 0 : o;
  }
  function a0(o, l) {
    return o === "textarea" || o === "noscript" || typeof l.children == "string" || typeof l.children == "number" || typeof l.children == "bigint" || typeof l.dangerouslySetInnerHTML == "object" && l.dangerouslySetInnerHTML !== null && l.dangerouslySetInnerHTML.__html != null;
  }
  var s0 = null;
  function JD() {
    var o = window.event;
    return o && o.type === "popstate" ? o === s0 ? !1 : (s0 = o, !0) : (s0 = null, !1);
  }
  var d_ = typeof setTimeout == "function" ? setTimeout : void 0, eP = typeof clearTimeout == "function" ? clearTimeout : void 0, h_ = typeof Promise == "function" ? Promise : void 0, tP = typeof queueMicrotask == "function" ? queueMicrotask : typeof h_ < "u" ? function(o) {
    return h_.resolve(null).then(o).catch(nP);
  } : d_;
  function nP(o) {
    setTimeout(function() {
      throw o;
    });
  }
  function So(o) {
    return o === "head";
  }
  function p_(o, l) {
    var c = l, m = 0, v = 0;
    do {
      var w = c.nextSibling;
      if (o.removeChild(c), w && w.nodeType === 8)
        if (c = w.data, c === "/$") {
          if (0 < m && 8 > m) {
            c = m;
            var M = o.ownerDocument;
            if (c & 1 && xu(M.documentElement), c & 2 && xu(M.body), c & 4)
              for (c = M.head, xu(c), M = c.firstChild; M; ) {
                var L = M.nextSibling, X = M.nodeName;
                M[Qo] || X === "SCRIPT" || X === "STYLE" || X === "LINK" && M.rel.toLowerCase() === "stylesheet" || c.removeChild(M), M = L;
              }
          }
          if (v === 0) {
            o.removeChild(w), Tu(l);
            return;
          }
          v--;
        } else
          c === "$" || c === "$?" || c === "$!" ? v++ : m = c.charCodeAt(0) - 48;
      else m = 0;
      c = w;
    } while (c);
    Tu(l);
  }
  function l0(o) {
    var l = o.firstChild;
    for (l && l.nodeType === 10 && (l = l.nextSibling); l; ) {
      var c = l;
      switch (l = l.nextSibling, c.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          l0(c), Ml(c);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (c.rel.toLowerCase() === "stylesheet") continue;
      }
      o.removeChild(c);
    }
  }
  function rP(o, l, c, m) {
    for (; o.nodeType === 1; ) {
      var v = c;
      if (o.nodeName.toLowerCase() !== l.toLowerCase()) {
        if (!m && (o.nodeName !== "INPUT" || o.type !== "hidden"))
          break;
      } else if (m) {
        if (!o[Qo])
          switch (l) {
            case "meta":
              if (!o.hasAttribute("itemprop")) break;
              return o;
            case "link":
              if (w = o.getAttribute("rel"), w === "stylesheet" && o.hasAttribute("data-precedence"))
                break;
              if (w !== v.rel || o.getAttribute("href") !== (v.href == null || v.href === "" ? null : v.href) || o.getAttribute("crossorigin") !== (v.crossOrigin == null ? null : v.crossOrigin) || o.getAttribute("title") !== (v.title == null ? null : v.title))
                break;
              return o;
            case "style":
              if (o.hasAttribute("data-precedence")) break;
              return o;
            case "script":
              if (w = o.getAttribute("src"), (w !== (v.src == null ? null : v.src) || o.getAttribute("type") !== (v.type == null ? null : v.type) || o.getAttribute("crossorigin") !== (v.crossOrigin == null ? null : v.crossOrigin)) && w && o.hasAttribute("async") && !o.hasAttribute("itemprop"))
                break;
              return o;
            default:
              return o;
          }
      } else if (l === "input" && o.type === "hidden") {
        var w = v.name == null ? null : "" + v.name;
        if (v.type === "hidden" && o.getAttribute("name") === w)
          return o;
      } else return o;
      if (o = Cr(o.nextSibling), o === null) break;
    }
    return null;
  }
  function iP(o, l, c) {
    if (l === "") return null;
    for (; o.nodeType !== 3; )
      if ((o.nodeType !== 1 || o.nodeName !== "INPUT" || o.type !== "hidden") && !c || (o = Cr(o.nextSibling), o === null)) return null;
    return o;
  }
  function u0(o) {
    return o.data === "$!" || o.data === "$?" && o.ownerDocument.readyState === "complete";
  }
  function oP(o, l) {
    var c = o.ownerDocument;
    if (o.data !== "$?" || c.readyState === "complete")
      l();
    else {
      var m = function() {
        l(), c.removeEventListener("DOMContentLoaded", m);
      };
      c.addEventListener("DOMContentLoaded", m), o._reactRetry = m;
    }
  }
  function Cr(o) {
    for (; o != null; o = o.nextSibling) {
      var l = o.nodeType;
      if (l === 1 || l === 3) break;
      if (l === 8) {
        if (l = o.data, l === "$" || l === "$!" || l === "$?" || l === "F!" || l === "F")
          break;
        if (l === "/$") return null;
      }
    }
    return o;
  }
  var c0 = null;
  function m_(o) {
    o = o.previousSibling;
    for (var l = 0; o; ) {
      if (o.nodeType === 8) {
        var c = o.data;
        if (c === "$" || c === "$!" || c === "$?") {
          if (l === 0) return o;
          l--;
        } else c === "/$" && l++;
      }
      o = o.previousSibling;
    }
    return null;
  }
  function g_(o, l, c) {
    switch (l = sd(c), o) {
      case "html":
        if (o = l.documentElement, !o) throw Error(r(452));
        return o;
      case "head":
        if (o = l.head, !o) throw Error(r(453));
        return o;
      case "body":
        if (o = l.body, !o) throw Error(r(454));
        return o;
      default:
        throw Error(r(451));
    }
  }
  function xu(o) {
    for (var l = o.attributes; l.length; )
      o.removeAttributeNode(l[0]);
    Ml(o);
  }
  var dr = /* @__PURE__ */ new Map(), y_ = /* @__PURE__ */ new Set();
  function ld(o) {
    return typeof o.getRootNode == "function" ? o.getRootNode() : o.nodeType === 9 ? o : o.ownerDocument;
  }
  var Oi = B.d;
  B.d = {
    f: aP,
    r: sP,
    D: lP,
    C: uP,
    L: cP,
    m: fP,
    X: hP,
    S: dP,
    M: pP
  };
  function aP() {
    var o = Oi.f(), l = Jf();
    return o || l;
  }
  function sP(o) {
    var l = mi(o);
    l !== null && l.tag === 5 && l.type === "form" ? Iw(l) : Oi.r(o);
  }
  var _s = typeof document > "u" ? null : document;
  function v_(o, l, c) {
    var m = _s;
    if (m && typeof l == "string" && l) {
      var v = An(l);
      v = 'link[rel="' + o + '"][href="' + v + '"]', typeof c == "string" && (v += '[crossorigin="' + c + '"]'), y_.has(v) || (y_.add(v), o = { rel: o, crossOrigin: c, href: l }, m.querySelector(v) === null && (l = m.createElement("link"), nn(l, "link", o), It(l), m.head.appendChild(l)));
    }
  }
  function lP(o) {
    Oi.D(o), v_("dns-prefetch", o, null);
  }
  function uP(o, l) {
    Oi.C(o, l), v_("preconnect", o, l);
  }
  function cP(o, l, c) {
    Oi.L(o, l, c);
    var m = _s;
    if (m && o && l) {
      var v = 'link[rel="preload"][as="' + An(l) + '"]';
      l === "image" && c && c.imageSrcSet ? (v += '[imagesrcset="' + An(
        c.imageSrcSet
      ) + '"]', typeof c.imageSizes == "string" && (v += '[imagesizes="' + An(
        c.imageSizes
      ) + '"]')) : v += '[href="' + An(o) + '"]';
      var w = v;
      switch (l) {
        case "style":
          w = Es(o);
          break;
        case "script":
          w = Cs(o);
      }
      dr.has(w) || (o = h(
        {
          rel: "preload",
          href: l === "image" && c && c.imageSrcSet ? void 0 : o,
          as: l
        },
        c
      ), dr.set(w, o), m.querySelector(v) !== null || l === "style" && m.querySelector(wu(w)) || l === "script" && m.querySelector(Su(w)) || (l = m.createElement("link"), nn(l, "link", o), It(l), m.head.appendChild(l)));
    }
  }
  function fP(o, l) {
    Oi.m(o, l);
    var c = _s;
    if (c && o) {
      var m = l && typeof l.as == "string" ? l.as : "script", v = 'link[rel="modulepreload"][as="' + An(m) + '"][href="' + An(o) + '"]', w = v;
      switch (m) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          w = Cs(o);
      }
      if (!dr.has(w) && (o = h({ rel: "modulepreload", href: o }, l), dr.set(w, o), c.querySelector(v) === null)) {
        switch (m) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (c.querySelector(Su(w)))
              return;
        }
        m = c.createElement("link"), nn(m, "link", o), It(m), c.head.appendChild(m);
      }
    }
  }
  function dP(o, l, c) {
    Oi.S(o, l, c);
    var m = _s;
    if (m && o) {
      var v = to(m).hoistableStyles, w = Es(o);
      l = l || "default";
      var M = v.get(w);
      if (!M) {
        var L = { loading: 0, preload: null };
        if (M = m.querySelector(
          wu(w)
        ))
          L.loading = 5;
        else {
          o = h(
            { rel: "stylesheet", href: o, "data-precedence": l },
            c
          ), (c = dr.get(w)) && f0(o, c);
          var X = M = m.createElement("link");
          It(X), nn(X, "link", o), X._p = new Promise(function(ee, ue) {
            X.onload = ee, X.onerror = ue;
          }), X.addEventListener("load", function() {
            L.loading |= 1;
          }), X.addEventListener("error", function() {
            L.loading |= 2;
          }), L.loading |= 4, ud(M, l, m);
        }
        M = {
          type: "stylesheet",
          instance: M,
          count: 1,
          state: L
        }, v.set(w, M);
      }
    }
  }
  function hP(o, l) {
    Oi.X(o, l);
    var c = _s;
    if (c && o) {
      var m = to(c).hoistableScripts, v = Cs(o), w = m.get(v);
      w || (w = c.querySelector(Su(v)), w || (o = h({ src: o, async: !0 }, l), (l = dr.get(v)) && d0(o, l), w = c.createElement("script"), It(w), nn(w, "link", o), c.head.appendChild(w)), w = {
        type: "script",
        instance: w,
        count: 1,
        state: null
      }, m.set(v, w));
    }
  }
  function pP(o, l) {
    Oi.M(o, l);
    var c = _s;
    if (c && o) {
      var m = to(c).hoistableScripts, v = Cs(o), w = m.get(v);
      w || (w = c.querySelector(Su(v)), w || (o = h({ src: o, async: !0, type: "module" }, l), (l = dr.get(v)) && d0(o, l), w = c.createElement("script"), It(w), nn(w, "link", o), c.head.appendChild(w)), w = {
        type: "script",
        instance: w,
        count: 1,
        state: null
      }, m.set(v, w));
    }
  }
  function b_(o, l, c, m) {
    var v = (v = re.current) ? ld(v) : null;
    if (!v) throw Error(r(446));
    switch (o) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof c.precedence == "string" && typeof c.href == "string" ? (l = Es(c.href), c = to(
          v
        ).hoistableStyles, m = c.get(l), m || (m = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, c.set(l, m)), m) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (c.rel === "stylesheet" && typeof c.href == "string" && typeof c.precedence == "string") {
          o = Es(c.href);
          var w = to(
            v
          ).hoistableStyles, M = w.get(o);
          if (M || (v = v.ownerDocument || v, M = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, w.set(o, M), (w = v.querySelector(
            wu(o)
          )) && !w._p && (M.instance = w, M.state.loading = 5), dr.has(o) || (c = {
            rel: "preload",
            as: "style",
            href: c.href,
            crossOrigin: c.crossOrigin,
            integrity: c.integrity,
            media: c.media,
            hrefLang: c.hrefLang,
            referrerPolicy: c.referrerPolicy
          }, dr.set(o, c), w || mP(
            v,
            o,
            c,
            M.state
          ))), l && m === null)
            throw Error(r(528, ""));
          return M;
        }
        if (l && m !== null)
          throw Error(r(529, ""));
        return null;
      case "script":
        return l = c.async, c = c.src, typeof c == "string" && l && typeof l != "function" && typeof l != "symbol" ? (l = Cs(c), c = to(
          v
        ).hoistableScripts, m = c.get(l), m || (m = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, c.set(l, m)), m) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(r(444, o));
    }
  }
  function Es(o) {
    return 'href="' + An(o) + '"';
  }
  function wu(o) {
    return 'link[rel="stylesheet"][' + o + "]";
  }
  function x_(o) {
    return h({}, o, {
      "data-precedence": o.precedence,
      precedence: null
    });
  }
  function mP(o, l, c, m) {
    o.querySelector('link[rel="preload"][as="style"][' + l + "]") ? m.loading = 1 : (l = o.createElement("link"), m.preload = l, l.addEventListener("load", function() {
      return m.loading |= 1;
    }), l.addEventListener("error", function() {
      return m.loading |= 2;
    }), nn(l, "link", c), It(l), o.head.appendChild(l));
  }
  function Cs(o) {
    return '[src="' + An(o) + '"]';
  }
  function Su(o) {
    return "script[async]" + o;
  }
  function w_(o, l, c) {
    if (l.count++, l.instance === null)
      switch (l.type) {
        case "style":
          var m = o.querySelector(
            'style[data-href~="' + An(c.href) + '"]'
          );
          if (m)
            return l.instance = m, It(m), m;
          var v = h({}, c, {
            "data-href": c.href,
            "data-precedence": c.precedence,
            href: null,
            precedence: null
          });
          return m = (o.ownerDocument || o).createElement(
            "style"
          ), It(m), nn(m, "style", v), ud(m, c.precedence, o), l.instance = m;
        case "stylesheet":
          v = Es(c.href);
          var w = o.querySelector(
            wu(v)
          );
          if (w)
            return l.state.loading |= 4, l.instance = w, It(w), w;
          m = x_(c), (v = dr.get(v)) && f0(m, v), w = (o.ownerDocument || o).createElement("link"), It(w);
          var M = w;
          return M._p = new Promise(function(L, X) {
            M.onload = L, M.onerror = X;
          }), nn(w, "link", m), l.state.loading |= 4, ud(w, c.precedence, o), l.instance = w;
        case "script":
          return w = Cs(c.src), (v = o.querySelector(
            Su(w)
          )) ? (l.instance = v, It(v), v) : (m = c, (v = dr.get(w)) && (m = h({}, c), d0(m, v)), o = o.ownerDocument || o, v = o.createElement("script"), It(v), nn(v, "link", m), o.head.appendChild(v), l.instance = v);
        case "void":
          return null;
        default:
          throw Error(r(443, l.type));
      }
    else
      l.type === "stylesheet" && (l.state.loading & 4) === 0 && (m = l.instance, l.state.loading |= 4, ud(m, c.precedence, o));
    return l.instance;
  }
  function ud(o, l, c) {
    for (var m = c.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), v = m.length ? m[m.length - 1] : null, w = v, M = 0; M < m.length; M++) {
      var L = m[M];
      if (L.dataset.precedence === l) w = L;
      else if (w !== v) break;
    }
    w ? w.parentNode.insertBefore(o, w.nextSibling) : (l = c.nodeType === 9 ? c.head : c, l.insertBefore(o, l.firstChild));
  }
  function f0(o, l) {
    o.crossOrigin == null && (o.crossOrigin = l.crossOrigin), o.referrerPolicy == null && (o.referrerPolicy = l.referrerPolicy), o.title == null && (o.title = l.title);
  }
  function d0(o, l) {
    o.crossOrigin == null && (o.crossOrigin = l.crossOrigin), o.referrerPolicy == null && (o.referrerPolicy = l.referrerPolicy), o.integrity == null && (o.integrity = l.integrity);
  }
  var cd = null;
  function S_(o, l, c) {
    if (cd === null) {
      var m = /* @__PURE__ */ new Map(), v = cd = /* @__PURE__ */ new Map();
      v.set(c, m);
    } else
      v = cd, m = v.get(c), m || (m = /* @__PURE__ */ new Map(), v.set(c, m));
    if (m.has(o)) return m;
    for (m.set(o, null), c = c.getElementsByTagName(o), v = 0; v < c.length; v++) {
      var w = c[v];
      if (!(w[Qo] || w[Xt] || o === "link" && w.getAttribute("rel") === "stylesheet") && w.namespaceURI !== "http://www.w3.org/2000/svg") {
        var M = w.getAttribute(l) || "";
        M = o + M;
        var L = m.get(M);
        L ? L.push(w) : m.set(M, [w]);
      }
    }
    return m;
  }
  function __(o, l, c) {
    o = o.ownerDocument || o, o.head.insertBefore(
      c,
      l === "title" ? o.querySelector("head > title") : null
    );
  }
  function gP(o, l, c) {
    if (c === 1 || l.itemProp != null) return !1;
    switch (o) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof l.precedence != "string" || typeof l.href != "string" || l.href === "")
          break;
        return !0;
      case "link":
        if (typeof l.rel != "string" || typeof l.href != "string" || l.href === "" || l.onLoad || l.onError)
          break;
        switch (l.rel) {
          case "stylesheet":
            return o = l.disabled, typeof l.precedence == "string" && o == null;
          default:
            return !0;
        }
      case "script":
        if (l.async && typeof l.async != "function" && typeof l.async != "symbol" && !l.onLoad && !l.onError && l.src && typeof l.src == "string")
          return !0;
    }
    return !1;
  }
  function E_(o) {
    return !(o.type === "stylesheet" && (o.state.loading & 3) === 0);
  }
  var _u = null;
  function yP() {
  }
  function vP(o, l, c) {
    if (_u === null) throw Error(r(475));
    var m = _u;
    if (l.type === "stylesheet" && (typeof c.media != "string" || matchMedia(c.media).matches !== !1) && (l.state.loading & 4) === 0) {
      if (l.instance === null) {
        var v = Es(c.href), w = o.querySelector(
          wu(v)
        );
        if (w) {
          o = w._p, o !== null && typeof o == "object" && typeof o.then == "function" && (m.count++, m = fd.bind(m), o.then(m, m)), l.state.loading |= 4, l.instance = w, It(w);
          return;
        }
        w = o.ownerDocument || o, c = x_(c), (v = dr.get(v)) && f0(c, v), w = w.createElement("link"), It(w);
        var M = w;
        M._p = new Promise(function(L, X) {
          M.onload = L, M.onerror = X;
        }), nn(w, "link", c), l.instance = w;
      }
      m.stylesheets === null && (m.stylesheets = /* @__PURE__ */ new Map()), m.stylesheets.set(l, o), (o = l.state.preload) && (l.state.loading & 3) === 0 && (m.count++, l = fd.bind(m), o.addEventListener("load", l), o.addEventListener("error", l));
    }
  }
  function bP() {
    if (_u === null) throw Error(r(475));
    var o = _u;
    return o.stylesheets && o.count === 0 && h0(o, o.stylesheets), 0 < o.count ? function(l) {
      var c = setTimeout(function() {
        if (o.stylesheets && h0(o, o.stylesheets), o.unsuspend) {
          var m = o.unsuspend;
          o.unsuspend = null, m();
        }
      }, 6e4);
      return o.unsuspend = l, function() {
        o.unsuspend = null, clearTimeout(c);
      };
    } : null;
  }
  function fd() {
    if (this.count--, this.count === 0) {
      if (this.stylesheets) h0(this, this.stylesheets);
      else if (this.unsuspend) {
        var o = this.unsuspend;
        this.unsuspend = null, o();
      }
    }
  }
  var dd = null;
  function h0(o, l) {
    o.stylesheets = null, o.unsuspend !== null && (o.count++, dd = /* @__PURE__ */ new Map(), l.forEach(xP, o), dd = null, fd.call(o));
  }
  function xP(o, l) {
    if (!(l.state.loading & 4)) {
      var c = dd.get(o);
      if (c) var m = c.get(null);
      else {
        c = /* @__PURE__ */ new Map(), dd.set(o, c);
        for (var v = o.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), w = 0; w < v.length; w++) {
          var M = v[w];
          (M.nodeName === "LINK" || M.getAttribute("media") !== "not all") && (c.set(M.dataset.precedence, M), m = M);
        }
        m && c.set(null, m);
      }
      v = l.instance, M = v.getAttribute("data-precedence"), w = c.get(M) || m, w === m && c.set(null, v), c.set(M, v), this.count++, m = fd.bind(this), v.addEventListener("load", m), v.addEventListener("error", m), w ? w.parentNode.insertBefore(v, w.nextSibling) : (o = o.nodeType === 9 ? o.head : o, o.insertBefore(v, o.firstChild)), l.state.loading |= 4;
    }
  }
  var Eu = {
    $$typeof: k,
    Provider: null,
    Consumer: null,
    _currentValue: q,
    _currentValue2: q,
    _threadCount: 0
  };
  function wP(o, l, c, m, v, w, M, L) {
    this.tag = 1, this.containerInfo = o, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Al(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Al(0), this.hiddenUpdates = Al(null), this.identifierPrefix = m, this.onUncaughtError = v, this.onCaughtError = w, this.onRecoverableError = M, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = L, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function C_(o, l, c, m, v, w, M, L, X, ee, ue, de) {
    return o = new wP(
      o,
      l,
      c,
      M,
      L,
      X,
      ee,
      de
    ), l = 1, w === !0 && (l |= 24), w = $n(3, null, null, l), o.current = w, w.stateNode = o, l = Xm(), l.refCount++, o.pooledCache = l, l.refCount++, w.memoizedState = {
      element: m,
      isDehydrated: c,
      cache: l
    }, Qm(w), o;
  }
  function k_(o) {
    return o ? (o = ns, o) : ns;
  }
  function A_(o, l, c, m, v, w) {
    v = k_(v), m.context === null ? m.context = v : m.pendingContext = v, m = lo(l), m.payload = { element: c }, w = w === void 0 ? null : w, w !== null && (m.callback = w), c = uo(o, m, l), c !== null && (Yn(c, o, l), eu(c, o, l));
  }
  function T_(o, l) {
    if (o = o.memoizedState, o !== null && o.dehydrated !== null) {
      var c = o.retryLane;
      o.retryLane = c !== 0 && c < l ? c : l;
    }
  }
  function p0(o, l) {
    T_(o, l), (o = o.alternate) && T_(o, l);
  }
  function R_(o) {
    if (o.tag === 13) {
      var l = ts(o, 67108864);
      l !== null && Yn(l, o, 67108864), p0(o, 67108864);
    }
  }
  var hd = !0;
  function SP(o, l, c, m) {
    var v = z.T;
    z.T = null;
    var w = B.p;
    try {
      B.p = 2, m0(o, l, c, m);
    } finally {
      B.p = w, z.T = v;
    }
  }
  function _P(o, l, c, m) {
    var v = z.T;
    z.T = null;
    var w = B.p;
    try {
      B.p = 8, m0(o, l, c, m);
    } finally {
      B.p = w, z.T = v;
    }
  }
  function m0(o, l, c, m) {
    if (hd) {
      var v = g0(m);
      if (v === null)
        n0(
          o,
          l,
          m,
          pd,
          c
        ), N_(o, m);
      else if (CP(
        v,
        o,
        l,
        c,
        m
      ))
        m.stopPropagation();
      else if (N_(o, m), l & 4 && -1 < EP.indexOf(o)) {
        for (; v !== null; ) {
          var w = mi(v);
          if (w !== null)
            switch (w.tag) {
              case 3:
                if (w = w.stateNode, w.current.memoizedState.isDehydrated) {
                  var M = yn(w.pendingLanes);
                  if (M !== 0) {
                    var L = w;
                    for (L.pendingLanes |= 2, L.entangledLanes |= 2; M; ) {
                      var X = 1 << 31 - Ae(M);
                      L.entanglements[1] |= X, M &= ~X;
                    }
                    Ur(w), (ot & 6) === 0 && (Zf = bt() + 500, yu(0));
                  }
                }
                break;
              case 13:
                L = ts(w, 2), L !== null && Yn(L, w, 2), Jf(), p0(w, 2);
            }
          if (w = g0(m), w === null && n0(
            o,
            l,
            m,
            pd,
            c
          ), w === v) break;
          v = w;
        }
        v !== null && m.stopPropagation();
      } else
        n0(
          o,
          l,
          m,
          null,
          c
        );
    }
  }
  function g0(o) {
    return o = wm(o), y0(o);
  }
  var pd = null;
  function y0(o) {
    if (pd = null, o = pi(o), o !== null) {
      var l = a(o);
      if (l === null) o = null;
      else {
        var c = l.tag;
        if (c === 13) {
          if (o = s(l), o !== null) return o;
          o = null;
        } else if (c === 3) {
          if (l.stateNode.current.memoizedState.isDehydrated)
            return l.tag === 3 ? l.stateNode.containerInfo : null;
          o = null;
        } else l !== o && (o = null);
      }
    }
    return pd = o, null;
  }
  function O_(o) {
    switch (o) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (Ln()) {
          case xr:
            return 2;
          case En:
            return 8;
          case ir:
          case Pe:
            return 32;
          case Lr:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var v0 = !1, _o = null, Eo = null, Co = null, Cu = /* @__PURE__ */ new Map(), ku = /* @__PURE__ */ new Map(), ko = [], EP = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function N_(o, l) {
    switch (o) {
      case "focusin":
      case "focusout":
        _o = null;
        break;
      case "dragenter":
      case "dragleave":
        Eo = null;
        break;
      case "mouseover":
      case "mouseout":
        Co = null;
        break;
      case "pointerover":
      case "pointerout":
        Cu.delete(l.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        ku.delete(l.pointerId);
    }
  }
  function Au(o, l, c, m, v, w) {
    return o === null || o.nativeEvent !== w ? (o = {
      blockedOn: l,
      domEventName: c,
      eventSystemFlags: m,
      nativeEvent: w,
      targetContainers: [v]
    }, l !== null && (l = mi(l), l !== null && R_(l)), o) : (o.eventSystemFlags |= m, l = o.targetContainers, v !== null && l.indexOf(v) === -1 && l.push(v), o);
  }
  function CP(o, l, c, m, v) {
    switch (l) {
      case "focusin":
        return _o = Au(
          _o,
          o,
          l,
          c,
          m,
          v
        ), !0;
      case "dragenter":
        return Eo = Au(
          Eo,
          o,
          l,
          c,
          m,
          v
        ), !0;
      case "mouseover":
        return Co = Au(
          Co,
          o,
          l,
          c,
          m,
          v
        ), !0;
      case "pointerover":
        var w = v.pointerId;
        return Cu.set(
          w,
          Au(
            Cu.get(w) || null,
            o,
            l,
            c,
            m,
            v
          )
        ), !0;
      case "gotpointercapture":
        return w = v.pointerId, ku.set(
          w,
          Au(
            ku.get(w) || null,
            o,
            l,
            c,
            m,
            v
          )
        ), !0;
    }
    return !1;
  }
  function M_(o) {
    var l = pi(o.target);
    if (l !== null) {
      var c = a(l);
      if (c !== null) {
        if (l = c.tag, l === 13) {
          if (l = s(c), l !== null) {
            o.blockedOn = l, dm(o.priority, function() {
              if (c.tag === 13) {
                var m = qn();
                m = Rl(m);
                var v = ts(c, m);
                v !== null && Yn(v, c, m), p0(c, m);
              }
            });
            return;
          }
        } else if (l === 3 && c.stateNode.current.memoizedState.isDehydrated) {
          o.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
          return;
        }
      }
    }
    o.blockedOn = null;
  }
  function md(o) {
    if (o.blockedOn !== null) return !1;
    for (var l = o.targetContainers; 0 < l.length; ) {
      var c = g0(o.nativeEvent);
      if (c === null) {
        c = o.nativeEvent;
        var m = new c.constructor(
          c.type,
          c
        );
        xm = m, c.target.dispatchEvent(m), xm = null;
      } else
        return l = mi(c), l !== null && R_(l), o.blockedOn = c, !1;
      l.shift();
    }
    return !0;
  }
  function D_(o, l, c) {
    md(o) && c.delete(l);
  }
  function kP() {
    v0 = !1, _o !== null && md(_o) && (_o = null), Eo !== null && md(Eo) && (Eo = null), Co !== null && md(Co) && (Co = null), Cu.forEach(D_), ku.forEach(D_);
  }
  function gd(o, l) {
    o.blockedOn === l && (o.blockedOn = null, v0 || (v0 = !0, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      kP
    )));
  }
  var yd = null;
  function P_(o) {
    yd !== o && (yd = o, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      function() {
        yd === o && (yd = null);
        for (var l = 0; l < o.length; l += 3) {
          var c = o[l], m = o[l + 1], v = o[l + 2];
          if (typeof m != "function") {
            if (y0(m || c) === null)
              continue;
            break;
          }
          var w = mi(c);
          w !== null && (o.splice(l, 3), l -= 3, yg(
            w,
            {
              pending: !0,
              data: v,
              method: c.method,
              action: m
            },
            m,
            v
          ));
        }
      }
    ));
  }
  function Tu(o) {
    function l(X) {
      return gd(X, o);
    }
    _o !== null && gd(_o, o), Eo !== null && gd(Eo, o), Co !== null && gd(Co, o), Cu.forEach(l), ku.forEach(l);
    for (var c = 0; c < ko.length; c++) {
      var m = ko[c];
      m.blockedOn === o && (m.blockedOn = null);
    }
    for (; 0 < ko.length && (c = ko[0], c.blockedOn === null); )
      M_(c), c.blockedOn === null && ko.shift();
    if (c = (o.ownerDocument || o).$$reactFormReplay, c != null)
      for (m = 0; m < c.length; m += 3) {
        var v = c[m], w = c[m + 1], M = v[sn] || null;
        if (typeof w == "function")
          M || P_(c);
        else if (M) {
          var L = null;
          if (w && w.hasAttribute("formAction")) {
            if (v = w, M = w[sn] || null)
              L = M.formAction;
            else if (y0(v) !== null) continue;
          } else L = M.action;
          typeof L == "function" ? c[m + 1] = L : (c.splice(m, 3), m -= 3), P_(c);
        }
      }
  }
  function b0(o) {
    this._internalRoot = o;
  }
  vd.prototype.render = b0.prototype.render = function(o) {
    var l = this._internalRoot;
    if (l === null) throw Error(r(409));
    var c = l.current, m = qn();
    A_(c, m, o, l, null, null);
  }, vd.prototype.unmount = b0.prototype.unmount = function() {
    var o = this._internalRoot;
    if (o !== null) {
      this._internalRoot = null;
      var l = o.containerInfo;
      A_(o.current, 2, null, o, null, null), Jf(), l[eo] = null;
    }
  };
  function vd(o) {
    this._internalRoot = o;
  }
  vd.prototype.unstable_scheduleHydration = function(o) {
    if (o) {
      var l = nf();
      o = { blockedOn: null, target: o, priority: l };
      for (var c = 0; c < ko.length && l !== 0 && l < ko[c].priority; c++) ;
      ko.splice(c, 0, o), c === 0 && M_(o);
    }
  };
  var z_ = t.version;
  if (z_ !== "19.1.0")
    throw Error(
      r(
        527,
        z_,
        "19.1.0"
      )
    );
  B.findDOMNode = function(o) {
    var l = o._reactInternals;
    if (l === void 0)
      throw typeof o.render == "function" ? Error(r(188)) : (o = Object.keys(o).join(","), Error(r(268, o)));
    return o = f(l), o = o !== null ? d(o) : null, o = o === null ? null : o.stateNode, o;
  };
  var AP = {
    bundleType: 0,
    version: "19.1.0",
    rendererPackageName: "react-dom",
    currentDispatcherRef: z,
    reconcilerVersion: "19.1.0"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var bd = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!bd.isDisabled && bd.supportsFiber)
      try {
        ae = bd.inject(
          AP
        ), pe = bd;
      } catch {
      }
  }
  return $u.createRoot = function(o, l) {
    if (!i(o)) throw Error(r(299));
    var c = !1, m = "", v = Zw, w = Qw, M = Jw, L = null;
    return l != null && (l.unstable_strictMode === !0 && (c = !0), l.identifierPrefix !== void 0 && (m = l.identifierPrefix), l.onUncaughtError !== void 0 && (v = l.onUncaughtError), l.onCaughtError !== void 0 && (w = l.onCaughtError), l.onRecoverableError !== void 0 && (M = l.onRecoverableError), l.unstable_transitionCallbacks !== void 0 && (L = l.unstable_transitionCallbacks)), l = C_(
      o,
      1,
      !1,
      null,
      null,
      c,
      m,
      v,
      w,
      M,
      L,
      null
    ), o[eo] = l.current, t0(o), new b0(l);
  }, $u.hydrateRoot = function(o, l, c) {
    if (!i(o)) throw Error(r(299));
    var m = !1, v = "", w = Zw, M = Qw, L = Jw, X = null, ee = null;
    return c != null && (c.unstable_strictMode === !0 && (m = !0), c.identifierPrefix !== void 0 && (v = c.identifierPrefix), c.onUncaughtError !== void 0 && (w = c.onUncaughtError), c.onCaughtError !== void 0 && (M = c.onCaughtError), c.onRecoverableError !== void 0 && (L = c.onRecoverableError), c.unstable_transitionCallbacks !== void 0 && (X = c.unstable_transitionCallbacks), c.formState !== void 0 && (ee = c.formState)), l = C_(
      o,
      1,
      !0,
      l,
      c ?? null,
      m,
      v,
      w,
      M,
      L,
      X,
      ee
    ), l.context = k_(null), c = l.current, m = qn(), m = Rl(m), v = lo(m), v.callback = null, uo(c, v, m), c = m, l.current.lanes = c, Zo(l, c), Ur(l), o[eo] = l.current, t0(o), new vd(l);
  }, $u.version = "19.1.0", $u;
}
var ET;
function aue() {
  if (ET) return Iy.exports;
  ET = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), Iy.exports = oue(), Iy.exports;
}
var sue = aue();
const lue = (e, t) => {
  t === void 0 && (t = {});
  const { element: n, eleid: r } = typeof e == "string" ? {
    element: document.getElementById(e),
    eleid: e
  } : { element: e, eleid: e.id };
  sue.createRoot(n).render(
    /* @__PURE__ */ _.jsx(C.StrictMode, { children: /* @__PURE__ */ _.jsx(nue, { ...t, id: t.id || r }) })
  );
};
window.FuncNodes = lue;
window.FuncNodes.version = "0.4.7";
