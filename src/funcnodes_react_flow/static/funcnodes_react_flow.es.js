var l6 = Object.defineProperty;
var u6 = (e, t, n) => t in e ? l6(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var Qu = (e, t, n) => u6(e, typeof t != "symbol" ? t + "" : t, n);
function c6(e, t) {
  for (var n = 0; n < t.length; n++) {
    const r = t[n];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const o in r)
        if (o !== "default" && !(o in e)) {
          const a = Object.getOwnPropertyDescriptor(r, o);
          a && Object.defineProperty(e, o, a.get ? a : {
            enumerable: !0,
            get: () => r[o]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
const f6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ArrayBufferDataStructure() {
    return i3;
  },
  get CTypeStructure() {
    return a3;
  },
  get DataPreviewViewRendererToHandlePreviewRenderer() {
    return _4;
  },
  get DataStructure() {
    return co;
  },
  get DataViewRendererToDataPreviewViewRenderer() {
    return zn;
  },
  get DataViewRendererToInputRenderer() {
    return S4;
  },
  get DataViewRendererToOverlayRenderer() {
    return Vm;
  },
  get FuncNodesRenderer() {
    return oP;
  },
  get JSONStructure() {
    return Qi;
  },
  get LATEST_VERSION() {
    return rP;
  },
  get TextStructure() {
    return s3;
  },
  get useFuncNodesContext() {
    return tt;
  },
  get useIOGetFullValue() {
    return Ym;
  },
  get useIOStore() {
    return Rt;
  },
  get useIOValueStore() {
    return yie;
  },
  get useNodeStore() {
    return cr;
  },
  get useSetIOValue() {
    return Ul;
  },
  get useSetIOValueOptions() {
    return gie;
  },
  get useWorkerApi() {
    return xn;
  }
}, Symbol.toStringTag, { value: "Module" }));
(function() {
  const t = document.createElement("link").relList;
  if (t && t.supports && t.supports("modulepreload")) return;
  for (const o of document.querySelectorAll('link[rel="modulepreload"]')) r(o);
  new MutationObserver((o) => {
    for (const a of o)
      if (a.type === "childList")
        for (const s of a.addedNodes) s.tagName === "LINK" && s.rel === "modulepreload" && r(s);
  }).observe(document, {
    childList: !0,
    subtree: !0
  });
  function n(o) {
    const a = {};
    return o.integrity && (a.integrity = o.integrity), o.referrerPolicy && (a.referrerPolicy = o.referrerPolicy), o.crossOrigin === "use-credentials" ? a.credentials = "include" : o.crossOrigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin", a;
  }
  function r(o) {
    if (o.ep) return;
    o.ep = !0;
    const a = n(o);
    fetch(o.href, a);
  }
})();
function jl(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var py = { exports: {} }, Ju = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var nC;
function d6() {
  if (nC) return Ju;
  nC = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.fragment");
  function n(r, o, a) {
    var s = null;
    if (a !== void 0 && (s = "" + a), o.key !== void 0 && (s = "" + o.key), "key" in o) {
      a = {};
      for (var u in o)
        u !== "key" && (a[u] = o[u]);
    } else a = o;
    return o = a.ref, {
      $$typeof: e,
      type: r,
      key: s,
      ref: o !== void 0 ? o : null,
      props: a
    };
  }
  return Ju.Fragment = t, Ju.jsx = n, Ju.jsxs = n, Ju;
}
var rC;
function h6() {
  return rC || (rC = 1, py.exports = d6()), py.exports;
}
var b = h6(), my = { exports: {} }, ec = {}, gy = { exports: {} }, yy = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var oC;
function p6() {
  return oC || (oC = 1, function(e) {
    function t(I, U) {
      var H = I.length;
      I.push(U);
      e: for (; 0 < H; ) {
        var G = H - 1 >>> 1, O = I[G];
        if (0 < o(O, U))
          I[G] = U, I[H] = O, H = G;
        else break e;
      }
    }
    function n(I) {
      return I.length === 0 ? null : I[0];
    }
    function r(I) {
      if (I.length === 0) return null;
      var U = I[0], H = I.pop();
      if (H !== U) {
        I[0] = H;
        e: for (var G = 0, O = I.length, W = O >>> 1; G < W; ) {
          var Z = 2 * (G + 1) - 1, L = I[Z], te = Z + 1, he = I[te];
          if (0 > o(L, H))
            te < O && 0 > o(he, L) ? (I[G] = he, I[te] = H, G = te) : (I[G] = L, I[Z] = H, G = Z);
          else if (te < O && 0 > o(he, H))
            I[G] = he, I[te] = H, G = te;
          else break e;
        }
      }
      return U;
    }
    function o(I, U) {
      var H = I.sortIndex - U.sortIndex;
      return H !== 0 ? H : I.id - U.id;
    }
    if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
      var a = performance;
      e.unstable_now = function() {
        return a.now();
      };
    } else {
      var s = Date, u = s.now();
      e.unstable_now = function() {
        return s.now() - u;
      };
    }
    var c = [], f = [], h = 1, p = null, g = 3, y = !1, w = !1, v = !1, S = !1, E = typeof setTimeout == "function" ? setTimeout : null, A = typeof clearTimeout == "function" ? clearTimeout : null, k = typeof setImmediate < "u" ? setImmediate : null;
    function T(I) {
      for (var U = n(f); U !== null; ) {
        if (U.callback === null) r(f);
        else if (U.startTime <= I)
          r(f), U.sortIndex = U.expirationTime, t(c, U);
        else break;
        U = n(f);
      }
    }
    function R(I) {
      if (v = !1, T(I), !w)
        if (n(c) !== null)
          w = !0, N || (N = !0, q());
        else {
          var U = n(f);
          U !== null && V(R, U.startTime - I);
        }
    }
    var N = !1, j = -1, z = 5, B = -1;
    function M() {
      return S ? !0 : !(e.unstable_now() - B < z);
    }
    function F() {
      if (S = !1, N) {
        var I = e.unstable_now();
        B = I;
        var U = !0;
        try {
          e: {
            w = !1, v && (v = !1, A(j), j = -1), y = !0;
            var H = g;
            try {
              t: {
                for (T(I), p = n(c); p !== null && !(p.expirationTime > I && M()); ) {
                  var G = p.callback;
                  if (typeof G == "function") {
                    p.callback = null, g = p.priorityLevel;
                    var O = G(
                      p.expirationTime <= I
                    );
                    if (I = e.unstable_now(), typeof O == "function") {
                      p.callback = O, T(I), U = !0;
                      break t;
                    }
                    p === n(c) && r(c), T(I);
                  } else r(c);
                  p = n(c);
                }
                if (p !== null) U = !0;
                else {
                  var W = n(f);
                  W !== null && V(
                    R,
                    W.startTime - I
                  ), U = !1;
                }
              }
              break e;
            } finally {
              p = null, g = H, y = !1;
            }
            U = void 0;
          }
        } finally {
          U ? q() : N = !1;
        }
      }
    }
    var q;
    if (typeof k == "function")
      q = function() {
        k(F);
      };
    else if (typeof MessageChannel < "u") {
      var Y = new MessageChannel(), P = Y.port2;
      Y.port1.onmessage = F, q = function() {
        P.postMessage(null);
      };
    } else
      q = function() {
        E(F, 0);
      };
    function V(I, U) {
      j = E(function() {
        I(e.unstable_now());
      }, U);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(I) {
      I.callback = null;
    }, e.unstable_forceFrameRate = function(I) {
      0 > I || 125 < I ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : z = 0 < I ? Math.floor(1e3 / I) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return g;
    }, e.unstable_next = function(I) {
      switch (g) {
        case 1:
        case 2:
        case 3:
          var U = 3;
          break;
        default:
          U = g;
      }
      var H = g;
      g = U;
      try {
        return I();
      } finally {
        g = H;
      }
    }, e.unstable_requestPaint = function() {
      S = !0;
    }, e.unstable_runWithPriority = function(I, U) {
      switch (I) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          I = 3;
      }
      var H = g;
      g = I;
      try {
        return U();
      } finally {
        g = H;
      }
    }, e.unstable_scheduleCallback = function(I, U, H) {
      var G = e.unstable_now();
      switch (typeof H == "object" && H !== null ? (H = H.delay, H = typeof H == "number" && 0 < H ? G + H : G) : H = G, I) {
        case 1:
          var O = -1;
          break;
        case 2:
          O = 250;
          break;
        case 5:
          O = 1073741823;
          break;
        case 4:
          O = 1e4;
          break;
        default:
          O = 5e3;
      }
      return O = H + O, I = {
        id: h++,
        callback: U,
        priorityLevel: I,
        startTime: H,
        expirationTime: O,
        sortIndex: -1
      }, H > G ? (I.sortIndex = H, t(f, I), n(c) === null && I === n(f) && (v ? (A(j), j = -1) : v = !0, V(R, H - G))) : (I.sortIndex = O, t(c, I), w || y || (w = !0, N || (N = !0, q()))), I;
    }, e.unstable_shouldYield = M, e.unstable_wrapCallback = function(I) {
      var U = g;
      return function() {
        var H = g;
        g = U;
        try {
          return I.apply(this, arguments);
        } finally {
          g = H;
        }
      };
    };
  }(yy)), yy;
}
var iC;
function m6() {
  return iC || (iC = 1, gy.exports = p6()), gy.exports;
}
var vy = { exports: {} }, $e = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aC;
function g6() {
  if (aC) return $e;
  aC = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.consumer"), s = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), f = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), p = Symbol.iterator;
  function g(O) {
    return O === null || typeof O != "object" ? null : (O = p && O[p] || O["@@iterator"], typeof O == "function" ? O : null);
  }
  var y = {
    isMounted: function() {
      return !1;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, w = Object.assign, v = {};
  function S(O, W, Z) {
    this.props = O, this.context = W, this.refs = v, this.updater = Z || y;
  }
  S.prototype.isReactComponent = {}, S.prototype.setState = function(O, W) {
    if (typeof O != "object" && typeof O != "function" && O != null)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, O, W, "setState");
  }, S.prototype.forceUpdate = function(O) {
    this.updater.enqueueForceUpdate(this, O, "forceUpdate");
  };
  function E() {
  }
  E.prototype = S.prototype;
  function A(O, W, Z) {
    this.props = O, this.context = W, this.refs = v, this.updater = Z || y;
  }
  var k = A.prototype = new E();
  k.constructor = A, w(k, S.prototype), k.isPureReactComponent = !0;
  var T = Array.isArray, R = { H: null, A: null, T: null, S: null, V: null }, N = Object.prototype.hasOwnProperty;
  function j(O, W, Z, L, te, he) {
    return Z = he.ref, {
      $$typeof: e,
      type: O,
      key: W,
      ref: Z !== void 0 ? Z : null,
      props: he
    };
  }
  function z(O, W) {
    return j(
      O.type,
      W,
      void 0,
      void 0,
      void 0,
      O.props
    );
  }
  function B(O) {
    return typeof O == "object" && O !== null && O.$$typeof === e;
  }
  function M(O) {
    var W = { "=": "=0", ":": "=2" };
    return "$" + O.replace(/[=:]/g, function(Z) {
      return W[Z];
    });
  }
  var F = /\/+/g;
  function q(O, W) {
    return typeof O == "object" && O !== null && O.key != null ? M("" + O.key) : W.toString(36);
  }
  function Y() {
  }
  function P(O) {
    switch (O.status) {
      case "fulfilled":
        return O.value;
      case "rejected":
        throw O.reason;
      default:
        switch (typeof O.status == "string" ? O.then(Y, Y) : (O.status = "pending", O.then(
          function(W) {
            O.status === "pending" && (O.status = "fulfilled", O.value = W);
          },
          function(W) {
            O.status === "pending" && (O.status = "rejected", O.reason = W);
          }
        )), O.status) {
          case "fulfilled":
            return O.value;
          case "rejected":
            throw O.reason;
        }
    }
    throw O;
  }
  function V(O, W, Z, L, te) {
    var he = typeof O;
    (he === "undefined" || he === "boolean") && (O = null);
    var oe = !1;
    if (O === null) oe = !0;
    else
      switch (he) {
        case "bigint":
        case "string":
        case "number":
          oe = !0;
          break;
        case "object":
          switch (O.$$typeof) {
            case e:
            case t:
              oe = !0;
              break;
            case h:
              return oe = O._init, V(
                oe(O._payload),
                W,
                Z,
                L,
                te
              );
          }
      }
    if (oe)
      return te = te(O), oe = L === "" ? "." + q(O, 0) : L, T(te) ? (Z = "", oe != null && (Z = oe.replace(F, "$&/") + "/"), V(te, W, Z, "", function(ye) {
        return ye;
      })) : te != null && (B(te) && (te = z(
        te,
        Z + (te.key == null || O && O.key === te.key ? "" : ("" + te.key).replace(
          F,
          "$&/"
        ) + "/") + oe
      )), W.push(te)), 1;
    oe = 0;
    var fe = L === "" ? "." : L + ":";
    if (T(O))
      for (var ae = 0; ae < O.length; ae++)
        L = O[ae], he = fe + q(L, ae), oe += V(
          L,
          W,
          Z,
          he,
          te
        );
    else if (ae = g(O), typeof ae == "function")
      for (O = ae.call(O), ae = 0; !(L = O.next()).done; )
        L = L.value, he = fe + q(L, ae++), oe += V(
          L,
          W,
          Z,
          he,
          te
        );
    else if (he === "object") {
      if (typeof O.then == "function")
        return V(
          P(O),
          W,
          Z,
          L,
          te
        );
      throw W = String(O), Error(
        "Objects are not valid as a React child (found: " + (W === "[object Object]" ? "object with keys {" + Object.keys(O).join(", ") + "}" : W) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return oe;
  }
  function I(O, W, Z) {
    if (O == null) return O;
    var L = [], te = 0;
    return V(O, L, "", "", function(he) {
      return W.call(Z, he, te++);
    }), L;
  }
  function U(O) {
    if (O._status === -1) {
      var W = O._result;
      W = W(), W.then(
        function(Z) {
          (O._status === 0 || O._status === -1) && (O._status = 1, O._result = Z);
        },
        function(Z) {
          (O._status === 0 || O._status === -1) && (O._status = 2, O._result = Z);
        }
      ), O._status === -1 && (O._status = 0, O._result = W);
    }
    if (O._status === 1) return O._result.default;
    throw O._result;
  }
  var H = typeof reportError == "function" ? reportError : function(O) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var W = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof O == "object" && O !== null && typeof O.message == "string" ? String(O.message) : String(O),
        error: O
      });
      if (!window.dispatchEvent(W)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", O);
      return;
    }
    console.error(O);
  };
  function G() {
  }
  return $e.Children = {
    map: I,
    forEach: function(O, W, Z) {
      I(
        O,
        function() {
          W.apply(this, arguments);
        },
        Z
      );
    },
    count: function(O) {
      var W = 0;
      return I(O, function() {
        W++;
      }), W;
    },
    toArray: function(O) {
      return I(O, function(W) {
        return W;
      }) || [];
    },
    only: function(O) {
      if (!B(O))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return O;
    }
  }, $e.Component = S, $e.Fragment = n, $e.Profiler = o, $e.PureComponent = A, $e.StrictMode = r, $e.Suspense = c, $e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = R, $e.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(O) {
      return R.H.useMemoCache(O);
    }
  }, $e.cache = function(O) {
    return function() {
      return O.apply(null, arguments);
    };
  }, $e.cloneElement = function(O, W, Z) {
    if (O == null)
      throw Error(
        "The argument must be a React element, but you passed " + O + "."
      );
    var L = w({}, O.props), te = O.key, he = void 0;
    if (W != null)
      for (oe in W.ref !== void 0 && (he = void 0), W.key !== void 0 && (te = "" + W.key), W)
        !N.call(W, oe) || oe === "key" || oe === "__self" || oe === "__source" || oe === "ref" && W.ref === void 0 || (L[oe] = W[oe]);
    var oe = arguments.length - 2;
    if (oe === 1) L.children = Z;
    else if (1 < oe) {
      for (var fe = Array(oe), ae = 0; ae < oe; ae++)
        fe[ae] = arguments[ae + 2];
      L.children = fe;
    }
    return j(O.type, te, void 0, void 0, he, L);
  }, $e.createContext = function(O) {
    return O = {
      $$typeof: s,
      _currentValue: O,
      _currentValue2: O,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    }, O.Provider = O, O.Consumer = {
      $$typeof: a,
      _context: O
    }, O;
  }, $e.createElement = function(O, W, Z) {
    var L, te = {}, he = null;
    if (W != null)
      for (L in W.key !== void 0 && (he = "" + W.key), W)
        N.call(W, L) && L !== "key" && L !== "__self" && L !== "__source" && (te[L] = W[L]);
    var oe = arguments.length - 2;
    if (oe === 1) te.children = Z;
    else if (1 < oe) {
      for (var fe = Array(oe), ae = 0; ae < oe; ae++)
        fe[ae] = arguments[ae + 2];
      te.children = fe;
    }
    if (O && O.defaultProps)
      for (L in oe = O.defaultProps, oe)
        te[L] === void 0 && (te[L] = oe[L]);
    return j(O, he, void 0, void 0, null, te);
  }, $e.createRef = function() {
    return { current: null };
  }, $e.forwardRef = function(O) {
    return { $$typeof: u, render: O };
  }, $e.isValidElement = B, $e.lazy = function(O) {
    return {
      $$typeof: h,
      _payload: { _status: -1, _result: O },
      _init: U
    };
  }, $e.memo = function(O, W) {
    return {
      $$typeof: f,
      type: O,
      compare: W === void 0 ? null : W
    };
  }, $e.startTransition = function(O) {
    var W = R.T, Z = {};
    R.T = Z;
    try {
      var L = O(), te = R.S;
      te !== null && te(Z, L), typeof L == "object" && L !== null && typeof L.then == "function" && L.then(G, H);
    } catch (he) {
      H(he);
    } finally {
      R.T = W;
    }
  }, $e.unstable_useCacheRefresh = function() {
    return R.H.useCacheRefresh();
  }, $e.use = function(O) {
    return R.H.use(O);
  }, $e.useActionState = function(O, W, Z) {
    return R.H.useActionState(O, W, Z);
  }, $e.useCallback = function(O, W) {
    return R.H.useCallback(O, W);
  }, $e.useContext = function(O) {
    return R.H.useContext(O);
  }, $e.useDebugValue = function() {
  }, $e.useDeferredValue = function(O, W) {
    return R.H.useDeferredValue(O, W);
  }, $e.useEffect = function(O, W, Z) {
    var L = R.H;
    if (typeof Z == "function")
      throw Error(
        "useEffect CRUD overload is not enabled in this build of React."
      );
    return L.useEffect(O, W);
  }, $e.useId = function() {
    return R.H.useId();
  }, $e.useImperativeHandle = function(O, W, Z) {
    return R.H.useImperativeHandle(O, W, Z);
  }, $e.useInsertionEffect = function(O, W) {
    return R.H.useInsertionEffect(O, W);
  }, $e.useLayoutEffect = function(O, W) {
    return R.H.useLayoutEffect(O, W);
  }, $e.useMemo = function(O, W) {
    return R.H.useMemo(O, W);
  }, $e.useOptimistic = function(O, W) {
    return R.H.useOptimistic(O, W);
  }, $e.useReducer = function(O, W, Z) {
    return R.H.useReducer(O, W, Z);
  }, $e.useRef = function(O) {
    return R.H.useRef(O);
  }, $e.useState = function(O) {
    return R.H.useState(O);
  }, $e.useSyncExternalStore = function(O, W, Z) {
    return R.H.useSyncExternalStore(
      O,
      W,
      Z
    );
  }, $e.useTransition = function() {
    return R.H.useTransition();
  }, $e.version = "19.1.0", $e;
}
var sC;
function ef() {
  return sC || (sC = 1, vy.exports = g6()), vy.exports;
}
var by = { exports: {} }, pn = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lC;
function y6() {
  if (lC) return pn;
  lC = 1;
  var e = ef();
  function t(c) {
    var f = "https://react.dev/errors/" + c;
    if (1 < arguments.length) {
      f += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var h = 2; h < arguments.length; h++)
        f += "&args[]=" + encodeURIComponent(arguments[h]);
    }
    return "Minified React error #" + c + "; visit " + f + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function n() {
  }
  var r = {
    d: {
      f: n,
      r: function() {
        throw Error(t(522));
      },
      D: n,
      C: n,
      L: n,
      m: n,
      X: n,
      S: n,
      M: n
    },
    p: 0,
    findDOMNode: null
  }, o = Symbol.for("react.portal");
  function a(c, f, h) {
    var p = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
      $$typeof: o,
      key: p == null ? null : "" + p,
      children: c,
      containerInfo: f,
      implementation: h
    };
  }
  var s = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function u(c, f) {
    if (c === "font") return "";
    if (typeof f == "string")
      return f === "use-credentials" ? f : "";
  }
  return pn.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r, pn.createPortal = function(c, f) {
    var h = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!f || f.nodeType !== 1 && f.nodeType !== 9 && f.nodeType !== 11)
      throw Error(t(299));
    return a(c, f, null, h);
  }, pn.flushSync = function(c) {
    var f = s.T, h = r.p;
    try {
      if (s.T = null, r.p = 2, c) return c();
    } finally {
      s.T = f, r.p = h, r.d.f();
    }
  }, pn.preconnect = function(c, f) {
    typeof c == "string" && (f ? (f = f.crossOrigin, f = typeof f == "string" ? f === "use-credentials" ? f : "" : void 0) : f = null, r.d.C(c, f));
  }, pn.prefetchDNS = function(c) {
    typeof c == "string" && r.d.D(c);
  }, pn.preinit = function(c, f) {
    if (typeof c == "string" && f && typeof f.as == "string") {
      var h = f.as, p = u(h, f.crossOrigin), g = typeof f.integrity == "string" ? f.integrity : void 0, y = typeof f.fetchPriority == "string" ? f.fetchPriority : void 0;
      h === "style" ? r.d.S(
        c,
        typeof f.precedence == "string" ? f.precedence : void 0,
        {
          crossOrigin: p,
          integrity: g,
          fetchPriority: y
        }
      ) : h === "script" && r.d.X(c, {
        crossOrigin: p,
        integrity: g,
        fetchPriority: y,
        nonce: typeof f.nonce == "string" ? f.nonce : void 0
      });
    }
  }, pn.preinitModule = function(c, f) {
    if (typeof c == "string")
      if (typeof f == "object" && f !== null) {
        if (f.as == null || f.as === "script") {
          var h = u(
            f.as,
            f.crossOrigin
          );
          r.d.M(c, {
            crossOrigin: h,
            integrity: typeof f.integrity == "string" ? f.integrity : void 0,
            nonce: typeof f.nonce == "string" ? f.nonce : void 0
          });
        }
      } else f == null && r.d.M(c);
  }, pn.preload = function(c, f) {
    if (typeof c == "string" && typeof f == "object" && f !== null && typeof f.as == "string") {
      var h = f.as, p = u(h, f.crossOrigin);
      r.d.L(c, h, {
        crossOrigin: p,
        integrity: typeof f.integrity == "string" ? f.integrity : void 0,
        nonce: typeof f.nonce == "string" ? f.nonce : void 0,
        type: typeof f.type == "string" ? f.type : void 0,
        fetchPriority: typeof f.fetchPriority == "string" ? f.fetchPriority : void 0,
        referrerPolicy: typeof f.referrerPolicy == "string" ? f.referrerPolicy : void 0,
        imageSrcSet: typeof f.imageSrcSet == "string" ? f.imageSrcSet : void 0,
        imageSizes: typeof f.imageSizes == "string" ? f.imageSizes : void 0,
        media: typeof f.media == "string" ? f.media : void 0
      });
    }
  }, pn.preloadModule = function(c, f) {
    if (typeof c == "string")
      if (f) {
        var h = u(f.as, f.crossOrigin);
        r.d.m(c, {
          as: typeof f.as == "string" && f.as !== "script" ? f.as : void 0,
          crossOrigin: h,
          integrity: typeof f.integrity == "string" ? f.integrity : void 0
        });
      } else r.d.m(c);
  }, pn.requestFormReset = function(c) {
    r.d.r(c);
  }, pn.unstable_batchedUpdates = function(c, f) {
    return c(f);
  }, pn.useFormState = function(c, f, h) {
    return s.H.useFormState(c, f, h);
  }, pn.useFormStatus = function() {
    return s.H.useHostTransitionStatus();
  }, pn.version = "19.1.0", pn;
}
var uC;
function JR() {
  if (uC) return by.exports;
  uC = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), by.exports = y6(), by.exports;
}
var cC;
function v6() {
  if (cC) return ec;
  cC = 1;
  /**
   * @license React
   * react-dom-client.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var e = m6(), t = ef(), n = JR();
  function r(i) {
    var l = "https://react.dev/errors/" + i;
    if (1 < arguments.length) {
      l += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var d = 2; d < arguments.length; d++)
        l += "&args[]=" + encodeURIComponent(arguments[d]);
    }
    return "Minified React error #" + i + "; visit " + l + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function o(i) {
    return !(!i || i.nodeType !== 1 && i.nodeType !== 9 && i.nodeType !== 11);
  }
  function a(i) {
    var l = i, d = i;
    if (i.alternate) for (; l.return; ) l = l.return;
    else {
      i = l;
      do
        l = i, (l.flags & 4098) !== 0 && (d = l.return), i = l.return;
      while (i);
    }
    return l.tag === 3 ? d : null;
  }
  function s(i) {
    if (i.tag === 13) {
      var l = i.memoizedState;
      if (l === null && (i = i.alternate, i !== null && (l = i.memoizedState)), l !== null) return l.dehydrated;
    }
    return null;
  }
  function u(i) {
    if (a(i) !== i)
      throw Error(r(188));
  }
  function c(i) {
    var l = i.alternate;
    if (!l) {
      if (l = a(i), l === null) throw Error(r(188));
      return l !== i ? null : i;
    }
    for (var d = i, m = l; ; ) {
      var x = d.return;
      if (x === null) break;
      var C = x.alternate;
      if (C === null) {
        if (m = x.return, m !== null) {
          d = m;
          continue;
        }
        break;
      }
      if (x.child === C.child) {
        for (C = x.child; C; ) {
          if (C === d) return u(x), i;
          if (C === m) return u(x), l;
          C = C.sibling;
        }
        throw Error(r(188));
      }
      if (d.return !== m.return) d = x, m = C;
      else {
        for (var D = !1, $ = x.child; $; ) {
          if ($ === d) {
            D = !0, d = x, m = C;
            break;
          }
          if ($ === m) {
            D = !0, m = x, d = C;
            break;
          }
          $ = $.sibling;
        }
        if (!D) {
          for ($ = C.child; $; ) {
            if ($ === d) {
              D = !0, d = C, m = x;
              break;
            }
            if ($ === m) {
              D = !0, m = C, d = x;
              break;
            }
            $ = $.sibling;
          }
          if (!D) throw Error(r(189));
        }
      }
      if (d.alternate !== m) throw Error(r(190));
    }
    if (d.tag !== 3) throw Error(r(188));
    return d.stateNode.current === d ? i : l;
  }
  function f(i) {
    var l = i.tag;
    if (l === 5 || l === 26 || l === 27 || l === 6) return i;
    for (i = i.child; i !== null; ) {
      if (l = f(i), l !== null) return l;
      i = i.sibling;
    }
    return null;
  }
  var h = Object.assign, p = Symbol.for("react.element"), g = Symbol.for("react.transitional.element"), y = Symbol.for("react.portal"), w = Symbol.for("react.fragment"), v = Symbol.for("react.strict_mode"), S = Symbol.for("react.profiler"), E = Symbol.for("react.provider"), A = Symbol.for("react.consumer"), k = Symbol.for("react.context"), T = Symbol.for("react.forward_ref"), R = Symbol.for("react.suspense"), N = Symbol.for("react.suspense_list"), j = Symbol.for("react.memo"), z = Symbol.for("react.lazy"), B = Symbol.for("react.activity"), M = Symbol.for("react.memo_cache_sentinel"), F = Symbol.iterator;
  function q(i) {
    return i === null || typeof i != "object" ? null : (i = F && i[F] || i["@@iterator"], typeof i == "function" ? i : null);
  }
  var Y = Symbol.for("react.client.reference");
  function P(i) {
    if (i == null) return null;
    if (typeof i == "function")
      return i.$$typeof === Y ? null : i.displayName || i.name || null;
    if (typeof i == "string") return i;
    switch (i) {
      case w:
        return "Fragment";
      case S:
        return "Profiler";
      case v:
        return "StrictMode";
      case R:
        return "Suspense";
      case N:
        return "SuspenseList";
      case B:
        return "Activity";
    }
    if (typeof i == "object")
      switch (i.$$typeof) {
        case y:
          return "Portal";
        case k:
          return (i.displayName || "Context") + ".Provider";
        case A:
          return (i._context.displayName || "Context") + ".Consumer";
        case T:
          var l = i.render;
          return i = i.displayName, i || (i = l.displayName || l.name || "", i = i !== "" ? "ForwardRef(" + i + ")" : "ForwardRef"), i;
        case j:
          return l = i.displayName || null, l !== null ? l : P(i.type) || "Memo";
        case z:
          l = i._payload, i = i._init;
          try {
            return P(i(l));
          } catch {
          }
      }
    return null;
  }
  var V = Array.isArray, I = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, U = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, H = {
    pending: !1,
    data: null,
    method: null,
    action: null
  }, G = [], O = -1;
  function W(i) {
    return { current: i };
  }
  function Z(i) {
    0 > O || (i.current = G[O], G[O] = null, O--);
  }
  function L(i, l) {
    O++, G[O] = i.current, i.current = l;
  }
  var te = W(null), he = W(null), oe = W(null), fe = W(null);
  function ae(i, l) {
    switch (L(oe, l), L(he, i), L(te, null), l.nodeType) {
      case 9:
      case 11:
        i = (i = l.documentElement) && (i = i.namespaceURI) ? ME(i) : 0;
        break;
      default:
        if (i = l.tagName, l = l.namespaceURI)
          l = ME(l), i = OE(l, i);
        else
          switch (i) {
            case "svg":
              i = 1;
              break;
            case "math":
              i = 2;
              break;
            default:
              i = 0;
          }
    }
    Z(te), L(te, i);
  }
  function ye() {
    Z(te), Z(he), Z(oe);
  }
  function Ne(i) {
    i.memoizedState !== null && L(fe, i);
    var l = te.current, d = OE(l, i.type);
    l !== d && (L(he, i), L(te, d));
  }
  function De(i) {
    he.current === i && (Z(te), Z(he)), fe.current === i && (Z(fe), Yu._currentValue = H);
  }
  var we = Object.prototype.hasOwnProperty, Ce = e.unstable_scheduleCallback, _e = e.unstable_cancelCallback, Xe = e.unstable_shouldYield, St = e.unstable_requestPaint, ct = e.unstable_now, cn = e.unstable_getCurrentPriorityLevel, fr = e.unstable_ImmediatePriority, Un = e.unstable_UserBlockingPriority, qn = e.unstable_NormalPriority, ze = e.unstable_LowPriority, qr = e.unstable_IdlePriority, ca = e.log, gi = e.unstable_setDisableYieldValue, se = null, pe = null;
  function ke(i) {
    if (typeof ca == "function" && gi(i), pe && typeof pe.setStrictMode == "function")
      try {
        pe.setStrictMode(se, i);
      } catch {
      }
  }
  var je = Math.clz32 ? Math.clz32 : Ar, et = Math.log, _n = Math.LN2;
  function Ar(i) {
    return i >>>= 0, i === 0 ? 32 : 31 - (et(i) / _n | 0) | 0;
  }
  var fn = 256, dr = 4194304;
  function Sn(i) {
    var l = i & 42;
    if (l !== 0) return l;
    switch (i & -i) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return i & 4194048;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return i & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return i;
    }
  }
  function $t(i, l, d) {
    var m = i.pendingLanes;
    if (m === 0) return 0;
    var x = 0, C = i.suspendedLanes, D = i.pingedLanes;
    i = i.warmLanes;
    var $ = m & 134217727;
    return $ !== 0 ? (m = $ & ~C, m !== 0 ? x = Sn(m) : (D &= $, D !== 0 ? x = Sn(D) : d || (d = $ & ~i, d !== 0 && (x = Sn(d))))) : ($ = m & ~C, $ !== 0 ? x = Sn($) : D !== 0 ? x = Sn(D) : d || (d = m & ~i, d !== 0 && (x = Sn(d)))), x === 0 ? 0 : l !== 0 && l !== x && (l & C) === 0 && (C = x & -x, d = l & -l, C >= d || C === 32 && (d & 4194048) !== 0) ? l : x;
  }
  function Rn(i, l) {
    return (i.pendingLanes & ~(i.suspendedLanes & ~i.pingedLanes) & l) === 0;
  }
  function Gn(i, l) {
    switch (i) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return l + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Mf() {
    var i = fn;
    return fn <<= 1, (fn & 4194048) === 0 && (fn = 256), i;
  }
  function Of() {
    var i = dr;
    return dr <<= 1, (dr & 62914560) === 0 && (dr = 4194304), i;
  }
  function Wl(i) {
    for (var l = [], d = 0; 31 > d; d++) l.push(i);
    return l;
  }
  function fa(i, l) {
    i.pendingLanes |= l, l !== 268435456 && (i.suspendedLanes = 0, i.pingedLanes = 0, i.warmLanes = 0);
  }
  function og(i, l, d, m, x, C) {
    var D = i.pendingLanes;
    i.pendingLanes = d, i.suspendedLanes = 0, i.pingedLanes = 0, i.warmLanes = 0, i.expiredLanes &= d, i.entangledLanes &= d, i.errorRecoveryDisabledLanes &= d, i.shellSuspendCounter = 0;
    var $ = i.entanglements, X = i.expirationTimes, ee = i.hiddenUpdates;
    for (d = D & ~d; 0 < d; ) {
      var ue = 31 - je(d), de = 1 << ue;
      $[ue] = 0, X[ue] = -1;
      var ne = ee[ue];
      if (ne !== null)
        for (ee[ue] = null, ue = 0; ue < ne.length; ue++) {
          var re = ne[ue];
          re !== null && (re.lane &= -536870913);
        }
      d &= ~de;
    }
    m !== 0 && Nf(i, m, 0), C !== 0 && x === 0 && i.tag !== 0 && (i.suspendedLanes |= C & ~(D & ~l));
  }
  function Nf(i, l, d) {
    i.pendingLanes |= l, i.suspendedLanes &= ~l;
    var m = 31 - je(l);
    i.entangledLanes |= l, i.entanglements[m] = i.entanglements[m] | 1073741824 | d & 4194090;
  }
  function Xl(i, l) {
    var d = i.entangledLanes |= l;
    for (i = i.entanglements; d; ) {
      var m = 31 - je(d), x = 1 << m;
      x & l | i[m] & l && (i[m] |= l), d &= ~x;
    }
  }
  function Kl(i) {
    switch (i) {
      case 2:
        i = 1;
        break;
      case 8:
        i = 4;
        break;
      case 32:
        i = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        i = 128;
        break;
      case 268435456:
        i = 134217728;
        break;
      default:
        i = 0;
    }
    return i;
  }
  function Zl(i) {
    return i &= -i, 2 < i ? 8 < i ? (i & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
  }
  function Df() {
    var i = U.p;
    return i !== 0 ? i : (i = window.event, i === void 0 ? 32 : KE(i.type));
  }
  function ig(i, l) {
    var d = U.p;
    try {
      return U.p = i, l();
    } finally {
      U.p = d;
    }
  }
  var Gr = Math.random().toString(36).slice(2), Qt = "__reactFiber$" + Gr, dn = "__reactProps$" + Gr, yi = "__reactContainer$" + Gr, Ql = "__reactEvents$" + Gr, ag = "__reactListeners$" + Gr, sg = "__reactHandles$" + Gr, jf = "__reactResources$" + Gr, da = "__reactMarker$" + Gr;
  function Jl(i) {
    delete i[Qt], delete i[dn], delete i[Ql], delete i[ag], delete i[sg];
  }
  function vi(i) {
    var l = i[Qt];
    if (l) return l;
    for (var d = i.parentNode; d; ) {
      if (l = d[yi] || d[Qt]) {
        if (d = l.alternate, l.child !== null || d !== null && d.child !== null)
          for (i = PE(i); i !== null; ) {
            if (d = i[Qt]) return d;
            i = PE(i);
          }
        return l;
      }
      i = d, d = i.parentNode;
    }
    return null;
  }
  function ko(i) {
    if (i = i[Qt] || i[yi]) {
      var l = i.tag;
      if (l === 5 || l === 6 || l === 13 || l === 26 || l === 27 || l === 3)
        return i;
    }
    return null;
  }
  function bi(i) {
    var l = i.tag;
    if (l === 5 || l === 26 || l === 27 || l === 6) return i.stateNode;
    throw Error(r(33));
  }
  function To(i) {
    var l = i[jf];
    return l || (l = i[jf] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), l;
  }
  function Bt(i) {
    i[da] = !0;
  }
  var Pf = /* @__PURE__ */ new Set(), If = {};
  function Ao(i, l) {
    xi(i, l), xi(i + "Capture", l);
  }
  function xi(i, l) {
    for (If[i] = l, i = 0; i < l.length; i++)
      Pf.add(l[i]);
  }
  var lg = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), eu = {}, zf = {};
  function ug(i) {
    return we.call(zf, i) ? !0 : we.call(eu, i) ? !1 : lg.test(i) ? zf[i] = !0 : (eu[i] = !0, !1);
  }
  function as(i, l, d) {
    if (ug(l))
      if (d === null) i.removeAttribute(l);
      else {
        switch (typeof d) {
          case "undefined":
          case "function":
          case "symbol":
            i.removeAttribute(l);
            return;
          case "boolean":
            var m = l.toLowerCase().slice(0, 5);
            if (m !== "data-" && m !== "aria-") {
              i.removeAttribute(l);
              return;
            }
        }
        i.setAttribute(l, "" + d);
      }
  }
  function ss(i, l, d) {
    if (d === null) i.removeAttribute(l);
    else {
      switch (typeof d) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          i.removeAttribute(l);
          return;
      }
      i.setAttribute(l, "" + d);
    }
  }
  function Rr(i, l, d, m) {
    if (m === null) i.removeAttribute(d);
    else {
      switch (typeof m) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          i.removeAttribute(d);
          return;
      }
      i.setAttributeNS(l, d, "" + m);
    }
  }
  var tu, Lf;
  function Ro(i) {
    if (tu === void 0)
      try {
        throw Error();
      } catch (d) {
        var l = d.stack.trim().match(/\n( *(at )?)/);
        tu = l && l[1] || "", Lf = -1 < d.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < d.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return `
` + tu + i + Lf;
  }
  var nu = !1;
  function ru(i, l) {
    if (!i || nu) return "";
    nu = !0;
    var d = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var m = {
        DetermineComponentFrameRoot: function() {
          try {
            if (l) {
              var de = function() {
                throw Error();
              };
              if (Object.defineProperty(de.prototype, "props", {
                set: function() {
                  throw Error();
                }
              }), typeof Reflect == "object" && Reflect.construct) {
                try {
                  Reflect.construct(de, []);
                } catch (re) {
                  var ne = re;
                }
                Reflect.construct(i, [], de);
              } else {
                try {
                  de.call();
                } catch (re) {
                  ne = re;
                }
                i.call(de.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (re) {
                ne = re;
              }
              (de = i()) && typeof de.catch == "function" && de.catch(function() {
              });
            }
          } catch (re) {
            if (re && ne && typeof re.stack == "string")
              return [re.stack, ne.stack];
          }
          return [null, null];
        }
      };
      m.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var x = Object.getOwnPropertyDescriptor(
        m.DetermineComponentFrameRoot,
        "name"
      );
      x && x.configurable && Object.defineProperty(
        m.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var C = m.DetermineComponentFrameRoot(), D = C[0], $ = C[1];
      if (D && $) {
        var X = D.split(`
`), ee = $.split(`
`);
        for (x = m = 0; m < X.length && !X[m].includes("DetermineComponentFrameRoot"); )
          m++;
        for (; x < ee.length && !ee[x].includes(
          "DetermineComponentFrameRoot"
        ); )
          x++;
        if (m === X.length || x === ee.length)
          for (m = X.length - 1, x = ee.length - 1; 1 <= m && 0 <= x && X[m] !== ee[x]; )
            x--;
        for (; 1 <= m && 0 <= x; m--, x--)
          if (X[m] !== ee[x]) {
            if (m !== 1 || x !== 1)
              do
                if (m--, x--, 0 > x || X[m] !== ee[x]) {
                  var ue = `
` + X[m].replace(" at new ", " at ");
                  return i.displayName && ue.includes("<anonymous>") && (ue = ue.replace("<anonymous>", i.displayName)), ue;
                }
              while (1 <= m && 0 <= x);
            break;
          }
      }
    } finally {
      nu = !1, Error.prepareStackTrace = d;
    }
    return (d = i ? i.displayName || i.name : "") ? Ro(d) : "";
  }
  function cg(i) {
    switch (i.tag) {
      case 26:
      case 27:
      case 5:
        return Ro(i.type);
      case 16:
        return Ro("Lazy");
      case 13:
        return Ro("Suspense");
      case 19:
        return Ro("SuspenseList");
      case 0:
      case 15:
        return ru(i.type, !1);
      case 11:
        return ru(i.type.render, !1);
      case 1:
        return ru(i.type, !0);
      case 31:
        return Ro("Activity");
      default:
        return "";
    }
  }
  function Ff(i) {
    try {
      var l = "";
      do
        l += cg(i), i = i.return;
      while (i);
      return l;
    } catch (d) {
      return `
Error generating stack: ` + d.message + `
` + d.stack;
    }
  }
  function Mn(i) {
    switch (typeof i) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return i;
      case "object":
        return i;
      default:
        return "";
    }
  }
  function $f(i) {
    var l = i.type;
    return (i = i.nodeName) && i.toLowerCase() === "input" && (l === "checkbox" || l === "radio");
  }
  function fg(i) {
    var l = $f(i) ? "checked" : "value", d = Object.getOwnPropertyDescriptor(
      i.constructor.prototype,
      l
    ), m = "" + i[l];
    if (!i.hasOwnProperty(l) && typeof d < "u" && typeof d.get == "function" && typeof d.set == "function") {
      var x = d.get, C = d.set;
      return Object.defineProperty(i, l, {
        configurable: !0,
        get: function() {
          return x.call(this);
        },
        set: function(D) {
          m = "" + D, C.call(this, D);
        }
      }), Object.defineProperty(i, l, {
        enumerable: d.enumerable
      }), {
        getValue: function() {
          return m;
        },
        setValue: function(D) {
          m = "" + D;
        },
        stopTracking: function() {
          i._valueTracker = null, delete i[l];
        }
      };
    }
  }
  function ls(i) {
    i._valueTracker || (i._valueTracker = fg(i));
  }
  function ou(i) {
    if (!i) return !1;
    var l = i._valueTracker;
    if (!l) return !0;
    var d = l.getValue(), m = "";
    return i && (m = $f(i) ? i.checked ? "true" : "false" : i.value), i = m, i !== d ? (l.setValue(i), !0) : !1;
  }
  function us(i) {
    if (i = i || (typeof document < "u" ? document : void 0), typeof i > "u") return null;
    try {
      return i.activeElement || i.body;
    } catch {
      return i.body;
    }
  }
  var dg = /[\n"\\]/g;
  function On(i) {
    return i.replace(
      dg,
      function(l) {
        return "\\" + l.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function ha(i, l, d, m, x, C, D, $) {
    i.name = "", D != null && typeof D != "function" && typeof D != "symbol" && typeof D != "boolean" ? i.type = D : i.removeAttribute("type"), l != null ? D === "number" ? (l === 0 && i.value === "" || i.value != l) && (i.value = "" + Mn(l)) : i.value !== "" + Mn(l) && (i.value = "" + Mn(l)) : D !== "submit" && D !== "reset" || i.removeAttribute("value"), l != null ? iu(i, D, Mn(l)) : d != null ? iu(i, D, Mn(d)) : m != null && i.removeAttribute("value"), x == null && C != null && (i.defaultChecked = !!C), x != null && (i.checked = x && typeof x != "function" && typeof x != "symbol"), $ != null && typeof $ != "function" && typeof $ != "symbol" && typeof $ != "boolean" ? i.name = "" + Mn($) : i.removeAttribute("name");
  }
  function Bf(i, l, d, m, x, C, D, $) {
    if (C != null && typeof C != "function" && typeof C != "symbol" && typeof C != "boolean" && (i.type = C), l != null || d != null) {
      if (!(C !== "submit" && C !== "reset" || l != null))
        return;
      d = d != null ? "" + Mn(d) : "", l = l != null ? "" + Mn(l) : d, $ || l === i.value || (i.value = l), i.defaultValue = l;
    }
    m = m ?? x, m = typeof m != "function" && typeof m != "symbol" && !!m, i.checked = $ ? i.checked : !!m, i.defaultChecked = !!m, D != null && typeof D != "function" && typeof D != "symbol" && typeof D != "boolean" && (i.name = D);
  }
  function iu(i, l, d) {
    l === "number" && us(i.ownerDocument) === i || i.defaultValue === "" + d || (i.defaultValue = "" + d);
  }
  function Mo(i, l, d, m) {
    if (i = i.options, l) {
      l = {};
      for (var x = 0; x < d.length; x++)
        l["$" + d[x]] = !0;
      for (d = 0; d < i.length; d++)
        x = l.hasOwnProperty("$" + i[d].value), i[d].selected !== x && (i[d].selected = x), x && m && (i[d].defaultSelected = !0);
    } else {
      for (d = "" + Mn(d), l = null, x = 0; x < i.length; x++) {
        if (i[x].value === d) {
          i[x].selected = !0, m && (i[x].defaultSelected = !0);
          return;
        }
        l !== null || i[x].disabled || (l = i[x]);
      }
      l !== null && (l.selected = !0);
    }
  }
  function Aw(i, l, d) {
    if (l != null && (l = "" + Mn(l), l !== i.value && (i.value = l), d == null)) {
      i.defaultValue !== l && (i.defaultValue = l);
      return;
    }
    i.defaultValue = d != null ? "" + Mn(d) : "";
  }
  function Rw(i, l, d, m) {
    if (l == null) {
      if (m != null) {
        if (d != null) throw Error(r(92));
        if (V(m)) {
          if (1 < m.length) throw Error(r(93));
          m = m[0];
        }
        d = m;
      }
      d == null && (d = ""), l = d;
    }
    d = Mn(l), i.defaultValue = d, m = i.textContent, m === d && m !== "" && m !== null && (i.value = m);
  }
  function cs(i, l) {
    if (l) {
      var d = i.firstChild;
      if (d && d === i.lastChild && d.nodeType === 3) {
        d.nodeValue = l;
        return;
      }
    }
    i.textContent = l;
  }
  var iP = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function Mw(i, l, d) {
    var m = l.indexOf("--") === 0;
    d == null || typeof d == "boolean" || d === "" ? m ? i.setProperty(l, "") : l === "float" ? i.cssFloat = "" : i[l] = "" : m ? i.setProperty(l, d) : typeof d != "number" || d === 0 || iP.has(l) ? l === "float" ? i.cssFloat = d : i[l] = ("" + d).trim() : i[l] = d + "px";
  }
  function Ow(i, l, d) {
    if (l != null && typeof l != "object")
      throw Error(r(62));
    if (i = i.style, d != null) {
      for (var m in d)
        !d.hasOwnProperty(m) || l != null && l.hasOwnProperty(m) || (m.indexOf("--") === 0 ? i.setProperty(m, "") : m === "float" ? i.cssFloat = "" : i[m] = "");
      for (var x in l)
        m = l[x], l.hasOwnProperty(x) && d[x] !== m && Mw(i, x, m);
    } else
      for (var C in l)
        l.hasOwnProperty(C) && Mw(i, C, l[C]);
  }
  function hg(i) {
    if (i.indexOf("-") === -1) return !1;
    switch (i) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var aP = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), sP = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function Hf(i) {
    return sP.test("" + i) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : i;
  }
  var pg = null;
  function mg(i) {
    return i = i.target || i.srcElement || window, i.correspondingUseElement && (i = i.correspondingUseElement), i.nodeType === 3 ? i.parentNode : i;
  }
  var fs = null, ds = null;
  function Nw(i) {
    var l = ko(i);
    if (l && (i = l.stateNode)) {
      var d = i[dn] || null;
      e: switch (i = l.stateNode, l.type) {
        case "input":
          if (ha(
            i,
            d.value,
            d.defaultValue,
            d.defaultValue,
            d.checked,
            d.defaultChecked,
            d.type,
            d.name
          ), l = d.name, d.type === "radio" && l != null) {
            for (d = i; d.parentNode; ) d = d.parentNode;
            for (d = d.querySelectorAll(
              'input[name="' + On(
                "" + l
              ) + '"][type="radio"]'
            ), l = 0; l < d.length; l++) {
              var m = d[l];
              if (m !== i && m.form === i.form) {
                var x = m[dn] || null;
                if (!x) throw Error(r(90));
                ha(
                  m,
                  x.value,
                  x.defaultValue,
                  x.defaultValue,
                  x.checked,
                  x.defaultChecked,
                  x.type,
                  x.name
                );
              }
            }
            for (l = 0; l < d.length; l++)
              m = d[l], m.form === i.form && ou(m);
          }
          break e;
        case "textarea":
          Aw(i, d.value, d.defaultValue);
          break e;
        case "select":
          l = d.value, l != null && Mo(i, !!d.multiple, l, !1);
      }
    }
  }
  var gg = !1;
  function Dw(i, l, d) {
    if (gg) return i(l, d);
    gg = !0;
    try {
      var m = i(l);
      return m;
    } finally {
      if (gg = !1, (fs !== null || ds !== null) && (Td(), fs && (l = fs, i = ds, ds = fs = null, Nw(l), i)))
        for (l = 0; l < i.length; l++) Nw(i[l]);
    }
  }
  function au(i, l) {
    var d = i.stateNode;
    if (d === null) return null;
    var m = d[dn] || null;
    if (m === null) return null;
    d = m[l];
    e: switch (l) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (m = !m.disabled) || (i = i.type, m = !(i === "button" || i === "input" || i === "select" || i === "textarea")), i = !m;
        break e;
      default:
        i = !1;
    }
    if (i) return null;
    if (d && typeof d != "function")
      throw Error(
        r(231, l, typeof d)
      );
    return d;
  }
  var Oo = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), yg = !1;
  if (Oo)
    try {
      var su = {};
      Object.defineProperty(su, "passive", {
        get: function() {
          yg = !0;
        }
      }), window.addEventListener("test", su, su), window.removeEventListener("test", su, su);
    } catch {
      yg = !1;
    }
  var wi = null, vg = null, Vf = null;
  function jw() {
    if (Vf) return Vf;
    var i, l = vg, d = l.length, m, x = "value" in wi ? wi.value : wi.textContent, C = x.length;
    for (i = 0; i < d && l[i] === x[i]; i++) ;
    var D = d - i;
    for (m = 1; m <= D && l[d - m] === x[C - m]; m++) ;
    return Vf = x.slice(i, 1 < m ? 1 - m : void 0);
  }
  function Uf(i) {
    var l = i.keyCode;
    return "charCode" in i ? (i = i.charCode, i === 0 && l === 13 && (i = 13)) : i = l, i === 10 && (i = 13), 32 <= i || i === 13 ? i : 0;
  }
  function qf() {
    return !0;
  }
  function Pw() {
    return !1;
  }
  function Nn(i) {
    function l(d, m, x, C, D) {
      this._reactName = d, this._targetInst = x, this.type = m, this.nativeEvent = C, this.target = D, this.currentTarget = null;
      for (var $ in i)
        i.hasOwnProperty($) && (d = i[$], this[$] = d ? d(C) : C[$]);
      return this.isDefaultPrevented = (C.defaultPrevented != null ? C.defaultPrevented : C.returnValue === !1) ? qf : Pw, this.isPropagationStopped = Pw, this;
    }
    return h(l.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0;
        var d = this.nativeEvent;
        d && (d.preventDefault ? d.preventDefault() : typeof d.returnValue != "unknown" && (d.returnValue = !1), this.isDefaultPrevented = qf);
      },
      stopPropagation: function() {
        var d = this.nativeEvent;
        d && (d.stopPropagation ? d.stopPropagation() : typeof d.cancelBubble != "unknown" && (d.cancelBubble = !0), this.isPropagationStopped = qf);
      },
      persist: function() {
      },
      isPersistent: qf
    }), l;
  }
  var pa = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(i) {
      return i.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, Gf = Nn(pa), lu = h({}, pa, { view: 0, detail: 0 }), lP = Nn(lu), bg, xg, uu, Yf = h({}, lu, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: _g,
    button: 0,
    buttons: 0,
    relatedTarget: function(i) {
      return i.relatedTarget === void 0 ? i.fromElement === i.srcElement ? i.toElement : i.fromElement : i.relatedTarget;
    },
    movementX: function(i) {
      return "movementX" in i ? i.movementX : (i !== uu && (uu && i.type === "mousemove" ? (bg = i.screenX - uu.screenX, xg = i.screenY - uu.screenY) : xg = bg = 0, uu = i), bg);
    },
    movementY: function(i) {
      return "movementY" in i ? i.movementY : xg;
    }
  }), Iw = Nn(Yf), uP = h({}, Yf, { dataTransfer: 0 }), cP = Nn(uP), fP = h({}, lu, { relatedTarget: 0 }), wg = Nn(fP), dP = h({}, pa, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), hP = Nn(dP), pP = h({}, pa, {
    clipboardData: function(i) {
      return "clipboardData" in i ? i.clipboardData : window.clipboardData;
    }
  }), mP = Nn(pP), gP = h({}, pa, { data: 0 }), zw = Nn(gP), yP = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, vP = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, bP = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function xP(i) {
    var l = this.nativeEvent;
    return l.getModifierState ? l.getModifierState(i) : (i = bP[i]) ? !!l[i] : !1;
  }
  function _g() {
    return xP;
  }
  var wP = h({}, lu, {
    key: function(i) {
      if (i.key) {
        var l = yP[i.key] || i.key;
        if (l !== "Unidentified") return l;
      }
      return i.type === "keypress" ? (i = Uf(i), i === 13 ? "Enter" : String.fromCharCode(i)) : i.type === "keydown" || i.type === "keyup" ? vP[i.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: _g,
    charCode: function(i) {
      return i.type === "keypress" ? Uf(i) : 0;
    },
    keyCode: function(i) {
      return i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0;
    },
    which: function(i) {
      return i.type === "keypress" ? Uf(i) : i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0;
    }
  }), _P = Nn(wP), SP = h({}, Yf, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), Lw = Nn(SP), EP = h({}, lu, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: _g
  }), CP = Nn(EP), kP = h({}, pa, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), TP = Nn(kP), AP = h({}, Yf, {
    deltaX: function(i) {
      return "deltaX" in i ? i.deltaX : "wheelDeltaX" in i ? -i.wheelDeltaX : 0;
    },
    deltaY: function(i) {
      return "deltaY" in i ? i.deltaY : "wheelDeltaY" in i ? -i.wheelDeltaY : "wheelDelta" in i ? -i.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), RP = Nn(AP), MP = h({}, pa, {
    newState: 0,
    oldState: 0
  }), OP = Nn(MP), NP = [9, 13, 27, 32], Sg = Oo && "CompositionEvent" in window, cu = null;
  Oo && "documentMode" in document && (cu = document.documentMode);
  var DP = Oo && "TextEvent" in window && !cu, Fw = Oo && (!Sg || cu && 8 < cu && 11 >= cu), $w = " ", Bw = !1;
  function Hw(i, l) {
    switch (i) {
      case "keyup":
        return NP.indexOf(l.keyCode) !== -1;
      case "keydown":
        return l.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Vw(i) {
    return i = i.detail, typeof i == "object" && "data" in i ? i.data : null;
  }
  var hs = !1;
  function jP(i, l) {
    switch (i) {
      case "compositionend":
        return Vw(l);
      case "keypress":
        return l.which !== 32 ? null : (Bw = !0, $w);
      case "textInput":
        return i = l.data, i === $w && Bw ? null : i;
      default:
        return null;
    }
  }
  function PP(i, l) {
    if (hs)
      return i === "compositionend" || !Sg && Hw(i, l) ? (i = jw(), Vf = vg = wi = null, hs = !1, i) : null;
    switch (i) {
      case "paste":
        return null;
      case "keypress":
        if (!(l.ctrlKey || l.altKey || l.metaKey) || l.ctrlKey && l.altKey) {
          if (l.char && 1 < l.char.length)
            return l.char;
          if (l.which) return String.fromCharCode(l.which);
        }
        return null;
      case "compositionend":
        return Fw && l.locale !== "ko" ? null : l.data;
      default:
        return null;
    }
  }
  var IP = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };
  function Uw(i) {
    var l = i && i.nodeName && i.nodeName.toLowerCase();
    return l === "input" ? !!IP[i.type] : l === "textarea";
  }
  function qw(i, l, d, m) {
    fs ? ds ? ds.push(m) : ds = [m] : fs = m, l = Dd(l, "onChange"), 0 < l.length && (d = new Gf(
      "onChange",
      "change",
      null,
      d,
      m
    ), i.push({ event: d, listeners: l }));
  }
  var fu = null, du = null;
  function zP(i) {
    CE(i, 0);
  }
  function Wf(i) {
    var l = bi(i);
    if (ou(l)) return i;
  }
  function Gw(i, l) {
    if (i === "change") return l;
  }
  var Yw = !1;
  if (Oo) {
    var Eg;
    if (Oo) {
      var Cg = "oninput" in document;
      if (!Cg) {
        var Ww = document.createElement("div");
        Ww.setAttribute("oninput", "return;"), Cg = typeof Ww.oninput == "function";
      }
      Eg = Cg;
    } else Eg = !1;
    Yw = Eg && (!document.documentMode || 9 < document.documentMode);
  }
  function Xw() {
    fu && (fu.detachEvent("onpropertychange", Kw), du = fu = null);
  }
  function Kw(i) {
    if (i.propertyName === "value" && Wf(du)) {
      var l = [];
      qw(
        l,
        du,
        i,
        mg(i)
      ), Dw(zP, l);
    }
  }
  function LP(i, l, d) {
    i === "focusin" ? (Xw(), fu = l, du = d, fu.attachEvent("onpropertychange", Kw)) : i === "focusout" && Xw();
  }
  function FP(i) {
    if (i === "selectionchange" || i === "keyup" || i === "keydown")
      return Wf(du);
  }
  function $P(i, l) {
    if (i === "click") return Wf(l);
  }
  function BP(i, l) {
    if (i === "input" || i === "change")
      return Wf(l);
  }
  function HP(i, l) {
    return i === l && (i !== 0 || 1 / i === 1 / l) || i !== i && l !== l;
  }
  var Yn = typeof Object.is == "function" ? Object.is : HP;
  function hu(i, l) {
    if (Yn(i, l)) return !0;
    if (typeof i != "object" || i === null || typeof l != "object" || l === null)
      return !1;
    var d = Object.keys(i), m = Object.keys(l);
    if (d.length !== m.length) return !1;
    for (m = 0; m < d.length; m++) {
      var x = d[m];
      if (!we.call(l, x) || !Yn(i[x], l[x]))
        return !1;
    }
    return !0;
  }
  function Zw(i) {
    for (; i && i.firstChild; ) i = i.firstChild;
    return i;
  }
  function Qw(i, l) {
    var d = Zw(i);
    i = 0;
    for (var m; d; ) {
      if (d.nodeType === 3) {
        if (m = i + d.textContent.length, i <= l && m >= l)
          return { node: d, offset: l - i };
        i = m;
      }
      e: {
        for (; d; ) {
          if (d.nextSibling) {
            d = d.nextSibling;
            break e;
          }
          d = d.parentNode;
        }
        d = void 0;
      }
      d = Zw(d);
    }
  }
  function Jw(i, l) {
    return i && l ? i === l ? !0 : i && i.nodeType === 3 ? !1 : l && l.nodeType === 3 ? Jw(i, l.parentNode) : "contains" in i ? i.contains(l) : i.compareDocumentPosition ? !!(i.compareDocumentPosition(l) & 16) : !1 : !1;
  }
  function e_(i) {
    i = i != null && i.ownerDocument != null && i.ownerDocument.defaultView != null ? i.ownerDocument.defaultView : window;
    for (var l = us(i.document); l instanceof i.HTMLIFrameElement; ) {
      try {
        var d = typeof l.contentWindow.location.href == "string";
      } catch {
        d = !1;
      }
      if (d) i = l.contentWindow;
      else break;
      l = us(i.document);
    }
    return l;
  }
  function kg(i) {
    var l = i && i.nodeName && i.nodeName.toLowerCase();
    return l && (l === "input" && (i.type === "text" || i.type === "search" || i.type === "tel" || i.type === "url" || i.type === "password") || l === "textarea" || i.contentEditable === "true");
  }
  var VP = Oo && "documentMode" in document && 11 >= document.documentMode, ps = null, Tg = null, pu = null, Ag = !1;
  function t_(i, l, d) {
    var m = d.window === d ? d.document : d.nodeType === 9 ? d : d.ownerDocument;
    Ag || ps == null || ps !== us(m) || (m = ps, "selectionStart" in m && kg(m) ? m = { start: m.selectionStart, end: m.selectionEnd } : (m = (m.ownerDocument && m.ownerDocument.defaultView || window).getSelection(), m = {
      anchorNode: m.anchorNode,
      anchorOffset: m.anchorOffset,
      focusNode: m.focusNode,
      focusOffset: m.focusOffset
    }), pu && hu(pu, m) || (pu = m, m = Dd(Tg, "onSelect"), 0 < m.length && (l = new Gf(
      "onSelect",
      "select",
      null,
      l,
      d
    ), i.push({ event: l, listeners: m }), l.target = ps)));
  }
  function ma(i, l) {
    var d = {};
    return d[i.toLowerCase()] = l.toLowerCase(), d["Webkit" + i] = "webkit" + l, d["Moz" + i] = "moz" + l, d;
  }
  var ms = {
    animationend: ma("Animation", "AnimationEnd"),
    animationiteration: ma("Animation", "AnimationIteration"),
    animationstart: ma("Animation", "AnimationStart"),
    transitionrun: ma("Transition", "TransitionRun"),
    transitionstart: ma("Transition", "TransitionStart"),
    transitioncancel: ma("Transition", "TransitionCancel"),
    transitionend: ma("Transition", "TransitionEnd")
  }, Rg = {}, n_ = {};
  Oo && (n_ = document.createElement("div").style, "AnimationEvent" in window || (delete ms.animationend.animation, delete ms.animationiteration.animation, delete ms.animationstart.animation), "TransitionEvent" in window || delete ms.transitionend.transition);
  function ga(i) {
    if (Rg[i]) return Rg[i];
    if (!ms[i]) return i;
    var l = ms[i], d;
    for (d in l)
      if (l.hasOwnProperty(d) && d in n_)
        return Rg[i] = l[d];
    return i;
  }
  var r_ = ga("animationend"), o_ = ga("animationiteration"), i_ = ga("animationstart"), UP = ga("transitionrun"), qP = ga("transitionstart"), GP = ga("transitioncancel"), a_ = ga("transitionend"), s_ = /* @__PURE__ */ new Map(), Mg = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  Mg.push("scrollEnd");
  function Mr(i, l) {
    s_.set(i, l), Ao(l, [i]);
  }
  var l_ = /* @__PURE__ */ new WeakMap();
  function hr(i, l) {
    if (typeof i == "object" && i !== null) {
      var d = l_.get(i);
      return d !== void 0 ? d : (l = {
        value: i,
        source: l,
        stack: Ff(l)
      }, l_.set(i, l), l);
    }
    return {
      value: i,
      source: l,
      stack: Ff(l)
    };
  }
  var pr = [], gs = 0, Og = 0;
  function Xf() {
    for (var i = gs, l = Og = gs = 0; l < i; ) {
      var d = pr[l];
      pr[l++] = null;
      var m = pr[l];
      pr[l++] = null;
      var x = pr[l];
      pr[l++] = null;
      var C = pr[l];
      if (pr[l++] = null, m !== null && x !== null) {
        var D = m.pending;
        D === null ? x.next = x : (x.next = D.next, D.next = x), m.pending = x;
      }
      C !== 0 && u_(d, x, C);
    }
  }
  function Kf(i, l, d, m) {
    pr[gs++] = i, pr[gs++] = l, pr[gs++] = d, pr[gs++] = m, Og |= m, i.lanes |= m, i = i.alternate, i !== null && (i.lanes |= m);
  }
  function Ng(i, l, d, m) {
    return Kf(i, l, d, m), Zf(i);
  }
  function ys(i, l) {
    return Kf(i, null, null, l), Zf(i);
  }
  function u_(i, l, d) {
    i.lanes |= d;
    var m = i.alternate;
    m !== null && (m.lanes |= d);
    for (var x = !1, C = i.return; C !== null; )
      C.childLanes |= d, m = C.alternate, m !== null && (m.childLanes |= d), C.tag === 22 && (i = C.stateNode, i === null || i._visibility & 1 || (x = !0)), i = C, C = C.return;
    return i.tag === 3 ? (C = i.stateNode, x && l !== null && (x = 31 - je(d), i = C.hiddenUpdates, m = i[x], m === null ? i[x] = [l] : m.push(l), l.lane = d | 536870912), C) : null;
  }
  function Zf(i) {
    if (50 < Fu)
      throw Fu = 0, L0 = null, Error(r(185));
    for (var l = i.return; l !== null; )
      i = l, l = i.return;
    return i.tag === 3 ? i.stateNode : null;
  }
  var vs = {};
  function YP(i, l, d, m) {
    this.tag = i, this.key = d, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = l, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = m, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Wn(i, l, d, m) {
    return new YP(i, l, d, m);
  }
  function Dg(i) {
    return i = i.prototype, !(!i || !i.isReactComponent);
  }
  function No(i, l) {
    var d = i.alternate;
    return d === null ? (d = Wn(
      i.tag,
      l,
      i.key,
      i.mode
    ), d.elementType = i.elementType, d.type = i.type, d.stateNode = i.stateNode, d.alternate = i, i.alternate = d) : (d.pendingProps = l, d.type = i.type, d.flags = 0, d.subtreeFlags = 0, d.deletions = null), d.flags = i.flags & 65011712, d.childLanes = i.childLanes, d.lanes = i.lanes, d.child = i.child, d.memoizedProps = i.memoizedProps, d.memoizedState = i.memoizedState, d.updateQueue = i.updateQueue, l = i.dependencies, d.dependencies = l === null ? null : { lanes: l.lanes, firstContext: l.firstContext }, d.sibling = i.sibling, d.index = i.index, d.ref = i.ref, d.refCleanup = i.refCleanup, d;
  }
  function c_(i, l) {
    i.flags &= 65011714;
    var d = i.alternate;
    return d === null ? (i.childLanes = 0, i.lanes = l, i.child = null, i.subtreeFlags = 0, i.memoizedProps = null, i.memoizedState = null, i.updateQueue = null, i.dependencies = null, i.stateNode = null) : (i.childLanes = d.childLanes, i.lanes = d.lanes, i.child = d.child, i.subtreeFlags = 0, i.deletions = null, i.memoizedProps = d.memoizedProps, i.memoizedState = d.memoizedState, i.updateQueue = d.updateQueue, i.type = d.type, l = d.dependencies, i.dependencies = l === null ? null : {
      lanes: l.lanes,
      firstContext: l.firstContext
    }), i;
  }
  function Qf(i, l, d, m, x, C) {
    var D = 0;
    if (m = i, typeof i == "function") Dg(i) && (D = 1);
    else if (typeof i == "string")
      D = XI(
        i,
        d,
        te.current
      ) ? 26 : i === "html" || i === "head" || i === "body" ? 27 : 5;
    else
      e: switch (i) {
        case B:
          return i = Wn(31, d, l, x), i.elementType = B, i.lanes = C, i;
        case w:
          return ya(d.children, x, C, l);
        case v:
          D = 8, x |= 24;
          break;
        case S:
          return i = Wn(12, d, l, x | 2), i.elementType = S, i.lanes = C, i;
        case R:
          return i = Wn(13, d, l, x), i.elementType = R, i.lanes = C, i;
        case N:
          return i = Wn(19, d, l, x), i.elementType = N, i.lanes = C, i;
        default:
          if (typeof i == "object" && i !== null)
            switch (i.$$typeof) {
              case E:
              case k:
                D = 10;
                break e;
              case A:
                D = 9;
                break e;
              case T:
                D = 11;
                break e;
              case j:
                D = 14;
                break e;
              case z:
                D = 16, m = null;
                break e;
            }
          D = 29, d = Error(
            r(130, i === null ? "null" : typeof i, "")
          ), m = null;
      }
    return l = Wn(D, d, l, x), l.elementType = i, l.type = m, l.lanes = C, l;
  }
  function ya(i, l, d, m) {
    return i = Wn(7, i, m, l), i.lanes = d, i;
  }
  function jg(i, l, d) {
    return i = Wn(6, i, null, l), i.lanes = d, i;
  }
  function Pg(i, l, d) {
    return l = Wn(
      4,
      i.children !== null ? i.children : [],
      i.key,
      l
    ), l.lanes = d, l.stateNode = {
      containerInfo: i.containerInfo,
      pendingChildren: null,
      implementation: i.implementation
    }, l;
  }
  var bs = [], xs = 0, Jf = null, ed = 0, mr = [], gr = 0, va = null, Do = 1, jo = "";
  function ba(i, l) {
    bs[xs++] = ed, bs[xs++] = Jf, Jf = i, ed = l;
  }
  function f_(i, l, d) {
    mr[gr++] = Do, mr[gr++] = jo, mr[gr++] = va, va = i;
    var m = Do;
    i = jo;
    var x = 32 - je(m) - 1;
    m &= ~(1 << x), d += 1;
    var C = 32 - je(l) + x;
    if (30 < C) {
      var D = x - x % 5;
      C = (m & (1 << D) - 1).toString(32), m >>= D, x -= D, Do = 1 << 32 - je(l) + x | d << x | m, jo = C + i;
    } else
      Do = 1 << C | d << x | m, jo = i;
  }
  function Ig(i) {
    i.return !== null && (ba(i, 1), f_(i, 1, 0));
  }
  function zg(i) {
    for (; i === Jf; )
      Jf = bs[--xs], bs[xs] = null, ed = bs[--xs], bs[xs] = null;
    for (; i === va; )
      va = mr[--gr], mr[gr] = null, jo = mr[--gr], mr[gr] = null, Do = mr[--gr], mr[gr] = null;
  }
  var En = null, Mt = null, rt = !1, xa = null, Yr = !1, Lg = Error(r(519));
  function wa(i) {
    var l = Error(r(418, ""));
    throw yu(hr(l, i)), Lg;
  }
  function d_(i) {
    var l = i.stateNode, d = i.type, m = i.memoizedProps;
    switch (l[Qt] = i, l[dn] = m, d) {
      case "dialog":
        Ye("cancel", l), Ye("close", l);
        break;
      case "iframe":
      case "object":
      case "embed":
        Ye("load", l);
        break;
      case "video":
      case "audio":
        for (d = 0; d < Bu.length; d++)
          Ye(Bu[d], l);
        break;
      case "source":
        Ye("error", l);
        break;
      case "img":
      case "image":
      case "link":
        Ye("error", l), Ye("load", l);
        break;
      case "details":
        Ye("toggle", l);
        break;
      case "input":
        Ye("invalid", l), Bf(
          l,
          m.value,
          m.defaultValue,
          m.checked,
          m.defaultChecked,
          m.type,
          m.name,
          !0
        ), ls(l);
        break;
      case "select":
        Ye("invalid", l);
        break;
      case "textarea":
        Ye("invalid", l), Rw(l, m.value, m.defaultValue, m.children), ls(l);
    }
    d = m.children, typeof d != "string" && typeof d != "number" && typeof d != "bigint" || l.textContent === "" + d || m.suppressHydrationWarning === !0 || RE(l.textContent, d) ? (m.popover != null && (Ye("beforetoggle", l), Ye("toggle", l)), m.onScroll != null && Ye("scroll", l), m.onScrollEnd != null && Ye("scrollend", l), m.onClick != null && (l.onclick = jd), l = !0) : l = !1, l || wa(i);
  }
  function h_(i) {
    for (En = i.return; En; )
      switch (En.tag) {
        case 5:
        case 13:
          Yr = !1;
          return;
        case 27:
        case 3:
          Yr = !0;
          return;
        default:
          En = En.return;
      }
  }
  function mu(i) {
    if (i !== En) return !1;
    if (!rt) return h_(i), rt = !0, !1;
    var l = i.tag, d;
    if ((d = l !== 3 && l !== 27) && ((d = l === 5) && (d = i.type, d = !(d !== "form" && d !== "button") || ey(i.type, i.memoizedProps)), d = !d), d && Mt && wa(i), h_(i), l === 13) {
      if (i = i.memoizedState, i = i !== null ? i.dehydrated : null, !i) throw Error(r(317));
      e: {
        for (i = i.nextSibling, l = 0; i; ) {
          if (i.nodeType === 8)
            if (d = i.data, d === "/$") {
              if (l === 0) {
                Mt = Nr(i.nextSibling);
                break e;
              }
              l--;
            } else
              d !== "$" && d !== "$!" && d !== "$?" || l++;
          i = i.nextSibling;
        }
        Mt = null;
      }
    } else
      l === 27 ? (l = Mt, zi(i.type) ? (i = oy, oy = null, Mt = i) : Mt = l) : Mt = En ? Nr(i.stateNode.nextSibling) : null;
    return !0;
  }
  function gu() {
    Mt = En = null, rt = !1;
  }
  function p_() {
    var i = xa;
    return i !== null && (Pn === null ? Pn = i : Pn.push.apply(
      Pn,
      i
    ), xa = null), i;
  }
  function yu(i) {
    xa === null ? xa = [i] : xa.push(i);
  }
  var Fg = W(null), _a = null, Po = null;
  function _i(i, l, d) {
    L(Fg, l._currentValue), l._currentValue = d;
  }
  function Io(i) {
    i._currentValue = Fg.current, Z(Fg);
  }
  function $g(i, l, d) {
    for (; i !== null; ) {
      var m = i.alternate;
      if ((i.childLanes & l) !== l ? (i.childLanes |= l, m !== null && (m.childLanes |= l)) : m !== null && (m.childLanes & l) !== l && (m.childLanes |= l), i === d) break;
      i = i.return;
    }
  }
  function Bg(i, l, d, m) {
    var x = i.child;
    for (x !== null && (x.return = i); x !== null; ) {
      var C = x.dependencies;
      if (C !== null) {
        var D = x.child;
        C = C.firstContext;
        e: for (; C !== null; ) {
          var $ = C;
          C = x;
          for (var X = 0; X < l.length; X++)
            if ($.context === l[X]) {
              C.lanes |= d, $ = C.alternate, $ !== null && ($.lanes |= d), $g(
                C.return,
                d,
                i
              ), m || (D = null);
              break e;
            }
          C = $.next;
        }
      } else if (x.tag === 18) {
        if (D = x.return, D === null) throw Error(r(341));
        D.lanes |= d, C = D.alternate, C !== null && (C.lanes |= d), $g(D, d, i), D = null;
      } else D = x.child;
      if (D !== null) D.return = x;
      else
        for (D = x; D !== null; ) {
          if (D === i) {
            D = null;
            break;
          }
          if (x = D.sibling, x !== null) {
            x.return = D.return, D = x;
            break;
          }
          D = D.return;
        }
      x = D;
    }
  }
  function vu(i, l, d, m) {
    i = null;
    for (var x = l, C = !1; x !== null; ) {
      if (!C) {
        if ((x.flags & 524288) !== 0) C = !0;
        else if ((x.flags & 262144) !== 0) break;
      }
      if (x.tag === 10) {
        var D = x.alternate;
        if (D === null) throw Error(r(387));
        if (D = D.memoizedProps, D !== null) {
          var $ = x.type;
          Yn(x.pendingProps.value, D.value) || (i !== null ? i.push($) : i = [$]);
        }
      } else if (x === fe.current) {
        if (D = x.alternate, D === null) throw Error(r(387));
        D.memoizedState.memoizedState !== x.memoizedState.memoizedState && (i !== null ? i.push(Yu) : i = [Yu]);
      }
      x = x.return;
    }
    i !== null && Bg(
      l,
      i,
      d,
      m
    ), l.flags |= 262144;
  }
  function td(i) {
    for (i = i.firstContext; i !== null; ) {
      if (!Yn(
        i.context._currentValue,
        i.memoizedValue
      ))
        return !0;
      i = i.next;
    }
    return !1;
  }
  function Sa(i) {
    _a = i, Po = null, i = i.dependencies, i !== null && (i.firstContext = null);
  }
  function hn(i) {
    return m_(_a, i);
  }
  function nd(i, l) {
    return _a === null && Sa(i), m_(i, l);
  }
  function m_(i, l) {
    var d = l._currentValue;
    if (l = { context: l, memoizedValue: d, next: null }, Po === null) {
      if (i === null) throw Error(r(308));
      Po = l, i.dependencies = { lanes: 0, firstContext: l }, i.flags |= 524288;
    } else Po = Po.next = l;
    return d;
  }
  var WP = typeof AbortController < "u" ? AbortController : function() {
    var i = [], l = this.signal = {
      aborted: !1,
      addEventListener: function(d, m) {
        i.push(m);
      }
    };
    this.abort = function() {
      l.aborted = !0, i.forEach(function(d) {
        return d();
      });
    };
  }, XP = e.unstable_scheduleCallback, KP = e.unstable_NormalPriority, Xt = {
    $$typeof: k,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function Hg() {
    return {
      controller: new WP(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function bu(i) {
    i.refCount--, i.refCount === 0 && XP(KP, function() {
      i.controller.abort();
    });
  }
  var xu = null, Vg = 0, ws = 0, _s = null;
  function ZP(i, l) {
    if (xu === null) {
      var d = xu = [];
      Vg = 0, ws = q0(), _s = {
        status: "pending",
        value: void 0,
        then: function(m) {
          d.push(m);
        }
      };
    }
    return Vg++, l.then(g_, g_), l;
  }
  function g_() {
    if (--Vg === 0 && xu !== null) {
      _s !== null && (_s.status = "fulfilled");
      var i = xu;
      xu = null, ws = 0, _s = null;
      for (var l = 0; l < i.length; l++) (0, i[l])();
    }
  }
  function QP(i, l) {
    var d = [], m = {
      status: "pending",
      value: null,
      reason: null,
      then: function(x) {
        d.push(x);
      }
    };
    return i.then(
      function() {
        m.status = "fulfilled", m.value = l;
        for (var x = 0; x < d.length; x++) (0, d[x])(l);
      },
      function(x) {
        for (m.status = "rejected", m.reason = x, x = 0; x < d.length; x++)
          (0, d[x])(void 0);
      }
    ), m;
  }
  var y_ = I.S;
  I.S = function(i, l) {
    typeof l == "object" && l !== null && typeof l.then == "function" && ZP(i, l), y_ !== null && y_(i, l);
  };
  var Ea = W(null);
  function Ug() {
    var i = Ea.current;
    return i !== null ? i : xt.pooledCache;
  }
  function rd(i, l) {
    l === null ? L(Ea, Ea.current) : L(Ea, l.pool);
  }
  function v_() {
    var i = Ug();
    return i === null ? null : { parent: Xt._currentValue, pool: i };
  }
  var wu = Error(r(460)), b_ = Error(r(474)), od = Error(r(542)), qg = { then: function() {
  } };
  function x_(i) {
    return i = i.status, i === "fulfilled" || i === "rejected";
  }
  function id() {
  }
  function w_(i, l, d) {
    switch (d = i[d], d === void 0 ? i.push(l) : d !== l && (l.then(id, id), l = d), l.status) {
      case "fulfilled":
        return l.value;
      case "rejected":
        throw i = l.reason, S_(i), i;
      default:
        if (typeof l.status == "string") l.then(id, id);
        else {
          if (i = xt, i !== null && 100 < i.shellSuspendCounter)
            throw Error(r(482));
          i = l, i.status = "pending", i.then(
            function(m) {
              if (l.status === "pending") {
                var x = l;
                x.status = "fulfilled", x.value = m;
              }
            },
            function(m) {
              if (l.status === "pending") {
                var x = l;
                x.status = "rejected", x.reason = m;
              }
            }
          );
        }
        switch (l.status) {
          case "fulfilled":
            return l.value;
          case "rejected":
            throw i = l.reason, S_(i), i;
        }
        throw _u = l, wu;
    }
  }
  var _u = null;
  function __() {
    if (_u === null) throw Error(r(459));
    var i = _u;
    return _u = null, i;
  }
  function S_(i) {
    if (i === wu || i === od)
      throw Error(r(483));
  }
  var Si = !1;
  function Gg(i) {
    i.updateQueue = {
      baseState: i.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function Yg(i, l) {
    i = i.updateQueue, l.updateQueue === i && (l.updateQueue = {
      baseState: i.baseState,
      firstBaseUpdate: i.firstBaseUpdate,
      lastBaseUpdate: i.lastBaseUpdate,
      shared: i.shared,
      callbacks: null
    });
  }
  function Ei(i) {
    return { lane: i, tag: 0, payload: null, callback: null, next: null };
  }
  function Ci(i, l, d) {
    var m = i.updateQueue;
    if (m === null) return null;
    if (m = m.shared, (lt & 2) !== 0) {
      var x = m.pending;
      return x === null ? l.next = l : (l.next = x.next, x.next = l), m.pending = l, l = Zf(i), u_(i, null, d), l;
    }
    return Kf(i, m, l, d), Zf(i);
  }
  function Su(i, l, d) {
    if (l = l.updateQueue, l !== null && (l = l.shared, (d & 4194048) !== 0)) {
      var m = l.lanes;
      m &= i.pendingLanes, d |= m, l.lanes = d, Xl(i, d);
    }
  }
  function Wg(i, l) {
    var d = i.updateQueue, m = i.alternate;
    if (m !== null && (m = m.updateQueue, d === m)) {
      var x = null, C = null;
      if (d = d.firstBaseUpdate, d !== null) {
        do {
          var D = {
            lane: d.lane,
            tag: d.tag,
            payload: d.payload,
            callback: null,
            next: null
          };
          C === null ? x = C = D : C = C.next = D, d = d.next;
        } while (d !== null);
        C === null ? x = C = l : C = C.next = l;
      } else x = C = l;
      d = {
        baseState: m.baseState,
        firstBaseUpdate: x,
        lastBaseUpdate: C,
        shared: m.shared,
        callbacks: m.callbacks
      }, i.updateQueue = d;
      return;
    }
    i = d.lastBaseUpdate, i === null ? d.firstBaseUpdate = l : i.next = l, d.lastBaseUpdate = l;
  }
  var Xg = !1;
  function Eu() {
    if (Xg) {
      var i = _s;
      if (i !== null) throw i;
    }
  }
  function Cu(i, l, d, m) {
    Xg = !1;
    var x = i.updateQueue;
    Si = !1;
    var C = x.firstBaseUpdate, D = x.lastBaseUpdate, $ = x.shared.pending;
    if ($ !== null) {
      x.shared.pending = null;
      var X = $, ee = X.next;
      X.next = null, D === null ? C = ee : D.next = ee, D = X;
      var ue = i.alternate;
      ue !== null && (ue = ue.updateQueue, $ = ue.lastBaseUpdate, $ !== D && ($ === null ? ue.firstBaseUpdate = ee : $.next = ee, ue.lastBaseUpdate = X));
    }
    if (C !== null) {
      var de = x.baseState;
      D = 0, ue = ee = X = null, $ = C;
      do {
        var ne = $.lane & -536870913, re = ne !== $.lane;
        if (re ? (Ze & ne) === ne : (m & ne) === ne) {
          ne !== 0 && ne === ws && (Xg = !0), ue !== null && (ue = ue.next = {
            lane: 0,
            tag: $.tag,
            payload: $.payload,
            callback: null,
            next: null
          });
          e: {
            var Le = i, Pe = $;
            ne = l;
            var ht = d;
            switch (Pe.tag) {
              case 1:
                if (Le = Pe.payload, typeof Le == "function") {
                  de = Le.call(ht, de, ne);
                  break e;
                }
                de = Le;
                break e;
              case 3:
                Le.flags = Le.flags & -65537 | 128;
              case 0:
                if (Le = Pe.payload, ne = typeof Le == "function" ? Le.call(ht, de, ne) : Le, ne == null) break e;
                de = h({}, de, ne);
                break e;
              case 2:
                Si = !0;
            }
          }
          ne = $.callback, ne !== null && (i.flags |= 64, re && (i.flags |= 8192), re = x.callbacks, re === null ? x.callbacks = [ne] : re.push(ne));
        } else
          re = {
            lane: ne,
            tag: $.tag,
            payload: $.payload,
            callback: $.callback,
            next: null
          }, ue === null ? (ee = ue = re, X = de) : ue = ue.next = re, D |= ne;
        if ($ = $.next, $ === null) {
          if ($ = x.shared.pending, $ === null)
            break;
          re = $, $ = re.next, re.next = null, x.lastBaseUpdate = re, x.shared.pending = null;
        }
      } while (!0);
      ue === null && (X = de), x.baseState = X, x.firstBaseUpdate = ee, x.lastBaseUpdate = ue, C === null && (x.shared.lanes = 0), Di |= D, i.lanes = D, i.memoizedState = de;
    }
  }
  function E_(i, l) {
    if (typeof i != "function")
      throw Error(r(191, i));
    i.call(l);
  }
  function C_(i, l) {
    var d = i.callbacks;
    if (d !== null)
      for (i.callbacks = null, i = 0; i < d.length; i++)
        E_(d[i], l);
  }
  var Ss = W(null), ad = W(0);
  function k_(i, l) {
    i = Vo, L(ad, i), L(Ss, l), Vo = i | l.baseLanes;
  }
  function Kg() {
    L(ad, Vo), L(Ss, Ss.current);
  }
  function Zg() {
    Vo = ad.current, Z(Ss), Z(ad);
  }
  var ki = 0, He = null, ft = null, Ht = null, sd = !1, Es = !1, Ca = !1, ld = 0, ku = 0, Cs = null, JP = 0;
  function Pt() {
    throw Error(r(321));
  }
  function Qg(i, l) {
    if (l === null) return !1;
    for (var d = 0; d < l.length && d < i.length; d++)
      if (!Yn(i[d], l[d])) return !1;
    return !0;
  }
  function Jg(i, l, d, m, x, C) {
    return ki = C, He = l, l.memoizedState = null, l.updateQueue = null, l.lanes = 0, I.H = i === null || i.memoizedState === null ? uS : cS, Ca = !1, C = d(m, x), Ca = !1, Es && (C = A_(
      l,
      d,
      m,
      x
    )), T_(i), C;
  }
  function T_(i) {
    I.H = pd;
    var l = ft !== null && ft.next !== null;
    if (ki = 0, Ht = ft = He = null, sd = !1, ku = 0, Cs = null, l) throw Error(r(300));
    i === null || Jt || (i = i.dependencies, i !== null && td(i) && (Jt = !0));
  }
  function A_(i, l, d, m) {
    He = i;
    var x = 0;
    do {
      if (Es && (Cs = null), ku = 0, Es = !1, 25 <= x) throw Error(r(301));
      if (x += 1, Ht = ft = null, i.updateQueue != null) {
        var C = i.updateQueue;
        C.lastEffect = null, C.events = null, C.stores = null, C.memoCache != null && (C.memoCache.index = 0);
      }
      I.H = aI, C = l(d, m);
    } while (Es);
    return C;
  }
  function eI() {
    var i = I.H, l = i.useState()[0];
    return l = typeof l.then == "function" ? Tu(l) : l, i = i.useState()[0], (ft !== null ? ft.memoizedState : null) !== i && (He.flags |= 1024), l;
  }
  function e0() {
    var i = ld !== 0;
    return ld = 0, i;
  }
  function t0(i, l, d) {
    l.updateQueue = i.updateQueue, l.flags &= -2053, i.lanes &= ~d;
  }
  function n0(i) {
    if (sd) {
      for (i = i.memoizedState; i !== null; ) {
        var l = i.queue;
        l !== null && (l.pending = null), i = i.next;
      }
      sd = !1;
    }
    ki = 0, Ht = ft = He = null, Es = !1, ku = ld = 0, Cs = null;
  }
  function Dn() {
    var i = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    return Ht === null ? He.memoizedState = Ht = i : Ht = Ht.next = i, Ht;
  }
  function Vt() {
    if (ft === null) {
      var i = He.alternate;
      i = i !== null ? i.memoizedState : null;
    } else i = ft.next;
    var l = Ht === null ? He.memoizedState : Ht.next;
    if (l !== null)
      Ht = l, ft = i;
    else {
      if (i === null)
        throw He.alternate === null ? Error(r(467)) : Error(r(310));
      ft = i, i = {
        memoizedState: ft.memoizedState,
        baseState: ft.baseState,
        baseQueue: ft.baseQueue,
        queue: ft.queue,
        next: null
      }, Ht === null ? He.memoizedState = Ht = i : Ht = Ht.next = i;
    }
    return Ht;
  }
  function r0() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function Tu(i) {
    var l = ku;
    return ku += 1, Cs === null && (Cs = []), i = w_(Cs, i, l), l = He, (Ht === null ? l.memoizedState : Ht.next) === null && (l = l.alternate, I.H = l === null || l.memoizedState === null ? uS : cS), i;
  }
  function ud(i) {
    if (i !== null && typeof i == "object") {
      if (typeof i.then == "function") return Tu(i);
      if (i.$$typeof === k) return hn(i);
    }
    throw Error(r(438, String(i)));
  }
  function o0(i) {
    var l = null, d = He.updateQueue;
    if (d !== null && (l = d.memoCache), l == null) {
      var m = He.alternate;
      m !== null && (m = m.updateQueue, m !== null && (m = m.memoCache, m != null && (l = {
        data: m.data.map(function(x) {
          return x.slice();
        }),
        index: 0
      })));
    }
    if (l == null && (l = { data: [], index: 0 }), d === null && (d = r0(), He.updateQueue = d), d.memoCache = l, d = l.data[l.index], d === void 0)
      for (d = l.data[l.index] = Array(i), m = 0; m < i; m++)
        d[m] = M;
    return l.index++, d;
  }
  function zo(i, l) {
    return typeof l == "function" ? l(i) : l;
  }
  function cd(i) {
    var l = Vt();
    return i0(l, ft, i);
  }
  function i0(i, l, d) {
    var m = i.queue;
    if (m === null) throw Error(r(311));
    m.lastRenderedReducer = d;
    var x = i.baseQueue, C = m.pending;
    if (C !== null) {
      if (x !== null) {
        var D = x.next;
        x.next = C.next, C.next = D;
      }
      l.baseQueue = x = C, m.pending = null;
    }
    if (C = i.baseState, x === null) i.memoizedState = C;
    else {
      l = x.next;
      var $ = D = null, X = null, ee = l, ue = !1;
      do {
        var de = ee.lane & -536870913;
        if (de !== ee.lane ? (Ze & de) === de : (ki & de) === de) {
          var ne = ee.revertLane;
          if (ne === 0)
            X !== null && (X = X.next = {
              lane: 0,
              revertLane: 0,
              action: ee.action,
              hasEagerState: ee.hasEagerState,
              eagerState: ee.eagerState,
              next: null
            }), de === ws && (ue = !0);
          else if ((ki & ne) === ne) {
            ee = ee.next, ne === ws && (ue = !0);
            continue;
          } else
            de = {
              lane: 0,
              revertLane: ee.revertLane,
              action: ee.action,
              hasEagerState: ee.hasEagerState,
              eagerState: ee.eagerState,
              next: null
            }, X === null ? ($ = X = de, D = C) : X = X.next = de, He.lanes |= ne, Di |= ne;
          de = ee.action, Ca && d(C, de), C = ee.hasEagerState ? ee.eagerState : d(C, de);
        } else
          ne = {
            lane: de,
            revertLane: ee.revertLane,
            action: ee.action,
            hasEagerState: ee.hasEagerState,
            eagerState: ee.eagerState,
            next: null
          }, X === null ? ($ = X = ne, D = C) : X = X.next = ne, He.lanes |= de, Di |= de;
        ee = ee.next;
      } while (ee !== null && ee !== l);
      if (X === null ? D = C : X.next = $, !Yn(C, i.memoizedState) && (Jt = !0, ue && (d = _s, d !== null)))
        throw d;
      i.memoizedState = C, i.baseState = D, i.baseQueue = X, m.lastRenderedState = C;
    }
    return x === null && (m.lanes = 0), [i.memoizedState, m.dispatch];
  }
  function a0(i) {
    var l = Vt(), d = l.queue;
    if (d === null) throw Error(r(311));
    d.lastRenderedReducer = i;
    var m = d.dispatch, x = d.pending, C = l.memoizedState;
    if (x !== null) {
      d.pending = null;
      var D = x = x.next;
      do
        C = i(C, D.action), D = D.next;
      while (D !== x);
      Yn(C, l.memoizedState) || (Jt = !0), l.memoizedState = C, l.baseQueue === null && (l.baseState = C), d.lastRenderedState = C;
    }
    return [C, m];
  }
  function R_(i, l, d) {
    var m = He, x = Vt(), C = rt;
    if (C) {
      if (d === void 0) throw Error(r(407));
      d = d();
    } else d = l();
    var D = !Yn(
      (ft || x).memoizedState,
      d
    );
    D && (x.memoizedState = d, Jt = !0), x = x.queue;
    var $ = N_.bind(null, m, x, i);
    if (Au(2048, 8, $, [i]), x.getSnapshot !== l || D || Ht !== null && Ht.memoizedState.tag & 1) {
      if (m.flags |= 2048, ks(
        9,
        fd(),
        O_.bind(
          null,
          m,
          x,
          d,
          l
        ),
        null
      ), xt === null) throw Error(r(349));
      C || (ki & 124) !== 0 || M_(m, l, d);
    }
    return d;
  }
  function M_(i, l, d) {
    i.flags |= 16384, i = { getSnapshot: l, value: d }, l = He.updateQueue, l === null ? (l = r0(), He.updateQueue = l, l.stores = [i]) : (d = l.stores, d === null ? l.stores = [i] : d.push(i));
  }
  function O_(i, l, d, m) {
    l.value = d, l.getSnapshot = m, D_(l) && j_(i);
  }
  function N_(i, l, d) {
    return d(function() {
      D_(l) && j_(i);
    });
  }
  function D_(i) {
    var l = i.getSnapshot;
    i = i.value;
    try {
      var d = l();
      return !Yn(i, d);
    } catch {
      return !0;
    }
  }
  function j_(i) {
    var l = ys(i, 2);
    l !== null && Jn(l, i, 2);
  }
  function s0(i) {
    var l = Dn();
    if (typeof i == "function") {
      var d = i;
      if (i = d(), Ca) {
        ke(!0);
        try {
          d();
        } finally {
          ke(!1);
        }
      }
    }
    return l.memoizedState = l.baseState = i, l.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: zo,
      lastRenderedState: i
    }, l;
  }
  function P_(i, l, d, m) {
    return i.baseState = d, i0(
      i,
      ft,
      typeof m == "function" ? m : zo
    );
  }
  function tI(i, l, d, m, x) {
    if (hd(i)) throw Error(r(485));
    if (i = l.action, i !== null) {
      var C = {
        payload: x,
        action: i,
        next: null,
        isTransition: !0,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(D) {
          C.listeners.push(D);
        }
      };
      I.T !== null ? d(!0) : C.isTransition = !1, m(C), d = l.pending, d === null ? (C.next = l.pending = C, I_(l, C)) : (C.next = d.next, l.pending = d.next = C);
    }
  }
  function I_(i, l) {
    var d = l.action, m = l.payload, x = i.state;
    if (l.isTransition) {
      var C = I.T, D = {};
      I.T = D;
      try {
        var $ = d(x, m), X = I.S;
        X !== null && X(D, $), z_(i, l, $);
      } catch (ee) {
        l0(i, l, ee);
      } finally {
        I.T = C;
      }
    } else
      try {
        C = d(x, m), z_(i, l, C);
      } catch (ee) {
        l0(i, l, ee);
      }
  }
  function z_(i, l, d) {
    d !== null && typeof d == "object" && typeof d.then == "function" ? d.then(
      function(m) {
        L_(i, l, m);
      },
      function(m) {
        return l0(i, l, m);
      }
    ) : L_(i, l, d);
  }
  function L_(i, l, d) {
    l.status = "fulfilled", l.value = d, F_(l), i.state = d, l = i.pending, l !== null && (d = l.next, d === l ? i.pending = null : (d = d.next, l.next = d, I_(i, d)));
  }
  function l0(i, l, d) {
    var m = i.pending;
    if (i.pending = null, m !== null) {
      m = m.next;
      do
        l.status = "rejected", l.reason = d, F_(l), l = l.next;
      while (l !== m);
    }
    i.action = null;
  }
  function F_(i) {
    i = i.listeners;
    for (var l = 0; l < i.length; l++) (0, i[l])();
  }
  function $_(i, l) {
    return l;
  }
  function B_(i, l) {
    if (rt) {
      var d = xt.formState;
      if (d !== null) {
        e: {
          var m = He;
          if (rt) {
            if (Mt) {
              t: {
                for (var x = Mt, C = Yr; x.nodeType !== 8; ) {
                  if (!C) {
                    x = null;
                    break t;
                  }
                  if (x = Nr(
                    x.nextSibling
                  ), x === null) {
                    x = null;
                    break t;
                  }
                }
                C = x.data, x = C === "F!" || C === "F" ? x : null;
              }
              if (x) {
                Mt = Nr(
                  x.nextSibling
                ), m = x.data === "F!";
                break e;
              }
            }
            wa(m);
          }
          m = !1;
        }
        m && (l = d[0]);
      }
    }
    return d = Dn(), d.memoizedState = d.baseState = l, m = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: $_,
      lastRenderedState: l
    }, d.queue = m, d = aS.bind(
      null,
      He,
      m
    ), m.dispatch = d, m = s0(!1), C = h0.bind(
      null,
      He,
      !1,
      m.queue
    ), m = Dn(), x = {
      state: l,
      dispatch: null,
      action: i,
      pending: null
    }, m.queue = x, d = tI.bind(
      null,
      He,
      x,
      C,
      d
    ), x.dispatch = d, m.memoizedState = i, [l, d, !1];
  }
  function H_(i) {
    var l = Vt();
    return V_(l, ft, i);
  }
  function V_(i, l, d) {
    if (l = i0(
      i,
      l,
      $_
    )[0], i = cd(zo)[0], typeof l == "object" && l !== null && typeof l.then == "function")
      try {
        var m = Tu(l);
      } catch (D) {
        throw D === wu ? od : D;
      }
    else m = l;
    l = Vt();
    var x = l.queue, C = x.dispatch;
    return d !== l.memoizedState && (He.flags |= 2048, ks(
      9,
      fd(),
      nI.bind(null, x, d),
      null
    )), [m, C, i];
  }
  function nI(i, l) {
    i.action = l;
  }
  function U_(i) {
    var l = Vt(), d = ft;
    if (d !== null)
      return V_(l, d, i);
    Vt(), l = l.memoizedState, d = Vt();
    var m = d.queue.dispatch;
    return d.memoizedState = i, [l, m, !1];
  }
  function ks(i, l, d, m) {
    return i = { tag: i, create: d, deps: m, inst: l, next: null }, l = He.updateQueue, l === null && (l = r0(), He.updateQueue = l), d = l.lastEffect, d === null ? l.lastEffect = i.next = i : (m = d.next, d.next = i, i.next = m, l.lastEffect = i), i;
  }
  function fd() {
    return { destroy: void 0, resource: void 0 };
  }
  function q_() {
    return Vt().memoizedState;
  }
  function dd(i, l, d, m) {
    var x = Dn();
    m = m === void 0 ? null : m, He.flags |= i, x.memoizedState = ks(
      1 | l,
      fd(),
      d,
      m
    );
  }
  function Au(i, l, d, m) {
    var x = Vt();
    m = m === void 0 ? null : m;
    var C = x.memoizedState.inst;
    ft !== null && m !== null && Qg(m, ft.memoizedState.deps) ? x.memoizedState = ks(l, C, d, m) : (He.flags |= i, x.memoizedState = ks(
      1 | l,
      C,
      d,
      m
    ));
  }
  function G_(i, l) {
    dd(8390656, 8, i, l);
  }
  function Y_(i, l) {
    Au(2048, 8, i, l);
  }
  function W_(i, l) {
    return Au(4, 2, i, l);
  }
  function X_(i, l) {
    return Au(4, 4, i, l);
  }
  function K_(i, l) {
    if (typeof l == "function") {
      i = i();
      var d = l(i);
      return function() {
        typeof d == "function" ? d() : l(null);
      };
    }
    if (l != null)
      return i = i(), l.current = i, function() {
        l.current = null;
      };
  }
  function Z_(i, l, d) {
    d = d != null ? d.concat([i]) : null, Au(4, 4, K_.bind(null, l, i), d);
  }
  function u0() {
  }
  function Q_(i, l) {
    var d = Vt();
    l = l === void 0 ? null : l;
    var m = d.memoizedState;
    return l !== null && Qg(l, m[1]) ? m[0] : (d.memoizedState = [i, l], i);
  }
  function J_(i, l) {
    var d = Vt();
    l = l === void 0 ? null : l;
    var m = d.memoizedState;
    if (l !== null && Qg(l, m[1]))
      return m[0];
    if (m = i(), Ca) {
      ke(!0);
      try {
        i();
      } finally {
        ke(!1);
      }
    }
    return d.memoizedState = [m, l], m;
  }
  function c0(i, l, d) {
    return d === void 0 || (ki & 1073741824) !== 0 ? i.memoizedState = l : (i.memoizedState = d, i = nE(), He.lanes |= i, Di |= i, d);
  }
  function eS(i, l, d, m) {
    return Yn(d, l) ? d : Ss.current !== null ? (i = c0(i, d, m), Yn(i, l) || (Jt = !0), i) : (ki & 42) === 0 ? (Jt = !0, i.memoizedState = d) : (i = nE(), He.lanes |= i, Di |= i, l);
  }
  function tS(i, l, d, m, x) {
    var C = U.p;
    U.p = C !== 0 && 8 > C ? C : 8;
    var D = I.T, $ = {};
    I.T = $, h0(i, !1, l, d);
    try {
      var X = x(), ee = I.S;
      if (ee !== null && ee($, X), X !== null && typeof X == "object" && typeof X.then == "function") {
        var ue = QP(
          X,
          m
        );
        Ru(
          i,
          l,
          ue,
          Qn(i)
        );
      } else
        Ru(
          i,
          l,
          m,
          Qn(i)
        );
    } catch (de) {
      Ru(
        i,
        l,
        { then: function() {
        }, status: "rejected", reason: de },
        Qn()
      );
    } finally {
      U.p = C, I.T = D;
    }
  }
  function rI() {
  }
  function f0(i, l, d, m) {
    if (i.tag !== 5) throw Error(r(476));
    var x = nS(i).queue;
    tS(
      i,
      x,
      l,
      H,
      d === null ? rI : function() {
        return rS(i), d(m);
      }
    );
  }
  function nS(i) {
    var l = i.memoizedState;
    if (l !== null) return l;
    l = {
      memoizedState: H,
      baseState: H,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: zo,
        lastRenderedState: H
      },
      next: null
    };
    var d = {};
    return l.next = {
      memoizedState: d,
      baseState: d,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: zo,
        lastRenderedState: d
      },
      next: null
    }, i.memoizedState = l, i = i.alternate, i !== null && (i.memoizedState = l), l;
  }
  function rS(i) {
    var l = nS(i).next.queue;
    Ru(i, l, {}, Qn());
  }
  function d0() {
    return hn(Yu);
  }
  function oS() {
    return Vt().memoizedState;
  }
  function iS() {
    return Vt().memoizedState;
  }
  function oI(i) {
    for (var l = i.return; l !== null; ) {
      switch (l.tag) {
        case 24:
        case 3:
          var d = Qn();
          i = Ei(d);
          var m = Ci(l, i, d);
          m !== null && (Jn(m, l, d), Su(m, l, d)), l = { cache: Hg() }, i.payload = l;
          return;
      }
      l = l.return;
    }
  }
  function iI(i, l, d) {
    var m = Qn();
    d = {
      lane: m,
      revertLane: 0,
      action: d,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, hd(i) ? sS(l, d) : (d = Ng(i, l, d, m), d !== null && (Jn(d, i, m), lS(d, l, m)));
  }
  function aS(i, l, d) {
    var m = Qn();
    Ru(i, l, d, m);
  }
  function Ru(i, l, d, m) {
    var x = {
      lane: m,
      revertLane: 0,
      action: d,
      hasEagerState: !1,
      eagerState: null,
      next: null
    };
    if (hd(i)) sS(l, x);
    else {
      var C = i.alternate;
      if (i.lanes === 0 && (C === null || C.lanes === 0) && (C = l.lastRenderedReducer, C !== null))
        try {
          var D = l.lastRenderedState, $ = C(D, d);
          if (x.hasEagerState = !0, x.eagerState = $, Yn($, D))
            return Kf(i, l, x, 0), xt === null && Xf(), !1;
        } catch {
        } finally {
        }
      if (d = Ng(i, l, x, m), d !== null)
        return Jn(d, i, m), lS(d, l, m), !0;
    }
    return !1;
  }
  function h0(i, l, d, m) {
    if (m = {
      lane: 2,
      revertLane: q0(),
      action: m,
      hasEagerState: !1,
      eagerState: null,
      next: null
    }, hd(i)) {
      if (l) throw Error(r(479));
    } else
      l = Ng(
        i,
        d,
        m,
        2
      ), l !== null && Jn(l, i, 2);
  }
  function hd(i) {
    var l = i.alternate;
    return i === He || l !== null && l === He;
  }
  function sS(i, l) {
    Es = sd = !0;
    var d = i.pending;
    d === null ? l.next = l : (l.next = d.next, d.next = l), i.pending = l;
  }
  function lS(i, l, d) {
    if ((d & 4194048) !== 0) {
      var m = l.lanes;
      m &= i.pendingLanes, d |= m, l.lanes = d, Xl(i, d);
    }
  }
  var pd = {
    readContext: hn,
    use: ud,
    useCallback: Pt,
    useContext: Pt,
    useEffect: Pt,
    useImperativeHandle: Pt,
    useLayoutEffect: Pt,
    useInsertionEffect: Pt,
    useMemo: Pt,
    useReducer: Pt,
    useRef: Pt,
    useState: Pt,
    useDebugValue: Pt,
    useDeferredValue: Pt,
    useTransition: Pt,
    useSyncExternalStore: Pt,
    useId: Pt,
    useHostTransitionStatus: Pt,
    useFormState: Pt,
    useActionState: Pt,
    useOptimistic: Pt,
    useMemoCache: Pt,
    useCacheRefresh: Pt
  }, uS = {
    readContext: hn,
    use: ud,
    useCallback: function(i, l) {
      return Dn().memoizedState = [
        i,
        l === void 0 ? null : l
      ], i;
    },
    useContext: hn,
    useEffect: G_,
    useImperativeHandle: function(i, l, d) {
      d = d != null ? d.concat([i]) : null, dd(
        4194308,
        4,
        K_.bind(null, l, i),
        d
      );
    },
    useLayoutEffect: function(i, l) {
      return dd(4194308, 4, i, l);
    },
    useInsertionEffect: function(i, l) {
      dd(4, 2, i, l);
    },
    useMemo: function(i, l) {
      var d = Dn();
      l = l === void 0 ? null : l;
      var m = i();
      if (Ca) {
        ke(!0);
        try {
          i();
        } finally {
          ke(!1);
        }
      }
      return d.memoizedState = [m, l], m;
    },
    useReducer: function(i, l, d) {
      var m = Dn();
      if (d !== void 0) {
        var x = d(l);
        if (Ca) {
          ke(!0);
          try {
            d(l);
          } finally {
            ke(!1);
          }
        }
      } else x = l;
      return m.memoizedState = m.baseState = x, i = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: i,
        lastRenderedState: x
      }, m.queue = i, i = i.dispatch = iI.bind(
        null,
        He,
        i
      ), [m.memoizedState, i];
    },
    useRef: function(i) {
      var l = Dn();
      return i = { current: i }, l.memoizedState = i;
    },
    useState: function(i) {
      i = s0(i);
      var l = i.queue, d = aS.bind(null, He, l);
      return l.dispatch = d, [i.memoizedState, d];
    },
    useDebugValue: u0,
    useDeferredValue: function(i, l) {
      var d = Dn();
      return c0(d, i, l);
    },
    useTransition: function() {
      var i = s0(!1);
      return i = tS.bind(
        null,
        He,
        i.queue,
        !0,
        !1
      ), Dn().memoizedState = i, [!1, i];
    },
    useSyncExternalStore: function(i, l, d) {
      var m = He, x = Dn();
      if (rt) {
        if (d === void 0)
          throw Error(r(407));
        d = d();
      } else {
        if (d = l(), xt === null)
          throw Error(r(349));
        (Ze & 124) !== 0 || M_(m, l, d);
      }
      x.memoizedState = d;
      var C = { value: d, getSnapshot: l };
      return x.queue = C, G_(N_.bind(null, m, C, i), [
        i
      ]), m.flags |= 2048, ks(
        9,
        fd(),
        O_.bind(
          null,
          m,
          C,
          d,
          l
        ),
        null
      ), d;
    },
    useId: function() {
      var i = Dn(), l = xt.identifierPrefix;
      if (rt) {
        var d = jo, m = Do;
        d = (m & ~(1 << 32 - je(m) - 1)).toString(32) + d, l = "" + l + "R" + d, d = ld++, 0 < d && (l += "H" + d.toString(32)), l += "";
      } else
        d = JP++, l = "" + l + "r" + d.toString(32) + "";
      return i.memoizedState = l;
    },
    useHostTransitionStatus: d0,
    useFormState: B_,
    useActionState: B_,
    useOptimistic: function(i) {
      var l = Dn();
      l.memoizedState = l.baseState = i;
      var d = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      return l.queue = d, l = h0.bind(
        null,
        He,
        !0,
        d
      ), d.dispatch = l, [i, l];
    },
    useMemoCache: o0,
    useCacheRefresh: function() {
      return Dn().memoizedState = oI.bind(
        null,
        He
      );
    }
  }, cS = {
    readContext: hn,
    use: ud,
    useCallback: Q_,
    useContext: hn,
    useEffect: Y_,
    useImperativeHandle: Z_,
    useInsertionEffect: W_,
    useLayoutEffect: X_,
    useMemo: J_,
    useReducer: cd,
    useRef: q_,
    useState: function() {
      return cd(zo);
    },
    useDebugValue: u0,
    useDeferredValue: function(i, l) {
      var d = Vt();
      return eS(
        d,
        ft.memoizedState,
        i,
        l
      );
    },
    useTransition: function() {
      var i = cd(zo)[0], l = Vt().memoizedState;
      return [
        typeof i == "boolean" ? i : Tu(i),
        l
      ];
    },
    useSyncExternalStore: R_,
    useId: oS,
    useHostTransitionStatus: d0,
    useFormState: H_,
    useActionState: H_,
    useOptimistic: function(i, l) {
      var d = Vt();
      return P_(d, ft, i, l);
    },
    useMemoCache: o0,
    useCacheRefresh: iS
  }, aI = {
    readContext: hn,
    use: ud,
    useCallback: Q_,
    useContext: hn,
    useEffect: Y_,
    useImperativeHandle: Z_,
    useInsertionEffect: W_,
    useLayoutEffect: X_,
    useMemo: J_,
    useReducer: a0,
    useRef: q_,
    useState: function() {
      return a0(zo);
    },
    useDebugValue: u0,
    useDeferredValue: function(i, l) {
      var d = Vt();
      return ft === null ? c0(d, i, l) : eS(
        d,
        ft.memoizedState,
        i,
        l
      );
    },
    useTransition: function() {
      var i = a0(zo)[0], l = Vt().memoizedState;
      return [
        typeof i == "boolean" ? i : Tu(i),
        l
      ];
    },
    useSyncExternalStore: R_,
    useId: oS,
    useHostTransitionStatus: d0,
    useFormState: U_,
    useActionState: U_,
    useOptimistic: function(i, l) {
      var d = Vt();
      return ft !== null ? P_(d, ft, i, l) : (d.baseState = i, [i, d.queue.dispatch]);
    },
    useMemoCache: o0,
    useCacheRefresh: iS
  }, Ts = null, Mu = 0;
  function md(i) {
    var l = Mu;
    return Mu += 1, Ts === null && (Ts = []), w_(Ts, i, l);
  }
  function Ou(i, l) {
    l = l.props.ref, i.ref = l !== void 0 ? l : null;
  }
  function gd(i, l) {
    throw l.$$typeof === p ? Error(r(525)) : (i = Object.prototype.toString.call(l), Error(
      r(
        31,
        i === "[object Object]" ? "object with keys {" + Object.keys(l).join(", ") + "}" : i
      )
    ));
  }
  function fS(i) {
    var l = i._init;
    return l(i._payload);
  }
  function dS(i) {
    function l(Q, K) {
      if (i) {
        var J = Q.deletions;
        J === null ? (Q.deletions = [K], Q.flags |= 16) : J.push(K);
      }
    }
    function d(Q, K) {
      if (!i) return null;
      for (; K !== null; )
        l(Q, K), K = K.sibling;
      return null;
    }
    function m(Q) {
      for (var K = /* @__PURE__ */ new Map(); Q !== null; )
        Q.key !== null ? K.set(Q.key, Q) : K.set(Q.index, Q), Q = Q.sibling;
      return K;
    }
    function x(Q, K) {
      return Q = No(Q, K), Q.index = 0, Q.sibling = null, Q;
    }
    function C(Q, K, J) {
      return Q.index = J, i ? (J = Q.alternate, J !== null ? (J = J.index, J < K ? (Q.flags |= 67108866, K) : J) : (Q.flags |= 67108866, K)) : (Q.flags |= 1048576, K);
    }
    function D(Q) {
      return i && Q.alternate === null && (Q.flags |= 67108866), Q;
    }
    function $(Q, K, J, ce) {
      return K === null || K.tag !== 6 ? (K = jg(J, Q.mode, ce), K.return = Q, K) : (K = x(K, J), K.return = Q, K);
    }
    function X(Q, K, J, ce) {
      var be = J.type;
      return be === w ? ue(
        Q,
        K,
        J.props.children,
        ce,
        J.key
      ) : K !== null && (K.elementType === be || typeof be == "object" && be !== null && be.$$typeof === z && fS(be) === K.type) ? (K = x(K, J.props), Ou(K, J), K.return = Q, K) : (K = Qf(
        J.type,
        J.key,
        J.props,
        null,
        Q.mode,
        ce
      ), Ou(K, J), K.return = Q, K);
    }
    function ee(Q, K, J, ce) {
      return K === null || K.tag !== 4 || K.stateNode.containerInfo !== J.containerInfo || K.stateNode.implementation !== J.implementation ? (K = Pg(J, Q.mode, ce), K.return = Q, K) : (K = x(K, J.children || []), K.return = Q, K);
    }
    function ue(Q, K, J, ce, be) {
      return K === null || K.tag !== 7 ? (K = ya(
        J,
        Q.mode,
        ce,
        be
      ), K.return = Q, K) : (K = x(K, J), K.return = Q, K);
    }
    function de(Q, K, J) {
      if (typeof K == "string" && K !== "" || typeof K == "number" || typeof K == "bigint")
        return K = jg(
          "" + K,
          Q.mode,
          J
        ), K.return = Q, K;
      if (typeof K == "object" && K !== null) {
        switch (K.$$typeof) {
          case g:
            return J = Qf(
              K.type,
              K.key,
              K.props,
              null,
              Q.mode,
              J
            ), Ou(J, K), J.return = Q, J;
          case y:
            return K = Pg(
              K,
              Q.mode,
              J
            ), K.return = Q, K;
          case z:
            var ce = K._init;
            return K = ce(K._payload), de(Q, K, J);
        }
        if (V(K) || q(K))
          return K = ya(
            K,
            Q.mode,
            J,
            null
          ), K.return = Q, K;
        if (typeof K.then == "function")
          return de(Q, md(K), J);
        if (K.$$typeof === k)
          return de(
            Q,
            nd(Q, K),
            J
          );
        gd(Q, K);
      }
      return null;
    }
    function ne(Q, K, J, ce) {
      var be = K !== null ? K.key : null;
      if (typeof J == "string" && J !== "" || typeof J == "number" || typeof J == "bigint")
        return be !== null ? null : $(Q, K, "" + J, ce);
      if (typeof J == "object" && J !== null) {
        switch (J.$$typeof) {
          case g:
            return J.key === be ? X(Q, K, J, ce) : null;
          case y:
            return J.key === be ? ee(Q, K, J, ce) : null;
          case z:
            return be = J._init, J = be(J._payload), ne(Q, K, J, ce);
        }
        if (V(J) || q(J))
          return be !== null ? null : ue(Q, K, J, ce, null);
        if (typeof J.then == "function")
          return ne(
            Q,
            K,
            md(J),
            ce
          );
        if (J.$$typeof === k)
          return ne(
            Q,
            K,
            nd(Q, J),
            ce
          );
        gd(Q, J);
      }
      return null;
    }
    function re(Q, K, J, ce, be) {
      if (typeof ce == "string" && ce !== "" || typeof ce == "number" || typeof ce == "bigint")
        return Q = Q.get(J) || null, $(K, Q, "" + ce, be);
      if (typeof ce == "object" && ce !== null) {
        switch (ce.$$typeof) {
          case g:
            return Q = Q.get(
              ce.key === null ? J : ce.key
            ) || null, X(K, Q, ce, be);
          case y:
            return Q = Q.get(
              ce.key === null ? J : ce.key
            ) || null, ee(K, Q, ce, be);
          case z:
            var Ue = ce._init;
            return ce = Ue(ce._payload), re(
              Q,
              K,
              J,
              ce,
              be
            );
        }
        if (V(ce) || q(ce))
          return Q = Q.get(J) || null, ue(K, Q, ce, be, null);
        if (typeof ce.then == "function")
          return re(
            Q,
            K,
            J,
            md(ce),
            be
          );
        if (ce.$$typeof === k)
          return re(
            Q,
            K,
            J,
            nd(K, ce),
            be
          );
        gd(K, ce);
      }
      return null;
    }
    function Le(Q, K, J, ce) {
      for (var be = null, Ue = null, Se = K, Ie = K = 0, tn = null; Se !== null && Ie < J.length; Ie++) {
        Se.index > Ie ? (tn = Se, Se = null) : tn = Se.sibling;
        var nt = ne(
          Q,
          Se,
          J[Ie],
          ce
        );
        if (nt === null) {
          Se === null && (Se = tn);
          break;
        }
        i && Se && nt.alternate === null && l(Q, Se), K = C(nt, K, Ie), Ue === null ? be = nt : Ue.sibling = nt, Ue = nt, Se = tn;
      }
      if (Ie === J.length)
        return d(Q, Se), rt && ba(Q, Ie), be;
      if (Se === null) {
        for (; Ie < J.length; Ie++)
          Se = de(Q, J[Ie], ce), Se !== null && (K = C(
            Se,
            K,
            Ie
          ), Ue === null ? be = Se : Ue.sibling = Se, Ue = Se);
        return rt && ba(Q, Ie), be;
      }
      for (Se = m(Se); Ie < J.length; Ie++)
        tn = re(
          Se,
          Q,
          Ie,
          J[Ie],
          ce
        ), tn !== null && (i && tn.alternate !== null && Se.delete(
          tn.key === null ? Ie : tn.key
        ), K = C(
          tn,
          K,
          Ie
        ), Ue === null ? be = tn : Ue.sibling = tn, Ue = tn);
      return i && Se.forEach(function(Hi) {
        return l(Q, Hi);
      }), rt && ba(Q, Ie), be;
    }
    function Pe(Q, K, J, ce) {
      if (J == null) throw Error(r(151));
      for (var be = null, Ue = null, Se = K, Ie = K = 0, tn = null, nt = J.next(); Se !== null && !nt.done; Ie++, nt = J.next()) {
        Se.index > Ie ? (tn = Se, Se = null) : tn = Se.sibling;
        var Hi = ne(Q, Se, nt.value, ce);
        if (Hi === null) {
          Se === null && (Se = tn);
          break;
        }
        i && Se && Hi.alternate === null && l(Q, Se), K = C(Hi, K, Ie), Ue === null ? be = Hi : Ue.sibling = Hi, Ue = Hi, Se = tn;
      }
      if (nt.done)
        return d(Q, Se), rt && ba(Q, Ie), be;
      if (Se === null) {
        for (; !nt.done; Ie++, nt = J.next())
          nt = de(Q, nt.value, ce), nt !== null && (K = C(nt, K, Ie), Ue === null ? be = nt : Ue.sibling = nt, Ue = nt);
        return rt && ba(Q, Ie), be;
      }
      for (Se = m(Se); !nt.done; Ie++, nt = J.next())
        nt = re(Se, Q, Ie, nt.value, ce), nt !== null && (i && nt.alternate !== null && Se.delete(nt.key === null ? Ie : nt.key), K = C(nt, K, Ie), Ue === null ? be = nt : Ue.sibling = nt, Ue = nt);
      return i && Se.forEach(function(s6) {
        return l(Q, s6);
      }), rt && ba(Q, Ie), be;
    }
    function ht(Q, K, J, ce) {
      if (typeof J == "object" && J !== null && J.type === w && J.key === null && (J = J.props.children), typeof J == "object" && J !== null) {
        switch (J.$$typeof) {
          case g:
            e: {
              for (var be = J.key; K !== null; ) {
                if (K.key === be) {
                  if (be = J.type, be === w) {
                    if (K.tag === 7) {
                      d(
                        Q,
                        K.sibling
                      ), ce = x(
                        K,
                        J.props.children
                      ), ce.return = Q, Q = ce;
                      break e;
                    }
                  } else if (K.elementType === be || typeof be == "object" && be !== null && be.$$typeof === z && fS(be) === K.type) {
                    d(
                      Q,
                      K.sibling
                    ), ce = x(K, J.props), Ou(ce, J), ce.return = Q, Q = ce;
                    break e;
                  }
                  d(Q, K);
                  break;
                } else l(Q, K);
                K = K.sibling;
              }
              J.type === w ? (ce = ya(
                J.props.children,
                Q.mode,
                ce,
                J.key
              ), ce.return = Q, Q = ce) : (ce = Qf(
                J.type,
                J.key,
                J.props,
                null,
                Q.mode,
                ce
              ), Ou(ce, J), ce.return = Q, Q = ce);
            }
            return D(Q);
          case y:
            e: {
              for (be = J.key; K !== null; ) {
                if (K.key === be)
                  if (K.tag === 4 && K.stateNode.containerInfo === J.containerInfo && K.stateNode.implementation === J.implementation) {
                    d(
                      Q,
                      K.sibling
                    ), ce = x(K, J.children || []), ce.return = Q, Q = ce;
                    break e;
                  } else {
                    d(Q, K);
                    break;
                  }
                else l(Q, K);
                K = K.sibling;
              }
              ce = Pg(J, Q.mode, ce), ce.return = Q, Q = ce;
            }
            return D(Q);
          case z:
            return be = J._init, J = be(J._payload), ht(
              Q,
              K,
              J,
              ce
            );
        }
        if (V(J))
          return Le(
            Q,
            K,
            J,
            ce
          );
        if (q(J)) {
          if (be = q(J), typeof be != "function") throw Error(r(150));
          return J = be.call(J), Pe(
            Q,
            K,
            J,
            ce
          );
        }
        if (typeof J.then == "function")
          return ht(
            Q,
            K,
            md(J),
            ce
          );
        if (J.$$typeof === k)
          return ht(
            Q,
            K,
            nd(Q, J),
            ce
          );
        gd(Q, J);
      }
      return typeof J == "string" && J !== "" || typeof J == "number" || typeof J == "bigint" ? (J = "" + J, K !== null && K.tag === 6 ? (d(Q, K.sibling), ce = x(K, J), ce.return = Q, Q = ce) : (d(Q, K), ce = jg(J, Q.mode, ce), ce.return = Q, Q = ce), D(Q)) : d(Q, K);
    }
    return function(Q, K, J, ce) {
      try {
        Mu = 0;
        var be = ht(
          Q,
          K,
          J,
          ce
        );
        return Ts = null, be;
      } catch (Se) {
        if (Se === wu || Se === od) throw Se;
        var Ue = Wn(29, Se, null, Q.mode);
        return Ue.lanes = ce, Ue.return = Q, Ue;
      } finally {
      }
    };
  }
  var As = dS(!0), hS = dS(!1), yr = W(null), Wr = null;
  function Ti(i) {
    var l = i.alternate;
    L(Kt, Kt.current & 1), L(yr, i), Wr === null && (l === null || Ss.current !== null || l.memoizedState !== null) && (Wr = i);
  }
  function pS(i) {
    if (i.tag === 22) {
      if (L(Kt, Kt.current), L(yr, i), Wr === null) {
        var l = i.alternate;
        l !== null && l.memoizedState !== null && (Wr = i);
      }
    } else Ai();
  }
  function Ai() {
    L(Kt, Kt.current), L(yr, yr.current);
  }
  function Lo(i) {
    Z(yr), Wr === i && (Wr = null), Z(Kt);
  }
  var Kt = W(0);
  function yd(i) {
    for (var l = i; l !== null; ) {
      if (l.tag === 13) {
        var d = l.memoizedState;
        if (d !== null && (d = d.dehydrated, d === null || d.data === "$?" || ry(d)))
          return l;
      } else if (l.tag === 19 && l.memoizedProps.revealOrder !== void 0) {
        if ((l.flags & 128) !== 0) return l;
      } else if (l.child !== null) {
        l.child.return = l, l = l.child;
        continue;
      }
      if (l === i) break;
      for (; l.sibling === null; ) {
        if (l.return === null || l.return === i) return null;
        l = l.return;
      }
      l.sibling.return = l.return, l = l.sibling;
    }
    return null;
  }
  function p0(i, l, d, m) {
    l = i.memoizedState, d = d(m, l), d = d == null ? l : h({}, l, d), i.memoizedState = d, i.lanes === 0 && (i.updateQueue.baseState = d);
  }
  var m0 = {
    enqueueSetState: function(i, l, d) {
      i = i._reactInternals;
      var m = Qn(), x = Ei(m);
      x.payload = l, d != null && (x.callback = d), l = Ci(i, x, m), l !== null && (Jn(l, i, m), Su(l, i, m));
    },
    enqueueReplaceState: function(i, l, d) {
      i = i._reactInternals;
      var m = Qn(), x = Ei(m);
      x.tag = 1, x.payload = l, d != null && (x.callback = d), l = Ci(i, x, m), l !== null && (Jn(l, i, m), Su(l, i, m));
    },
    enqueueForceUpdate: function(i, l) {
      i = i._reactInternals;
      var d = Qn(), m = Ei(d);
      m.tag = 2, l != null && (m.callback = l), l = Ci(i, m, d), l !== null && (Jn(l, i, d), Su(l, i, d));
    }
  };
  function mS(i, l, d, m, x, C, D) {
    return i = i.stateNode, typeof i.shouldComponentUpdate == "function" ? i.shouldComponentUpdate(m, C, D) : l.prototype && l.prototype.isPureReactComponent ? !hu(d, m) || !hu(x, C) : !0;
  }
  function gS(i, l, d, m) {
    i = l.state, typeof l.componentWillReceiveProps == "function" && l.componentWillReceiveProps(d, m), typeof l.UNSAFE_componentWillReceiveProps == "function" && l.UNSAFE_componentWillReceiveProps(d, m), l.state !== i && m0.enqueueReplaceState(l, l.state, null);
  }
  function ka(i, l) {
    var d = l;
    if ("ref" in l) {
      d = {};
      for (var m in l)
        m !== "ref" && (d[m] = l[m]);
    }
    if (i = i.defaultProps) {
      d === l && (d = h({}, d));
      for (var x in i)
        d[x] === void 0 && (d[x] = i[x]);
    }
    return d;
  }
  var vd = typeof reportError == "function" ? reportError : function(i) {
    if (typeof window == "object" && typeof window.ErrorEvent == "function") {
      var l = new window.ErrorEvent("error", {
        bubbles: !0,
        cancelable: !0,
        message: typeof i == "object" && i !== null && typeof i.message == "string" ? String(i.message) : String(i),
        error: i
      });
      if (!window.dispatchEvent(l)) return;
    } else if (typeof process == "object" && typeof process.emit == "function") {
      process.emit("uncaughtException", i);
      return;
    }
    console.error(i);
  };
  function yS(i) {
    vd(i);
  }
  function vS(i) {
    console.error(i);
  }
  function bS(i) {
    vd(i);
  }
  function bd(i, l) {
    try {
      var d = i.onUncaughtError;
      d(l.value, { componentStack: l.stack });
    } catch (m) {
      setTimeout(function() {
        throw m;
      });
    }
  }
  function xS(i, l, d) {
    try {
      var m = i.onCaughtError;
      m(d.value, {
        componentStack: d.stack,
        errorBoundary: l.tag === 1 ? l.stateNode : null
      });
    } catch (x) {
      setTimeout(function() {
        throw x;
      });
    }
  }
  function g0(i, l, d) {
    return d = Ei(d), d.tag = 3, d.payload = { element: null }, d.callback = function() {
      bd(i, l);
    }, d;
  }
  function wS(i) {
    return i = Ei(i), i.tag = 3, i;
  }
  function _S(i, l, d, m) {
    var x = d.type.getDerivedStateFromError;
    if (typeof x == "function") {
      var C = m.value;
      i.payload = function() {
        return x(C);
      }, i.callback = function() {
        xS(l, d, m);
      };
    }
    var D = d.stateNode;
    D !== null && typeof D.componentDidCatch == "function" && (i.callback = function() {
      xS(l, d, m), typeof x != "function" && (ji === null ? ji = /* @__PURE__ */ new Set([this]) : ji.add(this));
      var $ = m.stack;
      this.componentDidCatch(m.value, {
        componentStack: $ !== null ? $ : ""
      });
    });
  }
  function sI(i, l, d, m, x) {
    if (d.flags |= 32768, m !== null && typeof m == "object" && typeof m.then == "function") {
      if (l = d.alternate, l !== null && vu(
        l,
        d,
        x,
        !0
      ), d = yr.current, d !== null) {
        switch (d.tag) {
          case 13:
            return Wr === null ? $0() : d.alternate === null && Ot === 0 && (Ot = 3), d.flags &= -257, d.flags |= 65536, d.lanes = x, m === qg ? d.flags |= 16384 : (l = d.updateQueue, l === null ? d.updateQueue = /* @__PURE__ */ new Set([m]) : l.add(m), H0(i, m, x)), !1;
          case 22:
            return d.flags |= 65536, m === qg ? d.flags |= 16384 : (l = d.updateQueue, l === null ? (l = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([m])
            }, d.updateQueue = l) : (d = l.retryQueue, d === null ? l.retryQueue = /* @__PURE__ */ new Set([m]) : d.add(m)), H0(i, m, x)), !1;
        }
        throw Error(r(435, d.tag));
      }
      return H0(i, m, x), $0(), !1;
    }
    if (rt)
      return l = yr.current, l !== null ? ((l.flags & 65536) === 0 && (l.flags |= 256), l.flags |= 65536, l.lanes = x, m !== Lg && (i = Error(r(422), { cause: m }), yu(hr(i, d)))) : (m !== Lg && (l = Error(r(423), {
        cause: m
      }), yu(
        hr(l, d)
      )), i = i.current.alternate, i.flags |= 65536, x &= -x, i.lanes |= x, m = hr(m, d), x = g0(
        i.stateNode,
        m,
        x
      ), Wg(i, x), Ot !== 4 && (Ot = 2)), !1;
    var C = Error(r(520), { cause: m });
    if (C = hr(C, d), Lu === null ? Lu = [C] : Lu.push(C), Ot !== 4 && (Ot = 2), l === null) return !0;
    m = hr(m, d), d = l;
    do {
      switch (d.tag) {
        case 3:
          return d.flags |= 65536, i = x & -x, d.lanes |= i, i = g0(d.stateNode, m, i), Wg(d, i), !1;
        case 1:
          if (l = d.type, C = d.stateNode, (d.flags & 128) === 0 && (typeof l.getDerivedStateFromError == "function" || C !== null && typeof C.componentDidCatch == "function" && (ji === null || !ji.has(C))))
            return d.flags |= 65536, x &= -x, d.lanes |= x, x = wS(x), _S(
              x,
              i,
              d,
              m
            ), Wg(d, x), !1;
      }
      d = d.return;
    } while (d !== null);
    return !1;
  }
  var SS = Error(r(461)), Jt = !1;
  function on(i, l, d, m) {
    l.child = i === null ? hS(l, null, d, m) : As(
      l,
      i.child,
      d,
      m
    );
  }
  function ES(i, l, d, m, x) {
    d = d.render;
    var C = l.ref;
    if ("ref" in m) {
      var D = {};
      for (var $ in m)
        $ !== "ref" && (D[$] = m[$]);
    } else D = m;
    return Sa(l), m = Jg(
      i,
      l,
      d,
      D,
      C,
      x
    ), $ = e0(), i !== null && !Jt ? (t0(i, l, x), Fo(i, l, x)) : (rt && $ && Ig(l), l.flags |= 1, on(i, l, m, x), l.child);
  }
  function CS(i, l, d, m, x) {
    if (i === null) {
      var C = d.type;
      return typeof C == "function" && !Dg(C) && C.defaultProps === void 0 && d.compare === null ? (l.tag = 15, l.type = C, kS(
        i,
        l,
        C,
        m,
        x
      )) : (i = Qf(
        d.type,
        null,
        m,
        l,
        l.mode,
        x
      ), i.ref = l.ref, i.return = l, l.child = i);
    }
    if (C = i.child, !E0(i, x)) {
      var D = C.memoizedProps;
      if (d = d.compare, d = d !== null ? d : hu, d(D, m) && i.ref === l.ref)
        return Fo(i, l, x);
    }
    return l.flags |= 1, i = No(C, m), i.ref = l.ref, i.return = l, l.child = i;
  }
  function kS(i, l, d, m, x) {
    if (i !== null) {
      var C = i.memoizedProps;
      if (hu(C, m) && i.ref === l.ref)
        if (Jt = !1, l.pendingProps = m = C, E0(i, x))
          (i.flags & 131072) !== 0 && (Jt = !0);
        else
          return l.lanes = i.lanes, Fo(i, l, x);
    }
    return y0(
      i,
      l,
      d,
      m,
      x
    );
  }
  function TS(i, l, d) {
    var m = l.pendingProps, x = m.children, C = i !== null ? i.memoizedState : null;
    if (m.mode === "hidden") {
      if ((l.flags & 128) !== 0) {
        if (m = C !== null ? C.baseLanes | d : d, i !== null) {
          for (x = l.child = i.child, C = 0; x !== null; )
            C = C | x.lanes | x.childLanes, x = x.sibling;
          l.childLanes = C & ~m;
        } else l.childLanes = 0, l.child = null;
        return AS(
          i,
          l,
          m,
          d
        );
      }
      if ((d & 536870912) !== 0)
        l.memoizedState = { baseLanes: 0, cachePool: null }, i !== null && rd(
          l,
          C !== null ? C.cachePool : null
        ), C !== null ? k_(l, C) : Kg(), pS(l);
      else
        return l.lanes = l.childLanes = 536870912, AS(
          i,
          l,
          C !== null ? C.baseLanes | d : d,
          d
        );
    } else
      C !== null ? (rd(l, C.cachePool), k_(l, C), Ai(), l.memoizedState = null) : (i !== null && rd(l, null), Kg(), Ai());
    return on(i, l, x, d), l.child;
  }
  function AS(i, l, d, m) {
    var x = Ug();
    return x = x === null ? null : { parent: Xt._currentValue, pool: x }, l.memoizedState = {
      baseLanes: d,
      cachePool: x
    }, i !== null && rd(l, null), Kg(), pS(l), i !== null && vu(i, l, m, !0), null;
  }
  function xd(i, l) {
    var d = l.ref;
    if (d === null)
      i !== null && i.ref !== null && (l.flags |= 4194816);
    else {
      if (typeof d != "function" && typeof d != "object")
        throw Error(r(284));
      (i === null || i.ref !== d) && (l.flags |= 4194816);
    }
  }
  function y0(i, l, d, m, x) {
    return Sa(l), d = Jg(
      i,
      l,
      d,
      m,
      void 0,
      x
    ), m = e0(), i !== null && !Jt ? (t0(i, l, x), Fo(i, l, x)) : (rt && m && Ig(l), l.flags |= 1, on(i, l, d, x), l.child);
  }
  function RS(i, l, d, m, x, C) {
    return Sa(l), l.updateQueue = null, d = A_(
      l,
      m,
      d,
      x
    ), T_(i), m = e0(), i !== null && !Jt ? (t0(i, l, C), Fo(i, l, C)) : (rt && m && Ig(l), l.flags |= 1, on(i, l, d, C), l.child);
  }
  function MS(i, l, d, m, x) {
    if (Sa(l), l.stateNode === null) {
      var C = vs, D = d.contextType;
      typeof D == "object" && D !== null && (C = hn(D)), C = new d(m, C), l.memoizedState = C.state !== null && C.state !== void 0 ? C.state : null, C.updater = m0, l.stateNode = C, C._reactInternals = l, C = l.stateNode, C.props = m, C.state = l.memoizedState, C.refs = {}, Gg(l), D = d.contextType, C.context = typeof D == "object" && D !== null ? hn(D) : vs, C.state = l.memoizedState, D = d.getDerivedStateFromProps, typeof D == "function" && (p0(
        l,
        d,
        D,
        m
      ), C.state = l.memoizedState), typeof d.getDerivedStateFromProps == "function" || typeof C.getSnapshotBeforeUpdate == "function" || typeof C.UNSAFE_componentWillMount != "function" && typeof C.componentWillMount != "function" || (D = C.state, typeof C.componentWillMount == "function" && C.componentWillMount(), typeof C.UNSAFE_componentWillMount == "function" && C.UNSAFE_componentWillMount(), D !== C.state && m0.enqueueReplaceState(C, C.state, null), Cu(l, m, C, x), Eu(), C.state = l.memoizedState), typeof C.componentDidMount == "function" && (l.flags |= 4194308), m = !0;
    } else if (i === null) {
      C = l.stateNode;
      var $ = l.memoizedProps, X = ka(d, $);
      C.props = X;
      var ee = C.context, ue = d.contextType;
      D = vs, typeof ue == "object" && ue !== null && (D = hn(ue));
      var de = d.getDerivedStateFromProps;
      ue = typeof de == "function" || typeof C.getSnapshotBeforeUpdate == "function", $ = l.pendingProps !== $, ue || typeof C.UNSAFE_componentWillReceiveProps != "function" && typeof C.componentWillReceiveProps != "function" || ($ || ee !== D) && gS(
        l,
        C,
        m,
        D
      ), Si = !1;
      var ne = l.memoizedState;
      C.state = ne, Cu(l, m, C, x), Eu(), ee = l.memoizedState, $ || ne !== ee || Si ? (typeof de == "function" && (p0(
        l,
        d,
        de,
        m
      ), ee = l.memoizedState), (X = Si || mS(
        l,
        d,
        X,
        m,
        ne,
        ee,
        D
      )) ? (ue || typeof C.UNSAFE_componentWillMount != "function" && typeof C.componentWillMount != "function" || (typeof C.componentWillMount == "function" && C.componentWillMount(), typeof C.UNSAFE_componentWillMount == "function" && C.UNSAFE_componentWillMount()), typeof C.componentDidMount == "function" && (l.flags |= 4194308)) : (typeof C.componentDidMount == "function" && (l.flags |= 4194308), l.memoizedProps = m, l.memoizedState = ee), C.props = m, C.state = ee, C.context = D, m = X) : (typeof C.componentDidMount == "function" && (l.flags |= 4194308), m = !1);
    } else {
      C = l.stateNode, Yg(i, l), D = l.memoizedProps, ue = ka(d, D), C.props = ue, de = l.pendingProps, ne = C.context, ee = d.contextType, X = vs, typeof ee == "object" && ee !== null && (X = hn(ee)), $ = d.getDerivedStateFromProps, (ee = typeof $ == "function" || typeof C.getSnapshotBeforeUpdate == "function") || typeof C.UNSAFE_componentWillReceiveProps != "function" && typeof C.componentWillReceiveProps != "function" || (D !== de || ne !== X) && gS(
        l,
        C,
        m,
        X
      ), Si = !1, ne = l.memoizedState, C.state = ne, Cu(l, m, C, x), Eu();
      var re = l.memoizedState;
      D !== de || ne !== re || Si || i !== null && i.dependencies !== null && td(i.dependencies) ? (typeof $ == "function" && (p0(
        l,
        d,
        $,
        m
      ), re = l.memoizedState), (ue = Si || mS(
        l,
        d,
        ue,
        m,
        ne,
        re,
        X
      ) || i !== null && i.dependencies !== null && td(i.dependencies)) ? (ee || typeof C.UNSAFE_componentWillUpdate != "function" && typeof C.componentWillUpdate != "function" || (typeof C.componentWillUpdate == "function" && C.componentWillUpdate(m, re, X), typeof C.UNSAFE_componentWillUpdate == "function" && C.UNSAFE_componentWillUpdate(
        m,
        re,
        X
      )), typeof C.componentDidUpdate == "function" && (l.flags |= 4), typeof C.getSnapshotBeforeUpdate == "function" && (l.flags |= 1024)) : (typeof C.componentDidUpdate != "function" || D === i.memoizedProps && ne === i.memoizedState || (l.flags |= 4), typeof C.getSnapshotBeforeUpdate != "function" || D === i.memoizedProps && ne === i.memoizedState || (l.flags |= 1024), l.memoizedProps = m, l.memoizedState = re), C.props = m, C.state = re, C.context = X, m = ue) : (typeof C.componentDidUpdate != "function" || D === i.memoizedProps && ne === i.memoizedState || (l.flags |= 4), typeof C.getSnapshotBeforeUpdate != "function" || D === i.memoizedProps && ne === i.memoizedState || (l.flags |= 1024), m = !1);
    }
    return C = m, xd(i, l), m = (l.flags & 128) !== 0, C || m ? (C = l.stateNode, d = m && typeof d.getDerivedStateFromError != "function" ? null : C.render(), l.flags |= 1, i !== null && m ? (l.child = As(
      l,
      i.child,
      null,
      x
    ), l.child = As(
      l,
      null,
      d,
      x
    )) : on(i, l, d, x), l.memoizedState = C.state, i = l.child) : i = Fo(
      i,
      l,
      x
    ), i;
  }
  function OS(i, l, d, m) {
    return gu(), l.flags |= 256, on(i, l, d, m), l.child;
  }
  var v0 = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function b0(i) {
    return { baseLanes: i, cachePool: v_() };
  }
  function x0(i, l, d) {
    return i = i !== null ? i.childLanes & ~d : 0, l && (i |= vr), i;
  }
  function NS(i, l, d) {
    var m = l.pendingProps, x = !1, C = (l.flags & 128) !== 0, D;
    if ((D = C) || (D = i !== null && i.memoizedState === null ? !1 : (Kt.current & 2) !== 0), D && (x = !0, l.flags &= -129), D = (l.flags & 32) !== 0, l.flags &= -33, i === null) {
      if (rt) {
        if (x ? Ti(l) : Ai(), rt) {
          var $ = Mt, X;
          if (X = $) {
            e: {
              for (X = $, $ = Yr; X.nodeType !== 8; ) {
                if (!$) {
                  $ = null;
                  break e;
                }
                if (X = Nr(
                  X.nextSibling
                ), X === null) {
                  $ = null;
                  break e;
                }
              }
              $ = X;
            }
            $ !== null ? (l.memoizedState = {
              dehydrated: $,
              treeContext: va !== null ? { id: Do, overflow: jo } : null,
              retryLane: 536870912,
              hydrationErrors: null
            }, X = Wn(
              18,
              null,
              null,
              0
            ), X.stateNode = $, X.return = l, l.child = X, En = l, Mt = null, X = !0) : X = !1;
          }
          X || wa(l);
        }
        if ($ = l.memoizedState, $ !== null && ($ = $.dehydrated, $ !== null))
          return ry($) ? l.lanes = 32 : l.lanes = 536870912, null;
        Lo(l);
      }
      return $ = m.children, m = m.fallback, x ? (Ai(), x = l.mode, $ = wd(
        { mode: "hidden", children: $ },
        x
      ), m = ya(
        m,
        x,
        d,
        null
      ), $.return = l, m.return = l, $.sibling = m, l.child = $, x = l.child, x.memoizedState = b0(d), x.childLanes = x0(
        i,
        D,
        d
      ), l.memoizedState = v0, m) : (Ti(l), w0(l, $));
    }
    if (X = i.memoizedState, X !== null && ($ = X.dehydrated, $ !== null)) {
      if (C)
        l.flags & 256 ? (Ti(l), l.flags &= -257, l = _0(
          i,
          l,
          d
        )) : l.memoizedState !== null ? (Ai(), l.child = i.child, l.flags |= 128, l = null) : (Ai(), x = m.fallback, $ = l.mode, m = wd(
          { mode: "visible", children: m.children },
          $
        ), x = ya(
          x,
          $,
          d,
          null
        ), x.flags |= 2, m.return = l, x.return = l, m.sibling = x, l.child = m, As(
          l,
          i.child,
          null,
          d
        ), m = l.child, m.memoizedState = b0(d), m.childLanes = x0(
          i,
          D,
          d
        ), l.memoizedState = v0, l = x);
      else if (Ti(l), ry($)) {
        if (D = $.nextSibling && $.nextSibling.dataset, D) var ee = D.dgst;
        D = ee, m = Error(r(419)), m.stack = "", m.digest = D, yu({ value: m, source: null, stack: null }), l = _0(
          i,
          l,
          d
        );
      } else if (Jt || vu(i, l, d, !1), D = (d & i.childLanes) !== 0, Jt || D) {
        if (D = xt, D !== null && (m = d & -d, m = (m & 42) !== 0 ? 1 : Kl(m), m = (m & (D.suspendedLanes | d)) !== 0 ? 0 : m, m !== 0 && m !== X.retryLane))
          throw X.retryLane = m, ys(i, m), Jn(D, i, m), SS;
        $.data === "$?" || $0(), l = _0(
          i,
          l,
          d
        );
      } else
        $.data === "$?" ? (l.flags |= 192, l.child = i.child, l = null) : (i = X.treeContext, Mt = Nr(
          $.nextSibling
        ), En = l, rt = !0, xa = null, Yr = !1, i !== null && (mr[gr++] = Do, mr[gr++] = jo, mr[gr++] = va, Do = i.id, jo = i.overflow, va = l), l = w0(
          l,
          m.children
        ), l.flags |= 4096);
      return l;
    }
    return x ? (Ai(), x = m.fallback, $ = l.mode, X = i.child, ee = X.sibling, m = No(X, {
      mode: "hidden",
      children: m.children
    }), m.subtreeFlags = X.subtreeFlags & 65011712, ee !== null ? x = No(ee, x) : (x = ya(
      x,
      $,
      d,
      null
    ), x.flags |= 2), x.return = l, m.return = l, m.sibling = x, l.child = m, m = x, x = l.child, $ = i.child.memoizedState, $ === null ? $ = b0(d) : (X = $.cachePool, X !== null ? (ee = Xt._currentValue, X = X.parent !== ee ? { parent: ee, pool: ee } : X) : X = v_(), $ = {
      baseLanes: $.baseLanes | d,
      cachePool: X
    }), x.memoizedState = $, x.childLanes = x0(
      i,
      D,
      d
    ), l.memoizedState = v0, m) : (Ti(l), d = i.child, i = d.sibling, d = No(d, {
      mode: "visible",
      children: m.children
    }), d.return = l, d.sibling = null, i !== null && (D = l.deletions, D === null ? (l.deletions = [i], l.flags |= 16) : D.push(i)), l.child = d, l.memoizedState = null, d);
  }
  function w0(i, l) {
    return l = wd(
      { mode: "visible", children: l },
      i.mode
    ), l.return = i, i.child = l;
  }
  function wd(i, l) {
    return i = Wn(22, i, null, l), i.lanes = 0, i.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    }, i;
  }
  function _0(i, l, d) {
    return As(l, i.child, null, d), i = w0(
      l,
      l.pendingProps.children
    ), i.flags |= 2, l.memoizedState = null, i;
  }
  function DS(i, l, d) {
    i.lanes |= l;
    var m = i.alternate;
    m !== null && (m.lanes |= l), $g(i.return, l, d);
  }
  function S0(i, l, d, m, x) {
    var C = i.memoizedState;
    C === null ? i.memoizedState = {
      isBackwards: l,
      rendering: null,
      renderingStartTime: 0,
      last: m,
      tail: d,
      tailMode: x
    } : (C.isBackwards = l, C.rendering = null, C.renderingStartTime = 0, C.last = m, C.tail = d, C.tailMode = x);
  }
  function jS(i, l, d) {
    var m = l.pendingProps, x = m.revealOrder, C = m.tail;
    if (on(i, l, m.children, d), m = Kt.current, (m & 2) !== 0)
      m = m & 1 | 2, l.flags |= 128;
    else {
      if (i !== null && (i.flags & 128) !== 0)
        e: for (i = l.child; i !== null; ) {
          if (i.tag === 13)
            i.memoizedState !== null && DS(i, d, l);
          else if (i.tag === 19)
            DS(i, d, l);
          else if (i.child !== null) {
            i.child.return = i, i = i.child;
            continue;
          }
          if (i === l) break e;
          for (; i.sibling === null; ) {
            if (i.return === null || i.return === l)
              break e;
            i = i.return;
          }
          i.sibling.return = i.return, i = i.sibling;
        }
      m &= 1;
    }
    switch (L(Kt, m), x) {
      case "forwards":
        for (d = l.child, x = null; d !== null; )
          i = d.alternate, i !== null && yd(i) === null && (x = d), d = d.sibling;
        d = x, d === null ? (x = l.child, l.child = null) : (x = d.sibling, d.sibling = null), S0(
          l,
          !1,
          x,
          d,
          C
        );
        break;
      case "backwards":
        for (d = null, x = l.child, l.child = null; x !== null; ) {
          if (i = x.alternate, i !== null && yd(i) === null) {
            l.child = x;
            break;
          }
          i = x.sibling, x.sibling = d, d = x, x = i;
        }
        S0(
          l,
          !0,
          d,
          null,
          C
        );
        break;
      case "together":
        S0(l, !1, null, null, void 0);
        break;
      default:
        l.memoizedState = null;
    }
    return l.child;
  }
  function Fo(i, l, d) {
    if (i !== null && (l.dependencies = i.dependencies), Di |= l.lanes, (d & l.childLanes) === 0)
      if (i !== null) {
        if (vu(
          i,
          l,
          d,
          !1
        ), (d & l.childLanes) === 0)
          return null;
      } else return null;
    if (i !== null && l.child !== i.child)
      throw Error(r(153));
    if (l.child !== null) {
      for (i = l.child, d = No(i, i.pendingProps), l.child = d, d.return = l; i.sibling !== null; )
        i = i.sibling, d = d.sibling = No(i, i.pendingProps), d.return = l;
      d.sibling = null;
    }
    return l.child;
  }
  function E0(i, l) {
    return (i.lanes & l) !== 0 ? !0 : (i = i.dependencies, !!(i !== null && td(i)));
  }
  function lI(i, l, d) {
    switch (l.tag) {
      case 3:
        ae(l, l.stateNode.containerInfo), _i(l, Xt, i.memoizedState.cache), gu();
        break;
      case 27:
      case 5:
        Ne(l);
        break;
      case 4:
        ae(l, l.stateNode.containerInfo);
        break;
      case 10:
        _i(
          l,
          l.type,
          l.memoizedProps.value
        );
        break;
      case 13:
        var m = l.memoizedState;
        if (m !== null)
          return m.dehydrated !== null ? (Ti(l), l.flags |= 128, null) : (d & l.child.childLanes) !== 0 ? NS(i, l, d) : (Ti(l), i = Fo(
            i,
            l,
            d
          ), i !== null ? i.sibling : null);
        Ti(l);
        break;
      case 19:
        var x = (i.flags & 128) !== 0;
        if (m = (d & l.childLanes) !== 0, m || (vu(
          i,
          l,
          d,
          !1
        ), m = (d & l.childLanes) !== 0), x) {
          if (m)
            return jS(
              i,
              l,
              d
            );
          l.flags |= 128;
        }
        if (x = l.memoizedState, x !== null && (x.rendering = null, x.tail = null, x.lastEffect = null), L(Kt, Kt.current), m) break;
        return null;
      case 22:
      case 23:
        return l.lanes = 0, TS(i, l, d);
      case 24:
        _i(l, Xt, i.memoizedState.cache);
    }
    return Fo(i, l, d);
  }
  function PS(i, l, d) {
    if (i !== null)
      if (i.memoizedProps !== l.pendingProps)
        Jt = !0;
      else {
        if (!E0(i, d) && (l.flags & 128) === 0)
          return Jt = !1, lI(
            i,
            l,
            d
          );
        Jt = (i.flags & 131072) !== 0;
      }
    else
      Jt = !1, rt && (l.flags & 1048576) !== 0 && f_(l, ed, l.index);
    switch (l.lanes = 0, l.tag) {
      case 16:
        e: {
          i = l.pendingProps;
          var m = l.elementType, x = m._init;
          if (m = x(m._payload), l.type = m, typeof m == "function")
            Dg(m) ? (i = ka(m, i), l.tag = 1, l = MS(
              null,
              l,
              m,
              i,
              d
            )) : (l.tag = 0, l = y0(
              null,
              l,
              m,
              i,
              d
            ));
          else {
            if (m != null) {
              if (x = m.$$typeof, x === T) {
                l.tag = 11, l = ES(
                  null,
                  l,
                  m,
                  i,
                  d
                );
                break e;
              } else if (x === j) {
                l.tag = 14, l = CS(
                  null,
                  l,
                  m,
                  i,
                  d
                );
                break e;
              }
            }
            throw l = P(m) || m, Error(r(306, l, ""));
          }
        }
        return l;
      case 0:
        return y0(
          i,
          l,
          l.type,
          l.pendingProps,
          d
        );
      case 1:
        return m = l.type, x = ka(
          m,
          l.pendingProps
        ), MS(
          i,
          l,
          m,
          x,
          d
        );
      case 3:
        e: {
          if (ae(
            l,
            l.stateNode.containerInfo
          ), i === null) throw Error(r(387));
          m = l.pendingProps;
          var C = l.memoizedState;
          x = C.element, Yg(i, l), Cu(l, m, null, d);
          var D = l.memoizedState;
          if (m = D.cache, _i(l, Xt, m), m !== C.cache && Bg(
            l,
            [Xt],
            d,
            !0
          ), Eu(), m = D.element, C.isDehydrated)
            if (C = {
              element: m,
              isDehydrated: !1,
              cache: D.cache
            }, l.updateQueue.baseState = C, l.memoizedState = C, l.flags & 256) {
              l = OS(
                i,
                l,
                m,
                d
              );
              break e;
            } else if (m !== x) {
              x = hr(
                Error(r(424)),
                l
              ), yu(x), l = OS(
                i,
                l,
                m,
                d
              );
              break e;
            } else {
              switch (i = l.stateNode.containerInfo, i.nodeType) {
                case 9:
                  i = i.body;
                  break;
                default:
                  i = i.nodeName === "HTML" ? i.ownerDocument.body : i;
              }
              for (Mt = Nr(i.firstChild), En = l, rt = !0, xa = null, Yr = !0, d = hS(
                l,
                null,
                m,
                d
              ), l.child = d; d; )
                d.flags = d.flags & -3 | 4096, d = d.sibling;
            }
          else {
            if (gu(), m === x) {
              l = Fo(
                i,
                l,
                d
              );
              break e;
            }
            on(
              i,
              l,
              m,
              d
            );
          }
          l = l.child;
        }
        return l;
      case 26:
        return xd(i, l), i === null ? (d = FE(
          l.type,
          null,
          l.pendingProps,
          null
        )) ? l.memoizedState = d : rt || (d = l.type, i = l.pendingProps, m = Pd(
          oe.current
        ).createElement(d), m[Qt] = l, m[dn] = i, sn(m, d, i), Bt(m), l.stateNode = m) : l.memoizedState = FE(
          l.type,
          i.memoizedProps,
          l.pendingProps,
          i.memoizedState
        ), null;
      case 27:
        return Ne(l), i === null && rt && (m = l.stateNode = IE(
          l.type,
          l.pendingProps,
          oe.current
        ), En = l, Yr = !0, x = Mt, zi(l.type) ? (oy = x, Mt = Nr(
          m.firstChild
        )) : Mt = x), on(
          i,
          l,
          l.pendingProps.children,
          d
        ), xd(i, l), i === null && (l.flags |= 4194304), l.child;
      case 5:
        return i === null && rt && ((x = m = Mt) && (m = II(
          m,
          l.type,
          l.pendingProps,
          Yr
        ), m !== null ? (l.stateNode = m, En = l, Mt = Nr(
          m.firstChild
        ), Yr = !1, x = !0) : x = !1), x || wa(l)), Ne(l), x = l.type, C = l.pendingProps, D = i !== null ? i.memoizedProps : null, m = C.children, ey(x, C) ? m = null : D !== null && ey(x, D) && (l.flags |= 32), l.memoizedState !== null && (x = Jg(
          i,
          l,
          eI,
          null,
          null,
          d
        ), Yu._currentValue = x), xd(i, l), on(i, l, m, d), l.child;
      case 6:
        return i === null && rt && ((i = d = Mt) && (d = zI(
          d,
          l.pendingProps,
          Yr
        ), d !== null ? (l.stateNode = d, En = l, Mt = null, i = !0) : i = !1), i || wa(l)), null;
      case 13:
        return NS(i, l, d);
      case 4:
        return ae(
          l,
          l.stateNode.containerInfo
        ), m = l.pendingProps, i === null ? l.child = As(
          l,
          null,
          m,
          d
        ) : on(
          i,
          l,
          m,
          d
        ), l.child;
      case 11:
        return ES(
          i,
          l,
          l.type,
          l.pendingProps,
          d
        );
      case 7:
        return on(
          i,
          l,
          l.pendingProps,
          d
        ), l.child;
      case 8:
        return on(
          i,
          l,
          l.pendingProps.children,
          d
        ), l.child;
      case 12:
        return on(
          i,
          l,
          l.pendingProps.children,
          d
        ), l.child;
      case 10:
        return m = l.pendingProps, _i(l, l.type, m.value), on(
          i,
          l,
          m.children,
          d
        ), l.child;
      case 9:
        return x = l.type._context, m = l.pendingProps.children, Sa(l), x = hn(x), m = m(x), l.flags |= 1, on(i, l, m, d), l.child;
      case 14:
        return CS(
          i,
          l,
          l.type,
          l.pendingProps,
          d
        );
      case 15:
        return kS(
          i,
          l,
          l.type,
          l.pendingProps,
          d
        );
      case 19:
        return jS(i, l, d);
      case 31:
        return m = l.pendingProps, d = l.mode, m = {
          mode: m.mode,
          children: m.children
        }, i === null ? (d = wd(
          m,
          d
        ), d.ref = l.ref, l.child = d, d.return = l, l = d) : (d = No(i.child, m), d.ref = l.ref, l.child = d, d.return = l, l = d), l;
      case 22:
        return TS(i, l, d);
      case 24:
        return Sa(l), m = hn(Xt), i === null ? (x = Ug(), x === null && (x = xt, C = Hg(), x.pooledCache = C, C.refCount++, C !== null && (x.pooledCacheLanes |= d), x = C), l.memoizedState = {
          parent: m,
          cache: x
        }, Gg(l), _i(l, Xt, x)) : ((i.lanes & d) !== 0 && (Yg(i, l), Cu(l, null, null, d), Eu()), x = i.memoizedState, C = l.memoizedState, x.parent !== m ? (x = { parent: m, cache: m }, l.memoizedState = x, l.lanes === 0 && (l.memoizedState = l.updateQueue.baseState = x), _i(l, Xt, m)) : (m = C.cache, _i(l, Xt, m), m !== x.cache && Bg(
          l,
          [Xt],
          d,
          !0
        ))), on(
          i,
          l,
          l.pendingProps.children,
          d
        ), l.child;
      case 29:
        throw l.pendingProps;
    }
    throw Error(r(156, l.tag));
  }
  function $o(i) {
    i.flags |= 4;
  }
  function IS(i, l) {
    if (l.type !== "stylesheet" || (l.state.loading & 4) !== 0)
      i.flags &= -16777217;
    else if (i.flags |= 16777216, !UE(l)) {
      if (l = yr.current, l !== null && ((Ze & 4194048) === Ze ? Wr !== null : (Ze & 62914560) !== Ze && (Ze & 536870912) === 0 || l !== Wr))
        throw _u = qg, b_;
      i.flags |= 8192;
    }
  }
  function _d(i, l) {
    l !== null && (i.flags |= 4), i.flags & 16384 && (l = i.tag !== 22 ? Of() : 536870912, i.lanes |= l, Ns |= l);
  }
  function Nu(i, l) {
    if (!rt)
      switch (i.tailMode) {
        case "hidden":
          l = i.tail;
          for (var d = null; l !== null; )
            l.alternate !== null && (d = l), l = l.sibling;
          d === null ? i.tail = null : d.sibling = null;
          break;
        case "collapsed":
          d = i.tail;
          for (var m = null; d !== null; )
            d.alternate !== null && (m = d), d = d.sibling;
          m === null ? l || i.tail === null ? i.tail = null : i.tail.sibling = null : m.sibling = null;
      }
  }
  function Tt(i) {
    var l = i.alternate !== null && i.alternate.child === i.child, d = 0, m = 0;
    if (l)
      for (var x = i.child; x !== null; )
        d |= x.lanes | x.childLanes, m |= x.subtreeFlags & 65011712, m |= x.flags & 65011712, x.return = i, x = x.sibling;
    else
      for (x = i.child; x !== null; )
        d |= x.lanes | x.childLanes, m |= x.subtreeFlags, m |= x.flags, x.return = i, x = x.sibling;
    return i.subtreeFlags |= m, i.childLanes = d, l;
  }
  function uI(i, l, d) {
    var m = l.pendingProps;
    switch (zg(l), l.tag) {
      case 31:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Tt(l), null;
      case 1:
        return Tt(l), null;
      case 3:
        return d = l.stateNode, m = null, i !== null && (m = i.memoizedState.cache), l.memoizedState.cache !== m && (l.flags |= 2048), Io(Xt), ye(), d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null), (i === null || i.child === null) && (mu(l) ? $o(l) : i === null || i.memoizedState.isDehydrated && (l.flags & 256) === 0 || (l.flags |= 1024, p_())), Tt(l), null;
      case 26:
        return d = l.memoizedState, i === null ? ($o(l), d !== null ? (Tt(l), IS(l, d)) : (Tt(l), l.flags &= -16777217)) : d ? d !== i.memoizedState ? ($o(l), Tt(l), IS(l, d)) : (Tt(l), l.flags &= -16777217) : (i.memoizedProps !== m && $o(l), Tt(l), l.flags &= -16777217), null;
      case 27:
        De(l), d = oe.current;
        var x = l.type;
        if (i !== null && l.stateNode != null)
          i.memoizedProps !== m && $o(l);
        else {
          if (!m) {
            if (l.stateNode === null)
              throw Error(r(166));
            return Tt(l), null;
          }
          i = te.current, mu(l) ? d_(l) : (i = IE(x, m, d), l.stateNode = i, $o(l));
        }
        return Tt(l), null;
      case 5:
        if (De(l), d = l.type, i !== null && l.stateNode != null)
          i.memoizedProps !== m && $o(l);
        else {
          if (!m) {
            if (l.stateNode === null)
              throw Error(r(166));
            return Tt(l), null;
          }
          if (i = te.current, mu(l))
            d_(l);
          else {
            switch (x = Pd(
              oe.current
            ), i) {
              case 1:
                i = x.createElementNS(
                  "http://www.w3.org/2000/svg",
                  d
                );
                break;
              case 2:
                i = x.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  d
                );
                break;
              default:
                switch (d) {
                  case "svg":
                    i = x.createElementNS(
                      "http://www.w3.org/2000/svg",
                      d
                    );
                    break;
                  case "math":
                    i = x.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      d
                    );
                    break;
                  case "script":
                    i = x.createElement("div"), i.innerHTML = "<script><\/script>", i = i.removeChild(i.firstChild);
                    break;
                  case "select":
                    i = typeof m.is == "string" ? x.createElement("select", { is: m.is }) : x.createElement("select"), m.multiple ? i.multiple = !0 : m.size && (i.size = m.size);
                    break;
                  default:
                    i = typeof m.is == "string" ? x.createElement(d, { is: m.is }) : x.createElement(d);
                }
            }
            i[Qt] = l, i[dn] = m;
            e: for (x = l.child; x !== null; ) {
              if (x.tag === 5 || x.tag === 6)
                i.appendChild(x.stateNode);
              else if (x.tag !== 4 && x.tag !== 27 && x.child !== null) {
                x.child.return = x, x = x.child;
                continue;
              }
              if (x === l) break e;
              for (; x.sibling === null; ) {
                if (x.return === null || x.return === l)
                  break e;
                x = x.return;
              }
              x.sibling.return = x.return, x = x.sibling;
            }
            l.stateNode = i;
            e: switch (sn(i, d, m), d) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                i = !!m.autoFocus;
                break e;
              case "img":
                i = !0;
                break e;
              default:
                i = !1;
            }
            i && $o(l);
          }
        }
        return Tt(l), l.flags &= -16777217, null;
      case 6:
        if (i && l.stateNode != null)
          i.memoizedProps !== m && $o(l);
        else {
          if (typeof m != "string" && l.stateNode === null)
            throw Error(r(166));
          if (i = oe.current, mu(l)) {
            if (i = l.stateNode, d = l.memoizedProps, m = null, x = En, x !== null)
              switch (x.tag) {
                case 27:
                case 5:
                  m = x.memoizedProps;
              }
            i[Qt] = l, i = !!(i.nodeValue === d || m !== null && m.suppressHydrationWarning === !0 || RE(i.nodeValue, d)), i || wa(l);
          } else
            i = Pd(i).createTextNode(
              m
            ), i[Qt] = l, l.stateNode = i;
        }
        return Tt(l), null;
      case 13:
        if (m = l.memoizedState, i === null || i.memoizedState !== null && i.memoizedState.dehydrated !== null) {
          if (x = mu(l), m !== null && m.dehydrated !== null) {
            if (i === null) {
              if (!x) throw Error(r(318));
              if (x = l.memoizedState, x = x !== null ? x.dehydrated : null, !x) throw Error(r(317));
              x[Qt] = l;
            } else
              gu(), (l.flags & 128) === 0 && (l.memoizedState = null), l.flags |= 4;
            Tt(l), x = !1;
          } else
            x = p_(), i !== null && i.memoizedState !== null && (i.memoizedState.hydrationErrors = x), x = !0;
          if (!x)
            return l.flags & 256 ? (Lo(l), l) : (Lo(l), null);
        }
        if (Lo(l), (l.flags & 128) !== 0)
          return l.lanes = d, l;
        if (d = m !== null, i = i !== null && i.memoizedState !== null, d) {
          m = l.child, x = null, m.alternate !== null && m.alternate.memoizedState !== null && m.alternate.memoizedState.cachePool !== null && (x = m.alternate.memoizedState.cachePool.pool);
          var C = null;
          m.memoizedState !== null && m.memoizedState.cachePool !== null && (C = m.memoizedState.cachePool.pool), C !== x && (m.flags |= 2048);
        }
        return d !== i && d && (l.child.flags |= 8192), _d(l, l.updateQueue), Tt(l), null;
      case 4:
        return ye(), i === null && X0(l.stateNode.containerInfo), Tt(l), null;
      case 10:
        return Io(l.type), Tt(l), null;
      case 19:
        if (Z(Kt), x = l.memoizedState, x === null) return Tt(l), null;
        if (m = (l.flags & 128) !== 0, C = x.rendering, C === null)
          if (m) Nu(x, !1);
          else {
            if (Ot !== 0 || i !== null && (i.flags & 128) !== 0)
              for (i = l.child; i !== null; ) {
                if (C = yd(i), C !== null) {
                  for (l.flags |= 128, Nu(x, !1), i = C.updateQueue, l.updateQueue = i, _d(l, i), l.subtreeFlags = 0, i = d, d = l.child; d !== null; )
                    c_(d, i), d = d.sibling;
                  return L(
                    Kt,
                    Kt.current & 1 | 2
                  ), l.child;
                }
                i = i.sibling;
              }
            x.tail !== null && ct() > Cd && (l.flags |= 128, m = !0, Nu(x, !1), l.lanes = 4194304);
          }
        else {
          if (!m)
            if (i = yd(C), i !== null) {
              if (l.flags |= 128, m = !0, i = i.updateQueue, l.updateQueue = i, _d(l, i), Nu(x, !0), x.tail === null && x.tailMode === "hidden" && !C.alternate && !rt)
                return Tt(l), null;
            } else
              2 * ct() - x.renderingStartTime > Cd && d !== 536870912 && (l.flags |= 128, m = !0, Nu(x, !1), l.lanes = 4194304);
          x.isBackwards ? (C.sibling = l.child, l.child = C) : (i = x.last, i !== null ? i.sibling = C : l.child = C, x.last = C);
        }
        return x.tail !== null ? (l = x.tail, x.rendering = l, x.tail = l.sibling, x.renderingStartTime = ct(), l.sibling = null, i = Kt.current, L(Kt, m ? i & 1 | 2 : i & 1), l) : (Tt(l), null);
      case 22:
      case 23:
        return Lo(l), Zg(), m = l.memoizedState !== null, i !== null ? i.memoizedState !== null !== m && (l.flags |= 8192) : m && (l.flags |= 8192), m ? (d & 536870912) !== 0 && (l.flags & 128) === 0 && (Tt(l), l.subtreeFlags & 6 && (l.flags |= 8192)) : Tt(l), d = l.updateQueue, d !== null && _d(l, d.retryQueue), d = null, i !== null && i.memoizedState !== null && i.memoizedState.cachePool !== null && (d = i.memoizedState.cachePool.pool), m = null, l.memoizedState !== null && l.memoizedState.cachePool !== null && (m = l.memoizedState.cachePool.pool), m !== d && (l.flags |= 2048), i !== null && Z(Ea), null;
      case 24:
        return d = null, i !== null && (d = i.memoizedState.cache), l.memoizedState.cache !== d && (l.flags |= 2048), Io(Xt), Tt(l), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(r(156, l.tag));
  }
  function cI(i, l) {
    switch (zg(l), l.tag) {
      case 1:
        return i = l.flags, i & 65536 ? (l.flags = i & -65537 | 128, l) : null;
      case 3:
        return Io(Xt), ye(), i = l.flags, (i & 65536) !== 0 && (i & 128) === 0 ? (l.flags = i & -65537 | 128, l) : null;
      case 26:
      case 27:
      case 5:
        return De(l), null;
      case 13:
        if (Lo(l), i = l.memoizedState, i !== null && i.dehydrated !== null) {
          if (l.alternate === null)
            throw Error(r(340));
          gu();
        }
        return i = l.flags, i & 65536 ? (l.flags = i & -65537 | 128, l) : null;
      case 19:
        return Z(Kt), null;
      case 4:
        return ye(), null;
      case 10:
        return Io(l.type), null;
      case 22:
      case 23:
        return Lo(l), Zg(), i !== null && Z(Ea), i = l.flags, i & 65536 ? (l.flags = i & -65537 | 128, l) : null;
      case 24:
        return Io(Xt), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function zS(i, l) {
    switch (zg(l), l.tag) {
      case 3:
        Io(Xt), ye();
        break;
      case 26:
      case 27:
      case 5:
        De(l);
        break;
      case 4:
        ye();
        break;
      case 13:
        Lo(l);
        break;
      case 19:
        Z(Kt);
        break;
      case 10:
        Io(l.type);
        break;
      case 22:
      case 23:
        Lo(l), Zg(), i !== null && Z(Ea);
        break;
      case 24:
        Io(Xt);
    }
  }
  function Du(i, l) {
    try {
      var d = l.updateQueue, m = d !== null ? d.lastEffect : null;
      if (m !== null) {
        var x = m.next;
        d = x;
        do {
          if ((d.tag & i) === i) {
            m = void 0;
            var C = d.create, D = d.inst;
            m = C(), D.destroy = m;
          }
          d = d.next;
        } while (d !== x);
      }
    } catch ($) {
      mt(l, l.return, $);
    }
  }
  function Ri(i, l, d) {
    try {
      var m = l.updateQueue, x = m !== null ? m.lastEffect : null;
      if (x !== null) {
        var C = x.next;
        m = C;
        do {
          if ((m.tag & i) === i) {
            var D = m.inst, $ = D.destroy;
            if ($ !== void 0) {
              D.destroy = void 0, x = l;
              var X = d, ee = $;
              try {
                ee();
              } catch (ue) {
                mt(
                  x,
                  X,
                  ue
                );
              }
            }
          }
          m = m.next;
        } while (m !== C);
      }
    } catch (ue) {
      mt(l, l.return, ue);
    }
  }
  function LS(i) {
    var l = i.updateQueue;
    if (l !== null) {
      var d = i.stateNode;
      try {
        C_(l, d);
      } catch (m) {
        mt(i, i.return, m);
      }
    }
  }
  function FS(i, l, d) {
    d.props = ka(
      i.type,
      i.memoizedProps
    ), d.state = i.memoizedState;
    try {
      d.componentWillUnmount();
    } catch (m) {
      mt(i, l, m);
    }
  }
  function ju(i, l) {
    try {
      var d = i.ref;
      if (d !== null) {
        switch (i.tag) {
          case 26:
          case 27:
          case 5:
            var m = i.stateNode;
            break;
          case 30:
            m = i.stateNode;
            break;
          default:
            m = i.stateNode;
        }
        typeof d == "function" ? i.refCleanup = d(m) : d.current = m;
      }
    } catch (x) {
      mt(i, l, x);
    }
  }
  function Xr(i, l) {
    var d = i.ref, m = i.refCleanup;
    if (d !== null)
      if (typeof m == "function")
        try {
          m();
        } catch (x) {
          mt(i, l, x);
        } finally {
          i.refCleanup = null, i = i.alternate, i != null && (i.refCleanup = null);
        }
      else if (typeof d == "function")
        try {
          d(null);
        } catch (x) {
          mt(i, l, x);
        }
      else d.current = null;
  }
  function $S(i) {
    var l = i.type, d = i.memoizedProps, m = i.stateNode;
    try {
      e: switch (l) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          d.autoFocus && m.focus();
          break e;
        case "img":
          d.src ? m.src = d.src : d.srcSet && (m.srcset = d.srcSet);
      }
    } catch (x) {
      mt(i, i.return, x);
    }
  }
  function C0(i, l, d) {
    try {
      var m = i.stateNode;
      OI(m, i.type, d, l), m[dn] = l;
    } catch (x) {
      mt(i, i.return, x);
    }
  }
  function BS(i) {
    return i.tag === 5 || i.tag === 3 || i.tag === 26 || i.tag === 27 && zi(i.type) || i.tag === 4;
  }
  function k0(i) {
    e: for (; ; ) {
      for (; i.sibling === null; ) {
        if (i.return === null || BS(i.return)) return null;
        i = i.return;
      }
      for (i.sibling.return = i.return, i = i.sibling; i.tag !== 5 && i.tag !== 6 && i.tag !== 18; ) {
        if (i.tag === 27 && zi(i.type) || i.flags & 2 || i.child === null || i.tag === 4) continue e;
        i.child.return = i, i = i.child;
      }
      if (!(i.flags & 2)) return i.stateNode;
    }
  }
  function T0(i, l, d) {
    var m = i.tag;
    if (m === 5 || m === 6)
      i = i.stateNode, l ? (d.nodeType === 9 ? d.body : d.nodeName === "HTML" ? d.ownerDocument.body : d).insertBefore(i, l) : (l = d.nodeType === 9 ? d.body : d.nodeName === "HTML" ? d.ownerDocument.body : d, l.appendChild(i), d = d._reactRootContainer, d != null || l.onclick !== null || (l.onclick = jd));
    else if (m !== 4 && (m === 27 && zi(i.type) && (d = i.stateNode, l = null), i = i.child, i !== null))
      for (T0(i, l, d), i = i.sibling; i !== null; )
        T0(i, l, d), i = i.sibling;
  }
  function Sd(i, l, d) {
    var m = i.tag;
    if (m === 5 || m === 6)
      i = i.stateNode, l ? d.insertBefore(i, l) : d.appendChild(i);
    else if (m !== 4 && (m === 27 && zi(i.type) && (d = i.stateNode), i = i.child, i !== null))
      for (Sd(i, l, d), i = i.sibling; i !== null; )
        Sd(i, l, d), i = i.sibling;
  }
  function HS(i) {
    var l = i.stateNode, d = i.memoizedProps;
    try {
      for (var m = i.type, x = l.attributes; x.length; )
        l.removeAttributeNode(x[0]);
      sn(l, m, d), l[Qt] = i, l[dn] = d;
    } catch (C) {
      mt(i, i.return, C);
    }
  }
  var Bo = !1, It = !1, A0 = !1, VS = typeof WeakSet == "function" ? WeakSet : Set, en = null;
  function fI(i, l) {
    if (i = i.containerInfo, Q0 = Bd, i = e_(i), kg(i)) {
      if ("selectionStart" in i)
        var d = {
          start: i.selectionStart,
          end: i.selectionEnd
        };
      else
        e: {
          d = (d = i.ownerDocument) && d.defaultView || window;
          var m = d.getSelection && d.getSelection();
          if (m && m.rangeCount !== 0) {
            d = m.anchorNode;
            var x = m.anchorOffset, C = m.focusNode;
            m = m.focusOffset;
            try {
              d.nodeType, C.nodeType;
            } catch {
              d = null;
              break e;
            }
            var D = 0, $ = -1, X = -1, ee = 0, ue = 0, de = i, ne = null;
            t: for (; ; ) {
              for (var re; de !== d || x !== 0 && de.nodeType !== 3 || ($ = D + x), de !== C || m !== 0 && de.nodeType !== 3 || (X = D + m), de.nodeType === 3 && (D += de.nodeValue.length), (re = de.firstChild) !== null; )
                ne = de, de = re;
              for (; ; ) {
                if (de === i) break t;
                if (ne === d && ++ee === x && ($ = D), ne === C && ++ue === m && (X = D), (re = de.nextSibling) !== null) break;
                de = ne, ne = de.parentNode;
              }
              de = re;
            }
            d = $ === -1 || X === -1 ? null : { start: $, end: X };
          } else d = null;
        }
      d = d || { start: 0, end: 0 };
    } else d = null;
    for (J0 = { focusedElem: i, selectionRange: d }, Bd = !1, en = l; en !== null; )
      if (l = en, i = l.child, (l.subtreeFlags & 1024) !== 0 && i !== null)
        i.return = l, en = i;
      else
        for (; en !== null; ) {
          switch (l = en, C = l.alternate, i = l.flags, l.tag) {
            case 0:
              break;
            case 11:
            case 15:
              break;
            case 1:
              if ((i & 1024) !== 0 && C !== null) {
                i = void 0, d = l, x = C.memoizedProps, C = C.memoizedState, m = d.stateNode;
                try {
                  var Le = ka(
                    d.type,
                    x,
                    d.elementType === d.type
                  );
                  i = m.getSnapshotBeforeUpdate(
                    Le,
                    C
                  ), m.__reactInternalSnapshotBeforeUpdate = i;
                } catch (Pe) {
                  mt(
                    d,
                    d.return,
                    Pe
                  );
                }
              }
              break;
            case 3:
              if ((i & 1024) !== 0) {
                if (i = l.stateNode.containerInfo, d = i.nodeType, d === 9)
                  ny(i);
                else if (d === 1)
                  switch (i.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      ny(i);
                      break;
                    default:
                      i.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if ((i & 1024) !== 0) throw Error(r(163));
          }
          if (i = l.sibling, i !== null) {
            i.return = l.return, en = i;
            break;
          }
          en = l.return;
        }
  }
  function US(i, l, d) {
    var m = d.flags;
    switch (d.tag) {
      case 0:
      case 11:
      case 15:
        Mi(i, d), m & 4 && Du(5, d);
        break;
      case 1:
        if (Mi(i, d), m & 4)
          if (i = d.stateNode, l === null)
            try {
              i.componentDidMount();
            } catch (D) {
              mt(d, d.return, D);
            }
          else {
            var x = ka(
              d.type,
              l.memoizedProps
            );
            l = l.memoizedState;
            try {
              i.componentDidUpdate(
                x,
                l,
                i.__reactInternalSnapshotBeforeUpdate
              );
            } catch (D) {
              mt(
                d,
                d.return,
                D
              );
            }
          }
        m & 64 && LS(d), m & 512 && ju(d, d.return);
        break;
      case 3:
        if (Mi(i, d), m & 64 && (i = d.updateQueue, i !== null)) {
          if (l = null, d.child !== null)
            switch (d.child.tag) {
              case 27:
              case 5:
                l = d.child.stateNode;
                break;
              case 1:
                l = d.child.stateNode;
            }
          try {
            C_(i, l);
          } catch (D) {
            mt(d, d.return, D);
          }
        }
        break;
      case 27:
        l === null && m & 4 && HS(d);
      case 26:
      case 5:
        Mi(i, d), l === null && m & 4 && $S(d), m & 512 && ju(d, d.return);
        break;
      case 12:
        Mi(i, d);
        break;
      case 13:
        Mi(i, d), m & 4 && YS(i, d), m & 64 && (i = d.memoizedState, i !== null && (i = i.dehydrated, i !== null && (d = xI.bind(
          null,
          d
        ), LI(i, d))));
        break;
      case 22:
        if (m = d.memoizedState !== null || Bo, !m) {
          l = l !== null && l.memoizedState !== null || It, x = Bo;
          var C = It;
          Bo = m, (It = l) && !C ? Oi(
            i,
            d,
            (d.subtreeFlags & 8772) !== 0
          ) : Mi(i, d), Bo = x, It = C;
        }
        break;
      case 30:
        break;
      default:
        Mi(i, d);
    }
  }
  function qS(i) {
    var l = i.alternate;
    l !== null && (i.alternate = null, qS(l)), i.child = null, i.deletions = null, i.sibling = null, i.tag === 5 && (l = i.stateNode, l !== null && Jl(l)), i.stateNode = null, i.return = null, i.dependencies = null, i.memoizedProps = null, i.memoizedState = null, i.pendingProps = null, i.stateNode = null, i.updateQueue = null;
  }
  var Et = null, jn = !1;
  function Ho(i, l, d) {
    for (d = d.child; d !== null; )
      GS(i, l, d), d = d.sibling;
  }
  function GS(i, l, d) {
    if (pe && typeof pe.onCommitFiberUnmount == "function")
      try {
        pe.onCommitFiberUnmount(se, d);
      } catch {
      }
    switch (d.tag) {
      case 26:
        It || Xr(d, l), Ho(
          i,
          l,
          d
        ), d.memoizedState ? d.memoizedState.count-- : d.stateNode && (d = d.stateNode, d.parentNode.removeChild(d));
        break;
      case 27:
        It || Xr(d, l);
        var m = Et, x = jn;
        zi(d.type) && (Et = d.stateNode, jn = !1), Ho(
          i,
          l,
          d
        ), Vu(d.stateNode), Et = m, jn = x;
        break;
      case 5:
        It || Xr(d, l);
      case 6:
        if (m = Et, x = jn, Et = null, Ho(
          i,
          l,
          d
        ), Et = m, jn = x, Et !== null)
          if (jn)
            try {
              (Et.nodeType === 9 ? Et.body : Et.nodeName === "HTML" ? Et.ownerDocument.body : Et).removeChild(d.stateNode);
            } catch (C) {
              mt(
                d,
                l,
                C
              );
            }
          else
            try {
              Et.removeChild(d.stateNode);
            } catch (C) {
              mt(
                d,
                l,
                C
              );
            }
        break;
      case 18:
        Et !== null && (jn ? (i = Et, jE(
          i.nodeType === 9 ? i.body : i.nodeName === "HTML" ? i.ownerDocument.body : i,
          d.stateNode
        ), Zu(i)) : jE(Et, d.stateNode));
        break;
      case 4:
        m = Et, x = jn, Et = d.stateNode.containerInfo, jn = !0, Ho(
          i,
          l,
          d
        ), Et = m, jn = x;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        It || Ri(2, d, l), It || Ri(4, d, l), Ho(
          i,
          l,
          d
        );
        break;
      case 1:
        It || (Xr(d, l), m = d.stateNode, typeof m.componentWillUnmount == "function" && FS(
          d,
          l,
          m
        )), Ho(
          i,
          l,
          d
        );
        break;
      case 21:
        Ho(
          i,
          l,
          d
        );
        break;
      case 22:
        It = (m = It) || d.memoizedState !== null, Ho(
          i,
          l,
          d
        ), It = m;
        break;
      default:
        Ho(
          i,
          l,
          d
        );
    }
  }
  function YS(i, l) {
    if (l.memoizedState === null && (i = l.alternate, i !== null && (i = i.memoizedState, i !== null && (i = i.dehydrated, i !== null))))
      try {
        Zu(i);
      } catch (d) {
        mt(l, l.return, d);
      }
  }
  function dI(i) {
    switch (i.tag) {
      case 13:
      case 19:
        var l = i.stateNode;
        return l === null && (l = i.stateNode = new VS()), l;
      case 22:
        return i = i.stateNode, l = i._retryCache, l === null && (l = i._retryCache = new VS()), l;
      default:
        throw Error(r(435, i.tag));
    }
  }
  function R0(i, l) {
    var d = dI(i);
    l.forEach(function(m) {
      var x = wI.bind(null, i, m);
      d.has(m) || (d.add(m), m.then(x, x));
    });
  }
  function Xn(i, l) {
    var d = l.deletions;
    if (d !== null)
      for (var m = 0; m < d.length; m++) {
        var x = d[m], C = i, D = l, $ = D;
        e: for (; $ !== null; ) {
          switch ($.tag) {
            case 27:
              if (zi($.type)) {
                Et = $.stateNode, jn = !1;
                break e;
              }
              break;
            case 5:
              Et = $.stateNode, jn = !1;
              break e;
            case 3:
            case 4:
              Et = $.stateNode.containerInfo, jn = !0;
              break e;
          }
          $ = $.return;
        }
        if (Et === null) throw Error(r(160));
        GS(C, D, x), Et = null, jn = !1, C = x.alternate, C !== null && (C.return = null), x.return = null;
      }
    if (l.subtreeFlags & 13878)
      for (l = l.child; l !== null; )
        WS(l, i), l = l.sibling;
  }
  var Or = null;
  function WS(i, l) {
    var d = i.alternate, m = i.flags;
    switch (i.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Xn(l, i), Kn(i), m & 4 && (Ri(3, i, i.return), Du(3, i), Ri(5, i, i.return));
        break;
      case 1:
        Xn(l, i), Kn(i), m & 512 && (It || d === null || Xr(d, d.return)), m & 64 && Bo && (i = i.updateQueue, i !== null && (m = i.callbacks, m !== null && (d = i.shared.hiddenCallbacks, i.shared.hiddenCallbacks = d === null ? m : d.concat(m))));
        break;
      case 26:
        var x = Or;
        if (Xn(l, i), Kn(i), m & 512 && (It || d === null || Xr(d, d.return)), m & 4) {
          var C = d !== null ? d.memoizedState : null;
          if (m = i.memoizedState, d === null)
            if (m === null)
              if (i.stateNode === null) {
                e: {
                  m = i.type, d = i.memoizedProps, x = x.ownerDocument || x;
                  t: switch (m) {
                    case "title":
                      C = x.getElementsByTagName("title")[0], (!C || C[da] || C[Qt] || C.namespaceURI === "http://www.w3.org/2000/svg" || C.hasAttribute("itemprop")) && (C = x.createElement(m), x.head.insertBefore(
                        C,
                        x.querySelector("head > title")
                      )), sn(C, m, d), C[Qt] = i, Bt(C), m = C;
                      break e;
                    case "link":
                      var D = HE(
                        "link",
                        "href",
                        x
                      ).get(m + (d.href || ""));
                      if (D) {
                        for (var $ = 0; $ < D.length; $++)
                          if (C = D[$], C.getAttribute("href") === (d.href == null || d.href === "" ? null : d.href) && C.getAttribute("rel") === (d.rel == null ? null : d.rel) && C.getAttribute("title") === (d.title == null ? null : d.title) && C.getAttribute("crossorigin") === (d.crossOrigin == null ? null : d.crossOrigin)) {
                            D.splice($, 1);
                            break t;
                          }
                      }
                      C = x.createElement(m), sn(C, m, d), x.head.appendChild(C);
                      break;
                    case "meta":
                      if (D = HE(
                        "meta",
                        "content",
                        x
                      ).get(m + (d.content || ""))) {
                        for ($ = 0; $ < D.length; $++)
                          if (C = D[$], C.getAttribute("content") === (d.content == null ? null : "" + d.content) && C.getAttribute("name") === (d.name == null ? null : d.name) && C.getAttribute("property") === (d.property == null ? null : d.property) && C.getAttribute("http-equiv") === (d.httpEquiv == null ? null : d.httpEquiv) && C.getAttribute("charset") === (d.charSet == null ? null : d.charSet)) {
                            D.splice($, 1);
                            break t;
                          }
                      }
                      C = x.createElement(m), sn(C, m, d), x.head.appendChild(C);
                      break;
                    default:
                      throw Error(r(468, m));
                  }
                  C[Qt] = i, Bt(C), m = C;
                }
                i.stateNode = m;
              } else
                VE(
                  x,
                  i.type,
                  i.stateNode
                );
            else
              i.stateNode = BE(
                x,
                m,
                i.memoizedProps
              );
          else
            C !== m ? (C === null ? d.stateNode !== null && (d = d.stateNode, d.parentNode.removeChild(d)) : C.count--, m === null ? VE(
              x,
              i.type,
              i.stateNode
            ) : BE(
              x,
              m,
              i.memoizedProps
            )) : m === null && i.stateNode !== null && C0(
              i,
              i.memoizedProps,
              d.memoizedProps
            );
        }
        break;
      case 27:
        Xn(l, i), Kn(i), m & 512 && (It || d === null || Xr(d, d.return)), d !== null && m & 4 && C0(
          i,
          i.memoizedProps,
          d.memoizedProps
        );
        break;
      case 5:
        if (Xn(l, i), Kn(i), m & 512 && (It || d === null || Xr(d, d.return)), i.flags & 32) {
          x = i.stateNode;
          try {
            cs(x, "");
          } catch (re) {
            mt(i, i.return, re);
          }
        }
        m & 4 && i.stateNode != null && (x = i.memoizedProps, C0(
          i,
          x,
          d !== null ? d.memoizedProps : x
        )), m & 1024 && (A0 = !0);
        break;
      case 6:
        if (Xn(l, i), Kn(i), m & 4) {
          if (i.stateNode === null)
            throw Error(r(162));
          m = i.memoizedProps, d = i.stateNode;
          try {
            d.nodeValue = m;
          } catch (re) {
            mt(i, i.return, re);
          }
        }
        break;
      case 3:
        if (Ld = null, x = Or, Or = Id(l.containerInfo), Xn(l, i), Or = x, Kn(i), m & 4 && d !== null && d.memoizedState.isDehydrated)
          try {
            Zu(l.containerInfo);
          } catch (re) {
            mt(i, i.return, re);
          }
        A0 && (A0 = !1, XS(i));
        break;
      case 4:
        m = Or, Or = Id(
          i.stateNode.containerInfo
        ), Xn(l, i), Kn(i), Or = m;
        break;
      case 12:
        Xn(l, i), Kn(i);
        break;
      case 13:
        Xn(l, i), Kn(i), i.child.flags & 8192 && i.memoizedState !== null != (d !== null && d.memoizedState !== null) && (P0 = ct()), m & 4 && (m = i.updateQueue, m !== null && (i.updateQueue = null, R0(i, m)));
        break;
      case 22:
        x = i.memoizedState !== null;
        var X = d !== null && d.memoizedState !== null, ee = Bo, ue = It;
        if (Bo = ee || x, It = ue || X, Xn(l, i), It = ue, Bo = ee, Kn(i), m & 8192)
          e: for (l = i.stateNode, l._visibility = x ? l._visibility & -2 : l._visibility | 1, x && (d === null || X || Bo || It || Ta(i)), d = null, l = i; ; ) {
            if (l.tag === 5 || l.tag === 26) {
              if (d === null) {
                X = d = l;
                try {
                  if (C = X.stateNode, x)
                    D = C.style, typeof D.setProperty == "function" ? D.setProperty("display", "none", "important") : D.display = "none";
                  else {
                    $ = X.stateNode;
                    var de = X.memoizedProps.style, ne = de != null && de.hasOwnProperty("display") ? de.display : null;
                    $.style.display = ne == null || typeof ne == "boolean" ? "" : ("" + ne).trim();
                  }
                } catch (re) {
                  mt(X, X.return, re);
                }
              }
            } else if (l.tag === 6) {
              if (d === null) {
                X = l;
                try {
                  X.stateNode.nodeValue = x ? "" : X.memoizedProps;
                } catch (re) {
                  mt(X, X.return, re);
                }
              }
            } else if ((l.tag !== 22 && l.tag !== 23 || l.memoizedState === null || l === i) && l.child !== null) {
              l.child.return = l, l = l.child;
              continue;
            }
            if (l === i) break e;
            for (; l.sibling === null; ) {
              if (l.return === null || l.return === i) break e;
              d === l && (d = null), l = l.return;
            }
            d === l && (d = null), l.sibling.return = l.return, l = l.sibling;
          }
        m & 4 && (m = i.updateQueue, m !== null && (d = m.retryQueue, d !== null && (m.retryQueue = null, R0(i, d))));
        break;
      case 19:
        Xn(l, i), Kn(i), m & 4 && (m = i.updateQueue, m !== null && (i.updateQueue = null, R0(i, m)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        Xn(l, i), Kn(i);
    }
  }
  function Kn(i) {
    var l = i.flags;
    if (l & 2) {
      try {
        for (var d, m = i.return; m !== null; ) {
          if (BS(m)) {
            d = m;
            break;
          }
          m = m.return;
        }
        if (d == null) throw Error(r(160));
        switch (d.tag) {
          case 27:
            var x = d.stateNode, C = k0(i);
            Sd(i, C, x);
            break;
          case 5:
            var D = d.stateNode;
            d.flags & 32 && (cs(D, ""), d.flags &= -33);
            var $ = k0(i);
            Sd(i, $, D);
            break;
          case 3:
          case 4:
            var X = d.stateNode.containerInfo, ee = k0(i);
            T0(
              i,
              ee,
              X
            );
            break;
          default:
            throw Error(r(161));
        }
      } catch (ue) {
        mt(i, i.return, ue);
      }
      i.flags &= -3;
    }
    l & 4096 && (i.flags &= -4097);
  }
  function XS(i) {
    if (i.subtreeFlags & 1024)
      for (i = i.child; i !== null; ) {
        var l = i;
        XS(l), l.tag === 5 && l.flags & 1024 && l.stateNode.reset(), i = i.sibling;
      }
  }
  function Mi(i, l) {
    if (l.subtreeFlags & 8772)
      for (l = l.child; l !== null; )
        US(i, l.alternate, l), l = l.sibling;
  }
  function Ta(i) {
    for (i = i.child; i !== null; ) {
      var l = i;
      switch (l.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Ri(4, l, l.return), Ta(l);
          break;
        case 1:
          Xr(l, l.return);
          var d = l.stateNode;
          typeof d.componentWillUnmount == "function" && FS(
            l,
            l.return,
            d
          ), Ta(l);
          break;
        case 27:
          Vu(l.stateNode);
        case 26:
        case 5:
          Xr(l, l.return), Ta(l);
          break;
        case 22:
          l.memoizedState === null && Ta(l);
          break;
        case 30:
          Ta(l);
          break;
        default:
          Ta(l);
      }
      i = i.sibling;
    }
  }
  function Oi(i, l, d) {
    for (d = d && (l.subtreeFlags & 8772) !== 0, l = l.child; l !== null; ) {
      var m = l.alternate, x = i, C = l, D = C.flags;
      switch (C.tag) {
        case 0:
        case 11:
        case 15:
          Oi(
            x,
            C,
            d
          ), Du(4, C);
          break;
        case 1:
          if (Oi(
            x,
            C,
            d
          ), m = C, x = m.stateNode, typeof x.componentDidMount == "function")
            try {
              x.componentDidMount();
            } catch (ee) {
              mt(m, m.return, ee);
            }
          if (m = C, x = m.updateQueue, x !== null) {
            var $ = m.stateNode;
            try {
              var X = x.shared.hiddenCallbacks;
              if (X !== null)
                for (x.shared.hiddenCallbacks = null, x = 0; x < X.length; x++)
                  E_(X[x], $);
            } catch (ee) {
              mt(m, m.return, ee);
            }
          }
          d && D & 64 && LS(C), ju(C, C.return);
          break;
        case 27:
          HS(C);
        case 26:
        case 5:
          Oi(
            x,
            C,
            d
          ), d && m === null && D & 4 && $S(C), ju(C, C.return);
          break;
        case 12:
          Oi(
            x,
            C,
            d
          );
          break;
        case 13:
          Oi(
            x,
            C,
            d
          ), d && D & 4 && YS(x, C);
          break;
        case 22:
          C.memoizedState === null && Oi(
            x,
            C,
            d
          ), ju(C, C.return);
          break;
        case 30:
          break;
        default:
          Oi(
            x,
            C,
            d
          );
      }
      l = l.sibling;
    }
  }
  function M0(i, l) {
    var d = null;
    i !== null && i.memoizedState !== null && i.memoizedState.cachePool !== null && (d = i.memoizedState.cachePool.pool), i = null, l.memoizedState !== null && l.memoizedState.cachePool !== null && (i = l.memoizedState.cachePool.pool), i !== d && (i != null && i.refCount++, d != null && bu(d));
  }
  function O0(i, l) {
    i = null, l.alternate !== null && (i = l.alternate.memoizedState.cache), l = l.memoizedState.cache, l !== i && (l.refCount++, i != null && bu(i));
  }
  function Kr(i, l, d, m) {
    if (l.subtreeFlags & 10256)
      for (l = l.child; l !== null; )
        KS(
          i,
          l,
          d,
          m
        ), l = l.sibling;
  }
  function KS(i, l, d, m) {
    var x = l.flags;
    switch (l.tag) {
      case 0:
      case 11:
      case 15:
        Kr(
          i,
          l,
          d,
          m
        ), x & 2048 && Du(9, l);
        break;
      case 1:
        Kr(
          i,
          l,
          d,
          m
        );
        break;
      case 3:
        Kr(
          i,
          l,
          d,
          m
        ), x & 2048 && (i = null, l.alternate !== null && (i = l.alternate.memoizedState.cache), l = l.memoizedState.cache, l !== i && (l.refCount++, i != null && bu(i)));
        break;
      case 12:
        if (x & 2048) {
          Kr(
            i,
            l,
            d,
            m
          ), i = l.stateNode;
          try {
            var C = l.memoizedProps, D = C.id, $ = C.onPostCommit;
            typeof $ == "function" && $(
              D,
              l.alternate === null ? "mount" : "update",
              i.passiveEffectDuration,
              -0
            );
          } catch (X) {
            mt(l, l.return, X);
          }
        } else
          Kr(
            i,
            l,
            d,
            m
          );
        break;
      case 13:
        Kr(
          i,
          l,
          d,
          m
        );
        break;
      case 23:
        break;
      case 22:
        C = l.stateNode, D = l.alternate, l.memoizedState !== null ? C._visibility & 2 ? Kr(
          i,
          l,
          d,
          m
        ) : Pu(i, l) : C._visibility & 2 ? Kr(
          i,
          l,
          d,
          m
        ) : (C._visibility |= 2, Rs(
          i,
          l,
          d,
          m,
          (l.subtreeFlags & 10256) !== 0
        )), x & 2048 && M0(D, l);
        break;
      case 24:
        Kr(
          i,
          l,
          d,
          m
        ), x & 2048 && O0(l.alternate, l);
        break;
      default:
        Kr(
          i,
          l,
          d,
          m
        );
    }
  }
  function Rs(i, l, d, m, x) {
    for (x = x && (l.subtreeFlags & 10256) !== 0, l = l.child; l !== null; ) {
      var C = i, D = l, $ = d, X = m, ee = D.flags;
      switch (D.tag) {
        case 0:
        case 11:
        case 15:
          Rs(
            C,
            D,
            $,
            X,
            x
          ), Du(8, D);
          break;
        case 23:
          break;
        case 22:
          var ue = D.stateNode;
          D.memoizedState !== null ? ue._visibility & 2 ? Rs(
            C,
            D,
            $,
            X,
            x
          ) : Pu(
            C,
            D
          ) : (ue._visibility |= 2, Rs(
            C,
            D,
            $,
            X,
            x
          )), x && ee & 2048 && M0(
            D.alternate,
            D
          );
          break;
        case 24:
          Rs(
            C,
            D,
            $,
            X,
            x
          ), x && ee & 2048 && O0(D.alternate, D);
          break;
        default:
          Rs(
            C,
            D,
            $,
            X,
            x
          );
      }
      l = l.sibling;
    }
  }
  function Pu(i, l) {
    if (l.subtreeFlags & 10256)
      for (l = l.child; l !== null; ) {
        var d = i, m = l, x = m.flags;
        switch (m.tag) {
          case 22:
            Pu(d, m), x & 2048 && M0(
              m.alternate,
              m
            );
            break;
          case 24:
            Pu(d, m), x & 2048 && O0(m.alternate, m);
            break;
          default:
            Pu(d, m);
        }
        l = l.sibling;
      }
  }
  var Iu = 8192;
  function Ms(i) {
    if (i.subtreeFlags & Iu)
      for (i = i.child; i !== null; )
        ZS(i), i = i.sibling;
  }
  function ZS(i) {
    switch (i.tag) {
      case 26:
        Ms(i), i.flags & Iu && i.memoizedState !== null && ZI(
          Or,
          i.memoizedState,
          i.memoizedProps
        );
        break;
      case 5:
        Ms(i);
        break;
      case 3:
      case 4:
        var l = Or;
        Or = Id(i.stateNode.containerInfo), Ms(i), Or = l;
        break;
      case 22:
        i.memoizedState === null && (l = i.alternate, l !== null && l.memoizedState !== null ? (l = Iu, Iu = 16777216, Ms(i), Iu = l) : Ms(i));
        break;
      default:
        Ms(i);
    }
  }
  function QS(i) {
    var l = i.alternate;
    if (l !== null && (i = l.child, i !== null)) {
      l.child = null;
      do
        l = i.sibling, i.sibling = null, i = l;
      while (i !== null);
    }
  }
  function zu(i) {
    var l = i.deletions;
    if ((i.flags & 16) !== 0) {
      if (l !== null)
        for (var d = 0; d < l.length; d++) {
          var m = l[d];
          en = m, eE(
            m,
            i
          );
        }
      QS(i);
    }
    if (i.subtreeFlags & 10256)
      for (i = i.child; i !== null; )
        JS(i), i = i.sibling;
  }
  function JS(i) {
    switch (i.tag) {
      case 0:
      case 11:
      case 15:
        zu(i), i.flags & 2048 && Ri(9, i, i.return);
        break;
      case 3:
        zu(i);
        break;
      case 12:
        zu(i);
        break;
      case 22:
        var l = i.stateNode;
        i.memoizedState !== null && l._visibility & 2 && (i.return === null || i.return.tag !== 13) ? (l._visibility &= -3, Ed(i)) : zu(i);
        break;
      default:
        zu(i);
    }
  }
  function Ed(i) {
    var l = i.deletions;
    if ((i.flags & 16) !== 0) {
      if (l !== null)
        for (var d = 0; d < l.length; d++) {
          var m = l[d];
          en = m, eE(
            m,
            i
          );
        }
      QS(i);
    }
    for (i = i.child; i !== null; ) {
      switch (l = i, l.tag) {
        case 0:
        case 11:
        case 15:
          Ri(8, l, l.return), Ed(l);
          break;
        case 22:
          d = l.stateNode, d._visibility & 2 && (d._visibility &= -3, Ed(l));
          break;
        default:
          Ed(l);
      }
      i = i.sibling;
    }
  }
  function eE(i, l) {
    for (; en !== null; ) {
      var d = en;
      switch (d.tag) {
        case 0:
        case 11:
        case 15:
          Ri(8, d, l);
          break;
        case 23:
        case 22:
          if (d.memoizedState !== null && d.memoizedState.cachePool !== null) {
            var m = d.memoizedState.cachePool.pool;
            m != null && m.refCount++;
          }
          break;
        case 24:
          bu(d.memoizedState.cache);
      }
      if (m = d.child, m !== null) m.return = d, en = m;
      else
        e: for (d = i; en !== null; ) {
          m = en;
          var x = m.sibling, C = m.return;
          if (qS(m), m === d) {
            en = null;
            break e;
          }
          if (x !== null) {
            x.return = C, en = x;
            break e;
          }
          en = C;
        }
    }
  }
  var hI = {
    getCacheForType: function(i) {
      var l = hn(Xt), d = l.data.get(i);
      return d === void 0 && (d = i(), l.data.set(i, d)), d;
    }
  }, pI = typeof WeakMap == "function" ? WeakMap : Map, lt = 0, xt = null, Ge = null, Ze = 0, ut = 0, Zn = null, Ni = !1, Os = !1, N0 = !1, Vo = 0, Ot = 0, Di = 0, Aa = 0, D0 = 0, vr = 0, Ns = 0, Lu = null, Pn = null, j0 = !1, P0 = 0, Cd = 1 / 0, kd = null, ji = null, an = 0, Pi = null, Ds = null, js = 0, I0 = 0, z0 = null, tE = null, Fu = 0, L0 = null;
  function Qn() {
    if ((lt & 2) !== 0 && Ze !== 0)
      return Ze & -Ze;
    if (I.T !== null) {
      var i = ws;
      return i !== 0 ? i : q0();
    }
    return Df();
  }
  function nE() {
    vr === 0 && (vr = (Ze & 536870912) === 0 || rt ? Mf() : 536870912);
    var i = yr.current;
    return i !== null && (i.flags |= 32), vr;
  }
  function Jn(i, l, d) {
    (i === xt && (ut === 2 || ut === 9) || i.cancelPendingCommit !== null) && (Ps(i, 0), Ii(
      i,
      Ze,
      vr,
      !1
    )), fa(i, d), ((lt & 2) === 0 || i !== xt) && (i === xt && ((lt & 2) === 0 && (Aa |= d), Ot === 4 && Ii(
      i,
      Ze,
      vr,
      !1
    )), Zr(i));
  }
  function rE(i, l, d) {
    if ((lt & 6) !== 0) throw Error(r(327));
    var m = !d && (l & 124) === 0 && (l & i.expiredLanes) === 0 || Rn(i, l), x = m ? yI(i, l) : B0(i, l, !0), C = m;
    do {
      if (x === 0) {
        Os && !m && Ii(i, l, 0, !1);
        break;
      } else {
        if (d = i.current.alternate, C && !mI(d)) {
          x = B0(i, l, !1), C = !1;
          continue;
        }
        if (x === 2) {
          if (C = l, i.errorRecoveryDisabledLanes & C)
            var D = 0;
          else
            D = i.pendingLanes & -536870913, D = D !== 0 ? D : D & 536870912 ? 536870912 : 0;
          if (D !== 0) {
            l = D;
            e: {
              var $ = i;
              x = Lu;
              var X = $.current.memoizedState.isDehydrated;
              if (X && (Ps($, D).flags |= 256), D = B0(
                $,
                D,
                !1
              ), D !== 2) {
                if (N0 && !X) {
                  $.errorRecoveryDisabledLanes |= C, Aa |= C, x = 4;
                  break e;
                }
                C = Pn, Pn = x, C !== null && (Pn === null ? Pn = C : Pn.push.apply(
                  Pn,
                  C
                ));
              }
              x = D;
            }
            if (C = !1, x !== 2) continue;
          }
        }
        if (x === 1) {
          Ps(i, 0), Ii(i, l, 0, !0);
          break;
        }
        e: {
          switch (m = i, C = x, C) {
            case 0:
            case 1:
              throw Error(r(345));
            case 4:
              if ((l & 4194048) !== l) break;
            case 6:
              Ii(
                m,
                l,
                vr,
                !Ni
              );
              break e;
            case 2:
              Pn = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(r(329));
          }
          if ((l & 62914560) === l && (x = P0 + 300 - ct(), 10 < x)) {
            if (Ii(
              m,
              l,
              vr,
              !Ni
            ), $t(m, 0, !0) !== 0) break e;
            m.timeoutHandle = NE(
              oE.bind(
                null,
                m,
                d,
                Pn,
                kd,
                j0,
                l,
                vr,
                Aa,
                Ns,
                Ni,
                C,
                2,
                -0,
                0
              ),
              x
            );
            break e;
          }
          oE(
            m,
            d,
            Pn,
            kd,
            j0,
            l,
            vr,
            Aa,
            Ns,
            Ni,
            C,
            0,
            -0,
            0
          );
        }
      }
      break;
    } while (!0);
    Zr(i);
  }
  function oE(i, l, d, m, x, C, D, $, X, ee, ue, de, ne, re) {
    if (i.timeoutHandle = -1, de = l.subtreeFlags, (de & 8192 || (de & 16785408) === 16785408) && (Gu = { stylesheets: null, count: 0, unsuspend: KI }, ZS(l), de = QI(), de !== null)) {
      i.cancelPendingCommit = de(
        fE.bind(
          null,
          i,
          l,
          C,
          d,
          m,
          x,
          D,
          $,
          X,
          ue,
          1,
          ne,
          re
        )
      ), Ii(i, C, D, !ee);
      return;
    }
    fE(
      i,
      l,
      C,
      d,
      m,
      x,
      D,
      $,
      X
    );
  }
  function mI(i) {
    for (var l = i; ; ) {
      var d = l.tag;
      if ((d === 0 || d === 11 || d === 15) && l.flags & 16384 && (d = l.updateQueue, d !== null && (d = d.stores, d !== null)))
        for (var m = 0; m < d.length; m++) {
          var x = d[m], C = x.getSnapshot;
          x = x.value;
          try {
            if (!Yn(C(), x)) return !1;
          } catch {
            return !1;
          }
        }
      if (d = l.child, l.subtreeFlags & 16384 && d !== null)
        d.return = l, l = d;
      else {
        if (l === i) break;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === i) return !0;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
    }
    return !0;
  }
  function Ii(i, l, d, m) {
    l &= ~D0, l &= ~Aa, i.suspendedLanes |= l, i.pingedLanes &= ~l, m && (i.warmLanes |= l), m = i.expirationTimes;
    for (var x = l; 0 < x; ) {
      var C = 31 - je(x), D = 1 << C;
      m[C] = -1, x &= ~D;
    }
    d !== 0 && Nf(i, d, l);
  }
  function Td() {
    return (lt & 6) === 0 ? ($u(0), !1) : !0;
  }
  function F0() {
    if (Ge !== null) {
      if (ut === 0)
        var i = Ge.return;
      else
        i = Ge, Po = _a = null, n0(i), Ts = null, Mu = 0, i = Ge;
      for (; i !== null; )
        zS(i.alternate, i), i = i.return;
      Ge = null;
    }
  }
  function Ps(i, l) {
    var d = i.timeoutHandle;
    d !== -1 && (i.timeoutHandle = -1, DI(d)), d = i.cancelPendingCommit, d !== null && (i.cancelPendingCommit = null, d()), F0(), xt = i, Ge = d = No(i.current, null), Ze = l, ut = 0, Zn = null, Ni = !1, Os = Rn(i, l), N0 = !1, Ns = vr = D0 = Aa = Di = Ot = 0, Pn = Lu = null, j0 = !1, (l & 8) !== 0 && (l |= l & 32);
    var m = i.entangledLanes;
    if (m !== 0)
      for (i = i.entanglements, m &= l; 0 < m; ) {
        var x = 31 - je(m), C = 1 << x;
        l |= i[x], m &= ~C;
      }
    return Vo = l, Xf(), d;
  }
  function iE(i, l) {
    He = null, I.H = pd, l === wu || l === od ? (l = __(), ut = 3) : l === b_ ? (l = __(), ut = 4) : ut = l === SS ? 8 : l !== null && typeof l == "object" && typeof l.then == "function" ? 6 : 1, Zn = l, Ge === null && (Ot = 1, bd(
      i,
      hr(l, i.current)
    ));
  }
  function aE() {
    var i = I.H;
    return I.H = pd, i === null ? pd : i;
  }
  function sE() {
    var i = I.A;
    return I.A = hI, i;
  }
  function $0() {
    Ot = 4, Ni || (Ze & 4194048) !== Ze && yr.current !== null || (Os = !0), (Di & 134217727) === 0 && (Aa & 134217727) === 0 || xt === null || Ii(
      xt,
      Ze,
      vr,
      !1
    );
  }
  function B0(i, l, d) {
    var m = lt;
    lt |= 2;
    var x = aE(), C = sE();
    (xt !== i || Ze !== l) && (kd = null, Ps(i, l)), l = !1;
    var D = Ot;
    e: do
      try {
        if (ut !== 0 && Ge !== null) {
          var $ = Ge, X = Zn;
          switch (ut) {
            case 8:
              F0(), D = 6;
              break e;
            case 3:
            case 2:
            case 9:
            case 6:
              yr.current === null && (l = !0);
              var ee = ut;
              if (ut = 0, Zn = null, Is(i, $, X, ee), d && Os) {
                D = 0;
                break e;
              }
              break;
            default:
              ee = ut, ut = 0, Zn = null, Is(i, $, X, ee);
          }
        }
        gI(), D = Ot;
        break;
      } catch (ue) {
        iE(i, ue);
      }
    while (!0);
    return l && i.shellSuspendCounter++, Po = _a = null, lt = m, I.H = x, I.A = C, Ge === null && (xt = null, Ze = 0, Xf()), D;
  }
  function gI() {
    for (; Ge !== null; ) lE(Ge);
  }
  function yI(i, l) {
    var d = lt;
    lt |= 2;
    var m = aE(), x = sE();
    xt !== i || Ze !== l ? (kd = null, Cd = ct() + 500, Ps(i, l)) : Os = Rn(
      i,
      l
    );
    e: do
      try {
        if (ut !== 0 && Ge !== null) {
          l = Ge;
          var C = Zn;
          t: switch (ut) {
            case 1:
              ut = 0, Zn = null, Is(i, l, C, 1);
              break;
            case 2:
            case 9:
              if (x_(C)) {
                ut = 0, Zn = null, uE(l);
                break;
              }
              l = function() {
                ut !== 2 && ut !== 9 || xt !== i || (ut = 7), Zr(i);
              }, C.then(l, l);
              break e;
            case 3:
              ut = 7;
              break e;
            case 4:
              ut = 5;
              break e;
            case 7:
              x_(C) ? (ut = 0, Zn = null, uE(l)) : (ut = 0, Zn = null, Is(i, l, C, 7));
              break;
            case 5:
              var D = null;
              switch (Ge.tag) {
                case 26:
                  D = Ge.memoizedState;
                case 5:
                case 27:
                  var $ = Ge;
                  if (!D || UE(D)) {
                    ut = 0, Zn = null;
                    var X = $.sibling;
                    if (X !== null) Ge = X;
                    else {
                      var ee = $.return;
                      ee !== null ? (Ge = ee, Ad(ee)) : Ge = null;
                    }
                    break t;
                  }
              }
              ut = 0, Zn = null, Is(i, l, C, 5);
              break;
            case 6:
              ut = 0, Zn = null, Is(i, l, C, 6);
              break;
            case 8:
              F0(), Ot = 6;
              break e;
            default:
              throw Error(r(462));
          }
        }
        vI();
        break;
      } catch (ue) {
        iE(i, ue);
      }
    while (!0);
    return Po = _a = null, I.H = m, I.A = x, lt = d, Ge !== null ? 0 : (xt = null, Ze = 0, Xf(), Ot);
  }
  function vI() {
    for (; Ge !== null && !Xe(); )
      lE(Ge);
  }
  function lE(i) {
    var l = PS(i.alternate, i, Vo);
    i.memoizedProps = i.pendingProps, l === null ? Ad(i) : Ge = l;
  }
  function uE(i) {
    var l = i, d = l.alternate;
    switch (l.tag) {
      case 15:
      case 0:
        l = RS(
          d,
          l,
          l.pendingProps,
          l.type,
          void 0,
          Ze
        );
        break;
      case 11:
        l = RS(
          d,
          l,
          l.pendingProps,
          l.type.render,
          l.ref,
          Ze
        );
        break;
      case 5:
        n0(l);
      default:
        zS(d, l), l = Ge = c_(l, Vo), l = PS(d, l, Vo);
    }
    i.memoizedProps = i.pendingProps, l === null ? Ad(i) : Ge = l;
  }
  function Is(i, l, d, m) {
    Po = _a = null, n0(l), Ts = null, Mu = 0;
    var x = l.return;
    try {
      if (sI(
        i,
        x,
        l,
        d,
        Ze
      )) {
        Ot = 1, bd(
          i,
          hr(d, i.current)
        ), Ge = null;
        return;
      }
    } catch (C) {
      if (x !== null) throw Ge = x, C;
      Ot = 1, bd(
        i,
        hr(d, i.current)
      ), Ge = null;
      return;
    }
    l.flags & 32768 ? (rt || m === 1 ? i = !0 : Os || (Ze & 536870912) !== 0 ? i = !1 : (Ni = i = !0, (m === 2 || m === 9 || m === 3 || m === 6) && (m = yr.current, m !== null && m.tag === 13 && (m.flags |= 16384))), cE(l, i)) : Ad(l);
  }
  function Ad(i) {
    var l = i;
    do {
      if ((l.flags & 32768) !== 0) {
        cE(
          l,
          Ni
        );
        return;
      }
      i = l.return;
      var d = uI(
        l.alternate,
        l,
        Vo
      );
      if (d !== null) {
        Ge = d;
        return;
      }
      if (l = l.sibling, l !== null) {
        Ge = l;
        return;
      }
      Ge = l = i;
    } while (l !== null);
    Ot === 0 && (Ot = 5);
  }
  function cE(i, l) {
    do {
      var d = cI(i.alternate, i);
      if (d !== null) {
        d.flags &= 32767, Ge = d;
        return;
      }
      if (d = i.return, d !== null && (d.flags |= 32768, d.subtreeFlags = 0, d.deletions = null), !l && (i = i.sibling, i !== null)) {
        Ge = i;
        return;
      }
      Ge = i = d;
    } while (i !== null);
    Ot = 6, Ge = null;
  }
  function fE(i, l, d, m, x, C, D, $, X) {
    i.cancelPendingCommit = null;
    do
      Rd();
    while (an !== 0);
    if ((lt & 6) !== 0) throw Error(r(327));
    if (l !== null) {
      if (l === i.current) throw Error(r(177));
      if (C = l.lanes | l.childLanes, C |= Og, og(
        i,
        d,
        C,
        D,
        $,
        X
      ), i === xt && (Ge = xt = null, Ze = 0), Ds = l, Pi = i, js = d, I0 = C, z0 = x, tE = m, (l.subtreeFlags & 10256) !== 0 || (l.flags & 10256) !== 0 ? (i.callbackNode = null, i.callbackPriority = 0, _I(qn, function() {
        return gE(), null;
      })) : (i.callbackNode = null, i.callbackPriority = 0), m = (l.flags & 13878) !== 0, (l.subtreeFlags & 13878) !== 0 || m) {
        m = I.T, I.T = null, x = U.p, U.p = 2, D = lt, lt |= 4;
        try {
          fI(i, l, d);
        } finally {
          lt = D, U.p = x, I.T = m;
        }
      }
      an = 1, dE(), hE(), pE();
    }
  }
  function dE() {
    if (an === 1) {
      an = 0;
      var i = Pi, l = Ds, d = (l.flags & 13878) !== 0;
      if ((l.subtreeFlags & 13878) !== 0 || d) {
        d = I.T, I.T = null;
        var m = U.p;
        U.p = 2;
        var x = lt;
        lt |= 4;
        try {
          WS(l, i);
          var C = J0, D = e_(i.containerInfo), $ = C.focusedElem, X = C.selectionRange;
          if (D !== $ && $ && $.ownerDocument && Jw(
            $.ownerDocument.documentElement,
            $
          )) {
            if (X !== null && kg($)) {
              var ee = X.start, ue = X.end;
              if (ue === void 0 && (ue = ee), "selectionStart" in $)
                $.selectionStart = ee, $.selectionEnd = Math.min(
                  ue,
                  $.value.length
                );
              else {
                var de = $.ownerDocument || document, ne = de && de.defaultView || window;
                if (ne.getSelection) {
                  var re = ne.getSelection(), Le = $.textContent.length, Pe = Math.min(X.start, Le), ht = X.end === void 0 ? Pe : Math.min(X.end, Le);
                  !re.extend && Pe > ht && (D = ht, ht = Pe, Pe = D);
                  var Q = Qw(
                    $,
                    Pe
                  ), K = Qw(
                    $,
                    ht
                  );
                  if (Q && K && (re.rangeCount !== 1 || re.anchorNode !== Q.node || re.anchorOffset !== Q.offset || re.focusNode !== K.node || re.focusOffset !== K.offset)) {
                    var J = de.createRange();
                    J.setStart(Q.node, Q.offset), re.removeAllRanges(), Pe > ht ? (re.addRange(J), re.extend(K.node, K.offset)) : (J.setEnd(K.node, K.offset), re.addRange(J));
                  }
                }
              }
            }
            for (de = [], re = $; re = re.parentNode; )
              re.nodeType === 1 && de.push({
                element: re,
                left: re.scrollLeft,
                top: re.scrollTop
              });
            for (typeof $.focus == "function" && $.focus(), $ = 0; $ < de.length; $++) {
              var ce = de[$];
              ce.element.scrollLeft = ce.left, ce.element.scrollTop = ce.top;
            }
          }
          Bd = !!Q0, J0 = Q0 = null;
        } finally {
          lt = x, U.p = m, I.T = d;
        }
      }
      i.current = l, an = 2;
    }
  }
  function hE() {
    if (an === 2) {
      an = 0;
      var i = Pi, l = Ds, d = (l.flags & 8772) !== 0;
      if ((l.subtreeFlags & 8772) !== 0 || d) {
        d = I.T, I.T = null;
        var m = U.p;
        U.p = 2;
        var x = lt;
        lt |= 4;
        try {
          US(i, l.alternate, l);
        } finally {
          lt = x, U.p = m, I.T = d;
        }
      }
      an = 3;
    }
  }
  function pE() {
    if (an === 4 || an === 3) {
      an = 0, St();
      var i = Pi, l = Ds, d = js, m = tE;
      (l.subtreeFlags & 10256) !== 0 || (l.flags & 10256) !== 0 ? an = 5 : (an = 0, Ds = Pi = null, mE(i, i.pendingLanes));
      var x = i.pendingLanes;
      if (x === 0 && (ji = null), Zl(d), l = l.stateNode, pe && typeof pe.onCommitFiberRoot == "function")
        try {
          pe.onCommitFiberRoot(
            se,
            l,
            void 0,
            (l.current.flags & 128) === 128
          );
        } catch {
        }
      if (m !== null) {
        l = I.T, x = U.p, U.p = 2, I.T = null;
        try {
          for (var C = i.onRecoverableError, D = 0; D < m.length; D++) {
            var $ = m[D];
            C($.value, {
              componentStack: $.stack
            });
          }
        } finally {
          I.T = l, U.p = x;
        }
      }
      (js & 3) !== 0 && Rd(), Zr(i), x = i.pendingLanes, (d & 4194090) !== 0 && (x & 42) !== 0 ? i === L0 ? Fu++ : (Fu = 0, L0 = i) : Fu = 0, $u(0);
    }
  }
  function mE(i, l) {
    (i.pooledCacheLanes &= l) === 0 && (l = i.pooledCache, l != null && (i.pooledCache = null, bu(l)));
  }
  function Rd(i) {
    return dE(), hE(), pE(), gE();
  }
  function gE() {
    if (an !== 5) return !1;
    var i = Pi, l = I0;
    I0 = 0;
    var d = Zl(js), m = I.T, x = U.p;
    try {
      U.p = 32 > d ? 32 : d, I.T = null, d = z0, z0 = null;
      var C = Pi, D = js;
      if (an = 0, Ds = Pi = null, js = 0, (lt & 6) !== 0) throw Error(r(331));
      var $ = lt;
      if (lt |= 4, JS(C.current), KS(
        C,
        C.current,
        D,
        d
      ), lt = $, $u(0, !1), pe && typeof pe.onPostCommitFiberRoot == "function")
        try {
          pe.onPostCommitFiberRoot(se, C);
        } catch {
        }
      return !0;
    } finally {
      U.p = x, I.T = m, mE(i, l);
    }
  }
  function yE(i, l, d) {
    l = hr(d, l), l = g0(i.stateNode, l, 2), i = Ci(i, l, 2), i !== null && (fa(i, 2), Zr(i));
  }
  function mt(i, l, d) {
    if (i.tag === 3)
      yE(i, i, d);
    else
      for (; l !== null; ) {
        if (l.tag === 3) {
          yE(
            l,
            i,
            d
          );
          break;
        } else if (l.tag === 1) {
          var m = l.stateNode;
          if (typeof l.type.getDerivedStateFromError == "function" || typeof m.componentDidCatch == "function" && (ji === null || !ji.has(m))) {
            i = hr(d, i), d = wS(2), m = Ci(l, d, 2), m !== null && (_S(
              d,
              m,
              l,
              i
            ), fa(m, 2), Zr(m));
            break;
          }
        }
        l = l.return;
      }
  }
  function H0(i, l, d) {
    var m = i.pingCache;
    if (m === null) {
      m = i.pingCache = new pI();
      var x = /* @__PURE__ */ new Set();
      m.set(l, x);
    } else
      x = m.get(l), x === void 0 && (x = /* @__PURE__ */ new Set(), m.set(l, x));
    x.has(d) || (N0 = !0, x.add(d), i = bI.bind(null, i, l, d), l.then(i, i));
  }
  function bI(i, l, d) {
    var m = i.pingCache;
    m !== null && m.delete(l), i.pingedLanes |= i.suspendedLanes & d, i.warmLanes &= ~d, xt === i && (Ze & d) === d && (Ot === 4 || Ot === 3 && (Ze & 62914560) === Ze && 300 > ct() - P0 ? (lt & 2) === 0 && Ps(i, 0) : D0 |= d, Ns === Ze && (Ns = 0)), Zr(i);
  }
  function vE(i, l) {
    l === 0 && (l = Of()), i = ys(i, l), i !== null && (fa(i, l), Zr(i));
  }
  function xI(i) {
    var l = i.memoizedState, d = 0;
    l !== null && (d = l.retryLane), vE(i, d);
  }
  function wI(i, l) {
    var d = 0;
    switch (i.tag) {
      case 13:
        var m = i.stateNode, x = i.memoizedState;
        x !== null && (d = x.retryLane);
        break;
      case 19:
        m = i.stateNode;
        break;
      case 22:
        m = i.stateNode._retryCache;
        break;
      default:
        throw Error(r(314));
    }
    m !== null && m.delete(l), vE(i, d);
  }
  function _I(i, l) {
    return Ce(i, l);
  }
  var Md = null, zs = null, V0 = !1, Od = !1, U0 = !1, Ra = 0;
  function Zr(i) {
    i !== zs && i.next === null && (zs === null ? Md = zs = i : zs = zs.next = i), Od = !0, V0 || (V0 = !0, EI());
  }
  function $u(i, l) {
    if (!U0 && Od) {
      U0 = !0;
      do
        for (var d = !1, m = Md; m !== null; ) {
          if (i !== 0) {
            var x = m.pendingLanes;
            if (x === 0) var C = 0;
            else {
              var D = m.suspendedLanes, $ = m.pingedLanes;
              C = (1 << 31 - je(42 | i) + 1) - 1, C &= x & ~(D & ~$), C = C & 201326741 ? C & 201326741 | 1 : C ? C | 2 : 0;
            }
            C !== 0 && (d = !0, _E(m, C));
          } else
            C = Ze, C = $t(
              m,
              m === xt ? C : 0,
              m.cancelPendingCommit !== null || m.timeoutHandle !== -1
            ), (C & 3) === 0 || Rn(m, C) || (d = !0, _E(m, C));
          m = m.next;
        }
      while (d);
      U0 = !1;
    }
  }
  function SI() {
    bE();
  }
  function bE() {
    Od = V0 = !1;
    var i = 0;
    Ra !== 0 && (NI() && (i = Ra), Ra = 0);
    for (var l = ct(), d = null, m = Md; m !== null; ) {
      var x = m.next, C = xE(m, l);
      C === 0 ? (m.next = null, d === null ? Md = x : d.next = x, x === null && (zs = d)) : (d = m, (i !== 0 || (C & 3) !== 0) && (Od = !0)), m = x;
    }
    $u(i);
  }
  function xE(i, l) {
    for (var d = i.suspendedLanes, m = i.pingedLanes, x = i.expirationTimes, C = i.pendingLanes & -62914561; 0 < C; ) {
      var D = 31 - je(C), $ = 1 << D, X = x[D];
      X === -1 ? (($ & d) === 0 || ($ & m) !== 0) && (x[D] = Gn($, l)) : X <= l && (i.expiredLanes |= $), C &= ~$;
    }
    if (l = xt, d = Ze, d = $t(
      i,
      i === l ? d : 0,
      i.cancelPendingCommit !== null || i.timeoutHandle !== -1
    ), m = i.callbackNode, d === 0 || i === l && (ut === 2 || ut === 9) || i.cancelPendingCommit !== null)
      return m !== null && m !== null && _e(m), i.callbackNode = null, i.callbackPriority = 0;
    if ((d & 3) === 0 || Rn(i, d)) {
      if (l = d & -d, l === i.callbackPriority) return l;
      switch (m !== null && _e(m), Zl(d)) {
        case 2:
        case 8:
          d = Un;
          break;
        case 32:
          d = qn;
          break;
        case 268435456:
          d = qr;
          break;
        default:
          d = qn;
      }
      return m = wE.bind(null, i), d = Ce(d, m), i.callbackPriority = l, i.callbackNode = d, l;
    }
    return m !== null && m !== null && _e(m), i.callbackPriority = 2, i.callbackNode = null, 2;
  }
  function wE(i, l) {
    if (an !== 0 && an !== 5)
      return i.callbackNode = null, i.callbackPriority = 0, null;
    var d = i.callbackNode;
    if (Rd() && i.callbackNode !== d)
      return null;
    var m = Ze;
    return m = $t(
      i,
      i === xt ? m : 0,
      i.cancelPendingCommit !== null || i.timeoutHandle !== -1
    ), m === 0 ? null : (rE(i, m, l), xE(i, ct()), i.callbackNode != null && i.callbackNode === d ? wE.bind(null, i) : null);
  }
  function _E(i, l) {
    if (Rd()) return null;
    rE(i, l, !0);
  }
  function EI() {
    jI(function() {
      (lt & 6) !== 0 ? Ce(
        fr,
        SI
      ) : bE();
    });
  }
  function q0() {
    return Ra === 0 && (Ra = Mf()), Ra;
  }
  function SE(i) {
    return i == null || typeof i == "symbol" || typeof i == "boolean" ? null : typeof i == "function" ? i : Hf("" + i);
  }
  function EE(i, l) {
    var d = l.ownerDocument.createElement("input");
    return d.name = l.name, d.value = l.value, i.id && d.setAttribute("form", i.id), l.parentNode.insertBefore(d, l), i = new FormData(i), d.parentNode.removeChild(d), i;
  }
  function CI(i, l, d, m, x) {
    if (l === "submit" && d && d.stateNode === x) {
      var C = SE(
        (x[dn] || null).action
      ), D = m.submitter;
      D && (l = (l = D[dn] || null) ? SE(l.formAction) : D.getAttribute("formAction"), l !== null && (C = l, D = null));
      var $ = new Gf(
        "action",
        "action",
        null,
        m,
        x
      );
      i.push({
        event: $,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (m.defaultPrevented) {
                if (Ra !== 0) {
                  var X = D ? EE(x, D) : new FormData(x);
                  f0(
                    d,
                    {
                      pending: !0,
                      data: X,
                      method: x.method,
                      action: C
                    },
                    null,
                    X
                  );
                }
              } else
                typeof C == "function" && ($.preventDefault(), X = D ? EE(x, D) : new FormData(x), f0(
                  d,
                  {
                    pending: !0,
                    data: X,
                    method: x.method,
                    action: C
                  },
                  C,
                  X
                ));
            },
            currentTarget: x
          }
        ]
      });
    }
  }
  for (var G0 = 0; G0 < Mg.length; G0++) {
    var Y0 = Mg[G0], kI = Y0.toLowerCase(), TI = Y0[0].toUpperCase() + Y0.slice(1);
    Mr(
      kI,
      "on" + TI
    );
  }
  Mr(r_, "onAnimationEnd"), Mr(o_, "onAnimationIteration"), Mr(i_, "onAnimationStart"), Mr("dblclick", "onDoubleClick"), Mr("focusin", "onFocus"), Mr("focusout", "onBlur"), Mr(UP, "onTransitionRun"), Mr(qP, "onTransitionStart"), Mr(GP, "onTransitionCancel"), Mr(a_, "onTransitionEnd"), xi("onMouseEnter", ["mouseout", "mouseover"]), xi("onMouseLeave", ["mouseout", "mouseover"]), xi("onPointerEnter", ["pointerout", "pointerover"]), xi("onPointerLeave", ["pointerout", "pointerover"]), Ao(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  ), Ao(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  ), Ao("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]), Ao(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  ), Ao(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  ), Ao(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var Bu = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), AI = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Bu)
  );
  function CE(i, l) {
    l = (l & 4) !== 0;
    for (var d = 0; d < i.length; d++) {
      var m = i[d], x = m.event;
      m = m.listeners;
      e: {
        var C = void 0;
        if (l)
          for (var D = m.length - 1; 0 <= D; D--) {
            var $ = m[D], X = $.instance, ee = $.currentTarget;
            if ($ = $.listener, X !== C && x.isPropagationStopped())
              break e;
            C = $, x.currentTarget = ee;
            try {
              C(x);
            } catch (ue) {
              vd(ue);
            }
            x.currentTarget = null, C = X;
          }
        else
          for (D = 0; D < m.length; D++) {
            if ($ = m[D], X = $.instance, ee = $.currentTarget, $ = $.listener, X !== C && x.isPropagationStopped())
              break e;
            C = $, x.currentTarget = ee;
            try {
              C(x);
            } catch (ue) {
              vd(ue);
            }
            x.currentTarget = null, C = X;
          }
      }
    }
  }
  function Ye(i, l) {
    var d = l[Ql];
    d === void 0 && (d = l[Ql] = /* @__PURE__ */ new Set());
    var m = i + "__bubble";
    d.has(m) || (kE(l, i, 2, !1), d.add(m));
  }
  function W0(i, l, d) {
    var m = 0;
    l && (m |= 4), kE(
      d,
      i,
      m,
      l
    );
  }
  var Nd = "_reactListening" + Math.random().toString(36).slice(2);
  function X0(i) {
    if (!i[Nd]) {
      i[Nd] = !0, Pf.forEach(function(d) {
        d !== "selectionchange" && (AI.has(d) || W0(d, !1, i), W0(d, !0, i));
      });
      var l = i.nodeType === 9 ? i : i.ownerDocument;
      l === null || l[Nd] || (l[Nd] = !0, W0("selectionchange", !1, l));
    }
  }
  function kE(i, l, d, m) {
    switch (KE(l)) {
      case 2:
        var x = t6;
        break;
      case 8:
        x = n6;
        break;
      default:
        x = uy;
    }
    d = x.bind(
      null,
      l,
      d,
      i
    ), x = void 0, !yg || l !== "touchstart" && l !== "touchmove" && l !== "wheel" || (x = !0), m ? x !== void 0 ? i.addEventListener(l, d, {
      capture: !0,
      passive: x
    }) : i.addEventListener(l, d, !0) : x !== void 0 ? i.addEventListener(l, d, {
      passive: x
    }) : i.addEventListener(l, d, !1);
  }
  function K0(i, l, d, m, x) {
    var C = m;
    if ((l & 1) === 0 && (l & 2) === 0 && m !== null)
      e: for (; ; ) {
        if (m === null) return;
        var D = m.tag;
        if (D === 3 || D === 4) {
          var $ = m.stateNode.containerInfo;
          if ($ === x) break;
          if (D === 4)
            for (D = m.return; D !== null; ) {
              var X = D.tag;
              if ((X === 3 || X === 4) && D.stateNode.containerInfo === x)
                return;
              D = D.return;
            }
          for (; $ !== null; ) {
            if (D = vi($), D === null) return;
            if (X = D.tag, X === 5 || X === 6 || X === 26 || X === 27) {
              m = C = D;
              continue e;
            }
            $ = $.parentNode;
          }
        }
        m = m.return;
      }
    Dw(function() {
      var ee = C, ue = mg(d), de = [];
      e: {
        var ne = s_.get(i);
        if (ne !== void 0) {
          var re = Gf, Le = i;
          switch (i) {
            case "keypress":
              if (Uf(d) === 0) break e;
            case "keydown":
            case "keyup":
              re = _P;
              break;
            case "focusin":
              Le = "focus", re = wg;
              break;
            case "focusout":
              Le = "blur", re = wg;
              break;
            case "beforeblur":
            case "afterblur":
              re = wg;
              break;
            case "click":
              if (d.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              re = Iw;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              re = cP;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              re = CP;
              break;
            case r_:
            case o_:
            case i_:
              re = hP;
              break;
            case a_:
              re = TP;
              break;
            case "scroll":
            case "scrollend":
              re = lP;
              break;
            case "wheel":
              re = RP;
              break;
            case "copy":
            case "cut":
            case "paste":
              re = mP;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              re = Lw;
              break;
            case "toggle":
            case "beforetoggle":
              re = OP;
          }
          var Pe = (l & 4) !== 0, ht = !Pe && (i === "scroll" || i === "scrollend"), Q = Pe ? ne !== null ? ne + "Capture" : null : ne;
          Pe = [];
          for (var K = ee, J; K !== null; ) {
            var ce = K;
            if (J = ce.stateNode, ce = ce.tag, ce !== 5 && ce !== 26 && ce !== 27 || J === null || Q === null || (ce = au(K, Q), ce != null && Pe.push(
              Hu(K, ce, J)
            )), ht) break;
            K = K.return;
          }
          0 < Pe.length && (ne = new re(
            ne,
            Le,
            null,
            d,
            ue
          ), de.push({ event: ne, listeners: Pe }));
        }
      }
      if ((l & 7) === 0) {
        e: {
          if (ne = i === "mouseover" || i === "pointerover", re = i === "mouseout" || i === "pointerout", ne && d !== pg && (Le = d.relatedTarget || d.fromElement) && (vi(Le) || Le[yi]))
            break e;
          if ((re || ne) && (ne = ue.window === ue ? ue : (ne = ue.ownerDocument) ? ne.defaultView || ne.parentWindow : window, re ? (Le = d.relatedTarget || d.toElement, re = ee, Le = Le ? vi(Le) : null, Le !== null && (ht = a(Le), Pe = Le.tag, Le !== ht || Pe !== 5 && Pe !== 27 && Pe !== 6) && (Le = null)) : (re = null, Le = ee), re !== Le)) {
            if (Pe = Iw, ce = "onMouseLeave", Q = "onMouseEnter", K = "mouse", (i === "pointerout" || i === "pointerover") && (Pe = Lw, ce = "onPointerLeave", Q = "onPointerEnter", K = "pointer"), ht = re == null ? ne : bi(re), J = Le == null ? ne : bi(Le), ne = new Pe(
              ce,
              K + "leave",
              re,
              d,
              ue
            ), ne.target = ht, ne.relatedTarget = J, ce = null, vi(ue) === ee && (Pe = new Pe(
              Q,
              K + "enter",
              Le,
              d,
              ue
            ), Pe.target = J, Pe.relatedTarget = ht, ce = Pe), ht = ce, re && Le)
              t: {
                for (Pe = re, Q = Le, K = 0, J = Pe; J; J = Ls(J))
                  K++;
                for (J = 0, ce = Q; ce; ce = Ls(ce))
                  J++;
                for (; 0 < K - J; )
                  Pe = Ls(Pe), K--;
                for (; 0 < J - K; )
                  Q = Ls(Q), J--;
                for (; K--; ) {
                  if (Pe === Q || Q !== null && Pe === Q.alternate)
                    break t;
                  Pe = Ls(Pe), Q = Ls(Q);
                }
                Pe = null;
              }
            else Pe = null;
            re !== null && TE(
              de,
              ne,
              re,
              Pe,
              !1
            ), Le !== null && ht !== null && TE(
              de,
              ht,
              Le,
              Pe,
              !0
            );
          }
        }
        e: {
          if (ne = ee ? bi(ee) : window, re = ne.nodeName && ne.nodeName.toLowerCase(), re === "select" || re === "input" && ne.type === "file")
            var be = Gw;
          else if (Uw(ne))
            if (Yw)
              be = BP;
            else {
              be = FP;
              var Ue = LP;
            }
          else
            re = ne.nodeName, !re || re.toLowerCase() !== "input" || ne.type !== "checkbox" && ne.type !== "radio" ? ee && hg(ee.elementType) && (be = Gw) : be = $P;
          if (be && (be = be(i, ee))) {
            qw(
              de,
              be,
              d,
              ue
            );
            break e;
          }
          Ue && Ue(i, ne, ee), i === "focusout" && ee && ne.type === "number" && ee.memoizedProps.value != null && iu(ne, "number", ne.value);
        }
        switch (Ue = ee ? bi(ee) : window, i) {
          case "focusin":
            (Uw(Ue) || Ue.contentEditable === "true") && (ps = Ue, Tg = ee, pu = null);
            break;
          case "focusout":
            pu = Tg = ps = null;
            break;
          case "mousedown":
            Ag = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Ag = !1, t_(de, d, ue);
            break;
          case "selectionchange":
            if (VP) break;
          case "keydown":
          case "keyup":
            t_(de, d, ue);
        }
        var Se;
        if (Sg)
          e: {
            switch (i) {
              case "compositionstart":
                var Ie = "onCompositionStart";
                break e;
              case "compositionend":
                Ie = "onCompositionEnd";
                break e;
              case "compositionupdate":
                Ie = "onCompositionUpdate";
                break e;
            }
            Ie = void 0;
          }
        else
          hs ? Hw(i, d) && (Ie = "onCompositionEnd") : i === "keydown" && d.keyCode === 229 && (Ie = "onCompositionStart");
        Ie && (Fw && d.locale !== "ko" && (hs || Ie !== "onCompositionStart" ? Ie === "onCompositionEnd" && hs && (Se = jw()) : (wi = ue, vg = "value" in wi ? wi.value : wi.textContent, hs = !0)), Ue = Dd(ee, Ie), 0 < Ue.length && (Ie = new zw(
          Ie,
          i,
          null,
          d,
          ue
        ), de.push({ event: Ie, listeners: Ue }), Se ? Ie.data = Se : (Se = Vw(d), Se !== null && (Ie.data = Se)))), (Se = DP ? jP(i, d) : PP(i, d)) && (Ie = Dd(ee, "onBeforeInput"), 0 < Ie.length && (Ue = new zw(
          "onBeforeInput",
          "beforeinput",
          null,
          d,
          ue
        ), de.push({
          event: Ue,
          listeners: Ie
        }), Ue.data = Se)), CI(
          de,
          i,
          ee,
          d,
          ue
        );
      }
      CE(de, l);
    });
  }
  function Hu(i, l, d) {
    return {
      instance: i,
      listener: l,
      currentTarget: d
    };
  }
  function Dd(i, l) {
    for (var d = l + "Capture", m = []; i !== null; ) {
      var x = i, C = x.stateNode;
      if (x = x.tag, x !== 5 && x !== 26 && x !== 27 || C === null || (x = au(i, d), x != null && m.unshift(
        Hu(i, x, C)
      ), x = au(i, l), x != null && m.push(
        Hu(i, x, C)
      )), i.tag === 3) return m;
      i = i.return;
    }
    return [];
  }
  function Ls(i) {
    if (i === null) return null;
    do
      i = i.return;
    while (i && i.tag !== 5 && i.tag !== 27);
    return i || null;
  }
  function TE(i, l, d, m, x) {
    for (var C = l._reactName, D = []; d !== null && d !== m; ) {
      var $ = d, X = $.alternate, ee = $.stateNode;
      if ($ = $.tag, X !== null && X === m) break;
      $ !== 5 && $ !== 26 && $ !== 27 || ee === null || (X = ee, x ? (ee = au(d, C), ee != null && D.unshift(
        Hu(d, ee, X)
      )) : x || (ee = au(d, C), ee != null && D.push(
        Hu(d, ee, X)
      ))), d = d.return;
    }
    D.length !== 0 && i.push({ event: l, listeners: D });
  }
  var RI = /\r\n?/g, MI = /\u0000|\uFFFD/g;
  function AE(i) {
    return (typeof i == "string" ? i : "" + i).replace(RI, `
`).replace(MI, "");
  }
  function RE(i, l) {
    return l = AE(l), AE(i) === l;
  }
  function jd() {
  }
  function dt(i, l, d, m, x, C) {
    switch (d) {
      case "children":
        typeof m == "string" ? l === "body" || l === "textarea" && m === "" || cs(i, m) : (typeof m == "number" || typeof m == "bigint") && l !== "body" && cs(i, "" + m);
        break;
      case "className":
        ss(i, "class", m);
        break;
      case "tabIndex":
        ss(i, "tabindex", m);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        ss(i, d, m);
        break;
      case "style":
        Ow(i, m, C);
        break;
      case "data":
        if (l !== "object") {
          ss(i, "data", m);
          break;
        }
      case "src":
      case "href":
        if (m === "" && (l !== "a" || d !== "href")) {
          i.removeAttribute(d);
          break;
        }
        if (m == null || typeof m == "function" || typeof m == "symbol" || typeof m == "boolean") {
          i.removeAttribute(d);
          break;
        }
        m = Hf("" + m), i.setAttribute(d, m);
        break;
      case "action":
      case "formAction":
        if (typeof m == "function") {
          i.setAttribute(
            d,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          typeof C == "function" && (d === "formAction" ? (l !== "input" && dt(i, l, "name", x.name, x, null), dt(
            i,
            l,
            "formEncType",
            x.formEncType,
            x,
            null
          ), dt(
            i,
            l,
            "formMethod",
            x.formMethod,
            x,
            null
          ), dt(
            i,
            l,
            "formTarget",
            x.formTarget,
            x,
            null
          )) : (dt(i, l, "encType", x.encType, x, null), dt(i, l, "method", x.method, x, null), dt(i, l, "target", x.target, x, null)));
        if (m == null || typeof m == "symbol" || typeof m == "boolean") {
          i.removeAttribute(d);
          break;
        }
        m = Hf("" + m), i.setAttribute(d, m);
        break;
      case "onClick":
        m != null && (i.onclick = jd);
        break;
      case "onScroll":
        m != null && Ye("scroll", i);
        break;
      case "onScrollEnd":
        m != null && Ye("scrollend", i);
        break;
      case "dangerouslySetInnerHTML":
        if (m != null) {
          if (typeof m != "object" || !("__html" in m))
            throw Error(r(61));
          if (d = m.__html, d != null) {
            if (x.children != null) throw Error(r(60));
            i.innerHTML = d;
          }
        }
        break;
      case "multiple":
        i.multiple = m && typeof m != "function" && typeof m != "symbol";
        break;
      case "muted":
        i.muted = m && typeof m != "function" && typeof m != "symbol";
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (m == null || typeof m == "function" || typeof m == "boolean" || typeof m == "symbol") {
          i.removeAttribute("xlink:href");
          break;
        }
        d = Hf("" + m), i.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          d
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        m != null && typeof m != "function" && typeof m != "symbol" ? i.setAttribute(d, "" + m) : i.removeAttribute(d);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        m && typeof m != "function" && typeof m != "symbol" ? i.setAttribute(d, "") : i.removeAttribute(d);
        break;
      case "capture":
      case "download":
        m === !0 ? i.setAttribute(d, "") : m !== !1 && m != null && typeof m != "function" && typeof m != "symbol" ? i.setAttribute(d, m) : i.removeAttribute(d);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        m != null && typeof m != "function" && typeof m != "symbol" && !isNaN(m) && 1 <= m ? i.setAttribute(d, m) : i.removeAttribute(d);
        break;
      case "rowSpan":
      case "start":
        m == null || typeof m == "function" || typeof m == "symbol" || isNaN(m) ? i.removeAttribute(d) : i.setAttribute(d, m);
        break;
      case "popover":
        Ye("beforetoggle", i), Ye("toggle", i), as(i, "popover", m);
        break;
      case "xlinkActuate":
        Rr(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          m
        );
        break;
      case "xlinkArcrole":
        Rr(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          m
        );
        break;
      case "xlinkRole":
        Rr(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          m
        );
        break;
      case "xlinkShow":
        Rr(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          m
        );
        break;
      case "xlinkTitle":
        Rr(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          m
        );
        break;
      case "xlinkType":
        Rr(
          i,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          m
        );
        break;
      case "xmlBase":
        Rr(
          i,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          m
        );
        break;
      case "xmlLang":
        Rr(
          i,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          m
        );
        break;
      case "xmlSpace":
        Rr(
          i,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          m
        );
        break;
      case "is":
        as(i, "is", m);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        (!(2 < d.length) || d[0] !== "o" && d[0] !== "O" || d[1] !== "n" && d[1] !== "N") && (d = aP.get(d) || d, as(i, d, m));
    }
  }
  function Z0(i, l, d, m, x, C) {
    switch (d) {
      case "style":
        Ow(i, m, C);
        break;
      case "dangerouslySetInnerHTML":
        if (m != null) {
          if (typeof m != "object" || !("__html" in m))
            throw Error(r(61));
          if (d = m.__html, d != null) {
            if (x.children != null) throw Error(r(60));
            i.innerHTML = d;
          }
        }
        break;
      case "children":
        typeof m == "string" ? cs(i, m) : (typeof m == "number" || typeof m == "bigint") && cs(i, "" + m);
        break;
      case "onScroll":
        m != null && Ye("scroll", i);
        break;
      case "onScrollEnd":
        m != null && Ye("scrollend", i);
        break;
      case "onClick":
        m != null && (i.onclick = jd);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!If.hasOwnProperty(d))
          e: {
            if (d[0] === "o" && d[1] === "n" && (x = d.endsWith("Capture"), l = d.slice(2, x ? d.length - 7 : void 0), C = i[dn] || null, C = C != null ? C[d] : null, typeof C == "function" && i.removeEventListener(l, C, x), typeof m == "function")) {
              typeof C != "function" && C !== null && (d in i ? i[d] = null : i.hasAttribute(d) && i.removeAttribute(d)), i.addEventListener(l, m, x);
              break e;
            }
            d in i ? i[d] = m : m === !0 ? i.setAttribute(d, "") : as(i, d, m);
          }
    }
  }
  function sn(i, l, d) {
    switch (l) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        Ye("error", i), Ye("load", i);
        var m = !1, x = !1, C;
        for (C in d)
          if (d.hasOwnProperty(C)) {
            var D = d[C];
            if (D != null)
              switch (C) {
                case "src":
                  m = !0;
                  break;
                case "srcSet":
                  x = !0;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(r(137, l));
                default:
                  dt(i, l, C, D, d, null);
              }
          }
        x && dt(i, l, "srcSet", d.srcSet, d, null), m && dt(i, l, "src", d.src, d, null);
        return;
      case "input":
        Ye("invalid", i);
        var $ = C = D = x = null, X = null, ee = null;
        for (m in d)
          if (d.hasOwnProperty(m)) {
            var ue = d[m];
            if (ue != null)
              switch (m) {
                case "name":
                  x = ue;
                  break;
                case "type":
                  D = ue;
                  break;
                case "checked":
                  X = ue;
                  break;
                case "defaultChecked":
                  ee = ue;
                  break;
                case "value":
                  C = ue;
                  break;
                case "defaultValue":
                  $ = ue;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (ue != null)
                    throw Error(r(137, l));
                  break;
                default:
                  dt(i, l, m, ue, d, null);
              }
          }
        Bf(
          i,
          C,
          $,
          X,
          ee,
          D,
          x,
          !1
        ), ls(i);
        return;
      case "select":
        Ye("invalid", i), m = D = C = null;
        for (x in d)
          if (d.hasOwnProperty(x) && ($ = d[x], $ != null))
            switch (x) {
              case "value":
                C = $;
                break;
              case "defaultValue":
                D = $;
                break;
              case "multiple":
                m = $;
              default:
                dt(i, l, x, $, d, null);
            }
        l = C, d = D, i.multiple = !!m, l != null ? Mo(i, !!m, l, !1) : d != null && Mo(i, !!m, d, !0);
        return;
      case "textarea":
        Ye("invalid", i), C = x = m = null;
        for (D in d)
          if (d.hasOwnProperty(D) && ($ = d[D], $ != null))
            switch (D) {
              case "value":
                m = $;
                break;
              case "defaultValue":
                x = $;
                break;
              case "children":
                C = $;
                break;
              case "dangerouslySetInnerHTML":
                if ($ != null) throw Error(r(91));
                break;
              default:
                dt(i, l, D, $, d, null);
            }
        Rw(i, m, x, C), ls(i);
        return;
      case "option":
        for (X in d)
          if (d.hasOwnProperty(X) && (m = d[X], m != null))
            switch (X) {
              case "selected":
                i.selected = m && typeof m != "function" && typeof m != "symbol";
                break;
              default:
                dt(i, l, X, m, d, null);
            }
        return;
      case "dialog":
        Ye("beforetoggle", i), Ye("toggle", i), Ye("cancel", i), Ye("close", i);
        break;
      case "iframe":
      case "object":
        Ye("load", i);
        break;
      case "video":
      case "audio":
        for (m = 0; m < Bu.length; m++)
          Ye(Bu[m], i);
        break;
      case "image":
        Ye("error", i), Ye("load", i);
        break;
      case "details":
        Ye("toggle", i);
        break;
      case "embed":
      case "source":
      case "link":
        Ye("error", i), Ye("load", i);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (ee in d)
          if (d.hasOwnProperty(ee) && (m = d[ee], m != null))
            switch (ee) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(r(137, l));
              default:
                dt(i, l, ee, m, d, null);
            }
        return;
      default:
        if (hg(l)) {
          for (ue in d)
            d.hasOwnProperty(ue) && (m = d[ue], m !== void 0 && Z0(
              i,
              l,
              ue,
              m,
              d,
              void 0
            ));
          return;
        }
    }
    for ($ in d)
      d.hasOwnProperty($) && (m = d[$], m != null && dt(i, l, $, m, d, null));
  }
  function OI(i, l, d, m) {
    switch (l) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var x = null, C = null, D = null, $ = null, X = null, ee = null, ue = null;
        for (re in d) {
          var de = d[re];
          if (d.hasOwnProperty(re) && de != null)
            switch (re) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                X = de;
              default:
                m.hasOwnProperty(re) || dt(i, l, re, null, m, de);
            }
        }
        for (var ne in m) {
          var re = m[ne];
          if (de = d[ne], m.hasOwnProperty(ne) && (re != null || de != null))
            switch (ne) {
              case "type":
                C = re;
                break;
              case "name":
                x = re;
                break;
              case "checked":
                ee = re;
                break;
              case "defaultChecked":
                ue = re;
                break;
              case "value":
                D = re;
                break;
              case "defaultValue":
                $ = re;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (re != null)
                  throw Error(r(137, l));
                break;
              default:
                re !== de && dt(
                  i,
                  l,
                  ne,
                  re,
                  m,
                  de
                );
            }
        }
        ha(
          i,
          D,
          $,
          X,
          ee,
          ue,
          C,
          x
        );
        return;
      case "select":
        re = D = $ = ne = null;
        for (C in d)
          if (X = d[C], d.hasOwnProperty(C) && X != null)
            switch (C) {
              case "value":
                break;
              case "multiple":
                re = X;
              default:
                m.hasOwnProperty(C) || dt(
                  i,
                  l,
                  C,
                  null,
                  m,
                  X
                );
            }
        for (x in m)
          if (C = m[x], X = d[x], m.hasOwnProperty(x) && (C != null || X != null))
            switch (x) {
              case "value":
                ne = C;
                break;
              case "defaultValue":
                $ = C;
                break;
              case "multiple":
                D = C;
              default:
                C !== X && dt(
                  i,
                  l,
                  x,
                  C,
                  m,
                  X
                );
            }
        l = $, d = D, m = re, ne != null ? Mo(i, !!d, ne, !1) : !!m != !!d && (l != null ? Mo(i, !!d, l, !0) : Mo(i, !!d, d ? [] : "", !1));
        return;
      case "textarea":
        re = ne = null;
        for ($ in d)
          if (x = d[$], d.hasOwnProperty($) && x != null && !m.hasOwnProperty($))
            switch ($) {
              case "value":
                break;
              case "children":
                break;
              default:
                dt(i, l, $, null, m, x);
            }
        for (D in m)
          if (x = m[D], C = d[D], m.hasOwnProperty(D) && (x != null || C != null))
            switch (D) {
              case "value":
                ne = x;
                break;
              case "defaultValue":
                re = x;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (x != null) throw Error(r(91));
                break;
              default:
                x !== C && dt(i, l, D, x, m, C);
            }
        Aw(i, ne, re);
        return;
      case "option":
        for (var Le in d)
          if (ne = d[Le], d.hasOwnProperty(Le) && ne != null && !m.hasOwnProperty(Le))
            switch (Le) {
              case "selected":
                i.selected = !1;
                break;
              default:
                dt(
                  i,
                  l,
                  Le,
                  null,
                  m,
                  ne
                );
            }
        for (X in m)
          if (ne = m[X], re = d[X], m.hasOwnProperty(X) && ne !== re && (ne != null || re != null))
            switch (X) {
              case "selected":
                i.selected = ne && typeof ne != "function" && typeof ne != "symbol";
                break;
              default:
                dt(
                  i,
                  l,
                  X,
                  ne,
                  m,
                  re
                );
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var Pe in d)
          ne = d[Pe], d.hasOwnProperty(Pe) && ne != null && !m.hasOwnProperty(Pe) && dt(i, l, Pe, null, m, ne);
        for (ee in m)
          if (ne = m[ee], re = d[ee], m.hasOwnProperty(ee) && ne !== re && (ne != null || re != null))
            switch (ee) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (ne != null)
                  throw Error(r(137, l));
                break;
              default:
                dt(
                  i,
                  l,
                  ee,
                  ne,
                  m,
                  re
                );
            }
        return;
      default:
        if (hg(l)) {
          for (var ht in d)
            ne = d[ht], d.hasOwnProperty(ht) && ne !== void 0 && !m.hasOwnProperty(ht) && Z0(
              i,
              l,
              ht,
              void 0,
              m,
              ne
            );
          for (ue in m)
            ne = m[ue], re = d[ue], !m.hasOwnProperty(ue) || ne === re || ne === void 0 && re === void 0 || Z0(
              i,
              l,
              ue,
              ne,
              m,
              re
            );
          return;
        }
    }
    for (var Q in d)
      ne = d[Q], d.hasOwnProperty(Q) && ne != null && !m.hasOwnProperty(Q) && dt(i, l, Q, null, m, ne);
    for (de in m)
      ne = m[de], re = d[de], !m.hasOwnProperty(de) || ne === re || ne == null && re == null || dt(i, l, de, ne, m, re);
  }
  var Q0 = null, J0 = null;
  function Pd(i) {
    return i.nodeType === 9 ? i : i.ownerDocument;
  }
  function ME(i) {
    switch (i) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function OE(i, l) {
    if (i === 0)
      switch (l) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return i === 1 && l === "foreignObject" ? 0 : i;
  }
  function ey(i, l) {
    return i === "textarea" || i === "noscript" || typeof l.children == "string" || typeof l.children == "number" || typeof l.children == "bigint" || typeof l.dangerouslySetInnerHTML == "object" && l.dangerouslySetInnerHTML !== null && l.dangerouslySetInnerHTML.__html != null;
  }
  var ty = null;
  function NI() {
    var i = window.event;
    return i && i.type === "popstate" ? i === ty ? !1 : (ty = i, !0) : (ty = null, !1);
  }
  var NE = typeof setTimeout == "function" ? setTimeout : void 0, DI = typeof clearTimeout == "function" ? clearTimeout : void 0, DE = typeof Promise == "function" ? Promise : void 0, jI = typeof queueMicrotask == "function" ? queueMicrotask : typeof DE < "u" ? function(i) {
    return DE.resolve(null).then(i).catch(PI);
  } : NE;
  function PI(i) {
    setTimeout(function() {
      throw i;
    });
  }
  function zi(i) {
    return i === "head";
  }
  function jE(i, l) {
    var d = l, m = 0, x = 0;
    do {
      var C = d.nextSibling;
      if (i.removeChild(d), C && C.nodeType === 8)
        if (d = C.data, d === "/$") {
          if (0 < m && 8 > m) {
            d = m;
            var D = i.ownerDocument;
            if (d & 1 && Vu(D.documentElement), d & 2 && Vu(D.body), d & 4)
              for (d = D.head, Vu(d), D = d.firstChild; D; ) {
                var $ = D.nextSibling, X = D.nodeName;
                D[da] || X === "SCRIPT" || X === "STYLE" || X === "LINK" && D.rel.toLowerCase() === "stylesheet" || d.removeChild(D), D = $;
              }
          }
          if (x === 0) {
            i.removeChild(C), Zu(l);
            return;
          }
          x--;
        } else
          d === "$" || d === "$?" || d === "$!" ? x++ : m = d.charCodeAt(0) - 48;
      else m = 0;
      d = C;
    } while (d);
    Zu(l);
  }
  function ny(i) {
    var l = i.firstChild;
    for (l && l.nodeType === 10 && (l = l.nextSibling); l; ) {
      var d = l;
      switch (l = l.nextSibling, d.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          ny(d), Jl(d);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if (d.rel.toLowerCase() === "stylesheet") continue;
      }
      i.removeChild(d);
    }
  }
  function II(i, l, d, m) {
    for (; i.nodeType === 1; ) {
      var x = d;
      if (i.nodeName.toLowerCase() !== l.toLowerCase()) {
        if (!m && (i.nodeName !== "INPUT" || i.type !== "hidden"))
          break;
      } else if (m) {
        if (!i[da])
          switch (l) {
            case "meta":
              if (!i.hasAttribute("itemprop")) break;
              return i;
            case "link":
              if (C = i.getAttribute("rel"), C === "stylesheet" && i.hasAttribute("data-precedence"))
                break;
              if (C !== x.rel || i.getAttribute("href") !== (x.href == null || x.href === "" ? null : x.href) || i.getAttribute("crossorigin") !== (x.crossOrigin == null ? null : x.crossOrigin) || i.getAttribute("title") !== (x.title == null ? null : x.title))
                break;
              return i;
            case "style":
              if (i.hasAttribute("data-precedence")) break;
              return i;
            case "script":
              if (C = i.getAttribute("src"), (C !== (x.src == null ? null : x.src) || i.getAttribute("type") !== (x.type == null ? null : x.type) || i.getAttribute("crossorigin") !== (x.crossOrigin == null ? null : x.crossOrigin)) && C && i.hasAttribute("async") && !i.hasAttribute("itemprop"))
                break;
              return i;
            default:
              return i;
          }
      } else if (l === "input" && i.type === "hidden") {
        var C = x.name == null ? null : "" + x.name;
        if (x.type === "hidden" && i.getAttribute("name") === C)
          return i;
      } else return i;
      if (i = Nr(i.nextSibling), i === null) break;
    }
    return null;
  }
  function zI(i, l, d) {
    if (l === "") return null;
    for (; i.nodeType !== 3; )
      if ((i.nodeType !== 1 || i.nodeName !== "INPUT" || i.type !== "hidden") && !d || (i = Nr(i.nextSibling), i === null)) return null;
    return i;
  }
  function ry(i) {
    return i.data === "$!" || i.data === "$?" && i.ownerDocument.readyState === "complete";
  }
  function LI(i, l) {
    var d = i.ownerDocument;
    if (i.data !== "$?" || d.readyState === "complete")
      l();
    else {
      var m = function() {
        l(), d.removeEventListener("DOMContentLoaded", m);
      };
      d.addEventListener("DOMContentLoaded", m), i._reactRetry = m;
    }
  }
  function Nr(i) {
    for (; i != null; i = i.nextSibling) {
      var l = i.nodeType;
      if (l === 1 || l === 3) break;
      if (l === 8) {
        if (l = i.data, l === "$" || l === "$!" || l === "$?" || l === "F!" || l === "F")
          break;
        if (l === "/$") return null;
      }
    }
    return i;
  }
  var oy = null;
  function PE(i) {
    i = i.previousSibling;
    for (var l = 0; i; ) {
      if (i.nodeType === 8) {
        var d = i.data;
        if (d === "$" || d === "$!" || d === "$?") {
          if (l === 0) return i;
          l--;
        } else d === "/$" && l++;
      }
      i = i.previousSibling;
    }
    return null;
  }
  function IE(i, l, d) {
    switch (l = Pd(d), i) {
      case "html":
        if (i = l.documentElement, !i) throw Error(r(452));
        return i;
      case "head":
        if (i = l.head, !i) throw Error(r(453));
        return i;
      case "body":
        if (i = l.body, !i) throw Error(r(454));
        return i;
      default:
        throw Error(r(451));
    }
  }
  function Vu(i) {
    for (var l = i.attributes; l.length; )
      i.removeAttributeNode(l[0]);
    Jl(i);
  }
  var br = /* @__PURE__ */ new Map(), zE = /* @__PURE__ */ new Set();
  function Id(i) {
    return typeof i.getRootNode == "function" ? i.getRootNode() : i.nodeType === 9 ? i : i.ownerDocument;
  }
  var Uo = U.d;
  U.d = {
    f: FI,
    r: $I,
    D: BI,
    C: HI,
    L: VI,
    m: UI,
    X: GI,
    S: qI,
    M: YI
  };
  function FI() {
    var i = Uo.f(), l = Td();
    return i || l;
  }
  function $I(i) {
    var l = ko(i);
    l !== null && l.tag === 5 && l.type === "form" ? rS(l) : Uo.r(i);
  }
  var Fs = typeof document > "u" ? null : document;
  function LE(i, l, d) {
    var m = Fs;
    if (m && typeof l == "string" && l) {
      var x = On(l);
      x = 'link[rel="' + i + '"][href="' + x + '"]', typeof d == "string" && (x += '[crossorigin="' + d + '"]'), zE.has(x) || (zE.add(x), i = { rel: i, crossOrigin: d, href: l }, m.querySelector(x) === null && (l = m.createElement("link"), sn(l, "link", i), Bt(l), m.head.appendChild(l)));
    }
  }
  function BI(i) {
    Uo.D(i), LE("dns-prefetch", i, null);
  }
  function HI(i, l) {
    Uo.C(i, l), LE("preconnect", i, l);
  }
  function VI(i, l, d) {
    Uo.L(i, l, d);
    var m = Fs;
    if (m && i && l) {
      var x = 'link[rel="preload"][as="' + On(l) + '"]';
      l === "image" && d && d.imageSrcSet ? (x += '[imagesrcset="' + On(
        d.imageSrcSet
      ) + '"]', typeof d.imageSizes == "string" && (x += '[imagesizes="' + On(
        d.imageSizes
      ) + '"]')) : x += '[href="' + On(i) + '"]';
      var C = x;
      switch (l) {
        case "style":
          C = $s(i);
          break;
        case "script":
          C = Bs(i);
      }
      br.has(C) || (i = h(
        {
          rel: "preload",
          href: l === "image" && d && d.imageSrcSet ? void 0 : i,
          as: l
        },
        d
      ), br.set(C, i), m.querySelector(x) !== null || l === "style" && m.querySelector(Uu(C)) || l === "script" && m.querySelector(qu(C)) || (l = m.createElement("link"), sn(l, "link", i), Bt(l), m.head.appendChild(l)));
    }
  }
  function UI(i, l) {
    Uo.m(i, l);
    var d = Fs;
    if (d && i) {
      var m = l && typeof l.as == "string" ? l.as : "script", x = 'link[rel="modulepreload"][as="' + On(m) + '"][href="' + On(i) + '"]', C = x;
      switch (m) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          C = Bs(i);
      }
      if (!br.has(C) && (i = h({ rel: "modulepreload", href: i }, l), br.set(C, i), d.querySelector(x) === null)) {
        switch (m) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (d.querySelector(qu(C)))
              return;
        }
        m = d.createElement("link"), sn(m, "link", i), Bt(m), d.head.appendChild(m);
      }
    }
  }
  function qI(i, l, d) {
    Uo.S(i, l, d);
    var m = Fs;
    if (m && i) {
      var x = To(m).hoistableStyles, C = $s(i);
      l = l || "default";
      var D = x.get(C);
      if (!D) {
        var $ = { loading: 0, preload: null };
        if (D = m.querySelector(
          Uu(C)
        ))
          $.loading = 5;
        else {
          i = h(
            { rel: "stylesheet", href: i, "data-precedence": l },
            d
          ), (d = br.get(C)) && iy(i, d);
          var X = D = m.createElement("link");
          Bt(X), sn(X, "link", i), X._p = new Promise(function(ee, ue) {
            X.onload = ee, X.onerror = ue;
          }), X.addEventListener("load", function() {
            $.loading |= 1;
          }), X.addEventListener("error", function() {
            $.loading |= 2;
          }), $.loading |= 4, zd(D, l, m);
        }
        D = {
          type: "stylesheet",
          instance: D,
          count: 1,
          state: $
        }, x.set(C, D);
      }
    }
  }
  function GI(i, l) {
    Uo.X(i, l);
    var d = Fs;
    if (d && i) {
      var m = To(d).hoistableScripts, x = Bs(i), C = m.get(x);
      C || (C = d.querySelector(qu(x)), C || (i = h({ src: i, async: !0 }, l), (l = br.get(x)) && ay(i, l), C = d.createElement("script"), Bt(C), sn(C, "link", i), d.head.appendChild(C)), C = {
        type: "script",
        instance: C,
        count: 1,
        state: null
      }, m.set(x, C));
    }
  }
  function YI(i, l) {
    Uo.M(i, l);
    var d = Fs;
    if (d && i) {
      var m = To(d).hoistableScripts, x = Bs(i), C = m.get(x);
      C || (C = d.querySelector(qu(x)), C || (i = h({ src: i, async: !0, type: "module" }, l), (l = br.get(x)) && ay(i, l), C = d.createElement("script"), Bt(C), sn(C, "link", i), d.head.appendChild(C)), C = {
        type: "script",
        instance: C,
        count: 1,
        state: null
      }, m.set(x, C));
    }
  }
  function FE(i, l, d, m) {
    var x = (x = oe.current) ? Id(x) : null;
    if (!x) throw Error(r(446));
    switch (i) {
      case "meta":
      case "title":
        return null;
      case "style":
        return typeof d.precedence == "string" && typeof d.href == "string" ? (l = $s(d.href), d = To(
          x
        ).hoistableStyles, m = d.get(l), m || (m = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, d.set(l, m)), m) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if (d.rel === "stylesheet" && typeof d.href == "string" && typeof d.precedence == "string") {
          i = $s(d.href);
          var C = To(
            x
          ).hoistableStyles, D = C.get(i);
          if (D || (x = x.ownerDocument || x, D = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, C.set(i, D), (C = x.querySelector(
            Uu(i)
          )) && !C._p && (D.instance = C, D.state.loading = 5), br.has(i) || (d = {
            rel: "preload",
            as: "style",
            href: d.href,
            crossOrigin: d.crossOrigin,
            integrity: d.integrity,
            media: d.media,
            hrefLang: d.hrefLang,
            referrerPolicy: d.referrerPolicy
          }, br.set(i, d), C || WI(
            x,
            i,
            d,
            D.state
          ))), l && m === null)
            throw Error(r(528, ""));
          return D;
        }
        if (l && m !== null)
          throw Error(r(529, ""));
        return null;
      case "script":
        return l = d.async, d = d.src, typeof d == "string" && l && typeof l != "function" && typeof l != "symbol" ? (l = Bs(d), d = To(
          x
        ).hoistableScripts, m = d.get(l), m || (m = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, d.set(l, m)), m) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(r(444, i));
    }
  }
  function $s(i) {
    return 'href="' + On(i) + '"';
  }
  function Uu(i) {
    return 'link[rel="stylesheet"][' + i + "]";
  }
  function $E(i) {
    return h({}, i, {
      "data-precedence": i.precedence,
      precedence: null
    });
  }
  function WI(i, l, d, m) {
    i.querySelector('link[rel="preload"][as="style"][' + l + "]") ? m.loading = 1 : (l = i.createElement("link"), m.preload = l, l.addEventListener("load", function() {
      return m.loading |= 1;
    }), l.addEventListener("error", function() {
      return m.loading |= 2;
    }), sn(l, "link", d), Bt(l), i.head.appendChild(l));
  }
  function Bs(i) {
    return '[src="' + On(i) + '"]';
  }
  function qu(i) {
    return "script[async]" + i;
  }
  function BE(i, l, d) {
    if (l.count++, l.instance === null)
      switch (l.type) {
        case "style":
          var m = i.querySelector(
            'style[data-href~="' + On(d.href) + '"]'
          );
          if (m)
            return l.instance = m, Bt(m), m;
          var x = h({}, d, {
            "data-href": d.href,
            "data-precedence": d.precedence,
            href: null,
            precedence: null
          });
          return m = (i.ownerDocument || i).createElement(
            "style"
          ), Bt(m), sn(m, "style", x), zd(m, d.precedence, i), l.instance = m;
        case "stylesheet":
          x = $s(d.href);
          var C = i.querySelector(
            Uu(x)
          );
          if (C)
            return l.state.loading |= 4, l.instance = C, Bt(C), C;
          m = $E(d), (x = br.get(x)) && iy(m, x), C = (i.ownerDocument || i).createElement("link"), Bt(C);
          var D = C;
          return D._p = new Promise(function($, X) {
            D.onload = $, D.onerror = X;
          }), sn(C, "link", m), l.state.loading |= 4, zd(C, d.precedence, i), l.instance = C;
        case "script":
          return C = Bs(d.src), (x = i.querySelector(
            qu(C)
          )) ? (l.instance = x, Bt(x), x) : (m = d, (x = br.get(C)) && (m = h({}, d), ay(m, x)), i = i.ownerDocument || i, x = i.createElement("script"), Bt(x), sn(x, "link", m), i.head.appendChild(x), l.instance = x);
        case "void":
          return null;
        default:
          throw Error(r(443, l.type));
      }
    else
      l.type === "stylesheet" && (l.state.loading & 4) === 0 && (m = l.instance, l.state.loading |= 4, zd(m, d.precedence, i));
    return l.instance;
  }
  function zd(i, l, d) {
    for (var m = d.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), x = m.length ? m[m.length - 1] : null, C = x, D = 0; D < m.length; D++) {
      var $ = m[D];
      if ($.dataset.precedence === l) C = $;
      else if (C !== x) break;
    }
    C ? C.parentNode.insertBefore(i, C.nextSibling) : (l = d.nodeType === 9 ? d.head : d, l.insertBefore(i, l.firstChild));
  }
  function iy(i, l) {
    i.crossOrigin == null && (i.crossOrigin = l.crossOrigin), i.referrerPolicy == null && (i.referrerPolicy = l.referrerPolicy), i.title == null && (i.title = l.title);
  }
  function ay(i, l) {
    i.crossOrigin == null && (i.crossOrigin = l.crossOrigin), i.referrerPolicy == null && (i.referrerPolicy = l.referrerPolicy), i.integrity == null && (i.integrity = l.integrity);
  }
  var Ld = null;
  function HE(i, l, d) {
    if (Ld === null) {
      var m = /* @__PURE__ */ new Map(), x = Ld = /* @__PURE__ */ new Map();
      x.set(d, m);
    } else
      x = Ld, m = x.get(d), m || (m = /* @__PURE__ */ new Map(), x.set(d, m));
    if (m.has(i)) return m;
    for (m.set(i, null), d = d.getElementsByTagName(i), x = 0; x < d.length; x++) {
      var C = d[x];
      if (!(C[da] || C[Qt] || i === "link" && C.getAttribute("rel") === "stylesheet") && C.namespaceURI !== "http://www.w3.org/2000/svg") {
        var D = C.getAttribute(l) || "";
        D = i + D;
        var $ = m.get(D);
        $ ? $.push(C) : m.set(D, [C]);
      }
    }
    return m;
  }
  function VE(i, l, d) {
    i = i.ownerDocument || i, i.head.insertBefore(
      d,
      l === "title" ? i.querySelector("head > title") : null
    );
  }
  function XI(i, l, d) {
    if (d === 1 || l.itemProp != null) return !1;
    switch (i) {
      case "meta":
      case "title":
        return !0;
      case "style":
        if (typeof l.precedence != "string" || typeof l.href != "string" || l.href === "")
          break;
        return !0;
      case "link":
        if (typeof l.rel != "string" || typeof l.href != "string" || l.href === "" || l.onLoad || l.onError)
          break;
        switch (l.rel) {
          case "stylesheet":
            return i = l.disabled, typeof l.precedence == "string" && i == null;
          default:
            return !0;
        }
      case "script":
        if (l.async && typeof l.async != "function" && typeof l.async != "symbol" && !l.onLoad && !l.onError && l.src && typeof l.src == "string")
          return !0;
    }
    return !1;
  }
  function UE(i) {
    return !(i.type === "stylesheet" && (i.state.loading & 3) === 0);
  }
  var Gu = null;
  function KI() {
  }
  function ZI(i, l, d) {
    if (Gu === null) throw Error(r(475));
    var m = Gu;
    if (l.type === "stylesheet" && (typeof d.media != "string" || matchMedia(d.media).matches !== !1) && (l.state.loading & 4) === 0) {
      if (l.instance === null) {
        var x = $s(d.href), C = i.querySelector(
          Uu(x)
        );
        if (C) {
          i = C._p, i !== null && typeof i == "object" && typeof i.then == "function" && (m.count++, m = Fd.bind(m), i.then(m, m)), l.state.loading |= 4, l.instance = C, Bt(C);
          return;
        }
        C = i.ownerDocument || i, d = $E(d), (x = br.get(x)) && iy(d, x), C = C.createElement("link"), Bt(C);
        var D = C;
        D._p = new Promise(function($, X) {
          D.onload = $, D.onerror = X;
        }), sn(C, "link", d), l.instance = C;
      }
      m.stylesheets === null && (m.stylesheets = /* @__PURE__ */ new Map()), m.stylesheets.set(l, i), (i = l.state.preload) && (l.state.loading & 3) === 0 && (m.count++, l = Fd.bind(m), i.addEventListener("load", l), i.addEventListener("error", l));
    }
  }
  function QI() {
    if (Gu === null) throw Error(r(475));
    var i = Gu;
    return i.stylesheets && i.count === 0 && sy(i, i.stylesheets), 0 < i.count ? function(l) {
      var d = setTimeout(function() {
        if (i.stylesheets && sy(i, i.stylesheets), i.unsuspend) {
          var m = i.unsuspend;
          i.unsuspend = null, m();
        }
      }, 6e4);
      return i.unsuspend = l, function() {
        i.unsuspend = null, clearTimeout(d);
      };
    } : null;
  }
  function Fd() {
    if (this.count--, this.count === 0) {
      if (this.stylesheets) sy(this, this.stylesheets);
      else if (this.unsuspend) {
        var i = this.unsuspend;
        this.unsuspend = null, i();
      }
    }
  }
  var $d = null;
  function sy(i, l) {
    i.stylesheets = null, i.unsuspend !== null && (i.count++, $d = /* @__PURE__ */ new Map(), l.forEach(JI, i), $d = null, Fd.call(i));
  }
  function JI(i, l) {
    if (!(l.state.loading & 4)) {
      var d = $d.get(i);
      if (d) var m = d.get(null);
      else {
        d = /* @__PURE__ */ new Map(), $d.set(i, d);
        for (var x = i.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), C = 0; C < x.length; C++) {
          var D = x[C];
          (D.nodeName === "LINK" || D.getAttribute("media") !== "not all") && (d.set(D.dataset.precedence, D), m = D);
        }
        m && d.set(null, m);
      }
      x = l.instance, D = x.getAttribute("data-precedence"), C = d.get(D) || m, C === m && d.set(null, x), d.set(D, x), this.count++, m = Fd.bind(this), x.addEventListener("load", m), x.addEventListener("error", m), C ? C.parentNode.insertBefore(x, C.nextSibling) : (i = i.nodeType === 9 ? i.head : i, i.insertBefore(x, i.firstChild)), l.state.loading |= 4;
    }
  }
  var Yu = {
    $$typeof: k,
    Provider: null,
    Consumer: null,
    _currentValue: H,
    _currentValue2: H,
    _threadCount: 0
  };
  function e6(i, l, d, m, x, C, D, $) {
    this.tag = 1, this.containerInfo = i, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Wl(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Wl(0), this.hiddenUpdates = Wl(null), this.identifierPrefix = m, this.onUncaughtError = x, this.onCaughtError = C, this.onRecoverableError = D, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = $, this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function qE(i, l, d, m, x, C, D, $, X, ee, ue, de) {
    return i = new e6(
      i,
      l,
      d,
      D,
      $,
      X,
      ee,
      de
    ), l = 1, C === !0 && (l |= 24), C = Wn(3, null, null, l), i.current = C, C.stateNode = i, l = Hg(), l.refCount++, i.pooledCache = l, l.refCount++, C.memoizedState = {
      element: m,
      isDehydrated: d,
      cache: l
    }, Gg(C), i;
  }
  function GE(i) {
    return i ? (i = vs, i) : vs;
  }
  function YE(i, l, d, m, x, C) {
    x = GE(x), m.context === null ? m.context = x : m.pendingContext = x, m = Ei(l), m.payload = { element: d }, C = C === void 0 ? null : C, C !== null && (m.callback = C), d = Ci(i, m, l), d !== null && (Jn(d, i, l), Su(d, i, l));
  }
  function WE(i, l) {
    if (i = i.memoizedState, i !== null && i.dehydrated !== null) {
      var d = i.retryLane;
      i.retryLane = d !== 0 && d < l ? d : l;
    }
  }
  function ly(i, l) {
    WE(i, l), (i = i.alternate) && WE(i, l);
  }
  function XE(i) {
    if (i.tag === 13) {
      var l = ys(i, 67108864);
      l !== null && Jn(l, i, 67108864), ly(i, 67108864);
    }
  }
  var Bd = !0;
  function t6(i, l, d, m) {
    var x = I.T;
    I.T = null;
    var C = U.p;
    try {
      U.p = 2, uy(i, l, d, m);
    } finally {
      U.p = C, I.T = x;
    }
  }
  function n6(i, l, d, m) {
    var x = I.T;
    I.T = null;
    var C = U.p;
    try {
      U.p = 8, uy(i, l, d, m);
    } finally {
      U.p = C, I.T = x;
    }
  }
  function uy(i, l, d, m) {
    if (Bd) {
      var x = cy(m);
      if (x === null)
        K0(
          i,
          l,
          m,
          Hd,
          d
        ), ZE(i, m);
      else if (o6(
        x,
        i,
        l,
        d,
        m
      ))
        m.stopPropagation();
      else if (ZE(i, m), l & 4 && -1 < r6.indexOf(i)) {
        for (; x !== null; ) {
          var C = ko(x);
          if (C !== null)
            switch (C.tag) {
              case 3:
                if (C = C.stateNode, C.current.memoizedState.isDehydrated) {
                  var D = Sn(C.pendingLanes);
                  if (D !== 0) {
                    var $ = C;
                    for ($.pendingLanes |= 2, $.entangledLanes |= 2; D; ) {
                      var X = 1 << 31 - je(D);
                      $.entanglements[1] |= X, D &= ~X;
                    }
                    Zr(C), (lt & 6) === 0 && (Cd = ct() + 500, $u(0));
                  }
                }
                break;
              case 13:
                $ = ys(C, 2), $ !== null && Jn($, C, 2), Td(), ly(C, 2);
            }
          if (C = cy(m), C === null && K0(
            i,
            l,
            m,
            Hd,
            d
          ), C === x) break;
          x = C;
        }
        x !== null && m.stopPropagation();
      } else
        K0(
          i,
          l,
          m,
          null,
          d
        );
    }
  }
  function cy(i) {
    return i = mg(i), fy(i);
  }
  var Hd = null;
  function fy(i) {
    if (Hd = null, i = vi(i), i !== null) {
      var l = a(i);
      if (l === null) i = null;
      else {
        var d = l.tag;
        if (d === 13) {
          if (i = s(l), i !== null) return i;
          i = null;
        } else if (d === 3) {
          if (l.stateNode.current.memoizedState.isDehydrated)
            return l.tag === 3 ? l.stateNode.containerInfo : null;
          i = null;
        } else l !== i && (i = null);
      }
    }
    return Hd = i, null;
  }
  function KE(i) {
    switch (i) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (cn()) {
          case fr:
            return 2;
          case Un:
            return 8;
          case qn:
          case ze:
            return 32;
          case qr:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var dy = !1, Li = null, Fi = null, $i = null, Wu = /* @__PURE__ */ new Map(), Xu = /* @__PURE__ */ new Map(), Bi = [], r6 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function ZE(i, l) {
    switch (i) {
      case "focusin":
      case "focusout":
        Li = null;
        break;
      case "dragenter":
      case "dragleave":
        Fi = null;
        break;
      case "mouseover":
      case "mouseout":
        $i = null;
        break;
      case "pointerover":
      case "pointerout":
        Wu.delete(l.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Xu.delete(l.pointerId);
    }
  }
  function Ku(i, l, d, m, x, C) {
    return i === null || i.nativeEvent !== C ? (i = {
      blockedOn: l,
      domEventName: d,
      eventSystemFlags: m,
      nativeEvent: C,
      targetContainers: [x]
    }, l !== null && (l = ko(l), l !== null && XE(l)), i) : (i.eventSystemFlags |= m, l = i.targetContainers, x !== null && l.indexOf(x) === -1 && l.push(x), i);
  }
  function o6(i, l, d, m, x) {
    switch (l) {
      case "focusin":
        return Li = Ku(
          Li,
          i,
          l,
          d,
          m,
          x
        ), !0;
      case "dragenter":
        return Fi = Ku(
          Fi,
          i,
          l,
          d,
          m,
          x
        ), !0;
      case "mouseover":
        return $i = Ku(
          $i,
          i,
          l,
          d,
          m,
          x
        ), !0;
      case "pointerover":
        var C = x.pointerId;
        return Wu.set(
          C,
          Ku(
            Wu.get(C) || null,
            i,
            l,
            d,
            m,
            x
          )
        ), !0;
      case "gotpointercapture":
        return C = x.pointerId, Xu.set(
          C,
          Ku(
            Xu.get(C) || null,
            i,
            l,
            d,
            m,
            x
          )
        ), !0;
    }
    return !1;
  }
  function QE(i) {
    var l = vi(i.target);
    if (l !== null) {
      var d = a(l);
      if (d !== null) {
        if (l = d.tag, l === 13) {
          if (l = s(d), l !== null) {
            i.blockedOn = l, ig(i.priority, function() {
              if (d.tag === 13) {
                var m = Qn();
                m = Kl(m);
                var x = ys(d, m);
                x !== null && Jn(x, d, m), ly(d, m);
              }
            });
            return;
          }
        } else if (l === 3 && d.stateNode.current.memoizedState.isDehydrated) {
          i.blockedOn = d.tag === 3 ? d.stateNode.containerInfo : null;
          return;
        }
      }
    }
    i.blockedOn = null;
  }
  function Vd(i) {
    if (i.blockedOn !== null) return !1;
    for (var l = i.targetContainers; 0 < l.length; ) {
      var d = cy(i.nativeEvent);
      if (d === null) {
        d = i.nativeEvent;
        var m = new d.constructor(
          d.type,
          d
        );
        pg = m, d.target.dispatchEvent(m), pg = null;
      } else
        return l = ko(d), l !== null && XE(l), i.blockedOn = d, !1;
      l.shift();
    }
    return !0;
  }
  function JE(i, l, d) {
    Vd(i) && d.delete(l);
  }
  function i6() {
    dy = !1, Li !== null && Vd(Li) && (Li = null), Fi !== null && Vd(Fi) && (Fi = null), $i !== null && Vd($i) && ($i = null), Wu.forEach(JE), Xu.forEach(JE);
  }
  function Ud(i, l) {
    i.blockedOn === l && (i.blockedOn = null, dy || (dy = !0, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      i6
    )));
  }
  var qd = null;
  function eC(i) {
    qd !== i && (qd = i, e.unstable_scheduleCallback(
      e.unstable_NormalPriority,
      function() {
        qd === i && (qd = null);
        for (var l = 0; l < i.length; l += 3) {
          var d = i[l], m = i[l + 1], x = i[l + 2];
          if (typeof m != "function") {
            if (fy(m || d) === null)
              continue;
            break;
          }
          var C = ko(d);
          C !== null && (i.splice(l, 3), l -= 3, f0(
            C,
            {
              pending: !0,
              data: x,
              method: d.method,
              action: m
            },
            m,
            x
          ));
        }
      }
    ));
  }
  function Zu(i) {
    function l(X) {
      return Ud(X, i);
    }
    Li !== null && Ud(Li, i), Fi !== null && Ud(Fi, i), $i !== null && Ud($i, i), Wu.forEach(l), Xu.forEach(l);
    for (var d = 0; d < Bi.length; d++) {
      var m = Bi[d];
      m.blockedOn === i && (m.blockedOn = null);
    }
    for (; 0 < Bi.length && (d = Bi[0], d.blockedOn === null); )
      QE(d), d.blockedOn === null && Bi.shift();
    if (d = (i.ownerDocument || i).$$reactFormReplay, d != null)
      for (m = 0; m < d.length; m += 3) {
        var x = d[m], C = d[m + 1], D = x[dn] || null;
        if (typeof C == "function")
          D || eC(d);
        else if (D) {
          var $ = null;
          if (C && C.hasAttribute("formAction")) {
            if (x = C, D = C[dn] || null)
              $ = D.formAction;
            else if (fy(x) !== null) continue;
          } else $ = D.action;
          typeof $ == "function" ? d[m + 1] = $ : (d.splice(m, 3), m -= 3), eC(d);
        }
      }
  }
  function hy(i) {
    this._internalRoot = i;
  }
  Gd.prototype.render = hy.prototype.render = function(i) {
    var l = this._internalRoot;
    if (l === null) throw Error(r(409));
    var d = l.current, m = Qn();
    YE(d, m, i, l, null, null);
  }, Gd.prototype.unmount = hy.prototype.unmount = function() {
    var i = this._internalRoot;
    if (i !== null) {
      this._internalRoot = null;
      var l = i.containerInfo;
      YE(i.current, 2, null, i, null, null), Td(), l[yi] = null;
    }
  };
  function Gd(i) {
    this._internalRoot = i;
  }
  Gd.prototype.unstable_scheduleHydration = function(i) {
    if (i) {
      var l = Df();
      i = { blockedOn: null, target: i, priority: l };
      for (var d = 0; d < Bi.length && l !== 0 && l < Bi[d].priority; d++) ;
      Bi.splice(d, 0, i), d === 0 && QE(i);
    }
  };
  var tC = t.version;
  if (tC !== "19.1.0")
    throw Error(
      r(
        527,
        tC,
        "19.1.0"
      )
    );
  U.findDOMNode = function(i) {
    var l = i._reactInternals;
    if (l === void 0)
      throw typeof i.render == "function" ? Error(r(188)) : (i = Object.keys(i).join(","), Error(r(268, i)));
    return i = c(l), i = i !== null ? f(i) : null, i = i === null ? null : i.stateNode, i;
  };
  var a6 = {
    bundleType: 0,
    version: "19.1.0",
    rendererPackageName: "react-dom",
    currentDispatcherRef: I,
    reconcilerVersion: "19.1.0"
  };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var Yd = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!Yd.isDisabled && Yd.supportsFiber)
      try {
        se = Yd.inject(
          a6
        ), pe = Yd;
      } catch {
      }
  }
  return ec.createRoot = function(i, l) {
    if (!o(i)) throw Error(r(299));
    var d = !1, m = "", x = yS, C = vS, D = bS, $ = null;
    return l != null && (l.unstable_strictMode === !0 && (d = !0), l.identifierPrefix !== void 0 && (m = l.identifierPrefix), l.onUncaughtError !== void 0 && (x = l.onUncaughtError), l.onCaughtError !== void 0 && (C = l.onCaughtError), l.onRecoverableError !== void 0 && (D = l.onRecoverableError), l.unstable_transitionCallbacks !== void 0 && ($ = l.unstable_transitionCallbacks)), l = qE(
      i,
      1,
      !1,
      null,
      null,
      d,
      m,
      x,
      C,
      D,
      $,
      null
    ), i[yi] = l.current, X0(i), new hy(l);
  }, ec.hydrateRoot = function(i, l, d) {
    if (!o(i)) throw Error(r(299));
    var m = !1, x = "", C = yS, D = vS, $ = bS, X = null, ee = null;
    return d != null && (d.unstable_strictMode === !0 && (m = !0), d.identifierPrefix !== void 0 && (x = d.identifierPrefix), d.onUncaughtError !== void 0 && (C = d.onUncaughtError), d.onCaughtError !== void 0 && (D = d.onCaughtError), d.onRecoverableError !== void 0 && ($ = d.onRecoverableError), d.unstable_transitionCallbacks !== void 0 && (X = d.unstable_transitionCallbacks), d.formState !== void 0 && (ee = d.formState)), l = qE(
      i,
      1,
      !0,
      l,
      d ?? null,
      m,
      x,
      C,
      D,
      $,
      X,
      ee
    ), l.context = GE(null), d = l.current, m = Qn(), m = Kl(m), x = Ei(m), x.callback = null, Ci(d, x, m), d = m, l.current.lanes = d, fa(l, d), Zr(l), i[yi] = l.current, X0(i), new Gd(l);
  }, ec.version = "19.1.0", ec;
}
var fC;
function b6() {
  if (fC) return my.exports;
  fC = 1;
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  return e(), my.exports = v6(), my.exports;
}
var x6 = b6(), _ = ef();
const nn = /* @__PURE__ */ jl(_), yl = /* @__PURE__ */ c6({
  __proto__: null,
  default: nn
}, [_]), Zt = {
  /** Debug level - most verbose, for development debugging */
  DEBUG: 0,
  /** Info level - general information about application flow */
  INFO: 10,
  /** Warning level - concerning but non-critical issues */
  WARN: 20,
  /** Error level - critical problems requiring attention */
  ERROR: 30
}, w6 = Zt.DEBUG, eM = Zt.INFO, _6 = Zt.WARN, S6 = Zt.ERROR, dC = (e) => typeof e == "string" ? e : e === Zt.DEBUG ? "DEBUG" : e === Zt.INFO ? "INFO" : e === Zt.WARN ? "WARN" : e === Zt.ERROR ? "ERROR" : "UNKNOWN";
function E6() {
  const e = [];
  return function(t, n) {
    if (typeof n != "object" || n === null)
      return n;
    for (; e.length > 0 && e.at(-1) !== this; )
      e.pop();
    return e.includes(n) ? "[Circular]" : (e.push(n), n);
  };
}
const hC = (e) => {
  if (typeof e == "number") return e;
  const t = e.toLowerCase();
  if (t === "debug") return Zt.DEBUG;
  if (t === "info") return Zt.INFO;
  if (t === "warn" || t === "warning") return Zt.WARN;
  if (t === "error") return Zt.ERROR;
  throw new Error(`Unknown log level: ${e}`);
};
class u1 {
  /**
   * Create a new BaseLogger instance.
   *
   * @param {string} name - The name/identifier for this logger
   * @param {number | string} [level=LEVELS.INFO] - Initial log level
   * @param {boolean} [with_timestamp=true] - Whether to include timestamps
   * @example
   * ```typescript
   * const logger = new MyLogger("DatabaseService", "DEBUG", true);
   * ```
   */
  constructor(t, n = Zt.INFO, r = !0) {
    this.name = t, this.level = hC(n), this._level_name = dC(this.level), this.with_timestamp = r;
  }
  /**
   * Set the logging level for this logger instance.
   *
   * @param {number | string} level - The new log level (numeric or string)
   * @example
   * ```typescript
   * logger.set_level(DEBUG); // Enable debug logging
   * logger.set_level("debug"); // Same as above using string
   * ```
   */
  set_level(t) {
    typeof t == "string" && (t = hC(t)), this.level = t, this._level_name = dC(this.level);
  }
  /**
   * Get the string representation of the current log level.
   *
   * @returns {string} The current log level as a string
   * @example
   * ```typescript
   * logger.level_name // "INFO"
   * ```
   */
  get level_name() {
    return this._level_name;
  }
  /**
   * Format a log message with level, timestamp, and arguments.
   *
   * @param {string} levelstring - The log level string (DEBUG, INFO, etc.)
   * @param {string} message - The primary log message
   * @param {...any[]} args - Additional arguments to include
   * @returns {string} The formatted log message
   * @example
   * ```typescript
   * // Returns: "12/25/2023, 10:30:15 AM [MyApp] INFO: User logged in {userId: 123}"
   * logger.format_message("INFO", "User logged in", {userId: 123});
   * ```
   */
  format_message(t, n, ...r) {
    return `${this.with_timestamp ? (/* @__PURE__ */ new Date()).toLocaleString() : ""} [${this.name}] ${t}: ${n} ${r.map((a) => JSON.stringify(a, E6())).join(" ")}`.trim();
  }
  /**
   * Log a debug message if the current level allows it.
   *
   * @param {string} message - The primary log message
   * @param {...any[]} args - Additional context arguments
   */
  debug(t, ...n) {
    this.level <= Zt.DEBUG && this.out_debug(this.format_message("DEBUG", t, ...n));
  }
  /**
   * Log an info message if the current level allows it.
   *
   * @param {string} message - The primary log message
   * @param {...any[]} args - Additional context arguments
   */
  info(t, ...n) {
    this.level <= Zt.INFO && this.out_info(this.format_message("INFO", t, ...n));
  }
  /**
   * Log a warning message if the current level allows it.
   *
   * @param {string} message - The primary log message
   * @param {...any[]} args - Additional context arguments
   */
  warn(t, ...n) {
    this.level <= Zt.WARN && this.out_warn(this.format_message("WARN", t, ...n));
  }
  /**
   * Log an error message if the current level allows it.
   *
   * @param {string} message - The primary log message
   * @param {Error} [error] - Optional Error object for stack trace handling
   */
  error(t, n) {
    this.level <= Zt.ERROR && this.out_error(this.format_message("ERROR", t), n);
  }
}
class c1 extends u1 {
  /**
   * Create a new ConsoleLogger instance.
   *
   * @param {string} name - The name/identifier for this logger
   * @param {number | string} [level=LEVELS.INFO] - Initial log level
   * @example
   * ```typescript
   * const logger = new ConsoleLogger("API", "WARN");
   * ```
   */
  constructor(t, n = Zt.INFO) {
    super(t, n);
  }
  /**
   * Output debug message to console.debug.
   *
   * @protected
   * @param {string} formatted_message - The formatted message to output
   */
  out_debug(t) {
    console.debug(t);
  }
  /**
   * Output info message to console.info.
   *
   * @protected
   * @param {string} formatted_message - The formatted message to output
   */
  out_info(t) {
    console.info(t);
  }
  /**
   * Output warning message to console.warn.
   *
   * @protected
   * @param {string} formatted_message - The formatted message to output
   */
  out_warn(t) {
    console.warn(t);
  }
  /**
   * Output error message to console.error.
   *
   * @protected
   * @param {string} formatted_message - The formatted message to output
   * @param {Error | undefined} error - Optional Error object for stack trace handling
   */
  out_error(t, n) {
    console.error(t), n && console.error(n);
  }
}
function xy(e) {
  return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
class C6 extends u1 {
  /**
   * Create a new DivLogger instance.
   *
   * @param {HTMLDivElement} div - The HTML div element to append log messages to
   * @param {string} name - The name/identifier for this logger
   * @param {number | string} [level=LEVELS.INFO] - Initial log level
   * @example
   * ```typescript
   * const logContainer = document.createElement('div');
   * const logger = new DivLogger(logContainer, "WebWorker", "DEBUG");
   * ```
   */
  constructor(t, n, r = Zt.INFO) {
    super(n, r), this._div = t;
  }
  /**
   * Format a log message with HTML escaping for safe DOM insertion.
   *
   * Overrides the base implementation to automatically escape HTML content,
   * preventing XSS vulnerabilities when displaying logs in web interfaces.
   *
   * @param {string} levelstring - The log level string (DEBUG, INFO, etc.)
   * @param {string} message - The primary log message
   * @param {...any[]} args - Additional arguments to include
   * @returns {string} The formatted and HTML-escaped log message
   * @example
   * ```typescript
   * // Input: "User input: <script>alert('xss')<\/script>"
   * // Output: "12/25/2023, 10:30:15 AM [UI] INFO: User input: &lt;script&gt;alert('xss')&lt;/script&gt;"
   * ```
   */
  format_message(t, n, ...r) {
    return xy(super.format_message(t, n, ...r));
  }
  /**
   * Output debug message as HTML div with 'debug' class.
   *
   * @protected
   * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
   */
  out_debug(t) {
    this._div.innerHTML += `<div class="debug">${t}</div>`;
  }
  /**
   * Output info message as HTML div with 'info' class.
   *
   * @protected
   * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
   */
  out_info(t) {
    this._div.innerHTML += `<div class="info">${t}</div>`;
  }
  /**
   * Output warning message as HTML div with 'warn' class.
   *
   * @protected
   * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
   */
  out_warn(t) {
    this._div.innerHTML += `<div class="warn">${t}</div>`;
  }
  /**
   * Output error message as HTML div with 'error' class.
   *
   * @protected
   * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
   * @param {Error | undefined} error - Optional Error object for stack trace handling
   */
  out_error(t, n) {
    let r = t;
    if (n) {
      const o = n.stack ? xy(n.stack) : xy(n.message);
      r += `<br><pre>${o}</pre>`;
    }
    this._div.innerHTML += `<div class="error">${r}</div>`;
  }
}
function k6(e) {
  const t = window.atob(e), n = t.length, r = new Uint8Array(n);
  for (let o = 0; o < n; o++)
    r[o] = t.charCodeAt(o);
  return r;
}
function T6(e, t) {
  return new Blob([e], { type: t });
}
function A6(e, t) {
  return T6(k6(e), t);
}
function R6(e, t, n) {
  const r = A6(e, n), o = URL.createObjectURL(r), a = document.createElement("a");
  a.href = o, a.download = t, a.click(), URL.revokeObjectURL(o), a.remove();
}
function M6(e, t = !0) {
  return new Promise((n, r) => {
    const o = new FileReader();
    o.onload = () => {
      const a = o.result;
      n(t ? a.split(",")[1] : a);
    }, o.onerror = () => r(o.error), o.readAsDataURL(e);
  });
}
function O6(e) {
  return new Promise((t, n) => {
    const r = document.createElement("input");
    r.type = "file", r.accept = e, r.onchange = () => {
      const o = r.files?.[0];
      o ? t(o) : n(new Error("No file selected"));
    }, r.oncancel = () => {
      n(new Error("File selection cancelled"));
    }, r.click();
  });
}
function N6(e) {
  return O6(e).then(M6);
}
async function D6(e, t = !0) {
  try {
    const n = await fetch(e);
    if (!n.ok)
      throw new Error(
        `Failed to fetch from URL: ${n.status} ${n.statusText}`
      );
    const r = await n.blob();
    return await new Promise((a, s) => {
      const u = new FileReader();
      u.onload = () => {
        const c = u.result;
        typeof c != "string" && (s("Failed to convert URL to Base64: No result from FileReader"), s(u.error)), a(t ? c.split(",")[1] : c);
      }, u.onerror = () => s(u.error), u.readAsDataURL(r);
    });
  } catch (n) {
    throw console.error("Error converting URL to Base64:", n), n;
  }
}
function Ki(e) {
  if (Object.prototype.toString.call(e) !== "[object Object]")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t === null || t === Object.prototype;
}
function f1(e, t, n = /* @__PURE__ */ new WeakMap()) {
  if (e === t) return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  if (n.has(e))
    return n.get(e) === t;
  if (n.set(e, t), e.constructor !== t.constructor) return !1;
  if (e.constructor === Object || e.constructor === Array) {
    const r = Object.keys(e), o = Object.keys(t);
    if (r.length !== o.length) return !1;
    for (const a of r)
      if (!o.includes(a) || !f1(e[a], t[a], n)) return !1;
  }
  return e instanceof Date && t instanceof Date ? e.getTime() === t.getTime() : !0;
}
const Ha = (e, t) => {
  let n = !1;
  if (!Ki(e))
    throw new Error("Target must be a plain object not" + typeof e);
  if (!Ki(t))
    throw new Error("Source must be a plain object not" + typeof t);
  const r = { ...e };
  return Object.keys(t).forEach((o) => {
    const a = t[o], s = e[o];
    if (Ki(a) && Ki(s)) {
      const { new_obj: u, change: c } = Ha(
        s,
        a
      );
      c && (n = !0, r[o] = u);
    } else f1(s, a) || (n = !0, r[o] = a);
  }), { new_obj: r, change: n };
}, tM = (e, t) => {
  let n = !1;
  if (!Ki(e))
    throw new Error("Target must be a plain object");
  if (!Ki(t))
    throw new Error("Source must be a plain object");
  const r = { ...e };
  return Object.keys(t).forEach((o) => {
    const a = t[o], s = e[o];
    if (!(s === void 0 && a === void 0)) {
      if (s === void 0) {
        n = !0, r[o] = a;
        return;
      }
      if (Ki(a) && Ki(s)) {
        const { new_obj: u, change: c } = tM(
          s,
          a
        );
        c && (n = !0, r[o] = u);
      }
    }
  }), { new_obj: r, change: n };
}, d1 = (e, t = void 0) => {
  const n = JSON.stringify(e);
  return (r) => {
    let o = JSON.parse(n);
    return t !== void 0 && (o = t(o)), r === void 0 ? o : tM(r, o).new_obj;
  };
}, wr = (e, t) => t === void 0 ? [e, !1] : [t, e !== t];
function nM(e, t) {
  throw new Error("Unhandled case: " + e + " with: " + JSON.stringify(t));
}
const rl = (e, t) => {
  if (t === void 0) return [e, !1];
  if (e === void 0) return [t, t !== void 0];
  const { new_obj: n, change: r } = Ha(e, t);
  return [n, r];
}, j6 = ({ error: e }) => /* @__PURE__ */ b.jsxs("div", { className: "error-div", children: [
  /* @__PURE__ */ b.jsx("h1", { children: "Error" }),
  /* @__PURE__ */ b.jsx("p", { children: e.message })
] });
var Pl = JR();
const P6 = /* @__PURE__ */ jl(Pl), $p = _.createContext(
  void 0
), Zi = _.forwardRef((e, t) => {
  const {
    asChild: n = !1,
    children: r,
    className: o,
    style: a,
    htime: s = 300,
    vtime: u = 300,
    hdelay: c = 0,
    vdelay: f = 200,
    zIndex: h = 9999,
    ...p
  } = e, [g, y] = _.useState(!1), [w, v] = _.useState({}), S = _.useRef(null), E = _.useRef(null);
  _.useImperativeHandle(t, () => S.current, []);
  const A = _.useMemo(
    () => ({
      horizontal: s,
      vertical: u,
      horizontalDelay: c,
      verticalDelay: f
    }),
    [s, u, c, f]
  ), k = _.useCallback(
    () => Math.max(
      A.horizontal + A.horizontalDelay,
      A.vertical + A.verticalDelay
    ),
    [A]
  ), T = _.useCallback(async () => {
    if (S.current)
      try {
        const F = S.current.getBoundingClientRect();
        E.current = F, v({
          position: "fixed",
          top: `${F.top}px`,
          left: `${F.left}px`,
          width: `${F.width}px`,
          height: `${F.height}px`,
          zIndex: h,
          transition: "none"
        }), y(!0), S.current.offsetHeight, v((q) => ({
          ...q,
          transition: [
            `width ${A.horizontal}ms ease-in-out ${A.horizontalDelay}ms`,
            `left ${A.horizontal}ms ease-in-out ${A.horizontalDelay}ms`,
            `height ${A.vertical}ms ease-in-out ${A.verticalDelay}ms`,
            `top ${A.vertical}ms ease-in-out ${A.verticalDelay}ms`
          ].join(", ")
        })), requestAnimationFrame(() => {
          v((q) => ({
            ...q,
            top: "0",
            left: "0",
            width: "100vw",
            height: "100vh"
          }));
        }), await new Promise((q) => setTimeout(q, k()));
      } catch (F) {
        console.warn("Error during expand animation:", F), y(!0);
      }
  }, [A, h, k]), R = _.useCallback(async () => {
    if (!S.current || !E.current) return;
    const F = E.current;
    v((q) => ({
      ...q,
      transition: [
        `width ${A.horizontal}ms ease-in-out ${A.verticalDelay}ms`,
        `left ${A.horizontal}ms ease-in-out ${A.verticalDelay}ms`,
        `height ${A.vertical}ms ease-in-out ${A.horizontalDelay}ms`,
        `top ${A.vertical}ms ease-in-out ${A.horizontalDelay}ms`
      ].join(", ")
    })), requestAnimationFrame(() => {
      v((q) => ({
        ...q,
        top: `${F.top}px`,
        left: `${F.left}px`,
        width: `${F.width}px`,
        height: `${F.height}px`
      }));
    }), await new Promise((q) => setTimeout(q, k())), v({}), y(!1), E.current = null;
  }, [A, k]), N = _.useCallback(async () => {
    g ? await R() : await T();
  }, [g, T, R]), j = _.useMemo(
    () => ({ isExpanded: g, toggleExpand: N }),
    [g, N]
  ), z = _.useMemo(
    () => ({ ...a, ...w }),
    [a, w]
  );
  let B;
  if (n && _.isValidElement(r)) {
    const F = r;
    B = _.cloneElement(F, {
      ref: S,
      className: [F.props.className, o].filter(Boolean).join(" "),
      style: { ...F.props.style, ...z },
      ...p
    });
  } else
    B = /* @__PURE__ */ b.jsx("div", { ref: S, className: o, style: z, ...p, children: r });
  const M = /* @__PURE__ */ b.jsx($p.Provider, { value: j, children: B });
  return g ? Pl.createPortal(M, document.body) : M;
});
Zi.displayName = "SmoothExpand";
Zi.Trigger = function({
  children: t,
  className: n
}) {
  const r = _.useContext($p);
  if (!r)
    throw new Error(
      "SmoothExpand.Trigger must be used within a SmoothExpand component"
    );
  return /* @__PURE__ */ b.jsx(
    "div",
    {
      className: n,
      style: { cursor: "pointer" },
      onClick: r.toggleExpand,
      role: "button",
      tabIndex: 0,
      onKeyDown: (o) => {
        (o.key === "Enter" || o.key === " ") && (o.preventDefault(), r.toggleExpand());
      },
      children: t
    }
  );
};
Zi.Expanded = function({
  children: t
}) {
  const n = _.useContext($p);
  if (!n)
    throw new Error(
      "SmoothExpand.Expanded must be used within a SmoothExpand component"
    );
  return n.isExpanded ? /* @__PURE__ */ b.jsx(b.Fragment, { children: t }) : null;
};
Zi.Collapsed = function({
  children: t
}) {
  const n = _.useContext($p);
  if (!n)
    throw new Error(
      "SmoothExpand.Collapsed must be used within a SmoothExpand component"
    );
  return n.isExpanded ? null : /* @__PURE__ */ b.jsx(b.Fragment, { children: t });
};
const Bp = _.createContext(
  void 0
), Wo = _.forwardRef((e, t) => {
  const { asChild: n = !1, children: r, className: o, style: a, ...s } = e, [u, c] = _.useState(!1), f = _.useRef(null);
  _.useImperativeHandle(t, () => f.current, []);
  const h = _.useCallback(async (S) => {
    const E = S;
    if (S.requestFullscreen)
      await S.requestFullscreen();
    else if (E.mozRequestFullScreen)
      await E.mozRequestFullScreen();
    else if (E.webkitRequestFullscreen)
      await E.webkitRequestFullscreen();
    else if (E.msRequestFullscreen)
      await E.msRequestFullscreen();
    else
      throw new Error("Fullscreen API is not supported in this browser");
  }, []), p = _.useCallback(async () => {
    const S = document;
    if (document.exitFullscreen)
      await document.exitFullscreen();
    else if (S.mozCancelFullScreen)
      await S.mozCancelFullScreen();
    else if (S.webkitExitFullscreen)
      await S.webkitExitFullscreen();
    else if (S.msExitFullscreen)
      await S.msExitFullscreen();
    else
      throw new Error("Exit fullscreen API is not supported in this browser");
  }, []), g = _.useCallback(async () => {
    try {
      const S = f.current;
      if (!S) {
        console.warn("FullScreen: No element reference available");
        return;
      }
      u ? await p() : await h(S);
    } catch (S) {
      console.error("FullScreen: Error toggling fullscreen mode", S);
    }
  }, [u, h, p]), y = _.useCallback(() => {
    const S = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
    c(S);
  }, []);
  _.useEffect(() => {
    const S = [
      "fullscreenchange",
      "webkitfullscreenchange",
      "mozfullscreenchange",
      "MSFullscreenChange"
    ];
    return S.forEach((E) => {
      document.addEventListener(E, y);
    }), () => {
      S.forEach((E) => {
        document.removeEventListener(E, y);
      });
    };
  }, [y]);
  const w = _.useMemo(
    () => ({ isFullScreen: u, toggleFullscreen: g }),
    [u, g]
  );
  let v;
  if (n && _.isValidElement(r)) {
    const S = r;
    v = _.cloneElement(S, {
      ref: f,
      className: [S.props.className, o].filter(Boolean).join(" "),
      style: { ...S.props.style, ...a },
      ...s
    });
  } else
    v = /* @__PURE__ */ b.jsx("div", { ref: f, className: o, style: a, ...s, children: r });
  return /* @__PURE__ */ b.jsx(Bp.Provider, { value: w, children: v });
});
Wo.displayName = "FullScreen";
Wo.Trigger = function({
  children: t,
  className: n
}) {
  const r = _.useContext(Bp);
  if (!r)
    throw new Error(
      "FullScreen.Trigger must be used within a FullScreen component"
    );
  return /* @__PURE__ */ b.jsx(
    "div",
    {
      className: n,
      style: { cursor: "pointer" },
      onClick: r.toggleFullscreen,
      role: "button",
      tabIndex: 0,
      onKeyDown: (o) => {
        (o.key === "Enter" || o.key === " ") && (o.preventDefault(), r.toggleFullscreen());
      },
      children: t
    }
  );
};
Wo.InFullScreen = function({
  children: t
}) {
  const n = _.useContext(Bp);
  if (!n)
    throw new Error(
      "FullScreen.InFullScreen must be used within a FullScreen component"
    );
  return n.isFullScreen ? /* @__PURE__ */ b.jsx(b.Fragment, { children: t }) : null;
};
Wo.OutFullScreen = function({
  children: t
}) {
  const n = _.useContext(Bp);
  if (!n)
    throw new Error(
      "FullScreen.OutFullScreen must be used within a FullScreen component"
    );
  return n.isFullScreen ? null : /* @__PURE__ */ b.jsx(b.Fragment, { children: t });
};
var wy = { exports: {} }, _y, pC;
function I6() {
  if (pC) return _y;
  pC = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return _y = e, _y;
}
var Sy, mC;
function z6() {
  if (mC) return Sy;
  mC = 1;
  var e = /* @__PURE__ */ I6();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Sy = function() {
    function r(s, u, c, f, h, p) {
      if (p !== e) {
        var g = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw g.name = "Invariant Violation", g;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var a = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return a.PropTypes = a, a;
  }, Sy;
}
var gC;
function L6() {
  return gC || (gC = 1, wy.exports = /* @__PURE__ */ z6()()), wy.exports;
}
var Ut = /* @__PURE__ */ L6();
const Ve = /* @__PURE__ */ jl(Ut);
function rM(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (n = rM(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function zt() {
  for (var e, t, n = 0, r = "", o = arguments.length; n < o; n++) (e = arguments[n]) && (t = rM(e)) && (r && (r += " "), r += t);
  return r;
}
function li(e, t, n = void 0) {
  const r = {};
  for (const o in e) {
    const a = e[o];
    let s = "", u = !0;
    for (let c = 0; c < a.length; c += 1) {
      const f = a[c];
      f && (s += (u === !0 ? "" : " ") + t(f), u = !1, n && n[f] && (s += " " + n[f]));
    }
    r[o] = s;
  }
  return r;
}
const oM = /* @__PURE__ */ _.createContext();
function Va(e, ...t) {
  const n = new URL(`https://mui.com/production-error/?code=${e}`);
  return t.forEach((r) => n.searchParams.append("args[]", r)), `Minified MUI error #${e}; visit ${n} for the full message.`;
}
function Tn(e) {
  if (typeof e != "string")
    throw new Error(Va(7));
  return e.charAt(0).toUpperCase() + e.slice(1);
}
var Ey = { exports: {} }, pt = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var yC;
function F6() {
  if (yC) return pt;
  yC = 1;
  var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.consumer"), s = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), f = Symbol.for("react.suspense_list"), h = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), g = Symbol.for("react.view_transition"), y = Symbol.for("react.client.reference");
  function w(v) {
    if (typeof v == "object" && v !== null) {
      var S = v.$$typeof;
      switch (S) {
        case e:
          switch (v = v.type, v) {
            case n:
            case o:
            case r:
            case c:
            case f:
            case g:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case u:
                case p:
                case h:
                  return v;
                case a:
                  return v;
                default:
                  return S;
              }
          }
        case t:
          return S;
      }
    }
  }
  return pt.ContextConsumer = a, pt.ContextProvider = s, pt.Element = e, pt.ForwardRef = u, pt.Fragment = n, pt.Lazy = p, pt.Memo = h, pt.Portal = t, pt.Profiler = o, pt.StrictMode = r, pt.Suspense = c, pt.SuspenseList = f, pt.isContextConsumer = function(v) {
    return w(v) === a;
  }, pt.isContextProvider = function(v) {
    return w(v) === s;
  }, pt.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === e;
  }, pt.isForwardRef = function(v) {
    return w(v) === u;
  }, pt.isFragment = function(v) {
    return w(v) === n;
  }, pt.isLazy = function(v) {
    return w(v) === p;
  }, pt.isMemo = function(v) {
    return w(v) === h;
  }, pt.isPortal = function(v) {
    return w(v) === t;
  }, pt.isProfiler = function(v) {
    return w(v) === o;
  }, pt.isStrictMode = function(v) {
    return w(v) === r;
  }, pt.isSuspense = function(v) {
    return w(v) === c;
  }, pt.isSuspenseList = function(v) {
    return w(v) === f;
  }, pt.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === n || v === o || v === r || v === c || v === f || typeof v == "object" && v !== null && (v.$$typeof === p || v.$$typeof === h || v.$$typeof === s || v.$$typeof === a || v.$$typeof === u || v.$$typeof === y || v.getModuleId !== void 0);
  }, pt.typeOf = w, pt;
}
var vC;
function $6() {
  return vC || (vC = 1, Ey.exports = /* @__PURE__ */ F6()), Ey.exports;
}
var iM = /* @__PURE__ */ $6();
function Xo(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function aM(e) {
  if (/* @__PURE__ */ _.isValidElement(e) || iM.isValidElementType(e) || !Xo(e))
    return e;
  const t = {};
  return Object.keys(e).forEach((n) => {
    t[n] = aM(e[n]);
  }), t;
}
function or(e, t, n = {
  clone: !0
}) {
  const r = n.clone ? {
    ...e
  } : e;
  return Xo(e) && Xo(t) && Object.keys(t).forEach((o) => {
    /* @__PURE__ */ _.isValidElement(t[o]) || iM.isValidElementType(t[o]) ? r[o] = t[o] : Xo(t[o]) && // Avoid prototype pollution
    Object.prototype.hasOwnProperty.call(e, o) && Xo(e[o]) ? r[o] = or(e[o], t[o], n) : n.clone ? r[o] = Xo(t[o]) ? aM(t[o]) : t[o] : r[o] = t[o];
  }), r;
}
function vc(e, t) {
  return t ? or(e, t, {
    clone: !1
    // No need to clone deep, it's way faster.
  }) : e;
}
function bC(e, t) {
  if (!e.containerQueries)
    return t;
  const n = Object.keys(t).filter((r) => r.startsWith("@container")).sort((r, o) => {
    const a = /min-width:\s*([0-9.]+)/;
    return +(r.match(a)?.[1] || 0) - +(o.match(a)?.[1] || 0);
  });
  return n.length ? n.reduce((r, o) => {
    const a = t[o];
    return delete r[o], r[o] = a, r;
  }, {
    ...t
  }) : t;
}
function B6(e, t) {
  return t === "@" || t.startsWith("@") && (e.some((n) => t.startsWith(`@${n}`)) || !!t.match(/^@\d/));
}
function H6(e, t) {
  const n = t.match(/^@([^/]+)?\/?(.+)?$/);
  if (!n)
    return null;
  const [, r, o] = n, a = Number.isNaN(+r) ? r || 0 : +r;
  return e.containerQueries(o).up(a);
}
function V6(e) {
  const t = (a, s) => a.replace("@media", s ? `@container ${s}` : "@container");
  function n(a, s) {
    a.up = (...u) => t(e.breakpoints.up(...u), s), a.down = (...u) => t(e.breakpoints.down(...u), s), a.between = (...u) => t(e.breakpoints.between(...u), s), a.only = (...u) => t(e.breakpoints.only(...u), s), a.not = (...u) => {
      const c = t(e.breakpoints.not(...u), s);
      return c.includes("not all and") ? c.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or") : c;
    };
  }
  const r = {}, o = (a) => (n(r, a), r);
  return n(o), {
    ...e,
    containerQueries: o
  };
}
const Hp = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
}, xC = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (e) => `@media (min-width:${Hp[e]}px)`
}, U6 = {
  containerQueries: (e) => ({
    up: (t) => {
      let n = typeof t == "number" ? t : Hp[t] || t;
      return typeof n == "number" && (n = `${n}px`), e ? `@container ${e} (min-width:${n})` : `@container (min-width:${n})`;
    }
  })
};
function ti(e, t, n) {
  const r = e.theme || {};
  if (Array.isArray(t)) {
    const a = r.breakpoints || xC;
    return t.reduce((s, u, c) => (s[a.up(a.keys[c])] = n(t[c]), s), {});
  }
  if (typeof t == "object") {
    const a = r.breakpoints || xC;
    return Object.keys(t).reduce((s, u) => {
      if (B6(a.keys, u)) {
        const c = H6(r.containerQueries ? r : U6, u);
        c && (s[c] = n(t[u], u));
      } else if (Object.keys(a.values || Hp).includes(u)) {
        const c = a.up(u);
        s[c] = n(t[u], u);
      } else {
        const c = u;
        s[c] = t[c];
      }
      return s;
    }, {});
  }
  return n(t);
}
function q6(e = {}) {
  return e.keys?.reduce((n, r) => {
    const o = e.up(r);
    return n[o] = {}, n;
  }, {}) || {};
}
function wC(e, t) {
  return e.reduce((n, r) => {
    const o = n[r];
    return (!o || Object.keys(o).length === 0) && delete n[r], n;
  }, t);
}
function Vp(e, t, n = !0) {
  if (!t || typeof t != "string")
    return null;
  if (e && e.vars && n) {
    const r = `vars.${t}`.split(".").reduce((o, a) => o && o[a] ? o[a] : null, e);
    if (r != null)
      return r;
  }
  return t.split(".").reduce((r, o) => r && r[o] != null ? r[o] : null, e);
}
function Zh(e, t, n, r = n) {
  let o;
  return typeof e == "function" ? o = e(n) : Array.isArray(e) ? o = e[n] || r : o = Vp(e, n) || r, t && (o = t(o, r, e)), o;
}
function Ft(e) {
  const {
    prop: t,
    cssProperty: n = e.prop,
    themeKey: r,
    transform: o
  } = e, a = (s) => {
    if (s[t] == null)
      return null;
    const u = s[t], c = s.theme, f = Vp(c, r) || {};
    return ti(s, u, (p) => {
      let g = Zh(f, o, p);
      return p === g && typeof p == "string" && (g = Zh(f, o, `${t}${p === "default" ? "" : Tn(p)}`, p)), n === !1 ? g : {
        [n]: g
      };
    });
  };
  return a.propTypes = {}, a.filterProps = [t], a;
}
function G6(e) {
  const t = {};
  return (n) => (t[n] === void 0 && (t[n] = e(n)), t[n]);
}
const Y6 = {
  m: "margin",
  p: "padding"
}, W6 = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
}, _C = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
}, X6 = G6((e) => {
  if (e.length > 2)
    if (_C[e])
      e = _C[e];
    else
      return [e];
  const [t, n] = e.split(""), r = Y6[t], o = W6[n] || "";
  return Array.isArray(o) ? o.map((a) => r + a) : [r + o];
}), h1 = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], p1 = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...h1, ...p1];
function tf(e, t, n, r) {
  const o = Vp(e, t, !0) ?? n;
  return typeof o == "number" || typeof o == "string" ? (a) => typeof a == "string" ? a : typeof o == "string" ? o.startsWith("var(") && a === 0 ? 0 : o.startsWith("var(") && a === 1 ? o : `calc(${a} * ${o})` : o * a : Array.isArray(o) ? (a) => {
    if (typeof a == "string")
      return a;
    const s = Math.abs(a), u = o[s];
    return a >= 0 ? u : typeof u == "number" ? -u : typeof u == "string" && u.startsWith("var(") ? `calc(-1 * ${u})` : `-${u}`;
  } : typeof o == "function" ? o : () => {
  };
}
function m1(e) {
  return tf(e, "spacing", 8);
}
function nf(e, t) {
  return typeof t == "string" || t == null ? t : e(t);
}
function K6(e, t) {
  return (n) => e.reduce((r, o) => (r[o] = nf(t, n), r), {});
}
function Z6(e, t, n, r) {
  if (!t.includes(n))
    return null;
  const o = X6(n), a = K6(o, r), s = e[n];
  return ti(e, s, a);
}
function sM(e, t) {
  const n = m1(e.theme);
  return Object.keys(e).map((r) => Z6(e, t, r, n)).reduce(vc, {});
}
function Nt(e) {
  return sM(e, h1);
}
Nt.propTypes = {};
Nt.filterProps = h1;
function Dt(e) {
  return sM(e, p1);
}
Dt.propTypes = {};
Dt.filterProps = p1;
function Up(...e) {
  const t = e.reduce((r, o) => (o.filterProps.forEach((a) => {
    r[a] = o;
  }), r), {}), n = (r) => Object.keys(r).reduce((o, a) => t[a] ? vc(o, t[a](r)) : o, {});
  return n.propTypes = {}, n.filterProps = e.reduce((r, o) => r.concat(o.filterProps), []), n;
}
function _r(e) {
  return typeof e != "number" ? e : `${e}px solid`;
}
function kr(e, t) {
  return Ft({
    prop: e,
    themeKey: "borders",
    transform: t
  });
}
const Q6 = kr("border", _r), J6 = kr("borderTop", _r), ez = kr("borderRight", _r), tz = kr("borderBottom", _r), nz = kr("borderLeft", _r), rz = kr("borderColor"), oz = kr("borderTopColor"), iz = kr("borderRightColor"), az = kr("borderBottomColor"), sz = kr("borderLeftColor"), lz = kr("outline", _r), uz = kr("outlineColor"), qp = (e) => {
  if (e.borderRadius !== void 0 && e.borderRadius !== null) {
    const t = tf(e.theme, "shape.borderRadius", 4), n = (r) => ({
      borderRadius: nf(t, r)
    });
    return ti(e, e.borderRadius, n);
  }
  return null;
};
qp.propTypes = {};
qp.filterProps = ["borderRadius"];
Up(Q6, J6, ez, tz, nz, rz, oz, iz, az, sz, qp, lz, uz);
const Gp = (e) => {
  if (e.gap !== void 0 && e.gap !== null) {
    const t = tf(e.theme, "spacing", 8), n = (r) => ({
      gap: nf(t, r)
    });
    return ti(e, e.gap, n);
  }
  return null;
};
Gp.propTypes = {};
Gp.filterProps = ["gap"];
const Yp = (e) => {
  if (e.columnGap !== void 0 && e.columnGap !== null) {
    const t = tf(e.theme, "spacing", 8), n = (r) => ({
      columnGap: nf(t, r)
    });
    return ti(e, e.columnGap, n);
  }
  return null;
};
Yp.propTypes = {};
Yp.filterProps = ["columnGap"];
const Wp = (e) => {
  if (e.rowGap !== void 0 && e.rowGap !== null) {
    const t = tf(e.theme, "spacing", 8), n = (r) => ({
      rowGap: nf(t, r)
    });
    return ti(e, e.rowGap, n);
  }
  return null;
};
Wp.propTypes = {};
Wp.filterProps = ["rowGap"];
const cz = Ft({
  prop: "gridColumn"
}), fz = Ft({
  prop: "gridRow"
}), dz = Ft({
  prop: "gridAutoFlow"
}), hz = Ft({
  prop: "gridAutoColumns"
}), pz = Ft({
  prop: "gridAutoRows"
}), mz = Ft({
  prop: "gridTemplateColumns"
}), gz = Ft({
  prop: "gridTemplateRows"
}), yz = Ft({
  prop: "gridTemplateAreas"
}), vz = Ft({
  prop: "gridArea"
});
Up(Gp, Yp, Wp, cz, fz, dz, hz, pz, mz, gz, yz, vz);
function sl(e, t) {
  return t === "grey" ? t : e;
}
const bz = Ft({
  prop: "color",
  themeKey: "palette",
  transform: sl
}), xz = Ft({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: sl
}), wz = Ft({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: sl
});
Up(bz, xz, wz);
function nr(e) {
  return e <= 1 && e !== 0 ? `${e * 100}%` : e;
}
const _z = Ft({
  prop: "width",
  transform: nr
}), g1 = (e) => {
  if (e.maxWidth !== void 0 && e.maxWidth !== null) {
    const t = (n) => {
      const r = e.theme?.breakpoints?.values?.[n] || Hp[n];
      return r ? e.theme?.breakpoints?.unit !== "px" ? {
        maxWidth: `${r}${e.theme.breakpoints.unit}`
      } : {
        maxWidth: r
      } : {
        maxWidth: nr(n)
      };
    };
    return ti(e, e.maxWidth, t);
  }
  return null;
};
g1.filterProps = ["maxWidth"];
const Sz = Ft({
  prop: "minWidth",
  transform: nr
}), Ez = Ft({
  prop: "height",
  transform: nr
}), Cz = Ft({
  prop: "maxHeight",
  transform: nr
}), kz = Ft({
  prop: "minHeight",
  transform: nr
});
Ft({
  prop: "size",
  cssProperty: "width",
  transform: nr
});
Ft({
  prop: "size",
  cssProperty: "height",
  transform: nr
});
const Tz = Ft({
  prop: "boxSizing"
});
Up(_z, g1, Sz, Ez, Cz, kz, Tz);
const Xp = {
  // borders
  border: {
    themeKey: "borders",
    transform: _r
  },
  borderTop: {
    themeKey: "borders",
    transform: _r
  },
  borderRight: {
    themeKey: "borders",
    transform: _r
  },
  borderBottom: {
    themeKey: "borders",
    transform: _r
  },
  borderLeft: {
    themeKey: "borders",
    transform: _r
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  outline: {
    themeKey: "borders",
    transform: _r
  },
  outlineColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: qp
  },
  // palette
  color: {
    themeKey: "palette",
    transform: sl
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: sl
  },
  backgroundColor: {
    themeKey: "palette",
    transform: sl
  },
  // spacing
  p: {
    style: Dt
  },
  pt: {
    style: Dt
  },
  pr: {
    style: Dt
  },
  pb: {
    style: Dt
  },
  pl: {
    style: Dt
  },
  px: {
    style: Dt
  },
  py: {
    style: Dt
  },
  padding: {
    style: Dt
  },
  paddingTop: {
    style: Dt
  },
  paddingRight: {
    style: Dt
  },
  paddingBottom: {
    style: Dt
  },
  paddingLeft: {
    style: Dt
  },
  paddingX: {
    style: Dt
  },
  paddingY: {
    style: Dt
  },
  paddingInline: {
    style: Dt
  },
  paddingInlineStart: {
    style: Dt
  },
  paddingInlineEnd: {
    style: Dt
  },
  paddingBlock: {
    style: Dt
  },
  paddingBlockStart: {
    style: Dt
  },
  paddingBlockEnd: {
    style: Dt
  },
  m: {
    style: Nt
  },
  mt: {
    style: Nt
  },
  mr: {
    style: Nt
  },
  mb: {
    style: Nt
  },
  ml: {
    style: Nt
  },
  mx: {
    style: Nt
  },
  my: {
    style: Nt
  },
  margin: {
    style: Nt
  },
  marginTop: {
    style: Nt
  },
  marginRight: {
    style: Nt
  },
  marginBottom: {
    style: Nt
  },
  marginLeft: {
    style: Nt
  },
  marginX: {
    style: Nt
  },
  marginY: {
    style: Nt
  },
  marginInline: {
    style: Nt
  },
  marginInlineStart: {
    style: Nt
  },
  marginInlineEnd: {
    style: Nt
  },
  marginBlock: {
    style: Nt
  },
  marginBlockStart: {
    style: Nt
  },
  marginBlockEnd: {
    style: Nt
  },
  // display
  displayPrint: {
    cssProperty: !1,
    transform: (e) => ({
      "@media print": {
        display: e
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: Gp
  },
  rowGap: {
    style: Wp
  },
  columnGap: {
    style: Yp
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: nr
  },
  maxWidth: {
    style: g1
  },
  minWidth: {
    transform: nr
  },
  height: {
    transform: nr
  },
  maxHeight: {
    transform: nr
  },
  minHeight: {
    transform: nr
  },
  boxSizing: {},
  // typography
  font: {
    themeKey: "font"
  },
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: !1,
    themeKey: "typography"
  }
};
function Az(...e) {
  const t = e.reduce((r, o) => r.concat(Object.keys(o)), []), n = new Set(t);
  return e.every((r) => n.size === Object.keys(r).length);
}
function Rz(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Mz() {
  function e(n, r, o, a) {
    const s = {
      [n]: r,
      theme: o
    }, u = a[n];
    if (!u)
      return {
        [n]: r
      };
    const {
      cssProperty: c = n,
      themeKey: f,
      transform: h,
      style: p
    } = u;
    if (r == null)
      return null;
    if (f === "typography" && r === "inherit")
      return {
        [n]: r
      };
    const g = Vp(o, f) || {};
    return p ? p(s) : ti(s, r, (w) => {
      let v = Zh(g, h, w);
      return w === v && typeof w == "string" && (v = Zh(g, h, `${n}${w === "default" ? "" : Tn(w)}`, w)), c === !1 ? v : {
        [c]: v
      };
    });
  }
  function t(n) {
    const {
      sx: r,
      theme: o = {},
      nested: a
    } = n || {};
    if (!r)
      return null;
    const s = o.unstable_sxConfig ?? Xp;
    function u(c) {
      let f = c;
      if (typeof c == "function")
        f = c(o);
      else if (typeof c != "object")
        return c;
      if (!f)
        return null;
      const h = q6(o.breakpoints), p = Object.keys(h);
      let g = h;
      return Object.keys(f).forEach((y) => {
        const w = Rz(f[y], o);
        if (w != null)
          if (typeof w == "object")
            if (s[y])
              g = vc(g, e(y, w, o, s));
            else {
              const v = ti({
                theme: o
              }, w, (S) => ({
                [y]: S
              }));
              Az(v, w) ? g[y] = t({
                sx: w,
                theme: o,
                nested: !0
              }) : g = vc(g, v);
            }
          else
            g = vc(g, e(y, w, o, s));
      }), !a && o.modularCssLayers ? {
        "@layer sx": bC(o, wC(p, g))
      } : bC(o, wC(p, g));
    }
    return Array.isArray(r) ? r.map(u) : u(r);
  }
  return t;
}
const vl = Mz();
vl.filterProps = ["sx"];
function Re() {
  return Re = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, Re.apply(null, arguments);
}
function Oz(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function Nz(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var Dz = /* @__PURE__ */ function() {
  function e(n) {
    var r = this;
    this._insertTag = function(o) {
      var a;
      r.tags.length === 0 ? r.insertionPoint ? a = r.insertionPoint.nextSibling : r.prepend ? a = r.container.firstChild : a = r.before : a = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(o, a), r.tags.push(o);
    }, this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(r) {
    r.forEach(this._insertTag);
  }, t.insert = function(r) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(Nz(this));
    var o = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var a = Oz(o);
      try {
        a.insertRule(r, a.cssRules.length);
      } catch {
      }
    } else
      o.appendChild(document.createTextNode(r));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(r) {
      var o;
      return (o = r.parentNode) == null ? void 0 : o.removeChild(r);
    }), this.tags = [], this.ctr = 0;
  }, e;
}(), mn = "-ms-", Qh = "-moz-", ot = "-webkit-", lM = "comm", y1 = "rule", v1 = "decl", jz = "@import", uM = "@keyframes", Pz = "@layer", Iz = Math.abs, Kp = String.fromCharCode, zz = Object.assign;
function Lz(e, t) {
  return un(e, 0) ^ 45 ? (((t << 2 ^ un(e, 0)) << 2 ^ un(e, 1)) << 2 ^ un(e, 2)) << 2 ^ un(e, 3) : 0;
}
function cM(e) {
  return e.trim();
}
function Fz(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function it(e, t, n) {
  return e.replace(t, n);
}
function Lv(e, t) {
  return e.indexOf(t);
}
function un(e, t) {
  return e.charCodeAt(t) | 0;
}
function Ac(e, t, n) {
  return e.slice(t, n);
}
function ro(e) {
  return e.length;
}
function b1(e) {
  return e.length;
}
function Wd(e, t) {
  return t.push(e), e;
}
function $z(e, t) {
  return e.map(t).join("");
}
var Zp = 1, bl = 1, fM = 0, Bn = 0, Yt = 0, Il = "";
function Qp(e, t, n, r, o, a, s) {
  return { value: e, root: t, parent: n, type: r, props: o, children: a, line: Zp, column: bl, length: s, return: "" };
}
function tc(e, t) {
  return zz(Qp("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function Bz() {
  return Yt;
}
function Hz() {
  return Yt = Bn > 0 ? un(Il, --Bn) : 0, bl--, Yt === 10 && (bl = 1, Zp--), Yt;
}
function ir() {
  return Yt = Bn < fM ? un(Il, Bn++) : 0, bl++, Yt === 10 && (bl = 1, Zp++), Yt;
}
function ho() {
  return un(Il, Bn);
}
function Rh() {
  return Bn;
}
function rf(e, t) {
  return Ac(Il, e, t);
}
function Rc(e) {
  switch (e) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function dM(e) {
  return Zp = bl = 1, fM = ro(Il = e), Bn = 0, [];
}
function hM(e) {
  return Il = "", e;
}
function Mh(e) {
  return cM(rf(Bn - 1, Fv(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function Vz(e) {
  for (; (Yt = ho()) && Yt < 33; )
    ir();
  return Rc(e) > 2 || Rc(Yt) > 3 ? "" : " ";
}
function Uz(e, t) {
  for (; --t && ir() && !(Yt < 48 || Yt > 102 || Yt > 57 && Yt < 65 || Yt > 70 && Yt < 97); )
    ;
  return rf(e, Rh() + (t < 6 && ho() == 32 && ir() == 32));
}
function Fv(e) {
  for (; ir(); )
    switch (Yt) {
      // ] ) " '
      case e:
        return Bn;
      // " '
      case 34:
      case 39:
        e !== 34 && e !== 39 && Fv(Yt);
        break;
      // (
      case 40:
        e === 41 && Fv(e);
        break;
      // \
      case 92:
        ir();
        break;
    }
  return Bn;
}
function qz(e, t) {
  for (; ir() && e + Yt !== 57; )
    if (e + Yt === 84 && ho() === 47)
      break;
  return "/*" + rf(t, Bn - 1) + "*" + Kp(e === 47 ? e : ir());
}
function Gz(e) {
  for (; !Rc(ho()); )
    ir();
  return rf(e, Bn);
}
function Yz(e) {
  return hM(Oh("", null, null, null, [""], e = dM(e), 0, [0], e));
}
function Oh(e, t, n, r, o, a, s, u, c) {
  for (var f = 0, h = 0, p = s, g = 0, y = 0, w = 0, v = 1, S = 1, E = 1, A = 0, k = "", T = o, R = a, N = r, j = k; S; )
    switch (w = A, A = ir()) {
      // (
      case 40:
        if (w != 108 && un(j, p - 1) == 58) {
          Lv(j += it(Mh(A), "&", "&\f"), "&\f") != -1 && (E = -1);
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        j += Mh(A);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        j += Vz(w);
        break;
      // \
      case 92:
        j += Uz(Rh() - 1, 7);
        continue;
      // /
      case 47:
        switch (ho()) {
          case 42:
          case 47:
            Wd(Wz(qz(ir(), Rh()), t, n), c);
            break;
          default:
            j += "/";
        }
        break;
      // {
      case 123 * v:
        u[f++] = ro(j) * E;
      // } ; \0
      case 125 * v:
      case 59:
      case 0:
        switch (A) {
          // \0 }
          case 0:
          case 125:
            S = 0;
          // ;
          case 59 + h:
            E == -1 && (j = it(j, /\f/g, "")), y > 0 && ro(j) - p && Wd(y > 32 ? EC(j + ";", r, n, p - 1) : EC(it(j, " ", "") + ";", r, n, p - 2), c);
            break;
          // @ ;
          case 59:
            j += ";";
          // { rule/at-rule
          default:
            if (Wd(N = SC(j, t, n, f, h, o, u, k, T = [], R = [], p), a), A === 123)
              if (h === 0)
                Oh(j, t, N, N, T, a, p, u, R);
              else
                switch (g === 99 && un(j, 3) === 110 ? 100 : g) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Oh(e, N, N, r && Wd(SC(e, N, N, 0, 0, o, u, k, o, T = [], p), R), o, R, p, u, r ? T : R);
                    break;
                  default:
                    Oh(j, N, N, N, [""], R, 0, u, R);
                }
        }
        f = h = y = 0, v = E = 1, k = j = "", p = s;
        break;
      // :
      case 58:
        p = 1 + ro(j), y = w;
      default:
        if (v < 1) {
          if (A == 123)
            --v;
          else if (A == 125 && v++ == 0 && Hz() == 125)
            continue;
        }
        switch (j += Kp(A), A * v) {
          // &
          case 38:
            E = h > 0 ? 1 : (j += "\f", -1);
            break;
          // ,
          case 44:
            u[f++] = (ro(j) - 1) * E, E = 1;
            break;
          // @
          case 64:
            ho() === 45 && (j += Mh(ir())), g = ho(), h = p = ro(k = j += Gz(Rh())), A++;
            break;
          // -
          case 45:
            w === 45 && ro(j) == 2 && (v = 0);
        }
    }
  return a;
}
function SC(e, t, n, r, o, a, s, u, c, f, h) {
  for (var p = o - 1, g = o === 0 ? a : [""], y = b1(g), w = 0, v = 0, S = 0; w < r; ++w)
    for (var E = 0, A = Ac(e, p + 1, p = Iz(v = s[w])), k = e; E < y; ++E)
      (k = cM(v > 0 ? g[E] + " " + A : it(A, /&\f/g, g[E]))) && (c[S++] = k);
  return Qp(e, t, n, o === 0 ? y1 : u, c, f, h);
}
function Wz(e, t, n) {
  return Qp(e, t, n, lM, Kp(Bz()), Ac(e, 2, -2), 0);
}
function EC(e, t, n, r) {
  return Qp(e, t, n, v1, Ac(e, 0, r), Ac(e, r + 1, -1), r);
}
function ll(e, t) {
  for (var n = "", r = b1(e), o = 0; o < r; o++)
    n += t(e[o], o, e, t) || "";
  return n;
}
function Xz(e, t, n, r) {
  switch (e.type) {
    case Pz:
      if (e.children.length) break;
    case jz:
    case v1:
      return e.return = e.return || e.value;
    case lM:
      return "";
    case uM:
      return e.return = e.value + "{" + ll(e.children, r) + "}";
    case y1:
      e.value = e.props.join(",");
  }
  return ro(n = ll(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
}
function Kz(e) {
  var t = b1(e);
  return function(n, r, o, a) {
    for (var s = "", u = 0; u < t; u++)
      s += e[u](n, r, o, a) || "";
    return s;
  };
}
function Zz(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function pM(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var Qz = function(t, n, r) {
  for (var o = 0, a = 0; o = a, a = ho(), o === 38 && a === 12 && (n[r] = 1), !Rc(a); )
    ir();
  return rf(t, Bn);
}, Jz = function(t, n) {
  var r = -1, o = 44;
  do
    switch (Rc(o)) {
      case 0:
        o === 38 && ho() === 12 && (n[r] = 1), t[r] += Qz(Bn - 1, n, r);
        break;
      case 2:
        t[r] += Mh(o);
        break;
      case 4:
        if (o === 44) {
          t[++r] = ho() === 58 ? "&\f" : "", n[r] = t[r].length;
          break;
        }
      // fallthrough
      default:
        t[r] += Kp(o);
    }
  while (o = ir());
  return t;
}, eL = function(t, n) {
  return hM(Jz(dM(t), n));
}, CC = /* @__PURE__ */ new WeakMap(), tL = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var n = t.value, r = t.parent, o = t.column === r.column && t.line === r.line; r.type !== "rule"; )
      if (r = r.parent, !r) return;
    if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !CC.get(r)) && !o) {
      CC.set(t, !0);
      for (var a = [], s = eL(n, a), u = r.props, c = 0, f = 0; c < s.length; c++)
        for (var h = 0; h < u.length; h++, f++)
          t.props[f] = a[c] ? s[c].replace(/&\f/g, u[h]) : u[h] + " " + s[c];
    }
  }
}, nL = function(t) {
  if (t.type === "decl") {
    var n = t.value;
    // charcode for l
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
};
function mM(e, t) {
  switch (Lz(e, t)) {
    // color-adjust
    case 5103:
      return ot + "print-" + e + e;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return ot + e + e;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return ot + e + Qh + e + mn + e + e;
    // flex, flex-direction
    case 6828:
    case 4268:
      return ot + e + mn + e + e;
    // order
    case 6165:
      return ot + e + mn + "flex-" + e + e;
    // align-items
    case 5187:
      return ot + e + it(e, /(\w+).+(:[^]+)/, ot + "box-$1$2" + mn + "flex-$1$2") + e;
    // align-self
    case 5443:
      return ot + e + mn + "flex-item-" + it(e, /flex-|-self/, "") + e;
    // align-content
    case 4675:
      return ot + e + mn + "flex-line-pack" + it(e, /align-content|flex-|-self/, "") + e;
    // flex-shrink
    case 5548:
      return ot + e + mn + it(e, "shrink", "negative") + e;
    // flex-basis
    case 5292:
      return ot + e + mn + it(e, "basis", "preferred-size") + e;
    // flex-grow
    case 6060:
      return ot + "box-" + it(e, "-grow", "") + ot + e + mn + it(e, "grow", "positive") + e;
    // transition
    case 4554:
      return ot + it(e, /([^-])(transform)/g, "$1" + ot + "$2") + e;
    // cursor
    case 6187:
      return it(it(it(e, /(zoom-|grab)/, ot + "$1"), /(image-set)/, ot + "$1"), e, "") + e;
    // background, background-image
    case 5495:
    case 3959:
      return it(e, /(image-set\([^]*)/, ot + "$1$`$1");
    // justify-content
    case 4968:
      return it(it(e, /(.+:)(flex-)?(.*)/, ot + "box-pack:$3" + mn + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + ot + e + e;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return it(e, /(.+)-inline(.+)/, ot + "$1$2") + e;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (ro(e) - 1 - t > 6) switch (un(e, t + 1)) {
        // (m)ax-content, (m)in-content
        case 109:
          if (un(e, t + 4) !== 45) break;
        // (f)ill-available, (f)it-content
        case 102:
          return it(e, /(.+:)(.+)-([^]+)/, "$1" + ot + "$2-$3$1" + Qh + (un(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        // (s)tretch
        case 115:
          return ~Lv(e, "stretch") ? mM(it(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    // position: sticky
    case 4949:
      if (un(e, t + 1) !== 115) break;
    // display: (flex|inline-flex)
    case 6444:
      switch (un(e, ro(e) - 3 - (~Lv(e, "!important") && 10))) {
        // stic(k)y
        case 107:
          return it(e, ":", ":" + ot) + e;
        // (inline-)?fl(e)x
        case 101:
          return it(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + ot + (un(e, 14) === 45 ? "inline-" : "") + "box$3$1" + ot + "$2$3$1" + mn + "$2box$3") + e;
      }
      break;
    // writing-mode
    case 5936:
      switch (un(e, t + 11)) {
        // vertical-l(r)
        case 114:
          return ot + e + mn + it(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        // vertical-r(l)
        case 108:
          return ot + e + mn + it(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        // horizontal(-)tb
        case 45:
          return ot + e + mn + it(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return ot + e + mn + e + e;
  }
  return e;
}
var rL = function(t, n, r, o) {
  if (t.length > -1 && !t.return) switch (t.type) {
    case v1:
      t.return = mM(t.value, t.length);
      break;
    case uM:
      return ll([tc(t, {
        value: it(t.value, "@", "@" + ot)
      })], o);
    case y1:
      if (t.length) return $z(t.props, function(a) {
        switch (Fz(a, /(::plac\w+|:read-\w+)/)) {
          // :read-(only|write)
          case ":read-only":
          case ":read-write":
            return ll([tc(t, {
              props: [it(a, /:(read-\w+)/, ":" + Qh + "$1")]
            })], o);
          // :placeholder
          case "::placeholder":
            return ll([tc(t, {
              props: [it(a, /:(plac\w+)/, ":" + ot + "input-$1")]
            }), tc(t, {
              props: [it(a, /:(plac\w+)/, ":" + Qh + "$1")]
            }), tc(t, {
              props: [it(a, /:(plac\w+)/, mn + "input-$1")]
            })], o);
        }
        return "";
      });
  }
}, oL = [rL], iL = function(t) {
  var n = t.key;
  if (n === "css") {
    var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(r, function(v) {
      var S = v.getAttribute("data-emotion");
      S.indexOf(" ") !== -1 && (document.head.appendChild(v), v.setAttribute("data-s", ""));
    });
  }
  var o = t.stylisPlugins || oL, a = {}, s, u = [];
  s = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(v) {
      for (var S = v.getAttribute("data-emotion").split(" "), E = 1; E < S.length; E++)
        a[S[E]] = !0;
      u.push(v);
    }
  );
  var c, f = [tL, nL];
  {
    var h, p = [Xz, Zz(function(v) {
      h.insert(v);
    })], g = Kz(f.concat(o, p)), y = function(S) {
      return ll(Yz(S), g);
    };
    c = function(S, E, A, k) {
      h = A, y(S ? S + "{" + E.styles + "}" : E.styles), k && (w.inserted[E.name] = !0);
    };
  }
  var w = {
    key: n,
    sheet: new Dz({
      key: n,
      container: s,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: a,
    registered: {},
    insert: c
  };
  return w.sheet.hydrate(u), w;
}, Cy = { exports: {} }, at = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var kC;
function aL() {
  if (kC) return at;
  kC = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, a = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, u = e ? Symbol.for("react.context") : 60110, c = e ? Symbol.for("react.async_mode") : 60111, f = e ? Symbol.for("react.concurrent_mode") : 60111, h = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, g = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, w = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, S = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, A = e ? Symbol.for("react.scope") : 60119;
  function k(R) {
    if (typeof R == "object" && R !== null) {
      var N = R.$$typeof;
      switch (N) {
        case t:
          switch (R = R.type, R) {
            case c:
            case f:
            case r:
            case a:
            case o:
            case p:
              return R;
            default:
              switch (R = R && R.$$typeof, R) {
                case u:
                case h:
                case w:
                case y:
                case s:
                  return R;
                default:
                  return N;
              }
          }
        case n:
          return N;
      }
    }
  }
  function T(R) {
    return k(R) === f;
  }
  return at.AsyncMode = c, at.ConcurrentMode = f, at.ContextConsumer = u, at.ContextProvider = s, at.Element = t, at.ForwardRef = h, at.Fragment = r, at.Lazy = w, at.Memo = y, at.Portal = n, at.Profiler = a, at.StrictMode = o, at.Suspense = p, at.isAsyncMode = function(R) {
    return T(R) || k(R) === c;
  }, at.isConcurrentMode = T, at.isContextConsumer = function(R) {
    return k(R) === u;
  }, at.isContextProvider = function(R) {
    return k(R) === s;
  }, at.isElement = function(R) {
    return typeof R == "object" && R !== null && R.$$typeof === t;
  }, at.isForwardRef = function(R) {
    return k(R) === h;
  }, at.isFragment = function(R) {
    return k(R) === r;
  }, at.isLazy = function(R) {
    return k(R) === w;
  }, at.isMemo = function(R) {
    return k(R) === y;
  }, at.isPortal = function(R) {
    return k(R) === n;
  }, at.isProfiler = function(R) {
    return k(R) === a;
  }, at.isStrictMode = function(R) {
    return k(R) === o;
  }, at.isSuspense = function(R) {
    return k(R) === p;
  }, at.isValidElementType = function(R) {
    return typeof R == "string" || typeof R == "function" || R === r || R === f || R === a || R === o || R === p || R === g || typeof R == "object" && R !== null && (R.$$typeof === w || R.$$typeof === y || R.$$typeof === s || R.$$typeof === u || R.$$typeof === h || R.$$typeof === S || R.$$typeof === E || R.$$typeof === A || R.$$typeof === v);
  }, at.typeOf = k, at;
}
var TC;
function sL() {
  return TC || (TC = 1, Cy.exports = aL()), Cy.exports;
}
var ky, AC;
function lL() {
  if (AC) return ky;
  AC = 1;
  var e = sL(), t = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0
  }, n = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0
  }, r = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
  }, o = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
  }, a = {};
  a[e.ForwardRef] = r, a[e.Memo] = o;
  function s(w) {
    return e.isMemo(w) ? o : a[w.$$typeof] || t;
  }
  var u = Object.defineProperty, c = Object.getOwnPropertyNames, f = Object.getOwnPropertySymbols, h = Object.getOwnPropertyDescriptor, p = Object.getPrototypeOf, g = Object.prototype;
  function y(w, v, S) {
    if (typeof v != "string") {
      if (g) {
        var E = p(v);
        E && E !== g && y(w, E, S);
      }
      var A = c(v);
      f && (A = A.concat(f(v)));
      for (var k = s(w), T = s(v), R = 0; R < A.length; ++R) {
        var N = A[R];
        if (!n[N] && !(S && S[N]) && !(T && T[N]) && !(k && k[N])) {
          var j = h(v, N);
          try {
            u(w, N, j);
          } catch {
          }
        }
      }
    }
    return w;
  }
  return ky = y, ky;
}
lL();
var uL = !0;
function gM(e, t, n) {
  var r = "";
  return n.split(" ").forEach(function(o) {
    e[o] !== void 0 ? t.push(e[o] + ";") : o && (r += o + " ");
  }), r;
}
var x1 = function(t, n, r) {
  var o = t.key + "-" + n.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (r === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  uL === !1) && t.registered[o] === void 0 && (t.registered[o] = n.styles);
}, yM = function(t, n, r) {
  x1(t, n, r);
  var o = t.key + "-" + n.name;
  if (t.inserted[n.name] === void 0) {
    var a = n;
    do
      t.insert(n === a ? "." + o : "", a, t.sheet, !0), a = a.next;
    while (a !== void 0);
  }
};
function cL(e) {
  for (var t = 0, n, r = 0, o = e.length; o >= 4; ++r, o -= 4)
    n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (o) {
    case 3:
      t ^= (e.charCodeAt(r + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(r + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var fL = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, dL = /[A-Z]|^ms/g, hL = /_EMO_([^_]+?)_([^]*?)_EMO_/g, vM = function(t) {
  return t.charCodeAt(1) === 45;
}, RC = function(t) {
  return t != null && typeof t != "boolean";
}, Ty = /* @__PURE__ */ pM(function(e) {
  return vM(e) ? e : e.replace(dL, "-$&").toLowerCase();
}), MC = function(t, n) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(hL, function(r, o, a) {
          return oo = {
            name: o,
            styles: a,
            next: oo
          }, o;
        });
  }
  return fL[t] !== 1 && !vM(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
};
function Mc(e, t, n) {
  if (n == null)
    return "";
  var r = n;
  if (r.__emotion_styles !== void 0)
    return r;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var o = n;
      if (o.anim === 1)
        return oo = {
          name: o.name,
          styles: o.styles,
          next: oo
        }, o.name;
      var a = n;
      if (a.styles !== void 0) {
        var s = a.next;
        if (s !== void 0)
          for (; s !== void 0; )
            oo = {
              name: s.name,
              styles: s.styles,
              next: oo
            }, s = s.next;
        var u = a.styles + ";";
        return u;
      }
      return pL(e, t, n);
    }
    case "function": {
      if (e !== void 0) {
        var c = oo, f = n(e);
        return oo = c, Mc(e, t, f);
      }
      break;
    }
  }
  var h = n;
  if (t == null)
    return h;
  var p = t[h];
  return p !== void 0 ? p : h;
}
function pL(e, t, n) {
  var r = "";
  if (Array.isArray(n))
    for (var o = 0; o < n.length; o++)
      r += Mc(e, t, n[o]) + ";";
  else
    for (var a in n) {
      var s = n[a];
      if (typeof s != "object") {
        var u = s;
        t != null && t[u] !== void 0 ? r += a + "{" + t[u] + "}" : RC(u) && (r += Ty(a) + ":" + MC(a, u) + ";");
      } else if (Array.isArray(s) && typeof s[0] == "string" && (t == null || t[s[0]] === void 0))
        for (var c = 0; c < s.length; c++)
          RC(s[c]) && (r += Ty(a) + ":" + MC(a, s[c]) + ";");
      else {
        var f = Mc(e, t, s);
        switch (a) {
          case "animation":
          case "animationName": {
            r += Ty(a) + ":" + f + ";";
            break;
          }
          default:
            r += a + "{" + f + "}";
        }
      }
    }
  return r;
}
var OC = /label:\s*([^\s;{]+)\s*(;|$)/g, oo;
function Jp(e, t, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var r = !0, o = "";
  oo = void 0;
  var a = e[0];
  if (a == null || a.raw === void 0)
    r = !1, o += Mc(n, t, a);
  else {
    var s = a;
    o += s[0];
  }
  for (var u = 1; u < e.length; u++)
    if (o += Mc(n, t, e[u]), r) {
      var c = a;
      o += c[u];
    }
  OC.lastIndex = 0;
  for (var f = "", h; (h = OC.exec(o)) !== null; )
    f += "-" + h[1];
  var p = cL(o) + f;
  return {
    name: p,
    styles: o,
    next: oo
  };
}
var mL = function(t) {
  return t();
}, gL = yl.useInsertionEffect ? yl.useInsertionEffect : !1, bM = gL || mL, xM = /* @__PURE__ */ _.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ iL({
    key: "css"
  }) : null
);
xM.Provider;
var wM = function(t) {
  return /* @__PURE__ */ _.forwardRef(function(n, r) {
    var o = _.useContext(xM);
    return t(n, o, r);
  });
}, _M = /* @__PURE__ */ _.createContext({}), w1 = {}.hasOwnProperty, $v = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", yL = function(t, n) {
  var r = {};
  for (var o in n)
    w1.call(n, o) && (r[o] = n[o]);
  return r[$v] = t, r;
}, vL = function(t) {
  var n = t.cache, r = t.serialized, o = t.isStringTag;
  return x1(n, r, o), bM(function() {
    return yM(n, r, o);
  }), null;
}, bL = /* @__PURE__ */ wM(function(e, t, n) {
  var r = e.css;
  typeof r == "string" && t.registered[r] !== void 0 && (r = t.registered[r]);
  var o = e[$v], a = [r], s = "";
  typeof e.className == "string" ? s = gM(t.registered, a, e.className) : e.className != null && (s = e.className + " ");
  var u = Jp(a, void 0, _.useContext(_M));
  s += t.key + "-" + u.name;
  var c = {};
  for (var f in e)
    w1.call(e, f) && f !== "css" && f !== $v && (c[f] = e[f]);
  return c.className = s, n && (c.ref = n), /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(vL, {
    cache: t,
    serialized: u,
    isStringTag: typeof o == "string"
  }), /* @__PURE__ */ _.createElement(o, c));
}), xL = bL, Te = function(t, n) {
  var r = arguments;
  if (n == null || !w1.call(n, "css"))
    return _.createElement.apply(void 0, r);
  var o = r.length, a = new Array(o);
  a[0] = xL, a[1] = yL(t, n);
  for (var s = 2; s < o; s++)
    a[s] = r[s];
  return _.createElement.apply(null, a);
};
(function(e) {
  var t;
  t || (t = e.JSX || (e.JSX = {}));
})(Te || (Te = {}));
function _1() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return Jp(t);
}
function em() {
  var e = _1.apply(void 0, arguments), t = "animation-" + e.name;
  return {
    name: t,
    styles: "@keyframes " + t + "{" + e.styles + "}",
    anim: 1,
    toString: function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
var wL = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, _L = /* @__PURE__ */ pM(
  function(e) {
    return wL.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
  }
  /* Z+1 */
), SL = _L, EL = function(t) {
  return t !== "theme";
}, NC = function(t) {
  return typeof t == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  t.charCodeAt(0) > 96 ? SL : EL;
}, DC = function(t, n, r) {
  var o;
  if (n) {
    var a = n.shouldForwardProp;
    o = t.__emotion_forwardProp && a ? function(s) {
      return t.__emotion_forwardProp(s) && a(s);
    } : a;
  }
  return typeof o != "function" && r && (o = t.__emotion_forwardProp), o;
}, CL = function(t) {
  var n = t.cache, r = t.serialized, o = t.isStringTag;
  return x1(n, r, o), bM(function() {
    return yM(n, r, o);
  }), null;
}, kL = function e(t, n) {
  var r = t.__emotion_real === t, o = r && t.__emotion_base || t, a, s;
  n !== void 0 && (a = n.label, s = n.target);
  var u = DC(t, n, r), c = u || NC(o), f = !c("as");
  return function() {
    var h = arguments, p = r && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
    if (a !== void 0 && p.push("label:" + a + ";"), h[0] == null || h[0].raw === void 0)
      p.push.apply(p, h);
    else {
      var g = h[0];
      p.push(g[0]);
      for (var y = h.length, w = 1; w < y; w++)
        p.push(h[w], g[w]);
    }
    var v = wM(function(S, E, A) {
      var k = f && S.as || o, T = "", R = [], N = S;
      if (S.theme == null) {
        N = {};
        for (var j in S)
          N[j] = S[j];
        N.theme = _.useContext(_M);
      }
      typeof S.className == "string" ? T = gM(E.registered, R, S.className) : S.className != null && (T = S.className + " ");
      var z = Jp(p.concat(R), E.registered, N);
      T += E.key + "-" + z.name, s !== void 0 && (T += " " + s);
      var B = f && u === void 0 ? NC(k) : c, M = {};
      for (var F in S)
        f && F === "as" || B(F) && (M[F] = S[F]);
      return M.className = T, A && (M.ref = A), /* @__PURE__ */ _.createElement(_.Fragment, null, /* @__PURE__ */ _.createElement(CL, {
        cache: E,
        serialized: z,
        isStringTag: typeof k == "string"
      }), /* @__PURE__ */ _.createElement(k, M));
    });
    return v.displayName = a !== void 0 ? a : "Styled(" + (typeof o == "string" ? o : o.displayName || o.name || "Component") + ")", v.defaultProps = t.defaultProps, v.__emotion_real = v, v.__emotion_base = o, v.__emotion_styles = p, v.__emotion_forwardProp = u, Object.defineProperty(v, "toString", {
      value: function() {
        return "." + s;
      }
    }), v.withComponent = function(S, E) {
      var A = e(S, Re({}, n, E, {
        shouldForwardProp: DC(v, E, !0)
      }));
      return A.apply(void 0, p);
    }, v;
  };
}, TL = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
], Bv = kL.bind(null);
TL.forEach(function(e) {
  Bv[e] = Bv(e);
});
function AL(e, t) {
  return Bv(e, t);
}
function RL(e, t) {
  Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles));
}
const jC = [];
function La(e) {
  return jC[0] = e, Jp(jC);
}
const ML = (e) => {
  const t = Object.keys(e).map((n) => ({
    key: n,
    val: e[n]
  })) || [];
  return t.sort((n, r) => n.val - r.val), t.reduce((n, r) => ({
    ...n,
    [r.key]: r.val
  }), {});
};
function OL(e) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: t = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit: n = "px",
    step: r = 5,
    ...o
  } = e, a = ML(t), s = Object.keys(a);
  function u(g) {
    return `@media (min-width:${typeof t[g] == "number" ? t[g] : g}${n})`;
  }
  function c(g) {
    return `@media (max-width:${(typeof t[g] == "number" ? t[g] : g) - r / 100}${n})`;
  }
  function f(g, y) {
    const w = s.indexOf(y);
    return `@media (min-width:${typeof t[g] == "number" ? t[g] : g}${n}) and (max-width:${(w !== -1 && typeof t[s[w]] == "number" ? t[s[w]] : y) - r / 100}${n})`;
  }
  function h(g) {
    return s.indexOf(g) + 1 < s.length ? f(g, s[s.indexOf(g) + 1]) : u(g);
  }
  function p(g) {
    const y = s.indexOf(g);
    return y === 0 ? u(s[1]) : y === s.length - 1 ? c(s[y]) : f(g, s[s.indexOf(g) + 1]).replace("@media", "@media not all and");
  }
  return {
    keys: s,
    values: a,
    up: u,
    down: c,
    between: f,
    only: h,
    not: p,
    unit: n,
    ...o
  };
}
const NL = {
  borderRadius: 4
};
function SM(e = 8, t = m1({
  spacing: e
})) {
  if (e.mui)
    return e;
  const n = (...r) => (r.length === 0 ? [1] : r).map((a) => {
    const s = t(a);
    return typeof s == "number" ? `${s}px` : s;
  }).join(" ");
  return n.mui = !0, n;
}
function DL(e, t) {
  const n = this;
  if (n.vars) {
    if (!n.colorSchemes?.[e] || typeof n.getColorSchemeSelector != "function")
      return {};
    let r = n.getColorSchemeSelector(e);
    return r === "&" ? t : ((r.includes("data-") || r.includes(".")) && (r = `*:where(${r.replace(/\s*&$/, "")}) &`), {
      [r]: t
    });
  }
  return n.palette.mode === e ? t : {};
}
function EM(e = {}, ...t) {
  const {
    breakpoints: n = {},
    palette: r = {},
    spacing: o,
    shape: a = {},
    ...s
  } = e, u = OL(n), c = SM(o);
  let f = or({
    breakpoints: u,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: {
      mode: "light",
      ...r
    },
    spacing: c,
    shape: {
      ...NL,
      ...a
    }
  }, s);
  return f = V6(f), f.applyStyles = DL, f = t.reduce((h, p) => or(h, p), f), f.unstable_sxConfig = {
    ...Xp,
    ...s?.unstable_sxConfig
  }, f.unstable_sx = function(p) {
    return vl({
      sx: p,
      theme: this
    });
  }, f;
}
const PC = (e) => e, jL = () => {
  let e = PC;
  return {
    configure(t) {
      e = t;
    },
    generate(t) {
      return e(t);
    },
    reset() {
      e = PC;
    }
  };
}, PL = jL(), IL = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function bo(e, t, n = "Mui") {
  const r = IL[t];
  return r ? `${n}-${r}` : `${PL.generate(e)}-${t}`;
}
function xo(e, t, n = "Mui") {
  const r = {};
  return t.forEach((o) => {
    r[o] = bo(e, o, n);
  }), r;
}
function CM(e) {
  const {
    variants: t,
    ...n
  } = e, r = {
    variants: t,
    style: La(n),
    isProcessed: !0
  };
  return r.style === n || t && t.forEach((o) => {
    typeof o.style != "function" && (o.style = La(o.style));
  }), r;
}
const zL = EM();
function Ay(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
function Da(e, t) {
  return t && e && typeof e == "object" && e.styles && !e.styles.startsWith("@layer") && (e.styles = `@layer ${t}{${String(e.styles)}}`), e;
}
function LL(e) {
  return e ? (t, n) => n[e] : null;
}
function FL(e, t, n) {
  e.theme = HL(e.theme) ? n : e.theme[t] || e.theme;
}
function Nh(e, t, n) {
  const r = typeof t == "function" ? t(e) : t;
  if (Array.isArray(r))
    return r.flatMap((o) => Nh(e, o, n));
  if (Array.isArray(r?.variants)) {
    let o;
    if (r.isProcessed)
      o = n ? Da(r.style, n) : r.style;
    else {
      const {
        variants: a,
        ...s
      } = r;
      o = n ? Da(La(s), n) : s;
    }
    return kM(e, r.variants, [o], n);
  }
  return r?.isProcessed ? n ? Da(La(r.style), n) : r.style : n ? Da(La(r), n) : r;
}
function kM(e, t, n = [], r = void 0) {
  let o;
  e: for (let a = 0; a < t.length; a += 1) {
    const s = t[a];
    if (typeof s.props == "function") {
      if (o ?? (o = {
        ...e,
        ...e.ownerState,
        ownerState: e.ownerState
      }), !s.props(o))
        continue;
    } else
      for (const u in s.props)
        if (e[u] !== s.props[u] && e.ownerState?.[u] !== s.props[u])
          continue e;
    typeof s.style == "function" ? (o ?? (o = {
      ...e,
      ...e.ownerState,
      ownerState: e.ownerState
    }), n.push(r ? Da(La(s.style(o)), r) : s.style(o))) : n.push(r ? Da(La(s.style), r) : s.style);
  }
  return n;
}
function $L(e = {}) {
  const {
    themeId: t,
    defaultTheme: n = zL,
    rootShouldForwardProp: r = Ay,
    slotShouldForwardProp: o = Ay
  } = e;
  function a(u) {
    FL(u, t, n);
  }
  return (u, c = {}) => {
    RL(u, (N) => N.filter((j) => j !== vl));
    const {
      name: f,
      slot: h,
      skipVariantsResolver: p,
      skipSx: g,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: y = LL(UL(h)),
      ...w
    } = c, v = f && f.startsWith("Mui") || h ? "components" : "custom", S = p !== void 0 ? p : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      h && h !== "Root" && h !== "root" || !1
    ), E = g || !1;
    let A = Ay;
    h === "Root" || h === "root" ? A = r : h ? A = o : VL(u) && (A = void 0);
    const k = AL(u, {
      shouldForwardProp: A,
      label: BL(),
      ...w
    }), T = (N) => {
      if (N.__emotion_real === N)
        return N;
      if (typeof N == "function")
        return function(z) {
          return Nh(z, N, z.theme.modularCssLayers ? v : void 0);
        };
      if (Xo(N)) {
        const j = CM(N);
        return function(B) {
          return j.variants ? Nh(B, j, B.theme.modularCssLayers ? v : void 0) : B.theme.modularCssLayers ? Da(j.style, v) : j.style;
        };
      }
      return N;
    }, R = (...N) => {
      const j = [], z = N.map(T), B = [];
      if (j.push(a), f && y && B.push(function(Y) {
        const V = Y.theme.components?.[f]?.styleOverrides;
        if (!V)
          return null;
        const I = {};
        for (const U in V)
          I[U] = Nh(Y, V[U], Y.theme.modularCssLayers ? "theme" : void 0);
        return y(Y, I);
      }), f && !S && B.push(function(Y) {
        const V = Y.theme?.components?.[f]?.variants;
        return V ? kM(Y, V, [], Y.theme.modularCssLayers ? "theme" : void 0) : null;
      }), E || B.push(vl), Array.isArray(z[0])) {
        const q = z.shift(), Y = new Array(j.length).fill(""), P = new Array(B.length).fill("");
        let V;
        V = [...Y, ...q, ...P], V.raw = [...Y, ...q.raw, ...P], j.unshift(V);
      }
      const M = [...j, ...z, ...B], F = k(...M);
      return u.muiName && (F.muiName = u.muiName), F;
    };
    return k.withConfig && (R.withConfig = k.withConfig), R;
  };
}
function BL(e, t) {
  return void 0;
}
function HL(e) {
  for (const t in e)
    return !1;
  return !0;
}
function VL(e) {
  return typeof e == "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  e.charCodeAt(0) > 96;
}
function UL(e) {
  return e && e.charAt(0).toLowerCase() + e.slice(1);
}
function Hv(e, t, n = !1) {
  const r = {
    ...t
  };
  for (const o in e)
    if (Object.prototype.hasOwnProperty.call(e, o)) {
      const a = o;
      if (a === "components" || a === "slots")
        r[a] = {
          ...e[a],
          ...r[a]
        };
      else if (a === "componentsProps" || a === "slotProps") {
        const s = e[a], u = t[a];
        if (!u)
          r[a] = s || {};
        else if (!s)
          r[a] = u;
        else {
          r[a] = {
            ...u
          };
          for (const c in s)
            if (Object.prototype.hasOwnProperty.call(s, c)) {
              const f = c;
              r[a][f] = Hv(s[f], u[f], n);
            }
        }
      } else a === "className" && n && t.className ? r.className = zt(e?.className, t?.className) : a === "style" && n && t.style ? r.style = {
        ...e?.style,
        ...t?.style
      } : r[a] === void 0 && (r[a] = e[a]);
    }
  return r;
}
const qL = typeof window < "u" ? _.useLayoutEffect : _.useEffect;
function GL(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
  return Math.max(t, Math.min(e, n));
}
function S1(e, t = 0, n = 1) {
  return GL(e, t, n);
}
function YL(e) {
  e = e.slice(1);
  const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, "g");
  let n = e.match(t);
  return n && n[0].length === 1 && (n = n.map((r) => r + r)), n ? `rgb${n.length === 4 ? "a" : ""}(${n.map((r, o) => o < 3 ? parseInt(r, 16) : Math.round(parseInt(r, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
}
function ea(e) {
  if (e.type)
    return e;
  if (e.charAt(0) === "#")
    return ea(YL(e));
  const t = e.indexOf("("), n = e.substring(0, t);
  if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(n))
    throw new Error(Va(9, e));
  let r = e.substring(t + 1, e.length - 1), o;
  if (n === "color") {
    if (r = r.split(" "), o = r.shift(), r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)), !["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(o))
      throw new Error(Va(10, o));
  } else
    r = r.split(",");
  return r = r.map((a) => parseFloat(a)), {
    type: n,
    values: r,
    colorSpace: o
  };
}
const WL = (e) => {
  const t = ea(e);
  return t.values.slice(0, 3).map((n, r) => t.type.includes("hsl") && r !== 0 ? `${n}%` : n).join(" ");
}, fc = (e, t) => {
  try {
    return WL(e);
  } catch {
    return e;
  }
};
function tm(e) {
  const {
    type: t,
    colorSpace: n
  } = e;
  let {
    values: r
  } = e;
  return t.includes("rgb") ? r = r.map((o, a) => a < 3 ? parseInt(o, 10) : o) : t.includes("hsl") && (r[1] = `${r[1]}%`, r[2] = `${r[2]}%`), t.includes("color") ? r = `${n} ${r.join(" ")}` : r = `${r.join(", ")}`, `${t}(${r})`;
}
function TM(e) {
  e = ea(e);
  const {
    values: t
  } = e, n = t[0], r = t[1] / 100, o = t[2] / 100, a = r * Math.min(o, 1 - o), s = (f, h = (f + n / 30) % 12) => o - a * Math.max(Math.min(h - 3, 9 - h, 1), -1);
  let u = "rgb";
  const c = [Math.round(s(0) * 255), Math.round(s(8) * 255), Math.round(s(4) * 255)];
  return e.type === "hsla" && (u += "a", c.push(t[3])), tm({
    type: u,
    values: c
  });
}
function Vv(e) {
  e = ea(e);
  let t = e.type === "hsl" || e.type === "hsla" ? ea(TM(e)).values : e.values;
  return t = t.map((n) => (e.type !== "color" && (n /= 255), n <= 0.03928 ? n / 12.92 : ((n + 0.055) / 1.055) ** 2.4)), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3));
}
function XL(e, t) {
  const n = Vv(e), r = Vv(t);
  return (Math.max(n, r) + 0.05) / (Math.min(n, r) + 0.05);
}
function Oc(e, t) {
  return e = ea(e), t = S1(t), (e.type === "rgb" || e.type === "hsl") && (e.type += "a"), e.type === "color" ? e.values[3] = `/${t}` : e.values[3] = t, tm(e);
}
function Xd(e, t, n) {
  try {
    return Oc(e, t);
  } catch {
    return e;
  }
}
function nm(e, t) {
  if (e = ea(e), t = S1(t), e.type.includes("hsl"))
    e.values[2] *= 1 - t;
  else if (e.type.includes("rgb") || e.type.includes("color"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] *= 1 - t;
  return tm(e);
}
function gt(e, t, n) {
  try {
    return nm(e, t);
  } catch {
    return e;
  }
}
function rm(e, t) {
  if (e = ea(e), t = S1(t), e.type.includes("hsl"))
    e.values[2] += (100 - e.values[2]) * t;
  else if (e.type.includes("rgb"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (255 - e.values[n]) * t;
  else if (e.type.includes("color"))
    for (let n = 0; n < 3; n += 1)
      e.values[n] += (1 - e.values[n]) * t;
  return tm(e);
}
function yt(e, t, n) {
  try {
    return rm(e, t);
  } catch {
    return e;
  }
}
function KL(e, t = 0.15) {
  return Vv(e) > 0.5 ? nm(e, t) : rm(e, t);
}
function Kd(e, t, n) {
  try {
    return KL(e, t);
  } catch {
    return e;
  }
}
const ZL = /* @__PURE__ */ _.createContext(void 0);
function QL(e) {
  const {
    theme: t,
    name: n,
    props: r
  } = e;
  if (!t || !t.components || !t.components[n])
    return r;
  const o = t.components[n];
  return o.defaultProps ? Hv(o.defaultProps, r, t.components.mergeClassNameAndStyle) : !o.styleOverrides && !o.variants ? Hv(o, r, t.components.mergeClassNameAndStyle) : r;
}
function JL({
  props: e,
  name: t
}) {
  const n = _.useContext(ZL);
  return QL({
    props: e,
    name: t,
    theme: {
      components: n
    }
  });
}
const IC = {
  theme: void 0
};
function eF(e) {
  let t, n;
  return function(o) {
    let a = t;
    return (a === void 0 || o.theme !== n) && (IC.theme = o.theme, a = CM(e(IC)), t = a, n = o.theme), a;
  };
}
function tF(e = "") {
  function t(...r) {
    if (!r.length)
      return "";
    const o = r[0];
    return typeof o == "string" && !o.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/) ? `, var(--${e ? `${e}-` : ""}${o}${t(...r.slice(1))})` : `, ${o}`;
  }
  return (r, ...o) => `var(--${e ? `${e}-` : ""}${r}${t(...o)})`;
}
const zC = (e, t, n, r = []) => {
  let o = e;
  t.forEach((a, s) => {
    s === t.length - 1 ? Array.isArray(o) ? o[Number(a)] = n : o && typeof o == "object" && (o[a] = n) : o && typeof o == "object" && (o[a] || (o[a] = r.includes(a) ? [] : {}), o = o[a]);
  });
}, nF = (e, t, n) => {
  function r(o, a = [], s = []) {
    Object.entries(o).forEach(([u, c]) => {
      (!n || n && !n([...a, u])) && c != null && (typeof c == "object" && Object.keys(c).length > 0 ? r(c, [...a, u], Array.isArray(c) ? [...s, u] : s) : t([...a, u], c, s));
    });
  }
  r(e);
}, rF = (e, t) => typeof t == "number" ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((r) => e.includes(r)) || e[e.length - 1].toLowerCase().includes("opacity") ? t : `${t}px` : t;
function Ry(e, t) {
  const {
    prefix: n,
    shouldSkipGeneratingVar: r
  } = t || {}, o = {}, a = {}, s = {};
  return nF(
    e,
    (u, c, f) => {
      if ((typeof c == "string" || typeof c == "number") && (!r || !r(u, c))) {
        const h = `--${n ? `${n}-` : ""}${u.join("-")}`, p = rF(u, c);
        Object.assign(o, {
          [h]: p
        }), zC(a, u, `var(${h})`, f), zC(s, u, `var(${h}, ${p})`, f);
      }
    },
    (u) => u[0] === "vars"
    // skip 'vars/*' paths
  ), {
    css: o,
    vars: a,
    varsWithDefaults: s
  };
}
function oF(e, t = {}) {
  const {
    getSelector: n = S,
    disableCssColorScheme: r,
    colorSchemeSelector: o
  } = t, {
    colorSchemes: a = {},
    components: s,
    defaultColorScheme: u = "light",
    ...c
  } = e, {
    vars: f,
    css: h,
    varsWithDefaults: p
  } = Ry(c, t);
  let g = p;
  const y = {}, {
    [u]: w,
    ...v
  } = a;
  if (Object.entries(v || {}).forEach(([k, T]) => {
    const {
      vars: R,
      css: N,
      varsWithDefaults: j
    } = Ry(T, t);
    g = or(g, j), y[k] = {
      css: N,
      vars: R
    };
  }), w) {
    const {
      css: k,
      vars: T,
      varsWithDefaults: R
    } = Ry(w, t);
    g = or(g, R), y[u] = {
      css: k,
      vars: T
    };
  }
  function S(k, T) {
    let R = o;
    if (o === "class" && (R = ".%s"), o === "data" && (R = "[data-%s]"), o?.startsWith("data-") && !o.includes("%s") && (R = `[${o}="%s"]`), k) {
      if (R === "media")
        return e.defaultColorScheme === k ? ":root" : {
          [`@media (prefers-color-scheme: ${a[k]?.palette?.mode || k})`]: {
            ":root": T
          }
        };
      if (R)
        return e.defaultColorScheme === k ? `:root, ${R.replace("%s", String(k))}` : R.replace("%s", String(k));
    }
    return ":root";
  }
  return {
    vars: g,
    generateThemeVars: () => {
      let k = {
        ...f
      };
      return Object.entries(y).forEach(([, {
        vars: T
      }]) => {
        k = or(k, T);
      }), k;
    },
    generateStyleSheets: () => {
      const k = [], T = e.defaultColorScheme || "light";
      function R(z, B) {
        Object.keys(B).length && k.push(typeof z == "string" ? {
          [z]: {
            ...B
          }
        } : z);
      }
      R(n(void 0, {
        ...h
      }), h);
      const {
        [T]: N,
        ...j
      } = y;
      if (N) {
        const {
          css: z
        } = N, B = a[T]?.palette?.mode, M = !r && B ? {
          colorScheme: B,
          ...z
        } : {
          ...z
        };
        R(n(T, {
          ...M
        }), M);
      }
      return Object.entries(j).forEach(([z, {
        css: B
      }]) => {
        const M = a[z]?.palette?.mode, F = !r && M ? {
          colorScheme: M,
          ...B
        } : {
          ...B
        };
        R(n(z, {
          ...F
        }), F);
      }), k;
    }
  };
}
function iF(e) {
  return function(n) {
    return e === "media" ? `@media (prefers-color-scheme: ${n})` : e ? e.startsWith("data-") && !e.includes("%s") ? `[${e}="${n}"] &` : e === "class" ? `.${n} &` : e === "data" ? `[data-${n}] &` : `${e.replace("%s", n)} &` : "&";
  };
}
const Nc = {
  black: "#000",
  white: "#fff"
}, aF = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
}, Hs = {
  50: "#f3e5f5",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  700: "#7b1fa2"
}, Vs = {
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  700: "#d32f2f",
  800: "#c62828"
}, nc = {
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  700: "#f57c00",
  900: "#e65100"
}, Us = {
  50: "#e3f2fd",
  200: "#90caf9",
  400: "#42a5f5",
  700: "#1976d2",
  800: "#1565c0"
}, qs = {
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  700: "#0288d1",
  900: "#01579b"
}, Gs = {
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20"
};
function AM() {
  return {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: "rgba(0, 0, 0, 0.87)",
      // Secondary text.
      secondary: "rgba(0, 0, 0, 0.6)",
      // Disabled text have even lower visual prominence.
      disabled: "rgba(0, 0, 0, 0.38)"
    },
    // The color used to divide different elements.
    divider: "rgba(0, 0, 0, 0.12)",
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: Nc.white,
      default: Nc.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: "rgba(0, 0, 0, 0.54)",
      // The color of an hovered action.
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: "rgba(0, 0, 0, 0.26)",
      // The background color of a disabled action.
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
}
const sF = AM();
function RM() {
  return {
    text: {
      primary: Nc.white,
      secondary: "rgba(255, 255, 255, 0.7)",
      disabled: "rgba(255, 255, 255, 0.5)",
      icon: "rgba(255, 255, 255, 0.5)"
    },
    divider: "rgba(255, 255, 255, 0.12)",
    background: {
      paper: "#121212",
      default: "#121212"
    },
    action: {
      active: Nc.white,
      hover: "rgba(255, 255, 255, 0.08)",
      hoverOpacity: 0.08,
      selected: "rgba(255, 255, 255, 0.16)",
      selectedOpacity: 0.16,
      disabled: "rgba(255, 255, 255, 0.3)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };
}
const LC = RM();
function FC(e, t, n, r) {
  const o = r.light || r, a = r.dark || r * 1.5;
  e[t] || (e.hasOwnProperty(n) ? e[t] = e[n] : t === "light" ? e.light = rm(e.main, o) : t === "dark" && (e.dark = nm(e.main, a)));
}
function lF(e = "light") {
  return e === "dark" ? {
    main: Us[200],
    light: Us[50],
    dark: Us[400]
  } : {
    main: Us[700],
    light: Us[400],
    dark: Us[800]
  };
}
function uF(e = "light") {
  return e === "dark" ? {
    main: Hs[200],
    light: Hs[50],
    dark: Hs[400]
  } : {
    main: Hs[500],
    light: Hs[300],
    dark: Hs[700]
  };
}
function cF(e = "light") {
  return e === "dark" ? {
    main: Vs[500],
    light: Vs[300],
    dark: Vs[700]
  } : {
    main: Vs[700],
    light: Vs[400],
    dark: Vs[800]
  };
}
function fF(e = "light") {
  return e === "dark" ? {
    main: qs[400],
    light: qs[300],
    dark: qs[700]
  } : {
    main: qs[700],
    light: qs[500],
    dark: qs[900]
  };
}
function dF(e = "light") {
  return e === "dark" ? {
    main: Gs[400],
    light: Gs[300],
    dark: Gs[700]
  } : {
    main: Gs[800],
    light: Gs[500],
    dark: Gs[900]
  };
}
function hF(e = "light") {
  return e === "dark" ? {
    main: nc[400],
    light: nc[300],
    dark: nc[700]
  } : {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: nc[500],
    dark: nc[900]
  };
}
function E1(e) {
  const {
    mode: t = "light",
    contrastThreshold: n = 3,
    tonalOffset: r = 0.2,
    ...o
  } = e, a = e.primary || lF(t), s = e.secondary || uF(t), u = e.error || cF(t), c = e.info || fF(t), f = e.success || dF(t), h = e.warning || hF(t);
  function p(v) {
    return XL(v, LC.text.primary) >= n ? LC.text.primary : sF.text.primary;
  }
  const g = ({
    color: v,
    name: S,
    mainShade: E = 500,
    lightShade: A = 300,
    darkShade: k = 700
  }) => {
    if (v = {
      ...v
    }, !v.main && v[E] && (v.main = v[E]), !v.hasOwnProperty("main"))
      throw new Error(Va(11, S ? ` (${S})` : "", E));
    if (typeof v.main != "string")
      throw new Error(Va(12, S ? ` (${S})` : "", JSON.stringify(v.main)));
    return FC(v, "light", A, r), FC(v, "dark", k, r), v.contrastText || (v.contrastText = p(v.main)), v;
  };
  let y;
  return t === "light" ? y = AM() : t === "dark" && (y = RM()), or({
    // A collection of common colors.
    common: {
      ...Nc
    },
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode: t,
    // The colors used to represent primary interface elements for a user.
    primary: g({
      color: a,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: g({
      color: s,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: g({
      color: u,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: g({
      color: h,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: g({
      color: c,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: g({
      color: f,
      name: "success"
    }),
    // The grey colors.
    grey: aF,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold: n,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText: p,
    // Generate a rich color object.
    augmentColor: g,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset: r,
    // The light and dark mode object.
    ...y
  }, o);
}
function pF(e) {
  const t = {};
  return Object.entries(e).forEach((r) => {
    const [o, a] = r;
    typeof a == "object" && (t[o] = `${a.fontStyle ? `${a.fontStyle} ` : ""}${a.fontVariant ? `${a.fontVariant} ` : ""}${a.fontWeight ? `${a.fontWeight} ` : ""}${a.fontStretch ? `${a.fontStretch} ` : ""}${a.fontSize || ""}${a.lineHeight ? `/${a.lineHeight} ` : ""}${a.fontFamily || ""}`);
  }), t;
}
function mF(e, t) {
  return {
    toolbar: {
      minHeight: 56,
      [e.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [e.up("sm")]: {
        minHeight: 64
      }
    },
    ...t
  };
}
function gF(e) {
  return Math.round(e * 1e5) / 1e5;
}
const $C = {
  textTransform: "uppercase"
}, BC = '"Roboto", "Helvetica", "Arial", sans-serif';
function yF(e, t) {
  const {
    fontFamily: n = BC,
    // The default font size of the Material Specification.
    fontSize: r = 14,
    // px
    fontWeightLight: o = 300,
    fontWeightRegular: a = 400,
    fontWeightMedium: s = 500,
    fontWeightBold: u = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize: c = 16,
    // Apply the CSS properties to all the variants.
    allVariants: f,
    pxToRem: h,
    ...p
  } = typeof t == "function" ? t(e) : t, g = r / 14, y = h || ((S) => `${S / c * g}rem`), w = (S, E, A, k, T) => ({
    fontFamily: n,
    fontWeight: S,
    fontSize: y(E),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight: A,
    // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
    // across font-families can cause issues with the kerning.
    ...n === BC ? {
      letterSpacing: `${gF(k / E)}em`
    } : {},
    ...T,
    ...f
  }), v = {
    h1: w(o, 96, 1.167, -1.5),
    h2: w(o, 60, 1.2, -0.5),
    h3: w(a, 48, 1.167, 0),
    h4: w(a, 34, 1.235, 0.25),
    h5: w(a, 24, 1.334, 0),
    h6: w(s, 20, 1.6, 0.15),
    subtitle1: w(a, 16, 1.75, 0.15),
    subtitle2: w(s, 14, 1.57, 0.1),
    body1: w(a, 16, 1.5, 0.15),
    body2: w(a, 14, 1.43, 0.15),
    button: w(s, 14, 1.75, 0.4, $C),
    caption: w(a, 12, 1.66, 0.4),
    overline: w(a, 12, 2.66, 1, $C),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return or({
    htmlFontSize: c,
    pxToRem: y,
    fontFamily: n,
    fontSize: r,
    fontWeightLight: o,
    fontWeightRegular: a,
    fontWeightMedium: s,
    fontWeightBold: u,
    ...v
  }, p, {
    clone: !1
    // No need to clone deep
  });
}
const vF = 0.2, bF = 0.14, xF = 0.12;
function Ct(...e) {
  return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${vF})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${bF})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${xF})`].join(",");
}
const wF = ["none", Ct(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), Ct(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), Ct(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), Ct(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), Ct(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), Ct(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), Ct(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), Ct(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), Ct(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), Ct(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), Ct(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), Ct(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), Ct(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), Ct(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), Ct(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), Ct(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), Ct(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), Ct(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), Ct(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), Ct(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), Ct(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), Ct(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), Ct(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), Ct(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], _F = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}, SF = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function HC(e) {
  return `${Math.round(e)}ms`;
}
function EF(e) {
  if (!e)
    return 0;
  const t = e / 36;
  return Math.min(Math.round((4 + 15 * t ** 0.25 + t / 5) * 10), 3e3);
}
function CF(e) {
  const t = {
    ..._F,
    ...e.easing
  }, n = {
    ...SF,
    ...e.duration
  };
  return {
    getAutoHeightDuration: EF,
    create: (o = ["all"], a = {}) => {
      const {
        duration: s = n.standard,
        easing: u = t.easeInOut,
        delay: c = 0,
        ...f
      } = a;
      return (Array.isArray(o) ? o : [o]).map((h) => `${h} ${typeof s == "string" ? s : HC(s)} ${u} ${typeof c == "string" ? c : HC(c)}`).join(",");
    },
    ...e,
    easing: t,
    duration: n
  };
}
const kF = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
function TF(e) {
  return Xo(e) || typeof e > "u" || typeof e == "string" || typeof e == "boolean" || typeof e == "number" || Array.isArray(e);
}
function MM(e = {}) {
  const t = {
    ...e
  };
  function n(r) {
    const o = Object.entries(r);
    for (let a = 0; a < o.length; a++) {
      const [s, u] = o[a];
      !TF(u) || s.startsWith("unstable_") ? delete r[s] : Xo(u) && (r[s] = {
        ...u
      }, n(r[s]));
    }
  }
  return n(t), `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(t, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
}
function Uv(e = {}, ...t) {
  const {
    breakpoints: n,
    mixins: r = {},
    spacing: o,
    palette: a = {},
    transitions: s = {},
    typography: u = {},
    shape: c,
    ...f
  } = e;
  if (e.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
  // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
  e.generateThemeVars === void 0)
    throw new Error(Va(20));
  const h = E1(a), p = EM(e);
  let g = or(p, {
    mixins: mF(p.breakpoints, r),
    palette: h,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: wF.slice(),
    typography: yF(h, u),
    transitions: CF(s),
    zIndex: {
      ...kF
    }
  });
  return g = or(g, f), g = t.reduce((y, w) => or(y, w), g), g.unstable_sxConfig = {
    ...Xp,
    ...f?.unstable_sxConfig
  }, g.unstable_sx = function(w) {
    return vl({
      sx: w,
      theme: this
    });
  }, g.toRuntimeSource = MM, g;
}
function AF(e) {
  let t;
  return e < 1 ? t = 5.11916 * e ** 2 : t = 4.5 * Math.log(e + 1) + 2, Math.round(t * 10) / 1e3;
}
const RF = [...Array(25)].map((e, t) => {
  if (t === 0)
    return "none";
  const n = AF(t);
  return `linear-gradient(rgba(255 255 255 / ${n}), rgba(255 255 255 / ${n}))`;
});
function OM(e) {
  return {
    inputPlaceholder: e === "dark" ? 0.5 : 0.42,
    inputUnderline: e === "dark" ? 0.7 : 0.42,
    switchTrackDisabled: e === "dark" ? 0.2 : 0.12,
    switchTrack: e === "dark" ? 0.3 : 0.38
  };
}
function NM(e) {
  return e === "dark" ? RF : [];
}
function MF(e) {
  const {
    palette: t = {
      mode: "light"
    },
    // need to cast to avoid module augmentation test
    opacity: n,
    overlays: r,
    ...o
  } = e, a = E1(t);
  return {
    palette: a,
    opacity: {
      ...OM(a.mode),
      ...n
    },
    overlays: r || NM(a.mode),
    ...o
  };
}
function OF(e) {
  return !!e[0].match(/(cssVarPrefix|colorSchemeSelector|modularCssLayers|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!e[0].match(/sxConfig$/) || // ends with sxConfig
  e[0] === "palette" && !!e[1]?.match(/(mode|contrastThreshold|tonalOffset)/);
}
const NF = (e) => [...[...Array(25)].map((t, n) => `--${e ? `${e}-` : ""}overlays-${n}`), `--${e ? `${e}-` : ""}palette-AppBar-darkBg`, `--${e ? `${e}-` : ""}palette-AppBar-darkColor`], DF = (e) => (t, n) => {
  const r = e.rootSelector || ":root", o = e.colorSchemeSelector;
  let a = o;
  if (o === "class" && (a = ".%s"), o === "data" && (a = "[data-%s]"), o?.startsWith("data-") && !o.includes("%s") && (a = `[${o}="%s"]`), e.defaultColorScheme === t) {
    if (t === "dark") {
      const s = {};
      return NF(e.cssVarPrefix).forEach((u) => {
        s[u] = n[u], delete n[u];
      }), a === "media" ? {
        [r]: n,
        "@media (prefers-color-scheme: dark)": {
          [r]: s
        }
      } : a ? {
        [a.replace("%s", t)]: s,
        [`${r}, ${a.replace("%s", t)}`]: n
      } : {
        [r]: {
          ...n,
          ...s
        }
      };
    }
    if (a && a !== "media")
      return `${r}, ${a.replace("%s", String(t))}`;
  } else if (t) {
    if (a === "media")
      return {
        [`@media (prefers-color-scheme: ${String(t)})`]: {
          [r]: n
        }
      };
    if (a)
      return a.replace("%s", String(t));
  }
  return r;
};
function jF(e, t) {
  t.forEach((n) => {
    e[n] || (e[n] = {});
  });
}
function le(e, t, n) {
  !e[t] && n && (e[t] = n);
}
function dc(e) {
  return typeof e != "string" || !e.startsWith("hsl") ? e : TM(e);
}
function qo(e, t) {
  `${t}Channel` in e || (e[`${t}Channel`] = fc(dc(e[t])));
}
function PF(e) {
  return typeof e == "number" ? `${e}px` : typeof e == "string" || typeof e == "function" || Array.isArray(e) ? e : "8px";
}
const Qr = (e) => {
  try {
    return e();
  } catch {
  }
}, IF = (e = "mui") => tF(e);
function My(e, t, n, r) {
  if (!t)
    return;
  t = t === !0 ? {} : t;
  const o = r === "dark" ? "dark" : "light";
  if (!n) {
    e[r] = MF({
      ...t,
      palette: {
        mode: o,
        ...t?.palette
      }
    });
    return;
  }
  const {
    palette: a,
    ...s
  } = Uv({
    ...n,
    palette: {
      mode: o,
      ...t?.palette
    }
  });
  return e[r] = {
    ...t,
    palette: a,
    opacity: {
      ...OM(o),
      ...t?.opacity
    },
    overlays: t?.overlays || NM(o)
  }, s;
}
function zF(e = {}, ...t) {
  const {
    colorSchemes: n = {
      light: !0
    },
    defaultColorScheme: r,
    disableCssColorScheme: o = !1,
    cssVarPrefix: a = "mui",
    shouldSkipGeneratingVar: s = OF,
    colorSchemeSelector: u = n.light && n.dark ? "media" : void 0,
    rootSelector: c = ":root",
    ...f
  } = e, h = Object.keys(n)[0], p = r || (n.light && h !== "light" ? "light" : h), g = IF(a), {
    [p]: y,
    light: w,
    dark: v,
    ...S
  } = n, E = {
    ...S
  };
  let A = y;
  if ((p === "dark" && !("dark" in n) || p === "light" && !("light" in n)) && (A = !0), !A)
    throw new Error(Va(21, p));
  const k = My(E, A, f, p);
  w && !E.light && My(E, w, void 0, "light"), v && !E.dark && My(E, v, void 0, "dark");
  let T = {
    defaultColorScheme: p,
    ...k,
    cssVarPrefix: a,
    colorSchemeSelector: u,
    rootSelector: c,
    getCssVar: g,
    colorSchemes: E,
    font: {
      ...pF(k.typography),
      ...k.font
    },
    spacing: PF(f.spacing)
  };
  Object.keys(T.colorSchemes).forEach((B) => {
    const M = T.colorSchemes[B].palette, F = (q) => {
      const Y = q.split("-"), P = Y[1], V = Y[2];
      return g(q, M[P][V]);
    };
    if (M.mode === "light" && (le(M.common, "background", "#fff"), le(M.common, "onBackground", "#000")), M.mode === "dark" && (le(M.common, "background", "#000"), le(M.common, "onBackground", "#fff")), jF(M, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]), M.mode === "light") {
      le(M.Alert, "errorColor", gt(M.error.light, 0.6)), le(M.Alert, "infoColor", gt(M.info.light, 0.6)), le(M.Alert, "successColor", gt(M.success.light, 0.6)), le(M.Alert, "warningColor", gt(M.warning.light, 0.6)), le(M.Alert, "errorFilledBg", F("palette-error-main")), le(M.Alert, "infoFilledBg", F("palette-info-main")), le(M.Alert, "successFilledBg", F("palette-success-main")), le(M.Alert, "warningFilledBg", F("palette-warning-main")), le(M.Alert, "errorFilledColor", Qr(() => M.getContrastText(M.error.main))), le(M.Alert, "infoFilledColor", Qr(() => M.getContrastText(M.info.main))), le(M.Alert, "successFilledColor", Qr(() => M.getContrastText(M.success.main))), le(M.Alert, "warningFilledColor", Qr(() => M.getContrastText(M.warning.main))), le(M.Alert, "errorStandardBg", yt(M.error.light, 0.9)), le(M.Alert, "infoStandardBg", yt(M.info.light, 0.9)), le(M.Alert, "successStandardBg", yt(M.success.light, 0.9)), le(M.Alert, "warningStandardBg", yt(M.warning.light, 0.9)), le(M.Alert, "errorIconColor", F("palette-error-main")), le(M.Alert, "infoIconColor", F("palette-info-main")), le(M.Alert, "successIconColor", F("palette-success-main")), le(M.Alert, "warningIconColor", F("palette-warning-main")), le(M.AppBar, "defaultBg", F("palette-grey-100")), le(M.Avatar, "defaultBg", F("palette-grey-400")), le(M.Button, "inheritContainedBg", F("palette-grey-300")), le(M.Button, "inheritContainedHoverBg", F("palette-grey-A100")), le(M.Chip, "defaultBorder", F("palette-grey-400")), le(M.Chip, "defaultAvatarColor", F("palette-grey-700")), le(M.Chip, "defaultIconColor", F("palette-grey-700")), le(M.FilledInput, "bg", "rgba(0, 0, 0, 0.06)"), le(M.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)"), le(M.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)"), le(M.LinearProgress, "primaryBg", yt(M.primary.main, 0.62)), le(M.LinearProgress, "secondaryBg", yt(M.secondary.main, 0.62)), le(M.LinearProgress, "errorBg", yt(M.error.main, 0.62)), le(M.LinearProgress, "infoBg", yt(M.info.main, 0.62)), le(M.LinearProgress, "successBg", yt(M.success.main, 0.62)), le(M.LinearProgress, "warningBg", yt(M.warning.main, 0.62)), le(M.Skeleton, "bg", `rgba(${F("palette-text-primaryChannel")} / 0.11)`), le(M.Slider, "primaryTrack", yt(M.primary.main, 0.62)), le(M.Slider, "secondaryTrack", yt(M.secondary.main, 0.62)), le(M.Slider, "errorTrack", yt(M.error.main, 0.62)), le(M.Slider, "infoTrack", yt(M.info.main, 0.62)), le(M.Slider, "successTrack", yt(M.success.main, 0.62)), le(M.Slider, "warningTrack", yt(M.warning.main, 0.62));
      const q = Kd(M.background.default, 0.8);
      le(M.SnackbarContent, "bg", q), le(M.SnackbarContent, "color", Qr(() => M.getContrastText(q))), le(M.SpeedDialAction, "fabHoverBg", Kd(M.background.paper, 0.15)), le(M.StepConnector, "border", F("palette-grey-400")), le(M.StepContent, "border", F("palette-grey-400")), le(M.Switch, "defaultColor", F("palette-common-white")), le(M.Switch, "defaultDisabledColor", F("palette-grey-100")), le(M.Switch, "primaryDisabledColor", yt(M.primary.main, 0.62)), le(M.Switch, "secondaryDisabledColor", yt(M.secondary.main, 0.62)), le(M.Switch, "errorDisabledColor", yt(M.error.main, 0.62)), le(M.Switch, "infoDisabledColor", yt(M.info.main, 0.62)), le(M.Switch, "successDisabledColor", yt(M.success.main, 0.62)), le(M.Switch, "warningDisabledColor", yt(M.warning.main, 0.62)), le(M.TableCell, "border", yt(Xd(M.divider, 1), 0.88)), le(M.Tooltip, "bg", Xd(M.grey[700], 0.92));
    }
    if (M.mode === "dark") {
      le(M.Alert, "errorColor", yt(M.error.light, 0.6)), le(M.Alert, "infoColor", yt(M.info.light, 0.6)), le(M.Alert, "successColor", yt(M.success.light, 0.6)), le(M.Alert, "warningColor", yt(M.warning.light, 0.6)), le(M.Alert, "errorFilledBg", F("palette-error-dark")), le(M.Alert, "infoFilledBg", F("palette-info-dark")), le(M.Alert, "successFilledBg", F("palette-success-dark")), le(M.Alert, "warningFilledBg", F("palette-warning-dark")), le(M.Alert, "errorFilledColor", Qr(() => M.getContrastText(M.error.dark))), le(M.Alert, "infoFilledColor", Qr(() => M.getContrastText(M.info.dark))), le(M.Alert, "successFilledColor", Qr(() => M.getContrastText(M.success.dark))), le(M.Alert, "warningFilledColor", Qr(() => M.getContrastText(M.warning.dark))), le(M.Alert, "errorStandardBg", gt(M.error.light, 0.9)), le(M.Alert, "infoStandardBg", gt(M.info.light, 0.9)), le(M.Alert, "successStandardBg", gt(M.success.light, 0.9)), le(M.Alert, "warningStandardBg", gt(M.warning.light, 0.9)), le(M.Alert, "errorIconColor", F("palette-error-main")), le(M.Alert, "infoIconColor", F("palette-info-main")), le(M.Alert, "successIconColor", F("palette-success-main")), le(M.Alert, "warningIconColor", F("palette-warning-main")), le(M.AppBar, "defaultBg", F("palette-grey-900")), le(M.AppBar, "darkBg", F("palette-background-paper")), le(M.AppBar, "darkColor", F("palette-text-primary")), le(M.Avatar, "defaultBg", F("palette-grey-600")), le(M.Button, "inheritContainedBg", F("palette-grey-800")), le(M.Button, "inheritContainedHoverBg", F("palette-grey-700")), le(M.Chip, "defaultBorder", F("palette-grey-700")), le(M.Chip, "defaultAvatarColor", F("palette-grey-300")), le(M.Chip, "defaultIconColor", F("palette-grey-300")), le(M.FilledInput, "bg", "rgba(255, 255, 255, 0.09)"), le(M.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)"), le(M.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)"), le(M.LinearProgress, "primaryBg", gt(M.primary.main, 0.5)), le(M.LinearProgress, "secondaryBg", gt(M.secondary.main, 0.5)), le(M.LinearProgress, "errorBg", gt(M.error.main, 0.5)), le(M.LinearProgress, "infoBg", gt(M.info.main, 0.5)), le(M.LinearProgress, "successBg", gt(M.success.main, 0.5)), le(M.LinearProgress, "warningBg", gt(M.warning.main, 0.5)), le(M.Skeleton, "bg", `rgba(${F("palette-text-primaryChannel")} / 0.13)`), le(M.Slider, "primaryTrack", gt(M.primary.main, 0.5)), le(M.Slider, "secondaryTrack", gt(M.secondary.main, 0.5)), le(M.Slider, "errorTrack", gt(M.error.main, 0.5)), le(M.Slider, "infoTrack", gt(M.info.main, 0.5)), le(M.Slider, "successTrack", gt(M.success.main, 0.5)), le(M.Slider, "warningTrack", gt(M.warning.main, 0.5));
      const q = Kd(M.background.default, 0.98);
      le(M.SnackbarContent, "bg", q), le(M.SnackbarContent, "color", Qr(() => M.getContrastText(q))), le(M.SpeedDialAction, "fabHoverBg", Kd(M.background.paper, 0.15)), le(M.StepConnector, "border", F("palette-grey-600")), le(M.StepContent, "border", F("palette-grey-600")), le(M.Switch, "defaultColor", F("palette-grey-300")), le(M.Switch, "defaultDisabledColor", F("palette-grey-600")), le(M.Switch, "primaryDisabledColor", gt(M.primary.main, 0.55)), le(M.Switch, "secondaryDisabledColor", gt(M.secondary.main, 0.55)), le(M.Switch, "errorDisabledColor", gt(M.error.main, 0.55)), le(M.Switch, "infoDisabledColor", gt(M.info.main, 0.55)), le(M.Switch, "successDisabledColor", gt(M.success.main, 0.55)), le(M.Switch, "warningDisabledColor", gt(M.warning.main, 0.55)), le(M.TableCell, "border", gt(Xd(M.divider, 1), 0.68)), le(M.Tooltip, "bg", Xd(M.grey[700], 0.92));
    }
    qo(M.background, "default"), qo(M.background, "paper"), qo(M.common, "background"), qo(M.common, "onBackground"), qo(M, "divider"), Object.keys(M).forEach((q) => {
      const Y = M[q];
      q !== "tonalOffset" && Y && typeof Y == "object" && (Y.main && le(M[q], "mainChannel", fc(dc(Y.main))), Y.light && le(M[q], "lightChannel", fc(dc(Y.light))), Y.dark && le(M[q], "darkChannel", fc(dc(Y.dark))), Y.contrastText && le(M[q], "contrastTextChannel", fc(dc(Y.contrastText))), q === "text" && (qo(M[q], "primary"), qo(M[q], "secondary")), q === "action" && (Y.active && qo(M[q], "active"), Y.selected && qo(M[q], "selected")));
    });
  }), T = t.reduce((B, M) => or(B, M), T);
  const R = {
    prefix: a,
    disableCssColorScheme: o,
    shouldSkipGeneratingVar: s,
    getSelector: DF(T)
  }, {
    vars: N,
    generateThemeVars: j,
    generateStyleSheets: z
  } = oF(T, R);
  return T.vars = N, Object.entries(T.colorSchemes[T.defaultColorScheme]).forEach(([B, M]) => {
    T[B] = M;
  }), T.generateThemeVars = j, T.generateStyleSheets = z, T.generateSpacing = function() {
    return SM(f.spacing, m1(this));
  }, T.getColorSchemeSelector = iF(u), T.spacing = T.generateSpacing(), T.shouldSkipGeneratingVar = s, T.unstable_sxConfig = {
    ...Xp,
    ...f?.unstable_sxConfig
  }, T.unstable_sx = function(M) {
    return vl({
      sx: M,
      theme: this
    });
  }, T.toRuntimeSource = MM, T;
}
function VC(e, t, n) {
  e.colorSchemes && n && (e.colorSchemes[t] = {
    ...n !== !0 && n,
    palette: E1({
      ...n === !0 ? {} : n.palette,
      mode: t
    })
    // cast type to skip module augmentation test
  });
}
function LF(e = {}, ...t) {
  const {
    palette: n,
    cssVariables: r = !1,
    colorSchemes: o = n ? void 0 : {
      light: !0
    },
    defaultColorScheme: a = n?.mode,
    ...s
  } = e, u = a || "light", c = o?.[u], f = {
    ...o,
    ...n ? {
      [u]: {
        ...typeof c != "boolean" && c,
        palette: n
      }
    } : void 0
  };
  if (r === !1) {
    if (!("colorSchemes" in e))
      return Uv(e, ...t);
    let h = n;
    "palette" in e || f[u] && (f[u] !== !0 ? h = f[u].palette : u === "dark" && (h = {
      mode: "dark"
    }));
    const p = Uv({
      ...e,
      palette: h
    }, ...t);
    return p.defaultColorScheme = u, p.colorSchemes = f, p.palette.mode === "light" && (p.colorSchemes.light = {
      ...f.light !== !0 && f.light,
      palette: p.palette
    }, VC(p, "dark", f.dark)), p.palette.mode === "dark" && (p.colorSchemes.dark = {
      ...f.dark !== !0 && f.dark,
      palette: p.palette
    }, VC(p, "light", f.light)), p;
  }
  return !n && !("light" in f) && u === "light" && (f.light = !0), zF({
    ...s,
    colorSchemes: f,
    defaultColorScheme: u,
    ...typeof r != "boolean" && r
  }, ...t);
}
const FF = LF(), $F = "$$material";
function BF(e) {
  return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
}
const HF = (e) => BF(e) && e !== "classes", Tr = $L({
  themeId: $F,
  defaultTheme: FF,
  rootShouldForwardProp: HF
}), zl = eF;
function wo(e) {
  return JL(e);
}
function VF(e) {
  return bo("MuiTable", e);
}
xo("MuiTable", ["root", "stickyHeader"]);
const UF = (e) => {
  const {
    classes: t,
    stickyHeader: n
  } = e;
  return li({
    root: ["root", n && "stickyHeader"]
  }, VF, t);
}, qF = Tr("table", {
  name: "MuiTable",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.stickyHeader && t.stickyHeader];
  }
})(zl(({
  theme: e
}) => ({
  display: "table",
  width: "100%",
  borderCollapse: "collapse",
  borderSpacing: 0,
  "& caption": {
    ...e.typography.body2,
    padding: e.spacing(2),
    color: (e.vars || e).palette.text.secondary,
    textAlign: "left",
    captionSide: "bottom"
  },
  variants: [{
    props: ({
      ownerState: t
    }) => t.stickyHeader,
    style: {
      borderCollapse: "separate"
    }
  }]
}))), UC = "table", GF = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = wo({
    props: t,
    name: "MuiTable"
  }), {
    className: o,
    component: a = UC,
    padding: s = "normal",
    size: u = "medium",
    stickyHeader: c = !1,
    ...f
  } = r, h = {
    ...r,
    component: a,
    padding: s,
    size: u,
    stickyHeader: c
  }, p = UF(h), g = _.useMemo(() => ({
    padding: s,
    size: u,
    stickyHeader: c
  }), [s, u, c]);
  return /* @__PURE__ */ b.jsx(oM.Provider, {
    value: g,
    children: /* @__PURE__ */ b.jsx(qF, {
      as: a,
      role: a === UC ? null : "table",
      ref: n,
      className: zt(p.root, o),
      ownerState: h,
      ...f
    })
  });
}), om = /* @__PURE__ */ _.createContext();
function YF(e) {
  return bo("MuiTableBody", e);
}
xo("MuiTableBody", ["root"]);
const WF = (e) => {
  const {
    classes: t
  } = e;
  return li({
    root: ["root"]
  }, YF, t);
}, XF = Tr("tbody", {
  name: "MuiTableBody",
  slot: "Root"
})({
  display: "table-row-group"
}), KF = {
  variant: "body"
}, qC = "tbody", ZF = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = wo({
    props: t,
    name: "MuiTableBody"
  }), {
    className: o,
    component: a = qC,
    ...s
  } = r, u = {
    ...r,
    component: a
  }, c = WF(u);
  return /* @__PURE__ */ b.jsx(om.Provider, {
    value: KF,
    children: /* @__PURE__ */ b.jsx(XF, {
      className: zt(c.root, o),
      as: a,
      ref: n,
      role: a === qC ? null : "rowgroup",
      ownerState: u,
      ...s
    })
  });
});
function QF(e) {
  return bo("MuiTableCell", e);
}
const JF = xo("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]), e9 = (e) => {
  const {
    classes: t,
    variant: n,
    align: r,
    padding: o,
    size: a,
    stickyHeader: s
  } = e, u = {
    root: ["root", n, s && "stickyHeader", r !== "inherit" && `align${Tn(r)}`, o !== "normal" && `padding${Tn(o)}`, `size${Tn(a)}`]
  };
  return li(u, QF, t);
}, t9 = Tr("td", {
  name: "MuiTableCell",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, t[n.variant], t[`size${Tn(n.size)}`], n.padding !== "normal" && t[`padding${Tn(n.padding)}`], n.align !== "inherit" && t[`align${Tn(n.align)}`], n.stickyHeader && t.stickyHeader];
  }
})(zl(({
  theme: e
}) => ({
  ...e.typography.body2,
  display: "table-cell",
  verticalAlign: "inherit",
  // Workaround for a rendering bug with spanned columns in Chrome 62.0.
  // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
  borderBottom: e.vars ? `1px solid ${e.vars.palette.TableCell.border}` : `1px solid
    ${e.palette.mode === "light" ? rm(Oc(e.palette.divider, 1), 0.88) : nm(Oc(e.palette.divider, 1), 0.68)}`,
  textAlign: "left",
  padding: 16,
  variants: [{
    props: {
      variant: "head"
    },
    style: {
      color: (e.vars || e).palette.text.primary,
      lineHeight: e.typography.pxToRem(24),
      fontWeight: e.typography.fontWeightMedium
    }
  }, {
    props: {
      variant: "body"
    },
    style: {
      color: (e.vars || e).palette.text.primary
    }
  }, {
    props: {
      variant: "footer"
    },
    style: {
      color: (e.vars || e).palette.text.secondary,
      lineHeight: e.typography.pxToRem(21),
      fontSize: e.typography.pxToRem(12)
    }
  }, {
    props: {
      size: "small"
    },
    style: {
      padding: "6px 16px",
      [`&.${JF.paddingCheckbox}`]: {
        width: 24,
        // prevent the checkbox column from growing
        padding: "0 12px 0 16px",
        "& > *": {
          padding: 0
        }
      }
    }
  }, {
    props: {
      padding: "checkbox"
    },
    style: {
      width: 48,
      // prevent the checkbox column from growing
      padding: "0 0 0 4px"
    }
  }, {
    props: {
      padding: "none"
    },
    style: {
      padding: 0
    }
  }, {
    props: {
      align: "left"
    },
    style: {
      textAlign: "left"
    }
  }, {
    props: {
      align: "center"
    },
    style: {
      textAlign: "center"
    }
  }, {
    props: {
      align: "right"
    },
    style: {
      textAlign: "right",
      flexDirection: "row-reverse"
    }
  }, {
    props: {
      align: "justify"
    },
    style: {
      textAlign: "justify"
    }
  }, {
    props: ({
      ownerState: t
    }) => t.stickyHeader,
    style: {
      position: "sticky",
      top: 0,
      zIndex: 2,
      backgroundColor: (e.vars || e).palette.background.default
    }
  }]
}))), Zd = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = wo({
    props: t,
    name: "MuiTableCell"
  }), {
    align: o = "inherit",
    className: a,
    component: s,
    padding: u,
    scope: c,
    size: f,
    sortDirection: h,
    variant: p,
    ...g
  } = r, y = _.useContext(oM), w = _.useContext(om), v = w && w.variant === "head";
  let S;
  s ? S = s : S = v ? "th" : "td";
  let E = c;
  S === "td" ? E = void 0 : !E && v && (E = "col");
  const A = p || w && w.variant, k = {
    ...r,
    align: o,
    component: S,
    padding: u || (y && y.padding ? y.padding : "normal"),
    size: f || (y && y.size ? y.size : "medium"),
    sortDirection: h,
    stickyHeader: A === "head" && y && y.stickyHeader,
    variant: A
  }, T = e9(k);
  let R = null;
  return h && (R = h === "asc" ? "ascending" : "descending"), /* @__PURE__ */ b.jsx(t9, {
    as: S,
    ref: n,
    className: zt(T.root, a),
    "aria-sort": R,
    scope: E,
    ownerState: k,
    ...g
  });
});
function n9(e) {
  return bo("MuiTableContainer", e);
}
xo("MuiTableContainer", ["root"]);
const r9 = (e) => {
  const {
    classes: t
  } = e;
  return li({
    root: ["root"]
  }, n9, t);
}, o9 = Tr("div", {
  name: "MuiTableContainer",
  slot: "Root"
})({
  width: "100%",
  overflowX: "auto"
}), i9 = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = wo({
    props: t,
    name: "MuiTableContainer"
  }), {
    className: o,
    component: a = "div",
    ...s
  } = r, u = {
    ...r,
    component: a
  }, c = r9(u);
  return /* @__PURE__ */ b.jsx(o9, {
    ref: n,
    as: a,
    className: zt(c.root, o),
    ownerState: u,
    ...s
  });
});
function a9(e) {
  return bo("MuiTableHead", e);
}
xo("MuiTableHead", ["root"]);
const s9 = (e) => {
  const {
    classes: t
  } = e;
  return li({
    root: ["root"]
  }, a9, t);
}, l9 = Tr("thead", {
  name: "MuiTableHead",
  slot: "Root"
})({
  display: "table-header-group"
}), u9 = {
  variant: "head"
}, GC = "thead", c9 = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = wo({
    props: t,
    name: "MuiTableHead"
  }), {
    className: o,
    component: a = GC,
    ...s
  } = r, u = {
    ...r,
    component: a
  }, c = s9(u);
  return /* @__PURE__ */ b.jsx(om.Provider, {
    value: u9,
    children: /* @__PURE__ */ b.jsx(l9, {
      as: a,
      className: zt(c.root, o),
      ref: n,
      role: a === GC ? null : "rowgroup",
      ownerState: u,
      ...s
    })
  });
});
function f9(e) {
  return bo("MuiTableRow", e);
}
const YC = xo("MuiTableRow", ["root", "selected", "hover", "head", "footer"]), d9 = (e) => {
  const {
    classes: t,
    selected: n,
    hover: r,
    head: o,
    footer: a
  } = e;
  return li({
    root: ["root", n && "selected", r && "hover", o && "head", a && "footer"]
  }, f9, t);
}, h9 = Tr("tr", {
  name: "MuiTableRow",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.head && t.head, n.footer && t.footer];
  }
})(zl(({
  theme: e
}) => ({
  color: "inherit",
  display: "table-row",
  verticalAlign: "middle",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  [`&.${YC.hover}:hover`]: {
    backgroundColor: (e.vars || e).palette.action.hover
  },
  [`&.${YC.selected}`]: {
    backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / ${e.vars.palette.action.selectedOpacity})` : Oc(e.palette.primary.main, e.palette.action.selectedOpacity),
    "&:hover": {
      backgroundColor: e.vars ? `rgba(${e.vars.palette.primary.mainChannel} / calc(${e.vars.palette.action.selectedOpacity} + ${e.vars.palette.action.hoverOpacity}))` : Oc(e.palette.primary.main, e.palette.action.selectedOpacity + e.palette.action.hoverOpacity)
    }
  }
}))), WC = "tr", Qd = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = wo({
    props: t,
    name: "MuiTableRow"
  }), {
    className: o,
    component: a = WC,
    hover: s = !1,
    selected: u = !1,
    ...c
  } = r, f = _.useContext(om), h = {
    ...r,
    component: a,
    hover: s,
    selected: u,
    head: f && f.variant === "head",
    footer: f && f.variant === "footer"
  }, p = d9(h);
  return /* @__PURE__ */ b.jsx(h9, {
    as: a,
    ref: n,
    className: zt(p.root, o),
    role: a === WC ? null : "row",
    ownerState: h,
    ...c
  });
});
function XC(e) {
  try {
    return e.matches(":focus-visible");
  } catch {
  }
  return !1;
}
function qv(...e) {
  const t = _.useRef(void 0), n = _.useCallback((r) => {
    const o = e.map((a) => {
      if (a == null)
        return null;
      if (typeof a == "function") {
        const s = a, u = s(r);
        return typeof u == "function" ? u : () => {
          s(null);
        };
      }
      return a.current = r, () => {
        a.current = null;
      };
    });
    return () => {
      o.forEach((a) => a?.());
    };
  }, e);
  return _.useMemo(() => e.every((r) => r == null) ? null : (r) => {
    t.current && (t.current(), t.current = void 0), r != null && (t.current = n(r));
  }, e);
}
function Dh(e) {
  const t = _.useRef(e);
  return qL(() => {
    t.current = e;
  }), _.useRef((...n) => (
    // @ts-expect-error hide `this`
    (0, t.current)(...n)
  )).current;
}
const KC = {};
function DM(e, t) {
  const n = _.useRef(KC);
  return n.current === KC && (n.current = e(t)), n;
}
class Jh {
  constructor() {
    Qu(this, "mountEffect", () => {
      this.shouldMount && !this.didMount && this.ref.current !== null && (this.didMount = !0, this.mounted.resolve());
    });
    this.ref = {
      current: null
    }, this.mounted = null, this.didMount = !1, this.shouldMount = !1, this.setShouldMount = null;
  }
  /** React ref to the ripple instance */
  /** If the ripple component should be mounted */
  /** Promise that resolves when the ripple component is mounted */
  /** If the ripple component has been mounted */
  /** React state hook setter */
  static create() {
    return new Jh();
  }
  static use() {
    const t = DM(Jh.create).current, [n, r] = _.useState(!1);
    return t.shouldMount = n, t.setShouldMount = r, _.useEffect(t.mountEffect, [n]), t;
  }
  mount() {
    return this.mounted || (this.mounted = m9(), this.shouldMount = !0, this.setShouldMount(this.shouldMount)), this.mounted;
  }
  /* Ripple API */
  start(...t) {
    this.mount().then(() => this.ref.current?.start(...t));
  }
  stop(...t) {
    this.mount().then(() => this.ref.current?.stop(...t));
  }
  pulsate(...t) {
    this.mount().then(() => this.ref.current?.pulsate(...t));
  }
}
function p9() {
  return Jh.use();
}
function m9() {
  let e, t;
  const n = new Promise((r, o) => {
    e = r, t = o;
  });
  return n.resolve = e, n.reject = t, n;
}
function C1(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function ep(e, t) {
  return ep = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
    return n.__proto__ = r, n;
  }, ep(e, t);
}
function jM(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, ep(e, t);
}
const ZC = nn.createContext(null);
function PM(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function k1(e, t) {
  var n = function(a) {
    return t && _.isValidElement(a) ? t(a) : a;
  }, r = /* @__PURE__ */ Object.create(null);
  return e && _.Children.map(e, function(o) {
    return o;
  }).forEach(function(o) {
    r[o.key] = n(o);
  }), r;
}
function g9(e, t) {
  e = e || {}, t = t || {};
  function n(h) {
    return h in t ? t[h] : e[h];
  }
  var r = /* @__PURE__ */ Object.create(null), o = [];
  for (var a in e)
    a in t ? o.length && (r[a] = o, o = []) : o.push(a);
  var s, u = {};
  for (var c in t) {
    if (r[c])
      for (s = 0; s < r[c].length; s++) {
        var f = r[c][s];
        u[r[c][s]] = n(f);
      }
    u[c] = n(c);
  }
  for (s = 0; s < o.length; s++)
    u[o[s]] = n(o[s]);
  return u;
}
function ja(e, t, n) {
  return n[t] != null ? n[t] : e.props[t];
}
function y9(e, t) {
  return k1(e.children, function(n) {
    return _.cloneElement(n, {
      onExited: t.bind(null, n),
      in: !0,
      appear: ja(n, "appear", e),
      enter: ja(n, "enter", e),
      exit: ja(n, "exit", e)
    });
  });
}
function v9(e, t, n) {
  var r = k1(e.children), o = g9(t, r);
  return Object.keys(o).forEach(function(a) {
    var s = o[a];
    if (_.isValidElement(s)) {
      var u = a in t, c = a in r, f = t[a], h = _.isValidElement(f) && !f.props.in;
      c && (!u || h) ? o[a] = _.cloneElement(s, {
        onExited: n.bind(null, s),
        in: !0,
        exit: ja(s, "exit", e),
        enter: ja(s, "enter", e)
      }) : !c && u && !h ? o[a] = _.cloneElement(s, {
        in: !1
      }) : c && u && _.isValidElement(f) && (o[a] = _.cloneElement(s, {
        onExited: n.bind(null, s),
        in: f.props.in,
        exit: ja(s, "exit", e),
        enter: ja(s, "enter", e)
      }));
    }
  }), o;
}
var b9 = Object.values || function(e) {
  return Object.keys(e).map(function(t) {
    return e[t];
  });
}, x9 = {
  component: "div",
  childFactory: function(t) {
    return t;
  }
}, T1 = /* @__PURE__ */ function(e) {
  jM(t, e);
  function t(r, o) {
    var a;
    a = e.call(this, r, o) || this;
    var s = a.handleExited.bind(PM(a));
    return a.state = {
      contextValue: {
        isMounting: !0
      },
      handleExited: s,
      firstRender: !0
    }, a;
  }
  var n = t.prototype;
  return n.componentDidMount = function() {
    this.mounted = !0, this.setState({
      contextValue: {
        isMounting: !1
      }
    });
  }, n.componentWillUnmount = function() {
    this.mounted = !1;
  }, t.getDerivedStateFromProps = function(o, a) {
    var s = a.children, u = a.handleExited, c = a.firstRender;
    return {
      children: c ? y9(o, u) : v9(o, s, u),
      firstRender: !1
    };
  }, n.handleExited = function(o, a) {
    var s = k1(this.props.children);
    o.key in s || (o.props.onExited && o.props.onExited(a), this.mounted && this.setState(function(u) {
      var c = Re({}, u.children);
      return delete c[o.key], {
        children: c
      };
    }));
  }, n.render = function() {
    var o = this.props, a = o.component, s = o.childFactory, u = C1(o, ["component", "childFactory"]), c = this.state.contextValue, f = b9(this.state.children).map(s);
    return delete u.appear, delete u.enter, delete u.exit, a === null ? /* @__PURE__ */ nn.createElement(ZC.Provider, {
      value: c
    }, f) : /* @__PURE__ */ nn.createElement(ZC.Provider, {
      value: c
    }, /* @__PURE__ */ nn.createElement(a, u, f));
  }, t;
}(nn.Component);
T1.propTypes = {};
T1.defaultProps = x9;
const w9 = [];
function _9(e) {
  _.useEffect(e, w9);
}
class A1 {
  constructor() {
    Qu(this, "currentId", null);
    Qu(this, "clear", () => {
      this.currentId !== null && (clearTimeout(this.currentId), this.currentId = null);
    });
    Qu(this, "disposeEffect", () => this.clear);
  }
  static create() {
    return new A1();
  }
  /**
   * Executes `fn` after `delay`, clearing any previously scheduled call.
   */
  start(t, n) {
    this.clear(), this.currentId = setTimeout(() => {
      this.currentId = null, n();
    }, t);
  }
}
function S9() {
  const e = DM(A1.create).current;
  return _9(e.disposeEffect), e;
}
function E9(e) {
  const {
    className: t,
    classes: n,
    pulsate: r = !1,
    rippleX: o,
    rippleY: a,
    rippleSize: s,
    in: u,
    onExited: c,
    timeout: f
  } = e, [h, p] = _.useState(!1), g = zt(t, n.ripple, n.rippleVisible, r && n.ripplePulsate), y = {
    width: s,
    height: s,
    top: -(s / 2) + a,
    left: -(s / 2) + o
  }, w = zt(n.child, h && n.childLeaving, r && n.childPulsate);
  return !u && !h && p(!0), _.useEffect(() => {
    if (!u && c != null) {
      const v = setTimeout(c, f);
      return () => {
        clearTimeout(v);
      };
    }
  }, [c, u, f]), /* @__PURE__ */ b.jsx("span", {
    className: g,
    style: y,
    children: /* @__PURE__ */ b.jsx("span", {
      className: w
    })
  });
}
const xr = xo("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), Gv = 550, C9 = 80, k9 = em`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`, T9 = em`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`, A9 = em`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`, R9 = Tr("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
}), M9 = Tr(E9, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})`
  opacity: 0;
  position: absolute;

  &.${xr.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${k9};
    animation-duration: ${Gv}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  &.${xr.ripplePulsate} {
    animation-duration: ${({
  theme: e
}) => e.transitions.duration.shorter}ms;
  }

  & .${xr.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${xr.childLeaving} {
    opacity: 0;
    animation-name: ${T9};
    animation-duration: ${Gv}ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
  }

  & .${xr.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${A9};
    animation-duration: 2500ms;
    animation-timing-function: ${({
  theme: e
}) => e.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`, O9 = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = wo({
    props: t,
    name: "MuiTouchRipple"
  }), {
    center: o = !1,
    classes: a = {},
    className: s,
    ...u
  } = r, [c, f] = _.useState([]), h = _.useRef(0), p = _.useRef(null);
  _.useEffect(() => {
    p.current && (p.current(), p.current = null);
  }, [c]);
  const g = _.useRef(!1), y = S9(), w = _.useRef(null), v = _.useRef(null), S = _.useCallback((T) => {
    const {
      pulsate: R,
      rippleX: N,
      rippleY: j,
      rippleSize: z,
      cb: B
    } = T;
    f((M) => [...M, /* @__PURE__ */ b.jsx(M9, {
      classes: {
        ripple: zt(a.ripple, xr.ripple),
        rippleVisible: zt(a.rippleVisible, xr.rippleVisible),
        ripplePulsate: zt(a.ripplePulsate, xr.ripplePulsate),
        child: zt(a.child, xr.child),
        childLeaving: zt(a.childLeaving, xr.childLeaving),
        childPulsate: zt(a.childPulsate, xr.childPulsate)
      },
      timeout: Gv,
      pulsate: R,
      rippleX: N,
      rippleY: j,
      rippleSize: z
    }, h.current)]), h.current += 1, p.current = B;
  }, [a]), E = _.useCallback((T = {}, R = {}, N = () => {
  }) => {
    const {
      pulsate: j = !1,
      center: z = o || R.pulsate,
      fakeElement: B = !1
      // For test purposes
    } = R;
    if (T?.type === "mousedown" && g.current) {
      g.current = !1;
      return;
    }
    T?.type === "touchstart" && (g.current = !0);
    const M = B ? null : v.current, F = M ? M.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let q, Y, P;
    if (z || T === void 0 || T.clientX === 0 && T.clientY === 0 || !T.clientX && !T.touches)
      q = Math.round(F.width / 2), Y = Math.round(F.height / 2);
    else {
      const {
        clientX: V,
        clientY: I
      } = T.touches && T.touches.length > 0 ? T.touches[0] : T;
      q = Math.round(V - F.left), Y = Math.round(I - F.top);
    }
    if (z)
      P = Math.sqrt((2 * F.width ** 2 + F.height ** 2) / 3), P % 2 === 0 && (P += 1);
    else {
      const V = Math.max(Math.abs((M ? M.clientWidth : 0) - q), q) * 2 + 2, I = Math.max(Math.abs((M ? M.clientHeight : 0) - Y), Y) * 2 + 2;
      P = Math.sqrt(V ** 2 + I ** 2);
    }
    T?.touches ? w.current === null && (w.current = () => {
      S({
        pulsate: j,
        rippleX: q,
        rippleY: Y,
        rippleSize: P,
        cb: N
      });
    }, y.start(C9, () => {
      w.current && (w.current(), w.current = null);
    })) : S({
      pulsate: j,
      rippleX: q,
      rippleY: Y,
      rippleSize: P,
      cb: N
    });
  }, [o, S, y]), A = _.useCallback(() => {
    E({}, {
      pulsate: !0
    });
  }, [E]), k = _.useCallback((T, R) => {
    if (y.clear(), T?.type === "touchend" && w.current) {
      w.current(), w.current = null, y.start(0, () => {
        k(T, R);
      });
      return;
    }
    w.current = null, f((N) => N.length > 0 ? N.slice(1) : N), p.current = R;
  }, [y]);
  return _.useImperativeHandle(n, () => ({
    pulsate: A,
    start: E,
    stop: k
  }), [A, E, k]), /* @__PURE__ */ b.jsx(R9, {
    className: zt(xr.root, a.root, s),
    ref: v,
    ...u,
    children: /* @__PURE__ */ b.jsx(T1, {
      component: null,
      exit: !0,
      children: c
    })
  });
});
function N9(e) {
  return bo("MuiButtonBase", e);
}
const D9 = xo("MuiButtonBase", ["root", "disabled", "focusVisible"]), j9 = (e) => {
  const {
    disabled: t,
    focusVisible: n,
    focusVisibleClassName: r,
    classes: o
  } = e, s = li({
    root: ["root", t && "disabled", n && "focusVisible"]
  }, N9, o);
  return n && r && (s.root += ` ${r}`), s;
}, P9 = Tr("button", {
  name: "MuiButtonBase",
  slot: "Root"
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${D9.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
}), I9 = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = wo({
    props: t,
    name: "MuiButtonBase"
  }), {
    action: o,
    centerRipple: a = !1,
    children: s,
    className: u,
    component: c = "button",
    disabled: f = !1,
    disableRipple: h = !1,
    disableTouchRipple: p = !1,
    focusRipple: g = !1,
    focusVisibleClassName: y,
    LinkComponent: w = "a",
    onBlur: v,
    onClick: S,
    onContextMenu: E,
    onDragLeave: A,
    onFocus: k,
    onFocusVisible: T,
    onKeyDown: R,
    onKeyUp: N,
    onMouseDown: j,
    onMouseLeave: z,
    onMouseUp: B,
    onTouchEnd: M,
    onTouchMove: F,
    onTouchStart: q,
    tabIndex: Y = 0,
    TouchRippleProps: P,
    touchRippleRef: V,
    type: I,
    ...U
  } = r, H = _.useRef(null), G = p9(), O = qv(G.ref, V), [W, Z] = _.useState(!1);
  f && W && Z(!1), _.useImperativeHandle(o, () => ({
    focusVisible: () => {
      Z(!0), H.current.focus();
    }
  }), []);
  const L = G.shouldMount && !h && !f;
  _.useEffect(() => {
    W && g && !h && G.pulsate();
  }, [h, g, W, G]);
  const te = Go(G, "start", j, p), he = Go(G, "stop", E, p), oe = Go(G, "stop", A, p), fe = Go(G, "stop", B, p), ae = Go(G, "stop", (ze) => {
    W && ze.preventDefault(), z && z(ze);
  }, p), ye = Go(G, "start", q, p), Ne = Go(G, "stop", M, p), De = Go(G, "stop", F, p), we = Go(G, "stop", (ze) => {
    XC(ze.target) || Z(!1), v && v(ze);
  }, !1), Ce = Dh((ze) => {
    H.current || (H.current = ze.currentTarget), XC(ze.target) && (Z(!0), T && T(ze)), k && k(ze);
  }), _e = () => {
    const ze = H.current;
    return c && c !== "button" && !(ze.tagName === "A" && ze.href);
  }, Xe = Dh((ze) => {
    g && !ze.repeat && W && ze.key === " " && G.stop(ze, () => {
      G.start(ze);
    }), ze.target === ze.currentTarget && _e() && ze.key === " " && ze.preventDefault(), R && R(ze), ze.target === ze.currentTarget && _e() && ze.key === "Enter" && !f && (ze.preventDefault(), S && S(ze));
  }), St = Dh((ze) => {
    g && ze.key === " " && W && !ze.defaultPrevented && G.stop(ze, () => {
      G.pulsate(ze);
    }), N && N(ze), S && ze.target === ze.currentTarget && _e() && ze.key === " " && !ze.defaultPrevented && S(ze);
  });
  let ct = c;
  ct === "button" && (U.href || U.to) && (ct = w);
  const cn = {};
  ct === "button" ? (cn.type = I === void 0 ? "button" : I, cn.disabled = f) : (!U.href && !U.to && (cn.role = "button"), f && (cn["aria-disabled"] = f));
  const fr = qv(n, H), Un = {
    ...r,
    centerRipple: a,
    component: c,
    disabled: f,
    disableRipple: h,
    disableTouchRipple: p,
    focusRipple: g,
    tabIndex: Y,
    focusVisible: W
  }, qn = j9(Un);
  return /* @__PURE__ */ b.jsxs(P9, {
    as: ct,
    className: zt(qn.root, u),
    ownerState: Un,
    onBlur: we,
    onClick: S,
    onContextMenu: he,
    onFocus: Ce,
    onKeyDown: Xe,
    onKeyUp: St,
    onMouseDown: te,
    onMouseLeave: ae,
    onMouseUp: fe,
    onDragLeave: oe,
    onTouchEnd: Ne,
    onTouchMove: De,
    onTouchStart: ye,
    ref: fr,
    tabIndex: f ? -1 : Y,
    type: I,
    ...cn,
    ...U,
    children: [s, L ? /* @__PURE__ */ b.jsx(O9, {
      ref: O,
      center: a,
      ...P
    }) : null]
  });
});
function Go(e, t, n, r = !1) {
  return Dh((o) => (n && n(o), r || e[t](o), !0));
}
function z9(e) {
  return bo("MuiSvgIcon", e);
}
xo("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const L9 = (e) => {
  const {
    color: t,
    fontSize: n,
    classes: r
  } = e, o = {
    root: ["root", t !== "inherit" && `color${Tn(t)}`, `fontSize${Tn(n)}`]
  };
  return li(o, z9, r);
}, F9 = Tr("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.color !== "inherit" && t[`color${Tn(n.color)}`], t[`fontSize${Tn(n.fontSize)}`]];
  }
})(zl(({
  theme: e
}) => ({
  userSelect: "none",
  width: "1em",
  height: "1em",
  display: "inline-block",
  flexShrink: 0,
  transition: e.transitions?.create?.("fill", {
    duration: (e.vars ?? e).transitions?.duration?.shorter
  }),
  variants: [
    {
      props: (t) => !t.hasSvgAsChild,
      style: {
        // the <svg> will define the property that has `currentColor`
        // for example heroicons uses fill="none" and stroke="currentColor"
        fill: "currentColor"
      }
    },
    {
      props: {
        fontSize: "inherit"
      },
      style: {
        fontSize: "inherit"
      }
    },
    {
      props: {
        fontSize: "small"
      },
      style: {
        fontSize: e.typography?.pxToRem?.(20) || "1.25rem"
      }
    },
    {
      props: {
        fontSize: "medium"
      },
      style: {
        fontSize: e.typography?.pxToRem?.(24) || "1.5rem"
      }
    },
    {
      props: {
        fontSize: "large"
      },
      style: {
        fontSize: e.typography?.pxToRem?.(35) || "2.1875rem"
      }
    },
    // TODO v5 deprecate color prop, v6 remove for sx
    ...Object.entries((e.vars ?? e).palette).filter(([, t]) => t && t.main).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        color: (e.vars ?? e).palette?.[t]?.main
      }
    })),
    {
      props: {
        color: "action"
      },
      style: {
        color: (e.vars ?? e).palette?.action?.active
      }
    },
    {
      props: {
        color: "disabled"
      },
      style: {
        color: (e.vars ?? e).palette?.action?.disabled
      }
    },
    {
      props: {
        color: "inherit"
      },
      style: {
        color: void 0
      }
    }
  ]
}))), Yv = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = wo({
    props: t,
    name: "MuiSvgIcon"
  }), {
    children: o,
    className: a,
    color: s = "inherit",
    component: u = "svg",
    fontSize: c = "medium",
    htmlColor: f,
    inheritViewBox: h = !1,
    titleAccess: p,
    viewBox: g = "0 0 24 24",
    ...y
  } = r, w = /* @__PURE__ */ _.isValidElement(o) && o.type === "svg", v = {
    ...r,
    color: s,
    component: u,
    fontSize: c,
    instanceFontSize: t.fontSize,
    inheritViewBox: h,
    viewBox: g,
    hasSvgAsChild: w
  }, S = {};
  h || (S.viewBox = g);
  const E = L9(v);
  return /* @__PURE__ */ b.jsxs(F9, {
    as: u,
    className: zt(E.root, a),
    focusable: "false",
    color: f,
    "aria-hidden": p ? void 0 : !0,
    role: p ? "img" : void 0,
    ref: n,
    ...S,
    ...y,
    ...w && o.props,
    ownerState: v,
    children: [w ? o.props.children : o, p ? /* @__PURE__ */ b.jsx("title", {
      children: p
    }) : null]
  });
});
Yv.muiName = "SvgIcon";
function $9(e, t) {
  function n(r, o) {
    return /* @__PURE__ */ b.jsx(Yv, {
      "data-testid": void 0,
      ref: o,
      ...r,
      children: e
    });
  }
  return n.muiName = Yv.muiName, /* @__PURE__ */ _.memo(/* @__PURE__ */ _.forwardRef(n));
}
const B9 = $9(/* @__PURE__ */ b.jsx("path", {
  d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
}));
function H9(e) {
  return bo("MuiTableSortLabel", e);
}
const Oy = xo("MuiTableSortLabel", ["root", "active", "icon", "iconDirectionDesc", "iconDirectionAsc", "directionDesc", "directionAsc"]);
function V9(e) {
  return typeof e == "string";
}
function U9(e, t, n) {
  return e === void 0 || V9(e) ? t : {
    ...t,
    ownerState: {
      ...t.ownerState,
      ...n
    }
  };
}
function q9(e, t, n) {
  return typeof e == "function" ? e(t, n) : e;
}
function G9(e, t = []) {
  if (e === void 0)
    return {};
  const n = {};
  return Object.keys(e).filter((r) => r.match(/^on[A-Z]/) && typeof e[r] == "function" && !t.includes(r)).forEach((r) => {
    n[r] = e[r];
  }), n;
}
function QC(e) {
  if (e === void 0)
    return {};
  const t = {};
  return Object.keys(e).filter((n) => !(n.match(/^on[A-Z]/) && typeof e[n] == "function")).forEach((n) => {
    t[n] = e[n];
  }), t;
}
function Y9(e) {
  const {
    getSlotProps: t,
    additionalProps: n,
    externalSlotProps: r,
    externalForwardedProps: o,
    className: a
  } = e;
  if (!t) {
    const y = zt(n?.className, a, o?.className, r?.className), w = {
      ...n?.style,
      ...o?.style,
      ...r?.style
    }, v = {
      ...n,
      ...o,
      ...r
    };
    return y.length > 0 && (v.className = y), Object.keys(w).length > 0 && (v.style = w), {
      props: v,
      internalRef: void 0
    };
  }
  const s = G9({
    ...o,
    ...r
  }), u = QC(r), c = QC(o), f = t(s), h = zt(f?.className, n?.className, a, o?.className, r?.className), p = {
    ...f?.style,
    ...n?.style,
    ...o?.style,
    ...r?.style
  }, g = {
    ...f,
    ...n,
    ...c,
    ...u
  };
  return h.length > 0 && (g.className = h), Object.keys(p).length > 0 && (g.style = p), {
    props: g,
    internalRef: f.ref
  };
}
function JC(e, t) {
  const {
    className: n,
    elementType: r,
    ownerState: o,
    externalForwardedProps: a,
    internalForwardedProps: s,
    shouldForwardComponentProp: u = !1,
    ...c
  } = t, {
    component: f,
    slots: h = {
      [e]: void 0
    },
    slotProps: p = {
      [e]: void 0
    },
    ...g
  } = a, y = h[e] || r, w = q9(p[e], o), {
    props: {
      component: v,
      ...S
    },
    internalRef: E
  } = Y9({
    className: n,
    ...c,
    externalForwardedProps: e === "root" ? g : void 0,
    externalSlotProps: w
  }), A = qv(E, w?.ref, t.ref), k = e === "root" ? v || f : v, T = U9(y, {
    ...e === "root" && !f && !h[e] && s,
    ...e !== "root" && !h[e] && s,
    ...S,
    ...k && !u && {
      as: k
    },
    ...k && u && {
      component: k
    },
    ref: A
  }, o);
  return [y, T];
}
const W9 = (e) => {
  const {
    classes: t,
    direction: n,
    active: r
  } = e, o = {
    root: ["root", r && "active", `direction${Tn(n)}`],
    icon: ["icon", `iconDirection${Tn(n)}`]
  };
  return li(o, H9, t);
}, X9 = Tr(I9, {
  name: "MuiTableSortLabel",
  slot: "Root",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.active && t.active];
  }
})(zl(({
  theme: e
}) => ({
  cursor: "pointer",
  display: "inline-flex",
  justifyContent: "flex-start",
  flexDirection: "inherit",
  alignItems: "center",
  "&:focus": {
    color: (e.vars || e).palette.text.secondary
  },
  "&:hover": {
    color: (e.vars || e).palette.text.secondary,
    [`& .${Oy.icon}`]: {
      opacity: 0.5
    }
  },
  [`&.${Oy.active}`]: {
    color: (e.vars || e).palette.text.primary,
    [`& .${Oy.icon}`]: {
      opacity: 1,
      color: (e.vars || e).palette.text.secondary
    }
  }
}))), K9 = Tr("span", {
  name: "MuiTableSortLabel",
  slot: "Icon",
  overridesResolver: (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.icon, t[`iconDirection${Tn(n.direction)}`]];
  }
})(zl(({
  theme: e
}) => ({
  fontSize: 18,
  marginRight: 4,
  marginLeft: 4,
  opacity: 0,
  transition: e.transitions.create(["opacity", "transform"], {
    duration: e.transitions.duration.shorter
  }),
  userSelect: "none",
  variants: [{
    props: {
      direction: "desc"
    },
    style: {
      transform: "rotate(0deg)"
    }
  }, {
    props: {
      direction: "asc"
    },
    style: {
      transform: "rotate(180deg)"
    }
  }]
}))), Z9 = /* @__PURE__ */ _.forwardRef(function(t, n) {
  const r = wo({
    props: t,
    name: "MuiTableSortLabel"
  }), {
    active: o = !1,
    children: a,
    className: s,
    direction: u = "asc",
    hideSortIcon: c = !1,
    IconComponent: f = B9,
    slots: h = {},
    slotProps: p = {},
    ...g
  } = r, y = {
    ...r,
    active: o,
    direction: u,
    hideSortIcon: c,
    IconComponent: f
  }, w = W9(y), v = {
    slots: h,
    slotProps: p
  }, [S, E] = JC("root", {
    elementType: X9,
    externalForwardedProps: v,
    ownerState: y,
    className: zt(w.root, s),
    ref: n
  }), [A, k] = JC("icon", {
    elementType: K9,
    externalForwardedProps: v,
    ownerState: y,
    className: w.icon
  });
  return /* @__PURE__ */ b.jsxs(S, {
    disableRipple: !0,
    component: "span",
    ...E,
    ...g,
    children: [a, c && !o ? null : /* @__PURE__ */ b.jsx(A, {
      as: f,
      ...k
    })]
  });
}), Q9 = (e) => {
  const t = [];
  if (e === void 0)
    return {
      header: [],
      rows: []
    };
  e.data === void 0 && (e.data = []), (e.columns === void 0 || e.columns.length === 0) && (e.data.length === 0 ? e.columns = [] : e.columns = e.data[0].map((r, o) => `col${o}`)), (e.index === void 0 || e.index.length === 0) && (e.index = e.data.map((r, o) => `row${o}`));
  const n = Math.max(e.index.length, e.data.length);
  for (let r = 0; r < n; r++) {
    const a = [r < e.index.length ? e.index[r] : `row${r}`];
    for (let s = 0; s < e.columns.length; s++)
      a.push(e.data[r] ? e.data[r][s] : void 0);
    t.push(a);
  }
  return {
    header: ["index", ...e.columns],
    rows: t
  };
}, J9 = (e, t) => e === "desc" ? (n, r) => r[t] < n[t] ? -1 : r[t] > n[t] ? 1 : 0 : (n, r) => n[t] < r[t] ? -1 : n[t] > r[t] ? 1 : 0, Wv = (e, t) => {
  const n = e.map((r, o) => [
    r,
    o
  ]);
  return n.sort((r, o) => t(r[0], o[0])), n.map((r) => r[0]);
}, e8 = (e, t, n = 1e3) => {
  if (e.length <= n)
    return Wv(e, t);
  const r = [];
  for (let a = 0; a < e.length; a += n)
    r.push(e.slice(a, a + n));
  const o = r.map((a) => Wv(a, t));
  return t8(o, t);
}, t8 = (e, t) => {
  if (e.length === 1) return e[0];
  const n = [], r = new Array(e.length).fill(0);
  for (; r.some((o, a) => o < e[a].length); ) {
    let o = -1, a = null;
    for (let s = 0; s < e.length; s++)
      if (r[s] < e[s].length) {
        const u = e[s][r[s]];
        (a === null || t(u, a) < 0) && (a = u, o = s);
      }
    o !== -1 && a !== null && (n.push(a), r[o]++);
  }
  return n;
}, ek = (e, t, n) => {
  const r = Math.ceil(e / n);
  return {
    currentPage: r === 0 ? 1 : Math.min(Math.max(1, t), r),
    pageSize: n,
    totalPages: r,
    totalRows: e
  };
}, n8 = (e, t, n) => {
  const r = (t - 1) * n, o = r + n;
  return e.slice(r, o);
}, r8 = (e, t, n, r, o = 5) => {
  const a = Math.max(0, Math.floor(e / n) - o), s = Math.min(
    r - 1,
    Math.ceil((e + t) / n) + o
  );
  return { startIndex: a, endIndex: s };
}, o8 = (e, t) => {
  let n;
  return (...r) => {
    clearTimeout(n), n = setTimeout(() => e(...r), t);
  };
}, IM = ({
  tabledata: e,
  className: t = "",
  size: n = "small",
  onSortChange: r,
  enablePagination: o = void 0,
  pageSize: a = 50,
  enableVirtualScrolling: s = void 0,
  virtualScrollingHeight: u = 400,
  enableLazyLoading: c = void 0,
  onLoadMore: f
}) => {
  e || (e = {
    columns: [],
    index: [],
    data: []
  });
  const h = e.index.length;
  h > 1e4 && (c = c === void 0 ? !0 : c), h > 1e3 && (s = s === void 0 ? !0 : s), h > 2 * a && (o = o === void 0 ? !0 : o), c = c === void 0 ? !1 : c, s = s === void 0 ? !1 : s, o = o === void 0 ? !1 : o;
  const p = _.useMemo(
    () => Q9(e),
    [e]
  ), [g, y] = _.useState("asc"), [w, v] = _.useState("index"), [S, E] = _.useState(
    () => ek(p.rows.length, 1, a)
  ), [A, k] = _.useState(0), T = _.useRef(null), R = _.useMemo(() => {
    const H = p.header.indexOf(w);
    return H === -1 ? 0 : H;
  }, [p.header, w]), N = _.useMemo(
    () => o8((H, G) => {
      y(G), v(H), r?.(H, G);
    }, 150),
    [r]
  ), j = _.useCallback(
    (H) => {
      const O = w === H && g === "asc" ? "desc" : "asc";
      p.rows.length > 1e3 ? N(H, O) : (y(O), v(H), r?.(H, O));
    },
    [
      w,
      g,
      r,
      p.rows.length,
      N
    ]
  ), z = _.useMemo(
    () => J9(g, R),
    [g, R]
  ), B = _.useMemo(() => p.rows.length > 1e3 ? e8(p.rows, z) : Wv(p.rows, z), [p.rows, z]), M = _.useMemo(() => o ? n8(B, S.currentPage, S.pageSize) : B, [
    B,
    o,
    S.currentPage,
    S.pageSize
  ]), F = {
    itemHeight: 48,
    // Approximate row height
    overscan: 5,
    containerHeight: u
  }, q = _.useMemo(() => s ? r8(
    A,
    F.containerHeight,
    F.itemHeight,
    M.length,
    F.overscan
  ) : { startIndex: 0, endIndex: M.length - 1 }, [
    A,
    s,
    M.length,
    F
  ]), Y = _.useCallback(
    (H) => {
      s && k(H.currentTarget.scrollTop);
    },
    [s]
  ), P = _.useCallback((H) => {
    E((G) => ({
      ...G,
      currentPage: H
    }));
  }, []), V = _.useCallback(
    (H) => {
      if (!(!o || !(H.target.closest(".sortable-table-wrapper") === H.currentTarget)))
        switch (H.key) {
          case "ArrowLeft":
            S.currentPage > 1 && (H.preventDefault(), H.stopPropagation(), P(S.currentPage - 1));
            break;
          case "ArrowRight":
            S.currentPage < S.totalPages && (H.preventDefault(), H.stopPropagation(), P(S.currentPage + 1));
            break;
          case "Home":
            S.currentPage > 1 && (H.preventDefault(), H.stopPropagation(), P(1));
            break;
          case "End":
            S.currentPage < S.totalPages && (H.preventDefault(), H.stopPropagation(), P(S.totalPages));
            break;
        }
    },
    [
      o,
      S.currentPage,
      S.totalPages,
      P
    ]
  );
  _.useEffect(() => {
    o && E((H) => ek(
      B.length,
      H.currentPage,
      // Use previous current page instead of hardcoding 1
      a
    ));
  }, [B.length, o, a]), _.useEffect(() => {
    c && f && S.currentPage >= S.totalPages - 1 && f(S.currentPage + 1);
  }, [
    c,
    f,
    S.currentPage,
    S.totalPages
  ]);
  const I = () => o ? /* @__PURE__ */ b.jsxs("div", { className: "sortable-table-pagination", children: [
    /* @__PURE__ */ b.jsx(
      "button",
      {
        onClick: () => P(S.currentPage - 1),
        disabled: S.currentPage <= 1,
        className: "pagination-button",
        children: "Previous"
      }
    ),
    /* @__PURE__ */ b.jsxs("span", { className: "pagination-info", children: [
      "Page ",
      S.currentPage,
      " of ",
      S.totalPages,
      "(",
      S.totalRows,
      " total rows)"
    ] }),
    /* @__PURE__ */ b.jsx(
      "button",
      {
        onClick: () => P(S.currentPage + 1),
        disabled: S.currentPage >= S.totalPages,
        className: "pagination-button",
        children: "Next"
      }
    )
  ] }) : null, U = () => {
    const H = s ? M.slice(
      q.startIndex,
      q.endIndex + 1
    ) : M;
    return /* @__PURE__ */ b.jsxs(ZF, { children: [
      s && /* @__PURE__ */ b.jsx(
        Qd,
        {
          style: {
            height: q.startIndex * F.itemHeight
          },
          children: /* @__PURE__ */ b.jsx(Zd, { colSpan: p.header.length })
        }
      ),
      H.map((G, O) => {
        const W = s ? q.startIndex + O : O;
        return /* @__PURE__ */ b.jsx(Qd, { children: G.map((Z, L) => /* @__PURE__ */ b.jsx(
          Zd,
          {
            className: L === 0 ? "sortable-table-index-cell" : "sortable-table-data-cell",
            children: Z
          },
          `${e.index?.[W] || W}-${L}`
        )) }, e.index?.[W] || W);
      }),
      s && /* @__PURE__ */ b.jsx(
        Qd,
        {
          style: {
            height: (M.length - q.endIndex - 1) * F.itemHeight
          },
          children: /* @__PURE__ */ b.jsx(Zd, { colSpan: p.header.length })
        }
      )
    ] });
  };
  return /* @__PURE__ */ b.jsxs(
    "div",
    {
      className: "sortable-table-wrapper",
      onKeyDown: V,
      tabIndex: o ? 0 : -1,
      role: o ? "application" : void 0,
      "aria-label": o ? "Sortable table with pagination" : void 0,
      children: [
        /* @__PURE__ */ b.jsx(
          i9,
          {
            className: `sortable-table-container ${t}`,
            ref: T,
            onScroll: Y,
            style: s ? { height: u } : void 0,
            children: /* @__PURE__ */ b.jsxs(GF, { size: n, children: [
              /* @__PURE__ */ b.jsx(c9, { className: "sortable-table-head", children: /* @__PURE__ */ b.jsx(Qd, { className: "sortable-table-header-row", children: p.header.map((H) => /* @__PURE__ */ b.jsx(
                Zd,
                {
                  className: "sortable-table-header-cell",
                  "aria-label": `Sort by ${H}`,
                  children: /* @__PURE__ */ b.jsx(
                    Z9,
                    {
                      active: w === H,
                      direction: w === H ? g : "asc",
                      onClick: () => j(H),
                      className: "sortable-table-sort-label",
                      sx: {
                        "& .MuiTableSortLabel-icon": {
                          color: "inherit !important"
                        }
                      },
                      children: H
                    }
                  )
                },
                H
              )) }) }),
              U()
            ] })
          }
        ),
        I()
      ]
    }
  );
};
IM.displayName = "SortableTable";
function xe(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(o) {
    if (e?.(o), n === !1 || !o.defaultPrevented)
      return t?.(o);
  };
}
function tk(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function im(...e) {
  return (t) => {
    let n = !1;
    const r = e.map((o) => {
      const a = tk(o, t);
      return !n && typeof a == "function" && (n = !0), a;
    });
    if (n)
      return () => {
        for (let o = 0; o < r.length; o++) {
          const a = r[o];
          typeof a == "function" ? a() : tk(e[o], null);
        }
      };
  };
}
function bt(...e) {
  return _.useCallback(im(...e), e);
}
function i8(e, t) {
  const n = _.createContext(t), r = (a) => {
    const { children: s, ...u } = a, c = _.useMemo(() => u, Object.values(u));
    return /* @__PURE__ */ b.jsx(n.Provider, { value: c, children: s });
  };
  r.displayName = e + "Provider";
  function o(a) {
    const s = _.useContext(n);
    if (s) return s;
    if (t !== void 0) return t;
    throw new Error(`\`${a}\` must be used within \`${e}\``);
  }
  return [r, o];
}
function _o(e, t = []) {
  let n = [];
  function r(a, s) {
    const u = _.createContext(s), c = n.length;
    n = [...n, s];
    const f = (p) => {
      const { scope: g, children: y, ...w } = p, v = g?.[e]?.[c] || u, S = _.useMemo(() => w, Object.values(w));
      return /* @__PURE__ */ b.jsx(v.Provider, { value: S, children: y });
    };
    f.displayName = a + "Provider";
    function h(p, g) {
      const y = g?.[e]?.[c] || u, w = _.useContext(y);
      if (w) return w;
      if (s !== void 0) return s;
      throw new Error(`\`${p}\` must be used within \`${a}\``);
    }
    return [f, h];
  }
  const o = () => {
    const a = n.map((s) => _.createContext(s));
    return function(u) {
      const c = u?.[e] || a;
      return _.useMemo(
        () => ({ [`__scope${e}`]: { ...u, [e]: c } }),
        [u, c]
      );
    };
  };
  return o.scopeName = e, [r, a8(o, ...t)];
}
function a8(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((o) => ({
      useScope: o(),
      scopeName: o.scopeName
    }));
    return function(a) {
      const s = r.reduce((u, { useScope: c, scopeName: f }) => {
        const p = c(a)[`__scope${f}`];
        return { ...u, ...p };
      }, {});
      return _.useMemo(() => ({ [`__scope${t.scopeName}`]: s }), [s]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
var ni = globalThis?.document ? _.useLayoutEffect : () => {
}, s8 = yl[" useId ".trim().toString()] || (() => {
}), l8 = 0;
function po(e) {
  const [t, n] = _.useState(s8());
  return ni(() => {
    n((r) => r ?? String(l8++));
  }, [e]), e || (t ? `radix-${t}` : "");
}
var u8 = yl[" useInsertionEffect ".trim().toString()] || ni;
function sa({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  },
  caller: r
}) {
  const [o, a, s] = c8({
    defaultProp: t,
    onChange: n
  }), u = e !== void 0, c = u ? e : o;
  {
    const h = _.useRef(e !== void 0);
    _.useEffect(() => {
      const p = h.current;
      p !== u && console.warn(
        `${r} is changing from ${p ? "controlled" : "uncontrolled"} to ${u ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      ), h.current = u;
    }, [u, r]);
  }
  const f = _.useCallback(
    (h) => {
      if (u) {
        const p = f8(h) ? h(e) : h;
        p !== e && s.current?.(p);
      } else
        a(h);
    },
    [u, e, a, s]
  );
  return [c, f];
}
function c8({
  defaultProp: e,
  onChange: t
}) {
  const [n, r] = _.useState(e), o = _.useRef(n), a = _.useRef(t);
  return u8(() => {
    a.current = t;
  }, [t]), _.useEffect(() => {
    o.current !== n && (a.current?.(n), o.current = n);
  }, [n, o]), [n, r, a];
}
function f8(e) {
  return typeof e == "function";
}
// @__NO_SIDE_EFFECTS__
function xl(e) {
  const t = /* @__PURE__ */ d8(e), n = _.forwardRef((r, o) => {
    const { children: a, ...s } = r, u = _.Children.toArray(a), c = u.find(p8);
    if (c) {
      const f = c.props.children, h = u.map((p) => p === c ? _.Children.count(f) > 1 ? _.Children.only(null) : _.isValidElement(f) ? f.props.children : null : p);
      return /* @__PURE__ */ b.jsx(t, { ...s, ref: o, children: _.isValidElement(f) ? _.cloneElement(f, void 0, h) : null });
    }
    return /* @__PURE__ */ b.jsx(t, { ...s, ref: o, children: a });
  });
  return n.displayName = `${e}.Slot`, n;
}
// @__NO_SIDE_EFFECTS__
function d8(e) {
  const t = _.forwardRef((n, r) => {
    const { children: o, ...a } = n;
    if (_.isValidElement(o)) {
      const s = g8(o), u = m8(a, o.props);
      return o.type !== _.Fragment && (u.ref = r ? im(r, s) : s), _.cloneElement(o, u);
    }
    return _.Children.count(o) > 1 ? _.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var h8 = Symbol("radix.slottable");
function p8(e) {
  return _.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === h8;
}
function m8(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? o && a ? n[r] = (...u) => {
      const c = a(...u);
      return o(...u), c;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...a } : r === "className" && (n[r] = [o, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function g8(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var y8 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], qe = y8.reduce((e, t) => {
  const n = /* @__PURE__ */ xl(`Primitive.${t}`), r = _.forwardRef((o, a) => {
    const { asChild: s, ...u } = o, c = s ? n : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ b.jsx(c, { ...u, ref: a });
  });
  return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
}, {});
function R1(e, t) {
  e && Pl.flushSync(() => e.dispatchEvent(t));
}
function Hn(e) {
  const t = _.useRef(e);
  return _.useEffect(() => {
    t.current = e;
  }), _.useMemo(() => (...n) => t.current?.(...n), []);
}
function v8(e, t = globalThis?.document) {
  const n = Hn(e);
  _.useEffect(() => {
    const r = (o) => {
      o.key === "Escape" && n(o);
    };
    return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
  }, [n, t]);
}
var b8 = "DismissableLayer", Xv = "dismissableLayer.update", x8 = "dismissableLayer.pointerDownOutside", w8 = "dismissableLayer.focusOutside", nk, zM = _.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), of = _.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: o,
      onFocusOutside: a,
      onInteractOutside: s,
      onDismiss: u,
      ...c
    } = e, f = _.useContext(zM), [h, p] = _.useState(null), g = h?.ownerDocument ?? globalThis?.document, [, y] = _.useState({}), w = bt(t, (j) => p(j)), v = Array.from(f.layers), [S] = [...f.layersWithOutsidePointerEventsDisabled].slice(-1), E = v.indexOf(S), A = h ? v.indexOf(h) : -1, k = f.layersWithOutsidePointerEventsDisabled.size > 0, T = A >= E, R = S8((j) => {
      const z = j.target, B = [...f.branches].some((M) => M.contains(z));
      !T || B || (o?.(j), s?.(j), j.defaultPrevented || u?.());
    }, g), N = E8((j) => {
      const z = j.target;
      [...f.branches].some((M) => M.contains(z)) || (a?.(j), s?.(j), j.defaultPrevented || u?.());
    }, g);
    return v8((j) => {
      A === f.layers.size - 1 && (r?.(j), !j.defaultPrevented && u && (j.preventDefault(), u()));
    }, g), _.useEffect(() => {
      if (h)
        return n && (f.layersWithOutsidePointerEventsDisabled.size === 0 && (nk = g.body.style.pointerEvents, g.body.style.pointerEvents = "none"), f.layersWithOutsidePointerEventsDisabled.add(h)), f.layers.add(h), rk(), () => {
          n && f.layersWithOutsidePointerEventsDisabled.size === 1 && (g.body.style.pointerEvents = nk);
        };
    }, [h, g, n, f]), _.useEffect(() => () => {
      h && (f.layers.delete(h), f.layersWithOutsidePointerEventsDisabled.delete(h), rk());
    }, [h, f]), _.useEffect(() => {
      const j = () => y({});
      return document.addEventListener(Xv, j), () => document.removeEventListener(Xv, j);
    }, []), /* @__PURE__ */ b.jsx(
      qe.div,
      {
        ...c,
        ref: w,
        style: {
          pointerEvents: k ? T ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: xe(e.onFocusCapture, N.onFocusCapture),
        onBlurCapture: xe(e.onBlurCapture, N.onBlurCapture),
        onPointerDownCapture: xe(
          e.onPointerDownCapture,
          R.onPointerDownCapture
        )
      }
    );
  }
);
of.displayName = b8;
var _8 = "DismissableLayerBranch", LM = _.forwardRef((e, t) => {
  const n = _.useContext(zM), r = _.useRef(null), o = bt(t, r);
  return _.useEffect(() => {
    const a = r.current;
    if (a)
      return n.branches.add(a), () => {
        n.branches.delete(a);
      };
  }, [n.branches]), /* @__PURE__ */ b.jsx(qe.div, { ...e, ref: o });
});
LM.displayName = _8;
function S8(e, t = globalThis?.document) {
  const n = Hn(e), r = _.useRef(!1), o = _.useRef(() => {
  });
  return _.useEffect(() => {
    const a = (u) => {
      if (u.target && !r.current) {
        let c = function() {
          FM(
            x8,
            n,
            f,
            { discrete: !0 }
          );
        };
        const f = { originalEvent: u };
        u.pointerType === "touch" ? (t.removeEventListener("click", o.current), o.current = c, t.addEventListener("click", o.current, { once: !0 })) : c();
      } else
        t.removeEventListener("click", o.current);
      r.current = !1;
    }, s = window.setTimeout(() => {
      t.addEventListener("pointerdown", a);
    }, 0);
    return () => {
      window.clearTimeout(s), t.removeEventListener("pointerdown", a), t.removeEventListener("click", o.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function E8(e, t = globalThis?.document) {
  const n = Hn(e), r = _.useRef(!1);
  return _.useEffect(() => {
    const o = (a) => {
      a.target && !r.current && FM(w8, n, { originalEvent: a }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", o), () => t.removeEventListener("focusin", o);
  }, [t, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function rk() {
  const e = new CustomEvent(Xv);
  document.dispatchEvent(e);
}
function FM(e, t, n, { discrete: r }) {
  const o = n.originalEvent.target, a = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && o.addEventListener(e, t, { once: !0 }), r ? R1(o, a) : o.dispatchEvent(a);
}
var C8 = of, k8 = LM, Ny = "focusScope.autoFocusOnMount", Dy = "focusScope.autoFocusOnUnmount", ok = { bubbles: !1, cancelable: !0 }, T8 = "FocusScope", am = _.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: o,
    onUnmountAutoFocus: a,
    ...s
  } = e, [u, c] = _.useState(null), f = Hn(o), h = Hn(a), p = _.useRef(null), g = bt(t, (v) => c(v)), y = _.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  _.useEffect(() => {
    if (r) {
      let v = function(k) {
        if (y.paused || !u) return;
        const T = k.target;
        u.contains(T) ? p.current = T : Gi(p.current, { select: !0 });
      }, S = function(k) {
        if (y.paused || !u) return;
        const T = k.relatedTarget;
        T !== null && (u.contains(T) || Gi(p.current, { select: !0 }));
      }, E = function(k) {
        if (document.activeElement === document.body)
          for (const R of k)
            R.removedNodes.length > 0 && Gi(u);
      };
      document.addEventListener("focusin", v), document.addEventListener("focusout", S);
      const A = new MutationObserver(E);
      return u && A.observe(u, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", v), document.removeEventListener("focusout", S), A.disconnect();
      };
    }
  }, [r, u, y.paused]), _.useEffect(() => {
    if (u) {
      ak.add(y);
      const v = document.activeElement;
      if (!u.contains(v)) {
        const E = new CustomEvent(Ny, ok);
        u.addEventListener(Ny, f), u.dispatchEvent(E), E.defaultPrevented || (A8(D8($M(u)), { select: !0 }), document.activeElement === v && Gi(u));
      }
      return () => {
        u.removeEventListener(Ny, f), setTimeout(() => {
          const E = new CustomEvent(Dy, ok);
          u.addEventListener(Dy, h), u.dispatchEvent(E), E.defaultPrevented || Gi(v ?? document.body, { select: !0 }), u.removeEventListener(Dy, h), ak.remove(y);
        }, 0);
      };
    }
  }, [u, f, h, y]);
  const w = _.useCallback(
    (v) => {
      if (!n && !r || y.paused) return;
      const S = v.key === "Tab" && !v.altKey && !v.ctrlKey && !v.metaKey, E = document.activeElement;
      if (S && E) {
        const A = v.currentTarget, [k, T] = R8(A);
        k && T ? !v.shiftKey && E === T ? (v.preventDefault(), n && Gi(k, { select: !0 })) : v.shiftKey && E === k && (v.preventDefault(), n && Gi(T, { select: !0 })) : E === A && v.preventDefault();
      }
    },
    [n, r, y.paused]
  );
  return /* @__PURE__ */ b.jsx(qe.div, { tabIndex: -1, ...s, ref: g, onKeyDown: w });
});
am.displayName = T8;
function A8(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (Gi(r, { select: t }), document.activeElement !== n) return;
}
function R8(e) {
  const t = $M(e), n = ik(t, e), r = ik(t.reverse(), e);
  return [n, r];
}
function $M(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const o = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function ik(e, t) {
  for (const n of e)
    if (!M8(n, { upTo: t })) return n;
}
function M8(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function O8(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function Gi(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && O8(e) && t && e.select();
  }
}
var ak = N8();
function N8() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && n?.pause(), e = sk(e, t), e.unshift(t);
    },
    remove(t) {
      e = sk(e, t), e[0]?.resume();
    }
  };
}
function sk(e, t) {
  const n = [...e], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function D8(e) {
  return e.filter((t) => t.tagName !== "A");
}
var j8 = "Portal", sm = _.forwardRef((e, t) => {
  const { container: n, ...r } = e, [o, a] = _.useState(!1);
  ni(() => a(!0), []);
  const s = n || o && globalThis?.document?.body;
  return s ? P6.createPortal(/* @__PURE__ */ b.jsx(qe.div, { ...r, ref: t }), s) : null;
});
sm.displayName = j8;
function P8(e, t) {
  return _.useReducer((n, r) => t[n][r] ?? n, e);
}
var Br = (e) => {
  const { present: t, children: n } = e, r = I8(t), o = typeof n == "function" ? n({ present: r.isPresent }) : _.Children.only(n), a = bt(r.ref, z8(o));
  return typeof n == "function" || r.isPresent ? _.cloneElement(o, { ref: a }) : null;
};
Br.displayName = "Presence";
function I8(e) {
  const [t, n] = _.useState(), r = _.useRef(null), o = _.useRef(e), a = _.useRef("none"), s = e ? "mounted" : "unmounted", [u, c] = P8(s, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return _.useEffect(() => {
    const f = Jd(r.current);
    a.current = u === "mounted" ? f : "none";
  }, [u]), ni(() => {
    const f = r.current, h = o.current;
    if (h !== e) {
      const g = a.current, y = Jd(f);
      e ? c("MOUNT") : y === "none" || f?.display === "none" ? c("UNMOUNT") : c(h && g !== y ? "ANIMATION_OUT" : "UNMOUNT"), o.current = e;
    }
  }, [e, c]), ni(() => {
    if (t) {
      let f;
      const h = t.ownerDocument.defaultView ?? window, p = (y) => {
        const v = Jd(r.current).includes(y.animationName);
        if (y.target === t && v && (c("ANIMATION_END"), !o.current)) {
          const S = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", f = h.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = S);
          });
        }
      }, g = (y) => {
        y.target === t && (a.current = Jd(r.current));
      };
      return t.addEventListener("animationstart", g), t.addEventListener("animationcancel", p), t.addEventListener("animationend", p), () => {
        h.clearTimeout(f), t.removeEventListener("animationstart", g), t.removeEventListener("animationcancel", p), t.removeEventListener("animationend", p);
      };
    } else
      c("ANIMATION_END");
  }, [t, c]), {
    isPresent: ["mounted", "unmountSuspended"].includes(u),
    ref: _.useCallback((f) => {
      r.current = f ? getComputedStyle(f) : null, n(f);
    }, [])
  };
}
function Jd(e) {
  return e?.animationName || "none";
}
function z8(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var jy = 0;
function M1() {
  _.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? lk()), document.body.insertAdjacentElement("beforeend", e[1] ?? lk()), jy++, () => {
      jy === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), jy--;
    };
  }, []);
}
function lk() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var so = function() {
  return so = Object.assign || function(t) {
    for (var n, r = 1, o = arguments.length; r < o; r++) {
      n = arguments[r];
      for (var a in n) Object.prototype.hasOwnProperty.call(n, a) && (t[a] = n[a]);
    }
    return t;
  }, so.apply(this, arguments);
};
function BM(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
function jh(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, o = t.length, a; r < o; r++)
    (a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), a[r] = t[r]);
  return e.concat(a || Array.prototype.slice.call(t));
}
var Ph = "right-scroll-bar-position", Ih = "width-before-scroll-bar", L8 = "with-scroll-bars-hidden", F8 = "--removed-body-scroll-bar-size";
function Py(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function $8(e, t) {
  var n = _.useState(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var o = n.value;
          o !== r && (n.value = r, n.callback(r, o));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var B8 = typeof window < "u" ? _.useLayoutEffect : _.useEffect, uk = /* @__PURE__ */ new WeakMap();
function H8(e, t) {
  var n = $8(null, function(r) {
    return e.forEach(function(o) {
      return Py(o, r);
    });
  });
  return B8(function() {
    var r = uk.get(n);
    if (r) {
      var o = new Set(r), a = new Set(e), s = n.current;
      o.forEach(function(u) {
        a.has(u) || Py(u, null);
      }), a.forEach(function(u) {
        o.has(u) || Py(u, s);
      });
    }
    uk.set(n, e);
  }, [e]), n;
}
function V8(e) {
  return e;
}
function U8(e, t) {
  t === void 0 && (t = V8);
  var n = [], r = !1, o = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(a) {
      var s = t(a, r);
      return n.push(s), function() {
        n = n.filter(function(u) {
          return u !== s;
        });
      };
    },
    assignSyncMedium: function(a) {
      for (r = !0; n.length; ) {
        var s = n;
        n = [], s.forEach(a);
      }
      n = {
        push: function(u) {
          return a(u);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(a) {
      r = !0;
      var s = [];
      if (n.length) {
        var u = n;
        n = [], u.forEach(a), s = n;
      }
      var c = function() {
        var h = s;
        s = [], h.forEach(a);
      }, f = function() {
        return Promise.resolve().then(c);
      };
      f(), n = {
        push: function(h) {
          s.push(h), f();
        },
        filter: function(h) {
          return s = s.filter(h), n;
        }
      };
    }
  };
  return o;
}
function q8(e) {
  e === void 0 && (e = {});
  var t = U8(null);
  return t.options = so({ async: !0, ssr: !1 }, e), t;
}
var HM = function(e) {
  var t = e.sideCar, n = BM(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return _.createElement(r, so({}, n));
};
HM.isSideCarExport = !0;
function G8(e, t) {
  return e.useMedium(t), HM;
}
var VM = q8(), Iy = function() {
}, lm = _.forwardRef(function(e, t) {
  var n = _.useRef(null), r = _.useState({
    onScrollCapture: Iy,
    onWheelCapture: Iy,
    onTouchMoveCapture: Iy
  }), o = r[0], a = r[1], s = e.forwardProps, u = e.children, c = e.className, f = e.removeScrollBar, h = e.enabled, p = e.shards, g = e.sideCar, y = e.noRelative, w = e.noIsolation, v = e.inert, S = e.allowPinchZoom, E = e.as, A = E === void 0 ? "div" : E, k = e.gapMode, T = BM(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), R = g, N = H8([n, t]), j = so(so({}, T), o);
  return _.createElement(
    _.Fragment,
    null,
    h && _.createElement(R, { sideCar: VM, removeScrollBar: f, shards: p, noRelative: y, noIsolation: w, inert: v, setCallbacks: a, allowPinchZoom: !!S, lockRef: n, gapMode: k }),
    s ? _.cloneElement(_.Children.only(u), so(so({}, j), { ref: N })) : _.createElement(A, so({}, j, { className: c, ref: N }), u)
  );
});
lm.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
lm.classNames = {
  fullWidth: Ih,
  zeroRight: Ph
};
var Y8 = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function W8() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = Y8();
  return t && e.setAttribute("nonce", t), e;
}
function X8(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function K8(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var Z8 = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = W8()) && (X8(t, n), K8(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, Q8 = function() {
  var e = Z8();
  return function(t, n) {
    _.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, UM = function() {
  var e = Q8(), t = function(n) {
    var r = n.styles, o = n.dynamic;
    return e(r, o), null;
  };
  return t;
}, J8 = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, zy = function(e) {
  return parseInt(e || "", 10) || 0;
}, e$ = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], o = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [zy(n), zy(r), zy(o)];
}, t$ = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return J8;
  var t = e$(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, n$ = UM(), ul = "data-scroll-locked", r$ = function(e, t, n, r) {
  var o = e.left, a = e.top, s = e.right, u = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(L8, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(u, "px ").concat(r, `;
  }
  body[`).concat(ul, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(o, `px;
    padding-top: `).concat(a, `px;
    padding-right: `).concat(s, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(u, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(u, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }

  .`).concat(Ph, ` {
    right: `).concat(u, "px ").concat(r, `;
  }

  .`).concat(Ih, ` {
    margin-right: `).concat(u, "px ").concat(r, `;
  }

  .`).concat(Ph, " .").concat(Ph, ` {
    right: 0 `).concat(r, `;
  }

  .`).concat(Ih, " .").concat(Ih, ` {
    margin-right: 0 `).concat(r, `;
  }

  body[`).concat(ul, `] {
    `).concat(F8, ": ").concat(u, `px;
  }
`);
}, ck = function() {
  var e = parseInt(document.body.getAttribute(ul) || "0", 10);
  return isFinite(e) ? e : 0;
}, o$ = function() {
  _.useEffect(function() {
    return document.body.setAttribute(ul, (ck() + 1).toString()), function() {
      var e = ck() - 1;
      e <= 0 ? document.body.removeAttribute(ul) : document.body.setAttribute(ul, e.toString());
    };
  }, []);
}, i$ = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, o = r === void 0 ? "margin" : r;
  o$();
  var a = _.useMemo(function() {
    return t$(o);
  }, [o]);
  return _.createElement(n$, { styles: r$(a, !t, o, n ? "" : "!important") });
}, Kv = !1;
if (typeof window < "u")
  try {
    var eh = Object.defineProperty({}, "passive", {
      get: function() {
        return Kv = !0, !0;
      }
    });
    window.addEventListener("test", eh, eh), window.removeEventListener("test", eh, eh);
  } catch {
    Kv = !1;
  }
var Ys = Kv ? { passive: !1 } : !1, a$ = function(e) {
  return e.tagName === "TEXTAREA";
}, qM = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !a$(e) && n[t] === "visible")
  );
}, s$ = function(e) {
  return qM(e, "overflowY");
}, l$ = function(e) {
  return qM(e, "overflowX");
}, fk = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var o = GM(e, r);
    if (o) {
      var a = YM(e, r), s = a[1], u = a[2];
      if (s > u)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, u$ = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, c$ = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, GM = function(e, t) {
  return e === "v" ? s$(t) : l$(t);
}, YM = function(e, t) {
  return e === "v" ? u$(t) : c$(t);
}, f$ = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, d$ = function(e, t, n, r, o) {
  var a = f$(e, window.getComputedStyle(t).direction), s = a * r, u = n.target, c = t.contains(u), f = !1, h = s > 0, p = 0, g = 0;
  do {
    if (!u)
      break;
    var y = YM(e, u), w = y[0], v = y[1], S = y[2], E = v - S - a * w;
    (w || E) && GM(e, u) && (p += E, g += w);
    var A = u.parentNode;
    u = A && A.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? A.host : A;
  } while (
    // portaled content
    !c && u !== document.body || // self content
    c && (t.contains(u) || t === u)
  );
  return (h && Math.abs(p) < 1 || !h && Math.abs(g) < 1) && (f = !0), f;
}, th = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, dk = function(e) {
  return [e.deltaX, e.deltaY];
}, hk = function(e) {
  return e && "current" in e ? e.current : e;
}, h$ = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, p$ = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, m$ = 0, Ws = [];
function g$(e) {
  var t = _.useRef([]), n = _.useRef([0, 0]), r = _.useRef(), o = _.useState(m$++)[0], a = _.useState(UM)[0], s = _.useRef(e);
  _.useEffect(function() {
    s.current = e;
  }, [e]), _.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(o));
      var v = jh([e.lockRef.current], (e.shards || []).map(hk), !0).filter(Boolean);
      return v.forEach(function(S) {
        return S.classList.add("allow-interactivity-".concat(o));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(o)), v.forEach(function(S) {
          return S.classList.remove("allow-interactivity-".concat(o));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var u = _.useCallback(function(v, S) {
    if ("touches" in v && v.touches.length === 2 || v.type === "wheel" && v.ctrlKey)
      return !s.current.allowPinchZoom;
    var E = th(v), A = n.current, k = "deltaX" in v ? v.deltaX : A[0] - E[0], T = "deltaY" in v ? v.deltaY : A[1] - E[1], R, N = v.target, j = Math.abs(k) > Math.abs(T) ? "h" : "v";
    if ("touches" in v && j === "h" && N.type === "range")
      return !1;
    var z = fk(j, N);
    if (!z)
      return !0;
    if (z ? R = j : (R = j === "v" ? "h" : "v", z = fk(j, N)), !z)
      return !1;
    if (!r.current && "changedTouches" in v && (k || T) && (r.current = R), !R)
      return !0;
    var B = r.current || R;
    return d$(B, S, v, B === "h" ? k : T);
  }, []), c = _.useCallback(function(v) {
    var S = v;
    if (!(!Ws.length || Ws[Ws.length - 1] !== a)) {
      var E = "deltaY" in S ? dk(S) : th(S), A = t.current.filter(function(R) {
        return R.name === S.type && (R.target === S.target || S.target === R.shadowParent) && h$(R.delta, E);
      })[0];
      if (A && A.should) {
        S.cancelable && S.preventDefault();
        return;
      }
      if (!A) {
        var k = (s.current.shards || []).map(hk).filter(Boolean).filter(function(R) {
          return R.contains(S.target);
        }), T = k.length > 0 ? u(S, k[0]) : !s.current.noIsolation;
        T && S.cancelable && S.preventDefault();
      }
    }
  }, []), f = _.useCallback(function(v, S, E, A) {
    var k = { name: v, delta: S, target: E, should: A, shadowParent: y$(E) };
    t.current.push(k), setTimeout(function() {
      t.current = t.current.filter(function(T) {
        return T !== k;
      });
    }, 1);
  }, []), h = _.useCallback(function(v) {
    n.current = th(v), r.current = void 0;
  }, []), p = _.useCallback(function(v) {
    f(v.type, dk(v), v.target, u(v, e.lockRef.current));
  }, []), g = _.useCallback(function(v) {
    f(v.type, th(v), v.target, u(v, e.lockRef.current));
  }, []);
  _.useEffect(function() {
    return Ws.push(a), e.setCallbacks({
      onScrollCapture: p,
      onWheelCapture: p,
      onTouchMoveCapture: g
    }), document.addEventListener("wheel", c, Ys), document.addEventListener("touchmove", c, Ys), document.addEventListener("touchstart", h, Ys), function() {
      Ws = Ws.filter(function(v) {
        return v !== a;
      }), document.removeEventListener("wheel", c, Ys), document.removeEventListener("touchmove", c, Ys), document.removeEventListener("touchstart", h, Ys);
    };
  }, []);
  var y = e.removeScrollBar, w = e.inert;
  return _.createElement(
    _.Fragment,
    null,
    w ? _.createElement(a, { styles: p$(o) }) : null,
    y ? _.createElement(i$, { noRelative: e.noRelative, gapMode: e.gapMode }) : null
  );
}
function y$(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const v$ = G8(VM, g$);
var um = _.forwardRef(function(e, t) {
  return _.createElement(lm, so({}, e, { ref: t, sideCar: v$ }));
});
um.classNames = lm.classNames;
var b$ = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, Xs = /* @__PURE__ */ new WeakMap(), nh = /* @__PURE__ */ new WeakMap(), rh = {}, Ly = 0, WM = function(e) {
  return e && (e.host || WM(e.parentNode));
}, x$ = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = WM(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, w$ = function(e, t, n, r) {
  var o = x$(t, Array.isArray(e) ? e : [e]);
  rh[n] || (rh[n] = /* @__PURE__ */ new WeakMap());
  var a = rh[n], s = [], u = /* @__PURE__ */ new Set(), c = new Set(o), f = function(p) {
    !p || u.has(p) || (u.add(p), f(p.parentNode));
  };
  o.forEach(f);
  var h = function(p) {
    !p || c.has(p) || Array.prototype.forEach.call(p.children, function(g) {
      if (u.has(g))
        h(g);
      else
        try {
          var y = g.getAttribute(r), w = y !== null && y !== "false", v = (Xs.get(g) || 0) + 1, S = (a.get(g) || 0) + 1;
          Xs.set(g, v), a.set(g, S), s.push(g), v === 1 && w && nh.set(g, !0), S === 1 && g.setAttribute(n, "true"), w || g.setAttribute(r, "true");
        } catch (E) {
          console.error("aria-hidden: cannot operate on ", g, E);
        }
    });
  };
  return h(t), u.clear(), Ly++, function() {
    s.forEach(function(p) {
      var g = Xs.get(p) - 1, y = a.get(p) - 1;
      Xs.set(p, g), a.set(p, y), g || (nh.has(p) || p.removeAttribute(r), nh.delete(p)), y || p.removeAttribute(n);
    }), Ly--, Ly || (Xs = /* @__PURE__ */ new WeakMap(), Xs = /* @__PURE__ */ new WeakMap(), nh = /* @__PURE__ */ new WeakMap(), rh = {});
  };
}, O1 = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), o = b$(e);
  return o ? (r.push.apply(r, Array.from(o.querySelectorAll("[aria-live], script"))), w$(r, o, n, "aria-hidden")) : function() {
    return null;
  };
}, cm = "Dialog", [XM, Ype] = _o(cm), [_$, Hr] = XM(cm), KM = (e) => {
  const {
    __scopeDialog: t,
    children: n,
    open: r,
    defaultOpen: o,
    onOpenChange: a,
    modal: s = !0
  } = e, u = _.useRef(null), c = _.useRef(null), [f, h] = sa({
    prop: r,
    defaultProp: o ?? !1,
    onChange: a,
    caller: cm
  });
  return /* @__PURE__ */ b.jsx(
    _$,
    {
      scope: t,
      triggerRef: u,
      contentRef: c,
      contentId: po(),
      titleId: po(),
      descriptionId: po(),
      open: f,
      onOpenChange: h,
      onOpenToggle: _.useCallback(() => h((p) => !p), [h]),
      modal: s,
      children: n
    }
  );
};
KM.displayName = cm;
var ZM = "DialogTrigger", QM = _.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = Hr(ZM, n), a = bt(t, o.triggerRef);
    return /* @__PURE__ */ b.jsx(
      qe.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": o.open,
        "aria-controls": o.contentId,
        "data-state": j1(o.open),
        ...r,
        ref: a,
        onClick: xe(e.onClick, o.onOpenToggle)
      }
    );
  }
);
QM.displayName = ZM;
var N1 = "DialogPortal", [S$, JM] = XM(N1, {
  forceMount: void 0
}), eO = (e) => {
  const { __scopeDialog: t, forceMount: n, children: r, container: o } = e, a = Hr(N1, t);
  return /* @__PURE__ */ b.jsx(S$, { scope: t, forceMount: n, children: _.Children.map(r, (s) => /* @__PURE__ */ b.jsx(Br, { present: n || a.open, children: /* @__PURE__ */ b.jsx(sm, { asChild: !0, container: o, children: s }) })) });
};
eO.displayName = N1;
var tp = "DialogOverlay", tO = _.forwardRef(
  (e, t) => {
    const n = JM(tp, e.__scopeDialog), { forceMount: r = n.forceMount, ...o } = e, a = Hr(tp, e.__scopeDialog);
    return a.modal ? /* @__PURE__ */ b.jsx(Br, { present: r || a.open, children: /* @__PURE__ */ b.jsx(C$, { ...o, ref: t }) }) : null;
  }
);
tO.displayName = tp;
var E$ = /* @__PURE__ */ xl("DialogOverlay.RemoveScroll"), C$ = _.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = Hr(tp, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ b.jsx(um, { as: E$, allowPinchZoom: !0, shards: [o.contentRef], children: /* @__PURE__ */ b.jsx(
        qe.div,
        {
          "data-state": j1(o.open),
          ...r,
          ref: t,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), Ua = "DialogContent", nO = _.forwardRef(
  (e, t) => {
    const n = JM(Ua, e.__scopeDialog), { forceMount: r = n.forceMount, ...o } = e, a = Hr(Ua, e.__scopeDialog);
    return /* @__PURE__ */ b.jsx(Br, { present: r || a.open, children: a.modal ? /* @__PURE__ */ b.jsx(k$, { ...o, ref: t }) : /* @__PURE__ */ b.jsx(T$, { ...o, ref: t }) });
  }
);
nO.displayName = Ua;
var k$ = _.forwardRef(
  (e, t) => {
    const n = Hr(Ua, e.__scopeDialog), r = _.useRef(null), o = bt(t, n.contentRef, r);
    return _.useEffect(() => {
      const a = r.current;
      if (a) return O1(a);
    }, []), /* @__PURE__ */ b.jsx(
      rO,
      {
        ...e,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: xe(e.onCloseAutoFocus, (a) => {
          a.preventDefault(), n.triggerRef.current?.focus();
        }),
        onPointerDownOutside: xe(e.onPointerDownOutside, (a) => {
          const s = a.detail.originalEvent, u = s.button === 0 && s.ctrlKey === !0;
          (s.button === 2 || u) && a.preventDefault();
        }),
        onFocusOutside: xe(
          e.onFocusOutside,
          (a) => a.preventDefault()
        )
      }
    );
  }
), T$ = _.forwardRef(
  (e, t) => {
    const n = Hr(Ua, e.__scopeDialog), r = _.useRef(!1), o = _.useRef(!1);
    return /* @__PURE__ */ b.jsx(
      rO,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (a) => {
          e.onCloseAutoFocus?.(a), a.defaultPrevented || (r.current || n.triggerRef.current?.focus(), a.preventDefault()), r.current = !1, o.current = !1;
        },
        onInteractOutside: (a) => {
          e.onInteractOutside?.(a), a.defaultPrevented || (r.current = !0, a.detail.originalEvent.type === "pointerdown" && (o.current = !0));
          const s = a.target;
          n.triggerRef.current?.contains(s) && a.preventDefault(), a.detail.originalEvent.type === "focusin" && o.current && a.preventDefault();
        }
      }
    );
  }
), rO = _.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: o, onCloseAutoFocus: a, ...s } = e, u = Hr(Ua, n), c = _.useRef(null), f = bt(t, c);
    return M1(), /* @__PURE__ */ b.jsxs(b.Fragment, { children: [
      /* @__PURE__ */ b.jsx(
        am,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: o,
          onUnmountAutoFocus: a,
          children: /* @__PURE__ */ b.jsx(
            of,
            {
              role: "dialog",
              id: u.contentId,
              "aria-describedby": u.descriptionId,
              "aria-labelledby": u.titleId,
              "data-state": j1(u.open),
              ...s,
              ref: f,
              onDismiss: () => u.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ b.jsxs(b.Fragment, { children: [
        /* @__PURE__ */ b.jsx(A$, { titleId: u.titleId }),
        /* @__PURE__ */ b.jsx(M$, { contentRef: c, descriptionId: u.descriptionId })
      ] })
    ] });
  }
), D1 = "DialogTitle", oO = _.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = Hr(D1, n);
    return /* @__PURE__ */ b.jsx(qe.h2, { id: o.titleId, ...r, ref: t });
  }
);
oO.displayName = D1;
var iO = "DialogDescription", aO = _.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = Hr(iO, n);
    return /* @__PURE__ */ b.jsx(qe.p, { id: o.descriptionId, ...r, ref: t });
  }
);
aO.displayName = iO;
var sO = "DialogClose", lO = _.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, o = Hr(sO, n);
    return /* @__PURE__ */ b.jsx(
      qe.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: xe(e.onClick, () => o.onOpenChange(!1))
      }
    );
  }
);
lO.displayName = sO;
function j1(e) {
  return e ? "open" : "closed";
}
var uO = "DialogTitleWarning", [Wpe, cO] = i8(uO, {
  contentName: Ua,
  titleName: D1,
  docsSlug: "dialog"
}), A$ = ({ titleId: e }) => {
  const t = cO(uO), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return _.useEffect(() => {
    e && (document.getElementById(e) || console.error(n));
  }, [n, e]), null;
}, R$ = "DialogDescriptionWarning", M$ = ({ contentRef: e, descriptionId: t }) => {
  const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${cO(R$).contentName}}.`;
  return _.useEffect(() => {
    const o = e.current?.getAttribute("aria-describedby");
    t && o && (document.getElementById(t) || console.warn(r));
  }, [r, e, t]), null;
}, O$ = KM, N$ = QM, D$ = eO, j$ = tO, P$ = nO, I$ = oO, z$ = aO, fO = lO;
/*!
 * Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2025 Fonticons, Inc.
 */
function Zv(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function L$(e) {
  if (Array.isArray(e)) return e;
}
function F$(e) {
  if (Array.isArray(e)) return Zv(e);
}
function $$(e, t) {
  if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
}
function B$(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, dO(r.key), r);
  }
}
function H$(e, t, n) {
  return t && B$(e.prototype, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function zh(e, t) {
  var n = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (!n) {
    if (Array.isArray(e) || (n = P1(e)) || t) {
      n && (e = n);
      var r = 0, o = function() {
      };
      return {
        s: o,
        n: function() {
          return r >= e.length ? {
            done: !0
          } : {
            done: !1,
            value: e[r++]
          };
        },
        e: function(c) {
          throw c;
        },
        f: o
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var a, s = !0, u = !1;
  return {
    s: function() {
      n = n.call(e);
    },
    n: function() {
      var c = n.next();
      return s = c.done, c;
    },
    e: function(c) {
      u = !0, a = c;
    },
    f: function() {
      try {
        s || n.return == null || n.return();
      } finally {
        if (u) throw a;
      }
    }
  };
}
function Ke(e, t, n) {
  return (t = dO(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function V$(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function U$(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r, o, a, s, u = [], c = !0, f = !1;
    try {
      if (a = (n = n.call(e)).next, t === 0) {
        if (Object(n) !== n) return;
        c = !1;
      } else for (; !(c = (r = a.call(n)).done) && (u.push(r.value), u.length !== t); c = !0) ;
    } catch (h) {
      f = !0, o = h;
    } finally {
      try {
        if (!c && n.return != null && (s = n.return(), Object(s) !== s)) return;
      } finally {
        if (f) throw o;
      }
    }
    return u;
  }
}
function q$() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function G$() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function pk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ge(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pk(Object(n), !0).forEach(function(r) {
      Ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function fm(e, t) {
  return L$(e) || U$(e, t) || P1(e, t) || q$();
}
function Lr(e) {
  return F$(e) || V$(e) || P1(e) || G$();
}
function Y$(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function dO(e) {
  var t = Y$(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function np(e) {
  "@babel/helpers - typeof";
  return np = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, np(e);
}
function P1(e, t) {
  if (e) {
    if (typeof e == "string") return Zv(e, t);
    var n = {}.toString.call(e).slice(8, -1);
    return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Zv(e, t) : void 0;
  }
}
var mk = function() {
}, I1 = {}, hO = {}, pO = null, mO = {
  mark: mk,
  measure: mk
};
try {
  typeof window < "u" && (I1 = window), typeof document < "u" && (hO = document), typeof MutationObserver < "u" && (pO = MutationObserver), typeof performance < "u" && (mO = performance);
} catch {
}
var W$ = I1.navigator || {}, gk = W$.userAgent, yk = gk === void 0 ? "" : gk, ta = I1, _t = hO, vk = pO, oh = mO;
ta.document;
var ui = !!_t.documentElement && !!_t.head && typeof _t.addEventListener == "function" && typeof _t.createElement == "function", gO = ~yk.indexOf("MSIE") || ~yk.indexOf("Trident/"), Fy, X$ = /fa(k|kd|s|r|l|t|d|dr|dl|dt|b|slr|slpr|wsb|tl|ns|nds|es|jr|jfr|jdr|cr|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/, K$ = /Font ?Awesome ?([567 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit|Notdog Duo|Notdog|Chisel|Etch|Thumbprint|Jelly Fill|Jelly Duo|Jelly|Slab Press|Slab|Whiteboard)?.*/i, yO = {
  classic: {
    fa: "solid",
    fas: "solid",
    "fa-solid": "solid",
    far: "regular",
    "fa-regular": "regular",
    fal: "light",
    "fa-light": "light",
    fat: "thin",
    "fa-thin": "thin",
    fab: "brands",
    "fa-brands": "brands"
  },
  duotone: {
    fa: "solid",
    fad: "solid",
    "fa-solid": "solid",
    "fa-duotone": "solid",
    fadr: "regular",
    "fa-regular": "regular",
    fadl: "light",
    "fa-light": "light",
    fadt: "thin",
    "fa-thin": "thin"
  },
  sharp: {
    fa: "solid",
    fass: "solid",
    "fa-solid": "solid",
    fasr: "regular",
    "fa-regular": "regular",
    fasl: "light",
    "fa-light": "light",
    fast: "thin",
    "fa-thin": "thin"
  },
  "sharp-duotone": {
    fa: "solid",
    fasds: "solid",
    "fa-solid": "solid",
    fasdr: "regular",
    "fa-regular": "regular",
    fasdl: "light",
    "fa-light": "light",
    fasdt: "thin",
    "fa-thin": "thin"
  },
  slab: {
    "fa-regular": "regular",
    faslr: "regular"
  },
  "slab-press": {
    "fa-regular": "regular",
    faslpr: "regular"
  },
  thumbprint: {
    "fa-light": "light",
    fatl: "light"
  },
  whiteboard: {
    "fa-semibold": "semibold",
    fawsb: "semibold"
  },
  notdog: {
    "fa-solid": "solid",
    fans: "solid"
  },
  "notdog-duo": {
    "fa-solid": "solid",
    fands: "solid"
  },
  etch: {
    "fa-solid": "solid",
    faes: "solid"
  },
  jelly: {
    "fa-regular": "regular",
    fajr: "regular"
  },
  "jelly-fill": {
    "fa-regular": "regular",
    fajfr: "regular"
  },
  "jelly-duo": {
    "fa-regular": "regular",
    fajdr: "regular"
  },
  chisel: {
    "fa-regular": "regular",
    facr: "regular"
  }
}, Z$ = {
  GROUP: "duotone-group",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, vO = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone", "fa-thumbprint", "fa-whiteboard", "fa-notdog", "fa-notdog-duo", "fa-chisel", "fa-etch", "fa-jelly", "fa-jelly-fill", "fa-jelly-duo", "fa-slab", "fa-slab-press"], bn = "classic", af = "duotone", bO = "sharp", xO = "sharp-duotone", wO = "chisel", _O = "etch", SO = "jelly", EO = "jelly-duo", CO = "jelly-fill", kO = "notdog", TO = "notdog-duo", AO = "slab", RO = "slab-press", MO = "thumbprint", OO = "whiteboard", Q$ = "Classic", J$ = "Duotone", e7 = "Sharp", t7 = "Sharp Duotone", n7 = "Chisel", r7 = "Etch", o7 = "Jelly", i7 = "Jelly Duo", a7 = "Jelly Fill", s7 = "Notdog", l7 = "Notdog Duo", u7 = "Slab", c7 = "Slab Press", f7 = "Thumbprint", d7 = "Whiteboard", NO = [bn, af, bO, xO, wO, _O, SO, EO, CO, kO, TO, AO, RO, MO, OO];
Fy = {}, Ke(Ke(Ke(Ke(Ke(Ke(Ke(Ke(Ke(Ke(Fy, bn, Q$), af, J$), bO, e7), xO, t7), wO, n7), _O, r7), SO, o7), EO, i7), CO, a7), kO, s7), Ke(Ke(Ke(Ke(Ke(Fy, TO, l7), AO, u7), RO, c7), MO, f7), OO, d7);
var h7 = {
  classic: {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  duotone: {
    900: "fad",
    400: "fadr",
    300: "fadl",
    100: "fadt"
  },
  sharp: {
    900: "fass",
    400: "fasr",
    300: "fasl",
    100: "fast"
  },
  "sharp-duotone": {
    900: "fasds",
    400: "fasdr",
    300: "fasdl",
    100: "fasdt"
  },
  slab: {
    400: "faslr"
  },
  "slab-press": {
    400: "faslpr"
  },
  whiteboard: {
    600: "fawsb"
  },
  thumbprint: {
    300: "fatl"
  },
  notdog: {
    900: "fans"
  },
  "notdog-duo": {
    900: "fands"
  },
  etch: {
    900: "faes"
  },
  chisel: {
    400: "facr"
  },
  jelly: {
    400: "fajr"
  },
  "jelly-fill": {
    400: "fajfr"
  },
  "jelly-duo": {
    400: "fajdr"
  }
}, p7 = {
  "Font Awesome 7 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 7 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal",
    100: "fat"
  },
  "Font Awesome 7 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 7 Duotone": {
    900: "fad",
    400: "fadr",
    normal: "fadr",
    300: "fadl",
    100: "fadt"
  },
  "Font Awesome 7 Sharp": {
    900: "fass",
    400: "fasr",
    normal: "fasr",
    300: "fasl",
    100: "fast"
  },
  "Font Awesome 7 Sharp Duotone": {
    900: "fasds",
    400: "fasdr",
    normal: "fasdr",
    300: "fasdl",
    100: "fasdt"
  },
  "Font Awesome 7 Jelly": {
    400: "fajr",
    normal: "fajr"
  },
  "Font Awesome 7 Jelly Fill": {
    400: "fajfr",
    normal: "fajfr"
  },
  "Font Awesome 7 Jelly Duo": {
    400: "fajdr",
    normal: "fajdr"
  },
  "Font Awesome 7 Slab": {
    400: "faslr",
    normal: "faslr"
  },
  "Font Awesome 7 Slab Press": {
    400: "faslpr",
    normal: "faslpr"
  },
  "Font Awesome 7 Thumbprint": {
    300: "fatl",
    normal: "fatl"
  },
  "Font Awesome 7 Notdog": {
    900: "fans",
    normal: "fans"
  },
  "Font Awesome 7 Notdog Duo": {
    900: "fands",
    normal: "fands"
  },
  "Font Awesome 7 Etch": {
    900: "faes",
    normal: "faes"
  },
  "Font Awesome 7 Chisel": {
    400: "facr",
    normal: "facr"
  },
  "Font Awesome 7 Whiteboard": {
    600: "fawsb",
    normal: "fawsb"
  }
}, m7 = /* @__PURE__ */ new Map([["classic", {
  defaultShortPrefixId: "fas",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin", "brands"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["duotone", {
  defaultShortPrefixId: "fad",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp", {
  defaultShortPrefixId: "fass",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["sharp-duotone", {
  defaultShortPrefixId: "fasds",
  defaultStyleId: "solid",
  styleIds: ["solid", "regular", "light", "thin"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["chisel", {
  defaultShortPrefixId: "facr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["etch", {
  defaultShortPrefixId: "faes",
  defaultStyleId: "solid",
  styleIds: ["solid"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["jelly", {
  defaultShortPrefixId: "fajr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["jelly-duo", {
  defaultShortPrefixId: "fajdr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["jelly-fill", {
  defaultShortPrefixId: "fajfr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["notdog", {
  defaultShortPrefixId: "fans",
  defaultStyleId: "solid",
  styleIds: ["solid"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["notdog-duo", {
  defaultShortPrefixId: "fands",
  defaultStyleId: "solid",
  styleIds: ["solid"],
  futureStyleIds: [],
  defaultFontWeight: 900
}], ["slab", {
  defaultShortPrefixId: "faslr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["slab-press", {
  defaultShortPrefixId: "faslpr",
  defaultStyleId: "regular",
  styleIds: ["regular"],
  futureStyleIds: [],
  defaultFontWeight: 400
}], ["thumbprint", {
  defaultShortPrefixId: "fatl",
  defaultStyleId: "light",
  styleIds: ["light"],
  futureStyleIds: [],
  defaultFontWeight: 300
}], ["whiteboard", {
  defaultShortPrefixId: "fawsb",
  defaultStyleId: "semibold",
  styleIds: ["semibold"],
  futureStyleIds: [],
  defaultFontWeight: 600
}]]), g7 = {
  chisel: {
    regular: "facr"
  },
  classic: {
    brands: "fab",
    light: "fal",
    regular: "far",
    solid: "fas",
    thin: "fat"
  },
  duotone: {
    light: "fadl",
    regular: "fadr",
    solid: "fad",
    thin: "fadt"
  },
  etch: {
    solid: "faes"
  },
  jelly: {
    regular: "fajr"
  },
  "jelly-duo": {
    regular: "fajdr"
  },
  "jelly-fill": {
    regular: "fajfr"
  },
  notdog: {
    solid: "fans"
  },
  "notdog-duo": {
    solid: "fands"
  },
  sharp: {
    light: "fasl",
    regular: "fasr",
    solid: "fass",
    thin: "fast"
  },
  "sharp-duotone": {
    light: "fasdl",
    regular: "fasdr",
    solid: "fasds",
    thin: "fasdt"
  },
  slab: {
    regular: "faslr"
  },
  "slab-press": {
    regular: "faslpr"
  },
  thumbprint: {
    light: "fatl"
  },
  whiteboard: {
    semibold: "fawsb"
  }
}, DO = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], bk = {
  kit: {
    fak: "kit",
    "fa-kit": "kit"
  },
  "kit-duotone": {
    fakd: "kit-duotone",
    "fa-kit-duotone": "kit-duotone"
  }
}, y7 = ["kit"], v7 = "kit", b7 = "kit-duotone", x7 = "Kit", w7 = "Kit Duotone";
Ke(Ke({}, v7, x7), b7, w7);
var _7 = {
  kit: {
    "fa-kit": "fak"
  }
}, S7 = {
  "Font Awesome Kit": {
    400: "fak",
    normal: "fak"
  },
  "Font Awesome Kit Duotone": {
    400: "fakd",
    normal: "fakd"
  }
}, E7 = {
  kit: {
    fak: "fa-kit"
  }
}, xk = {
  kit: {
    kit: "fak"
  },
  "kit-duotone": {
    "kit-duotone": "fakd"
  }
}, $y, ih = {
  GROUP: "duotone-group",
  SWAP_OPACITY: "swap-opacity",
  PRIMARY: "primary",
  SECONDARY: "secondary"
}, C7 = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone", "fa-thumbprint", "fa-whiteboard", "fa-notdog", "fa-notdog-duo", "fa-chisel", "fa-etch", "fa-jelly", "fa-jelly-fill", "fa-jelly-duo", "fa-slab", "fa-slab-press"], k7 = "classic", T7 = "duotone", A7 = "sharp", R7 = "sharp-duotone", M7 = "chisel", O7 = "etch", N7 = "jelly", D7 = "jelly-duo", j7 = "jelly-fill", P7 = "notdog", I7 = "notdog-duo", z7 = "slab", L7 = "slab-press", F7 = "thumbprint", $7 = "whiteboard", B7 = "Classic", H7 = "Duotone", V7 = "Sharp", U7 = "Sharp Duotone", q7 = "Chisel", G7 = "Etch", Y7 = "Jelly", W7 = "Jelly Duo", X7 = "Jelly Fill", K7 = "Notdog", Z7 = "Notdog Duo", Q7 = "Slab", J7 = "Slab Press", eB = "Thumbprint", tB = "Whiteboard";
$y = {}, Ke(Ke(Ke(Ke(Ke(Ke(Ke(Ke(Ke(Ke($y, k7, B7), T7, H7), A7, V7), R7, U7), M7, q7), O7, G7), N7, Y7), D7, W7), j7, X7), P7, K7), Ke(Ke(Ke(Ke(Ke($y, I7, Z7), z7, Q7), L7, J7), F7, eB), $7, tB);
var nB = "kit", rB = "kit-duotone", oB = "Kit", iB = "Kit Duotone";
Ke(Ke({}, nB, oB), rB, iB);
var aB = {
  classic: {
    "fa-brands": "fab",
    "fa-duotone": "fad",
    "fa-light": "fal",
    "fa-regular": "far",
    "fa-solid": "fas",
    "fa-thin": "fat"
  },
  duotone: {
    "fa-regular": "fadr",
    "fa-light": "fadl",
    "fa-thin": "fadt"
  },
  sharp: {
    "fa-solid": "fass",
    "fa-regular": "fasr",
    "fa-light": "fasl",
    "fa-thin": "fast"
  },
  "sharp-duotone": {
    "fa-solid": "fasds",
    "fa-regular": "fasdr",
    "fa-light": "fasdl",
    "fa-thin": "fasdt"
  },
  slab: {
    "fa-regular": "faslr"
  },
  "slab-press": {
    "fa-regular": "faslpr"
  },
  whiteboard: {
    "fa-semibold": "fawsb"
  },
  thumbprint: {
    "fa-light": "fatl"
  },
  notdog: {
    "fa-solid": "fans"
  },
  "notdog-duo": {
    "fa-solid": "fands"
  },
  etch: {
    "fa-solid": "faes"
  },
  jelly: {
    "fa-regular": "fajr"
  },
  "jelly-fill": {
    "fa-regular": "fajfr"
  },
  "jelly-duo": {
    "fa-regular": "fajdr"
  },
  chisel: {
    "fa-regular": "facr"
  }
}, sB = {
  classic: ["fas", "far", "fal", "fat", "fad"],
  duotone: ["fadr", "fadl", "fadt"],
  sharp: ["fass", "fasr", "fasl", "fast"],
  "sharp-duotone": ["fasds", "fasdr", "fasdl", "fasdt"],
  slab: ["faslr"],
  "slab-press": ["faslpr"],
  whiteboard: ["fawsb"],
  thumbprint: ["fatl"],
  notdog: ["fans"],
  "notdog-duo": ["fands"],
  etch: ["faes"],
  jelly: ["fajr"],
  "jelly-fill": ["fajfr"],
  "jelly-duo": ["fajdr"],
  chisel: ["facr"]
}, Qv = {
  classic: {
    fab: "fa-brands",
    fad: "fa-duotone",
    fal: "fa-light",
    far: "fa-regular",
    fas: "fa-solid",
    fat: "fa-thin"
  },
  duotone: {
    fadr: "fa-regular",
    fadl: "fa-light",
    fadt: "fa-thin"
  },
  sharp: {
    fass: "fa-solid",
    fasr: "fa-regular",
    fasl: "fa-light",
    fast: "fa-thin"
  },
  "sharp-duotone": {
    fasds: "fa-solid",
    fasdr: "fa-regular",
    fasdl: "fa-light",
    fasdt: "fa-thin"
  },
  slab: {
    faslr: "fa-regular"
  },
  "slab-press": {
    faslpr: "fa-regular"
  },
  whiteboard: {
    fawsb: "fa-semibold"
  },
  thumbprint: {
    fatl: "fa-light"
  },
  notdog: {
    fans: "fa-solid"
  },
  "notdog-duo": {
    fands: "fa-solid"
  },
  etch: {
    faes: "fa-solid"
  },
  jelly: {
    fajr: "fa-regular"
  },
  "jelly-fill": {
    fajfr: "fa-regular"
  },
  "jelly-duo": {
    fajdr: "fa-regular"
  },
  chisel: {
    facr: "fa-regular"
  }
}, lB = ["fa-solid", "fa-regular", "fa-light", "fa-thin", "fa-duotone", "fa-brands", "fa-semibold"], jO = ["fa", "fas", "far", "fal", "fat", "fad", "fadr", "fadl", "fadt", "fab", "fass", "fasr", "fasl", "fast", "fasds", "fasdr", "fasdl", "fasdt", "faslr", "faslpr", "fawsb", "fatl", "fans", "fands", "faes", "fajr", "fajfr", "fajdr", "facr"].concat(C7, lB), uB = ["solid", "regular", "light", "thin", "duotone", "brands", "semibold"], PO = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], cB = PO.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), fB = ["aw", "fw", "pull-left", "pull-right"], dB = [].concat(Lr(Object.keys(sB)), uB, fB, ["2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "inverse", "layers", "layers-bottom-left", "layers-bottom-right", "layers-counter", "layers-text", "layers-top-left", "layers-top-right", "li", "pull-end", "pull-start", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", "width-auto", "width-fixed", ih.GROUP, ih.SWAP_OPACITY, ih.PRIMARY, ih.SECONDARY]).concat(PO.map(function(e) {
  return "".concat(e, "x");
})).concat(cB.map(function(e) {
  return "w-".concat(e);
})), hB = {
  "Font Awesome 5 Free": {
    900: "fas",
    400: "far"
  },
  "Font Awesome 5 Pro": {
    900: "fas",
    400: "far",
    normal: "far",
    300: "fal"
  },
  "Font Awesome 5 Brands": {
    400: "fab",
    normal: "fab"
  },
  "Font Awesome 5 Duotone": {
    900: "fad"
  }
}, ri = "___FONT_AWESOME___", Jv = 16, IO = "fa", zO = "svg-inline--fa", qa = "data-fa-i2svg", eb = "data-fa-pseudo-element", pB = "data-fa-pseudo-element-pending", z1 = "data-prefix", L1 = "data-icon", wk = "fontawesome-i2svg", mB = "async", gB = ["HTML", "HEAD", "STYLE", "SCRIPT"], LO = ["::before", "::after", ":before", ":after"], FO = function() {
  try {
    return !0;
  } catch {
    return !1;
  }
}();
function sf(e) {
  return new Proxy(e, {
    get: function(n, r) {
      return r in n ? n[r] : n[bn];
    }
  });
}
var $O = ge({}, yO);
$O[bn] = ge(ge(ge(ge({}, {
  "fa-duotone": "duotone"
}), yO[bn]), bk.kit), bk["kit-duotone"]);
var yB = sf($O), tb = ge({}, g7);
tb[bn] = ge(ge(ge(ge({}, {
  duotone: "fad"
}), tb[bn]), xk.kit), xk["kit-duotone"]);
var _k = sf(tb), nb = ge({}, Qv);
nb[bn] = ge(ge({}, nb[bn]), E7.kit);
var BO = sf(nb), rb = ge({}, aB);
rb[bn] = ge(ge({}, rb[bn]), _7.kit);
sf(rb);
var vB = X$, HO = "fa-layers-text", bB = K$, xB = ge({}, h7);
sf(xB);
var wB = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"], By = Z$, _B = [].concat(Lr(y7), Lr(dB)), bc = ta.FontAwesomeConfig || {};
function SB(e) {
  var t = _t.querySelector("script[" + e + "]");
  if (t)
    return t.getAttribute(e);
}
function EB(e) {
  return e === "" ? !0 : e === "false" ? !1 : e === "true" ? !0 : e;
}
if (_t && typeof _t.querySelector == "function") {
  var CB = [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-search-pseudo-elements-warnings", "searchPseudoElementsWarnings"], ["data-search-pseudo-elements-full-scan", "searchPseudoElementsFullScan"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
  CB.forEach(function(e) {
    var t = fm(e, 2), n = t[0], r = t[1], o = EB(SB(n));
    o != null && (bc[r] = o);
  });
}
var VO = {
  styleDefault: "solid",
  familyDefault: bn,
  cssPrefix: IO,
  replacementClass: zO,
  autoReplaceSvg: !0,
  autoAddCss: !0,
  searchPseudoElements: !1,
  searchPseudoElementsWarnings: !0,
  searchPseudoElementsFullScan: !1,
  observeMutations: !0,
  mutateApproach: "async",
  keepOriginalSource: !0,
  measurePerformance: !1,
  showMissingIcons: !0
};
bc.familyPrefix && (bc.cssPrefix = bc.familyPrefix);
var wl = ge(ge({}, VO), bc);
wl.autoReplaceSvg || (wl.observeMutations = !1);
var Ae = {};
Object.keys(VO).forEach(function(e) {
  Object.defineProperty(Ae, e, {
    enumerable: !0,
    set: function(n) {
      wl[e] = n, xc.forEach(function(r) {
        return r(Ae);
      });
    },
    get: function() {
      return wl[e];
    }
  });
});
Object.defineProperty(Ae, "familyPrefix", {
  enumerable: !0,
  set: function(t) {
    wl.cssPrefix = t, xc.forEach(function(n) {
      return n(Ae);
    });
  },
  get: function() {
    return wl.cssPrefix;
  }
});
ta.FontAwesomeConfig = Ae;
var xc = [];
function kB(e) {
  return xc.push(e), function() {
    xc.splice(xc.indexOf(e), 1);
  };
}
var Ks = Jv, lo = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: !1,
  flipY: !1
};
function TB(e) {
  if (!(!e || !ui)) {
    var t = _t.createElement("style");
    t.setAttribute("type", "text/css"), t.innerHTML = e;
    for (var n = _t.head.childNodes, r = null, o = n.length - 1; o > -1; o--) {
      var a = n[o], s = (a.tagName || "").toUpperCase();
      ["STYLE", "LINK"].indexOf(s) > -1 && (r = a);
    }
    return _t.head.insertBefore(t, r), e;
  }
}
var AB = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function Sk() {
  for (var e = 12, t = ""; e-- > 0; )
    t += AB[Math.random() * 62 | 0];
  return t;
}
function Ll(e) {
  for (var t = [], n = (e || []).length >>> 0; n--; )
    t[n] = e[n];
  return t;
}
function F1(e) {
  return e.classList ? Ll(e.classList) : (e.getAttribute("class") || "").split(" ").filter(function(t) {
    return t;
  });
}
function UO(e) {
  return "".concat(e).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function RB(e) {
  return Object.keys(e || {}).reduce(function(t, n) {
    return t + "".concat(n, '="').concat(UO(e[n]), '" ');
  }, "").trim();
}
function dm(e) {
  return Object.keys(e || {}).reduce(function(t, n) {
    return t + "".concat(n, ": ").concat(e[n].trim(), ";");
  }, "");
}
function $1(e) {
  return e.size !== lo.size || e.x !== lo.x || e.y !== lo.y || e.rotate !== lo.rotate || e.flipX || e.flipY;
}
function MB(e) {
  var t = e.transform, n = e.containerWidth, r = e.iconWidth, o = {
    transform: "translate(".concat(n / 2, " 256)")
  }, a = "translate(".concat(t.x * 32, ", ").concat(t.y * 32, ") "), s = "scale(".concat(t.size / 16 * (t.flipX ? -1 : 1), ", ").concat(t.size / 16 * (t.flipY ? -1 : 1), ") "), u = "rotate(".concat(t.rotate, " 0 0)"), c = {
    transform: "".concat(a, " ").concat(s, " ").concat(u)
  }, f = {
    transform: "translate(".concat(r / 2 * -1, " -256)")
  };
  return {
    outer: o,
    inner: c,
    path: f
  };
}
function OB(e) {
  var t = e.transform, n = e.width, r = n === void 0 ? Jv : n, o = e.height, a = o === void 0 ? Jv : o, s = "";
  return gO ? s += "translate(".concat(t.x / Ks - r / 2, "em, ").concat(t.y / Ks - a / 2, "em) ") : s += "translate(calc(-50% + ".concat(t.x / Ks, "em), calc(-50% + ").concat(t.y / Ks, "em)) "), s += "scale(".concat(t.size / Ks * (t.flipX ? -1 : 1), ", ").concat(t.size / Ks * (t.flipY ? -1 : 1), ") "), s += "rotate(".concat(t.rotate, "deg) "), s;
}
var NB = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 7 Free";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 7 Free";
  --fa-font-light: normal 300 1em/1 "Font Awesome 7 Pro";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 7 Pro";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-regular: normal 400 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-light: normal 300 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-thin: normal 100 1em/1 "Font Awesome 7 Duotone";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 7 Brands";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-regular: normal 400 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-light: normal 300 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-thin: normal 100 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-slab-regular: normal 400 1em/1 "Font Awesome 7 Slab";
  --fa-font-slab-press-regular: normal 400 1em/1 "Font Awesome 7 Slab Press";
  --fa-font-whiteboard-semibold: normal 600 1em/1 "Font Awesome 7 Whiteboard";
  --fa-font-thumbprint-light: normal 300 1em/1 "Font Awesome 7 Thumbprint";
  --fa-font-notdog-solid: normal 900 1em/1 "Font Awesome 7 Notdog";
  --fa-font-notdog-duo-solid: normal 900 1em/1 "Font Awesome 7 Notdog Duo";
  --fa-font-etch-solid: normal 900 1em/1 "Font Awesome 7 Etch";
  --fa-font-jelly-regular: normal 400 1em/1 "Font Awesome 7 Jelly";
  --fa-font-jelly-fill-regular: normal 400 1em/1 "Font Awesome 7 Jelly Fill";
  --fa-font-jelly-duo-regular: normal 400 1em/1 "Font Awesome 7 Jelly Duo";
  --fa-font-chisel-regular: normal 400 1em/1 "Font Awesome 7 Chisel";
}

.svg-inline--fa {
  box-sizing: content-box;
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
  width: var(--fa-width, 1.25em);
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285714em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left,
.svg-inline--fa .fa-pull-start {
  float: inline-start;
  margin-inline-end: var(--fa-pull-margin, 0.3em);
}
.svg-inline--fa.fa-pull-right,
.svg-inline--fa .fa-pull-end {
  float: inline-end;
  margin-inline-start: var(--fa-pull-margin, 0.3em);
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  inset-inline-start: calc(-1 * var(--fa-li-width, 2em));
  inset-block-start: 0.25em; /* syncing vertical alignment with Web Font rendering */
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: var(--fa-width, 1.25em);
}
.fa-layers .svg-inline--fa {
  inset: 0;
  margin: auto;
  position: absolute;
  transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-counter-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: calc(10 / 16 * 1em); /* converts a 10px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 10 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 10 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-xs {
  font-size: calc(12 / 16 * 1em); /* converts a 12px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 12 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 12 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-sm {
  font-size: calc(14 / 16 * 1em); /* converts a 14px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 14 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 14 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-lg {
  font-size: calc(20 / 16 * 1em); /* converts a 20px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 20 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 20 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-xl {
  font-size: calc(24 / 16 * 1em); /* converts a 24px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 24 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 24 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-2xl {
  font-size: calc(32 / 16 * 1em); /* converts a 32px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 32 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 32 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-width-auto {
  --fa-width: auto;
}

.fa-fw,
.fa-width-fixed {
  --fa-width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-inline-start: var(--fa-li-margin, 2.5em);
  padding-inline-start: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  inset-inline-start: calc(-1 * var(--fa-li-width, 2em));
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

/* Heads Up: Bordered Icons will not be supported in the future!
  - This feature will be deprecated in the next major release of Font Awesome (v8)!
  - You may continue to use it in this version *v7), but it will not be supported in Font Awesome v8.
*/
/* Notes:
* --@{v.$css-prefix}-border-width = 1/16 by default (to render as ~1px based on a 16px default font-size)
* --@{v.$css-prefix}-border-padding =
  ** 3/16 for vertical padding (to give ~2px of vertical whitespace around an icon considering it's vertical alignment)
  ** 4/16 for horizontal padding (to give ~4px of horizontal whitespace around an icon)
*/
.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.0625em);
  box-sizing: var(--fa-border-box-sizing, content-box);
  padding: var(--fa-border-padding, 0.1875em 0.25em);
}

.fa-pull-left,
.fa-pull-start {
  float: inline-start;
  margin-inline-end: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right,
.fa-pull-end {
  float: inline-end;
  margin-inline-start: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  animation-name: fa-beat;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  animation-name: fa-bounce;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  animation-name: fa-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  animation-name: fa-beat-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  animation-name: fa-flip;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  animation-name: fa-shake;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  animation-name: fa-spin;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 2s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  animation-name: fa-spin;
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
  .fa-bounce,
  .fa-fade,
  .fa-beat-fade,
  .fa-flip,
  .fa-pulse,
  .fa-shake,
  .fa-spin,
  .fa-spin-pulse {
    animation: none !important;
    transition: none !important;
  }
}
@keyframes fa-beat {
  0%, 90% {
    transform: scale(1);
  }
  45% {
    transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-bounce {
  0% {
    transform: scale(1, 1) translateY(0);
  }
  10% {
    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    transform: scale(1, 1) translateY(0);
  }
  100% {
    transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-flip {
  50% {
    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-shake {
  0% {
    transform: rotate(-15deg);
  }
  4% {
    transform: rotate(15deg);
  }
  8%, 24% {
    transform: rotate(-18deg);
  }
  12%, 28% {
    transform: rotate(18deg);
  }
  16% {
    transform: rotate(-22deg);
  }
  20% {
    transform: rotate(22deg);
  }
  32% {
    transform: rotate(-12deg);
  }
  36% {
    transform: rotate(12deg);
  }
  40%, 100% {
    transform: rotate(0deg);
  }
}
@keyframes fa-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  transform: rotate(90deg);
}

.fa-rotate-180 {
  transform: rotate(180deg);
}

.fa-rotate-270 {
  transform: rotate(270deg);
}

.fa-flip-horizontal {
  transform: scale(-1, 1);
}

.fa-flip-vertical {
  transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  transform: scale(-1, -1);
}

.fa-rotate-by {
  transform: rotate(var(--fa-rotate-angle, 0));
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}

.svg-inline--fa.fa-inverse {
  fill: var(--fa-inverse, #fff);
}

.fa-stack {
  display: inline-block;
  height: 2em;
  line-height: 2em;
  position: relative;
  vertical-align: middle;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
  z-index: var(--fa-stack-z-index, auto);
}`;
function qO() {
  var e = IO, t = zO, n = Ae.cssPrefix, r = Ae.replacementClass, o = NB;
  if (n !== e || r !== t) {
    var a = new RegExp("\\.".concat(e, "\\-"), "g"), s = new RegExp("\\--".concat(e, "\\-"), "g"), u = new RegExp("\\.".concat(t), "g");
    o = o.replace(a, ".".concat(n, "-")).replace(s, "--".concat(n, "-")).replace(u, ".".concat(r));
  }
  return o;
}
var Ek = !1;
function Hy() {
  Ae.autoAddCss && !Ek && (TB(qO()), Ek = !0);
}
var DB = {
  mixout: function() {
    return {
      dom: {
        css: qO,
        insertCss: Hy
      }
    };
  },
  hooks: function() {
    return {
      beforeDOMElementCreation: function() {
        Hy();
      },
      beforeI2svg: function() {
        Hy();
      }
    };
  }
}, oi = ta || {};
oi[ri] || (oi[ri] = {});
oi[ri].styles || (oi[ri].styles = {});
oi[ri].hooks || (oi[ri].hooks = {});
oi[ri].shims || (oi[ri].shims = []);
var Pr = oi[ri], GO = [], YO = function() {
  _t.removeEventListener("DOMContentLoaded", YO), rp = 1, GO.map(function(t) {
    return t();
  });
}, rp = !1;
ui && (rp = (_t.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(_t.readyState), rp || _t.addEventListener("DOMContentLoaded", YO));
function jB(e) {
  ui && (rp ? setTimeout(e, 0) : GO.push(e));
}
function lf(e) {
  var t = e.tag, n = e.attributes, r = n === void 0 ? {} : n, o = e.children, a = o === void 0 ? [] : o;
  return typeof e == "string" ? UO(e) : "<".concat(t, " ").concat(RB(r), ">").concat(a.map(lf).join(""), "</").concat(t, ">");
}
function Ck(e, t, n) {
  if (e && e[t] && e[t][n])
    return {
      prefix: t,
      iconName: n,
      icon: e[t][n]
    };
}
var Vy = function(t, n, r, o) {
  var a = Object.keys(t), s = a.length, u = n, c, f, h;
  for (r === void 0 ? (c = 1, h = t[a[0]]) : (c = 0, h = r); c < s; c++)
    f = a[c], h = u(h, t[f], f, t);
  return h;
};
function WO(e) {
  return Lr(e).length !== 1 ? null : e.codePointAt(0).toString(16);
}
function kk(e) {
  return Object.keys(e).reduce(function(t, n) {
    var r = e[n], o = !!r.icon;
    return o ? t[r.iconName] = r.icon : t[n] = r, t;
  }, {});
}
function XO(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = n.skipHooks, o = r === void 0 ? !1 : r, a = kk(t);
  typeof Pr.hooks.addPack == "function" && !o ? Pr.hooks.addPack(e, kk(t)) : Pr.styles[e] = ge(ge({}, Pr.styles[e] || {}), a), e === "fas" && XO("fa", t);
}
var Dc = Pr.styles, PB = Pr.shims, KO = Object.keys(BO), IB = KO.reduce(function(e, t) {
  return e[t] = Object.keys(BO[t]), e;
}, {}), B1 = null, ZO = {}, QO = {}, JO = {}, eN = {}, tN = {};
function zB(e) {
  return ~_B.indexOf(e);
}
function LB(e, t) {
  var n = t.split("-"), r = n[0], o = n.slice(1).join("-");
  return r === e && o !== "" && !zB(o) ? o : null;
}
var nN = function() {
  var t = function(a) {
    return Vy(Dc, function(s, u, c) {
      return s[c] = Vy(u, a, {}), s;
    }, {});
  };
  ZO = t(function(o, a, s) {
    if (a[3] && (o[a[3]] = s), a[2]) {
      var u = a[2].filter(function(c) {
        return typeof c == "number";
      });
      u.forEach(function(c) {
        o[c.toString(16)] = s;
      });
    }
    return o;
  }), QO = t(function(o, a, s) {
    if (o[s] = s, a[2]) {
      var u = a[2].filter(function(c) {
        return typeof c == "string";
      });
      u.forEach(function(c) {
        o[c] = s;
      });
    }
    return o;
  }), tN = t(function(o, a, s) {
    var u = a[2];
    return o[s] = s, u.forEach(function(c) {
      o[c] = s;
    }), o;
  });
  var n = "far" in Dc || Ae.autoFetchSvg, r = Vy(PB, function(o, a) {
    var s = a[0], u = a[1], c = a[2];
    return u === "far" && !n && (u = "fas"), typeof s == "string" && (o.names[s] = {
      prefix: u,
      iconName: c
    }), typeof s == "number" && (o.unicodes[s.toString(16)] = {
      prefix: u,
      iconName: c
    }), o;
  }, {
    names: {},
    unicodes: {}
  });
  JO = r.names, eN = r.unicodes, B1 = hm(Ae.styleDefault, {
    family: Ae.familyDefault
  });
};
kB(function(e) {
  B1 = hm(e.styleDefault, {
    family: Ae.familyDefault
  });
});
nN();
function H1(e, t) {
  return (ZO[e] || {})[t];
}
function FB(e, t) {
  return (QO[e] || {})[t];
}
function Pa(e, t) {
  return (tN[e] || {})[t];
}
function rN(e) {
  return JO[e] || {
    prefix: null,
    iconName: null
  };
}
function $B(e) {
  var t = eN[e], n = H1("fas", e);
  return t || (n ? {
    prefix: "fas",
    iconName: n
  } : null) || {
    prefix: null,
    iconName: null
  };
}
function na() {
  return B1;
}
var oN = function() {
  return {
    prefix: null,
    iconName: null,
    rest: []
  };
};
function BB(e) {
  var t = bn, n = KO.reduce(function(r, o) {
    return r[o] = "".concat(Ae.cssPrefix, "-").concat(o), r;
  }, {});
  return NO.forEach(function(r) {
    (e.includes(n[r]) || e.some(function(o) {
      return IB[r].includes(o);
    })) && (t = r);
  }), t;
}
function hm(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.family, r = n === void 0 ? bn : n, o = yB[r][e];
  if (r === af && !e)
    return "fad";
  var a = _k[r][e] || _k[r][o], s = e in Pr.styles ? e : null, u = a || s || null;
  return u;
}
function HB(e) {
  var t = [], n = null;
  return e.forEach(function(r) {
    var o = LB(Ae.cssPrefix, r);
    o ? n = o : r && t.push(r);
  }), {
    iconName: n,
    rest: t
  };
}
function Tk(e) {
  return e.sort().filter(function(t, n, r) {
    return r.indexOf(t) === n;
  });
}
var Ak = jO.concat(DO);
function pm(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.skipLookups, r = n === void 0 ? !1 : n, o = null, a = Tk(e.filter(function(y) {
    return Ak.includes(y);
  })), s = Tk(e.filter(function(y) {
    return !Ak.includes(y);
  })), u = a.filter(function(y) {
    return o = y, !vO.includes(y);
  }), c = fm(u, 1), f = c[0], h = f === void 0 ? null : f, p = BB(a), g = ge(ge({}, HB(s)), {}, {
    prefix: hm(h, {
      family: p
    })
  });
  return ge(ge(ge({}, g), GB({
    values: e,
    family: p,
    styles: Dc,
    config: Ae,
    canonical: g,
    givenPrefix: o
  })), VB(r, o, g));
}
function VB(e, t, n) {
  var r = n.prefix, o = n.iconName;
  if (e || !r || !o)
    return {
      prefix: r,
      iconName: o
    };
  var a = t === "fa" ? rN(o) : {}, s = Pa(r, o);
  return o = a.iconName || s || o, r = a.prefix || r, r === "far" && !Dc.far && Dc.fas && !Ae.autoFetchSvg && (r = "fas"), {
    prefix: r,
    iconName: o
  };
}
var UB = NO.filter(function(e) {
  return e !== bn || e !== af;
}), qB = Object.keys(Qv).filter(function(e) {
  return e !== bn;
}).map(function(e) {
  return Object.keys(Qv[e]);
}).flat();
function GB(e) {
  var t = e.values, n = e.family, r = e.canonical, o = e.givenPrefix, a = o === void 0 ? "" : o, s = e.styles, u = s === void 0 ? {} : s, c = e.config, f = c === void 0 ? {} : c, h = n === af, p = t.includes("fa-duotone") || t.includes("fad"), g = f.familyDefault === "duotone", y = r.prefix === "fad" || r.prefix === "fa-duotone";
  if (!h && (p || g || y) && (r.prefix = "fad"), (t.includes("fa-brands") || t.includes("fab")) && (r.prefix = "fab"), !r.prefix && UB.includes(n)) {
    var w = Object.keys(u).find(function(S) {
      return qB.includes(S);
    });
    if (w || f.autoFetchSvg) {
      var v = m7.get(n).defaultShortPrefixId;
      r.prefix = v, r.iconName = Pa(r.prefix, r.iconName) || r.iconName;
    }
  }
  return (r.prefix === "fa" || a === "fa") && (r.prefix = na() || "fas"), r;
}
var YB = /* @__PURE__ */ function() {
  function e() {
    $$(this, e), this.definitions = {};
  }
  return H$(e, [{
    key: "add",
    value: function() {
      for (var n = this, r = arguments.length, o = new Array(r), a = 0; a < r; a++)
        o[a] = arguments[a];
      var s = o.reduce(this._pullDefinitions, {});
      Object.keys(s).forEach(function(u) {
        n.definitions[u] = ge(ge({}, n.definitions[u] || {}), s[u]), XO(u, s[u]), nN();
      });
    }
  }, {
    key: "reset",
    value: function() {
      this.definitions = {};
    }
  }, {
    key: "_pullDefinitions",
    value: function(n, r) {
      var o = r.prefix && r.iconName && r.icon ? {
        0: r
      } : r;
      return Object.keys(o).map(function(a) {
        var s = o[a], u = s.prefix, c = s.iconName, f = s.icon, h = f[2];
        n[u] || (n[u] = {}), h.length > 0 && h.forEach(function(p) {
          typeof p == "string" && (n[u][p] = f);
        }), n[u][c] = f;
      }), n;
    }
  }]);
}(), Rk = [], ol = {}, cl = {}, WB = Object.keys(cl);
function XB(e, t) {
  var n = t.mixoutsTo;
  return Rk = e, ol = {}, Object.keys(cl).forEach(function(r) {
    WB.indexOf(r) === -1 && delete cl[r];
  }), Rk.forEach(function(r) {
    var o = r.mixout ? r.mixout() : {};
    if (Object.keys(o).forEach(function(s) {
      typeof o[s] == "function" && (n[s] = o[s]), np(o[s]) === "object" && Object.keys(o[s]).forEach(function(u) {
        n[s] || (n[s] = {}), n[s][u] = o[s][u];
      });
    }), r.hooks) {
      var a = r.hooks();
      Object.keys(a).forEach(function(s) {
        ol[s] || (ol[s] = []), ol[s].push(a[s]);
      });
    }
    r.provides && r.provides(cl);
  }), n;
}
function ob(e, t) {
  for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++)
    r[o - 2] = arguments[o];
  var a = ol[e] || [];
  return a.forEach(function(s) {
    t = s.apply(null, [t].concat(r));
  }), t;
}
function Ga(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  var o = ol[e] || [];
  o.forEach(function(a) {
    a.apply(null, n);
  });
}
function ra() {
  var e = arguments[0], t = Array.prototype.slice.call(arguments, 1);
  return cl[e] ? cl[e].apply(null, t) : void 0;
}
function ib(e) {
  e.prefix === "fa" && (e.prefix = "fas");
  var t = e.iconName, n = e.prefix || na();
  if (t)
    return t = Pa(n, t) || t, Ck(iN.definitions, n, t) || Ck(Pr.styles, n, t);
}
var iN = new YB(), KB = function() {
  Ae.autoReplaceSvg = !1, Ae.observeMutations = !1, Ga("noAuto");
}, ZB = {
  i2svg: function() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return ui ? (Ga("beforeI2svg", t), ra("pseudoElements2svg", t), ra("i2svg", t)) : Promise.reject(new Error("Operation requires a DOM of some kind."));
  },
  watch: function() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = t.autoReplaceSvgRoot;
    Ae.autoReplaceSvg === !1 && (Ae.autoReplaceSvg = !0), Ae.observeMutations = !0, jB(function() {
      JB({
        autoReplaceSvgRoot: n
      }), Ga("watch", t);
    });
  }
}, QB = {
  icon: function(t) {
    if (t === null)
      return null;
    if (np(t) === "object" && t.prefix && t.iconName)
      return {
        prefix: t.prefix,
        iconName: Pa(t.prefix, t.iconName) || t.iconName
      };
    if (Array.isArray(t) && t.length === 2) {
      var n = t[1].indexOf("fa-") === 0 ? t[1].slice(3) : t[1], r = hm(t[0]);
      return {
        prefix: r,
        iconName: Pa(r, n) || n
      };
    }
    if (typeof t == "string" && (t.indexOf("".concat(Ae.cssPrefix, "-")) > -1 || t.match(vB))) {
      var o = pm(t.split(" "), {
        skipLookups: !0
      });
      return {
        prefix: o.prefix || na(),
        iconName: Pa(o.prefix, o.iconName) || o.iconName
      };
    }
    if (typeof t == "string") {
      var a = na();
      return {
        prefix: a,
        iconName: Pa(a, t) || t
      };
    }
  }
}, ur = {
  noAuto: KB,
  config: Ae,
  dom: ZB,
  parse: QB,
  library: iN,
  findIconDefinition: ib,
  toHtml: lf
}, JB = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = t.autoReplaceSvgRoot, r = n === void 0 ? _t : n;
  (Object.keys(Pr.styles).length > 0 || Ae.autoFetchSvg) && ui && Ae.autoReplaceSvg && ur.dom.i2svg({
    node: r
  });
};
function mm(e, t) {
  return Object.defineProperty(e, "abstract", {
    get: t
  }), Object.defineProperty(e, "html", {
    get: function() {
      return e.abstract.map(function(r) {
        return lf(r);
      });
    }
  }), Object.defineProperty(e, "node", {
    get: function() {
      if (ui) {
        var r = _t.createElement("div");
        return r.innerHTML = e.html, r.children;
      }
    }
  }), e;
}
function eH(e) {
  var t = e.children, n = e.main, r = e.mask, o = e.attributes, a = e.styles, s = e.transform;
  if ($1(s) && n.found && !r.found) {
    var u = n.width, c = n.height, f = {
      x: u / c / 2,
      y: 0.5
    };
    o.style = dm(ge(ge({}, a), {}, {
      "transform-origin": "".concat(f.x + s.x / 16, "em ").concat(f.y + s.y / 16, "em")
    }));
  }
  return [{
    tag: "svg",
    attributes: o,
    children: t
  }];
}
function tH(e) {
  var t = e.prefix, n = e.iconName, r = e.children, o = e.attributes, a = e.symbol, s = a === !0 ? "".concat(t, "-").concat(Ae.cssPrefix, "-").concat(n) : a;
  return [{
    tag: "svg",
    attributes: {
      style: "display: none;"
    },
    children: [{
      tag: "symbol",
      attributes: ge(ge({}, o), {}, {
        id: s
      }),
      children: r
    }]
  }];
}
function nH(e) {
  var t = ["aria-label", "aria-labelledby", "title", "role"];
  return t.some(function(n) {
    return n in e;
  });
}
function V1(e) {
  var t = e.icons, n = t.main, r = t.mask, o = e.prefix, a = e.iconName, s = e.transform, u = e.symbol, c = e.maskId, f = e.extra, h = e.watchable, p = h === void 0 ? !1 : h, g = r.found ? r : n, y = g.width, w = g.height, v = [Ae.replacementClass, a ? "".concat(Ae.cssPrefix, "-").concat(a) : ""].filter(function(R) {
    return f.classes.indexOf(R) === -1;
  }).filter(function(R) {
    return R !== "" || !!R;
  }).concat(f.classes).join(" "), S = {
    children: [],
    attributes: ge(ge({}, f.attributes), {}, {
      "data-prefix": o,
      "data-icon": a,
      class: v,
      role: f.attributes.role || "img",
      viewBox: "0 0 ".concat(y, " ").concat(w)
    })
  };
  !nH(f.attributes) && !f.attributes["aria-hidden"] && (S.attributes["aria-hidden"] = "true"), p && (S.attributes[qa] = "");
  var E = ge(ge({}, S), {}, {
    prefix: o,
    iconName: a,
    main: n,
    mask: r,
    maskId: c,
    transform: s,
    symbol: u,
    styles: ge({}, f.styles)
  }), A = r.found && n.found ? ra("generateAbstractMask", E) || {
    children: [],
    attributes: {}
  } : ra("generateAbstractIcon", E) || {
    children: [],
    attributes: {}
  }, k = A.children, T = A.attributes;
  return E.children = k, E.attributes = T, u ? tH(E) : eH(E);
}
function Mk(e) {
  var t = e.content, n = e.width, r = e.height, o = e.transform, a = e.extra, s = e.watchable, u = s === void 0 ? !1 : s, c = ge(ge({}, a.attributes), {}, {
    class: a.classes.join(" ")
  });
  u && (c[qa] = "");
  var f = ge({}, a.styles);
  $1(o) && (f.transform = OB({
    transform: o,
    width: n,
    height: r
  }), f["-webkit-transform"] = f.transform);
  var h = dm(f);
  h.length > 0 && (c.style = h);
  var p = [];
  return p.push({
    tag: "span",
    attributes: c,
    children: [t]
  }), p;
}
function rH(e) {
  var t = e.content, n = e.extra, r = ge(ge({}, n.attributes), {}, {
    class: n.classes.join(" ")
  }), o = dm(n.styles);
  o.length > 0 && (r.style = o);
  var a = [];
  return a.push({
    tag: "span",
    attributes: r,
    children: [t]
  }), a;
}
var Uy = Pr.styles;
function ab(e) {
  var t = e[0], n = e[1], r = e.slice(4), o = fm(r, 1), a = o[0], s = null;
  return Array.isArray(a) ? s = {
    tag: "g",
    attributes: {
      class: "".concat(Ae.cssPrefix, "-").concat(By.GROUP)
    },
    children: [{
      tag: "path",
      attributes: {
        class: "".concat(Ae.cssPrefix, "-").concat(By.SECONDARY),
        fill: "currentColor",
        d: a[0]
      }
    }, {
      tag: "path",
      attributes: {
        class: "".concat(Ae.cssPrefix, "-").concat(By.PRIMARY),
        fill: "currentColor",
        d: a[1]
      }
    }]
  } : s = {
    tag: "path",
    attributes: {
      fill: "currentColor",
      d: a
    }
  }, {
    found: !0,
    width: t,
    height: n,
    icon: s
  };
}
var oH = {
  found: !1,
  width: 512,
  height: 512
};
function iH(e, t) {
  !FO && !Ae.showMissingIcons && e && console.error('Icon with name "'.concat(e, '" and prefix "').concat(t, '" is missing.'));
}
function sb(e, t) {
  var n = t;
  return t === "fa" && Ae.styleDefault !== null && (t = na()), new Promise(function(r, o) {
    if (n === "fa") {
      var a = rN(e) || {};
      e = a.iconName || e, t = a.prefix || t;
    }
    if (e && t && Uy[t] && Uy[t][e]) {
      var s = Uy[t][e];
      return r(ab(s));
    }
    iH(e, t), r(ge(ge({}, oH), {}, {
      icon: Ae.showMissingIcons && e ? ra("missingIconAbstract") || {} : {}
    }));
  });
}
var Ok = function() {
}, lb = Ae.measurePerformance && oh && oh.mark && oh.measure ? oh : {
  mark: Ok,
  measure: Ok
}, hc = 'FA "7.0.0"', aH = function(t) {
  return lb.mark("".concat(hc, " ").concat(t, " begins")), function() {
    return aN(t);
  };
}, aN = function(t) {
  lb.mark("".concat(hc, " ").concat(t, " ends")), lb.measure("".concat(hc, " ").concat(t), "".concat(hc, " ").concat(t, " begins"), "".concat(hc, " ").concat(t, " ends"));
}, U1 = {
  begin: aH,
  end: aN
}, Lh = function() {
};
function Nk(e) {
  var t = e.getAttribute ? e.getAttribute(qa) : null;
  return typeof t == "string";
}
function sH(e) {
  var t = e.getAttribute ? e.getAttribute(z1) : null, n = e.getAttribute ? e.getAttribute(L1) : null;
  return t && n;
}
function lH(e) {
  return e && e.classList && e.classList.contains && e.classList.contains(Ae.replacementClass);
}
function uH() {
  if (Ae.autoReplaceSvg === !0)
    return Fh.replace;
  var e = Fh[Ae.autoReplaceSvg];
  return e || Fh.replace;
}
function cH(e) {
  return _t.createElementNS("http://www.w3.org/2000/svg", e);
}
function fH(e) {
  return _t.createElement(e);
}
function sN(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.ceFn, r = n === void 0 ? e.tag === "svg" ? cH : fH : n;
  if (typeof e == "string")
    return _t.createTextNode(e);
  var o = r(e.tag);
  Object.keys(e.attributes || []).forEach(function(s) {
    o.setAttribute(s, e.attributes[s]);
  });
  var a = e.children || [];
  return a.forEach(function(s) {
    o.appendChild(sN(s, {
      ceFn: r
    }));
  }), o;
}
function dH(e) {
  var t = " ".concat(e.outerHTML, " ");
  return t = "".concat(t, "Font Awesome fontawesome.com "), t;
}
var Fh = {
  replace: function(t) {
    var n = t[0];
    if (n.parentNode)
      if (t[1].forEach(function(o) {
        n.parentNode.insertBefore(sN(o), n);
      }), n.getAttribute(qa) === null && Ae.keepOriginalSource) {
        var r = _t.createComment(dH(n));
        n.parentNode.replaceChild(r, n);
      } else
        n.remove();
  },
  nest: function(t) {
    var n = t[0], r = t[1];
    if (~F1(n).indexOf(Ae.replacementClass))
      return Fh.replace(t);
    var o = new RegExp("".concat(Ae.cssPrefix, "-.*"));
    if (delete r[0].attributes.id, r[0].attributes.class) {
      var a = r[0].attributes.class.split(" ").reduce(function(u, c) {
        return c === Ae.replacementClass || c.match(o) ? u.toSvg.push(c) : u.toNode.push(c), u;
      }, {
        toNode: [],
        toSvg: []
      });
      r[0].attributes.class = a.toSvg.join(" "), a.toNode.length === 0 ? n.removeAttribute("class") : n.setAttribute("class", a.toNode.join(" "));
    }
    var s = r.map(function(u) {
      return lf(u);
    }).join(`
`);
    n.setAttribute(qa, ""), n.innerHTML = s;
  }
};
function Dk(e) {
  e();
}
function lN(e, t) {
  var n = typeof t == "function" ? t : Lh;
  if (e.length === 0)
    n();
  else {
    var r = Dk;
    Ae.mutateApproach === mB && (r = ta.requestAnimationFrame || Dk), r(function() {
      var o = uH(), a = U1.begin("mutate");
      e.map(o), a(), n();
    });
  }
}
var q1 = !1;
function uN() {
  q1 = !0;
}
function ub() {
  q1 = !1;
}
var op = null;
function jk(e) {
  if (vk && Ae.observeMutations) {
    var t = e.treeCallback, n = t === void 0 ? Lh : t, r = e.nodeCallback, o = r === void 0 ? Lh : r, a = e.pseudoElementsCallback, s = a === void 0 ? Lh : a, u = e.observeMutationsRoot, c = u === void 0 ? _t : u;
    op = new vk(function(f) {
      if (!q1) {
        var h = na();
        Ll(f).forEach(function(p) {
          if (p.type === "childList" && p.addedNodes.length > 0 && !Nk(p.addedNodes[0]) && (Ae.searchPseudoElements && s(p.target), n(p.target)), p.type === "attributes" && p.target.parentNode && Ae.searchPseudoElements && s([p.target], !0), p.type === "attributes" && Nk(p.target) && ~wB.indexOf(p.attributeName))
            if (p.attributeName === "class" && sH(p.target)) {
              var g = pm(F1(p.target)), y = g.prefix, w = g.iconName;
              p.target.setAttribute(z1, y || h), w && p.target.setAttribute(L1, w);
            } else lH(p.target) && o(p.target);
        });
      }
    }), ui && op.observe(c, {
      childList: !0,
      attributes: !0,
      characterData: !0,
      subtree: !0
    });
  }
}
function hH() {
  op && op.disconnect();
}
function pH(e) {
  var t = e.getAttribute("style"), n = [];
  return t && (n = t.split(";").reduce(function(r, o) {
    var a = o.split(":"), s = a[0], u = a.slice(1);
    return s && u.length > 0 && (r[s] = u.join(":").trim()), r;
  }, {})), n;
}
function mH(e) {
  var t = e.getAttribute("data-prefix"), n = e.getAttribute("data-icon"), r = e.innerText !== void 0 ? e.innerText.trim() : "", o = pm(F1(e));
  return o.prefix || (o.prefix = na()), t && n && (o.prefix = t, o.iconName = n), o.iconName && o.prefix || (o.prefix && r.length > 0 && (o.iconName = FB(o.prefix, e.innerText) || H1(o.prefix, WO(e.innerText))), !o.iconName && Ae.autoFetchSvg && e.firstChild && e.firstChild.nodeType === Node.TEXT_NODE && (o.iconName = e.firstChild.data)), o;
}
function gH(e) {
  var t = Ll(e.attributes).reduce(function(n, r) {
    return n.name !== "class" && n.name !== "style" && (n[r.name] = r.value), n;
  }, {});
  return t;
}
function yH() {
  return {
    iconName: null,
    prefix: null,
    transform: lo,
    symbol: !1,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    extra: {
      classes: [],
      styles: {},
      attributes: {}
    }
  };
}
function Pk(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    styleParser: !0
  }, n = mH(e), r = n.iconName, o = n.prefix, a = n.rest, s = gH(e), u = ob("parseNodeAttributes", {}, e), c = t.styleParser ? pH(e) : [];
  return ge({
    iconName: r,
    prefix: o,
    transform: lo,
    mask: {
      iconName: null,
      prefix: null,
      rest: []
    },
    maskId: null,
    symbol: !1,
    extra: {
      classes: a,
      styles: c,
      attributes: s
    }
  }, u);
}
var vH = Pr.styles;
function cN(e) {
  var t = Ae.autoReplaceSvg === "nest" ? Pk(e, {
    styleParser: !1
  }) : Pk(e);
  return ~t.extra.classes.indexOf(HO) ? ra("generateLayersText", e, t) : ra("generateSvgReplacementMutation", e, t);
}
function bH() {
  return [].concat(Lr(DO), Lr(jO));
}
function Ik(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (!ui) return Promise.resolve();
  var n = _t.documentElement.classList, r = function(p) {
    return n.add("".concat(wk, "-").concat(p));
  }, o = function(p) {
    return n.remove("".concat(wk, "-").concat(p));
  }, a = Ae.autoFetchSvg ? bH() : vO.concat(Object.keys(vH));
  a.includes("fa") || a.push("fa");
  var s = [".".concat(HO, ":not([").concat(qa, "])")].concat(a.map(function(h) {
    return ".".concat(h, ":not([").concat(qa, "])");
  })).join(", ");
  if (s.length === 0)
    return Promise.resolve();
  var u = [];
  try {
    u = Ll(e.querySelectorAll(s));
  } catch {
  }
  if (u.length > 0)
    r("pending"), o("complete");
  else
    return Promise.resolve();
  var c = U1.begin("onTree"), f = u.reduce(function(h, p) {
    try {
      var g = cN(p);
      g && h.push(g);
    } catch (y) {
      FO || y.name === "MissingIcon" && console.error(y);
    }
    return h;
  }, []);
  return new Promise(function(h, p) {
    Promise.all(f).then(function(g) {
      lN(g, function() {
        r("active"), r("complete"), o("pending"), typeof t == "function" && t(), c(), h();
      });
    }).catch(function(g) {
      c(), p(g);
    });
  });
}
function xH(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  cN(e).then(function(n) {
    n && lN([n], t);
  });
}
function wH(e) {
  return function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = (t || {}).icon ? t : ib(t || {}), o = n.mask;
    return o && (o = (o || {}).icon ? o : ib(o || {})), e(r, ge(ge({}, n), {}, {
      mask: o
    }));
  };
}
var _H = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = n.transform, o = r === void 0 ? lo : r, a = n.symbol, s = a === void 0 ? !1 : a, u = n.mask, c = u === void 0 ? null : u, f = n.maskId, h = f === void 0 ? null : f, p = n.classes, g = p === void 0 ? [] : p, y = n.attributes, w = y === void 0 ? {} : y, v = n.styles, S = v === void 0 ? {} : v;
  if (t) {
    var E = t.prefix, A = t.iconName, k = t.icon;
    return mm(ge({
      type: "icon"
    }, t), function() {
      return Ga("beforeDOMElementCreation", {
        iconDefinition: t,
        params: n
      }), V1({
        icons: {
          main: ab(k),
          mask: c ? ab(c.icon) : {
            found: !1,
            width: null,
            height: null,
            icon: {}
          }
        },
        prefix: E,
        iconName: A,
        transform: ge(ge({}, lo), o),
        symbol: s,
        maskId: h,
        extra: {
          attributes: w,
          styles: S,
          classes: g
        }
      });
    });
  }
}, SH = {
  mixout: function() {
    return {
      icon: wH(_H)
    };
  },
  hooks: function() {
    return {
      mutationObserverCallbacks: function(n) {
        return n.treeCallback = Ik, n.nodeCallback = xH, n;
      }
    };
  },
  provides: function(t) {
    t.i2svg = function(n) {
      var r = n.node, o = r === void 0 ? _t : r, a = n.callback, s = a === void 0 ? function() {
      } : a;
      return Ik(o, s);
    }, t.generateSvgReplacementMutation = function(n, r) {
      var o = r.iconName, a = r.prefix, s = r.transform, u = r.symbol, c = r.mask, f = r.maskId, h = r.extra;
      return new Promise(function(p, g) {
        Promise.all([sb(o, a), c.iconName ? sb(c.iconName, c.prefix) : Promise.resolve({
          found: !1,
          width: 512,
          height: 512,
          icon: {}
        })]).then(function(y) {
          var w = fm(y, 2), v = w[0], S = w[1];
          p([n, V1({
            icons: {
              main: v,
              mask: S
            },
            prefix: a,
            iconName: o,
            transform: s,
            symbol: u,
            maskId: f,
            extra: h,
            watchable: !0
          })]);
        }).catch(g);
      });
    }, t.generateAbstractIcon = function(n) {
      var r = n.children, o = n.attributes, a = n.main, s = n.transform, u = n.styles, c = dm(u);
      c.length > 0 && (o.style = c);
      var f;
      return $1(s) && (f = ra("generateAbstractTransformGrouping", {
        main: a,
        transform: s,
        containerWidth: a.width,
        iconWidth: a.width
      })), r.push(f || a.icon), {
        children: r,
        attributes: o
      };
    };
  }
}, EH = {
  mixout: function() {
    return {
      layer: function(n) {
        var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o = r.classes, a = o === void 0 ? [] : o;
        return mm({
          type: "layer"
        }, function() {
          Ga("beforeDOMElementCreation", {
            assembler: n,
            params: r
          });
          var s = [];
          return n(function(u) {
            Array.isArray(u) ? u.map(function(c) {
              s = s.concat(c.abstract);
            }) : s = s.concat(u.abstract);
          }), [{
            tag: "span",
            attributes: {
              class: ["".concat(Ae.cssPrefix, "-layers")].concat(Lr(a)).join(" ")
            },
            children: s
          }];
        });
      }
    };
  }
}, CH = {
  mixout: function() {
    return {
      counter: function(n) {
        var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        r.title;
        var o = r.classes, a = o === void 0 ? [] : o, s = r.attributes, u = s === void 0 ? {} : s, c = r.styles, f = c === void 0 ? {} : c;
        return mm({
          type: "counter",
          content: n
        }, function() {
          return Ga("beforeDOMElementCreation", {
            content: n,
            params: r
          }), rH({
            content: n.toString(),
            extra: {
              attributes: u,
              styles: f,
              classes: ["".concat(Ae.cssPrefix, "-layers-counter")].concat(Lr(a))
            }
          });
        });
      }
    };
  }
}, kH = {
  mixout: function() {
    return {
      text: function(n) {
        var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o = r.transform, a = o === void 0 ? lo : o, s = r.classes, u = s === void 0 ? [] : s, c = r.attributes, f = c === void 0 ? {} : c, h = r.styles, p = h === void 0 ? {} : h;
        return mm({
          type: "text",
          content: n
        }, function() {
          return Ga("beforeDOMElementCreation", {
            content: n,
            params: r
          }), Mk({
            content: n,
            transform: ge(ge({}, lo), a),
            extra: {
              attributes: f,
              styles: p,
              classes: ["".concat(Ae.cssPrefix, "-layers-text")].concat(Lr(u))
            }
          });
        });
      }
    };
  },
  provides: function(t) {
    t.generateLayersText = function(n, r) {
      var o = r.transform, a = r.extra, s = null, u = null;
      if (gO) {
        var c = parseInt(getComputedStyle(n).fontSize, 10), f = n.getBoundingClientRect();
        s = f.width / c, u = f.height / c;
      }
      return Promise.resolve([n, Mk({
        content: n.innerHTML,
        width: s,
        height: u,
        transform: o,
        extra: a,
        watchable: !0
      })]);
    };
  }
}, fN = new RegExp('"', "ug"), zk = [1105920, 1112319], Lk = ge(ge(ge(ge({}, {
  FontAwesome: {
    normal: "fas",
    400: "fas"
  }
}), p7), hB), S7), cb = Object.keys(Lk).reduce(function(e, t) {
  return e[t.toLowerCase()] = Lk[t], e;
}, {}), TH = Object.keys(cb).reduce(function(e, t) {
  var n = cb[t];
  return e[t] = n[900] || Lr(Object.entries(n))[0][1], e;
}, {});
function AH(e) {
  var t = e.replace(fN, "");
  return WO(Lr(t)[0] || "");
}
function RH(e) {
  var t = e.getPropertyValue("font-feature-settings").includes("ss01"), n = e.getPropertyValue("content"), r = n.replace(fN, ""), o = r.codePointAt(0), a = o >= zk[0] && o <= zk[1], s = r.length === 2 ? r[0] === r[1] : !1;
  return a || s || t;
}
function MH(e, t) {
  var n = e.replace(/^['"]|['"]$/g, "").toLowerCase(), r = parseInt(t), o = isNaN(r) ? "normal" : r;
  return (cb[n] || {})[o] || TH[n];
}
function Fk(e, t) {
  var n = "".concat(pB).concat(t.replace(":", "-"));
  return new Promise(function(r, o) {
    if (e.getAttribute(n) !== null)
      return r();
    var a = Ll(e.children), s = a.filter(function(N) {
      return N.getAttribute(eb) === t;
    })[0], u = ta.getComputedStyle(e, t), c = u.getPropertyValue("font-family"), f = c.match(bB), h = u.getPropertyValue("font-weight"), p = u.getPropertyValue("content");
    if (s && !f)
      return e.removeChild(s), r();
    if (f && p !== "none" && p !== "") {
      var g = u.getPropertyValue("content"), y = MH(c, h), w = AH(g), v = f[0].startsWith("FontAwesome"), S = RH(u), E = H1(y, w), A = E;
      if (v) {
        var k = $B(w);
        k.iconName && k.prefix && (E = k.iconName, y = k.prefix);
      }
      if (E && !S && (!s || s.getAttribute(z1) !== y || s.getAttribute(L1) !== A)) {
        e.setAttribute(n, A), s && e.removeChild(s);
        var T = yH(), R = T.extra;
        R.attributes[eb] = t, sb(E, y).then(function(N) {
          var j = V1(ge(ge({}, T), {}, {
            icons: {
              main: N,
              mask: oN()
            },
            prefix: y,
            iconName: A,
            extra: R,
            watchable: !0
          })), z = _t.createElementNS("http://www.w3.org/2000/svg", "svg");
          t === "::before" ? e.insertBefore(z, e.firstChild) : e.appendChild(z), z.outerHTML = j.map(function(B) {
            return lf(B);
          }).join(`
`), e.removeAttribute(n), r();
        }).catch(o);
      } else
        r();
    } else
      r();
  });
}
function OH(e) {
  return Promise.all([Fk(e, "::before"), Fk(e, "::after")]);
}
function NH(e) {
  return e.parentNode !== document.head && !~gB.indexOf(e.tagName.toUpperCase()) && !e.getAttribute(eb) && (!e.parentNode || e.parentNode.tagName !== "svg");
}
var DH = function(t) {
  return !!t && LO.some(function(n) {
    return t.includes(n);
  });
}, jH = function(t) {
  if (!t) return [];
  for (var n = /* @__PURE__ */ new Set(), r = [t], o = [/(?=\s:)/, /(?<=\)\)?[^,]*,)/], a = function() {
    var y = u[s];
    r = r.flatMap(function(w) {
      return w.split(y).map(function(v) {
        return v.replace(/,\s*$/, "").trim();
      });
    });
  }, s = 0, u = o; s < u.length; s++)
    a();
  r = r.flatMap(function(g) {
    return g.includes("(") ? g : g.split(",").map(function(y) {
      return y.trim();
    });
  });
  var c = zh(r), f;
  try {
    for (c.s(); !(f = c.n()).done; ) {
      var h = f.value;
      if (DH(h)) {
        var p = LO.reduce(function(g, y) {
          return g.replace(y, "");
        }, h);
        p !== "" && p !== "*" && n.add(p);
      }
    }
  } catch (g) {
    c.e(g);
  } finally {
    c.f();
  }
  return n;
};
function $k(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  if (ui) {
    var n;
    if (t)
      n = e;
    else if (Ae.searchPseudoElementsFullScan)
      n = e.querySelectorAll("*");
    else {
      var r = /* @__PURE__ */ new Set(), o = zh(document.styleSheets), a;
      try {
        for (o.s(); !(a = o.n()).done; ) {
          var s = a.value;
          try {
            var u = zh(s.cssRules), c;
            try {
              for (u.s(); !(c = u.n()).done; ) {
                var f = c.value, h = jH(f.selectorText), p = zh(h), g;
                try {
                  for (p.s(); !(g = p.n()).done; ) {
                    var y = g.value;
                    r.add(y);
                  }
                } catch (v) {
                  p.e(v);
                } finally {
                  p.f();
                }
              }
            } catch (v) {
              u.e(v);
            } finally {
              u.f();
            }
          } catch (v) {
            Ae.searchPseudoElementsWarnings && console.warn("Font Awesome: cannot parse stylesheet: ".concat(s.href, " (").concat(v.message, `)
If it declares any Font Awesome CSS pseudo-elements, they will not be rendered as SVG icons. Add crossorigin="anonymous" to the <link>, enable searchPseudoElementsFullScan for slower but more thorough DOM parsing, or suppress this warning by setting searchPseudoElementsWarnings to false.`));
          }
        }
      } catch (v) {
        o.e(v);
      } finally {
        o.f();
      }
      if (!r.size) return;
      var w = Array.from(r).join(", ");
      try {
        n = e.querySelectorAll(w);
      } catch {
      }
    }
    return new Promise(function(v, S) {
      var E = Ll(n).filter(NH).map(OH), A = U1.begin("searchPseudoElements");
      uN(), Promise.all(E).then(function() {
        A(), ub(), v();
      }).catch(function() {
        A(), ub(), S();
      });
    });
  }
}
var PH = {
  hooks: function() {
    return {
      mutationObserverCallbacks: function(n) {
        return n.pseudoElementsCallback = $k, n;
      }
    };
  },
  provides: function(t) {
    t.pseudoElements2svg = function(n) {
      var r = n.node, o = r === void 0 ? _t : r;
      Ae.searchPseudoElements && $k(o);
    };
  }
}, Bk = !1, IH = {
  mixout: function() {
    return {
      dom: {
        unwatch: function() {
          uN(), Bk = !0;
        }
      }
    };
  },
  hooks: function() {
    return {
      bootstrap: function() {
        jk(ob("mutationObserverCallbacks", {}));
      },
      noAuto: function() {
        hH();
      },
      watch: function(n) {
        var r = n.observeMutationsRoot;
        Bk ? ub() : jk(ob("mutationObserverCallbacks", {
          observeMutationsRoot: r
        }));
      }
    };
  }
}, Hk = function(t) {
  var n = {
    size: 16,
    x: 0,
    y: 0,
    flipX: !1,
    flipY: !1,
    rotate: 0
  };
  return t.toLowerCase().split(" ").reduce(function(r, o) {
    var a = o.toLowerCase().split("-"), s = a[0], u = a.slice(1).join("-");
    if (s && u === "h")
      return r.flipX = !0, r;
    if (s && u === "v")
      return r.flipY = !0, r;
    if (u = parseFloat(u), isNaN(u))
      return r;
    switch (s) {
      case "grow":
        r.size = r.size + u;
        break;
      case "shrink":
        r.size = r.size - u;
        break;
      case "left":
        r.x = r.x - u;
        break;
      case "right":
        r.x = r.x + u;
        break;
      case "up":
        r.y = r.y - u;
        break;
      case "down":
        r.y = r.y + u;
        break;
      case "rotate":
        r.rotate = r.rotate + u;
        break;
    }
    return r;
  }, n);
}, zH = {
  mixout: function() {
    return {
      parse: {
        transform: function(n) {
          return Hk(n);
        }
      }
    };
  },
  hooks: function() {
    return {
      parseNodeAttributes: function(n, r) {
        var o = r.getAttribute("data-fa-transform");
        return o && (n.transform = Hk(o)), n;
      }
    };
  },
  provides: function(t) {
    t.generateAbstractTransformGrouping = function(n) {
      var r = n.main, o = n.transform, a = n.containerWidth, s = n.iconWidth, u = {
        transform: "translate(".concat(a / 2, " 256)")
      }, c = "translate(".concat(o.x * 32, ", ").concat(o.y * 32, ") "), f = "scale(".concat(o.size / 16 * (o.flipX ? -1 : 1), ", ").concat(o.size / 16 * (o.flipY ? -1 : 1), ") "), h = "rotate(".concat(o.rotate, " 0 0)"), p = {
        transform: "".concat(c, " ").concat(f, " ").concat(h)
      }, g = {
        transform: "translate(".concat(s / 2 * -1, " -256)")
      }, y = {
        outer: u,
        inner: p,
        path: g
      };
      return {
        tag: "g",
        attributes: ge({}, y.outer),
        children: [{
          tag: "g",
          attributes: ge({}, y.inner),
          children: [{
            tag: r.icon.tag,
            children: r.icon.children,
            attributes: ge(ge({}, r.icon.attributes), y.path)
          }]
        }]
      };
    };
  }
}, qy = {
  x: 0,
  y: 0,
  width: "100%",
  height: "100%"
};
function Vk(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return e.attributes && (e.attributes.fill || t) && (e.attributes.fill = "black"), e;
}
function LH(e) {
  return e.tag === "g" ? e.children : [e];
}
var FH = {
  hooks: function() {
    return {
      parseNodeAttributes: function(n, r) {
        var o = r.getAttribute("data-fa-mask"), a = o ? pm(o.split(" ").map(function(s) {
          return s.trim();
        })) : oN();
        return a.prefix || (a.prefix = na()), n.mask = a, n.maskId = r.getAttribute("data-fa-mask-id"), n;
      }
    };
  },
  provides: function(t) {
    t.generateAbstractMask = function(n) {
      var r = n.children, o = n.attributes, a = n.main, s = n.mask, u = n.maskId, c = n.transform, f = a.width, h = a.icon, p = s.width, g = s.icon, y = MB({
        transform: c,
        containerWidth: p,
        iconWidth: f
      }), w = {
        tag: "rect",
        attributes: ge(ge({}, qy), {}, {
          fill: "white"
        })
      }, v = h.children ? {
        children: h.children.map(Vk)
      } : {}, S = {
        tag: "g",
        attributes: ge({}, y.inner),
        children: [Vk(ge({
          tag: h.tag,
          attributes: ge(ge({}, h.attributes), y.path)
        }, v))]
      }, E = {
        tag: "g",
        attributes: ge({}, y.outer),
        children: [S]
      }, A = "mask-".concat(u || Sk()), k = "clip-".concat(u || Sk()), T = {
        tag: "mask",
        attributes: ge(ge({}, qy), {}, {
          id: A,
          maskUnits: "userSpaceOnUse",
          maskContentUnits: "userSpaceOnUse"
        }),
        children: [w, E]
      }, R = {
        tag: "defs",
        children: [{
          tag: "clipPath",
          attributes: {
            id: k
          },
          children: LH(g)
        }, T]
      };
      return r.push(R, {
        tag: "rect",
        attributes: ge({
          fill: "currentColor",
          "clip-path": "url(#".concat(k, ")"),
          mask: "url(#".concat(A, ")")
        }, qy)
      }), {
        children: r,
        attributes: o
      };
    };
  }
}, $H = {
  provides: function(t) {
    var n = !1;
    ta.matchMedia && (n = ta.matchMedia("(prefers-reduced-motion: reduce)").matches), t.missingIconAbstract = function() {
      var r = [], o = {
        fill: "currentColor"
      }, a = {
        attributeType: "XML",
        repeatCount: "indefinite",
        dur: "2s"
      };
      r.push({
        tag: "path",
        attributes: ge(ge({}, o), {}, {
          d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
        })
      });
      var s = ge(ge({}, a), {}, {
        attributeName: "opacity"
      }), u = {
        tag: "circle",
        attributes: ge(ge({}, o), {}, {
          cx: "256",
          cy: "364",
          r: "28"
        }),
        children: []
      };
      return n || u.children.push({
        tag: "animate",
        attributes: ge(ge({}, a), {}, {
          attributeName: "r",
          values: "28;14;28;28;14;28;"
        })
      }, {
        tag: "animate",
        attributes: ge(ge({}, s), {}, {
          values: "1;0;1;1;0;1;"
        })
      }), r.push(u), r.push({
        tag: "path",
        attributes: ge(ge({}, o), {}, {
          opacity: "1",
          d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
        }),
        children: n ? [] : [{
          tag: "animate",
          attributes: ge(ge({}, s), {}, {
            values: "1;0;0;0;0;1;"
          })
        }]
      }), n || r.push({
        tag: "path",
        attributes: ge(ge({}, o), {}, {
          opacity: "0",
          d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
        }),
        children: [{
          tag: "animate",
          attributes: ge(ge({}, s), {}, {
            values: "0;0;1;1;0;0;"
          })
        }]
      }), {
        tag: "g",
        attributes: {
          class: "missing"
        },
        children: r
      };
    };
  }
}, BH = {
  hooks: function() {
    return {
      parseNodeAttributes: function(n, r) {
        var o = r.getAttribute("data-fa-symbol"), a = o === null ? !1 : o === "" ? !0 : o;
        return n.symbol = a, n;
      }
    };
  }
}, HH = [DB, SH, EH, CH, kH, PH, IH, zH, FH, $H, BH];
XB(HH, {
  mixoutsTo: ur
});
ur.noAuto;
var VH = ur.config;
ur.library;
ur.dom;
var fb = ur.parse;
ur.findIconDefinition;
ur.toHtml;
var UH = ur.icon;
ur.layer;
ur.text;
ur.counter;
function db(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function qH(e) {
  if (Array.isArray(e)) return e;
}
function GH(e) {
  if (Array.isArray(e)) return db(e);
}
function Yi(e, t, n) {
  return (t = eV(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function YH(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function WH(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r, o, a, s, u = [], c = !0, f = !1;
    try {
      if (a = (n = n.call(e)).next, t !== 0) for (; !(c = (r = a.call(n)).done) && (u.push(r.value), u.length !== t); c = !0) ;
    } catch (h) {
      f = !0, o = h;
    } finally {
      try {
        if (!c && n.return != null && (s = n.return(), Object(s) !== s)) return;
      } finally {
        if (f) throw o;
      }
    }
    return u;
  }
}
function XH() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function KH() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Uk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function io(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Uk(Object(n), !0).forEach(function(r) {
      Yi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Uk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function ZH(e, t) {
  if (e == null) return {};
  var n, r, o = QH(e, t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    for (r = 0; r < a.length; r++) n = a[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
function QH(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.indexOf(r) !== -1) continue;
    n[r] = e[r];
  }
  return n;
}
function qk(e, t) {
  return qH(e) || WH(e, t) || dN(e, t) || XH();
}
function hb(e) {
  return GH(e) || YH(e) || dN(e) || KH();
}
function JH(e, t) {
  if (typeof e != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function eV(e) {
  var t = JH(e, "string");
  return typeof t == "symbol" ? t : t + "";
}
function ip(e) {
  "@babel/helpers - typeof";
  return ip = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ip(e);
}
function dN(e, t) {
  if (e) {
    if (typeof e == "string") return db(e, t);
    var n = {}.toString.call(e).slice(8, -1);
    return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? db(e, t) : void 0;
  }
}
var tV = "7.0.0-alpha1", pb;
try {
  var nV = require("@fortawesome/fontawesome-svg-core/package.json");
  pb = nV.version;
} catch {
  pb = "7.0.0";
}
function rV(e) {
  var t = e.beat, n = e.fade, r = e.beatFade, o = e.bounce, a = e.shake, s = e.flash, u = e.spin, c = e.spinPulse, f = e.spinReverse, h = e.pulse, p = e.fixedWidth, g = e.inverse, y = e.border, w = e.listItem, v = e.flip, S = e.size, E = e.rotation, A = e.pull, k = e.swapOpacity, T = e.rotateBy, R = e.widthAuto, N = oV(pb, tV), j = Yi(Yi(Yi(Yi(Yi(Yi({
    "fa-beat": t,
    "fa-fade": n,
    "fa-beat-fade": r,
    "fa-bounce": o,
    "fa-shake": a,
    "fa-flash": s,
    "fa-spin": u,
    "fa-spin-reverse": f,
    "fa-spin-pulse": c,
    "fa-pulse": h,
    "fa-fw": p,
    "fa-inverse": g,
    "fa-border": y,
    "fa-li": w,
    "fa-flip": v === !0,
    "fa-flip-horizontal": v === "horizontal" || v === "both",
    "fa-flip-vertical": v === "vertical" || v === "both"
  }, "fa-".concat(S), typeof S < "u" && S !== null), "fa-rotate-".concat(E), typeof E < "u" && E !== null && E !== 0), "fa-pull-".concat(A), typeof A < "u" && A !== null), "fa-swap-opacity", k), "fa-rotate-by", N && T), "fa-width-auto", N && R);
  return Object.keys(j).map(function(z) {
    return j[z] ? z : null;
  }).filter(function(z) {
    return z;
  });
}
function oV(e, t) {
  for (var n = e.split("-"), r = qk(n, 2), o = r[0], a = r[1], s = t.split("-"), u = qk(s, 2), c = u[0], f = u[1], h = o.split("."), p = c.split("."), g = 0; g < Math.max(h.length, p.length); g++) {
    var y = h[g] || "0", w = p[g] || "0", v = parseInt(y, 10), S = parseInt(w, 10);
    if (v !== S)
      return v > S;
  }
  for (var E = 0; E < Math.max(h.length, p.length); E++) {
    var A = h[E] || "0", k = p[E] || "0";
    if (A !== k && A.length !== k.length)
      return A.length < k.length;
  }
  return !(a && !f);
}
function iV(e) {
  return e = e - 0, e === e;
}
function hN(e) {
  return iV(e) ? e : (e = e.replace(/[\-_\s]+(.)?/g, function(t, n) {
    return n ? n.toUpperCase() : "";
  }), e.substr(0, 1).toLowerCase() + e.substr(1));
}
var aV = ["style"];
function sV(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
function lV(e) {
  return e.split(";").map(function(t) {
    return t.trim();
  }).filter(function(t) {
    return t;
  }).reduce(function(t, n) {
    var r = n.indexOf(":"), o = hN(n.slice(0, r)), a = n.slice(r + 1).trim();
    return o.startsWith("webkit") ? t[sV(o)] = a : t[o] = a, t;
  }, {});
}
function pN(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (typeof t == "string")
    return t;
  var r = (t.children || []).map(function(c) {
    return pN(e, c);
  }), o = Object.keys(t.attributes || {}).reduce(function(c, f) {
    var h = t.attributes[f];
    switch (f) {
      case "class":
        c.attrs.className = h, delete t.attributes.class;
        break;
      case "style":
        c.attrs.style = lV(h);
        break;
      default:
        f.indexOf("aria-") === 0 || f.indexOf("data-") === 0 ? c.attrs[f.toLowerCase()] = h : c.attrs[hN(f)] = h;
    }
    return c;
  }, {
    attrs: {}
  }), a = n.style, s = a === void 0 ? {} : a, u = ZH(n, aV);
  return o.attrs.style = io(io({}, o.attrs.style), s), e.apply(void 0, [t.tag, io(io({}, o.attrs), u)].concat(hb(r)));
}
var mN = !1;
try {
  mN = !0;
} catch {
}
function uV() {
  if (!mN && console && typeof console.error == "function") {
    var e;
    (e = console).error.apply(e, arguments);
  }
}
function Gk(e) {
  if (e && ip(e) === "object" && e.prefix && e.iconName && e.icon)
    return e;
  if (fb.icon)
    return fb.icon(e);
  if (e === null)
    return null;
  if (e && ip(e) === "object" && e.prefix && e.iconName)
    return e;
  if (Array.isArray(e) && e.length === 2)
    return {
      prefix: e[0],
      iconName: e[1]
    };
  if (typeof e == "string")
    return {
      prefix: "fas",
      iconName: e
    };
}
function Gy(e, t) {
  return Array.isArray(t) && t.length > 0 || !Array.isArray(t) && t ? Yi({}, e, t) : {};
}
var Yk = {
  border: !1,
  className: "",
  mask: null,
  maskId: null,
  // the fixedWidth property has been deprecated as of version 7
  fixedWidth: !1,
  inverse: !1,
  flip: !1,
  icon: null,
  listItem: !1,
  pull: null,
  pulse: !1,
  rotation: null,
  rotateBy: !1,
  size: null,
  spin: !1,
  spinPulse: !1,
  spinReverse: !1,
  beat: !1,
  fade: !1,
  beatFade: !1,
  bounce: !1,
  shake: !1,
  symbol: !1,
  title: "",
  titleId: null,
  transform: null,
  swapOpacity: !1,
  widthAuto: !1
}, G1 = /* @__PURE__ */ nn.forwardRef(function(e, t) {
  var n = io(io({}, Yk), e), r = n.icon, o = n.mask, a = n.symbol, s = n.className, u = n.title, c = n.titleId, f = n.maskId, h = Gk(r), p = Gy("classes", [].concat(hb(rV(n)), hb((s || "").split(" ")))), g = Gy("transform", typeof n.transform == "string" ? fb.transform(n.transform) : n.transform), y = Gy("mask", Gk(o)), w = UH(h, io(io(io(io({}, p), g), y), {}, {
    symbol: a,
    title: u,
    titleId: c,
    maskId: f
  }));
  if (!w)
    return uV("Could not find icon", h), null;
  var v = w.abstract, S = {
    ref: t
  };
  return Object.keys(n).forEach(function(E) {
    Yk.hasOwnProperty(E) || (S[E] = n[E]);
  }), cV(v[0], S);
});
G1.displayName = "FontAwesomeIcon";
G1.propTypes = {
  beat: Ve.bool,
  border: Ve.bool,
  beatFade: Ve.bool,
  bounce: Ve.bool,
  className: Ve.string,
  fade: Ve.bool,
  flash: Ve.bool,
  mask: Ve.oneOfType([Ve.object, Ve.array, Ve.string]),
  maskId: Ve.string,
  // the fixedWidth property has been deprecated as of version 7
  fixedWidth: Ve.bool,
  inverse: Ve.bool,
  flip: Ve.oneOf([!0, !1, "horizontal", "vertical", "both"]),
  icon: Ve.oneOfType([Ve.object, Ve.array, Ve.string]),
  listItem: Ve.bool,
  pull: Ve.oneOf(["right", "left"]),
  pulse: Ve.bool,
  rotation: Ve.oneOf([0, 90, 180, 270]),
  rotateBy: Ve.bool,
  shake: Ve.bool,
  size: Ve.oneOf(["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"]),
  spin: Ve.bool,
  spinPulse: Ve.bool,
  spinReverse: Ve.bool,
  symbol: Ve.oneOfType([Ve.bool, Ve.string]),
  title: Ve.string,
  titleId: Ve.string,
  transform: Ve.oneOfType([Ve.string, Ve.object]),
  swapOpacity: Ve.bool,
  widthAuto: Ve.bool
};
var cV = pN.bind(null, nn.createElement);
/*!
 * Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 * Copyright 2025 Fonticons, Inc.
 */
var fV = {
  prefix: "fas",
  iconName: "magnifying-glass",
  icon: [512, 512, [128269, "search"], "f002", "M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376C296.3 401.1 253.9 416 208 416 93.1 416 0 322.9 0 208S93.1 0 208 0 416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"]
}, dV = {
  prefix: "fas",
  iconName: "chevron-up",
  icon: [448, 512, [], "f077", "M201.4 105.4c12.5-12.5 32.8-12.5 45.3 0l192 192c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L224 173.3 54.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l192-192z"]
}, hV = {
  prefix: "fas",
  iconName: "expand",
  icon: [448, 512, [], "f065", "M32 32C14.3 32 0 46.3 0 64l0 96c0 17.7 14.3 32 32 32s32-14.3 32-32l0-64 64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L32 32zM64 352c0-17.7-14.3-32-32-32S0 334.3 0 352l0 96c0 17.7 14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-64zM320 32c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0 0 64c0 17.7 14.3 32 32 32s32-14.3 32-32l0-96c0-17.7-14.3-32-32-32l-96 0zM448 352c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 64-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32l0-96z"]
}, pV = {
  prefix: "fas",
  iconName: "chevron-right",
  icon: [320, 512, [9002], "f054", "M311.1 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L243.2 256 73.9 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z"]
}, mV = {
  prefix: "fas",
  iconName: "circle-xmark",
  icon: [512, 512, [61532, "times-circle", "xmark-circle"], "f057", "M256 512a256 256 0 1 0 0-512 256 256 0 1 0 0 512zM167 167c9.4-9.4 24.6-9.4 33.9 0l55 55 55-55c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-55 55 55 55c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-55-55-55 55c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l55-55-55-55c-9.4-9.4-9.4-24.6 0-33.9z"]
}, gV = {
  prefix: "fas",
  iconName: "network-wired",
  icon: [576, 512, [], "f6ff", "M248 88l80 0 0 48-80 0 0-48zm-8-56c-26.5 0-48 21.5-48 48l0 64c0 26.5 21.5 48 48 48l16 0 0 32-224 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0 0 32-16 0c-26.5 0-48 21.5-48 48l0 64c0 26.5 21.5 48 48 48l96 0c26.5 0 48-21.5 48-48l0-64c0-26.5-21.5-48-48-48l-16 0 0-32 192 0 0 32-16 0c-26.5 0-48 21.5-48 48l0 64c0 26.5 21.5 48 48 48l96 0c26.5 0 48-21.5 48-48l0-64c0-26.5-21.5-48-48-48l-16 0 0-32 96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-224 0 0-32 16 0c26.5 0 48-21.5 48-48l0-64c0-26.5-21.5-48-48-48l-96 0zM448 376l8 0 0 48-80 0 0-48 72 0zm-256 0l8 0 0 48-80 0 0-48 72 0z"]
}, yV = {
  prefix: "fas",
  iconName: "gear",
  icon: [512, 512, [9881, "cog"], "f013", "M195.1 9.5C198.1-5.3 211.2-16 226.4-16l59.8 0c15.2 0 28.3 10.7 31.3 25.5L332 79.5c14.1 6 27.3 13.7 39.3 22.8l67.8-22.5c14.4-4.8 30.2 1.2 37.8 14.4l29.9 51.8c7.6 13.2 4.9 29.8-6.5 39.9L447 233.3c.9 7.4 1.3 15 1.3 22.7s-.5 15.3-1.3 22.7l53.4 47.5c11.4 10.1 14 26.8 6.5 39.9l-29.9 51.8c-7.6 13.1-23.4 19.2-37.8 14.4l-67.8-22.5c-12.1 9.1-25.3 16.7-39.3 22.8l-14.4 69.9c-3.1 14.9-16.2 25.5-31.3 25.5l-59.8 0c-15.2 0-28.3-10.7-31.3-25.5l-14.4-69.9c-14.1-6-27.2-13.7-39.3-22.8L73.5 432.3c-14.4 4.8-30.2-1.2-37.8-14.4L5.8 366.1c-7.6-13.2-4.9-29.8 6.5-39.9l53.4-47.5c-.9-7.4-1.3-15-1.3-22.7s.5-15.3 1.3-22.7L12.3 185.8c-11.4-10.1-14-26.8-6.5-39.9L35.7 94.1c7.6-13.2 23.4-19.2 37.8-14.4l67.8 22.5c12.1-9.1 25.3-16.7 39.3-22.8L195.1 9.5zM256.3 336a80 80 0 1 0 -.6-160 80 80 0 1 0 .6 160z"]
}, vV = {
  prefix: "fas",
  iconName: "up-right-and-down-left-from-center",
  icon: [512, 512, ["expand-alt"], "f424", "M344 0L488 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39-87 87c-9.4 9.4-24.6 9.4-33.9 0l-32-32c-9.4-9.4-9.4-24.6 0-33.9l87-87-39-39c-6.9-6.9-8.9-17.2-5.2-26.2S334.3 0 344 0zM168 512L24 512c-13.3 0-24-10.7-24-24L0 344c0-9.7 5.8-18.5 14.8-22.2S34.1 320.2 41 327l39 39 87-87c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2S177.7 512 168 512z"]
}, bV = {
  prefix: "fas",
  iconName: "xmark",
  icon: [384, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M55.1 73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L147.2 256 9.9 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192.5 301.3 329.9 438.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.8 256 375.1 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192.5 210.7 55.1 73.4z"]
}, xV = {
  prefix: "fas",
  iconName: "lock-open",
  icon: [576, 512, [], "f3c1", "M384 96c0-35.3 28.7-64 64-64s64 28.7 64 64l0 32c0 17.7 14.3 32 32 32s32-14.3 32-32l0-32c0-70.7-57.3-128-128-128S320 25.3 320 96l0 64-160 0c-35.3 0-64 28.7-64 64l0 224c0 35.3 28.7 64 64 64l256 0c35.3 0 64-28.7 64-64l0-224c0-35.3-28.7-64-64-64l-32 0 0-64z"]
}, wV = {
  prefix: "fas",
  iconName: "circle-check",
  icon: [512, 512, [61533, "check-circle"], "f058", "M256 512a256 256 0 1 0 0-512 256 256 0 1 0 0 512zm84.4-299.3l-80 128c-4.2 6.7-11.4 10.9-19.3 11.3s-15.5-3.2-20.2-9.6l-48-64c-8-10.6-5.8-25.6 4.8-33.6s25.6-5.8 33.6 4.8l27 36 61.4-98.3c7-11.2 21.8-14.7 33.1-7.6s14.7 21.8 7.6 33.1z"]
}, _V = {
  prefix: "fas",
  iconName: "circle-play",
  icon: [512, 512, [61469, "play-circle"], "f144", "M0 256a256 256 0 1 1 512 0 256 256 0 1 1 -512 0zM188.3 147.1c-7.6 4.2-12.3 12.3-12.3 20.9l0 176c0 8.7 4.7 16.7 12.3 20.9s16.8 4.1 24.3-.5l144-88c7.1-4.4 11.5-12.1 11.5-20.5s-4.4-16.1-11.5-20.5l-144-88c-7.4-4.5-16.7-4.7-24.3-.5z"]
}, SV = {
  prefix: "fas",
  iconName: "chevron-down",
  icon: [448, 512, [], "f078", "M201.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 338.7 54.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"]
}, EV = {
  prefix: "fas",
  iconName: "chevron-left",
  icon: [320, 512, [9001], "f053", "M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l192 192c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256 246.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192z"]
}, CV = {
  prefix: "fas",
  iconName: "lock",
  icon: [384, 512, [128274], "f023", "M128 96l0 64 128 0 0-64c0-35.3-28.7-64-64-64s-64 28.7-64 64zM64 160l0-64C64 25.3 121.3-32 192-32S320 25.3 320 96l0 64c35.3 0 64 28.7 64 64l0 224c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64L0 224c0-35.3 28.7-64 64-64z"]
}, kV = {
  prefix: "fas",
  iconName: "down-left-and-up-right-to-center",
  icon: [512, 512, ["compress-alt"], "f422", "M439.5 7c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2S450.2 240 440.5 240l-144 0c-13.3 0-24-10.7-24-24l0-144c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2l39 39 87-87zM72.5 272l144 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39-87 87c-9.4 9.4-24.6 9.4-33.9 0l-32-32c-9.4-9.4-9.4-24.6 0-33.9l87-87-39-39c-6.9-6.9-8.9-17.2-5.2-26.2S62.8 272 72.5 272z"]
}, TV = {
  prefix: "fas",
  iconName: "compress",
  icon: [448, 512, [], "f066", "M160 64c0-17.7-14.3-32-32-32S96 46.3 96 64l0 64-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32l0-96zM32 320c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0 0 64c0 17.7 14.3 32 32 32s32-14.3 32-32l0-96c0-17.7-14.3-32-32-32l-96 0zM352 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-64zM320 320c-17.7 0-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32s32-14.3 32-32l0-64 64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-96 0z"]
}, AV = {
  prefix: "fas",
  iconName: "bars",
  icon: [448, 512, ["navicon"], "f0c9", "M0 96C0 78.3 14.3 64 32 64l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 128C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 288c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32L32 448c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"]
};
VH.autoAddCss = !1;
const rn = (e) => {
  const { style: t, ...n } = e;
  return /* @__PURE__ */ b.jsx("span", { style: t, children: /* @__PURE__ */ b.jsx(G1, { ...n }) });
}, Y1 = (e) => /* @__PURE__ */ b.jsx(rn, { ...e, icon: AV }), jc = (e) => /* @__PURE__ */ b.jsx(rn, { ...e, icon: pV }), ap = (e) => /* @__PURE__ */ b.jsx(rn, { ...e, icon: EV }), gN = (e) => /* @__PURE__ */ b.jsx(rn, { ...e, icon: hV }), RV = (e) => /* @__PURE__ */ b.jsx(rn, { ...e, icon: TV }), MV = (e) => /* @__PURE__ */ b.jsx(rn, { ...e, icon: kV }), OV = (e) => /* @__PURE__ */ b.jsx(rn, { ...e, icon: vV }), Pc = (e) => /* @__PURE__ */ b.jsx(rn, { ...e, icon: SV }), _l = (e) => /* @__PURE__ */ b.jsx(rn, { ...e, icon: dV }), uf = _l, Ic = (e) => /* @__PURE__ */ b.jsx(rn, { ...e, icon: bV }), NV = (e) => /* @__PURE__ */ b.jsx(rn, { ...e, icon: xV }), DV = (e) => /* @__PURE__ */ b.jsx(rn, { ...e, icon: CV }), jV = (e) => /* @__PURE__ */ b.jsx(rn, { ...e, icon: gV }), PV = (e) => /* @__PURE__ */ b.jsx(rn, { ...e, icon: _V }), IV = (e) => /* @__PURE__ */ b.jsx(rn, { ...e, icon: fV }), zV = (e) => /* @__PURE__ */ b.jsx(rn, { ...e, icon: yV }), LV = (e) => /* @__PURE__ */ b.jsx(rn, { ...e, icon: wV }), FV = (e) => /* @__PURE__ */ b.jsx(rn, { ...e, icon: mV }), yN = _.createContext(null), tt = () => {
  const e = _.useContext(yN);
  if (!e)
    throw new Error(
      "useFuncNodesContext must be used within a FuncNodesContext.Provider"
    );
  return e;
}, vN = _.createContext(
  void 0
), W1 = () => {
  const e = _.useContext(vN);
  if (!e)
    throw new Error("useKeyPress must be used within a KeyPressProvider");
  return e;
}, $V = ({
  children: e,
  preventDefault: t = !1,
  ignoredKeys: n = [],
  debug: r = !1,
  target: o
}) => {
  const [a, s] = _.useState(/* @__PURE__ */ new Set()), u = _.useMemo(
    () => new Set(n),
    [n]
  ), c = _.useRef(a);
  c.current = a;
  const f = _.useMemo(
    () => ({
      keys: a,
      isKeyPressed: (h) => a.has(h),
      areKeysPressed: (...h) => h.every((p) => a.has(p)),
      isAnyKeyPressed: (...h) => h.some((p) => a.has(p))
    }),
    [a]
  );
  return _.useEffect(() => {
    const h = o ?? window;
    if (!h) return;
    const p = (v) => {
      const S = v.key;
      u.has(S) || (t && v.preventDefault(), c.current.has(S) || (r && console.log(`[KeyPress] Key down: ${S}`), s((E) => {
        const A = new Set(E);
        return A.add(S), A;
      })));
    }, g = (v) => {
      const S = v.key;
      c.current.has(S) && (r && console.log(`[KeyPress] Key up: ${S}`), s((E) => {
        const A = new Set(E);
        return A.delete(S), A;
      }));
    }, y = () => {
      c.current.size > 0 && (r && console.log("[KeyPress] Window blur - clearing all keys"), s(/* @__PURE__ */ new Set()));
    }, w = () => {
      document.hidden && c.current.size > 0 && (r && console.log("[KeyPress] Tab hidden - clearing all keys"), s(/* @__PURE__ */ new Set()));
    };
    return h.addEventListener("keydown", p), h.addEventListener("keyup", g), h.addEventListener("blur", y), document.addEventListener("visibilitychange", w), () => {
      h.removeEventListener("keydown", p), h.removeEventListener("keyup", g), h.removeEventListener("blur", y), document.removeEventListener("visibilitychange", w);
    };
  }, [t, u, r, o]), /* @__PURE__ */ b.jsx(vN.Provider, { value: f, children: e });
}, bN = _.createContext({
  colorTheme: "classic",
  setColorTheme: () => {
  },
  previewColorTheme: () => {
  }
}), BV = ({
  available_themes: e,
  children: t,
  default_theme: n
}) => {
  const r = _.useMemo(
    () => new Set(e),
    [e]
  ), [o, a] = _.useState(
    n ?? e[0]
  ), s = _.useCallback(
    (f) => {
      if (!r.has(f))
        throw new Error(
          `Theme "${f}" is not in available_themes: [${Array.from(
            r
          ).join(", ")}]`
        );
      a(f);
      const h = {
        colorTheme: f
      };
      try {
        localStorage.setItem("theme", JSON.stringify(h));
      } catch (p) {
        console.warn("Failed to save theme to localStorage:", p);
      }
    },
    [r]
  ), u = _.useCallback(
    (f) => {
      if (!r.has(f))
        throw new Error(
          `Theme "${f}" is not in available_themes: [${Array.from(
            r
          ).join(", ")}]`
        );
      a(f);
    },
    [r]
  );
  _.useEffect(() => {
    document.documentElement.setAttribute("fn-data-color-theme", o);
  }, [o]), _.useEffect(() => {
    try {
      const f = localStorage.getItem("theme");
      if (!f) return;
      const h = JSON.parse(f);
      h.colorTheme && r.has(h.colorTheme) && a(h.colorTheme);
    } catch (f) {
      console.warn("Failed to load theme from localStorage:", f);
    }
  }, [r]), _.useEffect(() => {
    if (n && !r.has(n)) {
      const f = Array.from(r)[0];
      f && s(f);
    }
  }, [r, n, s]), _.useEffect(() => {
    if (!r.has(o)) {
      const f = Array.from(r)[0];
      f && s(f);
    }
  }, [o, r, s]);
  const c = _.useMemo(
    () => ({
      colorTheme: o,
      setColorTheme: s,
      previewColorTheme: u
    }),
    [o, s, u]
  );
  return /* @__PURE__ */ b.jsx(bN.Provider, { value: c, children: t });
}, xN = () => {
  const e = _.useContext(bN);
  if (!e)
    throw new Error("useTheme must be used within a ThemeProvider");
  return e;
}, wN = _.memo(({ button: e, index: t }) => {
  const n = _.useCallback(
    (o) => {
      o.preventDefault(), e.onClick(o);
    },
    [e]
  ), r = /* @__PURE__ */ b.jsx(
    "button",
    {
      className: `dialog-send-button ${e.className || ""}`,
      onClick: n,
      disabled: e.disabled,
      "aria-label": e.ariaLabel,
      type: "button",
      children: e.text
    }
  );
  return e.close !== !1 ? /* @__PURE__ */ b.jsx(fO, { asChild: !0, children: r }, t) : /* @__PURE__ */ b.jsx(_.Fragment, { children: r }, t);
});
wN.displayName = "DialogButton";
const ci = _.memo(
  ({
    trigger: e,
    title: t,
    description: n,
    children: r,
    closebutton: o = !0,
    onOpenChange: a,
    buttons: s = [],
    open: u,
    setOpen: c,
    modal: f = !0,
    dialogClassName: h = "default-dialog-content",
    ariaLabel: p,
    ariaDescription: g
  }) => {
    const w = tt().local_state((A) => A.funcnodescontainerRef), v = _.useMemo(
      () => `dialog-content funcnodescontainer ${h}`,
      [h]
    ), S = _.useCallback(
      (A) => {
        try {
          c?.(A), a?.(A);
        } catch (k) {
          console.error("Error in dialog open change handler:", k);
        }
      },
      [c, a]
    ), E = _.useMemo(
      () => s.map((A, k) => /* @__PURE__ */ b.jsx(
        wN,
        {
          button: A,
          index: k
        },
        `${A.text}-${k}`
      )),
      [s]
    );
    return /* @__PURE__ */ b.jsxs(O$, { open: u, onOpenChange: S, modal: f, children: [
      e && /* @__PURE__ */ b.jsx(N$, { asChild: !0, children: e }),
      /* @__PURE__ */ b.jsxs(D$, { container: w, children: [
        /* @__PURE__ */ b.jsx(j$, { className: "dialog-overlay funcnodescontainer" }),
        /* @__PURE__ */ b.jsx(P$, { asChild: !0, children: /* @__PURE__ */ b.jsxs(
          "div",
          {
            className: v,
            role: "dialog",
            "aria-label": p || t,
            "aria-description": g || (typeof n == "string" ? n : void 0),
            children: [
              t && /* @__PURE__ */ b.jsx(I$, { className: "dialog-title", id: "dialog-title", children: t }),
              n && /* @__PURE__ */ b.jsx(
                z$,
                {
                  className: "dialog-description",
                  id: "dialog-description",
                  children: n
                }
              ),
              /* @__PURE__ */ b.jsx("div", { className: "dialog-children", role: "main", children: r }),
              s.length > 0 && /* @__PURE__ */ b.jsx(
                "div",
                {
                  className: "dialog-buttons",
                  role: "group",
                  "aria-label": "Dialog actions",
                  children: E
                }
              ),
              o && /* @__PURE__ */ b.jsx(fO, { asChild: !0, children: /* @__PURE__ */ b.jsx(
                "button",
                {
                  className: "dialog-close-button",
                  "aria-label": "Close dialog",
                  type: "button",
                  children: /* @__PURE__ */ b.jsx(Ic, {})
                }
              ) })
            ]
          }
        ) })
      ] })
    ] });
  }
);
ci.displayName = "CustomDialog";
const HV = ["top", "right", "bottom", "left"], oa = Math.min, tr = Math.max, sp = Math.round, ah = Math.floor, mo = (e) => ({
  x: e,
  y: e
}), VV = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, UV = {
  start: "end",
  end: "start"
};
function mb(e, t, n) {
  return tr(e, oa(t, n));
}
function ii(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function ai(e) {
  return e.split("-")[0];
}
function Fl(e) {
  return e.split("-")[1];
}
function X1(e) {
  return e === "x" ? "y" : "x";
}
function K1(e) {
  return e === "y" ? "height" : "width";
}
const qV = /* @__PURE__ */ new Set(["top", "bottom"]);
function uo(e) {
  return qV.has(ai(e)) ? "y" : "x";
}
function Z1(e) {
  return X1(uo(e));
}
function GV(e, t, n) {
  n === void 0 && (n = !1);
  const r = Fl(e), o = Z1(e), a = K1(o);
  let s = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[a] > t.floating[a] && (s = lp(s)), [s, lp(s)];
}
function YV(e) {
  const t = lp(e);
  return [gb(e), t, gb(t)];
}
function gb(e) {
  return e.replace(/start|end/g, (t) => UV[t]);
}
const Wk = ["left", "right"], Xk = ["right", "left"], WV = ["top", "bottom"], XV = ["bottom", "top"];
function KV(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? Xk : Wk : t ? Wk : Xk;
    case "left":
    case "right":
      return t ? WV : XV;
    default:
      return [];
  }
}
function ZV(e, t, n, r) {
  const o = Fl(e);
  let a = KV(ai(e), n === "start", r);
  return o && (a = a.map((s) => s + "-" + o), t && (a = a.concat(a.map(gb)))), a;
}
function lp(e) {
  return e.replace(/left|right|bottom|top/g, (t) => VV[t]);
}
function QV(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function _N(e) {
  return typeof e != "number" ? QV(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function up(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: o
  } = e;
  return {
    width: r,
    height: o,
    top: n,
    left: t,
    right: t + r,
    bottom: n + o,
    x: t,
    y: n
  };
}
function Kk(e, t, n) {
  let {
    reference: r,
    floating: o
  } = e;
  const a = uo(t), s = Z1(t), u = K1(s), c = ai(t), f = a === "y", h = r.x + r.width / 2 - o.width / 2, p = r.y + r.height / 2 - o.height / 2, g = r[u] / 2 - o[u] / 2;
  let y;
  switch (c) {
    case "top":
      y = {
        x: h,
        y: r.y - o.height
      };
      break;
    case "bottom":
      y = {
        x: h,
        y: r.y + r.height
      };
      break;
    case "right":
      y = {
        x: r.x + r.width,
        y: p
      };
      break;
    case "left":
      y = {
        x: r.x - o.width,
        y: p
      };
      break;
    default:
      y = {
        x: r.x,
        y: r.y
      };
  }
  switch (Fl(t)) {
    case "start":
      y[s] -= g * (n && f ? -1 : 1);
      break;
    case "end":
      y[s] += g * (n && f ? -1 : 1);
      break;
  }
  return y;
}
const JV = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: o = "absolute",
    middleware: a = [],
    platform: s
  } = n, u = a.filter(Boolean), c = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let f = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: o
  }), {
    x: h,
    y: p
  } = Kk(f, r, c), g = r, y = {}, w = 0;
  for (let v = 0; v < u.length; v++) {
    const {
      name: S,
      fn: E
    } = u[v], {
      x: A,
      y: k,
      data: T,
      reset: R
    } = await E({
      x: h,
      y: p,
      initialPlacement: r,
      placement: g,
      strategy: o,
      middlewareData: y,
      rects: f,
      platform: s,
      elements: {
        reference: e,
        floating: t
      }
    });
    h = A ?? h, p = k ?? p, y = {
      ...y,
      [S]: {
        ...y[S],
        ...T
      }
    }, R && w <= 50 && (w++, typeof R == "object" && (R.placement && (g = R.placement), R.rects && (f = R.rects === !0 ? await s.getElementRects({
      reference: e,
      floating: t,
      strategy: o
    }) : R.rects), {
      x: h,
      y: p
    } = Kk(f, g, c)), v = -1);
  }
  return {
    x: h,
    y: p,
    placement: g,
    strategy: o,
    middlewareData: y
  };
};
async function zc(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: o,
    platform: a,
    rects: s,
    elements: u,
    strategy: c
  } = e, {
    boundary: f = "clippingAncestors",
    rootBoundary: h = "viewport",
    elementContext: p = "floating",
    altBoundary: g = !1,
    padding: y = 0
  } = ii(t, e), w = _N(y), S = u[g ? p === "floating" ? "reference" : "floating" : p], E = up(await a.getClippingRect({
    element: (n = await (a.isElement == null ? void 0 : a.isElement(S))) == null || n ? S : S.contextElement || await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(u.floating)),
    boundary: f,
    rootBoundary: h,
    strategy: c
  })), A = p === "floating" ? {
    x: r,
    y: o,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, k = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(u.floating)), T = await (a.isElement == null ? void 0 : a.isElement(k)) ? await (a.getScale == null ? void 0 : a.getScale(k)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, R = up(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: u,
    rect: A,
    offsetParent: k,
    strategy: c
  }) : A);
  return {
    top: (E.top - R.top + w.top) / T.y,
    bottom: (R.bottom - E.bottom + w.bottom) / T.y,
    left: (E.left - R.left + w.left) / T.x,
    right: (R.right - E.right + w.right) / T.x
  };
}
const eU = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: o,
      rects: a,
      platform: s,
      elements: u,
      middlewareData: c
    } = t, {
      element: f,
      padding: h = 0
    } = ii(e, t) || {};
    if (f == null)
      return {};
    const p = _N(h), g = {
      x: n,
      y: r
    }, y = Z1(o), w = K1(y), v = await s.getDimensions(f), S = y === "y", E = S ? "top" : "left", A = S ? "bottom" : "right", k = S ? "clientHeight" : "clientWidth", T = a.reference[w] + a.reference[y] - g[y] - a.floating[w], R = g[y] - a.reference[y], N = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(f));
    let j = N ? N[k] : 0;
    (!j || !await (s.isElement == null ? void 0 : s.isElement(N))) && (j = u.floating[k] || a.floating[w]);
    const z = T / 2 - R / 2, B = j / 2 - v[w] / 2 - 1, M = oa(p[E], B), F = oa(p[A], B), q = M, Y = j - v[w] - F, P = j / 2 - v[w] / 2 + z, V = mb(q, P, Y), I = !c.arrow && Fl(o) != null && P !== V && a.reference[w] / 2 - (P < q ? M : F) - v[w] / 2 < 0, U = I ? P < q ? P - q : P - Y : 0;
    return {
      [y]: g[y] + U,
      data: {
        [y]: V,
        centerOffset: P - V - U,
        ...I && {
          alignmentOffset: U
        }
      },
      reset: I
    };
  }
}), tU = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: o,
        middlewareData: a,
        rects: s,
        initialPlacement: u,
        platform: c,
        elements: f
      } = t, {
        mainAxis: h = !0,
        crossAxis: p = !0,
        fallbackPlacements: g,
        fallbackStrategy: y = "bestFit",
        fallbackAxisSideDirection: w = "none",
        flipAlignment: v = !0,
        ...S
      } = ii(e, t);
      if ((n = a.arrow) != null && n.alignmentOffset)
        return {};
      const E = ai(o), A = uo(u), k = ai(u) === u, T = await (c.isRTL == null ? void 0 : c.isRTL(f.floating)), R = g || (k || !v ? [lp(u)] : YV(u)), N = w !== "none";
      !g && N && R.push(...ZV(u, v, w, T));
      const j = [u, ...R], z = await zc(t, S), B = [];
      let M = ((r = a.flip) == null ? void 0 : r.overflows) || [];
      if (h && B.push(z[E]), p) {
        const P = GV(o, s, T);
        B.push(z[P[0]], z[P[1]]);
      }
      if (M = [...M, {
        placement: o,
        overflows: B
      }], !B.every((P) => P <= 0)) {
        var F, q;
        const P = (((F = a.flip) == null ? void 0 : F.index) || 0) + 1, V = j[P];
        if (V && (!(p === "alignment" ? A !== uo(V) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        M.every((H) => H.overflows[0] > 0 && uo(H.placement) === A)))
          return {
            data: {
              index: P,
              overflows: M
            },
            reset: {
              placement: V
            }
          };
        let I = (q = M.filter((U) => U.overflows[0] <= 0).sort((U, H) => U.overflows[1] - H.overflows[1])[0]) == null ? void 0 : q.placement;
        if (!I)
          switch (y) {
            case "bestFit": {
              var Y;
              const U = (Y = M.filter((H) => {
                if (N) {
                  const G = uo(H.placement);
                  return G === A || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  G === "y";
                }
                return !0;
              }).map((H) => [H.placement, H.overflows.filter((G) => G > 0).reduce((G, O) => G + O, 0)]).sort((H, G) => H[1] - G[1])[0]) == null ? void 0 : Y[0];
              U && (I = U);
              break;
            }
            case "initialPlacement":
              I = u;
              break;
          }
        if (o !== I)
          return {
            reset: {
              placement: I
            }
          };
      }
      return {};
    }
  };
};
function Zk(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function Qk(e) {
  return HV.some((t) => e[t] >= 0);
}
const nU = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: r = "referenceHidden",
        ...o
      } = ii(e, t);
      switch (r) {
        case "referenceHidden": {
          const a = await zc(t, {
            ...o,
            elementContext: "reference"
          }), s = Zk(a, n.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: Qk(s)
            }
          };
        }
        case "escaped": {
          const a = await zc(t, {
            ...o,
            altBoundary: !0
          }), s = Zk(a, n.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: Qk(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, SN = /* @__PURE__ */ new Set(["left", "top"]);
async function rU(e, t) {
  const {
    placement: n,
    platform: r,
    elements: o
  } = e, a = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)), s = ai(n), u = Fl(n), c = uo(n) === "y", f = SN.has(s) ? -1 : 1, h = a && c ? -1 : 1, p = ii(t, e);
  let {
    mainAxis: g,
    crossAxis: y,
    alignmentAxis: w
  } = typeof p == "number" ? {
    mainAxis: p,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: p.mainAxis || 0,
    crossAxis: p.crossAxis || 0,
    alignmentAxis: p.alignmentAxis
  };
  return u && typeof w == "number" && (y = u === "end" ? w * -1 : w), c ? {
    x: y * h,
    y: g * f
  } : {
    x: g * f,
    y: y * h
  };
}
const oU = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: o,
        y: a,
        placement: s,
        middlewareData: u
      } = t, c = await rU(t, e);
      return s === ((n = u.offset) == null ? void 0 : n.placement) && (r = u.arrow) != null && r.alignmentOffset ? {} : {
        x: o + c.x,
        y: a + c.y,
        data: {
          ...c,
          placement: s
        }
      };
    }
  };
}, iU = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: o
      } = t, {
        mainAxis: a = !0,
        crossAxis: s = !1,
        limiter: u = {
          fn: (S) => {
            let {
              x: E,
              y: A
            } = S;
            return {
              x: E,
              y: A
            };
          }
        },
        ...c
      } = ii(e, t), f = {
        x: n,
        y: r
      }, h = await zc(t, c), p = uo(ai(o)), g = X1(p);
      let y = f[g], w = f[p];
      if (a) {
        const S = g === "y" ? "top" : "left", E = g === "y" ? "bottom" : "right", A = y + h[S], k = y - h[E];
        y = mb(A, y, k);
      }
      if (s) {
        const S = p === "y" ? "top" : "left", E = p === "y" ? "bottom" : "right", A = w + h[S], k = w - h[E];
        w = mb(A, w, k);
      }
      const v = u.fn({
        ...t,
        [g]: y,
        [p]: w
      });
      return {
        ...v,
        data: {
          x: v.x - n,
          y: v.y - r,
          enabled: {
            [g]: a,
            [p]: s
          }
        }
      };
    }
  };
}, aU = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: r,
        placement: o,
        rects: a,
        middlewareData: s
      } = t, {
        offset: u = 0,
        mainAxis: c = !0,
        crossAxis: f = !0
      } = ii(e, t), h = {
        x: n,
        y: r
      }, p = uo(o), g = X1(p);
      let y = h[g], w = h[p];
      const v = ii(u, t), S = typeof v == "number" ? {
        mainAxis: v,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...v
      };
      if (c) {
        const k = g === "y" ? "height" : "width", T = a.reference[g] - a.floating[k] + S.mainAxis, R = a.reference[g] + a.reference[k] - S.mainAxis;
        y < T ? y = T : y > R && (y = R);
      }
      if (f) {
        var E, A;
        const k = g === "y" ? "width" : "height", T = SN.has(ai(o)), R = a.reference[p] - a.floating[k] + (T && ((E = s.offset) == null ? void 0 : E[p]) || 0) + (T ? 0 : S.crossAxis), N = a.reference[p] + a.reference[k] + (T ? 0 : ((A = s.offset) == null ? void 0 : A[p]) || 0) - (T ? S.crossAxis : 0);
        w < R ? w = R : w > N && (w = N);
      }
      return {
        [g]: y,
        [p]: w
      };
    }
  };
}, sU = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: o,
        rects: a,
        platform: s,
        elements: u
      } = t, {
        apply: c = () => {
        },
        ...f
      } = ii(e, t), h = await zc(t, f), p = ai(o), g = Fl(o), y = uo(o) === "y", {
        width: w,
        height: v
      } = a.floating;
      let S, E;
      p === "top" || p === "bottom" ? (S = p, E = g === (await (s.isRTL == null ? void 0 : s.isRTL(u.floating)) ? "start" : "end") ? "left" : "right") : (E = p, S = g === "end" ? "top" : "bottom");
      const A = v - h.top - h.bottom, k = w - h.left - h.right, T = oa(v - h[S], A), R = oa(w - h[E], k), N = !t.middlewareData.shift;
      let j = T, z = R;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (z = k), (r = t.middlewareData.shift) != null && r.enabled.y && (j = A), N && !g) {
        const M = tr(h.left, 0), F = tr(h.right, 0), q = tr(h.top, 0), Y = tr(h.bottom, 0);
        y ? z = w - 2 * (M !== 0 || F !== 0 ? M + F : tr(h.left, h.right)) : j = v - 2 * (q !== 0 || Y !== 0 ? q + Y : tr(h.top, h.bottom));
      }
      await c({
        ...t,
        availableWidth: z,
        availableHeight: j
      });
      const B = await s.getDimensions(u.floating);
      return w !== B.width || v !== B.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function gm() {
  return typeof window < "u";
}
function $l(e) {
  return EN(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function ar(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function So(e) {
  var t;
  return (t = (EN(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function EN(e) {
  return gm() ? e instanceof Node || e instanceof ar(e).Node : !1;
}
function Fr(e) {
  return gm() ? e instanceof Element || e instanceof ar(e).Element : !1;
}
function yo(e) {
  return gm() ? e instanceof HTMLElement || e instanceof ar(e).HTMLElement : !1;
}
function Jk(e) {
  return !gm() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof ar(e).ShadowRoot;
}
const lU = /* @__PURE__ */ new Set(["inline", "contents"]);
function cf(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: o
  } = $r(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !lU.has(o);
}
const uU = /* @__PURE__ */ new Set(["table", "td", "th"]);
function cU(e) {
  return uU.has($l(e));
}
const fU = [":popover-open", ":modal"];
function ym(e) {
  return fU.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const dU = ["transform", "translate", "scale", "rotate", "perspective"], hU = ["transform", "translate", "scale", "rotate", "perspective", "filter"], pU = ["paint", "layout", "strict", "content"];
function Q1(e) {
  const t = J1(), n = Fr(e) ? $r(e) : e;
  return dU.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || hU.some((r) => (n.willChange || "").includes(r)) || pU.some((r) => (n.contain || "").includes(r));
}
function mU(e) {
  let t = ia(e);
  for (; yo(t) && !Sl(t); ) {
    if (Q1(t))
      return t;
    if (ym(t))
      return null;
    t = ia(t);
  }
  return null;
}
function J1() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const gU = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function Sl(e) {
  return gU.has($l(e));
}
function $r(e) {
  return ar(e).getComputedStyle(e);
}
function vm(e) {
  return Fr(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function ia(e) {
  if ($l(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Jk(e) && e.host || // Fallback.
    So(e)
  );
  return Jk(t) ? t.host : t;
}
function CN(e) {
  const t = ia(e);
  return Sl(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : yo(t) && cf(t) ? t : CN(t);
}
function Lc(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const o = CN(e), a = o === ((r = e.ownerDocument) == null ? void 0 : r.body), s = ar(o);
  if (a) {
    const u = yb(s);
    return t.concat(s, s.visualViewport || [], cf(o) ? o : [], u && n ? Lc(u) : []);
  }
  return t.concat(o, Lc(o, [], n));
}
function yb(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function kN(e) {
  const t = $r(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const o = yo(e), a = o ? e.offsetWidth : n, s = o ? e.offsetHeight : r, u = sp(n) !== a || sp(r) !== s;
  return u && (n = a, r = s), {
    width: n,
    height: r,
    $: u
  };
}
function ex(e) {
  return Fr(e) ? e : e.contextElement;
}
function fl(e) {
  const t = ex(e);
  if (!yo(t))
    return mo(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: o,
    $: a
  } = kN(t);
  let s = (a ? sp(n.width) : n.width) / r, u = (a ? sp(n.height) : n.height) / o;
  return (!s || !Number.isFinite(s)) && (s = 1), (!u || !Number.isFinite(u)) && (u = 1), {
    x: s,
    y: u
  };
}
const yU = /* @__PURE__ */ mo(0);
function TN(e) {
  const t = ar(e);
  return !J1() || !t.visualViewport ? yU : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function vU(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== ar(e) ? !1 : t;
}
function Ya(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const o = e.getBoundingClientRect(), a = ex(e);
  let s = mo(1);
  t && (r ? Fr(r) && (s = fl(r)) : s = fl(e));
  const u = vU(a, n, r) ? TN(a) : mo(0);
  let c = (o.left + u.x) / s.x, f = (o.top + u.y) / s.y, h = o.width / s.x, p = o.height / s.y;
  if (a) {
    const g = ar(a), y = r && Fr(r) ? ar(r) : r;
    let w = g, v = yb(w);
    for (; v && r && y !== w; ) {
      const S = fl(v), E = v.getBoundingClientRect(), A = $r(v), k = E.left + (v.clientLeft + parseFloat(A.paddingLeft)) * S.x, T = E.top + (v.clientTop + parseFloat(A.paddingTop)) * S.y;
      c *= S.x, f *= S.y, h *= S.x, p *= S.y, c += k, f += T, w = ar(v), v = yb(w);
    }
  }
  return up({
    width: h,
    height: p,
    x: c,
    y: f
  });
}
function tx(e, t) {
  const n = vm(e).scrollLeft;
  return t ? t.left + n : Ya(So(e)).left + n;
}
function AN(e, t, n) {
  n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), o = r.left + t.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    tx(e, r)
  )), a = r.top + t.scrollTop;
  return {
    x: o,
    y: a
  };
}
function bU(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: o
  } = e;
  const a = o === "fixed", s = So(r), u = t ? ym(t.floating) : !1;
  if (r === s || u && a)
    return n;
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  }, f = mo(1);
  const h = mo(0), p = yo(r);
  if ((p || !p && !a) && (($l(r) !== "body" || cf(s)) && (c = vm(r)), yo(r))) {
    const y = Ya(r);
    f = fl(r), h.x = y.x + r.clientLeft, h.y = y.y + r.clientTop;
  }
  const g = s && !p && !a ? AN(s, c, !0) : mo(0);
  return {
    width: n.width * f.x,
    height: n.height * f.y,
    x: n.x * f.x - c.scrollLeft * f.x + h.x + g.x,
    y: n.y * f.y - c.scrollTop * f.y + h.y + g.y
  };
}
function xU(e) {
  return Array.from(e.getClientRects());
}
function wU(e) {
  const t = So(e), n = vm(e), r = e.ownerDocument.body, o = tr(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), a = tr(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -n.scrollLeft + tx(e);
  const u = -n.scrollTop;
  return $r(r).direction === "rtl" && (s += tr(t.clientWidth, r.clientWidth) - o), {
    width: o,
    height: a,
    x: s,
    y: u
  };
}
function _U(e, t) {
  const n = ar(e), r = So(e), o = n.visualViewport;
  let a = r.clientWidth, s = r.clientHeight, u = 0, c = 0;
  if (o) {
    a = o.width, s = o.height;
    const f = J1();
    (!f || f && t === "fixed") && (u = o.offsetLeft, c = o.offsetTop);
  }
  return {
    width: a,
    height: s,
    x: u,
    y: c
  };
}
const SU = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function EU(e, t) {
  const n = Ya(e, !0, t === "fixed"), r = n.top + e.clientTop, o = n.left + e.clientLeft, a = yo(e) ? fl(e) : mo(1), s = e.clientWidth * a.x, u = e.clientHeight * a.y, c = o * a.x, f = r * a.y;
  return {
    width: s,
    height: u,
    x: c,
    y: f
  };
}
function eT(e, t, n) {
  let r;
  if (t === "viewport")
    r = _U(e, n);
  else if (t === "document")
    r = wU(So(e));
  else if (Fr(t))
    r = EU(t, n);
  else {
    const o = TN(e);
    r = {
      x: t.x - o.x,
      y: t.y - o.y,
      width: t.width,
      height: t.height
    };
  }
  return up(r);
}
function RN(e, t) {
  const n = ia(e);
  return n === t || !Fr(n) || Sl(n) ? !1 : $r(n).position === "fixed" || RN(n, t);
}
function CU(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = Lc(e, [], !1).filter((u) => Fr(u) && $l(u) !== "body"), o = null;
  const a = $r(e).position === "fixed";
  let s = a ? ia(e) : e;
  for (; Fr(s) && !Sl(s); ) {
    const u = $r(s), c = Q1(s);
    !c && u.position === "fixed" && (o = null), (a ? !c && !o : !c && u.position === "static" && !!o && SU.has(o.position) || cf(s) && !c && RN(e, s)) ? r = r.filter((h) => h !== s) : o = u, s = ia(s);
  }
  return t.set(e, r), r;
}
function kU(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: o
  } = e;
  const s = [...n === "clippingAncestors" ? ym(t) ? [] : CU(t, this._c) : [].concat(n), r], u = s[0], c = s.reduce((f, h) => {
    const p = eT(t, h, o);
    return f.top = tr(p.top, f.top), f.right = oa(p.right, f.right), f.bottom = oa(p.bottom, f.bottom), f.left = tr(p.left, f.left), f;
  }, eT(t, u, o));
  return {
    width: c.right - c.left,
    height: c.bottom - c.top,
    x: c.left,
    y: c.top
  };
}
function TU(e) {
  const {
    width: t,
    height: n
  } = kN(e);
  return {
    width: t,
    height: n
  };
}
function AU(e, t, n) {
  const r = yo(t), o = So(t), a = n === "fixed", s = Ya(e, !0, a, t);
  let u = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const c = mo(0);
  function f() {
    c.x = tx(o);
  }
  if (r || !r && !a)
    if (($l(t) !== "body" || cf(o)) && (u = vm(t)), r) {
      const y = Ya(t, !0, a, t);
      c.x = y.x + t.clientLeft, c.y = y.y + t.clientTop;
    } else o && f();
  a && !r && o && f();
  const h = o && !r && !a ? AN(o, u) : mo(0), p = s.left + u.scrollLeft - c.x - h.x, g = s.top + u.scrollTop - c.y - h.y;
  return {
    x: p,
    y: g,
    width: s.width,
    height: s.height
  };
}
function Yy(e) {
  return $r(e).position === "static";
}
function tT(e, t) {
  if (!yo(e) || $r(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return So(e) === n && (n = n.ownerDocument.body), n;
}
function MN(e, t) {
  const n = ar(e);
  if (ym(e))
    return n;
  if (!yo(e)) {
    let o = ia(e);
    for (; o && !Sl(o); ) {
      if (Fr(o) && !Yy(o))
        return o;
      o = ia(o);
    }
    return n;
  }
  let r = tT(e, t);
  for (; r && cU(r) && Yy(r); )
    r = tT(r, t);
  return r && Sl(r) && Yy(r) && !Q1(r) ? n : r || mU(e) || n;
}
const RU = async function(e) {
  const t = this.getOffsetParent || MN, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: AU(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function MU(e) {
  return $r(e).direction === "rtl";
}
const OU = {
  convertOffsetParentRelativeRectToViewportRelativeRect: bU,
  getDocumentElement: So,
  getClippingRect: kU,
  getOffsetParent: MN,
  getElementRects: RU,
  getClientRects: xU,
  getDimensions: TU,
  getScale: fl,
  isElement: Fr,
  isRTL: MU
};
function ON(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function NU(e, t) {
  let n = null, r;
  const o = So(e);
  function a() {
    var u;
    clearTimeout(r), (u = n) == null || u.disconnect(), n = null;
  }
  function s(u, c) {
    u === void 0 && (u = !1), c === void 0 && (c = 1), a();
    const f = e.getBoundingClientRect(), {
      left: h,
      top: p,
      width: g,
      height: y
    } = f;
    if (u || t(), !g || !y)
      return;
    const w = ah(p), v = ah(o.clientWidth - (h + g)), S = ah(o.clientHeight - (p + y)), E = ah(h), k = {
      rootMargin: -w + "px " + -v + "px " + -S + "px " + -E + "px",
      threshold: tr(0, oa(1, c)) || 1
    };
    let T = !0;
    function R(N) {
      const j = N[0].intersectionRatio;
      if (j !== c) {
        if (!T)
          return s();
        j ? s(!1, j) : r = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      j === 1 && !ON(f, e.getBoundingClientRect()) && s(), T = !1;
    }
    try {
      n = new IntersectionObserver(R, {
        ...k,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(R, k);
    }
    n.observe(e);
  }
  return s(!0), a;
}
function NN(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: a = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: u = typeof IntersectionObserver == "function",
    animationFrame: c = !1
  } = r, f = ex(e), h = o || a ? [...f ? Lc(f) : [], ...Lc(t)] : [];
  h.forEach((E) => {
    o && E.addEventListener("scroll", n, {
      passive: !0
    }), a && E.addEventListener("resize", n);
  });
  const p = f && u ? NU(f, n) : null;
  let g = -1, y = null;
  s && (y = new ResizeObserver((E) => {
    let [A] = E;
    A && A.target === f && y && (y.unobserve(t), cancelAnimationFrame(g), g = requestAnimationFrame(() => {
      var k;
      (k = y) == null || k.observe(t);
    })), n();
  }), f && !c && y.observe(f), y.observe(t));
  let w, v = c ? Ya(e) : null;
  c && S();
  function S() {
    const E = Ya(e);
    v && !ON(v, E) && n(), v = E, w = requestAnimationFrame(S);
  }
  return n(), () => {
    var E;
    h.forEach((A) => {
      o && A.removeEventListener("scroll", n), a && A.removeEventListener("resize", n);
    }), p?.(), (E = y) == null || E.disconnect(), y = null, c && cancelAnimationFrame(w);
  };
}
const DU = oU, jU = iU, PU = tU, IU = sU, zU = nU, nT = eU, LU = aU, FU = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), o = {
    platform: OU,
    ...n
  }, a = {
    ...o.platform,
    _c: r
  };
  return JV(e, t, {
    ...o,
    platform: a
  });
};
var $U = typeof document < "u", BU = function() {
}, $h = $U ? _.useLayoutEffect : BU;
function cp(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, o;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!cp(e[r], t[r]))
          return !1;
      return !0;
    }
    if (o = Object.keys(e), n = o.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, o[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const a = o[r];
      if (!(a === "_owner" && e.$$typeof) && !cp(e[a], t[a]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function DN(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function rT(e, t) {
  const n = DN(e);
  return Math.round(t * n) / n;
}
function Wy(e) {
  const t = _.useRef(e);
  return $h(() => {
    t.current = e;
  }), t;
}
function HU(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: o,
    elements: {
      reference: a,
      floating: s
    } = {},
    transform: u = !0,
    whileElementsMounted: c,
    open: f
  } = e, [h, p] = _.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [g, y] = _.useState(r);
  cp(g, r) || y(r);
  const [w, v] = _.useState(null), [S, E] = _.useState(null), A = _.useCallback((H) => {
    H !== N.current && (N.current = H, v(H));
  }, []), k = _.useCallback((H) => {
    H !== j.current && (j.current = H, E(H));
  }, []), T = a || w, R = s || S, N = _.useRef(null), j = _.useRef(null), z = _.useRef(h), B = c != null, M = Wy(c), F = Wy(o), q = Wy(f), Y = _.useCallback(() => {
    if (!N.current || !j.current)
      return;
    const H = {
      placement: t,
      strategy: n,
      middleware: g
    };
    F.current && (H.platform = F.current), FU(N.current, j.current, H).then((G) => {
      const O = {
        ...G,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: q.current !== !1
      };
      P.current && !cp(z.current, O) && (z.current = O, Pl.flushSync(() => {
        p(O);
      }));
    });
  }, [g, t, n, F, q]);
  $h(() => {
    f === !1 && z.current.isPositioned && (z.current.isPositioned = !1, p((H) => ({
      ...H,
      isPositioned: !1
    })));
  }, [f]);
  const P = _.useRef(!1);
  $h(() => (P.current = !0, () => {
    P.current = !1;
  }), []), $h(() => {
    if (T && (N.current = T), R && (j.current = R), T && R) {
      if (M.current)
        return M.current(T, R, Y);
      Y();
    }
  }, [T, R, Y, M, B]);
  const V = _.useMemo(() => ({
    reference: N,
    floating: j,
    setReference: A,
    setFloating: k
  }), [A, k]), I = _.useMemo(() => ({
    reference: T,
    floating: R
  }), [T, R]), U = _.useMemo(() => {
    const H = {
      position: n,
      left: 0,
      top: 0
    };
    if (!I.floating)
      return H;
    const G = rT(I.floating, h.x), O = rT(I.floating, h.y);
    return u ? {
      ...H,
      transform: "translate(" + G + "px, " + O + "px)",
      ...DN(I.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: G,
      top: O
    };
  }, [n, u, I.floating, h.x, h.y]);
  return _.useMemo(() => ({
    ...h,
    update: Y,
    refs: V,
    elements: I,
    floatingStyles: U
  }), [h, Y, V, I, U]);
}
const VU = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: r,
        padding: o
      } = typeof e == "function" ? e(n) : e;
      return r && t(r) ? r.current != null ? nT({
        element: r.current,
        padding: o
      }).fn(n) : {} : r ? nT({
        element: r,
        padding: o
      }).fn(n) : {};
    }
  };
}, UU = (e, t) => ({
  ...DU(e),
  options: [e, t]
}), qU = (e, t) => ({
  ...jU(e),
  options: [e, t]
}), GU = (e, t) => ({
  ...LU(e),
  options: [e, t]
}), YU = (e, t) => ({
  ...PU(e),
  options: [e, t]
}), WU = (e, t) => ({
  ...IU(e),
  options: [e, t]
}), XU = (e, t) => ({
  ...zU(e),
  options: [e, t]
}), KU = (e, t) => ({
  ...VU(e),
  options: [e, t]
});
var ZU = "Arrow", jN = _.forwardRef((e, t) => {
  const { children: n, width: r = 10, height: o = 5, ...a } = e;
  return /* @__PURE__ */ b.jsx(
    qe.svg,
    {
      ...a,
      ref: t,
      width: r,
      height: o,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : /* @__PURE__ */ b.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
jN.displayName = ZU;
var QU = jN;
function PN(e) {
  const [t, n] = _.useState(void 0);
  return ni(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const r = new ResizeObserver((o) => {
        if (!Array.isArray(o) || !o.length)
          return;
        const a = o[0];
        let s, u;
        if ("borderBoxSize" in a) {
          const c = a.borderBoxSize, f = Array.isArray(c) ? c[0] : c;
          s = f.inlineSize, u = f.blockSize;
        } else
          s = e.offsetWidth, u = e.offsetHeight;
        n({ width: s, height: u });
      });
      return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
var nx = "Popper", [IN, bm] = _o(nx), [JU, zN] = IN(nx), LN = (e) => {
  const { __scopePopper: t, children: n } = e, [r, o] = _.useState(null);
  return /* @__PURE__ */ b.jsx(JU, { scope: t, anchor: r, onAnchorChange: o, children: n });
};
LN.displayName = nx;
var FN = "PopperAnchor", $N = _.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: r, ...o } = e, a = zN(FN, n), s = _.useRef(null), u = bt(t, s);
    return _.useEffect(() => {
      a.onAnchorChange(r?.current || s.current);
    }), r ? null : /* @__PURE__ */ b.jsx(qe.div, { ...o, ref: u });
  }
);
$N.displayName = FN;
var rx = "PopperContent", [eq, tq] = IN(rx), BN = _.forwardRef(
  (e, t) => {
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: o = 0,
      align: a = "center",
      alignOffset: s = 0,
      arrowPadding: u = 0,
      avoidCollisions: c = !0,
      collisionBoundary: f = [],
      collisionPadding: h = 0,
      sticky: p = "partial",
      hideWhenDetached: g = !1,
      updatePositionStrategy: y = "optimized",
      onPlaced: w,
      ...v
    } = e, S = zN(rx, n), [E, A] = _.useState(null), k = bt(t, (fe) => A(fe)), [T, R] = _.useState(null), N = PN(T), j = N?.width ?? 0, z = N?.height ?? 0, B = r + (a !== "center" ? "-" + a : ""), M = typeof h == "number" ? h : { top: 0, right: 0, bottom: 0, left: 0, ...h }, F = Array.isArray(f) ? f : [f], q = F.length > 0, Y = {
      padding: M,
      boundary: F.filter(rq),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: q
    }, { refs: P, floatingStyles: V, placement: I, isPositioned: U, middlewareData: H } = HU({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: B,
      whileElementsMounted: (...fe) => NN(...fe, {
        animationFrame: y === "always"
      }),
      elements: {
        reference: S.anchor
      },
      middleware: [
        UU({ mainAxis: o + z, alignmentAxis: s }),
        c && qU({
          mainAxis: !0,
          crossAxis: !1,
          limiter: p === "partial" ? GU() : void 0,
          ...Y
        }),
        c && YU({ ...Y }),
        WU({
          ...Y,
          apply: ({ elements: fe, rects: ae, availableWidth: ye, availableHeight: Ne }) => {
            const { width: De, height: we } = ae.reference, Ce = fe.floating.style;
            Ce.setProperty("--radix-popper-available-width", `${ye}px`), Ce.setProperty("--radix-popper-available-height", `${Ne}px`), Ce.setProperty("--radix-popper-anchor-width", `${De}px`), Ce.setProperty("--radix-popper-anchor-height", `${we}px`);
          }
        }),
        T && KU({ element: T, padding: u }),
        oq({ arrowWidth: j, arrowHeight: z }),
        g && XU({ strategy: "referenceHidden", ...Y })
      ]
    }), [G, O] = UN(I), W = Hn(w);
    ni(() => {
      U && W?.();
    }, [U, W]);
    const Z = H.arrow?.x, L = H.arrow?.y, te = H.arrow?.centerOffset !== 0, [he, oe] = _.useState();
    return ni(() => {
      E && oe(window.getComputedStyle(E).zIndex);
    }, [E]), /* @__PURE__ */ b.jsx(
      "div",
      {
        ref: P.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...V,
          transform: U ? V.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: he,
          "--radix-popper-transform-origin": [
            H.transformOrigin?.x,
            H.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...H.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ b.jsx(
          eq,
          {
            scope: n,
            placedSide: G,
            onArrowChange: R,
            arrowX: Z,
            arrowY: L,
            shouldHideArrow: te,
            children: /* @__PURE__ */ b.jsx(
              qe.div,
              {
                "data-side": G,
                "data-align": O,
                ...v,
                ref: k,
                style: {
                  ...v.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: U ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
BN.displayName = rx;
var HN = "PopperArrow", nq = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, VN = _.forwardRef(function(t, n) {
  const { __scopePopper: r, ...o } = t, a = tq(HN, r), s = nq[a.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ b.jsx(
      "span",
      {
        ref: a.onArrowChange,
        style: {
          position: "absolute",
          left: a.arrowX,
          top: a.arrowY,
          [s]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[a.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[a.placedSide],
          visibility: a.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ b.jsx(
          QU,
          {
            ...o,
            ref: n,
            style: {
              ...o.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
VN.displayName = HN;
function rq(e) {
  return e !== null;
}
var oq = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    const { placement: n, rects: r, middlewareData: o } = t, s = o.arrow?.centerOffset !== 0, u = s ? 0 : e.arrowWidth, c = s ? 0 : e.arrowHeight, [f, h] = UN(n), p = { start: "0%", center: "50%", end: "100%" }[h], g = (o.arrow?.x ?? 0) + u / 2, y = (o.arrow?.y ?? 0) + c / 2;
    let w = "", v = "";
    return f === "bottom" ? (w = s ? p : `${g}px`, v = `${-c}px`) : f === "top" ? (w = s ? p : `${g}px`, v = `${r.floating.height + c}px`) : f === "right" ? (w = `${-c}px`, v = s ? p : `${y}px`) : f === "left" && (w = `${r.floating.width + c}px`, v = s ? p : `${y}px`), { data: { x: w, y: v } };
  }
});
function UN(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var ox = LN, ix = $N, qN = BN, GN = VN, xm = "Popover", [YN, Xpe] = _o(xm, [
  bm
]), ff = bm(), [iq, la] = YN(xm), WN = (e) => {
  const {
    __scopePopover: t,
    children: n,
    open: r,
    defaultOpen: o,
    onOpenChange: a,
    modal: s = !1
  } = e, u = ff(t), c = _.useRef(null), [f, h] = _.useState(!1), [p, g] = sa({
    prop: r,
    defaultProp: o ?? !1,
    onChange: a,
    caller: xm
  });
  return /* @__PURE__ */ b.jsx(ox, { ...u, children: /* @__PURE__ */ b.jsx(
    iq,
    {
      scope: t,
      contentId: po(),
      triggerRef: c,
      open: p,
      onOpenChange: g,
      onOpenToggle: _.useCallback(() => g((y) => !y), [g]),
      hasCustomAnchor: f,
      onCustomAnchorAdd: _.useCallback(() => h(!0), []),
      onCustomAnchorRemove: _.useCallback(() => h(!1), []),
      modal: s,
      children: n
    }
  ) });
};
WN.displayName = xm;
var XN = "PopoverAnchor", aq = _.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, o = la(XN, n), a = ff(n), { onCustomAnchorAdd: s, onCustomAnchorRemove: u } = o;
    return _.useEffect(() => (s(), () => u()), [s, u]), /* @__PURE__ */ b.jsx(ix, { ...a, ...r, ref: t });
  }
);
aq.displayName = XN;
var KN = "PopoverTrigger", ZN = _.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, o = la(KN, n), a = ff(n), s = bt(t, o.triggerRef), u = /* @__PURE__ */ b.jsx(
      qe.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": o.open,
        "aria-controls": o.contentId,
        "data-state": r2(o.open),
        ...r,
        ref: s,
        onClick: xe(e.onClick, o.onOpenToggle)
      }
    );
    return o.hasCustomAnchor ? u : /* @__PURE__ */ b.jsx(ix, { asChild: !0, ...a, children: u });
  }
);
ZN.displayName = KN;
var ax = "PopoverPortal", [sq, lq] = YN(ax, {
  forceMount: void 0
}), QN = (e) => {
  const { __scopePopover: t, forceMount: n, children: r, container: o } = e, a = la(ax, t);
  return /* @__PURE__ */ b.jsx(sq, { scope: t, forceMount: n, children: /* @__PURE__ */ b.jsx(Br, { present: n || a.open, children: /* @__PURE__ */ b.jsx(sm, { asChild: !0, container: o, children: r }) }) });
};
QN.displayName = ax;
var El = "PopoverContent", JN = _.forwardRef(
  (e, t) => {
    const n = lq(El, e.__scopePopover), { forceMount: r = n.forceMount, ...o } = e, a = la(El, e.__scopePopover);
    return /* @__PURE__ */ b.jsx(Br, { present: r || a.open, children: a.modal ? /* @__PURE__ */ b.jsx(cq, { ...o, ref: t }) : /* @__PURE__ */ b.jsx(fq, { ...o, ref: t }) });
  }
);
JN.displayName = El;
var uq = /* @__PURE__ */ xl("PopoverContent.RemoveScroll"), cq = _.forwardRef(
  (e, t) => {
    const n = la(El, e.__scopePopover), r = _.useRef(null), o = bt(t, r), a = _.useRef(!1);
    return _.useEffect(() => {
      const s = r.current;
      if (s) return O1(s);
    }, []), /* @__PURE__ */ b.jsx(um, { as: uq, allowPinchZoom: !0, children: /* @__PURE__ */ b.jsx(
      e2,
      {
        ...e,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: xe(e.onCloseAutoFocus, (s) => {
          s.preventDefault(), a.current || n.triggerRef.current?.focus();
        }),
        onPointerDownOutside: xe(
          e.onPointerDownOutside,
          (s) => {
            const u = s.detail.originalEvent, c = u.button === 0 && u.ctrlKey === !0, f = u.button === 2 || c;
            a.current = f;
          },
          { checkForDefaultPrevented: !1 }
        ),
        onFocusOutside: xe(
          e.onFocusOutside,
          (s) => s.preventDefault(),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
), fq = _.forwardRef(
  (e, t) => {
    const n = la(El, e.__scopePopover), r = _.useRef(!1), o = _.useRef(!1);
    return /* @__PURE__ */ b.jsx(
      e2,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (a) => {
          e.onCloseAutoFocus?.(a), a.defaultPrevented || (r.current || n.triggerRef.current?.focus(), a.preventDefault()), r.current = !1, o.current = !1;
        },
        onInteractOutside: (a) => {
          e.onInteractOutside?.(a), a.defaultPrevented || (r.current = !0, a.detail.originalEvent.type === "pointerdown" && (o.current = !0));
          const s = a.target;
          n.triggerRef.current?.contains(s) && a.preventDefault(), a.detail.originalEvent.type === "focusin" && o.current && a.preventDefault();
        }
      }
    );
  }
), e2 = _.forwardRef(
  (e, t) => {
    const {
      __scopePopover: n,
      trapFocus: r,
      onOpenAutoFocus: o,
      onCloseAutoFocus: a,
      disableOutsidePointerEvents: s,
      onEscapeKeyDown: u,
      onPointerDownOutside: c,
      onFocusOutside: f,
      onInteractOutside: h,
      ...p
    } = e, g = la(El, n), y = ff(n);
    return M1(), /* @__PURE__ */ b.jsx(
      am,
      {
        asChild: !0,
        loop: !0,
        trapped: r,
        onMountAutoFocus: o,
        onUnmountAutoFocus: a,
        children: /* @__PURE__ */ b.jsx(
          of,
          {
            asChild: !0,
            disableOutsidePointerEvents: s,
            onInteractOutside: h,
            onEscapeKeyDown: u,
            onPointerDownOutside: c,
            onFocusOutside: f,
            onDismiss: () => g.onOpenChange(!1),
            children: /* @__PURE__ */ b.jsx(
              qN,
              {
                "data-state": r2(g.open),
                role: "dialog",
                id: g.contentId,
                ...y,
                ...p,
                ref: t,
                style: {
                  ...p.style,
                  "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                }
              }
            )
          }
        )
      }
    );
  }
), t2 = "PopoverClose", dq = _.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, o = la(t2, n);
    return /* @__PURE__ */ b.jsx(
      qe.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: xe(e.onClick, () => o.onOpenChange(!1))
      }
    );
  }
);
dq.displayName = t2;
var hq = "PopoverArrow", n2 = _.forwardRef(
  (e, t) => {
    const { __scopePopover: n, ...r } = e, o = ff(n);
    return /* @__PURE__ */ b.jsx(GN, { ...o, ...r, ref: t });
  }
);
n2.displayName = hq;
function r2(e) {
  return e ? "open" : "closed";
}
var o2 = WN, i2 = ZN, a2 = QN, s2 = JN, pq = n2;
const Fc = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
}, l2 = {};
for (const e of Object.keys(Fc))
  l2[Fc[e]] = e;
const ve = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  oklab: { channels: 3, labels: ["okl", "oka", "okb"] },
  lch: { channels: 3, labels: "lch" },
  oklch: { channels: 3, labels: ["okl", "okc", "okh"] },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] }
}, Jo = (6 / 29) ** 3;
function dl(e) {
  const t = e > 31308e-7 ? 1.055 * e ** 0.4166666666666667 - 0.055 : e * 12.92;
  return Math.min(Math.max(0, t), 1);
}
function hl(e) {
  return e > 0.04045 ? ((e + 0.055) / 1.055) ** 2.4 : e / 12.92;
}
for (const e of Object.keys(ve)) {
  if (!("channels" in ve[e]))
    throw new Error("missing channels property: " + e);
  if (!("labels" in ve[e]))
    throw new Error("missing channel labels property: " + e);
  if (ve[e].labels.length !== ve[e].channels)
    throw new Error("channel and label counts mismatch: " + e);
  const { channels: t, labels: n } = ve[e];
  delete ve[e].channels, delete ve[e].labels, Object.defineProperty(ve[e], "channels", { value: t }), Object.defineProperty(ve[e], "labels", { value: n });
}
ve.rgb.hsl = function(e) {
  const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.min(t, n, r), a = Math.max(t, n, r), s = a - o;
  let u, c;
  switch (a) {
    case o: {
      u = 0;
      break;
    }
    case t: {
      u = (n - r) / s;
      break;
    }
    case n: {
      u = 2 + (r - t) / s;
      break;
    }
    case r: {
      u = 4 + (t - n) / s;
      break;
    }
  }
  u = Math.min(u * 60, 360), u < 0 && (u += 360);
  const f = (o + a) / 2;
  return a === o ? c = 0 : f <= 0.5 ? c = s / (a + o) : c = s / (2 - a - o), [u, c * 100, f * 100];
};
ve.rgb.hsv = function(e) {
  let t, n, r, o, a;
  const s = e[0] / 255, u = e[1] / 255, c = e[2] / 255, f = Math.max(s, u, c), h = f - Math.min(s, u, c), p = function(g) {
    return (f - g) / 6 / h + 1 / 2;
  };
  if (h === 0)
    o = 0, a = 0;
  else {
    switch (a = h / f, t = p(s), n = p(u), r = p(c), f) {
      case s: {
        o = r - n;
        break;
      }
      case u: {
        o = 1 / 3 + t - r;
        break;
      }
      case c: {
        o = 2 / 3 + n - t;
        break;
      }
    }
    o < 0 ? o += 1 : o > 1 && (o -= 1);
  }
  return [
    o * 360,
    a * 100,
    f * 100
  ];
};
ve.rgb.hwb = function(e) {
  const t = e[0], n = e[1];
  let r = e[2];
  const o = ve.rgb.hsl(e)[0], a = 1 / 255 * Math.min(t, Math.min(n, r));
  return r = 1 - 1 / 255 * Math.max(t, Math.max(n, r)), [o, a * 100, r * 100];
};
ve.rgb.oklab = function(e) {
  const t = hl(e[0] / 255), n = hl(e[1] / 255), r = hl(e[2] / 255), o = Math.cbrt(0.4122214708 * t + 0.5363325363 * n + 0.0514459929 * r), a = Math.cbrt(0.2119034982 * t + 0.6806995451 * n + 0.1073969566 * r), s = Math.cbrt(0.0883024619 * t + 0.2817188376 * n + 0.6299787005 * r), u = 0.2104542553 * o + 0.793617785 * a - 0.0040720468 * s, c = 1.9779984951 * o - 2.428592205 * a + 0.4505937099 * s, f = 0.0259040371 * o + 0.7827717662 * a - 0.808675766 * s;
  return [u * 100, c * 100, f * 100];
};
ve.rgb.cmyk = function(e) {
  const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.min(1 - t, 1 - n, 1 - r), a = (1 - t - o) / (1 - o) || 0, s = (1 - n - o) / (1 - o) || 0, u = (1 - r - o) / (1 - o) || 0;
  return [a * 100, s * 100, u * 100, o * 100];
};
function mq(e, t) {
  return (e[0] - t[0]) ** 2 + (e[1] - t[1]) ** 2 + (e[2] - t[2]) ** 2;
}
ve.rgb.keyword = function(e) {
  const t = l2[e];
  if (t)
    return t;
  let n = Number.POSITIVE_INFINITY, r;
  for (const o of Object.keys(Fc)) {
    const a = Fc[o], s = mq(e, a);
    s < n && (n = s, r = o);
  }
  return r;
};
ve.keyword.rgb = function(e) {
  return Fc[e];
};
ve.rgb.xyz = function(e) {
  const t = hl(e[0] / 255), n = hl(e[1] / 255), r = hl(e[2] / 255), o = t * 0.4124564 + n * 0.3575761 + r * 0.1804375, a = t * 0.2126729 + n * 0.7151522 + r * 0.072175, s = t * 0.0193339 + n * 0.119192 + r * 0.9503041;
  return [o * 100, a * 100, s * 100];
};
ve.rgb.lab = function(e) {
  const t = ve.rgb.xyz(e);
  let n = t[0], r = t[1], o = t[2];
  n /= 95.047, r /= 100, o /= 108.883, n = n > Jo ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > Jo ? r ** (1 / 3) : 7.787 * r + 16 / 116, o = o > Jo ? o ** (1 / 3) : 7.787 * o + 16 / 116;
  const a = 116 * r - 16, s = 500 * (n - r), u = 200 * (r - o);
  return [a, s, u];
};
ve.hsl.rgb = function(e) {
  const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
  let o, a;
  if (n === 0)
    return a = r * 255, [a, a, a];
  const s = r < 0.5 ? r * (1 + n) : r + n - r * n, u = 2 * r - s, c = [0, 0, 0];
  for (let f = 0; f < 3; f++)
    o = t + 1 / 3 * -(f - 1), o < 0 && o++, o > 1 && o--, 6 * o < 1 ? a = u + (s - u) * 6 * o : 2 * o < 1 ? a = s : 3 * o < 2 ? a = u + (s - u) * (2 / 3 - o) * 6 : a = u, c[f] = a * 255;
  return c;
};
ve.hsl.hsv = function(e) {
  const t = e[0];
  let n = e[1] / 100, r = e[2] / 100, o = n;
  const a = Math.max(r, 0.01);
  r *= 2, n *= r <= 1 ? r : 2 - r, o *= a <= 1 ? a : 2 - a;
  const s = (r + n) / 2, u = r === 0 ? 2 * o / (a + o) : 2 * n / (r + n);
  return [t, u * 100, s * 100];
};
ve.hsv.rgb = function(e) {
  const t = e[0] / 60, n = e[1] / 100;
  let r = e[2] / 100;
  const o = Math.floor(t) % 6, a = t - Math.floor(t), s = 255 * r * (1 - n), u = 255 * r * (1 - n * a), c = 255 * r * (1 - n * (1 - a));
  switch (r *= 255, o) {
    case 0:
      return [r, c, s];
    case 1:
      return [u, r, s];
    case 2:
      return [s, r, c];
    case 3:
      return [s, u, r];
    case 4:
      return [c, s, r];
    case 5:
      return [r, s, u];
  }
};
ve.hsv.hsl = function(e) {
  const t = e[0], n = e[1] / 100, r = e[2] / 100, o = Math.max(r, 0.01);
  let a, s;
  s = (2 - n) * r;
  const u = (2 - n) * o;
  return a = n * o, a /= u <= 1 ? u : 2 - u, a = a || 0, s /= 2, [t, a * 100, s * 100];
};
ve.hwb.rgb = function(e) {
  const t = e[0] / 360;
  let n = e[1] / 100, r = e[2] / 100;
  const o = n + r;
  let a;
  o > 1 && (n /= o, r /= o);
  const s = Math.floor(6 * t), u = 1 - r;
  a = 6 * t - s, (s & 1) !== 0 && (a = 1 - a);
  const c = n + a * (u - n);
  let f, h, p;
  switch (s) {
    default:
    case 6:
    case 0: {
      f = u, h = c, p = n;
      break;
    }
    case 1: {
      f = c, h = u, p = n;
      break;
    }
    case 2: {
      f = n, h = u, p = c;
      break;
    }
    case 3: {
      f = n, h = c, p = u;
      break;
    }
    case 4: {
      f = c, h = n, p = u;
      break;
    }
    case 5: {
      f = u, h = n, p = c;
      break;
    }
  }
  return [f * 255, h * 255, p * 255];
};
ve.cmyk.rgb = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = e[3] / 100, a = 1 - Math.min(1, t * (1 - o) + o), s = 1 - Math.min(1, n * (1 - o) + o), u = 1 - Math.min(1, r * (1 - o) + o);
  return [a * 255, s * 255, u * 255];
};
ve.xyz.rgb = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100;
  let o, a, s;
  return o = t * 3.2404542 + n * -1.5371385 + r * -0.4985314, a = t * -0.969266 + n * 1.8760108 + r * 0.041556, s = t * 0.0556434 + n * -0.2040259 + r * 1.0572252, o = dl(o), a = dl(a), s = dl(s), [o * 255, a * 255, s * 255];
};
ve.xyz.lab = function(e) {
  let t = e[0], n = e[1], r = e[2];
  t /= 95.047, n /= 100, r /= 108.883, t = t > Jo ? t ** (1 / 3) : 7.787 * t + 16 / 116, n = n > Jo ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > Jo ? r ** (1 / 3) : 7.787 * r + 16 / 116;
  const o = 116 * n - 16, a = 500 * (t - n), s = 200 * (n - r);
  return [o, a, s];
};
ve.xyz.oklab = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = Math.cbrt(0.8189330101 * t + 0.3618667424 * n - 0.1288597137 * r), a = Math.cbrt(0.0329845436 * t + 0.9293118715 * n + 0.0361456387 * r), s = Math.cbrt(0.0482003018 * t + 0.2643662691 * n + 0.633851707 * r), u = 0.2104542553 * o + 0.793617785 * a - 0.0040720468 * s, c = 1.9779984951 * o - 2.428592205 * a + 0.4505937099 * s, f = 0.0259040371 * o + 0.7827717662 * a - 0.808675766 * s;
  return [u * 100, c * 100, f * 100];
};
ve.oklab.oklch = function(e) {
  return ve.lab.lch(e);
};
ve.oklab.xyz = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = (0.999999998 * t + 0.396337792 * n + 0.215803758 * r) ** 3, a = (1.000000008 * t - 0.105561342 * n - 0.063854175 * r) ** 3, s = (1.000000055 * t - 0.089484182 * n - 1.291485538 * r) ** 3, u = 1.227013851 * o - 0.55779998 * a + 0.281256149 * s, c = -0.040580178 * o + 1.11225687 * a - 0.071676679 * s, f = -0.076381285 * o - 0.421481978 * a + 1.58616322 * s;
  return [u * 100, c * 100, f * 100];
};
ve.oklab.rgb = function(e) {
  const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = (t + 0.3963377774 * n + 0.2158037573 * r) ** 3, a = (t - 0.1055613458 * n - 0.0638541728 * r) ** 3, s = (t - 0.0894841775 * n - 1.291485548 * r) ** 3, u = dl(4.0767416621 * o - 3.3077115913 * a + 0.2309699292 * s), c = dl(-1.2684380046 * o + 2.6097574011 * a - 0.3413193965 * s), f = dl(-0.0041960863 * o - 0.7034186147 * a + 1.707614701 * s);
  return [u * 255, c * 255, f * 255];
};
ve.oklch.oklab = function(e) {
  return ve.lch.lab(e);
};
ve.lab.xyz = function(e) {
  const t = e[0], n = e[1], r = e[2];
  let o, a, s;
  a = (t + 16) / 116, o = n / 500 + a, s = a - r / 200;
  const u = a ** 3, c = o ** 3, f = s ** 3;
  return a = u > Jo ? u : (a - 16 / 116) / 7.787, o = c > Jo ? c : (o - 16 / 116) / 7.787, s = f > Jo ? f : (s - 16 / 116) / 7.787, o *= 95.047, a *= 100, s *= 108.883, [o, a, s];
};
ve.lab.lch = function(e) {
  const t = e[0], n = e[1], r = e[2];
  let o;
  o = Math.atan2(r, n) * 360 / 2 / Math.PI, o < 0 && (o += 360);
  const s = Math.sqrt(n * n + r * r);
  return [t, s, o];
};
ve.lch.lab = function(e) {
  const t = e[0], n = e[1], o = e[2] / 360 * 2 * Math.PI, a = n * Math.cos(o), s = n * Math.sin(o);
  return [t, a, s];
};
ve.rgb.ansi16 = function(e, t = null) {
  const [n, r, o] = e;
  let a = t === null ? ve.rgb.hsv(e)[2] : t;
  if (a = Math.round(a / 50), a === 0)
    return 30;
  let s = 30 + (Math.round(o / 255) << 2 | Math.round(r / 255) << 1 | Math.round(n / 255));
  return a === 2 && (s += 60), s;
};
ve.hsv.ansi16 = function(e) {
  return ve.rgb.ansi16(ve.hsv.rgb(e), e[2]);
};
ve.rgb.ansi256 = function(e) {
  const t = e[0], n = e[1], r = e[2];
  return t >> 4 === n >> 4 && n >> 4 === r >> 4 ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(r / 255 * 5);
};
ve.ansi16.rgb = function(e) {
  e = e[0];
  let t = e % 10;
  if (t === 0 || t === 7)
    return e > 50 && (t += 3.5), t = t / 10.5 * 255, [t, t, t];
  const n = (Math.trunc(e > 50) + 1) * 0.5, r = (t & 1) * n * 255, o = (t >> 1 & 1) * n * 255, a = (t >> 2 & 1) * n * 255;
  return [r, o, a];
};
ve.ansi256.rgb = function(e) {
  if (e = e[0], e >= 232) {
    const a = (e - 232) * 10 + 8;
    return [a, a, a];
  }
  e -= 16;
  let t;
  const n = Math.floor(e / 36) / 5 * 255, r = Math.floor((t = e % 36) / 6) / 5 * 255, o = t % 6 / 5 * 255;
  return [n, r, o];
};
ve.rgb.hex = function(e) {
  const n = (((Math.round(e[0]) & 255) << 16) + ((Math.round(e[1]) & 255) << 8) + (Math.round(e[2]) & 255)).toString(16).toUpperCase();
  return "000000".slice(n.length) + n;
};
ve.hex.rgb = function(e) {
  const t = e.toString(16).match(/[a-f\d]{6}|[a-f\d]{3}/i);
  if (!t)
    return [0, 0, 0];
  let n = t[0];
  t[0].length === 3 && (n = [...n].map((u) => u + u).join(""));
  const r = Number.parseInt(n, 16), o = r >> 16 & 255, a = r >> 8 & 255, s = r & 255;
  return [o, a, s];
};
ve.rgb.hcg = function(e) {
  const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.max(Math.max(t, n), r), a = Math.min(Math.min(t, n), r), s = o - a;
  let u;
  const c = s < 1 ? a / (1 - s) : 0;
  return s <= 0 ? u = 0 : o === t ? u = (n - r) / s % 6 : o === n ? u = 2 + (r - t) / s : u = 4 + (t - n) / s, u /= 6, u %= 1, [u * 360, s * 100, c * 100];
};
ve.hsl.hcg = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = n < 0.5 ? 2 * t * n : 2 * t * (1 - n);
  let o = 0;
  return r < 1 && (o = (n - 0.5 * r) / (1 - r)), [e[0], r * 100, o * 100];
};
ve.hsv.hcg = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = t * n;
  let o = 0;
  return r < 1 && (o = (n - r) / (1 - r)), [e[0], r * 100, o * 100];
};
ve.hcg.rgb = function(e) {
  const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
  if (n === 0)
    return [r * 255, r * 255, r * 255];
  const o = [0, 0, 0], a = t % 1 * 6, s = a % 1, u = 1 - s;
  let c = 0;
  switch (Math.floor(a)) {
    case 0: {
      o[0] = 1, o[1] = s, o[2] = 0;
      break;
    }
    case 1: {
      o[0] = u, o[1] = 1, o[2] = 0;
      break;
    }
    case 2: {
      o[0] = 0, o[1] = 1, o[2] = s;
      break;
    }
    case 3: {
      o[0] = 0, o[1] = u, o[2] = 1;
      break;
    }
    case 4: {
      o[0] = s, o[1] = 0, o[2] = 1;
      break;
    }
    default:
      o[0] = 1, o[1] = 0, o[2] = u;
  }
  return c = (1 - n) * r, [
    (n * o[0] + c) * 255,
    (n * o[1] + c) * 255,
    (n * o[2] + c) * 255
  ];
};
ve.hcg.hsv = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = t + n * (1 - t);
  let o = 0;
  return r > 0 && (o = t / r), [e[0], o * 100, r * 100];
};
ve.hcg.hsl = function(e) {
  const t = e[1] / 100, r = e[2] / 100 * (1 - t) + 0.5 * t;
  let o = 0;
  return r > 0 && r < 0.5 ? o = t / (2 * r) : r >= 0.5 && r < 1 && (o = t / (2 * (1 - r))), [e[0], o * 100, r * 100];
};
ve.hcg.hwb = function(e) {
  const t = e[1] / 100, n = e[2] / 100, r = t + n * (1 - t);
  return [e[0], (r - t) * 100, (1 - r) * 100];
};
ve.hwb.hcg = function(e) {
  const t = e[1] / 100, r = 1 - e[2] / 100, o = r - t;
  let a = 0;
  return o < 1 && (a = (r - o) / (1 - o)), [e[0], o * 100, a * 100];
};
ve.apple.rgb = function(e) {
  return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255];
};
ve.rgb.apple = function(e) {
  return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535];
};
ve.gray.rgb = function(e) {
  return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255];
};
ve.gray.hsl = function(e) {
  return [0, 0, e[0]];
};
ve.gray.hsv = ve.gray.hsl;
ve.gray.hwb = function(e) {
  return [0, 100, e[0]];
};
ve.gray.cmyk = function(e) {
  return [0, 0, 0, e[0]];
};
ve.gray.lab = function(e) {
  return [e[0], 0, 0];
};
ve.gray.hex = function(e) {
  const t = Math.round(e[0] / 100 * 255) & 255, r = ((t << 16) + (t << 8) + t).toString(16).toUpperCase();
  return "000000".slice(r.length) + r;
};
ve.rgb.gray = function(e) {
  return [(e[0] + e[1] + e[2]) / 3 / 255 * 100];
};
function gq() {
  const e = {}, t = Object.keys(ve);
  for (let { length: n } = t, r = 0; r < n; r++)
    e[t[r]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  return e;
}
function yq(e) {
  const t = gq(), n = [e];
  for (t[e].distance = 0; n.length > 0; ) {
    const r = n.pop(), o = Object.keys(ve[r]);
    for (let { length: a } = o, s = 0; s < a; s++) {
      const u = o[s], c = t[u];
      c.distance === -1 && (c.distance = t[r].distance + 1, c.parent = r, n.unshift(u));
    }
  }
  return t;
}
function vq(e, t) {
  return function(n) {
    return t(e(n));
  };
}
function bq(e, t) {
  const n = [t[e].parent, e];
  let r = ve[t[e].parent][e], o = t[e].parent;
  for (; t[o].parent; )
    n.unshift(t[o].parent), r = vq(ve[t[o].parent][o], r), o = t[o].parent;
  return r.conversion = n, r;
}
function xq(e) {
  const t = yq(e), n = {}, r = Object.keys(t);
  for (let { length: o } = r, a = 0; a < o; a++) {
    const s = r[a];
    t[s].parent !== null && (n[s] = bq(s, t));
  }
  return n;
}
const Na = {}, wq = Object.keys(ve);
function _q(e) {
  const t = function(...n) {
    const r = n[0];
    return r == null ? r : (r.length > 1 && (n = r), e(n));
  };
  return "conversion" in e && (t.conversion = e.conversion), t;
}
function Sq(e) {
  const t = function(...n) {
    const r = n[0];
    if (r == null)
      return r;
    r.length > 1 && (n = r);
    const o = e(n);
    if (typeof o == "object")
      for (let { length: a } = o, s = 0; s < a; s++)
        o[s] = Math.round(o[s]);
    return o;
  };
  return "conversion" in e && (t.conversion = e.conversion), t;
}
for (const e of wq) {
  Na[e] = {}, Object.defineProperty(Na[e], "channels", { value: ve[e].channels }), Object.defineProperty(Na[e], "labels", { value: ve[e].labels });
  const t = xq(e), n = Object.keys(t);
  for (const r of n) {
    const o = t[r];
    Na[e][r] = Sq(o), Na[e][r].raw = _q(o);
  }
}
const Eq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Na
}, Symbol.toStringTag, { value: "Module" })), gn = (e, t) => {
  const n = Array.isArray(t) ? t : [t];
  if (n[0] === void 0 || n[0] === null)
    return gn("rgb", [0, 0, 0]);
  const r = Na[e];
  if (!r)
    throw new Error(
      `Unsupported color type: ${e} allowed are ${Object.keys(Eq).join(
        ", "
      )}`
    );
  r[e] = () => n;
  const o = (s) => {
    const u = s(...n);
    return Array.isArray(u) ? u[0] != null : u;
  };
  if (!o(r.rgb) || !o(r.hsl))
    return gn("rgb", [0, 0, 0]);
  const a = {};
  return Object.keys(r).forEach((s) => {
    const u = r[s];
    typeof u == "function" && (a[s] = () => s === e ? n : u(...n));
  }), a;
}, Cq = ({
  onChange: e,
  colorconverter: t,
  allow_null: n = !1
}) => {
  if (t === null && !n)
    throw new Error("Color converter is null");
  const [r, o] = _.useState(t), [a, s] = _.useState([0, 0, 0]), [u, c] = _.useState([0, 0, 0]), [f, h] = _.useState([0, 0, 0]), [p, g] = _.useState("000");
  _.useEffect(() => {
    if (!r) {
      if (!n) throw new Error("Color converter is null");
      c([0, 0, 0]), s([0, 0, 0]), h([0, 0, 0]), g("");
      return;
    }
    s(r.hsl()), c(r.rgb()), h(r.hsv()), g(r.hex());
  }, [r]);
  const y = {
    backgroundColor: `hsl(${a[0]}, ${a[1]}%, ${a[2]}%)`,
    padding: "10px",
    margin: "10px 0"
  };
  return /* @__PURE__ */ b.jsxs("div", { style: { backgroundColor: "white" }, children: [
    /* @__PURE__ */ b.jsx("div", { style: y, children: "Color Preview" }),
    /* @__PURE__ */ b.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ b.jsx("div", { className: "colorspace_title", children: "RGB" }),
      /* @__PURE__ */ b.jsx("div", {}),
      /* @__PURE__ */ b.jsx("label", { children: "Red" }),
      /* @__PURE__ */ b.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "255",
          value: u[0],
          onChange: (w) => {
            const v = [parseInt(w.target.value), u[1], u[2]], S = gn("rgb", v);
            o(S), e(S);
          },
          style: { background: "linear-gradient(to right, #000, #f00)" }
        }
      ),
      /* @__PURE__ */ b.jsx("label", { children: "Green" }),
      /* @__PURE__ */ b.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "255",
          value: u[1],
          onChange: (w) => {
            const v = [u[0], parseInt(w.target.value), u[2]], S = gn("rgb", v);
            o(S), e(S);
          },
          style: { background: "linear-gradient(to right, #000, #0f0)" }
        }
      ),
      /* @__PURE__ */ b.jsx("label", { children: "Blue" }),
      /* @__PURE__ */ b.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "255",
          value: u[2],
          onChange: (w) => {
            const v = [u[0], u[1], parseInt(w.target.value)], S = gn("rgb", v);
            o(S), e(S);
          },
          style: { background: "linear-gradient(to right, #000, #00f)" }
        }
      )
    ] }),
    /* @__PURE__ */ b.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ b.jsx("div", { className: "colorspace_title", children: "HSL" }),
      /* @__PURE__ */ b.jsx("div", {}),
      /* @__PURE__ */ b.jsx("label", { children: "Hue" }),
      /* @__PURE__ */ b.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "360",
          value: a[0],
          onChange: (w) => {
            const v = [parseInt(w.target.value), a[1], a[2]], S = gn("hsl", v);
            o(S), e(S);
          },
          style: {
            background: "linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)"
          }
        }
      ),
      /* @__PURE__ */ b.jsx("label", { children: "Saturation" }),
      /* @__PURE__ */ b.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: a[1],
          onChange: (w) => {
            const v = [a[0], parseInt(w.target.value), a[2]], S = gn("hsl", v);
            o(S), e(S);
          },
          style: {
            background: `linear-gradient(to right, #fff, hsl(${a[0]}, 100%, 50%))`
          }
        }
      ),
      /* @__PURE__ */ b.jsx("label", { children: "Lightness" }),
      /* @__PURE__ */ b.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: a[2],
          onChange: (w) => {
            const v = [a[0], a[1], parseInt(w.target.value)], S = gn("hsl", v);
            o(S), e(S);
          },
          style: {
            background: `linear-gradient(to right, #000, hsl(${a[0]}, 100%, 50%), #fff)`
          }
        }
      )
    ] }),
    /* @__PURE__ */ b.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ b.jsx("div", { className: "colorspace_title", children: "HSV" }),
      /* @__PURE__ */ b.jsx("div", {}),
      /* @__PURE__ */ b.jsx("label", { children: "Hue" }),
      /* @__PURE__ */ b.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "360",
          value: f[0],
          onChange: (w) => {
            const v = [parseInt(w.target.value), f[1], f[2]], S = gn("hsv", v);
            o(S), e(S);
          },
          style: {
            background: "linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)"
          }
        }
      ),
      /* @__PURE__ */ b.jsx("label", { children: "Saturation" }),
      /* @__PURE__ */ b.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: f[1],
          onChange: (w) => {
            const v = [f[0], parseInt(w.target.value), f[2]], S = gn("hsv", v);
            o(S), e(S);
          },
          style: {
            background: `linear-gradient(to right, #fff, hsl(${a[0]}, 100%, 50%))`
          }
        }
      ),
      /* @__PURE__ */ b.jsx("label", { children: "Value" }),
      /* @__PURE__ */ b.jsx(
        "input",
        {
          type: "range",
          min: "0",
          max: "100",
          value: f[2],
          onChange: (w) => {
            const v = [f[0], f[1], parseInt(w.target.value)], S = gn("hsv", v);
            o(S), e(S);
          },
          style: {
            background: `linear-gradient(to right, #000, hsl(${a[0]}, 100%, 50%))`
          }
        }
      )
    ] }),
    /* @__PURE__ */ b.jsxs("div", { className: "colorspace", children: [
      /* @__PURE__ */ b.jsx("div", { className: "colorspace_title", children: "HEX" }),
      /* @__PURE__ */ b.jsx("div", {}),
      /* @__PURE__ */ b.jsx(
        "input",
        {
          type: "text",
          value: p,
          onChange: (w) => {
            const v = w.target.value === "" ? null : gn("hex", [w.target.value]);
            o(v), e(v);
          }
        }
      )
    ] })
  ] });
}, kq = ({
  inicolordata: e,
  inicolorspace: t,
  allow_null: n = !1,
  delay: r = 1e3,
  onChange: o,
  portalContainer: a
}) => {
  const s = e !== void 0 ? e : [0, 0, 0], u = e === void 0 ? "rgb" : t || "hex", c = Array.isArray(s) ? s : [s], f = _.useMemo(() => {
    let v = gn(u, c);
    return v.rgb() === void 0 && (v = gn("rgb", [0, 0, 0])), v;
  }, [u, c]), [h, p] = _.useState(f);
  _.useEffect(() => {
    const v = e !== void 0 ? e : [0, 0, 0], S = e === void 0 ? "rgb" : t || "hex", E = Array.isArray(v) ? v : [v];
    let A = gn(S, E);
    A.rgb() === void 0 && (A = gn("rgb", [0, 0, 0])), p(A);
  }, [JSON.stringify(e), t]);
  const g = _.useRef(null), y = _.useCallback(
    (v) => {
      if (v === null && !n)
        throw new Error("Color is null");
      v !== null && p(v), g.current && clearTimeout(g.current), o && (g.current = setTimeout(() => {
        o(v), g.current = null;
      }, r));
    },
    [n, o, r]
  );
  _.useEffect(() => () => {
    g.current && clearTimeout(g.current);
  }, []);
  const w = _.useMemo(
    () => ({
      background: "#" + h.hex(),
      borderRadius: "0.3rem",
      width: "2rem",
      height: "1rem"
    }),
    [h]
  );
  return /* @__PURE__ */ b.jsxs(o2, { children: [
    /* @__PURE__ */ b.jsx(i2, { asChild: !0, children: /* @__PURE__ */ b.jsx("button", { style: w }) }),
    /* @__PURE__ */ b.jsx(a2, { container: a, children: /* @__PURE__ */ b.jsx(s2, { side: "left", className: "iotooltipcontent", children: /* @__PURE__ */ b.jsx(
      Cq,
      {
        onChange: y,
        colorconverter: h,
        allow_null: n
      }
    ) }) })
  ] });
};
function Wa(e) {
  "@babel/helpers - typeof";
  return Wa = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Wa(e);
}
function Tq(e, t) {
  if (Wa(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t);
    if (Wa(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function u2(e) {
  var t = Tq(e, "string");
  return Wa(t) == "symbol" ? t : t + "";
}
function pc(e, t, n) {
  return (t = u2(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function oT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Me(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oT(Object(n), !0).forEach(function(r) {
      pc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Aq(e) {
  if (Array.isArray(e)) return e;
}
function Rq(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r, o, a, s, u = [], c = !0, f = !1;
    try {
      if (a = (n = n.call(e)).next, t === 0) {
        if (Object(n) !== n) return;
        c = !1;
      } else for (; !(c = (r = a.call(n)).done) && (u.push(r.value), u.length !== t); c = !0) ;
    } catch (h) {
      f = !0, o = h;
    } finally {
      try {
        if (!c && n.return != null && (s = n.return(), Object(s) !== s)) return;
      } finally {
        if (f) throw o;
      }
    }
    return u;
  }
}
function vb(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function c2(e, t) {
  if (e) {
    if (typeof e == "string") return vb(e, t);
    var n = {}.toString.call(e).slice(8, -1);
    return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? vb(e, t) : void 0;
  }
}
function Mq() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ei(e, t) {
  return Aq(e) || Rq(e, t) || c2(e, t) || Mq();
}
function fi(e, t) {
  if (e == null) return {};
  var n, r, o = C1(e, t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    for (r = 0; r < a.length; r++) n = a[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var Oq = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function Nq(e) {
  var t = e.defaultInputValue, n = t === void 0 ? "" : t, r = e.defaultMenuIsOpen, o = r === void 0 ? !1 : r, a = e.defaultValue, s = a === void 0 ? null : a, u = e.inputValue, c = e.menuIsOpen, f = e.onChange, h = e.onInputChange, p = e.onMenuClose, g = e.onMenuOpen, y = e.value, w = fi(e, Oq), v = _.useState(u !== void 0 ? u : n), S = ei(v, 2), E = S[0], A = S[1], k = _.useState(c !== void 0 ? c : o), T = ei(k, 2), R = T[0], N = T[1], j = _.useState(y !== void 0 ? y : s), z = ei(j, 2), B = z[0], M = z[1], F = _.useCallback(function(H, G) {
    typeof f == "function" && f(H, G), M(H);
  }, [f]), q = _.useCallback(function(H, G) {
    var O;
    typeof h == "function" && (O = h(H, G)), A(O !== void 0 ? O : H);
  }, [h]), Y = _.useCallback(function() {
    typeof g == "function" && g(), N(!0);
  }, [g]), P = _.useCallback(function() {
    typeof p == "function" && p(), N(!1);
  }, [p]), V = u !== void 0 ? u : E, I = c !== void 0 ? c : R, U = y !== void 0 ? y : B;
  return Me(Me({}, w), {}, {
    inputValue: V,
    menuIsOpen: I,
    onChange: F,
    onInputChange: q,
    onMenuClose: P,
    onMenuOpen: Y,
    value: U
  });
}
function Dq(e, t) {
  if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
}
function iT(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, u2(r.key), r);
  }
}
function jq(e, t, n) {
  return t && iT(e.prototype, t), n && iT(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function Pq(e, t) {
  if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && ep(e, t);
}
function fp(e) {
  return fp = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, fp(e);
}
function f2() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (f2 = function() {
    return !!e;
  })();
}
function Iq(e, t) {
  if (t && (Wa(t) == "object" || typeof t == "function")) return t;
  if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return PM(e);
}
function zq(e) {
  var t = f2();
  return function() {
    var n, r = fp(e);
    if (t) {
      var o = fp(this).constructor;
      n = Reflect.construct(r, arguments, o);
    } else n = r.apply(this, arguments);
    return Iq(this, n);
  };
}
function Lq(e) {
  if (Array.isArray(e)) return vb(e);
}
function Fq(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function $q() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function sx(e) {
  return Lq(e) || Fq(e) || c2(e) || $q();
}
function Bq(e, t) {
  return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {
    raw: {
      value: Object.freeze(t)
    }
  }));
}
var bb = _.useLayoutEffect, Hq = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"], dp = function() {
};
function Vq(e, t) {
  return t ? t[0] === "-" ? e + t : e + "__" + t : e;
}
function Uq(e, t) {
  for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++)
    r[o - 2] = arguments[o];
  var a = [].concat(r);
  if (t && e)
    for (var s in t)
      t.hasOwnProperty(s) && t[s] && a.push("".concat(Vq(e, s)));
  return a.filter(function(u) {
    return u;
  }).map(function(u) {
    return String(u).trim();
  }).join(" ");
}
var aT = function(t) {
  return Jq(t) ? t.filter(Boolean) : Wa(t) === "object" && t !== null ? [t] : [];
}, d2 = function(t) {
  t.className, t.clearValue, t.cx, t.getStyles, t.getClassNames, t.getValue, t.hasValue, t.isMulti, t.isRtl, t.options, t.selectOption, t.selectProps, t.setValue, t.theme;
  var n = fi(t, Hq);
  return Me({}, n);
}, jt = function(t, n, r) {
  var o = t.cx, a = t.getStyles, s = t.getClassNames, u = t.className;
  return {
    css: a(n, t),
    className: o(r ?? {}, s(n, t), u)
  };
};
function wm(e) {
  return [document.documentElement, document.body, window].indexOf(e) > -1;
}
function qq(e) {
  return wm(e) ? window.innerHeight : e.clientHeight;
}
function h2(e) {
  return wm(e) ? window.pageYOffset : e.scrollTop;
}
function hp(e, t) {
  if (wm(e)) {
    window.scrollTo(0, t);
    return;
  }
  e.scrollTop = t;
}
function Gq(e) {
  var t = getComputedStyle(e), n = t.position === "absolute", r = /(auto|scroll)/;
  if (t.position === "fixed") return document.documentElement;
  for (var o = e; o = o.parentElement; )
    if (t = getComputedStyle(o), !(n && t.position === "static") && r.test(t.overflow + t.overflowY + t.overflowX))
      return o;
  return document.documentElement;
}
function Yq(e, t, n, r) {
  return n * ((e = e / r - 1) * e * e + 1) + t;
}
function sh(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : dp, o = h2(e), a = t - o, s = 10, u = 0;
  function c() {
    u += s;
    var f = Yq(u, o, a, n);
    hp(e, f), u < n ? window.requestAnimationFrame(c) : r(e);
  }
  c();
}
function sT(e, t) {
  var n = e.getBoundingClientRect(), r = t.getBoundingClientRect(), o = t.offsetHeight / 3;
  r.bottom + o > n.bottom ? hp(e, Math.min(t.offsetTop + t.clientHeight - e.offsetHeight + o, e.scrollHeight)) : r.top - o < n.top && hp(e, Math.max(t.offsetTop - o, 0));
}
function Wq(e) {
  var t = e.getBoundingClientRect();
  return {
    bottom: t.bottom,
    height: t.height,
    left: t.left,
    right: t.right,
    top: t.top,
    width: t.width
  };
}
function lT() {
  try {
    return document.createEvent("TouchEvent"), !0;
  } catch {
    return !1;
  }
}
function Xq() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch {
    return !1;
  }
}
var p2 = !1, Kq = {
  get passive() {
    return p2 = !0;
  }
}, lh = typeof window < "u" ? window : {};
lh.addEventListener && lh.removeEventListener && (lh.addEventListener("p", dp, Kq), lh.removeEventListener("p", dp, !1));
var Zq = p2;
function Qq(e) {
  return e != null;
}
function Jq(e) {
  return Array.isArray(e);
}
function uh(e, t, n) {
  return e ? t : n;
}
var eG = function(t) {
  for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)
    r[o - 1] = arguments[o];
  var a = Object.entries(t).filter(function(s) {
    var u = ei(s, 1), c = u[0];
    return !r.includes(c);
  });
  return a.reduce(function(s, u) {
    var c = ei(u, 2), f = c[0], h = c[1];
    return s[f] = h, s;
  }, {});
}, tG = ["children", "innerProps"], nG = ["children", "innerProps"];
function rG(e) {
  var t = e.maxHeight, n = e.menuEl, r = e.minHeight, o = e.placement, a = e.shouldScroll, s = e.isFixedPosition, u = e.controlHeight, c = Gq(n), f = {
    placement: "bottom",
    maxHeight: t
  };
  if (!n || !n.offsetParent) return f;
  var h = c.getBoundingClientRect(), p = h.height, g = n.getBoundingClientRect(), y = g.bottom, w = g.height, v = g.top, S = n.offsetParent.getBoundingClientRect(), E = S.top, A = s ? window.innerHeight : qq(c), k = h2(c), T = parseInt(getComputedStyle(n).marginBottom, 10), R = parseInt(getComputedStyle(n).marginTop, 10), N = E - R, j = A - v, z = N + k, B = p - k - v, M = y - A + k + T, F = k + v - R, q = 160;
  switch (o) {
    case "auto":
    case "bottom":
      if (j >= w)
        return {
          placement: "bottom",
          maxHeight: t
        };
      if (B >= w && !s)
        return a && sh(c, M, q), {
          placement: "bottom",
          maxHeight: t
        };
      if (!s && B >= r || s && j >= r) {
        a && sh(c, M, q);
        var Y = s ? j - T : B - T;
        return {
          placement: "bottom",
          maxHeight: Y
        };
      }
      if (o === "auto" || s) {
        var P = t, V = s ? N : z;
        return V >= r && (P = Math.min(V - T - u, t)), {
          placement: "top",
          maxHeight: P
        };
      }
      if (o === "bottom")
        return a && hp(c, M), {
          placement: "bottom",
          maxHeight: t
        };
      break;
    case "top":
      if (N >= w)
        return {
          placement: "top",
          maxHeight: t
        };
      if (z >= w && !s)
        return a && sh(c, F, q), {
          placement: "top",
          maxHeight: t
        };
      if (!s && z >= r || s && N >= r) {
        var I = t;
        return (!s && z >= r || s && N >= r) && (I = s ? N - R : z - R), a && sh(c, F, q), {
          placement: "top",
          maxHeight: I
        };
      }
      return {
        placement: "bottom",
        maxHeight: t
      };
    default:
      throw new Error('Invalid placement provided "'.concat(o, '".'));
  }
  return f;
}
function oG(e) {
  var t = {
    bottom: "top",
    top: "bottom"
  };
  return e ? t[e] : "bottom";
}
var m2 = function(t) {
  return t === "auto" ? "bottom" : t;
}, iG = function(t, n) {
  var r, o = t.placement, a = t.theme, s = a.borderRadius, u = a.spacing, c = a.colors;
  return Me((r = {
    label: "menu"
  }, pc(r, oG(o), "100%"), pc(r, "position", "absolute"), pc(r, "width", "100%"), pc(r, "zIndex", 1), r), n ? {} : {
    backgroundColor: c.neutral0,
    borderRadius: s,
    boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
    marginBottom: u.menuGutter,
    marginTop: u.menuGutter
  });
}, g2 = /* @__PURE__ */ _.createContext(null), aG = function(t) {
  var n = t.children, r = t.minMenuHeight, o = t.maxMenuHeight, a = t.menuPlacement, s = t.menuPosition, u = t.menuShouldScrollIntoView, c = t.theme, f = _.useContext(g2) || {}, h = f.setPortalPlacement, p = _.useRef(null), g = _.useState(o), y = ei(g, 2), w = y[0], v = y[1], S = _.useState(null), E = ei(S, 2), A = E[0], k = E[1], T = c.spacing.controlHeight;
  return bb(function() {
    var R = p.current;
    if (R) {
      var N = s === "fixed", j = u && !N, z = rG({
        maxHeight: o,
        menuEl: R,
        minHeight: r,
        placement: a,
        shouldScroll: j,
        isFixedPosition: N,
        controlHeight: T
      });
      v(z.maxHeight), k(z.placement), h?.(z.placement);
    }
  }, [o, a, s, u, r, h, T]), n({
    ref: p,
    placerProps: Me(Me({}, t), {}, {
      placement: A || m2(a),
      maxHeight: w
    })
  });
}, sG = function(t) {
  var n = t.children, r = t.innerRef, o = t.innerProps;
  return Te("div", Re({}, jt(t, "menu", {
    menu: !0
  }), {
    ref: r
  }, o), n);
}, lG = sG, uG = function(t, n) {
  var r = t.maxHeight, o = t.theme.spacing.baseUnit;
  return Me({
    maxHeight: r,
    overflowY: "auto",
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }, n ? {} : {
    paddingBottom: o,
    paddingTop: o
  });
}, cG = function(t) {
  var n = t.children, r = t.innerProps, o = t.innerRef, a = t.isMulti;
  return Te("div", Re({}, jt(t, "menuList", {
    "menu-list": !0,
    "menu-list--is-multi": a
  }), {
    ref: o
  }, r), n);
}, y2 = function(t, n) {
  var r = t.theme, o = r.spacing.baseUnit, a = r.colors;
  return Me({
    textAlign: "center"
  }, n ? {} : {
    color: a.neutral40,
    padding: "".concat(o * 2, "px ").concat(o * 3, "px")
  });
}, fG = y2, dG = y2, hG = function(t) {
  var n = t.children, r = n === void 0 ? "No options" : n, o = t.innerProps, a = fi(t, tG);
  return Te("div", Re({}, jt(Me(Me({}, a), {}, {
    children: r,
    innerProps: o
  }), "noOptionsMessage", {
    "menu-notice": !0,
    "menu-notice--no-options": !0
  }), o), r);
}, pG = function(t) {
  var n = t.children, r = n === void 0 ? "Loading..." : n, o = t.innerProps, a = fi(t, nG);
  return Te("div", Re({}, jt(Me(Me({}, a), {}, {
    children: r,
    innerProps: o
  }), "loadingMessage", {
    "menu-notice": !0,
    "menu-notice--loading": !0
  }), o), r);
}, mG = function(t) {
  var n = t.rect, r = t.offset, o = t.position;
  return {
    left: n.left,
    position: o,
    top: r,
    width: n.width,
    zIndex: 1
  };
}, gG = function(t) {
  var n = t.appendTo, r = t.children, o = t.controlElement, a = t.innerProps, s = t.menuPlacement, u = t.menuPosition, c = _.useRef(null), f = _.useRef(null), h = _.useState(m2(s)), p = ei(h, 2), g = p[0], y = p[1], w = _.useMemo(function() {
    return {
      setPortalPlacement: y
    };
  }, []), v = _.useState(null), S = ei(v, 2), E = S[0], A = S[1], k = _.useCallback(function() {
    if (o) {
      var j = Wq(o), z = u === "fixed" ? 0 : window.pageYOffset, B = j[g] + z;
      (B !== E?.offset || j.left !== E?.rect.left || j.width !== E?.rect.width) && A({
        offset: B,
        rect: j
      });
    }
  }, [o, u, g, E?.offset, E?.rect.left, E?.rect.width]);
  bb(function() {
    k();
  }, [k]);
  var T = _.useCallback(function() {
    typeof f.current == "function" && (f.current(), f.current = null), o && c.current && (f.current = NN(o, c.current, k, {
      elementResize: "ResizeObserver" in window
    }));
  }, [o, k]);
  bb(function() {
    T();
  }, [T]);
  var R = _.useCallback(function(j) {
    c.current = j, T();
  }, [T]);
  if (!n && u !== "fixed" || !E) return null;
  var N = Te("div", Re({
    ref: R
  }, jt(Me(Me({}, t), {}, {
    offset: E.offset,
    position: u,
    rect: E.rect
  }), "menuPortal", {
    "menu-portal": !0
  }), a), r);
  return Te(g2.Provider, {
    value: w
  }, n ? /* @__PURE__ */ Pl.createPortal(N, n) : N);
}, yG = function(t) {
  var n = t.isDisabled, r = t.isRtl;
  return {
    label: "container",
    direction: r ? "rtl" : void 0,
    pointerEvents: n ? "none" : void 0,
    // cancel mouse events when disabled
    position: "relative"
  };
}, vG = function(t) {
  var n = t.children, r = t.innerProps, o = t.isDisabled, a = t.isRtl;
  return Te("div", Re({}, jt(t, "container", {
    "--is-disabled": o,
    "--is-rtl": a
  }), r), n);
}, bG = function(t, n) {
  var r = t.theme.spacing, o = t.isMulti, a = t.hasValue, s = t.selectProps.controlShouldRenderValue;
  return Me({
    alignItems: "center",
    display: o && a && s ? "flex" : "grid",
    flex: 1,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, n ? {} : {
    padding: "".concat(r.baseUnit / 2, "px ").concat(r.baseUnit * 2, "px")
  });
}, xG = function(t) {
  var n = t.children, r = t.innerProps, o = t.isMulti, a = t.hasValue;
  return Te("div", Re({}, jt(t, "valueContainer", {
    "value-container": !0,
    "value-container--is-multi": o,
    "value-container--has-value": a
  }), r), n);
}, wG = function() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
}, _G = function(t) {
  var n = t.children, r = t.innerProps;
  return Te("div", Re({}, jt(t, "indicatorsContainer", {
    indicators: !0
  }), r), n);
}, uT, SG = ["size"], EG = ["innerProps", "isRtl", "size"], CG = {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
}, v2 = function(t) {
  var n = t.size, r = fi(t, SG);
  return Te("svg", Re({
    height: n,
    width: n,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: CG
  }, r));
}, lx = function(t) {
  return Te(v2, Re({
    size: 20
  }, t), Te("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
}, b2 = function(t) {
  return Te(v2, Re({
    size: 20
  }, t), Te("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
}, x2 = function(t, n) {
  var r = t.isFocused, o = t.theme, a = o.spacing.baseUnit, s = o.colors;
  return Me({
    label: "indicatorContainer",
    display: "flex",
    transition: "color 150ms"
  }, n ? {} : {
    color: r ? s.neutral60 : s.neutral20,
    padding: a * 2,
    ":hover": {
      color: r ? s.neutral80 : s.neutral40
    }
  });
}, kG = x2, TG = function(t) {
  var n = t.children, r = t.innerProps;
  return Te("div", Re({}, jt(t, "dropdownIndicator", {
    indicator: !0,
    "dropdown-indicator": !0
  }), r), n || Te(b2, null));
}, AG = x2, RG = function(t) {
  var n = t.children, r = t.innerProps;
  return Te("div", Re({}, jt(t, "clearIndicator", {
    indicator: !0,
    "clear-indicator": !0
  }), r), n || Te(lx, null));
}, MG = function(t, n) {
  var r = t.isDisabled, o = t.theme, a = o.spacing.baseUnit, s = o.colors;
  return Me({
    label: "indicatorSeparator",
    alignSelf: "stretch",
    width: 1
  }, n ? {} : {
    backgroundColor: r ? s.neutral10 : s.neutral20,
    marginBottom: a * 2,
    marginTop: a * 2
  });
}, OG = function(t) {
  var n = t.innerProps;
  return Te("span", Re({}, n, jt(t, "indicatorSeparator", {
    "indicator-separator": !0
  })));
}, NG = em(uT || (uT = Bq([`
  0%, 80%, 100% { opacity: 0; }
  40% { opacity: 1; }
`]))), DG = function(t, n) {
  var r = t.isFocused, o = t.size, a = t.theme, s = a.colors, u = a.spacing.baseUnit;
  return Me({
    label: "loadingIndicator",
    display: "flex",
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: o,
    lineHeight: 1,
    marginRight: o,
    textAlign: "center",
    verticalAlign: "middle"
  }, n ? {} : {
    color: r ? s.neutral60 : s.neutral20,
    padding: u * 2
  });
}, Xy = function(t) {
  var n = t.delay, r = t.offset;
  return Te("span", {
    css: /* @__PURE__ */ _1({
      animation: "".concat(NG, " 1s ease-in-out ").concat(n, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: r ? "1em" : void 0,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, "", "")
  });
}, jG = function(t) {
  var n = t.innerProps, r = t.isRtl, o = t.size, a = o === void 0 ? 4 : o, s = fi(t, EG);
  return Te("div", Re({}, jt(Me(Me({}, s), {}, {
    innerProps: n,
    isRtl: r,
    size: a
  }), "loadingIndicator", {
    indicator: !0,
    "loading-indicator": !0
  }), n), Te(Xy, {
    delay: 0,
    offset: r
  }), Te(Xy, {
    delay: 160,
    offset: !0
  }), Te(Xy, {
    delay: 320,
    offset: !r
  }));
}, PG = function(t, n) {
  var r = t.isDisabled, o = t.isFocused, a = t.theme, s = a.colors, u = a.borderRadius, c = a.spacing;
  return Me({
    label: "control",
    alignItems: "center",
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: c.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms"
  }, n ? {} : {
    backgroundColor: r ? s.neutral5 : s.neutral0,
    borderColor: r ? s.neutral10 : o ? s.primary : s.neutral20,
    borderRadius: u,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: o ? "0 0 0 1px ".concat(s.primary) : void 0,
    "&:hover": {
      borderColor: o ? s.primary : s.neutral30
    }
  });
}, IG = function(t) {
  var n = t.children, r = t.isDisabled, o = t.isFocused, a = t.innerRef, s = t.innerProps, u = t.menuIsOpen;
  return Te("div", Re({
    ref: a
  }, jt(t, "control", {
    control: !0,
    "control--is-disabled": r,
    "control--is-focused": o,
    "control--menu-is-open": u
  }), s, {
    "aria-disabled": r || void 0
  }), n);
}, zG = IG, LG = ["data"], FG = function(t, n) {
  var r = t.theme.spacing;
  return n ? {} : {
    paddingBottom: r.baseUnit * 2,
    paddingTop: r.baseUnit * 2
  };
}, $G = function(t) {
  var n = t.children, r = t.cx, o = t.getStyles, a = t.getClassNames, s = t.Heading, u = t.headingProps, c = t.innerProps, f = t.label, h = t.theme, p = t.selectProps;
  return Te("div", Re({}, jt(t, "group", {
    group: !0
  }), c), Te(s, Re({}, u, {
    selectProps: p,
    theme: h,
    getStyles: o,
    getClassNames: a,
    cx: r
  }), f), Te("div", null, n));
}, BG = function(t, n) {
  var r = t.theme, o = r.colors, a = r.spacing;
  return Me({
    label: "group",
    cursor: "default",
    display: "block"
  }, n ? {} : {
    color: o.neutral40,
    fontSize: "75%",
    fontWeight: 500,
    marginBottom: "0.25em",
    paddingLeft: a.baseUnit * 3,
    paddingRight: a.baseUnit * 3,
    textTransform: "uppercase"
  });
}, HG = function(t) {
  var n = d2(t);
  n.data;
  var r = fi(n, LG);
  return Te("div", Re({}, jt(t, "groupHeading", {
    "group-heading": !0
  }), r));
}, VG = $G, UG = ["innerRef", "isDisabled", "isHidden", "inputClassName"], qG = function(t, n) {
  var r = t.isDisabled, o = t.value, a = t.theme, s = a.spacing, u = a.colors;
  return Me(Me({
    visibility: r ? "hidden" : "visible",
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: o ? "translateZ(0)" : ""
  }, GG), n ? {} : {
    margin: s.baseUnit / 2,
    paddingBottom: s.baseUnit / 2,
    paddingTop: s.baseUnit / 2,
    color: u.neutral80
  });
}, w2 = {
  gridArea: "1 / 2",
  font: "inherit",
  minWidth: "2px",
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
}, GG = {
  flex: "1 1 auto",
  display: "inline-grid",
  gridArea: "1 / 1 / 2 / 3",
  gridTemplateColumns: "0 min-content",
  "&:after": Me({
    content: 'attr(data-value) " "',
    visibility: "hidden",
    whiteSpace: "pre"
  }, w2)
}, YG = function(t) {
  return Me({
    label: "input",
    color: "inherit",
    background: 0,
    opacity: t ? 0 : 1,
    width: "100%"
  }, w2);
}, WG = function(t) {
  var n = t.cx, r = t.value, o = d2(t), a = o.innerRef, s = o.isDisabled, u = o.isHidden, c = o.inputClassName, f = fi(o, UG);
  return Te("div", Re({}, jt(t, "input", {
    "input-container": !0
  }), {
    "data-value": r || ""
  }), Te("input", Re({
    className: n({
      input: !0
    }, c),
    ref: a,
    style: YG(u),
    disabled: s
  }, f)));
}, XG = WG, KG = function(t, n) {
  var r = t.theme, o = r.spacing, a = r.borderRadius, s = r.colors;
  return Me({
    label: "multiValue",
    display: "flex",
    minWidth: 0
  }, n ? {} : {
    backgroundColor: s.neutral10,
    borderRadius: a / 2,
    margin: o.baseUnit / 2
  });
}, ZG = function(t, n) {
  var r = t.theme, o = r.borderRadius, a = r.colors, s = t.cropWithEllipsis;
  return Me({
    overflow: "hidden",
    textOverflow: s || s === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, n ? {} : {
    borderRadius: o / 2,
    color: a.neutral80,
    fontSize: "85%",
    padding: 3,
    paddingLeft: 6
  });
}, QG = function(t, n) {
  var r = t.theme, o = r.spacing, a = r.borderRadius, s = r.colors, u = t.isFocused;
  return Me({
    alignItems: "center",
    display: "flex"
  }, n ? {} : {
    borderRadius: a / 2,
    backgroundColor: u ? s.dangerLight : void 0,
    paddingLeft: o.baseUnit,
    paddingRight: o.baseUnit,
    ":hover": {
      backgroundColor: s.dangerLight,
      color: s.danger
    }
  });
}, _2 = function(t) {
  var n = t.children, r = t.innerProps;
  return Te("div", r, n);
}, JG = _2, eY = _2;
function tY(e) {
  var t = e.children, n = e.innerProps;
  return Te("div", Re({
    role: "button"
  }, n), t || Te(lx, {
    size: 14
  }));
}
var nY = function(t) {
  var n = t.children, r = t.components, o = t.data, a = t.innerProps, s = t.isDisabled, u = t.removeProps, c = t.selectProps, f = r.Container, h = r.Label, p = r.Remove;
  return Te(f, {
    data: o,
    innerProps: Me(Me({}, jt(t, "multiValue", {
      "multi-value": !0,
      "multi-value--is-disabled": s
    })), a),
    selectProps: c
  }, Te(h, {
    data: o,
    innerProps: Me({}, jt(t, "multiValueLabel", {
      "multi-value__label": !0
    })),
    selectProps: c
  }, n), Te(p, {
    data: o,
    innerProps: Me(Me({}, jt(t, "multiValueRemove", {
      "multi-value__remove": !0
    })), {}, {
      "aria-label": "Remove ".concat(n || "option")
    }, u),
    selectProps: c
  }));
}, rY = nY, oY = function(t, n) {
  var r = t.isDisabled, o = t.isFocused, a = t.isSelected, s = t.theme, u = s.spacing, c = s.colors;
  return Me({
    label: "option",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
  }, n ? {} : {
    backgroundColor: a ? c.primary : o ? c.primary25 : "transparent",
    color: r ? c.neutral20 : a ? c.neutral0 : "inherit",
    padding: "".concat(u.baseUnit * 2, "px ").concat(u.baseUnit * 3, "px"),
    // provide some affordance on touch devices
    ":active": {
      backgroundColor: r ? void 0 : a ? c.primary : c.primary50
    }
  });
}, iY = function(t) {
  var n = t.children, r = t.isDisabled, o = t.isFocused, a = t.isSelected, s = t.innerRef, u = t.innerProps;
  return Te("div", Re({}, jt(t, "option", {
    option: !0,
    "option--is-disabled": r,
    "option--is-focused": o,
    "option--is-selected": a
  }), {
    ref: s,
    "aria-disabled": r
  }, u), n);
}, aY = iY, sY = function(t, n) {
  var r = t.theme, o = r.spacing, a = r.colors;
  return Me({
    label: "placeholder",
    gridArea: "1 / 1 / 2 / 3"
  }, n ? {} : {
    color: a.neutral50,
    marginLeft: o.baseUnit / 2,
    marginRight: o.baseUnit / 2
  });
}, lY = function(t) {
  var n = t.children, r = t.innerProps;
  return Te("div", Re({}, jt(t, "placeholder", {
    placeholder: !0
  }), r), n);
}, uY = lY, cY = function(t, n) {
  var r = t.isDisabled, o = t.theme, a = o.spacing, s = o.colors;
  return Me({
    label: "singleValue",
    gridArea: "1 / 1 / 2 / 3",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, n ? {} : {
    color: r ? s.neutral40 : s.neutral80,
    marginLeft: a.baseUnit / 2,
    marginRight: a.baseUnit / 2
  });
}, fY = function(t) {
  var n = t.children, r = t.isDisabled, o = t.innerProps;
  return Te("div", Re({}, jt(t, "singleValue", {
    "single-value": !0,
    "single-value--is-disabled": r
  }), o), n);
}, dY = fY, hY = {
  ClearIndicator: RG,
  Control: zG,
  DropdownIndicator: TG,
  DownChevron: b2,
  CrossIcon: lx,
  Group: VG,
  GroupHeading: HG,
  IndicatorsContainer: _G,
  IndicatorSeparator: OG,
  Input: XG,
  LoadingIndicator: jG,
  Menu: lG,
  MenuList: cG,
  MenuPortal: gG,
  LoadingMessage: pG,
  NoOptionsMessage: hG,
  MultiValue: rY,
  MultiValueContainer: JG,
  MultiValueLabel: eY,
  MultiValueRemove: tY,
  Option: aY,
  Placeholder: uY,
  SelectContainer: vG,
  SingleValue: dY,
  ValueContainer: xG
}, pY = function(t) {
  return Me(Me({}, hY), t.components);
}, cT = Number.isNaN || function(t) {
  return typeof t == "number" && t !== t;
};
function mY(e, t) {
  return !!(e === t || cT(e) && cT(t));
}
function gY(e, t) {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++)
    if (!mY(e[n], t[n]))
      return !1;
  return !0;
}
function yY(e, t) {
  t === void 0 && (t = gY);
  var n = null;
  function r() {
    for (var o = [], a = 0; a < arguments.length; a++)
      o[a] = arguments[a];
    if (n && n.lastThis === this && t(o, n.lastArgs))
      return n.lastResult;
    var s = e.apply(this, o);
    return n = {
      lastResult: s,
      lastArgs: o,
      lastThis: this
    }, s;
  }
  return r.clear = function() {
    n = null;
  }, r;
}
var vY = {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
}, bY = function(t) {
  return Te("span", Re({
    css: vY
  }, t));
}, fT = bY, xY = {
  guidance: function(t) {
    var n = t.isSearchable, r = t.isMulti, o = t.tabSelectsValue, a = t.context, s = t.isInitialFocus;
    switch (a) {
      case "menu":
        return "Use Up and Down to choose options, press Enter to select the currently focused option, press Escape to exit the menu".concat(o ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return s ? "".concat(t["aria-label"] || "Select", " is focused ").concat(n ? ",type to refine list" : "", ", press Down to open the menu, ").concat(r ? " press left to focus selected values" : "") : "";
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  },
  onChange: function(t) {
    var n = t.action, r = t.label, o = r === void 0 ? "" : r, a = t.labels, s = t.isDisabled;
    switch (n) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(o, ", deselected.");
      case "clear":
        return "All selected options have been cleared.";
      case "initial-input-focus":
        return "option".concat(a.length > 1 ? "s" : "", " ").concat(a.join(","), ", selected.");
      case "select-option":
        return s ? "option ".concat(o, " is disabled. Select another option.") : "option ".concat(o, ", selected.");
      default:
        return "";
    }
  },
  onFocus: function(t) {
    var n = t.context, r = t.focused, o = t.options, a = t.label, s = a === void 0 ? "" : a, u = t.selectValue, c = t.isDisabled, f = t.isSelected, h = t.isAppleDevice, p = function(v, S) {
      return v && v.length ? "".concat(v.indexOf(S) + 1, " of ").concat(v.length) : "";
    };
    if (n === "value" && u)
      return "value ".concat(s, " focused, ").concat(p(u, r), ".");
    if (n === "menu" && h) {
      var g = c ? " disabled" : "", y = "".concat(f ? " selected" : "").concat(g);
      return "".concat(s).concat(y, ", ").concat(p(o, r), ".");
    }
    return "";
  },
  onFilter: function(t) {
    var n = t.inputValue, r = t.resultsMessage;
    return "".concat(r).concat(n ? " for search term " + n : "", ".");
  }
}, wY = function(t) {
  var n = t.ariaSelection, r = t.focusedOption, o = t.focusedValue, a = t.focusableOptions, s = t.isFocused, u = t.selectValue, c = t.selectProps, f = t.id, h = t.isAppleDevice, p = c.ariaLiveMessages, g = c.getOptionLabel, y = c.inputValue, w = c.isMulti, v = c.isOptionDisabled, S = c.isSearchable, E = c.menuIsOpen, A = c.options, k = c.screenReaderStatus, T = c.tabSelectsValue, R = c.isLoading, N = c["aria-label"], j = c["aria-live"], z = _.useMemo(function() {
    return Me(Me({}, xY), p || {});
  }, [p]), B = _.useMemo(function() {
    var V = "";
    if (n && z.onChange) {
      var I = n.option, U = n.options, H = n.removedValue, G = n.removedValues, O = n.value, W = function(ae) {
        return Array.isArray(ae) ? null : ae;
      }, Z = H || I || W(O), L = Z ? g(Z) : "", te = U || G || void 0, he = te ? te.map(g) : [], oe = Me({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: Z && v(Z, u),
        label: L,
        labels: he
      }, n);
      V = z.onChange(oe);
    }
    return V;
  }, [n, z, v, u, g]), M = _.useMemo(function() {
    var V = "", I = r || o, U = !!(r && u && u.includes(r));
    if (I && z.onFocus) {
      var H = {
        focused: I,
        label: g(I),
        isDisabled: v(I, u),
        isSelected: U,
        options: a,
        context: I === r ? "menu" : "value",
        selectValue: u,
        isAppleDevice: h
      };
      V = z.onFocus(H);
    }
    return V;
  }, [r, o, g, v, z, a, u, h]), F = _.useMemo(function() {
    var V = "";
    if (E && A.length && !R && z.onFilter) {
      var I = k({
        count: a.length
      });
      V = z.onFilter({
        inputValue: y,
        resultsMessage: I
      });
    }
    return V;
  }, [a, y, E, z, A, k, R]), q = n?.action === "initial-input-focus", Y = _.useMemo(function() {
    var V = "";
    if (z.guidance) {
      var I = o ? "value" : E ? "menu" : "input";
      V = z.guidance({
        "aria-label": N,
        context: I,
        isDisabled: r && v(r, u),
        isMulti: w,
        isSearchable: S,
        tabSelectsValue: T,
        isInitialFocus: q
      });
    }
    return V;
  }, [N, r, o, w, v, S, E, z, u, T, q]), P = Te(_.Fragment, null, Te("span", {
    id: "aria-selection"
  }, B), Te("span", {
    id: "aria-focused"
  }, M), Te("span", {
    id: "aria-results"
  }, F), Te("span", {
    id: "aria-guidance"
  }, Y));
  return Te(_.Fragment, null, Te(fT, {
    id: f
  }, q && P), Te(fT, {
    "aria-live": j,
    "aria-atomic": "false",
    "aria-relevant": "additions text",
    role: "log"
  }, s && !q && P));
}, _Y = wY, xb = [{
  base: "A",
  letters: "A"
}, {
  base: "AA",
  letters: ""
}, {
  base: "AE",
  letters: ""
}, {
  base: "AO",
  letters: ""
}, {
  base: "AU",
  letters: ""
}, {
  base: "AV",
  letters: ""
}, {
  base: "AY",
  letters: ""
}, {
  base: "B",
  letters: "B"
}, {
  base: "C",
  letters: "C"
}, {
  base: "D",
  letters: "D"
}, {
  base: "DZ",
  letters: ""
}, {
  base: "Dz",
  letters: ""
}, {
  base: "E",
  letters: "E"
}, {
  base: "F",
  letters: "F"
}, {
  base: "G",
  letters: "G"
}, {
  base: "H",
  letters: "H"
}, {
  base: "I",
  letters: "I"
}, {
  base: "J",
  letters: "J"
}, {
  base: "K",
  letters: "K"
}, {
  base: "L",
  letters: "L"
}, {
  base: "LJ",
  letters: ""
}, {
  base: "Lj",
  letters: ""
}, {
  base: "M",
  letters: "M"
}, {
  base: "N",
  letters: "N"
}, {
  base: "NJ",
  letters: ""
}, {
  base: "Nj",
  letters: ""
}, {
  base: "O",
  letters: "O"
}, {
  base: "OI",
  letters: ""
}, {
  base: "OO",
  letters: ""
}, {
  base: "OU",
  letters: ""
}, {
  base: "P",
  letters: "P"
}, {
  base: "Q",
  letters: "Q"
}, {
  base: "R",
  letters: "R"
}, {
  base: "S",
  letters: "S"
}, {
  base: "T",
  letters: "T"
}, {
  base: "TZ",
  letters: ""
}, {
  base: "U",
  letters: "U"
}, {
  base: "V",
  letters: "V"
}, {
  base: "VY",
  letters: ""
}, {
  base: "W",
  letters: "W"
}, {
  base: "X",
  letters: "X"
}, {
  base: "Y",
  letters: "Y"
}, {
  base: "Z",
  letters: "Z"
}, {
  base: "a",
  letters: "a"
}, {
  base: "aa",
  letters: ""
}, {
  base: "ae",
  letters: ""
}, {
  base: "ao",
  letters: ""
}, {
  base: "au",
  letters: ""
}, {
  base: "av",
  letters: ""
}, {
  base: "ay",
  letters: ""
}, {
  base: "b",
  letters: "b"
}, {
  base: "c",
  letters: "c"
}, {
  base: "d",
  letters: "d"
}, {
  base: "dz",
  letters: ""
}, {
  base: "e",
  letters: "e"
}, {
  base: "f",
  letters: "f"
}, {
  base: "g",
  letters: "g"
}, {
  base: "h",
  letters: "h"
}, {
  base: "hv",
  letters: ""
}, {
  base: "i",
  letters: "i"
}, {
  base: "j",
  letters: "j"
}, {
  base: "k",
  letters: "k"
}, {
  base: "l",
  letters: "l"
}, {
  base: "lj",
  letters: ""
}, {
  base: "m",
  letters: "m"
}, {
  base: "n",
  letters: "n"
}, {
  base: "nj",
  letters: ""
}, {
  base: "o",
  letters: "o"
}, {
  base: "oi",
  letters: ""
}, {
  base: "ou",
  letters: ""
}, {
  base: "oo",
  letters: ""
}, {
  base: "p",
  letters: "p"
}, {
  base: "q",
  letters: "q"
}, {
  base: "r",
  letters: "r"
}, {
  base: "s",
  letters: "s"
}, {
  base: "t",
  letters: "t"
}, {
  base: "tz",
  letters: ""
}, {
  base: "u",
  letters: "u"
}, {
  base: "v",
  letters: "v"
}, {
  base: "vy",
  letters: ""
}, {
  base: "w",
  letters: "w"
}, {
  base: "x",
  letters: "x"
}, {
  base: "y",
  letters: "y"
}, {
  base: "z",
  letters: "z"
}], SY = new RegExp("[" + xb.map(function(e) {
  return e.letters;
}).join("") + "]", "g"), S2 = {};
for (var Ky = 0; Ky < xb.length; Ky++)
  for (var Zy = xb[Ky], Qy = 0; Qy < Zy.letters.length; Qy++)
    S2[Zy.letters[Qy]] = Zy.base;
var E2 = function(t) {
  return t.replace(SY, function(n) {
    return S2[n];
  });
}, EY = yY(E2), dT = function(t) {
  return t.replace(/^\s+|\s+$/g, "");
}, CY = function(t) {
  return "".concat(t.label, " ").concat(t.value);
}, kY = function(t) {
  return function(n, r) {
    if (n.data.__isNew__) return !0;
    var o = Me({
      ignoreCase: !0,
      ignoreAccents: !0,
      stringify: CY,
      trim: !0,
      matchFrom: "any"
    }, t), a = o.ignoreCase, s = o.ignoreAccents, u = o.stringify, c = o.trim, f = o.matchFrom, h = c ? dT(r) : r, p = c ? dT(u(n)) : u(n);
    return a && (h = h.toLowerCase(), p = p.toLowerCase()), s && (h = EY(h), p = E2(p)), f === "start" ? p.substr(0, h.length) === h : p.indexOf(h) > -1;
  };
}, TY = ["innerRef"];
function AY(e) {
  var t = e.innerRef, n = fi(e, TY), r = eG(n, "onExited", "in", "enter", "exit", "appear");
  return Te("input", Re({
    ref: t
  }, r, {
    css: /* @__PURE__ */ _1({
      label: "dummyInput",
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: "transparent",
      fontSize: "inherit",
      gridArea: "1 / 1 / 2 / 3",
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: "transparent",
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(.01)"
    }, "", "")
  }));
}
var RY = function(t) {
  t.cancelable && t.preventDefault(), t.stopPropagation();
};
function MY(e) {
  var t = e.isEnabled, n = e.onBottomArrive, r = e.onBottomLeave, o = e.onTopArrive, a = e.onTopLeave, s = _.useRef(!1), u = _.useRef(!1), c = _.useRef(0), f = _.useRef(null), h = _.useCallback(function(S, E) {
    if (f.current !== null) {
      var A = f.current, k = A.scrollTop, T = A.scrollHeight, R = A.clientHeight, N = f.current, j = E > 0, z = T - R - k, B = !1;
      z > E && s.current && (r && r(S), s.current = !1), j && u.current && (a && a(S), u.current = !1), j && E > z ? (n && !s.current && n(S), N.scrollTop = T, B = !0, s.current = !0) : !j && -E > k && (o && !u.current && o(S), N.scrollTop = 0, B = !0, u.current = !0), B && RY(S);
    }
  }, [n, r, o, a]), p = _.useCallback(function(S) {
    h(S, S.deltaY);
  }, [h]), g = _.useCallback(function(S) {
    c.current = S.changedTouches[0].clientY;
  }, []), y = _.useCallback(function(S) {
    var E = c.current - S.changedTouches[0].clientY;
    h(S, E);
  }, [h]), w = _.useCallback(function(S) {
    if (S) {
      var E = Zq ? {
        passive: !1
      } : !1;
      S.addEventListener("wheel", p, E), S.addEventListener("touchstart", g, E), S.addEventListener("touchmove", y, E);
    }
  }, [y, g, p]), v = _.useCallback(function(S) {
    S && (S.removeEventListener("wheel", p, !1), S.removeEventListener("touchstart", g, !1), S.removeEventListener("touchmove", y, !1));
  }, [y, g, p]);
  return _.useEffect(function() {
    if (t) {
      var S = f.current;
      return w(S), function() {
        v(S);
      };
    }
  }, [t, w, v]), function(S) {
    f.current = S;
  };
}
var hT = ["boxSizing", "height", "overflow", "paddingRight", "position"], pT = {
  boxSizing: "border-box",
  // account for possible declaration `width: 100%;` on body
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function mT(e) {
  e.cancelable && e.preventDefault();
}
function gT(e) {
  e.stopPropagation();
}
function yT() {
  var e = this.scrollTop, t = this.scrollHeight, n = e + this.offsetHeight;
  e === 0 ? this.scrollTop = 1 : n === t && (this.scrollTop = e - 1);
}
function vT() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
var bT = !!(typeof window < "u" && window.document && window.document.createElement), rc = 0, Zs = {
  capture: !1,
  passive: !1
};
function OY(e) {
  var t = e.isEnabled, n = e.accountForScrollbars, r = n === void 0 ? !0 : n, o = _.useRef({}), a = _.useRef(null), s = _.useCallback(function(c) {
    if (bT) {
      var f = document.body, h = f && f.style;
      if (r && hT.forEach(function(w) {
        var v = h && h[w];
        o.current[w] = v;
      }), r && rc < 1) {
        var p = parseInt(o.current.paddingRight, 10) || 0, g = document.body ? document.body.clientWidth : 0, y = window.innerWidth - g + p || 0;
        Object.keys(pT).forEach(function(w) {
          var v = pT[w];
          h && (h[w] = v);
        }), h && (h.paddingRight = "".concat(y, "px"));
      }
      f && vT() && (f.addEventListener("touchmove", mT, Zs), c && (c.addEventListener("touchstart", yT, Zs), c.addEventListener("touchmove", gT, Zs))), rc += 1;
    }
  }, [r]), u = _.useCallback(function(c) {
    if (bT) {
      var f = document.body, h = f && f.style;
      rc = Math.max(rc - 1, 0), r && rc < 1 && hT.forEach(function(p) {
        var g = o.current[p];
        h && (h[p] = g);
      }), f && vT() && (f.removeEventListener("touchmove", mT, Zs), c && (c.removeEventListener("touchstart", yT, Zs), c.removeEventListener("touchmove", gT, Zs)));
    }
  }, [r]);
  return _.useEffect(function() {
    if (t) {
      var c = a.current;
      return s(c), function() {
        u(c);
      };
    }
  }, [t, s, u]), function(c) {
    a.current = c;
  };
}
var NY = function(t) {
  var n = t.target;
  return n.ownerDocument.activeElement && n.ownerDocument.activeElement.blur();
}, DY = {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
};
function jY(e) {
  var t = e.children, n = e.lockEnabled, r = e.captureEnabled, o = r === void 0 ? !0 : r, a = e.onBottomArrive, s = e.onBottomLeave, u = e.onTopArrive, c = e.onTopLeave, f = MY({
    isEnabled: o,
    onBottomArrive: a,
    onBottomLeave: s,
    onTopArrive: u,
    onTopLeave: c
  }), h = OY({
    isEnabled: n
  }), p = function(y) {
    f(y), h(y);
  };
  return Te(_.Fragment, null, n && Te("div", {
    onClick: NY,
    css: DY
  }), t(p));
}
var PY = {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
}, IY = function(t) {
  var n = t.name, r = t.onFocus;
  return Te("input", {
    required: !0,
    name: n,
    tabIndex: -1,
    "aria-hidden": "true",
    onFocus: r,
    css: PY,
    value: "",
    onChange: function() {
    }
  });
}, zY = IY;
function ux(e) {
  var t;
  return typeof window < "u" && window.navigator != null ? e.test(((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.platform) || window.navigator.platform) : !1;
}
function LY() {
  return ux(/^iPhone/i);
}
function C2() {
  return ux(/^Mac/i);
}
function FY() {
  return ux(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
  C2() && navigator.maxTouchPoints > 1;
}
function $Y() {
  return LY() || FY();
}
function BY() {
  return C2() || $Y();
}
var HY = function(t) {
  return t.label;
}, VY = function(t) {
  return t.label;
}, UY = function(t) {
  return t.value;
}, qY = function(t) {
  return !!t.isDisabled;
}, GY = {
  clearIndicator: AG,
  container: yG,
  control: PG,
  dropdownIndicator: kG,
  group: FG,
  groupHeading: BG,
  indicatorsContainer: wG,
  indicatorSeparator: MG,
  input: qG,
  loadingIndicator: DG,
  loadingMessage: dG,
  menu: iG,
  menuList: uG,
  menuPortal: mG,
  multiValue: KG,
  multiValueLabel: ZG,
  multiValueRemove: QG,
  noOptionsMessage: fG,
  option: oY,
  placeholder: sY,
  singleValue: cY,
  valueContainer: bG
}, YY = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
}, WY = 4, k2 = 4, XY = 38, KY = k2 * 2, ZY = {
  baseUnit: k2,
  controlHeight: XY,
  menuGutter: KY
}, Jy = {
  borderRadius: WY,
  colors: YY,
  spacing: ZY
}, QY = {
  "aria-live": "polite",
  backspaceRemovesValue: !0,
  blurInputOnSelect: lT(),
  captureMenuScroll: !lT(),
  classNames: {},
  closeMenuOnSelect: !0,
  closeMenuOnScroll: !1,
  components: {},
  controlShouldRenderValue: !0,
  escapeClearsValue: !1,
  filterOption: kY(),
  formatGroupLabel: HY,
  getOptionLabel: VY,
  getOptionValue: UY,
  isDisabled: !1,
  isLoading: !1,
  isMulti: !1,
  isRtl: !1,
  isSearchable: !0,
  isOptionDisabled: qY,
  loadingMessage: function() {
    return "Loading...";
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: !1,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: !1,
  menuShouldScrollIntoView: !Xq(),
  noOptionsMessage: function() {
    return "No options";
  },
  openMenuOnFocus: !1,
  openMenuOnClick: !0,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: function(t) {
    var n = t.count;
    return "".concat(n, " result").concat(n !== 1 ? "s" : "", " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: !0,
  unstyled: !1
};
function xT(e, t, n, r) {
  var o = R2(e, t, n), a = M2(e, t, n), s = A2(e, t), u = pp(e, t);
  return {
    type: "option",
    data: t,
    isDisabled: o,
    isSelected: a,
    label: s,
    value: u,
    index: r
  };
}
function Bh(e, t) {
  return e.options.map(function(n, r) {
    if ("options" in n) {
      var o = n.options.map(function(s, u) {
        return xT(e, s, t, u);
      }).filter(function(s) {
        return _T(e, s);
      });
      return o.length > 0 ? {
        type: "group",
        data: n,
        options: o,
        index: r
      } : void 0;
    }
    var a = xT(e, n, t, r);
    return _T(e, a) ? a : void 0;
  }).filter(Qq);
}
function T2(e) {
  return e.reduce(function(t, n) {
    return n.type === "group" ? t.push.apply(t, sx(n.options.map(function(r) {
      return r.data;
    }))) : t.push(n.data), t;
  }, []);
}
function wT(e, t) {
  return e.reduce(function(n, r) {
    return r.type === "group" ? n.push.apply(n, sx(r.options.map(function(o) {
      return {
        data: o.data,
        id: "".concat(t, "-").concat(r.index, "-").concat(o.index)
      };
    }))) : n.push({
      data: r.data,
      id: "".concat(t, "-").concat(r.index)
    }), n;
  }, []);
}
function JY(e, t) {
  return T2(Bh(e, t));
}
function _T(e, t) {
  var n = e.inputValue, r = n === void 0 ? "" : n, o = t.data, a = t.isSelected, s = t.label, u = t.value;
  return (!N2(e) || !a) && O2(e, {
    label: s,
    value: u,
    data: o
  }, r);
}
function eW(e, t) {
  var n = e.focusedValue, r = e.selectValue, o = r.indexOf(n);
  if (o > -1) {
    var a = t.indexOf(n);
    if (a > -1)
      return n;
    if (o < t.length)
      return t[o];
  }
  return null;
}
function tW(e, t) {
  var n = e.focusedOption;
  return n && t.indexOf(n) > -1 ? n : t[0];
}
var ev = function(t, n) {
  var r, o = (r = t.find(function(a) {
    return a.data === n;
  })) === null || r === void 0 ? void 0 : r.id;
  return o || null;
}, A2 = function(t, n) {
  return t.getOptionLabel(n);
}, pp = function(t, n) {
  return t.getOptionValue(n);
};
function R2(e, t, n) {
  return typeof e.isOptionDisabled == "function" ? e.isOptionDisabled(t, n) : !1;
}
function M2(e, t, n) {
  if (n.indexOf(t) > -1) return !0;
  if (typeof e.isOptionSelected == "function")
    return e.isOptionSelected(t, n);
  var r = pp(e, t);
  return n.some(function(o) {
    return pp(e, o) === r;
  });
}
function O2(e, t, n) {
  return e.filterOption ? e.filterOption(t, n) : !0;
}
var N2 = function(t) {
  var n = t.hideSelectedOptions, r = t.isMulti;
  return n === void 0 ? r : n;
}, nW = 1, D2 = /* @__PURE__ */ function(e) {
  Pq(n, e);
  var t = zq(n);
  function n(r) {
    var o;
    if (Dq(this, n), o = t.call(this, r), o.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedOptionId: null,
      focusableOptionsWithIds: [],
      focusedValue: null,
      inputIsHidden: !1,
      isFocused: !1,
      selectValue: [],
      clearFocusValueOnUpdate: !1,
      prevWasFocused: !1,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0,
      instancePrefix: "",
      isAppleDevice: !1
    }, o.blockOptionHover = !1, o.isComposing = !1, o.commonProps = void 0, o.initialTouchX = 0, o.initialTouchY = 0, o.openAfterFocus = !1, o.scrollToFocusedOptionOnUpdate = !1, o.userIsDragging = void 0, o.controlRef = null, o.getControlRef = function(c) {
      o.controlRef = c;
    }, o.focusedOptionRef = null, o.getFocusedOptionRef = function(c) {
      o.focusedOptionRef = c;
    }, o.menuListRef = null, o.getMenuListRef = function(c) {
      o.menuListRef = c;
    }, o.inputRef = null, o.getInputRef = function(c) {
      o.inputRef = c;
    }, o.focus = o.focusInput, o.blur = o.blurInput, o.onChange = function(c, f) {
      var h = o.props, p = h.onChange, g = h.name;
      f.name = g, o.ariaOnChange(c, f), p(c, f);
    }, o.setValue = function(c, f, h) {
      var p = o.props, g = p.closeMenuOnSelect, y = p.isMulti, w = p.inputValue;
      o.onInputChange("", {
        action: "set-value",
        prevInputValue: w
      }), g && (o.setState({
        inputIsHiddenAfterUpdate: !y
      }), o.onMenuClose()), o.setState({
        clearFocusValueOnUpdate: !0
      }), o.onChange(c, {
        action: f,
        option: h
      });
    }, o.selectOption = function(c) {
      var f = o.props, h = f.blurInputOnSelect, p = f.isMulti, g = f.name, y = o.state.selectValue, w = p && o.isOptionSelected(c, y), v = o.isOptionDisabled(c, y);
      if (w) {
        var S = o.getOptionValue(c);
        o.setValue(y.filter(function(E) {
          return o.getOptionValue(E) !== S;
        }), "deselect-option", c);
      } else if (!v)
        p ? o.setValue([].concat(sx(y), [c]), "select-option", c) : o.setValue(c, "select-option");
      else {
        o.ariaOnChange(c, {
          action: "select-option",
          option: c,
          name: g
        });
        return;
      }
      h && o.blurInput();
    }, o.removeValue = function(c) {
      var f = o.props.isMulti, h = o.state.selectValue, p = o.getOptionValue(c), g = h.filter(function(w) {
        return o.getOptionValue(w) !== p;
      }), y = uh(f, g, g[0] || null);
      o.onChange(y, {
        action: "remove-value",
        removedValue: c
      }), o.focusInput();
    }, o.clearValue = function() {
      var c = o.state.selectValue;
      o.onChange(uh(o.props.isMulti, [], null), {
        action: "clear",
        removedValues: c
      });
    }, o.popValue = function() {
      var c = o.props.isMulti, f = o.state.selectValue, h = f[f.length - 1], p = f.slice(0, f.length - 1), g = uh(c, p, p[0] || null);
      h && o.onChange(g, {
        action: "pop-value",
        removedValue: h
      });
    }, o.getFocusedOptionId = function(c) {
      return ev(o.state.focusableOptionsWithIds, c);
    }, o.getFocusableOptionsWithIds = function() {
      return wT(Bh(o.props, o.state.selectValue), o.getElementId("option"));
    }, o.getValue = function() {
      return o.state.selectValue;
    }, o.cx = function() {
      for (var c = arguments.length, f = new Array(c), h = 0; h < c; h++)
        f[h] = arguments[h];
      return Uq.apply(void 0, [o.props.classNamePrefix].concat(f));
    }, o.getOptionLabel = function(c) {
      return A2(o.props, c);
    }, o.getOptionValue = function(c) {
      return pp(o.props, c);
    }, o.getStyles = function(c, f) {
      var h = o.props.unstyled, p = GY[c](f, h);
      p.boxSizing = "border-box";
      var g = o.props.styles[c];
      return g ? g(p, f) : p;
    }, o.getClassNames = function(c, f) {
      var h, p;
      return (h = (p = o.props.classNames)[c]) === null || h === void 0 ? void 0 : h.call(p, f);
    }, o.getElementId = function(c) {
      return "".concat(o.state.instancePrefix, "-").concat(c);
    }, o.getComponents = function() {
      return pY(o.props);
    }, o.buildCategorizedOptions = function() {
      return Bh(o.props, o.state.selectValue);
    }, o.getCategorizedOptions = function() {
      return o.props.menuIsOpen ? o.buildCategorizedOptions() : [];
    }, o.buildFocusableOptions = function() {
      return T2(o.buildCategorizedOptions());
    }, o.getFocusableOptions = function() {
      return o.props.menuIsOpen ? o.buildFocusableOptions() : [];
    }, o.ariaOnChange = function(c, f) {
      o.setState({
        ariaSelection: Me({
          value: c
        }, f)
      });
    }, o.onMenuMouseDown = function(c) {
      c.button === 0 && (c.stopPropagation(), c.preventDefault(), o.focusInput());
    }, o.onMenuMouseMove = function(c) {
      o.blockOptionHover = !1;
    }, o.onControlMouseDown = function(c) {
      if (!c.defaultPrevented) {
        var f = o.props.openMenuOnClick;
        o.state.isFocused ? o.props.menuIsOpen ? c.target.tagName !== "INPUT" && c.target.tagName !== "TEXTAREA" && o.onMenuClose() : f && o.openMenu("first") : (f && (o.openAfterFocus = !0), o.focusInput()), c.target.tagName !== "INPUT" && c.target.tagName !== "TEXTAREA" && c.preventDefault();
      }
    }, o.onDropdownIndicatorMouseDown = function(c) {
      if (!(c && c.type === "mousedown" && c.button !== 0) && !o.props.isDisabled) {
        var f = o.props, h = f.isMulti, p = f.menuIsOpen;
        o.focusInput(), p ? (o.setState({
          inputIsHiddenAfterUpdate: !h
        }), o.onMenuClose()) : o.openMenu("first"), c.preventDefault();
      }
    }, o.onClearIndicatorMouseDown = function(c) {
      c && c.type === "mousedown" && c.button !== 0 || (o.clearValue(), c.preventDefault(), o.openAfterFocus = !1, c.type === "touchend" ? o.focusInput() : setTimeout(function() {
        return o.focusInput();
      }));
    }, o.onScroll = function(c) {
      typeof o.props.closeMenuOnScroll == "boolean" ? c.target instanceof HTMLElement && wm(c.target) && o.props.onMenuClose() : typeof o.props.closeMenuOnScroll == "function" && o.props.closeMenuOnScroll(c) && o.props.onMenuClose();
    }, o.onCompositionStart = function() {
      o.isComposing = !0;
    }, o.onCompositionEnd = function() {
      o.isComposing = !1;
    }, o.onTouchStart = function(c) {
      var f = c.touches, h = f && f.item(0);
      h && (o.initialTouchX = h.clientX, o.initialTouchY = h.clientY, o.userIsDragging = !1);
    }, o.onTouchMove = function(c) {
      var f = c.touches, h = f && f.item(0);
      if (h) {
        var p = Math.abs(h.clientX - o.initialTouchX), g = Math.abs(h.clientY - o.initialTouchY), y = 5;
        o.userIsDragging = p > y || g > y;
      }
    }, o.onTouchEnd = function(c) {
      o.userIsDragging || (o.controlRef && !o.controlRef.contains(c.target) && o.menuListRef && !o.menuListRef.contains(c.target) && o.blurInput(), o.initialTouchX = 0, o.initialTouchY = 0);
    }, o.onControlTouchEnd = function(c) {
      o.userIsDragging || o.onControlMouseDown(c);
    }, o.onClearIndicatorTouchEnd = function(c) {
      o.userIsDragging || o.onClearIndicatorMouseDown(c);
    }, o.onDropdownIndicatorTouchEnd = function(c) {
      o.userIsDragging || o.onDropdownIndicatorMouseDown(c);
    }, o.handleInputChange = function(c) {
      var f = o.props.inputValue, h = c.currentTarget.value;
      o.setState({
        inputIsHiddenAfterUpdate: !1
      }), o.onInputChange(h, {
        action: "input-change",
        prevInputValue: f
      }), o.props.menuIsOpen || o.onMenuOpen();
    }, o.onInputFocus = function(c) {
      o.props.onFocus && o.props.onFocus(c), o.setState({
        inputIsHiddenAfterUpdate: !1,
        isFocused: !0
      }), (o.openAfterFocus || o.props.openMenuOnFocus) && o.openMenu("first"), o.openAfterFocus = !1;
    }, o.onInputBlur = function(c) {
      var f = o.props.inputValue;
      if (o.menuListRef && o.menuListRef.contains(document.activeElement)) {
        o.inputRef.focus();
        return;
      }
      o.props.onBlur && o.props.onBlur(c), o.onInputChange("", {
        action: "input-blur",
        prevInputValue: f
      }), o.onMenuClose(), o.setState({
        focusedValue: null,
        isFocused: !1
      });
    }, o.onOptionHover = function(c) {
      if (!(o.blockOptionHover || o.state.focusedOption === c)) {
        var f = o.getFocusableOptions(), h = f.indexOf(c);
        o.setState({
          focusedOption: c,
          focusedOptionId: h > -1 ? o.getFocusedOptionId(c) : null
        });
      }
    }, o.shouldHideSelectedOptions = function() {
      return N2(o.props);
    }, o.onValueInputFocus = function(c) {
      c.preventDefault(), c.stopPropagation(), o.focus();
    }, o.onKeyDown = function(c) {
      var f = o.props, h = f.isMulti, p = f.backspaceRemovesValue, g = f.escapeClearsValue, y = f.inputValue, w = f.isClearable, v = f.isDisabled, S = f.menuIsOpen, E = f.onKeyDown, A = f.tabSelectsValue, k = f.openMenuOnFocus, T = o.state, R = T.focusedOption, N = T.focusedValue, j = T.selectValue;
      if (!v && !(typeof E == "function" && (E(c), c.defaultPrevented))) {
        switch (o.blockOptionHover = !0, c.key) {
          case "ArrowLeft":
            if (!h || y) return;
            o.focusValue("previous");
            break;
          case "ArrowRight":
            if (!h || y) return;
            o.focusValue("next");
            break;
          case "Delete":
          case "Backspace":
            if (y) return;
            if (N)
              o.removeValue(N);
            else {
              if (!p) return;
              h ? o.popValue() : w && o.clearValue();
            }
            break;
          case "Tab":
            if (o.isComposing || c.shiftKey || !S || !A || !R || // don't capture the event if the menu opens on focus and the focused
            // option is already selected; it breaks the flow of navigation
            k && o.isOptionSelected(R, j))
              return;
            o.selectOption(R);
            break;
          case "Enter":
            if (c.keyCode === 229)
              break;
            if (S) {
              if (!R || o.isComposing) return;
              o.selectOption(R);
              break;
            }
            return;
          case "Escape":
            S ? (o.setState({
              inputIsHiddenAfterUpdate: !1
            }), o.onInputChange("", {
              action: "menu-close",
              prevInputValue: y
            }), o.onMenuClose()) : w && g && o.clearValue();
            break;
          case " ":
            if (y)
              return;
            if (!S) {
              o.openMenu("first");
              break;
            }
            if (!R) return;
            o.selectOption(R);
            break;
          case "ArrowUp":
            S ? o.focusOption("up") : o.openMenu("last");
            break;
          case "ArrowDown":
            S ? o.focusOption("down") : o.openMenu("first");
            break;
          case "PageUp":
            if (!S) return;
            o.focusOption("pageup");
            break;
          case "PageDown":
            if (!S) return;
            o.focusOption("pagedown");
            break;
          case "Home":
            if (!S) return;
            o.focusOption("first");
            break;
          case "End":
            if (!S) return;
            o.focusOption("last");
            break;
          default:
            return;
        }
        c.preventDefault();
      }
    }, o.state.instancePrefix = "react-select-" + (o.props.instanceId || ++nW), o.state.selectValue = aT(r.value), r.menuIsOpen && o.state.selectValue.length) {
      var a = o.getFocusableOptionsWithIds(), s = o.buildFocusableOptions(), u = s.indexOf(o.state.selectValue[0]);
      o.state.focusableOptionsWithIds = a, o.state.focusedOption = s[u], o.state.focusedOptionId = ev(a, s[u]);
    }
    return o;
  }
  return jq(n, [{
    key: "componentDidMount",
    value: function() {
      this.startListeningComposition(), this.startListeningToTouch(), this.props.closeMenuOnScroll && document && document.addEventListener && document.addEventListener("scroll", this.onScroll, !0), this.props.autoFocus && this.focusInput(), this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef && sT(this.menuListRef, this.focusedOptionRef), BY() && this.setState({
        isAppleDevice: !0
      });
    }
  }, {
    key: "componentDidUpdate",
    value: function(o) {
      var a = this.props, s = a.isDisabled, u = a.menuIsOpen, c = this.state.isFocused;
      // ensure focus is restored correctly when the control becomes enabled
      (c && !s && o.isDisabled || // ensure focus is on the Input when the menu opens
      c && u && !o.menuIsOpen) && this.focusInput(), c && s && !o.isDisabled ? this.setState({
        isFocused: !1
      }, this.onMenuClose) : !c && !s && o.isDisabled && this.inputRef === document.activeElement && this.setState({
        isFocused: !0
      }), this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate && (sT(this.menuListRef, this.focusedOptionRef), this.scrollToFocusedOptionOnUpdate = !1);
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.stopListeningComposition(), this.stopListeningToTouch(), document.removeEventListener("scroll", this.onScroll, !0);
    }
    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function() {
      this.onInputChange("", {
        action: "menu-close",
        prevInputValue: this.props.inputValue
      }), this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function(o, a) {
      this.props.onInputChange(o, a);
    }
    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function() {
      this.inputRef && this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function() {
      this.inputRef && this.inputRef.blur();
    }
    // aliased for consumers
  }, {
    key: "openMenu",
    value: function(o) {
      var a = this, s = this.state, u = s.selectValue, c = s.isFocused, f = this.buildFocusableOptions(), h = o === "first" ? 0 : f.length - 1;
      if (!this.props.isMulti) {
        var p = f.indexOf(u[0]);
        p > -1 && (h = p);
      }
      this.scrollToFocusedOptionOnUpdate = !(c && this.menuListRef), this.setState({
        inputIsHiddenAfterUpdate: !1,
        focusedValue: null,
        focusedOption: f[h],
        focusedOptionId: this.getFocusedOptionId(f[h])
      }, function() {
        return a.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function(o) {
      var a = this.state, s = a.selectValue, u = a.focusedValue;
      if (this.props.isMulti) {
        this.setState({
          focusedOption: null
        });
        var c = s.indexOf(u);
        u || (c = -1);
        var f = s.length - 1, h = -1;
        if (s.length) {
          switch (o) {
            case "previous":
              c === 0 ? h = 0 : c === -1 ? h = f : h = c - 1;
              break;
            case "next":
              c > -1 && c < f && (h = c + 1);
              break;
          }
          this.setState({
            inputIsHidden: h !== -1,
            focusedValue: s[h]
          });
        }
      }
    }
  }, {
    key: "focusOption",
    value: function() {
      var o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first", a = this.props.pageSize, s = this.state.focusedOption, u = this.getFocusableOptions();
      if (u.length) {
        var c = 0, f = u.indexOf(s);
        s || (f = -1), o === "up" ? c = f > 0 ? f - 1 : u.length - 1 : o === "down" ? c = (f + 1) % u.length : o === "pageup" ? (c = f - a, c < 0 && (c = 0)) : o === "pagedown" ? (c = f + a, c > u.length - 1 && (c = u.length - 1)) : o === "last" && (c = u.length - 1), this.scrollToFocusedOptionOnUpdate = !0, this.setState({
          focusedOption: u[c],
          focusedValue: null,
          focusedOptionId: this.getFocusedOptionId(u[c])
        });
      }
    }
  }, {
    key: "getTheme",
    value: (
      // ==============================
      // Getters
      // ==============================
      function() {
        return this.props.theme ? typeof this.props.theme == "function" ? this.props.theme(Jy) : Me(Me({}, Jy), this.props.theme) : Jy;
      }
    )
  }, {
    key: "getCommonProps",
    value: function() {
      var o = this.clearValue, a = this.cx, s = this.getStyles, u = this.getClassNames, c = this.getValue, f = this.selectOption, h = this.setValue, p = this.props, g = p.isMulti, y = p.isRtl, w = p.options, v = this.hasValue();
      return {
        clearValue: o,
        cx: a,
        getStyles: s,
        getClassNames: u,
        getValue: c,
        hasValue: v,
        isMulti: g,
        isRtl: y,
        options: w,
        selectOption: f,
        selectProps: p,
        setValue: h,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function() {
      var o = this.state.selectValue;
      return o.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function() {
      var o = this.props, a = o.isClearable, s = o.isMulti;
      return a === void 0 ? s : a;
    }
  }, {
    key: "isOptionDisabled",
    value: function(o, a) {
      return R2(this.props, o, a);
    }
  }, {
    key: "isOptionSelected",
    value: function(o, a) {
      return M2(this.props, o, a);
    }
  }, {
    key: "filterOption",
    value: function(o, a) {
      return O2(this.props, o, a);
    }
  }, {
    key: "formatOptionLabel",
    value: function(o, a) {
      if (typeof this.props.formatOptionLabel == "function") {
        var s = this.props.inputValue, u = this.state.selectValue;
        return this.props.formatOptionLabel(o, {
          context: a,
          inputValue: s,
          selectValue: u
        });
      } else
        return this.getOptionLabel(o);
    }
  }, {
    key: "formatGroupLabel",
    value: function(o) {
      return this.props.formatGroupLabel(o);
    }
    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value: (
      // ==============================
      // Composition Handlers
      // ==============================
      function() {
        document && document.addEventListener && (document.addEventListener("compositionstart", this.onCompositionStart, !1), document.addEventListener("compositionend", this.onCompositionEnd, !1));
      }
    )
  }, {
    key: "stopListeningComposition",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("compositionstart", this.onCompositionStart), document.removeEventListener("compositionend", this.onCompositionEnd));
    }
  }, {
    key: "startListeningToTouch",
    value: (
      // ==============================
      // Touch Handlers
      // ==============================
      function() {
        document && document.addEventListener && (document.addEventListener("touchstart", this.onTouchStart, !1), document.addEventListener("touchmove", this.onTouchMove, !1), document.addEventListener("touchend", this.onTouchEnd, !1));
      }
    )
  }, {
    key: "stopListeningToTouch",
    value: function() {
      document && document.removeEventListener && (document.removeEventListener("touchstart", this.onTouchStart), document.removeEventListener("touchmove", this.onTouchMove), document.removeEventListener("touchend", this.onTouchEnd));
    }
  }, {
    key: "renderInput",
    value: (
      // ==============================
      // Renderers
      // ==============================
      function() {
        var o = this.props, a = o.isDisabled, s = o.isSearchable, u = o.inputId, c = o.inputValue, f = o.tabIndex, h = o.form, p = o.menuIsOpen, g = o.required, y = this.getComponents(), w = y.Input, v = this.state, S = v.inputIsHidden, E = v.ariaSelection, A = this.commonProps, k = u || this.getElementId("input"), T = Me(Me(Me({
          "aria-autocomplete": "list",
          "aria-expanded": p,
          "aria-haspopup": !0,
          "aria-errormessage": this.props["aria-errormessage"],
          "aria-invalid": this.props["aria-invalid"],
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-required": g,
          role: "combobox",
          "aria-activedescendant": this.state.isAppleDevice ? void 0 : this.state.focusedOptionId || ""
        }, p && {
          "aria-controls": this.getElementId("listbox")
        }), !s && {
          "aria-readonly": !0
        }), this.hasValue() ? E?.action === "initial-input-focus" && {
          "aria-describedby": this.getElementId("live-region")
        } : {
          "aria-describedby": this.getElementId("placeholder")
        });
        return s ? /* @__PURE__ */ _.createElement(w, Re({}, A, {
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id: k,
          innerRef: this.getInputRef,
          isDisabled: a,
          isHidden: S,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex: f,
          form: h,
          type: "text",
          value: c
        }, T)) : /* @__PURE__ */ _.createElement(AY, Re({
          id: k,
          innerRef: this.getInputRef,
          onBlur: this.onInputBlur,
          onChange: dp,
          onFocus: this.onInputFocus,
          disabled: a,
          tabIndex: f,
          inputMode: "none",
          form: h,
          value: ""
        }, T));
      }
    )
  }, {
    key: "renderPlaceholderOrValue",
    value: function() {
      var o = this, a = this.getComponents(), s = a.MultiValue, u = a.MultiValueContainer, c = a.MultiValueLabel, f = a.MultiValueRemove, h = a.SingleValue, p = a.Placeholder, g = this.commonProps, y = this.props, w = y.controlShouldRenderValue, v = y.isDisabled, S = y.isMulti, E = y.inputValue, A = y.placeholder, k = this.state, T = k.selectValue, R = k.focusedValue, N = k.isFocused;
      if (!this.hasValue() || !w)
        return E ? null : /* @__PURE__ */ _.createElement(p, Re({}, g, {
          key: "placeholder",
          isDisabled: v,
          isFocused: N,
          innerProps: {
            id: this.getElementId("placeholder")
          }
        }), A);
      if (S)
        return T.map(function(z, B) {
          var M = z === R, F = "".concat(o.getOptionLabel(z), "-").concat(o.getOptionValue(z));
          return /* @__PURE__ */ _.createElement(s, Re({}, g, {
            components: {
              Container: u,
              Label: c,
              Remove: f
            },
            isFocused: M,
            isDisabled: v,
            key: F,
            index: B,
            removeProps: {
              onClick: function() {
                return o.removeValue(z);
              },
              onTouchEnd: function() {
                return o.removeValue(z);
              },
              onMouseDown: function(Y) {
                Y.preventDefault();
              }
            },
            data: z
          }), o.formatOptionLabel(z, "value"));
        });
      if (E)
        return null;
      var j = T[0];
      return /* @__PURE__ */ _.createElement(h, Re({}, g, {
        data: j,
        isDisabled: v
      }), this.formatOptionLabel(j, "value"));
    }
  }, {
    key: "renderClearIndicator",
    value: function() {
      var o = this.getComponents(), a = o.ClearIndicator, s = this.commonProps, u = this.props, c = u.isDisabled, f = u.isLoading, h = this.state.isFocused;
      if (!this.isClearable() || !a || c || !this.hasValue() || f)
        return null;
      var p = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ _.createElement(a, Re({}, s, {
        innerProps: p,
        isFocused: h
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function() {
      var o = this.getComponents(), a = o.LoadingIndicator, s = this.commonProps, u = this.props, c = u.isDisabled, f = u.isLoading, h = this.state.isFocused;
      if (!a || !f) return null;
      var p = {
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ _.createElement(a, Re({}, s, {
        innerProps: p,
        isDisabled: c,
        isFocused: h
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function() {
      var o = this.getComponents(), a = o.DropdownIndicator, s = o.IndicatorSeparator;
      if (!a || !s) return null;
      var u = this.commonProps, c = this.props.isDisabled, f = this.state.isFocused;
      return /* @__PURE__ */ _.createElement(s, Re({}, u, {
        isDisabled: c,
        isFocused: f
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function() {
      var o = this.getComponents(), a = o.DropdownIndicator;
      if (!a) return null;
      var s = this.commonProps, u = this.props.isDisabled, c = this.state.isFocused, f = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ _.createElement(a, Re({}, s, {
        innerProps: f,
        isDisabled: u,
        isFocused: c
      }));
    }
  }, {
    key: "renderMenu",
    value: function() {
      var o = this, a = this.getComponents(), s = a.Group, u = a.GroupHeading, c = a.Menu, f = a.MenuList, h = a.MenuPortal, p = a.LoadingMessage, g = a.NoOptionsMessage, y = a.Option, w = this.commonProps, v = this.state.focusedOption, S = this.props, E = S.captureMenuScroll, A = S.inputValue, k = S.isLoading, T = S.loadingMessage, R = S.minMenuHeight, N = S.maxMenuHeight, j = S.menuIsOpen, z = S.menuPlacement, B = S.menuPosition, M = S.menuPortalTarget, F = S.menuShouldBlockScroll, q = S.menuShouldScrollIntoView, Y = S.noOptionsMessage, P = S.onMenuScrollToTop, V = S.onMenuScrollToBottom;
      if (!j) return null;
      var I = function(L, te) {
        var he = L.type, oe = L.data, fe = L.isDisabled, ae = L.isSelected, ye = L.label, Ne = L.value, De = v === oe, we = fe ? void 0 : function() {
          return o.onOptionHover(oe);
        }, Ce = fe ? void 0 : function() {
          return o.selectOption(oe);
        }, _e = "".concat(o.getElementId("option"), "-").concat(te), Xe = {
          id: _e,
          onClick: Ce,
          onMouseMove: we,
          onMouseOver: we,
          tabIndex: -1,
          role: "option",
          "aria-selected": o.state.isAppleDevice ? void 0 : ae
          // is not supported on Apple devices
        };
        return /* @__PURE__ */ _.createElement(y, Re({}, w, {
          innerProps: Xe,
          data: oe,
          isDisabled: fe,
          isSelected: ae,
          key: _e,
          label: ye,
          type: he,
          value: Ne,
          isFocused: De,
          innerRef: De ? o.getFocusedOptionRef : void 0
        }), o.formatOptionLabel(L.data, "menu"));
      }, U;
      if (this.hasOptions())
        U = this.getCategorizedOptions().map(function(Z) {
          if (Z.type === "group") {
            var L = Z.data, te = Z.options, he = Z.index, oe = "".concat(o.getElementId("group"), "-").concat(he), fe = "".concat(oe, "-heading");
            return /* @__PURE__ */ _.createElement(s, Re({}, w, {
              key: oe,
              data: L,
              options: te,
              Heading: u,
              headingProps: {
                id: fe,
                data: Z.data
              },
              label: o.formatGroupLabel(Z.data)
            }), Z.options.map(function(ae) {
              return I(ae, "".concat(he, "-").concat(ae.index));
            }));
          } else if (Z.type === "option")
            return I(Z, "".concat(Z.index));
        });
      else if (k) {
        var H = T({
          inputValue: A
        });
        if (H === null) return null;
        U = /* @__PURE__ */ _.createElement(p, w, H);
      } else {
        var G = Y({
          inputValue: A
        });
        if (G === null) return null;
        U = /* @__PURE__ */ _.createElement(g, w, G);
      }
      var O = {
        minMenuHeight: R,
        maxMenuHeight: N,
        menuPlacement: z,
        menuPosition: B,
        menuShouldScrollIntoView: q
      }, W = /* @__PURE__ */ _.createElement(aG, Re({}, w, O), function(Z) {
        var L = Z.ref, te = Z.placerProps, he = te.placement, oe = te.maxHeight;
        return /* @__PURE__ */ _.createElement(c, Re({}, w, O, {
          innerRef: L,
          innerProps: {
            onMouseDown: o.onMenuMouseDown,
            onMouseMove: o.onMenuMouseMove
          },
          isLoading: k,
          placement: he
        }), /* @__PURE__ */ _.createElement(jY, {
          captureEnabled: E,
          onTopArrive: P,
          onBottomArrive: V,
          lockEnabled: F
        }, function(fe) {
          return /* @__PURE__ */ _.createElement(f, Re({}, w, {
            innerRef: function(ye) {
              o.getMenuListRef(ye), fe(ye);
            },
            innerProps: {
              role: "listbox",
              "aria-multiselectable": w.isMulti,
              id: o.getElementId("listbox")
            },
            isLoading: k,
            maxHeight: oe,
            focusedOption: v
          }), U);
        }));
      });
      return M || B === "fixed" ? /* @__PURE__ */ _.createElement(h, Re({}, w, {
        appendTo: M,
        controlElement: this.controlRef,
        menuPlacement: z,
        menuPosition: B
      }), W) : W;
    }
  }, {
    key: "renderFormField",
    value: function() {
      var o = this, a = this.props, s = a.delimiter, u = a.isDisabled, c = a.isMulti, f = a.name, h = a.required, p = this.state.selectValue;
      if (h && !this.hasValue() && !u)
        return /* @__PURE__ */ _.createElement(zY, {
          name: f,
          onFocus: this.onValueInputFocus
        });
      if (!(!f || u))
        if (c)
          if (s) {
            var g = p.map(function(v) {
              return o.getOptionValue(v);
            }).join(s);
            return /* @__PURE__ */ _.createElement("input", {
              name: f,
              type: "hidden",
              value: g
            });
          } else {
            var y = p.length > 0 ? p.map(function(v, S) {
              return /* @__PURE__ */ _.createElement("input", {
                key: "i-".concat(S),
                name: f,
                type: "hidden",
                value: o.getOptionValue(v)
              });
            }) : /* @__PURE__ */ _.createElement("input", {
              name: f,
              type: "hidden",
              value: ""
            });
            return /* @__PURE__ */ _.createElement("div", null, y);
          }
        else {
          var w = p[0] ? this.getOptionValue(p[0]) : "";
          return /* @__PURE__ */ _.createElement("input", {
            name: f,
            type: "hidden",
            value: w
          });
        }
    }
  }, {
    key: "renderLiveRegion",
    value: function() {
      var o = this.commonProps, a = this.state, s = a.ariaSelection, u = a.focusedOption, c = a.focusedValue, f = a.isFocused, h = a.selectValue, p = this.getFocusableOptions();
      return /* @__PURE__ */ _.createElement(_Y, Re({}, o, {
        id: this.getElementId("live-region"),
        ariaSelection: s,
        focusedOption: u,
        focusedValue: c,
        isFocused: f,
        selectValue: h,
        focusableOptions: p,
        isAppleDevice: this.state.isAppleDevice
      }));
    }
  }, {
    key: "render",
    value: function() {
      var o = this.getComponents(), a = o.Control, s = o.IndicatorsContainer, u = o.SelectContainer, c = o.ValueContainer, f = this.props, h = f.className, p = f.id, g = f.isDisabled, y = f.menuIsOpen, w = this.state.isFocused, v = this.commonProps = this.getCommonProps();
      return /* @__PURE__ */ _.createElement(u, Re({}, v, {
        className: h,
        innerProps: {
          id: p,
          onKeyDown: this.onKeyDown
        },
        isDisabled: g,
        isFocused: w
      }), this.renderLiveRegion(), /* @__PURE__ */ _.createElement(a, Re({}, v, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled: g,
        isFocused: w,
        menuIsOpen: y
      }), /* @__PURE__ */ _.createElement(c, Re({}, v, {
        isDisabled: g
      }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ _.createElement(s, Re({}, v, {
        isDisabled: g
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function(o, a) {
      var s = a.prevProps, u = a.clearFocusValueOnUpdate, c = a.inputIsHiddenAfterUpdate, f = a.ariaSelection, h = a.isFocused, p = a.prevWasFocused, g = a.instancePrefix, y = o.options, w = o.value, v = o.menuIsOpen, S = o.inputValue, E = o.isMulti, A = aT(w), k = {};
      if (s && (w !== s.value || y !== s.options || v !== s.menuIsOpen || S !== s.inputValue)) {
        var T = v ? JY(o, A) : [], R = v ? wT(Bh(o, A), "".concat(g, "-option")) : [], N = u ? eW(a, A) : null, j = tW(a, T), z = ev(R, j);
        k = {
          selectValue: A,
          focusedOption: j,
          focusedOptionId: z,
          focusableOptionsWithIds: R,
          focusedValue: N,
          clearFocusValueOnUpdate: !1
        };
      }
      var B = c != null && o !== s ? {
        inputIsHidden: c,
        inputIsHiddenAfterUpdate: void 0
      } : {}, M = f, F = h && p;
      return h && !F && (M = {
        value: uh(E, A, A[0] || null),
        options: A,
        action: "initial-input-focus"
      }, F = !p), f?.action === "initial-input-focus" && (M = null), Me(Me(Me({}, k), B), {}, {
        prevProps: o,
        ariaSelection: M,
        prevWasFocused: F
      });
    }
  }]), n;
}(_.Component);
D2.defaultProps = QY;
var rW = /* @__PURE__ */ _.forwardRef(function(e, t) {
  var n = Nq(e);
  return /* @__PURE__ */ _.createElement(D2, Re({
    ref: t
  }, n));
}), oW = rW;
const iW = ({
  options: e,
  items_per_page: t,
  className: n,
  defaultValue: r,
  onChange: o
}) => {
  const [a, s] = _.useState(""), [u, c] = _.useState(0), f = (y) => {
    s(y.toLowerCase()), c(0);
  }, h = e.filter((y) => y.label.toLowerCase().includes(a) || y.value.toLowerCase().includes(a));
  var p;
  t !== void 0 ? p = h.slice(
    u * t,
    (u + 1) * t
  ) : p = h;
  const g = {
    control: (y) => ({
      ...y,
      minHeight: void 0
    })
  };
  return /* @__PURE__ */ b.jsx(
    oW,
    {
      options: p,
      onInputChange: f,
      onChange: o,
      inputValue: a,
      isSearchable: !0,
      placeholder: "Select an option...",
      className: n,
      unstyled: !0,
      styles: g,
      classNamePrefix: "styled-select",
      defaultValue: r,
      value: r
    }
  );
}, aW = (e) => typeof e == "boolean" || e instanceof Boolean, sW = (e) => typeof e == "number" || e instanceof Number, lW = (e) => typeof e == "bigint" || e instanceof BigInt, j2 = (e) => !!e && e instanceof Date, uW = (e) => typeof e == "string" || e instanceof String, cW = (e) => Array.isArray(e), fW = (e) => typeof e == "object" && e !== null, P2 = (e) => !!e && e instanceof Object && typeof e == "function";
function mp(e, t) {
  return t === void 0 && (t = !1), !e || t ? `"${e}"` : e;
}
function dW(e, t, n) {
  return n ? JSON.stringify(e) : t ? `"${e}"` : e;
}
function I2(e) {
  let {
    field: t,
    value: n,
    data: r,
    lastElement: o,
    openBracket: a,
    closeBracket: s,
    level: u,
    style: c,
    shouldExpandNode: f,
    clickToExpandNode: h,
    outerRef: p,
    beforeExpandChange: g
  } = e;
  const y = _.useRef(!1), [w, v] = _.useState(() => f(u, n, t)), S = _.useRef(null);
  _.useEffect(() => {
    y.current ? v(f(u, n, t)) : y.current = !0;
  }, [f]);
  const E = _.useId();
  if (r.length === 0)
    return hW({
      field: t,
      openBracket: a,
      closeBracket: s,
      lastElement: o,
      style: c
    });
  const A = w ? c.collapseIcon : c.expandIcon, k = w ? c.ariaLables.collapseJson : c.ariaLables.expandJson, T = u + 1, R = r.length - 1, N = (B) => {
    w !== B && (!g || g({
      level: u,
      value: n,
      field: t,
      newExpandValue: B
    })) && v(B);
  }, j = (B) => {
    if (B.key === "ArrowRight" || B.key === "ArrowLeft")
      B.preventDefault(), N(B.key === "ArrowRight");
    else if (B.key === "ArrowUp" || B.key === "ArrowDown") {
      B.preventDefault();
      const M = B.key === "ArrowUp" ? -1 : 1;
      if (!p.current) return;
      const F = p.current.querySelectorAll("[role=button]");
      let q = -1;
      for (let P = 0; P < F.length; P++)
        if (F[P].tabIndex === 0) {
          q = P;
          break;
        }
      if (q < 0)
        return;
      const Y = (q + M + F.length) % F.length;
      F[q].tabIndex = -1, F[Y].tabIndex = 0, F[Y].focus();
    }
  }, z = () => {
    var B;
    N(!w);
    const M = S.current;
    if (!M) return;
    const F = (B = p.current) === null || B === void 0 ? void 0 : B.querySelector('[role=button][tabindex="0"]');
    F && (F.tabIndex = -1), M.tabIndex = 0, M.focus();
  };
  return /* @__PURE__ */ _.createElement("div", {
    className: c.basicChildStyle,
    role: "treeitem",
    "aria-expanded": w,
    "aria-selected": void 0
  }, /* @__PURE__ */ _.createElement("span", {
    className: A,
    onClick: z,
    onKeyDown: j,
    role: "button",
    "aria-label": k,
    "aria-expanded": w,
    "aria-controls": w ? E : void 0,
    ref: S,
    tabIndex: u === 0 ? 0 : -1
  }), (t || t === "") && (h ? /* @__PURE__ */ _.createElement("span", {
    className: c.clickableLabel,
    onClick: z,
    onKeyDown: j
  }, mp(t, c.quotesForFieldNames), ":") : /* @__PURE__ */ _.createElement("span", {
    className: c.label
  }, mp(t, c.quotesForFieldNames), ":")), /* @__PURE__ */ _.createElement("span", {
    className: c.punctuation
  }, a), w ? /* @__PURE__ */ _.createElement("ul", {
    id: E,
    role: "group",
    className: c.childFieldsContainer
  }, r.map((B, M) => /* @__PURE__ */ _.createElement(z2, {
    key: B[0] || M,
    field: B[0],
    value: B[1],
    style: c,
    lastElement: M === R,
    level: T,
    shouldExpandNode: f,
    clickToExpandNode: h,
    outerRef: p
  }))) : /* @__PURE__ */ _.createElement("span", {
    className: c.collapsedContent,
    onClick: z,
    onKeyDown: j
  }), /* @__PURE__ */ _.createElement("span", {
    className: c.punctuation
  }, s), !o && /* @__PURE__ */ _.createElement("span", {
    className: c.punctuation
  }, ","));
}
function hW(e) {
  let {
    field: t,
    openBracket: n,
    closeBracket: r,
    lastElement: o,
    style: a
  } = e;
  return /* @__PURE__ */ _.createElement("div", {
    className: a.basicChildStyle,
    role: "treeitem",
    "aria-selected": void 0
  }, (t || t === "") && /* @__PURE__ */ _.createElement("span", {
    className: a.label
  }, mp(t, a.quotesForFieldNames), ":"), /* @__PURE__ */ _.createElement("span", {
    className: a.punctuation
  }, n), /* @__PURE__ */ _.createElement("span", {
    className: a.punctuation
  }, r), !o && /* @__PURE__ */ _.createElement("span", {
    className: a.punctuation
  }, ","));
}
function pW(e) {
  let {
    field: t,
    value: n,
    style: r,
    lastElement: o,
    shouldExpandNode: a,
    clickToExpandNode: s,
    level: u,
    outerRef: c,
    beforeExpandChange: f
  } = e;
  return I2({
    field: t,
    value: n,
    lastElement: o || !1,
    level: u,
    openBracket: "{",
    closeBracket: "}",
    style: r,
    shouldExpandNode: a,
    clickToExpandNode: s,
    data: Object.keys(n).map((h) => [h, n[h]]),
    outerRef: c,
    beforeExpandChange: f
  });
}
function mW(e) {
  let {
    field: t,
    value: n,
    style: r,
    lastElement: o,
    level: a,
    shouldExpandNode: s,
    clickToExpandNode: u,
    outerRef: c,
    beforeExpandChange: f
  } = e;
  return I2({
    field: t,
    value: n,
    lastElement: o || !1,
    level: a,
    openBracket: "[",
    closeBracket: "]",
    style: r,
    shouldExpandNode: s,
    clickToExpandNode: u,
    data: n.map((h) => [void 0, h]),
    outerRef: c,
    beforeExpandChange: f
  });
}
function gW(e) {
  let {
    field: t,
    value: n,
    style: r,
    lastElement: o
  } = e, a, s = r.otherValue;
  return n === null ? (a = "null", s = r.nullValue) : n === void 0 ? (a = "undefined", s = r.undefinedValue) : uW(n) ? (a = dW(n, !r.noQuotesForStringValues, r.stringifyStringValues), s = r.stringValue) : aW(n) ? (a = n ? "true" : "false", s = r.booleanValue) : sW(n) ? (a = n.toString(), s = r.numberValue) : lW(n) ? (a = `${n.toString()}n`, s = r.numberValue) : j2(n) ? a = n.toISOString() : P2(n) ? a = "function() { }" : a = n.toString(), /* @__PURE__ */ _.createElement("div", {
    className: r.basicChildStyle,
    role: "treeitem",
    "aria-selected": void 0
  }, (t || t === "") && /* @__PURE__ */ _.createElement("span", {
    className: r.label
  }, mp(t, r.quotesForFieldNames), ":"), /* @__PURE__ */ _.createElement("span", {
    className: s
  }, a), !o && /* @__PURE__ */ _.createElement("span", {
    className: r.punctuation
  }, ","));
}
function z2(e) {
  const t = e.value;
  return cW(t) ? /* @__PURE__ */ _.createElement(mW, Object.assign({}, e)) : fW(t) && !j2(t) && !P2(t) ? /* @__PURE__ */ _.createElement(pW, Object.assign({}, e)) : /* @__PURE__ */ _.createElement(gW, Object.assign({}, e));
}
var st = { "container-light": "_2IvMF _GzYRV", "basic-element-style": "_2bkNM", "child-fields-container": "_1BXBN", "label-light": "_1MGIk", "clickable-label-light": "_2YKJg _1MGIk _1MFti", "punctuation-light": "_3uHL6 _3eOF8", "value-null-light": "_2T6PJ", "value-undefined-light": "_1Gho6", "value-string-light": "_vGjyY", "value-number-light": "_1bQdo", "value-boolean-light": "_3zQKs", "value-other-light": "_1xvuR", "collapse-icon-light": "_oLqym _f10Tu _1MFti _1LId0", "expand-icon-light": "_2AXVT _f10Tu _1MFti _1UmXx", "collapsed-content-light": "_2KJWg _1pNG9 _1MFti", "container-dark": "_11RoI _GzYRV", "expand-icon-dark": "_17H2C _f10Tu _1MFti _1UmXx", "collapse-icon-dark": "_3QHg2 _f10Tu _1MFti _1LId0", "collapsed-content-dark": "_3fDAz _1pNG9 _1MFti", "label-dark": "_2bSDX", "clickable-label-dark": "_1RQEj _2bSDX _1MFti", "punctuation-dark": "_gsbQL _3eOF8", "value-null-dark": "_LaAZe", "value-undefined-dark": "_GTKgm", "value-string-dark": "_Chy1W", "value-number-dark": "_2bveF", "value-boolean-dark": "_2vRm-", "value-other-dark": "_1prJR" };
const L2 = {
  collapseJson: "collapse JSON",
  expandJson: "expand JSON"
}, ST = {
  container: st["container-light"],
  basicChildStyle: st["basic-element-style"],
  childFieldsContainer: st["child-fields-container"],
  label: st["label-light"],
  clickableLabel: st["clickable-label-light"],
  nullValue: st["value-null-light"],
  undefinedValue: st["value-undefined-light"],
  stringValue: st["value-string-light"],
  booleanValue: st["value-boolean-light"],
  numberValue: st["value-number-light"],
  otherValue: st["value-other-light"],
  punctuation: st["punctuation-light"],
  collapseIcon: st["collapse-icon-light"],
  expandIcon: st["expand-icon-light"],
  collapsedContent: st["collapsed-content-light"],
  noQuotesForStringValues: !1,
  quotesForFieldNames: !1,
  ariaLables: L2,
  stringifyStringValues: !1
}, yW = {
  container: st["container-dark"],
  basicChildStyle: st["basic-element-style"],
  childFieldsContainer: st["child-fields-container"],
  label: st["label-dark"],
  clickableLabel: st["clickable-label-dark"],
  nullValue: st["value-null-dark"],
  undefinedValue: st["value-undefined-dark"],
  stringValue: st["value-string-dark"],
  booleanValue: st["value-boolean-dark"],
  numberValue: st["value-number-dark"],
  otherValue: st["value-other-dark"],
  punctuation: st["punctuation-dark"],
  collapseIcon: st["collapse-icon-dark"],
  expandIcon: st["expand-icon-dark"],
  collapsedContent: st["collapsed-content-dark"],
  noQuotesForStringValues: !1,
  quotesForFieldNames: !1,
  ariaLables: L2,
  stringifyStringValues: !1
}, vW = () => !0, bW = (e) => e < 1, xW = (e) => {
  let {
    data: t,
    style: n = ST,
    shouldExpandNode: r = vW,
    clickToExpandNode: o = !1,
    beforeExpandChange: a,
    ...s
  } = e;
  const u = _.useRef(null);
  return /* @__PURE__ */ _.createElement("div", Object.assign({
    "aria-label": "JSON view"
  }, s, {
    className: n.container,
    ref: u,
    role: "tree"
  }), /* @__PURE__ */ _.createElement(z2, {
    value: t,
    style: {
      ...ST,
      ...n
    },
    lastElement: !0,
    level: 0,
    shouldExpandNode: r,
    clickToExpandNode: o,
    outerRef: u,
    beforeExpandChange: a
  }));
};
function wW(e) {
  for (const t in e)
    if (Object.hasOwn(e, t))
      return !1;
  return !0;
}
function _W(e) {
  if (e == null || typeof e != "object")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t !== null && t !== Object.prototype ? !1 : wW(e);
}
const SW = ({
  data: e,
  className: t = "json-display"
}) => /* @__PURE__ */ b.jsx("div", { className: t, children: /* @__PURE__ */ b.jsx(
  xW,
  {
    data: _W(e) ? "" : e,
    style: yW,
    shouldExpandNode: bW
  }
) });
function EW(e, t, n = {}) {
  const {
    maxFontSize: r = 100,
    // default maximum font size
    minFontSize: o = 6,
    // default minimum font size
    decrementFactor: a = 0.9
    // font size decrement step
  } = n;
  if (!e || !t)
    return;
  if (a >= 1 || a <= 0)
    throw new Error("decrementFactor must be between 0 and 1");
  const s = e.getBoundingClientRect(), u = s.width, c = s.height;
  let f = r;
  t.style.whiteSpace = "nowrap", t.style.display = "inline-block", t.style.fontSize = f + "px";
  let h = t.getBoundingClientRect();
  for (; (h.width > u || h.height > c) && f > o; )
    f *= a, t.style.fontSize = f + "px", h = t.getBoundingClientRect();
}
function CW(e = {
  n: 0,
  elapsed: 0,
  ascii: !1,
  unit: "it",
  unit_scale: !1,
  unit_divisor: 1e3
}) {
  let t = e.total ?? null;
  const {
    n = 0,
    unit_scale: r = !1,
    elapsed: o = 0,
    // ascii,
    unit: a = "it",
    unit_divisor: s = 1e3,
    // ncols = undefined,
    prefix: u = "",
    rate: c = void 0,
    // bar_format = undefined,
    postfix: f = null,
    initial: h = 0
    // colour = undefined,
  } = e;
  t !== null && n >= t + 0.5 && (t = null);
  let p = n, g = t, y = c;
  r && r !== !0 && r !== 1 && (t !== null && (g = t * r), p = n * r, c !== void 0 && (y = c * r));
  const w = ET(o);
  y === void 0 && o > 0 && (y = (p - h) / o);
  const v = y ? 1 / y : void 0, [S, E] = y ? ch(y, s) : [void 0, ""], [A, k] = v ? ch(v, 1e3) : [void 0, ""], T = (S || "?") + `${E}${a}/s`, R = A ? `${A}${k}s/` + a : "?", N = v && v > 1 ? R : T, j = r ? ch(p, s).join("") : p.toString(), z = r && g !== null ? ch(g, s).join("") : g?.toString() ?? "?", B = y && g !== null ? (g - p) / y : 0, M = y ? ET(B) : "?", F = u ? `${u}: ` : "";
  if (t !== null) {
    const q = p / t * 100, Y = ` ${j}/${z} [${w} < ${M}, ${N}${f ?? ""}]`;
    return `${F}${q.toFixed(0)}%${Y}`;
  }
  return `${F}${j}${a} [${w}, ${N}${f ?? ""}]`;
}
function ET(e) {
  const t = Math.floor(e / 60), n = Math.floor(e % 60);
  return `${t}:${n.toString().padStart(2, "0")}`;
}
function ch(e, t) {
  const n = ["", "K", "M", "G", "T"];
  let r = 0;
  for (; e >= t && r < n.length - 1; )
    e /= t, r++;
  return [e.toFixed(2), n[r]];
}
const kW = ({ state: e, className: t = "reacttqdm", ...n }) => {
  const r = _.useRef(null), o = _.useRef(null);
  _.useEffect(() => {
    const s = () => {
      !r.current || !o.current || EW(r.current, o.current, {
        maxFontSize: 12,
        decrementFactor: 0.9
      });
    };
    return s(), window.addEventListener("resize", s), () => {
      window.removeEventListener("resize", s);
    };
  }, [e]);
  const a = e.total ? (e.n ?? 0) / e.total * 100 : 0;
  return /* @__PURE__ */ b.jsx("div", { ref: r, className: t, ...n, children: /* @__PURE__ */ b.jsxs(
    "div",
    {
      style: {
        position: "relative",
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center"
      },
      children: [
        /* @__PURE__ */ b.jsx(
          "div",
          {
            className: t + "-bar",
            style: {
              position: "absolute",
              width: "100%",
              height: "100%",
              // Adjust height if needed
              overflow: "hidden"
            },
            children: /* @__PURE__ */ b.jsx(
              "div",
              {
                className: t + "-progress",
                style: {
                  width: `${a}%`,
                  height: "100%"
                }
              }
            )
          }
        ),
        /* @__PURE__ */ b.jsx("div", { className: t + "-text", ref: o, children: CW(e) })
      ]
    }
  ) });
};
var fh = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var CT;
function TW() {
  if (CT) return fh;
  CT = 1;
  var e = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, t = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, n = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, r = /\\([\u000b\u0020-\u00ff])/g, o = /([\\"])/g, a = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
  fh.format = s, fh.parse = u;
  function s(p) {
    if (!p || typeof p != "object")
      throw new TypeError("argument obj is required");
    var g = p.parameters, y = p.type;
    if (!y || !a.test(y))
      throw new TypeError("invalid type");
    var w = y;
    if (g && typeof g == "object")
      for (var v, S = Object.keys(g).sort(), E = 0; E < S.length; E++) {
        if (v = S[E], !n.test(v))
          throw new TypeError("invalid parameter name");
        w += "; " + v + "=" + f(g[v]);
      }
    return w;
  }
  function u(p) {
    if (!p)
      throw new TypeError("argument string is required");
    var g = typeof p == "object" ? c(p) : p;
    if (typeof g != "string")
      throw new TypeError("argument string is required to be a string");
    var y = g.indexOf(";"), w = y !== -1 ? g.slice(0, y).trim() : g.trim();
    if (!a.test(w))
      throw new TypeError("invalid media type");
    var v = new h(w.toLowerCase());
    if (y !== -1) {
      var S, E, A;
      for (e.lastIndex = y; E = e.exec(g); ) {
        if (E.index !== y)
          throw new TypeError("invalid parameter format");
        y += E[0].length, S = E[1].toLowerCase(), A = E[2], A.charCodeAt(0) === 34 && (A = A.slice(1, -1), A.indexOf("\\") !== -1 && (A = A.replace(r, "$1"))), v.parameters[S] = A;
      }
      if (y !== g.length)
        throw new TypeError("invalid parameter format");
    }
    return v;
  }
  function c(p) {
    var g;
    if (typeof p.getHeader == "function" ? g = p.getHeader("content-type") : typeof p.headers == "object" && (g = p.headers && p.headers["content-type"]), typeof g != "string")
      throw new TypeError("content-type header is missing from object");
    return g;
  }
  function f(p) {
    var g = String(p);
    if (n.test(g))
      return g;
    if (g.length > 0 && !t.test(g))
      throw new TypeError("invalid parameter value");
    return '"' + g.replace(o, "\\$1") + '"';
  }
  function h(p) {
    this.parameters = /* @__PURE__ */ Object.create(null), this.type = p;
  }
  return fh;
}
var AW = TW(), tl = /* @__PURE__ */ new Map(), F2 = function(t) {
  return t.cloneNode(!0);
}, kT = function() {
  return window.location.protocol === "file:";
}, $2 = function(t, n, r) {
  var o = new XMLHttpRequest();
  o.onreadystatechange = function() {
    try {
      if (!/\.svg/i.test(t) && o.readyState === 2) {
        var a = o.getResponseHeader("Content-Type");
        if (!a)
          throw new Error("Content type not found");
        var s = AW.parse(a).type;
        if (!(s === "image/svg+xml" || s === "text/plain"))
          throw new Error("Invalid content type: ".concat(s));
      }
      if (o.readyState === 4) {
        if (o.status === 404 || o.responseXML === null)
          throw new Error(kT() ? "Note: SVG injection ajax calls do not work locally without adjusting security settings in your browser. Or consider using a local webserver." : "Unable to load SVG file: " + t);
        if (o.status === 200 || kT() && o.status === 0)
          r(null, o);
        else
          throw new Error("There was a problem injecting the SVG: " + o.status + " " + o.statusText);
      }
    } catch (u) {
      if (o.abort(), u instanceof Error)
        r(u, o);
      else
        throw u;
    }
  }, o.open("GET", t), o.withCredentials = n, o.overrideMimeType && o.overrideMimeType("text/xml"), o.send();
}, Wi = {}, TT = function(t, n) {
  Wi[t] = Wi[t] || [], Wi[t].push(n);
}, RW = function(t) {
  for (var n = function(s, u) {
    setTimeout(function() {
      if (Array.isArray(Wi[t])) {
        var c = tl.get(t), f = Wi[t][s];
        c instanceof SVGSVGElement && f(null, F2(c)), c instanceof Error && f(c), s === Wi[t].length - 1 && delete Wi[t];
      }
    }, 0);
  }, r = 0, o = Wi[t].length; r < o; r++)
    n(r);
}, MW = function(t, n, r) {
  if (tl.has(t)) {
    var o = tl.get(t);
    if (o === void 0) {
      TT(t, r);
      return;
    }
    if (o instanceof SVGSVGElement) {
      r(null, F2(o));
      return;
    }
  }
  tl.set(t, void 0), TT(t, r), $2(t, n, function(a, s) {
    var u;
    a ? tl.set(t, a) : ((u = s.responseXML) === null || u === void 0 ? void 0 : u.documentElement) instanceof SVGSVGElement && tl.set(t, s.responseXML.documentElement), RW(t);
  });
}, OW = function(t, n, r) {
  $2(t, n, function(o, a) {
    var s;
    o ? r(o) : ((s = a.responseXML) === null || s === void 0 ? void 0 : s.documentElement) instanceof SVGSVGElement && r(null, a.responseXML.documentElement);
  });
}, NW = 0, DW = function() {
  return ++NW;
}, Jr = [], AT = {}, jW = "http://www.w3.org/2000/svg", tv = "http://www.w3.org/1999/xlink", RT = function(t, n, r, o, a, s, u) {
  var c = t.getAttribute("data-src") || t.getAttribute("src");
  if (!c) {
    u(new Error("Invalid data-src or src attribute"));
    return;
  }
  if (Jr.indexOf(t) !== -1) {
    Jr.splice(Jr.indexOf(t), 1), t = null;
    return;
  }
  Jr.push(t), t.setAttribute("src", "");
  var f = o ? MW : OW;
  f(c, a, function(h, p) {
    if (!p) {
      Jr.splice(Jr.indexOf(t), 1), t = null, u(h);
      return;
    }
    var g = t.getAttribute("id");
    g && p.setAttribute("id", g);
    var y = t.getAttribute("title");
    y && p.setAttribute("title", y);
    var w = t.getAttribute("width");
    w && p.setAttribute("width", w);
    var v = t.getAttribute("height");
    v && p.setAttribute("height", v);
    var S = Array.from(new Set(jh(jh(jh([], (p.getAttribute("class") || "").split(" "), !0), ["injected-svg"], !1), (t.getAttribute("class") || "").split(" "), !0))).join(" ").trim();
    p.setAttribute("class", S);
    var E = t.getAttribute("style");
    E && p.setAttribute("style", E), p.setAttribute("data-src", c);
    var A = [].filter.call(t.attributes, function(H) {
      return /^data-\w[\w-]*$/.test(H.name);
    });
    if (Array.prototype.forEach.call(A, function(H) {
      H.name && H.value && p.setAttribute(H.name, H.value);
    }), r) {
      var k = {
        clipPath: ["clip-path"],
        "color-profile": ["color-profile"],
        cursor: ["cursor"],
        filter: ["filter"],
        linearGradient: ["fill", "stroke"],
        marker: ["marker", "marker-start", "marker-mid", "marker-end"],
        mask: ["mask"],
        path: [],
        pattern: ["fill", "stroke"],
        radialGradient: ["fill", "stroke"]
      }, T, R, N, j, z;
      Object.keys(k).forEach(function(H) {
        T = H, N = k[H], R = p.querySelectorAll(T + "[id]");
        for (var G = function(L, te) {
          j = R[L].id, z = j + "-" + DW();
          var he;
          Array.prototype.forEach.call(N, function(Ce) {
            he = p.querySelectorAll("[" + Ce + '*="' + j + '"]');
            for (var _e = 0, Xe = he.length; _e < Xe; _e++) {
              var St = he[_e].getAttribute(Ce);
              St && !St.match(new RegExp('url\\("?#' + j + '"?\\)')) || he[_e].setAttribute(Ce, "url(#" + z + ")");
            }
          });
          for (var oe = p.querySelectorAll("[*|href]"), fe = [], ae = 0, ye = oe.length; ae < ye; ae++) {
            var Ne = oe[ae].getAttributeNS(tv, "href");
            Ne && Ne.toString() === "#" + R[L].id && fe.push(oe[ae]);
          }
          for (var De = 0, we = fe.length; De < we; De++)
            fe[De].setAttributeNS(tv, "href", "#" + z);
          R[L].id = z;
        }, O = 0, W = R.length; O < W; O++)
          G(O);
      });
    }
    p.removeAttribute("xmlns:a");
    for (var B = p.querySelectorAll("script"), M = [], F, q, Y = 0, P = B.length; Y < P; Y++)
      q = B[Y].getAttribute("type"), (!q || q === "application/ecmascript" || q === "application/javascript" || q === "text/javascript") && (F = B[Y].innerText || B[Y].textContent, F && M.push(F), p.removeChild(B[Y]));
    if (M.length > 0 && (n === "always" || n === "once" && !AT[c])) {
      for (var V = 0, I = M.length; V < I; V++)
        new Function(M[V])(window);
      AT[c] = !0;
    }
    var U = p.querySelectorAll("style");
    if (Array.prototype.forEach.call(U, function(H) {
      H.textContent += "";
    }), p.setAttribute("xmlns", jW), p.setAttribute("xmlns:xlink", tv), s(p), !t.parentNode) {
      Jr.splice(Jr.indexOf(t), 1), t = null, u(new Error("Parent node is null"));
      return;
    }
    t.parentNode.replaceChild(p, t), Jr.splice(Jr.indexOf(t), 1), t = null, u(null, p);
  });
}, PW = function(t, n) {
  var r = n === void 0 ? {} : n, o = r.afterAll, a = o === void 0 ? function() {
  } : o, s = r.afterEach, u = s === void 0 ? function() {
  } : s, c = r.beforeEach, f = c === void 0 ? function() {
  } : c, h = r.cacheRequests, p = h === void 0 ? !0 : h, g = r.evalScripts, y = g === void 0 ? "never" : g, w = r.httpRequestWithCredentials, v = w === void 0 ? !1 : w, S = r.renumerateIRIElements, E = S === void 0 ? !0 : S;
  if (t && "length" in t)
    for (var A = 0, k = 0, T = t.length; k < T; k++)
      RT(t[k], y, E, p, v, f, function(R, N) {
        u(R, N), t && "length" in t && t.length === ++A && a(A);
      });
  else t ? RT(t, y, E, p, v, f, function(R, N) {
    u(R, N), a(1), t = null;
  }) : a(0);
}, IW = function(t) {
  var n = t?.ownerDocument || document;
  return n.defaultView || window;
}, zW = function(t, n) {
  for (var r in t)
    if (!(r in n))
      return !0;
  for (var o in n)
    if (t[o] !== n[o])
      return !0;
  return !1;
}, LW = ["afterInjection", "beforeInjection", "desc", "evalScripts", "fallback", "httpRequestWithCredentials", "loading", "renumerateIRIElements", "src", "title", "useRequestCache", "wrapper"], dh = "http://www.w3.org/2000/svg", MT = "http://www.w3.org/1999/xlink", cx = /* @__PURE__ */ function(e) {
  function t() {
    for (var r, o = arguments.length, a = new Array(o), s = 0; s < o; s++)
      a[s] = arguments[s];
    return r = e.call.apply(e, [this].concat(a)) || this, r.initialState = {
      hasError: !1,
      isLoading: !0
    }, r.state = r.initialState, r._isMounted = !1, r.reactWrapper = void 0, r.nonReactWrapper = void 0, r.refCallback = function(u) {
      r.reactWrapper = u;
    }, r;
  }
  jM(t, e);
  var n = t.prototype;
  return n.renderSVG = function() {
    var o = this;
    if (this.reactWrapper instanceof IW(this.reactWrapper).Node) {
      var a = this.props, s = a.desc, u = a.evalScripts, c = a.httpRequestWithCredentials, f = a.renumerateIRIElements, h = a.src, p = a.title, g = a.useRequestCache, y = this.props.onError, w = this.props.beforeInjection, v = this.props.afterInjection, S = this.props.wrapper, E, A;
      S === "svg" ? (E = document.createElementNS(dh, S), E.setAttribute("xmlns", dh), E.setAttribute("xmlns:xlink", MT), A = document.createElementNS(dh, S)) : (E = document.createElement(S), A = document.createElement(S)), E.appendChild(A), A.dataset.src = h, this.nonReactWrapper = this.reactWrapper.appendChild(E);
      var k = function(j) {
        if (o.removeSVG(), !o._isMounted) {
          y(j);
          return;
        }
        o.setState(function() {
          return {
            hasError: !0,
            isLoading: !1
          };
        }, function() {
          y(j);
        });
      }, T = function(j, z) {
        if (j) {
          k(j);
          return;
        }
        o._isMounted && o.setState(function() {
          return {
            isLoading: !1
          };
        }, function() {
          try {
            v(z);
          } catch (B) {
            k(B);
          }
        });
      }, R = function(j) {
        if (j.setAttribute("role", "img"), s) {
          var z = j.querySelector(":scope > desc");
          z && j.removeChild(z);
          var B = document.createElement("desc");
          B.innerHTML = s, j.prepend(B);
        }
        if (p) {
          var M = j.querySelector(":scope > title");
          M && j.removeChild(M);
          var F = document.createElement("title");
          F.innerHTML = p, j.prepend(F);
        }
        try {
          w(j);
        } catch (q) {
          k(q);
        }
      };
      PW(A, {
        afterEach: T,
        beforeEach: R,
        cacheRequests: g,
        evalScripts: u,
        httpRequestWithCredentials: c,
        renumerateIRIElements: f
      });
    }
  }, n.removeSVG = function() {
    var o;
    (o = this.nonReactWrapper) != null && o.parentNode && (this.nonReactWrapper.parentNode.removeChild(this.nonReactWrapper), this.nonReactWrapper = null);
  }, n.componentDidMount = function() {
    this._isMounted = !0, this.renderSVG();
  }, n.componentDidUpdate = function(o) {
    var a = this;
    zW(Re({}, o), this.props) && this.setState(function() {
      return a.initialState;
    }, function() {
      a.removeSVG(), a.renderSVG();
    });
  }, n.componentWillUnmount = function() {
    this._isMounted = !1, this.removeSVG();
  }, n.render = function() {
    var o = this.props;
    o.afterInjection, o.beforeInjection, o.desc, o.evalScripts;
    var a = o.fallback;
    o.httpRequestWithCredentials;
    var s = o.loading;
    o.renumerateIRIElements, o.src, o.title, o.useRequestCache;
    var u = o.wrapper, c = C1(o, LW), f = u;
    return /* @__PURE__ */ _.createElement(f, Re({}, c, {
      ref: this.refCallback
    }, u === "svg" ? {
      xmlns: dh,
      xmlnsXlink: MT
    } : {}), this.state.isLoading && s && /* @__PURE__ */ _.createElement(s, null), this.state.hasError && a && /* @__PURE__ */ _.createElement(a, null));
  }, t;
}(_.Component);
cx.defaultProps = {
  afterInjection: function() {
  },
  beforeInjection: function() {
  },
  desc: "",
  evalScripts: "never",
  fallback: null,
  httpRequestWithCredentials: !1,
  loading: null,
  onError: function() {
  },
  renumerateIRIElements: !0,
  title: "",
  useRequestCache: !0,
  wrapper: "div"
};
cx.propTypes = {
  afterInjection: Ut.func,
  beforeInjection: Ut.func,
  desc: Ut.string,
  evalScripts: Ut.oneOf(["always", "once", "never"]),
  fallback: Ut.oneOfType([Ut.func, Ut.object, Ut.string]),
  httpRequestWithCredentials: Ut.bool,
  loading: Ut.oneOfType([Ut.func, Ut.object, Ut.string]),
  onError: Ut.func,
  renumerateIRIElements: Ut.bool,
  src: Ut.string.isRequired,
  title: Ut.string,
  useRequestCache: Ut.bool,
  wrapper: Ut.oneOf(["div", "span", "svg"])
};
const fx = ({
  text: e = "No image data provided"
}) => /* @__PURE__ */ b.jsx(
  "div",
  {
    style: {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      minHeight: "100px",
      border: "1px dashed #ccc",
      color: "#666"
    },
    children: e
  }
), FW = _.memo(
  ({
    value: e,
    format: t = "jpeg",
    alt: n = "Base64 image",
    onError: r,
    onLoad: o,
    ...a
  }) => {
    const [s, u] = _.useState(!1), [c, f] = _.useState(!0), h = _.useRef(null), p = _.useMemo(() => {
      if (typeof e == "string")
        return e;
      if (e && typeof e == "object" && "data" in e) {
        const v = e.data;
        if (v instanceof ArrayBuffer) {
          const S = new Uint8Array(v);
          let E = "";
          for (let A = 0; A < S.byteLength; A++)
            E += String.fromCharCode(S[A]);
          return btoa(E);
        }
      }
      return "";
    }, [e]), g = _.useMemo(() => p ? `data:image/${t};base64,${p}` : "", [p, t]), y = _.useCallback(
      (v) => {
        u(!0), f(!1), r?.(v);
      },
      [r]
    ), w = _.useCallback(() => {
      f(!1), u(!1), o?.();
    }, [o]);
    return _.useEffect(() => {
      const v = h.current;
      if (v)
        return v.addEventListener("error", y), v.addEventListener("load", w), () => {
          v.removeEventListener("error", y), v.removeEventListener("load", w);
        };
    }, [y, w, e]), _.useEffect(() => {
      u(!1), f(!0);
    }, [e]), p ? s ? /* @__PURE__ */ b.jsx(
      "div",
      {
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          minHeight: "100px",
          border: "1px dashed #ccc",
          color: "#666"
        },
        children: "Failed to load base64 image"
      }
    ) : /* @__PURE__ */ b.jsx(
      "img",
      {
        ref: h,
        src: g,
        alt: n,
        className: `base64-image-renderer image-renderer ${a.className || ""} ${c ? " loading" : ""}`,
        ...a
      }
    ) : /* @__PURE__ */ b.jsx(fx, {});
  }
), $W = _.memo(
  ({
    value: e,
    alt: t = "SVG image",
    onError: n,
    onLoad: r,
    ...o
  }) => {
    const [a, s] = _.useState(!1), u = _.useMemo(() => {
      if (!e) return "";
      try {
        return `data:image/svg+xml;base64,${btoa(e)}`;
      } catch (f) {
        return console.error("Failed to encode SVG to base64:", f), "";
      }
    }, [e]);
    _.useEffect(() => {
      s(!1);
    }, [e]);
    const c = _.useCallback(
      (f) => {
        s(!0), n?.(f);
      },
      [n]
    );
    return e ? a || !u ? /* @__PURE__ */ b.jsx(
      "div",
      {
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          minHeight: "100px",
          border: "1px dashed #ccc",
          color: "#666"
        },
        children: "Failed to load SVG"
      }
    ) : /* @__PURE__ */ b.jsx(
      cx,
      {
        src: u,
        className: `svg-renderer ${o.className || ""}`,
        style: {
          maxWidth: "100%",
          maxHeight: "100%",
          ...o.style
        },
        beforeInjection: (f) => {
          f.classList.add("svg-renderer"), f.setAttribute("style", "max-width: 100%; max-height: 100%;"), f.setAttribute("width", "100%"), f.setAttribute("height", "100%"), f.setAttribute("aria-label", t);
          const h = () => {
            s(!1), r?.();
          }, p = (g) => {
            s(!0), n?.(g);
          };
          try {
            f.addEventListener("load", h), f.addEventListener("error", p);
          } catch {
            h();
          }
        },
        onError: c
      }
    ) : /* @__PURE__ */ b.jsx(fx, {});
  }
), BW = _.memo(
  ({
    src: e,
    alt: t = "Streaming image",
    onError: n,
    onLoad: r,
    ...o
  }) => {
    const a = _.useRef(null), [s, u] = _.useState(!1), [c, f] = _.useState(!0);
    _.useEffect(() => {
      a.current && e && (f(!0), u(!1), a.current.src = e);
    }, [e]);
    const h = _.useCallback(
      (g) => {
        u(!0), f(!1), n?.(g);
      },
      [n]
    ), p = _.useCallback(() => {
      f(!1), u(!1), r?.();
    }, [r]);
    return _.useEffect(() => {
      const g = a.current;
      if (g)
        return g.addEventListener("error", h), g.addEventListener("load", p), () => {
          g.removeEventListener("error", h), g.removeEventListener("load", p);
        };
    }, [h, p]), s ? /* @__PURE__ */ b.jsx(fx, { text: "Failed to load image" }) : /* @__PURE__ */ b.jsx(
      "img",
      {
        ref: a,
        className: `streaming-image image-renderer ${o.className || ""} ${c ? " loading" : ""}`,
        alt: t,
        ...o
      }
    );
  }
);
function _m(e) {
  const t = e + "CollectionProvider", [n, r] = _o(t), [o, a] = n(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), s = (v) => {
    const { scope: S, children: E } = v, A = nn.useRef(null), k = nn.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ b.jsx(o, { scope: S, itemMap: k, collectionRef: A, children: E });
  };
  s.displayName = t;
  const u = e + "CollectionSlot", c = /* @__PURE__ */ xl(u), f = nn.forwardRef(
    (v, S) => {
      const { scope: E, children: A } = v, k = a(u, E), T = bt(S, k.collectionRef);
      return /* @__PURE__ */ b.jsx(c, { ref: T, children: A });
    }
  );
  f.displayName = u;
  const h = e + "CollectionItemSlot", p = "data-radix-collection-item", g = /* @__PURE__ */ xl(h), y = nn.forwardRef(
    (v, S) => {
      const { scope: E, children: A, ...k } = v, T = nn.useRef(null), R = bt(S, T), N = a(h, E);
      return nn.useEffect(() => (N.itemMap.set(T, { ref: T, ...k }), () => void N.itemMap.delete(T))), /* @__PURE__ */ b.jsx(g, { [p]: "", ref: R, children: A });
    }
  );
  y.displayName = h;
  function w(v) {
    const S = a(e + "CollectionConsumer", v);
    return nn.useCallback(() => {
      const A = S.collectionRef.current;
      if (!A) return [];
      const k = Array.from(A.querySelectorAll(`[${p}]`));
      return Array.from(S.itemMap.values()).sort(
        (N, j) => k.indexOf(N.ref.current) - k.indexOf(j.ref.current)
      );
    }, [S.collectionRef, S.itemMap]);
  }
  return [
    { Provider: s, Slot: f, ItemSlot: y },
    w,
    r
  ];
}
var HW = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
}), VW = "VisuallyHidden", dx = _.forwardRef(
  (e, t) => /* @__PURE__ */ b.jsx(
    qe.span,
    {
      ...e,
      ref: t,
      style: { ...HW, ...e.style }
    }
  )
);
dx.displayName = VW;
var hx = "ToastProvider", [px, UW, qW] = _m("Toast"), [B2, Kpe] = _o("Toast", [qW]), [GW, Sm] = B2(hx), H2 = (e) => {
  const {
    __scopeToast: t,
    label: n = "Notification",
    duration: r = 5e3,
    swipeDirection: o = "right",
    swipeThreshold: a = 50,
    children: s
  } = e, [u, c] = _.useState(null), [f, h] = _.useState(0), p = _.useRef(!1), g = _.useRef(!1);
  return n.trim() || console.error(
    `Invalid prop \`label\` supplied to \`${hx}\`. Expected non-empty \`string\`.`
  ), /* @__PURE__ */ b.jsx(px.Provider, { scope: t, children: /* @__PURE__ */ b.jsx(
    GW,
    {
      scope: t,
      label: n,
      duration: r,
      swipeDirection: o,
      swipeThreshold: a,
      toastCount: f,
      viewport: u,
      onViewportChange: c,
      onToastAdd: _.useCallback(() => h((y) => y + 1), []),
      onToastRemove: _.useCallback(() => h((y) => y - 1), []),
      isFocusedToastEscapeKeyDownRef: p,
      isClosePausedRef: g,
      children: s
    }
  ) });
};
H2.displayName = hx;
var V2 = "ToastViewport", YW = ["F8"], wb = "toast.viewportPause", _b = "toast.viewportResume", U2 = _.forwardRef(
  (e, t) => {
    const {
      __scopeToast: n,
      hotkey: r = YW,
      label: o = "Notifications ({hotkey})",
      ...a
    } = e, s = Sm(V2, n), u = UW(n), c = _.useRef(null), f = _.useRef(null), h = _.useRef(null), p = _.useRef(null), g = bt(t, p, s.onViewportChange), y = r.join("+").replace(/Key/g, "").replace(/Digit/g, ""), w = s.toastCount > 0;
    _.useEffect(() => {
      const S = (E) => {
        r.length !== 0 && r.every((k) => E[k] || E.code === k) && p.current?.focus();
      };
      return document.addEventListener("keydown", S), () => document.removeEventListener("keydown", S);
    }, [r]), _.useEffect(() => {
      const S = c.current, E = p.current;
      if (w && S && E) {
        const A = () => {
          if (!s.isClosePausedRef.current) {
            const N = new CustomEvent(wb);
            E.dispatchEvent(N), s.isClosePausedRef.current = !0;
          }
        }, k = () => {
          if (s.isClosePausedRef.current) {
            const N = new CustomEvent(_b);
            E.dispatchEvent(N), s.isClosePausedRef.current = !1;
          }
        }, T = (N) => {
          !S.contains(N.relatedTarget) && k();
        }, R = () => {
          S.contains(document.activeElement) || k();
        };
        return S.addEventListener("focusin", A), S.addEventListener("focusout", T), S.addEventListener("pointermove", A), S.addEventListener("pointerleave", R), window.addEventListener("blur", A), window.addEventListener("focus", k), () => {
          S.removeEventListener("focusin", A), S.removeEventListener("focusout", T), S.removeEventListener("pointermove", A), S.removeEventListener("pointerleave", R), window.removeEventListener("blur", A), window.removeEventListener("focus", k);
        };
      }
    }, [w, s.isClosePausedRef]);
    const v = _.useCallback(
      ({ tabbingDirection: S }) => {
        const A = u().map((k) => {
          const T = k.ref.current, R = [T, ...aX(T)];
          return S === "forwards" ? R : R.reverse();
        });
        return (S === "forwards" ? A.reverse() : A).flat();
      },
      [u]
    );
    return _.useEffect(() => {
      const S = p.current;
      if (S) {
        const E = (A) => {
          const k = A.altKey || A.ctrlKey || A.metaKey;
          if (A.key === "Tab" && !k) {
            const R = document.activeElement, N = A.shiftKey;
            if (A.target === S && N) {
              f.current?.focus();
              return;
            }
            const B = v({ tabbingDirection: N ? "backwards" : "forwards" }), M = B.findIndex((F) => F === R);
            nv(B.slice(M + 1)) ? A.preventDefault() : N ? f.current?.focus() : h.current?.focus();
          }
        };
        return S.addEventListener("keydown", E), () => S.removeEventListener("keydown", E);
      }
    }, [u, v]), /* @__PURE__ */ b.jsxs(
      k8,
      {
        ref: c,
        role: "region",
        "aria-label": o.replace("{hotkey}", y),
        tabIndex: -1,
        style: { pointerEvents: w ? void 0 : "none" },
        children: [
          w && /* @__PURE__ */ b.jsx(
            Sb,
            {
              ref: f,
              onFocusFromOutsideViewport: () => {
                const S = v({
                  tabbingDirection: "forwards"
                });
                nv(S);
              }
            }
          ),
          /* @__PURE__ */ b.jsx(px.Slot, { scope: n, children: /* @__PURE__ */ b.jsx(qe.ol, { tabIndex: -1, ...a, ref: g }) }),
          w && /* @__PURE__ */ b.jsx(
            Sb,
            {
              ref: h,
              onFocusFromOutsideViewport: () => {
                const S = v({
                  tabbingDirection: "backwards"
                });
                nv(S);
              }
            }
          )
        ]
      }
    );
  }
);
U2.displayName = V2;
var q2 = "ToastFocusProxy", Sb = _.forwardRef(
  (e, t) => {
    const { __scopeToast: n, onFocusFromOutsideViewport: r, ...o } = e, a = Sm(q2, n);
    return /* @__PURE__ */ b.jsx(
      dx,
      {
        "aria-hidden": !0,
        tabIndex: 0,
        ...o,
        ref: t,
        style: { position: "fixed" },
        onFocus: (s) => {
          const u = s.relatedTarget;
          !a.viewport?.contains(u) && r();
        }
      }
    );
  }
);
Sb.displayName = q2;
var df = "Toast", WW = "toast.swipeStart", XW = "toast.swipeMove", KW = "toast.swipeCancel", ZW = "toast.swipeEnd", G2 = _.forwardRef(
  (e, t) => {
    const { forceMount: n, open: r, defaultOpen: o, onOpenChange: a, ...s } = e, [u, c] = sa({
      prop: r,
      defaultProp: o ?? !0,
      onChange: a,
      caller: df
    });
    return /* @__PURE__ */ b.jsx(Br, { present: n || u, children: /* @__PURE__ */ b.jsx(
      eX,
      {
        open: u,
        ...s,
        ref: t,
        onClose: () => c(!1),
        onPause: Hn(e.onPause),
        onResume: Hn(e.onResume),
        onSwipeStart: xe(e.onSwipeStart, (f) => {
          f.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: xe(e.onSwipeMove, (f) => {
          const { x: h, y: p } = f.detail.delta;
          f.currentTarget.setAttribute("data-swipe", "move"), f.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${h}px`), f.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${p}px`);
        }),
        onSwipeCancel: xe(e.onSwipeCancel, (f) => {
          f.currentTarget.setAttribute("data-swipe", "cancel"), f.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), f.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), f.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), f.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: xe(e.onSwipeEnd, (f) => {
          const { x: h, y: p } = f.detail.delta;
          f.currentTarget.setAttribute("data-swipe", "end"), f.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), f.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), f.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${h}px`), f.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${p}px`), c(!1);
        })
      }
    ) });
  }
);
G2.displayName = df;
var [QW, JW] = B2(df, {
  onClose() {
  }
}), eX = _.forwardRef(
  (e, t) => {
    const {
      __scopeToast: n,
      type: r = "foreground",
      duration: o,
      open: a,
      onClose: s,
      onEscapeKeyDown: u,
      onPause: c,
      onResume: f,
      onSwipeStart: h,
      onSwipeMove: p,
      onSwipeCancel: g,
      onSwipeEnd: y,
      ...w
    } = e, v = Sm(df, n), [S, E] = _.useState(null), A = bt(t, (P) => E(P)), k = _.useRef(null), T = _.useRef(null), R = o || v.duration, N = _.useRef(0), j = _.useRef(R), z = _.useRef(0), { onToastAdd: B, onToastRemove: M } = v, F = Hn(() => {
      S?.contains(document.activeElement) && v.viewport?.focus(), s();
    }), q = _.useCallback(
      (P) => {
        !P || P === 1 / 0 || (window.clearTimeout(z.current), N.current = (/* @__PURE__ */ new Date()).getTime(), z.current = window.setTimeout(F, P));
      },
      [F]
    );
    _.useEffect(() => {
      const P = v.viewport;
      if (P) {
        const V = () => {
          q(j.current), f?.();
        }, I = () => {
          const U = (/* @__PURE__ */ new Date()).getTime() - N.current;
          j.current = j.current - U, window.clearTimeout(z.current), c?.();
        };
        return P.addEventListener(wb, I), P.addEventListener(_b, V), () => {
          P.removeEventListener(wb, I), P.removeEventListener(_b, V);
        };
      }
    }, [v.viewport, R, c, f, q]), _.useEffect(() => {
      a && !v.isClosePausedRef.current && q(R);
    }, [a, R, v.isClosePausedRef, q]), _.useEffect(() => (B(), () => M()), [B, M]);
    const Y = _.useMemo(() => S ? J2(S) : null, [S]);
    return v.viewport ? /* @__PURE__ */ b.jsxs(b.Fragment, { children: [
      Y && /* @__PURE__ */ b.jsx(
        tX,
        {
          __scopeToast: n,
          role: "status",
          "aria-live": r === "foreground" ? "assertive" : "polite",
          "aria-atomic": !0,
          children: Y
        }
      ),
      /* @__PURE__ */ b.jsx(QW, { scope: n, onClose: F, children: Pl.createPortal(
        /* @__PURE__ */ b.jsx(px.ItemSlot, { scope: n, children: /* @__PURE__ */ b.jsx(
          C8,
          {
            asChild: !0,
            onEscapeKeyDown: xe(u, () => {
              v.isFocusedToastEscapeKeyDownRef.current || F(), v.isFocusedToastEscapeKeyDownRef.current = !1;
            }),
            children: /* @__PURE__ */ b.jsx(
              qe.li,
              {
                role: "status",
                "aria-live": "off",
                "aria-atomic": !0,
                tabIndex: 0,
                "data-state": a ? "open" : "closed",
                "data-swipe-direction": v.swipeDirection,
                ...w,
                ref: A,
                style: { userSelect: "none", touchAction: "none", ...e.style },
                onKeyDown: xe(e.onKeyDown, (P) => {
                  P.key === "Escape" && (u?.(P.nativeEvent), P.nativeEvent.defaultPrevented || (v.isFocusedToastEscapeKeyDownRef.current = !0, F()));
                }),
                onPointerDown: xe(e.onPointerDown, (P) => {
                  P.button === 0 && (k.current = { x: P.clientX, y: P.clientY });
                }),
                onPointerMove: xe(e.onPointerMove, (P) => {
                  if (!k.current) return;
                  const V = P.clientX - k.current.x, I = P.clientY - k.current.y, U = !!T.current, H = ["left", "right"].includes(v.swipeDirection), G = ["left", "up"].includes(v.swipeDirection) ? Math.min : Math.max, O = H ? G(0, V) : 0, W = H ? 0 : G(0, I), Z = P.pointerType === "touch" ? 10 : 2, L = { x: O, y: W }, te = { originalEvent: P, delta: L };
                  U ? (T.current = L, hh(XW, p, te, {
                    discrete: !1
                  })) : OT(L, v.swipeDirection, Z) ? (T.current = L, hh(WW, h, te, {
                    discrete: !1
                  }), P.target.setPointerCapture(P.pointerId)) : (Math.abs(V) > Z || Math.abs(I) > Z) && (k.current = null);
                }),
                onPointerUp: xe(e.onPointerUp, (P) => {
                  const V = T.current, I = P.target;
                  if (I.hasPointerCapture(P.pointerId) && I.releasePointerCapture(P.pointerId), T.current = null, k.current = null, V) {
                    const U = P.currentTarget, H = { originalEvent: P, delta: V };
                    OT(V, v.swipeDirection, v.swipeThreshold) ? hh(ZW, y, H, {
                      discrete: !0
                    }) : hh(
                      KW,
                      g,
                      H,
                      {
                        discrete: !0
                      }
                    ), U.addEventListener("click", (G) => G.preventDefault(), {
                      once: !0
                    });
                  }
                })
              }
            )
          }
        ) }),
        v.viewport
      ) })
    ] }) : null;
  }
), tX = (e) => {
  const { __scopeToast: t, children: n, ...r } = e, o = Sm(df, t), [a, s] = _.useState(!1), [u, c] = _.useState(!1);
  return oX(() => s(!0)), _.useEffect(() => {
    const f = window.setTimeout(() => c(!0), 1e3);
    return () => window.clearTimeout(f);
  }, []), u ? null : /* @__PURE__ */ b.jsx(sm, { asChild: !0, children: /* @__PURE__ */ b.jsx(dx, { ...r, children: a && /* @__PURE__ */ b.jsxs(b.Fragment, { children: [
    o.label,
    " ",
    n
  ] }) }) });
}, nX = "ToastTitle", Y2 = _.forwardRef(
  (e, t) => {
    const { __scopeToast: n, ...r } = e;
    return /* @__PURE__ */ b.jsx(qe.div, { ...r, ref: t });
  }
);
Y2.displayName = nX;
var rX = "ToastDescription", W2 = _.forwardRef(
  (e, t) => {
    const { __scopeToast: n, ...r } = e;
    return /* @__PURE__ */ b.jsx(qe.div, { ...r, ref: t });
  }
);
W2.displayName = rX;
var X2 = "ToastAction", K2 = _.forwardRef(
  (e, t) => {
    const { altText: n, ...r } = e;
    return n.trim() ? /* @__PURE__ */ b.jsx(Q2, { altText: n, asChild: !0, children: /* @__PURE__ */ b.jsx(mx, { ...r, ref: t }) }) : (console.error(
      `Invalid prop \`altText\` supplied to \`${X2}\`. Expected non-empty \`string\`.`
    ), null);
  }
);
K2.displayName = X2;
var Z2 = "ToastClose", mx = _.forwardRef(
  (e, t) => {
    const { __scopeToast: n, ...r } = e, o = JW(Z2, n);
    return /* @__PURE__ */ b.jsx(Q2, { asChild: !0, children: /* @__PURE__ */ b.jsx(
      qe.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: xe(e.onClick, o.onClose)
      }
    ) });
  }
);
mx.displayName = Z2;
var Q2 = _.forwardRef((e, t) => {
  const { __scopeToast: n, altText: r, ...o } = e;
  return /* @__PURE__ */ b.jsx(
    qe.div,
    {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": r || void 0,
      ...o,
      ref: t
    }
  );
});
function J2(e) {
  const t = [];
  return Array.from(e.childNodes).forEach((r) => {
    if (r.nodeType === r.TEXT_NODE && r.textContent && t.push(r.textContent), iX(r)) {
      const o = r.ariaHidden || r.hidden || r.style.display === "none", a = r.dataset.radixToastAnnounceExclude === "";
      if (!o)
        if (a) {
          const s = r.dataset.radixToastAnnounceAlt;
          s && t.push(s);
        } else
          t.push(...J2(r));
    }
  }), t;
}
function hh(e, t, n, { discrete: r }) {
  const o = n.originalEvent.currentTarget, a = new CustomEvent(e, { bubbles: !0, cancelable: !0, detail: n });
  t && o.addEventListener(e, t, { once: !0 }), r ? R1(o, a) : o.dispatchEvent(a);
}
var OT = (e, t, n = 0) => {
  const r = Math.abs(e.x), o = Math.abs(e.y), a = r > o;
  return t === "left" || t === "right" ? a && r > n : !a && o > n;
};
function oX(e = () => {
}) {
  const t = Hn(e);
  ni(() => {
    let n = 0, r = 0;
    return n = window.requestAnimationFrame(() => r = window.requestAnimationFrame(t)), () => {
      window.cancelAnimationFrame(n), window.cancelAnimationFrame(r);
    };
  }, [t]);
}
function iX(e) {
  return e.nodeType === e.ELEMENT_NODE;
}
function aX(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const o = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function nv(e) {
  const t = document.activeElement;
  return e.some((n) => n === t ? !0 : (n.focus(), document.activeElement !== t));
}
var sX = H2, lX = U2, uX = G2, cX = Y2, fX = W2, dX = K2, hX = mx;
const ln = [];
for (let e = 0; e < 256; ++e)
  ln.push((e + 256).toString(16).slice(1));
function pX(e, t = 0) {
  return (ln[e[t + 0]] + ln[e[t + 1]] + ln[e[t + 2]] + ln[e[t + 3]] + "-" + ln[e[t + 4]] + ln[e[t + 5]] + "-" + ln[e[t + 6]] + ln[e[t + 7]] + "-" + ln[e[t + 8]] + ln[e[t + 9]] + "-" + ln[e[t + 10]] + ln[e[t + 11]] + ln[e[t + 12]] + ln[e[t + 13]] + ln[e[t + 14]] + ln[e[t + 15]]).toLowerCase();
}
let rv;
const mX = new Uint8Array(16);
function gX() {
  if (!rv) {
    if (typeof crypto > "u" || !crypto.getRandomValues)
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    rv = crypto.getRandomValues.bind(crypto);
  }
  return rv(mX);
}
const yX = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), NT = { randomUUID: yX };
function gx(e, t, n) {
  if (NT.randomUUID && !e)
    return NT.randomUUID();
  e = e || {};
  const r = e.random ?? e.rng?.() ?? gX();
  if (r.length < 16)
    throw new Error("Random bytes length must be >= 16");
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, pX(r);
}
const e3 = _.createContext(
  void 0
), t3 = _.createContext(
  void 0
), vX = 350, bX = ({ children: e, fixedHeight: t, duration: n = 5e3, maxVisible: r = 3, ...o }) => {
  const [a, s] = _.useState(/* @__PURE__ */ new Map()), u = _.useRef(/* @__PURE__ */ new Map()), c = _.useRef(null), f = _.useRef(!0), h = _.useCallback(() => {
    const E = Array.from(u.current).reverse();
    if (t) {
      const A = t;
      E.forEach(([, k], T) => {
        if (!k) return;
        k.setAttribute("data-front", String(T === 0)), k.setAttribute("data-hidden", String(T >= r)), k.style.setProperty("--index", String(T)), k.style.setProperty("--height", `${t}px`), k.style.setProperty("--front-height", `${A}px`);
        const R = t * T;
        k.style.setProperty("--hover-offset-y", `-${R}px`);
      });
    } else {
      const A = E.map(([, T]) => {
        if (!T) return 0;
        const R = T.querySelector(
          ".ToastInner"
        );
        if (!R) return T.clientHeight;
        const N = R.style.height;
        R.style.height = "auto";
        const j = T.clientHeight;
        return R.style.height = N, j;
      }), k = A[0] || 0;
      E.forEach(([, T], R) => {
        if (!T) return;
        const N = A[R];
        T.setAttribute("data-front", String(R === 0)), T.setAttribute("data-hidden", String(R >= r)), T.style.setProperty("--index", String(R)), T.style.setProperty("--height", `${N}px`), T.style.setProperty("--front-height", `${k}px`);
        const j = A.slice(0, R).reduce((z, B) => z + B, 0);
        T.style.setProperty("--hover-offset-y", `-${j}px`);
      });
    }
  }, [t, r]), p = _.useCallback(
    (E) => {
      s((A) => {
        const k = new Map(A);
        return k.set(gx(), {
          ...E,
          duration: E.duration || n,
          open: !0
        }), k;
      });
    },
    [n]
  ), g = _.useCallback((E) => {
    f.current && s((A) => {
      const k = new Map(A);
      return k.delete(E), k;
    });
  }, []), y = _.useCallback(
    (E) => p({ ...E, status: E.status || "default" }),
    [p]
  ), w = _.useCallback(
    (E) => p({ ...E, status: "success" }),
    [p]
  ), v = _.useCallback(
    (E) => p({ ...E, status: "error" }),
    [p]
  );
  _.useEffect(() => (f.current = !0, () => {
    f.current = !1;
  }), []), _.useEffect(() => {
    const E = c.current;
    if (E) {
      const A = () => {
        u.current.forEach((R) => {
          R.setAttribute("data-hovering", "true");
        });
      }, k = (R) => {
        (!E.contains(R.target) || E === R.target) && u.current.forEach((N) => {
          N.setAttribute("data-hovering", "false");
        });
      }, T = () => {
        u.current.forEach((R) => {
          R.setAttribute("data-hovering", "false");
        });
      };
      return E.addEventListener("pointermove", A), E.addEventListener("pointerleave", T), E.addEventListener("focusin", A), E.addEventListener("focusout", k), () => {
        E.removeEventListener("pointermove", A), E.removeEventListener("pointerleave", T), E.removeEventListener("focusin", A), E.removeEventListener("focusout", k);
      };
    }
  }, []);
  const S = _.useMemo(
    () => Object.assign(y, {
      success: w,
      error: v
    }),
    [y, w, v]
  );
  return /* @__PURE__ */ b.jsx(e3.Provider, { value: S, children: /* @__PURE__ */ b.jsx(
    t3.Provider,
    {
      value: _.useMemo(
        () => ({
          toastElementsMapRef: u,
          sortToasts: h
        }),
        [h]
      ),
      children: /* @__PURE__ */ b.jsxs(sX, { ...o, children: [
        e,
        Array.from(a).map(([E, A]) => /* @__PURE__ */ b.jsx(
          _X,
          {
            id: E,
            toast: A,
            onOpenChange: (k) => {
              k || (u.current.delete(E), h(), s((T) => {
                const R = new Map(T), N = R.get(E);
                return N && R.set(E, { ...N, open: !1 }), R;
              }), setTimeout(() => {
                g(E);
              }, vX));
            }
          },
          E
        )),
        /* @__PURE__ */ b.jsx(
          lX,
          {
            ref: c,
            className: "ToastViewport",
            style: t ? {
              "--fixed-toast-height": `${t}px`
            } : void 0
          }
        )
      ] })
    }
  ) });
}, xX = () => {
  const e = _.useContext(e3);
  if (e) return e;
  throw new Error("useToast must be used within Toasts");
}, wX = () => {
  const e = _.useContext(t3);
  if (e) return e;
  throw new Error("useToastContext must be used within Toasts");
}, _X = ({
  onOpenChange: e,
  toast: t,
  id: n,
  ...r
}) => {
  const o = _.useRef(null), a = wX(), { sortToasts: s, toastElementsMapRef: u } = a, c = u.current;
  return _.useLayoutEffect(() => (o.current && (c.set(n, o.current), s()), () => {
    c.delete(n), s();
  }), [n, s, c]), /* @__PURE__ */ b.jsx(
    uX,
    {
      ...r,
      ref: o,
      type: t.type,
      duration: t.duration,
      className: "ToastRoot",
      onOpenChange: e,
      open: t.open,
      children: /* @__PURE__ */ b.jsxs("div", { className: "ToastInner", "data-status": t.status, children: [
        /* @__PURE__ */ b.jsx(SX, { status: t.status }),
        t.title && /* @__PURE__ */ b.jsx(cX, { className: "ToastTitle", children: t.title }),
        /* @__PURE__ */ b.jsx(fX, { className: "ToastDescription", children: t.description }),
        t.action && /* @__PURE__ */ b.jsx(
          dX,
          {
            className: "ToastAction Button small green",
            altText: t.action.altText,
            onClick: t.action.onClick,
            asChild: !0,
            children: /* @__PURE__ */ b.jsx("button", { children: t.action.label })
          }
        ),
        /* @__PURE__ */ b.jsx(hX, { "aria-label": "Close", className: "ToastClose", children: /* @__PURE__ */ b.jsx(Ic, { style: { fontSize: "12px" } }) })
      ] })
    }
  );
}, SX = ({ status: e }) => e !== "default" && e ? /* @__PURE__ */ b.jsxs("div", { style: { gridArea: "icon", alignSelf: "start" }, children: [
  e === "success" && /* @__PURE__ */ b.jsx(LV, { style: { color: "#61d345", fontSize: "20px" } }),
  e === "error" && /* @__PURE__ */ b.jsx(FV, { style: { color: "#ff4b4b", fontSize: "20px" } })
] }) : null, EX = {}, DT = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), r = (h, p) => {
    const g = typeof h == "function" ? h(t) : h;
    if (!Object.is(g, t)) {
      const y = t;
      t = p ?? (typeof g != "object" || g === null) ? g : Object.assign({}, t, g), n.forEach((w) => w(t, y));
    }
  }, o = () => t, c = { setState: r, getState: o, getInitialState: () => f, subscribe: (h) => (n.add(h), () => n.delete(h)), destroy: () => {
    (EX ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), n.clear();
  } }, f = t = e(r, o, c);
  return c;
}, n3 = (e) => e ? DT(e) : DT;
var ov = { exports: {} }, iv = {}, av = { exports: {} }, sv = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var jT;
function CX() {
  if (jT) return sv;
  jT = 1;
  var e = ef();
  function t(p, g) {
    return p === g && (p !== 0 || 1 / p === 1 / g) || p !== p && g !== g;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, o = e.useEffect, a = e.useLayoutEffect, s = e.useDebugValue;
  function u(p, g) {
    var y = g(), w = r({ inst: { value: y, getSnapshot: g } }), v = w[0].inst, S = w[1];
    return a(
      function() {
        v.value = y, v.getSnapshot = g, c(v) && S({ inst: v });
      },
      [p, y, g]
    ), o(
      function() {
        return c(v) && S({ inst: v }), p(function() {
          c(v) && S({ inst: v });
        });
      },
      [p]
    ), s(y), y;
  }
  function c(p) {
    var g = p.getSnapshot;
    p = p.value;
    try {
      var y = g();
      return !n(p, y);
    } catch {
      return !0;
    }
  }
  function f(p, g) {
    return g();
  }
  var h = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? f : u;
  return sv.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : h, sv;
}
var PT;
function kX() {
  return PT || (PT = 1, av.exports = CX()), av.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var IT;
function TX() {
  if (IT) return iv;
  IT = 1;
  var e = ef(), t = kX();
  function n(f, h) {
    return f === h && (f !== 0 || 1 / f === 1 / h) || f !== f && h !== h;
  }
  var r = typeof Object.is == "function" ? Object.is : n, o = t.useSyncExternalStore, a = e.useRef, s = e.useEffect, u = e.useMemo, c = e.useDebugValue;
  return iv.useSyncExternalStoreWithSelector = function(f, h, p, g, y) {
    var w = a(null);
    if (w.current === null) {
      var v = { hasValue: !1, value: null };
      w.current = v;
    } else v = w.current;
    w = u(
      function() {
        function E(N) {
          if (!A) {
            if (A = !0, k = N, N = g(N), y !== void 0 && v.hasValue) {
              var j = v.value;
              if (y(j, N))
                return T = j;
            }
            return T = N;
          }
          if (j = T, r(k, N)) return j;
          var z = g(N);
          return y !== void 0 && y(j, z) ? (k = N, j) : (k = N, T = z);
        }
        var A = !1, k, T, R = p === void 0 ? null : p;
        return [
          function() {
            return E(h());
          },
          R === null ? void 0 : function() {
            return E(R());
          }
        ];
      },
      [h, p, g, y]
    );
    var S = o(f, w[0], w[1]);
    return s(
      function() {
        v.hasValue = !0, v.value = S;
      },
      [S]
    ), c(S), S;
  }, iv;
}
var zT;
function AX() {
  return zT || (zT = 1, ov.exports = TX()), ov.exports;
}
var RX = AX();
const r3 = /* @__PURE__ */ jl(RX), o3 = {}, { useDebugValue: MX } = nn, { useSyncExternalStoreWithSelector: OX } = r3;
let LT = !1;
const NX = (e) => e;
function DX(e, t = NX, n) {
  (o3 ? "production" : void 0) !== "production" && n && !LT && (console.warn(
    "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
  ), LT = !0);
  const r = OX(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return MX(r), r;
}
const FT = (e) => {
  (o3 ? "production" : void 0) !== "production" && typeof e != "function" && console.warn(
    "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
  );
  const t = typeof e == "function" ? n3(e) : e, n = (r, o) => DX(t, r, o);
  return Object.assign(n, t), n;
}, Er = (e) => e ? FT(e) : FT;
class di {
  constructor(t) {
    this.context = t;
  }
  get communicationManager() {
    return this.context.worker.getCommunicationManager();
  }
  get eventManager() {
    return this.context.worker.getEventManager();
  }
  get hookManager() {
    return this.context.worker.getHookManager();
  }
  get nodeManager() {
    return this.context.worker.getNodeManager();
  }
  get syncManager() {
    return this.context.worker.getSyncManager();
  }
  get connectionHealthManager() {
    return this.context.worker.getConnectionHealthManager();
  }
  get edgeManager() {
    return this.context.worker.getEdgeManager();
  }
  get groupManager() {
    return this.context.worker.getGroupManager();
  }
  get libraryManager() {
    return this.context.worker.getLibraryManager();
  }
}
const ph = 2e3;
class jX extends di {
  constructor(t) {
    super(t), this._responsive = !1, this._last_pong = 0, this._last_pong = Date.now() - ph * 100;
  }
  start() {
    this.stop(), this.pingInterval = setInterval(() => {
      this.context.worker.is_open && this.context.worker.send({ type: "ping" });
    }, ph), this.responsivenessCheckInterval = setInterval(() => {
      this._responsive = Date.now() - this._last_pong <= ph * 3;
    }, ph * 2);
  }
  stop() {
    this.pingInterval && clearInterval(this.pingInterval), this.responsivenessCheckInterval && clearInterval(this.responsivenessCheckInterval);
  }
  receivePong() {
    this._last_pong = Date.now(), this._responsive = !0;
  }
  isResponsive() {
    return this._responsive;
  }
}
const $T = (e, t) => {
  e.properties = e.properties || {}, t.pos && (e.properties["frontend:pos"] = t.pos), t.size && (e.properties["frontend:size"] = t.size), t.collapsed !== void 0 && (e.properties["frontend:collapsed"] = !!t.collapsed);
}, BT = 2e3, HT = 2e3;
class PX extends di {
  constructor(t) {
    super(t), this._local_nodeupdates = /* @__PURE__ */ new Map(), this._local_groupupdates = /* @__PURE__ */ new Map(), this.on_sync_complete = t.on_sync_complete || (async () => {
    });
  }
  start() {
    this._nodeupdatetimer = setTimeout(() => {
      this.sync_local_node_updates();
    }, BT), this._groupupdatetimer = setTimeout(() => {
      this.sync_local_group_updates();
    }, HT);
  }
  stop() {
    this._nodeupdatetimer && clearTimeout(this._nodeupdatetimer), this._groupupdatetimer && clearTimeout(this._groupupdatetimer);
  }
  async stepwise_fullsync() {
    this.context.worker._zustand && this.context.worker.is_open && (await this.sync_lib(), await this.sync_external_worker(), await this.sync_funcnodes_plugins(), await this.sync_nodespace(), await this.sync_view_state(), await this.on_sync_complete(this.context.worker));
  }
  async sync_lib() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    const t = await this.communicationManager._send_cmd({
      cmd: "get_library",
      wait_for_response: !0,
      retries: 2,
      unique: !0
    });
    this.context.worker._zustand.lib.libstate.getState().set({
      lib: t
    });
  }
  async sync_external_worker() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    const t = await this.communicationManager._send_cmd({
      cmd: "get_worker_dependencies",
      wait_for_response: !0,
      unique: !0
    });
    this.context.worker._zustand.lib.libstate.getState().set({
      external_worker: t
    });
  }
  async sync_funcnodes_plugins() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    const t = await this.context.worker.getCommunicationManager()._send_cmd({
      cmd: "get_plugin_keys",
      wait_for_response: !0,
      unique: !0,
      kwargs: { type: "react" }
    });
    for (const n of t) {
      const r = await this.context.worker.getCommunicationManager()._send_cmd({
        cmd: "get_plugin",
        wait_for_response: !0,
        kwargs: { key: n, type: "react" },
        unique: !0
      });
      this.context.worker._zustand.add_packed_plugin(n, r);
    }
  }
  async sync_view_state() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    const t = await this.context.worker.getCommunicationManager()._send_cmd({
      cmd: "view_state",
      wait_for_response: !0,
      unique: !0
    });
    t.renderoptions && this.context.worker._zustand.update_render_options(t.renderoptions);
    const n = t.nodes;
    if (n)
      for (const r in n) {
        const o = {};
        $T(o, n[r]), this.context.worker._zustand.on_node_action({
          type: "update",
          node: o,
          id: r,
          from_remote: !0
        });
      }
  }
  async sync_nodespace() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    const t = await this.context.worker.getCommunicationManager()._send_cmd({
      cmd: "get_nodes",
      kwargs: { with_frontend: !0 },
      wait_for_response: !0,
      unique: !0
    });
    for (const o of t)
      this.eventManager._receive_node_added(o);
    const n = await this.context.worker.getCommunicationManager()._send_cmd({
      cmd: "get_edges",
      wait_for_response: !0,
      unique: !0
    });
    for (const o of n)
      this.eventManager._receive_edge_added(...o);
    const r = await this.context.worker.getCommunicationManager()._send_cmd({
      cmd: "get_groups",
      kwargs: {},
      wait_for_response: !0,
      unique: !0
    });
    this.eventManager._receive_groups(r);
  }
  async fullsync() {
    if (!this.context.worker._zustand || !this.context.worker.is_open) return;
    let t;
    for (; ; )
      try {
        t = await this.communicationManager._send_cmd({
          cmd: "full_state",
          unique: !0
        });
        break;
      } catch (o) {
        o instanceof Error ? this.context.worker._zustand.logger.error("Error in fullsync", o) : this.context.worker._zustand.logger.error(
          "Error in fullsync",
          new Error(JSON.stringify(o))
        );
      }
    this.context.worker._zustand.logger.debug("Full state", t), this.context.worker._zustand.lib.libstate.getState().set({
      lib: t.backend.lib,
      external_worker: t.worker_dependencies
    }), t.view.renderoptions && this.context.worker._zustand.update_render_options(
      t.view.renderoptions
    );
    const n = t.view.nodes;
    for (const o of t.backend.nodes) {
      const a = n[o.id];
      a !== void 0 && $T(o, a), this.eventManager._receive_node_added(o);
    }
    for (const o of t.backend.edges)
      this.eventManager._receive_edge_added(...o);
    const r = t.backend.groups;
    r && this.eventManager._receive_groups(r);
  }
  sync_local_node_updates() {
    clearTimeout(this._nodeupdatetimer), this._local_nodeupdates.forEach(async (t, n) => {
      const r = await this.context.worker.getCommunicationManager()._send_cmd({
        cmd: "update_node",
        kwargs: { nid: n, data: t },
        wait_for_response: !0
      });
      this.context.worker._zustand && Object.keys(r).length > 0 && this.context.worker._zustand.on_node_action({
        type: "update",
        node: r,
        id: n,
        from_remote: !0
      });
    }), this._local_nodeupdates.clear(), this._nodeupdatetimer = setTimeout(() => {
      this.sync_local_node_updates();
    }, BT);
  }
  sync_local_group_updates() {
    clearTimeout(this._groupupdatetimer), this._local_groupupdates.forEach(async (t, n) => {
      const r = await this.communicationManager._send_cmd({
        cmd: "update_group",
        kwargs: { gid: n, data: t },
        wait_for_response: !0
      });
      this.context.worker._zustand && this.context.worker._zustand.on_group_action({
        type: "update",
        group: r,
        id: n,
        from_remote: !0
      });
    }), this._local_groupupdates.clear(), this._groupupdatetimer = setTimeout(() => {
      this.sync_local_group_updates();
    }, HT);
  }
  locally_update_node(t) {
    const n = this._local_nodeupdates.get(t.id);
    if (n) {
      const { new_obj: r, change: o } = Ha(n, t.node);
      o && this._local_nodeupdates.set(t.id, r);
    } else
      this._local_nodeupdates.set(t.id, t.node);
    t.immediate && this.sync_local_node_updates();
  }
  locally_update_group(t) {
    const n = this._local_groupupdates.get(t.id);
    if (n) {
      const { new_obj: r, change: o } = Ha(n, t.group);
      o && this._local_groupupdates.set(t.id, r);
    } else
      this._local_groupupdates.set(t.id, t.group);
    t.immediate && this.sync_local_group_updates();
  }
}
class co {
  /**
   * Creates a new DataStructure instance.
   *
   * @param props - Configuration object containing data and MIME type
   */
  constructor({ data: t, mime: n }) {
    this._data = t, this._mime = n;
  }
  /**
   * Gets the raw wrapped data.
   *
   * @returns The original data in its native type
   */
  get data() {
    return this._data;
  }
  /**
   * Gets the data cast to the expected return type.
   * This is a type assertion and should be overridden in subclasses for proper type conversion.
   *
   * @returns The data cast to type R
   */
  get value() {
    return this._data;
  }
  /**
   * Gets the MIME type of the wrapped data.
   *
   * @returns The MIME type string
   */
  get mime() {
    return this._mime;
  }
  /**
   * Returns a string representation of the DataStructure.
   * The format varies based on the data type:
   * - ArrayBuffer: shows byte length
   * - Blob: shows size
   * - String/Array: shows length
   * - Object: shows number of keys
   * - Other types: shows only MIME type
   *
   * @returns String representation in format "DataStructure(size,mime)" or "DataStructure(mime)"
   */
  toString() {
    return this._data instanceof ArrayBuffer ? `DataStructure(${this._data.byteLength},${this._mime})` : this._data instanceof Blob ? `DataStructure(${this._data.size},${this._mime})` : this._data instanceof String ? `DataStructure(${this._data.length},${this._mime})` : this._data instanceof Array ? `DataStructure(${this._data.length},${this._mime})` : this._data instanceof Object ? `DataStructure(${Object.keys(this._data).length},${this._mime})` : `DataStructure(${this._mime})`;
  }
  /**
   * Returns the JSON representation of this DataStructure.
   * Currently delegates to toString() method.
   *
   * @returns JSON string representation
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Cleans up resources associated with this DataStructure.
   * Base implementation does nothing, but subclasses may override to release resources.
   */
  dispose() {
  }
}
class i3 extends co {
  get objectUrl() {
    if (this._objectUrl)
      return this._objectUrl;
    const t = this.data instanceof Blob ? this.data : new Blob([this.data], { type: this.mime });
    return this._objectUrl = URL.createObjectURL(t), this._objectUrl;
  }
  dispose() {
    this._objectUrl && URL.revokeObjectURL(this._objectUrl), super.dispose();
  }
  get value() {
    return this.objectUrl;
  }
}
const qt = (e) => e.buffer ? e.buffer : e, IX = {
  x: (e, t) => null,
  //  pad byte 	no value 	(7 )
  c: (e, t) => new DataView(qt(e)).getInt8(0),
  //  char 	bytes of length 1 	1 	b 	signed char 	integer 	1 	(1 ), (2 )
  B: (e, t) => new DataView(qt(e)).getUint8(0),
  //  unsigned char 	integer 	1 	(2 )
  "?": (e, t) => new DataView(qt(e)).getInt8(0) === 1,
  //  _Bool 	bool 	1 	(1 )
  h: (e, t) => new DataView(qt(e)).getInt16(0, t),
  //  short 	integer 	2 	(2 )
  H: (e, t) => new DataView(qt(e)).getUint16(0, t),
  //  unsigned short 	integer 	2 	(2 )
  i: (e, t) => new DataView(qt(e)).getInt32(0, t),
  //  int 	integer 	4 	(2 )
  I: (e, t) => new DataView(qt(e)).getUint32(0, t),
  //  unsigned int 	integer 	4 	(2 )
  l: (e, t) => new DataView(qt(e)).getInt32(0, t),
  //  long 	integer 	4 	(2 )
  L: (e, t) => new DataView(qt(e)).getUint32(0, t),
  //  unsigned long 	integer 	4 	(2 )
  q: (e, t) => Number(
    new DataView(qt(e)).getBigInt64(0, t)
  ),
  //  long long 	integer 	8 	(2 )
  Q: (e, t) => Number(
    new DataView(qt(e)).getBigUint64(0, t)
  ),
  //  unsigned long long 	integer 	8 	(2 )
  n: (e, t) => Number(
    new DataView(qt(e)).getBigInt64(0, t)
  ),
  //  ssize_t 	integer 	(3 )
  N: (e, t) => Number(
    new DataView(qt(e)).getBigUint64(0, t)
  ),
  //  size_t 	integer 	(3 )
  // "e":(data:ArrayBufferLike)=>{return new DataView(to_arraybuffer(data)).getFloat16(0)}, //  (6 ) float 	2 	(4 )
  f: (e, t) => new DataView(qt(e)).getFloat32(0, t),
  //  float 	float 	4 	(4 )
  d: (e, t) => new DataView(qt(e)).getFloat64(0, t),
  //  double 	float 	8 	(4 )
  s: (e, t) => new TextDecoder().decode(qt(e)),
  //  char[] 	bytes 	(9 )
  p: (e, t) => new TextDecoder().decode(qt(e)),
  //  char[] 	bytes 	(8 )
  P: (e, t) => Number(
    new DataView(qt(e)).getBigUint64(0, t)
  )
  //  void* 	int
};
class a3 extends co {
  constructor({ data: t, mime: n }) {
    super({ data: t, mime: n }), this._cType = n.split("application/fn.struct.")[1], this._value = null, this.parse_value();
  }
  parse_value() {
    let t = !0, n = this._cType;
    return n.startsWith("<") && (t = !0, n = n.slice(1)), n.startsWith(">") && (t = !1, n = n.slice(1)), n.startsWith("!") && (t = !1, n = n.slice(1)), n.startsWith("@") && (t = !1, n = n.slice(1)), n.startsWith("=") && (t = !1, n = n.slice(1)), this._value = IX[n](this.data, t), this._value;
  }
  get value() {
    return this._value;
  }
  toString() {
    return this._value === null ? "null" : this._value.toString();
  }
}
class Qi extends co {
  constructor({ data: t, mime: n }) {
    super({ data: t, mime: n }), t.length === 0 ? this._json = void 0 : (this._json = JSON.parse(new TextDecoder().decode(qt(t))), this._json === "<NoValue>" && (this._json = void 0));
  }
  get value() {
    return this._json;
  }
  static fromObject(t) {
    const n = t === "<NoValue>" ? new Uint8Array(0) : new TextEncoder().encode(JSON.stringify(t));
    return new Qi({ data: n, mime: "application/json" });
  }
  toString() {
    return typeof this._json == "string" ? this._json : JSON.stringify(this._json);
  }
}
class s3 extends co {
  constructor({ data: t, mime: n }) {
    super({ data: t, mime: n }), this._value = new TextDecoder().decode(qt(t));
  }
  get value() {
    return this._value;
  }
  toString() {
    return this._value;
  }
}
const l3 = ({
  data: e,
  mime: t
}) => e instanceof ArrayBuffer || e instanceof Uint8Array ? t.startsWith("application/fn.struct.") ? new a3({ data: e, mime: t }) : t.startsWith("application/json") ? new Qi({ data: e, mime: t }) : t === "text" || t.startsWith("text/") ? new s3({ data: e, mime: t }) : new i3({ data: e, mime: t }) : new co({ data: e, mime: t });
class zX extends di {
  constructor(t) {
    super(t), this.CHUNK_TIMEOUT = 1e4, this._unique_cmd_outs = {}, this.blobChunks = {}, this.cleanupChunks = () => {
      const n = Date.now();
      for (const r in this.blobChunks)
        n - this.blobChunks[r].timestamp > this.CHUNK_TIMEOUT && delete this.blobChunks[r];
    }, this.messagePromises = /* @__PURE__ */ new Map();
  }
  start() {
    this._chunk_cleanup_timer = setInterval(
      this.cleanupChunks.bind(this),
      this.CHUNK_TIMEOUT / 2
    );
  }
  stop() {
    this._chunk_cleanup_timer && clearInterval(this._chunk_cleanup_timer);
  }
  send(t) {
    this.context.worker.send(t);
  }
  async _send_cmd({
    cmd: t,
    kwargs: n,
    as_bytes: r = !1,
    wait_for_response: o = !0,
    response_timeout: a = 5e3,
    retries: s = 2,
    unique: u = !1
  }) {
    const c = {
      type: "cmd",
      as_bytes: r,
      cmd: t,
      kwargs: n || {}
    };
    if (await new Promise(async (f) => {
      if (this.context.worker.is_responsive) return f();
      const h = setInterval(() => {
        this.context.worker.is_responsive && (clearInterval(h), f());
      }, 100);
    }), o) {
      if (u && this._unique_cmd_outs[c.cmd] !== void 0)
        return this._unique_cmd_outs[c.cmd];
      s < 0 && (s = 0);
      const h = (async () => {
        let p;
        for (; s >= 0; ) {
          const g = c.id || gx();
          c.id = g;
          const y = new Promise((w, v) => {
            const S = setTimeout(() => {
              v("Timeout@wait_for_response for " + t);
            }, a);
            this.messagePromises.set(g, {
              resolve: (E) => {
                clearTimeout(S), w(E), this.messagePromises.delete(g);
              },
              reject: (E) => {
                clearTimeout(S), v(E), this.messagePromises.delete(g);
              }
            });
          });
          await this.send(c);
          try {
            p = await y;
            break;
          } catch (w) {
            if (s === 0)
              throw delete this._unique_cmd_outs[c.cmd], w;
            s -= 1;
            continue;
          }
        }
        return delete this._unique_cmd_outs[c.cmd], p;
      })();
      return u && (this._unique_cmd_outs[c.cmd] = h), h;
    }
    return this.send(c);
  }
  async receive(t) {
    let n;
    switch (this.connectionHealthManager.receivePong(), t.type) {
      case "pong":
        return this.connectionHealthManager.receivePong();
      case "nsevent":
        return await this.context.worker.getEventManager().receive_nodespace_event(t);
      case "result":
        if (n = t.id && this.messagePromises.get(t.id), n)
          return n.resolve(t.result);
        break;
      case "error":
        if (this.context.worker.on_error(t.tb + `
` + t.error), n = t.id && this.messagePromises.get(t.id), n)
          return n.reject(t.error);
        break;
      case "progress":
        if (!this.context.worker._zustand) return;
        this.context.worker._zustand.set_progress(t);
        break;
      case "workerevent":
        return await this.context.worker.getEventManager().receive_workerevent(t);
      case "large_message":
        return await this.context.worker.handle_large_message_hint(t);
      default:
        console.warn("Unhandled message", t);
        break;
    }
  }
  async recieve_bytes(t, n) {
    const { type: r } = t;
    if (r === "io_value") {
      if (!this.context.worker._zustand) return;
      const { node: o, io: a, preview: s, mime: u } = t, c = s ? "value" : "fullvalue";
      (!o || !a) && console.error("Invalid io_value message", t);
      const f = l3({
        data: n,
        mime: u || "application/octet-stream"
      });
      this.context.worker._zustand.on_node_action({
        type: "update",
        node: {
          id: o,
          io: {
            [a]: {
              [c]: f
            }
          }
        },
        id: o,
        from_remote: !0
      });
    } else if (r == "result") {
      const o = t.id && this.messagePromises.get(t.id);
      o && o.resolve({ bytes: n, header: t });
    } else
      console.warn("Unhandled bytes message", t);
  }
  async onbytes(t) {
    try {
      const n = new TextDecoder("utf-8").decode(t), r = n.indexOf(`\r
\r
`);
      if (r === -1) {
        console.error(`Header terminator not found for:
`, n);
        return;
      }
      const o = n.substring(0, r + 4), a = t.slice(r + 4), s = o.split(";"), u = {};
      if (s.forEach((p) => {
        const [g, y] = p.split("=");
        u[g.trim()] = y.trim();
      }), !u.chunk || !u.msgid) {
        console.error(
          "Header missing required fields chunk or msgid",
          u
        );
        return;
      }
      const [c, f] = u.chunk.split("/"), h = u.msgid;
      if (c === "1" && f === "1")
        return this.recieve_bytes(u, a);
      if (this.blobChunks[h] || (this.blobChunks[h] = {
        chunks: Array.from({ length: parseInt(f) }, () => null),
        timestamp: Date.now()
      }), this.blobChunks[h].chunks.length !== parseInt(f)) {
        console.error("Total chunks mismatch");
        return;
      }
      if (this.blobChunks[h].chunks[parseInt(c) - 1] = t, this.blobChunks[h].chunks.every((p) => p !== null)) {
        const p = new Uint8Array(
          this.blobChunks[h].chunks.reduce((g, y) => g.concat(Array.from(y)), [])
        );
        this.recieve_bytes(u, p), delete this.blobChunks[h];
      }
    } catch (n) {
      console.error("Websocketworker: onbytes error", n, t);
      return;
    }
  }
}
class LX extends di {
  constructor() {
    super(...arguments), this._ns_event_intercepts = /* @__PURE__ */ new Map();
  }
  start() {
  }
  stop() {
  }
  async _receive_edge_added(t, n, r, o) {
    this.context.worker._zustand && this.context.worker._zustand.on_edge_action({
      type: "add",
      from_remote: !0,
      src_nid: t,
      src_ioid: n,
      trg_nid: r,
      trg_ioid: o
    });
  }
  async _receive_groups(t) {
    this.context.worker._zustand && this.context.worker._zustand.on_group_action({
      type: "set",
      groups: t
    });
  }
  async _receive_node_added(t) {
    if (this.context.worker._zustand)
      return this.context.worker._zustand.on_node_action({
        type: "add",
        node: t,
        id: t.id,
        from_remote: !0
      });
  }
  async receive_workerevent({ event: t, data: n }) {
    switch (t) {
      case "worker_error":
        return this.context.worker._zustand ? this.context.worker._zustand.logger.error(n.error) : void 0;
      case "update_worker_dependencies":
        return this.context.worker._zustand ? this.context.worker._zustand.lib.libstate.getState().set({
          external_worker: n.worker_dependencies
        }) : void 0;
      case "lib_update":
        await this.context.worker.getSyncManager().sync_lib();
        return;
      case "fullsync":
        await this.context.worker.getSyncManager().stepwise_fullsync();
        return;
      case "external_worker_update":
        await this.context.worker.getSyncManager().sync_lib(), await this.context.worker.getSyncManager().sync_external_worker();
        return;
      case "starting":
        this.hookManager.call_hooks("starting");
        return;
      case "stopping":
        this.hookManager.call_hooks("stopping");
        return;
      default:
        console.warn("Unhandled worker event", t, n);
        break;
    }
  }
  async intercept_ns_event(t) {
    let n = t;
    for (const r of this._ns_event_intercepts.get(t.event) || [])
      n = await r(n);
    return n;
  }
  async receive_nodespace_event(t) {
    const { event: n, data: r } = await this.intercept_ns_event(t);
    switch (n) {
      case "after_set_value":
        return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            io: {
              [r.io]: {
                value: r.result
              }
            }
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "after_update_value_options":
        return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            io: {
              [r.io]: {
                value_options: r.result
              }
            }
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "triggerstart":
        return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            in_trigger: !0
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "triggerdone":
        return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            in_trigger: !1
          },
          id: r.node,
          from_remote: !0
        }) : void 0;
      case "triggerfast":
        if (!this.context.worker._zustand) return;
        this.context.worker._zustand.on_node_action({
          type: "update",
          node: {
            id: r.node,
            in_trigger: !0
          },
          id: r.node,
          from_remote: !0
        }), setTimeout(() => {
          this.context.worker._zustand && this.context.worker._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              in_trigger: !1
            },
            id: r.node,
            from_remote: !0
          });
        }, 50);
        return;
      case "node_trigger_error":
        return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
          type: "error",
          errortype: "trigger",
          error: r.error,
          id: r.node,
          tb: r.tb,
          from_remote: !0
        }) : void 0;
      case "node_removed":
        if (!this.context.worker._zustand) return;
        this.context.worker._zustand.on_node_action({
          type: "delete",
          id: r.node,
          from_remote: !0
        }), this.hookManager.call_hooks("node_removed", {
          node: r.node
        });
        return;
      case "node_added":
        this._receive_node_added(r.node);
        return;
      case "after_disconnect":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.on_edge_action({
          type: "delete",
          from_remote: !0,
          src_nid: r.result[0],
          src_ioid: r.result[1],
          trg_nid: r.result[2],
          trg_ioid: r.result[3]
        });
      case "after_unforward":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.on_edge_action({
          type: "delete",
          from_remote: !0,
          src_nid: r.result[0],
          src_ioid: r.result[1],
          trg_nid: r.result[2],
          trg_ioid: r.result[3]
        });
      case "after_connect":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 ? void 0 : this._receive_edge_added(
          ...r.result
        );
      case "after_forward":
        return !r.result || !Array.isArray(r.result) || r.result.length !== 4 ? void 0 : this._receive_edge_added(
          ...r.result
        );
      case "after_add_shelf":
        return !r.result || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.lib.libstate.getState().set({
          lib: r.result
        });
      case "after_remove_shelf":
        return !r.result || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.lib.libstate.getState().set({
          lib: r.result
        });
      case "progress":
        if (!this.context.worker._zustand) return;
        if (r.node)
          return this.context.worker._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              progress: r.info
            },
            id: r.node,
            from_remote: !0
          });
        console.warn("Unhandled nodepsace event", n, r);
        break;
      default:
        if (["after_set_nodespace"].includes(n)) return;
        console.warn("Unhandled nodepsace event", n, r);
        break;
    }
  }
  add_ns_event_intercept(t, n) {
    const r = this._ns_event_intercepts.get(t) || [];
    return r.push(n), this._ns_event_intercepts.set(t, r), () => {
      const a = this._ns_event_intercepts.get(t) || [], s = a.indexOf(n);
      s >= 0 && a.splice(s, 1);
    };
  }
}
class FX extends di {
  constructor() {
    super(...arguments), this._hooks = /* @__PURE__ */ new Map();
  }
  start() {
  }
  stop() {
  }
  add_hook(t, n) {
    const r = this._hooks.get(t) || [];
    return r.push(n), this._hooks.set(t, r), () => {
      const a = this._hooks.get(t) || [], s = a.indexOf(n);
      s >= 0 && a.splice(s, 1);
    };
  }
  async call_hooks(t, n) {
    const r = [];
    for (const o of this._hooks.get(t) || []) {
      const a = o({ worker: this.context.worker, data: n });
      a instanceof Promise && r.push(a);
    }
    await Promise.all(r);
  }
}
class $X extends di {
  start() {
  }
  stop() {
  }
  async trigger_node(t) {
    await this.communicationManager._send_cmd({
      cmd: "trigger_node",
      kwargs: { nid: t },
      wait_for_response: !1
    });
  }
  async add_node(t) {
    const n = await this.communicationManager._send_cmd({
      cmd: "add_node",
      kwargs: { id: t }
    });
    return this.eventManager._receive_node_added(n);
  }
  async remove_node(t) {
    await this.communicationManager._send_cmd({
      cmd: "remove_node",
      kwargs: { id: t }
    });
  }
  locally_update_node(t) {
    this.syncManager.locally_update_node(t);
  }
  set_io_value({
    nid: t,
    ioid: n,
    value: r,
    set_default: o = !1
  }) {
    return this.communicationManager._send_cmd({
      cmd: "set_io_value",
      kwargs: { nid: t, ioid: n, value: r, set_default: o },
      wait_for_response: !0
    });
  }
  set_io_value_options({
    nid: t,
    ioid: n,
    values: r,
    keys: o,
    nullable: a
  }) {
    return this.communicationManager._send_cmd({
      cmd: "update_io_value_options",
      kwargs: {
        nid: t,
        ioid: n,
        options: {
          options: {
            type: "enum",
            values: r,
            keys: o,
            nullable: a
          }
        }
      }
    });
  }
  async get_io_value({ nid: t, ioid: n }) {
    const r = await this.communicationManager._send_cmd({
      cmd: "get_io_value",
      kwargs: { nid: t, ioid: n },
      wait_for_response: !0
    });
    return this.context.worker._zustand && this.context.worker._zustand.on_node_action({
      type: "update",
      node: {
        io: {
          [n]: {
            value: r
          }
        }
      },
      id: t,
      from_remote: !0
    }), r;
  }
  async get_ios_values({ nid: t }) {
    const n = await this.communicationManager._send_cmd({
      cmd: "get_ios_values",
      kwargs: { nid: t },
      wait_for_response: !0
    });
    if (!this.context.worker._zustand) return n;
    const r = {};
    for (const o in n)
      r[o] = { value: n[o] };
    return this.context.worker._zustand.on_node_action({
      type: "update",
      node: {
        io: r
      },
      id: t,
      from_remote: !0
    }), n;
  }
  async get_io_full_value({ nid: t, ioid: n }) {
    const r = await this.communicationManager._send_cmd({
      cmd: "get_io_full_value",
      kwargs: { nid: t, ioid: n },
      wait_for_response: !0,
      as_bytes: !0
    }), { header: o, bytes: a } = r, { mime: s } = o, u = l3({
      data: a,
      mime: s || "application/octet-stream"
    });
    return this.context.worker._zustand?.on_node_action?.({
      type: "update",
      node: {
        id: t,
        io: {
          [n]: {
            fullvalue: u
          }
        }
      },
      id: t,
      from_remote: !0
    }), u;
  }
  async update_io_options({
    nid: t,
    ioid: n,
    options: r
  }) {
    const o = await this.communicationManager._send_cmd({
      cmd: "update_io_options",
      kwargs: { nid: t, ioid: n, ...r },
      wait_for_response: !0
    });
    if (!this.context.worker._zustand) return o;
    this.context.worker._zustand.on_node_action({
      type: "update",
      node: {
        io: {
          [n]: {
            ...r
          }
        }
      },
      id: t,
      from_remote: !0
    });
  }
  async get_node_status(t) {
    return await this.communicationManager._send_cmd({
      cmd: "get_node_state",
      kwargs: { nid: t },
      wait_for_response: !0
    });
  }
  async get_remote_node_state(t) {
    const n = await this.communicationManager._send_cmd({
      cmd: "get_node_state",
      kwargs: { nid: t },
      wait_for_response: !0
    });
    this.context.worker._zustand && this.context.worker._zustand.on_node_action({
      type: "update",
      node: n,
      id: n.id,
      from_remote: !0
    });
  }
}
class BX extends di {
  start() {
  }
  stop() {
  }
  add_edge({
    src_nid: t,
    src_ioid: n,
    trg_nid: r,
    trg_ioid: o,
    replace: a = !1
  }) {
    return this.communicationManager._send_cmd({
      cmd: "add_edge",
      kwargs: { src_nid: t, src_ioid: n, trg_nid: r, trg_ioid: o, replace: a }
    });
  }
  remove_edge({
    src_nid: t,
    src_ioid: n,
    trg_nid: r,
    trg_ioid: o
  }) {
    return this.communicationManager._send_cmd({
      cmd: "remove_edge",
      kwargs: { src_nid: t, src_ioid: n, trg_nid: r, trg_ioid: o }
    });
  }
}
class HX extends di {
  start() {
  }
  stop() {
  }
  async group_nodes(t, n) {
    const r = await this.communicationManager._send_cmd({
      cmd: "group_nodes",
      kwargs: { node_ids: t, group_ids: n },
      wait_for_response: !0
    });
    return this.eventManager._receive_groups(r), r;
  }
  async remove_group(t) {
    await this.communicationManager._send_cmd({
      cmd: "remove_group",
      kwargs: { gid: t },
      wait_for_response: !0
    }), await this.syncManager.sync_nodespace();
  }
  locally_update_group(t) {
    this.syncManager.locally_update_group(t);
  }
}
class VX extends di {
  start() {
  }
  stop() {
  }
  async add_external_worker({
    module: t,
    cls_module: n,
    cls_name: r
  }) {
    return await this.communicationManager._send_cmd({
      cmd: "add_external_worker",
      kwargs: { module: t, cls_module: n, cls_name: r }
    });
  }
  async add_lib(t, n) {
    return await this.communicationManager._send_cmd({
      cmd: "add_package_dependency",
      kwargs: { name: t, version: n },
      wait_for_response: !1
    });
  }
  async remove_lib(t) {
    return await this.communicationManager._send_cmd({
      cmd: "remove_package_dependency",
      kwargs: { name: t },
      wait_for_response: !1
    });
  }
  async get_available_modules() {
    return await this.communicationManager._send_cmd({
      cmd: "get_available_modules",
      wait_for_response: !0,
      unique: !0
    });
  }
  async remove_external_worker(t, n) {
    return await this.communicationManager._send_cmd({
      cmd: "remove_external_worker",
      kwargs: { worker_id: t, class_id: n },
      wait_for_response: !0
    });
  }
}
class UX {
  // Public getter for handlers to access eventManager
  getEventManager() {
    return this._eventManager;
  }
  getSyncManager() {
    return this._syncManager;
  }
  getCommunicationManager() {
    return this._communicationManager;
  }
  getConnectionHealthManager() {
    return this._connectionhealthManager;
  }
  getHookManager() {
    return this._hookManager;
  }
  getNodeManager() {
    return this._nodeManager;
  }
  getEdgeManager() {
    return this._edgeManager;
  }
  getGroupManager() {
    return this._groupManager;
  }
  getLibraryManager() {
    return this._libraryManager;
  }
  constructor(t) {
    this.uuid = t.uuid, this.on_error = t.on_error || ((r) => {
      this._zustand?.logger.error(r);
    }), this.state = Er((r, o) => ({
      is_open: !1
    }));
    const n = { worker: this };
    this._connectionhealthManager = new jX(
      n
    ), this._communicationManager = new zX(n), this._eventManager = new LX({
      ...n
    }), this._syncManager = new PX({
      ...n,
      on_sync_complete: t.on_sync_complete
    }), this._hookManager = new FX(n), this._nodeManager = new $X(n), this._edgeManager = new BX(n), this._groupManager = new HX(n), this._libraryManager = new VX(n), this._communicationManager.start(), this._connectionhealthManager.start(), this._syncManager.start(), this._eventManager.start(), this._hookManager.start(), this._nodeManager.start(), this._edgeManager.start(), this._groupManager.start(), this._libraryManager.start(), t.zustand && this.set_zustand(t.zustand), this.api = {
      node: this._nodeManager,
      group: this._groupManager,
      edge: this._edgeManager,
      hooks: this._hookManager,
      lib: this._libraryManager
    };
  }
  set_zustand(t) {
    t !== this._zustand && (t.logger.debug("Setting zustand for worker"), this._zustand = t, t.set_worker(this), this._zustand.auto_progress(), this._syncManager.stepwise_fullsync());
  }
  get is_open() {
    return this.state.getState().is_open;
  }
  set is_open(t) {
    this.state.setState({ is_open: t });
  }
  get is_responsive() {
    return this._connectionhealthManager.isResponsive();
  }
  clear() {
    return this._communicationManager._send_cmd({ cmd: "clear", unique: !0 });
  }
  save() {
    return this._communicationManager._send_cmd({
      cmd: "save",
      wait_for_response: !0,
      unique: !0
    });
  }
  load(t) {
    return this._communicationManager._send_cmd({
      cmd: "load_data",
      kwargs: { data: t },
      wait_for_response: !0
    }).then(() => {
      this._syncManager.stepwise_fullsync();
    });
  }
  async get_runstate() {
    return await this._communicationManager._send_cmd({
      cmd: "get_runstate",
      wait_for_response: !0,
      unique: !0
    });
  }
  async send(t) {
    throw new Error("async send(data: any)  not implemented");
  }
  async upload_file(t) {
    throw new Error("upload_file not implemented ");
  }
  async handle_large_message_hint({}) {
    throw new Error(
      "async handle_large_message_hint({}: LargeMessageHint) not implemented "
    );
  }
  disconnect() {
  }
  onclose() {
    this.is_open = !1, this._zustand && this._zustand.auto_progress();
  }
  async reconnect() {
  }
  async stop() {
    await this._communicationManager._send_cmd({
      cmd: "stop_worker",
      wait_for_response: !1
    });
    const t = this.onclose.bind(this);
    this.onclose = () => {
      t(), this._zustand && (this._zustand.worker === this && this._zustand.clear_all(), this.onclose = t);
    };
  }
  async update_external_worker(t, n, r) {
    return await this._communicationManager._send_cmd({
      cmd: "update_external_worker",
      kwargs: { worker_id: t, class_id: n, ...r },
      wait_for_response: !0
    });
  }
  async export({ withFiles: t = !1 }) {
    return await this._communicationManager._send_cmd({
      cmd: "export_worker",
      wait_for_response: !0,
      kwargs: { with_files: t }
    });
  }
  async update_from_export(t) {
    const n = this._hookManager.add_hook("node_added", async ({}) => {
      this._zustand?.center_all();
    });
    try {
      const r = await this._communicationManager._send_cmd({
        cmd: "update_from_export",
        kwargs: { data: t },
        wait_for_response: !0,
        response_timeout: 6e5,
        // 10 minutes
        unique: !0
      });
      return await new Promise((o) => {
        setTimeout(() => {
          o();
        }, 1e3);
      }), await this._syncManager.stepwise_fullsync(), r;
    } finally {
      n();
    }
  }
  /**
   * @deprecated This method is deprecated. Use the API or getCommunicationManager()._send_cmd directly instead.
   */
  _send_cmd(t) {
    return this._communicationManager._send_cmd(t);
  }
  /**
   * @deprecated This method is deprecated. Use the API or getNodeManager().set_io_value directly instead.
   */
  set_io_value(t) {
    return this._nodeManager.set_io_value(t);
  }
  /**
   * @deprecated This method is deprecated. Use the API or getNodeManager().get_io_value directly instead.
   */
  get_io_value(t) {
    return this._nodeManager.get_io_value(t);
  }
}
function u3(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: qX } = Object.prototype, { getPrototypeOf: yx } = Object, { iterator: Em, toStringTag: c3 } = Symbol, Cm = /* @__PURE__ */ ((e) => (t) => {
  const n = qX.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Vr = (e) => (e = e.toLowerCase(), (t) => Cm(t) === e), km = (e) => (t) => typeof t === e, { isArray: Bl } = Array, $c = km("undefined");
function hf(e) {
  return e !== null && !$c(e) && e.constructor !== null && !$c(e.constructor) && Fn(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const f3 = Vr("ArrayBuffer");
function GX(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && f3(e.buffer), t;
}
const YX = km("string"), Fn = km("function"), d3 = km("number"), pf = (e) => e !== null && typeof e == "object", WX = (e) => e === !0 || e === !1, Hh = (e) => {
  if (Cm(e) !== "object")
    return !1;
  const t = yx(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(c3 in e) && !(Em in e);
}, XX = (e) => {
  if (!pf(e) || hf(e))
    return !1;
  try {
    return Object.keys(e).length === 0 && Object.getPrototypeOf(e) === Object.prototype;
  } catch {
    return !1;
  }
}, KX = Vr("Date"), ZX = Vr("File"), QX = Vr("Blob"), JX = Vr("FileList"), eK = (e) => pf(e) && Fn(e.pipe), tK = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || Fn(e.append) && ((t = Cm(e)) === "formdata" || // detect form-data instance
  t === "object" && Fn(e.toString) && e.toString() === "[object FormData]"));
}, nK = Vr("URLSearchParams"), [rK, oK, iK, aK] = ["ReadableStream", "Request", "Response", "Headers"].map(Vr), sK = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function mf(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let r, o;
  if (typeof e != "object" && (e = [e]), Bl(e))
    for (r = 0, o = e.length; r < o; r++)
      t.call(null, e[r], r, e);
  else {
    if (hf(e))
      return;
    const a = n ? Object.getOwnPropertyNames(e) : Object.keys(e), s = a.length;
    let u;
    for (r = 0; r < s; r++)
      u = a[r], t.call(null, e[u], u, e);
  }
}
function h3(e, t) {
  if (hf(e))
    return null;
  t = t.toLowerCase();
  const n = Object.keys(e);
  let r = n.length, o;
  for (; r-- > 0; )
    if (o = n[r], t === o.toLowerCase())
      return o;
  return null;
}
const Ia = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : window, p3 = (e) => !$c(e) && e !== Ia;
function Eb() {
  const { caseless: e } = p3(this) && this || {}, t = {}, n = (r, o) => {
    const a = e && h3(t, o) || o;
    Hh(t[a]) && Hh(r) ? t[a] = Eb(t[a], r) : Hh(r) ? t[a] = Eb({}, r) : Bl(r) ? t[a] = r.slice() : t[a] = r;
  };
  for (let r = 0, o = arguments.length; r < o; r++)
    arguments[r] && mf(arguments[r], n);
  return t;
}
const lK = (e, t, n, { allOwnKeys: r } = {}) => (mf(t, (o, a) => {
  n && Fn(o) ? e[a] = u3(o, n) : e[a] = o;
}, { allOwnKeys: r }), e), uK = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), cK = (e, t, n, r) => {
  e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, fK = (e, t, n, r) => {
  let o, a, s;
  const u = {};
  if (t = t || {}, e == null) return t;
  do {
    for (o = Object.getOwnPropertyNames(e), a = o.length; a-- > 0; )
      s = o[a], (!r || r(s, e, t)) && !u[s] && (t[s] = e[s], u[s] = !0);
    e = n !== !1 && yx(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, dK = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const r = e.indexOf(t, n);
  return r !== -1 && r === n;
}, hK = (e) => {
  if (!e) return null;
  if (Bl(e)) return e;
  let t = e.length;
  if (!d3(t)) return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, pK = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && yx(Uint8Array)), mK = (e, t) => {
  const r = (e && e[Em]).call(e);
  let o;
  for (; (o = r.next()) && !o.done; ) {
    const a = o.value;
    t.call(e, a[0], a[1]);
  }
}, gK = (e, t) => {
  let n;
  const r = [];
  for (; (n = e.exec(t)) !== null; )
    r.push(n);
  return r;
}, yK = Vr("HTMLFormElement"), vK = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, r, o) {
    return r.toUpperCase() + o;
  }
), VT = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), bK = Vr("RegExp"), m3 = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), r = {};
  mf(n, (o, a) => {
    let s;
    (s = t(o, a, e)) !== !1 && (r[a] = s || o);
  }), Object.defineProperties(e, r);
}, xK = (e) => {
  m3(e, (t, n) => {
    if (Fn(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = e[n];
    if (Fn(r)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, wK = (e, t) => {
  const n = {}, r = (o) => {
    o.forEach((a) => {
      n[a] = !0;
    });
  };
  return Bl(e) ? r(e) : r(String(e).split(t)), n;
}, _K = () => {
}, SK = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
function EK(e) {
  return !!(e && Fn(e.append) && e[c3] === "FormData" && e[Em]);
}
const CK = (e) => {
  const t = new Array(10), n = (r, o) => {
    if (pf(r)) {
      if (t.indexOf(r) >= 0)
        return;
      if (hf(r))
        return r;
      if (!("toJSON" in r)) {
        t[o] = r;
        const a = Bl(r) ? [] : {};
        return mf(r, (s, u) => {
          const c = n(s, o + 1);
          !$c(c) && (a[u] = c);
        }), t[o] = void 0, a;
      }
    }
    return r;
  };
  return n(e, 0);
}, kK = Vr("AsyncFunction"), TK = (e) => e && (pf(e) || Fn(e)) && Fn(e.then) && Fn(e.catch), g3 = ((e, t) => e ? setImmediate : t ? ((n, r) => (Ia.addEventListener("message", ({ source: o, data: a }) => {
  o === Ia && a === n && r.length && r.shift()();
}, !1), (o) => {
  r.push(o), Ia.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  Fn(Ia.postMessage)
), AK = typeof queueMicrotask < "u" ? queueMicrotask.bind(Ia) : typeof process < "u" && process.nextTick || g3, RK = (e) => e != null && Fn(e[Em]), ie = {
  isArray: Bl,
  isArrayBuffer: f3,
  isBuffer: hf,
  isFormData: tK,
  isArrayBufferView: GX,
  isString: YX,
  isNumber: d3,
  isBoolean: WX,
  isObject: pf,
  isPlainObject: Hh,
  isEmptyObject: XX,
  isReadableStream: rK,
  isRequest: oK,
  isResponse: iK,
  isHeaders: aK,
  isUndefined: $c,
  isDate: KX,
  isFile: ZX,
  isBlob: QX,
  isRegExp: bK,
  isFunction: Fn,
  isStream: eK,
  isURLSearchParams: nK,
  isTypedArray: pK,
  isFileList: JX,
  forEach: mf,
  merge: Eb,
  extend: lK,
  trim: sK,
  stripBOM: uK,
  inherits: cK,
  toFlatObject: fK,
  kindOf: Cm,
  kindOfTest: Vr,
  endsWith: dK,
  toArray: hK,
  forEachEntry: mK,
  matchAll: gK,
  isHTMLForm: yK,
  hasOwnProperty: VT,
  hasOwnProp: VT,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: m3,
  freezeMethods: xK,
  toObjectSet: wK,
  toCamelCase: vK,
  noop: _K,
  toFiniteNumber: SK,
  findKey: h3,
  global: Ia,
  isContextDefined: p3,
  isSpecCompliantForm: EK,
  toJSONObject: CK,
  isAsyncFn: kK,
  isThenable: TK,
  setImmediate: g3,
  asap: AK,
  isIterable: RK
};
function Fe(e, t, n, r, o) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), o && (this.response = o, this.status = o.status ? o.status : null);
}
ie.inherits(Fe, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: ie.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const y3 = Fe.prototype, v3 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  v3[e] = { value: e };
});
Object.defineProperties(Fe, v3);
Object.defineProperty(y3, "isAxiosError", { value: !0 });
Fe.from = (e, t, n, r, o, a) => {
  const s = Object.create(y3);
  return ie.toFlatObject(e, s, function(c) {
    return c !== Error.prototype;
  }, (u) => u !== "isAxiosError"), Fe.call(s, e.message, t, n, r, o), s.cause = e, s.name = e.name, a && Object.assign(s, a), s;
};
const MK = null;
function Cb(e) {
  return ie.isPlainObject(e) || ie.isArray(e);
}
function b3(e) {
  return ie.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function UT(e, t, n) {
  return e ? e.concat(t).map(function(o, a) {
    return o = b3(o), !n && a ? "[" + o + "]" : o;
  }).join(n ? "." : "") : t;
}
function OK(e) {
  return ie.isArray(e) && !e.some(Cb);
}
const NK = ie.toFlatObject(ie, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function Tm(e, t, n) {
  if (!ie.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), n = ie.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(v, S) {
    return !ie.isUndefined(S[v]);
  });
  const r = n.metaTokens, o = n.visitor || h, a = n.dots, s = n.indexes, c = (n.Blob || typeof Blob < "u" && Blob) && ie.isSpecCompliantForm(t);
  if (!ie.isFunction(o))
    throw new TypeError("visitor must be a function");
  function f(w) {
    if (w === null) return "";
    if (ie.isDate(w))
      return w.toISOString();
    if (ie.isBoolean(w))
      return w.toString();
    if (!c && ie.isBlob(w))
      throw new Fe("Blob is not supported. Use a Buffer instead.");
    return ie.isArrayBuffer(w) || ie.isTypedArray(w) ? c && typeof Blob == "function" ? new Blob([w]) : Buffer.from(w) : w;
  }
  function h(w, v, S) {
    let E = w;
    if (w && !S && typeof w == "object") {
      if (ie.endsWith(v, "{}"))
        v = r ? v : v.slice(0, -2), w = JSON.stringify(w);
      else if (ie.isArray(w) && OK(w) || (ie.isFileList(w) || ie.endsWith(v, "[]")) && (E = ie.toArray(w)))
        return v = b3(v), E.forEach(function(k, T) {
          !(ie.isUndefined(k) || k === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            s === !0 ? UT([v], T, a) : s === null ? v : v + "[]",
            f(k)
          );
        }), !1;
    }
    return Cb(w) ? !0 : (t.append(UT(S, v, a), f(w)), !1);
  }
  const p = [], g = Object.assign(NK, {
    defaultVisitor: h,
    convertValue: f,
    isVisitable: Cb
  });
  function y(w, v) {
    if (!ie.isUndefined(w)) {
      if (p.indexOf(w) !== -1)
        throw Error("Circular reference detected in " + v.join("."));
      p.push(w), ie.forEach(w, function(E, A) {
        (!(ie.isUndefined(E) || E === null) && o.call(
          t,
          E,
          ie.isString(A) ? A.trim() : A,
          v,
          g
        )) === !0 && y(E, v ? v.concat(A) : [A]);
      }), p.pop();
    }
  }
  if (!ie.isObject(e))
    throw new TypeError("data must be an object");
  return y(e), t;
}
function qT(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
    return t[r];
  });
}
function vx(e, t) {
  this._pairs = [], e && Tm(e, this, t);
}
const x3 = vx.prototype;
x3.append = function(t, n) {
  this._pairs.push([t, n]);
};
x3.toString = function(t) {
  const n = t ? function(r) {
    return t.call(this, r, qT);
  } : qT;
  return this._pairs.map(function(o) {
    return n(o[0]) + "=" + n(o[1]);
  }, "").join("&");
};
function DK(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function w3(e, t, n) {
  if (!t)
    return e;
  const r = n && n.encode || DK;
  ie.isFunction(n) && (n = {
    serialize: n
  });
  const o = n && n.serialize;
  let a;
  if (o ? a = o(t, n) : a = ie.isURLSearchParams(t) ? t.toString() : new vx(t, n).toString(r), a) {
    const s = e.indexOf("#");
    s !== -1 && (e = e.slice(0, s)), e += (e.indexOf("?") === -1 ? "?" : "&") + a;
  }
  return e;
}
class GT {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, r) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    ie.forEach(this.handlers, function(r) {
      r !== null && t(r);
    });
  }
}
const _3 = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, jK = typeof URLSearchParams < "u" ? URLSearchParams : vx, PK = typeof FormData < "u" ? FormData : null, IK = typeof Blob < "u" ? Blob : null, zK = {
  isBrowser: !0,
  classes: {
    URLSearchParams: jK,
    FormData: PK,
    Blob: IK
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, bx = typeof window < "u" && typeof document < "u", kb = typeof navigator == "object" && navigator || void 0, LK = bx && (!kb || ["ReactNative", "NativeScript", "NS"].indexOf(kb.product) < 0), FK = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", $K = bx && window.location.href || "http://localhost", BK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: bx,
  hasStandardBrowserEnv: LK,
  hasStandardBrowserWebWorkerEnv: FK,
  navigator: kb,
  origin: $K
}, Symbol.toStringTag, { value: "Module" })), yn = {
  ...BK,
  ...zK
};
function HK(e, t) {
  return Tm(e, new yn.classes.URLSearchParams(), {
    visitor: function(n, r, o, a) {
      return yn.isNode && ie.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : a.defaultVisitor.apply(this, arguments);
    },
    ...t
  });
}
function VK(e) {
  return ie.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function UK(e) {
  const t = {}, n = Object.keys(e);
  let r;
  const o = n.length;
  let a;
  for (r = 0; r < o; r++)
    a = n[r], t[a] = e[a];
  return t;
}
function S3(e) {
  function t(n, r, o, a) {
    let s = n[a++];
    if (s === "__proto__") return !0;
    const u = Number.isFinite(+s), c = a >= n.length;
    return s = !s && ie.isArray(o) ? o.length : s, c ? (ie.hasOwnProp(o, s) ? o[s] = [o[s], r] : o[s] = r, !u) : ((!o[s] || !ie.isObject(o[s])) && (o[s] = []), t(n, r, o[s], a) && ie.isArray(o[s]) && (o[s] = UK(o[s])), !u);
  }
  if (ie.isFormData(e) && ie.isFunction(e.entries)) {
    const n = {};
    return ie.forEachEntry(e, (r, o) => {
      t(VK(r), o, n, 0);
    }), n;
  }
  return null;
}
function qK(e, t, n) {
  if (ie.isString(e))
    try {
      return (t || JSON.parse)(e), ie.trim(e);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(e);
}
const gf = {
  transitional: _3,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, n) {
    const r = n.getContentType() || "", o = r.indexOf("application/json") > -1, a = ie.isObject(t);
    if (a && ie.isHTMLForm(t) && (t = new FormData(t)), ie.isFormData(t))
      return o ? JSON.stringify(S3(t)) : t;
    if (ie.isArrayBuffer(t) || ie.isBuffer(t) || ie.isStream(t) || ie.isFile(t) || ie.isBlob(t) || ie.isReadableStream(t))
      return t;
    if (ie.isArrayBufferView(t))
      return t.buffer;
    if (ie.isURLSearchParams(t))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let u;
    if (a) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return HK(t, this.formSerializer).toString();
      if ((u = ie.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
        const c = this.env && this.env.FormData;
        return Tm(
          u ? { "files[]": t } : t,
          c && new c(),
          this.formSerializer
        );
      }
    }
    return a || o ? (n.setContentType("application/json", !1), qK(t)) : t;
  }],
  transformResponse: [function(t) {
    const n = this.transitional || gf.transitional, r = n && n.forcedJSONParsing, o = this.responseType === "json";
    if (ie.isResponse(t) || ie.isReadableStream(t))
      return t;
    if (t && ie.isString(t) && (r && !this.responseType || o)) {
      const s = !(n && n.silentJSONParsing) && o;
      try {
        return JSON.parse(t);
      } catch (u) {
        if (s)
          throw u.name === "SyntaxError" ? Fe.from(u, Fe.ERR_BAD_RESPONSE, this, null, this.response) : u;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: yn.classes.FormData,
    Blob: yn.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
ie.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  gf.headers[e] = {};
});
const GK = ie.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), YK = (e) => {
  const t = {};
  let n, r, o;
  return e && e.split(`
`).forEach(function(s) {
    o = s.indexOf(":"), n = s.substring(0, o).trim().toLowerCase(), r = s.substring(o + 1).trim(), !(!n || t[n] && GK[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
  }), t;
}, YT = Symbol("internals");
function oc(e) {
  return e && String(e).trim().toLowerCase();
}
function Vh(e) {
  return e === !1 || e == null ? e : ie.isArray(e) ? e.map(Vh) : String(e);
}
function WK(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(e); )
    t[r[1]] = r[2];
  return t;
}
const XK = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function lv(e, t, n, r, o) {
  if (ie.isFunction(r))
    return r.call(this, t, n);
  if (o && (t = n), !!ie.isString(t)) {
    if (ie.isString(r))
      return t.indexOf(r) !== -1;
    if (ie.isRegExp(r))
      return r.test(t);
  }
}
function KK(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
}
function ZK(e, t) {
  const n = ie.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(e, r + n, {
      value: function(o, a, s) {
        return this[r].call(this, t, o, a, s);
      },
      configurable: !0
    });
  });
}
let $n = class {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, r) {
    const o = this;
    function a(u, c, f) {
      const h = oc(c);
      if (!h)
        throw new Error("header name must be a non-empty string");
      const p = ie.findKey(o, h);
      (!p || o[p] === void 0 || f === !0 || f === void 0 && o[p] !== !1) && (o[p || c] = Vh(u));
    }
    const s = (u, c) => ie.forEach(u, (f, h) => a(f, h, c));
    if (ie.isPlainObject(t) || t instanceof this.constructor)
      s(t, n);
    else if (ie.isString(t) && (t = t.trim()) && !XK(t))
      s(YK(t), n);
    else if (ie.isObject(t) && ie.isIterable(t)) {
      let u = {}, c, f;
      for (const h of t) {
        if (!ie.isArray(h))
          throw TypeError("Object iterator must return a key-value pair");
        u[f = h[0]] = (c = u[f]) ? ie.isArray(c) ? [...c, h[1]] : [c, h[1]] : h[1];
      }
      s(u, n);
    } else
      t != null && a(n, t, r);
    return this;
  }
  get(t, n) {
    if (t = oc(t), t) {
      const r = ie.findKey(this, t);
      if (r) {
        const o = this[r];
        if (!n)
          return o;
        if (n === !0)
          return WK(o);
        if (ie.isFunction(n))
          return n.call(this, o, r);
        if (ie.isRegExp(n))
          return n.exec(o);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, n) {
    if (t = oc(t), t) {
      const r = ie.findKey(this, t);
      return !!(r && this[r] !== void 0 && (!n || lv(this, this[r], r, n)));
    }
    return !1;
  }
  delete(t, n) {
    const r = this;
    let o = !1;
    function a(s) {
      if (s = oc(s), s) {
        const u = ie.findKey(r, s);
        u && (!n || lv(r, r[u], u, n)) && (delete r[u], o = !0);
      }
    }
    return ie.isArray(t) ? t.forEach(a) : a(t), o;
  }
  clear(t) {
    const n = Object.keys(this);
    let r = n.length, o = !1;
    for (; r--; ) {
      const a = n[r];
      (!t || lv(this, this[a], a, t, !0)) && (delete this[a], o = !0);
    }
    return o;
  }
  normalize(t) {
    const n = this, r = {};
    return ie.forEach(this, (o, a) => {
      const s = ie.findKey(r, a);
      if (s) {
        n[s] = Vh(o), delete n[a];
        return;
      }
      const u = t ? KK(a) : String(a).trim();
      u !== a && delete n[a], n[u] = Vh(o), r[u] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const n = /* @__PURE__ */ Object.create(null);
    return ie.forEach(this, (r, o) => {
      r != null && r !== !1 && (n[o] = t && ie.isArray(r) ? r.join(", ") : r);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...n) {
    const r = new this(t);
    return n.forEach((o) => r.set(o)), r;
  }
  static accessor(t) {
    const r = (this[YT] = this[YT] = {
      accessors: {}
    }).accessors, o = this.prototype;
    function a(s) {
      const u = oc(s);
      r[u] || (ZK(o, s), r[u] = !0);
    }
    return ie.isArray(t) ? t.forEach(a) : a(t), this;
  }
};
$n.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
ie.reduceDescriptors($n.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(r) {
      this[n] = r;
    }
  };
});
ie.freezeMethods($n);
function uv(e, t) {
  const n = this || gf, r = t || n, o = $n.from(r.headers);
  let a = r.data;
  return ie.forEach(e, function(u) {
    a = u.call(n, a, o.normalize(), t ? t.status : void 0);
  }), o.normalize(), a;
}
function E3(e) {
  return !!(e && e.__CANCEL__);
}
function Hl(e, t, n) {
  Fe.call(this, e ?? "canceled", Fe.ERR_CANCELED, t, n), this.name = "CanceledError";
}
ie.inherits(Hl, Fe, {
  __CANCEL__: !0
});
function C3(e, t, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? e(n) : t(new Fe(
    "Request failed with status code " + n.status,
    [Fe.ERR_BAD_REQUEST, Fe.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function QK(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function JK(e, t) {
  e = e || 10;
  const n = new Array(e), r = new Array(e);
  let o = 0, a = 0, s;
  return t = t !== void 0 ? t : 1e3, function(c) {
    const f = Date.now(), h = r[a];
    s || (s = f), n[o] = c, r[o] = f;
    let p = a, g = 0;
    for (; p !== o; )
      g += n[p++], p = p % e;
    if (o = (o + 1) % e, o === a && (a = (a + 1) % e), f - s < t)
      return;
    const y = h && f - h;
    return y ? Math.round(g * 1e3 / y) : void 0;
  };
}
function eZ(e, t) {
  let n = 0, r = 1e3 / t, o, a;
  const s = (f, h = Date.now()) => {
    n = h, o = null, a && (clearTimeout(a), a = null), e(...f);
  };
  return [(...f) => {
    const h = Date.now(), p = h - n;
    p >= r ? s(f, h) : (o = f, a || (a = setTimeout(() => {
      a = null, s(o);
    }, r - p)));
  }, () => o && s(o)];
}
const gp = (e, t, n = 3) => {
  let r = 0;
  const o = JK(50, 250);
  return eZ((a) => {
    const s = a.loaded, u = a.lengthComputable ? a.total : void 0, c = s - r, f = o(c), h = s <= u;
    r = s;
    const p = {
      loaded: s,
      total: u,
      progress: u ? s / u : void 0,
      bytes: c,
      rate: f || void 0,
      estimated: f && u && h ? (u - s) / f : void 0,
      event: a,
      lengthComputable: u != null,
      [t ? "download" : "upload"]: !0
    };
    e(p);
  }, n);
}, WT = (e, t) => {
  const n = e != null;
  return [(r) => t[0]({
    lengthComputable: n,
    total: e,
    loaded: r
  }), t[1]];
}, XT = (e) => (...t) => ie.asap(() => e(...t)), tZ = yn.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t) => (n) => (n = new URL(n, yn.origin), e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(
  new URL(yn.origin),
  yn.navigator && /(msie|trident)/i.test(yn.navigator.userAgent)
) : () => !0, nZ = yn.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, n, r, o, a) {
      const s = [e + "=" + encodeURIComponent(t)];
      ie.isNumber(n) && s.push("expires=" + new Date(n).toGMTString()), ie.isString(r) && s.push("path=" + r), ie.isString(o) && s.push("domain=" + o), a === !0 && s.push("secure"), document.cookie = s.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function rZ(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function oZ(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function k3(e, t, n) {
  let r = !rZ(t);
  return e && (r || n == !1) ? oZ(e, t) : t;
}
const KT = (e) => e instanceof $n ? { ...e } : e;
function Xa(e, t) {
  t = t || {};
  const n = {};
  function r(f, h, p, g) {
    return ie.isPlainObject(f) && ie.isPlainObject(h) ? ie.merge.call({ caseless: g }, f, h) : ie.isPlainObject(h) ? ie.merge({}, h) : ie.isArray(h) ? h.slice() : h;
  }
  function o(f, h, p, g) {
    if (ie.isUndefined(h)) {
      if (!ie.isUndefined(f))
        return r(void 0, f, p, g);
    } else return r(f, h, p, g);
  }
  function a(f, h) {
    if (!ie.isUndefined(h))
      return r(void 0, h);
  }
  function s(f, h) {
    if (ie.isUndefined(h)) {
      if (!ie.isUndefined(f))
        return r(void 0, f);
    } else return r(void 0, h);
  }
  function u(f, h, p) {
    if (p in t)
      return r(f, h);
    if (p in e)
      return r(void 0, f);
  }
  const c = {
    url: a,
    method: a,
    data: a,
    baseURL: s,
    transformRequest: s,
    transformResponse: s,
    paramsSerializer: s,
    timeout: s,
    timeoutMessage: s,
    withCredentials: s,
    withXSRFToken: s,
    adapter: s,
    responseType: s,
    xsrfCookieName: s,
    xsrfHeaderName: s,
    onUploadProgress: s,
    onDownloadProgress: s,
    decompress: s,
    maxContentLength: s,
    maxBodyLength: s,
    beforeRedirect: s,
    transport: s,
    httpAgent: s,
    httpsAgent: s,
    cancelToken: s,
    socketPath: s,
    responseEncoding: s,
    validateStatus: u,
    headers: (f, h, p) => o(KT(f), KT(h), p, !0)
  };
  return ie.forEach(Object.keys({ ...e, ...t }), function(h) {
    const p = c[h] || o, g = p(e[h], t[h], h);
    ie.isUndefined(g) && p !== u || (n[h] = g);
  }), n;
}
const T3 = (e) => {
  const t = Xa({}, e);
  let { data: n, withXSRFToken: r, xsrfHeaderName: o, xsrfCookieName: a, headers: s, auth: u } = t;
  t.headers = s = $n.from(s), t.url = w3(k3(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), u && s.set(
    "Authorization",
    "Basic " + btoa((u.username || "") + ":" + (u.password ? unescape(encodeURIComponent(u.password)) : ""))
  );
  let c;
  if (ie.isFormData(n)) {
    if (yn.hasStandardBrowserEnv || yn.hasStandardBrowserWebWorkerEnv)
      s.setContentType(void 0);
    else if ((c = s.getContentType()) !== !1) {
      const [f, ...h] = c ? c.split(";").map((p) => p.trim()).filter(Boolean) : [];
      s.setContentType([f || "multipart/form-data", ...h].join("; "));
    }
  }
  if (yn.hasStandardBrowserEnv && (r && ie.isFunction(r) && (r = r(t)), r || r !== !1 && tZ(t.url))) {
    const f = o && a && nZ.read(a);
    f && s.set(o, f);
  }
  return t;
}, iZ = typeof XMLHttpRequest < "u", aZ = iZ && function(e) {
  return new Promise(function(n, r) {
    const o = T3(e);
    let a = o.data;
    const s = $n.from(o.headers).normalize();
    let { responseType: u, onUploadProgress: c, onDownloadProgress: f } = o, h, p, g, y, w;
    function v() {
      y && y(), w && w(), o.cancelToken && o.cancelToken.unsubscribe(h), o.signal && o.signal.removeEventListener("abort", h);
    }
    let S = new XMLHttpRequest();
    S.open(o.method.toUpperCase(), o.url, !0), S.timeout = o.timeout;
    function E() {
      if (!S)
        return;
      const k = $n.from(
        "getAllResponseHeaders" in S && S.getAllResponseHeaders()
      ), R = {
        data: !u || u === "text" || u === "json" ? S.responseText : S.response,
        status: S.status,
        statusText: S.statusText,
        headers: k,
        config: e,
        request: S
      };
      C3(function(j) {
        n(j), v();
      }, function(j) {
        r(j), v();
      }, R), S = null;
    }
    "onloadend" in S ? S.onloadend = E : S.onreadystatechange = function() {
      !S || S.readyState !== 4 || S.status === 0 && !(S.responseURL && S.responseURL.indexOf("file:") === 0) || setTimeout(E);
    }, S.onabort = function() {
      S && (r(new Fe("Request aborted", Fe.ECONNABORTED, e, S)), S = null);
    }, S.onerror = function() {
      r(new Fe("Network Error", Fe.ERR_NETWORK, e, S)), S = null;
    }, S.ontimeout = function() {
      let T = o.timeout ? "timeout of " + o.timeout + "ms exceeded" : "timeout exceeded";
      const R = o.transitional || _3;
      o.timeoutErrorMessage && (T = o.timeoutErrorMessage), r(new Fe(
        T,
        R.clarifyTimeoutError ? Fe.ETIMEDOUT : Fe.ECONNABORTED,
        e,
        S
      )), S = null;
    }, a === void 0 && s.setContentType(null), "setRequestHeader" in S && ie.forEach(s.toJSON(), function(T, R) {
      S.setRequestHeader(R, T);
    }), ie.isUndefined(o.withCredentials) || (S.withCredentials = !!o.withCredentials), u && u !== "json" && (S.responseType = o.responseType), f && ([g, w] = gp(f, !0), S.addEventListener("progress", g)), c && S.upload && ([p, y] = gp(c), S.upload.addEventListener("progress", p), S.upload.addEventListener("loadend", y)), (o.cancelToken || o.signal) && (h = (k) => {
      S && (r(!k || k.type ? new Hl(null, e, S) : k), S.abort(), S = null);
    }, o.cancelToken && o.cancelToken.subscribe(h), o.signal && (o.signal.aborted ? h() : o.signal.addEventListener("abort", h)));
    const A = QK(o.url);
    if (A && yn.protocols.indexOf(A) === -1) {
      r(new Fe("Unsupported protocol " + A + ":", Fe.ERR_BAD_REQUEST, e));
      return;
    }
    S.send(a || null);
  });
}, sZ = (e, t) => {
  const { length: n } = e = e ? e.filter(Boolean) : [];
  if (t || n) {
    let r = new AbortController(), o;
    const a = function(f) {
      if (!o) {
        o = !0, u();
        const h = f instanceof Error ? f : this.reason;
        r.abort(h instanceof Fe ? h : new Hl(h instanceof Error ? h.message : h));
      }
    };
    let s = t && setTimeout(() => {
      s = null, a(new Fe(`timeout ${t} of ms exceeded`, Fe.ETIMEDOUT));
    }, t);
    const u = () => {
      e && (s && clearTimeout(s), s = null, e.forEach((f) => {
        f.unsubscribe ? f.unsubscribe(a) : f.removeEventListener("abort", a);
      }), e = null);
    };
    e.forEach((f) => f.addEventListener("abort", a));
    const { signal: c } = r;
    return c.unsubscribe = () => ie.asap(u), c;
  }
}, lZ = function* (e, t) {
  let n = e.byteLength;
  if (n < t) {
    yield e;
    return;
  }
  let r = 0, o;
  for (; r < n; )
    o = r + t, yield e.slice(r, o), r = o;
}, uZ = async function* (e, t) {
  for await (const n of cZ(e))
    yield* lZ(n, t);
}, cZ = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: n, value: r } = await t.read();
      if (n)
        break;
      yield r;
    }
  } finally {
    await t.cancel();
  }
}, ZT = (e, t, n, r) => {
  const o = uZ(e, t);
  let a = 0, s, u = (c) => {
    s || (s = !0, r && r(c));
  };
  return new ReadableStream({
    async pull(c) {
      try {
        const { done: f, value: h } = await o.next();
        if (f) {
          u(), c.close();
          return;
        }
        let p = h.byteLength;
        if (n) {
          let g = a += p;
          n(g);
        }
        c.enqueue(new Uint8Array(h));
      } catch (f) {
        throw u(f), f;
      }
    },
    cancel(c) {
      return u(c), o.return();
    }
  }, {
    highWaterMark: 2
  });
}, Am = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", A3 = Am && typeof ReadableStream == "function", fZ = Am && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), R3 = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
}, dZ = A3 && R3(() => {
  let e = !1;
  const t = new Request(yn.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
}), QT = 64 * 1024, Tb = A3 && R3(() => ie.isReadableStream(new Response("").body)), yp = {
  stream: Tb && ((e) => e.body)
};
Am && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !yp[t] && (yp[t] = ie.isFunction(e[t]) ? (n) => n[t]() : (n, r) => {
      throw new Fe(`Response type '${t}' is not supported`, Fe.ERR_NOT_SUPPORT, r);
    });
  });
})(new Response());
const hZ = async (e) => {
  if (e == null)
    return 0;
  if (ie.isBlob(e))
    return e.size;
  if (ie.isSpecCompliantForm(e))
    return (await new Request(yn.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (ie.isArrayBufferView(e) || ie.isArrayBuffer(e))
    return e.byteLength;
  if (ie.isURLSearchParams(e) && (e = e + ""), ie.isString(e))
    return (await fZ(e)).byteLength;
}, pZ = async (e, t) => {
  const n = ie.toFiniteNumber(e.getContentLength());
  return n ?? hZ(t);
}, mZ = Am && (async (e) => {
  let {
    url: t,
    method: n,
    data: r,
    signal: o,
    cancelToken: a,
    timeout: s,
    onDownloadProgress: u,
    onUploadProgress: c,
    responseType: f,
    headers: h,
    withCredentials: p = "same-origin",
    fetchOptions: g
  } = T3(e);
  f = f ? (f + "").toLowerCase() : "text";
  let y = sZ([o, a && a.toAbortSignal()], s), w;
  const v = y && y.unsubscribe && (() => {
    y.unsubscribe();
  });
  let S;
  try {
    if (c && dZ && n !== "get" && n !== "head" && (S = await pZ(h, r)) !== 0) {
      let R = new Request(t, {
        method: "POST",
        body: r,
        duplex: "half"
      }), N;
      if (ie.isFormData(r) && (N = R.headers.get("content-type")) && h.setContentType(N), R.body) {
        const [j, z] = WT(
          S,
          gp(XT(c))
        );
        r = ZT(R.body, QT, j, z);
      }
    }
    ie.isString(p) || (p = p ? "include" : "omit");
    const E = "credentials" in Request.prototype;
    w = new Request(t, {
      ...g,
      signal: y,
      method: n.toUpperCase(),
      headers: h.normalize().toJSON(),
      body: r,
      duplex: "half",
      credentials: E ? p : void 0
    });
    let A = await fetch(w, g);
    const k = Tb && (f === "stream" || f === "response");
    if (Tb && (u || k && v)) {
      const R = {};
      ["status", "statusText", "headers"].forEach((B) => {
        R[B] = A[B];
      });
      const N = ie.toFiniteNumber(A.headers.get("content-length")), [j, z] = u && WT(
        N,
        gp(XT(u), !0)
      ) || [];
      A = new Response(
        ZT(A.body, QT, j, () => {
          z && z(), v && v();
        }),
        R
      );
    }
    f = f || "text";
    let T = await yp[ie.findKey(yp, f) || "text"](A, e);
    return !k && v && v(), await new Promise((R, N) => {
      C3(R, N, {
        data: T,
        headers: $n.from(A.headers),
        status: A.status,
        statusText: A.statusText,
        config: e,
        request: w
      });
    });
  } catch (E) {
    throw v && v(), E && E.name === "TypeError" && /Load failed|fetch/i.test(E.message) ? Object.assign(
      new Fe("Network Error", Fe.ERR_NETWORK, e, w),
      {
        cause: E.cause || E
      }
    ) : Fe.from(E, E && E.code, e, w);
  }
}), Ab = {
  http: MK,
  xhr: aZ,
  fetch: mZ
};
ie.forEach(Ab, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const JT = (e) => `- ${e}`, gZ = (e) => ie.isFunction(e) || e === null || e === !1, M3 = {
  getAdapter: (e) => {
    e = ie.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, r;
    const o = {};
    for (let a = 0; a < t; a++) {
      n = e[a];
      let s;
      if (r = n, !gZ(n) && (r = Ab[(s = String(n)).toLowerCase()], r === void 0))
        throw new Fe(`Unknown adapter '${s}'`);
      if (r)
        break;
      o[s || "#" + a] = r;
    }
    if (!r) {
      const a = Object.entries(o).map(
        ([u, c]) => `adapter ${u} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let s = t ? a.length > 1 ? `since :
` + a.map(JT).join(`
`) : " " + JT(a[0]) : "as no adapter specified";
      throw new Fe(
        "There is no suitable adapter to dispatch the request " + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return r;
  },
  adapters: Ab
};
function cv(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Hl(null, e);
}
function eA(e) {
  return cv(e), e.headers = $n.from(e.headers), e.data = uv.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), M3.getAdapter(e.adapter || gf.adapter)(e).then(function(r) {
    return cv(e), r.data = uv.call(
      e,
      e.transformResponse,
      r
    ), r.headers = $n.from(r.headers), r;
  }, function(r) {
    return E3(r) || (cv(e), r && r.response && (r.response.data = uv.call(
      e,
      e.transformResponse,
      r.response
    ), r.response.headers = $n.from(r.response.headers))), Promise.reject(r);
  });
}
const O3 = "1.11.0", Rm = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  Rm[e] = function(r) {
    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const tA = {};
Rm.transitional = function(t, n, r) {
  function o(a, s) {
    return "[Axios v" + O3 + "] Transitional option '" + a + "'" + s + (r ? ". " + r : "");
  }
  return (a, s, u) => {
    if (t === !1)
      throw new Fe(
        o(s, " has been removed" + (n ? " in " + n : "")),
        Fe.ERR_DEPRECATED
      );
    return n && !tA[s] && (tA[s] = !0, console.warn(
      o(
        s,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), t ? t(a, s, u) : !0;
  };
};
Rm.spelling = function(t) {
  return (n, r) => (console.warn(`${r} is likely a misspelling of ${t}`), !0);
};
function yZ(e, t, n) {
  if (typeof e != "object")
    throw new Fe("options must be an object", Fe.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(e);
  let o = r.length;
  for (; o-- > 0; ) {
    const a = r[o], s = t[a];
    if (s) {
      const u = e[a], c = u === void 0 || s(u, a, e);
      if (c !== !0)
        throw new Fe("option " + a + " must be " + c, Fe.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new Fe("Unknown option " + a, Fe.ERR_BAD_OPTION);
  }
}
const Uh = {
  assertOptions: yZ,
  validators: Rm
}, eo = Uh.validators;
let Fa = class {
  constructor(t) {
    this.defaults = t || {}, this.interceptors = {
      request: new GT(),
      response: new GT()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, n) {
    try {
      return await this._request(t, n);
    } catch (r) {
      if (r instanceof Error) {
        let o = {};
        Error.captureStackTrace ? Error.captureStackTrace(o) : o = new Error();
        const a = o.stack ? o.stack.replace(/^.+\n/, "") : "";
        try {
          r.stack ? a && !String(r.stack).endsWith(a.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + a) : r.stack = a;
        } catch {
        }
      }
      throw r;
    }
  }
  _request(t, n) {
    typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = Xa(this.defaults, n);
    const { transitional: r, paramsSerializer: o, headers: a } = n;
    r !== void 0 && Uh.assertOptions(r, {
      silentJSONParsing: eo.transitional(eo.boolean),
      forcedJSONParsing: eo.transitional(eo.boolean),
      clarifyTimeoutError: eo.transitional(eo.boolean)
    }, !1), o != null && (ie.isFunction(o) ? n.paramsSerializer = {
      serialize: o
    } : Uh.assertOptions(o, {
      encode: eo.function,
      serialize: eo.function
    }, !0)), n.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? n.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : n.allowAbsoluteUrls = !0), Uh.assertOptions(n, {
      baseUrl: eo.spelling("baseURL"),
      withXsrfToken: eo.spelling("withXSRFToken")
    }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let s = a && ie.merge(
      a.common,
      a[n.method]
    );
    a && ie.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (w) => {
        delete a[w];
      }
    ), n.headers = $n.concat(s, a);
    const u = [];
    let c = !0;
    this.interceptors.request.forEach(function(v) {
      typeof v.runWhen == "function" && v.runWhen(n) === !1 || (c = c && v.synchronous, u.unshift(v.fulfilled, v.rejected));
    });
    const f = [];
    this.interceptors.response.forEach(function(v) {
      f.push(v.fulfilled, v.rejected);
    });
    let h, p = 0, g;
    if (!c) {
      const w = [eA.bind(this), void 0];
      for (w.unshift(...u), w.push(...f), g = w.length, h = Promise.resolve(n); p < g; )
        h = h.then(w[p++], w[p++]);
      return h;
    }
    g = u.length;
    let y = n;
    for (p = 0; p < g; ) {
      const w = u[p++], v = u[p++];
      try {
        y = w(y);
      } catch (S) {
        v.call(this, S);
        break;
      }
    }
    try {
      h = eA.call(this, y);
    } catch (w) {
      return Promise.reject(w);
    }
    for (p = 0, g = f.length; p < g; )
      h = h.then(f[p++], f[p++]);
    return h;
  }
  getUri(t) {
    t = Xa(this.defaults, t);
    const n = k3(t.baseURL, t.url, t.allowAbsoluteUrls);
    return w3(n, t.params, t.paramsSerializer);
  }
};
ie.forEach(["delete", "get", "head", "options"], function(t) {
  Fa.prototype[t] = function(n, r) {
    return this.request(Xa(r || {}, {
      method: t,
      url: n,
      data: (r || {}).data
    }));
  };
});
ie.forEach(["post", "put", "patch"], function(t) {
  function n(r) {
    return function(a, s, u) {
      return this.request(Xa(u || {}, {
        method: t,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: a,
        data: s
      }));
    };
  }
  Fa.prototype[t] = n(), Fa.prototype[t + "Form"] = n(!0);
});
let vZ = class N3 {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(a) {
      n = a;
    });
    const r = this;
    this.promise.then((o) => {
      if (!r._listeners) return;
      let a = r._listeners.length;
      for (; a-- > 0; )
        r._listeners[a](o);
      r._listeners = null;
    }), this.promise.then = (o) => {
      let a;
      const s = new Promise((u) => {
        r.subscribe(u), a = u;
      }).then(o);
      return s.cancel = function() {
        r.unsubscribe(a);
      }, s;
    }, t(function(a, s, u) {
      r.reason || (r.reason = new Hl(a, s, u), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), n = (r) => {
      t.abort(r);
    };
    return this.subscribe(n), t.signal.unsubscribe = () => this.unsubscribe(n), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new N3(function(o) {
        t = o;
      }),
      cancel: t
    };
  }
};
function bZ(e) {
  return function(n) {
    return e.apply(null, n);
  };
}
function xZ(e) {
  return ie.isObject(e) && e.isAxiosError === !0;
}
const Rb = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Rb).forEach(([e, t]) => {
  Rb[t] = e;
});
function D3(e) {
  const t = new Fa(e), n = u3(Fa.prototype.request, t);
  return ie.extend(n, Fa.prototype, t, { allOwnKeys: !0 }), ie.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(o) {
    return D3(Xa(e, o));
  }, n;
}
const Lt = D3(gf);
Lt.Axios = Fa;
Lt.CanceledError = Hl;
Lt.CancelToken = vZ;
Lt.isCancel = E3;
Lt.VERSION = O3;
Lt.toFormData = Tm;
Lt.AxiosError = Fe;
Lt.Cancel = Lt.CanceledError;
Lt.all = function(t) {
  return Promise.all(t);
};
Lt.spread = bZ;
Lt.isAxiosError = xZ;
Lt.mergeConfig = Xa;
Lt.AxiosHeaders = $n;
Lt.formToJSON = (e) => S3(ie.isHTMLForm(e) ? new FormData(e) : e);
Lt.getAdapter = M3.getAdapter;
Lt.HttpStatusCode = Rb;
Lt.default = Lt;
const {
  Axios: Jpe,
  AxiosError: eme,
  CanceledError: tme,
  isCancel: nme,
  CancelToken: rme,
  VERSION: ome,
  all: ime,
  Cancel: ame,
  isAxiosError: sme,
  spread: lme,
  toFormData: ume,
  AxiosHeaders: cme,
  HttpStatusCode: fme,
  formToJSON: dme,
  getAdapter: hme,
  mergeConfig: pme
} = Lt;
class j3 extends UX {
  constructor(t) {
    super(t), this._websocket = null, this.reconnectAttempts = 0, this.maxReconnectAttempts = 999, this.initialTimeout = 200, this.maxTimeout = 5e3, this._reconnect = !0, this._reconnect_timeout = void 0, this._url = t.url, this._reconnect_timeout = setTimeout(() => {
      this.connect();
    }, 200), this._zustand && this._zustand.auto_progress();
  }
  connect() {
    this._zustand?.logger.info("Connecting to websocket"), this.is_open = !1, this._websocket = new WebSocket(this._url), this._websocket.onopen = () => {
      this.onopen();
    }, this._websocket.onclose = () => {
      this.onclose();
    }, this._websocket.onerror = () => {
      this.on_ws_error();
    }, this._websocket.onmessage = (t) => {
      typeof t.data == "string" ? this.onmessage(t.data) : t.data instanceof Blob && t.data.arrayBuffer().then((n) => {
        const r = new Uint8Array(n);
        this.getCommunicationManager().onbytes(r);
      });
    };
  }
  calculateReconnectTimeout() {
    return Math.min(
      this.initialTimeout * Math.pow(2, this.reconnectAttempts),
      this.maxTimeout
    );
  }
  auto_reconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      let t = this.calculateReconnectTimeout();
      this._zustand?.logger.info(`Attempting to reconnect in ${t} ms`), this._reconnect_timeout = setTimeout(() => {
        this._websocket && this._websocket.readyState === WebSocket.OPEN || (this.reconnectAttempts++, this.connect());
      }, t);
    } else
      this._zustand?.logger.warn(
        "Maximum reconnect attempts reached. Giving up."
      );
  }
  async onmessage(t) {
    try {
      const n = JSON.parse(t);
      this._zustand?.logger.debug(
        `Recieved data of length: ${t.length} and data"`,
        n
      ), await this.getCommunicationManager().receive(n);
    } catch (n) {
      console.error("Websocketworker: onmessage JSON.parse error", n, t);
      return;
    }
  }
  get http_protocol() {
    return this.secure_url ? "https" : "http";
  }
  get secure_url() {
    return this._url.startsWith("wss");
  }
  get url_wo_protocol() {
    return this._url.substring(this.secure_url ? 6 : 5);
  }
  get http_url() {
    var t = this.http_protocol + "://" + this.url_wo_protocol;
    return t[t.length - 1] !== "/" && (t += "/"), t;
  }
  get_io_subscription_url({
    node_id: t,
    io_id: n,
    stream: r
  }) {
    let o = this.http_url + `node/${t}/io/${n}/value`;
    return r && (o += "/stream"), o;
  }
  async upload_file({
    files: t,
    onProgressCallback: n,
    root: r
  }) {
    const o = `${this.http_url}upload/`, a = new FormData(), s = Array.isArray(t) ? t : Array.from(t);
    for (const u of s) {
      const c = u.webkitRelativePath || u.name, f = r ? `${r}/${c}` : c;
      a.append("file", u, f);
    }
    try {
      return (await Lt.post(o, a, {
        headers: {
          "Content-Type": "multipart/form-data"
        },
        onUploadProgress: (c) => {
          n && n(c.loaded, c.total);
        }
      })).data.file;
    } catch {
      throw new Error("Failed to upload file");
    }
  }
  async handle_large_message_hint({ msg_id: t }) {
    const n = this.http_url + "message/" + t, o = await (await fetch(n, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*"
      }
    })).json();
    this.getCommunicationManager().receive(o);
  }
  onopen() {
    this._zustand?.logger.info("Websocket opened"), this.is_open = !0, this._zustand && this._zustand.auto_progress(), this.reconnectAttempts = 0, this.getSyncManager().stepwise_fullsync();
  }
  onclose() {
    this._zustand?.logger.info("Websocket closed"), super.onclose(), this._reconnect && (this._zustand?.logger.info("Websocket closed,reconnecting"), this.auto_reconnect());
  }
  on_ws_error() {
    this._zustand?.logger.warn("Websocket error"), this._websocket ? this._websocket.close() : this.auto_reconnect();
  }
  async send_large_message(t) {
    const n = `${this.http_url}message/`;
    await fetch(n, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: t
    });
  }
  async send(t) {
    if (!this._websocket || this._websocket.readyState !== WebSocket.OPEN) {
      this._zustand?.logger.warn("Websocket not connected");
      return;
    }
    const n = JSON.stringify(t);
    if (new Blob([n]).size > 1e6)
      return this._zustand?.logger.info("Data too large, sending via http"), await this.send_large_message(n);
    this._zustand?.logger.debug("Sending data", t), this._websocket.send(n);
  }
  async stop() {
    await super.stop(), this._reconnect = !1;
  }
  close() {
    this._websocket && this._websocket.close();
  }
  disconnect() {
    super.disconnect(), this._reconnect = !1, this._reconnect_timeout && (clearTimeout(this._reconnect_timeout), this._reconnect_timeout = void 0), this.close();
  }
  async reconnect() {
    if (await super.reconnect(), this._reconnect = !0, this._websocket && (this._zustand?.logger.info("Reconnecting"), (this._websocket.readyState === WebSocket.OPEN || this._websocket.readyState === WebSocket.CONNECTING) && (this._websocket.readyState === WebSocket.CONNECTING && await new Promise((t, n) => {
      if (this._websocket === null) return;
      let r = setTimeout(() => {
        n("Timeout@reconnect");
      }, 2e3);
      this._websocket.addEventListener(
        "open",
        () => {
          clearTimeout(r), t(null);
        },
        { once: !0 }
      ), this._websocket.readyState === WebSocket.OPEN && (clearTimeout(r), t(null));
    }), this._websocket.readyState === WebSocket.OPEN))) {
      this.getSyncManager().stepwise_fullsync();
      return;
    }
    this.connect();
  }
}
class wZ {
  constructor(t, n) {
    this.ws = null, this.reconnectAttempts = 0, this.maxReconnectAttempts = 999, this.initialTimeout = 200, this.maxTimeout = 2e3, n.logger.debug("Initializing worker manager"), this._wsuri = t, this.zustand = n, this.workers = {}, this.on_setWorker = (r) => {
      this.zustand.set_worker(r);
    }, this.connectionTimeout = setTimeout(() => {
      this.connect();
    }, 200);
  }
  get wsuri() {
    return this._wsuri;
  }
  get open() {
    return this.ws?.readyState === WebSocket.OPEN;
  }
  connect() {
    this.zustand.set_progress({
      progress: 0,
      message: "connecting to worker manager",
      status: "info",
      blocking: !0
    }), this.zustand.logger.info("Connecting to websocket:", this._wsuri), this.ws = new WebSocket(this._wsuri), this.ws.onopen = () => {
      this.onopen();
    }, this.ws.onclose = () => {
      this.onclose();
    }, this.ws.onerror = () => {
      this.on_ws_error();
    }, this.ws.onmessage = (t) => {
      typeof t.data == "string" ? this.onmessage(t.data) : console.error(
        "WorkerManager: onmessage event.data is not a string",
        typeof t.data
      );
    }, this.connectionTimeout = setTimeout(() => {
      this.ws?.readyState !== WebSocket.OPEN && this.on_ws_error();
    }, 5e3);
  }
  on_ws_error() {
    console.warn("Websocket error"), this.ws ? this.ws.close() : this.reconnect();
  }
  onopen() {
    this.connectionTimeout && (clearTimeout(this.connectionTimeout), this.connectionTimeout = void 0), this.zustand.auto_progress(), this.ws && this.ws.send("worker_status");
    const t = window.localStorage.getItem(
      "funcnodes__active_worker"
    );
    t && this.set_active(t);
  }
  onmessage(t) {
    try {
      let n = JSON.parse(t);
      if (n.type === "worker_status") {
        const r = {};
        for (let o of n.active)
          o.active = !0, r[o.uuid] = o;
        for (let o of n.inactive)
          o.active = !1, r[o.uuid] = o;
        this.zustand.workers.setState(r);
        return;
      } else if (n.type === "set_worker") {
        if (n.data.type === "WSWorker") {
          let r = "ws" + (n.data.ssl ? "s" : "") + "://" + n.data.host + ":" + n.data.port;
          this.setWorker(
            this.workers[n.data.uuid] || new j3({
              url: r,
              zustand: this.zustand,
              uuid: n.data.uuid,
              on_sync_complete: this.zustand.options.on_sync_complete
            })
          );
        } else
          this.zustand.logger.error("WorkerManager: unknown worker type", n);
        return;
      } else if (n.type === "progress") {
        this.zustand.set_progress(n);
        return;
      }
      this.zustand.logger.error("WorkerManager: unknown message", n);
    } catch (n) {
      console.error("WorkerManager: onmessage JSON.parse error", n, t);
      return;
    }
  }
  setWorker(t) {
    for (let n in this.workers)
      n !== t?.uuid && this.workers[n].disconnect();
    t !== void 0 && (this.workers[t.uuid] = t, t.reconnect()), t?.uuid && window.localStorage.setItem("funcnodes__active_worker", t?.uuid), this.zustand.worker !== void 0 && this.zustand.clear_all(), this.zustand.set_worker(t), this.on_setWorker(t);
  }
  async restart_worker(t) {
    this.ws?.send(JSON.stringify({ type: "restart_worker", workerid: t }));
  }
  calculateReconnectTimeout() {
    return Math.min(
      this.initialTimeout * Math.pow(2, this.reconnectAttempts),
      this.maxTimeout
    );
  }
  reconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      let t = this.calculateReconnectTimeout();
      this.zustand.logger.info(`Attempting to reconnect in ${t} ms`), setTimeout(() => {
        this.ws && this.ws.readyState === WebSocket.OPEN || (this.reconnectAttempts++, this.connect());
      }, t);
    } else
      this.zustand.logger.warn(
        "Maximum reconnect attempts reached. Giving up."
      );
  }
  onclose() {
    this.zustand.logger.warn("WorkerManager: onclose"), this.reconnect();
  }
  set_active(t) {
    this.ws && this.ws.send(JSON.stringify({ type: "set_active", workerid: t }));
  }
  new_worker({
    name: t,
    reference: n,
    copyLib: r,
    copyNS: o,
    in_venv: a
  }) {
    t || (t = void 0), r || (r = !1), o || (o = !1), n || (n = void 0, r = !1, o = !1), this.ws && this.ws.send(
      JSON.stringify({
        type: "new_worker",
        kwargs: {
          name: t,
          reference: n,
          copyLib: r,
          copyNS: o,
          in_venv: a
        }
      })
    );
  }
  remove() {
    for (let t in this.workers)
      this.workers[t].disconnect();
    this.connectionTimeout && (clearTimeout(this.connectionTimeout), this.connectionTimeout = void 0), this.ws && (this.ws.onclose = () => {
    }, this.ws.onerror = () => {
    }, this.ws.onmessage = () => {
    }, this.ws.onopen = () => {
    }, this.ws.close());
  }
}
const xn = () => {
  const e = tt();
  return e.worker ? {
    ...e.worker.api,
    worker: e.worker
  } : {
    node: void 0,
    group: void 0,
    edge: void 0,
    hooks: void 0,
    lib: void 0,
    worker: e.worker
  };
}, _Z = {
  show: !0
}, SZ = {
  show: !0,
  showmenu: !0
}, EZ = {
  minimap: !0,
  static: !1,
  minZoom: 0.1,
  maxZoom: 5,
  allowFullScreen: !0,
  allowExpand: !0,
  showNodeSettings: !0
}, CZ = {
  id: "",
  // required
  debug: !1,
  useWorkerManager: !0,
  show_library: !0,
  header: SZ,
  flow: EZ,
  library: _Z
}, P3 = [
  "classic",
  "metal",
  "light",
  "solarized",
  "midnight",
  "forest",
  "scientific",
  "neon",
  "ocean",
  "sunset"
];
function Wt(e) {
  if (typeof e == "string" || typeof e == "number") return "" + e;
  let t = "";
  if (Array.isArray(e))
    for (let n = 0, r; n < e.length; n++)
      (r = Wt(e[n])) !== "" && (t += (t && " ") + r);
  else
    for (let n in e)
      e[n] && (t += (t && " ") + n);
  return t;
}
var kZ = { value: () => {
} };
function Mm() {
  for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {
    if (!(r = arguments[e] + "") || r in n || /[\s.]/.test(r)) throw new Error("illegal type: " + r);
    n[r] = [];
  }
  return new qh(n);
}
function qh(e) {
  this._ = e;
}
function TZ(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var r = "", o = n.indexOf(".");
    if (o >= 0 && (r = n.slice(o + 1), n = n.slice(0, o)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
    return { type: n, name: r };
  });
}
qh.prototype = Mm.prototype = {
  constructor: qh,
  on: function(e, t) {
    var n = this._, r = TZ(e + "", n), o, a = -1, s = r.length;
    if (arguments.length < 2) {
      for (; ++a < s; ) if ((o = (e = r[a]).type) && (o = AZ(n[o], e.name))) return o;
      return;
    }
    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
    for (; ++a < s; )
      if (o = (e = r[a]).type) n[o] = nA(n[o], e.name, t);
      else if (t == null) for (o in n) n[o] = nA(n[o], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t) e[n] = t[n].slice();
    return new qh(e);
  },
  call: function(e, t) {
    if ((o = arguments.length - 2) > 0) for (var n = new Array(o), r = 0, o, a; r < o; ++r) n[r] = arguments[r + 2];
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (a = this._[e], r = 0, o = a.length; r < o; ++r) a[r].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (var r = this._[e], o = 0, a = r.length; o < a; ++o) r[o].value.apply(t, n);
  }
};
function AZ(e, t) {
  for (var n = 0, r = e.length, o; n < r; ++n)
    if ((o = e[n]).name === t)
      return o.value;
}
function nA(e, t, n) {
  for (var r = 0, o = e.length; r < o; ++r)
    if (e[r].name === t) {
      e[r] = kZ, e = e.slice(0, r).concat(e.slice(r + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var Mb = "http://www.w3.org/1999/xhtml";
const rA = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Mb,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function Om(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), rA.hasOwnProperty(t) ? { space: rA[t], local: e } : e;
}
function RZ(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === Mb && t.documentElement.namespaceURI === Mb ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function MZ(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function I3(e) {
  var t = Om(e);
  return (t.local ? MZ : RZ)(t);
}
function OZ() {
}
function xx(e) {
  return e == null ? OZ : function() {
    return this.querySelector(e);
  };
}
function NZ(e) {
  typeof e != "function" && (e = xx(e));
  for (var t = this._groups, n = t.length, r = new Array(n), o = 0; o < n; ++o)
    for (var a = t[o], s = a.length, u = r[o] = new Array(s), c, f, h = 0; h < s; ++h)
      (c = a[h]) && (f = e.call(c, c.__data__, h, a)) && ("__data__" in c && (f.__data__ = c.__data__), u[h] = f);
  return new lr(r, this._parents);
}
function DZ(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function jZ() {
  return [];
}
function z3(e) {
  return e == null ? jZ : function() {
    return this.querySelectorAll(e);
  };
}
function PZ(e) {
  return function() {
    return DZ(e.apply(this, arguments));
  };
}
function IZ(e) {
  typeof e == "function" ? e = PZ(e) : e = z3(e);
  for (var t = this._groups, n = t.length, r = [], o = [], a = 0; a < n; ++a)
    for (var s = t[a], u = s.length, c, f = 0; f < u; ++f)
      (c = s[f]) && (r.push(e.call(c, c.__data__, f, s)), o.push(c));
  return new lr(r, o);
}
function L3(e) {
  return function() {
    return this.matches(e);
  };
}
function F3(e) {
  return function(t) {
    return t.matches(e);
  };
}
var zZ = Array.prototype.find;
function LZ(e) {
  return function() {
    return zZ.call(this.children, e);
  };
}
function FZ() {
  return this.firstElementChild;
}
function $Z(e) {
  return this.select(e == null ? FZ : LZ(typeof e == "function" ? e : F3(e)));
}
var BZ = Array.prototype.filter;
function HZ() {
  return Array.from(this.children);
}
function VZ(e) {
  return function() {
    return BZ.call(this.children, e);
  };
}
function UZ(e) {
  return this.selectAll(e == null ? HZ : VZ(typeof e == "function" ? e : F3(e)));
}
function qZ(e) {
  typeof e != "function" && (e = L3(e));
  for (var t = this._groups, n = t.length, r = new Array(n), o = 0; o < n; ++o)
    for (var a = t[o], s = a.length, u = r[o] = [], c, f = 0; f < s; ++f)
      (c = a[f]) && e.call(c, c.__data__, f, a) && u.push(c);
  return new lr(r, this._parents);
}
function $3(e) {
  return new Array(e.length);
}
function GZ() {
  return new lr(this._enter || this._groups.map($3), this._parents);
}
function vp(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
vp.prototype = {
  constructor: vp,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function YZ(e) {
  return function() {
    return e;
  };
}
function WZ(e, t, n, r, o, a) {
  for (var s = 0, u, c = t.length, f = a.length; s < f; ++s)
    (u = t[s]) ? (u.__data__ = a[s], r[s] = u) : n[s] = new vp(e, a[s]);
  for (; s < c; ++s)
    (u = t[s]) && (o[s] = u);
}
function XZ(e, t, n, r, o, a, s) {
  var u, c, f = /* @__PURE__ */ new Map(), h = t.length, p = a.length, g = new Array(h), y;
  for (u = 0; u < h; ++u)
    (c = t[u]) && (g[u] = y = s.call(c, c.__data__, u, t) + "", f.has(y) ? o[u] = c : f.set(y, c));
  for (u = 0; u < p; ++u)
    y = s.call(e, a[u], u, a) + "", (c = f.get(y)) ? (r[u] = c, c.__data__ = a[u], f.delete(y)) : n[u] = new vp(e, a[u]);
  for (u = 0; u < h; ++u)
    (c = t[u]) && f.get(g[u]) === c && (o[u] = c);
}
function KZ(e) {
  return e.__data__;
}
function ZZ(e, t) {
  if (!arguments.length) return Array.from(this, KZ);
  var n = t ? XZ : WZ, r = this._parents, o = this._groups;
  typeof e != "function" && (e = YZ(e));
  for (var a = o.length, s = new Array(a), u = new Array(a), c = new Array(a), f = 0; f < a; ++f) {
    var h = r[f], p = o[f], g = p.length, y = QZ(e.call(h, h && h.__data__, f, r)), w = y.length, v = u[f] = new Array(w), S = s[f] = new Array(w), E = c[f] = new Array(g);
    n(h, p, v, S, E, y, t);
    for (var A = 0, k = 0, T, R; A < w; ++A)
      if (T = v[A]) {
        for (A >= k && (k = A + 1); !(R = S[k]) && ++k < w; ) ;
        T._next = R || null;
      }
  }
  return s = new lr(s, r), s._enter = u, s._exit = c, s;
}
function QZ(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function JZ() {
  return new lr(this._exit || this._groups.map($3), this._parents);
}
function eQ(e, t, n) {
  var r = this.enter(), o = this, a = this.exit();
  return typeof e == "function" ? (r = e(r), r && (r = r.selection())) : r = r.append(e + ""), t != null && (o = t(o), o && (o = o.selection())), n == null ? a.remove() : n(a), r && o ? r.merge(o).order() : o;
}
function tQ(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, r = t._groups, o = n.length, a = r.length, s = Math.min(o, a), u = new Array(o), c = 0; c < s; ++c)
    for (var f = n[c], h = r[c], p = f.length, g = u[c] = new Array(p), y, w = 0; w < p; ++w)
      (y = f[w] || h[w]) && (g[w] = y);
  for (; c < o; ++c)
    u[c] = n[c];
  return new lr(u, this._parents);
}
function nQ() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var r = e[t], o = r.length - 1, a = r[o], s; --o >= 0; )
      (s = r[o]) && (a && s.compareDocumentPosition(a) ^ 4 && a.parentNode.insertBefore(s, a), a = s);
  return this;
}
function rQ(e) {
  e || (e = oQ);
  function t(p, g) {
    return p && g ? e(p.__data__, g.__data__) : !p - !g;
  }
  for (var n = this._groups, r = n.length, o = new Array(r), a = 0; a < r; ++a) {
    for (var s = n[a], u = s.length, c = o[a] = new Array(u), f, h = 0; h < u; ++h)
      (f = s[h]) && (c[h] = f);
    c.sort(t);
  }
  return new lr(o, this._parents).order();
}
function oQ(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function iQ() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function aQ() {
  return Array.from(this);
}
function sQ() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], o = 0, a = r.length; o < a; ++o) {
      var s = r[o];
      if (s) return s;
    }
  return null;
}
function lQ() {
  let e = 0;
  for (const t of this) ++e;
  return e;
}
function uQ() {
  return !this.node();
}
function cQ(e) {
  for (var t = this._groups, n = 0, r = t.length; n < r; ++n)
    for (var o = t[n], a = 0, s = o.length, u; a < s; ++a)
      (u = o[a]) && e.call(u, u.__data__, a, o);
  return this;
}
function fQ(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function dQ(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function hQ(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function pQ(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function mQ(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function gQ(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function yQ(e, t) {
  var n = Om(e);
  if (arguments.length < 2) {
    var r = this.node();
    return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);
  }
  return this.each((t == null ? n.local ? dQ : fQ : typeof t == "function" ? n.local ? gQ : mQ : n.local ? pQ : hQ)(n, t));
}
function B3(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function vQ(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function bQ(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function xQ(e, t, n) {
  return function() {
    var r = t.apply(this, arguments);
    r == null ? this.style.removeProperty(e) : this.style.setProperty(e, r, n);
  };
}
function wQ(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? vQ : typeof t == "function" ? xQ : bQ)(e, t, n ?? "")) : Cl(this.node(), e);
}
function Cl(e, t) {
  return e.style.getPropertyValue(t) || B3(e).getComputedStyle(e, null).getPropertyValue(t);
}
function _Q(e) {
  return function() {
    delete this[e];
  };
}
function SQ(e, t) {
  return function() {
    this[e] = t;
  };
}
function EQ(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function CQ(e, t) {
  return arguments.length > 1 ? this.each((t == null ? _Q : typeof t == "function" ? EQ : SQ)(e, t)) : this.node()[e];
}
function H3(e) {
  return e.trim().split(/^|\s+/);
}
function wx(e) {
  return e.classList || new V3(e);
}
function V3(e) {
  this._node = e, this._names = H3(e.getAttribute("class") || "");
}
V3.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function U3(e, t) {
  for (var n = wx(e), r = -1, o = t.length; ++r < o; ) n.add(t[r]);
}
function q3(e, t) {
  for (var n = wx(e), r = -1, o = t.length; ++r < o; ) n.remove(t[r]);
}
function kQ(e) {
  return function() {
    U3(this, e);
  };
}
function TQ(e) {
  return function() {
    q3(this, e);
  };
}
function AQ(e, t) {
  return function() {
    (t.apply(this, arguments) ? U3 : q3)(this, e);
  };
}
function RQ(e, t) {
  var n = H3(e + "");
  if (arguments.length < 2) {
    for (var r = wx(this.node()), o = -1, a = n.length; ++o < a; ) if (!r.contains(n[o])) return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? AQ : t ? kQ : TQ)(n, t));
}
function MQ() {
  this.textContent = "";
}
function OQ(e) {
  return function() {
    this.textContent = e;
  };
}
function NQ(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function DQ(e) {
  return arguments.length ? this.each(e == null ? MQ : (typeof e == "function" ? NQ : OQ)(e)) : this.node().textContent;
}
function jQ() {
  this.innerHTML = "";
}
function PQ(e) {
  return function() {
    this.innerHTML = e;
  };
}
function IQ(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function zQ(e) {
  return arguments.length ? this.each(e == null ? jQ : (typeof e == "function" ? IQ : PQ)(e)) : this.node().innerHTML;
}
function LQ() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function FQ() {
  return this.each(LQ);
}
function $Q() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function BQ() {
  return this.each($Q);
}
function HQ(e) {
  var t = typeof e == "function" ? e : I3(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function VQ() {
  return null;
}
function UQ(e, t) {
  var n = typeof e == "function" ? e : I3(e), r = t == null ? VQ : typeof t == "function" ? t : xx(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null);
  });
}
function qQ() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function GQ() {
  return this.each(qQ);
}
function YQ() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function WQ() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function XQ(e) {
  return this.select(e ? WQ : YQ);
}
function KQ(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function ZQ(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function QQ(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", r = t.indexOf(".");
    return r >= 0 && (n = t.slice(r + 1), t = t.slice(0, r)), { type: t, name: n };
  });
}
function JQ(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, r = -1, o = t.length, a; n < o; ++n)
        a = t[n], (!e.type || a.type === e.type) && a.name === e.name ? this.removeEventListener(a.type, a.listener, a.options) : t[++r] = a;
      ++r ? t.length = r : delete this.__on;
    }
  };
}
function eJ(e, t, n) {
  return function() {
    var r = this.__on, o, a = ZQ(t);
    if (r) {
      for (var s = 0, u = r.length; s < u; ++s)
        if ((o = r[s]).type === e.type && o.name === e.name) {
          this.removeEventListener(o.type, o.listener, o.options), this.addEventListener(o.type, o.listener = a, o.options = n), o.value = t;
          return;
        }
    }
    this.addEventListener(e.type, a, n), o = { type: e.type, name: e.name, value: t, listener: a, options: n }, r ? r.push(o) : this.__on = [o];
  };
}
function tJ(e, t, n) {
  var r = QQ(e + ""), o, a = r.length, s;
  if (arguments.length < 2) {
    var u = this.node().__on;
    if (u) {
      for (var c = 0, f = u.length, h; c < f; ++c)
        for (o = 0, h = u[c]; o < a; ++o)
          if ((s = r[o]).type === h.type && s.name === h.name)
            return h.value;
    }
    return;
  }
  for (u = t ? eJ : JQ, o = 0; o < a; ++o) this.each(u(r[o], t, n));
  return this;
}
function G3(e, t, n) {
  var r = B3(e), o = r.CustomEvent;
  typeof o == "function" ? o = new o(t, n) : (o = r.document.createEvent("Event"), n ? (o.initEvent(t, n.bubbles, n.cancelable), o.detail = n.detail) : o.initEvent(t, !1, !1)), e.dispatchEvent(o);
}
function nJ(e, t) {
  return function() {
    return G3(this, e, t);
  };
}
function rJ(e, t) {
  return function() {
    return G3(this, e, t.apply(this, arguments));
  };
}
function oJ(e, t) {
  return this.each((typeof t == "function" ? rJ : nJ)(e, t));
}
function* iJ() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], o = 0, a = r.length, s; o < a; ++o)
      (s = r[o]) && (yield s);
}
var Y3 = [null];
function lr(e, t) {
  this._groups = e, this._parents = t;
}
function yf() {
  return new lr([[document.documentElement]], Y3);
}
function aJ() {
  return this;
}
lr.prototype = yf.prototype = {
  constructor: lr,
  select: NZ,
  selectAll: IZ,
  selectChild: $Z,
  selectChildren: UZ,
  filter: qZ,
  data: ZZ,
  enter: GZ,
  exit: JZ,
  join: eQ,
  merge: tQ,
  selection: aJ,
  order: nQ,
  sort: rQ,
  call: iQ,
  nodes: aQ,
  node: sQ,
  size: lQ,
  empty: uQ,
  each: cQ,
  attr: yQ,
  style: wQ,
  property: CQ,
  classed: RQ,
  text: DQ,
  html: zQ,
  raise: FQ,
  lower: BQ,
  append: HQ,
  insert: UQ,
  remove: GQ,
  clone: XQ,
  datum: KQ,
  on: tJ,
  dispatch: oJ,
  [Symbol.iterator]: iJ
};
function rr(e) {
  return typeof e == "string" ? new lr([[document.querySelector(e)]], [document.documentElement]) : new lr([[e]], Y3);
}
function sJ(e) {
  let t;
  for (; t = e.sourceEvent; ) e = t;
  return e;
}
function Dr(e, t) {
  if (e = sJ(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var r = n.createSVGPoint();
      return r.x = e.clientX, r.y = e.clientY, r = r.matrixTransform(t.getScreenCTM().inverse()), [r.x, r.y];
    }
    if (t.getBoundingClientRect) {
      var o = t.getBoundingClientRect();
      return [e.clientX - o.left - t.clientLeft, e.clientY - o.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
const lJ = { passive: !1 }, Bc = { capture: !0, passive: !1 };
function fv(e) {
  e.stopImmediatePropagation();
}
function pl(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function W3(e) {
  var t = e.document.documentElement, n = rr(e).on("dragstart.drag", pl, Bc);
  "onselectstart" in t ? n.on("selectstart.drag", pl, Bc) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function X3(e, t) {
  var n = e.document.documentElement, r = rr(e).on("dragstart.drag", null);
  t && (r.on("click.drag", pl, Bc), setTimeout(function() {
    r.on("click.drag", null);
  }, 0)), "onselectstart" in n ? r.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
}
const mh = (e) => () => e;
function Ob(e, {
  sourceEvent: t,
  subject: n,
  target: r,
  identifier: o,
  active: a,
  x: s,
  y: u,
  dx: c,
  dy: f,
  dispatch: h
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    subject: { value: n, enumerable: !0, configurable: !0 },
    target: { value: r, enumerable: !0, configurable: !0 },
    identifier: { value: o, enumerable: !0, configurable: !0 },
    active: { value: a, enumerable: !0, configurable: !0 },
    x: { value: s, enumerable: !0, configurable: !0 },
    y: { value: u, enumerable: !0, configurable: !0 },
    dx: { value: c, enumerable: !0, configurable: !0 },
    dy: { value: f, enumerable: !0, configurable: !0 },
    _: { value: h }
  });
}
Ob.prototype.on = function() {
  var e = this._.on.apply(this._, arguments);
  return e === this._ ? this : e;
};
function uJ(e) {
  return !e.ctrlKey && !e.button;
}
function cJ() {
  return this.parentNode;
}
function fJ(e, t) {
  return t ?? { x: e.x, y: e.y };
}
function dJ() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function K3() {
  var e = uJ, t = cJ, n = fJ, r = dJ, o = {}, a = Mm("start", "drag", "end"), s = 0, u, c, f, h, p = 0;
  function g(T) {
    T.on("mousedown.drag", y).filter(r).on("touchstart.drag", S).on("touchmove.drag", E, lJ).on("touchend.drag touchcancel.drag", A).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function y(T, R) {
    if (!(h || !e.call(this, T, R))) {
      var N = k(this, t.call(this, T, R), T, R, "mouse");
      N && (rr(T.view).on("mousemove.drag", w, Bc).on("mouseup.drag", v, Bc), W3(T.view), fv(T), f = !1, u = T.clientX, c = T.clientY, N("start", T));
    }
  }
  function w(T) {
    if (pl(T), !f) {
      var R = T.clientX - u, N = T.clientY - c;
      f = R * R + N * N > p;
    }
    o.mouse("drag", T);
  }
  function v(T) {
    rr(T.view).on("mousemove.drag mouseup.drag", null), X3(T.view, f), pl(T), o.mouse("end", T);
  }
  function S(T, R) {
    if (e.call(this, T, R)) {
      var N = T.changedTouches, j = t.call(this, T, R), z = N.length, B, M;
      for (B = 0; B < z; ++B)
        (M = k(this, j, T, R, N[B].identifier, N[B])) && (fv(T), M("start", T, N[B]));
    }
  }
  function E(T) {
    var R = T.changedTouches, N = R.length, j, z;
    for (j = 0; j < N; ++j)
      (z = o[R[j].identifier]) && (pl(T), z("drag", T, R[j]));
  }
  function A(T) {
    var R = T.changedTouches, N = R.length, j, z;
    for (h && clearTimeout(h), h = setTimeout(function() {
      h = null;
    }, 500), j = 0; j < N; ++j)
      (z = o[R[j].identifier]) && (fv(T), z("end", T, R[j]));
  }
  function k(T, R, N, j, z, B) {
    var M = a.copy(), F = Dr(B || N, R), q, Y, P;
    if ((P = n.call(T, new Ob("beforestart", {
      sourceEvent: N,
      target: g,
      identifier: z,
      active: s,
      x: F[0],
      y: F[1],
      dx: 0,
      dy: 0,
      dispatch: M
    }), j)) != null)
      return q = P.x - F[0] || 0, Y = P.y - F[1] || 0, function V(I, U, H) {
        var G = F, O;
        switch (I) {
          case "start":
            o[z] = V, O = s++;
            break;
          case "end":
            delete o[z], --s;
          // falls through
          case "drag":
            F = Dr(H || U, R), O = s;
            break;
        }
        M.call(
          I,
          T,
          new Ob(I, {
            sourceEvent: U,
            subject: P,
            target: g,
            identifier: z,
            active: O,
            x: F[0] + q,
            y: F[1] + Y,
            dx: F[0] - G[0],
            dy: F[1] - G[1],
            dispatch: M
          }),
          j
        );
      };
  }
  return g.filter = function(T) {
    return arguments.length ? (e = typeof T == "function" ? T : mh(!!T), g) : e;
  }, g.container = function(T) {
    return arguments.length ? (t = typeof T == "function" ? T : mh(T), g) : t;
  }, g.subject = function(T) {
    return arguments.length ? (n = typeof T == "function" ? T : mh(T), g) : n;
  }, g.touchable = function(T) {
    return arguments.length ? (r = typeof T == "function" ? T : mh(!!T), g) : r;
  }, g.on = function() {
    var T = a.on.apply(a, arguments);
    return T === a ? g : T;
  }, g.clickDistance = function(T) {
    return arguments.length ? (p = (T = +T) * T, g) : Math.sqrt(p);
  }, g;
}
function _x(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function Z3(e, t) {
  var n = Object.create(e.prototype);
  for (var r in t) n[r] = t[r];
  return n;
}
function vf() {
}
var Hc = 0.7, bp = 1 / Hc, ml = "\\s*([+-]?\\d+)\\s*", Vc = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", go = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", hJ = /^#([0-9a-f]{3,8})$/, pJ = new RegExp(`^rgb\\(${ml},${ml},${ml}\\)$`), mJ = new RegExp(`^rgb\\(${go},${go},${go}\\)$`), gJ = new RegExp(`^rgba\\(${ml},${ml},${ml},${Vc}\\)$`), yJ = new RegExp(`^rgba\\(${go},${go},${go},${Vc}\\)$`), vJ = new RegExp(`^hsl\\(${Vc},${go},${go}\\)$`), bJ = new RegExp(`^hsla\\(${Vc},${go},${go},${Vc}\\)$`), oA = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
_x(vf, Ka, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: iA,
  // Deprecated! Use color.formatHex.
  formatHex: iA,
  formatHex8: xJ,
  formatHsl: wJ,
  formatRgb: aA,
  toString: aA
});
function iA() {
  return this.rgb().formatHex();
}
function xJ() {
  return this.rgb().formatHex8();
}
function wJ() {
  return Q3(this).formatHsl();
}
function aA() {
  return this.rgb().formatRgb();
}
function Ka(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = hJ.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? sA(t) : n === 3 ? new Ln(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? gh(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? gh(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = pJ.exec(e)) ? new Ln(t[1], t[2], t[3], 1) : (t = mJ.exec(e)) ? new Ln(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = gJ.exec(e)) ? gh(t[1], t[2], t[3], t[4]) : (t = yJ.exec(e)) ? gh(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = vJ.exec(e)) ? cA(t[1], t[2] / 100, t[3] / 100, 1) : (t = bJ.exec(e)) ? cA(t[1], t[2] / 100, t[3] / 100, t[4]) : oA.hasOwnProperty(e) ? sA(oA[e]) : e === "transparent" ? new Ln(NaN, NaN, NaN, 0) : null;
}
function sA(e) {
  return new Ln(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function gh(e, t, n, r) {
  return r <= 0 && (e = t = n = NaN), new Ln(e, t, n, r);
}
function _J(e) {
  return e instanceof vf || (e = Ka(e)), e ? (e = e.rgb(), new Ln(e.r, e.g, e.b, e.opacity)) : new Ln();
}
function Nb(e, t, n, r) {
  return arguments.length === 1 ? _J(e) : new Ln(e, t, n, r ?? 1);
}
function Ln(e, t, n, r) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;
}
_x(Ln, Nb, Z3(vf, {
  brighter(e) {
    return e = e == null ? bp : Math.pow(bp, e), new Ln(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Hc : Math.pow(Hc, e), new Ln(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Ln($a(this.r), $a(this.g), $a(this.b), xp(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: lA,
  // Deprecated! Use color.formatHex.
  formatHex: lA,
  formatHex8: SJ,
  formatRgb: uA,
  toString: uA
}));
function lA() {
  return `#${za(this.r)}${za(this.g)}${za(this.b)}`;
}
function SJ() {
  return `#${za(this.r)}${za(this.g)}${za(this.b)}${za((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function uA() {
  const e = xp(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${$a(this.r)}, ${$a(this.g)}, ${$a(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function xp(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function $a(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function za(e) {
  return e = $a(e), (e < 16 ? "0" : "") + e.toString(16);
}
function cA(e, t, n, r) {
  return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new jr(e, t, n, r);
}
function Q3(e) {
  if (e instanceof jr) return new jr(e.h, e.s, e.l, e.opacity);
  if (e instanceof vf || (e = Ka(e)), !e) return new jr();
  if (e instanceof jr) return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, r = e.b / 255, o = Math.min(t, n, r), a = Math.max(t, n, r), s = NaN, u = a - o, c = (a + o) / 2;
  return u ? (t === a ? s = (n - r) / u + (n < r) * 6 : n === a ? s = (r - t) / u + 2 : s = (t - n) / u + 4, u /= c < 0.5 ? a + o : 2 - a - o, s *= 60) : u = c > 0 && c < 1 ? 0 : s, new jr(s, u, c, e.opacity);
}
function EJ(e, t, n, r) {
  return arguments.length === 1 ? Q3(e) : new jr(e, t, n, r ?? 1);
}
function jr(e, t, n, r) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
}
_x(jr, EJ, Z3(vf, {
  brighter(e) {
    return e = e == null ? bp : Math.pow(bp, e), new jr(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Hc : Math.pow(Hc, e), new jr(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * t, o = 2 * n - r;
    return new Ln(
      dv(e >= 240 ? e - 240 : e + 120, o, r),
      dv(e, o, r),
      dv(e < 120 ? e + 240 : e - 120, o, r),
      this.opacity
    );
  },
  clamp() {
    return new jr(fA(this.h), yh(this.s), yh(this.l), xp(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = xp(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${fA(this.h)}, ${yh(this.s) * 100}%, ${yh(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function fA(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function yh(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function dv(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const Sx = (e) => () => e;
function CJ(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function kJ(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(r) {
    return Math.pow(e + r * t, n);
  };
}
function TJ(e) {
  return (e = +e) == 1 ? J3 : function(t, n) {
    return n - t ? kJ(t, n, e) : Sx(isNaN(t) ? n : t);
  };
}
function J3(e, t) {
  var n = t - e;
  return n ? CJ(e, n) : Sx(isNaN(e) ? t : e);
}
const wp = function e(t) {
  var n = TJ(t);
  function r(o, a) {
    var s = n((o = Nb(o)).r, (a = Nb(a)).r), u = n(o.g, a.g), c = n(o.b, a.b), f = J3(o.opacity, a.opacity);
    return function(h) {
      return o.r = s(h), o.g = u(h), o.b = c(h), o.opacity = f(h), o + "";
    };
  }
  return r.gamma = e, r;
}(1);
function AJ(e, t) {
  t || (t = []);
  var n = e ? Math.min(t.length, e.length) : 0, r = t.slice(), o;
  return function(a) {
    for (o = 0; o < n; ++o) r[o] = e[o] * (1 - a) + t[o] * a;
    return r;
  };
}
function RJ(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function MJ(e, t) {
  var n = t ? t.length : 0, r = e ? Math.min(n, e.length) : 0, o = new Array(r), a = new Array(n), s;
  for (s = 0; s < r; ++s) o[s] = wc(e[s], t[s]);
  for (; s < n; ++s) a[s] = t[s];
  return function(u) {
    for (s = 0; s < r; ++s) a[s] = o[s](u);
    return a;
  };
}
function OJ(e, t) {
  var n = /* @__PURE__ */ new Date();
  return e = +e, t = +t, function(r) {
    return n.setTime(e * (1 - r) + t * r), n;
  };
}
function ao(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
function NJ(e, t) {
  var n = {}, r = {}, o;
  (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
  for (o in t)
    o in e ? n[o] = wc(e[o], t[o]) : r[o] = t[o];
  return function(a) {
    for (o in n) r[o] = n[o](a);
    return r;
  };
}
var Db = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, hv = new RegExp(Db.source, "g");
function DJ(e) {
  return function() {
    return e;
  };
}
function jJ(e) {
  return function(t) {
    return e(t) + "";
  };
}
function e5(e, t) {
  var n = Db.lastIndex = hv.lastIndex = 0, r, o, a, s = -1, u = [], c = [];
  for (e = e + "", t = t + ""; (r = Db.exec(e)) && (o = hv.exec(t)); )
    (a = o.index) > n && (a = t.slice(n, a), u[s] ? u[s] += a : u[++s] = a), (r = r[0]) === (o = o[0]) ? u[s] ? u[s] += o : u[++s] = o : (u[++s] = null, c.push({ i: s, x: ao(r, o) })), n = hv.lastIndex;
  return n < t.length && (a = t.slice(n), u[s] ? u[s] += a : u[++s] = a), u.length < 2 ? c[0] ? jJ(c[0].x) : DJ(t) : (t = c.length, function(f) {
    for (var h = 0, p; h < t; ++h) u[(p = c[h]).i] = p.x(f);
    return u.join("");
  });
}
function wc(e, t) {
  var n = typeof t, r;
  return t == null || n === "boolean" ? Sx(t) : (n === "number" ? ao : n === "string" ? (r = Ka(t)) ? (t = r, wp) : e5 : t instanceof Ka ? wp : t instanceof Date ? OJ : RJ(t) ? AJ : Array.isArray(t) ? MJ : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? NJ : ao)(e, t);
}
var dA = 180 / Math.PI, jb = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function t5(e, t, n, r, o, a) {
  var s, u, c;
  return (s = Math.sqrt(e * e + t * t)) && (e /= s, t /= s), (c = e * n + t * r) && (n -= e * c, r -= t * c), (u = Math.sqrt(n * n + r * r)) && (n /= u, r /= u, c /= u), e * r < t * n && (e = -e, t = -t, c = -c, s = -s), {
    translateX: o,
    translateY: a,
    rotate: Math.atan2(t, e) * dA,
    skewX: Math.atan(c) * dA,
    scaleX: s,
    scaleY: u
  };
}
var vh;
function PJ(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? jb : t5(t.a, t.b, t.c, t.d, t.e, t.f);
}
function IJ(e) {
  return e == null || (vh || (vh = document.createElementNS("http://www.w3.org/2000/svg", "g")), vh.setAttribute("transform", e), !(e = vh.transform.baseVal.consolidate())) ? jb : (e = e.matrix, t5(e.a, e.b, e.c, e.d, e.e, e.f));
}
function n5(e, t, n, r) {
  function o(f) {
    return f.length ? f.pop() + " " : "";
  }
  function a(f, h, p, g, y, w) {
    if (f !== p || h !== g) {
      var v = y.push("translate(", null, t, null, n);
      w.push({ i: v - 4, x: ao(f, p) }, { i: v - 2, x: ao(h, g) });
    } else (p || g) && y.push("translate(" + p + t + g + n);
  }
  function s(f, h, p, g) {
    f !== h ? (f - h > 180 ? h += 360 : h - f > 180 && (f += 360), g.push({ i: p.push(o(p) + "rotate(", null, r) - 2, x: ao(f, h) })) : h && p.push(o(p) + "rotate(" + h + r);
  }
  function u(f, h, p, g) {
    f !== h ? g.push({ i: p.push(o(p) + "skewX(", null, r) - 2, x: ao(f, h) }) : h && p.push(o(p) + "skewX(" + h + r);
  }
  function c(f, h, p, g, y, w) {
    if (f !== p || h !== g) {
      var v = y.push(o(y) + "scale(", null, ",", null, ")");
      w.push({ i: v - 4, x: ao(f, p) }, { i: v - 2, x: ao(h, g) });
    } else (p !== 1 || g !== 1) && y.push(o(y) + "scale(" + p + "," + g + ")");
  }
  return function(f, h) {
    var p = [], g = [];
    return f = e(f), h = e(h), a(f.translateX, f.translateY, h.translateX, h.translateY, p, g), s(f.rotate, h.rotate, p, g), u(f.skewX, h.skewX, p, g), c(f.scaleX, f.scaleY, h.scaleX, h.scaleY, p, g), f = h = null, function(y) {
      for (var w = -1, v = g.length, S; ++w < v; ) p[(S = g[w]).i] = S.x(y);
      return p.join("");
    };
  };
}
var zJ = n5(PJ, "px, ", "px)", "deg)"), LJ = n5(IJ, ", ", ")", ")"), FJ = 1e-12;
function hA(e) {
  return ((e = Math.exp(e)) + 1 / e) / 2;
}
function $J(e) {
  return ((e = Math.exp(e)) - 1 / e) / 2;
}
function BJ(e) {
  return ((e = Math.exp(2 * e)) - 1) / (e + 1);
}
const Gh = function e(t, n, r) {
  function o(a, s) {
    var u = a[0], c = a[1], f = a[2], h = s[0], p = s[1], g = s[2], y = h - u, w = p - c, v = y * y + w * w, S, E;
    if (v < FJ)
      E = Math.log(g / f) / t, S = function(j) {
        return [
          u + j * y,
          c + j * w,
          f * Math.exp(t * j * E)
        ];
      };
    else {
      var A = Math.sqrt(v), k = (g * g - f * f + r * v) / (2 * f * n * A), T = (g * g - f * f - r * v) / (2 * g * n * A), R = Math.log(Math.sqrt(k * k + 1) - k), N = Math.log(Math.sqrt(T * T + 1) - T);
      E = (N - R) / t, S = function(j) {
        var z = j * E, B = hA(R), M = f / (n * A) * (B * BJ(t * z + R) - $J(R));
        return [
          u + M * y,
          c + M * w,
          f * B / hA(t * z + R)
        ];
      };
    }
    return S.duration = E * 1e3 * t / Math.SQRT2, S;
  }
  return o.rho = function(a) {
    var s = Math.max(1e-3, +a), u = s * s, c = u * u;
    return e(s, u, c);
  }, o;
}(Math.SQRT2, 2, 4);
var kl = 0, mc = 0, ic = 0, r5 = 1e3, _p, gc, Sp = 0, Za = 0, Nm = 0, Uc = typeof performance == "object" && performance.now ? performance : Date, o5 = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function Ex() {
  return Za || (o5(HJ), Za = Uc.now() + Nm);
}
function HJ() {
  Za = 0;
}
function Ep() {
  this._call = this._time = this._next = null;
}
Ep.prototype = i5.prototype = {
  constructor: Ep,
  restart: function(e, t, n) {
    if (typeof e != "function") throw new TypeError("callback is not a function");
    n = (n == null ? Ex() : +n) + (t == null ? 0 : +t), !this._next && gc !== this && (gc ? gc._next = this : _p = this, gc = this), this._call = e, this._time = n, Pb();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, Pb());
  }
};
function i5(e, t, n) {
  var r = new Ep();
  return r.restart(e, t, n), r;
}
function VJ() {
  Ex(), ++kl;
  for (var e = _p, t; e; )
    (t = Za - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --kl;
}
function pA() {
  Za = (Sp = Uc.now()) + Nm, kl = mc = 0;
  try {
    VJ();
  } finally {
    kl = 0, qJ(), Za = 0;
  }
}
function UJ() {
  var e = Uc.now(), t = e - Sp;
  t > r5 && (Nm -= t, Sp = e);
}
function qJ() {
  for (var e, t = _p, n, r = 1 / 0; t; )
    t._call ? (r > t._time && (r = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : _p = n);
  gc = e, Pb(r);
}
function Pb(e) {
  if (!kl) {
    mc && (mc = clearTimeout(mc));
    var t = e - Za;
    t > 24 ? (e < 1 / 0 && (mc = setTimeout(pA, e - Uc.now() - Nm)), ic && (ic = clearInterval(ic))) : (ic || (Sp = Uc.now(), ic = setInterval(UJ, r5)), kl = 1, o5(pA));
  }
}
function mA(e, t, n) {
  var r = new Ep();
  return t = t == null ? 0 : +t, r.restart((o) => {
    r.stop(), e(o + t);
  }, t, n), r;
}
var GJ = Mm("start", "end", "cancel", "interrupt"), YJ = [], a5 = 0, gA = 1, Ib = 2, Yh = 3, yA = 4, zb = 5, Wh = 6;
function Dm(e, t, n, r, o, a) {
  var s = e.__transition;
  if (!s) e.__transition = {};
  else if (n in s) return;
  WJ(e, n, {
    name: t,
    index: r,
    // For context during callback.
    group: o,
    // For context during callback.
    on: GJ,
    tween: YJ,
    time: a.time,
    delay: a.delay,
    duration: a.duration,
    ease: a.ease,
    timer: null,
    state: a5
  });
}
function Cx(e, t) {
  var n = Ur(e, t);
  if (n.state > a5) throw new Error("too late; already scheduled");
  return n;
}
function Eo(e, t) {
  var n = Ur(e, t);
  if (n.state > Yh) throw new Error("too late; already running");
  return n;
}
function Ur(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t])) throw new Error("transition not found");
  return n;
}
function WJ(e, t, n) {
  var r = e.__transition, o;
  r[t] = n, n.timer = i5(a, 0, n.time);
  function a(f) {
    n.state = gA, n.timer.restart(s, n.delay, n.time), n.delay <= f && s(f - n.delay);
  }
  function s(f) {
    var h, p, g, y;
    if (n.state !== gA) return c();
    for (h in r)
      if (y = r[h], y.name === n.name) {
        if (y.state === Yh) return mA(s);
        y.state === yA ? (y.state = Wh, y.timer.stop(), y.on.call("interrupt", e, e.__data__, y.index, y.group), delete r[h]) : +h < t && (y.state = Wh, y.timer.stop(), y.on.call("cancel", e, e.__data__, y.index, y.group), delete r[h]);
      }
    if (mA(function() {
      n.state === Yh && (n.state = yA, n.timer.restart(u, n.delay, n.time), u(f));
    }), n.state = Ib, n.on.call("start", e, e.__data__, n.index, n.group), n.state === Ib) {
      for (n.state = Yh, o = new Array(g = n.tween.length), h = 0, p = -1; h < g; ++h)
        (y = n.tween[h].value.call(e, e.__data__, n.index, n.group)) && (o[++p] = y);
      o.length = p + 1;
    }
  }
  function u(f) {
    for (var h = f < n.duration ? n.ease.call(null, f / n.duration) : (n.timer.restart(c), n.state = zb, 1), p = -1, g = o.length; ++p < g; )
      o[p].call(e, h);
    n.state === zb && (n.on.call("end", e, e.__data__, n.index, n.group), c());
  }
  function c() {
    n.state = Wh, n.timer.stop(), delete r[t];
    for (var f in r) return;
    delete e.__transition;
  }
}
function Xh(e, t) {
  var n = e.__transition, r, o, a = !0, s;
  if (n) {
    t = t == null ? null : t + "";
    for (s in n) {
      if ((r = n[s]).name !== t) {
        a = !1;
        continue;
      }
      o = r.state > Ib && r.state < zb, r.state = Wh, r.timer.stop(), r.on.call(o ? "interrupt" : "cancel", e, e.__data__, r.index, r.group), delete n[s];
    }
    a && delete e.__transition;
  }
}
function XJ(e) {
  return this.each(function() {
    Xh(this, e);
  });
}
function KJ(e, t) {
  var n, r;
  return function() {
    var o = Eo(this, e), a = o.tween;
    if (a !== n) {
      r = n = a;
      for (var s = 0, u = r.length; s < u; ++s)
        if (r[s].name === t) {
          r = r.slice(), r.splice(s, 1);
          break;
        }
    }
    o.tween = r;
  };
}
function ZJ(e, t, n) {
  var r, o;
  if (typeof n != "function") throw new Error();
  return function() {
    var a = Eo(this, e), s = a.tween;
    if (s !== r) {
      o = (r = s).slice();
      for (var u = { name: t, value: n }, c = 0, f = o.length; c < f; ++c)
        if (o[c].name === t) {
          o[c] = u;
          break;
        }
      c === f && o.push(u);
    }
    a.tween = o;
  };
}
function QJ(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var r = Ur(this.node(), n).tween, o = 0, a = r.length, s; o < a; ++o)
      if ((s = r[o]).name === e)
        return s.value;
    return null;
  }
  return this.each((t == null ? KJ : ZJ)(n, e, t));
}
function kx(e, t, n) {
  var r = e._id;
  return e.each(function() {
    var o = Eo(this, r);
    (o.value || (o.value = {}))[t] = n.apply(this, arguments);
  }), function(o) {
    return Ur(o, r).value[t];
  };
}
function s5(e, t) {
  var n;
  return (typeof t == "number" ? ao : t instanceof Ka ? wp : (n = Ka(t)) ? (t = n, wp) : e5)(e, t);
}
function JJ(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function eee(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function tee(e, t, n) {
  var r, o = n + "", a;
  return function() {
    var s = this.getAttribute(e);
    return s === o ? null : s === r ? a : a = t(r = s, n);
  };
}
function nee(e, t, n) {
  var r, o = n + "", a;
  return function() {
    var s = this.getAttributeNS(e.space, e.local);
    return s === o ? null : s === r ? a : a = t(r = s, n);
  };
}
function ree(e, t, n) {
  var r, o, a;
  return function() {
    var s, u = n(this), c;
    return u == null ? void this.removeAttribute(e) : (s = this.getAttribute(e), c = u + "", s === c ? null : s === r && c === o ? a : (o = c, a = t(r = s, u)));
  };
}
function oee(e, t, n) {
  var r, o, a;
  return function() {
    var s, u = n(this), c;
    return u == null ? void this.removeAttributeNS(e.space, e.local) : (s = this.getAttributeNS(e.space, e.local), c = u + "", s === c ? null : s === r && c === o ? a : (o = c, a = t(r = s, u)));
  };
}
function iee(e, t) {
  var n = Om(e), r = n === "transform" ? LJ : s5;
  return this.attrTween(e, typeof t == "function" ? (n.local ? oee : ree)(n, r, kx(this, "attr." + e, t)) : t == null ? (n.local ? eee : JJ)(n) : (n.local ? nee : tee)(n, r, t));
}
function aee(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function see(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function lee(e, t) {
  var n, r;
  function o() {
    var a = t.apply(this, arguments);
    return a !== r && (n = (r = a) && see(e, a)), n;
  }
  return o._value = t, o;
}
function uee(e, t) {
  var n, r;
  function o() {
    var a = t.apply(this, arguments);
    return a !== r && (n = (r = a) && aee(e, a)), n;
  }
  return o._value = t, o;
}
function cee(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (t == null) return this.tween(n, null);
  if (typeof t != "function") throw new Error();
  var r = Om(e);
  return this.tween(n, (r.local ? lee : uee)(r, t));
}
function fee(e, t) {
  return function() {
    Cx(this, e).delay = +t.apply(this, arguments);
  };
}
function dee(e, t) {
  return t = +t, function() {
    Cx(this, e).delay = t;
  };
}
function hee(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? fee : dee)(t, e)) : Ur(this.node(), t).delay;
}
function pee(e, t) {
  return function() {
    Eo(this, e).duration = +t.apply(this, arguments);
  };
}
function mee(e, t) {
  return t = +t, function() {
    Eo(this, e).duration = t;
  };
}
function gee(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? pee : mee)(t, e)) : Ur(this.node(), t).duration;
}
function yee(e, t) {
  if (typeof t != "function") throw new Error();
  return function() {
    Eo(this, e).ease = t;
  };
}
function vee(e) {
  var t = this._id;
  return arguments.length ? this.each(yee(t, e)) : Ur(this.node(), t).ease;
}
function bee(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function") throw new Error();
    Eo(this, e).ease = n;
  };
}
function xee(e) {
  if (typeof e != "function") throw new Error();
  return this.each(bee(this._id, e));
}
function wee(e) {
  typeof e != "function" && (e = L3(e));
  for (var t = this._groups, n = t.length, r = new Array(n), o = 0; o < n; ++o)
    for (var a = t[o], s = a.length, u = r[o] = [], c, f = 0; f < s; ++f)
      (c = a[f]) && e.call(c, c.__data__, f, a) && u.push(c);
  return new si(r, this._parents, this._name, this._id);
}
function _ee(e) {
  if (e._id !== this._id) throw new Error();
  for (var t = this._groups, n = e._groups, r = t.length, o = n.length, a = Math.min(r, o), s = new Array(r), u = 0; u < a; ++u)
    for (var c = t[u], f = n[u], h = c.length, p = s[u] = new Array(h), g, y = 0; y < h; ++y)
      (g = c[y] || f[y]) && (p[y] = g);
  for (; u < r; ++u)
    s[u] = t[u];
  return new si(s, this._parents, this._name, this._id);
}
function See(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function Eee(e, t, n) {
  var r, o, a = See(t) ? Cx : Eo;
  return function() {
    var s = a(this, e), u = s.on;
    u !== r && (o = (r = u).copy()).on(t, n), s.on = o;
  };
}
function Cee(e, t) {
  var n = this._id;
  return arguments.length < 2 ? Ur(this.node(), n).on.on(e) : this.each(Eee(n, e, t));
}
function kee(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition) if (+n !== e) return;
    t && t.removeChild(this);
  };
}
function Tee() {
  return this.on("end.remove", kee(this._id));
}
function Aee(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = xx(e));
  for (var r = this._groups, o = r.length, a = new Array(o), s = 0; s < o; ++s)
    for (var u = r[s], c = u.length, f = a[s] = new Array(c), h, p, g = 0; g < c; ++g)
      (h = u[g]) && (p = e.call(h, h.__data__, g, u)) && ("__data__" in h && (p.__data__ = h.__data__), f[g] = p, Dm(f[g], t, n, g, f, Ur(h, n)));
  return new si(a, this._parents, t, n);
}
function Ree(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = z3(e));
  for (var r = this._groups, o = r.length, a = [], s = [], u = 0; u < o; ++u)
    for (var c = r[u], f = c.length, h, p = 0; p < f; ++p)
      if (h = c[p]) {
        for (var g = e.call(h, h.__data__, p, c), y, w = Ur(h, n), v = 0, S = g.length; v < S; ++v)
          (y = g[v]) && Dm(y, t, n, v, g, w);
        a.push(g), s.push(h);
      }
  return new si(a, s, t, n);
}
var Mee = yf.prototype.constructor;
function Oee() {
  return new Mee(this._groups, this._parents);
}
function Nee(e, t) {
  var n, r, o;
  return function() {
    var a = Cl(this, e), s = (this.style.removeProperty(e), Cl(this, e));
    return a === s ? null : a === n && s === r ? o : o = t(n = a, r = s);
  };
}
function l5(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function Dee(e, t, n) {
  var r, o = n + "", a;
  return function() {
    var s = Cl(this, e);
    return s === o ? null : s === r ? a : a = t(r = s, n);
  };
}
function jee(e, t, n) {
  var r, o, a;
  return function() {
    var s = Cl(this, e), u = n(this), c = u + "";
    return u == null && (c = u = (this.style.removeProperty(e), Cl(this, e))), s === c ? null : s === r && c === o ? a : (o = c, a = t(r = s, u));
  };
}
function Pee(e, t) {
  var n, r, o, a = "style." + t, s = "end." + a, u;
  return function() {
    var c = Eo(this, e), f = c.on, h = c.value[a] == null ? u || (u = l5(t)) : void 0;
    (f !== n || o !== h) && (r = (n = f).copy()).on(s, o = h), c.on = r;
  };
}
function Iee(e, t, n) {
  var r = (e += "") == "transform" ? zJ : s5;
  return t == null ? this.styleTween(e, Nee(e, r)).on("end.style." + e, l5(e)) : typeof t == "function" ? this.styleTween(e, jee(e, r, kx(this, "style." + e, t))).each(Pee(this._id, e)) : this.styleTween(e, Dee(e, r, t), n).on("end.style." + e, null);
}
function zee(e, t, n) {
  return function(r) {
    this.style.setProperty(e, t.call(this, r), n);
  };
}
function Lee(e, t, n) {
  var r, o;
  function a() {
    var s = t.apply(this, arguments);
    return s !== o && (r = (o = s) && zee(e, s, n)), r;
  }
  return a._value = t, a;
}
function Fee(e, t, n) {
  var r = "style." + (e += "");
  if (arguments.length < 2) return (r = this.tween(r)) && r._value;
  if (t == null) return this.tween(r, null);
  if (typeof t != "function") throw new Error();
  return this.tween(r, Lee(e, t, n ?? ""));
}
function $ee(e) {
  return function() {
    this.textContent = e;
  };
}
function Bee(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function Hee(e) {
  return this.tween("text", typeof e == "function" ? Bee(kx(this, "text", e)) : $ee(e == null ? "" : e + ""));
}
function Vee(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function Uee(e) {
  var t, n;
  function r() {
    var o = e.apply(this, arguments);
    return o !== n && (t = (n = o) && Vee(o)), t;
  }
  return r._value = e, r;
}
function qee(e) {
  var t = "text";
  if (arguments.length < 1) return (t = this.tween(t)) && t._value;
  if (e == null) return this.tween(t, null);
  if (typeof e != "function") throw new Error();
  return this.tween(t, Uee(e));
}
function Gee() {
  for (var e = this._name, t = this._id, n = u5(), r = this._groups, o = r.length, a = 0; a < o; ++a)
    for (var s = r[a], u = s.length, c, f = 0; f < u; ++f)
      if (c = s[f]) {
        var h = Ur(c, t);
        Dm(c, e, n, f, s, {
          time: h.time + h.delay + h.duration,
          delay: 0,
          duration: h.duration,
          ease: h.ease
        });
      }
  return new si(r, this._parents, e, n);
}
function Yee() {
  var e, t, n = this, r = n._id, o = n.size();
  return new Promise(function(a, s) {
    var u = { value: s }, c = { value: function() {
      --o === 0 && a();
    } };
    n.each(function() {
      var f = Eo(this, r), h = f.on;
      h !== e && (t = (e = h).copy(), t._.cancel.push(u), t._.interrupt.push(u), t._.end.push(c)), f.on = t;
    }), o === 0 && a();
  });
}
var Wee = 0;
function si(e, t, n, r) {
  this._groups = e, this._parents = t, this._name = n, this._id = r;
}
function u5() {
  return ++Wee;
}
var Yo = yf.prototype;
si.prototype = {
  constructor: si,
  select: Aee,
  selectAll: Ree,
  selectChild: Yo.selectChild,
  selectChildren: Yo.selectChildren,
  filter: wee,
  merge: _ee,
  selection: Oee,
  transition: Gee,
  call: Yo.call,
  nodes: Yo.nodes,
  node: Yo.node,
  size: Yo.size,
  empty: Yo.empty,
  each: Yo.each,
  on: Cee,
  attr: iee,
  attrTween: cee,
  style: Iee,
  styleTween: Fee,
  text: Hee,
  textTween: qee,
  remove: Tee,
  tween: QJ,
  delay: hee,
  duration: gee,
  ease: vee,
  easeVarying: xee,
  end: Yee,
  [Symbol.iterator]: Yo[Symbol.iterator]
};
function Xee(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var Kee = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: Xee
};
function Zee(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function Qee(e) {
  var t, n;
  e instanceof si ? (t = e._id, e = e._name) : (t = u5(), (n = Kee).time = Ex(), e = e == null ? null : e + "");
  for (var r = this._groups, o = r.length, a = 0; a < o; ++a)
    for (var s = r[a], u = s.length, c, f = 0; f < u; ++f)
      (c = s[f]) && Dm(c, e, t, f, s, n || Zee(c, t));
  return new si(r, this._parents, e, t);
}
yf.prototype.interrupt = XJ;
yf.prototype.transition = Qee;
const bh = (e) => () => e;
function Jee(e, {
  sourceEvent: t,
  target: n,
  transform: r,
  dispatch: o
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    transform: { value: r, enumerable: !0, configurable: !0 },
    _: { value: o }
  });
}
function Zo(e, t, n) {
  this.k = e, this.x = t, this.y = n;
}
Zo.prototype = {
  constructor: Zo,
  scale: function(e) {
    return e === 1 ? this : new Zo(this.k * e, this.x, this.y);
  },
  translate: function(e, t) {
    return e === 0 & t === 0 ? this : new Zo(this.k, this.x + this.k * e, this.y + this.k * t);
  },
  apply: function(e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y];
  },
  applyX: function(e) {
    return e * this.k + this.x;
  },
  applyY: function(e) {
    return e * this.k + this.y;
  },
  invert: function(e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
  },
  invertX: function(e) {
    return (e - this.x) / this.k;
  },
  invertY: function(e) {
    return (e - this.y) / this.k;
  },
  rescaleX: function(e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
  },
  rescaleY: function(e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var jm = new Zo(1, 0, 0);
c5.prototype = Zo.prototype;
function c5(e) {
  for (; !e.__zoom; ) if (!(e = e.parentNode)) return jm;
  return e.__zoom;
}
function pv(e) {
  e.stopImmediatePropagation();
}
function ac(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function ete(e) {
  return (!e.ctrlKey || e.type === "wheel") && !e.button;
}
function tte() {
  var e = this;
  return e instanceof SVGElement ? (e = e.ownerSVGElement || e, e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]]) : [[0, 0], [e.clientWidth, e.clientHeight]];
}
function vA() {
  return this.__zoom || jm;
}
function nte(e) {
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * (e.ctrlKey ? 10 : 1);
}
function rte() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function ote(e, t, n) {
  var r = e.invertX(t[0][0]) - n[0][0], o = e.invertX(t[1][0]) - n[1][0], a = e.invertY(t[0][1]) - n[0][1], s = e.invertY(t[1][1]) - n[1][1];
  return e.translate(
    o > r ? (r + o) / 2 : Math.min(0, r) || Math.max(0, o),
    s > a ? (a + s) / 2 : Math.min(0, a) || Math.max(0, s)
  );
}
function f5() {
  var e = ete, t = tte, n = ote, r = nte, o = rte, a = [0, 1 / 0], s = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], u = 250, c = Gh, f = Mm("start", "zoom", "end"), h, p, g, y = 500, w = 150, v = 0, S = 10;
  function E(P) {
    P.property("__zoom", vA).on("wheel.zoom", z, { passive: !1 }).on("mousedown.zoom", B).on("dblclick.zoom", M).filter(o).on("touchstart.zoom", F).on("touchmove.zoom", q).on("touchend.zoom touchcancel.zoom", Y).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  E.transform = function(P, V, I, U) {
    var H = P.selection ? P.selection() : P;
    H.property("__zoom", vA), P !== H ? R(P, V, I, U) : H.interrupt().each(function() {
      N(this, arguments).event(U).start().zoom(null, typeof V == "function" ? V.apply(this, arguments) : V).end();
    });
  }, E.scaleBy = function(P, V, I, U) {
    E.scaleTo(P, function() {
      var H = this.__zoom.k, G = typeof V == "function" ? V.apply(this, arguments) : V;
      return H * G;
    }, I, U);
  }, E.scaleTo = function(P, V, I, U) {
    E.transform(P, function() {
      var H = t.apply(this, arguments), G = this.__zoom, O = I == null ? T(H) : typeof I == "function" ? I.apply(this, arguments) : I, W = G.invert(O), Z = typeof V == "function" ? V.apply(this, arguments) : V;
      return n(k(A(G, Z), O, W), H, s);
    }, I, U);
  }, E.translateBy = function(P, V, I, U) {
    E.transform(P, function() {
      return n(this.__zoom.translate(
        typeof V == "function" ? V.apply(this, arguments) : V,
        typeof I == "function" ? I.apply(this, arguments) : I
      ), t.apply(this, arguments), s);
    }, null, U);
  }, E.translateTo = function(P, V, I, U, H) {
    E.transform(P, function() {
      var G = t.apply(this, arguments), O = this.__zoom, W = U == null ? T(G) : typeof U == "function" ? U.apply(this, arguments) : U;
      return n(jm.translate(W[0], W[1]).scale(O.k).translate(
        typeof V == "function" ? -V.apply(this, arguments) : -V,
        typeof I == "function" ? -I.apply(this, arguments) : -I
      ), G, s);
    }, U, H);
  };
  function A(P, V) {
    return V = Math.max(a[0], Math.min(a[1], V)), V === P.k ? P : new Zo(V, P.x, P.y);
  }
  function k(P, V, I) {
    var U = V[0] - I[0] * P.k, H = V[1] - I[1] * P.k;
    return U === P.x && H === P.y ? P : new Zo(P.k, U, H);
  }
  function T(P) {
    return [(+P[0][0] + +P[1][0]) / 2, (+P[0][1] + +P[1][1]) / 2];
  }
  function R(P, V, I, U) {
    P.on("start.zoom", function() {
      N(this, arguments).event(U).start();
    }).on("interrupt.zoom end.zoom", function() {
      N(this, arguments).event(U).end();
    }).tween("zoom", function() {
      var H = this, G = arguments, O = N(H, G).event(U), W = t.apply(H, G), Z = I == null ? T(W) : typeof I == "function" ? I.apply(H, G) : I, L = Math.max(W[1][0] - W[0][0], W[1][1] - W[0][1]), te = H.__zoom, he = typeof V == "function" ? V.apply(H, G) : V, oe = c(te.invert(Z).concat(L / te.k), he.invert(Z).concat(L / he.k));
      return function(fe) {
        if (fe === 1) fe = he;
        else {
          var ae = oe(fe), ye = L / ae[2];
          fe = new Zo(ye, Z[0] - ae[0] * ye, Z[1] - ae[1] * ye);
        }
        O.zoom(null, fe);
      };
    });
  }
  function N(P, V, I) {
    return !I && P.__zooming || new j(P, V);
  }
  function j(P, V) {
    this.that = P, this.args = V, this.active = 0, this.sourceEvent = null, this.extent = t.apply(P, V), this.taps = 0;
  }
  j.prototype = {
    event: function(P) {
      return P && (this.sourceEvent = P), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(P, V) {
      return this.mouse && P !== "mouse" && (this.mouse[1] = V.invert(this.mouse[0])), this.touch0 && P !== "touch" && (this.touch0[1] = V.invert(this.touch0[0])), this.touch1 && P !== "touch" && (this.touch1[1] = V.invert(this.touch1[0])), this.that.__zoom = V, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(P) {
      var V = rr(this.that).datum();
      f.call(
        P,
        this.that,
        new Jee(P, {
          sourceEvent: this.sourceEvent,
          target: E,
          transform: this.that.__zoom,
          dispatch: f
        }),
        V
      );
    }
  };
  function z(P, ...V) {
    if (!e.apply(this, arguments)) return;
    var I = N(this, V).event(P), U = this.__zoom, H = Math.max(a[0], Math.min(a[1], U.k * Math.pow(2, r.apply(this, arguments)))), G = Dr(P);
    if (I.wheel)
      (I.mouse[0][0] !== G[0] || I.mouse[0][1] !== G[1]) && (I.mouse[1] = U.invert(I.mouse[0] = G)), clearTimeout(I.wheel);
    else {
      if (U.k === H) return;
      I.mouse = [G, U.invert(G)], Xh(this), I.start();
    }
    ac(P), I.wheel = setTimeout(O, w), I.zoom("mouse", n(k(A(U, H), I.mouse[0], I.mouse[1]), I.extent, s));
    function O() {
      I.wheel = null, I.end();
    }
  }
  function B(P, ...V) {
    if (g || !e.apply(this, arguments)) return;
    var I = P.currentTarget, U = N(this, V, !0).event(P), H = rr(P.view).on("mousemove.zoom", Z, !0).on("mouseup.zoom", L, !0), G = Dr(P, I), O = P.clientX, W = P.clientY;
    W3(P.view), pv(P), U.mouse = [G, this.__zoom.invert(G)], Xh(this), U.start();
    function Z(te) {
      if (ac(te), !U.moved) {
        var he = te.clientX - O, oe = te.clientY - W;
        U.moved = he * he + oe * oe > v;
      }
      U.event(te).zoom("mouse", n(k(U.that.__zoom, U.mouse[0] = Dr(te, I), U.mouse[1]), U.extent, s));
    }
    function L(te) {
      H.on("mousemove.zoom mouseup.zoom", null), X3(te.view, U.moved), ac(te), U.event(te).end();
    }
  }
  function M(P, ...V) {
    if (e.apply(this, arguments)) {
      var I = this.__zoom, U = Dr(P.changedTouches ? P.changedTouches[0] : P, this), H = I.invert(U), G = I.k * (P.shiftKey ? 0.5 : 2), O = n(k(A(I, G), U, H), t.apply(this, V), s);
      ac(P), u > 0 ? rr(this).transition().duration(u).call(R, O, U, P) : rr(this).call(E.transform, O, U, P);
    }
  }
  function F(P, ...V) {
    if (e.apply(this, arguments)) {
      var I = P.touches, U = I.length, H = N(this, V, P.changedTouches.length === U).event(P), G, O, W, Z;
      for (pv(P), O = 0; O < U; ++O)
        W = I[O], Z = Dr(W, this), Z = [Z, this.__zoom.invert(Z), W.identifier], H.touch0 ? !H.touch1 && H.touch0[2] !== Z[2] && (H.touch1 = Z, H.taps = 0) : (H.touch0 = Z, G = !0, H.taps = 1 + !!h);
      h && (h = clearTimeout(h)), G && (H.taps < 2 && (p = Z[0], h = setTimeout(function() {
        h = null;
      }, y)), Xh(this), H.start());
    }
  }
  function q(P, ...V) {
    if (this.__zooming) {
      var I = N(this, V).event(P), U = P.changedTouches, H = U.length, G, O, W, Z;
      for (ac(P), G = 0; G < H; ++G)
        O = U[G], W = Dr(O, this), I.touch0 && I.touch0[2] === O.identifier ? I.touch0[0] = W : I.touch1 && I.touch1[2] === O.identifier && (I.touch1[0] = W);
      if (O = I.that.__zoom, I.touch1) {
        var L = I.touch0[0], te = I.touch0[1], he = I.touch1[0], oe = I.touch1[1], fe = (fe = he[0] - L[0]) * fe + (fe = he[1] - L[1]) * fe, ae = (ae = oe[0] - te[0]) * ae + (ae = oe[1] - te[1]) * ae;
        O = A(O, Math.sqrt(fe / ae)), W = [(L[0] + he[0]) / 2, (L[1] + he[1]) / 2], Z = [(te[0] + oe[0]) / 2, (te[1] + oe[1]) / 2];
      } else if (I.touch0) W = I.touch0[0], Z = I.touch0[1];
      else return;
      I.zoom("touch", n(k(O, W, Z), I.extent, s));
    }
  }
  function Y(P, ...V) {
    if (this.__zooming) {
      var I = N(this, V).event(P), U = P.changedTouches, H = U.length, G, O;
      for (pv(P), g && clearTimeout(g), g = setTimeout(function() {
        g = null;
      }, y), G = 0; G < H; ++G)
        O = U[G], I.touch0 && I.touch0[2] === O.identifier ? delete I.touch0 : I.touch1 && I.touch1[2] === O.identifier && delete I.touch1;
      if (I.touch1 && !I.touch0 && (I.touch0 = I.touch1, delete I.touch1), I.touch0) I.touch0[1] = this.__zoom.invert(I.touch0[0]);
      else if (I.end(), I.taps === 2 && (O = Dr(O, this), Math.hypot(p[0] - O[0], p[1] - O[1]) < S)) {
        var W = rr(this).on("dblclick.zoom");
        W && W.apply(this, arguments);
      }
    }
  }
  return E.wheelDelta = function(P) {
    return arguments.length ? (r = typeof P == "function" ? P : bh(+P), E) : r;
  }, E.filter = function(P) {
    return arguments.length ? (e = typeof P == "function" ? P : bh(!!P), E) : e;
  }, E.touchable = function(P) {
    return arguments.length ? (o = typeof P == "function" ? P : bh(!!P), E) : o;
  }, E.extent = function(P) {
    return arguments.length ? (t = typeof P == "function" ? P : bh([[+P[0][0], +P[0][1]], [+P[1][0], +P[1][1]]]), E) : t;
  }, E.scaleExtent = function(P) {
    return arguments.length ? (a[0] = +P[0], a[1] = +P[1], E) : [a[0], a[1]];
  }, E.translateExtent = function(P) {
    return arguments.length ? (s[0][0] = +P[0][0], s[1][0] = +P[1][0], s[0][1] = +P[0][1], s[1][1] = +P[1][1], E) : [[s[0][0], s[0][1]], [s[1][0], s[1][1]]];
  }, E.constrain = function(P) {
    return arguments.length ? (n = P, E) : n;
  }, E.duration = function(P) {
    return arguments.length ? (u = +P, E) : u;
  }, E.interpolate = function(P) {
    return arguments.length ? (c = P, E) : c;
  }, E.on = function() {
    var P = f.on.apply(f, arguments);
    return P === f ? E : P;
  }, E.clickDistance = function(P) {
    return arguments.length ? (v = (P = +P) * P, E) : Math.sqrt(v);
  }, E.tapDistance = function(P) {
    return arguments.length ? (S = +P, E) : S;
  }, E;
}
const vo = {
  error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
  error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
  error003: (e) => `Node type "${e}" not found. Using fallback type "default".`,
  error004: () => "The React Flow parent container needs a width and a height to render the graph.",
  error005: () => "Only child nodes can use a parent extent.",
  error006: () => "Can't create edge. An edge needs a source and a target.",
  error007: (e) => `The old edge with id=${e} does not exist.`,
  error009: (e) => `Marker type "${e}" doesn't exist.`,
  error008: (e, { id: t, sourceHandle: n, targetHandle: r }) => `Couldn't create edge for ${e} handle id: "${e === "source" ? n : r}", edge id: ${t}.`,
  error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
  error011: (e) => `Edge type "${e}" not found. Using fallback type "default".`,
  error012: (e) => `Node with id "${e}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
  error013: (e = "react") => `It seems that you haven't loaded the styles. Please import '@xyflow/${e}/dist/style.css' or base.css to make sure everything is working properly.`,
  error014: () => "useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.",
  error015: () => "It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs."
}, qc = [
  [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
  [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
], d5 = ["Enter", " ", "Escape"], h5 = {
  "node.a11yDescription.default": "Press enter or space to select a node. Press delete to remove it and escape to cancel.",
  "node.a11yDescription.keyboardDisabled": "Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.",
  "node.a11yDescription.ariaLiveMessage": ({ direction: e, x: t, y: n }) => `Moved selected node ${e}. New position, x: ${t}, y: ${n}`,
  "edge.a11yDescription.default": "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.",
  // Control elements
  "controls.ariaLabel": "Control Panel",
  "controls.zoomIn.ariaLabel": "Zoom In",
  "controls.zoomOut.ariaLabel": "Zoom Out",
  "controls.fitView.ariaLabel": "Fit View",
  "controls.interactive.ariaLabel": "Toggle Interactivity",
  // Mini map
  "minimap.ariaLabel": "Mini Map",
  // Handle
  "handle.ariaLabel": "Handle"
};
var Tl;
(function(e) {
  e.Strict = "strict", e.Loose = "loose";
})(Tl || (Tl = {}));
var Ba;
(function(e) {
  e.Free = "free", e.Vertical = "vertical", e.Horizontal = "horizontal";
})(Ba || (Ba = {}));
var Gc;
(function(e) {
  e.Partial = "partial", e.Full = "full";
})(Gc || (Gc = {}));
const p5 = {
  inProgress: !1,
  isValid: null,
  from: null,
  fromHandle: null,
  fromPosition: null,
  fromNode: null,
  to: null,
  toHandle: null,
  toPosition: null,
  toNode: null
};
var Xi;
(function(e) {
  e.Bezier = "default", e.Straight = "straight", e.Step = "step", e.SmoothStep = "smoothstep", e.SimpleBezier = "simplebezier";
})(Xi || (Xi = {}));
var Cp;
(function(e) {
  e.Arrow = "arrow", e.ArrowClosed = "arrowclosed";
})(Cp || (Cp = {}));
var Ee;
(function(e) {
  e.Left = "left", e.Top = "top", e.Right = "right", e.Bottom = "bottom";
})(Ee || (Ee = {}));
const bA = {
  [Ee.Left]: Ee.Right,
  [Ee.Right]: Ee.Left,
  [Ee.Top]: Ee.Bottom,
  [Ee.Bottom]: Ee.Top
};
function m5(e) {
  return e === null ? null : e ? "valid" : "invalid";
}
const g5 = (e) => "id" in e && "source" in e && "target" in e, ite = (e) => "id" in e && "position" in e && !("source" in e) && !("target" in e), Tx = (e) => "id" in e && "internals" in e && !("source" in e) && !("target" in e), bf = (e, t = [0, 0]) => {
  const { width: n, height: r } = hi(e), o = e.origin ?? t, a = n * o[0], s = r * o[1];
  return {
    x: e.position.x - a,
    y: e.position.y - s
  };
}, ate = (e, t = { nodeOrigin: [0, 0] }) => {
  if (e.length === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  const n = e.reduce((r, o) => {
    const a = typeof o == "string";
    let s = !t.nodeLookup && !a ? o : void 0;
    t.nodeLookup && (s = a ? t.nodeLookup.get(o) : Tx(o) ? o : t.nodeLookup.get(o.id));
    const u = s ? kp(s, t.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };
    return Pm(r, u);
  }, { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 });
  return Im(n);
}, xf = (e, t = {}) => {
  if (e.size === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  let n = { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 };
  return e.forEach((r) => {
    if (t.filter === void 0 || t.filter(r)) {
      const o = kp(r);
      n = Pm(n, o);
    }
  }), Im(n);
}, Ax = (e, t, [n, r, o] = [0, 0, 1], a = !1, s = !1) => {
  const u = {
    ...wf(t, [n, r, o]),
    width: t.width / o,
    height: t.height / o
  }, c = [];
  for (const f of e.values()) {
    const { measured: h, selectable: p = !0, hidden: g = !1 } = f;
    if (s && !p || g)
      continue;
    const y = h.width ?? f.width ?? f.initialWidth ?? null, w = h.height ?? f.height ?? f.initialHeight ?? null, v = Yc(u, Rl(f)), S = (y ?? 0) * (w ?? 0), E = a && v > 0;
    (!f.internals.handleBounds || E || v >= S || f.dragging) && c.push(f);
  }
  return c;
}, ste = (e, t) => {
  const n = /* @__PURE__ */ new Set();
  return e.forEach((r) => {
    n.add(r.id);
  }), t.filter((r) => n.has(r.source) || n.has(r.target));
};
function lte(e, t) {
  const n = /* @__PURE__ */ new Map(), r = t?.nodes ? new Set(t.nodes.map((o) => o.id)) : null;
  return e.forEach((o) => {
    o.measured.width && o.measured.height && (t?.includeHiddenNodes || !o.hidden) && (!r || r.has(o.id)) && n.set(o.id, o);
  }), n;
}
async function ute({ nodes: e, width: t, height: n, panZoom: r, minZoom: o, maxZoom: a }, s) {
  if (e.size === 0)
    return Promise.resolve(!0);
  const u = lte(e, s), c = xf(u), f = Rx(c, t, n, s?.minZoom ?? o, s?.maxZoom ?? a, s?.padding ?? 0.1);
  return await r.setViewport(f, {
    duration: s?.duration,
    ease: s?.ease,
    interpolate: s?.interpolate
  }), Promise.resolve(!0);
}
function y5({ nodeId: e, nextPosition: t, nodeLookup: n, nodeOrigin: r = [0, 0], nodeExtent: o, onError: a }) {
  const s = n.get(e), u = s.parentId ? n.get(s.parentId) : void 0, { x: c, y: f } = u ? u.internals.positionAbsolute : { x: 0, y: 0 }, h = s.origin ?? r;
  let p = s.extent || o;
  if (s.extent === "parent" && !s.expandParent)
    if (!u)
      a?.("005", vo.error005());
    else {
      const y = u.measured.width, w = u.measured.height;
      y && w && (p = [
        [c, f],
        [c + y, f + w]
      ]);
    }
  else u && Ml(s.extent) && (p = [
    [s.extent[0][0] + c, s.extent[0][1] + f],
    [s.extent[1][0] + c, s.extent[1][1] + f]
  ]);
  const g = Ml(p) ? Qa(t, p, s.measured) : t;
  return (s.measured.width === void 0 || s.measured.height === void 0) && a?.("015", vo.error015()), {
    position: {
      x: g.x - c + (s.measured.width ?? 0) * h[0],
      y: g.y - f + (s.measured.height ?? 0) * h[1]
    },
    positionAbsolute: g
  };
}
async function cte({ nodesToRemove: e = [], edgesToRemove: t = [], nodes: n, edges: r, onBeforeDelete: o }) {
  const a = new Set(e.map((g) => g.id)), s = [];
  for (const g of n) {
    if (g.deletable === !1)
      continue;
    const y = a.has(g.id), w = !y && g.parentId && s.find((v) => v.id === g.parentId);
    (y || w) && s.push(g);
  }
  const u = new Set(t.map((g) => g.id)), c = r.filter((g) => g.deletable !== !1), h = ste(s, c);
  for (const g of c)
    u.has(g.id) && !h.find((w) => w.id === g.id) && h.push(g);
  if (!o)
    return {
      edges: h,
      nodes: s
    };
  const p = await o({
    nodes: s,
    edges: h
  });
  return typeof p == "boolean" ? p ? { edges: h, nodes: s } : { edges: [], nodes: [] } : p;
}
const Al = (e, t = 0, n = 1) => Math.min(Math.max(e, t), n), Qa = (e = { x: 0, y: 0 }, t, n) => ({
  x: Al(e.x, t[0][0], t[1][0] - (n?.width ?? 0)),
  y: Al(e.y, t[0][1], t[1][1] - (n?.height ?? 0))
});
function v5(e, t, n) {
  const { width: r, height: o } = hi(n), { x: a, y: s } = n.internals.positionAbsolute;
  return Qa(e, [
    [a, s],
    [a + r, s + o]
  ], t);
}
const xA = (e, t, n) => e < t ? Al(Math.abs(e - t), 1, t) / t : e > n ? -Al(Math.abs(e - n), 1, t) / t : 0, b5 = (e, t, n = 15, r = 40) => {
  const o = xA(e.x, r, t.width - r) * n, a = xA(e.y, r, t.height - r) * n;
  return [o, a];
}, Pm = (e, t) => ({
  x: Math.min(e.x, t.x),
  y: Math.min(e.y, t.y),
  x2: Math.max(e.x2, t.x2),
  y2: Math.max(e.y2, t.y2)
}), Lb = ({ x: e, y: t, width: n, height: r }) => ({
  x: e,
  y: t,
  x2: e + n,
  y2: t + r
}), Im = ({ x: e, y: t, x2: n, y2: r }) => ({
  x: e,
  y: t,
  width: n - e,
  height: r - t
}), Rl = (e, t = [0, 0]) => {
  const { x: n, y: r } = Tx(e) ? e.internals.positionAbsolute : bf(e, t);
  return {
    x: n,
    y: r,
    width: e.measured?.width ?? e.width ?? e.initialWidth ?? 0,
    height: e.measured?.height ?? e.height ?? e.initialHeight ?? 0
  };
}, kp = (e, t = [0, 0]) => {
  const { x: n, y: r } = Tx(e) ? e.internals.positionAbsolute : bf(e, t);
  return {
    x: n,
    y: r,
    x2: n + (e.measured?.width ?? e.width ?? e.initialWidth ?? 0),
    y2: r + (e.measured?.height ?? e.height ?? e.initialHeight ?? 0)
  };
}, x5 = (e, t) => Im(Pm(Lb(e), Lb(t))), Yc = (e, t) => {
  const n = Math.max(0, Math.min(e.x + e.width, t.x + t.width) - Math.max(e.x, t.x)), r = Math.max(0, Math.min(e.y + e.height, t.y + t.height) - Math.max(e.y, t.y));
  return Math.ceil(n * r);
}, wA = (e) => Ir(e.width) && Ir(e.height) && Ir(e.x) && Ir(e.y), Ir = (e) => !isNaN(e) && isFinite(e), fte = (e, t) => {
}, zm = (e, t = [1, 1]) => ({
  x: t[0] * Math.round(e.x / t[0]),
  y: t[1] * Math.round(e.y / t[1])
}), wf = ({ x: e, y: t }, [n, r, o], a = !1, s = [1, 1]) => {
  const u = {
    x: (e - n) / o,
    y: (t - r) / o
  };
  return a ? zm(u, s) : u;
}, Tp = ({ x: e, y: t }, [n, r, o]) => ({
  x: e * o + n,
  y: t * o + r
});
function Qs(e, t) {
  if (typeof e == "number")
    return Math.floor((t - t / (1 + e)) * 0.5);
  if (typeof e == "string" && e.endsWith("px")) {
    const n = parseFloat(e);
    if (!Number.isNaN(n))
      return Math.floor(n);
  }
  if (typeof e == "string" && e.endsWith("%")) {
    const n = parseFloat(e);
    if (!Number.isNaN(n))
      return Math.floor(t * n * 0.01);
  }
  return console.error(`[React Flow] The padding value "${e}" is invalid. Please provide a number or a string with a valid unit (px or %).`), 0;
}
function dte(e, t, n) {
  if (typeof e == "string" || typeof e == "number") {
    const r = Qs(e, n), o = Qs(e, t);
    return {
      top: r,
      right: o,
      bottom: r,
      left: o,
      x: o * 2,
      y: r * 2
    };
  }
  if (typeof e == "object") {
    const r = Qs(e.top ?? e.y ?? 0, n), o = Qs(e.bottom ?? e.y ?? 0, n), a = Qs(e.left ?? e.x ?? 0, t), s = Qs(e.right ?? e.x ?? 0, t);
    return { top: r, right: s, bottom: o, left: a, x: a + s, y: r + o };
  }
  return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 };
}
function hte(e, t, n, r, o, a) {
  const { x: s, y: u } = Tp(e, [t, n, r]), { x: c, y: f } = Tp({ x: e.x + e.width, y: e.y + e.height }, [t, n, r]), h = o - c, p = a - f;
  return {
    left: Math.floor(s),
    top: Math.floor(u),
    right: Math.floor(h),
    bottom: Math.floor(p)
  };
}
const Rx = (e, t, n, r, o, a) => {
  const s = dte(a, t, n), u = (t - s.x) / e.width, c = (n - s.y) / e.height, f = Math.min(u, c), h = Al(f, r, o), p = e.x + e.width / 2, g = e.y + e.height / 2, y = t / 2 - p * h, w = n / 2 - g * h, v = hte(e, y, w, h, t, n), S = {
    left: Math.min(v.left - s.left, 0),
    top: Math.min(v.top - s.top, 0),
    right: Math.min(v.right - s.right, 0),
    bottom: Math.min(v.bottom - s.bottom, 0)
  };
  return {
    x: y - S.left + S.right,
    y: w - S.top + S.bottom,
    zoom: h
  };
}, Ap = () => typeof navigator < "u" && navigator?.userAgent?.indexOf("Mac") >= 0;
function Ml(e) {
  return e !== void 0 && e !== "parent";
}
function hi(e) {
  return {
    width: e.measured?.width ?? e.width ?? e.initialWidth ?? 0,
    height: e.measured?.height ?? e.height ?? e.initialHeight ?? 0
  };
}
function w5(e) {
  return (e.measured?.width ?? e.width ?? e.initialWidth) !== void 0 && (e.measured?.height ?? e.height ?? e.initialHeight) !== void 0;
}
function _5(e, t = { width: 0, height: 0 }, n, r, o) {
  const a = { ...e }, s = r.get(n);
  if (s) {
    const u = s.origin || o;
    a.x += s.internals.positionAbsolute.x - (t.width ?? 0) * u[0], a.y += s.internals.positionAbsolute.y - (t.height ?? 0) * u[1];
  }
  return a;
}
function _A(e, t) {
  if (e.size !== t.size)
    return !1;
  for (const n of e)
    if (!t.has(n))
      return !1;
  return !0;
}
function pte() {
  let e, t;
  return { promise: new Promise((r, o) => {
    e = r, t = o;
  }), resolve: e, reject: t };
}
function mte(e) {
  return { ...h5, ...e || {} };
}
function _c(e, { snapGrid: t = [0, 0], snapToGrid: n = !1, transform: r, containerBounds: o }) {
  const { x: a, y: s } = fo(e), u = wf({ x: a - (o?.left ?? 0), y: s - (o?.top ?? 0) }, r), { x: c, y: f } = n ? zm(u, t) : u;
  return {
    xSnapped: c,
    ySnapped: f,
    ...u
  };
}
const Mx = (e) => ({
  width: e.offsetWidth,
  height: e.offsetHeight
}), S5 = (e) => e?.getRootNode?.() || window?.document, gte = ["INPUT", "SELECT", "TEXTAREA"];
function E5(e) {
  const t = e.composedPath?.()?.[0] || e.target;
  return t?.nodeType !== 1 ? !1 : gte.includes(t.nodeName) || t.hasAttribute("contenteditable") || !!t.closest(".nokey");
}
const C5 = (e) => "clientX" in e, fo = (e, t) => {
  const n = C5(e), r = n ? e.clientX : e.touches?.[0].clientX, o = n ? e.clientY : e.touches?.[0].clientY;
  return {
    x: r - (t?.left ?? 0),
    y: o - (t?.top ?? 0)
  };
}, SA = (e, t, n, r, o) => {
  const a = t.querySelectorAll(`.${e}`);
  return !a || !a.length ? null : Array.from(a).map((s) => {
    const u = s.getBoundingClientRect();
    return {
      id: s.getAttribute("data-handleid"),
      type: e,
      nodeId: o,
      position: s.getAttribute("data-handlepos"),
      x: (u.left - n.left) / r,
      y: (u.top - n.top) / r,
      ...Mx(s)
    };
  });
};
function k5({ sourceX: e, sourceY: t, targetX: n, targetY: r, sourceControlX: o, sourceControlY: a, targetControlX: s, targetControlY: u }) {
  const c = e * 0.125 + o * 0.375 + s * 0.375 + n * 0.125, f = t * 0.125 + a * 0.375 + u * 0.375 + r * 0.125, h = Math.abs(c - e), p = Math.abs(f - t);
  return [c, f, h, p];
}
function xh(e, t) {
  return e >= 0 ? 0.5 * e : t * 25 * Math.sqrt(-e);
}
function EA({ pos: e, x1: t, y1: n, x2: r, y2: o, c: a }) {
  switch (e) {
    case Ee.Left:
      return [t - xh(t - r, a), n];
    case Ee.Right:
      return [t + xh(r - t, a), n];
    case Ee.Top:
      return [t, n - xh(n - o, a)];
    case Ee.Bottom:
      return [t, n + xh(o - n, a)];
  }
}
function Ox({ sourceX: e, sourceY: t, sourcePosition: n = Ee.Bottom, targetX: r, targetY: o, targetPosition: a = Ee.Top, curvature: s = 0.25 }) {
  const [u, c] = EA({
    pos: n,
    x1: e,
    y1: t,
    x2: r,
    y2: o,
    c: s
  }), [f, h] = EA({
    pos: a,
    x1: r,
    y1: o,
    x2: e,
    y2: t,
    c: s
  }), [p, g, y, w] = k5({
    sourceX: e,
    sourceY: t,
    targetX: r,
    targetY: o,
    sourceControlX: u,
    sourceControlY: c,
    targetControlX: f,
    targetControlY: h
  });
  return [
    `M${e},${t} C${u},${c} ${f},${h} ${r},${o}`,
    p,
    g,
    y,
    w
  ];
}
function T5({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
  const o = Math.abs(n - e) / 2, a = n < e ? n + o : n - o, s = Math.abs(r - t) / 2, u = r < t ? r + s : r - s;
  return [a, u, o, s];
}
function yte({ sourceNode: e, targetNode: t, selected: n = !1, zIndex: r, elevateOnSelect: o = !1 }) {
  if (r !== void 0)
    return r;
  const a = o && n ? 1e3 : 0, s = Math.max(e.parentId ? e.internals.z : 0, t.parentId ? t.internals.z : 0);
  return a + s;
}
function vte({ sourceNode: e, targetNode: t, width: n, height: r, transform: o }) {
  const a = Pm(kp(e), kp(t));
  a.x === a.x2 && (a.x2 += 1), a.y === a.y2 && (a.y2 += 1);
  const s = {
    x: -o[0] / o[2],
    y: -o[1] / o[2],
    width: n / o[2],
    height: r / o[2]
  };
  return Yc(s, Im(a)) > 0;
}
const bte = ({ source: e, sourceHandle: t, target: n, targetHandle: r }) => `xy-edge__${e}${t || ""}-${n}${r || ""}`, xte = (e, t) => t.some((n) => n.source === e.source && n.target === e.target && (n.sourceHandle === e.sourceHandle || !n.sourceHandle && !e.sourceHandle) && (n.targetHandle === e.targetHandle || !n.targetHandle && !e.targetHandle)), wte = (e, t) => {
  if (!e.source || !e.target)
    return t;
  let n;
  return g5(e) ? n = { ...e } : n = {
    ...e,
    id: bte(e)
  }, xte(n, t) ? t : (n.sourceHandle === null && delete n.sourceHandle, n.targetHandle === null && delete n.targetHandle, t.concat(n));
};
function A5({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
  const [o, a, s, u] = T5({
    sourceX: e,
    sourceY: t,
    targetX: n,
    targetY: r
  });
  return [`M ${e},${t}L ${n},${r}`, o, a, s, u];
}
const CA = {
  [Ee.Left]: { x: -1, y: 0 },
  [Ee.Right]: { x: 1, y: 0 },
  [Ee.Top]: { x: 0, y: -1 },
  [Ee.Bottom]: { x: 0, y: 1 }
}, _te = ({ source: e, sourcePosition: t = Ee.Bottom, target: n }) => t === Ee.Left || t === Ee.Right ? e.x < n.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : e.y < n.y ? { x: 0, y: 1 } : { x: 0, y: -1 }, kA = (e, t) => Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
function Ste({ source: e, sourcePosition: t = Ee.Bottom, target: n, targetPosition: r = Ee.Top, center: o, offset: a, stepPosition: s }) {
  const u = CA[t], c = CA[r], f = { x: e.x + u.x * a, y: e.y + u.y * a }, h = { x: n.x + c.x * a, y: n.y + c.y * a }, p = _te({
    source: f,
    sourcePosition: t,
    target: h
  }), g = p.x !== 0 ? "x" : "y", y = p[g];
  let w = [], v, S;
  const E = { x: 0, y: 0 }, A = { x: 0, y: 0 }, [, , k, T] = T5({
    sourceX: e.x,
    sourceY: e.y,
    targetX: n.x,
    targetY: n.y
  });
  if (u[g] * c[g] === -1) {
    g === "x" ? (v = o.x ?? f.x + (h.x - f.x) * s, S = o.y ?? (f.y + h.y) / 2) : (v = o.x ?? (f.x + h.x) / 2, S = o.y ?? f.y + (h.y - f.y) * s);
    const N = [
      { x: v, y: f.y },
      { x: v, y: h.y }
    ], j = [
      { x: f.x, y: S },
      { x: h.x, y: S }
    ];
    u[g] === y ? w = g === "x" ? N : j : w = g === "x" ? j : N;
  } else {
    const N = [{ x: f.x, y: h.y }], j = [{ x: h.x, y: f.y }];
    if (g === "x" ? w = u.x === y ? j : N : w = u.y === y ? N : j, t === r) {
      const q = Math.abs(e[g] - n[g]);
      if (q <= a) {
        const Y = Math.min(a - 1, a - q);
        u[g] === y ? E[g] = (f[g] > e[g] ? -1 : 1) * Y : A[g] = (h[g] > n[g] ? -1 : 1) * Y;
      }
    }
    if (t !== r) {
      const q = g === "x" ? "y" : "x", Y = u[g] === c[q], P = f[q] > h[q], V = f[q] < h[q];
      (u[g] === 1 && (!Y && P || Y && V) || u[g] !== 1 && (!Y && V || Y && P)) && (w = g === "x" ? N : j);
    }
    const z = { x: f.x + E.x, y: f.y + E.y }, B = { x: h.x + A.x, y: h.y + A.y }, M = Math.max(Math.abs(z.x - w[0].x), Math.abs(B.x - w[0].x)), F = Math.max(Math.abs(z.y - w[0].y), Math.abs(B.y - w[0].y));
    M >= F ? (v = (z.x + B.x) / 2, S = w[0].y) : (v = w[0].x, S = (z.y + B.y) / 2);
  }
  return [[
    e,
    { x: f.x + E.x, y: f.y + E.y },
    ...w,
    { x: h.x + A.x, y: h.y + A.y },
    n
  ], v, S, k, T];
}
function Ete(e, t, n, r) {
  const o = Math.min(kA(e, t) / 2, kA(t, n) / 2, r), { x: a, y: s } = t;
  if (e.x === a && a === n.x || e.y === s && s === n.y)
    return `L${a} ${s}`;
  if (e.y === s) {
    const f = e.x < n.x ? -1 : 1, h = e.y < n.y ? 1 : -1;
    return `L ${a + o * f},${s}Q ${a},${s} ${a},${s + o * h}`;
  }
  const u = e.x < n.x ? 1 : -1, c = e.y < n.y ? -1 : 1;
  return `L ${a},${s + o * c}Q ${a},${s} ${a + o * u},${s}`;
}
function Fb({ sourceX: e, sourceY: t, sourcePosition: n = Ee.Bottom, targetX: r, targetY: o, targetPosition: a = Ee.Top, borderRadius: s = 5, centerX: u, centerY: c, offset: f = 20, stepPosition: h = 0.5 }) {
  const [p, g, y, w, v] = Ste({
    source: { x: e, y: t },
    sourcePosition: n,
    target: { x: r, y: o },
    targetPosition: a,
    center: { x: u, y: c },
    offset: f,
    stepPosition: h
  });
  return [p.reduce((E, A, k) => {
    let T = "";
    return k > 0 && k < p.length - 1 ? T = Ete(p[k - 1], A, p[k + 1], s) : T = `${k === 0 ? "M" : "L"}${A.x} ${A.y}`, E += T, E;
  }, ""), g, y, w, v];
}
function TA(e) {
  return e && !!(e.internals.handleBounds || e.handles?.length) && !!(e.measured.width || e.width || e.initialWidth);
}
function Cte(e) {
  const { sourceNode: t, targetNode: n } = e;
  if (!TA(t) || !TA(n))
    return null;
  const r = t.internals.handleBounds || AA(t.handles), o = n.internals.handleBounds || AA(n.handles), a = RA(r?.source ?? [], e.sourceHandle), s = RA(
    // when connection type is loose we can define all handles as sources and connect source -> source
    e.connectionMode === Tl.Strict ? o?.target ?? [] : (o?.target ?? []).concat(o?.source ?? []),
    e.targetHandle
  );
  if (!a || !s)
    return e.onError?.("008", vo.error008(a ? "target" : "source", {
      id: e.id,
      sourceHandle: e.sourceHandle,
      targetHandle: e.targetHandle
    })), null;
  const u = a?.position || Ee.Bottom, c = s?.position || Ee.Top, f = Wc(t, a, u), h = Wc(n, s, c);
  return {
    sourceX: f.x,
    sourceY: f.y,
    targetX: h.x,
    targetY: h.y,
    sourcePosition: u,
    targetPosition: c
  };
}
function AA(e) {
  if (!e)
    return null;
  const t = [], n = [];
  for (const r of e)
    r.width = r.width ?? 1, r.height = r.height ?? 1, r.type === "source" ? t.push(r) : r.type === "target" && n.push(r);
  return {
    source: t,
    target: n
  };
}
function Wc(e, t, n = Ee.Left, r = !1) {
  const o = (t?.x ?? 0) + e.internals.positionAbsolute.x, a = (t?.y ?? 0) + e.internals.positionAbsolute.y, { width: s, height: u } = t ?? hi(e);
  if (r)
    return { x: o + s / 2, y: a + u / 2 };
  switch (t?.position ?? n) {
    case Ee.Top:
      return { x: o + s / 2, y: a };
    case Ee.Right:
      return { x: o + s, y: a + u / 2 };
    case Ee.Bottom:
      return { x: o + s / 2, y: a + u };
    case Ee.Left:
      return { x: o, y: a + u / 2 };
  }
}
function RA(e, t) {
  return e && (t ? e.find((n) => n.id === t) : e[0]) || null;
}
function $b(e, t) {
  return e ? typeof e == "string" ? e : `${t ? `${t}__` : ""}${Object.keys(e).sort().map((r) => `${r}=${e[r]}`).join("&")}` : "";
}
function kte(e, { id: t, defaultColor: n, defaultMarkerStart: r, defaultMarkerEnd: o }) {
  const a = /* @__PURE__ */ new Set();
  return e.reduce((s, u) => ([u.markerStart || r, u.markerEnd || o].forEach((c) => {
    if (c && typeof c == "object") {
      const f = $b(c, t);
      a.has(f) || (s.push({ id: f, color: c.color || n, ...c }), a.add(f));
    }
  }), s), []).sort((s, u) => s.id.localeCompare(u.id));
}
const Nx = {
  nodeOrigin: [0, 0],
  nodeExtent: qc,
  elevateNodesOnSelect: !0,
  defaults: {}
}, Tte = {
  ...Nx,
  checkEquality: !0
};
function Dx(e, t) {
  const n = { ...e };
  for (const r in t)
    t[r] !== void 0 && (n[r] = t[r]);
  return n;
}
function Ate(e, t, n) {
  const r = Dx(Nx, n);
  for (const o of e.values())
    if (o.parentId)
      jx(o, e, t, r);
    else {
      const a = bf(o, r.nodeOrigin), s = Ml(o.extent) ? o.extent : r.nodeExtent, u = Qa(a, s, hi(o));
      o.internals.positionAbsolute = u;
    }
}
function Bb(e, t, n, r) {
  const o = Dx(Tte, r);
  let a = e.length > 0;
  const s = new Map(t), u = o?.elevateNodesOnSelect ? 1e3 : 0;
  t.clear(), n.clear();
  for (const c of e) {
    let f = s.get(c.id);
    if (o.checkEquality && c === f?.internals.userNode)
      t.set(c.id, f);
    else {
      const h = bf(c, o.nodeOrigin), p = Ml(c.extent) ? c.extent : o.nodeExtent, g = Qa(h, p, hi(c));
      f = {
        ...o.defaults,
        ...c,
        measured: {
          width: c.measured?.width,
          height: c.measured?.height
        },
        internals: {
          positionAbsolute: g,
          // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured
          handleBounds: c.measured ? f?.internals.handleBounds : void 0,
          z: R5(c, u),
          userNode: c
        }
      }, t.set(c.id, f);
    }
    (f.measured === void 0 || f.measured.width === void 0 || f.measured.height === void 0) && !f.hidden && (a = !1), c.parentId && jx(f, t, n, r);
  }
  return a;
}
function Rte(e, t) {
  if (!e.parentId)
    return;
  const n = t.get(e.parentId);
  n ? n.set(e.id, e) : t.set(e.parentId, /* @__PURE__ */ new Map([[e.id, e]]));
}
function jx(e, t, n, r) {
  const { elevateNodesOnSelect: o, nodeOrigin: a, nodeExtent: s } = Dx(Nx, r), u = e.parentId, c = t.get(u);
  if (!c) {
    console.warn(`Parent node ${u} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);
    return;
  }
  Rte(e, n);
  const f = o ? 1e3 : 0, { x: h, y: p, z: g } = Mte(e, c, a, s, f), { positionAbsolute: y } = e.internals, w = h !== y.x || p !== y.y;
  (w || g !== e.internals.z) && t.set(e.id, {
    ...e,
    internals: {
      ...e.internals,
      positionAbsolute: w ? { x: h, y: p } : y,
      z: g
    }
  });
}
function R5(e, t) {
  return (Ir(e.zIndex) ? e.zIndex : 0) + (e.selected ? t : 0);
}
function Mte(e, t, n, r, o) {
  const { x: a, y: s } = t.internals.positionAbsolute, u = hi(e), c = bf(e, n), f = Ml(e.extent) ? Qa(c, e.extent, u) : c;
  let h = Qa({ x: a + f.x, y: s + f.y }, r, u);
  e.extent === "parent" && (h = v5(h, u, t));
  const p = R5(e, o), g = t.internals.z ?? 0;
  return {
    x: h.x,
    y: h.y,
    z: g >= p ? g + 1 : p
  };
}
function Px(e, t, n, r = [0, 0]) {
  const o = [], a = /* @__PURE__ */ new Map();
  for (const s of e) {
    const u = t.get(s.parentId);
    if (!u)
      continue;
    const c = a.get(s.parentId)?.expandedRect ?? Rl(u), f = x5(c, s.rect);
    a.set(s.parentId, { expandedRect: f, parent: u });
  }
  return a.size > 0 && a.forEach(({ expandedRect: s, parent: u }, c) => {
    const f = u.internals.positionAbsolute, h = hi(u), p = u.origin ?? r, g = s.x < f.x ? Math.round(Math.abs(f.x - s.x)) : 0, y = s.y < f.y ? Math.round(Math.abs(f.y - s.y)) : 0, w = Math.max(h.width, Math.round(s.width)), v = Math.max(h.height, Math.round(s.height)), S = (w - h.width) * p[0], E = (v - h.height) * p[1];
    (g > 0 || y > 0 || S || E) && (o.push({
      id: c,
      type: "position",
      position: {
        x: u.position.x - g + S,
        y: u.position.y - y + E
      }
    }), n.get(c)?.forEach((A) => {
      e.some((k) => k.id === A.id) || o.push({
        id: A.id,
        type: "position",
        position: {
          x: A.position.x + g,
          y: A.position.y + y
        }
      });
    })), (h.width < s.width || h.height < s.height || g || y) && o.push({
      id: c,
      type: "dimensions",
      setAttributes: !0,
      dimensions: {
        width: w + (g ? p[0] * g - S : 0),
        height: v + (y ? p[1] * y - E : 0)
      }
    });
  }), o;
}
function Ote(e, t, n, r, o, a) {
  const s = r?.querySelector(".xyflow__viewport");
  let u = !1;
  if (!s)
    return { changes: [], updatedInternals: u };
  const c = [], f = window.getComputedStyle(s), { m22: h } = new window.DOMMatrixReadOnly(f.transform), p = [];
  for (const g of e.values()) {
    const y = t.get(g.id);
    if (!y)
      continue;
    if (y.hidden) {
      t.set(y.id, {
        ...y,
        internals: {
          ...y.internals,
          handleBounds: void 0
        }
      }), u = !0;
      continue;
    }
    const w = Mx(g.nodeElement), v = y.measured.width !== w.width || y.measured.height !== w.height;
    if (!!(w.width && w.height && (v || !y.internals.handleBounds || g.force))) {
      const E = g.nodeElement.getBoundingClientRect(), A = Ml(y.extent) ? y.extent : a;
      let { positionAbsolute: k } = y.internals;
      y.parentId && y.extent === "parent" ? k = v5(k, w, t.get(y.parentId)) : A && (k = Qa(k, A, w));
      const T = {
        ...y,
        measured: w,
        internals: {
          ...y.internals,
          positionAbsolute: k,
          handleBounds: {
            source: SA("source", g.nodeElement, E, h, y.id),
            target: SA("target", g.nodeElement, E, h, y.id)
          }
        }
      };
      t.set(y.id, T), y.parentId && jx(T, t, n, { nodeOrigin: o }), u = !0, v && (c.push({
        id: y.id,
        type: "dimensions",
        dimensions: w
      }), y.expandParent && y.parentId && p.push({
        id: y.id,
        parentId: y.parentId,
        rect: Rl(T, o)
      }));
    }
  }
  if (p.length > 0) {
    const g = Px(p, t, n, o);
    c.push(...g);
  }
  return { changes: c, updatedInternals: u };
}
async function Nte({ delta: e, panZoom: t, transform: n, translateExtent: r, width: o, height: a }) {
  if (!t || !e.x && !e.y)
    return Promise.resolve(!1);
  const s = await t.setViewportConstrained({
    x: n[0] + e.x,
    y: n[1] + e.y,
    zoom: n[2]
  }, [
    [0, 0],
    [o, a]
  ], r), u = !!s && (s.x !== n[0] || s.y !== n[1] || s.k !== n[2]);
  return Promise.resolve(u);
}
function MA(e, t, n, r, o, a) {
  let s = o;
  const u = r.get(s) || /* @__PURE__ */ new Map();
  r.set(s, u.set(n, t)), s = `${o}-${e}`;
  const c = r.get(s) || /* @__PURE__ */ new Map();
  if (r.set(s, c.set(n, t)), a) {
    s = `${o}-${e}-${a}`;
    const f = r.get(s) || /* @__PURE__ */ new Map();
    r.set(s, f.set(n, t));
  }
}
function M5(e, t, n) {
  e.clear(), t.clear();
  for (const r of n) {
    const { source: o, target: a, sourceHandle: s = null, targetHandle: u = null } = r, c = { edgeId: r.id, source: o, target: a, sourceHandle: s, targetHandle: u }, f = `${o}-${s}--${a}-${u}`, h = `${a}-${u}--${o}-${s}`;
    MA("source", c, h, e, o, s), MA("target", c, f, e, a, u), t.set(r.id, r);
  }
}
function O5(e, t) {
  if (!e.parentId)
    return !1;
  const n = t.get(e.parentId);
  return n ? n.selected ? !0 : O5(n, t) : !1;
}
function OA(e, t, n) {
  let r = e;
  do {
    if (r?.matches?.(t))
      return !0;
    if (r === n)
      return !1;
    r = r?.parentElement;
  } while (r);
  return !1;
}
function Dte(e, t, n, r) {
  const o = /* @__PURE__ */ new Map();
  for (const [a, s] of e)
    if ((s.selected || s.id === r) && (!s.parentId || !O5(s, e)) && (s.draggable || t && typeof s.draggable > "u")) {
      const u = e.get(a);
      u && o.set(a, {
        id: a,
        position: u.position || { x: 0, y: 0 },
        distance: {
          x: n.x - u.internals.positionAbsolute.x,
          y: n.y - u.internals.positionAbsolute.y
        },
        extent: u.extent,
        parentId: u.parentId,
        origin: u.origin,
        expandParent: u.expandParent,
        internals: {
          positionAbsolute: u.internals.positionAbsolute || { x: 0, y: 0 }
        },
        measured: {
          width: u.measured.width ?? 0,
          height: u.measured.height ?? 0
        }
      });
    }
  return o;
}
function mv({ nodeId: e, dragItems: t, nodeLookup: n, dragging: r = !0 }) {
  const o = [];
  for (const [s, u] of t) {
    const c = n.get(s)?.internals.userNode;
    c && o.push({
      ...c,
      position: u.position,
      dragging: r
    });
  }
  if (!e)
    return [o[0], o];
  const a = n.get(e)?.internals.userNode;
  return [
    a ? {
      ...a,
      position: t.get(e)?.position || a.position,
      dragging: r
    } : o[0],
    o
  ];
}
function jte({ onNodeMouseDown: e, getStoreItems: t, onDragStart: n, onDrag: r, onDragStop: o }) {
  let a = { x: null, y: null }, s = 0, u = /* @__PURE__ */ new Map(), c = !1, f = { x: 0, y: 0 }, h = null, p = !1, g = null, y = !1, w = !1;
  function v({ noDragClassName: E, handleSelector: A, domNode: k, isSelectable: T, nodeId: R, nodeClickDistance: N = 0 }) {
    g = rr(k);
    function j({ x: F, y: q }, Y) {
      const { nodeLookup: P, nodeExtent: V, snapGrid: I, snapToGrid: U, nodeOrigin: H, onNodeDrag: G, onSelectionDrag: O, onError: W, updateNodePositions: Z } = t();
      a = { x: F, y: q };
      let L = !1, te = { x: 0, y: 0, x2: 0, y2: 0 };
      if (u.size > 1 && V) {
        const he = xf(u);
        te = Lb(he);
      }
      for (const [he, oe] of u) {
        if (!P.has(he))
          continue;
        let fe = { x: F - oe.distance.x, y: q - oe.distance.y };
        U && (fe = zm(fe, I));
        let ae = [
          [V[0][0], V[0][1]],
          [V[1][0], V[1][1]]
        ];
        if (u.size > 1 && V && !oe.extent) {
          const { positionAbsolute: De } = oe.internals, we = De.x - te.x + V[0][0], Ce = De.x + oe.measured.width - te.x2 + V[1][0], _e = De.y - te.y + V[0][1], Xe = De.y + oe.measured.height - te.y2 + V[1][1];
          ae = [
            [we, _e],
            [Ce, Xe]
          ];
        }
        const { position: ye, positionAbsolute: Ne } = y5({
          nodeId: he,
          nextPosition: fe,
          nodeLookup: P,
          nodeExtent: ae,
          nodeOrigin: H,
          onError: W
        });
        L = L || oe.position.x !== ye.x || oe.position.y !== ye.y, oe.position = ye, oe.internals.positionAbsolute = Ne;
      }
      if (w = w || L, !!L && (Z(u, !0), Y && (r || G || !R && O))) {
        const [he, oe] = mv({
          nodeId: R,
          dragItems: u,
          nodeLookup: P
        });
        r?.(Y, u, he, oe), G?.(Y, he, oe), R || O?.(Y, oe);
      }
    }
    async function z() {
      if (!h)
        return;
      const { transform: F, panBy: q, autoPanSpeed: Y, autoPanOnNodeDrag: P } = t();
      if (!P) {
        c = !1, cancelAnimationFrame(s);
        return;
      }
      const [V, I] = b5(f, h, Y);
      (V !== 0 || I !== 0) && (a.x = (a.x ?? 0) - V / F[2], a.y = (a.y ?? 0) - I / F[2], await q({ x: V, y: I }) && j(a, null)), s = requestAnimationFrame(z);
    }
    function B(F) {
      const { nodeLookup: q, multiSelectionActive: Y, nodesDraggable: P, transform: V, snapGrid: I, snapToGrid: U, selectNodesOnDrag: H, onNodeDragStart: G, onSelectionDragStart: O, unselectNodesAndEdges: W } = t();
      p = !0, (!H || !T) && !Y && R && (q.get(R)?.selected || W()), T && H && R && e?.(R);
      const Z = _c(F.sourceEvent, { transform: V, snapGrid: I, snapToGrid: U, containerBounds: h });
      if (a = Z, u = Dte(q, P, Z, R), u.size > 0 && (n || G || !R && O)) {
        const [L, te] = mv({
          nodeId: R,
          dragItems: u,
          nodeLookup: q
        });
        n?.(F.sourceEvent, u, L, te), G?.(F.sourceEvent, L, te), R || O?.(F.sourceEvent, te);
      }
    }
    const M = K3().clickDistance(N).on("start", (F) => {
      const { domNode: q, nodeDragThreshold: Y, transform: P, snapGrid: V, snapToGrid: I } = t();
      h = q?.getBoundingClientRect() || null, y = !1, w = !1, Y === 0 && B(F), a = _c(F.sourceEvent, { transform: P, snapGrid: V, snapToGrid: I, containerBounds: h }), f = fo(F.sourceEvent, h);
    }).on("drag", (F) => {
      const { autoPanOnNodeDrag: q, transform: Y, snapGrid: P, snapToGrid: V, nodeDragThreshold: I, nodeLookup: U } = t(), H = _c(F.sourceEvent, { transform: Y, snapGrid: P, snapToGrid: V, containerBounds: h });
      if ((F.sourceEvent.type === "touchmove" && F.sourceEvent.touches.length > 1 || // if user deletes a node while dragging, we need to abort the drag to prevent errors
      R && !U.has(R)) && (y = !0), !y) {
        if (!c && q && p && (c = !0, z()), !p) {
          const G = H.xSnapped - (a.x ?? 0), O = H.ySnapped - (a.y ?? 0);
          Math.sqrt(G * G + O * O) > I && B(F);
        }
        (a.x !== H.xSnapped || a.y !== H.ySnapped) && u && p && (f = fo(F.sourceEvent, h), j(H, F.sourceEvent));
      }
    }).on("end", (F) => {
      if (!(!p || y) && (c = !1, p = !1, cancelAnimationFrame(s), u.size > 0)) {
        const { nodeLookup: q, updateNodePositions: Y, onNodeDragStop: P, onSelectionDragStop: V } = t();
        if (w && (Y(u, !1), w = !1), o || P || !R && V) {
          const [I, U] = mv({
            nodeId: R,
            dragItems: u,
            nodeLookup: q,
            dragging: !1
          });
          o?.(F.sourceEvent, u, I, U), P?.(F.sourceEvent, I, U), R || V?.(F.sourceEvent, U);
        }
      }
    }).filter((F) => {
      const q = F.target;
      return !F.button && (!E || !OA(q, `.${E}`, k)) && (!A || OA(q, A, k));
    });
    g.call(M);
  }
  function S() {
    g?.on(".drag", null);
  }
  return {
    update: v,
    destroy: S
  };
}
function Pte(e, t, n) {
  const r = [], o = {
    x: e.x - n,
    y: e.y - n,
    width: n * 2,
    height: n * 2
  };
  for (const a of t.values())
    Yc(o, Rl(a)) > 0 && r.push(a);
  return r;
}
const Ite = 250;
function zte(e, t, n, r) {
  let o = [], a = 1 / 0;
  const s = Pte(e, n, t + Ite);
  for (const u of s) {
    const c = [...u.internals.handleBounds?.source ?? [], ...u.internals.handleBounds?.target ?? []];
    for (const f of c) {
      if (r.nodeId === f.nodeId && r.type === f.type && r.id === f.id)
        continue;
      const { x: h, y: p } = Wc(u, f, f.position, !0), g = Math.sqrt(Math.pow(h - e.x, 2) + Math.pow(p - e.y, 2));
      g > t || (g < a ? (o = [{ ...f, x: h, y: p }], a = g) : g === a && o.push({ ...f, x: h, y: p }));
    }
  }
  if (!o.length)
    return null;
  if (o.length > 1) {
    const u = r.type === "source" ? "target" : "source";
    return o.find((c) => c.type === u) ?? o[0];
  }
  return o[0];
}
function N5(e, t, n, r, o, a = !1) {
  const s = r.get(e);
  if (!s)
    return null;
  const u = o === "strict" ? s.internals.handleBounds?.[t] : [...s.internals.handleBounds?.source ?? [], ...s.internals.handleBounds?.target ?? []], c = (n ? u?.find((f) => f.id === n) : u?.[0]) ?? null;
  return c && a ? { ...c, ...Wc(s, c, c.position, !0) } : c;
}
function D5(e, t) {
  return e || (t?.classList.contains("target") ? "target" : t?.classList.contains("source") ? "source" : null);
}
function Lte(e, t) {
  let n = null;
  return t ? n = !0 : e && !t && (n = !1), n;
}
const j5 = () => !0;
function Fte(e, { connectionMode: t, connectionRadius: n, handleId: r, nodeId: o, edgeUpdaterType: a, isTarget: s, domNode: u, nodeLookup: c, lib: f, autoPanOnConnect: h, flowId: p, panBy: g, cancelConnection: y, onConnectStart: w, onConnect: v, onConnectEnd: S, isValidConnection: E = j5, onReconnectEnd: A, updateConnection: k, getTransform: T, getFromHandle: R, autoPanSpeed: N, dragThreshold: j = 1 }) {
  const z = S5(e.target);
  let B = 0, M;
  const { x: F, y: q } = fo(e), Y = z?.elementFromPoint(F, q), P = D5(a, Y), V = u?.getBoundingClientRect();
  let I = !1;
  if (!V || !P)
    return;
  const U = N5(o, P, r, c, t);
  if (!U)
    return;
  let H = fo(e, V), G = !1, O = null, W = !1, Z = null;
  function L() {
    if (!h || !V)
      return;
    const [De, we] = b5(H, V, N);
    g({ x: De, y: we }), B = requestAnimationFrame(L);
  }
  const te = {
    ...U,
    nodeId: o,
    type: P,
    position: U.position
  }, he = c.get(o);
  let fe = {
    inProgress: !0,
    isValid: null,
    from: Wc(he, te, Ee.Left, !0),
    fromHandle: te,
    fromPosition: te.position,
    fromNode: he,
    to: H,
    toHandle: null,
    toPosition: bA[te.position],
    toNode: null
  };
  function ae() {
    I = !0, k(fe), w?.(e, { nodeId: o, handleId: r, handleType: P });
  }
  j === 0 && ae();
  function ye(De) {
    if (!I) {
      const { x: Xe, y: St } = fo(De), ct = Xe - F, cn = St - q;
      if (!(ct * ct + cn * cn > j * j))
        return;
      ae();
    }
    if (!R() || !te) {
      Ne(De);
      return;
    }
    const we = T();
    H = fo(De, V), M = zte(wf(H, we, !1, [1, 1]), n, c, te), G || (L(), G = !0);
    const Ce = P5(De, {
      handle: M,
      connectionMode: t,
      fromNodeId: o,
      fromHandleId: r,
      fromType: s ? "target" : "source",
      isValidConnection: E,
      doc: z,
      lib: f,
      flowId: p,
      nodeLookup: c
    });
    Z = Ce.handleDomNode, O = Ce.connection, W = Lte(!!M, Ce.isValid);
    const _e = {
      // from stays the same
      ...fe,
      isValid: W,
      to: Ce.toHandle && W ? Tp({ x: Ce.toHandle.x, y: Ce.toHandle.y }, we) : H,
      toHandle: Ce.toHandle,
      toPosition: W && Ce.toHandle ? Ce.toHandle.position : bA[te.position],
      toNode: Ce.toHandle ? c.get(Ce.toHandle.nodeId) : null
    };
    W && M && fe.toHandle && _e.toHandle && fe.toHandle.type === _e.toHandle.type && fe.toHandle.nodeId === _e.toHandle.nodeId && fe.toHandle.id === _e.toHandle.id && fe.to.x === _e.to.x && fe.to.y === _e.to.y || (k(_e), fe = _e);
  }
  function Ne(De) {
    if (I) {
      (M || Z) && O && W && v?.(O);
      const { inProgress: we, ...Ce } = fe, _e = {
        ...Ce,
        toPosition: fe.toHandle ? fe.toPosition : null
      };
      S?.(De, _e), a && A?.(De, _e);
    }
    y(), cancelAnimationFrame(B), G = !1, W = !1, O = null, Z = null, z.removeEventListener("mousemove", ye), z.removeEventListener("mouseup", Ne), z.removeEventListener("touchmove", ye), z.removeEventListener("touchend", Ne);
  }
  z.addEventListener("mousemove", ye), z.addEventListener("mouseup", Ne), z.addEventListener("touchmove", ye), z.addEventListener("touchend", Ne);
}
function P5(e, { handle: t, connectionMode: n, fromNodeId: r, fromHandleId: o, fromType: a, doc: s, lib: u, flowId: c, isValidConnection: f = j5, nodeLookup: h }) {
  const p = a === "target", g = t ? s.querySelector(`.${u}-flow__handle[data-id="${c}-${t?.nodeId}-${t?.id}-${t?.type}"]`) : null, { x: y, y: w } = fo(e), v = s.elementFromPoint(y, w), S = v?.classList.contains(`${u}-flow__handle`) ? v : g, E = {
    handleDomNode: S,
    isValid: !1,
    connection: null,
    toHandle: null
  };
  if (S) {
    const A = D5(void 0, S), k = S.getAttribute("data-nodeid"), T = S.getAttribute("data-handleid"), R = S.classList.contains("connectable"), N = S.classList.contains("connectableend");
    if (!k || !A)
      return E;
    const j = {
      source: p ? k : r,
      sourceHandle: p ? T : o,
      target: p ? r : k,
      targetHandle: p ? o : T
    };
    E.connection = j;
    const B = R && N && (n === Tl.Strict ? p && A === "source" || !p && A === "target" : k !== r || T !== o);
    E.isValid = B && f(j), E.toHandle = N5(k, A, T, h, n, !0);
  }
  return E;
}
const Hb = {
  onPointerDown: Fte,
  isValid: P5
};
function $te({ domNode: e, panZoom: t, getTransform: n, getViewScale: r }) {
  const o = rr(e);
  function a({ translateExtent: u, width: c, height: f, zoomStep: h = 10, pannable: p = !0, zoomable: g = !0, inversePan: y = !1 }) {
    const w = (k) => {
      const T = n();
      if (k.sourceEvent.type !== "wheel" || !t)
        return;
      const R = -k.sourceEvent.deltaY * (k.sourceEvent.deltaMode === 1 ? 0.05 : k.sourceEvent.deltaMode ? 1 : 2e-3) * h, N = T[2] * Math.pow(2, R);
      t.scaleTo(N);
    };
    let v = [0, 0];
    const S = (k) => {
      (k.sourceEvent.type === "mousedown" || k.sourceEvent.type === "touchstart") && (v = [
        k.sourceEvent.clientX ?? k.sourceEvent.touches[0].clientX,
        k.sourceEvent.clientY ?? k.sourceEvent.touches[0].clientY
      ]);
    }, E = (k) => {
      const T = n();
      if (k.sourceEvent.type !== "mousemove" && k.sourceEvent.type !== "touchmove" || !t)
        return;
      const R = [
        k.sourceEvent.clientX ?? k.sourceEvent.touches[0].clientX,
        k.sourceEvent.clientY ?? k.sourceEvent.touches[0].clientY
      ], N = [R[0] - v[0], R[1] - v[1]];
      v = R;
      const j = r() * Math.max(T[2], Math.log(T[2])) * (y ? -1 : 1), z = {
        x: T[0] - N[0] * j,
        y: T[1] - N[1] * j
      }, B = [
        [0, 0],
        [c, f]
      ];
      t.setViewportConstrained({
        x: z.x,
        y: z.y,
        zoom: T[2]
      }, B, u);
    }, A = f5().on("start", S).on("zoom", p ? E : null).on("zoom.wheel", g ? w : null);
    o.call(A, {});
  }
  function s() {
    o.on("zoom", null);
  }
  return {
    update: a,
    destroy: s,
    pointer: Dr
  };
}
const Bte = (e, t) => e.x !== t.x || e.y !== t.y || e.zoom !== t.k, Lm = (e) => ({
  x: e.x,
  y: e.y,
  zoom: e.k
}), gv = ({ x: e, y: t, zoom: n }) => jm.translate(e, t).scale(n), il = (e, t) => e.target.closest(`.${t}`), I5 = (e, t) => t === 2 && Array.isArray(e) && e.includes(2), Hte = (e) => ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2, yv = (e, t = 0, n = Hte, r = () => {
}) => {
  const o = typeof t == "number" && t > 0;
  return o || r(), o ? e.transition().duration(t).ease(n).on("end", r) : e;
}, z5 = (e) => {
  const t = e.ctrlKey && Ap() ? 10 : 1;
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * t;
};
function Vte({ zoomPanValues: e, noWheelClassName: t, d3Selection: n, d3Zoom: r, panOnScrollMode: o, panOnScrollSpeed: a, zoomOnPinch: s, onPanZoomStart: u, onPanZoom: c, onPanZoomEnd: f }) {
  return (h) => {
    if (il(h, t))
      return !1;
    h.preventDefault(), h.stopImmediatePropagation();
    const p = n.property("__zoom").k || 1;
    if (h.ctrlKey && s) {
      const S = Dr(h), E = z5(h), A = p * Math.pow(2, E);
      r.scaleTo(n, A, S, h);
      return;
    }
    const g = h.deltaMode === 1 ? 20 : 1;
    let y = o === Ba.Vertical ? 0 : h.deltaX * g, w = o === Ba.Horizontal ? 0 : h.deltaY * g;
    !Ap() && h.shiftKey && o !== Ba.Vertical && (y = h.deltaY * g, w = 0), r.translateBy(
      n,
      -(y / p) * a,
      -(w / p) * a,
      // @ts-ignore
      { internal: !0 }
    );
    const v = Lm(n.property("__zoom"));
    clearTimeout(e.panScrollTimeout), e.isPanScrolling || (e.isPanScrolling = !0, u?.(h, v)), e.isPanScrolling && (c?.(h, v), e.panScrollTimeout = setTimeout(() => {
      f?.(h, v), e.isPanScrolling = !1;
    }, 150));
  };
}
function Ute({ noWheelClassName: e, preventScrolling: t, d3ZoomHandler: n }) {
  return function(r, o) {
    const a = r.type === "wheel", s = !t && a && !r.ctrlKey, u = il(r, e);
    if (r.ctrlKey && a && u && r.preventDefault(), s || u)
      return null;
    r.preventDefault(), n.call(this, r, o);
  };
}
function qte({ zoomPanValues: e, onDraggingChange: t, onPanZoomStart: n }) {
  return (r) => {
    if (r.sourceEvent?.internal)
      return;
    const o = Lm(r.transform);
    e.mouseButton = r.sourceEvent?.button || 0, e.isZoomingOrPanning = !0, e.prevViewport = o, r.sourceEvent?.type === "mousedown" && t(!0), n && n?.(r.sourceEvent, o);
  };
}
function Gte({ zoomPanValues: e, panOnDrag: t, onPaneContextMenu: n, onTransformChange: r, onPanZoom: o }) {
  return (a) => {
    e.usedRightMouseButton = !!(n && I5(t, e.mouseButton ?? 0)), a.sourceEvent?.sync || r([a.transform.x, a.transform.y, a.transform.k]), o && !a.sourceEvent?.internal && o?.(a.sourceEvent, Lm(a.transform));
  };
}
function Yte({ zoomPanValues: e, panOnDrag: t, panOnScroll: n, onDraggingChange: r, onPanZoomEnd: o, onPaneContextMenu: a }) {
  return (s) => {
    if (!s.sourceEvent?.internal && (e.isZoomingOrPanning = !1, a && I5(t, e.mouseButton ?? 0) && !e.usedRightMouseButton && s.sourceEvent && a(s.sourceEvent), e.usedRightMouseButton = !1, r(!1), o && Bte(e.prevViewport, s.transform))) {
      const u = Lm(s.transform);
      e.prevViewport = u, clearTimeout(e.timerId), e.timerId = setTimeout(
        () => {
          o?.(s.sourceEvent, u);
        },
        // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
        n ? 150 : 0
      );
    }
  };
}
function Wte({ zoomActivationKeyPressed: e, zoomOnScroll: t, zoomOnPinch: n, panOnDrag: r, panOnScroll: o, zoomOnDoubleClick: a, userSelectionActive: s, noWheelClassName: u, noPanClassName: c, lib: f }) {
  return (h) => {
    const p = e || t, g = n && h.ctrlKey;
    if (h.button === 1 && h.type === "mousedown" && (il(h, `${f}-flow__node`) || il(h, `${f}-flow__edge`)))
      return !0;
    if (!r && !p && !o && !a && !n || s || il(h, u) && h.type === "wheel" || il(h, c) && (h.type !== "wheel" || o && h.type === "wheel" && !e) || !n && h.ctrlKey && h.type === "wheel")
      return !1;
    if (!n && h.type === "touchstart" && h.touches?.length > 1)
      return h.preventDefault(), !1;
    if (!p && !o && !g && h.type === "wheel" || !r && (h.type === "mousedown" || h.type === "touchstart") || Array.isArray(r) && !r.includes(h.button) && h.type === "mousedown")
      return !1;
    const y = Array.isArray(r) && r.includes(h.button) || !h.button || h.button <= 1;
    return (!h.ctrlKey || h.type === "wheel") && y;
  };
}
function Xte({ domNode: e, minZoom: t, maxZoom: n, paneClickDistance: r, translateExtent: o, viewport: a, onPanZoom: s, onPanZoomStart: u, onPanZoomEnd: c, onDraggingChange: f }) {
  const h = {
    isZoomingOrPanning: !1,
    usedRightMouseButton: !1,
    prevViewport: { x: 0, y: 0, zoom: 0 },
    mouseButton: 0,
    timerId: void 0,
    panScrollTimeout: void 0,
    isPanScrolling: !1
  }, p = e.getBoundingClientRect(), g = f5().clickDistance(!Ir(r) || r < 0 ? 0 : r).scaleExtent([t, n]).translateExtent(o), y = rr(e).call(g);
  k({
    x: a.x,
    y: a.y,
    zoom: Al(a.zoom, t, n)
  }, [
    [0, 0],
    [p.width, p.height]
  ], o);
  const w = y.on("wheel.zoom"), v = y.on("dblclick.zoom");
  g.wheelDelta(z5);
  function S(q, Y) {
    return y ? new Promise((P) => {
      g?.interpolate(Y?.interpolate === "linear" ? wc : Gh).transform(yv(y, Y?.duration, Y?.ease, () => P(!0)), q);
    }) : Promise.resolve(!1);
  }
  function E({ noWheelClassName: q, noPanClassName: Y, onPaneContextMenu: P, userSelectionActive: V, panOnScroll: I, panOnDrag: U, panOnScrollMode: H, panOnScrollSpeed: G, preventScrolling: O, zoomOnPinch: W, zoomOnScroll: Z, zoomOnDoubleClick: L, zoomActivationKeyPressed: te, lib: he, onTransformChange: oe }) {
    V && !h.isZoomingOrPanning && A();
    const ae = I && !te && !V ? Vte({
      zoomPanValues: h,
      noWheelClassName: q,
      d3Selection: y,
      d3Zoom: g,
      panOnScrollMode: H,
      panOnScrollSpeed: G,
      zoomOnPinch: W,
      onPanZoomStart: u,
      onPanZoom: s,
      onPanZoomEnd: c
    }) : Ute({
      noWheelClassName: q,
      preventScrolling: O,
      d3ZoomHandler: w
    });
    if (y.on("wheel.zoom", ae, { passive: !1 }), !V) {
      const Ne = qte({
        zoomPanValues: h,
        onDraggingChange: f,
        onPanZoomStart: u
      });
      g.on("start", Ne);
      const De = Gte({
        zoomPanValues: h,
        panOnDrag: U,
        onPaneContextMenu: !!P,
        onPanZoom: s,
        onTransformChange: oe
      });
      g.on("zoom", De);
      const we = Yte({
        zoomPanValues: h,
        panOnDrag: U,
        panOnScroll: I,
        onPaneContextMenu: P,
        onPanZoomEnd: c,
        onDraggingChange: f
      });
      g.on("end", we);
    }
    const ye = Wte({
      zoomActivationKeyPressed: te,
      panOnDrag: U,
      zoomOnScroll: Z,
      panOnScroll: I,
      zoomOnDoubleClick: L,
      zoomOnPinch: W,
      userSelectionActive: V,
      noPanClassName: Y,
      noWheelClassName: q,
      lib: he
    });
    g.filter(ye), L ? y.on("dblclick.zoom", v) : y.on("dblclick.zoom", null);
  }
  function A() {
    g.on("zoom", null);
  }
  async function k(q, Y, P) {
    const V = gv(q), I = g?.constrain()(V, Y, P);
    return I && await S(I), new Promise((U) => U(I));
  }
  async function T(q, Y) {
    const P = gv(q);
    return await S(P, Y), new Promise((V) => V(P));
  }
  function R(q) {
    if (y) {
      const Y = gv(q), P = y.property("__zoom");
      (P.k !== q.zoom || P.x !== q.x || P.y !== q.y) && g?.transform(y, Y, null, { sync: !0 });
    }
  }
  function N() {
    const q = y ? c5(y.node()) : { x: 0, y: 0, k: 1 };
    return { x: q.x, y: q.y, zoom: q.k };
  }
  function j(q, Y) {
    return y ? new Promise((P) => {
      g?.interpolate(Y?.interpolate === "linear" ? wc : Gh).scaleTo(yv(y, Y?.duration, Y?.ease, () => P(!0)), q);
    }) : Promise.resolve(!1);
  }
  function z(q, Y) {
    return y ? new Promise((P) => {
      g?.interpolate(Y?.interpolate === "linear" ? wc : Gh).scaleBy(yv(y, Y?.duration, Y?.ease, () => P(!0)), q);
    }) : Promise.resolve(!1);
  }
  function B(q) {
    g?.scaleExtent(q);
  }
  function M(q) {
    g?.translateExtent(q);
  }
  function F(q) {
    const Y = !Ir(q) || q < 0 ? 0 : q;
    g?.clickDistance(Y);
  }
  return {
    update: E,
    destroy: A,
    setViewport: T,
    setViewportConstrained: k,
    getViewport: N,
    scaleTo: j,
    scaleBy: z,
    setScaleExtent: B,
    setTranslateExtent: M,
    syncViewport: R,
    setClickDistance: F
  };
}
var Ol;
(function(e) {
  e.Line = "line", e.Handle = "handle";
})(Ol || (Ol = {}));
function Kte({ width: e, prevWidth: t, height: n, prevHeight: r, affectsX: o, affectsY: a }) {
  const s = e - t, u = n - r, c = [s > 0 ? 1 : s < 0 ? -1 : 0, u > 0 ? 1 : u < 0 ? -1 : 0];
  return s && o && (c[0] = c[0] * -1), u && a && (c[1] = c[1] * -1), c;
}
function Zte(e) {
  const t = e.includes("right") || e.includes("left"), n = e.includes("bottom") || e.includes("top"), r = e.includes("left"), o = e.includes("top");
  return {
    isHorizontal: t,
    isVertical: n,
    affectsX: r,
    affectsY: o
  };
}
function Vi(e, t) {
  return Math.max(0, t - e);
}
function Ui(e, t) {
  return Math.max(0, e - t);
}
function wh(e, t, n) {
  return Math.max(0, t - e, e - n);
}
function NA(e, t) {
  return e ? !t : t;
}
function Qte(e, t, n, r, o, a, s, u) {
  let { affectsX: c, affectsY: f } = t;
  const { isHorizontal: h, isVertical: p } = t, g = h && p, { xSnapped: y, ySnapped: w } = n, { minWidth: v, maxWidth: S, minHeight: E, maxHeight: A } = r, { x: k, y: T, width: R, height: N, aspectRatio: j } = e;
  let z = Math.floor(h ? y - e.pointerX : 0), B = Math.floor(p ? w - e.pointerY : 0);
  const M = R + (c ? -z : z), F = N + (f ? -B : B), q = -a[0] * R, Y = -a[1] * N;
  let P = wh(M, v, S), V = wh(F, E, A);
  if (s) {
    let H = 0, G = 0;
    c && z < 0 ? H = Vi(k + z + q, s[0][0]) : !c && z > 0 && (H = Ui(k + M + q, s[1][0])), f && B < 0 ? G = Vi(T + B + Y, s[0][1]) : !f && B > 0 && (G = Ui(T + F + Y, s[1][1])), P = Math.max(P, H), V = Math.max(V, G);
  }
  if (u) {
    let H = 0, G = 0;
    c && z > 0 ? H = Ui(k + z, u[0][0]) : !c && z < 0 && (H = Vi(k + M, u[1][0])), f && B > 0 ? G = Ui(T + B, u[0][1]) : !f && B < 0 && (G = Vi(T + F, u[1][1])), P = Math.max(P, H), V = Math.max(V, G);
  }
  if (o) {
    if (h) {
      const H = wh(M / j, E, A) * j;
      if (P = Math.max(P, H), s) {
        let G = 0;
        !c && !f || c && !f && g ? G = Ui(T + Y + M / j, s[1][1]) * j : G = Vi(T + Y + (c ? z : -z) / j, s[0][1]) * j, P = Math.max(P, G);
      }
      if (u) {
        let G = 0;
        !c && !f || c && !f && g ? G = Vi(T + M / j, u[1][1]) * j : G = Ui(T + (c ? z : -z) / j, u[0][1]) * j, P = Math.max(P, G);
      }
    }
    if (p) {
      const H = wh(F * j, v, S) / j;
      if (V = Math.max(V, H), s) {
        let G = 0;
        !c && !f || f && !c && g ? G = Ui(k + F * j + q, s[1][0]) / j : G = Vi(k + (f ? B : -B) * j + q, s[0][0]) / j, V = Math.max(V, G);
      }
      if (u) {
        let G = 0;
        !c && !f || f && !c && g ? G = Vi(k + F * j, u[1][0]) / j : G = Ui(k + (f ? B : -B) * j, u[0][0]) / j, V = Math.max(V, G);
      }
    }
  }
  B = B + (B < 0 ? V : -V), z = z + (z < 0 ? P : -P), o && (g ? M > F * j ? B = (NA(c, f) ? -z : z) / j : z = (NA(c, f) ? -B : B) * j : h ? (B = z / j, f = c) : (z = B * j, c = f));
  const I = c ? k + z : k, U = f ? T + B : T;
  return {
    width: R + (c ? -z : z),
    height: N + (f ? -B : B),
    x: a[0] * z * (c ? -1 : 1) + I,
    y: a[1] * B * (f ? -1 : 1) + U
  };
}
const L5 = { width: 0, height: 0, x: 0, y: 0 }, Jte = {
  ...L5,
  pointerX: 0,
  pointerY: 0,
  aspectRatio: 1
};
function ene(e) {
  return [
    [0, 0],
    [e.measured.width, e.measured.height]
  ];
}
function tne(e, t, n) {
  const r = t.position.x + e.position.x, o = t.position.y + e.position.y, a = e.measured.width ?? 0, s = e.measured.height ?? 0, u = n[0] * a, c = n[1] * s;
  return [
    [r - u, o - c],
    [r + a - u, o + s - c]
  ];
}
function nne({ domNode: e, nodeId: t, getStoreItems: n, onChange: r, onEnd: o }) {
  const a = rr(e);
  function s({ controlPosition: c, boundaries: f, keepAspectRatio: h, resizeDirection: p, onResizeStart: g, onResize: y, onResizeEnd: w, shouldResize: v }) {
    let S = { ...L5 }, E = { ...Jte };
    const A = Zte(c);
    let k, T = null, R = [], N, j, z;
    const B = K3().on("start", (M) => {
      const { nodeLookup: F, transform: q, snapGrid: Y, snapToGrid: P, nodeOrigin: V, paneDomNode: I } = n();
      if (k = F.get(t), !k)
        return;
      T = I?.getBoundingClientRect() ?? null;
      const { xSnapped: U, ySnapped: H } = _c(M.sourceEvent, {
        transform: q,
        snapGrid: Y,
        snapToGrid: P,
        containerBounds: T
      });
      S = {
        width: k.measured.width ?? 0,
        height: k.measured.height ?? 0,
        x: k.position.x ?? 0,
        y: k.position.y ?? 0
      }, E = {
        ...S,
        pointerX: U,
        pointerY: H,
        aspectRatio: S.width / S.height
      }, N = void 0, k.parentId && (k.extent === "parent" || k.expandParent) && (N = F.get(k.parentId), j = N && k.extent === "parent" ? ene(N) : void 0), R = [], z = void 0;
      for (const [G, O] of F)
        if (O.parentId === t && (R.push({
          id: G,
          position: { ...O.position },
          extent: O.extent
        }), O.extent === "parent" || O.expandParent)) {
          const W = tne(O, k, O.origin ?? V);
          z ? z = [
            [Math.min(W[0][0], z[0][0]), Math.min(W[0][1], z[0][1])],
            [Math.max(W[1][0], z[1][0]), Math.max(W[1][1], z[1][1])]
          ] : z = W;
        }
      g?.(M, { ...S });
    }).on("drag", (M) => {
      const { transform: F, snapGrid: q, snapToGrid: Y, nodeOrigin: P } = n(), V = _c(M.sourceEvent, {
        transform: F,
        snapGrid: q,
        snapToGrid: Y,
        containerBounds: T
      }), I = [];
      if (!k)
        return;
      const { x: U, y: H, width: G, height: O } = S, W = {}, Z = k.origin ?? P, { width: L, height: te, x: he, y: oe } = Qte(E, A, V, f, h, Z, j, z), fe = L !== G, ae = te !== O, ye = he !== U && fe, Ne = oe !== H && ae;
      if (!ye && !Ne && !fe && !ae)
        return;
      if ((ye || Ne || Z[0] === 1 || Z[1] === 1) && (W.x = ye ? he : S.x, W.y = Ne ? oe : S.y, S.x = W.x, S.y = W.y, R.length > 0)) {
        const _e = he - U, Xe = oe - H;
        for (const St of R)
          St.position = {
            x: St.position.x - _e + Z[0] * (L - G),
            y: St.position.y - Xe + Z[1] * (te - O)
          }, I.push(St);
      }
      if ((fe || ae) && (W.width = fe && (!p || p === "horizontal") ? L : S.width, W.height = ae && (!p || p === "vertical") ? te : S.height, S.width = W.width, S.height = W.height), N && k.expandParent) {
        const _e = Z[0] * (W.width ?? 0);
        W.x && W.x < _e && (S.x = _e, E.x = E.x - (W.x - _e));
        const Xe = Z[1] * (W.height ?? 0);
        W.y && W.y < Xe && (S.y = Xe, E.y = E.y - (W.y - Xe));
      }
      const De = Kte({
        width: S.width,
        prevWidth: G,
        height: S.height,
        prevHeight: O,
        affectsX: A.affectsX,
        affectsY: A.affectsY
      }), we = { ...S, direction: De };
      v?.(M, we) !== !1 && (y?.(M, we), r(W, I));
    }).on("end", (M) => {
      w?.(M, { ...S }), o?.({ ...S });
    });
    a.call(B);
  }
  function u() {
    a.on(".drag", null);
  }
  return {
    update: s,
    destroy: u
  };
}
const { useDebugValue: rne } = nn, { useSyncExternalStoreWithSelector: one } = r3, ine = (e) => e;
function F5(e, t = ine, n) {
  const r = one(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return rne(r), r;
}
const DA = (e, t) => {
  const n = n3(e), r = (o, a = t) => F5(n, o, a);
  return Object.assign(r, n), r;
}, ane = (e, t) => e ? DA(e, t) : DA;
function At(e, t) {
  if (Object.is(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  if (e instanceof Map && t instanceof Map) {
    if (e.size !== t.size) return !1;
    for (const [r, o] of e)
      if (!Object.is(o, t.get(r)))
        return !1;
    return !0;
  }
  if (e instanceof Set && t instanceof Set) {
    if (e.size !== t.size) return !1;
    for (const r of e)
      if (!t.has(r))
        return !1;
    return !0;
  }
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
    return !1;
  for (const r of n)
    if (!Object.prototype.hasOwnProperty.call(t, r) || !Object.is(e[r], t[r]))
      return !1;
  return !0;
}
const Fm = _.createContext(null), sne = Fm.Provider, $5 = vo.error001();
function Je(e, t) {
  const n = _.useContext(Fm);
  if (n === null)
    throw new Error($5);
  return F5(n, e, t);
}
function kt() {
  const e = _.useContext(Fm);
  if (e === null)
    throw new Error($5);
  return _.useMemo(() => ({
    getState: e.getState,
    setState: e.setState,
    subscribe: e.subscribe
  }), [e]);
}
const jA = { display: "none" }, lne = {
  position: "absolute",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0px, 0px, 0px, 0px)",
  clipPath: "inset(100%)"
}, B5 = "react-flow__node-desc", H5 = "react-flow__edge-desc", une = "react-flow__aria-live", cne = (e) => e.ariaLiveMessage, fne = (e) => e.ariaLabelConfig;
function dne({ rfId: e }) {
  const t = Je(cne);
  return b.jsx("div", { id: `${une}-${e}`, "aria-live": "assertive", "aria-atomic": "true", style: lne, children: t });
}
function hne({ rfId: e, disableKeyboardA11y: t }) {
  const n = Je(fne);
  return b.jsxs(b.Fragment, { children: [b.jsx("div", { id: `${B5}-${e}`, style: jA, children: t ? n["node.a11yDescription.default"] : n["node.a11yDescription.keyboardDisabled"] }), b.jsx("div", { id: `${H5}-${e}`, style: jA, children: n["edge.a11yDescription.default"] }), !t && b.jsx(dne, { rfId: e })] });
}
const $m = _.forwardRef(({ position: e = "top-left", children: t, className: n, style: r, ...o }, a) => {
  const s = `${e}`.split("-");
  return b.jsx("div", { className: Wt(["react-flow__panel", n, ...s]), style: r, ref: a, ...o, children: t });
});
$m.displayName = "Panel";
function pne({ proOptions: e, position: t = "bottom-right" }) {
  return e?.hideAttribution ? null : b.jsx($m, { position: t, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev", children: b.jsx("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution", children: "React Flow" }) });
}
const mne = (e) => {
  const t = [], n = [];
  for (const [, r] of e.nodeLookup)
    r.selected && t.push(r.internals.userNode);
  for (const [, r] of e.edgeLookup)
    r.selected && n.push(r);
  return { selectedNodes: t, selectedEdges: n };
}, _h = (e) => e.id;
function gne(e, t) {
  return At(e.selectedNodes.map(_h), t.selectedNodes.map(_h)) && At(e.selectedEdges.map(_h), t.selectedEdges.map(_h));
}
function yne({ onSelectionChange: e }) {
  const t = kt(), { selectedNodes: n, selectedEdges: r } = Je(mne, gne);
  return _.useEffect(() => {
    const o = { nodes: n, edges: r };
    e?.(o), t.getState().onSelectionChangeHandlers.forEach((a) => a(o));
  }, [n, r, e]), null;
}
const vne = (e) => !!e.onSelectionChangeHandlers;
function bne({ onSelectionChange: e }) {
  const t = Je(vne);
  return e || t ? b.jsx(yne, { onSelectionChange: e }) : null;
}
const V5 = [0, 0], xne = { x: 0, y: 0, zoom: 1 }, wne = [
  "nodes",
  "edges",
  "defaultNodes",
  "defaultEdges",
  "onConnect",
  "onConnectStart",
  "onConnectEnd",
  "onClickConnectStart",
  "onClickConnectEnd",
  "nodesDraggable",
  "autoPanOnNodeFocus",
  "nodesConnectable",
  "nodesFocusable",
  "edgesFocusable",
  "edgesReconnectable",
  "elevateNodesOnSelect",
  "elevateEdgesOnSelect",
  "minZoom",
  "maxZoom",
  "nodeExtent",
  "onNodesChange",
  "onEdgesChange",
  "elementsSelectable",
  "connectionMode",
  "snapGrid",
  "snapToGrid",
  "translateExtent",
  "connectOnClick",
  "defaultEdgeOptions",
  "fitView",
  "fitViewOptions",
  "onNodesDelete",
  "onEdgesDelete",
  "onDelete",
  "onNodeDrag",
  "onNodeDragStart",
  "onNodeDragStop",
  "onSelectionDrag",
  "onSelectionDragStart",
  "onSelectionDragStop",
  "onMoveStart",
  "onMove",
  "onMoveEnd",
  "noPanClassName",
  "nodeOrigin",
  "autoPanOnConnect",
  "autoPanOnNodeDrag",
  "onError",
  "connectionRadius",
  "isValidConnection",
  "selectNodesOnDrag",
  "nodeDragThreshold",
  "connectionDragThreshold",
  "onBeforeDelete",
  "debug",
  "autoPanSpeed",
  "paneClickDistance",
  "ariaLabelConfig"
], PA = [...wne, "rfId"], _ne = (e) => ({
  setNodes: e.setNodes,
  setEdges: e.setEdges,
  setMinZoom: e.setMinZoom,
  setMaxZoom: e.setMaxZoom,
  setTranslateExtent: e.setTranslateExtent,
  setNodeExtent: e.setNodeExtent,
  reset: e.reset,
  setDefaultNodesAndEdges: e.setDefaultNodesAndEdges,
  setPaneClickDistance: e.setPaneClickDistance
}), IA = {
  /*
   * these are values that are also passed directly to other components
   * than the StoreUpdater. We can reduce the number of setStore calls
   * by setting the same values here as prev fields.
   */
  translateExtent: qc,
  nodeOrigin: V5,
  minZoom: 0.5,
  maxZoom: 2,
  elementsSelectable: !0,
  noPanClassName: "nopan",
  rfId: "1",
  paneClickDistance: 0
};
function Sne(e) {
  const { setNodes: t, setEdges: n, setMinZoom: r, setMaxZoom: o, setTranslateExtent: a, setNodeExtent: s, reset: u, setDefaultNodesAndEdges: c, setPaneClickDistance: f } = Je(_ne, At), h = kt();
  _.useEffect(() => (c(e.defaultNodes, e.defaultEdges), () => {
    p.current = IA, u();
  }), []);
  const p = _.useRef(IA);
  return _.useEffect(
    () => {
      for (const g of PA) {
        const y = e[g], w = p.current[g];
        y !== w && (typeof e[g] > "u" || (g === "nodes" ? t(y) : g === "edges" ? n(y) : g === "minZoom" ? r(y) : g === "maxZoom" ? o(y) : g === "translateExtent" ? a(y) : g === "nodeExtent" ? s(y) : g === "paneClickDistance" ? f(y) : g === "ariaLabelConfig" ? h.setState({ ariaLabelConfig: mte(y) }) : g === "fitView" ? h.setState({ fitViewQueued: y }) : g === "fitViewOptions" ? h.setState({ fitViewOptions: y }) : h.setState({ [g]: y })));
      }
      p.current = e;
    },
    // Only re-run the effect if one of the fields we track changes
    PA.map((g) => e[g])
  ), null;
}
function zA() {
  return typeof window > "u" || !window.matchMedia ? null : window.matchMedia("(prefers-color-scheme: dark)");
}
function Ene(e) {
  const [t, n] = _.useState(e === "system" ? null : e);
  return _.useEffect(() => {
    if (e !== "system") {
      n(e);
      return;
    }
    const r = zA(), o = () => n(r?.matches ? "dark" : "light");
    return o(), r?.addEventListener("change", o), () => {
      r?.removeEventListener("change", o);
    };
  }, [e]), t !== null ? t : zA()?.matches ? "dark" : "light";
}
const LA = typeof document < "u" ? document : null;
function Qo(e = null, t = { target: LA, actInsideInputWithModifier: !0 }) {
  const [n, r] = _.useState(!1), o = _.useRef(!1), a = _.useRef(/* @__PURE__ */ new Set([])), [s, u] = _.useMemo(() => {
    if (e !== null) {
      const f = (Array.isArray(e) ? e : [e]).filter((p) => typeof p == "string").map((p) => p.replace("+", `
`).replace(`

`, `
+`).split(`
`)), h = f.reduce((p, g) => p.concat(...g), []);
      return [f, h];
    }
    return [[], []];
  }, [e]);
  return _.useEffect(() => {
    const c = t?.target ?? LA, f = t?.actInsideInputWithModifier ?? !0;
    if (e !== null) {
      const h = (y) => {
        if (o.current = y.ctrlKey || y.metaKey || y.shiftKey || y.altKey, (!o.current || o.current && !f) && E5(y))
          return !1;
        const v = $A(y.code, u);
        if (a.current.add(y[v]), FA(s, a.current, !1)) {
          const S = y.composedPath?.()?.[0] || y.target, E = S?.nodeName === "BUTTON" || S?.nodeName === "A";
          t.preventDefault !== !1 && (o.current || !E) && y.preventDefault(), r(!0);
        }
      }, p = (y) => {
        const w = $A(y.code, u);
        FA(s, a.current, !0) ? (r(!1), a.current.clear()) : a.current.delete(y[w]), y.key === "Meta" && a.current.clear(), o.current = !1;
      }, g = () => {
        a.current.clear(), r(!1);
      };
      return c?.addEventListener("keydown", h), c?.addEventListener("keyup", p), window.addEventListener("blur", g), window.addEventListener("contextmenu", g), () => {
        c?.removeEventListener("keydown", h), c?.removeEventListener("keyup", p), window.removeEventListener("blur", g), window.removeEventListener("contextmenu", g);
      };
    }
  }, [e, r]), n;
}
function FA(e, t, n) {
  return e.filter((r) => n || r.length === t.size).some((r) => r.every((o) => t.has(o)));
}
function $A(e, t) {
  return t.includes(e) ? "code" : "key";
}
const Cne = () => {
  const e = kt();
  return _.useMemo(() => ({
    zoomIn: (t) => {
      const { panZoom: n } = e.getState();
      return n ? n.scaleBy(1.2, { duration: t?.duration }) : Promise.resolve(!1);
    },
    zoomOut: (t) => {
      const { panZoom: n } = e.getState();
      return n ? n.scaleBy(1 / 1.2, { duration: t?.duration }) : Promise.resolve(!1);
    },
    zoomTo: (t, n) => {
      const { panZoom: r } = e.getState();
      return r ? r.scaleTo(t, { duration: n?.duration }) : Promise.resolve(!1);
    },
    getZoom: () => e.getState().transform[2],
    setViewport: async (t, n) => {
      const { transform: [r, o, a], panZoom: s } = e.getState();
      return s ? (await s.setViewport({
        x: t.x ?? r,
        y: t.y ?? o,
        zoom: t.zoom ?? a
      }, n), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    getViewport: () => {
      const [t, n, r] = e.getState().transform;
      return { x: t, y: n, zoom: r };
    },
    setCenter: async (t, n, r) => e.getState().setCenter(t, n, r),
    fitBounds: async (t, n) => {
      const { width: r, height: o, minZoom: a, maxZoom: s, panZoom: u } = e.getState(), c = Rx(t, r, o, a, s, n?.padding ?? 0.1);
      return u ? (await u.setViewport(c, {
        duration: n?.duration,
        ease: n?.ease,
        interpolate: n?.interpolate
      }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    screenToFlowPosition: (t, n = {}) => {
      const { transform: r, snapGrid: o, snapToGrid: a, domNode: s } = e.getState();
      if (!s)
        return t;
      const { x: u, y: c } = s.getBoundingClientRect(), f = {
        x: t.x - u,
        y: t.y - c
      }, h = n.snapGrid ?? o, p = n.snapToGrid ?? a;
      return wf(f, r, p, h);
    },
    flowToScreenPosition: (t) => {
      const { transform: n, domNode: r } = e.getState();
      if (!r)
        return t;
      const { x: o, y: a } = r.getBoundingClientRect(), s = Tp(t, n);
      return {
        x: s.x + o,
        y: s.y + a
      };
    }
  }), []);
};
function U5(e, t) {
  const n = [], r = /* @__PURE__ */ new Map(), o = [];
  for (const a of e)
    if (a.type === "add") {
      o.push(a);
      continue;
    } else if (a.type === "remove" || a.type === "replace")
      r.set(a.id, [a]);
    else {
      const s = r.get(a.id);
      s ? s.push(a) : r.set(a.id, [a]);
    }
  for (const a of t) {
    const s = r.get(a.id);
    if (!s) {
      n.push(a);
      continue;
    }
    if (s[0].type === "remove")
      continue;
    if (s[0].type === "replace") {
      n.push({ ...s[0].item });
      continue;
    }
    const u = { ...a };
    for (const c of s)
      kne(c, u);
    n.push(u);
  }
  return o.length && o.forEach((a) => {
    a.index !== void 0 ? n.splice(a.index, 0, { ...a.item }) : n.push({ ...a.item });
  }), n;
}
function kne(e, t) {
  switch (e.type) {
    case "select": {
      t.selected = e.selected;
      break;
    }
    case "position": {
      typeof e.position < "u" && (t.position = e.position), typeof e.dragging < "u" && (t.dragging = e.dragging);
      break;
    }
    case "dimensions": {
      typeof e.dimensions < "u" && (t.measured ?? (t.measured = {}), t.measured.width = e.dimensions.width, t.measured.height = e.dimensions.height, e.setAttributes && ((e.setAttributes === !0 || e.setAttributes === "width") && (t.width = e.dimensions.width), (e.setAttributes === !0 || e.setAttributes === "height") && (t.height = e.dimensions.height))), typeof e.resizing == "boolean" && (t.resizing = e.resizing);
      break;
    }
  }
}
function Ix(e, t) {
  return U5(e, t);
}
function q5(e, t) {
  return U5(e, t);
}
function Oa(e, t) {
  return {
    id: e,
    type: "select",
    selected: t
  };
}
function al(e, t = /* @__PURE__ */ new Set(), n = !1) {
  const r = [];
  for (const [o, a] of e) {
    const s = t.has(o);
    !(a.selected === void 0 && !s) && a.selected !== s && (n && (a.selected = s), r.push(Oa(a.id, s)));
  }
  return r;
}
function BA({ items: e = [], lookup: t }) {
  const n = [], r = new Map(e.map((o) => [o.id, o]));
  for (const [o, a] of e.entries()) {
    const s = t.get(a.id), u = s?.internals?.userNode ?? s;
    u !== void 0 && u !== a && n.push({ id: a.id, item: a, type: "replace" }), u === void 0 && n.push({ item: a, type: "add", index: o });
  }
  for (const [o] of t)
    r.get(o) === void 0 && n.push({ id: o, type: "remove" });
  return n;
}
function HA(e) {
  return {
    id: e.id,
    type: "remove"
  };
}
const VA = (e) => ite(e), Tne = (e) => g5(e);
function G5(e) {
  return _.forwardRef(e);
}
const Ane = typeof window < "u" ? _.useLayoutEffect : _.useEffect;
function UA(e) {
  const [t, n] = _.useState(BigInt(0)), [r] = _.useState(() => Rne(() => n((o) => o + BigInt(1))));
  return Ane(() => {
    const o = r.get();
    o.length && (e(o), r.reset());
  }, [t]), r;
}
function Rne(e) {
  let t = [];
  return {
    get: () => t,
    reset: () => {
      t = [];
    },
    push: (n) => {
      t.push(n), e();
    }
  };
}
const Y5 = _.createContext(null);
function Mne({ children: e }) {
  const t = kt(), n = _.useCallback((u) => {
    const { nodes: c = [], setNodes: f, hasDefaultNodes: h, onNodesChange: p, nodeLookup: g, fitViewQueued: y } = t.getState();
    let w = c;
    for (const S of u)
      w = typeof S == "function" ? S(w) : S;
    const v = BA({
      items: w,
      lookup: g
    });
    h && f(w), v.length > 0 ? p?.(v) : y && window.requestAnimationFrame(() => {
      const { fitViewQueued: S, nodes: E, setNodes: A } = t.getState();
      S && A(E);
    });
  }, []), r = UA(n), o = _.useCallback((u) => {
    const { edges: c = [], setEdges: f, hasDefaultEdges: h, onEdgesChange: p, edgeLookup: g } = t.getState();
    let y = c;
    for (const w of u)
      y = typeof w == "function" ? w(y) : w;
    h ? f(y) : p && p(BA({
      items: y,
      lookup: g
    }));
  }, []), a = UA(o), s = _.useMemo(() => ({ nodeQueue: r, edgeQueue: a }), []);
  return b.jsx(Y5.Provider, { value: s, children: e });
}
function One() {
  const e = _.useContext(Y5);
  if (!e)
    throw new Error("useBatchContext must be used within a BatchProvider");
  return e;
}
const Nne = (e) => !!e.panZoom;
function ts() {
  const e = Cne(), t = kt(), n = One(), r = Je(Nne), o = _.useMemo(() => {
    const a = (p) => t.getState().nodeLookup.get(p), s = (p) => {
      n.nodeQueue.push(p);
    }, u = (p) => {
      n.edgeQueue.push(p);
    }, c = (p) => {
      const { nodeLookup: g, nodeOrigin: y } = t.getState(), w = VA(p) ? p : g.get(p.id), v = w.parentId ? _5(w.position, w.measured, w.parentId, g, y) : w.position, S = {
        ...w,
        position: v,
        width: w.measured?.width ?? w.width,
        height: w.measured?.height ?? w.height
      };
      return Rl(S);
    }, f = (p, g, y = { replace: !1 }) => {
      s((w) => w.map((v) => {
        if (v.id === p) {
          const S = typeof g == "function" ? g(v) : g;
          return y.replace && VA(S) ? S : { ...v, ...S };
        }
        return v;
      }));
    }, h = (p, g, y = { replace: !1 }) => {
      u((w) => w.map((v) => {
        if (v.id === p) {
          const S = typeof g == "function" ? g(v) : g;
          return y.replace && Tne(S) ? S : { ...v, ...S };
        }
        return v;
      }));
    };
    return {
      getNodes: () => t.getState().nodes.map((p) => ({ ...p })),
      getNode: (p) => a(p)?.internals.userNode,
      getInternalNode: a,
      getEdges: () => {
        const { edges: p = [] } = t.getState();
        return p.map((g) => ({ ...g }));
      },
      getEdge: (p) => t.getState().edgeLookup.get(p),
      setNodes: s,
      setEdges: u,
      addNodes: (p) => {
        const g = Array.isArray(p) ? p : [p];
        n.nodeQueue.push((y) => [...y, ...g]);
      },
      addEdges: (p) => {
        const g = Array.isArray(p) ? p : [p];
        n.edgeQueue.push((y) => [...y, ...g]);
      },
      toObject: () => {
        const { nodes: p = [], edges: g = [], transform: y } = t.getState(), [w, v, S] = y;
        return {
          nodes: p.map((E) => ({ ...E })),
          edges: g.map((E) => ({ ...E })),
          viewport: {
            x: w,
            y: v,
            zoom: S
          }
        };
      },
      deleteElements: async ({ nodes: p = [], edges: g = [] }) => {
        const { nodes: y, edges: w, onNodesDelete: v, onEdgesDelete: S, triggerNodeChanges: E, triggerEdgeChanges: A, onDelete: k, onBeforeDelete: T } = t.getState(), { nodes: R, edges: N } = await cte({
          nodesToRemove: p,
          edgesToRemove: g,
          nodes: y,
          edges: w,
          onBeforeDelete: T
        }), j = N.length > 0, z = R.length > 0;
        if (j) {
          const B = N.map(HA);
          S?.(N), A(B);
        }
        if (z) {
          const B = R.map(HA);
          v?.(R), E(B);
        }
        return (z || j) && k?.({ nodes: R, edges: N }), { deletedNodes: R, deletedEdges: N };
      },
      getIntersectingNodes: (p, g = !0, y) => {
        const w = wA(p), v = w ? p : c(p), S = y !== void 0;
        return v ? (y || t.getState().nodes).filter((E) => {
          const A = t.getState().nodeLookup.get(E.id);
          if (A && !w && (E.id === p.id || !A.internals.positionAbsolute))
            return !1;
          const k = Rl(S ? E : A), T = Yc(k, v);
          return g && T > 0 || T >= k.width * k.height || T >= v.width * v.height;
        }) : [];
      },
      isNodeIntersecting: (p, g, y = !0) => {
        const v = wA(p) ? p : c(p);
        if (!v)
          return !1;
        const S = Yc(v, g);
        return y && S > 0 || S >= v.width * v.height;
      },
      updateNode: f,
      updateNodeData: (p, g, y = { replace: !1 }) => {
        f(p, (w) => {
          const v = typeof g == "function" ? g(w) : g;
          return y.replace ? { ...w, data: v } : { ...w, data: { ...w.data, ...v } };
        }, y);
      },
      updateEdge: h,
      updateEdgeData: (p, g, y = { replace: !1 }) => {
        h(p, (w) => {
          const v = typeof g == "function" ? g(w) : g;
          return y.replace ? { ...w, data: v } : { ...w, data: { ...w.data, ...v } };
        }, y);
      },
      getNodesBounds: (p) => {
        const { nodeLookup: g, nodeOrigin: y } = t.getState();
        return ate(p, { nodeLookup: g, nodeOrigin: y });
      },
      getHandleConnections: ({ type: p, id: g, nodeId: y }) => Array.from(t.getState().connectionLookup.get(`${y}-${p}${g ? `-${g}` : ""}`)?.values() ?? []),
      getNodeConnections: ({ type: p, handleId: g, nodeId: y }) => Array.from(t.getState().connectionLookup.get(`${y}${p ? g ? `-${p}-${g}` : `-${p}` : ""}`)?.values() ?? []),
      fitView: async (p) => {
        const g = t.getState().fitViewResolver ?? pte();
        return t.setState({ fitViewQueued: !0, fitViewOptions: p, fitViewResolver: g }), n.nodeQueue.push((y) => [...y]), g.promise;
      }
    };
  }, []);
  return _.useMemo(() => ({
    ...o,
    ...e,
    viewportInitialized: r
  }), [r]);
}
const qA = (e) => e.selected, Dne = typeof window < "u" ? window : void 0;
function jne({ deleteKeyCode: e, multiSelectionKeyCode: t }) {
  const n = kt(), { deleteElements: r } = ts(), o = Qo(e, { actInsideInputWithModifier: !1 }), a = Qo(t, { target: Dne });
  _.useEffect(() => {
    if (o) {
      const { edges: s, nodes: u } = n.getState();
      r({ nodes: u.filter(qA), edges: s.filter(qA) }), n.setState({ nodesSelectionActive: !1 });
    }
  }, [o]), _.useEffect(() => {
    n.setState({ multiSelectionActive: a });
  }, [a]);
}
function Pne(e) {
  const t = kt();
  _.useEffect(() => {
    const n = () => {
      if (!e.current)
        return !1;
      const r = Mx(e.current);
      (r.height === 0 || r.width === 0) && t.getState().onError?.("004", vo.error004()), t.setState({ width: r.width || 500, height: r.height || 500 });
    };
    if (e.current) {
      n(), window.addEventListener("resize", n);
      const r = new ResizeObserver(() => n());
      return r.observe(e.current), () => {
        window.removeEventListener("resize", n), r && e.current && r.unobserve(e.current);
      };
    }
  }, []);
}
const Bm = {
  position: "absolute",
  width: "100%",
  height: "100%",
  top: 0,
  left: 0
}, Ine = (e) => ({
  userSelectionActive: e.userSelectionActive,
  lib: e.lib
});
function zne({ onPaneContextMenu: e, zoomOnScroll: t = !0, zoomOnPinch: n = !0, panOnScroll: r = !1, panOnScrollSpeed: o = 0.5, panOnScrollMode: a = Ba.Free, zoomOnDoubleClick: s = !0, panOnDrag: u = !0, defaultViewport: c, translateExtent: f, minZoom: h, maxZoom: p, zoomActivationKeyCode: g, preventScrolling: y = !0, children: w, noWheelClassName: v, noPanClassName: S, onViewportChange: E, isControlledViewport: A, paneClickDistance: k }) {
  const T = kt(), R = _.useRef(null), { userSelectionActive: N, lib: j } = Je(Ine, At), z = Qo(g), B = _.useRef();
  Pne(R);
  const M = _.useCallback((F) => {
    E?.({ x: F[0], y: F[1], zoom: F[2] }), A || T.setState({ transform: F });
  }, [E, A]);
  return _.useEffect(() => {
    if (R.current) {
      B.current = Xte({
        domNode: R.current,
        minZoom: h,
        maxZoom: p,
        translateExtent: f,
        viewport: c,
        paneClickDistance: k,
        onDraggingChange: (P) => T.setState({ paneDragging: P }),
        onPanZoomStart: (P, V) => {
          const { onViewportChangeStart: I, onMoveStart: U } = T.getState();
          U?.(P, V), I?.(V);
        },
        onPanZoom: (P, V) => {
          const { onViewportChange: I, onMove: U } = T.getState();
          U?.(P, V), I?.(V);
        },
        onPanZoomEnd: (P, V) => {
          const { onViewportChangeEnd: I, onMoveEnd: U } = T.getState();
          U?.(P, V), I?.(V);
        }
      });
      const { x: F, y: q, zoom: Y } = B.current.getViewport();
      return T.setState({
        panZoom: B.current,
        transform: [F, q, Y],
        domNode: R.current.closest(".react-flow")
      }), () => {
        B.current?.destroy();
      };
    }
  }, []), _.useEffect(() => {
    B.current?.update({
      onPaneContextMenu: e,
      zoomOnScroll: t,
      zoomOnPinch: n,
      panOnScroll: r,
      panOnScrollSpeed: o,
      panOnScrollMode: a,
      zoomOnDoubleClick: s,
      panOnDrag: u,
      zoomActivationKeyPressed: z,
      preventScrolling: y,
      noPanClassName: S,
      userSelectionActive: N,
      noWheelClassName: v,
      lib: j,
      onTransformChange: M
    });
  }, [
    e,
    t,
    n,
    r,
    o,
    a,
    s,
    u,
    z,
    y,
    S,
    N,
    v,
    j,
    M
  ]), b.jsx("div", { className: "react-flow__renderer", ref: R, style: Bm, children: w });
}
const Lne = (e) => ({
  userSelectionActive: e.userSelectionActive,
  userSelectionRect: e.userSelectionRect
});
function Fne() {
  const { userSelectionActive: e, userSelectionRect: t } = Je(Lne, At);
  return e && t ? b.jsx("div", { className: "react-flow__selection react-flow__container", style: {
    width: t.width,
    height: t.height,
    transform: `translate(${t.x}px, ${t.y}px)`
  } }) : null;
}
const vv = (e, t) => (n) => {
  n.target === t.current && e?.(n);
}, $ne = (e) => ({
  userSelectionActive: e.userSelectionActive,
  elementsSelectable: e.elementsSelectable,
  connectionInProgress: e.connection.inProgress,
  dragging: e.paneDragging
});
function Bne({ isSelecting: e, selectionKeyPressed: t, selectionMode: n = Gc.Full, panOnDrag: r, selectionOnDrag: o, onSelectionStart: a, onSelectionEnd: s, onPaneClick: u, onPaneContextMenu: c, onPaneScroll: f, onPaneMouseEnter: h, onPaneMouseMove: p, onPaneMouseLeave: g, children: y }) {
  const w = kt(), { userSelectionActive: v, elementsSelectable: S, dragging: E, connectionInProgress: A } = Je($ne, At), k = S && (e || v), T = _.useRef(null), R = _.useRef(), N = _.useRef(/* @__PURE__ */ new Set()), j = _.useRef(/* @__PURE__ */ new Set()), z = _.useRef(!1), B = _.useRef(!1), M = (U) => {
    if (z.current || A) {
      z.current = !1;
      return;
    }
    u?.(U), w.getState().resetSelectedElements(), w.setState({ nodesSelectionActive: !1 });
  }, F = (U) => {
    if (Array.isArray(r) && r?.includes(2)) {
      U.preventDefault();
      return;
    }
    c?.(U);
  }, q = f ? (U) => f(U) : void 0, Y = (U) => {
    const { resetSelectedElements: H, domNode: G } = w.getState();
    if (R.current = G?.getBoundingClientRect(), !S || !e || U.button !== 0 || U.target !== T.current || !R.current)
      return;
    U.target?.setPointerCapture?.(U.pointerId), B.current = !0, z.current = !1;
    const { x: O, y: W } = fo(U.nativeEvent, R.current);
    H(), w.setState({
      userSelectionRect: {
        width: 0,
        height: 0,
        startX: O,
        startY: W,
        x: O,
        y: W
      }
    }), a?.(U);
  }, P = (U) => {
    const { userSelectionRect: H, transform: G, nodeLookup: O, edgeLookup: W, connectionLookup: Z, triggerNodeChanges: L, triggerEdgeChanges: te, defaultEdgeOptions: he } = w.getState();
    if (!R.current || !H)
      return;
    z.current = !0;
    const { x: oe, y: fe } = fo(U.nativeEvent, R.current), { startX: ae, startY: ye } = H, Ne = {
      startX: ae,
      startY: ye,
      x: oe < ae ? oe : ae,
      y: fe < ye ? fe : ye,
      width: Math.abs(oe - ae),
      height: Math.abs(fe - ye)
    }, De = N.current, we = j.current;
    N.current = new Set(Ax(O, Ne, G, n === Gc.Partial, !0).map((_e) => _e.id)), j.current = /* @__PURE__ */ new Set();
    const Ce = he?.selectable ?? !0;
    for (const _e of N.current) {
      const Xe = Z.get(_e);
      if (Xe)
        for (const { edgeId: St } of Xe.values()) {
          const ct = W.get(St);
          ct && (ct.selectable ?? Ce) && j.current.add(St);
        }
    }
    if (!_A(De, N.current)) {
      const _e = al(O, N.current, !0);
      L(_e);
    }
    if (!_A(we, j.current)) {
      const _e = al(W, j.current);
      te(_e);
    }
    w.setState({
      userSelectionRect: Ne,
      userSelectionActive: !0,
      nodesSelectionActive: !1
    });
  }, V = (U) => {
    if (U.button !== 0 || !B.current)
      return;
    U.target?.releasePointerCapture?.(U.pointerId);
    const { userSelectionRect: H } = w.getState();
    !v && H && U.target === T.current && M?.(U), w.setState({
      userSelectionActive: !1,
      userSelectionRect: null,
      nodesSelectionActive: N.current.size > 0
    }), s?.(U), (t || o) && (z.current = !1), B.current = !1;
  }, I = r === !0 || Array.isArray(r) && r.includes(0);
  return b.jsxs("div", { className: Wt(["react-flow__pane", { draggable: I, dragging: E, selection: e }]), onClick: k ? void 0 : vv(M, T), onContextMenu: vv(F, T), onWheel: vv(q, T), onPointerEnter: k ? void 0 : h, onPointerDown: k ? Y : p, onPointerMove: k ? P : p, onPointerUp: k ? V : void 0, onPointerLeave: g, ref: T, style: Bm, children: [y, b.jsx(Fne, {})] });
}
function Vb({ id: e, store: t, unselect: n = !1, nodeRef: r }) {
  const { addSelectedNodes: o, unselectNodesAndEdges: a, multiSelectionActive: s, nodeLookup: u, onError: c } = t.getState(), f = u.get(e);
  if (!f) {
    c?.("012", vo.error012(e));
    return;
  }
  t.setState({ nodesSelectionActive: !1 }), f.selected ? (n || f.selected && s) && (a({ nodes: [f], edges: [] }), requestAnimationFrame(() => r?.current?.blur())) : o([e]);
}
function W5({ nodeRef: e, disabled: t = !1, noDragClassName: n, handleSelector: r, nodeId: o, isSelectable: a, nodeClickDistance: s }) {
  const u = kt(), [c, f] = _.useState(!1), h = _.useRef();
  return _.useEffect(() => {
    h.current = jte({
      getStoreItems: () => u.getState(),
      onNodeMouseDown: (p) => {
        Vb({
          id: p,
          store: u,
          nodeRef: e
        });
      },
      onDragStart: () => {
        f(!0);
      },
      onDragStop: () => {
        f(!1);
      }
    });
  }, []), _.useEffect(() => {
    if (t)
      h.current?.destroy();
    else if (e.current)
      return h.current?.update({
        noDragClassName: n,
        handleSelector: r,
        domNode: e.current,
        isSelectable: a,
        nodeId: o,
        nodeClickDistance: s
      }), () => {
        h.current?.destroy();
      };
  }, [n, r, t, a, e, o]), c;
}
const Hne = (e) => (t) => t.selected && (t.draggable || e && typeof t.draggable > "u");
function X5() {
  const e = kt();
  return _.useCallback((n) => {
    const { nodeExtent: r, snapToGrid: o, snapGrid: a, nodesDraggable: s, onError: u, updateNodePositions: c, nodeLookup: f, nodeOrigin: h } = e.getState(), p = /* @__PURE__ */ new Map(), g = Hne(s), y = o ? a[0] : 5, w = o ? a[1] : 5, v = n.direction.x * y * n.factor, S = n.direction.y * w * n.factor;
    for (const [, E] of f) {
      if (!g(E))
        continue;
      let A = {
        x: E.internals.positionAbsolute.x + v,
        y: E.internals.positionAbsolute.y + S
      };
      o && (A = zm(A, a));
      const { position: k, positionAbsolute: T } = y5({
        nodeId: E.id,
        nextPosition: A,
        nodeLookup: f,
        nodeExtent: r,
        nodeOrigin: h,
        onError: u
      });
      E.position = k, E.internals.positionAbsolute = T, p.set(E.id, E);
    }
    c(p);
  }, []);
}
const zx = _.createContext(null), Vne = zx.Provider;
zx.Consumer;
const K5 = () => _.useContext(zx), Une = (e) => ({
  connectOnClick: e.connectOnClick,
  noPanClassName: e.noPanClassName,
  rfId: e.rfId
}), qne = (e, t, n) => (r) => {
  const { connectionClickStartHandle: o, connectionMode: a, connection: s } = r, { fromHandle: u, toHandle: c, isValid: f } = s, h = c?.nodeId === e && c?.id === t && c?.type === n;
  return {
    connectingFrom: u?.nodeId === e && u?.id === t && u?.type === n,
    connectingTo: h,
    clickConnecting: o?.nodeId === e && o?.id === t && o?.type === n,
    isPossibleEndHandle: a === Tl.Strict ? u?.type !== n : e !== u?.nodeId || t !== u?.id,
    connectionInProcess: !!u,
    clickConnectionInProcess: !!o,
    valid: h && f
  };
};
function Gne({ type: e = "source", position: t = Ee.Top, isValidConnection: n, isConnectable: r = !0, isConnectableStart: o = !0, isConnectableEnd: a = !0, id: s, onConnect: u, children: c, className: f, onMouseDown: h, onTouchStart: p, ...g }, y) {
  const w = s || null, v = e === "target", S = kt(), E = K5(), { connectOnClick: A, noPanClassName: k, rfId: T } = Je(Une, At), { connectingFrom: R, connectingTo: N, clickConnecting: j, isPossibleEndHandle: z, connectionInProcess: B, clickConnectionInProcess: M, valid: F } = Je(qne(E, w, e), At);
  E || S.getState().onError?.("010", vo.error010());
  const q = (V) => {
    const { defaultEdgeOptions: I, onConnect: U, hasDefaultEdges: H } = S.getState(), G = {
      ...I,
      ...V
    };
    if (H) {
      const { edges: O, setEdges: W } = S.getState();
      W(wte(G, O));
    }
    U?.(G), u?.(G);
  }, Y = (V) => {
    if (!E)
      return;
    const I = C5(V.nativeEvent);
    if (o && (I && V.button === 0 || !I)) {
      const U = S.getState();
      Hb.onPointerDown(V.nativeEvent, {
        autoPanOnConnect: U.autoPanOnConnect,
        connectionMode: U.connectionMode,
        connectionRadius: U.connectionRadius,
        domNode: U.domNode,
        nodeLookup: U.nodeLookup,
        lib: U.lib,
        isTarget: v,
        handleId: w,
        nodeId: E,
        flowId: U.rfId,
        panBy: U.panBy,
        cancelConnection: U.cancelConnection,
        onConnectStart: U.onConnectStart,
        onConnectEnd: U.onConnectEnd,
        updateConnection: U.updateConnection,
        onConnect: q,
        isValidConnection: n || U.isValidConnection,
        getTransform: () => S.getState().transform,
        getFromHandle: () => S.getState().connection.fromHandle,
        autoPanSpeed: U.autoPanSpeed,
        dragThreshold: U.connectionDragThreshold
      });
    }
    I ? h?.(V) : p?.(V);
  }, P = (V) => {
    const { onClickConnectStart: I, onClickConnectEnd: U, connectionClickStartHandle: H, connectionMode: G, isValidConnection: O, lib: W, rfId: Z, nodeLookup: L, connection: te } = S.getState();
    if (!E || !H && !o)
      return;
    if (!H) {
      I?.(V.nativeEvent, { nodeId: E, handleId: w, handleType: e }), S.setState({ connectionClickStartHandle: { nodeId: E, type: e, id: w } });
      return;
    }
    const he = S5(V.target), oe = n || O, { connection: fe, isValid: ae } = Hb.isValid(V.nativeEvent, {
      handle: {
        nodeId: E,
        id: w,
        type: e
      },
      connectionMode: G,
      fromNodeId: H.nodeId,
      fromHandleId: H.id || null,
      fromType: H.type,
      isValidConnection: oe,
      flowId: Z,
      doc: he,
      lib: W,
      nodeLookup: L
    });
    ae && fe && q(fe);
    const ye = structuredClone(te);
    delete ye.inProgress, ye.toPosition = ye.toHandle ? ye.toHandle.position : null, U?.(V, ye), S.setState({ connectionClickStartHandle: null });
  };
  return b.jsx("div", { "data-handleid": w, "data-nodeid": E, "data-handlepos": t, "data-id": `${T}-${E}-${w}-${e}`, className: Wt([
    "react-flow__handle",
    `react-flow__handle-${t}`,
    "nodrag",
    k,
    f,
    {
      source: !v,
      target: v,
      connectable: r,
      connectablestart: o,
      connectableend: a,
      clickconnecting: j,
      connectingfrom: R,
      connectingto: N,
      valid: F,
      /*
       * shows where you can start a connection from
       * and where you can end it while connecting
       */
      connectionindicator: r && (!B || z) && (B || M ? a : o)
    }
  ]), onMouseDown: Y, onTouchStart: Y, onClick: A ? P : void 0, ref: y, ...g, children: c });
}
const Ja = _.memo(G5(Gne));
function Yne({ data: e, isConnectable: t, sourcePosition: n = Ee.Bottom }) {
  return b.jsxs(b.Fragment, { children: [e?.label, b.jsx(Ja, { type: "source", position: n, isConnectable: t })] });
}
function Wne({ data: e, isConnectable: t, targetPosition: n = Ee.Top, sourcePosition: r = Ee.Bottom }) {
  return b.jsxs(b.Fragment, { children: [b.jsx(Ja, { type: "target", position: n, isConnectable: t }), e?.label, b.jsx(Ja, { type: "source", position: r, isConnectable: t })] });
}
function Xne() {
  return null;
}
function Kne({ data: e, isConnectable: t, targetPosition: n = Ee.Top }) {
  return b.jsxs(b.Fragment, { children: [b.jsx(Ja, { type: "target", position: n, isConnectable: t }), e?.label] });
}
const Rp = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
}, GA = {
  input: Yne,
  default: Wne,
  output: Kne,
  group: Xne
};
function Zne(e) {
  return e.internals.handleBounds === void 0 ? {
    width: e.width ?? e.initialWidth ?? e.style?.width,
    height: e.height ?? e.initialHeight ?? e.style?.height
  } : {
    width: e.width ?? e.style?.width,
    height: e.height ?? e.style?.height
  };
}
const Qne = (e) => {
  const { width: t, height: n, x: r, y: o } = xf(e.nodeLookup, {
    filter: (a) => !!a.selected
  });
  return {
    width: Ir(t) ? t : null,
    height: Ir(n) ? n : null,
    userSelectionActive: e.userSelectionActive,
    transformString: `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]}) translate(${r}px,${o}px)`
  };
};
function Jne({ onSelectionContextMenu: e, noPanClassName: t, disableKeyboardA11y: n }) {
  const r = kt(), { width: o, height: a, transformString: s, userSelectionActive: u } = Je(Qne, At), c = X5(), f = _.useRef(null);
  if (_.useEffect(() => {
    n || f.current?.focus({
      preventScroll: !0
    });
  }, [n]), W5({
    nodeRef: f
  }), u || !o || !a)
    return null;
  const h = e ? (g) => {
    const y = r.getState().nodes.filter((w) => w.selected);
    e(g, y);
  } : void 0, p = (g) => {
    Object.prototype.hasOwnProperty.call(Rp, g.key) && (g.preventDefault(), c({
      direction: Rp[g.key],
      factor: g.shiftKey ? 4 : 1
    }));
  };
  return b.jsx("div", { className: Wt(["react-flow__nodesselection", "react-flow__container", t]), style: {
    transform: s
  }, children: b.jsx("div", { ref: f, className: "react-flow__nodesselection-rect", onContextMenu: h, tabIndex: n ? void 0 : -1, onKeyDown: n ? void 0 : p, style: {
    width: o,
    height: a
  } }) });
}
const YA = typeof window < "u" ? window : void 0, ere = (e) => ({ nodesSelectionActive: e.nodesSelectionActive, userSelectionActive: e.userSelectionActive });
function Z5({ children: e, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: o, onPaneContextMenu: a, onPaneScroll: s, paneClickDistance: u, deleteKeyCode: c, selectionKeyCode: f, selectionOnDrag: h, selectionMode: p, onSelectionStart: g, onSelectionEnd: y, multiSelectionKeyCode: w, panActivationKeyCode: v, zoomActivationKeyCode: S, elementsSelectable: E, zoomOnScroll: A, zoomOnPinch: k, panOnScroll: T, panOnScrollSpeed: R, panOnScrollMode: N, zoomOnDoubleClick: j, panOnDrag: z, defaultViewport: B, translateExtent: M, minZoom: F, maxZoom: q, preventScrolling: Y, onSelectionContextMenu: P, noWheelClassName: V, noPanClassName: I, disableKeyboardA11y: U, onViewportChange: H, isControlledViewport: G }) {
  const { nodesSelectionActive: O, userSelectionActive: W } = Je(ere), Z = Qo(f, { target: YA }), L = Qo(v, { target: YA }), te = L || z, he = L || T, oe = h && te !== !0, fe = Z || W || oe;
  return jne({ deleteKeyCode: c, multiSelectionKeyCode: w }), b.jsx(zne, { onPaneContextMenu: a, elementsSelectable: E, zoomOnScroll: A, zoomOnPinch: k, panOnScroll: he, panOnScrollSpeed: R, panOnScrollMode: N, zoomOnDoubleClick: j, panOnDrag: !Z && te, defaultViewport: B, translateExtent: M, minZoom: F, maxZoom: q, zoomActivationKeyCode: S, preventScrolling: Y, noWheelClassName: V, noPanClassName: I, onViewportChange: H, isControlledViewport: G, paneClickDistance: u, children: b.jsxs(Bne, { onSelectionStart: g, onSelectionEnd: y, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: o, onPaneContextMenu: a, onPaneScroll: s, panOnDrag: te, isSelecting: !!fe, selectionMode: p, selectionKeyPressed: Z, selectionOnDrag: oe, children: [e, O && b.jsx(Jne, { onSelectionContextMenu: P, noPanClassName: I, disableKeyboardA11y: U })] }) });
}
Z5.displayName = "FlowRenderer";
const tre = _.memo(Z5), nre = (e) => (t) => e ? Ax(t.nodeLookup, { x: 0, y: 0, width: t.width, height: t.height }, t.transform, !0).map((n) => n.id) : Array.from(t.nodeLookup.keys());
function rre(e) {
  return Je(_.useCallback(nre(e), [e]), At);
}
const ore = (e) => e.updateNodeInternals;
function ire() {
  const e = Je(ore), [t] = _.useState(() => typeof ResizeObserver > "u" ? null : new ResizeObserver((n) => {
    const r = /* @__PURE__ */ new Map();
    n.forEach((o) => {
      const a = o.target.getAttribute("data-id");
      r.set(a, {
        id: a,
        nodeElement: o.target,
        force: !0
      });
    }), e(r);
  }));
  return _.useEffect(() => () => {
    t?.disconnect();
  }, [t]), t;
}
function are({ node: e, nodeType: t, hasDimensions: n, resizeObserver: r }) {
  const o = kt(), a = _.useRef(null), s = _.useRef(null), u = _.useRef(e.sourcePosition), c = _.useRef(e.targetPosition), f = _.useRef(t), h = n && !!e.internals.handleBounds;
  return _.useEffect(() => {
    a.current && !e.hidden && (!h || s.current !== a.current) && (s.current && r?.unobserve(s.current), r?.observe(a.current), s.current = a.current);
  }, [h, e.hidden]), _.useEffect(() => () => {
    s.current && (r?.unobserve(s.current), s.current = null);
  }, []), _.useEffect(() => {
    if (a.current) {
      const p = f.current !== t, g = u.current !== e.sourcePosition, y = c.current !== e.targetPosition;
      (p || g || y) && (f.current = t, u.current = e.sourcePosition, c.current = e.targetPosition, o.getState().updateNodeInternals(/* @__PURE__ */ new Map([[e.id, { id: e.id, nodeElement: a.current, force: !0 }]])));
    }
  }, [e.id, t, e.sourcePosition, e.targetPosition]), a;
}
function sre({ id: e, onClick: t, onMouseEnter: n, onMouseMove: r, onMouseLeave: o, onContextMenu: a, onDoubleClick: s, nodesDraggable: u, elementsSelectable: c, nodesConnectable: f, nodesFocusable: h, resizeObserver: p, noDragClassName: g, noPanClassName: y, disableKeyboardA11y: w, rfId: v, nodeTypes: S, nodeClickDistance: E, onError: A }) {
  const { node: k, internals: T, isParent: R } = Je((ae) => {
    const ye = ae.nodeLookup.get(e), Ne = ae.parentLookup.has(e);
    return {
      node: ye,
      internals: ye.internals,
      isParent: Ne
    };
  }, At);
  let N = k.type || "default", j = S?.[N] || GA[N];
  j === void 0 && (A?.("003", vo.error003(N)), N = "default", j = S?.default || GA.default);
  const z = !!(k.draggable || u && typeof k.draggable > "u"), B = !!(k.selectable || c && typeof k.selectable > "u"), M = !!(k.connectable || f && typeof k.connectable > "u"), F = !!(k.focusable || h && typeof k.focusable > "u"), q = kt(), Y = w5(k), P = are({ node: k, nodeType: N, hasDimensions: Y, resizeObserver: p }), V = W5({
    nodeRef: P,
    disabled: k.hidden || !z,
    noDragClassName: g,
    handleSelector: k.dragHandle,
    nodeId: e,
    isSelectable: B,
    nodeClickDistance: E
  }), I = X5();
  if (k.hidden)
    return null;
  const U = hi(k), H = Zne(k), G = B || z || t || n || r || o, O = n ? (ae) => n(ae, { ...T.userNode }) : void 0, W = r ? (ae) => r(ae, { ...T.userNode }) : void 0, Z = o ? (ae) => o(ae, { ...T.userNode }) : void 0, L = a ? (ae) => a(ae, { ...T.userNode }) : void 0, te = s ? (ae) => s(ae, { ...T.userNode }) : void 0, he = (ae) => {
    const { selectNodesOnDrag: ye, nodeDragThreshold: Ne } = q.getState();
    B && (!ye || !z || Ne > 0) && Vb({
      id: e,
      store: q,
      nodeRef: P
    }), t && t(ae, { ...T.userNode });
  }, oe = (ae) => {
    if (!(E5(ae.nativeEvent) || w)) {
      if (d5.includes(ae.key) && B) {
        const ye = ae.key === "Escape";
        Vb({
          id: e,
          store: q,
          unselect: ye,
          nodeRef: P
        });
      } else if (z && k.selected && Object.prototype.hasOwnProperty.call(Rp, ae.key)) {
        ae.preventDefault();
        const { ariaLabelConfig: ye } = q.getState();
        q.setState({
          ariaLiveMessage: ye["node.a11yDescription.ariaLiveMessage"]({
            direction: ae.key.replace("Arrow", "").toLowerCase(),
            x: ~~T.positionAbsolute.x,
            y: ~~T.positionAbsolute.y
          })
        }), I({
          direction: Rp[ae.key],
          factor: ae.shiftKey ? 4 : 1
        });
      }
    }
  }, fe = () => {
    if (w || !P.current?.matches(":focus-visible"))
      return;
    const { transform: ae, width: ye, height: Ne, autoPanOnNodeFocus: De, setCenter: we } = q.getState();
    if (!De)
      return;
    Ax(/* @__PURE__ */ new Map([[e, k]]), { x: 0, y: 0, width: ye, height: Ne }, ae, !0).length > 0 || we(k.position.x + U.width / 2, k.position.y + U.height / 2, {
      zoom: ae[2]
    });
  };
  return b.jsx("div", { className: Wt([
    "react-flow__node",
    `react-flow__node-${N}`,
    {
      // this is overwritable by passing `nopan` as a class name
      [y]: z
    },
    k.className,
    {
      selected: k.selected,
      selectable: B,
      parent: R,
      draggable: z,
      dragging: V
    }
  ]), ref: P, style: {
    zIndex: T.z,
    transform: `translate(${T.positionAbsolute.x}px,${T.positionAbsolute.y}px)`,
    pointerEvents: G ? "all" : "none",
    visibility: Y ? "visible" : "hidden",
    ...k.style,
    ...H
  }, "data-id": e, "data-testid": `rf__node-${e}`, onMouseEnter: O, onMouseMove: W, onMouseLeave: Z, onContextMenu: L, onClick: he, onDoubleClick: te, onKeyDown: F ? oe : void 0, tabIndex: F ? 0 : void 0, onFocus: F ? fe : void 0, role: k.ariaRole ?? (F ? "group" : void 0), "aria-roledescription": "node", "aria-describedby": w ? void 0 : `${B5}-${v}`, "aria-label": k.ariaLabel, ...k.domAttributes, children: b.jsx(Vne, { value: e, children: b.jsx(j, { id: e, data: k.data, type: N, positionAbsoluteX: T.positionAbsolute.x, positionAbsoluteY: T.positionAbsolute.y, selected: k.selected ?? !1, selectable: B, draggable: z, deletable: k.deletable ?? !0, isConnectable: M, sourcePosition: k.sourcePosition, targetPosition: k.targetPosition, dragging: V, dragHandle: k.dragHandle, zIndex: T.z, parentId: k.parentId, ...U }) }) });
}
const lre = (e) => ({
  nodesDraggable: e.nodesDraggable,
  nodesConnectable: e.nodesConnectable,
  nodesFocusable: e.nodesFocusable,
  elementsSelectable: e.elementsSelectable,
  onError: e.onError
});
function Q5(e) {
  const { nodesDraggable: t, nodesConnectable: n, nodesFocusable: r, elementsSelectable: o, onError: a } = Je(lre, At), s = rre(e.onlyRenderVisibleElements), u = ire();
  return b.jsx("div", { className: "react-flow__nodes", style: Bm, children: s.map((c) => (
    /*
     * The split of responsibilities between NodeRenderer and
     * NodeComponentWrapper may appear weird. However, its designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For example, when youre dragging a single node, that node gets
     * updated multiple times per second. If `NodeRenderer` were to update
     * every time, it would have to re-run the `nodes.map()` loop every
     * time. This gets pricey with hundreds of nodes, especially if every
     * loop cycle does more than just rendering a JSX element!
     *
     * As a result of this choice, we took the following implementation
     * decisions:
     * - NodeRenderer subscribes *only* to node IDs  and therefore
     *   rerender *only* when visible nodes are added or removed.
     * - NodeRenderer performs all operations the result of which can be
     *   shared between nodes (such as creating the `ResizeObserver`
     *   instance, or subscribing to `selector`). This means extra prop
     *   drilling into `NodeComponentWrapper`, but it means we need to run
     *   these operations only once  instead of once per node.
     * - Any operations that youd normally write inside `nodes.map` are
     *   moved into `NodeComponentWrapper`. This ensures they are
     *   memorized  so if `NodeRenderer` *has* to rerender, it only
     *   needs to regenerate the list of nodes, nothing else.
     */
    b.jsx(sre, { id: c, nodeTypes: e.nodeTypes, nodeExtent: e.nodeExtent, onClick: e.onNodeClick, onMouseEnter: e.onNodeMouseEnter, onMouseMove: e.onNodeMouseMove, onMouseLeave: e.onNodeMouseLeave, onContextMenu: e.onNodeContextMenu, onDoubleClick: e.onNodeDoubleClick, noDragClassName: e.noDragClassName, noPanClassName: e.noPanClassName, rfId: e.rfId, disableKeyboardA11y: e.disableKeyboardA11y, resizeObserver: u, nodesDraggable: t, nodesConnectable: n, nodesFocusable: r, elementsSelectable: o, nodeClickDistance: e.nodeClickDistance, onError: a }, c)
  )) });
}
Q5.displayName = "NodeRenderer";
const ure = _.memo(Q5);
function cre(e) {
  return Je(_.useCallback((n) => {
    if (!e)
      return n.edges.map((o) => o.id);
    const r = [];
    if (n.width && n.height)
      for (const o of n.edges) {
        const a = n.nodeLookup.get(o.source), s = n.nodeLookup.get(o.target);
        a && s && vte({
          sourceNode: a,
          targetNode: s,
          width: n.width,
          height: n.height,
          transform: n.transform
        }) && r.push(o.id);
      }
    return r;
  }, [e]), At);
}
const fre = ({ color: e = "none", strokeWidth: t = 1 }) => b.jsx("polyline", { style: {
  stroke: e,
  strokeWidth: t
}, strokeLinecap: "round", strokeLinejoin: "round", fill: "none", points: "-5,-4 0,0 -5,4" }), dre = ({ color: e = "none", strokeWidth: t = 1 }) => b.jsx("polyline", { style: {
  stroke: e,
  fill: e,
  strokeWidth: t
}, strokeLinecap: "round", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4 -5,-4" }), WA = {
  [Cp.Arrow]: fre,
  [Cp.ArrowClosed]: dre
};
function hre(e) {
  const t = kt();
  return _.useMemo(() => Object.prototype.hasOwnProperty.call(WA, e) ? WA[e] : (t.getState().onError?.("009", vo.error009(e)), null), [e]);
}
const pre = ({ id: e, type: t, color: n, width: r = 12.5, height: o = 12.5, markerUnits: a = "strokeWidth", strokeWidth: s, orient: u = "auto-start-reverse" }) => {
  const c = hre(t);
  return c ? b.jsx("marker", { className: "react-flow__arrowhead", id: e, markerWidth: `${r}`, markerHeight: `${o}`, viewBox: "-10 -10 20 20", markerUnits: a, orient: u, refX: "0", refY: "0", children: b.jsx(c, { color: n, strokeWidth: s }) }) : null;
}, J5 = ({ defaultColor: e, rfId: t }) => {
  const n = Je((a) => a.edges), r = Je((a) => a.defaultEdgeOptions), o = _.useMemo(() => kte(n, {
    id: t,
    defaultColor: e,
    defaultMarkerStart: r?.markerStart,
    defaultMarkerEnd: r?.markerEnd
  }), [n, r, t, e]);
  return o.length ? b.jsx("svg", { className: "react-flow__marker", "aria-hidden": "true", children: b.jsx("defs", { children: o.map((a) => b.jsx(pre, { id: a.id, type: a.type, color: a.color, width: a.width, height: a.height, markerUnits: a.markerUnits, strokeWidth: a.strokeWidth, orient: a.orient }, a.id)) }) }) : null;
};
J5.displayName = "MarkerDefinitions";
var mre = _.memo(J5);
function e4({ x: e, y: t, label: n, labelStyle: r, labelShowBg: o = !0, labelBgStyle: a, labelBgPadding: s = [2, 4], labelBgBorderRadius: u = 2, children: c, className: f, ...h }) {
  const [p, g] = _.useState({ x: 1, y: 0, width: 0, height: 0 }), y = Wt(["react-flow__edge-textwrapper", f]), w = _.useRef(null);
  return _.useEffect(() => {
    if (w.current) {
      const v = w.current.getBBox();
      g({
        x: v.x,
        y: v.y,
        width: v.width,
        height: v.height
      });
    }
  }, [n]), n ? b.jsxs("g", { transform: `translate(${e - p.width / 2} ${t - p.height / 2})`, className: y, visibility: p.width ? "visible" : "hidden", ...h, children: [o && b.jsx("rect", { width: p.width + 2 * s[0], x: -s[0], y: -s[1], height: p.height + 2 * s[1], className: "react-flow__edge-textbg", style: a, rx: u, ry: u }), b.jsx("text", { className: "react-flow__edge-text", y: p.height / 2, dy: "0.3em", ref: w, style: r, children: n }), c] }) : null;
}
e4.displayName = "EdgeText";
const gre = _.memo(e4);
function _f({ path: e, labelX: t, labelY: n, label: r, labelStyle: o, labelShowBg: a, labelBgStyle: s, labelBgPadding: u, labelBgBorderRadius: c, interactionWidth: f = 20, ...h }) {
  return b.jsxs(b.Fragment, { children: [b.jsx("path", { ...h, d: e, fill: "none", className: Wt(["react-flow__edge-path", h.className]) }), f && b.jsx("path", { d: e, fill: "none", strokeOpacity: 0, strokeWidth: f, className: "react-flow__edge-interaction" }), r && Ir(t) && Ir(n) ? b.jsx(gre, { x: t, y: n, label: r, labelStyle: o, labelShowBg: a, labelBgStyle: s, labelBgPadding: u, labelBgBorderRadius: c }) : null] });
}
function XA({ pos: e, x1: t, y1: n, x2: r, y2: o }) {
  return e === Ee.Left || e === Ee.Right ? [0.5 * (t + r), n] : [t, 0.5 * (n + o)];
}
function t4({ sourceX: e, sourceY: t, sourcePosition: n = Ee.Bottom, targetX: r, targetY: o, targetPosition: a = Ee.Top }) {
  const [s, u] = XA({
    pos: n,
    x1: e,
    y1: t,
    x2: r,
    y2: o
  }), [c, f] = XA({
    pos: a,
    x1: r,
    y1: o,
    x2: e,
    y2: t
  }), [h, p, g, y] = k5({
    sourceX: e,
    sourceY: t,
    targetX: r,
    targetY: o,
    sourceControlX: s,
    sourceControlY: u,
    targetControlX: c,
    targetControlY: f
  });
  return [
    `M${e},${t} C${s},${u} ${c},${f} ${r},${o}`,
    h,
    p,
    g,
    y
  ];
}
function n4(e) {
  return _.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: a, sourcePosition: s, targetPosition: u, label: c, labelStyle: f, labelShowBg: h, labelBgStyle: p, labelBgPadding: g, labelBgBorderRadius: y, style: w, markerEnd: v, markerStart: S, interactionWidth: E }) => {
    const [A, k, T] = t4({
      sourceX: n,
      sourceY: r,
      sourcePosition: s,
      targetX: o,
      targetY: a,
      targetPosition: u
    }), R = e.isInternal ? void 0 : t;
    return b.jsx(_f, { id: R, path: A, labelX: k, labelY: T, label: c, labelStyle: f, labelShowBg: h, labelBgStyle: p, labelBgPadding: g, labelBgBorderRadius: y, style: w, markerEnd: v, markerStart: S, interactionWidth: E });
  });
}
const yre = n4({ isInternal: !1 }), r4 = n4({ isInternal: !0 });
yre.displayName = "SimpleBezierEdge";
r4.displayName = "SimpleBezierEdgeInternal";
function o4(e) {
  return _.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: a, label: s, labelStyle: u, labelShowBg: c, labelBgStyle: f, labelBgPadding: h, labelBgBorderRadius: p, style: g, sourcePosition: y = Ee.Bottom, targetPosition: w = Ee.Top, markerEnd: v, markerStart: S, pathOptions: E, interactionWidth: A }) => {
    const [k, T, R] = Fb({
      sourceX: n,
      sourceY: r,
      sourcePosition: y,
      targetX: o,
      targetY: a,
      targetPosition: w,
      borderRadius: E?.borderRadius,
      offset: E?.offset,
      stepPosition: E?.stepPosition
    }), N = e.isInternal ? void 0 : t;
    return b.jsx(_f, { id: N, path: k, labelX: T, labelY: R, label: s, labelStyle: u, labelShowBg: c, labelBgStyle: f, labelBgPadding: h, labelBgBorderRadius: p, style: g, markerEnd: v, markerStart: S, interactionWidth: A });
  });
}
const i4 = o4({ isInternal: !1 }), a4 = o4({ isInternal: !0 });
i4.displayName = "SmoothStepEdge";
a4.displayName = "SmoothStepEdgeInternal";
function s4(e) {
  return _.memo(({ id: t, ...n }) => {
    const r = e.isInternal ? void 0 : t;
    return b.jsx(i4, { ...n, id: r, pathOptions: _.useMemo(() => ({ borderRadius: 0, offset: n.pathOptions?.offset }), [n.pathOptions?.offset]) });
  });
}
const vre = s4({ isInternal: !1 }), l4 = s4({ isInternal: !0 });
vre.displayName = "StepEdge";
l4.displayName = "StepEdgeInternal";
function u4(e) {
  return _.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: a, label: s, labelStyle: u, labelShowBg: c, labelBgStyle: f, labelBgPadding: h, labelBgBorderRadius: p, style: g, markerEnd: y, markerStart: w, interactionWidth: v }) => {
    const [S, E, A] = A5({ sourceX: n, sourceY: r, targetX: o, targetY: a }), k = e.isInternal ? void 0 : t;
    return b.jsx(_f, { id: k, path: S, labelX: E, labelY: A, label: s, labelStyle: u, labelShowBg: c, labelBgStyle: f, labelBgPadding: h, labelBgBorderRadius: p, style: g, markerEnd: y, markerStart: w, interactionWidth: v });
  });
}
const bre = u4({ isInternal: !1 }), c4 = u4({ isInternal: !0 });
bre.displayName = "StraightEdge";
c4.displayName = "StraightEdgeInternal";
function f4(e) {
  return _.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: a, sourcePosition: s = Ee.Bottom, targetPosition: u = Ee.Top, label: c, labelStyle: f, labelShowBg: h, labelBgStyle: p, labelBgPadding: g, labelBgBorderRadius: y, style: w, markerEnd: v, markerStart: S, pathOptions: E, interactionWidth: A }) => {
    const [k, T, R] = Ox({
      sourceX: n,
      sourceY: r,
      sourcePosition: s,
      targetX: o,
      targetY: a,
      targetPosition: u,
      curvature: E?.curvature
    }), N = e.isInternal ? void 0 : t;
    return b.jsx(_f, { id: N, path: k, labelX: T, labelY: R, label: c, labelStyle: f, labelShowBg: h, labelBgStyle: p, labelBgPadding: g, labelBgBorderRadius: y, style: w, markerEnd: v, markerStart: S, interactionWidth: A });
  });
}
const xre = f4({ isInternal: !1 }), d4 = f4({ isInternal: !0 });
xre.displayName = "BezierEdge";
d4.displayName = "BezierEdgeInternal";
const KA = {
  default: d4,
  straight: c4,
  step: l4,
  smoothstep: a4,
  simplebezier: r4
}, ZA = {
  sourceX: null,
  sourceY: null,
  targetX: null,
  targetY: null,
  sourcePosition: null,
  targetPosition: null
}, wre = (e, t, n) => n === Ee.Left ? e - t : n === Ee.Right ? e + t : e, _re = (e, t, n) => n === Ee.Top ? e - t : n === Ee.Bottom ? e + t : e, QA = "react-flow__edgeupdater";
function JA({ position: e, centerX: t, centerY: n, radius: r = 10, onMouseDown: o, onMouseEnter: a, onMouseOut: s, type: u }) {
  return b.jsx("circle", { onMouseDown: o, onMouseEnter: a, onMouseOut: s, className: Wt([QA, `${QA}-${u}`]), cx: wre(t, r, e), cy: _re(n, r, e), r, stroke: "transparent", fill: "transparent" });
}
function Sre({ isReconnectable: e, reconnectRadius: t, edge: n, sourceX: r, sourceY: o, targetX: a, targetY: s, sourcePosition: u, targetPosition: c, onReconnect: f, onReconnectStart: h, onReconnectEnd: p, setReconnecting: g, setUpdateHover: y }) {
  const w = kt(), v = (T, R) => {
    if (T.button !== 0)
      return;
    const { autoPanOnConnect: N, domNode: j, isValidConnection: z, connectionMode: B, connectionRadius: M, lib: F, onConnectStart: q, onConnectEnd: Y, cancelConnection: P, nodeLookup: V, rfId: I, panBy: U, updateConnection: H } = w.getState(), G = R.type === "target", O = (L, te) => {
      g(!1), p?.(L, n, R.type, te);
    }, W = (L) => f?.(n, L), Z = (L, te) => {
      g(!0), h?.(T, n, R.type), q?.(L, te);
    };
    Hb.onPointerDown(T.nativeEvent, {
      autoPanOnConnect: N,
      connectionMode: B,
      connectionRadius: M,
      domNode: j,
      handleId: R.id,
      nodeId: R.nodeId,
      nodeLookup: V,
      isTarget: G,
      edgeUpdaterType: R.type,
      lib: F,
      flowId: I,
      cancelConnection: P,
      panBy: U,
      isValidConnection: z,
      onConnect: W,
      onConnectStart: Z,
      onConnectEnd: Y,
      onReconnectEnd: O,
      updateConnection: H,
      getTransform: () => w.getState().transform,
      getFromHandle: () => w.getState().connection.fromHandle,
      dragThreshold: w.getState().connectionDragThreshold
    });
  }, S = (T) => v(T, { nodeId: n.target, id: n.targetHandle ?? null, type: "target" }), E = (T) => v(T, { nodeId: n.source, id: n.sourceHandle ?? null, type: "source" }), A = () => y(!0), k = () => y(!1);
  return b.jsxs(b.Fragment, { children: [(e === !0 || e === "source") && b.jsx(JA, { position: u, centerX: r, centerY: o, radius: t, onMouseDown: S, onMouseEnter: A, onMouseOut: k, type: "source" }), (e === !0 || e === "target") && b.jsx(JA, { position: c, centerX: a, centerY: s, radius: t, onMouseDown: E, onMouseEnter: A, onMouseOut: k, type: "target" })] });
}
function Ere({ id: e, edgesFocusable: t, edgesReconnectable: n, elementsSelectable: r, onClick: o, onDoubleClick: a, onContextMenu: s, onMouseEnter: u, onMouseMove: c, onMouseLeave: f, reconnectRadius: h, onReconnect: p, onReconnectStart: g, onReconnectEnd: y, rfId: w, edgeTypes: v, noPanClassName: S, onError: E, disableKeyboardA11y: A }) {
  let k = Je((we) => we.edgeLookup.get(e));
  const T = Je((we) => we.defaultEdgeOptions);
  k = T ? { ...T, ...k } : k;
  let R = k.type || "default", N = v?.[R] || KA[R];
  N === void 0 && (E?.("011", vo.error011(R)), R = "default", N = v?.default || KA.default);
  const j = !!(k.focusable || t && typeof k.focusable > "u"), z = typeof p < "u" && (k.reconnectable || n && typeof k.reconnectable > "u"), B = !!(k.selectable || r && typeof k.selectable > "u"), M = _.useRef(null), [F, q] = _.useState(!1), [Y, P] = _.useState(!1), V = kt(), { zIndex: I, sourceX: U, sourceY: H, targetX: G, targetY: O, sourcePosition: W, targetPosition: Z } = Je(_.useCallback((we) => {
    const Ce = we.nodeLookup.get(k.source), _e = we.nodeLookup.get(k.target);
    if (!Ce || !_e)
      return {
        zIndex: k.zIndex,
        ...ZA
      };
    const Xe = Cte({
      id: e,
      sourceNode: Ce,
      targetNode: _e,
      sourceHandle: k.sourceHandle || null,
      targetHandle: k.targetHandle || null,
      connectionMode: we.connectionMode,
      onError: E
    });
    return {
      zIndex: yte({
        selected: k.selected,
        zIndex: k.zIndex,
        sourceNode: Ce,
        targetNode: _e,
        elevateOnSelect: we.elevateEdgesOnSelect
      }),
      ...Xe || ZA
    };
  }, [k.source, k.target, k.sourceHandle, k.targetHandle, k.selected, k.zIndex]), At), L = _.useMemo(() => k.markerStart ? `url('#${$b(k.markerStart, w)}')` : void 0, [k.markerStart, w]), te = _.useMemo(() => k.markerEnd ? `url('#${$b(k.markerEnd, w)}')` : void 0, [k.markerEnd, w]);
  if (k.hidden || U === null || H === null || G === null || O === null)
    return null;
  const he = (we) => {
    const { addSelectedEdges: Ce, unselectNodesAndEdges: _e, multiSelectionActive: Xe } = V.getState();
    B && (V.setState({ nodesSelectionActive: !1 }), k.selected && Xe ? (_e({ nodes: [], edges: [k] }), M.current?.blur()) : Ce([e])), o && o(we, k);
  }, oe = a ? (we) => {
    a(we, { ...k });
  } : void 0, fe = s ? (we) => {
    s(we, { ...k });
  } : void 0, ae = u ? (we) => {
    u(we, { ...k });
  } : void 0, ye = c ? (we) => {
    c(we, { ...k });
  } : void 0, Ne = f ? (we) => {
    f(we, { ...k });
  } : void 0, De = (we) => {
    if (!A && d5.includes(we.key) && B) {
      const { unselectNodesAndEdges: Ce, addSelectedEdges: _e } = V.getState();
      we.key === "Escape" ? (M.current?.blur(), Ce({ edges: [k] })) : _e([e]);
    }
  };
  return b.jsx("svg", { style: { zIndex: I }, children: b.jsxs("g", { className: Wt([
    "react-flow__edge",
    `react-flow__edge-${R}`,
    k.className,
    S,
    {
      selected: k.selected,
      animated: k.animated,
      inactive: !B && !o,
      updating: F,
      selectable: B
    }
  ]), onClick: he, onDoubleClick: oe, onContextMenu: fe, onMouseEnter: ae, onMouseMove: ye, onMouseLeave: Ne, onKeyDown: j ? De : void 0, tabIndex: j ? 0 : void 0, role: k.ariaRole ?? (j ? "group" : "img"), "aria-roledescription": "edge", "data-id": e, "data-testid": `rf__edge-${e}`, "aria-label": k.ariaLabel === null ? void 0 : k.ariaLabel || `Edge from ${k.source} to ${k.target}`, "aria-describedby": j ? `${H5}-${w}` : void 0, ref: M, ...k.domAttributes, children: [!Y && b.jsx(N, { id: e, source: k.source, target: k.target, type: k.type, selected: k.selected, animated: k.animated, selectable: B, deletable: k.deletable ?? !0, label: k.label, labelStyle: k.labelStyle, labelShowBg: k.labelShowBg, labelBgStyle: k.labelBgStyle, labelBgPadding: k.labelBgPadding, labelBgBorderRadius: k.labelBgBorderRadius, sourceX: U, sourceY: H, targetX: G, targetY: O, sourcePosition: W, targetPosition: Z, data: k.data, style: k.style, sourceHandleId: k.sourceHandle, targetHandleId: k.targetHandle, markerStart: L, markerEnd: te, pathOptions: "pathOptions" in k ? k.pathOptions : void 0, interactionWidth: k.interactionWidth }), z && b.jsx(Sre, { edge: k, isReconnectable: z, reconnectRadius: h, onReconnect: p, onReconnectStart: g, onReconnectEnd: y, sourceX: U, sourceY: H, targetX: G, targetY: O, sourcePosition: W, targetPosition: Z, setUpdateHover: q, setReconnecting: P })] }) });
}
const Cre = (e) => ({
  edgesFocusable: e.edgesFocusable,
  edgesReconnectable: e.edgesReconnectable,
  elementsSelectable: e.elementsSelectable,
  connectionMode: e.connectionMode,
  onError: e.onError
});
function h4({ defaultMarkerColor: e, onlyRenderVisibleElements: t, rfId: n, edgeTypes: r, noPanClassName: o, onReconnect: a, onEdgeContextMenu: s, onEdgeMouseEnter: u, onEdgeMouseMove: c, onEdgeMouseLeave: f, onEdgeClick: h, reconnectRadius: p, onEdgeDoubleClick: g, onReconnectStart: y, onReconnectEnd: w, disableKeyboardA11y: v }) {
  const { edgesFocusable: S, edgesReconnectable: E, elementsSelectable: A, onError: k } = Je(Cre, At), T = cre(t);
  return b.jsxs("div", { className: "react-flow__edges", children: [b.jsx(mre, { defaultColor: e, rfId: n }), T.map((R) => b.jsx(Ere, { id: R, edgesFocusable: S, edgesReconnectable: E, elementsSelectable: A, noPanClassName: o, onReconnect: a, onContextMenu: s, onMouseEnter: u, onMouseMove: c, onMouseLeave: f, onClick: h, reconnectRadius: p, onDoubleClick: g, onReconnectStart: y, onReconnectEnd: w, rfId: n, onError: k, edgeTypes: r, disableKeyboardA11y: v }, R))] });
}
h4.displayName = "EdgeRenderer";
const kre = _.memo(h4), Tre = (e) => `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]})`;
function Are({ children: e }) {
  const t = Je(Tre);
  return b.jsx("div", { className: "react-flow__viewport xyflow__viewport react-flow__container", style: { transform: t }, children: e });
}
function Rre(e) {
  const t = ts(), n = _.useRef(!1);
  _.useEffect(() => {
    !n.current && t.viewportInitialized && e && (setTimeout(() => e(t), 1), n.current = !0);
  }, [e, t.viewportInitialized]);
}
const Mre = (e) => e.panZoom?.syncViewport;
function Ore(e) {
  const t = Je(Mre), n = kt();
  return _.useEffect(() => {
    e && (t?.(e), n.setState({ transform: [e.x, e.y, e.zoom] }));
  }, [e, t]), null;
}
function Nre(e) {
  return e.connection.inProgress ? { ...e.connection, to: wf(e.connection.to, e.transform) } : { ...e.connection };
}
function Dre(e) {
  return Nre;
}
function jre(e) {
  const t = Dre();
  return Je(t, At);
}
const Pre = (e) => ({
  nodesConnectable: e.nodesConnectable,
  isValid: e.connection.isValid,
  inProgress: e.connection.inProgress,
  width: e.width,
  height: e.height
});
function Ire({ containerStyle: e, style: t, type: n, component: r }) {
  const { nodesConnectable: o, width: a, height: s, isValid: u, inProgress: c } = Je(Pre, At);
  return !(a && o && c) ? null : b.jsx("svg", { style: e, width: a, height: s, className: "react-flow__connectionline react-flow__container", children: b.jsx("g", { className: Wt(["react-flow__connection", m5(u)]), children: b.jsx(p4, { style: t, type: n, CustomComponent: r, isValid: u }) }) });
}
const p4 = ({ style: e, type: t = Xi.Bezier, CustomComponent: n, isValid: r }) => {
  const { inProgress: o, from: a, fromNode: s, fromHandle: u, fromPosition: c, to: f, toNode: h, toHandle: p, toPosition: g } = jre();
  if (!o)
    return;
  if (n)
    return b.jsx(n, { connectionLineType: t, connectionLineStyle: e, fromNode: s, fromHandle: u, fromX: a.x, fromY: a.y, toX: f.x, toY: f.y, fromPosition: c, toPosition: g, connectionStatus: m5(r), toNode: h, toHandle: p });
  let y = "";
  const w = {
    sourceX: a.x,
    sourceY: a.y,
    sourcePosition: c,
    targetX: f.x,
    targetY: f.y,
    targetPosition: g
  };
  switch (t) {
    case Xi.Bezier:
      [y] = Ox(w);
      break;
    case Xi.SimpleBezier:
      [y] = t4(w);
      break;
    case Xi.Step:
      [y] = Fb({
        ...w,
        borderRadius: 0
      });
      break;
    case Xi.SmoothStep:
      [y] = Fb(w);
      break;
    default:
      [y] = A5(w);
  }
  return b.jsx("path", { d: y, fill: "none", className: "react-flow__connection-path", style: e });
};
p4.displayName = "ConnectionLine";
const zre = {};
function eR(e = zre) {
  _.useRef(e), kt(), _.useEffect(() => {
  }, [e]);
}
function Lre() {
  kt(), _.useRef(!1), _.useEffect(() => {
  }, []);
}
function m4({ nodeTypes: e, edgeTypes: t, onInit: n, onNodeClick: r, onEdgeClick: o, onNodeDoubleClick: a, onEdgeDoubleClick: s, onNodeMouseEnter: u, onNodeMouseMove: c, onNodeMouseLeave: f, onNodeContextMenu: h, onSelectionContextMenu: p, onSelectionStart: g, onSelectionEnd: y, connectionLineType: w, connectionLineStyle: v, connectionLineComponent: S, connectionLineContainerStyle: E, selectionKeyCode: A, selectionOnDrag: k, selectionMode: T, multiSelectionKeyCode: R, panActivationKeyCode: N, zoomActivationKeyCode: j, deleteKeyCode: z, onlyRenderVisibleElements: B, elementsSelectable: M, defaultViewport: F, translateExtent: q, minZoom: Y, maxZoom: P, preventScrolling: V, defaultMarkerColor: I, zoomOnScroll: U, zoomOnPinch: H, panOnScroll: G, panOnScrollSpeed: O, panOnScrollMode: W, zoomOnDoubleClick: Z, panOnDrag: L, onPaneClick: te, onPaneMouseEnter: he, onPaneMouseMove: oe, onPaneMouseLeave: fe, onPaneScroll: ae, onPaneContextMenu: ye, paneClickDistance: Ne, nodeClickDistance: De, onEdgeContextMenu: we, onEdgeMouseEnter: Ce, onEdgeMouseMove: _e, onEdgeMouseLeave: Xe, reconnectRadius: St, onReconnect: ct, onReconnectStart: cn, onReconnectEnd: fr, noDragClassName: Un, noWheelClassName: qn, noPanClassName: ze, disableKeyboardA11y: qr, nodeExtent: ca, rfId: gi, viewport: se, onViewportChange: pe }) {
  return eR(e), eR(t), Lre(), Rre(n), Ore(se), b.jsx(tre, { onPaneClick: te, onPaneMouseEnter: he, onPaneMouseMove: oe, onPaneMouseLeave: fe, onPaneContextMenu: ye, onPaneScroll: ae, paneClickDistance: Ne, deleteKeyCode: z, selectionKeyCode: A, selectionOnDrag: k, selectionMode: T, onSelectionStart: g, onSelectionEnd: y, multiSelectionKeyCode: R, panActivationKeyCode: N, zoomActivationKeyCode: j, elementsSelectable: M, zoomOnScroll: U, zoomOnPinch: H, zoomOnDoubleClick: Z, panOnScroll: G, panOnScrollSpeed: O, panOnScrollMode: W, panOnDrag: L, defaultViewport: F, translateExtent: q, minZoom: Y, maxZoom: P, onSelectionContextMenu: p, preventScrolling: V, noDragClassName: Un, noWheelClassName: qn, noPanClassName: ze, disableKeyboardA11y: qr, onViewportChange: pe, isControlledViewport: !!se, children: b.jsxs(Are, { children: [b.jsx(kre, { edgeTypes: t, onEdgeClick: o, onEdgeDoubleClick: s, onReconnect: ct, onReconnectStart: cn, onReconnectEnd: fr, onlyRenderVisibleElements: B, onEdgeContextMenu: we, onEdgeMouseEnter: Ce, onEdgeMouseMove: _e, onEdgeMouseLeave: Xe, reconnectRadius: St, defaultMarkerColor: I, noPanClassName: ze, disableKeyboardA11y: qr, rfId: gi }), b.jsx(Ire, { style: v, type: w, component: S, containerStyle: E }), b.jsx("div", { className: "react-flow__edgelabel-renderer" }), b.jsx(ure, { nodeTypes: e, onNodeClick: r, onNodeDoubleClick: a, onNodeMouseEnter: u, onNodeMouseMove: c, onNodeMouseLeave: f, onNodeContextMenu: h, nodeClickDistance: De, onlyRenderVisibleElements: B, noPanClassName: ze, noDragClassName: Un, disableKeyboardA11y: qr, nodeExtent: ca, rfId: gi }), b.jsx("div", { className: "react-flow__viewport-portal" })] }) });
}
m4.displayName = "GraphView";
const Fre = _.memo(m4), tR = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, width: o, height: a, fitView: s, fitViewOptions: u, minZoom: c = 0.5, maxZoom: f = 2, nodeOrigin: h, nodeExtent: p } = {}) => {
  const g = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Map(), w = /* @__PURE__ */ new Map(), v = /* @__PURE__ */ new Map(), S = r ?? t ?? [], E = n ?? e ?? [], A = h ?? [0, 0], k = p ?? qc;
  M5(w, v, S);
  const T = Bb(E, g, y, {
    nodeOrigin: A,
    nodeExtent: k,
    elevateNodesOnSelect: !1
  });
  let R = [0, 0, 1];
  if (s && o && a) {
    const N = xf(g, {
      filter: (M) => !!((M.width || M.initialWidth) && (M.height || M.initialHeight))
    }), { x: j, y: z, zoom: B } = Rx(N, o, a, c, f, u?.padding ?? 0.1);
    R = [j, z, B];
  }
  return {
    rfId: "1",
    width: 0,
    height: 0,
    transform: R,
    nodes: E,
    nodesInitialized: T,
    nodeLookup: g,
    parentLookup: y,
    edges: S,
    edgeLookup: v,
    connectionLookup: w,
    onNodesChange: null,
    onEdgesChange: null,
    hasDefaultNodes: n !== void 0,
    hasDefaultEdges: r !== void 0,
    panZoom: null,
    minZoom: c,
    maxZoom: f,
    translateExtent: qc,
    nodeExtent: k,
    nodesSelectionActive: !1,
    userSelectionActive: !1,
    userSelectionRect: null,
    connectionMode: Tl.Strict,
    domNode: null,
    paneDragging: !1,
    noPanClassName: "nopan",
    nodeOrigin: A,
    nodeDragThreshold: 1,
    connectionDragThreshold: 1,
    snapGrid: [15, 15],
    snapToGrid: !1,
    nodesDraggable: !0,
    nodesConnectable: !0,
    nodesFocusable: !0,
    edgesFocusable: !0,
    edgesReconnectable: !0,
    elementsSelectable: !0,
    elevateNodesOnSelect: !0,
    elevateEdgesOnSelect: !1,
    selectNodesOnDrag: !0,
    multiSelectionActive: !1,
    fitViewQueued: s ?? !1,
    fitViewOptions: u,
    fitViewResolver: null,
    connection: { ...p5 },
    connectionClickStartHandle: null,
    connectOnClick: !0,
    ariaLiveMessage: "",
    autoPanOnConnect: !0,
    autoPanOnNodeDrag: !0,
    autoPanOnNodeFocus: !0,
    autoPanSpeed: 15,
    connectionRadius: 20,
    onError: fte,
    isValidConnection: void 0,
    onSelectionChangeHandlers: [],
    lib: "react",
    debug: !1,
    ariaLabelConfig: h5
  };
}, $re = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, width: o, height: a, fitView: s, fitViewOptions: u, minZoom: c, maxZoom: f, nodeOrigin: h, nodeExtent: p }) => ane((g, y) => {
  async function w() {
    const { nodeLookup: v, panZoom: S, fitViewOptions: E, fitViewResolver: A, width: k, height: T, minZoom: R, maxZoom: N } = y();
    S && (await ute({
      nodes: v,
      width: k,
      height: T,
      panZoom: S,
      minZoom: R,
      maxZoom: N
    }, E), A?.resolve(!0), g({ fitViewResolver: null }));
  }
  return {
    ...tR({
      nodes: e,
      edges: t,
      width: o,
      height: a,
      fitView: s,
      fitViewOptions: u,
      minZoom: c,
      maxZoom: f,
      nodeOrigin: h,
      nodeExtent: p,
      defaultNodes: n,
      defaultEdges: r
    }),
    setNodes: (v) => {
      const { nodeLookup: S, parentLookup: E, nodeOrigin: A, elevateNodesOnSelect: k, fitViewQueued: T } = y(), R = Bb(v, S, E, {
        nodeOrigin: A,
        nodeExtent: p,
        elevateNodesOnSelect: k,
        checkEquality: !0
      });
      T && R ? (w(), g({ nodes: v, nodesInitialized: R, fitViewQueued: !1, fitViewOptions: void 0 })) : g({ nodes: v, nodesInitialized: R });
    },
    setEdges: (v) => {
      const { connectionLookup: S, edgeLookup: E } = y();
      M5(S, E, v), g({ edges: v });
    },
    setDefaultNodesAndEdges: (v, S) => {
      if (v) {
        const { setNodes: E } = y();
        E(v), g({ hasDefaultNodes: !0 });
      }
      if (S) {
        const { setEdges: E } = y();
        E(S), g({ hasDefaultEdges: !0 });
      }
    },
    /*
     * Every node gets registerd at a ResizeObserver. Whenever a node
     * changes its dimensions, this function is called to measure the
     * new dimensions and update the nodes.
     */
    updateNodeInternals: (v) => {
      const { triggerNodeChanges: S, nodeLookup: E, parentLookup: A, domNode: k, nodeOrigin: T, nodeExtent: R, debug: N, fitViewQueued: j } = y(), { changes: z, updatedInternals: B } = Ote(v, E, A, k, T, R);
      B && (Ate(E, A, { nodeOrigin: T, nodeExtent: R }), j ? (w(), g({ fitViewQueued: !1, fitViewOptions: void 0 })) : g({}), z?.length > 0 && (N && console.log("React Flow: trigger node changes", z), S?.(z)));
    },
    updateNodePositions: (v, S = !1) => {
      const E = [], A = [], { nodeLookup: k, triggerNodeChanges: T } = y();
      for (const [R, N] of v) {
        const j = k.get(R), z = !!(j?.expandParent && j?.parentId && N?.position), B = {
          id: R,
          type: "position",
          position: z ? {
            x: Math.max(0, N.position.x),
            y: Math.max(0, N.position.y)
          } : N.position,
          dragging: S
        };
        z && j.parentId && E.push({
          id: R,
          parentId: j.parentId,
          rect: {
            ...N.internals.positionAbsolute,
            width: N.measured.width ?? 0,
            height: N.measured.height ?? 0
          }
        }), A.push(B);
      }
      if (E.length > 0) {
        const { parentLookup: R, nodeOrigin: N } = y(), j = Px(E, k, R, N);
        A.push(...j);
      }
      T(A);
    },
    triggerNodeChanges: (v) => {
      const { onNodesChange: S, setNodes: E, nodes: A, hasDefaultNodes: k, debug: T } = y();
      if (v?.length) {
        if (k) {
          const R = Ix(v, A);
          E(R);
        }
        T && console.log("React Flow: trigger node changes", v), S?.(v);
      }
    },
    triggerEdgeChanges: (v) => {
      const { onEdgesChange: S, setEdges: E, edges: A, hasDefaultEdges: k, debug: T } = y();
      if (v?.length) {
        if (k) {
          const R = q5(v, A);
          E(R);
        }
        T && console.log("React Flow: trigger edge changes", v), S?.(v);
      }
    },
    addSelectedNodes: (v) => {
      const { multiSelectionActive: S, edgeLookup: E, nodeLookup: A, triggerNodeChanges: k, triggerEdgeChanges: T } = y();
      if (S) {
        const R = v.map((N) => Oa(N, !0));
        k(R);
        return;
      }
      k(al(A, /* @__PURE__ */ new Set([...v]), !0)), T(al(E));
    },
    addSelectedEdges: (v) => {
      const { multiSelectionActive: S, edgeLookup: E, nodeLookup: A, triggerNodeChanges: k, triggerEdgeChanges: T } = y();
      if (S) {
        const R = v.map((N) => Oa(N, !0));
        T(R);
        return;
      }
      T(al(E, /* @__PURE__ */ new Set([...v]))), k(al(A, /* @__PURE__ */ new Set(), !0));
    },
    unselectNodesAndEdges: ({ nodes: v, edges: S } = {}) => {
      const { edges: E, nodes: A, nodeLookup: k, triggerNodeChanges: T, triggerEdgeChanges: R } = y(), N = v || A, j = S || E, z = N.map((M) => {
        const F = k.get(M.id);
        return F && (F.selected = !1), Oa(M.id, !1);
      }), B = j.map((M) => Oa(M.id, !1));
      T(z), R(B);
    },
    setMinZoom: (v) => {
      const { panZoom: S, maxZoom: E } = y();
      S?.setScaleExtent([v, E]), g({ minZoom: v });
    },
    setMaxZoom: (v) => {
      const { panZoom: S, minZoom: E } = y();
      S?.setScaleExtent([E, v]), g({ maxZoom: v });
    },
    setTranslateExtent: (v) => {
      y().panZoom?.setTranslateExtent(v), g({ translateExtent: v });
    },
    setPaneClickDistance: (v) => {
      y().panZoom?.setClickDistance(v);
    },
    resetSelectedElements: () => {
      const { edges: v, nodes: S, triggerNodeChanges: E, triggerEdgeChanges: A, elementsSelectable: k } = y();
      if (!k)
        return;
      const T = S.reduce((N, j) => j.selected ? [...N, Oa(j.id, !1)] : N, []), R = v.reduce((N, j) => j.selected ? [...N, Oa(j.id, !1)] : N, []);
      E(T), A(R);
    },
    setNodeExtent: (v) => {
      const { nodes: S, nodeLookup: E, parentLookup: A, nodeOrigin: k, elevateNodesOnSelect: T, nodeExtent: R } = y();
      v[0][0] === R[0][0] && v[0][1] === R[0][1] && v[1][0] === R[1][0] && v[1][1] === R[1][1] || (Bb(S, E, A, {
        nodeOrigin: k,
        nodeExtent: v,
        elevateNodesOnSelect: T,
        checkEquality: !1
      }), g({ nodeExtent: v }));
    },
    panBy: (v) => {
      const { transform: S, width: E, height: A, panZoom: k, translateExtent: T } = y();
      return Nte({ delta: v, panZoom: k, transform: S, translateExtent: T, width: E, height: A });
    },
    setCenter: async (v, S, E) => {
      const { width: A, height: k, maxZoom: T, panZoom: R } = y();
      if (!R)
        return Promise.resolve(!1);
      const N = typeof E?.zoom < "u" ? E.zoom : T;
      return await R.setViewport({
        x: A / 2 - v * N,
        y: k / 2 - S * N,
        zoom: N
      }, { duration: E?.duration, ease: E?.ease, interpolate: E?.interpolate }), Promise.resolve(!0);
    },
    cancelConnection: () => {
      g({
        connection: { ...p5 }
      });
    },
    updateConnection: (v) => {
      g({ connection: v });
    },
    reset: () => g({ ...tR() })
  };
}, Object.is);
function Bre({ initialNodes: e, initialEdges: t, defaultNodes: n, defaultEdges: r, initialWidth: o, initialHeight: a, initialMinZoom: s, initialMaxZoom: u, initialFitViewOptions: c, fitView: f, nodeOrigin: h, nodeExtent: p, children: g }) {
  const [y] = _.useState(() => $re({
    nodes: e,
    edges: t,
    defaultNodes: n,
    defaultEdges: r,
    width: o,
    height: a,
    fitView: f,
    minZoom: s,
    maxZoom: u,
    fitViewOptions: c,
    nodeOrigin: h,
    nodeExtent: p
  }));
  return b.jsx(sne, { value: y, children: b.jsx(Mne, { children: g }) });
}
function Hre({ children: e, nodes: t, edges: n, defaultNodes: r, defaultEdges: o, width: a, height: s, fitView: u, fitViewOptions: c, minZoom: f, maxZoom: h, nodeOrigin: p, nodeExtent: g }) {
  return _.useContext(Fm) ? b.jsx(b.Fragment, { children: e }) : b.jsx(Bre, { initialNodes: t, initialEdges: n, defaultNodes: r, defaultEdges: o, initialWidth: a, initialHeight: s, fitView: u, initialFitViewOptions: c, initialMinZoom: f, initialMaxZoom: h, nodeOrigin: p, nodeExtent: g, children: e });
}
const Vre = {
  width: "100%",
  height: "100%",
  overflow: "hidden",
  position: "relative",
  zIndex: 0
};
function Ure({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, className: o, nodeTypes: a, edgeTypes: s, onNodeClick: u, onEdgeClick: c, onInit: f, onMove: h, onMoveStart: p, onMoveEnd: g, onConnect: y, onConnectStart: w, onConnectEnd: v, onClickConnectStart: S, onClickConnectEnd: E, onNodeMouseEnter: A, onNodeMouseMove: k, onNodeMouseLeave: T, onNodeContextMenu: R, onNodeDoubleClick: N, onNodeDragStart: j, onNodeDrag: z, onNodeDragStop: B, onNodesDelete: M, onEdgesDelete: F, onDelete: q, onSelectionChange: Y, onSelectionDragStart: P, onSelectionDrag: V, onSelectionDragStop: I, onSelectionContextMenu: U, onSelectionStart: H, onSelectionEnd: G, onBeforeDelete: O, connectionMode: W, connectionLineType: Z = Xi.Bezier, connectionLineStyle: L, connectionLineComponent: te, connectionLineContainerStyle: he, deleteKeyCode: oe = "Backspace", selectionKeyCode: fe = "Shift", selectionOnDrag: ae = !1, selectionMode: ye = Gc.Full, panActivationKeyCode: Ne = "Space", multiSelectionKeyCode: De = Ap() ? "Meta" : "Control", zoomActivationKeyCode: we = Ap() ? "Meta" : "Control", snapToGrid: Ce, snapGrid: _e, onlyRenderVisibleElements: Xe = !1, selectNodesOnDrag: St, nodesDraggable: ct, autoPanOnNodeFocus: cn, nodesConnectable: fr, nodesFocusable: Un, nodeOrigin: qn = V5, edgesFocusable: ze, edgesReconnectable: qr, elementsSelectable: ca = !0, defaultViewport: gi = xne, minZoom: se = 0.5, maxZoom: pe = 2, translateExtent: ke = qc, preventScrolling: je = !0, nodeExtent: et, defaultMarkerColor: _n = "#b1b1b7", zoomOnScroll: Ar = !0, zoomOnPinch: fn = !0, panOnScroll: dr = !1, panOnScrollSpeed: Sn = 0.5, panOnScrollMode: $t = Ba.Free, zoomOnDoubleClick: Rn = !0, panOnDrag: Gn = !0, onPaneClick: Mf, onPaneMouseEnter: Of, onPaneMouseMove: Wl, onPaneMouseLeave: fa, onPaneScroll: og, onPaneContextMenu: Nf, paneClickDistance: Xl = 0, nodeClickDistance: Kl = 0, children: Zl, onReconnect: Df, onReconnectStart: ig, onReconnectEnd: Gr, onEdgeContextMenu: Qt, onEdgeDoubleClick: dn, onEdgeMouseEnter: yi, onEdgeMouseMove: Ql, onEdgeMouseLeave: ag, reconnectRadius: sg = 10, onNodesChange: jf, onEdgesChange: da, noDragClassName: Jl = "nodrag", noWheelClassName: vi = "nowheel", noPanClassName: ko = "nopan", fitView: bi, fitViewOptions: To, connectOnClick: Bt, attributionPosition: Pf, proOptions: If, defaultEdgeOptions: Ao, elevateNodesOnSelect: xi, elevateEdgesOnSelect: lg, disableKeyboardA11y: eu = !1, autoPanOnConnect: zf, autoPanOnNodeDrag: ug, autoPanSpeed: as, connectionRadius: ss, isValidConnection: Rr, onError: tu, style: Lf, id: Ro, nodeDragThreshold: nu, connectionDragThreshold: ru, viewport: cg, onViewportChange: Ff, width: Mn, height: $f, colorMode: fg = "light", debug: ls, onScroll: ou, ariaLabelConfig: us, ...dg }, On) {
  const ha = Ro || "1", Bf = Ene(fg), iu = _.useCallback((Mo) => {
    Mo.currentTarget.scrollTo({ top: 0, left: 0, behavior: "instant" }), ou?.(Mo);
  }, [ou]);
  return b.jsx("div", { "data-testid": "rf__wrapper", ...dg, onScroll: iu, style: { ...Lf, ...Vre }, ref: On, className: Wt(["react-flow", o, Bf]), id: Ro, role: "application", children: b.jsxs(Hre, { nodes: e, edges: t, width: Mn, height: $f, fitView: bi, fitViewOptions: To, minZoom: se, maxZoom: pe, nodeOrigin: qn, nodeExtent: et, children: [b.jsx(Fre, { onInit: f, onNodeClick: u, onEdgeClick: c, onNodeMouseEnter: A, onNodeMouseMove: k, onNodeMouseLeave: T, onNodeContextMenu: R, onNodeDoubleClick: N, nodeTypes: a, edgeTypes: s, connectionLineType: Z, connectionLineStyle: L, connectionLineComponent: te, connectionLineContainerStyle: he, selectionKeyCode: fe, selectionOnDrag: ae, selectionMode: ye, deleteKeyCode: oe, multiSelectionKeyCode: De, panActivationKeyCode: Ne, zoomActivationKeyCode: we, onlyRenderVisibleElements: Xe, defaultViewport: gi, translateExtent: ke, minZoom: se, maxZoom: pe, preventScrolling: je, zoomOnScroll: Ar, zoomOnPinch: fn, zoomOnDoubleClick: Rn, panOnScroll: dr, panOnScrollSpeed: Sn, panOnScrollMode: $t, panOnDrag: Gn, onPaneClick: Mf, onPaneMouseEnter: Of, onPaneMouseMove: Wl, onPaneMouseLeave: fa, onPaneScroll: og, onPaneContextMenu: Nf, paneClickDistance: Xl, nodeClickDistance: Kl, onSelectionContextMenu: U, onSelectionStart: H, onSelectionEnd: G, onReconnect: Df, onReconnectStart: ig, onReconnectEnd: Gr, onEdgeContextMenu: Qt, onEdgeDoubleClick: dn, onEdgeMouseEnter: yi, onEdgeMouseMove: Ql, onEdgeMouseLeave: ag, reconnectRadius: sg, defaultMarkerColor: _n, noDragClassName: Jl, noWheelClassName: vi, noPanClassName: ko, rfId: ha, disableKeyboardA11y: eu, nodeExtent: et, viewport: cg, onViewportChange: Ff }), b.jsx(Sne, { nodes: e, edges: t, defaultNodes: n, defaultEdges: r, onConnect: y, onConnectStart: w, onConnectEnd: v, onClickConnectStart: S, onClickConnectEnd: E, nodesDraggable: ct, autoPanOnNodeFocus: cn, nodesConnectable: fr, nodesFocusable: Un, edgesFocusable: ze, edgesReconnectable: qr, elementsSelectable: ca, elevateNodesOnSelect: xi, elevateEdgesOnSelect: lg, minZoom: se, maxZoom: pe, nodeExtent: et, onNodesChange: jf, onEdgesChange: da, snapToGrid: Ce, snapGrid: _e, connectionMode: W, translateExtent: ke, connectOnClick: Bt, defaultEdgeOptions: Ao, fitView: bi, fitViewOptions: To, onNodesDelete: M, onEdgesDelete: F, onDelete: q, onNodeDragStart: j, onNodeDrag: z, onNodeDragStop: B, onSelectionDrag: V, onSelectionDragStart: P, onSelectionDragStop: I, onMove: h, onMoveStart: p, onMoveEnd: g, noPanClassName: ko, nodeOrigin: qn, rfId: ha, autoPanOnConnect: zf, autoPanOnNodeDrag: ug, autoPanSpeed: as, onError: tu, connectionRadius: ss, isValidConnection: Rr, selectNodesOnDrag: St, nodeDragThreshold: nu, connectionDragThreshold: ru, onBeforeDelete: O, paneClickDistance: Xl, debug: ls, ariaLabelConfig: us }), b.jsx(bne, { onSelectionChange: Y }), Zl, b.jsx(pne, { proOptions: If, position: Pf }), b.jsx(hne, { rfId: ha, disableKeyboardA11y: eu })] }) });
}
var qre = G5(Ure);
function Gre({ dimensions: e, lineWidth: t, variant: n, className: r }) {
  return b.jsx("path", { strokeWidth: t, d: `M${e[0] / 2} 0 V${e[1]} M0 ${e[1] / 2} H${e[0]}`, className: Wt(["react-flow__background-pattern", n, r]) });
}
function Yre({ radius: e, className: t }) {
  return b.jsx("circle", { cx: e, cy: e, r: e, className: Wt(["react-flow__background-pattern", "dots", t]) });
}
var Cn;
(function(e) {
  e.Lines = "lines", e.Dots = "dots", e.Cross = "cross";
})(Cn || (Cn = {}));
const Wre = {
  [Cn.Dots]: 1,
  [Cn.Lines]: 1,
  [Cn.Cross]: 6
}, Xre = (e) => ({ transform: e.transform, patternId: `pattern-${e.rfId}` });
function g4({
  id: e,
  variant: t = Cn.Dots,
  // only used for dots and cross
  gap: n = 20,
  // only used for lines and cross
  size: r,
  lineWidth: o = 1,
  offset: a = 0,
  color: s,
  bgColor: u,
  style: c,
  className: f,
  patternClassName: h
}) {
  const p = _.useRef(null), { transform: g, patternId: y } = Je(Xre, At), w = r || Wre[t], v = t === Cn.Dots, S = t === Cn.Cross, E = Array.isArray(n) ? n : [n, n], A = [E[0] * g[2] || 1, E[1] * g[2] || 1], k = w * g[2], T = Array.isArray(a) ? a : [a, a], R = S ? [k, k] : A, N = [
    T[0] * g[2] || 1 + R[0] / 2,
    T[1] * g[2] || 1 + R[1] / 2
  ], j = `${y}${e || ""}`;
  return b.jsxs("svg", { className: Wt(["react-flow__background", f]), style: {
    ...c,
    ...Bm,
    "--xy-background-color-props": u,
    "--xy-background-pattern-color-props": s
  }, ref: p, "data-testid": "rf__background", children: [b.jsx("pattern", { id: j, x: g[0] % A[0], y: g[1] % A[1], width: A[0], height: A[1], patternUnits: "userSpaceOnUse", patternTransform: `translate(-${N[0]},-${N[1]})`, children: v ? b.jsx(Yre, { radius: k / 2, className: h }) : b.jsx(Gre, { dimensions: R, lineWidth: o, variant: t, className: h }) }), b.jsx("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: `url(#${j})` })] });
}
g4.displayName = "Background";
const Kre = _.memo(g4);
function Zre() {
  return b.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", children: b.jsx("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" }) });
}
function Qre() {
  return b.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 5", children: b.jsx("path", { d: "M0 0h32v4.2H0z" }) });
}
function Jre() {
  return b.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 30", children: b.jsx("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" }) });
}
function eoe() {
  return b.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: b.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" }) });
}
function toe() {
  return b.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: b.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z" }) });
}
function Sh({ children: e, className: t, ...n }) {
  return b.jsx("button", { type: "button", className: Wt(["react-flow__controls-button", t]), ...n, children: e });
}
const noe = (e) => ({
  isInteractive: e.nodesDraggable || e.nodesConnectable || e.elementsSelectable,
  minZoomReached: e.transform[2] <= e.minZoom,
  maxZoomReached: e.transform[2] >= e.maxZoom,
  ariaLabelConfig: e.ariaLabelConfig
});
function y4({ style: e, showZoom: t = !0, showFitView: n = !0, showInteractive: r = !0, fitViewOptions: o, onZoomIn: a, onZoomOut: s, onFitView: u, onInteractiveChange: c, className: f, children: h, position: p = "bottom-left", orientation: g = "vertical", "aria-label": y }) {
  const w = kt(), { isInteractive: v, minZoomReached: S, maxZoomReached: E, ariaLabelConfig: A } = Je(noe, At), { zoomIn: k, zoomOut: T, fitView: R } = ts(), N = () => {
    k(), a?.();
  }, j = () => {
    T(), s?.();
  }, z = () => {
    R(o), u?.();
  }, B = () => {
    w.setState({
      nodesDraggable: !v,
      nodesConnectable: !v,
      elementsSelectable: !v
    }), c?.(!v);
  }, M = g === "horizontal" ? "horizontal" : "vertical";
  return b.jsxs($m, { className: Wt(["react-flow__controls", M, f]), position: p, style: e, "data-testid": "rf__controls", "aria-label": y ?? A["controls.ariaLabel"], children: [t && b.jsxs(b.Fragment, { children: [b.jsx(Sh, { onClick: N, className: "react-flow__controls-zoomin", title: A["controls.zoomIn.ariaLabel"], "aria-label": A["controls.zoomIn.ariaLabel"], disabled: E, children: b.jsx(Zre, {}) }), b.jsx(Sh, { onClick: j, className: "react-flow__controls-zoomout", title: A["controls.zoomOut.ariaLabel"], "aria-label": A["controls.zoomOut.ariaLabel"], disabled: S, children: b.jsx(Qre, {}) })] }), n && b.jsx(Sh, { className: "react-flow__controls-fitview", onClick: z, title: A["controls.fitView.ariaLabel"], "aria-label": A["controls.fitView.ariaLabel"], children: b.jsx(Jre, {}) }), r && b.jsx(Sh, { className: "react-flow__controls-interactive", onClick: B, title: A["controls.interactive.ariaLabel"], "aria-label": A["controls.interactive.ariaLabel"], children: v ? b.jsx(toe, {}) : b.jsx(eoe, {}) }), h] });
}
y4.displayName = "Controls";
_.memo(y4);
function roe({ id: e, x: t, y: n, width: r, height: o, style: a, color: s, strokeColor: u, strokeWidth: c, className: f, borderRadius: h, shapeRendering: p, selected: g, onClick: y }) {
  const { background: w, backgroundColor: v } = a || {}, S = s || w || v;
  return b.jsx("rect", { className: Wt(["react-flow__minimap-node", { selected: g }, f]), x: t, y: n, rx: h, ry: h, width: r, height: o, style: {
    fill: S,
    stroke: u,
    strokeWidth: c
  }, shapeRendering: p, onClick: y ? (E) => y(E, e) : void 0 });
}
const ooe = _.memo(roe), ioe = (e) => e.nodes.map((t) => t.id), bv = (e) => e instanceof Function ? e : () => e;
function aoe({
  nodeStrokeColor: e,
  nodeColor: t,
  nodeClassName: n = "",
  nodeBorderRadius: r = 5,
  nodeStrokeWidth: o,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent: a = ooe,
  onClick: s
}) {
  const u = Je(ioe, At), c = bv(t), f = bv(e), h = bv(n), p = typeof window > "u" || window.chrome ? "crispEdges" : "geometricPrecision";
  return b.jsx(b.Fragment, { children: u.map((g) => (
    /*
     * The split of responsibilities between MiniMapNodes and
     * NodeComponentWrapper may appear weird. However, its designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For more details, see a similar commit in `NodeRenderer/index.tsx`.
     */
    b.jsx(loe, { id: g, nodeColorFunc: c, nodeStrokeColorFunc: f, nodeClassNameFunc: h, nodeBorderRadius: r, nodeStrokeWidth: o, NodeComponent: a, onClick: s, shapeRendering: p }, g)
  )) });
}
function soe({ id: e, nodeColorFunc: t, nodeStrokeColorFunc: n, nodeClassNameFunc: r, nodeBorderRadius: o, nodeStrokeWidth: a, shapeRendering: s, NodeComponent: u, onClick: c }) {
  const { node: f, x: h, y: p, width: g, height: y } = Je((w) => {
    const { internals: v } = w.nodeLookup.get(e), S = v.userNode, { x: E, y: A } = v.positionAbsolute, { width: k, height: T } = hi(S);
    return {
      node: S,
      x: E,
      y: A,
      width: k,
      height: T
    };
  }, At);
  return !f || f.hidden || !w5(f) ? null : b.jsx(u, { x: h, y: p, width: g, height: y, style: f.style, selected: !!f.selected, className: r(f), color: t(f), borderRadius: o, strokeColor: n(f), strokeWidth: a, shapeRendering: s, onClick: c, id: f.id });
}
const loe = _.memo(soe);
var uoe = _.memo(aoe);
const coe = 200, foe = 150, doe = (e) => !e.hidden, hoe = (e) => {
  const t = {
    x: -e.transform[0] / e.transform[2],
    y: -e.transform[1] / e.transform[2],
    width: e.width / e.transform[2],
    height: e.height / e.transform[2]
  };
  return {
    viewBB: t,
    boundingRect: e.nodeLookup.size > 0 ? x5(xf(e.nodeLookup, { filter: doe }), t) : t,
    rfId: e.rfId,
    panZoom: e.panZoom,
    translateExtent: e.translateExtent,
    flowWidth: e.width,
    flowHeight: e.height,
    ariaLabelConfig: e.ariaLabelConfig
  };
}, poe = "react-flow__minimap-desc";
function v4({
  style: e,
  className: t,
  nodeStrokeColor: n,
  nodeColor: r,
  nodeClassName: o = "",
  nodeBorderRadius: a = 5,
  nodeStrokeWidth: s,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent: u,
  bgColor: c,
  maskColor: f,
  maskStrokeColor: h,
  maskStrokeWidth: p,
  position: g = "bottom-right",
  onClick: y,
  onNodeClick: w,
  pannable: v = !1,
  zoomable: S = !1,
  ariaLabel: E,
  inversePan: A,
  zoomStep: k = 10,
  offsetScale: T = 5
}) {
  const R = kt(), N = _.useRef(null), { boundingRect: j, viewBB: z, rfId: B, panZoom: M, translateExtent: F, flowWidth: q, flowHeight: Y, ariaLabelConfig: P } = Je(hoe, At), V = e?.width ?? coe, I = e?.height ?? foe, U = j.width / V, H = j.height / I, G = Math.max(U, H), O = G * V, W = G * I, Z = T * G, L = j.x - (O - j.width) / 2 - Z, te = j.y - (W - j.height) / 2 - Z, he = O + Z * 2, oe = W + Z * 2, fe = `${poe}-${B}`, ae = _.useRef(0), ye = _.useRef();
  ae.current = G, _.useEffect(() => {
    if (N.current && M)
      return ye.current = $te({
        domNode: N.current,
        panZoom: M,
        getTransform: () => R.getState().transform,
        getViewScale: () => ae.current
      }), () => {
        ye.current?.destroy();
      };
  }, [M]), _.useEffect(() => {
    ye.current?.update({
      translateExtent: F,
      width: q,
      height: Y,
      inversePan: A,
      pannable: v,
      zoomStep: k,
      zoomable: S
    });
  }, [v, S, A, k, F, q, Y]);
  const Ne = y ? (Ce) => {
    const [_e, Xe] = ye.current?.pointer(Ce) || [0, 0];
    y(Ce, { x: _e, y: Xe });
  } : void 0, De = w ? _.useCallback((Ce, _e) => {
    const Xe = R.getState().nodeLookup.get(_e).internals.userNode;
    w(Ce, Xe);
  }, []) : void 0, we = E ?? P["minimap.ariaLabel"];
  return b.jsx($m, { position: g, style: {
    ...e,
    "--xy-minimap-background-color-props": typeof c == "string" ? c : void 0,
    "--xy-minimap-mask-background-color-props": typeof f == "string" ? f : void 0,
    "--xy-minimap-mask-stroke-color-props": typeof h == "string" ? h : void 0,
    "--xy-minimap-mask-stroke-width-props": typeof p == "number" ? p * G : void 0,
    "--xy-minimap-node-background-color-props": typeof r == "string" ? r : void 0,
    "--xy-minimap-node-stroke-color-props": typeof n == "string" ? n : void 0,
    "--xy-minimap-node-stroke-width-props": typeof s == "number" ? s : void 0
  }, className: Wt(["react-flow__minimap", t]), "data-testid": "rf__minimap", children: b.jsxs("svg", { width: V, height: I, viewBox: `${L} ${te} ${he} ${oe}`, className: "react-flow__minimap-svg", role: "img", "aria-labelledby": fe, ref: N, onClick: Ne, children: [we && b.jsx("title", { id: fe, children: we }), b.jsx(uoe, { onClick: De, nodeColor: r, nodeStrokeColor: n, nodeBorderRadius: a, nodeClassName: o, nodeStrokeWidth: s, nodeComponent: u }), b.jsx("path", { className: "react-flow__minimap-mask", d: `M${L - Z},${te - Z}h${he + Z * 2}v${oe + Z * 2}h${-he - Z * 2}z
        M${z.x},${z.y}h${z.width}v${z.height}h${-z.width}z`, fillRule: "evenodd", pointerEvents: "none" })] }) });
}
v4.displayName = "MiniMap";
const moe = _.memo(v4), goe = (e) => (t) => e ? `${Math.max(1 / t.transform[2], 1)}` : void 0, yoe = {
  [Ol.Line]: "right",
  [Ol.Handle]: "bottom-right"
};
function voe({ nodeId: e, position: t, variant: n = Ol.Handle, className: r, style: o = void 0, children: a, color: s, minWidth: u = 10, minHeight: c = 10, maxWidth: f = Number.MAX_VALUE, maxHeight: h = Number.MAX_VALUE, keepAspectRatio: p = !1, resizeDirection: g, autoScale: y = !0, shouldResize: w, onResizeStart: v, onResize: S, onResizeEnd: E }) {
  const A = K5(), k = typeof e == "string" ? e : A, T = kt(), R = _.useRef(null), N = n === Ol.Handle, j = Je(_.useCallback(goe(N && y), [N, y]), At), z = _.useRef(null), B = t ?? yoe[n];
  _.useEffect(() => {
    if (!(!R.current || !k))
      return z.current || (z.current = nne({
        domNode: R.current,
        nodeId: k,
        getStoreItems: () => {
          const { nodeLookup: F, transform: q, snapGrid: Y, snapToGrid: P, nodeOrigin: V, domNode: I } = T.getState();
          return {
            nodeLookup: F,
            transform: q,
            snapGrid: Y,
            snapToGrid: P,
            nodeOrigin: V,
            paneDomNode: I
          };
        },
        onChange: (F, q) => {
          const { triggerNodeChanges: Y, nodeLookup: P, parentLookup: V, nodeOrigin: I } = T.getState(), U = [], H = { x: F.x, y: F.y }, G = P.get(k);
          if (G && G.expandParent && G.parentId) {
            const O = G.origin ?? I, W = F.width ?? G.measured.width ?? 0, Z = F.height ?? G.measured.height ?? 0, L = {
              id: G.id,
              parentId: G.parentId,
              rect: {
                width: W,
                height: Z,
                ..._5({
                  x: F.x ?? G.position.x,
                  y: F.y ?? G.position.y
                }, { width: W, height: Z }, G.parentId, P, O)
              }
            }, te = Px([L], P, V, I);
            U.push(...te), H.x = F.x ? Math.max(O[0] * W, F.x) : void 0, H.y = F.y ? Math.max(O[1] * Z, F.y) : void 0;
          }
          if (H.x !== void 0 && H.y !== void 0) {
            const O = {
              id: k,
              type: "position",
              position: { ...H }
            };
            U.push(O);
          }
          if (F.width !== void 0 && F.height !== void 0) {
            const W = {
              id: k,
              type: "dimensions",
              resizing: !0,
              setAttributes: g ? g === "horizontal" ? "width" : "height" : !0,
              dimensions: {
                width: F.width,
                height: F.height
              }
            };
            U.push(W);
          }
          for (const O of q) {
            const W = {
              ...O,
              type: "position"
            };
            U.push(W);
          }
          Y(U);
        },
        onEnd: ({ width: F, height: q }) => {
          const Y = {
            id: k,
            type: "dimensions",
            resizing: !1,
            dimensions: {
              width: F,
              height: q
            }
          };
          T.getState().triggerNodeChanges([Y]);
        }
      })), z.current.update({
        controlPosition: B,
        boundaries: {
          minWidth: u,
          minHeight: c,
          maxWidth: f,
          maxHeight: h
        },
        keepAspectRatio: p,
        resizeDirection: g,
        onResizeStart: v,
        onResize: S,
        onResizeEnd: E,
        shouldResize: w
      }), () => {
        z.current?.destroy();
      };
  }, [
    B,
    u,
    c,
    f,
    h,
    p,
    v,
    S,
    E,
    w
  ]);
  const M = B.split("-");
  return b.jsx("div", { className: Wt(["react-flow__resize-control", "nodrag", ...M, n, r]), ref: R, style: {
    ...o,
    scale: j,
    ...s && { [N ? "backgroundColor" : "borderColor"]: s }
  }, children: a });
}
_.memo(voe);
function boe(e, t) {
  if (Object.is(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  if (e instanceof Map && t instanceof Map) {
    if (e.size !== t.size) return !1;
    for (const [r, o] of e)
      if (!Object.is(o, t.get(r)))
        return !1;
    return !0;
  }
  if (e instanceof Set && t instanceof Set) {
    if (e.size !== t.size) return !1;
    for (const r of e)
      if (!t.has(r))
        return !1;
    return !0;
  }
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
    return !1;
  for (const r of n)
    if (!Object.prototype.hasOwnProperty.call(t, r) || !Object.is(e[r], t[r]))
      return !1;
  return !0;
}
const { useRef: xoe } = nn;
function Lx(e) {
  const t = xoe();
  return (n) => {
    const r = e(n);
    return boe(t.current, r) ? t.current : t.current = r;
  };
}
const woe = () => {
  const { group: e } = xn();
  return async (t, n) => {
    if (e)
      return await e.group_nodes(t, n);
  };
}, _oe = () => {
  const { group: e } = xn();
  return async (t) => {
    if (e)
      for (const n of t)
        await e.remove_group(n);
  };
}, Soe = ({ data: e }) => {
  const t = e.id, n = _oe(), r = tt(), { group: o } = xn(), a = e?.collapsed ?? e?.group?.meta?.collapsed ?? !1, s = e?.collapsedInfo ?? {
    inputs: [],
    outputs: []
  }, u = e?.group?.meta?.name || e?.group?.meta?.label || t || "Group", c = _.useCallback(
    (p) => {
      p.stopPropagation(), t && n([t]);
    },
    [t, n]
  ), f = _.useCallback(
    (p) => {
      if (p.stopPropagation(), !t)
        return;
      const y = {
        type: "update",
        id: t,
        group: { meta: { collapsed: !a } },
        from_remote: !0
      };
      r.on_group_action(y);
      const w = {
        ...y,
        from_remote: !1,
        immediate: !0
      };
      o?.locally_update_group(w);
    },
    [a, r, o, t]
  ), h = _.useCallback(
    (p, g) => {
      const y = g === "input", w = p.connectionCount > 0 ? `${p.connectionCount} connection${p.connectionCount > 1 ? "s" : ""}` : void 0;
      return /* @__PURE__ */ b.jsxs(
        "div",
        {
          className: `fn-group-io fn-group-io--${g}`,
          title: `${p.nodeName}  ${p.ioName}`,
          children: [
            y ? /* @__PURE__ */ b.jsx(
              Ja,
              {
                id: p.handleId,
                type: "target",
                position: Ee.Left,
                className: "fn-group-io__handle",
                "data-type": p.type
              }
            ) : null,
            /* @__PURE__ */ b.jsxs("div", { className: "fn-group-io__label", children: [
              /* @__PURE__ */ b.jsx("span", { className: "fn-group-io__label-node", children: p.nodeName }),
              /* @__PURE__ */ b.jsx("span", { className: "fn-group-io__label-name", children: p.ioName }),
              p.connectionCount > 0 ? /* @__PURE__ */ b.jsx(
                "span",
                {
                  className: "fn-group-io__badge",
                  title: w,
                  "aria-label": w,
                  children: p.connectionCount
                }
              ) : null
            ] }),
            y ? null : /* @__PURE__ */ b.jsx(
              Ja,
              {
                id: p.handleId,
                type: "source",
                position: Ee.Right,
                className: "fn-group-io__handle",
                "data-type": p.type
              }
            )
          ]
        },
        p.handleId
      );
    },
    []
  );
  if (a) {
    const p = s.inputs.length > 0, g = s.outputs.length > 0, y = p || g;
    return /* @__PURE__ */ b.jsx("div", { className: "fn-group-collapsed-wrapper", children: /* @__PURE__ */ b.jsx("div", { className: "fn-group-collapsed react-flow__node-default", children: /* @__PURE__ */ b.jsxs("div", { className: "innernode", children: [
      /* @__PURE__ */ b.jsxs("div", { className: "nodeheader", children: [
        /* @__PURE__ */ b.jsx("div", { className: "nodeheader_element", children: /* @__PURE__ */ b.jsx(
          "button",
          {
            className: "nodeheaderbutton fn-group-collapsed__button",
            onClick: f,
            title: "Expand group",
            children: /* @__PURE__ */ b.jsx(Pc, {})
          }
        ) }),
        /* @__PURE__ */ b.jsx("div", { className: "nodeheader_element nodeheader_title", children: /* @__PURE__ */ b.jsx("div", { className: "nodeheader_title_text", children: u }) }),
        /* @__PURE__ */ b.jsx("div", { className: "nodeheader_element", children: /* @__PURE__ */ b.jsx(
          "button",
          {
            className: "nodeheaderbutton fn-group-collapsed__button",
            onClick: c,
            title: "Remove group",
            children: /* @__PURE__ */ b.jsx(Ic, {})
          }
        ) })
      ] }),
      /* @__PURE__ */ b.jsx("div", { className: "nodebody fn-group-collapsed__body", children: y ? /* @__PURE__ */ b.jsxs("div", { className: "fn-group-collapsed__columns", children: [
        /* @__PURE__ */ b.jsx("div", { className: "fn-group-collapsed__column fn-group-collapsed__column--inputs", children: s.inputs.map((w) => h(w, "input")) }),
        /* @__PURE__ */ b.jsx("div", { className: "fn-group-collapsed__column fn-group-collapsed__column--outputs", children: s.outputs.map(
          (w) => h(w, "output")
        ) })
      ] }) : /* @__PURE__ */ b.jsx("div", { className: "fn-group-collapsed__empty", children: "No exposed IOs" }) })
    ] }) }) });
  }
  return /* @__PURE__ */ b.jsxs("div", { className: "fn-group", children: [
    /* @__PURE__ */ b.jsx(
      "button",
      {
        className: "fn-group-toggle",
        title: "Collapse group",
        onClick: f,
        children: /* @__PURE__ */ b.jsx(_l, {})
      }
    ),
    /* @__PURE__ */ b.jsx(
      "button",
      {
        className: "fn-group-remove",
        title: "Remove group",
        onClick: c,
        children: /* @__PURE__ */ b.jsx(Ic, {})
      }
    ),
    u
  ] });
}, Fx = _.memo(
  ({ value: e }) => {
    const t = e?.toString() ?? "", n = Math.round(3 * t.length / 4);
    return /* @__PURE__ */ b.jsx("div", { children: /* @__PURE__ */ b.jsxs("pre", { children: [
      "Bytes(",
      n,
      ")"
    ] }) });
  }
), b4 = _.memo(
  ({ value: e }) => typeof e != "string" ? /* @__PURE__ */ b.jsx("div", { children: "Invalid SVG" }) : /* @__PURE__ */ b.jsx($W, { value: e })
), x4 = ({
  value: e,
  preValue: t,
  onLoaded: n
}) => {
  const [r, o] = _.useState(
    t?.toString() || e?.toString()
  );
  return _.useEffect(() => {
    if (e === t || e == null) return;
    const s = new Image(), u = e.toString();
    return s.onload = () => {
      n?.(), o(u);
    }, s.src = u, () => {
      s.onload = null;
    };
  }, [e, t, n]), r === void 0 ? /* @__PURE__ */ b.jsx(b.Fragment, {}) : typeof r != "string" ? (console.error("ImageRenderer: value is not a string", r), /* @__PURE__ */ b.jsx(b.Fragment, {})) : r.startsWith("data:") || r.startsWith("blob:") ? /* @__PURE__ */ b.jsx(BW, { src: r }) : /* @__PURE__ */ b.jsx(FW, { value: r, format: "jpeg" });
}, Eoe = _.memo(
  ({ value: e }) => {
    let t = "";
    try {
      t = JSON.stringify(e);
    } catch {
    }
    return /* @__PURE__ */ b.jsx("div", { children: /* @__PURE__ */ b.jsx("pre", { children: t }) });
  }
), Hm = ({
  value: e
}) => /* @__PURE__ */ b.jsx(SW, { data: e }), w4 = _.memo(
  ({ value: e }) => {
    if (typeof e != "object" || e == null)
      return /* @__PURE__ */ b.jsx("div", { children: "Invalid Table" });
    if (!("columns" in e && "index" in e && "data" in e))
      return /* @__PURE__ */ b.jsx("div", { children: "Invalid Table" });
    if (!Array.isArray(e.columns) || !Array.isArray(e.index) || !Array.isArray(e.data) || !e.data.every((n) => Array.isArray(n)))
      return /* @__PURE__ */ b.jsx("div", { children: "Invalid Table" });
    const t = {
      columns: e.columns || [],
      index: e.index || [],
      data: e.data || []
    };
    return /* @__PURE__ */ b.jsx(IM, { tabledata: t });
  }
), Mp = (e) => /* @__PURE__ */ b.jsx(Eoe, { ...e }), Op = Hm, $x = {
  string: Mp,
  str: Mp,
  table: w4,
  image: x4,
  svg: b4,
  dict: Hm,
  bytes: Fx
}, Coe = () => {
  const e = Rt(), { full: t, preview: n } = e.valuestore(), r = JSON.stringify(t?.value || n?.value) || "";
  return `Bytes(${Math.round(3 * r.length / 4)})`;
}, koe = {
  bytes: Coe
}, Vm = (e) => ({ value: t, preValue: n, onLoaded: r }) => /* @__PURE__ */ b.jsx(e, { value: t, preValue: n, onLoaded: r }), zn = (e, t = void 0, n = {}) => ({}) => {
  const r = Rt(), { full: o, preview: a } = r.valuestore(), u = (o === void 0 ? a : o)?.value || t;
  return /* @__PURE__ */ b.jsx(e, { value: u, ...n });
}, _4 = (e) => ({}) => /* @__PURE__ */ b.jsx(e, {}), S4 = (e, t = void 0) => ({}) => {
  const n = Rt(), { full: r, preview: o } = n.valuestore(), s = (r === void 0 ? o : r)?.value || t;
  return /* @__PURE__ */ b.jsx(e, { value: s });
}, Toe = {
  ...Object.fromEntries(
    Object.entries($x).map(([e, t]) => [
      e,
      t ? Vm(t) : void 0
    ])
  )
}, nR = Vm(Hm), E4 = {
  ...Object.fromEntries(
    Object.entries($x).map(([e, t]) => [
      e,
      t ? zn(t) : void 0
    ])
  ),
  string: zn(Mp),
  str: zn(Mp),
  table: zn(w4, void 0, {
    pageSize: 10
  }),
  image: zn(x4),
  svg: zn(b4, ""),
  dict: zn(Hm, "{}"),
  bytes: zn(Fx, "")
}, Aoe = {
  ...Object.fromEntries(
    Object.entries(E4).map(([e, t]) => [
      e,
      t ? _4(t) : void 0
    ])
  )
}, Roe = () => {
  const e = Rt(), { preview: t, full: n } = e.valuestore();
  let r = (JSON.stringify(n || t) || "").replace(/\\n/g, `
`);
  return r.length > 63 && (r = r.slice(0, 60) + "..."), /* @__PURE__ */ b.jsx("div", { children: r });
}, Moe = {}, Ooe = ({ inputconverter: e }) => {
  const t = Rt(), { preview: n } = t.valuestore(), r = t.use(), o = n?.value === void 0, a = _.useRef(null), s = Ul(r);
  _.useEffect(() => {
    a.current && (a.current.indeterminate = o);
  }, [a, o]);
  const u = _.useCallback(
    (c) => {
      let f = c.target.checked;
      try {
        f = e[0](c.target.checked);
      } catch {
      }
      s(f);
    },
    [s, e]
  );
  return /* @__PURE__ */ b.jsx(
    "input",
    {
      ref: a,
      type: "checkbox",
      className: "styledcheckbox booleaninput",
      checked: !!e[1](n?.value),
      onChange: u,
      disabled: r.connected
    }
  );
}, Noe = ({}) => {
  const e = Rt(), t = tt(), n = e.use(), { preview: r, full: o } = e.valuestore(), a = o === void 0 ? r?.value : o.value, s = Ul(n), u = typeof a == "string" || Array.isArray(a) && a.every((g) => typeof g == "number") ? a : void 0, c = n.value_options?.colorspace || "hex", f = _.useCallback(
    (g) => {
      let y = "<NoValue>";
      g && (g[c] ? y = g[c]() : y = g.hex()), g === null && (y = null);
      try {
        y = y;
      } catch {
      }
      s(y);
    },
    [s, c]
  );
  let h = !1;
  typeof n.type != "string" && "anyOf" in n.type && n.type.anyOf !== void 0 && (h = n.type.anyOf.some((g) => g === "None"));
  const p = t.local_state(() => t.reactflowRef);
  return /* @__PURE__ */ b.jsx(
    kq,
    {
      onChange: f,
      inicolordata: u,
      allow_null: h,
      inicolorspace: c,
      portalContainer: p
    }
  );
};
function C4(e, [t, n]) {
  return Math.min(n, Math.max(t, e));
}
var Doe = _.createContext(void 0);
function Um(e) {
  const t = _.useContext(Doe);
  return e || t || "ltr";
}
function joe(e) {
  const t = _.useRef({ value: e, previous: e });
  return _.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]);
}
var k4 = ["PageUp", "PageDown"], T4 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], A4 = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
}, Vl = "Slider", [Ub, Poe, Ioe] = _m(Vl), [R4, mme] = _o(Vl, [
  Ioe
]), [zoe, qm] = R4(Vl), M4 = _.forwardRef(
  (e, t) => {
    const {
      name: n,
      min: r = 0,
      max: o = 100,
      step: a = 1,
      orientation: s = "horizontal",
      disabled: u = !1,
      minStepsBetweenThumbs: c = 0,
      defaultValue: f = [r],
      value: h,
      onValueChange: p = () => {
      },
      onValueCommit: g = () => {
      },
      inverted: y = !1,
      form: w,
      ...v
    } = e, S = _.useRef(/* @__PURE__ */ new Set()), E = _.useRef(0), k = s === "horizontal" ? Loe : Foe, [T = [], R] = sa({
      prop: h,
      defaultProp: f,
      onChange: (F) => {
        [...S.current][E.current]?.focus(), p(F);
      }
    }), N = _.useRef(T);
    function j(F) {
      const q = Uoe(T, F);
      M(F, q);
    }
    function z(F) {
      M(F, E.current);
    }
    function B() {
      const F = N.current[E.current];
      T[E.current] !== F && g(T);
    }
    function M(F, q, { commit: Y } = { commit: !1 }) {
      const P = Woe(a), V = Xoe(Math.round((F - r) / a) * a + r, P), I = C4(V, [r, o]);
      R((U = []) => {
        const H = Hoe(U, I, q);
        if (Yoe(H, c * a)) {
          E.current = H.indexOf(I);
          const G = String(H) !== String(U);
          return G && Y && g(H), G ? H : U;
        } else
          return U;
      });
    }
    return /* @__PURE__ */ b.jsx(
      zoe,
      {
        scope: e.__scopeSlider,
        name: n,
        disabled: u,
        min: r,
        max: o,
        valueIndexToChangeRef: E,
        thumbs: S.current,
        values: T,
        orientation: s,
        form: w,
        children: /* @__PURE__ */ b.jsx(Ub.Provider, { scope: e.__scopeSlider, children: /* @__PURE__ */ b.jsx(Ub.Slot, { scope: e.__scopeSlider, children: /* @__PURE__ */ b.jsx(
          k,
          {
            "aria-disabled": u,
            "data-disabled": u ? "" : void 0,
            ...v,
            ref: t,
            onPointerDown: xe(v.onPointerDown, () => {
              u || (N.current = T);
            }),
            min: r,
            max: o,
            inverted: y,
            onSlideStart: u ? void 0 : j,
            onSlideMove: u ? void 0 : z,
            onSlideEnd: u ? void 0 : B,
            onHomeKeyDown: () => !u && M(r, 0, { commit: !0 }),
            onEndKeyDown: () => !u && M(o, T.length - 1, { commit: !0 }),
            onStepKeyDown: ({ event: F, direction: q }) => {
              if (!u) {
                const V = k4.includes(F.key) || F.shiftKey && T4.includes(F.key) ? 10 : 1, I = E.current, U = T[I], H = a * V * q;
                M(U + H, I, { commit: !0 });
              }
            }
          }
        ) }) })
      }
    );
  }
);
M4.displayName = Vl;
var [O4, N4] = R4(Vl, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
}), Loe = _.forwardRef(
  (e, t) => {
    const {
      min: n,
      max: r,
      dir: o,
      inverted: a,
      onSlideStart: s,
      onSlideMove: u,
      onSlideEnd: c,
      onStepKeyDown: f,
      ...h
    } = e, [p, g] = _.useState(null), y = bt(t, (k) => g(k)), w = _.useRef(void 0), v = Um(o), S = v === "ltr", E = S && !a || !S && a;
    function A(k) {
      const T = w.current || p.getBoundingClientRect(), R = [0, T.width], j = Bx(R, E ? [n, r] : [r, n]);
      return w.current = T, j(k - T.left);
    }
    return /* @__PURE__ */ b.jsx(
      O4,
      {
        scope: e.__scopeSlider,
        startEdge: E ? "left" : "right",
        endEdge: E ? "right" : "left",
        direction: E ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ b.jsx(
          D4,
          {
            dir: v,
            "data-orientation": "horizontal",
            ...h,
            ref: y,
            style: {
              ...h.style,
              "--radix-slider-thumb-transform": "translateX(-50%)"
            },
            onSlideStart: (k) => {
              const T = A(k.clientX);
              s?.(T);
            },
            onSlideMove: (k) => {
              const T = A(k.clientX);
              u?.(T);
            },
            onSlideEnd: () => {
              w.current = void 0, c?.();
            },
            onStepKeyDown: (k) => {
              const R = A4[E ? "from-left" : "from-right"].includes(k.key);
              f?.({ event: k, direction: R ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), Foe = _.forwardRef(
  (e, t) => {
    const {
      min: n,
      max: r,
      inverted: o,
      onSlideStart: a,
      onSlideMove: s,
      onSlideEnd: u,
      onStepKeyDown: c,
      ...f
    } = e, h = _.useRef(null), p = bt(t, h), g = _.useRef(void 0), y = !o;
    function w(v) {
      const S = g.current || h.current.getBoundingClientRect(), E = [0, S.height], k = Bx(E, y ? [r, n] : [n, r]);
      return g.current = S, k(v - S.top);
    }
    return /* @__PURE__ */ b.jsx(
      O4,
      {
        scope: e.__scopeSlider,
        startEdge: y ? "bottom" : "top",
        endEdge: y ? "top" : "bottom",
        size: "height",
        direction: y ? 1 : -1,
        children: /* @__PURE__ */ b.jsx(
          D4,
          {
            "data-orientation": "vertical",
            ...f,
            ref: p,
            style: {
              ...f.style,
              "--radix-slider-thumb-transform": "translateY(50%)"
            },
            onSlideStart: (v) => {
              const S = w(v.clientY);
              a?.(S);
            },
            onSlideMove: (v) => {
              const S = w(v.clientY);
              s?.(S);
            },
            onSlideEnd: () => {
              g.current = void 0, u?.();
            },
            onStepKeyDown: (v) => {
              const E = A4[y ? "from-bottom" : "from-top"].includes(v.key);
              c?.({ event: v, direction: E ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), D4 = _.forwardRef(
  (e, t) => {
    const {
      __scopeSlider: n,
      onSlideStart: r,
      onSlideMove: o,
      onSlideEnd: a,
      onHomeKeyDown: s,
      onEndKeyDown: u,
      onStepKeyDown: c,
      ...f
    } = e, h = qm(Vl, n);
    return /* @__PURE__ */ b.jsx(
      qe.span,
      {
        ...f,
        ref: t,
        onKeyDown: xe(e.onKeyDown, (p) => {
          p.key === "Home" ? (s(p), p.preventDefault()) : p.key === "End" ? (u(p), p.preventDefault()) : k4.concat(T4).includes(p.key) && (c(p), p.preventDefault());
        }),
        onPointerDown: xe(e.onPointerDown, (p) => {
          const g = p.target;
          g.setPointerCapture(p.pointerId), p.preventDefault(), h.thumbs.has(g) ? g.focus() : r(p);
        }),
        onPointerMove: xe(e.onPointerMove, (p) => {
          p.target.hasPointerCapture(p.pointerId) && o(p);
        }),
        onPointerUp: xe(e.onPointerUp, (p) => {
          const g = p.target;
          g.hasPointerCapture(p.pointerId) && (g.releasePointerCapture(p.pointerId), a(p));
        })
      }
    );
  }
), j4 = "SliderTrack", P4 = _.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, ...r } = e, o = qm(j4, n);
    return /* @__PURE__ */ b.jsx(
      qe.span,
      {
        "data-disabled": o.disabled ? "" : void 0,
        "data-orientation": o.orientation,
        ...r,
        ref: t
      }
    );
  }
);
P4.displayName = j4;
var qb = "SliderRange", I4 = _.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, ...r } = e, o = qm(qb, n), a = N4(qb, n), s = _.useRef(null), u = bt(t, s), c = o.values.length, f = o.values.map(
      (g) => F4(g, o.min, o.max)
    ), h = c > 1 ? Math.min(...f) : 0, p = 100 - Math.max(...f);
    return /* @__PURE__ */ b.jsx(
      qe.span,
      {
        "data-orientation": o.orientation,
        "data-disabled": o.disabled ? "" : void 0,
        ...r,
        ref: u,
        style: {
          ...e.style,
          [a.startEdge]: h + "%",
          [a.endEdge]: p + "%"
        }
      }
    );
  }
);
I4.displayName = qb;
var Gb = "SliderThumb", z4 = _.forwardRef(
  (e, t) => {
    const n = Poe(e.__scopeSlider), [r, o] = _.useState(null), a = bt(t, (u) => o(u)), s = _.useMemo(
      () => r ? n().findIndex((u) => u.ref.current === r) : -1,
      [n, r]
    );
    return /* @__PURE__ */ b.jsx($oe, { ...e, ref: a, index: s });
  }
), $oe = _.forwardRef(
  (e, t) => {
    const { __scopeSlider: n, index: r, name: o, ...a } = e, s = qm(Gb, n), u = N4(Gb, n), [c, f] = _.useState(null), h = bt(t, (A) => f(A)), p = c ? s.form || !!c.closest("form") : !0, g = PN(c), y = s.values[r], w = y === void 0 ? 0 : F4(y, s.min, s.max), v = Voe(r, s.values.length), S = g?.[u.size], E = S ? qoe(S, w, u.direction) : 0;
    return _.useEffect(() => {
      if (c)
        return s.thumbs.add(c), () => {
          s.thumbs.delete(c);
        };
    }, [c, s.thumbs]), /* @__PURE__ */ b.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [u.startEdge]: `calc(${w}% + ${E}px)`
        },
        children: [
          /* @__PURE__ */ b.jsx(Ub.ItemSlot, { scope: e.__scopeSlider, children: /* @__PURE__ */ b.jsx(
            qe.span,
            {
              role: "slider",
              "aria-label": e["aria-label"] || v,
              "aria-valuemin": s.min,
              "aria-valuenow": y,
              "aria-valuemax": s.max,
              "aria-orientation": s.orientation,
              "data-orientation": s.orientation,
              "data-disabled": s.disabled ? "" : void 0,
              tabIndex: s.disabled ? void 0 : 0,
              ...a,
              ref: h,
              style: y === void 0 ? { display: "none" } : e.style,
              onFocus: xe(e.onFocus, () => {
                s.valueIndexToChangeRef.current = r;
              })
            }
          ) }),
          p && /* @__PURE__ */ b.jsx(
            L4,
            {
              name: o ?? (s.name ? s.name + (s.values.length > 1 ? "[]" : "") : void 0),
              form: s.form,
              value: y
            },
            r
          )
        ]
      }
    );
  }
);
z4.displayName = Gb;
var Boe = "RadioBubbleInput", L4 = _.forwardRef(
  ({ __scopeSlider: e, value: t, ...n }, r) => {
    const o = _.useRef(null), a = bt(o, r), s = joe(t);
    return _.useEffect(() => {
      const u = o.current;
      if (!u) return;
      const c = window.HTMLInputElement.prototype, h = Object.getOwnPropertyDescriptor(c, "value").set;
      if (s !== t && h) {
        const p = new Event("input", { bubbles: !0 });
        h.call(u, t), u.dispatchEvent(p);
      }
    }, [s, t]), /* @__PURE__ */ b.jsx(
      qe.input,
      {
        style: { display: "none" },
        ...n,
        ref: a,
        defaultValue: t
      }
    );
  }
);
L4.displayName = Boe;
function Hoe(e = [], t, n) {
  const r = [...e];
  return r[n] = t, r.sort((o, a) => o - a);
}
function F4(e, t, n) {
  const a = 100 / (n - t) * (e - t);
  return C4(a, [0, 100]);
}
function Voe(e, t) {
  return t > 2 ? `Value ${e + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][e] : void 0;
}
function Uoe(e, t) {
  if (e.length === 1) return 0;
  const n = e.map((o) => Math.abs(o - t)), r = Math.min(...n);
  return n.indexOf(r);
}
function qoe(e, t, n) {
  const r = e / 2, a = Bx([0, 50], [0, r]);
  return (r - a(t) * n) * n;
}
function Goe(e) {
  return e.slice(0, -1).map((t, n) => e[n + 1] - t);
}
function Yoe(e, t) {
  if (t > 0) {
    const n = Goe(e);
    return Math.min(...n) >= t;
  }
  return !0;
}
function Bx(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1]) return t[0];
    const r = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + r * (n - e[0]);
  };
}
function Woe(e) {
  return (String(e).split(".")[1] || "").length;
}
function Xoe(e, t) {
  const n = Math.pow(10, t);
  return Math.round(e * n) / n;
}
var Koe = M4, Zoe = P4, Qoe = I4, Joe = z4;
function eie(e) {
  return e === 0 ? 0 : Math.abs(e) < 1e-12 ? e : Number(e.toPrecision(12));
}
const $4 = ({
  inputconverter: e,
  parser: t = (n) => parseFloat(n)
}) => {
  const n = Rt(), { preview: r } = n.valuestore(), o = n.use(), a = Ul(o), [s, u] = _.useState(
    e[1](r?.value)
  );
  _.useEffect(() => {
    u(e[1](r?.value));
  }, [r]);
  const c = _.useCallback(
    (y) => {
      y = t(
        parseFloat(y.toString()).toString()
        // parse float first for e notation
      ), isNaN(y) ? (y = "<NoValue>", u("")) : (o.value_options?.min !== void 0 && y < o.value_options.min && (y = o.value_options.min), o.value_options?.max !== void 0 && y > o.value_options.max && (y = o.value_options.max), y = eie(y), u(y.toString()));
      try {
        y = e[0](y);
      } catch {
      }
      y !== r?.value && a(y);
    },
    [o, e, a]
  ), f = _.useCallback(
    (y) => {
      c(y.target.value);
    },
    [c]
  );
  let h = o.connected ? e[1](r?.value) : s;
  h === void 0 && (h = o.value_options?.min), h === void 0 && (h = o.value_options?.max), h === void 0 && (h = ""), h === null && (h = "");
  let p = null, g = 1;
  return o.value_options?.step !== void 0 ? g = o.value_options.step : o.value_options?.max !== void 0 && o.value_options?.min !== void 0 && (g = (o.value_options?.max - o.value_options?.min) / 1e3), o.value_options?.max !== void 0 && o.value_options?.min !== void 0 && !o.connected && (p = /* @__PURE__ */ b.jsx("div", { style: { minWidth: "6.25rem" }, className: "SliderContainer", children: /* @__PURE__ */ b.jsxs(
    Koe,
    {
      className: "SliderRoot",
      value: [h === void 0 ? o.value_options?.min : h],
      min: o.value_options?.min,
      max: o.value_options?.max,
      step: g,
      disabled: o.connected,
      onValueCommit: (y) => {
        isNaN(y[0]) || c(y[0]);
      },
      onValueChange: (y) => {
        isNaN(y[0]) || u(y[0].toString());
      },
      onKeyDown: (y) => {
        ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(
          y.key
        ) && y.stopPropagation();
      },
      children: [
        /* @__PURE__ */ b.jsx(Zoe, { className: "SliderTrack", children: /* @__PURE__ */ b.jsx(Qoe, { className: "SliderRange" }) }),
        /* @__PURE__ */ b.jsx(Joe, { className: "SliderThumb" })
      ]
    }
  ) })), /* @__PURE__ */ b.jsxs(b.Fragment, { children: [
    p,
    /* @__PURE__ */ b.jsx(
      "input",
      {
        type: "text",
        className: "nodedatainput styledinput numberinput",
        value: h,
        onChange: (y) => u(y.target.value),
        onBlur: f,
        step: g,
        onKeyDown: (y) => {
          if (!(y.ctrlKey || y.metaKey)) {
            if (y.key === "ArrowUp") {
              y.shiftKey && (g *= 10);
              let w = (parseFloat(h) || 0) + g;
              c(w);
              return;
            }
            if (y.key === "ArrowDown") {
              y.shiftKey && (g *= 10);
              let w = (parseFloat(h) || 0) - g;
              c(w);
              return;
            }
            !/^[0-9.eE+-]$/.test(y.key) && !["Backspace", "ArrowLeft", "ArrowRight", "Delete", "Tab"].includes(
              y.key
            ) && y.preventDefault();
          }
        },
        disabled: o.connected,
        min: o.value_options?.min,
        max: o.value_options?.max
      }
    )
  ] });
}, tie = ({ inputconverter: e }) => $4({ inputconverter: e, parser: parseFloat }), nie = ({ inputconverter: e }) => $4({ inputconverter: e, parser: parseInt }), rie = (e) => e, oie = (e) => parseFloat(e), iie = (e) => !!e, aie = (e) => e === "null" ? null : e, sie = (e) => e === "nuinputconvertermber" ? oie : e === "boolean" ? iie : e === "undefined" ? aie : rie, Xc = ({
  inputconverter: e,
  parser: t
}) => {
  const n = Rt(), r = n.use(), { preview: o, full: a } = n.valuestore(), s = a === void 0 ? o?.value : a.value, u = Ul(r);
  let c = r.value_options?.options || [];
  Array.isArray(c) && (c = {
    type: "enum",
    values: c,
    keys: c.map((v) => v === null ? "None" : v.toString()),
    nullable: !1
  }), c.type !== "enum" && (c = {
    type: "enum",
    values: Object.values(c),
    keys: Object.keys(c),
    nullable: !1
  }), c = c, c.nullable && !c.values.includes(null) && !c.keys.includes("None") && (c.values.unshift(null), c.keys.unshift("None"));
  const f = [];
  for (let v = 0; v < c.values.length; v++) {
    const S = c.values[v] === null || c.values[v] === void 0 ? "undefined" : typeof c.values[v];
    let E = c.values[v];
    E === null && (E = "null"), E === void 0 && (E = "undefined"), f.push([c.keys[v], E.toString(), S]);
  }
  const h = _.useCallback(
    ({
      value: v,
      // label
      datatype: S
    }) => {
      let A = (t || sie(S))(v);
      try {
        A = e[0](v);
      } catch {
      }
      u(A);
    },
    [r, e, u]
  );
  let p = s;
  p === null && (p = "null"), p === void 0 && (p = "undefined");
  const g = f.find((v) => v[1] === p.toString());
  let y;
  g !== void 0 && (y = {
    value: g[1],
    label: g[0],
    datatype: g[2]
  });
  const w = f.map(
    (v) => ({
      value: v[1],
      label: v[0],
      datatype: v[2]
    })
  );
  return (
    // <Suspense fallback={<select disabled={true}></select>}>
    /* @__PURE__ */ b.jsx(
      iW,
      {
        className: "nodedatainput styleddropdown",
        options: w,
        defaultValue: y,
        onChange: (v) => {
          if (v === null) {
            h({
              value: "<NoValue>",
              datatype: "string"
            });
            return;
          }
          h(v);
        }
      }
    )
  );
}, rR = ({ inputconverter: e }) => {
  const t = Rt(), { preview: n, full: r } = t.valuestore(), o = t.use(), a = r === void 0 ? n?.value : r?.value, s = Ul(o), [u, c] = _.useState(e[1](a));
  _.useEffect(() => {
    c(e[1](a));
  }, [a]);
  const f = _.useCallback(
    (y) => {
      let w = y.target.value;
      w || (w = "<NoValue>");
      try {
        w = e[0](w);
      } catch {
      }
      w !== a && s(w);
    },
    [s, e, a]
  );
  let h = o.connected ? e[1](a) : u;
  h == null && (h = ""), h = h.toString();
  const p = (h.toString().match(/\n/g) || []).length, g = Math.max(...h.split(`
`).map((y) => y.length), 0);
  return /* @__PURE__ */ b.jsx(
    "textarea",
    {
      className: "nodedatainput styledinput stringinput",
      value: h,
      onChange: (y) => c(y.target.value),
      onBlur: (y) => {
        f(y);
      },
      disabled: o.connected,
      rows: p + 1,
      cols: g + 1
    }
  );
}, lie = {
  float: tie,
  int: nie,
  bool: Ooe,
  string: rR,
  str: rR,
  color: Noe,
  select: Xc,
  enum: Xc,
  bytes: S4(Fx, "")
}, uie = {}, cie = {}, to = {
  Inputrenderer: lie,
  Outputrenderer: Moe,
  HandlePreviewRenderer: Aoe,
  DataOverlayRenderer: Toe,
  DataPreviewViewRenderer: E4,
  DataViewRenderer: $x,
  InLineRenderer: koe,
  NodeRenderer: uie,
  NodeHooks: cie
}, fie = (e, t) => {
  const n = t.options || {}, r = n.overwrite === void 0 ? !0 : n.overwrite;
  switch (t.type) {
    case "EXTEND_INPUT_RENDER":
      return !r && e.Inputrenderer[t.payload.type] ? e : {
        ...e,
        Inputrenderer: {
          ...e.Inputrenderer,
          [t.payload.type]: t.payload.component
        }
      };
    case "EXTEND_FROM_PLUGIN": {
      let s = !1;
      const u = [
        [t.payload.plugin.input_renderers || {}, e.Inputrenderer],
        [t.payload.plugin.output_renderers || {}, e.Outputrenderer],
        [
          t.payload.plugin.handle_preview_renderers || {},
          e.HandlePreviewRenderer
        ],
        [
          t.payload.plugin.data_overlay_renderers || {},
          e.DataOverlayRenderer
        ],
        [
          t.payload.plugin.data_preview_renderers || {},
          e.DataPreviewViewRenderer
        ],
        [
          t.payload.plugin.data_view_renderers || {},
          e.DataViewRenderer
        ],
        [t.payload.plugin.node_renderers || {}, e.NodeRenderer],
        [t.payload.plugin.node_hooks || {}, e.NodeHooks]
      ];
      for (const [f, h] of u) {
        if (Object.keys(f).length > 0) {
          if (r)
            s = !0;
          else
            for (const p in f)
              if (!h[p]) {
                s = !0;
                break;
              }
        }
        if (s) break;
      }
      if (!s)
        return e;
      const c = { ...e };
      return u.forEach(([f, h]) => {
        Object.assign(h, f);
      }), c;
    }
    default:
      const a = {
        EXTEND_OUTPUT_RENDER: "Outputrenderer",
        EXTEND_HANDLE_PREVIEW_RENDER: "HandlePreviewRenderer",
        EXTEND_DATA_OVERLAY_RENDER: "DataOverlayRenderer",
        EXTEND_DATA_PREVIEW_RENDER: "DataPreviewViewRenderer",
        EXTEND_DATA_VIEW_RENDER: "DataViewRenderer",
        EXTEND_NODE_CONTEXT_EXTENDER: "NodeContextExtenders",
        EXTEND_NODE_RENDERER: "NodeRenderer",
        EXTEND_NODE_HOOKS: "NodeHooks"
      }[t.type];
      if (a) {
        const s = e[a];
        return !r && s[t.payload.type] ? e : {
          ...e,
          [a]: {
            ...s,
            [t.payload.type]: t.payload.component
          }
        };
      }
      return e;
  }
}, die = ({
  children: e,
  plugins: t,
  fnrf_zst: n
}) => {
  const [r, o] = _.useReducer(
    fie,
    to
  ), a = (w, v, S) => {
    o({
      type: "EXTEND_INPUT_RENDER",
      payload: { type: w, component: v },
      options: S
    });
  }, s = (w, v, S) => {
    o({
      type: "EXTEND_OUTPUT_RENDER",
      payload: { type: w, component: v },
      options: S
    });
  }, u = (w, v, S) => {
    o({
      type: "EXTEND_HANDLE_PREVIEW_RENDER",
      payload: { type: w, component: v },
      options: S
    });
  }, c = (w, v, S) => {
    o({
      type: "EXTEND_DATA_OVERLAY_RENDER",
      payload: { type: w, component: v },
      options: S
    });
  }, f = (w, v, S) => {
    o({
      type: "EXTEND_DATA_PREVIEW_RENDER",
      payload: { type: w, component: v },
      options: S
    });
  }, h = (w, v, S) => {
    o({
      type: "EXTEND_DATA_VIEW_RENDER",
      payload: { type: w, component: v },
      options: S
    });
  }, p = (w, v, S) => {
    o({
      type: "EXTEND_NODE_RENDERER",
      payload: { type: w, component: v },
      options: S
    });
  }, g = (w, v, S) => {
    o({
      type: "EXTEND_NODE_HOOKS",
      payload: { type: w, component: v },
      options: S
    });
  }, y = (w, v) => {
    o({
      type: "EXTEND_FROM_PLUGIN",
      payload: { plugin: w },
      options: v
    });
  };
  return _.useEffect(() => {
    for (const w in t) {
      const v = t[w];
      if (!v) continue;
      const S = v.renderpluginfactory;
      S && y(S({ React: yl, fnrf_zst: n, NodeContext: Gm }));
    }
  }, [t]), /* @__PURE__ */ b.jsx(
    pi.Provider,
    {
      value: {
        Inputrenderer: r.Inputrenderer,
        Outputrenderer: r.Outputrenderer,
        HandlePreviewRenderer: r.HandlePreviewRenderer,
        DataOverlayRenderer: r.DataOverlayRenderer,
        DataPreviewViewRenderer: r.DataPreviewViewRenderer,
        DataViewRenderer: r.DataViewRenderer,
        InLineRenderer: r.InLineRenderer,
        NodeRenderer: r.NodeRenderer,
        NodeHooks: r.NodeHooks,
        extendNodeRenderer: p,
        extendInputRenderMapping: a,
        extendOutputRenderMapping: s,
        extendHandlePreviewRenderMapping: u,
        extendDataOverlayRenderMapping: c,
        extendDataPreviewRenderMapping: f,
        extendDataViewRenderMapping: h,
        extendNodeHooks: g,
        extendFromPlugin: y
      },
      children: e
    }
  );
}, pi = _.createContext({
  Inputrenderer: to.Inputrenderer,
  Outputrenderer: to.Outputrenderer,
  HandlePreviewRenderer: to.HandlePreviewRenderer,
  DataOverlayRenderer: to.DataOverlayRenderer,
  DataPreviewViewRenderer: to.DataPreviewViewRenderer,
  DataViewRenderer: to.DataViewRenderer,
  InLineRenderer: to.InLineRenderer,
  NodeRenderer: to.NodeRenderer,
  NodeHooks: to.NodeHooks,
  extendInputRenderMapping: (e, t, n) => {
  },
  extendOutputRenderMapping: (e, t, n) => {
  },
  extendHandlePreviewRenderMapping: (e, t, n) => {
  },
  extendDataOverlayRenderMapping: (e, t, n) => {
  },
  extendDataPreviewRenderMapping: (e, t, n) => {
  },
  extendDataViewRenderMapping: (e, t, n) => {
  },
  extendNodeRenderer: (e, t, n) => {
  },
  extendNodeHooks: (e, t, n) => {
  },
  extendFromPlugin: (e, t) => {
  }
}), B4 = (e) => {
  const t = tt(), { DataOverlayRenderer: n, DataViewRenderer: r } = _.useContext(pi);
  if (e === void 0) return;
  const o = t.render_options(), [a] = ns(e, o.typemap || {});
  return a ? n[a] ? n[a] : r[a] ? Vm(r[a]) : nR : nR;
}, hie = (e) => {
  const t = tt(), n = B4(e), { DataPreviewViewRenderer: r, DataViewRenderer: o } = _.useContext(pi), a = t.render_options();
  if (e === void 0) return [void 0, n];
  const [s] = ns(e, a.typemap || {});
  return s ? r[s] ? [r[s], n] : o[s] ? [
    zn(o[s]),
    n
  ] : [
    zn(Op),
    n
  ] : [
    zn(Op),
    n
  ];
}, pie = (e) => {
  const n = tt().render_options(), { HandlePreviewRenderer: r, DataPreviewViewRenderer: o } = _.useContext(pi), a = B4(e);
  let s;
  if (e) {
    const [u] = ns(e, n.typemap || {});
    u ? r[u] ? s = r[u] : o[u] ? s = o[u] : s = zn(
      Op
    ) : s = zn(
      Op
    );
  }
  return [s, a];
}, mie = (e) => {
  const [t, n] = _.useState(!1), r = e.use((o) => o.in_trigger);
  return _.useEffect(() => {
    let o;
    return r && !t ? n(!0) : t && (o = setTimeout(() => n(!1), 200)), () => clearTimeout(o);
  }, [r, t]), { visualTrigger: t, nodestore: e };
}, Gm = _.createContext({}), cr = () => _.useContext(Gm), aa = _.createContext(void 0);
function Rt(e) {
  if (e)
    return cr().io_stores.get(e);
  {
    const t = _.useContext(aa);
    if (!t)
      throw new Error("IOContext not set");
    return t;
  }
}
function Ul(e) {
  const { node: t } = xn();
  if (e || (e = Rt().use()), typeof e == "string" && (e = Rt(e)?.use(), !e))
    throw new Error(`No IO found for ${e}`);
  if (!e)
    throw new Error("No IO found");
  return _.useCallback(
    (r, o) => {
      t?.set_io_value({
        nid: e.node,
        ioid: e.id,
        value: r,
        set_default: o ?? e.render_options.set_default
      });
    },
    [e, t]
  );
}
function gie(e) {
  const { node: t } = xn();
  let n, r;
  if (!e) {
    const s = Rt().useShallow((u) => ({
      io_id: u.id,
      node_id: u.node
    }));
    n = s.io_id, r = s.node_id;
  }
  if (typeof e == "string") {
    const a = Rt(e);
    if (!a)
      throw new Error(`No IO found for ${e}`);
    const s = a.useShallow((u) => ({
      io_id: u.id,
      node_id: u.node
    }));
    n = s.io_id, r = s.node_id;
  } else {
    if (!e)
      throw new Error("No IO found");
    n = e.id, r = e.node;
  }
  return _.useCallback(
    (a) => {
      t?.set_io_value_options({
        nid: r,
        ioid: n,
        values: a.values ?? a.keys,
        keys: a.keys,
        nullable: a.nullable ?? !1
      });
    },
    [t, n, r]
  );
}
function yie(e) {
  return Rt(e)?.valuestore();
}
function Ym(e) {
  const t = Rt(e);
  if (!t) return;
  const { node: n, id: r } = t.useShallow((s) => ({
    node: s.node,
    id: s.id
  })), { node: o } = xn();
  return _.useCallback(() => o?.get_io_full_value({ nid: n, ioid: r }), [o, n, r]);
}
function Hx(e) {
  const t = Rt(e);
  if (!t) return;
  const { node: n, id: r } = t.useShallow((s) => ({
    node: s.node,
    id: s.id
  })), { node: o } = xn();
  return _.useCallback(
    (s) => {
      o?.update_io_options({
        nid: n,
        ioid: r,
        options: { hidden: s }
      });
    },
    [o, n, r]
  );
}
const H4 = ({
  iostore: e,
  Component: t
}) => {
  const [n, r] = _.useState(void 0), [o, a] = _.useState(void 0), { full: s } = e.valuestore(), u = Ym();
  _.useEffect(() => {
    s === void 0 ? u?.() : a(s.value);
  }, [s, u]);
  const c = () => {
    o !== void 0 && r(o);
  };
  return /* @__PURE__ */ b.jsx(
    t,
    {
      value: o,
      preValue: n,
      onLoaded: c
    }
  );
}, V4 = ({
  Component: e
}) => /* @__PURE__ */ b.jsx(e, {}), ns = (e, t) => U4(e.render_options?.type ?? "any", t), U4 = (e, t) => {
  if (typeof e == "string")
    return e in t ? [t[e], e] : [e, e];
  if ("allOf" in e && e.allOf !== void 0)
    return [void 0, void 0];
  if ("anyOf" in e && e.anyOf !== void 0) {
    const n = e.anyOf.map(
      (r) => U4(r || "any", t)
    );
    for (const r of n)
      switch (r[0]) {
        case "bool":
          return ["bool", r[1]];
        case "enum":
          return ["enum", r[1]];
        case "float":
          return ["float", r[1]];
        case "int":
          return ["int", r[1]];
        case "string":
          return ["string", r[1]];
        case "str":
          return ["string", r[1]];
      }
    return [void 0, void 0];
  }
  return !("type" in e) || e.type === void 0 ? [void 0, void 0] : e.type === "enum" ? ["enum", "enum"] : [void 0, void 0];
}, Yb = ({
  typestring: e,
  preview: t,
  ...n
}) => {
  const [r, o] = _.useState(!1), [a, s] = _.useState(!1), u = tt(), c = Rt(), f = c.use(), h = Ym(), [p, g] = pie(f), y = u.local_state(() => u.reactflowRef);
  return (
    // <Tooltip.Provider>
    /* @__PURE__ */ b.jsxs(o2, { open: r || a, onOpenChange: s, children: [
      /* @__PURE__ */ b.jsx(i2, { asChild: !0, children: /* @__PURE__ */ b.jsx(Ja, { id: f.id, "data-type": e, ...n }) }),
      /* @__PURE__ */ b.jsx(a2, { container: y, children: /* @__PURE__ */ b.jsxs(
        s2,
        {
          className: "iotooltipcontent",
          sideOffset: 5,
          avoidCollisions: !0,
          collisionBoundary: y,
          collisionPadding: 10,
          onOpenAutoFocus: (w) => w.preventDefault(),
          onCloseAutoFocus: (w) => w.preventDefault(),
          children: [
            /* @__PURE__ */ b.jsxs("div", { className: "iotooltip_container", children: [
              /* @__PURE__ */ b.jsxs("div", { className: "iotooltip_header", children: [
                r ? /* @__PURE__ */ b.jsx(DV, { onClick: () => o(!1) }) : /* @__PURE__ */ b.jsx(NV, { onClick: () => o(!0) }),
                g && /* @__PURE__ */ b.jsx(
                  ci,
                  {
                    title: f.full_id,
                    trigger: /* @__PURE__ */ b.jsx(gN, {}),
                    onOpenChange: (w) => {
                      w && h?.(), o(w);
                    },
                    children: /* @__PURE__ */ b.jsx(
                      H4,
                      {
                        Component: g,
                        iostore: c
                      }
                    )
                  }
                )
              ] }),
              p ? /* @__PURE__ */ b.jsx(V4, { Component: p }) : `no preview available for "${e}"`
            ] }),
            /* @__PURE__ */ b.jsx(pq, { className: "iotooltipcontentarrow" })
          ]
        }
      ) })
    ] })
  );
}, Nl = {
  "": [(e) => e, (e) => e],
  str_to_json: [
    (e) => JSON.parse(e),
    (e) => typeof e == "string" ? e : JSON.stringify(e)
  ],
  str_to_list: [
    (e) => {
      try {
        const t = JSON.parse(e);
        return Array.isArray(t) ? t : [t];
      } catch {
        try {
          return JSON.parse("[" + e + "]");
        } catch {
        }
      }
      throw new Error("Invalid list");
    },
    (e) => JSON.stringify(e)
  ]
}, vie = ({
  setNodeSettingsPath: e,
  setShowSettings: t
}) => {
  const r = tt().render_options(), a = Rt().use(), [s, u] = ns(a, r.typemap || {}), { Inputrenderer: c } = _.useContext(pi), f = s ? a.value_options?.options ? Xc : c[s] : void 0, h = Nl[(u && r.inputconverter?.[u]) ?? ""] || Nl[""], { keys: p } = W1(), g = (y) => {
    p.has("s") && (e && e("inputs/" + a.id), t && t(!0), y.stopPropagation());
  };
  return a.hidden ? null : /* @__PURE__ */ b.jsxs(
    "div",
    {
      className: "nodeinput",
      "data-type": s,
      onClick: g,
      children: [
        /* @__PURE__ */ b.jsx(
          Yb,
          {
            typestring: s,
            position: Ee.Left,
            type: "target"
          }
        ),
        /* @__PURE__ */ b.jsxs("div", { className: "inner_nodeio", children: [
          f && /* @__PURE__ */ b.jsx("div", { className: "iovaluefield nodrag", "data-type": s, children: /* @__PURE__ */ b.jsx(f, { inputconverter: h }) }),
          /* @__PURE__ */ b.jsx("div", { className: "ioname", children: a.name })
        ] }),
        /* @__PURE__ */ b.jsx(
          Yb,
          {
            typestring: s,
            position: Ee.Right,
            type: "source"
          }
        )
      ]
    }
  );
}, bie = ({
  setNodeSettingsPath: e,
  setShowSettings: t
}) => {
  const r = tt().render_options(), a = Rt().use(), [s] = ns(a, r.typemap || {}), { Outputrenderer: u } = _.useContext(pi), { keys: c } = W1(), f = s ? u[s] : void 0, h = (p) => {
    c.has("s") && (e && e("outputs/" + a.id), t && t(!0), p.stopPropagation());
  };
  return a.hidden ? null : /* @__PURE__ */ b.jsxs(
    "div",
    {
      className: "nodeoutput",
      "data-type": s,
      onClick: h,
      children: [
        /* @__PURE__ */ b.jsx(
          Yb,
          {
            typestring: s,
            position: Ee.Right,
            type: "source"
          }
        ),
        /* @__PURE__ */ b.jsxs("div", { className: "inner_nodeio", children: [
          /* @__PURE__ */ b.jsx("div", { className: "ioname", children: a.name }),
          f ? /* @__PURE__ */ b.jsx("div", { className: "iovaluefield nodrag", children: /* @__PURE__ */ b.jsx(f, {}) }) : /* @__PURE__ */ b.jsx("div", { className: "iovaluefield", children: /* @__PURE__ */ b.jsx(Roe, {}) })
        ] })
      ]
    }
  );
}, xie = () => {
  const t = tt().render_options(), r = Rt().use(), o = Hx(), [a, s] = ns(r, t.typemap || {}), { Inputrenderer: u } = _.useContext(pi), c = a ? r.value_options?.options ? Xc : u[a] : void 0, f = Nl[(s && t.inputconverter?.[s]) ?? ""] || Nl[""];
  return /* @__PURE__ */ b.jsxs("div", { className: "nodesettings_component", children: [
    /* @__PURE__ */ b.jsx("div", { children: r.name }),
    c && /* @__PURE__ */ b.jsx(c, { inputconverter: f }),
    /* @__PURE__ */ b.jsx("div", { children: /* @__PURE__ */ b.jsxs("label", { children: [
      "hidden:",
      /* @__PURE__ */ b.jsx(
        "input",
        {
          className: "styledcheckbox",
          type: "checkbox",
          disabled: r.connected,
          onChange: (h) => {
            o?.(h.target.checked);
          },
          checked: r.hidden
        }
      )
    ] }) })
  ] });
}, wie = () => {
  const t = Rt().use(), n = Hx();
  return /* @__PURE__ */ b.jsxs("div", { className: "nodesettings_component", children: [
    /* @__PURE__ */ b.jsx("div", { children: t.name }),
    /* @__PURE__ */ b.jsx("div", { children: /* @__PURE__ */ b.jsxs("label", { children: [
      "hidden:",
      /* @__PURE__ */ b.jsx(
        "input",
        {
          className: "styledcheckbox",
          type: "checkbox",
          disabled: t.connected,
          onChange: (r) => {
            n?.(r.target.checked);
          },
          checked: t.hidden
        }
      )
    ] }) })
  ] });
}, q4 = ({}) => {
  const e = tt(), { node: t } = xn(), r = Rt().use(), o = e.render_options(), a = Hx(), [s, u] = _.useState(r.name);
  _.useEffect(() => u(r.name), [r.name]);
  const c = _.useCallback(
    (v) => u(v.target.value),
    []
  ), f = _.useCallback(() => {
    s !== r.name && t?.update_io_options({
      nid: r.node,
      ioid: r.id,
      options: { name: s }
    });
  }, [r, t, s]), [h, p] = ns(
    r,
    o.typemap || {}
  ), g = Nl[(p && o.inputconverter?.[p]) ?? ""] || Nl[""], { Inputrenderer: y } = _.useContext(pi), w = h ? r.value_options?.options ? Xc : y[h] : void 0;
  return /* @__PURE__ */ b.jsxs("div", { className: "nodesettings-io-entry funcnodes-control-group", children: [
    /* @__PURE__ */ b.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ b.jsx("label", { htmlFor: `io-name-${r.id}`, children: "Name:" }),
      /* @__PURE__ */ b.jsx(
        "input",
        {
          id: `io-name-${r.id}`,
          type: "text",
          value: s,
          onChange: c,
          onBlur: f,
          className: "styledinput"
        }
      )
    ] }),
    /* @__PURE__ */ b.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ b.jsx("label", { children: "ID:" }),
      /* @__PURE__ */ b.jsx("span", { children: r.id })
    ] }),
    /* @__PURE__ */ b.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ b.jsx("label", { children: "Value:" }),
      w && /* @__PURE__ */ b.jsx(w, { inputconverter: g })
    ] }),
    /* @__PURE__ */ b.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ b.jsx("label", { children: "Type:" }),
      /* @__PURE__ */ b.jsx("pre", { children: JSON.stringify(r.type, null, 2) })
    ] }),
    /* @__PURE__ */ b.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ b.jsx("label", { htmlFor: `io-hidden-${r.id}`, children: "Hidden:" }),
      /* @__PURE__ */ b.jsx(
        "input",
        {
          id: `io-hidden-${r.id}`,
          type: "checkbox",
          checked: r.hidden,
          onChange: (v) => a?.(v.target.checked),
          className: "styledcheckbox",
          disabled: r.connected && r.is_input
        }
      )
    ] }),
    /* @__PURE__ */ b.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ b.jsx("label", { children: "Value Options:" }),
      /* @__PURE__ */ b.jsx("pre", { children: JSON.stringify(r.value_options, null, 2) })
    ] }),
    /* @__PURE__ */ b.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ b.jsx("label", { children: "Render Options:" }),
      /* @__PURE__ */ b.jsx("pre", { className: "code-display", children: JSON.stringify(r.render_options, null, 2) })
    ] }),
    r.is_input && /* @__PURE__ */ b.jsxs(b.Fragment, { children: [
      /* @__PURE__ */ b.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ b.jsx("label", { children: "Does Trigger:" }),
        /* @__PURE__ */ b.jsx("span", { children: String(r.does_trigger) })
      ] }),
      /* @__PURE__ */ b.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ b.jsx("label", { children: "Required:" }),
        /* @__PURE__ */ b.jsx("span", { children: String(r.required) })
      ] })
    ] }),
    /* @__PURE__ */ b.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ b.jsx("label", { children: "Emit Value Set:" }),
      /* @__PURE__ */ b.jsx("span", { children: String(r.emit_value_set) })
    ] }),
    /* @__PURE__ */ b.jsx("hr", {})
  ] });
}, Wb = {
  xxs: 0,
  xs: 320,
  s: 480,
  m: 768,
  l: 960,
  xl: 1280,
  xxl: 1920
}, _ie = Object.entries(Wb).sort(
  ([, e], [, t]) => t - e
), G4 = _.createContext(void 0), Sie = (e, t) => {
  let n;
  return (...r) => {
    clearTimeout(n), n = setTimeout(() => e(...r), t);
  };
}, Eie = (e) => {
  for (const [t, n] of _ie)
    if (e >= n)
      return t;
  return "xxs";
}, Y4 = _.memo(
  _.forwardRef(
    (e, t) => {
      const { className: n, children: r, ...o } = e, [a, s] = _.useState(
        {
          wKey: "m",
          w: 0,
          h: 0
        }
      ), u = _.useRef(null);
      _.useImperativeHandle(
        t,
        () => u.current,
        []
      );
      const c = _.useCallback((h) => {
        const p = h.width, g = h.height, y = Eie(p);
        s((w) => w.wKey === y && w.w === p && w.h === g ? w : { wKey: y, w: p, h: g });
      }, []), f = _.useMemo(
        () => Sie(c, 16),
        [c]
      );
      return _.useEffect(() => {
        const h = u.current;
        if (!h)
          return;
        const p = new ResizeObserver((g) => {
          const y = g[0];
          y && f(y.contentRect);
        });
        return c(h.getBoundingClientRect()), p.observe(h), () => {
          p.disconnect();
        };
      }, [c, f]), /* @__PURE__ */ b.jsx(G4.Provider, { value: a, children: /* @__PURE__ */ b.jsx(
        "div",
        {
          ref: u,
          className: `size-context w-${a.wKey} ${n || ""}`.trim(),
          ...o,
          children: r
        }
      ) });
    }
  )
);
Y4.displayName = "SizeContextContainer";
const Cie = () => {
  const e = _.useContext(G4);
  if (!e)
    throw new Error(
      "useSizeContext must be used within a SizeContextContainerContext"
    );
  return e;
}, kie = (e, t) => e === t ? !1 : e === "" ? !0 : Wb[e] < Wb[t], Tie = (e) => {
  const { wKey: t } = Cie();
  return kie(t, e);
}, oR = (e, t, n = "", r = "") => {
  const o = [];
  return typeof e == "string" ? o.push(`${t}-${e}`) : typeof e == "boolean" ? o.push(e ? n : r) : e && typeof e == "object" && Object.entries(e).forEach(([a, s]) => {
    if (typeof s == "string")
      o.push(
        a === "" ? `${t}-${s}` : `${a}-${t}-${s}`
      );
    else if (typeof s == "boolean") {
      const u = s ? n : r;
      u && o.push(a === "" ? u : `${a}-${u}`);
    }
  }), o.filter(Boolean).join(" ");
}, Ji = _.memo(
  ({
    direction: e,
    className: t = "",
    children: n,
    wrap: r = !1,
    grow: o = !1,
    ...a
  }) => {
    const s = "float-container", u = oR(e, "direction"), c = oR(o, "", "grow", "no-grow"), h = [
      s,
      u,
      c,
      typeof r == "boolean" && r ? "flex-wrap" : "",
      t
    ].filter(Boolean).join(" ");
    return /* @__PURE__ */ b.jsx("div", { className: h, ...a, children: n });
  }
);
Ji.displayName = "FloatContainer";
const Aie = {
  up: (e) => /* @__PURE__ */ b.jsx(b.Fragment, { children: "" }),
  down: (e) => /* @__PURE__ */ b.jsx(b.Fragment, { children: "" }),
  left: (e) => /* @__PURE__ */ b.jsx(b.Fragment, { children: "" }),
  right: (e) => /* @__PURE__ */ b.jsx(b.Fragment, { children: "" })
}, Rie = {
  up: (e) => /* @__PURE__ */ b.jsx(b.Fragment, { children: "" }),
  down: (e) => /* @__PURE__ */ b.jsx(b.Fragment, { children: "" }),
  left: (e) => /* @__PURE__ */ b.jsx(b.Fragment, { children: "" }),
  right: (e) => /* @__PURE__ */ b.jsx(b.Fragment, { children: "" })
}, Vx = _.memo(
  ({
    direction: e,
    expanded: t = !0,
    children: n,
    className: r,
    maxSize: o = "18.75rem",
    expanderSize: a = "2rem",
    containerStyle: s,
    style: u,
    containerClassName: c,
    expandIcons: f,
    collapseIcons: h,
    onExpandChange: p,
    ...g
  }) => {
    const [y, w] = _.useState(t);
    _.useEffect(() => {
      w(t);
    }, [t]);
    const v = _.useCallback(() => {
      w((M) => {
        const F = !M;
        return p?.(F), F;
      });
    }, [p]), S = _.useCallback(
      (M) => {
        (M.key === "Enter" || M.key === " ") && (M.preventDefault(), v());
      },
      [v]
    ), E = e === "right" || e === "left", A = e === "left" || e === "up", k = y ? h?.[e] || Rie[e] : f?.[e] || Aie[e], T = `${e} ${y ? "expanded" : "collapsed"}`, R = _.useMemo(
      () => ({
        [E ? "width" : "height"]: y ? o : a
      }),
      [E, y, o, a]
    ), N = _.useMemo(
      () => ({
        [E ? "width" : "height"]: y ? o : 0
      }),
      [E, y, o]
    ), j = _.useMemo(
      () => ({
        [E ? "width" : "height"]: a
      }),
      [E, a]
    ), z = /* @__PURE__ */ b.jsx(
      "div",
      {
        className: `expanding_container_content ${T} ${r || ""}`.trim(),
        style: { ...u, ...N },
        ...g,
        children: n
      }
    ), B = /* @__PURE__ */ b.jsx(
      "div",
      {
        className: `expanding_container_expander ${T}`,
        onClick: v,
        onKeyDown: S,
        style: j,
        role: "button",
        tabIndex: 0,
        "aria-label": `${y ? "Collapse" : "Expand"} ${e}`,
        children: /* @__PURE__ */ b.jsx(k, {})
      }
    );
    return /* @__PURE__ */ b.jsxs(
      "div",
      {
        className: `expanding_container ${T} ${c || ""}`,
        style: { ...s, ...R },
        children: [
          A ? B : z,
          A ? z : B
        ]
      }
    );
  }
);
Vx.displayName = "ExpandingContainer";
const Mie = ({ nodestore: e }) => {
  const t = e.use();
  return /* @__PURE__ */ b.jsx(Gm.Provider, { value: e, children: /* @__PURE__ */ b.jsxs("div", { className: "nodesettings_content", children: [
    /* @__PURE__ */ b.jsx("div", { className: "nodesettings_section", children: /* @__PURE__ */ b.jsxs("div", { className: "nodesettings_component", children: [
      /* @__PURE__ */ b.jsx("div", { children: "Name" }),
      /* @__PURE__ */ b.jsx("div", { children: /* @__PURE__ */ b.jsx(Yx, {}) })
    ] }) }),
    /* @__PURE__ */ b.jsxs("div", { className: "nodesettings_section", children: [
      /* @__PURE__ */ b.jsx("div", { children: "Inputs" }),
      t.inputs.map((n) => {
        const r = e.io_stores.get(n);
        if (r)
          return /* @__PURE__ */ b.jsx(aa.Provider, { value: r, children: /* @__PURE__ */ b.jsx(xie, {}) }, n);
      })
    ] }),
    /* @__PURE__ */ b.jsxs("div", { className: "nodesettings_section", children: [
      /* @__PURE__ */ b.jsx("div", { children: "Outputs" }),
      t.outputs.map((n) => {
        const r = e.io_stores.get(n);
        if (r)
          return /* @__PURE__ */ b.jsx(aa.Provider, { value: r, children: /* @__PURE__ */ b.jsx(wie, {}) }, n);
      })
    ] })
  ] }) });
}, Oie = () => {
  const e = tt(), t = e.local_state((r) => r.selected_nodes);
  if (t.length === 0)
    return /* @__PURE__ */ b.jsx("div", { children: "Node Settings" });
  if (t.length > 1)
    return /* @__PURE__ */ b.jsx("div", { children: "Multiple Nodes Selected" });
  const n = e.nodespace.get_node(t[0]);
  return n ? /* @__PURE__ */ b.jsx(Mie, { nodestore: n }) : /* @__PURE__ */ b.jsx("div", { children: "Node not found" });
}, Nie = () => {
  const e = tt(), t = e.local_settings(
    (r) => r.view_settings.expand_node_props
  ), n = (r) => {
    e.update_view_settings({ expand_node_props: r });
  };
  return /* @__PURE__ */ b.jsx(
    Vx,
    {
      direction: "left",
      expanded: t === void 0 ? !1 : t,
      containerClassName: "pos-right pos-top bg1 h-12",
      className: "nodesettings_content",
      onExpandChange: n,
      collapseIcons: {
        up: Pc,
        down: _l,
        left: jc,
        right: ap
      },
      expandIcons: {
        up: _l,
        down: Pc,
        left: ap,
        right: jc
      },
      children: /* @__PURE__ */ b.jsx(Oie, {})
    }
  );
};
var xv = "rovingFocusGroup.onEntryFocus", Die = { bubbles: !1, cancelable: !0 }, Sf = "RovingFocusGroup", [Xb, W4, jie] = _m(Sf), [Pie, Wm] = _o(
  Sf,
  [jie]
), [Iie, zie] = Pie(Sf), X4 = _.forwardRef(
  (e, t) => /* @__PURE__ */ b.jsx(Xb.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ b.jsx(Xb.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ b.jsx(Lie, { ...e, ref: t }) }) })
);
X4.displayName = Sf;
var Lie = _.forwardRef((e, t) => {
  const {
    __scopeRovingFocusGroup: n,
    orientation: r,
    loop: o = !1,
    dir: a,
    currentTabStopId: s,
    defaultCurrentTabStopId: u,
    onCurrentTabStopIdChange: c,
    onEntryFocus: f,
    preventScrollOnEntryFocus: h = !1,
    ...p
  } = e, g = _.useRef(null), y = bt(t, g), w = Um(a), [v, S] = sa({
    prop: s,
    defaultProp: u ?? null,
    onChange: c,
    caller: Sf
  }), [E, A] = _.useState(!1), k = Hn(f), T = W4(n), R = _.useRef(!1), [N, j] = _.useState(0);
  return _.useEffect(() => {
    const z = g.current;
    if (z)
      return z.addEventListener(xv, k), () => z.removeEventListener(xv, k);
  }, [k]), /* @__PURE__ */ b.jsx(
    Iie,
    {
      scope: n,
      orientation: r,
      dir: w,
      loop: o,
      currentTabStopId: v,
      onItemFocus: _.useCallback(
        (z) => S(z),
        [S]
      ),
      onItemShiftTab: _.useCallback(() => A(!0), []),
      onFocusableItemAdd: _.useCallback(
        () => j((z) => z + 1),
        []
      ),
      onFocusableItemRemove: _.useCallback(
        () => j((z) => z - 1),
        []
      ),
      children: /* @__PURE__ */ b.jsx(
        qe.div,
        {
          tabIndex: E || N === 0 ? -1 : 0,
          "data-orientation": r,
          ...p,
          ref: y,
          style: { outline: "none", ...e.style },
          onMouseDown: xe(e.onMouseDown, () => {
            R.current = !0;
          }),
          onFocus: xe(e.onFocus, (z) => {
            const B = !R.current;
            if (z.target === z.currentTarget && B && !E) {
              const M = new CustomEvent(xv, Die);
              if (z.currentTarget.dispatchEvent(M), !M.defaultPrevented) {
                const F = T().filter((I) => I.focusable), q = F.find((I) => I.active), Y = F.find((I) => I.id === v), V = [q, Y, ...F].filter(
                  Boolean
                ).map((I) => I.ref.current);
                Q4(V, h);
              }
            }
            R.current = !1;
          }),
          onBlur: xe(e.onBlur, () => A(!1))
        }
      )
    }
  );
}), K4 = "RovingFocusGroupItem", Z4 = _.forwardRef(
  (e, t) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: r = !0,
      active: o = !1,
      tabStopId: a,
      children: s,
      ...u
    } = e, c = po(), f = a || c, h = zie(K4, n), p = h.currentTabStopId === f, g = W4(n), { onFocusableItemAdd: y, onFocusableItemRemove: w, currentTabStopId: v } = h;
    return _.useEffect(() => {
      if (r)
        return y(), () => w();
    }, [r, y, w]), /* @__PURE__ */ b.jsx(
      Xb.ItemSlot,
      {
        scope: n,
        id: f,
        focusable: r,
        active: o,
        children: /* @__PURE__ */ b.jsx(
          qe.span,
          {
            tabIndex: p ? 0 : -1,
            "data-orientation": h.orientation,
            ...u,
            ref: t,
            onMouseDown: xe(e.onMouseDown, (S) => {
              r ? h.onItemFocus(f) : S.preventDefault();
            }),
            onFocus: xe(e.onFocus, () => h.onItemFocus(f)),
            onKeyDown: xe(e.onKeyDown, (S) => {
              if (S.key === "Tab" && S.shiftKey) {
                h.onItemShiftTab();
                return;
              }
              if (S.target !== S.currentTarget) return;
              const E = Bie(S, h.orientation, h.dir);
              if (E !== void 0) {
                if (S.metaKey || S.ctrlKey || S.altKey || S.shiftKey) return;
                S.preventDefault();
                let k = g().filter((T) => T.focusable).map((T) => T.ref.current);
                if (E === "last") k.reverse();
                else if (E === "prev" || E === "next") {
                  E === "prev" && k.reverse();
                  const T = k.indexOf(S.currentTarget);
                  k = h.loop ? Hie(k, T + 1) : k.slice(T + 1);
                }
                setTimeout(() => Q4(k));
              }
            }),
            children: typeof s == "function" ? s({ isCurrentTabStop: p, hasTabStop: v != null }) : s
          }
        )
      }
    );
  }
);
Z4.displayName = K4;
var Fie = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function $ie(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function Bie(e, t, n) {
  const r = $ie(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return Fie[r];
}
function Q4(e, t = !1) {
  const n = document.activeElement;
  for (const r of e)
    if (r === n || (r.focus({ preventScroll: t }), document.activeElement !== n)) return;
}
function Hie(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
var J4 = X4, eD = Z4, Xm = "Tabs", [Vie, gme] = _o(Xm, [
  Wm
]), tD = Wm(), [Uie, Ux] = Vie(Xm), nD = _.forwardRef(
  (e, t) => {
    const {
      __scopeTabs: n,
      value: r,
      onValueChange: o,
      defaultValue: a,
      orientation: s = "horizontal",
      dir: u,
      activationMode: c = "automatic",
      ...f
    } = e, h = Um(u), [p, g] = sa({
      prop: r,
      onChange: o,
      defaultProp: a ?? "",
      caller: Xm
    });
    return /* @__PURE__ */ b.jsx(
      Uie,
      {
        scope: n,
        baseId: po(),
        value: p,
        onValueChange: g,
        orientation: s,
        dir: h,
        activationMode: c,
        children: /* @__PURE__ */ b.jsx(
          qe.div,
          {
            dir: h,
            "data-orientation": s,
            ...f,
            ref: t
          }
        )
      }
    );
  }
);
nD.displayName = Xm;
var rD = "TabsList", oD = _.forwardRef(
  (e, t) => {
    const { __scopeTabs: n, loop: r = !0, ...o } = e, a = Ux(rD, n), s = tD(n);
    return /* @__PURE__ */ b.jsx(
      J4,
      {
        asChild: !0,
        ...s,
        orientation: a.orientation,
        dir: a.dir,
        loop: r,
        children: /* @__PURE__ */ b.jsx(
          qe.div,
          {
            role: "tablist",
            "aria-orientation": a.orientation,
            ...o,
            ref: t
          }
        )
      }
    );
  }
);
oD.displayName = rD;
var iD = "TabsTrigger", aD = _.forwardRef(
  (e, t) => {
    const { __scopeTabs: n, value: r, disabled: o = !1, ...a } = e, s = Ux(iD, n), u = tD(n), c = uD(s.baseId, r), f = cD(s.baseId, r), h = r === s.value;
    return /* @__PURE__ */ b.jsx(
      eD,
      {
        asChild: !0,
        ...u,
        focusable: !o,
        active: h,
        children: /* @__PURE__ */ b.jsx(
          qe.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": h,
            "aria-controls": f,
            "data-state": h ? "active" : "inactive",
            "data-disabled": o ? "" : void 0,
            disabled: o,
            id: c,
            ...a,
            ref: t,
            onMouseDown: xe(e.onMouseDown, (p) => {
              !o && p.button === 0 && p.ctrlKey === !1 ? s.onValueChange(r) : p.preventDefault();
            }),
            onKeyDown: xe(e.onKeyDown, (p) => {
              [" ", "Enter"].includes(p.key) && s.onValueChange(r);
            }),
            onFocus: xe(e.onFocus, () => {
              const p = s.activationMode !== "manual";
              !h && !o && p && s.onValueChange(r);
            })
          }
        )
      }
    );
  }
);
aD.displayName = iD;
var sD = "TabsContent", lD = _.forwardRef(
  (e, t) => {
    const { __scopeTabs: n, value: r, forceMount: o, children: a, ...s } = e, u = Ux(sD, n), c = uD(u.baseId, r), f = cD(u.baseId, r), h = r === u.value, p = _.useRef(h);
    return _.useEffect(() => {
      const g = requestAnimationFrame(() => p.current = !1);
      return () => cancelAnimationFrame(g);
    }, []), /* @__PURE__ */ b.jsx(Br, { present: o || h, children: ({ present: g }) => /* @__PURE__ */ b.jsx(
      qe.div,
      {
        "data-state": h ? "active" : "inactive",
        "data-orientation": u.orientation,
        role: "tabpanel",
        "aria-labelledby": c,
        hidden: !g,
        id: f,
        tabIndex: 0,
        ...s,
        ref: t,
        style: {
          ...e.style,
          animationDuration: p.current ? "0s" : void 0
        },
        children: g && a
      }
    ) });
  }
);
lD.displayName = sD;
function uD(e, t) {
  return `${e}-trigger-${t}`;
}
function cD(e, t) {
  return `${e}-content-${t}`;
}
var qx = nD, Gx = oD, Sc = aD, Ec = lD;
const qie = ({}) => {
  const e = tt(), t = cr(), { description: n, id: r, node_id: o, node_name: a, reset_inputs_on_trigger: s } = t.useShallow((p) => ({
    description: p.description,
    id: p.id,
    node_id: p.node_id,
    node_name: p.node_name,
    reset_inputs_on_trigger: p.reset_inputs_on_trigger
  })), [u, c] = _.useState(
    n || ""
  );
  _.useEffect(() => c(n || ""), [n]);
  const f = (p) => c(p.target.value), h = () => {
    u !== (n || "") && e.on_node_action({
      type: "update",
      from_remote: !1,
      id: r,
      node: { description: u }
    });
  };
  return /* @__PURE__ */ b.jsxs("div", { className: "nodesettings-section funcnodes-control-group", children: [
    /* @__PURE__ */ b.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ b.jsx("label", { htmlFor: `node-name-${r}`, children: "Name:" }),
      /* @__PURE__ */ b.jsx(Yx, {})
    ] }),
    /* @__PURE__ */ b.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ b.jsx("label", { children: "Instance ID:" }),
      /* @__PURE__ */ b.jsx("span", { children: r })
    ] }),
    /* @__PURE__ */ b.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ b.jsx("label", { children: "Node Type ID:" }),
      /* @__PURE__ */ b.jsx("span", { children: o })
    ] }),
    /* @__PURE__ */ b.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ b.jsx("label", { children: "Node Type Name:" }),
      /* @__PURE__ */ b.jsx("span", { children: a })
    ] }),
    /* @__PURE__ */ b.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ b.jsx("label", { htmlFor: `node-desc-${r}`, children: "Description:" }),
      /* @__PURE__ */ b.jsx(
        "textarea",
        {
          id: `node-desc-${r}`,
          value: u,
          onChange: f,
          onBlur: h,
          className: "styledinput",
          rows: 3
        }
      )
    ] }),
    /* @__PURE__ */ b.jsxs("div", { className: "funcnodes-control-row", children: [
      /* @__PURE__ */ b.jsx("label", { children: "Reset Inputs on Trigger:" }),
      /* @__PURE__ */ b.jsx(
        "input",
        {
          type: "checkbox",
          checked: s,
          onChange: (p) => {
            e.on_node_action({
              type: "update",
              from_remote: !1,
              id: r,
              node: { reset_inputs_on_trigger: p.target.checked }
            });
          },
          className: "styledcheckbox"
        }
      )
    ] })
  ] });
}, Gie = ({ splitnodesettingsPath: e = [] }) => {
  const t = cr(), n = t.use((r) => r.inputs);
  return /* @__PURE__ */ b.jsxs(
    qx,
    {
      defaultValue: e[0] || n[0],
      className: "nodesettings-tabs funcnodes-control-root",
      children: [
        /* @__PURE__ */ b.jsx(
          Gx,
          {
            className: "nodesettings-tabs-list",
            "aria-label": "Manage node inputs",
            children: n.map((r) => /* @__PURE__ */ b.jsx(
              Sc,
              {
                value: r,
                className: "nodesettings-tabs-trigger",
                children: r
              },
              r
            ))
          }
        ),
        n.map((r) => {
          const o = t.io_stores.get(r);
          return /* @__PURE__ */ b.jsx(
            Ec,
            {
              value: r,
              className: "nodesettings-tabs-content nodesettings-io-list",
              children: o && /* @__PURE__ */ b.jsx(aa.Provider, { value: o, children: /* @__PURE__ */ b.jsx(q4, {}) })
            },
            r
          );
        })
      ]
    }
  );
}, Yie = ({ splitnodesettingsPath: e = [] }) => {
  const t = cr(), n = t.use((r) => r.outputs);
  return /* @__PURE__ */ b.jsxs(
    qx,
    {
      defaultValue: e[0] || n[0],
      className: "nodesettings-tabs funcnodes-control-root",
      children: [
        /* @__PURE__ */ b.jsx(
          Gx,
          {
            className: "nodesettings-tabs-list",
            "aria-label": "Manage node outputs",
            children: n.map((r) => /* @__PURE__ */ b.jsx(
              Sc,
              {
                value: r,
                className: "nodesettings-tabs-trigger",
                children: r
              },
              r
            ))
          }
        ),
        n.map((r) => {
          const o = t.io_stores.get(r);
          return /* @__PURE__ */ b.jsx(
            Ec,
            {
              value: r,
              className: "nodesettings-tabs-content nodesettings-io-list",
              children: o && /* @__PURE__ */ b.jsx(aa.Provider, { value: o, children: /* @__PURE__ */ b.jsx(q4, {}) })
            },
            r
          );
        })
      ]
    }
  );
}, Wie = ({
  nodeSettingsPath: e
}) => {
  const t = e.split("/") || ["general"];
  return /* @__PURE__ */ b.jsxs(
    qx,
    {
      defaultValue: t[0] || "general",
      className: "nodesettings-tabs funcnodes-control-root",
      children: [
        /* @__PURE__ */ b.jsxs(
          Gx,
          {
            className: "nodesettings-tabs-list",
            "aria-label": "Manage node settings",
            children: [
              /* @__PURE__ */ b.jsx(Sc, { value: "general", className: "nodesettings-tabs-trigger", children: "General" }),
              /* @__PURE__ */ b.jsx(Sc, { value: "inputs", className: "nodesettings-tabs-trigger", children: "Inputs" }),
              /* @__PURE__ */ b.jsx(Sc, { value: "outputs", className: "nodesettings-tabs-trigger", children: "Outputs" })
            ]
          }
        ),
        /* @__PURE__ */ b.jsx(Ec, { value: "general", className: "nodesettings-tabs-content", children: /* @__PURE__ */ b.jsx(qie, {}) }),
        /* @__PURE__ */ b.jsx(
          Ec,
          {
            value: "inputs",
            className: "nodesettings-tabs-content nodesettings-io-list",
            children: /* @__PURE__ */ b.jsx(
              Gie,
              {
                splitnodesettingsPath: (
                  // all but first element
                  t.slice(1)
                )
              }
            )
          }
        ),
        /* @__PURE__ */ b.jsx(
          Ec,
          {
            value: "outputs",
            className: "nodesettings-tabs-content nodesettings-io-list",
            children: /* @__PURE__ */ b.jsx(
              Yie,
              {
                splitnodesettingsPath: (
                  // all but first element
                  t.slice(1)
                )
              }
            )
          }
        )
      ]
    }
  );
}, Xie = _.memo(
  ({ isOpen: e, onOpenChange: t, nodeSettingsPath: n }) => {
    const o = cr().use((a) => a.id);
    return /* @__PURE__ */ b.jsx(
      ci,
      {
        title: `Node Settings: ${o}`,
        open: e,
        onOpenChange: t,
        dialogClassName: "nodesettings-dialog",
        children: /* @__PURE__ */ b.jsx(Wie, { nodeSettingsPath: n })
      }
    );
  }
), Kie = _.memo(({ toogleShowSettings: e }) => {
  const t = tt(), { node: n } = xn(), r = cr(), { id: o, description: a, node_name: s } = r.useShallow((c) => ({
    id: c.id,
    description: c.description,
    node_name: c.node_name
  })), u = _.useCallback(() => {
    t.on_node_action({
      type: "trigger",
      from_remote: !1,
      id: o
    });
  }, [t, o]);
  return /* @__PURE__ */ b.jsxs("div", { className: "nodeheader", title: a || s, children: [
    /* @__PURE__ */ b.jsxs("div", { className: "nodeheader_element", children: [
      /* @__PURE__ */ b.jsx(
        PV,
        {
          fontSize: "inherit",
          className: "triggerbutton nodeheaderbutton ",
          onClick: u
        }
      ),
      /* @__PURE__ */ b.jsx(
        jV,
        {
          fontSize: "inherit",
          className: "nodestatusbutton nodeheaderbutton",
          onClick: async () => {
            n && console.log("nodestatus", await n.get_node_status(o));
          }
        }
      ),
      /* @__PURE__ */ b.jsx(
        zV,
        {
          fontSize: "inherit",
          className: "nodesettingsbutton nodeheaderbutton",
          onClick: () => {
            e?.();
          }
        }
      )
    ] }),
    /* @__PURE__ */ b.jsx("div", { className: "nodeheader_element nodeheader_title", children: /* @__PURE__ */ b.jsx("div", { className: "nodeheader_title_text", children: s }) }),
    /* @__PURE__ */ b.jsx("div", { className: "nodeheader_element", children: /* @__PURE__ */ b.jsx(uf, { fontSize: "inherit" }) })
  ] });
}), Zie = _.memo(({ iostore: e }) => {
  const t = e.use(), r = cr().use((u) => u.render_options), o = Ym(t.id), [a, s] = hie(t);
  return /* @__PURE__ */ b.jsx(
    "div",
    {
      className: "nodrag nodedatabody",
      "data-src": r?.data?.src || "",
      children: a && t && /* @__PURE__ */ b.jsx(aa.Provider, { value: e, children: /* @__PURE__ */ b.jsx(
        ci,
        {
          title: t.full_id,
          trigger: /* @__PURE__ */ b.jsx("div", { className: "nodedatabutton", children: /* @__PURE__ */ b.jsx(V4, { Component: a }) }),
          onOpenChange: (u) => {
            u && o?.();
          },
          children: s && /* @__PURE__ */ b.jsx(H4, { Component: s, iostore: e })
        }
      ) })
    }
  );
}), Qie = _.memo(
  ({ setShowSettings: e, setNodeSettingsPath: t }) => {
    const n = cr(), { render_options: r, outputs: o, inputs: a } = n.useShallow(
      (u) => ({
        render_options: u.render_options,
        outputs: u.outputs,
        inputs: u.inputs
      })
    ), s = r?.data?.src ? n.io_stores.get(r?.data?.src) : void 0;
    return /* @__PURE__ */ b.jsxs("div", { className: "nodebody nowheel ", children: [
      o.map((u) => {
        const c = n.io_stores.get(u);
        if (c)
          return /* @__PURE__ */ b.jsx(aa.Provider, { value: c, children: /* @__PURE__ */ b.jsx(
            bie,
            {
              setNodeSettingsPath: t,
              setShowSettings: e
            }
          ) }, u);
      }),
      s && /* @__PURE__ */ b.jsx(Zie, { iostore: s }),
      a.map((u) => {
        const c = n.io_stores.get(u);
        if (c)
          return /* @__PURE__ */ b.jsx(aa.Provider, { value: c, children: /* @__PURE__ */ b.jsx(
            vie,
            {
              setNodeSettingsPath: t,
              setShowSettings: e
            }
          ) }, u);
      })
    ] });
  }
), Yx = () => {
  const e = cr(), { original_name: t, id: n } = e.useShallow((c) => ({
    original_name: c.name,
    id: c.id
  })), [r, o] = _.useState(t);
  _.useEffect(() => {
    o(t);
  }, [t]);
  const a = tt(), s = (c) => {
    o(c.target.value);
  }, u = (c) => {
    const f = c.target.value;
    f !== t && a.on_node_action({
      type: "update",
      from_remote: !1,
      id: n,
      node: { name: f }
    });
  };
  return /* @__PURE__ */ b.jsx(
    "input",
    {
      className: "nodename_input",
      value: r,
      onChange: s,
      onBlur: u
    }
  );
}, Jie = () => {
  const t = cr().use((n) => n.progress);
  return t ? /* @__PURE__ */ b.jsx(
    kW,
    {
      state: t,
      className: "nodeprogress"
    }
  ) : null;
}, eae = _.memo(() => {
  const t = cr().use((n) => n.error);
  return /* @__PURE__ */ b.jsxs("div", { className: "nodefooter", children: [
    t && /* @__PURE__ */ b.jsx("div", { className: "nodeerror", children: t }),
    /* @__PURE__ */ b.jsx(Jie, {})
  ] });
}), tae = () => {
  const e = cr(), { collapsed: t, error: n, node_id: r } = e.useShallow((w) => ({
    collapsed: w.properties["frontend:collapsed"] || !1,
    error: w.error,
    node_id: w.node_id
  })), { visualTrigger: o } = mie(e), [a, s] = _.useState(!1), [u, c] = _.useState(""), { keys: f } = W1(), p = _.useContext(pi).NodeHooks[r] ?? [], g = _.useCallback(() => {
    s((w) => !w);
  }, []), y = (w) => {
    f.has("s") && !a && (c(""), s(!0), w.stopPropagation());
  };
  return /* @__PURE__ */ b.jsxs(
    "div",
    {
      className: "innernode" + (o ? " intrigger" : "") + (n ? " error" : ""),
      onClick: y,
      children: [
        /* @__PURE__ */ b.jsx(Kie, { toogleShowSettings: g }),
        /* @__PURE__ */ b.jsx(Yx, {}),
        t ? null : /* @__PURE__ */ b.jsx(
          Qie,
          {
            setNodeSettingsPath: c,
            setShowSettings: s
          }
        ),
        /* @__PURE__ */ b.jsx(eae, {}),
        /* @__PURE__ */ b.jsx(
          Xie,
          {
            isOpen: a,
            onOpenChange: s,
            nodeSettingsPath: u
          }
        ),
        p.map((w, v) => /* @__PURE__ */ b.jsx(_.Fragment, { children: /* @__PURE__ */ b.jsx(w, {}) }, v))
      ]
    }
  );
}, nae = _.memo(
  ({ data: e }) => /* @__PURE__ */ b.jsx(Gm.Provider, { value: e.nodestore, children: /* @__PURE__ */ b.jsx(tae, {}) }),
  (e, t) => e.data.nodestore === t.data.nodestore
), rae = ({
  id: e,
  sourceX: t,
  sourceY: n,
  targetX: r,
  targetY: o,
  sourcePosition: a,
  targetPosition: s,
  data: u,
  ...c
}) => {
  const [f] = Ox({
    sourceX: t,
    sourceY: n,
    sourcePosition: a,
    targetX: r,
    targetY: o,
    targetPosition: s
  });
  return /* @__PURE__ */ b.jsx(b.Fragment, { children: /* @__PURE__ */ b.jsx(_f, { id: e, path: f, ...c }) });
}, oae = {
  default: nae,
  group: Soe
}, iae = {
  default: rae
}, aae = (e) => ({
  nodes: e.getNodes(),
  edges: e.getEdges(),
  onNodesChange: e.onNodesChange,
  onEdgesChange: e.onEdgesChange,
  onConnect: e.onConnect
}), Wx = (e) => {
  const t = /* @__PURE__ */ new Set(), n = e.filter(
    (o) => o.type === "group"
  );
  n.forEach((o) => {
    t.add(o.id);
  });
  const r = e.filter(
    (o) => !t.has(o.id)
  );
  return { group_nodes: n, default_nodes: r };
};
function Np(e) {
  const t = new Map(e.map((s) => [s.id, s])), n = /* @__PURE__ */ new Map(), r = [];
  for (const s of e)
    if (n.has(s.id) || n.set(s.id, []), s.parentId && t.has(s.parentId)) {
      const u = t.get(s.parentId);
      if (u) {
        const c = n.get(u.id) || [];
        c.push(s), n.set(u.id, c);
      } else
        r.push(s);
    } else
      r.push(s);
  const o = [];
  function a(s) {
    o.push(s);
    const u = n.get(s.id) || [];
    for (const c of u)
      a(c);
  }
  for (const s of r)
    a(s);
  if (o.length !== e.length) {
    console.warn(
      "Sorting mismatch: Not all nodes could be placed. Check for circular dependencies or missing parents."
    );
    const s = new Set(o.map((u) => u.id));
    e.forEach((u) => {
      s.has(u.id) || o.push(u);
    });
  }
  return o;
}
const fD = () => {
  const { getNodes: e } = ts();
  return {
    getNodes: e,
    getSelectedNodes: (o) => (o === void 0 && (o = e()), o.filter((a) => a.selected)),
    getSplitNodes: (o) => {
      o === void 0 && (o = e());
      const { group_nodes: a, default_nodes: s } = Wx(o);
      return { group_nodes: a, default_nodes: s };
    },
    getSortedNodes: (o) => (o === void 0 && (o = e()), Np(o))
  };
}, dD = (e, t) => {
  const n = e.getState(), { new_obj: r, change: o } = Ha(n, t);
  o && e.setState(r);
}, hD = (e) => Er(e);
function iR(e) {
  return e != null && typeof e == "object" && "id" in e && typeof e.id == "string";
}
const pD = (e) => {
  let t = e.io ?? {}, n = e.io_order, r = [];
  const o = {};
  if (n === void 0)
    if (Array.isArray(t)) {
      const a = t.filter(iR);
      r = a.map((s) => s.id);
      for (const s of a)
        o[s.id] = s;
    } else {
      r = Object.keys(t);
      for (const a in t)
        t[a] !== void 0 && (o[a] = t[a]);
    }
  else if (r = n, Array.isArray(t)) {
    const a = t.filter(iR);
    for (const s of a)
      o[s.id] = s, r.includes(s.id) || r.push(s.id);
  } else
    for (const a in t)
      t[a] !== void 0 && (o[a] = t[a]), r.includes(a) || r.push(a);
  return { ...e, io_order: r, io: o };
}, sae = {
  id: "dummy",
  node_id: "dummy",
  node_name: "dummy",
  properties: {
    "frontend:size": [200, 100],
    "frontend:pos": [NaN, NaN],
    "frontend:collapsed": !1
  },
  io: {},
  io_order: [],
  name: "dummy",
  in_trigger: !1,
  reset_inputs_on_trigger: !1,
  progress: {
    ascii: !1,
    elapsed: 0,
    initial: 0,
    n: 0,
    prefix: "idle",
    unit: "it",
    unit_divisor: 1e3,
    unit_scale: !1
  }
}, lae = {
  id: "dummy",
  name: "dummy",
  node: "dummy",
  full_id: "dummy",
  type: "any",
  value: void 0,
  is_input: !1,
  connected: !1,
  does_trigger: !0,
  fullvalue: void 0,
  render_options: {
    set_default: !0,
    type: "any"
  },
  hidden: !1,
  emit_value_set: !0,
  required: !1
}, uae = d1(sae), cae = d1(lae), fae = (e) => {
  const t = e.io_order;
  if (t === void 0)
    throw new Error("Node must have io_order");
  return {
    ...e,
    inputs: Object.keys(e.io).filter((r) => e.io[r].is_input),
    outputs: Object.keys(e.io).filter((r) => !e.io[r].is_input),
    io_order: t
  };
}, dae = (e) => (e.value === "<NoValue>" && (e.value = void 0), e.fullvalue === "<NoValue>" && (e.fullvalue = void 0), e.hidden === void 0 && (e.hidden = !1), [{
  ...e
}, e.value, e.fullvalue]), hae = (e) => {
  if (!e.id)
    throw new Error("Node must have an id");
  const t = uae(e);
  return fae(t);
}, pae = (e, t) => {
  const n = e.getState(), r = {}, o = pD(t), a = Object.keys(o);
  for (const s of a)
    switch (s) {
      case "id": {
        const [u, c] = wr(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      case "node_id": {
        const [u, c] = wr(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      case "node_name": {
        const [u, c] = wr(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      case "name": {
        const [u, c] = wr(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      case "in_trigger": {
        const [u, c] = wr(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      case "error": {
        o[s] !== n[s] && (r[s] = o[s]);
        break;
      }
      case "render_options": {
        const [u, c] = rl(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      case "io_order": {
        const [u, c] = ((f, h) => h === void 0 ? [f, !1] : [h, !f1(f, h)])(n[s], o[s]);
        c && (r[s] = u.filter((f) => f !== void 0));
        break;
      }
      case "io": {
        const u = o[s];
        if (u === void 0) break;
        for (const c in u) {
          const f = e.io_stores.get(c);
          if (!f) {
            console.error("io key not found in oldvalue:", c);
            continue;
          }
          f.update(u[c]);
        }
        break;
      }
      case "progress": {
        const [u, c] = rl(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      case "description": {
        r[s] = o[s];
        break;
      }
      case "properties": {
        const [u, c] = rl(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      case "status": {
        const [u, c] = rl(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      case "reset_inputs_on_trigger": {
        const [u, c] = wr(
          n[s],
          o[s]
        );
        c && (r[s] = u);
        break;
      }
      default:
        try {
          nM(s, o[s]);
        } catch (u) {
          console.error(u);
        }
    }
  Object.keys(r).length > 0 && e.setState(r);
}, mae = (e, t) => {
  const n = e.getState(), r = {}, o = {}, a = Object.keys(t);
  for (const s of a)
    switch (s) {
      case "name": {
        const [u, c] = wr(
          n[s],
          t[s]
        );
        c && (r[s] = u);
        break;
      }
      case "id": {
        const [u, c] = wr(
          n[s],
          t[s]
        );
        c && (r[s] = u);
        break;
      }
      case "connected": {
        const [u, c] = wr(
          n[s],
          t[s]
        );
        c && (r[s] = u);
        break;
      }
      case "does_trigger": {
        const [u, c] = wr(
          n[s],
          t[s]
        );
        c && (r[s] = u);
        break;
      }
      case "hidden": {
        const [u, c] = wr(
          n[s],
          t[s]
        );
        c && (r[s] = u);
        break;
      }
      case "full_id": {
        const [u, c] = wr(
          n[s],
          t[s]
        );
        c && (r[s] = u);
        break;
      }
      case "is_input":
        break;
      case "node":
        break;
      case "type":
        break;
      case "value": {
        o.preview = t[s];
        break;
      }
      case "fullvalue": {
        o.full = t[s];
        break;
      }
      case "render_options": {
        const [u, c] = rl(
          n[s],
          t[s]
        );
        c && (r[s] = u);
        break;
      }
      case "value_options": {
        const [u, c] = rl(
          n[s],
          t[s]
        );
        c && (r[s] = u);
        break;
      }
      case "valuepreview_type": {
        r[s] = t[s];
        break;
      }
      case "emit_value_set": {
        r[s] = t[s];
        break;
      }
      case "default": {
        r[s] = t[s];
        break;
      }
      case "required": {
        r[s] = t[s];
        break;
      }
      default:
        try {
          nM(s, t[s]);
        } catch (u) {
          console.error(u);
        }
    }
  Object.keys(o).length > 0 && e.updateValueStore(o), Object.keys(r).length > 0 && e.setState(r);
}, gae = (e) => {
  if (!e.id)
    throw new Error(
      "IO must have an id but is missing for " + JSON.stringify(e)
    );
  e.name === void 0 && (e.name = e.id);
  const t = cae(e);
  return (t.render_options.type === "any" || t.render_options.type === void 0) && (t.render_options.type = t.type), dae(t);
}, yae = (e, t) => {
  let n;
  const [r, o, a] = gae(t);
  return n = {
    io_state: hD((s, u) => r),
    use: (s) => s ? n.io_state(s) : n.io_state(),
    useShallow: (s) => n.io_state(Lx(s)),
    getState: () => n.io_state.getState(),
    setState: (s) => {
      n.io_state.setState(s);
    },
    update: (s) => {
      mae(n, s);
    },
    valuestore: Er((s, u) => {
      let c = o;
      c === "<NoValue>" && (c = void 0), !(c instanceof co) && c !== void 0 && (c = Qi.fromObject(c));
      let f = a;
      return f === "<NoValue>" && (f = void 0), !(f instanceof co) && f !== void 0 && (f = Qi.fromObject(f)), {
        preview: c,
        full: f
      };
    }),
    updateValueStore: (s) => {
      n.valuestore.setState((u) => (u.preview && typeof u.preview.dispose == "function" && u.preview.dispose(), u.full && typeof u.full.dispose == "function" && u.full.dispose(), s.preview !== void 0 && s.full === void 0 && (s.full = void 0, u.full = void 0), s.preview !== void 0 && !(s.preview instanceof co) && (s.preview = Qi.fromObject(s.preview)), s.full !== void 0 && !(s.full instanceof co) && (s.full = Qi.fromObject(s.full)), { ...u, ...s }));
    },
    node: e,
    serialize: () => {
      const s = n.io_state.getState(), u = n.valuestore.getState();
      return {
        ...s,
        value: u.preview,
        fullvalue: u.full,
        render_options: s.render_options,
        valuepreview_type: s.valuepreview_type,
        emit_value_set: s.emit_value_set
      };
    }
  }, n;
}, vae = (e) => {
  const t = {
    use: (a) => a ? r.node_state(a) : r.node_state(),
    useShallow: (a) => r.node_state(Lx(a)),
    io_stores: /* @__PURE__ */ new Map(),
    getState: () => r.node_state.getState(),
    setState: (a) => {
      r.node_state.setState(a);
    },
    update: (a) => {
      pae(r, a);
    },
    serialize: () => ({
      ...r.node_state.getState(),
      io: Object.fromEntries(
        Array.from(r.io_stores.entries()).map(([u, c]) => [
          u,
          c.serialize()
        ])
      )
    })
  }, n = pD(e), r = {
    ...t,
    node_state: hD((a, s) => hae(n))
  }, o = n.io;
  return Object.entries(o).forEach(([a, s]) => {
    s !== void 0 && r.io_stores.set(a, yae(n.id, s));
  }), r;
}, bae = () => {
  const e = tt();
  return {
    onSelectionChange: _.useCallback(
      ({ nodes: n, edges: r }) => {
        const { group_nodes: o, default_nodes: a } = Wx(n), s = e.local_state.getState();
        e.local_state.setState({
          ...s,
          selected_nodes: a.map((u) => u.id),
          selected_edges: r.map((u) => u.id),
          selected_groups: o.map((u) => u.id)
        });
      },
      [e]
    )
  };
}, xae = () => {
  const e = ts(), t = tt();
  return t.rf_instance = e, /* @__PURE__ */ b.jsx(b.Fragment, {});
}, wae = () => {
  const e = tt(), { getEdges: t } = ts(), { getSelectedNodes: n } = fD();
  return {
    copySelectedNodes: _.useCallback(() => {
      const o = t(), a = n();
      if (a.length === 0) return;
      const s = { nodes: [], edges: [] };
      for (const f of a) {
        const h = e.nodespace.get_node(f.id, !1);
        h && s.nodes.push(h.serialize());
      }
      const u = new Set(a.map((f) => f.id)), c = o.filter(
        (f) => u.has(f.source) && u.has(f.target)
      );
      for (const f of c)
        !f.sourceHandle || !f.targetHandle || s.edges.push({
          src_nid: f.source,
          src_ioid: f.sourceHandle,
          trg_nid: f.target,
          trg_ioid: f.targetHandle
        });
      navigator.clipboard.writeText(JSON.stringify(s));
    }, [n, t, e])
  };
}, _ae = () => {
  const e = Qo("Delete"), t = Qo(["Meta+c", "Control+c", "Strg+c"]), n = Qo(["Control+g", "Meta+g"]), r = Qo(["Control+Alt+g", "Meta+Alt+g"]), o = woe(), { getEdges: a } = ts(), { getNodes: s, getSelectedNodes: u, getSplitNodes: c } = fD(), { copySelectedNodes: f } = wae(), { node: h, group: p, edge: g } = xn();
  return _.useEffect(() => {
    if (e) {
      const y = a().filter((E) => E.selected);
      for (const E of y)
        !E.source || !E.target || !E.sourceHandle || !E.targetHandle || g?.remove_edge({
          src_nid: E.source,
          src_ioid: E.sourceHandle,
          trg_nid: E.target,
          trg_ioid: E.targetHandle
        });
      const w = u(), { group_nodes: v, default_nodes: S } = c(w);
      for (const E of S)
        h?.remove_node(E.id);
      for (const E of v)
        p?.remove_group(E.id);
    }
  }, [e, s, a, h, p, g]), _.useEffect(() => {
    t && f();
  }, [t, f]), _.useEffect(() => {
    if (n) {
      const y = u(), { group_nodes: w, default_nodes: v } = c(y);
      y.length > 0 && o(
        v.map((S) => S.id),
        w.map((S) => S.id)
      );
    }
  }, [n, s]), _.useEffect(() => {
    if (r) {
      const y = u(), { group_nodes: w } = c(y);
      w.forEach((v) => {
        p?.remove_group(v.id);
      });
    }
  }, [r, s]), /* @__PURE__ */ b.jsx(b.Fragment, {});
}, Sae = () => {
  const { node: e, edge: t } = xn(), n = tt();
  return _.useCallback(
    async (o, a) => {
      try {
        if (!o || !e || !t) return;
        const s = JSON.parse(o);
        if (!s || !n.worker || !s.nodes) return;
        const u = [0, 0];
        for (const f of s.nodes)
          u[0] += f.properties["frontend:pos"][0], u[1] += f.properties["frontend:pos"][1];
        u[0] /= s.nodes.length, u[1] /= s.nodes.length;
        const c = [];
        for (const f of s.nodes) {
          const h = {
            id: f.node_id,
            src_id: f.id,
            position: [
              f.properties["frontend:pos"][0] - u[0],
              f.properties["frontend:pos"][1] - u[1]
            ]
          };
          c.push(h);
        }
        for (const f of c) {
          const h = await e.add_node(f.id);
          !h || !n.nodespace.get_node(h.id, !1) || (f.new_id = h.id, a([
            {
              id: h.id,
              type: "position",
              position: {
                x: f.position[0] + h.properties["frontend:pos"][0],
                y: f.position[1] + h.properties["frontend:pos"][1]
              }
            }
          ]));
        }
        for (const f of s.edges) {
          const h = c.find(
            (g) => g.src_id === f.src_nid
          ), p = c.find(
            (g) => g.src_id === f.trg_nid
          );
          !h || !p || !h.new_id || !p.new_id || t.add_edge({
            src_nid: h.new_id,
            src_ioid: f.src_ioid,
            trg_nid: p.new_id,
            trg_ioid: f.trg_ioid
          });
        }
      } catch (s) {
        console.error("Failed to process pasted data:", s);
      }
    },
    [e, t, n]
  );
}, Eae = (e, t) => {
  const n = e.properties || {};
  n["frontend:size"] || (n["frontend:size"] = [200, 100]);
  const r = n["frontend:pos"];
  if (!r || r.length !== 2 || isNaN(r[0]) || r[0] === null || isNaN(r[1]) || r[1] === null)
    if (!t || !t.rf_instance || t.reactflowRef === null)
      n["frontend:pos"] = [0, 0];
    else {
      const a = t.reactflowRef.getBoundingClientRect(), s = a.left + a.width / 2, u = a.top + a.height / 2, c = t.rf_instance.screenToFlowPosition({
        x: s,
        y: u
      });
      n["frontend:pos"] = [
        c.x - n["frontend:size"][0] / 2,
        c.y - n["frontend:size"][0] / 2
      ];
    }
  n["frontend:collapsed"] || (n["frontend:collapsed"] = !1), e.properties = n;
}, Cae = (e, t) => {
  const n = e.getState();
  if (Eae(n, t), n.id === void 0)
    throw new Error("Node must have an id");
  const r = {
    nodestore: e
  };
  return {
    position: {
      x: n.properties["frontend:pos"][0],
      y: n.properties["frontend:pos"][1]
    },
    data: r,
    type: "default",
    zIndex: 1003,
    // expandParent: true,
    ...n
  };
}, aR = {
  default: Cn.Dots,
  metal: Cn.Cross,
  light: Cn.Dots,
  solarized: Cn.Dots,
  midnight: Cn.Dots,
  forest: Cn.Dots,
  scientific: Cn.Lines
}, kae = (e) => {
  const t = tt(), n = _.useRef(null), { colorTheme: r } = xN(), { onSelectionChange: o } = bae(), a = xX();
  _.useEffect(() => {
    t.getStateManager().toaster = a;
  }, []), _.useEffect(() => {
    t.reactflowRef = n.current;
  }, [n]);
  const { nodes: s, edges: u, onNodesChange: c, onEdgesChange: f, onConnect: h } = t.useReactFlowStore(Lx(aae)), p = Sae(), g = _.useCallback(
    (y) => {
      const w = n.current;
      if (!w) return;
      let v = y.target, S = 0;
      for (; v && v.parentElement && v !== w; )
        S++, v = v.parentElement;
      t.logger.debug(`onPasteCapture: ${S} steps to reactflow`), S <= 2 && p(
        y.clipboardData.getData("text/plain"),
        c
      );
    },
    [p, c, t.logger]
  );
  return /* @__PURE__ */ b.jsx("div", { className: "reactflowlayer", children: /* @__PURE__ */ b.jsxs(
    qre,
    {
      onPasteCapture: g,
      nodes: s,
      edges: u,
      onNodesChange: c,
      onEdgesChange: f,
      onConnect: h,
      nodeTypes: oae,
      edgeTypes: iae,
      minZoom: e.minZoom,
      maxZoom: e.maxZoom,
      fitView: !0,
      onSelectionChange: o,
      ref: n,
      panOnDrag: !e.static,
      children: [
        /* @__PURE__ */ b.jsx(xae, {}),
        /* @__PURE__ */ b.jsx(_ae, {}),
        /* @__PURE__ */ b.jsx(
          Kre,
          {
            color: "#888",
            gap: 24,
            size: 2,
            variant: aR[r] || aR.default,
            patternClassName: "fn-background-pattern"
          }
        ),
        e.minimap && /* @__PURE__ */ b.jsx(
          moe,
          {
            nodeStrokeWidth: 3,
            pannable: !e.static,
            zoomable: !e.static,
            zoomStep: 3
          }
        )
      ]
    }
  ) });
}, Tae = ({
  on_node_change: e,
  on_edge_change: t,
  on_connect: n
}) => {
  const r = e || ((u) => {
  }), o = t || ((u) => {
  }), a = n || ((u) => {
  });
  return Er((u, c) => ({
    _nodes: [],
    _edges: [],
    _nodes_map: /* @__PURE__ */ new Map(),
    update_nodes: (f) => {
      f = Np(f), u({
        _nodes: f,
        _nodes_map: new Map(f.map((h) => [h.id, h]))
      });
    },
    partial_update_nodes: (f) => {
      const h = c(), p = h._nodes, g = new Map(
        p.map((y) => [y.id, y])
      );
      for (const y of f)
        g.set(y.id, y);
      h.update_nodes(Array.from(g.values()));
    },
    update_edges: (f) => {
      u({
        _edges: f
      });
    },
    onNodesChange: (f) => {
      const h = c();
      h.update_nodes(Ix(f, h._nodes)), r(f);
    },
    onEdgesChange: (f) => {
      u({
        _edges: q5(f, c()._edges)
      }), o(f);
    },
    onConnect: (f) => {
      f.source == null || f.target == null || a(f);
    },
    getNode: (f) => c()._nodes_map.get(f),
    getNodes: () => c()._nodes,
    getEdges: () => c()._edges
  }));
}, Aae = () => {
  const t = tt().progress_state();
  return /* @__PURE__ */ b.jsxs("div", { className: "statusbar", children: [
    /* @__PURE__ */ b.jsx(
      "span",
      {
        className: "statusbar-progressbar",
        style: { width: Math.min(100, 100 * t.progress) + "%" }
      }
    ),
    /* @__PURE__ */ b.jsx("span", { className: "statusbar-message", children: t.message })
  ] });
}, Dp = !1;
var Kb = ["Enter", " "], Rae = ["ArrowDown", "PageUp", "Home"], mD = ["ArrowUp", "PageDown", "End"], Mae = [...Rae, ...mD], Oae = {
  ltr: [...Kb, "ArrowRight"],
  rtl: [...Kb, "ArrowLeft"]
}, Nae = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, Ef = "Menu", [Kc, Dae, jae] = _m(Ef), [rs, gD] = _o(Ef, [
  jae,
  bm,
  Wm
]), Cf = bm(), yD = Wm(), [vD, os] = rs(Ef), [Pae, kf] = rs(Ef), bD = (e) => {
  const { __scopeMenu: t, open: n = !1, children: r, dir: o, onOpenChange: a, modal: s = !0 } = e, u = Cf(t), [c, f] = _.useState(null), h = _.useRef(!1), p = Hn(a), g = Um(o);
  return _.useEffect(() => {
    const y = () => {
      h.current = !0, document.addEventListener("pointerdown", w, { capture: !0, once: !0 }), document.addEventListener("pointermove", w, { capture: !0, once: !0 });
    }, w = () => h.current = !1;
    return document.addEventListener("keydown", y, { capture: !0 }), () => {
      document.removeEventListener("keydown", y, { capture: !0 }), document.removeEventListener("pointerdown", w, { capture: !0 }), document.removeEventListener("pointermove", w, { capture: !0 });
    };
  }, []), /* @__PURE__ */ b.jsx(ox, { ...u, children: /* @__PURE__ */ b.jsx(
    vD,
    {
      scope: t,
      open: n,
      onOpenChange: p,
      content: c,
      onContentChange: f,
      children: /* @__PURE__ */ b.jsx(
        Pae,
        {
          scope: t,
          onClose: _.useCallback(() => p(!1), [p]),
          isUsingKeyboardRef: h,
          dir: g,
          modal: s,
          children: r
        }
      )
    }
  ) });
};
bD.displayName = Ef;
var Iae = "MenuAnchor", Xx = _.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, o = Cf(n);
    return /* @__PURE__ */ b.jsx(ix, { ...o, ...r, ref: t });
  }
);
Xx.displayName = Iae;
var zae = "MenuPortal", [yme, xD] = rs(zae, {
  forceMount: void 0
}), Cr = "MenuContent", [Lae, Kx] = rs(Cr), wD = _.forwardRef(
  (e, t) => {
    const n = xD(Cr, e.__scopeMenu), { forceMount: r = n.forceMount, ...o } = e, a = os(Cr, e.__scopeMenu), s = kf(Cr, e.__scopeMenu);
    return /* @__PURE__ */ b.jsx(Kc.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ b.jsx(Br, { present: r || a.open, children: /* @__PURE__ */ b.jsx(Kc.Slot, { scope: e.__scopeMenu, children: s.modal ? /* @__PURE__ */ b.jsx(Fae, { ...o, ref: t }) : /* @__PURE__ */ b.jsx($ae, { ...o, ref: t }) }) }) });
  }
), Fae = _.forwardRef(
  (e, t) => {
    const n = os(Cr, e.__scopeMenu), r = _.useRef(null), o = bt(t, r);
    return _.useEffect(() => {
      const a = r.current;
      if (a) return O1(a);
    }, []), /* @__PURE__ */ b.jsx(
      Zx,
      {
        ...e,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: xe(
          e.onFocusOutside,
          (a) => a.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }
), $ae = _.forwardRef((e, t) => {
  const n = os(Cr, e.__scopeMenu);
  return /* @__PURE__ */ b.jsx(
    Zx,
    {
      ...e,
      ref: t,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1)
    }
  );
}), Bae = /* @__PURE__ */ xl("MenuContent.ScrollLock"), Zx = _.forwardRef(
  (e, t) => {
    const {
      __scopeMenu: n,
      loop: r = !1,
      trapFocus: o,
      onOpenAutoFocus: a,
      onCloseAutoFocus: s,
      disableOutsidePointerEvents: u,
      onEntryFocus: c,
      onEscapeKeyDown: f,
      onPointerDownOutside: h,
      onFocusOutside: p,
      onInteractOutside: g,
      onDismiss: y,
      disableOutsideScroll: w,
      ...v
    } = e, S = os(Cr, n), E = kf(Cr, n), A = Cf(n), k = yD(n), T = Dae(n), [R, N] = _.useState(null), j = _.useRef(null), z = bt(t, j, S.onContentChange), B = _.useRef(0), M = _.useRef(""), F = _.useRef(0), q = _.useRef(null), Y = _.useRef("right"), P = _.useRef(0), V = w ? um : _.Fragment, I = w ? { as: Bae, allowPinchZoom: !0 } : void 0, U = (G) => {
      const O = M.current + G, W = T().filter((fe) => !fe.disabled), Z = document.activeElement, L = W.find((fe) => fe.ref.current === Z)?.textValue, te = W.map((fe) => fe.textValue), he = Jae(te, O, L), oe = W.find((fe) => fe.textValue === he)?.ref.current;
      (function fe(ae) {
        M.current = ae, window.clearTimeout(B.current), ae !== "" && (B.current = window.setTimeout(() => fe(""), 1e3));
      })(O), oe && setTimeout(() => oe.focus());
    };
    _.useEffect(() => () => window.clearTimeout(B.current), []), M1();
    const H = _.useCallback((G) => Y.current === q.current?.side && tse(G, q.current?.area), []);
    return /* @__PURE__ */ b.jsx(
      Lae,
      {
        scope: n,
        searchRef: M,
        onItemEnter: _.useCallback(
          (G) => {
            H(G) && G.preventDefault();
          },
          [H]
        ),
        onItemLeave: _.useCallback(
          (G) => {
            H(G) || (j.current?.focus(), N(null));
          },
          [H]
        ),
        onTriggerLeave: _.useCallback(
          (G) => {
            H(G) && G.preventDefault();
          },
          [H]
        ),
        pointerGraceTimerRef: F,
        onPointerGraceIntentChange: _.useCallback((G) => {
          q.current = G;
        }, []),
        children: /* @__PURE__ */ b.jsx(V, { ...I, children: /* @__PURE__ */ b.jsx(
          am,
          {
            asChild: !0,
            trapped: o,
            onMountAutoFocus: xe(a, (G) => {
              G.preventDefault(), j.current?.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: s,
            children: /* @__PURE__ */ b.jsx(
              of,
              {
                asChild: !0,
                disableOutsidePointerEvents: u,
                onEscapeKeyDown: f,
                onPointerDownOutside: h,
                onFocusOutside: p,
                onInteractOutside: g,
                onDismiss: y,
                children: /* @__PURE__ */ b.jsx(
                  J4,
                  {
                    asChild: !0,
                    ...k,
                    dir: E.dir,
                    orientation: "vertical",
                    loop: r,
                    currentTabStopId: R,
                    onCurrentTabStopIdChange: N,
                    onEntryFocus: xe(c, (G) => {
                      E.isUsingKeyboardRef.current || G.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ b.jsx(
                      qN,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": LD(S.open),
                        "data-radix-menu-content": "",
                        dir: E.dir,
                        ...A,
                        ...v,
                        ref: z,
                        style: { outline: "none", ...v.style },
                        onKeyDown: xe(v.onKeyDown, (G) => {
                          const W = G.target.closest("[data-radix-menu-content]") === G.currentTarget, Z = G.ctrlKey || G.altKey || G.metaKey, L = G.key.length === 1;
                          W && (G.key === "Tab" && G.preventDefault(), !Z && L && U(G.key));
                          const te = j.current;
                          if (G.target !== te || !Mae.includes(G.key)) return;
                          G.preventDefault();
                          const oe = T().filter((fe) => !fe.disabled).map((fe) => fe.ref.current);
                          mD.includes(G.key) && oe.reverse(), Zae(oe);
                        }),
                        onBlur: xe(e.onBlur, (G) => {
                          G.currentTarget.contains(G.target) || (window.clearTimeout(B.current), M.current = "");
                        }),
                        onPointerMove: xe(
                          e.onPointerMove,
                          Zc((G) => {
                            const O = G.target, W = P.current !== G.clientX;
                            if (G.currentTarget.contains(O) && W) {
                              const Z = G.clientX > P.current ? "right" : "left";
                              Y.current = Z, P.current = G.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
wD.displayName = Cr;
var Hae = "MenuGroup", Qx = _.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ b.jsx(qe.div, { role: "group", ...r, ref: t });
  }
);
Qx.displayName = Hae;
var Vae = "MenuLabel", _D = _.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ b.jsx(qe.div, { ...r, ref: t });
  }
);
_D.displayName = Vae;
var jp = "MenuItem", sR = "menu.itemSelect", Km = _.forwardRef(
  (e, t) => {
    const { disabled: n = !1, onSelect: r, ...o } = e, a = _.useRef(null), s = kf(jp, e.__scopeMenu), u = Kx(jp, e.__scopeMenu), c = bt(t, a), f = _.useRef(!1), h = () => {
      const p = a.current;
      if (!n && p) {
        const g = new CustomEvent(sR, { bubbles: !0, cancelable: !0 });
        p.addEventListener(sR, (y) => r?.(y), { once: !0 }), R1(p, g), g.defaultPrevented ? f.current = !1 : s.onClose();
      }
    };
    return /* @__PURE__ */ b.jsx(
      SD,
      {
        ...o,
        ref: c,
        disabled: n,
        onClick: xe(e.onClick, h),
        onPointerDown: (p) => {
          e.onPointerDown?.(p), f.current = !0;
        },
        onPointerUp: xe(e.onPointerUp, (p) => {
          f.current || p.currentTarget?.click();
        }),
        onKeyDown: xe(e.onKeyDown, (p) => {
          const g = u.searchRef.current !== "";
          n || g && p.key === " " || Kb.includes(p.key) && (p.currentTarget.click(), p.preventDefault());
        })
      }
    );
  }
);
Km.displayName = jp;
var SD = _.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, disabled: r = !1, textValue: o, ...a } = e, s = Kx(jp, n), u = yD(n), c = _.useRef(null), f = bt(t, c), [h, p] = _.useState(!1), [g, y] = _.useState("");
    return _.useEffect(() => {
      const w = c.current;
      w && y((w.textContent ?? "").trim());
    }, [a.children]), /* @__PURE__ */ b.jsx(
      Kc.ItemSlot,
      {
        scope: n,
        disabled: r,
        textValue: o ?? g,
        children: /* @__PURE__ */ b.jsx(eD, { asChild: !0, ...u, focusable: !r, children: /* @__PURE__ */ b.jsx(
          qe.div,
          {
            role: "menuitem",
            "data-highlighted": h ? "" : void 0,
            "aria-disabled": r || void 0,
            "data-disabled": r ? "" : void 0,
            ...a,
            ref: f,
            onPointerMove: xe(
              e.onPointerMove,
              Zc((w) => {
                r ? s.onItemLeave(w) : (s.onItemEnter(w), w.defaultPrevented || w.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: xe(
              e.onPointerLeave,
              Zc((w) => s.onItemLeave(w))
            ),
            onFocus: xe(e.onFocus, () => p(!0)),
            onBlur: xe(e.onBlur, () => p(!1))
          }
        ) })
      }
    );
  }
), Uae = "MenuCheckboxItem", ED = _.forwardRef(
  (e, t) => {
    const { checked: n = !1, onCheckedChange: r, ...o } = e;
    return /* @__PURE__ */ b.jsx(RD, { scope: e.__scopeMenu, checked: n, children: /* @__PURE__ */ b.jsx(
      Km,
      {
        role: "menuitemcheckbox",
        "aria-checked": Pp(n) ? "mixed" : n,
        ...o,
        ref: t,
        "data-state": tw(n),
        onSelect: xe(
          o.onSelect,
          () => r?.(Pp(n) ? !0 : !n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
ED.displayName = Uae;
var CD = "MenuRadioGroup", [qae, Gae] = rs(
  CD,
  { value: void 0, onValueChange: () => {
  } }
), kD = _.forwardRef(
  (e, t) => {
    const { value: n, onValueChange: r, ...o } = e, a = Hn(r);
    return /* @__PURE__ */ b.jsx(qae, { scope: e.__scopeMenu, value: n, onValueChange: a, children: /* @__PURE__ */ b.jsx(Qx, { ...o, ref: t }) });
  }
);
kD.displayName = CD;
var TD = "MenuRadioItem", AD = _.forwardRef(
  (e, t) => {
    const { value: n, ...r } = e, o = Gae(TD, e.__scopeMenu), a = n === o.value;
    return /* @__PURE__ */ b.jsx(RD, { scope: e.__scopeMenu, checked: a, children: /* @__PURE__ */ b.jsx(
      Km,
      {
        role: "menuitemradio",
        "aria-checked": a,
        ...r,
        ref: t,
        "data-state": tw(a),
        onSelect: xe(
          r.onSelect,
          () => o.onValueChange?.(n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
AD.displayName = TD;
var Jx = "MenuItemIndicator", [RD, Yae] = rs(
  Jx,
  { checked: !1 }
), MD = _.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, forceMount: r, ...o } = e, a = Yae(Jx, n);
    return /* @__PURE__ */ b.jsx(
      Br,
      {
        present: r || Pp(a.checked) || a.checked === !0,
        children: /* @__PURE__ */ b.jsx(
          qe.span,
          {
            ...o,
            ref: t,
            "data-state": tw(a.checked)
          }
        )
      }
    );
  }
);
MD.displayName = Jx;
var Wae = "MenuSeparator", OD = _.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e;
    return /* @__PURE__ */ b.jsx(
      qe.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: t
      }
    );
  }
);
OD.displayName = Wae;
var Xae = "MenuArrow", ND = _.forwardRef(
  (e, t) => {
    const { __scopeMenu: n, ...r } = e, o = Cf(n);
    return /* @__PURE__ */ b.jsx(GN, { ...o, ...r, ref: t });
  }
);
ND.displayName = Xae;
var ew = "MenuSub", [Kae, DD] = rs(ew), jD = (e) => {
  const { __scopeMenu: t, children: n, open: r = !1, onOpenChange: o } = e, a = os(ew, t), s = Cf(t), [u, c] = _.useState(null), [f, h] = _.useState(null), p = Hn(o);
  return _.useEffect(() => (a.open === !1 && p(!1), () => p(!1)), [a.open, p]), /* @__PURE__ */ b.jsx(ox, { ...s, children: /* @__PURE__ */ b.jsx(
    vD,
    {
      scope: t,
      open: r,
      onOpenChange: p,
      content: f,
      onContentChange: h,
      children: /* @__PURE__ */ b.jsx(
        Kae,
        {
          scope: t,
          contentId: po(),
          triggerId: po(),
          trigger: u,
          onTriggerChange: c,
          children: n
        }
      )
    }
  ) });
};
jD.displayName = ew;
var yc = "MenuSubTrigger", PD = _.forwardRef(
  (e, t) => {
    const n = os(yc, e.__scopeMenu), r = kf(yc, e.__scopeMenu), o = DD(yc, e.__scopeMenu), a = Kx(yc, e.__scopeMenu), s = _.useRef(null), { pointerGraceTimerRef: u, onPointerGraceIntentChange: c } = a, f = { __scopeMenu: e.__scopeMenu }, h = _.useCallback(() => {
      s.current && window.clearTimeout(s.current), s.current = null;
    }, []);
    return _.useEffect(() => h, [h]), _.useEffect(() => {
      const p = u.current;
      return () => {
        window.clearTimeout(p), c(null);
      };
    }, [u, c]), /* @__PURE__ */ b.jsx(Xx, { asChild: !0, ...f, children: /* @__PURE__ */ b.jsx(
      SD,
      {
        id: o.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": n.open,
        "aria-controls": o.contentId,
        "data-state": LD(n.open),
        ...e,
        ref: im(t, o.onTriggerChange),
        onClick: (p) => {
          e.onClick?.(p), !(e.disabled || p.defaultPrevented) && (p.currentTarget.focus(), n.open || n.onOpenChange(!0));
        },
        onPointerMove: xe(
          e.onPointerMove,
          Zc((p) => {
            a.onItemEnter(p), !p.defaultPrevented && !e.disabled && !n.open && !s.current && (a.onPointerGraceIntentChange(null), s.current = window.setTimeout(() => {
              n.onOpenChange(!0), h();
            }, 100));
          })
        ),
        onPointerLeave: xe(
          e.onPointerLeave,
          Zc((p) => {
            h();
            const g = n.content?.getBoundingClientRect();
            if (g) {
              const y = n.content?.dataset.side, w = y === "right", v = w ? -5 : 5, S = g[w ? "left" : "right"], E = g[w ? "right" : "left"];
              a.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: p.clientX + v, y: p.clientY },
                  { x: S, y: g.top },
                  { x: E, y: g.top },
                  { x: E, y: g.bottom },
                  { x: S, y: g.bottom }
                ],
                side: y
              }), window.clearTimeout(u.current), u.current = window.setTimeout(
                () => a.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (a.onTriggerLeave(p), p.defaultPrevented) return;
              a.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: xe(e.onKeyDown, (p) => {
          const g = a.searchRef.current !== "";
          e.disabled || g && p.key === " " || Oae[r.dir].includes(p.key) && (n.onOpenChange(!0), n.content?.focus(), p.preventDefault());
        })
      }
    ) });
  }
);
PD.displayName = yc;
var ID = "MenuSubContent", zD = _.forwardRef(
  (e, t) => {
    const n = xD(Cr, e.__scopeMenu), { forceMount: r = n.forceMount, ...o } = e, a = os(Cr, e.__scopeMenu), s = kf(Cr, e.__scopeMenu), u = DD(ID, e.__scopeMenu), c = _.useRef(null), f = bt(t, c);
    return /* @__PURE__ */ b.jsx(Kc.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ b.jsx(Br, { present: r || a.open, children: /* @__PURE__ */ b.jsx(Kc.Slot, { scope: e.__scopeMenu, children: /* @__PURE__ */ b.jsx(
      Zx,
      {
        id: u.contentId,
        "aria-labelledby": u.triggerId,
        ...o,
        ref: f,
        align: "start",
        side: s.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (h) => {
          s.isUsingKeyboardRef.current && c.current?.focus(), h.preventDefault();
        },
        onCloseAutoFocus: (h) => h.preventDefault(),
        onFocusOutside: xe(e.onFocusOutside, (h) => {
          h.target !== u.trigger && a.onOpenChange(!1);
        }),
        onEscapeKeyDown: xe(e.onEscapeKeyDown, (h) => {
          s.onClose(), h.preventDefault();
        }),
        onKeyDown: xe(e.onKeyDown, (h) => {
          const p = h.currentTarget.contains(h.target), g = Nae[s.dir].includes(h.key);
          p && g && (a.onOpenChange(!1), u.trigger?.focus(), h.preventDefault());
        })
      }
    ) }) }) });
  }
);
zD.displayName = ID;
function LD(e) {
  return e ? "open" : "closed";
}
function Pp(e) {
  return e === "indeterminate";
}
function tw(e) {
  return Pp(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
function Zae(e) {
  const t = document.activeElement;
  for (const n of e)
    if (n === t || (n.focus(), document.activeElement !== t)) return;
}
function Qae(e, t) {
  return e.map((n, r) => e[(t + r) % e.length]);
}
function Jae(e, t, n) {
  const o = t.length > 1 && Array.from(t).every((f) => f === t[0]) ? t[0] : t, a = n ? e.indexOf(n) : -1;
  let s = Qae(e, Math.max(a, 0));
  o.length === 1 && (s = s.filter((f) => f !== n));
  const c = s.find(
    (f) => f.toLowerCase().startsWith(o.toLowerCase())
  );
  return c !== n ? c : void 0;
}
function ese(e, t) {
  const { x: n, y: r } = e;
  let o = !1;
  for (let a = 0, s = t.length - 1; a < t.length; s = a++) {
    const u = t[a], c = t[s], f = u.x, h = u.y, p = c.x, g = c.y;
    h > r != g > r && n < (p - f) * (r - h) / (g - h) + f && (o = !o);
  }
  return o;
}
function tse(e, t) {
  if (!t) return !1;
  const n = { x: e.clientX, y: e.clientY };
  return ese(n, t);
}
function Zc(e) {
  return (t) => t.pointerType === "mouse" ? e(t) : void 0;
}
var nse = bD, rse = Xx, ose = wD, ise = Qx, ase = _D, sse = Km, lse = ED, use = kD, cse = AD, fse = MD, dse = OD, hse = ND, pse = jD, mse = PD, gse = zD, Zm = "DropdownMenu", [yse, vme] = _o(
  Zm,
  [gD]
), An = gD(), [vse, FD] = yse(Zm), $D = (e) => {
  const {
    __scopeDropdownMenu: t,
    children: n,
    dir: r,
    open: o,
    defaultOpen: a,
    onOpenChange: s,
    modal: u = !0
  } = e, c = An(t), f = _.useRef(null), [h, p] = sa({
    prop: o,
    defaultProp: a ?? !1,
    onChange: s,
    caller: Zm
  });
  return /* @__PURE__ */ b.jsx(
    vse,
    {
      scope: t,
      triggerId: po(),
      triggerRef: f,
      contentId: po(),
      open: h,
      onOpenChange: p,
      onOpenToggle: _.useCallback(() => p((g) => !g), [p]),
      modal: u,
      children: /* @__PURE__ */ b.jsx(nse, { ...c, open: h, onOpenChange: p, dir: r, modal: u, children: n })
    }
  );
};
$D.displayName = Zm;
var BD = "DropdownMenuTrigger", HD = _.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, disabled: r = !1, ...o } = e, a = FD(BD, n), s = An(n);
    return /* @__PURE__ */ b.jsx(rse, { asChild: !0, ...s, children: /* @__PURE__ */ b.jsx(
      qe.button,
      {
        type: "button",
        id: a.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": a.open,
        "aria-controls": a.open ? a.contentId : void 0,
        "data-state": a.open ? "open" : "closed",
        "data-disabled": r ? "" : void 0,
        disabled: r,
        ...o,
        ref: im(t, a.triggerRef),
        onPointerDown: xe(e.onPointerDown, (u) => {
          !r && u.button === 0 && u.ctrlKey === !1 && (a.onOpenToggle(), a.open || u.preventDefault());
        }),
        onKeyDown: xe(e.onKeyDown, (u) => {
          r || (["Enter", " "].includes(u.key) && a.onOpenToggle(), u.key === "ArrowDown" && a.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(u.key) && u.preventDefault());
        })
      }
    ) });
  }
);
HD.displayName = BD;
var VD = "DropdownMenuContent", UD = _.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = FD(VD, n), a = An(n), s = _.useRef(!1);
    return /* @__PURE__ */ b.jsx(
      ose,
      {
        id: o.contentId,
        "aria-labelledby": o.triggerId,
        ...a,
        ...r,
        ref: t,
        onCloseAutoFocus: xe(e.onCloseAutoFocus, (u) => {
          s.current || o.triggerRef.current?.focus(), s.current = !1, u.preventDefault();
        }),
        onInteractOutside: xe(e.onInteractOutside, (u) => {
          const c = u.detail.originalEvent, f = c.button === 0 && c.ctrlKey === !0, h = c.button === 2 || f;
          (!o.modal || h) && (s.current = !0);
        }),
        style: {
          ...e.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
UD.displayName = VD;
var bse = "DropdownMenuGroup", qD = _.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = An(n);
    return /* @__PURE__ */ b.jsx(ise, { ...o, ...r, ref: t });
  }
);
qD.displayName = bse;
var xse = "DropdownMenuLabel", wse = _.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = An(n);
    return /* @__PURE__ */ b.jsx(ase, { ...o, ...r, ref: t });
  }
);
wse.displayName = xse;
var _se = "DropdownMenuItem", GD = _.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = An(n);
    return /* @__PURE__ */ b.jsx(sse, { ...o, ...r, ref: t });
  }
);
GD.displayName = _se;
var Sse = "DropdownMenuCheckboxItem", Ese = _.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = An(n);
  return /* @__PURE__ */ b.jsx(lse, { ...o, ...r, ref: t });
});
Ese.displayName = Sse;
var Cse = "DropdownMenuRadioGroup", YD = _.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = An(n);
  return /* @__PURE__ */ b.jsx(use, { ...o, ...r, ref: t });
});
YD.displayName = Cse;
var kse = "DropdownMenuRadioItem", WD = _.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = An(n);
  return /* @__PURE__ */ b.jsx(cse, { ...o, ...r, ref: t });
});
WD.displayName = kse;
var Tse = "DropdownMenuItemIndicator", Ase = _.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = An(n);
  return /* @__PURE__ */ b.jsx(fse, { ...o, ...r, ref: t });
});
Ase.displayName = Tse;
var Rse = "DropdownMenuSeparator", Mse = _.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = An(n);
  return /* @__PURE__ */ b.jsx(dse, { ...o, ...r, ref: t });
});
Mse.displayName = Rse;
var Ose = "DropdownMenuArrow", Nse = _.forwardRef(
  (e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = An(n);
    return /* @__PURE__ */ b.jsx(hse, { ...o, ...r, ref: t });
  }
);
Nse.displayName = Ose;
var Dse = (e) => {
  const { __scopeDropdownMenu: t, children: n, open: r, onOpenChange: o, defaultOpen: a } = e, s = An(t), [u, c] = sa({
    prop: r,
    defaultProp: a ?? !1,
    onChange: o,
    caller: "DropdownMenuSub"
  });
  return /* @__PURE__ */ b.jsx(pse, { ...s, open: u, onOpenChange: c, children: n });
}, jse = "DropdownMenuSubTrigger", XD = _.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = An(n);
  return /* @__PURE__ */ b.jsx(mse, { ...o, ...r, ref: t });
});
XD.displayName = jse;
var Pse = "DropdownMenuSubContent", KD = _.forwardRef((e, t) => {
  const { __scopeDropdownMenu: n, ...r } = e, o = An(n);
  return /* @__PURE__ */ b.jsx(
    gse,
    {
      ...o,
      ...r,
      ref: t,
      style: {
        ...e.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
KD.displayName = Pse;
var nw = $D, rw = HD, ow = UD, iw = qD, Ko = GD, Ise = YD, zse = WD, Lse = Dse, Fse = XD, $se = KD;
const Bse = ({
  trigger: e,
  setOpen: t,
  open: n
}) => {
  const [r, o] = _.useState(""), [a, s] = _.useState(!0), u = tt();
  return u.options.useWorkerManager ? /* @__PURE__ */ b.jsxs(
    ci,
    {
      setOpen: t,
      open: n,
      trigger: e,
      title: "New Worker",
      description: "Create a new worker",
      children: [
        /* @__PURE__ */ b.jsxs("div", { children: [
          "Name:",
          /* @__PURE__ */ b.jsx("br", {}),
          /* @__PURE__ */ b.jsx(
            "input",
            {
              className: "styledinput",
              onChange: (c) => {
                o(c.currentTarget.value);
              },
              value: r
            }
          ),
          /* @__PURE__ */ b.jsxs("div", { style: { marginTop: 8 }, children: [
            /* @__PURE__ */ b.jsx(
              "input",
              {
                type: "checkbox",
                id: "inVenvCheckbox",
                checked: a,
                onChange: (c) => s(c.currentTarget.checked)
              }
            ),
            /* @__PURE__ */ b.jsx("label", { htmlFor: "inVenvCheckbox", style: { marginLeft: 4 }, children: "Create in new virtual environment" })
          ] })
        ] }),
        /* @__PURE__ */ b.jsx("div", { children: r && /* @__PURE__ */ b.jsx("div", { children: /* @__PURE__ */ b.jsx(
          "button",
          {
            className: "styledbtn",
            onClick: () => {
              u.workermanager?.new_worker({
                name: r,
                in_venv: a
                // reference: reference.uuid,
                // copyLib,
                // copyNS,
              }), t(!1);
            },
            children: "Create"
          }
        ) }) })
      ]
    }
  ) : null;
}, Hse = ({
  trigger: e,
  setOpen: t,
  open: n
}) => {
  const r = tt(), [o, a] = _.useState(!1), s = r.workers(), u = r.worker?.uuid, c = (u ? s[u]?.name : void 0) || u || "worker", f = async () => {
    if (!r.worker) return;
    const h = await r.worker.export({ withFiles: o });
    R6(h, c + ".fnw", "application/zip"), t(!1);
  };
  return /* @__PURE__ */ b.jsx(
    ci,
    {
      setOpen: t,
      open: n,
      trigger: e,
      title: "Export Worker",
      description: "Export the worker as a .fnw file",
      children: /* @__PURE__ */ b.jsxs("div", { children: [
        /* @__PURE__ */ b.jsxs("div", { children: [
          /* @__PURE__ */ b.jsx(
            "input",
            {
              type: "checkbox",
              className: "styledcheckbox",
              checked: o,
              onChange: (h) => {
                a(h.currentTarget.checked);
              }
            }
          ),
          "Include Files"
        ] }),
        /* @__PURE__ */ b.jsx("button", { className: "styledbtn", onClick: f, children: "Export" })
      ] })
    }
  );
}, Vse = () => {
  const e = tt(), t = e.workers(), [n, r] = _.useState(!1), [o, a] = _.useState(!1), s = (y) => {
    y !== "__select__" && e.workers && e.workermanager && t[y] && (!t[y].active && !window.confirm(
      "this is an inactive worker, selecting it will start it, continue?"
    ) || e.workermanager.set_active(y));
  }, u = async () => {
    if (!e.worker || !window.confirm(
      "Updateing the worker might replace the current nodespace, continue?"
    )) return;
    const w = await N6(".fnw");
    e.worker.update_from_export(w);
  }, c = e.options.useWorkerManager && e.workermanager && e.workermanager.open || Dp, f = c && Object.keys(t).length > 0, h = e.worker && e.worker.is_open, p = h && c;
  return c || h ? /* @__PURE__ */ b.jsxs(b.Fragment, { children: [
    /* @__PURE__ */ b.jsxs(nw, { children: [
      /* @__PURE__ */ b.jsx(rw, { asChild: !0, children: /* @__PURE__ */ b.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ b.jsxs(Ji, { direction: "row", children: [
        "Worker ",
        /* @__PURE__ */ b.jsx(Y1, { className: "m-x-s" })
      ] }) }) }),
      /* @__PURE__ */ b.jsx(ow, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ b.jsxs(iw, { children: [
        f && /* @__PURE__ */ b.jsxs(Lse, { children: [
          /* @__PURE__ */ b.jsx(Fse, { className: "headermenuitem submenuitem", children: /* @__PURE__ */ b.jsxs(Ji, { direction: "row", children: [
            "Select",
            /* @__PURE__ */ b.jsx(jc, {})
          ] }) }),
          /* @__PURE__ */ b.jsx(
            $se,
            {
              className: "headermenucontent funcnodescontainer",
              sideOffset: 2,
              alignOffset: -5,
              children: /* @__PURE__ */ b.jsx(
                Ise,
                {
                  value: e.worker?.uuid,
                  onValueChange: (y) => {
                    s(y);
                  },
                  children: Object.keys(t).sort((y, w) => {
                    if (t[y].active && !t[w].active)
                      return -1;
                    if (!t[y].active && t[w].active)
                      return 1;
                    const v = t[y].name || y, S = t[w].name || w;
                    return v.localeCompare(S);
                  }).map((y) => /* @__PURE__ */ b.jsx(
                    zse,
                    {
                      className: "headermenuitem workerselectoption" + (t[y]?.active ? " active" : " inactive") + " headermenuitem",
                      value: y,
                      disabled: y === e.worker?.uuid,
                      children: t[y]?.name || y
                    },
                    y
                  ))
                }
              )
            }
          )
        ] }),
        h && /* @__PURE__ */ b.jsxs(b.Fragment, { children: [
          p && /* @__PURE__ */ b.jsx(
            Ko,
            {
              className: "headermenuitem",
              onClick: () => {
                if (e.worker) {
                  if (!e.workermanager)
                    return e.logger.error("no workermanager");
                  e.workermanager?.restart_worker(
                    e.worker.uuid
                  );
                }
              },
              children: "Restart"
            }
          ),
          /* @__PURE__ */ b.jsx(
            Ko,
            {
              className: "headermenuitem",
              onClick: () => {
                e.worker && e.worker.stop();
              },
              children: "Stop"
            }
          ),
          /* @__PURE__ */ b.jsx(
            Ko,
            {
              className: "headermenuitem",
              onClick: () => a(!0),
              children: "Export"
            }
          ),
          /* @__PURE__ */ b.jsx(
            Ko,
            {
              className: "headermenuitem",
              onClick: u,
              children: "Update"
            }
          )
        ] }),
        c && /* @__PURE__ */ b.jsx(b.Fragment, { children: /* @__PURE__ */ b.jsx(
          Ko,
          {
            className: "headermenuitem",
            onClick: () => r(!0),
            children: "New"
          }
        ) })
      ] }) })
    ] }),
    /* @__PURE__ */ b.jsx(
      Bse,
      {
        open: n,
        setOpen: r
      }
    ),
    /* @__PURE__ */ b.jsx(
      Hse,
      {
        open: o,
        setOpen: a
      }
    )
  ] }) : null;
}, Use = () => {
  const e = tt(), t = () => {
    window.confirm("Are you sure you want to start a new flow?") && e.worker?.clear();
  }, n = async () => {
    const o = await e.worker?.save();
    if (!o) return;
    const a = new Blob([JSON.stringify(o)], {
      type: "application/json"
    }), s = URL.createObjectURL(a), u = document.createElement("a");
    u.href = s, u.download = "flow.json", u.click(), URL.revokeObjectURL(s), u.remove();
  }, r = async () => {
    const o = document.createElement("input");
    o.type = "file", o.accept = ".json", o.onchange = async (a) => {
      const s = a.target.files?.[0];
      if (!s) return;
      const u = new FileReader();
      u.onload = async (c) => {
        const f = c.target?.result;
        if (!f) return;
        const h = JSON.parse(f);
        await e.worker?.load(h);
      }, u.readAsText(s);
    }, o.click();
  };
  return /* @__PURE__ */ b.jsx(b.Fragment, { children: /* @__PURE__ */ b.jsxs(nw, { children: [
    /* @__PURE__ */ b.jsx(rw, { asChild: !0, children: /* @__PURE__ */ b.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ b.jsxs(Ji, { direction: "row", children: [
      "Nodespace ",
      /* @__PURE__ */ b.jsx(Y1, { className: "m-x-s" })
    ] }) }) }),
    /* @__PURE__ */ b.jsx(ow, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ b.jsxs(iw, { children: [
      /* @__PURE__ */ b.jsx(Ko, { className: "headermenuitem", onClick: t, children: "New" }),
      /* @__PURE__ */ b.jsx(Ko, { className: "headermenuitem", onClick: n, children: "Save" }),
      /* @__PURE__ */ b.jsx(Ko, { className: "headermenuitem", onClick: r, children: "Load" })
    ] }) })
  ] }) });
}, qse = ({ theme: e, selected: t }) => /* @__PURE__ */ b.jsxs(
  "div",
  {
    style: {
      width: 80,
      height: 54,
      borderRadius: "var(--fn-border-radius-s, 8px)",
      border: t ? "2.5px solid #1976d2" : "1.5px solid #bbb",
      boxShadow: t ? "0 0 0 2px #1976d2" : "0 1px 4px #0002",
      background: "var(--fn-app-background)",
      display: "flex",
      flexDirection: "column",
      alignItems: "stretch",
      justifyContent: "flex-start",
      position: "relative",
      overflow: "hidden",
      transition: "border 0.2s, box-shadow 0.2s"
    },
    "fn-data-color-theme": e,
    children: [
      /* @__PURE__ */ b.jsx(
        "div",
        {
          style: {
            height: 10,
            background: "var(--fn-primary-color)",
            borderBottom: "1px solid var(--fn-neutral-element-border)"
          }
        }
      ),
      /* @__PURE__ */ b.jsxs("div", { style: { display: "flex", flex: 1 }, children: [
        /* @__PURE__ */ b.jsx(
          "div",
          {
            style: {
              width: 12,
              background: "var(--fn-surface-elevation-low, var(--fn-container-background))",
              borderRight: "1px solid var(--fn-neutral-element-border)"
            }
          }
        ),
        /* @__PURE__ */ b.jsx(
          "div",
          {
            style: {
              flex: 1,
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              background: "var(--fn-container-background)"
            },
            children: /* @__PURE__ */ b.jsxs(
              "div",
              {
                style: {
                  width: 22,
                  height: 14,
                  borderRadius: "var(--fn-border-radius-xs, 4px)",
                  background: "var(--fn-node-background)",
                  border: "1px solid var(--fn-node-header-color)",
                  boxShadow: "0 1px 2px #0002",
                  display: "flex",
                  flexDirection: "column"
                },
                children: [
                  /* @__PURE__ */ b.jsx(
                    "div",
                    {
                      style: {
                        height: 5,
                        background: "var(--fn-node-header-color)",
                        borderTopLeftRadius: "var(--fn-border-radius-xs, 4px)",
                        borderTopRightRadius: "var(--fn-border-radius-xs, 4px)"
                      }
                    }
                  ),
                  /* @__PURE__ */ b.jsx(
                    "div",
                    {
                      style: {
                        flex: 1,
                        background: "transparent"
                      }
                    }
                  )
                ]
              }
            )
          }
        )
      ] }),
      /* @__PURE__ */ b.jsx(
        "span",
        {
          style: {
            position: "absolute",
            bottom: 2,
            right: 4,
            fontSize: 9,
            color: "var(--fn-text-color-neutral)",
            opacity: 0.7,
            textTransform: "capitalize",
            fontWeight: 600,
            pointerEvents: "none"
          },
          children: e
        }
      ),
      t && /* @__PURE__ */ b.jsx(
        "span",
        {
          style: {
            position: "absolute",
            top: 2,
            left: 6,
            fontSize: 14,
            color: "#1976d2",
            fontWeight: 900,
            pointerEvents: "none"
          },
          "aria-label": "Selected",
          children: ""
        }
      )
    ]
  }
), Gse = () => {
  const { colorTheme: e, setColorTheme: t } = xN(), [n, r] = _.useState(null), [o, a] = _.useState(null), s = (c) => {
    c !== e && (a(e), t(c), r(c));
  }, u = (c) => {
    n === c && o && o !== c && t(o), r(null), a(null);
  };
  return /* @__PURE__ */ b.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "1em" }, children: [
    /* @__PURE__ */ b.jsx("div", { style: { marginBottom: 8, fontWeight: 500 }, children: "Theme:" }),
    /* @__PURE__ */ b.jsx("div", { style: {
      display: "grid",
      gridTemplateColumns: "repeat(auto-fill, minmax(80px, 1fr))",
      gap: 16,
      justifyItems: "center"
    }, children: P3.map((c) => /* @__PURE__ */ b.jsx(
      "button",
      {
        onClick: () => {
          t(c), r(null), a(null);
        },
        onMouseEnter: () => s(c),
        onMouseLeave: () => u(c),
        style: {
          background: "none",
          border: "none",
          padding: 0,
          cursor: "pointer",
          outline: "none",
          borderRadius: 8
        },
        "aria-label": `Select ${c} theme`,
        children: /* @__PURE__ */ b.jsx(
          qse,
          {
            theme: c,
            selected: e === c
          }
        )
      },
      c
    )) })
  ] });
}, Yse = () => {
  const [e, t] = _.useState(!1), n = () => {
    t(!0);
  };
  return /* @__PURE__ */ b.jsxs(b.Fragment, { children: [
    /* @__PURE__ */ b.jsxs(nw, { children: [
      /* @__PURE__ */ b.jsx(rw, { asChild: !0, children: /* @__PURE__ */ b.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ b.jsxs(Ji, { direction: "row", children: [
        "Settings ",
        /* @__PURE__ */ b.jsx(Y1, { className: "m-x-s" })
      ] }) }) }),
      /* @__PURE__ */ b.jsx(ow, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ b.jsx(iw, { children: /* @__PURE__ */ b.jsx(
        Ko,
        {
          className: "headermenuitem",
          onClick: n,
          children: "Appearance"
        }
      ) }) })
    ] }),
    /* @__PURE__ */ b.jsx(
      ci,
      {
        open: e,
        setOpen: t,
        title: "Appearance",
        description: "Change the color theme.",
        closebutton: !0,
        children: /* @__PURE__ */ b.jsx(Gse, {})
      }
    )
  ] });
}, Wse = ({
  ...e
}) => {
  const t = tt(), n = t.workerstate();
  return Object.keys(e).length > 0 && t.logger.debug("headerprops", e), /* @__PURE__ */ b.jsxs(Ji, { className: "funcnodesreactflowheader", direction: "row", wrap: !0, children: [
    /* @__PURE__ */ b.jsx(
      Ji,
      {
        className: "headerelement m-w-6",
        grow: {
          "": !0,
          m: !1
        },
        children: /* @__PURE__ */ b.jsx(Aae, {})
      }
    ),
    (e.showmenu || Dp) && /* @__PURE__ */ b.jsxs(Ji, { direction: "row", wrap: !0, children: [
      /* @__PURE__ */ b.jsx("div", { className: "headerelement", children: /* @__PURE__ */ b.jsx(Vse, {}) }),
      (t.worker && n.is_open || Dp) && /* @__PURE__ */ b.jsx("div", { className: "headerelement", children: /* @__PURE__ */ b.jsx(Use, {}) }),
      /* @__PURE__ */ b.jsx("div", { className: "headerelement", children: /* @__PURE__ */ b.jsx(Yse, {}) })
    ] })
  ] });
}, ZD = ({ item: e }) => {
  const { node: t } = xn(), n = _.useCallback(() => {
    t?.add_node(e.node_id);
  }, [e.node_id, t]), r = _.useCallback(
    (o) => {
      o.detail === 2 && n();
    },
    [n]
  );
  return /* @__PURE__ */ b.jsx("div", { className: "libnodeentry", onClick: r, title: e.description, children: e.node_name || e.node_id });
}, QD = (e, t) => {
  const n = e.nodes?.some(
    (o) => o.node_id.toLowerCase().includes(t.toLowerCase())
  ) ?? !1, r = e.subshelves?.some((o) => QD(o, t)) ?? !1;
  return n || r;
}, aw = ({
  item: e,
  filter: t,
  parentkey: n
}) => {
  const [r, o] = _.useState(!1), a = () => o(!r), s = e.nodes?.filter(
    (c) => c.node_id.toLowerCase().includes(t.toLowerCase())
  ), u = r || t.length > 0;
  return QD(e, t) ? /* @__PURE__ */ b.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ b.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: a,
        style: { cursor: "pointer" },
        title: e.description,
        children: [
          /* @__PURE__ */ b.jsx("div", { className: "shelftitle_text", children: e.name }),
          /* @__PURE__ */ b.jsx("div", { className: "expandicon " + (u ? "open" : "close"), children: /* @__PURE__ */ b.jsx(uf, {}) })
        ]
      }
    ),
    /* @__PURE__ */ b.jsx("div", { className: "libnodecontainer " + (u ? "open" : "close"), children: /* @__PURE__ */ b.jsxs("div", { className: "libnodecontainer_inner", children: [
      s && /* @__PURE__ */ b.jsx(b.Fragment, { children: s.map((c) => /* @__PURE__ */ b.jsx(ZD, { item: c }, c.node_id)) }),
      e.subshelves && /* @__PURE__ */ b.jsx(b.Fragment, { children: e.subshelves.map((c) => /* @__PURE__ */ b.jsx(
        aw,
        {
          item: c,
          filter: t,
          parentkey: n + c.name
        },
        n + c.name
      )) })
    ] }) }),
    /* @__PURE__ */ b.jsx("hr", {})
  ] }) : /* @__PURE__ */ b.jsx(b.Fragment, {});
}, Xse = ({
  filter: e,
  setFilter: t
}) => /* @__PURE__ */ b.jsxs("div", { className: "libfilter", children: [
  /* @__PURE__ */ b.jsx(IV, { fontSize: "inherit" }),
  /* @__PURE__ */ b.jsx(
    "input",
    {
      type: "text",
      placeholder: "Filter",
      value: e,
      onChange: (n) => {
        t(n.target.value);
      }
    }
  ),
  e && /* @__PURE__ */ b.jsx(
    Ic,
    {
      fontSize: "inherit",
      onClick: () => {
        t("");
      }
    }
  )
] }), Kse = ({
  children: e
}) => {
  const [t, n] = _.useState(""), r = tt(), [o, a] = _.useState(!0), [s, u] = _.useState(!0), [c, f] = _.useState(!0), [h, p] = _.useState({
    installed: [],
    available: [],
    active: []
  }), [g, y] = _.useState(!1), { lib: w } = xn(), v = (z) => {
    z && (r.worker === void 0 || !r.worker.is_open || w?.get_available_modules().then((B) => {
      p(B);
    }));
  };
  if (!r.worker)
    return /* @__PURE__ */ b.jsx(b.Fragment, {});
  const S = _.useCallback(
    (z, B) => {
      y(!1), w?.add_lib(z.name, B);
    },
    [w]
  ), E = _.useCallback(
    (z, B) => {
      y(!1), w?.add_lib(z.name, B);
    },
    [w]
  ), A = _.useCallback(
    (z) => {
      y(!1), w?.remove_lib(z.name);
    },
    [w]
  ), k = _.useCallback(
    (z, B) => {
      y(!1), w?.add_lib(z.name, B);
    },
    [w]
  ), T = _.useCallback(
    (z) => z.filter(
      (B) => B.name.toLowerCase().includes(t.toLowerCase()) || B.description.toLowerCase().includes(t.toLowerCase())
    ),
    [t]
  ), R = T(h.available), N = T(h.installed), j = T(h.active);
  return /* @__PURE__ */ b.jsxs(
    ci,
    {
      title: "Manage Library",
      trigger: e,
      description: "Add or remove libraries to the current worker.",
      onOpenChange: v,
      open: g,
      setOpen: y,
      children: [
        /* @__PURE__ */ b.jsx(
          "input",
          {
            className: "filter-input styledinput",
            type: "text",
            placeholder: "Filter modules...",
            value: t,
            onChange: (z) => n(z.target.value)
          }
        ),
        /* @__PURE__ */ b.jsxs(
          "div",
          {
            className: "packagelist",
            style: { maxHeight: "70%", overflow: "auto" },
            children: [
              N.length > 0 && /* @__PURE__ */ b.jsx(
                "h3",
                {
                  onClick: () => {
                    f(!c);
                  },
                  children: "Installed"
                }
              ),
              c && N.map((z) => /* @__PURE__ */ b.jsx(
                _pe,
                {
                  availableModule: z,
                  on_add: S
                },
                z.name + z.source
              )),
              R.length > 0 && /* @__PURE__ */ b.jsx(
                "h3",
                {
                  onClick: () => {
                    u(!s);
                  },
                  children: "Available"
                }
              ),
              s && R.map((z) => /* @__PURE__ */ b.jsx(
                Spe,
                {
                  availableModule: z,
                  on_add: E
                },
                z.name + z.source
              )),
              j.length > 0 && /* @__PURE__ */ b.jsx(
                "h3",
                {
                  onClick: () => {
                    a(!o);
                  },
                  children: "Active"
                }
              ),
              o && j.map((z) => /* @__PURE__ */ b.jsx(
                wpe,
                {
                  availableModule: z,
                  on_remove: A,
                  on_update: k
                },
                z.name + z.source
              ))
            ]
          }
        )
      ]
    }
  );
}, sw = ({
  availableModule: e
}) => /* @__PURE__ */ b.jsxs("div", { className: "module-links", children: [
  e.homepage && /* @__PURE__ */ b.jsx(b.Fragment, { children: /* @__PURE__ */ b.jsx(
    "a",
    {
      href: e.homepage,
      target: "_blank",
      rel: "noopener noreferrer",
      children: "Homepage"
    }
  ) }),
  e.source && e.homepage && " | ",
  e.source && /* @__PURE__ */ b.jsx(b.Fragment, { children: /* @__PURE__ */ b.jsx(
    "a",
    {
      href: e.source,
      target: "_blank",
      rel: "noopener noreferrer",
      children: "Source"
    }
  ) })
] });
function Zse(e, t) {
  const n = {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const Qse = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, Jse = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, ele = {};
function lR(e, t) {
  return (ele.jsx ? Jse : Qse).test(e);
}
const tle = /[ \t\n\f\r]/g;
function nle(e) {
  return typeof e == "object" ? e.type === "text" ? uR(e.value) : !1 : uR(e);
}
function uR(e) {
  return e.replace(tle, "") === "";
}
class Tf {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(t, n, r) {
    this.normal = n, this.property = t, r && (this.space = r);
  }
}
Tf.prototype.normal = {};
Tf.prototype.property = {};
Tf.prototype.space = void 0;
function JD(e, t) {
  const n = {}, r = {};
  for (const o of e)
    Object.assign(n, o.property), Object.assign(r, o.normal);
  return new Tf(n, r, t);
}
function Zb(e) {
  return e.toLowerCase();
}
class Vn {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(t, n) {
    this.attribute = n, this.property = t;
  }
}
Vn.prototype.attribute = "";
Vn.prototype.booleanish = !1;
Vn.prototype.boolean = !1;
Vn.prototype.commaOrSpaceSeparated = !1;
Vn.prototype.commaSeparated = !1;
Vn.prototype.defined = !1;
Vn.prototype.mustUseProperty = !1;
Vn.prototype.number = !1;
Vn.prototype.overloadedBoolean = !1;
Vn.prototype.property = "";
Vn.prototype.spaceSeparated = !1;
Vn.prototype.space = void 0;
let rle = 0;
const Be = is(), Gt = is(), Qb = is(), me = is(), wt = is(), gl = is(), er = is();
function is() {
  return 2 ** ++rle;
}
const Jb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Be,
  booleanish: Gt,
  commaOrSpaceSeparated: er,
  commaSeparated: gl,
  number: me,
  overloadedBoolean: Qb,
  spaceSeparated: wt
}, Symbol.toStringTag, { value: "Module" })), wv = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(Jb)
);
class lw extends Vn {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(t, n, r, o) {
    let a = -1;
    if (super(t, n), cR(this, "space", o), typeof r == "number")
      for (; ++a < wv.length; ) {
        const s = wv[a];
        cR(this, wv[a], (r & Jb[s]) === Jb[s]);
      }
  }
}
lw.prototype.defined = !0;
function cR(e, t, n) {
  n && (e[t] = n);
}
function ql(e) {
  const t = {}, n = {};
  for (const [r, o] of Object.entries(e.properties)) {
    const a = new lw(
      r,
      e.transform(e.attributes || {}, r),
      o,
      e.space
    );
    e.mustUseProperty && e.mustUseProperty.includes(r) && (a.mustUseProperty = !0), t[r] = a, n[Zb(r)] = r, n[Zb(a.attribute)] = r;
  }
  return new Tf(t, n, e.space);
}
const ej = ql({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: Gt,
    ariaAutoComplete: null,
    ariaBusy: Gt,
    ariaChecked: Gt,
    ariaColCount: me,
    ariaColIndex: me,
    ariaColSpan: me,
    ariaControls: wt,
    ariaCurrent: null,
    ariaDescribedBy: wt,
    ariaDetails: null,
    ariaDisabled: Gt,
    ariaDropEffect: wt,
    ariaErrorMessage: null,
    ariaExpanded: Gt,
    ariaFlowTo: wt,
    ariaGrabbed: Gt,
    ariaHasPopup: null,
    ariaHidden: Gt,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: wt,
    ariaLevel: me,
    ariaLive: null,
    ariaModal: Gt,
    ariaMultiLine: Gt,
    ariaMultiSelectable: Gt,
    ariaOrientation: null,
    ariaOwns: wt,
    ariaPlaceholder: null,
    ariaPosInSet: me,
    ariaPressed: Gt,
    ariaReadOnly: Gt,
    ariaRelevant: null,
    ariaRequired: Gt,
    ariaRoleDescription: wt,
    ariaRowCount: me,
    ariaRowIndex: me,
    ariaRowSpan: me,
    ariaSelected: Gt,
    ariaSetSize: me,
    ariaSort: null,
    ariaValueMax: me,
    ariaValueMin: me,
    ariaValueNow: me,
    ariaValueText: null,
    role: null
  },
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  }
});
function tj(e, t) {
  return t in e ? e[t] : t;
}
function nj(e, t) {
  return tj(e, t.toLowerCase());
}
const ole = ql({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: gl,
    acceptCharset: wt,
    accessKey: wt,
    action: null,
    allow: null,
    allowFullScreen: Be,
    allowPaymentRequest: Be,
    allowUserMedia: Be,
    alt: null,
    as: null,
    async: Be,
    autoCapitalize: null,
    autoComplete: wt,
    autoFocus: Be,
    autoPlay: Be,
    blocking: wt,
    capture: null,
    charSet: null,
    checked: Be,
    cite: null,
    className: wt,
    cols: me,
    colSpan: null,
    content: null,
    contentEditable: Gt,
    controls: Be,
    controlsList: wt,
    coords: me | gl,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Be,
    defer: Be,
    dir: null,
    dirName: null,
    disabled: Be,
    download: Qb,
    draggable: Gt,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Be,
    formTarget: null,
    headers: wt,
    height: me,
    hidden: Qb,
    high: me,
    href: null,
    hrefLang: null,
    htmlFor: wt,
    httpEquiv: wt,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: Be,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Be,
    itemId: null,
    itemProp: wt,
    itemRef: wt,
    itemScope: Be,
    itemType: wt,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Be,
    low: me,
    manifest: null,
    max: null,
    maxLength: me,
    media: null,
    method: null,
    min: null,
    minLength: me,
    multiple: Be,
    muted: Be,
    name: null,
    nonce: null,
    noModule: Be,
    noValidate: Be,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Be,
    optimum: me,
    pattern: null,
    ping: wt,
    placeholder: null,
    playsInline: Be,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: Be,
    referrerPolicy: null,
    rel: wt,
    required: Be,
    reversed: Be,
    rows: me,
    rowSpan: me,
    sandbox: wt,
    scope: null,
    scoped: Be,
    seamless: Be,
    selected: Be,
    shadowRootClonable: Be,
    shadowRootDelegatesFocus: Be,
    shadowRootMode: null,
    shape: null,
    size: me,
    sizes: null,
    slot: null,
    span: me,
    spellCheck: Gt,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: me,
    step: null,
    style: null,
    tabIndex: me,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Be,
    useMap: null,
    value: Gt,
    width: me,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: wt,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: me,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: me,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Be,
    // Lists. Use CSS to reduce space between items instead
    declare: Be,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: me,
    // `<img>` and `<object>`
    leftMargin: me,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: me,
    // `<body>`
    marginWidth: me,
    // `<body>`
    noResize: Be,
    // `<frame>`
    noHref: Be,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Be,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Be,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: me,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: Gt,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: me,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: me,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Be,
    disableRemotePlayback: Be,
    prefix: null,
    property: null,
    results: me,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: nj
}), ile = ql({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: er,
    accentHeight: me,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: me,
    amplitude: me,
    arabicForm: null,
    ascent: me,
    attributeName: null,
    attributeType: null,
    azimuth: me,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: me,
    by: null,
    calcMode: null,
    capHeight: me,
    className: wt,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: me,
    diffuseConstant: me,
    direction: null,
    display: null,
    dur: null,
    divisor: me,
    dominantBaseline: null,
    download: Be,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: me,
    enableBackground: null,
    end: null,
    event: null,
    exponent: me,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: me,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: gl,
    g2: gl,
    glyphName: gl,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: me,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: me,
    horizOriginX: me,
    horizOriginY: me,
    id: null,
    ideographic: me,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: me,
    k: me,
    k1: me,
    k2: me,
    k3: me,
    k4: me,
    kernelMatrix: er,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: me,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: me,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: me,
    overlineThickness: me,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: me,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: wt,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: me,
    pointsAtY: me,
    pointsAtZ: me,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: er,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: er,
    rev: er,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: er,
    requiredFeatures: er,
    requiredFonts: er,
    requiredFormats: er,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: me,
    specularExponent: me,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: me,
    strikethroughThickness: me,
    string: null,
    stroke: null,
    strokeDashArray: er,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: me,
    strokeOpacity: me,
    strokeWidth: null,
    style: null,
    surfaceScale: me,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: er,
    tabIndex: me,
    tableValues: null,
    target: null,
    targetX: me,
    targetY: me,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: er,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: me,
    underlineThickness: me,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: me,
    values: null,
    vAlphabetic: me,
    vMathematical: me,
    vectorEffect: null,
    vHanging: me,
    vIdeographic: me,
    version: null,
    vertAdvY: me,
    vertOriginX: me,
    vertOriginY: me,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: me,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: tj
}), rj = ql({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  }
}), oj = ql({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: nj
}), ij = ql({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  }
}), ale = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, sle = /[A-Z]/g, fR = /-[a-z]/g, lle = /^data[-\w.:]+$/i;
function ule(e, t) {
  const n = Zb(t);
  let r = t, o = Vn;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && lle.test(t)) {
    if (t.charAt(4) === "-") {
      const a = t.slice(5).replace(fR, fle);
      r = "data" + a.charAt(0).toUpperCase() + a.slice(1);
    } else {
      const a = t.slice(4);
      if (!fR.test(a)) {
        let s = a.replace(sle, cle);
        s.charAt(0) !== "-" && (s = "-" + s), t = "data" + s;
      }
    }
    o = lw;
  }
  return new o(r, t);
}
function cle(e) {
  return "-" + e.toLowerCase();
}
function fle(e) {
  return e.charAt(1).toUpperCase();
}
const dle = JD([ej, ole, rj, oj, ij], "html"), uw = JD([ej, ile, rj, oj, ij], "svg");
function hle(e) {
  return e.join(" ").trim();
}
var Js = {}, _v, dR;
function ple() {
  if (dR) return _v;
  dR = 1;
  var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, t = /\n/g, n = /^\s*/, r = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, o = /^:\s*/, a = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, s = /^[;\s]*/, u = /^\s+|\s+$/g, c = `
`, f = "/", h = "*", p = "", g = "comment", y = "declaration";
  _v = function(v, S) {
    if (typeof v != "string")
      throw new TypeError("First argument must be a string");
    if (!v) return [];
    S = S || {};
    var E = 1, A = 1;
    function k(Y) {
      var P = Y.match(t);
      P && (E += P.length);
      var V = Y.lastIndexOf(c);
      A = ~V ? Y.length - V : A + Y.length;
    }
    function T() {
      var Y = { line: E, column: A };
      return function(P) {
        return P.position = new R(Y), z(), P;
      };
    }
    function R(Y) {
      this.start = Y, this.end = { line: E, column: A }, this.source = S.source;
    }
    R.prototype.content = v;
    function N(Y) {
      var P = new Error(
        S.source + ":" + E + ":" + A + ": " + Y
      );
      if (P.reason = Y, P.filename = S.source, P.line = E, P.column = A, P.source = v, !S.silent) throw P;
    }
    function j(Y) {
      var P = Y.exec(v);
      if (P) {
        var V = P[0];
        return k(V), v = v.slice(V.length), P;
      }
    }
    function z() {
      j(n);
    }
    function B(Y) {
      var P;
      for (Y = Y || []; P = M(); )
        P !== !1 && Y.push(P);
      return Y;
    }
    function M() {
      var Y = T();
      if (!(f != v.charAt(0) || h != v.charAt(1))) {
        for (var P = 2; p != v.charAt(P) && (h != v.charAt(P) || f != v.charAt(P + 1)); )
          ++P;
        if (P += 2, p === v.charAt(P - 1))
          return N("End of comment missing");
        var V = v.slice(2, P - 2);
        return A += 2, k(V), v = v.slice(P), A += 2, Y({
          type: g,
          comment: V
        });
      }
    }
    function F() {
      var Y = T(), P = j(r);
      if (P) {
        if (M(), !j(o)) return N("property missing ':'");
        var V = j(a), I = Y({
          type: y,
          property: w(P[0].replace(e, p)),
          value: V ? w(V[0].replace(e, p)) : p
        });
        return j(s), I;
      }
    }
    function q() {
      var Y = [];
      B(Y);
      for (var P; P = F(); )
        P !== !1 && (Y.push(P), B(Y));
      return Y;
    }
    return z(), q();
  };
  function w(v) {
    return v ? v.replace(u, p) : p;
  }
  return _v;
}
var hR;
function mle() {
  if (hR) return Js;
  hR = 1;
  var e = Js && Js.__importDefault || function(r) {
    return r && r.__esModule ? r : { default: r };
  };
  Object.defineProperty(Js, "__esModule", { value: !0 }), Js.default = n;
  var t = e(ple());
  function n(r, o) {
    var a = null;
    if (!r || typeof r != "string")
      return a;
    var s = (0, t.default)(r), u = typeof o == "function";
    return s.forEach(function(c) {
      if (c.type === "declaration") {
        var f = c.property, h = c.value;
        u ? o(f, h, c) : h && (a = a || {}, a[f] = h);
      }
    }), a;
  }
  return Js;
}
var sc = {}, pR;
function gle() {
  if (pR) return sc;
  pR = 1, Object.defineProperty(sc, "__esModule", { value: !0 }), sc.camelCase = void 0;
  var e = /^--[a-zA-Z0-9_-]+$/, t = /-([a-z])/g, n = /^[^-]+$/, r = /^-(webkit|moz|ms|o|khtml)-/, o = /^-(ms)-/, a = function(f) {
    return !f || n.test(f) || e.test(f);
  }, s = function(f, h) {
    return h.toUpperCase();
  }, u = function(f, h) {
    return "".concat(h, "-");
  }, c = function(f, h) {
    return h === void 0 && (h = {}), a(f) ? f : (f = f.toLowerCase(), h.reactCompat ? f = f.replace(o, u) : f = f.replace(r, u), f.replace(t, s));
  };
  return sc.camelCase = c, sc;
}
var lc, mR;
function yle() {
  if (mR) return lc;
  mR = 1;
  var e = lc && lc.__importDefault || function(o) {
    return o && o.__esModule ? o : { default: o };
  }, t = e(mle()), n = gle();
  function r(o, a) {
    var s = {};
    return !o || typeof o != "string" || (0, t.default)(o, function(u, c) {
      u && c && (s[(0, n.camelCase)(u, a)] = c);
    }), s;
  }
  return r.default = r, lc = r, lc;
}
var vle = yle();
const ble = /* @__PURE__ */ jl(vle), aj = sj("end"), cw = sj("start");
function sj(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function xle(e) {
  const t = cw(e), n = aj(e);
  if (t && n)
    return { start: t, end: n };
}
function Cc(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? gR(e.position) : "start" in e || "end" in e ? gR(e) : "line" in e || "column" in e ? e1(e) : "";
}
function e1(e) {
  return yR(e && e.line) + ":" + yR(e && e.column);
}
function gR(e) {
  return e1(e && e.start) + "-" + e1(e && e.end);
}
function yR(e) {
  return e && typeof e == "number" ? e : 1;
}
class wn extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let o = "", a = {}, s = !1;
    if (n && ("line" in n && "column" in n ? a = { place: n } : "start" in n && "end" in n ? a = { place: n } : "type" in n ? a = {
      ancestors: [n],
      place: n.position
    } : a = { ...n }), typeof t == "string" ? o = t : !a.cause && t && (s = !0, o = t.message, a.cause = t), !a.ruleId && !a.source && typeof r == "string") {
      const c = r.indexOf(":");
      c === -1 ? a.ruleId = r : (a.source = r.slice(0, c), a.ruleId = r.slice(c + 1));
    }
    if (!a.place && a.ancestors && a.ancestors) {
      const c = a.ancestors[a.ancestors.length - 1];
      c && (a.place = c.position);
    }
    const u = a.place && "start" in a.place ? a.place.start : a.place;
    this.ancestors = a.ancestors || void 0, this.cause = a.cause || void 0, this.column = u ? u.column : void 0, this.fatal = void 0, this.file, this.message = o, this.line = u ? u.line : void 0, this.name = Cc(a.place) || "1:1", this.place = a.place || void 0, this.reason = this.message, this.ruleId = a.ruleId || void 0, this.source = a.source || void 0, this.stack = s && a.cause && typeof a.cause.stack == "string" ? a.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
wn.prototype.file = "";
wn.prototype.name = "";
wn.prototype.reason = "";
wn.prototype.message = "";
wn.prototype.stack = "";
wn.prototype.column = void 0;
wn.prototype.line = void 0;
wn.prototype.ancestors = void 0;
wn.prototype.cause = void 0;
wn.prototype.fatal = void 0;
wn.prototype.place = void 0;
wn.prototype.ruleId = void 0;
wn.prototype.source = void 0;
const fw = {}.hasOwnProperty, wle = /* @__PURE__ */ new Map(), _le = /[A-Z]/g, Sle = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), Ele = /* @__PURE__ */ new Set(["td", "th"]), lj = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function Cle(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = Dle(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = Nle(n, t.jsx, t.jsxs);
  }
  const o = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? uw : dle,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, a = uj(o, e, void 0);
  return a && typeof a != "string" ? a : o.create(
    e,
    o.Fragment,
    { children: a || void 0 },
    void 0
  );
}
function uj(e, t, n) {
  if (t.type === "element")
    return kle(e, t, n);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return Tle(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return Rle(e, t, n);
  if (t.type === "mdxjsEsm")
    return Ale(e, t);
  if (t.type === "root")
    return Mle(e, t, n);
  if (t.type === "text")
    return Ole(e, t);
}
function kle(e, t, n) {
  const r = e.schema;
  let o = r;
  t.tagName.toLowerCase() === "svg" && r.space === "html" && (o = uw, e.schema = o), e.ancestors.push(t);
  const a = fj(e, t.tagName, !1), s = jle(e, t);
  let u = hw(e, t);
  return Sle.has(t.tagName) && (u = u.filter(function(c) {
    return typeof c == "string" ? !nle(c) : !0;
  })), cj(e, s, a, t), dw(s, u), e.ancestors.pop(), e.schema = r, e.create(t, a, s, n);
}
function Tle(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const r = t.data.estree.body[0];
    return r.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(r.expression);
  }
  Qc(e, t.position);
}
function Ale(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  Qc(e, t.position);
}
function Rle(e, t, n) {
  const r = e.schema;
  let o = r;
  t.name === "svg" && r.space === "html" && (o = uw, e.schema = o), e.ancestors.push(t);
  const a = t.name === null ? e.Fragment : fj(e, t.name, !0), s = Ple(e, t), u = hw(e, t);
  return cj(e, s, a, t), dw(s, u), e.ancestors.pop(), e.schema = r, e.create(t, a, s, n);
}
function Mle(e, t, n) {
  const r = {};
  return dw(r, hw(e, t)), e.create(t, e.Fragment, r, n);
}
function Ole(e, t) {
  return t.value;
}
function cj(e, t, n, r) {
  typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
}
function dw(e, t) {
  if (t.length > 0) {
    const n = t.length > 1 ? t : t[0];
    n && (e.children = n);
  }
}
function Nle(e, t, n) {
  return r;
  function r(o, a, s, u) {
    const f = Array.isArray(s.children) ? n : t;
    return u ? f(a, s, u) : f(a, s);
  }
}
function Dle(e, t) {
  return n;
  function n(r, o, a, s) {
    const u = Array.isArray(a.children), c = cw(r);
    return t(
      o,
      a,
      s,
      u,
      {
        columnNumber: c ? c.column - 1 : void 0,
        fileName: e,
        lineNumber: c ? c.line : void 0
      },
      void 0
    );
  }
}
function jle(e, t) {
  const n = {};
  let r, o;
  for (o in t.properties)
    if (o !== "children" && fw.call(t.properties, o)) {
      const a = Ile(e, o, t.properties[o]);
      if (a) {
        const [s, u] = a;
        e.tableCellAlignToStyle && s === "align" && typeof u == "string" && Ele.has(t.tagName) ? r = u : n[s] = u;
      }
    }
  if (r) {
    const a = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    a[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n;
}
function Ple(e, t) {
  const n = {};
  for (const r of t.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && e.evaluater) {
        const a = r.data.estree.body[0];
        a.type;
        const s = a.expression;
        s.type;
        const u = s.properties[0];
        u.type, Object.assign(
          n,
          e.evaluater.evaluateExpression(u.argument)
        );
      } else
        Qc(e, t.position);
    else {
      const o = r.name;
      let a;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && e.evaluater) {
          const u = r.value.data.estree.body[0];
          u.type, a = e.evaluater.evaluateExpression(u.expression);
        } else
          Qc(e, t.position);
      else
        a = r.value === null ? !0 : r.value;
      n[o] = /** @type {Props[keyof Props]} */
      a;
    }
  return n;
}
function hw(e, t) {
  const n = [];
  let r = -1;
  const o = e.passKeys ? /* @__PURE__ */ new Map() : wle;
  for (; ++r < t.children.length; ) {
    const a = t.children[r];
    let s;
    if (e.passKeys) {
      const c = a.type === "element" ? a.tagName : a.type === "mdxJsxFlowElement" || a.type === "mdxJsxTextElement" ? a.name : void 0;
      if (c) {
        const f = o.get(c) || 0;
        s = c + "-" + f, o.set(c, f + 1);
      }
    }
    const u = uj(e, a, s);
    u !== void 0 && n.push(u);
  }
  return n;
}
function Ile(e, t, n) {
  const r = ule(e.schema, t);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r.commaSeparated ? Zse(n) : hle(n)), r.property === "style") {
      let o = typeof n == "object" ? n : zle(e, String(n));
      return e.stylePropertyNameCase === "css" && (o = Lle(o)), ["style", o];
    }
    return [
      e.elementAttributeNameCase === "react" && r.space ? ale[r.property] || r.property : r.attribute,
      n
    ];
  }
}
function zle(e, t) {
  try {
    return ble(t, { reactCompat: !0 });
  } catch (n) {
    if (e.ignoreInvalidStyle)
      return {};
    const r = (
      /** @type {Error} */
      n
    ), o = new wn("Cannot parse `style` attribute", {
      ancestors: e.ancestors,
      cause: r,
      ruleId: "style",
      source: "hast-util-to-jsx-runtime"
    });
    throw o.file = e.filePath || void 0, o.url = lj + "#cannot-parse-style-attribute", o;
  }
}
function fj(e, t, n) {
  let r;
  if (!n)
    r = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const o = t.split(".");
    let a = -1, s;
    for (; ++a < o.length; ) {
      const u = lR(o[a]) ? { type: "Identifier", name: o[a] } : { type: "Literal", value: o[a] };
      s = s ? {
        type: "MemberExpression",
        object: s,
        property: u,
        computed: !!(a && u.type === "Literal"),
        optional: !1
      } : u;
    }
    r = s;
  } else
    r = lR(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (r.type === "Literal") {
    const o = (
      /** @type {string | number} */
      r.value
    );
    return fw.call(e.components, o) ? e.components[o] : o;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(r);
  Qc(e);
}
function Qc(e, t) {
  const n = new wn(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = e.filePath || void 0, n.url = lj + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function Lle(e) {
  const t = {};
  let n;
  for (n in e)
    fw.call(e, n) && (t[Fle(n)] = e[n]);
  return t;
}
function Fle(e) {
  let t = e.replace(_le, $le);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function $le(e) {
  return "-" + e.toLowerCase();
}
const Sv = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, Ble = {};
function pw(e, t) {
  const n = Ble, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, o = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return dj(e, r, o);
}
function dj(e, t, n) {
  if (Hle(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return vR(e.children, t, n);
  }
  return Array.isArray(e) ? vR(e, t, n) : "";
}
function vR(e, t, n) {
  const r = [];
  let o = -1;
  for (; ++o < e.length; )
    r[o] = dj(e[o], t, n);
  return r.join("");
}
function Hle(e) {
  return !!(e && typeof e == "object");
}
const bR = document.createElement("i");
function mw(e) {
  const t = "&" + e + ";";
  bR.innerHTML = t;
  const n = bR.textContent;
  return (
    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
    // yield `null`.
    n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n
  );
}
function sr(e, t, n, r) {
  const o = e.length;
  let a = 0, s;
  if (t < 0 ? t = -t > o ? 0 : o + t : t = t > o ? o : t, n = n > 0 ? n : 0, r.length < 1e4)
    s = Array.from(r), s.unshift(t, n), e.splice(...s);
  else
    for (n && e.splice(t, n); a < r.length; )
      s = r.slice(a, a + 1e4), s.unshift(t, 0), e.splice(...s), a += 1e4, t += 1e4;
}
function Sr(e, t) {
  return e.length > 0 ? (sr(e, e.length, 0, t), e) : t;
}
const xR = {}.hasOwnProperty;
function hj(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    Vle(t, e[n]);
  return t;
}
function Vle(e, t) {
  let n;
  for (n in t) {
    const o = (xR.call(e, n) ? e[n] : void 0) || (e[n] = {}), a = t[n];
    let s;
    if (a)
      for (s in a) {
        xR.call(o, s) || (o[s] = []);
        const u = a[s];
        Ule(
          // @ts-expect-error Looks like a list.
          o[s],
          Array.isArray(u) ? u : u ? [u] : []
        );
      }
  }
}
function Ule(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  sr(e, 0, 0, r);
}
function pj(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "" : String.fromCodePoint(n)
  );
}
function zr(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const kn = ua(/[A-Za-z]/), vn = ua(/[\dA-Za-z]/), qle = ua(/[#-'*+\--9=?A-Z^-~]/);
function Ip(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const t1 = ua(/\d/), Gle = ua(/[\dA-Fa-f]/), Yle = ua(/[!-/:-@[-`{-~]/);
function Oe(e) {
  return e !== null && e < -2;
}
function vt(e) {
  return e !== null && (e < 0 || e === 32);
}
function We(e) {
  return e === -2 || e === -1 || e === 32;
}
const Qm = ua(/\p{P}|\p{S}/u), es = ua(/\s/);
function ua(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function Gl(e) {
  const t = [];
  let n = -1, r = 0, o = 0;
  for (; ++n < e.length; ) {
    const a = e.charCodeAt(n);
    let s = "";
    if (a === 37 && vn(e.charCodeAt(n + 1)) && vn(e.charCodeAt(n + 2)))
      o = 2;
    else if (a < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(a)) || (s = String.fromCharCode(a));
    else if (a > 55295 && a < 57344) {
      const u = e.charCodeAt(n + 1);
      a < 56320 && u > 56319 && u < 57344 ? (s = String.fromCharCode(a, u), o = 1) : s = "";
    } else
      s = String.fromCharCode(a);
    s && (t.push(e.slice(r, n), encodeURIComponent(s)), r = n + o + 1, s = ""), o && (n += o, o = 0);
  }
  return t.join("") + e.slice(r);
}
function Qe(e, t, n, r) {
  const o = r ? r - 1 : Number.POSITIVE_INFINITY;
  let a = 0;
  return s;
  function s(c) {
    return We(c) ? (e.enter(n), u(c)) : t(c);
  }
  function u(c) {
    return We(c) && a++ < o ? (e.consume(c), u) : (e.exit(n), t(c));
  }
}
const Wle = {
  tokenize: Xle
};
function Xle(e) {
  const t = e.attempt(this.parser.constructs.contentInitial, r, o);
  let n;
  return t;
  function r(u) {
    if (u === null) {
      e.consume(u);
      return;
    }
    return e.enter("lineEnding"), e.consume(u), e.exit("lineEnding"), Qe(e, t, "linePrefix");
  }
  function o(u) {
    return e.enter("paragraph"), a(u);
  }
  function a(u) {
    const c = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = c), n = c, s(u);
  }
  function s(u) {
    if (u === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(u);
      return;
    }
    return Oe(u) ? (e.consume(u), e.exit("chunkText"), a) : (e.consume(u), s);
  }
}
const Kle = {
  tokenize: Zle
}, wR = {
  tokenize: Qle
};
function Zle(e) {
  const t = this, n = [];
  let r = 0, o, a, s;
  return u;
  function u(k) {
    if (r < n.length) {
      const T = n[r];
      return t.containerState = T[1], e.attempt(T[0].continuation, c, f)(k);
    }
    return f(k);
  }
  function c(k) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, o && A();
      const T = t.events.length;
      let R = T, N;
      for (; R--; )
        if (t.events[R][0] === "exit" && t.events[R][1].type === "chunkFlow") {
          N = t.events[R][1].end;
          break;
        }
      E(r);
      let j = T;
      for (; j < t.events.length; )
        t.events[j][1].end = {
          ...N
        }, j++;
      return sr(t.events, R + 1, 0, t.events.slice(T)), t.events.length = j, f(k);
    }
    return u(k);
  }
  function f(k) {
    if (r === n.length) {
      if (!o)
        return g(k);
      if (o.currentConstruct && o.currentConstruct.concrete)
        return w(k);
      t.interrupt = !!(o.currentConstruct && !o._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(wR, h, p)(k);
  }
  function h(k) {
    return o && A(), E(r), g(k);
  }
  function p(k) {
    return t.parser.lazy[t.now().line] = r !== n.length, s = t.now().offset, w(k);
  }
  function g(k) {
    return t.containerState = {}, e.attempt(wR, y, w)(k);
  }
  function y(k) {
    return r++, n.push([t.currentConstruct, t.containerState]), g(k);
  }
  function w(k) {
    if (k === null) {
      o && A(), E(0), e.consume(k);
      return;
    }
    return o = o || t.parser.flow(t.now()), e.enter("chunkFlow", {
      _tokenizer: o,
      contentType: "flow",
      previous: a
    }), v(k);
  }
  function v(k) {
    if (k === null) {
      S(e.exit("chunkFlow"), !0), E(0), e.consume(k);
      return;
    }
    return Oe(k) ? (e.consume(k), S(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, u) : (e.consume(k), v);
  }
  function S(k, T) {
    const R = t.sliceStream(k);
    if (T && R.push(null), k.previous = a, a && (a.next = k), a = k, o.defineSkip(k.start), o.write(R), t.parser.lazy[k.start.line]) {
      let N = o.events.length;
      for (; N--; )
        if (
          // The token starts before the line ending
          o.events[N][1].start.offset < s && // and either is not ended yet
          (!o.events[N][1].end || // or ends after it.
          o.events[N][1].end.offset > s)
        )
          return;
      const j = t.events.length;
      let z = j, B, M;
      for (; z--; )
        if (t.events[z][0] === "exit" && t.events[z][1].type === "chunkFlow") {
          if (B) {
            M = t.events[z][1].end;
            break;
          }
          B = !0;
        }
      for (E(r), N = j; N < t.events.length; )
        t.events[N][1].end = {
          ...M
        }, N++;
      sr(t.events, z + 1, 0, t.events.slice(j)), t.events.length = N;
    }
  }
  function E(k) {
    let T = n.length;
    for (; T-- > k; ) {
      const R = n[T];
      t.containerState = R[1], R[0].exit.call(t, e);
    }
    n.length = k;
  }
  function A() {
    o.write([null]), a = void 0, o = void 0, t.containerState._closeFlow = void 0;
  }
}
function Qle(e, t, n) {
  return Qe(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
}
function Dl(e) {
  if (e === null || vt(e) || es(e))
    return 1;
  if (Qm(e))
    return 2;
}
function Jm(e, t, n) {
  const r = [];
  let o = -1;
  for (; ++o < e.length; ) {
    const a = e[o].resolveAll;
    a && !r.includes(a) && (t = a(t, n), r.push(a));
  }
  return t;
}
const n1 = {
  name: "attention",
  resolveAll: Jle,
  tokenize: eue
};
function Jle(e, t) {
  let n = -1, r, o, a, s, u, c, f, h;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          c = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const p = {
            ...e[r][1].end
          }, g = {
            ...e[n][1].start
          };
          _R(p, -c), _R(g, c), s = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: p,
            end: {
              ...e[r][1].end
            }
          }, u = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: {
              ...e[n][1].start
            },
            end: g
          }, a = {
            type: c > 1 ? "strongText" : "emphasisText",
            start: {
              ...e[r][1].end
            },
            end: {
              ...e[n][1].start
            }
          }, o = {
            type: c > 1 ? "strong" : "emphasis",
            start: {
              ...s.start
            },
            end: {
              ...u.end
            }
          }, e[r][1].end = {
            ...s.start
          }, e[n][1].start = {
            ...u.end
          }, f = [], e[r][1].end.offset - e[r][1].start.offset && (f = Sr(f, [["enter", e[r][1], t], ["exit", e[r][1], t]])), f = Sr(f, [["enter", o, t], ["enter", s, t], ["exit", s, t], ["enter", a, t]]), f = Sr(f, Jm(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), f = Sr(f, [["exit", a, t], ["enter", u, t], ["exit", u, t], ["exit", o, t]]), e[n][1].end.offset - e[n][1].start.offset ? (h = 2, f = Sr(f, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : h = 0, sr(e, r - 1, n - r + 3, f), n = r + f.length - h - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function eue(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, o = Dl(r);
  let a;
  return s;
  function s(c) {
    return a = c, e.enter("attentionSequence"), u(c);
  }
  function u(c) {
    if (c === a)
      return e.consume(c), u;
    const f = e.exit("attentionSequence"), h = Dl(c), p = !h || h === 2 && o || n.includes(c), g = !o || o === 2 && h || n.includes(r);
    return f._open = !!(a === 42 ? p : p && (o || !g)), f._close = !!(a === 42 ? g : g && (h || !p)), t(c);
  }
}
function _R(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const tue = {
  name: "autolink",
  tokenize: nue
};
function nue(e, t, n) {
  let r = 0;
  return o;
  function o(y) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), a;
  }
  function a(y) {
    return kn(y) ? (e.consume(y), s) : y === 64 ? n(y) : f(y);
  }
  function s(y) {
    return y === 43 || y === 45 || y === 46 || vn(y) ? (r = 1, u(y)) : f(y);
  }
  function u(y) {
    return y === 58 ? (e.consume(y), r = 0, c) : (y === 43 || y === 45 || y === 46 || vn(y)) && r++ < 32 ? (e.consume(y), u) : (r = 0, f(y));
  }
  function c(y) {
    return y === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.exit("autolink"), t) : y === null || y === 32 || y === 60 || Ip(y) ? n(y) : (e.consume(y), c);
  }
  function f(y) {
    return y === 64 ? (e.consume(y), h) : qle(y) ? (e.consume(y), f) : n(y);
  }
  function h(y) {
    return vn(y) ? p(y) : n(y);
  }
  function p(y) {
    return y === 46 ? (e.consume(y), r = 0, h) : y === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(y), e.exit("autolinkMarker"), e.exit("autolink"), t) : g(y);
  }
  function g(y) {
    if ((y === 45 || vn(y)) && r++ < 63) {
      const w = y === 45 ? g : p;
      return e.consume(y), w;
    }
    return n(y);
  }
}
const Af = {
  partial: !0,
  tokenize: rue
};
function rue(e, t, n) {
  return r;
  function r(a) {
    return We(a) ? Qe(e, o, "linePrefix")(a) : o(a);
  }
  function o(a) {
    return a === null || Oe(a) ? t(a) : n(a);
  }
}
const mj = {
  continuation: {
    tokenize: iue
  },
  exit: aue,
  name: "blockQuote",
  tokenize: oue
};
function oue(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    if (s === 62) {
      const u = r.containerState;
      return u.open || (e.enter("blockQuote", {
        _container: !0
      }), u.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(s), e.exit("blockQuoteMarker"), a;
    }
    return n(s);
  }
  function a(s) {
    return We(s) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(s), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(s));
  }
}
function iue(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return We(s) ? Qe(e, a, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s) : a(s);
  }
  function a(s) {
    return e.attempt(mj, t, n)(s);
  }
}
function aue(e) {
  e.exit("blockQuote");
}
const gj = {
  name: "characterEscape",
  tokenize: sue
};
function sue(e, t, n) {
  return r;
  function r(a) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(a), e.exit("escapeMarker"), o;
  }
  function o(a) {
    return Yle(a) ? (e.enter("characterEscapeValue"), e.consume(a), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(a);
  }
}
const yj = {
  name: "characterReference",
  tokenize: lue
};
function lue(e, t, n) {
  const r = this;
  let o = 0, a, s;
  return u;
  function u(p) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(p), e.exit("characterReferenceMarker"), c;
  }
  function c(p) {
    return p === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(p), e.exit("characterReferenceMarkerNumeric"), f) : (e.enter("characterReferenceValue"), a = 31, s = vn, h(p));
  }
  function f(p) {
    return p === 88 || p === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(p), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), a = 6, s = Gle, h) : (e.enter("characterReferenceValue"), a = 7, s = t1, h(p));
  }
  function h(p) {
    if (p === 59 && o) {
      const g = e.exit("characterReferenceValue");
      return s === vn && !mw(r.sliceSerialize(g)) ? n(p) : (e.enter("characterReferenceMarker"), e.consume(p), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return s(p) && o++ < a ? (e.consume(p), h) : n(p);
  }
}
const SR = {
  partial: !0,
  tokenize: cue
}, ER = {
  concrete: !0,
  name: "codeFenced",
  tokenize: uue
};
function uue(e, t, n) {
  const r = this, o = {
    partial: !0,
    tokenize: R
  };
  let a = 0, s = 0, u;
  return c;
  function c(N) {
    return f(N);
  }
  function f(N) {
    const j = r.events[r.events.length - 1];
    return a = j && j[1].type === "linePrefix" ? j[2].sliceSerialize(j[1], !0).length : 0, u = N, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), h(N);
  }
  function h(N) {
    return N === u ? (s++, e.consume(N), h) : s < 3 ? n(N) : (e.exit("codeFencedFenceSequence"), We(N) ? Qe(e, p, "whitespace")(N) : p(N));
  }
  function p(N) {
    return N === null || Oe(N) ? (e.exit("codeFencedFence"), r.interrupt ? t(N) : e.check(SR, v, T)(N)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), g(N));
  }
  function g(N) {
    return N === null || Oe(N) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), p(N)) : We(N) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), Qe(e, y, "whitespace")(N)) : N === 96 && N === u ? n(N) : (e.consume(N), g);
  }
  function y(N) {
    return N === null || Oe(N) ? p(N) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), w(N));
  }
  function w(N) {
    return N === null || Oe(N) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), p(N)) : N === 96 && N === u ? n(N) : (e.consume(N), w);
  }
  function v(N) {
    return e.attempt(o, T, S)(N);
  }
  function S(N) {
    return e.enter("lineEnding"), e.consume(N), e.exit("lineEnding"), E;
  }
  function E(N) {
    return a > 0 && We(N) ? Qe(e, A, "linePrefix", a + 1)(N) : A(N);
  }
  function A(N) {
    return N === null || Oe(N) ? e.check(SR, v, T)(N) : (e.enter("codeFlowValue"), k(N));
  }
  function k(N) {
    return N === null || Oe(N) ? (e.exit("codeFlowValue"), A(N)) : (e.consume(N), k);
  }
  function T(N) {
    return e.exit("codeFenced"), t(N);
  }
  function R(N, j, z) {
    let B = 0;
    return M;
    function M(V) {
      return N.enter("lineEnding"), N.consume(V), N.exit("lineEnding"), F;
    }
    function F(V) {
      return N.enter("codeFencedFence"), We(V) ? Qe(N, q, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(V) : q(V);
    }
    function q(V) {
      return V === u ? (N.enter("codeFencedFenceSequence"), Y(V)) : z(V);
    }
    function Y(V) {
      return V === u ? (B++, N.consume(V), Y) : B >= s ? (N.exit("codeFencedFenceSequence"), We(V) ? Qe(N, P, "whitespace")(V) : P(V)) : z(V);
    }
    function P(V) {
      return V === null || Oe(V) ? (N.exit("codeFencedFence"), j(V)) : z(V);
    }
  }
}
function cue(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return s === null ? n(s) : (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), a);
  }
  function a(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
const Ev = {
  name: "codeIndented",
  tokenize: due
}, fue = {
  partial: !0,
  tokenize: hue
};
function due(e, t, n) {
  const r = this;
  return o;
  function o(f) {
    return e.enter("codeIndented"), Qe(e, a, "linePrefix", 5)(f);
  }
  function a(f) {
    const h = r.events[r.events.length - 1];
    return h && h[1].type === "linePrefix" && h[2].sliceSerialize(h[1], !0).length >= 4 ? s(f) : n(f);
  }
  function s(f) {
    return f === null ? c(f) : Oe(f) ? e.attempt(fue, s, c)(f) : (e.enter("codeFlowValue"), u(f));
  }
  function u(f) {
    return f === null || Oe(f) ? (e.exit("codeFlowValue"), s(f)) : (e.consume(f), u);
  }
  function c(f) {
    return e.exit("codeIndented"), t(f);
  }
}
function hue(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return r.parser.lazy[r.now().line] ? n(s) : Oe(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), o) : Qe(e, a, "linePrefix", 5)(s);
  }
  function a(s) {
    const u = r.events[r.events.length - 1];
    return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? t(s) : Oe(s) ? o(s) : n(s);
  }
}
const pue = {
  name: "codeText",
  previous: gue,
  resolve: mue,
  tokenize: yue
};
function mue(e) {
  let t = e.length - 4, n = 3, r, o;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    o === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (o = r) : (r === t || e[r][1].type === "lineEnding") && (e[o][1].type = "codeTextData", r !== o + 2 && (e[o][1].end = e[r - 1][1].end, e.splice(o + 2, r - o - 2), t -= r - o - 2, r = o + 2), o = void 0);
  return e;
}
function gue(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function yue(e, t, n) {
  let r = 0, o, a;
  return s;
  function s(p) {
    return e.enter("codeText"), e.enter("codeTextSequence"), u(p);
  }
  function u(p) {
    return p === 96 ? (e.consume(p), r++, u) : (e.exit("codeTextSequence"), c(p));
  }
  function c(p) {
    return p === null ? n(p) : p === 32 ? (e.enter("space"), e.consume(p), e.exit("space"), c) : p === 96 ? (a = e.enter("codeTextSequence"), o = 0, h(p)) : Oe(p) ? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), c) : (e.enter("codeTextData"), f(p));
  }
  function f(p) {
    return p === null || p === 32 || p === 96 || Oe(p) ? (e.exit("codeTextData"), c(p)) : (e.consume(p), f);
  }
  function h(p) {
    return p === 96 ? (e.consume(p), o++, h) : o === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(p)) : (a.type = "codeTextData", f(p));
  }
}
class vue {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, n, r) {
    const o = n || 0;
    this.setCursor(Math.trunc(t));
    const a = this.right.splice(this.right.length - o, Number.POSITIVE_INFINITY);
    return r && uc(this.left, r), a.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), uc(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), uc(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const n = this.left.splice(t, Number.POSITIVE_INFINITY);
        uc(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        uc(this.left, n.reverse());
      }
  }
}
function uc(e, t) {
  let n = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; n < t.length; )
      e.push(...t.slice(n, n + 1e4)), n += 1e4;
}
function vj(e) {
  const t = {};
  let n = -1, r, o, a, s, u, c, f;
  const h = new vue(e);
  for (; ++n < h.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = h.get(n), n && r[1].type === "chunkFlow" && h.get(n - 1)[1].type === "listItemPrefix" && (c = r[1]._tokenizer.events, a = 0, a < c.length && c[a][1].type === "lineEndingBlank" && (a += 2), a < c.length && c[a][1].type === "content"))
      for (; ++a < c.length && c[a][1].type !== "content"; )
        c[a][1].type === "chunkText" && (c[a][1]._isInFirstContentOfListItem = !0, a++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, bue(h, n)), n = t[n], f = !0);
    else if (r[1]._container) {
      for (a = n, o = void 0; a--; )
        if (s = h.get(a), s[1].type === "lineEnding" || s[1].type === "lineEndingBlank")
          s[0] === "enter" && (o && (h.get(o)[1].type = "lineEndingBlank"), s[1].type = "lineEnding", o = a);
        else if (!(s[1].type === "linePrefix" || s[1].type === "listItemIndent")) break;
      o && (r[1].end = {
        ...h.get(o)[1].start
      }, u = h.slice(o, n), u.unshift(r), h.splice(o, n - o + 1, u));
    }
  }
  return sr(e, 0, Number.POSITIVE_INFINITY, h.slice(0)), !f;
}
function bue(e, t) {
  const n = e.get(t)[1], r = e.get(t)[2];
  let o = t - 1;
  const a = [];
  let s = n._tokenizer;
  s || (s = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (s._contentTypeTextTrailing = !0));
  const u = s.events, c = [], f = {};
  let h, p, g = -1, y = n, w = 0, v = 0;
  const S = [v];
  for (; y; ) {
    for (; e.get(++o)[1] !== y; )
      ;
    a.push(o), y._tokenizer || (h = r.sliceStream(y), y.next || h.push(null), p && s.defineSkip(y.start), y._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = !0), s.write(h), y._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = void 0)), p = y, y = y.next;
  }
  for (y = n; ++g < u.length; )
    // Find a void token that includes a break.
    u[g][0] === "exit" && u[g - 1][0] === "enter" && u[g][1].type === u[g - 1][1].type && u[g][1].start.line !== u[g][1].end.line && (v = g + 1, S.push(v), y._tokenizer = void 0, y.previous = void 0, y = y.next);
  for (s.events = [], y ? (y._tokenizer = void 0, y.previous = void 0) : S.pop(), g = S.length; g--; ) {
    const E = u.slice(S[g], S[g + 1]), A = a.pop();
    c.push([A, A + E.length - 1]), e.splice(A, 2, E);
  }
  for (c.reverse(), g = -1; ++g < c.length; )
    f[w + c[g][0]] = w + c[g][1], w += c[g][1] - c[g][0] - 1;
  return f;
}
const xue = {
  resolve: _ue,
  tokenize: Sue
}, wue = {
  partial: !0,
  tokenize: Eue
};
function _ue(e) {
  return vj(e), e;
}
function Sue(e, t) {
  let n;
  return r;
  function r(u) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), o(u);
  }
  function o(u) {
    return u === null ? a(u) : Oe(u) ? e.check(wue, s, a)(u) : (e.consume(u), o);
  }
  function a(u) {
    return e.exit("chunkContent"), e.exit("content"), t(u);
  }
  function s(u) {
    return e.consume(u), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, o;
  }
}
function Eue(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), Qe(e, a, "linePrefix");
  }
  function a(s) {
    if (s === null || Oe(s))
      return n(s);
    const u = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? t(s) : e.interrupt(r.parser.constructs.flow, n, t)(s);
  }
}
function bj(e, t, n, r, o, a, s, u, c) {
  const f = c || Number.POSITIVE_INFINITY;
  let h = 0;
  return p;
  function p(E) {
    return E === 60 ? (e.enter(r), e.enter(o), e.enter(a), e.consume(E), e.exit(a), g) : E === null || E === 32 || E === 41 || Ip(E) ? n(E) : (e.enter(r), e.enter(s), e.enter(u), e.enter("chunkString", {
      contentType: "string"
    }), v(E));
  }
  function g(E) {
    return E === 62 ? (e.enter(a), e.consume(E), e.exit(a), e.exit(o), e.exit(r), t) : (e.enter(u), e.enter("chunkString", {
      contentType: "string"
    }), y(E));
  }
  function y(E) {
    return E === 62 ? (e.exit("chunkString"), e.exit(u), g(E)) : E === null || E === 60 || Oe(E) ? n(E) : (e.consume(E), E === 92 ? w : y);
  }
  function w(E) {
    return E === 60 || E === 62 || E === 92 ? (e.consume(E), y) : y(E);
  }
  function v(E) {
    return !h && (E === null || E === 41 || vt(E)) ? (e.exit("chunkString"), e.exit(u), e.exit(s), e.exit(r), t(E)) : h < f && E === 40 ? (e.consume(E), h++, v) : E === 41 ? (e.consume(E), h--, v) : E === null || E === 32 || E === 40 || Ip(E) ? n(E) : (e.consume(E), E === 92 ? S : v);
  }
  function S(E) {
    return E === 40 || E === 41 || E === 92 ? (e.consume(E), v) : v(E);
  }
}
function xj(e, t, n, r, o, a) {
  const s = this;
  let u = 0, c;
  return f;
  function f(y) {
    return e.enter(r), e.enter(o), e.consume(y), e.exit(o), e.enter(a), h;
  }
  function h(y) {
    return u > 999 || y === null || y === 91 || y === 93 && !c || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    y === 94 && !u && "_hiddenFootnoteSupport" in s.parser.constructs ? n(y) : y === 93 ? (e.exit(a), e.enter(o), e.consume(y), e.exit(o), e.exit(r), t) : Oe(y) ? (e.enter("lineEnding"), e.consume(y), e.exit("lineEnding"), h) : (e.enter("chunkString", {
      contentType: "string"
    }), p(y));
  }
  function p(y) {
    return y === null || y === 91 || y === 93 || Oe(y) || u++ > 999 ? (e.exit("chunkString"), h(y)) : (e.consume(y), c || (c = !We(y)), y === 92 ? g : p);
  }
  function g(y) {
    return y === 91 || y === 92 || y === 93 ? (e.consume(y), u++, p) : p(y);
  }
}
function wj(e, t, n, r, o, a) {
  let s;
  return u;
  function u(g) {
    return g === 34 || g === 39 || g === 40 ? (e.enter(r), e.enter(o), e.consume(g), e.exit(o), s = g === 40 ? 41 : g, c) : n(g);
  }
  function c(g) {
    return g === s ? (e.enter(o), e.consume(g), e.exit(o), e.exit(r), t) : (e.enter(a), f(g));
  }
  function f(g) {
    return g === s ? (e.exit(a), c(s)) : g === null ? n(g) : Oe(g) ? (e.enter("lineEnding"), e.consume(g), e.exit("lineEnding"), Qe(e, f, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), h(g));
  }
  function h(g) {
    return g === s || g === null || Oe(g) ? (e.exit("chunkString"), f(g)) : (e.consume(g), g === 92 ? p : h);
  }
  function p(g) {
    return g === s || g === 92 ? (e.consume(g), h) : h(g);
  }
}
function kc(e, t) {
  let n;
  return r;
  function r(o) {
    return Oe(o) ? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), n = !0, r) : We(o) ? Qe(e, r, n ? "linePrefix" : "lineSuffix")(o) : t(o);
  }
}
const Cue = {
  name: "definition",
  tokenize: Tue
}, kue = {
  partial: !0,
  tokenize: Aue
};
function Tue(e, t, n) {
  const r = this;
  let o;
  return a;
  function a(y) {
    return e.enter("definition"), s(y);
  }
  function s(y) {
    return xj.call(
      r,
      e,
      u,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(y);
  }
  function u(y) {
    return o = zr(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), y === 58 ? (e.enter("definitionMarker"), e.consume(y), e.exit("definitionMarker"), c) : n(y);
  }
  function c(y) {
    return vt(y) ? kc(e, f)(y) : f(y);
  }
  function f(y) {
    return bj(
      e,
      h,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(y);
  }
  function h(y) {
    return e.attempt(kue, p, p)(y);
  }
  function p(y) {
    return We(y) ? Qe(e, g, "whitespace")(y) : g(y);
  }
  function g(y) {
    return y === null || Oe(y) ? (e.exit("definition"), r.parser.defined.push(o), t(y)) : n(y);
  }
}
function Aue(e, t, n) {
  return r;
  function r(u) {
    return vt(u) ? kc(e, o)(u) : n(u);
  }
  function o(u) {
    return wj(e, a, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(u);
  }
  function a(u) {
    return We(u) ? Qe(e, s, "whitespace")(u) : s(u);
  }
  function s(u) {
    return u === null || Oe(u) ? t(u) : n(u);
  }
}
const Rue = {
  name: "hardBreakEscape",
  tokenize: Mue
};
function Mue(e, t, n) {
  return r;
  function r(a) {
    return e.enter("hardBreakEscape"), e.consume(a), o;
  }
  function o(a) {
    return Oe(a) ? (e.exit("hardBreakEscape"), t(a)) : n(a);
  }
}
const Oue = {
  name: "headingAtx",
  resolve: Nue,
  tokenize: Due
};
function Nue(e, t) {
  let n = e.length - 2, r = 3, o, a;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (o = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, a = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, sr(e, r, n - r + 1, [["enter", o, t], ["enter", a, t], ["exit", a, t], ["exit", o, t]])), e;
}
function Due(e, t, n) {
  let r = 0;
  return o;
  function o(h) {
    return e.enter("atxHeading"), a(h);
  }
  function a(h) {
    return e.enter("atxHeadingSequence"), s(h);
  }
  function s(h) {
    return h === 35 && r++ < 6 ? (e.consume(h), s) : h === null || vt(h) ? (e.exit("atxHeadingSequence"), u(h)) : n(h);
  }
  function u(h) {
    return h === 35 ? (e.enter("atxHeadingSequence"), c(h)) : h === null || Oe(h) ? (e.exit("atxHeading"), t(h)) : We(h) ? Qe(e, u, "whitespace")(h) : (e.enter("atxHeadingText"), f(h));
  }
  function c(h) {
    return h === 35 ? (e.consume(h), c) : (e.exit("atxHeadingSequence"), u(h));
  }
  function f(h) {
    return h === null || h === 35 || vt(h) ? (e.exit("atxHeadingText"), u(h)) : (e.consume(h), f);
  }
}
const jue = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], CR = ["pre", "script", "style", "textarea"], Pue = {
  concrete: !0,
  name: "htmlFlow",
  resolveTo: Lue,
  tokenize: Fue
}, Iue = {
  partial: !0,
  tokenize: Bue
}, zue = {
  partial: !0,
  tokenize: $ue
};
function Lue(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function Fue(e, t, n) {
  const r = this;
  let o, a, s, u, c;
  return f;
  function f(L) {
    return h(L);
  }
  function h(L) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(L), p;
  }
  function p(L) {
    return L === 33 ? (e.consume(L), g) : L === 47 ? (e.consume(L), a = !0, v) : L === 63 ? (e.consume(L), o = 3, r.interrupt ? t : O) : kn(L) ? (e.consume(L), s = String.fromCharCode(L), S) : n(L);
  }
  function g(L) {
    return L === 45 ? (e.consume(L), o = 2, y) : L === 91 ? (e.consume(L), o = 5, u = 0, w) : kn(L) ? (e.consume(L), o = 4, r.interrupt ? t : O) : n(L);
  }
  function y(L) {
    return L === 45 ? (e.consume(L), r.interrupt ? t : O) : n(L);
  }
  function w(L) {
    const te = "CDATA[";
    return L === te.charCodeAt(u++) ? (e.consume(L), u === te.length ? r.interrupt ? t : q : w) : n(L);
  }
  function v(L) {
    return kn(L) ? (e.consume(L), s = String.fromCharCode(L), S) : n(L);
  }
  function S(L) {
    if (L === null || L === 47 || L === 62 || vt(L)) {
      const te = L === 47, he = s.toLowerCase();
      return !te && !a && CR.includes(he) ? (o = 1, r.interrupt ? t(L) : q(L)) : jue.includes(s.toLowerCase()) ? (o = 6, te ? (e.consume(L), E) : r.interrupt ? t(L) : q(L)) : (o = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(L) : a ? A(L) : k(L));
    }
    return L === 45 || vn(L) ? (e.consume(L), s += String.fromCharCode(L), S) : n(L);
  }
  function E(L) {
    return L === 62 ? (e.consume(L), r.interrupt ? t : q) : n(L);
  }
  function A(L) {
    return We(L) ? (e.consume(L), A) : M(L);
  }
  function k(L) {
    return L === 47 ? (e.consume(L), M) : L === 58 || L === 95 || kn(L) ? (e.consume(L), T) : We(L) ? (e.consume(L), k) : M(L);
  }
  function T(L) {
    return L === 45 || L === 46 || L === 58 || L === 95 || vn(L) ? (e.consume(L), T) : R(L);
  }
  function R(L) {
    return L === 61 ? (e.consume(L), N) : We(L) ? (e.consume(L), R) : k(L);
  }
  function N(L) {
    return L === null || L === 60 || L === 61 || L === 62 || L === 96 ? n(L) : L === 34 || L === 39 ? (e.consume(L), c = L, j) : We(L) ? (e.consume(L), N) : z(L);
  }
  function j(L) {
    return L === c ? (e.consume(L), c = null, B) : L === null || Oe(L) ? n(L) : (e.consume(L), j);
  }
  function z(L) {
    return L === null || L === 34 || L === 39 || L === 47 || L === 60 || L === 61 || L === 62 || L === 96 || vt(L) ? R(L) : (e.consume(L), z);
  }
  function B(L) {
    return L === 47 || L === 62 || We(L) ? k(L) : n(L);
  }
  function M(L) {
    return L === 62 ? (e.consume(L), F) : n(L);
  }
  function F(L) {
    return L === null || Oe(L) ? q(L) : We(L) ? (e.consume(L), F) : n(L);
  }
  function q(L) {
    return L === 45 && o === 2 ? (e.consume(L), I) : L === 60 && o === 1 ? (e.consume(L), U) : L === 62 && o === 4 ? (e.consume(L), W) : L === 63 && o === 3 ? (e.consume(L), O) : L === 93 && o === 5 ? (e.consume(L), G) : Oe(L) && (o === 6 || o === 7) ? (e.exit("htmlFlowData"), e.check(Iue, Z, Y)(L)) : L === null || Oe(L) ? (e.exit("htmlFlowData"), Y(L)) : (e.consume(L), q);
  }
  function Y(L) {
    return e.check(zue, P, Z)(L);
  }
  function P(L) {
    return e.enter("lineEnding"), e.consume(L), e.exit("lineEnding"), V;
  }
  function V(L) {
    return L === null || Oe(L) ? Y(L) : (e.enter("htmlFlowData"), q(L));
  }
  function I(L) {
    return L === 45 ? (e.consume(L), O) : q(L);
  }
  function U(L) {
    return L === 47 ? (e.consume(L), s = "", H) : q(L);
  }
  function H(L) {
    if (L === 62) {
      const te = s.toLowerCase();
      return CR.includes(te) ? (e.consume(L), W) : q(L);
    }
    return kn(L) && s.length < 8 ? (e.consume(L), s += String.fromCharCode(L), H) : q(L);
  }
  function G(L) {
    return L === 93 ? (e.consume(L), O) : q(L);
  }
  function O(L) {
    return L === 62 ? (e.consume(L), W) : L === 45 && o === 2 ? (e.consume(L), O) : q(L);
  }
  function W(L) {
    return L === null || Oe(L) ? (e.exit("htmlFlowData"), Z(L)) : (e.consume(L), W);
  }
  function Z(L) {
    return e.exit("htmlFlow"), t(L);
  }
}
function $ue(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return Oe(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), a) : n(s);
  }
  function a(s) {
    return r.parser.lazy[r.now().line] ? n(s) : t(s);
  }
}
function Bue(e, t, n) {
  return r;
  function r(o) {
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), e.attempt(Af, t, n);
  }
}
const Hue = {
  name: "htmlText",
  tokenize: Vue
};
function Vue(e, t, n) {
  const r = this;
  let o, a, s;
  return u;
  function u(O) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(O), c;
  }
  function c(O) {
    return O === 33 ? (e.consume(O), f) : O === 47 ? (e.consume(O), R) : O === 63 ? (e.consume(O), k) : kn(O) ? (e.consume(O), z) : n(O);
  }
  function f(O) {
    return O === 45 ? (e.consume(O), h) : O === 91 ? (e.consume(O), a = 0, w) : kn(O) ? (e.consume(O), A) : n(O);
  }
  function h(O) {
    return O === 45 ? (e.consume(O), y) : n(O);
  }
  function p(O) {
    return O === null ? n(O) : O === 45 ? (e.consume(O), g) : Oe(O) ? (s = p, U(O)) : (e.consume(O), p);
  }
  function g(O) {
    return O === 45 ? (e.consume(O), y) : p(O);
  }
  function y(O) {
    return O === 62 ? I(O) : O === 45 ? g(O) : p(O);
  }
  function w(O) {
    const W = "CDATA[";
    return O === W.charCodeAt(a++) ? (e.consume(O), a === W.length ? v : w) : n(O);
  }
  function v(O) {
    return O === null ? n(O) : O === 93 ? (e.consume(O), S) : Oe(O) ? (s = v, U(O)) : (e.consume(O), v);
  }
  function S(O) {
    return O === 93 ? (e.consume(O), E) : v(O);
  }
  function E(O) {
    return O === 62 ? I(O) : O === 93 ? (e.consume(O), E) : v(O);
  }
  function A(O) {
    return O === null || O === 62 ? I(O) : Oe(O) ? (s = A, U(O)) : (e.consume(O), A);
  }
  function k(O) {
    return O === null ? n(O) : O === 63 ? (e.consume(O), T) : Oe(O) ? (s = k, U(O)) : (e.consume(O), k);
  }
  function T(O) {
    return O === 62 ? I(O) : k(O);
  }
  function R(O) {
    return kn(O) ? (e.consume(O), N) : n(O);
  }
  function N(O) {
    return O === 45 || vn(O) ? (e.consume(O), N) : j(O);
  }
  function j(O) {
    return Oe(O) ? (s = j, U(O)) : We(O) ? (e.consume(O), j) : I(O);
  }
  function z(O) {
    return O === 45 || vn(O) ? (e.consume(O), z) : O === 47 || O === 62 || vt(O) ? B(O) : n(O);
  }
  function B(O) {
    return O === 47 ? (e.consume(O), I) : O === 58 || O === 95 || kn(O) ? (e.consume(O), M) : Oe(O) ? (s = B, U(O)) : We(O) ? (e.consume(O), B) : I(O);
  }
  function M(O) {
    return O === 45 || O === 46 || O === 58 || O === 95 || vn(O) ? (e.consume(O), M) : F(O);
  }
  function F(O) {
    return O === 61 ? (e.consume(O), q) : Oe(O) ? (s = F, U(O)) : We(O) ? (e.consume(O), F) : B(O);
  }
  function q(O) {
    return O === null || O === 60 || O === 61 || O === 62 || O === 96 ? n(O) : O === 34 || O === 39 ? (e.consume(O), o = O, Y) : Oe(O) ? (s = q, U(O)) : We(O) ? (e.consume(O), q) : (e.consume(O), P);
  }
  function Y(O) {
    return O === o ? (e.consume(O), o = void 0, V) : O === null ? n(O) : Oe(O) ? (s = Y, U(O)) : (e.consume(O), Y);
  }
  function P(O) {
    return O === null || O === 34 || O === 39 || O === 60 || O === 61 || O === 96 ? n(O) : O === 47 || O === 62 || vt(O) ? B(O) : (e.consume(O), P);
  }
  function V(O) {
    return O === 47 || O === 62 || vt(O) ? B(O) : n(O);
  }
  function I(O) {
    return O === 62 ? (e.consume(O), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(O);
  }
  function U(O) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(O), e.exit("lineEnding"), H;
  }
  function H(O) {
    return We(O) ? Qe(e, G, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(O) : G(O);
  }
  function G(O) {
    return e.enter("htmlTextData"), s(O);
  }
}
const gw = {
  name: "labelEnd",
  resolveAll: Yue,
  resolveTo: Wue,
  tokenize: Xue
}, Uue = {
  tokenize: Kue
}, que = {
  tokenize: Zue
}, Gue = {
  tokenize: Que
};
function Yue(e) {
  let t = -1;
  const n = [];
  for (; ++t < e.length; ) {
    const r = e[t][1];
    if (n.push(e[t]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
      const o = r.type === "labelImage" ? 4 : 2;
      r.type = "data", t += o;
    }
  }
  return e.length !== n.length && sr(e, 0, e.length, n), e;
}
function Wue(e, t) {
  let n = e.length, r = 0, o, a, s, u;
  for (; n--; )
    if (o = e[n][1], a) {
      if (o.type === "link" || o.type === "labelLink" && o._inactive)
        break;
      e[n][0] === "enter" && o.type === "labelLink" && (o._inactive = !0);
    } else if (s) {
      if (e[n][0] === "enter" && (o.type === "labelImage" || o.type === "labelLink") && !o._balanced && (a = n, o.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else o.type === "labelEnd" && (s = n);
  const c = {
    type: e[a][1].type === "labelLink" ? "link" : "image",
    start: {
      ...e[a][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  }, f = {
    type: "label",
    start: {
      ...e[a][1].start
    },
    end: {
      ...e[s][1].end
    }
  }, h = {
    type: "labelText",
    start: {
      ...e[a + r + 2][1].end
    },
    end: {
      ...e[s - 2][1].start
    }
  };
  return u = [["enter", c, t], ["enter", f, t]], u = Sr(u, e.slice(a + 1, a + r + 3)), u = Sr(u, [["enter", h, t]]), u = Sr(u, Jm(t.parser.constructs.insideSpan.null, e.slice(a + r + 4, s - 3), t)), u = Sr(u, [["exit", h, t], e[s - 2], e[s - 1], ["exit", f, t]]), u = Sr(u, e.slice(s + 1)), u = Sr(u, [["exit", c, t]]), sr(e, a, e.length, u), e;
}
function Xue(e, t, n) {
  const r = this;
  let o = r.events.length, a, s;
  for (; o--; )
    if ((r.events[o][1].type === "labelImage" || r.events[o][1].type === "labelLink") && !r.events[o][1]._balanced) {
      a = r.events[o][1];
      break;
    }
  return u;
  function u(g) {
    return a ? a._inactive ? p(g) : (s = r.parser.defined.includes(zr(r.sliceSerialize({
      start: a.end,
      end: r.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(g), e.exit("labelMarker"), e.exit("labelEnd"), c) : n(g);
  }
  function c(g) {
    return g === 40 ? e.attempt(Uue, h, s ? h : p)(g) : g === 91 ? e.attempt(que, h, s ? f : p)(g) : s ? h(g) : p(g);
  }
  function f(g) {
    return e.attempt(Gue, h, p)(g);
  }
  function h(g) {
    return t(g);
  }
  function p(g) {
    return a._balanced = !0, n(g);
  }
}
function Kue(e, t, n) {
  return r;
  function r(p) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(p), e.exit("resourceMarker"), o;
  }
  function o(p) {
    return vt(p) ? kc(e, a)(p) : a(p);
  }
  function a(p) {
    return p === 41 ? h(p) : bj(e, s, u, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(p);
  }
  function s(p) {
    return vt(p) ? kc(e, c)(p) : h(p);
  }
  function u(p) {
    return n(p);
  }
  function c(p) {
    return p === 34 || p === 39 || p === 40 ? wj(e, f, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(p) : h(p);
  }
  function f(p) {
    return vt(p) ? kc(e, h)(p) : h(p);
  }
  function h(p) {
    return p === 41 ? (e.enter("resourceMarker"), e.consume(p), e.exit("resourceMarker"), e.exit("resource"), t) : n(p);
  }
}
function Zue(e, t, n) {
  const r = this;
  return o;
  function o(u) {
    return xj.call(r, e, a, s, "reference", "referenceMarker", "referenceString")(u);
  }
  function a(u) {
    return r.parser.defined.includes(zr(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(u) : n(u);
  }
  function s(u) {
    return n(u);
  }
}
function Que(e, t, n) {
  return r;
  function r(a) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), o;
  }
  function o(a) {
    return a === 93 ? (e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), e.exit("reference"), t) : n(a);
  }
}
const Jue = {
  name: "labelStartImage",
  resolveAll: gw.resolveAll,
  tokenize: ece
};
function ece(e, t, n) {
  const r = this;
  return o;
  function o(u) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(u), e.exit("labelImageMarker"), a;
  }
  function a(u) {
    return u === 91 ? (e.enter("labelMarker"), e.consume(u), e.exit("labelMarker"), e.exit("labelImage"), s) : n(u);
  }
  function s(u) {
    return u === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(u) : t(u);
  }
}
const tce = {
  name: "labelStartLink",
  resolveAll: gw.resolveAll,
  tokenize: nce
};
function nce(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelLink"), a;
  }
  function a(s) {
    return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s);
  }
}
const Cv = {
  name: "lineEnding",
  tokenize: rce
};
function rce(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), Qe(e, t, "linePrefix");
  }
}
const Kh = {
  name: "thematicBreak",
  tokenize: oce
};
function oce(e, t, n) {
  let r = 0, o;
  return a;
  function a(f) {
    return e.enter("thematicBreak"), s(f);
  }
  function s(f) {
    return o = f, u(f);
  }
  function u(f) {
    return f === o ? (e.enter("thematicBreakSequence"), c(f)) : r >= 3 && (f === null || Oe(f)) ? (e.exit("thematicBreak"), t(f)) : n(f);
  }
  function c(f) {
    return f === o ? (e.consume(f), r++, c) : (e.exit("thematicBreakSequence"), We(f) ? Qe(e, u, "whitespace")(f) : u(f));
  }
}
const In = {
  continuation: {
    tokenize: lce
  },
  exit: cce,
  name: "list",
  tokenize: sce
}, ice = {
  partial: !0,
  tokenize: fce
}, ace = {
  partial: !0,
  tokenize: uce
};
function sce(e, t, n) {
  const r = this, o = r.events[r.events.length - 1];
  let a = o && o[1].type === "linePrefix" ? o[2].sliceSerialize(o[1], !0).length : 0, s = 0;
  return u;
  function u(y) {
    const w = r.containerState.type || (y === 42 || y === 43 || y === 45 ? "listUnordered" : "listOrdered");
    if (w === "listUnordered" ? !r.containerState.marker || y === r.containerState.marker : t1(y)) {
      if (r.containerState.type || (r.containerState.type = w, e.enter(w, {
        _container: !0
      })), w === "listUnordered")
        return e.enter("listItemPrefix"), y === 42 || y === 45 ? e.check(Kh, n, f)(y) : f(y);
      if (!r.interrupt || y === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), c(y);
    }
    return n(y);
  }
  function c(y) {
    return t1(y) && ++s < 10 ? (e.consume(y), c) : (!r.interrupt || s < 2) && (r.containerState.marker ? y === r.containerState.marker : y === 41 || y === 46) ? (e.exit("listItemValue"), f(y)) : n(y);
  }
  function f(y) {
    return e.enter("listItemMarker"), e.consume(y), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || y, e.check(
      Af,
      // Cant be empty when interrupting.
      r.interrupt ? n : h,
      e.attempt(ice, g, p)
    );
  }
  function h(y) {
    return r.containerState.initialBlankLine = !0, a++, g(y);
  }
  function p(y) {
    return We(y) ? (e.enter("listItemPrefixWhitespace"), e.consume(y), e.exit("listItemPrefixWhitespace"), g) : n(y);
  }
  function g(y) {
    return r.containerState.size = a + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(y);
  }
}
function lce(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(Af, o, a);
  function o(u) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, Qe(e, t, "listItemIndent", r.containerState.size + 1)(u);
  }
  function a(u) {
    return r.containerState.furtherBlankLines || !We(u) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, s(u)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(ace, t, s)(u));
  }
  function s(u) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, Qe(e, e.attempt(In, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(u);
  }
}
function uce(e, t, n) {
  const r = this;
  return Qe(e, o, "listItemIndent", r.containerState.size + 1);
  function o(a) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "listItemIndent" && s[2].sliceSerialize(s[1], !0).length === r.containerState.size ? t(a) : n(a);
  }
}
function cce(e) {
  e.exit(this.containerState.type);
}
function fce(e, t, n) {
  const r = this;
  return Qe(e, o, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function o(a) {
    const s = r.events[r.events.length - 1];
    return !We(a) && s && s[1].type === "listItemPrefixWhitespace" ? t(a) : n(a);
  }
}
const kR = {
  name: "setextUnderline",
  resolveTo: dce,
  tokenize: hce
};
function dce(e, t) {
  let n = e.length, r, o, a;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (o = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !a && e[n][1].type === "definition" && (a = n);
  const s = {
    type: "setextHeading",
    start: {
      ...e[r][1].start
    },
    end: {
      ...e[e.length - 1][1].end
    }
  };
  return e[o][1].type = "setextHeadingText", a ? (e.splice(o, 0, ["enter", s, t]), e.splice(a + 1, 0, ["exit", e[r][1], t]), e[r][1].end = {
    ...e[a][1].end
  }) : e[r][1] = s, e.push(["exit", s, t]), e;
}
function hce(e, t, n) {
  const r = this;
  let o;
  return a;
  function a(f) {
    let h = r.events.length, p;
    for (; h--; )
      if (r.events[h][1].type !== "lineEnding" && r.events[h][1].type !== "linePrefix" && r.events[h][1].type !== "content") {
        p = r.events[h][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || p) ? (e.enter("setextHeadingLine"), o = f, s(f)) : n(f);
  }
  function s(f) {
    return e.enter("setextHeadingLineSequence"), u(f);
  }
  function u(f) {
    return f === o ? (e.consume(f), u) : (e.exit("setextHeadingLineSequence"), We(f) ? Qe(e, c, "lineSuffix")(f) : c(f));
  }
  function c(f) {
    return f === null || Oe(f) ? (e.exit("setextHeadingLine"), t(f)) : n(f);
  }
}
const pce = {
  tokenize: mce
};
function mce(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    Af,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(this.parser.constructs.flowInitial, o, Qe(e, e.attempt(this.parser.constructs.flow, o, e.attempt(xue, o)), "linePrefix"))
  );
  return n;
  function r(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(a), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function o(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const gce = {
  resolveAll: Sj()
}, yce = _j("string"), vce = _j("text");
function _j(e) {
  return {
    resolveAll: Sj(e === "text" ? bce : void 0),
    tokenize: t
  };
  function t(n) {
    const r = this, o = this.parser.constructs[e], a = n.attempt(o, s, u);
    return s;
    function s(h) {
      return f(h) ? a(h) : u(h);
    }
    function u(h) {
      if (h === null) {
        n.consume(h);
        return;
      }
      return n.enter("data"), n.consume(h), c;
    }
    function c(h) {
      return f(h) ? (n.exit("data"), a(h)) : (n.consume(h), c);
    }
    function f(h) {
      if (h === null)
        return !0;
      const p = o[h];
      let g = -1;
      if (p)
        for (; ++g < p.length; ) {
          const y = p[g];
          if (!y.previous || y.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function Sj(e) {
  return t;
  function t(n, r) {
    let o = -1, a;
    for (; ++o <= n.length; )
      a === void 0 ? n[o] && n[o][1].type === "data" && (a = o, o++) : (!n[o] || n[o][1].type !== "data") && (o !== a + 2 && (n[a][1].end = n[o - 1][1].end, n.splice(a + 2, o - a - 2), o = a + 2), a = void 0);
    return e ? e(n, r) : n;
  }
}
function bce(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], o = t.sliceStream(r);
      let a = o.length, s = -1, u = 0, c;
      for (; a--; ) {
        const f = o[a];
        if (typeof f == "string") {
          for (s = f.length; f.charCodeAt(s - 1) === 32; )
            u++, s--;
          if (s) break;
          s = -1;
        } else if (f === -2)
          c = !0, u++;
        else if (f !== -1) {
          a++;
          break;
        }
      }
      if (t._contentTypeTextTrailing && n === e.length && (u = 0), u) {
        const f = {
          type: n === e.length || c || u < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            _bufferIndex: a ? s : r.start._bufferIndex + s,
            _index: r.start._index + a,
            line: r.end.line,
            column: r.end.column - u,
            offset: r.end.offset - u
          },
          end: {
            ...r.end
          }
        };
        r.end = {
          ...f.start
        }, r.start.offset === r.end.offset ? Object.assign(r, f) : (e.splice(n, 0, ["enter", f, t], ["exit", f, t]), n += 2);
      }
      n++;
    }
  return e;
}
const xce = {
  42: In,
  43: In,
  45: In,
  48: In,
  49: In,
  50: In,
  51: In,
  52: In,
  53: In,
  54: In,
  55: In,
  56: In,
  57: In,
  62: mj
}, wce = {
  91: Cue
}, _ce = {
  [-2]: Ev,
  [-1]: Ev,
  32: Ev
}, Sce = {
  35: Oue,
  42: Kh,
  45: [kR, Kh],
  60: Pue,
  61: kR,
  95: Kh,
  96: ER,
  126: ER
}, Ece = {
  38: yj,
  92: gj
}, Cce = {
  [-5]: Cv,
  [-4]: Cv,
  [-3]: Cv,
  33: Jue,
  38: yj,
  42: n1,
  60: [tue, Hue],
  91: tce,
  92: [Rue, gj],
  93: gw,
  95: n1,
  96: pue
}, kce = {
  null: [n1, gce]
}, Tce = {
  null: [42, 95]
}, Ace = {
  null: []
}, Rce = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: Tce,
  contentInitial: wce,
  disable: Ace,
  document: xce,
  flow: Sce,
  flowInitial: _ce,
  insideSpan: kce,
  string: Ece,
  text: Cce
}, Symbol.toStringTag, { value: "Module" }));
function Mce(e, t, n) {
  let r = {
    _bufferIndex: -1,
    _index: 0,
    line: n && n.line || 1,
    column: n && n.column || 1,
    offset: n && n.offset || 0
  };
  const o = {}, a = [];
  let s = [], u = [];
  const c = {
    attempt: j(R),
    check: j(N),
    consume: A,
    enter: k,
    exit: T,
    interrupt: j(N, {
      interrupt: !0
    })
  }, f = {
    code: null,
    containerState: {},
    defineSkip: v,
    events: [],
    now: w,
    parser: e,
    previous: null,
    sliceSerialize: g,
    sliceStream: y,
    write: p
  };
  let h = t.tokenize.call(f, c);
  return t.resolveAll && a.push(t), f;
  function p(F) {
    return s = Sr(s, F), S(), s[s.length - 1] !== null ? [] : (z(t, 0), f.events = Jm(a, f.events, f), f.events);
  }
  function g(F, q) {
    return Nce(y(F), q);
  }
  function y(F) {
    return Oce(s, F);
  }
  function w() {
    const {
      _bufferIndex: F,
      _index: q,
      line: Y,
      column: P,
      offset: V
    } = r;
    return {
      _bufferIndex: F,
      _index: q,
      line: Y,
      column: P,
      offset: V
    };
  }
  function v(F) {
    o[F.line] = F.column, M();
  }
  function S() {
    let F;
    for (; r._index < s.length; ) {
      const q = s[r._index];
      if (typeof q == "string")
        for (F = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === F && r._bufferIndex < q.length; )
          E(q.charCodeAt(r._bufferIndex));
      else
        E(q);
    }
  }
  function E(F) {
    h = h(F);
  }
  function A(F) {
    Oe(F) ? (r.line++, r.column = 1, r.offset += F === -3 ? 2 : 1, M()) : F !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
    // strings.
    /** @type {string} */
    s[r._index].length && (r._bufferIndex = -1, r._index++)), f.previous = F;
  }
  function k(F, q) {
    const Y = q || {};
    return Y.type = F, Y.start = w(), f.events.push(["enter", Y, f]), u.push(Y), Y;
  }
  function T(F) {
    const q = u.pop();
    return q.end = w(), f.events.push(["exit", q, f]), q;
  }
  function R(F, q) {
    z(F, q.from);
  }
  function N(F, q) {
    q.restore();
  }
  function j(F, q) {
    return Y;
    function Y(P, V, I) {
      let U, H, G, O;
      return Array.isArray(P) ? (
        /* c8 ignore next 1 */
        Z(P)
      ) : "tokenize" in P ? (
        // Looks like a construct.
        Z([
          /** @type {Construct} */
          P
        ])
      ) : W(P);
      function W(oe) {
        return fe;
        function fe(ae) {
          const ye = ae !== null && oe[ae], Ne = ae !== null && oe.null, De = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(ye) ? ye : ye ? [ye] : [],
            ...Array.isArray(Ne) ? Ne : Ne ? [Ne] : []
          ];
          return Z(De)(ae);
        }
      }
      function Z(oe) {
        return U = oe, H = 0, oe.length === 0 ? I : L(oe[H]);
      }
      function L(oe) {
        return fe;
        function fe(ae) {
          return O = B(), G = oe, oe.partial || (f.currentConstruct = oe), oe.name && f.parser.constructs.disable.null.includes(oe.name) ? he() : oe.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            q ? Object.assign(Object.create(f), q) : f,
            c,
            te,
            he
          )(ae);
        }
      }
      function te(oe) {
        return F(G, O), V;
      }
      function he(oe) {
        return O.restore(), ++H < U.length ? L(U[H]) : I;
      }
    }
  }
  function z(F, q) {
    F.resolveAll && !a.includes(F) && a.push(F), F.resolve && sr(f.events, q, f.events.length - q, F.resolve(f.events.slice(q), f)), F.resolveTo && (f.events = F.resolveTo(f.events, f));
  }
  function B() {
    const F = w(), q = f.previous, Y = f.currentConstruct, P = f.events.length, V = Array.from(u);
    return {
      from: P,
      restore: I
    };
    function I() {
      r = F, f.previous = q, f.currentConstruct = Y, f.events.length = P, u = V, M();
    }
  }
  function M() {
    r.line in o && r.column < 2 && (r.column = o[r.line], r.offset += o[r.line] - 1);
  }
}
function Oce(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, o = t.end._index, a = t.end._bufferIndex;
  let s;
  if (n === o)
    s = [e[n].slice(r, a)];
  else {
    if (s = e.slice(n, o), r > -1) {
      const u = s[0];
      typeof u == "string" ? s[0] = u.slice(r) : s.shift();
    }
    a > 0 && s.push(e[o].slice(0, a));
  }
  return s;
}
function Nce(e, t) {
  let n = -1;
  const r = [];
  let o;
  for (; ++n < e.length; ) {
    const a = e[n];
    let s;
    if (typeof a == "string")
      s = a;
    else switch (a) {
      case -5: {
        s = "\r";
        break;
      }
      case -4: {
        s = `
`;
        break;
      }
      case -3: {
        s = `\r
`;
        break;
      }
      case -2: {
        s = t ? " " : "	";
        break;
      }
      case -1: {
        if (!t && o) continue;
        s = " ";
        break;
      }
      default:
        s = String.fromCharCode(a);
    }
    o = a === -2, r.push(s);
  }
  return r.join("");
}
function Dce(e) {
  const r = {
    constructs: (
      /** @type {FullNormalizedExtension} */
      hj([Rce, ...(e || {}).extensions || []])
    ),
    content: o(Wle),
    defined: [],
    document: o(Kle),
    flow: o(pce),
    lazy: {},
    string: o(yce),
    text: o(vce)
  };
  return r;
  function o(a) {
    return s;
    function s(u) {
      return Mce(r, a, u);
    }
  }
}
function jce(e) {
  for (; !vj(e); )
    ;
  return e;
}
const TR = /[\0\t\n\r]/g;
function Pce() {
  let e = 1, t = "", n = !0, r;
  return o;
  function o(a, s, u) {
    const c = [];
    let f, h, p, g, y;
    for (a = t + (typeof a == "string" ? a.toString() : new TextDecoder(s || void 0).decode(a)), p = 0, t = "", n && (a.charCodeAt(0) === 65279 && p++, n = void 0); p < a.length; ) {
      if (TR.lastIndex = p, f = TR.exec(a), g = f && f.index !== void 0 ? f.index : a.length, y = a.charCodeAt(g), !f) {
        t = a.slice(p);
        break;
      }
      if (y === 10 && p === g && r)
        c.push(-3), r = void 0;
      else
        switch (r && (c.push(-5), r = void 0), p < g && (c.push(a.slice(p, g)), e += g - p), y) {
          case 0: {
            c.push(65533), e++;
            break;
          }
          case 9: {
            for (h = Math.ceil(e / 4) * 4, c.push(-2); e++ < h; ) c.push(-1);
            break;
          }
          case 10: {
            c.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      p = g + 1;
    }
    return u && (r && c.push(-5), t && c.push(t), c.push(null)), c;
  }
}
const Ice = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function zce(e) {
  return e.replace(Ice, Lce);
}
function Lce(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const o = n.charCodeAt(1), a = o === 120 || o === 88;
    return pj(n.slice(a ? 2 : 1), a ? 16 : 10);
  }
  return mw(n) || e;
}
const Ej = {}.hasOwnProperty;
function Fce(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), $ce(n)(jce(Dce(n).document().write(Pce()(e, t, !0))));
}
function $ce(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: a(fr),
      autolinkProtocol: B,
      autolinkEmail: B,
      atxHeading: a(Xe),
      blockQuote: a(Ne),
      characterEscape: B,
      characterReference: B,
      codeFenced: a(De),
      codeFencedFenceInfo: s,
      codeFencedFenceMeta: s,
      codeIndented: a(De, s),
      codeText: a(we, s),
      codeTextData: B,
      data: B,
      codeFlowValue: B,
      definition: a(Ce),
      definitionDestinationString: s,
      definitionLabelString: s,
      definitionTitleString: s,
      emphasis: a(_e),
      hardBreakEscape: a(St),
      hardBreakTrailing: a(St),
      htmlFlow: a(ct, s),
      htmlFlowData: B,
      htmlText: a(ct, s),
      htmlTextData: B,
      image: a(cn),
      label: s,
      link: a(fr),
      listItem: a(qn),
      listItemValue: g,
      listOrdered: a(Un, p),
      listUnordered: a(Un),
      paragraph: a(ze),
      reference: L,
      referenceString: s,
      resourceDestinationString: s,
      resourceTitleString: s,
      setextHeading: a(Xe),
      strong: a(qr),
      thematicBreak: a(gi)
    },
    exit: {
      atxHeading: c(),
      atxHeadingSequence: R,
      autolink: c(),
      autolinkEmail: ye,
      autolinkProtocol: ae,
      blockQuote: c(),
      characterEscapeValue: M,
      characterReferenceMarkerHexadecimal: he,
      characterReferenceMarkerNumeric: he,
      characterReferenceValue: oe,
      characterReference: fe,
      codeFenced: c(S),
      codeFencedFence: v,
      codeFencedFenceInfo: y,
      codeFencedFenceMeta: w,
      codeFlowValue: M,
      codeIndented: c(E),
      codeText: c(V),
      codeTextData: M,
      data: M,
      definition: c(),
      definitionDestinationString: T,
      definitionLabelString: A,
      definitionTitleString: k,
      emphasis: c(),
      hardBreakEscape: c(q),
      hardBreakTrailing: c(q),
      htmlFlow: c(Y),
      htmlFlowData: M,
      htmlText: c(P),
      htmlTextData: M,
      image: c(U),
      label: G,
      labelText: H,
      lineEnding: F,
      link: c(I),
      listItem: c(),
      listOrdered: c(),
      listUnordered: c(),
      paragraph: c(),
      referenceString: te,
      resourceDestinationString: O,
      resourceTitleString: W,
      resource: Z,
      setextHeading: c(z),
      setextHeadingLineSequence: j,
      setextHeadingText: N,
      strong: c(),
      thematicBreak: c()
    }
  };
  Cj(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(se) {
    let pe = {
      type: "root",
      children: []
    };
    const ke = {
      stack: [pe],
      tokenStack: [],
      config: t,
      enter: u,
      exit: f,
      buffer: s,
      resume: h,
      data: n
    }, je = [];
    let et = -1;
    for (; ++et < se.length; )
      if (se[et][1].type === "listOrdered" || se[et][1].type === "listUnordered")
        if (se[et][0] === "enter")
          je.push(et);
        else {
          const _n = je.pop();
          et = o(se, _n, et);
        }
    for (et = -1; ++et < se.length; ) {
      const _n = t[se[et][0]];
      Ej.call(_n, se[et][1].type) && _n[se[et][1].type].call(Object.assign({
        sliceSerialize: se[et][2].sliceSerialize
      }, ke), se[et][1]);
    }
    if (ke.tokenStack.length > 0) {
      const _n = ke.tokenStack[ke.tokenStack.length - 1];
      (_n[1] || AR).call(ke, void 0, _n[0]);
    }
    for (pe.position = {
      start: qi(se.length > 0 ? se[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: qi(se.length > 0 ? se[se.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, et = -1; ++et < t.transforms.length; )
      pe = t.transforms[et](pe) || pe;
    return pe;
  }
  function o(se, pe, ke) {
    let je = pe - 1, et = -1, _n = !1, Ar, fn, dr, Sn;
    for (; ++je <= ke; ) {
      const $t = se[je];
      switch ($t[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          $t[0] === "enter" ? et++ : et--, Sn = void 0;
          break;
        }
        case "lineEndingBlank": {
          $t[0] === "enter" && (Ar && !Sn && !et && !dr && (dr = je), Sn = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          Sn = void 0;
      }
      if (!et && $t[0] === "enter" && $t[1].type === "listItemPrefix" || et === -1 && $t[0] === "exit" && ($t[1].type === "listUnordered" || $t[1].type === "listOrdered")) {
        if (Ar) {
          let Rn = je;
          for (fn = void 0; Rn--; ) {
            const Gn = se[Rn];
            if (Gn[1].type === "lineEnding" || Gn[1].type === "lineEndingBlank") {
              if (Gn[0] === "exit") continue;
              fn && (se[fn][1].type = "lineEndingBlank", _n = !0), Gn[1].type = "lineEnding", fn = Rn;
            } else if (!(Gn[1].type === "linePrefix" || Gn[1].type === "blockQuotePrefix" || Gn[1].type === "blockQuotePrefixWhitespace" || Gn[1].type === "blockQuoteMarker" || Gn[1].type === "listItemIndent")) break;
          }
          dr && (!fn || dr < fn) && (Ar._spread = !0), Ar.end = Object.assign({}, fn ? se[fn][1].start : $t[1].end), se.splice(fn || je, 0, ["exit", Ar, $t[2]]), je++, ke++;
        }
        if ($t[1].type === "listItemPrefix") {
          const Rn = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, $t[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          Ar = Rn, se.splice(je, 0, ["enter", Rn, $t[2]]), je++, ke++, dr = void 0, Sn = !0;
        }
      }
    }
    return se[pe][1]._spread = _n, ke;
  }
  function a(se, pe) {
    return ke;
    function ke(je) {
      u.call(this, se(je), je), pe && pe.call(this, je);
    }
  }
  function s() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function u(se, pe, ke) {
    this.stack[this.stack.length - 1].children.push(se), this.stack.push(se), this.tokenStack.push([pe, ke || void 0]), se.position = {
      start: qi(pe.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function c(se) {
    return pe;
    function pe(ke) {
      se && se.call(this, ke), f.call(this, ke);
    }
  }
  function f(se, pe) {
    const ke = this.stack.pop(), je = this.tokenStack.pop();
    if (je)
      je[0].type !== se.type && (pe ? pe.call(this, se, je[0]) : (je[1] || AR).call(this, se, je[0]));
    else throw new Error("Cannot close `" + se.type + "` (" + Cc({
      start: se.start,
      end: se.end
    }) + "): its not open");
    ke.position.end = qi(se.end);
  }
  function h() {
    return pw(this.stack.pop());
  }
  function p() {
    this.data.expectingFirstListItemValue = !0;
  }
  function g(se) {
    if (this.data.expectingFirstListItemValue) {
      const pe = this.stack[this.stack.length - 2];
      pe.start = Number.parseInt(this.sliceSerialize(se), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function y() {
    const se = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.lang = se;
  }
  function w() {
    const se = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.meta = se;
  }
  function v() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function S() {
    const se = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.value = se.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function E() {
    const se = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.value = se.replace(/(\r?\n|\r)$/g, "");
  }
  function A(se) {
    const pe = this.resume(), ke = this.stack[this.stack.length - 1];
    ke.label = pe, ke.identifier = zr(this.sliceSerialize(se)).toLowerCase();
  }
  function k() {
    const se = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.title = se;
  }
  function T() {
    const se = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.url = se;
  }
  function R(se) {
    const pe = this.stack[this.stack.length - 1];
    if (!pe.depth) {
      const ke = this.sliceSerialize(se).length;
      pe.depth = ke;
    }
  }
  function N() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function j(se) {
    const pe = this.stack[this.stack.length - 1];
    pe.depth = this.sliceSerialize(se).codePointAt(0) === 61 ? 1 : 2;
  }
  function z() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function B(se) {
    const ke = this.stack[this.stack.length - 1].children;
    let je = ke[ke.length - 1];
    (!je || je.type !== "text") && (je = ca(), je.position = {
      start: qi(se.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, ke.push(je)), this.stack.push(je);
  }
  function M(se) {
    const pe = this.stack.pop();
    pe.value += this.sliceSerialize(se), pe.position.end = qi(se.end);
  }
  function F(se) {
    const pe = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const ke = pe.children[pe.children.length - 1];
      ke.position.end = qi(se.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(pe.type) && (B.call(this, se), M.call(this, se));
  }
  function q() {
    this.data.atHardBreak = !0;
  }
  function Y() {
    const se = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.value = se;
  }
  function P() {
    const se = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.value = se;
  }
  function V() {
    const se = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.value = se;
  }
  function I() {
    const se = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const pe = this.data.referenceType || "shortcut";
      se.type += "Reference", se.referenceType = pe, delete se.url, delete se.title;
    } else
      delete se.identifier, delete se.label;
    this.data.referenceType = void 0;
  }
  function U() {
    const se = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const pe = this.data.referenceType || "shortcut";
      se.type += "Reference", se.referenceType = pe, delete se.url, delete se.title;
    } else
      delete se.identifier, delete se.label;
    this.data.referenceType = void 0;
  }
  function H(se) {
    const pe = this.sliceSerialize(se), ke = this.stack[this.stack.length - 2];
    ke.label = zce(pe), ke.identifier = zr(pe).toLowerCase();
  }
  function G() {
    const se = this.stack[this.stack.length - 1], pe = this.resume(), ke = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, ke.type === "link") {
      const je = se.children;
      ke.children = je;
    } else
      ke.alt = pe;
  }
  function O() {
    const se = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.url = se;
  }
  function W() {
    const se = this.resume(), pe = this.stack[this.stack.length - 1];
    pe.title = se;
  }
  function Z() {
    this.data.inReference = void 0;
  }
  function L() {
    this.data.referenceType = "collapsed";
  }
  function te(se) {
    const pe = this.resume(), ke = this.stack[this.stack.length - 1];
    ke.label = pe, ke.identifier = zr(this.sliceSerialize(se)).toLowerCase(), this.data.referenceType = "full";
  }
  function he(se) {
    this.data.characterReferenceType = se.type;
  }
  function oe(se) {
    const pe = this.sliceSerialize(se), ke = this.data.characterReferenceType;
    let je;
    ke ? (je = pj(pe, ke === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : je = mw(pe);
    const et = this.stack[this.stack.length - 1];
    et.value += je;
  }
  function fe(se) {
    const pe = this.stack.pop();
    pe.position.end = qi(se.end);
  }
  function ae(se) {
    M.call(this, se);
    const pe = this.stack[this.stack.length - 1];
    pe.url = this.sliceSerialize(se);
  }
  function ye(se) {
    M.call(this, se);
    const pe = this.stack[this.stack.length - 1];
    pe.url = "mailto:" + this.sliceSerialize(se);
  }
  function Ne() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function De() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function we() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function Ce() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function _e() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Xe() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function St() {
    return {
      type: "break"
    };
  }
  function ct() {
    return {
      type: "html",
      value: ""
    };
  }
  function cn() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function fr() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function Un(se) {
    return {
      type: "list",
      ordered: se.type === "listOrdered",
      start: null,
      spread: se._spread,
      children: []
    };
  }
  function qn(se) {
    return {
      type: "listItem",
      spread: se._spread,
      checked: null,
      children: []
    };
  }
  function ze() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function qr() {
    return {
      type: "strong",
      children: []
    };
  }
  function ca() {
    return {
      type: "text",
      value: ""
    };
  }
  function gi() {
    return {
      type: "thematicBreak"
    };
  }
}
function qi(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function Cj(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? Cj(e, r) : Bce(e, r);
  }
}
function Bce(e, t) {
  let n;
  for (n in t)
    if (Ej.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function AR(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + Cc({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + Cc({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + Cc({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function Hce(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return Fce(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function Vce(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Uce(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function qce(e, t) {
  const n = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let o = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (o.data = { meta: t.meta }), e.patch(t, o), o = e.applyData(t, o), o = { type: "element", tagName: "pre", properties: {}, children: [o] }, e.patch(t, o), o;
}
function Gce(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Yce(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Wce(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), o = Gl(r.toLowerCase()), a = e.footnoteOrder.indexOf(r);
  let s, u = e.footnoteCounts.get(r);
  u === void 0 ? (u = 0, e.footnoteOrder.push(r), s = e.footnoteOrder.length) : s = a + 1, u += 1, e.footnoteCounts.set(r, u);
  const c = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + o,
      id: n + "fnref-" + o + (u > 1 ? "-" + u : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(s) }]
  };
  e.patch(t, c);
  const f = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [c]
  };
  return e.patch(t, f), e.applyData(t, f);
}
function Xce(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Kce(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function kj(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const o = e.all(t), a = o[0];
  a && a.type === "text" ? a.value = "[" + a.value : o.unshift({ type: "text", value: "[" });
  const s = o[o.length - 1];
  return s && s.type === "text" ? s.value += r : o.push({ type: "text", value: r }), o;
}
function Zce(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return kj(e, t);
  const o = { src: Gl(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (o.title = r.title);
  const a = { type: "element", tagName: "img", properties: o, children: [] };
  return e.patch(t, a), e.applyData(t, a);
}
function Qce(e, t) {
  const n = { src: Gl(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function Jce(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function efe(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return kj(e, t);
  const o = { href: Gl(r.url || "") };
  r.title !== null && r.title !== void 0 && (o.title = r.title);
  const a = {
    type: "element",
    tagName: "a",
    properties: o,
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function tfe(e, t) {
  const n = { href: Gl(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function nfe(e, t, n) {
  const r = e.all(t), o = n ? rfe(n) : Tj(t), a = {}, s = [];
  if (typeof t.checked == "boolean") {
    const h = r[0];
    let p;
    h && h.type === "element" && h.tagName === "p" ? p = h : (p = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(p)), p.children.length > 0 && p.children.unshift({ type: "text", value: " " }), p.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), a.className = ["task-list-item"];
  }
  let u = -1;
  for (; ++u < r.length; ) {
    const h = r[u];
    (o || u !== 0 || h.type !== "element" || h.tagName !== "p") && s.push({ type: "text", value: `
` }), h.type === "element" && h.tagName === "p" && !o ? s.push(...h.children) : s.push(h);
  }
  const c = r[r.length - 1];
  c && (o || c.type !== "element" || c.tagName !== "p") && s.push({ type: "text", value: `
` });
  const f = { type: "element", tagName: "li", properties: a, children: s };
  return e.patch(t, f), e.applyData(t, f);
}
function rfe(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = Tj(n[r]);
  }
  return t;
}
function Tj(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function ofe(e, t) {
  const n = {}, r = e.all(t);
  let o = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++o < r.length; ) {
    const s = r[o];
    if (s.type === "element" && s.tagName === "li" && s.properties && Array.isArray(s.properties.className) && s.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const a = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function ife(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function afe(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function sfe(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function lfe(e, t) {
  const n = e.all(t), r = n.shift(), o = [];
  if (r) {
    const s = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], s), o.push(s);
  }
  if (n.length > 0) {
    const s = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, u = cw(t.children[1]), c = aj(t.children[t.children.length - 1]);
    u && c && (s.position = { start: u, end: c }), o.push(s);
  }
  const a = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(o, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function ufe(e, t, n) {
  const r = n ? n.children : void 0, a = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", s = n && n.type === "table" ? n.align : void 0, u = s ? s.length : t.children.length;
  let c = -1;
  const f = [];
  for (; ++c < u; ) {
    const p = t.children[c], g = {}, y = s ? s[c] : void 0;
    y && (g.align = y);
    let w = { type: "element", tagName: a, properties: g, children: [] };
    p && (w.children = e.all(p), e.patch(p, w), w = e.applyData(p, w)), f.push(w);
  }
  const h = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(f, !0)
  };
  return e.patch(t, h), e.applyData(t, h);
}
function cfe(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const RR = 9, MR = 32;
function ffe(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), o = 0;
  const a = [];
  for (; r; )
    a.push(
      OR(t.slice(o, r.index), o > 0, !0),
      r[0]
    ), o = r.index + r[0].length, r = n.exec(t);
  return a.push(OR(t.slice(o), o > 0, !1)), a.join("");
}
function OR(e, t, n) {
  let r = 0, o = e.length;
  if (t) {
    let a = e.codePointAt(r);
    for (; a === RR || a === MR; )
      r++, a = e.codePointAt(r);
  }
  if (n) {
    let a = e.codePointAt(o - 1);
    for (; a === RR || a === MR; )
      o--, a = e.codePointAt(o - 1);
  }
  return o > r ? e.slice(r, o) : "";
}
function dfe(e, t) {
  const n = { type: "text", value: ffe(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function hfe(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const pfe = {
  blockquote: Vce,
  break: Uce,
  code: qce,
  delete: Gce,
  emphasis: Yce,
  footnoteReference: Wce,
  heading: Xce,
  html: Kce,
  imageReference: Zce,
  image: Qce,
  inlineCode: Jce,
  linkReference: efe,
  link: tfe,
  listItem: nfe,
  list: ofe,
  paragraph: ife,
  // @ts-expect-error: root is different, but hard to type.
  root: afe,
  strong: sfe,
  table: lfe,
  tableCell: cfe,
  tableRow: ufe,
  text: dfe,
  thematicBreak: hfe,
  toml: Eh,
  yaml: Eh,
  definition: Eh,
  footnoteDefinition: Eh
};
function Eh() {
}
const Aj = -1, eg = 0, Tc = 1, zp = 2, yw = 3, vw = 4, bw = 5, xw = 6, Rj = 7, Mj = 8, NR = typeof self == "object" ? self : globalThis, mfe = (e, t) => {
  const n = (o, a) => (e.set(a, o), o), r = (o) => {
    if (e.has(o))
      return e.get(o);
    const [a, s] = t[o];
    switch (a) {
      case eg:
      case Aj:
        return n(s, o);
      case Tc: {
        const u = n([], o);
        for (const c of s)
          u.push(r(c));
        return u;
      }
      case zp: {
        const u = n({}, o);
        for (const [c, f] of s)
          u[r(c)] = r(f);
        return u;
      }
      case yw:
        return n(new Date(s), o);
      case vw: {
        const { source: u, flags: c } = s;
        return n(new RegExp(u, c), o);
      }
      case bw: {
        const u = n(/* @__PURE__ */ new Map(), o);
        for (const [c, f] of s)
          u.set(r(c), r(f));
        return u;
      }
      case xw: {
        const u = n(/* @__PURE__ */ new Set(), o);
        for (const c of s)
          u.add(r(c));
        return u;
      }
      case Rj: {
        const { name: u, message: c } = s;
        return n(new NR[u](c), o);
      }
      case Mj:
        return n(BigInt(s), o);
      case "BigInt":
        return n(Object(BigInt(s)), o);
      case "ArrayBuffer":
        return n(new Uint8Array(s).buffer, s);
      case "DataView": {
        const { buffer: u } = new Uint8Array(s);
        return n(new DataView(u), s);
      }
    }
    return n(new NR[a](s), o);
  };
  return r;
}, DR = (e) => mfe(/* @__PURE__ */ new Map(), e)(0), el = "", { toString: gfe } = {}, { keys: yfe } = Object, cc = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [eg, t];
  const n = gfe.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [Tc, el];
    case "Object":
      return [zp, el];
    case "Date":
      return [yw, el];
    case "RegExp":
      return [vw, el];
    case "Map":
      return [bw, el];
    case "Set":
      return [xw, el];
    case "DataView":
      return [Tc, n];
  }
  return n.includes("Array") ? [Tc, n] : n.includes("Error") ? [Rj, n] : [zp, n];
}, Ch = ([e, t]) => e === eg && (t === "function" || t === "symbol"), vfe = (e, t, n, r) => {
  const o = (s, u) => {
    const c = r.push(s) - 1;
    return n.set(u, c), c;
  }, a = (s) => {
    if (n.has(s))
      return n.get(s);
    let [u, c] = cc(s);
    switch (u) {
      case eg: {
        let h = s;
        switch (c) {
          case "bigint":
            u = Mj, h = s.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + c);
            h = null;
            break;
          case "undefined":
            return o([Aj], s);
        }
        return o([u, h], s);
      }
      case Tc: {
        if (c) {
          let g = s;
          return c === "DataView" ? g = new Uint8Array(s.buffer) : c === "ArrayBuffer" && (g = new Uint8Array(s)), o([c, [...g]], s);
        }
        const h = [], p = o([u, h], s);
        for (const g of s)
          h.push(a(g));
        return p;
      }
      case zp: {
        if (c)
          switch (c) {
            case "BigInt":
              return o([c, s.toString()], s);
            case "Boolean":
            case "Number":
            case "String":
              return o([c, s.valueOf()], s);
          }
        if (t && "toJSON" in s)
          return a(s.toJSON());
        const h = [], p = o([u, h], s);
        for (const g of yfe(s))
          (e || !Ch(cc(s[g]))) && h.push([a(g), a(s[g])]);
        return p;
      }
      case yw:
        return o([u, s.toISOString()], s);
      case vw: {
        const { source: h, flags: p } = s;
        return o([u, { source: h, flags: p }], s);
      }
      case bw: {
        const h = [], p = o([u, h], s);
        for (const [g, y] of s)
          (e || !(Ch(cc(g)) || Ch(cc(y)))) && h.push([a(g), a(y)]);
        return p;
      }
      case xw: {
        const h = [], p = o([u, h], s);
        for (const g of s)
          (e || !Ch(cc(g))) && h.push(a(g));
        return p;
      }
    }
    const { message: f } = s;
    return o([u, { name: c, message: f }], s);
  };
  return a;
}, jR = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return vfe(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, Lp = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? DR(jR(e, t)) : structuredClone(e)
) : (e, t) => DR(jR(e, t));
function bfe(e, t) {
  const n = [{ type: "text", value: "" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function xfe(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function wfe(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || bfe, r = e.options.footnoteBackLabel || xfe, o = e.options.footnoteLabel || "Footnotes", a = e.options.footnoteLabelTagName || "h2", s = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, u = [];
  let c = -1;
  for (; ++c < e.footnoteOrder.length; ) {
    const f = e.footnoteById.get(
      e.footnoteOrder[c]
    );
    if (!f)
      continue;
    const h = e.all(f), p = String(f.identifier).toUpperCase(), g = Gl(p.toLowerCase());
    let y = 0;
    const w = [], v = e.footnoteCounts.get(p);
    for (; v !== void 0 && ++y <= v; ) {
      w.length > 0 && w.push({ type: "text", value: " " });
      let A = typeof n == "string" ? n : n(c, y);
      typeof A == "string" && (A = { type: "text", value: A }), w.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + g + (y > 1 ? "-" + y : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(c, y),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(A) ? A : [A]
      });
    }
    const S = h[h.length - 1];
    if (S && S.type === "element" && S.tagName === "p") {
      const A = S.children[S.children.length - 1];
      A && A.type === "text" ? A.value += " " : S.children.push({ type: "text", value: " " }), S.children.push(...w);
    } else
      h.push(...w);
    const E = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + g },
      children: e.wrap(h, !0)
    };
    e.patch(f, E), u.push(E);
  }
  if (u.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: a,
          properties: {
            ...Lp(s),
            id: "footnote-label"
          },
          children: [{ type: "text", value: o }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(u, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const tg = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return Cfe;
    if (typeof e == "function")
      return ng(e);
    if (typeof e == "object")
      return Array.isArray(e) ? _fe(e) : Sfe(e);
    if (typeof e == "string")
      return Efe(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function _fe(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = tg(e[n]);
  return ng(r);
  function r(...o) {
    let a = -1;
    for (; ++a < t.length; )
      if (t[a].apply(this, o)) return !0;
    return !1;
  }
}
function Sfe(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return ng(n);
  function n(r) {
    const o = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let a;
    for (a in e)
      if (o[a] !== t[a]) return !1;
    return !0;
  }
}
function Efe(e) {
  return ng(t);
  function t(n) {
    return n && n.type === e;
  }
}
function ng(e) {
  return t;
  function t(n, r, o) {
    return !!(kfe(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      o || void 0
    ));
  }
}
function Cfe() {
  return !0;
}
function kfe(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const Oj = [], Tfe = !0, r1 = !1, Afe = "skip";
function Nj(e, t, n, r) {
  let o;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : o = t;
  const a = tg(o), s = r ? -1 : 1;
  u(e, void 0, [])();
  function u(c, f, h) {
    const p = (
      /** @type {Record<string, unknown>} */
      c && typeof c == "object" ? c : {}
    );
    if (typeof p.type == "string") {
      const y = (
        // `hast`
        typeof p.tagName == "string" ? p.tagName : (
          // `xast`
          typeof p.name == "string" ? p.name : void 0
        )
      );
      Object.defineProperty(g, "name", {
        value: "node (" + (c.type + (y ? "<" + y + ">" : "")) + ")"
      });
    }
    return g;
    function g() {
      let y = Oj, w, v, S;
      if ((!t || a(c, f, h[h.length - 1] || void 0)) && (y = Rfe(n(c, h)), y[0] === r1))
        return y;
      if ("children" in c && c.children) {
        const E = (
          /** @type {UnistParent} */
          c
        );
        if (E.children && y[0] !== Afe)
          for (v = (r ? E.children.length : -1) + s, S = h.concat(E); v > -1 && v < E.children.length; ) {
            const A = E.children[v];
            if (w = u(A, v, S)(), w[0] === r1)
              return w;
            v = typeof w[1] == "number" ? w[1] : v + s;
          }
      }
      return y;
    }
  }
}
function Rfe(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [Tfe, e] : e == null ? Oj : [e];
}
function ww(e, t, n, r) {
  let o, a, s;
  typeof t == "function" && typeof n != "function" ? (a = void 0, s = t, o = n) : (a = t, s = n, o = r), Nj(e, a, u, o);
  function u(c, f) {
    const h = f[f.length - 1], p = h ? h.children.indexOf(c) : void 0;
    return s(c, p, h);
  }
}
const o1 = {}.hasOwnProperty, Mfe = {};
function Ofe(e, t) {
  const n = t || Mfe, r = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), s = { ...pfe, ...n.handlers }, u = {
    all: f,
    applyData: Dfe,
    definitionById: r,
    footnoteById: o,
    footnoteCounts: a,
    footnoteOrder: [],
    handlers: s,
    one: c,
    options: n,
    patch: Nfe,
    wrap: Pfe
  };
  return ww(e, function(h) {
    if (h.type === "definition" || h.type === "footnoteDefinition") {
      const p = h.type === "definition" ? r : o, g = String(h.identifier).toUpperCase();
      p.has(g) || p.set(g, h);
    }
  }), u;
  function c(h, p) {
    const g = h.type, y = u.handlers[g];
    if (o1.call(u.handlers, g) && y)
      return y(u, h, p);
    if (u.options.passThrough && u.options.passThrough.includes(g)) {
      if ("children" in h) {
        const { children: v, ...S } = h, E = Lp(S);
        return E.children = u.all(h), E;
      }
      return Lp(h);
    }
    return (u.options.unknownHandler || jfe)(u, h, p);
  }
  function f(h) {
    const p = [];
    if ("children" in h) {
      const g = h.children;
      let y = -1;
      for (; ++y < g.length; ) {
        const w = u.one(g[y], h);
        if (w) {
          if (y && g[y - 1].type === "break" && (!Array.isArray(w) && w.type === "text" && (w.value = PR(w.value)), !Array.isArray(w) && w.type === "element")) {
            const v = w.children[0];
            v && v.type === "text" && (v.value = PR(v.value));
          }
          Array.isArray(w) ? p.push(...w) : p.push(w);
        }
      }
    }
    return p;
  }
}
function Nfe(e, t) {
  e.position && (t.position = xle(e));
}
function Dfe(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, o = e.data.hChildren, a = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const s = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: s };
      }
    n.type === "element" && a && Object.assign(n.properties, Lp(a)), "children" in n && n.children && o !== null && o !== void 0 && (n.children = o);
  }
  return n;
}
function jfe(e, t) {
  const n = t.data || {}, r = "value" in t && !(o1.call(n, "hProperties") || o1.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function Pfe(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function PR(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function IR(e, t) {
  const n = Ofe(e, t), r = n.one(e, void 0), o = wfe(n), a = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return o && a.children.push({ type: "text", value: `
` }, o), a;
}
function Ife(e, t) {
  return e && "run" in e ? async function(n, r) {
    const o = (
      /** @type {HastRoot} */
      IR(n, { file: r, ...t })
    );
    await e.run(o, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      IR(n, { file: r, ...e || t })
    );
  };
}
function zR(e) {
  if (e)
    throw e;
}
var kv, LR;
function zfe() {
  if (LR) return kv;
  LR = 1;
  var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString, n = Object.defineProperty, r = Object.getOwnPropertyDescriptor, o = function(f) {
    return typeof Array.isArray == "function" ? Array.isArray(f) : t.call(f) === "[object Array]";
  }, a = function(f) {
    if (!f || t.call(f) !== "[object Object]")
      return !1;
    var h = e.call(f, "constructor"), p = f.constructor && f.constructor.prototype && e.call(f.constructor.prototype, "isPrototypeOf");
    if (f.constructor && !h && !p)
      return !1;
    var g;
    for (g in f)
      ;
    return typeof g > "u" || e.call(f, g);
  }, s = function(f, h) {
    n && h.name === "__proto__" ? n(f, h.name, {
      enumerable: !0,
      configurable: !0,
      value: h.newValue,
      writable: !0
    }) : f[h.name] = h.newValue;
  }, u = function(f, h) {
    if (h === "__proto__")
      if (e.call(f, h)) {
        if (r)
          return r(f, h).value;
      } else return;
    return f[h];
  };
  return kv = function c() {
    var f, h, p, g, y, w, v = arguments[0], S = 1, E = arguments.length, A = !1;
    for (typeof v == "boolean" && (A = v, v = arguments[1] || {}, S = 2), (v == null || typeof v != "object" && typeof v != "function") && (v = {}); S < E; ++S)
      if (f = arguments[S], f != null)
        for (h in f)
          p = u(v, h), g = u(f, h), v !== g && (A && g && (a(g) || (y = o(g))) ? (y ? (y = !1, w = p && o(p) ? p : []) : w = p && a(p) ? p : {}, s(v, { name: h, newValue: c(A, w, g) })) : typeof g < "u" && s(v, { name: h, newValue: g }));
    return v;
  }, kv;
}
var Lfe = zfe();
const Tv = /* @__PURE__ */ jl(Lfe);
function i1(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function Ffe() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...o) {
    let a = -1;
    const s = o.pop();
    if (typeof s != "function")
      throw new TypeError("Expected function as last argument, not " + s);
    u(null, ...o);
    function u(c, ...f) {
      const h = e[++a];
      let p = -1;
      if (c) {
        s(c);
        return;
      }
      for (; ++p < o.length; )
        (f[p] === null || f[p] === void 0) && (f[p] = o[p]);
      o = f, h ? $fe(h, u)(...f) : s(null, ...f);
    }
  }
  function r(o) {
    if (typeof o != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + o
      );
    return e.push(o), t;
  }
}
function $fe(e, t) {
  let n;
  return r;
  function r(...s) {
    const u = e.length > s.length;
    let c;
    u && s.push(o);
    try {
      c = e.apply(this, s);
    } catch (f) {
      const h = (
        /** @type {Error} */
        f
      );
      if (u && n)
        throw h;
      return o(h);
    }
    u || (c && c.then && typeof c.then == "function" ? c.then(a, o) : c instanceof Error ? o(c) : a(c));
  }
  function o(s, ...u) {
    n || (n = !0, t(s, ...u));
  }
  function a(s) {
    o(null, s);
  }
}
const no = { basename: Bfe, dirname: Hfe, extname: Vfe, join: Ufe, sep: "/" };
function Bfe(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  Rf(e);
  let n = 0, r = -1, o = e.length, a;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; o--; )
      if (e.codePointAt(o) === 47) {
        if (a) {
          n = o + 1;
          break;
        }
      } else r < 0 && (a = !0, r = o + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let s = -1, u = t.length - 1;
  for (; o--; )
    if (e.codePointAt(o) === 47) {
      if (a) {
        n = o + 1;
        break;
      }
    } else
      s < 0 && (a = !0, s = o + 1), u > -1 && (e.codePointAt(o) === t.codePointAt(u--) ? u < 0 && (r = o) : (u = -1, r = s));
  return n === r ? r = s : r < 0 && (r = e.length), e.slice(n, r);
}
function Hfe(e) {
  if (Rf(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function Vfe(e) {
  Rf(e);
  let t = e.length, n = -1, r = 0, o = -1, a = 0, s;
  for (; t--; ) {
    const u = e.codePointAt(t);
    if (u === 47) {
      if (s) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (s = !0, n = t + 1), u === 46 ? o < 0 ? o = t : a !== 1 && (a = 1) : o > -1 && (a = -1);
  }
  return o < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  a === 0 || // The (right-most) trimmed path component is exactly `..`.
  a === 1 && o === n - 1 && o === r + 1 ? "" : e.slice(o, n);
}
function Ufe(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    Rf(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : qfe(n);
}
function qfe(e) {
  Rf(e);
  const t = e.codePointAt(0) === 47;
  let n = Gfe(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function Gfe(e, t) {
  let n = "", r = 0, o = -1, a = 0, s = -1, u, c;
  for (; ++s <= e.length; ) {
    if (s < e.length)
      u = e.codePointAt(s);
    else {
      if (u === 47)
        break;
      u = 47;
    }
    if (u === 47) {
      if (!(o === s - 1 || a === 1)) if (o !== s - 1 && a === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (c = n.lastIndexOf("/"), c !== n.length - 1) {
              c < 0 ? (n = "", r = 0) : (n = n.slice(0, c), r = n.length - 1 - n.lastIndexOf("/")), o = s, a = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, o = s, a = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(o + 1, s) : n = e.slice(o + 1, s), r = s - o - 1;
      o = s, a = 0;
    } else u === 46 && a > -1 ? a++ : a = -1;
  }
  return n;
}
function Rf(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const Yfe = { cwd: Wfe };
function Wfe() {
  return "/";
}
function a1(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function Xfe(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!a1(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return Kfe(e);
}
function Kfe(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const o = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw o.code = "ERR_INVALID_FILE_URL_PATH", o;
      }
    }
  return decodeURIComponent(t);
}
const Av = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class Dj {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? a1(t) ? n = { path: t } : typeof t == "string" || Zfe(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : Yfe.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < Av.length; ) {
      const a = Av[r];
      a in n && n[a] !== void 0 && n[a] !== null && (this[a] = a === "history" ? [...n[a]] : n[a]);
    }
    let o;
    for (o in n)
      Av.includes(o) || (this[o] = n[o]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? no.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    Mv(t, "basename"), Rv(t, "basename"), this.path = no.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? no.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    FR(this.basename, "dirname"), this.path = no.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? no.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (Rv(t, "extname"), FR(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = no.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    a1(t) && (t = Xfe(t)), Mv(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? no.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    Mv(t, "stem"), Rv(t, "stem"), this.path = no.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const o = this.message(t, n, r);
    throw o.fatal = !0, o;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const o = this.message(t, n, r);
    return o.fatal = void 0, o;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const o = new wn(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (o.name = this.path + ":" + o.name, o.file = this.path), o.fatal = !1, this.messages.push(o), o;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function Rv(e, t) {
  if (e && e.includes(no.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + no.sep + "`"
    );
}
function Mv(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function FR(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function Zfe(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const Qfe = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), o = r[e], a = function() {
      return o.apply(a, arguments);
    };
    return Object.setPrototypeOf(a, r), a;
  }
), Jfe = {}.hasOwnProperty;
class _w extends Qfe {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = Ffe();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new _w()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(Tv(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (Dv("data", this.frozen), this.namespace[t] = n, this) : Jfe.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (Dv("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const o = n.call(t, ...r);
      typeof o == "function" && this.transformers.use(o);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = kh(t), r = this.parser || this.Parser;
    return Ov("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), Ov("process", this.parser || this.Parser), Nv("process", this.compiler || this.Compiler), n ? o(void 0, n) : new Promise(o);
    function o(a, s) {
      const u = kh(t), c = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(u)
      );
      r.run(c, u, function(h, p, g) {
        if (h || !p || !g)
          return f(h);
        const y = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          p
        ), w = r.stringify(y, g);
        nde(w) ? g.value = w : g.result = w, f(
          h,
          /** @type {VFileWithOutput<CompileResult>} */
          g
        );
      });
      function f(h, p) {
        h || !p ? s(h) : a ? a(p) : n(void 0, p);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), Ov("processSync", this.parser || this.Parser), Nv("processSync", this.compiler || this.Compiler), this.process(t, o), BR("processSync", "process", n), r;
    function o(a, s) {
      n = !0, zR(a), r = s;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    $R(t), this.freeze();
    const o = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? a(void 0, r) : new Promise(a);
    function a(s, u) {
      const c = kh(n);
      o.run(t, c, f);
      function f(h, p, g) {
        const y = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          p || t
        );
        h ? u(h) : s ? s(y) : r(void 0, y, g);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, o;
    return this.run(t, n, a), BR("runSync", "run", r), o;
    function a(s, u) {
      zR(s), o = u, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = kh(n), o = this.compiler || this.Compiler;
    return Nv("stringify", o), $R(t), o(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, o = this.namespace;
    if (Dv("use", this.frozen), t != null) if (typeof t == "function")
      c(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? u(t) : s(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function a(f) {
      if (typeof f == "function")
        c(f, []);
      else if (typeof f == "object")
        if (Array.isArray(f)) {
          const [h, ...p] = (
            /** @type {PluginTuple<Array<unknown>>} */
            f
          );
          c(h, p);
        } else
          s(f);
      else
        throw new TypeError("Expected usable value, not `" + f + "`");
    }
    function s(f) {
      if (!("plugins" in f) && !("settings" in f))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      u(f.plugins), f.settings && (o.settings = Tv(!0, o.settings, f.settings));
    }
    function u(f) {
      let h = -1;
      if (f != null) if (Array.isArray(f))
        for (; ++h < f.length; ) {
          const p = f[h];
          a(p);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + f + "`");
    }
    function c(f, h) {
      let p = -1, g = -1;
      for (; ++p < r.length; )
        if (r[p][0] === f) {
          g = p;
          break;
        }
      if (g === -1)
        r.push([f, ...h]);
      else if (h.length > 0) {
        let [y, ...w] = h;
        const v = r[g][1];
        i1(v) && i1(y) && (y = Tv(!0, v, y)), r[g] = [f, y, ...w];
      }
    }
  }
}
const ede = new _w().freeze();
function Ov(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function Nv(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function Dv(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function $R(e) {
  if (!i1(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function BR(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function kh(e) {
  return tde(e) ? e : new Dj(e);
}
function tde(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function nde(e) {
  return typeof e == "string" || rde(e);
}
function rde(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const ode = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", HR = [], VR = { allowDangerousHtml: !0 }, ide = /^(https?|ircs?|mailto|xmpp)$/i, ade = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  { from: "className", id: "remove-classname" },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function sde(e) {
  const t = lde(e), n = ude(e);
  return cde(t.runSync(t.parse(n), n), e);
}
function lde(e) {
  const t = e.rehypePlugins || HR, n = e.remarkPlugins || HR, r = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...VR } : VR;
  return ede().use(Hce).use(n).use(Ife, r).use(t);
}
function ude(e) {
  const t = e.children || "", n = new Dj();
  return typeof t == "string" && (n.value = t), n;
}
function cde(e, t) {
  const n = t.allowedElements, r = t.allowElement, o = t.components, a = t.disallowedElements, s = t.skipHtml, u = t.unwrapDisallowed, c = t.urlTransform || fde;
  for (const h of ade)
    Object.hasOwn(t, h.from) && ("" + h.from + (h.to ? "use `" + h.to + "` instead" : "remove it") + ode + h.id, void 0);
  return ww(e, f), Cle(e, {
    Fragment: b.Fragment,
    components: o,
    ignoreInvalidStyle: !0,
    jsx: b.jsx,
    jsxs: b.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function f(h, p, g) {
    if (h.type === "raw" && g && typeof p == "number")
      return s ? g.children.splice(p, 1) : g.children[p] = { type: "text", value: h.value }, p;
    if (h.type === "element") {
      let y;
      for (y in Sv)
        if (Object.hasOwn(Sv, y) && Object.hasOwn(h.properties, y)) {
          const w = h.properties[y], v = Sv[y];
          (v === null || v.includes(h.tagName)) && (h.properties[y] = c(String(w || ""), y, h));
        }
    }
    if (h.type === "element") {
      let y = n ? !n.includes(h.tagName) : a ? a.includes(h.tagName) : !1;
      if (!y && r && typeof p == "number" && (y = !r(h, p, g)), y && g && typeof p == "number")
        return u && h.children ? g.children.splice(p, 1, ...h.children) : g.children.splice(p, 1), p;
    }
  }
}
function fde(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), o = e.indexOf("/");
  return (
    // If there is no protocol, its relative.
    t === -1 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    o !== -1 && t > o || n !== -1 && t > n || r !== -1 && t > r || // It is a protocol, it should be allowed.
    ide.test(e.slice(0, t)) ? e : ""
  );
}
function UR(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, o = n.indexOf(t);
  for (; o !== -1; )
    r++, o = n.indexOf(t, o + t.length);
  return r;
}
function dde(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function hde(e, t, n) {
  const o = tg((n || {}).ignore || []), a = pde(t);
  let s = -1;
  for (; ++s < a.length; )
    Nj(e, "text", u);
  function u(f, h) {
    let p = -1, g;
    for (; ++p < h.length; ) {
      const y = h[p], w = g ? g.children : void 0;
      if (o(
        y,
        w ? w.indexOf(y) : void 0,
        g
      ))
        return;
      g = y;
    }
    if (g)
      return c(f, h);
  }
  function c(f, h) {
    const p = h[h.length - 1], g = a[s][0], y = a[s][1];
    let w = 0;
    const S = p.children.indexOf(f);
    let E = !1, A = [];
    g.lastIndex = 0;
    let k = g.exec(f.value);
    for (; k; ) {
      const T = k.index, R = {
        index: k.index,
        input: k.input,
        stack: [...h, f]
      };
      let N = y(...k, R);
      if (typeof N == "string" && (N = N.length > 0 ? { type: "text", value: N } : void 0), N === !1 ? g.lastIndex = T + 1 : (w !== T && A.push({
        type: "text",
        value: f.value.slice(w, T)
      }), Array.isArray(N) ? A.push(...N) : N && A.push(N), w = T + k[0].length, E = !0), !g.global)
        break;
      k = g.exec(f.value);
    }
    return E ? (w < f.value.length && A.push({ type: "text", value: f.value.slice(w) }), p.children.splice(S, 1, ...A)) : A = [f], S + A.length;
  }
}
function pde(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const o = n[r];
    t.push([mde(o[0]), gde(o[1])]);
  }
  return t;
}
function mde(e) {
  return typeof e == "string" ? new RegExp(dde(e), "g") : e;
}
function gde(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const jv = "phrasing", Pv = ["autolink", "link", "image", "label"];
function yde() {
  return {
    transforms: [Ede],
    enter: {
      literalAutolink: bde,
      literalAutolinkEmail: Iv,
      literalAutolinkHttp: Iv,
      literalAutolinkWww: Iv
    },
    exit: {
      literalAutolink: Sde,
      literalAutolinkEmail: _de,
      literalAutolinkHttp: xde,
      literalAutolinkWww: wde
    }
  };
}
function vde() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: jv,
        notInConstruct: Pv
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: jv,
        notInConstruct: Pv
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: jv,
        notInConstruct: Pv
      }
    ]
  };
}
function bde(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function Iv(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function xde(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function wde(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function _de(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function Sde(e) {
  this.exit(e);
}
function Ede(e) {
  hde(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, Cde],
      [/(?<=^|\s|\p{P}|\p{S})([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/gu, kde]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function Cde(e, t, n, r, o) {
  let a = "";
  if (!jj(o) || (/^w/i.test(t) && (n = t + n, t = "", a = "http://"), !Tde(n)))
    return !1;
  const s = Ade(n + r);
  if (!s[0]) return !1;
  const u = {
    type: "link",
    title: null,
    url: a + t + s[0],
    children: [{ type: "text", value: t + s[0] }]
  };
  return s[1] ? [u, { type: "text", value: s[1] }] : u;
}
function kde(e, t, n, r) {
  return (
    // Not an expected previous character.
    !jj(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function Tde(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function Ade(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const o = UR(e, "(");
  let a = UR(e, ")");
  for (; r !== -1 && o > a; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), a++;
  return [e, n];
}
function jj(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || es(n) || Qm(n)) && // If its an email, the previous character should not be a slash.
  (!t || n !== 47);
}
Pj.peek = zde;
function Rde() {
  this.buffer();
}
function Mde(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function Ode() {
  this.buffer();
}
function Nde(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function Dde(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = zr(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function jde(e) {
  this.exit(e);
}
function Pde(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.identifier = zr(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function Ide(e) {
  this.exit(e);
}
function zde() {
  return "[";
}
function Pj(e, t, n, r) {
  const o = n.createTracker(r);
  let a = o.move("[^");
  const s = n.enter("footnoteReference"), u = n.enter("reference");
  return a += o.move(
    n.safe(n.associationId(e), { after: "]", before: a })
  ), u(), s(), a += o.move("]"), a;
}
function Lde() {
  return {
    enter: {
      gfmFootnoteCallString: Rde,
      gfmFootnoteCall: Mde,
      gfmFootnoteDefinitionLabelString: Ode,
      gfmFootnoteDefinition: Nde
    },
    exit: {
      gfmFootnoteCallString: Dde,
      gfmFootnoteCall: jde,
      gfmFootnoteDefinitionLabelString: Pde,
      gfmFootnoteDefinition: Ide
    }
  };
}
function Fde(e) {
  let t = !1;
  return e && e.firstLineBlank && (t = !0), {
    handlers: { footnoteDefinition: n, footnoteReference: Pj },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function n(r, o, a, s) {
    const u = a.createTracker(s);
    let c = u.move("[^");
    const f = a.enter("footnoteDefinition"), h = a.enter("label");
    return c += u.move(
      a.safe(a.associationId(r), { before: c, after: "]" })
    ), h(), c += u.move("]:"), r.children && r.children.length > 0 && (u.shift(4), c += u.move(
      (t ? `
` : " ") + a.indentLines(
        a.containerFlow(r, u.current()),
        t ? Ij : $de
      )
    )), f(), c;
  }
}
function $de(e, t, n) {
  return t === 0 ? e : Ij(e, t, n);
}
function Ij(e, t, n) {
  return (n ? "" : "    ") + e;
}
const Bde = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
zj.peek = Gde;
function Hde() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: Ude },
    exit: { strikethrough: qde }
  };
}
function Vde() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: Bde
      }
    ],
    handlers: { delete: zj }
  };
}
function Ude(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function qde(e) {
  this.exit(e);
}
function zj(e, t, n, r) {
  const o = n.createTracker(r), a = n.enter("strikethrough");
  let s = o.move("~~");
  return s += n.containerPhrasing(e, {
    ...o.current(),
    before: s,
    after: "~"
  }), s += o.move("~~"), a(), s;
}
function Gde() {
  return "~";
}
function Yde(e) {
  return e.length;
}
function Wde(e, t) {
  const n = t || {}, r = (n.align || []).concat(), o = n.stringLength || Yde, a = [], s = [], u = [], c = [];
  let f = 0, h = -1;
  for (; ++h < e.length; ) {
    const v = [], S = [];
    let E = -1;
    for (e[h].length > f && (f = e[h].length); ++E < e[h].length; ) {
      const A = Xde(e[h][E]);
      if (n.alignDelimiters !== !1) {
        const k = o(A);
        S[E] = k, (c[E] === void 0 || k > c[E]) && (c[E] = k);
      }
      v.push(A);
    }
    s[h] = v, u[h] = S;
  }
  let p = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++p < f; )
      a[p] = qR(r[p]);
  else {
    const v = qR(r);
    for (; ++p < f; )
      a[p] = v;
  }
  p = -1;
  const g = [], y = [];
  for (; ++p < f; ) {
    const v = a[p];
    let S = "", E = "";
    v === 99 ? (S = ":", E = ":") : v === 108 ? S = ":" : v === 114 && (E = ":");
    let A = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      c[p] - S.length - E.length
    );
    const k = S + "-".repeat(A) + E;
    n.alignDelimiters !== !1 && (A = S.length + A + E.length, A > c[p] && (c[p] = A), y[p] = A), g[p] = k;
  }
  s.splice(1, 0, g), u.splice(1, 0, y), h = -1;
  const w = [];
  for (; ++h < s.length; ) {
    const v = s[h], S = u[h];
    p = -1;
    const E = [];
    for (; ++p < f; ) {
      const A = v[p] || "";
      let k = "", T = "";
      if (n.alignDelimiters !== !1) {
        const R = c[p] - (S[p] || 0), N = a[p];
        N === 114 ? k = " ".repeat(R) : N === 99 ? R % 2 ? (k = " ".repeat(R / 2 + 0.5), T = " ".repeat(R / 2 - 0.5)) : (k = " ".repeat(R / 2), T = k) : T = " ".repeat(R);
      }
      n.delimiterStart !== !1 && !p && E.push("|"), n.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && A === "") && (n.delimiterStart !== !1 || p) && E.push(" "), n.alignDelimiters !== !1 && E.push(k), E.push(A), n.alignDelimiters !== !1 && E.push(T), n.padding !== !1 && E.push(" "), (n.delimiterEnd !== !1 || p !== f - 1) && E.push("|");
    }
    w.push(
      n.delimiterEnd === !1 ? E.join("").replace(/ +$/, "") : E.join("")
    );
  }
  return w.join(`
`);
}
function Xde(e) {
  return e == null ? "" : String(e);
}
function qR(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function Kde(e, t, n, r) {
  const o = n.enter("blockquote"), a = n.createTracker(r);
  a.move("> "), a.shift(2);
  const s = n.indentLines(
    n.containerFlow(e, a.current()),
    Zde
  );
  return o(), s;
}
function Zde(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function Qde(e, t) {
  return GR(e, t.inConstruct, !0) && !GR(e, t.notInConstruct, !1);
}
function GR(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function YR(e, t, n, r) {
  let o = -1;
  for (; ++o < n.unsafe.length; )
    if (n.unsafe[o].character === `
` && Qde(n.stack, n.unsafe[o]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function Jde(e, t) {
  const n = String(e);
  let r = n.indexOf(t), o = r, a = 0, s = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === o ? ++a > s && (s = a) : a = 1, o = r + t.length, r = n.indexOf(t, o);
  return s;
}
function ehe(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function the(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function nhe(e, t, n, r) {
  const o = the(n), a = e.value || "", s = o === "`" ? "GraveAccent" : "Tilde";
  if (ehe(e, n)) {
    const p = n.enter("codeIndented"), g = n.indentLines(a, rhe);
    return p(), g;
  }
  const u = n.createTracker(r), c = o.repeat(Math.max(Jde(a, o) + 1, 3)), f = n.enter("codeFenced");
  let h = u.move(c);
  if (e.lang) {
    const p = n.enter(`codeFencedLang${s}`);
    h += u.move(
      n.safe(e.lang, {
        before: h,
        after: " ",
        encode: ["`"],
        ...u.current()
      })
    ), p();
  }
  if (e.lang && e.meta) {
    const p = n.enter(`codeFencedMeta${s}`);
    h += u.move(" "), h += u.move(
      n.safe(e.meta, {
        before: h,
        after: `
`,
        encode: ["`"],
        ...u.current()
      })
    ), p();
  }
  return h += u.move(`
`), a && (h += u.move(a + `
`)), h += u.move(c), f(), h;
}
function rhe(e, t, n) {
  return (n ? "" : "    ") + e;
}
function Sw(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function ohe(e, t, n, r) {
  const o = Sw(n), a = o === '"' ? "Quote" : "Apostrophe", s = n.enter("definition");
  let u = n.enter("label");
  const c = n.createTracker(r);
  let f = c.move("[");
  return f += c.move(
    n.safe(n.associationId(e), {
      before: f,
      after: "]",
      ...c.current()
    })
  ), f += c.move("]: "), u(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (u = n.enter("destinationLiteral"), f += c.move("<"), f += c.move(
    n.safe(e.url, { before: f, after: ">", ...c.current() })
  ), f += c.move(">")) : (u = n.enter("destinationRaw"), f += c.move(
    n.safe(e.url, {
      before: f,
      after: e.title ? " " : `
`,
      ...c.current()
    })
  )), u(), e.title && (u = n.enter(`title${a}`), f += c.move(" " + o), f += c.move(
    n.safe(e.title, {
      before: f,
      after: o,
      ...c.current()
    })
  ), f += c.move(o), u()), s(), f;
}
function ihe(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function Jc(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function Fp(e, t, n) {
  const r = Dl(e), o = Dl(t);
  return r === void 0 ? o === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : o === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? o === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : o === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : o === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : o === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
Lj.peek = ahe;
function Lj(e, t, n, r) {
  const o = ihe(n), a = n.enter("emphasis"), s = n.createTracker(r), u = s.move(o);
  let c = s.move(
    n.containerPhrasing(e, {
      after: o,
      before: u,
      ...s.current()
    })
  );
  const f = c.charCodeAt(0), h = Fp(
    r.before.charCodeAt(r.before.length - 1),
    f,
    o
  );
  h.inside && (c = Jc(f) + c.slice(1));
  const p = c.charCodeAt(c.length - 1), g = Fp(r.after.charCodeAt(0), p, o);
  g.inside && (c = c.slice(0, -1) + Jc(p));
  const y = s.move(o);
  return a(), n.attentionEncodeSurroundingInfo = {
    after: g.outside,
    before: h.outside
  }, u + c + y;
}
function ahe(e, t, n) {
  return n.options.emphasis || "*";
}
function she(e, t) {
  let n = !1;
  return ww(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, r1;
  }), !!((!e.depth || e.depth < 3) && pw(e) && (t.options.setext || n));
}
function lhe(e, t, n, r) {
  const o = Math.max(Math.min(6, e.depth || 1), 1), a = n.createTracker(r);
  if (she(e, n)) {
    const h = n.enter("headingSetext"), p = n.enter("phrasing"), g = n.containerPhrasing(e, {
      ...a.current(),
      before: `
`,
      after: `
`
    });
    return p(), h(), g + `
` + (o === 1 ? "=" : "-").repeat(
      // The whole size
      g.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(g.lastIndexOf("\r"), g.lastIndexOf(`
`)) + 1)
    );
  }
  const s = "#".repeat(o), u = n.enter("headingAtx"), c = n.enter("phrasing");
  a.move(s + " ");
  let f = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...a.current()
  });
  return /^[\t ]/.test(f) && (f = Jc(f.charCodeAt(0)) + f.slice(1)), f = f ? s + " " + f : s, n.options.closeAtx && (f += " " + s), c(), u(), f;
}
Fj.peek = uhe;
function Fj(e) {
  return e.value || "";
}
function uhe() {
  return "<";
}
$j.peek = che;
function $j(e, t, n, r) {
  const o = Sw(n), a = o === '"' ? "Quote" : "Apostrophe", s = n.enter("image");
  let u = n.enter("label");
  const c = n.createTracker(r);
  let f = c.move("![");
  return f += c.move(
    n.safe(e.alt, { before: f, after: "]", ...c.current() })
  ), f += c.move("]("), u(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (u = n.enter("destinationLiteral"), f += c.move("<"), f += c.move(
    n.safe(e.url, { before: f, after: ">", ...c.current() })
  ), f += c.move(">")) : (u = n.enter("destinationRaw"), f += c.move(
    n.safe(e.url, {
      before: f,
      after: e.title ? " " : ")",
      ...c.current()
    })
  )), u(), e.title && (u = n.enter(`title${a}`), f += c.move(" " + o), f += c.move(
    n.safe(e.title, {
      before: f,
      after: o,
      ...c.current()
    })
  ), f += c.move(o), u()), f += c.move(")"), s(), f;
}
function che() {
  return "!";
}
Bj.peek = fhe;
function Bj(e, t, n, r) {
  const o = e.referenceType, a = n.enter("imageReference");
  let s = n.enter("label");
  const u = n.createTracker(r);
  let c = u.move("![");
  const f = n.safe(e.alt, {
    before: c,
    after: "]",
    ...u.current()
  });
  c += u.move(f + "]["), s();
  const h = n.stack;
  n.stack = [], s = n.enter("reference");
  const p = n.safe(n.associationId(e), {
    before: c,
    after: "]",
    ...u.current()
  });
  return s(), n.stack = h, a(), o === "full" || !f || f !== p ? c += u.move(p + "]") : o === "shortcut" ? c = c.slice(0, -1) : c += u.move("]"), c;
}
function fhe() {
  return "!";
}
Hj.peek = dhe;
function Hj(e, t, n) {
  let r = e.value || "", o = "`", a = -1;
  for (; new RegExp("(^|[^`])" + o + "([^`]|$)").test(r); )
    o += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++a < n.unsafe.length; ) {
    const s = n.unsafe[a], u = n.compilePattern(s);
    let c;
    if (s.atBreak)
      for (; c = u.exec(r); ) {
        let f = c.index;
        r.charCodeAt(f) === 10 && r.charCodeAt(f - 1) === 13 && f--, r = r.slice(0, f) + " " + r.slice(c.index + 1);
      }
  }
  return o + r + o;
}
function dhe() {
  return "`";
}
function Vj(e, t) {
  const n = pw(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
Uj.peek = hhe;
function Uj(e, t, n, r) {
  const o = Sw(n), a = o === '"' ? "Quote" : "Apostrophe", s = n.createTracker(r);
  let u, c;
  if (Vj(e, n)) {
    const h = n.stack;
    n.stack = [], u = n.enter("autolink");
    let p = s.move("<");
    return p += s.move(
      n.containerPhrasing(e, {
        before: p,
        after: ">",
        ...s.current()
      })
    ), p += s.move(">"), u(), n.stack = h, p;
  }
  u = n.enter("link"), c = n.enter("label");
  let f = s.move("[");
  return f += s.move(
    n.containerPhrasing(e, {
      before: f,
      after: "](",
      ...s.current()
    })
  ), f += s.move("]("), c(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (c = n.enter("destinationLiteral"), f += s.move("<"), f += s.move(
    n.safe(e.url, { before: f, after: ">", ...s.current() })
  ), f += s.move(">")) : (c = n.enter("destinationRaw"), f += s.move(
    n.safe(e.url, {
      before: f,
      after: e.title ? " " : ")",
      ...s.current()
    })
  )), c(), e.title && (c = n.enter(`title${a}`), f += s.move(" " + o), f += s.move(
    n.safe(e.title, {
      before: f,
      after: o,
      ...s.current()
    })
  ), f += s.move(o), c()), f += s.move(")"), u(), f;
}
function hhe(e, t, n) {
  return Vj(e, n) ? "<" : "[";
}
qj.peek = phe;
function qj(e, t, n, r) {
  const o = e.referenceType, a = n.enter("linkReference");
  let s = n.enter("label");
  const u = n.createTracker(r);
  let c = u.move("[");
  const f = n.containerPhrasing(e, {
    before: c,
    after: "]",
    ...u.current()
  });
  c += u.move(f + "]["), s();
  const h = n.stack;
  n.stack = [], s = n.enter("reference");
  const p = n.safe(n.associationId(e), {
    before: c,
    after: "]",
    ...u.current()
  });
  return s(), n.stack = h, a(), o === "full" || !f || f !== p ? c += u.move(p + "]") : o === "shortcut" ? c = c.slice(0, -1) : c += u.move("]"), c;
}
function phe() {
  return "[";
}
function Ew(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function mhe(e) {
  const t = Ew(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function ghe(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function Gj(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function yhe(e, t, n, r) {
  const o = n.enter("list"), a = n.bulletCurrent;
  let s = e.ordered ? ghe(n) : Ew(n);
  const u = e.ordered ? s === "." ? ")" : "." : mhe(n);
  let c = t && n.bulletLastUsed ? s === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const h = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (s === "*" || s === "-") && // Empty first list item:
      h && (!h.children || !h.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (c = !0), Gj(n) === s && h
    ) {
      let p = -1;
      for (; ++p < e.children.length; ) {
        const g = e.children[p];
        if (g && g.type === "listItem" && g.children && g.children[0] && g.children[0].type === "thematicBreak") {
          c = !0;
          break;
        }
      }
    }
  }
  c && (s = u), n.bulletCurrent = s;
  const f = n.containerFlow(e, r);
  return n.bulletLastUsed = s, n.bulletCurrent = a, o(), f;
}
function vhe(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function bhe(e, t, n, r) {
  const o = vhe(n);
  let a = n.bulletCurrent || Ew(n);
  t && t.type === "list" && t.ordered && (a = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + a);
  let s = a.length + 1;
  (o === "tab" || o === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (s = Math.ceil(s / 4) * 4);
  const u = n.createTracker(r);
  u.move(a + " ".repeat(s - a.length)), u.shift(s);
  const c = n.enter("listItem"), f = n.indentLines(
    n.containerFlow(e, u.current()),
    h
  );
  return c(), f;
  function h(p, g, y) {
    return g ? (y ? "" : " ".repeat(s)) + p : (y ? a : a + " ".repeat(s - a.length)) + p;
  }
}
function xhe(e, t, n, r) {
  const o = n.enter("paragraph"), a = n.enter("phrasing"), s = n.containerPhrasing(e, r);
  return a(), o(), s;
}
const whe = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  tg([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function _he(e, t, n, r) {
  return (e.children.some(function(s) {
    return whe(s);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function She(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
Yj.peek = Ehe;
function Yj(e, t, n, r) {
  const o = She(n), a = n.enter("strong"), s = n.createTracker(r), u = s.move(o + o);
  let c = s.move(
    n.containerPhrasing(e, {
      after: o,
      before: u,
      ...s.current()
    })
  );
  const f = c.charCodeAt(0), h = Fp(
    r.before.charCodeAt(r.before.length - 1),
    f,
    o
  );
  h.inside && (c = Jc(f) + c.slice(1));
  const p = c.charCodeAt(c.length - 1), g = Fp(r.after.charCodeAt(0), p, o);
  g.inside && (c = c.slice(0, -1) + Jc(p));
  const y = s.move(o + o);
  return a(), n.attentionEncodeSurroundingInfo = {
    after: g.outside,
    before: h.outside
  }, u + c + y;
}
function Ehe(e, t, n) {
  return n.options.strong || "*";
}
function Che(e, t, n, r) {
  return n.safe(e.value, r);
}
function khe(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function The(e, t, n) {
  const r = (Gj(n) + (n.options.ruleSpaces ? " " : "")).repeat(khe(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const Wj = {
  blockquote: Kde,
  break: YR,
  code: nhe,
  definition: ohe,
  emphasis: Lj,
  hardBreak: YR,
  heading: lhe,
  html: Fj,
  image: $j,
  imageReference: Bj,
  inlineCode: Hj,
  link: Uj,
  linkReference: qj,
  list: yhe,
  listItem: bhe,
  paragraph: xhe,
  root: _he,
  strong: Yj,
  text: Che,
  thematicBreak: The
};
function Ahe() {
  return {
    enter: {
      table: Rhe,
      tableData: WR,
      tableHeader: WR,
      tableRow: Ohe
    },
    exit: {
      codeText: Nhe,
      table: Mhe,
      tableData: zv,
      tableHeader: zv,
      tableRow: zv
    }
  };
}
function Rhe(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function Mhe(e) {
  this.exit(e), this.data.inTable = void 0;
}
function Ohe(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function zv(e) {
  this.exit(e);
}
function WR(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function Nhe(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, Dhe));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function Dhe(e, t) {
  return t === "|" ? t : e;
}
function jhe(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, o = t.stringLength, a = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: g,
      table: s,
      tableCell: c,
      tableRow: u
    }
  };
  function s(y, w, v, S) {
    return f(h(y, v, S), y.align);
  }
  function u(y, w, v, S) {
    const E = p(y, v, S), A = f([E]);
    return A.slice(0, A.indexOf(`
`));
  }
  function c(y, w, v, S) {
    const E = v.enter("tableCell"), A = v.enter("phrasing"), k = v.containerPhrasing(y, {
      ...S,
      before: a,
      after: a
    });
    return A(), E(), k;
  }
  function f(y, w) {
    return Wde(y, {
      align: w,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: o
    });
  }
  function h(y, w, v) {
    const S = y.children;
    let E = -1;
    const A = [], k = w.enter("table");
    for (; ++E < S.length; )
      A[E] = p(S[E], w, v);
    return k(), A;
  }
  function p(y, w, v) {
    const S = y.children;
    let E = -1;
    const A = [], k = w.enter("tableRow");
    for (; ++E < S.length; )
      A[E] = c(S[E], y, w, v);
    return k(), A;
  }
  function g(y, w, v) {
    let S = Wj.inlineCode(y, w, v);
    return v.stack.includes("tableCell") && (S = S.replace(/\|/g, "\\$&")), S;
  }
}
function Phe() {
  return {
    exit: {
      taskListCheckValueChecked: XR,
      taskListCheckValueUnchecked: XR,
      paragraph: zhe
    }
  };
}
function Ihe() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: Lhe }
  };
}
function XR(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function zhe(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const o = t.children;
      let a = -1, s;
      for (; ++a < o.length; ) {
        const u = o[a];
        if (u.type === "paragraph") {
          s = u;
          break;
        }
      }
      s === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function Lhe(e, t, n, r) {
  const o = e.children[0], a = typeof e.checked == "boolean" && o && o.type === "paragraph", s = "[" + (e.checked ? "x" : " ") + "] ", u = n.createTracker(r);
  a && u.move(s);
  let c = Wj.listItem(e, t, n, {
    ...r,
    ...u.current()
  });
  return a && (c = c.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, f)), c;
  function f(h) {
    return h + s;
  }
}
function Fhe() {
  return [
    yde(),
    Lde(),
    Hde(),
    Ahe(),
    Phe()
  ];
}
function $he(e) {
  return {
    extensions: [
      vde(),
      Fde(e),
      Vde(),
      jhe(e),
      Ihe()
    ]
  };
}
const Bhe = {
  tokenize: Yhe,
  partial: !0
}, Xj = {
  tokenize: Whe,
  partial: !0
}, Kj = {
  tokenize: Xhe,
  partial: !0
}, Zj = {
  tokenize: Khe,
  partial: !0
}, Hhe = {
  tokenize: Zhe,
  partial: !0
}, Qj = {
  name: "wwwAutolink",
  tokenize: qhe,
  previous: eP
}, Jj = {
  name: "protocolAutolink",
  tokenize: Ghe,
  previous: tP
}, mi = {
  name: "emailAutolink",
  tokenize: Uhe,
  previous: nP
}, Co = {};
function Vhe() {
  return {
    text: Co
  };
}
let Ma = 48;
for (; Ma < 123; )
  Co[Ma] = mi, Ma++, Ma === 58 ? Ma = 65 : Ma === 91 && (Ma = 97);
Co[43] = mi;
Co[45] = mi;
Co[46] = mi;
Co[95] = mi;
Co[72] = [mi, Jj];
Co[104] = [mi, Jj];
Co[87] = [mi, Qj];
Co[119] = [mi, Qj];
function Uhe(e, t, n) {
  const r = this;
  let o, a;
  return s;
  function s(p) {
    return !s1(p) || !nP.call(r, r.previous) || Cw(r.events) ? n(p) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), u(p));
  }
  function u(p) {
    return s1(p) ? (e.consume(p), u) : p === 64 ? (e.consume(p), c) : n(p);
  }
  function c(p) {
    return p === 46 ? e.check(Hhe, h, f)(p) : p === 45 || p === 95 || vn(p) ? (a = !0, e.consume(p), c) : h(p);
  }
  function f(p) {
    return e.consume(p), o = !0, c;
  }
  function h(p) {
    return a && o && kn(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(p)) : n(p);
  }
}
function qhe(e, t, n) {
  const r = this;
  return o;
  function o(s) {
    return s !== 87 && s !== 119 || !eP.call(r, r.previous) || Cw(r.events) ? n(s) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(Bhe, e.attempt(Xj, e.attempt(Kj, a), n), n)(s));
  }
  function a(s) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(s);
  }
}
function Ghe(e, t, n) {
  const r = this;
  let o = "", a = !1;
  return s;
  function s(p) {
    return (p === 72 || p === 104) && tP.call(r, r.previous) && !Cw(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), o += String.fromCodePoint(p), e.consume(p), u) : n(p);
  }
  function u(p) {
    if (kn(p) && o.length < 5)
      return o += String.fromCodePoint(p), e.consume(p), u;
    if (p === 58) {
      const g = o.toLowerCase();
      if (g === "http" || g === "https")
        return e.consume(p), c;
    }
    return n(p);
  }
  function c(p) {
    return p === 47 ? (e.consume(p), a ? f : (a = !0, c)) : n(p);
  }
  function f(p) {
    return p === null || Ip(p) || vt(p) || es(p) || Qm(p) ? n(p) : e.attempt(Xj, e.attempt(Kj, h), n)(p);
  }
  function h(p) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(p);
  }
}
function Yhe(e, t, n) {
  let r = 0;
  return o;
  function o(s) {
    return (s === 87 || s === 119) && r < 3 ? (r++, e.consume(s), o) : s === 46 && r === 3 ? (e.consume(s), a) : n(s);
  }
  function a(s) {
    return s === null ? n(s) : t(s);
  }
}
function Whe(e, t, n) {
  let r, o, a;
  return s;
  function s(f) {
    return f === 46 || f === 95 ? e.check(Zj, c, u)(f) : f === null || vt(f) || es(f) || f !== 45 && Qm(f) ? c(f) : (a = !0, e.consume(f), s);
  }
  function u(f) {
    return f === 95 ? r = !0 : (o = r, r = void 0), e.consume(f), s;
  }
  function c(f) {
    return o || r || !a ? n(f) : t(f);
  }
}
function Xhe(e, t) {
  let n = 0, r = 0;
  return o;
  function o(s) {
    return s === 40 ? (n++, e.consume(s), o) : s === 41 && r < n ? a(s) : s === 33 || s === 34 || s === 38 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 60 || s === 63 || s === 93 || s === 95 || s === 126 ? e.check(Zj, t, a)(s) : s === null || vt(s) || es(s) ? t(s) : (e.consume(s), o);
  }
  function a(s) {
    return s === 41 && r++, e.consume(s), o;
  }
}
function Khe(e, t, n) {
  return r;
  function r(u) {
    return u === 33 || u === 34 || u === 39 || u === 41 || u === 42 || u === 44 || u === 46 || u === 58 || u === 59 || u === 63 || u === 95 || u === 126 ? (e.consume(u), r) : u === 38 ? (e.consume(u), a) : u === 93 ? (e.consume(u), o) : (
      // `<` is an end.
      u === 60 || // So is whitespace.
      u === null || vt(u) || es(u) ? t(u) : n(u)
    );
  }
  function o(u) {
    return u === null || u === 40 || u === 91 || vt(u) || es(u) ? t(u) : r(u);
  }
  function a(u) {
    return kn(u) ? s(u) : n(u);
  }
  function s(u) {
    return u === 59 ? (e.consume(u), r) : kn(u) ? (e.consume(u), s) : n(u);
  }
}
function Zhe(e, t, n) {
  return r;
  function r(a) {
    return e.consume(a), o;
  }
  function o(a) {
    return vn(a) ? n(a) : t(a);
  }
}
function eP(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || vt(e);
}
function tP(e) {
  return !kn(e);
}
function nP(e) {
  return !(e === 47 || s1(e));
}
function s1(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || vn(e);
}
function Cw(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
const Qhe = {
  tokenize: ape,
  partial: !0
};
function Jhe() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: rpe,
        continuation: {
          tokenize: ope
        },
        exit: ipe
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: npe
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: epe,
        resolveTo: tpe
      }
    }
  };
}
function epe(e, t, n) {
  const r = this;
  let o = r.events.length;
  const a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let s;
  for (; o--; ) {
    const c = r.events[o][1];
    if (c.type === "labelImage") {
      s = c;
      break;
    }
    if (c.type === "gfmFootnoteCall" || c.type === "labelLink" || c.type === "label" || c.type === "image" || c.type === "link")
      break;
  }
  return u;
  function u(c) {
    if (!s || !s._balanced)
      return n(c);
    const f = zr(r.sliceSerialize({
      start: s.end,
      end: r.now()
    }));
    return f.codePointAt(0) !== 94 || !a.includes(f.slice(1)) ? n(c) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(c), e.exit("gfmFootnoteCallLabelMarker"), t(c));
  }
}
function tpe(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, o = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  o.end.column++, o.end.offset++, o.end._bufferIndex++;
  const a = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, o.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, s = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, a.start),
    end: Object.assign({}, a.end)
  }, u = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", o, t],
    ["exit", o, t],
    // Everything in between.
    ["enter", a, t],
    ["enter", s, t],
    ["exit", s, t],
    ["exit", a, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...u), e;
}
function npe(e, t, n) {
  const r = this, o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a = 0, s;
  return u;
  function u(p) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), c;
  }
  function c(p) {
    return p !== 94 ? n(p) : (e.enter("gfmFootnoteCallMarker"), e.consume(p), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", f);
  }
  function f(p) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      p === 93 && !s || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      p === null || p === 91 || vt(p)
    )
      return n(p);
    if (p === 93) {
      e.exit("chunkString");
      const g = e.exit("gfmFootnoteCallString");
      return o.includes(zr(r.sliceSerialize(g))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(p);
    }
    return vt(p) || (s = !0), a++, e.consume(p), p === 92 ? h : f;
  }
  function h(p) {
    return p === 91 || p === 92 || p === 93 ? (e.consume(p), a++, f) : f(p);
  }
}
function rpe(e, t, n) {
  const r = this, o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a, s = 0, u;
  return c;
  function c(w) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(w), e.exit("gfmFootnoteDefinitionLabelMarker"), f;
  }
  function f(w) {
    return w === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(w), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", h) : n(w);
  }
  function h(w) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      w === 93 && !u || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      w === null || w === 91 || vt(w)
    )
      return n(w);
    if (w === 93) {
      e.exit("chunkString");
      const v = e.exit("gfmFootnoteDefinitionLabelString");
      return a = zr(r.sliceSerialize(v)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(w), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), g;
    }
    return vt(w) || (u = !0), s++, e.consume(w), w === 92 ? p : h;
  }
  function p(w) {
    return w === 91 || w === 92 || w === 93 ? (e.consume(w), s++, h) : h(w);
  }
  function g(w) {
    return w === 58 ? (e.enter("definitionMarker"), e.consume(w), e.exit("definitionMarker"), o.includes(a) || o.push(a), Qe(e, y, "gfmFootnoteDefinitionWhitespace")) : n(w);
  }
  function y(w) {
    return t(w);
  }
}
function ope(e, t, n) {
  return e.check(Af, t, e.attempt(Qhe, t, n));
}
function ipe(e) {
  e.exit("gfmFootnoteDefinition");
}
function ape(e, t, n) {
  const r = this;
  return Qe(e, o, "gfmFootnoteDefinitionIndent", 5);
  function o(a) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "gfmFootnoteDefinitionIndent" && s[2].sliceSerialize(s[1], !0).length === 4 ? t(a) : n(a);
  }
}
function spe(e) {
  let n = (e || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: a,
    resolveAll: o
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function o(s, u) {
    let c = -1;
    for (; ++c < s.length; )
      if (s[c][0] === "enter" && s[c][1].type === "strikethroughSequenceTemporary" && s[c][1]._close) {
        let f = c;
        for (; f--; )
          if (s[f][0] === "exit" && s[f][1].type === "strikethroughSequenceTemporary" && s[f][1]._open && // If the sizes are the same:
          s[c][1].end.offset - s[c][1].start.offset === s[f][1].end.offset - s[f][1].start.offset) {
            s[c][1].type = "strikethroughSequence", s[f][1].type = "strikethroughSequence";
            const h = {
              type: "strikethrough",
              start: Object.assign({}, s[f][1].start),
              end: Object.assign({}, s[c][1].end)
            }, p = {
              type: "strikethroughText",
              start: Object.assign({}, s[f][1].end),
              end: Object.assign({}, s[c][1].start)
            }, g = [["enter", h, u], ["enter", s[f][1], u], ["exit", s[f][1], u], ["enter", p, u]], y = u.parser.constructs.insideSpan.null;
            y && sr(g, g.length, 0, Jm(y, s.slice(f + 1, c), u)), sr(g, g.length, 0, [["exit", p, u], ["enter", s[c][1], u], ["exit", s[c][1], u], ["exit", h, u]]), sr(s, f - 1, c - f + 3, g), c = f + g.length - 2;
            break;
          }
      }
    for (c = -1; ++c < s.length; )
      s[c][1].type === "strikethroughSequenceTemporary" && (s[c][1].type = "data");
    return s;
  }
  function a(s, u, c) {
    const f = this.previous, h = this.events;
    let p = 0;
    return g;
    function g(w) {
      return f === 126 && h[h.length - 1][1].type !== "characterEscape" ? c(w) : (s.enter("strikethroughSequenceTemporary"), y(w));
    }
    function y(w) {
      const v = Dl(f);
      if (w === 126)
        return p > 1 ? c(w) : (s.consume(w), p++, y);
      if (p < 2 && !n) return c(w);
      const S = s.exit("strikethroughSequenceTemporary"), E = Dl(w);
      return S._open = !E || E === 2 && !!v, S._close = !v || v === 2 && !!E, u(w);
    }
  }
}
class lpe {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    upe(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(a, s) {
      return a[0] - s[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
    r.push(t.slice()), t.length = 0;
    let o = r.pop();
    for (; o; ) {
      for (const a of o)
        t.push(a);
      o = r.pop();
    }
    this.map.length = 0;
  }
}
function upe(e, t, n, r) {
  let o = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; o < e.map.length; ) {
      if (e.map[o][0] === t) {
        e.map[o][1] += n, e.map[o][2].push(...r);
        return;
      }
      o += 1;
    }
    e.map.push([t, n, r]);
  }
}
function cpe(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const o = e[t];
    if (n) {
      if (o[0] === "enter")
        o[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (o[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const a = r.length - 1;
          r[a] = r[a] === "left" ? "center" : "right";
        }
      } else if (o[1].type === "tableDelimiterRow")
        break;
    } else o[0] === "enter" && o[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function fpe() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: dpe,
        resolveAll: hpe
      }
    }
  };
}
function dpe(e, t, n) {
  const r = this;
  let o = 0, a = 0, s;
  return u;
  function u(M) {
    let F = r.events.length - 1;
    for (; F > -1; ) {
      const P = r.events[F][1].type;
      if (P === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      P === "linePrefix") F--;
      else break;
    }
    const q = F > -1 ? r.events[F][1].type : null, Y = q === "tableHead" || q === "tableRow" ? N : c;
    return Y === N && r.parser.lazy[r.now().line] ? n(M) : Y(M);
  }
  function c(M) {
    return e.enter("tableHead"), e.enter("tableRow"), f(M);
  }
  function f(M) {
    return M === 124 || (s = !0, a += 1), h(M);
  }
  function h(M) {
    return M === null ? n(M) : Oe(M) ? a > 1 ? (a = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(M), e.exit("lineEnding"), y) : n(M) : We(M) ? Qe(e, h, "whitespace")(M) : (a += 1, s && (s = !1, o += 1), M === 124 ? (e.enter("tableCellDivider"), e.consume(M), e.exit("tableCellDivider"), s = !0, h) : (e.enter("data"), p(M)));
  }
  function p(M) {
    return M === null || M === 124 || vt(M) ? (e.exit("data"), h(M)) : (e.consume(M), M === 92 ? g : p);
  }
  function g(M) {
    return M === 92 || M === 124 ? (e.consume(M), p) : p(M);
  }
  function y(M) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(M) : (e.enter("tableDelimiterRow"), s = !1, We(M) ? Qe(e, w, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(M) : w(M));
  }
  function w(M) {
    return M === 45 || M === 58 ? S(M) : M === 124 ? (s = !0, e.enter("tableCellDivider"), e.consume(M), e.exit("tableCellDivider"), v) : R(M);
  }
  function v(M) {
    return We(M) ? Qe(e, S, "whitespace")(M) : S(M);
  }
  function S(M) {
    return M === 58 ? (a += 1, s = !0, e.enter("tableDelimiterMarker"), e.consume(M), e.exit("tableDelimiterMarker"), E) : M === 45 ? (a += 1, E(M)) : M === null || Oe(M) ? T(M) : R(M);
  }
  function E(M) {
    return M === 45 ? (e.enter("tableDelimiterFiller"), A(M)) : R(M);
  }
  function A(M) {
    return M === 45 ? (e.consume(M), A) : M === 58 ? (s = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(M), e.exit("tableDelimiterMarker"), k) : (e.exit("tableDelimiterFiller"), k(M));
  }
  function k(M) {
    return We(M) ? Qe(e, T, "whitespace")(M) : T(M);
  }
  function T(M) {
    return M === 124 ? w(M) : M === null || Oe(M) ? !s || o !== a ? R(M) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(M)) : R(M);
  }
  function R(M) {
    return n(M);
  }
  function N(M) {
    return e.enter("tableRow"), j(M);
  }
  function j(M) {
    return M === 124 ? (e.enter("tableCellDivider"), e.consume(M), e.exit("tableCellDivider"), j) : M === null || Oe(M) ? (e.exit("tableRow"), t(M)) : We(M) ? Qe(e, j, "whitespace")(M) : (e.enter("data"), z(M));
  }
  function z(M) {
    return M === null || M === 124 || vt(M) ? (e.exit("data"), j(M)) : (e.consume(M), M === 92 ? B : z);
  }
  function B(M) {
    return M === 92 || M === 124 ? (e.consume(M), z) : z(M);
  }
}
function hpe(e, t) {
  let n = -1, r = !0, o = 0, a = [0, 0, 0, 0], s = [0, 0, 0, 0], u = !1, c = 0, f, h, p;
  const g = new lpe();
  for (; ++n < e.length; ) {
    const y = e[n], w = y[1];
    y[0] === "enter" ? w.type === "tableHead" ? (u = !1, c !== 0 && (KR(g, t, c, f, h), h = void 0, c = 0), f = {
      type: "table",
      start: Object.assign({}, w.start),
      // Note: correct end is set later.
      end: Object.assign({}, w.end)
    }, g.add(n, 0, [["enter", f, t]])) : w.type === "tableRow" || w.type === "tableDelimiterRow" ? (r = !0, p = void 0, a = [0, 0, 0, 0], s = [0, n + 1, 0, 0], u && (u = !1, h = {
      type: "tableBody",
      start: Object.assign({}, w.start),
      // Note: correct end is set later.
      end: Object.assign({}, w.end)
    }, g.add(n, 0, [["enter", h, t]])), o = w.type === "tableDelimiterRow" ? 2 : h ? 3 : 1) : o && (w.type === "data" || w.type === "tableDelimiterMarker" || w.type === "tableDelimiterFiller") ? (r = !1, s[2] === 0 && (a[1] !== 0 && (s[0] = s[1], p = Th(g, t, a, o, void 0, p), a = [0, 0, 0, 0]), s[2] = n)) : w.type === "tableCellDivider" && (r ? r = !1 : (a[1] !== 0 && (s[0] = s[1], p = Th(g, t, a, o, void 0, p)), a = s, s = [a[1], n, 0, 0])) : w.type === "tableHead" ? (u = !0, c = n) : w.type === "tableRow" || w.type === "tableDelimiterRow" ? (c = n, a[1] !== 0 ? (s[0] = s[1], p = Th(g, t, a, o, n, p)) : s[1] !== 0 && (p = Th(g, t, s, o, n, p)), o = 0) : o && (w.type === "data" || w.type === "tableDelimiterMarker" || w.type === "tableDelimiterFiller") && (s[3] = n);
  }
  for (c !== 0 && KR(g, t, c, f, h), g.consume(t.events), n = -1; ++n < t.events.length; ) {
    const y = t.events[n];
    y[0] === "enter" && y[1].type === "table" && (y[1]._align = cpe(t.events, n));
  }
  return e;
}
function Th(e, t, n, r, o, a) {
  const s = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", u = "tableContent";
  n[0] !== 0 && (a.end = Object.assign({}, nl(t.events, n[0])), e.add(n[0], 0, [["exit", a, t]]));
  const c = nl(t.events, n[1]);
  if (a = {
    type: s,
    start: Object.assign({}, c),
    // Note: correct end is set later.
    end: Object.assign({}, c)
  }, e.add(n[1], 0, [["enter", a, t]]), n[2] !== 0) {
    const f = nl(t.events, n[2]), h = nl(t.events, n[3]), p = {
      type: u,
      start: Object.assign({}, f),
      end: Object.assign({}, h)
    };
    if (e.add(n[2], 0, [["enter", p, t]]), r !== 2) {
      const g = t.events[n[2]], y = t.events[n[3]];
      if (g[1].end = Object.assign({}, y[1].end), g[1].type = "chunkText", g[1].contentType = "text", n[3] > n[2] + 1) {
        const w = n[2] + 1, v = n[3] - n[2] - 1;
        e.add(w, v, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", p, t]]);
  }
  return o !== void 0 && (a.end = Object.assign({}, nl(t.events, o)), e.add(o, 0, [["exit", a, t]]), a = void 0), a;
}
function KR(e, t, n, r, o) {
  const a = [], s = nl(t.events, n);
  o && (o.end = Object.assign({}, s), a.push(["exit", o, t])), r.end = Object.assign({}, s), a.push(["exit", r, t]), e.add(n + 1, 0, a);
}
function nl(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const ppe = {
  name: "tasklistCheck",
  tokenize: gpe
};
function mpe() {
  return {
    text: {
      91: ppe
    }
  };
}
function gpe(e, t, n) {
  const r = this;
  return o;
  function o(c) {
    return (
      // Exit if theres stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(c) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), a)
    );
  }
  function a(c) {
    return vt(c) ? (e.enter("taskListCheckValueUnchecked"), e.consume(c), e.exit("taskListCheckValueUnchecked"), s) : c === 88 || c === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(c), e.exit("taskListCheckValueChecked"), s) : n(c);
  }
  function s(c) {
    return c === 93 ? (e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), u) : n(c);
  }
  function u(c) {
    return Oe(c) ? t(c) : We(c) ? e.check({
      tokenize: ype
    }, t, n)(c) : n(c);
  }
}
function ype(e, t, n) {
  return Qe(e, r, "whitespace");
  function r(o) {
    return o === null ? n(o) : t(o);
  }
}
function vpe(e) {
  return hj([
    Vhe(),
    Jhe(),
    spe(e),
    fpe(),
    mpe()
  ]);
}
const bpe = {};
function xpe(e) {
  const t = (
    /** @type {Processor<Root>} */
    this
  ), n = e || bpe, r = t.data(), o = r.micromarkExtensions || (r.micromarkExtensions = []), a = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), s = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  o.push(vpe(n)), a.push(Fhe()), s.push($he(n));
}
const kw = ({
  availableModule: e
}) => {
  const [t, n] = _.useState(!1), r = () => n(!t), o = 150, a = e.description.length > o ? e.description.substring(0, o) + "..." : e.description;
  return /* @__PURE__ */ b.jsxs("div", { className: "module-description", children: [
    /* @__PURE__ */ b.jsx(sde, { remarkPlugins: [xpe], children: t ? e.description.replace(/\\n/g, `
`) : a.replace(/\\n/g, `
`) }),
    e.description.length > o && /* @__PURE__ */ b.jsx("button", { onClick: r, className: "toggle-description", children: t ? "Show less" : "Show more" })
  ] });
}, ZR = [
  ">=",
  "==",
  "<=",
  "<",
  ">"
], rg = ">=", Tw = ({
  availableModule: e,
  on_change: t
}) => {
  const [n, r] = _.useState(
    e.version || "latest"
  ), [o, a] = _.useState(rg), s = (c) => {
    const f = c.target.value;
    r(f), t(f !== "latest" ? o + f : f);
  }, u = (c) => {
    c.target.value !== o && ZR.includes(c.target.value) && (a(c.target.value), n !== "latest" && t(c.target.value + n));
  };
  return e.releases && !e.releases.includes(n) && e.releases.unshift(n), /* @__PURE__ */ b.jsxs(b.Fragment, { children: [
    /* @__PURE__ */ b.jsx("select", { value: o, onChange: u, children: ZR.map((c) => /* @__PURE__ */ b.jsx("option", { value: c, children: c }, c)) }),
    /* @__PURE__ */ b.jsx("select", { onChange: s, value: n, children: e.releases && e.releases.map((c) => /* @__PURE__ */ b.jsx("option", { value: c, children: c }, c)) })
  ] });
}, wpe = ({
  availableModule: e,
  on_remove: t,
  on_update: n
}) => {
  const [r, o] = _.useState(
    rg + e.version || "latest"
  );
  return /* @__PURE__ */ b.jsxs("div", { className: "addable-module", children: [
    /* @__PURE__ */ b.jsx("div", { className: "module-name", children: e.name + (e.version ? ` (${e.version})` : "") }),
    /* @__PURE__ */ b.jsx(sw, { availableModule: e }),
    /* @__PURE__ */ b.jsx(kw, { availableModule: e }),
    /* @__PURE__ */ b.jsxs("div", { children: [
      /* @__PURE__ */ b.jsx(
        Tw,
        {
          availableModule: e,
          on_change: o
        }
      ),
      /* @__PURE__ */ b.jsx(
        "button",
        {
          className: "update-button",
          disabled: r === e.version,
          onClick: () => {
            n(e, r);
          },
          children: "Update"
        }
      ),
      /* @__PURE__ */ b.jsx(
        "button",
        {
          className: "remove-button",
          onClick: () => {
            t(e);
          },
          children: "Remove"
        }
      )
    ] })
  ] });
}, _pe = ({
  availableModule: e,
  on_add: t
}) => {
  const [n, r] = _.useState(
    rg + e.version || "latest"
  );
  return /* @__PURE__ */ b.jsxs("div", { className: "addable-module", children: [
    /* @__PURE__ */ b.jsx("div", { className: "module-name", children: e.name + (e.version ? ` (${e.version})` : "") }),
    /* @__PURE__ */ b.jsx(sw, { availableModule: e }),
    /* @__PURE__ */ b.jsx(kw, { availableModule: e }),
    /* @__PURE__ */ b.jsxs("div", { children: [
      /* @__PURE__ */ b.jsx(
        Tw,
        {
          availableModule: e,
          on_change: r
        }
      ),
      /* @__PURE__ */ b.jsx(
        "button",
        {
          className: "add-button",
          onClick: () => {
            t(e, n);
          },
          children: "Add"
        }
      )
    ] })
  ] });
}, Spe = ({
  availableModule: e,
  on_add: t
}) => {
  const [n, r] = _.useState(
    rg + e.version || "latest"
  );
  return /* @__PURE__ */ b.jsxs("div", { className: "addable-module", children: [
    /* @__PURE__ */ b.jsx("div", { className: "module-name", children: e.name }),
    /* @__PURE__ */ b.jsx(sw, { availableModule: e }),
    /* @__PURE__ */ b.jsx(kw, { availableModule: e }),
    /* @__PURE__ */ b.jsxs("div", { children: [
      /* @__PURE__ */ b.jsx(
        Tw,
        {
          availableModule: e,
          on_change: r
        }
      ),
      /* @__PURE__ */ b.jsx(
        "button",
        {
          className: "add-button",
          onClick: () => {
            t(e, n);
          },
          children: "Add"
        }
      )
    ] })
  ] });
}, Epe = ({
  ins: e
}) => {
  const [t, n] = _.useState(e.name), r = tt(), { lib: o } = xn(), a = () => {
    r.worker && o?.remove_external_worker(e.uuid, e.nodeclassid);
  }, s = () => {
    r.worker && (r.worker.update_external_worker(e.uuid, e.nodeclassid, {
      name: t
    }), e.name = t);
  };
  return /* @__PURE__ */ b.jsx(b.Fragment, { children: /* @__PURE__ */ b.jsx(
    ci,
    {
      title: e.name,
      description: "Settings for" + e.name,
      trigger: /* @__PURE__ */ b.jsx("div", { children: "Settings" }),
      buttons: [
        {
          text: "Save",
          onClick: s,
          close: !0
        },
        {
          text: "Delete",
          onClick: a,
          close: !0
        }
      ],
      children: /* @__PURE__ */ b.jsx("div", { children: /* @__PURE__ */ b.jsxs("div", { children: [
        /* @__PURE__ */ b.jsx("label", { htmlFor: "name", children: "Name: " }),
        /* @__PURE__ */ b.jsx(
          "input",
          {
            type: "text",
            name: "name",
            value: t,
            onChange: (u) => n(u.target.value),
            className: "styledinput"
          }
        )
      ] }) })
    }
  ) });
}, Cpe = ({
  ins: e,
  lib: t,
  filter: n = "",
  parentkey: r
}) => {
  const [o, a] = _.useState(!1), s = () => a(!o), u = t?.nodes?.filter(
    (c) => c.node_id.toLowerCase().includes(n.toLowerCase())
  );
  return /* @__PURE__ */ b.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ b.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: s,
        style: { cursor: "pointer" },
        title: e.name,
        children: [
          /* @__PURE__ */ b.jsx("div", { className: "shelftitle_text", children: e.name }),
          /* @__PURE__ */ b.jsx("div", { className: "expandicon " + (o ? "open" : "close"), children: /* @__PURE__ */ b.jsx(uf, {}) })
        ]
      }
    ),
    /* @__PURE__ */ b.jsx("div", { className: "libnodecontainer " + (o ? "open" : "close"), children: /* @__PURE__ */ b.jsx("div", { className: "libnodecontainer_inner", children: o && /* @__PURE__ */ b.jsxs(b.Fragment, { children: [
      /* @__PURE__ */ b.jsx("div", { className: "libnodeentry", title: e.uuid, children: /* @__PURE__ */ b.jsx(Epe, { ins: e }) }),
      t && /* @__PURE__ */ b.jsxs(b.Fragment, { children: [
        u && /* @__PURE__ */ b.jsx(b.Fragment, { children: u.map((c) => /* @__PURE__ */ b.jsx(
          ZD,
          {
            item: c
          },
          r + c.node_id
        )) }),
        t.subshelves.map((c) => /* @__PURE__ */ b.jsx(
          aw,
          {
            item: c,
            filter: n,
            parentkey: r + c.name
          },
          r + c.name
        ))
      ] })
    ] }) }) })
  ] });
}, kpe = ({
  item: e,
  mod: t,
  lib: n
}) => {
  const { lib: r } = xn(), [o, a] = _.useState(!1), s = () => a(!o), u = _.useCallback(() => {
    r?.add_external_worker({
      module: t,
      cls_module: e.module,
      cls_name: e.class_name
    });
  }, [r, t, e]), c = (h) => {
    h.detail === 2 && u();
  }, f = e.name || e.module + "." + e.class_name;
  return /* @__PURE__ */ b.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ b.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: s,
        style: { cursor: "pointer" },
        title: f,
        children: [
          /* @__PURE__ */ b.jsx("div", { className: "shelftitle_text", children: f }),
          /* @__PURE__ */ b.jsx("div", { className: "expandicon " + (o ? "open" : "close"), children: /* @__PURE__ */ b.jsx(uf, {}) })
        ]
      }
    ),
    /* @__PURE__ */ b.jsx("div", { className: "libnodecontainer " + (o ? "open" : "close"), children: /* @__PURE__ */ b.jsx("div", { className: "libnodecontainer_inner", children: o && /* @__PURE__ */ b.jsxs(b.Fragment, { children: [
      /* @__PURE__ */ b.jsx(
        "div",
        {
          className: "libnodeentry",
          onClick: c,
          title: e.name,
          children: "New Instance"
        }
      ),
      e.instances.map((h) => /* @__PURE__ */ b.jsx(
        Cpe,
        {
          ins: h,
          lib: n?.subshelves.find(
            (p) => p.name === h.uuid
          ),
          parentkey: h.uuid
        },
        h.uuid
      ))
    ] }) }) })
  ] });
}, Tpe = ({
  externalworkermod: e,
  lib: t
}) => {
  const [n, r] = _.useState(!1), o = () => r(!n), a = n;
  return /* @__PURE__ */ b.jsxs("div", { className: "shelfcontainer", children: [
    /* @__PURE__ */ b.jsxs(
      "div",
      {
        className: "shelftitle",
        onClick: o,
        style: { cursor: "pointer" },
        title: e.module,
        children: [
          /* @__PURE__ */ b.jsx("div", { className: "shelftitle_text", children: e.module }),
          /* @__PURE__ */ b.jsx("div", { className: "expandicon " + (a ? "open" : "close"), children: /* @__PURE__ */ b.jsx(uf, {}) })
        ]
      }
    ),
    /* @__PURE__ */ b.jsx("div", { className: "libnodecontainer " + (a ? "open" : "close"), children: /* @__PURE__ */ b.jsx("div", { className: "libnodecontainer_inner", children: e.worker_classes.map((s) => /* @__PURE__ */ b.jsx(
      kpe,
      {
        item: s,
        mod: e.module,
        lib: t
      },
      s.module + s.class_name
    )) }) }),
    /* @__PURE__ */ b.jsx("hr", {})
  ] });
}, Ape = () => {
  const e = tt(), t = e.lib.libstate(), n = tt(), r = n.local_settings(
    (f) => f.view_settings.expand_lib
  ), o = (f) => {
    n.update_view_settings({ expand_lib: f });
  }, a = Tie("m"), [s, u] = _.useState(""), c = e.worker?.state((f) => f.is_open) ?? !1;
  return /* @__PURE__ */ b.jsx(
    Vx,
    {
      maxSize: a ? "100%" : "18.75rem",
      direction: a ? "down" : "right",
      containerClassName: "pos-left pos-top bg1 h-12",
      onExpandChange: o,
      expanded: r === void 0 ? !0 : r,
      collapseIcons: {
        up: Pc,
        down: _l,
        left: jc,
        right: ap
      },
      expandIcons: {
        up: _l,
        down: Pc,
        left: ap,
        right: jc
      },
      children: /* @__PURE__ */ b.jsxs("div", { className: "libcontainer", children: [
        /* @__PURE__ */ b.jsxs("div", { className: "library", children: [
          /* @__PURE__ */ b.jsx("div", { className: "libtitle", children: "Lib" }),
          /* @__PURE__ */ b.jsx("hr", { className: "hr_prominent" }),
          /* @__PURE__ */ b.jsx(Xse, { filter: s, setFilter: u }),
          /* @__PURE__ */ b.jsx("div", { className: "vscrollcontainer", children: t.lib.shelves.filter((f) => f.name !== "_external_worker").map((f) => /* @__PURE__ */ b.jsx(
            aw,
            {
              item: f,
              filter: s,
              parentkey: f.name
            },
            f.name
          )) }),
          /* @__PURE__ */ b.jsx("hr", {}),
          /* @__PURE__ */ b.jsx("div", { className: "libtitle", children: "External Worker" }),
          /* @__PURE__ */ b.jsx("hr", { className: "hr_prominent" }),
          /* @__PURE__ */ b.jsx("div", { className: "vscrollcontainer", children: t.external_worker?.map((f) => /* @__PURE__ */ b.jsx(
            Tpe,
            {
              externalworkermod: f,
              lib: t.lib.shelves.find(
                (h) => h.name === "_external_worker"
              )
            },
            f.module
          )) }),
          /* @__PURE__ */ b.jsx("hr", {})
        ] }),
        c && /* @__PURE__ */ b.jsx("div", { className: "addlib", children: /* @__PURE__ */ b.jsx(Kse, { children: /* @__PURE__ */ b.jsx("button", { children: "Manage Libraries" }) }) })
      ] })
    }
  );
}, Rpe = ({
  fnrf_zst: e,
  header: t,
  flow: n,
  library: r
}) => {
  const [o, a] = _.useState(
    e.options.worker || e.getWorkerManager().worker
  ), s = _.useRef(null);
  e.workermanager && (e.workermanager.on_setWorker = a), _.useEffect(() => {
    e.auto_progress();
  }, []), _.useEffect(() => {
    e.local_state.setState({ funcnodescontainerRef: s.current });
  }, [s]);
  const u = e.plugins();
  return /* @__PURE__ */ b.jsx(die, { plugins: u, fnrf_zst: e, children: /* @__PURE__ */ b.jsx($V, { children: /* @__PURE__ */ b.jsx(yN.Provider, { value: e, children: /* @__PURE__ */ b.jsx(Zi, { asChild: !0, children: /* @__PURE__ */ b.jsx(Wo, { asChild: !0, children: /* @__PURE__ */ b.jsx(
    Y4,
    {
      style: {
        height: "100%",
        width: "100%",
        display: "flex",
        flexDirection: "column",
        flex: 1
      },
      children: /* @__PURE__ */ b.jsxs(
        "div",
        {
          ref: s,
          className: "funcnodesreactflowcontainer funcnodescontainer",
          children: [
            t.show && /* @__PURE__ */ b.jsx(Wse, { ...t }),
            /* @__PURE__ */ b.jsxs("div", { className: "funcnodesreactflowbody", children: [
              /* @__PURE__ */ b.jsx(kae, { ...n }),
              o && r.show && /* @__PURE__ */ b.jsx(Ape, {}),
              o && n.showNodeSettings && /* @__PURE__ */ b.jsx(Nie, {})
            ] }),
            /* @__PURE__ */ b.jsxs("div", { className: "funcnodesflaotingmenu", children: [
              /* @__PURE__ */ b.jsx(Wo.OutFullScreen, { children: n.allowExpand && /* @__PURE__ */ b.jsxs(Zi.Trigger, { children: [
                /* @__PURE__ */ b.jsx(Zi.Expanded, { children: /* @__PURE__ */ b.jsx(
                  MV,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) }),
                /* @__PURE__ */ b.jsx(Zi.Collapsed, { children: /* @__PURE__ */ b.jsx(
                  OV,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) })
              ] }) }),
              n.allowFullScreen && /* @__PURE__ */ b.jsxs(Wo.Trigger, { children: [
                /* @__PURE__ */ b.jsx(Wo.OutFullScreen, { children: /* @__PURE__ */ b.jsx(
                  gN,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) }),
                /* @__PURE__ */ b.jsx(Wo.InFullScreen, { children: /* @__PURE__ */ b.jsx(
                  RV,
                  {
                    size: "xl",
                    style: { padding: "4px" }
                  }
                ) })
              ] })
            ] })
          ]
        }
      )
    }
  ) }) }) }) }) });
};
class Yl {
  constructor(t) {
    this.context = t;
  }
  get nodespaceManager() {
    return this.context.rf.getNodespaceManager();
  }
  get libManager() {
    return this.context.rf.getLibManager();
  }
  get workerManager() {
    return this.context.rf.getWorkerManager();
  }
  get stateManager() {
    return this.context.rf.getStateManager();
  }
  get pluginManager() {
    return this.context.rf.getPluginManager();
  }
  get reactFlowManager() {
    return this.context.rf.getReactFlowManager();
  }
}
const QR = ({
  src_nid: e,
  src_ioid: t,
  trg_nid: n,
  trg_ioid: r
}) => [`${e}:${t}`, `${n}:${r}`].sort().join("--"), Mpe = ({}) => {
  const e = /* @__PURE__ */ new Map();
  return {
    nodesstates: e,
    get_node: (t, n = !0) => {
      const r = e.get(t);
      if (!r && n) {
        const o = e.keys();
        throw new Error(
          `Node ${t} not found, available nodes: ${Array.from(o)}`
        );
      }
      return r;
    }
  };
}, Ah = (e, t, n) => `${n}:${e}:${t}`, Ope = (e, t, n = /* @__PURE__ */ new Set()) => {
  const r = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set(), a = [e];
  for (; a.length > 0; ) {
    const s = a.pop();
    if (!s || n.has(s))
      continue;
    n.add(s);
    const u = t[s];
    if (u) {
      for (const c of u.node_ids)
        r.add(c);
      for (const c of u.child_groups)
        n.has(c) || (o.add(c), a.push(c));
    }
  }
  return { nodeIds: r, groupIds: o };
}, Npe = (e, t, n) => {
  let r = t[e]?.parent_group ?? null;
  for (; r; ) {
    if (n.has(r))
      return !0;
    r = t[r]?.parent_group ?? null;
  }
  return !1;
};
class Dpe extends Yl {
  constructor(t) {
    super(t), this._groups = {}, this._collapsedHandleMap = /* @__PURE__ */ new Map(), this._activeCollapsedGroups = /* @__PURE__ */ new Set(), this.on_node_action = (n) => {
      switch (n.type) {
        case "add":
          return this._add_node(n);
        case "update":
          return this._update_node(n);
        case "delete":
          return this._delete_node(n);
        case "error":
          return this._error_action(n);
        case "trigger":
          return this._trigger_action(n);
        default:
          this.context.rf.logger.error("Unknown node action", n);
          return;
      }
    }, this.on_edge_action = (n) => {
      const r = this.reactFlowManager.useReactFlowStore.getState();
      switch (n.type) {
        case "add":
          if (n.from_remote) {
            const o = r.getEdges(), a = QR(n);
            if (o.some((u) => u.id === a))
              return;
            const s = {
              id: a,
              source: n.src_nid,
              target: n.trg_nid,
              sourceHandle: n.src_ioid,
              targetHandle: n.trg_ioid,
              className: "funcnodes-edge animated",
              zIndex: 1003
              // just above elevated groups
            };
            this.context.rf.logger.info("Adding edge", s), r.update_edges([...o, s]), this.workerManager.worker?.api.node.get_remote_node_state(
              n.src_nid
            ), this.workerManager.worker?.api.node.get_remote_node_state(
              n.trg_nid
            );
          }
          break;
        case "delete":
          if (n.from_remote) {
            const o = r.getEdges(), a = QR(n);
            this.context.rf.logger.info("Deleting edge", a);
            const s = o.filter((u) => u.id !== a);
            r.update_edges(s), this.workerManager.worker?.api.node.get_remote_node_state(
              n.src_nid
            ), this.workerManager.worker?.api.node.get_remote_node_state(
              n.trg_nid
            );
          }
          break;
        default:
          this.context.rf.logger.error("Unknown edge action", n);
      }
      n.from_remote && this._refresh_collapsed_groups();
    }, this.on_group_action = (n) => {
      switch (n.type) {
        case "set":
          return this._set_groups(n.groups);
        case "update":
          return this._update_group(n);
        default:
          this.context.rf.logger.error("Unknown group action", n);
      }
    }, this.clear_all = () => {
      this.context.rf.logger.debug("Clearing all nodespace"), this.workerManager.worker?.disconnect(), this.workerManager.set_worker(void 0), this.workerManager.workermanager?.setWorker(void 0), this.libManager.lib.libstate.getState().set({ lib: { shelves: [] }, external_worker: [] }), this._groups = {}, this._collapsedHandleMap.clear(), this._activeCollapsedGroups.clear(), this.nodespace.nodesstates.clear(), this.reactFlowManager.useReactFlowStore.getState().update_nodes([]), this.reactFlowManager.useReactFlowStore.getState().update_edges([]), this.stateManager.auto_progress();
    }, this.center_node = (n) => {
      if (!this.reactFlowManager.rf_instance)
        return;
      n = Array.isArray(n) ? n : [n];
      const r = this.reactFlowManager.useReactFlowStore.getState().getNodes().filter((o) => n.includes(o.id));
      r.length > 0 && this.reactFlowManager.rf_instance?.fitView({ padding: 0.2, nodes: r });
    }, this.auto_resize_group = (n) => {
      const r = this.reactFlowManager.useReactFlowStore.getState(), o = r.getNode(n);
      if (o === void 0 || o.type !== "group")
        return;
      const a = o.data.group.node_ids.map((h) => r.getNode(h)).filter((h) => h !== void 0), s = o.data.group.child_groups.map((h) => r.getNode(h)).filter((h) => h !== void 0), u = [...a, ...s], c = this.reactFlowManager.rf_instance?.getNodesBounds(u);
      if (c === void 0)
        return;
      const f = {
        ...o,
        position: {
          x: c.x,
          y: c.y
        },
        height: c.height,
        width: c.width
      };
      f.data.group.position = [c.x, c.y], r.partial_update_nodes([f]);
    }, this.change_group_position = (n) => {
      if (n.position === void 0)
        return;
      const r = this.reactFlowManager.useReactFlowStore.getState(), o = r.getNode(n.id);
      if (o === void 0 || o.type !== "group")
        return;
      const a = [
        ...o.data.group.node_ids,
        ...o.data.group.child_groups
      ], s = this.reactFlowManager.rf_instance?.getNodesBounds(a);
      if (s === void 0)
        return;
      const u = n.position.x - s?.x, c = n.position.y - s?.y, f = [];
      for (const h of a) {
        const p = r.getNode(h);
        p !== void 0 && f.push({
          id: h,
          type: "position",
          position: {
            x: p.position.x + u,
            y: p.position.y + c
          }
        });
      }
      r.onNodesChange(f);
    }, this.change_fn_node_position = (n) => {
      n.position !== void 0 && this.on_node_action({
        type: "update",
        id: n.id,
        node: {
          properties: {
            "frontend:pos": [n.position.x, n.position.y]
          }
        },
        from_remote: !1
      });
    }, this.change_group_dimensions = (n) => {
      if (n.dimensions === void 0)
        return;
      const o = this.reactFlowManager.useReactFlowStore.getState().getNode(n.id);
      o !== void 0 && this.reactFlowManager.useReactFlowStore.getState().partial_update_nodes(Ix([n], [o]));
    }, this.change_fn_node_dimensions = (n) => {
      n.dimensions !== void 0 && this.on_node_action({
        type: "update",
        id: n.id,
        node: {
          properties: {
            "frontend:size": [n.dimensions.width, n.dimensions.height]
          }
        },
        from_remote: !1
      });
    }, this._update_group = (n) => {
      if (n.from_remote) {
        const r = this.reactFlowManager.useReactFlowStore.getState(), o = r.getNode(n.id);
        if (o === void 0 || o.type !== "group")
          return;
        const { new_obj: a, change: s } = Ha(o.data.group, n.group);
        s && (o.data.group = a, this._groups[n.id] = a), r.partial_update_nodes([o]), this._refresh_collapsed_groups();
      } else
        this.workerManager.worker && this.workerManager.worker.api.group.locally_update_group(n);
    }, this._set_groups = (n) => {
      const r = this.reactFlowManager.useReactFlowStore.getState();
      this._groups = { ...n };
      const { default_nodes: o } = Wx(r.getNodes()), a = [...o], s = {};
      for (const c in n) {
        const f = n[c];
        for (const p of f.node_ids)
          s[p] = c;
        for (const p of f.child_groups)
          s[p] = c;
        f.position === void 0 && (f.position = [0, 0]);
        const h = {
          id: c,
          type: "group",
          data: { group: n[c], id: c },
          position: { x: f.position[0], y: f.position[1] },
          zIndex: 2
        };
        f.parent_group && (h.data.groupID = f.parent_group), a.push(h);
      }
      for (const c of a)
        c.id in s ? c.data.groupID = s[c.id] : c.data.groupID = void 0;
      const u = Np(a);
      r.update_nodes(u);
      for (const c of u.reverse())
        c.type === "group" && (n[c.id]?.meta?.collapsed || this.auto_resize_group(c.id));
      this._refresh_collapsed_groups();
    }, this._refresh_collapsed_groups = () => {
      const n = this.reactFlowManager.useReactFlowStore.getState(), r = n.getNodes(), o = n.getEdges(), a = o.filter((k) => !(k.data && k.data.__fnrfCollapsedProxy)).map((k) => ({
        ...k,
        data: k.data ? { ...k.data } : void 0
      }));
      for (const k of a)
        k.hidden = !1;
      if (r.length === 0) {
        this._collapsedHandleMap.clear(), this._activeCollapsedGroups.clear(), o.length !== a.length && n.update_edges(a);
        return;
      }
      const s = r.map((k) => ({
        ...k,
        data: { ...k.data }
      })), u = new Map(s.map((k) => [k.id, k]));
      for (const k of s)
        if (k.hidden = !1, k.type === "group") {
          const T = k;
          T.data.collapsed = !1, T.data.collapsedInfo = void 0;
        }
      const c = /* @__PURE__ */ new Set();
      for (const [k, T] of Object.entries(this._groups))
        T?.meta?.collapsed && c.add(k);
      const f = Array.from(c).filter(
        (k) => !Npe(k, this._groups, c)
      ), h = new Set(this._activeCollapsedGroups), p = new Set(f), g = [];
      for (const k of h)
        p.has(k) || g.push(k);
      const y = /* @__PURE__ */ new Map();
      for (const k of f)
        y.set(k, Ope(k, this._groups));
      const w = /* @__PURE__ */ new Map();
      for (const [k, T] of y)
        for (const R of T.nodeIds)
          w.set(R, k);
      const v = /* @__PURE__ */ new Map(), S = /* @__PURE__ */ new Map(), E = [];
      for (const k of f) {
        const T = y.get(k);
        if (!T)
          continue;
        const R = u.get(k);
        if (!R)
          continue;
        const N = /* @__PURE__ */ new Map(), j = /* @__PURE__ */ new Map(), z = [], B = [];
        for (const Y of T.nodeIds) {
          const P = this.nodespace.get_node(Y, !1);
          if (!P)
            continue;
          const V = P.getState(), I = V.name || V.node_name || V.id || Y, U = (H, G) => {
            const O = P.io_stores.get(H);
            if (!O)
              return;
            const W = O.getState();
            if (W.hidden)
              return;
            const Z = G === "input" ? a.filter(
              (ae) => ae.target === Y && ae.targetHandle === H
            ) : a.filter(
              (ae) => ae.source === Y && ae.sourceHandle === H
            ), L = Z.filter((ae) => {
              const ye = G === "input" ? ae.source : ae.target;
              return !ye || T.nodeIds.has(ye) ? !1 : w.get(ye) !== k;
            });
            if (L.length === 0 && Z.length !== 0)
              return;
            const te = Ah(Y, H, G), he = typeof W.type == "string" ? W.type : typeof W.render_options?.type == "string" ? W.render_options?.type : void 0, oe = {
              handleId: te,
              nodeId: Y,
              ioId: H,
              ioName: W.name || H,
              nodeName: I,
              direction: G,
              connectionCount: L.length,
              type: he
            };
            G === "input" ? z.push(oe) : B.push(oe);
            const fe = {
              nodeId: Y,
              ioId: H,
              direction: G,
              handleId: te
            };
            N.set(te, fe), j.set(Ah(Y, H, G), fe);
          };
          V.inputs?.forEach((H) => U(H, "input")), V.outputs?.forEach((H) => U(H, "output"));
        }
        R.data.collapsed = !0, R.data.collapsedInfo = { inputs: z, outputs: B };
        const M = Math.max(z.length, B.length), F = Math.max(100, M * 34 + 70), q = z.length > 0 && B.length > 0 ? 260 : 220;
        R.height = F, R.width = q, R.zIndex = 1003;
        for (const Y of T.nodeIds) {
          const P = u.get(Y);
          P && (P.hidden = !0);
        }
        for (const Y of T.groupIds) {
          const P = u.get(Y);
          P && (P.hidden = !0);
        }
        v.set(k, N), S.set(k, j);
      }
      for (const k of a) {
        if (!k.source || !k.target || !k.sourceHandle || !k.targetHandle)
          continue;
        const T = w.get(k.source), R = w.get(k.target);
        if (!T && !R)
          continue;
        if (T && R && T === R) {
          k.hidden = !0;
          continue;
        }
        let N = k.source, j = k.sourceHandle, z = k.target, B = k.targetHandle;
        if (T) {
          const M = S.get(T)?.get(Ah(k.source, k.sourceHandle, "output"));
          if (!M) {
            k.hidden = !1;
            continue;
          }
          N = T, j = M.handleId;
        }
        if (R) {
          const M = S.get(R)?.get(Ah(k.target, k.targetHandle, "input"));
          if (!M) {
            k.hidden = !1;
            continue;
          }
          z = R, B = M.handleId;
        }
        k.hidden = !0, E.push({
          ...k,
          id: `collapsed:${k.id}`,
          source: N,
          sourceHandle: j,
          target: z,
          targetHandle: B,
          hidden: !1,
          data: {
            ...k.data || {},
            __fnrfCollapsedProxy: !0,
            originalEdgeId: k.id
          }
        });
      }
      const A = Np(s);
      n.update_nodes(A), n.update_edges([...a, ...E]), this._collapsedHandleMap = v, this._activeCollapsedGroups = p;
      for (const k of g)
        this.auto_resize_group(k);
    }, this._add_node = (n) => {
      this.context.rf.logger.info("add node", n);
      const r = this.reactFlowManager.useReactFlowStore.getState();
      if (n.from_remote) {
        let o = this.nodespace.get_node(n.node.id, !1);
        if (o)
          return;
        if (!o)
          try {
            o = vae(n.node), this.nodespace.nodesstates.set(n.node.id, o);
          } catch (c) {
            this.context.rf.logger.error(`Failed to create node store ${c}`);
            return;
          }
        const a = o.getState();
        this.context.rf.logger.info("Add node", a.id, a.name);
        const s = Cae(o, this.context.rf), u = [...r.getNodes(), s];
        this.reactFlowManager.useReactFlowStore.getState().update_nodes(u), this._refresh_collapsed_groups();
        for (const c of s.io_order)
          this.workerManager.worker?.api.node.get_io_value({
            nid: s.id,
            ioid: c
          });
        return setTimeout(() => {
          this.workerManager.worker?.api.hooks.call_hooks("node_added", {
            node: a.id
          });
        }, 0), a;
      }
    }, this._update_node = (n) => {
      if (Object.keys(n.node).length === 0) {
        this.context.rf.logger.error(
          "Node update is empty",
          new Error(JSON.stringify(n))
        );
        return;
      }
      if (n.node.in_trigger && (n.node.error = void 0), n.from_remote) {
        const r = this.nodespace.get_node(n.id, !1);
        if (!r) {
          console.error("Node not found to update", n.id);
          return;
        }
        r.update(n.node);
        const o = r.getState();
        return this._refresh_collapsed_groups(), o;
      } else
        this.workerManager.worker && this.workerManager.worker.api.node.locally_update_node(n);
    }, this._sync_nodes = () => {
      const n = this.reactFlowManager.useReactFlowStore.getState().getNodes(), r = this.nodespace.nodesstates;
      for (const o of r.keys())
        n.some((a) => a.id === o) || r.delete(o);
    }, this._delete_node = (n) => {
      this.context.rf.logger.info("Deleting node", n.id), n.from_remote ? (this.reactFlowManager.useReactFlowStore.getState().onNodesChange([
        {
          type: "remove",
          id: n.id
        }
      ]), this._refresh_collapsed_groups(), this._sync_nodes()) : this.workerManager.worker?.api.node.remove_node(n.id);
    }, this._error_action = (n) => (this.context.rf.logger.error("Error", new Error(JSON.stringify(n))), this.on_node_action({
      type: "update",
      id: n.id,
      node: {
        in_trigger: !1,
        error: n.error
      },
      from_remote: !0
    })), this._trigger_action = (n) => {
      if (n.from_remote)
        return this.on_node_action({
          type: "update",
          id: n.id,
          node: {
            in_trigger: !0,
            error: void 0
          },
          from_remote: !0
        });
      this.workerManager.worker?.api.node.trigger_node(n.id);
    }, this.get_collapsed_handle_mapping = (n, r) => this._collapsedHandleMap.get(n)?.get(r), this.nodespace = Mpe({});
  }
  center_all() {
    this.reactFlowManager.rf_instance?.fitView({ padding: 0.2 });
  }
}
const jpe = () => ({
  libstate: Er((e, t) => ({
    lib: {
      shelves: []
    },
    external_worker: [],
    set: (n) => e((r) => ({ ...r, ...n })),
    get_lib: () => t().lib,
    get_external_worker: () => t().external_worker
  }))
});
class Ppe extends Yl {
  constructor(t) {
    super(t), this.lib = jpe();
  }
}
class Ipe extends Yl {
  constructor(t) {
    super(t), t.rf.logger.debug("Initializing worker manager handler"), this.workers = Er((n, r) => ({})), this.workerstate = Er((n, r) => ({
      is_open: !1
    }));
  }
  set_worker(t) {
    t !== this.worker && (this._unsubscribeFromWorker && (this._unsubscribeFromWorker(), this._unsubscribeFromWorker = void 0), t ? (this.context.rf.logger.debug("Setting worker in worker manager"), this._unsubscribeFromWorker = t.state.subscribe((n) => {
      this.workerstate.setState(n);
    }), this.workerstate.setState(t.state.getState())) : this.context.rf.logger.debug("Removing worker in worker manager"), this.worker = t, t?.set_zustand(this.context.rf));
  }
}
class zpe extends Yl {
  constructor(t) {
    super(t), this.progress_state = Er((n, r) => ({
      message: "please select worker",
      status: "info",
      progress: 0,
      blocking: !1
    })), this.local_settings = Er(
      (n, r) => ({
        view_settings: {
          expand_node_props: !1,
          expand_lib: !1
        }
      })
    ), this.local_state = Er((n, r) => ({
      selected_nodes: [],
      selected_edges: [],
      selected_groups: [],
      funcnodescontainerRef: null
    }));
  }
  set_progress(t) {
    if (t.message === "")
      return this.auto_progress();
    const n = this.progress_state.getState(), { new_obj: r, change: o } = Ha(n, t);
    o && this.progress_state.setState(r);
  }
  auto_progress() {
    const t = this.workerManager.workermanager, n = this.workerManager.worker;
    if (t !== void 0 && !t.open)
      return this.set_progress({
        progress: 0,
        message: "connecting to worker manager",
        status: "error",
        blocking: !1
      });
    if (n === void 0)
      return this.set_progress({
        progress: 0,
        message: "please select worker",
        status: "error",
        blocking: !1
      });
    if (!n.is_open)
      return this.set_progress({
        progress: 0,
        message: "connecting to worker",
        status: "info",
        blocking: !0
      });
    this.set_progress({
      progress: 1,
      message: "running",
      status: "info",
      blocking: !1
    });
  }
  update_view_settings(t) {
    dD(this.local_settings, { view_settings: t });
  }
}
const rP = "1.0.0", Lpe = ["1"], Fpe = (e) => {
  if (!e.v.toString().includes(".") || // old polugin version without "."
  !Lpe.includes(e.v.toString().split(".")[0]))
    throw new Error(`Unsupported version: ${e.v}`);
  return { ...e, v: rP };
};
class $pe extends Yl {
  constructor(t) {
    super(t), this.plugins = Er((n, r) => ({})), this.render_options = Er((n, r) => ({}));
  }
  add_plugin(t, n) {
    if (n !== void 0)
      try {
        const r = Fpe(n);
        this.plugins.setState((o) => ({ ...o, [t]: r }));
      } catch (r) {
        r instanceof Error ? this.context.rf.logger.error(`Error loading plugin ${t}`, r) : this.context.rf.logger.error(
          `Error loading plugin ${t}`,
          new Error(String(r))
        ), this.stateManager.toaster?.error({
          title: "Error",
          description: `Error loading plugin ${t}: ${r instanceof Error ? r.message : String(r)}`,
          duration: 5e3
        });
      }
  }
  update_render_options(t) {
    dD(this.render_options, t);
  }
  async add_packed_plugin(t, n) {
    if (n.js)
      for (const r of n.js) {
        const o = document.createElement("script");
        o.text = atob(r), document.body.appendChild(o);
      }
    if (n.css)
      for (const r of n.css) {
        const o = document.createElement("style");
        o.innerHTML = atob(r), document.head.appendChild(o);
      }
    if (n.module !== void 0) {
      const r = atob(n.module);
      try {
        const a = await new Function(
          "React",
          "FuncNodesReactFlow",
          `
          return (async () => {
            ${r}
            return FuncNodesPlugin;
          })();
        `
        )(yl, f6);
        this.add_plugin(t, a);
      } catch (o) {
        o instanceof Error ? this.context.rf.logger.error(`Error building plugin ${t}`, o) : this.context.rf.logger.error(
          `Error building plugin ${t}`,
          new Error(String(o))
        ), this.stateManager.toaster?.error({
          title: "Error",
          description: `Error building plugin ${t}: ${o}`,
          duration: 5e3
        });
      }
    }
  }
}
class Bpe extends Yl {
  constructor(t) {
    super(t), this.on_rf_node_change = (n) => {
      const r = this.useReactFlowStore.getState();
      for (const o of n)
        switch (o.type) {
          case "position":
            if (o.position) {
              const a = r.getNode(o.id);
              if (a === void 0)
                continue;
              a.type === "group" ? this.nodespaceManager.change_group_position(o) : this.nodespaceManager.change_fn_node_position(o), a.data.groupID && this.nodespaceManager.auto_resize_group(a.data.groupID);
            }
            break;
          case "dimensions":
            if (o.dimensions) {
              const a = r.getNode(o.id);
              if (a === void 0)
                continue;
              a.type === "group" ? this.nodespaceManager.change_group_dimensions(o) : this.nodespaceManager.change_fn_node_dimensions(o), a.data.groupID && this.nodespaceManager.auto_resize_group(
                a.data.groupID
              );
            }
            break;
        }
    }, this.on_rf_edge_change = (n) => {
    }, this.on_connect = (n) => {
      if (n.source === null || n.target === null || n.sourceHandle === null || n.targetHandle === null || !this.workerManager.worker)
        return;
      const r = this.nodespaceManager.get_collapsed_handle_mapping(
        n.source,
        n.sourceHandle
      ), o = this.nodespaceManager.get_collapsed_handle_mapping(
        n.target,
        n.targetHandle
      ), a = r ? r.nodeId : n.source, s = r ? r.ioId : n.sourceHandle, u = o ? o.nodeId : n.target, c = o ? o.ioId : n.targetHandle;
      this.workerManager.worker.api.edge.add_edge({
        src_nid: a,
        src_ioid: s,
        trg_nid: u,
        trg_ioid: c,
        replace: !0
      });
    }, this.useReactFlowStore = Tae({
      on_node_change: this.on_rf_node_change.bind(this),
      on_edge_change: this.on_rf_edge_change.bind(this),
      on_connect: this.on_connect.bind(this)
    });
  }
}
let Hpe = class {
  constructor(t) {
    this.reactflowRef = null, this.dev_settings = {
      debug: Dp
    }, this.options = t, this.logger = t.logger ?? new c1("fn", eM);
    const n = { rf: this };
    this._nodespaceManager = new Dpe(n), this._libManager = new Ppe(n), this._workerManager = new Ipe(n), this._stateManager = new zpe(n), this._pluginManager = new $pe(n), this._reactFlowManager = new Bpe(n);
  }
  // #region handlers
  getNodespaceManager() {
    return this._nodespaceManager;
  }
  getLibManager() {
    return this._libManager;
  }
  getWorkerManager() {
    return this._workerManager;
  }
  getStateManager() {
    return this._stateManager;
  }
  getPluginManager() {
    return this._pluginManager;
  }
  getReactFlowManager() {
    return this._reactFlowManager;
  }
  // #endregion handlers
  // #region nodespace manager
  get nodespace() {
    return this._nodespaceManager.nodespace;
  }
  get on_node_action() {
    return this._nodespaceManager.on_node_action.bind(this._nodespaceManager);
  }
  get on_edge_action() {
    return this._nodespaceManager.on_edge_action.bind(this._nodespaceManager);
  }
  get on_group_action() {
    return this._nodespaceManager.on_group_action.bind(this._nodespaceManager);
  }
  get clear_all() {
    return this._nodespaceManager.clear_all.bind(this._nodespaceManager);
  }
  get center_node() {
    return this._nodespaceManager.center_node.bind(this._nodespaceManager);
  }
  get center_all() {
    return this._nodespaceManager.center_all.bind(this._nodespaceManager);
  }
  // #endregion nodespace manager
  // #region lib manager
  get lib() {
    return this._libManager.lib;
  }
  // #endregion lib manager
  // #region worker manager
  get set_worker() {
    return this._workerManager.set_worker.bind(this._workerManager);
  }
  get workermanager() {
    return this._workerManager.workermanager;
  }
  set workermanager(t) {
    this._workerManager.workermanager = t;
  }
  get worker() {
    return this._workerManager.worker;
  }
  get workers() {
    return this._workerManager.workers;
  }
  get workerstate() {
    return this._workerManager.workerstate;
  }
  get _unsubscribeFromWorker() {
    return this._workerManager._unsubscribeFromWorker?.bind(
      this._workerManager
    );
  }
  // #endregion worker manager
  // #region statemanager
  get set_progress() {
    return this._stateManager.set_progress.bind(this._stateManager);
  }
  get auto_progress() {
    return this._stateManager.auto_progress.bind(this._stateManager);
  }
  get progress_state() {
    return this._stateManager.progress_state;
  }
  get local_settings() {
    return this._stateManager.local_settings;
  }
  get local_state() {
    return this._stateManager.local_state;
  }
  update_view_settings(t) {
    this._stateManager.update_view_settings(t);
  }
  // #endregion statemanager
  // #region plugis
  get plugins() {
    return this._pluginManager.plugins.bind(this._pluginManager);
  }
  get add_plugin() {
    return this._pluginManager.add_plugin.bind(this._pluginManager);
  }
  get add_packed_plugin() {
    return this._pluginManager.add_packed_plugin.bind(this._pluginManager);
  }
  get render_options() {
    return this._pluginManager.render_options.bind(this._pluginManager);
  }
  get update_render_options() {
    return this._pluginManager.update_render_options.bind(this._pluginManager);
  }
  // #endregion plugis
  // #region reactflow
  get useReactFlowStore() {
    return this._reactFlowManager.useReactFlowStore.bind(
      this._reactFlowManager
    );
  }
  get rf_instance() {
    return this._reactFlowManager.rf_instance;
  }
  set rf_instance(t) {
    this._reactFlowManager.rf_instance = t;
  }
  // #endregion reactflow
};
const Vpe = d1(
  CZ,
  (e) => (e.id = gx(), e)
), Upe = (e) => {
  if (!e.useWorkerManager && e.worker === void 0)
    throw new Error(
      "If you don't use a worker manager, you must provide a default worker."
    );
  if (e.useWorkerManager && e.workermanager_url === void 0)
    throw new Error(
      "Error: If you use a worker manager, you must provide a worker managerurl."
    );
}, l1 = {};
window.fnrf_zst === void 0 && (window.fnrf_zst = l1);
const qpe = (e) => {
  const [t, n] = _.useState(void 0), [r, o] = _.useState(
    void 0
  ), [a, s] = _.useState(!1);
  if (_.useEffect(() => {
    const u = Vpe(e);
    u.logger = u.logger || new c1("FuncNodes", u.debug ? "debug" : "info"), u.logger.debug("Initializing FuncNodes with props:", u), n(u), s(!1);
  }, [e]), _.useEffect(() => {
    if (!t) return;
    t.logger?.debug("Initializing/Getting Zustand store");
    const u = l1[t.id];
    if (u === void 0) {
      const c = new Hpe(t);
      l1[t.id] = c, o(c);
    } else
      o(u), u.options.debug = t.debug;
  }, [t?.id, t?.debug]), _.useEffect(() => {
    if (!(!t || !r) && !(t.useWorkerManager || !t.worker_url))
      if (t.logger?.debug("Worker effect running"), t.worker) {
        t.worker.set_zustand(r);
        return;
      } else {
        t.logger?.debug("Creating WebSocket worker");
        const u = new j3({
          url: t.worker_url,
          uuid: t.id,
          on_sync_complete: t.on_sync_complete
        });
        return u.set_zustand(r), n(
          (c) => c && { ...c, worker: u, useWorkerManager: !1 }
        ), () => {
          t.logger?.debug("Disconnecting worker"), u.disconnect(), n((c) => c && { ...c, worker: void 0 });
        };
      }
  }, [
    t?.worker_url,
    t?.id,
    t?.useWorkerManager,
    r,
    t?.on_sync_complete
  ]), _.useEffect(() => {
    if (!t?.fnw_url || !t.worker) return;
    t.logger?.debug("Loading fnw_url data");
    let u = !1;
    const c = t.worker.getSyncManager().on_sync_complete;
    return (async () => {
      try {
        const h = await D6(t.fnw_url);
        !u && t.worker && (t.worker.getSyncManager().on_sync_complete = async (p) => {
          await p.update_from_export(h), t.worker.getSyncManager().on_sync_complete = c, c && c(p);
        });
      } catch (h) {
        h instanceof Error ? t.logger?.error("Failed to load fnw_url:", h) : t.logger?.error(
          "Failed to load fnw_url:",
          new Error(String(h))
        );
      }
    })(), () => {
      u = !0, t.worker && (t.worker.getSyncManager().on_sync_complete = c);
    };
  }, [t?.fnw_url, t?.worker]), _.useEffect(() => {
    if (!t || !r || !t.useWorkerManager) return;
    if (!t.workermanager_url)
      throw new Error(
        "Error: If you use a worker manager, you must provide a worker manager url."
      );
    r.logger.info("Worker manager effect running");
    const u = !r.workermanager, c = r.workermanager && r.workermanager.wsuri !== t.workermanager_url;
    if (u || c) {
      r.workermanager && (r.logger.info("Removing existing worker manager"), r.workermanager.remove(), r.workermanager = void 0), r.logger.info("Creating new worker manager");
      const f = new wZ(
        t.workermanager_url,
        r
      );
      return r.workermanager = f, n((h) => h && { ...h, workermanager: f }), () => {
        r.logger.info("Worker manager cleanup running"), r.workermanager === f ? (r.logger.info("Removing worker manager instance"), f.remove(), r.workermanager = void 0) : r.logger.info(
          "Worker manager instance mismatch, skipping cleanup"
        );
      };
    } else {
      r.logger.info(
        "Worker manager already initialized with correct URL"
      );
      return;
    }
  }, [
    t?.useWorkerManager,
    t?.workermanager_url,
    t?.id,
    r
  ]), _.useEffect(() => {
    if (!t || !r || a) return;
    (t.useWorkerManager ? r.workermanager !== void 0 : t.worker !== void 0) && t.on_ready && typeof t.on_ready == "function" && (t.logger?.debug("Firing on_ready callback"), t.on_ready({ fnrf_zst: r }), s(!0));
  }, [
    t,
    r,
    a,
    t?.useWorkerManager,
    r?.workermanager,
    t?.worker
  ]), t === void 0 || r === void 0)
    return /* @__PURE__ */ b.jsx("div", { children: "Loading..." });
  try {
    Upe(t);
  } catch (u) {
    return /* @__PURE__ */ b.jsx(j6, { error: u });
  }
  return /* @__PURE__ */ b.jsx("div", { className: "FuncnodesApp", children: /* @__PURE__ */ b.jsx(BV, { available_themes: P3, children: /* @__PURE__ */ b.jsx(bX, { duration: 5e3, children: /* @__PURE__ */ b.jsx(
    Rpe,
    {
      fnrf_zst: r,
      header: t.header,
      library: t.library,
      flow: t.flow
    }
  ) }) }) });
}, oP = (e, t) => {
  t === void 0 && (t = {});
  const { element: n, eleid: r } = typeof e == "string" ? {
    element: document.getElementById(e),
    eleid: e
  } : { element: e, eleid: e.id };
  x6.createRoot(n).render(
    /* @__PURE__ */ b.jsx(_.StrictMode, { children: /* @__PURE__ */ b.jsx(qpe, { ...t, id: t.id || r }) })
  );
};
window.FuncNodes = oP;
window.FuncNodes.version = "1.0.2";
window.FuncNodes.utils = {
  logger: {
    ConsoleLogger: c1,
    DivLogger: C6,
    BaseLogger: u1,
    DEBUG: w6,
    INFO: eM,
    WARN: _6,
    ERROR: S6
  }
};
