var pG = Object.defineProperty;
var hG = (e, t, n) => t in e ? pG(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var mG = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var Wn = (e, t, n) => hG(e, typeof t != "symbol" ? t + "" : t, n);
var FLe = mG((ro, oo) => {
  function gG(e, t) {
    for (var n = 0; n < t.length; n++) {
      const r = t[n];
      if (typeof r != "string" && !Array.isArray(r)) {
        for (const o in r)
          if (o !== "default" && !(o in e)) {
            const i = Object.getOwnPropertyDescriptor(r, o);
            i && Object.defineProperty(e, o, i.get ? i : {
              enumerable: !0,
              get: () => r[o]
            });
          }
      }
    }
    return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
  }
  const yG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    get ArrayBufferDataStructure() {
      return B6;
    },
    get CTypeStructure() {
      return U6;
    },
    get DataPreviewViewRendererToHandlePreviewRenderer() {
      return o8;
    },
    get DataStructure() {
      return Ai;
    },
    get DataViewRendererToDataPreviewViewRenderer() {
      return Fr;
    },
    get DataViewRendererToInputRenderer() {
      return i8;
    },
    get DataViewRendererToOverlayRenderer() {
      return Gb;
    },
    get FuncNodesRenderer() {
      return cq;
    },
    get JSONStructure() {
      return Vs;
    },
    get LATEST_VERSION() {
      return lq;
    },
    get TextStructure() {
      return V6;
    },
    get useFuncNodesContext() {
      return jt;
    },
    get useIOGetFullValue() {
      return Zb;
    },
    get useIOStore() {
      return wn;
    },
    get useIOValueStore() {
      return K0e;
    },
    get useNodeStore() {
      return fo;
    },
    get useSetIOValue() {
      return Mf;
    },
    get useSetIOValueOptions() {
      return G0e;
    },
    get useWorkerApi() {
      return Or;
    }
  }, Symbol.toStringTag, { value: "Module" }));
  (function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload")) return;
    for (const o of document.querySelectorAll('link[rel="modulepreload"]')) r(o);
    new MutationObserver((o) => {
      for (const i of o)
        if (i.type === "childList")
          for (const a of i.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && r(a);
    }).observe(document, {
      childList: !0,
      subtree: !0
    });
    function n(o) {
      const i = {};
      return o.integrity && (i.integrity = o.integrity), o.referrerPolicy && (i.referrerPolicy = o.referrerPolicy), o.crossOrigin === "use-credentials" ? i.credentials = "include" : o.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i;
    }
    function r(o) {
      if (o.ep) return;
      o.ep = !0;
      const i = n(o);
      fetch(o.href, i);
    }
  })();
  function Jo(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
  }
  var Uw = { exports: {} }, Bd = {};
  /**
   * @license React
   * react-jsx-runtime.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var JM;
  function vG() {
    if (JM) return Bd;
    JM = 1;
    var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.fragment");
    function n(r, o, i) {
      var a = null;
      if (i !== void 0 && (a = "" + i), o.key !== void 0 && (a = "" + o.key), "key" in o) {
        i = {};
        for (var s in o)
          s !== "key" && (i[s] = o[s]);
      } else i = o;
      return o = i.ref, {
        $$typeof: e,
        type: r,
        key: a,
        ref: o !== void 0 ? o : null,
        props: i
      };
    }
    return Bd.Fragment = t, Bd.jsx = n, Bd.jsxs = n, Bd;
  }
  var eP;
  function bG() {
    return eP || (eP = 1, Uw.exports = vG()), Uw.exports;
  }
  var S = bG(), Vw = { exports: {} }, Ud = {}, Hw = { exports: {} }, qw = {};
  /**
   * @license React
   * scheduler.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var tP;
  function xG() {
    return tP || (tP = 1, function(e) {
      function t(F, G) {
        var W = F.length;
        F.push(G);
        e: for (; 0 < W; ) {
          var K = W - 1 >>> 1, $ = F[K];
          if (0 < o($, G))
            F[K] = G, F[W] = $, W = K;
          else break e;
        }
      }
      function n(F) {
        return F.length === 0 ? null : F[0];
      }
      function r(F) {
        if (F.length === 0) return null;
        var G = F[0], W = F.pop();
        if (W !== G) {
          F[0] = W;
          e: for (var K = 0, $ = F.length, U = $ >>> 1; K < U; ) {
            var X = 2 * (K + 1) - 1, z = F[X], H = X + 1, Y = F[H];
            if (0 > o(z, W))
              H < $ && 0 > o(Y, z) ? (F[K] = Y, F[H] = W, K = H) : (F[K] = z, F[X] = W, K = X);
            else if (H < $ && 0 > o(Y, W))
              F[K] = Y, F[H] = W, K = H;
            else break e;
          }
        }
        return G;
      }
      function o(F, G) {
        var W = F.sortIndex - G.sortIndex;
        return W !== 0 ? W : F.id - G.id;
      }
      if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
        var i = performance;
        e.unstable_now = function() {
          return i.now();
        };
      } else {
        var a = Date, s = a.now();
        e.unstable_now = function() {
          return a.now() - s;
        };
      }
      var l = [], u = [], d = 1, p = null, h = 3, g = !1, y = !1, b = !1, v = !1, x = typeof setTimeout == "function" ? setTimeout : null, E = typeof clearTimeout == "function" ? clearTimeout : null, _ = typeof setImmediate < "u" ? setImmediate : null;
      function C(F) {
        for (var G = n(u); G !== null; ) {
          if (G.callback === null) r(u);
          else if (G.startTime <= F)
            r(u), G.sortIndex = G.expirationTime, t(l, G);
          else break;
          G = n(u);
        }
      }
      function k(F) {
        if (b = !1, C(F), !y)
          if (n(l) !== null)
            y = !0, R || (R = !0, P());
          else {
            var G = n(u);
            G !== null && V(k, G.startTime - F);
          }
      }
      var R = !1, A = -1, M = 5, I = -1;
      function D() {
        return v ? !0 : !(e.unstable_now() - I < M);
      }
      function L() {
        if (v = !1, R) {
          var F = e.unstable_now();
          I = F;
          var G = !0;
          try {
            e: {
              y = !1, b && (b = !1, E(A), A = -1), g = !0;
              var W = h;
              try {
                t: {
                  for (C(F), p = n(l); p !== null && !(p.expirationTime > F && D()); ) {
                    var K = p.callback;
                    if (typeof K == "function") {
                      p.callback = null, h = p.priorityLevel;
                      var $ = K(
                        p.expirationTime <= F
                      );
                      if (F = e.unstable_now(), typeof $ == "function") {
                        p.callback = $, C(F), G = !0;
                        break t;
                      }
                      p === n(l) && r(l), C(F);
                    } else r(l);
                    p = n(l);
                  }
                  if (p !== null) G = !0;
                  else {
                    var U = n(u);
                    U !== null && V(
                      k,
                      U.startTime - F
                    ), G = !1;
                  }
                }
                break e;
              } finally {
                p = null, h = W, g = !1;
              }
              G = void 0;
            }
          } finally {
            G ? P() : R = !1;
          }
        }
      }
      var P;
      if (typeof _ == "function")
        P = function() {
          _(L);
        };
      else if (typeof MessageChannel < "u") {
        var B = new MessageChannel(), j = B.port2;
        B.port1.onmessage = L, P = function() {
          j.postMessage(null);
        };
      } else
        P = function() {
          x(L, 0);
        };
      function V(F, G) {
        A = x(function() {
          F(e.unstable_now());
        }, G);
      }
      e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(F) {
        F.callback = null;
      }, e.unstable_forceFrameRate = function(F) {
        0 > F || 125 < F ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : M = 0 < F ? Math.floor(1e3 / F) : 5;
      }, e.unstable_getCurrentPriorityLevel = function() {
        return h;
      }, e.unstable_next = function(F) {
        switch (h) {
          case 1:
          case 2:
          case 3:
            var G = 3;
            break;
          default:
            G = h;
        }
        var W = h;
        h = G;
        try {
          return F();
        } finally {
          h = W;
        }
      }, e.unstable_requestPaint = function() {
        v = !0;
      }, e.unstable_runWithPriority = function(F, G) {
        switch (F) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            F = 3;
        }
        var W = h;
        h = F;
        try {
          return G();
        } finally {
          h = W;
        }
      }, e.unstable_scheduleCallback = function(F, G, W) {
        var K = e.unstable_now();
        switch (typeof W == "object" && W !== null ? (W = W.delay, W = typeof W == "number" && 0 < W ? K + W : K) : W = K, F) {
          case 1:
            var $ = -1;
            break;
          case 2:
            $ = 250;
            break;
          case 5:
            $ = 1073741823;
            break;
          case 4:
            $ = 1e4;
            break;
          default:
            $ = 5e3;
        }
        return $ = W + $, F = {
          id: d++,
          callback: G,
          priorityLevel: F,
          startTime: W,
          expirationTime: $,
          sortIndex: -1
        }, W > K ? (F.sortIndex = W, t(u, F), n(l) === null && F === n(u) && (b ? (E(A), A = -1) : b = !0, V(k, W - K))) : (F.sortIndex = $, t(l, F), y || g || (y = !0, R || (R = !0, P()))), F;
      }, e.unstable_shouldYield = D, e.unstable_wrapCallback = function(F) {
        var G = h;
        return function() {
          var W = h;
          h = G;
          try {
            return F.apply(this, arguments);
          } finally {
            h = W;
          }
        };
      };
    }(qw)), qw;
  }
  var nP;
  function wG() {
    return nP || (nP = 1, Hw.exports = xG()), Hw.exports;
  }
  var Ww = { exports: {} }, ft = {};
  /**
   * @license React
   * react.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var rP;
  function SG() {
    if (rP) return ft;
    rP = 1;
    var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), i = Symbol.for("react.consumer"), a = Symbol.for("react.context"), s = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), u = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), p = Symbol.iterator;
    function h($) {
      return $ === null || typeof $ != "object" ? null : ($ = p && $[p] || $["@@iterator"], typeof $ == "function" ? $ : null);
    }
    var g = {
      isMounted: function() {
        return !1;
      },
      enqueueForceUpdate: function() {
      },
      enqueueReplaceState: function() {
      },
      enqueueSetState: function() {
      }
    }, y = Object.assign, b = {};
    function v($, U, X) {
      this.props = $, this.context = U, this.refs = b, this.updater = X || g;
    }
    v.prototype.isReactComponent = {}, v.prototype.setState = function($, U) {
      if (typeof $ != "object" && typeof $ != "function" && $ != null)
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, $, U, "setState");
    }, v.prototype.forceUpdate = function($) {
      this.updater.enqueueForceUpdate(this, $, "forceUpdate");
    };
    function x() {
    }
    x.prototype = v.prototype;
    function E($, U, X) {
      this.props = $, this.context = U, this.refs = b, this.updater = X || g;
    }
    var _ = E.prototype = new x();
    _.constructor = E, y(_, v.prototype), _.isPureReactComponent = !0;
    var C = Array.isArray, k = { H: null, A: null, T: null, S: null, V: null }, R = Object.prototype.hasOwnProperty;
    function A($, U, X, z, H, Y) {
      return X = Y.ref, {
        $$typeof: e,
        type: $,
        key: U,
        ref: X !== void 0 ? X : null,
        props: Y
      };
    }
    function M($, U) {
      return A(
        $.type,
        U,
        void 0,
        void 0,
        void 0,
        $.props
      );
    }
    function I($) {
      return typeof $ == "object" && $ !== null && $.$$typeof === e;
    }
    function D($) {
      var U = { "=": "=0", ":": "=2" };
      return "$" + $.replace(/[=:]/g, function(X) {
        return U[X];
      });
    }
    var L = /\/+/g;
    function P($, U) {
      return typeof $ == "object" && $ !== null && $.key != null ? D("" + $.key) : U.toString(36);
    }
    function B() {
    }
    function j($) {
      switch ($.status) {
        case "fulfilled":
          return $.value;
        case "rejected":
          throw $.reason;
        default:
          switch (typeof $.status == "string" ? $.then(B, B) : ($.status = "pending", $.then(
            function(U) {
              $.status === "pending" && ($.status = "fulfilled", $.value = U);
            },
            function(U) {
              $.status === "pending" && ($.status = "rejected", $.reason = U);
            }
          )), $.status) {
            case "fulfilled":
              return $.value;
            case "rejected":
              throw $.reason;
          }
      }
      throw $;
    }
    function V($, U, X, z, H) {
      var Y = typeof $;
      (Y === "undefined" || Y === "boolean") && ($ = null);
      var Q = !1;
      if ($ === null) Q = !0;
      else
        switch (Y) {
          case "bigint":
          case "string":
          case "number":
            Q = !0;
            break;
          case "object":
            switch ($.$$typeof) {
              case e:
              case t:
                Q = !0;
                break;
              case d:
                return Q = $._init, V(
                  Q($._payload),
                  U,
                  X,
                  z,
                  H
                );
            }
        }
      if (Q)
        return H = H($), Q = z === "" ? "." + P($, 0) : z, C(H) ? (X = "", Q != null && (X = Q.replace(L, "$&/") + "/"), V(H, U, X, "", function(le) {
          return le;
        })) : H != null && (I(H) && (H = M(
          H,
          X + (H.key == null || $ && $.key === H.key ? "" : ("" + H.key).replace(
            L,
            "$&/"
          ) + "/") + Q
        )), U.push(H)), 1;
      Q = 0;
      var re = z === "" ? "." : z + ":";
      if (C($))
        for (var te = 0; te < $.length; te++)
          z = $[te], Y = re + P(z, te), Q += V(
            z,
            U,
            X,
            Y,
            H
          );
      else if (te = h($), typeof te == "function")
        for ($ = te.call($), te = 0; !(z = $.next()).done; )
          z = z.value, Y = re + P(z, te++), Q += V(
            z,
            U,
            X,
            Y,
            H
          );
      else if (Y === "object") {
        if (typeof $.then == "function")
          return V(
            j($),
            U,
            X,
            z,
            H
          );
        throw U = String($), Error(
          "Objects are not valid as a React child (found: " + (U === "[object Object]" ? "object with keys {" + Object.keys($).join(", ") + "}" : U) + "). If you meant to render a collection of children, use an array instead."
        );
      }
      return Q;
    }
    function F($, U, X) {
      if ($ == null) return $;
      var z = [], H = 0;
      return V($, z, "", "", function(Y) {
        return U.call(X, Y, H++);
      }), z;
    }
    function G($) {
      if ($._status === -1) {
        var U = $._result;
        U = U(), U.then(
          function(X) {
            ($._status === 0 || $._status === -1) && ($._status = 1, $._result = X);
          },
          function(X) {
            ($._status === 0 || $._status === -1) && ($._status = 2, $._result = X);
          }
        ), $._status === -1 && ($._status = 0, $._result = U);
      }
      if ($._status === 1) return $._result.default;
      throw $._result;
    }
    var W = typeof reportError == "function" ? reportError : function($) {
      if (typeof window == "object" && typeof window.ErrorEvent == "function") {
        var U = new window.ErrorEvent("error", {
          bubbles: !0,
          cancelable: !0,
          message: typeof $ == "object" && $ !== null && typeof $.message == "string" ? String($.message) : String($),
          error: $
        });
        if (!window.dispatchEvent(U)) return;
      } else if (typeof process == "object" && typeof process.emit == "function") {
        process.emit("uncaughtException", $);
        return;
      }
      console.error($);
    };
    function K() {
    }
    return ft.Children = {
      map: F,
      forEach: function($, U, X) {
        F(
          $,
          function() {
            U.apply(this, arguments);
          },
          X
        );
      },
      count: function($) {
        var U = 0;
        return F($, function() {
          U++;
        }), U;
      },
      toArray: function($) {
        return F($, function(U) {
          return U;
        }) || [];
      },
      only: function($) {
        if (!I($))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return $;
      }
    }, ft.Component = v, ft.Fragment = n, ft.Profiler = o, ft.PureComponent = E, ft.StrictMode = r, ft.Suspense = l, ft.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = k, ft.__COMPILER_RUNTIME = {
      __proto__: null,
      c: function($) {
        return k.H.useMemoCache($);
      }
    }, ft.cache = function($) {
      return function() {
        return $.apply(null, arguments);
      };
    }, ft.cloneElement = function($, U, X) {
      if ($ == null)
        throw Error(
          "The argument must be a React element, but you passed " + $ + "."
        );
      var z = y({}, $.props), H = $.key, Y = void 0;
      if (U != null)
        for (Q in U.ref !== void 0 && (Y = void 0), U.key !== void 0 && (H = "" + U.key), U)
          !R.call(U, Q) || Q === "key" || Q === "__self" || Q === "__source" || Q === "ref" && U.ref === void 0 || (z[Q] = U[Q]);
      var Q = arguments.length - 2;
      if (Q === 1) z.children = X;
      else if (1 < Q) {
        for (var re = Array(Q), te = 0; te < Q; te++)
          re[te] = arguments[te + 2];
        z.children = re;
      }
      return A($.type, H, void 0, void 0, Y, z);
    }, ft.createContext = function($) {
      return $ = {
        $$typeof: a,
        _currentValue: $,
        _currentValue2: $,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      }, $.Provider = $, $.Consumer = {
        $$typeof: i,
        _context: $
      }, $;
    }, ft.createElement = function($, U, X) {
      var z, H = {}, Y = null;
      if (U != null)
        for (z in U.key !== void 0 && (Y = "" + U.key), U)
          R.call(U, z) && z !== "key" && z !== "__self" && z !== "__source" && (H[z] = U[z]);
      var Q = arguments.length - 2;
      if (Q === 1) H.children = X;
      else if (1 < Q) {
        for (var re = Array(Q), te = 0; te < Q; te++)
          re[te] = arguments[te + 2];
        H.children = re;
      }
      if ($ && $.defaultProps)
        for (z in Q = $.defaultProps, Q)
          H[z] === void 0 && (H[z] = Q[z]);
      return A($, Y, void 0, void 0, null, H);
    }, ft.createRef = function() {
      return { current: null };
    }, ft.forwardRef = function($) {
      return { $$typeof: s, render: $ };
    }, ft.isValidElement = I, ft.lazy = function($) {
      return {
        $$typeof: d,
        _payload: { _status: -1, _result: $ },
        _init: G
      };
    }, ft.memo = function($, U) {
      return {
        $$typeof: u,
        type: $,
        compare: U === void 0 ? null : U
      };
    }, ft.startTransition = function($) {
      var U = k.T, X = {};
      k.T = X;
      try {
        var z = $(), H = k.S;
        H !== null && H(X, z), typeof z == "object" && z !== null && typeof z.then == "function" && z.then(K, W);
      } catch (Y) {
        W(Y);
      } finally {
        k.T = U;
      }
    }, ft.unstable_useCacheRefresh = function() {
      return k.H.useCacheRefresh();
    }, ft.use = function($) {
      return k.H.use($);
    }, ft.useActionState = function($, U, X) {
      return k.H.useActionState($, U, X);
    }, ft.useCallback = function($, U) {
      return k.H.useCallback($, U);
    }, ft.useContext = function($) {
      return k.H.useContext($);
    }, ft.useDebugValue = function() {
    }, ft.useDeferredValue = function($, U) {
      return k.H.useDeferredValue($, U);
    }, ft.useEffect = function($, U, X) {
      var z = k.H;
      if (typeof X == "function")
        throw Error(
          "useEffect CRUD overload is not enabled in this build of React."
        );
      return z.useEffect($, U);
    }, ft.useId = function() {
      return k.H.useId();
    }, ft.useImperativeHandle = function($, U, X) {
      return k.H.useImperativeHandle($, U, X);
    }, ft.useInsertionEffect = function($, U) {
      return k.H.useInsertionEffect($, U);
    }, ft.useLayoutEffect = function($, U) {
      return k.H.useLayoutEffect($, U);
    }, ft.useMemo = function($, U) {
      return k.H.useMemo($, U);
    }, ft.useOptimistic = function($, U) {
      return k.H.useOptimistic($, U);
    }, ft.useReducer = function($, U, X) {
      return k.H.useReducer($, U, X);
    }, ft.useRef = function($) {
      return k.H.useRef($);
    }, ft.useState = function($) {
      return k.H.useState($);
    }, ft.useSyncExternalStore = function($, U, X) {
      return k.H.useSyncExternalStore(
        $,
        U,
        X
      );
    }, ft.useTransition = function() {
      return k.H.useTransition();
    }, ft.version = "19.1.0", ft;
  }
  var oP;
  function kh() {
    return oP || (oP = 1, Ww.exports = SG()), Ww.exports;
  }
  var Gw = { exports: {} }, dr = {};
  /**
   * @license React
   * react-dom.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var iP;
  function _G() {
    if (iP) return dr;
    iP = 1;
    var e = kh();
    function t(l) {
      var u = "https://react.dev/errors/" + l;
      if (1 < arguments.length) {
        u += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var d = 2; d < arguments.length; d++)
          u += "&args[]=" + encodeURIComponent(arguments[d]);
      }
      return "Minified React error #" + l + "; visit " + u + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function n() {
    }
    var r = {
      d: {
        f: n,
        r: function() {
          throw Error(t(522));
        },
        D: n,
        C: n,
        L: n,
        m: n,
        X: n,
        S: n,
        M: n
      },
      p: 0,
      findDOMNode: null
    }, o = Symbol.for("react.portal");
    function i(l, u, d) {
      var p = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {
        $$typeof: o,
        key: p == null ? null : "" + p,
        children: l,
        containerInfo: u,
        implementation: d
      };
    }
    var a = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function s(l, u) {
      if (l === "font") return "";
      if (typeof u == "string")
        return u === "use-credentials" ? u : "";
    }
    return dr.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r, dr.createPortal = function(l, u) {
      var d = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!u || u.nodeType !== 1 && u.nodeType !== 9 && u.nodeType !== 11)
        throw Error(t(299));
      return i(l, u, null, d);
    }, dr.flushSync = function(l) {
      var u = a.T, d = r.p;
      try {
        if (a.T = null, r.p = 2, l) return l();
      } finally {
        a.T = u, r.p = d, r.d.f();
      }
    }, dr.preconnect = function(l, u) {
      typeof l == "string" && (u ? (u = u.crossOrigin, u = typeof u == "string" ? u === "use-credentials" ? u : "" : void 0) : u = null, r.d.C(l, u));
    }, dr.prefetchDNS = function(l) {
      typeof l == "string" && r.d.D(l);
    }, dr.preinit = function(l, u) {
      if (typeof l == "string" && u && typeof u.as == "string") {
        var d = u.as, p = s(d, u.crossOrigin), h = typeof u.integrity == "string" ? u.integrity : void 0, g = typeof u.fetchPriority == "string" ? u.fetchPriority : void 0;
        d === "style" ? r.d.S(
          l,
          typeof u.precedence == "string" ? u.precedence : void 0,
          {
            crossOrigin: p,
            integrity: h,
            fetchPriority: g
          }
        ) : d === "script" && r.d.X(l, {
          crossOrigin: p,
          integrity: h,
          fetchPriority: g,
          nonce: typeof u.nonce == "string" ? u.nonce : void 0
        });
      }
    }, dr.preinitModule = function(l, u) {
      if (typeof l == "string")
        if (typeof u == "object" && u !== null) {
          if (u.as == null || u.as === "script") {
            var d = s(
              u.as,
              u.crossOrigin
            );
            r.d.M(l, {
              crossOrigin: d,
              integrity: typeof u.integrity == "string" ? u.integrity : void 0,
              nonce: typeof u.nonce == "string" ? u.nonce : void 0
            });
          }
        } else u == null && r.d.M(l);
    }, dr.preload = function(l, u) {
      if (typeof l == "string" && typeof u == "object" && u !== null && typeof u.as == "string") {
        var d = u.as, p = s(d, u.crossOrigin);
        r.d.L(l, d, {
          crossOrigin: p,
          integrity: typeof u.integrity == "string" ? u.integrity : void 0,
          nonce: typeof u.nonce == "string" ? u.nonce : void 0,
          type: typeof u.type == "string" ? u.type : void 0,
          fetchPriority: typeof u.fetchPriority == "string" ? u.fetchPriority : void 0,
          referrerPolicy: typeof u.referrerPolicy == "string" ? u.referrerPolicy : void 0,
          imageSrcSet: typeof u.imageSrcSet == "string" ? u.imageSrcSet : void 0,
          imageSizes: typeof u.imageSizes == "string" ? u.imageSizes : void 0,
          media: typeof u.media == "string" ? u.media : void 0
        });
      }
    }, dr.preloadModule = function(l, u) {
      if (typeof l == "string")
        if (u) {
          var d = s(u.as, u.crossOrigin);
          r.d.m(l, {
            as: typeof u.as == "string" && u.as !== "script" ? u.as : void 0,
            crossOrigin: d,
            integrity: typeof u.integrity == "string" ? u.integrity : void 0
          });
        } else r.d.m(l);
    }, dr.requestFormReset = function(l) {
      r.d.r(l);
    }, dr.unstable_batchedUpdates = function(l, u) {
      return l(u);
    }, dr.useFormState = function(l, u, d) {
      return a.H.useFormState(l, u, d);
    }, dr.useFormStatus = function() {
      return a.H.useHostTransitionStatus();
    }, dr.version = "19.1.0", dr;
  }
  var aP;
  function S4() {
    if (aP) return Gw.exports;
    aP = 1;
    function e() {
      if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
        } catch (t) {
          console.error(t);
        }
    }
    return e(), Gw.exports = _G(), Gw.exports;
  }
  var sP;
  function EG() {
    if (sP) return Ud;
    sP = 1;
    /**
     * @license React
     * react-dom-client.production.js
     *
     * Copyright (c) Meta Platforms, Inc. and affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var e = wG(), t = kh(), n = S4();
    function r(c) {
      var f = "https://react.dev/errors/" + c;
      if (1 < arguments.length) {
        f += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var m = 2; m < arguments.length; m++)
          f += "&args[]=" + encodeURIComponent(arguments[m]);
      }
      return "Minified React error #" + c + "; visit " + f + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function o(c) {
      return !(!c || c.nodeType !== 1 && c.nodeType !== 9 && c.nodeType !== 11);
    }
    function i(c) {
      var f = c, m = c;
      if (c.alternate) for (; f.return; ) f = f.return;
      else {
        c = f;
        do
          f = c, (f.flags & 4098) !== 0 && (m = f.return), c = f.return;
        while (c);
      }
      return f.tag === 3 ? m : null;
    }
    function a(c) {
      if (c.tag === 13) {
        var f = c.memoizedState;
        if (f === null && (c = c.alternate, c !== null && (f = c.memoizedState)), f !== null) return f.dehydrated;
      }
      return null;
    }
    function s(c) {
      if (i(c) !== c)
        throw Error(r(188));
    }
    function l(c) {
      var f = c.alternate;
      if (!f) {
        if (f = i(c), f === null) throw Error(r(188));
        return f !== c ? null : c;
      }
      for (var m = c, w = f; ; ) {
        var O = m.return;
        if (O === null) break;
        var N = O.alternate;
        if (N === null) {
          if (w = O.return, w !== null) {
            m = w;
            continue;
          }
          break;
        }
        if (O.child === N.child) {
          for (N = O.child; N; ) {
            if (N === m) return s(O), c;
            if (N === w) return s(O), f;
            N = N.sibling;
          }
          throw Error(r(188));
        }
        if (m.return !== w.return) m = O, w = N;
        else {
          for (var q = !1, Z = O.child; Z; ) {
            if (Z === m) {
              q = !0, m = O, w = N;
              break;
            }
            if (Z === w) {
              q = !0, w = O, m = N;
              break;
            }
            Z = Z.sibling;
          }
          if (!q) {
            for (Z = N.child; Z; ) {
              if (Z === m) {
                q = !0, m = N, w = O;
                break;
              }
              if (Z === w) {
                q = !0, w = N, m = O;
                break;
              }
              Z = Z.sibling;
            }
            if (!q) throw Error(r(189));
          }
        }
        if (m.alternate !== w) throw Error(r(190));
      }
      if (m.tag !== 3) throw Error(r(188));
      return m.stateNode.current === m ? c : f;
    }
    function u(c) {
      var f = c.tag;
      if (f === 5 || f === 26 || f === 27 || f === 6) return c;
      for (c = c.child; c !== null; ) {
        if (f = u(c), f !== null) return f;
        c = c.sibling;
      }
      return null;
    }
    var d = Object.assign, p = Symbol.for("react.element"), h = Symbol.for("react.transitional.element"), g = Symbol.for("react.portal"), y = Symbol.for("react.fragment"), b = Symbol.for("react.strict_mode"), v = Symbol.for("react.profiler"), x = Symbol.for("react.provider"), E = Symbol.for("react.consumer"), _ = Symbol.for("react.context"), C = Symbol.for("react.forward_ref"), k = Symbol.for("react.suspense"), R = Symbol.for("react.suspense_list"), A = Symbol.for("react.memo"), M = Symbol.for("react.lazy"), I = Symbol.for("react.activity"), D = Symbol.for("react.memo_cache_sentinel"), L = Symbol.iterator;
    function P(c) {
      return c === null || typeof c != "object" ? null : (c = L && c[L] || c["@@iterator"], typeof c == "function" ? c : null);
    }
    var B = Symbol.for("react.client.reference");
    function j(c) {
      if (c == null) return null;
      if (typeof c == "function")
        return c.$$typeof === B ? null : c.displayName || c.name || null;
      if (typeof c == "string") return c;
      switch (c) {
        case y:
          return "Fragment";
        case v:
          return "Profiler";
        case b:
          return "StrictMode";
        case k:
          return "Suspense";
        case R:
          return "SuspenseList";
        case I:
          return "Activity";
      }
      if (typeof c == "object")
        switch (c.$$typeof) {
          case g:
            return "Portal";
          case _:
            return (c.displayName || "Context") + ".Provider";
          case E:
            return (c._context.displayName || "Context") + ".Consumer";
          case C:
            var f = c.render;
            return c = c.displayName, c || (c = f.displayName || f.name || "", c = c !== "" ? "ForwardRef(" + c + ")" : "ForwardRef"), c;
          case A:
            return f = c.displayName || null, f !== null ? f : j(c.type) || "Memo";
          case M:
            f = c._payload, c = c._init;
            try {
              return j(c(f));
            } catch {
            }
        }
      return null;
    }
    var V = Array.isArray, F = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, G = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, W = {
      pending: !1,
      data: null,
      method: null,
      action: null
    }, K = [], $ = -1;
    function U(c) {
      return { current: c };
    }
    function X(c) {
      0 > $ || (c.current = K[$], K[$] = null, $--);
    }
    function z(c, f) {
      $++, K[$] = c.current, c.current = f;
    }
    var H = U(null), Y = U(null), Q = U(null), re = U(null);
    function te(c, f) {
      switch (z(Q, f), z(Y, c), z(H, null), f.nodeType) {
        case 9:
        case 11:
          c = (c = f.documentElement) && (c = c.namespaceURI) ? TM(c) : 0;
          break;
        default:
          if (c = f.tagName, f = f.namespaceURI)
            f = TM(f), c = RM(f, c);
          else
            switch (c) {
              case "svg":
                c = 1;
                break;
              case "math":
                c = 2;
                break;
              default:
                c = 0;
            }
      }
      X(H), z(H, c);
    }
    function le() {
      X(H), X(Y), X(Q);
    }
    function fe(c) {
      c.memoizedState !== null && z(re, c);
      var f = H.current, m = RM(f, c.type);
      f !== m && (z(Y, c), z(H, m));
    }
    function J(c) {
      Y.current === c && (X(H), X(Y)), re.current === c && (X(re), jd._currentValue = W);
    }
    var ee = Object.prototype.hasOwnProperty, ie = e.unstable_scheduleCallback, ae = e.unstable_cancelCallback, ge = e.unstable_shouldYield, Ce = e.unstable_requestPaint, Ne = e.unstable_now, Le = e.unstable_getCurrentPriorityLevel, Ve = e.unstable_ImmediatePriority, Ke = e.unstable_UserBlockingPriority, ze = e.unstable_NormalPriority, Me = e.unstable_LowPriority, ct = e.unstable_IdlePriority, wt = e.log, Re = e.unstable_setDisableYieldValue, oe = null, ue = null;
    function Se(c) {
      if (typeof wt == "function" && Re(c), ue && typeof ue.setStrictMode == "function")
        try {
          ue.setStrictMode(oe, c);
        } catch {
        }
    }
    var _e = Math.clz32 ? Math.clz32 : Ft, Ae = Math.log, Ue = Math.LN2;
    function Ft(c) {
      return c >>>= 0, c === 0 ? 32 : 31 - (Ae(c) / Ue | 0) | 0;
    }
    var ut = 256, sn = 4194304;
    function Ie(c) {
      var f = c & 42;
      if (f !== 0) return f;
      switch (c & -c) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return c & 4194048;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return c & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return c;
      }
    }
    function tt(c, f, m) {
      var w = c.pendingLanes;
      if (w === 0) return 0;
      var O = 0, N = c.suspendedLanes, q = c.pingedLanes;
      c = c.warmLanes;
      var Z = w & 134217727;
      return Z !== 0 ? (w = Z & ~N, w !== 0 ? O = Ie(w) : (q &= Z, q !== 0 ? O = Ie(q) : m || (m = Z & ~c, m !== 0 && (O = Ie(m))))) : (Z = w & ~N, Z !== 0 ? O = Ie(Z) : q !== 0 ? O = Ie(q) : m || (m = w & ~c, m !== 0 && (O = Ie(m)))), O === 0 ? 0 : f !== 0 && f !== O && (f & N) === 0 && (N = O & -O, m = f & -f, N >= m || N === 32 && (m & 4194048) !== 0) ? f : O;
    }
    function Ct(c, f) {
      return (c.pendingLanes & ~(c.suspendedLanes & ~c.pingedLanes) & f) === 0;
    }
    function Sn(c, f) {
      switch (c) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return f + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return f + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function $o() {
      var c = ut;
      return ut <<= 1, (ut & 4194048) === 0 && (ut = 256), c;
    }
    function ns() {
      var c = sn;
      return sn <<= 1, (sn & 62914560) === 0 && (sn = 4194304), c;
    }
    function pl(c) {
      for (var f = [], m = 0; 31 > m; m++) f.push(c);
      return f;
    }
    function Zt(c, f) {
      c.pendingLanes |= f, f !== 268435456 && (c.suspendedLanes = 0, c.pingedLanes = 0, c.warmLanes = 0);
    }
    function On(c, f, m, w, O, N) {
      var q = c.pendingLanes;
      c.pendingLanes = m, c.suspendedLanes = 0, c.pingedLanes = 0, c.warmLanes = 0, c.expiredLanes &= m, c.entangledLanes &= m, c.errorRecoveryDisabledLanes &= m, c.shellSuspendCounter = 0;
      var Z = c.entanglements, ne = c.expirationTimes, pe = c.hiddenUpdates;
      for (m = q & ~m; 0 < m; ) {
        var be = 31 - _e(m), we = 1 << be;
        Z[be] = 0, ne[be] = -1;
        var he = pe[be];
        if (he !== null)
          for (pe[be] = null, be = 0; be < he.length; be++) {
            var me = he[be];
            me !== null && (me.lane &= -536870913);
          }
        m &= ~we;
      }
      w !== 0 && rs(c, w, 0), N !== 0 && O === 0 && c.tag !== 0 && (c.suspendedLanes |= N & ~(q & ~f));
    }
    function rs(c, f, m) {
      c.pendingLanes |= f, c.suspendedLanes &= ~f;
      var w = 31 - _e(f);
      c.entangledLanes |= f, c.entanglements[w] = c.entanglements[w] | 1073741824 | m & 4194090;
    }
    function ii(c, f) {
      var m = c.entangledLanes |= f;
      for (c = c.entanglements; m; ) {
        var w = 31 - _e(m), O = 1 << w;
        O & f | c[w] & f && (c[w] |= f), m &= ~O;
      }
    }
    function _r(c) {
      switch (c) {
        case 2:
          c = 1;
          break;
        case 8:
          c = 4;
          break;
        case 32:
          c = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          c = 128;
          break;
        case 268435456:
          c = 134217728;
          break;
        default:
          c = 0;
      }
      return c;
    }
    function zf(c) {
      return c &= -c, 2 < c ? 8 < c ? (c & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
    }
    function vm() {
      var c = G.p;
      return c !== 0 ? c : (c = window.event, c === void 0 ? 32 : GM(c.type));
    }
    function P1(c, f) {
      var m = G.p;
      try {
        return G.p = c, f();
      } finally {
        G.p = m;
      }
    }
    var ai = Math.random().toString(36).slice(2), Yn = "__reactFiber$" + ai, ur = "__reactProps$" + ai, os = "__reactContainer$" + ai, Bf = "__reactEvents$" + ai, $1 = "__reactListeners$" + ai, I1 = "__reactHandles$" + ai, bm = "__reactResources$" + ai, hl = "__reactMarker$" + ai;
    function Uf(c) {
      delete c[Yn], delete c[ur], delete c[Bf], delete c[$1], delete c[I1];
    }
    function is(c) {
      var f = c[Yn];
      if (f) return f;
      for (var m = c.parentNode; m; ) {
        if (f = m[os] || m[Yn]) {
          if (m = f.alternate, f.child !== null || m !== null && m.child !== null)
            for (c = MM(c); c !== null; ) {
              if (m = c[Yn]) return m;
              c = MM(c);
            }
          return f;
        }
        c = m, m = c.parentNode;
      }
      return null;
    }
    function ta(c) {
      if (c = c[Yn] || c[os]) {
        var f = c.tag;
        if (f === 5 || f === 6 || f === 13 || f === 26 || f === 27 || f === 3)
          return c;
      }
      return null;
    }
    function as(c) {
      var f = c.tag;
      if (f === 5 || f === 26 || f === 27 || f === 6) return c.stateNode;
      throw Error(r(33));
    }
    function na(c) {
      var f = c[bm];
      return f || (f = c[bm] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), f;
    }
    function $n(c) {
      c[hl] = !0;
    }
    var xm = /* @__PURE__ */ new Set(), wm = {};
    function ra(c, f) {
      ss(c, f), ss(c + "Capture", f);
    }
    function ss(c, f) {
      for (wm[c] = f, c = 0; c < f.length; c++)
        xm.add(f[c]);
    }
    var j1 = RegExp(
      "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), Vf = {}, Sm = {};
    function D1(c) {
      return ee.call(Sm, c) ? !0 : ee.call(Vf, c) ? !1 : j1.test(c) ? Sm[c] = !0 : (Vf[c] = !0, !1);
    }
    function Ac(c, f, m) {
      if (D1(f))
        if (m === null) c.removeAttribute(f);
        else {
          switch (typeof m) {
            case "undefined":
            case "function":
            case "symbol":
              c.removeAttribute(f);
              return;
            case "boolean":
              var w = f.toLowerCase().slice(0, 5);
              if (w !== "data-" && w !== "aria-") {
                c.removeAttribute(f);
                return;
              }
          }
          c.setAttribute(f, "" + m);
        }
    }
    function Nc(c, f, m) {
      if (m === null) c.removeAttribute(f);
      else {
        switch (typeof m) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            c.removeAttribute(f);
            return;
        }
        c.setAttribute(f, "" + m);
      }
    }
    function Io(c, f, m, w) {
      if (w === null) c.removeAttribute(m);
      else {
        switch (typeof w) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            c.removeAttribute(m);
            return;
        }
        c.setAttributeNS(f, m, "" + w);
      }
    }
    var Hf, _m;
    function oa(c) {
      if (Hf === void 0)
        try {
          throw Error();
        } catch (m) {
          var f = m.stack.trim().match(/\n( *(at )?)/);
          Hf = f && f[1] || "", _m = -1 < m.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < m.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return `
` + Hf + c + _m;
    }
    var qf = !1;
    function Wf(c, f) {
      if (!c || qf) return "";
      qf = !0;
      var m = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        var w = {
          DetermineComponentFrameRoot: function() {
            try {
              if (f) {
                var we = function() {
                  throw Error();
                };
                if (Object.defineProperty(we.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                }), typeof Reflect == "object" && Reflect.construct) {
                  try {
                    Reflect.construct(we, []);
                  } catch (me) {
                    var he = me;
                  }
                  Reflect.construct(c, [], we);
                } else {
                  try {
                    we.call();
                  } catch (me) {
                    he = me;
                  }
                  c.call(we.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (me) {
                  he = me;
                }
                (we = c()) && typeof we.catch == "function" && we.catch(function() {
                });
              }
            } catch (me) {
              if (me && he && typeof me.stack == "string")
                return [me.stack, he.stack];
            }
            return [null, null];
          }
        };
        w.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var O = Object.getOwnPropertyDescriptor(
          w.DetermineComponentFrameRoot,
          "name"
        );
        O && O.configurable && Object.defineProperty(
          w.DetermineComponentFrameRoot,
          "name",
          { value: "DetermineComponentFrameRoot" }
        );
        var N = w.DetermineComponentFrameRoot(), q = N[0], Z = N[1];
        if (q && Z) {
          var ne = q.split(`
`), pe = Z.split(`
`);
          for (O = w = 0; w < ne.length && !ne[w].includes("DetermineComponentFrameRoot"); )
            w++;
          for (; O < pe.length && !pe[O].includes(
            "DetermineComponentFrameRoot"
          ); )
            O++;
          if (w === ne.length || O === pe.length)
            for (w = ne.length - 1, O = pe.length - 1; 1 <= w && 0 <= O && ne[w] !== pe[O]; )
              O--;
          for (; 1 <= w && 0 <= O; w--, O--)
            if (ne[w] !== pe[O]) {
              if (w !== 1 || O !== 1)
                do
                  if (w--, O--, 0 > O || ne[w] !== pe[O]) {
                    var be = `
` + ne[w].replace(" at new ", " at ");
                    return c.displayName && be.includes("<anonymous>") && (be = be.replace("<anonymous>", c.displayName)), be;
                  }
                while (1 <= w && 0 <= O);
              break;
            }
        }
      } finally {
        qf = !1, Error.prepareStackTrace = m;
      }
      return (m = c ? c.displayName || c.name : "") ? oa(m) : "";
    }
    function F1(c) {
      switch (c.tag) {
        case 26:
        case 27:
        case 5:
          return oa(c.type);
        case 16:
          return oa("Lazy");
        case 13:
          return oa("Suspense");
        case 19:
          return oa("SuspenseList");
        case 0:
        case 15:
          return Wf(c.type, !1);
        case 11:
          return Wf(c.type.render, !1);
        case 1:
          return Wf(c.type, !0);
        case 31:
          return oa("Activity");
        default:
          return "";
      }
    }
    function Em(c) {
      try {
        var f = "";
        do
          f += F1(c), c = c.return;
        while (c);
        return f;
      } catch (m) {
        return `
Error generating stack: ` + m.message + `
` + m.stack;
      }
    }
    function Nr(c) {
      switch (typeof c) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return c;
        case "object":
          return c;
        default:
          return "";
      }
    }
    function Cm(c) {
      var f = c.type;
      return (c = c.nodeName) && c.toLowerCase() === "input" && (f === "checkbox" || f === "radio");
    }
    function L1(c) {
      var f = Cm(c) ? "checked" : "value", m = Object.getOwnPropertyDescriptor(
        c.constructor.prototype,
        f
      ), w = "" + c[f];
      if (!c.hasOwnProperty(f) && typeof m < "u" && typeof m.get == "function" && typeof m.set == "function") {
        var O = m.get, N = m.set;
        return Object.defineProperty(c, f, {
          configurable: !0,
          get: function() {
            return O.call(this);
          },
          set: function(q) {
            w = "" + q, N.call(this, q);
          }
        }), Object.defineProperty(c, f, {
          enumerable: m.enumerable
        }), {
          getValue: function() {
            return w;
          },
          setValue: function(q) {
            w = "" + q;
          },
          stopTracking: function() {
            c._valueTracker = null, delete c[f];
          }
        };
      }
    }
    function Mc(c) {
      c._valueTracker || (c._valueTracker = L1(c));
    }
    function Gf(c) {
      if (!c) return !1;
      var f = c._valueTracker;
      if (!f) return !0;
      var m = f.getValue(), w = "";
      return c && (w = Cm(c) ? c.checked ? "true" : "false" : c.value), c = w, c !== m ? (f.setValue(c), !0) : !1;
    }
    function Pc(c) {
      if (c = c || (typeof document < "u" ? document : void 0), typeof c > "u") return null;
      try {
        return c.activeElement || c.body;
      } catch {
        return c.body;
      }
    }
    var z1 = /[\n"\\]/g;
    function Mr(c) {
      return c.replace(
        z1,
        function(f) {
          return "\\" + f.charCodeAt(0).toString(16) + " ";
        }
      );
    }
    function ml(c, f, m, w, O, N, q, Z) {
      c.name = "", q != null && typeof q != "function" && typeof q != "symbol" && typeof q != "boolean" ? c.type = q : c.removeAttribute("type"), f != null ? q === "number" ? (f === 0 && c.value === "" || c.value != f) && (c.value = "" + Nr(f)) : c.value !== "" + Nr(f) && (c.value = "" + Nr(f)) : q !== "submit" && q !== "reset" || c.removeAttribute("value"), f != null ? Kf(c, q, Nr(f)) : m != null ? Kf(c, q, Nr(m)) : w != null && c.removeAttribute("value"), O == null && N != null && (c.defaultChecked = !!N), O != null && (c.checked = O && typeof O != "function" && typeof O != "symbol"), Z != null && typeof Z != "function" && typeof Z != "symbol" && typeof Z != "boolean" ? c.name = "" + Nr(Z) : c.removeAttribute("name");
    }
    function km(c, f, m, w, O, N, q, Z) {
      if (N != null && typeof N != "function" && typeof N != "symbol" && typeof N != "boolean" && (c.type = N), f != null || m != null) {
        if (!(N !== "submit" && N !== "reset" || f != null))
          return;
        m = m != null ? "" + Nr(m) : "", f = f != null ? "" + Nr(f) : m, Z || f === c.value || (c.value = f), c.defaultValue = f;
      }
      w = w ?? O, w = typeof w != "function" && typeof w != "symbol" && !!w, c.checked = Z ? c.checked : !!w, c.defaultChecked = !!w, q != null && typeof q != "function" && typeof q != "symbol" && typeof q != "boolean" && (c.name = q);
    }
    function Kf(c, f, m) {
      f === "number" && Pc(c.ownerDocument) === c || c.defaultValue === "" + m || (c.defaultValue = "" + m);
    }
    function ia(c, f, m, w) {
      if (c = c.options, f) {
        f = {};
        for (var O = 0; O < m.length; O++)
          f["$" + m[O]] = !0;
        for (m = 0; m < c.length; m++)
          O = f.hasOwnProperty("$" + c[m].value), c[m].selected !== O && (c[m].selected = O), O && w && (c[m].defaultSelected = !0);
      } else {
        for (m = "" + Nr(m), f = null, O = 0; O < c.length; O++) {
          if (c[O].value === m) {
            c[O].selected = !0, w && (c[O].defaultSelected = !0);
            return;
          }
          f !== null || c[O].disabled || (f = c[O]);
        }
        f !== null && (f.selected = !0);
      }
    }
    function CO(c, f, m) {
      if (f != null && (f = "" + Nr(f), f !== c.value && (c.value = f), m == null)) {
        c.defaultValue !== f && (c.defaultValue = f);
        return;
      }
      c.defaultValue = m != null ? "" + Nr(m) : "";
    }
    function kO(c, f, m, w) {
      if (f == null) {
        if (w != null) {
          if (m != null) throw Error(r(92));
          if (V(w)) {
            if (1 < w.length) throw Error(r(93));
            w = w[0];
          }
          m = w;
        }
        m == null && (m = ""), f = m;
      }
      m = Nr(f), c.defaultValue = m, w = c.textContent, w === m && w !== "" && w !== null && (c.value = w);
    }
    function $c(c, f) {
      if (f) {
        var m = c.firstChild;
        if (m && m === c.lastChild && m.nodeType === 3) {
          m.nodeValue = f;
          return;
        }
      }
      c.textContent = f;
    }
    var uq = new Set(
      "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
        " "
      )
    );
    function TO(c, f, m) {
      var w = f.indexOf("--") === 0;
      m == null || typeof m == "boolean" || m === "" ? w ? c.setProperty(f, "") : f === "float" ? c.cssFloat = "" : c[f] = "" : w ? c.setProperty(f, m) : typeof m != "number" || m === 0 || uq.has(f) ? f === "float" ? c.cssFloat = m : c[f] = ("" + m).trim() : c[f] = m + "px";
    }
    function RO(c, f, m) {
      if (f != null && typeof f != "object")
        throw Error(r(62));
      if (c = c.style, m != null) {
        for (var w in m)
          !m.hasOwnProperty(w) || f != null && f.hasOwnProperty(w) || (w.indexOf("--") === 0 ? c.setProperty(w, "") : w === "float" ? c.cssFloat = "" : c[w] = "");
        for (var O in f)
          w = f[O], f.hasOwnProperty(O) && m[O] !== w && TO(c, O, w);
      } else
        for (var N in f)
          f.hasOwnProperty(N) && TO(c, N, f[N]);
    }
    function B1(c) {
      if (c.indexOf("-") === -1) return !1;
      switch (c) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var fq = /* @__PURE__ */ new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"]
    ]), dq = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function Tm(c) {
      return dq.test("" + c) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : c;
    }
    var U1 = null;
    function V1(c) {
      return c = c.target || c.srcElement || window, c.correspondingUseElement && (c = c.correspondingUseElement), c.nodeType === 3 ? c.parentNode : c;
    }
    var Ic = null, jc = null;
    function OO(c) {
      var f = ta(c);
      if (f && (c = f.stateNode)) {
        var m = c[ur] || null;
        e: switch (c = f.stateNode, f.type) {
          case "input":
            if (ml(
              c,
              m.value,
              m.defaultValue,
              m.defaultValue,
              m.checked,
              m.defaultChecked,
              m.type,
              m.name
            ), f = m.name, m.type === "radio" && f != null) {
              for (m = c; m.parentNode; ) m = m.parentNode;
              for (m = m.querySelectorAll(
                'input[name="' + Mr(
                  "" + f
                ) + '"][type="radio"]'
              ), f = 0; f < m.length; f++) {
                var w = m[f];
                if (w !== c && w.form === c.form) {
                  var O = w[ur] || null;
                  if (!O) throw Error(r(90));
                  ml(
                    w,
                    O.value,
                    O.defaultValue,
                    O.defaultValue,
                    O.checked,
                    O.defaultChecked,
                    O.type,
                    O.name
                  );
                }
              }
              for (f = 0; f < m.length; f++)
                w = m[f], w.form === c.form && Gf(w);
            }
            break e;
          case "textarea":
            CO(c, m.value, m.defaultValue);
            break e;
          case "select":
            f = m.value, f != null && ia(c, !!m.multiple, f, !1);
        }
      }
    }
    var H1 = !1;
    function AO(c, f, m) {
      if (H1) return c(f, m);
      H1 = !0;
      try {
        var w = c(f);
        return w;
      } finally {
        if (H1 = !1, (Ic !== null || jc !== null) && (dg(), Ic && (f = Ic, c = jc, jc = Ic = null, OO(f), c)))
          for (f = 0; f < c.length; f++) OO(c[f]);
      }
    }
    function Yf(c, f) {
      var m = c.stateNode;
      if (m === null) return null;
      var w = m[ur] || null;
      if (w === null) return null;
      m = w[f];
      e: switch (f) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (w = !w.disabled) || (c = c.type, w = !(c === "button" || c === "input" || c === "select" || c === "textarea")), c = !w;
          break e;
        default:
          c = !1;
      }
      if (c) return null;
      if (m && typeof m != "function")
        throw Error(
          r(231, f, typeof m)
        );
      return m;
    }
    var aa = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), q1 = !1;
    if (aa)
      try {
        var Xf = {};
        Object.defineProperty(Xf, "passive", {
          get: function() {
            q1 = !0;
          }
        }), window.addEventListener("test", Xf, Xf), window.removeEventListener("test", Xf, Xf);
      } catch {
        q1 = !1;
      }
    var ls = null, W1 = null, Rm = null;
    function NO() {
      if (Rm) return Rm;
      var c, f = W1, m = f.length, w, O = "value" in ls ? ls.value : ls.textContent, N = O.length;
      for (c = 0; c < m && f[c] === O[c]; c++) ;
      var q = m - c;
      for (w = 1; w <= q && f[m - w] === O[N - w]; w++) ;
      return Rm = O.slice(c, 1 < w ? 1 - w : void 0);
    }
    function Om(c) {
      var f = c.keyCode;
      return "charCode" in c ? (c = c.charCode, c === 0 && f === 13 && (c = 13)) : c = f, c === 10 && (c = 13), 32 <= c || c === 13 ? c : 0;
    }
    function Am() {
      return !0;
    }
    function MO() {
      return !1;
    }
    function Pr(c) {
      function f(m, w, O, N, q) {
        this._reactName = m, this._targetInst = O, this.type = w, this.nativeEvent = N, this.target = q, this.currentTarget = null;
        for (var Z in c)
          c.hasOwnProperty(Z) && (m = c[Z], this[Z] = m ? m(N) : N[Z]);
        return this.isDefaultPrevented = (N.defaultPrevented != null ? N.defaultPrevented : N.returnValue === !1) ? Am : MO, this.isPropagationStopped = MO, this;
      }
      return d(f.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var m = this.nativeEvent;
          m && (m.preventDefault ? m.preventDefault() : typeof m.returnValue != "unknown" && (m.returnValue = !1), this.isDefaultPrevented = Am);
        },
        stopPropagation: function() {
          var m = this.nativeEvent;
          m && (m.stopPropagation ? m.stopPropagation() : typeof m.cancelBubble != "unknown" && (m.cancelBubble = !0), this.isPropagationStopped = Am);
        },
        persist: function() {
        },
        isPersistent: Am
      }), f;
    }
    var gl = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(c) {
        return c.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, Nm = Pr(gl), Zf = d({}, gl, { view: 0, detail: 0 }), pq = Pr(Zf), G1, K1, Qf, Mm = d({}, Zf, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: X1,
      button: 0,
      buttons: 0,
      relatedTarget: function(c) {
        return c.relatedTarget === void 0 ? c.fromElement === c.srcElement ? c.toElement : c.fromElement : c.relatedTarget;
      },
      movementX: function(c) {
        return "movementX" in c ? c.movementX : (c !== Qf && (Qf && c.type === "mousemove" ? (G1 = c.screenX - Qf.screenX, K1 = c.screenY - Qf.screenY) : K1 = G1 = 0, Qf = c), G1);
      },
      movementY: function(c) {
        return "movementY" in c ? c.movementY : K1;
      }
    }), PO = Pr(Mm), hq = d({}, Mm, { dataTransfer: 0 }), mq = Pr(hq), gq = d({}, Zf, { relatedTarget: 0 }), Y1 = Pr(gq), yq = d({}, gl, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), vq = Pr(yq), bq = d({}, gl, {
      clipboardData: function(c) {
        return "clipboardData" in c ? c.clipboardData : window.clipboardData;
      }
    }), xq = Pr(bq), wq = d({}, gl, { data: 0 }), $O = Pr(wq), Sq = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, _q = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, Eq = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function Cq(c) {
      var f = this.nativeEvent;
      return f.getModifierState ? f.getModifierState(c) : (c = Eq[c]) ? !!f[c] : !1;
    }
    function X1() {
      return Cq;
    }
    var kq = d({}, Zf, {
      key: function(c) {
        if (c.key) {
          var f = Sq[c.key] || c.key;
          if (f !== "Unidentified") return f;
        }
        return c.type === "keypress" ? (c = Om(c), c === 13 ? "Enter" : String.fromCharCode(c)) : c.type === "keydown" || c.type === "keyup" ? _q[c.keyCode] || "Unidentified" : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: X1,
      charCode: function(c) {
        return c.type === "keypress" ? Om(c) : 0;
      },
      keyCode: function(c) {
        return c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0;
      },
      which: function(c) {
        return c.type === "keypress" ? Om(c) : c.type === "keydown" || c.type === "keyup" ? c.keyCode : 0;
      }
    }), Tq = Pr(kq), Rq = d({}, Mm, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), IO = Pr(Rq), Oq = d({}, Zf, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: X1
    }), Aq = Pr(Oq), Nq = d({}, gl, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Mq = Pr(Nq), Pq = d({}, Mm, {
      deltaX: function(c) {
        return "deltaX" in c ? c.deltaX : "wheelDeltaX" in c ? -c.wheelDeltaX : 0;
      },
      deltaY: function(c) {
        return "deltaY" in c ? c.deltaY : "wheelDeltaY" in c ? -c.wheelDeltaY : "wheelDelta" in c ? -c.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), $q = Pr(Pq), Iq = d({}, gl, {
      newState: 0,
      oldState: 0
    }), jq = Pr(Iq), Dq = [9, 13, 27, 32], Z1 = aa && "CompositionEvent" in window, Jf = null;
    aa && "documentMode" in document && (Jf = document.documentMode);
    var Fq = aa && "TextEvent" in window && !Jf, jO = aa && (!Z1 || Jf && 8 < Jf && 11 >= Jf), DO = " ", FO = !1;
    function LO(c, f) {
      switch (c) {
        case "keyup":
          return Dq.indexOf(f.keyCode) !== -1;
        case "keydown":
          return f.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function zO(c) {
      return c = c.detail, typeof c == "object" && "data" in c ? c.data : null;
    }
    var Dc = !1;
    function Lq(c, f) {
      switch (c) {
        case "compositionend":
          return zO(f);
        case "keypress":
          return f.which !== 32 ? null : (FO = !0, DO);
        case "textInput":
          return c = f.data, c === DO && FO ? null : c;
        default:
          return null;
      }
    }
    function zq(c, f) {
      if (Dc)
        return c === "compositionend" || !Z1 && LO(c, f) ? (c = NO(), Rm = W1 = ls = null, Dc = !1, c) : null;
      switch (c) {
        case "paste":
          return null;
        case "keypress":
          if (!(f.ctrlKey || f.altKey || f.metaKey) || f.ctrlKey && f.altKey) {
            if (f.char && 1 < f.char.length)
              return f.char;
            if (f.which) return String.fromCharCode(f.which);
          }
          return null;
        case "compositionend":
          return jO && f.locale !== "ko" ? null : f.data;
        default:
          return null;
      }
    }
    var Bq = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function BO(c) {
      var f = c && c.nodeName && c.nodeName.toLowerCase();
      return f === "input" ? !!Bq[c.type] : f === "textarea";
    }
    function UO(c, f, m, w) {
      Ic ? jc ? jc.push(w) : jc = [w] : Ic = w, f = vg(f, "onChange"), 0 < f.length && (m = new Nm(
        "onChange",
        "change",
        null,
        m,
        w
      ), c.push({ event: m, listeners: f }));
    }
    var ed = null, td = null;
    function Uq(c) {
      SM(c, 0);
    }
    function Pm(c) {
      var f = as(c);
      if (Gf(f)) return c;
    }
    function VO(c, f) {
      if (c === "change") return f;
    }
    var HO = !1;
    if (aa) {
      var Q1;
      if (aa) {
        var J1 = "oninput" in document;
        if (!J1) {
          var qO = document.createElement("div");
          qO.setAttribute("oninput", "return;"), J1 = typeof qO.oninput == "function";
        }
        Q1 = J1;
      } else Q1 = !1;
      HO = Q1 && (!document.documentMode || 9 < document.documentMode);
    }
    function WO() {
      ed && (ed.detachEvent("onpropertychange", GO), td = ed = null);
    }
    function GO(c) {
      if (c.propertyName === "value" && Pm(td)) {
        var f = [];
        UO(
          f,
          td,
          c,
          V1(c)
        ), AO(Uq, f);
      }
    }
    function Vq(c, f, m) {
      c === "focusin" ? (WO(), ed = f, td = m, ed.attachEvent("onpropertychange", GO)) : c === "focusout" && WO();
    }
    function Hq(c) {
      if (c === "selectionchange" || c === "keyup" || c === "keydown")
        return Pm(td);
    }
    function qq(c, f) {
      if (c === "click") return Pm(f);
    }
    function Wq(c, f) {
      if (c === "input" || c === "change")
        return Pm(f);
    }
    function Gq(c, f) {
      return c === f && (c !== 0 || 1 / c === 1 / f) || c !== c && f !== f;
    }
    var qr = typeof Object.is == "function" ? Object.is : Gq;
    function nd(c, f) {
      if (qr(c, f)) return !0;
      if (typeof c != "object" || c === null || typeof f != "object" || f === null)
        return !1;
      var m = Object.keys(c), w = Object.keys(f);
      if (m.length !== w.length) return !1;
      for (w = 0; w < m.length; w++) {
        var O = m[w];
        if (!ee.call(f, O) || !qr(c[O], f[O]))
          return !1;
      }
      return !0;
    }
    function KO(c) {
      for (; c && c.firstChild; ) c = c.firstChild;
      return c;
    }
    function YO(c, f) {
      var m = KO(c);
      c = 0;
      for (var w; m; ) {
        if (m.nodeType === 3) {
          if (w = c + m.textContent.length, c <= f && w >= f)
            return { node: m, offset: f - c };
          c = w;
        }
        e: {
          for (; m; ) {
            if (m.nextSibling) {
              m = m.nextSibling;
              break e;
            }
            m = m.parentNode;
          }
          m = void 0;
        }
        m = KO(m);
      }
    }
    function XO(c, f) {
      return c && f ? c === f ? !0 : c && c.nodeType === 3 ? !1 : f && f.nodeType === 3 ? XO(c, f.parentNode) : "contains" in c ? c.contains(f) : c.compareDocumentPosition ? !!(c.compareDocumentPosition(f) & 16) : !1 : !1;
    }
    function ZO(c) {
      c = c != null && c.ownerDocument != null && c.ownerDocument.defaultView != null ? c.ownerDocument.defaultView : window;
      for (var f = Pc(c.document); f instanceof c.HTMLIFrameElement; ) {
        try {
          var m = typeof f.contentWindow.location.href == "string";
        } catch {
          m = !1;
        }
        if (m) c = f.contentWindow;
        else break;
        f = Pc(c.document);
      }
      return f;
    }
    function ex(c) {
      var f = c && c.nodeName && c.nodeName.toLowerCase();
      return f && (f === "input" && (c.type === "text" || c.type === "search" || c.type === "tel" || c.type === "url" || c.type === "password") || f === "textarea" || c.contentEditable === "true");
    }
    var Kq = aa && "documentMode" in document && 11 >= document.documentMode, Fc = null, tx = null, rd = null, nx = !1;
    function QO(c, f, m) {
      var w = m.window === m ? m.document : m.nodeType === 9 ? m : m.ownerDocument;
      nx || Fc == null || Fc !== Pc(w) || (w = Fc, "selectionStart" in w && ex(w) ? w = { start: w.selectionStart, end: w.selectionEnd } : (w = (w.ownerDocument && w.ownerDocument.defaultView || window).getSelection(), w = {
        anchorNode: w.anchorNode,
        anchorOffset: w.anchorOffset,
        focusNode: w.focusNode,
        focusOffset: w.focusOffset
      }), rd && nd(rd, w) || (rd = w, w = vg(tx, "onSelect"), 0 < w.length && (f = new Nm(
        "onSelect",
        "select",
        null,
        f,
        m
      ), c.push({ event: f, listeners: w }), f.target = Fc)));
    }
    function yl(c, f) {
      var m = {};
      return m[c.toLowerCase()] = f.toLowerCase(), m["Webkit" + c] = "webkit" + f, m["Moz" + c] = "moz" + f, m;
    }
    var Lc = {
      animationend: yl("Animation", "AnimationEnd"),
      animationiteration: yl("Animation", "AnimationIteration"),
      animationstart: yl("Animation", "AnimationStart"),
      transitionrun: yl("Transition", "TransitionRun"),
      transitionstart: yl("Transition", "TransitionStart"),
      transitioncancel: yl("Transition", "TransitionCancel"),
      transitionend: yl("Transition", "TransitionEnd")
    }, rx = {}, JO = {};
    aa && (JO = document.createElement("div").style, "AnimationEvent" in window || (delete Lc.animationend.animation, delete Lc.animationiteration.animation, delete Lc.animationstart.animation), "TransitionEvent" in window || delete Lc.transitionend.transition);
    function vl(c) {
      if (rx[c]) return rx[c];
      if (!Lc[c]) return c;
      var f = Lc[c], m;
      for (m in f)
        if (f.hasOwnProperty(m) && m in JO)
          return rx[c] = f[m];
      return c;
    }
    var eA = vl("animationend"), tA = vl("animationiteration"), nA = vl("animationstart"), Yq = vl("transitionrun"), Xq = vl("transitionstart"), Zq = vl("transitioncancel"), rA = vl("transitionend"), oA = /* @__PURE__ */ new Map(), ox = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
    ox.push("scrollEnd");
    function jo(c, f) {
      oA.set(c, f), ra(f, [c]);
    }
    var iA = /* @__PURE__ */ new WeakMap();
    function ho(c, f) {
      if (typeof c == "object" && c !== null) {
        var m = iA.get(c);
        return m !== void 0 ? m : (f = {
          value: c,
          source: f,
          stack: Em(f)
        }, iA.set(c, f), f);
      }
      return {
        value: c,
        source: f,
        stack: Em(f)
      };
    }
    var mo = [], zc = 0, ix = 0;
    function $m() {
      for (var c = zc, f = ix = zc = 0; f < c; ) {
        var m = mo[f];
        mo[f++] = null;
        var w = mo[f];
        mo[f++] = null;
        var O = mo[f];
        mo[f++] = null;
        var N = mo[f];
        if (mo[f++] = null, w !== null && O !== null) {
          var q = w.pending;
          q === null ? O.next = O : (O.next = q.next, q.next = O), w.pending = O;
        }
        N !== 0 && aA(m, O, N);
      }
    }
    function Im(c, f, m, w) {
      mo[zc++] = c, mo[zc++] = f, mo[zc++] = m, mo[zc++] = w, ix |= w, c.lanes |= w, c = c.alternate, c !== null && (c.lanes |= w);
    }
    function ax(c, f, m, w) {
      return Im(c, f, m, w), jm(c);
    }
    function Bc(c, f) {
      return Im(c, null, null, f), jm(c);
    }
    function aA(c, f, m) {
      c.lanes |= m;
      var w = c.alternate;
      w !== null && (w.lanes |= m);
      for (var O = !1, N = c.return; N !== null; )
        N.childLanes |= m, w = N.alternate, w !== null && (w.childLanes |= m), N.tag === 22 && (c = N.stateNode, c === null || c._visibility & 1 || (O = !0)), c = N, N = N.return;
      return c.tag === 3 ? (N = c.stateNode, O && f !== null && (O = 31 - _e(m), c = N.hiddenUpdates, w = c[O], w === null ? c[O] = [f] : w.push(f), f.lane = m | 536870912), N) : null;
    }
    function jm(c) {
      if (50 < Rd)
        throw Rd = 0, dw = null, Error(r(185));
      for (var f = c.return; f !== null; )
        c = f, f = c.return;
      return c.tag === 3 ? c.stateNode : null;
    }
    var Uc = {};
    function Qq(c, f, m, w) {
      this.tag = c, this.key = m, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = f, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = w, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
    }
    function Wr(c, f, m, w) {
      return new Qq(c, f, m, w);
    }
    function sx(c) {
      return c = c.prototype, !(!c || !c.isReactComponent);
    }
    function sa(c, f) {
      var m = c.alternate;
      return m === null ? (m = Wr(
        c.tag,
        f,
        c.key,
        c.mode
      ), m.elementType = c.elementType, m.type = c.type, m.stateNode = c.stateNode, m.alternate = c, c.alternate = m) : (m.pendingProps = f, m.type = c.type, m.flags = 0, m.subtreeFlags = 0, m.deletions = null), m.flags = c.flags & 65011712, m.childLanes = c.childLanes, m.lanes = c.lanes, m.child = c.child, m.memoizedProps = c.memoizedProps, m.memoizedState = c.memoizedState, m.updateQueue = c.updateQueue, f = c.dependencies, m.dependencies = f === null ? null : { lanes: f.lanes, firstContext: f.firstContext }, m.sibling = c.sibling, m.index = c.index, m.ref = c.ref, m.refCleanup = c.refCleanup, m;
    }
    function sA(c, f) {
      c.flags &= 65011714;
      var m = c.alternate;
      return m === null ? (c.childLanes = 0, c.lanes = f, c.child = null, c.subtreeFlags = 0, c.memoizedProps = null, c.memoizedState = null, c.updateQueue = null, c.dependencies = null, c.stateNode = null) : (c.childLanes = m.childLanes, c.lanes = m.lanes, c.child = m.child, c.subtreeFlags = 0, c.deletions = null, c.memoizedProps = m.memoizedProps, c.memoizedState = m.memoizedState, c.updateQueue = m.updateQueue, c.type = m.type, f = m.dependencies, c.dependencies = f === null ? null : {
        lanes: f.lanes,
        firstContext: f.firstContext
      }), c;
    }
    function Dm(c, f, m, w, O, N) {
      var q = 0;
      if (w = c, typeof c == "function") sx(c) && (q = 1);
      else if (typeof c == "string")
        q = eG(
          c,
          m,
          H.current
        ) ? 26 : c === "html" || c === "head" || c === "body" ? 27 : 5;
      else
        e: switch (c) {
          case I:
            return c = Wr(31, m, f, O), c.elementType = I, c.lanes = N, c;
          case y:
            return bl(m.children, O, N, f);
          case b:
            q = 8, O |= 24;
            break;
          case v:
            return c = Wr(12, m, f, O | 2), c.elementType = v, c.lanes = N, c;
          case k:
            return c = Wr(13, m, f, O), c.elementType = k, c.lanes = N, c;
          case R:
            return c = Wr(19, m, f, O), c.elementType = R, c.lanes = N, c;
          default:
            if (typeof c == "object" && c !== null)
              switch (c.$$typeof) {
                case x:
                case _:
                  q = 10;
                  break e;
                case E:
                  q = 9;
                  break e;
                case C:
                  q = 11;
                  break e;
                case A:
                  q = 14;
                  break e;
                case M:
                  q = 16, w = null;
                  break e;
              }
            q = 29, m = Error(
              r(130, c === null ? "null" : typeof c, "")
            ), w = null;
        }
      return f = Wr(q, m, f, O), f.elementType = c, f.type = w, f.lanes = N, f;
    }
    function bl(c, f, m, w) {
      return c = Wr(7, c, w, f), c.lanes = m, c;
    }
    function lx(c, f, m) {
      return c = Wr(6, c, null, f), c.lanes = m, c;
    }
    function cx(c, f, m) {
      return f = Wr(
        4,
        c.children !== null ? c.children : [],
        c.key,
        f
      ), f.lanes = m, f.stateNode = {
        containerInfo: c.containerInfo,
        pendingChildren: null,
        implementation: c.implementation
      }, f;
    }
    var Vc = [], Hc = 0, Fm = null, Lm = 0, go = [], yo = 0, xl = null, la = 1, ca = "";
    function wl(c, f) {
      Vc[Hc++] = Lm, Vc[Hc++] = Fm, Fm = c, Lm = f;
    }
    function lA(c, f, m) {
      go[yo++] = la, go[yo++] = ca, go[yo++] = xl, xl = c;
      var w = la;
      c = ca;
      var O = 32 - _e(w) - 1;
      w &= ~(1 << O), m += 1;
      var N = 32 - _e(f) + O;
      if (30 < N) {
        var q = O - O % 5;
        N = (w & (1 << q) - 1).toString(32), w >>= q, O -= q, la = 1 << 32 - _e(f) + O | m << O | w, ca = N + c;
      } else
        la = 1 << N | m << O | w, ca = c;
    }
    function ux(c) {
      c.return !== null && (wl(c, 1), lA(c, 1, 0));
    }
    function fx(c) {
      for (; c === Fm; )
        Fm = Vc[--Hc], Vc[Hc] = null, Lm = Vc[--Hc], Vc[Hc] = null;
      for (; c === xl; )
        xl = go[--yo], go[yo] = null, ca = go[--yo], go[yo] = null, la = go[--yo], go[yo] = null;
    }
    var Er = null, _n = null, Lt = !1, Sl = null, si = !1, dx = Error(r(519));
    function _l(c) {
      var f = Error(r(418, ""));
      throw ad(ho(f, c)), dx;
    }
    function cA(c) {
      var f = c.stateNode, m = c.type, w = c.memoizedProps;
      switch (f[Yn] = c, f[ur] = w, m) {
        case "dialog":
          _t("cancel", f), _t("close", f);
          break;
        case "iframe":
        case "object":
        case "embed":
          _t("load", f);
          break;
        case "video":
        case "audio":
          for (m = 0; m < Ad.length; m++)
            _t(Ad[m], f);
          break;
        case "source":
          _t("error", f);
          break;
        case "img":
        case "image":
        case "link":
          _t("error", f), _t("load", f);
          break;
        case "details":
          _t("toggle", f);
          break;
        case "input":
          _t("invalid", f), km(
            f,
            w.value,
            w.defaultValue,
            w.checked,
            w.defaultChecked,
            w.type,
            w.name,
            !0
          ), Mc(f);
          break;
        case "select":
          _t("invalid", f);
          break;
        case "textarea":
          _t("invalid", f), kO(f, w.value, w.defaultValue, w.children), Mc(f);
      }
      m = w.children, typeof m != "string" && typeof m != "number" && typeof m != "bigint" || f.textContent === "" + m || w.suppressHydrationWarning === !0 || kM(f.textContent, m) ? (w.popover != null && (_t("beforetoggle", f), _t("toggle", f)), w.onScroll != null && _t("scroll", f), w.onScrollEnd != null && _t("scrollend", f), w.onClick != null && (f.onclick = bg), f = !0) : f = !1, f || _l(c);
    }
    function uA(c) {
      for (Er = c.return; Er; )
        switch (Er.tag) {
          case 5:
          case 13:
            si = !1;
            return;
          case 27:
          case 3:
            si = !0;
            return;
          default:
            Er = Er.return;
        }
    }
    function od(c) {
      if (c !== Er) return !1;
      if (!Lt) return uA(c), Lt = !0, !1;
      var f = c.tag, m;
      if ((m = f !== 3 && f !== 27) && ((m = f === 5) && (m = c.type, m = !(m !== "form" && m !== "button") || Rw(c.type, c.memoizedProps)), m = !m), m && _n && _l(c), uA(c), f === 13) {
        if (c = c.memoizedState, c = c !== null ? c.dehydrated : null, !c) throw Error(r(317));
        e: {
          for (c = c.nextSibling, f = 0; c; ) {
            if (c.nodeType === 8)
              if (m = c.data, m === "/$") {
                if (f === 0) {
                  _n = Fo(c.nextSibling);
                  break e;
                }
                f--;
              } else
                m !== "$" && m !== "$!" && m !== "$?" || f++;
            c = c.nextSibling;
          }
          _n = null;
        }
      } else
        f === 27 ? (f = _n, Es(c.type) ? (c = Mw, Mw = null, _n = c) : _n = f) : _n = Er ? Fo(c.stateNode.nextSibling) : null;
      return !0;
    }
    function id() {
      _n = Er = null, Lt = !1;
    }
    function fA() {
      var c = Sl;
      return c !== null && (jr === null ? jr = c : jr.push.apply(
        jr,
        c
      ), Sl = null), c;
    }
    function ad(c) {
      Sl === null ? Sl = [c] : Sl.push(c);
    }
    var px = U(null), El = null, ua = null;
    function cs(c, f, m) {
      z(px, f._currentValue), f._currentValue = m;
    }
    function fa(c) {
      c._currentValue = px.current, X(px);
    }
    function hx(c, f, m) {
      for (; c !== null; ) {
        var w = c.alternate;
        if ((c.childLanes & f) !== f ? (c.childLanes |= f, w !== null && (w.childLanes |= f)) : w !== null && (w.childLanes & f) !== f && (w.childLanes |= f), c === m) break;
        c = c.return;
      }
    }
    function mx(c, f, m, w) {
      var O = c.child;
      for (O !== null && (O.return = c); O !== null; ) {
        var N = O.dependencies;
        if (N !== null) {
          var q = O.child;
          N = N.firstContext;
          e: for (; N !== null; ) {
            var Z = N;
            N = O;
            for (var ne = 0; ne < f.length; ne++)
              if (Z.context === f[ne]) {
                N.lanes |= m, Z = N.alternate, Z !== null && (Z.lanes |= m), hx(
                  N.return,
                  m,
                  c
                ), w || (q = null);
                break e;
              }
            N = Z.next;
          }
        } else if (O.tag === 18) {
          if (q = O.return, q === null) throw Error(r(341));
          q.lanes |= m, N = q.alternate, N !== null && (N.lanes |= m), hx(q, m, c), q = null;
        } else q = O.child;
        if (q !== null) q.return = O;
        else
          for (q = O; q !== null; ) {
            if (q === c) {
              q = null;
              break;
            }
            if (O = q.sibling, O !== null) {
              O.return = q.return, q = O;
              break;
            }
            q = q.return;
          }
        O = q;
      }
    }
    function sd(c, f, m, w) {
      c = null;
      for (var O = f, N = !1; O !== null; ) {
        if (!N) {
          if ((O.flags & 524288) !== 0) N = !0;
          else if ((O.flags & 262144) !== 0) break;
        }
        if (O.tag === 10) {
          var q = O.alternate;
          if (q === null) throw Error(r(387));
          if (q = q.memoizedProps, q !== null) {
            var Z = O.type;
            qr(O.pendingProps.value, q.value) || (c !== null ? c.push(Z) : c = [Z]);
          }
        } else if (O === re.current) {
          if (q = O.alternate, q === null) throw Error(r(387));
          q.memoizedState.memoizedState !== O.memoizedState.memoizedState && (c !== null ? c.push(jd) : c = [jd]);
        }
        O = O.return;
      }
      c !== null && mx(
        f,
        c,
        m,
        w
      ), f.flags |= 262144;
    }
    function zm(c) {
      for (c = c.firstContext; c !== null; ) {
        if (!qr(
          c.context._currentValue,
          c.memoizedValue
        ))
          return !0;
        c = c.next;
      }
      return !1;
    }
    function Cl(c) {
      El = c, ua = null, c = c.dependencies, c !== null && (c.firstContext = null);
    }
    function fr(c) {
      return dA(El, c);
    }
    function Bm(c, f) {
      return El === null && Cl(c), dA(c, f);
    }
    function dA(c, f) {
      var m = f._currentValue;
      if (f = { context: f, memoizedValue: m, next: null }, ua === null) {
        if (c === null) throw Error(r(308));
        ua = f, c.dependencies = { lanes: 0, firstContext: f }, c.flags |= 524288;
      } else ua = ua.next = f;
      return m;
    }
    var Jq = typeof AbortController < "u" ? AbortController : function() {
      var c = [], f = this.signal = {
        aborted: !1,
        addEventListener: function(m, w) {
          c.push(w);
        }
      };
      this.abort = function() {
        f.aborted = !0, c.forEach(function(m) {
          return m();
        });
      };
    }, eW = e.unstable_scheduleCallback, tW = e.unstable_NormalPriority, Hn = {
      $$typeof: _,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0
    };
    function gx() {
      return {
        controller: new Jq(),
        data: /* @__PURE__ */ new Map(),
        refCount: 0
      };
    }
    function ld(c) {
      c.refCount--, c.refCount === 0 && eW(tW, function() {
        c.controller.abort();
      });
    }
    var cd = null, yx = 0, qc = 0, Wc = null;
    function nW(c, f) {
      if (cd === null) {
        var m = cd = [];
        yx = 0, qc = bw(), Wc = {
          status: "pending",
          value: void 0,
          then: function(w) {
            m.push(w);
          }
        };
      }
      return yx++, f.then(pA, pA), f;
    }
    function pA() {
      if (--yx === 0 && cd !== null) {
        Wc !== null && (Wc.status = "fulfilled");
        var c = cd;
        cd = null, qc = 0, Wc = null;
        for (var f = 0; f < c.length; f++) (0, c[f])();
      }
    }
    function rW(c, f) {
      var m = [], w = {
        status: "pending",
        value: null,
        reason: null,
        then: function(O) {
          m.push(O);
        }
      };
      return c.then(
        function() {
          w.status = "fulfilled", w.value = f;
          for (var O = 0; O < m.length; O++) (0, m[O])(f);
        },
        function(O) {
          for (w.status = "rejected", w.reason = O, O = 0; O < m.length; O++)
            (0, m[O])(void 0);
        }
      ), w;
    }
    var hA = F.S;
    F.S = function(c, f) {
      typeof f == "object" && f !== null && typeof f.then == "function" && nW(c, f), hA !== null && hA(c, f);
    };
    var kl = U(null);
    function vx() {
      var c = kl.current;
      return c !== null ? c : ln.pooledCache;
    }
    function Um(c, f) {
      f === null ? z(kl, kl.current) : z(kl, f.pool);
    }
    function mA() {
      var c = vx();
      return c === null ? null : { parent: Hn._currentValue, pool: c };
    }
    var ud = Error(r(460)), gA = Error(r(474)), Vm = Error(r(542)), bx = { then: function() {
    } };
    function yA(c) {
      return c = c.status, c === "fulfilled" || c === "rejected";
    }
    function Hm() {
    }
    function vA(c, f, m) {
      switch (m = c[m], m === void 0 ? c.push(f) : m !== f && (f.then(Hm, Hm), f = m), f.status) {
        case "fulfilled":
          return f.value;
        case "rejected":
          throw c = f.reason, xA(c), c;
        default:
          if (typeof f.status == "string") f.then(Hm, Hm);
          else {
            if (c = ln, c !== null && 100 < c.shellSuspendCounter)
              throw Error(r(482));
            c = f, c.status = "pending", c.then(
              function(w) {
                if (f.status === "pending") {
                  var O = f;
                  O.status = "fulfilled", O.value = w;
                }
              },
              function(w) {
                if (f.status === "pending") {
                  var O = f;
                  O.status = "rejected", O.reason = w;
                }
              }
            );
          }
          switch (f.status) {
            case "fulfilled":
              return f.value;
            case "rejected":
              throw c = f.reason, xA(c), c;
          }
          throw fd = f, ud;
      }
    }
    var fd = null;
    function bA() {
      if (fd === null) throw Error(r(459));
      var c = fd;
      return fd = null, c;
    }
    function xA(c) {
      if (c === ud || c === Vm)
        throw Error(r(483));
    }
    var us = !1;
    function xx(c) {
      c.updateQueue = {
        baseState: c.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null
      };
    }
    function wx(c, f) {
      c = c.updateQueue, f.updateQueue === c && (f.updateQueue = {
        baseState: c.baseState,
        firstBaseUpdate: c.firstBaseUpdate,
        lastBaseUpdate: c.lastBaseUpdate,
        shared: c.shared,
        callbacks: null
      });
    }
    function fs(c) {
      return { lane: c, tag: 0, payload: null, callback: null, next: null };
    }
    function ds(c, f, m) {
      var w = c.updateQueue;
      if (w === null) return null;
      if (w = w.shared, (qt & 2) !== 0) {
        var O = w.pending;
        return O === null ? f.next = f : (f.next = O.next, O.next = f), w.pending = f, f = jm(c), aA(c, null, m), f;
      }
      return Im(c, w, f, m), jm(c);
    }
    function dd(c, f, m) {
      if (f = f.updateQueue, f !== null && (f = f.shared, (m & 4194048) !== 0)) {
        var w = f.lanes;
        w &= c.pendingLanes, m |= w, f.lanes = m, ii(c, m);
      }
    }
    function Sx(c, f) {
      var m = c.updateQueue, w = c.alternate;
      if (w !== null && (w = w.updateQueue, m === w)) {
        var O = null, N = null;
        if (m = m.firstBaseUpdate, m !== null) {
          do {
            var q = {
              lane: m.lane,
              tag: m.tag,
              payload: m.payload,
              callback: null,
              next: null
            };
            N === null ? O = N = q : N = N.next = q, m = m.next;
          } while (m !== null);
          N === null ? O = N = f : N = N.next = f;
        } else O = N = f;
        m = {
          baseState: w.baseState,
          firstBaseUpdate: O,
          lastBaseUpdate: N,
          shared: w.shared,
          callbacks: w.callbacks
        }, c.updateQueue = m;
        return;
      }
      c = m.lastBaseUpdate, c === null ? m.firstBaseUpdate = f : c.next = f, m.lastBaseUpdate = f;
    }
    var _x = !1;
    function pd() {
      if (_x) {
        var c = Wc;
        if (c !== null) throw c;
      }
    }
    function hd(c, f, m, w) {
      _x = !1;
      var O = c.updateQueue;
      us = !1;
      var N = O.firstBaseUpdate, q = O.lastBaseUpdate, Z = O.shared.pending;
      if (Z !== null) {
        O.shared.pending = null;
        var ne = Z, pe = ne.next;
        ne.next = null, q === null ? N = pe : q.next = pe, q = ne;
        var be = c.alternate;
        be !== null && (be = be.updateQueue, Z = be.lastBaseUpdate, Z !== q && (Z === null ? be.firstBaseUpdate = pe : Z.next = pe, be.lastBaseUpdate = ne));
      }
      if (N !== null) {
        var we = O.baseState;
        q = 0, be = pe = ne = null, Z = N;
        do {
          var he = Z.lane & -536870913, me = he !== Z.lane;
          if (me ? (Ot & he) === he : (w & he) === he) {
            he !== 0 && he === qc && (_x = !0), be !== null && (be = be.next = {
              lane: 0,
              tag: Z.tag,
              payload: Z.payload,
              callback: null,
              next: null
            });
            e: {
              var nt = c, Qe = Z;
              he = f;
              var en = m;
              switch (Qe.tag) {
                case 1:
                  if (nt = Qe.payload, typeof nt == "function") {
                    we = nt.call(en, we, he);
                    break e;
                  }
                  we = nt;
                  break e;
                case 3:
                  nt.flags = nt.flags & -65537 | 128;
                case 0:
                  if (nt = Qe.payload, he = typeof nt == "function" ? nt.call(en, we, he) : nt, he == null) break e;
                  we = d({}, we, he);
                  break e;
                case 2:
                  us = !0;
              }
            }
            he = Z.callback, he !== null && (c.flags |= 64, me && (c.flags |= 8192), me = O.callbacks, me === null ? O.callbacks = [he] : me.push(he));
          } else
            me = {
              lane: he,
              tag: Z.tag,
              payload: Z.payload,
              callback: Z.callback,
              next: null
            }, be === null ? (pe = be = me, ne = we) : be = be.next = me, q |= he;
          if (Z = Z.next, Z === null) {
            if (Z = O.shared.pending, Z === null)
              break;
            me = Z, Z = me.next, me.next = null, O.lastBaseUpdate = me, O.shared.pending = null;
          }
        } while (!0);
        be === null && (ne = we), O.baseState = ne, O.firstBaseUpdate = pe, O.lastBaseUpdate = be, N === null && (O.shared.lanes = 0), xs |= q, c.lanes = q, c.memoizedState = we;
      }
    }
    function wA(c, f) {
      if (typeof c != "function")
        throw Error(r(191, c));
      c.call(f);
    }
    function SA(c, f) {
      var m = c.callbacks;
      if (m !== null)
        for (c.callbacks = null, c = 0; c < m.length; c++)
          wA(m[c], f);
    }
    var Gc = U(null), qm = U(0);
    function _A(c, f) {
      c = va, z(qm, c), z(Gc, f), va = c | f.baseLanes;
    }
    function Ex() {
      z(qm, va), z(Gc, Gc.current);
    }
    function Cx() {
      va = qm.current, X(Gc), X(qm);
    }
    var ps = 0, pt = null, Qt = null, In = null, Wm = !1, Kc = !1, Tl = !1, Gm = 0, md = 0, Yc = null, oW = 0;
    function An() {
      throw Error(r(321));
    }
    function kx(c, f) {
      if (f === null) return !1;
      for (var m = 0; m < f.length && m < c.length; m++)
        if (!qr(c[m], f[m])) return !1;
      return !0;
    }
    function Tx(c, f, m, w, O, N) {
      return ps = N, pt = f, f.memoizedState = null, f.updateQueue = null, f.lanes = 0, F.H = c === null || c.memoizedState === null ? aN : sN, Tl = !1, N = m(w, O), Tl = !1, Kc && (N = CA(
        f,
        m,
        w,
        O
      )), EA(c), N;
    }
    function EA(c) {
      F.H = Jm;
      var f = Qt !== null && Qt.next !== null;
      if (ps = 0, In = Qt = pt = null, Wm = !1, md = 0, Yc = null, f) throw Error(r(300));
      c === null || Xn || (c = c.dependencies, c !== null && zm(c) && (Xn = !0));
    }
    function CA(c, f, m, w) {
      pt = c;
      var O = 0;
      do {
        if (Kc && (Yc = null), md = 0, Kc = !1, 25 <= O) throw Error(r(301));
        if (O += 1, In = Qt = null, c.updateQueue != null) {
          var N = c.updateQueue;
          N.lastEffect = null, N.events = null, N.stores = null, N.memoCache != null && (N.memoCache.index = 0);
        }
        F.H = fW, N = f(m, w);
      } while (Kc);
      return N;
    }
    function iW() {
      var c = F.H, f = c.useState()[0];
      return f = typeof f.then == "function" ? gd(f) : f, c = c.useState()[0], (Qt !== null ? Qt.memoizedState : null) !== c && (pt.flags |= 1024), f;
    }
    function Rx() {
      var c = Gm !== 0;
      return Gm = 0, c;
    }
    function Ox(c, f, m) {
      f.updateQueue = c.updateQueue, f.flags &= -2053, c.lanes &= ~m;
    }
    function Ax(c) {
      if (Wm) {
        for (c = c.memoizedState; c !== null; ) {
          var f = c.queue;
          f !== null && (f.pending = null), c = c.next;
        }
        Wm = !1;
      }
      ps = 0, In = Qt = pt = null, Kc = !1, md = Gm = 0, Yc = null;
    }
    function $r() {
      var c = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return In === null ? pt.memoizedState = In = c : In = In.next = c, In;
    }
    function jn() {
      if (Qt === null) {
        var c = pt.alternate;
        c = c !== null ? c.memoizedState : null;
      } else c = Qt.next;
      var f = In === null ? pt.memoizedState : In.next;
      if (f !== null)
        In = f, Qt = c;
      else {
        if (c === null)
          throw pt.alternate === null ? Error(r(467)) : Error(r(310));
        Qt = c, c = {
          memoizedState: Qt.memoizedState,
          baseState: Qt.baseState,
          baseQueue: Qt.baseQueue,
          queue: Qt.queue,
          next: null
        }, In === null ? pt.memoizedState = In = c : In = In.next = c;
      }
      return In;
    }
    function Nx() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }
    function gd(c) {
      var f = md;
      return md += 1, Yc === null && (Yc = []), c = vA(Yc, c, f), f = pt, (In === null ? f.memoizedState : In.next) === null && (f = f.alternate, F.H = f === null || f.memoizedState === null ? aN : sN), c;
    }
    function Km(c) {
      if (c !== null && typeof c == "object") {
        if (typeof c.then == "function") return gd(c);
        if (c.$$typeof === _) return fr(c);
      }
      throw Error(r(438, String(c)));
    }
    function Mx(c) {
      var f = null, m = pt.updateQueue;
      if (m !== null && (f = m.memoCache), f == null) {
        var w = pt.alternate;
        w !== null && (w = w.updateQueue, w !== null && (w = w.memoCache, w != null && (f = {
          data: w.data.map(function(O) {
            return O.slice();
          }),
          index: 0
        })));
      }
      if (f == null && (f = { data: [], index: 0 }), m === null && (m = Nx(), pt.updateQueue = m), m.memoCache = f, m = f.data[f.index], m === void 0)
        for (m = f.data[f.index] = Array(c), w = 0; w < c; w++)
          m[w] = D;
      return f.index++, m;
    }
    function da(c, f) {
      return typeof f == "function" ? f(c) : f;
    }
    function Ym(c) {
      var f = jn();
      return Px(f, Qt, c);
    }
    function Px(c, f, m) {
      var w = c.queue;
      if (w === null) throw Error(r(311));
      w.lastRenderedReducer = m;
      var O = c.baseQueue, N = w.pending;
      if (N !== null) {
        if (O !== null) {
          var q = O.next;
          O.next = N.next, N.next = q;
        }
        f.baseQueue = O = N, w.pending = null;
      }
      if (N = c.baseState, O === null) c.memoizedState = N;
      else {
        f = O.next;
        var Z = q = null, ne = null, pe = f, be = !1;
        do {
          var we = pe.lane & -536870913;
          if (we !== pe.lane ? (Ot & we) === we : (ps & we) === we) {
            var he = pe.revertLane;
            if (he === 0)
              ne !== null && (ne = ne.next = {
                lane: 0,
                revertLane: 0,
                action: pe.action,
                hasEagerState: pe.hasEagerState,
                eagerState: pe.eagerState,
                next: null
              }), we === qc && (be = !0);
            else if ((ps & he) === he) {
              pe = pe.next, he === qc && (be = !0);
              continue;
            } else
              we = {
                lane: 0,
                revertLane: pe.revertLane,
                action: pe.action,
                hasEagerState: pe.hasEagerState,
                eagerState: pe.eagerState,
                next: null
              }, ne === null ? (Z = ne = we, q = N) : ne = ne.next = we, pt.lanes |= he, xs |= he;
            we = pe.action, Tl && m(N, we), N = pe.hasEagerState ? pe.eagerState : m(N, we);
          } else
            he = {
              lane: we,
              revertLane: pe.revertLane,
              action: pe.action,
              hasEagerState: pe.hasEagerState,
              eagerState: pe.eagerState,
              next: null
            }, ne === null ? (Z = ne = he, q = N) : ne = ne.next = he, pt.lanes |= we, xs |= we;
          pe = pe.next;
        } while (pe !== null && pe !== f);
        if (ne === null ? q = N : ne.next = Z, !qr(N, c.memoizedState) && (Xn = !0, be && (m = Wc, m !== null)))
          throw m;
        c.memoizedState = N, c.baseState = q, c.baseQueue = ne, w.lastRenderedState = N;
      }
      return O === null && (w.lanes = 0), [c.memoizedState, w.dispatch];
    }
    function $x(c) {
      var f = jn(), m = f.queue;
      if (m === null) throw Error(r(311));
      m.lastRenderedReducer = c;
      var w = m.dispatch, O = m.pending, N = f.memoizedState;
      if (O !== null) {
        m.pending = null;
        var q = O = O.next;
        do
          N = c(N, q.action), q = q.next;
        while (q !== O);
        qr(N, f.memoizedState) || (Xn = !0), f.memoizedState = N, f.baseQueue === null && (f.baseState = N), m.lastRenderedState = N;
      }
      return [N, w];
    }
    function kA(c, f, m) {
      var w = pt, O = jn(), N = Lt;
      if (N) {
        if (m === void 0) throw Error(r(407));
        m = m();
      } else m = f();
      var q = !qr(
        (Qt || O).memoizedState,
        m
      );
      q && (O.memoizedState = m, Xn = !0), O = O.queue;
      var Z = OA.bind(null, w, O, c);
      if (yd(2048, 8, Z, [c]), O.getSnapshot !== f || q || In !== null && In.memoizedState.tag & 1) {
        if (w.flags |= 2048, Xc(
          9,
          Xm(),
          RA.bind(
            null,
            w,
            O,
            m,
            f
          ),
          null
        ), ln === null) throw Error(r(349));
        N || (ps & 124) !== 0 || TA(w, f, m);
      }
      return m;
    }
    function TA(c, f, m) {
      c.flags |= 16384, c = { getSnapshot: f, value: m }, f = pt.updateQueue, f === null ? (f = Nx(), pt.updateQueue = f, f.stores = [c]) : (m = f.stores, m === null ? f.stores = [c] : m.push(c));
    }
    function RA(c, f, m, w) {
      f.value = m, f.getSnapshot = w, AA(f) && NA(c);
    }
    function OA(c, f, m) {
      return m(function() {
        AA(f) && NA(c);
      });
    }
    function AA(c) {
      var f = c.getSnapshot;
      c = c.value;
      try {
        var m = f();
        return !qr(c, m);
      } catch {
        return !0;
      }
    }
    function NA(c) {
      var f = Bc(c, 2);
      f !== null && Zr(f, c, 2);
    }
    function Ix(c) {
      var f = $r();
      if (typeof c == "function") {
        var m = c;
        if (c = m(), Tl) {
          Se(!0);
          try {
            m();
          } finally {
            Se(!1);
          }
        }
      }
      return f.memoizedState = f.baseState = c, f.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: da,
        lastRenderedState: c
      }, f;
    }
    function MA(c, f, m, w) {
      return c.baseState = m, Px(
        c,
        Qt,
        typeof w == "function" ? w : da
      );
    }
    function aW(c, f, m, w, O) {
      if (Qm(c)) throw Error(r(485));
      if (c = f.action, c !== null) {
        var N = {
          payload: O,
          action: c,
          next: null,
          isTransition: !0,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function(q) {
            N.listeners.push(q);
          }
        };
        F.T !== null ? m(!0) : N.isTransition = !1, w(N), m = f.pending, m === null ? (N.next = f.pending = N, PA(f, N)) : (N.next = m.next, f.pending = m.next = N);
      }
    }
    function PA(c, f) {
      var m = f.action, w = f.payload, O = c.state;
      if (f.isTransition) {
        var N = F.T, q = {};
        F.T = q;
        try {
          var Z = m(O, w), ne = F.S;
          ne !== null && ne(q, Z), $A(c, f, Z);
        } catch (pe) {
          jx(c, f, pe);
        } finally {
          F.T = N;
        }
      } else
        try {
          N = m(O, w), $A(c, f, N);
        } catch (pe) {
          jx(c, f, pe);
        }
    }
    function $A(c, f, m) {
      m !== null && typeof m == "object" && typeof m.then == "function" ? m.then(
        function(w) {
          IA(c, f, w);
        },
        function(w) {
          return jx(c, f, w);
        }
      ) : IA(c, f, m);
    }
    function IA(c, f, m) {
      f.status = "fulfilled", f.value = m, jA(f), c.state = m, f = c.pending, f !== null && (m = f.next, m === f ? c.pending = null : (m = m.next, f.next = m, PA(c, m)));
    }
    function jx(c, f, m) {
      var w = c.pending;
      if (c.pending = null, w !== null) {
        w = w.next;
        do
          f.status = "rejected", f.reason = m, jA(f), f = f.next;
        while (f !== w);
      }
      c.action = null;
    }
    function jA(c) {
      c = c.listeners;
      for (var f = 0; f < c.length; f++) (0, c[f])();
    }
    function DA(c, f) {
      return f;
    }
    function FA(c, f) {
      if (Lt) {
        var m = ln.formState;
        if (m !== null) {
          e: {
            var w = pt;
            if (Lt) {
              if (_n) {
                t: {
                  for (var O = _n, N = si; O.nodeType !== 8; ) {
                    if (!N) {
                      O = null;
                      break t;
                    }
                    if (O = Fo(
                      O.nextSibling
                    ), O === null) {
                      O = null;
                      break t;
                    }
                  }
                  N = O.data, O = N === "F!" || N === "F" ? O : null;
                }
                if (O) {
                  _n = Fo(
                    O.nextSibling
                  ), w = O.data === "F!";
                  break e;
                }
              }
              _l(w);
            }
            w = !1;
          }
          w && (f = m[0]);
        }
      }
      return m = $r(), m.memoizedState = m.baseState = f, w = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: DA,
        lastRenderedState: f
      }, m.queue = w, m = rN.bind(
        null,
        pt,
        w
      ), w.dispatch = m, w = Ix(!1), N = Bx.bind(
        null,
        pt,
        !1,
        w.queue
      ), w = $r(), O = {
        state: f,
        dispatch: null,
        action: c,
        pending: null
      }, w.queue = O, m = aW.bind(
        null,
        pt,
        O,
        N,
        m
      ), O.dispatch = m, w.memoizedState = c, [f, m, !1];
    }
    function LA(c) {
      var f = jn();
      return zA(f, Qt, c);
    }
    function zA(c, f, m) {
      if (f = Px(
        c,
        f,
        DA
      )[0], c = Ym(da)[0], typeof f == "object" && f !== null && typeof f.then == "function")
        try {
          var w = gd(f);
        } catch (q) {
          throw q === ud ? Vm : q;
        }
      else w = f;
      f = jn();
      var O = f.queue, N = O.dispatch;
      return m !== f.memoizedState && (pt.flags |= 2048, Xc(
        9,
        Xm(),
        sW.bind(null, O, m),
        null
      )), [w, N, c];
    }
    function sW(c, f) {
      c.action = f;
    }
    function BA(c) {
      var f = jn(), m = Qt;
      if (m !== null)
        return zA(f, m, c);
      jn(), f = f.memoizedState, m = jn();
      var w = m.queue.dispatch;
      return m.memoizedState = c, [f, w, !1];
    }
    function Xc(c, f, m, w) {
      return c = { tag: c, create: m, deps: w, inst: f, next: null }, f = pt.updateQueue, f === null && (f = Nx(), pt.updateQueue = f), m = f.lastEffect, m === null ? f.lastEffect = c.next = c : (w = m.next, m.next = c, c.next = w, f.lastEffect = c), c;
    }
    function Xm() {
      return { destroy: void 0, resource: void 0 };
    }
    function UA() {
      return jn().memoizedState;
    }
    function Zm(c, f, m, w) {
      var O = $r();
      w = w === void 0 ? null : w, pt.flags |= c, O.memoizedState = Xc(
        1 | f,
        Xm(),
        m,
        w
      );
    }
    function yd(c, f, m, w) {
      var O = jn();
      w = w === void 0 ? null : w;
      var N = O.memoizedState.inst;
      Qt !== null && w !== null && kx(w, Qt.memoizedState.deps) ? O.memoizedState = Xc(f, N, m, w) : (pt.flags |= c, O.memoizedState = Xc(
        1 | f,
        N,
        m,
        w
      ));
    }
    function VA(c, f) {
      Zm(8390656, 8, c, f);
    }
    function HA(c, f) {
      yd(2048, 8, c, f);
    }
    function qA(c, f) {
      return yd(4, 2, c, f);
    }
    function WA(c, f) {
      return yd(4, 4, c, f);
    }
    function GA(c, f) {
      if (typeof f == "function") {
        c = c();
        var m = f(c);
        return function() {
          typeof m == "function" ? m() : f(null);
        };
      }
      if (f != null)
        return c = c(), f.current = c, function() {
          f.current = null;
        };
    }
    function KA(c, f, m) {
      m = m != null ? m.concat([c]) : null, yd(4, 4, GA.bind(null, f, c), m);
    }
    function Dx() {
    }
    function YA(c, f) {
      var m = jn();
      f = f === void 0 ? null : f;
      var w = m.memoizedState;
      return f !== null && kx(f, w[1]) ? w[0] : (m.memoizedState = [c, f], c);
    }
    function XA(c, f) {
      var m = jn();
      f = f === void 0 ? null : f;
      var w = m.memoizedState;
      if (f !== null && kx(f, w[1]))
        return w[0];
      if (w = c(), Tl) {
        Se(!0);
        try {
          c();
        } finally {
          Se(!1);
        }
      }
      return m.memoizedState = [w, f], w;
    }
    function Fx(c, f, m) {
      return m === void 0 || (ps & 1073741824) !== 0 ? c.memoizedState = f : (c.memoizedState = m, c = JN(), pt.lanes |= c, xs |= c, m);
    }
    function ZA(c, f, m, w) {
      return qr(m, f) ? m : Gc.current !== null ? (c = Fx(c, m, w), qr(c, f) || (Xn = !0), c) : (ps & 42) === 0 ? (Xn = !0, c.memoizedState = m) : (c = JN(), pt.lanes |= c, xs |= c, f);
    }
    function QA(c, f, m, w, O) {
      var N = G.p;
      G.p = N !== 0 && 8 > N ? N : 8;
      var q = F.T, Z = {};
      F.T = Z, Bx(c, !1, f, m);
      try {
        var ne = O(), pe = F.S;
        if (pe !== null && pe(Z, ne), ne !== null && typeof ne == "object" && typeof ne.then == "function") {
          var be = rW(
            ne,
            w
          );
          vd(
            c,
            f,
            be,
            Xr(c)
          );
        } else
          vd(
            c,
            f,
            w,
            Xr(c)
          );
      } catch (we) {
        vd(
          c,
          f,
          { then: function() {
          }, status: "rejected", reason: we },
          Xr()
        );
      } finally {
        G.p = N, F.T = q;
      }
    }
    function lW() {
    }
    function Lx(c, f, m, w) {
      if (c.tag !== 5) throw Error(r(476));
      var O = JA(c).queue;
      QA(
        c,
        O,
        f,
        W,
        m === null ? lW : function() {
          return eN(c), m(w);
        }
      );
    }
    function JA(c) {
      var f = c.memoizedState;
      if (f !== null) return f;
      f = {
        memoizedState: W,
        baseState: W,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: da,
          lastRenderedState: W
        },
        next: null
      };
      var m = {};
      return f.next = {
        memoizedState: m,
        baseState: m,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: da,
          lastRenderedState: m
        },
        next: null
      }, c.memoizedState = f, c = c.alternate, c !== null && (c.memoizedState = f), f;
    }
    function eN(c) {
      var f = JA(c).next.queue;
      vd(c, f, {}, Xr());
    }
    function zx() {
      return fr(jd);
    }
    function tN() {
      return jn().memoizedState;
    }
    function nN() {
      return jn().memoizedState;
    }
    function cW(c) {
      for (var f = c.return; f !== null; ) {
        switch (f.tag) {
          case 24:
          case 3:
            var m = Xr();
            c = fs(m);
            var w = ds(f, c, m);
            w !== null && (Zr(w, f, m), dd(w, f, m)), f = { cache: gx() }, c.payload = f;
            return;
        }
        f = f.return;
      }
    }
    function uW(c, f, m) {
      var w = Xr();
      m = {
        lane: w,
        revertLane: 0,
        action: m,
        hasEagerState: !1,
        eagerState: null,
        next: null
      }, Qm(c) ? oN(f, m) : (m = ax(c, f, m, w), m !== null && (Zr(m, c, w), iN(m, f, w)));
    }
    function rN(c, f, m) {
      var w = Xr();
      vd(c, f, m, w);
    }
    function vd(c, f, m, w) {
      var O = {
        lane: w,
        revertLane: 0,
        action: m,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (Qm(c)) oN(f, O);
      else {
        var N = c.alternate;
        if (c.lanes === 0 && (N === null || N.lanes === 0) && (N = f.lastRenderedReducer, N !== null))
          try {
            var q = f.lastRenderedState, Z = N(q, m);
            if (O.hasEagerState = !0, O.eagerState = Z, qr(Z, q))
              return Im(c, f, O, 0), ln === null && $m(), !1;
          } catch {
          } finally {
          }
        if (m = ax(c, f, O, w), m !== null)
          return Zr(m, c, w), iN(m, f, w), !0;
      }
      return !1;
    }
    function Bx(c, f, m, w) {
      if (w = {
        lane: 2,
        revertLane: bw(),
        action: w,
        hasEagerState: !1,
        eagerState: null,
        next: null
      }, Qm(c)) {
        if (f) throw Error(r(479));
      } else
        f = ax(
          c,
          m,
          w,
          2
        ), f !== null && Zr(f, c, 2);
    }
    function Qm(c) {
      var f = c.alternate;
      return c === pt || f !== null && f === pt;
    }
    function oN(c, f) {
      Kc = Wm = !0;
      var m = c.pending;
      m === null ? f.next = f : (f.next = m.next, m.next = f), c.pending = f;
    }
    function iN(c, f, m) {
      if ((m & 4194048) !== 0) {
        var w = f.lanes;
        w &= c.pendingLanes, m |= w, f.lanes = m, ii(c, m);
      }
    }
    var Jm = {
      readContext: fr,
      use: Km,
      useCallback: An,
      useContext: An,
      useEffect: An,
      useImperativeHandle: An,
      useLayoutEffect: An,
      useInsertionEffect: An,
      useMemo: An,
      useReducer: An,
      useRef: An,
      useState: An,
      useDebugValue: An,
      useDeferredValue: An,
      useTransition: An,
      useSyncExternalStore: An,
      useId: An,
      useHostTransitionStatus: An,
      useFormState: An,
      useActionState: An,
      useOptimistic: An,
      useMemoCache: An,
      useCacheRefresh: An
    }, aN = {
      readContext: fr,
      use: Km,
      useCallback: function(c, f) {
        return $r().memoizedState = [
          c,
          f === void 0 ? null : f
        ], c;
      },
      useContext: fr,
      useEffect: VA,
      useImperativeHandle: function(c, f, m) {
        m = m != null ? m.concat([c]) : null, Zm(
          4194308,
          4,
          GA.bind(null, f, c),
          m
        );
      },
      useLayoutEffect: function(c, f) {
        return Zm(4194308, 4, c, f);
      },
      useInsertionEffect: function(c, f) {
        Zm(4, 2, c, f);
      },
      useMemo: function(c, f) {
        var m = $r();
        f = f === void 0 ? null : f;
        var w = c();
        if (Tl) {
          Se(!0);
          try {
            c();
          } finally {
            Se(!1);
          }
        }
        return m.memoizedState = [w, f], w;
      },
      useReducer: function(c, f, m) {
        var w = $r();
        if (m !== void 0) {
          var O = m(f);
          if (Tl) {
            Se(!0);
            try {
              m(f);
            } finally {
              Se(!1);
            }
          }
        } else O = f;
        return w.memoizedState = w.baseState = O, c = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: c,
          lastRenderedState: O
        }, w.queue = c, c = c.dispatch = uW.bind(
          null,
          pt,
          c
        ), [w.memoizedState, c];
      },
      useRef: function(c) {
        var f = $r();
        return c = { current: c }, f.memoizedState = c;
      },
      useState: function(c) {
        c = Ix(c);
        var f = c.queue, m = rN.bind(null, pt, f);
        return f.dispatch = m, [c.memoizedState, m];
      },
      useDebugValue: Dx,
      useDeferredValue: function(c, f) {
        var m = $r();
        return Fx(m, c, f);
      },
      useTransition: function() {
        var c = Ix(!1);
        return c = QA.bind(
          null,
          pt,
          c.queue,
          !0,
          !1
        ), $r().memoizedState = c, [!1, c];
      },
      useSyncExternalStore: function(c, f, m) {
        var w = pt, O = $r();
        if (Lt) {
          if (m === void 0)
            throw Error(r(407));
          m = m();
        } else {
          if (m = f(), ln === null)
            throw Error(r(349));
          (Ot & 124) !== 0 || TA(w, f, m);
        }
        O.memoizedState = m;
        var N = { value: m, getSnapshot: f };
        return O.queue = N, VA(OA.bind(null, w, N, c), [
          c
        ]), w.flags |= 2048, Xc(
          9,
          Xm(),
          RA.bind(
            null,
            w,
            N,
            m,
            f
          ),
          null
        ), m;
      },
      useId: function() {
        var c = $r(), f = ln.identifierPrefix;
        if (Lt) {
          var m = ca, w = la;
          m = (w & ~(1 << 32 - _e(w) - 1)).toString(32) + m, f = "" + f + "R" + m, m = Gm++, 0 < m && (f += "H" + m.toString(32)), f += "";
        } else
          m = oW++, f = "" + f + "r" + m.toString(32) + "";
        return c.memoizedState = f;
      },
      useHostTransitionStatus: zx,
      useFormState: FA,
      useActionState: FA,
      useOptimistic: function(c) {
        var f = $r();
        f.memoizedState = f.baseState = c;
        var m = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null
        };
        return f.queue = m, f = Bx.bind(
          null,
          pt,
          !0,
          m
        ), m.dispatch = f, [c, f];
      },
      useMemoCache: Mx,
      useCacheRefresh: function() {
        return $r().memoizedState = cW.bind(
          null,
          pt
        );
      }
    }, sN = {
      readContext: fr,
      use: Km,
      useCallback: YA,
      useContext: fr,
      useEffect: HA,
      useImperativeHandle: KA,
      useInsertionEffect: qA,
      useLayoutEffect: WA,
      useMemo: XA,
      useReducer: Ym,
      useRef: UA,
      useState: function() {
        return Ym(da);
      },
      useDebugValue: Dx,
      useDeferredValue: function(c, f) {
        var m = jn();
        return ZA(
          m,
          Qt.memoizedState,
          c,
          f
        );
      },
      useTransition: function() {
        var c = Ym(da)[0], f = jn().memoizedState;
        return [
          typeof c == "boolean" ? c : gd(c),
          f
        ];
      },
      useSyncExternalStore: kA,
      useId: tN,
      useHostTransitionStatus: zx,
      useFormState: LA,
      useActionState: LA,
      useOptimistic: function(c, f) {
        var m = jn();
        return MA(m, Qt, c, f);
      },
      useMemoCache: Mx,
      useCacheRefresh: nN
    }, fW = {
      readContext: fr,
      use: Km,
      useCallback: YA,
      useContext: fr,
      useEffect: HA,
      useImperativeHandle: KA,
      useInsertionEffect: qA,
      useLayoutEffect: WA,
      useMemo: XA,
      useReducer: $x,
      useRef: UA,
      useState: function() {
        return $x(da);
      },
      useDebugValue: Dx,
      useDeferredValue: function(c, f) {
        var m = jn();
        return Qt === null ? Fx(m, c, f) : ZA(
          m,
          Qt.memoizedState,
          c,
          f
        );
      },
      useTransition: function() {
        var c = $x(da)[0], f = jn().memoizedState;
        return [
          typeof c == "boolean" ? c : gd(c),
          f
        ];
      },
      useSyncExternalStore: kA,
      useId: tN,
      useHostTransitionStatus: zx,
      useFormState: BA,
      useActionState: BA,
      useOptimistic: function(c, f) {
        var m = jn();
        return Qt !== null ? MA(m, Qt, c, f) : (m.baseState = c, [c, m.queue.dispatch]);
      },
      useMemoCache: Mx,
      useCacheRefresh: nN
    }, Zc = null, bd = 0;
    function eg(c) {
      var f = bd;
      return bd += 1, Zc === null && (Zc = []), vA(Zc, c, f);
    }
    function xd(c, f) {
      f = f.props.ref, c.ref = f !== void 0 ? f : null;
    }
    function tg(c, f) {
      throw f.$$typeof === p ? Error(r(525)) : (c = Object.prototype.toString.call(f), Error(
        r(
          31,
          c === "[object Object]" ? "object with keys {" + Object.keys(f).join(", ") + "}" : c
        )
      ));
    }
    function lN(c) {
      var f = c._init;
      return f(c._payload);
    }
    function cN(c) {
      function f(ce, se) {
        if (c) {
          var de = ce.deletions;
          de === null ? (ce.deletions = [se], ce.flags |= 16) : de.push(se);
        }
      }
      function m(ce, se) {
        if (!c) return null;
        for (; se !== null; )
          f(ce, se), se = se.sibling;
        return null;
      }
      function w(ce) {
        for (var se = /* @__PURE__ */ new Map(); ce !== null; )
          ce.key !== null ? se.set(ce.key, ce) : se.set(ce.index, ce), ce = ce.sibling;
        return se;
      }
      function O(ce, se) {
        return ce = sa(ce, se), ce.index = 0, ce.sibling = null, ce;
      }
      function N(ce, se, de) {
        return ce.index = de, c ? (de = ce.alternate, de !== null ? (de = de.index, de < se ? (ce.flags |= 67108866, se) : de) : (ce.flags |= 67108866, se)) : (ce.flags |= 1048576, se);
      }
      function q(ce) {
        return c && ce.alternate === null && (ce.flags |= 67108866), ce;
      }
      function Z(ce, se, de, xe) {
        return se === null || se.tag !== 6 ? (se = lx(de, ce.mode, xe), se.return = ce, se) : (se = O(se, de), se.return = ce, se);
      }
      function ne(ce, se, de, xe) {
        var De = de.type;
        return De === y ? be(
          ce,
          se,
          de.props.children,
          xe,
          de.key
        ) : se !== null && (se.elementType === De || typeof De == "object" && De !== null && De.$$typeof === M && lN(De) === se.type) ? (se = O(se, de.props), xd(se, de), se.return = ce, se) : (se = Dm(
          de.type,
          de.key,
          de.props,
          null,
          ce.mode,
          xe
        ), xd(se, de), se.return = ce, se);
      }
      function pe(ce, se, de, xe) {
        return se === null || se.tag !== 4 || se.stateNode.containerInfo !== de.containerInfo || se.stateNode.implementation !== de.implementation ? (se = cx(de, ce.mode, xe), se.return = ce, se) : (se = O(se, de.children || []), se.return = ce, se);
      }
      function be(ce, se, de, xe, De) {
        return se === null || se.tag !== 7 ? (se = bl(
          de,
          ce.mode,
          xe,
          De
        ), se.return = ce, se) : (se = O(se, de), se.return = ce, se);
      }
      function we(ce, se, de) {
        if (typeof se == "string" && se !== "" || typeof se == "number" || typeof se == "bigint")
          return se = lx(
            "" + se,
            ce.mode,
            de
          ), se.return = ce, se;
        if (typeof se == "object" && se !== null) {
          switch (se.$$typeof) {
            case h:
              return de = Dm(
                se.type,
                se.key,
                se.props,
                null,
                ce.mode,
                de
              ), xd(de, se), de.return = ce, de;
            case g:
              return se = cx(
                se,
                ce.mode,
                de
              ), se.return = ce, se;
            case M:
              var xe = se._init;
              return se = xe(se._payload), we(ce, se, de);
          }
          if (V(se) || P(se))
            return se = bl(
              se,
              ce.mode,
              de,
              null
            ), se.return = ce, se;
          if (typeof se.then == "function")
            return we(ce, eg(se), de);
          if (se.$$typeof === _)
            return we(
              ce,
              Bm(ce, se),
              de
            );
          tg(ce, se);
        }
        return null;
      }
      function he(ce, se, de, xe) {
        var De = se !== null ? se.key : null;
        if (typeof de == "string" && de !== "" || typeof de == "number" || typeof de == "bigint")
          return De !== null ? null : Z(ce, se, "" + de, xe);
        if (typeof de == "object" && de !== null) {
          switch (de.$$typeof) {
            case h:
              return de.key === De ? ne(ce, se, de, xe) : null;
            case g:
              return de.key === De ? pe(ce, se, de, xe) : null;
            case M:
              return De = de._init, de = De(de._payload), he(ce, se, de, xe);
          }
          if (V(de) || P(de))
            return De !== null ? null : be(ce, se, de, xe, null);
          if (typeof de.then == "function")
            return he(
              ce,
              se,
              eg(de),
              xe
            );
          if (de.$$typeof === _)
            return he(
              ce,
              se,
              Bm(ce, de),
              xe
            );
          tg(ce, de);
        }
        return null;
      }
      function me(ce, se, de, xe, De) {
        if (typeof xe == "string" && xe !== "" || typeof xe == "number" || typeof xe == "bigint")
          return ce = ce.get(de) || null, Z(se, ce, "" + xe, De);
        if (typeof xe == "object" && xe !== null) {
          switch (xe.$$typeof) {
            case h:
              return ce = ce.get(
                xe.key === null ? de : xe.key
              ) || null, ne(se, ce, xe, De);
            case g:
              return ce = ce.get(
                xe.key === null ? de : xe.key
              ) || null, pe(se, ce, xe, De);
            case M:
              var vt = xe._init;
              return xe = vt(xe._payload), me(
                ce,
                se,
                de,
                xe,
                De
              );
          }
          if (V(xe) || P(xe))
            return ce = ce.get(de) || null, be(se, ce, xe, De, null);
          if (typeof xe.then == "function")
            return me(
              ce,
              se,
              de,
              eg(xe),
              De
            );
          if (xe.$$typeof === _)
            return me(
              ce,
              se,
              de,
              Bm(se, xe),
              De
            );
          tg(se, xe);
        }
        return null;
      }
      function nt(ce, se, de, xe) {
        for (var De = null, vt = null, Be = se, Je = se = 0, Qn = null; Be !== null && Je < de.length; Je++) {
          Be.index > Je ? (Qn = Be, Be = null) : Qn = Be.sibling;
          var $t = he(
            ce,
            Be,
            de[Je],
            xe
          );
          if ($t === null) {
            Be === null && (Be = Qn);
            break;
          }
          c && Be && $t.alternate === null && f(ce, Be), se = N($t, se, Je), vt === null ? De = $t : vt.sibling = $t, vt = $t, Be = Qn;
        }
        if (Je === de.length)
          return m(ce, Be), Lt && wl(ce, Je), De;
        if (Be === null) {
          for (; Je < de.length; Je++)
            Be = we(ce, de[Je], xe), Be !== null && (se = N(
              Be,
              se,
              Je
            ), vt === null ? De = Be : vt.sibling = Be, vt = Be);
          return Lt && wl(ce, Je), De;
        }
        for (Be = w(Be); Je < de.length; Je++)
          Qn = me(
            Be,
            ce,
            Je,
            de[Je],
            xe
          ), Qn !== null && (c && Qn.alternate !== null && Be.delete(
            Qn.key === null ? Je : Qn.key
          ), se = N(
            Qn,
            se,
            Je
          ), vt === null ? De = Qn : vt.sibling = Qn, vt = Qn);
        return c && Be.forEach(function(Os) {
          return f(ce, Os);
        }), Lt && wl(ce, Je), De;
      }
      function Qe(ce, se, de, xe) {
        if (de == null) throw Error(r(151));
        for (var De = null, vt = null, Be = se, Je = se = 0, Qn = null, $t = de.next(); Be !== null && !$t.done; Je++, $t = de.next()) {
          Be.index > Je ? (Qn = Be, Be = null) : Qn = Be.sibling;
          var Os = he(ce, Be, $t.value, xe);
          if (Os === null) {
            Be === null && (Be = Qn);
            break;
          }
          c && Be && Os.alternate === null && f(ce, Be), se = N(Os, se, Je), vt === null ? De = Os : vt.sibling = Os, vt = Os, Be = Qn;
        }
        if ($t.done)
          return m(ce, Be), Lt && wl(ce, Je), De;
        if (Be === null) {
          for (; !$t.done; Je++, $t = de.next())
            $t = we(ce, $t.value, xe), $t !== null && (se = N($t, se, Je), vt === null ? De = $t : vt.sibling = $t, vt = $t);
          return Lt && wl(ce, Je), De;
        }
        for (Be = w(Be); !$t.done; Je++, $t = de.next())
          $t = me(Be, ce, Je, $t.value, xe), $t !== null && (c && $t.alternate !== null && Be.delete($t.key === null ? Je : $t.key), se = N($t, se, Je), vt === null ? De = $t : vt.sibling = $t, vt = $t);
        return c && Be.forEach(function(dG) {
          return f(ce, dG);
        }), Lt && wl(ce, Je), De;
      }
      function en(ce, se, de, xe) {
        if (typeof de == "object" && de !== null && de.type === y && de.key === null && (de = de.props.children), typeof de == "object" && de !== null) {
          switch (de.$$typeof) {
            case h:
              e: {
                for (var De = de.key; se !== null; ) {
                  if (se.key === De) {
                    if (De = de.type, De === y) {
                      if (se.tag === 7) {
                        m(
                          ce,
                          se.sibling
                        ), xe = O(
                          se,
                          de.props.children
                        ), xe.return = ce, ce = xe;
                        break e;
                      }
                    } else if (se.elementType === De || typeof De == "object" && De !== null && De.$$typeof === M && lN(De) === se.type) {
                      m(
                        ce,
                        se.sibling
                      ), xe = O(se, de.props), xd(xe, de), xe.return = ce, ce = xe;
                      break e;
                    }
                    m(ce, se);
                    break;
                  } else f(ce, se);
                  se = se.sibling;
                }
                de.type === y ? (xe = bl(
                  de.props.children,
                  ce.mode,
                  xe,
                  de.key
                ), xe.return = ce, ce = xe) : (xe = Dm(
                  de.type,
                  de.key,
                  de.props,
                  null,
                  ce.mode,
                  xe
                ), xd(xe, de), xe.return = ce, ce = xe);
              }
              return q(ce);
            case g:
              e: {
                for (De = de.key; se !== null; ) {
                  if (se.key === De)
                    if (se.tag === 4 && se.stateNode.containerInfo === de.containerInfo && se.stateNode.implementation === de.implementation) {
                      m(
                        ce,
                        se.sibling
                      ), xe = O(se, de.children || []), xe.return = ce, ce = xe;
                      break e;
                    } else {
                      m(ce, se);
                      break;
                    }
                  else f(ce, se);
                  se = se.sibling;
                }
                xe = cx(de, ce.mode, xe), xe.return = ce, ce = xe;
              }
              return q(ce);
            case M:
              return De = de._init, de = De(de._payload), en(
                ce,
                se,
                de,
                xe
              );
          }
          if (V(de))
            return nt(
              ce,
              se,
              de,
              xe
            );
          if (P(de)) {
            if (De = P(de), typeof De != "function") throw Error(r(150));
            return de = De.call(de), Qe(
              ce,
              se,
              de,
              xe
            );
          }
          if (typeof de.then == "function")
            return en(
              ce,
              se,
              eg(de),
              xe
            );
          if (de.$$typeof === _)
            return en(
              ce,
              se,
              Bm(ce, de),
              xe
            );
          tg(ce, de);
        }
        return typeof de == "string" && de !== "" || typeof de == "number" || typeof de == "bigint" ? (de = "" + de, se !== null && se.tag === 6 ? (m(ce, se.sibling), xe = O(se, de), xe.return = ce, ce = xe) : (m(ce, se), xe = lx(de, ce.mode, xe), xe.return = ce, ce = xe), q(ce)) : m(ce, se);
      }
      return function(ce, se, de, xe) {
        try {
          bd = 0;
          var De = en(
            ce,
            se,
            de,
            xe
          );
          return Zc = null, De;
        } catch (Be) {
          if (Be === ud || Be === Vm) throw Be;
          var vt = Wr(29, Be, null, ce.mode);
          return vt.lanes = xe, vt.return = ce, vt;
        } finally {
        }
      };
    }
    var Qc = cN(!0), uN = cN(!1), vo = U(null), li = null;
    function hs(c) {
      var f = c.alternate;
      z(qn, qn.current & 1), z(vo, c), li === null && (f === null || Gc.current !== null || f.memoizedState !== null) && (li = c);
    }
    function fN(c) {
      if (c.tag === 22) {
        if (z(qn, qn.current), z(vo, c), li === null) {
          var f = c.alternate;
          f !== null && f.memoizedState !== null && (li = c);
        }
      } else ms();
    }
    function ms() {
      z(qn, qn.current), z(vo, vo.current);
    }
    function pa(c) {
      X(vo), li === c && (li = null), X(qn);
    }
    var qn = U(0);
    function ng(c) {
      for (var f = c; f !== null; ) {
        if (f.tag === 13) {
          var m = f.memoizedState;
          if (m !== null && (m = m.dehydrated, m === null || m.data === "$?" || Nw(m)))
            return f;
        } else if (f.tag === 19 && f.memoizedProps.revealOrder !== void 0) {
          if ((f.flags & 128) !== 0) return f;
        } else if (f.child !== null) {
          f.child.return = f, f = f.child;
          continue;
        }
        if (f === c) break;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === c) return null;
          f = f.return;
        }
        f.sibling.return = f.return, f = f.sibling;
      }
      return null;
    }
    function Ux(c, f, m, w) {
      f = c.memoizedState, m = m(w, f), m = m == null ? f : d({}, f, m), c.memoizedState = m, c.lanes === 0 && (c.updateQueue.baseState = m);
    }
    var Vx = {
      enqueueSetState: function(c, f, m) {
        c = c._reactInternals;
        var w = Xr(), O = fs(w);
        O.payload = f, m != null && (O.callback = m), f = ds(c, O, w), f !== null && (Zr(f, c, w), dd(f, c, w));
      },
      enqueueReplaceState: function(c, f, m) {
        c = c._reactInternals;
        var w = Xr(), O = fs(w);
        O.tag = 1, O.payload = f, m != null && (O.callback = m), f = ds(c, O, w), f !== null && (Zr(f, c, w), dd(f, c, w));
      },
      enqueueForceUpdate: function(c, f) {
        c = c._reactInternals;
        var m = Xr(), w = fs(m);
        w.tag = 2, f != null && (w.callback = f), f = ds(c, w, m), f !== null && (Zr(f, c, m), dd(f, c, m));
      }
    };
    function dN(c, f, m, w, O, N, q) {
      return c = c.stateNode, typeof c.shouldComponentUpdate == "function" ? c.shouldComponentUpdate(w, N, q) : f.prototype && f.prototype.isPureReactComponent ? !nd(m, w) || !nd(O, N) : !0;
    }
    function pN(c, f, m, w) {
      c = f.state, typeof f.componentWillReceiveProps == "function" && f.componentWillReceiveProps(m, w), typeof f.UNSAFE_componentWillReceiveProps == "function" && f.UNSAFE_componentWillReceiveProps(m, w), f.state !== c && Vx.enqueueReplaceState(f, f.state, null);
    }
    function Rl(c, f) {
      var m = f;
      if ("ref" in f) {
        m = {};
        for (var w in f)
          w !== "ref" && (m[w] = f[w]);
      }
      if (c = c.defaultProps) {
        m === f && (m = d({}, m));
        for (var O in c)
          m[O] === void 0 && (m[O] = c[O]);
      }
      return m;
    }
    var rg = typeof reportError == "function" ? reportError : function(c) {
      if (typeof window == "object" && typeof window.ErrorEvent == "function") {
        var f = new window.ErrorEvent("error", {
          bubbles: !0,
          cancelable: !0,
          message: typeof c == "object" && c !== null && typeof c.message == "string" ? String(c.message) : String(c),
          error: c
        });
        if (!window.dispatchEvent(f)) return;
      } else if (typeof process == "object" && typeof process.emit == "function") {
        process.emit("uncaughtException", c);
        return;
      }
      console.error(c);
    };
    function hN(c) {
      rg(c);
    }
    function mN(c) {
      console.error(c);
    }
    function gN(c) {
      rg(c);
    }
    function og(c, f) {
      try {
        var m = c.onUncaughtError;
        m(f.value, { componentStack: f.stack });
      } catch (w) {
        setTimeout(function() {
          throw w;
        });
      }
    }
    function yN(c, f, m) {
      try {
        var w = c.onCaughtError;
        w(m.value, {
          componentStack: m.stack,
          errorBoundary: f.tag === 1 ? f.stateNode : null
        });
      } catch (O) {
        setTimeout(function() {
          throw O;
        });
      }
    }
    function Hx(c, f, m) {
      return m = fs(m), m.tag = 3, m.payload = { element: null }, m.callback = function() {
        og(c, f);
      }, m;
    }
    function vN(c) {
      return c = fs(c), c.tag = 3, c;
    }
    function bN(c, f, m, w) {
      var O = m.type.getDerivedStateFromError;
      if (typeof O == "function") {
        var N = w.value;
        c.payload = function() {
          return O(N);
        }, c.callback = function() {
          yN(f, m, w);
        };
      }
      var q = m.stateNode;
      q !== null && typeof q.componentDidCatch == "function" && (c.callback = function() {
        yN(f, m, w), typeof O != "function" && (ws === null ? ws = /* @__PURE__ */ new Set([this]) : ws.add(this));
        var Z = w.stack;
        this.componentDidCatch(w.value, {
          componentStack: Z !== null ? Z : ""
        });
      });
    }
    function dW(c, f, m, w, O) {
      if (m.flags |= 32768, w !== null && typeof w == "object" && typeof w.then == "function") {
        if (f = m.alternate, f !== null && sd(
          f,
          m,
          O,
          !0
        ), m = vo.current, m !== null) {
          switch (m.tag) {
            case 13:
              return li === null ? hw() : m.alternate === null && En === 0 && (En = 3), m.flags &= -257, m.flags |= 65536, m.lanes = O, w === bx ? m.flags |= 16384 : (f = m.updateQueue, f === null ? m.updateQueue = /* @__PURE__ */ new Set([w]) : f.add(w), gw(c, w, O)), !1;
            case 22:
              return m.flags |= 65536, w === bx ? m.flags |= 16384 : (f = m.updateQueue, f === null ? (f = {
                transitions: null,
                markerInstances: null,
                retryQueue: /* @__PURE__ */ new Set([w])
              }, m.updateQueue = f) : (m = f.retryQueue, m === null ? f.retryQueue = /* @__PURE__ */ new Set([w]) : m.add(w)), gw(c, w, O)), !1;
          }
          throw Error(r(435, m.tag));
        }
        return gw(c, w, O), hw(), !1;
      }
      if (Lt)
        return f = vo.current, f !== null ? ((f.flags & 65536) === 0 && (f.flags |= 256), f.flags |= 65536, f.lanes = O, w !== dx && (c = Error(r(422), { cause: w }), ad(ho(c, m)))) : (w !== dx && (f = Error(r(423), {
          cause: w
        }), ad(
          ho(f, m)
        )), c = c.current.alternate, c.flags |= 65536, O &= -O, c.lanes |= O, w = ho(w, m), O = Hx(
          c.stateNode,
          w,
          O
        ), Sx(c, O), En !== 4 && (En = 2)), !1;
      var N = Error(r(520), { cause: w });
      if (N = ho(N, m), Td === null ? Td = [N] : Td.push(N), En !== 4 && (En = 2), f === null) return !0;
      w = ho(w, m), m = f;
      do {
        switch (m.tag) {
          case 3:
            return m.flags |= 65536, c = O & -O, m.lanes |= c, c = Hx(m.stateNode, w, c), Sx(m, c), !1;
          case 1:
            if (f = m.type, N = m.stateNode, (m.flags & 128) === 0 && (typeof f.getDerivedStateFromError == "function" || N !== null && typeof N.componentDidCatch == "function" && (ws === null || !ws.has(N))))
              return m.flags |= 65536, O &= -O, m.lanes |= O, O = vN(O), bN(
                O,
                c,
                m,
                w
              ), Sx(m, O), !1;
        }
        m = m.return;
      } while (m !== null);
      return !1;
    }
    var xN = Error(r(461)), Xn = !1;
    function nr(c, f, m, w) {
      f.child = c === null ? uN(f, null, m, w) : Qc(
        f,
        c.child,
        m,
        w
      );
    }
    function wN(c, f, m, w, O) {
      m = m.render;
      var N = f.ref;
      if ("ref" in w) {
        var q = {};
        for (var Z in w)
          Z !== "ref" && (q[Z] = w[Z]);
      } else q = w;
      return Cl(f), w = Tx(
        c,
        f,
        m,
        q,
        N,
        O
      ), Z = Rx(), c !== null && !Xn ? (Ox(c, f, O), ha(c, f, O)) : (Lt && Z && ux(f), f.flags |= 1, nr(c, f, w, O), f.child);
    }
    function SN(c, f, m, w, O) {
      if (c === null) {
        var N = m.type;
        return typeof N == "function" && !sx(N) && N.defaultProps === void 0 && m.compare === null ? (f.tag = 15, f.type = N, _N(
          c,
          f,
          N,
          w,
          O
        )) : (c = Dm(
          m.type,
          null,
          w,
          f,
          f.mode,
          O
        ), c.ref = f.ref, c.return = f, f.child = c);
      }
      if (N = c.child, !Qx(c, O)) {
        var q = N.memoizedProps;
        if (m = m.compare, m = m !== null ? m : nd, m(q, w) && c.ref === f.ref)
          return ha(c, f, O);
      }
      return f.flags |= 1, c = sa(N, w), c.ref = f.ref, c.return = f, f.child = c;
    }
    function _N(c, f, m, w, O) {
      if (c !== null) {
        var N = c.memoizedProps;
        if (nd(N, w) && c.ref === f.ref)
          if (Xn = !1, f.pendingProps = w = N, Qx(c, O))
            (c.flags & 131072) !== 0 && (Xn = !0);
          else
            return f.lanes = c.lanes, ha(c, f, O);
      }
      return qx(
        c,
        f,
        m,
        w,
        O
      );
    }
    function EN(c, f, m) {
      var w = f.pendingProps, O = w.children, N = c !== null ? c.memoizedState : null;
      if (w.mode === "hidden") {
        if ((f.flags & 128) !== 0) {
          if (w = N !== null ? N.baseLanes | m : m, c !== null) {
            for (O = f.child = c.child, N = 0; O !== null; )
              N = N | O.lanes | O.childLanes, O = O.sibling;
            f.childLanes = N & ~w;
          } else f.childLanes = 0, f.child = null;
          return CN(
            c,
            f,
            w,
            m
          );
        }
        if ((m & 536870912) !== 0)
          f.memoizedState = { baseLanes: 0, cachePool: null }, c !== null && Um(
            f,
            N !== null ? N.cachePool : null
          ), N !== null ? _A(f, N) : Ex(), fN(f);
        else
          return f.lanes = f.childLanes = 536870912, CN(
            c,
            f,
            N !== null ? N.baseLanes | m : m,
            m
          );
      } else
        N !== null ? (Um(f, N.cachePool), _A(f, N), ms(), f.memoizedState = null) : (c !== null && Um(f, null), Ex(), ms());
      return nr(c, f, O, m), f.child;
    }
    function CN(c, f, m, w) {
      var O = vx();
      return O = O === null ? null : { parent: Hn._currentValue, pool: O }, f.memoizedState = {
        baseLanes: m,
        cachePool: O
      }, c !== null && Um(f, null), Ex(), fN(f), c !== null && sd(c, f, w, !0), null;
    }
    function ig(c, f) {
      var m = f.ref;
      if (m === null)
        c !== null && c.ref !== null && (f.flags |= 4194816);
      else {
        if (typeof m != "function" && typeof m != "object")
          throw Error(r(284));
        (c === null || c.ref !== m) && (f.flags |= 4194816);
      }
    }
    function qx(c, f, m, w, O) {
      return Cl(f), m = Tx(
        c,
        f,
        m,
        w,
        void 0,
        O
      ), w = Rx(), c !== null && !Xn ? (Ox(c, f, O), ha(c, f, O)) : (Lt && w && ux(f), f.flags |= 1, nr(c, f, m, O), f.child);
    }
    function kN(c, f, m, w, O, N) {
      return Cl(f), f.updateQueue = null, m = CA(
        f,
        w,
        m,
        O
      ), EA(c), w = Rx(), c !== null && !Xn ? (Ox(c, f, N), ha(c, f, N)) : (Lt && w && ux(f), f.flags |= 1, nr(c, f, m, N), f.child);
    }
    function TN(c, f, m, w, O) {
      if (Cl(f), f.stateNode === null) {
        var N = Uc, q = m.contextType;
        typeof q == "object" && q !== null && (N = fr(q)), N = new m(w, N), f.memoizedState = N.state !== null && N.state !== void 0 ? N.state : null, N.updater = Vx, f.stateNode = N, N._reactInternals = f, N = f.stateNode, N.props = w, N.state = f.memoizedState, N.refs = {}, xx(f), q = m.contextType, N.context = typeof q == "object" && q !== null ? fr(q) : Uc, N.state = f.memoizedState, q = m.getDerivedStateFromProps, typeof q == "function" && (Ux(
          f,
          m,
          q,
          w
        ), N.state = f.memoizedState), typeof m.getDerivedStateFromProps == "function" || typeof N.getSnapshotBeforeUpdate == "function" || typeof N.UNSAFE_componentWillMount != "function" && typeof N.componentWillMount != "function" || (q = N.state, typeof N.componentWillMount == "function" && N.componentWillMount(), typeof N.UNSAFE_componentWillMount == "function" && N.UNSAFE_componentWillMount(), q !== N.state && Vx.enqueueReplaceState(N, N.state, null), hd(f, w, N, O), pd(), N.state = f.memoizedState), typeof N.componentDidMount == "function" && (f.flags |= 4194308), w = !0;
      } else if (c === null) {
        N = f.stateNode;
        var Z = f.memoizedProps, ne = Rl(m, Z);
        N.props = ne;
        var pe = N.context, be = m.contextType;
        q = Uc, typeof be == "object" && be !== null && (q = fr(be));
        var we = m.getDerivedStateFromProps;
        be = typeof we == "function" || typeof N.getSnapshotBeforeUpdate == "function", Z = f.pendingProps !== Z, be || typeof N.UNSAFE_componentWillReceiveProps != "function" && typeof N.componentWillReceiveProps != "function" || (Z || pe !== q) && pN(
          f,
          N,
          w,
          q
        ), us = !1;
        var he = f.memoizedState;
        N.state = he, hd(f, w, N, O), pd(), pe = f.memoizedState, Z || he !== pe || us ? (typeof we == "function" && (Ux(
          f,
          m,
          we,
          w
        ), pe = f.memoizedState), (ne = us || dN(
          f,
          m,
          ne,
          w,
          he,
          pe,
          q
        )) ? (be || typeof N.UNSAFE_componentWillMount != "function" && typeof N.componentWillMount != "function" || (typeof N.componentWillMount == "function" && N.componentWillMount(), typeof N.UNSAFE_componentWillMount == "function" && N.UNSAFE_componentWillMount()), typeof N.componentDidMount == "function" && (f.flags |= 4194308)) : (typeof N.componentDidMount == "function" && (f.flags |= 4194308), f.memoizedProps = w, f.memoizedState = pe), N.props = w, N.state = pe, N.context = q, w = ne) : (typeof N.componentDidMount == "function" && (f.flags |= 4194308), w = !1);
      } else {
        N = f.stateNode, wx(c, f), q = f.memoizedProps, be = Rl(m, q), N.props = be, we = f.pendingProps, he = N.context, pe = m.contextType, ne = Uc, typeof pe == "object" && pe !== null && (ne = fr(pe)), Z = m.getDerivedStateFromProps, (pe = typeof Z == "function" || typeof N.getSnapshotBeforeUpdate == "function") || typeof N.UNSAFE_componentWillReceiveProps != "function" && typeof N.componentWillReceiveProps != "function" || (q !== we || he !== ne) && pN(
          f,
          N,
          w,
          ne
        ), us = !1, he = f.memoizedState, N.state = he, hd(f, w, N, O), pd();
        var me = f.memoizedState;
        q !== we || he !== me || us || c !== null && c.dependencies !== null && zm(c.dependencies) ? (typeof Z == "function" && (Ux(
          f,
          m,
          Z,
          w
        ), me = f.memoizedState), (be = us || dN(
          f,
          m,
          be,
          w,
          he,
          me,
          ne
        ) || c !== null && c.dependencies !== null && zm(c.dependencies)) ? (pe || typeof N.UNSAFE_componentWillUpdate != "function" && typeof N.componentWillUpdate != "function" || (typeof N.componentWillUpdate == "function" && N.componentWillUpdate(w, me, ne), typeof N.UNSAFE_componentWillUpdate == "function" && N.UNSAFE_componentWillUpdate(
          w,
          me,
          ne
        )), typeof N.componentDidUpdate == "function" && (f.flags |= 4), typeof N.getSnapshotBeforeUpdate == "function" && (f.flags |= 1024)) : (typeof N.componentDidUpdate != "function" || q === c.memoizedProps && he === c.memoizedState || (f.flags |= 4), typeof N.getSnapshotBeforeUpdate != "function" || q === c.memoizedProps && he === c.memoizedState || (f.flags |= 1024), f.memoizedProps = w, f.memoizedState = me), N.props = w, N.state = me, N.context = ne, w = be) : (typeof N.componentDidUpdate != "function" || q === c.memoizedProps && he === c.memoizedState || (f.flags |= 4), typeof N.getSnapshotBeforeUpdate != "function" || q === c.memoizedProps && he === c.memoizedState || (f.flags |= 1024), w = !1);
      }
      return N = w, ig(c, f), w = (f.flags & 128) !== 0, N || w ? (N = f.stateNode, m = w && typeof m.getDerivedStateFromError != "function" ? null : N.render(), f.flags |= 1, c !== null && w ? (f.child = Qc(
        f,
        c.child,
        null,
        O
      ), f.child = Qc(
        f,
        null,
        m,
        O
      )) : nr(c, f, m, O), f.memoizedState = N.state, c = f.child) : c = ha(
        c,
        f,
        O
      ), c;
    }
    function RN(c, f, m, w) {
      return id(), f.flags |= 256, nr(c, f, m, w), f.child;
    }
    var Wx = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null
    };
    function Gx(c) {
      return { baseLanes: c, cachePool: mA() };
    }
    function Kx(c, f, m) {
      return c = c !== null ? c.childLanes & ~m : 0, f && (c |= bo), c;
    }
    function ON(c, f, m) {
      var w = f.pendingProps, O = !1, N = (f.flags & 128) !== 0, q;
      if ((q = N) || (q = c !== null && c.memoizedState === null ? !1 : (qn.current & 2) !== 0), q && (O = !0, f.flags &= -129), q = (f.flags & 32) !== 0, f.flags &= -33, c === null) {
        if (Lt) {
          if (O ? hs(f) : ms(), Lt) {
            var Z = _n, ne;
            if (ne = Z) {
              e: {
                for (ne = Z, Z = si; ne.nodeType !== 8; ) {
                  if (!Z) {
                    Z = null;
                    break e;
                  }
                  if (ne = Fo(
                    ne.nextSibling
                  ), ne === null) {
                    Z = null;
                    break e;
                  }
                }
                Z = ne;
              }
              Z !== null ? (f.memoizedState = {
                dehydrated: Z,
                treeContext: xl !== null ? { id: la, overflow: ca } : null,
                retryLane: 536870912,
                hydrationErrors: null
              }, ne = Wr(
                18,
                null,
                null,
                0
              ), ne.stateNode = Z, ne.return = f, f.child = ne, Er = f, _n = null, ne = !0) : ne = !1;
            }
            ne || _l(f);
          }
          if (Z = f.memoizedState, Z !== null && (Z = Z.dehydrated, Z !== null))
            return Nw(Z) ? f.lanes = 32 : f.lanes = 536870912, null;
          pa(f);
        }
        return Z = w.children, w = w.fallback, O ? (ms(), O = f.mode, Z = ag(
          { mode: "hidden", children: Z },
          O
        ), w = bl(
          w,
          O,
          m,
          null
        ), Z.return = f, w.return = f, Z.sibling = w, f.child = Z, O = f.child, O.memoizedState = Gx(m), O.childLanes = Kx(
          c,
          q,
          m
        ), f.memoizedState = Wx, w) : (hs(f), Yx(f, Z));
      }
      if (ne = c.memoizedState, ne !== null && (Z = ne.dehydrated, Z !== null)) {
        if (N)
          f.flags & 256 ? (hs(f), f.flags &= -257, f = Xx(
            c,
            f,
            m
          )) : f.memoizedState !== null ? (ms(), f.child = c.child, f.flags |= 128, f = null) : (ms(), O = w.fallback, Z = f.mode, w = ag(
            { mode: "visible", children: w.children },
            Z
          ), O = bl(
            O,
            Z,
            m,
            null
          ), O.flags |= 2, w.return = f, O.return = f, w.sibling = O, f.child = w, Qc(
            f,
            c.child,
            null,
            m
          ), w = f.child, w.memoizedState = Gx(m), w.childLanes = Kx(
            c,
            q,
            m
          ), f.memoizedState = Wx, f = O);
        else if (hs(f), Nw(Z)) {
          if (q = Z.nextSibling && Z.nextSibling.dataset, q) var pe = q.dgst;
          q = pe, w = Error(r(419)), w.stack = "", w.digest = q, ad({ value: w, source: null, stack: null }), f = Xx(
            c,
            f,
            m
          );
        } else if (Xn || sd(c, f, m, !1), q = (m & c.childLanes) !== 0, Xn || q) {
          if (q = ln, q !== null && (w = m & -m, w = (w & 42) !== 0 ? 1 : _r(w), w = (w & (q.suspendedLanes | m)) !== 0 ? 0 : w, w !== 0 && w !== ne.retryLane))
            throw ne.retryLane = w, Bc(c, w), Zr(q, c, w), xN;
          Z.data === "$?" || hw(), f = Xx(
            c,
            f,
            m
          );
        } else
          Z.data === "$?" ? (f.flags |= 192, f.child = c.child, f = null) : (c = ne.treeContext, _n = Fo(
            Z.nextSibling
          ), Er = f, Lt = !0, Sl = null, si = !1, c !== null && (go[yo++] = la, go[yo++] = ca, go[yo++] = xl, la = c.id, ca = c.overflow, xl = f), f = Yx(
            f,
            w.children
          ), f.flags |= 4096);
        return f;
      }
      return O ? (ms(), O = w.fallback, Z = f.mode, ne = c.child, pe = ne.sibling, w = sa(ne, {
        mode: "hidden",
        children: w.children
      }), w.subtreeFlags = ne.subtreeFlags & 65011712, pe !== null ? O = sa(pe, O) : (O = bl(
        O,
        Z,
        m,
        null
      ), O.flags |= 2), O.return = f, w.return = f, w.sibling = O, f.child = w, w = O, O = f.child, Z = c.child.memoizedState, Z === null ? Z = Gx(m) : (ne = Z.cachePool, ne !== null ? (pe = Hn._currentValue, ne = ne.parent !== pe ? { parent: pe, pool: pe } : ne) : ne = mA(), Z = {
        baseLanes: Z.baseLanes | m,
        cachePool: ne
      }), O.memoizedState = Z, O.childLanes = Kx(
        c,
        q,
        m
      ), f.memoizedState = Wx, w) : (hs(f), m = c.child, c = m.sibling, m = sa(m, {
        mode: "visible",
        children: w.children
      }), m.return = f, m.sibling = null, c !== null && (q = f.deletions, q === null ? (f.deletions = [c], f.flags |= 16) : q.push(c)), f.child = m, f.memoizedState = null, m);
    }
    function Yx(c, f) {
      return f = ag(
        { mode: "visible", children: f },
        c.mode
      ), f.return = c, c.child = f;
    }
    function ag(c, f) {
      return c = Wr(22, c, null, f), c.lanes = 0, c.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      }, c;
    }
    function Xx(c, f, m) {
      return Qc(f, c.child, null, m), c = Yx(
        f,
        f.pendingProps.children
      ), c.flags |= 2, f.memoizedState = null, c;
    }
    function AN(c, f, m) {
      c.lanes |= f;
      var w = c.alternate;
      w !== null && (w.lanes |= f), hx(c.return, f, m);
    }
    function Zx(c, f, m, w, O) {
      var N = c.memoizedState;
      N === null ? c.memoizedState = {
        isBackwards: f,
        rendering: null,
        renderingStartTime: 0,
        last: w,
        tail: m,
        tailMode: O
      } : (N.isBackwards = f, N.rendering = null, N.renderingStartTime = 0, N.last = w, N.tail = m, N.tailMode = O);
    }
    function NN(c, f, m) {
      var w = f.pendingProps, O = w.revealOrder, N = w.tail;
      if (nr(c, f, w.children, m), w = qn.current, (w & 2) !== 0)
        w = w & 1 | 2, f.flags |= 128;
      else {
        if (c !== null && (c.flags & 128) !== 0)
          e: for (c = f.child; c !== null; ) {
            if (c.tag === 13)
              c.memoizedState !== null && AN(c, m, f);
            else if (c.tag === 19)
              AN(c, m, f);
            else if (c.child !== null) {
              c.child.return = c, c = c.child;
              continue;
            }
            if (c === f) break e;
            for (; c.sibling === null; ) {
              if (c.return === null || c.return === f)
                break e;
              c = c.return;
            }
            c.sibling.return = c.return, c = c.sibling;
          }
        w &= 1;
      }
      switch (z(qn, w), O) {
        case "forwards":
          for (m = f.child, O = null; m !== null; )
            c = m.alternate, c !== null && ng(c) === null && (O = m), m = m.sibling;
          m = O, m === null ? (O = f.child, f.child = null) : (O = m.sibling, m.sibling = null), Zx(
            f,
            !1,
            O,
            m,
            N
          );
          break;
        case "backwards":
          for (m = null, O = f.child, f.child = null; O !== null; ) {
            if (c = O.alternate, c !== null && ng(c) === null) {
              f.child = O;
              break;
            }
            c = O.sibling, O.sibling = m, m = O, O = c;
          }
          Zx(
            f,
            !0,
            m,
            null,
            N
          );
          break;
        case "together":
          Zx(f, !1, null, null, void 0);
          break;
        default:
          f.memoizedState = null;
      }
      return f.child;
    }
    function ha(c, f, m) {
      if (c !== null && (f.dependencies = c.dependencies), xs |= f.lanes, (m & f.childLanes) === 0)
        if (c !== null) {
          if (sd(
            c,
            f,
            m,
            !1
          ), (m & f.childLanes) === 0)
            return null;
        } else return null;
      if (c !== null && f.child !== c.child)
        throw Error(r(153));
      if (f.child !== null) {
        for (c = f.child, m = sa(c, c.pendingProps), f.child = m, m.return = f; c.sibling !== null; )
          c = c.sibling, m = m.sibling = sa(c, c.pendingProps), m.return = f;
        m.sibling = null;
      }
      return f.child;
    }
    function Qx(c, f) {
      return (c.lanes & f) !== 0 ? !0 : (c = c.dependencies, !!(c !== null && zm(c)));
    }
    function pW(c, f, m) {
      switch (f.tag) {
        case 3:
          te(f, f.stateNode.containerInfo), cs(f, Hn, c.memoizedState.cache), id();
          break;
        case 27:
        case 5:
          fe(f);
          break;
        case 4:
          te(f, f.stateNode.containerInfo);
          break;
        case 10:
          cs(
            f,
            f.type,
            f.memoizedProps.value
          );
          break;
        case 13:
          var w = f.memoizedState;
          if (w !== null)
            return w.dehydrated !== null ? (hs(f), f.flags |= 128, null) : (m & f.child.childLanes) !== 0 ? ON(c, f, m) : (hs(f), c = ha(
              c,
              f,
              m
            ), c !== null ? c.sibling : null);
          hs(f);
          break;
        case 19:
          var O = (c.flags & 128) !== 0;
          if (w = (m & f.childLanes) !== 0, w || (sd(
            c,
            f,
            m,
            !1
          ), w = (m & f.childLanes) !== 0), O) {
            if (w)
              return NN(
                c,
                f,
                m
              );
            f.flags |= 128;
          }
          if (O = f.memoizedState, O !== null && (O.rendering = null, O.tail = null, O.lastEffect = null), z(qn, qn.current), w) break;
          return null;
        case 22:
        case 23:
          return f.lanes = 0, EN(c, f, m);
        case 24:
          cs(f, Hn, c.memoizedState.cache);
      }
      return ha(c, f, m);
    }
    function MN(c, f, m) {
      if (c !== null)
        if (c.memoizedProps !== f.pendingProps)
          Xn = !0;
        else {
          if (!Qx(c, m) && (f.flags & 128) === 0)
            return Xn = !1, pW(
              c,
              f,
              m
            );
          Xn = (c.flags & 131072) !== 0;
        }
      else
        Xn = !1, Lt && (f.flags & 1048576) !== 0 && lA(f, Lm, f.index);
      switch (f.lanes = 0, f.tag) {
        case 16:
          e: {
            c = f.pendingProps;
            var w = f.elementType, O = w._init;
            if (w = O(w._payload), f.type = w, typeof w == "function")
              sx(w) ? (c = Rl(w, c), f.tag = 1, f = TN(
                null,
                f,
                w,
                c,
                m
              )) : (f.tag = 0, f = qx(
                null,
                f,
                w,
                c,
                m
              ));
            else {
              if (w != null) {
                if (O = w.$$typeof, O === C) {
                  f.tag = 11, f = wN(
                    null,
                    f,
                    w,
                    c,
                    m
                  );
                  break e;
                } else if (O === A) {
                  f.tag = 14, f = SN(
                    null,
                    f,
                    w,
                    c,
                    m
                  );
                  break e;
                }
              }
              throw f = j(w) || w, Error(r(306, f, ""));
            }
          }
          return f;
        case 0:
          return qx(
            c,
            f,
            f.type,
            f.pendingProps,
            m
          );
        case 1:
          return w = f.type, O = Rl(
            w,
            f.pendingProps
          ), TN(
            c,
            f,
            w,
            O,
            m
          );
        case 3:
          e: {
            if (te(
              f,
              f.stateNode.containerInfo
            ), c === null) throw Error(r(387));
            w = f.pendingProps;
            var N = f.memoizedState;
            O = N.element, wx(c, f), hd(f, w, null, m);
            var q = f.memoizedState;
            if (w = q.cache, cs(f, Hn, w), w !== N.cache && mx(
              f,
              [Hn],
              m,
              !0
            ), pd(), w = q.element, N.isDehydrated)
              if (N = {
                element: w,
                isDehydrated: !1,
                cache: q.cache
              }, f.updateQueue.baseState = N, f.memoizedState = N, f.flags & 256) {
                f = RN(
                  c,
                  f,
                  w,
                  m
                );
                break e;
              } else if (w !== O) {
                O = ho(
                  Error(r(424)),
                  f
                ), ad(O), f = RN(
                  c,
                  f,
                  w,
                  m
                );
                break e;
              } else {
                switch (c = f.stateNode.containerInfo, c.nodeType) {
                  case 9:
                    c = c.body;
                    break;
                  default:
                    c = c.nodeName === "HTML" ? c.ownerDocument.body : c;
                }
                for (_n = Fo(c.firstChild), Er = f, Lt = !0, Sl = null, si = !0, m = uN(
                  f,
                  null,
                  w,
                  m
                ), f.child = m; m; )
                  m.flags = m.flags & -3 | 4096, m = m.sibling;
              }
            else {
              if (id(), w === O) {
                f = ha(
                  c,
                  f,
                  m
                );
                break e;
              }
              nr(
                c,
                f,
                w,
                m
              );
            }
            f = f.child;
          }
          return f;
        case 26:
          return ig(c, f), c === null ? (m = jM(
            f.type,
            null,
            f.pendingProps,
            null
          )) ? f.memoizedState = m : Lt || (m = f.type, c = f.pendingProps, w = xg(
            Q.current
          ).createElement(m), w[Yn] = f, w[ur] = c, or(w, m, c), $n(w), f.stateNode = w) : f.memoizedState = jM(
            f.type,
            c.memoizedProps,
            f.pendingProps,
            c.memoizedState
          ), null;
        case 27:
          return fe(f), c === null && Lt && (w = f.stateNode = PM(
            f.type,
            f.pendingProps,
            Q.current
          ), Er = f, si = !0, O = _n, Es(f.type) ? (Mw = O, _n = Fo(
            w.firstChild
          )) : _n = O), nr(
            c,
            f,
            f.pendingProps.children,
            m
          ), ig(c, f), c === null && (f.flags |= 4194304), f.child;
        case 5:
          return c === null && Lt && ((O = w = _n) && (w = BW(
            w,
            f.type,
            f.pendingProps,
            si
          ), w !== null ? (f.stateNode = w, Er = f, _n = Fo(
            w.firstChild
          ), si = !1, O = !0) : O = !1), O || _l(f)), fe(f), O = f.type, N = f.pendingProps, q = c !== null ? c.memoizedProps : null, w = N.children, Rw(O, N) ? w = null : q !== null && Rw(O, q) && (f.flags |= 32), f.memoizedState !== null && (O = Tx(
            c,
            f,
            iW,
            null,
            null,
            m
          ), jd._currentValue = O), ig(c, f), nr(c, f, w, m), f.child;
        case 6:
          return c === null && Lt && ((c = m = _n) && (m = UW(
            m,
            f.pendingProps,
            si
          ), m !== null ? (f.stateNode = m, Er = f, _n = null, c = !0) : c = !1), c || _l(f)), null;
        case 13:
          return ON(c, f, m);
        case 4:
          return te(
            f,
            f.stateNode.containerInfo
          ), w = f.pendingProps, c === null ? f.child = Qc(
            f,
            null,
            w,
            m
          ) : nr(
            c,
            f,
            w,
            m
          ), f.child;
        case 11:
          return wN(
            c,
            f,
            f.type,
            f.pendingProps,
            m
          );
        case 7:
          return nr(
            c,
            f,
            f.pendingProps,
            m
          ), f.child;
        case 8:
          return nr(
            c,
            f,
            f.pendingProps.children,
            m
          ), f.child;
        case 12:
          return nr(
            c,
            f,
            f.pendingProps.children,
            m
          ), f.child;
        case 10:
          return w = f.pendingProps, cs(f, f.type, w.value), nr(
            c,
            f,
            w.children,
            m
          ), f.child;
        case 9:
          return O = f.type._context, w = f.pendingProps.children, Cl(f), O = fr(O), w = w(O), f.flags |= 1, nr(c, f, w, m), f.child;
        case 14:
          return SN(
            c,
            f,
            f.type,
            f.pendingProps,
            m
          );
        case 15:
          return _N(
            c,
            f,
            f.type,
            f.pendingProps,
            m
          );
        case 19:
          return NN(c, f, m);
        case 31:
          return w = f.pendingProps, m = f.mode, w = {
            mode: w.mode,
            children: w.children
          }, c === null ? (m = ag(
            w,
            m
          ), m.ref = f.ref, f.child = m, m.return = f, f = m) : (m = sa(c.child, w), m.ref = f.ref, f.child = m, m.return = f, f = m), f;
        case 22:
          return EN(c, f, m);
        case 24:
          return Cl(f), w = fr(Hn), c === null ? (O = vx(), O === null && (O = ln, N = gx(), O.pooledCache = N, N.refCount++, N !== null && (O.pooledCacheLanes |= m), O = N), f.memoizedState = {
            parent: w,
            cache: O
          }, xx(f), cs(f, Hn, O)) : ((c.lanes & m) !== 0 && (wx(c, f), hd(f, null, null, m), pd()), O = c.memoizedState, N = f.memoizedState, O.parent !== w ? (O = { parent: w, cache: w }, f.memoizedState = O, f.lanes === 0 && (f.memoizedState = f.updateQueue.baseState = O), cs(f, Hn, w)) : (w = N.cache, cs(f, Hn, w), w !== O.cache && mx(
            f,
            [Hn],
            m,
            !0
          ))), nr(
            c,
            f,
            f.pendingProps.children,
            m
          ), f.child;
        case 29:
          throw f.pendingProps;
      }
      throw Error(r(156, f.tag));
    }
    function ma(c) {
      c.flags |= 4;
    }
    function PN(c, f) {
      if (f.type !== "stylesheet" || (f.state.loading & 4) !== 0)
        c.flags &= -16777217;
      else if (c.flags |= 16777216, !BM(f)) {
        if (f = vo.current, f !== null && ((Ot & 4194048) === Ot ? li !== null : (Ot & 62914560) !== Ot && (Ot & 536870912) === 0 || f !== li))
          throw fd = bx, gA;
        c.flags |= 8192;
      }
    }
    function sg(c, f) {
      f !== null && (c.flags |= 4), c.flags & 16384 && (f = c.tag !== 22 ? ns() : 536870912, c.lanes |= f, nu |= f);
    }
    function wd(c, f) {
      if (!Lt)
        switch (c.tailMode) {
          case "hidden":
            f = c.tail;
            for (var m = null; f !== null; )
              f.alternate !== null && (m = f), f = f.sibling;
            m === null ? c.tail = null : m.sibling = null;
            break;
          case "collapsed":
            m = c.tail;
            for (var w = null; m !== null; )
              m.alternate !== null && (w = m), m = m.sibling;
            w === null ? f || c.tail === null ? c.tail = null : c.tail.sibling = null : w.sibling = null;
        }
    }
    function bn(c) {
      var f = c.alternate !== null && c.alternate.child === c.child, m = 0, w = 0;
      if (f)
        for (var O = c.child; O !== null; )
          m |= O.lanes | O.childLanes, w |= O.subtreeFlags & 65011712, w |= O.flags & 65011712, O.return = c, O = O.sibling;
      else
        for (O = c.child; O !== null; )
          m |= O.lanes | O.childLanes, w |= O.subtreeFlags, w |= O.flags, O.return = c, O = O.sibling;
      return c.subtreeFlags |= w, c.childLanes = m, f;
    }
    function hW(c, f, m) {
      var w = f.pendingProps;
      switch (fx(f), f.tag) {
        case 31:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return bn(f), null;
        case 1:
          return bn(f), null;
        case 3:
          return m = f.stateNode, w = null, c !== null && (w = c.memoizedState.cache), f.memoizedState.cache !== w && (f.flags |= 2048), fa(Hn), le(), m.pendingContext && (m.context = m.pendingContext, m.pendingContext = null), (c === null || c.child === null) && (od(f) ? ma(f) : c === null || c.memoizedState.isDehydrated && (f.flags & 256) === 0 || (f.flags |= 1024, fA())), bn(f), null;
        case 26:
          return m = f.memoizedState, c === null ? (ma(f), m !== null ? (bn(f), PN(f, m)) : (bn(f), f.flags &= -16777217)) : m ? m !== c.memoizedState ? (ma(f), bn(f), PN(f, m)) : (bn(f), f.flags &= -16777217) : (c.memoizedProps !== w && ma(f), bn(f), f.flags &= -16777217), null;
        case 27:
          J(f), m = Q.current;
          var O = f.type;
          if (c !== null && f.stateNode != null)
            c.memoizedProps !== w && ma(f);
          else {
            if (!w) {
              if (f.stateNode === null)
                throw Error(r(166));
              return bn(f), null;
            }
            c = H.current, od(f) ? cA(f) : (c = PM(O, w, m), f.stateNode = c, ma(f));
          }
          return bn(f), null;
        case 5:
          if (J(f), m = f.type, c !== null && f.stateNode != null)
            c.memoizedProps !== w && ma(f);
          else {
            if (!w) {
              if (f.stateNode === null)
                throw Error(r(166));
              return bn(f), null;
            }
            if (c = H.current, od(f))
              cA(f);
            else {
              switch (O = xg(
                Q.current
              ), c) {
                case 1:
                  c = O.createElementNS(
                    "http://www.w3.org/2000/svg",
                    m
                  );
                  break;
                case 2:
                  c = O.createElementNS(
                    "http://www.w3.org/1998/Math/MathML",
                    m
                  );
                  break;
                default:
                  switch (m) {
                    case "svg":
                      c = O.createElementNS(
                        "http://www.w3.org/2000/svg",
                        m
                      );
                      break;
                    case "math":
                      c = O.createElementNS(
                        "http://www.w3.org/1998/Math/MathML",
                        m
                      );
                      break;
                    case "script":
                      c = O.createElement("div"), c.innerHTML = "<script><\/script>", c = c.removeChild(c.firstChild);
                      break;
                    case "select":
                      c = typeof w.is == "string" ? O.createElement("select", { is: w.is }) : O.createElement("select"), w.multiple ? c.multiple = !0 : w.size && (c.size = w.size);
                      break;
                    default:
                      c = typeof w.is == "string" ? O.createElement(m, { is: w.is }) : O.createElement(m);
                  }
              }
              c[Yn] = f, c[ur] = w;
              e: for (O = f.child; O !== null; ) {
                if (O.tag === 5 || O.tag === 6)
                  c.appendChild(O.stateNode);
                else if (O.tag !== 4 && O.tag !== 27 && O.child !== null) {
                  O.child.return = O, O = O.child;
                  continue;
                }
                if (O === f) break e;
                for (; O.sibling === null; ) {
                  if (O.return === null || O.return === f)
                    break e;
                  O = O.return;
                }
                O.sibling.return = O.return, O = O.sibling;
              }
              f.stateNode = c;
              e: switch (or(c, m, w), m) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  c = !!w.autoFocus;
                  break e;
                case "img":
                  c = !0;
                  break e;
                default:
                  c = !1;
              }
              c && ma(f);
            }
          }
          return bn(f), f.flags &= -16777217, null;
        case 6:
          if (c && f.stateNode != null)
            c.memoizedProps !== w && ma(f);
          else {
            if (typeof w != "string" && f.stateNode === null)
              throw Error(r(166));
            if (c = Q.current, od(f)) {
              if (c = f.stateNode, m = f.memoizedProps, w = null, O = Er, O !== null)
                switch (O.tag) {
                  case 27:
                  case 5:
                    w = O.memoizedProps;
                }
              c[Yn] = f, c = !!(c.nodeValue === m || w !== null && w.suppressHydrationWarning === !0 || kM(c.nodeValue, m)), c || _l(f);
            } else
              c = xg(c).createTextNode(
                w
              ), c[Yn] = f, f.stateNode = c;
          }
          return bn(f), null;
        case 13:
          if (w = f.memoizedState, c === null || c.memoizedState !== null && c.memoizedState.dehydrated !== null) {
            if (O = od(f), w !== null && w.dehydrated !== null) {
              if (c === null) {
                if (!O) throw Error(r(318));
                if (O = f.memoizedState, O = O !== null ? O.dehydrated : null, !O) throw Error(r(317));
                O[Yn] = f;
              } else
                id(), (f.flags & 128) === 0 && (f.memoizedState = null), f.flags |= 4;
              bn(f), O = !1;
            } else
              O = fA(), c !== null && c.memoizedState !== null && (c.memoizedState.hydrationErrors = O), O = !0;
            if (!O)
              return f.flags & 256 ? (pa(f), f) : (pa(f), null);
          }
          if (pa(f), (f.flags & 128) !== 0)
            return f.lanes = m, f;
          if (m = w !== null, c = c !== null && c.memoizedState !== null, m) {
            w = f.child, O = null, w.alternate !== null && w.alternate.memoizedState !== null && w.alternate.memoizedState.cachePool !== null && (O = w.alternate.memoizedState.cachePool.pool);
            var N = null;
            w.memoizedState !== null && w.memoizedState.cachePool !== null && (N = w.memoizedState.cachePool.pool), N !== O && (w.flags |= 2048);
          }
          return m !== c && m && (f.child.flags |= 8192), sg(f, f.updateQueue), bn(f), null;
        case 4:
          return le(), c === null && _w(f.stateNode.containerInfo), bn(f), null;
        case 10:
          return fa(f.type), bn(f), null;
        case 19:
          if (X(qn), O = f.memoizedState, O === null) return bn(f), null;
          if (w = (f.flags & 128) !== 0, N = O.rendering, N === null)
            if (w) wd(O, !1);
            else {
              if (En !== 0 || c !== null && (c.flags & 128) !== 0)
                for (c = f.child; c !== null; ) {
                  if (N = ng(c), N !== null) {
                    for (f.flags |= 128, wd(O, !1), c = N.updateQueue, f.updateQueue = c, sg(f, c), f.subtreeFlags = 0, c = m, m = f.child; m !== null; )
                      sA(m, c), m = m.sibling;
                    return z(
                      qn,
                      qn.current & 1 | 2
                    ), f.child;
                  }
                  c = c.sibling;
                }
              O.tail !== null && Ne() > ug && (f.flags |= 128, w = !0, wd(O, !1), f.lanes = 4194304);
            }
          else {
            if (!w)
              if (c = ng(N), c !== null) {
                if (f.flags |= 128, w = !0, c = c.updateQueue, f.updateQueue = c, sg(f, c), wd(O, !0), O.tail === null && O.tailMode === "hidden" && !N.alternate && !Lt)
                  return bn(f), null;
              } else
                2 * Ne() - O.renderingStartTime > ug && m !== 536870912 && (f.flags |= 128, w = !0, wd(O, !1), f.lanes = 4194304);
            O.isBackwards ? (N.sibling = f.child, f.child = N) : (c = O.last, c !== null ? c.sibling = N : f.child = N, O.last = N);
          }
          return O.tail !== null ? (f = O.tail, O.rendering = f, O.tail = f.sibling, O.renderingStartTime = Ne(), f.sibling = null, c = qn.current, z(qn, w ? c & 1 | 2 : c & 1), f) : (bn(f), null);
        case 22:
        case 23:
          return pa(f), Cx(), w = f.memoizedState !== null, c !== null ? c.memoizedState !== null !== w && (f.flags |= 8192) : w && (f.flags |= 8192), w ? (m & 536870912) !== 0 && (f.flags & 128) === 0 && (bn(f), f.subtreeFlags & 6 && (f.flags |= 8192)) : bn(f), m = f.updateQueue, m !== null && sg(f, m.retryQueue), m = null, c !== null && c.memoizedState !== null && c.memoizedState.cachePool !== null && (m = c.memoizedState.cachePool.pool), w = null, f.memoizedState !== null && f.memoizedState.cachePool !== null && (w = f.memoizedState.cachePool.pool), w !== m && (f.flags |= 2048), c !== null && X(kl), null;
        case 24:
          return m = null, c !== null && (m = c.memoizedState.cache), f.memoizedState.cache !== m && (f.flags |= 2048), fa(Hn), bn(f), null;
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error(r(156, f.tag));
    }
    function mW(c, f) {
      switch (fx(f), f.tag) {
        case 1:
          return c = f.flags, c & 65536 ? (f.flags = c & -65537 | 128, f) : null;
        case 3:
          return fa(Hn), le(), c = f.flags, (c & 65536) !== 0 && (c & 128) === 0 ? (f.flags = c & -65537 | 128, f) : null;
        case 26:
        case 27:
        case 5:
          return J(f), null;
        case 13:
          if (pa(f), c = f.memoizedState, c !== null && c.dehydrated !== null) {
            if (f.alternate === null)
              throw Error(r(340));
            id();
          }
          return c = f.flags, c & 65536 ? (f.flags = c & -65537 | 128, f) : null;
        case 19:
          return X(qn), null;
        case 4:
          return le(), null;
        case 10:
          return fa(f.type), null;
        case 22:
        case 23:
          return pa(f), Cx(), c !== null && X(kl), c = f.flags, c & 65536 ? (f.flags = c & -65537 | 128, f) : null;
        case 24:
          return fa(Hn), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function $N(c, f) {
      switch (fx(f), f.tag) {
        case 3:
          fa(Hn), le();
          break;
        case 26:
        case 27:
        case 5:
          J(f);
          break;
        case 4:
          le();
          break;
        case 13:
          pa(f);
          break;
        case 19:
          X(qn);
          break;
        case 10:
          fa(f.type);
          break;
        case 22:
        case 23:
          pa(f), Cx(), c !== null && X(kl);
          break;
        case 24:
          fa(Hn);
      }
    }
    function Sd(c, f) {
      try {
        var m = f.updateQueue, w = m !== null ? m.lastEffect : null;
        if (w !== null) {
          var O = w.next;
          m = O;
          do {
            if ((m.tag & c) === c) {
              w = void 0;
              var N = m.create, q = m.inst;
              w = N(), q.destroy = w;
            }
            m = m.next;
          } while (m !== O);
        }
      } catch (Z) {
        rn(f, f.return, Z);
      }
    }
    function gs(c, f, m) {
      try {
        var w = f.updateQueue, O = w !== null ? w.lastEffect : null;
        if (O !== null) {
          var N = O.next;
          w = N;
          do {
            if ((w.tag & c) === c) {
              var q = w.inst, Z = q.destroy;
              if (Z !== void 0) {
                q.destroy = void 0, O = f;
                var ne = m, pe = Z;
                try {
                  pe();
                } catch (be) {
                  rn(
                    O,
                    ne,
                    be
                  );
                }
              }
            }
            w = w.next;
          } while (w !== N);
        }
      } catch (be) {
        rn(f, f.return, be);
      }
    }
    function IN(c) {
      var f = c.updateQueue;
      if (f !== null) {
        var m = c.stateNode;
        try {
          SA(f, m);
        } catch (w) {
          rn(c, c.return, w);
        }
      }
    }
    function jN(c, f, m) {
      m.props = Rl(
        c.type,
        c.memoizedProps
      ), m.state = c.memoizedState;
      try {
        m.componentWillUnmount();
      } catch (w) {
        rn(c, f, w);
      }
    }
    function _d(c, f) {
      try {
        var m = c.ref;
        if (m !== null) {
          switch (c.tag) {
            case 26:
            case 27:
            case 5:
              var w = c.stateNode;
              break;
            case 30:
              w = c.stateNode;
              break;
            default:
              w = c.stateNode;
          }
          typeof m == "function" ? c.refCleanup = m(w) : m.current = w;
        }
      } catch (O) {
        rn(c, f, O);
      }
    }
    function ci(c, f) {
      var m = c.ref, w = c.refCleanup;
      if (m !== null)
        if (typeof w == "function")
          try {
            w();
          } catch (O) {
            rn(c, f, O);
          } finally {
            c.refCleanup = null, c = c.alternate, c != null && (c.refCleanup = null);
          }
        else if (typeof m == "function")
          try {
            m(null);
          } catch (O) {
            rn(c, f, O);
          }
        else m.current = null;
    }
    function DN(c) {
      var f = c.type, m = c.memoizedProps, w = c.stateNode;
      try {
        e: switch (f) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            m.autoFocus && w.focus();
            break e;
          case "img":
            m.src ? w.src = m.src : m.srcSet && (w.srcset = m.srcSet);
        }
      } catch (O) {
        rn(c, c.return, O);
      }
    }
    function Jx(c, f, m) {
      try {
        var w = c.stateNode;
        jW(w, c.type, m, f), w[ur] = f;
      } catch (O) {
        rn(c, c.return, O);
      }
    }
    function FN(c) {
      return c.tag === 5 || c.tag === 3 || c.tag === 26 || c.tag === 27 && Es(c.type) || c.tag === 4;
    }
    function ew(c) {
      e: for (; ; ) {
        for (; c.sibling === null; ) {
          if (c.return === null || FN(c.return)) return null;
          c = c.return;
        }
        for (c.sibling.return = c.return, c = c.sibling; c.tag !== 5 && c.tag !== 6 && c.tag !== 18; ) {
          if (c.tag === 27 && Es(c.type) || c.flags & 2 || c.child === null || c.tag === 4) continue e;
          c.child.return = c, c = c.child;
        }
        if (!(c.flags & 2)) return c.stateNode;
      }
    }
    function tw(c, f, m) {
      var w = c.tag;
      if (w === 5 || w === 6)
        c = c.stateNode, f ? (m.nodeType === 9 ? m.body : m.nodeName === "HTML" ? m.ownerDocument.body : m).insertBefore(c, f) : (f = m.nodeType === 9 ? m.body : m.nodeName === "HTML" ? m.ownerDocument.body : m, f.appendChild(c), m = m._reactRootContainer, m != null || f.onclick !== null || (f.onclick = bg));
      else if (w !== 4 && (w === 27 && Es(c.type) && (m = c.stateNode, f = null), c = c.child, c !== null))
        for (tw(c, f, m), c = c.sibling; c !== null; )
          tw(c, f, m), c = c.sibling;
    }
    function lg(c, f, m) {
      var w = c.tag;
      if (w === 5 || w === 6)
        c = c.stateNode, f ? m.insertBefore(c, f) : m.appendChild(c);
      else if (w !== 4 && (w === 27 && Es(c.type) && (m = c.stateNode), c = c.child, c !== null))
        for (lg(c, f, m), c = c.sibling; c !== null; )
          lg(c, f, m), c = c.sibling;
    }
    function LN(c) {
      var f = c.stateNode, m = c.memoizedProps;
      try {
        for (var w = c.type, O = f.attributes; O.length; )
          f.removeAttributeNode(O[0]);
        or(f, w, m), f[Yn] = c, f[ur] = m;
      } catch (N) {
        rn(c, c.return, N);
      }
    }
    var ga = !1, Nn = !1, nw = !1, zN = typeof WeakSet == "function" ? WeakSet : Set, Zn = null;
    function gW(c, f) {
      if (c = c.containerInfo, kw = kg, c = ZO(c), ex(c)) {
        if ("selectionStart" in c)
          var m = {
            start: c.selectionStart,
            end: c.selectionEnd
          };
        else
          e: {
            m = (m = c.ownerDocument) && m.defaultView || window;
            var w = m.getSelection && m.getSelection();
            if (w && w.rangeCount !== 0) {
              m = w.anchorNode;
              var O = w.anchorOffset, N = w.focusNode;
              w = w.focusOffset;
              try {
                m.nodeType, N.nodeType;
              } catch {
                m = null;
                break e;
              }
              var q = 0, Z = -1, ne = -1, pe = 0, be = 0, we = c, he = null;
              t: for (; ; ) {
                for (var me; we !== m || O !== 0 && we.nodeType !== 3 || (Z = q + O), we !== N || w !== 0 && we.nodeType !== 3 || (ne = q + w), we.nodeType === 3 && (q += we.nodeValue.length), (me = we.firstChild) !== null; )
                  he = we, we = me;
                for (; ; ) {
                  if (we === c) break t;
                  if (he === m && ++pe === O && (Z = q), he === N && ++be === w && (ne = q), (me = we.nextSibling) !== null) break;
                  we = he, he = we.parentNode;
                }
                we = me;
              }
              m = Z === -1 || ne === -1 ? null : { start: Z, end: ne };
            } else m = null;
          }
        m = m || { start: 0, end: 0 };
      } else m = null;
      for (Tw = { focusedElem: c, selectionRange: m }, kg = !1, Zn = f; Zn !== null; )
        if (f = Zn, c = f.child, (f.subtreeFlags & 1024) !== 0 && c !== null)
          c.return = f, Zn = c;
        else
          for (; Zn !== null; ) {
            switch (f = Zn, N = f.alternate, c = f.flags, f.tag) {
              case 0:
                break;
              case 11:
              case 15:
                break;
              case 1:
                if ((c & 1024) !== 0 && N !== null) {
                  c = void 0, m = f, O = N.memoizedProps, N = N.memoizedState, w = m.stateNode;
                  try {
                    var nt = Rl(
                      m.type,
                      O,
                      m.elementType === m.type
                    );
                    c = w.getSnapshotBeforeUpdate(
                      nt,
                      N
                    ), w.__reactInternalSnapshotBeforeUpdate = c;
                  } catch (Qe) {
                    rn(
                      m,
                      m.return,
                      Qe
                    );
                  }
                }
                break;
              case 3:
                if ((c & 1024) !== 0) {
                  if (c = f.stateNode.containerInfo, m = c.nodeType, m === 9)
                    Aw(c);
                  else if (m === 1)
                    switch (c.nodeName) {
                      case "HEAD":
                      case "HTML":
                      case "BODY":
                        Aw(c);
                        break;
                      default:
                        c.textContent = "";
                    }
                }
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if ((c & 1024) !== 0) throw Error(r(163));
            }
            if (c = f.sibling, c !== null) {
              c.return = f.return, Zn = c;
              break;
            }
            Zn = f.return;
          }
    }
    function BN(c, f, m) {
      var w = m.flags;
      switch (m.tag) {
        case 0:
        case 11:
        case 15:
          ys(c, m), w & 4 && Sd(5, m);
          break;
        case 1:
          if (ys(c, m), w & 4)
            if (c = m.stateNode, f === null)
              try {
                c.componentDidMount();
              } catch (q) {
                rn(m, m.return, q);
              }
            else {
              var O = Rl(
                m.type,
                f.memoizedProps
              );
              f = f.memoizedState;
              try {
                c.componentDidUpdate(
                  O,
                  f,
                  c.__reactInternalSnapshotBeforeUpdate
                );
              } catch (q) {
                rn(
                  m,
                  m.return,
                  q
                );
              }
            }
          w & 64 && IN(m), w & 512 && _d(m, m.return);
          break;
        case 3:
          if (ys(c, m), w & 64 && (c = m.updateQueue, c !== null)) {
            if (f = null, m.child !== null)
              switch (m.child.tag) {
                case 27:
                case 5:
                  f = m.child.stateNode;
                  break;
                case 1:
                  f = m.child.stateNode;
              }
            try {
              SA(c, f);
            } catch (q) {
              rn(m, m.return, q);
            }
          }
          break;
        case 27:
          f === null && w & 4 && LN(m);
        case 26:
        case 5:
          ys(c, m), f === null && w & 4 && DN(m), w & 512 && _d(m, m.return);
          break;
        case 12:
          ys(c, m);
          break;
        case 13:
          ys(c, m), w & 4 && HN(c, m), w & 64 && (c = m.memoizedState, c !== null && (c = c.dehydrated, c !== null && (m = CW.bind(
            null,
            m
          ), VW(c, m))));
          break;
        case 22:
          if (w = m.memoizedState !== null || ga, !w) {
            f = f !== null && f.memoizedState !== null || Nn, O = ga;
            var N = Nn;
            ga = w, (Nn = f) && !N ? vs(
              c,
              m,
              (m.subtreeFlags & 8772) !== 0
            ) : ys(c, m), ga = O, Nn = N;
          }
          break;
        case 30:
          break;
        default:
          ys(c, m);
      }
    }
    function UN(c) {
      var f = c.alternate;
      f !== null && (c.alternate = null, UN(f)), c.child = null, c.deletions = null, c.sibling = null, c.tag === 5 && (f = c.stateNode, f !== null && Uf(f)), c.stateNode = null, c.return = null, c.dependencies = null, c.memoizedProps = null, c.memoizedState = null, c.pendingProps = null, c.stateNode = null, c.updateQueue = null;
    }
    var gn = null, Ir = !1;
    function ya(c, f, m) {
      for (m = m.child; m !== null; )
        VN(c, f, m), m = m.sibling;
    }
    function VN(c, f, m) {
      if (ue && typeof ue.onCommitFiberUnmount == "function")
        try {
          ue.onCommitFiberUnmount(oe, m);
        } catch {
        }
      switch (m.tag) {
        case 26:
          Nn || ci(m, f), ya(
            c,
            f,
            m
          ), m.memoizedState ? m.memoizedState.count-- : m.stateNode && (m = m.stateNode, m.parentNode.removeChild(m));
          break;
        case 27:
          Nn || ci(m, f);
          var w = gn, O = Ir;
          Es(m.type) && (gn = m.stateNode, Ir = !1), ya(
            c,
            f,
            m
          ), Md(m.stateNode), gn = w, Ir = O;
          break;
        case 5:
          Nn || ci(m, f);
        case 6:
          if (w = gn, O = Ir, gn = null, ya(
            c,
            f,
            m
          ), gn = w, Ir = O, gn !== null)
            if (Ir)
              try {
                (gn.nodeType === 9 ? gn.body : gn.nodeName === "HTML" ? gn.ownerDocument.body : gn).removeChild(m.stateNode);
              } catch (N) {
                rn(
                  m,
                  f,
                  N
                );
              }
            else
              try {
                gn.removeChild(m.stateNode);
              } catch (N) {
                rn(
                  m,
                  f,
                  N
                );
              }
          break;
        case 18:
          gn !== null && (Ir ? (c = gn, NM(
            c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c,
            m.stateNode
          ), zd(c)) : NM(gn, m.stateNode));
          break;
        case 4:
          w = gn, O = Ir, gn = m.stateNode.containerInfo, Ir = !0, ya(
            c,
            f,
            m
          ), gn = w, Ir = O;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          Nn || gs(2, m, f), Nn || gs(4, m, f), ya(
            c,
            f,
            m
          );
          break;
        case 1:
          Nn || (ci(m, f), w = m.stateNode, typeof w.componentWillUnmount == "function" && jN(
            m,
            f,
            w
          )), ya(
            c,
            f,
            m
          );
          break;
        case 21:
          ya(
            c,
            f,
            m
          );
          break;
        case 22:
          Nn = (w = Nn) || m.memoizedState !== null, ya(
            c,
            f,
            m
          ), Nn = w;
          break;
        default:
          ya(
            c,
            f,
            m
          );
      }
    }
    function HN(c, f) {
      if (f.memoizedState === null && (c = f.alternate, c !== null && (c = c.memoizedState, c !== null && (c = c.dehydrated, c !== null))))
        try {
          zd(c);
        } catch (m) {
          rn(f, f.return, m);
        }
    }
    function yW(c) {
      switch (c.tag) {
        case 13:
        case 19:
          var f = c.stateNode;
          return f === null && (f = c.stateNode = new zN()), f;
        case 22:
          return c = c.stateNode, f = c._retryCache, f === null && (f = c._retryCache = new zN()), f;
        default:
          throw Error(r(435, c.tag));
      }
    }
    function rw(c, f) {
      var m = yW(c);
      f.forEach(function(w) {
        var O = kW.bind(null, c, w);
        m.has(w) || (m.add(w), w.then(O, O));
      });
    }
    function Gr(c, f) {
      var m = f.deletions;
      if (m !== null)
        for (var w = 0; w < m.length; w++) {
          var O = m[w], N = c, q = f, Z = q;
          e: for (; Z !== null; ) {
            switch (Z.tag) {
              case 27:
                if (Es(Z.type)) {
                  gn = Z.stateNode, Ir = !1;
                  break e;
                }
                break;
              case 5:
                gn = Z.stateNode, Ir = !1;
                break e;
              case 3:
              case 4:
                gn = Z.stateNode.containerInfo, Ir = !0;
                break e;
            }
            Z = Z.return;
          }
          if (gn === null) throw Error(r(160));
          VN(N, q, O), gn = null, Ir = !1, N = O.alternate, N !== null && (N.return = null), O.return = null;
        }
      if (f.subtreeFlags & 13878)
        for (f = f.child; f !== null; )
          qN(f, c), f = f.sibling;
    }
    var Do = null;
    function qN(c, f) {
      var m = c.alternate, w = c.flags;
      switch (c.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Gr(f, c), Kr(c), w & 4 && (gs(3, c, c.return), Sd(3, c), gs(5, c, c.return));
          break;
        case 1:
          Gr(f, c), Kr(c), w & 512 && (Nn || m === null || ci(m, m.return)), w & 64 && ga && (c = c.updateQueue, c !== null && (w = c.callbacks, w !== null && (m = c.shared.hiddenCallbacks, c.shared.hiddenCallbacks = m === null ? w : m.concat(w))));
          break;
        case 26:
          var O = Do;
          if (Gr(f, c), Kr(c), w & 512 && (Nn || m === null || ci(m, m.return)), w & 4) {
            var N = m !== null ? m.memoizedState : null;
            if (w = c.memoizedState, m === null)
              if (w === null)
                if (c.stateNode === null) {
                  e: {
                    w = c.type, m = c.memoizedProps, O = O.ownerDocument || O;
                    t: switch (w) {
                      case "title":
                        N = O.getElementsByTagName("title")[0], (!N || N[hl] || N[Yn] || N.namespaceURI === "http://www.w3.org/2000/svg" || N.hasAttribute("itemprop")) && (N = O.createElement(w), O.head.insertBefore(
                          N,
                          O.querySelector("head > title")
                        )), or(N, w, m), N[Yn] = c, $n(N), w = N;
                        break e;
                      case "link":
                        var q = LM(
                          "link",
                          "href",
                          O
                        ).get(w + (m.href || ""));
                        if (q) {
                          for (var Z = 0; Z < q.length; Z++)
                            if (N = q[Z], N.getAttribute("href") === (m.href == null || m.href === "" ? null : m.href) && N.getAttribute("rel") === (m.rel == null ? null : m.rel) && N.getAttribute("title") === (m.title == null ? null : m.title) && N.getAttribute("crossorigin") === (m.crossOrigin == null ? null : m.crossOrigin)) {
                              q.splice(Z, 1);
                              break t;
                            }
                        }
                        N = O.createElement(w), or(N, w, m), O.head.appendChild(N);
                        break;
                      case "meta":
                        if (q = LM(
                          "meta",
                          "content",
                          O
                        ).get(w + (m.content || ""))) {
                          for (Z = 0; Z < q.length; Z++)
                            if (N = q[Z], N.getAttribute("content") === (m.content == null ? null : "" + m.content) && N.getAttribute("name") === (m.name == null ? null : m.name) && N.getAttribute("property") === (m.property == null ? null : m.property) && N.getAttribute("http-equiv") === (m.httpEquiv == null ? null : m.httpEquiv) && N.getAttribute("charset") === (m.charSet == null ? null : m.charSet)) {
                              q.splice(Z, 1);
                              break t;
                            }
                        }
                        N = O.createElement(w), or(N, w, m), O.head.appendChild(N);
                        break;
                      default:
                        throw Error(r(468, w));
                    }
                    N[Yn] = c, $n(N), w = N;
                  }
                  c.stateNode = w;
                } else
                  zM(
                    O,
                    c.type,
                    c.stateNode
                  );
              else
                c.stateNode = FM(
                  O,
                  w,
                  c.memoizedProps
                );
            else
              N !== w ? (N === null ? m.stateNode !== null && (m = m.stateNode, m.parentNode.removeChild(m)) : N.count--, w === null ? zM(
                O,
                c.type,
                c.stateNode
              ) : FM(
                O,
                w,
                c.memoizedProps
              )) : w === null && c.stateNode !== null && Jx(
                c,
                c.memoizedProps,
                m.memoizedProps
              );
          }
          break;
        case 27:
          Gr(f, c), Kr(c), w & 512 && (Nn || m === null || ci(m, m.return)), m !== null && w & 4 && Jx(
            c,
            c.memoizedProps,
            m.memoizedProps
          );
          break;
        case 5:
          if (Gr(f, c), Kr(c), w & 512 && (Nn || m === null || ci(m, m.return)), c.flags & 32) {
            O = c.stateNode;
            try {
              $c(O, "");
            } catch (me) {
              rn(c, c.return, me);
            }
          }
          w & 4 && c.stateNode != null && (O = c.memoizedProps, Jx(
            c,
            O,
            m !== null ? m.memoizedProps : O
          )), w & 1024 && (nw = !0);
          break;
        case 6:
          if (Gr(f, c), Kr(c), w & 4) {
            if (c.stateNode === null)
              throw Error(r(162));
            w = c.memoizedProps, m = c.stateNode;
            try {
              m.nodeValue = w;
            } catch (me) {
              rn(c, c.return, me);
            }
          }
          break;
        case 3:
          if (_g = null, O = Do, Do = wg(f.containerInfo), Gr(f, c), Do = O, Kr(c), w & 4 && m !== null && m.memoizedState.isDehydrated)
            try {
              zd(f.containerInfo);
            } catch (me) {
              rn(c, c.return, me);
            }
          nw && (nw = !1, WN(c));
          break;
        case 4:
          w = Do, Do = wg(
            c.stateNode.containerInfo
          ), Gr(f, c), Kr(c), Do = w;
          break;
        case 12:
          Gr(f, c), Kr(c);
          break;
        case 13:
          Gr(f, c), Kr(c), c.child.flags & 8192 && c.memoizedState !== null != (m !== null && m.memoizedState !== null) && (cw = Ne()), w & 4 && (w = c.updateQueue, w !== null && (c.updateQueue = null, rw(c, w)));
          break;
        case 22:
          O = c.memoizedState !== null;
          var ne = m !== null && m.memoizedState !== null, pe = ga, be = Nn;
          if (ga = pe || O, Nn = be || ne, Gr(f, c), Nn = be, ga = pe, Kr(c), w & 8192)
            e: for (f = c.stateNode, f._visibility = O ? f._visibility & -2 : f._visibility | 1, O && (m === null || ne || ga || Nn || Ol(c)), m = null, f = c; ; ) {
              if (f.tag === 5 || f.tag === 26) {
                if (m === null) {
                  ne = m = f;
                  try {
                    if (N = ne.stateNode, O)
                      q = N.style, typeof q.setProperty == "function" ? q.setProperty("display", "none", "important") : q.display = "none";
                    else {
                      Z = ne.stateNode;
                      var we = ne.memoizedProps.style, he = we != null && we.hasOwnProperty("display") ? we.display : null;
                      Z.style.display = he == null || typeof he == "boolean" ? "" : ("" + he).trim();
                    }
                  } catch (me) {
                    rn(ne, ne.return, me);
                  }
                }
              } else if (f.tag === 6) {
                if (m === null) {
                  ne = f;
                  try {
                    ne.stateNode.nodeValue = O ? "" : ne.memoizedProps;
                  } catch (me) {
                    rn(ne, ne.return, me);
                  }
                }
              } else if ((f.tag !== 22 && f.tag !== 23 || f.memoizedState === null || f === c) && f.child !== null) {
                f.child.return = f, f = f.child;
                continue;
              }
              if (f === c) break e;
              for (; f.sibling === null; ) {
                if (f.return === null || f.return === c) break e;
                m === f && (m = null), f = f.return;
              }
              m === f && (m = null), f.sibling.return = f.return, f = f.sibling;
            }
          w & 4 && (w = c.updateQueue, w !== null && (m = w.retryQueue, m !== null && (w.retryQueue = null, rw(c, m))));
          break;
        case 19:
          Gr(f, c), Kr(c), w & 4 && (w = c.updateQueue, w !== null && (c.updateQueue = null, rw(c, w)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          Gr(f, c), Kr(c);
      }
    }
    function Kr(c) {
      var f = c.flags;
      if (f & 2) {
        try {
          for (var m, w = c.return; w !== null; ) {
            if (FN(w)) {
              m = w;
              break;
            }
            w = w.return;
          }
          if (m == null) throw Error(r(160));
          switch (m.tag) {
            case 27:
              var O = m.stateNode, N = ew(c);
              lg(c, N, O);
              break;
            case 5:
              var q = m.stateNode;
              m.flags & 32 && ($c(q, ""), m.flags &= -33);
              var Z = ew(c);
              lg(c, Z, q);
              break;
            case 3:
            case 4:
              var ne = m.stateNode.containerInfo, pe = ew(c);
              tw(
                c,
                pe,
                ne
              );
              break;
            default:
              throw Error(r(161));
          }
        } catch (be) {
          rn(c, c.return, be);
        }
        c.flags &= -3;
      }
      f & 4096 && (c.flags &= -4097);
    }
    function WN(c) {
      if (c.subtreeFlags & 1024)
        for (c = c.child; c !== null; ) {
          var f = c;
          WN(f), f.tag === 5 && f.flags & 1024 && f.stateNode.reset(), c = c.sibling;
        }
    }
    function ys(c, f) {
      if (f.subtreeFlags & 8772)
        for (f = f.child; f !== null; )
          BN(c, f.alternate, f), f = f.sibling;
    }
    function Ol(c) {
      for (c = c.child; c !== null; ) {
        var f = c;
        switch (f.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            gs(4, f, f.return), Ol(f);
            break;
          case 1:
            ci(f, f.return);
            var m = f.stateNode;
            typeof m.componentWillUnmount == "function" && jN(
              f,
              f.return,
              m
            ), Ol(f);
            break;
          case 27:
            Md(f.stateNode);
          case 26:
          case 5:
            ci(f, f.return), Ol(f);
            break;
          case 22:
            f.memoizedState === null && Ol(f);
            break;
          case 30:
            Ol(f);
            break;
          default:
            Ol(f);
        }
        c = c.sibling;
      }
    }
    function vs(c, f, m) {
      for (m = m && (f.subtreeFlags & 8772) !== 0, f = f.child; f !== null; ) {
        var w = f.alternate, O = c, N = f, q = N.flags;
        switch (N.tag) {
          case 0:
          case 11:
          case 15:
            vs(
              O,
              N,
              m
            ), Sd(4, N);
            break;
          case 1:
            if (vs(
              O,
              N,
              m
            ), w = N, O = w.stateNode, typeof O.componentDidMount == "function")
              try {
                O.componentDidMount();
              } catch (pe) {
                rn(w, w.return, pe);
              }
            if (w = N, O = w.updateQueue, O !== null) {
              var Z = w.stateNode;
              try {
                var ne = O.shared.hiddenCallbacks;
                if (ne !== null)
                  for (O.shared.hiddenCallbacks = null, O = 0; O < ne.length; O++)
                    wA(ne[O], Z);
              } catch (pe) {
                rn(w, w.return, pe);
              }
            }
            m && q & 64 && IN(N), _d(N, N.return);
            break;
          case 27:
            LN(N);
          case 26:
          case 5:
            vs(
              O,
              N,
              m
            ), m && w === null && q & 4 && DN(N), _d(N, N.return);
            break;
          case 12:
            vs(
              O,
              N,
              m
            );
            break;
          case 13:
            vs(
              O,
              N,
              m
            ), m && q & 4 && HN(O, N);
            break;
          case 22:
            N.memoizedState === null && vs(
              O,
              N,
              m
            ), _d(N, N.return);
            break;
          case 30:
            break;
          default:
            vs(
              O,
              N,
              m
            );
        }
        f = f.sibling;
      }
    }
    function ow(c, f) {
      var m = null;
      c !== null && c.memoizedState !== null && c.memoizedState.cachePool !== null && (m = c.memoizedState.cachePool.pool), c = null, f.memoizedState !== null && f.memoizedState.cachePool !== null && (c = f.memoizedState.cachePool.pool), c !== m && (c != null && c.refCount++, m != null && ld(m));
    }
    function iw(c, f) {
      c = null, f.alternate !== null && (c = f.alternate.memoizedState.cache), f = f.memoizedState.cache, f !== c && (f.refCount++, c != null && ld(c));
    }
    function ui(c, f, m, w) {
      if (f.subtreeFlags & 10256)
        for (f = f.child; f !== null; )
          GN(
            c,
            f,
            m,
            w
          ), f = f.sibling;
    }
    function GN(c, f, m, w) {
      var O = f.flags;
      switch (f.tag) {
        case 0:
        case 11:
        case 15:
          ui(
            c,
            f,
            m,
            w
          ), O & 2048 && Sd(9, f);
          break;
        case 1:
          ui(
            c,
            f,
            m,
            w
          );
          break;
        case 3:
          ui(
            c,
            f,
            m,
            w
          ), O & 2048 && (c = null, f.alternate !== null && (c = f.alternate.memoizedState.cache), f = f.memoizedState.cache, f !== c && (f.refCount++, c != null && ld(c)));
          break;
        case 12:
          if (O & 2048) {
            ui(
              c,
              f,
              m,
              w
            ), c = f.stateNode;
            try {
              var N = f.memoizedProps, q = N.id, Z = N.onPostCommit;
              typeof Z == "function" && Z(
                q,
                f.alternate === null ? "mount" : "update",
                c.passiveEffectDuration,
                -0
              );
            } catch (ne) {
              rn(f, f.return, ne);
            }
          } else
            ui(
              c,
              f,
              m,
              w
            );
          break;
        case 13:
          ui(
            c,
            f,
            m,
            w
          );
          break;
        case 23:
          break;
        case 22:
          N = f.stateNode, q = f.alternate, f.memoizedState !== null ? N._visibility & 2 ? ui(
            c,
            f,
            m,
            w
          ) : Ed(c, f) : N._visibility & 2 ? ui(
            c,
            f,
            m,
            w
          ) : (N._visibility |= 2, Jc(
            c,
            f,
            m,
            w,
            (f.subtreeFlags & 10256) !== 0
          )), O & 2048 && ow(q, f);
          break;
        case 24:
          ui(
            c,
            f,
            m,
            w
          ), O & 2048 && iw(f.alternate, f);
          break;
        default:
          ui(
            c,
            f,
            m,
            w
          );
      }
    }
    function Jc(c, f, m, w, O) {
      for (O = O && (f.subtreeFlags & 10256) !== 0, f = f.child; f !== null; ) {
        var N = c, q = f, Z = m, ne = w, pe = q.flags;
        switch (q.tag) {
          case 0:
          case 11:
          case 15:
            Jc(
              N,
              q,
              Z,
              ne,
              O
            ), Sd(8, q);
            break;
          case 23:
            break;
          case 22:
            var be = q.stateNode;
            q.memoizedState !== null ? be._visibility & 2 ? Jc(
              N,
              q,
              Z,
              ne,
              O
            ) : Ed(
              N,
              q
            ) : (be._visibility |= 2, Jc(
              N,
              q,
              Z,
              ne,
              O
            )), O && pe & 2048 && ow(
              q.alternate,
              q
            );
            break;
          case 24:
            Jc(
              N,
              q,
              Z,
              ne,
              O
            ), O && pe & 2048 && iw(q.alternate, q);
            break;
          default:
            Jc(
              N,
              q,
              Z,
              ne,
              O
            );
        }
        f = f.sibling;
      }
    }
    function Ed(c, f) {
      if (f.subtreeFlags & 10256)
        for (f = f.child; f !== null; ) {
          var m = c, w = f, O = w.flags;
          switch (w.tag) {
            case 22:
              Ed(m, w), O & 2048 && ow(
                w.alternate,
                w
              );
              break;
            case 24:
              Ed(m, w), O & 2048 && iw(w.alternate, w);
              break;
            default:
              Ed(m, w);
          }
          f = f.sibling;
        }
    }
    var Cd = 8192;
    function eu(c) {
      if (c.subtreeFlags & Cd)
        for (c = c.child; c !== null; )
          KN(c), c = c.sibling;
    }
    function KN(c) {
      switch (c.tag) {
        case 26:
          eu(c), c.flags & Cd && c.memoizedState !== null && nG(
            Do,
            c.memoizedState,
            c.memoizedProps
          );
          break;
        case 5:
          eu(c);
          break;
        case 3:
        case 4:
          var f = Do;
          Do = wg(c.stateNode.containerInfo), eu(c), Do = f;
          break;
        case 22:
          c.memoizedState === null && (f = c.alternate, f !== null && f.memoizedState !== null ? (f = Cd, Cd = 16777216, eu(c), Cd = f) : eu(c));
          break;
        default:
          eu(c);
      }
    }
    function YN(c) {
      var f = c.alternate;
      if (f !== null && (c = f.child, c !== null)) {
        f.child = null;
        do
          f = c.sibling, c.sibling = null, c = f;
        while (c !== null);
      }
    }
    function kd(c) {
      var f = c.deletions;
      if ((c.flags & 16) !== 0) {
        if (f !== null)
          for (var m = 0; m < f.length; m++) {
            var w = f[m];
            Zn = w, ZN(
              w,
              c
            );
          }
        YN(c);
      }
      if (c.subtreeFlags & 10256)
        for (c = c.child; c !== null; )
          XN(c), c = c.sibling;
    }
    function XN(c) {
      switch (c.tag) {
        case 0:
        case 11:
        case 15:
          kd(c), c.flags & 2048 && gs(9, c, c.return);
          break;
        case 3:
          kd(c);
          break;
        case 12:
          kd(c);
          break;
        case 22:
          var f = c.stateNode;
          c.memoizedState !== null && f._visibility & 2 && (c.return === null || c.return.tag !== 13) ? (f._visibility &= -3, cg(c)) : kd(c);
          break;
        default:
          kd(c);
      }
    }
    function cg(c) {
      var f = c.deletions;
      if ((c.flags & 16) !== 0) {
        if (f !== null)
          for (var m = 0; m < f.length; m++) {
            var w = f[m];
            Zn = w, ZN(
              w,
              c
            );
          }
        YN(c);
      }
      for (c = c.child; c !== null; ) {
        switch (f = c, f.tag) {
          case 0:
          case 11:
          case 15:
            gs(8, f, f.return), cg(f);
            break;
          case 22:
            m = f.stateNode, m._visibility & 2 && (m._visibility &= -3, cg(f));
            break;
          default:
            cg(f);
        }
        c = c.sibling;
      }
    }
    function ZN(c, f) {
      for (; Zn !== null; ) {
        var m = Zn;
        switch (m.tag) {
          case 0:
          case 11:
          case 15:
            gs(8, m, f);
            break;
          case 23:
          case 22:
            if (m.memoizedState !== null && m.memoizedState.cachePool !== null) {
              var w = m.memoizedState.cachePool.pool;
              w != null && w.refCount++;
            }
            break;
          case 24:
            ld(m.memoizedState.cache);
        }
        if (w = m.child, w !== null) w.return = m, Zn = w;
        else
          e: for (m = c; Zn !== null; ) {
            w = Zn;
            var O = w.sibling, N = w.return;
            if (UN(w), w === m) {
              Zn = null;
              break e;
            }
            if (O !== null) {
              O.return = N, Zn = O;
              break e;
            }
            Zn = N;
          }
      }
    }
    var vW = {
      getCacheForType: function(c) {
        var f = fr(Hn), m = f.data.get(c);
        return m === void 0 && (m = c(), f.data.set(c, m)), m;
      }
    }, bW = typeof WeakMap == "function" ? WeakMap : Map, qt = 0, ln = null, St = null, Ot = 0, Wt = 0, Yr = null, bs = !1, tu = !1, aw = !1, va = 0, En = 0, xs = 0, Al = 0, sw = 0, bo = 0, nu = 0, Td = null, jr = null, lw = !1, cw = 0, ug = 1 / 0, fg = null, ws = null, rr = 0, Ss = null, ru = null, ou = 0, uw = 0, fw = null, QN = null, Rd = 0, dw = null;
    function Xr() {
      if ((qt & 2) !== 0 && Ot !== 0)
        return Ot & -Ot;
      if (F.T !== null) {
        var c = qc;
        return c !== 0 ? c : bw();
      }
      return vm();
    }
    function JN() {
      bo === 0 && (bo = (Ot & 536870912) === 0 || Lt ? $o() : 536870912);
      var c = vo.current;
      return c !== null && (c.flags |= 32), bo;
    }
    function Zr(c, f, m) {
      (c === ln && (Wt === 2 || Wt === 9) || c.cancelPendingCommit !== null) && (iu(c, 0), _s(
        c,
        Ot,
        bo,
        !1
      )), Zt(c, m), ((qt & 2) === 0 || c !== ln) && (c === ln && ((qt & 2) === 0 && (Al |= m), En === 4 && _s(
        c,
        Ot,
        bo,
        !1
      )), fi(c));
    }
    function eM(c, f, m) {
      if ((qt & 6) !== 0) throw Error(r(327));
      var w = !m && (f & 124) === 0 && (f & c.expiredLanes) === 0 || Ct(c, f), O = w ? SW(c, f) : mw(c, f, !0), N = w;
      do {
        if (O === 0) {
          tu && !w && _s(c, f, 0, !1);
          break;
        } else {
          if (m = c.current.alternate, N && !xW(m)) {
            O = mw(c, f, !1), N = !1;
            continue;
          }
          if (O === 2) {
            if (N = f, c.errorRecoveryDisabledLanes & N)
              var q = 0;
            else
              q = c.pendingLanes & -536870913, q = q !== 0 ? q : q & 536870912 ? 536870912 : 0;
            if (q !== 0) {
              f = q;
              e: {
                var Z = c;
                O = Td;
                var ne = Z.current.memoizedState.isDehydrated;
                if (ne && (iu(Z, q).flags |= 256), q = mw(
                  Z,
                  q,
                  !1
                ), q !== 2) {
                  if (aw && !ne) {
                    Z.errorRecoveryDisabledLanes |= N, Al |= N, O = 4;
                    break e;
                  }
                  N = jr, jr = O, N !== null && (jr === null ? jr = N : jr.push.apply(
                    jr,
                    N
                  ));
                }
                O = q;
              }
              if (N = !1, O !== 2) continue;
            }
          }
          if (O === 1) {
            iu(c, 0), _s(c, f, 0, !0);
            break;
          }
          e: {
            switch (w = c, N = O, N) {
              case 0:
              case 1:
                throw Error(r(345));
              case 4:
                if ((f & 4194048) !== f) break;
              case 6:
                _s(
                  w,
                  f,
                  bo,
                  !bs
                );
                break e;
              case 2:
                jr = null;
                break;
              case 3:
              case 5:
                break;
              default:
                throw Error(r(329));
            }
            if ((f & 62914560) === f && (O = cw + 300 - Ne(), 10 < O)) {
              if (_s(
                w,
                f,
                bo,
                !bs
              ), tt(w, 0, !0) !== 0) break e;
              w.timeoutHandle = OM(
                tM.bind(
                  null,
                  w,
                  m,
                  jr,
                  fg,
                  lw,
                  f,
                  bo,
                  Al,
                  nu,
                  bs,
                  N,
                  2,
                  -0,
                  0
                ),
                O
              );
              break e;
            }
            tM(
              w,
              m,
              jr,
              fg,
              lw,
              f,
              bo,
              Al,
              nu,
              bs,
              N,
              0,
              -0,
              0
            );
          }
        }
        break;
      } while (!0);
      fi(c);
    }
    function tM(c, f, m, w, O, N, q, Z, ne, pe, be, we, he, me) {
      if (c.timeoutHandle = -1, we = f.subtreeFlags, (we & 8192 || (we & 16785408) === 16785408) && (Id = { stylesheets: null, count: 0, unsuspend: tG }, KN(f), we = rG(), we !== null)) {
        c.cancelPendingCommit = we(
          lM.bind(
            null,
            c,
            f,
            N,
            m,
            w,
            O,
            q,
            Z,
            ne,
            be,
            1,
            he,
            me
          )
        ), _s(c, N, q, !pe);
        return;
      }
      lM(
        c,
        f,
        N,
        m,
        w,
        O,
        q,
        Z,
        ne
      );
    }
    function xW(c) {
      for (var f = c; ; ) {
        var m = f.tag;
        if ((m === 0 || m === 11 || m === 15) && f.flags & 16384 && (m = f.updateQueue, m !== null && (m = m.stores, m !== null)))
          for (var w = 0; w < m.length; w++) {
            var O = m[w], N = O.getSnapshot;
            O = O.value;
            try {
              if (!qr(N(), O)) return !1;
            } catch {
              return !1;
            }
          }
        if (m = f.child, f.subtreeFlags & 16384 && m !== null)
          m.return = f, f = m;
        else {
          if (f === c) break;
          for (; f.sibling === null; ) {
            if (f.return === null || f.return === c) return !0;
            f = f.return;
          }
          f.sibling.return = f.return, f = f.sibling;
        }
      }
      return !0;
    }
    function _s(c, f, m, w) {
      f &= ~sw, f &= ~Al, c.suspendedLanes |= f, c.pingedLanes &= ~f, w && (c.warmLanes |= f), w = c.expirationTimes;
      for (var O = f; 0 < O; ) {
        var N = 31 - _e(O), q = 1 << N;
        w[N] = -1, O &= ~q;
      }
      m !== 0 && rs(c, m, f);
    }
    function dg() {
      return (qt & 6) === 0 ? (Od(0), !1) : !0;
    }
    function pw() {
      if (St !== null) {
        if (Wt === 0)
          var c = St.return;
        else
          c = St, ua = El = null, Ax(c), Zc = null, bd = 0, c = St;
        for (; c !== null; )
          $N(c.alternate, c), c = c.return;
        St = null;
      }
    }
    function iu(c, f) {
      var m = c.timeoutHandle;
      m !== -1 && (c.timeoutHandle = -1, FW(m)), m = c.cancelPendingCommit, m !== null && (c.cancelPendingCommit = null, m()), pw(), ln = c, St = m = sa(c.current, null), Ot = f, Wt = 0, Yr = null, bs = !1, tu = Ct(c, f), aw = !1, nu = bo = sw = Al = xs = En = 0, jr = Td = null, lw = !1, (f & 8) !== 0 && (f |= f & 32);
      var w = c.entangledLanes;
      if (w !== 0)
        for (c = c.entanglements, w &= f; 0 < w; ) {
          var O = 31 - _e(w), N = 1 << O;
          f |= c[O], w &= ~N;
        }
      return va = f, $m(), m;
    }
    function nM(c, f) {
      pt = null, F.H = Jm, f === ud || f === Vm ? (f = bA(), Wt = 3) : f === gA ? (f = bA(), Wt = 4) : Wt = f === xN ? 8 : f !== null && typeof f == "object" && typeof f.then == "function" ? 6 : 1, Yr = f, St === null && (En = 1, og(
        c,
        ho(f, c.current)
      ));
    }
    function rM() {
      var c = F.H;
      return F.H = Jm, c === null ? Jm : c;
    }
    function oM() {
      var c = F.A;
      return F.A = vW, c;
    }
    function hw() {
      En = 4, bs || (Ot & 4194048) !== Ot && vo.current !== null || (tu = !0), (xs & 134217727) === 0 && (Al & 134217727) === 0 || ln === null || _s(
        ln,
        Ot,
        bo,
        !1
      );
    }
    function mw(c, f, m) {
      var w = qt;
      qt |= 2;
      var O = rM(), N = oM();
      (ln !== c || Ot !== f) && (fg = null, iu(c, f)), f = !1;
      var q = En;
      e: do
        try {
          if (Wt !== 0 && St !== null) {
            var Z = St, ne = Yr;
            switch (Wt) {
              case 8:
                pw(), q = 6;
                break e;
              case 3:
              case 2:
              case 9:
              case 6:
                vo.current === null && (f = !0);
                var pe = Wt;
                if (Wt = 0, Yr = null, au(c, Z, ne, pe), m && tu) {
                  q = 0;
                  break e;
                }
                break;
              default:
                pe = Wt, Wt = 0, Yr = null, au(c, Z, ne, pe);
            }
          }
          wW(), q = En;
          break;
        } catch (be) {
          nM(c, be);
        }
      while (!0);
      return f && c.shellSuspendCounter++, ua = El = null, qt = w, F.H = O, F.A = N, St === null && (ln = null, Ot = 0, $m()), q;
    }
    function wW() {
      for (; St !== null; ) iM(St);
    }
    function SW(c, f) {
      var m = qt;
      qt |= 2;
      var w = rM(), O = oM();
      ln !== c || Ot !== f ? (fg = null, ug = Ne() + 500, iu(c, f)) : tu = Ct(
        c,
        f
      );
      e: do
        try {
          if (Wt !== 0 && St !== null) {
            f = St;
            var N = Yr;
            t: switch (Wt) {
              case 1:
                Wt = 0, Yr = null, au(c, f, N, 1);
                break;
              case 2:
              case 9:
                if (yA(N)) {
                  Wt = 0, Yr = null, aM(f);
                  break;
                }
                f = function() {
                  Wt !== 2 && Wt !== 9 || ln !== c || (Wt = 7), fi(c);
                }, N.then(f, f);
                break e;
              case 3:
                Wt = 7;
                break e;
              case 4:
                Wt = 5;
                break e;
              case 7:
                yA(N) ? (Wt = 0, Yr = null, aM(f)) : (Wt = 0, Yr = null, au(c, f, N, 7));
                break;
              case 5:
                var q = null;
                switch (St.tag) {
                  case 26:
                    q = St.memoizedState;
                  case 5:
                  case 27:
                    var Z = St;
                    if (!q || BM(q)) {
                      Wt = 0, Yr = null;
                      var ne = Z.sibling;
                      if (ne !== null) St = ne;
                      else {
                        var pe = Z.return;
                        pe !== null ? (St = pe, pg(pe)) : St = null;
                      }
                      break t;
                    }
                }
                Wt = 0, Yr = null, au(c, f, N, 5);
                break;
              case 6:
                Wt = 0, Yr = null, au(c, f, N, 6);
                break;
              case 8:
                pw(), En = 6;
                break e;
              default:
                throw Error(r(462));
            }
          }
          _W();
          break;
        } catch (be) {
          nM(c, be);
        }
      while (!0);
      return ua = El = null, F.H = w, F.A = O, qt = m, St !== null ? 0 : (ln = null, Ot = 0, $m(), En);
    }
    function _W() {
      for (; St !== null && !ge(); )
        iM(St);
    }
    function iM(c) {
      var f = MN(c.alternate, c, va);
      c.memoizedProps = c.pendingProps, f === null ? pg(c) : St = f;
    }
    function aM(c) {
      var f = c, m = f.alternate;
      switch (f.tag) {
        case 15:
        case 0:
          f = kN(
            m,
            f,
            f.pendingProps,
            f.type,
            void 0,
            Ot
          );
          break;
        case 11:
          f = kN(
            m,
            f,
            f.pendingProps,
            f.type.render,
            f.ref,
            Ot
          );
          break;
        case 5:
          Ax(f);
        default:
          $N(m, f), f = St = sA(f, va), f = MN(m, f, va);
      }
      c.memoizedProps = c.pendingProps, f === null ? pg(c) : St = f;
    }
    function au(c, f, m, w) {
      ua = El = null, Ax(f), Zc = null, bd = 0;
      var O = f.return;
      try {
        if (dW(
          c,
          O,
          f,
          m,
          Ot
        )) {
          En = 1, og(
            c,
            ho(m, c.current)
          ), St = null;
          return;
        }
      } catch (N) {
        if (O !== null) throw St = O, N;
        En = 1, og(
          c,
          ho(m, c.current)
        ), St = null;
        return;
      }
      f.flags & 32768 ? (Lt || w === 1 ? c = !0 : tu || (Ot & 536870912) !== 0 ? c = !1 : (bs = c = !0, (w === 2 || w === 9 || w === 3 || w === 6) && (w = vo.current, w !== null && w.tag === 13 && (w.flags |= 16384))), sM(f, c)) : pg(f);
    }
    function pg(c) {
      var f = c;
      do {
        if ((f.flags & 32768) !== 0) {
          sM(
            f,
            bs
          );
          return;
        }
        c = f.return;
        var m = hW(
          f.alternate,
          f,
          va
        );
        if (m !== null) {
          St = m;
          return;
        }
        if (f = f.sibling, f !== null) {
          St = f;
          return;
        }
        St = f = c;
      } while (f !== null);
      En === 0 && (En = 5);
    }
    function sM(c, f) {
      do {
        var m = mW(c.alternate, c);
        if (m !== null) {
          m.flags &= 32767, St = m;
          return;
        }
        if (m = c.return, m !== null && (m.flags |= 32768, m.subtreeFlags = 0, m.deletions = null), !f && (c = c.sibling, c !== null)) {
          St = c;
          return;
        }
        St = c = m;
      } while (c !== null);
      En = 6, St = null;
    }
    function lM(c, f, m, w, O, N, q, Z, ne) {
      c.cancelPendingCommit = null;
      do
        hg();
      while (rr !== 0);
      if ((qt & 6) !== 0) throw Error(r(327));
      if (f !== null) {
        if (f === c.current) throw Error(r(177));
        if (N = f.lanes | f.childLanes, N |= ix, On(
          c,
          m,
          N,
          q,
          Z,
          ne
        ), c === ln && (St = ln = null, Ot = 0), ru = f, Ss = c, ou = m, uw = N, fw = O, QN = w, (f.subtreeFlags & 10256) !== 0 || (f.flags & 10256) !== 0 ? (c.callbackNode = null, c.callbackPriority = 0, TW(ze, function() {
          return pM(), null;
        })) : (c.callbackNode = null, c.callbackPriority = 0), w = (f.flags & 13878) !== 0, (f.subtreeFlags & 13878) !== 0 || w) {
          w = F.T, F.T = null, O = G.p, G.p = 2, q = qt, qt |= 4;
          try {
            gW(c, f, m);
          } finally {
            qt = q, G.p = O, F.T = w;
          }
        }
        rr = 1, cM(), uM(), fM();
      }
    }
    function cM() {
      if (rr === 1) {
        rr = 0;
        var c = Ss, f = ru, m = (f.flags & 13878) !== 0;
        if ((f.subtreeFlags & 13878) !== 0 || m) {
          m = F.T, F.T = null;
          var w = G.p;
          G.p = 2;
          var O = qt;
          qt |= 4;
          try {
            qN(f, c);
            var N = Tw, q = ZO(c.containerInfo), Z = N.focusedElem, ne = N.selectionRange;
            if (q !== Z && Z && Z.ownerDocument && XO(
              Z.ownerDocument.documentElement,
              Z
            )) {
              if (ne !== null && ex(Z)) {
                var pe = ne.start, be = ne.end;
                if (be === void 0 && (be = pe), "selectionStart" in Z)
                  Z.selectionStart = pe, Z.selectionEnd = Math.min(
                    be,
                    Z.value.length
                  );
                else {
                  var we = Z.ownerDocument || document, he = we && we.defaultView || window;
                  if (he.getSelection) {
                    var me = he.getSelection(), nt = Z.textContent.length, Qe = Math.min(ne.start, nt), en = ne.end === void 0 ? Qe : Math.min(ne.end, nt);
                    !me.extend && Qe > en && (q = en, en = Qe, Qe = q);
                    var ce = YO(
                      Z,
                      Qe
                    ), se = YO(
                      Z,
                      en
                    );
                    if (ce && se && (me.rangeCount !== 1 || me.anchorNode !== ce.node || me.anchorOffset !== ce.offset || me.focusNode !== se.node || me.focusOffset !== se.offset)) {
                      var de = we.createRange();
                      de.setStart(ce.node, ce.offset), me.removeAllRanges(), Qe > en ? (me.addRange(de), me.extend(se.node, se.offset)) : (de.setEnd(se.node, se.offset), me.addRange(de));
                    }
                  }
                }
              }
              for (we = [], me = Z; me = me.parentNode; )
                me.nodeType === 1 && we.push({
                  element: me,
                  left: me.scrollLeft,
                  top: me.scrollTop
                });
              for (typeof Z.focus == "function" && Z.focus(), Z = 0; Z < we.length; Z++) {
                var xe = we[Z];
                xe.element.scrollLeft = xe.left, xe.element.scrollTop = xe.top;
              }
            }
            kg = !!kw, Tw = kw = null;
          } finally {
            qt = O, G.p = w, F.T = m;
          }
        }
        c.current = f, rr = 2;
      }
    }
    function uM() {
      if (rr === 2) {
        rr = 0;
        var c = Ss, f = ru, m = (f.flags & 8772) !== 0;
        if ((f.subtreeFlags & 8772) !== 0 || m) {
          m = F.T, F.T = null;
          var w = G.p;
          G.p = 2;
          var O = qt;
          qt |= 4;
          try {
            BN(c, f.alternate, f);
          } finally {
            qt = O, G.p = w, F.T = m;
          }
        }
        rr = 3;
      }
    }
    function fM() {
      if (rr === 4 || rr === 3) {
        rr = 0, Ce();
        var c = Ss, f = ru, m = ou, w = QN;
        (f.subtreeFlags & 10256) !== 0 || (f.flags & 10256) !== 0 ? rr = 5 : (rr = 0, ru = Ss = null, dM(c, c.pendingLanes));
        var O = c.pendingLanes;
        if (O === 0 && (ws = null), zf(m), f = f.stateNode, ue && typeof ue.onCommitFiberRoot == "function")
          try {
            ue.onCommitFiberRoot(
              oe,
              f,
              void 0,
              (f.current.flags & 128) === 128
            );
          } catch {
          }
        if (w !== null) {
          f = F.T, O = G.p, G.p = 2, F.T = null;
          try {
            for (var N = c.onRecoverableError, q = 0; q < w.length; q++) {
              var Z = w[q];
              N(Z.value, {
                componentStack: Z.stack
              });
            }
          } finally {
            F.T = f, G.p = O;
          }
        }
        (ou & 3) !== 0 && hg(), fi(c), O = c.pendingLanes, (m & 4194090) !== 0 && (O & 42) !== 0 ? c === dw ? Rd++ : (Rd = 0, dw = c) : Rd = 0, Od(0);
      }
    }
    function dM(c, f) {
      (c.pooledCacheLanes &= f) === 0 && (f = c.pooledCache, f != null && (c.pooledCache = null, ld(f)));
    }
    function hg(c) {
      return cM(), uM(), fM(), pM();
    }
    function pM() {
      if (rr !== 5) return !1;
      var c = Ss, f = uw;
      uw = 0;
      var m = zf(ou), w = F.T, O = G.p;
      try {
        G.p = 32 > m ? 32 : m, F.T = null, m = fw, fw = null;
        var N = Ss, q = ou;
        if (rr = 0, ru = Ss = null, ou = 0, (qt & 6) !== 0) throw Error(r(331));
        var Z = qt;
        if (qt |= 4, XN(N.current), GN(
          N,
          N.current,
          q,
          m
        ), qt = Z, Od(0, !1), ue && typeof ue.onPostCommitFiberRoot == "function")
          try {
            ue.onPostCommitFiberRoot(oe, N);
          } catch {
          }
        return !0;
      } finally {
        G.p = O, F.T = w, dM(c, f);
      }
    }
    function hM(c, f, m) {
      f = ho(m, f), f = Hx(c.stateNode, f, 2), c = ds(c, f, 2), c !== null && (Zt(c, 2), fi(c));
    }
    function rn(c, f, m) {
      if (c.tag === 3)
        hM(c, c, m);
      else
        for (; f !== null; ) {
          if (f.tag === 3) {
            hM(
              f,
              c,
              m
            );
            break;
          } else if (f.tag === 1) {
            var w = f.stateNode;
            if (typeof f.type.getDerivedStateFromError == "function" || typeof w.componentDidCatch == "function" && (ws === null || !ws.has(w))) {
              c = ho(m, c), m = vN(2), w = ds(f, m, 2), w !== null && (bN(
                m,
                w,
                f,
                c
              ), Zt(w, 2), fi(w));
              break;
            }
          }
          f = f.return;
        }
    }
    function gw(c, f, m) {
      var w = c.pingCache;
      if (w === null) {
        w = c.pingCache = new bW();
        var O = /* @__PURE__ */ new Set();
        w.set(f, O);
      } else
        O = w.get(f), O === void 0 && (O = /* @__PURE__ */ new Set(), w.set(f, O));
      O.has(m) || (aw = !0, O.add(m), c = EW.bind(null, c, f, m), f.then(c, c));
    }
    function EW(c, f, m) {
      var w = c.pingCache;
      w !== null && w.delete(f), c.pingedLanes |= c.suspendedLanes & m, c.warmLanes &= ~m, ln === c && (Ot & m) === m && (En === 4 || En === 3 && (Ot & 62914560) === Ot && 300 > Ne() - cw ? (qt & 2) === 0 && iu(c, 0) : sw |= m, nu === Ot && (nu = 0)), fi(c);
    }
    function mM(c, f) {
      f === 0 && (f = ns()), c = Bc(c, f), c !== null && (Zt(c, f), fi(c));
    }
    function CW(c) {
      var f = c.memoizedState, m = 0;
      f !== null && (m = f.retryLane), mM(c, m);
    }
    function kW(c, f) {
      var m = 0;
      switch (c.tag) {
        case 13:
          var w = c.stateNode, O = c.memoizedState;
          O !== null && (m = O.retryLane);
          break;
        case 19:
          w = c.stateNode;
          break;
        case 22:
          w = c.stateNode._retryCache;
          break;
        default:
          throw Error(r(314));
      }
      w !== null && w.delete(f), mM(c, m);
    }
    function TW(c, f) {
      return ie(c, f);
    }
    var mg = null, su = null, yw = !1, gg = !1, vw = !1, Nl = 0;
    function fi(c) {
      c !== su && c.next === null && (su === null ? mg = su = c : su = su.next = c), gg = !0, yw || (yw = !0, OW());
    }
    function Od(c, f) {
      if (!vw && gg) {
        vw = !0;
        do
          for (var m = !1, w = mg; w !== null; ) {
            if (c !== 0) {
              var O = w.pendingLanes;
              if (O === 0) var N = 0;
              else {
                var q = w.suspendedLanes, Z = w.pingedLanes;
                N = (1 << 31 - _e(42 | c) + 1) - 1, N &= O & ~(q & ~Z), N = N & 201326741 ? N & 201326741 | 1 : N ? N | 2 : 0;
              }
              N !== 0 && (m = !0, bM(w, N));
            } else
              N = Ot, N = tt(
                w,
                w === ln ? N : 0,
                w.cancelPendingCommit !== null || w.timeoutHandle !== -1
              ), (N & 3) === 0 || Ct(w, N) || (m = !0, bM(w, N));
            w = w.next;
          }
        while (m);
        vw = !1;
      }
    }
    function RW() {
      gM();
    }
    function gM() {
      gg = yw = !1;
      var c = 0;
      Nl !== 0 && (DW() && (c = Nl), Nl = 0);
      for (var f = Ne(), m = null, w = mg; w !== null; ) {
        var O = w.next, N = yM(w, f);
        N === 0 ? (w.next = null, m === null ? mg = O : m.next = O, O === null && (su = m)) : (m = w, (c !== 0 || (N & 3) !== 0) && (gg = !0)), w = O;
      }
      Od(c);
    }
    function yM(c, f) {
      for (var m = c.suspendedLanes, w = c.pingedLanes, O = c.expirationTimes, N = c.pendingLanes & -62914561; 0 < N; ) {
        var q = 31 - _e(N), Z = 1 << q, ne = O[q];
        ne === -1 ? ((Z & m) === 0 || (Z & w) !== 0) && (O[q] = Sn(Z, f)) : ne <= f && (c.expiredLanes |= Z), N &= ~Z;
      }
      if (f = ln, m = Ot, m = tt(
        c,
        c === f ? m : 0,
        c.cancelPendingCommit !== null || c.timeoutHandle !== -1
      ), w = c.callbackNode, m === 0 || c === f && (Wt === 2 || Wt === 9) || c.cancelPendingCommit !== null)
        return w !== null && w !== null && ae(w), c.callbackNode = null, c.callbackPriority = 0;
      if ((m & 3) === 0 || Ct(c, m)) {
        if (f = m & -m, f === c.callbackPriority) return f;
        switch (w !== null && ae(w), zf(m)) {
          case 2:
          case 8:
            m = Ke;
            break;
          case 32:
            m = ze;
            break;
          case 268435456:
            m = ct;
            break;
          default:
            m = ze;
        }
        return w = vM.bind(null, c), m = ie(m, w), c.callbackPriority = f, c.callbackNode = m, f;
      }
      return w !== null && w !== null && ae(w), c.callbackPriority = 2, c.callbackNode = null, 2;
    }
    function vM(c, f) {
      if (rr !== 0 && rr !== 5)
        return c.callbackNode = null, c.callbackPriority = 0, null;
      var m = c.callbackNode;
      if (hg() && c.callbackNode !== m)
        return null;
      var w = Ot;
      return w = tt(
        c,
        c === ln ? w : 0,
        c.cancelPendingCommit !== null || c.timeoutHandle !== -1
      ), w === 0 ? null : (eM(c, w, f), yM(c, Ne()), c.callbackNode != null && c.callbackNode === m ? vM.bind(null, c) : null);
    }
    function bM(c, f) {
      if (hg()) return null;
      eM(c, f, !0);
    }
    function OW() {
      LW(function() {
        (qt & 6) !== 0 ? ie(
          Ve,
          RW
        ) : gM();
      });
    }
    function bw() {
      return Nl === 0 && (Nl = $o()), Nl;
    }
    function xM(c) {
      return c == null || typeof c == "symbol" || typeof c == "boolean" ? null : typeof c == "function" ? c : Tm("" + c);
    }
    function wM(c, f) {
      var m = f.ownerDocument.createElement("input");
      return m.name = f.name, m.value = f.value, c.id && m.setAttribute("form", c.id), f.parentNode.insertBefore(m, f), c = new FormData(c), m.parentNode.removeChild(m), c;
    }
    function AW(c, f, m, w, O) {
      if (f === "submit" && m && m.stateNode === O) {
        var N = xM(
          (O[ur] || null).action
        ), q = w.submitter;
        q && (f = (f = q[ur] || null) ? xM(f.formAction) : q.getAttribute("formAction"), f !== null && (N = f, q = null));
        var Z = new Nm(
          "action",
          "action",
          null,
          w,
          O
        );
        c.push({
          event: Z,
          listeners: [
            {
              instance: null,
              listener: function() {
                if (w.defaultPrevented) {
                  if (Nl !== 0) {
                    var ne = q ? wM(O, q) : new FormData(O);
                    Lx(
                      m,
                      {
                        pending: !0,
                        data: ne,
                        method: O.method,
                        action: N
                      },
                      null,
                      ne
                    );
                  }
                } else
                  typeof N == "function" && (Z.preventDefault(), ne = q ? wM(O, q) : new FormData(O), Lx(
                    m,
                    {
                      pending: !0,
                      data: ne,
                      method: O.method,
                      action: N
                    },
                    N,
                    ne
                  ));
              },
              currentTarget: O
            }
          ]
        });
      }
    }
    for (var xw = 0; xw < ox.length; xw++) {
      var ww = ox[xw], NW = ww.toLowerCase(), MW = ww[0].toUpperCase() + ww.slice(1);
      jo(
        NW,
        "on" + MW
      );
    }
    jo(eA, "onAnimationEnd"), jo(tA, "onAnimationIteration"), jo(nA, "onAnimationStart"), jo("dblclick", "onDoubleClick"), jo("focusin", "onFocus"), jo("focusout", "onBlur"), jo(Yq, "onTransitionRun"), jo(Xq, "onTransitionStart"), jo(Zq, "onTransitionCancel"), jo(rA, "onTransitionEnd"), ss("onMouseEnter", ["mouseout", "mouseover"]), ss("onMouseLeave", ["mouseout", "mouseover"]), ss("onPointerEnter", ["pointerout", "pointerover"]), ss("onPointerLeave", ["pointerout", "pointerover"]), ra(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(" ")
    ), ra(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    ), ra("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]), ra(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    ), ra(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    ), ra(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
    var Ad = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ), PW = new Set(
      "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Ad)
    );
    function SM(c, f) {
      f = (f & 4) !== 0;
      for (var m = 0; m < c.length; m++) {
        var w = c[m], O = w.event;
        w = w.listeners;
        e: {
          var N = void 0;
          if (f)
            for (var q = w.length - 1; 0 <= q; q--) {
              var Z = w[q], ne = Z.instance, pe = Z.currentTarget;
              if (Z = Z.listener, ne !== N && O.isPropagationStopped())
                break e;
              N = Z, O.currentTarget = pe;
              try {
                N(O);
              } catch (be) {
                rg(be);
              }
              O.currentTarget = null, N = ne;
            }
          else
            for (q = 0; q < w.length; q++) {
              if (Z = w[q], ne = Z.instance, pe = Z.currentTarget, Z = Z.listener, ne !== N && O.isPropagationStopped())
                break e;
              N = Z, O.currentTarget = pe;
              try {
                N(O);
              } catch (be) {
                rg(be);
              }
              O.currentTarget = null, N = ne;
            }
        }
      }
    }
    function _t(c, f) {
      var m = f[Bf];
      m === void 0 && (m = f[Bf] = /* @__PURE__ */ new Set());
      var w = c + "__bubble";
      m.has(w) || (_M(f, c, 2, !1), m.add(w));
    }
    function Sw(c, f, m) {
      var w = 0;
      f && (w |= 4), _M(
        m,
        c,
        w,
        f
      );
    }
    var yg = "_reactListening" + Math.random().toString(36).slice(2);
    function _w(c) {
      if (!c[yg]) {
        c[yg] = !0, xm.forEach(function(m) {
          m !== "selectionchange" && (PW.has(m) || Sw(m, !1, c), Sw(m, !0, c));
        });
        var f = c.nodeType === 9 ? c : c.ownerDocument;
        f === null || f[yg] || (f[yg] = !0, Sw("selectionchange", !1, f));
      }
    }
    function _M(c, f, m, w) {
      switch (GM(f)) {
        case 2:
          var O = aG;
          break;
        case 8:
          O = sG;
          break;
        default:
          O = Dw;
      }
      m = O.bind(
        null,
        f,
        m,
        c
      ), O = void 0, !q1 || f !== "touchstart" && f !== "touchmove" && f !== "wheel" || (O = !0), w ? O !== void 0 ? c.addEventListener(f, m, {
        capture: !0,
        passive: O
      }) : c.addEventListener(f, m, !0) : O !== void 0 ? c.addEventListener(f, m, {
        passive: O
      }) : c.addEventListener(f, m, !1);
    }
    function Ew(c, f, m, w, O) {
      var N = w;
      if ((f & 1) === 0 && (f & 2) === 0 && w !== null)
        e: for (; ; ) {
          if (w === null) return;
          var q = w.tag;
          if (q === 3 || q === 4) {
            var Z = w.stateNode.containerInfo;
            if (Z === O) break;
            if (q === 4)
              for (q = w.return; q !== null; ) {
                var ne = q.tag;
                if ((ne === 3 || ne === 4) && q.stateNode.containerInfo === O)
                  return;
                q = q.return;
              }
            for (; Z !== null; ) {
              if (q = is(Z), q === null) return;
              if (ne = q.tag, ne === 5 || ne === 6 || ne === 26 || ne === 27) {
                w = N = q;
                continue e;
              }
              Z = Z.parentNode;
            }
          }
          w = w.return;
        }
      AO(function() {
        var pe = N, be = V1(m), we = [];
        e: {
          var he = oA.get(c);
          if (he !== void 0) {
            var me = Nm, nt = c;
            switch (c) {
              case "keypress":
                if (Om(m) === 0) break e;
              case "keydown":
              case "keyup":
                me = Tq;
                break;
              case "focusin":
                nt = "focus", me = Y1;
                break;
              case "focusout":
                nt = "blur", me = Y1;
                break;
              case "beforeblur":
              case "afterblur":
                me = Y1;
                break;
              case "click":
                if (m.button === 2) break e;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                me = PO;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                me = mq;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                me = Aq;
                break;
              case eA:
              case tA:
              case nA:
                me = vq;
                break;
              case rA:
                me = Mq;
                break;
              case "scroll":
              case "scrollend":
                me = pq;
                break;
              case "wheel":
                me = $q;
                break;
              case "copy":
              case "cut":
              case "paste":
                me = xq;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                me = IO;
                break;
              case "toggle":
              case "beforetoggle":
                me = jq;
            }
            var Qe = (f & 4) !== 0, en = !Qe && (c === "scroll" || c === "scrollend"), ce = Qe ? he !== null ? he + "Capture" : null : he;
            Qe = [];
            for (var se = pe, de; se !== null; ) {
              var xe = se;
              if (de = xe.stateNode, xe = xe.tag, xe !== 5 && xe !== 26 && xe !== 27 || de === null || ce === null || (xe = Yf(se, ce), xe != null && Qe.push(
                Nd(se, xe, de)
              )), en) break;
              se = se.return;
            }
            0 < Qe.length && (he = new me(
              he,
              nt,
              null,
              m,
              be
            ), we.push({ event: he, listeners: Qe }));
          }
        }
        if ((f & 7) === 0) {
          e: {
            if (he = c === "mouseover" || c === "pointerover", me = c === "mouseout" || c === "pointerout", he && m !== U1 && (nt = m.relatedTarget || m.fromElement) && (is(nt) || nt[os]))
              break e;
            if ((me || he) && (he = be.window === be ? be : (he = be.ownerDocument) ? he.defaultView || he.parentWindow : window, me ? (nt = m.relatedTarget || m.toElement, me = pe, nt = nt ? is(nt) : null, nt !== null && (en = i(nt), Qe = nt.tag, nt !== en || Qe !== 5 && Qe !== 27 && Qe !== 6) && (nt = null)) : (me = null, nt = pe), me !== nt)) {
              if (Qe = PO, xe = "onMouseLeave", ce = "onMouseEnter", se = "mouse", (c === "pointerout" || c === "pointerover") && (Qe = IO, xe = "onPointerLeave", ce = "onPointerEnter", se = "pointer"), en = me == null ? he : as(me), de = nt == null ? he : as(nt), he = new Qe(
                xe,
                se + "leave",
                me,
                m,
                be
              ), he.target = en, he.relatedTarget = de, xe = null, is(be) === pe && (Qe = new Qe(
                ce,
                se + "enter",
                nt,
                m,
                be
              ), Qe.target = de, Qe.relatedTarget = en, xe = Qe), en = xe, me && nt)
                t: {
                  for (Qe = me, ce = nt, se = 0, de = Qe; de; de = lu(de))
                    se++;
                  for (de = 0, xe = ce; xe; xe = lu(xe))
                    de++;
                  for (; 0 < se - de; )
                    Qe = lu(Qe), se--;
                  for (; 0 < de - se; )
                    ce = lu(ce), de--;
                  for (; se--; ) {
                    if (Qe === ce || ce !== null && Qe === ce.alternate)
                      break t;
                    Qe = lu(Qe), ce = lu(ce);
                  }
                  Qe = null;
                }
              else Qe = null;
              me !== null && EM(
                we,
                he,
                me,
                Qe,
                !1
              ), nt !== null && en !== null && EM(
                we,
                en,
                nt,
                Qe,
                !0
              );
            }
          }
          e: {
            if (he = pe ? as(pe) : window, me = he.nodeName && he.nodeName.toLowerCase(), me === "select" || me === "input" && he.type === "file")
              var De = VO;
            else if (BO(he))
              if (HO)
                De = Wq;
              else {
                De = Hq;
                var vt = Vq;
              }
            else
              me = he.nodeName, !me || me.toLowerCase() !== "input" || he.type !== "checkbox" && he.type !== "radio" ? pe && B1(pe.elementType) && (De = VO) : De = qq;
            if (De && (De = De(c, pe))) {
              UO(
                we,
                De,
                m,
                be
              );
              break e;
            }
            vt && vt(c, he, pe), c === "focusout" && pe && he.type === "number" && pe.memoizedProps.value != null && Kf(he, "number", he.value);
          }
          switch (vt = pe ? as(pe) : window, c) {
            case "focusin":
              (BO(vt) || vt.contentEditable === "true") && (Fc = vt, tx = pe, rd = null);
              break;
            case "focusout":
              rd = tx = Fc = null;
              break;
            case "mousedown":
              nx = !0;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              nx = !1, QO(we, m, be);
              break;
            case "selectionchange":
              if (Kq) break;
            case "keydown":
            case "keyup":
              QO(we, m, be);
          }
          var Be;
          if (Z1)
            e: {
              switch (c) {
                case "compositionstart":
                  var Je = "onCompositionStart";
                  break e;
                case "compositionend":
                  Je = "onCompositionEnd";
                  break e;
                case "compositionupdate":
                  Je = "onCompositionUpdate";
                  break e;
              }
              Je = void 0;
            }
          else
            Dc ? LO(c, m) && (Je = "onCompositionEnd") : c === "keydown" && m.keyCode === 229 && (Je = "onCompositionStart");
          Je && (jO && m.locale !== "ko" && (Dc || Je !== "onCompositionStart" ? Je === "onCompositionEnd" && Dc && (Be = NO()) : (ls = be, W1 = "value" in ls ? ls.value : ls.textContent, Dc = !0)), vt = vg(pe, Je), 0 < vt.length && (Je = new $O(
            Je,
            c,
            null,
            m,
            be
          ), we.push({ event: Je, listeners: vt }), Be ? Je.data = Be : (Be = zO(m), Be !== null && (Je.data = Be)))), (Be = Fq ? Lq(c, m) : zq(c, m)) && (Je = vg(pe, "onBeforeInput"), 0 < Je.length && (vt = new $O(
            "onBeforeInput",
            "beforeinput",
            null,
            m,
            be
          ), we.push({
            event: vt,
            listeners: Je
          }), vt.data = Be)), AW(
            we,
            c,
            pe,
            m,
            be
          );
        }
        SM(we, f);
      });
    }
    function Nd(c, f, m) {
      return {
        instance: c,
        listener: f,
        currentTarget: m
      };
    }
    function vg(c, f) {
      for (var m = f + "Capture", w = []; c !== null; ) {
        var O = c, N = O.stateNode;
        if (O = O.tag, O !== 5 && O !== 26 && O !== 27 || N === null || (O = Yf(c, m), O != null && w.unshift(
          Nd(c, O, N)
        ), O = Yf(c, f), O != null && w.push(
          Nd(c, O, N)
        )), c.tag === 3) return w;
        c = c.return;
      }
      return [];
    }
    function lu(c) {
      if (c === null) return null;
      do
        c = c.return;
      while (c && c.tag !== 5 && c.tag !== 27);
      return c || null;
    }
    function EM(c, f, m, w, O) {
      for (var N = f._reactName, q = []; m !== null && m !== w; ) {
        var Z = m, ne = Z.alternate, pe = Z.stateNode;
        if (Z = Z.tag, ne !== null && ne === w) break;
        Z !== 5 && Z !== 26 && Z !== 27 || pe === null || (ne = pe, O ? (pe = Yf(m, N), pe != null && q.unshift(
          Nd(m, pe, ne)
        )) : O || (pe = Yf(m, N), pe != null && q.push(
          Nd(m, pe, ne)
        ))), m = m.return;
      }
      q.length !== 0 && c.push({ event: f, listeners: q });
    }
    var $W = /\r\n?/g, IW = /\u0000|\uFFFD/g;
    function CM(c) {
      return (typeof c == "string" ? c : "" + c).replace($W, `
`).replace(IW, "");
    }
    function kM(c, f) {
      return f = CM(f), CM(c) === f;
    }
    function bg() {
    }
    function Jt(c, f, m, w, O, N) {
      switch (m) {
        case "children":
          typeof w == "string" ? f === "body" || f === "textarea" && w === "" || $c(c, w) : (typeof w == "number" || typeof w == "bigint") && f !== "body" && $c(c, "" + w);
          break;
        case "className":
          Nc(c, "class", w);
          break;
        case "tabIndex":
          Nc(c, "tabindex", w);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          Nc(c, m, w);
          break;
        case "style":
          RO(c, w, N);
          break;
        case "data":
          if (f !== "object") {
            Nc(c, "data", w);
            break;
          }
        case "src":
        case "href":
          if (w === "" && (f !== "a" || m !== "href")) {
            c.removeAttribute(m);
            break;
          }
          if (w == null || typeof w == "function" || typeof w == "symbol" || typeof w == "boolean") {
            c.removeAttribute(m);
            break;
          }
          w = Tm("" + w), c.setAttribute(m, w);
          break;
        case "action":
        case "formAction":
          if (typeof w == "function") {
            c.setAttribute(
              m,
              "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
            );
            break;
          } else
            typeof N == "function" && (m === "formAction" ? (f !== "input" && Jt(c, f, "name", O.name, O, null), Jt(
              c,
              f,
              "formEncType",
              O.formEncType,
              O,
              null
            ), Jt(
              c,
              f,
              "formMethod",
              O.formMethod,
              O,
              null
            ), Jt(
              c,
              f,
              "formTarget",
              O.formTarget,
              O,
              null
            )) : (Jt(c, f, "encType", O.encType, O, null), Jt(c, f, "method", O.method, O, null), Jt(c, f, "target", O.target, O, null)));
          if (w == null || typeof w == "symbol" || typeof w == "boolean") {
            c.removeAttribute(m);
            break;
          }
          w = Tm("" + w), c.setAttribute(m, w);
          break;
        case "onClick":
          w != null && (c.onclick = bg);
          break;
        case "onScroll":
          w != null && _t("scroll", c);
          break;
        case "onScrollEnd":
          w != null && _t("scrollend", c);
          break;
        case "dangerouslySetInnerHTML":
          if (w != null) {
            if (typeof w != "object" || !("__html" in w))
              throw Error(r(61));
            if (m = w.__html, m != null) {
              if (O.children != null) throw Error(r(60));
              c.innerHTML = m;
            }
          }
          break;
        case "multiple":
          c.multiple = w && typeof w != "function" && typeof w != "symbol";
          break;
        case "muted":
          c.muted = w && typeof w != "function" && typeof w != "symbol";
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (w == null || typeof w == "function" || typeof w == "boolean" || typeof w == "symbol") {
            c.removeAttribute("xlink:href");
            break;
          }
          m = Tm("" + w), c.setAttributeNS(
            "http://www.w3.org/1999/xlink",
            "xlink:href",
            m
          );
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          w != null && typeof w != "function" && typeof w != "symbol" ? c.setAttribute(m, "" + w) : c.removeAttribute(m);
          break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          w && typeof w != "function" && typeof w != "symbol" ? c.setAttribute(m, "") : c.removeAttribute(m);
          break;
        case "capture":
        case "download":
          w === !0 ? c.setAttribute(m, "") : w !== !1 && w != null && typeof w != "function" && typeof w != "symbol" ? c.setAttribute(m, w) : c.removeAttribute(m);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          w != null && typeof w != "function" && typeof w != "symbol" && !isNaN(w) && 1 <= w ? c.setAttribute(m, w) : c.removeAttribute(m);
          break;
        case "rowSpan":
        case "start":
          w == null || typeof w == "function" || typeof w == "symbol" || isNaN(w) ? c.removeAttribute(m) : c.setAttribute(m, w);
          break;
        case "popover":
          _t("beforetoggle", c), _t("toggle", c), Ac(c, "popover", w);
          break;
        case "xlinkActuate":
          Io(
            c,
            "http://www.w3.org/1999/xlink",
            "xlink:actuate",
            w
          );
          break;
        case "xlinkArcrole":
          Io(
            c,
            "http://www.w3.org/1999/xlink",
            "xlink:arcrole",
            w
          );
          break;
        case "xlinkRole":
          Io(
            c,
            "http://www.w3.org/1999/xlink",
            "xlink:role",
            w
          );
          break;
        case "xlinkShow":
          Io(
            c,
            "http://www.w3.org/1999/xlink",
            "xlink:show",
            w
          );
          break;
        case "xlinkTitle":
          Io(
            c,
            "http://www.w3.org/1999/xlink",
            "xlink:title",
            w
          );
          break;
        case "xlinkType":
          Io(
            c,
            "http://www.w3.org/1999/xlink",
            "xlink:type",
            w
          );
          break;
        case "xmlBase":
          Io(
            c,
            "http://www.w3.org/XML/1998/namespace",
            "xml:base",
            w
          );
          break;
        case "xmlLang":
          Io(
            c,
            "http://www.w3.org/XML/1998/namespace",
            "xml:lang",
            w
          );
          break;
        case "xmlSpace":
          Io(
            c,
            "http://www.w3.org/XML/1998/namespace",
            "xml:space",
            w
          );
          break;
        case "is":
          Ac(c, "is", w);
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          (!(2 < m.length) || m[0] !== "o" && m[0] !== "O" || m[1] !== "n" && m[1] !== "N") && (m = fq.get(m) || m, Ac(c, m, w));
      }
    }
    function Cw(c, f, m, w, O, N) {
      switch (m) {
        case "style":
          RO(c, w, N);
          break;
        case "dangerouslySetInnerHTML":
          if (w != null) {
            if (typeof w != "object" || !("__html" in w))
              throw Error(r(61));
            if (m = w.__html, m != null) {
              if (O.children != null) throw Error(r(60));
              c.innerHTML = m;
            }
          }
          break;
        case "children":
          typeof w == "string" ? $c(c, w) : (typeof w == "number" || typeof w == "bigint") && $c(c, "" + w);
          break;
        case "onScroll":
          w != null && _t("scroll", c);
          break;
        case "onScrollEnd":
          w != null && _t("scrollend", c);
          break;
        case "onClick":
          w != null && (c.onclick = bg);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (!wm.hasOwnProperty(m))
            e: {
              if (m[0] === "o" && m[1] === "n" && (O = m.endsWith("Capture"), f = m.slice(2, O ? m.length - 7 : void 0), N = c[ur] || null, N = N != null ? N[m] : null, typeof N == "function" && c.removeEventListener(f, N, O), typeof w == "function")) {
                typeof N != "function" && N !== null && (m in c ? c[m] = null : c.hasAttribute(m) && c.removeAttribute(m)), c.addEventListener(f, w, O);
                break e;
              }
              m in c ? c[m] = w : w === !0 ? c.setAttribute(m, "") : Ac(c, m, w);
            }
      }
    }
    function or(c, f, m) {
      switch (f) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          _t("error", c), _t("load", c);
          var w = !1, O = !1, N;
          for (N in m)
            if (m.hasOwnProperty(N)) {
              var q = m[N];
              if (q != null)
                switch (N) {
                  case "src":
                    w = !0;
                    break;
                  case "srcSet":
                    O = !0;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(r(137, f));
                  default:
                    Jt(c, f, N, q, m, null);
                }
            }
          O && Jt(c, f, "srcSet", m.srcSet, m, null), w && Jt(c, f, "src", m.src, m, null);
          return;
        case "input":
          _t("invalid", c);
          var Z = N = q = O = null, ne = null, pe = null;
          for (w in m)
            if (m.hasOwnProperty(w)) {
              var be = m[w];
              if (be != null)
                switch (w) {
                  case "name":
                    O = be;
                    break;
                  case "type":
                    q = be;
                    break;
                  case "checked":
                    ne = be;
                    break;
                  case "defaultChecked":
                    pe = be;
                    break;
                  case "value":
                    N = be;
                    break;
                  case "defaultValue":
                    Z = be;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (be != null)
                      throw Error(r(137, f));
                    break;
                  default:
                    Jt(c, f, w, be, m, null);
                }
            }
          km(
            c,
            N,
            Z,
            ne,
            pe,
            q,
            O,
            !1
          ), Mc(c);
          return;
        case "select":
          _t("invalid", c), w = q = N = null;
          for (O in m)
            if (m.hasOwnProperty(O) && (Z = m[O], Z != null))
              switch (O) {
                case "value":
                  N = Z;
                  break;
                case "defaultValue":
                  q = Z;
                  break;
                case "multiple":
                  w = Z;
                default:
                  Jt(c, f, O, Z, m, null);
              }
          f = N, m = q, c.multiple = !!w, f != null ? ia(c, !!w, f, !1) : m != null && ia(c, !!w, m, !0);
          return;
        case "textarea":
          _t("invalid", c), N = O = w = null;
          for (q in m)
            if (m.hasOwnProperty(q) && (Z = m[q], Z != null))
              switch (q) {
                case "value":
                  w = Z;
                  break;
                case "defaultValue":
                  O = Z;
                  break;
                case "children":
                  N = Z;
                  break;
                case "dangerouslySetInnerHTML":
                  if (Z != null) throw Error(r(91));
                  break;
                default:
                  Jt(c, f, q, Z, m, null);
              }
          kO(c, w, O, N), Mc(c);
          return;
        case "option":
          for (ne in m)
            if (m.hasOwnProperty(ne) && (w = m[ne], w != null))
              switch (ne) {
                case "selected":
                  c.selected = w && typeof w != "function" && typeof w != "symbol";
                  break;
                default:
                  Jt(c, f, ne, w, m, null);
              }
          return;
        case "dialog":
          _t("beforetoggle", c), _t("toggle", c), _t("cancel", c), _t("close", c);
          break;
        case "iframe":
        case "object":
          _t("load", c);
          break;
        case "video":
        case "audio":
          for (w = 0; w < Ad.length; w++)
            _t(Ad[w], c);
          break;
        case "image":
          _t("error", c), _t("load", c);
          break;
        case "details":
          _t("toggle", c);
          break;
        case "embed":
        case "source":
        case "link":
          _t("error", c), _t("load", c);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (pe in m)
            if (m.hasOwnProperty(pe) && (w = m[pe], w != null))
              switch (pe) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(r(137, f));
                default:
                  Jt(c, f, pe, w, m, null);
              }
          return;
        default:
          if (B1(f)) {
            for (be in m)
              m.hasOwnProperty(be) && (w = m[be], w !== void 0 && Cw(
                c,
                f,
                be,
                w,
                m,
                void 0
              ));
            return;
          }
      }
      for (Z in m)
        m.hasOwnProperty(Z) && (w = m[Z], w != null && Jt(c, f, Z, w, m, null));
    }
    function jW(c, f, m, w) {
      switch (f) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var O = null, N = null, q = null, Z = null, ne = null, pe = null, be = null;
          for (me in m) {
            var we = m[me];
            if (m.hasOwnProperty(me) && we != null)
              switch (me) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  ne = we;
                default:
                  w.hasOwnProperty(me) || Jt(c, f, me, null, w, we);
              }
          }
          for (var he in w) {
            var me = w[he];
            if (we = m[he], w.hasOwnProperty(he) && (me != null || we != null))
              switch (he) {
                case "type":
                  N = me;
                  break;
                case "name":
                  O = me;
                  break;
                case "checked":
                  pe = me;
                  break;
                case "defaultChecked":
                  be = me;
                  break;
                case "value":
                  q = me;
                  break;
                case "defaultValue":
                  Z = me;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (me != null)
                    throw Error(r(137, f));
                  break;
                default:
                  me !== we && Jt(
                    c,
                    f,
                    he,
                    me,
                    w,
                    we
                  );
              }
          }
          ml(
            c,
            q,
            Z,
            ne,
            pe,
            be,
            N,
            O
          );
          return;
        case "select":
          me = q = Z = he = null;
          for (N in m)
            if (ne = m[N], m.hasOwnProperty(N) && ne != null)
              switch (N) {
                case "value":
                  break;
                case "multiple":
                  me = ne;
                default:
                  w.hasOwnProperty(N) || Jt(
                    c,
                    f,
                    N,
                    null,
                    w,
                    ne
                  );
              }
          for (O in w)
            if (N = w[O], ne = m[O], w.hasOwnProperty(O) && (N != null || ne != null))
              switch (O) {
                case "value":
                  he = N;
                  break;
                case "defaultValue":
                  Z = N;
                  break;
                case "multiple":
                  q = N;
                default:
                  N !== ne && Jt(
                    c,
                    f,
                    O,
                    N,
                    w,
                    ne
                  );
              }
          f = Z, m = q, w = me, he != null ? ia(c, !!m, he, !1) : !!w != !!m && (f != null ? ia(c, !!m, f, !0) : ia(c, !!m, m ? [] : "", !1));
          return;
        case "textarea":
          me = he = null;
          for (Z in m)
            if (O = m[Z], m.hasOwnProperty(Z) && O != null && !w.hasOwnProperty(Z))
              switch (Z) {
                case "value":
                  break;
                case "children":
                  break;
                default:
                  Jt(c, f, Z, null, w, O);
              }
          for (q in w)
            if (O = w[q], N = m[q], w.hasOwnProperty(q) && (O != null || N != null))
              switch (q) {
                case "value":
                  he = O;
                  break;
                case "defaultValue":
                  me = O;
                  break;
                case "children":
                  break;
                case "dangerouslySetInnerHTML":
                  if (O != null) throw Error(r(91));
                  break;
                default:
                  O !== N && Jt(c, f, q, O, w, N);
              }
          CO(c, he, me);
          return;
        case "option":
          for (var nt in m)
            if (he = m[nt], m.hasOwnProperty(nt) && he != null && !w.hasOwnProperty(nt))
              switch (nt) {
                case "selected":
                  c.selected = !1;
                  break;
                default:
                  Jt(
                    c,
                    f,
                    nt,
                    null,
                    w,
                    he
                  );
              }
          for (ne in w)
            if (he = w[ne], me = m[ne], w.hasOwnProperty(ne) && he !== me && (he != null || me != null))
              switch (ne) {
                case "selected":
                  c.selected = he && typeof he != "function" && typeof he != "symbol";
                  break;
                default:
                  Jt(
                    c,
                    f,
                    ne,
                    he,
                    w,
                    me
                  );
              }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var Qe in m)
            he = m[Qe], m.hasOwnProperty(Qe) && he != null && !w.hasOwnProperty(Qe) && Jt(c, f, Qe, null, w, he);
          for (pe in w)
            if (he = w[pe], me = m[pe], w.hasOwnProperty(pe) && he !== me && (he != null || me != null))
              switch (pe) {
                case "children":
                case "dangerouslySetInnerHTML":
                  if (he != null)
                    throw Error(r(137, f));
                  break;
                default:
                  Jt(
                    c,
                    f,
                    pe,
                    he,
                    w,
                    me
                  );
              }
          return;
        default:
          if (B1(f)) {
            for (var en in m)
              he = m[en], m.hasOwnProperty(en) && he !== void 0 && !w.hasOwnProperty(en) && Cw(
                c,
                f,
                en,
                void 0,
                w,
                he
              );
            for (be in w)
              he = w[be], me = m[be], !w.hasOwnProperty(be) || he === me || he === void 0 && me === void 0 || Cw(
                c,
                f,
                be,
                he,
                w,
                me
              );
            return;
          }
      }
      for (var ce in m)
        he = m[ce], m.hasOwnProperty(ce) && he != null && !w.hasOwnProperty(ce) && Jt(c, f, ce, null, w, he);
      for (we in w)
        he = w[we], me = m[we], !w.hasOwnProperty(we) || he === me || he == null && me == null || Jt(c, f, we, he, w, me);
    }
    var kw = null, Tw = null;
    function xg(c) {
      return c.nodeType === 9 ? c : c.ownerDocument;
    }
    function TM(c) {
      switch (c) {
        case "http://www.w3.org/2000/svg":
          return 1;
        case "http://www.w3.org/1998/Math/MathML":
          return 2;
        default:
          return 0;
      }
    }
    function RM(c, f) {
      if (c === 0)
        switch (f) {
          case "svg":
            return 1;
          case "math":
            return 2;
          default:
            return 0;
        }
      return c === 1 && f === "foreignObject" ? 0 : c;
    }
    function Rw(c, f) {
      return c === "textarea" || c === "noscript" || typeof f.children == "string" || typeof f.children == "number" || typeof f.children == "bigint" || typeof f.dangerouslySetInnerHTML == "object" && f.dangerouslySetInnerHTML !== null && f.dangerouslySetInnerHTML.__html != null;
    }
    var Ow = null;
    function DW() {
      var c = window.event;
      return c && c.type === "popstate" ? c === Ow ? !1 : (Ow = c, !0) : (Ow = null, !1);
    }
    var OM = typeof setTimeout == "function" ? setTimeout : void 0, FW = typeof clearTimeout == "function" ? clearTimeout : void 0, AM = typeof Promise == "function" ? Promise : void 0, LW = typeof queueMicrotask == "function" ? queueMicrotask : typeof AM < "u" ? function(c) {
      return AM.resolve(null).then(c).catch(zW);
    } : OM;
    function zW(c) {
      setTimeout(function() {
        throw c;
      });
    }
    function Es(c) {
      return c === "head";
    }
    function NM(c, f) {
      var m = f, w = 0, O = 0;
      do {
        var N = m.nextSibling;
        if (c.removeChild(m), N && N.nodeType === 8)
          if (m = N.data, m === "/$") {
            if (0 < w && 8 > w) {
              m = w;
              var q = c.ownerDocument;
              if (m & 1 && Md(q.documentElement), m & 2 && Md(q.body), m & 4)
                for (m = q.head, Md(m), q = m.firstChild; q; ) {
                  var Z = q.nextSibling, ne = q.nodeName;
                  q[hl] || ne === "SCRIPT" || ne === "STYLE" || ne === "LINK" && q.rel.toLowerCase() === "stylesheet" || m.removeChild(q), q = Z;
                }
            }
            if (O === 0) {
              c.removeChild(N), zd(f);
              return;
            }
            O--;
          } else
            m === "$" || m === "$?" || m === "$!" ? O++ : w = m.charCodeAt(0) - 48;
        else w = 0;
        m = N;
      } while (m);
      zd(f);
    }
    function Aw(c) {
      var f = c.firstChild;
      for (f && f.nodeType === 10 && (f = f.nextSibling); f; ) {
        var m = f;
        switch (f = f.nextSibling, m.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            Aw(m), Uf(m);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if (m.rel.toLowerCase() === "stylesheet") continue;
        }
        c.removeChild(m);
      }
    }
    function BW(c, f, m, w) {
      for (; c.nodeType === 1; ) {
        var O = m;
        if (c.nodeName.toLowerCase() !== f.toLowerCase()) {
          if (!w && (c.nodeName !== "INPUT" || c.type !== "hidden"))
            break;
        } else if (w) {
          if (!c[hl])
            switch (f) {
              case "meta":
                if (!c.hasAttribute("itemprop")) break;
                return c;
              case "link":
                if (N = c.getAttribute("rel"), N === "stylesheet" && c.hasAttribute("data-precedence"))
                  break;
                if (N !== O.rel || c.getAttribute("href") !== (O.href == null || O.href === "" ? null : O.href) || c.getAttribute("crossorigin") !== (O.crossOrigin == null ? null : O.crossOrigin) || c.getAttribute("title") !== (O.title == null ? null : O.title))
                  break;
                return c;
              case "style":
                if (c.hasAttribute("data-precedence")) break;
                return c;
              case "script":
                if (N = c.getAttribute("src"), (N !== (O.src == null ? null : O.src) || c.getAttribute("type") !== (O.type == null ? null : O.type) || c.getAttribute("crossorigin") !== (O.crossOrigin == null ? null : O.crossOrigin)) && N && c.hasAttribute("async") && !c.hasAttribute("itemprop"))
                  break;
                return c;
              default:
                return c;
            }
        } else if (f === "input" && c.type === "hidden") {
          var N = O.name == null ? null : "" + O.name;
          if (O.type === "hidden" && c.getAttribute("name") === N)
            return c;
        } else return c;
        if (c = Fo(c.nextSibling), c === null) break;
      }
      return null;
    }
    function UW(c, f, m) {
      if (f === "") return null;
      for (; c.nodeType !== 3; )
        if ((c.nodeType !== 1 || c.nodeName !== "INPUT" || c.type !== "hidden") && !m || (c = Fo(c.nextSibling), c === null)) return null;
      return c;
    }
    function Nw(c) {
      return c.data === "$!" || c.data === "$?" && c.ownerDocument.readyState === "complete";
    }
    function VW(c, f) {
      var m = c.ownerDocument;
      if (c.data !== "$?" || m.readyState === "complete")
        f();
      else {
        var w = function() {
          f(), m.removeEventListener("DOMContentLoaded", w);
        };
        m.addEventListener("DOMContentLoaded", w), c._reactRetry = w;
      }
    }
    function Fo(c) {
      for (; c != null; c = c.nextSibling) {
        var f = c.nodeType;
        if (f === 1 || f === 3) break;
        if (f === 8) {
          if (f = c.data, f === "$" || f === "$!" || f === "$?" || f === "F!" || f === "F")
            break;
          if (f === "/$") return null;
        }
      }
      return c;
    }
    var Mw = null;
    function MM(c) {
      c = c.previousSibling;
      for (var f = 0; c; ) {
        if (c.nodeType === 8) {
          var m = c.data;
          if (m === "$" || m === "$!" || m === "$?") {
            if (f === 0) return c;
            f--;
          } else m === "/$" && f++;
        }
        c = c.previousSibling;
      }
      return null;
    }
    function PM(c, f, m) {
      switch (f = xg(m), c) {
        case "html":
          if (c = f.documentElement, !c) throw Error(r(452));
          return c;
        case "head":
          if (c = f.head, !c) throw Error(r(453));
          return c;
        case "body":
          if (c = f.body, !c) throw Error(r(454));
          return c;
        default:
          throw Error(r(451));
      }
    }
    function Md(c) {
      for (var f = c.attributes; f.length; )
        c.removeAttributeNode(f[0]);
      Uf(c);
    }
    var xo = /* @__PURE__ */ new Map(), $M = /* @__PURE__ */ new Set();
    function wg(c) {
      return typeof c.getRootNode == "function" ? c.getRootNode() : c.nodeType === 9 ? c : c.ownerDocument;
    }
    var ba = G.d;
    G.d = {
      f: HW,
      r: qW,
      D: WW,
      C: GW,
      L: KW,
      m: YW,
      X: ZW,
      S: XW,
      M: QW
    };
    function HW() {
      var c = ba.f(), f = dg();
      return c || f;
    }
    function qW(c) {
      var f = ta(c);
      f !== null && f.tag === 5 && f.type === "form" ? eN(f) : ba.r(c);
    }
    var cu = typeof document > "u" ? null : document;
    function IM(c, f, m) {
      var w = cu;
      if (w && typeof f == "string" && f) {
        var O = Mr(f);
        O = 'link[rel="' + c + '"][href="' + O + '"]', typeof m == "string" && (O += '[crossorigin="' + m + '"]'), $M.has(O) || ($M.add(O), c = { rel: c, crossOrigin: m, href: f }, w.querySelector(O) === null && (f = w.createElement("link"), or(f, "link", c), $n(f), w.head.appendChild(f)));
      }
    }
    function WW(c) {
      ba.D(c), IM("dns-prefetch", c, null);
    }
    function GW(c, f) {
      ba.C(c, f), IM("preconnect", c, f);
    }
    function KW(c, f, m) {
      ba.L(c, f, m);
      var w = cu;
      if (w && c && f) {
        var O = 'link[rel="preload"][as="' + Mr(f) + '"]';
        f === "image" && m && m.imageSrcSet ? (O += '[imagesrcset="' + Mr(
          m.imageSrcSet
        ) + '"]', typeof m.imageSizes == "string" && (O += '[imagesizes="' + Mr(
          m.imageSizes
        ) + '"]')) : O += '[href="' + Mr(c) + '"]';
        var N = O;
        switch (f) {
          case "style":
            N = uu(c);
            break;
          case "script":
            N = fu(c);
        }
        xo.has(N) || (c = d(
          {
            rel: "preload",
            href: f === "image" && m && m.imageSrcSet ? void 0 : c,
            as: f
          },
          m
        ), xo.set(N, c), w.querySelector(O) !== null || f === "style" && w.querySelector(Pd(N)) || f === "script" && w.querySelector($d(N)) || (f = w.createElement("link"), or(f, "link", c), $n(f), w.head.appendChild(f)));
      }
    }
    function YW(c, f) {
      ba.m(c, f);
      var m = cu;
      if (m && c) {
        var w = f && typeof f.as == "string" ? f.as : "script", O = 'link[rel="modulepreload"][as="' + Mr(w) + '"][href="' + Mr(c) + '"]', N = O;
        switch (w) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            N = fu(c);
        }
        if (!xo.has(N) && (c = d({ rel: "modulepreload", href: c }, f), xo.set(N, c), m.querySelector(O) === null)) {
          switch (w) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              if (m.querySelector($d(N)))
                return;
          }
          w = m.createElement("link"), or(w, "link", c), $n(w), m.head.appendChild(w);
        }
      }
    }
    function XW(c, f, m) {
      ba.S(c, f, m);
      var w = cu;
      if (w && c) {
        var O = na(w).hoistableStyles, N = uu(c);
        f = f || "default";
        var q = O.get(N);
        if (!q) {
          var Z = { loading: 0, preload: null };
          if (q = w.querySelector(
            Pd(N)
          ))
            Z.loading = 5;
          else {
            c = d(
              { rel: "stylesheet", href: c, "data-precedence": f },
              m
            ), (m = xo.get(N)) && Pw(c, m);
            var ne = q = w.createElement("link");
            $n(ne), or(ne, "link", c), ne._p = new Promise(function(pe, be) {
              ne.onload = pe, ne.onerror = be;
            }), ne.addEventListener("load", function() {
              Z.loading |= 1;
            }), ne.addEventListener("error", function() {
              Z.loading |= 2;
            }), Z.loading |= 4, Sg(q, f, w);
          }
          q = {
            type: "stylesheet",
            instance: q,
            count: 1,
            state: Z
          }, O.set(N, q);
        }
      }
    }
    function ZW(c, f) {
      ba.X(c, f);
      var m = cu;
      if (m && c) {
        var w = na(m).hoistableScripts, O = fu(c), N = w.get(O);
        N || (N = m.querySelector($d(O)), N || (c = d({ src: c, async: !0 }, f), (f = xo.get(O)) && $w(c, f), N = m.createElement("script"), $n(N), or(N, "link", c), m.head.appendChild(N)), N = {
          type: "script",
          instance: N,
          count: 1,
          state: null
        }, w.set(O, N));
      }
    }
    function QW(c, f) {
      ba.M(c, f);
      var m = cu;
      if (m && c) {
        var w = na(m).hoistableScripts, O = fu(c), N = w.get(O);
        N || (N = m.querySelector($d(O)), N || (c = d({ src: c, async: !0, type: "module" }, f), (f = xo.get(O)) && $w(c, f), N = m.createElement("script"), $n(N), or(N, "link", c), m.head.appendChild(N)), N = {
          type: "script",
          instance: N,
          count: 1,
          state: null
        }, w.set(O, N));
      }
    }
    function jM(c, f, m, w) {
      var O = (O = Q.current) ? wg(O) : null;
      if (!O) throw Error(r(446));
      switch (c) {
        case "meta":
        case "title":
          return null;
        case "style":
          return typeof m.precedence == "string" && typeof m.href == "string" ? (f = uu(m.href), m = na(
            O
          ).hoistableStyles, w = m.get(f), w || (w = {
            type: "style",
            instance: null,
            count: 0,
            state: null
          }, m.set(f, w)), w) : { type: "void", instance: null, count: 0, state: null };
        case "link":
          if (m.rel === "stylesheet" && typeof m.href == "string" && typeof m.precedence == "string") {
            c = uu(m.href);
            var N = na(
              O
            ).hoistableStyles, q = N.get(c);
            if (q || (O = O.ownerDocument || O, q = {
              type: "stylesheet",
              instance: null,
              count: 0,
              state: { loading: 0, preload: null }
            }, N.set(c, q), (N = O.querySelector(
              Pd(c)
            )) && !N._p && (q.instance = N, q.state.loading = 5), xo.has(c) || (m = {
              rel: "preload",
              as: "style",
              href: m.href,
              crossOrigin: m.crossOrigin,
              integrity: m.integrity,
              media: m.media,
              hrefLang: m.hrefLang,
              referrerPolicy: m.referrerPolicy
            }, xo.set(c, m), N || JW(
              O,
              c,
              m,
              q.state
            ))), f && w === null)
              throw Error(r(528, ""));
            return q;
          }
          if (f && w !== null)
            throw Error(r(529, ""));
          return null;
        case "script":
          return f = m.async, m = m.src, typeof m == "string" && f && typeof f != "function" && typeof f != "symbol" ? (f = fu(m), m = na(
            O
          ).hoistableScripts, w = m.get(f), w || (w = {
            type: "script",
            instance: null,
            count: 0,
            state: null
          }, m.set(f, w)), w) : { type: "void", instance: null, count: 0, state: null };
        default:
          throw Error(r(444, c));
      }
    }
    function uu(c) {
      return 'href="' + Mr(c) + '"';
    }
    function Pd(c) {
      return 'link[rel="stylesheet"][' + c + "]";
    }
    function DM(c) {
      return d({}, c, {
        "data-precedence": c.precedence,
        precedence: null
      });
    }
    function JW(c, f, m, w) {
      c.querySelector('link[rel="preload"][as="style"][' + f + "]") ? w.loading = 1 : (f = c.createElement("link"), w.preload = f, f.addEventListener("load", function() {
        return w.loading |= 1;
      }), f.addEventListener("error", function() {
        return w.loading |= 2;
      }), or(f, "link", m), $n(f), c.head.appendChild(f));
    }
    function fu(c) {
      return '[src="' + Mr(c) + '"]';
    }
    function $d(c) {
      return "script[async]" + c;
    }
    function FM(c, f, m) {
      if (f.count++, f.instance === null)
        switch (f.type) {
          case "style":
            var w = c.querySelector(
              'style[data-href~="' + Mr(m.href) + '"]'
            );
            if (w)
              return f.instance = w, $n(w), w;
            var O = d({}, m, {
              "data-href": m.href,
              "data-precedence": m.precedence,
              href: null,
              precedence: null
            });
            return w = (c.ownerDocument || c).createElement(
              "style"
            ), $n(w), or(w, "style", O), Sg(w, m.precedence, c), f.instance = w;
          case "stylesheet":
            O = uu(m.href);
            var N = c.querySelector(
              Pd(O)
            );
            if (N)
              return f.state.loading |= 4, f.instance = N, $n(N), N;
            w = DM(m), (O = xo.get(O)) && Pw(w, O), N = (c.ownerDocument || c).createElement("link"), $n(N);
            var q = N;
            return q._p = new Promise(function(Z, ne) {
              q.onload = Z, q.onerror = ne;
            }), or(N, "link", w), f.state.loading |= 4, Sg(N, m.precedence, c), f.instance = N;
          case "script":
            return N = fu(m.src), (O = c.querySelector(
              $d(N)
            )) ? (f.instance = O, $n(O), O) : (w = m, (O = xo.get(N)) && (w = d({}, m), $w(w, O)), c = c.ownerDocument || c, O = c.createElement("script"), $n(O), or(O, "link", w), c.head.appendChild(O), f.instance = O);
          case "void":
            return null;
          default:
            throw Error(r(443, f.type));
        }
      else
        f.type === "stylesheet" && (f.state.loading & 4) === 0 && (w = f.instance, f.state.loading |= 4, Sg(w, m.precedence, c));
      return f.instance;
    }
    function Sg(c, f, m) {
      for (var w = m.querySelectorAll(
        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
      ), O = w.length ? w[w.length - 1] : null, N = O, q = 0; q < w.length; q++) {
        var Z = w[q];
        if (Z.dataset.precedence === f) N = Z;
        else if (N !== O) break;
      }
      N ? N.parentNode.insertBefore(c, N.nextSibling) : (f = m.nodeType === 9 ? m.head : m, f.insertBefore(c, f.firstChild));
    }
    function Pw(c, f) {
      c.crossOrigin == null && (c.crossOrigin = f.crossOrigin), c.referrerPolicy == null && (c.referrerPolicy = f.referrerPolicy), c.title == null && (c.title = f.title);
    }
    function $w(c, f) {
      c.crossOrigin == null && (c.crossOrigin = f.crossOrigin), c.referrerPolicy == null && (c.referrerPolicy = f.referrerPolicy), c.integrity == null && (c.integrity = f.integrity);
    }
    var _g = null;
    function LM(c, f, m) {
      if (_g === null) {
        var w = /* @__PURE__ */ new Map(), O = _g = /* @__PURE__ */ new Map();
        O.set(m, w);
      } else
        O = _g, w = O.get(m), w || (w = /* @__PURE__ */ new Map(), O.set(m, w));
      if (w.has(c)) return w;
      for (w.set(c, null), m = m.getElementsByTagName(c), O = 0; O < m.length; O++) {
        var N = m[O];
        if (!(N[hl] || N[Yn] || c === "link" && N.getAttribute("rel") === "stylesheet") && N.namespaceURI !== "http://www.w3.org/2000/svg") {
          var q = N.getAttribute(f) || "";
          q = c + q;
          var Z = w.get(q);
          Z ? Z.push(N) : w.set(q, [N]);
        }
      }
      return w;
    }
    function zM(c, f, m) {
      c = c.ownerDocument || c, c.head.insertBefore(
        m,
        f === "title" ? c.querySelector("head > title") : null
      );
    }
    function eG(c, f, m) {
      if (m === 1 || f.itemProp != null) return !1;
      switch (c) {
        case "meta":
        case "title":
          return !0;
        case "style":
          if (typeof f.precedence != "string" || typeof f.href != "string" || f.href === "")
            break;
          return !0;
        case "link":
          if (typeof f.rel != "string" || typeof f.href != "string" || f.href === "" || f.onLoad || f.onError)
            break;
          switch (f.rel) {
            case "stylesheet":
              return c = f.disabled, typeof f.precedence == "string" && c == null;
            default:
              return !0;
          }
        case "script":
          if (f.async && typeof f.async != "function" && typeof f.async != "symbol" && !f.onLoad && !f.onError && f.src && typeof f.src == "string")
            return !0;
      }
      return !1;
    }
    function BM(c) {
      return !(c.type === "stylesheet" && (c.state.loading & 3) === 0);
    }
    var Id = null;
    function tG() {
    }
    function nG(c, f, m) {
      if (Id === null) throw Error(r(475));
      var w = Id;
      if (f.type === "stylesheet" && (typeof m.media != "string" || matchMedia(m.media).matches !== !1) && (f.state.loading & 4) === 0) {
        if (f.instance === null) {
          var O = uu(m.href), N = c.querySelector(
            Pd(O)
          );
          if (N) {
            c = N._p, c !== null && typeof c == "object" && typeof c.then == "function" && (w.count++, w = Eg.bind(w), c.then(w, w)), f.state.loading |= 4, f.instance = N, $n(N);
            return;
          }
          N = c.ownerDocument || c, m = DM(m), (O = xo.get(O)) && Pw(m, O), N = N.createElement("link"), $n(N);
          var q = N;
          q._p = new Promise(function(Z, ne) {
            q.onload = Z, q.onerror = ne;
          }), or(N, "link", m), f.instance = N;
        }
        w.stylesheets === null && (w.stylesheets = /* @__PURE__ */ new Map()), w.stylesheets.set(f, c), (c = f.state.preload) && (f.state.loading & 3) === 0 && (w.count++, f = Eg.bind(w), c.addEventListener("load", f), c.addEventListener("error", f));
      }
    }
    function rG() {
      if (Id === null) throw Error(r(475));
      var c = Id;
      return c.stylesheets && c.count === 0 && Iw(c, c.stylesheets), 0 < c.count ? function(f) {
        var m = setTimeout(function() {
          if (c.stylesheets && Iw(c, c.stylesheets), c.unsuspend) {
            var w = c.unsuspend;
            c.unsuspend = null, w();
          }
        }, 6e4);
        return c.unsuspend = f, function() {
          c.unsuspend = null, clearTimeout(m);
        };
      } : null;
    }
    function Eg() {
      if (this.count--, this.count === 0) {
        if (this.stylesheets) Iw(this, this.stylesheets);
        else if (this.unsuspend) {
          var c = this.unsuspend;
          this.unsuspend = null, c();
        }
      }
    }
    var Cg = null;
    function Iw(c, f) {
      c.stylesheets = null, c.unsuspend !== null && (c.count++, Cg = /* @__PURE__ */ new Map(), f.forEach(oG, c), Cg = null, Eg.call(c));
    }
    function oG(c, f) {
      if (!(f.state.loading & 4)) {
        var m = Cg.get(c);
        if (m) var w = m.get(null);
        else {
          m = /* @__PURE__ */ new Map(), Cg.set(c, m);
          for (var O = c.querySelectorAll(
            "link[data-precedence],style[data-precedence]"
          ), N = 0; N < O.length; N++) {
            var q = O[N];
            (q.nodeName === "LINK" || q.getAttribute("media") !== "not all") && (m.set(q.dataset.precedence, q), w = q);
          }
          w && m.set(null, w);
        }
        O = f.instance, q = O.getAttribute("data-precedence"), N = m.get(q) || w, N === w && m.set(null, O), m.set(q, O), this.count++, w = Eg.bind(this), O.addEventListener("load", w), O.addEventListener("error", w), N ? N.parentNode.insertBefore(O, N.nextSibling) : (c = c.nodeType === 9 ? c.head : c, c.insertBefore(O, c.firstChild)), f.state.loading |= 4;
      }
    }
    var jd = {
      $$typeof: _,
      Provider: null,
      Consumer: null,
      _currentValue: W,
      _currentValue2: W,
      _threadCount: 0
    };
    function iG(c, f, m, w, O, N, q, Z) {
      this.tag = 1, this.containerInfo = c, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = pl(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = pl(0), this.hiddenUpdates = pl(null), this.identifierPrefix = w, this.onUncaughtError = O, this.onCaughtError = N, this.onRecoverableError = q, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = Z, this.incompleteTransitions = /* @__PURE__ */ new Map();
    }
    function UM(c, f, m, w, O, N, q, Z, ne, pe, be, we) {
      return c = new iG(
        c,
        f,
        m,
        q,
        Z,
        ne,
        pe,
        we
      ), f = 1, N === !0 && (f |= 24), N = Wr(3, null, null, f), c.current = N, N.stateNode = c, f = gx(), f.refCount++, c.pooledCache = f, f.refCount++, N.memoizedState = {
        element: w,
        isDehydrated: m,
        cache: f
      }, xx(N), c;
    }
    function VM(c) {
      return c ? (c = Uc, c) : Uc;
    }
    function HM(c, f, m, w, O, N) {
      O = VM(O), w.context === null ? w.context = O : w.pendingContext = O, w = fs(f), w.payload = { element: m }, N = N === void 0 ? null : N, N !== null && (w.callback = N), m = ds(c, w, f), m !== null && (Zr(m, c, f), dd(m, c, f));
    }
    function qM(c, f) {
      if (c = c.memoizedState, c !== null && c.dehydrated !== null) {
        var m = c.retryLane;
        c.retryLane = m !== 0 && m < f ? m : f;
      }
    }
    function jw(c, f) {
      qM(c, f), (c = c.alternate) && qM(c, f);
    }
    function WM(c) {
      if (c.tag === 13) {
        var f = Bc(c, 67108864);
        f !== null && Zr(f, c, 67108864), jw(c, 67108864);
      }
    }
    var kg = !0;
    function aG(c, f, m, w) {
      var O = F.T;
      F.T = null;
      var N = G.p;
      try {
        G.p = 2, Dw(c, f, m, w);
      } finally {
        G.p = N, F.T = O;
      }
    }
    function sG(c, f, m, w) {
      var O = F.T;
      F.T = null;
      var N = G.p;
      try {
        G.p = 8, Dw(c, f, m, w);
      } finally {
        G.p = N, F.T = O;
      }
    }
    function Dw(c, f, m, w) {
      if (kg) {
        var O = Fw(w);
        if (O === null)
          Ew(
            c,
            f,
            w,
            Tg,
            m
          ), KM(c, w);
        else if (cG(
          O,
          c,
          f,
          m,
          w
        ))
          w.stopPropagation();
        else if (KM(c, w), f & 4 && -1 < lG.indexOf(c)) {
          for (; O !== null; ) {
            var N = ta(O);
            if (N !== null)
              switch (N.tag) {
                case 3:
                  if (N = N.stateNode, N.current.memoizedState.isDehydrated) {
                    var q = Ie(N.pendingLanes);
                    if (q !== 0) {
                      var Z = N;
                      for (Z.pendingLanes |= 2, Z.entangledLanes |= 2; q; ) {
                        var ne = 1 << 31 - _e(q);
                        Z.entanglements[1] |= ne, q &= ~ne;
                      }
                      fi(N), (qt & 6) === 0 && (ug = Ne() + 500, Od(0));
                    }
                  }
                  break;
                case 13:
                  Z = Bc(N, 2), Z !== null && Zr(Z, N, 2), dg(), jw(N, 2);
              }
            if (N = Fw(w), N === null && Ew(
              c,
              f,
              w,
              Tg,
              m
            ), N === O) break;
            O = N;
          }
          O !== null && w.stopPropagation();
        } else
          Ew(
            c,
            f,
            w,
            null,
            m
          );
      }
    }
    function Fw(c) {
      return c = V1(c), Lw(c);
    }
    var Tg = null;
    function Lw(c) {
      if (Tg = null, c = is(c), c !== null) {
        var f = i(c);
        if (f === null) c = null;
        else {
          var m = f.tag;
          if (m === 13) {
            if (c = a(f), c !== null) return c;
            c = null;
          } else if (m === 3) {
            if (f.stateNode.current.memoizedState.isDehydrated)
              return f.tag === 3 ? f.stateNode.containerInfo : null;
            c = null;
          } else f !== c && (c = null);
        }
      }
      return Tg = c, null;
    }
    function GM(c) {
      switch (c) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 2;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 8;
        case "message":
          switch (Le()) {
            case Ve:
              return 2;
            case Ke:
              return 8;
            case ze:
            case Me:
              return 32;
            case ct:
              return 268435456;
            default:
              return 32;
          }
        default:
          return 32;
      }
    }
    var zw = !1, Cs = null, ks = null, Ts = null, Dd = /* @__PURE__ */ new Map(), Fd = /* @__PURE__ */ new Map(), Rs = [], lG = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
      " "
    );
    function KM(c, f) {
      switch (c) {
        case "focusin":
        case "focusout":
          Cs = null;
          break;
        case "dragenter":
        case "dragleave":
          ks = null;
          break;
        case "mouseover":
        case "mouseout":
          Ts = null;
          break;
        case "pointerover":
        case "pointerout":
          Dd.delete(f.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Fd.delete(f.pointerId);
      }
    }
    function Ld(c, f, m, w, O, N) {
      return c === null || c.nativeEvent !== N ? (c = {
        blockedOn: f,
        domEventName: m,
        eventSystemFlags: w,
        nativeEvent: N,
        targetContainers: [O]
      }, f !== null && (f = ta(f), f !== null && WM(f)), c) : (c.eventSystemFlags |= w, f = c.targetContainers, O !== null && f.indexOf(O) === -1 && f.push(O), c);
    }
    function cG(c, f, m, w, O) {
      switch (f) {
        case "focusin":
          return Cs = Ld(
            Cs,
            c,
            f,
            m,
            w,
            O
          ), !0;
        case "dragenter":
          return ks = Ld(
            ks,
            c,
            f,
            m,
            w,
            O
          ), !0;
        case "mouseover":
          return Ts = Ld(
            Ts,
            c,
            f,
            m,
            w,
            O
          ), !0;
        case "pointerover":
          var N = O.pointerId;
          return Dd.set(
            N,
            Ld(
              Dd.get(N) || null,
              c,
              f,
              m,
              w,
              O
            )
          ), !0;
        case "gotpointercapture":
          return N = O.pointerId, Fd.set(
            N,
            Ld(
              Fd.get(N) || null,
              c,
              f,
              m,
              w,
              O
            )
          ), !0;
      }
      return !1;
    }
    function YM(c) {
      var f = is(c.target);
      if (f !== null) {
        var m = i(f);
        if (m !== null) {
          if (f = m.tag, f === 13) {
            if (f = a(m), f !== null) {
              c.blockedOn = f, P1(c.priority, function() {
                if (m.tag === 13) {
                  var w = Xr();
                  w = _r(w);
                  var O = Bc(m, w);
                  O !== null && Zr(O, m, w), jw(m, w);
                }
              });
              return;
            }
          } else if (f === 3 && m.stateNode.current.memoizedState.isDehydrated) {
            c.blockedOn = m.tag === 3 ? m.stateNode.containerInfo : null;
            return;
          }
        }
      }
      c.blockedOn = null;
    }
    function Rg(c) {
      if (c.blockedOn !== null) return !1;
      for (var f = c.targetContainers; 0 < f.length; ) {
        var m = Fw(c.nativeEvent);
        if (m === null) {
          m = c.nativeEvent;
          var w = new m.constructor(
            m.type,
            m
          );
          U1 = w, m.target.dispatchEvent(w), U1 = null;
        } else
          return f = ta(m), f !== null && WM(f), c.blockedOn = m, !1;
        f.shift();
      }
      return !0;
    }
    function XM(c, f, m) {
      Rg(c) && m.delete(f);
    }
    function uG() {
      zw = !1, Cs !== null && Rg(Cs) && (Cs = null), ks !== null && Rg(ks) && (ks = null), Ts !== null && Rg(Ts) && (Ts = null), Dd.forEach(XM), Fd.forEach(XM);
    }
    function Og(c, f) {
      c.blockedOn === f && (c.blockedOn = null, zw || (zw = !0, e.unstable_scheduleCallback(
        e.unstable_NormalPriority,
        uG
      )));
    }
    var Ag = null;
    function ZM(c) {
      Ag !== c && (Ag = c, e.unstable_scheduleCallback(
        e.unstable_NormalPriority,
        function() {
          Ag === c && (Ag = null);
          for (var f = 0; f < c.length; f += 3) {
            var m = c[f], w = c[f + 1], O = c[f + 2];
            if (typeof w != "function") {
              if (Lw(w || m) === null)
                continue;
              break;
            }
            var N = ta(m);
            N !== null && (c.splice(f, 3), f -= 3, Lx(
              N,
              {
                pending: !0,
                data: O,
                method: m.method,
                action: w
              },
              w,
              O
            ));
          }
        }
      ));
    }
    function zd(c) {
      function f(ne) {
        return Og(ne, c);
      }
      Cs !== null && Og(Cs, c), ks !== null && Og(ks, c), Ts !== null && Og(Ts, c), Dd.forEach(f), Fd.forEach(f);
      for (var m = 0; m < Rs.length; m++) {
        var w = Rs[m];
        w.blockedOn === c && (w.blockedOn = null);
      }
      for (; 0 < Rs.length && (m = Rs[0], m.blockedOn === null); )
        YM(m), m.blockedOn === null && Rs.shift();
      if (m = (c.ownerDocument || c).$$reactFormReplay, m != null)
        for (w = 0; w < m.length; w += 3) {
          var O = m[w], N = m[w + 1], q = O[ur] || null;
          if (typeof N == "function")
            q || ZM(m);
          else if (q) {
            var Z = null;
            if (N && N.hasAttribute("formAction")) {
              if (O = N, q = N[ur] || null)
                Z = q.formAction;
              else if (Lw(O) !== null) continue;
            } else Z = q.action;
            typeof Z == "function" ? m[w + 1] = Z : (m.splice(w, 3), w -= 3), ZM(m);
          }
        }
    }
    function Bw(c) {
      this._internalRoot = c;
    }
    Ng.prototype.render = Bw.prototype.render = function(c) {
      var f = this._internalRoot;
      if (f === null) throw Error(r(409));
      var m = f.current, w = Xr();
      HM(m, w, c, f, null, null);
    }, Ng.prototype.unmount = Bw.prototype.unmount = function() {
      var c = this._internalRoot;
      if (c !== null) {
        this._internalRoot = null;
        var f = c.containerInfo;
        HM(c.current, 2, null, c, null, null), dg(), f[os] = null;
      }
    };
    function Ng(c) {
      this._internalRoot = c;
    }
    Ng.prototype.unstable_scheduleHydration = function(c) {
      if (c) {
        var f = vm();
        c = { blockedOn: null, target: c, priority: f };
        for (var m = 0; m < Rs.length && f !== 0 && f < Rs[m].priority; m++) ;
        Rs.splice(m, 0, c), m === 0 && YM(c);
      }
    };
    var QM = t.version;
    if (QM !== "19.1.0")
      throw Error(
        r(
          527,
          QM,
          "19.1.0"
        )
      );
    G.findDOMNode = function(c) {
      var f = c._reactInternals;
      if (f === void 0)
        throw typeof c.render == "function" ? Error(r(188)) : (c = Object.keys(c).join(","), Error(r(268, c)));
      return c = l(f), c = c !== null ? u(c) : null, c = c === null ? null : c.stateNode, c;
    };
    var fG = {
      bundleType: 0,
      version: "19.1.0",
      rendererPackageName: "react-dom",
      currentDispatcherRef: F,
      reconcilerVersion: "19.1.0"
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
      var Mg = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!Mg.isDisabled && Mg.supportsFiber)
        try {
          oe = Mg.inject(
            fG
          ), ue = Mg;
        } catch {
        }
    }
    return Ud.createRoot = function(c, f) {
      if (!o(c)) throw Error(r(299));
      var m = !1, w = "", O = hN, N = mN, q = gN, Z = null;
      return f != null && (f.unstable_strictMode === !0 && (m = !0), f.identifierPrefix !== void 0 && (w = f.identifierPrefix), f.onUncaughtError !== void 0 && (O = f.onUncaughtError), f.onCaughtError !== void 0 && (N = f.onCaughtError), f.onRecoverableError !== void 0 && (q = f.onRecoverableError), f.unstable_transitionCallbacks !== void 0 && (Z = f.unstable_transitionCallbacks)), f = UM(
        c,
        1,
        !1,
        null,
        null,
        m,
        w,
        O,
        N,
        q,
        Z,
        null
      ), c[os] = f.current, _w(c), new Bw(f);
    }, Ud.hydrateRoot = function(c, f, m) {
      if (!o(c)) throw Error(r(299));
      var w = !1, O = "", N = hN, q = mN, Z = gN, ne = null, pe = null;
      return m != null && (m.unstable_strictMode === !0 && (w = !0), m.identifierPrefix !== void 0 && (O = m.identifierPrefix), m.onUncaughtError !== void 0 && (N = m.onUncaughtError), m.onCaughtError !== void 0 && (q = m.onCaughtError), m.onRecoverableError !== void 0 && (Z = m.onRecoverableError), m.unstable_transitionCallbacks !== void 0 && (ne = m.unstable_transitionCallbacks), m.formState !== void 0 && (pe = m.formState)), f = UM(
        c,
        1,
        !0,
        f,
        m ?? null,
        w,
        O,
        N,
        q,
        Z,
        ne,
        pe
      ), f.context = VM(null), m = f.current, w = Xr(), w = _r(w), O = fs(w), O.callback = null, ds(m, O, w), m = w, f.current.lanes = m, Zt(f, m), fi(f), c[os] = f.current, _w(c), new Ng(f);
    }, Ud.version = "19.1.0", Ud;
  }
  var lP;
  function CG() {
    if (lP) return Vw.exports;
    lP = 1;
    function e() {
      if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
        } catch (t) {
          console.error(t);
        }
    }
    return e(), Vw.exports = EG(), Vw.exports;
  }
  var kG = CG(), T = kh();
  const Tn = /* @__PURE__ */ Jo(T), ec = /* @__PURE__ */ gG({
    __proto__: null,
    default: Tn
  }, [T]), Gn = {
    /** Debug level - most verbose, for development debugging */
    DEBUG: 0,
    /** Info level - general information about application flow */
    INFO: 10,
    /** Warning level - concerning but non-critical issues */
    WARN: 20,
    /** Error level - critical problems requiring attention */
    ERROR: 30
  }, TG = Gn.DEBUG, _4 = Gn.INFO, RG = Gn.WARN, OG = Gn.ERROR, cP = (e) => typeof e == "string" ? e : e === Gn.DEBUG ? "DEBUG" : e === Gn.INFO ? "INFO" : e === Gn.WARN ? "WARN" : e === Gn.ERROR ? "ERROR" : "UNKNOWN";
  function AG() {
    const e = [];
    return function(t, n) {
      if (typeof n != "object" || n === null)
        return n;
      for (; e.length > 0 && e.at(-1) !== this; )
        e.pop();
      return e.includes(n) ? "[Circular]" : (e.push(n), n);
    };
  }
  const uP = (e) => {
    if (typeof e == "number") return e;
    const t = e.toLowerCase();
    if (t === "debug") return Gn.DEBUG;
    if (t === "info") return Gn.INFO;
    if (t === "warn" || t === "warning") return Gn.WARN;
    if (t === "error") return Gn.ERROR;
    throw new Error(`Unknown log level: ${e}`);
  };
  class ZC {
    /**
     * Create a new BaseLogger instance.
     *
     * @param {string} name - The name/identifier for this logger
     * @param {number | string} [level=LEVELS.INFO] - Initial log level
     * @param {boolean} [with_timestamp=true] - Whether to include timestamps
     * @example
     * ```typescript
     * const logger = new MyLogger("DatabaseService", "DEBUG", true);
     * ```
     */
    constructor(t, n = Gn.INFO, r = !0) {
      this.name = t, this.level = uP(n), this._level_name = cP(this.level), this.with_timestamp = r;
    }
    /**
     * Set the logging level for this logger instance.
     *
     * @param {number | string} level - The new log level (numeric or string)
     * @example
     * ```typescript
     * logger.set_level(DEBUG); // Enable debug logging
     * logger.set_level("debug"); // Same as above using string
     * ```
     */
    set_level(t) {
      typeof t == "string" && (t = uP(t)), this.level = t, this._level_name = cP(this.level);
    }
    /**
     * Get the string representation of the current log level.
     *
     * @returns {string} The current log level as a string
     * @example
     * ```typescript
     * logger.level_name // "INFO"
     * ```
     */
    get level_name() {
      return this._level_name;
    }
    /**
     * Format a log message with level, timestamp, and arguments.
     *
     * @param {string} levelstring - The log level string (DEBUG, INFO, etc.)
     * @param {string} message - The primary log message
     * @param {...any[]} args - Additional arguments to include
     * @returns {string} The formatted log message
     * @example
     * ```typescript
     * // Returns: "12/25/2023, 10:30:15 AM [MyApp] INFO: User logged in {userId: 123}"
     * logger.format_message("INFO", "User logged in", {userId: 123});
     * ```
     */
    format_message(t, n, ...r) {
      return `${this.with_timestamp ? (/* @__PURE__ */ new Date()).toLocaleString() : ""} [${this.name}] ${t}: ${n} ${r.map((i) => JSON.stringify(i, AG())).join(" ")}`.trim();
    }
    /**
     * Log a debug message if the current level allows it.
     *
     * @param {string} message - The primary log message
     * @param {...any[]} args - Additional context arguments
     */
    debug(t, ...n) {
      this.level <= Gn.DEBUG && this.out_debug(this.format_message("DEBUG", t, ...n));
    }
    /**
     * Log an info message if the current level allows it.
     *
     * @param {string} message - The primary log message
     * @param {...any[]} args - Additional context arguments
     */
    info(t, ...n) {
      this.level <= Gn.INFO && this.out_info(this.format_message("INFO", t, ...n));
    }
    /**
     * Log a warning message if the current level allows it.
     *
     * @param {string} message - The primary log message
     * @param {...any[]} args - Additional context arguments
     */
    warn(t, ...n) {
      this.level <= Gn.WARN && this.out_warn(this.format_message("WARN", t, ...n));
    }
    /**
     * Log an error message if the current level allows it.
     *
     * @param {string} message - The primary log message
     * @param {Error} [error] - Optional Error object for stack trace handling
     */
    error(t, n) {
      this.level <= Gn.ERROR && this.out_error(this.format_message("ERROR", t), n);
    }
  }
  class QC extends ZC {
    /**
     * Create a new ConsoleLogger instance.
     *
     * @param {string} name - The name/identifier for this logger
     * @param {number | string} [level=LEVELS.INFO] - Initial log level
     * @example
     * ```typescript
     * const logger = new ConsoleLogger("API", "WARN");
     * ```
     */
    constructor(t, n = Gn.INFO) {
      super(t, n);
    }
    /**
     * Output debug message to console.debug.
     *
     * @protected
     * @param {string} formatted_message - The formatted message to output
     */
    out_debug(t) {
      console.debug(t);
    }
    /**
     * Output info message to console.info.
     *
     * @protected
     * @param {string} formatted_message - The formatted message to output
     */
    out_info(t) {
      console.info(t);
    }
    /**
     * Output warning message to console.warn.
     *
     * @protected
     * @param {string} formatted_message - The formatted message to output
     */
    out_warn(t) {
      console.warn(t);
    }
    /**
     * Output error message to console.error.
     *
     * @protected
     * @param {string} formatted_message - The formatted message to output
     * @param {Error | undefined} error - Optional Error object for stack trace handling
     */
    out_error(t, n) {
      console.error(t), n && console.error(n);
    }
  }
  function Kw(e) {
    return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }
  class NG extends ZC {
    /**
     * Create a new DivLogger instance.
     *
     * @param {HTMLDivElement} div - The HTML div element to append log messages to
     * @param {string} name - The name/identifier for this logger
     * @param {number | string} [level=LEVELS.INFO] - Initial log level
     * @example
     * ```typescript
     * const logContainer = document.createElement('div');
     * const logger = new DivLogger(logContainer, "WebWorker", "DEBUG");
     * ```
     */
    constructor(t, n, r = Gn.INFO) {
      super(n, r), this._div = t;
    }
    /**
     * Format a log message with HTML escaping for safe DOM insertion.
     *
     * Overrides the base implementation to automatically escape HTML content,
     * preventing XSS vulnerabilities when displaying logs in web interfaces.
     *
     * @param {string} levelstring - The log level string (DEBUG, INFO, etc.)
     * @param {string} message - The primary log message
     * @param {...any[]} args - Additional arguments to include
     * @returns {string} The formatted and HTML-escaped log message
     * @example
     * ```typescript
     * // Input: "User input: <script>alert('xss')<\/script>"
     * // Output: "12/25/2023, 10:30:15 AM [UI] INFO: User input: &lt;script&gt;alert('xss')&lt;/script&gt;"
     * ```
     */
    format_message(t, n, ...r) {
      return Kw(super.format_message(t, n, ...r));
    }
    /**
     * Output debug message as HTML div with 'debug' class.
     *
     * @protected
     * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
     */
    out_debug(t) {
      this._div.innerHTML += `<div class="debug">${t}</div>`;
    }
    /**
     * Output info message as HTML div with 'info' class.
     *
     * @protected
     * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
     */
    out_info(t) {
      this._div.innerHTML += `<div class="info">${t}</div>`;
    }
    /**
     * Output warning message as HTML div with 'warn' class.
     *
     * @protected
     * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
     */
    out_warn(t) {
      this._div.innerHTML += `<div class="warn">${t}</div>`;
    }
    /**
     * Output error message as HTML div with 'error' class.
     *
     * @protected
     * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
     * @param {Error | undefined} error - Optional Error object for stack trace handling
     */
    out_error(t, n) {
      let r = t;
      if (n) {
        const o = n.stack ? Kw(n.stack) : Kw(n.message);
        r += `<br><pre>${o}</pre>`;
      }
      this._div.innerHTML += `<div class="error">${r}</div>`;
    }
  }
  function MG(e) {
    const t = window.atob(e), n = t.length, r = new Uint8Array(n);
    for (let o = 0; o < n; o++)
      r[o] = t.charCodeAt(o);
    return r;
  }
  function PG(e, t) {
    return new Blob([e], { type: t });
  }
  function $G(e, t) {
    return PG(MG(e), t);
  }
  function IG(e, t, n) {
    const r = $G(e, n), o = URL.createObjectURL(r), i = document.createElement("a");
    i.href = o, i.download = t, i.click(), URL.revokeObjectURL(o), i.remove();
  }
  function jG(e, t = !0) {
    return new Promise((n, r) => {
      const o = new FileReader();
      o.onload = () => {
        const i = o.result;
        n(t ? i.split(",")[1] : i);
      }, o.onerror = () => r(o.error), o.readAsDataURL(e);
    });
  }
  function DG(e) {
    return new Promise((t, n) => {
      const r = document.createElement("input");
      r.type = "file", r.accept = e, r.onchange = () => {
        const o = r.files?.[0];
        o ? t(o) : n(new Error("No file selected"));
      }, r.oncancel = () => {
        n(new Error("File selection cancelled"));
      }, r.click();
    });
  }
  function FG(e) {
    return DG(e).then(jG);
  }
  async function LG(e, t = !0) {
    try {
      const n = await fetch(e);
      if (!n.ok)
        throw new Error(
          `Failed to fetch from URL: ${n.status} ${n.statusText}`
        );
      const r = await n.blob();
      return await new Promise((i, a) => {
        const s = new FileReader();
        s.onload = () => {
          const l = s.result;
          typeof l != "string" && (a("Failed to convert URL to Base64: No result from FileReader"), a(s.error)), i(t ? l.split(",")[1] : l);
        }, s.onerror = () => a(s.error), s.readAsDataURL(r);
      });
    } catch (n) {
      throw console.error("Error converting URL to Base64:", n), n;
    }
  }
  function Bs(e) {
    if (Object.prototype.toString.call(e) !== "[object Object]")
      return !1;
    const t = Object.getPrototypeOf(e);
    return t === null || t === Object.prototype;
  }
  function JC(e, t, n = /* @__PURE__ */ new WeakMap()) {
    if (e === t) return !0;
    if (typeof e != "object" || e === null || typeof t != "object" || t === null)
      return !1;
    if (n.has(e))
      return n.get(e) === t;
    if (n.set(e, t), e.constructor !== t.constructor) return !1;
    if (e.constructor === Object || e.constructor === Array) {
      const r = Object.keys(e), o = Object.keys(t);
      if (r.length !== o.length) return !1;
      for (const i of r)
        if (!o.includes(i) || !JC(e[i], t[i], n)) return !1;
    }
    return e instanceof Date && t instanceof Date ? e.getTime() === t.getTime() : !0;
  }
  const tc = (e, t) => {
    let n = !1;
    if (!Bs(e))
      throw new Error("Target must be a plain object not" + typeof e);
    if (!Bs(t))
      throw new Error("Source must be a plain object not" + typeof t);
    const r = { ...e };
    return Object.keys(t).forEach((o) => {
      const i = t[o], a = e[o];
      if (Bs(i) && Bs(a)) {
        const { new_obj: s, change: l } = tc(
          a,
          i
        );
        l && (n = !0, r[o] = s);
      } else JC(a, i) || (n = !0, r[o] = i);
    }), { new_obj: r, change: n };
  }, E4 = (e, t) => {
    let n = !1;
    if (!Bs(e))
      throw new Error("Target must be a plain object");
    if (!Bs(t))
      throw new Error("Source must be a plain object");
    const r = { ...e };
    return Object.keys(t).forEach((o) => {
      const i = t[o], a = e[o];
      if (!(a === void 0 && i === void 0)) {
        if (a === void 0) {
          n = !0, r[o] = i;
          return;
        }
        if (Bs(i) && Bs(a)) {
          const { new_obj: s, change: l } = E4(
            a,
            i
          );
          l && (n = !0, r[o] = s);
        }
      }
    }), { new_obj: r, change: n };
  }, ek = (e, t = void 0) => {
    const n = JSON.stringify(e);
    return (r) => {
      let o = JSON.parse(n);
      return t !== void 0 && (o = t(o)), r === void 0 ? o : E4(r, o).new_obj;
    };
  }, So = (e, t) => t === void 0 ? [e, !1] : [t, e !== t];
  function C4(e, t) {
    throw new Error("Unhandled case: " + e + " with: " + JSON.stringify(t));
  }
  const ju = (e, t) => {
    if (t === void 0) return [e, !1];
    if (e === void 0) return [t, t !== void 0];
    const { new_obj: n, change: r } = tc(e, t);
    return [n, r];
  }, zG = ({ error: e }) => /* @__PURE__ */ S.jsxs("div", { className: "error-div", children: [
    /* @__PURE__ */ S.jsx("h1", { children: "Error" }),
    /* @__PURE__ */ S.jsx("p", { children: e.message })
  ] });
  var gc = S4();
  const up = /* @__PURE__ */ Jo(gc), z0 = T.createContext(
    void 0
  ), Us = T.forwardRef((e, t) => {
    const {
      asChild: n = !1,
      children: r,
      className: o,
      style: i,
      htime: a = 300,
      vtime: s = 300,
      hdelay: l = 0,
      vdelay: u = 200,
      zIndex: d = 9999,
      ...p
    } = e, [h, g] = T.useState(!1), [y, b] = T.useState({}), v = T.useRef(null), x = T.useRef(null);
    T.useImperativeHandle(t, () => v.current, []);
    const E = T.useMemo(
      () => ({
        horizontal: a,
        vertical: s,
        horizontalDelay: l,
        verticalDelay: u
      }),
      [a, s, l, u]
    ), _ = T.useCallback(
      () => Math.max(
        E.horizontal + E.horizontalDelay,
        E.vertical + E.verticalDelay
      ),
      [E]
    ), C = T.useCallback(async () => {
      if (v.current)
        try {
          const L = v.current.getBoundingClientRect();
          x.current = L, b({
            position: "fixed",
            top: `${L.top}px`,
            left: `${L.left}px`,
            width: `${L.width}px`,
            height: `${L.height}px`,
            zIndex: d,
            transition: "none"
          }), g(!0), v.current.offsetHeight, b((P) => ({
            ...P,
            transition: [
              `width ${E.horizontal}ms ease-in-out ${E.horizontalDelay}ms`,
              `left ${E.horizontal}ms ease-in-out ${E.horizontalDelay}ms`,
              `height ${E.vertical}ms ease-in-out ${E.verticalDelay}ms`,
              `top ${E.vertical}ms ease-in-out ${E.verticalDelay}ms`
            ].join(", ")
          })), requestAnimationFrame(() => {
            b((P) => ({
              ...P,
              top: "0",
              left: "0",
              width: "100vw",
              height: "100vh"
            }));
          }), await new Promise((P) => setTimeout(P, _()));
        } catch (L) {
          console.warn("Error during expand animation:", L), g(!0);
        }
    }, [E, d, _]), k = T.useCallback(async () => {
      if (!v.current || !x.current) return;
      const L = x.current;
      b((P) => ({
        ...P,
        transition: [
          `width ${E.horizontal}ms ease-in-out ${E.verticalDelay}ms`,
          `left ${E.horizontal}ms ease-in-out ${E.verticalDelay}ms`,
          `height ${E.vertical}ms ease-in-out ${E.horizontalDelay}ms`,
          `top ${E.vertical}ms ease-in-out ${E.horizontalDelay}ms`
        ].join(", ")
      })), requestAnimationFrame(() => {
        b((P) => ({
          ...P,
          top: `${L.top}px`,
          left: `${L.left}px`,
          width: `${L.width}px`,
          height: `${L.height}px`
        }));
      }), await new Promise((P) => setTimeout(P, _())), b({}), g(!1), x.current = null;
    }, [E, _]), R = T.useCallback(async () => {
      h ? await k() : await C();
    }, [h, C, k]), A = T.useMemo(
      () => ({ isExpanded: h, toggleExpand: R }),
      [h, R]
    ), M = T.useMemo(
      () => ({ ...i, ...y }),
      [i, y]
    );
    let I;
    if (n && T.isValidElement(r)) {
      const L = r;
      I = T.cloneElement(L, {
        ref: v,
        className: [L.props.className, o].filter(Boolean).join(" "),
        style: { ...L.props.style, ...M },
        ...p
      });
    } else
      I = /* @__PURE__ */ S.jsx("div", { ref: v, className: o, style: M, ...p, children: r });
    const D = /* @__PURE__ */ S.jsx(z0.Provider, { value: A, children: I });
    return h ? gc.createPortal(D, document.body) : D;
  });
  Us.displayName = "SmoothExpand";
  Us.Trigger = function({
    children: t,
    className: n
  }) {
    const r = T.useContext(z0);
    if (!r)
      throw new Error(
        "SmoothExpand.Trigger must be used within a SmoothExpand component"
      );
    return /* @__PURE__ */ S.jsx(
      "div",
      {
        className: n,
        style: { cursor: "pointer" },
        onClick: r.toggleExpand,
        role: "button",
        tabIndex: 0,
        onKeyDown: (o) => {
          (o.key === "Enter" || o.key === " ") && (o.preventDefault(), r.toggleExpand());
        },
        children: t
      }
    );
  };
  Us.Expanded = function({
    children: t
  }) {
    const n = T.useContext(z0);
    if (!n)
      throw new Error(
        "SmoothExpand.Expanded must be used within a SmoothExpand component"
      );
    return n.isExpanded ? /* @__PURE__ */ S.jsx(S.Fragment, { children: t }) : null;
  };
  Us.Collapsed = function({
    children: t
  }) {
    const n = T.useContext(z0);
    if (!n)
      throw new Error(
        "SmoothExpand.Collapsed must be used within a SmoothExpand component"
      );
    return n.isExpanded ? null : /* @__PURE__ */ S.jsx(S.Fragment, { children: t });
  };
  const B0 = T.createContext(
    void 0
  ), Ra = T.forwardRef((e, t) => {
    const { asChild: n = !1, children: r, className: o, style: i, ...a } = e, [s, l] = T.useState(!1), u = T.useRef(null);
    T.useImperativeHandle(t, () => u.current, []);
    const d = T.useCallback(async (v) => {
      const x = v;
      if (v.requestFullscreen)
        await v.requestFullscreen();
      else if (x.mozRequestFullScreen)
        await x.mozRequestFullScreen();
      else if (x.webkitRequestFullscreen)
        await x.webkitRequestFullscreen();
      else if (x.msRequestFullscreen)
        await x.msRequestFullscreen();
      else
        throw new Error("Fullscreen API is not supported in this browser");
    }, []), p = T.useCallback(async () => {
      const v = document;
      if (document.exitFullscreen)
        await document.exitFullscreen();
      else if (v.mozCancelFullScreen)
        await v.mozCancelFullScreen();
      else if (v.webkitExitFullscreen)
        await v.webkitExitFullscreen();
      else if (v.msExitFullscreen)
        await v.msExitFullscreen();
      else
        throw new Error("Exit fullscreen API is not supported in this browser");
    }, []), h = T.useCallback(async () => {
      try {
        const v = u.current;
        if (!v) {
          console.warn("FullScreen: No element reference available");
          return;
        }
        s ? await p() : await d(v);
      } catch (v) {
        console.error("FullScreen: Error toggling fullscreen mode", v);
      }
    }, [s, d, p]), g = T.useCallback(() => {
      const v = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
      l(v);
    }, []);
    T.useEffect(() => {
      const v = [
        "fullscreenchange",
        "webkitfullscreenchange",
        "mozfullscreenchange",
        "MSFullscreenChange"
      ];
      return v.forEach((x) => {
        document.addEventListener(x, g);
      }), () => {
        v.forEach((x) => {
          document.removeEventListener(x, g);
        });
      };
    }, [g]);
    const y = T.useMemo(
      () => ({ isFullScreen: s, toggleFullscreen: h }),
      [s, h]
    );
    let b;
    if (n && T.isValidElement(r)) {
      const v = r;
      b = T.cloneElement(v, {
        ref: u,
        className: [v.props.className, o].filter(Boolean).join(" "),
        style: { ...v.props.style, ...i },
        ...a
      });
    } else
      b = /* @__PURE__ */ S.jsx("div", { ref: u, className: o, style: i, ...a, children: r });
    return /* @__PURE__ */ S.jsx(B0.Provider, { value: y, children: b });
  });
  Ra.displayName = "FullScreen";
  Ra.Trigger = function({
    children: t,
    className: n
  }) {
    const r = T.useContext(B0);
    if (!r)
      throw new Error(
        "FullScreen.Trigger must be used within a FullScreen component"
      );
    return /* @__PURE__ */ S.jsx(
      "div",
      {
        className: n,
        style: { cursor: "pointer" },
        onClick: r.toggleFullscreen,
        role: "button",
        tabIndex: 0,
        onKeyDown: (o) => {
          (o.key === "Enter" || o.key === " ") && (o.preventDefault(), r.toggleFullscreen());
        },
        children: t
      }
    );
  };
  Ra.InFullScreen = function({
    children: t
  }) {
    const n = T.useContext(B0);
    if (!n)
      throw new Error(
        "FullScreen.InFullScreen must be used within a FullScreen component"
      );
    return n.isFullScreen ? /* @__PURE__ */ S.jsx(S.Fragment, { children: t }) : null;
  };
  Ra.OutFullScreen = function({
    children: t
  }) {
    const n = T.useContext(B0);
    if (!n)
      throw new Error(
        "FullScreen.OutFullScreen must be used within a FullScreen component"
      );
    return n.isFullScreen ? null : /* @__PURE__ */ S.jsx(S.Fragment, { children: t });
  };
  var Yw = { exports: {} }, Xw, fP;
  function BG() {
    if (fP) return Xw;
    fP = 1;
    var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    return Xw = e, Xw;
  }
  var Zw, dP;
  function UG() {
    if (dP) return Zw;
    dP = 1;
    var e = /* @__PURE__ */ BG();
    function t() {
    }
    function n() {
    }
    return n.resetWarningCache = t, Zw = function() {
      function r(a, s, l, u, d, p) {
        if (p !== e) {
          var h = new Error(
            "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
          );
          throw h.name = "Invariant Violation", h;
        }
      }
      r.isRequired = r;
      function o() {
        return r;
      }
      var i = {
        array: r,
        bigint: r,
        bool: r,
        func: r,
        number: r,
        object: r,
        string: r,
        symbol: r,
        any: r,
        arrayOf: o,
        element: r,
        elementType: r,
        instanceOf: o,
        node: r,
        objectOf: o,
        oneOf: o,
        oneOfType: o,
        shape: o,
        exact: o,
        checkPropTypes: n,
        resetWarningCache: t
      };
      return i.PropTypes = i, i;
    }, Zw;
  }
  var pP;
  function VG() {
    return pP || (pP = 1, Yw.exports = /* @__PURE__ */ UG()()), Yw.exports;
  }
  var Fn = /* @__PURE__ */ VG();
  const ht = /* @__PURE__ */ Jo(Fn);
  function k4(e) {
    var t, n, r = "";
    if (typeof e == "string" || typeof e == "number") r += e;
    else if (typeof e == "object") if (Array.isArray(e)) {
      var o = e.length;
      for (t = 0; t < o; t++) e[t] && (n = k4(e[t])) && (r && (r += " "), r += n);
    } else for (n in e) e[n] && (r && (r += " "), r += n);
    return r;
  }
  function je() {
    for (var e, t, n = 0, r = "", o = arguments.length; n < o; n++) (e = arguments[n]) && (t = k4(e)) && (r && (r += " "), r += t);
    return r;
  }
  function ot(e, t, n = void 0) {
    const r = {};
    for (const o in e) {
      const i = e[o];
      let a = "", s = !0;
      for (let l = 0; l < i.length; l += 1) {
        const u = i[l];
        u && (a += (s === !0 ? "" : " ") + t(u), s = !1, n && n[u] && (a += " " + n[u]));
      }
      r[o] = a;
    }
    return r;
  }
  const T4 = /* @__PURE__ */ T.createContext();
  function ja(e, ...t) {
    const n = new URL(`https://mui.com/production-error/?code=${e}`);
    return t.forEach((r) => n.searchParams.append("args[]", r)), `Minified MUI error #${e}; visit ${n} for the full message.`;
  }
  function $e(e) {
    if (typeof e != "string")
      throw new Error(ja(7));
    return e.charAt(0).toUpperCase() + e.slice(1);
  }
  var Qw = { exports: {} }, tn = {};
  /**
   * @license React
   * react-is.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var hP;
  function HG() {
    if (hP) return tn;
    hP = 1;
    var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), i = Symbol.for("react.consumer"), a = Symbol.for("react.context"), s = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), h = Symbol.for("react.view_transition"), g = Symbol.for("react.client.reference");
    function y(b) {
      if (typeof b == "object" && b !== null) {
        var v = b.$$typeof;
        switch (v) {
          case e:
            switch (b = b.type, b) {
              case n:
              case o:
              case r:
              case l:
              case u:
              case h:
                return b;
              default:
                switch (b = b && b.$$typeof, b) {
                  case a:
                  case s:
                  case p:
                  case d:
                    return b;
                  case i:
                    return b;
                  default:
                    return v;
                }
            }
          case t:
            return v;
        }
      }
    }
    return tn.ContextConsumer = i, tn.ContextProvider = a, tn.Element = e, tn.ForwardRef = s, tn.Fragment = n, tn.Lazy = p, tn.Memo = d, tn.Portal = t, tn.Profiler = o, tn.StrictMode = r, tn.Suspense = l, tn.SuspenseList = u, tn.isContextConsumer = function(b) {
      return y(b) === i;
    }, tn.isContextProvider = function(b) {
      return y(b) === a;
    }, tn.isElement = function(b) {
      return typeof b == "object" && b !== null && b.$$typeof === e;
    }, tn.isForwardRef = function(b) {
      return y(b) === s;
    }, tn.isFragment = function(b) {
      return y(b) === n;
    }, tn.isLazy = function(b) {
      return y(b) === p;
    }, tn.isMemo = function(b) {
      return y(b) === d;
    }, tn.isPortal = function(b) {
      return y(b) === t;
    }, tn.isProfiler = function(b) {
      return y(b) === o;
    }, tn.isStrictMode = function(b) {
      return y(b) === r;
    }, tn.isSuspense = function(b) {
      return y(b) === l;
    }, tn.isSuspenseList = function(b) {
      return y(b) === u;
    }, tn.isValidElementType = function(b) {
      return typeof b == "string" || typeof b == "function" || b === n || b === o || b === r || b === l || b === u || typeof b == "object" && b !== null && (b.$$typeof === p || b.$$typeof === d || b.$$typeof === a || b.$$typeof === i || b.$$typeof === s || b.$$typeof === g || b.getModuleId !== void 0);
    }, tn.typeOf = y, tn;
  }
  var mP;
  function qG() {
    return mP || (mP = 1, Qw.exports = /* @__PURE__ */ HG()), Qw.exports;
  }
  var R4 = /* @__PURE__ */ qG();
  function ki(e) {
    if (typeof e != "object" || e === null)
      return !1;
    const t = Object.getPrototypeOf(e);
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
  }
  function O4(e) {
    if (/* @__PURE__ */ T.isValidElement(e) || R4.isValidElementType(e) || !ki(e))
      return e;
    const t = {};
    return Object.keys(e).forEach((n) => {
      t[n] = O4(e[n]);
    }), t;
  }
  function vr(e, t, n = {
    clone: !0
  }) {
    const r = n.clone ? {
      ...e
    } : e;
    return ki(e) && ki(t) && Object.keys(t).forEach((o) => {
      /* @__PURE__ */ T.isValidElement(t[o]) || R4.isValidElementType(t[o]) ? r[o] = t[o] : ki(t[o]) && // Avoid prototype pollution
      Object.prototype.hasOwnProperty.call(e, o) && ki(e[o]) ? r[o] = vr(e[o], t[o], n) : n.clone ? r[o] = ki(t[o]) ? O4(t[o]) : t[o] : r[o] = t[o];
    }), r;
  }
  function _p(e, t) {
    return t ? vr(e, t, {
      clone: !1
      // No need to clone deep, it's way faster.
    }) : e;
  }
  function gP(e, t) {
    if (!e.containerQueries)
      return t;
    const n = Object.keys(t).filter((r) => r.startsWith("@container")).sort((r, o) => {
      const i = /min-width:\s*([0-9.]+)/;
      return +(r.match(i)?.[1] || 0) - +(o.match(i)?.[1] || 0);
    });
    return n.length ? n.reduce((r, o) => {
      const i = t[o];
      return delete r[o], r[o] = i, r;
    }, {
      ...t
    }) : t;
  }
  function WG(e, t) {
    return t === "@" || t.startsWith("@") && (e.some((n) => t.startsWith(`@${n}`)) || !!t.match(/^@\d/));
  }
  function GG(e, t) {
    const n = t.match(/^@([^/]+)?\/?(.+)?$/);
    if (!n)
      return null;
    const [, r, o] = n, i = Number.isNaN(+r) ? r || 0 : +r;
    return e.containerQueries(o).up(i);
  }
  function KG(e) {
    const t = (i, a) => i.replace("@media", a ? `@container ${a}` : "@container");
    function n(i, a) {
      i.up = (...s) => t(e.breakpoints.up(...s), a), i.down = (...s) => t(e.breakpoints.down(...s), a), i.between = (...s) => t(e.breakpoints.between(...s), a), i.only = (...s) => t(e.breakpoints.only(...s), a), i.not = (...s) => {
        const l = t(e.breakpoints.not(...s), a);
        return l.includes("not all and") ? l.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or") : l;
      };
    }
    const r = {}, o = (i) => (n(r, i), r);
    return n(o), {
      ...e,
      containerQueries: o
    };
  }
  const U0 = {
    xs: 0,
    // phone
    sm: 600,
    // tablet
    md: 900,
    // small laptop
    lg: 1200,
    // desktop
    xl: 1536
    // large screen
  }, yP = {
    // Sorted ASC by size. That's important.
    // It can't be configured as it's used statically for propTypes.
    keys: ["xs", "sm", "md", "lg", "xl"],
    up: (e) => `@media (min-width:${U0[e]}px)`
  }, YG = {
    containerQueries: (e) => ({
      up: (t) => {
        let n = typeof t == "number" ? t : U0[t] || t;
        return typeof n == "number" && (n = `${n}px`), e ? `@container ${e} (min-width:${n})` : `@container (min-width:${n})`;
      }
    })
  };
  function Da(e, t, n) {
    const r = e.theme || {};
    if (Array.isArray(t)) {
      const i = r.breakpoints || yP;
      return t.reduce((a, s, l) => (a[i.up(i.keys[l])] = n(t[l]), a), {});
    }
    if (typeof t == "object") {
      const i = r.breakpoints || yP;
      return Object.keys(t).reduce((a, s) => {
        if (WG(i.keys, s)) {
          const l = GG(r.containerQueries ? r : YG, s);
          l && (a[l] = n(t[s], s));
        } else if (Object.keys(i.values || U0).includes(s)) {
          const l = i.up(s);
          a[l] = n(t[s], s);
        } else {
          const l = s;
          a[l] = t[l];
        }
        return a;
      }, {});
    }
    return n(t);
  }
  function XG(e = {}) {
    return e.keys?.reduce((n, r) => {
      const o = e.up(r);
      return n[o] = {}, n;
    }, {}) || {};
  }
  function vP(e, t) {
    return e.reduce((n, r) => {
      const o = n[r];
      return (!o || Object.keys(o).length === 0) && delete n[r], n;
    }, t);
  }
  function V0(e, t, n = !0) {
    if (!t || typeof t != "string")
      return null;
    if (e && e.vars && n) {
      const r = `vars.${t}`.split(".").reduce((o, i) => o && o[i] ? o[i] : null, e);
      if (r != null)
        return r;
    }
    return t.split(".").reduce((r, o) => r && r[o] != null ? r[o] : null, e);
  }
  function jv(e, t, n, r = n) {
    let o;
    return typeof e == "function" ? o = e(n) : Array.isArray(e) ? o = e[n] || r : o = V0(e, n) || r, t && (o = t(o, r, e)), o;
  }
  function Pn(e) {
    const {
      prop: t,
      cssProperty: n = e.prop,
      themeKey: r,
      transform: o
    } = e, i = (a) => {
      if (a[t] == null)
        return null;
      const s = a[t], l = a.theme, u = V0(l, r) || {};
      return Da(a, s, (p) => {
        let h = jv(u, o, p);
        return p === h && typeof p == "string" && (h = jv(u, o, `${t}${p === "default" ? "" : $e(p)}`, p)), n === !1 ? h : {
          [n]: h
        };
      });
    };
    return i.propTypes = {}, i.filterProps = [t], i;
  }
  function ZG(e) {
    const t = {};
    return (n) => (t[n] === void 0 && (t[n] = e(n)), t[n]);
  }
  const QG = {
    m: "margin",
    p: "padding"
  }, JG = {
    t: "Top",
    r: "Right",
    b: "Bottom",
    l: "Left",
    x: ["Left", "Right"],
    y: ["Top", "Bottom"]
  }, bP = {
    marginX: "mx",
    marginY: "my",
    paddingX: "px",
    paddingY: "py"
  }, eK = ZG((e) => {
    if (e.length > 2)
      if (bP[e])
        e = bP[e];
      else
        return [e];
    const [t, n] = e.split(""), r = QG[t], o = JG[n] || "";
    return Array.isArray(o) ? o.map((i) => r + i) : [r + o];
  }), tk = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], nk = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
  [...tk, ...nk];
  function Th(e, t, n, r) {
    const o = V0(e, t, !0) ?? n;
    return typeof o == "number" || typeof o == "string" ? (i) => typeof i == "string" ? i : typeof o == "string" ? o.startsWith("var(") && i === 0 ? 0 : o.startsWith("var(") && i === 1 ? o : `calc(${i} * ${o})` : o * i : Array.isArray(o) ? (i) => {
      if (typeof i == "string")
        return i;
      const a = Math.abs(i), s = o[a];
      return i >= 0 ? s : typeof s == "number" ? -s : typeof s == "string" && s.startsWith("var(") ? `calc(-1 * ${s})` : `-${s}`;
    } : typeof o == "function" ? o : () => {
    };
  }
  function rk(e) {
    return Th(e, "spacing", 8);
  }
  function Rh(e, t) {
    return typeof t == "string" || t == null ? t : e(t);
  }
  function tK(e, t) {
    return (n) => e.reduce((r, o) => (r[o] = Rh(t, n), r), {});
  }
  function nK(e, t, n, r) {
    if (!t.includes(n))
      return null;
    const o = eK(n), i = tK(o, r), a = e[n];
    return Da(e, a, i);
  }
  function A4(e, t) {
    const n = rk(e.theme);
    return Object.keys(e).map((r) => nK(e, t, r, n)).reduce(_p, {});
  }
  function Cn(e) {
    return A4(e, tk);
  }
  Cn.propTypes = {};
  Cn.filterProps = tk;
  function kn(e) {
    return A4(e, nk);
  }
  kn.propTypes = {};
  kn.filterProps = nk;
  function H0(...e) {
    const t = e.reduce((r, o) => (o.filterProps.forEach((i) => {
      r[i] = o;
    }), r), {}), n = (r) => Object.keys(r).reduce((o, i) => t[i] ? _p(o, t[i](r)) : o, {});
    return n.propTypes = {}, n.filterProps = e.reduce((r, o) => r.concat(o.filterProps), []), n;
  }
  function _o(e) {
    return typeof e != "number" ? e : `${e}px solid`;
  }
  function Po(e, t) {
    return Pn({
      prop: e,
      themeKey: "borders",
      transform: t
    });
  }
  const rK = Po("border", _o), oK = Po("borderTop", _o), iK = Po("borderRight", _o), aK = Po("borderBottom", _o), sK = Po("borderLeft", _o), lK = Po("borderColor"), cK = Po("borderTopColor"), uK = Po("borderRightColor"), fK = Po("borderBottomColor"), dK = Po("borderLeftColor"), pK = Po("outline", _o), hK = Po("outlineColor"), q0 = (e) => {
    if (e.borderRadius !== void 0 && e.borderRadius !== null) {
      const t = Th(e.theme, "shape.borderRadius", 4), n = (r) => ({
        borderRadius: Rh(t, r)
      });
      return Da(e, e.borderRadius, n);
    }
    return null;
  };
  q0.propTypes = {};
  q0.filterProps = ["borderRadius"];
  H0(rK, oK, iK, aK, sK, lK, cK, uK, fK, dK, q0, pK, hK);
  const W0 = (e) => {
    if (e.gap !== void 0 && e.gap !== null) {
      const t = Th(e.theme, "spacing", 8), n = (r) => ({
        gap: Rh(t, r)
      });
      return Da(e, e.gap, n);
    }
    return null;
  };
  W0.propTypes = {};
  W0.filterProps = ["gap"];
  const G0 = (e) => {
    if (e.columnGap !== void 0 && e.columnGap !== null) {
      const t = Th(e.theme, "spacing", 8), n = (r) => ({
        columnGap: Rh(t, r)
      });
      return Da(e, e.columnGap, n);
    }
    return null;
  };
  G0.propTypes = {};
  G0.filterProps = ["columnGap"];
  const K0 = (e) => {
    if (e.rowGap !== void 0 && e.rowGap !== null) {
      const t = Th(e.theme, "spacing", 8), n = (r) => ({
        rowGap: Rh(t, r)
      });
      return Da(e, e.rowGap, n);
    }
    return null;
  };
  K0.propTypes = {};
  K0.filterProps = ["rowGap"];
  const mK = Pn({
    prop: "gridColumn"
  }), gK = Pn({
    prop: "gridRow"
  }), yK = Pn({
    prop: "gridAutoFlow"
  }), vK = Pn({
    prop: "gridAutoColumns"
  }), bK = Pn({
    prop: "gridAutoRows"
  }), xK = Pn({
    prop: "gridTemplateColumns"
  }), wK = Pn({
    prop: "gridTemplateRows"
  }), SK = Pn({
    prop: "gridTemplateAreas"
  }), _K = Pn({
    prop: "gridArea"
  });
  H0(W0, G0, K0, mK, gK, yK, vK, bK, xK, wK, SK, _K);
  function Uu(e, t) {
    return t === "grey" ? t : e;
  }
  const EK = Pn({
    prop: "color",
    themeKey: "palette",
    transform: Uu
  }), CK = Pn({
    prop: "bgcolor",
    cssProperty: "backgroundColor",
    themeKey: "palette",
    transform: Uu
  }), kK = Pn({
    prop: "backgroundColor",
    themeKey: "palette",
    transform: Uu
  });
  H0(EK, CK, kK);
  function to(e) {
    return e <= 1 && e !== 0 ? `${e * 100}%` : e;
  }
  const TK = Pn({
    prop: "width",
    transform: to
  }), ok = (e) => {
    if (e.maxWidth !== void 0 && e.maxWidth !== null) {
      const t = (n) => {
        const r = e.theme?.breakpoints?.values?.[n] || U0[n];
        return r ? e.theme?.breakpoints?.unit !== "px" ? {
          maxWidth: `${r}${e.theme.breakpoints.unit}`
        } : {
          maxWidth: r
        } : {
          maxWidth: to(n)
        };
      };
      return Da(e, e.maxWidth, t);
    }
    return null;
  };
  ok.filterProps = ["maxWidth"];
  const RK = Pn({
    prop: "minWidth",
    transform: to
  }), OK = Pn({
    prop: "height",
    transform: to
  }), AK = Pn({
    prop: "maxHeight",
    transform: to
  }), NK = Pn({
    prop: "minHeight",
    transform: to
  });
  Pn({
    prop: "size",
    cssProperty: "width",
    transform: to
  });
  Pn({
    prop: "size",
    cssProperty: "height",
    transform: to
  });
  const MK = Pn({
    prop: "boxSizing"
  });
  H0(TK, ok, RK, OK, AK, NK, MK);
  const Oh = {
    // borders
    border: {
      themeKey: "borders",
      transform: _o
    },
    borderTop: {
      themeKey: "borders",
      transform: _o
    },
    borderRight: {
      themeKey: "borders",
      transform: _o
    },
    borderBottom: {
      themeKey: "borders",
      transform: _o
    },
    borderLeft: {
      themeKey: "borders",
      transform: _o
    },
    borderColor: {
      themeKey: "palette"
    },
    borderTopColor: {
      themeKey: "palette"
    },
    borderRightColor: {
      themeKey: "palette"
    },
    borderBottomColor: {
      themeKey: "palette"
    },
    borderLeftColor: {
      themeKey: "palette"
    },
    outline: {
      themeKey: "borders",
      transform: _o
    },
    outlineColor: {
      themeKey: "palette"
    },
    borderRadius: {
      themeKey: "shape.borderRadius",
      style: q0
    },
    // palette
    color: {
      themeKey: "palette",
      transform: Uu
    },
    bgcolor: {
      themeKey: "palette",
      cssProperty: "backgroundColor",
      transform: Uu
    },
    backgroundColor: {
      themeKey: "palette",
      transform: Uu
    },
    // spacing
    p: {
      style: kn
    },
    pt: {
      style: kn
    },
    pr: {
      style: kn
    },
    pb: {
      style: kn
    },
    pl: {
      style: kn
    },
    px: {
      style: kn
    },
    py: {
      style: kn
    },
    padding: {
      style: kn
    },
    paddingTop: {
      style: kn
    },
    paddingRight: {
      style: kn
    },
    paddingBottom: {
      style: kn
    },
    paddingLeft: {
      style: kn
    },
    paddingX: {
      style: kn
    },
    paddingY: {
      style: kn
    },
    paddingInline: {
      style: kn
    },
    paddingInlineStart: {
      style: kn
    },
    paddingInlineEnd: {
      style: kn
    },
    paddingBlock: {
      style: kn
    },
    paddingBlockStart: {
      style: kn
    },
    paddingBlockEnd: {
      style: kn
    },
    m: {
      style: Cn
    },
    mt: {
      style: Cn
    },
    mr: {
      style: Cn
    },
    mb: {
      style: Cn
    },
    ml: {
      style: Cn
    },
    mx: {
      style: Cn
    },
    my: {
      style: Cn
    },
    margin: {
      style: Cn
    },
    marginTop: {
      style: Cn
    },
    marginRight: {
      style: Cn
    },
    marginBottom: {
      style: Cn
    },
    marginLeft: {
      style: Cn
    },
    marginX: {
      style: Cn
    },
    marginY: {
      style: Cn
    },
    marginInline: {
      style: Cn
    },
    marginInlineStart: {
      style: Cn
    },
    marginInlineEnd: {
      style: Cn
    },
    marginBlock: {
      style: Cn
    },
    marginBlockStart: {
      style: Cn
    },
    marginBlockEnd: {
      style: Cn
    },
    // display
    displayPrint: {
      cssProperty: !1,
      transform: (e) => ({
        "@media print": {
          display: e
        }
      })
    },
    display: {},
    overflow: {},
    textOverflow: {},
    visibility: {},
    whiteSpace: {},
    // flexbox
    flexBasis: {},
    flexDirection: {},
    flexWrap: {},
    justifyContent: {},
    alignItems: {},
    alignContent: {},
    order: {},
    flex: {},
    flexGrow: {},
    flexShrink: {},
    alignSelf: {},
    justifyItems: {},
    justifySelf: {},
    // grid
    gap: {
      style: W0
    },
    rowGap: {
      style: K0
    },
    columnGap: {
      style: G0
    },
    gridColumn: {},
    gridRow: {},
    gridAutoFlow: {},
    gridAutoColumns: {},
    gridAutoRows: {},
    gridTemplateColumns: {},
    gridTemplateRows: {},
    gridTemplateAreas: {},
    gridArea: {},
    // positions
    position: {},
    zIndex: {
      themeKey: "zIndex"
    },
    top: {},
    right: {},
    bottom: {},
    left: {},
    // shadows
    boxShadow: {
      themeKey: "shadows"
    },
    // sizing
    width: {
      transform: to
    },
    maxWidth: {
      style: ok
    },
    minWidth: {
      transform: to
    },
    height: {
      transform: to
    },
    maxHeight: {
      transform: to
    },
    minHeight: {
      transform: to
    },
    boxSizing: {},
    // typography
    font: {
      themeKey: "font"
    },
    fontFamily: {
      themeKey: "typography"
    },
    fontSize: {
      themeKey: "typography"
    },
    fontStyle: {
      themeKey: "typography"
    },
    fontWeight: {
      themeKey: "typography"
    },
    letterSpacing: {},
    textTransform: {},
    lineHeight: {},
    textAlign: {},
    typography: {
      cssProperty: !1,
      themeKey: "typography"
    }
  };
  function PK(...e) {
    const t = e.reduce((r, o) => r.concat(Object.keys(o)), []), n = new Set(t);
    return e.every((r) => n.size === Object.keys(r).length);
  }
  function $K(e, t) {
    return typeof e == "function" ? e(t) : e;
  }
  function IK() {
    function e(n, r, o, i) {
      const a = {
        [n]: r,
        theme: o
      }, s = i[n];
      if (!s)
        return {
          [n]: r
        };
      const {
        cssProperty: l = n,
        themeKey: u,
        transform: d,
        style: p
      } = s;
      if (r == null)
        return null;
      if (u === "typography" && r === "inherit")
        return {
          [n]: r
        };
      const h = V0(o, u) || {};
      return p ? p(a) : Da(a, r, (y) => {
        let b = jv(h, d, y);
        return y === b && typeof y == "string" && (b = jv(h, d, `${n}${y === "default" ? "" : $e(y)}`, y)), l === !1 ? b : {
          [l]: b
        };
      });
    }
    function t(n) {
      const {
        sx: r,
        theme: o = {},
        nested: i
      } = n || {};
      if (!r)
        return null;
      const a = o.unstable_sxConfig ?? Oh;
      function s(l) {
        let u = l;
        if (typeof l == "function")
          u = l(o);
        else if (typeof l != "object")
          return l;
        if (!u)
          return null;
        const d = XG(o.breakpoints), p = Object.keys(d);
        let h = d;
        return Object.keys(u).forEach((g) => {
          const y = $K(u[g], o);
          if (y != null)
            if (typeof y == "object")
              if (a[g])
                h = _p(h, e(g, y, o, a));
              else {
                const b = Da({
                  theme: o
                }, y, (v) => ({
                  [g]: v
                }));
                PK(b, y) ? h[g] = t({
                  sx: y,
                  theme: o,
                  nested: !0
                }) : h = _p(h, b);
              }
            else
              h = _p(h, e(g, y, o, a));
        }), !i && o.modularCssLayers ? {
          "@layer sx": gP(o, vP(p, h))
        } : gP(o, vP(p, h));
      }
      return Array.isArray(r) ? r.map(s) : s(r);
    }
    return t;
  }
  const Xs = IK();
  Xs.filterProps = ["sx"];
  const jK = (e) => {
    const t = {
      systemProps: {},
      otherProps: {}
    }, n = e?.theme?.unstable_sxConfig ?? Oh;
    return Object.keys(e).forEach((r) => {
      n[r] ? t.systemProps[r] = e[r] : t.otherProps[r] = e[r];
    }), t;
  };
  function ik(e) {
    const {
      sx: t,
      ...n
    } = e, {
      systemProps: r,
      otherProps: o
    } = jK(n);
    let i;
    return Array.isArray(t) ? i = [r, ...t] : typeof t == "function" ? i = (...a) => {
      const s = t(...a);
      return ki(s) ? {
        ...r,
        ...s
      } : r;
    } : i = {
      ...r,
      ...t
    }, {
      ...o,
      sx: i
    };
  }
  function Ge() {
    return Ge = Object.assign ? Object.assign.bind() : function(e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];
        for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
      }
      return e;
    }, Ge.apply(null, arguments);
  }
  function DK(e) {
    if (e.sheet)
      return e.sheet;
    for (var t = 0; t < document.styleSheets.length; t++)
      if (document.styleSheets[t].ownerNode === e)
        return document.styleSheets[t];
  }
  function FK(e) {
    var t = document.createElement("style");
    return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
  }
  var LK = /* @__PURE__ */ function() {
    function e(n) {
      var r = this;
      this._insertTag = function(o) {
        var i;
        r.tags.length === 0 ? r.insertionPoint ? i = r.insertionPoint.nextSibling : r.prepend ? i = r.container.firstChild : i = r.before : i = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(o, i), r.tags.push(o);
      }, this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
    }
    var t = e.prototype;
    return t.hydrate = function(r) {
      r.forEach(this._insertTag);
    }, t.insert = function(r) {
      this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(FK(this));
      var o = this.tags[this.tags.length - 1];
      if (this.isSpeedy) {
        var i = DK(o);
        try {
          i.insertRule(r, i.cssRules.length);
        } catch {
        }
      } else
        o.appendChild(document.createTextNode(r));
      this.ctr++;
    }, t.flush = function() {
      this.tags.forEach(function(r) {
        var o;
        return (o = r.parentNode) == null ? void 0 : o.removeChild(r);
      }), this.tags = [], this.ctr = 0;
    }, e;
  }(), pr = "-ms-", Dv = "-moz-", zt = "-webkit-", N4 = "comm", ak = "rule", sk = "decl", zK = "@import", M4 = "@keyframes", BK = "@layer", UK = Math.abs, Y0 = String.fromCharCode, VK = Object.assign;
  function HK(e, t) {
    return sr(e, 0) ^ 45 ? (((t << 2 ^ sr(e, 0)) << 2 ^ sr(e, 1)) << 2 ^ sr(e, 2)) << 2 ^ sr(e, 3) : 0;
  }
  function P4(e) {
    return e.trim();
  }
  function qK(e, t) {
    return (e = t.exec(e)) ? e[0] : e;
  }
  function Bt(e, t, n) {
    return e.replace(t, n);
  }
  function rE(e, t) {
    return e.indexOf(t);
  }
  function sr(e, t) {
    return e.charCodeAt(t) | 0;
  }
  function Up(e, t, n) {
    return e.slice(t, n);
  }
  function wi(e) {
    return e.length;
  }
  function lk(e) {
    return e.length;
  }
  function Pg(e, t) {
    return t.push(e), e;
  }
  function WK(e, t) {
    return e.map(t).join("");
  }
  var X0 = 1, tf = 1, $4 = 0, Ur = 0, Bn = 0, Sf = "";
  function Z0(e, t, n, r, o, i, a) {
    return { value: e, root: t, parent: n, type: r, props: o, children: i, line: X0, column: tf, length: a, return: "" };
  }
  function Vd(e, t) {
    return VK(Z0("", null, null, "", null, null, 0), e, { length: -e.length }, t);
  }
  function GK() {
    return Bn;
  }
  function KK() {
    return Bn = Ur > 0 ? sr(Sf, --Ur) : 0, tf--, Bn === 10 && (tf = 1, X0--), Bn;
  }
  function io() {
    return Bn = Ur < $4 ? sr(Sf, Ur++) : 0, tf++, Bn === 10 && (tf = 1, X0++), Bn;
  }
  function Di() {
    return sr(Sf, Ur);
  }
  function lv() {
    return Ur;
  }
  function Ah(e, t) {
    return Up(Sf, e, t);
  }
  function Vp(e) {
    switch (e) {
      // \0 \t \n \r \s whitespace token
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      // ! + , / > @ ~ isolate token
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      // ; { } breakpoint token
      case 59:
      case 123:
      case 125:
        return 4;
      // : accompanied token
      case 58:
        return 3;
      // " ' ( [ opening delimit token
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      // ) ] closing delimit token
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function I4(e) {
    return X0 = tf = 1, $4 = wi(Sf = e), Ur = 0, [];
  }
  function j4(e) {
    return Sf = "", e;
  }
  function cv(e) {
    return P4(Ah(Ur - 1, oE(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
  }
  function YK(e) {
    for (; (Bn = Di()) && Bn < 33; )
      io();
    return Vp(e) > 2 || Vp(Bn) > 3 ? "" : " ";
  }
  function XK(e, t) {
    for (; --t && io() && !(Bn < 48 || Bn > 102 || Bn > 57 && Bn < 65 || Bn > 70 && Bn < 97); )
      ;
    return Ah(e, lv() + (t < 6 && Di() == 32 && io() == 32));
  }
  function oE(e) {
    for (; io(); )
      switch (Bn) {
        // ] ) " '
        case e:
          return Ur;
        // " '
        case 34:
        case 39:
          e !== 34 && e !== 39 && oE(Bn);
          break;
        // (
        case 40:
          e === 41 && oE(e);
          break;
        // \
        case 92:
          io();
          break;
      }
    return Ur;
  }
  function ZK(e, t) {
    for (; io() && e + Bn !== 57; )
      if (e + Bn === 84 && Di() === 47)
        break;
    return "/*" + Ah(t, Ur - 1) + "*" + Y0(e === 47 ? e : io());
  }
  function QK(e) {
    for (; !Vp(Di()); )
      io();
    return Ah(e, Ur);
  }
  function JK(e) {
    return j4(uv("", null, null, null, [""], e = I4(e), 0, [0], e));
  }
  function uv(e, t, n, r, o, i, a, s, l) {
    for (var u = 0, d = 0, p = a, h = 0, g = 0, y = 0, b = 1, v = 1, x = 1, E = 0, _ = "", C = o, k = i, R = r, A = _; v; )
      switch (y = E, E = io()) {
        // (
        case 40:
          if (y != 108 && sr(A, p - 1) == 58) {
            rE(A += Bt(cv(E), "&", "&\f"), "&\f") != -1 && (x = -1);
            break;
          }
        // " ' [
        case 34:
        case 39:
        case 91:
          A += cv(E);
          break;
        // \t \n \r \s
        case 9:
        case 10:
        case 13:
        case 32:
          A += YK(y);
          break;
        // \
        case 92:
          A += XK(lv() - 1, 7);
          continue;
        // /
        case 47:
          switch (Di()) {
            case 42:
            case 47:
              Pg(eY(ZK(io(), lv()), t, n), l);
              break;
            default:
              A += "/";
          }
          break;
        // {
        case 123 * b:
          s[u++] = wi(A) * x;
        // } ; \0
        case 125 * b:
        case 59:
        case 0:
          switch (E) {
            // \0 }
            case 0:
            case 125:
              v = 0;
            // ;
            case 59 + d:
              x == -1 && (A = Bt(A, /\f/g, "")), g > 0 && wi(A) - p && Pg(g > 32 ? wP(A + ";", r, n, p - 1) : wP(Bt(A, " ", "") + ";", r, n, p - 2), l);
              break;
            // @ ;
            case 59:
              A += ";";
            // { rule/at-rule
            default:
              if (Pg(R = xP(A, t, n, u, d, o, s, _, C = [], k = [], p), i), E === 123)
                if (d === 0)
                  uv(A, t, R, R, C, i, p, s, k);
                else
                  switch (h === 99 && sr(A, 3) === 110 ? 100 : h) {
                    // d l m s
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      uv(e, R, R, r && Pg(xP(e, R, R, 0, 0, o, s, _, o, C = [], p), k), o, k, p, s, r ? C : k);
                      break;
                    default:
                      uv(A, R, R, R, [""], k, 0, s, k);
                  }
          }
          u = d = g = 0, b = x = 1, _ = A = "", p = a;
          break;
        // :
        case 58:
          p = 1 + wi(A), g = y;
        default:
          if (b < 1) {
            if (E == 123)
              --b;
            else if (E == 125 && b++ == 0 && KK() == 125)
              continue;
          }
          switch (A += Y0(E), E * b) {
            // &
            case 38:
              x = d > 0 ? 1 : (A += "\f", -1);
              break;
            // ,
            case 44:
              s[u++] = (wi(A) - 1) * x, x = 1;
              break;
            // @
            case 64:
              Di() === 45 && (A += cv(io())), h = Di(), d = p = wi(_ = A += QK(lv())), E++;
              break;
            // -
            case 45:
              y === 45 && wi(A) == 2 && (b = 0);
          }
      }
    return i;
  }
  function xP(e, t, n, r, o, i, a, s, l, u, d) {
    for (var p = o - 1, h = o === 0 ? i : [""], g = lk(h), y = 0, b = 0, v = 0; y < r; ++y)
      for (var x = 0, E = Up(e, p + 1, p = UK(b = a[y])), _ = e; x < g; ++x)
        (_ = P4(b > 0 ? h[x] + " " + E : Bt(E, /&\f/g, h[x]))) && (l[v++] = _);
    return Z0(e, t, n, o === 0 ? ak : s, l, u, d);
  }
  function eY(e, t, n) {
    return Z0(e, t, n, N4, Y0(GK()), Up(e, 2, -2), 0);
  }
  function wP(e, t, n, r) {
    return Z0(e, t, n, sk, Up(e, 0, r), Up(e, r + 1, -1), r);
  }
  function Vu(e, t) {
    for (var n = "", r = lk(e), o = 0; o < r; o++)
      n += t(e[o], o, e, t) || "";
    return n;
  }
  function tY(e, t, n, r) {
    switch (e.type) {
      case BK:
        if (e.children.length) break;
      case zK:
      case sk:
        return e.return = e.return || e.value;
      case N4:
        return "";
      case M4:
        return e.return = e.value + "{" + Vu(e.children, r) + "}";
      case ak:
        e.value = e.props.join(",");
    }
    return wi(n = Vu(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
  }
  function nY(e) {
    var t = lk(e);
    return function(n, r, o, i) {
      for (var a = "", s = 0; s < t; s++)
        a += e[s](n, r, o, i) || "";
      return a;
    };
  }
  function rY(e) {
    return function(t) {
      t.root || (t = t.return) && e(t);
    };
  }
  function D4(e) {
    var t = /* @__PURE__ */ Object.create(null);
    return function(n) {
      return t[n] === void 0 && (t[n] = e(n)), t[n];
    };
  }
  var oY = function(t, n, r) {
    for (var o = 0, i = 0; o = i, i = Di(), o === 38 && i === 12 && (n[r] = 1), !Vp(i); )
      io();
    return Ah(t, Ur);
  }, iY = function(t, n) {
    var r = -1, o = 44;
    do
      switch (Vp(o)) {
        case 0:
          o === 38 && Di() === 12 && (n[r] = 1), t[r] += oY(Ur - 1, n, r);
          break;
        case 2:
          t[r] += cv(o);
          break;
        case 4:
          if (o === 44) {
            t[++r] = Di() === 58 ? "&\f" : "", n[r] = t[r].length;
            break;
          }
        // fallthrough
        default:
          t[r] += Y0(o);
      }
    while (o = io());
    return t;
  }, aY = function(t, n) {
    return j4(iY(I4(t), n));
  }, SP = /* @__PURE__ */ new WeakMap(), sY = function(t) {
    if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
    // negative .length indicates that this rule has been already prefixed
    t.length < 1)) {
      for (var n = t.value, r = t.parent, o = t.column === r.column && t.line === r.line; r.type !== "rule"; )
        if (r = r.parent, !r) return;
      if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !SP.get(r)) && !o) {
        SP.set(t, !0);
        for (var i = [], a = aY(n, i), s = r.props, l = 0, u = 0; l < a.length; l++)
          for (var d = 0; d < s.length; d++, u++)
            t.props[u] = i[l] ? a[l].replace(/&\f/g, s[d]) : s[d] + " " + a[l];
      }
    }
  }, lY = function(t) {
    if (t.type === "decl") {
      var n = t.value;
      // charcode for l
      n.charCodeAt(0) === 108 && // charcode for b
      n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
    }
  };
  function F4(e, t) {
    switch (HK(e, t)) {
      // color-adjust
      case 5103:
        return zt + "print-" + e + e;
      // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
      case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
      // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
      case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
      // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
      case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
      // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
      case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return zt + e + e;
      // appearance, user-select, transform, hyphens, text-size-adjust
      case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return zt + e + Dv + e + pr + e + e;
      // flex, flex-direction
      case 6828:
      case 4268:
        return zt + e + pr + e + e;
      // order
      case 6165:
        return zt + e + pr + "flex-" + e + e;
      // align-items
      case 5187:
        return zt + e + Bt(e, /(\w+).+(:[^]+)/, zt + "box-$1$2" + pr + "flex-$1$2") + e;
      // align-self
      case 5443:
        return zt + e + pr + "flex-item-" + Bt(e, /flex-|-self/, "") + e;
      // align-content
      case 4675:
        return zt + e + pr + "flex-line-pack" + Bt(e, /align-content|flex-|-self/, "") + e;
      // flex-shrink
      case 5548:
        return zt + e + pr + Bt(e, "shrink", "negative") + e;
      // flex-basis
      case 5292:
        return zt + e + pr + Bt(e, "basis", "preferred-size") + e;
      // flex-grow
      case 6060:
        return zt + "box-" + Bt(e, "-grow", "") + zt + e + pr + Bt(e, "grow", "positive") + e;
      // transition
      case 4554:
        return zt + Bt(e, /([^-])(transform)/g, "$1" + zt + "$2") + e;
      // cursor
      case 6187:
        return Bt(Bt(Bt(e, /(zoom-|grab)/, zt + "$1"), /(image-set)/, zt + "$1"), e, "") + e;
      // background, background-image
      case 5495:
      case 3959:
        return Bt(e, /(image-set\([^]*)/, zt + "$1$`$1");
      // justify-content
      case 4968:
        return Bt(Bt(e, /(.+:)(flex-)?(.*)/, zt + "box-pack:$3" + pr + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + zt + e + e;
      // (margin|padding)-inline-(start|end)
      case 4095:
      case 3583:
      case 4068:
      case 2532:
        return Bt(e, /(.+)-inline(.+)/, zt + "$1$2") + e;
      // (min|max)?(width|height|inline-size|block-size)
      case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (wi(e) - 1 - t > 6) switch (sr(e, t + 1)) {
          // (m)ax-content, (m)in-content
          case 109:
            if (sr(e, t + 4) !== 45) break;
          // (f)ill-available, (f)it-content
          case 102:
            return Bt(e, /(.+:)(.+)-([^]+)/, "$1" + zt + "$2-$3$1" + Dv + (sr(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
          // (s)tretch
          case 115:
            return ~rE(e, "stretch") ? F4(Bt(e, "stretch", "fill-available"), t) + e : e;
        }
        break;
      // position: sticky
      case 4949:
        if (sr(e, t + 1) !== 115) break;
      // display: (flex|inline-flex)
      case 6444:
        switch (sr(e, wi(e) - 3 - (~rE(e, "!important") && 10))) {
          // stic(k)y
          case 107:
            return Bt(e, ":", ":" + zt) + e;
          // (inline-)?fl(e)x
          case 101:
            return Bt(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + zt + (sr(e, 14) === 45 ? "inline-" : "") + "box$3$1" + zt + "$2$3$1" + pr + "$2box$3") + e;
        }
        break;
      // writing-mode
      case 5936:
        switch (sr(e, t + 11)) {
          // vertical-l(r)
          case 114:
            return zt + e + pr + Bt(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
          // vertical-r(l)
          case 108:
            return zt + e + pr + Bt(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
          // horizontal(-)tb
          case 45:
            return zt + e + pr + Bt(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
        }
        return zt + e + pr + e + e;
    }
    return e;
  }
  var cY = function(t, n, r, o) {
    if (t.length > -1 && !t.return) switch (t.type) {
      case sk:
        t.return = F4(t.value, t.length);
        break;
      case M4:
        return Vu([Vd(t, {
          value: Bt(t.value, "@", "@" + zt)
        })], o);
      case ak:
        if (t.length) return WK(t.props, function(i) {
          switch (qK(i, /(::plac\w+|:read-\w+)/)) {
            // :read-(only|write)
            case ":read-only":
            case ":read-write":
              return Vu([Vd(t, {
                props: [Bt(i, /:(read-\w+)/, ":" + Dv + "$1")]
              })], o);
            // :placeholder
            case "::placeholder":
              return Vu([Vd(t, {
                props: [Bt(i, /:(plac\w+)/, ":" + zt + "input-$1")]
              }), Vd(t, {
                props: [Bt(i, /:(plac\w+)/, ":" + Dv + "$1")]
              }), Vd(t, {
                props: [Bt(i, /:(plac\w+)/, pr + "input-$1")]
              })], o);
          }
          return "";
        });
    }
  }, uY = [cY], fY = function(t) {
    var n = t.key;
    if (n === "css") {
      var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(r, function(b) {
        var v = b.getAttribute("data-emotion");
        v.indexOf(" ") !== -1 && (document.head.appendChild(b), b.setAttribute("data-s", ""));
      });
    }
    var o = t.stylisPlugins || uY, i = {}, a, s = [];
    a = t.container || document.head, Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
      function(b) {
        for (var v = b.getAttribute("data-emotion").split(" "), x = 1; x < v.length; x++)
          i[v[x]] = !0;
        s.push(b);
      }
    );
    var l, u = [sY, lY];
    {
      var d, p = [tY, rY(function(b) {
        d.insert(b);
      })], h = nY(u.concat(o, p)), g = function(v) {
        return Vu(JK(v), h);
      };
      l = function(v, x, E, _) {
        d = E, g(v ? v + "{" + x.styles + "}" : x.styles), _ && (y.inserted[x.name] = !0);
      };
    }
    var y = {
      key: n,
      sheet: new LK({
        key: n,
        container: a,
        nonce: t.nonce,
        speedy: t.speedy,
        prepend: t.prepend,
        insertionPoint: t.insertionPoint
      }),
      nonce: t.nonce,
      inserted: i,
      registered: {},
      insert: l
    };
    return y.sheet.hydrate(s), y;
  }, Jw = { exports: {} }, Ut = {};
  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var _P;
  function dY() {
    if (_P) return Ut;
    _P = 1;
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, d = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, h = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, y = e ? Symbol.for("react.lazy") : 60116, b = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, x = e ? Symbol.for("react.responder") : 60118, E = e ? Symbol.for("react.scope") : 60119;
    function _(k) {
      if (typeof k == "object" && k !== null) {
        var R = k.$$typeof;
        switch (R) {
          case t:
            switch (k = k.type, k) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return k;
              default:
                switch (k = k && k.$$typeof, k) {
                  case s:
                  case d:
                  case y:
                  case g:
                  case a:
                    return k;
                  default:
                    return R;
                }
            }
          case n:
            return R;
        }
      }
    }
    function C(k) {
      return _(k) === u;
    }
    return Ut.AsyncMode = l, Ut.ConcurrentMode = u, Ut.ContextConsumer = s, Ut.ContextProvider = a, Ut.Element = t, Ut.ForwardRef = d, Ut.Fragment = r, Ut.Lazy = y, Ut.Memo = g, Ut.Portal = n, Ut.Profiler = i, Ut.StrictMode = o, Ut.Suspense = p, Ut.isAsyncMode = function(k) {
      return C(k) || _(k) === l;
    }, Ut.isConcurrentMode = C, Ut.isContextConsumer = function(k) {
      return _(k) === s;
    }, Ut.isContextProvider = function(k) {
      return _(k) === a;
    }, Ut.isElement = function(k) {
      return typeof k == "object" && k !== null && k.$$typeof === t;
    }, Ut.isForwardRef = function(k) {
      return _(k) === d;
    }, Ut.isFragment = function(k) {
      return _(k) === r;
    }, Ut.isLazy = function(k) {
      return _(k) === y;
    }, Ut.isMemo = function(k) {
      return _(k) === g;
    }, Ut.isPortal = function(k) {
      return _(k) === n;
    }, Ut.isProfiler = function(k) {
      return _(k) === i;
    }, Ut.isStrictMode = function(k) {
      return _(k) === o;
    }, Ut.isSuspense = function(k) {
      return _(k) === p;
    }, Ut.isValidElementType = function(k) {
      return typeof k == "string" || typeof k == "function" || k === r || k === u || k === i || k === o || k === p || k === h || typeof k == "object" && k !== null && (k.$$typeof === y || k.$$typeof === g || k.$$typeof === a || k.$$typeof === s || k.$$typeof === d || k.$$typeof === v || k.$$typeof === x || k.$$typeof === E || k.$$typeof === b);
    }, Ut.typeOf = _, Ut;
  }
  var EP;
  function pY() {
    return EP || (EP = 1, Jw.exports = dY()), Jw.exports;
  }
  var eS, CP;
  function hY() {
    if (CP) return eS;
    CP = 1;
    var e = pY(), t = {
      childContextTypes: !0,
      contextType: !0,
      contextTypes: !0,
      defaultProps: !0,
      displayName: !0,
      getDefaultProps: !0,
      getDerivedStateFromError: !0,
      getDerivedStateFromProps: !0,
      mixins: !0,
      propTypes: !0,
      type: !0
    }, n = {
      name: !0,
      length: !0,
      prototype: !0,
      caller: !0,
      callee: !0,
      arguments: !0,
      arity: !0
    }, r = {
      $$typeof: !0,
      render: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0
    }, o = {
      $$typeof: !0,
      compare: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0,
      type: !0
    }, i = {};
    i[e.ForwardRef] = r, i[e.Memo] = o;
    function a(y) {
      return e.isMemo(y) ? o : i[y.$$typeof] || t;
    }
    var s = Object.defineProperty, l = Object.getOwnPropertyNames, u = Object.getOwnPropertySymbols, d = Object.getOwnPropertyDescriptor, p = Object.getPrototypeOf, h = Object.prototype;
    function g(y, b, v) {
      if (typeof b != "string") {
        if (h) {
          var x = p(b);
          x && x !== h && g(y, x, v);
        }
        var E = l(b);
        u && (E = E.concat(u(b)));
        for (var _ = a(y), C = a(b), k = 0; k < E.length; ++k) {
          var R = E[k];
          if (!n[R] && !(v && v[R]) && !(C && C[R]) && !(_ && _[R])) {
            var A = d(b, R);
            try {
              s(y, R, A);
            } catch {
            }
          }
        }
      }
      return y;
    }
    return eS = g, eS;
  }
  hY();
  var mY = !0;
  function L4(e, t, n) {
    var r = "";
    return n.split(" ").forEach(function(o) {
      e[o] !== void 0 ? t.push(e[o] + ";") : o && (r += o + " ");
    }), r;
  }
  var ck = function(t, n, r) {
    var o = t.key + "-" + n.name;
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (r === !1 || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    mY === !1) && t.registered[o] === void 0 && (t.registered[o] = n.styles);
  }, uk = function(t, n, r) {
    ck(t, n, r);
    var o = t.key + "-" + n.name;
    if (t.inserted[n.name] === void 0) {
      var i = n;
      do
        t.insert(n === i ? "." + o : "", i, t.sheet, !0), i = i.next;
      while (i !== void 0);
    }
  };
  function gY(e) {
    for (var t = 0, n, r = 0, o = e.length; o >= 4; ++r, o -= 4)
      n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
      (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
      n >>> 24, t = /* Math.imul(k, m): */
      (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
    switch (o) {
      case 3:
        t ^= (e.charCodeAt(r + 2) & 255) << 16;
      case 2:
        t ^= (e.charCodeAt(r + 1) & 255) << 8;
      case 1:
        t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
        (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
    }
    return t ^= t >>> 13, t = /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
  }
  var yY = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  }, vY = /[A-Z]|^ms/g, bY = /_EMO_([^_]+?)_([^]*?)_EMO_/g, z4 = function(t) {
    return t.charCodeAt(1) === 45;
  }, kP = function(t) {
    return t != null && typeof t != "boolean";
  }, tS = /* @__PURE__ */ D4(function(e) {
    return z4(e) ? e : e.replace(vY, "-$&").toLowerCase();
  }), TP = function(t, n) {
    switch (t) {
      case "animation":
      case "animationName":
        if (typeof n == "string")
          return n.replace(bY, function(r, o, i) {
            return Si = {
              name: o,
              styles: i,
              next: Si
            }, o;
          });
    }
    return yY[t] !== 1 && !z4(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
  };
  function Hp(e, t, n) {
    if (n == null)
      return "";
    var r = n;
    if (r.__emotion_styles !== void 0)
      return r;
    switch (typeof n) {
      case "boolean":
        return "";
      case "object": {
        var o = n;
        if (o.anim === 1)
          return Si = {
            name: o.name,
            styles: o.styles,
            next: Si
          }, o.name;
        var i = n;
        if (i.styles !== void 0) {
          var a = i.next;
          if (a !== void 0)
            for (; a !== void 0; )
              Si = {
                name: a.name,
                styles: a.styles,
                next: Si
              }, a = a.next;
          var s = i.styles + ";";
          return s;
        }
        return xY(e, t, n);
      }
      case "function": {
        if (e !== void 0) {
          var l = Si, u = n(e);
          return Si = l, Hp(e, t, u);
        }
        break;
      }
    }
    var d = n;
    if (t == null)
      return d;
    var p = t[d];
    return p !== void 0 ? p : d;
  }
  function xY(e, t, n) {
    var r = "";
    if (Array.isArray(n))
      for (var o = 0; o < n.length; o++)
        r += Hp(e, t, n[o]) + ";";
    else
      for (var i in n) {
        var a = n[i];
        if (typeof a != "object") {
          var s = a;
          t != null && t[s] !== void 0 ? r += i + "{" + t[s] + "}" : kP(s) && (r += tS(i) + ":" + TP(i, s) + ";");
        } else if (Array.isArray(a) && typeof a[0] == "string" && (t == null || t[a[0]] === void 0))
          for (var l = 0; l < a.length; l++)
            kP(a[l]) && (r += tS(i) + ":" + TP(i, a[l]) + ";");
        else {
          var u = Hp(e, t, a);
          switch (i) {
            case "animation":
            case "animationName": {
              r += tS(i) + ":" + u + ";";
              break;
            }
            default:
              r += i + "{" + u + "}";
          }
        }
      }
    return r;
  }
  var RP = /label:\s*([^\s;{]+)\s*(;|$)/g, Si;
  function Nh(e, t, n) {
    if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
      return e[0];
    var r = !0, o = "";
    Si = void 0;
    var i = e[0];
    if (i == null || i.raw === void 0)
      r = !1, o += Hp(n, t, i);
    else {
      var a = i;
      o += a[0];
    }
    for (var s = 1; s < e.length; s++)
      if (o += Hp(n, t, e[s]), r) {
        var l = i;
        o += l[s];
      }
    RP.lastIndex = 0;
    for (var u = "", d; (d = RP.exec(o)) !== null; )
      u += "-" + d[1];
    var p = gY(o) + u;
    return {
      name: p,
      styles: o,
      next: Si
    };
  }
  var wY = function(t) {
    return t();
  }, B4 = ec.useInsertionEffect ? ec.useInsertionEffect : !1, U4 = B4 || wY, OP = B4 || T.useLayoutEffect, V4 = /* @__PURE__ */ T.createContext(
    // we're doing this to avoid preconstruct's dead code elimination in this one case
    // because this module is primarily intended for the browser and node
    // but it's also required in react native and similar environments sometimes
    // and we could have a special build just for that
    // but this is much easier and the native packages
    // might use a different theme context in the future anyway
    typeof HTMLElement < "u" ? /* @__PURE__ */ fY({
      key: "css"
    }) : null
  );
  V4.Provider;
  var fk = function(t) {
    return /* @__PURE__ */ T.forwardRef(function(n, r) {
      var o = T.useContext(V4);
      return t(n, o, r);
    });
  }, Mh = /* @__PURE__ */ T.createContext({}), dk = {}.hasOwnProperty, iE = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", SY = function(t, n) {
    var r = {};
    for (var o in n)
      dk.call(n, o) && (r[o] = n[o]);
    return r[iE] = t, r;
  }, _Y = function(t) {
    var n = t.cache, r = t.serialized, o = t.isStringTag;
    return ck(n, r, o), U4(function() {
      return uk(n, r, o);
    }), null;
  }, EY = /* @__PURE__ */ fk(function(e, t, n) {
    var r = e.css;
    typeof r == "string" && t.registered[r] !== void 0 && (r = t.registered[r]);
    var o = e[iE], i = [r], a = "";
    typeof e.className == "string" ? a = L4(t.registered, i, e.className) : e.className != null && (a = e.className + " ");
    var s = Nh(i, void 0, T.useContext(Mh));
    a += t.key + "-" + s.name;
    var l = {};
    for (var u in e)
      dk.call(e, u) && u !== "css" && u !== iE && (l[u] = e[u]);
    return l.className = a, n && (l.ref = n), /* @__PURE__ */ T.createElement(T.Fragment, null, /* @__PURE__ */ T.createElement(_Y, {
      cache: t,
      serialized: s,
      isStringTag: typeof o == "string"
    }), /* @__PURE__ */ T.createElement(o, l));
  }), CY = EY, He = function(t, n) {
    var r = arguments;
    if (n == null || !dk.call(n, "css"))
      return T.createElement.apply(void 0, r);
    var o = r.length, i = new Array(o);
    i[0] = CY, i[1] = SY(t, n);
    for (var a = 2; a < o; a++)
      i[a] = r[a];
    return T.createElement.apply(null, i);
  };
  (function(e) {
    var t;
    t || (t = e.JSX || (e.JSX = {}));
  })(He || (He = {}));
  var kY = /* @__PURE__ */ fk(function(e, t) {
    var n = e.styles, r = Nh([n], void 0, T.useContext(Mh)), o = T.useRef();
    return OP(function() {
      var i = t.key + "-global", a = new t.sheet.constructor({
        key: i,
        nonce: t.sheet.nonce,
        container: t.sheet.container,
        speedy: t.sheet.isSpeedy
      }), s = !1, l = document.querySelector('style[data-emotion="' + i + " " + r.name + '"]');
      return t.sheet.tags.length && (a.before = t.sheet.tags[0]), l !== null && (s = !0, l.setAttribute("data-emotion", i), a.hydrate([l])), o.current = [a, s], function() {
        a.flush();
      };
    }, [t]), OP(function() {
      var i = o.current, a = i[0], s = i[1];
      if (s) {
        i[1] = !1;
        return;
      }
      if (r.next !== void 0 && uk(t, r.next, !0), a.tags.length) {
        var l = a.tags[a.tags.length - 1].nextElementSibling;
        a.before = l, a.flush();
      }
      t.insert("", r, a, !1);
    }, [t, r.name]), null;
  });
  function Ph() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return Nh(t);
  }
  function _f() {
    var e = Ph.apply(void 0, arguments), t = "animation-" + e.name;
    return {
      name: t,
      styles: "@keyframes " + t + "{" + e.styles + "}",
      anim: 1,
      toString: function() {
        return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
      }
    };
  }
  var TY = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, RY = /* @__PURE__ */ D4(
    function(e) {
      return TY.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
    }
    /* Z+1 */
  ), OY = RY, AY = function(t) {
    return t !== "theme";
  }, AP = function(t) {
    return typeof t == "string" && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    t.charCodeAt(0) > 96 ? OY : AY;
  }, NP = function(t, n, r) {
    var o;
    if (n) {
      var i = n.shouldForwardProp;
      o = t.__emotion_forwardProp && i ? function(a) {
        return t.__emotion_forwardProp(a) && i(a);
      } : i;
    }
    return typeof o != "function" && r && (o = t.__emotion_forwardProp), o;
  }, NY = function(t) {
    var n = t.cache, r = t.serialized, o = t.isStringTag;
    return ck(n, r, o), U4(function() {
      return uk(n, r, o);
    }), null;
  }, MY = function e(t, n) {
    var r = t.__emotion_real === t, o = r && t.__emotion_base || t, i, a;
    n !== void 0 && (i = n.label, a = n.target);
    var s = NP(t, n, r), l = s || AP(o), u = !l("as");
    return function() {
      var d = arguments, p = r && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
      if (i !== void 0 && p.push("label:" + i + ";"), d[0] == null || d[0].raw === void 0)
        p.push.apply(p, d);
      else {
        var h = d[0];
        p.push(h[0]);
        for (var g = d.length, y = 1; y < g; y++)
          p.push(d[y], h[y]);
      }
      var b = fk(function(v, x, E) {
        var _ = u && v.as || o, C = "", k = [], R = v;
        if (v.theme == null) {
          R = {};
          for (var A in v)
            R[A] = v[A];
          R.theme = T.useContext(Mh);
        }
        typeof v.className == "string" ? C = L4(x.registered, k, v.className) : v.className != null && (C = v.className + " ");
        var M = Nh(p.concat(k), x.registered, R);
        C += x.key + "-" + M.name, a !== void 0 && (C += " " + a);
        var I = u && s === void 0 ? AP(_) : l, D = {};
        for (var L in v)
          u && L === "as" || I(L) && (D[L] = v[L]);
        return D.className = C, E && (D.ref = E), /* @__PURE__ */ T.createElement(T.Fragment, null, /* @__PURE__ */ T.createElement(NY, {
          cache: x,
          serialized: M,
          isStringTag: typeof _ == "string"
        }), /* @__PURE__ */ T.createElement(_, D));
      });
      return b.displayName = i !== void 0 ? i : "Styled(" + (typeof o == "string" ? o : o.displayName || o.name || "Component") + ")", b.defaultProps = t.defaultProps, b.__emotion_real = b, b.__emotion_base = o, b.__emotion_styles = p, b.__emotion_forwardProp = s, Object.defineProperty(b, "toString", {
        value: function() {
          return "." + a;
        }
      }), b.withComponent = function(v, x) {
        var E = e(v, Ge({}, n, x, {
          shouldForwardProp: NP(b, x, !0)
        }));
        return E.apply(void 0, p);
      }, b;
    };
  }, PY = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    // SVG
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan"
  ], aE = MY.bind(null);
  PY.forEach(function(e) {
    aE[e] = aE(e);
  });
  function $Y(e) {
    return e == null || Object.keys(e).length === 0;
  }
  function H4(e) {
    const {
      styles: t,
      defaultTheme: n = {}
    } = e, r = typeof t == "function" ? (o) => t($Y(o) ? n : o) : t;
    return /* @__PURE__ */ S.jsx(kY, {
      styles: r
    });
  }
  function q4(e, t) {
    return aE(e, t);
  }
  function IY(e, t) {
    Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles));
  }
  const MP = [];
  function qs(e) {
    return MP[0] = e, Nh(MP);
  }
  const jY = (e) => {
    const t = Object.keys(e).map((n) => ({
      key: n,
      val: e[n]
    })) || [];
    return t.sort((n, r) => n.val - r.val), t.reduce((n, r) => ({
      ...n,
      [r.key]: r.val
    }), {});
  };
  function DY(e) {
    const {
      // The breakpoint **start** at this value.
      // For instance with the first breakpoint xs: [xs, sm).
      values: t = {
        xs: 0,
        // phone
        sm: 600,
        // tablet
        md: 900,
        // small laptop
        lg: 1200,
        // desktop
        xl: 1536
        // large screen
      },
      unit: n = "px",
      step: r = 5,
      ...o
    } = e, i = jY(t), a = Object.keys(i);
    function s(h) {
      return `@media (min-width:${typeof t[h] == "number" ? t[h] : h}${n})`;
    }
    function l(h) {
      return `@media (max-width:${(typeof t[h] == "number" ? t[h] : h) - r / 100}${n})`;
    }
    function u(h, g) {
      const y = a.indexOf(g);
      return `@media (min-width:${typeof t[h] == "number" ? t[h] : h}${n}) and (max-width:${(y !== -1 && typeof t[a[y]] == "number" ? t[a[y]] : g) - r / 100}${n})`;
    }
    function d(h) {
      return a.indexOf(h) + 1 < a.length ? u(h, a[a.indexOf(h) + 1]) : s(h);
    }
    function p(h) {
      const g = a.indexOf(h);
      return g === 0 ? s(a[1]) : g === a.length - 1 ? l(a[g]) : u(h, a[a.indexOf(h) + 1]).replace("@media", "@media not all and");
    }
    return {
      keys: a,
      values: i,
      up: s,
      down: l,
      between: u,
      only: d,
      not: p,
      unit: n,
      ...o
    };
  }
  const FY = {
    borderRadius: 4
  };
  function W4(e = 8, t = rk({
    spacing: e
  })) {
    if (e.mui)
      return e;
    const n = (...r) => (r.length === 0 ? [1] : r).map((i) => {
      const a = t(i);
      return typeof a == "number" ? `${a}px` : a;
    }).join(" ");
    return n.mui = !0, n;
  }
  function LY(e, t) {
    const n = this;
    if (n.vars) {
      if (!n.colorSchemes?.[e] || typeof n.getColorSchemeSelector != "function")
        return {};
      let r = n.getColorSchemeSelector(e);
      return r === "&" ? t : ((r.includes("data-") || r.includes(".")) && (r = `*:where(${r.replace(/\s*&$/, "")}) &`), {
        [r]: t
      });
    }
    return n.palette.mode === e ? t : {};
  }
  function Q0(e = {}, ...t) {
    const {
      breakpoints: n = {},
      palette: r = {},
      spacing: o,
      shape: i = {},
      ...a
    } = e, s = DY(n), l = W4(o);
    let u = vr({
      breakpoints: s,
      direction: "ltr",
      components: {},
      // Inject component definitions.
      palette: {
        mode: "light",
        ...r
      },
      spacing: l,
      shape: {
        ...FY,
        ...i
      }
    }, a);
    return u = KG(u), u.applyStyles = LY, u = t.reduce((d, p) => vr(d, p), u), u.unstable_sxConfig = {
      ...Oh,
      ...a?.unstable_sxConfig
    }, u.unstable_sx = function(p) {
      return Xs({
        sx: p,
        theme: this
      });
    }, u;
  }
  function zY(e) {
    return Object.keys(e).length === 0;
  }
  function pk(e = null) {
    const t = T.useContext(Mh);
    return !t || zY(t) ? e : t;
  }
  const BY = Q0();
  function $h(e = BY) {
    return pk(e);
  }
  function nS(e) {
    const t = qs(e);
    return e !== t && t.styles ? (t.styles.match(/^@layer\s+[^{]*$/) || (t.styles = `@layer global{${t.styles}}`), t) : e;
  }
  function G4({
    styles: e,
    themeId: t,
    defaultTheme: n = {}
  }) {
    const r = $h(n), o = t && r[t] || r;
    let i = typeof e == "function" ? e(o) : e;
    return o.modularCssLayers && (Array.isArray(i) ? i = i.map((a) => nS(typeof a == "function" ? a(o) : a)) : i = nS(i)), /* @__PURE__ */ S.jsx(H4, {
      styles: i
    });
  }
  const PP = (e) => e, UY = () => {
    let e = PP;
    return {
      configure(t) {
        e = t;
      },
      generate(t) {
        return e(t);
      },
      reset() {
        e = PP;
      }
    };
  }, K4 = UY();
  function VY(e = {}) {
    const {
      themeId: t,
      defaultTheme: n,
      defaultClassName: r = "MuiBox-root",
      generateClassName: o
    } = e, i = q4("div", {
      shouldForwardProp: (s) => s !== "theme" && s !== "sx" && s !== "as"
    })(Xs);
    return /* @__PURE__ */ T.forwardRef(function(l, u) {
      const d = $h(n), {
        className: p,
        component: h = "div",
        ...g
      } = ik(l);
      return /* @__PURE__ */ S.jsx(i, {
        as: h,
        ref: u,
        className: je(p, o ? o(r) : r),
        theme: t && d[t] || d,
        ...g
      });
    });
  }
  const HY = {
    active: "active",
    checked: "checked",
    completed: "completed",
    disabled: "disabled",
    error: "error",
    expanded: "expanded",
    focused: "focused",
    focusVisible: "focusVisible",
    open: "open",
    readOnly: "readOnly",
    required: "required",
    selected: "selected"
  };
  function it(e, t, n = "Mui") {
    const r = HY[t];
    return r ? `${n}-${r}` : `${K4.generate(e)}-${t}`;
  }
  function rt(e, t, n = "Mui") {
    const r = {};
    return t.forEach((o) => {
      r[o] = it(e, o, n);
    }), r;
  }
  function Y4(e) {
    const {
      variants: t,
      ...n
    } = e, r = {
      variants: t,
      style: qs(n),
      isProcessed: !0
    };
    return r.style === n || t && t.forEach((o) => {
      typeof o.style != "function" && (o.style = qs(o.style));
    }), r;
  }
  const qY = Q0();
  function rS(e) {
    return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
  }
  function Wl(e, t) {
    return t && e && typeof e == "object" && e.styles && !e.styles.startsWith("@layer") && (e.styles = `@layer ${t}{${String(e.styles)}}`), e;
  }
  function WY(e) {
    return e ? (t, n) => n[e] : null;
  }
  function GY(e, t, n) {
    e.theme = YY(e.theme) ? n : e.theme[t] || e.theme;
  }
  function fv(e, t, n) {
    const r = typeof t == "function" ? t(e) : t;
    if (Array.isArray(r))
      return r.flatMap((o) => fv(e, o, n));
    if (Array.isArray(r?.variants)) {
      let o;
      if (r.isProcessed)
        o = n ? Wl(r.style, n) : r.style;
      else {
        const {
          variants: i,
          ...a
        } = r;
        o = n ? Wl(qs(a), n) : a;
      }
      return X4(e, r.variants, [o], n);
    }
    return r?.isProcessed ? n ? Wl(qs(r.style), n) : r.style : n ? Wl(qs(r), n) : r;
  }
  function X4(e, t, n = [], r = void 0) {
    let o;
    e: for (let i = 0; i < t.length; i += 1) {
      const a = t[i];
      if (typeof a.props == "function") {
        if (o ?? (o = {
          ...e,
          ...e.ownerState,
          ownerState: e.ownerState
        }), !a.props(o))
          continue;
      } else
        for (const s in a.props)
          if (e[s] !== a.props[s] && e.ownerState?.[s] !== a.props[s])
            continue e;
      typeof a.style == "function" ? (o ?? (o = {
        ...e,
        ...e.ownerState,
        ownerState: e.ownerState
      }), n.push(r ? Wl(qs(a.style(o)), r) : a.style(o))) : n.push(r ? Wl(qs(a.style), r) : a.style);
    }
    return n;
  }
  function Z4(e = {}) {
    const {
      themeId: t,
      defaultTheme: n = qY,
      rootShouldForwardProp: r = rS,
      slotShouldForwardProp: o = rS
    } = e;
    function i(s) {
      GY(s, t, n);
    }
    return (s, l = {}) => {
      IY(s, (R) => R.filter((A) => A !== Xs));
      const {
        name: u,
        slot: d,
        skipVariantsResolver: p,
        skipSx: h,
        // TODO v6: remove `lowercaseFirstLetter()` in the next major release
        // For more details: https://github.com/mui/material-ui/pull/37908
        overridesResolver: g = WY(ZY(d)),
        ...y
      } = l, b = u && u.startsWith("Mui") || d ? "components" : "custom", v = p !== void 0 ? p : (
        // TODO v6: remove `Root` in the next major release
        // For more details: https://github.com/mui/material-ui/pull/37908
        d && d !== "Root" && d !== "root" || !1
      ), x = h || !1;
      let E = rS;
      d === "Root" || d === "root" ? E = r : d ? E = o : XY(s) && (E = void 0);
      const _ = q4(s, {
        shouldForwardProp: E,
        label: KY(),
        ...y
      }), C = (R) => {
        if (R.__emotion_real === R)
          return R;
        if (typeof R == "function")
          return function(M) {
            return fv(M, R, M.theme.modularCssLayers ? b : void 0);
          };
        if (ki(R)) {
          const A = Y4(R);
          return function(I) {
            return A.variants ? fv(I, A, I.theme.modularCssLayers ? b : void 0) : I.theme.modularCssLayers ? Wl(A.style, b) : A.style;
          };
        }
        return R;
      }, k = (...R) => {
        const A = [], M = R.map(C), I = [];
        if (A.push(i), u && g && I.push(function(B) {
          const V = B.theme.components?.[u]?.styleOverrides;
          if (!V)
            return null;
          const F = {};
          for (const G in V)
            F[G] = fv(B, V[G], B.theme.modularCssLayers ? "theme" : void 0);
          return g(B, F);
        }), u && !v && I.push(function(B) {
          const V = B.theme?.components?.[u]?.variants;
          return V ? X4(B, V, [], B.theme.modularCssLayers ? "theme" : void 0) : null;
        }), x || I.push(Xs), Array.isArray(M[0])) {
          const P = M.shift(), B = new Array(A.length).fill(""), j = new Array(I.length).fill("");
          let V;
          V = [...B, ...P, ...j], V.raw = [...B, ...P.raw, ...j], A.unshift(V);
        }
        const D = [...A, ...M, ...I], L = _(...D);
        return s.muiName && (L.muiName = s.muiName), L;
      };
      return _.withConfig && (k.withConfig = _.withConfig), k;
    };
  }
  function KY(e, t) {
    return void 0;
  }
  function YY(e) {
    for (const t in e)
      return !1;
    return !0;
  }
  function XY(e) {
    return typeof e == "string" && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    e.charCodeAt(0) > 96;
  }
  function ZY(e) {
    return e && e.charAt(0).toLowerCase() + e.slice(1);
  }
  const QY = Z4();
  function qp(e, t, n = !1) {
    const r = {
      ...t
    };
    for (const o in e)
      if (Object.prototype.hasOwnProperty.call(e, o)) {
        const i = o;
        if (i === "components" || i === "slots")
          r[i] = {
            ...e[i],
            ...r[i]
          };
        else if (i === "componentsProps" || i === "slotProps") {
          const a = e[i], s = t[i];
          if (!s)
            r[i] = a || {};
          else if (!a)
            r[i] = s;
          else {
            r[i] = {
              ...s
            };
            for (const l in a)
              if (Object.prototype.hasOwnProperty.call(a, l)) {
                const u = l;
                r[i][u] = qp(a[u], s[u], n);
              }
          }
        } else i === "className" && n && t.className ? r.className = je(e?.className, t?.className) : i === "style" && n && t.style ? r.style = {
          ...e?.style,
          ...t?.style
        } : r[i] === void 0 && (r[i] = e[i]);
      }
    return r;
  }
  function JY(e) {
    const {
      theme: t,
      name: n,
      props: r
    } = e;
    return !t || !t.components || !t.components[n] || !t.components[n].defaultProps ? r : qp(t.components[n].defaultProps, r);
  }
  function eX({
    props: e,
    name: t,
    defaultTheme: n,
    themeId: r
  }) {
    let o = $h(n);
    return r && (o = o[r] || o), JY({
      theme: o,
      name: t,
      props: e
    });
  }
  const Ko = typeof window < "u" ? T.useLayoutEffect : T.useEffect;
  function Nu(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
    return Math.max(t, Math.min(e, n));
  }
  function hk(e, t = 0, n = 1) {
    return Nu(e, t, n);
  }
  function tX(e) {
    e = e.slice(1);
    const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, "g");
    let n = e.match(t);
    return n && n[0].length === 1 && (n = n.map((r) => r + r)), n ? `rgb${n.length === 4 ? "a" : ""}(${n.map((r, o) => o < 3 ? parseInt(r, 16) : Math.round(parseInt(r, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
  }
  function Zs(e) {
    if (e.type)
      return e;
    if (e.charAt(0) === "#")
      return Zs(tX(e));
    const t = e.indexOf("("), n = e.substring(0, t);
    if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(n))
      throw new Error(ja(9, e));
    let r = e.substring(t + 1, e.length - 1), o;
    if (n === "color") {
      if (r = r.split(" "), o = r.shift(), r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)), !["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(o))
        throw new Error(ja(10, o));
    } else
      r = r.split(",");
    return r = r.map((i) => parseFloat(i)), {
      type: n,
      values: r,
      colorSpace: o
    };
  }
  const nX = (e) => {
    const t = Zs(e);
    return t.values.slice(0, 3).map((n, r) => t.type.includes("hsl") && r !== 0 ? `${n}%` : n).join(" ");
  }, fp = (e, t) => {
    try {
      return nX(e);
    } catch {
      return e;
    }
  };
  function J0(e) {
    const {
      type: t,
      colorSpace: n
    } = e;
    let {
      values: r
    } = e;
    return t.includes("rgb") ? r = r.map((o, i) => i < 3 ? parseInt(o, 10) : o) : t.includes("hsl") && (r[1] = `${r[1]}%`, r[2] = `${r[2]}%`), t.includes("color") ? r = `${n} ${r.join(" ")}` : r = `${r.join(", ")}`, `${t}(${r})`;
  }
  function Q4(e) {
    e = Zs(e);
    const {
      values: t
    } = e, n = t[0], r = t[1] / 100, o = t[2] / 100, i = r * Math.min(o, 1 - o), a = (u, d = (u + n / 30) % 12) => o - i * Math.max(Math.min(d - 3, 9 - d, 1), -1);
    let s = "rgb";
    const l = [Math.round(a(0) * 255), Math.round(a(8) * 255), Math.round(a(4) * 255)];
    return e.type === "hsla" && (s += "a", l.push(t[3])), J0({
      type: s,
      values: l
    });
  }
  function sE(e) {
    e = Zs(e);
    let t = e.type === "hsl" || e.type === "hsla" ? Zs(Q4(e)).values : e.values;
    return t = t.map((n) => (e.type !== "color" && (n /= 255), n <= 0.03928 ? n / 12.92 : ((n + 0.055) / 1.055) ** 2.4)), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3));
  }
  function rX(e, t) {
    const n = sE(e), r = sE(t);
    return (Math.max(n, r) + 0.05) / (Math.min(n, r) + 0.05);
  }
  function Fv(e, t) {
    return e = Zs(e), t = hk(t), (e.type === "rgb" || e.type === "hsl") && (e.type += "a"), e.type === "color" ? e.values[3] = `/${t}` : e.values[3] = t, J0(e);
  }
  function Ml(e, t, n) {
    try {
      return Fv(e, t);
    } catch {
      return e;
    }
  }
  function eb(e, t) {
    if (e = Zs(e), t = hk(t), e.type.includes("hsl"))
      e.values[2] *= 1 - t;
    else if (e.type.includes("rgb") || e.type.includes("color"))
      for (let n = 0; n < 3; n += 1)
        e.values[n] *= 1 - t;
    return J0(e);
  }
  function Gt(e, t, n) {
    try {
      return eb(e, t);
    } catch {
      return e;
    }
  }
  function tb(e, t) {
    if (e = Zs(e), t = hk(t), e.type.includes("hsl"))
      e.values[2] += (100 - e.values[2]) * t;
    else if (e.type.includes("rgb"))
      for (let n = 0; n < 3; n += 1)
        e.values[n] += (255 - e.values[n]) * t;
    else if (e.type.includes("color"))
      for (let n = 0; n < 3; n += 1)
        e.values[n] += (1 - e.values[n]) * t;
    return J0(e);
  }
  function Kt(e, t, n) {
    try {
      return tb(e, t);
    } catch {
      return e;
    }
  }
  function oX(e, t = 0.15) {
    return sE(e) > 0.5 ? eb(e, t) : tb(e, t);
  }
  function $g(e, t, n) {
    try {
      return oX(e, t);
    } catch {
      return e;
    }
  }
  const J4 = /* @__PURE__ */ T.createContext(null);
  function mk() {
    return T.useContext(J4);
  }
  const iX = typeof Symbol == "function" && Symbol.for, aX = iX ? Symbol.for("mui.nested") : "__THEME_NESTED__";
  function sX(e, t) {
    return typeof t == "function" ? t(e) : {
      ...e,
      ...t
    };
  }
  function lX(e) {
    const {
      children: t,
      theme: n
    } = e, r = mk(), o = T.useMemo(() => {
      const i = r === null ? {
        ...n
      } : sX(r, n);
      return i != null && (i[aX] = r !== null), i;
    }, [n, r]);
    return /* @__PURE__ */ S.jsx(J4.Provider, {
      value: o,
      children: t
    });
  }
  const eF = /* @__PURE__ */ T.createContext();
  function cX({
    value: e,
    ...t
  }) {
    return /* @__PURE__ */ S.jsx(eF.Provider, {
      value: e ?? !0,
      ...t
    });
  }
  const tF = () => T.useContext(eF) ?? !1, nF = /* @__PURE__ */ T.createContext(void 0);
  function uX({
    value: e,
    children: t
  }) {
    return /* @__PURE__ */ S.jsx(nF.Provider, {
      value: e,
      children: t
    });
  }
  function fX(e) {
    const {
      theme: t,
      name: n,
      props: r
    } = e;
    if (!t || !t.components || !t.components[n])
      return r;
    const o = t.components[n];
    return o.defaultProps ? qp(o.defaultProps, r, t.components.mergeClassNameAndStyle) : !o.styleOverrides && !o.variants ? qp(o, r, t.components.mergeClassNameAndStyle) : r;
  }
  function dX({
    props: e,
    name: t
  }) {
    const n = T.useContext(nF);
    return fX({
      props: e,
      name: t,
      theme: {
        components: n
      }
    });
  }
  let $P = 0;
  function pX(e) {
    const [t, n] = T.useState(e), r = e || t;
    return T.useEffect(() => {
      t == null && ($P += 1, n(`mui-${$P}`));
    }, [t]), r;
  }
  const hX = {
    ...ec
  }, IP = hX.useId;
  function Ef(e) {
    if (IP !== void 0) {
      const t = IP();
      return e ?? t;
    }
    return pX(e);
  }
  function mX(e) {
    const t = pk(), n = Ef() || "", {
      modularCssLayers: r
    } = e;
    let o = "mui.global, mui.components, mui.theme, mui.custom, mui.sx";
    return !r || t !== null ? o = "" : typeof r == "string" ? o = r.replace(/mui(?!\.)/g, o) : o = `@layer ${o};`, Ko(() => {
      const i = document.querySelector("head");
      if (!i)
        return;
      const a = i.firstChild;
      if (o) {
        if (a && a.hasAttribute?.("data-mui-layer-order") && a.getAttribute("data-mui-layer-order") === n)
          return;
        const s = document.createElement("style");
        s.setAttribute("data-mui-layer-order", n), s.textContent = o, i.prepend(s);
      } else
        i.querySelector(`style[data-mui-layer-order="${n}"]`)?.remove();
    }, [o, n]), o ? /* @__PURE__ */ S.jsx(G4, {
      styles: o
    }) : null;
  }
  const jP = {};
  function DP(e, t, n, r = !1) {
    return T.useMemo(() => {
      const o = e && t[e] || t;
      if (typeof n == "function") {
        const i = n(o), a = e ? {
          ...t,
          [e]: i
        } : i;
        return r ? () => a : a;
      }
      return e ? {
        ...t,
        [e]: n
      } : {
        ...t,
        ...n
      };
    }, [e, t, n, r]);
  }
  function rF(e) {
    const {
      children: t,
      theme: n,
      themeId: r
    } = e, o = pk(jP), i = mk() || jP, a = DP(r, o, n), s = DP(r, i, n, !0), l = (r ? a[r] : a).direction === "rtl", u = mX(a);
    return /* @__PURE__ */ S.jsx(lX, {
      theme: s,
      children: /* @__PURE__ */ S.jsx(Mh.Provider, {
        value: a,
        children: /* @__PURE__ */ S.jsx(cX, {
          value: l,
          children: /* @__PURE__ */ S.jsxs(uX, {
            value: r ? a[r].components : a.components,
            children: [u, t]
          })
        })
      })
    });
  }
  const FP = {
    theme: void 0
  };
  function gX(e) {
    let t, n;
    return function(o) {
      let i = t;
      return (i === void 0 || o.theme !== n) && (FP.theme = o.theme, i = Y4(e(FP)), t = i, n = o.theme), i;
    };
  }
  const gk = "mode", yk = "color-scheme", yX = "data-color-scheme";
  function vX(e) {
    const {
      defaultMode: t = "system",
      defaultLightColorScheme: n = "light",
      defaultDarkColorScheme: r = "dark",
      modeStorageKey: o = gk,
      colorSchemeStorageKey: i = yk,
      attribute: a = yX,
      colorSchemeNode: s = "document.documentElement",
      nonce: l
    } = e || {};
    let u = "", d = a;
    if (a === "class" && (d = ".%s"), a === "data" && (d = "[data-%s]"), d.startsWith(".")) {
      const h = d.substring(1);
      u += `${s}.classList.remove('${h}'.replace('%s', light), '${h}'.replace('%s', dark));
      ${s}.classList.add('${h}'.replace('%s', colorScheme));`;
    }
    const p = d.match(/\[([^[\]]+)\]/);
    if (p) {
      const [h, g] = p[1].split("=");
      g || (u += `${s}.removeAttribute('${h}'.replace('%s', light));
      ${s}.removeAttribute('${h}'.replace('%s', dark));`), u += `
      ${s}.setAttribute('${h}'.replace('%s', colorScheme), ${g ? `${g}.replace('%s', colorScheme)` : '""'});`;
    } else
      u += `${s}.setAttribute('${d}', colorScheme);`;
    return /* @__PURE__ */ S.jsx("script", {
      suppressHydrationWarning: !0,
      nonce: typeof window > "u" ? l : "",
      dangerouslySetInnerHTML: {
        __html: `(function() {
try {
  let colorScheme = '';
  const mode = localStorage.getItem('${o}') || '${t}';
  const dark = localStorage.getItem('${i}-dark') || '${r}';
  const light = localStorage.getItem('${i}-light') || '${n}';
  if (mode === 'system') {
    // handle system mode
    const mql = window.matchMedia('(prefers-color-scheme: dark)');
    if (mql.matches) {
      colorScheme = dark
    } else {
      colorScheme = light
    }
  }
  if (mode === 'light') {
    colorScheme = light;
  }
  if (mode === 'dark') {
    colorScheme = dark;
  }
  if (colorScheme) {
    ${u}
  }
} catch(e){}})();`
      }
    }, "mui-color-scheme-init");
  }
  function bX() {
  }
  const xX = ({
    key: e,
    storageWindow: t
  }) => (!t && typeof window < "u" && (t = window), {
    get(n) {
      if (typeof window > "u")
        return;
      if (!t)
        return n;
      let r;
      try {
        r = t.localStorage.getItem(e);
      } catch {
      }
      return r || n;
    },
    set: (n) => {
      if (t)
        try {
          t.localStorage.setItem(e, n);
        } catch {
        }
    },
    subscribe: (n) => {
      if (!t)
        return bX;
      const r = (o) => {
        const i = o.newValue;
        o.key === e && n(i);
      };
      return t.addEventListener("storage", r), () => {
        t.removeEventListener("storage", r);
      };
    }
  });
  function oS() {
  }
  function LP(e) {
    if (typeof window < "u" && typeof window.matchMedia == "function" && e === "system")
      return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
  }
  function oF(e, t) {
    if (e.mode === "light" || e.mode === "system" && e.systemMode === "light")
      return t("light");
    if (e.mode === "dark" || e.mode === "system" && e.systemMode === "dark")
      return t("dark");
  }
  function wX(e) {
    return oF(e, (t) => {
      if (t === "light")
        return e.lightColorScheme;
      if (t === "dark")
        return e.darkColorScheme;
    });
  }
  function SX(e) {
    const {
      defaultMode: t = "light",
      defaultLightColorScheme: n,
      defaultDarkColorScheme: r,
      supportedColorSchemes: o = [],
      modeStorageKey: i = gk,
      colorSchemeStorageKey: a = yk,
      storageWindow: s = typeof window > "u" ? void 0 : window,
      storageManager: l = xX,
      noSsr: u = !1
    } = e, d = o.join(","), p = o.length > 1, h = T.useMemo(() => l?.({
      key: i,
      storageWindow: s
    }), [l, i, s]), g = T.useMemo(() => l?.({
      key: `${a}-light`,
      storageWindow: s
    }), [l, a, s]), y = T.useMemo(() => l?.({
      key: `${a}-dark`,
      storageWindow: s
    }), [l, a, s]), [b, v] = T.useState(() => {
      const M = h?.get(t) || t, I = g?.get(n) || n, D = y?.get(r) || r;
      return {
        mode: M,
        systemMode: LP(M),
        lightColorScheme: I,
        darkColorScheme: D
      };
    }), [x, E] = T.useState(u || !p);
    T.useEffect(() => {
      E(!0);
    }, []);
    const _ = wX(b), C = T.useCallback((M) => {
      v((I) => {
        if (M === I.mode)
          return I;
        const D = M ?? t;
        return h?.set(D), {
          ...I,
          mode: D,
          systemMode: LP(D)
        };
      });
    }, [h, t]), k = T.useCallback((M) => {
      M ? typeof M == "string" ? M && !d.includes(M) ? console.error(`\`${M}\` does not exist in \`theme.colorSchemes\`.`) : v((I) => {
        const D = {
          ...I
        };
        return oF(I, (L) => {
          L === "light" && (g?.set(M), D.lightColorScheme = M), L === "dark" && (y?.set(M), D.darkColorScheme = M);
        }), D;
      }) : v((I) => {
        const D = {
          ...I
        }, L = M.light === null ? n : M.light, P = M.dark === null ? r : M.dark;
        return L && (d.includes(L) ? (D.lightColorScheme = L, g?.set(L)) : console.error(`\`${L}\` does not exist in \`theme.colorSchemes\`.`)), P && (d.includes(P) ? (D.darkColorScheme = P, y?.set(P)) : console.error(`\`${P}\` does not exist in \`theme.colorSchemes\`.`)), D;
      }) : v((I) => (g?.set(n), y?.set(r), {
        ...I,
        lightColorScheme: n,
        darkColorScheme: r
      }));
    }, [d, g, y, n, r]), R = T.useCallback((M) => {
      b.mode === "system" && v((I) => {
        const D = M?.matches ? "dark" : "light";
        return I.systemMode === D ? I : {
          ...I,
          systemMode: D
        };
      });
    }, [b.mode]), A = T.useRef(R);
    return A.current = R, T.useEffect(() => {
      if (typeof window.matchMedia != "function" || !p)
        return;
      const M = (...D) => A.current(...D), I = window.matchMedia("(prefers-color-scheme: dark)");
      return I.addListener(M), M(I), () => {
        I.removeListener(M);
      };
    }, [p]), T.useEffect(() => {
      if (p) {
        const M = h?.subscribe((L) => {
          (!L || ["light", "dark", "system"].includes(L)) && C(L || t);
        }) || oS, I = g?.subscribe((L) => {
          (!L || d.match(L)) && k({
            light: L
          });
        }) || oS, D = y?.subscribe((L) => {
          (!L || d.match(L)) && k({
            dark: L
          });
        }) || oS;
        return () => {
          M(), I(), D();
        };
      }
    }, [k, C, d, t, s, p, h, g, y]), {
      ...b,
      mode: x ? b.mode : void 0,
      systemMode: x ? b.systemMode : void 0,
      colorScheme: x ? _ : void 0,
      setMode: C,
      setColorScheme: k
    };
  }
  const _X = "*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
  function EX(e) {
    const {
      themeId: t,
      /**
       * This `theme` object needs to follow a certain structure to
       * be used correctly by the finel `CssVarsProvider`. It should have a
       * `colorSchemes` key with the light and dark (and any other) palette.
       * It should also ideally have a vars object created using `prepareCssVars`.
       */
      theme: n = {},
      modeStorageKey: r = gk,
      colorSchemeStorageKey: o = yk,
      disableTransitionOnChange: i = !1,
      defaultColorScheme: a,
      resolveTheme: s
    } = e, l = {
      allColorSchemes: [],
      colorScheme: void 0,
      darkColorScheme: void 0,
      lightColorScheme: void 0,
      mode: void 0,
      setColorScheme: () => {
      },
      setMode: () => {
      },
      systemMode: void 0
    }, u = /* @__PURE__ */ T.createContext(void 0), d = () => T.useContext(u) || l, p = {}, h = {};
    function g(x) {
      const {
        children: E,
        theme: _,
        modeStorageKey: C = r,
        colorSchemeStorageKey: k = o,
        disableTransitionOnChange: R = i,
        storageManager: A,
        storageWindow: M = typeof window > "u" ? void 0 : window,
        documentNode: I = typeof document > "u" ? void 0 : document,
        colorSchemeNode: D = typeof document > "u" ? void 0 : document.documentElement,
        disableNestedContext: L = !1,
        disableStyleSheetGeneration: P = !1,
        defaultMode: B = "system",
        forceThemeRerender: j = !1,
        noSsr: V
      } = x, F = T.useRef(!1), G = mk(), W = T.useContext(u), K = !!W && !L, $ = T.useMemo(() => _ || (typeof n == "function" ? n() : n), [_]), U = $[t], X = U || $, {
        colorSchemes: z = p,
        components: H = h,
        cssVarPrefix: Y
      } = X, Q = Object.keys(z).filter((oe) => !!z[oe]).join(","), re = T.useMemo(() => Q.split(","), [Q]), te = typeof a == "string" ? a : a.light, le = typeof a == "string" ? a : a.dark, fe = z[te] && z[le] ? B : z[X.defaultColorScheme]?.palette?.mode || X.palette?.mode, {
        mode: J,
        setMode: ee,
        systemMode: ie,
        lightColorScheme: ae,
        darkColorScheme: ge,
        colorScheme: Ce,
        setColorScheme: Ne
      } = SX({
        supportedColorSchemes: re,
        defaultLightColorScheme: te,
        defaultDarkColorScheme: le,
        modeStorageKey: C,
        colorSchemeStorageKey: k,
        defaultMode: fe,
        storageManager: A,
        storageWindow: M,
        noSsr: V
      });
      let Le = J, Ve = Ce;
      K && (Le = W.mode, Ve = W.colorScheme);
      let Ke = Ve || X.defaultColorScheme;
      X.vars && !j && (Ke = X.defaultColorScheme);
      const ze = T.useMemo(() => {
        const oe = X.generateThemeVars?.() || X.vars, ue = {
          ...X,
          components: H,
          colorSchemes: z,
          cssVarPrefix: Y,
          vars: oe
        };
        if (typeof ue.generateSpacing == "function" && (ue.spacing = ue.generateSpacing()), Ke) {
          const Se = z[Ke];
          Se && typeof Se == "object" && Object.keys(Se).forEach((_e) => {
            Se[_e] && typeof Se[_e] == "object" ? ue[_e] = {
              ...ue[_e],
              ...Se[_e]
            } : ue[_e] = Se[_e];
          });
        }
        return s ? s(ue) : ue;
      }, [X, Ke, H, z, Y]), Me = X.colorSchemeSelector;
      Ko(() => {
        if (Ve && D && Me && Me !== "media") {
          const oe = Me;
          let ue = Me;
          if (oe === "class" && (ue = ".%s"), oe === "data" && (ue = "[data-%s]"), oe?.startsWith("data-") && !oe.includes("%s") && (ue = `[${oe}="%s"]`), ue.startsWith("."))
            D.classList.remove(...re.map((Se) => ue.substring(1).replace("%s", Se))), D.classList.add(ue.substring(1).replace("%s", Ve));
          else {
            const Se = ue.replace("%s", Ve).match(/\[([^\]]+)\]/);
            if (Se) {
              const [_e, Ae] = Se[1].split("=");
              Ae || re.forEach((Ue) => {
                D.removeAttribute(_e.replace(Ve, Ue));
              }), D.setAttribute(_e, Ae ? Ae.replace(/"|'/g, "") : "");
            } else
              D.setAttribute(ue, Ve);
          }
        }
      }, [Ve, Me, D, re]), T.useEffect(() => {
        let oe;
        if (R && F.current && I) {
          const ue = I.createElement("style");
          ue.appendChild(I.createTextNode(_X)), I.head.appendChild(ue), window.getComputedStyle(I.body), oe = setTimeout(() => {
            I.head.removeChild(ue);
          }, 1);
        }
        return () => {
          clearTimeout(oe);
        };
      }, [Ve, R, I]), T.useEffect(() => (F.current = !0, () => {
        F.current = !1;
      }), []);
      const ct = T.useMemo(() => ({
        allColorSchemes: re,
        colorScheme: Ve,
        darkColorScheme: ge,
        lightColorScheme: ae,
        mode: Le,
        setColorScheme: Ne,
        setMode: ee,
        systemMode: ie
      }), [re, Ve, ge, ae, Le, Ne, ee, ie, ze.colorSchemeSelector]);
      let wt = !0;
      (P || X.cssVariables === !1 || K && G?.cssVarPrefix === Y) && (wt = !1);
      const Re = /* @__PURE__ */ S.jsxs(T.Fragment, {
        children: [/* @__PURE__ */ S.jsx(rF, {
          themeId: U ? t : void 0,
          theme: ze,
          children: E
        }), wt && /* @__PURE__ */ S.jsx(H4, {
          styles: ze.generateStyleSheets?.() || []
        })]
      });
      return K ? Re : /* @__PURE__ */ S.jsx(u.Provider, {
        value: ct,
        children: Re
      });
    }
    const y = typeof a == "string" ? a : a.light, b = typeof a == "string" ? a : a.dark;
    return {
      CssVarsProvider: g,
      useColorScheme: d,
      getInitColorSchemeScript: (x) => vX({
        colorSchemeStorageKey: o,
        defaultLightColorScheme: y,
        defaultDarkColorScheme: b,
        modeStorageKey: r,
        ...x
      })
    };
  }
  function CX(e = "") {
    function t(...r) {
      if (!r.length)
        return "";
      const o = r[0];
      return typeof o == "string" && !o.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/) ? `, var(--${e ? `${e}-` : ""}${o}${t(...r.slice(1))})` : `, ${o}`;
    }
    return (r, ...o) => `var(--${e ? `${e}-` : ""}${r}${t(...o)})`;
  }
  const zP = (e, t, n, r = []) => {
    let o = e;
    t.forEach((i, a) => {
      a === t.length - 1 ? Array.isArray(o) ? o[Number(i)] = n : o && typeof o == "object" && (o[i] = n) : o && typeof o == "object" && (o[i] || (o[i] = r.includes(i) ? [] : {}), o = o[i]);
    });
  }, kX = (e, t, n) => {
    function r(o, i = [], a = []) {
      Object.entries(o).forEach(([s, l]) => {
        (!n || n && !n([...i, s])) && l != null && (typeof l == "object" && Object.keys(l).length > 0 ? r(l, [...i, s], Array.isArray(l) ? [...a, s] : a) : t([...i, s], l, a));
      });
    }
    r(e);
  }, TX = (e, t) => typeof t == "number" ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((r) => e.includes(r)) || e[e.length - 1].toLowerCase().includes("opacity") ? t : `${t}px` : t;
  function iS(e, t) {
    const {
      prefix: n,
      shouldSkipGeneratingVar: r
    } = t || {}, o = {}, i = {}, a = {};
    return kX(
      e,
      (s, l, u) => {
        if ((typeof l == "string" || typeof l == "number") && (!r || !r(s, l))) {
          const d = `--${n ? `${n}-` : ""}${s.join("-")}`, p = TX(s, l);
          Object.assign(o, {
            [d]: p
          }), zP(i, s, `var(${d})`, u), zP(a, s, `var(${d}, ${p})`, u);
        }
      },
      (s) => s[0] === "vars"
      // skip 'vars/*' paths
    ), {
      css: o,
      vars: i,
      varsWithDefaults: a
    };
  }
  function RX(e, t = {}) {
    const {
      getSelector: n = x,
      disableCssColorScheme: r,
      colorSchemeSelector: o,
      enableContrastVars: i
    } = t, {
      colorSchemes: a = {},
      components: s,
      defaultColorScheme: l = "light",
      ...u
    } = e, {
      vars: d,
      css: p,
      varsWithDefaults: h
    } = iS(u, t);
    let g = h;
    const y = {}, {
      [l]: b,
      ...v
    } = a;
    if (Object.entries(v || {}).forEach(([C, k]) => {
      const {
        vars: R,
        css: A,
        varsWithDefaults: M
      } = iS(k, t);
      g = vr(g, M), y[C] = {
        css: A,
        vars: R
      };
    }), b) {
      const {
        css: C,
        vars: k,
        varsWithDefaults: R
      } = iS(b, t);
      g = vr(g, R), y[l] = {
        css: C,
        vars: k
      };
    }
    function x(C, k) {
      let R = o;
      if (o === "class" && (R = ".%s"), o === "data" && (R = "[data-%s]"), o?.startsWith("data-") && !o.includes("%s") && (R = `[${o}="%s"]`), C) {
        if (R === "media")
          return e.defaultColorScheme === C ? ":root" : {
            [`@media (prefers-color-scheme: ${a[C]?.palette?.mode || C})`]: {
              ":root": k
            }
          };
        if (R)
          return e.defaultColorScheme === C ? `:root, ${R.replace("%s", String(C))}` : R.replace("%s", String(C));
      }
      return ":root";
    }
    return {
      vars: g,
      generateThemeVars: () => {
        let C = {
          ...d
        };
        return Object.entries(y).forEach(([, {
          vars: k
        }]) => {
          C = vr(C, k);
        }), C;
      },
      generateStyleSheets: () => {
        const C = [], k = e.defaultColorScheme || "light";
        function R(I, D) {
          Object.keys(D).length && C.push(typeof I == "string" ? {
            [I]: {
              ...D
            }
          } : I);
        }
        R(n(void 0, {
          ...p
        }), p);
        const {
          [k]: A,
          ...M
        } = y;
        if (A) {
          const {
            css: I
          } = A, D = a[k]?.palette?.mode, L = !r && D ? {
            colorScheme: D,
            ...I
          } : {
            ...I
          };
          R(n(k, {
            ...L
          }), L);
        }
        return Object.entries(M).forEach(([I, {
          css: D
        }]) => {
          const L = a[I]?.palette?.mode, P = !r && L ? {
            colorScheme: L,
            ...D
          } : {
            ...D
          };
          R(n(I, {
            ...P
          }), P);
        }), i && C.push({
          ":root": {
            // use double underscore to indicate that these are private variables
            "--__l-threshold": "0.7",
            "--__l": "clamp(0, (l / var(--__l-threshold) - 1) * -infinity, 1)",
            "--__a": "clamp(0.87, (l / var(--__l-threshold) - 1) * -infinity, 1)"
            // 0.87 is the default alpha value for black text.
          }
        }), C;
      }
    };
  }
  function OX(e) {
    return function(n) {
      return e === "media" ? `@media (prefers-color-scheme: ${n})` : e ? e.startsWith("data-") && !e.includes("%s") ? `[${e}="${n}"] &` : e === "class" ? `.${n} &` : e === "data" ? `[data-${n}] &` : `${e.replace("%s", n)} &` : "&";
    };
  }
  function Ep(e, t) {
    return /* @__PURE__ */ T.isValidElement(e) && t.indexOf(
      // For server components `muiName` is available in element.type._payload.value.muiName
      // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
      // eslint-disable-next-line no-underscore-dangle
      e.type.muiName ?? e.type?._payload?.value?.muiName
    ) !== -1;
  }
  const AX = (e, t) => e.filter((n) => t.includes(n)), Cf = (e, t, n) => {
    const r = e.keys[0];
    Array.isArray(t) ? t.forEach((o, i) => {
      n((a, s) => {
        i <= e.keys.length - 1 && (i === 0 ? Object.assign(a, s) : a[e.up(e.keys[i])] = s);
      }, o);
    }) : t && typeof t == "object" ? (Object.keys(t).length > e.keys.length ? e.keys : AX(e.keys, Object.keys(t))).forEach((i) => {
      if (e.keys.includes(i)) {
        const a = t[i];
        a !== void 0 && n((s, l) => {
          r === i ? Object.assign(s, l) : s[e.up(i)] = l;
        }, a);
      }
    }) : (typeof t == "number" || typeof t == "string") && n((o, i) => {
      Object.assign(o, i);
    }, t);
  };
  function Lv(e) {
    return `--Grid-${e}Spacing`;
  }
  function nb(e) {
    return `--Grid-parent-${e}Spacing`;
  }
  const BP = "--Grid-columns", Hu = "--Grid-parent-columns", NX = ({
    theme: e,
    ownerState: t
  }) => {
    const n = {};
    return Cf(e.breakpoints, t.size, (r, o) => {
      let i = {};
      o === "grow" && (i = {
        flexBasis: 0,
        flexGrow: 1,
        maxWidth: "100%"
      }), o === "auto" && (i = {
        flexBasis: "auto",
        flexGrow: 0,
        flexShrink: 0,
        maxWidth: "none",
        width: "auto"
      }), typeof o == "number" && (i = {
        flexGrow: 0,
        flexBasis: "auto",
        width: `calc(100% * ${o} / var(${Hu}) - (var(${Hu}) - ${o}) * (var(${nb("column")}) / var(${Hu})))`
      }), r(n, i);
    }), n;
  }, MX = ({
    theme: e,
    ownerState: t
  }) => {
    const n = {};
    return Cf(e.breakpoints, t.offset, (r, o) => {
      let i = {};
      o === "auto" && (i = {
        marginLeft: "auto"
      }), typeof o == "number" && (i = {
        marginLeft: o === 0 ? "0px" : `calc(100% * ${o} / var(${Hu}) + var(${nb("column")}) * ${o} / var(${Hu}))`
      }), r(n, i);
    }), n;
  }, PX = ({
    theme: e,
    ownerState: t
  }) => {
    if (!t.container)
      return {};
    const n = {
      [BP]: 12
    };
    return Cf(e.breakpoints, t.columns, (r, o) => {
      const i = o ?? 12;
      r(n, {
        [BP]: i,
        "> *": {
          [Hu]: i
        }
      });
    }), n;
  }, $X = ({
    theme: e,
    ownerState: t
  }) => {
    if (!t.container)
      return {};
    const n = {};
    return Cf(e.breakpoints, t.rowSpacing, (r, o) => {
      const i = typeof o == "string" ? o : e.spacing?.(o);
      r(n, {
        [Lv("row")]: i,
        "> *": {
          [nb("row")]: i
        }
      });
    }), n;
  }, IX = ({
    theme: e,
    ownerState: t
  }) => {
    if (!t.container)
      return {};
    const n = {};
    return Cf(e.breakpoints, t.columnSpacing, (r, o) => {
      const i = typeof o == "string" ? o : e.spacing?.(o);
      r(n, {
        [Lv("column")]: i,
        "> *": {
          [nb("column")]: i
        }
      });
    }), n;
  }, jX = ({
    theme: e,
    ownerState: t
  }) => {
    if (!t.container)
      return {};
    const n = {};
    return Cf(e.breakpoints, t.direction, (r, o) => {
      r(n, {
        flexDirection: o
      });
    }), n;
  }, DX = ({
    ownerState: e
  }) => ({
    minWidth: 0,
    boxSizing: "border-box",
    ...e.container && {
      display: "flex",
      flexWrap: "wrap",
      ...e.wrap && e.wrap !== "wrap" && {
        flexWrap: e.wrap
      },
      gap: `var(${Lv("row")}) var(${Lv("column")})`
    }
  }), FX = (e) => {
    const t = [];
    return Object.entries(e).forEach(([n, r]) => {
      r !== !1 && r !== void 0 && t.push(`grid-${n}-${String(r)}`);
    }), t;
  }, LX = (e, t = "xs") => {
    function n(r) {
      return r === void 0 ? !1 : typeof r == "string" && !Number.isNaN(Number(r)) || typeof r == "number" && r > 0;
    }
    if (n(e))
      return [`spacing-${t}-${String(e)}`];
    if (typeof e == "object" && !Array.isArray(e)) {
      const r = [];
      return Object.entries(e).forEach(([o, i]) => {
        n(i) && r.push(`spacing-${o}-${String(i)}`);
      }), r;
    }
    return [];
  }, zX = (e) => e === void 0 ? [] : typeof e == "object" ? Object.entries(e).map(([t, n]) => `direction-${t}-${n}`) : [`direction-xs-${String(e)}`];
  function BX(e, t) {
    e.item !== void 0 && delete e.item, e.zeroMinWidth !== void 0 && delete e.zeroMinWidth, t.keys.forEach((n) => {
      e[n] !== void 0 && delete e[n];
    });
  }
  const UX = Q0(), VX = QY("div", {
    name: "MuiGrid",
    slot: "Root"
  });
  function HX(e) {
    return eX({
      props: e,
      name: "MuiGrid",
      defaultTheme: UX
    });
  }
  function qX(e = {}) {
    const {
      // This will allow adding custom styled fn (for example for custom sx style function)
      createStyledComponent: t = VX,
      useThemeProps: n = HX,
      useTheme: r = $h,
      componentName: o = "MuiGrid"
    } = e, i = (u, d) => {
      const {
        container: p,
        direction: h,
        spacing: g,
        wrap: y,
        size: b
      } = u, v = {
        root: ["root", p && "container", y !== "wrap" && `wrap-xs-${String(y)}`, ...zX(h), ...FX(b), ...p ? LX(g, d.breakpoints.keys[0]) : []]
      };
      return ot(v, (x) => it(o, x), {});
    };
    function a(u, d, p = () => !0) {
      const h = {};
      return u === null || (Array.isArray(u) ? u.forEach((g, y) => {
        g !== null && p(g) && d.keys[y] && (h[d.keys[y]] = g);
      }) : typeof u == "object" ? Object.keys(u).forEach((g) => {
        const y = u[g];
        y != null && p(y) && (h[g] = y);
      }) : h[d.keys[0]] = u), h;
    }
    const s = t(PX, IX, $X, NX, jX, DX, MX), l = /* @__PURE__ */ T.forwardRef(function(d, p) {
      const h = r(), g = n(d), y = ik(g);
      BX(y, h.breakpoints);
      const {
        className: b,
        children: v,
        columns: x = 12,
        container: E = !1,
        component: _ = "div",
        direction: C = "row",
        wrap: k = "wrap",
        size: R = {},
        offset: A = {},
        spacing: M = 0,
        rowSpacing: I = M,
        columnSpacing: D = M,
        unstable_level: L = 0,
        ...P
      } = y, B = a(R, h.breakpoints, (U) => U !== !1), j = a(A, h.breakpoints), V = d.columns ?? (L ? void 0 : x), F = d.spacing ?? (L ? void 0 : M), G = d.rowSpacing ?? d.spacing ?? (L ? void 0 : I), W = d.columnSpacing ?? d.spacing ?? (L ? void 0 : D), K = {
        ...y,
        level: L,
        columns: V,
        container: E,
        direction: C,
        wrap: k,
        spacing: F,
        rowSpacing: G,
        columnSpacing: W,
        size: B,
        offset: j
      }, $ = i(K, h);
      return /* @__PURE__ */ S.jsx(s, {
        ref: p,
        as: _,
        ownerState: K,
        className: je($.root, b),
        ...P,
        children: T.Children.map(v, (U) => /* @__PURE__ */ T.isValidElement(U) && Ep(U, ["Grid"]) && E && U.props.container ? /* @__PURE__ */ T.cloneElement(U, {
          unstable_level: U.props?.unstable_level ?? L + 1
        }) : U)
      });
    });
    return l.muiName = "Grid", l;
  }
  const Wp = {
    black: "#000",
    white: "#fff"
  }, WX = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#eeeeee",
    300: "#e0e0e0",
    400: "#bdbdbd",
    500: "#9e9e9e",
    600: "#757575",
    700: "#616161",
    800: "#424242",
    900: "#212121",
    A100: "#f5f5f5",
    A200: "#eeeeee",
    A400: "#bdbdbd",
    A700: "#616161"
  }, du = {
    50: "#f3e5f5",
    200: "#ce93d8",
    300: "#ba68c8",
    400: "#ab47bc",
    500: "#9c27b0",
    700: "#7b1fa2"
  }, pu = {
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    700: "#d32f2f",
    800: "#c62828"
  }, Hd = {
    300: "#ffb74d",
    400: "#ffa726",
    500: "#ff9800",
    700: "#f57c00",
    900: "#e65100"
  }, hu = {
    50: "#e3f2fd",
    200: "#90caf9",
    400: "#42a5f5",
    700: "#1976d2",
    800: "#1565c0"
  }, mu = {
    300: "#4fc3f7",
    400: "#29b6f6",
    500: "#03a9f4",
    700: "#0288d1",
    900: "#01579b"
  }, gu = {
    300: "#81c784",
    400: "#66bb6a",
    500: "#4caf50",
    700: "#388e3c",
    800: "#2e7d32",
    900: "#1b5e20"
  };
  function iF() {
    return {
      // The colors used to style the text.
      text: {
        // The most important text.
        primary: "rgba(0, 0, 0, 0.87)",
        // Secondary text.
        secondary: "rgba(0, 0, 0, 0.6)",
        // Disabled text have even lower visual prominence.
        disabled: "rgba(0, 0, 0, 0.38)"
      },
      // The color used to divide different elements.
      divider: "rgba(0, 0, 0, 0.12)",
      // The background colors used to style the surfaces.
      // Consistency between these values is important.
      background: {
        paper: Wp.white,
        default: Wp.white
      },
      // The colors used to style the action elements.
      action: {
        // The color of an active action like an icon button.
        active: "rgba(0, 0, 0, 0.54)",
        // The color of an hovered action.
        hover: "rgba(0, 0, 0, 0.04)",
        hoverOpacity: 0.04,
        // The color of a selected action.
        selected: "rgba(0, 0, 0, 0.08)",
        selectedOpacity: 0.08,
        // The color of a disabled action.
        disabled: "rgba(0, 0, 0, 0.26)",
        // The background color of a disabled action.
        disabledBackground: "rgba(0, 0, 0, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(0, 0, 0, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.12
      }
    };
  }
  const aF = iF();
  function sF() {
    return {
      text: {
        primary: Wp.white,
        secondary: "rgba(255, 255, 255, 0.7)",
        disabled: "rgba(255, 255, 255, 0.5)",
        icon: "rgba(255, 255, 255, 0.5)"
      },
      divider: "rgba(255, 255, 255, 0.12)",
      background: {
        paper: "#121212",
        default: "#121212"
      },
      action: {
        active: Wp.white,
        hover: "rgba(255, 255, 255, 0.08)",
        hoverOpacity: 0.08,
        selected: "rgba(255, 255, 255, 0.16)",
        selectedOpacity: 0.16,
        disabled: "rgba(255, 255, 255, 0.3)",
        disabledBackground: "rgba(255, 255, 255, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(255, 255, 255, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.24
      }
    };
  }
  const lE = sF();
  function UP(e, t, n, r) {
    const o = r.light || r, i = r.dark || r * 1.5;
    e[t] || (e.hasOwnProperty(n) ? e[t] = e[n] : t === "light" ? e.light = tb(e.main, o) : t === "dark" && (e.dark = eb(e.main, i)));
  }
  function VP(e, t, n, r, o) {
    const i = o.light || o, a = o.dark || o * 1.5;
    t[n] || (t.hasOwnProperty(r) ? t[n] = t[r] : n === "light" ? t.light = `color-mix(in ${e}, ${t.main}, #fff ${(i * 100).toFixed(0)}%)` : n === "dark" && (t.dark = `color-mix(in ${e}, ${t.main}, #000 ${(a * 100).toFixed(0)}%)`));
  }
  function GX(e = "light") {
    return e === "dark" ? {
      main: hu[200],
      light: hu[50],
      dark: hu[400]
    } : {
      main: hu[700],
      light: hu[400],
      dark: hu[800]
    };
  }
  function KX(e = "light") {
    return e === "dark" ? {
      main: du[200],
      light: du[50],
      dark: du[400]
    } : {
      main: du[500],
      light: du[300],
      dark: du[700]
    };
  }
  function YX(e = "light") {
    return e === "dark" ? {
      main: pu[500],
      light: pu[300],
      dark: pu[700]
    } : {
      main: pu[700],
      light: pu[400],
      dark: pu[800]
    };
  }
  function XX(e = "light") {
    return e === "dark" ? {
      main: mu[400],
      light: mu[300],
      dark: mu[700]
    } : {
      main: mu[700],
      light: mu[500],
      dark: mu[900]
    };
  }
  function ZX(e = "light") {
    return e === "dark" ? {
      main: gu[400],
      light: gu[300],
      dark: gu[700]
    } : {
      main: gu[800],
      light: gu[500],
      dark: gu[900]
    };
  }
  function QX(e = "light") {
    return e === "dark" ? {
      main: Hd[400],
      light: Hd[300],
      dark: Hd[700]
    } : {
      main: "#ed6c02",
      // closest to orange[800] that pass 3:1.
      light: Hd[500],
      dark: Hd[900]
    };
  }
  function JX(e) {
    return `oklch(from ${e} var(--__l) 0 h / var(--__a))`;
  }
  function vk(e) {
    const {
      mode: t = "light",
      contrastThreshold: n = 3,
      tonalOffset: r = 0.2,
      colorSpace: o,
      ...i
    } = e, a = e.primary || GX(t), s = e.secondary || KX(t), l = e.error || YX(t), u = e.info || XX(t), d = e.success || ZX(t), p = e.warning || QX(t);
    function h(v) {
      return o ? JX(v) : rX(v, lE.text.primary) >= n ? lE.text.primary : aF.text.primary;
    }
    const g = ({
      color: v,
      name: x,
      mainShade: E = 500,
      lightShade: _ = 300,
      darkShade: C = 700
    }) => {
      if (v = {
        ...v
      }, !v.main && v[E] && (v.main = v[E]), !v.hasOwnProperty("main"))
        throw new Error(ja(11, x ? ` (${x})` : "", E));
      if (typeof v.main != "string")
        throw new Error(ja(12, x ? ` (${x})` : "", JSON.stringify(v.main)));
      return o ? (VP(o, v, "light", _, r), VP(o, v, "dark", C, r)) : (UP(v, "light", _, r), UP(v, "dark", C, r)), v.contrastText || (v.contrastText = h(v.main)), v;
    };
    let y;
    return t === "light" ? y = iF() : t === "dark" && (y = sF()), vr({
      // A collection of common colors.
      common: {
        ...Wp
      },
      // prevent mutable object.
      // The palette mode, can be light or dark.
      mode: t,
      // The colors used to represent primary interface elements for a user.
      primary: g({
        color: a,
        name: "primary"
      }),
      // The colors used to represent secondary interface elements for a user.
      secondary: g({
        color: s,
        name: "secondary",
        mainShade: "A400",
        lightShade: "A200",
        darkShade: "A700"
      }),
      // The colors used to represent interface elements that the user should be made aware of.
      error: g({
        color: l,
        name: "error"
      }),
      // The colors used to represent potentially dangerous actions or important messages.
      warning: g({
        color: p,
        name: "warning"
      }),
      // The colors used to present information to the user that is neutral and not necessarily important.
      info: g({
        color: u,
        name: "info"
      }),
      // The colors used to indicate the successful completion of an action that user triggered.
      success: g({
        color: d,
        name: "success"
      }),
      // The grey colors.
      grey: WX,
      // Used by `getContrastText()` to maximize the contrast between
      // the background and the text.
      contrastThreshold: n,
      // Takes a background color and returns the text color that maximizes the contrast.
      getContrastText: h,
      // Generate a rich color object.
      augmentColor: g,
      // Used by the functions below to shift a color's luminance by approximately
      // two indexes within its tonal palette.
      // E.g., shift from Red 500 to Red 300 or Red 700.
      tonalOffset: r,
      // The light and dark mode object.
      ...y
    }, i);
  }
  function eZ(e) {
    const t = {};
    return Object.entries(e).forEach((r) => {
      const [o, i] = r;
      typeof i == "object" && (t[o] = `${i.fontStyle ? `${i.fontStyle} ` : ""}${i.fontVariant ? `${i.fontVariant} ` : ""}${i.fontWeight ? `${i.fontWeight} ` : ""}${i.fontStretch ? `${i.fontStretch} ` : ""}${i.fontSize || ""}${i.lineHeight ? `/${i.lineHeight} ` : ""}${i.fontFamily || ""}`);
    }), t;
  }
  function tZ(e, t) {
    return {
      toolbar: {
        minHeight: 56,
        [e.up("xs")]: {
          "@media (orientation: landscape)": {
            minHeight: 48
          }
        },
        [e.up("sm")]: {
          minHeight: 64
        }
      },
      ...t
    };
  }
  function nZ(e) {
    return Math.round(e * 1e5) / 1e5;
  }
  const HP = {
    textTransform: "uppercase"
  }, qP = '"Roboto", "Helvetica", "Arial", sans-serif';
  function lF(e, t) {
    const {
      fontFamily: n = qP,
      // The default font size of the Material Specification.
      fontSize: r = 14,
      // px
      fontWeightLight: o = 300,
      fontWeightRegular: i = 400,
      fontWeightMedium: a = 500,
      fontWeightBold: s = 700,
      // Tell MUI what's the font-size on the html element.
      // 16px is the default font-size used by browsers.
      htmlFontSize: l = 16,
      // Apply the CSS properties to all the variants.
      allVariants: u,
      pxToRem: d,
      ...p
    } = typeof t == "function" ? t(e) : t, h = r / 14, g = d || ((v) => `${v / l * h}rem`), y = (v, x, E, _, C) => ({
      fontFamily: n,
      fontWeight: v,
      fontSize: g(x),
      // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
      lineHeight: E,
      // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
      // across font-families can cause issues with the kerning.
      ...n === qP ? {
        letterSpacing: `${nZ(_ / x)}em`
      } : {},
      ...C,
      ...u
    }), b = {
      h1: y(o, 96, 1.167, -1.5),
      h2: y(o, 60, 1.2, -0.5),
      h3: y(i, 48, 1.167, 0),
      h4: y(i, 34, 1.235, 0.25),
      h5: y(i, 24, 1.334, 0),
      h6: y(a, 20, 1.6, 0.15),
      subtitle1: y(i, 16, 1.75, 0.15),
      subtitle2: y(a, 14, 1.57, 0.1),
      body1: y(i, 16, 1.5, 0.15),
      body2: y(i, 14, 1.43, 0.15),
      button: y(a, 14, 1.75, 0.4, HP),
      caption: y(i, 12, 1.66, 0.4),
      overline: y(i, 12, 2.66, 1, HP),
      // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
      inherit: {
        fontFamily: "inherit",
        fontWeight: "inherit",
        fontSize: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit"
      }
    };
    return vr({
      htmlFontSize: l,
      pxToRem: g,
      fontFamily: n,
      fontSize: r,
      fontWeightLight: o,
      fontWeightRegular: i,
      fontWeightMedium: a,
      fontWeightBold: s,
      ...b
    }, p, {
      clone: !1
      // No need to clone deep
    });
  }
  const rZ = 0.2, oZ = 0.14, iZ = 0.12;
  function yn(...e) {
    return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${rZ})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${oZ})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${iZ})`].join(",");
  }
  const aZ = ["none", yn(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), yn(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), yn(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), yn(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), yn(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), yn(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), yn(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), yn(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), yn(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), yn(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), yn(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), yn(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), yn(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), yn(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), yn(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), yn(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), yn(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), yn(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), yn(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), yn(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), yn(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), yn(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), yn(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), yn(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], sZ = {
    // This is the most common easing curve.
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    // Objects enter the screen at full velocity from off-screen and
    // slowly decelerate to a resting point.
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    // Objects leave the screen at full velocity. They do not decelerate when off-screen.
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    // The sharp curve is used by objects that may return to the screen at any time.
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
  }, lZ = {
    shortest: 150,
    shorter: 200,
    short: 250,
    // most basic recommended timing
    standard: 300,
    // this is to be used in complex animations
    complex: 375,
    // recommended when something is entering screen
    enteringScreen: 225,
    // recommended when something is leaving screen
    leavingScreen: 195
  };
  function WP(e) {
    return `${Math.round(e)}ms`;
  }
  function cZ(e) {
    if (!e)
      return 0;
    const t = e / 36;
    return Math.min(Math.round((4 + 15 * t ** 0.25 + t / 5) * 10), 3e3);
  }
  function uZ(e) {
    const t = {
      ...sZ,
      ...e.easing
    }, n = {
      ...lZ,
      ...e.duration
    };
    return {
      getAutoHeightDuration: cZ,
      create: (o = ["all"], i = {}) => {
        const {
          duration: a = n.standard,
          easing: s = t.easeInOut,
          delay: l = 0,
          ...u
        } = i;
        return (Array.isArray(o) ? o : [o]).map((d) => `${d} ${typeof a == "string" ? a : WP(a)} ${s} ${typeof l == "string" ? l : WP(l)}`).join(",");
      },
      ...e,
      easing: t,
      duration: n
    };
  }
  const fZ = {
    mobileStepper: 1e3,
    fab: 1050,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500
  };
  function dZ(e) {
    return ki(e) || typeof e > "u" || typeof e == "string" || typeof e == "boolean" || typeof e == "number" || Array.isArray(e);
  }
  function cF(e = {}) {
    const t = {
      ...e
    };
    function n(r) {
      const o = Object.entries(r);
      for (let i = 0; i < o.length; i++) {
        const [a, s] = o[i];
        !dZ(s) || a.startsWith("unstable_") ? delete r[a] : ki(s) && (r[a] = {
          ...s
        }, n(r[a]));
      }
    }
    return n(t), `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(t, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
  }
  function GP(e) {
    return typeof e == "number" ? `${(e * 100).toFixed(0)}%` : `calc((${e}) * 100%)`;
  }
  const pZ = (e) => {
    if (!Number.isNaN(+e))
      return +e;
    const t = e.match(/\d*\.?\d+/g);
    if (!t)
      return 0;
    let n = 0;
    for (let r = 0; r < t.length; r += 1)
      n += +t[r];
    return n;
  };
  function hZ(e) {
    Object.assign(e, {
      alpha(t, n) {
        const r = this || e;
        return r.colorSpace ? `oklch(from ${t} l c h / ${typeof n == "string" ? `calc(${n})` : n})` : r.vars ? `rgba(${t.replace(/var\(--([^,\s)]+)(?:,[^)]+)?\)+/g, "var(--$1Channel)")} / ${typeof n == "string" ? `calc(${n})` : n})` : Fv(t, pZ(n));
      },
      lighten(t, n) {
        const r = this || e;
        return r.colorSpace ? `color-mix(in ${r.colorSpace}, ${t}, #fff ${GP(n)})` : tb(t, n);
      },
      darken(t, n) {
        const r = this || e;
        return r.colorSpace ? `color-mix(in ${r.colorSpace}, ${t}, #000 ${GP(n)})` : eb(t, n);
      }
    });
  }
  function cE(e = {}, ...t) {
    const {
      breakpoints: n,
      mixins: r = {},
      spacing: o,
      palette: i = {},
      transitions: a = {},
      typography: s = {},
      shape: l,
      colorSpace: u,
      ...d
    } = e;
    if (e.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
    // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
    e.generateThemeVars === void 0)
      throw new Error(ja(20));
    const p = vk({
      ...i,
      colorSpace: u
    }), h = Q0(e);
    let g = vr(h, {
      mixins: tZ(h.breakpoints, r),
      palette: p,
      // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
      shadows: aZ.slice(),
      typography: lF(p, s),
      transitions: uZ(a),
      zIndex: {
        ...fZ
      }
    });
    return g = vr(g, d), g = t.reduce((y, b) => vr(y, b), g), g.unstable_sxConfig = {
      ...Oh,
      ...d?.unstable_sxConfig
    }, g.unstable_sx = function(b) {
      return Xs({
        sx: b,
        theme: this
      });
    }, g.toRuntimeSource = cF, hZ(g), g;
  }
  function uE(e) {
    let t;
    return e < 1 ? t = 5.11916 * e ** 2 : t = 4.5 * Math.log(e + 1) + 2, Math.round(t * 10) / 1e3;
  }
  const mZ = [...Array(25)].map((e, t) => {
    if (t === 0)
      return "none";
    const n = uE(t);
    return `linear-gradient(rgba(255 255 255 / ${n}), rgba(255 255 255 / ${n}))`;
  });
  function uF(e) {
    return {
      inputPlaceholder: e === "dark" ? 0.5 : 0.42,
      inputUnderline: e === "dark" ? 0.7 : 0.42,
      switchTrackDisabled: e === "dark" ? 0.2 : 0.12,
      switchTrack: e === "dark" ? 0.3 : 0.38
    };
  }
  function fF(e) {
    return e === "dark" ? mZ : [];
  }
  function gZ(e) {
    const {
      palette: t = {
        mode: "light"
      },
      // need to cast to avoid module augmentation test
      opacity: n,
      overlays: r,
      colorSpace: o,
      ...i
    } = e, a = vk({
      ...t,
      colorSpace: o
    });
    return {
      palette: a,
      opacity: {
        ...uF(a.mode),
        ...n
      },
      overlays: r || fF(a.mode),
      ...i
    };
  }
  function yZ(e) {
    return !!e[0].match(/(cssVarPrefix|colorSchemeSelector|modularCssLayers|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!e[0].match(/sxConfig$/) || // ends with sxConfig
    e[0] === "palette" && !!e[1]?.match(/(mode|contrastThreshold|tonalOffset)/);
  }
  const vZ = (e) => [...[...Array(25)].map((t, n) => `--${e ? `${e}-` : ""}overlays-${n}`), `--${e ? `${e}-` : ""}palette-AppBar-darkBg`, `--${e ? `${e}-` : ""}palette-AppBar-darkColor`], bZ = (e) => (t, n) => {
    const r = e.rootSelector || ":root", o = e.colorSchemeSelector;
    let i = o;
    if (o === "class" && (i = ".%s"), o === "data" && (i = "[data-%s]"), o?.startsWith("data-") && !o.includes("%s") && (i = `[${o}="%s"]`), e.defaultColorScheme === t) {
      if (t === "dark") {
        const a = {};
        return vZ(e.cssVarPrefix).forEach((s) => {
          a[s] = n[s], delete n[s];
        }), i === "media" ? {
          [r]: n,
          "@media (prefers-color-scheme: dark)": {
            [r]: a
          }
        } : i ? {
          [i.replace("%s", t)]: a,
          [`${r}, ${i.replace("%s", t)}`]: n
        } : {
          [r]: {
            ...n,
            ...a
          }
        };
      }
      if (i && i !== "media")
        return `${r}, ${i.replace("%s", String(t))}`;
    } else if (t) {
      if (i === "media")
        return {
          [`@media (prefers-color-scheme: ${String(t)})`]: {
            [r]: n
          }
        };
      if (i)
        return i.replace("%s", String(t));
    }
    return r;
  };
  function xZ(e, t) {
    t.forEach((n) => {
      e[n] || (e[n] = {});
    });
  }
  function ve(e, t, n) {
    !e[t] && n && (e[t] = n);
  }
  function dp(e) {
    return typeof e != "string" || !e.startsWith("hsl") ? e : Q4(e);
  }
  function xa(e, t) {
    `${t}Channel` in e || (e[`${t}Channel`] = fp(dp(e[t])));
  }
  function wZ(e) {
    return typeof e == "number" ? `${e}px` : typeof e == "string" || typeof e == "function" || Array.isArray(e) ? e : "8px";
  }
  const di = (e) => {
    try {
      return e();
    } catch {
    }
  }, SZ = (e = "mui") => CX(e);
  function aS(e, t, n, r, o) {
    if (!n)
      return;
    n = n === !0 ? {} : n;
    const i = o === "dark" ? "dark" : "light";
    if (!r) {
      t[o] = gZ({
        ...n,
        palette: {
          mode: i,
          ...n?.palette
        },
        colorSpace: e
      });
      return;
    }
    const {
      palette: a,
      ...s
    } = cE({
      ...r,
      palette: {
        mode: i,
        ...n?.palette
      },
      colorSpace: e
    });
    return t[o] = {
      ...n,
      palette: a,
      opacity: {
        ...uF(i),
        ...n?.opacity
      },
      overlays: n?.overlays || fF(i)
    }, s;
  }
  function _Z(e = {}, ...t) {
    const {
      colorSchemes: n = {
        light: !0
      },
      defaultColorScheme: r,
      disableCssColorScheme: o = !1,
      cssVarPrefix: i = "mui",
      nativeColor: a = !1,
      shouldSkipGeneratingVar: s = yZ,
      colorSchemeSelector: l = n.light && n.dark ? "media" : void 0,
      rootSelector: u = ":root",
      ...d
    } = e, p = Object.keys(n)[0], h = r || (n.light && p !== "light" ? "light" : p), g = SZ(i), {
      [h]: y,
      light: b,
      dark: v,
      ...x
    } = n, E = {
      ...x
    };
    let _ = y;
    if ((h === "dark" && !("dark" in n) || h === "light" && !("light" in n)) && (_ = !0), !_)
      throw new Error(ja(21, h));
    let C;
    a && (C = "oklch");
    const k = aS(C, E, _, d, h);
    b && !E.light && aS(C, E, b, void 0, "light"), v && !E.dark && aS(C, E, v, void 0, "dark");
    let R = {
      defaultColorScheme: h,
      ...k,
      cssVarPrefix: i,
      colorSchemeSelector: l,
      rootSelector: u,
      getCssVar: g,
      colorSchemes: E,
      font: {
        ...eZ(k.typography),
        ...k.font
      },
      spacing: wZ(d.spacing)
    };
    Object.keys(R.colorSchemes).forEach((L) => {
      const P = R.colorSchemes[L].palette, B = (V) => {
        const F = V.split("-"), G = F[1], W = F[2];
        return g(V, P[G][W]);
      };
      P.mode === "light" && (ve(P.common, "background", "#fff"), ve(P.common, "onBackground", "#000")), P.mode === "dark" && (ve(P.common, "background", "#000"), ve(P.common, "onBackground", "#fff"));
      function j(V, F, G) {
        if (C) {
          let W;
          return V === Ml && (W = `transparent ${((1 - G) * 100).toFixed(0)}%`), V === Gt && (W = `#000 ${(G * 100).toFixed(0)}%`), V === Kt && (W = `#fff ${(G * 100).toFixed(0)}%`), `color-mix(in ${C}, ${F}, ${W})`;
        }
        return V(F, G);
      }
      if (xZ(P, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]), P.mode === "light") {
        ve(P.Alert, "errorColor", j(Gt, P.error.light, 0.6)), ve(P.Alert, "infoColor", j(Gt, P.info.light, 0.6)), ve(P.Alert, "successColor", j(Gt, P.success.light, 0.6)), ve(P.Alert, "warningColor", j(Gt, P.warning.light, 0.6)), ve(P.Alert, "errorFilledBg", B("palette-error-main")), ve(P.Alert, "infoFilledBg", B("palette-info-main")), ve(P.Alert, "successFilledBg", B("palette-success-main")), ve(P.Alert, "warningFilledBg", B("palette-warning-main")), ve(P.Alert, "errorFilledColor", di(() => P.getContrastText(P.error.main))), ve(P.Alert, "infoFilledColor", di(() => P.getContrastText(P.info.main))), ve(P.Alert, "successFilledColor", di(() => P.getContrastText(P.success.main))), ve(P.Alert, "warningFilledColor", di(() => P.getContrastText(P.warning.main))), ve(P.Alert, "errorStandardBg", j(Kt, P.error.light, 0.9)), ve(P.Alert, "infoStandardBg", j(Kt, P.info.light, 0.9)), ve(P.Alert, "successStandardBg", j(Kt, P.success.light, 0.9)), ve(P.Alert, "warningStandardBg", j(Kt, P.warning.light, 0.9)), ve(P.Alert, "errorIconColor", B("palette-error-main")), ve(P.Alert, "infoIconColor", B("palette-info-main")), ve(P.Alert, "successIconColor", B("palette-success-main")), ve(P.Alert, "warningIconColor", B("palette-warning-main")), ve(P.AppBar, "defaultBg", B("palette-grey-100")), ve(P.Avatar, "defaultBg", B("palette-grey-400")), ve(P.Button, "inheritContainedBg", B("palette-grey-300")), ve(P.Button, "inheritContainedHoverBg", B("palette-grey-A100")), ve(P.Chip, "defaultBorder", B("palette-grey-400")), ve(P.Chip, "defaultAvatarColor", B("palette-grey-700")), ve(P.Chip, "defaultIconColor", B("palette-grey-700")), ve(P.FilledInput, "bg", "rgba(0, 0, 0, 0.06)"), ve(P.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)"), ve(P.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)"), ve(P.LinearProgress, "primaryBg", j(Kt, P.primary.main, 0.62)), ve(P.LinearProgress, "secondaryBg", j(Kt, P.secondary.main, 0.62)), ve(P.LinearProgress, "errorBg", j(Kt, P.error.main, 0.62)), ve(P.LinearProgress, "infoBg", j(Kt, P.info.main, 0.62)), ve(P.LinearProgress, "successBg", j(Kt, P.success.main, 0.62)), ve(P.LinearProgress, "warningBg", j(Kt, P.warning.main, 0.62)), ve(P.Skeleton, "bg", C ? j(Ml, P.text.primary, 0.11) : `rgba(${B("palette-text-primaryChannel")} / 0.11)`), ve(P.Slider, "primaryTrack", j(Kt, P.primary.main, 0.62)), ve(P.Slider, "secondaryTrack", j(Kt, P.secondary.main, 0.62)), ve(P.Slider, "errorTrack", j(Kt, P.error.main, 0.62)), ve(P.Slider, "infoTrack", j(Kt, P.info.main, 0.62)), ve(P.Slider, "successTrack", j(Kt, P.success.main, 0.62)), ve(P.Slider, "warningTrack", j(Kt, P.warning.main, 0.62));
        const V = C ? j(Gt, P.background.default, 0.6825) : $g(P.background.default, 0.8);
        ve(P.SnackbarContent, "bg", V), ve(P.SnackbarContent, "color", di(() => C ? lE.text.primary : P.getContrastText(V))), ve(P.SpeedDialAction, "fabHoverBg", $g(P.background.paper, 0.15)), ve(P.StepConnector, "border", B("palette-grey-400")), ve(P.StepContent, "border", B("palette-grey-400")), ve(P.Switch, "defaultColor", B("palette-common-white")), ve(P.Switch, "defaultDisabledColor", B("palette-grey-100")), ve(P.Switch, "primaryDisabledColor", j(Kt, P.primary.main, 0.62)), ve(P.Switch, "secondaryDisabledColor", j(Kt, P.secondary.main, 0.62)), ve(P.Switch, "errorDisabledColor", j(Kt, P.error.main, 0.62)), ve(P.Switch, "infoDisabledColor", j(Kt, P.info.main, 0.62)), ve(P.Switch, "successDisabledColor", j(Kt, P.success.main, 0.62)), ve(P.Switch, "warningDisabledColor", j(Kt, P.warning.main, 0.62)), ve(P.TableCell, "border", j(Kt, j(Ml, P.divider, 1), 0.88)), ve(P.Tooltip, "bg", j(Ml, P.grey[700], 0.92));
      }
      if (P.mode === "dark") {
        ve(P.Alert, "errorColor", j(Kt, P.error.light, 0.6)), ve(P.Alert, "infoColor", j(Kt, P.info.light, 0.6)), ve(P.Alert, "successColor", j(Kt, P.success.light, 0.6)), ve(P.Alert, "warningColor", j(Kt, P.warning.light, 0.6)), ve(P.Alert, "errorFilledBg", B("palette-error-dark")), ve(P.Alert, "infoFilledBg", B("palette-info-dark")), ve(P.Alert, "successFilledBg", B("palette-success-dark")), ve(P.Alert, "warningFilledBg", B("palette-warning-dark")), ve(P.Alert, "errorFilledColor", di(() => P.getContrastText(P.error.dark))), ve(P.Alert, "infoFilledColor", di(() => P.getContrastText(P.info.dark))), ve(P.Alert, "successFilledColor", di(() => P.getContrastText(P.success.dark))), ve(P.Alert, "warningFilledColor", di(() => P.getContrastText(P.warning.dark))), ve(P.Alert, "errorStandardBg", j(Gt, P.error.light, 0.9)), ve(P.Alert, "infoStandardBg", j(Gt, P.info.light, 0.9)), ve(P.Alert, "successStandardBg", j(Gt, P.success.light, 0.9)), ve(P.Alert, "warningStandardBg", j(Gt, P.warning.light, 0.9)), ve(P.Alert, "errorIconColor", B("palette-error-main")), ve(P.Alert, "infoIconColor", B("palette-info-main")), ve(P.Alert, "successIconColor", B("palette-success-main")), ve(P.Alert, "warningIconColor", B("palette-warning-main")), ve(P.AppBar, "defaultBg", B("palette-grey-900")), ve(P.AppBar, "darkBg", B("palette-background-paper")), ve(P.AppBar, "darkColor", B("palette-text-primary")), ve(P.Avatar, "defaultBg", B("palette-grey-600")), ve(P.Button, "inheritContainedBg", B("palette-grey-800")), ve(P.Button, "inheritContainedHoverBg", B("palette-grey-700")), ve(P.Chip, "defaultBorder", B("palette-grey-700")), ve(P.Chip, "defaultAvatarColor", B("palette-grey-300")), ve(P.Chip, "defaultIconColor", B("palette-grey-300")), ve(P.FilledInput, "bg", "rgba(255, 255, 255, 0.09)"), ve(P.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)"), ve(P.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)"), ve(P.LinearProgress, "primaryBg", j(Gt, P.primary.main, 0.5)), ve(P.LinearProgress, "secondaryBg", j(Gt, P.secondary.main, 0.5)), ve(P.LinearProgress, "errorBg", j(Gt, P.error.main, 0.5)), ve(P.LinearProgress, "infoBg", j(Gt, P.info.main, 0.5)), ve(P.LinearProgress, "successBg", j(Gt, P.success.main, 0.5)), ve(P.LinearProgress, "warningBg", j(Gt, P.warning.main, 0.5)), ve(P.Skeleton, "bg", C ? j(Ml, P.text.primary, 0.13) : `rgba(${B("palette-text-primaryChannel")} / 0.13)`), ve(P.Slider, "primaryTrack", j(Gt, P.primary.main, 0.5)), ve(P.Slider, "secondaryTrack", j(Gt, P.secondary.main, 0.5)), ve(P.Slider, "errorTrack", j(Gt, P.error.main, 0.5)), ve(P.Slider, "infoTrack", j(Gt, P.info.main, 0.5)), ve(P.Slider, "successTrack", j(Gt, P.success.main, 0.5)), ve(P.Slider, "warningTrack", j(Gt, P.warning.main, 0.5));
        const V = C ? j(Kt, P.background.default, 0.985) : $g(P.background.default, 0.98);
        ve(P.SnackbarContent, "bg", V), ve(P.SnackbarContent, "color", di(() => C ? aF.text.primary : P.getContrastText(V))), ve(P.SpeedDialAction, "fabHoverBg", $g(P.background.paper, 0.15)), ve(P.StepConnector, "border", B("palette-grey-600")), ve(P.StepContent, "border", B("palette-grey-600")), ve(P.Switch, "defaultColor", B("palette-grey-300")), ve(P.Switch, "defaultDisabledColor", B("palette-grey-600")), ve(P.Switch, "primaryDisabledColor", j(Gt, P.primary.main, 0.55)), ve(P.Switch, "secondaryDisabledColor", j(Gt, P.secondary.main, 0.55)), ve(P.Switch, "errorDisabledColor", j(Gt, P.error.main, 0.55)), ve(P.Switch, "infoDisabledColor", j(Gt, P.info.main, 0.55)), ve(P.Switch, "successDisabledColor", j(Gt, P.success.main, 0.55)), ve(P.Switch, "warningDisabledColor", j(Gt, P.warning.main, 0.55)), ve(P.TableCell, "border", j(Gt, j(Ml, P.divider, 1), 0.68)), ve(P.Tooltip, "bg", j(Ml, P.grey[700], 0.92));
      }
      xa(P.background, "default"), xa(P.background, "paper"), xa(P.common, "background"), xa(P.common, "onBackground"), xa(P, "divider"), Object.keys(P).forEach((V) => {
        const F = P[V];
        V !== "tonalOffset" && F && typeof F == "object" && (F.main && ve(P[V], "mainChannel", fp(dp(F.main))), F.light && ve(P[V], "lightChannel", fp(dp(F.light))), F.dark && ve(P[V], "darkChannel", fp(dp(F.dark))), F.contrastText && ve(P[V], "contrastTextChannel", fp(dp(F.contrastText))), V === "text" && (xa(P[V], "primary"), xa(P[V], "secondary")), V === "action" && (F.active && xa(P[V], "active"), F.selected && xa(P[V], "selected")));
      });
    }), R = t.reduce((L, P) => vr(L, P), R);
    const A = {
      prefix: i,
      disableCssColorScheme: o,
      shouldSkipGeneratingVar: s,
      getSelector: bZ(R),
      enableContrastVars: a
    }, {
      vars: M,
      generateThemeVars: I,
      generateStyleSheets: D
    } = RX(R, A);
    return R.vars = M, Object.entries(R.colorSchemes[R.defaultColorScheme]).forEach(([L, P]) => {
      R[L] = P;
    }), R.generateThemeVars = I, R.generateStyleSheets = D, R.generateSpacing = function() {
      return W4(d.spacing, rk(this));
    }, R.getColorSchemeSelector = OX(l), R.spacing = R.generateSpacing(), R.shouldSkipGeneratingVar = s, R.unstable_sxConfig = {
      ...Oh,
      ...d?.unstable_sxConfig
    }, R.unstable_sx = function(P) {
      return Xs({
        sx: P,
        theme: this
      });
    }, R.toRuntimeSource = cF, R;
  }
  function KP(e, t, n) {
    e.colorSchemes && n && (e.colorSchemes[t] = {
      ...n !== !0 && n,
      palette: vk({
        ...n === !0 ? {} : n.palette,
        mode: t
      })
      // cast type to skip module augmentation test
    });
  }
  function rb(e = {}, ...t) {
    const {
      palette: n,
      cssVariables: r = !1,
      colorSchemes: o = n ? void 0 : {
        light: !0
      },
      defaultColorScheme: i = n?.mode,
      ...a
    } = e, s = i || "light", l = o?.[s], u = {
      ...o,
      ...n ? {
        [s]: {
          ...typeof l != "boolean" && l,
          palette: n
        }
      } : void 0
    };
    if (r === !1) {
      if (!("colorSchemes" in e))
        return cE(e, ...t);
      let d = n;
      "palette" in e || u[s] && (u[s] !== !0 ? d = u[s].palette : s === "dark" && (d = {
        mode: "dark"
      }));
      const p = cE({
        ...e,
        palette: d
      }, ...t);
      return p.defaultColorScheme = s, p.colorSchemes = u, p.palette.mode === "light" && (p.colorSchemes.light = {
        ...u.light !== !0 && u.light,
        palette: p.palette
      }, KP(p, "dark", u.dark)), p.palette.mode === "dark" && (p.colorSchemes.dark = {
        ...u.dark !== !0 && u.dark,
        palette: p.palette
      }, KP(p, "light", u.light)), p;
    }
    return !n && !("light" in u) && s === "light" && (u.light = !0), _Z({
      ...a,
      colorSchemes: u,
      defaultColorScheme: s,
      ...typeof r != "boolean" && r
    }, ...t);
  }
  const bk = rb(), Fi = "$$material";
  function ob() {
    const e = $h(bk);
    return e[Fi] || e;
  }
  function EZ(e) {
    return /* @__PURE__ */ S.jsx(G4, {
      ...e,
      defaultTheme: bk,
      themeId: Fi
    });
  }
  function ib(e) {
    return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
  }
  const wr = (e) => ib(e) && e !== "classes", Oe = Z4({
    themeId: Fi,
    defaultTheme: bk,
    rootShouldForwardProp: wr
  });
  function CZ(e) {
    return function(n) {
      return (
        // Pigment CSS `globalCss` support callback with theme inside an object but `GlobalStyles` support theme as a callback value.
        /* @__PURE__ */ S.jsx(EZ, {
          styles: typeof e == "function" ? (r) => e({
            theme: r,
            ...n
          }) : e
        })
      );
    };
  }
  function kZ() {
    return ik;
  }
  const at = gX;
  function lt(e) {
    return dX(e);
  }
  function TZ(e) {
    return it("MuiTable", e);
  }
  rt("MuiTable", ["root", "stickyHeader"]);
  const RZ = (e) => {
    const {
      classes: t,
      stickyHeader: n
    } = e;
    return ot({
      root: ["root", n && "stickyHeader"]
    }, TZ, t);
  }, OZ = Oe("table", {
    name: "MuiTable",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.stickyHeader && t.stickyHeader];
    }
  })(at(({
    theme: e
  }) => ({
    display: "table",
    width: "100%",
    borderCollapse: "collapse",
    borderSpacing: 0,
    "& caption": {
      ...e.typography.body2,
      padding: e.spacing(2),
      color: (e.vars || e).palette.text.secondary,
      textAlign: "left",
      captionSide: "bottom"
    },
    variants: [{
      props: ({
        ownerState: t
      }) => t.stickyHeader,
      style: {
        borderCollapse: "separate"
      }
    }]
  }))), YP = "table", AZ = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiTable"
    }), {
      className: o,
      component: i = YP,
      padding: a = "normal",
      size: s = "medium",
      stickyHeader: l = !1,
      ...u
    } = r, d = {
      ...r,
      component: i,
      padding: a,
      size: s,
      stickyHeader: l
    }, p = RZ(d), h = T.useMemo(() => ({
      padding: a,
      size: s,
      stickyHeader: l
    }), [a, s, l]);
    return /* @__PURE__ */ S.jsx(T4.Provider, {
      value: h,
      children: /* @__PURE__ */ S.jsx(OZ, {
        as: i,
        role: i === YP ? null : "table",
        ref: n,
        className: je(p.root, o),
        ownerState: d,
        ...u
      })
    });
  }), ab = /* @__PURE__ */ T.createContext();
  function NZ(e) {
    return it("MuiTableBody", e);
  }
  rt("MuiTableBody", ["root"]);
  const MZ = (e) => {
    const {
      classes: t
    } = e;
    return ot({
      root: ["root"]
    }, NZ, t);
  }, PZ = Oe("tbody", {
    name: "MuiTableBody",
    slot: "Root"
  })({
    display: "table-row-group"
  }), $Z = {
    variant: "body"
  }, XP = "tbody", IZ = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiTableBody"
    }), {
      className: o,
      component: i = XP,
      ...a
    } = r, s = {
      ...r,
      component: i
    }, l = MZ(s);
    return /* @__PURE__ */ S.jsx(ab.Provider, {
      value: $Z,
      children: /* @__PURE__ */ S.jsx(PZ, {
        className: je(l.root, o),
        as: i,
        ref: n,
        role: i === XP ? null : "rowgroup",
        ownerState: s,
        ...a
      })
    });
  });
  function jZ(e) {
    return it("MuiTableCell", e);
  }
  const DZ = rt("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]), FZ = (e) => {
    const {
      classes: t,
      variant: n,
      align: r,
      padding: o,
      size: i,
      stickyHeader: a
    } = e, s = {
      root: ["root", n, a && "stickyHeader", r !== "inherit" && `align${$e(r)}`, o !== "normal" && `padding${$e(o)}`, `size${$e(i)}`]
    };
    return ot(s, jZ, t);
  }, LZ = Oe("td", {
    name: "MuiTableCell",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[n.variant], t[`size${$e(n.size)}`], n.padding !== "normal" && t[`padding${$e(n.padding)}`], n.align !== "inherit" && t[`align${$e(n.align)}`], n.stickyHeader && t.stickyHeader];
    }
  })(at(({
    theme: e
  }) => ({
    ...e.typography.body2,
    display: "table-cell",
    verticalAlign: "inherit",
    // Workaround for a rendering bug with spanned columns in Chrome 62.0.
    // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
    borderBottom: e.vars ? `1px solid ${e.vars.palette.TableCell.border}` : `1px solid
    ${e.palette.mode === "light" ? e.lighten(e.alpha(e.palette.divider, 1), 0.88) : e.darken(e.alpha(e.palette.divider, 1), 0.68)}`,
    textAlign: "left",
    padding: 16,
    variants: [{
      props: {
        variant: "head"
      },
      style: {
        color: (e.vars || e).palette.text.primary,
        lineHeight: e.typography.pxToRem(24),
        fontWeight: e.typography.fontWeightMedium
      }
    }, {
      props: {
        variant: "body"
      },
      style: {
        color: (e.vars || e).palette.text.primary
      }
    }, {
      props: {
        variant: "footer"
      },
      style: {
        color: (e.vars || e).palette.text.secondary,
        lineHeight: e.typography.pxToRem(21),
        fontSize: e.typography.pxToRem(12)
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        padding: "6px 16px",
        [`&.${DZ.paddingCheckbox}`]: {
          width: 24,
          // prevent the checkbox column from growing
          padding: "0 12px 0 16px",
          "& > *": {
            padding: 0
          }
        }
      }
    }, {
      props: {
        padding: "checkbox"
      },
      style: {
        width: 48,
        // prevent the checkbox column from growing
        padding: "0 0 0 4px"
      }
    }, {
      props: {
        padding: "none"
      },
      style: {
        padding: 0
      }
    }, {
      props: {
        align: "left"
      },
      style: {
        textAlign: "left"
      }
    }, {
      props: {
        align: "center"
      },
      style: {
        textAlign: "center"
      }
    }, {
      props: {
        align: "right"
      },
      style: {
        textAlign: "right",
        flexDirection: "row-reverse"
      }
    }, {
      props: {
        align: "justify"
      },
      style: {
        textAlign: "justify"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.stickyHeader,
      style: {
        position: "sticky",
        top: 0,
        zIndex: 2,
        backgroundColor: (e.vars || e).palette.background.default
      }
    }]
  }))), Ig = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiTableCell"
    }), {
      align: o = "inherit",
      className: i,
      component: a,
      padding: s,
      scope: l,
      size: u,
      sortDirection: d,
      variant: p,
      ...h
    } = r, g = T.useContext(T4), y = T.useContext(ab), b = y && y.variant === "head";
    let v;
    a ? v = a : v = b ? "th" : "td";
    let x = l;
    v === "td" ? x = void 0 : !x && b && (x = "col");
    const E = p || y && y.variant, _ = {
      ...r,
      align: o,
      component: v,
      padding: s || (g && g.padding ? g.padding : "normal"),
      size: u || (g && g.size ? g.size : "medium"),
      sortDirection: d,
      stickyHeader: E === "head" && g && g.stickyHeader,
      variant: E
    }, C = FZ(_);
    let k = null;
    return d && (k = d === "asc" ? "ascending" : "descending"), /* @__PURE__ */ S.jsx(LZ, {
      as: v,
      ref: n,
      className: je(C.root, i),
      "aria-sort": k,
      scope: x,
      ownerState: _,
      ...h
    });
  });
  function zZ(e) {
    return it("MuiTableContainer", e);
  }
  rt("MuiTableContainer", ["root"]);
  const BZ = (e) => {
    const {
      classes: t
    } = e;
    return ot({
      root: ["root"]
    }, zZ, t);
  }, UZ = Oe("div", {
    name: "MuiTableContainer",
    slot: "Root"
  })({
    width: "100%",
    overflowX: "auto"
  }), VZ = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiTableContainer"
    }), {
      className: o,
      component: i = "div",
      ...a
    } = r, s = {
      ...r,
      component: i
    }, l = BZ(s);
    return /* @__PURE__ */ S.jsx(UZ, {
      ref: n,
      as: i,
      className: je(l.root, o),
      ownerState: s,
      ...a
    });
  });
  function HZ(e) {
    return it("MuiTableHead", e);
  }
  rt("MuiTableHead", ["root"]);
  const qZ = (e) => {
    const {
      classes: t
    } = e;
    return ot({
      root: ["root"]
    }, HZ, t);
  }, WZ = Oe("thead", {
    name: "MuiTableHead",
    slot: "Root"
  })({
    display: "table-header-group"
  }), GZ = {
    variant: "head"
  }, ZP = "thead", KZ = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiTableHead"
    }), {
      className: o,
      component: i = ZP,
      ...a
    } = r, s = {
      ...r,
      component: i
    }, l = qZ(s);
    return /* @__PURE__ */ S.jsx(ab.Provider, {
      value: GZ,
      children: /* @__PURE__ */ S.jsx(WZ, {
        as: i,
        className: je(l.root, o),
        ref: n,
        role: i === ZP ? null : "rowgroup",
        ownerState: s,
        ...a
      })
    });
  });
  function YZ(e) {
    return it("MuiTableRow", e);
  }
  const QP = rt("MuiTableRow", ["root", "selected", "hover", "head", "footer"]), XZ = (e) => {
    const {
      classes: t,
      selected: n,
      hover: r,
      head: o,
      footer: i
    } = e;
    return ot({
      root: ["root", n && "selected", r && "hover", o && "head", i && "footer"]
    }, YZ, t);
  }, ZZ = Oe("tr", {
    name: "MuiTableRow",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.head && t.head, n.footer && t.footer];
    }
  })(at(({
    theme: e
  }) => ({
    color: "inherit",
    display: "table-row",
    verticalAlign: "middle",
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    [`&.${QP.hover}:hover`]: {
      backgroundColor: (e.vars || e).palette.action.hover
    },
    [`&.${QP.selected}`]: {
      backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity),
      "&:hover": {
        backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.hoverOpacity}`)
      }
    }
  }))), JP = "tr", jg = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiTableRow"
    }), {
      className: o,
      component: i = JP,
      hover: a = !1,
      selected: s = !1,
      ...l
    } = r, u = T.useContext(ab), d = {
      ...r,
      component: i,
      hover: a,
      selected: s,
      head: u && u.variant === "head",
      footer: u && u.variant === "footer"
    }, p = XZ(d);
    return /* @__PURE__ */ S.jsx(ZZ, {
      as: i,
      ref: n,
      className: je(p.root, o),
      role: i === JP ? null : "row",
      ownerState: d,
      ...l
    });
  });
  function zv(e) {
    try {
      return e.matches(":focus-visible");
    } catch {
    }
    return !1;
  }
  function er(...e) {
    const t = T.useRef(void 0), n = T.useCallback((r) => {
      const o = e.map((i) => {
        if (i == null)
          return null;
        if (typeof i == "function") {
          const a = i, s = a(r);
          return typeof s == "function" ? s : () => {
            a(null);
          };
        }
        return i.current = r, () => {
          i.current = null;
        };
      });
      return () => {
        o.forEach((i) => i?.());
      };
    }, e);
    return T.useMemo(() => e.every((r) => r == null) ? null : (r) => {
      t.current && (t.current(), t.current = void 0), r != null && (t.current = n(r));
    }, e);
  }
  function Li(e) {
    const t = T.useRef(e);
    return Ko(() => {
      t.current = e;
    }), T.useRef((...n) => (
      // @ts-expect-error hide `this`
      (0, t.current)(...n)
    )).current;
  }
  const e$ = {};
  function dF(e, t) {
    const n = T.useRef(e$);
    return n.current === e$ && (n.current = e(t)), n;
  }
  class Bv {
    constructor() {
      Wn(this, "mountEffect", () => {
        this.shouldMount && !this.didMount && this.ref.current !== null && (this.didMount = !0, this.mounted.resolve());
      });
      this.ref = {
        current: null
      }, this.mounted = null, this.didMount = !1, this.shouldMount = !1, this.setShouldMount = null;
    }
    /** React ref to the ripple instance */
    /** If the ripple component should be mounted */
    /** Promise that resolves when the ripple component is mounted */
    /** If the ripple component has been mounted */
    /** React state hook setter */
    static create() {
      return new Bv();
    }
    static use() {
      const t = dF(Bv.create).current, [n, r] = T.useState(!1);
      return t.shouldMount = n, t.setShouldMount = r, T.useEffect(t.mountEffect, [n]), t;
    }
    mount() {
      return this.mounted || (this.mounted = JZ(), this.shouldMount = !0, this.setShouldMount(this.shouldMount)), this.mounted;
    }
    /* Ripple API */
    start(...t) {
      this.mount().then(() => this.ref.current?.start(...t));
    }
    stop(...t) {
      this.mount().then(() => this.ref.current?.stop(...t));
    }
    pulsate(...t) {
      this.mount().then(() => this.ref.current?.pulsate(...t));
    }
  }
  function QZ() {
    return Bv.use();
  }
  function JZ() {
    let e, t;
    const n = new Promise((r, o) => {
      e = r, t = o;
    });
    return n.resolve = e, n.reject = t, n;
  }
  function sb(e, t) {
    if (e == null) return {};
    var n = {};
    for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue;
      n[r] = e[r];
    }
    return n;
  }
  function Uv(e, t) {
    return Uv = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
      return n.__proto__ = r, n;
    }, Uv(e, t);
  }
  function xk(e, t) {
    e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Uv(e, t);
  }
  const t$ = {
    disabled: !1
  }, Vv = Tn.createContext(null);
  var eQ = function(t) {
    return t.scrollTop;
  }, pp = "unmounted", Bl = "exited", Ul = "entering", Mu = "entered", fE = "exiting", Ki = /* @__PURE__ */ function(e) {
    xk(t, e);
    function t(r, o) {
      var i;
      i = e.call(this, r, o) || this;
      var a = o, s = a && !a.isMounting ? r.enter : r.appear, l;
      return i.appearStatus = null, r.in ? s ? (l = Bl, i.appearStatus = Ul) : l = Mu : r.unmountOnExit || r.mountOnEnter ? l = pp : l = Bl, i.state = {
        status: l
      }, i.nextCallback = null, i;
    }
    t.getDerivedStateFromProps = function(o, i) {
      var a = o.in;
      return a && i.status === pp ? {
        status: Bl
      } : null;
    };
    var n = t.prototype;
    return n.componentDidMount = function() {
      this.updateStatus(!0, this.appearStatus);
    }, n.componentDidUpdate = function(o) {
      var i = null;
      if (o !== this.props) {
        var a = this.state.status;
        this.props.in ? a !== Ul && a !== Mu && (i = Ul) : (a === Ul || a === Mu) && (i = fE);
      }
      this.updateStatus(!1, i);
    }, n.componentWillUnmount = function() {
      this.cancelNextCallback();
    }, n.getTimeouts = function() {
      var o = this.props.timeout, i, a, s;
      return i = a = s = o, o != null && typeof o != "number" && (i = o.exit, a = o.enter, s = o.appear !== void 0 ? o.appear : a), {
        exit: i,
        enter: a,
        appear: s
      };
    }, n.updateStatus = function(o, i) {
      if (o === void 0 && (o = !1), i !== null)
        if (this.cancelNextCallback(), i === Ul) {
          if (this.props.unmountOnExit || this.props.mountOnEnter) {
            var a = this.props.nodeRef ? this.props.nodeRef.current : up.findDOMNode(this);
            a && eQ(a);
          }
          this.performEnter(o);
        } else
          this.performExit();
      else this.props.unmountOnExit && this.state.status === Bl && this.setState({
        status: pp
      });
    }, n.performEnter = function(o) {
      var i = this, a = this.props.enter, s = this.context ? this.context.isMounting : o, l = this.props.nodeRef ? [s] : [up.findDOMNode(this), s], u = l[0], d = l[1], p = this.getTimeouts(), h = s ? p.appear : p.enter;
      if (!o && !a || t$.disabled) {
        this.safeSetState({
          status: Mu
        }, function() {
          i.props.onEntered(u);
        });
        return;
      }
      this.props.onEnter(u, d), this.safeSetState({
        status: Ul
      }, function() {
        i.props.onEntering(u, d), i.onTransitionEnd(h, function() {
          i.safeSetState({
            status: Mu
          }, function() {
            i.props.onEntered(u, d);
          });
        });
      });
    }, n.performExit = function() {
      var o = this, i = this.props.exit, a = this.getTimeouts(), s = this.props.nodeRef ? void 0 : up.findDOMNode(this);
      if (!i || t$.disabled) {
        this.safeSetState({
          status: Bl
        }, function() {
          o.props.onExited(s);
        });
        return;
      }
      this.props.onExit(s), this.safeSetState({
        status: fE
      }, function() {
        o.props.onExiting(s), o.onTransitionEnd(a.exit, function() {
          o.safeSetState({
            status: Bl
          }, function() {
            o.props.onExited(s);
          });
        });
      });
    }, n.cancelNextCallback = function() {
      this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
    }, n.safeSetState = function(o, i) {
      i = this.setNextCallback(i), this.setState(o, i);
    }, n.setNextCallback = function(o) {
      var i = this, a = !0;
      return this.nextCallback = function(s) {
        a && (a = !1, i.nextCallback = null, o(s));
      }, this.nextCallback.cancel = function() {
        a = !1;
      }, this.nextCallback;
    }, n.onTransitionEnd = function(o, i) {
      this.setNextCallback(i);
      var a = this.props.nodeRef ? this.props.nodeRef.current : up.findDOMNode(this), s = o == null && !this.props.addEndListener;
      if (!a || s) {
        setTimeout(this.nextCallback, 0);
        return;
      }
      if (this.props.addEndListener) {
        var l = this.props.nodeRef ? [this.nextCallback] : [a, this.nextCallback], u = l[0], d = l[1];
        this.props.addEndListener(u, d);
      }
      o != null && setTimeout(this.nextCallback, o);
    }, n.render = function() {
      var o = this.state.status;
      if (o === pp)
        return null;
      var i = this.props, a = i.children;
      i.in, i.mountOnEnter, i.unmountOnExit, i.appear, i.enter, i.exit, i.timeout, i.addEndListener, i.onEnter, i.onEntering, i.onEntered, i.onExit, i.onExiting, i.onExited, i.nodeRef;
      var s = sb(i, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
      return (
        // allows for nested Transitions
        /* @__PURE__ */ Tn.createElement(Vv.Provider, {
          value: null
        }, typeof a == "function" ? a(o, s) : Tn.cloneElement(Tn.Children.only(a), s))
      );
    }, t;
  }(Tn.Component);
  Ki.contextType = Vv;
  Ki.propTypes = {};
  function yu() {
  }
  Ki.defaultProps = {
    in: !1,
    mountOnEnter: !1,
    unmountOnExit: !1,
    appear: !1,
    enter: !0,
    exit: !0,
    onEnter: yu,
    onEntering: yu,
    onEntered: yu,
    onExit: yu,
    onExiting: yu,
    onExited: yu
  };
  Ki.UNMOUNTED = pp;
  Ki.EXITED = Bl;
  Ki.ENTERING = Ul;
  Ki.ENTERED = Mu;
  Ki.EXITING = fE;
  function pF(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  function wk(e, t) {
    var n = function(i) {
      return t && T.isValidElement(i) ? t(i) : i;
    }, r = /* @__PURE__ */ Object.create(null);
    return e && T.Children.map(e, function(o) {
      return o;
    }).forEach(function(o) {
      r[o.key] = n(o);
    }), r;
  }
  function tQ(e, t) {
    e = e || {}, t = t || {};
    function n(d) {
      return d in t ? t[d] : e[d];
    }
    var r = /* @__PURE__ */ Object.create(null), o = [];
    for (var i in e)
      i in t ? o.length && (r[i] = o, o = []) : o.push(i);
    var a, s = {};
    for (var l in t) {
      if (r[l])
        for (a = 0; a < r[l].length; a++) {
          var u = r[l][a];
          s[r[l][a]] = n(u);
        }
      s[l] = n(l);
    }
    for (a = 0; a < o.length; a++)
      s[o[a]] = n(o[a]);
    return s;
  }
  function Gl(e, t, n) {
    return n[t] != null ? n[t] : e.props[t];
  }
  function nQ(e, t) {
    return wk(e.children, function(n) {
      return T.cloneElement(n, {
        onExited: t.bind(null, n),
        in: !0,
        appear: Gl(n, "appear", e),
        enter: Gl(n, "enter", e),
        exit: Gl(n, "exit", e)
      });
    });
  }
  function rQ(e, t, n) {
    var r = wk(e.children), o = tQ(t, r);
    return Object.keys(o).forEach(function(i) {
      var a = o[i];
      if (T.isValidElement(a)) {
        var s = i in t, l = i in r, u = t[i], d = T.isValidElement(u) && !u.props.in;
        l && (!s || d) ? o[i] = T.cloneElement(a, {
          onExited: n.bind(null, a),
          in: !0,
          exit: Gl(a, "exit", e),
          enter: Gl(a, "enter", e)
        }) : !l && s && !d ? o[i] = T.cloneElement(a, {
          in: !1
        }) : l && s && T.isValidElement(u) && (o[i] = T.cloneElement(a, {
          onExited: n.bind(null, a),
          in: u.props.in,
          exit: Gl(a, "exit", e),
          enter: Gl(a, "enter", e)
        }));
      }
    }), o;
  }
  var oQ = Object.values || function(e) {
    return Object.keys(e).map(function(t) {
      return e[t];
    });
  }, iQ = {
    component: "div",
    childFactory: function(t) {
      return t;
    }
  }, Sk = /* @__PURE__ */ function(e) {
    xk(t, e);
    function t(r, o) {
      var i;
      i = e.call(this, r, o) || this;
      var a = i.handleExited.bind(pF(i));
      return i.state = {
        contextValue: {
          isMounting: !0
        },
        handleExited: a,
        firstRender: !0
      }, i;
    }
    var n = t.prototype;
    return n.componentDidMount = function() {
      this.mounted = !0, this.setState({
        contextValue: {
          isMounting: !1
        }
      });
    }, n.componentWillUnmount = function() {
      this.mounted = !1;
    }, t.getDerivedStateFromProps = function(o, i) {
      var a = i.children, s = i.handleExited, l = i.firstRender;
      return {
        children: l ? nQ(o, s) : rQ(o, a, s),
        firstRender: !1
      };
    }, n.handleExited = function(o, i) {
      var a = wk(this.props.children);
      o.key in a || (o.props.onExited && o.props.onExited(i), this.mounted && this.setState(function(s) {
        var l = Ge({}, s.children);
        return delete l[o.key], {
          children: l
        };
      }));
    }, n.render = function() {
      var o = this.props, i = o.component, a = o.childFactory, s = sb(o, ["component", "childFactory"]), l = this.state.contextValue, u = oQ(this.state.children).map(a);
      return delete s.appear, delete s.enter, delete s.exit, i === null ? /* @__PURE__ */ Tn.createElement(Vv.Provider, {
        value: l
      }, u) : /* @__PURE__ */ Tn.createElement(Vv.Provider, {
        value: l
      }, /* @__PURE__ */ Tn.createElement(i, s, u));
    }, t;
  }(Tn.Component);
  Sk.propTypes = {};
  Sk.defaultProps = iQ;
  const aQ = [];
  function sQ(e) {
    T.useEffect(e, aQ);
  }
  class _k {
    constructor() {
      Wn(this, "currentId", null);
      Wn(this, "clear", () => {
        this.currentId !== null && (clearTimeout(this.currentId), this.currentId = null);
      });
      Wn(this, "disposeEffect", () => this.clear);
    }
    static create() {
      return new _k();
    }
    /**
     * Executes `fn` after `delay`, clearing any previously scheduled call.
     */
    start(t, n) {
      this.clear(), this.currentId = setTimeout(() => {
        this.currentId = null, n();
      }, t);
    }
  }
  function hF() {
    const e = dF(_k.create).current;
    return sQ(e.disposeEffect), e;
  }
  function lQ(e) {
    const {
      className: t,
      classes: n,
      pulsate: r = !1,
      rippleX: o,
      rippleY: i,
      rippleSize: a,
      in: s,
      onExited: l,
      timeout: u
    } = e, [d, p] = T.useState(!1), h = je(t, n.ripple, n.rippleVisible, r && n.ripplePulsate), g = {
      width: a,
      height: a,
      top: -(a / 2) + i,
      left: -(a / 2) + o
    }, y = je(n.child, d && n.childLeaving, r && n.childPulsate);
    return !s && !d && p(!0), T.useEffect(() => {
      if (!s && l != null) {
        const b = setTimeout(l, u);
        return () => {
          clearTimeout(b);
        };
      }
    }, [l, s, u]), /* @__PURE__ */ S.jsx("span", {
      className: h,
      style: g,
      children: /* @__PURE__ */ S.jsx("span", {
        className: y
      })
    });
  }
  const wo = rt("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), dE = 550, cQ = 80, uQ = _f`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`, fQ = _f`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`, dQ = _f`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`, pQ = Oe("span", {
    name: "MuiTouchRipple",
    slot: "Root"
  })({
    overflow: "hidden",
    pointerEvents: "none",
    position: "absolute",
    zIndex: 0,
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    borderRadius: "inherit"
  }), hQ = Oe(lQ, {
    name: "MuiTouchRipple",
    slot: "Ripple"
  })`
  opacity: 0;
  position: absolute;

  &.${wo.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${uQ};
    animation-duration: ${dE}ms;
    animation-timing-function: ${({
    theme: e
  }) => e.transitions.easing.easeInOut};
  }

  &.${wo.ripplePulsate} {
    animation-duration: ${({
    theme: e
  }) => e.transitions.duration.shorter}ms;
  }

  & .${wo.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${wo.childLeaving} {
    opacity: 0;
    animation-name: ${fQ};
    animation-duration: ${dE}ms;
    animation-timing-function: ${({
    theme: e
  }) => e.transitions.easing.easeInOut};
  }

  & .${wo.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${dQ};
    animation-duration: 2500ms;
    animation-timing-function: ${({
    theme: e
  }) => e.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`, mQ = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiTouchRipple"
    }), {
      center: o = !1,
      classes: i = {},
      className: a,
      ...s
    } = r, [l, u] = T.useState([]), d = T.useRef(0), p = T.useRef(null);
    T.useEffect(() => {
      p.current && (p.current(), p.current = null);
    }, [l]);
    const h = T.useRef(!1), g = hF(), y = T.useRef(null), b = T.useRef(null), v = T.useCallback((C) => {
      const {
        pulsate: k,
        rippleX: R,
        rippleY: A,
        rippleSize: M,
        cb: I
      } = C;
      u((D) => [...D, /* @__PURE__ */ S.jsx(hQ, {
        classes: {
          ripple: je(i.ripple, wo.ripple),
          rippleVisible: je(i.rippleVisible, wo.rippleVisible),
          ripplePulsate: je(i.ripplePulsate, wo.ripplePulsate),
          child: je(i.child, wo.child),
          childLeaving: je(i.childLeaving, wo.childLeaving),
          childPulsate: je(i.childPulsate, wo.childPulsate)
        },
        timeout: dE,
        pulsate: k,
        rippleX: R,
        rippleY: A,
        rippleSize: M
      }, d.current)]), d.current += 1, p.current = I;
    }, [i]), x = T.useCallback((C = {}, k = {}, R = () => {
    }) => {
      const {
        pulsate: A = !1,
        center: M = o || k.pulsate,
        fakeElement: I = !1
        // For test purposes
      } = k;
      if (C?.type === "mousedown" && h.current) {
        h.current = !1;
        return;
      }
      C?.type === "touchstart" && (h.current = !0);
      const D = I ? null : b.current, L = D ? D.getBoundingClientRect() : {
        width: 0,
        height: 0,
        left: 0,
        top: 0
      };
      let P, B, j;
      if (M || C === void 0 || C.clientX === 0 && C.clientY === 0 || !C.clientX && !C.touches)
        P = Math.round(L.width / 2), B = Math.round(L.height / 2);
      else {
        const {
          clientX: V,
          clientY: F
        } = C.touches && C.touches.length > 0 ? C.touches[0] : C;
        P = Math.round(V - L.left), B = Math.round(F - L.top);
      }
      if (M)
        j = Math.sqrt((2 * L.width ** 2 + L.height ** 2) / 3), j % 2 === 0 && (j += 1);
      else {
        const V = Math.max(Math.abs((D ? D.clientWidth : 0) - P), P) * 2 + 2, F = Math.max(Math.abs((D ? D.clientHeight : 0) - B), B) * 2 + 2;
        j = Math.sqrt(V ** 2 + F ** 2);
      }
      C?.touches ? y.current === null && (y.current = () => {
        v({
          pulsate: A,
          rippleX: P,
          rippleY: B,
          rippleSize: j,
          cb: R
        });
      }, g.start(cQ, () => {
        y.current && (y.current(), y.current = null);
      })) : v({
        pulsate: A,
        rippleX: P,
        rippleY: B,
        rippleSize: j,
        cb: R
      });
    }, [o, v, g]), E = T.useCallback(() => {
      x({}, {
        pulsate: !0
      });
    }, [x]), _ = T.useCallback((C, k) => {
      if (g.clear(), C?.type === "touchend" && y.current) {
        y.current(), y.current = null, g.start(0, () => {
          _(C, k);
        });
        return;
      }
      y.current = null, u((R) => R.length > 0 ? R.slice(1) : R), p.current = k;
    }, [g]);
    return T.useImperativeHandle(n, () => ({
      pulsate: E,
      start: x,
      stop: _
    }), [E, x, _]), /* @__PURE__ */ S.jsx(pQ, {
      className: je(wo.root, i.root, a),
      ref: b,
      ...s,
      children: /* @__PURE__ */ S.jsx(Sk, {
        component: null,
        exit: !0,
        children: l
      })
    });
  });
  function gQ(e) {
    return it("MuiButtonBase", e);
  }
  const yQ = rt("MuiButtonBase", ["root", "disabled", "focusVisible"]), vQ = (e) => {
    const {
      disabled: t,
      focusVisible: n,
      focusVisibleClassName: r,
      classes: o
    } = e, a = ot({
      root: ["root", t && "disabled", n && "focusVisible"]
    }, gQ, o);
    return n && r && (a.root += ` ${r}`), a;
  }, bQ = Oe("button", {
    name: "MuiButtonBase",
    slot: "Root"
  })({
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    boxSizing: "border-box",
    WebkitTapHighlightColor: "transparent",
    backgroundColor: "transparent",
    // Reset default value
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    border: 0,
    margin: 0,
    // Remove the margin in Safari
    borderRadius: 0,
    padding: 0,
    // Remove the padding in Firefox
    cursor: "pointer",
    userSelect: "none",
    verticalAlign: "middle",
    MozAppearance: "none",
    // Reset
    WebkitAppearance: "none",
    // Reset
    textDecoration: "none",
    // So we take precedent over the style of a native <a /> element.
    color: "inherit",
    "&::-moz-focus-inner": {
      borderStyle: "none"
      // Remove Firefox dotted outline.
    },
    [`&.${yQ.disabled}`]: {
      pointerEvents: "none",
      // Disable link interactions
      cursor: "default"
    },
    "@media print": {
      colorAdjust: "exact"
    }
  }), Ih = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiButtonBase"
    }), {
      action: o,
      centerRipple: i = !1,
      children: a,
      className: s,
      component: l = "button",
      disabled: u = !1,
      disableRipple: d = !1,
      disableTouchRipple: p = !1,
      focusRipple: h = !1,
      focusVisibleClassName: g,
      LinkComponent: y = "a",
      onBlur: b,
      onClick: v,
      onContextMenu: x,
      onDragLeave: E,
      onFocus: _,
      onFocusVisible: C,
      onKeyDown: k,
      onKeyUp: R,
      onMouseDown: A,
      onMouseLeave: M,
      onMouseUp: I,
      onTouchEnd: D,
      onTouchMove: L,
      onTouchStart: P,
      tabIndex: B = 0,
      TouchRippleProps: j,
      touchRippleRef: V,
      type: F,
      ...G
    } = r, W = T.useRef(null), K = QZ(), $ = er(K.ref, V), [U, X] = T.useState(!1);
    u && U && X(!1), T.useImperativeHandle(o, () => ({
      focusVisible: () => {
        X(!0), W.current.focus();
      }
    }), []);
    const z = K.shouldMount && !d && !u;
    T.useEffect(() => {
      U && h && !d && K.pulsate();
    }, [d, h, U, K]);
    const H = wa(K, "start", A, p), Y = wa(K, "stop", x, p), Q = wa(K, "stop", E, p), re = wa(K, "stop", I, p), te = wa(K, "stop", (Me) => {
      U && Me.preventDefault(), M && M(Me);
    }, p), le = wa(K, "start", P, p), fe = wa(K, "stop", D, p), J = wa(K, "stop", L, p), ee = wa(K, "stop", (Me) => {
      zv(Me.target) || X(!1), b && b(Me);
    }, !1), ie = Li((Me) => {
      W.current || (W.current = Me.currentTarget), zv(Me.target) && (X(!0), C && C(Me)), _ && _(Me);
    }), ae = () => {
      const Me = W.current;
      return l && l !== "button" && !(Me.tagName === "A" && Me.href);
    }, ge = Li((Me) => {
      h && !Me.repeat && U && Me.key === " " && K.stop(Me, () => {
        K.start(Me);
      }), Me.target === Me.currentTarget && ae() && Me.key === " " && Me.preventDefault(), k && k(Me), Me.target === Me.currentTarget && ae() && Me.key === "Enter" && !u && (Me.preventDefault(), v && v(Me));
    }), Ce = Li((Me) => {
      h && Me.key === " " && U && !Me.defaultPrevented && K.stop(Me, () => {
        K.pulsate(Me);
      }), R && R(Me), v && Me.target === Me.currentTarget && ae() && Me.key === " " && !Me.defaultPrevented && v(Me);
    });
    let Ne = l;
    Ne === "button" && (G.href || G.to) && (Ne = y);
    const Le = {};
    Ne === "button" ? (Le.type = F === void 0 ? "button" : F, Le.disabled = u) : (!G.href && !G.to && (Le.role = "button"), u && (Le["aria-disabled"] = u));
    const Ve = er(n, W), Ke = {
      ...r,
      centerRipple: i,
      component: l,
      disabled: u,
      disableRipple: d,
      disableTouchRipple: p,
      focusRipple: h,
      tabIndex: B,
      focusVisible: U
    }, ze = vQ(Ke);
    return /* @__PURE__ */ S.jsxs(bQ, {
      as: Ne,
      className: je(ze.root, s),
      ownerState: Ke,
      onBlur: ee,
      onClick: v,
      onContextMenu: Y,
      onFocus: ie,
      onKeyDown: ge,
      onKeyUp: Ce,
      onMouseDown: H,
      onMouseLeave: te,
      onMouseUp: re,
      onDragLeave: Q,
      onTouchEnd: fe,
      onTouchMove: J,
      onTouchStart: le,
      ref: Ve,
      tabIndex: u ? -1 : B,
      type: F,
      ...Le,
      ...G,
      children: [a, z ? /* @__PURE__ */ S.jsx(mQ, {
        ref: $,
        center: i,
        ...j
      }) : null]
    });
  });
  function wa(e, t, n, r = !1) {
    return Li((o) => (n && n(o), r || e[t](o), !0));
  }
  function xQ(e) {
    return it("MuiSvgIcon", e);
  }
  rt("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
  const wQ = (e) => {
    const {
      color: t,
      fontSize: n,
      classes: r
    } = e, o = {
      root: ["root", t !== "inherit" && `color${$e(t)}`, `fontSize${$e(n)}`]
    };
    return ot(o, xQ, r);
  }, SQ = Oe("svg", {
    name: "MuiSvgIcon",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.color !== "inherit" && t[`color${$e(n.color)}`], t[`fontSize${$e(n.fontSize)}`]];
    }
  })(at(({
    theme: e
  }) => ({
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    flexShrink: 0,
    transition: e.transitions?.create?.("fill", {
      duration: (e.vars ?? e).transitions?.duration?.shorter
    }),
    variants: [
      {
        props: (t) => !t.hasSvgAsChild,
        style: {
          // the <svg> will define the property that has `currentColor`
          // for example heroicons uses fill="none" and stroke="currentColor"
          fill: "currentColor"
        }
      },
      {
        props: {
          fontSize: "inherit"
        },
        style: {
          fontSize: "inherit"
        }
      },
      {
        props: {
          fontSize: "small"
        },
        style: {
          fontSize: e.typography?.pxToRem?.(20) || "1.25rem"
        }
      },
      {
        props: {
          fontSize: "medium"
        },
        style: {
          fontSize: e.typography?.pxToRem?.(24) || "1.5rem"
        }
      },
      {
        props: {
          fontSize: "large"
        },
        style: {
          fontSize: e.typography?.pxToRem?.(35) || "2.1875rem"
        }
      },
      // TODO v5 deprecate color prop, v6 remove for sx
      ...Object.entries((e.vars ?? e).palette).filter(([, t]) => t && t.main).map(([t]) => ({
        props: {
          color: t
        },
        style: {
          color: (e.vars ?? e).palette?.[t]?.main
        }
      })),
      {
        props: {
          color: "action"
        },
        style: {
          color: (e.vars ?? e).palette?.action?.active
        }
      },
      {
        props: {
          color: "disabled"
        },
        style: {
          color: (e.vars ?? e).palette?.action?.disabled
        }
      },
      {
        props: {
          color: "inherit"
        },
        style: {
          color: void 0
        }
      }
    ]
  }))), pE = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiSvgIcon"
    }), {
      children: o,
      className: i,
      color: a = "inherit",
      component: s = "svg",
      fontSize: l = "medium",
      htmlColor: u,
      inheritViewBox: d = !1,
      titleAccess: p,
      viewBox: h = "0 0 24 24",
      ...g
    } = r, y = /* @__PURE__ */ T.isValidElement(o) && o.type === "svg", b = {
      ...r,
      color: a,
      component: s,
      fontSize: l,
      instanceFontSize: t.fontSize,
      inheritViewBox: d,
      viewBox: h,
      hasSvgAsChild: y
    }, v = {};
    d || (v.viewBox = h);
    const x = wQ(b);
    return /* @__PURE__ */ S.jsxs(SQ, {
      as: s,
      className: je(x.root, i),
      focusable: "false",
      color: u,
      "aria-hidden": p ? void 0 : !0,
      role: p ? "img" : void 0,
      ref: n,
      ...v,
      ...g,
      ...y && o.props,
      ownerState: b,
      children: [y ? o.props.children : o, p ? /* @__PURE__ */ S.jsx("title", {
        children: p
      }) : null]
    });
  });
  pE.muiName = "SvgIcon";
  function co(e, t) {
    function n(r, o) {
      return /* @__PURE__ */ S.jsx(pE, {
        "data-testid": void 0,
        ref: o,
        ...r,
        children: e
      });
    }
    return n.muiName = pE.muiName, /* @__PURE__ */ T.memo(/* @__PURE__ */ T.forwardRef(n));
  }
  const _Q = co(/* @__PURE__ */ S.jsx("path", {
    d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
  }));
  function EQ(e) {
    return it("MuiTableSortLabel", e);
  }
  const sS = rt("MuiTableSortLabel", ["root", "active", "icon", "iconDirectionDesc", "iconDirectionAsc", "directionDesc", "directionAsc"]);
  function zi(e) {
    return typeof e == "string";
  }
  function mF(e, t, n) {
    return e === void 0 || zi(e) ? t : {
      ...t,
      ownerState: {
        ...t.ownerState,
        ...n
      }
    };
  }
  function gF(e, t, n) {
    return typeof e == "function" ? e(t, n) : e;
  }
  function Cp(e, t = []) {
    if (e === void 0)
      return {};
    const n = {};
    return Object.keys(e).filter((r) => r.match(/^on[A-Z]/) && typeof e[r] == "function" && !t.includes(r)).forEach((r) => {
      n[r] = e[r];
    }), n;
  }
  function n$(e) {
    if (e === void 0)
      return {};
    const t = {};
    return Object.keys(e).filter((n) => !(n.match(/^on[A-Z]/) && typeof e[n] == "function")).forEach((n) => {
      t[n] = e[n];
    }), t;
  }
  function yF(e) {
    const {
      getSlotProps: t,
      additionalProps: n,
      externalSlotProps: r,
      externalForwardedProps: o,
      className: i
    } = e;
    if (!t) {
      const g = je(n?.className, i, o?.className, r?.className), y = {
        ...n?.style,
        ...o?.style,
        ...r?.style
      }, b = {
        ...n,
        ...o,
        ...r
      };
      return g.length > 0 && (b.className = g), Object.keys(y).length > 0 && (b.style = y), {
        props: b,
        internalRef: void 0
      };
    }
    const a = Cp({
      ...o,
      ...r
    }), s = n$(r), l = n$(o), u = t(a), d = je(u?.className, n?.className, i, o?.className, r?.className), p = {
      ...u?.style,
      ...n?.style,
      ...o?.style,
      ...r?.style
    }, h = {
      ...u,
      ...n,
      ...l,
      ...s
    };
    return d.length > 0 && (h.className = d), Object.keys(p).length > 0 && (h.style = p), {
      props: h,
      internalRef: u.ref
    };
  }
  function dn(e, t) {
    const {
      className: n,
      elementType: r,
      ownerState: o,
      externalForwardedProps: i,
      internalForwardedProps: a,
      shouldForwardComponentProp: s = !1,
      ...l
    } = t, {
      component: u,
      slots: d = {
        [e]: void 0
      },
      slotProps: p = {
        [e]: void 0
      },
      ...h
    } = i, g = d[e] || r, y = gF(p[e], o), {
      props: {
        component: b,
        ...v
      },
      internalRef: x
    } = yF({
      className: n,
      ...l,
      externalForwardedProps: e === "root" ? h : void 0,
      externalSlotProps: y
    }), E = er(x, y?.ref, t.ref), _ = e === "root" ? b || u : b, C = mF(g, {
      ...e === "root" && !u && !d[e] && a,
      ...e !== "root" && !d[e] && a,
      ...v,
      ..._ && !s && {
        as: _
      },
      ..._ && s && {
        component: _
      },
      ref: E
    }, o);
    return [g, C];
  }
  const CQ = (e) => {
    const {
      classes: t,
      direction: n,
      active: r
    } = e, o = {
      root: ["root", r && "active", `direction${$e(n)}`],
      icon: ["icon", `iconDirection${$e(n)}`]
    };
    return ot(o, EQ, t);
  }, kQ = Oe(Ih, {
    name: "MuiTableSortLabel",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.active && t.active];
    }
  })(at(({
    theme: e
  }) => ({
    cursor: "pointer",
    display: "inline-flex",
    justifyContent: "flex-start",
    flexDirection: "inherit",
    alignItems: "center",
    "&:focus": {
      color: (e.vars || e).palette.text.secondary
    },
    "&:hover": {
      color: (e.vars || e).palette.text.secondary,
      [`& .${sS.icon}`]: {
        opacity: 0.5
      }
    },
    [`&.${sS.active}`]: {
      color: (e.vars || e).palette.text.primary,
      [`& .${sS.icon}`]: {
        opacity: 1,
        color: (e.vars || e).palette.text.secondary
      }
    }
  }))), TQ = Oe("span", {
    name: "MuiTableSortLabel",
    slot: "Icon",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.icon, t[`iconDirection${$e(n.direction)}`]];
    }
  })(at(({
    theme: e
  }) => ({
    fontSize: 18,
    marginRight: 4,
    marginLeft: 4,
    opacity: 0,
    transition: e.transitions.create(["opacity", "transform"], {
      duration: e.transitions.duration.shorter
    }),
    userSelect: "none",
    variants: [{
      props: {
        direction: "desc"
      },
      style: {
        transform: "rotate(0deg)"
      }
    }, {
      props: {
        direction: "asc"
      },
      style: {
        transform: "rotate(180deg)"
      }
    }]
  }))), RQ = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiTableSortLabel"
    }), {
      active: o = !1,
      children: i,
      className: a,
      direction: s = "asc",
      hideSortIcon: l = !1,
      IconComponent: u = _Q,
      slots: d = {},
      slotProps: p = {},
      ...h
    } = r, g = {
      ...r,
      active: o,
      direction: s,
      hideSortIcon: l,
      IconComponent: u
    }, y = CQ(g), b = {
      slots: d,
      slotProps: p
    }, [v, x] = dn("root", {
      elementType: kQ,
      externalForwardedProps: b,
      ownerState: g,
      className: je(y.root, a),
      ref: n
    }), [E, _] = dn("icon", {
      elementType: TQ,
      externalForwardedProps: b,
      ownerState: g,
      className: y.icon
    });
    return /* @__PURE__ */ S.jsxs(v, {
      disableRipple: !0,
      component: "span",
      ...x,
      ...h,
      children: [i, l && !o ? null : /* @__PURE__ */ S.jsx(E, {
        as: u,
        ..._
      })]
    });
  }), OQ = (e) => {
    const t = [];
    if (e === void 0)
      return {
        header: [],
        rows: []
      };
    e.data === void 0 && (e.data = []), (e.columns === void 0 || e.columns.length === 0) && (e.data.length === 0 ? e.columns = [] : e.columns = e.data[0].map((r, o) => `col${o}`)), (e.index === void 0 || e.index.length === 0) && (e.index = e.data.map((r, o) => `row${o}`));
    const n = Math.max(e.index.length, e.data.length);
    for (let r = 0; r < n; r++) {
      const i = [r < e.index.length ? e.index[r] : `row${r}`];
      for (let a = 0; a < e.columns.length; a++)
        i.push(e.data[r] ? e.data[r][a] : void 0);
      t.push(i);
    }
    return {
      header: ["index", ...e.columns],
      rows: t
    };
  }, AQ = (e, t) => e === "desc" ? (n, r) => r[t] < n[t] ? -1 : r[t] > n[t] ? 1 : 0 : (n, r) => n[t] < r[t] ? -1 : n[t] > r[t] ? 1 : 0, hE = (e, t) => {
    const n = e.map((r, o) => [
      r,
      o
    ]);
    return n.sort((r, o) => t(r[0], o[0])), n.map((r) => r[0]);
  }, NQ = (e, t, n = 1e3) => {
    if (e.length <= n)
      return hE(e, t);
    const r = [];
    for (let i = 0; i < e.length; i += n)
      r.push(e.slice(i, i + n));
    const o = r.map((i) => hE(i, t));
    return MQ(o, t);
  }, MQ = (e, t) => {
    if (e.length === 1) return e[0];
    const n = [], r = new Array(e.length).fill(0);
    for (; r.some((o, i) => o < e[i].length); ) {
      let o = -1, i = null;
      for (let a = 0; a < e.length; a++)
        if (r[a] < e[a].length) {
          const s = e[a][r[a]];
          (i === null || t(s, i) < 0) && (i = s, o = a);
        }
      o !== -1 && i !== null && (n.push(i), r[o]++);
    }
    return n;
  }, r$ = (e, t, n) => {
    const r = Math.ceil(e / n);
    return {
      currentPage: r === 0 ? 1 : Math.min(Math.max(1, t), r),
      pageSize: n,
      totalPages: r,
      totalRows: e
    };
  }, PQ = (e, t, n) => {
    const r = (t - 1) * n, o = r + n;
    return e.slice(r, o);
  }, $Q = (e, t, n, r, o = 5) => {
    const i = Math.max(0, Math.floor(e / n) - o), a = Math.min(
      r - 1,
      Math.ceil((e + t) / n) + o
    );
    return { startIndex: i, endIndex: a };
  }, IQ = (e, t) => {
    let n;
    return (...r) => {
      clearTimeout(n), n = setTimeout(() => e(...r), t);
    };
  }, vF = ({
    tabledata: e,
    className: t = "",
    size: n = "small",
    onSortChange: r,
    enablePagination: o = void 0,
    pageSize: i = 50,
    enableVirtualScrolling: a = void 0,
    virtualScrollingHeight: s = 400,
    enableLazyLoading: l = void 0,
    onLoadMore: u
  }) => {
    e || (e = {
      columns: [],
      index: [],
      data: []
    });
    const d = e.index.length;
    d > 1e4 && (l = l === void 0 ? !0 : l), d > 1e3 && (a = a === void 0 ? !0 : a), d > 2 * i && (o = o === void 0 ? !0 : o), l = l === void 0 ? !1 : l, a = a === void 0 ? !1 : a, o = o === void 0 ? !1 : o;
    const p = T.useMemo(
      () => OQ(e),
      [e]
    ), [h, g] = T.useState("asc"), [y, b] = T.useState("index"), [v, x] = T.useState(
      () => r$(p.rows.length, 1, i)
    ), [E, _] = T.useState(0), C = T.useRef(null), k = T.useMemo(() => {
      const W = p.header.indexOf(y);
      return W === -1 ? 0 : W;
    }, [p.header, y]), R = T.useMemo(
      () => IQ((W, K) => {
        g(K), b(W), r?.(W, K);
      }, 150),
      [r]
    ), A = T.useCallback(
      (W) => {
        const $ = y === W && h === "asc" ? "desc" : "asc";
        p.rows.length > 1e3 ? R(W, $) : (g($), b(W), r?.(W, $));
      },
      [
        y,
        h,
        r,
        p.rows.length,
        R
      ]
    ), M = T.useMemo(
      () => AQ(h, k),
      [h, k]
    ), I = T.useMemo(() => p.rows.length > 1e3 ? NQ(p.rows, M) : hE(p.rows, M), [p.rows, M]), D = T.useMemo(() => o ? PQ(I, v.currentPage, v.pageSize) : I, [
      I,
      o,
      v.currentPage,
      v.pageSize
    ]), L = {
      itemHeight: 48,
      // Approximate row height
      overscan: 5,
      containerHeight: s
    }, P = T.useMemo(() => a ? $Q(
      E,
      L.containerHeight,
      L.itemHeight,
      D.length,
      L.overscan
    ) : { startIndex: 0, endIndex: D.length - 1 }, [
      E,
      a,
      D.length,
      L
    ]), B = T.useCallback(
      (W) => {
        a && _(W.currentTarget.scrollTop);
      },
      [a]
    ), j = T.useCallback((W) => {
      x((K) => ({
        ...K,
        currentPage: W
      }));
    }, []), V = T.useCallback(
      (W) => {
        if (!(!o || !(W.target.closest(".sortable-table-wrapper") === W.currentTarget)))
          switch (W.key) {
            case "ArrowLeft":
              v.currentPage > 1 && (W.preventDefault(), W.stopPropagation(), j(v.currentPage - 1));
              break;
            case "ArrowRight":
              v.currentPage < v.totalPages && (W.preventDefault(), W.stopPropagation(), j(v.currentPage + 1));
              break;
            case "Home":
              v.currentPage > 1 && (W.preventDefault(), W.stopPropagation(), j(1));
              break;
            case "End":
              v.currentPage < v.totalPages && (W.preventDefault(), W.stopPropagation(), j(v.totalPages));
              break;
          }
      },
      [
        o,
        v.currentPage,
        v.totalPages,
        j
      ]
    );
    T.useEffect(() => {
      o && x((W) => r$(
        I.length,
        W.currentPage,
        // Use previous current page instead of hardcoding 1
        i
      ));
    }, [I.length, o, i]), T.useEffect(() => {
      l && u && v.currentPage >= v.totalPages - 1 && u(v.currentPage + 1);
    }, [
      l,
      u,
      v.currentPage,
      v.totalPages
    ]);
    const F = () => o ? /* @__PURE__ */ S.jsxs("div", { className: "sortable-table-pagination", children: [
      /* @__PURE__ */ S.jsx(
        "button",
        {
          onClick: () => j(v.currentPage - 1),
          disabled: v.currentPage <= 1,
          className: "pagination-button",
          children: "Previous"
        }
      ),
      /* @__PURE__ */ S.jsxs("span", { className: "pagination-info", children: [
        "Page ",
        v.currentPage,
        " of ",
        v.totalPages,
        "(",
        v.totalRows,
        " total rows)"
      ] }),
      /* @__PURE__ */ S.jsx(
        "button",
        {
          onClick: () => j(v.currentPage + 1),
          disabled: v.currentPage >= v.totalPages,
          className: "pagination-button",
          children: "Next"
        }
      )
    ] }) : null, G = () => {
      const W = a ? D.slice(
        P.startIndex,
        P.endIndex + 1
      ) : D;
      return /* @__PURE__ */ S.jsxs(IZ, { children: [
        a && /* @__PURE__ */ S.jsx(
          jg,
          {
            style: {
              height: P.startIndex * L.itemHeight
            },
            children: /* @__PURE__ */ S.jsx(Ig, { colSpan: p.header.length })
          }
        ),
        W.map((K, $) => {
          const U = a ? P.startIndex + $ : $;
          return /* @__PURE__ */ S.jsx(jg, { children: K.map((X, z) => /* @__PURE__ */ S.jsx(
            Ig,
            {
              className: z === 0 ? "sortable-table-index-cell" : "sortable-table-data-cell",
              children: X
            },
            `${e.index?.[U] || U}-${z}`
          )) }, e.index?.[U] || U);
        }),
        a && /* @__PURE__ */ S.jsx(
          jg,
          {
            style: {
              height: (D.length - P.endIndex - 1) * L.itemHeight
            },
            children: /* @__PURE__ */ S.jsx(Ig, { colSpan: p.header.length })
          }
        )
      ] });
    };
    return /* @__PURE__ */ S.jsxs(
      "div",
      {
        className: "sortable-table-wrapper",
        onKeyDown: V,
        tabIndex: o ? 0 : -1,
        role: o ? "application" : void 0,
        "aria-label": o ? "Sortable table with pagination" : void 0,
        children: [
          /* @__PURE__ */ S.jsx(
            VZ,
            {
              className: `sortable-table-container ${t}`,
              ref: C,
              onScroll: B,
              style: a ? { height: s } : void 0,
              children: /* @__PURE__ */ S.jsxs(AZ, { size: n, children: [
                /* @__PURE__ */ S.jsx(KZ, { className: "sortable-table-head", children: /* @__PURE__ */ S.jsx(jg, { className: "sortable-table-header-row", children: p.header.map((W) => /* @__PURE__ */ S.jsx(
                  Ig,
                  {
                    className: "sortable-table-header-cell",
                    "aria-label": `Sort by ${W}`,
                    children: /* @__PURE__ */ S.jsx(
                      RQ,
                      {
                        active: y === W,
                        direction: y === W ? h : "asc",
                        onClick: () => A(W),
                        className: "sortable-table-sort-label",
                        sx: {
                          "& .MuiTableSortLabel-icon": {
                            color: "inherit !important"
                          }
                        },
                        children: W
                      }
                    )
                  },
                  W
                )) }) }),
                G()
              ] })
            }
          ),
          F()
        ]
      }
    );
  };
  vF.displayName = "SortableTable";
  function Fe(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
    return function(o) {
      if (e?.(o), n === !1 || !o.defaultPrevented)
        return t?.(o);
    };
  }
  function o$(e, t) {
    if (typeof e == "function")
      return e(t);
    e != null && (e.current = t);
  }
  function lb(...e) {
    return (t) => {
      let n = !1;
      const r = e.map((o) => {
        const i = o$(o, t);
        return !n && typeof i == "function" && (n = !0), i;
      });
      if (n)
        return () => {
          for (let o = 0; o < r.length; o++) {
            const i = r[o];
            typeof i == "function" ? i() : o$(e[o], null);
          }
        };
    };
  }
  function an(...e) {
    return T.useCallback(lb(...e), e);
  }
  function jQ(e, t) {
    const n = T.createContext(t), r = (i) => {
      const { children: a, ...s } = i, l = T.useMemo(() => s, Object.values(s));
      return /* @__PURE__ */ S.jsx(n.Provider, { value: l, children: a });
    };
    r.displayName = e + "Provider";
    function o(i) {
      const a = T.useContext(n);
      if (a) return a;
      if (t !== void 0) return t;
      throw new Error(`\`${i}\` must be used within \`${e}\``);
    }
    return [r, o];
  }
  function Yi(e, t = []) {
    let n = [];
    function r(i, a) {
      const s = T.createContext(a), l = n.length;
      n = [...n, a];
      const u = (p) => {
        const { scope: h, children: g, ...y } = p, b = h?.[e]?.[l] || s, v = T.useMemo(() => y, Object.values(y));
        return /* @__PURE__ */ S.jsx(b.Provider, { value: v, children: g });
      };
      u.displayName = i + "Provider";
      function d(p, h) {
        const g = h?.[e]?.[l] || s, y = T.useContext(g);
        if (y) return y;
        if (a !== void 0) return a;
        throw new Error(`\`${p}\` must be used within \`${i}\``);
      }
      return [u, d];
    }
    const o = () => {
      const i = n.map((a) => T.createContext(a));
      return function(s) {
        const l = s?.[e] || i;
        return T.useMemo(
          () => ({ [`__scope${e}`]: { ...s, [e]: l } }),
          [s, l]
        );
      };
    };
    return o.scopeName = e, [r, DQ(o, ...t)];
  }
  function DQ(...e) {
    const t = e[0];
    if (e.length === 1) return t;
    const n = () => {
      const r = e.map((o) => ({
        useScope: o(),
        scopeName: o.scopeName
      }));
      return function(i) {
        const a = r.reduce((s, { useScope: l, scopeName: u }) => {
          const p = l(i)[`__scope${u}`];
          return { ...s, ...p };
        }, {});
        return T.useMemo(() => ({ [`__scope${t.scopeName}`]: a }), [a]);
      };
    };
    return n.scopeName = t.scopeName, n;
  }
  var Fa = globalThis?.document ? T.useLayoutEffect : () => {
  }, FQ = ec[" useId ".trim().toString()] || (() => {
  }), LQ = 0;
  function Bi(e) {
    const [t, n] = T.useState(FQ());
    return Fa(() => {
      n((r) => r ?? String(LQ++));
    }, [e]), e || (t ? `radix-${t}` : "");
  }
  var zQ = ec[" useInsertionEffect ".trim().toString()] || Fa;
  function ll({
    prop: e,
    defaultProp: t,
    onChange: n = () => {
    },
    caller: r
  }) {
    const [o, i, a] = BQ({
      defaultProp: t,
      onChange: n
    }), s = e !== void 0, l = s ? e : o;
    {
      const d = T.useRef(e !== void 0);
      T.useEffect(() => {
        const p = d.current;
        p !== s && console.warn(
          `${r} is changing from ${p ? "controlled" : "uncontrolled"} to ${s ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        ), d.current = s;
      }, [s, r]);
    }
    const u = T.useCallback(
      (d) => {
        if (s) {
          const p = UQ(d) ? d(e) : d;
          p !== e && a.current?.(p);
        } else
          i(d);
      },
      [s, e, i, a]
    );
    return [l, u];
  }
  function BQ({
    defaultProp: e,
    onChange: t
  }) {
    const [n, r] = T.useState(e), o = T.useRef(n), i = T.useRef(t);
    return zQ(() => {
      i.current = t;
    }, [t]), T.useEffect(() => {
      o.current !== n && (i.current?.(n), o.current = n);
    }, [n, o]), [n, r, i];
  }
  function UQ(e) {
    return typeof e == "function";
  }
  // @__NO_SIDE_EFFECTS__
  function nf(e) {
    const t = /* @__PURE__ */ VQ(e), n = T.forwardRef((r, o) => {
      const { children: i, ...a } = r, s = T.Children.toArray(i), l = s.find(qQ);
      if (l) {
        const u = l.props.children, d = s.map((p) => p === l ? T.Children.count(u) > 1 ? T.Children.only(null) : T.isValidElement(u) ? u.props.children : null : p);
        return /* @__PURE__ */ S.jsx(t, { ...a, ref: o, children: T.isValidElement(u) ? T.cloneElement(u, void 0, d) : null });
      }
      return /* @__PURE__ */ S.jsx(t, { ...a, ref: o, children: i });
    });
    return n.displayName = `${e}.Slot`, n;
  }
  // @__NO_SIDE_EFFECTS__
  function VQ(e) {
    const t = T.forwardRef((n, r) => {
      const { children: o, ...i } = n;
      if (T.isValidElement(o)) {
        const a = GQ(o), s = WQ(i, o.props);
        return o.type !== T.Fragment && (s.ref = r ? lb(r, a) : a), T.cloneElement(o, s);
      }
      return T.Children.count(o) > 1 ? T.Children.only(null) : null;
    });
    return t.displayName = `${e}.SlotClone`, t;
  }
  var HQ = Symbol("radix.slottable");
  function qQ(e) {
    return T.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === HQ;
  }
  function WQ(e, t) {
    const n = { ...t };
    for (const r in t) {
      const o = e[r], i = t[r];
      /^on[A-Z]/.test(r) ? o && i ? n[r] = (...s) => {
        const l = i(...s);
        return o(...s), l;
      } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...i } : r === "className" && (n[r] = [o, i].filter(Boolean).join(" "));
    }
    return { ...e, ...n };
  }
  function GQ(e) {
    let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
    return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
  }
  var KQ = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "select",
    "span",
    "svg",
    "ul"
  ], xt = KQ.reduce((e, t) => {
    const n = /* @__PURE__ */ nf(`Primitive.${t}`), r = T.forwardRef((o, i) => {
      const { asChild: a, ...s } = o, l = a ? n : t;
      return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ S.jsx(l, { ...s, ref: i });
    });
    return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
  }, {});
  function Ek(e, t) {
    e && gc.flushSync(() => e.dispatchEvent(t));
  }
  function Vr(e) {
    const t = T.useRef(e);
    return T.useEffect(() => {
      t.current = e;
    }), T.useMemo(() => (...n) => t.current?.(...n), []);
  }
  function YQ(e, t = globalThis?.document) {
    const n = Vr(e);
    T.useEffect(() => {
      const r = (o) => {
        o.key === "Escape" && n(o);
      };
      return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
    }, [n, t]);
  }
  var XQ = "DismissableLayer", mE = "dismissableLayer.update", ZQ = "dismissableLayer.pointerDownOutside", QQ = "dismissableLayer.focusOutside", i$, bF = T.createContext({
    layers: /* @__PURE__ */ new Set(),
    layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
    branches: /* @__PURE__ */ new Set()
  }), jh = T.forwardRef(
    (e, t) => {
      const {
        disableOutsidePointerEvents: n = !1,
        onEscapeKeyDown: r,
        onPointerDownOutside: o,
        onFocusOutside: i,
        onInteractOutside: a,
        onDismiss: s,
        ...l
      } = e, u = T.useContext(bF), [d, p] = T.useState(null), h = d?.ownerDocument ?? globalThis?.document, [, g] = T.useState({}), y = an(t, (A) => p(A)), b = Array.from(u.layers), [v] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1), x = b.indexOf(v), E = d ? b.indexOf(d) : -1, _ = u.layersWithOutsidePointerEventsDisabled.size > 0, C = E >= x, k = eJ((A) => {
        const M = A.target, I = [...u.branches].some((D) => D.contains(M));
        !C || I || (o?.(A), a?.(A), A.defaultPrevented || s?.());
      }, h), R = tJ((A) => {
        const M = A.target;
        [...u.branches].some((D) => D.contains(M)) || (i?.(A), a?.(A), A.defaultPrevented || s?.());
      }, h);
      return YQ((A) => {
        E === u.layers.size - 1 && (r?.(A), !A.defaultPrevented && s && (A.preventDefault(), s()));
      }, h), T.useEffect(() => {
        if (d)
          return n && (u.layersWithOutsidePointerEventsDisabled.size === 0 && (i$ = h.body.style.pointerEvents, h.body.style.pointerEvents = "none"), u.layersWithOutsidePointerEventsDisabled.add(d)), u.layers.add(d), a$(), () => {
            n && u.layersWithOutsidePointerEventsDisabled.size === 1 && (h.body.style.pointerEvents = i$);
          };
      }, [d, h, n, u]), T.useEffect(() => () => {
        d && (u.layers.delete(d), u.layersWithOutsidePointerEventsDisabled.delete(d), a$());
      }, [d, u]), T.useEffect(() => {
        const A = () => g({});
        return document.addEventListener(mE, A), () => document.removeEventListener(mE, A);
      }, []), /* @__PURE__ */ S.jsx(
        xt.div,
        {
          ...l,
          ref: y,
          style: {
            pointerEvents: _ ? C ? "auto" : "none" : void 0,
            ...e.style
          },
          onFocusCapture: Fe(e.onFocusCapture, R.onFocusCapture),
          onBlurCapture: Fe(e.onBlurCapture, R.onBlurCapture),
          onPointerDownCapture: Fe(
            e.onPointerDownCapture,
            k.onPointerDownCapture
          )
        }
      );
    }
  );
  jh.displayName = XQ;
  var JQ = "DismissableLayerBranch", xF = T.forwardRef((e, t) => {
    const n = T.useContext(bF), r = T.useRef(null), o = an(t, r);
    return T.useEffect(() => {
      const i = r.current;
      if (i)
        return n.branches.add(i), () => {
          n.branches.delete(i);
        };
    }, [n.branches]), /* @__PURE__ */ S.jsx(xt.div, { ...e, ref: o });
  });
  xF.displayName = JQ;
  function eJ(e, t = globalThis?.document) {
    const n = Vr(e), r = T.useRef(!1), o = T.useRef(() => {
    });
    return T.useEffect(() => {
      const i = (s) => {
        if (s.target && !r.current) {
          let l = function() {
            wF(
              ZQ,
              n,
              u,
              { discrete: !0 }
            );
          };
          const u = { originalEvent: s };
          s.pointerType === "touch" ? (t.removeEventListener("click", o.current), o.current = l, t.addEventListener("click", o.current, { once: !0 })) : l();
        } else
          t.removeEventListener("click", o.current);
        r.current = !1;
      }, a = window.setTimeout(() => {
        t.addEventListener("pointerdown", i);
      }, 0);
      return () => {
        window.clearTimeout(a), t.removeEventListener("pointerdown", i), t.removeEventListener("click", o.current);
      };
    }, [t, n]), {
      // ensures we check React component tree (not just DOM tree)
      onPointerDownCapture: () => r.current = !0
    };
  }
  function tJ(e, t = globalThis?.document) {
    const n = Vr(e), r = T.useRef(!1);
    return T.useEffect(() => {
      const o = (i) => {
        i.target && !r.current && wF(QQ, n, { originalEvent: i }, {
          discrete: !1
        });
      };
      return t.addEventListener("focusin", o), () => t.removeEventListener("focusin", o);
    }, [t, n]), {
      onFocusCapture: () => r.current = !0,
      onBlurCapture: () => r.current = !1
    };
  }
  function a$() {
    const e = new CustomEvent(mE);
    document.dispatchEvent(e);
  }
  function wF(e, t, n, { discrete: r }) {
    const o = n.originalEvent.target, i = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
    t && o.addEventListener(e, t, { once: !0 }), r ? Ek(o, i) : o.dispatchEvent(i);
  }
  var nJ = jh, rJ = xF, lS = "focusScope.autoFocusOnMount", cS = "focusScope.autoFocusOnUnmount", s$ = { bubbles: !1, cancelable: !0 }, oJ = "FocusScope", cb = T.forwardRef((e, t) => {
    const {
      loop: n = !1,
      trapped: r = !1,
      onMountAutoFocus: o,
      onUnmountAutoFocus: i,
      ...a
    } = e, [s, l] = T.useState(null), u = Vr(o), d = Vr(i), p = T.useRef(null), h = an(t, (b) => l(b)), g = T.useRef({
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    }).current;
    T.useEffect(() => {
      if (r) {
        let b = function(_) {
          if (g.paused || !s) return;
          const C = _.target;
          s.contains(C) ? p.current = C : Is(p.current, { select: !0 });
        }, v = function(_) {
          if (g.paused || !s) return;
          const C = _.relatedTarget;
          C !== null && (s.contains(C) || Is(p.current, { select: !0 }));
        }, x = function(_) {
          if (document.activeElement === document.body)
            for (const k of _)
              k.removedNodes.length > 0 && Is(s);
        };
        document.addEventListener("focusin", b), document.addEventListener("focusout", v);
        const E = new MutationObserver(x);
        return s && E.observe(s, { childList: !0, subtree: !0 }), () => {
          document.removeEventListener("focusin", b), document.removeEventListener("focusout", v), E.disconnect();
        };
      }
    }, [r, s, g.paused]), T.useEffect(() => {
      if (s) {
        c$.add(g);
        const b = document.activeElement;
        if (!s.contains(b)) {
          const x = new CustomEvent(lS, s$);
          s.addEventListener(lS, u), s.dispatchEvent(x), x.defaultPrevented || (iJ(uJ(SF(s)), { select: !0 }), document.activeElement === b && Is(s));
        }
        return () => {
          s.removeEventListener(lS, u), setTimeout(() => {
            const x = new CustomEvent(cS, s$);
            s.addEventListener(cS, d), s.dispatchEvent(x), x.defaultPrevented || Is(b ?? document.body, { select: !0 }), s.removeEventListener(cS, d), c$.remove(g);
          }, 0);
        };
      }
    }, [s, u, d, g]);
    const y = T.useCallback(
      (b) => {
        if (!n && !r || g.paused) return;
        const v = b.key === "Tab" && !b.altKey && !b.ctrlKey && !b.metaKey, x = document.activeElement;
        if (v && x) {
          const E = b.currentTarget, [_, C] = aJ(E);
          _ && C ? !b.shiftKey && x === C ? (b.preventDefault(), n && Is(_, { select: !0 })) : b.shiftKey && x === _ && (b.preventDefault(), n && Is(C, { select: !0 })) : x === E && b.preventDefault();
        }
      },
      [n, r, g.paused]
    );
    return /* @__PURE__ */ S.jsx(xt.div, { tabIndex: -1, ...a, ref: h, onKeyDown: y });
  });
  cb.displayName = oJ;
  function iJ(e, { select: t = !1 } = {}) {
    const n = document.activeElement;
    for (const r of e)
      if (Is(r, { select: t }), document.activeElement !== n) return;
  }
  function aJ(e) {
    const t = SF(e), n = l$(t, e), r = l$(t.reverse(), e);
    return [n, r];
  }
  function SF(e) {
    const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const o = r.tagName === "INPUT" && r.type === "hidden";
        return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    for (; n.nextNode(); ) t.push(n.currentNode);
    return t;
  }
  function l$(e, t) {
    for (const n of e)
      if (!sJ(n, { upTo: t })) return n;
  }
  function sJ(e, { upTo: t }) {
    if (getComputedStyle(e).visibility === "hidden") return !0;
    for (; e; ) {
      if (t !== void 0 && e === t) return !1;
      if (getComputedStyle(e).display === "none") return !0;
      e = e.parentElement;
    }
    return !1;
  }
  function lJ(e) {
    return e instanceof HTMLInputElement && "select" in e;
  }
  function Is(e, { select: t = !1 } = {}) {
    if (e && e.focus) {
      const n = document.activeElement;
      e.focus({ preventScroll: !0 }), e !== n && lJ(e) && t && e.select();
    }
  }
  var c$ = cJ();
  function cJ() {
    let e = [];
    return {
      add(t) {
        const n = e[0];
        t !== n && n?.pause(), e = u$(e, t), e.unshift(t);
      },
      remove(t) {
        e = u$(e, t), e[0]?.resume();
      }
    };
  }
  function u$(e, t) {
    const n = [...e], r = n.indexOf(t);
    return r !== -1 && n.splice(r, 1), n;
  }
  function uJ(e) {
    return e.filter((t) => t.tagName !== "A");
  }
  var fJ = "Portal", ub = T.forwardRef((e, t) => {
    const { container: n, ...r } = e, [o, i] = T.useState(!1);
    Fa(() => i(!0), []);
    const a = n || o && globalThis?.document?.body;
    return a ? up.createPortal(/* @__PURE__ */ S.jsx(xt.div, { ...r, ref: t }), a) : null;
  });
  ub.displayName = fJ;
  function dJ(e, t) {
    return T.useReducer((n, r) => t[n][r] ?? n, e);
  }
  var ei = (e) => {
    const { present: t, children: n } = e, r = pJ(t), o = typeof n == "function" ? n({ present: r.isPresent }) : T.Children.only(n), i = an(r.ref, hJ(o));
    return typeof n == "function" || r.isPresent ? T.cloneElement(o, { ref: i }) : null;
  };
  ei.displayName = "Presence";
  function pJ(e) {
    const [t, n] = T.useState(), r = T.useRef(null), o = T.useRef(e), i = T.useRef("none"), a = e ? "mounted" : "unmounted", [s, l] = dJ(a, {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
        MOUNT: "mounted",
        ANIMATION_END: "unmounted"
      },
      unmounted: {
        MOUNT: "mounted"
      }
    });
    return T.useEffect(() => {
      const u = Dg(r.current);
      i.current = s === "mounted" ? u : "none";
    }, [s]), Fa(() => {
      const u = r.current, d = o.current;
      if (d !== e) {
        const h = i.current, g = Dg(u);
        e ? l("MOUNT") : g === "none" || u?.display === "none" ? l("UNMOUNT") : l(d && h !== g ? "ANIMATION_OUT" : "UNMOUNT"), o.current = e;
      }
    }, [e, l]), Fa(() => {
      if (t) {
        let u;
        const d = t.ownerDocument.defaultView ?? window, p = (g) => {
          const b = Dg(r.current).includes(g.animationName);
          if (g.target === t && b && (l("ANIMATION_END"), !o.current)) {
            const v = t.style.animationFillMode;
            t.style.animationFillMode = "forwards", u = d.setTimeout(() => {
              t.style.animationFillMode === "forwards" && (t.style.animationFillMode = v);
            });
          }
        }, h = (g) => {
          g.target === t && (i.current = Dg(r.current));
        };
        return t.addEventListener("animationstart", h), t.addEventListener("animationcancel", p), t.addEventListener("animationend", p), () => {
          d.clearTimeout(u), t.removeEventListener("animationstart", h), t.removeEventListener("animationcancel", p), t.removeEventListener("animationend", p);
        };
      } else
        l("ANIMATION_END");
    }, [t, l]), {
      isPresent: ["mounted", "unmountSuspended"].includes(s),
      ref: T.useCallback((u) => {
        r.current = u ? getComputedStyle(u) : null, n(u);
      }, [])
    };
  }
  function Dg(e) {
    return e?.animationName || "none";
  }
  function hJ(e) {
    let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
    return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
  }
  var uS = 0;
  function Ck() {
    T.useEffect(() => {
      const e = document.querySelectorAll("[data-radix-focus-guard]");
      return document.body.insertAdjacentElement("afterbegin", e[0] ?? f$()), document.body.insertAdjacentElement("beforeend", e[1] ?? f$()), uS++, () => {
        uS === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), uS--;
      };
    }, []);
  }
  function f$() {
    const e = document.createElement("span");
    return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
  }
  var Ti = function() {
    return Ti = Object.assign || function(t) {
      for (var n, r = 1, o = arguments.length; r < o; r++) {
        n = arguments[r];
        for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
      }
      return t;
    }, Ti.apply(this, arguments);
  };
  function _F(e, t) {
    var n = {};
    for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
      for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
        t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
    return n;
  }
  function dv(e, t, n) {
    if (n || arguments.length === 2) for (var r = 0, o = t.length, i; r < o; r++)
      (i || !(r in t)) && (i || (i = Array.prototype.slice.call(t, 0, r)), i[r] = t[r]);
    return e.concat(i || Array.prototype.slice.call(t));
  }
  var pv = "right-scroll-bar-position", hv = "width-before-scroll-bar", mJ = "with-scroll-bars-hidden", gJ = "--removed-body-scroll-bar-size";
  function fS(e, t) {
    return typeof e == "function" ? e(t) : e && (e.current = t), e;
  }
  function yJ(e, t) {
    var n = T.useState(function() {
      return {
        // value
        value: e,
        // last callback
        callback: t,
        // "memoized" public interface
        facade: {
          get current() {
            return n.value;
          },
          set current(r) {
            var o = n.value;
            o !== r && (n.value = r, n.callback(r, o));
          }
        }
      };
    })[0];
    return n.callback = t, n.facade;
  }
  var vJ = typeof window < "u" ? T.useLayoutEffect : T.useEffect, d$ = /* @__PURE__ */ new WeakMap();
  function bJ(e, t) {
    var n = yJ(null, function(r) {
      return e.forEach(function(o) {
        return fS(o, r);
      });
    });
    return vJ(function() {
      var r = d$.get(n);
      if (r) {
        var o = new Set(r), i = new Set(e), a = n.current;
        o.forEach(function(s) {
          i.has(s) || fS(s, null);
        }), i.forEach(function(s) {
          o.has(s) || fS(s, a);
        });
      }
      d$.set(n, e);
    }, [e]), n;
  }
  function xJ(e) {
    return e;
  }
  function wJ(e, t) {
    t === void 0 && (t = xJ);
    var n = [], r = !1, o = {
      read: function() {
        if (r)
          throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
        return n.length ? n[n.length - 1] : e;
      },
      useMedium: function(i) {
        var a = t(i, r);
        return n.push(a), function() {
          n = n.filter(function(s) {
            return s !== a;
          });
        };
      },
      assignSyncMedium: function(i) {
        for (r = !0; n.length; ) {
          var a = n;
          n = [], a.forEach(i);
        }
        n = {
          push: function(s) {
            return i(s);
          },
          filter: function() {
            return n;
          }
        };
      },
      assignMedium: function(i) {
        r = !0;
        var a = [];
        if (n.length) {
          var s = n;
          n = [], s.forEach(i), a = n;
        }
        var l = function() {
          var d = a;
          a = [], d.forEach(i);
        }, u = function() {
          return Promise.resolve().then(l);
        };
        u(), n = {
          push: function(d) {
            a.push(d), u();
          },
          filter: function(d) {
            return a = a.filter(d), n;
          }
        };
      }
    };
    return o;
  }
  function SJ(e) {
    e === void 0 && (e = {});
    var t = wJ(null);
    return t.options = Ti({ async: !0, ssr: !1 }, e), t;
  }
  var EF = function(e) {
    var t = e.sideCar, n = _F(e, ["sideCar"]);
    if (!t)
      throw new Error("Sidecar: please provide `sideCar` property to import the right car");
    var r = t.read();
    if (!r)
      throw new Error("Sidecar medium not found");
    return T.createElement(r, Ti({}, n));
  };
  EF.isSideCarExport = !0;
  function _J(e, t) {
    return e.useMedium(t), EF;
  }
  var CF = SJ(), dS = function() {
  }, fb = T.forwardRef(function(e, t) {
    var n = T.useRef(null), r = T.useState({
      onScrollCapture: dS,
      onWheelCapture: dS,
      onTouchMoveCapture: dS
    }), o = r[0], i = r[1], a = e.forwardProps, s = e.children, l = e.className, u = e.removeScrollBar, d = e.enabled, p = e.shards, h = e.sideCar, g = e.noRelative, y = e.noIsolation, b = e.inert, v = e.allowPinchZoom, x = e.as, E = x === void 0 ? "div" : x, _ = e.gapMode, C = _F(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), k = h, R = bJ([n, t]), A = Ti(Ti({}, C), o);
    return T.createElement(
      T.Fragment,
      null,
      d && T.createElement(k, { sideCar: CF, removeScrollBar: u, shards: p, noRelative: g, noIsolation: y, inert: b, setCallbacks: i, allowPinchZoom: !!v, lockRef: n, gapMode: _ }),
      a ? T.cloneElement(T.Children.only(s), Ti(Ti({}, A), { ref: R })) : T.createElement(E, Ti({}, A, { className: l, ref: R }), s)
    );
  });
  fb.defaultProps = {
    enabled: !0,
    removeScrollBar: !0,
    inert: !1
  };
  fb.classNames = {
    fullWidth: hv,
    zeroRight: pv
  };
  var EJ = function() {
    if (typeof __webpack_nonce__ < "u")
      return __webpack_nonce__;
  };
  function CJ() {
    if (!document)
      return null;
    var e = document.createElement("style");
    e.type = "text/css";
    var t = EJ();
    return t && e.setAttribute("nonce", t), e;
  }
  function kJ(e, t) {
    e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
  }
  function TJ(e) {
    var t = document.head || document.getElementsByTagName("head")[0];
    t.appendChild(e);
  }
  var RJ = function() {
    var e = 0, t = null;
    return {
      add: function(n) {
        e == 0 && (t = CJ()) && (kJ(t, n), TJ(t)), e++;
      },
      remove: function() {
        e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
      }
    };
  }, OJ = function() {
    var e = RJ();
    return function(t, n) {
      T.useEffect(function() {
        return e.add(t), function() {
          e.remove();
        };
      }, [t && n]);
    };
  }, kF = function() {
    var e = OJ(), t = function(n) {
      var r = n.styles, o = n.dynamic;
      return e(r, o), null;
    };
    return t;
  }, AJ = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
  }, pS = function(e) {
    return parseInt(e || "", 10) || 0;
  }, NJ = function(e) {
    var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], o = t[e === "padding" ? "paddingRight" : "marginRight"];
    return [pS(n), pS(r), pS(o)];
  }, MJ = function(e) {
    if (e === void 0 && (e = "margin"), typeof window > "u")
      return AJ;
    var t = NJ(e), n = document.documentElement.clientWidth, r = window.innerWidth;
    return {
      left: t[0],
      top: t[1],
      right: t[2],
      gap: Math.max(0, r - n + t[2] - t[0])
    };
  }, PJ = kF(), qu = "data-scroll-locked", $J = function(e, t, n, r) {
    var o = e.left, i = e.top, a = e.right, s = e.gap;
    return n === void 0 && (n = "margin"), `
  .`.concat(mJ, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(s, "px ").concat(r, `;
  }
  body[`).concat(qu, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
      t && "position: relative ".concat(r, ";"),
      n === "margin" && `
    padding-left: `.concat(o, `px;
    padding-top: `).concat(i, `px;
    padding-right: `).concat(a, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(s, "px ").concat(r, `;
    `),
      n === "padding" && "padding-right: ".concat(s, "px ").concat(r, ";")
    ].filter(Boolean).join(""), `
  }

  .`).concat(pv, ` {
    right: `).concat(s, "px ").concat(r, `;
  }

  .`).concat(hv, ` {
    margin-right: `).concat(s, "px ").concat(r, `;
  }

  .`).concat(pv, " .").concat(pv, ` {
    right: 0 `).concat(r, `;
  }

  .`).concat(hv, " .").concat(hv, ` {
    margin-right: 0 `).concat(r, `;
  }

  body[`).concat(qu, `] {
    `).concat(gJ, ": ").concat(s, `px;
  }
`);
  }, p$ = function() {
    var e = parseInt(document.body.getAttribute(qu) || "0", 10);
    return isFinite(e) ? e : 0;
  }, IJ = function() {
    T.useEffect(function() {
      return document.body.setAttribute(qu, (p$() + 1).toString()), function() {
        var e = p$() - 1;
        e <= 0 ? document.body.removeAttribute(qu) : document.body.setAttribute(qu, e.toString());
      };
    }, []);
  }, jJ = function(e) {
    var t = e.noRelative, n = e.noImportant, r = e.gapMode, o = r === void 0 ? "margin" : r;
    IJ();
    var i = T.useMemo(function() {
      return MJ(o);
    }, [o]);
    return T.createElement(PJ, { styles: $J(i, !t, o, n ? "" : "!important") });
  }, gE = !1;
  if (typeof window < "u")
    try {
      var Fg = Object.defineProperty({}, "passive", {
        get: function() {
          return gE = !0, !0;
        }
      });
      window.addEventListener("test", Fg, Fg), window.removeEventListener("test", Fg, Fg);
    } catch {
      gE = !1;
    }
  var vu = gE ? { passive: !1 } : !1, DJ = function(e) {
    return e.tagName === "TEXTAREA";
  }, TF = function(e, t) {
    if (!(e instanceof Element))
      return !1;
    var n = window.getComputedStyle(e);
    return (
      // not-not-scrollable
      n[t] !== "hidden" && // contains scroll inside self
      !(n.overflowY === n.overflowX && !DJ(e) && n[t] === "visible")
    );
  }, FJ = function(e) {
    return TF(e, "overflowY");
  }, LJ = function(e) {
    return TF(e, "overflowX");
  }, h$ = function(e, t) {
    var n = t.ownerDocument, r = t;
    do {
      typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
      var o = RF(e, r);
      if (o) {
        var i = OF(e, r), a = i[1], s = i[2];
        if (a > s)
          return !0;
      }
      r = r.parentNode;
    } while (r && r !== n.body);
    return !1;
  }, zJ = function(e) {
    var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
    return [
      t,
      n,
      r
    ];
  }, BJ = function(e) {
    var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
    return [
      t,
      n,
      r
    ];
  }, RF = function(e, t) {
    return e === "v" ? FJ(t) : LJ(t);
  }, OF = function(e, t) {
    return e === "v" ? zJ(t) : BJ(t);
  }, UJ = function(e, t) {
    return e === "h" && t === "rtl" ? -1 : 1;
  }, VJ = function(e, t, n, r, o) {
    var i = UJ(e, window.getComputedStyle(t).direction), a = i * r, s = n.target, l = t.contains(s), u = !1, d = a > 0, p = 0, h = 0;
    do {
      if (!s)
        break;
      var g = OF(e, s), y = g[0], b = g[1], v = g[2], x = b - v - i * y;
      (y || x) && RF(e, s) && (p += x, h += y);
      var E = s.parentNode;
      s = E && E.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? E.host : E;
    } while (
      // portaled content
      !l && s !== document.body || // self content
      l && (t.contains(s) || t === s)
    );
    return (d && Math.abs(p) < 1 || !d && Math.abs(h) < 1) && (u = !0), u;
  }, Lg = function(e) {
    return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
  }, m$ = function(e) {
    return [e.deltaX, e.deltaY];
  }, g$ = function(e) {
    return e && "current" in e ? e.current : e;
  }, HJ = function(e, t) {
    return e[0] === t[0] && e[1] === t[1];
  }, qJ = function(e) {
    return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
  }, WJ = 0, bu = [];
  function GJ(e) {
    var t = T.useRef([]), n = T.useRef([0, 0]), r = T.useRef(), o = T.useState(WJ++)[0], i = T.useState(kF)[0], a = T.useRef(e);
    T.useEffect(function() {
      a.current = e;
    }, [e]), T.useEffect(function() {
      if (e.inert) {
        document.body.classList.add("block-interactivity-".concat(o));
        var b = dv([e.lockRef.current], (e.shards || []).map(g$), !0).filter(Boolean);
        return b.forEach(function(v) {
          return v.classList.add("allow-interactivity-".concat(o));
        }), function() {
          document.body.classList.remove("block-interactivity-".concat(o)), b.forEach(function(v) {
            return v.classList.remove("allow-interactivity-".concat(o));
          });
        };
      }
    }, [e.inert, e.lockRef.current, e.shards]);
    var s = T.useCallback(function(b, v) {
      if ("touches" in b && b.touches.length === 2 || b.type === "wheel" && b.ctrlKey)
        return !a.current.allowPinchZoom;
      var x = Lg(b), E = n.current, _ = "deltaX" in b ? b.deltaX : E[0] - x[0], C = "deltaY" in b ? b.deltaY : E[1] - x[1], k, R = b.target, A = Math.abs(_) > Math.abs(C) ? "h" : "v";
      if ("touches" in b && A === "h" && R.type === "range")
        return !1;
      var M = h$(A, R);
      if (!M)
        return !0;
      if (M ? k = A : (k = A === "v" ? "h" : "v", M = h$(A, R)), !M)
        return !1;
      if (!r.current && "changedTouches" in b && (_ || C) && (r.current = k), !k)
        return !0;
      var I = r.current || k;
      return VJ(I, v, b, I === "h" ? _ : C);
    }, []), l = T.useCallback(function(b) {
      var v = b;
      if (!(!bu.length || bu[bu.length - 1] !== i)) {
        var x = "deltaY" in v ? m$(v) : Lg(v), E = t.current.filter(function(k) {
          return k.name === v.type && (k.target === v.target || v.target === k.shadowParent) && HJ(k.delta, x);
        })[0];
        if (E && E.should) {
          v.cancelable && v.preventDefault();
          return;
        }
        if (!E) {
          var _ = (a.current.shards || []).map(g$).filter(Boolean).filter(function(k) {
            return k.contains(v.target);
          }), C = _.length > 0 ? s(v, _[0]) : !a.current.noIsolation;
          C && v.cancelable && v.preventDefault();
        }
      }
    }, []), u = T.useCallback(function(b, v, x, E) {
      var _ = { name: b, delta: v, target: x, should: E, shadowParent: KJ(x) };
      t.current.push(_), setTimeout(function() {
        t.current = t.current.filter(function(C) {
          return C !== _;
        });
      }, 1);
    }, []), d = T.useCallback(function(b) {
      n.current = Lg(b), r.current = void 0;
    }, []), p = T.useCallback(function(b) {
      u(b.type, m$(b), b.target, s(b, e.lockRef.current));
    }, []), h = T.useCallback(function(b) {
      u(b.type, Lg(b), b.target, s(b, e.lockRef.current));
    }, []);
    T.useEffect(function() {
      return bu.push(i), e.setCallbacks({
        onScrollCapture: p,
        onWheelCapture: p,
        onTouchMoveCapture: h
      }), document.addEventListener("wheel", l, vu), document.addEventListener("touchmove", l, vu), document.addEventListener("touchstart", d, vu), function() {
        bu = bu.filter(function(b) {
          return b !== i;
        }), document.removeEventListener("wheel", l, vu), document.removeEventListener("touchmove", l, vu), document.removeEventListener("touchstart", d, vu);
      };
    }, []);
    var g = e.removeScrollBar, y = e.inert;
    return T.createElement(
      T.Fragment,
      null,
      y ? T.createElement(i, { styles: qJ(o) }) : null,
      g ? T.createElement(jJ, { noRelative: e.noRelative, gapMode: e.gapMode }) : null
    );
  }
  function KJ(e) {
    for (var t = null; e !== null; )
      e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
    return t;
  }
  const YJ = _J(CF, GJ);
  var db = T.forwardRef(function(e, t) {
    return T.createElement(fb, Ti({}, e, { ref: t, sideCar: YJ }));
  });
  db.classNames = fb.classNames;
  var XJ = function(e) {
    if (typeof document > "u")
      return null;
    var t = Array.isArray(e) ? e[0] : e;
    return t.ownerDocument.body;
  }, xu = /* @__PURE__ */ new WeakMap(), zg = /* @__PURE__ */ new WeakMap(), Bg = {}, hS = 0, AF = function(e) {
    return e && (e.host || AF(e.parentNode));
  }, ZJ = function(e, t) {
    return t.map(function(n) {
      if (e.contains(n))
        return n;
      var r = AF(n);
      return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
    }).filter(function(n) {
      return !!n;
    });
  }, QJ = function(e, t, n, r) {
    var o = ZJ(t, Array.isArray(e) ? e : [e]);
    Bg[n] || (Bg[n] = /* @__PURE__ */ new WeakMap());
    var i = Bg[n], a = [], s = /* @__PURE__ */ new Set(), l = new Set(o), u = function(p) {
      !p || s.has(p) || (s.add(p), u(p.parentNode));
    };
    o.forEach(u);
    var d = function(p) {
      !p || l.has(p) || Array.prototype.forEach.call(p.children, function(h) {
        if (s.has(h))
          d(h);
        else
          try {
            var g = h.getAttribute(r), y = g !== null && g !== "false", b = (xu.get(h) || 0) + 1, v = (i.get(h) || 0) + 1;
            xu.set(h, b), i.set(h, v), a.push(h), b === 1 && y && zg.set(h, !0), v === 1 && h.setAttribute(n, "true"), y || h.setAttribute(r, "true");
          } catch (x) {
            console.error("aria-hidden: cannot operate on ", h, x);
          }
      });
    };
    return d(t), s.clear(), hS++, function() {
      a.forEach(function(p) {
        var h = xu.get(p) - 1, g = i.get(p) - 1;
        xu.set(p, h), i.set(p, g), h || (zg.has(p) || p.removeAttribute(r), zg.delete(p)), g || p.removeAttribute(n);
      }), hS--, hS || (xu = /* @__PURE__ */ new WeakMap(), xu = /* @__PURE__ */ new WeakMap(), zg = /* @__PURE__ */ new WeakMap(), Bg = {});
    };
  }, kk = function(e, t, n) {
    n === void 0 && (n = "data-aria-hidden");
    var r = Array.from(Array.isArray(e) ? e : [e]), o = XJ(e);
    return o ? (r.push.apply(r, Array.from(o.querySelectorAll("[aria-live], script"))), QJ(r, o, n, "aria-hidden")) : function() {
      return null;
    };
  }, pb = "Dialog", [NF, zLe] = Yi(pb), [JJ, ti] = NF(pb), MF = (e) => {
    const {
      __scopeDialog: t,
      children: n,
      open: r,
      defaultOpen: o,
      onOpenChange: i,
      modal: a = !0
    } = e, s = T.useRef(null), l = T.useRef(null), [u, d] = ll({
      prop: r,
      defaultProp: o ?? !1,
      onChange: i,
      caller: pb
    });
    return /* @__PURE__ */ S.jsx(
      JJ,
      {
        scope: t,
        triggerRef: s,
        contentRef: l,
        contentId: Bi(),
        titleId: Bi(),
        descriptionId: Bi(),
        open: u,
        onOpenChange: d,
        onOpenToggle: T.useCallback(() => d((p) => !p), [d]),
        modal: a,
        children: n
      }
    );
  };
  MF.displayName = pb;
  var PF = "DialogTrigger", $F = T.forwardRef(
    (e, t) => {
      const { __scopeDialog: n, ...r } = e, o = ti(PF, n), i = an(t, o.triggerRef);
      return /* @__PURE__ */ S.jsx(
        xt.button,
        {
          type: "button",
          "aria-haspopup": "dialog",
          "aria-expanded": o.open,
          "aria-controls": o.contentId,
          "data-state": Ok(o.open),
          ...r,
          ref: i,
          onClick: Fe(e.onClick, o.onOpenToggle)
        }
      );
    }
  );
  $F.displayName = PF;
  var Tk = "DialogPortal", [eee, IF] = NF(Tk, {
    forceMount: void 0
  }), jF = (e) => {
    const { __scopeDialog: t, forceMount: n, children: r, container: o } = e, i = ti(Tk, t);
    return /* @__PURE__ */ S.jsx(eee, { scope: t, forceMount: n, children: T.Children.map(r, (a) => /* @__PURE__ */ S.jsx(ei, { present: n || i.open, children: /* @__PURE__ */ S.jsx(ub, { asChild: !0, container: o, children: a }) })) });
  };
  jF.displayName = Tk;
  var Hv = "DialogOverlay", DF = T.forwardRef(
    (e, t) => {
      const n = IF(Hv, e.__scopeDialog), { forceMount: r = n.forceMount, ...o } = e, i = ti(Hv, e.__scopeDialog);
      return i.modal ? /* @__PURE__ */ S.jsx(ei, { present: r || i.open, children: /* @__PURE__ */ S.jsx(nee, { ...o, ref: t }) }) : null;
    }
  );
  DF.displayName = Hv;
  var tee = /* @__PURE__ */ nf("DialogOverlay.RemoveScroll"), nee = T.forwardRef(
    (e, t) => {
      const { __scopeDialog: n, ...r } = e, o = ti(Hv, n);
      return (
        // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
        // ie. when `Overlay` and `Content` are siblings
        /* @__PURE__ */ S.jsx(db, { as: tee, allowPinchZoom: !0, shards: [o.contentRef], children: /* @__PURE__ */ S.jsx(
          xt.div,
          {
            "data-state": Ok(o.open),
            ...r,
            ref: t,
            style: { pointerEvents: "auto", ...r.style }
          }
        ) })
      );
    }
  ), nc = "DialogContent", FF = T.forwardRef(
    (e, t) => {
      const n = IF(nc, e.__scopeDialog), { forceMount: r = n.forceMount, ...o } = e, i = ti(nc, e.__scopeDialog);
      return /* @__PURE__ */ S.jsx(ei, { present: r || i.open, children: i.modal ? /* @__PURE__ */ S.jsx(ree, { ...o, ref: t }) : /* @__PURE__ */ S.jsx(oee, { ...o, ref: t }) });
    }
  );
  FF.displayName = nc;
  var ree = T.forwardRef(
    (e, t) => {
      const n = ti(nc, e.__scopeDialog), r = T.useRef(null), o = an(t, n.contentRef, r);
      return T.useEffect(() => {
        const i = r.current;
        if (i) return kk(i);
      }, []), /* @__PURE__ */ S.jsx(
        LF,
        {
          ...e,
          ref: o,
          trapFocus: n.open,
          disableOutsidePointerEvents: !0,
          onCloseAutoFocus: Fe(e.onCloseAutoFocus, (i) => {
            i.preventDefault(), n.triggerRef.current?.focus();
          }),
          onPointerDownOutside: Fe(e.onPointerDownOutside, (i) => {
            const a = i.detail.originalEvent, s = a.button === 0 && a.ctrlKey === !0;
            (a.button === 2 || s) && i.preventDefault();
          }),
          onFocusOutside: Fe(
            e.onFocusOutside,
            (i) => i.preventDefault()
          )
        }
      );
    }
  ), oee = T.forwardRef(
    (e, t) => {
      const n = ti(nc, e.__scopeDialog), r = T.useRef(!1), o = T.useRef(!1);
      return /* @__PURE__ */ S.jsx(
        LF,
        {
          ...e,
          ref: t,
          trapFocus: !1,
          disableOutsidePointerEvents: !1,
          onCloseAutoFocus: (i) => {
            e.onCloseAutoFocus?.(i), i.defaultPrevented || (r.current || n.triggerRef.current?.focus(), i.preventDefault()), r.current = !1, o.current = !1;
          },
          onInteractOutside: (i) => {
            e.onInteractOutside?.(i), i.defaultPrevented || (r.current = !0, i.detail.originalEvent.type === "pointerdown" && (o.current = !0));
            const a = i.target;
            n.triggerRef.current?.contains(a) && i.preventDefault(), i.detail.originalEvent.type === "focusin" && o.current && i.preventDefault();
          }
        }
      );
    }
  ), LF = T.forwardRef(
    (e, t) => {
      const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: o, onCloseAutoFocus: i, ...a } = e, s = ti(nc, n), l = T.useRef(null), u = an(t, l);
      return Ck(), /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
        /* @__PURE__ */ S.jsx(
          cb,
          {
            asChild: !0,
            loop: !0,
            trapped: r,
            onMountAutoFocus: o,
            onUnmountAutoFocus: i,
            children: /* @__PURE__ */ S.jsx(
              jh,
              {
                role: "dialog",
                id: s.contentId,
                "aria-describedby": s.descriptionId,
                "aria-labelledby": s.titleId,
                "data-state": Ok(s.open),
                ...a,
                ref: u,
                onDismiss: () => s.onOpenChange(!1)
              }
            )
          }
        ),
        /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
          /* @__PURE__ */ S.jsx(iee, { titleId: s.titleId }),
          /* @__PURE__ */ S.jsx(see, { contentRef: l, descriptionId: s.descriptionId })
        ] })
      ] });
    }
  ), Rk = "DialogTitle", zF = T.forwardRef(
    (e, t) => {
      const { __scopeDialog: n, ...r } = e, o = ti(Rk, n);
      return /* @__PURE__ */ S.jsx(xt.h2, { id: o.titleId, ...r, ref: t });
    }
  );
  zF.displayName = Rk;
  var BF = "DialogDescription", UF = T.forwardRef(
    (e, t) => {
      const { __scopeDialog: n, ...r } = e, o = ti(BF, n);
      return /* @__PURE__ */ S.jsx(xt.p, { id: o.descriptionId, ...r, ref: t });
    }
  );
  UF.displayName = BF;
  var VF = "DialogClose", HF = T.forwardRef(
    (e, t) => {
      const { __scopeDialog: n, ...r } = e, o = ti(VF, n);
      return /* @__PURE__ */ S.jsx(
        xt.button,
        {
          type: "button",
          ...r,
          ref: t,
          onClick: Fe(e.onClick, () => o.onOpenChange(!1))
        }
      );
    }
  );
  HF.displayName = VF;
  function Ok(e) {
    return e ? "open" : "closed";
  }
  var qF = "DialogTitleWarning", [BLe, WF] = jQ(qF, {
    contentName: nc,
    titleName: Rk,
    docsSlug: "dialog"
  }), iee = ({ titleId: e }) => {
    const t = WF(qF), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
    return T.useEffect(() => {
      e && (document.getElementById(e) || console.error(n));
    }, [n, e]), null;
  }, aee = "DialogDescriptionWarning", see = ({ contentRef: e, descriptionId: t }) => {
    const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${WF(aee).contentName}}.`;
    return T.useEffect(() => {
      const o = e.current?.getAttribute("aria-describedby");
      t && o && (document.getElementById(t) || console.warn(r));
    }, [r, e, t]), null;
  }, lee = MF, cee = $F, uee = jF, fee = DF, dee = FF, pee = zF, hee = UF, GF = HF;
  /*!
   * Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com
   * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
   * Copyright 2025 Fonticons, Inc.
   */
  function yE(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
    return r;
  }
  function mee(e) {
    if (Array.isArray(e)) return e;
  }
  function gee(e) {
    if (Array.isArray(e)) return yE(e);
  }
  function yee(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
  }
  function vee(e, t) {
    for (var n = 0; n < t.length; n++) {
      var r = t[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, KF(r.key), r);
    }
  }
  function bee(e, t, n) {
    return t && vee(e.prototype, t), Object.defineProperty(e, "prototype", {
      writable: !1
    }), e;
  }
  function mv(e, t) {
    var n = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (!n) {
      if (Array.isArray(e) || (n = Ak(e)) || t) {
        n && (e = n);
        var r = 0, o = function() {
        };
        return {
          s: o,
          n: function() {
            return r >= e.length ? {
              done: !0
            } : {
              done: !1,
              value: e[r++]
            };
          },
          e: function(l) {
            throw l;
          },
          f: o
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var i, a = !0, s = !1;
    return {
      s: function() {
        n = n.call(e);
      },
      n: function() {
        var l = n.next();
        return a = l.done, l;
      },
      e: function(l) {
        s = !0, i = l;
      },
      f: function() {
        try {
          a || n.return == null || n.return();
        } finally {
          if (s) throw i;
        }
      }
    };
  }
  function Tt(e, t, n) {
    return (t = KF(t)) in e ? Object.defineProperty(e, t, {
      value: n,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[t] = n, e;
  }
  function xee(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
  }
  function wee(e, t) {
    var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n != null) {
      var r, o, i, a, s = [], l = !0, u = !1;
      try {
        if (i = (n = n.call(e)).next, t === 0) {
          if (Object(n) !== n) return;
          l = !1;
        } else for (; !(l = (r = i.call(n)).done) && (s.push(r.value), s.length !== t); l = !0) ;
      } catch (d) {
        u = !0, o = d;
      } finally {
        try {
          if (!l && n.return != null && (a = n.return(), Object(a) !== a)) return;
        } finally {
          if (u) throw o;
        }
      }
      return s;
    }
  }
  function See() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function _ee() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function y$(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var r = Object.getOwnPropertySymbols(e);
      t && (r = r.filter(function(o) {
        return Object.getOwnPropertyDescriptor(e, o).enumerable;
      })), n.push.apply(n, r);
    }
    return n;
  }
  function Te(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t] != null ? arguments[t] : {};
      t % 2 ? y$(Object(n), !0).forEach(function(r) {
        Tt(e, r, n[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : y$(Object(n)).forEach(function(r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
      });
    }
    return e;
  }
  function hb(e, t) {
    return mee(e) || wee(e, t) || Ak(e, t) || See();
  }
  function Yo(e) {
    return gee(e) || xee(e) || Ak(e) || _ee();
  }
  function Eee(e, t) {
    if (typeof e != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
      var r = n.call(e, t);
      if (typeof r != "object") return r;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (t === "string" ? String : Number)(e);
  }
  function KF(e) {
    var t = Eee(e, "string");
    return typeof t == "symbol" ? t : t + "";
  }
  function qv(e) {
    "@babel/helpers - typeof";
    return qv = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
      return typeof t;
    } : function(t) {
      return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
    }, qv(e);
  }
  function Ak(e, t) {
    if (e) {
      if (typeof e == "string") return yE(e, t);
      var n = {}.toString.call(e).slice(8, -1);
      return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? yE(e, t) : void 0;
    }
  }
  var v$ = function() {
  }, Nk = {}, YF = {}, XF = null, ZF = {
    mark: v$,
    measure: v$
  };
  try {
    typeof window < "u" && (Nk = window), typeof document < "u" && (YF = document), typeof MutationObserver < "u" && (XF = MutationObserver), typeof performance < "u" && (ZF = performance);
  } catch {
  }
  var Cee = Nk.navigator || {}, b$ = Cee.userAgent, x$ = b$ === void 0 ? "" : b$, Qs = Nk, hn = YF, w$ = XF, Ug = ZF;
  Qs.document;
  var Wa = !!hn.documentElement && !!hn.head && typeof hn.addEventListener == "function" && typeof hn.createElement == "function", QF = ~x$.indexOf("MSIE") || ~x$.indexOf("Trident/"), mS, kee = /fa(k|kd|s|r|l|t|d|dr|dl|dt|b|slr|slpr|wsb|tl|ns|nds|es|jr|jfr|jdr|cr|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/, Tee = /Font ?Awesome ?([567 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit|Notdog Duo|Notdog|Chisel|Etch|Thumbprint|Jelly Fill|Jelly Duo|Jelly|Slab Press|Slab|Whiteboard)?.*/i, JF = {
    classic: {
      fa: "solid",
      fas: "solid",
      "fa-solid": "solid",
      far: "regular",
      "fa-regular": "regular",
      fal: "light",
      "fa-light": "light",
      fat: "thin",
      "fa-thin": "thin",
      fab: "brands",
      "fa-brands": "brands"
    },
    duotone: {
      fa: "solid",
      fad: "solid",
      "fa-solid": "solid",
      "fa-duotone": "solid",
      fadr: "regular",
      "fa-regular": "regular",
      fadl: "light",
      "fa-light": "light",
      fadt: "thin",
      "fa-thin": "thin"
    },
    sharp: {
      fa: "solid",
      fass: "solid",
      "fa-solid": "solid",
      fasr: "regular",
      "fa-regular": "regular",
      fasl: "light",
      "fa-light": "light",
      fast: "thin",
      "fa-thin": "thin"
    },
    "sharp-duotone": {
      fa: "solid",
      fasds: "solid",
      "fa-solid": "solid",
      fasdr: "regular",
      "fa-regular": "regular",
      fasdl: "light",
      "fa-light": "light",
      fasdt: "thin",
      "fa-thin": "thin"
    },
    slab: {
      "fa-regular": "regular",
      faslr: "regular"
    },
    "slab-press": {
      "fa-regular": "regular",
      faslpr: "regular"
    },
    thumbprint: {
      "fa-light": "light",
      fatl: "light"
    },
    whiteboard: {
      "fa-semibold": "semibold",
      fawsb: "semibold"
    },
    notdog: {
      "fa-solid": "solid",
      fans: "solid"
    },
    "notdog-duo": {
      "fa-solid": "solid",
      fands: "solid"
    },
    etch: {
      "fa-solid": "solid",
      faes: "solid"
    },
    jelly: {
      "fa-regular": "regular",
      fajr: "regular"
    },
    "jelly-fill": {
      "fa-regular": "regular",
      fajfr: "regular"
    },
    "jelly-duo": {
      "fa-regular": "regular",
      fajdr: "regular"
    },
    chisel: {
      "fa-regular": "regular",
      facr: "regular"
    }
  }, Ree = {
    GROUP: "duotone-group",
    PRIMARY: "primary",
    SECONDARY: "secondary"
  }, eL = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone", "fa-thumbprint", "fa-whiteboard", "fa-notdog", "fa-notdog-duo", "fa-chisel", "fa-etch", "fa-jelly", "fa-jelly-fill", "fa-jelly-duo", "fa-slab", "fa-slab-press"], br = "classic", Dh = "duotone", tL = "sharp", nL = "sharp-duotone", rL = "chisel", oL = "etch", iL = "jelly", aL = "jelly-duo", sL = "jelly-fill", lL = "notdog", cL = "notdog-duo", uL = "slab", fL = "slab-press", dL = "thumbprint", pL = "whiteboard", Oee = "Classic", Aee = "Duotone", Nee = "Sharp", Mee = "Sharp Duotone", Pee = "Chisel", $ee = "Etch", Iee = "Jelly", jee = "Jelly Duo", Dee = "Jelly Fill", Fee = "Notdog", Lee = "Notdog Duo", zee = "Slab", Bee = "Slab Press", Uee = "Thumbprint", Vee = "Whiteboard", hL = [br, Dh, tL, nL, rL, oL, iL, aL, sL, lL, cL, uL, fL, dL, pL];
  mS = {}, Tt(Tt(Tt(Tt(Tt(Tt(Tt(Tt(Tt(Tt(mS, br, Oee), Dh, Aee), tL, Nee), nL, Mee), rL, Pee), oL, $ee), iL, Iee), aL, jee), sL, Dee), lL, Fee), Tt(Tt(Tt(Tt(Tt(mS, cL, Lee), uL, zee), fL, Bee), dL, Uee), pL, Vee);
  var Hee = {
    classic: {
      900: "fas",
      400: "far",
      normal: "far",
      300: "fal",
      100: "fat"
    },
    duotone: {
      900: "fad",
      400: "fadr",
      300: "fadl",
      100: "fadt"
    },
    sharp: {
      900: "fass",
      400: "fasr",
      300: "fasl",
      100: "fast"
    },
    "sharp-duotone": {
      900: "fasds",
      400: "fasdr",
      300: "fasdl",
      100: "fasdt"
    },
    slab: {
      400: "faslr"
    },
    "slab-press": {
      400: "faslpr"
    },
    whiteboard: {
      600: "fawsb"
    },
    thumbprint: {
      300: "fatl"
    },
    notdog: {
      900: "fans"
    },
    "notdog-duo": {
      900: "fands"
    },
    etch: {
      900: "faes"
    },
    chisel: {
      400: "facr"
    },
    jelly: {
      400: "fajr"
    },
    "jelly-fill": {
      400: "fajfr"
    },
    "jelly-duo": {
      400: "fajdr"
    }
  }, qee = {
    "Font Awesome 7 Free": {
      900: "fas",
      400: "far"
    },
    "Font Awesome 7 Pro": {
      900: "fas",
      400: "far",
      normal: "far",
      300: "fal",
      100: "fat"
    },
    "Font Awesome 7 Brands": {
      400: "fab",
      normal: "fab"
    },
    "Font Awesome 7 Duotone": {
      900: "fad",
      400: "fadr",
      normal: "fadr",
      300: "fadl",
      100: "fadt"
    },
    "Font Awesome 7 Sharp": {
      900: "fass",
      400: "fasr",
      normal: "fasr",
      300: "fasl",
      100: "fast"
    },
    "Font Awesome 7 Sharp Duotone": {
      900: "fasds",
      400: "fasdr",
      normal: "fasdr",
      300: "fasdl",
      100: "fasdt"
    },
    "Font Awesome 7 Jelly": {
      400: "fajr",
      normal: "fajr"
    },
    "Font Awesome 7 Jelly Fill": {
      400: "fajfr",
      normal: "fajfr"
    },
    "Font Awesome 7 Jelly Duo": {
      400: "fajdr",
      normal: "fajdr"
    },
    "Font Awesome 7 Slab": {
      400: "faslr",
      normal: "faslr"
    },
    "Font Awesome 7 Slab Press": {
      400: "faslpr",
      normal: "faslpr"
    },
    "Font Awesome 7 Thumbprint": {
      300: "fatl",
      normal: "fatl"
    },
    "Font Awesome 7 Notdog": {
      900: "fans",
      normal: "fans"
    },
    "Font Awesome 7 Notdog Duo": {
      900: "fands",
      normal: "fands"
    },
    "Font Awesome 7 Etch": {
      900: "faes",
      normal: "faes"
    },
    "Font Awesome 7 Chisel": {
      400: "facr",
      normal: "facr"
    },
    "Font Awesome 7 Whiteboard": {
      600: "fawsb",
      normal: "fawsb"
    }
  }, Wee = /* @__PURE__ */ new Map([["classic", {
    defaultShortPrefixId: "fas",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin", "brands"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["duotone", {
    defaultShortPrefixId: "fad",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["sharp", {
    defaultShortPrefixId: "fass",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["sharp-duotone", {
    defaultShortPrefixId: "fasds",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["chisel", {
    defaultShortPrefixId: "facr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["etch", {
    defaultShortPrefixId: "faes",
    defaultStyleId: "solid",
    styleIds: ["solid"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["jelly", {
    defaultShortPrefixId: "fajr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["jelly-duo", {
    defaultShortPrefixId: "fajdr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["jelly-fill", {
    defaultShortPrefixId: "fajfr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["notdog", {
    defaultShortPrefixId: "fans",
    defaultStyleId: "solid",
    styleIds: ["solid"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["notdog-duo", {
    defaultShortPrefixId: "fands",
    defaultStyleId: "solid",
    styleIds: ["solid"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["slab", {
    defaultShortPrefixId: "faslr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["slab-press", {
    defaultShortPrefixId: "faslpr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["thumbprint", {
    defaultShortPrefixId: "fatl",
    defaultStyleId: "light",
    styleIds: ["light"],
    futureStyleIds: [],
    defaultFontWeight: 300
  }], ["whiteboard", {
    defaultShortPrefixId: "fawsb",
    defaultStyleId: "semibold",
    styleIds: ["semibold"],
    futureStyleIds: [],
    defaultFontWeight: 600
  }]]), Gee = {
    chisel: {
      regular: "facr"
    },
    classic: {
      brands: "fab",
      light: "fal",
      regular: "far",
      solid: "fas",
      thin: "fat"
    },
    duotone: {
      light: "fadl",
      regular: "fadr",
      solid: "fad",
      thin: "fadt"
    },
    etch: {
      solid: "faes"
    },
    jelly: {
      regular: "fajr"
    },
    "jelly-duo": {
      regular: "fajdr"
    },
    "jelly-fill": {
      regular: "fajfr"
    },
    notdog: {
      solid: "fans"
    },
    "notdog-duo": {
      solid: "fands"
    },
    sharp: {
      light: "fasl",
      regular: "fasr",
      solid: "fass",
      thin: "fast"
    },
    "sharp-duotone": {
      light: "fasdl",
      regular: "fasdr",
      solid: "fasds",
      thin: "fasdt"
    },
    slab: {
      regular: "faslr"
    },
    "slab-press": {
      regular: "faslpr"
    },
    thumbprint: {
      light: "fatl"
    },
    whiteboard: {
      semibold: "fawsb"
    }
  }, mL = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], S$ = {
    kit: {
      fak: "kit",
      "fa-kit": "kit"
    },
    "kit-duotone": {
      fakd: "kit-duotone",
      "fa-kit-duotone": "kit-duotone"
    }
  }, Kee = ["kit"], Yee = "kit", Xee = "kit-duotone", Zee = "Kit", Qee = "Kit Duotone";
  Tt(Tt({}, Yee, Zee), Xee, Qee);
  var Jee = {
    kit: {
      "fa-kit": "fak"
    }
  }, ete = {
    "Font Awesome Kit": {
      400: "fak",
      normal: "fak"
    },
    "Font Awesome Kit Duotone": {
      400: "fakd",
      normal: "fakd"
    }
  }, tte = {
    kit: {
      fak: "fa-kit"
    }
  }, _$ = {
    kit: {
      kit: "fak"
    },
    "kit-duotone": {
      "kit-duotone": "fakd"
    }
  }, gS, Vg = {
    GROUP: "duotone-group",
    SWAP_OPACITY: "swap-opacity",
    PRIMARY: "primary",
    SECONDARY: "secondary"
  }, nte = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone", "fa-thumbprint", "fa-whiteboard", "fa-notdog", "fa-notdog-duo", "fa-chisel", "fa-etch", "fa-jelly", "fa-jelly-fill", "fa-jelly-duo", "fa-slab", "fa-slab-press"], rte = "classic", ote = "duotone", ite = "sharp", ate = "sharp-duotone", ste = "chisel", lte = "etch", cte = "jelly", ute = "jelly-duo", fte = "jelly-fill", dte = "notdog", pte = "notdog-duo", hte = "slab", mte = "slab-press", gte = "thumbprint", yte = "whiteboard", vte = "Classic", bte = "Duotone", xte = "Sharp", wte = "Sharp Duotone", Ste = "Chisel", _te = "Etch", Ete = "Jelly", Cte = "Jelly Duo", kte = "Jelly Fill", Tte = "Notdog", Rte = "Notdog Duo", Ote = "Slab", Ate = "Slab Press", Nte = "Thumbprint", Mte = "Whiteboard";
  gS = {}, Tt(Tt(Tt(Tt(Tt(Tt(Tt(Tt(Tt(Tt(gS, rte, vte), ote, bte), ite, xte), ate, wte), ste, Ste), lte, _te), cte, Ete), ute, Cte), fte, kte), dte, Tte), Tt(Tt(Tt(Tt(Tt(gS, pte, Rte), hte, Ote), mte, Ate), gte, Nte), yte, Mte);
  var Pte = "kit", $te = "kit-duotone", Ite = "Kit", jte = "Kit Duotone";
  Tt(Tt({}, Pte, Ite), $te, jte);
  var Dte = {
    classic: {
      "fa-brands": "fab",
      "fa-duotone": "fad",
      "fa-light": "fal",
      "fa-regular": "far",
      "fa-solid": "fas",
      "fa-thin": "fat"
    },
    duotone: {
      "fa-regular": "fadr",
      "fa-light": "fadl",
      "fa-thin": "fadt"
    },
    sharp: {
      "fa-solid": "fass",
      "fa-regular": "fasr",
      "fa-light": "fasl",
      "fa-thin": "fast"
    },
    "sharp-duotone": {
      "fa-solid": "fasds",
      "fa-regular": "fasdr",
      "fa-light": "fasdl",
      "fa-thin": "fasdt"
    },
    slab: {
      "fa-regular": "faslr"
    },
    "slab-press": {
      "fa-regular": "faslpr"
    },
    whiteboard: {
      "fa-semibold": "fawsb"
    },
    thumbprint: {
      "fa-light": "fatl"
    },
    notdog: {
      "fa-solid": "fans"
    },
    "notdog-duo": {
      "fa-solid": "fands"
    },
    etch: {
      "fa-solid": "faes"
    },
    jelly: {
      "fa-regular": "fajr"
    },
    "jelly-fill": {
      "fa-regular": "fajfr"
    },
    "jelly-duo": {
      "fa-regular": "fajdr"
    },
    chisel: {
      "fa-regular": "facr"
    }
  }, Fte = {
    classic: ["fas", "far", "fal", "fat", "fad"],
    duotone: ["fadr", "fadl", "fadt"],
    sharp: ["fass", "fasr", "fasl", "fast"],
    "sharp-duotone": ["fasds", "fasdr", "fasdl", "fasdt"],
    slab: ["faslr"],
    "slab-press": ["faslpr"],
    whiteboard: ["fawsb"],
    thumbprint: ["fatl"],
    notdog: ["fans"],
    "notdog-duo": ["fands"],
    etch: ["faes"],
    jelly: ["fajr"],
    "jelly-fill": ["fajfr"],
    "jelly-duo": ["fajdr"],
    chisel: ["facr"]
  }, vE = {
    classic: {
      fab: "fa-brands",
      fad: "fa-duotone",
      fal: "fa-light",
      far: "fa-regular",
      fas: "fa-solid",
      fat: "fa-thin"
    },
    duotone: {
      fadr: "fa-regular",
      fadl: "fa-light",
      fadt: "fa-thin"
    },
    sharp: {
      fass: "fa-solid",
      fasr: "fa-regular",
      fasl: "fa-light",
      fast: "fa-thin"
    },
    "sharp-duotone": {
      fasds: "fa-solid",
      fasdr: "fa-regular",
      fasdl: "fa-light",
      fasdt: "fa-thin"
    },
    slab: {
      faslr: "fa-regular"
    },
    "slab-press": {
      faslpr: "fa-regular"
    },
    whiteboard: {
      fawsb: "fa-semibold"
    },
    thumbprint: {
      fatl: "fa-light"
    },
    notdog: {
      fans: "fa-solid"
    },
    "notdog-duo": {
      fands: "fa-solid"
    },
    etch: {
      faes: "fa-solid"
    },
    jelly: {
      fajr: "fa-regular"
    },
    "jelly-fill": {
      fajfr: "fa-regular"
    },
    "jelly-duo": {
      fajdr: "fa-regular"
    },
    chisel: {
      facr: "fa-regular"
    }
  }, Lte = ["fa-solid", "fa-regular", "fa-light", "fa-thin", "fa-duotone", "fa-brands", "fa-semibold"], gL = ["fa", "fas", "far", "fal", "fat", "fad", "fadr", "fadl", "fadt", "fab", "fass", "fasr", "fasl", "fast", "fasds", "fasdr", "fasdl", "fasdt", "faslr", "faslpr", "fawsb", "fatl", "fans", "fands", "faes", "fajr", "fajfr", "fajdr", "facr"].concat(nte, Lte), zte = ["solid", "regular", "light", "thin", "duotone", "brands", "semibold"], yL = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], Bte = yL.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), Ute = ["aw", "fw", "pull-left", "pull-right"], Vte = [].concat(Yo(Object.keys(Fte)), zte, Ute, ["2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "inverse", "layers", "layers-bottom-left", "layers-bottom-right", "layers-counter", "layers-text", "layers-top-left", "layers-top-right", "li", "pull-end", "pull-start", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", "width-auto", "width-fixed", Vg.GROUP, Vg.SWAP_OPACITY, Vg.PRIMARY, Vg.SECONDARY]).concat(yL.map(function(e) {
    return "".concat(e, "x");
  })).concat(Bte.map(function(e) {
    return "w-".concat(e);
  })), Hte = {
    "Font Awesome 5 Free": {
      900: "fas",
      400: "far"
    },
    "Font Awesome 5 Pro": {
      900: "fas",
      400: "far",
      normal: "far",
      300: "fal"
    },
    "Font Awesome 5 Brands": {
      400: "fab",
      normal: "fab"
    },
    "Font Awesome 5 Duotone": {
      900: "fad"
    }
  }, La = "___FONT_AWESOME___", bE = 16, vL = "fa", bL = "svg-inline--fa", rc = "data-fa-i2svg", xE = "data-fa-pseudo-element", qte = "data-fa-pseudo-element-pending", Mk = "data-prefix", Pk = "data-icon", E$ = "fontawesome-i2svg", Wte = "async", Gte = ["HTML", "HEAD", "STYLE", "SCRIPT"], xL = ["::before", "::after", ":before", ":after"], wL = function() {
    try {
      return !0;
    } catch {
      return !1;
    }
  }();
  function Fh(e) {
    return new Proxy(e, {
      get: function(n, r) {
        return r in n ? n[r] : n[br];
      }
    });
  }
  var SL = Te({}, JF);
  SL[br] = Te(Te(Te(Te({}, {
    "fa-duotone": "duotone"
  }), JF[br]), S$.kit), S$["kit-duotone"]);
  var Kte = Fh(SL), wE = Te({}, Gee);
  wE[br] = Te(Te(Te(Te({}, {
    duotone: "fad"
  }), wE[br]), _$.kit), _$["kit-duotone"]);
  var C$ = Fh(wE), SE = Te({}, vE);
  SE[br] = Te(Te({}, SE[br]), tte.kit);
  var _L = Fh(SE), _E = Te({}, Dte);
  _E[br] = Te(Te({}, _E[br]), Jee.kit);
  Fh(_E);
  var Yte = kee, EL = "fa-layers-text", Xte = Tee, Zte = Te({}, Hee);
  Fh(Zte);
  var Qte = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"], yS = Ree, Jte = [].concat(Yo(Kee), Yo(Vte)), kp = Qs.FontAwesomeConfig || {};
  function ene(e) {
    var t = hn.querySelector("script[" + e + "]");
    if (t)
      return t.getAttribute(e);
  }
  function tne(e) {
    return e === "" ? !0 : e === "false" ? !1 : e === "true" ? !0 : e;
  }
  if (hn && typeof hn.querySelector == "function") {
    var nne = [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-search-pseudo-elements-warnings", "searchPseudoElementsWarnings"], ["data-search-pseudo-elements-full-scan", "searchPseudoElementsFullScan"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
    nne.forEach(function(e) {
      var t = hb(e, 2), n = t[0], r = t[1], o = tne(ene(n));
      o != null && (kp[r] = o);
    });
  }
  var CL = {
    styleDefault: "solid",
    familyDefault: br,
    cssPrefix: vL,
    replacementClass: bL,
    autoReplaceSvg: !0,
    autoAddCss: !0,
    searchPseudoElements: !1,
    searchPseudoElementsWarnings: !0,
    searchPseudoElementsFullScan: !1,
    observeMutations: !0,
    mutateApproach: "async",
    keepOriginalSource: !0,
    measurePerformance: !1,
    showMissingIcons: !0
  };
  kp.familyPrefix && (kp.cssPrefix = kp.familyPrefix);
  var rf = Te(Te({}, CL), kp);
  rf.autoReplaceSvg || (rf.observeMutations = !1);
  var We = {};
  Object.keys(CL).forEach(function(e) {
    Object.defineProperty(We, e, {
      enumerable: !0,
      set: function(n) {
        rf[e] = n, Tp.forEach(function(r) {
          return r(We);
        });
      },
      get: function() {
        return rf[e];
      }
    });
  });
  Object.defineProperty(We, "familyPrefix", {
    enumerable: !0,
    set: function(t) {
      rf.cssPrefix = t, Tp.forEach(function(n) {
        return n(We);
      });
    },
    get: function() {
      return rf.cssPrefix;
    }
  });
  Qs.FontAwesomeConfig = We;
  var Tp = [];
  function rne(e) {
    return Tp.push(e), function() {
      Tp.splice(Tp.indexOf(e), 1);
    };
  }
  var wu = bE, Ri = {
    size: 16,
    x: 0,
    y: 0,
    rotate: 0,
    flipX: !1,
    flipY: !1
  };
  function one(e) {
    if (!(!e || !Wa)) {
      var t = hn.createElement("style");
      t.setAttribute("type", "text/css"), t.innerHTML = e;
      for (var n = hn.head.childNodes, r = null, o = n.length - 1; o > -1; o--) {
        var i = n[o], a = (i.tagName || "").toUpperCase();
        ["STYLE", "LINK"].indexOf(a) > -1 && (r = i);
      }
      return hn.head.insertBefore(t, r), e;
    }
  }
  var ine = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  function k$() {
    for (var e = 12, t = ""; e-- > 0; )
      t += ine[Math.random() * 62 | 0];
    return t;
  }
  function kf(e) {
    for (var t = [], n = (e || []).length >>> 0; n--; )
      t[n] = e[n];
    return t;
  }
  function $k(e) {
    return e.classList ? kf(e.classList) : (e.getAttribute("class") || "").split(" ").filter(function(t) {
      return t;
    });
  }
  function kL(e) {
    return "".concat(e).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  function ane(e) {
    return Object.keys(e || {}).reduce(function(t, n) {
      return t + "".concat(n, '="').concat(kL(e[n]), '" ');
    }, "").trim();
  }
  function mb(e) {
    return Object.keys(e || {}).reduce(function(t, n) {
      return t + "".concat(n, ": ").concat(e[n].trim(), ";");
    }, "");
  }
  function Ik(e) {
    return e.size !== Ri.size || e.x !== Ri.x || e.y !== Ri.y || e.rotate !== Ri.rotate || e.flipX || e.flipY;
  }
  function sne(e) {
    var t = e.transform, n = e.containerWidth, r = e.iconWidth, o = {
      transform: "translate(".concat(n / 2, " 256)")
    }, i = "translate(".concat(t.x * 32, ", ").concat(t.y * 32, ") "), a = "scale(".concat(t.size / 16 * (t.flipX ? -1 : 1), ", ").concat(t.size / 16 * (t.flipY ? -1 : 1), ") "), s = "rotate(".concat(t.rotate, " 0 0)"), l = {
      transform: "".concat(i, " ").concat(a, " ").concat(s)
    }, u = {
      transform: "translate(".concat(r / 2 * -1, " -256)")
    };
    return {
      outer: o,
      inner: l,
      path: u
    };
  }
  function lne(e) {
    var t = e.transform, n = e.width, r = n === void 0 ? bE : n, o = e.height, i = o === void 0 ? bE : o, a = "";
    return QF ? a += "translate(".concat(t.x / wu - r / 2, "em, ").concat(t.y / wu - i / 2, "em) ") : a += "translate(calc(-50% + ".concat(t.x / wu, "em), calc(-50% + ").concat(t.y / wu, "em)) "), a += "scale(".concat(t.size / wu * (t.flipX ? -1 : 1), ", ").concat(t.size / wu * (t.flipY ? -1 : 1), ") "), a += "rotate(".concat(t.rotate, "deg) "), a;
  }
  var cne = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 7 Free";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 7 Free";
  --fa-font-light: normal 300 1em/1 "Font Awesome 7 Pro";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 7 Pro";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-regular: normal 400 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-light: normal 300 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-thin: normal 100 1em/1 "Font Awesome 7 Duotone";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 7 Brands";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-regular: normal 400 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-light: normal 300 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-thin: normal 100 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-slab-regular: normal 400 1em/1 "Font Awesome 7 Slab";
  --fa-font-slab-press-regular: normal 400 1em/1 "Font Awesome 7 Slab Press";
  --fa-font-whiteboard-semibold: normal 600 1em/1 "Font Awesome 7 Whiteboard";
  --fa-font-thumbprint-light: normal 300 1em/1 "Font Awesome 7 Thumbprint";
  --fa-font-notdog-solid: normal 900 1em/1 "Font Awesome 7 Notdog";
  --fa-font-notdog-duo-solid: normal 900 1em/1 "Font Awesome 7 Notdog Duo";
  --fa-font-etch-solid: normal 900 1em/1 "Font Awesome 7 Etch";
  --fa-font-jelly-regular: normal 400 1em/1 "Font Awesome 7 Jelly";
  --fa-font-jelly-fill-regular: normal 400 1em/1 "Font Awesome 7 Jelly Fill";
  --fa-font-jelly-duo-regular: normal 400 1em/1 "Font Awesome 7 Jelly Duo";
  --fa-font-chisel-regular: normal 400 1em/1 "Font Awesome 7 Chisel";
}

.svg-inline--fa {
  box-sizing: content-box;
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
  width: var(--fa-width, 1.25em);
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285714em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left,
.svg-inline--fa .fa-pull-start {
  float: inline-start;
  margin-inline-end: var(--fa-pull-margin, 0.3em);
}
.svg-inline--fa.fa-pull-right,
.svg-inline--fa .fa-pull-end {
  float: inline-end;
  margin-inline-start: var(--fa-pull-margin, 0.3em);
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  inset-inline-start: calc(-1 * var(--fa-li-width, 2em));
  inset-block-start: 0.25em; /* syncing vertical alignment with Web Font rendering */
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: var(--fa-width, 1.25em);
}
.fa-layers .svg-inline--fa {
  inset: 0;
  margin: auto;
  position: absolute;
  transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-counter-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: calc(10 / 16 * 1em); /* converts a 10px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 10 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 10 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-xs {
  font-size: calc(12 / 16 * 1em); /* converts a 12px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 12 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 12 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-sm {
  font-size: calc(14 / 16 * 1em); /* converts a 14px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 14 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 14 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-lg {
  font-size: calc(20 / 16 * 1em); /* converts a 20px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 20 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 20 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-xl {
  font-size: calc(24 / 16 * 1em); /* converts a 24px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 24 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 24 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-2xl {
  font-size: calc(32 / 16 * 1em); /* converts a 32px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 32 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 32 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-width-auto {
  --fa-width: auto;
}

.fa-fw,
.fa-width-fixed {
  --fa-width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-inline-start: var(--fa-li-margin, 2.5em);
  padding-inline-start: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  inset-inline-start: calc(-1 * var(--fa-li-width, 2em));
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

/* Heads Up: Bordered Icons will not be supported in the future!
  - This feature will be deprecated in the next major release of Font Awesome (v8)!
  - You may continue to use it in this version *v7), but it will not be supported in Font Awesome v8.
*/
/* Notes:
* --@{v.$css-prefix}-border-width = 1/16 by default (to render as ~1px based on a 16px default font-size)
* --@{v.$css-prefix}-border-padding =
  ** 3/16 for vertical padding (to give ~2px of vertical whitespace around an icon considering it's vertical alignment)
  ** 4/16 for horizontal padding (to give ~4px of horizontal whitespace around an icon)
*/
.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.0625em);
  box-sizing: var(--fa-border-box-sizing, content-box);
  padding: var(--fa-border-padding, 0.1875em 0.25em);
}

.fa-pull-left,
.fa-pull-start {
  float: inline-start;
  margin-inline-end: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right,
.fa-pull-end {
  float: inline-end;
  margin-inline-start: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  animation-name: fa-beat;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  animation-name: fa-bounce;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  animation-name: fa-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  animation-name: fa-beat-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  animation-name: fa-flip;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  animation-name: fa-shake;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  animation-name: fa-spin;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 2s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  animation-name: fa-spin;
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
  .fa-bounce,
  .fa-fade,
  .fa-beat-fade,
  .fa-flip,
  .fa-pulse,
  .fa-shake,
  .fa-spin,
  .fa-spin-pulse {
    animation: none !important;
    transition: none !important;
  }
}
@keyframes fa-beat {
  0%, 90% {
    transform: scale(1);
  }
  45% {
    transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-bounce {
  0% {
    transform: scale(1, 1) translateY(0);
  }
  10% {
    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    transform: scale(1, 1) translateY(0);
  }
  100% {
    transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-flip {
  50% {
    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-shake {
  0% {
    transform: rotate(-15deg);
  }
  4% {
    transform: rotate(15deg);
  }
  8%, 24% {
    transform: rotate(-18deg);
  }
  12%, 28% {
    transform: rotate(18deg);
  }
  16% {
    transform: rotate(-22deg);
  }
  20% {
    transform: rotate(22deg);
  }
  32% {
    transform: rotate(-12deg);
  }
  36% {
    transform: rotate(12deg);
  }
  40%, 100% {
    transform: rotate(0deg);
  }
}
@keyframes fa-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  transform: rotate(90deg);
}

.fa-rotate-180 {
  transform: rotate(180deg);
}

.fa-rotate-270 {
  transform: rotate(270deg);
}

.fa-flip-horizontal {
  transform: scale(-1, 1);
}

.fa-flip-vertical {
  transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  transform: scale(-1, -1);
}

.fa-rotate-by {
  transform: rotate(var(--fa-rotate-angle, 0));
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}

.svg-inline--fa.fa-inverse {
  fill: var(--fa-inverse, #fff);
}

.fa-stack {
  display: inline-block;
  height: 2em;
  line-height: 2em;
  position: relative;
  vertical-align: middle;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
  z-index: var(--fa-stack-z-index, auto);
}`;
  function TL() {
    var e = vL, t = bL, n = We.cssPrefix, r = We.replacementClass, o = cne;
    if (n !== e || r !== t) {
      var i = new RegExp("\\.".concat(e, "\\-"), "g"), a = new RegExp("\\--".concat(e, "\\-"), "g"), s = new RegExp("\\.".concat(t), "g");
      o = o.replace(i, ".".concat(n, "-")).replace(a, "--".concat(n, "-")).replace(s, ".".concat(r));
    }
    return o;
  }
  var T$ = !1;
  function vS() {
    We.autoAddCss && !T$ && (one(TL()), T$ = !0);
  }
  var une = {
    mixout: function() {
      return {
        dom: {
          css: TL,
          insertCss: vS
        }
      };
    },
    hooks: function() {
      return {
        beforeDOMElementCreation: function() {
          vS();
        },
        beforeI2svg: function() {
          vS();
        }
      };
    }
  }, za = Qs || {};
  za[La] || (za[La] = {});
  za[La].styles || (za[La].styles = {});
  za[La].hooks || (za[La].hooks = {});
  za[La].shims || (za[La].shims = []);
  var Ho = za[La], RL = [], OL = function() {
    hn.removeEventListener("DOMContentLoaded", OL), Wv = 1, RL.map(function(t) {
      return t();
    });
  }, Wv = !1;
  Wa && (Wv = (hn.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(hn.readyState), Wv || hn.addEventListener("DOMContentLoaded", OL));
  function fne(e) {
    Wa && (Wv ? setTimeout(e, 0) : RL.push(e));
  }
  function Lh(e) {
    var t = e.tag, n = e.attributes, r = n === void 0 ? {} : n, o = e.children, i = o === void 0 ? [] : o;
    return typeof e == "string" ? kL(e) : "<".concat(t, " ").concat(ane(r), ">").concat(i.map(Lh).join(""), "</").concat(t, ">");
  }
  function R$(e, t, n) {
    if (e && e[t] && e[t][n])
      return {
        prefix: t,
        iconName: n,
        icon: e[t][n]
      };
  }
  var bS = function(t, n, r, o) {
    var i = Object.keys(t), a = i.length, s = n, l, u, d;
    for (r === void 0 ? (l = 1, d = t[i[0]]) : (l = 0, d = r); l < a; l++)
      u = i[l], d = s(d, t[u], u, t);
    return d;
  };
  function AL(e) {
    return Yo(e).length !== 1 ? null : e.codePointAt(0).toString(16);
  }
  function O$(e) {
    return Object.keys(e).reduce(function(t, n) {
      var r = e[n], o = !!r.icon;
      return o ? t[r.iconName] = r.icon : t[n] = r, t;
    }, {});
  }
  function NL(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = n.skipHooks, o = r === void 0 ? !1 : r, i = O$(t);
    typeof Ho.hooks.addPack == "function" && !o ? Ho.hooks.addPack(e, O$(t)) : Ho.styles[e] = Te(Te({}, Ho.styles[e] || {}), i), e === "fas" && NL("fa", t);
  }
  var Gp = Ho.styles, dne = Ho.shims, ML = Object.keys(_L), pne = ML.reduce(function(e, t) {
    return e[t] = Object.keys(_L[t]), e;
  }, {}), jk = null, PL = {}, $L = {}, IL = {}, jL = {}, DL = {};
  function hne(e) {
    return ~Jte.indexOf(e);
  }
  function mne(e, t) {
    var n = t.split("-"), r = n[0], o = n.slice(1).join("-");
    return r === e && o !== "" && !hne(o) ? o : null;
  }
  var FL = function() {
    var t = function(i) {
      return bS(Gp, function(a, s, l) {
        return a[l] = bS(s, i, {}), a;
      }, {});
    };
    PL = t(function(o, i, a) {
      if (i[3] && (o[i[3]] = a), i[2]) {
        var s = i[2].filter(function(l) {
          return typeof l == "number";
        });
        s.forEach(function(l) {
          o[l.toString(16)] = a;
        });
      }
      return o;
    }), $L = t(function(o, i, a) {
      if (o[a] = a, i[2]) {
        var s = i[2].filter(function(l) {
          return typeof l == "string";
        });
        s.forEach(function(l) {
          o[l] = a;
        });
      }
      return o;
    }), DL = t(function(o, i, a) {
      var s = i[2];
      return o[a] = a, s.forEach(function(l) {
        o[l] = a;
      }), o;
    });
    var n = "far" in Gp || We.autoFetchSvg, r = bS(dne, function(o, i) {
      var a = i[0], s = i[1], l = i[2];
      return s === "far" && !n && (s = "fas"), typeof a == "string" && (o.names[a] = {
        prefix: s,
        iconName: l
      }), typeof a == "number" && (o.unicodes[a.toString(16)] = {
        prefix: s,
        iconName: l
      }), o;
    }, {
      names: {},
      unicodes: {}
    });
    IL = r.names, jL = r.unicodes, jk = gb(We.styleDefault, {
      family: We.familyDefault
    });
  };
  rne(function(e) {
    jk = gb(e.styleDefault, {
      family: We.familyDefault
    });
  });
  FL();
  function Dk(e, t) {
    return (PL[e] || {})[t];
  }
  function gne(e, t) {
    return ($L[e] || {})[t];
  }
  function Kl(e, t) {
    return (DL[e] || {})[t];
  }
  function LL(e) {
    return IL[e] || {
      prefix: null,
      iconName: null
    };
  }
  function yne(e) {
    var t = jL[e], n = Dk("fas", e);
    return t || (n ? {
      prefix: "fas",
      iconName: n
    } : null) || {
      prefix: null,
      iconName: null
    };
  }
  function Js() {
    return jk;
  }
  var zL = function() {
    return {
      prefix: null,
      iconName: null,
      rest: []
    };
  };
  function vne(e) {
    var t = br, n = ML.reduce(function(r, o) {
      return r[o] = "".concat(We.cssPrefix, "-").concat(o), r;
    }, {});
    return hL.forEach(function(r) {
      (e.includes(n[r]) || e.some(function(o) {
        return pne[r].includes(o);
      })) && (t = r);
    }), t;
  }
  function gb(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.family, r = n === void 0 ? br : n, o = Kte[r][e];
    if (r === Dh && !e)
      return "fad";
    var i = C$[r][e] || C$[r][o], a = e in Ho.styles ? e : null, s = i || a || null;
    return s;
  }
  function bne(e) {
    var t = [], n = null;
    return e.forEach(function(r) {
      var o = mne(We.cssPrefix, r);
      o ? n = o : r && t.push(r);
    }), {
      iconName: n,
      rest: t
    };
  }
  function A$(e) {
    return e.sort().filter(function(t, n, r) {
      return r.indexOf(t) === n;
    });
  }
  var N$ = gL.concat(mL);
  function yb(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.skipLookups, r = n === void 0 ? !1 : n, o = null, i = A$(e.filter(function(g) {
      return N$.includes(g);
    })), a = A$(e.filter(function(g) {
      return !N$.includes(g);
    })), s = i.filter(function(g) {
      return o = g, !eL.includes(g);
    }), l = hb(s, 1), u = l[0], d = u === void 0 ? null : u, p = vne(i), h = Te(Te({}, bne(a)), {}, {
      prefix: gb(d, {
        family: p
      })
    });
    return Te(Te(Te({}, h), _ne({
      values: e,
      family: p,
      styles: Gp,
      config: We,
      canonical: h,
      givenPrefix: o
    })), xne(r, o, h));
  }
  function xne(e, t, n) {
    var r = n.prefix, o = n.iconName;
    if (e || !r || !o)
      return {
        prefix: r,
        iconName: o
      };
    var i = t === "fa" ? LL(o) : {}, a = Kl(r, o);
    return o = i.iconName || a || o, r = i.prefix || r, r === "far" && !Gp.far && Gp.fas && !We.autoFetchSvg && (r = "fas"), {
      prefix: r,
      iconName: o
    };
  }
  var wne = hL.filter(function(e) {
    return e !== br || e !== Dh;
  }), Sne = Object.keys(vE).filter(function(e) {
    return e !== br;
  }).map(function(e) {
    return Object.keys(vE[e]);
  }).flat();
  function _ne(e) {
    var t = e.values, n = e.family, r = e.canonical, o = e.givenPrefix, i = o === void 0 ? "" : o, a = e.styles, s = a === void 0 ? {} : a, l = e.config, u = l === void 0 ? {} : l, d = n === Dh, p = t.includes("fa-duotone") || t.includes("fad"), h = u.familyDefault === "duotone", g = r.prefix === "fad" || r.prefix === "fa-duotone";
    if (!d && (p || h || g) && (r.prefix = "fad"), (t.includes("fa-brands") || t.includes("fab")) && (r.prefix = "fab"), !r.prefix && wne.includes(n)) {
      var y = Object.keys(s).find(function(v) {
        return Sne.includes(v);
      });
      if (y || u.autoFetchSvg) {
        var b = Wee.get(n).defaultShortPrefixId;
        r.prefix = b, r.iconName = Kl(r.prefix, r.iconName) || r.iconName;
      }
    }
    return (r.prefix === "fa" || i === "fa") && (r.prefix = Js() || "fas"), r;
  }
  var Ene = /* @__PURE__ */ function() {
    function e() {
      yee(this, e), this.definitions = {};
    }
    return bee(e, [{
      key: "add",
      value: function() {
        for (var n = this, r = arguments.length, o = new Array(r), i = 0; i < r; i++)
          o[i] = arguments[i];
        var a = o.reduce(this._pullDefinitions, {});
        Object.keys(a).forEach(function(s) {
          n.definitions[s] = Te(Te({}, n.definitions[s] || {}), a[s]), NL(s, a[s]), FL();
        });
      }
    }, {
      key: "reset",
      value: function() {
        this.definitions = {};
      }
    }, {
      key: "_pullDefinitions",
      value: function(n, r) {
        var o = r.prefix && r.iconName && r.icon ? {
          0: r
        } : r;
        return Object.keys(o).map(function(i) {
          var a = o[i], s = a.prefix, l = a.iconName, u = a.icon, d = u[2];
          n[s] || (n[s] = {}), d.length > 0 && d.forEach(function(p) {
            typeof p == "string" && (n[s][p] = u);
          }), n[s][l] = u;
        }), n;
      }
    }]);
  }(), M$ = [], Du = {}, Wu = {}, Cne = Object.keys(Wu);
  function kne(e, t) {
    var n = t.mixoutsTo;
    return M$ = e, Du = {}, Object.keys(Wu).forEach(function(r) {
      Cne.indexOf(r) === -1 && delete Wu[r];
    }), M$.forEach(function(r) {
      var o = r.mixout ? r.mixout() : {};
      if (Object.keys(o).forEach(function(a) {
        typeof o[a] == "function" && (n[a] = o[a]), qv(o[a]) === "object" && Object.keys(o[a]).forEach(function(s) {
          n[a] || (n[a] = {}), n[a][s] = o[a][s];
        });
      }), r.hooks) {
        var i = r.hooks();
        Object.keys(i).forEach(function(a) {
          Du[a] || (Du[a] = []), Du[a].push(i[a]);
        });
      }
      r.provides && r.provides(Wu);
    }), n;
  }
  function EE(e, t) {
    for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++)
      r[o - 2] = arguments[o];
    var i = Du[e] || [];
    return i.forEach(function(a) {
      t = a.apply(null, [t].concat(r));
    }), t;
  }
  function oc(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
      n[r - 1] = arguments[r];
    var o = Du[e] || [];
    o.forEach(function(i) {
      i.apply(null, n);
    });
  }
  function el() {
    var e = arguments[0], t = Array.prototype.slice.call(arguments, 1);
    return Wu[e] ? Wu[e].apply(null, t) : void 0;
  }
  function CE(e) {
    e.prefix === "fa" && (e.prefix = "fas");
    var t = e.iconName, n = e.prefix || Js();
    if (t)
      return t = Kl(n, t) || t, R$(BL.definitions, n, t) || R$(Ho.styles, n, t);
  }
  var BL = new Ene(), Tne = function() {
    We.autoReplaceSvg = !1, We.observeMutations = !1, oc("noAuto");
  }, Rne = {
    i2svg: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return Wa ? (oc("beforeI2svg", t), el("pseudoElements2svg", t), el("i2svg", t)) : Promise.reject(new Error("Operation requires a DOM of some kind."));
    },
    watch: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = t.autoReplaceSvgRoot;
      We.autoReplaceSvg === !1 && (We.autoReplaceSvg = !0), We.observeMutations = !0, fne(function() {
        Ane({
          autoReplaceSvgRoot: n
        }), oc("watch", t);
      });
    }
  }, One = {
    icon: function(t) {
      if (t === null)
        return null;
      if (qv(t) === "object" && t.prefix && t.iconName)
        return {
          prefix: t.prefix,
          iconName: Kl(t.prefix, t.iconName) || t.iconName
        };
      if (Array.isArray(t) && t.length === 2) {
        var n = t[1].indexOf("fa-") === 0 ? t[1].slice(3) : t[1], r = gb(t[0]);
        return {
          prefix: r,
          iconName: Kl(r, n) || n
        };
      }
      if (typeof t == "string" && (t.indexOf("".concat(We.cssPrefix, "-")) > -1 || t.match(Yte))) {
        var o = yb(t.split(" "), {
          skipLookups: !0
        });
        return {
          prefix: o.prefix || Js(),
          iconName: Kl(o.prefix, o.iconName) || o.iconName
        };
      }
      if (typeof t == "string") {
        var i = Js();
        return {
          prefix: i,
          iconName: Kl(i, t) || t
        };
      }
    }
  }, uo = {
    noAuto: Tne,
    config: We,
    dom: Rne,
    parse: One,
    library: BL,
    findIconDefinition: CE,
    toHtml: Lh
  }, Ane = function() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = t.autoReplaceSvgRoot, r = n === void 0 ? hn : n;
    (Object.keys(Ho.styles).length > 0 || We.autoFetchSvg) && Wa && We.autoReplaceSvg && uo.dom.i2svg({
      node: r
    });
  };
  function vb(e, t) {
    return Object.defineProperty(e, "abstract", {
      get: t
    }), Object.defineProperty(e, "html", {
      get: function() {
        return e.abstract.map(function(r) {
          return Lh(r);
        });
      }
    }), Object.defineProperty(e, "node", {
      get: function() {
        if (Wa) {
          var r = hn.createElement("div");
          return r.innerHTML = e.html, r.children;
        }
      }
    }), e;
  }
  function Nne(e) {
    var t = e.children, n = e.main, r = e.mask, o = e.attributes, i = e.styles, a = e.transform;
    if (Ik(a) && n.found && !r.found) {
      var s = n.width, l = n.height, u = {
        x: s / l / 2,
        y: 0.5
      };
      o.style = mb(Te(Te({}, i), {}, {
        "transform-origin": "".concat(u.x + a.x / 16, "em ").concat(u.y + a.y / 16, "em")
      }));
    }
    return [{
      tag: "svg",
      attributes: o,
      children: t
    }];
  }
  function Mne(e) {
    var t = e.prefix, n = e.iconName, r = e.children, o = e.attributes, i = e.symbol, a = i === !0 ? "".concat(t, "-").concat(We.cssPrefix, "-").concat(n) : i;
    return [{
      tag: "svg",
      attributes: {
        style: "display: none;"
      },
      children: [{
        tag: "symbol",
        attributes: Te(Te({}, o), {}, {
          id: a
        }),
        children: r
      }]
    }];
  }
  function Pne(e) {
    var t = ["aria-label", "aria-labelledby", "title", "role"];
    return t.some(function(n) {
      return n in e;
    });
  }
  function Fk(e) {
    var t = e.icons, n = t.main, r = t.mask, o = e.prefix, i = e.iconName, a = e.transform, s = e.symbol, l = e.maskId, u = e.extra, d = e.watchable, p = d === void 0 ? !1 : d, h = r.found ? r : n, g = h.width, y = h.height, b = [We.replacementClass, i ? "".concat(We.cssPrefix, "-").concat(i) : ""].filter(function(k) {
      return u.classes.indexOf(k) === -1;
    }).filter(function(k) {
      return k !== "" || !!k;
    }).concat(u.classes).join(" "), v = {
      children: [],
      attributes: Te(Te({}, u.attributes), {}, {
        "data-prefix": o,
        "data-icon": i,
        class: b,
        role: u.attributes.role || "img",
        viewBox: "0 0 ".concat(g, " ").concat(y)
      })
    };
    !Pne(u.attributes) && !u.attributes["aria-hidden"] && (v.attributes["aria-hidden"] = "true"), p && (v.attributes[rc] = "");
    var x = Te(Te({}, v), {}, {
      prefix: o,
      iconName: i,
      main: n,
      mask: r,
      maskId: l,
      transform: a,
      symbol: s,
      styles: Te({}, u.styles)
    }), E = r.found && n.found ? el("generateAbstractMask", x) || {
      children: [],
      attributes: {}
    } : el("generateAbstractIcon", x) || {
      children: [],
      attributes: {}
    }, _ = E.children, C = E.attributes;
    return x.children = _, x.attributes = C, s ? Mne(x) : Nne(x);
  }
  function P$(e) {
    var t = e.content, n = e.width, r = e.height, o = e.transform, i = e.extra, a = e.watchable, s = a === void 0 ? !1 : a, l = Te(Te({}, i.attributes), {}, {
      class: i.classes.join(" ")
    });
    s && (l[rc] = "");
    var u = Te({}, i.styles);
    Ik(o) && (u.transform = lne({
      transform: o,
      width: n,
      height: r
    }), u["-webkit-transform"] = u.transform);
    var d = mb(u);
    d.length > 0 && (l.style = d);
    var p = [];
    return p.push({
      tag: "span",
      attributes: l,
      children: [t]
    }), p;
  }
  function $ne(e) {
    var t = e.content, n = e.extra, r = Te(Te({}, n.attributes), {}, {
      class: n.classes.join(" ")
    }), o = mb(n.styles);
    o.length > 0 && (r.style = o);
    var i = [];
    return i.push({
      tag: "span",
      attributes: r,
      children: [t]
    }), i;
  }
  var xS = Ho.styles;
  function kE(e) {
    var t = e[0], n = e[1], r = e.slice(4), o = hb(r, 1), i = o[0], a = null;
    return Array.isArray(i) ? a = {
      tag: "g",
      attributes: {
        class: "".concat(We.cssPrefix, "-").concat(yS.GROUP)
      },
      children: [{
        tag: "path",
        attributes: {
          class: "".concat(We.cssPrefix, "-").concat(yS.SECONDARY),
          fill: "currentColor",
          d: i[0]
        }
      }, {
        tag: "path",
        attributes: {
          class: "".concat(We.cssPrefix, "-").concat(yS.PRIMARY),
          fill: "currentColor",
          d: i[1]
        }
      }]
    } : a = {
      tag: "path",
      attributes: {
        fill: "currentColor",
        d: i
      }
    }, {
      found: !0,
      width: t,
      height: n,
      icon: a
    };
  }
  var Ine = {
    found: !1,
    width: 512,
    height: 512
  };
  function jne(e, t) {
    !wL && !We.showMissingIcons && e && console.error('Icon with name "'.concat(e, '" and prefix "').concat(t, '" is missing.'));
  }
  function TE(e, t) {
    var n = t;
    return t === "fa" && We.styleDefault !== null && (t = Js()), new Promise(function(r, o) {
      if (n === "fa") {
        var i = LL(e) || {};
        e = i.iconName || e, t = i.prefix || t;
      }
      if (e && t && xS[t] && xS[t][e]) {
        var a = xS[t][e];
        return r(kE(a));
      }
      jne(e, t), r(Te(Te({}, Ine), {}, {
        icon: We.showMissingIcons && e ? el("missingIconAbstract") || {} : {}
      }));
    });
  }
  var $$ = function() {
  }, RE = We.measurePerformance && Ug && Ug.mark && Ug.measure ? Ug : {
    mark: $$,
    measure: $$
  }, hp = 'FA "7.0.0"', Dne = function(t) {
    return RE.mark("".concat(hp, " ").concat(t, " begins")), function() {
      return UL(t);
    };
  }, UL = function(t) {
    RE.mark("".concat(hp, " ").concat(t, " ends")), RE.measure("".concat(hp, " ").concat(t), "".concat(hp, " ").concat(t, " begins"), "".concat(hp, " ").concat(t, " ends"));
  }, Lk = {
    begin: Dne,
    end: UL
  }, gv = function() {
  };
  function I$(e) {
    var t = e.getAttribute ? e.getAttribute(rc) : null;
    return typeof t == "string";
  }
  function Fne(e) {
    var t = e.getAttribute ? e.getAttribute(Mk) : null, n = e.getAttribute ? e.getAttribute(Pk) : null;
    return t && n;
  }
  function Lne(e) {
    return e && e.classList && e.classList.contains && e.classList.contains(We.replacementClass);
  }
  function zne() {
    if (We.autoReplaceSvg === !0)
      return yv.replace;
    var e = yv[We.autoReplaceSvg];
    return e || yv.replace;
  }
  function Bne(e) {
    return hn.createElementNS("http://www.w3.org/2000/svg", e);
  }
  function Une(e) {
    return hn.createElement(e);
  }
  function VL(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.ceFn, r = n === void 0 ? e.tag === "svg" ? Bne : Une : n;
    if (typeof e == "string")
      return hn.createTextNode(e);
    var o = r(e.tag);
    Object.keys(e.attributes || []).forEach(function(a) {
      o.setAttribute(a, e.attributes[a]);
    });
    var i = e.children || [];
    return i.forEach(function(a) {
      o.appendChild(VL(a, {
        ceFn: r
      }));
    }), o;
  }
  function Vne(e) {
    var t = " ".concat(e.outerHTML, " ");
    return t = "".concat(t, "Font Awesome fontawesome.com "), t;
  }
  var yv = {
    replace: function(t) {
      var n = t[0];
      if (n.parentNode)
        if (t[1].forEach(function(o) {
          n.parentNode.insertBefore(VL(o), n);
        }), n.getAttribute(rc) === null && We.keepOriginalSource) {
          var r = hn.createComment(Vne(n));
          n.parentNode.replaceChild(r, n);
        } else
          n.remove();
    },
    nest: function(t) {
      var n = t[0], r = t[1];
      if (~$k(n).indexOf(We.replacementClass))
        return yv.replace(t);
      var o = new RegExp("".concat(We.cssPrefix, "-.*"));
      if (delete r[0].attributes.id, r[0].attributes.class) {
        var i = r[0].attributes.class.split(" ").reduce(function(s, l) {
          return l === We.replacementClass || l.match(o) ? s.toSvg.push(l) : s.toNode.push(l), s;
        }, {
          toNode: [],
          toSvg: []
        });
        r[0].attributes.class = i.toSvg.join(" "), i.toNode.length === 0 ? n.removeAttribute("class") : n.setAttribute("class", i.toNode.join(" "));
      }
      var a = r.map(function(s) {
        return Lh(s);
      }).join(`
`);
      n.setAttribute(rc, ""), n.innerHTML = a;
    }
  };
  function j$(e) {
    e();
  }
  function HL(e, t) {
    var n = typeof t == "function" ? t : gv;
    if (e.length === 0)
      n();
    else {
      var r = j$;
      We.mutateApproach === Wte && (r = Qs.requestAnimationFrame || j$), r(function() {
        var o = zne(), i = Lk.begin("mutate");
        e.map(o), i(), n();
      });
    }
  }
  var zk = !1;
  function qL() {
    zk = !0;
  }
  function OE() {
    zk = !1;
  }
  var Gv = null;
  function D$(e) {
    if (w$ && We.observeMutations) {
      var t = e.treeCallback, n = t === void 0 ? gv : t, r = e.nodeCallback, o = r === void 0 ? gv : r, i = e.pseudoElementsCallback, a = i === void 0 ? gv : i, s = e.observeMutationsRoot, l = s === void 0 ? hn : s;
      Gv = new w$(function(u) {
        if (!zk) {
          var d = Js();
          kf(u).forEach(function(p) {
            if (p.type === "childList" && p.addedNodes.length > 0 && !I$(p.addedNodes[0]) && (We.searchPseudoElements && a(p.target), n(p.target)), p.type === "attributes" && p.target.parentNode && We.searchPseudoElements && a([p.target], !0), p.type === "attributes" && I$(p.target) && ~Qte.indexOf(p.attributeName))
              if (p.attributeName === "class" && Fne(p.target)) {
                var h = yb($k(p.target)), g = h.prefix, y = h.iconName;
                p.target.setAttribute(Mk, g || d), y && p.target.setAttribute(Pk, y);
              } else Lne(p.target) && o(p.target);
          });
        }
      }), Wa && Gv.observe(l, {
        childList: !0,
        attributes: !0,
        characterData: !0,
        subtree: !0
      });
    }
  }
  function Hne() {
    Gv && Gv.disconnect();
  }
  function qne(e) {
    var t = e.getAttribute("style"), n = [];
    return t && (n = t.split(";").reduce(function(r, o) {
      var i = o.split(":"), a = i[0], s = i.slice(1);
      return a && s.length > 0 && (r[a] = s.join(":").trim()), r;
    }, {})), n;
  }
  function Wne(e) {
    var t = e.getAttribute("data-prefix"), n = e.getAttribute("data-icon"), r = e.innerText !== void 0 ? e.innerText.trim() : "", o = yb($k(e));
    return o.prefix || (o.prefix = Js()), t && n && (o.prefix = t, o.iconName = n), o.iconName && o.prefix || (o.prefix && r.length > 0 && (o.iconName = gne(o.prefix, e.innerText) || Dk(o.prefix, AL(e.innerText))), !o.iconName && We.autoFetchSvg && e.firstChild && e.firstChild.nodeType === Node.TEXT_NODE && (o.iconName = e.firstChild.data)), o;
  }
  function Gne(e) {
    var t = kf(e.attributes).reduce(function(n, r) {
      return n.name !== "class" && n.name !== "style" && (n[r.name] = r.value), n;
    }, {});
    return t;
  }
  function Kne() {
    return {
      iconName: null,
      prefix: null,
      transform: Ri,
      symbol: !1,
      mask: {
        iconName: null,
        prefix: null,
        rest: []
      },
      maskId: null,
      extra: {
        classes: [],
        styles: {},
        attributes: {}
      }
    };
  }
  function F$(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      styleParser: !0
    }, n = Wne(e), r = n.iconName, o = n.prefix, i = n.rest, a = Gne(e), s = EE("parseNodeAttributes", {}, e), l = t.styleParser ? qne(e) : [];
    return Te({
      iconName: r,
      prefix: o,
      transform: Ri,
      mask: {
        iconName: null,
        prefix: null,
        rest: []
      },
      maskId: null,
      symbol: !1,
      extra: {
        classes: i,
        styles: l,
        attributes: a
      }
    }, s);
  }
  var Yne = Ho.styles;
  function WL(e) {
    var t = We.autoReplaceSvg === "nest" ? F$(e, {
      styleParser: !1
    }) : F$(e);
    return ~t.extra.classes.indexOf(EL) ? el("generateLayersText", e, t) : el("generateSvgReplacementMutation", e, t);
  }
  function Xne() {
    return [].concat(Yo(mL), Yo(gL));
  }
  function L$(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (!Wa) return Promise.resolve();
    var n = hn.documentElement.classList, r = function(p) {
      return n.add("".concat(E$, "-").concat(p));
    }, o = function(p) {
      return n.remove("".concat(E$, "-").concat(p));
    }, i = We.autoFetchSvg ? Xne() : eL.concat(Object.keys(Yne));
    i.includes("fa") || i.push("fa");
    var a = [".".concat(EL, ":not([").concat(rc, "])")].concat(i.map(function(d) {
      return ".".concat(d, ":not([").concat(rc, "])");
    })).join(", ");
    if (a.length === 0)
      return Promise.resolve();
    var s = [];
    try {
      s = kf(e.querySelectorAll(a));
    } catch {
    }
    if (s.length > 0)
      r("pending"), o("complete");
    else
      return Promise.resolve();
    var l = Lk.begin("onTree"), u = s.reduce(function(d, p) {
      try {
        var h = WL(p);
        h && d.push(h);
      } catch (g) {
        wL || g.name === "MissingIcon" && console.error(g);
      }
      return d;
    }, []);
    return new Promise(function(d, p) {
      Promise.all(u).then(function(h) {
        HL(h, function() {
          r("active"), r("complete"), o("pending"), typeof t == "function" && t(), l(), d();
        });
      }).catch(function(h) {
        l(), p(h);
      });
    });
  }
  function Zne(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    WL(e).then(function(n) {
      n && HL([n], t);
    });
  }
  function Qne(e) {
    return function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = (t || {}).icon ? t : CE(t || {}), o = n.mask;
      return o && (o = (o || {}).icon ? o : CE(o || {})), e(r, Te(Te({}, n), {}, {
        mask: o
      }));
    };
  }
  var Jne = function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = n.transform, o = r === void 0 ? Ri : r, i = n.symbol, a = i === void 0 ? !1 : i, s = n.mask, l = s === void 0 ? null : s, u = n.maskId, d = u === void 0 ? null : u, p = n.classes, h = p === void 0 ? [] : p, g = n.attributes, y = g === void 0 ? {} : g, b = n.styles, v = b === void 0 ? {} : b;
    if (t) {
      var x = t.prefix, E = t.iconName, _ = t.icon;
      return vb(Te({
        type: "icon"
      }, t), function() {
        return oc("beforeDOMElementCreation", {
          iconDefinition: t,
          params: n
        }), Fk({
          icons: {
            main: kE(_),
            mask: l ? kE(l.icon) : {
              found: !1,
              width: null,
              height: null,
              icon: {}
            }
          },
          prefix: x,
          iconName: E,
          transform: Te(Te({}, Ri), o),
          symbol: a,
          maskId: d,
          extra: {
            attributes: y,
            styles: v,
            classes: h
          }
        });
      });
    }
  }, ere = {
    mixout: function() {
      return {
        icon: Qne(Jne)
      };
    },
    hooks: function() {
      return {
        mutationObserverCallbacks: function(n) {
          return n.treeCallback = L$, n.nodeCallback = Zne, n;
        }
      };
    },
    provides: function(t) {
      t.i2svg = function(n) {
        var r = n.node, o = r === void 0 ? hn : r, i = n.callback, a = i === void 0 ? function() {
        } : i;
        return L$(o, a);
      }, t.generateSvgReplacementMutation = function(n, r) {
        var o = r.iconName, i = r.prefix, a = r.transform, s = r.symbol, l = r.mask, u = r.maskId, d = r.extra;
        return new Promise(function(p, h) {
          Promise.all([TE(o, i), l.iconName ? TE(l.iconName, l.prefix) : Promise.resolve({
            found: !1,
            width: 512,
            height: 512,
            icon: {}
          })]).then(function(g) {
            var y = hb(g, 2), b = y[0], v = y[1];
            p([n, Fk({
              icons: {
                main: b,
                mask: v
              },
              prefix: i,
              iconName: o,
              transform: a,
              symbol: s,
              maskId: u,
              extra: d,
              watchable: !0
            })]);
          }).catch(h);
        });
      }, t.generateAbstractIcon = function(n) {
        var r = n.children, o = n.attributes, i = n.main, a = n.transform, s = n.styles, l = mb(s);
        l.length > 0 && (o.style = l);
        var u;
        return Ik(a) && (u = el("generateAbstractTransformGrouping", {
          main: i,
          transform: a,
          containerWidth: i.width,
          iconWidth: i.width
        })), r.push(u || i.icon), {
          children: r,
          attributes: o
        };
      };
    }
  }, tre = {
    mixout: function() {
      return {
        layer: function(n) {
          var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o = r.classes, i = o === void 0 ? [] : o;
          return vb({
            type: "layer"
          }, function() {
            oc("beforeDOMElementCreation", {
              assembler: n,
              params: r
            });
            var a = [];
            return n(function(s) {
              Array.isArray(s) ? s.map(function(l) {
                a = a.concat(l.abstract);
              }) : a = a.concat(s.abstract);
            }), [{
              tag: "span",
              attributes: {
                class: ["".concat(We.cssPrefix, "-layers")].concat(Yo(i)).join(" ")
              },
              children: a
            }];
          });
        }
      };
    }
  }, nre = {
    mixout: function() {
      return {
        counter: function(n) {
          var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          r.title;
          var o = r.classes, i = o === void 0 ? [] : o, a = r.attributes, s = a === void 0 ? {} : a, l = r.styles, u = l === void 0 ? {} : l;
          return vb({
            type: "counter",
            content: n
          }, function() {
            return oc("beforeDOMElementCreation", {
              content: n,
              params: r
            }), $ne({
              content: n.toString(),
              extra: {
                attributes: s,
                styles: u,
                classes: ["".concat(We.cssPrefix, "-layers-counter")].concat(Yo(i))
              }
            });
          });
        }
      };
    }
  }, rre = {
    mixout: function() {
      return {
        text: function(n) {
          var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o = r.transform, i = o === void 0 ? Ri : o, a = r.classes, s = a === void 0 ? [] : a, l = r.attributes, u = l === void 0 ? {} : l, d = r.styles, p = d === void 0 ? {} : d;
          return vb({
            type: "text",
            content: n
          }, function() {
            return oc("beforeDOMElementCreation", {
              content: n,
              params: r
            }), P$({
              content: n,
              transform: Te(Te({}, Ri), i),
              extra: {
                attributes: u,
                styles: p,
                classes: ["".concat(We.cssPrefix, "-layers-text")].concat(Yo(s))
              }
            });
          });
        }
      };
    },
    provides: function(t) {
      t.generateLayersText = function(n, r) {
        var o = r.transform, i = r.extra, a = null, s = null;
        if (QF) {
          var l = parseInt(getComputedStyle(n).fontSize, 10), u = n.getBoundingClientRect();
          a = u.width / l, s = u.height / l;
        }
        return Promise.resolve([n, P$({
          content: n.innerHTML,
          width: a,
          height: s,
          transform: o,
          extra: i,
          watchable: !0
        })]);
      };
    }
  }, GL = new RegExp('"', "ug"), z$ = [1105920, 1112319], B$ = Te(Te(Te(Te({}, {
    FontAwesome: {
      normal: "fas",
      400: "fas"
    }
  }), qee), Hte), ete), AE = Object.keys(B$).reduce(function(e, t) {
    return e[t.toLowerCase()] = B$[t], e;
  }, {}), ore = Object.keys(AE).reduce(function(e, t) {
    var n = AE[t];
    return e[t] = n[900] || Yo(Object.entries(n))[0][1], e;
  }, {});
  function ire(e) {
    var t = e.replace(GL, "");
    return AL(Yo(t)[0] || "");
  }
  function are(e) {
    var t = e.getPropertyValue("font-feature-settings").includes("ss01"), n = e.getPropertyValue("content"), r = n.replace(GL, ""), o = r.codePointAt(0), i = o >= z$[0] && o <= z$[1], a = r.length === 2 ? r[0] === r[1] : !1;
    return i || a || t;
  }
  function sre(e, t) {
    var n = e.replace(/^['"]|['"]$/g, "").toLowerCase(), r = parseInt(t), o = isNaN(r) ? "normal" : r;
    return (AE[n] || {})[o] || ore[n];
  }
  function U$(e, t) {
    var n = "".concat(qte).concat(t.replace(":", "-"));
    return new Promise(function(r, o) {
      if (e.getAttribute(n) !== null)
        return r();
      var i = kf(e.children), a = i.filter(function(R) {
        return R.getAttribute(xE) === t;
      })[0], s = Qs.getComputedStyle(e, t), l = s.getPropertyValue("font-family"), u = l.match(Xte), d = s.getPropertyValue("font-weight"), p = s.getPropertyValue("content");
      if (a && !u)
        return e.removeChild(a), r();
      if (u && p !== "none" && p !== "") {
        var h = s.getPropertyValue("content"), g = sre(l, d), y = ire(h), b = u[0].startsWith("FontAwesome"), v = are(s), x = Dk(g, y), E = x;
        if (b) {
          var _ = yne(y);
          _.iconName && _.prefix && (x = _.iconName, g = _.prefix);
        }
        if (x && !v && (!a || a.getAttribute(Mk) !== g || a.getAttribute(Pk) !== E)) {
          e.setAttribute(n, E), a && e.removeChild(a);
          var C = Kne(), k = C.extra;
          k.attributes[xE] = t, TE(x, g).then(function(R) {
            var A = Fk(Te(Te({}, C), {}, {
              icons: {
                main: R,
                mask: zL()
              },
              prefix: g,
              iconName: E,
              extra: k,
              watchable: !0
            })), M = hn.createElementNS("http://www.w3.org/2000/svg", "svg");
            t === "::before" ? e.insertBefore(M, e.firstChild) : e.appendChild(M), M.outerHTML = A.map(function(I) {
              return Lh(I);
            }).join(`
`), e.removeAttribute(n), r();
          }).catch(o);
        } else
          r();
      } else
        r();
    });
  }
  function lre(e) {
    return Promise.all([U$(e, "::before"), U$(e, "::after")]);
  }
  function cre(e) {
    return e.parentNode !== document.head && !~Gte.indexOf(e.tagName.toUpperCase()) && !e.getAttribute(xE) && (!e.parentNode || e.parentNode.tagName !== "svg");
  }
  var ure = function(t) {
    return !!t && xL.some(function(n) {
      return t.includes(n);
    });
  }, fre = function(t) {
    if (!t) return [];
    for (var n = /* @__PURE__ */ new Set(), r = [t], o = [/(?=\s:)/, /(?<=\)\)?[^,]*,)/], i = function() {
      var g = s[a];
      r = r.flatMap(function(y) {
        return y.split(g).map(function(b) {
          return b.replace(/,\s*$/, "").trim();
        });
      });
    }, a = 0, s = o; a < s.length; a++)
      i();
    r = r.flatMap(function(h) {
      return h.includes("(") ? h : h.split(",").map(function(g) {
        return g.trim();
      });
    });
    var l = mv(r), u;
    try {
      for (l.s(); !(u = l.n()).done; ) {
        var d = u.value;
        if (ure(d)) {
          var p = xL.reduce(function(h, g) {
            return h.replace(g, "");
          }, d);
          p !== "" && p !== "*" && n.add(p);
        }
      }
    } catch (h) {
      l.e(h);
    } finally {
      l.f();
    }
    return n;
  };
  function V$(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (Wa) {
      var n;
      if (t)
        n = e;
      else if (We.searchPseudoElementsFullScan)
        n = e.querySelectorAll("*");
      else {
        var r = /* @__PURE__ */ new Set(), o = mv(document.styleSheets), i;
        try {
          for (o.s(); !(i = o.n()).done; ) {
            var a = i.value;
            try {
              var s = mv(a.cssRules), l;
              try {
                for (s.s(); !(l = s.n()).done; ) {
                  var u = l.value, d = fre(u.selectorText), p = mv(d), h;
                  try {
                    for (p.s(); !(h = p.n()).done; ) {
                      var g = h.value;
                      r.add(g);
                    }
                  } catch (b) {
                    p.e(b);
                  } finally {
                    p.f();
                  }
                }
              } catch (b) {
                s.e(b);
              } finally {
                s.f();
              }
            } catch (b) {
              We.searchPseudoElementsWarnings && console.warn("Font Awesome: cannot parse stylesheet: ".concat(a.href, " (").concat(b.message, `)
If it declares any Font Awesome CSS pseudo-elements, they will not be rendered as SVG icons. Add crossorigin="anonymous" to the <link>, enable searchPseudoElementsFullScan for slower but more thorough DOM parsing, or suppress this warning by setting searchPseudoElementsWarnings to false.`));
            }
          }
        } catch (b) {
          o.e(b);
        } finally {
          o.f();
        }
        if (!r.size) return;
        var y = Array.from(r).join(", ");
        try {
          n = e.querySelectorAll(y);
        } catch {
        }
      }
      return new Promise(function(b, v) {
        var x = kf(n).filter(cre).map(lre), E = Lk.begin("searchPseudoElements");
        qL(), Promise.all(x).then(function() {
          E(), OE(), b();
        }).catch(function() {
          E(), OE(), v();
        });
      });
    }
  }
  var dre = {
    hooks: function() {
      return {
        mutationObserverCallbacks: function(n) {
          return n.pseudoElementsCallback = V$, n;
        }
      };
    },
    provides: function(t) {
      t.pseudoElements2svg = function(n) {
        var r = n.node, o = r === void 0 ? hn : r;
        We.searchPseudoElements && V$(o);
      };
    }
  }, H$ = !1, pre = {
    mixout: function() {
      return {
        dom: {
          unwatch: function() {
            qL(), H$ = !0;
          }
        }
      };
    },
    hooks: function() {
      return {
        bootstrap: function() {
          D$(EE("mutationObserverCallbacks", {}));
        },
        noAuto: function() {
          Hne();
        },
        watch: function(n) {
          var r = n.observeMutationsRoot;
          H$ ? OE() : D$(EE("mutationObserverCallbacks", {
            observeMutationsRoot: r
          }));
        }
      };
    }
  }, q$ = function(t) {
    var n = {
      size: 16,
      x: 0,
      y: 0,
      flipX: !1,
      flipY: !1,
      rotate: 0
    };
    return t.toLowerCase().split(" ").reduce(function(r, o) {
      var i = o.toLowerCase().split("-"), a = i[0], s = i.slice(1).join("-");
      if (a && s === "h")
        return r.flipX = !0, r;
      if (a && s === "v")
        return r.flipY = !0, r;
      if (s = parseFloat(s), isNaN(s))
        return r;
      switch (a) {
        case "grow":
          r.size = r.size + s;
          break;
        case "shrink":
          r.size = r.size - s;
          break;
        case "left":
          r.x = r.x - s;
          break;
        case "right":
          r.x = r.x + s;
          break;
        case "up":
          r.y = r.y - s;
          break;
        case "down":
          r.y = r.y + s;
          break;
        case "rotate":
          r.rotate = r.rotate + s;
          break;
      }
      return r;
    }, n);
  }, hre = {
    mixout: function() {
      return {
        parse: {
          transform: function(n) {
            return q$(n);
          }
        }
      };
    },
    hooks: function() {
      return {
        parseNodeAttributes: function(n, r) {
          var o = r.getAttribute("data-fa-transform");
          return o && (n.transform = q$(o)), n;
        }
      };
    },
    provides: function(t) {
      t.generateAbstractTransformGrouping = function(n) {
        var r = n.main, o = n.transform, i = n.containerWidth, a = n.iconWidth, s = {
          transform: "translate(".concat(i / 2, " 256)")
        }, l = "translate(".concat(o.x * 32, ", ").concat(o.y * 32, ") "), u = "scale(".concat(o.size / 16 * (o.flipX ? -1 : 1), ", ").concat(o.size / 16 * (o.flipY ? -1 : 1), ") "), d = "rotate(".concat(o.rotate, " 0 0)"), p = {
          transform: "".concat(l, " ").concat(u, " ").concat(d)
        }, h = {
          transform: "translate(".concat(a / 2 * -1, " -256)")
        }, g = {
          outer: s,
          inner: p,
          path: h
        };
        return {
          tag: "g",
          attributes: Te({}, g.outer),
          children: [{
            tag: "g",
            attributes: Te({}, g.inner),
            children: [{
              tag: r.icon.tag,
              children: r.icon.children,
              attributes: Te(Te({}, r.icon.attributes), g.path)
            }]
          }]
        };
      };
    }
  }, wS = {
    x: 0,
    y: 0,
    width: "100%",
    height: "100%"
  };
  function W$(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return e.attributes && (e.attributes.fill || t) && (e.attributes.fill = "black"), e;
  }
  function mre(e) {
    return e.tag === "g" ? e.children : [e];
  }
  var gre = {
    hooks: function() {
      return {
        parseNodeAttributes: function(n, r) {
          var o = r.getAttribute("data-fa-mask"), i = o ? yb(o.split(" ").map(function(a) {
            return a.trim();
          })) : zL();
          return i.prefix || (i.prefix = Js()), n.mask = i, n.maskId = r.getAttribute("data-fa-mask-id"), n;
        }
      };
    },
    provides: function(t) {
      t.generateAbstractMask = function(n) {
        var r = n.children, o = n.attributes, i = n.main, a = n.mask, s = n.maskId, l = n.transform, u = i.width, d = i.icon, p = a.width, h = a.icon, g = sne({
          transform: l,
          containerWidth: p,
          iconWidth: u
        }), y = {
          tag: "rect",
          attributes: Te(Te({}, wS), {}, {
            fill: "white"
          })
        }, b = d.children ? {
          children: d.children.map(W$)
        } : {}, v = {
          tag: "g",
          attributes: Te({}, g.inner),
          children: [W$(Te({
            tag: d.tag,
            attributes: Te(Te({}, d.attributes), g.path)
          }, b))]
        }, x = {
          tag: "g",
          attributes: Te({}, g.outer),
          children: [v]
        }, E = "mask-".concat(s || k$()), _ = "clip-".concat(s || k$()), C = {
          tag: "mask",
          attributes: Te(Te({}, wS), {}, {
            id: E,
            maskUnits: "userSpaceOnUse",
            maskContentUnits: "userSpaceOnUse"
          }),
          children: [y, x]
        }, k = {
          tag: "defs",
          children: [{
            tag: "clipPath",
            attributes: {
              id: _
            },
            children: mre(h)
          }, C]
        };
        return r.push(k, {
          tag: "rect",
          attributes: Te({
            fill: "currentColor",
            "clip-path": "url(#".concat(_, ")"),
            mask: "url(#".concat(E, ")")
          }, wS)
        }), {
          children: r,
          attributes: o
        };
      };
    }
  }, yre = {
    provides: function(t) {
      var n = !1;
      Qs.matchMedia && (n = Qs.matchMedia("(prefers-reduced-motion: reduce)").matches), t.missingIconAbstract = function() {
        var r = [], o = {
          fill: "currentColor"
        }, i = {
          attributeType: "XML",
          repeatCount: "indefinite",
          dur: "2s"
        };
        r.push({
          tag: "path",
          attributes: Te(Te({}, o), {}, {
            d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
          })
        });
        var a = Te(Te({}, i), {}, {
          attributeName: "opacity"
        }), s = {
          tag: "circle",
          attributes: Te(Te({}, o), {}, {
            cx: "256",
            cy: "364",
            r: "28"
          }),
          children: []
        };
        return n || s.children.push({
          tag: "animate",
          attributes: Te(Te({}, i), {}, {
            attributeName: "r",
            values: "28;14;28;28;14;28;"
          })
        }, {
          tag: "animate",
          attributes: Te(Te({}, a), {}, {
            values: "1;0;1;1;0;1;"
          })
        }), r.push(s), r.push({
          tag: "path",
          attributes: Te(Te({}, o), {}, {
            opacity: "1",
            d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
          }),
          children: n ? [] : [{
            tag: "animate",
            attributes: Te(Te({}, a), {}, {
              values: "1;0;0;0;0;1;"
            })
          }]
        }), n || r.push({
          tag: "path",
          attributes: Te(Te({}, o), {}, {
            opacity: "0",
            d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
          }),
          children: [{
            tag: "animate",
            attributes: Te(Te({}, a), {}, {
              values: "0;0;1;1;0;0;"
            })
          }]
        }), {
          tag: "g",
          attributes: {
            class: "missing"
          },
          children: r
        };
      };
    }
  }, vre = {
    hooks: function() {
      return {
        parseNodeAttributes: function(n, r) {
          var o = r.getAttribute("data-fa-symbol"), i = o === null ? !1 : o === "" ? !0 : o;
          return n.symbol = i, n;
        }
      };
    }
  }, bre = [une, ere, tre, nre, rre, dre, pre, hre, gre, yre, vre];
  kne(bre, {
    mixoutsTo: uo
  });
  uo.noAuto;
  var xre = uo.config;
  uo.library;
  uo.dom;
  var NE = uo.parse;
  uo.findIconDefinition;
  uo.toHtml;
  var wre = uo.icon;
  uo.layer;
  uo.text;
  uo.counter;
  function ME(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
    return r;
  }
  function Sre(e) {
    if (Array.isArray(e)) return e;
  }
  function _re(e) {
    if (Array.isArray(e)) return ME(e);
  }
  function Fs(e, t, n) {
    return (t = Nre(t)) in e ? Object.defineProperty(e, t, {
      value: n,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[t] = n, e;
  }
  function Ere(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
  }
  function Cre(e, t) {
    var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n != null) {
      var r, o, i, a, s = [], l = !0, u = !1;
      try {
        if (i = (n = n.call(e)).next, t !== 0) for (; !(l = (r = i.call(n)).done) && (s.push(r.value), s.length !== t); l = !0) ;
      } catch (d) {
        u = !0, o = d;
      } finally {
        try {
          if (!l && n.return != null && (a = n.return(), Object(a) !== a)) return;
        } finally {
          if (u) throw o;
        }
      }
      return s;
    }
  }
  function kre() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function Tre() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function G$(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var r = Object.getOwnPropertySymbols(e);
      t && (r = r.filter(function(o) {
        return Object.getOwnPropertyDescriptor(e, o).enumerable;
      })), n.push.apply(n, r);
    }
    return n;
  }
  function _i(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t] != null ? arguments[t] : {};
      t % 2 ? G$(Object(n), !0).forEach(function(r) {
        Fs(e, r, n[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : G$(Object(n)).forEach(function(r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
      });
    }
    return e;
  }
  function Rre(e, t) {
    if (e == null) return {};
    var n, r, o = Ore(e, t);
    if (Object.getOwnPropertySymbols) {
      var i = Object.getOwnPropertySymbols(e);
      for (r = 0; r < i.length; r++) n = i[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
    }
    return o;
  }
  function Ore(e, t) {
    if (e == null) return {};
    var n = {};
    for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue;
      n[r] = e[r];
    }
    return n;
  }
  function K$(e, t) {
    return Sre(e) || Cre(e, t) || KL(e, t) || kre();
  }
  function PE(e) {
    return _re(e) || Ere(e) || KL(e) || Tre();
  }
  function Are(e, t) {
    if (typeof e != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
      var r = n.call(e, t);
      if (typeof r != "object") return r;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (t === "string" ? String : Number)(e);
  }
  function Nre(e) {
    var t = Are(e, "string");
    return typeof t == "symbol" ? t : t + "";
  }
  function Kv(e) {
    "@babel/helpers - typeof";
    return Kv = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
      return typeof t;
    } : function(t) {
      return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
    }, Kv(e);
  }
  function KL(e, t) {
    if (e) {
      if (typeof e == "string") return ME(e, t);
      var n = {}.toString.call(e).slice(8, -1);
      return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? ME(e, t) : void 0;
    }
  }
  var Mre = "7.0.0-alpha1", $E;
  try {
    var Pre = require("@fortawesome/fontawesome-svg-core/package.json");
    $E = Pre.version;
  } catch {
    $E = "7.0.0";
  }
  function $re(e) {
    var t = e.beat, n = e.fade, r = e.beatFade, o = e.bounce, i = e.shake, a = e.flash, s = e.spin, l = e.spinPulse, u = e.spinReverse, d = e.pulse, p = e.fixedWidth, h = e.inverse, g = e.border, y = e.listItem, b = e.flip, v = e.size, x = e.rotation, E = e.pull, _ = e.swapOpacity, C = e.rotateBy, k = e.widthAuto, R = Ire($E, Mre), A = Fs(Fs(Fs(Fs(Fs(Fs({
      "fa-beat": t,
      "fa-fade": n,
      "fa-beat-fade": r,
      "fa-bounce": o,
      "fa-shake": i,
      "fa-flash": a,
      "fa-spin": s,
      "fa-spin-reverse": u,
      "fa-spin-pulse": l,
      "fa-pulse": d,
      "fa-fw": p,
      "fa-inverse": h,
      "fa-border": g,
      "fa-li": y,
      "fa-flip": b === !0,
      "fa-flip-horizontal": b === "horizontal" || b === "both",
      "fa-flip-vertical": b === "vertical" || b === "both"
    }, "fa-".concat(v), typeof v < "u" && v !== null), "fa-rotate-".concat(x), typeof x < "u" && x !== null && x !== 0), "fa-pull-".concat(E), typeof E < "u" && E !== null), "fa-swap-opacity", _), "fa-rotate-by", R && C), "fa-width-auto", R && k);
    return Object.keys(A).map(function(M) {
      return A[M] ? M : null;
    }).filter(function(M) {
      return M;
    });
  }
  function Ire(e, t) {
    for (var n = e.split("-"), r = K$(n, 2), o = r[0], i = r[1], a = t.split("-"), s = K$(a, 2), l = s[0], u = s[1], d = o.split("."), p = l.split("."), h = 0; h < Math.max(d.length, p.length); h++) {
      var g = d[h] || "0", y = p[h] || "0", b = parseInt(g, 10), v = parseInt(y, 10);
      if (b !== v)
        return b > v;
    }
    for (var x = 0; x < Math.max(d.length, p.length); x++) {
      var E = d[x] || "0", _ = p[x] || "0";
      if (E !== _ && E.length !== _.length)
        return E.length < _.length;
    }
    return !(i && !u);
  }
  function jre(e) {
    return e = e - 0, e === e;
  }
  function YL(e) {
    return jre(e) ? e : (e = e.replace(/[\-_\s]+(.)?/g, function(t, n) {
      return n ? n.toUpperCase() : "";
    }), e.substr(0, 1).toLowerCase() + e.substr(1));
  }
  var Dre = ["style"];
  function Fre(e) {
    return e.charAt(0).toUpperCase() + e.slice(1);
  }
  function Lre(e) {
    return e.split(";").map(function(t) {
      return t.trim();
    }).filter(function(t) {
      return t;
    }).reduce(function(t, n) {
      var r = n.indexOf(":"), o = YL(n.slice(0, r)), i = n.slice(r + 1).trim();
      return o.startsWith("webkit") ? t[Fre(o)] = i : t[o] = i, t;
    }, {});
  }
  function XL(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (typeof t == "string")
      return t;
    var r = (t.children || []).map(function(l) {
      return XL(e, l);
    }), o = Object.keys(t.attributes || {}).reduce(function(l, u) {
      var d = t.attributes[u];
      switch (u) {
        case "class":
          l.attrs.className = d, delete t.attributes.class;
          break;
        case "style":
          l.attrs.style = Lre(d);
          break;
        default:
          u.indexOf("aria-") === 0 || u.indexOf("data-") === 0 ? l.attrs[u.toLowerCase()] = d : l.attrs[YL(u)] = d;
      }
      return l;
    }, {
      attrs: {}
    }), i = n.style, a = i === void 0 ? {} : i, s = Rre(n, Dre);
    return o.attrs.style = _i(_i({}, o.attrs.style), a), e.apply(void 0, [t.tag, _i(_i({}, o.attrs), s)].concat(PE(r)));
  }
  var ZL = !1;
  try {
    ZL = !0;
  } catch {
  }
  function zre() {
    if (!ZL && console && typeof console.error == "function") {
      var e;
      (e = console).error.apply(e, arguments);
    }
  }
  function Y$(e) {
    if (e && Kv(e) === "object" && e.prefix && e.iconName && e.icon)
      return e;
    if (NE.icon)
      return NE.icon(e);
    if (e === null)
      return null;
    if (e && Kv(e) === "object" && e.prefix && e.iconName)
      return e;
    if (Array.isArray(e) && e.length === 2)
      return {
        prefix: e[0],
        iconName: e[1]
      };
    if (typeof e == "string")
      return {
        prefix: "fas",
        iconName: e
      };
  }
  function SS(e, t) {
    return Array.isArray(t) && t.length > 0 || !Array.isArray(t) && t ? Fs({}, e, t) : {};
  }
  var X$ = {
    border: !1,
    className: "",
    mask: null,
    maskId: null,
    // the fixedWidth property has been deprecated as of version 7
    fixedWidth: !1,
    inverse: !1,
    flip: !1,
    icon: null,
    listItem: !1,
    pull: null,
    pulse: !1,
    rotation: null,
    rotateBy: !1,
    size: null,
    spin: !1,
    spinPulse: !1,
    spinReverse: !1,
    beat: !1,
    fade: !1,
    beatFade: !1,
    bounce: !1,
    shake: !1,
    symbol: !1,
    title: "",
    titleId: null,
    transform: null,
    swapOpacity: !1,
    widthAuto: !1
  }, Bk = /* @__PURE__ */ Tn.forwardRef(function(e, t) {
    var n = _i(_i({}, X$), e), r = n.icon, o = n.mask, i = n.symbol, a = n.className, s = n.title, l = n.titleId, u = n.maskId, d = Y$(r), p = SS("classes", [].concat(PE($re(n)), PE((a || "").split(" ")))), h = SS("transform", typeof n.transform == "string" ? NE.transform(n.transform) : n.transform), g = SS("mask", Y$(o)), y = wre(d, _i(_i(_i(_i({}, p), h), g), {}, {
      symbol: i,
      title: s,
      titleId: l,
      maskId: u
    }));
    if (!y)
      return zre("Could not find icon", d), null;
    var b = y.abstract, v = {
      ref: t
    };
    return Object.keys(n).forEach(function(x) {
      X$.hasOwnProperty(x) || (v[x] = n[x]);
    }), Bre(b[0], v);
  });
  Bk.displayName = "FontAwesomeIcon";
  Bk.propTypes = {
    beat: ht.bool,
    border: ht.bool,
    beatFade: ht.bool,
    bounce: ht.bool,
    className: ht.string,
    fade: ht.bool,
    flash: ht.bool,
    mask: ht.oneOfType([ht.object, ht.array, ht.string]),
    maskId: ht.string,
    // the fixedWidth property has been deprecated as of version 7
    fixedWidth: ht.bool,
    inverse: ht.bool,
    flip: ht.oneOf([!0, !1, "horizontal", "vertical", "both"]),
    icon: ht.oneOfType([ht.object, ht.array, ht.string]),
    listItem: ht.bool,
    pull: ht.oneOf(["right", "left"]),
    pulse: ht.bool,
    rotation: ht.oneOf([0, 90, 180, 270]),
    rotateBy: ht.bool,
    shake: ht.bool,
    size: ht.oneOf(["2xs", "xs", "sm", "lg", "xl", "2xl", "1x", "2x", "3x", "4x", "5x", "6x", "7x", "8x", "9x", "10x"]),
    spin: ht.bool,
    spinPulse: ht.bool,
    spinReverse: ht.bool,
    symbol: ht.oneOfType([ht.bool, ht.string]),
    title: ht.string,
    titleId: ht.string,
    transform: ht.oneOfType([ht.string, ht.object]),
    swapOpacity: ht.bool,
    widthAuto: ht.bool
  };
  var Bre = XL.bind(null, Tn.createElement);
  /*!
   * Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com
   * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
   * Copyright 2025 Fonticons, Inc.
   */
  var Ure = {
    prefix: "fas",
    iconName: "magnifying-glass",
    icon: [512, 512, [128269, "search"], "f002", "M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376C296.3 401.1 253.9 416 208 416 93.1 416 0 322.9 0 208S93.1 0 208 0 416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"]
  }, Vre = {
    prefix: "fas",
    iconName: "chevron-up",
    icon: [448, 512, [], "f077", "M201.4 105.4c12.5-12.5 32.8-12.5 45.3 0l192 192c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L224 173.3 54.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l192-192z"]
  }, Hre = {
    prefix: "fas",
    iconName: "expand",
    icon: [448, 512, [], "f065", "M32 32C14.3 32 0 46.3 0 64l0 96c0 17.7 14.3 32 32 32s32-14.3 32-32l0-64 64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L32 32zM64 352c0-17.7-14.3-32-32-32S0 334.3 0 352l0 96c0 17.7 14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-64zM320 32c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0 0 64c0 17.7 14.3 32 32 32s32-14.3 32-32l0-96c0-17.7-14.3-32-32-32l-96 0zM448 352c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 64-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32l0-96z"]
  }, qre = {
    prefix: "fas",
    iconName: "chevron-right",
    icon: [320, 512, [9002], "f054", "M311.1 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L243.2 256 73.9 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z"]
  }, Wre = {
    prefix: "fas",
    iconName: "circle-xmark",
    icon: [512, 512, [61532, "times-circle", "xmark-circle"], "f057", "M256 512a256 256 0 1 0 0-512 256 256 0 1 0 0 512zM167 167c9.4-9.4 24.6-9.4 33.9 0l55 55 55-55c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-55 55 55 55c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-55-55-55 55c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l55-55-55-55c-9.4-9.4-9.4-24.6 0-33.9z"]
  }, Gre = {
    prefix: "fas",
    iconName: "network-wired",
    icon: [576, 512, [], "f6ff", "M248 88l80 0 0 48-80 0 0-48zm-8-56c-26.5 0-48 21.5-48 48l0 64c0 26.5 21.5 48 48 48l16 0 0 32-224 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0 0 32-16 0c-26.5 0-48 21.5-48 48l0 64c0 26.5 21.5 48 48 48l96 0c26.5 0 48-21.5 48-48l0-64c0-26.5-21.5-48-48-48l-16 0 0-32 192 0 0 32-16 0c-26.5 0-48 21.5-48 48l0 64c0 26.5 21.5 48 48 48l96 0c26.5 0 48-21.5 48-48l0-64c0-26.5-21.5-48-48-48l-16 0 0-32 96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-224 0 0-32 16 0c26.5 0 48-21.5 48-48l0-64c0-26.5-21.5-48-48-48l-96 0zM448 376l8 0 0 48-80 0 0-48 72 0zm-256 0l8 0 0 48-80 0 0-48 72 0z"]
  }, Kre = {
    prefix: "fas",
    iconName: "gear",
    icon: [512, 512, [9881, "cog"], "f013", "M195.1 9.5C198.1-5.3 211.2-16 226.4-16l59.8 0c15.2 0 28.3 10.7 31.3 25.5L332 79.5c14.1 6 27.3 13.7 39.3 22.8l67.8-22.5c14.4-4.8 30.2 1.2 37.8 14.4l29.9 51.8c7.6 13.2 4.9 29.8-6.5 39.9L447 233.3c.9 7.4 1.3 15 1.3 22.7s-.5 15.3-1.3 22.7l53.4 47.5c11.4 10.1 14 26.8 6.5 39.9l-29.9 51.8c-7.6 13.1-23.4 19.2-37.8 14.4l-67.8-22.5c-12.1 9.1-25.3 16.7-39.3 22.8l-14.4 69.9c-3.1 14.9-16.2 25.5-31.3 25.5l-59.8 0c-15.2 0-28.3-10.7-31.3-25.5l-14.4-69.9c-14.1-6-27.2-13.7-39.3-22.8L73.5 432.3c-14.4 4.8-30.2-1.2-37.8-14.4L5.8 366.1c-7.6-13.2-4.9-29.8 6.5-39.9l53.4-47.5c-.9-7.4-1.3-15-1.3-22.7s.5-15.3 1.3-22.7L12.3 185.8c-11.4-10.1-14-26.8-6.5-39.9L35.7 94.1c7.6-13.2 23.4-19.2 37.8-14.4l67.8 22.5c12.1-9.1 25.3-16.7 39.3-22.8L195.1 9.5zM256.3 336a80 80 0 1 0 -.6-160 80 80 0 1 0 .6 160z"]
  }, Yre = {
    prefix: "fas",
    iconName: "up-right-and-down-left-from-center",
    icon: [512, 512, ["expand-alt"], "f424", "M344 0L488 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39-87 87c-9.4 9.4-24.6 9.4-33.9 0l-32-32c-9.4-9.4-9.4-24.6 0-33.9l87-87-39-39c-6.9-6.9-8.9-17.2-5.2-26.2S334.3 0 344 0zM168 512L24 512c-13.3 0-24-10.7-24-24L0 344c0-9.7 5.8-18.5 14.8-22.2S34.1 320.2 41 327l39 39 87-87c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2S177.7 512 168 512z"]
  }, Xre = {
    prefix: "fas",
    iconName: "xmark",
    icon: [384, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M55.1 73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L147.2 256 9.9 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192.5 301.3 329.9 438.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.8 256 375.1 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192.5 210.7 55.1 73.4z"]
  }, Zre = {
    prefix: "fas",
    iconName: "lock-open",
    icon: [576, 512, [], "f3c1", "M384 96c0-35.3 28.7-64 64-64s64 28.7 64 64l0 32c0 17.7 14.3 32 32 32s32-14.3 32-32l0-32c0-70.7-57.3-128-128-128S320 25.3 320 96l0 64-160 0c-35.3 0-64 28.7-64 64l0 224c0 35.3 28.7 64 64 64l256 0c35.3 0 64-28.7 64-64l0-224c0-35.3-28.7-64-64-64l-32 0 0-64z"]
  }, Qre = {
    prefix: "fas",
    iconName: "circle-check",
    icon: [512, 512, [61533, "check-circle"], "f058", "M256 512a256 256 0 1 0 0-512 256 256 0 1 0 0 512zm84.4-299.3l-80 128c-4.2 6.7-11.4 10.9-19.3 11.3s-15.5-3.2-20.2-9.6l-48-64c-8-10.6-5.8-25.6 4.8-33.6s25.6-5.8 33.6 4.8l27 36 61.4-98.3c7-11.2 21.8-14.7 33.1-7.6s14.7 21.8 7.6 33.1z"]
  }, Jre = {
    prefix: "fas",
    iconName: "circle-play",
    icon: [512, 512, [61469, "play-circle"], "f144", "M0 256a256 256 0 1 1 512 0 256 256 0 1 1 -512 0zM188.3 147.1c-7.6 4.2-12.3 12.3-12.3 20.9l0 176c0 8.7 4.7 16.7 12.3 20.9s16.8 4.1 24.3-.5l144-88c7.1-4.4 11.5-12.1 11.5-20.5s-4.4-16.1-11.5-20.5l-144-88c-7.4-4.5-16.7-4.7-24.3-.5z"]
  }, eoe = {
    prefix: "fas",
    iconName: "chevron-down",
    icon: [448, 512, [], "f078", "M201.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 338.7 54.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"]
  }, toe = {
    prefix: "fas",
    iconName: "chevron-left",
    icon: [320, 512, [9001], "f053", "M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l192 192c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256 246.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192z"]
  }, noe = {
    prefix: "fas",
    iconName: "lock",
    icon: [384, 512, [128274], "f023", "M128 96l0 64 128 0 0-64c0-35.3-28.7-64-64-64s-64 28.7-64 64zM64 160l0-64C64 25.3 121.3-32 192-32S320 25.3 320 96l0 64c35.3 0 64 28.7 64 64l0 224c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64L0 224c0-35.3 28.7-64 64-64z"]
  }, roe = {
    prefix: "fas",
    iconName: "down-left-and-up-right-to-center",
    icon: [512, 512, ["compress-alt"], "f422", "M439.5 7c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2S450.2 240 440.5 240l-144 0c-13.3 0-24-10.7-24-24l0-144c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2l39 39 87-87zM72.5 272l144 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39-87 87c-9.4 9.4-24.6 9.4-33.9 0l-32-32c-9.4-9.4-9.4-24.6 0-33.9l87-87-39-39c-6.9-6.9-8.9-17.2-5.2-26.2S62.8 272 72.5 272z"]
  }, ooe = {
    prefix: "fas",
    iconName: "compress",
    icon: [448, 512, [], "f066", "M160 64c0-17.7-14.3-32-32-32S96 46.3 96 64l0 64-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32l0-96zM32 320c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0 0 64c0 17.7 14.3 32 32 32s32-14.3 32-32l0-96c0-17.7-14.3-32-32-32l-96 0zM352 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-64zM320 320c-17.7 0-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32s32-14.3 32-32l0-64 64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-96 0z"]
  }, ioe = {
    prefix: "fas",
    iconName: "bars",
    icon: [448, 512, ["navicon"], "f0c9", "M0 96C0 78.3 14.3 64 32 64l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 128C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 288c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32L32 448c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"]
  };
  xre.autoAddCss = !1;
  const tr = (e) => {
    const { style: t, ...n } = e;
    return /* @__PURE__ */ S.jsx("span", { style: t, children: /* @__PURE__ */ S.jsx(Bk, { ...n }) });
  }, Uk = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: ioe }), Kp = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: qre }), Yv = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: toe }), QL = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Hre }), aoe = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: ooe }), soe = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: roe }), loe = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Yre }), Xv = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: eoe }), Yp = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Vre }), zh = Yp, bb = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Xre }), coe = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Zre }), uoe = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: noe }), foe = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Gre }), doe = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Jre }), poe = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Ure }), hoe = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Kre }), moe = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Qre }), goe = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Wre }), JL = T.createContext(null), jt = () => {
    const e = T.useContext(JL);
    if (!e)
      throw new Error(
        "useFuncNodesContext must be used within a FuncNodesContext.Provider"
      );
    return e;
  }, ez = T.createContext(
    void 0
  ), Vk = () => {
    const e = T.useContext(ez);
    if (!e)
      throw new Error("useKeyPress must be used within a KeyPressProvider");
    return e;
  }, yoe = ({
    children: e,
    preventDefault: t = !1,
    ignoredKeys: n = [],
    debug: r = !1,
    target: o
  }) => {
    const [i, a] = T.useState(/* @__PURE__ */ new Set()), s = T.useMemo(
      () => new Set(n),
      [n]
    ), l = T.useRef(i);
    l.current = i;
    const u = T.useMemo(
      () => ({
        keys: i,
        isKeyPressed: (d) => i.has(d),
        areKeysPressed: (...d) => d.every((p) => i.has(p)),
        isAnyKeyPressed: (...d) => d.some((p) => i.has(p))
      }),
      [i]
    );
    return T.useEffect(() => {
      const d = o ?? window;
      if (!d) return;
      const p = (b) => {
        const v = b.key;
        s.has(v) || (t && b.preventDefault(), l.current.has(v) || (r && console.log(`[KeyPress] Key down: ${v}`), a((x) => {
          const E = new Set(x);
          return E.add(v), E;
        })));
      }, h = (b) => {
        const v = b.key;
        l.current.has(v) && (r && console.log(`[KeyPress] Key up: ${v}`), a((x) => {
          const E = new Set(x);
          return E.delete(v), E;
        }));
      }, g = () => {
        l.current.size > 0 && (r && console.log("[KeyPress] Window blur - clearing all keys"), a(/* @__PURE__ */ new Set()));
      }, y = () => {
        document.hidden && l.current.size > 0 && (r && console.log("[KeyPress] Tab hidden - clearing all keys"), a(/* @__PURE__ */ new Set()));
      };
      return d.addEventListener("keydown", p), d.addEventListener("keyup", h), d.addEventListener("blur", g), document.addEventListener("visibilitychange", y), () => {
        d.removeEventListener("keydown", p), d.removeEventListener("keyup", h), d.removeEventListener("blur", g), document.removeEventListener("visibilitychange", y);
      };
    }, [t, s, r, o]), /* @__PURE__ */ S.jsx(ez.Provider, { value: u, children: e });
  }, tz = T.createContext({
    colorTheme: "classic",
    setColorTheme: () => {
    },
    previewColorTheme: () => {
    }
  }), voe = ({
    available_themes: e,
    children: t,
    default_theme: n
  }) => {
    const r = T.useMemo(
      () => new Set(e),
      [e]
    ), [o, i] = T.useState(
      n ?? e[0]
    ), a = T.useCallback(
      (u) => {
        if (!r.has(u))
          throw new Error(
            `Theme "${u}" is not in available_themes: [${Array.from(
              r
            ).join(", ")}]`
          );
        i(u);
        const d = {
          colorTheme: u
        };
        try {
          localStorage.setItem("theme", JSON.stringify(d));
        } catch (p) {
          console.warn("Failed to save theme to localStorage:", p);
        }
      },
      [r]
    ), s = T.useCallback(
      (u) => {
        if (!r.has(u))
          throw new Error(
            `Theme "${u}" is not in available_themes: [${Array.from(
              r
            ).join(", ")}]`
          );
        i(u);
      },
      [r]
    );
    T.useEffect(() => {
      document.documentElement.setAttribute("fn-data-color-theme", o);
    }, [o]), T.useEffect(() => {
      try {
        const u = localStorage.getItem("theme");
        if (!u) return;
        const d = JSON.parse(u);
        d.colorTheme && r.has(d.colorTheme) && i(d.colorTheme);
      } catch (u) {
        console.warn("Failed to load theme from localStorage:", u);
      }
    }, [r]), T.useEffect(() => {
      if (n && !r.has(n)) {
        const u = Array.from(r)[0];
        u && a(u);
      }
    }, [r, n, a]), T.useEffect(() => {
      if (!r.has(o)) {
        const u = Array.from(r)[0];
        u && a(u);
      }
    }, [o, r, a]);
    const l = T.useMemo(
      () => ({
        colorTheme: o,
        setColorTheme: a,
        previewColorTheme: s
      }),
      [o, a, s]
    );
    return /* @__PURE__ */ S.jsx(tz.Provider, { value: l, children: t });
  }, nz = () => {
    const e = T.useContext(tz);
    if (!e)
      throw new Error("useTheme must be used within a ThemeProvider");
    return e;
  }, rz = T.memo(({ button: e, index: t }) => {
    const n = T.useCallback(
      (o) => {
        o.preventDefault(), e.onClick(o);
      },
      [e]
    ), r = /* @__PURE__ */ S.jsx(
      "button",
      {
        className: `dialog-send-button ${e.className || ""}`,
        onClick: n,
        disabled: e.disabled,
        "aria-label": e.ariaLabel,
        type: "button",
        children: e.text
      }
    );
    return e.close !== !1 ? /* @__PURE__ */ S.jsx(GF, { asChild: !0, children: r }, t) : /* @__PURE__ */ S.jsx(T.Fragment, { children: r }, t);
  });
  rz.displayName = "DialogButton";
  const Ga = T.memo(
    ({
      trigger: e,
      title: t,
      description: n,
      children: r,
      closebutton: o = !0,
      onOpenChange: i,
      buttons: a = [],
      open: s,
      setOpen: l,
      modal: u = !0,
      dialogClassName: d = "default-dialog-content",
      ariaLabel: p,
      ariaDescription: h
    }) => {
      const y = jt().local_state((E) => E.funcnodescontainerRef), b = T.useMemo(
        () => `dialog-content funcnodescontainer ${d}`,
        [d]
      ), v = T.useCallback(
        (E) => {
          try {
            l?.(E), i?.(E);
          } catch (_) {
            console.error("Error in dialog open change handler:", _);
          }
        },
        [l, i]
      ), x = T.useMemo(
        () => a.map((E, _) => /* @__PURE__ */ S.jsx(
          rz,
          {
            button: E,
            index: _
          },
          `${E.text}-${_}`
        )),
        [a]
      );
      return /* @__PURE__ */ S.jsxs(lee, { open: s, onOpenChange: v, modal: u, children: [
        e && /* @__PURE__ */ S.jsx(cee, { asChild: !0, children: e }),
        /* @__PURE__ */ S.jsxs(uee, { container: y, children: [
          /* @__PURE__ */ S.jsx(fee, { className: "dialog-overlay funcnodescontainer" }),
          /* @__PURE__ */ S.jsx(dee, { asChild: !0, children: /* @__PURE__ */ S.jsxs(
            "div",
            {
              className: b,
              role: "dialog",
              "aria-label": p || t,
              "aria-description": h || (typeof n == "string" ? n : void 0),
              children: [
                t && /* @__PURE__ */ S.jsx(pee, { className: "dialog-title", id: "dialog-title", children: t }),
                n && /* @__PURE__ */ S.jsx(
                  hee,
                  {
                    className: "dialog-description",
                    id: "dialog-description",
                    children: n
                  }
                ),
                /* @__PURE__ */ S.jsx("div", { className: "dialog-children", role: "main", children: r }),
                a.length > 0 && /* @__PURE__ */ S.jsx(
                  "div",
                  {
                    className: "dialog-buttons",
                    role: "group",
                    "aria-label": "Dialog actions",
                    children: x
                  }
                ),
                o && /* @__PURE__ */ S.jsx(GF, { asChild: !0, children: /* @__PURE__ */ S.jsx(
                  "button",
                  {
                    className: "dialog-close-button",
                    "aria-label": "Close dialog",
                    type: "button",
                    children: /* @__PURE__ */ S.jsx(bb, {})
                  }
                ) })
              ]
            }
          ) })
        ] })
      ] });
    }
  );
  Ga.displayName = "CustomDialog";
  const boe = ["top", "right", "bottom", "left"], tl = Math.min, eo = Math.max, Zv = Math.round, Hg = Math.floor, Ui = (e) => ({
    x: e,
    y: e
  }), xoe = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  }, woe = {
    start: "end",
    end: "start"
  };
  function IE(e, t, n) {
    return eo(e, tl(t, n));
  }
  function Ba(e, t) {
    return typeof e == "function" ? e(t) : e;
  }
  function Ua(e) {
    return e.split("-")[0];
  }
  function Tf(e) {
    return e.split("-")[1];
  }
  function Hk(e) {
    return e === "x" ? "y" : "x";
  }
  function qk(e) {
    return e === "y" ? "height" : "width";
  }
  const Soe = /* @__PURE__ */ new Set(["top", "bottom"]);
  function Oi(e) {
    return Soe.has(Ua(e)) ? "y" : "x";
  }
  function Wk(e) {
    return Hk(Oi(e));
  }
  function _oe(e, t, n) {
    n === void 0 && (n = !1);
    const r = Tf(e), o = Wk(e), i = qk(o);
    let a = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
    return t.reference[i] > t.floating[i] && (a = Qv(a)), [a, Qv(a)];
  }
  function Eoe(e) {
    const t = Qv(e);
    return [jE(e), t, jE(t)];
  }
  function jE(e) {
    return e.replace(/start|end/g, (t) => woe[t]);
  }
  const Z$ = ["left", "right"], Q$ = ["right", "left"], Coe = ["top", "bottom"], koe = ["bottom", "top"];
  function Toe(e, t, n) {
    switch (e) {
      case "top":
      case "bottom":
        return n ? t ? Q$ : Z$ : t ? Z$ : Q$;
      case "left":
      case "right":
        return t ? Coe : koe;
      default:
        return [];
    }
  }
  function Roe(e, t, n, r) {
    const o = Tf(e);
    let i = Toe(Ua(e), n === "start", r);
    return o && (i = i.map((a) => a + "-" + o), t && (i = i.concat(i.map(jE)))), i;
  }
  function Qv(e) {
    return e.replace(/left|right|bottom|top/g, (t) => xoe[t]);
  }
  function Ooe(e) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...e
    };
  }
  function oz(e) {
    return typeof e != "number" ? Ooe(e) : {
      top: e,
      right: e,
      bottom: e,
      left: e
    };
  }
  function Jv(e) {
    const {
      x: t,
      y: n,
      width: r,
      height: o
    } = e;
    return {
      width: r,
      height: o,
      top: n,
      left: t,
      right: t + r,
      bottom: n + o,
      x: t,
      y: n
    };
  }
  function J$(e, t, n) {
    let {
      reference: r,
      floating: o
    } = e;
    const i = Oi(t), a = Wk(t), s = qk(a), l = Ua(t), u = i === "y", d = r.x + r.width / 2 - o.width / 2, p = r.y + r.height / 2 - o.height / 2, h = r[s] / 2 - o[s] / 2;
    let g;
    switch (l) {
      case "top":
        g = {
          x: d,
          y: r.y - o.height
        };
        break;
      case "bottom":
        g = {
          x: d,
          y: r.y + r.height
        };
        break;
      case "right":
        g = {
          x: r.x + r.width,
          y: p
        };
        break;
      case "left":
        g = {
          x: r.x - o.width,
          y: p
        };
        break;
      default:
        g = {
          x: r.x,
          y: r.y
        };
    }
    switch (Tf(t)) {
      case "start":
        g[a] -= h * (n && u ? -1 : 1);
        break;
      case "end":
        g[a] += h * (n && u ? -1 : 1);
        break;
    }
    return g;
  }
  const Aoe = async (e, t, n) => {
    const {
      placement: r = "bottom",
      strategy: o = "absolute",
      middleware: i = [],
      platform: a
    } = n, s = i.filter(Boolean), l = await (a.isRTL == null ? void 0 : a.isRTL(t));
    let u = await a.getElementRects({
      reference: e,
      floating: t,
      strategy: o
    }), {
      x: d,
      y: p
    } = J$(u, r, l), h = r, g = {}, y = 0;
    for (let b = 0; b < s.length; b++) {
      const {
        name: v,
        fn: x
      } = s[b], {
        x: E,
        y: _,
        data: C,
        reset: k
      } = await x({
        x: d,
        y: p,
        initialPlacement: r,
        placement: h,
        strategy: o,
        middlewareData: g,
        rects: u,
        platform: a,
        elements: {
          reference: e,
          floating: t
        }
      });
      d = E ?? d, p = _ ?? p, g = {
        ...g,
        [v]: {
          ...g[v],
          ...C
        }
      }, k && y <= 50 && (y++, typeof k == "object" && (k.placement && (h = k.placement), k.rects && (u = k.rects === !0 ? await a.getElementRects({
        reference: e,
        floating: t,
        strategy: o
      }) : k.rects), {
        x: d,
        y: p
      } = J$(u, h, l)), b = -1);
    }
    return {
      x: d,
      y: p,
      placement: h,
      strategy: o,
      middlewareData: g
    };
  };
  async function Xp(e, t) {
    var n;
    t === void 0 && (t = {});
    const {
      x: r,
      y: o,
      platform: i,
      rects: a,
      elements: s,
      strategy: l
    } = e, {
      boundary: u = "clippingAncestors",
      rootBoundary: d = "viewport",
      elementContext: p = "floating",
      altBoundary: h = !1,
      padding: g = 0
    } = Ba(t, e), y = oz(g), v = s[h ? p === "floating" ? "reference" : "floating" : p], x = Jv(await i.getClippingRect({
      element: (n = await (i.isElement == null ? void 0 : i.isElement(v))) == null || n ? v : v.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(s.floating)),
      boundary: u,
      rootBoundary: d,
      strategy: l
    })), E = p === "floating" ? {
      x: r,
      y: o,
      width: a.floating.width,
      height: a.floating.height
    } : a.reference, _ = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(s.floating)), C = await (i.isElement == null ? void 0 : i.isElement(_)) ? await (i.getScale == null ? void 0 : i.getScale(_)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    }, k = Jv(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements: s,
      rect: E,
      offsetParent: _,
      strategy: l
    }) : E);
    return {
      top: (x.top - k.top + y.top) / C.y,
      bottom: (k.bottom - x.bottom + y.bottom) / C.y,
      left: (x.left - k.left + y.left) / C.x,
      right: (k.right - x.right + y.right) / C.x
    };
  }
  const Noe = (e) => ({
    name: "arrow",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: o,
        rects: i,
        platform: a,
        elements: s,
        middlewareData: l
      } = t, {
        element: u,
        padding: d = 0
      } = Ba(e, t) || {};
      if (u == null)
        return {};
      const p = oz(d), h = {
        x: n,
        y: r
      }, g = Wk(o), y = qk(g), b = await a.getDimensions(u), v = g === "y", x = v ? "top" : "left", E = v ? "bottom" : "right", _ = v ? "clientHeight" : "clientWidth", C = i.reference[y] + i.reference[g] - h[g] - i.floating[y], k = h[g] - i.reference[g], R = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(u));
      let A = R ? R[_] : 0;
      (!A || !await (a.isElement == null ? void 0 : a.isElement(R))) && (A = s.floating[_] || i.floating[y]);
      const M = C / 2 - k / 2, I = A / 2 - b[y] / 2 - 1, D = tl(p[x], I), L = tl(p[E], I), P = D, B = A - b[y] - L, j = A / 2 - b[y] / 2 + M, V = IE(P, j, B), F = !l.arrow && Tf(o) != null && j !== V && i.reference[y] / 2 - (j < P ? D : L) - b[y] / 2 < 0, G = F ? j < P ? j - P : j - B : 0;
      return {
        [g]: h[g] + G,
        data: {
          [g]: V,
          centerOffset: j - V - G,
          ...F && {
            alignmentOffset: G
          }
        },
        reset: F
      };
    }
  }), Moe = function(e) {
    return e === void 0 && (e = {}), {
      name: "flip",
      options: e,
      async fn(t) {
        var n, r;
        const {
          placement: o,
          middlewareData: i,
          rects: a,
          initialPlacement: s,
          platform: l,
          elements: u
        } = t, {
          mainAxis: d = !0,
          crossAxis: p = !0,
          fallbackPlacements: h,
          fallbackStrategy: g = "bestFit",
          fallbackAxisSideDirection: y = "none",
          flipAlignment: b = !0,
          ...v
        } = Ba(e, t);
        if ((n = i.arrow) != null && n.alignmentOffset)
          return {};
        const x = Ua(o), E = Oi(s), _ = Ua(s) === s, C = await (l.isRTL == null ? void 0 : l.isRTL(u.floating)), k = h || (_ || !b ? [Qv(s)] : Eoe(s)), R = y !== "none";
        !h && R && k.push(...Roe(s, b, y, C));
        const A = [s, ...k], M = await Xp(t, v), I = [];
        let D = ((r = i.flip) == null ? void 0 : r.overflows) || [];
        if (d && I.push(M[x]), p) {
          const j = _oe(o, a, C);
          I.push(M[j[0]], M[j[1]]);
        }
        if (D = [...D, {
          placement: o,
          overflows: I
        }], !I.every((j) => j <= 0)) {
          var L, P;
          const j = (((L = i.flip) == null ? void 0 : L.index) || 0) + 1, V = A[j];
          if (V && (!(p === "alignment" ? E !== Oi(V) : !1) || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          D.every((W) => W.overflows[0] > 0 && Oi(W.placement) === E)))
            return {
              data: {
                index: j,
                overflows: D
              },
              reset: {
                placement: V
              }
            };
          let F = (P = D.filter((G) => G.overflows[0] <= 0).sort((G, W) => G.overflows[1] - W.overflows[1])[0]) == null ? void 0 : P.placement;
          if (!F)
            switch (g) {
              case "bestFit": {
                var B;
                const G = (B = D.filter((W) => {
                  if (R) {
                    const K = Oi(W.placement);
                    return K === E || // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    K === "y";
                  }
                  return !0;
                }).map((W) => [W.placement, W.overflows.filter((K) => K > 0).reduce((K, $) => K + $, 0)]).sort((W, K) => W[1] - K[1])[0]) == null ? void 0 : B[0];
                G && (F = G);
                break;
              }
              case "initialPlacement":
                F = s;
                break;
            }
          if (o !== F)
            return {
              reset: {
                placement: F
              }
            };
        }
        return {};
      }
    };
  };
  function e2(e, t) {
    return {
      top: e.top - t.height,
      right: e.right - t.width,
      bottom: e.bottom - t.height,
      left: e.left - t.width
    };
  }
  function t2(e) {
    return boe.some((t) => e[t] >= 0);
  }
  const Poe = function(e) {
    return e === void 0 && (e = {}), {
      name: "hide",
      options: e,
      async fn(t) {
        const {
          rects: n
        } = t, {
          strategy: r = "referenceHidden",
          ...o
        } = Ba(e, t);
        switch (r) {
          case "referenceHidden": {
            const i = await Xp(t, {
              ...o,
              elementContext: "reference"
            }), a = e2(i, n.reference);
            return {
              data: {
                referenceHiddenOffsets: a,
                referenceHidden: t2(a)
              }
            };
          }
          case "escaped": {
            const i = await Xp(t, {
              ...o,
              altBoundary: !0
            }), a = e2(i, n.floating);
            return {
              data: {
                escapedOffsets: a,
                escaped: t2(a)
              }
            };
          }
          default:
            return {};
        }
      }
    };
  }, iz = /* @__PURE__ */ new Set(["left", "top"]);
  async function $oe(e, t) {
    const {
      placement: n,
      platform: r,
      elements: o
    } = e, i = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)), a = Ua(n), s = Tf(n), l = Oi(n) === "y", u = iz.has(a) ? -1 : 1, d = i && l ? -1 : 1, p = Ba(t, e);
    let {
      mainAxis: h,
      crossAxis: g,
      alignmentAxis: y
    } = typeof p == "number" ? {
      mainAxis: p,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: p.mainAxis || 0,
      crossAxis: p.crossAxis || 0,
      alignmentAxis: p.alignmentAxis
    };
    return s && typeof y == "number" && (g = s === "end" ? y * -1 : y), l ? {
      x: g * d,
      y: h * u
    } : {
      x: h * u,
      y: g * d
    };
  }
  const Ioe = function(e) {
    return e === void 0 && (e = 0), {
      name: "offset",
      options: e,
      async fn(t) {
        var n, r;
        const {
          x: o,
          y: i,
          placement: a,
          middlewareData: s
        } = t, l = await $oe(t, e);
        return a === ((n = s.offset) == null ? void 0 : n.placement) && (r = s.arrow) != null && r.alignmentOffset ? {} : {
          x: o + l.x,
          y: i + l.y,
          data: {
            ...l,
            placement: a
          }
        };
      }
    };
  }, joe = function(e) {
    return e === void 0 && (e = {}), {
      name: "shift",
      options: e,
      async fn(t) {
        const {
          x: n,
          y: r,
          placement: o
        } = t, {
          mainAxis: i = !0,
          crossAxis: a = !1,
          limiter: s = {
            fn: (v) => {
              let {
                x,
                y: E
              } = v;
              return {
                x,
                y: E
              };
            }
          },
          ...l
        } = Ba(e, t), u = {
          x: n,
          y: r
        }, d = await Xp(t, l), p = Oi(Ua(o)), h = Hk(p);
        let g = u[h], y = u[p];
        if (i) {
          const v = h === "y" ? "top" : "left", x = h === "y" ? "bottom" : "right", E = g + d[v], _ = g - d[x];
          g = IE(E, g, _);
        }
        if (a) {
          const v = p === "y" ? "top" : "left", x = p === "y" ? "bottom" : "right", E = y + d[v], _ = y - d[x];
          y = IE(E, y, _);
        }
        const b = s.fn({
          ...t,
          [h]: g,
          [p]: y
        });
        return {
          ...b,
          data: {
            x: b.x - n,
            y: b.y - r,
            enabled: {
              [h]: i,
              [p]: a
            }
          }
        };
      }
    };
  }, Doe = function(e) {
    return e === void 0 && (e = {}), {
      options: e,
      fn(t) {
        const {
          x: n,
          y: r,
          placement: o,
          rects: i,
          middlewareData: a
        } = t, {
          offset: s = 0,
          mainAxis: l = !0,
          crossAxis: u = !0
        } = Ba(e, t), d = {
          x: n,
          y: r
        }, p = Oi(o), h = Hk(p);
        let g = d[h], y = d[p];
        const b = Ba(s, t), v = typeof b == "number" ? {
          mainAxis: b,
          crossAxis: 0
        } : {
          mainAxis: 0,
          crossAxis: 0,
          ...b
        };
        if (l) {
          const _ = h === "y" ? "height" : "width", C = i.reference[h] - i.floating[_] + v.mainAxis, k = i.reference[h] + i.reference[_] - v.mainAxis;
          g < C ? g = C : g > k && (g = k);
        }
        if (u) {
          var x, E;
          const _ = h === "y" ? "width" : "height", C = iz.has(Ua(o)), k = i.reference[p] - i.floating[_] + (C && ((x = a.offset) == null ? void 0 : x[p]) || 0) + (C ? 0 : v.crossAxis), R = i.reference[p] + i.reference[_] + (C ? 0 : ((E = a.offset) == null ? void 0 : E[p]) || 0) - (C ? v.crossAxis : 0);
          y < k ? y = k : y > R && (y = R);
        }
        return {
          [h]: g,
          [p]: y
        };
      }
    };
  }, Foe = function(e) {
    return e === void 0 && (e = {}), {
      name: "size",
      options: e,
      async fn(t) {
        var n, r;
        const {
          placement: o,
          rects: i,
          platform: a,
          elements: s
        } = t, {
          apply: l = () => {
          },
          ...u
        } = Ba(e, t), d = await Xp(t, u), p = Ua(o), h = Tf(o), g = Oi(o) === "y", {
          width: y,
          height: b
        } = i.floating;
        let v, x;
        p === "top" || p === "bottom" ? (v = p, x = h === (await (a.isRTL == null ? void 0 : a.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (x = p, v = h === "end" ? "top" : "bottom");
        const E = b - d.top - d.bottom, _ = y - d.left - d.right, C = tl(b - d[v], E), k = tl(y - d[x], _), R = !t.middlewareData.shift;
        let A = C, M = k;
        if ((n = t.middlewareData.shift) != null && n.enabled.x && (M = _), (r = t.middlewareData.shift) != null && r.enabled.y && (A = E), R && !h) {
          const D = eo(d.left, 0), L = eo(d.right, 0), P = eo(d.top, 0), B = eo(d.bottom, 0);
          g ? M = y - 2 * (D !== 0 || L !== 0 ? D + L : eo(d.left, d.right)) : A = b - 2 * (P !== 0 || B !== 0 ? P + B : eo(d.top, d.bottom));
        }
        await l({
          ...t,
          availableWidth: M,
          availableHeight: A
        });
        const I = await a.getDimensions(s.floating);
        return y !== I.width || b !== I.height ? {
          reset: {
            rects: !0
          }
        } : {};
      }
    };
  };
  function xb() {
    return typeof window < "u";
  }
  function Rf(e) {
    return az(e) ? (e.nodeName || "").toLowerCase() : "#document";
  }
  function ao(e) {
    var t;
    return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
  }
  function Xi(e) {
    var t;
    return (t = (az(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
  }
  function az(e) {
    return xb() ? e instanceof Node || e instanceof ao(e).Node : !1;
  }
  function Xo(e) {
    return xb() ? e instanceof Element || e instanceof ao(e).Element : !1;
  }
  function Hi(e) {
    return xb() ? e instanceof HTMLElement || e instanceof ao(e).HTMLElement : !1;
  }
  function n2(e) {
    return !xb() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof ao(e).ShadowRoot;
  }
  const Loe = /* @__PURE__ */ new Set(["inline", "contents"]);
  function Bh(e) {
    const {
      overflow: t,
      overflowX: n,
      overflowY: r,
      display: o
    } = Zo(e);
    return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !Loe.has(o);
  }
  const zoe = /* @__PURE__ */ new Set(["table", "td", "th"]);
  function Boe(e) {
    return zoe.has(Rf(e));
  }
  const Uoe = [":popover-open", ":modal"];
  function wb(e) {
    return Uoe.some((t) => {
      try {
        return e.matches(t);
      } catch {
        return !1;
      }
    });
  }
  const Voe = ["transform", "translate", "scale", "rotate", "perspective"], Hoe = ["transform", "translate", "scale", "rotate", "perspective", "filter"], qoe = ["paint", "layout", "strict", "content"];
  function Gk(e) {
    const t = Kk(), n = Xo(e) ? Zo(e) : e;
    return Voe.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || Hoe.some((r) => (n.willChange || "").includes(r)) || qoe.some((r) => (n.contain || "").includes(r));
  }
  function Woe(e) {
    let t = nl(e);
    for (; Hi(t) && !of(t); ) {
      if (Gk(t))
        return t;
      if (wb(t))
        return null;
      t = nl(t);
    }
    return null;
  }
  function Kk() {
    return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
  }
  const Goe = /* @__PURE__ */ new Set(["html", "body", "#document"]);
  function of(e) {
    return Goe.has(Rf(e));
  }
  function Zo(e) {
    return ao(e).getComputedStyle(e);
  }
  function Sb(e) {
    return Xo(e) ? {
      scrollLeft: e.scrollLeft,
      scrollTop: e.scrollTop
    } : {
      scrollLeft: e.scrollX,
      scrollTop: e.scrollY
    };
  }
  function nl(e) {
    if (Rf(e) === "html")
      return e;
    const t = (
      // Step into the shadow DOM of the parent of a slotted node.
      e.assignedSlot || // DOM Element detected.
      e.parentNode || // ShadowRoot detected.
      n2(e) && e.host || // Fallback.
      Xi(e)
    );
    return n2(t) ? t.host : t;
  }
  function sz(e) {
    const t = nl(e);
    return of(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Hi(t) && Bh(t) ? t : sz(t);
  }
  function Zp(e, t, n) {
    var r;
    t === void 0 && (t = []), n === void 0 && (n = !0);
    const o = sz(e), i = o === ((r = e.ownerDocument) == null ? void 0 : r.body), a = ao(o);
    if (i) {
      const s = DE(a);
      return t.concat(a, a.visualViewport || [], Bh(o) ? o : [], s && n ? Zp(s) : []);
    }
    return t.concat(o, Zp(o, [], n));
  }
  function DE(e) {
    return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
  }
  function lz(e) {
    const t = Zo(e);
    let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
    const o = Hi(e), i = o ? e.offsetWidth : n, a = o ? e.offsetHeight : r, s = Zv(n) !== i || Zv(r) !== a;
    return s && (n = i, r = a), {
      width: n,
      height: r,
      $: s
    };
  }
  function Yk(e) {
    return Xo(e) ? e : e.contextElement;
  }
  function Gu(e) {
    const t = Yk(e);
    if (!Hi(t))
      return Ui(1);
    const n = t.getBoundingClientRect(), {
      width: r,
      height: o,
      $: i
    } = lz(t);
    let a = (i ? Zv(n.width) : n.width) / r, s = (i ? Zv(n.height) : n.height) / o;
    return (!a || !Number.isFinite(a)) && (a = 1), (!s || !Number.isFinite(s)) && (s = 1), {
      x: a,
      y: s
    };
  }
  const Koe = /* @__PURE__ */ Ui(0);
  function cz(e) {
    const t = ao(e);
    return !Kk() || !t.visualViewport ? Koe : {
      x: t.visualViewport.offsetLeft,
      y: t.visualViewport.offsetTop
    };
  }
  function Yoe(e, t, n) {
    return t === void 0 && (t = !1), !n || t && n !== ao(e) ? !1 : t;
  }
  function ic(e, t, n, r) {
    t === void 0 && (t = !1), n === void 0 && (n = !1);
    const o = e.getBoundingClientRect(), i = Yk(e);
    let a = Ui(1);
    t && (r ? Xo(r) && (a = Gu(r)) : a = Gu(e));
    const s = Yoe(i, n, r) ? cz(i) : Ui(0);
    let l = (o.left + s.x) / a.x, u = (o.top + s.y) / a.y, d = o.width / a.x, p = o.height / a.y;
    if (i) {
      const h = ao(i), g = r && Xo(r) ? ao(r) : r;
      let y = h, b = DE(y);
      for (; b && r && g !== y; ) {
        const v = Gu(b), x = b.getBoundingClientRect(), E = Zo(b), _ = x.left + (b.clientLeft + parseFloat(E.paddingLeft)) * v.x, C = x.top + (b.clientTop + parseFloat(E.paddingTop)) * v.y;
        l *= v.x, u *= v.y, d *= v.x, p *= v.y, l += _, u += C, y = ao(b), b = DE(y);
      }
    }
    return Jv({
      width: d,
      height: p,
      x: l,
      y: u
    });
  }
  function Xk(e, t) {
    const n = Sb(e).scrollLeft;
    return t ? t.left + n : ic(Xi(e)).left + n;
  }
  function uz(e, t, n) {
    n === void 0 && (n = !1);
    const r = e.getBoundingClientRect(), o = r.left + t.scrollLeft - (n ? 0 : (
      // RTL <body> scrollbar.
      Xk(e, r)
    )), i = r.top + t.scrollTop;
    return {
      x: o,
      y: i
    };
  }
  function Xoe(e) {
    let {
      elements: t,
      rect: n,
      offsetParent: r,
      strategy: o
    } = e;
    const i = o === "fixed", a = Xi(r), s = t ? wb(t.floating) : !1;
    if (r === a || s && i)
      return n;
    let l = {
      scrollLeft: 0,
      scrollTop: 0
    }, u = Ui(1);
    const d = Ui(0), p = Hi(r);
    if ((p || !p && !i) && ((Rf(r) !== "body" || Bh(a)) && (l = Sb(r)), Hi(r))) {
      const g = ic(r);
      u = Gu(r), d.x = g.x + r.clientLeft, d.y = g.y + r.clientTop;
    }
    const h = a && !p && !i ? uz(a, l, !0) : Ui(0);
    return {
      width: n.width * u.x,
      height: n.height * u.y,
      x: n.x * u.x - l.scrollLeft * u.x + d.x + h.x,
      y: n.y * u.y - l.scrollTop * u.y + d.y + h.y
    };
  }
  function Zoe(e) {
    return Array.from(e.getClientRects());
  }
  function Qoe(e) {
    const t = Xi(e), n = Sb(e), r = e.ownerDocument.body, o = eo(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), i = eo(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
    let a = -n.scrollLeft + Xk(e);
    const s = -n.scrollTop;
    return Zo(r).direction === "rtl" && (a += eo(t.clientWidth, r.clientWidth) - o), {
      width: o,
      height: i,
      x: a,
      y: s
    };
  }
  function Joe(e, t) {
    const n = ao(e), r = Xi(e), o = n.visualViewport;
    let i = r.clientWidth, a = r.clientHeight, s = 0, l = 0;
    if (o) {
      i = o.width, a = o.height;
      const u = Kk();
      (!u || u && t === "fixed") && (s = o.offsetLeft, l = o.offsetTop);
    }
    return {
      width: i,
      height: a,
      x: s,
      y: l
    };
  }
  const eie = /* @__PURE__ */ new Set(["absolute", "fixed"]);
  function tie(e, t) {
    const n = ic(e, !0, t === "fixed"), r = n.top + e.clientTop, o = n.left + e.clientLeft, i = Hi(e) ? Gu(e) : Ui(1), a = e.clientWidth * i.x, s = e.clientHeight * i.y, l = o * i.x, u = r * i.y;
    return {
      width: a,
      height: s,
      x: l,
      y: u
    };
  }
  function r2(e, t, n) {
    let r;
    if (t === "viewport")
      r = Joe(e, n);
    else if (t === "document")
      r = Qoe(Xi(e));
    else if (Xo(t))
      r = tie(t, n);
    else {
      const o = cz(e);
      r = {
        x: t.x - o.x,
        y: t.y - o.y,
        width: t.width,
        height: t.height
      };
    }
    return Jv(r);
  }
  function fz(e, t) {
    const n = nl(e);
    return n === t || !Xo(n) || of(n) ? !1 : Zo(n).position === "fixed" || fz(n, t);
  }
  function nie(e, t) {
    const n = t.get(e);
    if (n)
      return n;
    let r = Zp(e, [], !1).filter((s) => Xo(s) && Rf(s) !== "body"), o = null;
    const i = Zo(e).position === "fixed";
    let a = i ? nl(e) : e;
    for (; Xo(a) && !of(a); ) {
      const s = Zo(a), l = Gk(a);
      !l && s.position === "fixed" && (o = null), (i ? !l && !o : !l && s.position === "static" && !!o && eie.has(o.position) || Bh(a) && !l && fz(e, a)) ? r = r.filter((d) => d !== a) : o = s, a = nl(a);
    }
    return t.set(e, r), r;
  }
  function rie(e) {
    let {
      element: t,
      boundary: n,
      rootBoundary: r,
      strategy: o
    } = e;
    const a = [...n === "clippingAncestors" ? wb(t) ? [] : nie(t, this._c) : [].concat(n), r], s = a[0], l = a.reduce((u, d) => {
      const p = r2(t, d, o);
      return u.top = eo(p.top, u.top), u.right = tl(p.right, u.right), u.bottom = tl(p.bottom, u.bottom), u.left = eo(p.left, u.left), u;
    }, r2(t, s, o));
    return {
      width: l.right - l.left,
      height: l.bottom - l.top,
      x: l.left,
      y: l.top
    };
  }
  function oie(e) {
    const {
      width: t,
      height: n
    } = lz(e);
    return {
      width: t,
      height: n
    };
  }
  function iie(e, t, n) {
    const r = Hi(t), o = Xi(t), i = n === "fixed", a = ic(e, !0, i, t);
    let s = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const l = Ui(0);
    function u() {
      l.x = Xk(o);
    }
    if (r || !r && !i)
      if ((Rf(t) !== "body" || Bh(o)) && (s = Sb(t)), r) {
        const g = ic(t, !0, i, t);
        l.x = g.x + t.clientLeft, l.y = g.y + t.clientTop;
      } else o && u();
    i && !r && o && u();
    const d = o && !r && !i ? uz(o, s) : Ui(0), p = a.left + s.scrollLeft - l.x - d.x, h = a.top + s.scrollTop - l.y - d.y;
    return {
      x: p,
      y: h,
      width: a.width,
      height: a.height
    };
  }
  function _S(e) {
    return Zo(e).position === "static";
  }
  function o2(e, t) {
    if (!Hi(e) || Zo(e).position === "fixed")
      return null;
    if (t)
      return t(e);
    let n = e.offsetParent;
    return Xi(e) === n && (n = n.ownerDocument.body), n;
  }
  function dz(e, t) {
    const n = ao(e);
    if (wb(e))
      return n;
    if (!Hi(e)) {
      let o = nl(e);
      for (; o && !of(o); ) {
        if (Xo(o) && !_S(o))
          return o;
        o = nl(o);
      }
      return n;
    }
    let r = o2(e, t);
    for (; r && Boe(r) && _S(r); )
      r = o2(r, t);
    return r && of(r) && _S(r) && !Gk(r) ? n : r || Woe(e) || n;
  }
  const aie = async function(e) {
    const t = this.getOffsetParent || dz, n = this.getDimensions, r = await n(e.floating);
    return {
      reference: iie(e.reference, await t(e.floating), e.strategy),
      floating: {
        x: 0,
        y: 0,
        width: r.width,
        height: r.height
      }
    };
  };
  function sie(e) {
    return Zo(e).direction === "rtl";
  }
  const lie = {
    convertOffsetParentRelativeRectToViewportRelativeRect: Xoe,
    getDocumentElement: Xi,
    getClippingRect: rie,
    getOffsetParent: dz,
    getElementRects: aie,
    getClientRects: Zoe,
    getDimensions: oie,
    getScale: Gu,
    isElement: Xo,
    isRTL: sie
  };
  function pz(e, t) {
    return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
  }
  function cie(e, t) {
    let n = null, r;
    const o = Xi(e);
    function i() {
      var s;
      clearTimeout(r), (s = n) == null || s.disconnect(), n = null;
    }
    function a(s, l) {
      s === void 0 && (s = !1), l === void 0 && (l = 1), i();
      const u = e.getBoundingClientRect(), {
        left: d,
        top: p,
        width: h,
        height: g
      } = u;
      if (s || t(), !h || !g)
        return;
      const y = Hg(p), b = Hg(o.clientWidth - (d + h)), v = Hg(o.clientHeight - (p + g)), x = Hg(d), _ = {
        rootMargin: -y + "px " + -b + "px " + -v + "px " + -x + "px",
        threshold: eo(0, tl(1, l)) || 1
      };
      let C = !0;
      function k(R) {
        const A = R[0].intersectionRatio;
        if (A !== l) {
          if (!C)
            return a();
          A ? a(!1, A) : r = setTimeout(() => {
            a(!1, 1e-7);
          }, 1e3);
        }
        A === 1 && !pz(u, e.getBoundingClientRect()) && a(), C = !1;
      }
      try {
        n = new IntersectionObserver(k, {
          ..._,
          // Handle <iframe>s
          root: o.ownerDocument
        });
      } catch {
        n = new IntersectionObserver(k, _);
      }
      n.observe(e);
    }
    return a(!0), i;
  }
  function hz(e, t, n, r) {
    r === void 0 && (r = {});
    const {
      ancestorScroll: o = !0,
      ancestorResize: i = !0,
      elementResize: a = typeof ResizeObserver == "function",
      layoutShift: s = typeof IntersectionObserver == "function",
      animationFrame: l = !1
    } = r, u = Yk(e), d = o || i ? [...u ? Zp(u) : [], ...Zp(t)] : [];
    d.forEach((x) => {
      o && x.addEventListener("scroll", n, {
        passive: !0
      }), i && x.addEventListener("resize", n);
    });
    const p = u && s ? cie(u, n) : null;
    let h = -1, g = null;
    a && (g = new ResizeObserver((x) => {
      let [E] = x;
      E && E.target === u && g && (g.unobserve(t), cancelAnimationFrame(h), h = requestAnimationFrame(() => {
        var _;
        (_ = g) == null || _.observe(t);
      })), n();
    }), u && !l && g.observe(u), g.observe(t));
    let y, b = l ? ic(e) : null;
    l && v();
    function v() {
      const x = ic(e);
      b && !pz(b, x) && n(), b = x, y = requestAnimationFrame(v);
    }
    return n(), () => {
      var x;
      d.forEach((E) => {
        o && E.removeEventListener("scroll", n), i && E.removeEventListener("resize", n);
      }), p?.(), (x = g) == null || x.disconnect(), g = null, l && cancelAnimationFrame(y);
    };
  }
  const uie = Ioe, fie = joe, die = Moe, pie = Foe, hie = Poe, i2 = Noe, mie = Doe, gie = (e, t, n) => {
    const r = /* @__PURE__ */ new Map(), o = {
      platform: lie,
      ...n
    }, i = {
      ...o.platform,
      _c: r
    };
    return Aoe(e, t, {
      ...o,
      platform: i
    });
  };
  var yie = typeof document < "u", vie = function() {
  }, vv = yie ? T.useLayoutEffect : vie;
  function e0(e, t) {
    if (e === t)
      return !0;
    if (typeof e != typeof t)
      return !1;
    if (typeof e == "function" && e.toString() === t.toString())
      return !0;
    let n, r, o;
    if (e && t && typeof e == "object") {
      if (Array.isArray(e)) {
        if (n = e.length, n !== t.length) return !1;
        for (r = n; r-- !== 0; )
          if (!e0(e[r], t[r]))
            return !1;
        return !0;
      }
      if (o = Object.keys(e), n = o.length, n !== Object.keys(t).length)
        return !1;
      for (r = n; r-- !== 0; )
        if (!{}.hasOwnProperty.call(t, o[r]))
          return !1;
      for (r = n; r-- !== 0; ) {
        const i = o[r];
        if (!(i === "_owner" && e.$$typeof) && !e0(e[i], t[i]))
          return !1;
      }
      return !0;
    }
    return e !== e && t !== t;
  }
  function mz(e) {
    return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
  }
  function a2(e, t) {
    const n = mz(e);
    return Math.round(t * n) / n;
  }
  function ES(e) {
    const t = T.useRef(e);
    return vv(() => {
      t.current = e;
    }), t;
  }
  function bie(e) {
    e === void 0 && (e = {});
    const {
      placement: t = "bottom",
      strategy: n = "absolute",
      middleware: r = [],
      platform: o,
      elements: {
        reference: i,
        floating: a
      } = {},
      transform: s = !0,
      whileElementsMounted: l,
      open: u
    } = e, [d, p] = T.useState({
      x: 0,
      y: 0,
      strategy: n,
      placement: t,
      middlewareData: {},
      isPositioned: !1
    }), [h, g] = T.useState(r);
    e0(h, r) || g(r);
    const [y, b] = T.useState(null), [v, x] = T.useState(null), E = T.useCallback((W) => {
      W !== R.current && (R.current = W, b(W));
    }, []), _ = T.useCallback((W) => {
      W !== A.current && (A.current = W, x(W));
    }, []), C = i || y, k = a || v, R = T.useRef(null), A = T.useRef(null), M = T.useRef(d), I = l != null, D = ES(l), L = ES(o), P = ES(u), B = T.useCallback(() => {
      if (!R.current || !A.current)
        return;
      const W = {
        placement: t,
        strategy: n,
        middleware: h
      };
      L.current && (W.platform = L.current), gie(R.current, A.current, W).then((K) => {
        const $ = {
          ...K,
          // The floating element's position may be recomputed while it's closed
          // but still mounted (such as when transitioning out). To ensure
          // `isPositioned` will be `false` initially on the next open, avoid
          // setting it to `true` when `open === false` (must be specified).
          isPositioned: P.current !== !1
        };
        j.current && !e0(M.current, $) && (M.current = $, gc.flushSync(() => {
          p($);
        }));
      });
    }, [h, t, n, L, P]);
    vv(() => {
      u === !1 && M.current.isPositioned && (M.current.isPositioned = !1, p((W) => ({
        ...W,
        isPositioned: !1
      })));
    }, [u]);
    const j = T.useRef(!1);
    vv(() => (j.current = !0, () => {
      j.current = !1;
    }), []), vv(() => {
      if (C && (R.current = C), k && (A.current = k), C && k) {
        if (D.current)
          return D.current(C, k, B);
        B();
      }
    }, [C, k, B, D, I]);
    const V = T.useMemo(() => ({
      reference: R,
      floating: A,
      setReference: E,
      setFloating: _
    }), [E, _]), F = T.useMemo(() => ({
      reference: C,
      floating: k
    }), [C, k]), G = T.useMemo(() => {
      const W = {
        position: n,
        left: 0,
        top: 0
      };
      if (!F.floating)
        return W;
      const K = a2(F.floating, d.x), $ = a2(F.floating, d.y);
      return s ? {
        ...W,
        transform: "translate(" + K + "px, " + $ + "px)",
        ...mz(F.floating) >= 1.5 && {
          willChange: "transform"
        }
      } : {
        position: n,
        left: K,
        top: $
      };
    }, [n, s, F.floating, d.x, d.y]);
    return T.useMemo(() => ({
      ...d,
      update: B,
      refs: V,
      elements: F,
      floatingStyles: G
    }), [d, B, V, F, G]);
  }
  const xie = (e) => {
    function t(n) {
      return {}.hasOwnProperty.call(n, "current");
    }
    return {
      name: "arrow",
      options: e,
      fn(n) {
        const {
          element: r,
          padding: o
        } = typeof e == "function" ? e(n) : e;
        return r && t(r) ? r.current != null ? i2({
          element: r.current,
          padding: o
        }).fn(n) : {} : r ? i2({
          element: r,
          padding: o
        }).fn(n) : {};
      }
    };
  }, wie = (e, t) => ({
    ...uie(e),
    options: [e, t]
  }), Sie = (e, t) => ({
    ...fie(e),
    options: [e, t]
  }), _ie = (e, t) => ({
    ...mie(e),
    options: [e, t]
  }), Eie = (e, t) => ({
    ...die(e),
    options: [e, t]
  }), Cie = (e, t) => ({
    ...pie(e),
    options: [e, t]
  }), kie = (e, t) => ({
    ...hie(e),
    options: [e, t]
  }), Tie = (e, t) => ({
    ...xie(e),
    options: [e, t]
  });
  var Rie = "Arrow", gz = T.forwardRef((e, t) => {
    const { children: n, width: r = 10, height: o = 5, ...i } = e;
    return /* @__PURE__ */ S.jsx(
      xt.svg,
      {
        ...i,
        ref: t,
        width: r,
        height: o,
        viewBox: "0 0 30 10",
        preserveAspectRatio: "none",
        children: e.asChild ? n : /* @__PURE__ */ S.jsx("polygon", { points: "0,0 30,0 15,10" })
      }
    );
  });
  gz.displayName = Rie;
  var Oie = gz;
  function yz(e) {
    const [t, n] = T.useState(void 0);
    return Fa(() => {
      if (e) {
        n({ width: e.offsetWidth, height: e.offsetHeight });
        const r = new ResizeObserver((o) => {
          if (!Array.isArray(o) || !o.length)
            return;
          const i = o[0];
          let a, s;
          if ("borderBoxSize" in i) {
            const l = i.borderBoxSize, u = Array.isArray(l) ? l[0] : l;
            a = u.inlineSize, s = u.blockSize;
          } else
            a = e.offsetWidth, s = e.offsetHeight;
          n({ width: a, height: s });
        });
        return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
      } else
        n(void 0);
    }, [e]), t;
  }
  var Zk = "Popper", [vz, _b] = Yi(Zk), [Aie, bz] = vz(Zk), xz = (e) => {
    const { __scopePopper: t, children: n } = e, [r, o] = T.useState(null);
    return /* @__PURE__ */ S.jsx(Aie, { scope: t, anchor: r, onAnchorChange: o, children: n });
  };
  xz.displayName = Zk;
  var wz = "PopperAnchor", Sz = T.forwardRef(
    (e, t) => {
      const { __scopePopper: n, virtualRef: r, ...o } = e, i = bz(wz, n), a = T.useRef(null), s = an(t, a);
      return T.useEffect(() => {
        i.onAnchorChange(r?.current || a.current);
      }), r ? null : /* @__PURE__ */ S.jsx(xt.div, { ...o, ref: s });
    }
  );
  Sz.displayName = wz;
  var Qk = "PopperContent", [Nie, Mie] = vz(Qk), _z = T.forwardRef(
    (e, t) => {
      const {
        __scopePopper: n,
        side: r = "bottom",
        sideOffset: o = 0,
        align: i = "center",
        alignOffset: a = 0,
        arrowPadding: s = 0,
        avoidCollisions: l = !0,
        collisionBoundary: u = [],
        collisionPadding: d = 0,
        sticky: p = "partial",
        hideWhenDetached: h = !1,
        updatePositionStrategy: g = "optimized",
        onPlaced: y,
        ...b
      } = e, v = bz(Qk, n), [x, E] = T.useState(null), _ = an(t, (re) => E(re)), [C, k] = T.useState(null), R = yz(C), A = R?.width ?? 0, M = R?.height ?? 0, I = r + (i !== "center" ? "-" + i : ""), D = typeof d == "number" ? d : { top: 0, right: 0, bottom: 0, left: 0, ...d }, L = Array.isArray(u) ? u : [u], P = L.length > 0, B = {
        padding: D,
        boundary: L.filter($ie),
        // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
        altBoundary: P
      }, { refs: j, floatingStyles: V, placement: F, isPositioned: G, middlewareData: W } = bie({
        // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
        strategy: "fixed",
        placement: I,
        whileElementsMounted: (...re) => hz(...re, {
          animationFrame: g === "always"
        }),
        elements: {
          reference: v.anchor
        },
        middleware: [
          wie({ mainAxis: o + M, alignmentAxis: a }),
          l && Sie({
            mainAxis: !0,
            crossAxis: !1,
            limiter: p === "partial" ? _ie() : void 0,
            ...B
          }),
          l && Eie({ ...B }),
          Cie({
            ...B,
            apply: ({ elements: re, rects: te, availableWidth: le, availableHeight: fe }) => {
              const { width: J, height: ee } = te.reference, ie = re.floating.style;
              ie.setProperty("--radix-popper-available-width", `${le}px`), ie.setProperty("--radix-popper-available-height", `${fe}px`), ie.setProperty("--radix-popper-anchor-width", `${J}px`), ie.setProperty("--radix-popper-anchor-height", `${ee}px`);
            }
          }),
          C && Tie({ element: C, padding: s }),
          Iie({ arrowWidth: A, arrowHeight: M }),
          h && kie({ strategy: "referenceHidden", ...B })
        ]
      }), [K, $] = kz(F), U = Vr(y);
      Fa(() => {
        G && U?.();
      }, [G, U]);
      const X = W.arrow?.x, z = W.arrow?.y, H = W.arrow?.centerOffset !== 0, [Y, Q] = T.useState();
      return Fa(() => {
        x && Q(window.getComputedStyle(x).zIndex);
      }, [x]), /* @__PURE__ */ S.jsx(
        "div",
        {
          ref: j.setFloating,
          "data-radix-popper-content-wrapper": "",
          style: {
            ...V,
            transform: G ? V.transform : "translate(0, -200%)",
            // keep off the page when measuring
            minWidth: "max-content",
            zIndex: Y,
            "--radix-popper-transform-origin": [
              W.transformOrigin?.x,
              W.transformOrigin?.y
            ].join(" "),
            // hide the content if using the hide middleware and should be hidden
            // set visibility to hidden and disable pointer events so the UI behaves
            // as if the PopperContent isn't there at all
            ...W.hide?.referenceHidden && {
              visibility: "hidden",
              pointerEvents: "none"
            }
          },
          dir: e.dir,
          children: /* @__PURE__ */ S.jsx(
            Nie,
            {
              scope: n,
              placedSide: K,
              onArrowChange: k,
              arrowX: X,
              arrowY: z,
              shouldHideArrow: H,
              children: /* @__PURE__ */ S.jsx(
                xt.div,
                {
                  "data-side": K,
                  "data-align": $,
                  ...b,
                  ref: _,
                  style: {
                    ...b.style,
                    // if the PopperContent hasn't been placed yet (not all measurements done)
                    // we prevent animations so that users's animation don't kick in too early referring wrong sides
                    animation: G ? void 0 : "none"
                  }
                }
              )
            }
          )
        }
      );
    }
  );
  _z.displayName = Qk;
  var Ez = "PopperArrow", Pie = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
  }, Cz = T.forwardRef(function(t, n) {
    const { __scopePopper: r, ...o } = t, i = Mie(Ez, r), a = Pie[i.placedSide];
    return (
      // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
      // doesn't report size as we'd expect on SVG elements.
      // it reports their bounding box which is effectively the largest path inside the SVG.
      /* @__PURE__ */ S.jsx(
        "span",
        {
          ref: i.onArrowChange,
          style: {
            position: "absolute",
            left: i.arrowX,
            top: i.arrowY,
            [a]: 0,
            transformOrigin: {
              top: "",
              right: "0 0",
              bottom: "center 0",
              left: "100% 0"
            }[i.placedSide],
            transform: {
              top: "translateY(100%)",
              right: "translateY(50%) rotate(90deg) translateX(-50%)",
              bottom: "rotate(180deg)",
              left: "translateY(50%) rotate(-90deg) translateX(50%)"
            }[i.placedSide],
            visibility: i.shouldHideArrow ? "hidden" : void 0
          },
          children: /* @__PURE__ */ S.jsx(
            Oie,
            {
              ...o,
              ref: n,
              style: {
                ...o.style,
                // ensures the element can be measured correctly (mostly for if SVG)
                display: "block"
              }
            }
          )
        }
      )
    );
  });
  Cz.displayName = Ez;
  function $ie(e) {
    return e !== null;
  }
  var Iie = (e) => ({
    name: "transformOrigin",
    options: e,
    fn(t) {
      const { placement: n, rects: r, middlewareData: o } = t, a = o.arrow?.centerOffset !== 0, s = a ? 0 : e.arrowWidth, l = a ? 0 : e.arrowHeight, [u, d] = kz(n), p = { start: "0%", center: "50%", end: "100%" }[d], h = (o.arrow?.x ?? 0) + s / 2, g = (o.arrow?.y ?? 0) + l / 2;
      let y = "", b = "";
      return u === "bottom" ? (y = a ? p : `${h}px`, b = `${-l}px`) : u === "top" ? (y = a ? p : `${h}px`, b = `${r.floating.height + l}px`) : u === "right" ? (y = `${-l}px`, b = a ? p : `${g}px`) : u === "left" && (y = `${r.floating.width + l}px`, b = a ? p : `${g}px`), { data: { x: y, y: b } };
    }
  });
  function kz(e) {
    const [t, n = "center"] = e.split("-");
    return [t, n];
  }
  var Jk = xz, eT = Sz, Tz = _z, Rz = Cz, Eb = "Popover", [Oz, ULe] = Yi(Eb, [
    _b
  ]), Uh = _b(), [jie, cl] = Oz(Eb), Az = (e) => {
    const {
      __scopePopover: t,
      children: n,
      open: r,
      defaultOpen: o,
      onOpenChange: i,
      modal: a = !1
    } = e, s = Uh(t), l = T.useRef(null), [u, d] = T.useState(!1), [p, h] = ll({
      prop: r,
      defaultProp: o ?? !1,
      onChange: i,
      caller: Eb
    });
    return /* @__PURE__ */ S.jsx(Jk, { ...s, children: /* @__PURE__ */ S.jsx(
      jie,
      {
        scope: t,
        contentId: Bi(),
        triggerRef: l,
        open: p,
        onOpenChange: h,
        onOpenToggle: T.useCallback(() => h((g) => !g), [h]),
        hasCustomAnchor: u,
        onCustomAnchorAdd: T.useCallback(() => d(!0), []),
        onCustomAnchorRemove: T.useCallback(() => d(!1), []),
        modal: a,
        children: n
      }
    ) });
  };
  Az.displayName = Eb;
  var Nz = "PopoverAnchor", Die = T.forwardRef(
    (e, t) => {
      const { __scopePopover: n, ...r } = e, o = cl(Nz, n), i = Uh(n), { onCustomAnchorAdd: a, onCustomAnchorRemove: s } = o;
      return T.useEffect(() => (a(), () => s()), [a, s]), /* @__PURE__ */ S.jsx(eT, { ...i, ...r, ref: t });
    }
  );
  Die.displayName = Nz;
  var Mz = "PopoverTrigger", Pz = T.forwardRef(
    (e, t) => {
      const { __scopePopover: n, ...r } = e, o = cl(Mz, n), i = Uh(n), a = an(t, o.triggerRef), s = /* @__PURE__ */ S.jsx(
        xt.button,
        {
          type: "button",
          "aria-haspopup": "dialog",
          "aria-expanded": o.open,
          "aria-controls": o.contentId,
          "data-state": Lz(o.open),
          ...r,
          ref: a,
          onClick: Fe(e.onClick, o.onOpenToggle)
        }
      );
      return o.hasCustomAnchor ? s : /* @__PURE__ */ S.jsx(eT, { asChild: !0, ...i, children: s });
    }
  );
  Pz.displayName = Mz;
  var tT = "PopoverPortal", [Fie, Lie] = Oz(tT, {
    forceMount: void 0
  }), $z = (e) => {
    const { __scopePopover: t, forceMount: n, children: r, container: o } = e, i = cl(tT, t);
    return /* @__PURE__ */ S.jsx(Fie, { scope: t, forceMount: n, children: /* @__PURE__ */ S.jsx(ei, { present: n || i.open, children: /* @__PURE__ */ S.jsx(ub, { asChild: !0, container: o, children: r }) }) });
  };
  $z.displayName = tT;
  var af = "PopoverContent", Iz = T.forwardRef(
    (e, t) => {
      const n = Lie(af, e.__scopePopover), { forceMount: r = n.forceMount, ...o } = e, i = cl(af, e.__scopePopover);
      return /* @__PURE__ */ S.jsx(ei, { present: r || i.open, children: i.modal ? /* @__PURE__ */ S.jsx(Bie, { ...o, ref: t }) : /* @__PURE__ */ S.jsx(Uie, { ...o, ref: t }) });
    }
  );
  Iz.displayName = af;
  var zie = /* @__PURE__ */ nf("PopoverContent.RemoveScroll"), Bie = T.forwardRef(
    (e, t) => {
      const n = cl(af, e.__scopePopover), r = T.useRef(null), o = an(t, r), i = T.useRef(!1);
      return T.useEffect(() => {
        const a = r.current;
        if (a) return kk(a);
      }, []), /* @__PURE__ */ S.jsx(db, { as: zie, allowPinchZoom: !0, children: /* @__PURE__ */ S.jsx(
        jz,
        {
          ...e,
          ref: o,
          trapFocus: n.open,
          disableOutsidePointerEvents: !0,
          onCloseAutoFocus: Fe(e.onCloseAutoFocus, (a) => {
            a.preventDefault(), i.current || n.triggerRef.current?.focus();
          }),
          onPointerDownOutside: Fe(
            e.onPointerDownOutside,
            (a) => {
              const s = a.detail.originalEvent, l = s.button === 0 && s.ctrlKey === !0, u = s.button === 2 || l;
              i.current = u;
            },
            { checkForDefaultPrevented: !1 }
          ),
          onFocusOutside: Fe(
            e.onFocusOutside,
            (a) => a.preventDefault(),
            { checkForDefaultPrevented: !1 }
          )
        }
      ) });
    }
  ), Uie = T.forwardRef(
    (e, t) => {
      const n = cl(af, e.__scopePopover), r = T.useRef(!1), o = T.useRef(!1);
      return /* @__PURE__ */ S.jsx(
        jz,
        {
          ...e,
          ref: t,
          trapFocus: !1,
          disableOutsidePointerEvents: !1,
          onCloseAutoFocus: (i) => {
            e.onCloseAutoFocus?.(i), i.defaultPrevented || (r.current || n.triggerRef.current?.focus(), i.preventDefault()), r.current = !1, o.current = !1;
          },
          onInteractOutside: (i) => {
            e.onInteractOutside?.(i), i.defaultPrevented || (r.current = !0, i.detail.originalEvent.type === "pointerdown" && (o.current = !0));
            const a = i.target;
            n.triggerRef.current?.contains(a) && i.preventDefault(), i.detail.originalEvent.type === "focusin" && o.current && i.preventDefault();
          }
        }
      );
    }
  ), jz = T.forwardRef(
    (e, t) => {
      const {
        __scopePopover: n,
        trapFocus: r,
        onOpenAutoFocus: o,
        onCloseAutoFocus: i,
        disableOutsidePointerEvents: a,
        onEscapeKeyDown: s,
        onPointerDownOutside: l,
        onFocusOutside: u,
        onInteractOutside: d,
        ...p
      } = e, h = cl(af, n), g = Uh(n);
      return Ck(), /* @__PURE__ */ S.jsx(
        cb,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: o,
          onUnmountAutoFocus: i,
          children: /* @__PURE__ */ S.jsx(
            jh,
            {
              asChild: !0,
              disableOutsidePointerEvents: a,
              onInteractOutside: d,
              onEscapeKeyDown: s,
              onPointerDownOutside: l,
              onFocusOutside: u,
              onDismiss: () => h.onOpenChange(!1),
              children: /* @__PURE__ */ S.jsx(
                Tz,
                {
                  "data-state": Lz(h.open),
                  role: "dialog",
                  id: h.contentId,
                  ...g,
                  ...p,
                  ref: t,
                  style: {
                    ...p.style,
                    "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                    "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                    "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                    "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                    "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                  }
                }
              )
            }
          )
        }
      );
    }
  ), Dz = "PopoverClose", Vie = T.forwardRef(
    (e, t) => {
      const { __scopePopover: n, ...r } = e, o = cl(Dz, n);
      return /* @__PURE__ */ S.jsx(
        xt.button,
        {
          type: "button",
          ...r,
          ref: t,
          onClick: Fe(e.onClick, () => o.onOpenChange(!1))
        }
      );
    }
  );
  Vie.displayName = Dz;
  var Hie = "PopoverArrow", Fz = T.forwardRef(
    (e, t) => {
      const { __scopePopover: n, ...r } = e, o = Uh(n);
      return /* @__PURE__ */ S.jsx(Rz, { ...o, ...r, ref: t });
    }
  );
  Fz.displayName = Hie;
  function Lz(e) {
    return e ? "open" : "closed";
  }
  var zz = Az, Bz = Pz, Uz = $z, Vz = Iz, qie = Fz;
  const Qp = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  }, Hz = {};
  for (const e of Object.keys(Qp))
    Hz[Qp[e]] = e;
  const Pe = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    oklab: { channels: 3, labels: ["okl", "oka", "okb"] },
    lch: { channels: 3, labels: "lch" },
    oklch: { channels: 3, labels: ["okl", "okc", "okh"] },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  }, Ma = (6 / 29) ** 3;
  function Ku(e) {
    const t = e > 31308e-7 ? 1.055 * e ** 0.4166666666666667 - 0.055 : e * 12.92;
    return Math.min(Math.max(0, t), 1);
  }
  function Yu(e) {
    return e > 0.04045 ? ((e + 0.055) / 1.055) ** 2.4 : e / 12.92;
  }
  for (const e of Object.keys(Pe)) {
    if (!("channels" in Pe[e]))
      throw new Error("missing channels property: " + e);
    if (!("labels" in Pe[e]))
      throw new Error("missing channel labels property: " + e);
    if (Pe[e].labels.length !== Pe[e].channels)
      throw new Error("channel and label counts mismatch: " + e);
    const { channels: t, labels: n } = Pe[e];
    delete Pe[e].channels, delete Pe[e].labels, Object.defineProperty(Pe[e], "channels", { value: t }), Object.defineProperty(Pe[e], "labels", { value: n });
  }
  Pe.rgb.hsl = function(e) {
    const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.min(t, n, r), i = Math.max(t, n, r), a = i - o;
    let s, l;
    switch (i) {
      case o: {
        s = 0;
        break;
      }
      case t: {
        s = (n - r) / a;
        break;
      }
      case n: {
        s = 2 + (r - t) / a;
        break;
      }
      case r: {
        s = 4 + (t - n) / a;
        break;
      }
    }
    s = Math.min(s * 60, 360), s < 0 && (s += 360);
    const u = (o + i) / 2;
    return i === o ? l = 0 : u <= 0.5 ? l = a / (i + o) : l = a / (2 - i - o), [s, l * 100, u * 100];
  };
  Pe.rgb.hsv = function(e) {
    let t, n, r, o, i;
    const a = e[0] / 255, s = e[1] / 255, l = e[2] / 255, u = Math.max(a, s, l), d = u - Math.min(a, s, l), p = function(h) {
      return (u - h) / 6 / d + 1 / 2;
    };
    if (d === 0)
      o = 0, i = 0;
    else {
      switch (i = d / u, t = p(a), n = p(s), r = p(l), u) {
        case a: {
          o = r - n;
          break;
        }
        case s: {
          o = 1 / 3 + t - r;
          break;
        }
        case l: {
          o = 2 / 3 + n - t;
          break;
        }
      }
      o < 0 ? o += 1 : o > 1 && (o -= 1);
    }
    return [
      o * 360,
      i * 100,
      u * 100
    ];
  };
  Pe.rgb.hwb = function(e) {
    const t = e[0], n = e[1];
    let r = e[2];
    const o = Pe.rgb.hsl(e)[0], i = 1 / 255 * Math.min(t, Math.min(n, r));
    return r = 1 - 1 / 255 * Math.max(t, Math.max(n, r)), [o, i * 100, r * 100];
  };
  Pe.rgb.oklab = function(e) {
    const t = Yu(e[0] / 255), n = Yu(e[1] / 255), r = Yu(e[2] / 255), o = Math.cbrt(0.4122214708 * t + 0.5363325363 * n + 0.0514459929 * r), i = Math.cbrt(0.2119034982 * t + 0.6806995451 * n + 0.1073969566 * r), a = Math.cbrt(0.0883024619 * t + 0.2817188376 * n + 0.6299787005 * r), s = 0.2104542553 * o + 0.793617785 * i - 0.0040720468 * a, l = 1.9779984951 * o - 2.428592205 * i + 0.4505937099 * a, u = 0.0259040371 * o + 0.7827717662 * i - 0.808675766 * a;
    return [s * 100, l * 100, u * 100];
  };
  Pe.rgb.cmyk = function(e) {
    const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.min(1 - t, 1 - n, 1 - r), i = (1 - t - o) / (1 - o) || 0, a = (1 - n - o) / (1 - o) || 0, s = (1 - r - o) / (1 - o) || 0;
    return [i * 100, a * 100, s * 100, o * 100];
  };
  function Wie(e, t) {
    return (e[0] - t[0]) ** 2 + (e[1] - t[1]) ** 2 + (e[2] - t[2]) ** 2;
  }
  Pe.rgb.keyword = function(e) {
    const t = Hz[e];
    if (t)
      return t;
    let n = Number.POSITIVE_INFINITY, r;
    for (const o of Object.keys(Qp)) {
      const i = Qp[o], a = Wie(e, i);
      a < n && (n = a, r = o);
    }
    return r;
  };
  Pe.keyword.rgb = function(e) {
    return Qp[e];
  };
  Pe.rgb.xyz = function(e) {
    const t = Yu(e[0] / 255), n = Yu(e[1] / 255), r = Yu(e[2] / 255), o = t * 0.4124564 + n * 0.3575761 + r * 0.1804375, i = t * 0.2126729 + n * 0.7151522 + r * 0.072175, a = t * 0.0193339 + n * 0.119192 + r * 0.9503041;
    return [o * 100, i * 100, a * 100];
  };
  Pe.rgb.lab = function(e) {
    const t = Pe.rgb.xyz(e);
    let n = t[0], r = t[1], o = t[2];
    n /= 95.047, r /= 100, o /= 108.883, n = n > Ma ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > Ma ? r ** (1 / 3) : 7.787 * r + 16 / 116, o = o > Ma ? o ** (1 / 3) : 7.787 * o + 16 / 116;
    const i = 116 * r - 16, a = 500 * (n - r), s = 200 * (r - o);
    return [i, a, s];
  };
  Pe.hsl.rgb = function(e) {
    const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
    let o, i;
    if (n === 0)
      return i = r * 255, [i, i, i];
    const a = r < 0.5 ? r * (1 + n) : r + n - r * n, s = 2 * r - a, l = [0, 0, 0];
    for (let u = 0; u < 3; u++)
      o = t + 1 / 3 * -(u - 1), o < 0 && o++, o > 1 && o--, 6 * o < 1 ? i = s + (a - s) * 6 * o : 2 * o < 1 ? i = a : 3 * o < 2 ? i = s + (a - s) * (2 / 3 - o) * 6 : i = s, l[u] = i * 255;
    return l;
  };
  Pe.hsl.hsv = function(e) {
    const t = e[0];
    let n = e[1] / 100, r = e[2] / 100, o = n;
    const i = Math.max(r, 0.01);
    r *= 2, n *= r <= 1 ? r : 2 - r, o *= i <= 1 ? i : 2 - i;
    const a = (r + n) / 2, s = r === 0 ? 2 * o / (i + o) : 2 * n / (r + n);
    return [t, s * 100, a * 100];
  };
  Pe.hsv.rgb = function(e) {
    const t = e[0] / 60, n = e[1] / 100;
    let r = e[2] / 100;
    const o = Math.floor(t) % 6, i = t - Math.floor(t), a = 255 * r * (1 - n), s = 255 * r * (1 - n * i), l = 255 * r * (1 - n * (1 - i));
    switch (r *= 255, o) {
      case 0:
        return [r, l, a];
      case 1:
        return [s, r, a];
      case 2:
        return [a, r, l];
      case 3:
        return [a, s, r];
      case 4:
        return [l, a, r];
      case 5:
        return [r, a, s];
    }
  };
  Pe.hsv.hsl = function(e) {
    const t = e[0], n = e[1] / 100, r = e[2] / 100, o = Math.max(r, 0.01);
    let i, a;
    a = (2 - n) * r;
    const s = (2 - n) * o;
    return i = n * o, i /= s <= 1 ? s : 2 - s, i = i || 0, a /= 2, [t, i * 100, a * 100];
  };
  Pe.hwb.rgb = function(e) {
    const t = e[0] / 360;
    let n = e[1] / 100, r = e[2] / 100;
    const o = n + r;
    let i;
    o > 1 && (n /= o, r /= o);
    const a = Math.floor(6 * t), s = 1 - r;
    i = 6 * t - a, (a & 1) !== 0 && (i = 1 - i);
    const l = n + i * (s - n);
    let u, d, p;
    switch (a) {
      default:
      case 6:
      case 0: {
        u = s, d = l, p = n;
        break;
      }
      case 1: {
        u = l, d = s, p = n;
        break;
      }
      case 2: {
        u = n, d = s, p = l;
        break;
      }
      case 3: {
        u = n, d = l, p = s;
        break;
      }
      case 4: {
        u = l, d = n, p = s;
        break;
      }
      case 5: {
        u = s, d = n, p = l;
        break;
      }
    }
    return [u * 255, d * 255, p * 255];
  };
  Pe.cmyk.rgb = function(e) {
    const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = e[3] / 100, i = 1 - Math.min(1, t * (1 - o) + o), a = 1 - Math.min(1, n * (1 - o) + o), s = 1 - Math.min(1, r * (1 - o) + o);
    return [i * 255, a * 255, s * 255];
  };
  Pe.xyz.rgb = function(e) {
    const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100;
    let o, i, a;
    return o = t * 3.2404542 + n * -1.5371385 + r * -0.4985314, i = t * -0.969266 + n * 1.8760108 + r * 0.041556, a = t * 0.0556434 + n * -0.2040259 + r * 1.0572252, o = Ku(o), i = Ku(i), a = Ku(a), [o * 255, i * 255, a * 255];
  };
  Pe.xyz.lab = function(e) {
    let t = e[0], n = e[1], r = e[2];
    t /= 95.047, n /= 100, r /= 108.883, t = t > Ma ? t ** (1 / 3) : 7.787 * t + 16 / 116, n = n > Ma ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > Ma ? r ** (1 / 3) : 7.787 * r + 16 / 116;
    const o = 116 * n - 16, i = 500 * (t - n), a = 200 * (n - r);
    return [o, i, a];
  };
  Pe.xyz.oklab = function(e) {
    const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = Math.cbrt(0.8189330101 * t + 0.3618667424 * n - 0.1288597137 * r), i = Math.cbrt(0.0329845436 * t + 0.9293118715 * n + 0.0361456387 * r), a = Math.cbrt(0.0482003018 * t + 0.2643662691 * n + 0.633851707 * r), s = 0.2104542553 * o + 0.793617785 * i - 0.0040720468 * a, l = 1.9779984951 * o - 2.428592205 * i + 0.4505937099 * a, u = 0.0259040371 * o + 0.7827717662 * i - 0.808675766 * a;
    return [s * 100, l * 100, u * 100];
  };
  Pe.oklab.oklch = function(e) {
    return Pe.lab.lch(e);
  };
  Pe.oklab.xyz = function(e) {
    const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = (0.999999998 * t + 0.396337792 * n + 0.215803758 * r) ** 3, i = (1.000000008 * t - 0.105561342 * n - 0.063854175 * r) ** 3, a = (1.000000055 * t - 0.089484182 * n - 1.291485538 * r) ** 3, s = 1.227013851 * o - 0.55779998 * i + 0.281256149 * a, l = -0.040580178 * o + 1.11225687 * i - 0.071676679 * a, u = -0.076381285 * o - 0.421481978 * i + 1.58616322 * a;
    return [s * 100, l * 100, u * 100];
  };
  Pe.oklab.rgb = function(e) {
    const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = (t + 0.3963377774 * n + 0.2158037573 * r) ** 3, i = (t - 0.1055613458 * n - 0.0638541728 * r) ** 3, a = (t - 0.0894841775 * n - 1.291485548 * r) ** 3, s = Ku(4.0767416621 * o - 3.3077115913 * i + 0.2309699292 * a), l = Ku(-1.2684380046 * o + 2.6097574011 * i - 0.3413193965 * a), u = Ku(-0.0041960863 * o - 0.7034186147 * i + 1.707614701 * a);
    return [s * 255, l * 255, u * 255];
  };
  Pe.oklch.oklab = function(e) {
    return Pe.lch.lab(e);
  };
  Pe.lab.xyz = function(e) {
    const t = e[0], n = e[1], r = e[2];
    let o, i, a;
    i = (t + 16) / 116, o = n / 500 + i, a = i - r / 200;
    const s = i ** 3, l = o ** 3, u = a ** 3;
    return i = s > Ma ? s : (i - 16 / 116) / 7.787, o = l > Ma ? l : (o - 16 / 116) / 7.787, a = u > Ma ? u : (a - 16 / 116) / 7.787, o *= 95.047, i *= 100, a *= 108.883, [o, i, a];
  };
  Pe.lab.lch = function(e) {
    const t = e[0], n = e[1], r = e[2];
    let o;
    o = Math.atan2(r, n) * 360 / 2 / Math.PI, o < 0 && (o += 360);
    const a = Math.sqrt(n * n + r * r);
    return [t, a, o];
  };
  Pe.lch.lab = function(e) {
    const t = e[0], n = e[1], o = e[2] / 360 * 2 * Math.PI, i = n * Math.cos(o), a = n * Math.sin(o);
    return [t, i, a];
  };
  Pe.rgb.ansi16 = function(e, t = null) {
    const [n, r, o] = e;
    let i = t === null ? Pe.rgb.hsv(e)[2] : t;
    if (i = Math.round(i / 50), i === 0)
      return 30;
    let a = 30 + (Math.round(o / 255) << 2 | Math.round(r / 255) << 1 | Math.round(n / 255));
    return i === 2 && (a += 60), a;
  };
  Pe.hsv.ansi16 = function(e) {
    return Pe.rgb.ansi16(Pe.hsv.rgb(e), e[2]);
  };
  Pe.rgb.ansi256 = function(e) {
    const t = e[0], n = e[1], r = e[2];
    return t >> 4 === n >> 4 && n >> 4 === r >> 4 ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(r / 255 * 5);
  };
  Pe.ansi16.rgb = function(e) {
    e = e[0];
    let t = e % 10;
    if (t === 0 || t === 7)
      return e > 50 && (t += 3.5), t = t / 10.5 * 255, [t, t, t];
    const n = (Math.trunc(e > 50) + 1) * 0.5, r = (t & 1) * n * 255, o = (t >> 1 & 1) * n * 255, i = (t >> 2 & 1) * n * 255;
    return [r, o, i];
  };
  Pe.ansi256.rgb = function(e) {
    if (e = e[0], e >= 232) {
      const i = (e - 232) * 10 + 8;
      return [i, i, i];
    }
    e -= 16;
    let t;
    const n = Math.floor(e / 36) / 5 * 255, r = Math.floor((t = e % 36) / 6) / 5 * 255, o = t % 6 / 5 * 255;
    return [n, r, o];
  };
  Pe.rgb.hex = function(e) {
    const n = (((Math.round(e[0]) & 255) << 16) + ((Math.round(e[1]) & 255) << 8) + (Math.round(e[2]) & 255)).toString(16).toUpperCase();
    return "000000".slice(n.length) + n;
  };
  Pe.hex.rgb = function(e) {
    const t = e.toString(16).match(/[a-f\d]{6}|[a-f\d]{3}/i);
    if (!t)
      return [0, 0, 0];
    let n = t[0];
    t[0].length === 3 && (n = [...n].map((s) => s + s).join(""));
    const r = Number.parseInt(n, 16), o = r >> 16 & 255, i = r >> 8 & 255, a = r & 255;
    return [o, i, a];
  };
  Pe.rgb.hcg = function(e) {
    const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.max(Math.max(t, n), r), i = Math.min(Math.min(t, n), r), a = o - i;
    let s;
    const l = a < 1 ? i / (1 - a) : 0;
    return a <= 0 ? s = 0 : o === t ? s = (n - r) / a % 6 : o === n ? s = 2 + (r - t) / a : s = 4 + (t - n) / a, s /= 6, s %= 1, [s * 360, a * 100, l * 100];
  };
  Pe.hsl.hcg = function(e) {
    const t = e[1] / 100, n = e[2] / 100, r = n < 0.5 ? 2 * t * n : 2 * t * (1 - n);
    let o = 0;
    return r < 1 && (o = (n - 0.5 * r) / (1 - r)), [e[0], r * 100, o * 100];
  };
  Pe.hsv.hcg = function(e) {
    const t = e[1] / 100, n = e[2] / 100, r = t * n;
    let o = 0;
    return r < 1 && (o = (n - r) / (1 - r)), [e[0], r * 100, o * 100];
  };
  Pe.hcg.rgb = function(e) {
    const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
    if (n === 0)
      return [r * 255, r * 255, r * 255];
    const o = [0, 0, 0], i = t % 1 * 6, a = i % 1, s = 1 - a;
    let l = 0;
    switch (Math.floor(i)) {
      case 0: {
        o[0] = 1, o[1] = a, o[2] = 0;
        break;
      }
      case 1: {
        o[0] = s, o[1] = 1, o[2] = 0;
        break;
      }
      case 2: {
        o[0] = 0, o[1] = 1, o[2] = a;
        break;
      }
      case 3: {
        o[0] = 0, o[1] = s, o[2] = 1;
        break;
      }
      case 4: {
        o[0] = a, o[1] = 0, o[2] = 1;
        break;
      }
      default:
        o[0] = 1, o[1] = 0, o[2] = s;
    }
    return l = (1 - n) * r, [
      (n * o[0] + l) * 255,
      (n * o[1] + l) * 255,
      (n * o[2] + l) * 255
    ];
  };
  Pe.hcg.hsv = function(e) {
    const t = e[1] / 100, n = e[2] / 100, r = t + n * (1 - t);
    let o = 0;
    return r > 0 && (o = t / r), [e[0], o * 100, r * 100];
  };
  Pe.hcg.hsl = function(e) {
    const t = e[1] / 100, r = e[2] / 100 * (1 - t) + 0.5 * t;
    let o = 0;
    return r > 0 && r < 0.5 ? o = t / (2 * r) : r >= 0.5 && r < 1 && (o = t / (2 * (1 - r))), [e[0], o * 100, r * 100];
  };
  Pe.hcg.hwb = function(e) {
    const t = e[1] / 100, n = e[2] / 100, r = t + n * (1 - t);
    return [e[0], (r - t) * 100, (1 - r) * 100];
  };
  Pe.hwb.hcg = function(e) {
    const t = e[1] / 100, r = 1 - e[2] / 100, o = r - t;
    let i = 0;
    return o < 1 && (i = (r - o) / (1 - o)), [e[0], o * 100, i * 100];
  };
  Pe.apple.rgb = function(e) {
    return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255];
  };
  Pe.rgb.apple = function(e) {
    return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535];
  };
  Pe.gray.rgb = function(e) {
    return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255];
  };
  Pe.gray.hsl = function(e) {
    return [0, 0, e[0]];
  };
  Pe.gray.hsv = Pe.gray.hsl;
  Pe.gray.hwb = function(e) {
    return [0, 100, e[0]];
  };
  Pe.gray.cmyk = function(e) {
    return [0, 0, 0, e[0]];
  };
  Pe.gray.lab = function(e) {
    return [e[0], 0, 0];
  };
  Pe.gray.hex = function(e) {
    const t = Math.round(e[0] / 100 * 255) & 255, r = ((t << 16) + (t << 8) + t).toString(16).toUpperCase();
    return "000000".slice(r.length) + r;
  };
  Pe.rgb.gray = function(e) {
    return [(e[0] + e[1] + e[2]) / 3 / 255 * 100];
  };
  function Gie() {
    const e = {}, t = Object.keys(Pe);
    for (let { length: n } = t, r = 0; r < n; r++)
      e[t[r]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return e;
  }
  function Kie(e) {
    const t = Gie(), n = [e];
    for (t[e].distance = 0; n.length > 0; ) {
      const r = n.pop(), o = Object.keys(Pe[r]);
      for (let { length: i } = o, a = 0; a < i; a++) {
        const s = o[a], l = t[s];
        l.distance === -1 && (l.distance = t[r].distance + 1, l.parent = r, n.unshift(s));
      }
    }
    return t;
  }
  function Yie(e, t) {
    return function(n) {
      return t(e(n));
    };
  }
  function Xie(e, t) {
    const n = [t[e].parent, e];
    let r = Pe[t[e].parent][e], o = t[e].parent;
    for (; t[o].parent; )
      n.unshift(t[o].parent), r = Yie(Pe[t[o].parent][o], r), o = t[o].parent;
    return r.conversion = n, r;
  }
  function Zie(e) {
    const t = Kie(e), n = {}, r = Object.keys(t);
    for (let { length: o } = r, i = 0; i < o; i++) {
      const a = r[i];
      t[a].parent !== null && (n[a] = Xie(a, t));
    }
    return n;
  }
  const ql = {}, Qie = Object.keys(Pe);
  function Jie(e) {
    const t = function(...n) {
      const r = n[0];
      return r == null ? r : (r.length > 1 && (n = r), e(n));
    };
    return "conversion" in e && (t.conversion = e.conversion), t;
  }
  function eae(e) {
    const t = function(...n) {
      const r = n[0];
      if (r == null)
        return r;
      r.length > 1 && (n = r);
      const o = e(n);
      if (typeof o == "object")
        for (let { length: i } = o, a = 0; a < i; a++)
          o[a] = Math.round(o[a]);
      return o;
    };
    return "conversion" in e && (t.conversion = e.conversion), t;
  }
  for (const e of Qie) {
    ql[e] = {}, Object.defineProperty(ql[e], "channels", { value: Pe[e].channels }), Object.defineProperty(ql[e], "labels", { value: Pe[e].labels });
    const t = Zie(e), n = Object.keys(t);
    for (const r of n) {
      const o = t[r];
      ql[e][r] = eae(o), ql[e][r].raw = Jie(o);
    }
  }
  const tae = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: ql
  }, Symbol.toStringTag, { value: "Module" })), hr = (e, t) => {
    const n = Array.isArray(t) ? t : [t];
    if (n[0] === void 0 || n[0] === null)
      return hr("rgb", [0, 0, 0]);
    const r = ql[e];
    if (!r)
      throw new Error(
        `Unsupported color type: ${e} allowed are ${Object.keys(tae).join(
          ", "
        )}`
      );
    r[e] = () => n;
    const o = (a) => {
      const s = a(...n);
      return Array.isArray(s) ? s[0] != null : s;
    };
    if (!o(r.rgb) || !o(r.hsl))
      return hr("rgb", [0, 0, 0]);
    const i = {};
    return Object.keys(r).forEach((a) => {
      const s = r[a];
      typeof s == "function" && (i[a] = () => a === e ? n : s(...n));
    }), i;
  }, nae = ({
    onChange: e,
    colorconverter: t,
    allow_null: n = !1
  }) => {
    if (t === null && !n)
      throw new Error("Color converter is null");
    const [r, o] = T.useState(t), [i, a] = T.useState([0, 0, 0]), [s, l] = T.useState([0, 0, 0]), [u, d] = T.useState([0, 0, 0]), [p, h] = T.useState("000");
    T.useEffect(() => {
      if (!r) {
        if (!n) throw new Error("Color converter is null");
        l([0, 0, 0]), a([0, 0, 0]), d([0, 0, 0]), h("");
        return;
      }
      a(r.hsl()), l(r.rgb()), d(r.hsv()), h(r.hex());
    }, [r]);
    const g = {
      backgroundColor: `hsl(${i[0]}, ${i[1]}%, ${i[2]}%)`,
      padding: "10px",
      margin: "10px 0"
    };
    return /* @__PURE__ */ S.jsxs("div", { style: { backgroundColor: "white" }, children: [
      /* @__PURE__ */ S.jsx("div", { style: g, children: "Color Preview" }),
      /* @__PURE__ */ S.jsxs("div", { className: "colorspace", children: [
        /* @__PURE__ */ S.jsx("div", { className: "colorspace_title", children: "RGB" }),
        /* @__PURE__ */ S.jsx("div", {}),
        /* @__PURE__ */ S.jsx("label", { children: "Red" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "255",
            value: s[0],
            onChange: (y) => {
              const b = [parseInt(y.target.value), s[1], s[2]], v = hr("rgb", b);
              o(v), e(v);
            },
            style: { background: "linear-gradient(to right, #000, #f00)" }
          }
        ),
        /* @__PURE__ */ S.jsx("label", { children: "Green" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "255",
            value: s[1],
            onChange: (y) => {
              const b = [s[0], parseInt(y.target.value), s[2]], v = hr("rgb", b);
              o(v), e(v);
            },
            style: { background: "linear-gradient(to right, #000, #0f0)" }
          }
        ),
        /* @__PURE__ */ S.jsx("label", { children: "Blue" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "255",
            value: s[2],
            onChange: (y) => {
              const b = [s[0], s[1], parseInt(y.target.value)], v = hr("rgb", b);
              o(v), e(v);
            },
            style: { background: "linear-gradient(to right, #000, #00f)" }
          }
        )
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "colorspace", children: [
        /* @__PURE__ */ S.jsx("div", { className: "colorspace_title", children: "HSL" }),
        /* @__PURE__ */ S.jsx("div", {}),
        /* @__PURE__ */ S.jsx("label", { children: "Hue" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "360",
            value: i[0],
            onChange: (y) => {
              const b = [parseInt(y.target.value), i[1], i[2]], v = hr("hsl", b);
              o(v), e(v);
            },
            style: {
              background: "linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)"
            }
          }
        ),
        /* @__PURE__ */ S.jsx("label", { children: "Saturation" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "100",
            value: i[1],
            onChange: (y) => {
              const b = [i[0], parseInt(y.target.value), i[2]], v = hr("hsl", b);
              o(v), e(v);
            },
            style: {
              background: `linear-gradient(to right, #fff, hsl(${i[0]}, 100%, 50%))`
            }
          }
        ),
        /* @__PURE__ */ S.jsx("label", { children: "Lightness" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "100",
            value: i[2],
            onChange: (y) => {
              const b = [i[0], i[1], parseInt(y.target.value)], v = hr("hsl", b);
              o(v), e(v);
            },
            style: {
              background: `linear-gradient(to right, #000, hsl(${i[0]}, 100%, 50%), #fff)`
            }
          }
        )
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "colorspace", children: [
        /* @__PURE__ */ S.jsx("div", { className: "colorspace_title", children: "HSV" }),
        /* @__PURE__ */ S.jsx("div", {}),
        /* @__PURE__ */ S.jsx("label", { children: "Hue" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "360",
            value: u[0],
            onChange: (y) => {
              const b = [parseInt(y.target.value), u[1], u[2]], v = hr("hsv", b);
              o(v), e(v);
            },
            style: {
              background: "linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)"
            }
          }
        ),
        /* @__PURE__ */ S.jsx("label", { children: "Saturation" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "100",
            value: u[1],
            onChange: (y) => {
              const b = [u[0], parseInt(y.target.value), u[2]], v = hr("hsv", b);
              o(v), e(v);
            },
            style: {
              background: `linear-gradient(to right, #fff, hsl(${i[0]}, 100%, 50%))`
            }
          }
        ),
        /* @__PURE__ */ S.jsx("label", { children: "Value" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "100",
            value: u[2],
            onChange: (y) => {
              const b = [u[0], u[1], parseInt(y.target.value)], v = hr("hsv", b);
              o(v), e(v);
            },
            style: {
              background: `linear-gradient(to right, #000, hsl(${i[0]}, 100%, 50%))`
            }
          }
        )
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "colorspace", children: [
        /* @__PURE__ */ S.jsx("div", { className: "colorspace_title", children: "HEX" }),
        /* @__PURE__ */ S.jsx("div", {}),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "text",
            value: p,
            onChange: (y) => {
              const b = y.target.value === "" ? null : hr("hex", [y.target.value]);
              o(b), e(b);
            }
          }
        )
      ] })
    ] });
  }, rae = ({
    inicolordata: e,
    inicolorspace: t,
    allow_null: n = !1,
    delay: r = 1e3,
    onChange: o,
    portalContainer: i
  }) => {
    const a = e !== void 0 ? e : [0, 0, 0], s = e === void 0 ? "rgb" : t || "hex", l = Array.isArray(a) ? a : [a], u = T.useMemo(() => {
      let b = hr(s, l);
      return b.rgb() === void 0 && (b = hr("rgb", [0, 0, 0])), b;
    }, [s, l]), [d, p] = T.useState(u);
    T.useEffect(() => {
      const b = e !== void 0 ? e : [0, 0, 0], v = e === void 0 ? "rgb" : t || "hex", x = Array.isArray(b) ? b : [b];
      let E = hr(v, x);
      E.rgb() === void 0 && (E = hr("rgb", [0, 0, 0])), p(E);
    }, [JSON.stringify(e), t]);
    const h = T.useRef(null), g = T.useCallback(
      (b) => {
        if (b === null && !n)
          throw new Error("Color is null");
        b !== null && p(b), h.current && clearTimeout(h.current), o && (h.current = setTimeout(() => {
          o(b), h.current = null;
        }, r));
      },
      [n, o, r]
    );
    T.useEffect(() => () => {
      h.current && clearTimeout(h.current);
    }, []);
    const y = T.useMemo(
      () => ({
        background: "#" + d.hex(),
        borderRadius: "0.3rem",
        width: "2rem",
        height: "1rem"
      }),
      [d]
    );
    return /* @__PURE__ */ S.jsxs(zz, { children: [
      /* @__PURE__ */ S.jsx(Bz, { asChild: !0, children: /* @__PURE__ */ S.jsx("button", { style: y }) }),
      /* @__PURE__ */ S.jsx(Uz, { container: i, children: /* @__PURE__ */ S.jsx(Vz, { side: "left", className: "iotooltipcontent", children: /* @__PURE__ */ S.jsx(
        nae,
        {
          onChange: g,
          colorconverter: d,
          allow_null: n
        }
      ) }) })
    ] });
  };
  function ac(e) {
    "@babel/helpers - typeof";
    return ac = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
      return typeof t;
    } : function(t) {
      return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
    }, ac(e);
  }
  function oae(e, t) {
    if (ac(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
      var r = n.call(e, t);
      if (ac(r) != "object") return r;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (t === "string" ? String : Number)(e);
  }
  function qz(e) {
    var t = oae(e, "string");
    return ac(t) == "symbol" ? t : t + "";
  }
  function mp(e, t, n) {
    return (t = qz(t)) in e ? Object.defineProperty(e, t, {
      value: n,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[t] = n, e;
  }
  function s2(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var r = Object.getOwnPropertySymbols(e);
      t && (r = r.filter(function(o) {
        return Object.getOwnPropertyDescriptor(e, o).enumerable;
      })), n.push.apply(n, r);
    }
    return n;
  }
  function Ye(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t] != null ? arguments[t] : {};
      t % 2 ? s2(Object(n), !0).forEach(function(r) {
        mp(e, r, n[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : s2(Object(n)).forEach(function(r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
      });
    }
    return e;
  }
  function iae(e) {
    if (Array.isArray(e)) return e;
  }
  function aae(e, t) {
    var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n != null) {
      var r, o, i, a, s = [], l = !0, u = !1;
      try {
        if (i = (n = n.call(e)).next, t === 0) {
          if (Object(n) !== n) return;
          l = !1;
        } else for (; !(l = (r = i.call(n)).done) && (s.push(r.value), s.length !== t); l = !0) ;
      } catch (d) {
        u = !0, o = d;
      } finally {
        try {
          if (!l && n.return != null && (a = n.return(), Object(a) !== a)) return;
        } finally {
          if (u) throw o;
        }
      }
      return s;
    }
  }
  function FE(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
    return r;
  }
  function Wz(e, t) {
    if (e) {
      if (typeof e == "string") return FE(e, t);
      var n = {}.toString.call(e).slice(8, -1);
      return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? FE(e, t) : void 0;
    }
  }
  function sae() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function Pa(e, t) {
    return iae(e) || aae(e, t) || Wz(e, t) || sae();
  }
  function Ka(e, t) {
    if (e == null) return {};
    var n, r, o = sb(e, t);
    if (Object.getOwnPropertySymbols) {
      var i = Object.getOwnPropertySymbols(e);
      for (r = 0; r < i.length; r++) n = i[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
    }
    return o;
  }
  var lae = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
  function cae(e) {
    var t = e.defaultInputValue, n = t === void 0 ? "" : t, r = e.defaultMenuIsOpen, o = r === void 0 ? !1 : r, i = e.defaultValue, a = i === void 0 ? null : i, s = e.inputValue, l = e.menuIsOpen, u = e.onChange, d = e.onInputChange, p = e.onMenuClose, h = e.onMenuOpen, g = e.value, y = Ka(e, lae), b = T.useState(s !== void 0 ? s : n), v = Pa(b, 2), x = v[0], E = v[1], _ = T.useState(l !== void 0 ? l : o), C = Pa(_, 2), k = C[0], R = C[1], A = T.useState(g !== void 0 ? g : a), M = Pa(A, 2), I = M[0], D = M[1], L = T.useCallback(function(W, K) {
      typeof u == "function" && u(W, K), D(W);
    }, [u]), P = T.useCallback(function(W, K) {
      var $;
      typeof d == "function" && ($ = d(W, K)), E($ !== void 0 ? $ : W);
    }, [d]), B = T.useCallback(function() {
      typeof h == "function" && h(), R(!0);
    }, [h]), j = T.useCallback(function() {
      typeof p == "function" && p(), R(!1);
    }, [p]), V = s !== void 0 ? s : x, F = l !== void 0 ? l : k, G = g !== void 0 ? g : I;
    return Ye(Ye({}, y), {}, {
      inputValue: V,
      menuIsOpen: F,
      onChange: L,
      onInputChange: P,
      onMenuClose: j,
      onMenuOpen: B,
      value: G
    });
  }
  function uae(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
  }
  function l2(e, t) {
    for (var n = 0; n < t.length; n++) {
      var r = t[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, qz(r.key), r);
    }
  }
  function fae(e, t, n) {
    return t && l2(e.prototype, t), n && l2(e, n), Object.defineProperty(e, "prototype", {
      writable: !1
    }), e;
  }
  function dae(e, t) {
    if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e,
        writable: !0,
        configurable: !0
      }
    }), Object.defineProperty(e, "prototype", {
      writable: !1
    }), t && Uv(e, t);
  }
  function t0(e) {
    return t0 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    }, t0(e);
  }
  function Gz() {
    try {
      var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (Gz = function() {
      return !!e;
    })();
  }
  function pae(e, t) {
    if (t && (ac(t) == "object" || typeof t == "function")) return t;
    if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return pF(e);
  }
  function hae(e) {
    var t = Gz();
    return function() {
      var n, r = t0(e);
      if (t) {
        var o = t0(this).constructor;
        n = Reflect.construct(r, arguments, o);
      } else n = r.apply(this, arguments);
      return pae(this, n);
    };
  }
  function mae(e) {
    if (Array.isArray(e)) return FE(e);
  }
  function gae(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
  }
  function yae() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function nT(e) {
    return mae(e) || gae(e) || Wz(e) || yae();
  }
  function vae(e, t) {
    return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {
      raw: {
        value: Object.freeze(t)
      }
    }));
  }
  var LE = T.useLayoutEffect, bae = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"], n0 = function() {
  };
  function xae(e, t) {
    return t ? t[0] === "-" ? e + t : e + "__" + t : e;
  }
  function wae(e, t) {
    for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++)
      r[o - 2] = arguments[o];
    var i = [].concat(r);
    if (t && e)
      for (var a in t)
        t.hasOwnProperty(a) && t[a] && i.push("".concat(xae(e, a)));
    return i.filter(function(s) {
      return s;
    }).map(function(s) {
      return String(s).trim();
    }).join(" ");
  }
  var c2 = function(t) {
    return Aae(t) ? t.filter(Boolean) : ac(t) === "object" && t !== null ? [t] : [];
  }, Kz = function(t) {
    t.className, t.clearValue, t.cx, t.getStyles, t.getClassNames, t.getValue, t.hasValue, t.isMulti, t.isRtl, t.options, t.selectOption, t.selectProps, t.setValue, t.theme;
    var n = Ka(t, bae);
    return Ye({}, n);
  }, Rn = function(t, n, r) {
    var o = t.cx, i = t.getStyles, a = t.getClassNames, s = t.className;
    return {
      css: i(n, t),
      className: o(r ?? {}, a(n, t), s)
    };
  };
  function Cb(e) {
    return [document.documentElement, document.body, window].indexOf(e) > -1;
  }
  function Sae(e) {
    return Cb(e) ? window.innerHeight : e.clientHeight;
  }
  function Yz(e) {
    return Cb(e) ? window.pageYOffset : e.scrollTop;
  }
  function r0(e, t) {
    if (Cb(e)) {
      window.scrollTo(0, t);
      return;
    }
    e.scrollTop = t;
  }
  function _ae(e) {
    var t = getComputedStyle(e), n = t.position === "absolute", r = /(auto|scroll)/;
    if (t.position === "fixed") return document.documentElement;
    for (var o = e; o = o.parentElement; )
      if (t = getComputedStyle(o), !(n && t.position === "static") && r.test(t.overflow + t.overflowY + t.overflowX))
        return o;
    return document.documentElement;
  }
  function Eae(e, t, n, r) {
    return n * ((e = e / r - 1) * e * e + 1) + t;
  }
  function qg(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : n0, o = Yz(e), i = t - o, a = 10, s = 0;
    function l() {
      s += a;
      var u = Eae(s, o, i, n);
      r0(e, u), s < n ? window.requestAnimationFrame(l) : r(e);
    }
    l();
  }
  function u2(e, t) {
    var n = e.getBoundingClientRect(), r = t.getBoundingClientRect(), o = t.offsetHeight / 3;
    r.bottom + o > n.bottom ? r0(e, Math.min(t.offsetTop + t.clientHeight - e.offsetHeight + o, e.scrollHeight)) : r.top - o < n.top && r0(e, Math.max(t.offsetTop - o, 0));
  }
  function Cae(e) {
    var t = e.getBoundingClientRect();
    return {
      bottom: t.bottom,
      height: t.height,
      left: t.left,
      right: t.right,
      top: t.top,
      width: t.width
    };
  }
  function f2() {
    try {
      return document.createEvent("TouchEvent"), !0;
    } catch {
      return !1;
    }
  }
  function kae() {
    try {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    } catch {
      return !1;
    }
  }
  var Xz = !1, Tae = {
    get passive() {
      return Xz = !0;
    }
  }, Wg = typeof window < "u" ? window : {};
  Wg.addEventListener && Wg.removeEventListener && (Wg.addEventListener("p", n0, Tae), Wg.removeEventListener("p", n0, !1));
  var Rae = Xz;
  function Oae(e) {
    return e != null;
  }
  function Aae(e) {
    return Array.isArray(e);
  }
  function Gg(e, t, n) {
    return e ? t : n;
  }
  var Nae = function(t) {
    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)
      r[o - 1] = arguments[o];
    var i = Object.entries(t).filter(function(a) {
      var s = Pa(a, 1), l = s[0];
      return !r.includes(l);
    });
    return i.reduce(function(a, s) {
      var l = Pa(s, 2), u = l[0], d = l[1];
      return a[u] = d, a;
    }, {});
  }, Mae = ["children", "innerProps"], Pae = ["children", "innerProps"];
  function $ae(e) {
    var t = e.maxHeight, n = e.menuEl, r = e.minHeight, o = e.placement, i = e.shouldScroll, a = e.isFixedPosition, s = e.controlHeight, l = _ae(n), u = {
      placement: "bottom",
      maxHeight: t
    };
    if (!n || !n.offsetParent) return u;
    var d = l.getBoundingClientRect(), p = d.height, h = n.getBoundingClientRect(), g = h.bottom, y = h.height, b = h.top, v = n.offsetParent.getBoundingClientRect(), x = v.top, E = a ? window.innerHeight : Sae(l), _ = Yz(l), C = parseInt(getComputedStyle(n).marginBottom, 10), k = parseInt(getComputedStyle(n).marginTop, 10), R = x - k, A = E - b, M = R + _, I = p - _ - b, D = g - E + _ + C, L = _ + b - k, P = 160;
    switch (o) {
      case "auto":
      case "bottom":
        if (A >= y)
          return {
            placement: "bottom",
            maxHeight: t
          };
        if (I >= y && !a)
          return i && qg(l, D, P), {
            placement: "bottom",
            maxHeight: t
          };
        if (!a && I >= r || a && A >= r) {
          i && qg(l, D, P);
          var B = a ? A - C : I - C;
          return {
            placement: "bottom",
            maxHeight: B
          };
        }
        if (o === "auto" || a) {
          var j = t, V = a ? R : M;
          return V >= r && (j = Math.min(V - C - s, t)), {
            placement: "top",
            maxHeight: j
          };
        }
        if (o === "bottom")
          return i && r0(l, D), {
            placement: "bottom",
            maxHeight: t
          };
        break;
      case "top":
        if (R >= y)
          return {
            placement: "top",
            maxHeight: t
          };
        if (M >= y && !a)
          return i && qg(l, L, P), {
            placement: "top",
            maxHeight: t
          };
        if (!a && M >= r || a && R >= r) {
          var F = t;
          return (!a && M >= r || a && R >= r) && (F = a ? R - k : M - k), i && qg(l, L, P), {
            placement: "top",
            maxHeight: F
          };
        }
        return {
          placement: "bottom",
          maxHeight: t
        };
      default:
        throw new Error('Invalid placement provided "'.concat(o, '".'));
    }
    return u;
  }
  function Iae(e) {
    var t = {
      bottom: "top",
      top: "bottom"
    };
    return e ? t[e] : "bottom";
  }
  var Zz = function(t) {
    return t === "auto" ? "bottom" : t;
  }, jae = function(t, n) {
    var r, o = t.placement, i = t.theme, a = i.borderRadius, s = i.spacing, l = i.colors;
    return Ye((r = {
      label: "menu"
    }, mp(r, Iae(o), "100%"), mp(r, "position", "absolute"), mp(r, "width", "100%"), mp(r, "zIndex", 1), r), n ? {} : {
      backgroundColor: l.neutral0,
      borderRadius: a,
      boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
      marginBottom: s.menuGutter,
      marginTop: s.menuGutter
    });
  }, Qz = /* @__PURE__ */ T.createContext(null), Dae = function(t) {
    var n = t.children, r = t.minMenuHeight, o = t.maxMenuHeight, i = t.menuPlacement, a = t.menuPosition, s = t.menuShouldScrollIntoView, l = t.theme, u = T.useContext(Qz) || {}, d = u.setPortalPlacement, p = T.useRef(null), h = T.useState(o), g = Pa(h, 2), y = g[0], b = g[1], v = T.useState(null), x = Pa(v, 2), E = x[0], _ = x[1], C = l.spacing.controlHeight;
    return LE(function() {
      var k = p.current;
      if (k) {
        var R = a === "fixed", A = s && !R, M = $ae({
          maxHeight: o,
          menuEl: k,
          minHeight: r,
          placement: i,
          shouldScroll: A,
          isFixedPosition: R,
          controlHeight: C
        });
        b(M.maxHeight), _(M.placement), d?.(M.placement);
      }
    }, [o, i, a, s, r, d, C]), n({
      ref: p,
      placerProps: Ye(Ye({}, t), {}, {
        placement: E || Zz(i),
        maxHeight: y
      })
    });
  }, Fae = function(t) {
    var n = t.children, r = t.innerRef, o = t.innerProps;
    return He("div", Ge({}, Rn(t, "menu", {
      menu: !0
    }), {
      ref: r
    }, o), n);
  }, Lae = Fae, zae = function(t, n) {
    var r = t.maxHeight, o = t.theme.spacing.baseUnit;
    return Ye({
      maxHeight: r,
      overflowY: "auto",
      position: "relative",
      // required for offset[Height, Top] > keyboard scroll
      WebkitOverflowScrolling: "touch"
    }, n ? {} : {
      paddingBottom: o,
      paddingTop: o
    });
  }, Bae = function(t) {
    var n = t.children, r = t.innerProps, o = t.innerRef, i = t.isMulti;
    return He("div", Ge({}, Rn(t, "menuList", {
      "menu-list": !0,
      "menu-list--is-multi": i
    }), {
      ref: o
    }, r), n);
  }, Jz = function(t, n) {
    var r = t.theme, o = r.spacing.baseUnit, i = r.colors;
    return Ye({
      textAlign: "center"
    }, n ? {} : {
      color: i.neutral40,
      padding: "".concat(o * 2, "px ").concat(o * 3, "px")
    });
  }, Uae = Jz, Vae = Jz, Hae = function(t) {
    var n = t.children, r = n === void 0 ? "No options" : n, o = t.innerProps, i = Ka(t, Mae);
    return He("div", Ge({}, Rn(Ye(Ye({}, i), {}, {
      children: r,
      innerProps: o
    }), "noOptionsMessage", {
      "menu-notice": !0,
      "menu-notice--no-options": !0
    }), o), r);
  }, qae = function(t) {
    var n = t.children, r = n === void 0 ? "Loading..." : n, o = t.innerProps, i = Ka(t, Pae);
    return He("div", Ge({}, Rn(Ye(Ye({}, i), {}, {
      children: r,
      innerProps: o
    }), "loadingMessage", {
      "menu-notice": !0,
      "menu-notice--loading": !0
    }), o), r);
  }, Wae = function(t) {
    var n = t.rect, r = t.offset, o = t.position;
    return {
      left: n.left,
      position: o,
      top: r,
      width: n.width,
      zIndex: 1
    };
  }, Gae = function(t) {
    var n = t.appendTo, r = t.children, o = t.controlElement, i = t.innerProps, a = t.menuPlacement, s = t.menuPosition, l = T.useRef(null), u = T.useRef(null), d = T.useState(Zz(a)), p = Pa(d, 2), h = p[0], g = p[1], y = T.useMemo(function() {
      return {
        setPortalPlacement: g
      };
    }, []), b = T.useState(null), v = Pa(b, 2), x = v[0], E = v[1], _ = T.useCallback(function() {
      if (o) {
        var A = Cae(o), M = s === "fixed" ? 0 : window.pageYOffset, I = A[h] + M;
        (I !== x?.offset || A.left !== x?.rect.left || A.width !== x?.rect.width) && E({
          offset: I,
          rect: A
        });
      }
    }, [o, s, h, x?.offset, x?.rect.left, x?.rect.width]);
    LE(function() {
      _();
    }, [_]);
    var C = T.useCallback(function() {
      typeof u.current == "function" && (u.current(), u.current = null), o && l.current && (u.current = hz(o, l.current, _, {
        elementResize: "ResizeObserver" in window
      }));
    }, [o, _]);
    LE(function() {
      C();
    }, [C]);
    var k = T.useCallback(function(A) {
      l.current = A, C();
    }, [C]);
    if (!n && s !== "fixed" || !x) return null;
    var R = He("div", Ge({
      ref: k
    }, Rn(Ye(Ye({}, t), {}, {
      offset: x.offset,
      position: s,
      rect: x.rect
    }), "menuPortal", {
      "menu-portal": !0
    }), i), r);
    return He(Qz.Provider, {
      value: y
    }, n ? /* @__PURE__ */ gc.createPortal(R, n) : R);
  }, Kae = function(t) {
    var n = t.isDisabled, r = t.isRtl;
    return {
      label: "container",
      direction: r ? "rtl" : void 0,
      pointerEvents: n ? "none" : void 0,
      // cancel mouse events when disabled
      position: "relative"
    };
  }, Yae = function(t) {
    var n = t.children, r = t.innerProps, o = t.isDisabled, i = t.isRtl;
    return He("div", Ge({}, Rn(t, "container", {
      "--is-disabled": o,
      "--is-rtl": i
    }), r), n);
  }, Xae = function(t, n) {
    var r = t.theme.spacing, o = t.isMulti, i = t.hasValue, a = t.selectProps.controlShouldRenderValue;
    return Ye({
      alignItems: "center",
      display: o && i && a ? "flex" : "grid",
      flex: 1,
      flexWrap: "wrap",
      WebkitOverflowScrolling: "touch",
      position: "relative",
      overflow: "hidden"
    }, n ? {} : {
      padding: "".concat(r.baseUnit / 2, "px ").concat(r.baseUnit * 2, "px")
    });
  }, Zae = function(t) {
    var n = t.children, r = t.innerProps, o = t.isMulti, i = t.hasValue;
    return He("div", Ge({}, Rn(t, "valueContainer", {
      "value-container": !0,
      "value-container--is-multi": o,
      "value-container--has-value": i
    }), r), n);
  }, Qae = function() {
    return {
      alignItems: "center",
      alignSelf: "stretch",
      display: "flex",
      flexShrink: 0
    };
  }, Jae = function(t) {
    var n = t.children, r = t.innerProps;
    return He("div", Ge({}, Rn(t, "indicatorsContainer", {
      indicators: !0
    }), r), n);
  }, d2, ese = ["size"], tse = ["innerProps", "isRtl", "size"], nse = {
    name: "8mmkcg",
    styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
  }, e6 = function(t) {
    var n = t.size, r = Ka(t, ese);
    return He("svg", Ge({
      height: n,
      width: n,
      viewBox: "0 0 20 20",
      "aria-hidden": "true",
      focusable: "false",
      css: nse
    }, r));
  }, rT = function(t) {
    return He(e6, Ge({
      size: 20
    }, t), He("path", {
      d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
    }));
  }, t6 = function(t) {
    return He(e6, Ge({
      size: 20
    }, t), He("path", {
      d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
    }));
  }, n6 = function(t, n) {
    var r = t.isFocused, o = t.theme, i = o.spacing.baseUnit, a = o.colors;
    return Ye({
      label: "indicatorContainer",
      display: "flex",
      transition: "color 150ms"
    }, n ? {} : {
      color: r ? a.neutral60 : a.neutral20,
      padding: i * 2,
      ":hover": {
        color: r ? a.neutral80 : a.neutral40
      }
    });
  }, rse = n6, ose = function(t) {
    var n = t.children, r = t.innerProps;
    return He("div", Ge({}, Rn(t, "dropdownIndicator", {
      indicator: !0,
      "dropdown-indicator": !0
    }), r), n || He(t6, null));
  }, ise = n6, ase = function(t) {
    var n = t.children, r = t.innerProps;
    return He("div", Ge({}, Rn(t, "clearIndicator", {
      indicator: !0,
      "clear-indicator": !0
    }), r), n || He(rT, null));
  }, sse = function(t, n) {
    var r = t.isDisabled, o = t.theme, i = o.spacing.baseUnit, a = o.colors;
    return Ye({
      label: "indicatorSeparator",
      alignSelf: "stretch",
      width: 1
    }, n ? {} : {
      backgroundColor: r ? a.neutral10 : a.neutral20,
      marginBottom: i * 2,
      marginTop: i * 2
    });
  }, lse = function(t) {
    var n = t.innerProps;
    return He("span", Ge({}, n, Rn(t, "indicatorSeparator", {
      "indicator-separator": !0
    })));
  }, cse = _f(d2 || (d2 = vae([`
  0%, 80%, 100% { opacity: 0; }
  40% { opacity: 1; }
`]))), use = function(t, n) {
    var r = t.isFocused, o = t.size, i = t.theme, a = i.colors, s = i.spacing.baseUnit;
    return Ye({
      label: "loadingIndicator",
      display: "flex",
      transition: "color 150ms",
      alignSelf: "center",
      fontSize: o,
      lineHeight: 1,
      marginRight: o,
      textAlign: "center",
      verticalAlign: "middle"
    }, n ? {} : {
      color: r ? a.neutral60 : a.neutral20,
      padding: s * 2
    });
  }, CS = function(t) {
    var n = t.delay, r = t.offset;
    return He("span", {
      css: /* @__PURE__ */ Ph({
        animation: "".concat(cse, " 1s ease-in-out ").concat(n, "ms infinite;"),
        backgroundColor: "currentColor",
        borderRadius: "1em",
        display: "inline-block",
        marginLeft: r ? "1em" : void 0,
        height: "1em",
        verticalAlign: "top",
        width: "1em"
      }, "", "")
    });
  }, fse = function(t) {
    var n = t.innerProps, r = t.isRtl, o = t.size, i = o === void 0 ? 4 : o, a = Ka(t, tse);
    return He("div", Ge({}, Rn(Ye(Ye({}, a), {}, {
      innerProps: n,
      isRtl: r,
      size: i
    }), "loadingIndicator", {
      indicator: !0,
      "loading-indicator": !0
    }), n), He(CS, {
      delay: 0,
      offset: r
    }), He(CS, {
      delay: 160,
      offset: !0
    }), He(CS, {
      delay: 320,
      offset: !r
    }));
  }, dse = function(t, n) {
    var r = t.isDisabled, o = t.isFocused, i = t.theme, a = i.colors, s = i.borderRadius, l = i.spacing;
    return Ye({
      label: "control",
      alignItems: "center",
      cursor: "default",
      display: "flex",
      flexWrap: "wrap",
      justifyContent: "space-between",
      minHeight: l.controlHeight,
      outline: "0 !important",
      position: "relative",
      transition: "all 100ms"
    }, n ? {} : {
      backgroundColor: r ? a.neutral5 : a.neutral0,
      borderColor: r ? a.neutral10 : o ? a.primary : a.neutral20,
      borderRadius: s,
      borderStyle: "solid",
      borderWidth: 1,
      boxShadow: o ? "0 0 0 1px ".concat(a.primary) : void 0,
      "&:hover": {
        borderColor: o ? a.primary : a.neutral30
      }
    });
  }, pse = function(t) {
    var n = t.children, r = t.isDisabled, o = t.isFocused, i = t.innerRef, a = t.innerProps, s = t.menuIsOpen;
    return He("div", Ge({
      ref: i
    }, Rn(t, "control", {
      control: !0,
      "control--is-disabled": r,
      "control--is-focused": o,
      "control--menu-is-open": s
    }), a, {
      "aria-disabled": r || void 0
    }), n);
  }, hse = pse, mse = ["data"], gse = function(t, n) {
    var r = t.theme.spacing;
    return n ? {} : {
      paddingBottom: r.baseUnit * 2,
      paddingTop: r.baseUnit * 2
    };
  }, yse = function(t) {
    var n = t.children, r = t.cx, o = t.getStyles, i = t.getClassNames, a = t.Heading, s = t.headingProps, l = t.innerProps, u = t.label, d = t.theme, p = t.selectProps;
    return He("div", Ge({}, Rn(t, "group", {
      group: !0
    }), l), He(a, Ge({}, s, {
      selectProps: p,
      theme: d,
      getStyles: o,
      getClassNames: i,
      cx: r
    }), u), He("div", null, n));
  }, vse = function(t, n) {
    var r = t.theme, o = r.colors, i = r.spacing;
    return Ye({
      label: "group",
      cursor: "default",
      display: "block"
    }, n ? {} : {
      color: o.neutral40,
      fontSize: "75%",
      fontWeight: 500,
      marginBottom: "0.25em",
      paddingLeft: i.baseUnit * 3,
      paddingRight: i.baseUnit * 3,
      textTransform: "uppercase"
    });
  }, bse = function(t) {
    var n = Kz(t);
    n.data;
    var r = Ka(n, mse);
    return He("div", Ge({}, Rn(t, "groupHeading", {
      "group-heading": !0
    }), r));
  }, xse = yse, wse = ["innerRef", "isDisabled", "isHidden", "inputClassName"], Sse = function(t, n) {
    var r = t.isDisabled, o = t.value, i = t.theme, a = i.spacing, s = i.colors;
    return Ye(Ye({
      visibility: r ? "hidden" : "visible",
      // force css to recompute when value change due to @emotion bug.
      // We can remove it whenever the bug is fixed.
      transform: o ? "translateZ(0)" : ""
    }, _se), n ? {} : {
      margin: a.baseUnit / 2,
      paddingBottom: a.baseUnit / 2,
      paddingTop: a.baseUnit / 2,
      color: s.neutral80
    });
  }, r6 = {
    gridArea: "1 / 2",
    font: "inherit",
    minWidth: "2px",
    border: 0,
    margin: 0,
    outline: 0,
    padding: 0
  }, _se = {
    flex: "1 1 auto",
    display: "inline-grid",
    gridArea: "1 / 1 / 2 / 3",
    gridTemplateColumns: "0 min-content",
    "&:after": Ye({
      content: 'attr(data-value) " "',
      visibility: "hidden",
      whiteSpace: "pre"
    }, r6)
  }, Ese = function(t) {
    return Ye({
      label: "input",
      color: "inherit",
      background: 0,
      opacity: t ? 0 : 1,
      width: "100%"
    }, r6);
  }, Cse = function(t) {
    var n = t.cx, r = t.value, o = Kz(t), i = o.innerRef, a = o.isDisabled, s = o.isHidden, l = o.inputClassName, u = Ka(o, wse);
    return He("div", Ge({}, Rn(t, "input", {
      "input-container": !0
    }), {
      "data-value": r || ""
    }), He("input", Ge({
      className: n({
        input: !0
      }, l),
      ref: i,
      style: Ese(s),
      disabled: a
    }, u)));
  }, kse = Cse, Tse = function(t, n) {
    var r = t.theme, o = r.spacing, i = r.borderRadius, a = r.colors;
    return Ye({
      label: "multiValue",
      display: "flex",
      minWidth: 0
    }, n ? {} : {
      backgroundColor: a.neutral10,
      borderRadius: i / 2,
      margin: o.baseUnit / 2
    });
  }, Rse = function(t, n) {
    var r = t.theme, o = r.borderRadius, i = r.colors, a = t.cropWithEllipsis;
    return Ye({
      overflow: "hidden",
      textOverflow: a || a === void 0 ? "ellipsis" : void 0,
      whiteSpace: "nowrap"
    }, n ? {} : {
      borderRadius: o / 2,
      color: i.neutral80,
      fontSize: "85%",
      padding: 3,
      paddingLeft: 6
    });
  }, Ose = function(t, n) {
    var r = t.theme, o = r.spacing, i = r.borderRadius, a = r.colors, s = t.isFocused;
    return Ye({
      alignItems: "center",
      display: "flex"
    }, n ? {} : {
      borderRadius: i / 2,
      backgroundColor: s ? a.dangerLight : void 0,
      paddingLeft: o.baseUnit,
      paddingRight: o.baseUnit,
      ":hover": {
        backgroundColor: a.dangerLight,
        color: a.danger
      }
    });
  }, o6 = function(t) {
    var n = t.children, r = t.innerProps;
    return He("div", r, n);
  }, Ase = o6, Nse = o6;
  function Mse(e) {
    var t = e.children, n = e.innerProps;
    return He("div", Ge({
      role: "button"
    }, n), t || He(rT, {
      size: 14
    }));
  }
  var Pse = function(t) {
    var n = t.children, r = t.components, o = t.data, i = t.innerProps, a = t.isDisabled, s = t.removeProps, l = t.selectProps, u = r.Container, d = r.Label, p = r.Remove;
    return He(u, {
      data: o,
      innerProps: Ye(Ye({}, Rn(t, "multiValue", {
        "multi-value": !0,
        "multi-value--is-disabled": a
      })), i),
      selectProps: l
    }, He(d, {
      data: o,
      innerProps: Ye({}, Rn(t, "multiValueLabel", {
        "multi-value__label": !0
      })),
      selectProps: l
    }, n), He(p, {
      data: o,
      innerProps: Ye(Ye({}, Rn(t, "multiValueRemove", {
        "multi-value__remove": !0
      })), {}, {
        "aria-label": "Remove ".concat(n || "option")
      }, s),
      selectProps: l
    }));
  }, $se = Pse, Ise = function(t, n) {
    var r = t.isDisabled, o = t.isFocused, i = t.isSelected, a = t.theme, s = a.spacing, l = a.colors;
    return Ye({
      label: "option",
      cursor: "default",
      display: "block",
      fontSize: "inherit",
      width: "100%",
      userSelect: "none",
      WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
    }, n ? {} : {
      backgroundColor: i ? l.primary : o ? l.primary25 : "transparent",
      color: r ? l.neutral20 : i ? l.neutral0 : "inherit",
      padding: "".concat(s.baseUnit * 2, "px ").concat(s.baseUnit * 3, "px"),
      // provide some affordance on touch devices
      ":active": {
        backgroundColor: r ? void 0 : i ? l.primary : l.primary50
      }
    });
  }, jse = function(t) {
    var n = t.children, r = t.isDisabled, o = t.isFocused, i = t.isSelected, a = t.innerRef, s = t.innerProps;
    return He("div", Ge({}, Rn(t, "option", {
      option: !0,
      "option--is-disabled": r,
      "option--is-focused": o,
      "option--is-selected": i
    }), {
      ref: a,
      "aria-disabled": r
    }, s), n);
  }, Dse = jse, Fse = function(t, n) {
    var r = t.theme, o = r.spacing, i = r.colors;
    return Ye({
      label: "placeholder",
      gridArea: "1 / 1 / 2 / 3"
    }, n ? {} : {
      color: i.neutral50,
      marginLeft: o.baseUnit / 2,
      marginRight: o.baseUnit / 2
    });
  }, Lse = function(t) {
    var n = t.children, r = t.innerProps;
    return He("div", Ge({}, Rn(t, "placeholder", {
      placeholder: !0
    }), r), n);
  }, zse = Lse, Bse = function(t, n) {
    var r = t.isDisabled, o = t.theme, i = o.spacing, a = o.colors;
    return Ye({
      label: "singleValue",
      gridArea: "1 / 1 / 2 / 3",
      maxWidth: "100%",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    }, n ? {} : {
      color: r ? a.neutral40 : a.neutral80,
      marginLeft: i.baseUnit / 2,
      marginRight: i.baseUnit / 2
    });
  }, Use = function(t) {
    var n = t.children, r = t.isDisabled, o = t.innerProps;
    return He("div", Ge({}, Rn(t, "singleValue", {
      "single-value": !0,
      "single-value--is-disabled": r
    }), o), n);
  }, Vse = Use, Hse = {
    ClearIndicator: ase,
    Control: hse,
    DropdownIndicator: ose,
    DownChevron: t6,
    CrossIcon: rT,
    Group: xse,
    GroupHeading: bse,
    IndicatorsContainer: Jae,
    IndicatorSeparator: lse,
    Input: kse,
    LoadingIndicator: fse,
    Menu: Lae,
    MenuList: Bae,
    MenuPortal: Gae,
    LoadingMessage: qae,
    NoOptionsMessage: Hae,
    MultiValue: $se,
    MultiValueContainer: Ase,
    MultiValueLabel: Nse,
    MultiValueRemove: Mse,
    Option: Dse,
    Placeholder: zse,
    SelectContainer: Yae,
    SingleValue: Vse,
    ValueContainer: Zae
  }, qse = function(t) {
    return Ye(Ye({}, Hse), t.components);
  }, p2 = Number.isNaN || function(t) {
    return typeof t == "number" && t !== t;
  };
  function Wse(e, t) {
    return !!(e === t || p2(e) && p2(t));
  }
  function Gse(e, t) {
    if (e.length !== t.length)
      return !1;
    for (var n = 0; n < e.length; n++)
      if (!Wse(e[n], t[n]))
        return !1;
    return !0;
  }
  function Kse(e, t) {
    t === void 0 && (t = Gse);
    var n = null;
    function r() {
      for (var o = [], i = 0; i < arguments.length; i++)
        o[i] = arguments[i];
      if (n && n.lastThis === this && t(o, n.lastArgs))
        return n.lastResult;
      var a = e.apply(this, o);
      return n = {
        lastResult: a,
        lastArgs: o,
        lastThis: this
      }, a;
    }
    return r.clear = function() {
      n = null;
    }, r;
  }
  var Yse = {
    name: "7pg0cj-a11yText",
    styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
  }, Xse = function(t) {
    return He("span", Ge({
      css: Yse
    }, t));
  }, h2 = Xse, Zse = {
    guidance: function(t) {
      var n = t.isSearchable, r = t.isMulti, o = t.tabSelectsValue, i = t.context, a = t.isInitialFocus;
      switch (i) {
        case "menu":
          return "Use Up and Down to choose options, press Enter to select the currently focused option, press Escape to exit the menu".concat(o ? ", press Tab to select the option and exit the menu" : "", ".");
        case "input":
          return a ? "".concat(t["aria-label"] || "Select", " is focused ").concat(n ? ",type to refine list" : "", ", press Down to open the menu, ").concat(r ? " press left to focus selected values" : "") : "";
        case "value":
          return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
        default:
          return "";
      }
    },
    onChange: function(t) {
      var n = t.action, r = t.label, o = r === void 0 ? "" : r, i = t.labels, a = t.isDisabled;
      switch (n) {
        case "deselect-option":
        case "pop-value":
        case "remove-value":
          return "option ".concat(o, ", deselected.");
        case "clear":
          return "All selected options have been cleared.";
        case "initial-input-focus":
          return "option".concat(i.length > 1 ? "s" : "", " ").concat(i.join(","), ", selected.");
        case "select-option":
          return a ? "option ".concat(o, " is disabled. Select another option.") : "option ".concat(o, ", selected.");
        default:
          return "";
      }
    },
    onFocus: function(t) {
      var n = t.context, r = t.focused, o = t.options, i = t.label, a = i === void 0 ? "" : i, s = t.selectValue, l = t.isDisabled, u = t.isSelected, d = t.isAppleDevice, p = function(b, v) {
        return b && b.length ? "".concat(b.indexOf(v) + 1, " of ").concat(b.length) : "";
      };
      if (n === "value" && s)
        return "value ".concat(a, " focused, ").concat(p(s, r), ".");
      if (n === "menu" && d) {
        var h = l ? " disabled" : "", g = "".concat(u ? " selected" : "").concat(h);
        return "".concat(a).concat(g, ", ").concat(p(o, r), ".");
      }
      return "";
    },
    onFilter: function(t) {
      var n = t.inputValue, r = t.resultsMessage;
      return "".concat(r).concat(n ? " for search term " + n : "", ".");
    }
  }, Qse = function(t) {
    var n = t.ariaSelection, r = t.focusedOption, o = t.focusedValue, i = t.focusableOptions, a = t.isFocused, s = t.selectValue, l = t.selectProps, u = t.id, d = t.isAppleDevice, p = l.ariaLiveMessages, h = l.getOptionLabel, g = l.inputValue, y = l.isMulti, b = l.isOptionDisabled, v = l.isSearchable, x = l.menuIsOpen, E = l.options, _ = l.screenReaderStatus, C = l.tabSelectsValue, k = l.isLoading, R = l["aria-label"], A = l["aria-live"], M = T.useMemo(function() {
      return Ye(Ye({}, Zse), p || {});
    }, [p]), I = T.useMemo(function() {
      var V = "";
      if (n && M.onChange) {
        var F = n.option, G = n.options, W = n.removedValue, K = n.removedValues, $ = n.value, U = function(te) {
          return Array.isArray(te) ? null : te;
        }, X = W || F || U($), z = X ? h(X) : "", H = G || K || void 0, Y = H ? H.map(h) : [], Q = Ye({
          // multiSelected items are usually items that have already been selected
          // or set by the user as a default value so we assume they are not disabled
          isDisabled: X && b(X, s),
          label: z,
          labels: Y
        }, n);
        V = M.onChange(Q);
      }
      return V;
    }, [n, M, b, s, h]), D = T.useMemo(function() {
      var V = "", F = r || o, G = !!(r && s && s.includes(r));
      if (F && M.onFocus) {
        var W = {
          focused: F,
          label: h(F),
          isDisabled: b(F, s),
          isSelected: G,
          options: i,
          context: F === r ? "menu" : "value",
          selectValue: s,
          isAppleDevice: d
        };
        V = M.onFocus(W);
      }
      return V;
    }, [r, o, h, b, M, i, s, d]), L = T.useMemo(function() {
      var V = "";
      if (x && E.length && !k && M.onFilter) {
        var F = _({
          count: i.length
        });
        V = M.onFilter({
          inputValue: g,
          resultsMessage: F
        });
      }
      return V;
    }, [i, g, x, M, E, _, k]), P = n?.action === "initial-input-focus", B = T.useMemo(function() {
      var V = "";
      if (M.guidance) {
        var F = o ? "value" : x ? "menu" : "input";
        V = M.guidance({
          "aria-label": R,
          context: F,
          isDisabled: r && b(r, s),
          isMulti: y,
          isSearchable: v,
          tabSelectsValue: C,
          isInitialFocus: P
        });
      }
      return V;
    }, [R, r, o, y, b, v, x, M, s, C, P]), j = He(T.Fragment, null, He("span", {
      id: "aria-selection"
    }, I), He("span", {
      id: "aria-focused"
    }, D), He("span", {
      id: "aria-results"
    }, L), He("span", {
      id: "aria-guidance"
    }, B));
    return He(T.Fragment, null, He(h2, {
      id: u
    }, P && j), He(h2, {
      "aria-live": A,
      "aria-atomic": "false",
      "aria-relevant": "additions text",
      role: "log"
    }, a && !P && j));
  }, Jse = Qse, zE = [{
    base: "A",
    letters: "A"
  }, {
    base: "AA",
    letters: ""
  }, {
    base: "AE",
    letters: ""
  }, {
    base: "AO",
    letters: ""
  }, {
    base: "AU",
    letters: ""
  }, {
    base: "AV",
    letters: ""
  }, {
    base: "AY",
    letters: ""
  }, {
    base: "B",
    letters: "B"
  }, {
    base: "C",
    letters: "C"
  }, {
    base: "D",
    letters: "D"
  }, {
    base: "DZ",
    letters: ""
  }, {
    base: "Dz",
    letters: ""
  }, {
    base: "E",
    letters: "E"
  }, {
    base: "F",
    letters: "F"
  }, {
    base: "G",
    letters: "G"
  }, {
    base: "H",
    letters: "H"
  }, {
    base: "I",
    letters: "I"
  }, {
    base: "J",
    letters: "J"
  }, {
    base: "K",
    letters: "K"
  }, {
    base: "L",
    letters: "L"
  }, {
    base: "LJ",
    letters: ""
  }, {
    base: "Lj",
    letters: ""
  }, {
    base: "M",
    letters: "M"
  }, {
    base: "N",
    letters: "N"
  }, {
    base: "NJ",
    letters: ""
  }, {
    base: "Nj",
    letters: ""
  }, {
    base: "O",
    letters: "O"
  }, {
    base: "OI",
    letters: ""
  }, {
    base: "OO",
    letters: ""
  }, {
    base: "OU",
    letters: ""
  }, {
    base: "P",
    letters: "P"
  }, {
    base: "Q",
    letters: "Q"
  }, {
    base: "R",
    letters: "R"
  }, {
    base: "S",
    letters: "S"
  }, {
    base: "T",
    letters: "T"
  }, {
    base: "TZ",
    letters: ""
  }, {
    base: "U",
    letters: "U"
  }, {
    base: "V",
    letters: "V"
  }, {
    base: "VY",
    letters: ""
  }, {
    base: "W",
    letters: "W"
  }, {
    base: "X",
    letters: "X"
  }, {
    base: "Y",
    letters: "Y"
  }, {
    base: "Z",
    letters: "Z"
  }, {
    base: "a",
    letters: "a"
  }, {
    base: "aa",
    letters: ""
  }, {
    base: "ae",
    letters: ""
  }, {
    base: "ao",
    letters: ""
  }, {
    base: "au",
    letters: ""
  }, {
    base: "av",
    letters: ""
  }, {
    base: "ay",
    letters: ""
  }, {
    base: "b",
    letters: "b"
  }, {
    base: "c",
    letters: "c"
  }, {
    base: "d",
    letters: "d"
  }, {
    base: "dz",
    letters: ""
  }, {
    base: "e",
    letters: "e"
  }, {
    base: "f",
    letters: "f"
  }, {
    base: "g",
    letters: "g"
  }, {
    base: "h",
    letters: "h"
  }, {
    base: "hv",
    letters: ""
  }, {
    base: "i",
    letters: "i"
  }, {
    base: "j",
    letters: "j"
  }, {
    base: "k",
    letters: "k"
  }, {
    base: "l",
    letters: "l"
  }, {
    base: "lj",
    letters: ""
  }, {
    base: "m",
    letters: "m"
  }, {
    base: "n",
    letters: "n"
  }, {
    base: "nj",
    letters: ""
  }, {
    base: "o",
    letters: "o"
  }, {
    base: "oi",
    letters: ""
  }, {
    base: "ou",
    letters: ""
  }, {
    base: "oo",
    letters: ""
  }, {
    base: "p",
    letters: "p"
  }, {
    base: "q",
    letters: "q"
  }, {
    base: "r",
    letters: "r"
  }, {
    base: "s",
    letters: "s"
  }, {
    base: "t",
    letters: "t"
  }, {
    base: "tz",
    letters: ""
  }, {
    base: "u",
    letters: "u"
  }, {
    base: "v",
    letters: "v"
  }, {
    base: "vy",
    letters: ""
  }, {
    base: "w",
    letters: "w"
  }, {
    base: "x",
    letters: "x"
  }, {
    base: "y",
    letters: "y"
  }, {
    base: "z",
    letters: "z"
  }], ele = new RegExp("[" + zE.map(function(e) {
    return e.letters;
  }).join("") + "]", "g"), i6 = {};
  for (var kS = 0; kS < zE.length; kS++)
    for (var TS = zE[kS], RS = 0; RS < TS.letters.length; RS++)
      i6[TS.letters[RS]] = TS.base;
  var a6 = function(t) {
    return t.replace(ele, function(n) {
      return i6[n];
    });
  }, tle = Kse(a6), m2 = function(t) {
    return t.replace(/^\s+|\s+$/g, "");
  }, nle = function(t) {
    return "".concat(t.label, " ").concat(t.value);
  }, rle = function(t) {
    return function(n, r) {
      if (n.data.__isNew__) return !0;
      var o = Ye({
        ignoreCase: !0,
        ignoreAccents: !0,
        stringify: nle,
        trim: !0,
        matchFrom: "any"
      }, t), i = o.ignoreCase, a = o.ignoreAccents, s = o.stringify, l = o.trim, u = o.matchFrom, d = l ? m2(r) : r, p = l ? m2(s(n)) : s(n);
      return i && (d = d.toLowerCase(), p = p.toLowerCase()), a && (d = tle(d), p = a6(p)), u === "start" ? p.substr(0, d.length) === d : p.indexOf(d) > -1;
    };
  }, ole = ["innerRef"];
  function ile(e) {
    var t = e.innerRef, n = Ka(e, ole), r = Nae(n, "onExited", "in", "enter", "exit", "appear");
    return He("input", Ge({
      ref: t
    }, r, {
      css: /* @__PURE__ */ Ph({
        label: "dummyInput",
        // get rid of any default styles
        background: 0,
        border: 0,
        // important! this hides the flashing cursor
        caretColor: "transparent",
        fontSize: "inherit",
        gridArea: "1 / 1 / 2 / 3",
        outline: 0,
        padding: 0,
        // important! without `width` browsers won't allow focus
        width: 1,
        // remove cursor on desktop
        color: "transparent",
        // remove cursor on mobile whilst maintaining "scroll into view" behaviour
        left: -100,
        opacity: 0,
        position: "relative",
        transform: "scale(.01)"
      }, "", "")
    }));
  }
  var ale = function(t) {
    t.cancelable && t.preventDefault(), t.stopPropagation();
  };
  function sle(e) {
    var t = e.isEnabled, n = e.onBottomArrive, r = e.onBottomLeave, o = e.onTopArrive, i = e.onTopLeave, a = T.useRef(!1), s = T.useRef(!1), l = T.useRef(0), u = T.useRef(null), d = T.useCallback(function(v, x) {
      if (u.current !== null) {
        var E = u.current, _ = E.scrollTop, C = E.scrollHeight, k = E.clientHeight, R = u.current, A = x > 0, M = C - k - _, I = !1;
        M > x && a.current && (r && r(v), a.current = !1), A && s.current && (i && i(v), s.current = !1), A && x > M ? (n && !a.current && n(v), R.scrollTop = C, I = !0, a.current = !0) : !A && -x > _ && (o && !s.current && o(v), R.scrollTop = 0, I = !0, s.current = !0), I && ale(v);
      }
    }, [n, r, o, i]), p = T.useCallback(function(v) {
      d(v, v.deltaY);
    }, [d]), h = T.useCallback(function(v) {
      l.current = v.changedTouches[0].clientY;
    }, []), g = T.useCallback(function(v) {
      var x = l.current - v.changedTouches[0].clientY;
      d(v, x);
    }, [d]), y = T.useCallback(function(v) {
      if (v) {
        var x = Rae ? {
          passive: !1
        } : !1;
        v.addEventListener("wheel", p, x), v.addEventListener("touchstart", h, x), v.addEventListener("touchmove", g, x);
      }
    }, [g, h, p]), b = T.useCallback(function(v) {
      v && (v.removeEventListener("wheel", p, !1), v.removeEventListener("touchstart", h, !1), v.removeEventListener("touchmove", g, !1));
    }, [g, h, p]);
    return T.useEffect(function() {
      if (t) {
        var v = u.current;
        return y(v), function() {
          b(v);
        };
      }
    }, [t, y, b]), function(v) {
      u.current = v;
    };
  }
  var g2 = ["boxSizing", "height", "overflow", "paddingRight", "position"], y2 = {
    boxSizing: "border-box",
    // account for possible declaration `width: 100%;` on body
    overflow: "hidden",
    position: "relative",
    height: "100%"
  };
  function v2(e) {
    e.cancelable && e.preventDefault();
  }
  function b2(e) {
    e.stopPropagation();
  }
  function x2() {
    var e = this.scrollTop, t = this.scrollHeight, n = e + this.offsetHeight;
    e === 0 ? this.scrollTop = 1 : n === t && (this.scrollTop = e - 1);
  }
  function w2() {
    return "ontouchstart" in window || navigator.maxTouchPoints;
  }
  var S2 = !!(typeof window < "u" && window.document && window.document.createElement), qd = 0, Su = {
    capture: !1,
    passive: !1
  };
  function lle(e) {
    var t = e.isEnabled, n = e.accountForScrollbars, r = n === void 0 ? !0 : n, o = T.useRef({}), i = T.useRef(null), a = T.useCallback(function(l) {
      if (S2) {
        var u = document.body, d = u && u.style;
        if (r && g2.forEach(function(y) {
          var b = d && d[y];
          o.current[y] = b;
        }), r && qd < 1) {
          var p = parseInt(o.current.paddingRight, 10) || 0, h = document.body ? document.body.clientWidth : 0, g = window.innerWidth - h + p || 0;
          Object.keys(y2).forEach(function(y) {
            var b = y2[y];
            d && (d[y] = b);
          }), d && (d.paddingRight = "".concat(g, "px"));
        }
        u && w2() && (u.addEventListener("touchmove", v2, Su), l && (l.addEventListener("touchstart", x2, Su), l.addEventListener("touchmove", b2, Su))), qd += 1;
      }
    }, [r]), s = T.useCallback(function(l) {
      if (S2) {
        var u = document.body, d = u && u.style;
        qd = Math.max(qd - 1, 0), r && qd < 1 && g2.forEach(function(p) {
          var h = o.current[p];
          d && (d[p] = h);
        }), u && w2() && (u.removeEventListener("touchmove", v2, Su), l && (l.removeEventListener("touchstart", x2, Su), l.removeEventListener("touchmove", b2, Su)));
      }
    }, [r]);
    return T.useEffect(function() {
      if (t) {
        var l = i.current;
        return a(l), function() {
          s(l);
        };
      }
    }, [t, a, s]), function(l) {
      i.current = l;
    };
  }
  var cle = function(t) {
    var n = t.target;
    return n.ownerDocument.activeElement && n.ownerDocument.activeElement.blur();
  }, ule = {
    name: "1kfdb0e",
    styles: "position:fixed;left:0;bottom:0;right:0;top:0"
  };
  function fle(e) {
    var t = e.children, n = e.lockEnabled, r = e.captureEnabled, o = r === void 0 ? !0 : r, i = e.onBottomArrive, a = e.onBottomLeave, s = e.onTopArrive, l = e.onTopLeave, u = sle({
      isEnabled: o,
      onBottomArrive: i,
      onBottomLeave: a,
      onTopArrive: s,
      onTopLeave: l
    }), d = lle({
      isEnabled: n
    }), p = function(g) {
      u(g), d(g);
    };
    return He(T.Fragment, null, n && He("div", {
      onClick: cle,
      css: ule
    }), t(p));
  }
  var dle = {
    name: "1a0ro4n-requiredInput",
    styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
  }, ple = function(t) {
    var n = t.name, r = t.onFocus;
    return He("input", {
      required: !0,
      name: n,
      tabIndex: -1,
      "aria-hidden": "true",
      onFocus: r,
      css: dle,
      value: "",
      onChange: function() {
      }
    });
  }, hle = ple;
  function oT(e) {
    var t;
    return typeof window < "u" && window.navigator != null ? e.test(((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.platform) || window.navigator.platform) : !1;
  }
  function mle() {
    return oT(/^iPhone/i);
  }
  function s6() {
    return oT(/^Mac/i);
  }
  function gle() {
    return oT(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
    s6() && navigator.maxTouchPoints > 1;
  }
  function yle() {
    return mle() || gle();
  }
  function vle() {
    return s6() || yle();
  }
  var ble = function(t) {
    return t.label;
  }, xle = function(t) {
    return t.label;
  }, wle = function(t) {
    return t.value;
  }, Sle = function(t) {
    return !!t.isDisabled;
  }, _le = {
    clearIndicator: ise,
    container: Kae,
    control: dse,
    dropdownIndicator: rse,
    group: gse,
    groupHeading: vse,
    indicatorsContainer: Qae,
    indicatorSeparator: sse,
    input: Sse,
    loadingIndicator: use,
    loadingMessage: Vae,
    menu: jae,
    menuList: zae,
    menuPortal: Wae,
    multiValue: Tse,
    multiValueLabel: Rse,
    multiValueRemove: Ose,
    noOptionsMessage: Uae,
    option: Ise,
    placeholder: Fse,
    singleValue: Bse,
    valueContainer: Xae
  }, Ele = {
    primary: "#2684FF",
    primary75: "#4C9AFF",
    primary50: "#B2D4FF",
    primary25: "#DEEBFF",
    danger: "#DE350B",
    dangerLight: "#FFBDAD",
    neutral0: "hsl(0, 0%, 100%)",
    neutral5: "hsl(0, 0%, 95%)",
    neutral10: "hsl(0, 0%, 90%)",
    neutral20: "hsl(0, 0%, 80%)",
    neutral30: "hsl(0, 0%, 70%)",
    neutral40: "hsl(0, 0%, 60%)",
    neutral50: "hsl(0, 0%, 50%)",
    neutral60: "hsl(0, 0%, 40%)",
    neutral70: "hsl(0, 0%, 30%)",
    neutral80: "hsl(0, 0%, 20%)",
    neutral90: "hsl(0, 0%, 10%)"
  }, Cle = 4, l6 = 4, kle = 38, Tle = l6 * 2, Rle = {
    baseUnit: l6,
    controlHeight: kle,
    menuGutter: Tle
  }, OS = {
    borderRadius: Cle,
    colors: Ele,
    spacing: Rle
  }, Ole = {
    "aria-live": "polite",
    backspaceRemovesValue: !0,
    blurInputOnSelect: f2(),
    captureMenuScroll: !f2(),
    classNames: {},
    closeMenuOnSelect: !0,
    closeMenuOnScroll: !1,
    components: {},
    controlShouldRenderValue: !0,
    escapeClearsValue: !1,
    filterOption: rle(),
    formatGroupLabel: ble,
    getOptionLabel: xle,
    getOptionValue: wle,
    isDisabled: !1,
    isLoading: !1,
    isMulti: !1,
    isRtl: !1,
    isSearchable: !0,
    isOptionDisabled: Sle,
    loadingMessage: function() {
      return "Loading...";
    },
    maxMenuHeight: 300,
    minMenuHeight: 140,
    menuIsOpen: !1,
    menuPlacement: "bottom",
    menuPosition: "absolute",
    menuShouldBlockScroll: !1,
    menuShouldScrollIntoView: !kae(),
    noOptionsMessage: function() {
      return "No options";
    },
    openMenuOnFocus: !1,
    openMenuOnClick: !0,
    options: [],
    pageSize: 5,
    placeholder: "Select...",
    screenReaderStatus: function(t) {
      var n = t.count;
      return "".concat(n, " result").concat(n !== 1 ? "s" : "", " available");
    },
    styles: {},
    tabIndex: 0,
    tabSelectsValue: !0,
    unstyled: !1
  };
  function _2(e, t, n, r) {
    var o = f6(e, t, n), i = d6(e, t, n), a = u6(e, t), s = o0(e, t);
    return {
      type: "option",
      data: t,
      isDisabled: o,
      isSelected: i,
      label: a,
      value: s,
      index: r
    };
  }
  function bv(e, t) {
    return e.options.map(function(n, r) {
      if ("options" in n) {
        var o = n.options.map(function(a, s) {
          return _2(e, a, t, s);
        }).filter(function(a) {
          return C2(e, a);
        });
        return o.length > 0 ? {
          type: "group",
          data: n,
          options: o,
          index: r
        } : void 0;
      }
      var i = _2(e, n, t, r);
      return C2(e, i) ? i : void 0;
    }).filter(Oae);
  }
  function c6(e) {
    return e.reduce(function(t, n) {
      return n.type === "group" ? t.push.apply(t, nT(n.options.map(function(r) {
        return r.data;
      }))) : t.push(n.data), t;
    }, []);
  }
  function E2(e, t) {
    return e.reduce(function(n, r) {
      return r.type === "group" ? n.push.apply(n, nT(r.options.map(function(o) {
        return {
          data: o.data,
          id: "".concat(t, "-").concat(r.index, "-").concat(o.index)
        };
      }))) : n.push({
        data: r.data,
        id: "".concat(t, "-").concat(r.index)
      }), n;
    }, []);
  }
  function Ale(e, t) {
    return c6(bv(e, t));
  }
  function C2(e, t) {
    var n = e.inputValue, r = n === void 0 ? "" : n, o = t.data, i = t.isSelected, a = t.label, s = t.value;
    return (!h6(e) || !i) && p6(e, {
      label: a,
      value: s,
      data: o
    }, r);
  }
  function Nle(e, t) {
    var n = e.focusedValue, r = e.selectValue, o = r.indexOf(n);
    if (o > -1) {
      var i = t.indexOf(n);
      if (i > -1)
        return n;
      if (o < t.length)
        return t[o];
    }
    return null;
  }
  function Mle(e, t) {
    var n = e.focusedOption;
    return n && t.indexOf(n) > -1 ? n : t[0];
  }
  var AS = function(t, n) {
    var r, o = (r = t.find(function(i) {
      return i.data === n;
    })) === null || r === void 0 ? void 0 : r.id;
    return o || null;
  }, u6 = function(t, n) {
    return t.getOptionLabel(n);
  }, o0 = function(t, n) {
    return t.getOptionValue(n);
  };
  function f6(e, t, n) {
    return typeof e.isOptionDisabled == "function" ? e.isOptionDisabled(t, n) : !1;
  }
  function d6(e, t, n) {
    if (n.indexOf(t) > -1) return !0;
    if (typeof e.isOptionSelected == "function")
      return e.isOptionSelected(t, n);
    var r = o0(e, t);
    return n.some(function(o) {
      return o0(e, o) === r;
    });
  }
  function p6(e, t, n) {
    return e.filterOption ? e.filterOption(t, n) : !0;
  }
  var h6 = function(t) {
    var n = t.hideSelectedOptions, r = t.isMulti;
    return n === void 0 ? r : n;
  }, Ple = 1, m6 = /* @__PURE__ */ function(e) {
    dae(n, e);
    var t = hae(n);
    function n(r) {
      var o;
      if (uae(this, n), o = t.call(this, r), o.state = {
        ariaSelection: null,
        focusedOption: null,
        focusedOptionId: null,
        focusableOptionsWithIds: [],
        focusedValue: null,
        inputIsHidden: !1,
        isFocused: !1,
        selectValue: [],
        clearFocusValueOnUpdate: !1,
        prevWasFocused: !1,
        inputIsHiddenAfterUpdate: void 0,
        prevProps: void 0,
        instancePrefix: "",
        isAppleDevice: !1
      }, o.blockOptionHover = !1, o.isComposing = !1, o.commonProps = void 0, o.initialTouchX = 0, o.initialTouchY = 0, o.openAfterFocus = !1, o.scrollToFocusedOptionOnUpdate = !1, o.userIsDragging = void 0, o.controlRef = null, o.getControlRef = function(l) {
        o.controlRef = l;
      }, o.focusedOptionRef = null, o.getFocusedOptionRef = function(l) {
        o.focusedOptionRef = l;
      }, o.menuListRef = null, o.getMenuListRef = function(l) {
        o.menuListRef = l;
      }, o.inputRef = null, o.getInputRef = function(l) {
        o.inputRef = l;
      }, o.focus = o.focusInput, o.blur = o.blurInput, o.onChange = function(l, u) {
        var d = o.props, p = d.onChange, h = d.name;
        u.name = h, o.ariaOnChange(l, u), p(l, u);
      }, o.setValue = function(l, u, d) {
        var p = o.props, h = p.closeMenuOnSelect, g = p.isMulti, y = p.inputValue;
        o.onInputChange("", {
          action: "set-value",
          prevInputValue: y
        }), h && (o.setState({
          inputIsHiddenAfterUpdate: !g
        }), o.onMenuClose()), o.setState({
          clearFocusValueOnUpdate: !0
        }), o.onChange(l, {
          action: u,
          option: d
        });
      }, o.selectOption = function(l) {
        var u = o.props, d = u.blurInputOnSelect, p = u.isMulti, h = u.name, g = o.state.selectValue, y = p && o.isOptionSelected(l, g), b = o.isOptionDisabled(l, g);
        if (y) {
          var v = o.getOptionValue(l);
          o.setValue(g.filter(function(x) {
            return o.getOptionValue(x) !== v;
          }), "deselect-option", l);
        } else if (!b)
          p ? o.setValue([].concat(nT(g), [l]), "select-option", l) : o.setValue(l, "select-option");
        else {
          o.ariaOnChange(l, {
            action: "select-option",
            option: l,
            name: h
          });
          return;
        }
        d && o.blurInput();
      }, o.removeValue = function(l) {
        var u = o.props.isMulti, d = o.state.selectValue, p = o.getOptionValue(l), h = d.filter(function(y) {
          return o.getOptionValue(y) !== p;
        }), g = Gg(u, h, h[0] || null);
        o.onChange(g, {
          action: "remove-value",
          removedValue: l
        }), o.focusInput();
      }, o.clearValue = function() {
        var l = o.state.selectValue;
        o.onChange(Gg(o.props.isMulti, [], null), {
          action: "clear",
          removedValues: l
        });
      }, o.popValue = function() {
        var l = o.props.isMulti, u = o.state.selectValue, d = u[u.length - 1], p = u.slice(0, u.length - 1), h = Gg(l, p, p[0] || null);
        d && o.onChange(h, {
          action: "pop-value",
          removedValue: d
        });
      }, o.getFocusedOptionId = function(l) {
        return AS(o.state.focusableOptionsWithIds, l);
      }, o.getFocusableOptionsWithIds = function() {
        return E2(bv(o.props, o.state.selectValue), o.getElementId("option"));
      }, o.getValue = function() {
        return o.state.selectValue;
      }, o.cx = function() {
        for (var l = arguments.length, u = new Array(l), d = 0; d < l; d++)
          u[d] = arguments[d];
        return wae.apply(void 0, [o.props.classNamePrefix].concat(u));
      }, o.getOptionLabel = function(l) {
        return u6(o.props, l);
      }, o.getOptionValue = function(l) {
        return o0(o.props, l);
      }, o.getStyles = function(l, u) {
        var d = o.props.unstyled, p = _le[l](u, d);
        p.boxSizing = "border-box";
        var h = o.props.styles[l];
        return h ? h(p, u) : p;
      }, o.getClassNames = function(l, u) {
        var d, p;
        return (d = (p = o.props.classNames)[l]) === null || d === void 0 ? void 0 : d.call(p, u);
      }, o.getElementId = function(l) {
        return "".concat(o.state.instancePrefix, "-").concat(l);
      }, o.getComponents = function() {
        return qse(o.props);
      }, o.buildCategorizedOptions = function() {
        return bv(o.props, o.state.selectValue);
      }, o.getCategorizedOptions = function() {
        return o.props.menuIsOpen ? o.buildCategorizedOptions() : [];
      }, o.buildFocusableOptions = function() {
        return c6(o.buildCategorizedOptions());
      }, o.getFocusableOptions = function() {
        return o.props.menuIsOpen ? o.buildFocusableOptions() : [];
      }, o.ariaOnChange = function(l, u) {
        o.setState({
          ariaSelection: Ye({
            value: l
          }, u)
        });
      }, o.onMenuMouseDown = function(l) {
        l.button === 0 && (l.stopPropagation(), l.preventDefault(), o.focusInput());
      }, o.onMenuMouseMove = function(l) {
        o.blockOptionHover = !1;
      }, o.onControlMouseDown = function(l) {
        if (!l.defaultPrevented) {
          var u = o.props.openMenuOnClick;
          o.state.isFocused ? o.props.menuIsOpen ? l.target.tagName !== "INPUT" && l.target.tagName !== "TEXTAREA" && o.onMenuClose() : u && o.openMenu("first") : (u && (o.openAfterFocus = !0), o.focusInput()), l.target.tagName !== "INPUT" && l.target.tagName !== "TEXTAREA" && l.preventDefault();
        }
      }, o.onDropdownIndicatorMouseDown = function(l) {
        if (!(l && l.type === "mousedown" && l.button !== 0) && !o.props.isDisabled) {
          var u = o.props, d = u.isMulti, p = u.menuIsOpen;
          o.focusInput(), p ? (o.setState({
            inputIsHiddenAfterUpdate: !d
          }), o.onMenuClose()) : o.openMenu("first"), l.preventDefault();
        }
      }, o.onClearIndicatorMouseDown = function(l) {
        l && l.type === "mousedown" && l.button !== 0 || (o.clearValue(), l.preventDefault(), o.openAfterFocus = !1, l.type === "touchend" ? o.focusInput() : setTimeout(function() {
          return o.focusInput();
        }));
      }, o.onScroll = function(l) {
        typeof o.props.closeMenuOnScroll == "boolean" ? l.target instanceof HTMLElement && Cb(l.target) && o.props.onMenuClose() : typeof o.props.closeMenuOnScroll == "function" && o.props.closeMenuOnScroll(l) && o.props.onMenuClose();
      }, o.onCompositionStart = function() {
        o.isComposing = !0;
      }, o.onCompositionEnd = function() {
        o.isComposing = !1;
      }, o.onTouchStart = function(l) {
        var u = l.touches, d = u && u.item(0);
        d && (o.initialTouchX = d.clientX, o.initialTouchY = d.clientY, o.userIsDragging = !1);
      }, o.onTouchMove = function(l) {
        var u = l.touches, d = u && u.item(0);
        if (d) {
          var p = Math.abs(d.clientX - o.initialTouchX), h = Math.abs(d.clientY - o.initialTouchY), g = 5;
          o.userIsDragging = p > g || h > g;
        }
      }, o.onTouchEnd = function(l) {
        o.userIsDragging || (o.controlRef && !o.controlRef.contains(l.target) && o.menuListRef && !o.menuListRef.contains(l.target) && o.blurInput(), o.initialTouchX = 0, o.initialTouchY = 0);
      }, o.onControlTouchEnd = function(l) {
        o.userIsDragging || o.onControlMouseDown(l);
      }, o.onClearIndicatorTouchEnd = function(l) {
        o.userIsDragging || o.onClearIndicatorMouseDown(l);
      }, o.onDropdownIndicatorTouchEnd = function(l) {
        o.userIsDragging || o.onDropdownIndicatorMouseDown(l);
      }, o.handleInputChange = function(l) {
        var u = o.props.inputValue, d = l.currentTarget.value;
        o.setState({
          inputIsHiddenAfterUpdate: !1
        }), o.onInputChange(d, {
          action: "input-change",
          prevInputValue: u
        }), o.props.menuIsOpen || o.onMenuOpen();
      }, o.onInputFocus = function(l) {
        o.props.onFocus && o.props.onFocus(l), o.setState({
          inputIsHiddenAfterUpdate: !1,
          isFocused: !0
        }), (o.openAfterFocus || o.props.openMenuOnFocus) && o.openMenu("first"), o.openAfterFocus = !1;
      }, o.onInputBlur = function(l) {
        var u = o.props.inputValue;
        if (o.menuListRef && o.menuListRef.contains(document.activeElement)) {
          o.inputRef.focus();
          return;
        }
        o.props.onBlur && o.props.onBlur(l), o.onInputChange("", {
          action: "input-blur",
          prevInputValue: u
        }), o.onMenuClose(), o.setState({
          focusedValue: null,
          isFocused: !1
        });
      }, o.onOptionHover = function(l) {
        if (!(o.blockOptionHover || o.state.focusedOption === l)) {
          var u = o.getFocusableOptions(), d = u.indexOf(l);
          o.setState({
            focusedOption: l,
            focusedOptionId: d > -1 ? o.getFocusedOptionId(l) : null
          });
        }
      }, o.shouldHideSelectedOptions = function() {
        return h6(o.props);
      }, o.onValueInputFocus = function(l) {
        l.preventDefault(), l.stopPropagation(), o.focus();
      }, o.onKeyDown = function(l) {
        var u = o.props, d = u.isMulti, p = u.backspaceRemovesValue, h = u.escapeClearsValue, g = u.inputValue, y = u.isClearable, b = u.isDisabled, v = u.menuIsOpen, x = u.onKeyDown, E = u.tabSelectsValue, _ = u.openMenuOnFocus, C = o.state, k = C.focusedOption, R = C.focusedValue, A = C.selectValue;
        if (!b && !(typeof x == "function" && (x(l), l.defaultPrevented))) {
          switch (o.blockOptionHover = !0, l.key) {
            case "ArrowLeft":
              if (!d || g) return;
              o.focusValue("previous");
              break;
            case "ArrowRight":
              if (!d || g) return;
              o.focusValue("next");
              break;
            case "Delete":
            case "Backspace":
              if (g) return;
              if (R)
                o.removeValue(R);
              else {
                if (!p) return;
                d ? o.popValue() : y && o.clearValue();
              }
              break;
            case "Tab":
              if (o.isComposing || l.shiftKey || !v || !E || !k || // don't capture the event if the menu opens on focus and the focused
              // option is already selected; it breaks the flow of navigation
              _ && o.isOptionSelected(k, A))
                return;
              o.selectOption(k);
              break;
            case "Enter":
              if (l.keyCode === 229)
                break;
              if (v) {
                if (!k || o.isComposing) return;
                o.selectOption(k);
                break;
              }
              return;
            case "Escape":
              v ? (o.setState({
                inputIsHiddenAfterUpdate: !1
              }), o.onInputChange("", {
                action: "menu-close",
                prevInputValue: g
              }), o.onMenuClose()) : y && h && o.clearValue();
              break;
            case " ":
              if (g)
                return;
              if (!v) {
                o.openMenu("first");
                break;
              }
              if (!k) return;
              o.selectOption(k);
              break;
            case "ArrowUp":
              v ? o.focusOption("up") : o.openMenu("last");
              break;
            case "ArrowDown":
              v ? o.focusOption("down") : o.openMenu("first");
              break;
            case "PageUp":
              if (!v) return;
              o.focusOption("pageup");
              break;
            case "PageDown":
              if (!v) return;
              o.focusOption("pagedown");
              break;
            case "Home":
              if (!v) return;
              o.focusOption("first");
              break;
            case "End":
              if (!v) return;
              o.focusOption("last");
              break;
            default:
              return;
          }
          l.preventDefault();
        }
      }, o.state.instancePrefix = "react-select-" + (o.props.instanceId || ++Ple), o.state.selectValue = c2(r.value), r.menuIsOpen && o.state.selectValue.length) {
        var i = o.getFocusableOptionsWithIds(), a = o.buildFocusableOptions(), s = a.indexOf(o.state.selectValue[0]);
        o.state.focusableOptionsWithIds = i, o.state.focusedOption = a[s], o.state.focusedOptionId = AS(i, a[s]);
      }
      return o;
    }
    return fae(n, [{
      key: "componentDidMount",
      value: function() {
        this.startListeningComposition(), this.startListeningToTouch(), this.props.closeMenuOnScroll && document && document.addEventListener && document.addEventListener("scroll", this.onScroll, !0), this.props.autoFocus && this.focusInput(), this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef && u2(this.menuListRef, this.focusedOptionRef), vle() && this.setState({
          isAppleDevice: !0
        });
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        var i = this.props, a = i.isDisabled, s = i.menuIsOpen, l = this.state.isFocused;
        // ensure focus is restored correctly when the control becomes enabled
        (l && !a && o.isDisabled || // ensure focus is on the Input when the menu opens
        l && s && !o.menuIsOpen) && this.focusInput(), l && a && !o.isDisabled ? this.setState({
          isFocused: !1
        }, this.onMenuClose) : !l && !a && o.isDisabled && this.inputRef === document.activeElement && this.setState({
          isFocused: !0
        }), this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate && (u2(this.menuListRef, this.focusedOptionRef), this.scrollToFocusedOptionOnUpdate = !1);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        this.stopListeningComposition(), this.stopListeningToTouch(), document.removeEventListener("scroll", this.onScroll, !0);
      }
      // ==============================
      // Consumer Handlers
      // ==============================
    }, {
      key: "onMenuOpen",
      value: function() {
        this.props.onMenuOpen();
      }
    }, {
      key: "onMenuClose",
      value: function() {
        this.onInputChange("", {
          action: "menu-close",
          prevInputValue: this.props.inputValue
        }), this.props.onMenuClose();
      }
    }, {
      key: "onInputChange",
      value: function(o, i) {
        this.props.onInputChange(o, i);
      }
      // ==============================
      // Methods
      // ==============================
    }, {
      key: "focusInput",
      value: function() {
        this.inputRef && this.inputRef.focus();
      }
    }, {
      key: "blurInput",
      value: function() {
        this.inputRef && this.inputRef.blur();
      }
      // aliased for consumers
    }, {
      key: "openMenu",
      value: function(o) {
        var i = this, a = this.state, s = a.selectValue, l = a.isFocused, u = this.buildFocusableOptions(), d = o === "first" ? 0 : u.length - 1;
        if (!this.props.isMulti) {
          var p = u.indexOf(s[0]);
          p > -1 && (d = p);
        }
        this.scrollToFocusedOptionOnUpdate = !(l && this.menuListRef), this.setState({
          inputIsHiddenAfterUpdate: !1,
          focusedValue: null,
          focusedOption: u[d],
          focusedOptionId: this.getFocusedOptionId(u[d])
        }, function() {
          return i.onMenuOpen();
        });
      }
    }, {
      key: "focusValue",
      value: function(o) {
        var i = this.state, a = i.selectValue, s = i.focusedValue;
        if (this.props.isMulti) {
          this.setState({
            focusedOption: null
          });
          var l = a.indexOf(s);
          s || (l = -1);
          var u = a.length - 1, d = -1;
          if (a.length) {
            switch (o) {
              case "previous":
                l === 0 ? d = 0 : l === -1 ? d = u : d = l - 1;
                break;
              case "next":
                l > -1 && l < u && (d = l + 1);
                break;
            }
            this.setState({
              inputIsHidden: d !== -1,
              focusedValue: a[d]
            });
          }
        }
      }
    }, {
      key: "focusOption",
      value: function() {
        var o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first", i = this.props.pageSize, a = this.state.focusedOption, s = this.getFocusableOptions();
        if (s.length) {
          var l = 0, u = s.indexOf(a);
          a || (u = -1), o === "up" ? l = u > 0 ? u - 1 : s.length - 1 : o === "down" ? l = (u + 1) % s.length : o === "pageup" ? (l = u - i, l < 0 && (l = 0)) : o === "pagedown" ? (l = u + i, l > s.length - 1 && (l = s.length - 1)) : o === "last" && (l = s.length - 1), this.scrollToFocusedOptionOnUpdate = !0, this.setState({
            focusedOption: s[l],
            focusedValue: null,
            focusedOptionId: this.getFocusedOptionId(s[l])
          });
        }
      }
    }, {
      key: "getTheme",
      value: (
        // ==============================
        // Getters
        // ==============================
        function() {
          return this.props.theme ? typeof this.props.theme == "function" ? this.props.theme(OS) : Ye(Ye({}, OS), this.props.theme) : OS;
        }
      )
    }, {
      key: "getCommonProps",
      value: function() {
        var o = this.clearValue, i = this.cx, a = this.getStyles, s = this.getClassNames, l = this.getValue, u = this.selectOption, d = this.setValue, p = this.props, h = p.isMulti, g = p.isRtl, y = p.options, b = this.hasValue();
        return {
          clearValue: o,
          cx: i,
          getStyles: a,
          getClassNames: s,
          getValue: l,
          hasValue: b,
          isMulti: h,
          isRtl: g,
          options: y,
          selectOption: u,
          selectProps: p,
          setValue: d,
          theme: this.getTheme()
        };
      }
    }, {
      key: "hasValue",
      value: function() {
        var o = this.state.selectValue;
        return o.length > 0;
      }
    }, {
      key: "hasOptions",
      value: function() {
        return !!this.getFocusableOptions().length;
      }
    }, {
      key: "isClearable",
      value: function() {
        var o = this.props, i = o.isClearable, a = o.isMulti;
        return i === void 0 ? a : i;
      }
    }, {
      key: "isOptionDisabled",
      value: function(o, i) {
        return f6(this.props, o, i);
      }
    }, {
      key: "isOptionSelected",
      value: function(o, i) {
        return d6(this.props, o, i);
      }
    }, {
      key: "filterOption",
      value: function(o, i) {
        return p6(this.props, o, i);
      }
    }, {
      key: "formatOptionLabel",
      value: function(o, i) {
        if (typeof this.props.formatOptionLabel == "function") {
          var a = this.props.inputValue, s = this.state.selectValue;
          return this.props.formatOptionLabel(o, {
            context: i,
            inputValue: a,
            selectValue: s
          });
        } else
          return this.getOptionLabel(o);
      }
    }, {
      key: "formatGroupLabel",
      value: function(o) {
        return this.props.formatGroupLabel(o);
      }
      // ==============================
      // Mouse Handlers
      // ==============================
    }, {
      key: "startListeningComposition",
      value: (
        // ==============================
        // Composition Handlers
        // ==============================
        function() {
          document && document.addEventListener && (document.addEventListener("compositionstart", this.onCompositionStart, !1), document.addEventListener("compositionend", this.onCompositionEnd, !1));
        }
      )
    }, {
      key: "stopListeningComposition",
      value: function() {
        document && document.removeEventListener && (document.removeEventListener("compositionstart", this.onCompositionStart), document.removeEventListener("compositionend", this.onCompositionEnd));
      }
    }, {
      key: "startListeningToTouch",
      value: (
        // ==============================
        // Touch Handlers
        // ==============================
        function() {
          document && document.addEventListener && (document.addEventListener("touchstart", this.onTouchStart, !1), document.addEventListener("touchmove", this.onTouchMove, !1), document.addEventListener("touchend", this.onTouchEnd, !1));
        }
      )
    }, {
      key: "stopListeningToTouch",
      value: function() {
        document && document.removeEventListener && (document.removeEventListener("touchstart", this.onTouchStart), document.removeEventListener("touchmove", this.onTouchMove), document.removeEventListener("touchend", this.onTouchEnd));
      }
    }, {
      key: "renderInput",
      value: (
        // ==============================
        // Renderers
        // ==============================
        function() {
          var o = this.props, i = o.isDisabled, a = o.isSearchable, s = o.inputId, l = o.inputValue, u = o.tabIndex, d = o.form, p = o.menuIsOpen, h = o.required, g = this.getComponents(), y = g.Input, b = this.state, v = b.inputIsHidden, x = b.ariaSelection, E = this.commonProps, _ = s || this.getElementId("input"), C = Ye(Ye(Ye({
            "aria-autocomplete": "list",
            "aria-expanded": p,
            "aria-haspopup": !0,
            "aria-errormessage": this.props["aria-errormessage"],
            "aria-invalid": this.props["aria-invalid"],
            "aria-label": this.props["aria-label"],
            "aria-labelledby": this.props["aria-labelledby"],
            "aria-required": h,
            role: "combobox",
            "aria-activedescendant": this.state.isAppleDevice ? void 0 : this.state.focusedOptionId || ""
          }, p && {
            "aria-controls": this.getElementId("listbox")
          }), !a && {
            "aria-readonly": !0
          }), this.hasValue() ? x?.action === "initial-input-focus" && {
            "aria-describedby": this.getElementId("live-region")
          } : {
            "aria-describedby": this.getElementId("placeholder")
          });
          return a ? /* @__PURE__ */ T.createElement(y, Ge({}, E, {
            autoCapitalize: "none",
            autoComplete: "off",
            autoCorrect: "off",
            id: _,
            innerRef: this.getInputRef,
            isDisabled: i,
            isHidden: v,
            onBlur: this.onInputBlur,
            onChange: this.handleInputChange,
            onFocus: this.onInputFocus,
            spellCheck: "false",
            tabIndex: u,
            form: d,
            type: "text",
            value: l
          }, C)) : /* @__PURE__ */ T.createElement(ile, Ge({
            id: _,
            innerRef: this.getInputRef,
            onBlur: this.onInputBlur,
            onChange: n0,
            onFocus: this.onInputFocus,
            disabled: i,
            tabIndex: u,
            inputMode: "none",
            form: d,
            value: ""
          }, C));
        }
      )
    }, {
      key: "renderPlaceholderOrValue",
      value: function() {
        var o = this, i = this.getComponents(), a = i.MultiValue, s = i.MultiValueContainer, l = i.MultiValueLabel, u = i.MultiValueRemove, d = i.SingleValue, p = i.Placeholder, h = this.commonProps, g = this.props, y = g.controlShouldRenderValue, b = g.isDisabled, v = g.isMulti, x = g.inputValue, E = g.placeholder, _ = this.state, C = _.selectValue, k = _.focusedValue, R = _.isFocused;
        if (!this.hasValue() || !y)
          return x ? null : /* @__PURE__ */ T.createElement(p, Ge({}, h, {
            key: "placeholder",
            isDisabled: b,
            isFocused: R,
            innerProps: {
              id: this.getElementId("placeholder")
            }
          }), E);
        if (v)
          return C.map(function(M, I) {
            var D = M === k, L = "".concat(o.getOptionLabel(M), "-").concat(o.getOptionValue(M));
            return /* @__PURE__ */ T.createElement(a, Ge({}, h, {
              components: {
                Container: s,
                Label: l,
                Remove: u
              },
              isFocused: D,
              isDisabled: b,
              key: L,
              index: I,
              removeProps: {
                onClick: function() {
                  return o.removeValue(M);
                },
                onTouchEnd: function() {
                  return o.removeValue(M);
                },
                onMouseDown: function(B) {
                  B.preventDefault();
                }
              },
              data: M
            }), o.formatOptionLabel(M, "value"));
          });
        if (x)
          return null;
        var A = C[0];
        return /* @__PURE__ */ T.createElement(d, Ge({}, h, {
          data: A,
          isDisabled: b
        }), this.formatOptionLabel(A, "value"));
      }
    }, {
      key: "renderClearIndicator",
      value: function() {
        var o = this.getComponents(), i = o.ClearIndicator, a = this.commonProps, s = this.props, l = s.isDisabled, u = s.isLoading, d = this.state.isFocused;
        if (!this.isClearable() || !i || l || !this.hasValue() || u)
          return null;
        var p = {
          onMouseDown: this.onClearIndicatorMouseDown,
          onTouchEnd: this.onClearIndicatorTouchEnd,
          "aria-hidden": "true"
        };
        return /* @__PURE__ */ T.createElement(i, Ge({}, a, {
          innerProps: p,
          isFocused: d
        }));
      }
    }, {
      key: "renderLoadingIndicator",
      value: function() {
        var o = this.getComponents(), i = o.LoadingIndicator, a = this.commonProps, s = this.props, l = s.isDisabled, u = s.isLoading, d = this.state.isFocused;
        if (!i || !u) return null;
        var p = {
          "aria-hidden": "true"
        };
        return /* @__PURE__ */ T.createElement(i, Ge({}, a, {
          innerProps: p,
          isDisabled: l,
          isFocused: d
        }));
      }
    }, {
      key: "renderIndicatorSeparator",
      value: function() {
        var o = this.getComponents(), i = o.DropdownIndicator, a = o.IndicatorSeparator;
        if (!i || !a) return null;
        var s = this.commonProps, l = this.props.isDisabled, u = this.state.isFocused;
        return /* @__PURE__ */ T.createElement(a, Ge({}, s, {
          isDisabled: l,
          isFocused: u
        }));
      }
    }, {
      key: "renderDropdownIndicator",
      value: function() {
        var o = this.getComponents(), i = o.DropdownIndicator;
        if (!i) return null;
        var a = this.commonProps, s = this.props.isDisabled, l = this.state.isFocused, u = {
          onMouseDown: this.onDropdownIndicatorMouseDown,
          onTouchEnd: this.onDropdownIndicatorTouchEnd,
          "aria-hidden": "true"
        };
        return /* @__PURE__ */ T.createElement(i, Ge({}, a, {
          innerProps: u,
          isDisabled: s,
          isFocused: l
        }));
      }
    }, {
      key: "renderMenu",
      value: function() {
        var o = this, i = this.getComponents(), a = i.Group, s = i.GroupHeading, l = i.Menu, u = i.MenuList, d = i.MenuPortal, p = i.LoadingMessage, h = i.NoOptionsMessage, g = i.Option, y = this.commonProps, b = this.state.focusedOption, v = this.props, x = v.captureMenuScroll, E = v.inputValue, _ = v.isLoading, C = v.loadingMessage, k = v.minMenuHeight, R = v.maxMenuHeight, A = v.menuIsOpen, M = v.menuPlacement, I = v.menuPosition, D = v.menuPortalTarget, L = v.menuShouldBlockScroll, P = v.menuShouldScrollIntoView, B = v.noOptionsMessage, j = v.onMenuScrollToTop, V = v.onMenuScrollToBottom;
        if (!A) return null;
        var F = function(z, H) {
          var Y = z.type, Q = z.data, re = z.isDisabled, te = z.isSelected, le = z.label, fe = z.value, J = b === Q, ee = re ? void 0 : function() {
            return o.onOptionHover(Q);
          }, ie = re ? void 0 : function() {
            return o.selectOption(Q);
          }, ae = "".concat(o.getElementId("option"), "-").concat(H), ge = {
            id: ae,
            onClick: ie,
            onMouseMove: ee,
            onMouseOver: ee,
            tabIndex: -1,
            role: "option",
            "aria-selected": o.state.isAppleDevice ? void 0 : te
            // is not supported on Apple devices
          };
          return /* @__PURE__ */ T.createElement(g, Ge({}, y, {
            innerProps: ge,
            data: Q,
            isDisabled: re,
            isSelected: te,
            key: ae,
            label: le,
            type: Y,
            value: fe,
            isFocused: J,
            innerRef: J ? o.getFocusedOptionRef : void 0
          }), o.formatOptionLabel(z.data, "menu"));
        }, G;
        if (this.hasOptions())
          G = this.getCategorizedOptions().map(function(X) {
            if (X.type === "group") {
              var z = X.data, H = X.options, Y = X.index, Q = "".concat(o.getElementId("group"), "-").concat(Y), re = "".concat(Q, "-heading");
              return /* @__PURE__ */ T.createElement(a, Ge({}, y, {
                key: Q,
                data: z,
                options: H,
                Heading: s,
                headingProps: {
                  id: re,
                  data: X.data
                },
                label: o.formatGroupLabel(X.data)
              }), X.options.map(function(te) {
                return F(te, "".concat(Y, "-").concat(te.index));
              }));
            } else if (X.type === "option")
              return F(X, "".concat(X.index));
          });
        else if (_) {
          var W = C({
            inputValue: E
          });
          if (W === null) return null;
          G = /* @__PURE__ */ T.createElement(p, y, W);
        } else {
          var K = B({
            inputValue: E
          });
          if (K === null) return null;
          G = /* @__PURE__ */ T.createElement(h, y, K);
        }
        var $ = {
          minMenuHeight: k,
          maxMenuHeight: R,
          menuPlacement: M,
          menuPosition: I,
          menuShouldScrollIntoView: P
        }, U = /* @__PURE__ */ T.createElement(Dae, Ge({}, y, $), function(X) {
          var z = X.ref, H = X.placerProps, Y = H.placement, Q = H.maxHeight;
          return /* @__PURE__ */ T.createElement(l, Ge({}, y, $, {
            innerRef: z,
            innerProps: {
              onMouseDown: o.onMenuMouseDown,
              onMouseMove: o.onMenuMouseMove
            },
            isLoading: _,
            placement: Y
          }), /* @__PURE__ */ T.createElement(fle, {
            captureEnabled: x,
            onTopArrive: j,
            onBottomArrive: V,
            lockEnabled: L
          }, function(re) {
            return /* @__PURE__ */ T.createElement(u, Ge({}, y, {
              innerRef: function(le) {
                o.getMenuListRef(le), re(le);
              },
              innerProps: {
                role: "listbox",
                "aria-multiselectable": y.isMulti,
                id: o.getElementId("listbox")
              },
              isLoading: _,
              maxHeight: Q,
              focusedOption: b
            }), G);
          }));
        });
        return D || I === "fixed" ? /* @__PURE__ */ T.createElement(d, Ge({}, y, {
          appendTo: D,
          controlElement: this.controlRef,
          menuPlacement: M,
          menuPosition: I
        }), U) : U;
      }
    }, {
      key: "renderFormField",
      value: function() {
        var o = this, i = this.props, a = i.delimiter, s = i.isDisabled, l = i.isMulti, u = i.name, d = i.required, p = this.state.selectValue;
        if (d && !this.hasValue() && !s)
          return /* @__PURE__ */ T.createElement(hle, {
            name: u,
            onFocus: this.onValueInputFocus
          });
        if (!(!u || s))
          if (l)
            if (a) {
              var h = p.map(function(b) {
                return o.getOptionValue(b);
              }).join(a);
              return /* @__PURE__ */ T.createElement("input", {
                name: u,
                type: "hidden",
                value: h
              });
            } else {
              var g = p.length > 0 ? p.map(function(b, v) {
                return /* @__PURE__ */ T.createElement("input", {
                  key: "i-".concat(v),
                  name: u,
                  type: "hidden",
                  value: o.getOptionValue(b)
                });
              }) : /* @__PURE__ */ T.createElement("input", {
                name: u,
                type: "hidden",
                value: ""
              });
              return /* @__PURE__ */ T.createElement("div", null, g);
            }
          else {
            var y = p[0] ? this.getOptionValue(p[0]) : "";
            return /* @__PURE__ */ T.createElement("input", {
              name: u,
              type: "hidden",
              value: y
            });
          }
      }
    }, {
      key: "renderLiveRegion",
      value: function() {
        var o = this.commonProps, i = this.state, a = i.ariaSelection, s = i.focusedOption, l = i.focusedValue, u = i.isFocused, d = i.selectValue, p = this.getFocusableOptions();
        return /* @__PURE__ */ T.createElement(Jse, Ge({}, o, {
          id: this.getElementId("live-region"),
          ariaSelection: a,
          focusedOption: s,
          focusedValue: l,
          isFocused: u,
          selectValue: d,
          focusableOptions: p,
          isAppleDevice: this.state.isAppleDevice
        }));
      }
    }, {
      key: "render",
      value: function() {
        var o = this.getComponents(), i = o.Control, a = o.IndicatorsContainer, s = o.SelectContainer, l = o.ValueContainer, u = this.props, d = u.className, p = u.id, h = u.isDisabled, g = u.menuIsOpen, y = this.state.isFocused, b = this.commonProps = this.getCommonProps();
        return /* @__PURE__ */ T.createElement(s, Ge({}, b, {
          className: d,
          innerProps: {
            id: p,
            onKeyDown: this.onKeyDown
          },
          isDisabled: h,
          isFocused: y
        }), this.renderLiveRegion(), /* @__PURE__ */ T.createElement(i, Ge({}, b, {
          innerRef: this.getControlRef,
          innerProps: {
            onMouseDown: this.onControlMouseDown,
            onTouchEnd: this.onControlTouchEnd
          },
          isDisabled: h,
          isFocused: y,
          menuIsOpen: g
        }), /* @__PURE__ */ T.createElement(l, Ge({}, b, {
          isDisabled: h
        }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ T.createElement(a, Ge({}, b, {
          isDisabled: h
        }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function(o, i) {
        var a = i.prevProps, s = i.clearFocusValueOnUpdate, l = i.inputIsHiddenAfterUpdate, u = i.ariaSelection, d = i.isFocused, p = i.prevWasFocused, h = i.instancePrefix, g = o.options, y = o.value, b = o.menuIsOpen, v = o.inputValue, x = o.isMulti, E = c2(y), _ = {};
        if (a && (y !== a.value || g !== a.options || b !== a.menuIsOpen || v !== a.inputValue)) {
          var C = b ? Ale(o, E) : [], k = b ? E2(bv(o, E), "".concat(h, "-option")) : [], R = s ? Nle(i, E) : null, A = Mle(i, C), M = AS(k, A);
          _ = {
            selectValue: E,
            focusedOption: A,
            focusedOptionId: M,
            focusableOptionsWithIds: k,
            focusedValue: R,
            clearFocusValueOnUpdate: !1
          };
        }
        var I = l != null && o !== a ? {
          inputIsHidden: l,
          inputIsHiddenAfterUpdate: void 0
        } : {}, D = u, L = d && p;
        return d && !L && (D = {
          value: Gg(x, E, E[0] || null),
          options: E,
          action: "initial-input-focus"
        }, L = !p), u?.action === "initial-input-focus" && (D = null), Ye(Ye(Ye({}, _), I), {}, {
          prevProps: o,
          ariaSelection: D,
          prevWasFocused: L
        });
      }
    }]), n;
  }(T.Component);
  m6.defaultProps = Ole;
  var $le = /* @__PURE__ */ T.forwardRef(function(e, t) {
    var n = cae(e);
    return /* @__PURE__ */ T.createElement(m6, Ge({
      ref: t
    }, n));
  }), Ile = $le;
  const jle = ({
    options: e,
    items_per_page: t,
    className: n,
    defaultValue: r,
    onChange: o
  }) => {
    const [i, a] = T.useState(""), [s, l] = T.useState(0), u = (g) => {
      a(g.toLowerCase()), l(0);
    }, d = e.filter((g) => g.label.toLowerCase().includes(i) || g.value.toLowerCase().includes(i));
    var p;
    t !== void 0 ? p = d.slice(
      s * t,
      (s + 1) * t
    ) : p = d;
    const h = {
      control: (g) => ({
        ...g,
        minHeight: void 0
      })
    };
    return /* @__PURE__ */ S.jsx(
      Ile,
      {
        options: p,
        onInputChange: u,
        onChange: o,
        inputValue: i,
        isSearchable: !0,
        placeholder: "Select an option...",
        className: n,
        unstyled: !0,
        styles: h,
        classNamePrefix: "styled-select",
        defaultValue: r,
        value: r
      }
    );
  }, Dle = (e) => typeof e == "boolean" || e instanceof Boolean, Fle = (e) => typeof e == "number" || e instanceof Number, Lle = (e) => typeof e == "bigint" || e instanceof BigInt, g6 = (e) => !!e && e instanceof Date, zle = (e) => typeof e == "string" || e instanceof String, Ble = (e) => Array.isArray(e), Ule = (e) => typeof e == "object" && e !== null, y6 = (e) => !!e && e instanceof Object && typeof e == "function";
  function i0(e, t) {
    return t === void 0 && (t = !1), !e || t ? `"${e}"` : e;
  }
  function Vle(e, t, n) {
    return n ? JSON.stringify(e) : t ? `"${e}"` : e;
  }
  function v6(e) {
    let {
      field: t,
      value: n,
      data: r,
      lastElement: o,
      openBracket: i,
      closeBracket: a,
      level: s,
      style: l,
      shouldExpandNode: u,
      clickToExpandNode: d,
      outerRef: p,
      beforeExpandChange: h
    } = e;
    const g = T.useRef(!1), [y, b] = T.useState(() => u(s, n, t)), v = T.useRef(null);
    T.useEffect(() => {
      g.current ? b(u(s, n, t)) : g.current = !0;
    }, [u]);
    const x = T.useId();
    if (r.length === 0)
      return Hle({
        field: t,
        openBracket: i,
        closeBracket: a,
        lastElement: o,
        style: l
      });
    const E = y ? l.collapseIcon : l.expandIcon, _ = y ? l.ariaLables.collapseJson : l.ariaLables.expandJson, C = s + 1, k = r.length - 1, R = (I) => {
      y !== I && (!h || h({
        level: s,
        value: n,
        field: t,
        newExpandValue: I
      })) && b(I);
    }, A = (I) => {
      if (I.key === "ArrowRight" || I.key === "ArrowLeft")
        I.preventDefault(), R(I.key === "ArrowRight");
      else if (I.key === "ArrowUp" || I.key === "ArrowDown") {
        I.preventDefault();
        const D = I.key === "ArrowUp" ? -1 : 1;
        if (!p.current) return;
        const L = p.current.querySelectorAll("[role=button]");
        let P = -1;
        for (let j = 0; j < L.length; j++)
          if (L[j].tabIndex === 0) {
            P = j;
            break;
          }
        if (P < 0)
          return;
        const B = (P + D + L.length) % L.length;
        L[P].tabIndex = -1, L[B].tabIndex = 0, L[B].focus();
      }
    }, M = () => {
      var I;
      R(!y);
      const D = v.current;
      if (!D) return;
      const L = (I = p.current) === null || I === void 0 ? void 0 : I.querySelector('[role=button][tabindex="0"]');
      L && (L.tabIndex = -1), D.tabIndex = 0, D.focus();
    };
    return /* @__PURE__ */ T.createElement("div", {
      className: l.basicChildStyle,
      role: "treeitem",
      "aria-expanded": y,
      "aria-selected": void 0
    }, /* @__PURE__ */ T.createElement("span", {
      className: E,
      onClick: M,
      onKeyDown: A,
      role: "button",
      "aria-label": _,
      "aria-expanded": y,
      "aria-controls": y ? x : void 0,
      ref: v,
      tabIndex: s === 0 ? 0 : -1
    }), (t || t === "") && (d ? /* @__PURE__ */ T.createElement("span", {
      className: l.clickableLabel,
      onClick: M,
      onKeyDown: A
    }, i0(t, l.quotesForFieldNames), ":") : /* @__PURE__ */ T.createElement("span", {
      className: l.label
    }, i0(t, l.quotesForFieldNames), ":")), /* @__PURE__ */ T.createElement("span", {
      className: l.punctuation
    }, i), y ? /* @__PURE__ */ T.createElement("ul", {
      id: x,
      role: "group",
      className: l.childFieldsContainer
    }, r.map((I, D) => /* @__PURE__ */ T.createElement(b6, {
      key: I[0] || D,
      field: I[0],
      value: I[1],
      style: l,
      lastElement: D === k,
      level: C,
      shouldExpandNode: u,
      clickToExpandNode: d,
      outerRef: p
    }))) : /* @__PURE__ */ T.createElement("span", {
      className: l.collapsedContent,
      onClick: M,
      onKeyDown: A
    }), /* @__PURE__ */ T.createElement("span", {
      className: l.punctuation
    }, a), !o && /* @__PURE__ */ T.createElement("span", {
      className: l.punctuation
    }, ","));
  }
  function Hle(e) {
    let {
      field: t,
      openBracket: n,
      closeBracket: r,
      lastElement: o,
      style: i
    } = e;
    return /* @__PURE__ */ T.createElement("div", {
      className: i.basicChildStyle,
      role: "treeitem",
      "aria-selected": void 0
    }, (t || t === "") && /* @__PURE__ */ T.createElement("span", {
      className: i.label
    }, i0(t, i.quotesForFieldNames), ":"), /* @__PURE__ */ T.createElement("span", {
      className: i.punctuation
    }, n), /* @__PURE__ */ T.createElement("span", {
      className: i.punctuation
    }, r), !o && /* @__PURE__ */ T.createElement("span", {
      className: i.punctuation
    }, ","));
  }
  function qle(e) {
    let {
      field: t,
      value: n,
      style: r,
      lastElement: o,
      shouldExpandNode: i,
      clickToExpandNode: a,
      level: s,
      outerRef: l,
      beforeExpandChange: u
    } = e;
    return v6({
      field: t,
      value: n,
      lastElement: o || !1,
      level: s,
      openBracket: "{",
      closeBracket: "}",
      style: r,
      shouldExpandNode: i,
      clickToExpandNode: a,
      data: Object.keys(n).map((d) => [d, n[d]]),
      outerRef: l,
      beforeExpandChange: u
    });
  }
  function Wle(e) {
    let {
      field: t,
      value: n,
      style: r,
      lastElement: o,
      level: i,
      shouldExpandNode: a,
      clickToExpandNode: s,
      outerRef: l,
      beforeExpandChange: u
    } = e;
    return v6({
      field: t,
      value: n,
      lastElement: o || !1,
      level: i,
      openBracket: "[",
      closeBracket: "]",
      style: r,
      shouldExpandNode: a,
      clickToExpandNode: s,
      data: n.map((d) => [void 0, d]),
      outerRef: l,
      beforeExpandChange: u
    });
  }
  function Gle(e) {
    let {
      field: t,
      value: n,
      style: r,
      lastElement: o
    } = e, i, a = r.otherValue;
    return n === null ? (i = "null", a = r.nullValue) : n === void 0 ? (i = "undefined", a = r.undefinedValue) : zle(n) ? (i = Vle(n, !r.noQuotesForStringValues, r.stringifyStringValues), a = r.stringValue) : Dle(n) ? (i = n ? "true" : "false", a = r.booleanValue) : Fle(n) ? (i = n.toString(), a = r.numberValue) : Lle(n) ? (i = `${n.toString()}n`, a = r.numberValue) : g6(n) ? i = n.toISOString() : y6(n) ? i = "function() { }" : i = n.toString(), /* @__PURE__ */ T.createElement("div", {
      className: r.basicChildStyle,
      role: "treeitem",
      "aria-selected": void 0
    }, (t || t === "") && /* @__PURE__ */ T.createElement("span", {
      className: r.label
    }, i0(t, r.quotesForFieldNames), ":"), /* @__PURE__ */ T.createElement("span", {
      className: a
    }, i), !o && /* @__PURE__ */ T.createElement("span", {
      className: r.punctuation
    }, ","));
  }
  function b6(e) {
    const t = e.value;
    return Ble(t) ? /* @__PURE__ */ T.createElement(Wle, Object.assign({}, e)) : Ule(t) && !g6(t) && !y6(t) ? /* @__PURE__ */ T.createElement(qle, Object.assign({}, e)) : /* @__PURE__ */ T.createElement(Gle, Object.assign({}, e));
  }
  var Ht = { "container-light": "_2IvMF _GzYRV", "basic-element-style": "_2bkNM", "child-fields-container": "_1BXBN", "label-light": "_1MGIk", "clickable-label-light": "_2YKJg _1MGIk _1MFti", "punctuation-light": "_3uHL6 _3eOF8", "value-null-light": "_2T6PJ", "value-undefined-light": "_1Gho6", "value-string-light": "_vGjyY", "value-number-light": "_1bQdo", "value-boolean-light": "_3zQKs", "value-other-light": "_1xvuR", "collapse-icon-light": "_oLqym _f10Tu _1MFti _1LId0", "expand-icon-light": "_2AXVT _f10Tu _1MFti _1UmXx", "collapsed-content-light": "_2KJWg _1pNG9 _1MFti", "container-dark": "_11RoI _GzYRV", "expand-icon-dark": "_17H2C _f10Tu _1MFti _1UmXx", "collapse-icon-dark": "_3QHg2 _f10Tu _1MFti _1LId0", "collapsed-content-dark": "_3fDAz _1pNG9 _1MFti", "label-dark": "_2bSDX", "clickable-label-dark": "_1RQEj _2bSDX _1MFti", "punctuation-dark": "_gsbQL _3eOF8", "value-null-dark": "_LaAZe", "value-undefined-dark": "_GTKgm", "value-string-dark": "_Chy1W", "value-number-dark": "_2bveF", "value-boolean-dark": "_2vRm-", "value-other-dark": "_1prJR" };
  const x6 = {
    collapseJson: "collapse JSON",
    expandJson: "expand JSON"
  }, k2 = {
    container: Ht["container-light"],
    basicChildStyle: Ht["basic-element-style"],
    childFieldsContainer: Ht["child-fields-container"],
    label: Ht["label-light"],
    clickableLabel: Ht["clickable-label-light"],
    nullValue: Ht["value-null-light"],
    undefinedValue: Ht["value-undefined-light"],
    stringValue: Ht["value-string-light"],
    booleanValue: Ht["value-boolean-light"],
    numberValue: Ht["value-number-light"],
    otherValue: Ht["value-other-light"],
    punctuation: Ht["punctuation-light"],
    collapseIcon: Ht["collapse-icon-light"],
    expandIcon: Ht["expand-icon-light"],
    collapsedContent: Ht["collapsed-content-light"],
    noQuotesForStringValues: !1,
    quotesForFieldNames: !1,
    ariaLables: x6,
    stringifyStringValues: !1
  }, Kle = {
    container: Ht["container-dark"],
    basicChildStyle: Ht["basic-element-style"],
    childFieldsContainer: Ht["child-fields-container"],
    label: Ht["label-dark"],
    clickableLabel: Ht["clickable-label-dark"],
    nullValue: Ht["value-null-dark"],
    undefinedValue: Ht["value-undefined-dark"],
    stringValue: Ht["value-string-dark"],
    booleanValue: Ht["value-boolean-dark"],
    numberValue: Ht["value-number-dark"],
    otherValue: Ht["value-other-dark"],
    punctuation: Ht["punctuation-dark"],
    collapseIcon: Ht["collapse-icon-dark"],
    expandIcon: Ht["expand-icon-dark"],
    collapsedContent: Ht["collapsed-content-dark"],
    noQuotesForStringValues: !1,
    quotesForFieldNames: !1,
    ariaLables: x6,
    stringifyStringValues: !1
  }, Yle = () => !0, Xle = (e) => e < 1, Zle = (e) => {
    let {
      data: t,
      style: n = k2,
      shouldExpandNode: r = Yle,
      clickToExpandNode: o = !1,
      beforeExpandChange: i,
      ...a
    } = e;
    const s = T.useRef(null);
    return /* @__PURE__ */ T.createElement("div", Object.assign({
      "aria-label": "JSON view"
    }, a, {
      className: n.container,
      ref: s,
      role: "tree"
    }), /* @__PURE__ */ T.createElement(b6, {
      value: t,
      style: {
        ...k2,
        ...n
      },
      lastElement: !0,
      level: 0,
      shouldExpandNode: r,
      clickToExpandNode: o,
      outerRef: s,
      beforeExpandChange: i
    }));
  };
  function Qle(e) {
    for (const t in e)
      if (Object.hasOwn(e, t))
        return !1;
    return !0;
  }
  function Jle(e) {
    if (e == null || typeof e != "object")
      return !1;
    const t = Object.getPrototypeOf(e);
    return t !== null && t !== Object.prototype ? !1 : Qle(e);
  }
  const ece = ({
    data: e,
    className: t = "json-display"
  }) => /* @__PURE__ */ S.jsx("div", { className: t, children: /* @__PURE__ */ S.jsx(
    Zle,
    {
      data: Jle(e) ? "" : e,
      style: Kle,
      shouldExpandNode: Xle
    }
  ) });
  function tce(e, t, n = {}) {
    const {
      maxFontSize: r = 100,
      // default maximum font size
      minFontSize: o = 6,
      // default minimum font size
      decrementFactor: i = 0.9
      // font size decrement step
    } = n;
    if (!e || !t)
      return;
    if (i >= 1 || i <= 0)
      throw new Error("decrementFactor must be between 0 and 1");
    const a = e.getBoundingClientRect(), s = a.width, l = a.height;
    let u = r;
    t.style.whiteSpace = "nowrap", t.style.display = "inline-block", t.style.fontSize = u + "px";
    let d = t.getBoundingClientRect();
    for (; (d.width > s || d.height > l) && u > o; )
      u *= i, t.style.fontSize = u + "px", d = t.getBoundingClientRect();
  }
  function nce(e = {
    n: 0,
    elapsed: 0,
    ascii: !1,
    unit: "it",
    unit_scale: !1,
    unit_divisor: 1e3
  }) {
    let t = e.total ?? null;
    const {
      n = 0,
      unit_scale: r = !1,
      elapsed: o = 0,
      // ascii,
      unit: i = "it",
      unit_divisor: a = 1e3,
      // ncols = undefined,
      prefix: s = "",
      rate: l = void 0,
      // bar_format = undefined,
      postfix: u = null,
      initial: d = 0
      // colour = undefined,
    } = e;
    t !== null && n >= t + 0.5 && (t = null);
    let p = n, h = t, g = l;
    r && r !== !0 && r !== 1 && (t !== null && (h = t * r), p = n * r, l !== void 0 && (g = l * r));
    const y = T2(o);
    g === void 0 && o > 0 && (g = (p - d) / o);
    const b = g ? 1 / g : void 0, [v, x] = g ? Kg(g, a) : [void 0, ""], [E, _] = b ? Kg(b, 1e3) : [void 0, ""], C = (v || "?") + `${x}${i}/s`, k = E ? `${E}${_}s/` + i : "?", R = b && b > 1 ? k : C, A = r ? Kg(p, a).join("") : p.toString(), M = r && h !== null ? Kg(h, a).join("") : h?.toString() ?? "?", I = g && h !== null ? (h - p) / g : 0, D = g ? T2(I) : "?", L = s ? `${s}: ` : "";
    if (t !== null) {
      const P = p / t * 100, B = ` ${A}/${M} [${y} < ${D}, ${R}${u ?? ""}]`;
      return `${L}${P.toFixed(0)}%${B}`;
    }
    return `${L}${A}${i} [${y}, ${R}${u ?? ""}]`;
  }
  function T2(e) {
    const t = Math.floor(e / 60), n = Math.floor(e % 60);
    return `${t}:${n.toString().padStart(2, "0")}`;
  }
  function Kg(e, t) {
    const n = ["", "K", "M", "G", "T"];
    let r = 0;
    for (; e >= t && r < n.length - 1; )
      e /= t, r++;
    return [e.toFixed(2), n[r]];
  }
  const rce = ({ state: e, className: t = "reacttqdm", ...n }) => {
    const r = T.useRef(null), o = T.useRef(null);
    T.useEffect(() => {
      const a = () => {
        !r.current || !o.current || tce(r.current, o.current, {
          maxFontSize: 12,
          decrementFactor: 0.9
        });
      };
      return a(), window.addEventListener("resize", a), () => {
        window.removeEventListener("resize", a);
      };
    }, [e]);
    const i = e.total ? (e.n ?? 0) / e.total * 100 : 0;
    return /* @__PURE__ */ S.jsx("div", { ref: r, className: t, ...n, children: /* @__PURE__ */ S.jsxs(
      "div",
      {
        style: {
          position: "relative",
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center"
        },
        children: [
          /* @__PURE__ */ S.jsx(
            "div",
            {
              className: t + "-bar",
              style: {
                position: "absolute",
                width: "100%",
                height: "100%",
                // Adjust height if needed
                overflow: "hidden"
              },
              children: /* @__PURE__ */ S.jsx(
                "div",
                {
                  className: t + "-progress",
                  style: {
                    width: `${i}%`,
                    height: "100%"
                  }
                }
              )
            }
          ),
          /* @__PURE__ */ S.jsx("div", { className: t + "-text", ref: o, children: nce(e) })
        ]
      }
    ) });
  };
  var Yg = {};
  /*!
   * content-type
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var R2;
  function oce() {
    if (R2) return Yg;
    R2 = 1;
    var e = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, t = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, n = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, r = /\\([\u000b\u0020-\u00ff])/g, o = /([\\"])/g, i = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
    Yg.format = a, Yg.parse = s;
    function a(p) {
      if (!p || typeof p != "object")
        throw new TypeError("argument obj is required");
      var h = p.parameters, g = p.type;
      if (!g || !i.test(g))
        throw new TypeError("invalid type");
      var y = g;
      if (h && typeof h == "object")
        for (var b, v = Object.keys(h).sort(), x = 0; x < v.length; x++) {
          if (b = v[x], !n.test(b))
            throw new TypeError("invalid parameter name");
          y += "; " + b + "=" + u(h[b]);
        }
      return y;
    }
    function s(p) {
      if (!p)
        throw new TypeError("argument string is required");
      var h = typeof p == "object" ? l(p) : p;
      if (typeof h != "string")
        throw new TypeError("argument string is required to be a string");
      var g = h.indexOf(";"), y = g !== -1 ? h.slice(0, g).trim() : h.trim();
      if (!i.test(y))
        throw new TypeError("invalid media type");
      var b = new d(y.toLowerCase());
      if (g !== -1) {
        var v, x, E;
        for (e.lastIndex = g; x = e.exec(h); ) {
          if (x.index !== g)
            throw new TypeError("invalid parameter format");
          g += x[0].length, v = x[1].toLowerCase(), E = x[2], E.charCodeAt(0) === 34 && (E = E.slice(1, -1), E.indexOf("\\") !== -1 && (E = E.replace(r, "$1"))), b.parameters[v] = E;
        }
        if (g !== h.length)
          throw new TypeError("invalid parameter format");
      }
      return b;
    }
    function l(p) {
      var h;
      if (typeof p.getHeader == "function" ? h = p.getHeader("content-type") : typeof p.headers == "object" && (h = p.headers && p.headers["content-type"]), typeof h != "string")
        throw new TypeError("content-type header is missing from object");
      return h;
    }
    function u(p) {
      var h = String(p);
      if (n.test(h))
        return h;
      if (h.length > 0 && !t.test(h))
        throw new TypeError("invalid parameter value");
      return '"' + h.replace(o, "\\$1") + '"';
    }
    function d(p) {
      this.parameters = /* @__PURE__ */ Object.create(null), this.type = p;
    }
    return Yg;
  }
  var ice = oce(), Pu = /* @__PURE__ */ new Map(), w6 = function(t) {
    return t.cloneNode(!0);
  }, O2 = function() {
    return window.location.protocol === "file:";
  }, S6 = function(t, n, r) {
    var o = new XMLHttpRequest();
    o.onreadystatechange = function() {
      try {
        if (!/\.svg/i.test(t) && o.readyState === 2) {
          var i = o.getResponseHeader("Content-Type");
          if (!i)
            throw new Error("Content type not found");
          var a = ice.parse(i).type;
          if (!(a === "image/svg+xml" || a === "text/plain"))
            throw new Error("Invalid content type: ".concat(a));
        }
        if (o.readyState === 4) {
          if (o.status === 404 || o.responseXML === null)
            throw new Error(O2() ? "Note: SVG injection ajax calls do not work locally without adjusting security settings in your browser. Or consider using a local webserver." : "Unable to load SVG file: " + t);
          if (o.status === 200 || O2() && o.status === 0)
            r(null, o);
          else
            throw new Error("There was a problem injecting the SVG: " + o.status + " " + o.statusText);
        }
      } catch (s) {
        if (o.abort(), s instanceof Error)
          r(s, o);
        else
          throw s;
      }
    }, o.open("GET", t), o.withCredentials = n, o.overrideMimeType && o.overrideMimeType("text/xml"), o.send();
  }, Ls = {}, A2 = function(t, n) {
    Ls[t] = Ls[t] || [], Ls[t].push(n);
  }, ace = function(t) {
    for (var n = function(a, s) {
      setTimeout(function() {
        if (Array.isArray(Ls[t])) {
          var l = Pu.get(t), u = Ls[t][a];
          l instanceof SVGSVGElement && u(null, w6(l)), l instanceof Error && u(l), a === Ls[t].length - 1 && delete Ls[t];
        }
      }, 0);
    }, r = 0, o = Ls[t].length; r < o; r++)
      n(r);
  }, sce = function(t, n, r) {
    if (Pu.has(t)) {
      var o = Pu.get(t);
      if (o === void 0) {
        A2(t, r);
        return;
      }
      if (o instanceof SVGSVGElement) {
        r(null, w6(o));
        return;
      }
    }
    Pu.set(t, void 0), A2(t, r), S6(t, n, function(i, a) {
      var s;
      i ? Pu.set(t, i) : ((s = a.responseXML) === null || s === void 0 ? void 0 : s.documentElement) instanceof SVGSVGElement && Pu.set(t, a.responseXML.documentElement), ace(t);
    });
  }, lce = function(t, n, r) {
    S6(t, n, function(o, i) {
      var a;
      o ? r(o) : ((a = i.responseXML) === null || a === void 0 ? void 0 : a.documentElement) instanceof SVGSVGElement && r(null, i.responseXML.documentElement);
    });
  }, cce = 0, uce = function() {
    return ++cce;
  }, pi = [], N2 = {}, fce = "http://www.w3.org/2000/svg", NS = "http://www.w3.org/1999/xlink", M2 = function(t, n, r, o, i, a, s) {
    var l = t.getAttribute("data-src") || t.getAttribute("src");
    if (!l) {
      s(new Error("Invalid data-src or src attribute"));
      return;
    }
    if (pi.indexOf(t) !== -1) {
      pi.splice(pi.indexOf(t), 1), t = null;
      return;
    }
    pi.push(t), t.setAttribute("src", "");
    var u = o ? sce : lce;
    u(l, i, function(d, p) {
      if (!p) {
        pi.splice(pi.indexOf(t), 1), t = null, s(d);
        return;
      }
      var h = t.getAttribute("id");
      h && p.setAttribute("id", h);
      var g = t.getAttribute("title");
      g && p.setAttribute("title", g);
      var y = t.getAttribute("width");
      y && p.setAttribute("width", y);
      var b = t.getAttribute("height");
      b && p.setAttribute("height", b);
      var v = Array.from(new Set(dv(dv(dv([], (p.getAttribute("class") || "").split(" "), !0), ["injected-svg"], !1), (t.getAttribute("class") || "").split(" "), !0))).join(" ").trim();
      p.setAttribute("class", v);
      var x = t.getAttribute("style");
      x && p.setAttribute("style", x), p.setAttribute("data-src", l);
      var E = [].filter.call(t.attributes, function(W) {
        return /^data-\w[\w-]*$/.test(W.name);
      });
      if (Array.prototype.forEach.call(E, function(W) {
        W.name && W.value && p.setAttribute(W.name, W.value);
      }), r) {
        var _ = {
          clipPath: ["clip-path"],
          "color-profile": ["color-profile"],
          cursor: ["cursor"],
          filter: ["filter"],
          linearGradient: ["fill", "stroke"],
          marker: ["marker", "marker-start", "marker-mid", "marker-end"],
          mask: ["mask"],
          path: [],
          pattern: ["fill", "stroke"],
          radialGradient: ["fill", "stroke"]
        }, C, k, R, A, M;
        Object.keys(_).forEach(function(W) {
          C = W, R = _[W], k = p.querySelectorAll(C + "[id]");
          for (var K = function(z, H) {
            A = k[z].id, M = A + "-" + uce();
            var Y;
            Array.prototype.forEach.call(R, function(ie) {
              Y = p.querySelectorAll("[" + ie + '*="' + A + '"]');
              for (var ae = 0, ge = Y.length; ae < ge; ae++) {
                var Ce = Y[ae].getAttribute(ie);
                Ce && !Ce.match(new RegExp('url\\("?#' + A + '"?\\)')) || Y[ae].setAttribute(ie, "url(#" + M + ")");
              }
            });
            for (var Q = p.querySelectorAll("[*|href]"), re = [], te = 0, le = Q.length; te < le; te++) {
              var fe = Q[te].getAttributeNS(NS, "href");
              fe && fe.toString() === "#" + k[z].id && re.push(Q[te]);
            }
            for (var J = 0, ee = re.length; J < ee; J++)
              re[J].setAttributeNS(NS, "href", "#" + M);
            k[z].id = M;
          }, $ = 0, U = k.length; $ < U; $++)
            K($);
        });
      }
      p.removeAttribute("xmlns:a");
      for (var I = p.querySelectorAll("script"), D = [], L, P, B = 0, j = I.length; B < j; B++)
        P = I[B].getAttribute("type"), (!P || P === "application/ecmascript" || P === "application/javascript" || P === "text/javascript") && (L = I[B].innerText || I[B].textContent, L && D.push(L), p.removeChild(I[B]));
      if (D.length > 0 && (n === "always" || n === "once" && !N2[l])) {
        for (var V = 0, F = D.length; V < F; V++)
          new Function(D[V])(window);
        N2[l] = !0;
      }
      var G = p.querySelectorAll("style");
      if (Array.prototype.forEach.call(G, function(W) {
        W.textContent += "";
      }), p.setAttribute("xmlns", fce), p.setAttribute("xmlns:xlink", NS), a(p), !t.parentNode) {
        pi.splice(pi.indexOf(t), 1), t = null, s(new Error("Parent node is null"));
        return;
      }
      t.parentNode.replaceChild(p, t), pi.splice(pi.indexOf(t), 1), t = null, s(null, p);
    });
  }, dce = function(t, n) {
    var r = n === void 0 ? {} : n, o = r.afterAll, i = o === void 0 ? function() {
    } : o, a = r.afterEach, s = a === void 0 ? function() {
    } : a, l = r.beforeEach, u = l === void 0 ? function() {
    } : l, d = r.cacheRequests, p = d === void 0 ? !0 : d, h = r.evalScripts, g = h === void 0 ? "never" : h, y = r.httpRequestWithCredentials, b = y === void 0 ? !1 : y, v = r.renumerateIRIElements, x = v === void 0 ? !0 : v;
    if (t && "length" in t)
      for (var E = 0, _ = 0, C = t.length; _ < C; _++)
        M2(t[_], g, x, p, b, u, function(k, R) {
          s(k, R), t && "length" in t && t.length === ++E && i(E);
        });
    else t ? M2(t, g, x, p, b, u, function(k, R) {
      s(k, R), i(1), t = null;
    }) : i(0);
  }, pce = function(t) {
    var n = t?.ownerDocument || document;
    return n.defaultView || window;
  }, hce = function(t, n) {
    for (var r in t)
      if (!(r in n))
        return !0;
    for (var o in n)
      if (t[o] !== n[o])
        return !0;
    return !1;
  }, mce = ["afterInjection", "beforeInjection", "desc", "evalScripts", "fallback", "httpRequestWithCredentials", "loading", "renumerateIRIElements", "src", "title", "useRequestCache", "wrapper"], Xg = "http://www.w3.org/2000/svg", P2 = "http://www.w3.org/1999/xlink", iT = /* @__PURE__ */ function(e) {
    function t() {
      for (var r, o = arguments.length, i = new Array(o), a = 0; a < o; a++)
        i[a] = arguments[a];
      return r = e.call.apply(e, [this].concat(i)) || this, r.initialState = {
        hasError: !1,
        isLoading: !0
      }, r.state = r.initialState, r._isMounted = !1, r.reactWrapper = void 0, r.nonReactWrapper = void 0, r.refCallback = function(s) {
        r.reactWrapper = s;
      }, r;
    }
    xk(t, e);
    var n = t.prototype;
    return n.renderSVG = function() {
      var o = this;
      if (this.reactWrapper instanceof pce(this.reactWrapper).Node) {
        var i = this.props, a = i.desc, s = i.evalScripts, l = i.httpRequestWithCredentials, u = i.renumerateIRIElements, d = i.src, p = i.title, h = i.useRequestCache, g = this.props.onError, y = this.props.beforeInjection, b = this.props.afterInjection, v = this.props.wrapper, x, E;
        v === "svg" ? (x = document.createElementNS(Xg, v), x.setAttribute("xmlns", Xg), x.setAttribute("xmlns:xlink", P2), E = document.createElementNS(Xg, v)) : (x = document.createElement(v), E = document.createElement(v)), x.appendChild(E), E.dataset.src = d, this.nonReactWrapper = this.reactWrapper.appendChild(x);
        var _ = function(A) {
          if (o.removeSVG(), !o._isMounted) {
            g(A);
            return;
          }
          o.setState(function() {
            return {
              hasError: !0,
              isLoading: !1
            };
          }, function() {
            g(A);
          });
        }, C = function(A, M) {
          if (A) {
            _(A);
            return;
          }
          o._isMounted && o.setState(function() {
            return {
              isLoading: !1
            };
          }, function() {
            try {
              b(M);
            } catch (I) {
              _(I);
            }
          });
        }, k = function(A) {
          if (A.setAttribute("role", "img"), a) {
            var M = A.querySelector(":scope > desc");
            M && A.removeChild(M);
            var I = document.createElement("desc");
            I.innerHTML = a, A.prepend(I);
          }
          if (p) {
            var D = A.querySelector(":scope > title");
            D && A.removeChild(D);
            var L = document.createElement("title");
            L.innerHTML = p, A.prepend(L);
          }
          try {
            y(A);
          } catch (P) {
            _(P);
          }
        };
        dce(E, {
          afterEach: C,
          beforeEach: k,
          cacheRequests: h,
          evalScripts: s,
          httpRequestWithCredentials: l,
          renumerateIRIElements: u
        });
      }
    }, n.removeSVG = function() {
      var o;
      (o = this.nonReactWrapper) != null && o.parentNode && (this.nonReactWrapper.parentNode.removeChild(this.nonReactWrapper), this.nonReactWrapper = null);
    }, n.componentDidMount = function() {
      this._isMounted = !0, this.renderSVG();
    }, n.componentDidUpdate = function(o) {
      var i = this;
      hce(Ge({}, o), this.props) && this.setState(function() {
        return i.initialState;
      }, function() {
        i.removeSVG(), i.renderSVG();
      });
    }, n.componentWillUnmount = function() {
      this._isMounted = !1, this.removeSVG();
    }, n.render = function() {
      var o = this.props;
      o.afterInjection, o.beforeInjection, o.desc, o.evalScripts;
      var i = o.fallback;
      o.httpRequestWithCredentials;
      var a = o.loading;
      o.renumerateIRIElements, o.src, o.title, o.useRequestCache;
      var s = o.wrapper, l = sb(o, mce), u = s;
      return /* @__PURE__ */ T.createElement(u, Ge({}, l, {
        ref: this.refCallback
      }, s === "svg" ? {
        xmlns: Xg,
        xmlnsXlink: P2
      } : {}), this.state.isLoading && a && /* @__PURE__ */ T.createElement(a, null), this.state.hasError && i && /* @__PURE__ */ T.createElement(i, null));
    }, t;
  }(T.Component);
  iT.defaultProps = {
    afterInjection: function() {
    },
    beforeInjection: function() {
    },
    desc: "",
    evalScripts: "never",
    fallback: null,
    httpRequestWithCredentials: !1,
    loading: null,
    onError: function() {
    },
    renumerateIRIElements: !0,
    title: "",
    useRequestCache: !0,
    wrapper: "div"
  };
  iT.propTypes = {
    afterInjection: Fn.func,
    beforeInjection: Fn.func,
    desc: Fn.string,
    evalScripts: Fn.oneOf(["always", "once", "never"]),
    fallback: Fn.oneOfType([Fn.func, Fn.object, Fn.string]),
    httpRequestWithCredentials: Fn.bool,
    loading: Fn.oneOfType([Fn.func, Fn.object, Fn.string]),
    onError: Fn.func,
    renumerateIRIElements: Fn.bool,
    src: Fn.string.isRequired,
    title: Fn.string,
    useRequestCache: Fn.bool,
    wrapper: Fn.oneOf(["div", "span", "svg"])
  };
  const aT = ({
    text: e = "No image data provided"
  }) => /* @__PURE__ */ S.jsx(
    "div",
    {
      style: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        minHeight: "100px",
        border: "1px dashed #ccc",
        color: "#666"
      },
      children: e
    }
  ), gce = T.memo(
    ({
      value: e,
      format: t = "jpeg",
      alt: n = "Base64 image",
      onError: r,
      onLoad: o,
      ...i
    }) => {
      const [a, s] = T.useState(!1), [l, u] = T.useState(!0), d = T.useRef(null), p = T.useMemo(() => {
        if (typeof e == "string")
          return e;
        if (e && typeof e == "object" && "data" in e) {
          const b = e.data;
          if (b instanceof ArrayBuffer) {
            const v = new Uint8Array(b);
            let x = "";
            for (let E = 0; E < v.byteLength; E++)
              x += String.fromCharCode(v[E]);
            return btoa(x);
          }
        }
        return "";
      }, [e]), h = T.useMemo(() => p ? `data:image/${t};base64,${p}` : "", [p, t]), g = T.useCallback(
        (b) => {
          s(!0), u(!1), r?.(b);
        },
        [r]
      ), y = T.useCallback(() => {
        u(!1), s(!1), o?.();
      }, [o]);
      return T.useEffect(() => {
        const b = d.current;
        if (b)
          return b.addEventListener("error", g), b.addEventListener("load", y), () => {
            b.removeEventListener("error", g), b.removeEventListener("load", y);
          };
      }, [g, y, e]), T.useEffect(() => {
        s(!1), u(!0);
      }, [e]), p ? a ? /* @__PURE__ */ S.jsx(
        "div",
        {
          style: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            minHeight: "100px",
            border: "1px dashed #ccc",
            color: "#666"
          },
          children: "Failed to load base64 image"
        }
      ) : /* @__PURE__ */ S.jsx(
        "img",
        {
          ref: d,
          src: h,
          alt: n,
          className: `base64-image-renderer image-renderer ${i.className || ""} ${l ? " loading" : ""}`,
          ...i
        }
      ) : /* @__PURE__ */ S.jsx(aT, {});
    }
  ), yce = T.memo(
    ({
      value: e,
      alt: t = "SVG image",
      onError: n,
      onLoad: r,
      ...o
    }) => {
      const [i, a] = T.useState(!1), s = T.useMemo(() => {
        if (!e) return "";
        try {
          return `data:image/svg+xml;base64,${btoa(e)}`;
        } catch (u) {
          return console.error("Failed to encode SVG to base64:", u), "";
        }
      }, [e]);
      T.useEffect(() => {
        a(!1);
      }, [e]);
      const l = T.useCallback(
        (u) => {
          a(!0), n?.(u);
        },
        [n]
      );
      return e ? i || !s ? /* @__PURE__ */ S.jsx(
        "div",
        {
          style: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            minHeight: "100px",
            border: "1px dashed #ccc",
            color: "#666"
          },
          children: "Failed to load SVG"
        }
      ) : /* @__PURE__ */ S.jsx(
        iT,
        {
          src: s,
          className: `svg-renderer ${o.className || ""}`,
          style: {
            maxWidth: "100%",
            maxHeight: "100%",
            ...o.style
          },
          beforeInjection: (u) => {
            u.classList.add("svg-renderer"), u.setAttribute("style", "max-width: 100%; max-height: 100%;"), u.setAttribute("width", "100%"), u.setAttribute("height", "100%"), u.setAttribute("aria-label", t);
            const d = () => {
              a(!1), r?.();
            }, p = (h) => {
              a(!0), n?.(h);
            };
            try {
              u.addEventListener("load", d), u.addEventListener("error", p);
            } catch {
              d();
            }
          },
          onError: l
        }
      ) : /* @__PURE__ */ S.jsx(aT, {});
    }
  ), vce = T.memo(
    ({
      src: e,
      alt: t = "Streaming image",
      onError: n,
      onLoad: r,
      ...o
    }) => {
      const i = T.useRef(null), [a, s] = T.useState(!1), [l, u] = T.useState(!0);
      T.useEffect(() => {
        i.current && e && (u(!0), s(!1), i.current.src = e);
      }, [e]);
      const d = T.useCallback(
        (h) => {
          s(!0), u(!1), n?.(h);
        },
        [n]
      ), p = T.useCallback(() => {
        u(!1), s(!1), r?.();
      }, [r]);
      return T.useEffect(() => {
        const h = i.current;
        if (h)
          return h.addEventListener("error", d), h.addEventListener("load", p), () => {
            h.removeEventListener("error", d), h.removeEventListener("load", p);
          };
      }, [d, p]), a ? /* @__PURE__ */ S.jsx(aT, { text: "Failed to load image" }) : /* @__PURE__ */ S.jsx(
        "img",
        {
          ref: i,
          className: `streaming-image image-renderer ${o.className || ""} ${l ? " loading" : ""}`,
          alt: t,
          ...o
        }
      );
    }
  );
  function kb(e) {
    const t = e + "CollectionProvider", [n, r] = Yi(t), [o, i] = n(
      t,
      { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
    ), a = (b) => {
      const { scope: v, children: x } = b, E = Tn.useRef(null), _ = Tn.useRef(/* @__PURE__ */ new Map()).current;
      return /* @__PURE__ */ S.jsx(o, { scope: v, itemMap: _, collectionRef: E, children: x });
    };
    a.displayName = t;
    const s = e + "CollectionSlot", l = /* @__PURE__ */ nf(s), u = Tn.forwardRef(
      (b, v) => {
        const { scope: x, children: E } = b, _ = i(s, x), C = an(v, _.collectionRef);
        return /* @__PURE__ */ S.jsx(l, { ref: C, children: E });
      }
    );
    u.displayName = s;
    const d = e + "CollectionItemSlot", p = "data-radix-collection-item", h = /* @__PURE__ */ nf(d), g = Tn.forwardRef(
      (b, v) => {
        const { scope: x, children: E, ..._ } = b, C = Tn.useRef(null), k = an(v, C), R = i(d, x);
        return Tn.useEffect(() => (R.itemMap.set(C, { ref: C, ..._ }), () => void R.itemMap.delete(C))), /* @__PURE__ */ S.jsx(h, { [p]: "", ref: k, children: E });
      }
    );
    g.displayName = d;
    function y(b) {
      const v = i(e + "CollectionConsumer", b);
      return Tn.useCallback(() => {
        const E = v.collectionRef.current;
        if (!E) return [];
        const _ = Array.from(E.querySelectorAll(`[${p}]`));
        return Array.from(v.itemMap.values()).sort(
          (R, A) => _.indexOf(R.ref.current) - _.indexOf(A.ref.current)
        );
      }, [v.collectionRef, v.itemMap]);
    }
    return [
      { Provider: a, Slot: u, ItemSlot: g },
      y,
      r
    ];
  }
  var bce = Object.freeze({
    // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
    position: "absolute",
    border: 0,
    width: 1,
    height: 1,
    padding: 0,
    margin: -1,
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    wordWrap: "normal"
  }), xce = "VisuallyHidden", sT = T.forwardRef(
    (e, t) => /* @__PURE__ */ S.jsx(
      xt.span,
      {
        ...e,
        ref: t,
        style: { ...bce, ...e.style }
      }
    )
  );
  sT.displayName = xce;
  var lT = "ToastProvider", [cT, wce, Sce] = kb("Toast"), [_6, VLe] = Yi("Toast", [Sce]), [_ce, Tb] = _6(lT), E6 = (e) => {
    const {
      __scopeToast: t,
      label: n = "Notification",
      duration: r = 5e3,
      swipeDirection: o = "right",
      swipeThreshold: i = 50,
      children: a
    } = e, [s, l] = T.useState(null), [u, d] = T.useState(0), p = T.useRef(!1), h = T.useRef(!1);
    return n.trim() || console.error(
      `Invalid prop \`label\` supplied to \`${lT}\`. Expected non-empty \`string\`.`
    ), /* @__PURE__ */ S.jsx(cT.Provider, { scope: t, children: /* @__PURE__ */ S.jsx(
      _ce,
      {
        scope: t,
        label: n,
        duration: r,
        swipeDirection: o,
        swipeThreshold: i,
        toastCount: u,
        viewport: s,
        onViewportChange: l,
        onToastAdd: T.useCallback(() => d((g) => g + 1), []),
        onToastRemove: T.useCallback(() => d((g) => g - 1), []),
        isFocusedToastEscapeKeyDownRef: p,
        isClosePausedRef: h,
        children: a
      }
    ) });
  };
  E6.displayName = lT;
  var C6 = "ToastViewport", Ece = ["F8"], BE = "toast.viewportPause", UE = "toast.viewportResume", k6 = T.forwardRef(
    (e, t) => {
      const {
        __scopeToast: n,
        hotkey: r = Ece,
        label: o = "Notifications ({hotkey})",
        ...i
      } = e, a = Tb(C6, n), s = wce(n), l = T.useRef(null), u = T.useRef(null), d = T.useRef(null), p = T.useRef(null), h = an(t, p, a.onViewportChange), g = r.join("+").replace(/Key/g, "").replace(/Digit/g, ""), y = a.toastCount > 0;
      T.useEffect(() => {
        const v = (x) => {
          r.length !== 0 && r.every((_) => x[_] || x.code === _) && p.current?.focus();
        };
        return document.addEventListener("keydown", v), () => document.removeEventListener("keydown", v);
      }, [r]), T.useEffect(() => {
        const v = l.current, x = p.current;
        if (y && v && x) {
          const E = () => {
            if (!a.isClosePausedRef.current) {
              const R = new CustomEvent(BE);
              x.dispatchEvent(R), a.isClosePausedRef.current = !0;
            }
          }, _ = () => {
            if (a.isClosePausedRef.current) {
              const R = new CustomEvent(UE);
              x.dispatchEvent(R), a.isClosePausedRef.current = !1;
            }
          }, C = (R) => {
            !v.contains(R.relatedTarget) && _();
          }, k = () => {
            v.contains(document.activeElement) || _();
          };
          return v.addEventListener("focusin", E), v.addEventListener("focusout", C), v.addEventListener("pointermove", E), v.addEventListener("pointerleave", k), window.addEventListener("blur", E), window.addEventListener("focus", _), () => {
            v.removeEventListener("focusin", E), v.removeEventListener("focusout", C), v.removeEventListener("pointermove", E), v.removeEventListener("pointerleave", k), window.removeEventListener("blur", E), window.removeEventListener("focus", _);
          };
        }
      }, [y, a.isClosePausedRef]);
      const b = T.useCallback(
        ({ tabbingDirection: v }) => {
          const E = s().map((_) => {
            const C = _.ref.current, k = [C, ...Dce(C)];
            return v === "forwards" ? k : k.reverse();
          });
          return (v === "forwards" ? E.reverse() : E).flat();
        },
        [s]
      );
      return T.useEffect(() => {
        const v = p.current;
        if (v) {
          const x = (E) => {
            const _ = E.altKey || E.ctrlKey || E.metaKey;
            if (E.key === "Tab" && !_) {
              const k = document.activeElement, R = E.shiftKey;
              if (E.target === v && R) {
                u.current?.focus();
                return;
              }
              const I = b({ tabbingDirection: R ? "backwards" : "forwards" }), D = I.findIndex((L) => L === k);
              MS(I.slice(D + 1)) ? E.preventDefault() : R ? u.current?.focus() : d.current?.focus();
            }
          };
          return v.addEventListener("keydown", x), () => v.removeEventListener("keydown", x);
        }
      }, [s, b]), /* @__PURE__ */ S.jsxs(
        rJ,
        {
          ref: l,
          role: "region",
          "aria-label": o.replace("{hotkey}", g),
          tabIndex: -1,
          style: { pointerEvents: y ? void 0 : "none" },
          children: [
            y && /* @__PURE__ */ S.jsx(
              VE,
              {
                ref: u,
                onFocusFromOutsideViewport: () => {
                  const v = b({
                    tabbingDirection: "forwards"
                  });
                  MS(v);
                }
              }
            ),
            /* @__PURE__ */ S.jsx(cT.Slot, { scope: n, children: /* @__PURE__ */ S.jsx(xt.ol, { tabIndex: -1, ...i, ref: h }) }),
            y && /* @__PURE__ */ S.jsx(
              VE,
              {
                ref: d,
                onFocusFromOutsideViewport: () => {
                  const v = b({
                    tabbingDirection: "backwards"
                  });
                  MS(v);
                }
              }
            )
          ]
        }
      );
    }
  );
  k6.displayName = C6;
  var T6 = "ToastFocusProxy", VE = T.forwardRef(
    (e, t) => {
      const { __scopeToast: n, onFocusFromOutsideViewport: r, ...o } = e, i = Tb(T6, n);
      return /* @__PURE__ */ S.jsx(
        sT,
        {
          "aria-hidden": !0,
          tabIndex: 0,
          ...o,
          ref: t,
          style: { position: "fixed" },
          onFocus: (a) => {
            const s = a.relatedTarget;
            !i.viewport?.contains(s) && r();
          }
        }
      );
    }
  );
  VE.displayName = T6;
  var Vh = "Toast", Cce = "toast.swipeStart", kce = "toast.swipeMove", Tce = "toast.swipeCancel", Rce = "toast.swipeEnd", R6 = T.forwardRef(
    (e, t) => {
      const { forceMount: n, open: r, defaultOpen: o, onOpenChange: i, ...a } = e, [s, l] = ll({
        prop: r,
        defaultProp: o ?? !0,
        onChange: i,
        caller: Vh
      });
      return /* @__PURE__ */ S.jsx(ei, { present: n || s, children: /* @__PURE__ */ S.jsx(
        Nce,
        {
          open: s,
          ...a,
          ref: t,
          onClose: () => l(!1),
          onPause: Vr(e.onPause),
          onResume: Vr(e.onResume),
          onSwipeStart: Fe(e.onSwipeStart, (u) => {
            u.currentTarget.setAttribute("data-swipe", "start");
          }),
          onSwipeMove: Fe(e.onSwipeMove, (u) => {
            const { x: d, y: p } = u.detail.delta;
            u.currentTarget.setAttribute("data-swipe", "move"), u.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${d}px`), u.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${p}px`);
          }),
          onSwipeCancel: Fe(e.onSwipeCancel, (u) => {
            u.currentTarget.setAttribute("data-swipe", "cancel"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), u.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), u.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
          }),
          onSwipeEnd: Fe(e.onSwipeEnd, (u) => {
            const { x: d, y: p } = u.detail.delta;
            u.currentTarget.setAttribute("data-swipe", "end"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), u.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${d}px`), u.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${p}px`), l(!1);
          })
        }
      ) });
    }
  );
  R6.displayName = Vh;
  var [Oce, Ace] = _6(Vh, {
    onClose() {
    }
  }), Nce = T.forwardRef(
    (e, t) => {
      const {
        __scopeToast: n,
        type: r = "foreground",
        duration: o,
        open: i,
        onClose: a,
        onEscapeKeyDown: s,
        onPause: l,
        onResume: u,
        onSwipeStart: d,
        onSwipeMove: p,
        onSwipeCancel: h,
        onSwipeEnd: g,
        ...y
      } = e, b = Tb(Vh, n), [v, x] = T.useState(null), E = an(t, (j) => x(j)), _ = T.useRef(null), C = T.useRef(null), k = o || b.duration, R = T.useRef(0), A = T.useRef(k), M = T.useRef(0), { onToastAdd: I, onToastRemove: D } = b, L = Vr(() => {
        v?.contains(document.activeElement) && b.viewport?.focus(), a();
      }), P = T.useCallback(
        (j) => {
          !j || j === 1 / 0 || (window.clearTimeout(M.current), R.current = (/* @__PURE__ */ new Date()).getTime(), M.current = window.setTimeout(L, j));
        },
        [L]
      );
      T.useEffect(() => {
        const j = b.viewport;
        if (j) {
          const V = () => {
            P(A.current), u?.();
          }, F = () => {
            const G = (/* @__PURE__ */ new Date()).getTime() - R.current;
            A.current = A.current - G, window.clearTimeout(M.current), l?.();
          };
          return j.addEventListener(BE, F), j.addEventListener(UE, V), () => {
            j.removeEventListener(BE, F), j.removeEventListener(UE, V);
          };
        }
      }, [b.viewport, k, l, u, P]), T.useEffect(() => {
        i && !b.isClosePausedRef.current && P(k);
      }, [i, k, b.isClosePausedRef, P]), T.useEffect(() => (I(), () => D()), [I, D]);
      const B = T.useMemo(() => v ? I6(v) : null, [v]);
      return b.viewport ? /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
        B && /* @__PURE__ */ S.jsx(
          Mce,
          {
            __scopeToast: n,
            role: "status",
            "aria-live": r === "foreground" ? "assertive" : "polite",
            "aria-atomic": !0,
            children: B
          }
        ),
        /* @__PURE__ */ S.jsx(Oce, { scope: n, onClose: L, children: gc.createPortal(
          /* @__PURE__ */ S.jsx(cT.ItemSlot, { scope: n, children: /* @__PURE__ */ S.jsx(
            nJ,
            {
              asChild: !0,
              onEscapeKeyDown: Fe(s, () => {
                b.isFocusedToastEscapeKeyDownRef.current || L(), b.isFocusedToastEscapeKeyDownRef.current = !1;
              }),
              children: /* @__PURE__ */ S.jsx(
                xt.li,
                {
                  role: "status",
                  "aria-live": "off",
                  "aria-atomic": !0,
                  tabIndex: 0,
                  "data-state": i ? "open" : "closed",
                  "data-swipe-direction": b.swipeDirection,
                  ...y,
                  ref: E,
                  style: { userSelect: "none", touchAction: "none", ...e.style },
                  onKeyDown: Fe(e.onKeyDown, (j) => {
                    j.key === "Escape" && (s?.(j.nativeEvent), j.nativeEvent.defaultPrevented || (b.isFocusedToastEscapeKeyDownRef.current = !0, L()));
                  }),
                  onPointerDown: Fe(e.onPointerDown, (j) => {
                    j.button === 0 && (_.current = { x: j.clientX, y: j.clientY });
                  }),
                  onPointerMove: Fe(e.onPointerMove, (j) => {
                    if (!_.current) return;
                    const V = j.clientX - _.current.x, F = j.clientY - _.current.y, G = !!C.current, W = ["left", "right"].includes(b.swipeDirection), K = ["left", "up"].includes(b.swipeDirection) ? Math.min : Math.max, $ = W ? K(0, V) : 0, U = W ? 0 : K(0, F), X = j.pointerType === "touch" ? 10 : 2, z = { x: $, y: U }, H = { originalEvent: j, delta: z };
                    G ? (C.current = z, Zg(kce, p, H, {
                      discrete: !1
                    })) : $2(z, b.swipeDirection, X) ? (C.current = z, Zg(Cce, d, H, {
                      discrete: !1
                    }), j.target.setPointerCapture(j.pointerId)) : (Math.abs(V) > X || Math.abs(F) > X) && (_.current = null);
                  }),
                  onPointerUp: Fe(e.onPointerUp, (j) => {
                    const V = C.current, F = j.target;
                    if (F.hasPointerCapture(j.pointerId) && F.releasePointerCapture(j.pointerId), C.current = null, _.current = null, V) {
                      const G = j.currentTarget, W = { originalEvent: j, delta: V };
                      $2(V, b.swipeDirection, b.swipeThreshold) ? Zg(Rce, g, W, {
                        discrete: !0
                      }) : Zg(
                        Tce,
                        h,
                        W,
                        {
                          discrete: !0
                        }
                      ), G.addEventListener("click", (K) => K.preventDefault(), {
                        once: !0
                      });
                    }
                  })
                }
              )
            }
          ) }),
          b.viewport
        ) })
      ] }) : null;
    }
  ), Mce = (e) => {
    const { __scopeToast: t, children: n, ...r } = e, o = Tb(Vh, t), [i, a] = T.useState(!1), [s, l] = T.useState(!1);
    return Ice(() => a(!0)), T.useEffect(() => {
      const u = window.setTimeout(() => l(!0), 1e3);
      return () => window.clearTimeout(u);
    }, []), s ? null : /* @__PURE__ */ S.jsx(ub, { asChild: !0, children: /* @__PURE__ */ S.jsx(sT, { ...r, children: i && /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      o.label,
      " ",
      n
    ] }) }) });
  }, Pce = "ToastTitle", O6 = T.forwardRef(
    (e, t) => {
      const { __scopeToast: n, ...r } = e;
      return /* @__PURE__ */ S.jsx(xt.div, { ...r, ref: t });
    }
  );
  O6.displayName = Pce;
  var $ce = "ToastDescription", A6 = T.forwardRef(
    (e, t) => {
      const { __scopeToast: n, ...r } = e;
      return /* @__PURE__ */ S.jsx(xt.div, { ...r, ref: t });
    }
  );
  A6.displayName = $ce;
  var N6 = "ToastAction", M6 = T.forwardRef(
    (e, t) => {
      const { altText: n, ...r } = e;
      return n.trim() ? /* @__PURE__ */ S.jsx($6, { altText: n, asChild: !0, children: /* @__PURE__ */ S.jsx(uT, { ...r, ref: t }) }) : (console.error(
        `Invalid prop \`altText\` supplied to \`${N6}\`. Expected non-empty \`string\`.`
      ), null);
    }
  );
  M6.displayName = N6;
  var P6 = "ToastClose", uT = T.forwardRef(
    (e, t) => {
      const { __scopeToast: n, ...r } = e, o = Ace(P6, n);
      return /* @__PURE__ */ S.jsx($6, { asChild: !0, children: /* @__PURE__ */ S.jsx(
        xt.button,
        {
          type: "button",
          ...r,
          ref: t,
          onClick: Fe(e.onClick, o.onClose)
        }
      ) });
    }
  );
  uT.displayName = P6;
  var $6 = T.forwardRef((e, t) => {
    const { __scopeToast: n, altText: r, ...o } = e;
    return /* @__PURE__ */ S.jsx(
      xt.div,
      {
        "data-radix-toast-announce-exclude": "",
        "data-radix-toast-announce-alt": r || void 0,
        ...o,
        ref: t
      }
    );
  });
  function I6(e) {
    const t = [];
    return Array.from(e.childNodes).forEach((r) => {
      if (r.nodeType === r.TEXT_NODE && r.textContent && t.push(r.textContent), jce(r)) {
        const o = r.ariaHidden || r.hidden || r.style.display === "none", i = r.dataset.radixToastAnnounceExclude === "";
        if (!o)
          if (i) {
            const a = r.dataset.radixToastAnnounceAlt;
            a && t.push(a);
          } else
            t.push(...I6(r));
      }
    }), t;
  }
  function Zg(e, t, n, { discrete: r }) {
    const o = n.originalEvent.currentTarget, i = new CustomEvent(e, { bubbles: !0, cancelable: !0, detail: n });
    t && o.addEventListener(e, t, { once: !0 }), r ? Ek(o, i) : o.dispatchEvent(i);
  }
  var $2 = (e, t, n = 0) => {
    const r = Math.abs(e.x), o = Math.abs(e.y), i = r > o;
    return t === "left" || t === "right" ? i && r > n : !i && o > n;
  };
  function Ice(e = () => {
  }) {
    const t = Vr(e);
    Fa(() => {
      let n = 0, r = 0;
      return n = window.requestAnimationFrame(() => r = window.requestAnimationFrame(t)), () => {
        window.cancelAnimationFrame(n), window.cancelAnimationFrame(r);
      };
    }, [t]);
  }
  function jce(e) {
    return e.nodeType === e.ELEMENT_NODE;
  }
  function Dce(e) {
    const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const o = r.tagName === "INPUT" && r.type === "hidden";
        return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    for (; n.nextNode(); ) t.push(n.currentNode);
    return t;
  }
  function MS(e) {
    const t = document.activeElement;
    return e.some((n) => n === t ? !0 : (n.focus(), document.activeElement !== t));
  }
  var Fce = E6, Lce = k6, zce = R6, Bce = O6, Uce = A6, Vce = M6, Hce = uT;
  const ar = [];
  for (let e = 0; e < 256; ++e)
    ar.push((e + 256).toString(16).slice(1));
  function qce(e, t = 0) {
    return (ar[e[t + 0]] + ar[e[t + 1]] + ar[e[t + 2]] + ar[e[t + 3]] + "-" + ar[e[t + 4]] + ar[e[t + 5]] + "-" + ar[e[t + 6]] + ar[e[t + 7]] + "-" + ar[e[t + 8]] + ar[e[t + 9]] + "-" + ar[e[t + 10]] + ar[e[t + 11]] + ar[e[t + 12]] + ar[e[t + 13]] + ar[e[t + 14]] + ar[e[t + 15]]).toLowerCase();
  }
  let PS;
  const Wce = new Uint8Array(16);
  function Gce() {
    if (!PS) {
      if (typeof crypto > "u" || !crypto.getRandomValues)
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      PS = crypto.getRandomValues.bind(crypto);
    }
    return PS(Wce);
  }
  const Kce = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), I2 = { randomUUID: Kce };
  function fT(e, t, n) {
    if (I2.randomUUID && !e)
      return I2.randomUUID();
    e = e || {};
    const r = e.random ?? e.rng?.() ?? Gce();
    if (r.length < 16)
      throw new Error("Random bytes length must be >= 16");
    return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, qce(r);
  }
  const j6 = T.createContext(
    void 0
  ), D6 = T.createContext(
    void 0
  ), Yce = 350, Xce = ({ children: e, fixedHeight: t, duration: n = 5e3, maxVisible: r = 3, ...o }) => {
    const [i, a] = T.useState(/* @__PURE__ */ new Map()), s = T.useRef(/* @__PURE__ */ new Map()), l = T.useRef(null), u = T.useRef(!0), d = T.useCallback(() => {
      const x = Array.from(s.current).reverse();
      if (t) {
        const E = t;
        x.forEach(([, _], C) => {
          if (!_) return;
          _.setAttribute("data-front", String(C === 0)), _.setAttribute("data-hidden", String(C >= r)), _.style.setProperty("--index", String(C)), _.style.setProperty("--height", `${t}px`), _.style.setProperty("--front-height", `${E}px`);
          const k = t * C;
          _.style.setProperty("--hover-offset-y", `-${k}px`);
        });
      } else {
        const E = x.map(([, C]) => {
          if (!C) return 0;
          const k = C.querySelector(
            ".ToastInner"
          );
          if (!k) return C.clientHeight;
          const R = k.style.height;
          k.style.height = "auto";
          const A = C.clientHeight;
          return k.style.height = R, A;
        }), _ = E[0] || 0;
        x.forEach(([, C], k) => {
          if (!C) return;
          const R = E[k];
          C.setAttribute("data-front", String(k === 0)), C.setAttribute("data-hidden", String(k >= r)), C.style.setProperty("--index", String(k)), C.style.setProperty("--height", `${R}px`), C.style.setProperty("--front-height", `${_}px`);
          const A = E.slice(0, k).reduce((M, I) => M + I, 0);
          C.style.setProperty("--hover-offset-y", `-${A}px`);
        });
      }
    }, [t, r]), p = T.useCallback(
      (x) => {
        a((E) => {
          const _ = new Map(E);
          return _.set(fT(), {
            ...x,
            duration: x.duration || n,
            open: !0
          }), _;
        });
      },
      [n]
    ), h = T.useCallback((x) => {
      u.current && a((E) => {
        const _ = new Map(E);
        return _.delete(x), _;
      });
    }, []), g = T.useCallback(
      (x) => p({ ...x, status: x.status || "default" }),
      [p]
    ), y = T.useCallback(
      (x) => p({ ...x, status: "success" }),
      [p]
    ), b = T.useCallback(
      (x) => p({ ...x, status: "error" }),
      [p]
    );
    T.useEffect(() => (u.current = !0, () => {
      u.current = !1;
    }), []), T.useEffect(() => {
      const x = l.current;
      if (x) {
        const E = () => {
          s.current.forEach((k) => {
            k.setAttribute("data-hovering", "true");
          });
        }, _ = (k) => {
          (!x.contains(k.target) || x === k.target) && s.current.forEach((R) => {
            R.setAttribute("data-hovering", "false");
          });
        }, C = () => {
          s.current.forEach((k) => {
            k.setAttribute("data-hovering", "false");
          });
        };
        return x.addEventListener("pointermove", E), x.addEventListener("pointerleave", C), x.addEventListener("focusin", E), x.addEventListener("focusout", _), () => {
          x.removeEventListener("pointermove", E), x.removeEventListener("pointerleave", C), x.removeEventListener("focusin", E), x.removeEventListener("focusout", _);
        };
      }
    }, []);
    const v = T.useMemo(
      () => Object.assign(g, {
        success: y,
        error: b
      }),
      [g, y, b]
    );
    return /* @__PURE__ */ S.jsx(j6.Provider, { value: v, children: /* @__PURE__ */ S.jsx(
      D6.Provider,
      {
        value: T.useMemo(
          () => ({
            toastElementsMapRef: s,
            sortToasts: d
          }),
          [d]
        ),
        children: /* @__PURE__ */ S.jsxs(Fce, { ...o, children: [
          e,
          Array.from(i).map(([x, E]) => /* @__PURE__ */ S.jsx(
            Jce,
            {
              id: x,
              toast: E,
              onOpenChange: (_) => {
                _ || (s.current.delete(x), d(), a((C) => {
                  const k = new Map(C), R = k.get(x);
                  return R && k.set(x, { ...R, open: !1 }), k;
                }), setTimeout(() => {
                  h(x);
                }, Yce));
              }
            },
            x
          )),
          /* @__PURE__ */ S.jsx(
            Lce,
            {
              ref: l,
              className: "ToastViewport",
              style: t ? {
                "--fixed-toast-height": `${t}px`
              } : void 0
            }
          )
        ] })
      }
    ) });
  }, Zce = () => {
    const e = T.useContext(j6);
    if (e) return e;
    throw new Error("useToast must be used within Toasts");
  }, Qce = () => {
    const e = T.useContext(D6);
    if (e) return e;
    throw new Error("useToastContext must be used within Toasts");
  }, Jce = ({
    onOpenChange: e,
    toast: t,
    id: n,
    ...r
  }) => {
    const o = T.useRef(null), i = Qce(), { sortToasts: a, toastElementsMapRef: s } = i, l = s.current;
    return T.useLayoutEffect(() => (o.current && (l.set(n, o.current), a()), () => {
      l.delete(n), a();
    }), [n, a, l]), /* @__PURE__ */ S.jsx(
      zce,
      {
        ...r,
        ref: o,
        type: t.type,
        duration: t.duration,
        className: "ToastRoot",
        onOpenChange: e,
        open: t.open,
        children: /* @__PURE__ */ S.jsxs("div", { className: "ToastInner", "data-status": t.status, children: [
          /* @__PURE__ */ S.jsx(eue, { status: t.status }),
          t.title && /* @__PURE__ */ S.jsx(Bce, { className: "ToastTitle", children: t.title }),
          /* @__PURE__ */ S.jsx(Uce, { className: "ToastDescription", children: t.description }),
          t.action && /* @__PURE__ */ S.jsx(
            Vce,
            {
              className: "ToastAction Button small green",
              altText: t.action.altText,
              onClick: t.action.onClick,
              asChild: !0,
              children: /* @__PURE__ */ S.jsx("button", { children: t.action.label })
            }
          ),
          /* @__PURE__ */ S.jsx(Hce, { "aria-label": "Close", className: "ToastClose", children: /* @__PURE__ */ S.jsx(bb, { style: { fontSize: "12px" } }) })
        ] })
      }
    );
  }, eue = ({ status: e }) => e !== "default" && e ? /* @__PURE__ */ S.jsxs("div", { style: { gridArea: "icon", alignSelf: "start" }, children: [
    e === "success" && /* @__PURE__ */ S.jsx(moe, { style: { color: "#61d345", fontSize: "20px" } }),
    e === "error" && /* @__PURE__ */ S.jsx(goe, { style: { color: "#ff4b4b", fontSize: "20px" } })
  ] }) : null, tue = {}, j2 = (e) => {
    let t;
    const n = /* @__PURE__ */ new Set(), r = (d, p) => {
      const h = typeof d == "function" ? d(t) : d;
      if (!Object.is(h, t)) {
        const g = t;
        t = p ?? (typeof h != "object" || h === null) ? h : Object.assign({}, t, h), n.forEach((y) => y(t, g));
      }
    }, o = () => t, l = { setState: r, getState: o, getInitialState: () => u, subscribe: (d) => (n.add(d), () => n.delete(d)), destroy: () => {
      (tue ? "production" : void 0) !== "production" && console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      ), n.clear();
    } }, u = t = e(r, o, l);
    return l;
  }, F6 = (e) => e ? j2(e) : j2;
  var $S = { exports: {} }, IS = {}, jS = { exports: {} }, DS = {};
  /**
   * @license React
   * use-sync-external-store-shim.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var D2;
  function nue() {
    if (D2) return DS;
    D2 = 1;
    var e = kh();
    function t(p, h) {
      return p === h && (p !== 0 || 1 / p === 1 / h) || p !== p && h !== h;
    }
    var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, o = e.useEffect, i = e.useLayoutEffect, a = e.useDebugValue;
    function s(p, h) {
      var g = h(), y = r({ inst: { value: g, getSnapshot: h } }), b = y[0].inst, v = y[1];
      return i(
        function() {
          b.value = g, b.getSnapshot = h, l(b) && v({ inst: b });
        },
        [p, g, h]
      ), o(
        function() {
          return l(b) && v({ inst: b }), p(function() {
            l(b) && v({ inst: b });
          });
        },
        [p]
      ), a(g), g;
    }
    function l(p) {
      var h = p.getSnapshot;
      p = p.value;
      try {
        var g = h();
        return !n(p, g);
      } catch {
        return !0;
      }
    }
    function u(p, h) {
      return h();
    }
    var d = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? u : s;
    return DS.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : d, DS;
  }
  var F2;
  function rue() {
    return F2 || (F2 = 1, jS.exports = nue()), jS.exports;
  }
  /**
   * @license React
   * use-sync-external-store-shim/with-selector.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var L2;
  function oue() {
    if (L2) return IS;
    L2 = 1;
    var e = kh(), t = rue();
    function n(u, d) {
      return u === d && (u !== 0 || 1 / u === 1 / d) || u !== u && d !== d;
    }
    var r = typeof Object.is == "function" ? Object.is : n, o = t.useSyncExternalStore, i = e.useRef, a = e.useEffect, s = e.useMemo, l = e.useDebugValue;
    return IS.useSyncExternalStoreWithSelector = function(u, d, p, h, g) {
      var y = i(null);
      if (y.current === null) {
        var b = { hasValue: !1, value: null };
        y.current = b;
      } else b = y.current;
      y = s(
        function() {
          function x(R) {
            if (!E) {
              if (E = !0, _ = R, R = h(R), g !== void 0 && b.hasValue) {
                var A = b.value;
                if (g(A, R))
                  return C = A;
              }
              return C = R;
            }
            if (A = C, r(_, R)) return A;
            var M = h(R);
            return g !== void 0 && g(A, M) ? (_ = R, A) : (_ = R, C = M);
          }
          var E = !1, _, C, k = p === void 0 ? null : p;
          return [
            function() {
              return x(d());
            },
            k === null ? void 0 : function() {
              return x(k());
            }
          ];
        },
        [d, p, h, g]
      );
      var v = o(u, y[0], y[1]);
      return a(
        function() {
          b.hasValue = !0, b.value = v;
        },
        [v]
      ), l(v), v;
    }, IS;
  }
  var z2;
  function iue() {
    return z2 || (z2 = 1, $S.exports = oue()), $S.exports;
  }
  var aue = iue();
  const L6 = /* @__PURE__ */ Jo(aue), z6 = {}, { useDebugValue: sue } = Tn, { useSyncExternalStoreWithSelector: lue } = L6;
  let B2 = !1;
  const cue = (e) => e;
  function uue(e, t = cue, n) {
    (z6 ? "production" : void 0) !== "production" && n && !B2 && (console.warn(
      "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
    ), B2 = !0);
    const r = lue(
      e.subscribe,
      e.getState,
      e.getServerState || e.getInitialState,
      t,
      n
    );
    return sue(r), r;
  }
  const U2 = (e) => {
    (z6 ? "production" : void 0) !== "production" && typeof e != "function" && console.warn(
      "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
    );
    const t = typeof e == "function" ? F6(e) : e, n = (r, o) => uue(t, r, o);
    return Object.assign(n, t), n;
  }, To = (e) => e ? U2(e) : U2;
  class Ya {
    constructor(t) {
      this.context = t;
    }
    get communicationManager() {
      return this.context.worker.getCommunicationManager();
    }
    get eventManager() {
      return this.context.worker.getEventManager();
    }
    get hookManager() {
      return this.context.worker.getHookManager();
    }
    get nodeManager() {
      return this.context.worker.getNodeManager();
    }
    get syncManager() {
      return this.context.worker.getSyncManager();
    }
    get connectionHealthManager() {
      return this.context.worker.getConnectionHealthManager();
    }
    get edgeManager() {
      return this.context.worker.getEdgeManager();
    }
    get groupManager() {
      return this.context.worker.getGroupManager();
    }
    get libraryManager() {
      return this.context.worker.getLibraryManager();
    }
  }
  const Qg = 2e3;
  class fue extends Ya {
    constructor(t) {
      super(t), this._responsive = !1, this._last_pong = 0, this._last_pong = Date.now() - Qg * 100;
    }
    start() {
      this.stop(), this.pingInterval = setInterval(() => {
        this.context.worker.is_open && this.context.worker.send({ type: "ping" });
      }, Qg), this.responsivenessCheckInterval = setInterval(() => {
        this._responsive = Date.now() - this._last_pong <= Qg * 3;
      }, Qg * 2);
    }
    stop() {
      this.pingInterval && clearInterval(this.pingInterval), this.responsivenessCheckInterval && clearInterval(this.responsivenessCheckInterval);
    }
    receivePong() {
      this._last_pong = Date.now(), this._responsive = !0;
    }
    isResponsive() {
      return this._responsive;
    }
  }
  const V2 = (e, t) => {
    e.properties = e.properties || {}, t.pos && (e.properties["frontend:pos"] = t.pos), t.size && (e.properties["frontend:size"] = t.size), t.collapsed !== void 0 && (e.properties["frontend:collapsed"] = !!t.collapsed);
  }, H2 = 2e3, q2 = 2e3;
  class due extends Ya {
    constructor(t) {
      super(t), this._local_nodeupdates = /* @__PURE__ */ new Map(), this._local_groupupdates = /* @__PURE__ */ new Map(), this.on_sync_complete = t.on_sync_complete || (async () => {
      });
    }
    start() {
      this._nodeupdatetimer = setTimeout(() => {
        this.sync_local_node_updates();
      }, H2), this._groupupdatetimer = setTimeout(() => {
        this.sync_local_group_updates();
      }, q2);
    }
    stop() {
      this._nodeupdatetimer && clearTimeout(this._nodeupdatetimer), this._groupupdatetimer && clearTimeout(this._groupupdatetimer);
    }
    async stepwise_fullsync() {
      this.context.worker._zustand && this.context.worker.is_open && (await this.sync_lib(), await this.sync_external_worker(), await this.sync_funcnodes_plugins(), await this.sync_nodespace(), await this.sync_view_state(), await this.on_sync_complete(this.context.worker));
    }
    async sync_lib() {
      if (!this.context.worker._zustand || !this.context.worker.is_open) return;
      const t = await this.communicationManager._send_cmd({
        cmd: "get_library",
        wait_for_response: !0,
        retries: 2,
        unique: !0
      });
      this.context.worker._zustand.lib.libstate.getState().set({
        lib: t
      });
    }
    async sync_external_worker() {
      if (!this.context.worker._zustand || !this.context.worker.is_open) return;
      const t = await this.communicationManager._send_cmd({
        cmd: "get_worker_dependencies",
        wait_for_response: !0,
        unique: !0
      });
      this.context.worker._zustand.lib.libstate.getState().set({
        external_worker: t
      });
    }
    async sync_funcnodes_plugins() {
      if (!this.context.worker._zustand || !this.context.worker.is_open) return;
      const t = await this.context.worker.getCommunicationManager()._send_cmd({
        cmd: "get_plugin_keys",
        wait_for_response: !0,
        unique: !0,
        kwargs: { type: "react" }
      });
      for (const n of t) {
        const r = await this.context.worker.getCommunicationManager()._send_cmd({
          cmd: "get_plugin",
          wait_for_response: !0,
          kwargs: { key: n, type: "react" },
          unique: !0
        });
        this.context.worker._zustand.add_packed_plugin(n, r);
      }
    }
    async sync_view_state() {
      if (!this.context.worker._zustand || !this.context.worker.is_open) return;
      const t = await this.context.worker.getCommunicationManager()._send_cmd({
        cmd: "view_state",
        wait_for_response: !0,
        unique: !0
      });
      t.renderoptions && this.context.worker._zustand.update_render_options(t.renderoptions);
      const n = t.nodes;
      if (n)
        for (const r in n) {
          const o = {};
          V2(o, n[r]), this.context.worker._zustand.on_node_action({
            type: "update",
            node: o,
            id: r,
            from_remote: !0
          });
        }
    }
    async sync_nodespace() {
      if (!this.context.worker._zustand || !this.context.worker.is_open) return;
      const t = await this.context.worker.getCommunicationManager()._send_cmd({
        cmd: "get_nodes",
        kwargs: { with_frontend: !0 },
        wait_for_response: !0,
        unique: !0
      });
      for (const o of t)
        this.eventManager._receive_node_added(o);
      const n = await this.context.worker.getCommunicationManager()._send_cmd({
        cmd: "get_edges",
        wait_for_response: !0,
        unique: !0
      });
      for (const o of n)
        this.eventManager._receive_edge_added(...o);
      const r = await this.context.worker.getCommunicationManager()._send_cmd({
        cmd: "get_groups",
        kwargs: {},
        wait_for_response: !0,
        unique: !0
      });
      this.eventManager._receive_groups(r);
    }
    async fullsync() {
      if (!this.context.worker._zustand || !this.context.worker.is_open) return;
      let t;
      for (; ; )
        try {
          t = await this.communicationManager._send_cmd({
            cmd: "full_state",
            unique: !0
          });
          break;
        } catch (o) {
          o instanceof Error ? this.context.worker._zustand.logger.error("Error in fullsync", o) : this.context.worker._zustand.logger.error(
            "Error in fullsync",
            new Error(JSON.stringify(o))
          );
        }
      this.context.worker._zustand.logger.debug("Full state", t), this.context.worker._zustand.lib.libstate.getState().set({
        lib: t.backend.lib,
        external_worker: t.worker_dependencies
      }), t.view.renderoptions && this.context.worker._zustand.update_render_options(
        t.view.renderoptions
      );
      const n = t.view.nodes;
      for (const o of t.backend.nodes) {
        const i = n[o.id];
        i !== void 0 && V2(o, i), this.eventManager._receive_node_added(o);
      }
      for (const o of t.backend.edges)
        this.eventManager._receive_edge_added(...o);
      const r = t.backend.groups;
      r && this.eventManager._receive_groups(r);
    }
    sync_local_node_updates() {
      clearTimeout(this._nodeupdatetimer), this._local_nodeupdates.forEach(async (t, n) => {
        const r = await this.context.worker.getCommunicationManager()._send_cmd({
          cmd: "update_node",
          kwargs: { nid: n, data: t },
          wait_for_response: !0
        });
        this.context.worker._zustand && Object.keys(r).length > 0 && this.context.worker._zustand.on_node_action({
          type: "update",
          node: r,
          id: n,
          from_remote: !0
        });
      }), this._local_nodeupdates.clear(), this._nodeupdatetimer = setTimeout(() => {
        this.sync_local_node_updates();
      }, H2);
    }
    sync_local_group_updates() {
      clearTimeout(this._groupupdatetimer), this._local_groupupdates.forEach(async (t, n) => {
        const r = await this.communicationManager._send_cmd({
          cmd: "update_group",
          kwargs: { gid: n, data: t },
          wait_for_response: !0
        });
        this.context.worker._zustand && this.context.worker._zustand.on_group_action({
          type: "update",
          group: r,
          id: n,
          from_remote: !0
        });
      }), this._local_groupupdates.clear(), this._groupupdatetimer = setTimeout(() => {
        this.sync_local_group_updates();
      }, q2);
    }
    locally_update_node(t) {
      const n = this._local_nodeupdates.get(t.id);
      if (n) {
        const { new_obj: r, change: o } = tc(n, t.node);
        o && this._local_nodeupdates.set(t.id, r);
      } else
        this._local_nodeupdates.set(t.id, t.node);
      t.immediate && this.sync_local_node_updates();
    }
    locally_update_group(t) {
      const n = this._local_groupupdates.get(t.id);
      if (n) {
        const { new_obj: r, change: o } = tc(n, t.group);
        o && this._local_groupupdates.set(t.id, r);
      } else
        this._local_groupupdates.set(t.id, t.group);
      t.immediate && this.sync_local_group_updates();
    }
  }
  class Ai {
    /**
     * Creates a new DataStructure instance.
     *
     * @param props - Configuration object containing data and MIME type
     */
    constructor({ data: t, mime: n }) {
      this._data = t, this._mime = n;
    }
    /**
     * Gets the raw wrapped data.
     *
     * @returns The original data in its native type
     */
    get data() {
      return this._data;
    }
    /**
     * Gets the data cast to the expected return type.
     * This is a type assertion and should be overridden in subclasses for proper type conversion.
     *
     * @returns The data cast to type R
     */
    get value() {
      return this._data;
    }
    /**
     * Gets the MIME type of the wrapped data.
     *
     * @returns The MIME type string
     */
    get mime() {
      return this._mime;
    }
    /**
     * Returns a string representation of the DataStructure.
     * The format varies based on the data type:
     * - ArrayBuffer: shows byte length
     * - Blob: shows size
     * - String/Array: shows length
     * - Object: shows number of keys
     * - Other types: shows only MIME type
     *
     * @returns String representation in format "DataStructure(size,mime)" or "DataStructure(mime)"
     */
    toString() {
      return this._data instanceof ArrayBuffer ? `DataStructure(${this._data.byteLength},${this._mime})` : this._data instanceof Blob ? `DataStructure(${this._data.size},${this._mime})` : this._data instanceof String ? `DataStructure(${this._data.length},${this._mime})` : this._data instanceof Array ? `DataStructure(${this._data.length},${this._mime})` : this._data instanceof Object ? `DataStructure(${Object.keys(this._data).length},${this._mime})` : `DataStructure(${this._mime})`;
    }
    /**
     * Returns the JSON representation of this DataStructure.
     * Currently delegates to toString() method.
     *
     * @returns JSON string representation
     */
    toJSON() {
      return this.toString();
    }
    /**
     * Cleans up resources associated with this DataStructure.
     * Base implementation does nothing, but subclasses may override to release resources.
     */
    dispose() {
    }
  }
  class B6 extends Ai {
    get objectUrl() {
      if (this._objectUrl)
        return this._objectUrl;
      const t = this.data instanceof Blob ? this.data : new Blob([this.data], { type: this.mime });
      return this._objectUrl = URL.createObjectURL(t), this._objectUrl;
    }
    dispose() {
      this._objectUrl && URL.revokeObjectURL(this._objectUrl), super.dispose();
    }
    get value() {
      return this.objectUrl;
    }
  }
  const Ln = (e) => e.buffer ? e.buffer : e, pue = {
    x: (e, t) => null,
    //  pad byte 	no value 	(7 )
    c: (e, t) => new DataView(Ln(e)).getInt8(0),
    //  char 	bytes of length 1 	1 	b 	signed char 	integer 	1 	(1 ), (2 )
    B: (e, t) => new DataView(Ln(e)).getUint8(0),
    //  unsigned char 	integer 	1 	(2 )
    "?": (e, t) => new DataView(Ln(e)).getInt8(0) === 1,
    //  _Bool 	bool 	1 	(1 )
    h: (e, t) => new DataView(Ln(e)).getInt16(0, t),
    //  short 	integer 	2 	(2 )
    H: (e, t) => new DataView(Ln(e)).getUint16(0, t),
    //  unsigned short 	integer 	2 	(2 )
    i: (e, t) => new DataView(Ln(e)).getInt32(0, t),
    //  int 	integer 	4 	(2 )
    I: (e, t) => new DataView(Ln(e)).getUint32(0, t),
    //  unsigned int 	integer 	4 	(2 )
    l: (e, t) => new DataView(Ln(e)).getInt32(0, t),
    //  long 	integer 	4 	(2 )
    L: (e, t) => new DataView(Ln(e)).getUint32(0, t),
    //  unsigned long 	integer 	4 	(2 )
    q: (e, t) => Number(
      new DataView(Ln(e)).getBigInt64(0, t)
    ),
    //  long long 	integer 	8 	(2 )
    Q: (e, t) => Number(
      new DataView(Ln(e)).getBigUint64(0, t)
    ),
    //  unsigned long long 	integer 	8 	(2 )
    n: (e, t) => Number(
      new DataView(Ln(e)).getBigInt64(0, t)
    ),
    //  ssize_t 	integer 	(3 )
    N: (e, t) => Number(
      new DataView(Ln(e)).getBigUint64(0, t)
    ),
    //  size_t 	integer 	(3 )
    // "e":(data:ArrayBufferLike)=>{return new DataView(to_arraybuffer(data)).getFloat16(0)}, //  (6 ) float 	2 	(4 )
    f: (e, t) => new DataView(Ln(e)).getFloat32(0, t),
    //  float 	float 	4 	(4 )
    d: (e, t) => new DataView(Ln(e)).getFloat64(0, t),
    //  double 	float 	8 	(4 )
    s: (e, t) => new TextDecoder().decode(Ln(e)),
    //  char[] 	bytes 	(9 )
    p: (e, t) => new TextDecoder().decode(Ln(e)),
    //  char[] 	bytes 	(8 )
    P: (e, t) => Number(
      new DataView(Ln(e)).getBigUint64(0, t)
    )
    //  void* 	int
  };
  class U6 extends Ai {
    constructor({ data: t, mime: n }) {
      super({ data: t, mime: n }), this._cType = n.split("application/fn.struct.")[1], this._value = null, this.parse_value();
    }
    parse_value() {
      let t = !0, n = this._cType;
      return n.startsWith("<") && (t = !0, n = n.slice(1)), n.startsWith(">") && (t = !1, n = n.slice(1)), n.startsWith("!") && (t = !1, n = n.slice(1)), n.startsWith("@") && (t = !1, n = n.slice(1)), n.startsWith("=") && (t = !1, n = n.slice(1)), this._value = pue[n](this.data, t), this._value;
    }
    get value() {
      return this._value;
    }
    toString() {
      return this._value === null ? "null" : this._value.toString();
    }
  }
  class Vs extends Ai {
    constructor({ data: t, mime: n }) {
      super({ data: t, mime: n }), t.length === 0 ? this._json = void 0 : (this._json = JSON.parse(new TextDecoder().decode(Ln(t))), this._json === "<NoValue>" && (this._json = void 0));
    }
    get value() {
      return this._json;
    }
    static fromObject(t) {
      const n = t === "<NoValue>" ? new Uint8Array(0) : new TextEncoder().encode(JSON.stringify(t));
      return new Vs({ data: n, mime: "application/json" });
    }
    toString() {
      return typeof this._json == "string" ? this._json : JSON.stringify(this._json);
    }
  }
  class V6 extends Ai {
    constructor({ data: t, mime: n }) {
      super({ data: t, mime: n }), this._value = new TextDecoder().decode(Ln(t));
    }
    get value() {
      return this._value;
    }
    toString() {
      return this._value;
    }
  }
  const H6 = ({
    data: e,
    mime: t
  }) => e instanceof ArrayBuffer || e instanceof Uint8Array ? t.startsWith("application/fn.struct.") ? new U6({ data: e, mime: t }) : t.startsWith("application/json") ? new Vs({ data: e, mime: t }) : t === "text" || t.startsWith("text/") ? new V6({ data: e, mime: t }) : new B6({ data: e, mime: t }) : new Ai({ data: e, mime: t });
  class hue extends Ya {
    constructor(t) {
      super(t), this.CHUNK_TIMEOUT = 1e4, this._unique_cmd_outs = {}, this.blobChunks = {}, this.cleanupChunks = () => {
        const n = Date.now();
        for (const r in this.blobChunks)
          n - this.blobChunks[r].timestamp > this.CHUNK_TIMEOUT && delete this.blobChunks[r];
      }, this.messagePromises = /* @__PURE__ */ new Map();
    }
    start() {
      this._chunk_cleanup_timer = setInterval(
        this.cleanupChunks.bind(this),
        this.CHUNK_TIMEOUT / 2
      );
    }
    stop() {
      this._chunk_cleanup_timer && clearInterval(this._chunk_cleanup_timer);
    }
    send(t) {
      this.context.worker.send(t);
    }
    async _send_cmd({
      cmd: t,
      kwargs: n,
      as_bytes: r = !1,
      wait_for_response: o = !0,
      response_timeout: i = 5e3,
      retries: a = 2,
      unique: s = !1
    }) {
      const l = {
        type: "cmd",
        as_bytes: r,
        cmd: t,
        kwargs: n || {}
      };
      if (await new Promise(async (u) => {
        if (this.context.worker.is_responsive) return u();
        const d = setInterval(() => {
          this.context.worker.is_responsive && (clearInterval(d), u());
        }, 100);
      }), o) {
        if (s && this._unique_cmd_outs[l.cmd] !== void 0)
          return this._unique_cmd_outs[l.cmd];
        a < 0 && (a = 0);
        const d = (async () => {
          let p;
          for (; a >= 0; ) {
            const h = l.id || fT();
            l.id = h;
            const g = new Promise((y, b) => {
              const v = setTimeout(() => {
                b("Timeout@wait_for_response for " + t);
              }, i);
              this.messagePromises.set(h, {
                resolve: (x) => {
                  clearTimeout(v), y(x), this.messagePromises.delete(h);
                },
                reject: (x) => {
                  clearTimeout(v), b(x), this.messagePromises.delete(h);
                }
              });
            });
            await this.send(l);
            try {
              p = await g;
              break;
            } catch (y) {
              if (a === 0)
                throw delete this._unique_cmd_outs[l.cmd], y;
              a -= 1;
              continue;
            }
          }
          return delete this._unique_cmd_outs[l.cmd], p;
        })();
        return s && (this._unique_cmd_outs[l.cmd] = d), d;
      }
      return this.send(l);
    }
    async receive(t) {
      let n;
      switch (this.connectionHealthManager.receivePong(), t.type) {
        case "pong":
          return this.connectionHealthManager.receivePong();
        case "nsevent":
          return await this.context.worker.getEventManager().receive_nodespace_event(t);
        case "result":
          if (n = t.id && this.messagePromises.get(t.id), n)
            return n.resolve(t.result);
          break;
        case "error":
          if (this.context.worker.on_error(t.tb + `
` + t.error), n = t.id && this.messagePromises.get(t.id), n)
            return n.reject(t.error);
          break;
        case "progress":
          if (!this.context.worker._zustand) return;
          this.context.worker._zustand.set_progress(t);
          break;
        case "workerevent":
          return await this.context.worker.getEventManager().receive_workerevent(t);
        case "large_message":
          return await this.context.worker.handle_large_message_hint(t);
        default:
          console.warn("Unhandled message", t);
          break;
      }
    }
    async recieve_bytes(t, n) {
      const { type: r } = t;
      if (r === "io_value") {
        if (!this.context.worker._zustand) return;
        const { node: o, io: i, preview: a, mime: s } = t, l = a ? "value" : "fullvalue";
        (!o || !i) && console.error("Invalid io_value message", t);
        const u = H6({
          data: n,
          mime: s || "application/octet-stream"
        });
        this.context.worker._zustand.on_node_action({
          type: "update",
          node: {
            id: o,
            io: {
              [i]: {
                [l]: u
              }
            }
          },
          id: o,
          from_remote: !0
        });
      } else if (r == "result") {
        const o = t.id && this.messagePromises.get(t.id);
        o && o.resolve({ bytes: n, header: t });
      } else
        console.warn("Unhandled bytes message", t);
    }
    async onbytes(t) {
      try {
        const n = new TextDecoder("utf-8").decode(t), r = n.indexOf(`\r
\r
`);
        if (r === -1) {
          console.error(`Header terminator not found for:
`, n);
          return;
        }
        const o = n.substring(0, r + 4), i = t.slice(r + 4), a = o.split(";"), s = {};
        if (a.forEach((p) => {
          const [h, g] = p.split("=");
          s[h.trim()] = g.trim();
        }), !s.chunk || !s.msgid) {
          console.error(
            "Header missing required fields chunk or msgid",
            s
          );
          return;
        }
        const [l, u] = s.chunk.split("/"), d = s.msgid;
        if (l === "1" && u === "1")
          return this.recieve_bytes(s, i);
        if (this.blobChunks[d] || (this.blobChunks[d] = {
          chunks: Array.from({ length: parseInt(u) }, () => null),
          timestamp: Date.now()
        }), this.blobChunks[d].chunks.length !== parseInt(u)) {
          console.error("Total chunks mismatch");
          return;
        }
        if (this.blobChunks[d].chunks[parseInt(l) - 1] = t, this.blobChunks[d].chunks.every((p) => p !== null)) {
          const p = new Uint8Array(
            this.blobChunks[d].chunks.reduce((h, g) => h.concat(Array.from(g)), [])
          );
          this.recieve_bytes(s, p), delete this.blobChunks[d];
        }
      } catch (n) {
        console.error("Websocketworker: onbytes error", n, t);
        return;
      }
    }
  }
  class mue extends Ya {
    constructor() {
      super(...arguments), this._ns_event_intercepts = /* @__PURE__ */ new Map();
    }
    start() {
    }
    stop() {
    }
    async _receive_edge_added(t, n, r, o) {
      this.context.worker._zustand && this.context.worker._zustand.on_edge_action({
        type: "add",
        from_remote: !0,
        src_nid: t,
        src_ioid: n,
        trg_nid: r,
        trg_ioid: o
      });
    }
    async _receive_groups(t) {
      this.context.worker._zustand && this.context.worker._zustand.on_group_action({
        type: "set",
        groups: t
      });
    }
    async _receive_node_added(t) {
      if (this.context.worker._zustand)
        return this.context.worker._zustand.on_node_action({
          type: "add",
          node: t,
          id: t.id,
          from_remote: !0
        });
    }
    async receive_workerevent({ event: t, data: n }) {
      switch (t) {
        case "worker_error":
          return this.context.worker._zustand ? this.context.worker._zustand.logger.error(n.error) : void 0;
        case "update_worker_dependencies":
          return this.context.worker._zustand ? this.context.worker._zustand.lib.libstate.getState().set({
            external_worker: n.worker_dependencies
          }) : void 0;
        case "lib_update":
          await this.context.worker.getSyncManager().sync_lib();
          return;
        case "fullsync":
          await this.context.worker.getSyncManager().stepwise_fullsync();
          return;
        case "external_worker_update":
          await this.context.worker.getSyncManager().sync_lib(), await this.context.worker.getSyncManager().sync_external_worker();
          return;
        case "starting":
          this.hookManager.call_hooks("starting");
          return;
        case "stopping":
          this.hookManager.call_hooks("stopping");
          return;
        default:
          console.warn("Unhandled worker event", t, n);
          break;
      }
    }
    async intercept_ns_event(t) {
      let n = t;
      for (const r of this._ns_event_intercepts.get(t.event) || [])
        n = await r(n);
      return n;
    }
    async receive_nodespace_event(t) {
      const { event: n, data: r } = await this.intercept_ns_event(t);
      switch (n) {
        case "after_set_value":
          return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              io: {
                [r.io]: {
                  value: r.result
                }
              }
            },
            id: r.node,
            from_remote: !0
          }) : void 0;
        case "after_update_value_options":
          return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              io: {
                [r.io]: {
                  value_options: r.result
                }
              }
            },
            id: r.node,
            from_remote: !0
          }) : void 0;
        case "triggerstart":
          return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              in_trigger: !0
            },
            id: r.node,
            from_remote: !0
          }) : void 0;
        case "triggerdone":
          return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              in_trigger: !1
            },
            id: r.node,
            from_remote: !0
          }) : void 0;
        case "triggerfast":
          if (!this.context.worker._zustand) return;
          this.context.worker._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              in_trigger: !0
            },
            id: r.node,
            from_remote: !0
          }), setTimeout(() => {
            this.context.worker._zustand && this.context.worker._zustand.on_node_action({
              type: "update",
              node: {
                id: r.node,
                in_trigger: !1
              },
              id: r.node,
              from_remote: !0
            });
          }, 50);
          return;
        case "node_trigger_error":
          return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
            type: "error",
            errortype: "trigger",
            error: r.error,
            id: r.node,
            tb: r.tb,
            from_remote: !0
          }) : void 0;
        case "node_removed":
          if (!this.context.worker._zustand) return;
          this.context.worker._zustand.on_node_action({
            type: "delete",
            id: r.node,
            from_remote: !0
          }), this.hookManager.call_hooks("node_removed", {
            node: r.node
          });
          return;
        case "node_added":
          this._receive_node_added(r.node);
          return;
        case "after_disconnect":
          return !r.result || !Array.isArray(r.result) || r.result.length !== 4 || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.on_edge_action({
            type: "delete",
            from_remote: !0,
            src_nid: r.result[0],
            src_ioid: r.result[1],
            trg_nid: r.result[2],
            trg_ioid: r.result[3]
          });
        case "after_unforward":
          return !r.result || !Array.isArray(r.result) || r.result.length !== 4 || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.on_edge_action({
            type: "delete",
            from_remote: !0,
            src_nid: r.result[0],
            src_ioid: r.result[1],
            trg_nid: r.result[2],
            trg_ioid: r.result[3]
          });
        case "after_connect":
          return !r.result || !Array.isArray(r.result) || r.result.length !== 4 ? void 0 : this._receive_edge_added(
            ...r.result
          );
        case "after_forward":
          return !r.result || !Array.isArray(r.result) || r.result.length !== 4 ? void 0 : this._receive_edge_added(
            ...r.result
          );
        case "after_add_shelf":
          return !r.result || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.lib.libstate.getState().set({
            lib: r.result
          });
        case "after_remove_shelf":
          return !r.result || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.lib.libstate.getState().set({
            lib: r.result
          });
        case "progress":
          if (!this.context.worker._zustand) return;
          if (r.node)
            return this.context.worker._zustand.on_node_action({
              type: "update",
              node: {
                id: r.node,
                progress: r.info
              },
              id: r.node,
              from_remote: !0
            });
          console.warn("Unhandled nodepsace event", n, r);
          break;
        default:
          if (["after_set_nodespace"].includes(n)) return;
          console.warn("Unhandled nodepsace event", n, r);
          break;
      }
    }
    add_ns_event_intercept(t, n) {
      const r = this._ns_event_intercepts.get(t) || [];
      return r.push(n), this._ns_event_intercepts.set(t, r), () => {
        const i = this._ns_event_intercepts.get(t) || [], a = i.indexOf(n);
        a >= 0 && i.splice(a, 1);
      };
    }
  }
  class gue extends Ya {
    constructor() {
      super(...arguments), this._hooks = /* @__PURE__ */ new Map();
    }
    start() {
    }
    stop() {
    }
    add_hook(t, n) {
      const r = this._hooks.get(t) || [];
      return r.push(n), this._hooks.set(t, r), () => {
        const i = this._hooks.get(t) || [], a = i.indexOf(n);
        a >= 0 && i.splice(a, 1);
      };
    }
    async call_hooks(t, n) {
      const r = [];
      for (const o of this._hooks.get(t) || []) {
        const i = o({ worker: this.context.worker, data: n });
        i instanceof Promise && r.push(i);
      }
      await Promise.all(r);
    }
  }
  class yue extends Ya {
    start() {
    }
    stop() {
    }
    async trigger_node(t) {
      await this.communicationManager._send_cmd({
        cmd: "trigger_node",
        kwargs: { nid: t },
        wait_for_response: !1
      });
    }
    async add_node(t) {
      const n = await this.communicationManager._send_cmd({
        cmd: "add_node",
        kwargs: { id: t }
      });
      return this.eventManager._receive_node_added(n);
    }
    async remove_node(t) {
      await this.communicationManager._send_cmd({
        cmd: "remove_node",
        kwargs: { id: t }
      });
    }
    locally_update_node(t) {
      this.syncManager.locally_update_node(t);
    }
    set_io_value({
      nid: t,
      ioid: n,
      value: r,
      set_default: o = !1
    }) {
      return this.communicationManager._send_cmd({
        cmd: "set_io_value",
        kwargs: { nid: t, ioid: n, value: r, set_default: o },
        wait_for_response: !0
      });
    }
    set_io_value_options({
      nid: t,
      ioid: n,
      values: r,
      keys: o,
      nullable: i
    }) {
      return this.communicationManager._send_cmd({
        cmd: "update_io_value_options",
        kwargs: {
          nid: t,
          ioid: n,
          options: {
            options: {
              type: "enum",
              values: r,
              keys: o,
              nullable: i
            }
          }
        }
      });
    }
    async get_io_value({ nid: t, ioid: n }) {
      const r = await this.communicationManager._send_cmd({
        cmd: "get_io_value",
        kwargs: { nid: t, ioid: n },
        wait_for_response: !0
      });
      return this.context.worker._zustand && this.context.worker._zustand.on_node_action({
        type: "update",
        node: {
          io: {
            [n]: {
              value: r
            }
          }
        },
        id: t,
        from_remote: !0
      }), r;
    }
    async get_ios_values({ nid: t }) {
      const n = await this.communicationManager._send_cmd({
        cmd: "get_ios_values",
        kwargs: { nid: t },
        wait_for_response: !0
      });
      if (!this.context.worker._zustand) return n;
      const r = {};
      for (const o in n)
        r[o] = { value: n[o] };
      return this.context.worker._zustand.on_node_action({
        type: "update",
        node: {
          io: r
        },
        id: t,
        from_remote: !0
      }), n;
    }
    async get_io_full_value({ nid: t, ioid: n }) {
      const r = await this.communicationManager._send_cmd({
        cmd: "get_io_full_value",
        kwargs: { nid: t, ioid: n },
        wait_for_response: !0,
        as_bytes: !0
      }), { header: o, bytes: i } = r, { mime: a } = o, s = H6({
        data: i,
        mime: a || "application/octet-stream"
      });
      return this.context.worker._zustand?.on_node_action?.({
        type: "update",
        node: {
          id: t,
          io: {
            [n]: {
              fullvalue: s
            }
          }
        },
        id: t,
        from_remote: !0
      }), s;
    }
    async update_io_options({
      nid: t,
      ioid: n,
      options: r
    }) {
      const o = await this.communicationManager._send_cmd({
        cmd: "update_io_options",
        kwargs: { nid: t, ioid: n, ...r },
        wait_for_response: !0
      });
      if (!this.context.worker._zustand) return o;
      this.context.worker._zustand.on_node_action({
        type: "update",
        node: {
          io: {
            [n]: {
              ...r
            }
          }
        },
        id: t,
        from_remote: !0
      });
    }
    async get_node_status(t) {
      return await this.communicationManager._send_cmd({
        cmd: "get_node_state",
        kwargs: { nid: t },
        wait_for_response: !0
      });
    }
    async get_remote_node_state(t) {
      const n = await this.communicationManager._send_cmd({
        cmd: "get_node_state",
        kwargs: { nid: t },
        wait_for_response: !0
      });
      this.context.worker._zustand && this.context.worker._zustand.on_node_action({
        type: "update",
        node: n,
        id: n.id,
        from_remote: !0
      });
    }
  }
  class vue extends Ya {
    start() {
    }
    stop() {
    }
    add_edge({
      src_nid: t,
      src_ioid: n,
      trg_nid: r,
      trg_ioid: o,
      replace: i = !1
    }) {
      return this.communicationManager._send_cmd({
        cmd: "add_edge",
        kwargs: { src_nid: t, src_ioid: n, trg_nid: r, trg_ioid: o, replace: i }
      });
    }
    remove_edge({
      src_nid: t,
      src_ioid: n,
      trg_nid: r,
      trg_ioid: o
    }) {
      return this.communicationManager._send_cmd({
        cmd: "remove_edge",
        kwargs: { src_nid: t, src_ioid: n, trg_nid: r, trg_ioid: o }
      });
    }
  }
  class bue extends Ya {
    start() {
    }
    stop() {
    }
    async group_nodes(t, n) {
      const r = await this.communicationManager._send_cmd({
        cmd: "group_nodes",
        kwargs: { node_ids: t, group_ids: n },
        wait_for_response: !0
      });
      return this.eventManager._receive_groups(r), r;
    }
    async remove_group(t) {
      await this.communicationManager._send_cmd({
        cmd: "remove_group",
        kwargs: { gid: t },
        wait_for_response: !0
      }), await this.syncManager.sync_nodespace();
    }
    locally_update_group(t) {
      this.syncManager.locally_update_group(t);
    }
  }
  class xue extends Ya {
    start() {
    }
    stop() {
    }
    async add_external_worker({
      module: t,
      cls_module: n,
      cls_name: r
    }) {
      return await this.communicationManager._send_cmd({
        cmd: "add_external_worker",
        kwargs: { module: t, cls_module: n, cls_name: r }
      });
    }
    async add_lib(t, n) {
      return await this.communicationManager._send_cmd({
        cmd: "add_package_dependency",
        kwargs: { name: t, version: n },
        wait_for_response: !1
      });
    }
    async remove_lib(t) {
      return await this.communicationManager._send_cmd({
        cmd: "remove_package_dependency",
        kwargs: { name: t },
        wait_for_response: !1
      });
    }
    async get_available_modules() {
      return await this.communicationManager._send_cmd({
        cmd: "get_available_modules",
        wait_for_response: !0,
        unique: !0
      });
    }
    async remove_external_worker(t, n) {
      return await this.communicationManager._send_cmd({
        cmd: "remove_external_worker",
        kwargs: { worker_id: t, class_id: n },
        wait_for_response: !0
      });
    }
    async get_external_worker_config(t, n) {
      return await this.communicationManager._send_cmd({
        cmd: "get_external_worker_config",
        kwargs: { worker_id: t, class_id: n },
        wait_for_response: !0
      });
    }
  }
  class wue {
    // Public getter for handlers to access eventManager
    getEventManager() {
      return this._eventManager;
    }
    getSyncManager() {
      return this._syncManager;
    }
    getCommunicationManager() {
      return this._communicationManager;
    }
    getConnectionHealthManager() {
      return this._connectionhealthManager;
    }
    getHookManager() {
      return this._hookManager;
    }
    getNodeManager() {
      return this._nodeManager;
    }
    getEdgeManager() {
      return this._edgeManager;
    }
    getGroupManager() {
      return this._groupManager;
    }
    getLibraryManager() {
      return this._libraryManager;
    }
    constructor(t) {
      this.uuid = t.uuid, this.on_error = t.on_error || ((r) => {
        this._zustand?.logger.error(r);
      }), this.state = To((r, o) => ({
        is_open: !1
      }));
      const n = { worker: this };
      this._connectionhealthManager = new fue(
        n
      ), this._communicationManager = new hue(n), this._eventManager = new mue({
        ...n
      }), this._syncManager = new due({
        ...n,
        on_sync_complete: t.on_sync_complete
      }), this._hookManager = new gue(n), this._nodeManager = new yue(n), this._edgeManager = new vue(n), this._groupManager = new bue(n), this._libraryManager = new xue(n), this._communicationManager.start(), this._connectionhealthManager.start(), this._syncManager.start(), this._eventManager.start(), this._hookManager.start(), this._nodeManager.start(), this._edgeManager.start(), this._groupManager.start(), this._libraryManager.start(), t.zustand && this.set_zustand(t.zustand), this.api = {
        node: this._nodeManager,
        group: this._groupManager,
        edge: this._edgeManager,
        hooks: this._hookManager,
        lib: this._libraryManager
      };
    }
    set_zustand(t) {
      t !== this._zustand && (t.logger.debug("Setting zustand for worker"), this._zustand = t, t.set_worker(this), this._zustand.auto_progress(), this._syncManager.stepwise_fullsync());
    }
    get is_open() {
      return this.state.getState().is_open;
    }
    set is_open(t) {
      this.state.setState({ is_open: t });
    }
    get is_responsive() {
      return this._connectionhealthManager.isResponsive();
    }
    clear() {
      return this._communicationManager._send_cmd({ cmd: "clear", unique: !0 });
    }
    save() {
      return this._communicationManager._send_cmd({
        cmd: "save",
        wait_for_response: !0,
        unique: !0
      });
    }
    load(t) {
      return this._communicationManager._send_cmd({
        cmd: "load_data",
        kwargs: { data: t },
        wait_for_response: !0
      }).then(() => {
        this._syncManager.stepwise_fullsync();
      });
    }
    async get_runstate() {
      return await this._communicationManager._send_cmd({
        cmd: "get_runstate",
        wait_for_response: !0,
        unique: !0
      });
    }
    async send(t) {
      throw new Error("async send(data: any)  not implemented");
    }
    async upload_file(t) {
      throw new Error("upload_file not implemented ");
    }
    async handle_large_message_hint({}) {
      throw new Error(
        "async handle_large_message_hint({}: LargeMessageHint) not implemented "
      );
    }
    disconnect() {
    }
    onclose() {
      this.is_open = !1, this._zustand && this._zustand.auto_progress();
    }
    async reconnect() {
    }
    async stop() {
      await this._communicationManager._send_cmd({
        cmd: "stop_worker",
        wait_for_response: !1
      });
      const t = this.onclose.bind(this);
      this.onclose = () => {
        t(), this._zustand && (this._zustand.worker === this && this._zustand.clear_all(), this.onclose = t);
      };
    }
    async update_external_worker(t, n, r) {
      return await this._communicationManager._send_cmd({
        cmd: "update_external_worker",
        kwargs: { worker_id: t, class_id: n, ...r },
        wait_for_response: !0
      });
    }
    async export({ withFiles: t = !1 }) {
      return await this._communicationManager._send_cmd({
        cmd: "export_worker",
        wait_for_response: !0,
        kwargs: { with_files: t }
      });
    }
    async update_from_export(t) {
      const n = this._hookManager.add_hook("node_added", async ({}) => {
        this._zustand?.center_all();
      });
      try {
        const r = await this._communicationManager._send_cmd({
          cmd: "update_from_export",
          kwargs: { data: t },
          wait_for_response: !0,
          response_timeout: 6e5,
          // 10 minutes
          unique: !0
        });
        return await new Promise((o) => {
          setTimeout(() => {
            o();
          }, 1e3);
        }), await this._syncManager.stepwise_fullsync(), r;
      } finally {
        n();
      }
    }
    /**
     * @deprecated This method is deprecated. Use the API or getCommunicationManager()._send_cmd directly instead.
     */
    _send_cmd(t) {
      return this._communicationManager._send_cmd(t);
    }
    /**
     * @deprecated This method is deprecated. Use the API or getNodeManager().set_io_value directly instead.
     */
    set_io_value(t) {
      return this._nodeManager.set_io_value(t);
    }
    /**
     * @deprecated This method is deprecated. Use the API or getNodeManager().get_io_value directly instead.
     */
    get_io_value(t) {
      return this._nodeManager.get_io_value(t);
    }
  }
  function q6(e, t) {
    return function() {
      return e.apply(t, arguments);
    };
  }
  const { toString: Sue } = Object.prototype, { getPrototypeOf: dT } = Object, { iterator: Rb, toStringTag: W6 } = Symbol, Ob = /* @__PURE__ */ ((e) => (t) => {
    const n = Sue.call(t);
    return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null)), ni = (e) => (e = e.toLowerCase(), (t) => Ob(t) === e), Ab = (e) => (t) => typeof t === e, { isArray: Of } = Array, Jp = Ab("undefined");
  function Hh(e) {
    return e !== null && !Jp(e) && e.constructor !== null && !Jp(e.constructor) && zr(e.constructor.isBuffer) && e.constructor.isBuffer(e);
  }
  const G6 = ni("ArrayBuffer");
  function _ue(e) {
    let t;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && G6(e.buffer), t;
  }
  const Eue = Ab("string"), zr = Ab("function"), K6 = Ab("number"), qh = (e) => e !== null && typeof e == "object", Cue = (e) => e === !0 || e === !1, xv = (e) => {
    if (Ob(e) !== "object")
      return !1;
    const t = dT(e);
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(W6 in e) && !(Rb in e);
  }, kue = (e) => {
    if (!qh(e) || Hh(e))
      return !1;
    try {
      return Object.keys(e).length === 0 && Object.getPrototypeOf(e) === Object.prototype;
    } catch {
      return !1;
    }
  }, Tue = ni("Date"), Rue = ni("File"), Oue = ni("Blob"), Aue = ni("FileList"), Nue = (e) => qh(e) && zr(e.pipe), Mue = (e) => {
    let t;
    return e && (typeof FormData == "function" && e instanceof FormData || zr(e.append) && ((t = Ob(e)) === "formdata" || // detect form-data instance
    t === "object" && zr(e.toString) && e.toString() === "[object FormData]"));
  }, Pue = ni("URLSearchParams"), [$ue, Iue, jue, Due] = ["ReadableStream", "Request", "Response", "Headers"].map(ni), Fue = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function Wh(e, t, { allOwnKeys: n = !1 } = {}) {
    if (e === null || typeof e > "u")
      return;
    let r, o;
    if (typeof e != "object" && (e = [e]), Of(e))
      for (r = 0, o = e.length; r < o; r++)
        t.call(null, e[r], r, e);
    else {
      if (Hh(e))
        return;
      const i = n ? Object.getOwnPropertyNames(e) : Object.keys(e), a = i.length;
      let s;
      for (r = 0; r < a; r++)
        s = i[r], t.call(null, e[s], s, e);
    }
  }
  function Y6(e, t) {
    if (Hh(e))
      return null;
    t = t.toLowerCase();
    const n = Object.keys(e);
    let r = n.length, o;
    for (; r-- > 0; )
      if (o = n[r], t === o.toLowerCase())
        return o;
    return null;
  }
  const Yl = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : window, X6 = (e) => !Jp(e) && e !== Yl;
  function HE() {
    const { caseless: e } = X6(this) && this || {}, t = {}, n = (r, o) => {
      const i = e && Y6(t, o) || o;
      xv(t[i]) && xv(r) ? t[i] = HE(t[i], r) : xv(r) ? t[i] = HE({}, r) : Of(r) ? t[i] = r.slice() : t[i] = r;
    };
    for (let r = 0, o = arguments.length; r < o; r++)
      arguments[r] && Wh(arguments[r], n);
    return t;
  }
  const Lue = (e, t, n, { allOwnKeys: r } = {}) => (Wh(t, (o, i) => {
    n && zr(o) ? e[i] = q6(o, n) : e[i] = o;
  }, { allOwnKeys: r }), e), zue = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), Bue = (e, t, n, r) => {
    e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
      value: t.prototype
    }), n && Object.assign(e.prototype, n);
  }, Uue = (e, t, n, r) => {
    let o, i, a;
    const s = {};
    if (t = t || {}, e == null) return t;
    do {
      for (o = Object.getOwnPropertyNames(e), i = o.length; i-- > 0; )
        a = o[i], (!r || r(a, e, t)) && !s[a] && (t[a] = e[a], s[a] = !0);
      e = n !== !1 && dT(e);
    } while (e && (!n || n(e, t)) && e !== Object.prototype);
    return t;
  }, Vue = (e, t, n) => {
    e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
    const r = e.indexOf(t, n);
    return r !== -1 && r === n;
  }, Hue = (e) => {
    if (!e) return null;
    if (Of(e)) return e;
    let t = e.length;
    if (!K6(t)) return null;
    const n = new Array(t);
    for (; t-- > 0; )
      n[t] = e[t];
    return n;
  }, que = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && dT(Uint8Array)), Wue = (e, t) => {
    const r = (e && e[Rb]).call(e);
    let o;
    for (; (o = r.next()) && !o.done; ) {
      const i = o.value;
      t.call(e, i[0], i[1]);
    }
  }, Gue = (e, t) => {
    let n;
    const r = [];
    for (; (n = e.exec(t)) !== null; )
      r.push(n);
    return r;
  }, Kue = ni("HTMLFormElement"), Yue = (e) => e.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function(n, r, o) {
      return r.toUpperCase() + o;
    }
  ), W2 = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), Xue = ni("RegExp"), Z6 = (e, t) => {
    const n = Object.getOwnPropertyDescriptors(e), r = {};
    Wh(n, (o, i) => {
      let a;
      (a = t(o, i, e)) !== !1 && (r[i] = a || o);
    }), Object.defineProperties(e, r);
  }, Zue = (e) => {
    Z6(e, (t, n) => {
      if (zr(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
        return !1;
      const r = e[n];
      if (zr(r)) {
        if (t.enumerable = !1, "writable" in t) {
          t.writable = !1;
          return;
        }
        t.set || (t.set = () => {
          throw Error("Can not rewrite read-only method '" + n + "'");
        });
      }
    });
  }, Que = (e, t) => {
    const n = {}, r = (o) => {
      o.forEach((i) => {
        n[i] = !0;
      });
    };
    return Of(e) ? r(e) : r(String(e).split(t)), n;
  }, Jue = () => {
  }, efe = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
  function tfe(e) {
    return !!(e && zr(e.append) && e[W6] === "FormData" && e[Rb]);
  }
  const nfe = (e) => {
    const t = new Array(10), n = (r, o) => {
      if (qh(r)) {
        if (t.indexOf(r) >= 0)
          return;
        if (Hh(r))
          return r;
        if (!("toJSON" in r)) {
          t[o] = r;
          const i = Of(r) ? [] : {};
          return Wh(r, (a, s) => {
            const l = n(a, o + 1);
            !Jp(l) && (i[s] = l);
          }), t[o] = void 0, i;
        }
      }
      return r;
    };
    return n(e, 0);
  }, rfe = ni("AsyncFunction"), ofe = (e) => e && (qh(e) || zr(e)) && zr(e.then) && zr(e.catch), Q6 = ((e, t) => e ? setImmediate : t ? ((n, r) => (Yl.addEventListener("message", ({ source: o, data: i }) => {
    o === Yl && i === n && r.length && r.shift()();
  }, !1), (o) => {
    r.push(o), Yl.postMessage(n, "*");
  }))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
    typeof setImmediate == "function",
    zr(Yl.postMessage)
  ), ife = typeof queueMicrotask < "u" ? queueMicrotask.bind(Yl) : typeof process < "u" && process.nextTick || Q6, afe = (e) => e != null && zr(e[Rb]), ye = {
    isArray: Of,
    isArrayBuffer: G6,
    isBuffer: Hh,
    isFormData: Mue,
    isArrayBufferView: _ue,
    isString: Eue,
    isNumber: K6,
    isBoolean: Cue,
    isObject: qh,
    isPlainObject: xv,
    isEmptyObject: kue,
    isReadableStream: $ue,
    isRequest: Iue,
    isResponse: jue,
    isHeaders: Due,
    isUndefined: Jp,
    isDate: Tue,
    isFile: Rue,
    isBlob: Oue,
    isRegExp: Xue,
    isFunction: zr,
    isStream: Nue,
    isURLSearchParams: Pue,
    isTypedArray: que,
    isFileList: Aue,
    forEach: Wh,
    merge: HE,
    extend: Lue,
    trim: Fue,
    stripBOM: zue,
    inherits: Bue,
    toFlatObject: Uue,
    kindOf: Ob,
    kindOfTest: ni,
    endsWith: Vue,
    toArray: Hue,
    forEachEntry: Wue,
    matchAll: Gue,
    isHTMLForm: Kue,
    hasOwnProperty: W2,
    hasOwnProp: W2,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors: Z6,
    freezeMethods: Zue,
    toObjectSet: Que,
    toCamelCase: Yue,
    noop: Jue,
    toFiniteNumber: efe,
    findKey: Y6,
    global: Yl,
    isContextDefined: X6,
    isSpecCompliantForm: tfe,
    toJSONObject: nfe,
    isAsyncFn: rfe,
    isThenable: ofe,
    setImmediate: Q6,
    asap: ife,
    isIterable: afe
  };
  function st(e, t, n, r, o) {
    Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), o && (this.response = o, this.status = o.status ? o.status : null);
  }
  ye.inherits(st, Error, {
    toJSON: function() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: ye.toJSONObject(this.config),
        code: this.code,
        status: this.status
      };
    }
  });
  const J6 = st.prototype, e9 = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((e) => {
    e9[e] = { value: e };
  });
  Object.defineProperties(st, e9);
  Object.defineProperty(J6, "isAxiosError", { value: !0 });
  st.from = (e, t, n, r, o, i) => {
    const a = Object.create(J6);
    return ye.toFlatObject(e, a, function(l) {
      return l !== Error.prototype;
    }, (s) => s !== "isAxiosError"), st.call(a, e.message, t, n, r, o), a.cause = e, a.name = e.name, i && Object.assign(a, i), a;
  };
  const sfe = null;
  function qE(e) {
    return ye.isPlainObject(e) || ye.isArray(e);
  }
  function t9(e) {
    return ye.endsWith(e, "[]") ? e.slice(0, -2) : e;
  }
  function G2(e, t, n) {
    return e ? e.concat(t).map(function(o, i) {
      return o = t9(o), !n && i ? "[" + o + "]" : o;
    }).join(n ? "." : "") : t;
  }
  function lfe(e) {
    return ye.isArray(e) && !e.some(qE);
  }
  const cfe = ye.toFlatObject(ye, {}, null, function(t) {
    return /^is[A-Z]/.test(t);
  });
  function Nb(e, t, n) {
    if (!ye.isObject(e))
      throw new TypeError("target must be an object");
    t = t || new FormData(), n = ye.toFlatObject(n, {
      metaTokens: !0,
      dots: !1,
      indexes: !1
    }, !1, function(b, v) {
      return !ye.isUndefined(v[b]);
    });
    const r = n.metaTokens, o = n.visitor || d, i = n.dots, a = n.indexes, l = (n.Blob || typeof Blob < "u" && Blob) && ye.isSpecCompliantForm(t);
    if (!ye.isFunction(o))
      throw new TypeError("visitor must be a function");
    function u(y) {
      if (y === null) return "";
      if (ye.isDate(y))
        return y.toISOString();
      if (ye.isBoolean(y))
        return y.toString();
      if (!l && ye.isBlob(y))
        throw new st("Blob is not supported. Use a Buffer instead.");
      return ye.isArrayBuffer(y) || ye.isTypedArray(y) ? l && typeof Blob == "function" ? new Blob([y]) : Buffer.from(y) : y;
    }
    function d(y, b, v) {
      let x = y;
      if (y && !v && typeof y == "object") {
        if (ye.endsWith(b, "{}"))
          b = r ? b : b.slice(0, -2), y = JSON.stringify(y);
        else if (ye.isArray(y) && lfe(y) || (ye.isFileList(y) || ye.endsWith(b, "[]")) && (x = ye.toArray(y)))
          return b = t9(b), x.forEach(function(_, C) {
            !(ye.isUndefined(_) || _ === null) && t.append(
              // eslint-disable-next-line no-nested-ternary
              a === !0 ? G2([b], C, i) : a === null ? b : b + "[]",
              u(_)
            );
          }), !1;
      }
      return qE(y) ? !0 : (t.append(G2(v, b, i), u(y)), !1);
    }
    const p = [], h = Object.assign(cfe, {
      defaultVisitor: d,
      convertValue: u,
      isVisitable: qE
    });
    function g(y, b) {
      if (!ye.isUndefined(y)) {
        if (p.indexOf(y) !== -1)
          throw Error("Circular reference detected in " + b.join("."));
        p.push(y), ye.forEach(y, function(x, E) {
          (!(ye.isUndefined(x) || x === null) && o.call(
            t,
            x,
            ye.isString(E) ? E.trim() : E,
            b,
            h
          )) === !0 && g(x, b ? b.concat(E) : [E]);
        }), p.pop();
      }
    }
    if (!ye.isObject(e))
      throw new TypeError("data must be an object");
    return g(e), t;
  }
  function K2(e) {
    const t = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
      return t[r];
    });
  }
  function pT(e, t) {
    this._pairs = [], e && Nb(e, this, t);
  }
  const n9 = pT.prototype;
  n9.append = function(t, n) {
    this._pairs.push([t, n]);
  };
  n9.toString = function(t) {
    const n = t ? function(r) {
      return t.call(this, r, K2);
    } : K2;
    return this._pairs.map(function(o) {
      return n(o[0]) + "=" + n(o[1]);
    }, "").join("&");
  };
  function ufe(e) {
    return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function r9(e, t, n) {
    if (!t)
      return e;
    const r = n && n.encode || ufe;
    ye.isFunction(n) && (n = {
      serialize: n
    });
    const o = n && n.serialize;
    let i;
    if (o ? i = o(t, n) : i = ye.isURLSearchParams(t) ? t.toString() : new pT(t, n).toString(r), i) {
      const a = e.indexOf("#");
      a !== -1 && (e = e.slice(0, a)), e += (e.indexOf("?") === -1 ? "?" : "&") + i;
    }
    return e;
  }
  class Y2 {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(t, n, r) {
      return this.handlers.push({
        fulfilled: t,
        rejected: n,
        synchronous: r ? r.synchronous : !1,
        runWhen: r ? r.runWhen : null
      }), this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
     */
    eject(t) {
      this.handlers[t] && (this.handlers[t] = null);
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      this.handlers && (this.handlers = []);
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(t) {
      ye.forEach(this.handlers, function(r) {
        r !== null && t(r);
      });
    }
  }
  const o9 = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
  }, ffe = typeof URLSearchParams < "u" ? URLSearchParams : pT, dfe = typeof FormData < "u" ? FormData : null, pfe = typeof Blob < "u" ? Blob : null, hfe = {
    isBrowser: !0,
    classes: {
      URLSearchParams: ffe,
      FormData: dfe,
      Blob: pfe
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
  }, hT = typeof window < "u" && typeof document < "u", WE = typeof navigator == "object" && navigator || void 0, mfe = hT && (!WE || ["ReactNative", "NativeScript", "NS"].indexOf(WE.product) < 0), gfe = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts == "function", yfe = hT && window.location.href || "http://localhost", vfe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    hasBrowserEnv: hT,
    hasStandardBrowserEnv: mfe,
    hasStandardBrowserWebWorkerEnv: gfe,
    navigator: WE,
    origin: yfe
  }, Symbol.toStringTag, { value: "Module" })), mr = {
    ...vfe,
    ...hfe
  };
  function bfe(e, t) {
    return Nb(e, new mr.classes.URLSearchParams(), {
      visitor: function(n, r, o, i) {
        return mr.isNode && ye.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : i.defaultVisitor.apply(this, arguments);
      },
      ...t
    });
  }
  function xfe(e) {
    return ye.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
  }
  function wfe(e) {
    const t = {}, n = Object.keys(e);
    let r;
    const o = n.length;
    let i;
    for (r = 0; r < o; r++)
      i = n[r], t[i] = e[i];
    return t;
  }
  function i9(e) {
    function t(n, r, o, i) {
      let a = n[i++];
      if (a === "__proto__") return !0;
      const s = Number.isFinite(+a), l = i >= n.length;
      return a = !a && ye.isArray(o) ? o.length : a, l ? (ye.hasOwnProp(o, a) ? o[a] = [o[a], r] : o[a] = r, !s) : ((!o[a] || !ye.isObject(o[a])) && (o[a] = []), t(n, r, o[a], i) && ye.isArray(o[a]) && (o[a] = wfe(o[a])), !s);
    }
    if (ye.isFormData(e) && ye.isFunction(e.entries)) {
      const n = {};
      return ye.forEachEntry(e, (r, o) => {
        t(xfe(r), o, n, 0);
      }), n;
    }
    return null;
  }
  function Sfe(e, t, n) {
    if (ye.isString(e))
      try {
        return (t || JSON.parse)(e), ye.trim(e);
      } catch (r) {
        if (r.name !== "SyntaxError")
          throw r;
      }
    return (n || JSON.stringify)(e);
  }
  const Gh = {
    transitional: o9,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function(t, n) {
      const r = n.getContentType() || "", o = r.indexOf("application/json") > -1, i = ye.isObject(t);
      if (i && ye.isHTMLForm(t) && (t = new FormData(t)), ye.isFormData(t))
        return o ? JSON.stringify(i9(t)) : t;
      if (ye.isArrayBuffer(t) || ye.isBuffer(t) || ye.isStream(t) || ye.isFile(t) || ye.isBlob(t) || ye.isReadableStream(t))
        return t;
      if (ye.isArrayBufferView(t))
        return t.buffer;
      if (ye.isURLSearchParams(t))
        return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
      let s;
      if (i) {
        if (r.indexOf("application/x-www-form-urlencoded") > -1)
          return bfe(t, this.formSerializer).toString();
        if ((s = ye.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
          const l = this.env && this.env.FormData;
          return Nb(
            s ? { "files[]": t } : t,
            l && new l(),
            this.formSerializer
          );
        }
      }
      return i || o ? (n.setContentType("application/json", !1), Sfe(t)) : t;
    }],
    transformResponse: [function(t) {
      const n = this.transitional || Gh.transitional, r = n && n.forcedJSONParsing, o = this.responseType === "json";
      if (ye.isResponse(t) || ye.isReadableStream(t))
        return t;
      if (t && ye.isString(t) && (r && !this.responseType || o)) {
        const a = !(n && n.silentJSONParsing) && o;
        try {
          return JSON.parse(t);
        } catch (s) {
          if (a)
            throw s.name === "SyntaxError" ? st.from(s, st.ERR_BAD_RESPONSE, this, null, this.response) : s;
        }
      }
      return t;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: mr.classes.FormData,
      Blob: mr.classes.Blob
    },
    validateStatus: function(t) {
      return t >= 200 && t < 300;
    },
    headers: {
      common: {
        Accept: "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  ye.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
    Gh.headers[e] = {};
  });
  const _fe = ye.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]), Efe = (e) => {
    const t = {};
    let n, r, o;
    return e && e.split(`
`).forEach(function(a) {
      o = a.indexOf(":"), n = a.substring(0, o).trim().toLowerCase(), r = a.substring(o + 1).trim(), !(!n || t[n] && _fe[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
    }), t;
  }, X2 = Symbol("internals");
  function Wd(e) {
    return e && String(e).trim().toLowerCase();
  }
  function wv(e) {
    return e === !1 || e == null ? e : ye.isArray(e) ? e.map(wv) : String(e);
  }
  function Cfe(e) {
    const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let r;
    for (; r = n.exec(e); )
      t[r[1]] = r[2];
    return t;
  }
  const kfe = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
  function FS(e, t, n, r, o) {
    if (ye.isFunction(r))
      return r.call(this, t, n);
    if (o && (t = n), !!ye.isString(t)) {
      if (ye.isString(r))
        return t.indexOf(r) !== -1;
      if (ye.isRegExp(r))
        return r.test(t);
    }
  }
  function Tfe(e) {
    return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
  }
  function Rfe(e, t) {
    const n = ye.toCamelCase(" " + t);
    ["get", "set", "has"].forEach((r) => {
      Object.defineProperty(e, r + n, {
        value: function(o, i, a) {
          return this[r].call(this, t, o, i, a);
        },
        configurable: !0
      });
    });
  }
  let Br = class {
    constructor(t) {
      t && this.set(t);
    }
    set(t, n, r) {
      const o = this;
      function i(s, l, u) {
        const d = Wd(l);
        if (!d)
          throw new Error("header name must be a non-empty string");
        const p = ye.findKey(o, d);
        (!p || o[p] === void 0 || u === !0 || u === void 0 && o[p] !== !1) && (o[p || l] = wv(s));
      }
      const a = (s, l) => ye.forEach(s, (u, d) => i(u, d, l));
      if (ye.isPlainObject(t) || t instanceof this.constructor)
        a(t, n);
      else if (ye.isString(t) && (t = t.trim()) && !kfe(t))
        a(Efe(t), n);
      else if (ye.isObject(t) && ye.isIterable(t)) {
        let s = {}, l, u;
        for (const d of t) {
          if (!ye.isArray(d))
            throw TypeError("Object iterator must return a key-value pair");
          s[u = d[0]] = (l = s[u]) ? ye.isArray(l) ? [...l, d[1]] : [l, d[1]] : d[1];
        }
        a(s, n);
      } else
        t != null && i(n, t, r);
      return this;
    }
    get(t, n) {
      if (t = Wd(t), t) {
        const r = ye.findKey(this, t);
        if (r) {
          const o = this[r];
          if (!n)
            return o;
          if (n === !0)
            return Cfe(o);
          if (ye.isFunction(n))
            return n.call(this, o, r);
          if (ye.isRegExp(n))
            return n.exec(o);
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(t, n) {
      if (t = Wd(t), t) {
        const r = ye.findKey(this, t);
        return !!(r && this[r] !== void 0 && (!n || FS(this, this[r], r, n)));
      }
      return !1;
    }
    delete(t, n) {
      const r = this;
      let o = !1;
      function i(a) {
        if (a = Wd(a), a) {
          const s = ye.findKey(r, a);
          s && (!n || FS(r, r[s], s, n)) && (delete r[s], o = !0);
        }
      }
      return ye.isArray(t) ? t.forEach(i) : i(t), o;
    }
    clear(t) {
      const n = Object.keys(this);
      let r = n.length, o = !1;
      for (; r--; ) {
        const i = n[r];
        (!t || FS(this, this[i], i, t, !0)) && (delete this[i], o = !0);
      }
      return o;
    }
    normalize(t) {
      const n = this, r = {};
      return ye.forEach(this, (o, i) => {
        const a = ye.findKey(r, i);
        if (a) {
          n[a] = wv(o), delete n[i];
          return;
        }
        const s = t ? Tfe(i) : String(i).trim();
        s !== i && delete n[i], n[s] = wv(o), r[s] = !0;
      }), this;
    }
    concat(...t) {
      return this.constructor.concat(this, ...t);
    }
    toJSON(t) {
      const n = /* @__PURE__ */ Object.create(null);
      return ye.forEach(this, (r, o) => {
        r != null && r !== !1 && (n[o] = t && ye.isArray(r) ? r.join(", ") : r);
      }), n;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
    }
    getSetCookie() {
      return this.get("set-cookie") || [];
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(t) {
      return t instanceof this ? t : new this(t);
    }
    static concat(t, ...n) {
      const r = new this(t);
      return n.forEach((o) => r.set(o)), r;
    }
    static accessor(t) {
      const r = (this[X2] = this[X2] = {
        accessors: {}
      }).accessors, o = this.prototype;
      function i(a) {
        const s = Wd(a);
        r[s] || (Rfe(o, a), r[s] = !0);
      }
      return ye.isArray(t) ? t.forEach(i) : i(t), this;
    }
  };
  Br.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  ye.reduceDescriptors(Br.prototype, ({ value: e }, t) => {
    let n = t[0].toUpperCase() + t.slice(1);
    return {
      get: () => e,
      set(r) {
        this[n] = r;
      }
    };
  });
  ye.freezeMethods(Br);
  function LS(e, t) {
    const n = this || Gh, r = t || n, o = Br.from(r.headers);
    let i = r.data;
    return ye.forEach(e, function(s) {
      i = s.call(n, i, o.normalize(), t ? t.status : void 0);
    }), o.normalize(), i;
  }
  function a9(e) {
    return !!(e && e.__CANCEL__);
  }
  function Af(e, t, n) {
    st.call(this, e ?? "canceled", st.ERR_CANCELED, t, n), this.name = "CanceledError";
  }
  ye.inherits(Af, st, {
    __CANCEL__: !0
  });
  function s9(e, t, n) {
    const r = n.config.validateStatus;
    !n.status || !r || r(n.status) ? e(n) : t(new st(
      "Request failed with status code " + n.status,
      [st.ERR_BAD_REQUEST, st.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
      n.config,
      n.request,
      n
    ));
  }
  function Ofe(e) {
    const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
    return t && t[1] || "";
  }
  function Afe(e, t) {
    e = e || 10;
    const n = new Array(e), r = new Array(e);
    let o = 0, i = 0, a;
    return t = t !== void 0 ? t : 1e3, function(l) {
      const u = Date.now(), d = r[i];
      a || (a = u), n[o] = l, r[o] = u;
      let p = i, h = 0;
      for (; p !== o; )
        h += n[p++], p = p % e;
      if (o = (o + 1) % e, o === i && (i = (i + 1) % e), u - a < t)
        return;
      const g = d && u - d;
      return g ? Math.round(h * 1e3 / g) : void 0;
    };
  }
  function Nfe(e, t) {
    let n = 0, r = 1e3 / t, o, i;
    const a = (u, d = Date.now()) => {
      n = d, o = null, i && (clearTimeout(i), i = null), e(...u);
    };
    return [(...u) => {
      const d = Date.now(), p = d - n;
      p >= r ? a(u, d) : (o = u, i || (i = setTimeout(() => {
        i = null, a(o);
      }, r - p)));
    }, () => o && a(o)];
  }
  const a0 = (e, t, n = 3) => {
    let r = 0;
    const o = Afe(50, 250);
    return Nfe((i) => {
      const a = i.loaded, s = i.lengthComputable ? i.total : void 0, l = a - r, u = o(l), d = a <= s;
      r = a;
      const p = {
        loaded: a,
        total: s,
        progress: s ? a / s : void 0,
        bytes: l,
        rate: u || void 0,
        estimated: u && s && d ? (s - a) / u : void 0,
        event: i,
        lengthComputable: s != null,
        [t ? "download" : "upload"]: !0
      };
      e(p);
    }, n);
  }, Z2 = (e, t) => {
    const n = e != null;
    return [(r) => t[0]({
      lengthComputable: n,
      total: e,
      loaded: r
    }), t[1]];
  }, Q2 = (e) => (...t) => ye.asap(() => e(...t)), Mfe = mr.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t) => (n) => (n = new URL(n, mr.origin), e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(
    new URL(mr.origin),
    mr.navigator && /(msie|trident)/i.test(mr.navigator.userAgent)
  ) : () => !0, Pfe = mr.hasStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    {
      write(e, t, n, r, o, i) {
        const a = [e + "=" + encodeURIComponent(t)];
        ye.isNumber(n) && a.push("expires=" + new Date(n).toGMTString()), ye.isString(r) && a.push("path=" + r), ye.isString(o) && a.push("domain=" + o), i === !0 && a.push("secure"), document.cookie = a.join("; ");
      },
      read(e) {
        const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
        return t ? decodeURIComponent(t[3]) : null;
      },
      remove(e) {
        this.write(e, "", Date.now() - 864e5);
      }
    }
  ) : (
    // Non-standard browser env (web workers, react-native) lack needed support.
    {
      write() {
      },
      read() {
        return null;
      },
      remove() {
      }
    }
  );
  function $fe(e) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
  }
  function Ife(e, t) {
    return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
  }
  function l9(e, t, n) {
    let r = !$fe(t);
    return e && (r || n == !1) ? Ife(e, t) : t;
  }
  const J2 = (e) => e instanceof Br ? { ...e } : e;
  function sc(e, t) {
    t = t || {};
    const n = {};
    function r(u, d, p, h) {
      return ye.isPlainObject(u) && ye.isPlainObject(d) ? ye.merge.call({ caseless: h }, u, d) : ye.isPlainObject(d) ? ye.merge({}, d) : ye.isArray(d) ? d.slice() : d;
    }
    function o(u, d, p, h) {
      if (ye.isUndefined(d)) {
        if (!ye.isUndefined(u))
          return r(void 0, u, p, h);
      } else return r(u, d, p, h);
    }
    function i(u, d) {
      if (!ye.isUndefined(d))
        return r(void 0, d);
    }
    function a(u, d) {
      if (ye.isUndefined(d)) {
        if (!ye.isUndefined(u))
          return r(void 0, u);
      } else return r(void 0, d);
    }
    function s(u, d, p) {
      if (p in t)
        return r(u, d);
      if (p in e)
        return r(void 0, u);
    }
    const l = {
      url: i,
      method: i,
      data: i,
      baseURL: a,
      transformRequest: a,
      transformResponse: a,
      paramsSerializer: a,
      timeout: a,
      timeoutMessage: a,
      withCredentials: a,
      withXSRFToken: a,
      adapter: a,
      responseType: a,
      xsrfCookieName: a,
      xsrfHeaderName: a,
      onUploadProgress: a,
      onDownloadProgress: a,
      decompress: a,
      maxContentLength: a,
      maxBodyLength: a,
      beforeRedirect: a,
      transport: a,
      httpAgent: a,
      httpsAgent: a,
      cancelToken: a,
      socketPath: a,
      responseEncoding: a,
      validateStatus: s,
      headers: (u, d, p) => o(J2(u), J2(d), p, !0)
    };
    return ye.forEach(Object.keys({ ...e, ...t }), function(d) {
      const p = l[d] || o, h = p(e[d], t[d], d);
      ye.isUndefined(h) && p !== s || (n[d] = h);
    }), n;
  }
  const c9 = (e) => {
    const t = sc({}, e);
    let { data: n, withXSRFToken: r, xsrfHeaderName: o, xsrfCookieName: i, headers: a, auth: s } = t;
    t.headers = a = Br.from(a), t.url = r9(l9(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), s && a.set(
      "Authorization",
      "Basic " + btoa((s.username || "") + ":" + (s.password ? unescape(encodeURIComponent(s.password)) : ""))
    );
    let l;
    if (ye.isFormData(n)) {
      if (mr.hasStandardBrowserEnv || mr.hasStandardBrowserWebWorkerEnv)
        a.setContentType(void 0);
      else if ((l = a.getContentType()) !== !1) {
        const [u, ...d] = l ? l.split(";").map((p) => p.trim()).filter(Boolean) : [];
        a.setContentType([u || "multipart/form-data", ...d].join("; "));
      }
    }
    if (mr.hasStandardBrowserEnv && (r && ye.isFunction(r) && (r = r(t)), r || r !== !1 && Mfe(t.url))) {
      const u = o && i && Pfe.read(i);
      u && a.set(o, u);
    }
    return t;
  }, jfe = typeof XMLHttpRequest < "u", Dfe = jfe && function(e) {
    return new Promise(function(n, r) {
      const o = c9(e);
      let i = o.data;
      const a = Br.from(o.headers).normalize();
      let { responseType: s, onUploadProgress: l, onDownloadProgress: u } = o, d, p, h, g, y;
      function b() {
        g && g(), y && y(), o.cancelToken && o.cancelToken.unsubscribe(d), o.signal && o.signal.removeEventListener("abort", d);
      }
      let v = new XMLHttpRequest();
      v.open(o.method.toUpperCase(), o.url, !0), v.timeout = o.timeout;
      function x() {
        if (!v)
          return;
        const _ = Br.from(
          "getAllResponseHeaders" in v && v.getAllResponseHeaders()
        ), k = {
          data: !s || s === "text" || s === "json" ? v.responseText : v.response,
          status: v.status,
          statusText: v.statusText,
          headers: _,
          config: e,
          request: v
        };
        s9(function(A) {
          n(A), b();
        }, function(A) {
          r(A), b();
        }, k), v = null;
      }
      "onloadend" in v ? v.onloadend = x : v.onreadystatechange = function() {
        !v || v.readyState !== 4 || v.status === 0 && !(v.responseURL && v.responseURL.indexOf("file:") === 0) || setTimeout(x);
      }, v.onabort = function() {
        v && (r(new st("Request aborted", st.ECONNABORTED, e, v)), v = null);
      }, v.onerror = function() {
        r(new st("Network Error", st.ERR_NETWORK, e, v)), v = null;
      }, v.ontimeout = function() {
        let C = o.timeout ? "timeout of " + o.timeout + "ms exceeded" : "timeout exceeded";
        const k = o.transitional || o9;
        o.timeoutErrorMessage && (C = o.timeoutErrorMessage), r(new st(
          C,
          k.clarifyTimeoutError ? st.ETIMEDOUT : st.ECONNABORTED,
          e,
          v
        )), v = null;
      }, i === void 0 && a.setContentType(null), "setRequestHeader" in v && ye.forEach(a.toJSON(), function(C, k) {
        v.setRequestHeader(k, C);
      }), ye.isUndefined(o.withCredentials) || (v.withCredentials = !!o.withCredentials), s && s !== "json" && (v.responseType = o.responseType), u && ([h, y] = a0(u, !0), v.addEventListener("progress", h)), l && v.upload && ([p, g] = a0(l), v.upload.addEventListener("progress", p), v.upload.addEventListener("loadend", g)), (o.cancelToken || o.signal) && (d = (_) => {
        v && (r(!_ || _.type ? new Af(null, e, v) : _), v.abort(), v = null);
      }, o.cancelToken && o.cancelToken.subscribe(d), o.signal && (o.signal.aborted ? d() : o.signal.addEventListener("abort", d)));
      const E = Ofe(o.url);
      if (E && mr.protocols.indexOf(E) === -1) {
        r(new st("Unsupported protocol " + E + ":", st.ERR_BAD_REQUEST, e));
        return;
      }
      v.send(i || null);
    });
  }, Ffe = (e, t) => {
    const { length: n } = e = e ? e.filter(Boolean) : [];
    if (t || n) {
      let r = new AbortController(), o;
      const i = function(u) {
        if (!o) {
          o = !0, s();
          const d = u instanceof Error ? u : this.reason;
          r.abort(d instanceof st ? d : new Af(d instanceof Error ? d.message : d));
        }
      };
      let a = t && setTimeout(() => {
        a = null, i(new st(`timeout ${t} of ms exceeded`, st.ETIMEDOUT));
      }, t);
      const s = () => {
        e && (a && clearTimeout(a), a = null, e.forEach((u) => {
          u.unsubscribe ? u.unsubscribe(i) : u.removeEventListener("abort", i);
        }), e = null);
      };
      e.forEach((u) => u.addEventListener("abort", i));
      const { signal: l } = r;
      return l.unsubscribe = () => ye.asap(s), l;
    }
  }, Lfe = function* (e, t) {
    let n = e.byteLength;
    if (n < t) {
      yield e;
      return;
    }
    let r = 0, o;
    for (; r < n; )
      o = r + t, yield e.slice(r, o), r = o;
  }, zfe = async function* (e, t) {
    for await (const n of Bfe(e))
      yield* Lfe(n, t);
  }, Bfe = async function* (e) {
    if (e[Symbol.asyncIterator]) {
      yield* e;
      return;
    }
    const t = e.getReader();
    try {
      for (; ; ) {
        const { done: n, value: r } = await t.read();
        if (n)
          break;
        yield r;
      }
    } finally {
      await t.cancel();
    }
  }, eI = (e, t, n, r) => {
    const o = zfe(e, t);
    let i = 0, a, s = (l) => {
      a || (a = !0, r && r(l));
    };
    return new ReadableStream({
      async pull(l) {
        try {
          const { done: u, value: d } = await o.next();
          if (u) {
            s(), l.close();
            return;
          }
          let p = d.byteLength;
          if (n) {
            let h = i += p;
            n(h);
          }
          l.enqueue(new Uint8Array(d));
        } catch (u) {
          throw s(u), u;
        }
      },
      cancel(l) {
        return s(l), o.return();
      }
    }, {
      highWaterMark: 2
    });
  }, Mb = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", u9 = Mb && typeof ReadableStream == "function", Ufe = Mb && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), f9 = (e, ...t) => {
    try {
      return !!e(...t);
    } catch {
      return !1;
    }
  }, Vfe = u9 && f9(() => {
    let e = !1;
    const t = new Request(mr.origin, {
      body: new ReadableStream(),
      method: "POST",
      get duplex() {
        return e = !0, "half";
      }
    }).headers.has("Content-Type");
    return e && !t;
  }), tI = 64 * 1024, GE = u9 && f9(() => ye.isReadableStream(new Response("").body)), s0 = {
    stream: GE && ((e) => e.body)
  };
  Mb && ((e) => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
      !s0[t] && (s0[t] = ye.isFunction(e[t]) ? (n) => n[t]() : (n, r) => {
        throw new st(`Response type '${t}' is not supported`, st.ERR_NOT_SUPPORT, r);
      });
    });
  })(new Response());
  const Hfe = async (e) => {
    if (e == null)
      return 0;
    if (ye.isBlob(e))
      return e.size;
    if (ye.isSpecCompliantForm(e))
      return (await new Request(mr.origin, {
        method: "POST",
        body: e
      }).arrayBuffer()).byteLength;
    if (ye.isArrayBufferView(e) || ye.isArrayBuffer(e))
      return e.byteLength;
    if (ye.isURLSearchParams(e) && (e = e + ""), ye.isString(e))
      return (await Ufe(e)).byteLength;
  }, qfe = async (e, t) => {
    const n = ye.toFiniteNumber(e.getContentLength());
    return n ?? Hfe(t);
  }, Wfe = Mb && (async (e) => {
    let {
      url: t,
      method: n,
      data: r,
      signal: o,
      cancelToken: i,
      timeout: a,
      onDownloadProgress: s,
      onUploadProgress: l,
      responseType: u,
      headers: d,
      withCredentials: p = "same-origin",
      fetchOptions: h
    } = c9(e);
    u = u ? (u + "").toLowerCase() : "text";
    let g = Ffe([o, i && i.toAbortSignal()], a), y;
    const b = g && g.unsubscribe && (() => {
      g.unsubscribe();
    });
    let v;
    try {
      if (l && Vfe && n !== "get" && n !== "head" && (v = await qfe(d, r)) !== 0) {
        let k = new Request(t, {
          method: "POST",
          body: r,
          duplex: "half"
        }), R;
        if (ye.isFormData(r) && (R = k.headers.get("content-type")) && d.setContentType(R), k.body) {
          const [A, M] = Z2(
            v,
            a0(Q2(l))
          );
          r = eI(k.body, tI, A, M);
        }
      }
      ye.isString(p) || (p = p ? "include" : "omit");
      const x = "credentials" in Request.prototype;
      y = new Request(t, {
        ...h,
        signal: g,
        method: n.toUpperCase(),
        headers: d.normalize().toJSON(),
        body: r,
        duplex: "half",
        credentials: x ? p : void 0
      });
      let E = await fetch(y, h);
      const _ = GE && (u === "stream" || u === "response");
      if (GE && (s || _ && b)) {
        const k = {};
        ["status", "statusText", "headers"].forEach((I) => {
          k[I] = E[I];
        });
        const R = ye.toFiniteNumber(E.headers.get("content-length")), [A, M] = s && Z2(
          R,
          a0(Q2(s), !0)
        ) || [];
        E = new Response(
          eI(E.body, tI, A, () => {
            M && M(), b && b();
          }),
          k
        );
      }
      u = u || "text";
      let C = await s0[ye.findKey(s0, u) || "text"](E, e);
      return !_ && b && b(), await new Promise((k, R) => {
        s9(k, R, {
          data: C,
          headers: Br.from(E.headers),
          status: E.status,
          statusText: E.statusText,
          config: e,
          request: y
        });
      });
    } catch (x) {
      throw b && b(), x && x.name === "TypeError" && /Load failed|fetch/i.test(x.message) ? Object.assign(
        new st("Network Error", st.ERR_NETWORK, e, y),
        {
          cause: x.cause || x
        }
      ) : st.from(x, x && x.code, e, y);
    }
  }), KE = {
    http: sfe,
    xhr: Dfe,
    fetch: Wfe
  };
  ye.forEach(KE, (e, t) => {
    if (e) {
      try {
        Object.defineProperty(e, "name", { value: t });
      } catch {
      }
      Object.defineProperty(e, "adapterName", { value: t });
    }
  });
  const nI = (e) => `- ${e}`, Gfe = (e) => ye.isFunction(e) || e === null || e === !1, d9 = {
    getAdapter: (e) => {
      e = ye.isArray(e) ? e : [e];
      const { length: t } = e;
      let n, r;
      const o = {};
      for (let i = 0; i < t; i++) {
        n = e[i];
        let a;
        if (r = n, !Gfe(n) && (r = KE[(a = String(n)).toLowerCase()], r === void 0))
          throw new st(`Unknown adapter '${a}'`);
        if (r)
          break;
        o[a || "#" + i] = r;
      }
      if (!r) {
        const i = Object.entries(o).map(
          ([s, l]) => `adapter ${s} ` + (l === !1 ? "is not supported by the environment" : "is not available in the build")
        );
        let a = t ? i.length > 1 ? `since :
` + i.map(nI).join(`
`) : " " + nI(i[0]) : "as no adapter specified";
        throw new st(
          "There is no suitable adapter to dispatch the request " + a,
          "ERR_NOT_SUPPORT"
        );
      }
      return r;
    },
    adapters: KE
  };
  function zS(e) {
    if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
      throw new Af(null, e);
  }
  function rI(e) {
    return zS(e), e.headers = Br.from(e.headers), e.data = LS.call(
      e,
      e.transformRequest
    ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), d9.getAdapter(e.adapter || Gh.adapter)(e).then(function(r) {
      return zS(e), r.data = LS.call(
        e,
        e.transformResponse,
        r
      ), r.headers = Br.from(r.headers), r;
    }, function(r) {
      return a9(r) || (zS(e), r && r.response && (r.response.data = LS.call(
        e,
        e.transformResponse,
        r.response
      ), r.response.headers = Br.from(r.response.headers))), Promise.reject(r);
    });
  }
  const p9 = "1.11.0", Pb = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
    Pb[e] = function(r) {
      return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
    };
  });
  const oI = {};
  Pb.transitional = function(t, n, r) {
    function o(i, a) {
      return "[Axios v" + p9 + "] Transitional option '" + i + "'" + a + (r ? ". " + r : "");
    }
    return (i, a, s) => {
      if (t === !1)
        throw new st(
          o(a, " has been removed" + (n ? " in " + n : "")),
          st.ERR_DEPRECATED
        );
      return n && !oI[a] && (oI[a] = !0, console.warn(
        o(
          a,
          " has been deprecated since v" + n + " and will be removed in the near future"
        )
      )), t ? t(i, a, s) : !0;
    };
  };
  Pb.spelling = function(t) {
    return (n, r) => (console.warn(`${r} is likely a misspelling of ${t}`), !0);
  };
  function Kfe(e, t, n) {
    if (typeof e != "object")
      throw new st("options must be an object", st.ERR_BAD_OPTION_VALUE);
    const r = Object.keys(e);
    let o = r.length;
    for (; o-- > 0; ) {
      const i = r[o], a = t[i];
      if (a) {
        const s = e[i], l = s === void 0 || a(s, i, e);
        if (l !== !0)
          throw new st("option " + i + " must be " + l, st.ERR_BAD_OPTION_VALUE);
        continue;
      }
      if (n !== !0)
        throw new st("Unknown option " + i, st.ERR_BAD_OPTION);
    }
  }
  const Sv = {
    assertOptions: Kfe,
    validators: Pb
  }, hi = Sv.validators;
  let Zl = class {
    constructor(t) {
      this.defaults = t || {}, this.interceptors = {
        request: new Y2(),
        response: new Y2()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    async request(t, n) {
      try {
        return await this._request(t, n);
      } catch (r) {
        if (r instanceof Error) {
          let o = {};
          Error.captureStackTrace ? Error.captureStackTrace(o) : o = new Error();
          const i = o.stack ? o.stack.replace(/^.+\n/, "") : "";
          try {
            r.stack ? i && !String(r.stack).endsWith(i.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + i) : r.stack = i;
          } catch {
          }
        }
        throw r;
      }
    }
    _request(t, n) {
      typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = sc(this.defaults, n);
      const { transitional: r, paramsSerializer: o, headers: i } = n;
      r !== void 0 && Sv.assertOptions(r, {
        silentJSONParsing: hi.transitional(hi.boolean),
        forcedJSONParsing: hi.transitional(hi.boolean),
        clarifyTimeoutError: hi.transitional(hi.boolean)
      }, !1), o != null && (ye.isFunction(o) ? n.paramsSerializer = {
        serialize: o
      } : Sv.assertOptions(o, {
        encode: hi.function,
        serialize: hi.function
      }, !0)), n.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? n.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : n.allowAbsoluteUrls = !0), Sv.assertOptions(n, {
        baseUrl: hi.spelling("baseURL"),
        withXsrfToken: hi.spelling("withXSRFToken")
      }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase();
      let a = i && ye.merge(
        i.common,
        i[n.method]
      );
      i && ye.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (y) => {
          delete i[y];
        }
      ), n.headers = Br.concat(a, i);
      const s = [];
      let l = !0;
      this.interceptors.request.forEach(function(b) {
        typeof b.runWhen == "function" && b.runWhen(n) === !1 || (l = l && b.synchronous, s.unshift(b.fulfilled, b.rejected));
      });
      const u = [];
      this.interceptors.response.forEach(function(b) {
        u.push(b.fulfilled, b.rejected);
      });
      let d, p = 0, h;
      if (!l) {
        const y = [rI.bind(this), void 0];
        for (y.unshift(...s), y.push(...u), h = y.length, d = Promise.resolve(n); p < h; )
          d = d.then(y[p++], y[p++]);
        return d;
      }
      h = s.length;
      let g = n;
      for (p = 0; p < h; ) {
        const y = s[p++], b = s[p++];
        try {
          g = y(g);
        } catch (v) {
          b.call(this, v);
          break;
        }
      }
      try {
        d = rI.call(this, g);
      } catch (y) {
        return Promise.reject(y);
      }
      for (p = 0, h = u.length; p < h; )
        d = d.then(u[p++], u[p++]);
      return d;
    }
    getUri(t) {
      t = sc(this.defaults, t);
      const n = l9(t.baseURL, t.url, t.allowAbsoluteUrls);
      return r9(n, t.params, t.paramsSerializer);
    }
  };
  ye.forEach(["delete", "get", "head", "options"], function(t) {
    Zl.prototype[t] = function(n, r) {
      return this.request(sc(r || {}, {
        method: t,
        url: n,
        data: (r || {}).data
      }));
    };
  });
  ye.forEach(["post", "put", "patch"], function(t) {
    function n(r) {
      return function(i, a, s) {
        return this.request(sc(s || {}, {
          method: t,
          headers: r ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url: i,
          data: a
        }));
      };
    }
    Zl.prototype[t] = n(), Zl.prototype[t + "Form"] = n(!0);
  });
  let Yfe = class h9 {
    constructor(t) {
      if (typeof t != "function")
        throw new TypeError("executor must be a function.");
      let n;
      this.promise = new Promise(function(i) {
        n = i;
      });
      const r = this;
      this.promise.then((o) => {
        if (!r._listeners) return;
        let i = r._listeners.length;
        for (; i-- > 0; )
          r._listeners[i](o);
        r._listeners = null;
      }), this.promise.then = (o) => {
        let i;
        const a = new Promise((s) => {
          r.subscribe(s), i = s;
        }).then(o);
        return a.cancel = function() {
          r.unsubscribe(i);
        }, a;
      }, t(function(i, a, s) {
        r.reason || (r.reason = new Af(i, a, s), n(r.reason));
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason)
        throw this.reason;
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(t) {
      if (this.reason) {
        t(this.reason);
        return;
      }
      this._listeners ? this._listeners.push(t) : this._listeners = [t];
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(t) {
      if (!this._listeners)
        return;
      const n = this._listeners.indexOf(t);
      n !== -1 && this._listeners.splice(n, 1);
    }
    toAbortSignal() {
      const t = new AbortController(), n = (r) => {
        t.abort(r);
      };
      return this.subscribe(n), t.signal.unsubscribe = () => this.unsubscribe(n), t.signal;
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let t;
      return {
        token: new h9(function(o) {
          t = o;
        }),
        cancel: t
      };
    }
  };
  function Xfe(e) {
    return function(n) {
      return e.apply(null, n);
    };
  }
  function Zfe(e) {
    return ye.isObject(e) && e.isAxiosError === !0;
  }
  const YE = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(YE).forEach(([e, t]) => {
    YE[t] = e;
  });
  function m9(e) {
    const t = new Zl(e), n = q6(Zl.prototype.request, t);
    return ye.extend(n, Zl.prototype, t, { allOwnKeys: !0 }), ye.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(o) {
      return m9(sc(e, o));
    }, n;
  }
  const Mn = m9(Gh);
  Mn.Axios = Zl;
  Mn.CanceledError = Af;
  Mn.CancelToken = Yfe;
  Mn.isCancel = a9;
  Mn.VERSION = p9;
  Mn.toFormData = Nb;
  Mn.AxiosError = st;
  Mn.Cancel = Mn.CanceledError;
  Mn.all = function(t) {
    return Promise.all(t);
  };
  Mn.spread = Xfe;
  Mn.isAxiosError = Zfe;
  Mn.mergeConfig = sc;
  Mn.AxiosHeaders = Br;
  Mn.formToJSON = (e) => i9(ye.isHTMLForm(e) ? new FormData(e) : e);
  Mn.getAdapter = d9.getAdapter;
  Mn.HttpStatusCode = YE;
  Mn.default = Mn;
  const {
    Axios: WLe,
    AxiosError: GLe,
    CanceledError: KLe,
    isCancel: YLe,
    CancelToken: XLe,
    VERSION: ZLe,
    all: QLe,
    Cancel: JLe,
    isAxiosError: eze,
    spread: tze,
    toFormData: nze,
    AxiosHeaders: rze,
    HttpStatusCode: oze,
    formToJSON: ize,
    getAdapter: aze,
    mergeConfig: sze
  } = Mn;
  class g9 extends wue {
    constructor(t) {
      super(t), this._websocket = null, this.reconnectAttempts = 0, this.maxReconnectAttempts = 999, this.initialTimeout = 200, this.maxTimeout = 5e3, this._reconnect = !0, this._reconnect_timeout = void 0, this._url = t.url, this._reconnect_timeout = setTimeout(() => {
        this.connect();
      }, 200), this._zustand && this._zustand.auto_progress();
    }
    connect() {
      this._zustand?.logger.info("Connecting to websocket"), this.is_open = !1, this._websocket = new WebSocket(this._url), this._websocket.onopen = () => {
        this.onopen();
      }, this._websocket.onclose = () => {
        this.onclose();
      }, this._websocket.onerror = () => {
        this.on_ws_error();
      }, this._websocket.onmessage = (t) => {
        typeof t.data == "string" ? this.onmessage(t.data) : t.data instanceof Blob && t.data.arrayBuffer().then((n) => {
          const r = new Uint8Array(n);
          this.getCommunicationManager().onbytes(r);
        });
      };
    }
    calculateReconnectTimeout() {
      return Math.min(
        this.initialTimeout * Math.pow(2, this.reconnectAttempts),
        this.maxTimeout
      );
    }
    auto_reconnect() {
      if (this.reconnectAttempts < this.maxReconnectAttempts) {
        let t = this.calculateReconnectTimeout();
        this._zustand?.logger.info(`Attempting to reconnect in ${t} ms`), this._reconnect_timeout = setTimeout(() => {
          this._websocket && this._websocket.readyState === WebSocket.OPEN || (this.reconnectAttempts++, this.connect());
        }, t);
      } else
        this._zustand?.logger.warn(
          "Maximum reconnect attempts reached. Giving up."
        );
    }
    async onmessage(t) {
      try {
        const n = JSON.parse(t);
        this._zustand?.logger.debug(
          `Recieved data of length: ${t.length} and data"`,
          n
        ), await this.getCommunicationManager().receive(n);
      } catch (n) {
        console.error("Websocketworker: onmessage JSON.parse error", n, t);
        return;
      }
    }
    get http_protocol() {
      return this.secure_url ? "https" : "http";
    }
    get secure_url() {
      return this._url.startsWith("wss");
    }
    get url_wo_protocol() {
      return this._url.substring(this.secure_url ? 6 : 5);
    }
    get http_url() {
      var t = this.http_protocol + "://" + this.url_wo_protocol;
      return t[t.length - 1] !== "/" && (t += "/"), t;
    }
    get_io_subscription_url({
      node_id: t,
      io_id: n,
      stream: r
    }) {
      let o = this.http_url + `node/${t}/io/${n}/value`;
      return r && (o += "/stream"), o;
    }
    async upload_file({
      files: t,
      onProgressCallback: n,
      root: r
    }) {
      const o = `${this.http_url}upload/`, i = new FormData(), a = Array.isArray(t) ? t : Array.from(t);
      for (const s of a) {
        const l = s.webkitRelativePath || s.name, u = r ? `${r}/${l}` : l;
        i.append("file", s, u);
      }
      try {
        return (await Mn.post(o, i, {
          headers: {
            "Content-Type": "multipart/form-data"
          },
          onUploadProgress: (l) => {
            n && n(l.loaded, l.total);
          }
        })).data.file;
      } catch {
        throw new Error("Failed to upload file");
      }
    }
    async handle_large_message_hint({ msg_id: t }) {
      const n = this.http_url + "message/" + t, o = await (await fetch(n, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*"
        }
      })).json();
      this.getCommunicationManager().receive(o);
    }
    onopen() {
      this._zustand?.logger.info("Websocket opened"), this.is_open = !0, this._zustand && this._zustand.auto_progress(), this.reconnectAttempts = 0, this.getSyncManager().stepwise_fullsync();
    }
    onclose() {
      this._zustand?.logger.info("Websocket closed"), super.onclose(), this._reconnect && (this._zustand?.logger.info("Websocket closed,reconnecting"), this.auto_reconnect());
    }
    on_ws_error() {
      this._zustand?.logger.warn("Websocket error"), this._websocket ? this._websocket.close() : this.auto_reconnect();
    }
    async send_large_message(t) {
      const n = `${this.http_url}message/`;
      await fetch(n, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: t
      });
    }
    async send(t) {
      if (!this._websocket || this._websocket.readyState !== WebSocket.OPEN) {
        this._zustand?.logger.warn("Websocket not connected");
        return;
      }
      const n = JSON.stringify(t);
      if (new Blob([n]).size > 1e6)
        return this._zustand?.logger.info("Data too large, sending via http"), await this.send_large_message(n);
      this._zustand?.logger.debug("Sending data", t), this._websocket.send(n);
    }
    async stop() {
      await super.stop(), this._reconnect = !1;
    }
    close() {
      this._websocket && this._websocket.close();
    }
    disconnect() {
      super.disconnect(), this._reconnect = !1, this._reconnect_timeout && (clearTimeout(this._reconnect_timeout), this._reconnect_timeout = void 0), this.close();
    }
    async reconnect() {
      if (await super.reconnect(), this._reconnect = !0, this._websocket && (this._zustand?.logger.info("Reconnecting"), (this._websocket.readyState === WebSocket.OPEN || this._websocket.readyState === WebSocket.CONNECTING) && (this._websocket.readyState === WebSocket.CONNECTING && await new Promise((t, n) => {
        if (this._websocket === null) return;
        let r = setTimeout(() => {
          n("Timeout@reconnect");
        }, 2e3);
        this._websocket.addEventListener(
          "open",
          () => {
            clearTimeout(r), t(null);
          },
          { once: !0 }
        ), this._websocket.readyState === WebSocket.OPEN && (clearTimeout(r), t(null));
      }), this._websocket.readyState === WebSocket.OPEN))) {
        this.getSyncManager().stepwise_fullsync();
        return;
      }
      this.connect();
    }
  }
  class Qfe {
    constructor(t, n) {
      this.ws = null, this.reconnectAttempts = 0, this.maxReconnectAttempts = 999, this.initialTimeout = 200, this.maxTimeout = 2e3, n.logger.debug("Initializing worker manager"), this._wsuri = t, this.zustand = n, this.workers = {}, this.on_setWorker = (r) => {
        this.zustand.set_worker(r);
      }, this.connectionTimeout = setTimeout(() => {
        this.connect();
      }, 200);
    }
    get wsuri() {
      return this._wsuri;
    }
    get open() {
      return this.ws?.readyState === WebSocket.OPEN;
    }
    connect() {
      this.zustand.set_progress({
        progress: 0,
        message: "connecting to worker manager",
        status: "info",
        blocking: !0
      }), this.zustand.logger.info("Connecting to websocket:", this._wsuri), this.ws = new WebSocket(this._wsuri), this.ws.onopen = () => {
        this.onopen();
      }, this.ws.onclose = () => {
        this.onclose();
      }, this.ws.onerror = () => {
        this.on_ws_error();
      }, this.ws.onmessage = (t) => {
        typeof t.data == "string" ? this.onmessage(t.data) : console.error(
          "WorkerManager: onmessage event.data is not a string",
          typeof t.data
        );
      }, this.connectionTimeout = setTimeout(() => {
        this.ws?.readyState !== WebSocket.OPEN && this.on_ws_error();
      }, 5e3);
    }
    on_ws_error() {
      console.warn("Websocket error"), this.ws ? this.ws.close() : this.reconnect();
    }
    onopen() {
      this.connectionTimeout && (clearTimeout(this.connectionTimeout), this.connectionTimeout = void 0), this.zustand.auto_progress(), this.ws && this.ws.send("worker_status");
    }
    onmessage(t) {
      try {
        let n = JSON.parse(t);
        if (n.type === "worker_status") {
          const r = {};
          for (let o of n.active)
            o.active = !0, r[o.uuid] = o;
          for (let o of n.inactive)
            o.active = !1, r[o.uuid] = o;
          if (this.zustand.workers.setState(r), !this.zustand.worker) {
            const o = window.localStorage.getItem(
              "funcnodes__active_worker"
            );
            o && r[o] && r[o].active && this.set_active(o);
          }
          return;
        } else if (n.type === "set_worker") {
          if (n.data.type === "WSWorker") {
            let r = "ws" + (n.data.ssl ? "s" : "") + "://" + n.data.host + ":" + n.data.port;
            this.setWorker(
              this.workers[n.data.uuid] || new g9({
                url: r,
                zustand: this.zustand,
                uuid: n.data.uuid,
                on_sync_complete: this.zustand.options.on_sync_complete
              })
            );
          } else
            this.zustand.logger.error("WorkerManager: unknown worker type", n);
          return;
        } else if (n.type === "progress") {
          this.zustand.set_progress(n);
          return;
        }
        this.zustand.logger.error("WorkerManager: unknown message", n);
      } catch (n) {
        console.error("WorkerManager: onmessage JSON.parse error", n, t);
        return;
      }
    }
    setWorker(t) {
      for (let n in this.workers)
        n !== t?.uuid && this.workers[n].disconnect();
      t !== void 0 && (this.workers[t.uuid] = t, t.reconnect()), t?.uuid && window.localStorage.setItem("funcnodes__active_worker", t?.uuid), this.zustand.worker !== void 0 && this.zustand.clear_all(), this.zustand.set_worker(t), this.on_setWorker(t);
    }
    async restart_worker(t) {
      this.ws?.send(JSON.stringify({ type: "restart_worker", workerid: t }));
    }
    calculateReconnectTimeout() {
      return Math.min(
        this.initialTimeout * Math.pow(2, this.reconnectAttempts),
        this.maxTimeout
      );
    }
    reconnect() {
      if (this.reconnectAttempts < this.maxReconnectAttempts) {
        let t = this.calculateReconnectTimeout();
        this.zustand.logger.info(`Attempting to reconnect in ${t} ms`), setTimeout(() => {
          this.ws && this.ws.readyState === WebSocket.OPEN || (this.reconnectAttempts++, this.connect());
        }, t);
      } else
        this.zustand.logger.warn(
          "Maximum reconnect attempts reached. Giving up."
        );
    }
    onclose() {
      this.zustand.logger.warn("WorkerManager: onclose"), this.reconnect();
    }
    set_active(t) {
      this.ws && this.ws.send(JSON.stringify({ type: "set_active", workerid: t }));
    }
    new_worker({
      name: t,
      reference: n,
      copyLib: r,
      copyNS: o,
      in_venv: i
    }) {
      t || (t = void 0), r || (r = !1), o || (o = !1), n || (n = void 0, r = !1, o = !1), this.ws && this.ws.send(
        JSON.stringify({
          type: "new_worker",
          kwargs: {
            name: t,
            reference: n,
            copyLib: r,
            copyNS: o,
            in_venv: i
          }
        })
      );
    }
    remove() {
      for (let t in this.workers)
        this.workers[t].disconnect();
      this.connectionTimeout && (clearTimeout(this.connectionTimeout), this.connectionTimeout = void 0), this.ws && (this.ws.onclose = () => {
      }, this.ws.onerror = () => {
      }, this.ws.onmessage = () => {
      }, this.ws.onopen = () => {
      }, this.ws.close());
    }
  }
  const Or = () => {
    const e = jt();
    return e.worker ? {
      ...e.worker.api,
      worker: e.worker
    } : {
      node: void 0,
      group: void 0,
      edge: void 0,
      hooks: void 0,
      lib: void 0,
      worker: e.worker
    };
  }, Jfe = {
    show: !0
  }, ede = {
    show: !0,
    showmenu: !0
  }, tde = {
    minimap: !0,
    static: !1,
    minZoom: 0.1,
    maxZoom: 5,
    allowFullScreen: !0,
    allowExpand: !0,
    showNodeSettings: !0
  }, nde = {
    id: "",
    // required
    debug: !1,
    useWorkerManager: !0,
    show_library: !0,
    header: ede,
    flow: tde,
    library: Jfe
  }, y9 = [
    "classic",
    "metal",
    "light",
    "solarized",
    "midnight",
    "forest",
    "scientific",
    "neon",
    "ocean",
    "sunset"
  ];
  function Vn(e) {
    if (typeof e == "string" || typeof e == "number") return "" + e;
    let t = "";
    if (Array.isArray(e))
      for (let n = 0, r; n < e.length; n++)
        (r = Vn(e[n])) !== "" && (t += (t && " ") + r);
    else
      for (let n in e)
        e[n] && (t += (t && " ") + n);
    return t;
  }
  var rde = { value: () => {
  } };
  function $b() {
    for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {
      if (!(r = arguments[e] + "") || r in n || /[\s.]/.test(r)) throw new Error("illegal type: " + r);
      n[r] = [];
    }
    return new _v(n);
  }
  function _v(e) {
    this._ = e;
  }
  function ode(e, t) {
    return e.trim().split(/^|\s+/).map(function(n) {
      var r = "", o = n.indexOf(".");
      if (o >= 0 && (r = n.slice(o + 1), n = n.slice(0, o)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
      return { type: n, name: r };
    });
  }
  _v.prototype = $b.prototype = {
    constructor: _v,
    on: function(e, t) {
      var n = this._, r = ode(e + "", n), o, i = -1, a = r.length;
      if (arguments.length < 2) {
        for (; ++i < a; ) if ((o = (e = r[i]).type) && (o = ide(n[o], e.name))) return o;
        return;
      }
      if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
      for (; ++i < a; )
        if (o = (e = r[i]).type) n[o] = iI(n[o], e.name, t);
        else if (t == null) for (o in n) n[o] = iI(n[o], e.name, null);
      return this;
    },
    copy: function() {
      var e = {}, t = this._;
      for (var n in t) e[n] = t[n].slice();
      return new _v(e);
    },
    call: function(e, t) {
      if ((o = arguments.length - 2) > 0) for (var n = new Array(o), r = 0, o, i; r < o; ++r) n[r] = arguments[r + 2];
      if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
      for (i = this._[e], r = 0, o = i.length; r < o; ++r) i[r].value.apply(t, n);
    },
    apply: function(e, t, n) {
      if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
      for (var r = this._[e], o = 0, i = r.length; o < i; ++o) r[o].value.apply(t, n);
    }
  };
  function ide(e, t) {
    for (var n = 0, r = e.length, o; n < r; ++n)
      if ((o = e[n]).name === t)
        return o.value;
  }
  function iI(e, t, n) {
    for (var r = 0, o = e.length; r < o; ++r)
      if (e[r].name === t) {
        e[r] = rde, e = e.slice(0, r).concat(e.slice(r + 1));
        break;
      }
    return n != null && e.push({ name: t, value: n }), e;
  }
  var XE = "http://www.w3.org/1999/xhtml";
  const aI = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: XE,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  function Ib(e) {
    var t = e += "", n = t.indexOf(":");
    return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), aI.hasOwnProperty(t) ? { space: aI[t], local: e } : e;
  }
  function ade(e) {
    return function() {
      var t = this.ownerDocument, n = this.namespaceURI;
      return n === XE && t.documentElement.namespaceURI === XE ? t.createElement(e) : t.createElementNS(n, e);
    };
  }
  function sde(e) {
    return function() {
      return this.ownerDocument.createElementNS(e.space, e.local);
    };
  }
  function v9(e) {
    var t = Ib(e);
    return (t.local ? sde : ade)(t);
  }
  function lde() {
  }
  function mT(e) {
    return e == null ? lde : function() {
      return this.querySelector(e);
    };
  }
  function cde(e) {
    typeof e != "function" && (e = mT(e));
    for (var t = this._groups, n = t.length, r = new Array(n), o = 0; o < n; ++o)
      for (var i = t[o], a = i.length, s = r[o] = new Array(a), l, u, d = 0; d < a; ++d)
        (l = i[d]) && (u = e.call(l, l.__data__, d, i)) && ("__data__" in l && (u.__data__ = l.__data__), s[d] = u);
    return new lo(r, this._parents);
  }
  function ude(e) {
    return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
  }
  function fde() {
    return [];
  }
  function b9(e) {
    return e == null ? fde : function() {
      return this.querySelectorAll(e);
    };
  }
  function dde(e) {
    return function() {
      return ude(e.apply(this, arguments));
    };
  }
  function pde(e) {
    typeof e == "function" ? e = dde(e) : e = b9(e);
    for (var t = this._groups, n = t.length, r = [], o = [], i = 0; i < n; ++i)
      for (var a = t[i], s = a.length, l, u = 0; u < s; ++u)
        (l = a[u]) && (r.push(e.call(l, l.__data__, u, a)), o.push(l));
    return new lo(r, o);
  }
  function x9(e) {
    return function() {
      return this.matches(e);
    };
  }
  function w9(e) {
    return function(t) {
      return t.matches(e);
    };
  }
  var hde = Array.prototype.find;
  function mde(e) {
    return function() {
      return hde.call(this.children, e);
    };
  }
  function gde() {
    return this.firstElementChild;
  }
  function yde(e) {
    return this.select(e == null ? gde : mde(typeof e == "function" ? e : w9(e)));
  }
  var vde = Array.prototype.filter;
  function bde() {
    return Array.from(this.children);
  }
  function xde(e) {
    return function() {
      return vde.call(this.children, e);
    };
  }
  function wde(e) {
    return this.selectAll(e == null ? bde : xde(typeof e == "function" ? e : w9(e)));
  }
  function Sde(e) {
    typeof e != "function" && (e = x9(e));
    for (var t = this._groups, n = t.length, r = new Array(n), o = 0; o < n; ++o)
      for (var i = t[o], a = i.length, s = r[o] = [], l, u = 0; u < a; ++u)
        (l = i[u]) && e.call(l, l.__data__, u, i) && s.push(l);
    return new lo(r, this._parents);
  }
  function S9(e) {
    return new Array(e.length);
  }
  function _de() {
    return new lo(this._enter || this._groups.map(S9), this._parents);
  }
  function l0(e, t) {
    this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
  }
  l0.prototype = {
    constructor: l0,
    appendChild: function(e) {
      return this._parent.insertBefore(e, this._next);
    },
    insertBefore: function(e, t) {
      return this._parent.insertBefore(e, t);
    },
    querySelector: function(e) {
      return this._parent.querySelector(e);
    },
    querySelectorAll: function(e) {
      return this._parent.querySelectorAll(e);
    }
  };
  function Ede(e) {
    return function() {
      return e;
    };
  }
  function Cde(e, t, n, r, o, i) {
    for (var a = 0, s, l = t.length, u = i.length; a < u; ++a)
      (s = t[a]) ? (s.__data__ = i[a], r[a] = s) : n[a] = new l0(e, i[a]);
    for (; a < l; ++a)
      (s = t[a]) && (o[a] = s);
  }
  function kde(e, t, n, r, o, i, a) {
    var s, l, u = /* @__PURE__ */ new Map(), d = t.length, p = i.length, h = new Array(d), g;
    for (s = 0; s < d; ++s)
      (l = t[s]) && (h[s] = g = a.call(l, l.__data__, s, t) + "", u.has(g) ? o[s] = l : u.set(g, l));
    for (s = 0; s < p; ++s)
      g = a.call(e, i[s], s, i) + "", (l = u.get(g)) ? (r[s] = l, l.__data__ = i[s], u.delete(g)) : n[s] = new l0(e, i[s]);
    for (s = 0; s < d; ++s)
      (l = t[s]) && u.get(h[s]) === l && (o[s] = l);
  }
  function Tde(e) {
    return e.__data__;
  }
  function Rde(e, t) {
    if (!arguments.length) return Array.from(this, Tde);
    var n = t ? kde : Cde, r = this._parents, o = this._groups;
    typeof e != "function" && (e = Ede(e));
    for (var i = o.length, a = new Array(i), s = new Array(i), l = new Array(i), u = 0; u < i; ++u) {
      var d = r[u], p = o[u], h = p.length, g = Ode(e.call(d, d && d.__data__, u, r)), y = g.length, b = s[u] = new Array(y), v = a[u] = new Array(y), x = l[u] = new Array(h);
      n(d, p, b, v, x, g, t);
      for (var E = 0, _ = 0, C, k; E < y; ++E)
        if (C = b[E]) {
          for (E >= _ && (_ = E + 1); !(k = v[_]) && ++_ < y; ) ;
          C._next = k || null;
        }
    }
    return a = new lo(a, r), a._enter = s, a._exit = l, a;
  }
  function Ode(e) {
    return typeof e == "object" && "length" in e ? e : Array.from(e);
  }
  function Ade() {
    return new lo(this._exit || this._groups.map(S9), this._parents);
  }
  function Nde(e, t, n) {
    var r = this.enter(), o = this, i = this.exit();
    return typeof e == "function" ? (r = e(r), r && (r = r.selection())) : r = r.append(e + ""), t != null && (o = t(o), o && (o = o.selection())), n == null ? i.remove() : n(i), r && o ? r.merge(o).order() : o;
  }
  function Mde(e) {
    for (var t = e.selection ? e.selection() : e, n = this._groups, r = t._groups, o = n.length, i = r.length, a = Math.min(o, i), s = new Array(o), l = 0; l < a; ++l)
      for (var u = n[l], d = r[l], p = u.length, h = s[l] = new Array(p), g, y = 0; y < p; ++y)
        (g = u[y] || d[y]) && (h[y] = g);
    for (; l < o; ++l)
      s[l] = n[l];
    return new lo(s, this._parents);
  }
  function Pde() {
    for (var e = this._groups, t = -1, n = e.length; ++t < n; )
      for (var r = e[t], o = r.length - 1, i = r[o], a; --o >= 0; )
        (a = r[o]) && (i && a.compareDocumentPosition(i) ^ 4 && i.parentNode.insertBefore(a, i), i = a);
    return this;
  }
  function $de(e) {
    e || (e = Ide);
    function t(p, h) {
      return p && h ? e(p.__data__, h.__data__) : !p - !h;
    }
    for (var n = this._groups, r = n.length, o = new Array(r), i = 0; i < r; ++i) {
      for (var a = n[i], s = a.length, l = o[i] = new Array(s), u, d = 0; d < s; ++d)
        (u = a[d]) && (l[d] = u);
      l.sort(t);
    }
    return new lo(o, this._parents).order();
  }
  function Ide(e, t) {
    return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
  }
  function jde() {
    var e = arguments[0];
    return arguments[0] = this, e.apply(null, arguments), this;
  }
  function Dde() {
    return Array.from(this);
  }
  function Fde() {
    for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
      for (var r = e[t], o = 0, i = r.length; o < i; ++o) {
        var a = r[o];
        if (a) return a;
      }
    return null;
  }
  function Lde() {
    let e = 0;
    for (const t of this) ++e;
    return e;
  }
  function zde() {
    return !this.node();
  }
  function Bde(e) {
    for (var t = this._groups, n = 0, r = t.length; n < r; ++n)
      for (var o = t[n], i = 0, a = o.length, s; i < a; ++i)
        (s = o[i]) && e.call(s, s.__data__, i, o);
    return this;
  }
  function Ude(e) {
    return function() {
      this.removeAttribute(e);
    };
  }
  function Vde(e) {
    return function() {
      this.removeAttributeNS(e.space, e.local);
    };
  }
  function Hde(e, t) {
    return function() {
      this.setAttribute(e, t);
    };
  }
  function qde(e, t) {
    return function() {
      this.setAttributeNS(e.space, e.local, t);
    };
  }
  function Wde(e, t) {
    return function() {
      var n = t.apply(this, arguments);
      n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
    };
  }
  function Gde(e, t) {
    return function() {
      var n = t.apply(this, arguments);
      n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
    };
  }
  function Kde(e, t) {
    var n = Ib(e);
    if (arguments.length < 2) {
      var r = this.node();
      return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);
    }
    return this.each((t == null ? n.local ? Vde : Ude : typeof t == "function" ? n.local ? Gde : Wde : n.local ? qde : Hde)(n, t));
  }
  function _9(e) {
    return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
  }
  function Yde(e) {
    return function() {
      this.style.removeProperty(e);
    };
  }
  function Xde(e, t, n) {
    return function() {
      this.style.setProperty(e, t, n);
    };
  }
  function Zde(e, t, n) {
    return function() {
      var r = t.apply(this, arguments);
      r == null ? this.style.removeProperty(e) : this.style.setProperty(e, r, n);
    };
  }
  function Qde(e, t, n) {
    return arguments.length > 1 ? this.each((t == null ? Yde : typeof t == "function" ? Zde : Xde)(e, t, n ?? "")) : sf(this.node(), e);
  }
  function sf(e, t) {
    return e.style.getPropertyValue(t) || _9(e).getComputedStyle(e, null).getPropertyValue(t);
  }
  function Jde(e) {
    return function() {
      delete this[e];
    };
  }
  function epe(e, t) {
    return function() {
      this[e] = t;
    };
  }
  function tpe(e, t) {
    return function() {
      var n = t.apply(this, arguments);
      n == null ? delete this[e] : this[e] = n;
    };
  }
  function npe(e, t) {
    return arguments.length > 1 ? this.each((t == null ? Jde : typeof t == "function" ? tpe : epe)(e, t)) : this.node()[e];
  }
  function E9(e) {
    return e.trim().split(/^|\s+/);
  }
  function gT(e) {
    return e.classList || new C9(e);
  }
  function C9(e) {
    this._node = e, this._names = E9(e.getAttribute("class") || "");
  }
  C9.prototype = {
    add: function(e) {
      var t = this._names.indexOf(e);
      t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
    },
    remove: function(e) {
      var t = this._names.indexOf(e);
      t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
    },
    contains: function(e) {
      return this._names.indexOf(e) >= 0;
    }
  };
  function k9(e, t) {
    for (var n = gT(e), r = -1, o = t.length; ++r < o; ) n.add(t[r]);
  }
  function T9(e, t) {
    for (var n = gT(e), r = -1, o = t.length; ++r < o; ) n.remove(t[r]);
  }
  function rpe(e) {
    return function() {
      k9(this, e);
    };
  }
  function ope(e) {
    return function() {
      T9(this, e);
    };
  }
  function ipe(e, t) {
    return function() {
      (t.apply(this, arguments) ? k9 : T9)(this, e);
    };
  }
  function ape(e, t) {
    var n = E9(e + "");
    if (arguments.length < 2) {
      for (var r = gT(this.node()), o = -1, i = n.length; ++o < i; ) if (!r.contains(n[o])) return !1;
      return !0;
    }
    return this.each((typeof t == "function" ? ipe : t ? rpe : ope)(n, t));
  }
  function spe() {
    this.textContent = "";
  }
  function lpe(e) {
    return function() {
      this.textContent = e;
    };
  }
  function cpe(e) {
    return function() {
      var t = e.apply(this, arguments);
      this.textContent = t ?? "";
    };
  }
  function upe(e) {
    return arguments.length ? this.each(e == null ? spe : (typeof e == "function" ? cpe : lpe)(e)) : this.node().textContent;
  }
  function fpe() {
    this.innerHTML = "";
  }
  function dpe(e) {
    return function() {
      this.innerHTML = e;
    };
  }
  function ppe(e) {
    return function() {
      var t = e.apply(this, arguments);
      this.innerHTML = t ?? "";
    };
  }
  function hpe(e) {
    return arguments.length ? this.each(e == null ? fpe : (typeof e == "function" ? ppe : dpe)(e)) : this.node().innerHTML;
  }
  function mpe() {
    this.nextSibling && this.parentNode.appendChild(this);
  }
  function gpe() {
    return this.each(mpe);
  }
  function ype() {
    this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }
  function vpe() {
    return this.each(ype);
  }
  function bpe(e) {
    var t = typeof e == "function" ? e : v9(e);
    return this.select(function() {
      return this.appendChild(t.apply(this, arguments));
    });
  }
  function xpe() {
    return null;
  }
  function wpe(e, t) {
    var n = typeof e == "function" ? e : v9(e), r = t == null ? xpe : typeof t == "function" ? t : mT(t);
    return this.select(function() {
      return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null);
    });
  }
  function Spe() {
    var e = this.parentNode;
    e && e.removeChild(this);
  }
  function _pe() {
    return this.each(Spe);
  }
  function Epe() {
    var e = this.cloneNode(!1), t = this.parentNode;
    return t ? t.insertBefore(e, this.nextSibling) : e;
  }
  function Cpe() {
    var e = this.cloneNode(!0), t = this.parentNode;
    return t ? t.insertBefore(e, this.nextSibling) : e;
  }
  function kpe(e) {
    return this.select(e ? Cpe : Epe);
  }
  function Tpe(e) {
    return arguments.length ? this.property("__data__", e) : this.node().__data__;
  }
  function Rpe(e) {
    return function(t) {
      e.call(this, t, this.__data__);
    };
  }
  function Ope(e) {
    return e.trim().split(/^|\s+/).map(function(t) {
      var n = "", r = t.indexOf(".");
      return r >= 0 && (n = t.slice(r + 1), t = t.slice(0, r)), { type: t, name: n };
    });
  }
  function Ape(e) {
    return function() {
      var t = this.__on;
      if (t) {
        for (var n = 0, r = -1, o = t.length, i; n < o; ++n)
          i = t[n], (!e.type || i.type === e.type) && i.name === e.name ? this.removeEventListener(i.type, i.listener, i.options) : t[++r] = i;
        ++r ? t.length = r : delete this.__on;
      }
    };
  }
  function Npe(e, t, n) {
    return function() {
      var r = this.__on, o, i = Rpe(t);
      if (r) {
        for (var a = 0, s = r.length; a < s; ++a)
          if ((o = r[a]).type === e.type && o.name === e.name) {
            this.removeEventListener(o.type, o.listener, o.options), this.addEventListener(o.type, o.listener = i, o.options = n), o.value = t;
            return;
          }
      }
      this.addEventListener(e.type, i, n), o = { type: e.type, name: e.name, value: t, listener: i, options: n }, r ? r.push(o) : this.__on = [o];
    };
  }
  function Mpe(e, t, n) {
    var r = Ope(e + ""), o, i = r.length, a;
    if (arguments.length < 2) {
      var s = this.node().__on;
      if (s) {
        for (var l = 0, u = s.length, d; l < u; ++l)
          for (o = 0, d = s[l]; o < i; ++o)
            if ((a = r[o]).type === d.type && a.name === d.name)
              return d.value;
      }
      return;
    }
    for (s = t ? Npe : Ape, o = 0; o < i; ++o) this.each(s(r[o], t, n));
    return this;
  }
  function R9(e, t, n) {
    var r = _9(e), o = r.CustomEvent;
    typeof o == "function" ? o = new o(t, n) : (o = r.document.createEvent("Event"), n ? (o.initEvent(t, n.bubbles, n.cancelable), o.detail = n.detail) : o.initEvent(t, !1, !1)), e.dispatchEvent(o);
  }
  function Ppe(e, t) {
    return function() {
      return R9(this, e, t);
    };
  }
  function $pe(e, t) {
    return function() {
      return R9(this, e, t.apply(this, arguments));
    };
  }
  function Ipe(e, t) {
    return this.each((typeof t == "function" ? $pe : Ppe)(e, t));
  }
  function* jpe() {
    for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
      for (var r = e[t], o = 0, i = r.length, a; o < i; ++o)
        (a = r[o]) && (yield a);
  }
  var O9 = [null];
  function lo(e, t) {
    this._groups = e, this._parents = t;
  }
  function Kh() {
    return new lo([[document.documentElement]], O9);
  }
  function Dpe() {
    return this;
  }
  lo.prototype = Kh.prototype = {
    constructor: lo,
    select: cde,
    selectAll: pde,
    selectChild: yde,
    selectChildren: wde,
    filter: Sde,
    data: Rde,
    enter: _de,
    exit: Ade,
    join: Nde,
    merge: Mde,
    selection: Dpe,
    order: Pde,
    sort: $de,
    call: jde,
    nodes: Dde,
    node: Fde,
    size: Lde,
    empty: zde,
    each: Bde,
    attr: Kde,
    style: Qde,
    property: npe,
    classed: ape,
    text: upe,
    html: hpe,
    raise: gpe,
    lower: vpe,
    append: bpe,
    insert: wpe,
    remove: _pe,
    clone: kpe,
    datum: Tpe,
    on: Mpe,
    dispatch: Ipe,
    [Symbol.iterator]: jpe
  };
  function no(e) {
    return typeof e == "string" ? new lo([[document.querySelector(e)]], [document.documentElement]) : new lo([[e]], O9);
  }
  function Fpe(e) {
    let t;
    for (; t = e.sourceEvent; ) e = t;
    return e;
  }
  function Bo(e, t) {
    if (e = Fpe(e), t === void 0 && (t = e.currentTarget), t) {
      var n = t.ownerSVGElement || t;
      if (n.createSVGPoint) {
        var r = n.createSVGPoint();
        return r.x = e.clientX, r.y = e.clientY, r = r.matrixTransform(t.getScreenCTM().inverse()), [r.x, r.y];
      }
      if (t.getBoundingClientRect) {
        var o = t.getBoundingClientRect();
        return [e.clientX - o.left - t.clientLeft, e.clientY - o.top - t.clientTop];
      }
    }
    return [e.pageX, e.pageY];
  }
  const Lpe = { passive: !1 }, eh = { capture: !0, passive: !1 };
  function BS(e) {
    e.stopImmediatePropagation();
  }
  function Xu(e) {
    e.preventDefault(), e.stopImmediatePropagation();
  }
  function A9(e) {
    var t = e.document.documentElement, n = no(e).on("dragstart.drag", Xu, eh);
    "onselectstart" in t ? n.on("selectstart.drag", Xu, eh) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
  }
  function N9(e, t) {
    var n = e.document.documentElement, r = no(e).on("dragstart.drag", null);
    t && (r.on("click.drag", Xu, eh), setTimeout(function() {
      r.on("click.drag", null);
    }, 0)), "onselectstart" in n ? r.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
  }
  const Jg = (e) => () => e;
  function ZE(e, {
    sourceEvent: t,
    subject: n,
    target: r,
    identifier: o,
    active: i,
    x: a,
    y: s,
    dx: l,
    dy: u,
    dispatch: d
  }) {
    Object.defineProperties(this, {
      type: { value: e, enumerable: !0, configurable: !0 },
      sourceEvent: { value: t, enumerable: !0, configurable: !0 },
      subject: { value: n, enumerable: !0, configurable: !0 },
      target: { value: r, enumerable: !0, configurable: !0 },
      identifier: { value: o, enumerable: !0, configurable: !0 },
      active: { value: i, enumerable: !0, configurable: !0 },
      x: { value: a, enumerable: !0, configurable: !0 },
      y: { value: s, enumerable: !0, configurable: !0 },
      dx: { value: l, enumerable: !0, configurable: !0 },
      dy: { value: u, enumerable: !0, configurable: !0 },
      _: { value: d }
    });
  }
  ZE.prototype.on = function() {
    var e = this._.on.apply(this._, arguments);
    return e === this._ ? this : e;
  };
  function zpe(e) {
    return !e.ctrlKey && !e.button;
  }
  function Bpe() {
    return this.parentNode;
  }
  function Upe(e, t) {
    return t ?? { x: e.x, y: e.y };
  }
  function Vpe() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function M9() {
    var e = zpe, t = Bpe, n = Upe, r = Vpe, o = {}, i = $b("start", "drag", "end"), a = 0, s, l, u, d, p = 0;
    function h(C) {
      C.on("mousedown.drag", g).filter(r).on("touchstart.drag", v).on("touchmove.drag", x, Lpe).on("touchend.drag touchcancel.drag", E).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    function g(C, k) {
      if (!(d || !e.call(this, C, k))) {
        var R = _(this, t.call(this, C, k), C, k, "mouse");
        R && (no(C.view).on("mousemove.drag", y, eh).on("mouseup.drag", b, eh), A9(C.view), BS(C), u = !1, s = C.clientX, l = C.clientY, R("start", C));
      }
    }
    function y(C) {
      if (Xu(C), !u) {
        var k = C.clientX - s, R = C.clientY - l;
        u = k * k + R * R > p;
      }
      o.mouse("drag", C);
    }
    function b(C) {
      no(C.view).on("mousemove.drag mouseup.drag", null), N9(C.view, u), Xu(C), o.mouse("end", C);
    }
    function v(C, k) {
      if (e.call(this, C, k)) {
        var R = C.changedTouches, A = t.call(this, C, k), M = R.length, I, D;
        for (I = 0; I < M; ++I)
          (D = _(this, A, C, k, R[I].identifier, R[I])) && (BS(C), D("start", C, R[I]));
      }
    }
    function x(C) {
      var k = C.changedTouches, R = k.length, A, M;
      for (A = 0; A < R; ++A)
        (M = o[k[A].identifier]) && (Xu(C), M("drag", C, k[A]));
    }
    function E(C) {
      var k = C.changedTouches, R = k.length, A, M;
      for (d && clearTimeout(d), d = setTimeout(function() {
        d = null;
      }, 500), A = 0; A < R; ++A)
        (M = o[k[A].identifier]) && (BS(C), M("end", C, k[A]));
    }
    function _(C, k, R, A, M, I) {
      var D = i.copy(), L = Bo(I || R, k), P, B, j;
      if ((j = n.call(C, new ZE("beforestart", {
        sourceEvent: R,
        target: h,
        identifier: M,
        active: a,
        x: L[0],
        y: L[1],
        dx: 0,
        dy: 0,
        dispatch: D
      }), A)) != null)
        return P = j.x - L[0] || 0, B = j.y - L[1] || 0, function V(F, G, W) {
          var K = L, $;
          switch (F) {
            case "start":
              o[M] = V, $ = a++;
              break;
            case "end":
              delete o[M], --a;
            // falls through
            case "drag":
              L = Bo(W || G, k), $ = a;
              break;
          }
          D.call(
            F,
            C,
            new ZE(F, {
              sourceEvent: G,
              subject: j,
              target: h,
              identifier: M,
              active: $,
              x: L[0] + P,
              y: L[1] + B,
              dx: L[0] - K[0],
              dy: L[1] - K[1],
              dispatch: D
            }),
            A
          );
        };
    }
    return h.filter = function(C) {
      return arguments.length ? (e = typeof C == "function" ? C : Jg(!!C), h) : e;
    }, h.container = function(C) {
      return arguments.length ? (t = typeof C == "function" ? C : Jg(C), h) : t;
    }, h.subject = function(C) {
      return arguments.length ? (n = typeof C == "function" ? C : Jg(C), h) : n;
    }, h.touchable = function(C) {
      return arguments.length ? (r = typeof C == "function" ? C : Jg(!!C), h) : r;
    }, h.on = function() {
      var C = i.on.apply(i, arguments);
      return C === i ? h : C;
    }, h.clickDistance = function(C) {
      return arguments.length ? (p = (C = +C) * C, h) : Math.sqrt(p);
    }, h;
  }
  function yT(e, t, n) {
    e.prototype = t.prototype = n, n.constructor = e;
  }
  function P9(e, t) {
    var n = Object.create(e.prototype);
    for (var r in t) n[r] = t[r];
    return n;
  }
  function Yh() {
  }
  var th = 0.7, c0 = 1 / th, Zu = "\\s*([+-]?\\d+)\\s*", nh = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Vi = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", Hpe = /^#([0-9a-f]{3,8})$/, qpe = new RegExp(`^rgb\\(${Zu},${Zu},${Zu}\\)$`), Wpe = new RegExp(`^rgb\\(${Vi},${Vi},${Vi}\\)$`), Gpe = new RegExp(`^rgba\\(${Zu},${Zu},${Zu},${nh}\\)$`), Kpe = new RegExp(`^rgba\\(${Vi},${Vi},${Vi},${nh}\\)$`), Ype = new RegExp(`^hsl\\(${nh},${Vi},${Vi}\\)$`), Xpe = new RegExp(`^hsla\\(${nh},${Vi},${Vi},${nh}\\)$`), sI = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  yT(Yh, lc, {
    copy(e) {
      return Object.assign(new this.constructor(), this, e);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: lI,
    // Deprecated! Use color.formatHex.
    formatHex: lI,
    formatHex8: Zpe,
    formatHsl: Qpe,
    formatRgb: cI,
    toString: cI
  });
  function lI() {
    return this.rgb().formatHex();
  }
  function Zpe() {
    return this.rgb().formatHex8();
  }
  function Qpe() {
    return $9(this).formatHsl();
  }
  function cI() {
    return this.rgb().formatRgb();
  }
  function lc(e) {
    var t, n;
    return e = (e + "").trim().toLowerCase(), (t = Hpe.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? uI(t) : n === 3 ? new Lr(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? ey(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? ey(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = qpe.exec(e)) ? new Lr(t[1], t[2], t[3], 1) : (t = Wpe.exec(e)) ? new Lr(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = Gpe.exec(e)) ? ey(t[1], t[2], t[3], t[4]) : (t = Kpe.exec(e)) ? ey(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = Ype.exec(e)) ? pI(t[1], t[2] / 100, t[3] / 100, 1) : (t = Xpe.exec(e)) ? pI(t[1], t[2] / 100, t[3] / 100, t[4]) : sI.hasOwnProperty(e) ? uI(sI[e]) : e === "transparent" ? new Lr(NaN, NaN, NaN, 0) : null;
  }
  function uI(e) {
    return new Lr(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
  }
  function ey(e, t, n, r) {
    return r <= 0 && (e = t = n = NaN), new Lr(e, t, n, r);
  }
  function Jpe(e) {
    return e instanceof Yh || (e = lc(e)), e ? (e = e.rgb(), new Lr(e.r, e.g, e.b, e.opacity)) : new Lr();
  }
  function QE(e, t, n, r) {
    return arguments.length === 1 ? Jpe(e) : new Lr(e, t, n, r ?? 1);
  }
  function Lr(e, t, n, r) {
    this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;
  }
  yT(Lr, QE, P9(Yh, {
    brighter(e) {
      return e = e == null ? c0 : Math.pow(c0, e), new Lr(this.r * e, this.g * e, this.b * e, this.opacity);
    },
    darker(e) {
      return e = e == null ? th : Math.pow(th, e), new Lr(this.r * e, this.g * e, this.b * e, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Lr(Ql(this.r), Ql(this.g), Ql(this.b), u0(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
    },
    hex: fI,
    // Deprecated! Use color.formatHex.
    formatHex: fI,
    formatHex8: ehe,
    formatRgb: dI,
    toString: dI
  }));
  function fI() {
    return `#${Xl(this.r)}${Xl(this.g)}${Xl(this.b)}`;
  }
  function ehe() {
    return `#${Xl(this.r)}${Xl(this.g)}${Xl(this.b)}${Xl((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function dI() {
    const e = u0(this.opacity);
    return `${e === 1 ? "rgb(" : "rgba("}${Ql(this.r)}, ${Ql(this.g)}, ${Ql(this.b)}${e === 1 ? ")" : `, ${e})`}`;
  }
  function u0(e) {
    return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
  }
  function Ql(e) {
    return Math.max(0, Math.min(255, Math.round(e) || 0));
  }
  function Xl(e) {
    return e = Ql(e), (e < 16 ? "0" : "") + e.toString(16);
  }
  function pI(e, t, n, r) {
    return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new Uo(e, t, n, r);
  }
  function $9(e) {
    if (e instanceof Uo) return new Uo(e.h, e.s, e.l, e.opacity);
    if (e instanceof Yh || (e = lc(e)), !e) return new Uo();
    if (e instanceof Uo) return e;
    e = e.rgb();
    var t = e.r / 255, n = e.g / 255, r = e.b / 255, o = Math.min(t, n, r), i = Math.max(t, n, r), a = NaN, s = i - o, l = (i + o) / 2;
    return s ? (t === i ? a = (n - r) / s + (n < r) * 6 : n === i ? a = (r - t) / s + 2 : a = (t - n) / s + 4, s /= l < 0.5 ? i + o : 2 - i - o, a *= 60) : s = l > 0 && l < 1 ? 0 : a, new Uo(a, s, l, e.opacity);
  }
  function the(e, t, n, r) {
    return arguments.length === 1 ? $9(e) : new Uo(e, t, n, r ?? 1);
  }
  function Uo(e, t, n, r) {
    this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
  }
  yT(Uo, the, P9(Yh, {
    brighter(e) {
      return e = e == null ? c0 : Math.pow(c0, e), new Uo(this.h, this.s, this.l * e, this.opacity);
    },
    darker(e) {
      return e = e == null ? th : Math.pow(th, e), new Uo(this.h, this.s, this.l * e, this.opacity);
    },
    rgb() {
      var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * t, o = 2 * n - r;
      return new Lr(
        US(e >= 240 ? e - 240 : e + 120, o, r),
        US(e, o, r),
        US(e < 120 ? e + 240 : e - 120, o, r),
        this.opacity
      );
    },
    clamp() {
      return new Uo(hI(this.h), ty(this.s), ty(this.l), u0(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
    },
    formatHsl() {
      const e = u0(this.opacity);
      return `${e === 1 ? "hsl(" : "hsla("}${hI(this.h)}, ${ty(this.s) * 100}%, ${ty(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
    }
  }));
  function hI(e) {
    return e = (e || 0) % 360, e < 0 ? e + 360 : e;
  }
  function ty(e) {
    return Math.max(0, Math.min(1, e || 0));
  }
  function US(e, t, n) {
    return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
  }
  const vT = (e) => () => e;
  function nhe(e, t) {
    return function(n) {
      return e + n * t;
    };
  }
  function rhe(e, t, n) {
    return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(r) {
      return Math.pow(e + r * t, n);
    };
  }
  function ohe(e) {
    return (e = +e) == 1 ? I9 : function(t, n) {
      return n - t ? rhe(t, n, e) : vT(isNaN(t) ? n : t);
    };
  }
  function I9(e, t) {
    var n = t - e;
    return n ? nhe(e, n) : vT(isNaN(e) ? t : e);
  }
  const f0 = function e(t) {
    var n = ohe(t);
    function r(o, i) {
      var a = n((o = QE(o)).r, (i = QE(i)).r), s = n(o.g, i.g), l = n(o.b, i.b), u = I9(o.opacity, i.opacity);
      return function(d) {
        return o.r = a(d), o.g = s(d), o.b = l(d), o.opacity = u(d), o + "";
      };
    }
    return r.gamma = e, r;
  }(1);
  function ihe(e, t) {
    t || (t = []);
    var n = e ? Math.min(t.length, e.length) : 0, r = t.slice(), o;
    return function(i) {
      for (o = 0; o < n; ++o) r[o] = e[o] * (1 - i) + t[o] * i;
      return r;
    };
  }
  function ahe(e) {
    return ArrayBuffer.isView(e) && !(e instanceof DataView);
  }
  function she(e, t) {
    var n = t ? t.length : 0, r = e ? Math.min(n, e.length) : 0, o = new Array(r), i = new Array(n), a;
    for (a = 0; a < r; ++a) o[a] = Rp(e[a], t[a]);
    for (; a < n; ++a) i[a] = t[a];
    return function(s) {
      for (a = 0; a < r; ++a) i[a] = o[a](s);
      return i;
    };
  }
  function lhe(e, t) {
    var n = /* @__PURE__ */ new Date();
    return e = +e, t = +t, function(r) {
      return n.setTime(e * (1 - r) + t * r), n;
    };
  }
  function Ei(e, t) {
    return e = +e, t = +t, function(n) {
      return e * (1 - n) + t * n;
    };
  }
  function che(e, t) {
    var n = {}, r = {}, o;
    (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
    for (o in t)
      o in e ? n[o] = Rp(e[o], t[o]) : r[o] = t[o];
    return function(i) {
      for (o in n) r[o] = n[o](i);
      return r;
    };
  }
  var JE = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, VS = new RegExp(JE.source, "g");
  function uhe(e) {
    return function() {
      return e;
    };
  }
  function fhe(e) {
    return function(t) {
      return e(t) + "";
    };
  }
  function j9(e, t) {
    var n = JE.lastIndex = VS.lastIndex = 0, r, o, i, a = -1, s = [], l = [];
    for (e = e + "", t = t + ""; (r = JE.exec(e)) && (o = VS.exec(t)); )
      (i = o.index) > n && (i = t.slice(n, i), s[a] ? s[a] += i : s[++a] = i), (r = r[0]) === (o = o[0]) ? s[a] ? s[a] += o : s[++a] = o : (s[++a] = null, l.push({ i: a, x: Ei(r, o) })), n = VS.lastIndex;
    return n < t.length && (i = t.slice(n), s[a] ? s[a] += i : s[++a] = i), s.length < 2 ? l[0] ? fhe(l[0].x) : uhe(t) : (t = l.length, function(u) {
      for (var d = 0, p; d < t; ++d) s[(p = l[d]).i] = p.x(u);
      return s.join("");
    });
  }
  function Rp(e, t) {
    var n = typeof t, r;
    return t == null || n === "boolean" ? vT(t) : (n === "number" ? Ei : n === "string" ? (r = lc(t)) ? (t = r, f0) : j9 : t instanceof lc ? f0 : t instanceof Date ? lhe : ahe(t) ? ihe : Array.isArray(t) ? she : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? che : Ei)(e, t);
  }
  var mI = 180 / Math.PI, eC = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
  };
  function D9(e, t, n, r, o, i) {
    var a, s, l;
    return (a = Math.sqrt(e * e + t * t)) && (e /= a, t /= a), (l = e * n + t * r) && (n -= e * l, r -= t * l), (s = Math.sqrt(n * n + r * r)) && (n /= s, r /= s, l /= s), e * r < t * n && (e = -e, t = -t, l = -l, a = -a), {
      translateX: o,
      translateY: i,
      rotate: Math.atan2(t, e) * mI,
      skewX: Math.atan(l) * mI,
      scaleX: a,
      scaleY: s
    };
  }
  var ny;
  function dhe(e) {
    const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
    return t.isIdentity ? eC : D9(t.a, t.b, t.c, t.d, t.e, t.f);
  }
  function phe(e) {
    return e == null || (ny || (ny = document.createElementNS("http://www.w3.org/2000/svg", "g")), ny.setAttribute("transform", e), !(e = ny.transform.baseVal.consolidate())) ? eC : (e = e.matrix, D9(e.a, e.b, e.c, e.d, e.e, e.f));
  }
  function F9(e, t, n, r) {
    function o(u) {
      return u.length ? u.pop() + " " : "";
    }
    function i(u, d, p, h, g, y) {
      if (u !== p || d !== h) {
        var b = g.push("translate(", null, t, null, n);
        y.push({ i: b - 4, x: Ei(u, p) }, { i: b - 2, x: Ei(d, h) });
      } else (p || h) && g.push("translate(" + p + t + h + n);
    }
    function a(u, d, p, h) {
      u !== d ? (u - d > 180 ? d += 360 : d - u > 180 && (u += 360), h.push({ i: p.push(o(p) + "rotate(", null, r) - 2, x: Ei(u, d) })) : d && p.push(o(p) + "rotate(" + d + r);
    }
    function s(u, d, p, h) {
      u !== d ? h.push({ i: p.push(o(p) + "skewX(", null, r) - 2, x: Ei(u, d) }) : d && p.push(o(p) + "skewX(" + d + r);
    }
    function l(u, d, p, h, g, y) {
      if (u !== p || d !== h) {
        var b = g.push(o(g) + "scale(", null, ",", null, ")");
        y.push({ i: b - 4, x: Ei(u, p) }, { i: b - 2, x: Ei(d, h) });
      } else (p !== 1 || h !== 1) && g.push(o(g) + "scale(" + p + "," + h + ")");
    }
    return function(u, d) {
      var p = [], h = [];
      return u = e(u), d = e(d), i(u.translateX, u.translateY, d.translateX, d.translateY, p, h), a(u.rotate, d.rotate, p, h), s(u.skewX, d.skewX, p, h), l(u.scaleX, u.scaleY, d.scaleX, d.scaleY, p, h), u = d = null, function(g) {
        for (var y = -1, b = h.length, v; ++y < b; ) p[(v = h[y]).i] = v.x(g);
        return p.join("");
      };
    };
  }
  var hhe = F9(dhe, "px, ", "px)", "deg)"), mhe = F9(phe, ", ", ")", ")"), ghe = 1e-12;
  function gI(e) {
    return ((e = Math.exp(e)) + 1 / e) / 2;
  }
  function yhe(e) {
    return ((e = Math.exp(e)) - 1 / e) / 2;
  }
  function vhe(e) {
    return ((e = Math.exp(2 * e)) - 1) / (e + 1);
  }
  const Ev = function e(t, n, r) {
    function o(i, a) {
      var s = i[0], l = i[1], u = i[2], d = a[0], p = a[1], h = a[2], g = d - s, y = p - l, b = g * g + y * y, v, x;
      if (b < ghe)
        x = Math.log(h / u) / t, v = function(A) {
          return [
            s + A * g,
            l + A * y,
            u * Math.exp(t * A * x)
          ];
        };
      else {
        var E = Math.sqrt(b), _ = (h * h - u * u + r * b) / (2 * u * n * E), C = (h * h - u * u - r * b) / (2 * h * n * E), k = Math.log(Math.sqrt(_ * _ + 1) - _), R = Math.log(Math.sqrt(C * C + 1) - C);
        x = (R - k) / t, v = function(A) {
          var M = A * x, I = gI(k), D = u / (n * E) * (I * vhe(t * M + k) - yhe(k));
          return [
            s + D * g,
            l + D * y,
            u * I / gI(t * M + k)
          ];
        };
      }
      return v.duration = x * 1e3 * t / Math.SQRT2, v;
    }
    return o.rho = function(i) {
      var a = Math.max(1e-3, +i), s = a * a, l = s * s;
      return e(a, s, l);
    }, o;
  }(Math.SQRT2, 2, 4);
  var lf = 0, gp = 0, Gd = 0, L9 = 1e3, d0, yp, p0 = 0, cc = 0, jb = 0, rh = typeof performance == "object" && performance.now ? performance : Date, z9 = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
    setTimeout(e, 17);
  };
  function bT() {
    return cc || (z9(bhe), cc = rh.now() + jb);
  }
  function bhe() {
    cc = 0;
  }
  function h0() {
    this._call = this._time = this._next = null;
  }
  h0.prototype = B9.prototype = {
    constructor: h0,
    restart: function(e, t, n) {
      if (typeof e != "function") throw new TypeError("callback is not a function");
      n = (n == null ? bT() : +n) + (t == null ? 0 : +t), !this._next && yp !== this && (yp ? yp._next = this : d0 = this, yp = this), this._call = e, this._time = n, tC();
    },
    stop: function() {
      this._call && (this._call = null, this._time = 1 / 0, tC());
    }
  };
  function B9(e, t, n) {
    var r = new h0();
    return r.restart(e, t, n), r;
  }
  function xhe() {
    bT(), ++lf;
    for (var e = d0, t; e; )
      (t = cc - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
    --lf;
  }
  function yI() {
    cc = (p0 = rh.now()) + jb, lf = gp = 0;
    try {
      xhe();
    } finally {
      lf = 0, She(), cc = 0;
    }
  }
  function whe() {
    var e = rh.now(), t = e - p0;
    t > L9 && (jb -= t, p0 = e);
  }
  function She() {
    for (var e, t = d0, n, r = 1 / 0; t; )
      t._call ? (r > t._time && (r = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : d0 = n);
    yp = e, tC(r);
  }
  function tC(e) {
    if (!lf) {
      gp && (gp = clearTimeout(gp));
      var t = e - cc;
      t > 24 ? (e < 1 / 0 && (gp = setTimeout(yI, e - rh.now() - jb)), Gd && (Gd = clearInterval(Gd))) : (Gd || (p0 = rh.now(), Gd = setInterval(whe, L9)), lf = 1, z9(yI));
    }
  }
  function vI(e, t, n) {
    var r = new h0();
    return t = t == null ? 0 : +t, r.restart((o) => {
      r.stop(), e(o + t);
    }, t, n), r;
  }
  var _he = $b("start", "end", "cancel", "interrupt"), Ehe = [], U9 = 0, bI = 1, nC = 2, Cv = 3, xI = 4, rC = 5, kv = 6;
  function Db(e, t, n, r, o, i) {
    var a = e.__transition;
    if (!a) e.__transition = {};
    else if (n in a) return;
    Che(e, n, {
      name: t,
      index: r,
      // For context during callback.
      group: o,
      // For context during callback.
      on: _he,
      tween: Ehe,
      time: i.time,
      delay: i.delay,
      duration: i.duration,
      ease: i.ease,
      timer: null,
      state: U9
    });
  }
  function xT(e, t) {
    var n = ri(e, t);
    if (n.state > U9) throw new Error("too late; already scheduled");
    return n;
  }
  function Zi(e, t) {
    var n = ri(e, t);
    if (n.state > Cv) throw new Error("too late; already running");
    return n;
  }
  function ri(e, t) {
    var n = e.__transition;
    if (!n || !(n = n[t])) throw new Error("transition not found");
    return n;
  }
  function Che(e, t, n) {
    var r = e.__transition, o;
    r[t] = n, n.timer = B9(i, 0, n.time);
    function i(u) {
      n.state = bI, n.timer.restart(a, n.delay, n.time), n.delay <= u && a(u - n.delay);
    }
    function a(u) {
      var d, p, h, g;
      if (n.state !== bI) return l();
      for (d in r)
        if (g = r[d], g.name === n.name) {
          if (g.state === Cv) return vI(a);
          g.state === xI ? (g.state = kv, g.timer.stop(), g.on.call("interrupt", e, e.__data__, g.index, g.group), delete r[d]) : +d < t && (g.state = kv, g.timer.stop(), g.on.call("cancel", e, e.__data__, g.index, g.group), delete r[d]);
        }
      if (vI(function() {
        n.state === Cv && (n.state = xI, n.timer.restart(s, n.delay, n.time), s(u));
      }), n.state = nC, n.on.call("start", e, e.__data__, n.index, n.group), n.state === nC) {
        for (n.state = Cv, o = new Array(h = n.tween.length), d = 0, p = -1; d < h; ++d)
          (g = n.tween[d].value.call(e, e.__data__, n.index, n.group)) && (o[++p] = g);
        o.length = p + 1;
      }
    }
    function s(u) {
      for (var d = u < n.duration ? n.ease.call(null, u / n.duration) : (n.timer.restart(l), n.state = rC, 1), p = -1, h = o.length; ++p < h; )
        o[p].call(e, d);
      n.state === rC && (n.on.call("end", e, e.__data__, n.index, n.group), l());
    }
    function l() {
      n.state = kv, n.timer.stop(), delete r[t];
      for (var u in r) return;
      delete e.__transition;
    }
  }
  function Tv(e, t) {
    var n = e.__transition, r, o, i = !0, a;
    if (n) {
      t = t == null ? null : t + "";
      for (a in n) {
        if ((r = n[a]).name !== t) {
          i = !1;
          continue;
        }
        o = r.state > nC && r.state < rC, r.state = kv, r.timer.stop(), r.on.call(o ? "interrupt" : "cancel", e, e.__data__, r.index, r.group), delete n[a];
      }
      i && delete e.__transition;
    }
  }
  function khe(e) {
    return this.each(function() {
      Tv(this, e);
    });
  }
  function The(e, t) {
    var n, r;
    return function() {
      var o = Zi(this, e), i = o.tween;
      if (i !== n) {
        r = n = i;
        for (var a = 0, s = r.length; a < s; ++a)
          if (r[a].name === t) {
            r = r.slice(), r.splice(a, 1);
            break;
          }
      }
      o.tween = r;
    };
  }
  function Rhe(e, t, n) {
    var r, o;
    if (typeof n != "function") throw new Error();
    return function() {
      var i = Zi(this, e), a = i.tween;
      if (a !== r) {
        o = (r = a).slice();
        for (var s = { name: t, value: n }, l = 0, u = o.length; l < u; ++l)
          if (o[l].name === t) {
            o[l] = s;
            break;
          }
        l === u && o.push(s);
      }
      i.tween = o;
    };
  }
  function Ohe(e, t) {
    var n = this._id;
    if (e += "", arguments.length < 2) {
      for (var r = ri(this.node(), n).tween, o = 0, i = r.length, a; o < i; ++o)
        if ((a = r[o]).name === e)
          return a.value;
      return null;
    }
    return this.each((t == null ? The : Rhe)(n, e, t));
  }
  function wT(e, t, n) {
    var r = e._id;
    return e.each(function() {
      var o = Zi(this, r);
      (o.value || (o.value = {}))[t] = n.apply(this, arguments);
    }), function(o) {
      return ri(o, r).value[t];
    };
  }
  function V9(e, t) {
    var n;
    return (typeof t == "number" ? Ei : t instanceof lc ? f0 : (n = lc(t)) ? (t = n, f0) : j9)(e, t);
  }
  function Ahe(e) {
    return function() {
      this.removeAttribute(e);
    };
  }
  function Nhe(e) {
    return function() {
      this.removeAttributeNS(e.space, e.local);
    };
  }
  function Mhe(e, t, n) {
    var r, o = n + "", i;
    return function() {
      var a = this.getAttribute(e);
      return a === o ? null : a === r ? i : i = t(r = a, n);
    };
  }
  function Phe(e, t, n) {
    var r, o = n + "", i;
    return function() {
      var a = this.getAttributeNS(e.space, e.local);
      return a === o ? null : a === r ? i : i = t(r = a, n);
    };
  }
  function $he(e, t, n) {
    var r, o, i;
    return function() {
      var a, s = n(this), l;
      return s == null ? void this.removeAttribute(e) : (a = this.getAttribute(e), l = s + "", a === l ? null : a === r && l === o ? i : (o = l, i = t(r = a, s)));
    };
  }
  function Ihe(e, t, n) {
    var r, o, i;
    return function() {
      var a, s = n(this), l;
      return s == null ? void this.removeAttributeNS(e.space, e.local) : (a = this.getAttributeNS(e.space, e.local), l = s + "", a === l ? null : a === r && l === o ? i : (o = l, i = t(r = a, s)));
    };
  }
  function jhe(e, t) {
    var n = Ib(e), r = n === "transform" ? mhe : V9;
    return this.attrTween(e, typeof t == "function" ? (n.local ? Ihe : $he)(n, r, wT(this, "attr." + e, t)) : t == null ? (n.local ? Nhe : Ahe)(n) : (n.local ? Phe : Mhe)(n, r, t));
  }
  function Dhe(e, t) {
    return function(n) {
      this.setAttribute(e, t.call(this, n));
    };
  }
  function Fhe(e, t) {
    return function(n) {
      this.setAttributeNS(e.space, e.local, t.call(this, n));
    };
  }
  function Lhe(e, t) {
    var n, r;
    function o() {
      var i = t.apply(this, arguments);
      return i !== r && (n = (r = i) && Fhe(e, i)), n;
    }
    return o._value = t, o;
  }
  function zhe(e, t) {
    var n, r;
    function o() {
      var i = t.apply(this, arguments);
      return i !== r && (n = (r = i) && Dhe(e, i)), n;
    }
    return o._value = t, o;
  }
  function Bhe(e, t) {
    var n = "attr." + e;
    if (arguments.length < 2) return (n = this.tween(n)) && n._value;
    if (t == null) return this.tween(n, null);
    if (typeof t != "function") throw new Error();
    var r = Ib(e);
    return this.tween(n, (r.local ? Lhe : zhe)(r, t));
  }
  function Uhe(e, t) {
    return function() {
      xT(this, e).delay = +t.apply(this, arguments);
    };
  }
  function Vhe(e, t) {
    return t = +t, function() {
      xT(this, e).delay = t;
    };
  }
  function Hhe(e) {
    var t = this._id;
    return arguments.length ? this.each((typeof e == "function" ? Uhe : Vhe)(t, e)) : ri(this.node(), t).delay;
  }
  function qhe(e, t) {
    return function() {
      Zi(this, e).duration = +t.apply(this, arguments);
    };
  }
  function Whe(e, t) {
    return t = +t, function() {
      Zi(this, e).duration = t;
    };
  }
  function Ghe(e) {
    var t = this._id;
    return arguments.length ? this.each((typeof e == "function" ? qhe : Whe)(t, e)) : ri(this.node(), t).duration;
  }
  function Khe(e, t) {
    if (typeof t != "function") throw new Error();
    return function() {
      Zi(this, e).ease = t;
    };
  }
  function Yhe(e) {
    var t = this._id;
    return arguments.length ? this.each(Khe(t, e)) : ri(this.node(), t).ease;
  }
  function Xhe(e, t) {
    return function() {
      var n = t.apply(this, arguments);
      if (typeof n != "function") throw new Error();
      Zi(this, e).ease = n;
    };
  }
  function Zhe(e) {
    if (typeof e != "function") throw new Error();
    return this.each(Xhe(this._id, e));
  }
  function Qhe(e) {
    typeof e != "function" && (e = x9(e));
    for (var t = this._groups, n = t.length, r = new Array(n), o = 0; o < n; ++o)
      for (var i = t[o], a = i.length, s = r[o] = [], l, u = 0; u < a; ++u)
        (l = i[u]) && e.call(l, l.__data__, u, i) && s.push(l);
    return new Va(r, this._parents, this._name, this._id);
  }
  function Jhe(e) {
    if (e._id !== this._id) throw new Error();
    for (var t = this._groups, n = e._groups, r = t.length, o = n.length, i = Math.min(r, o), a = new Array(r), s = 0; s < i; ++s)
      for (var l = t[s], u = n[s], d = l.length, p = a[s] = new Array(d), h, g = 0; g < d; ++g)
        (h = l[g] || u[g]) && (p[g] = h);
    for (; s < r; ++s)
      a[s] = t[s];
    return new Va(a, this._parents, this._name, this._id);
  }
  function eme(e) {
    return (e + "").trim().split(/^|\s+/).every(function(t) {
      var n = t.indexOf(".");
      return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
    });
  }
  function tme(e, t, n) {
    var r, o, i = eme(t) ? xT : Zi;
    return function() {
      var a = i(this, e), s = a.on;
      s !== r && (o = (r = s).copy()).on(t, n), a.on = o;
    };
  }
  function nme(e, t) {
    var n = this._id;
    return arguments.length < 2 ? ri(this.node(), n).on.on(e) : this.each(tme(n, e, t));
  }
  function rme(e) {
    return function() {
      var t = this.parentNode;
      for (var n in this.__transition) if (+n !== e) return;
      t && t.removeChild(this);
    };
  }
  function ome() {
    return this.on("end.remove", rme(this._id));
  }
  function ime(e) {
    var t = this._name, n = this._id;
    typeof e != "function" && (e = mT(e));
    for (var r = this._groups, o = r.length, i = new Array(o), a = 0; a < o; ++a)
      for (var s = r[a], l = s.length, u = i[a] = new Array(l), d, p, h = 0; h < l; ++h)
        (d = s[h]) && (p = e.call(d, d.__data__, h, s)) && ("__data__" in d && (p.__data__ = d.__data__), u[h] = p, Db(u[h], t, n, h, u, ri(d, n)));
    return new Va(i, this._parents, t, n);
  }
  function ame(e) {
    var t = this._name, n = this._id;
    typeof e != "function" && (e = b9(e));
    for (var r = this._groups, o = r.length, i = [], a = [], s = 0; s < o; ++s)
      for (var l = r[s], u = l.length, d, p = 0; p < u; ++p)
        if (d = l[p]) {
          for (var h = e.call(d, d.__data__, p, l), g, y = ri(d, n), b = 0, v = h.length; b < v; ++b)
            (g = h[b]) && Db(g, t, n, b, h, y);
          i.push(h), a.push(d);
        }
    return new Va(i, a, t, n);
  }
  var sme = Kh.prototype.constructor;
  function lme() {
    return new sme(this._groups, this._parents);
  }
  function cme(e, t) {
    var n, r, o;
    return function() {
      var i = sf(this, e), a = (this.style.removeProperty(e), sf(this, e));
      return i === a ? null : i === n && a === r ? o : o = t(n = i, r = a);
    };
  }
  function H9(e) {
    return function() {
      this.style.removeProperty(e);
    };
  }
  function ume(e, t, n) {
    var r, o = n + "", i;
    return function() {
      var a = sf(this, e);
      return a === o ? null : a === r ? i : i = t(r = a, n);
    };
  }
  function fme(e, t, n) {
    var r, o, i;
    return function() {
      var a = sf(this, e), s = n(this), l = s + "";
      return s == null && (l = s = (this.style.removeProperty(e), sf(this, e))), a === l ? null : a === r && l === o ? i : (o = l, i = t(r = a, s));
    };
  }
  function dme(e, t) {
    var n, r, o, i = "style." + t, a = "end." + i, s;
    return function() {
      var l = Zi(this, e), u = l.on, d = l.value[i] == null ? s || (s = H9(t)) : void 0;
      (u !== n || o !== d) && (r = (n = u).copy()).on(a, o = d), l.on = r;
    };
  }
  function pme(e, t, n) {
    var r = (e += "") == "transform" ? hhe : V9;
    return t == null ? this.styleTween(e, cme(e, r)).on("end.style." + e, H9(e)) : typeof t == "function" ? this.styleTween(e, fme(e, r, wT(this, "style." + e, t))).each(dme(this._id, e)) : this.styleTween(e, ume(e, r, t), n).on("end.style." + e, null);
  }
  function hme(e, t, n) {
    return function(r) {
      this.style.setProperty(e, t.call(this, r), n);
    };
  }
  function mme(e, t, n) {
    var r, o;
    function i() {
      var a = t.apply(this, arguments);
      return a !== o && (r = (o = a) && hme(e, a, n)), r;
    }
    return i._value = t, i;
  }
  function gme(e, t, n) {
    var r = "style." + (e += "");
    if (arguments.length < 2) return (r = this.tween(r)) && r._value;
    if (t == null) return this.tween(r, null);
    if (typeof t != "function") throw new Error();
    return this.tween(r, mme(e, t, n ?? ""));
  }
  function yme(e) {
    return function() {
      this.textContent = e;
    };
  }
  function vme(e) {
    return function() {
      var t = e(this);
      this.textContent = t ?? "";
    };
  }
  function bme(e) {
    return this.tween("text", typeof e == "function" ? vme(wT(this, "text", e)) : yme(e == null ? "" : e + ""));
  }
  function xme(e) {
    return function(t) {
      this.textContent = e.call(this, t);
    };
  }
  function wme(e) {
    var t, n;
    function r() {
      var o = e.apply(this, arguments);
      return o !== n && (t = (n = o) && xme(o)), t;
    }
    return r._value = e, r;
  }
  function Sme(e) {
    var t = "text";
    if (arguments.length < 1) return (t = this.tween(t)) && t._value;
    if (e == null) return this.tween(t, null);
    if (typeof e != "function") throw new Error();
    return this.tween(t, wme(e));
  }
  function _me() {
    for (var e = this._name, t = this._id, n = q9(), r = this._groups, o = r.length, i = 0; i < o; ++i)
      for (var a = r[i], s = a.length, l, u = 0; u < s; ++u)
        if (l = a[u]) {
          var d = ri(l, t);
          Db(l, e, n, u, a, {
            time: d.time + d.delay + d.duration,
            delay: 0,
            duration: d.duration,
            ease: d.ease
          });
        }
    return new Va(r, this._parents, e, n);
  }
  function Eme() {
    var e, t, n = this, r = n._id, o = n.size();
    return new Promise(function(i, a) {
      var s = { value: a }, l = { value: function() {
        --o === 0 && i();
      } };
      n.each(function() {
        var u = Zi(this, r), d = u.on;
        d !== e && (t = (e = d).copy(), t._.cancel.push(s), t._.interrupt.push(s), t._.end.push(l)), u.on = t;
      }), o === 0 && i();
    });
  }
  var Cme = 0;
  function Va(e, t, n, r) {
    this._groups = e, this._parents = t, this._name = n, this._id = r;
  }
  function q9() {
    return ++Cme;
  }
  var Sa = Kh.prototype;
  Va.prototype = {
    constructor: Va,
    select: ime,
    selectAll: ame,
    selectChild: Sa.selectChild,
    selectChildren: Sa.selectChildren,
    filter: Qhe,
    merge: Jhe,
    selection: lme,
    transition: _me,
    call: Sa.call,
    nodes: Sa.nodes,
    node: Sa.node,
    size: Sa.size,
    empty: Sa.empty,
    each: Sa.each,
    on: nme,
    attr: jhe,
    attrTween: Bhe,
    style: pme,
    styleTween: gme,
    text: bme,
    textTween: Sme,
    remove: ome,
    tween: Ohe,
    delay: Hhe,
    duration: Ghe,
    ease: Yhe,
    easeVarying: Zhe,
    end: Eme,
    [Symbol.iterator]: Sa[Symbol.iterator]
  };
  function kme(e) {
    return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
  }
  var Tme = {
    time: null,
    // Set on use.
    delay: 0,
    duration: 250,
    ease: kme
  };
  function Rme(e, t) {
    for (var n; !(n = e.__transition) || !(n = n[t]); )
      if (!(e = e.parentNode))
        throw new Error(`transition ${t} not found`);
    return n;
  }
  function Ome(e) {
    var t, n;
    e instanceof Va ? (t = e._id, e = e._name) : (t = q9(), (n = Tme).time = bT(), e = e == null ? null : e + "");
    for (var r = this._groups, o = r.length, i = 0; i < o; ++i)
      for (var a = r[i], s = a.length, l, u = 0; u < s; ++u)
        (l = a[u]) && Db(l, e, t, u, a, n || Rme(l, t));
    return new Va(r, this._parents, e, t);
  }
  Kh.prototype.interrupt = khe;
  Kh.prototype.transition = Ome;
  const ry = (e) => () => e;
  function Ame(e, {
    sourceEvent: t,
    target: n,
    transform: r,
    dispatch: o
  }) {
    Object.defineProperties(this, {
      type: { value: e, enumerable: !0, configurable: !0 },
      sourceEvent: { value: t, enumerable: !0, configurable: !0 },
      target: { value: n, enumerable: !0, configurable: !0 },
      transform: { value: r, enumerable: !0, configurable: !0 },
      _: { value: o }
    });
  }
  function Aa(e, t, n) {
    this.k = e, this.x = t, this.y = n;
  }
  Aa.prototype = {
    constructor: Aa,
    scale: function(e) {
      return e === 1 ? this : new Aa(this.k * e, this.x, this.y);
    },
    translate: function(e, t) {
      return e === 0 & t === 0 ? this : new Aa(this.k, this.x + this.k * e, this.y + this.k * t);
    },
    apply: function(e) {
      return [e[0] * this.k + this.x, e[1] * this.k + this.y];
    },
    applyX: function(e) {
      return e * this.k + this.x;
    },
    applyY: function(e) {
      return e * this.k + this.y;
    },
    invert: function(e) {
      return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
    },
    invertX: function(e) {
      return (e - this.x) / this.k;
    },
    invertY: function(e) {
      return (e - this.y) / this.k;
    },
    rescaleX: function(e) {
      return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
    },
    rescaleY: function(e) {
      return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
    },
    toString: function() {
      return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
    }
  };
  var Fb = new Aa(1, 0, 0);
  W9.prototype = Aa.prototype;
  function W9(e) {
    for (; !e.__zoom; ) if (!(e = e.parentNode)) return Fb;
    return e.__zoom;
  }
  function HS(e) {
    e.stopImmediatePropagation();
  }
  function Kd(e) {
    e.preventDefault(), e.stopImmediatePropagation();
  }
  function Nme(e) {
    return (!e.ctrlKey || e.type === "wheel") && !e.button;
  }
  function Mme() {
    var e = this;
    return e instanceof SVGElement ? (e = e.ownerSVGElement || e, e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]]) : [[0, 0], [e.clientWidth, e.clientHeight]];
  }
  function wI() {
    return this.__zoom || Fb;
  }
  function Pme(e) {
    return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * (e.ctrlKey ? 10 : 1);
  }
  function $me() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function Ime(e, t, n) {
    var r = e.invertX(t[0][0]) - n[0][0], o = e.invertX(t[1][0]) - n[1][0], i = e.invertY(t[0][1]) - n[0][1], a = e.invertY(t[1][1]) - n[1][1];
    return e.translate(
      o > r ? (r + o) / 2 : Math.min(0, r) || Math.max(0, o),
      a > i ? (i + a) / 2 : Math.min(0, i) || Math.max(0, a)
    );
  }
  function G9() {
    var e = Nme, t = Mme, n = Ime, r = Pme, o = $me, i = [0, 1 / 0], a = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], s = 250, l = Ev, u = $b("start", "zoom", "end"), d, p, h, g = 500, y = 150, b = 0, v = 10;
    function x(j) {
      j.property("__zoom", wI).on("wheel.zoom", M, { passive: !1 }).on("mousedown.zoom", I).on("dblclick.zoom", D).filter(o).on("touchstart.zoom", L).on("touchmove.zoom", P).on("touchend.zoom touchcancel.zoom", B).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    x.transform = function(j, V, F, G) {
      var W = j.selection ? j.selection() : j;
      W.property("__zoom", wI), j !== W ? k(j, V, F, G) : W.interrupt().each(function() {
        R(this, arguments).event(G).start().zoom(null, typeof V == "function" ? V.apply(this, arguments) : V).end();
      });
    }, x.scaleBy = function(j, V, F, G) {
      x.scaleTo(j, function() {
        var W = this.__zoom.k, K = typeof V == "function" ? V.apply(this, arguments) : V;
        return W * K;
      }, F, G);
    }, x.scaleTo = function(j, V, F, G) {
      x.transform(j, function() {
        var W = t.apply(this, arguments), K = this.__zoom, $ = F == null ? C(W) : typeof F == "function" ? F.apply(this, arguments) : F, U = K.invert($), X = typeof V == "function" ? V.apply(this, arguments) : V;
        return n(_(E(K, X), $, U), W, a);
      }, F, G);
    }, x.translateBy = function(j, V, F, G) {
      x.transform(j, function() {
        return n(this.__zoom.translate(
          typeof V == "function" ? V.apply(this, arguments) : V,
          typeof F == "function" ? F.apply(this, arguments) : F
        ), t.apply(this, arguments), a);
      }, null, G);
    }, x.translateTo = function(j, V, F, G, W) {
      x.transform(j, function() {
        var K = t.apply(this, arguments), $ = this.__zoom, U = G == null ? C(K) : typeof G == "function" ? G.apply(this, arguments) : G;
        return n(Fb.translate(U[0], U[1]).scale($.k).translate(
          typeof V == "function" ? -V.apply(this, arguments) : -V,
          typeof F == "function" ? -F.apply(this, arguments) : -F
        ), K, a);
      }, G, W);
    };
    function E(j, V) {
      return V = Math.max(i[0], Math.min(i[1], V)), V === j.k ? j : new Aa(V, j.x, j.y);
    }
    function _(j, V, F) {
      var G = V[0] - F[0] * j.k, W = V[1] - F[1] * j.k;
      return G === j.x && W === j.y ? j : new Aa(j.k, G, W);
    }
    function C(j) {
      return [(+j[0][0] + +j[1][0]) / 2, (+j[0][1] + +j[1][1]) / 2];
    }
    function k(j, V, F, G) {
      j.on("start.zoom", function() {
        R(this, arguments).event(G).start();
      }).on("interrupt.zoom end.zoom", function() {
        R(this, arguments).event(G).end();
      }).tween("zoom", function() {
        var W = this, K = arguments, $ = R(W, K).event(G), U = t.apply(W, K), X = F == null ? C(U) : typeof F == "function" ? F.apply(W, K) : F, z = Math.max(U[1][0] - U[0][0], U[1][1] - U[0][1]), H = W.__zoom, Y = typeof V == "function" ? V.apply(W, K) : V, Q = l(H.invert(X).concat(z / H.k), Y.invert(X).concat(z / Y.k));
        return function(re) {
          if (re === 1) re = Y;
          else {
            var te = Q(re), le = z / te[2];
            re = new Aa(le, X[0] - te[0] * le, X[1] - te[1] * le);
          }
          $.zoom(null, re);
        };
      });
    }
    function R(j, V, F) {
      return !F && j.__zooming || new A(j, V);
    }
    function A(j, V) {
      this.that = j, this.args = V, this.active = 0, this.sourceEvent = null, this.extent = t.apply(j, V), this.taps = 0;
    }
    A.prototype = {
      event: function(j) {
        return j && (this.sourceEvent = j), this;
      },
      start: function() {
        return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
      },
      zoom: function(j, V) {
        return this.mouse && j !== "mouse" && (this.mouse[1] = V.invert(this.mouse[0])), this.touch0 && j !== "touch" && (this.touch0[1] = V.invert(this.touch0[0])), this.touch1 && j !== "touch" && (this.touch1[1] = V.invert(this.touch1[0])), this.that.__zoom = V, this.emit("zoom"), this;
      },
      end: function() {
        return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
      },
      emit: function(j) {
        var V = no(this.that).datum();
        u.call(
          j,
          this.that,
          new Ame(j, {
            sourceEvent: this.sourceEvent,
            target: x,
            transform: this.that.__zoom,
            dispatch: u
          }),
          V
        );
      }
    };
    function M(j, ...V) {
      if (!e.apply(this, arguments)) return;
      var F = R(this, V).event(j), G = this.__zoom, W = Math.max(i[0], Math.min(i[1], G.k * Math.pow(2, r.apply(this, arguments)))), K = Bo(j);
      if (F.wheel)
        (F.mouse[0][0] !== K[0] || F.mouse[0][1] !== K[1]) && (F.mouse[1] = G.invert(F.mouse[0] = K)), clearTimeout(F.wheel);
      else {
        if (G.k === W) return;
        F.mouse = [K, G.invert(K)], Tv(this), F.start();
      }
      Kd(j), F.wheel = setTimeout($, y), F.zoom("mouse", n(_(E(G, W), F.mouse[0], F.mouse[1]), F.extent, a));
      function $() {
        F.wheel = null, F.end();
      }
    }
    function I(j, ...V) {
      if (h || !e.apply(this, arguments)) return;
      var F = j.currentTarget, G = R(this, V, !0).event(j), W = no(j.view).on("mousemove.zoom", X, !0).on("mouseup.zoom", z, !0), K = Bo(j, F), $ = j.clientX, U = j.clientY;
      A9(j.view), HS(j), G.mouse = [K, this.__zoom.invert(K)], Tv(this), G.start();
      function X(H) {
        if (Kd(H), !G.moved) {
          var Y = H.clientX - $, Q = H.clientY - U;
          G.moved = Y * Y + Q * Q > b;
        }
        G.event(H).zoom("mouse", n(_(G.that.__zoom, G.mouse[0] = Bo(H, F), G.mouse[1]), G.extent, a));
      }
      function z(H) {
        W.on("mousemove.zoom mouseup.zoom", null), N9(H.view, G.moved), Kd(H), G.event(H).end();
      }
    }
    function D(j, ...V) {
      if (e.apply(this, arguments)) {
        var F = this.__zoom, G = Bo(j.changedTouches ? j.changedTouches[0] : j, this), W = F.invert(G), K = F.k * (j.shiftKey ? 0.5 : 2), $ = n(_(E(F, K), G, W), t.apply(this, V), a);
        Kd(j), s > 0 ? no(this).transition().duration(s).call(k, $, G, j) : no(this).call(x.transform, $, G, j);
      }
    }
    function L(j, ...V) {
      if (e.apply(this, arguments)) {
        var F = j.touches, G = F.length, W = R(this, V, j.changedTouches.length === G).event(j), K, $, U, X;
        for (HS(j), $ = 0; $ < G; ++$)
          U = F[$], X = Bo(U, this), X = [X, this.__zoom.invert(X), U.identifier], W.touch0 ? !W.touch1 && W.touch0[2] !== X[2] && (W.touch1 = X, W.taps = 0) : (W.touch0 = X, K = !0, W.taps = 1 + !!d);
        d && (d = clearTimeout(d)), K && (W.taps < 2 && (p = X[0], d = setTimeout(function() {
          d = null;
        }, g)), Tv(this), W.start());
      }
    }
    function P(j, ...V) {
      if (this.__zooming) {
        var F = R(this, V).event(j), G = j.changedTouches, W = G.length, K, $, U, X;
        for (Kd(j), K = 0; K < W; ++K)
          $ = G[K], U = Bo($, this), F.touch0 && F.touch0[2] === $.identifier ? F.touch0[0] = U : F.touch1 && F.touch1[2] === $.identifier && (F.touch1[0] = U);
        if ($ = F.that.__zoom, F.touch1) {
          var z = F.touch0[0], H = F.touch0[1], Y = F.touch1[0], Q = F.touch1[1], re = (re = Y[0] - z[0]) * re + (re = Y[1] - z[1]) * re, te = (te = Q[0] - H[0]) * te + (te = Q[1] - H[1]) * te;
          $ = E($, Math.sqrt(re / te)), U = [(z[0] + Y[0]) / 2, (z[1] + Y[1]) / 2], X = [(H[0] + Q[0]) / 2, (H[1] + Q[1]) / 2];
        } else if (F.touch0) U = F.touch0[0], X = F.touch0[1];
        else return;
        F.zoom("touch", n(_($, U, X), F.extent, a));
      }
    }
    function B(j, ...V) {
      if (this.__zooming) {
        var F = R(this, V).event(j), G = j.changedTouches, W = G.length, K, $;
        for (HS(j), h && clearTimeout(h), h = setTimeout(function() {
          h = null;
        }, g), K = 0; K < W; ++K)
          $ = G[K], F.touch0 && F.touch0[2] === $.identifier ? delete F.touch0 : F.touch1 && F.touch1[2] === $.identifier && delete F.touch1;
        if (F.touch1 && !F.touch0 && (F.touch0 = F.touch1, delete F.touch1), F.touch0) F.touch0[1] = this.__zoom.invert(F.touch0[0]);
        else if (F.end(), F.taps === 2 && ($ = Bo($, this), Math.hypot(p[0] - $[0], p[1] - $[1]) < v)) {
          var U = no(this).on("dblclick.zoom");
          U && U.apply(this, arguments);
        }
      }
    }
    return x.wheelDelta = function(j) {
      return arguments.length ? (r = typeof j == "function" ? j : ry(+j), x) : r;
    }, x.filter = function(j) {
      return arguments.length ? (e = typeof j == "function" ? j : ry(!!j), x) : e;
    }, x.touchable = function(j) {
      return arguments.length ? (o = typeof j == "function" ? j : ry(!!j), x) : o;
    }, x.extent = function(j) {
      return arguments.length ? (t = typeof j == "function" ? j : ry([[+j[0][0], +j[0][1]], [+j[1][0], +j[1][1]]]), x) : t;
    }, x.scaleExtent = function(j) {
      return arguments.length ? (i[0] = +j[0], i[1] = +j[1], x) : [i[0], i[1]];
    }, x.translateExtent = function(j) {
      return arguments.length ? (a[0][0] = +j[0][0], a[1][0] = +j[1][0], a[0][1] = +j[0][1], a[1][1] = +j[1][1], x) : [[a[0][0], a[0][1]], [a[1][0], a[1][1]]];
    }, x.constrain = function(j) {
      return arguments.length ? (n = j, x) : n;
    }, x.duration = function(j) {
      return arguments.length ? (s = +j, x) : s;
    }, x.interpolate = function(j) {
      return arguments.length ? (l = j, x) : l;
    }, x.on = function() {
      var j = u.on.apply(u, arguments);
      return j === u ? x : j;
    }, x.clickDistance = function(j) {
      return arguments.length ? (b = (j = +j) * j, x) : Math.sqrt(b);
    }, x.tapDistance = function(j) {
      return arguments.length ? (v = +j, x) : v;
    }, x;
  }
  const qi = {
    error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
    error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
    error003: (e) => `Node type "${e}" not found. Using fallback type "default".`,
    error004: () => "The React Flow parent container needs a width and a height to render the graph.",
    error005: () => "Only child nodes can use a parent extent.",
    error006: () => "Can't create edge. An edge needs a source and a target.",
    error007: (e) => `The old edge with id=${e} does not exist.`,
    error009: (e) => `Marker type "${e}" doesn't exist.`,
    error008: (e, { id: t, sourceHandle: n, targetHandle: r }) => `Couldn't create edge for ${e} handle id: "${e === "source" ? n : r}", edge id: ${t}.`,
    error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
    error011: (e) => `Edge type "${e}" not found. Using fallback type "default".`,
    error012: (e) => `Node with id "${e}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
    error013: (e = "react") => `It seems that you haven't loaded the styles. Please import '@xyflow/${e}/dist/style.css' or base.css to make sure everything is working properly.`,
    error014: () => "useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.",
    error015: () => "It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs."
  }, oh = [
    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
  ], K9 = ["Enter", " ", "Escape"], Y9 = {
    "node.a11yDescription.default": "Press enter or space to select a node. Press delete to remove it and escape to cancel.",
    "node.a11yDescription.keyboardDisabled": "Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.",
    "node.a11yDescription.ariaLiveMessage": ({ direction: e, x: t, y: n }) => `Moved selected node ${e}. New position, x: ${t}, y: ${n}`,
    "edge.a11yDescription.default": "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.",
    // Control elements
    "controls.ariaLabel": "Control Panel",
    "controls.zoomIn.ariaLabel": "Zoom In",
    "controls.zoomOut.ariaLabel": "Zoom Out",
    "controls.fitView.ariaLabel": "Fit View",
    "controls.interactive.ariaLabel": "Toggle Interactivity",
    // Mini map
    "minimap.ariaLabel": "Mini Map",
    // Handle
    "handle.ariaLabel": "Handle"
  };
  var cf;
  (function(e) {
    e.Strict = "strict", e.Loose = "loose";
  })(cf || (cf = {}));
  var Jl;
  (function(e) {
    e.Free = "free", e.Vertical = "vertical", e.Horizontal = "horizontal";
  })(Jl || (Jl = {}));
  var ih;
  (function(e) {
    e.Partial = "partial", e.Full = "full";
  })(ih || (ih = {}));
  const X9 = {
    inProgress: !1,
    isValid: null,
    from: null,
    fromHandle: null,
    fromPosition: null,
    fromNode: null,
    to: null,
    toHandle: null,
    toPosition: null,
    toNode: null
  };
  var zs;
  (function(e) {
    e.Bezier = "default", e.Straight = "straight", e.Step = "step", e.SmoothStep = "smoothstep", e.SimpleBezier = "simplebezier";
  })(zs || (zs = {}));
  var m0;
  (function(e) {
    e.Arrow = "arrow", e.ArrowClosed = "arrowclosed";
  })(m0 || (m0 = {}));
  var qe;
  (function(e) {
    e.Left = "left", e.Top = "top", e.Right = "right", e.Bottom = "bottom";
  })(qe || (qe = {}));
  const SI = {
    [qe.Left]: qe.Right,
    [qe.Right]: qe.Left,
    [qe.Top]: qe.Bottom,
    [qe.Bottom]: qe.Top
  };
  function Z9(e) {
    return e === null ? null : e ? "valid" : "invalid";
  }
  const Q9 = (e) => "id" in e && "source" in e && "target" in e, jme = (e) => "id" in e && "position" in e && !("source" in e) && !("target" in e), ST = (e) => "id" in e && "internals" in e && !("source" in e) && !("target" in e), Xh = (e, t = [0, 0]) => {
    const { width: n, height: r } = Xa(e), o = e.origin ?? t, i = n * o[0], a = r * o[1];
    return {
      x: e.position.x - i,
      y: e.position.y - a
    };
  }, Dme = (e, t = { nodeOrigin: [0, 0] }) => {
    if (e.length === 0)
      return { x: 0, y: 0, width: 0, height: 0 };
    const n = e.reduce((r, o) => {
      const i = typeof o == "string";
      let a = !t.nodeLookup && !i ? o : void 0;
      t.nodeLookup && (a = i ? t.nodeLookup.get(o) : ST(o) ? o : t.nodeLookup.get(o.id));
      const s = a ? g0(a, t.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };
      return Lb(r, s);
    }, { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 });
    return zb(n);
  }, Zh = (e, t = {}) => {
    if (e.size === 0)
      return { x: 0, y: 0, width: 0, height: 0 };
    let n = { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 };
    return e.forEach((r) => {
      if (t.filter === void 0 || t.filter(r)) {
        const o = g0(r);
        n = Lb(n, o);
      }
    }), zb(n);
  }, _T = (e, t, [n, r, o] = [0, 0, 1], i = !1, a = !1) => {
    const s = {
      ...Qh(t, [n, r, o]),
      width: t.width / o,
      height: t.height / o
    }, l = [];
    for (const u of e.values()) {
      const { measured: d, selectable: p = !0, hidden: h = !1 } = u;
      if (a && !p || h)
        continue;
      const g = d.width ?? u.width ?? u.initialWidth ?? null, y = d.height ?? u.height ?? u.initialHeight ?? null, b = ah(s, ff(u)), v = (g ?? 0) * (y ?? 0), x = i && b > 0;
      (!u.internals.handleBounds || x || b >= v || u.dragging) && l.push(u);
    }
    return l;
  }, Fme = (e, t) => {
    const n = /* @__PURE__ */ new Set();
    return e.forEach((r) => {
      n.add(r.id);
    }), t.filter((r) => n.has(r.source) || n.has(r.target));
  };
  function Lme(e, t) {
    const n = /* @__PURE__ */ new Map(), r = t?.nodes ? new Set(t.nodes.map((o) => o.id)) : null;
    return e.forEach((o) => {
      o.measured.width && o.measured.height && (t?.includeHiddenNodes || !o.hidden) && (!r || r.has(o.id)) && n.set(o.id, o);
    }), n;
  }
  async function zme({ nodes: e, width: t, height: n, panZoom: r, minZoom: o, maxZoom: i }, a) {
    if (e.size === 0)
      return Promise.resolve(!0);
    const s = Lme(e, a), l = Zh(s), u = ET(l, t, n, a?.minZoom ?? o, a?.maxZoom ?? i, a?.padding ?? 0.1);
    return await r.setViewport(u, {
      duration: a?.duration,
      ease: a?.ease,
      interpolate: a?.interpolate
    }), Promise.resolve(!0);
  }
  function J9({ nodeId: e, nextPosition: t, nodeLookup: n, nodeOrigin: r = [0, 0], nodeExtent: o, onError: i }) {
    const a = n.get(e), s = a.parentId ? n.get(a.parentId) : void 0, { x: l, y: u } = s ? s.internals.positionAbsolute : { x: 0, y: 0 }, d = a.origin ?? r;
    let p = a.extent || o;
    if (a.extent === "parent" && !a.expandParent)
      if (!s)
        i?.("005", qi.error005());
      else {
        const g = s.measured.width, y = s.measured.height;
        g && y && (p = [
          [l, u],
          [l + g, u + y]
        ]);
      }
    else s && df(a.extent) && (p = [
      [a.extent[0][0] + l, a.extent[0][1] + u],
      [a.extent[1][0] + l, a.extent[1][1] + u]
    ]);
    const h = df(p) ? uc(t, p, a.measured) : t;
    return (a.measured.width === void 0 || a.measured.height === void 0) && i?.("015", qi.error015()), {
      position: {
        x: h.x - l + (a.measured.width ?? 0) * d[0],
        y: h.y - u + (a.measured.height ?? 0) * d[1]
      },
      positionAbsolute: h
    };
  }
  async function Bme({ nodesToRemove: e = [], edgesToRemove: t = [], nodes: n, edges: r, onBeforeDelete: o }) {
    const i = new Set(e.map((h) => h.id)), a = [];
    for (const h of n) {
      if (h.deletable === !1)
        continue;
      const g = i.has(h.id), y = !g && h.parentId && a.find((b) => b.id === h.parentId);
      (g || y) && a.push(h);
    }
    const s = new Set(t.map((h) => h.id)), l = r.filter((h) => h.deletable !== !1), d = Fme(a, l);
    for (const h of l)
      s.has(h.id) && !d.find((y) => y.id === h.id) && d.push(h);
    if (!o)
      return {
        edges: d,
        nodes: a
      };
    const p = await o({
      nodes: a,
      edges: d
    });
    return typeof p == "boolean" ? p ? { edges: d, nodes: a } : { edges: [], nodes: [] } : p;
  }
  const uf = (e, t = 0, n = 1) => Math.min(Math.max(e, t), n), uc = (e = { x: 0, y: 0 }, t, n) => ({
    x: uf(e.x, t[0][0], t[1][0] - (n?.width ?? 0)),
    y: uf(e.y, t[0][1], t[1][1] - (n?.height ?? 0))
  });
  function eB(e, t, n) {
    const { width: r, height: o } = Xa(n), { x: i, y: a } = n.internals.positionAbsolute;
    return uc(e, [
      [i, a],
      [i + r, a + o]
    ], t);
  }
  const _I = (e, t, n) => e < t ? uf(Math.abs(e - t), 1, t) / t : e > n ? -uf(Math.abs(e - n), 1, t) / t : 0, tB = (e, t, n = 15, r = 40) => {
    const o = _I(e.x, r, t.width - r) * n, i = _I(e.y, r, t.height - r) * n;
    return [o, i];
  }, Lb = (e, t) => ({
    x: Math.min(e.x, t.x),
    y: Math.min(e.y, t.y),
    x2: Math.max(e.x2, t.x2),
    y2: Math.max(e.y2, t.y2)
  }), oC = ({ x: e, y: t, width: n, height: r }) => ({
    x: e,
    y: t,
    x2: e + n,
    y2: t + r
  }), zb = ({ x: e, y: t, x2: n, y2: r }) => ({
    x: e,
    y: t,
    width: n - e,
    height: r - t
  }), ff = (e, t = [0, 0]) => {
    const { x: n, y: r } = ST(e) ? e.internals.positionAbsolute : Xh(e, t);
    return {
      x: n,
      y: r,
      width: e.measured?.width ?? e.width ?? e.initialWidth ?? 0,
      height: e.measured?.height ?? e.height ?? e.initialHeight ?? 0
    };
  }, g0 = (e, t = [0, 0]) => {
    const { x: n, y: r } = ST(e) ? e.internals.positionAbsolute : Xh(e, t);
    return {
      x: n,
      y: r,
      x2: n + (e.measured?.width ?? e.width ?? e.initialWidth ?? 0),
      y2: r + (e.measured?.height ?? e.height ?? e.initialHeight ?? 0)
    };
  }, nB = (e, t) => zb(Lb(oC(e), oC(t))), ah = (e, t) => {
    const n = Math.max(0, Math.min(e.x + e.width, t.x + t.width) - Math.max(e.x, t.x)), r = Math.max(0, Math.min(e.y + e.height, t.y + t.height) - Math.max(e.y, t.y));
    return Math.ceil(n * r);
  }, EI = (e) => qo(e.width) && qo(e.height) && qo(e.x) && qo(e.y), qo = (e) => !isNaN(e) && isFinite(e), Ume = (e, t) => {
  }, Bb = (e, t = [1, 1]) => ({
    x: t[0] * Math.round(e.x / t[0]),
    y: t[1] * Math.round(e.y / t[1])
  }), Qh = ({ x: e, y: t }, [n, r, o], i = !1, a = [1, 1]) => {
    const s = {
      x: (e - n) / o,
      y: (t - r) / o
    };
    return i ? Bb(s, a) : s;
  }, y0 = ({ x: e, y: t }, [n, r, o]) => ({
    x: e * o + n,
    y: t * o + r
  });
  function _u(e, t) {
    if (typeof e == "number")
      return Math.floor((t - t / (1 + e)) * 0.5);
    if (typeof e == "string" && e.endsWith("px")) {
      const n = parseFloat(e);
      if (!Number.isNaN(n))
        return Math.floor(n);
    }
    if (typeof e == "string" && e.endsWith("%")) {
      const n = parseFloat(e);
      if (!Number.isNaN(n))
        return Math.floor(t * n * 0.01);
    }
    return console.error(`[React Flow] The padding value "${e}" is invalid. Please provide a number or a string with a valid unit (px or %).`), 0;
  }
  function Vme(e, t, n) {
    if (typeof e == "string" || typeof e == "number") {
      const r = _u(e, n), o = _u(e, t);
      return {
        top: r,
        right: o,
        bottom: r,
        left: o,
        x: o * 2,
        y: r * 2
      };
    }
    if (typeof e == "object") {
      const r = _u(e.top ?? e.y ?? 0, n), o = _u(e.bottom ?? e.y ?? 0, n), i = _u(e.left ?? e.x ?? 0, t), a = _u(e.right ?? e.x ?? 0, t);
      return { top: r, right: a, bottom: o, left: i, x: i + a, y: r + o };
    }
    return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 };
  }
  function Hme(e, t, n, r, o, i) {
    const { x: a, y: s } = y0(e, [t, n, r]), { x: l, y: u } = y0({ x: e.x + e.width, y: e.y + e.height }, [t, n, r]), d = o - l, p = i - u;
    return {
      left: Math.floor(a),
      top: Math.floor(s),
      right: Math.floor(d),
      bottom: Math.floor(p)
    };
  }
  const ET = (e, t, n, r, o, i) => {
    const a = Vme(i, t, n), s = (t - a.x) / e.width, l = (n - a.y) / e.height, u = Math.min(s, l), d = uf(u, r, o), p = e.x + e.width / 2, h = e.y + e.height / 2, g = t / 2 - p * d, y = n / 2 - h * d, b = Hme(e, g, y, d, t, n), v = {
      left: Math.min(b.left - a.left, 0),
      top: Math.min(b.top - a.top, 0),
      right: Math.min(b.right - a.right, 0),
      bottom: Math.min(b.bottom - a.bottom, 0)
    };
    return {
      x: g - v.left + v.right,
      y: y - v.top + v.bottom,
      zoom: d
    };
  }, v0 = () => typeof navigator < "u" && navigator?.userAgent?.indexOf("Mac") >= 0;
  function df(e) {
    return e !== void 0 && e !== "parent";
  }
  function Xa(e) {
    return {
      width: e.measured?.width ?? e.width ?? e.initialWidth ?? 0,
      height: e.measured?.height ?? e.height ?? e.initialHeight ?? 0
    };
  }
  function rB(e) {
    return (e.measured?.width ?? e.width ?? e.initialWidth) !== void 0 && (e.measured?.height ?? e.height ?? e.initialHeight) !== void 0;
  }
  function oB(e, t = { width: 0, height: 0 }, n, r, o) {
    const i = { ...e }, a = r.get(n);
    if (a) {
      const s = a.origin || o;
      i.x += a.internals.positionAbsolute.x - (t.width ?? 0) * s[0], i.y += a.internals.positionAbsolute.y - (t.height ?? 0) * s[1];
    }
    return i;
  }
  function CI(e, t) {
    if (e.size !== t.size)
      return !1;
    for (const n of e)
      if (!t.has(n))
        return !1;
    return !0;
  }
  function qme() {
    let e, t;
    return { promise: new Promise((r, o) => {
      e = r, t = o;
    }), resolve: e, reject: t };
  }
  function Wme(e) {
    return { ...Y9, ...e || {} };
  }
  function Op(e, { snapGrid: t = [0, 0], snapToGrid: n = !1, transform: r, containerBounds: o }) {
    const { x: i, y: a } = Ni(e), s = Qh({ x: i - (o?.left ?? 0), y: a - (o?.top ?? 0) }, r), { x: l, y: u } = n ? Bb(s, t) : s;
    return {
      xSnapped: l,
      ySnapped: u,
      ...s
    };
  }
  const CT = (e) => ({
    width: e.offsetWidth,
    height: e.offsetHeight
  }), iB = (e) => e?.getRootNode?.() || window?.document, Gme = ["INPUT", "SELECT", "TEXTAREA"];
  function aB(e) {
    const t = e.composedPath?.()?.[0] || e.target;
    return t?.nodeType !== 1 ? !1 : Gme.includes(t.nodeName) || t.hasAttribute("contenteditable") || !!t.closest(".nokey");
  }
  const sB = (e) => "clientX" in e, Ni = (e, t) => {
    const n = sB(e), r = n ? e.clientX : e.touches?.[0].clientX, o = n ? e.clientY : e.touches?.[0].clientY;
    return {
      x: r - (t?.left ?? 0),
      y: o - (t?.top ?? 0)
    };
  }, kI = (e, t, n, r, o) => {
    const i = t.querySelectorAll(`.${e}`);
    return !i || !i.length ? null : Array.from(i).map((a) => {
      const s = a.getBoundingClientRect();
      return {
        id: a.getAttribute("data-handleid"),
        type: e,
        nodeId: o,
        position: a.getAttribute("data-handlepos"),
        x: (s.left - n.left) / r,
        y: (s.top - n.top) / r,
        ...CT(a)
      };
    });
  };
  function lB({ sourceX: e, sourceY: t, targetX: n, targetY: r, sourceControlX: o, sourceControlY: i, targetControlX: a, targetControlY: s }) {
    const l = e * 0.125 + o * 0.375 + a * 0.375 + n * 0.125, u = t * 0.125 + i * 0.375 + s * 0.375 + r * 0.125, d = Math.abs(l - e), p = Math.abs(u - t);
    return [l, u, d, p];
  }
  function oy(e, t) {
    return e >= 0 ? 0.5 * e : t * 25 * Math.sqrt(-e);
  }
  function TI({ pos: e, x1: t, y1: n, x2: r, y2: o, c: i }) {
    switch (e) {
      case qe.Left:
        return [t - oy(t - r, i), n];
      case qe.Right:
        return [t + oy(r - t, i), n];
      case qe.Top:
        return [t, n - oy(n - o, i)];
      case qe.Bottom:
        return [t, n + oy(o - n, i)];
    }
  }
  function kT({ sourceX: e, sourceY: t, sourcePosition: n = qe.Bottom, targetX: r, targetY: o, targetPosition: i = qe.Top, curvature: a = 0.25 }) {
    const [s, l] = TI({
      pos: n,
      x1: e,
      y1: t,
      x2: r,
      y2: o,
      c: a
    }), [u, d] = TI({
      pos: i,
      x1: r,
      y1: o,
      x2: e,
      y2: t,
      c: a
    }), [p, h, g, y] = lB({
      sourceX: e,
      sourceY: t,
      targetX: r,
      targetY: o,
      sourceControlX: s,
      sourceControlY: l,
      targetControlX: u,
      targetControlY: d
    });
    return [
      `M${e},${t} C${s},${l} ${u},${d} ${r},${o}`,
      p,
      h,
      g,
      y
    ];
  }
  function cB({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
    const o = Math.abs(n - e) / 2, i = n < e ? n + o : n - o, a = Math.abs(r - t) / 2, s = r < t ? r + a : r - a;
    return [i, s, o, a];
  }
  function Kme({ sourceNode: e, targetNode: t, selected: n = !1, zIndex: r, elevateOnSelect: o = !1 }) {
    if (r !== void 0)
      return r;
    const i = o && n ? 1e3 : 0, a = Math.max(e.parentId ? e.internals.z : 0, t.parentId ? t.internals.z : 0);
    return i + a;
  }
  function Yme({ sourceNode: e, targetNode: t, width: n, height: r, transform: o }) {
    const i = Lb(g0(e), g0(t));
    i.x === i.x2 && (i.x2 += 1), i.y === i.y2 && (i.y2 += 1);
    const a = {
      x: -o[0] / o[2],
      y: -o[1] / o[2],
      width: n / o[2],
      height: r / o[2]
    };
    return ah(a, zb(i)) > 0;
  }
  const Xme = ({ source: e, sourceHandle: t, target: n, targetHandle: r }) => `xy-edge__${e}${t || ""}-${n}${r || ""}`, Zme = (e, t) => t.some((n) => n.source === e.source && n.target === e.target && (n.sourceHandle === e.sourceHandle || !n.sourceHandle && !e.sourceHandle) && (n.targetHandle === e.targetHandle || !n.targetHandle && !e.targetHandle)), Qme = (e, t) => {
    if (!e.source || !e.target)
      return t;
    let n;
    return Q9(e) ? n = { ...e } : n = {
      ...e,
      id: Xme(e)
    }, Zme(n, t) ? t : (n.sourceHandle === null && delete n.sourceHandle, n.targetHandle === null && delete n.targetHandle, t.concat(n));
  };
  function uB({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
    const [o, i, a, s] = cB({
      sourceX: e,
      sourceY: t,
      targetX: n,
      targetY: r
    });
    return [`M ${e},${t}L ${n},${r}`, o, i, a, s];
  }
  const RI = {
    [qe.Left]: { x: -1, y: 0 },
    [qe.Right]: { x: 1, y: 0 },
    [qe.Top]: { x: 0, y: -1 },
    [qe.Bottom]: { x: 0, y: 1 }
  }, Jme = ({ source: e, sourcePosition: t = qe.Bottom, target: n }) => t === qe.Left || t === qe.Right ? e.x < n.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : e.y < n.y ? { x: 0, y: 1 } : { x: 0, y: -1 }, OI = (e, t) => Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
  function ege({ source: e, sourcePosition: t = qe.Bottom, target: n, targetPosition: r = qe.Top, center: o, offset: i, stepPosition: a }) {
    const s = RI[t], l = RI[r], u = { x: e.x + s.x * i, y: e.y + s.y * i }, d = { x: n.x + l.x * i, y: n.y + l.y * i }, p = Jme({
      source: u,
      sourcePosition: t,
      target: d
    }), h = p.x !== 0 ? "x" : "y", g = p[h];
    let y = [], b, v;
    const x = { x: 0, y: 0 }, E = { x: 0, y: 0 }, [, , _, C] = cB({
      sourceX: e.x,
      sourceY: e.y,
      targetX: n.x,
      targetY: n.y
    });
    if (s[h] * l[h] === -1) {
      h === "x" ? (b = o.x ?? u.x + (d.x - u.x) * a, v = o.y ?? (u.y + d.y) / 2) : (b = o.x ?? (u.x + d.x) / 2, v = o.y ?? u.y + (d.y - u.y) * a);
      const R = [
        { x: b, y: u.y },
        { x: b, y: d.y }
      ], A = [
        { x: u.x, y: v },
        { x: d.x, y: v }
      ];
      s[h] === g ? y = h === "x" ? R : A : y = h === "x" ? A : R;
    } else {
      const R = [{ x: u.x, y: d.y }], A = [{ x: d.x, y: u.y }];
      if (h === "x" ? y = s.x === g ? A : R : y = s.y === g ? R : A, t === r) {
        const P = Math.abs(e[h] - n[h]);
        if (P <= i) {
          const B = Math.min(i - 1, i - P);
          s[h] === g ? x[h] = (u[h] > e[h] ? -1 : 1) * B : E[h] = (d[h] > n[h] ? -1 : 1) * B;
        }
      }
      if (t !== r) {
        const P = h === "x" ? "y" : "x", B = s[h] === l[P], j = u[P] > d[P], V = u[P] < d[P];
        (s[h] === 1 && (!B && j || B && V) || s[h] !== 1 && (!B && V || B && j)) && (y = h === "x" ? R : A);
      }
      const M = { x: u.x + x.x, y: u.y + x.y }, I = { x: d.x + E.x, y: d.y + E.y }, D = Math.max(Math.abs(M.x - y[0].x), Math.abs(I.x - y[0].x)), L = Math.max(Math.abs(M.y - y[0].y), Math.abs(I.y - y[0].y));
      D >= L ? (b = (M.x + I.x) / 2, v = y[0].y) : (b = y[0].x, v = (M.y + I.y) / 2);
    }
    return [[
      e,
      { x: u.x + x.x, y: u.y + x.y },
      ...y,
      { x: d.x + E.x, y: d.y + E.y },
      n
    ], b, v, _, C];
  }
  function tge(e, t, n, r) {
    const o = Math.min(OI(e, t) / 2, OI(t, n) / 2, r), { x: i, y: a } = t;
    if (e.x === i && i === n.x || e.y === a && a === n.y)
      return `L${i} ${a}`;
    if (e.y === a) {
      const u = e.x < n.x ? -1 : 1, d = e.y < n.y ? 1 : -1;
      return `L ${i + o * u},${a}Q ${i},${a} ${i},${a + o * d}`;
    }
    const s = e.x < n.x ? 1 : -1, l = e.y < n.y ? -1 : 1;
    return `L ${i},${a + o * l}Q ${i},${a} ${i + o * s},${a}`;
  }
  function iC({ sourceX: e, sourceY: t, sourcePosition: n = qe.Bottom, targetX: r, targetY: o, targetPosition: i = qe.Top, borderRadius: a = 5, centerX: s, centerY: l, offset: u = 20, stepPosition: d = 0.5 }) {
    const [p, h, g, y, b] = ege({
      source: { x: e, y: t },
      sourcePosition: n,
      target: { x: r, y: o },
      targetPosition: i,
      center: { x: s, y: l },
      offset: u,
      stepPosition: d
    });
    return [p.reduce((x, E, _) => {
      let C = "";
      return _ > 0 && _ < p.length - 1 ? C = tge(p[_ - 1], E, p[_ + 1], a) : C = `${_ === 0 ? "M" : "L"}${E.x} ${E.y}`, x += C, x;
    }, ""), h, g, y, b];
  }
  function AI(e) {
    return e && !!(e.internals.handleBounds || e.handles?.length) && !!(e.measured.width || e.width || e.initialWidth);
  }
  function nge(e) {
    const { sourceNode: t, targetNode: n } = e;
    if (!AI(t) || !AI(n))
      return null;
    const r = t.internals.handleBounds || NI(t.handles), o = n.internals.handleBounds || NI(n.handles), i = MI(r?.source ?? [], e.sourceHandle), a = MI(
      // when connection type is loose we can define all handles as sources and connect source -> source
      e.connectionMode === cf.Strict ? o?.target ?? [] : (o?.target ?? []).concat(o?.source ?? []),
      e.targetHandle
    );
    if (!i || !a)
      return e.onError?.("008", qi.error008(i ? "target" : "source", {
        id: e.id,
        sourceHandle: e.sourceHandle,
        targetHandle: e.targetHandle
      })), null;
    const s = i?.position || qe.Bottom, l = a?.position || qe.Top, u = sh(t, i, s), d = sh(n, a, l);
    return {
      sourceX: u.x,
      sourceY: u.y,
      targetX: d.x,
      targetY: d.y,
      sourcePosition: s,
      targetPosition: l
    };
  }
  function NI(e) {
    if (!e)
      return null;
    const t = [], n = [];
    for (const r of e)
      r.width = r.width ?? 1, r.height = r.height ?? 1, r.type === "source" ? t.push(r) : r.type === "target" && n.push(r);
    return {
      source: t,
      target: n
    };
  }
  function sh(e, t, n = qe.Left, r = !1) {
    const o = (t?.x ?? 0) + e.internals.positionAbsolute.x, i = (t?.y ?? 0) + e.internals.positionAbsolute.y, { width: a, height: s } = t ?? Xa(e);
    if (r)
      return { x: o + a / 2, y: i + s / 2 };
    switch (t?.position ?? n) {
      case qe.Top:
        return { x: o + a / 2, y: i };
      case qe.Right:
        return { x: o + a, y: i + s / 2 };
      case qe.Bottom:
        return { x: o + a / 2, y: i + s };
      case qe.Left:
        return { x: o, y: i + s / 2 };
    }
  }
  function MI(e, t) {
    return e && (t ? e.find((n) => n.id === t) : e[0]) || null;
  }
  function aC(e, t) {
    return e ? typeof e == "string" ? e : `${t ? `${t}__` : ""}${Object.keys(e).sort().map((r) => `${r}=${e[r]}`).join("&")}` : "";
  }
  function rge(e, { id: t, defaultColor: n, defaultMarkerStart: r, defaultMarkerEnd: o }) {
    const i = /* @__PURE__ */ new Set();
    return e.reduce((a, s) => ([s.markerStart || r, s.markerEnd || o].forEach((l) => {
      if (l && typeof l == "object") {
        const u = aC(l, t);
        i.has(u) || (a.push({ id: u, color: l.color || n, ...l }), i.add(u));
      }
    }), a), []).sort((a, s) => a.id.localeCompare(s.id));
  }
  const TT = {
    nodeOrigin: [0, 0],
    nodeExtent: oh,
    elevateNodesOnSelect: !0,
    defaults: {}
  }, oge = {
    ...TT,
    checkEquality: !0
  };
  function RT(e, t) {
    const n = { ...e };
    for (const r in t)
      t[r] !== void 0 && (n[r] = t[r]);
    return n;
  }
  function ige(e, t, n) {
    const r = RT(TT, n);
    for (const o of e.values())
      if (o.parentId)
        OT(o, e, t, r);
      else {
        const i = Xh(o, r.nodeOrigin), a = df(o.extent) ? o.extent : r.nodeExtent, s = uc(i, a, Xa(o));
        o.internals.positionAbsolute = s;
      }
  }
  function sC(e, t, n, r) {
    const o = RT(oge, r);
    let i = e.length > 0;
    const a = new Map(t), s = o?.elevateNodesOnSelect ? 1e3 : 0;
    t.clear(), n.clear();
    for (const l of e) {
      let u = a.get(l.id);
      if (o.checkEquality && l === u?.internals.userNode)
        t.set(l.id, u);
      else {
        const d = Xh(l, o.nodeOrigin), p = df(l.extent) ? l.extent : o.nodeExtent, h = uc(d, p, Xa(l));
        u = {
          ...o.defaults,
          ...l,
          measured: {
            width: l.measured?.width,
            height: l.measured?.height
          },
          internals: {
            positionAbsolute: h,
            // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured
            handleBounds: l.measured ? u?.internals.handleBounds : void 0,
            z: fB(l, s),
            userNode: l
          }
        }, t.set(l.id, u);
      }
      (u.measured === void 0 || u.measured.width === void 0 || u.measured.height === void 0) && !u.hidden && (i = !1), l.parentId && OT(u, t, n, r);
    }
    return i;
  }
  function age(e, t) {
    if (!e.parentId)
      return;
    const n = t.get(e.parentId);
    n ? n.set(e.id, e) : t.set(e.parentId, /* @__PURE__ */ new Map([[e.id, e]]));
  }
  function OT(e, t, n, r) {
    const { elevateNodesOnSelect: o, nodeOrigin: i, nodeExtent: a } = RT(TT, r), s = e.parentId, l = t.get(s);
    if (!l) {
      console.warn(`Parent node ${s} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);
      return;
    }
    age(e, n);
    const u = o ? 1e3 : 0, { x: d, y: p, z: h } = sge(e, l, i, a, u), { positionAbsolute: g } = e.internals, y = d !== g.x || p !== g.y;
    (y || h !== e.internals.z) && t.set(e.id, {
      ...e,
      internals: {
        ...e.internals,
        positionAbsolute: y ? { x: d, y: p } : g,
        z: h
      }
    });
  }
  function fB(e, t) {
    return (qo(e.zIndex) ? e.zIndex : 0) + (e.selected ? t : 0);
  }
  function sge(e, t, n, r, o) {
    const { x: i, y: a } = t.internals.positionAbsolute, s = Xa(e), l = Xh(e, n), u = df(e.extent) ? uc(l, e.extent, s) : l;
    let d = uc({ x: i + u.x, y: a + u.y }, r, s);
    e.extent === "parent" && (d = eB(d, s, t));
    const p = fB(e, o), h = t.internals.z ?? 0;
    return {
      x: d.x,
      y: d.y,
      z: h >= p ? h + 1 : p
    };
  }
  function AT(e, t, n, r = [0, 0]) {
    const o = [], i = /* @__PURE__ */ new Map();
    for (const a of e) {
      const s = t.get(a.parentId);
      if (!s)
        continue;
      const l = i.get(a.parentId)?.expandedRect ?? ff(s), u = nB(l, a.rect);
      i.set(a.parentId, { expandedRect: u, parent: s });
    }
    return i.size > 0 && i.forEach(({ expandedRect: a, parent: s }, l) => {
      const u = s.internals.positionAbsolute, d = Xa(s), p = s.origin ?? r, h = a.x < u.x ? Math.round(Math.abs(u.x - a.x)) : 0, g = a.y < u.y ? Math.round(Math.abs(u.y - a.y)) : 0, y = Math.max(d.width, Math.round(a.width)), b = Math.max(d.height, Math.round(a.height)), v = (y - d.width) * p[0], x = (b - d.height) * p[1];
      (h > 0 || g > 0 || v || x) && (o.push({
        id: l,
        type: "position",
        position: {
          x: s.position.x - h + v,
          y: s.position.y - g + x
        }
      }), n.get(l)?.forEach((E) => {
        e.some((_) => _.id === E.id) || o.push({
          id: E.id,
          type: "position",
          position: {
            x: E.position.x + h,
            y: E.position.y + g
          }
        });
      })), (d.width < a.width || d.height < a.height || h || g) && o.push({
        id: l,
        type: "dimensions",
        setAttributes: !0,
        dimensions: {
          width: y + (h ? p[0] * h - v : 0),
          height: b + (g ? p[1] * g - x : 0)
        }
      });
    }), o;
  }
  function lge(e, t, n, r, o, i) {
    const a = r?.querySelector(".xyflow__viewport");
    let s = !1;
    if (!a)
      return { changes: [], updatedInternals: s };
    const l = [], u = window.getComputedStyle(a), { m22: d } = new window.DOMMatrixReadOnly(u.transform), p = [];
    for (const h of e.values()) {
      const g = t.get(h.id);
      if (!g)
        continue;
      if (g.hidden) {
        t.set(g.id, {
          ...g,
          internals: {
            ...g.internals,
            handleBounds: void 0
          }
        }), s = !0;
        continue;
      }
      const y = CT(h.nodeElement), b = g.measured.width !== y.width || g.measured.height !== y.height;
      if (!!(y.width && y.height && (b || !g.internals.handleBounds || h.force))) {
        const x = h.nodeElement.getBoundingClientRect(), E = df(g.extent) ? g.extent : i;
        let { positionAbsolute: _ } = g.internals;
        g.parentId && g.extent === "parent" ? _ = eB(_, y, t.get(g.parentId)) : E && (_ = uc(_, E, y));
        const C = {
          ...g,
          measured: y,
          internals: {
            ...g.internals,
            positionAbsolute: _,
            handleBounds: {
              source: kI("source", h.nodeElement, x, d, g.id),
              target: kI("target", h.nodeElement, x, d, g.id)
            }
          }
        };
        t.set(g.id, C), g.parentId && OT(C, t, n, { nodeOrigin: o }), s = !0, b && (l.push({
          id: g.id,
          type: "dimensions",
          dimensions: y
        }), g.expandParent && g.parentId && p.push({
          id: g.id,
          parentId: g.parentId,
          rect: ff(C, o)
        }));
      }
    }
    if (p.length > 0) {
      const h = AT(p, t, n, o);
      l.push(...h);
    }
    return { changes: l, updatedInternals: s };
  }
  async function cge({ delta: e, panZoom: t, transform: n, translateExtent: r, width: o, height: i }) {
    if (!t || !e.x && !e.y)
      return Promise.resolve(!1);
    const a = await t.setViewportConstrained({
      x: n[0] + e.x,
      y: n[1] + e.y,
      zoom: n[2]
    }, [
      [0, 0],
      [o, i]
    ], r), s = !!a && (a.x !== n[0] || a.y !== n[1] || a.k !== n[2]);
    return Promise.resolve(s);
  }
  function PI(e, t, n, r, o, i) {
    let a = o;
    const s = r.get(a) || /* @__PURE__ */ new Map();
    r.set(a, s.set(n, t)), a = `${o}-${e}`;
    const l = r.get(a) || /* @__PURE__ */ new Map();
    if (r.set(a, l.set(n, t)), i) {
      a = `${o}-${e}-${i}`;
      const u = r.get(a) || /* @__PURE__ */ new Map();
      r.set(a, u.set(n, t));
    }
  }
  function dB(e, t, n) {
    e.clear(), t.clear();
    for (const r of n) {
      const { source: o, target: i, sourceHandle: a = null, targetHandle: s = null } = r, l = { edgeId: r.id, source: o, target: i, sourceHandle: a, targetHandle: s }, u = `${o}-${a}--${i}-${s}`, d = `${i}-${s}--${o}-${a}`;
      PI("source", l, d, e, o, a), PI("target", l, u, e, i, s), t.set(r.id, r);
    }
  }
  function pB(e, t) {
    if (!e.parentId)
      return !1;
    const n = t.get(e.parentId);
    return n ? n.selected ? !0 : pB(n, t) : !1;
  }
  function $I(e, t, n) {
    let r = e;
    do {
      if (r?.matches?.(t))
        return !0;
      if (r === n)
        return !1;
      r = r?.parentElement;
    } while (r);
    return !1;
  }
  function uge(e, t, n, r) {
    const o = /* @__PURE__ */ new Map();
    for (const [i, a] of e)
      if ((a.selected || a.id === r) && (!a.parentId || !pB(a, e)) && (a.draggable || t && typeof a.draggable > "u")) {
        const s = e.get(i);
        s && o.set(i, {
          id: i,
          position: s.position || { x: 0, y: 0 },
          distance: {
            x: n.x - s.internals.positionAbsolute.x,
            y: n.y - s.internals.positionAbsolute.y
          },
          extent: s.extent,
          parentId: s.parentId,
          origin: s.origin,
          expandParent: s.expandParent,
          internals: {
            positionAbsolute: s.internals.positionAbsolute || { x: 0, y: 0 }
          },
          measured: {
            width: s.measured.width ?? 0,
            height: s.measured.height ?? 0
          }
        });
      }
    return o;
  }
  function qS({ nodeId: e, dragItems: t, nodeLookup: n, dragging: r = !0 }) {
    const o = [];
    for (const [a, s] of t) {
      const l = n.get(a)?.internals.userNode;
      l && o.push({
        ...l,
        position: s.position,
        dragging: r
      });
    }
    if (!e)
      return [o[0], o];
    const i = n.get(e)?.internals.userNode;
    return [
      i ? {
        ...i,
        position: t.get(e)?.position || i.position,
        dragging: r
      } : o[0],
      o
    ];
  }
  function fge({ onNodeMouseDown: e, getStoreItems: t, onDragStart: n, onDrag: r, onDragStop: o }) {
    let i = { x: null, y: null }, a = 0, s = /* @__PURE__ */ new Map(), l = !1, u = { x: 0, y: 0 }, d = null, p = !1, h = null, g = !1, y = !1;
    function b({ noDragClassName: x, handleSelector: E, domNode: _, isSelectable: C, nodeId: k, nodeClickDistance: R = 0 }) {
      h = no(_);
      function A({ x: L, y: P }, B) {
        const { nodeLookup: j, nodeExtent: V, snapGrid: F, snapToGrid: G, nodeOrigin: W, onNodeDrag: K, onSelectionDrag: $, onError: U, updateNodePositions: X } = t();
        i = { x: L, y: P };
        let z = !1, H = { x: 0, y: 0, x2: 0, y2: 0 };
        if (s.size > 1 && V) {
          const Y = Zh(s);
          H = oC(Y);
        }
        for (const [Y, Q] of s) {
          if (!j.has(Y))
            continue;
          let re = { x: L - Q.distance.x, y: P - Q.distance.y };
          G && (re = Bb(re, F));
          let te = [
            [V[0][0], V[0][1]],
            [V[1][0], V[1][1]]
          ];
          if (s.size > 1 && V && !Q.extent) {
            const { positionAbsolute: J } = Q.internals, ee = J.x - H.x + V[0][0], ie = J.x + Q.measured.width - H.x2 + V[1][0], ae = J.y - H.y + V[0][1], ge = J.y + Q.measured.height - H.y2 + V[1][1];
            te = [
              [ee, ae],
              [ie, ge]
            ];
          }
          const { position: le, positionAbsolute: fe } = J9({
            nodeId: Y,
            nextPosition: re,
            nodeLookup: j,
            nodeExtent: te,
            nodeOrigin: W,
            onError: U
          });
          z = z || Q.position.x !== le.x || Q.position.y !== le.y, Q.position = le, Q.internals.positionAbsolute = fe;
        }
        if (y = y || z, !!z && (X(s, !0), B && (r || K || !k && $))) {
          const [Y, Q] = qS({
            nodeId: k,
            dragItems: s,
            nodeLookup: j
          });
          r?.(B, s, Y, Q), K?.(B, Y, Q), k || $?.(B, Q);
        }
      }
      async function M() {
        if (!d)
          return;
        const { transform: L, panBy: P, autoPanSpeed: B, autoPanOnNodeDrag: j } = t();
        if (!j) {
          l = !1, cancelAnimationFrame(a);
          return;
        }
        const [V, F] = tB(u, d, B);
        (V !== 0 || F !== 0) && (i.x = (i.x ?? 0) - V / L[2], i.y = (i.y ?? 0) - F / L[2], await P({ x: V, y: F }) && A(i, null)), a = requestAnimationFrame(M);
      }
      function I(L) {
        const { nodeLookup: P, multiSelectionActive: B, nodesDraggable: j, transform: V, snapGrid: F, snapToGrid: G, selectNodesOnDrag: W, onNodeDragStart: K, onSelectionDragStart: $, unselectNodesAndEdges: U } = t();
        p = !0, (!W || !C) && !B && k && (P.get(k)?.selected || U()), C && W && k && e?.(k);
        const X = Op(L.sourceEvent, { transform: V, snapGrid: F, snapToGrid: G, containerBounds: d });
        if (i = X, s = uge(P, j, X, k), s.size > 0 && (n || K || !k && $)) {
          const [z, H] = qS({
            nodeId: k,
            dragItems: s,
            nodeLookup: P
          });
          n?.(L.sourceEvent, s, z, H), K?.(L.sourceEvent, z, H), k || $?.(L.sourceEvent, H);
        }
      }
      const D = M9().clickDistance(R).on("start", (L) => {
        const { domNode: P, nodeDragThreshold: B, transform: j, snapGrid: V, snapToGrid: F } = t();
        d = P?.getBoundingClientRect() || null, g = !1, y = !1, B === 0 && I(L), i = Op(L.sourceEvent, { transform: j, snapGrid: V, snapToGrid: F, containerBounds: d }), u = Ni(L.sourceEvent, d);
      }).on("drag", (L) => {
        const { autoPanOnNodeDrag: P, transform: B, snapGrid: j, snapToGrid: V, nodeDragThreshold: F, nodeLookup: G } = t(), W = Op(L.sourceEvent, { transform: B, snapGrid: j, snapToGrid: V, containerBounds: d });
        if ((L.sourceEvent.type === "touchmove" && L.sourceEvent.touches.length > 1 || // if user deletes a node while dragging, we need to abort the drag to prevent errors
        k && !G.has(k)) && (g = !0), !g) {
          if (!l && P && p && (l = !0, M()), !p) {
            const K = W.xSnapped - (i.x ?? 0), $ = W.ySnapped - (i.y ?? 0);
            Math.sqrt(K * K + $ * $) > F && I(L);
          }
          (i.x !== W.xSnapped || i.y !== W.ySnapped) && s && p && (u = Ni(L.sourceEvent, d), A(W, L.sourceEvent));
        }
      }).on("end", (L) => {
        if (!(!p || g) && (l = !1, p = !1, cancelAnimationFrame(a), s.size > 0)) {
          const { nodeLookup: P, updateNodePositions: B, onNodeDragStop: j, onSelectionDragStop: V } = t();
          if (y && (B(s, !1), y = !1), o || j || !k && V) {
            const [F, G] = qS({
              nodeId: k,
              dragItems: s,
              nodeLookup: P,
              dragging: !1
            });
            o?.(L.sourceEvent, s, F, G), j?.(L.sourceEvent, F, G), k || V?.(L.sourceEvent, G);
          }
        }
      }).filter((L) => {
        const P = L.target;
        return !L.button && (!x || !$I(P, `.${x}`, _)) && (!E || $I(P, E, _));
      });
      h.call(D);
    }
    function v() {
      h?.on(".drag", null);
    }
    return {
      update: b,
      destroy: v
    };
  }
  function dge(e, t, n) {
    const r = [], o = {
      x: e.x - n,
      y: e.y - n,
      width: n * 2,
      height: n * 2
    };
    for (const i of t.values())
      ah(o, ff(i)) > 0 && r.push(i);
    return r;
  }
  const pge = 250;
  function hge(e, t, n, r) {
    let o = [], i = 1 / 0;
    const a = dge(e, n, t + pge);
    for (const s of a) {
      const l = [...s.internals.handleBounds?.source ?? [], ...s.internals.handleBounds?.target ?? []];
      for (const u of l) {
        if (r.nodeId === u.nodeId && r.type === u.type && r.id === u.id)
          continue;
        const { x: d, y: p } = sh(s, u, u.position, !0), h = Math.sqrt(Math.pow(d - e.x, 2) + Math.pow(p - e.y, 2));
        h > t || (h < i ? (o = [{ ...u, x: d, y: p }], i = h) : h === i && o.push({ ...u, x: d, y: p }));
      }
    }
    if (!o.length)
      return null;
    if (o.length > 1) {
      const s = r.type === "source" ? "target" : "source";
      return o.find((l) => l.type === s) ?? o[0];
    }
    return o[0];
  }
  function hB(e, t, n, r, o, i = !1) {
    const a = r.get(e);
    if (!a)
      return null;
    const s = o === "strict" ? a.internals.handleBounds?.[t] : [...a.internals.handleBounds?.source ?? [], ...a.internals.handleBounds?.target ?? []], l = (n ? s?.find((u) => u.id === n) : s?.[0]) ?? null;
    return l && i ? { ...l, ...sh(a, l, l.position, !0) } : l;
  }
  function mB(e, t) {
    return e || (t?.classList.contains("target") ? "target" : t?.classList.contains("source") ? "source" : null);
  }
  function mge(e, t) {
    let n = null;
    return t ? n = !0 : e && !t && (n = !1), n;
  }
  const gB = () => !0;
  function gge(e, { connectionMode: t, connectionRadius: n, handleId: r, nodeId: o, edgeUpdaterType: i, isTarget: a, domNode: s, nodeLookup: l, lib: u, autoPanOnConnect: d, flowId: p, panBy: h, cancelConnection: g, onConnectStart: y, onConnect: b, onConnectEnd: v, isValidConnection: x = gB, onReconnectEnd: E, updateConnection: _, getTransform: C, getFromHandle: k, autoPanSpeed: R, dragThreshold: A = 1 }) {
    const M = iB(e.target);
    let I = 0, D;
    const { x: L, y: P } = Ni(e), B = M?.elementFromPoint(L, P), j = mB(i, B), V = s?.getBoundingClientRect();
    let F = !1;
    if (!V || !j)
      return;
    const G = hB(o, j, r, l, t);
    if (!G)
      return;
    let W = Ni(e, V), K = !1, $ = null, U = !1, X = null;
    function z() {
      if (!d || !V)
        return;
      const [J, ee] = tB(W, V, R);
      h({ x: J, y: ee }), I = requestAnimationFrame(z);
    }
    const H = {
      ...G,
      nodeId: o,
      type: j,
      position: G.position
    }, Y = l.get(o);
    let re = {
      inProgress: !0,
      isValid: null,
      from: sh(Y, H, qe.Left, !0),
      fromHandle: H,
      fromPosition: H.position,
      fromNode: Y,
      to: W,
      toHandle: null,
      toPosition: SI[H.position],
      toNode: null
    };
    function te() {
      F = !0, _(re), y?.(e, { nodeId: o, handleId: r, handleType: j });
    }
    A === 0 && te();
    function le(J) {
      if (!F) {
        const { x: ge, y: Ce } = Ni(J), Ne = ge - L, Le = Ce - P;
        if (!(Ne * Ne + Le * Le > A * A))
          return;
        te();
      }
      if (!k() || !H) {
        fe(J);
        return;
      }
      const ee = C();
      W = Ni(J, V), D = hge(Qh(W, ee, !1, [1, 1]), n, l, H), K || (z(), K = !0);
      const ie = yB(J, {
        handle: D,
        connectionMode: t,
        fromNodeId: o,
        fromHandleId: r,
        fromType: a ? "target" : "source",
        isValidConnection: x,
        doc: M,
        lib: u,
        flowId: p,
        nodeLookup: l
      });
      X = ie.handleDomNode, $ = ie.connection, U = mge(!!D, ie.isValid);
      const ae = {
        // from stays the same
        ...re,
        isValid: U,
        to: ie.toHandle && U ? y0({ x: ie.toHandle.x, y: ie.toHandle.y }, ee) : W,
        toHandle: ie.toHandle,
        toPosition: U && ie.toHandle ? ie.toHandle.position : SI[H.position],
        toNode: ie.toHandle ? l.get(ie.toHandle.nodeId) : null
      };
      U && D && re.toHandle && ae.toHandle && re.toHandle.type === ae.toHandle.type && re.toHandle.nodeId === ae.toHandle.nodeId && re.toHandle.id === ae.toHandle.id && re.to.x === ae.to.x && re.to.y === ae.to.y || (_(ae), re = ae);
    }
    function fe(J) {
      if (F) {
        (D || X) && $ && U && b?.($);
        const { inProgress: ee, ...ie } = re, ae = {
          ...ie,
          toPosition: re.toHandle ? re.toPosition : null
        };
        v?.(J, ae), i && E?.(J, ae);
      }
      g(), cancelAnimationFrame(I), K = !1, U = !1, $ = null, X = null, M.removeEventListener("mousemove", le), M.removeEventListener("mouseup", fe), M.removeEventListener("touchmove", le), M.removeEventListener("touchend", fe);
    }
    M.addEventListener("mousemove", le), M.addEventListener("mouseup", fe), M.addEventListener("touchmove", le), M.addEventListener("touchend", fe);
  }
  function yB(e, { handle: t, connectionMode: n, fromNodeId: r, fromHandleId: o, fromType: i, doc: a, lib: s, flowId: l, isValidConnection: u = gB, nodeLookup: d }) {
    const p = i === "target", h = t ? a.querySelector(`.${s}-flow__handle[data-id="${l}-${t?.nodeId}-${t?.id}-${t?.type}"]`) : null, { x: g, y } = Ni(e), b = a.elementFromPoint(g, y), v = b?.classList.contains(`${s}-flow__handle`) ? b : h, x = {
      handleDomNode: v,
      isValid: !1,
      connection: null,
      toHandle: null
    };
    if (v) {
      const E = mB(void 0, v), _ = v.getAttribute("data-nodeid"), C = v.getAttribute("data-handleid"), k = v.classList.contains("connectable"), R = v.classList.contains("connectableend");
      if (!_ || !E)
        return x;
      const A = {
        source: p ? _ : r,
        sourceHandle: p ? C : o,
        target: p ? r : _,
        targetHandle: p ? o : C
      };
      x.connection = A;
      const I = k && R && (n === cf.Strict ? p && E === "source" || !p && E === "target" : _ !== r || C !== o);
      x.isValid = I && u(A), x.toHandle = hB(_, E, C, d, n, !0);
    }
    return x;
  }
  const lC = {
    onPointerDown: gge,
    isValid: yB
  };
  function yge({ domNode: e, panZoom: t, getTransform: n, getViewScale: r }) {
    const o = no(e);
    function i({ translateExtent: s, width: l, height: u, zoomStep: d = 10, pannable: p = !0, zoomable: h = !0, inversePan: g = !1 }) {
      const y = (_) => {
        const C = n();
        if (_.sourceEvent.type !== "wheel" || !t)
          return;
        const k = -_.sourceEvent.deltaY * (_.sourceEvent.deltaMode === 1 ? 0.05 : _.sourceEvent.deltaMode ? 1 : 2e-3) * d, R = C[2] * Math.pow(2, k);
        t.scaleTo(R);
      };
      let b = [0, 0];
      const v = (_) => {
        (_.sourceEvent.type === "mousedown" || _.sourceEvent.type === "touchstart") && (b = [
          _.sourceEvent.clientX ?? _.sourceEvent.touches[0].clientX,
          _.sourceEvent.clientY ?? _.sourceEvent.touches[0].clientY
        ]);
      }, x = (_) => {
        const C = n();
        if (_.sourceEvent.type !== "mousemove" && _.sourceEvent.type !== "touchmove" || !t)
          return;
        const k = [
          _.sourceEvent.clientX ?? _.sourceEvent.touches[0].clientX,
          _.sourceEvent.clientY ?? _.sourceEvent.touches[0].clientY
        ], R = [k[0] - b[0], k[1] - b[1]];
        b = k;
        const A = r() * Math.max(C[2], Math.log(C[2])) * (g ? -1 : 1), M = {
          x: C[0] - R[0] * A,
          y: C[1] - R[1] * A
        }, I = [
          [0, 0],
          [l, u]
        ];
        t.setViewportConstrained({
          x: M.x,
          y: M.y,
          zoom: C[2]
        }, I, s);
      }, E = G9().on("start", v).on("zoom", p ? x : null).on("zoom.wheel", h ? y : null);
      o.call(E, {});
    }
    function a() {
      o.on("zoom", null);
    }
    return {
      update: i,
      destroy: a,
      pointer: Bo
    };
  }
  const vge = (e, t) => e.x !== t.x || e.y !== t.y || e.zoom !== t.k, Ub = (e) => ({
    x: e.x,
    y: e.y,
    zoom: e.k
  }), WS = ({ x: e, y: t, zoom: n }) => Fb.translate(e, t).scale(n), Fu = (e, t) => e.target.closest(`.${t}`), vB = (e, t) => t === 2 && Array.isArray(e) && e.includes(2), bge = (e) => ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2, GS = (e, t = 0, n = bge, r = () => {
  }) => {
    const o = typeof t == "number" && t > 0;
    return o || r(), o ? e.transition().duration(t).ease(n).on("end", r) : e;
  }, bB = (e) => {
    const t = e.ctrlKey && v0() ? 10 : 1;
    return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * t;
  };
  function xge({ zoomPanValues: e, noWheelClassName: t, d3Selection: n, d3Zoom: r, panOnScrollMode: o, panOnScrollSpeed: i, zoomOnPinch: a, onPanZoomStart: s, onPanZoom: l, onPanZoomEnd: u }) {
    return (d) => {
      if (Fu(d, t))
        return !1;
      d.preventDefault(), d.stopImmediatePropagation();
      const p = n.property("__zoom").k || 1;
      if (d.ctrlKey && a) {
        const v = Bo(d), x = bB(d), E = p * Math.pow(2, x);
        r.scaleTo(n, E, v, d);
        return;
      }
      const h = d.deltaMode === 1 ? 20 : 1;
      let g = o === Jl.Vertical ? 0 : d.deltaX * h, y = o === Jl.Horizontal ? 0 : d.deltaY * h;
      !v0() && d.shiftKey && o !== Jl.Vertical && (g = d.deltaY * h, y = 0), r.translateBy(
        n,
        -(g / p) * i,
        -(y / p) * i,
        // @ts-ignore
        { internal: !0 }
      );
      const b = Ub(n.property("__zoom"));
      clearTimeout(e.panScrollTimeout), e.isPanScrolling || (e.isPanScrolling = !0, s?.(d, b)), e.isPanScrolling && (l?.(d, b), e.panScrollTimeout = setTimeout(() => {
        u?.(d, b), e.isPanScrolling = !1;
      }, 150));
    };
  }
  function wge({ noWheelClassName: e, preventScrolling: t, d3ZoomHandler: n }) {
    return function(r, o) {
      const i = r.type === "wheel", a = !t && i && !r.ctrlKey, s = Fu(r, e);
      if (r.ctrlKey && i && s && r.preventDefault(), a || s)
        return null;
      r.preventDefault(), n.call(this, r, o);
    };
  }
  function Sge({ zoomPanValues: e, onDraggingChange: t, onPanZoomStart: n }) {
    return (r) => {
      if (r.sourceEvent?.internal)
        return;
      const o = Ub(r.transform);
      e.mouseButton = r.sourceEvent?.button || 0, e.isZoomingOrPanning = !0, e.prevViewport = o, r.sourceEvent?.type === "mousedown" && t(!0), n && n?.(r.sourceEvent, o);
    };
  }
  function _ge({ zoomPanValues: e, panOnDrag: t, onPaneContextMenu: n, onTransformChange: r, onPanZoom: o }) {
    return (i) => {
      e.usedRightMouseButton = !!(n && vB(t, e.mouseButton ?? 0)), i.sourceEvent?.sync || r([i.transform.x, i.transform.y, i.transform.k]), o && !i.sourceEvent?.internal && o?.(i.sourceEvent, Ub(i.transform));
    };
  }
  function Ege({ zoomPanValues: e, panOnDrag: t, panOnScroll: n, onDraggingChange: r, onPanZoomEnd: o, onPaneContextMenu: i }) {
    return (a) => {
      if (!a.sourceEvent?.internal && (e.isZoomingOrPanning = !1, i && vB(t, e.mouseButton ?? 0) && !e.usedRightMouseButton && a.sourceEvent && i(a.sourceEvent), e.usedRightMouseButton = !1, r(!1), o && vge(e.prevViewport, a.transform))) {
        const s = Ub(a.transform);
        e.prevViewport = s, clearTimeout(e.timerId), e.timerId = setTimeout(
          () => {
            o?.(a.sourceEvent, s);
          },
          // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
          n ? 150 : 0
        );
      }
    };
  }
  function Cge({ zoomActivationKeyPressed: e, zoomOnScroll: t, zoomOnPinch: n, panOnDrag: r, panOnScroll: o, zoomOnDoubleClick: i, userSelectionActive: a, noWheelClassName: s, noPanClassName: l, lib: u }) {
    return (d) => {
      const p = e || t, h = n && d.ctrlKey;
      if (d.button === 1 && d.type === "mousedown" && (Fu(d, `${u}-flow__node`) || Fu(d, `${u}-flow__edge`)))
        return !0;
      if (!r && !p && !o && !i && !n || a || Fu(d, s) && d.type === "wheel" || Fu(d, l) && (d.type !== "wheel" || o && d.type === "wheel" && !e) || !n && d.ctrlKey && d.type === "wheel")
        return !1;
      if (!n && d.type === "touchstart" && d.touches?.length > 1)
        return d.preventDefault(), !1;
      if (!p && !o && !h && d.type === "wheel" || !r && (d.type === "mousedown" || d.type === "touchstart") || Array.isArray(r) && !r.includes(d.button) && d.type === "mousedown")
        return !1;
      const g = Array.isArray(r) && r.includes(d.button) || !d.button || d.button <= 1;
      return (!d.ctrlKey || d.type === "wheel") && g;
    };
  }
  function kge({ domNode: e, minZoom: t, maxZoom: n, paneClickDistance: r, translateExtent: o, viewport: i, onPanZoom: a, onPanZoomStart: s, onPanZoomEnd: l, onDraggingChange: u }) {
    const d = {
      isZoomingOrPanning: !1,
      usedRightMouseButton: !1,
      prevViewport: { x: 0, y: 0, zoom: 0 },
      mouseButton: 0,
      timerId: void 0,
      panScrollTimeout: void 0,
      isPanScrolling: !1
    }, p = e.getBoundingClientRect(), h = G9().clickDistance(!qo(r) || r < 0 ? 0 : r).scaleExtent([t, n]).translateExtent(o), g = no(e).call(h);
    _({
      x: i.x,
      y: i.y,
      zoom: uf(i.zoom, t, n)
    }, [
      [0, 0],
      [p.width, p.height]
    ], o);
    const y = g.on("wheel.zoom"), b = g.on("dblclick.zoom");
    h.wheelDelta(bB);
    function v(P, B) {
      return g ? new Promise((j) => {
        h?.interpolate(B?.interpolate === "linear" ? Rp : Ev).transform(GS(g, B?.duration, B?.ease, () => j(!0)), P);
      }) : Promise.resolve(!1);
    }
    function x({ noWheelClassName: P, noPanClassName: B, onPaneContextMenu: j, userSelectionActive: V, panOnScroll: F, panOnDrag: G, panOnScrollMode: W, panOnScrollSpeed: K, preventScrolling: $, zoomOnPinch: U, zoomOnScroll: X, zoomOnDoubleClick: z, zoomActivationKeyPressed: H, lib: Y, onTransformChange: Q }) {
      V && !d.isZoomingOrPanning && E();
      const te = F && !H && !V ? xge({
        zoomPanValues: d,
        noWheelClassName: P,
        d3Selection: g,
        d3Zoom: h,
        panOnScrollMode: W,
        panOnScrollSpeed: K,
        zoomOnPinch: U,
        onPanZoomStart: s,
        onPanZoom: a,
        onPanZoomEnd: l
      }) : wge({
        noWheelClassName: P,
        preventScrolling: $,
        d3ZoomHandler: y
      });
      if (g.on("wheel.zoom", te, { passive: !1 }), !V) {
        const fe = Sge({
          zoomPanValues: d,
          onDraggingChange: u,
          onPanZoomStart: s
        });
        h.on("start", fe);
        const J = _ge({
          zoomPanValues: d,
          panOnDrag: G,
          onPaneContextMenu: !!j,
          onPanZoom: a,
          onTransformChange: Q
        });
        h.on("zoom", J);
        const ee = Ege({
          zoomPanValues: d,
          panOnDrag: G,
          panOnScroll: F,
          onPaneContextMenu: j,
          onPanZoomEnd: l,
          onDraggingChange: u
        });
        h.on("end", ee);
      }
      const le = Cge({
        zoomActivationKeyPressed: H,
        panOnDrag: G,
        zoomOnScroll: X,
        panOnScroll: F,
        zoomOnDoubleClick: z,
        zoomOnPinch: U,
        userSelectionActive: V,
        noPanClassName: B,
        noWheelClassName: P,
        lib: Y
      });
      h.filter(le), z ? g.on("dblclick.zoom", b) : g.on("dblclick.zoom", null);
    }
    function E() {
      h.on("zoom", null);
    }
    async function _(P, B, j) {
      const V = WS(P), F = h?.constrain()(V, B, j);
      return F && await v(F), new Promise((G) => G(F));
    }
    async function C(P, B) {
      const j = WS(P);
      return await v(j, B), new Promise((V) => V(j));
    }
    function k(P) {
      if (g) {
        const B = WS(P), j = g.property("__zoom");
        (j.k !== P.zoom || j.x !== P.x || j.y !== P.y) && h?.transform(g, B, null, { sync: !0 });
      }
    }
    function R() {
      const P = g ? W9(g.node()) : { x: 0, y: 0, k: 1 };
      return { x: P.x, y: P.y, zoom: P.k };
    }
    function A(P, B) {
      return g ? new Promise((j) => {
        h?.interpolate(B?.interpolate === "linear" ? Rp : Ev).scaleTo(GS(g, B?.duration, B?.ease, () => j(!0)), P);
      }) : Promise.resolve(!1);
    }
    function M(P, B) {
      return g ? new Promise((j) => {
        h?.interpolate(B?.interpolate === "linear" ? Rp : Ev).scaleBy(GS(g, B?.duration, B?.ease, () => j(!0)), P);
      }) : Promise.resolve(!1);
    }
    function I(P) {
      h?.scaleExtent(P);
    }
    function D(P) {
      h?.translateExtent(P);
    }
    function L(P) {
      const B = !qo(P) || P < 0 ? 0 : P;
      h?.clickDistance(B);
    }
    return {
      update: x,
      destroy: E,
      setViewport: C,
      setViewportConstrained: _,
      getViewport: R,
      scaleTo: A,
      scaleBy: M,
      setScaleExtent: I,
      setTranslateExtent: D,
      syncViewport: k,
      setClickDistance: L
    };
  }
  var pf;
  (function(e) {
    e.Line = "line", e.Handle = "handle";
  })(pf || (pf = {}));
  function Tge({ width: e, prevWidth: t, height: n, prevHeight: r, affectsX: o, affectsY: i }) {
    const a = e - t, s = n - r, l = [a > 0 ? 1 : a < 0 ? -1 : 0, s > 0 ? 1 : s < 0 ? -1 : 0];
    return a && o && (l[0] = l[0] * -1), s && i && (l[1] = l[1] * -1), l;
  }
  function Rge(e) {
    const t = e.includes("right") || e.includes("left"), n = e.includes("bottom") || e.includes("top"), r = e.includes("left"), o = e.includes("top");
    return {
      isHorizontal: t,
      isVertical: n,
      affectsX: r,
      affectsY: o
    };
  }
  function As(e, t) {
    return Math.max(0, t - e);
  }
  function Ns(e, t) {
    return Math.max(0, e - t);
  }
  function iy(e, t, n) {
    return Math.max(0, t - e, e - n);
  }
  function II(e, t) {
    return e ? !t : t;
  }
  function Oge(e, t, n, r, o, i, a, s) {
    let { affectsX: l, affectsY: u } = t;
    const { isHorizontal: d, isVertical: p } = t, h = d && p, { xSnapped: g, ySnapped: y } = n, { minWidth: b, maxWidth: v, minHeight: x, maxHeight: E } = r, { x: _, y: C, width: k, height: R, aspectRatio: A } = e;
    let M = Math.floor(d ? g - e.pointerX : 0), I = Math.floor(p ? y - e.pointerY : 0);
    const D = k + (l ? -M : M), L = R + (u ? -I : I), P = -i[0] * k, B = -i[1] * R;
    let j = iy(D, b, v), V = iy(L, x, E);
    if (a) {
      let W = 0, K = 0;
      l && M < 0 ? W = As(_ + M + P, a[0][0]) : !l && M > 0 && (W = Ns(_ + D + P, a[1][0])), u && I < 0 ? K = As(C + I + B, a[0][1]) : !u && I > 0 && (K = Ns(C + L + B, a[1][1])), j = Math.max(j, W), V = Math.max(V, K);
    }
    if (s) {
      let W = 0, K = 0;
      l && M > 0 ? W = Ns(_ + M, s[0][0]) : !l && M < 0 && (W = As(_ + D, s[1][0])), u && I > 0 ? K = Ns(C + I, s[0][1]) : !u && I < 0 && (K = As(C + L, s[1][1])), j = Math.max(j, W), V = Math.max(V, K);
    }
    if (o) {
      if (d) {
        const W = iy(D / A, x, E) * A;
        if (j = Math.max(j, W), a) {
          let K = 0;
          !l && !u || l && !u && h ? K = Ns(C + B + D / A, a[1][1]) * A : K = As(C + B + (l ? M : -M) / A, a[0][1]) * A, j = Math.max(j, K);
        }
        if (s) {
          let K = 0;
          !l && !u || l && !u && h ? K = As(C + D / A, s[1][1]) * A : K = Ns(C + (l ? M : -M) / A, s[0][1]) * A, j = Math.max(j, K);
        }
      }
      if (p) {
        const W = iy(L * A, b, v) / A;
        if (V = Math.max(V, W), a) {
          let K = 0;
          !l && !u || u && !l && h ? K = Ns(_ + L * A + P, a[1][0]) / A : K = As(_ + (u ? I : -I) * A + P, a[0][0]) / A, V = Math.max(V, K);
        }
        if (s) {
          let K = 0;
          !l && !u || u && !l && h ? K = As(_ + L * A, s[1][0]) / A : K = Ns(_ + (u ? I : -I) * A, s[0][0]) / A, V = Math.max(V, K);
        }
      }
    }
    I = I + (I < 0 ? V : -V), M = M + (M < 0 ? j : -j), o && (h ? D > L * A ? I = (II(l, u) ? -M : M) / A : M = (II(l, u) ? -I : I) * A : d ? (I = M / A, u = l) : (M = I * A, l = u));
    const F = l ? _ + M : _, G = u ? C + I : C;
    return {
      width: k + (l ? -M : M),
      height: R + (u ? -I : I),
      x: i[0] * M * (l ? -1 : 1) + F,
      y: i[1] * I * (u ? -1 : 1) + G
    };
  }
  const xB = { width: 0, height: 0, x: 0, y: 0 }, Age = {
    ...xB,
    pointerX: 0,
    pointerY: 0,
    aspectRatio: 1
  };
  function Nge(e) {
    return [
      [0, 0],
      [e.measured.width, e.measured.height]
    ];
  }
  function Mge(e, t, n) {
    const r = t.position.x + e.position.x, o = t.position.y + e.position.y, i = e.measured.width ?? 0, a = e.measured.height ?? 0, s = n[0] * i, l = n[1] * a;
    return [
      [r - s, o - l],
      [r + i - s, o + a - l]
    ];
  }
  function Pge({ domNode: e, nodeId: t, getStoreItems: n, onChange: r, onEnd: o }) {
    const i = no(e);
    function a({ controlPosition: l, boundaries: u, keepAspectRatio: d, resizeDirection: p, onResizeStart: h, onResize: g, onResizeEnd: y, shouldResize: b }) {
      let v = { ...xB }, x = { ...Age };
      const E = Rge(l);
      let _, C = null, k = [], R, A, M;
      const I = M9().on("start", (D) => {
        const { nodeLookup: L, transform: P, snapGrid: B, snapToGrid: j, nodeOrigin: V, paneDomNode: F } = n();
        if (_ = L.get(t), !_)
          return;
        C = F?.getBoundingClientRect() ?? null;
        const { xSnapped: G, ySnapped: W } = Op(D.sourceEvent, {
          transform: P,
          snapGrid: B,
          snapToGrid: j,
          containerBounds: C
        });
        v = {
          width: _.measured.width ?? 0,
          height: _.measured.height ?? 0,
          x: _.position.x ?? 0,
          y: _.position.y ?? 0
        }, x = {
          ...v,
          pointerX: G,
          pointerY: W,
          aspectRatio: v.width / v.height
        }, R = void 0, _.parentId && (_.extent === "parent" || _.expandParent) && (R = L.get(_.parentId), A = R && _.extent === "parent" ? Nge(R) : void 0), k = [], M = void 0;
        for (const [K, $] of L)
          if ($.parentId === t && (k.push({
            id: K,
            position: { ...$.position },
            extent: $.extent
          }), $.extent === "parent" || $.expandParent)) {
            const U = Mge($, _, $.origin ?? V);
            M ? M = [
              [Math.min(U[0][0], M[0][0]), Math.min(U[0][1], M[0][1])],
              [Math.max(U[1][0], M[1][0]), Math.max(U[1][1], M[1][1])]
            ] : M = U;
          }
        h?.(D, { ...v });
      }).on("drag", (D) => {
        const { transform: L, snapGrid: P, snapToGrid: B, nodeOrigin: j } = n(), V = Op(D.sourceEvent, {
          transform: L,
          snapGrid: P,
          snapToGrid: B,
          containerBounds: C
        }), F = [];
        if (!_)
          return;
        const { x: G, y: W, width: K, height: $ } = v, U = {}, X = _.origin ?? j, { width: z, height: H, x: Y, y: Q } = Oge(x, E, V, u, d, X, A, M), re = z !== K, te = H !== $, le = Y !== G && re, fe = Q !== W && te;
        if (!le && !fe && !re && !te)
          return;
        if ((le || fe || X[0] === 1 || X[1] === 1) && (U.x = le ? Y : v.x, U.y = fe ? Q : v.y, v.x = U.x, v.y = U.y, k.length > 0)) {
          const ae = Y - G, ge = Q - W;
          for (const Ce of k)
            Ce.position = {
              x: Ce.position.x - ae + X[0] * (z - K),
              y: Ce.position.y - ge + X[1] * (H - $)
            }, F.push(Ce);
        }
        if ((re || te) && (U.width = re && (!p || p === "horizontal") ? z : v.width, U.height = te && (!p || p === "vertical") ? H : v.height, v.width = U.width, v.height = U.height), R && _.expandParent) {
          const ae = X[0] * (U.width ?? 0);
          U.x && U.x < ae && (v.x = ae, x.x = x.x - (U.x - ae));
          const ge = X[1] * (U.height ?? 0);
          U.y && U.y < ge && (v.y = ge, x.y = x.y - (U.y - ge));
        }
        const J = Tge({
          width: v.width,
          prevWidth: K,
          height: v.height,
          prevHeight: $,
          affectsX: E.affectsX,
          affectsY: E.affectsY
        }), ee = { ...v, direction: J };
        b?.(D, ee) !== !1 && (g?.(D, ee), r(U, F));
      }).on("end", (D) => {
        y?.(D, { ...v }), o?.({ ...v });
      });
      i.call(I);
    }
    function s() {
      i.on(".drag", null);
    }
    return {
      update: a,
      destroy: s
    };
  }
  const { useDebugValue: $ge } = Tn, { useSyncExternalStoreWithSelector: Ige } = L6, jge = (e) => e;
  function wB(e, t = jge, n) {
    const r = Ige(
      e.subscribe,
      e.getState,
      e.getServerState || e.getInitialState,
      t,
      n
    );
    return $ge(r), r;
  }
  const jI = (e, t) => {
    const n = F6(e), r = (o, i = t) => wB(n, o, i);
    return Object.assign(r, n), r;
  }, Dge = (e, t) => e ? jI(e, t) : jI;
  function xn(e, t) {
    if (Object.is(e, t))
      return !0;
    if (typeof e != "object" || e === null || typeof t != "object" || t === null)
      return !1;
    if (e instanceof Map && t instanceof Map) {
      if (e.size !== t.size) return !1;
      for (const [r, o] of e)
        if (!Object.is(o, t.get(r)))
          return !1;
      return !0;
    }
    if (e instanceof Set && t instanceof Set) {
      if (e.size !== t.size) return !1;
      for (const r of e)
        if (!t.has(r))
          return !1;
      return !0;
    }
    const n = Object.keys(e);
    if (n.length !== Object.keys(t).length)
      return !1;
    for (const r of n)
      if (!Object.prototype.hasOwnProperty.call(t, r) || !Object.is(e[r], t[r]))
        return !1;
    return !0;
  }
  const Vb = T.createContext(null), Fge = Vb.Provider, SB = qi.error001();
  function Mt(e, t) {
    const n = T.useContext(Vb);
    if (n === null)
      throw new Error(SB);
    return wB(n, e, t);
  }
  function vn() {
    const e = T.useContext(Vb);
    if (e === null)
      throw new Error(SB);
    return T.useMemo(() => ({
      getState: e.getState,
      setState: e.setState,
      subscribe: e.subscribe
    }), [e]);
  }
  const DI = { display: "none" }, Lge = {
    position: "absolute",
    width: 1,
    height: 1,
    margin: -1,
    border: 0,
    padding: 0,
    overflow: "hidden",
    clip: "rect(0px, 0px, 0px, 0px)",
    clipPath: "inset(100%)"
  }, _B = "react-flow__node-desc", EB = "react-flow__edge-desc", zge = "react-flow__aria-live", Bge = (e) => e.ariaLiveMessage, Uge = (e) => e.ariaLabelConfig;
  function Vge({ rfId: e }) {
    const t = Mt(Bge);
    return S.jsx("div", { id: `${zge}-${e}`, "aria-live": "assertive", "aria-atomic": "true", style: Lge, children: t });
  }
  function Hge({ rfId: e, disableKeyboardA11y: t }) {
    const n = Mt(Uge);
    return S.jsxs(S.Fragment, { children: [S.jsx("div", { id: `${_B}-${e}`, style: DI, children: t ? n["node.a11yDescription.default"] : n["node.a11yDescription.keyboardDisabled"] }), S.jsx("div", { id: `${EB}-${e}`, style: DI, children: n["edge.a11yDescription.default"] }), !t && S.jsx(Vge, { rfId: e })] });
  }
  const Hb = T.forwardRef(({ position: e = "top-left", children: t, className: n, style: r, ...o }, i) => {
    const a = `${e}`.split("-");
    return S.jsx("div", { className: Vn(["react-flow__panel", n, ...a]), style: r, ref: i, ...o, children: t });
  });
  Hb.displayName = "Panel";
  function qge({ proOptions: e, position: t = "bottom-right" }) {
    return e?.hideAttribution ? null : S.jsx(Hb, { position: t, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev", children: S.jsx("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution", children: "React Flow" }) });
  }
  const Wge = (e) => {
    const t = [], n = [];
    for (const [, r] of e.nodeLookup)
      r.selected && t.push(r.internals.userNode);
    for (const [, r] of e.edgeLookup)
      r.selected && n.push(r);
    return { selectedNodes: t, selectedEdges: n };
  }, ay = (e) => e.id;
  function Gge(e, t) {
    return xn(e.selectedNodes.map(ay), t.selectedNodes.map(ay)) && xn(e.selectedEdges.map(ay), t.selectedEdges.map(ay));
  }
  function Kge({ onSelectionChange: e }) {
    const t = vn(), { selectedNodes: n, selectedEdges: r } = Mt(Wge, Gge);
    return T.useEffect(() => {
      const o = { nodes: n, edges: r };
      e?.(o), t.getState().onSelectionChangeHandlers.forEach((i) => i(o));
    }, [n, r, e]), null;
  }
  const Yge = (e) => !!e.onSelectionChangeHandlers;
  function Xge({ onSelectionChange: e }) {
    const t = Mt(Yge);
    return e || t ? S.jsx(Kge, { onSelectionChange: e }) : null;
  }
  const CB = [0, 0], Zge = { x: 0, y: 0, zoom: 1 }, Qge = [
    "nodes",
    "edges",
    "defaultNodes",
    "defaultEdges",
    "onConnect",
    "onConnectStart",
    "onConnectEnd",
    "onClickConnectStart",
    "onClickConnectEnd",
    "nodesDraggable",
    "autoPanOnNodeFocus",
    "nodesConnectable",
    "nodesFocusable",
    "edgesFocusable",
    "edgesReconnectable",
    "elevateNodesOnSelect",
    "elevateEdgesOnSelect",
    "minZoom",
    "maxZoom",
    "nodeExtent",
    "onNodesChange",
    "onEdgesChange",
    "elementsSelectable",
    "connectionMode",
    "snapGrid",
    "snapToGrid",
    "translateExtent",
    "connectOnClick",
    "defaultEdgeOptions",
    "fitView",
    "fitViewOptions",
    "onNodesDelete",
    "onEdgesDelete",
    "onDelete",
    "onNodeDrag",
    "onNodeDragStart",
    "onNodeDragStop",
    "onSelectionDrag",
    "onSelectionDragStart",
    "onSelectionDragStop",
    "onMoveStart",
    "onMove",
    "onMoveEnd",
    "noPanClassName",
    "nodeOrigin",
    "autoPanOnConnect",
    "autoPanOnNodeDrag",
    "onError",
    "connectionRadius",
    "isValidConnection",
    "selectNodesOnDrag",
    "nodeDragThreshold",
    "connectionDragThreshold",
    "onBeforeDelete",
    "debug",
    "autoPanSpeed",
    "paneClickDistance",
    "ariaLabelConfig"
  ], FI = [...Qge, "rfId"], Jge = (e) => ({
    setNodes: e.setNodes,
    setEdges: e.setEdges,
    setMinZoom: e.setMinZoom,
    setMaxZoom: e.setMaxZoom,
    setTranslateExtent: e.setTranslateExtent,
    setNodeExtent: e.setNodeExtent,
    reset: e.reset,
    setDefaultNodesAndEdges: e.setDefaultNodesAndEdges,
    setPaneClickDistance: e.setPaneClickDistance
  }), LI = {
    /*
     * these are values that are also passed directly to other components
     * than the StoreUpdater. We can reduce the number of setStore calls
     * by setting the same values here as prev fields.
     */
    translateExtent: oh,
    nodeOrigin: CB,
    minZoom: 0.5,
    maxZoom: 2,
    elementsSelectable: !0,
    noPanClassName: "nopan",
    rfId: "1",
    paneClickDistance: 0
  };
  function eye(e) {
    const { setNodes: t, setEdges: n, setMinZoom: r, setMaxZoom: o, setTranslateExtent: i, setNodeExtent: a, reset: s, setDefaultNodesAndEdges: l, setPaneClickDistance: u } = Mt(Jge, xn), d = vn();
    T.useEffect(() => (l(e.defaultNodes, e.defaultEdges), () => {
      p.current = LI, s();
    }), []);
    const p = T.useRef(LI);
    return T.useEffect(
      () => {
        for (const h of FI) {
          const g = e[h], y = p.current[h];
          g !== y && (typeof e[h] > "u" || (h === "nodes" ? t(g) : h === "edges" ? n(g) : h === "minZoom" ? r(g) : h === "maxZoom" ? o(g) : h === "translateExtent" ? i(g) : h === "nodeExtent" ? a(g) : h === "paneClickDistance" ? u(g) : h === "ariaLabelConfig" ? d.setState({ ariaLabelConfig: Wme(g) }) : h === "fitView" ? d.setState({ fitViewQueued: g }) : h === "fitViewOptions" ? d.setState({ fitViewOptions: g }) : d.setState({ [h]: g })));
        }
        p.current = e;
      },
      // Only re-run the effect if one of the fields we track changes
      FI.map((h) => e[h])
    ), null;
  }
  function zI() {
    return typeof window > "u" || !window.matchMedia ? null : window.matchMedia("(prefers-color-scheme: dark)");
  }
  function tye(e) {
    const [t, n] = T.useState(e === "system" ? null : e);
    return T.useEffect(() => {
      if (e !== "system") {
        n(e);
        return;
      }
      const r = zI(), o = () => n(r?.matches ? "dark" : "light");
      return o(), r?.addEventListener("change", o), () => {
        r?.removeEventListener("change", o);
      };
    }, [e]), t !== null ? t : zI()?.matches ? "dark" : "light";
  }
  const BI = typeof document < "u" ? document : null;
  function Na(e = null, t = { target: BI, actInsideInputWithModifier: !0 }) {
    const [n, r] = T.useState(!1), o = T.useRef(!1), i = T.useRef(/* @__PURE__ */ new Set([])), [a, s] = T.useMemo(() => {
      if (e !== null) {
        const u = (Array.isArray(e) ? e : [e]).filter((p) => typeof p == "string").map((p) => p.replace("+", `
`).replace(`

`, `
+`).split(`
`)), d = u.reduce((p, h) => p.concat(...h), []);
        return [u, d];
      }
      return [[], []];
    }, [e]);
    return T.useEffect(() => {
      const l = t?.target ?? BI, u = t?.actInsideInputWithModifier ?? !0;
      if (e !== null) {
        const d = (g) => {
          if (o.current = g.ctrlKey || g.metaKey || g.shiftKey || g.altKey, (!o.current || o.current && !u) && aB(g))
            return !1;
          const b = VI(g.code, s);
          if (i.current.add(g[b]), UI(a, i.current, !1)) {
            const v = g.composedPath?.()?.[0] || g.target, x = v?.nodeName === "BUTTON" || v?.nodeName === "A";
            t.preventDefault !== !1 && (o.current || !x) && g.preventDefault(), r(!0);
          }
        }, p = (g) => {
          const y = VI(g.code, s);
          UI(a, i.current, !0) ? (r(!1), i.current.clear()) : i.current.delete(g[y]), g.key === "Meta" && i.current.clear(), o.current = !1;
        }, h = () => {
          i.current.clear(), r(!1);
        };
        return l?.addEventListener("keydown", d), l?.addEventListener("keyup", p), window.addEventListener("blur", h), window.addEventListener("contextmenu", h), () => {
          l?.removeEventListener("keydown", d), l?.removeEventListener("keyup", p), window.removeEventListener("blur", h), window.removeEventListener("contextmenu", h);
        };
      }
    }, [e, r]), n;
  }
  function UI(e, t, n) {
    return e.filter((r) => n || r.length === t.size).some((r) => r.every((o) => t.has(o)));
  }
  function VI(e, t) {
    return t.includes(e) ? "code" : "key";
  }
  const nye = () => {
    const e = vn();
    return T.useMemo(() => ({
      zoomIn: (t) => {
        const { panZoom: n } = e.getState();
        return n ? n.scaleBy(1.2, { duration: t?.duration }) : Promise.resolve(!1);
      },
      zoomOut: (t) => {
        const { panZoom: n } = e.getState();
        return n ? n.scaleBy(1 / 1.2, { duration: t?.duration }) : Promise.resolve(!1);
      },
      zoomTo: (t, n) => {
        const { panZoom: r } = e.getState();
        return r ? r.scaleTo(t, { duration: n?.duration }) : Promise.resolve(!1);
      },
      getZoom: () => e.getState().transform[2],
      setViewport: async (t, n) => {
        const { transform: [r, o, i], panZoom: a } = e.getState();
        return a ? (await a.setViewport({
          x: t.x ?? r,
          y: t.y ?? o,
          zoom: t.zoom ?? i
        }, n), Promise.resolve(!0)) : Promise.resolve(!1);
      },
      getViewport: () => {
        const [t, n, r] = e.getState().transform;
        return { x: t, y: n, zoom: r };
      },
      setCenter: async (t, n, r) => e.getState().setCenter(t, n, r),
      fitBounds: async (t, n) => {
        const { width: r, height: o, minZoom: i, maxZoom: a, panZoom: s } = e.getState(), l = ET(t, r, o, i, a, n?.padding ?? 0.1);
        return s ? (await s.setViewport(l, {
          duration: n?.duration,
          ease: n?.ease,
          interpolate: n?.interpolate
        }), Promise.resolve(!0)) : Promise.resolve(!1);
      },
      screenToFlowPosition: (t, n = {}) => {
        const { transform: r, snapGrid: o, snapToGrid: i, domNode: a } = e.getState();
        if (!a)
          return t;
        const { x: s, y: l } = a.getBoundingClientRect(), u = {
          x: t.x - s,
          y: t.y - l
        }, d = n.snapGrid ?? o, p = n.snapToGrid ?? i;
        return Qh(u, r, p, d);
      },
      flowToScreenPosition: (t) => {
        const { transform: n, domNode: r } = e.getState();
        if (!r)
          return t;
        const { x: o, y: i } = r.getBoundingClientRect(), a = y0(t, n);
        return {
          x: a.x + o,
          y: a.y + i
        };
      }
    }), []);
  };
  function kB(e, t) {
    const n = [], r = /* @__PURE__ */ new Map(), o = [];
    for (const i of e)
      if (i.type === "add") {
        o.push(i);
        continue;
      } else if (i.type === "remove" || i.type === "replace")
        r.set(i.id, [i]);
      else {
        const a = r.get(i.id);
        a ? a.push(i) : r.set(i.id, [i]);
      }
    for (const i of t) {
      const a = r.get(i.id);
      if (!a) {
        n.push(i);
        continue;
      }
      if (a[0].type === "remove")
        continue;
      if (a[0].type === "replace") {
        n.push({ ...a[0].item });
        continue;
      }
      const s = { ...i };
      for (const l of a)
        rye(l, s);
      n.push(s);
    }
    return o.length && o.forEach((i) => {
      i.index !== void 0 ? n.splice(i.index, 0, { ...i.item }) : n.push({ ...i.item });
    }), n;
  }
  function rye(e, t) {
    switch (e.type) {
      case "select": {
        t.selected = e.selected;
        break;
      }
      case "position": {
        typeof e.position < "u" && (t.position = e.position), typeof e.dragging < "u" && (t.dragging = e.dragging);
        break;
      }
      case "dimensions": {
        typeof e.dimensions < "u" && (t.measured ?? (t.measured = {}), t.measured.width = e.dimensions.width, t.measured.height = e.dimensions.height, e.setAttributes && ((e.setAttributes === !0 || e.setAttributes === "width") && (t.width = e.dimensions.width), (e.setAttributes === !0 || e.setAttributes === "height") && (t.height = e.dimensions.height))), typeof e.resizing == "boolean" && (t.resizing = e.resizing);
        break;
      }
    }
  }
  function NT(e, t) {
    return kB(e, t);
  }
  function TB(e, t) {
    return kB(e, t);
  }
  function Vl(e, t) {
    return {
      id: e,
      type: "select",
      selected: t
    };
  }
  function Lu(e, t = /* @__PURE__ */ new Set(), n = !1) {
    const r = [];
    for (const [o, i] of e) {
      const a = t.has(o);
      !(i.selected === void 0 && !a) && i.selected !== a && (n && (i.selected = a), r.push(Vl(i.id, a)));
    }
    return r;
  }
  function HI({ items: e = [], lookup: t }) {
    const n = [], r = new Map(e.map((o) => [o.id, o]));
    for (const [o, i] of e.entries()) {
      const a = t.get(i.id), s = a?.internals?.userNode ?? a;
      s !== void 0 && s !== i && n.push({ id: i.id, item: i, type: "replace" }), s === void 0 && n.push({ item: i, type: "add", index: o });
    }
    for (const [o] of t)
      r.get(o) === void 0 && n.push({ id: o, type: "remove" });
    return n;
  }
  function qI(e) {
    return {
      id: e.id,
      type: "remove"
    };
  }
  const WI = (e) => jme(e), oye = (e) => Q9(e);
  function RB(e) {
    return T.forwardRef(e);
  }
  const iye = typeof window < "u" ? T.useLayoutEffect : T.useEffect;
  function GI(e) {
    const [t, n] = T.useState(BigInt(0)), [r] = T.useState(() => aye(() => n((o) => o + BigInt(1))));
    return iye(() => {
      const o = r.get();
      o.length && (e(o), r.reset());
    }, [t]), r;
  }
  function aye(e) {
    let t = [];
    return {
      get: () => t,
      reset: () => {
        t = [];
      },
      push: (n) => {
        t.push(n), e();
      }
    };
  }
  const OB = T.createContext(null);
  function sye({ children: e }) {
    const t = vn(), n = T.useCallback((s) => {
      const { nodes: l = [], setNodes: u, hasDefaultNodes: d, onNodesChange: p, nodeLookup: h, fitViewQueued: g } = t.getState();
      let y = l;
      for (const v of s)
        y = typeof v == "function" ? v(y) : v;
      const b = HI({
        items: y,
        lookup: h
      });
      d && u(y), b.length > 0 ? p?.(b) : g && window.requestAnimationFrame(() => {
        const { fitViewQueued: v, nodes: x, setNodes: E } = t.getState();
        v && E(x);
      });
    }, []), r = GI(n), o = T.useCallback((s) => {
      const { edges: l = [], setEdges: u, hasDefaultEdges: d, onEdgesChange: p, edgeLookup: h } = t.getState();
      let g = l;
      for (const y of s)
        g = typeof y == "function" ? y(g) : y;
      d ? u(g) : p && p(HI({
        items: g,
        lookup: h
      }));
    }, []), i = GI(o), a = T.useMemo(() => ({ nodeQueue: r, edgeQueue: i }), []);
    return S.jsx(OB.Provider, { value: a, children: e });
  }
  function lye() {
    const e = T.useContext(OB);
    if (!e)
      throw new Error("useBatchContext must be used within a BatchProvider");
    return e;
  }
  const cye = (e) => !!e.panZoom;
  function yc() {
    const e = nye(), t = vn(), n = lye(), r = Mt(cye), o = T.useMemo(() => {
      const i = (p) => t.getState().nodeLookup.get(p), a = (p) => {
        n.nodeQueue.push(p);
      }, s = (p) => {
        n.edgeQueue.push(p);
      }, l = (p) => {
        const { nodeLookup: h, nodeOrigin: g } = t.getState(), y = WI(p) ? p : h.get(p.id), b = y.parentId ? oB(y.position, y.measured, y.parentId, h, g) : y.position, v = {
          ...y,
          position: b,
          width: y.measured?.width ?? y.width,
          height: y.measured?.height ?? y.height
        };
        return ff(v);
      }, u = (p, h, g = { replace: !1 }) => {
        a((y) => y.map((b) => {
          if (b.id === p) {
            const v = typeof h == "function" ? h(b) : h;
            return g.replace && WI(v) ? v : { ...b, ...v };
          }
          return b;
        }));
      }, d = (p, h, g = { replace: !1 }) => {
        s((y) => y.map((b) => {
          if (b.id === p) {
            const v = typeof h == "function" ? h(b) : h;
            return g.replace && oye(v) ? v : { ...b, ...v };
          }
          return b;
        }));
      };
      return {
        getNodes: () => t.getState().nodes.map((p) => ({ ...p })),
        getNode: (p) => i(p)?.internals.userNode,
        getInternalNode: i,
        getEdges: () => {
          const { edges: p = [] } = t.getState();
          return p.map((h) => ({ ...h }));
        },
        getEdge: (p) => t.getState().edgeLookup.get(p),
        setNodes: a,
        setEdges: s,
        addNodes: (p) => {
          const h = Array.isArray(p) ? p : [p];
          n.nodeQueue.push((g) => [...g, ...h]);
        },
        addEdges: (p) => {
          const h = Array.isArray(p) ? p : [p];
          n.edgeQueue.push((g) => [...g, ...h]);
        },
        toObject: () => {
          const { nodes: p = [], edges: h = [], transform: g } = t.getState(), [y, b, v] = g;
          return {
            nodes: p.map((x) => ({ ...x })),
            edges: h.map((x) => ({ ...x })),
            viewport: {
              x: y,
              y: b,
              zoom: v
            }
          };
        },
        deleteElements: async ({ nodes: p = [], edges: h = [] }) => {
          const { nodes: g, edges: y, onNodesDelete: b, onEdgesDelete: v, triggerNodeChanges: x, triggerEdgeChanges: E, onDelete: _, onBeforeDelete: C } = t.getState(), { nodes: k, edges: R } = await Bme({
            nodesToRemove: p,
            edgesToRemove: h,
            nodes: g,
            edges: y,
            onBeforeDelete: C
          }), A = R.length > 0, M = k.length > 0;
          if (A) {
            const I = R.map(qI);
            v?.(R), E(I);
          }
          if (M) {
            const I = k.map(qI);
            b?.(k), x(I);
          }
          return (M || A) && _?.({ nodes: k, edges: R }), { deletedNodes: k, deletedEdges: R };
        },
        getIntersectingNodes: (p, h = !0, g) => {
          const y = EI(p), b = y ? p : l(p), v = g !== void 0;
          return b ? (g || t.getState().nodes).filter((x) => {
            const E = t.getState().nodeLookup.get(x.id);
            if (E && !y && (x.id === p.id || !E.internals.positionAbsolute))
              return !1;
            const _ = ff(v ? x : E), C = ah(_, b);
            return h && C > 0 || C >= _.width * _.height || C >= b.width * b.height;
          }) : [];
        },
        isNodeIntersecting: (p, h, g = !0) => {
          const b = EI(p) ? p : l(p);
          if (!b)
            return !1;
          const v = ah(b, h);
          return g && v > 0 || v >= b.width * b.height;
        },
        updateNode: u,
        updateNodeData: (p, h, g = { replace: !1 }) => {
          u(p, (y) => {
            const b = typeof h == "function" ? h(y) : h;
            return g.replace ? { ...y, data: b } : { ...y, data: { ...y.data, ...b } };
          }, g);
        },
        updateEdge: d,
        updateEdgeData: (p, h, g = { replace: !1 }) => {
          d(p, (y) => {
            const b = typeof h == "function" ? h(y) : h;
            return g.replace ? { ...y, data: b } : { ...y, data: { ...y.data, ...b } };
          }, g);
        },
        getNodesBounds: (p) => {
          const { nodeLookup: h, nodeOrigin: g } = t.getState();
          return Dme(p, { nodeLookup: h, nodeOrigin: g });
        },
        getHandleConnections: ({ type: p, id: h, nodeId: g }) => Array.from(t.getState().connectionLookup.get(`${g}-${p}${h ? `-${h}` : ""}`)?.values() ?? []),
        getNodeConnections: ({ type: p, handleId: h, nodeId: g }) => Array.from(t.getState().connectionLookup.get(`${g}${p ? h ? `-${p}-${h}` : `-${p}` : ""}`)?.values() ?? []),
        fitView: async (p) => {
          const h = t.getState().fitViewResolver ?? qme();
          return t.setState({ fitViewQueued: !0, fitViewOptions: p, fitViewResolver: h }), n.nodeQueue.push((g) => [...g]), h.promise;
        }
      };
    }, []);
    return T.useMemo(() => ({
      ...o,
      ...e,
      viewportInitialized: r
    }), [r]);
  }
  const KI = (e) => e.selected, uye = typeof window < "u" ? window : void 0;
  function fye({ deleteKeyCode: e, multiSelectionKeyCode: t }) {
    const n = vn(), { deleteElements: r } = yc(), o = Na(e, { actInsideInputWithModifier: !1 }), i = Na(t, { target: uye });
    T.useEffect(() => {
      if (o) {
        const { edges: a, nodes: s } = n.getState();
        r({ nodes: s.filter(KI), edges: a.filter(KI) }), n.setState({ nodesSelectionActive: !1 });
      }
    }, [o]), T.useEffect(() => {
      n.setState({ multiSelectionActive: i });
    }, [i]);
  }
  function dye(e) {
    const t = vn();
    T.useEffect(() => {
      const n = () => {
        if (!e.current)
          return !1;
        const r = CT(e.current);
        (r.height === 0 || r.width === 0) && t.getState().onError?.("004", qi.error004()), t.setState({ width: r.width || 500, height: r.height || 500 });
      };
      if (e.current) {
        n(), window.addEventListener("resize", n);
        const r = new ResizeObserver(() => n());
        return r.observe(e.current), () => {
          window.removeEventListener("resize", n), r && e.current && r.unobserve(e.current);
        };
      }
    }, []);
  }
  const qb = {
    position: "absolute",
    width: "100%",
    height: "100%",
    top: 0,
    left: 0
  }, pye = (e) => ({
    userSelectionActive: e.userSelectionActive,
    lib: e.lib
  });
  function hye({ onPaneContextMenu: e, zoomOnScroll: t = !0, zoomOnPinch: n = !0, panOnScroll: r = !1, panOnScrollSpeed: o = 0.5, panOnScrollMode: i = Jl.Free, zoomOnDoubleClick: a = !0, panOnDrag: s = !0, defaultViewport: l, translateExtent: u, minZoom: d, maxZoom: p, zoomActivationKeyCode: h, preventScrolling: g = !0, children: y, noWheelClassName: b, noPanClassName: v, onViewportChange: x, isControlledViewport: E, paneClickDistance: _ }) {
    const C = vn(), k = T.useRef(null), { userSelectionActive: R, lib: A } = Mt(pye, xn), M = Na(h), I = T.useRef();
    dye(k);
    const D = T.useCallback((L) => {
      x?.({ x: L[0], y: L[1], zoom: L[2] }), E || C.setState({ transform: L });
    }, [x, E]);
    return T.useEffect(() => {
      if (k.current) {
        I.current = kge({
          domNode: k.current,
          minZoom: d,
          maxZoom: p,
          translateExtent: u,
          viewport: l,
          paneClickDistance: _,
          onDraggingChange: (j) => C.setState({ paneDragging: j }),
          onPanZoomStart: (j, V) => {
            const { onViewportChangeStart: F, onMoveStart: G } = C.getState();
            G?.(j, V), F?.(V);
          },
          onPanZoom: (j, V) => {
            const { onViewportChange: F, onMove: G } = C.getState();
            G?.(j, V), F?.(V);
          },
          onPanZoomEnd: (j, V) => {
            const { onViewportChangeEnd: F, onMoveEnd: G } = C.getState();
            G?.(j, V), F?.(V);
          }
        });
        const { x: L, y: P, zoom: B } = I.current.getViewport();
        return C.setState({
          panZoom: I.current,
          transform: [L, P, B],
          domNode: k.current.closest(".react-flow")
        }), () => {
          I.current?.destroy();
        };
      }
    }, []), T.useEffect(() => {
      I.current?.update({
        onPaneContextMenu: e,
        zoomOnScroll: t,
        zoomOnPinch: n,
        panOnScroll: r,
        panOnScrollSpeed: o,
        panOnScrollMode: i,
        zoomOnDoubleClick: a,
        panOnDrag: s,
        zoomActivationKeyPressed: M,
        preventScrolling: g,
        noPanClassName: v,
        userSelectionActive: R,
        noWheelClassName: b,
        lib: A,
        onTransformChange: D
      });
    }, [
      e,
      t,
      n,
      r,
      o,
      i,
      a,
      s,
      M,
      g,
      v,
      R,
      b,
      A,
      D
    ]), S.jsx("div", { className: "react-flow__renderer", ref: k, style: qb, children: y });
  }
  const mye = (e) => ({
    userSelectionActive: e.userSelectionActive,
    userSelectionRect: e.userSelectionRect
  });
  function gye() {
    const { userSelectionActive: e, userSelectionRect: t } = Mt(mye, xn);
    return e && t ? S.jsx("div", { className: "react-flow__selection react-flow__container", style: {
      width: t.width,
      height: t.height,
      transform: `translate(${t.x}px, ${t.y}px)`
    } }) : null;
  }
  const KS = (e, t) => (n) => {
    n.target === t.current && e?.(n);
  }, yye = (e) => ({
    userSelectionActive: e.userSelectionActive,
    elementsSelectable: e.elementsSelectable,
    connectionInProgress: e.connection.inProgress,
    dragging: e.paneDragging
  });
  function vye({ isSelecting: e, selectionKeyPressed: t, selectionMode: n = ih.Full, panOnDrag: r, selectionOnDrag: o, onSelectionStart: i, onSelectionEnd: a, onPaneClick: s, onPaneContextMenu: l, onPaneScroll: u, onPaneMouseEnter: d, onPaneMouseMove: p, onPaneMouseLeave: h, children: g }) {
    const y = vn(), { userSelectionActive: b, elementsSelectable: v, dragging: x, connectionInProgress: E } = Mt(yye, xn), _ = v && (e || b), C = T.useRef(null), k = T.useRef(), R = T.useRef(/* @__PURE__ */ new Set()), A = T.useRef(/* @__PURE__ */ new Set()), M = T.useRef(!1), I = T.useRef(!1), D = (G) => {
      if (M.current || E) {
        M.current = !1;
        return;
      }
      s?.(G), y.getState().resetSelectedElements(), y.setState({ nodesSelectionActive: !1 });
    }, L = (G) => {
      if (Array.isArray(r) && r?.includes(2)) {
        G.preventDefault();
        return;
      }
      l?.(G);
    }, P = u ? (G) => u(G) : void 0, B = (G) => {
      const { resetSelectedElements: W, domNode: K } = y.getState();
      if (k.current = K?.getBoundingClientRect(), !v || !e || G.button !== 0 || G.target !== C.current || !k.current)
        return;
      G.target?.setPointerCapture?.(G.pointerId), I.current = !0, M.current = !1;
      const { x: $, y: U } = Ni(G.nativeEvent, k.current);
      W(), y.setState({
        userSelectionRect: {
          width: 0,
          height: 0,
          startX: $,
          startY: U,
          x: $,
          y: U
        }
      }), i?.(G);
    }, j = (G) => {
      const { userSelectionRect: W, transform: K, nodeLookup: $, edgeLookup: U, connectionLookup: X, triggerNodeChanges: z, triggerEdgeChanges: H, defaultEdgeOptions: Y } = y.getState();
      if (!k.current || !W)
        return;
      M.current = !0;
      const { x: Q, y: re } = Ni(G.nativeEvent, k.current), { startX: te, startY: le } = W, fe = {
        startX: te,
        startY: le,
        x: Q < te ? Q : te,
        y: re < le ? re : le,
        width: Math.abs(Q - te),
        height: Math.abs(re - le)
      }, J = R.current, ee = A.current;
      R.current = new Set(_T($, fe, K, n === ih.Partial, !0).map((ae) => ae.id)), A.current = /* @__PURE__ */ new Set();
      const ie = Y?.selectable ?? !0;
      for (const ae of R.current) {
        const ge = X.get(ae);
        if (ge)
          for (const { edgeId: Ce } of ge.values()) {
            const Ne = U.get(Ce);
            Ne && (Ne.selectable ?? ie) && A.current.add(Ce);
          }
      }
      if (!CI(J, R.current)) {
        const ae = Lu($, R.current, !0);
        z(ae);
      }
      if (!CI(ee, A.current)) {
        const ae = Lu(U, A.current);
        H(ae);
      }
      y.setState({
        userSelectionRect: fe,
        userSelectionActive: !0,
        nodesSelectionActive: !1
      });
    }, V = (G) => {
      if (G.button !== 0 || !I.current)
        return;
      G.target?.releasePointerCapture?.(G.pointerId);
      const { userSelectionRect: W } = y.getState();
      !b && W && G.target === C.current && D?.(G), y.setState({
        userSelectionActive: !1,
        userSelectionRect: null,
        nodesSelectionActive: R.current.size > 0
      }), a?.(G), (t || o) && (M.current = !1), I.current = !1;
    }, F = r === !0 || Array.isArray(r) && r.includes(0);
    return S.jsxs("div", { className: Vn(["react-flow__pane", { draggable: F, dragging: x, selection: e }]), onClick: _ ? void 0 : KS(D, C), onContextMenu: KS(L, C), onWheel: KS(P, C), onPointerEnter: _ ? void 0 : d, onPointerDown: _ ? B : p, onPointerMove: _ ? j : p, onPointerUp: _ ? V : void 0, onPointerLeave: h, ref: C, style: qb, children: [g, S.jsx(gye, {})] });
  }
  function cC({ id: e, store: t, unselect: n = !1, nodeRef: r }) {
    const { addSelectedNodes: o, unselectNodesAndEdges: i, multiSelectionActive: a, nodeLookup: s, onError: l } = t.getState(), u = s.get(e);
    if (!u) {
      l?.("012", qi.error012(e));
      return;
    }
    t.setState({ nodesSelectionActive: !1 }), u.selected ? (n || u.selected && a) && (i({ nodes: [u], edges: [] }), requestAnimationFrame(() => r?.current?.blur())) : o([e]);
  }
  function AB({ nodeRef: e, disabled: t = !1, noDragClassName: n, handleSelector: r, nodeId: o, isSelectable: i, nodeClickDistance: a }) {
    const s = vn(), [l, u] = T.useState(!1), d = T.useRef();
    return T.useEffect(() => {
      d.current = fge({
        getStoreItems: () => s.getState(),
        onNodeMouseDown: (p) => {
          cC({
            id: p,
            store: s,
            nodeRef: e
          });
        },
        onDragStart: () => {
          u(!0);
        },
        onDragStop: () => {
          u(!1);
        }
      });
    }, []), T.useEffect(() => {
      if (t)
        d.current?.destroy();
      else if (e.current)
        return d.current?.update({
          noDragClassName: n,
          handleSelector: r,
          domNode: e.current,
          isSelectable: i,
          nodeId: o,
          nodeClickDistance: a
        }), () => {
          d.current?.destroy();
        };
    }, [n, r, t, i, e, o]), l;
  }
  const bye = (e) => (t) => t.selected && (t.draggable || e && typeof t.draggable > "u");
  function NB() {
    const e = vn();
    return T.useCallback((n) => {
      const { nodeExtent: r, snapToGrid: o, snapGrid: i, nodesDraggable: a, onError: s, updateNodePositions: l, nodeLookup: u, nodeOrigin: d } = e.getState(), p = /* @__PURE__ */ new Map(), h = bye(a), g = o ? i[0] : 5, y = o ? i[1] : 5, b = n.direction.x * g * n.factor, v = n.direction.y * y * n.factor;
      for (const [, x] of u) {
        if (!h(x))
          continue;
        let E = {
          x: x.internals.positionAbsolute.x + b,
          y: x.internals.positionAbsolute.y + v
        };
        o && (E = Bb(E, i));
        const { position: _, positionAbsolute: C } = J9({
          nodeId: x.id,
          nextPosition: E,
          nodeLookup: u,
          nodeExtent: r,
          nodeOrigin: d,
          onError: s
        });
        x.position = _, x.internals.positionAbsolute = C, p.set(x.id, x);
      }
      l(p);
    }, []);
  }
  const MT = T.createContext(null), xye = MT.Provider;
  MT.Consumer;
  const MB = () => T.useContext(MT), wye = (e) => ({
    connectOnClick: e.connectOnClick,
    noPanClassName: e.noPanClassName,
    rfId: e.rfId
  }), Sye = (e, t, n) => (r) => {
    const { connectionClickStartHandle: o, connectionMode: i, connection: a } = r, { fromHandle: s, toHandle: l, isValid: u } = a, d = l?.nodeId === e && l?.id === t && l?.type === n;
    return {
      connectingFrom: s?.nodeId === e && s?.id === t && s?.type === n,
      connectingTo: d,
      clickConnecting: o?.nodeId === e && o?.id === t && o?.type === n,
      isPossibleEndHandle: i === cf.Strict ? s?.type !== n : e !== s?.nodeId || t !== s?.id,
      connectionInProcess: !!s,
      clickConnectionInProcess: !!o,
      valid: d && u
    };
  };
  function _ye({ type: e = "source", position: t = qe.Top, isValidConnection: n, isConnectable: r = !0, isConnectableStart: o = !0, isConnectableEnd: i = !0, id: a, onConnect: s, children: l, className: u, onMouseDown: d, onTouchStart: p, ...h }, g) {
    const y = a || null, b = e === "target", v = vn(), x = MB(), { connectOnClick: E, noPanClassName: _, rfId: C } = Mt(wye, xn), { connectingFrom: k, connectingTo: R, clickConnecting: A, isPossibleEndHandle: M, connectionInProcess: I, clickConnectionInProcess: D, valid: L } = Mt(Sye(x, y, e), xn);
    x || v.getState().onError?.("010", qi.error010());
    const P = (V) => {
      const { defaultEdgeOptions: F, onConnect: G, hasDefaultEdges: W } = v.getState(), K = {
        ...F,
        ...V
      };
      if (W) {
        const { edges: $, setEdges: U } = v.getState();
        U(Qme(K, $));
      }
      G?.(K), s?.(K);
    }, B = (V) => {
      if (!x)
        return;
      const F = sB(V.nativeEvent);
      if (o && (F && V.button === 0 || !F)) {
        const G = v.getState();
        lC.onPointerDown(V.nativeEvent, {
          autoPanOnConnect: G.autoPanOnConnect,
          connectionMode: G.connectionMode,
          connectionRadius: G.connectionRadius,
          domNode: G.domNode,
          nodeLookup: G.nodeLookup,
          lib: G.lib,
          isTarget: b,
          handleId: y,
          nodeId: x,
          flowId: G.rfId,
          panBy: G.panBy,
          cancelConnection: G.cancelConnection,
          onConnectStart: G.onConnectStart,
          onConnectEnd: G.onConnectEnd,
          updateConnection: G.updateConnection,
          onConnect: P,
          isValidConnection: n || G.isValidConnection,
          getTransform: () => v.getState().transform,
          getFromHandle: () => v.getState().connection.fromHandle,
          autoPanSpeed: G.autoPanSpeed,
          dragThreshold: G.connectionDragThreshold
        });
      }
      F ? d?.(V) : p?.(V);
    }, j = (V) => {
      const { onClickConnectStart: F, onClickConnectEnd: G, connectionClickStartHandle: W, connectionMode: K, isValidConnection: $, lib: U, rfId: X, nodeLookup: z, connection: H } = v.getState();
      if (!x || !W && !o)
        return;
      if (!W) {
        F?.(V.nativeEvent, { nodeId: x, handleId: y, handleType: e }), v.setState({ connectionClickStartHandle: { nodeId: x, type: e, id: y } });
        return;
      }
      const Y = iB(V.target), Q = n || $, { connection: re, isValid: te } = lC.isValid(V.nativeEvent, {
        handle: {
          nodeId: x,
          id: y,
          type: e
        },
        connectionMode: K,
        fromNodeId: W.nodeId,
        fromHandleId: W.id || null,
        fromType: W.type,
        isValidConnection: Q,
        flowId: X,
        doc: Y,
        lib: U,
        nodeLookup: z
      });
      te && re && P(re);
      const le = structuredClone(H);
      delete le.inProgress, le.toPosition = le.toHandle ? le.toHandle.position : null, G?.(V, le), v.setState({ connectionClickStartHandle: null });
    };
    return S.jsx("div", { "data-handleid": y, "data-nodeid": x, "data-handlepos": t, "data-id": `${C}-${x}-${y}-${e}`, className: Vn([
      "react-flow__handle",
      `react-flow__handle-${t}`,
      "nodrag",
      _,
      u,
      {
        source: !b,
        target: b,
        connectable: r,
        connectablestart: o,
        connectableend: i,
        clickconnecting: A,
        connectingfrom: k,
        connectingto: R,
        valid: L,
        /*
         * shows where you can start a connection from
         * and where you can end it while connecting
         */
        connectionindicator: r && (!I || M) && (I || D ? i : o)
      }
    ]), onMouseDown: B, onTouchStart: B, onClick: E ? j : void 0, ref: g, ...h, children: l });
  }
  const lh = T.memo(RB(_ye));
  function Eye({ data: e, isConnectable: t, sourcePosition: n = qe.Bottom }) {
    return S.jsxs(S.Fragment, { children: [e?.label, S.jsx(lh, { type: "source", position: n, isConnectable: t })] });
  }
  function Cye({ data: e, isConnectable: t, targetPosition: n = qe.Top, sourcePosition: r = qe.Bottom }) {
    return S.jsxs(S.Fragment, { children: [S.jsx(lh, { type: "target", position: n, isConnectable: t }), e?.label, S.jsx(lh, { type: "source", position: r, isConnectable: t })] });
  }
  function kye() {
    return null;
  }
  function Tye({ data: e, isConnectable: t, targetPosition: n = qe.Top }) {
    return S.jsxs(S.Fragment, { children: [S.jsx(lh, { type: "target", position: n, isConnectable: t }), e?.label] });
  }
  const b0 = {
    ArrowUp: { x: 0, y: -1 },
    ArrowDown: { x: 0, y: 1 },
    ArrowLeft: { x: -1, y: 0 },
    ArrowRight: { x: 1, y: 0 }
  }, YI = {
    input: Eye,
    default: Cye,
    output: Tye,
    group: kye
  };
  function Rye(e) {
    return e.internals.handleBounds === void 0 ? {
      width: e.width ?? e.initialWidth ?? e.style?.width,
      height: e.height ?? e.initialHeight ?? e.style?.height
    } : {
      width: e.width ?? e.style?.width,
      height: e.height ?? e.style?.height
    };
  }
  const Oye = (e) => {
    const { width: t, height: n, x: r, y: o } = Zh(e.nodeLookup, {
      filter: (i) => !!i.selected
    });
    return {
      width: qo(t) ? t : null,
      height: qo(n) ? n : null,
      userSelectionActive: e.userSelectionActive,
      transformString: `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]}) translate(${r}px,${o}px)`
    };
  };
  function Aye({ onSelectionContextMenu: e, noPanClassName: t, disableKeyboardA11y: n }) {
    const r = vn(), { width: o, height: i, transformString: a, userSelectionActive: s } = Mt(Oye, xn), l = NB(), u = T.useRef(null);
    if (T.useEffect(() => {
      n || u.current?.focus({
        preventScroll: !0
      });
    }, [n]), AB({
      nodeRef: u
    }), s || !o || !i)
      return null;
    const d = e ? (h) => {
      const g = r.getState().nodes.filter((y) => y.selected);
      e(h, g);
    } : void 0, p = (h) => {
      Object.prototype.hasOwnProperty.call(b0, h.key) && (h.preventDefault(), l({
        direction: b0[h.key],
        factor: h.shiftKey ? 4 : 1
      }));
    };
    return S.jsx("div", { className: Vn(["react-flow__nodesselection", "react-flow__container", t]), style: {
      transform: a
    }, children: S.jsx("div", { ref: u, className: "react-flow__nodesselection-rect", onContextMenu: d, tabIndex: n ? void 0 : -1, onKeyDown: n ? void 0 : p, style: {
      width: o,
      height: i
    } }) });
  }
  const XI = typeof window < "u" ? window : void 0, Nye = (e) => ({ nodesSelectionActive: e.nodesSelectionActive, userSelectionActive: e.userSelectionActive });
  function PB({ children: e, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: o, onPaneContextMenu: i, onPaneScroll: a, paneClickDistance: s, deleteKeyCode: l, selectionKeyCode: u, selectionOnDrag: d, selectionMode: p, onSelectionStart: h, onSelectionEnd: g, multiSelectionKeyCode: y, panActivationKeyCode: b, zoomActivationKeyCode: v, elementsSelectable: x, zoomOnScroll: E, zoomOnPinch: _, panOnScroll: C, panOnScrollSpeed: k, panOnScrollMode: R, zoomOnDoubleClick: A, panOnDrag: M, defaultViewport: I, translateExtent: D, minZoom: L, maxZoom: P, preventScrolling: B, onSelectionContextMenu: j, noWheelClassName: V, noPanClassName: F, disableKeyboardA11y: G, onViewportChange: W, isControlledViewport: K }) {
    const { nodesSelectionActive: $, userSelectionActive: U } = Mt(Nye), X = Na(u, { target: XI }), z = Na(b, { target: XI }), H = z || M, Y = z || C, Q = d && H !== !0, re = X || U || Q;
    return fye({ deleteKeyCode: l, multiSelectionKeyCode: y }), S.jsx(hye, { onPaneContextMenu: i, elementsSelectable: x, zoomOnScroll: E, zoomOnPinch: _, panOnScroll: Y, panOnScrollSpeed: k, panOnScrollMode: R, zoomOnDoubleClick: A, panOnDrag: !X && H, defaultViewport: I, translateExtent: D, minZoom: L, maxZoom: P, zoomActivationKeyCode: v, preventScrolling: B, noWheelClassName: V, noPanClassName: F, onViewportChange: W, isControlledViewport: K, paneClickDistance: s, children: S.jsxs(vye, { onSelectionStart: h, onSelectionEnd: g, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: o, onPaneContextMenu: i, onPaneScroll: a, panOnDrag: H, isSelecting: !!re, selectionMode: p, selectionKeyPressed: X, selectionOnDrag: Q, children: [e, $ && S.jsx(Aye, { onSelectionContextMenu: j, noPanClassName: F, disableKeyboardA11y: G })] }) });
  }
  PB.displayName = "FlowRenderer";
  const Mye = T.memo(PB), Pye = (e) => (t) => e ? _T(t.nodeLookup, { x: 0, y: 0, width: t.width, height: t.height }, t.transform, !0).map((n) => n.id) : Array.from(t.nodeLookup.keys());
  function $ye(e) {
    return Mt(T.useCallback(Pye(e), [e]), xn);
  }
  const Iye = (e) => e.updateNodeInternals;
  function jye() {
    const e = Mt(Iye), [t] = T.useState(() => typeof ResizeObserver > "u" ? null : new ResizeObserver((n) => {
      const r = /* @__PURE__ */ new Map();
      n.forEach((o) => {
        const i = o.target.getAttribute("data-id");
        r.set(i, {
          id: i,
          nodeElement: o.target,
          force: !0
        });
      }), e(r);
    }));
    return T.useEffect(() => () => {
      t?.disconnect();
    }, [t]), t;
  }
  function Dye({ node: e, nodeType: t, hasDimensions: n, resizeObserver: r }) {
    const o = vn(), i = T.useRef(null), a = T.useRef(null), s = T.useRef(e.sourcePosition), l = T.useRef(e.targetPosition), u = T.useRef(t), d = n && !!e.internals.handleBounds;
    return T.useEffect(() => {
      i.current && !e.hidden && (!d || a.current !== i.current) && (a.current && r?.unobserve(a.current), r?.observe(i.current), a.current = i.current);
    }, [d, e.hidden]), T.useEffect(() => () => {
      a.current && (r?.unobserve(a.current), a.current = null);
    }, []), T.useEffect(() => {
      if (i.current) {
        const p = u.current !== t, h = s.current !== e.sourcePosition, g = l.current !== e.targetPosition;
        (p || h || g) && (u.current = t, s.current = e.sourcePosition, l.current = e.targetPosition, o.getState().updateNodeInternals(/* @__PURE__ */ new Map([[e.id, { id: e.id, nodeElement: i.current, force: !0 }]])));
      }
    }, [e.id, t, e.sourcePosition, e.targetPosition]), i;
  }
  function Fye({ id: e, onClick: t, onMouseEnter: n, onMouseMove: r, onMouseLeave: o, onContextMenu: i, onDoubleClick: a, nodesDraggable: s, elementsSelectable: l, nodesConnectable: u, nodesFocusable: d, resizeObserver: p, noDragClassName: h, noPanClassName: g, disableKeyboardA11y: y, rfId: b, nodeTypes: v, nodeClickDistance: x, onError: E }) {
    const { node: _, internals: C, isParent: k } = Mt((te) => {
      const le = te.nodeLookup.get(e), fe = te.parentLookup.has(e);
      return {
        node: le,
        internals: le.internals,
        isParent: fe
      };
    }, xn);
    let R = _.type || "default", A = v?.[R] || YI[R];
    A === void 0 && (E?.("003", qi.error003(R)), R = "default", A = v?.default || YI.default);
    const M = !!(_.draggable || s && typeof _.draggable > "u"), I = !!(_.selectable || l && typeof _.selectable > "u"), D = !!(_.connectable || u && typeof _.connectable > "u"), L = !!(_.focusable || d && typeof _.focusable > "u"), P = vn(), B = rB(_), j = Dye({ node: _, nodeType: R, hasDimensions: B, resizeObserver: p }), V = AB({
      nodeRef: j,
      disabled: _.hidden || !M,
      noDragClassName: h,
      handleSelector: _.dragHandle,
      nodeId: e,
      isSelectable: I,
      nodeClickDistance: x
    }), F = NB();
    if (_.hidden)
      return null;
    const G = Xa(_), W = Rye(_), K = I || M || t || n || r || o, $ = n ? (te) => n(te, { ...C.userNode }) : void 0, U = r ? (te) => r(te, { ...C.userNode }) : void 0, X = o ? (te) => o(te, { ...C.userNode }) : void 0, z = i ? (te) => i(te, { ...C.userNode }) : void 0, H = a ? (te) => a(te, { ...C.userNode }) : void 0, Y = (te) => {
      const { selectNodesOnDrag: le, nodeDragThreshold: fe } = P.getState();
      I && (!le || !M || fe > 0) && cC({
        id: e,
        store: P,
        nodeRef: j
      }), t && t(te, { ...C.userNode });
    }, Q = (te) => {
      if (!(aB(te.nativeEvent) || y)) {
        if (K9.includes(te.key) && I) {
          const le = te.key === "Escape";
          cC({
            id: e,
            store: P,
            unselect: le,
            nodeRef: j
          });
        } else if (M && _.selected && Object.prototype.hasOwnProperty.call(b0, te.key)) {
          te.preventDefault();
          const { ariaLabelConfig: le } = P.getState();
          P.setState({
            ariaLiveMessage: le["node.a11yDescription.ariaLiveMessage"]({
              direction: te.key.replace("Arrow", "").toLowerCase(),
              x: ~~C.positionAbsolute.x,
              y: ~~C.positionAbsolute.y
            })
          }), F({
            direction: b0[te.key],
            factor: te.shiftKey ? 4 : 1
          });
        }
      }
    }, re = () => {
      if (y || !j.current?.matches(":focus-visible"))
        return;
      const { transform: te, width: le, height: fe, autoPanOnNodeFocus: J, setCenter: ee } = P.getState();
      if (!J)
        return;
      _T(/* @__PURE__ */ new Map([[e, _]]), { x: 0, y: 0, width: le, height: fe }, te, !0).length > 0 || ee(_.position.x + G.width / 2, _.position.y + G.height / 2, {
        zoom: te[2]
      });
    };
    return S.jsx("div", { className: Vn([
      "react-flow__node",
      `react-flow__node-${R}`,
      {
        // this is overwritable by passing `nopan` as a class name
        [g]: M
      },
      _.className,
      {
        selected: _.selected,
        selectable: I,
        parent: k,
        draggable: M,
        dragging: V
      }
    ]), ref: j, style: {
      zIndex: C.z,
      transform: `translate(${C.positionAbsolute.x}px,${C.positionAbsolute.y}px)`,
      pointerEvents: K ? "all" : "none",
      visibility: B ? "visible" : "hidden",
      ..._.style,
      ...W
    }, "data-id": e, "data-testid": `rf__node-${e}`, onMouseEnter: $, onMouseMove: U, onMouseLeave: X, onContextMenu: z, onClick: Y, onDoubleClick: H, onKeyDown: L ? Q : void 0, tabIndex: L ? 0 : void 0, onFocus: L ? re : void 0, role: _.ariaRole ?? (L ? "group" : void 0), "aria-roledescription": "node", "aria-describedby": y ? void 0 : `${_B}-${b}`, "aria-label": _.ariaLabel, ..._.domAttributes, children: S.jsx(xye, { value: e, children: S.jsx(A, { id: e, data: _.data, type: R, positionAbsoluteX: C.positionAbsolute.x, positionAbsoluteY: C.positionAbsolute.y, selected: _.selected ?? !1, selectable: I, draggable: M, deletable: _.deletable ?? !0, isConnectable: D, sourcePosition: _.sourcePosition, targetPosition: _.targetPosition, dragging: V, dragHandle: _.dragHandle, zIndex: C.z, parentId: _.parentId, ...G }) }) });
  }
  const Lye = (e) => ({
    nodesDraggable: e.nodesDraggable,
    nodesConnectable: e.nodesConnectable,
    nodesFocusable: e.nodesFocusable,
    elementsSelectable: e.elementsSelectable,
    onError: e.onError
  });
  function $B(e) {
    const { nodesDraggable: t, nodesConnectable: n, nodesFocusable: r, elementsSelectable: o, onError: i } = Mt(Lye, xn), a = $ye(e.onlyRenderVisibleElements), s = jye();
    return S.jsx("div", { className: "react-flow__nodes", style: qb, children: a.map((l) => (
      /*
       * The split of responsibilities between NodeRenderer and
       * NodeComponentWrapper may appear weird. However, its designed to
       * minimize the cost of updates when individual nodes change.
       *
       * For example, when youre dragging a single node, that node gets
       * updated multiple times per second. If `NodeRenderer` were to update
       * every time, it would have to re-run the `nodes.map()` loop every
       * time. This gets pricey with hundreds of nodes, especially if every
       * loop cycle does more than just rendering a JSX element!
       *
       * As a result of this choice, we took the following implementation
       * decisions:
       * - NodeRenderer subscribes *only* to node IDs  and therefore
       *   rerender *only* when visible nodes are added or removed.
       * - NodeRenderer performs all operations the result of which can be
       *   shared between nodes (such as creating the `ResizeObserver`
       *   instance, or subscribing to `selector`). This means extra prop
       *   drilling into `NodeComponentWrapper`, but it means we need to run
       *   these operations only once  instead of once per node.
       * - Any operations that youd normally write inside `nodes.map` are
       *   moved into `NodeComponentWrapper`. This ensures they are
       *   memorized  so if `NodeRenderer` *has* to rerender, it only
       *   needs to regenerate the list of nodes, nothing else.
       */
      S.jsx(Fye, { id: l, nodeTypes: e.nodeTypes, nodeExtent: e.nodeExtent, onClick: e.onNodeClick, onMouseEnter: e.onNodeMouseEnter, onMouseMove: e.onNodeMouseMove, onMouseLeave: e.onNodeMouseLeave, onContextMenu: e.onNodeContextMenu, onDoubleClick: e.onNodeDoubleClick, noDragClassName: e.noDragClassName, noPanClassName: e.noPanClassName, rfId: e.rfId, disableKeyboardA11y: e.disableKeyboardA11y, resizeObserver: s, nodesDraggable: t, nodesConnectable: n, nodesFocusable: r, elementsSelectable: o, nodeClickDistance: e.nodeClickDistance, onError: i }, l)
    )) });
  }
  $B.displayName = "NodeRenderer";
  const zye = T.memo($B);
  function Bye(e) {
    return Mt(T.useCallback((n) => {
      if (!e)
        return n.edges.map((o) => o.id);
      const r = [];
      if (n.width && n.height)
        for (const o of n.edges) {
          const i = n.nodeLookup.get(o.source), a = n.nodeLookup.get(o.target);
          i && a && Yme({
            sourceNode: i,
            targetNode: a,
            width: n.width,
            height: n.height,
            transform: n.transform
          }) && r.push(o.id);
        }
      return r;
    }, [e]), xn);
  }
  const Uye = ({ color: e = "none", strokeWidth: t = 1 }) => S.jsx("polyline", { style: {
    stroke: e,
    strokeWidth: t
  }, strokeLinecap: "round", strokeLinejoin: "round", fill: "none", points: "-5,-4 0,0 -5,4" }), Vye = ({ color: e = "none", strokeWidth: t = 1 }) => S.jsx("polyline", { style: {
    stroke: e,
    fill: e,
    strokeWidth: t
  }, strokeLinecap: "round", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4 -5,-4" }), ZI = {
    [m0.Arrow]: Uye,
    [m0.ArrowClosed]: Vye
  };
  function Hye(e) {
    const t = vn();
    return T.useMemo(() => Object.prototype.hasOwnProperty.call(ZI, e) ? ZI[e] : (t.getState().onError?.("009", qi.error009(e)), null), [e]);
  }
  const qye = ({ id: e, type: t, color: n, width: r = 12.5, height: o = 12.5, markerUnits: i = "strokeWidth", strokeWidth: a, orient: s = "auto-start-reverse" }) => {
    const l = Hye(t);
    return l ? S.jsx("marker", { className: "react-flow__arrowhead", id: e, markerWidth: `${r}`, markerHeight: `${o}`, viewBox: "-10 -10 20 20", markerUnits: i, orient: s, refX: "0", refY: "0", children: S.jsx(l, { color: n, strokeWidth: a }) }) : null;
  }, IB = ({ defaultColor: e, rfId: t }) => {
    const n = Mt((i) => i.edges), r = Mt((i) => i.defaultEdgeOptions), o = T.useMemo(() => rge(n, {
      id: t,
      defaultColor: e,
      defaultMarkerStart: r?.markerStart,
      defaultMarkerEnd: r?.markerEnd
    }), [n, r, t, e]);
    return o.length ? S.jsx("svg", { className: "react-flow__marker", "aria-hidden": "true", children: S.jsx("defs", { children: o.map((i) => S.jsx(qye, { id: i.id, type: i.type, color: i.color, width: i.width, height: i.height, markerUnits: i.markerUnits, strokeWidth: i.strokeWidth, orient: i.orient }, i.id)) }) }) : null;
  };
  IB.displayName = "MarkerDefinitions";
  var Wye = T.memo(IB);
  function jB({ x: e, y: t, label: n, labelStyle: r, labelShowBg: o = !0, labelBgStyle: i, labelBgPadding: a = [2, 4], labelBgBorderRadius: s = 2, children: l, className: u, ...d }) {
    const [p, h] = T.useState({ x: 1, y: 0, width: 0, height: 0 }), g = Vn(["react-flow__edge-textwrapper", u]), y = T.useRef(null);
    return T.useEffect(() => {
      if (y.current) {
        const b = y.current.getBBox();
        h({
          x: b.x,
          y: b.y,
          width: b.width,
          height: b.height
        });
      }
    }, [n]), n ? S.jsxs("g", { transform: `translate(${e - p.width / 2} ${t - p.height / 2})`, className: g, visibility: p.width ? "visible" : "hidden", ...d, children: [o && S.jsx("rect", { width: p.width + 2 * a[0], x: -a[0], y: -a[1], height: p.height + 2 * a[1], className: "react-flow__edge-textbg", style: i, rx: s, ry: s }), S.jsx("text", { className: "react-flow__edge-text", y: p.height / 2, dy: "0.3em", ref: y, style: r, children: n }), l] }) : null;
  }
  jB.displayName = "EdgeText";
  const Gye = T.memo(jB);
  function Jh({ path: e, labelX: t, labelY: n, label: r, labelStyle: o, labelShowBg: i, labelBgStyle: a, labelBgPadding: s, labelBgBorderRadius: l, interactionWidth: u = 20, ...d }) {
    return S.jsxs(S.Fragment, { children: [S.jsx("path", { ...d, d: e, fill: "none", className: Vn(["react-flow__edge-path", d.className]) }), u && S.jsx("path", { d: e, fill: "none", strokeOpacity: 0, strokeWidth: u, className: "react-flow__edge-interaction" }), r && qo(t) && qo(n) ? S.jsx(Gye, { x: t, y: n, label: r, labelStyle: o, labelShowBg: i, labelBgStyle: a, labelBgPadding: s, labelBgBorderRadius: l }) : null] });
  }
  function QI({ pos: e, x1: t, y1: n, x2: r, y2: o }) {
    return e === qe.Left || e === qe.Right ? [0.5 * (t + r), n] : [t, 0.5 * (n + o)];
  }
  function DB({ sourceX: e, sourceY: t, sourcePosition: n = qe.Bottom, targetX: r, targetY: o, targetPosition: i = qe.Top }) {
    const [a, s] = QI({
      pos: n,
      x1: e,
      y1: t,
      x2: r,
      y2: o
    }), [l, u] = QI({
      pos: i,
      x1: r,
      y1: o,
      x2: e,
      y2: t
    }), [d, p, h, g] = lB({
      sourceX: e,
      sourceY: t,
      targetX: r,
      targetY: o,
      sourceControlX: a,
      sourceControlY: s,
      targetControlX: l,
      targetControlY: u
    });
    return [
      `M${e},${t} C${a},${s} ${l},${u} ${r},${o}`,
      d,
      p,
      h,
      g
    ];
  }
  function FB(e) {
    return T.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: i, sourcePosition: a, targetPosition: s, label: l, labelStyle: u, labelShowBg: d, labelBgStyle: p, labelBgPadding: h, labelBgBorderRadius: g, style: y, markerEnd: b, markerStart: v, interactionWidth: x }) => {
      const [E, _, C] = DB({
        sourceX: n,
        sourceY: r,
        sourcePosition: a,
        targetX: o,
        targetY: i,
        targetPosition: s
      }), k = e.isInternal ? void 0 : t;
      return S.jsx(Jh, { id: k, path: E, labelX: _, labelY: C, label: l, labelStyle: u, labelShowBg: d, labelBgStyle: p, labelBgPadding: h, labelBgBorderRadius: g, style: y, markerEnd: b, markerStart: v, interactionWidth: x });
    });
  }
  const Kye = FB({ isInternal: !1 }), LB = FB({ isInternal: !0 });
  Kye.displayName = "SimpleBezierEdge";
  LB.displayName = "SimpleBezierEdgeInternal";
  function zB(e) {
    return T.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: i, label: a, labelStyle: s, labelShowBg: l, labelBgStyle: u, labelBgPadding: d, labelBgBorderRadius: p, style: h, sourcePosition: g = qe.Bottom, targetPosition: y = qe.Top, markerEnd: b, markerStart: v, pathOptions: x, interactionWidth: E }) => {
      const [_, C, k] = iC({
        sourceX: n,
        sourceY: r,
        sourcePosition: g,
        targetX: o,
        targetY: i,
        targetPosition: y,
        borderRadius: x?.borderRadius,
        offset: x?.offset,
        stepPosition: x?.stepPosition
      }), R = e.isInternal ? void 0 : t;
      return S.jsx(Jh, { id: R, path: _, labelX: C, labelY: k, label: a, labelStyle: s, labelShowBg: l, labelBgStyle: u, labelBgPadding: d, labelBgBorderRadius: p, style: h, markerEnd: b, markerStart: v, interactionWidth: E });
    });
  }
  const BB = zB({ isInternal: !1 }), UB = zB({ isInternal: !0 });
  BB.displayName = "SmoothStepEdge";
  UB.displayName = "SmoothStepEdgeInternal";
  function VB(e) {
    return T.memo(({ id: t, ...n }) => {
      const r = e.isInternal ? void 0 : t;
      return S.jsx(BB, { ...n, id: r, pathOptions: T.useMemo(() => ({ borderRadius: 0, offset: n.pathOptions?.offset }), [n.pathOptions?.offset]) });
    });
  }
  const Yye = VB({ isInternal: !1 }), HB = VB({ isInternal: !0 });
  Yye.displayName = "StepEdge";
  HB.displayName = "StepEdgeInternal";
  function qB(e) {
    return T.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: i, label: a, labelStyle: s, labelShowBg: l, labelBgStyle: u, labelBgPadding: d, labelBgBorderRadius: p, style: h, markerEnd: g, markerStart: y, interactionWidth: b }) => {
      const [v, x, E] = uB({ sourceX: n, sourceY: r, targetX: o, targetY: i }), _ = e.isInternal ? void 0 : t;
      return S.jsx(Jh, { id: _, path: v, labelX: x, labelY: E, label: a, labelStyle: s, labelShowBg: l, labelBgStyle: u, labelBgPadding: d, labelBgBorderRadius: p, style: h, markerEnd: g, markerStart: y, interactionWidth: b });
    });
  }
  const Xye = qB({ isInternal: !1 }), WB = qB({ isInternal: !0 });
  Xye.displayName = "StraightEdge";
  WB.displayName = "StraightEdgeInternal";
  function GB(e) {
    return T.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: i, sourcePosition: a = qe.Bottom, targetPosition: s = qe.Top, label: l, labelStyle: u, labelShowBg: d, labelBgStyle: p, labelBgPadding: h, labelBgBorderRadius: g, style: y, markerEnd: b, markerStart: v, pathOptions: x, interactionWidth: E }) => {
      const [_, C, k] = kT({
        sourceX: n,
        sourceY: r,
        sourcePosition: a,
        targetX: o,
        targetY: i,
        targetPosition: s,
        curvature: x?.curvature
      }), R = e.isInternal ? void 0 : t;
      return S.jsx(Jh, { id: R, path: _, labelX: C, labelY: k, label: l, labelStyle: u, labelShowBg: d, labelBgStyle: p, labelBgPadding: h, labelBgBorderRadius: g, style: y, markerEnd: b, markerStart: v, interactionWidth: E });
    });
  }
  const Zye = GB({ isInternal: !1 }), KB = GB({ isInternal: !0 });
  Zye.displayName = "BezierEdge";
  KB.displayName = "BezierEdgeInternal";
  const JI = {
    default: KB,
    straight: WB,
    step: HB,
    smoothstep: UB,
    simplebezier: LB
  }, ej = {
    sourceX: null,
    sourceY: null,
    targetX: null,
    targetY: null,
    sourcePosition: null,
    targetPosition: null
  }, Qye = (e, t, n) => n === qe.Left ? e - t : n === qe.Right ? e + t : e, Jye = (e, t, n) => n === qe.Top ? e - t : n === qe.Bottom ? e + t : e, tj = "react-flow__edgeupdater";
  function nj({ position: e, centerX: t, centerY: n, radius: r = 10, onMouseDown: o, onMouseEnter: i, onMouseOut: a, type: s }) {
    return S.jsx("circle", { onMouseDown: o, onMouseEnter: i, onMouseOut: a, className: Vn([tj, `${tj}-${s}`]), cx: Qye(t, r, e), cy: Jye(n, r, e), r, stroke: "transparent", fill: "transparent" });
  }
  function eve({ isReconnectable: e, reconnectRadius: t, edge: n, sourceX: r, sourceY: o, targetX: i, targetY: a, sourcePosition: s, targetPosition: l, onReconnect: u, onReconnectStart: d, onReconnectEnd: p, setReconnecting: h, setUpdateHover: g }) {
    const y = vn(), b = (C, k) => {
      if (C.button !== 0)
        return;
      const { autoPanOnConnect: R, domNode: A, isValidConnection: M, connectionMode: I, connectionRadius: D, lib: L, onConnectStart: P, onConnectEnd: B, cancelConnection: j, nodeLookup: V, rfId: F, panBy: G, updateConnection: W } = y.getState(), K = k.type === "target", $ = (z, H) => {
        h(!1), p?.(z, n, k.type, H);
      }, U = (z) => u?.(n, z), X = (z, H) => {
        h(!0), d?.(C, n, k.type), P?.(z, H);
      };
      lC.onPointerDown(C.nativeEvent, {
        autoPanOnConnect: R,
        connectionMode: I,
        connectionRadius: D,
        domNode: A,
        handleId: k.id,
        nodeId: k.nodeId,
        nodeLookup: V,
        isTarget: K,
        edgeUpdaterType: k.type,
        lib: L,
        flowId: F,
        cancelConnection: j,
        panBy: G,
        isValidConnection: M,
        onConnect: U,
        onConnectStart: X,
        onConnectEnd: B,
        onReconnectEnd: $,
        updateConnection: W,
        getTransform: () => y.getState().transform,
        getFromHandle: () => y.getState().connection.fromHandle,
        dragThreshold: y.getState().connectionDragThreshold
      });
    }, v = (C) => b(C, { nodeId: n.target, id: n.targetHandle ?? null, type: "target" }), x = (C) => b(C, { nodeId: n.source, id: n.sourceHandle ?? null, type: "source" }), E = () => g(!0), _ = () => g(!1);
    return S.jsxs(S.Fragment, { children: [(e === !0 || e === "source") && S.jsx(nj, { position: s, centerX: r, centerY: o, radius: t, onMouseDown: v, onMouseEnter: E, onMouseOut: _, type: "source" }), (e === !0 || e === "target") && S.jsx(nj, { position: l, centerX: i, centerY: a, radius: t, onMouseDown: x, onMouseEnter: E, onMouseOut: _, type: "target" })] });
  }
  function tve({ id: e, edgesFocusable: t, edgesReconnectable: n, elementsSelectable: r, onClick: o, onDoubleClick: i, onContextMenu: a, onMouseEnter: s, onMouseMove: l, onMouseLeave: u, reconnectRadius: d, onReconnect: p, onReconnectStart: h, onReconnectEnd: g, rfId: y, edgeTypes: b, noPanClassName: v, onError: x, disableKeyboardA11y: E }) {
    let _ = Mt((ee) => ee.edgeLookup.get(e));
    const C = Mt((ee) => ee.defaultEdgeOptions);
    _ = C ? { ...C, ..._ } : _;
    let k = _.type || "default", R = b?.[k] || JI[k];
    R === void 0 && (x?.("011", qi.error011(k)), k = "default", R = b?.default || JI.default);
    const A = !!(_.focusable || t && typeof _.focusable > "u"), M = typeof p < "u" && (_.reconnectable || n && typeof _.reconnectable > "u"), I = !!(_.selectable || r && typeof _.selectable > "u"), D = T.useRef(null), [L, P] = T.useState(!1), [B, j] = T.useState(!1), V = vn(), { zIndex: F, sourceX: G, sourceY: W, targetX: K, targetY: $, sourcePosition: U, targetPosition: X } = Mt(T.useCallback((ee) => {
      const ie = ee.nodeLookup.get(_.source), ae = ee.nodeLookup.get(_.target);
      if (!ie || !ae)
        return {
          zIndex: _.zIndex,
          ...ej
        };
      const ge = nge({
        id: e,
        sourceNode: ie,
        targetNode: ae,
        sourceHandle: _.sourceHandle || null,
        targetHandle: _.targetHandle || null,
        connectionMode: ee.connectionMode,
        onError: x
      });
      return {
        zIndex: Kme({
          selected: _.selected,
          zIndex: _.zIndex,
          sourceNode: ie,
          targetNode: ae,
          elevateOnSelect: ee.elevateEdgesOnSelect
        }),
        ...ge || ej
      };
    }, [_.source, _.target, _.sourceHandle, _.targetHandle, _.selected, _.zIndex]), xn), z = T.useMemo(() => _.markerStart ? `url('#${aC(_.markerStart, y)}')` : void 0, [_.markerStart, y]), H = T.useMemo(() => _.markerEnd ? `url('#${aC(_.markerEnd, y)}')` : void 0, [_.markerEnd, y]);
    if (_.hidden || G === null || W === null || K === null || $ === null)
      return null;
    const Y = (ee) => {
      const { addSelectedEdges: ie, unselectNodesAndEdges: ae, multiSelectionActive: ge } = V.getState();
      I && (V.setState({ nodesSelectionActive: !1 }), _.selected && ge ? (ae({ nodes: [], edges: [_] }), D.current?.blur()) : ie([e])), o && o(ee, _);
    }, Q = i ? (ee) => {
      i(ee, { ..._ });
    } : void 0, re = a ? (ee) => {
      a(ee, { ..._ });
    } : void 0, te = s ? (ee) => {
      s(ee, { ..._ });
    } : void 0, le = l ? (ee) => {
      l(ee, { ..._ });
    } : void 0, fe = u ? (ee) => {
      u(ee, { ..._ });
    } : void 0, J = (ee) => {
      if (!E && K9.includes(ee.key) && I) {
        const { unselectNodesAndEdges: ie, addSelectedEdges: ae } = V.getState();
        ee.key === "Escape" ? (D.current?.blur(), ie({ edges: [_] })) : ae([e]);
      }
    };
    return S.jsx("svg", { style: { zIndex: F }, children: S.jsxs("g", { className: Vn([
      "react-flow__edge",
      `react-flow__edge-${k}`,
      _.className,
      v,
      {
        selected: _.selected,
        animated: _.animated,
        inactive: !I && !o,
        updating: L,
        selectable: I
      }
    ]), onClick: Y, onDoubleClick: Q, onContextMenu: re, onMouseEnter: te, onMouseMove: le, onMouseLeave: fe, onKeyDown: A ? J : void 0, tabIndex: A ? 0 : void 0, role: _.ariaRole ?? (A ? "group" : "img"), "aria-roledescription": "edge", "data-id": e, "data-testid": `rf__edge-${e}`, "aria-label": _.ariaLabel === null ? void 0 : _.ariaLabel || `Edge from ${_.source} to ${_.target}`, "aria-describedby": A ? `${EB}-${y}` : void 0, ref: D, ..._.domAttributes, children: [!B && S.jsx(R, { id: e, source: _.source, target: _.target, type: _.type, selected: _.selected, animated: _.animated, selectable: I, deletable: _.deletable ?? !0, label: _.label, labelStyle: _.labelStyle, labelShowBg: _.labelShowBg, labelBgStyle: _.labelBgStyle, labelBgPadding: _.labelBgPadding, labelBgBorderRadius: _.labelBgBorderRadius, sourceX: G, sourceY: W, targetX: K, targetY: $, sourcePosition: U, targetPosition: X, data: _.data, style: _.style, sourceHandleId: _.sourceHandle, targetHandleId: _.targetHandle, markerStart: z, markerEnd: H, pathOptions: "pathOptions" in _ ? _.pathOptions : void 0, interactionWidth: _.interactionWidth }), M && S.jsx(eve, { edge: _, isReconnectable: M, reconnectRadius: d, onReconnect: p, onReconnectStart: h, onReconnectEnd: g, sourceX: G, sourceY: W, targetX: K, targetY: $, sourcePosition: U, targetPosition: X, setUpdateHover: P, setReconnecting: j })] }) });
  }
  const nve = (e) => ({
    edgesFocusable: e.edgesFocusable,
    edgesReconnectable: e.edgesReconnectable,
    elementsSelectable: e.elementsSelectable,
    connectionMode: e.connectionMode,
    onError: e.onError
  });
  function YB({ defaultMarkerColor: e, onlyRenderVisibleElements: t, rfId: n, edgeTypes: r, noPanClassName: o, onReconnect: i, onEdgeContextMenu: a, onEdgeMouseEnter: s, onEdgeMouseMove: l, onEdgeMouseLeave: u, onEdgeClick: d, reconnectRadius: p, onEdgeDoubleClick: h, onReconnectStart: g, onReconnectEnd: y, disableKeyboardA11y: b }) {
    const { edgesFocusable: v, edgesReconnectable: x, elementsSelectable: E, onError: _ } = Mt(nve, xn), C = Bye(t);
    return S.jsxs("div", { className: "react-flow__edges", children: [S.jsx(Wye, { defaultColor: e, rfId: n }), C.map((k) => S.jsx(tve, { id: k, edgesFocusable: v, edgesReconnectable: x, elementsSelectable: E, noPanClassName: o, onReconnect: i, onContextMenu: a, onMouseEnter: s, onMouseMove: l, onMouseLeave: u, onClick: d, reconnectRadius: p, onDoubleClick: h, onReconnectStart: g, onReconnectEnd: y, rfId: n, onError: _, edgeTypes: r, disableKeyboardA11y: b }, k))] });
  }
  YB.displayName = "EdgeRenderer";
  const rve = T.memo(YB), ove = (e) => `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]})`;
  function ive({ children: e }) {
    const t = Mt(ove);
    return S.jsx("div", { className: "react-flow__viewport xyflow__viewport react-flow__container", style: { transform: t }, children: e });
  }
  function ave(e) {
    const t = yc(), n = T.useRef(!1);
    T.useEffect(() => {
      !n.current && t.viewportInitialized && e && (setTimeout(() => e(t), 1), n.current = !0);
    }, [e, t.viewportInitialized]);
  }
  const sve = (e) => e.panZoom?.syncViewport;
  function lve(e) {
    const t = Mt(sve), n = vn();
    return T.useEffect(() => {
      e && (t?.(e), n.setState({ transform: [e.x, e.y, e.zoom] }));
    }, [e, t]), null;
  }
  function cve(e) {
    return e.connection.inProgress ? { ...e.connection, to: Qh(e.connection.to, e.transform) } : { ...e.connection };
  }
  function uve(e) {
    return cve;
  }
  function fve(e) {
    const t = uve();
    return Mt(t, xn);
  }
  const dve = (e) => ({
    nodesConnectable: e.nodesConnectable,
    isValid: e.connection.isValid,
    inProgress: e.connection.inProgress,
    width: e.width,
    height: e.height
  });
  function pve({ containerStyle: e, style: t, type: n, component: r }) {
    const { nodesConnectable: o, width: i, height: a, isValid: s, inProgress: l } = Mt(dve, xn);
    return !(i && o && l) ? null : S.jsx("svg", { style: e, width: i, height: a, className: "react-flow__connectionline react-flow__container", children: S.jsx("g", { className: Vn(["react-flow__connection", Z9(s)]), children: S.jsx(XB, { style: t, type: n, CustomComponent: r, isValid: s }) }) });
  }
  const XB = ({ style: e, type: t = zs.Bezier, CustomComponent: n, isValid: r }) => {
    const { inProgress: o, from: i, fromNode: a, fromHandle: s, fromPosition: l, to: u, toNode: d, toHandle: p, toPosition: h } = fve();
    if (!o)
      return;
    if (n)
      return S.jsx(n, { connectionLineType: t, connectionLineStyle: e, fromNode: a, fromHandle: s, fromX: i.x, fromY: i.y, toX: u.x, toY: u.y, fromPosition: l, toPosition: h, connectionStatus: Z9(r), toNode: d, toHandle: p });
    let g = "";
    const y = {
      sourceX: i.x,
      sourceY: i.y,
      sourcePosition: l,
      targetX: u.x,
      targetY: u.y,
      targetPosition: h
    };
    switch (t) {
      case zs.Bezier:
        [g] = kT(y);
        break;
      case zs.SimpleBezier:
        [g] = DB(y);
        break;
      case zs.Step:
        [g] = iC({
          ...y,
          borderRadius: 0
        });
        break;
      case zs.SmoothStep:
        [g] = iC(y);
        break;
      default:
        [g] = uB(y);
    }
    return S.jsx("path", { d: g, fill: "none", className: "react-flow__connection-path", style: e });
  };
  XB.displayName = "ConnectionLine";
  const hve = {};
  function rj(e = hve) {
    T.useRef(e), vn(), T.useEffect(() => {
    }, [e]);
  }
  function mve() {
    vn(), T.useRef(!1), T.useEffect(() => {
    }, []);
  }
  function ZB({ nodeTypes: e, edgeTypes: t, onInit: n, onNodeClick: r, onEdgeClick: o, onNodeDoubleClick: i, onEdgeDoubleClick: a, onNodeMouseEnter: s, onNodeMouseMove: l, onNodeMouseLeave: u, onNodeContextMenu: d, onSelectionContextMenu: p, onSelectionStart: h, onSelectionEnd: g, connectionLineType: y, connectionLineStyle: b, connectionLineComponent: v, connectionLineContainerStyle: x, selectionKeyCode: E, selectionOnDrag: _, selectionMode: C, multiSelectionKeyCode: k, panActivationKeyCode: R, zoomActivationKeyCode: A, deleteKeyCode: M, onlyRenderVisibleElements: I, elementsSelectable: D, defaultViewport: L, translateExtent: P, minZoom: B, maxZoom: j, preventScrolling: V, defaultMarkerColor: F, zoomOnScroll: G, zoomOnPinch: W, panOnScroll: K, panOnScrollSpeed: $, panOnScrollMode: U, zoomOnDoubleClick: X, panOnDrag: z, onPaneClick: H, onPaneMouseEnter: Y, onPaneMouseMove: Q, onPaneMouseLeave: re, onPaneScroll: te, onPaneContextMenu: le, paneClickDistance: fe, nodeClickDistance: J, onEdgeContextMenu: ee, onEdgeMouseEnter: ie, onEdgeMouseMove: ae, onEdgeMouseLeave: ge, reconnectRadius: Ce, onReconnect: Ne, onReconnectStart: Le, onReconnectEnd: Ve, noDragClassName: Ke, noWheelClassName: ze, noPanClassName: Me, disableKeyboardA11y: ct, nodeExtent: wt, rfId: Re, viewport: oe, onViewportChange: ue }) {
    return rj(e), rj(t), mve(), ave(n), lve(oe), S.jsx(Mye, { onPaneClick: H, onPaneMouseEnter: Y, onPaneMouseMove: Q, onPaneMouseLeave: re, onPaneContextMenu: le, onPaneScroll: te, paneClickDistance: fe, deleteKeyCode: M, selectionKeyCode: E, selectionOnDrag: _, selectionMode: C, onSelectionStart: h, onSelectionEnd: g, multiSelectionKeyCode: k, panActivationKeyCode: R, zoomActivationKeyCode: A, elementsSelectable: D, zoomOnScroll: G, zoomOnPinch: W, zoomOnDoubleClick: X, panOnScroll: K, panOnScrollSpeed: $, panOnScrollMode: U, panOnDrag: z, defaultViewport: L, translateExtent: P, minZoom: B, maxZoom: j, onSelectionContextMenu: p, preventScrolling: V, noDragClassName: Ke, noWheelClassName: ze, noPanClassName: Me, disableKeyboardA11y: ct, onViewportChange: ue, isControlledViewport: !!oe, children: S.jsxs(ive, { children: [S.jsx(rve, { edgeTypes: t, onEdgeClick: o, onEdgeDoubleClick: a, onReconnect: Ne, onReconnectStart: Le, onReconnectEnd: Ve, onlyRenderVisibleElements: I, onEdgeContextMenu: ee, onEdgeMouseEnter: ie, onEdgeMouseMove: ae, onEdgeMouseLeave: ge, reconnectRadius: Ce, defaultMarkerColor: F, noPanClassName: Me, disableKeyboardA11y: ct, rfId: Re }), S.jsx(pve, { style: b, type: y, component: v, containerStyle: x }), S.jsx("div", { className: "react-flow__edgelabel-renderer" }), S.jsx(zye, { nodeTypes: e, onNodeClick: r, onNodeDoubleClick: i, onNodeMouseEnter: s, onNodeMouseMove: l, onNodeMouseLeave: u, onNodeContextMenu: d, nodeClickDistance: J, onlyRenderVisibleElements: I, noPanClassName: Me, noDragClassName: Ke, disableKeyboardA11y: ct, nodeExtent: wt, rfId: Re }), S.jsx("div", { className: "react-flow__viewport-portal" })] }) });
  }
  ZB.displayName = "GraphView";
  const gve = T.memo(ZB), oj = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, width: o, height: i, fitView: a, fitViewOptions: s, minZoom: l = 0.5, maxZoom: u = 2, nodeOrigin: d, nodeExtent: p } = {}) => {
    const h = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Map(), b = /* @__PURE__ */ new Map(), v = r ?? t ?? [], x = n ?? e ?? [], E = d ?? [0, 0], _ = p ?? oh;
    dB(y, b, v);
    const C = sC(x, h, g, {
      nodeOrigin: E,
      nodeExtent: _,
      elevateNodesOnSelect: !1
    });
    let k = [0, 0, 1];
    if (a && o && i) {
      const R = Zh(h, {
        filter: (D) => !!((D.width || D.initialWidth) && (D.height || D.initialHeight))
      }), { x: A, y: M, zoom: I } = ET(R, o, i, l, u, s?.padding ?? 0.1);
      k = [A, M, I];
    }
    return {
      rfId: "1",
      width: 0,
      height: 0,
      transform: k,
      nodes: x,
      nodesInitialized: C,
      nodeLookup: h,
      parentLookup: g,
      edges: v,
      edgeLookup: b,
      connectionLookup: y,
      onNodesChange: null,
      onEdgesChange: null,
      hasDefaultNodes: n !== void 0,
      hasDefaultEdges: r !== void 0,
      panZoom: null,
      minZoom: l,
      maxZoom: u,
      translateExtent: oh,
      nodeExtent: _,
      nodesSelectionActive: !1,
      userSelectionActive: !1,
      userSelectionRect: null,
      connectionMode: cf.Strict,
      domNode: null,
      paneDragging: !1,
      noPanClassName: "nopan",
      nodeOrigin: E,
      nodeDragThreshold: 1,
      connectionDragThreshold: 1,
      snapGrid: [15, 15],
      snapToGrid: !1,
      nodesDraggable: !0,
      nodesConnectable: !0,
      nodesFocusable: !0,
      edgesFocusable: !0,
      edgesReconnectable: !0,
      elementsSelectable: !0,
      elevateNodesOnSelect: !0,
      elevateEdgesOnSelect: !1,
      selectNodesOnDrag: !0,
      multiSelectionActive: !1,
      fitViewQueued: a ?? !1,
      fitViewOptions: s,
      fitViewResolver: null,
      connection: { ...X9 },
      connectionClickStartHandle: null,
      connectOnClick: !0,
      ariaLiveMessage: "",
      autoPanOnConnect: !0,
      autoPanOnNodeDrag: !0,
      autoPanOnNodeFocus: !0,
      autoPanSpeed: 15,
      connectionRadius: 20,
      onError: Ume,
      isValidConnection: void 0,
      onSelectionChangeHandlers: [],
      lib: "react",
      debug: !1,
      ariaLabelConfig: Y9
    };
  }, yve = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, width: o, height: i, fitView: a, fitViewOptions: s, minZoom: l, maxZoom: u, nodeOrigin: d, nodeExtent: p }) => Dge((h, g) => {
    async function y() {
      const { nodeLookup: b, panZoom: v, fitViewOptions: x, fitViewResolver: E, width: _, height: C, minZoom: k, maxZoom: R } = g();
      v && (await zme({
        nodes: b,
        width: _,
        height: C,
        panZoom: v,
        minZoom: k,
        maxZoom: R
      }, x), E?.resolve(!0), h({ fitViewResolver: null }));
    }
    return {
      ...oj({
        nodes: e,
        edges: t,
        width: o,
        height: i,
        fitView: a,
        fitViewOptions: s,
        minZoom: l,
        maxZoom: u,
        nodeOrigin: d,
        nodeExtent: p,
        defaultNodes: n,
        defaultEdges: r
      }),
      setNodes: (b) => {
        const { nodeLookup: v, parentLookup: x, nodeOrigin: E, elevateNodesOnSelect: _, fitViewQueued: C } = g(), k = sC(b, v, x, {
          nodeOrigin: E,
          nodeExtent: p,
          elevateNodesOnSelect: _,
          checkEquality: !0
        });
        C && k ? (y(), h({ nodes: b, nodesInitialized: k, fitViewQueued: !1, fitViewOptions: void 0 })) : h({ nodes: b, nodesInitialized: k });
      },
      setEdges: (b) => {
        const { connectionLookup: v, edgeLookup: x } = g();
        dB(v, x, b), h({ edges: b });
      },
      setDefaultNodesAndEdges: (b, v) => {
        if (b) {
          const { setNodes: x } = g();
          x(b), h({ hasDefaultNodes: !0 });
        }
        if (v) {
          const { setEdges: x } = g();
          x(v), h({ hasDefaultEdges: !0 });
        }
      },
      /*
       * Every node gets registerd at a ResizeObserver. Whenever a node
       * changes its dimensions, this function is called to measure the
       * new dimensions and update the nodes.
       */
      updateNodeInternals: (b) => {
        const { triggerNodeChanges: v, nodeLookup: x, parentLookup: E, domNode: _, nodeOrigin: C, nodeExtent: k, debug: R, fitViewQueued: A } = g(), { changes: M, updatedInternals: I } = lge(b, x, E, _, C, k);
        I && (ige(x, E, { nodeOrigin: C, nodeExtent: k }), A ? (y(), h({ fitViewQueued: !1, fitViewOptions: void 0 })) : h({}), M?.length > 0 && (R && console.log("React Flow: trigger node changes", M), v?.(M)));
      },
      updateNodePositions: (b, v = !1) => {
        const x = [], E = [], { nodeLookup: _, triggerNodeChanges: C } = g();
        for (const [k, R] of b) {
          const A = _.get(k), M = !!(A?.expandParent && A?.parentId && R?.position), I = {
            id: k,
            type: "position",
            position: M ? {
              x: Math.max(0, R.position.x),
              y: Math.max(0, R.position.y)
            } : R.position,
            dragging: v
          };
          M && A.parentId && x.push({
            id: k,
            parentId: A.parentId,
            rect: {
              ...R.internals.positionAbsolute,
              width: R.measured.width ?? 0,
              height: R.measured.height ?? 0
            }
          }), E.push(I);
        }
        if (x.length > 0) {
          const { parentLookup: k, nodeOrigin: R } = g(), A = AT(x, _, k, R);
          E.push(...A);
        }
        C(E);
      },
      triggerNodeChanges: (b) => {
        const { onNodesChange: v, setNodes: x, nodes: E, hasDefaultNodes: _, debug: C } = g();
        if (b?.length) {
          if (_) {
            const k = NT(b, E);
            x(k);
          }
          C && console.log("React Flow: trigger node changes", b), v?.(b);
        }
      },
      triggerEdgeChanges: (b) => {
        const { onEdgesChange: v, setEdges: x, edges: E, hasDefaultEdges: _, debug: C } = g();
        if (b?.length) {
          if (_) {
            const k = TB(b, E);
            x(k);
          }
          C && console.log("React Flow: trigger edge changes", b), v?.(b);
        }
      },
      addSelectedNodes: (b) => {
        const { multiSelectionActive: v, edgeLookup: x, nodeLookup: E, triggerNodeChanges: _, triggerEdgeChanges: C } = g();
        if (v) {
          const k = b.map((R) => Vl(R, !0));
          _(k);
          return;
        }
        _(Lu(E, /* @__PURE__ */ new Set([...b]), !0)), C(Lu(x));
      },
      addSelectedEdges: (b) => {
        const { multiSelectionActive: v, edgeLookup: x, nodeLookup: E, triggerNodeChanges: _, triggerEdgeChanges: C } = g();
        if (v) {
          const k = b.map((R) => Vl(R, !0));
          C(k);
          return;
        }
        C(Lu(x, /* @__PURE__ */ new Set([...b]))), _(Lu(E, /* @__PURE__ */ new Set(), !0));
      },
      unselectNodesAndEdges: ({ nodes: b, edges: v } = {}) => {
        const { edges: x, nodes: E, nodeLookup: _, triggerNodeChanges: C, triggerEdgeChanges: k } = g(), R = b || E, A = v || x, M = R.map((D) => {
          const L = _.get(D.id);
          return L && (L.selected = !1), Vl(D.id, !1);
        }), I = A.map((D) => Vl(D.id, !1));
        C(M), k(I);
      },
      setMinZoom: (b) => {
        const { panZoom: v, maxZoom: x } = g();
        v?.setScaleExtent([b, x]), h({ minZoom: b });
      },
      setMaxZoom: (b) => {
        const { panZoom: v, minZoom: x } = g();
        v?.setScaleExtent([x, b]), h({ maxZoom: b });
      },
      setTranslateExtent: (b) => {
        g().panZoom?.setTranslateExtent(b), h({ translateExtent: b });
      },
      setPaneClickDistance: (b) => {
        g().panZoom?.setClickDistance(b);
      },
      resetSelectedElements: () => {
        const { edges: b, nodes: v, triggerNodeChanges: x, triggerEdgeChanges: E, elementsSelectable: _ } = g();
        if (!_)
          return;
        const C = v.reduce((R, A) => A.selected ? [...R, Vl(A.id, !1)] : R, []), k = b.reduce((R, A) => A.selected ? [...R, Vl(A.id, !1)] : R, []);
        x(C), E(k);
      },
      setNodeExtent: (b) => {
        const { nodes: v, nodeLookup: x, parentLookup: E, nodeOrigin: _, elevateNodesOnSelect: C, nodeExtent: k } = g();
        b[0][0] === k[0][0] && b[0][1] === k[0][1] && b[1][0] === k[1][0] && b[1][1] === k[1][1] || (sC(v, x, E, {
          nodeOrigin: _,
          nodeExtent: b,
          elevateNodesOnSelect: C,
          checkEquality: !1
        }), h({ nodeExtent: b }));
      },
      panBy: (b) => {
        const { transform: v, width: x, height: E, panZoom: _, translateExtent: C } = g();
        return cge({ delta: b, panZoom: _, transform: v, translateExtent: C, width: x, height: E });
      },
      setCenter: async (b, v, x) => {
        const { width: E, height: _, maxZoom: C, panZoom: k } = g();
        if (!k)
          return Promise.resolve(!1);
        const R = typeof x?.zoom < "u" ? x.zoom : C;
        return await k.setViewport({
          x: E / 2 - b * R,
          y: _ / 2 - v * R,
          zoom: R
        }, { duration: x?.duration, ease: x?.ease, interpolate: x?.interpolate }), Promise.resolve(!0);
      },
      cancelConnection: () => {
        h({
          connection: { ...X9 }
        });
      },
      updateConnection: (b) => {
        h({ connection: b });
      },
      reset: () => h({ ...oj() })
    };
  }, Object.is);
  function vve({ initialNodes: e, initialEdges: t, defaultNodes: n, defaultEdges: r, initialWidth: o, initialHeight: i, initialMinZoom: a, initialMaxZoom: s, initialFitViewOptions: l, fitView: u, nodeOrigin: d, nodeExtent: p, children: h }) {
    const [g] = T.useState(() => yve({
      nodes: e,
      edges: t,
      defaultNodes: n,
      defaultEdges: r,
      width: o,
      height: i,
      fitView: u,
      minZoom: a,
      maxZoom: s,
      fitViewOptions: l,
      nodeOrigin: d,
      nodeExtent: p
    }));
    return S.jsx(Fge, { value: g, children: S.jsx(sye, { children: h }) });
  }
  function bve({ children: e, nodes: t, edges: n, defaultNodes: r, defaultEdges: o, width: i, height: a, fitView: s, fitViewOptions: l, minZoom: u, maxZoom: d, nodeOrigin: p, nodeExtent: h }) {
    return T.useContext(Vb) ? S.jsx(S.Fragment, { children: e }) : S.jsx(vve, { initialNodes: t, initialEdges: n, defaultNodes: r, defaultEdges: o, initialWidth: i, initialHeight: a, fitView: s, initialFitViewOptions: l, initialMinZoom: u, initialMaxZoom: d, nodeOrigin: p, nodeExtent: h, children: e });
  }
  const xve = {
    width: "100%",
    height: "100%",
    overflow: "hidden",
    position: "relative",
    zIndex: 0
  };
  function wve({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, className: o, nodeTypes: i, edgeTypes: a, onNodeClick: s, onEdgeClick: l, onInit: u, onMove: d, onMoveStart: p, onMoveEnd: h, onConnect: g, onConnectStart: y, onConnectEnd: b, onClickConnectStart: v, onClickConnectEnd: x, onNodeMouseEnter: E, onNodeMouseMove: _, onNodeMouseLeave: C, onNodeContextMenu: k, onNodeDoubleClick: R, onNodeDragStart: A, onNodeDrag: M, onNodeDragStop: I, onNodesDelete: D, onEdgesDelete: L, onDelete: P, onSelectionChange: B, onSelectionDragStart: j, onSelectionDrag: V, onSelectionDragStop: F, onSelectionContextMenu: G, onSelectionStart: W, onSelectionEnd: K, onBeforeDelete: $, connectionMode: U, connectionLineType: X = zs.Bezier, connectionLineStyle: z, connectionLineComponent: H, connectionLineContainerStyle: Y, deleteKeyCode: Q = "Backspace", selectionKeyCode: re = "Shift", selectionOnDrag: te = !1, selectionMode: le = ih.Full, panActivationKeyCode: fe = "Space", multiSelectionKeyCode: J = v0() ? "Meta" : "Control", zoomActivationKeyCode: ee = v0() ? "Meta" : "Control", snapToGrid: ie, snapGrid: ae, onlyRenderVisibleElements: ge = !1, selectNodesOnDrag: Ce, nodesDraggable: Ne, autoPanOnNodeFocus: Le, nodesConnectable: Ve, nodesFocusable: Ke, nodeOrigin: ze = CB, edgesFocusable: Me, edgesReconnectable: ct, elementsSelectable: wt = !0, defaultViewport: Re = Zge, minZoom: oe = 0.5, maxZoom: ue = 2, translateExtent: Se = oh, preventScrolling: _e = !0, nodeExtent: Ae, defaultMarkerColor: Ue = "#b1b1b7", zoomOnScroll: Ft = !0, zoomOnPinch: ut = !0, panOnScroll: sn = !1, panOnScrollSpeed: Ie = 0.5, panOnScrollMode: tt = Jl.Free, zoomOnDoubleClick: Ct = !0, panOnDrag: Sn = !0, onPaneClick: $o, onPaneMouseEnter: ns, onPaneMouseMove: pl, onPaneMouseLeave: Zt, onPaneScroll: On, onPaneContextMenu: rs, paneClickDistance: ii = 0, nodeClickDistance: _r = 0, children: zf, onReconnect: vm, onReconnectStart: P1, onReconnectEnd: ai, onEdgeContextMenu: Yn, onEdgeDoubleClick: ur, onEdgeMouseEnter: os, onEdgeMouseMove: Bf, onEdgeMouseLeave: $1, reconnectRadius: I1 = 10, onNodesChange: bm, onEdgesChange: hl, noDragClassName: Uf = "nodrag", noWheelClassName: is = "nowheel", noPanClassName: ta = "nopan", fitView: as, fitViewOptions: na, connectOnClick: $n, attributionPosition: xm, proOptions: wm, defaultEdgeOptions: ra, elevateNodesOnSelect: ss, elevateEdgesOnSelect: j1, disableKeyboardA11y: Vf = !1, autoPanOnConnect: Sm, autoPanOnNodeDrag: D1, autoPanSpeed: Ac, connectionRadius: Nc, isValidConnection: Io, onError: Hf, style: _m, id: oa, nodeDragThreshold: qf, connectionDragThreshold: Wf, viewport: F1, onViewportChange: Em, width: Nr, height: Cm, colorMode: L1 = "light", debug: Mc, onScroll: Gf, ariaLabelConfig: Pc, ...z1 }, Mr) {
    const ml = oa || "1", km = tye(L1), Kf = T.useCallback((ia) => {
      ia.currentTarget.scrollTo({ top: 0, left: 0, behavior: "instant" }), Gf?.(ia);
    }, [Gf]);
    return S.jsx("div", { "data-testid": "rf__wrapper", ...z1, onScroll: Kf, style: { ..._m, ...xve }, ref: Mr, className: Vn(["react-flow", o, km]), id: oa, role: "application", children: S.jsxs(bve, { nodes: e, edges: t, width: Nr, height: Cm, fitView: as, fitViewOptions: na, minZoom: oe, maxZoom: ue, nodeOrigin: ze, nodeExtent: Ae, children: [S.jsx(gve, { onInit: u, onNodeClick: s, onEdgeClick: l, onNodeMouseEnter: E, onNodeMouseMove: _, onNodeMouseLeave: C, onNodeContextMenu: k, onNodeDoubleClick: R, nodeTypes: i, edgeTypes: a, connectionLineType: X, connectionLineStyle: z, connectionLineComponent: H, connectionLineContainerStyle: Y, selectionKeyCode: re, selectionOnDrag: te, selectionMode: le, deleteKeyCode: Q, multiSelectionKeyCode: J, panActivationKeyCode: fe, zoomActivationKeyCode: ee, onlyRenderVisibleElements: ge, defaultViewport: Re, translateExtent: Se, minZoom: oe, maxZoom: ue, preventScrolling: _e, zoomOnScroll: Ft, zoomOnPinch: ut, zoomOnDoubleClick: Ct, panOnScroll: sn, panOnScrollSpeed: Ie, panOnScrollMode: tt, panOnDrag: Sn, onPaneClick: $o, onPaneMouseEnter: ns, onPaneMouseMove: pl, onPaneMouseLeave: Zt, onPaneScroll: On, onPaneContextMenu: rs, paneClickDistance: ii, nodeClickDistance: _r, onSelectionContextMenu: G, onSelectionStart: W, onSelectionEnd: K, onReconnect: vm, onReconnectStart: P1, onReconnectEnd: ai, onEdgeContextMenu: Yn, onEdgeDoubleClick: ur, onEdgeMouseEnter: os, onEdgeMouseMove: Bf, onEdgeMouseLeave: $1, reconnectRadius: I1, defaultMarkerColor: Ue, noDragClassName: Uf, noWheelClassName: is, noPanClassName: ta, rfId: ml, disableKeyboardA11y: Vf, nodeExtent: Ae, viewport: F1, onViewportChange: Em }), S.jsx(eye, { nodes: e, edges: t, defaultNodes: n, defaultEdges: r, onConnect: g, onConnectStart: y, onConnectEnd: b, onClickConnectStart: v, onClickConnectEnd: x, nodesDraggable: Ne, autoPanOnNodeFocus: Le, nodesConnectable: Ve, nodesFocusable: Ke, edgesFocusable: Me, edgesReconnectable: ct, elementsSelectable: wt, elevateNodesOnSelect: ss, elevateEdgesOnSelect: j1, minZoom: oe, maxZoom: ue, nodeExtent: Ae, onNodesChange: bm, onEdgesChange: hl, snapToGrid: ie, snapGrid: ae, connectionMode: U, translateExtent: Se, connectOnClick: $n, defaultEdgeOptions: ra, fitView: as, fitViewOptions: na, onNodesDelete: D, onEdgesDelete: L, onDelete: P, onNodeDragStart: A, onNodeDrag: M, onNodeDragStop: I, onSelectionDrag: V, onSelectionDragStart: j, onSelectionDragStop: F, onMove: d, onMoveStart: p, onMoveEnd: h, noPanClassName: ta, nodeOrigin: ze, rfId: ml, autoPanOnConnect: Sm, autoPanOnNodeDrag: D1, autoPanSpeed: Ac, onError: Hf, connectionRadius: Nc, isValidConnection: Io, selectNodesOnDrag: Ce, nodeDragThreshold: qf, connectionDragThreshold: Wf, onBeforeDelete: $, paneClickDistance: ii, debug: Mc, ariaLabelConfig: Pc }), S.jsx(Xge, { onSelectionChange: B }), zf, S.jsx(qge, { proOptions: wm, position: xm }), S.jsx(Hge, { rfId: ml, disableKeyboardA11y: Vf })] }) });
  }
  var Sve = RB(wve);
  function _ve({ dimensions: e, lineWidth: t, variant: n, className: r }) {
    return S.jsx("path", { strokeWidth: t, d: `M${e[0] / 2} 0 V${e[1]} M0 ${e[1] / 2} H${e[0]}`, className: Vn(["react-flow__background-pattern", n, r]) });
  }
  function Eve({ radius: e, className: t }) {
    return S.jsx("circle", { cx: e, cy: e, r: e, className: Vn(["react-flow__background-pattern", "dots", t]) });
  }
  var kr;
  (function(e) {
    e.Lines = "lines", e.Dots = "dots", e.Cross = "cross";
  })(kr || (kr = {}));
  const Cve = {
    [kr.Dots]: 1,
    [kr.Lines]: 1,
    [kr.Cross]: 6
  }, kve = (e) => ({ transform: e.transform, patternId: `pattern-${e.rfId}` });
  function QB({
    id: e,
    variant: t = kr.Dots,
    // only used for dots and cross
    gap: n = 20,
    // only used for lines and cross
    size: r,
    lineWidth: o = 1,
    offset: i = 0,
    color: a,
    bgColor: s,
    style: l,
    className: u,
    patternClassName: d
  }) {
    const p = T.useRef(null), { transform: h, patternId: g } = Mt(kve, xn), y = r || Cve[t], b = t === kr.Dots, v = t === kr.Cross, x = Array.isArray(n) ? n : [n, n], E = [x[0] * h[2] || 1, x[1] * h[2] || 1], _ = y * h[2], C = Array.isArray(i) ? i : [i, i], k = v ? [_, _] : E, R = [
      C[0] * h[2] || 1 + k[0] / 2,
      C[1] * h[2] || 1 + k[1] / 2
    ], A = `${g}${e || ""}`;
    return S.jsxs("svg", { className: Vn(["react-flow__background", u]), style: {
      ...l,
      ...qb,
      "--xy-background-color-props": s,
      "--xy-background-pattern-color-props": a
    }, ref: p, "data-testid": "rf__background", children: [S.jsx("pattern", { id: A, x: h[0] % E[0], y: h[1] % E[1], width: E[0], height: E[1], patternUnits: "userSpaceOnUse", patternTransform: `translate(-${R[0]},-${R[1]})`, children: b ? S.jsx(Eve, { radius: _ / 2, className: d }) : S.jsx(_ve, { dimensions: k, lineWidth: o, variant: t, className: d }) }), S.jsx("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: `url(#${A})` })] });
  }
  QB.displayName = "Background";
  const Tve = T.memo(QB);
  function Rve() {
    return S.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", children: S.jsx("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" }) });
  }
  function Ove() {
    return S.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 5", children: S.jsx("path", { d: "M0 0h32v4.2H0z" }) });
  }
  function Ave() {
    return S.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 30", children: S.jsx("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" }) });
  }
  function Nve() {
    return S.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: S.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" }) });
  }
  function Mve() {
    return S.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: S.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z" }) });
  }
  function sy({ children: e, className: t, ...n }) {
    return S.jsx("button", { type: "button", className: Vn(["react-flow__controls-button", t]), ...n, children: e });
  }
  const Pve = (e) => ({
    isInteractive: e.nodesDraggable || e.nodesConnectable || e.elementsSelectable,
    minZoomReached: e.transform[2] <= e.minZoom,
    maxZoomReached: e.transform[2] >= e.maxZoom,
    ariaLabelConfig: e.ariaLabelConfig
  });
  function JB({ style: e, showZoom: t = !0, showFitView: n = !0, showInteractive: r = !0, fitViewOptions: o, onZoomIn: i, onZoomOut: a, onFitView: s, onInteractiveChange: l, className: u, children: d, position: p = "bottom-left", orientation: h = "vertical", "aria-label": g }) {
    const y = vn(), { isInteractive: b, minZoomReached: v, maxZoomReached: x, ariaLabelConfig: E } = Mt(Pve, xn), { zoomIn: _, zoomOut: C, fitView: k } = yc(), R = () => {
      _(), i?.();
    }, A = () => {
      C(), a?.();
    }, M = () => {
      k(o), s?.();
    }, I = () => {
      y.setState({
        nodesDraggable: !b,
        nodesConnectable: !b,
        elementsSelectable: !b
      }), l?.(!b);
    }, D = h === "horizontal" ? "horizontal" : "vertical";
    return S.jsxs(Hb, { className: Vn(["react-flow__controls", D, u]), position: p, style: e, "data-testid": "rf__controls", "aria-label": g ?? E["controls.ariaLabel"], children: [t && S.jsxs(S.Fragment, { children: [S.jsx(sy, { onClick: R, className: "react-flow__controls-zoomin", title: E["controls.zoomIn.ariaLabel"], "aria-label": E["controls.zoomIn.ariaLabel"], disabled: x, children: S.jsx(Rve, {}) }), S.jsx(sy, { onClick: A, className: "react-flow__controls-zoomout", title: E["controls.zoomOut.ariaLabel"], "aria-label": E["controls.zoomOut.ariaLabel"], disabled: v, children: S.jsx(Ove, {}) })] }), n && S.jsx(sy, { className: "react-flow__controls-fitview", onClick: M, title: E["controls.fitView.ariaLabel"], "aria-label": E["controls.fitView.ariaLabel"], children: S.jsx(Ave, {}) }), r && S.jsx(sy, { className: "react-flow__controls-interactive", onClick: I, title: E["controls.interactive.ariaLabel"], "aria-label": E["controls.interactive.ariaLabel"], children: b ? S.jsx(Mve, {}) : S.jsx(Nve, {}) }), d] });
  }
  JB.displayName = "Controls";
  T.memo(JB);
  function $ve({ id: e, x: t, y: n, width: r, height: o, style: i, color: a, strokeColor: s, strokeWidth: l, className: u, borderRadius: d, shapeRendering: p, selected: h, onClick: g }) {
    const { background: y, backgroundColor: b } = i || {}, v = a || y || b;
    return S.jsx("rect", { className: Vn(["react-flow__minimap-node", { selected: h }, u]), x: t, y: n, rx: d, ry: d, width: r, height: o, style: {
      fill: v,
      stroke: s,
      strokeWidth: l
    }, shapeRendering: p, onClick: g ? (x) => g(x, e) : void 0 });
  }
  const Ive = T.memo($ve), jve = (e) => e.nodes.map((t) => t.id), YS = (e) => e instanceof Function ? e : () => e;
  function Dve({
    nodeStrokeColor: e,
    nodeColor: t,
    nodeClassName: n = "",
    nodeBorderRadius: r = 5,
    nodeStrokeWidth: o,
    /*
     * We need to rename the prop to be `CapitalCase` so that JSX will render it as
     * a component properly.
     */
    nodeComponent: i = Ive,
    onClick: a
  }) {
    const s = Mt(jve, xn), l = YS(t), u = YS(e), d = YS(n), p = typeof window > "u" || window.chrome ? "crispEdges" : "geometricPrecision";
    return S.jsx(S.Fragment, { children: s.map((h) => (
      /*
       * The split of responsibilities between MiniMapNodes and
       * NodeComponentWrapper may appear weird. However, its designed to
       * minimize the cost of updates when individual nodes change.
       *
       * For more details, see a similar commit in `NodeRenderer/index.tsx`.
       */
      S.jsx(Lve, { id: h, nodeColorFunc: l, nodeStrokeColorFunc: u, nodeClassNameFunc: d, nodeBorderRadius: r, nodeStrokeWidth: o, NodeComponent: i, onClick: a, shapeRendering: p }, h)
    )) });
  }
  function Fve({ id: e, nodeColorFunc: t, nodeStrokeColorFunc: n, nodeClassNameFunc: r, nodeBorderRadius: o, nodeStrokeWidth: i, shapeRendering: a, NodeComponent: s, onClick: l }) {
    const { node: u, x: d, y: p, width: h, height: g } = Mt((y) => {
      const { internals: b } = y.nodeLookup.get(e), v = b.userNode, { x, y: E } = b.positionAbsolute, { width: _, height: C } = Xa(v);
      return {
        node: v,
        x,
        y: E,
        width: _,
        height: C
      };
    }, xn);
    return !u || u.hidden || !rB(u) ? null : S.jsx(s, { x: d, y: p, width: h, height: g, style: u.style, selected: !!u.selected, className: r(u), color: t(u), borderRadius: o, strokeColor: n(u), strokeWidth: i, shapeRendering: a, onClick: l, id: u.id });
  }
  const Lve = T.memo(Fve);
  var zve = T.memo(Dve);
  const Bve = 200, Uve = 150, Vve = (e) => !e.hidden, Hve = (e) => {
    const t = {
      x: -e.transform[0] / e.transform[2],
      y: -e.transform[1] / e.transform[2],
      width: e.width / e.transform[2],
      height: e.height / e.transform[2]
    };
    return {
      viewBB: t,
      boundingRect: e.nodeLookup.size > 0 ? nB(Zh(e.nodeLookup, { filter: Vve }), t) : t,
      rfId: e.rfId,
      panZoom: e.panZoom,
      translateExtent: e.translateExtent,
      flowWidth: e.width,
      flowHeight: e.height,
      ariaLabelConfig: e.ariaLabelConfig
    };
  }, qve = "react-flow__minimap-desc";
  function e8({
    style: e,
    className: t,
    nodeStrokeColor: n,
    nodeColor: r,
    nodeClassName: o = "",
    nodeBorderRadius: i = 5,
    nodeStrokeWidth: a,
    /*
     * We need to rename the prop to be `CapitalCase` so that JSX will render it as
     * a component properly.
     */
    nodeComponent: s,
    bgColor: l,
    maskColor: u,
    maskStrokeColor: d,
    maskStrokeWidth: p,
    position: h = "bottom-right",
    onClick: g,
    onNodeClick: y,
    pannable: b = !1,
    zoomable: v = !1,
    ariaLabel: x,
    inversePan: E,
    zoomStep: _ = 10,
    offsetScale: C = 5
  }) {
    const k = vn(), R = T.useRef(null), { boundingRect: A, viewBB: M, rfId: I, panZoom: D, translateExtent: L, flowWidth: P, flowHeight: B, ariaLabelConfig: j } = Mt(Hve, xn), V = e?.width ?? Bve, F = e?.height ?? Uve, G = A.width / V, W = A.height / F, K = Math.max(G, W), $ = K * V, U = K * F, X = C * K, z = A.x - ($ - A.width) / 2 - X, H = A.y - (U - A.height) / 2 - X, Y = $ + X * 2, Q = U + X * 2, re = `${qve}-${I}`, te = T.useRef(0), le = T.useRef();
    te.current = K, T.useEffect(() => {
      if (R.current && D)
        return le.current = yge({
          domNode: R.current,
          panZoom: D,
          getTransform: () => k.getState().transform,
          getViewScale: () => te.current
        }), () => {
          le.current?.destroy();
        };
    }, [D]), T.useEffect(() => {
      le.current?.update({
        translateExtent: L,
        width: P,
        height: B,
        inversePan: E,
        pannable: b,
        zoomStep: _,
        zoomable: v
      });
    }, [b, v, E, _, L, P, B]);
    const fe = g ? (ie) => {
      const [ae, ge] = le.current?.pointer(ie) || [0, 0];
      g(ie, { x: ae, y: ge });
    } : void 0, J = y ? T.useCallback((ie, ae) => {
      const ge = k.getState().nodeLookup.get(ae).internals.userNode;
      y(ie, ge);
    }, []) : void 0, ee = x ?? j["minimap.ariaLabel"];
    return S.jsx(Hb, { position: h, style: {
      ...e,
      "--xy-minimap-background-color-props": typeof l == "string" ? l : void 0,
      "--xy-minimap-mask-background-color-props": typeof u == "string" ? u : void 0,
      "--xy-minimap-mask-stroke-color-props": typeof d == "string" ? d : void 0,
      "--xy-minimap-mask-stroke-width-props": typeof p == "number" ? p * K : void 0,
      "--xy-minimap-node-background-color-props": typeof r == "string" ? r : void 0,
      "--xy-minimap-node-stroke-color-props": typeof n == "string" ? n : void 0,
      "--xy-minimap-node-stroke-width-props": typeof a == "number" ? a : void 0
    }, className: Vn(["react-flow__minimap", t]), "data-testid": "rf__minimap", children: S.jsxs("svg", { width: V, height: F, viewBox: `${z} ${H} ${Y} ${Q}`, className: "react-flow__minimap-svg", role: "img", "aria-labelledby": re, ref: R, onClick: fe, children: [ee && S.jsx("title", { id: re, children: ee }), S.jsx(zve, { onClick: J, nodeColor: r, nodeStrokeColor: n, nodeBorderRadius: i, nodeClassName: o, nodeStrokeWidth: a, nodeComponent: s }), S.jsx("path", { className: "react-flow__minimap-mask", d: `M${z - X},${H - X}h${Y + X * 2}v${Q + X * 2}h${-Y - X * 2}z
        M${M.x},${M.y}h${M.width}v${M.height}h${-M.width}z`, fillRule: "evenodd", pointerEvents: "none" })] }) });
  }
  e8.displayName = "MiniMap";
  const Wve = T.memo(e8), Gve = (e) => (t) => e ? `${Math.max(1 / t.transform[2], 1)}` : void 0, Kve = {
    [pf.Line]: "right",
    [pf.Handle]: "bottom-right"
  };
  function Yve({ nodeId: e, position: t, variant: n = pf.Handle, className: r, style: o = void 0, children: i, color: a, minWidth: s = 10, minHeight: l = 10, maxWidth: u = Number.MAX_VALUE, maxHeight: d = Number.MAX_VALUE, keepAspectRatio: p = !1, resizeDirection: h, autoScale: g = !0, shouldResize: y, onResizeStart: b, onResize: v, onResizeEnd: x }) {
    const E = MB(), _ = typeof e == "string" ? e : E, C = vn(), k = T.useRef(null), R = n === pf.Handle, A = Mt(T.useCallback(Gve(R && g), [R, g]), xn), M = T.useRef(null), I = t ?? Kve[n];
    T.useEffect(() => {
      if (!(!k.current || !_))
        return M.current || (M.current = Pge({
          domNode: k.current,
          nodeId: _,
          getStoreItems: () => {
            const { nodeLookup: L, transform: P, snapGrid: B, snapToGrid: j, nodeOrigin: V, domNode: F } = C.getState();
            return {
              nodeLookup: L,
              transform: P,
              snapGrid: B,
              snapToGrid: j,
              nodeOrigin: V,
              paneDomNode: F
            };
          },
          onChange: (L, P) => {
            const { triggerNodeChanges: B, nodeLookup: j, parentLookup: V, nodeOrigin: F } = C.getState(), G = [], W = { x: L.x, y: L.y }, K = j.get(_);
            if (K && K.expandParent && K.parentId) {
              const $ = K.origin ?? F, U = L.width ?? K.measured.width ?? 0, X = L.height ?? K.measured.height ?? 0, z = {
                id: K.id,
                parentId: K.parentId,
                rect: {
                  width: U,
                  height: X,
                  ...oB({
                    x: L.x ?? K.position.x,
                    y: L.y ?? K.position.y
                  }, { width: U, height: X }, K.parentId, j, $)
                }
              }, H = AT([z], j, V, F);
              G.push(...H), W.x = L.x ? Math.max($[0] * U, L.x) : void 0, W.y = L.y ? Math.max($[1] * X, L.y) : void 0;
            }
            if (W.x !== void 0 && W.y !== void 0) {
              const $ = {
                id: _,
                type: "position",
                position: { ...W }
              };
              G.push($);
            }
            if (L.width !== void 0 && L.height !== void 0) {
              const U = {
                id: _,
                type: "dimensions",
                resizing: !0,
                setAttributes: h ? h === "horizontal" ? "width" : "height" : !0,
                dimensions: {
                  width: L.width,
                  height: L.height
                }
              };
              G.push(U);
            }
            for (const $ of P) {
              const U = {
                ...$,
                type: "position"
              };
              G.push(U);
            }
            B(G);
          },
          onEnd: ({ width: L, height: P }) => {
            const B = {
              id: _,
              type: "dimensions",
              resizing: !1,
              dimensions: {
                width: L,
                height: P
              }
            };
            C.getState().triggerNodeChanges([B]);
          }
        })), M.current.update({
          controlPosition: I,
          boundaries: {
            minWidth: s,
            minHeight: l,
            maxWidth: u,
            maxHeight: d
          },
          keepAspectRatio: p,
          resizeDirection: h,
          onResizeStart: b,
          onResize: v,
          onResizeEnd: x,
          shouldResize: y
        }), () => {
          M.current?.destroy();
        };
    }, [
      I,
      s,
      l,
      u,
      d,
      p,
      b,
      v,
      x,
      y
    ]);
    const D = I.split("-");
    return S.jsx("div", { className: Vn(["react-flow__resize-control", "nodrag", ...D, n, r]), ref: k, style: {
      ...o,
      scale: A,
      ...a && { [R ? "backgroundColor" : "borderColor"]: a }
    }, children: i });
  }
  T.memo(Yve);
  function Xve(e, t) {
    if (Object.is(e, t))
      return !0;
    if (typeof e != "object" || e === null || typeof t != "object" || t === null)
      return !1;
    if (e instanceof Map && t instanceof Map) {
      if (e.size !== t.size) return !1;
      for (const [r, o] of e)
        if (!Object.is(o, t.get(r)))
          return !1;
      return !0;
    }
    if (e instanceof Set && t instanceof Set) {
      if (e.size !== t.size) return !1;
      for (const r of e)
        if (!t.has(r))
          return !1;
      return !0;
    }
    const n = Object.keys(e);
    if (n.length !== Object.keys(t).length)
      return !1;
    for (const r of n)
      if (!Object.prototype.hasOwnProperty.call(t, r) || !Object.is(e[r], t[r]))
        return !1;
    return !0;
  }
  const { useRef: Zve } = Tn;
  function PT(e) {
    const t = Zve();
    return (n) => {
      const r = e(n);
      return Xve(t.current, r) ? t.current : t.current = r;
    };
  }
  const Qve = () => {
    const { group: e } = Or();
    return async (t, n) => {
      if (e)
        return await e.group_nodes(t, n);
    };
  }, Jve = () => {
    const { group: e } = Or();
    return async (t) => {
      if (e)
        for (const n of t)
          await e.remove_group(n);
    };
  }, e0e = ({ data: e }) => {
    const t = e?.group?.id || e?.id, n = Jve(), r = T.useCallback(
      (o) => {
        o.stopPropagation(), t && n([t]);
      },
      [t, n]
    );
    return /* @__PURE__ */ S.jsxs("div", { className: "fn-group", children: [
      /* @__PURE__ */ S.jsx(
        "button",
        {
          className: "fn-group-remove",
          title: "Remove group",
          onClick: r,
          children: /* @__PURE__ */ S.jsx(bb, {})
        }
      ),
      "Group"
    ] });
  }, $T = T.memo(
    ({ value: e }) => {
      const t = e?.toString() ?? "", n = Math.round(3 * t.length / 4);
      return /* @__PURE__ */ S.jsx("div", { children: /* @__PURE__ */ S.jsxs("pre", { children: [
        "Bytes(",
        n,
        ")"
      ] }) });
    }
  ), t8 = T.memo(
    ({ value: e }) => typeof e != "string" ? /* @__PURE__ */ S.jsx("div", { children: "Invalid SVG" }) : /* @__PURE__ */ S.jsx(yce, { value: e })
  ), n8 = ({
    value: e,
    preValue: t,
    onLoaded: n
  }) => {
    const [r, o] = T.useState(
      t?.toString() || e?.toString()
    );
    return T.useEffect(() => {
      if (e === t || e == null) return;
      const a = new Image(), s = e.toString();
      return a.onload = () => {
        n?.(), o(s);
      }, a.src = s, () => {
        a.onload = null;
      };
    }, [e, t, n]), r === void 0 ? /* @__PURE__ */ S.jsx(S.Fragment, {}) : typeof r != "string" ? (console.error("ImageRenderer: value is not a string", r), /* @__PURE__ */ S.jsx(S.Fragment, {})) : r.startsWith("data:") || r.startsWith("blob:") ? /* @__PURE__ */ S.jsx(vce, { src: r }) : /* @__PURE__ */ S.jsx(gce, { value: r, format: "jpeg" });
  }, t0e = T.memo(
    ({ value: e }) => {
      let t = "";
      try {
        t = JSON.stringify(e);
      } catch {
      }
      return /* @__PURE__ */ S.jsx("div", { children: /* @__PURE__ */ S.jsx("pre", { children: t }) });
    }
  ), Wb = ({
    value: e
  }) => /* @__PURE__ */ S.jsx(ece, { data: e }), r8 = T.memo(
    ({ value: e }) => {
      if (typeof e != "object" || e == null)
        return /* @__PURE__ */ S.jsx("div", { children: "Invalid Table" });
      if (!("columns" in e && "index" in e && "data" in e))
        return /* @__PURE__ */ S.jsx("div", { children: "Invalid Table" });
      if (!Array.isArray(e.columns) || !Array.isArray(e.index) || !Array.isArray(e.data) || !e.data.every((n) => Array.isArray(n)))
        return /* @__PURE__ */ S.jsx("div", { children: "Invalid Table" });
      const t = {
        columns: e.columns || [],
        index: e.index || [],
        data: e.data || []
      };
      return /* @__PURE__ */ S.jsx(vF, { tabledata: t });
    }
  ), x0 = (e) => /* @__PURE__ */ S.jsx(t0e, { ...e }), w0 = Wb, IT = {
    string: x0,
    str: x0,
    table: r8,
    image: n8,
    svg: t8,
    dict: Wb,
    bytes: $T
  }, n0e = () => {
    const e = wn(), { full: t, preview: n } = e.valuestore(), r = JSON.stringify(t?.value || n?.value) || "";
    return `Bytes(${Math.round(3 * r.length / 4)})`;
  }, r0e = {
    bytes: n0e
  }, Gb = (e) => ({ value: t, preValue: n, onLoaded: r }) => /* @__PURE__ */ S.jsx(e, { value: t, preValue: n, onLoaded: r }), Fr = (e, t = void 0, n = {}) => ({}) => {
    const r = wn(), { full: o, preview: i } = r.valuestore(), s = (o === void 0 ? i : o)?.value || t;
    return /* @__PURE__ */ S.jsx(e, { value: s, ...n });
  }, o8 = (e) => ({}) => /* @__PURE__ */ S.jsx(e, {}), i8 = (e, t = void 0) => ({}) => {
    const n = wn(), { full: r, preview: o } = n.valuestore(), a = (r === void 0 ? o : r)?.value || t;
    return /* @__PURE__ */ S.jsx(e, { value: a });
  }, o0e = {
    ...Object.fromEntries(
      Object.entries(IT).map(([e, t]) => [
        e,
        t ? Gb(t) : void 0
      ])
    )
  }, ij = Gb(Wb), a8 = {
    ...Object.fromEntries(
      Object.entries(IT).map(([e, t]) => [
        e,
        t ? Fr(t) : void 0
      ])
    ),
    string: Fr(x0),
    str: Fr(x0),
    table: Fr(r8, void 0, {
      pageSize: 10
    }),
    image: Fr(n8),
    svg: Fr(t8, ""),
    dict: Fr(Wb, "{}"),
    bytes: Fr($T, "")
  }, i0e = {
    ...Object.fromEntries(
      Object.entries(a8).map(([e, t]) => [
        e,
        t ? o8(t) : void 0
      ])
    )
  }, a0e = () => {
    const e = wn(), { preview: t, full: n } = e.valuestore();
    let r = (JSON.stringify(n || t) || "").replace(/\\n/g, `
`);
    return r.length > 63 && (r = r.slice(0, 60) + "..."), /* @__PURE__ */ S.jsx("div", { children: r });
  }, s0e = {}, l0e = ({ inputconverter: e }) => {
    const t = wn(), { preview: n } = t.valuestore(), r = t.use(), o = n?.value === void 0, i = T.useRef(null), a = Mf(r);
    T.useEffect(() => {
      i.current && (i.current.indeterminate = o);
    }, [i, o]);
    const s = T.useCallback(
      (l) => {
        let u = l.target.checked;
        try {
          u = e[0](l.target.checked);
        } catch {
        }
        a(u);
      },
      [a, e]
    );
    return /* @__PURE__ */ S.jsx(
      "input",
      {
        ref: i,
        type: "checkbox",
        className: "styledcheckbox booleaninput",
        checked: !!e[1](n?.value),
        onChange: s,
        disabled: r.connected
      }
    );
  }, c0e = ({}) => {
    const e = wn(), t = jt(), n = e.use(), { preview: r, full: o } = e.valuestore(), i = o === void 0 ? r?.value : o.value, a = Mf(n), s = typeof i == "string" || Array.isArray(i) && i.every((h) => typeof h == "number") ? i : void 0, l = n.value_options?.colorspace || "hex", u = T.useCallback(
      (h) => {
        let g = "<NoValue>";
        h && (h[l] ? g = h[l]() : g = h.hex()), h === null && (g = null);
        try {
          g = g;
        } catch {
        }
        a(g);
      },
      [a, l]
    );
    let d = !1;
    typeof n.type != "string" && "anyOf" in n.type && n.type.anyOf !== void 0 && (d = n.type.anyOf.some((h) => h === "None"));
    const p = t.local_state(() => t.reactflowRef);
    return /* @__PURE__ */ S.jsx(
      rae,
      {
        onChange: u,
        inicolordata: s,
        allow_null: d,
        inicolorspace: l,
        portalContainer: p
      }
    );
  };
  function s8(e, [t, n]) {
    return Math.min(n, Math.max(t, e));
  }
  var u0e = T.createContext(void 0);
  function Kb(e) {
    const t = T.useContext(u0e);
    return e || t || "ltr";
  }
  function f0e(e) {
    const t = T.useRef({ value: e, previous: e });
    return T.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]);
  }
  var l8 = ["PageUp", "PageDown"], c8 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], u8 = {
    "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
    "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
    "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
    "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
  }, Nf = "Slider", [uC, d0e, p0e] = kb(Nf), [f8, lze] = Yi(Nf, [
    p0e
  ]), [h0e, Yb] = f8(Nf), d8 = T.forwardRef(
    (e, t) => {
      const {
        name: n,
        min: r = 0,
        max: o = 100,
        step: i = 1,
        orientation: a = "horizontal",
        disabled: s = !1,
        minStepsBetweenThumbs: l = 0,
        defaultValue: u = [r],
        value: d,
        onValueChange: p = () => {
        },
        onValueCommit: h = () => {
        },
        inverted: g = !1,
        form: y,
        ...b
      } = e, v = T.useRef(/* @__PURE__ */ new Set()), x = T.useRef(0), _ = a === "horizontal" ? m0e : g0e, [C = [], k] = ll({
        prop: d,
        defaultProp: u,
        onChange: (L) => {
          [...v.current][x.current]?.focus(), p(L);
        }
      }), R = T.useRef(C);
      function A(L) {
        const P = w0e(C, L);
        D(L, P);
      }
      function M(L) {
        D(L, x.current);
      }
      function I() {
        const L = R.current[x.current];
        C[x.current] !== L && h(C);
      }
      function D(L, P, { commit: B } = { commit: !1 }) {
        const j = C0e(i), V = k0e(Math.round((L - r) / i) * i + r, j), F = s8(V, [r, o]);
        k((G = []) => {
          const W = b0e(G, F, P);
          if (E0e(W, l * i)) {
            x.current = W.indexOf(F);
            const K = String(W) !== String(G);
            return K && B && h(W), K ? W : G;
          } else
            return G;
        });
      }
      return /* @__PURE__ */ S.jsx(
        h0e,
        {
          scope: e.__scopeSlider,
          name: n,
          disabled: s,
          min: r,
          max: o,
          valueIndexToChangeRef: x,
          thumbs: v.current,
          values: C,
          orientation: a,
          form: y,
          children: /* @__PURE__ */ S.jsx(uC.Provider, { scope: e.__scopeSlider, children: /* @__PURE__ */ S.jsx(uC.Slot, { scope: e.__scopeSlider, children: /* @__PURE__ */ S.jsx(
            _,
            {
              "aria-disabled": s,
              "data-disabled": s ? "" : void 0,
              ...b,
              ref: t,
              onPointerDown: Fe(b.onPointerDown, () => {
                s || (R.current = C);
              }),
              min: r,
              max: o,
              inverted: g,
              onSlideStart: s ? void 0 : A,
              onSlideMove: s ? void 0 : M,
              onSlideEnd: s ? void 0 : I,
              onHomeKeyDown: () => !s && D(r, 0, { commit: !0 }),
              onEndKeyDown: () => !s && D(o, C.length - 1, { commit: !0 }),
              onStepKeyDown: ({ event: L, direction: P }) => {
                if (!s) {
                  const V = l8.includes(L.key) || L.shiftKey && c8.includes(L.key) ? 10 : 1, F = x.current, G = C[F], W = i * V * P;
                  D(G + W, F, { commit: !0 });
                }
              }
            }
          ) }) })
        }
      );
    }
  );
  d8.displayName = Nf;
  var [p8, h8] = f8(Nf, {
    startEdge: "left",
    endEdge: "right",
    size: "width",
    direction: 1
  }), m0e = T.forwardRef(
    (e, t) => {
      const {
        min: n,
        max: r,
        dir: o,
        inverted: i,
        onSlideStart: a,
        onSlideMove: s,
        onSlideEnd: l,
        onStepKeyDown: u,
        ...d
      } = e, [p, h] = T.useState(null), g = an(t, (_) => h(_)), y = T.useRef(void 0), b = Kb(o), v = b === "ltr", x = v && !i || !v && i;
      function E(_) {
        const C = y.current || p.getBoundingClientRect(), k = [0, C.width], A = jT(k, x ? [n, r] : [r, n]);
        return y.current = C, A(_ - C.left);
      }
      return /* @__PURE__ */ S.jsx(
        p8,
        {
          scope: e.__scopeSlider,
          startEdge: x ? "left" : "right",
          endEdge: x ? "right" : "left",
          direction: x ? 1 : -1,
          size: "width",
          children: /* @__PURE__ */ S.jsx(
            m8,
            {
              dir: b,
              "data-orientation": "horizontal",
              ...d,
              ref: g,
              style: {
                ...d.style,
                "--radix-slider-thumb-transform": "translateX(-50%)"
              },
              onSlideStart: (_) => {
                const C = E(_.clientX);
                a?.(C);
              },
              onSlideMove: (_) => {
                const C = E(_.clientX);
                s?.(C);
              },
              onSlideEnd: () => {
                y.current = void 0, l?.();
              },
              onStepKeyDown: (_) => {
                const k = u8[x ? "from-left" : "from-right"].includes(_.key);
                u?.({ event: _, direction: k ? -1 : 1 });
              }
            }
          )
        }
      );
    }
  ), g0e = T.forwardRef(
    (e, t) => {
      const {
        min: n,
        max: r,
        inverted: o,
        onSlideStart: i,
        onSlideMove: a,
        onSlideEnd: s,
        onStepKeyDown: l,
        ...u
      } = e, d = T.useRef(null), p = an(t, d), h = T.useRef(void 0), g = !o;
      function y(b) {
        const v = h.current || d.current.getBoundingClientRect(), x = [0, v.height], _ = jT(x, g ? [r, n] : [n, r]);
        return h.current = v, _(b - v.top);
      }
      return /* @__PURE__ */ S.jsx(
        p8,
        {
          scope: e.__scopeSlider,
          startEdge: g ? "bottom" : "top",
          endEdge: g ? "top" : "bottom",
          size: "height",
          direction: g ? 1 : -1,
          children: /* @__PURE__ */ S.jsx(
            m8,
            {
              "data-orientation": "vertical",
              ...u,
              ref: p,
              style: {
                ...u.style,
                "--radix-slider-thumb-transform": "translateY(50%)"
              },
              onSlideStart: (b) => {
                const v = y(b.clientY);
                i?.(v);
              },
              onSlideMove: (b) => {
                const v = y(b.clientY);
                a?.(v);
              },
              onSlideEnd: () => {
                h.current = void 0, s?.();
              },
              onStepKeyDown: (b) => {
                const x = u8[g ? "from-bottom" : "from-top"].includes(b.key);
                l?.({ event: b, direction: x ? -1 : 1 });
              }
            }
          )
        }
      );
    }
  ), m8 = T.forwardRef(
    (e, t) => {
      const {
        __scopeSlider: n,
        onSlideStart: r,
        onSlideMove: o,
        onSlideEnd: i,
        onHomeKeyDown: a,
        onEndKeyDown: s,
        onStepKeyDown: l,
        ...u
      } = e, d = Yb(Nf, n);
      return /* @__PURE__ */ S.jsx(
        xt.span,
        {
          ...u,
          ref: t,
          onKeyDown: Fe(e.onKeyDown, (p) => {
            p.key === "Home" ? (a(p), p.preventDefault()) : p.key === "End" ? (s(p), p.preventDefault()) : l8.concat(c8).includes(p.key) && (l(p), p.preventDefault());
          }),
          onPointerDown: Fe(e.onPointerDown, (p) => {
            const h = p.target;
            h.setPointerCapture(p.pointerId), p.preventDefault(), d.thumbs.has(h) ? h.focus() : r(p);
          }),
          onPointerMove: Fe(e.onPointerMove, (p) => {
            p.target.hasPointerCapture(p.pointerId) && o(p);
          }),
          onPointerUp: Fe(e.onPointerUp, (p) => {
            const h = p.target;
            h.hasPointerCapture(p.pointerId) && (h.releasePointerCapture(p.pointerId), i(p));
          })
        }
      );
    }
  ), g8 = "SliderTrack", y8 = T.forwardRef(
    (e, t) => {
      const { __scopeSlider: n, ...r } = e, o = Yb(g8, n);
      return /* @__PURE__ */ S.jsx(
        xt.span,
        {
          "data-disabled": o.disabled ? "" : void 0,
          "data-orientation": o.orientation,
          ...r,
          ref: t
        }
      );
    }
  );
  y8.displayName = g8;
  var fC = "SliderRange", v8 = T.forwardRef(
    (e, t) => {
      const { __scopeSlider: n, ...r } = e, o = Yb(fC, n), i = h8(fC, n), a = T.useRef(null), s = an(t, a), l = o.values.length, u = o.values.map(
        (h) => w8(h, o.min, o.max)
      ), d = l > 1 ? Math.min(...u) : 0, p = 100 - Math.max(...u);
      return /* @__PURE__ */ S.jsx(
        xt.span,
        {
          "data-orientation": o.orientation,
          "data-disabled": o.disabled ? "" : void 0,
          ...r,
          ref: s,
          style: {
            ...e.style,
            [i.startEdge]: d + "%",
            [i.endEdge]: p + "%"
          }
        }
      );
    }
  );
  v8.displayName = fC;
  var dC = "SliderThumb", b8 = T.forwardRef(
    (e, t) => {
      const n = d0e(e.__scopeSlider), [r, o] = T.useState(null), i = an(t, (s) => o(s)), a = T.useMemo(
        () => r ? n().findIndex((s) => s.ref.current === r) : -1,
        [n, r]
      );
      return /* @__PURE__ */ S.jsx(y0e, { ...e, ref: i, index: a });
    }
  ), y0e = T.forwardRef(
    (e, t) => {
      const { __scopeSlider: n, index: r, name: o, ...i } = e, a = Yb(dC, n), s = h8(dC, n), [l, u] = T.useState(null), d = an(t, (E) => u(E)), p = l ? a.form || !!l.closest("form") : !0, h = yz(l), g = a.values[r], y = g === void 0 ? 0 : w8(g, a.min, a.max), b = x0e(r, a.values.length), v = h?.[s.size], x = v ? S0e(v, y, s.direction) : 0;
      return T.useEffect(() => {
        if (l)
          return a.thumbs.add(l), () => {
            a.thumbs.delete(l);
          };
      }, [l, a.thumbs]), /* @__PURE__ */ S.jsxs(
        "span",
        {
          style: {
            transform: "var(--radix-slider-thumb-transform)",
            position: "absolute",
            [s.startEdge]: `calc(${y}% + ${x}px)`
          },
          children: [
            /* @__PURE__ */ S.jsx(uC.ItemSlot, { scope: e.__scopeSlider, children: /* @__PURE__ */ S.jsx(
              xt.span,
              {
                role: "slider",
                "aria-label": e["aria-label"] || b,
                "aria-valuemin": a.min,
                "aria-valuenow": g,
                "aria-valuemax": a.max,
                "aria-orientation": a.orientation,
                "data-orientation": a.orientation,
                "data-disabled": a.disabled ? "" : void 0,
                tabIndex: a.disabled ? void 0 : 0,
                ...i,
                ref: d,
                style: g === void 0 ? { display: "none" } : e.style,
                onFocus: Fe(e.onFocus, () => {
                  a.valueIndexToChangeRef.current = r;
                })
              }
            ) }),
            p && /* @__PURE__ */ S.jsx(
              x8,
              {
                name: o ?? (a.name ? a.name + (a.values.length > 1 ? "[]" : "") : void 0),
                form: a.form,
                value: g
              },
              r
            )
          ]
        }
      );
    }
  );
  b8.displayName = dC;
  var v0e = "RadioBubbleInput", x8 = T.forwardRef(
    ({ __scopeSlider: e, value: t, ...n }, r) => {
      const o = T.useRef(null), i = an(o, r), a = f0e(t);
      return T.useEffect(() => {
        const s = o.current;
        if (!s) return;
        const l = window.HTMLInputElement.prototype, d = Object.getOwnPropertyDescriptor(l, "value").set;
        if (a !== t && d) {
          const p = new Event("input", { bubbles: !0 });
          d.call(s, t), s.dispatchEvent(p);
        }
      }, [a, t]), /* @__PURE__ */ S.jsx(
        xt.input,
        {
          style: { display: "none" },
          ...n,
          ref: i,
          defaultValue: t
        }
      );
    }
  );
  x8.displayName = v0e;
  function b0e(e = [], t, n) {
    const r = [...e];
    return r[n] = t, r.sort((o, i) => o - i);
  }
  function w8(e, t, n) {
    const i = 100 / (n - t) * (e - t);
    return s8(i, [0, 100]);
  }
  function x0e(e, t) {
    return t > 2 ? `Value ${e + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][e] : void 0;
  }
  function w0e(e, t) {
    if (e.length === 1) return 0;
    const n = e.map((o) => Math.abs(o - t)), r = Math.min(...n);
    return n.indexOf(r);
  }
  function S0e(e, t, n) {
    const r = e / 2, i = jT([0, 50], [0, r]);
    return (r - i(t) * n) * n;
  }
  function _0e(e) {
    return e.slice(0, -1).map((t, n) => e[n + 1] - t);
  }
  function E0e(e, t) {
    if (t > 0) {
      const n = _0e(e);
      return Math.min(...n) >= t;
    }
    return !0;
  }
  function jT(e, t) {
    return (n) => {
      if (e[0] === e[1] || t[0] === t[1]) return t[0];
      const r = (t[1] - t[0]) / (e[1] - e[0]);
      return t[0] + r * (n - e[0]);
    };
  }
  function C0e(e) {
    return (String(e).split(".")[1] || "").length;
  }
  function k0e(e, t) {
    const n = Math.pow(10, t);
    return Math.round(e * n) / n;
  }
  var T0e = d8, R0e = y8, O0e = v8, A0e = b8;
  function N0e(e) {
    return e === 0 ? 0 : Math.abs(e) < 1e-12 ? e : Number(e.toPrecision(12));
  }
  const S8 = ({
    inputconverter: e,
    parser: t = (n) => parseFloat(n)
  }) => {
    const n = wn(), { preview: r } = n.valuestore(), o = n.use(), i = Mf(o), [a, s] = T.useState(
      e[1](r?.value)
    );
    T.useEffect(() => {
      s(e[1](r?.value));
    }, [r]);
    const l = T.useCallback(
      (g) => {
        g = t(
          parseFloat(g.toString()).toString()
          // parse float first for e notation
        ), isNaN(g) ? (g = "<NoValue>", s("")) : (o.value_options?.min !== void 0 && g < o.value_options.min && (g = o.value_options.min), o.value_options?.max !== void 0 && g > o.value_options.max && (g = o.value_options.max), g = N0e(g), s(g.toString()));
        try {
          g = e[0](g);
        } catch {
        }
        g !== r?.value && i(g);
      },
      [o, e, i]
    ), u = T.useCallback(
      (g) => {
        l(g.target.value);
      },
      [l]
    );
    let d = o.connected ? e[1](r?.value) : a;
    d === void 0 && (d = o.value_options?.min), d === void 0 && (d = o.value_options?.max), d === void 0 && (d = ""), d === null && (d = "");
    let p = null, h = 1;
    return o.value_options?.step !== void 0 ? h = o.value_options.step : o.value_options?.max !== void 0 && o.value_options?.min !== void 0 && (h = (o.value_options?.max - o.value_options?.min) / 1e3), o.value_options?.max !== void 0 && o.value_options?.min !== void 0 && !o.connected && (p = /* @__PURE__ */ S.jsx("div", { style: { minWidth: "6.25rem" }, className: "SliderContainer", children: /* @__PURE__ */ S.jsxs(
      T0e,
      {
        className: "SliderRoot",
        value: [d === void 0 ? o.value_options?.min : d],
        min: o.value_options?.min,
        max: o.value_options?.max,
        step: h,
        disabled: o.connected,
        onValueCommit: (g) => {
          isNaN(g[0]) || l(g[0]);
        },
        onValueChange: (g) => {
          isNaN(g[0]) || s(g[0].toString());
        },
        onKeyDown: (g) => {
          ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(
            g.key
          ) && g.stopPropagation();
        },
        children: [
          /* @__PURE__ */ S.jsx(R0e, { className: "SliderTrack", children: /* @__PURE__ */ S.jsx(O0e, { className: "SliderRange" }) }),
          /* @__PURE__ */ S.jsx(A0e, { className: "SliderThumb" })
        ]
      }
    ) })), /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      p,
      /* @__PURE__ */ S.jsx(
        "input",
        {
          type: "text",
          className: "nodedatainput styledinput numberinput",
          value: d,
          onChange: (g) => s(g.target.value),
          onBlur: u,
          step: h,
          onKeyDown: (g) => {
            if (!(g.ctrlKey || g.metaKey)) {
              if (g.key === "ArrowUp") {
                g.shiftKey && (h *= 10);
                let y = (parseFloat(d) || 0) + h;
                l(y);
                return;
              }
              if (g.key === "ArrowDown") {
                g.shiftKey && (h *= 10);
                let y = (parseFloat(d) || 0) - h;
                l(y);
                return;
              }
              !/^[0-9.eE+-]$/.test(g.key) && !["Backspace", "ArrowLeft", "ArrowRight", "Delete", "Tab"].includes(
                g.key
              ) && g.preventDefault();
            }
          },
          disabled: o.connected,
          min: o.value_options?.min,
          max: o.value_options?.max
        }
      )
    ] });
  }, M0e = ({ inputconverter: e }) => S8({ inputconverter: e, parser: parseFloat }), P0e = ({ inputconverter: e }) => S8({ inputconverter: e, parser: parseInt }), $0e = (e) => e, I0e = (e) => parseFloat(e), j0e = (e) => !!e, D0e = (e) => e === "null" ? null : e, F0e = (e) => e === "nuinputconvertermber" ? I0e : e === "boolean" ? j0e : e === "undefined" ? D0e : $0e, ch = ({
    inputconverter: e,
    parser: t
  }) => {
    const n = wn(), r = n.use(), { preview: o, full: i } = n.valuestore(), a = i === void 0 ? o?.value : i.value, s = Mf(r);
    let l = r.value_options?.options || [];
    Array.isArray(l) && (l = {
      type: "enum",
      values: l,
      keys: l.map((b) => b === null ? "None" : b.toString()),
      nullable: !1
    }), l.type !== "enum" && (l = {
      type: "enum",
      values: Object.values(l),
      keys: Object.keys(l),
      nullable: !1
    }), l = l, l.nullable && !l.values.includes(null) && !l.keys.includes("None") && (l.values.unshift(null), l.keys.unshift("None"));
    const u = [];
    for (let b = 0; b < l.values.length; b++) {
      const v = l.values[b] === null || l.values[b] === void 0 ? "undefined" : typeof l.values[b];
      let x = l.values[b];
      x === null && (x = "null"), x === void 0 && (x = "undefined"), u.push([l.keys[b], x.toString(), v]);
    }
    const d = T.useCallback(
      ({
        value: b,
        // label
        datatype: v
      }) => {
        let E = (t || F0e(v))(b);
        try {
          E = e[0](b);
        } catch {
        }
        s(E);
      },
      [r, e, s]
    );
    let p = a;
    p === null && (p = "null"), p === void 0 && (p = "undefined");
    const h = u.find((b) => b[1] === p.toString());
    let g;
    h !== void 0 && (g = {
      value: h[1],
      label: h[0],
      datatype: h[2]
    });
    const y = u.map(
      (b) => ({
        value: b[1],
        label: b[0],
        datatype: b[2]
      })
    );
    return (
      // <Suspense fallback={<select disabled={true}></select>}>
      /* @__PURE__ */ S.jsx(
        jle,
        {
          className: "nodedatainput styleddropdown",
          options: y,
          defaultValue: g,
          onChange: (b) => {
            if (b === null) {
              d({
                value: "<NoValue>",
                datatype: "string"
              });
              return;
            }
            d(b);
          }
        }
      )
    );
  }, aj = ({ inputconverter: e }) => {
    const t = wn(), { preview: n, full: r } = t.valuestore(), o = t.use(), i = r === void 0 ? n?.value : r?.value, a = Mf(o), [s, l] = T.useState(e[1](i));
    T.useEffect(() => {
      l(e[1](i));
    }, [i]);
    const u = T.useCallback(
      (g) => {
        let y = g.target.value;
        y || (y = "<NoValue>");
        try {
          y = e[0](y);
        } catch {
        }
        y !== i && a(y);
      },
      [a, e, i]
    );
    let d = o.connected ? e[1](i) : s;
    d == null && (d = ""), d = d.toString();
    const p = (d.toString().match(/\n/g) || []).length, h = Math.max(...d.split(`
`).map((g) => g.length), 0);
    return /* @__PURE__ */ S.jsx(
      "textarea",
      {
        className: "nodedatainput styledinput stringinput",
        value: d,
        onChange: (g) => l(g.target.value),
        onBlur: (g) => {
          u(g);
        },
        disabled: o.connected,
        rows: p + 1,
        cols: h + 1
      }
    );
  }, L0e = {
    float: M0e,
    int: P0e,
    bool: l0e,
    string: aj,
    str: aj,
    color: c0e,
    select: ch,
    enum: ch,
    bytes: i8($T, "")
  }, z0e = {}, B0e = {}, gi = {
    Inputrenderer: L0e,
    Outputrenderer: s0e,
    HandlePreviewRenderer: i0e,
    DataOverlayRenderer: o0e,
    DataPreviewViewRenderer: a8,
    DataViewRenderer: IT,
    InLineRenderer: r0e,
    NodeRenderer: z0e,
    NodeHooks: B0e
  }, U0e = (e, t) => {
    const n = t.options || {}, r = n.overwrite === void 0 ? !0 : n.overwrite;
    switch (t.type) {
      case "EXTEND_INPUT_RENDER":
        return !r && e.Inputrenderer[t.payload.type] ? e : {
          ...e,
          Inputrenderer: {
            ...e.Inputrenderer,
            [t.payload.type]: t.payload.component
          }
        };
      case "EXTEND_FROM_PLUGIN": {
        let a = !1;
        const s = [
          [t.payload.plugin.input_renderers || {}, e.Inputrenderer],
          [t.payload.plugin.output_renderers || {}, e.Outputrenderer],
          [
            t.payload.plugin.handle_preview_renderers || {},
            e.HandlePreviewRenderer
          ],
          [
            t.payload.plugin.data_overlay_renderers || {},
            e.DataOverlayRenderer
          ],
          [
            t.payload.plugin.data_preview_renderers || {},
            e.DataPreviewViewRenderer
          ],
          [
            t.payload.plugin.data_view_renderers || {},
            e.DataViewRenderer
          ],
          [t.payload.plugin.node_renderers || {}, e.NodeRenderer],
          [t.payload.plugin.node_hooks || {}, e.NodeHooks]
        ];
        for (const [u, d] of s) {
          if (Object.keys(u).length > 0) {
            if (r)
              a = !0;
            else
              for (const p in u)
                if (!d[p]) {
                  a = !0;
                  break;
                }
          }
          if (a) break;
        }
        if (!a)
          return e;
        const l = { ...e };
        return s.forEach(([u, d]) => {
          Object.assign(d, u);
        }), l;
      }
      default:
        const i = {
          EXTEND_OUTPUT_RENDER: "Outputrenderer",
          EXTEND_HANDLE_PREVIEW_RENDER: "HandlePreviewRenderer",
          EXTEND_DATA_OVERLAY_RENDER: "DataOverlayRenderer",
          EXTEND_DATA_PREVIEW_RENDER: "DataPreviewViewRenderer",
          EXTEND_DATA_VIEW_RENDER: "DataViewRenderer",
          EXTEND_NODE_CONTEXT_EXTENDER: "NodeContextExtenders",
          EXTEND_NODE_RENDERER: "NodeRenderer",
          EXTEND_NODE_HOOKS: "NodeHooks"
        }[t.type];
        if (i) {
          const a = e[i];
          return !r && a[t.payload.type] ? e : {
            ...e,
            [i]: {
              ...a,
              [t.payload.type]: t.payload.component
            }
          };
        }
        return e;
    }
  }, V0e = ({
    children: e,
    plugins: t,
    fnrf_zst: n
  }) => {
    const [r, o] = T.useReducer(
      U0e,
      gi
    ), i = (y, b, v) => {
      o({
        type: "EXTEND_INPUT_RENDER",
        payload: { type: y, component: b },
        options: v
      });
    }, a = (y, b, v) => {
      o({
        type: "EXTEND_OUTPUT_RENDER",
        payload: { type: y, component: b },
        options: v
      });
    }, s = (y, b, v) => {
      o({
        type: "EXTEND_HANDLE_PREVIEW_RENDER",
        payload: { type: y, component: b },
        options: v
      });
    }, l = (y, b, v) => {
      o({
        type: "EXTEND_DATA_OVERLAY_RENDER",
        payload: { type: y, component: b },
        options: v
      });
    }, u = (y, b, v) => {
      o({
        type: "EXTEND_DATA_PREVIEW_RENDER",
        payload: { type: y, component: b },
        options: v
      });
    }, d = (y, b, v) => {
      o({
        type: "EXTEND_DATA_VIEW_RENDER",
        payload: { type: y, component: b },
        options: v
      });
    }, p = (y, b, v) => {
      o({
        type: "EXTEND_NODE_RENDERER",
        payload: { type: y, component: b },
        options: v
      });
    }, h = (y, b, v) => {
      o({
        type: "EXTEND_NODE_HOOKS",
        payload: { type: y, component: b },
        options: v
      });
    }, g = (y, b) => {
      o({
        type: "EXTEND_FROM_PLUGIN",
        payload: { plugin: y },
        options: b
      });
    };
    return T.useEffect(() => {
      for (const y in t) {
        const b = t[y];
        if (!b) continue;
        const v = b.renderpluginfactory;
        v && g(v({ React: ec, fnrf_zst: n, NodeContext: Xb }));
      }
    }, [t]), /* @__PURE__ */ S.jsx(
      Za.Provider,
      {
        value: {
          Inputrenderer: r.Inputrenderer,
          Outputrenderer: r.Outputrenderer,
          HandlePreviewRenderer: r.HandlePreviewRenderer,
          DataOverlayRenderer: r.DataOverlayRenderer,
          DataPreviewViewRenderer: r.DataPreviewViewRenderer,
          DataViewRenderer: r.DataViewRenderer,
          InLineRenderer: r.InLineRenderer,
          NodeRenderer: r.NodeRenderer,
          NodeHooks: r.NodeHooks,
          extendNodeRenderer: p,
          extendInputRenderMapping: i,
          extendOutputRenderMapping: a,
          extendHandlePreviewRenderMapping: s,
          extendDataOverlayRenderMapping: l,
          extendDataPreviewRenderMapping: u,
          extendDataViewRenderMapping: d,
          extendNodeHooks: h,
          extendFromPlugin: g
        },
        children: e
      }
    );
  }, Za = T.createContext({
    Inputrenderer: gi.Inputrenderer,
    Outputrenderer: gi.Outputrenderer,
    HandlePreviewRenderer: gi.HandlePreviewRenderer,
    DataOverlayRenderer: gi.DataOverlayRenderer,
    DataPreviewViewRenderer: gi.DataPreviewViewRenderer,
    DataViewRenderer: gi.DataViewRenderer,
    InLineRenderer: gi.InLineRenderer,
    NodeRenderer: gi.NodeRenderer,
    NodeHooks: gi.NodeHooks,
    extendInputRenderMapping: (e, t, n) => {
    },
    extendOutputRenderMapping: (e, t, n) => {
    },
    extendHandlePreviewRenderMapping: (e, t, n) => {
    },
    extendDataOverlayRenderMapping: (e, t, n) => {
    },
    extendDataPreviewRenderMapping: (e, t, n) => {
    },
    extendDataViewRenderMapping: (e, t, n) => {
    },
    extendNodeRenderer: (e, t, n) => {
    },
    extendNodeHooks: (e, t, n) => {
    },
    extendFromPlugin: (e, t) => {
    }
  }), _8 = (e) => {
    const t = jt(), { DataOverlayRenderer: n, DataViewRenderer: r } = T.useContext(Za);
    if (e === void 0) return;
    const o = t.render_options(), [i] = vc(e, o.typemap || {});
    return i ? n[i] ? n[i] : r[i] ? Gb(r[i]) : ij : ij;
  }, H0e = (e) => {
    const t = jt(), n = _8(e), { DataPreviewViewRenderer: r, DataViewRenderer: o } = T.useContext(Za), i = t.render_options();
    if (e === void 0) return [void 0, n];
    const [a] = vc(e, i.typemap || {});
    return a ? r[a] ? [r[a], n] : o[a] ? [
      Fr(o[a]),
      n
    ] : [
      Fr(w0),
      n
    ] : [
      Fr(w0),
      n
    ];
  }, q0e = (e) => {
    const n = jt().render_options(), { HandlePreviewRenderer: r, DataPreviewViewRenderer: o } = T.useContext(Za), i = _8(e);
    let a;
    if (e) {
      const [s] = vc(e, n.typemap || {});
      s ? r[s] ? a = r[s] : o[s] ? a = o[s] : a = Fr(
        w0
      ) : a = Fr(
        w0
      );
    }
    return [a, i];
  }, W0e = (e) => {
    const [t, n] = T.useState(!1), r = e.use((o) => o.in_trigger);
    return T.useEffect(() => {
      let o;
      return r && !t ? n(!0) : t && (o = setTimeout(() => n(!1), 200)), () => clearTimeout(o);
    }, [r, t]), { visualTrigger: t, nodestore: e };
  }, Xb = T.createContext({}), fo = () => T.useContext(Xb), rl = T.createContext(void 0);
  function wn(e) {
    if (e)
      return fo().io_stores.get(e);
    {
      const t = T.useContext(rl);
      if (!t)
        throw new Error("IOContext not set");
      return t;
    }
  }
  function Mf(e) {
    const { node: t } = Or();
    if (e || (e = wn().use()), typeof e == "string" && (e = wn(e)?.use(), !e))
      throw new Error(`No IO found for ${e}`);
    if (!e)
      throw new Error("No IO found");
    return T.useCallback(
      (r, o) => {
        t?.set_io_value({
          nid: e.node,
          ioid: e.id,
          value: r,
          set_default: o ?? e.render_options.set_default
        });
      },
      [e, t]
    );
  }
  function G0e(e) {
    const { node: t } = Or();
    let n, r;
    if (!e) {
      const a = wn().useShallow((s) => ({
        io_id: s.id,
        node_id: s.node
      }));
      n = a.io_id, r = a.node_id;
    }
    if (typeof e == "string") {
      const i = wn(e);
      if (!i)
        throw new Error(`No IO found for ${e}`);
      const a = i.useShallow((s) => ({
        io_id: s.id,
        node_id: s.node
      }));
      n = a.io_id, r = a.node_id;
    } else {
      if (!e)
        throw new Error("No IO found");
      n = e.id, r = e.node;
    }
    return T.useCallback(
      (i) => {
        t?.set_io_value_options({
          nid: r,
          ioid: n,
          values: i.values ?? i.keys,
          keys: i.keys,
          nullable: i.nullable ?? !1
        });
      },
      [t, n, r]
    );
  }
  function K0e(e) {
    return wn(e)?.valuestore();
  }
  function Zb(e) {
    const t = wn(e);
    if (!t) return;
    const { node: n, id: r } = t.useShallow((a) => ({
      node: a.node,
      id: a.id
    })), { node: o } = Or();
    return T.useCallback(() => o?.get_io_full_value({ nid: n, ioid: r }), [o, n, r]);
  }
  function DT(e) {
    const t = wn(e);
    if (!t) return;
    const { node: n, id: r } = t.useShallow((a) => ({
      node: a.node,
      id: a.id
    })), { node: o } = Or();
    return T.useCallback(
      (a) => {
        o?.update_io_options({
          nid: n,
          ioid: r,
          options: { hidden: a }
        });
      },
      [o, n, r]
    );
  }
  const E8 = ({
    iostore: e,
    Component: t
  }) => {
    const [n, r] = T.useState(void 0), [o, i] = T.useState(void 0), { full: a } = e.valuestore(), s = Zb();
    T.useEffect(() => {
      a === void 0 ? s?.() : i(a.value);
    }, [a, s]);
    const l = () => {
      o !== void 0 && r(o);
    };
    return /* @__PURE__ */ S.jsx(
      t,
      {
        value: o,
        preValue: n,
        onLoaded: l
      }
    );
  }, C8 = ({
    Component: e
  }) => /* @__PURE__ */ S.jsx(e, {}), vc = (e, t) => k8(e.render_options?.type ?? "any", t), k8 = (e, t) => {
    if (typeof e == "string")
      return e in t ? [t[e], e] : [e, e];
    if ("allOf" in e && e.allOf !== void 0)
      return [void 0, void 0];
    if ("anyOf" in e && e.anyOf !== void 0) {
      const n = e.anyOf.map(
        (r) => k8(r || "any", t)
      );
      for (const r of n)
        switch (r[0]) {
          case "bool":
            return ["bool", r[1]];
          case "enum":
            return ["enum", r[1]];
          case "float":
            return ["float", r[1]];
          case "int":
            return ["int", r[1]];
          case "string":
            return ["string", r[1]];
          case "str":
            return ["string", r[1]];
        }
      return [void 0, void 0];
    }
    return !("type" in e) || e.type === void 0 ? [void 0, void 0] : e.type === "enum" ? ["enum", "enum"] : [void 0, void 0];
  }, pC = ({
    typestring: e,
    preview: t,
    ...n
  }) => {
    const [r, o] = T.useState(!1), [i, a] = T.useState(!1), s = jt(), l = wn(), u = l.use(), d = Zb(), [p, h] = q0e(u), g = s.local_state(() => s.reactflowRef);
    return (
      // <Tooltip.Provider>
      /* @__PURE__ */ S.jsxs(zz, { open: r || i, onOpenChange: a, children: [
        /* @__PURE__ */ S.jsx(Bz, { asChild: !0, children: /* @__PURE__ */ S.jsx(lh, { id: u.id, "data-type": e, ...n }) }),
        /* @__PURE__ */ S.jsx(Uz, { container: g, children: /* @__PURE__ */ S.jsxs(
          Vz,
          {
            className: "iotooltipcontent",
            sideOffset: 5,
            avoidCollisions: !0,
            collisionBoundary: g,
            collisionPadding: 10,
            onOpenAutoFocus: (y) => y.preventDefault(),
            onCloseAutoFocus: (y) => y.preventDefault(),
            children: [
              /* @__PURE__ */ S.jsxs("div", { className: "iotooltip_container", children: [
                /* @__PURE__ */ S.jsxs("div", { className: "iotooltip_header", children: [
                  u.name,
                  r ? /* @__PURE__ */ S.jsx(uoe, { onClick: () => o(!1) }) : /* @__PURE__ */ S.jsx(coe, { onClick: () => o(!0) }),
                  h && /* @__PURE__ */ S.jsx(
                    Ga,
                    {
                      title: u.full_id,
                      trigger: /* @__PURE__ */ S.jsx(QL, {}),
                      onOpenChange: (y) => {
                        y && d?.(), o(y);
                      },
                      children: /* @__PURE__ */ S.jsx(
                        E8,
                        {
                          Component: h,
                          iostore: l
                        }
                      )
                    }
                  )
                ] }),
                p ? /* @__PURE__ */ S.jsx(C8, { Component: p }) : `no preview available for "${e}"`
              ] }),
              /* @__PURE__ */ S.jsx(qie, { className: "iotooltipcontentarrow" })
            ]
          }
        ) })
      ] })
    );
  }, hf = {
    "": [(e) => e, (e) => e],
    str_to_json: [
      (e) => JSON.parse(e),
      (e) => typeof e == "string" ? e : JSON.stringify(e)
    ],
    str_to_list: [
      (e) => {
        try {
          const t = JSON.parse(e);
          return Array.isArray(t) ? t : [t];
        } catch {
          try {
            return JSON.parse("[" + e + "]");
          } catch {
          }
        }
        throw new Error("Invalid list");
      },
      (e) => JSON.stringify(e)
    ]
  }, Y0e = ({
    setNodeSettingsPath: e,
    setShowSettings: t
  }) => {
    const r = jt().render_options(), i = wn().use(), [a, s] = vc(i, r.typemap || {}), { Inputrenderer: l } = T.useContext(Za), u = a ? i.value_options?.options ? ch : l[a] : void 0, d = hf[(s && r.inputconverter?.[s]) ?? ""] || hf[""], { keys: p } = Vk(), h = (g) => {
      p.has("s") && (e && e("inputs/" + i.id), t && t(!0), g.stopPropagation());
    };
    return i.hidden ? null : /* @__PURE__ */ S.jsxs(
      "div",
      {
        className: "nodeinput",
        "data-type": a,
        onClick: h,
        children: [
          /* @__PURE__ */ S.jsx(
            pC,
            {
              typestring: a,
              position: qe.Left,
              type: "target"
            }
          ),
          /* @__PURE__ */ S.jsxs("div", { className: "inner_nodeio", children: [
            u && /* @__PURE__ */ S.jsx("div", { className: "iovaluefield nodrag", "data-type": a, children: /* @__PURE__ */ S.jsx(u, { inputconverter: d }) }),
            /* @__PURE__ */ S.jsx("div", { className: "ioname", children: i.name })
          ] }),
          /* @__PURE__ */ S.jsx(
            pC,
            {
              typestring: a,
              position: qe.Right,
              type: "source"
            }
          )
        ]
      }
    );
  }, X0e = ({
    setNodeSettingsPath: e,
    setShowSettings: t
  }) => {
    const r = jt().render_options(), i = wn().use(), [a] = vc(i, r.typemap || {}), { Outputrenderer: s } = T.useContext(Za), { keys: l } = Vk(), u = a ? s[a] : void 0, d = (p) => {
      l.has("s") && (e && e("outputs/" + i.id), t && t(!0), p.stopPropagation());
    };
    return i.hidden ? null : /* @__PURE__ */ S.jsxs(
      "div",
      {
        className: "nodeoutput",
        "data-type": a,
        onClick: d,
        children: [
          /* @__PURE__ */ S.jsx(
            pC,
            {
              typestring: a,
              position: qe.Right,
              type: "source"
            }
          ),
          /* @__PURE__ */ S.jsxs("div", { className: "inner_nodeio", children: [
            /* @__PURE__ */ S.jsx("div", { className: "ioname", children: i.name }),
            u ? /* @__PURE__ */ S.jsx("div", { className: "iovaluefield nodrag", children: /* @__PURE__ */ S.jsx(u, {}) }) : /* @__PURE__ */ S.jsx("div", { className: "iovaluefield", children: /* @__PURE__ */ S.jsx(a0e, {}) })
          ] })
        ]
      }
    );
  }, Z0e = () => {
    const t = jt().render_options(), r = wn().use(), o = DT(), [i, a] = vc(r, t.typemap || {}), { Inputrenderer: s } = T.useContext(Za), l = i ? r.value_options?.options ? ch : s[i] : void 0, u = hf[(a && t.inputconverter?.[a]) ?? ""] || hf[""];
    return /* @__PURE__ */ S.jsxs("div", { className: "nodesettings_component", children: [
      /* @__PURE__ */ S.jsx("div", { children: r.name }),
      l && /* @__PURE__ */ S.jsx(l, { inputconverter: u }),
      /* @__PURE__ */ S.jsx("div", { children: /* @__PURE__ */ S.jsxs("label", { children: [
        "hidden:",
        /* @__PURE__ */ S.jsx(
          "input",
          {
            className: "styledcheckbox",
            type: "checkbox",
            disabled: r.connected,
            onChange: (d) => {
              o?.(d.target.checked);
            },
            checked: r.hidden
          }
        )
      ] }) })
    ] });
  }, Q0e = () => {
    const t = wn().use(), n = DT();
    return /* @__PURE__ */ S.jsxs("div", { className: "nodesettings_component", children: [
      /* @__PURE__ */ S.jsx("div", { children: t.name }),
      /* @__PURE__ */ S.jsx("div", { children: /* @__PURE__ */ S.jsxs("label", { children: [
        "hidden:",
        /* @__PURE__ */ S.jsx(
          "input",
          {
            className: "styledcheckbox",
            type: "checkbox",
            disabled: t.connected,
            onChange: (r) => {
              n?.(r.target.checked);
            },
            checked: t.hidden
          }
        )
      ] }) })
    ] });
  }, T8 = ({}) => {
    const e = jt(), { node: t } = Or(), r = wn().use(), o = e.render_options(), i = DT(), [a, s] = T.useState(r.name);
    T.useEffect(() => s(r.name), [r.name]);
    const l = T.useCallback(
      (b) => s(b.target.value),
      []
    ), u = T.useCallback(() => {
      a !== r.name && t?.update_io_options({
        nid: r.node,
        ioid: r.id,
        options: { name: a }
      });
    }, [r, t, a]), [d, p] = vc(
      r,
      o.typemap || {}
    ), h = hf[(p && o.inputconverter?.[p]) ?? ""] || hf[""], { Inputrenderer: g } = T.useContext(Za), y = d ? r.value_options?.options ? ch : g[d] : void 0;
    return /* @__PURE__ */ S.jsxs("div", { className: "nodesettings-io-entry funcnodes-control-group", children: [
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { htmlFor: `io-name-${r.id}`, children: "Name:" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            id: `io-name-${r.id}`,
            type: "text",
            value: a,
            onChange: l,
            onBlur: u,
            className: "styledinput"
          }
        )
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "ID:" }),
        /* @__PURE__ */ S.jsx("span", { children: r.id })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Value:" }),
        y && /* @__PURE__ */ S.jsx(y, { inputconverter: h })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Type:" }),
        /* @__PURE__ */ S.jsx("pre", { children: JSON.stringify(r.type, null, 2) })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { htmlFor: `io-hidden-${r.id}`, children: "Hidden:" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            id: `io-hidden-${r.id}`,
            type: "checkbox",
            checked: r.hidden,
            onChange: (b) => i?.(b.target.checked),
            className: "styledcheckbox",
            disabled: r.connected && r.is_input
          }
        )
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Value Options:" }),
        /* @__PURE__ */ S.jsx("pre", { children: JSON.stringify(r.value_options, null, 2) })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Render Options:" }),
        /* @__PURE__ */ S.jsx("pre", { className: "code-display", children: JSON.stringify(r.render_options, null, 2) })
      ] }),
      r.is_input && /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
        /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
          /* @__PURE__ */ S.jsx("label", { children: "Does Trigger:" }),
          /* @__PURE__ */ S.jsx("span", { children: String(r.does_trigger) })
        ] }),
        /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
          /* @__PURE__ */ S.jsx("label", { children: "Required:" }),
          /* @__PURE__ */ S.jsx("span", { children: String(r.required) })
        ] })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Emit Value Set:" }),
        /* @__PURE__ */ S.jsx("span", { children: String(r.emit_value_set) })
      ] }),
      /* @__PURE__ */ S.jsx("hr", {})
    ] });
  }, hC = {
    xxs: 0,
    xs: 320,
    s: 480,
    m: 768,
    l: 960,
    xl: 1280,
    xxl: 1920
  }, J0e = Object.entries(hC).sort(
    ([, e], [, t]) => t - e
  ), R8 = T.createContext(void 0), ebe = (e, t) => {
    let n;
    return (...r) => {
      clearTimeout(n), n = setTimeout(() => e(...r), t);
    };
  }, tbe = (e) => {
    for (const [t, n] of J0e)
      if (e >= n)
        return t;
    return "xxs";
  }, O8 = T.memo(
    T.forwardRef(
      (e, t) => {
        const { className: n, children: r, ...o } = e, [i, a] = T.useState(
          {
            wKey: "m",
            w: 0,
            h: 0
          }
        ), s = T.useRef(null);
        T.useImperativeHandle(
          t,
          () => s.current,
          []
        );
        const l = T.useCallback((d) => {
          const p = d.width, h = d.height, g = tbe(p);
          a((y) => y.wKey === g && y.w === p && y.h === h ? y : { wKey: g, w: p, h });
        }, []), u = T.useMemo(
          () => ebe(l, 16),
          [l]
        );
        return T.useEffect(() => {
          const d = s.current;
          if (!d)
            return;
          const p = new ResizeObserver((h) => {
            const g = h[0];
            g && u(g.contentRect);
          });
          return l(d.getBoundingClientRect()), p.observe(d), () => {
            p.disconnect();
          };
        }, [l, u]), /* @__PURE__ */ S.jsx(R8.Provider, { value: i, children: /* @__PURE__ */ S.jsx(
          "div",
          {
            ref: s,
            className: `size-context w-${i.wKey} ${n || ""}`.trim(),
            ...o,
            children: r
          }
        ) });
      }
    )
  );
  O8.displayName = "SizeContextContainer";
  const nbe = () => {
    const e = T.useContext(R8);
    if (!e)
      throw new Error(
        "useSizeContext must be used within a SizeContextContainerContext"
      );
    return e;
  }, rbe = (e, t) => e === t ? !1 : e === "" ? !0 : hC[e] < hC[t], obe = (e) => {
    const { wKey: t } = nbe();
    return rbe(t, e);
  }, sj = (e, t, n = "", r = "") => {
    const o = [];
    return typeof e == "string" ? o.push(`${t}-${e}`) : typeof e == "boolean" ? o.push(e ? n : r) : e && typeof e == "object" && Object.entries(e).forEach(([i, a]) => {
      if (typeof a == "string")
        o.push(
          i === "" ? `${t}-${a}` : `${i}-${t}-${a}`
        );
      else if (typeof a == "boolean") {
        const s = a ? n : r;
        s && o.push(i === "" ? s : `${i}-${s}`);
      }
    }), o.filter(Boolean).join(" ");
  }, Ws = T.memo(
    ({
      direction: e,
      className: t = "",
      children: n,
      wrap: r = !1,
      grow: o = !1,
      ...i
    }) => {
      const a = "float-container", s = sj(e, "direction"), l = sj(o, "", "grow", "no-grow"), d = [
        a,
        s,
        l,
        typeof r == "boolean" && r ? "flex-wrap" : "",
        t
      ].filter(Boolean).join(" ");
      return /* @__PURE__ */ S.jsx("div", { className: d, ...i, children: n });
    }
  );
  Ws.displayName = "FloatContainer";
  const ibe = {
    up: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" }),
    down: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" }),
    left: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" }),
    right: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" })
  }, abe = {
    up: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" }),
    down: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" }),
    left: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" }),
    right: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" })
  }, FT = T.memo(
    ({
      direction: e,
      expanded: t = !0,
      children: n,
      className: r,
      maxSize: o = "18.75rem",
      expanderSize: i = "2rem",
      containerStyle: a,
      style: s,
      containerClassName: l,
      expandIcons: u,
      collapseIcons: d,
      onExpandChange: p,
      ...h
    }) => {
      const [g, y] = T.useState(t);
      T.useEffect(() => {
        y(t);
      }, [t]);
      const b = T.useCallback(() => {
        y((D) => {
          const L = !D;
          return p?.(L), L;
        });
      }, [p]), v = T.useCallback(
        (D) => {
          (D.key === "Enter" || D.key === " ") && (D.preventDefault(), b());
        },
        [b]
      ), x = e === "right" || e === "left", E = e === "left" || e === "up", _ = g ? d?.[e] || abe[e] : u?.[e] || ibe[e], C = `${e} ${g ? "expanded" : "collapsed"}`, k = T.useMemo(
        () => ({
          [x ? "width" : "height"]: g ? o : i
        }),
        [x, g, o, i]
      ), R = T.useMemo(
        () => ({
          [x ? "width" : "height"]: g ? o : 0
        }),
        [x, g, o]
      ), A = T.useMemo(
        () => ({
          [x ? "width" : "height"]: i
        }),
        [x, i]
      ), M = /* @__PURE__ */ S.jsx(
        "div",
        {
          className: `expanding_container_content ${C} ${r || ""}`.trim(),
          style: { ...s, ...R },
          ...h,
          children: n
        }
      ), I = /* @__PURE__ */ S.jsx(
        "div",
        {
          className: `expanding_container_expander ${C}`,
          onClick: b,
          onKeyDown: v,
          style: A,
          role: "button",
          tabIndex: 0,
          "aria-label": `${g ? "Collapse" : "Expand"} ${e}`,
          children: /* @__PURE__ */ S.jsx(_, {})
        }
      );
      return /* @__PURE__ */ S.jsxs(
        "div",
        {
          className: `expanding_container ${C} ${l || ""}`,
          style: { ...a, ...k },
          children: [
            E ? I : M,
            E ? M : I
          ]
        }
      );
    }
  );
  FT.displayName = "ExpandingContainer";
  const sbe = ({ nodestore: e }) => {
    const t = e.use();
    return /* @__PURE__ */ S.jsx(Xb.Provider, { value: e, children: /* @__PURE__ */ S.jsxs("div", { className: "nodesettings_content", children: [
      /* @__PURE__ */ S.jsx("div", { className: "nodesettings_section", children: /* @__PURE__ */ S.jsxs("div", { className: "nodesettings_component", children: [
        /* @__PURE__ */ S.jsx("div", { children: "Name" }),
        /* @__PURE__ */ S.jsx("div", { children: /* @__PURE__ */ S.jsx(UT, {}) })
      ] }) }),
      /* @__PURE__ */ S.jsxs("div", { className: "nodesettings_section", children: [
        /* @__PURE__ */ S.jsx("div", { children: "Inputs" }),
        t.inputs.map((n) => {
          const r = e.io_stores.get(n);
          if (r)
            return /* @__PURE__ */ S.jsx(rl.Provider, { value: r, children: /* @__PURE__ */ S.jsx(Z0e, {}) }, n);
        })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "nodesettings_section", children: [
        /* @__PURE__ */ S.jsx("div", { children: "Outputs" }),
        t.outputs.map((n) => {
          const r = e.io_stores.get(n);
          if (r)
            return /* @__PURE__ */ S.jsx(rl.Provider, { value: r, children: /* @__PURE__ */ S.jsx(Q0e, {}) }, n);
        })
      ] })
    ] }) });
  }, lbe = () => {
    const e = jt(), t = e.local_state((r) => r.selected_nodes);
    if (t.length === 0)
      return /* @__PURE__ */ S.jsx("div", { children: "Node Settings" });
    if (t.length > 1)
      return /* @__PURE__ */ S.jsx("div", { children: "Multiple Nodes Selected" });
    const n = e.nodespace.get_node(t[0]);
    return n ? /* @__PURE__ */ S.jsx(sbe, { nodestore: n }) : /* @__PURE__ */ S.jsx("div", { children: "Node not found" });
  }, cbe = () => {
    const e = jt(), t = e.local_settings(
      (r) => r.view_settings.expand_node_props
    ), n = (r) => {
      e.update_view_settings({ expand_node_props: r });
    };
    return /* @__PURE__ */ S.jsx(
      FT,
      {
        direction: "left",
        expanded: t === void 0 ? !1 : t,
        containerClassName: "pos-right pos-top bg1 h-12",
        className: "nodesettings_content",
        onExpandChange: n,
        collapseIcons: {
          up: Xv,
          down: Yp,
          left: Kp,
          right: Yv
        },
        expandIcons: {
          up: Yp,
          down: Xv,
          left: Yv,
          right: Kp
        },
        children: /* @__PURE__ */ S.jsx(lbe, {})
      }
    );
  };
  var XS = "rovingFocusGroup.onEntryFocus", ube = { bubbles: !1, cancelable: !0 }, em = "RovingFocusGroup", [mC, A8, fbe] = kb(em), [dbe, Qb] = Yi(
    em,
    [fbe]
  ), [pbe, hbe] = dbe(em), N8 = T.forwardRef(
    (e, t) => /* @__PURE__ */ S.jsx(mC.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ S.jsx(mC.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ S.jsx(mbe, { ...e, ref: t }) }) })
  );
  N8.displayName = em;
  var mbe = T.forwardRef((e, t) => {
    const {
      __scopeRovingFocusGroup: n,
      orientation: r,
      loop: o = !1,
      dir: i,
      currentTabStopId: a,
      defaultCurrentTabStopId: s,
      onCurrentTabStopIdChange: l,
      onEntryFocus: u,
      preventScrollOnEntryFocus: d = !1,
      ...p
    } = e, h = T.useRef(null), g = an(t, h), y = Kb(i), [b, v] = ll({
      prop: a,
      defaultProp: s ?? null,
      onChange: l,
      caller: em
    }), [x, E] = T.useState(!1), _ = Vr(u), C = A8(n), k = T.useRef(!1), [R, A] = T.useState(0);
    return T.useEffect(() => {
      const M = h.current;
      if (M)
        return M.addEventListener(XS, _), () => M.removeEventListener(XS, _);
    }, [_]), /* @__PURE__ */ S.jsx(
      pbe,
      {
        scope: n,
        orientation: r,
        dir: y,
        loop: o,
        currentTabStopId: b,
        onItemFocus: T.useCallback(
          (M) => v(M),
          [v]
        ),
        onItemShiftTab: T.useCallback(() => E(!0), []),
        onFocusableItemAdd: T.useCallback(
          () => A((M) => M + 1),
          []
        ),
        onFocusableItemRemove: T.useCallback(
          () => A((M) => M - 1),
          []
        ),
        children: /* @__PURE__ */ S.jsx(
          xt.div,
          {
            tabIndex: x || R === 0 ? -1 : 0,
            "data-orientation": r,
            ...p,
            ref: g,
            style: { outline: "none", ...e.style },
            onMouseDown: Fe(e.onMouseDown, () => {
              k.current = !0;
            }),
            onFocus: Fe(e.onFocus, (M) => {
              const I = !k.current;
              if (M.target === M.currentTarget && I && !x) {
                const D = new CustomEvent(XS, ube);
                if (M.currentTarget.dispatchEvent(D), !D.defaultPrevented) {
                  const L = C().filter((F) => F.focusable), P = L.find((F) => F.active), B = L.find((F) => F.id === b), V = [P, B, ...L].filter(
                    Boolean
                  ).map((F) => F.ref.current);
                  $8(V, d);
                }
              }
              k.current = !1;
            }),
            onBlur: Fe(e.onBlur, () => E(!1))
          }
        )
      }
    );
  }), M8 = "RovingFocusGroupItem", P8 = T.forwardRef(
    (e, t) => {
      const {
        __scopeRovingFocusGroup: n,
        focusable: r = !0,
        active: o = !1,
        tabStopId: i,
        children: a,
        ...s
      } = e, l = Bi(), u = i || l, d = hbe(M8, n), p = d.currentTabStopId === u, h = A8(n), { onFocusableItemAdd: g, onFocusableItemRemove: y, currentTabStopId: b } = d;
      return T.useEffect(() => {
        if (r)
          return g(), () => y();
      }, [r, g, y]), /* @__PURE__ */ S.jsx(
        mC.ItemSlot,
        {
          scope: n,
          id: u,
          focusable: r,
          active: o,
          children: /* @__PURE__ */ S.jsx(
            xt.span,
            {
              tabIndex: p ? 0 : -1,
              "data-orientation": d.orientation,
              ...s,
              ref: t,
              onMouseDown: Fe(e.onMouseDown, (v) => {
                r ? d.onItemFocus(u) : v.preventDefault();
              }),
              onFocus: Fe(e.onFocus, () => d.onItemFocus(u)),
              onKeyDown: Fe(e.onKeyDown, (v) => {
                if (v.key === "Tab" && v.shiftKey) {
                  d.onItemShiftTab();
                  return;
                }
                if (v.target !== v.currentTarget) return;
                const x = vbe(v, d.orientation, d.dir);
                if (x !== void 0) {
                  if (v.metaKey || v.ctrlKey || v.altKey || v.shiftKey) return;
                  v.preventDefault();
                  let _ = h().filter((C) => C.focusable).map((C) => C.ref.current);
                  if (x === "last") _.reverse();
                  else if (x === "prev" || x === "next") {
                    x === "prev" && _.reverse();
                    const C = _.indexOf(v.currentTarget);
                    _ = d.loop ? bbe(_, C + 1) : _.slice(C + 1);
                  }
                  setTimeout(() => $8(_));
                }
              }),
              children: typeof a == "function" ? a({ isCurrentTabStop: p, hasTabStop: b != null }) : a
            }
          )
        }
      );
    }
  );
  P8.displayName = M8;
  var gbe = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last"
  };
  function ybe(e, t) {
    return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
  }
  function vbe(e, t, n) {
    const r = ybe(e.key, n);
    if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
      return gbe[r];
  }
  function $8(e, t = !1) {
    const n = document.activeElement;
    for (const r of e)
      if (r === n || (r.focus({ preventScroll: t }), document.activeElement !== n)) return;
  }
  function bbe(e, t) {
    return e.map((n, r) => e[(t + r) % e.length]);
  }
  var I8 = N8, j8 = P8, Jb = "Tabs", [xbe, cze] = Yi(Jb, [
    Qb
  ]), D8 = Qb(), [wbe, LT] = xbe(Jb), F8 = T.forwardRef(
    (e, t) => {
      const {
        __scopeTabs: n,
        value: r,
        onValueChange: o,
        defaultValue: i,
        orientation: a = "horizontal",
        dir: s,
        activationMode: l = "automatic",
        ...u
      } = e, d = Kb(s), [p, h] = ll({
        prop: r,
        onChange: o,
        defaultProp: i ?? "",
        caller: Jb
      });
      return /* @__PURE__ */ S.jsx(
        wbe,
        {
          scope: n,
          baseId: Bi(),
          value: p,
          onValueChange: h,
          orientation: a,
          dir: d,
          activationMode: l,
          children: /* @__PURE__ */ S.jsx(
            xt.div,
            {
              dir: d,
              "data-orientation": a,
              ...u,
              ref: t
            }
          )
        }
      );
    }
  );
  F8.displayName = Jb;
  var L8 = "TabsList", z8 = T.forwardRef(
    (e, t) => {
      const { __scopeTabs: n, loop: r = !0, ...o } = e, i = LT(L8, n), a = D8(n);
      return /* @__PURE__ */ S.jsx(
        I8,
        {
          asChild: !0,
          ...a,
          orientation: i.orientation,
          dir: i.dir,
          loop: r,
          children: /* @__PURE__ */ S.jsx(
            xt.div,
            {
              role: "tablist",
              "aria-orientation": i.orientation,
              ...o,
              ref: t
            }
          )
        }
      );
    }
  );
  z8.displayName = L8;
  var B8 = "TabsTrigger", U8 = T.forwardRef(
    (e, t) => {
      const { __scopeTabs: n, value: r, disabled: o = !1, ...i } = e, a = LT(B8, n), s = D8(n), l = q8(a.baseId, r), u = W8(a.baseId, r), d = r === a.value;
      return /* @__PURE__ */ S.jsx(
        j8,
        {
          asChild: !0,
          ...s,
          focusable: !o,
          active: d,
          children: /* @__PURE__ */ S.jsx(
            xt.button,
            {
              type: "button",
              role: "tab",
              "aria-selected": d,
              "aria-controls": u,
              "data-state": d ? "active" : "inactive",
              "data-disabled": o ? "" : void 0,
              disabled: o,
              id: l,
              ...i,
              ref: t,
              onMouseDown: Fe(e.onMouseDown, (p) => {
                !o && p.button === 0 && p.ctrlKey === !1 ? a.onValueChange(r) : p.preventDefault();
              }),
              onKeyDown: Fe(e.onKeyDown, (p) => {
                [" ", "Enter"].includes(p.key) && a.onValueChange(r);
              }),
              onFocus: Fe(e.onFocus, () => {
                const p = a.activationMode !== "manual";
                !d && !o && p && a.onValueChange(r);
              })
            }
          )
        }
      );
    }
  );
  U8.displayName = B8;
  var V8 = "TabsContent", H8 = T.forwardRef(
    (e, t) => {
      const { __scopeTabs: n, value: r, forceMount: o, children: i, ...a } = e, s = LT(V8, n), l = q8(s.baseId, r), u = W8(s.baseId, r), d = r === s.value, p = T.useRef(d);
      return T.useEffect(() => {
        const h = requestAnimationFrame(() => p.current = !1);
        return () => cancelAnimationFrame(h);
      }, []), /* @__PURE__ */ S.jsx(ei, { present: o || d, children: ({ present: h }) => /* @__PURE__ */ S.jsx(
        xt.div,
        {
          "data-state": d ? "active" : "inactive",
          "data-orientation": s.orientation,
          role: "tabpanel",
          "aria-labelledby": l,
          hidden: !h,
          id: u,
          tabIndex: 0,
          ...a,
          ref: t,
          style: {
            ...e.style,
            animationDuration: p.current ? "0s" : void 0
          },
          children: h && i
        }
      ) });
    }
  );
  H8.displayName = V8;
  function q8(e, t) {
    return `${e}-trigger-${t}`;
  }
  function W8(e, t) {
    return `${e}-content-${t}`;
  }
  var zT = F8, BT = z8, Ap = U8, Np = H8;
  const Sbe = ({}) => {
    const e = jt(), t = fo(), { description: n, id: r, node_id: o, node_name: i, reset_inputs_on_trigger: a } = t.useShallow((p) => ({
      description: p.description,
      id: p.id,
      node_id: p.node_id,
      node_name: p.node_name,
      reset_inputs_on_trigger: p.reset_inputs_on_trigger
    })), [s, l] = T.useState(
      n || ""
    );
    T.useEffect(() => l(n || ""), [n]);
    const u = (p) => l(p.target.value), d = () => {
      s !== (n || "") && e.on_node_action({
        type: "update",
        from_remote: !1,
        id: r,
        node: { description: s }
      });
    };
    return /* @__PURE__ */ S.jsxs("div", { className: "nodesettings-section funcnodes-control-group", children: [
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { htmlFor: `node-name-${r}`, children: "Name:" }),
        /* @__PURE__ */ S.jsx(UT, {})
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Instance ID:" }),
        /* @__PURE__ */ S.jsx("span", { children: r })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Node Type ID:" }),
        /* @__PURE__ */ S.jsx("span", { children: o })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Node Type Name:" }),
        /* @__PURE__ */ S.jsx("span", { children: i })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { htmlFor: `node-desc-${r}`, children: "Description:" }),
        /* @__PURE__ */ S.jsx(
          "textarea",
          {
            id: `node-desc-${r}`,
            value: s,
            onChange: u,
            onBlur: d,
            className: "styledinput",
            rows: 3
          }
        )
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Reset Inputs on Trigger:" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "checkbox",
            checked: a,
            onChange: (p) => {
              e.on_node_action({
                type: "update",
                from_remote: !1,
                id: r,
                node: { reset_inputs_on_trigger: p.target.checked }
              });
            },
            className: "styledcheckbox"
          }
        )
      ] })
    ] });
  }, _be = ({ splitnodesettingsPath: e = [] }) => {
    const t = fo(), n = t.use((r) => r.inputs);
    return /* @__PURE__ */ S.jsxs(
      zT,
      {
        defaultValue: e[0] || n[0],
        className: "nodesettings-tabs funcnodes-control-root",
        children: [
          /* @__PURE__ */ S.jsx(
            BT,
            {
              className: "nodesettings-tabs-list",
              "aria-label": "Manage node inputs",
              children: n.map((r) => /* @__PURE__ */ S.jsx(
                Ap,
                {
                  value: r,
                  className: "nodesettings-tabs-trigger",
                  children: r
                },
                r
              ))
            }
          ),
          n.map((r) => {
            const o = t.io_stores.get(r);
            return /* @__PURE__ */ S.jsx(
              Np,
              {
                value: r,
                className: "nodesettings-tabs-content nodesettings-io-list",
                children: o && /* @__PURE__ */ S.jsx(rl.Provider, { value: o, children: /* @__PURE__ */ S.jsx(T8, {}) })
              },
              r
            );
          })
        ]
      }
    );
  }, Ebe = ({ splitnodesettingsPath: e = [] }) => {
    const t = fo(), n = t.use((r) => r.outputs);
    return /* @__PURE__ */ S.jsxs(
      zT,
      {
        defaultValue: e[0] || n[0],
        className: "nodesettings-tabs funcnodes-control-root",
        children: [
          /* @__PURE__ */ S.jsx(
            BT,
            {
              className: "nodesettings-tabs-list",
              "aria-label": "Manage node outputs",
              children: n.map((r) => /* @__PURE__ */ S.jsx(
                Ap,
                {
                  value: r,
                  className: "nodesettings-tabs-trigger",
                  children: r
                },
                r
              ))
            }
          ),
          n.map((r) => {
            const o = t.io_stores.get(r);
            return /* @__PURE__ */ S.jsx(
              Np,
              {
                value: r,
                className: "nodesettings-tabs-content nodesettings-io-list",
                children: o && /* @__PURE__ */ S.jsx(rl.Provider, { value: o, children: /* @__PURE__ */ S.jsx(T8, {}) })
              },
              r
            );
          })
        ]
      }
    );
  }, Cbe = ({
    nodeSettingsPath: e
  }) => {
    const t = e.split("/") || ["general"];
    return /* @__PURE__ */ S.jsxs(
      zT,
      {
        defaultValue: t[0] || "general",
        className: "nodesettings-tabs funcnodes-control-root",
        children: [
          /* @__PURE__ */ S.jsxs(
            BT,
            {
              className: "nodesettings-tabs-list",
              "aria-label": "Manage node settings",
              children: [
                /* @__PURE__ */ S.jsx(Ap, { value: "general", className: "nodesettings-tabs-trigger", children: "General" }),
                /* @__PURE__ */ S.jsx(Ap, { value: "inputs", className: "nodesettings-tabs-trigger", children: "Inputs" }),
                /* @__PURE__ */ S.jsx(Ap, { value: "outputs", className: "nodesettings-tabs-trigger", children: "Outputs" })
              ]
            }
          ),
          /* @__PURE__ */ S.jsx(Np, { value: "general", className: "nodesettings-tabs-content", children: /* @__PURE__ */ S.jsx(Sbe, {}) }),
          /* @__PURE__ */ S.jsx(
            Np,
            {
              value: "inputs",
              className: "nodesettings-tabs-content nodesettings-io-list",
              children: /* @__PURE__ */ S.jsx(
                _be,
                {
                  splitnodesettingsPath: (
                    // all but first element
                    t.slice(1)
                  )
                }
              )
            }
          ),
          /* @__PURE__ */ S.jsx(
            Np,
            {
              value: "outputs",
              className: "nodesettings-tabs-content nodesettings-io-list",
              children: /* @__PURE__ */ S.jsx(
                Ebe,
                {
                  splitnodesettingsPath: (
                    // all but first element
                    t.slice(1)
                  )
                }
              )
            }
          )
        ]
      }
    );
  }, kbe = T.memo(
    ({ isOpen: e, onOpenChange: t, nodeSettingsPath: n }) => {
      const o = fo().use((i) => i.id);
      return /* @__PURE__ */ S.jsx(
        Ga,
        {
          title: `Node Settings: ${o}`,
          open: e,
          onOpenChange: t,
          dialogClassName: "nodesettings-dialog",
          children: /* @__PURE__ */ S.jsx(Cbe, { nodeSettingsPath: n })
        }
      );
    }
  ), Tbe = T.memo(({ toogleShowSettings: e }) => {
    const t = jt(), { node: n } = Or(), r = fo(), { id: o, description: i, node_name: a } = r.useShallow((l) => ({
      id: l.id,
      description: l.description,
      node_name: l.node_name
    })), s = T.useCallback(() => {
      t.on_node_action({
        type: "trigger",
        from_remote: !1,
        id: o
      });
    }, [t, o]);
    return /* @__PURE__ */ S.jsxs("div", { className: "nodeheader", title: i || a, children: [
      /* @__PURE__ */ S.jsxs("div", { className: "nodeheader_element", children: [
        /* @__PURE__ */ S.jsx(
          doe,
          {
            fontSize: "inherit",
            className: "triggerbutton nodeheaderbutton ",
            onClick: s
          }
        ),
        /* @__PURE__ */ S.jsx(
          foe,
          {
            fontSize: "inherit",
            className: "nodestatusbutton nodeheaderbutton",
            onClick: async () => {
              n && console.log("nodestatus", await n.get_node_status(o));
            }
          }
        ),
        /* @__PURE__ */ S.jsx(
          hoe,
          {
            fontSize: "inherit",
            className: "nodesettingsbutton nodeheaderbutton",
            onClick: () => {
              e?.();
            }
          }
        )
      ] }),
      /* @__PURE__ */ S.jsx("div", { className: "nodeheader_element nodeheader_title", children: /* @__PURE__ */ S.jsx("div", { className: "nodeheader_title_text", children: a }) }),
      /* @__PURE__ */ S.jsx("div", { className: "nodeheader_element", children: /* @__PURE__ */ S.jsx(zh, { fontSize: "inherit" }) })
    ] });
  }), Rbe = T.memo(({ iostore: e }) => {
    const t = e.use(), r = fo().use((s) => s.render_options), o = Zb(t.id), [i, a] = H0e(t);
    return /* @__PURE__ */ S.jsx(
      "div",
      {
        className: "nodrag nodedatabody",
        "data-src": r?.data?.src || "",
        children: i && t && /* @__PURE__ */ S.jsx(rl.Provider, { value: e, children: /* @__PURE__ */ S.jsx(
          Ga,
          {
            title: t.full_id,
            trigger: /* @__PURE__ */ S.jsx("div", { className: "nodedatabutton", children: /* @__PURE__ */ S.jsx(C8, { Component: i }) }),
            onOpenChange: (s) => {
              s && o?.();
            },
            children: a && /* @__PURE__ */ S.jsx(E8, { Component: a, iostore: e })
          }
        ) })
      }
    );
  }), Obe = T.memo(
    ({ setShowSettings: e, setNodeSettingsPath: t }) => {
      const n = fo(), { render_options: r, outputs: o, inputs: i } = n.useShallow(
        (s) => ({
          render_options: s.render_options,
          outputs: s.outputs,
          inputs: s.inputs
        })
      ), a = r?.data?.src ? n.io_stores.get(r?.data?.src) : void 0;
      return /* @__PURE__ */ S.jsxs("div", { className: "nodebody nowheel ", children: [
        o.map((s) => {
          const l = n.io_stores.get(s);
          if (l)
            return /* @__PURE__ */ S.jsx(rl.Provider, { value: l, children: /* @__PURE__ */ S.jsx(
              X0e,
              {
                setNodeSettingsPath: t,
                setShowSettings: e
              }
            ) }, s);
        }),
        a && /* @__PURE__ */ S.jsx(Rbe, { iostore: a }),
        i.map((s) => {
          const l = n.io_stores.get(s);
          if (l)
            return /* @__PURE__ */ S.jsx(rl.Provider, { value: l, children: /* @__PURE__ */ S.jsx(
              Y0e,
              {
                setNodeSettingsPath: t,
                setShowSettings: e
              }
            ) }, s);
        })
      ] });
    }
  ), UT = () => {
    const e = fo(), { original_name: t, id: n } = e.useShallow((l) => ({
      original_name: l.name,
      id: l.id
    })), [r, o] = T.useState(t);
    T.useEffect(() => {
      o(t);
    }, [t]);
    const i = jt(), a = (l) => {
      o(l.target.value);
    }, s = (l) => {
      const u = l.target.value;
      u !== t && i.on_node_action({
        type: "update",
        from_remote: !1,
        id: n,
        node: { name: u }
      });
    };
    return /* @__PURE__ */ S.jsx(
      "input",
      {
        className: "nodename_input",
        value: r,
        onChange: a,
        onBlur: s
      }
    );
  }, Abe = () => {
    const t = fo().use((n) => n.progress);
    return t ? /* @__PURE__ */ S.jsx(
      rce,
      {
        state: t,
        className: "nodeprogress"
      }
    ) : null;
  }, Nbe = T.memo(() => {
    const t = fo().use((n) => n.error);
    return /* @__PURE__ */ S.jsxs("div", { className: "nodefooter", children: [
      t && /* @__PURE__ */ S.jsx("div", { className: "nodeerror", children: t }),
      /* @__PURE__ */ S.jsx(Abe, {})
    ] });
  }), Mbe = () => {
    const e = fo(), { collapsed: t, error: n, node_id: r } = e.useShallow((y) => ({
      collapsed: y.properties["frontend:collapsed"] || !1,
      error: y.error,
      node_id: y.node_id
    })), { visualTrigger: o } = W0e(e), [i, a] = T.useState(!1), [s, l] = T.useState(""), { keys: u } = Vk(), p = T.useContext(Za).NodeHooks[r] ?? [], h = T.useCallback(() => {
      a((y) => !y);
    }, []), g = (y) => {
      u.has("s") && !i && (l(""), a(!0), y.stopPropagation());
    };
    return /* @__PURE__ */ S.jsxs(
      "div",
      {
        className: "innernode" + (o ? " intrigger" : "") + (n ? " error" : ""),
        onClick: g,
        children: [
          /* @__PURE__ */ S.jsx(Tbe, { toogleShowSettings: h }),
          /* @__PURE__ */ S.jsx(UT, {}),
          t ? null : /* @__PURE__ */ S.jsx(
            Obe,
            {
              setNodeSettingsPath: l,
              setShowSettings: a
            }
          ),
          /* @__PURE__ */ S.jsx(Nbe, {}),
          /* @__PURE__ */ S.jsx(
            kbe,
            {
              isOpen: i,
              onOpenChange: a,
              nodeSettingsPath: s
            }
          ),
          p.map((y, b) => /* @__PURE__ */ S.jsx(T.Fragment, { children: /* @__PURE__ */ S.jsx(y, {}) }, b))
        ]
      }
    );
  }, Pbe = T.memo(
    ({ data: e }) => /* @__PURE__ */ S.jsx(Xb.Provider, { value: e.nodestore, children: /* @__PURE__ */ S.jsx(Mbe, {}) }),
    (e, t) => e.data.nodestore === t.data.nodestore
  ), $be = ({
    id: e,
    sourceX: t,
    sourceY: n,
    targetX: r,
    targetY: o,
    sourcePosition: i,
    targetPosition: a,
    data: s,
    ...l
  }) => {
    const [u] = kT({
      sourceX: t,
      sourceY: n,
      sourcePosition: i,
      targetX: r,
      targetY: o,
      targetPosition: a
    });
    return /* @__PURE__ */ S.jsx(S.Fragment, { children: /* @__PURE__ */ S.jsx(Jh, { id: e, path: u, ...l }) });
  }, Ibe = {
    default: Pbe,
    group: e0e
  }, jbe = {
    default: $be
  }, Dbe = (e) => ({
    nodes: e.getNodes(),
    edges: e.getEdges(),
    onNodesChange: e.onNodesChange,
    onEdgesChange: e.onEdgesChange,
    onConnect: e.onConnect
  }), VT = (e) => {
    const t = /* @__PURE__ */ new Set(), n = e.filter(
      (o) => o.type === "group"
    );
    n.forEach((o) => {
      t.add(o.id);
    });
    const r = e.filter(
      (o) => !t.has(o.id)
    );
    return { group_nodes: n, default_nodes: r };
  };
  function HT(e) {
    const t = new Map(e.map((a) => [a.id, a])), n = /* @__PURE__ */ new Map(), r = [];
    for (const a of e)
      if (n.has(a.id) || n.set(a.id, []), a.parentId && t.has(a.parentId)) {
        const s = t.get(a.parentId);
        if (s) {
          const l = n.get(s.id) || [];
          l.push(a), n.set(s.id, l);
        } else
          r.push(a);
      } else
        r.push(a);
    const o = [];
    function i(a) {
      o.push(a);
      const s = n.get(a.id) || [];
      for (const l of s)
        i(l);
    }
    for (const a of r)
      i(a);
    if (o.length !== e.length) {
      console.warn(
        "Sorting mismatch: Not all nodes could be placed. Check for circular dependencies or missing parents."
      );
      const a = new Set(o.map((s) => s.id));
      e.forEach((s) => {
        a.has(s.id) || o.push(s);
      });
    }
    return o;
  }
  const G8 = () => {
    const { getNodes: e } = yc();
    return {
      getNodes: e,
      getSelectedNodes: (o) => (o === void 0 && (o = e()), o.filter((i) => i.selected)),
      getSplitNodes: (o) => {
        o === void 0 && (o = e());
        const { group_nodes: i, default_nodes: a } = VT(o);
        return { group_nodes: i, default_nodes: a };
      },
      getSortedNodes: (o) => (o === void 0 && (o = e()), HT(o))
    };
  }, K8 = (e, t) => {
    const n = e.getState(), { new_obj: r, change: o } = tc(n, t);
    o && e.setState(r);
  }, Y8 = (e) => To(e);
  function lj(e) {
    return e != null && typeof e == "object" && "id" in e && typeof e.id == "string";
  }
  const X8 = (e) => {
    let t = e.io ?? {}, n = e.io_order, r = [];
    const o = {};
    if (n === void 0)
      if (Array.isArray(t)) {
        const i = t.filter(lj);
        r = i.map((a) => a.id);
        for (const a of i)
          o[a.id] = a;
      } else {
        r = Object.keys(t);
        for (const i in t)
          t[i] !== void 0 && (o[i] = t[i]);
      }
    else if (r = n, Array.isArray(t)) {
      const i = t.filter(lj);
      for (const a of i)
        o[a.id] = a, r.includes(a.id) || r.push(a.id);
    } else
      for (const i in t)
        t[i] !== void 0 && (o[i] = t[i]), r.includes(i) || r.push(i);
    return { ...e, io_order: r, io: o };
  }, Fbe = {
    id: "dummy",
    node_id: "dummy",
    node_name: "dummy",
    properties: {
      "frontend:size": [200, 100],
      "frontend:pos": [NaN, NaN],
      "frontend:collapsed": !1
    },
    io: {},
    io_order: [],
    name: "dummy",
    in_trigger: !1,
    reset_inputs_on_trigger: !1,
    progress: {
      ascii: !1,
      elapsed: 0,
      initial: 0,
      n: 0,
      prefix: "idle",
      unit: "it",
      unit_divisor: 1e3,
      unit_scale: !1
    }
  }, Lbe = {
    id: "dummy",
    name: "dummy",
    node: "dummy",
    full_id: "dummy",
    type: "any",
    value: void 0,
    is_input: !1,
    connected: !1,
    does_trigger: !0,
    fullvalue: void 0,
    render_options: {
      set_default: !0,
      type: "any"
    },
    hidden: !1,
    emit_value_set: !0,
    required: !1
  }, zbe = ek(Fbe), Bbe = ek(Lbe), Ube = (e) => {
    const t = e.io_order;
    if (t === void 0)
      throw new Error("Node must have io_order");
    return {
      ...e,
      inputs: Object.keys(e.io).filter((r) => e.io[r].is_input),
      outputs: Object.keys(e.io).filter((r) => !e.io[r].is_input),
      io_order: t
    };
  }, Vbe = (e) => (e.value === "<NoValue>" && (e.value = void 0), e.fullvalue === "<NoValue>" && (e.fullvalue = void 0), e.hidden === void 0 && (e.hidden = !1), [{
    ...e
  }, e.value, e.fullvalue]), Hbe = (e) => {
    if (!e.id)
      throw new Error("Node must have an id");
    const t = zbe(e);
    return Ube(t);
  }, qbe = (e, t) => {
    const n = e.getState(), r = {}, o = X8(t), i = Object.keys(o);
    for (const a of i)
      switch (a) {
        case "id": {
          const [s, l] = So(
            n[a],
            o[a]
          );
          l && (r[a] = s);
          break;
        }
        case "node_id": {
          const [s, l] = So(
            n[a],
            o[a]
          );
          l && (r[a] = s);
          break;
        }
        case "node_name": {
          const [s, l] = So(
            n[a],
            o[a]
          );
          l && (r[a] = s);
          break;
        }
        case "name": {
          const [s, l] = So(
            n[a],
            o[a]
          );
          l && (r[a] = s);
          break;
        }
        case "in_trigger": {
          const [s, l] = So(
            n[a],
            o[a]
          );
          l && (r[a] = s);
          break;
        }
        case "error": {
          o[a] !== n[a] && (r[a] = o[a]);
          break;
        }
        case "render_options": {
          const [s, l] = ju(
            n[a],
            o[a]
          );
          l && (r[a] = s);
          break;
        }
        case "io_order": {
          const [s, l] = ((u, d) => d === void 0 ? [u, !1] : [d, !JC(u, d)])(n[a], o[a]);
          l && (r[a] = s.filter((u) => u !== void 0));
          break;
        }
        case "io": {
          const s = o[a];
          if (s === void 0) break;
          for (const l in s) {
            const u = e.io_stores.get(l);
            if (!u) {
              console.error("io key not found in oldvalue:", l);
              continue;
            }
            u.update(s[l]);
          }
          break;
        }
        case "progress": {
          const [s, l] = ju(
            n[a],
            o[a]
          );
          l && (r[a] = s);
          break;
        }
        case "description": {
          r[a] = o[a];
          break;
        }
        case "properties": {
          const [s, l] = ju(
            n[a],
            o[a]
          );
          l && (r[a] = s);
          break;
        }
        case "status": {
          const [s, l] = ju(
            n[a],
            o[a]
          );
          l && (r[a] = s);
          break;
        }
        case "reset_inputs_on_trigger": {
          const [s, l] = So(
            n[a],
            o[a]
          );
          l && (r[a] = s);
          break;
        }
        default:
          try {
            C4(a, o[a]);
          } catch (s) {
            console.error(s);
          }
      }
    Object.keys(r).length > 0 && e.setState(r);
  }, Wbe = (e, t) => {
    const n = e.getState(), r = {}, o = {}, i = Object.keys(t);
    for (const a of i)
      switch (a) {
        case "name": {
          const [s, l] = So(
            n[a],
            t[a]
          );
          l && (r[a] = s);
          break;
        }
        case "id": {
          const [s, l] = So(
            n[a],
            t[a]
          );
          l && (r[a] = s);
          break;
        }
        case "connected": {
          const [s, l] = So(
            n[a],
            t[a]
          );
          l && (r[a] = s);
          break;
        }
        case "does_trigger": {
          const [s, l] = So(
            n[a],
            t[a]
          );
          l && (r[a] = s);
          break;
        }
        case "hidden": {
          const [s, l] = So(
            n[a],
            t[a]
          );
          l && (r[a] = s);
          break;
        }
        case "full_id": {
          const [s, l] = So(
            n[a],
            t[a]
          );
          l && (r[a] = s);
          break;
        }
        case "is_input":
          break;
        case "node":
          break;
        case "type":
          break;
        case "value": {
          o.preview = t[a];
          break;
        }
        case "fullvalue": {
          o.full = t[a];
          break;
        }
        case "render_options": {
          const [s, l] = ju(
            n[a],
            t[a]
          );
          l && (r[a] = s);
          break;
        }
        case "value_options": {
          const [s, l] = ju(
            n[a],
            t[a]
          );
          l && (r[a] = s);
          break;
        }
        case "valuepreview_type": {
          r[a] = t[a];
          break;
        }
        case "emit_value_set": {
          r[a] = t[a];
          break;
        }
        case "default": {
          r[a] = t[a];
          break;
        }
        case "required": {
          r[a] = t[a];
          break;
        }
        default:
          try {
            C4(a, t[a]);
          } catch (s) {
            console.error(s);
          }
      }
    Object.keys(o).length > 0 && e.updateValueStore(o), Object.keys(r).length > 0 && e.setState(r);
  }, Gbe = (e) => {
    if (!e.id)
      throw new Error(
        "IO must have an id but is missing for " + JSON.stringify(e)
      );
    e.name === void 0 && (e.name = e.id);
    const t = Bbe(e);
    return (t.render_options.type === "any" || t.render_options.type === void 0) && (t.render_options.type = t.type), Vbe(t);
  }, Kbe = (e, t) => {
    let n;
    const [r, o, i] = Gbe(t);
    return n = {
      io_state: Y8((a, s) => r),
      use: (a) => a ? n.io_state(a) : n.io_state(),
      useShallow: (a) => n.io_state(PT(a)),
      getState: () => n.io_state.getState(),
      setState: (a) => {
        n.io_state.setState(a);
      },
      update: (a) => {
        Wbe(n, a);
      },
      valuestore: To((a, s) => {
        let l = o;
        l === "<NoValue>" && (l = void 0), !(l instanceof Ai) && l !== void 0 && (l = Vs.fromObject(l));
        let u = i;
        return u === "<NoValue>" && (u = void 0), !(u instanceof Ai) && u !== void 0 && (u = Vs.fromObject(u)), {
          preview: l,
          full: u
        };
      }),
      updateValueStore: (a) => {
        n.valuestore.setState((s) => (s.preview && typeof s.preview.dispose == "function" && s.preview.dispose(), s.full && typeof s.full.dispose == "function" && s.full.dispose(), a.preview !== void 0 && a.full === void 0 && (a.full = void 0, s.full = void 0), a.preview !== void 0 && !(a.preview instanceof Ai) && (a.preview = Vs.fromObject(a.preview)), a.full !== void 0 && !(a.full instanceof Ai) && (a.full = Vs.fromObject(a.full)), { ...s, ...a }));
      },
      node: e,
      serialize: () => {
        const a = n.io_state.getState(), s = n.valuestore.getState();
        return {
          ...a,
          value: s.preview,
          fullvalue: s.full,
          render_options: a.render_options,
          valuepreview_type: a.valuepreview_type,
          emit_value_set: a.emit_value_set
        };
      }
    }, n;
  }, Ybe = (e) => {
    const t = {
      use: (i) => i ? r.node_state(i) : r.node_state(),
      useShallow: (i) => r.node_state(PT(i)),
      io_stores: /* @__PURE__ */ new Map(),
      getState: () => r.node_state.getState(),
      setState: (i) => {
        r.node_state.setState(i);
      },
      update: (i) => {
        qbe(r, i);
      },
      serialize: () => ({
        ...r.node_state.getState(),
        io: Object.fromEntries(
          Array.from(r.io_stores.entries()).map(([s, l]) => [
            s,
            l.serialize()
          ])
        )
      })
    }, n = X8(e), r = {
      ...t,
      node_state: Y8((i, a) => Hbe(n))
    }, o = n.io;
    return Object.entries(o).forEach(([i, a]) => {
      a !== void 0 && r.io_stores.set(i, Kbe(n.id, a));
    }), r;
  }, Xbe = () => {
    const e = jt();
    return {
      onSelectionChange: T.useCallback(
        ({ nodes: n, edges: r }) => {
          const { group_nodes: o, default_nodes: i } = VT(n), a = e.local_state.getState();
          e.local_state.setState({
            ...a,
            selected_nodes: i.map((s) => s.id),
            selected_edges: r.map((s) => s.id),
            selected_groups: o.map((s) => s.id)
          });
        },
        [e]
      )
    };
  }, Zbe = () => {
    const e = yc(), t = jt();
    return t.rf_instance = e, /* @__PURE__ */ S.jsx(S.Fragment, {});
  }, Qbe = () => {
    const e = jt(), { getEdges: t } = yc(), { getSelectedNodes: n } = G8();
    return {
      copySelectedNodes: T.useCallback(() => {
        const o = t(), i = n();
        if (i.length === 0) return;
        const a = { nodes: [], edges: [] };
        for (const u of i) {
          const d = e.nodespace.get_node(u.id, !1);
          d && a.nodes.push(d.serialize());
        }
        const s = new Set(i.map((u) => u.id)), l = o.filter(
          (u) => s.has(u.source) && s.has(u.target)
        );
        for (const u of l)
          !u.sourceHandle || !u.targetHandle || a.edges.push({
            src_nid: u.source,
            src_ioid: u.sourceHandle,
            trg_nid: u.target,
            trg_ioid: u.targetHandle
          });
        navigator.clipboard.writeText(JSON.stringify(a));
      }, [n, t, e])
    };
  }, Jbe = () => {
    const e = Na("Delete"), t = Na(["Meta+c", "Control+c", "Strg+c"]), n = Na(["Control+g", "Meta+g"]), r = Na(["Control+Alt+g", "Meta+Alt+g"]), o = Qve(), { getEdges: i } = yc(), { getNodes: a, getSelectedNodes: s, getSplitNodes: l } = G8(), { copySelectedNodes: u } = Qbe(), { node: d, group: p, edge: h } = Or();
    return T.useEffect(() => {
      if (e) {
        const g = i().filter((x) => x.selected);
        for (const x of g)
          !x.source || !x.target || !x.sourceHandle || !x.targetHandle || h?.remove_edge({
            src_nid: x.source,
            src_ioid: x.sourceHandle,
            trg_nid: x.target,
            trg_ioid: x.targetHandle
          });
        const y = s(), { group_nodes: b, default_nodes: v } = l(y);
        for (const x of v)
          d?.remove_node(x.id);
        for (const x of b)
          p?.remove_group(x.id);
      }
    }, [e, a, i, d, p, h]), T.useEffect(() => {
      t && u();
    }, [t, u]), T.useEffect(() => {
      if (n) {
        const g = s(), { group_nodes: y, default_nodes: b } = l(g);
        g.length > 0 && o(
          b.map((v) => v.id),
          y.map((v) => v.id)
        );
      }
    }, [n, a]), T.useEffect(() => {
      if (r) {
        const g = s(), { group_nodes: y } = l(g);
        y.forEach((b) => {
          p?.remove_group(b.id);
        });
      }
    }, [r, a]), /* @__PURE__ */ S.jsx(S.Fragment, {});
  }, e1e = () => {
    const { node: e, edge: t } = Or(), n = jt();
    return T.useCallback(
      async (o, i) => {
        try {
          if (!o || !e || !t) return;
          const a = JSON.parse(o);
          if (!a || !n.worker || !a.nodes) return;
          const s = [0, 0];
          for (const u of a.nodes)
            s[0] += u.properties["frontend:pos"][0], s[1] += u.properties["frontend:pos"][1];
          s[0] /= a.nodes.length, s[1] /= a.nodes.length;
          const l = [];
          for (const u of a.nodes) {
            const d = {
              id: u.node_id,
              src_id: u.id,
              position: [
                u.properties["frontend:pos"][0] - s[0],
                u.properties["frontend:pos"][1] - s[1]
              ]
            };
            l.push(d);
          }
          for (const u of l) {
            const d = await e.add_node(u.id);
            !d || !n.nodespace.get_node(d.id, !1) || (u.new_id = d.id, i([
              {
                id: d.id,
                type: "position",
                position: {
                  x: u.position[0] + d.properties["frontend:pos"][0],
                  y: u.position[1] + d.properties["frontend:pos"][1]
                }
              }
            ]));
          }
          for (const u of a.edges) {
            const d = l.find(
              (h) => h.src_id === u.src_nid
            ), p = l.find(
              (h) => h.src_id === u.trg_nid
            );
            !d || !p || !d.new_id || !p.new_id || t.add_edge({
              src_nid: d.new_id,
              src_ioid: u.src_ioid,
              trg_nid: p.new_id,
              trg_ioid: u.trg_ioid
            });
          }
        } catch (a) {
          console.error("Failed to process pasted data:", a);
        }
      },
      [e, t, n]
    );
  }, t1e = (e, t) => {
    const n = e.properties || {};
    n["frontend:size"] || (n["frontend:size"] = [200, 100]);
    const r = n["frontend:pos"];
    if (!r || r.length !== 2 || isNaN(r[0]) || r[0] === null || isNaN(r[1]) || r[1] === null)
      if (!t || !t.rf_instance || t.reactflowRef === null)
        n["frontend:pos"] = [0, 0];
      else {
        const i = t.reactflowRef.getBoundingClientRect(), a = i.left + i.width / 2, s = i.top + i.height / 2, l = t.rf_instance.screenToFlowPosition({
          x: a,
          y: s
        });
        n["frontend:pos"] = [
          l.x - n["frontend:size"][0] / 2,
          l.y - n["frontend:size"][0] / 2
        ];
      }
    n["frontend:collapsed"] || (n["frontend:collapsed"] = !1), e.properties = n;
  }, n1e = (e, t) => {
    const n = e.getState();
    if (t1e(n, t), n.id === void 0)
      throw new Error("Node must have an id");
    const r = {
      nodestore: e
    };
    return {
      position: {
        x: n.properties["frontend:pos"][0],
        y: n.properties["frontend:pos"][1]
      },
      data: r,
      type: "default",
      zIndex: 1003,
      // expandParent: true,
      ...n
    };
  }, cj = {
    default: kr.Dots,
    metal: kr.Cross,
    light: kr.Dots,
    solarized: kr.Dots,
    midnight: kr.Dots,
    forest: kr.Dots,
    scientific: kr.Lines
  }, r1e = (e) => {
    const t = jt(), n = T.useRef(null), { colorTheme: r } = nz(), { onSelectionChange: o } = Xbe(), i = Zce();
    T.useEffect(() => {
      t.getStateManager().toaster = i;
    }, []), T.useEffect(() => {
      t.reactflowRef = n.current;
    }, [n]);
    const { nodes: a, edges: s, onNodesChange: l, onEdgesChange: u, onConnect: d } = t.useReactFlowStore(PT(Dbe)), p = e1e(), h = T.useCallback(
      (g) => {
        const y = n.current;
        if (!y) return;
        let b = g.target, v = 0;
        for (; b && b.parentElement && b !== y; )
          v++, b = b.parentElement;
        t.logger.debug(`onPasteCapture: ${v} steps to reactflow`), v <= 2 && p(
          g.clipboardData.getData("text/plain"),
          l
        );
      },
      [p, l, t.logger]
    );
    return /* @__PURE__ */ S.jsx("div", { className: "reactflowlayer", children: /* @__PURE__ */ S.jsxs(
      Sve,
      {
        onPasteCapture: h,
        nodes: a,
        edges: s,
        onNodesChange: l,
        onEdgesChange: u,
        onConnect: d,
        nodeTypes: Ibe,
        edgeTypes: jbe,
        minZoom: e.minZoom,
        maxZoom: e.maxZoom,
        fitView: !0,
        onSelectionChange: o,
        ref: n,
        panOnDrag: !e.static,
        children: [
          /* @__PURE__ */ S.jsx(Zbe, {}),
          /* @__PURE__ */ S.jsx(Jbe, {}),
          /* @__PURE__ */ S.jsx(
            Tve,
            {
              color: "#888",
              gap: 24,
              size: 2,
              variant: cj[r] || cj.default,
              patternClassName: "fn-background-pattern"
            }
          ),
          e.minimap && /* @__PURE__ */ S.jsx(
            Wve,
            {
              nodeStrokeWidth: 3,
              pannable: !e.static,
              zoomable: !e.static,
              zoomStep: 3
            }
          )
        ]
      }
    ) });
  }, o1e = ({
    on_node_change: e,
    on_edge_change: t,
    on_connect: n
  }) => {
    const r = e || ((s) => {
    }), o = t || ((s) => {
    }), i = n || ((s) => {
    });
    return To((s, l) => ({
      _nodes: [],
      _edges: [],
      _nodes_map: /* @__PURE__ */ new Map(),
      update_nodes: (u) => {
        u = HT(u), s({
          _nodes: u,
          _nodes_map: new Map(u.map((d) => [d.id, d]))
        });
      },
      partial_update_nodes: (u) => {
        const d = l(), p = d._nodes, h = new Map(
          p.map((g) => [g.id, g])
        );
        for (const g of u)
          h.set(g.id, g);
        d.update_nodes(Array.from(h.values()));
      },
      update_edges: (u) => {
        s({
          _edges: u
        });
      },
      onNodesChange: (u) => {
        const d = l();
        d.update_nodes(NT(u, d._nodes)), r(u);
      },
      onEdgesChange: (u) => {
        s({
          _edges: TB(u, l()._edges)
        }), o(u);
      },
      onConnect: (u) => {
        u.source == null || u.target == null || i(u);
      },
      getNode: (u) => l()._nodes_map.get(u),
      getNodes: () => l()._nodes,
      getEdges: () => l()._edges
    }));
  }, i1e = () => {
    const t = jt().progress_state();
    return /* @__PURE__ */ S.jsxs("div", { className: "statusbar", children: [
      /* @__PURE__ */ S.jsx(
        "span",
        {
          className: "statusbar-progressbar",
          style: { width: Math.min(100, 100 * t.progress) + "%" }
        }
      ),
      /* @__PURE__ */ S.jsx("span", { className: "statusbar-message", children: t.message })
    ] });
  }, S0 = !1;
  var gC = ["Enter", " "], a1e = ["ArrowDown", "PageUp", "Home"], Z8 = ["ArrowUp", "PageDown", "End"], s1e = [...a1e, ...Z8], l1e = {
    ltr: [...gC, "ArrowRight"],
    rtl: [...gC, "ArrowLeft"]
  }, c1e = {
    ltr: ["ArrowLeft"],
    rtl: ["ArrowRight"]
  }, tm = "Menu", [uh, u1e, f1e] = kb(tm), [bc, Q8] = Yi(tm, [
    f1e,
    _b,
    Qb
  ]), nm = _b(), J8 = Qb(), [eU, xc] = bc(tm), [d1e, rm] = bc(tm), tU = (e) => {
    const { __scopeMenu: t, open: n = !1, children: r, dir: o, onOpenChange: i, modal: a = !0 } = e, s = nm(t), [l, u] = T.useState(null), d = T.useRef(!1), p = Vr(i), h = Kb(o);
    return T.useEffect(() => {
      const g = () => {
        d.current = !0, document.addEventListener("pointerdown", y, { capture: !0, once: !0 }), document.addEventListener("pointermove", y, { capture: !0, once: !0 });
      }, y = () => d.current = !1;
      return document.addEventListener("keydown", g, { capture: !0 }), () => {
        document.removeEventListener("keydown", g, { capture: !0 }), document.removeEventListener("pointerdown", y, { capture: !0 }), document.removeEventListener("pointermove", y, { capture: !0 });
      };
    }, []), /* @__PURE__ */ S.jsx(Jk, { ...s, children: /* @__PURE__ */ S.jsx(
      eU,
      {
        scope: t,
        open: n,
        onOpenChange: p,
        content: l,
        onContentChange: u,
        children: /* @__PURE__ */ S.jsx(
          d1e,
          {
            scope: t,
            onClose: T.useCallback(() => p(!1), [p]),
            isUsingKeyboardRef: d,
            dir: h,
            modal: a,
            children: r
          }
        )
      }
    ) });
  };
  tU.displayName = tm;
  var p1e = "MenuAnchor", qT = T.forwardRef(
    (e, t) => {
      const { __scopeMenu: n, ...r } = e, o = nm(n);
      return /* @__PURE__ */ S.jsx(eT, { ...o, ...r, ref: t });
    }
  );
  qT.displayName = p1e;
  var h1e = "MenuPortal", [uze, nU] = bc(h1e, {
    forceMount: void 0
  }), Ro = "MenuContent", [m1e, WT] = bc(Ro), rU = T.forwardRef(
    (e, t) => {
      const n = nU(Ro, e.__scopeMenu), { forceMount: r = n.forceMount, ...o } = e, i = xc(Ro, e.__scopeMenu), a = rm(Ro, e.__scopeMenu);
      return /* @__PURE__ */ S.jsx(uh.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ S.jsx(ei, { present: r || i.open, children: /* @__PURE__ */ S.jsx(uh.Slot, { scope: e.__scopeMenu, children: a.modal ? /* @__PURE__ */ S.jsx(g1e, { ...o, ref: t }) : /* @__PURE__ */ S.jsx(y1e, { ...o, ref: t }) }) }) });
    }
  ), g1e = T.forwardRef(
    (e, t) => {
      const n = xc(Ro, e.__scopeMenu), r = T.useRef(null), o = an(t, r);
      return T.useEffect(() => {
        const i = r.current;
        if (i) return kk(i);
      }, []), /* @__PURE__ */ S.jsx(
        GT,
        {
          ...e,
          ref: o,
          trapFocus: n.open,
          disableOutsidePointerEvents: n.open,
          disableOutsideScroll: !0,
          onFocusOutside: Fe(
            e.onFocusOutside,
            (i) => i.preventDefault(),
            { checkForDefaultPrevented: !1 }
          ),
          onDismiss: () => n.onOpenChange(!1)
        }
      );
    }
  ), y1e = T.forwardRef((e, t) => {
    const n = xc(Ro, e.__scopeMenu);
    return /* @__PURE__ */ S.jsx(
      GT,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }), v1e = /* @__PURE__ */ nf("MenuContent.ScrollLock"), GT = T.forwardRef(
    (e, t) => {
      const {
        __scopeMenu: n,
        loop: r = !1,
        trapFocus: o,
        onOpenAutoFocus: i,
        onCloseAutoFocus: a,
        disableOutsidePointerEvents: s,
        onEntryFocus: l,
        onEscapeKeyDown: u,
        onPointerDownOutside: d,
        onFocusOutside: p,
        onInteractOutside: h,
        onDismiss: g,
        disableOutsideScroll: y,
        ...b
      } = e, v = xc(Ro, n), x = rm(Ro, n), E = nm(n), _ = J8(n), C = u1e(n), [k, R] = T.useState(null), A = T.useRef(null), M = an(t, A, v.onContentChange), I = T.useRef(0), D = T.useRef(""), L = T.useRef(0), P = T.useRef(null), B = T.useRef("right"), j = T.useRef(0), V = y ? db : T.Fragment, F = y ? { as: v1e, allowPinchZoom: !0 } : void 0, G = (K) => {
        const $ = D.current + K, U = C().filter((re) => !re.disabled), X = document.activeElement, z = U.find((re) => re.ref.current === X)?.textValue, H = U.map((re) => re.textValue), Y = A1e(H, $, z), Q = U.find((re) => re.textValue === Y)?.ref.current;
        (function re(te) {
          D.current = te, window.clearTimeout(I.current), te !== "" && (I.current = window.setTimeout(() => re(""), 1e3));
        })($), Q && setTimeout(() => Q.focus());
      };
      T.useEffect(() => () => window.clearTimeout(I.current), []), Ck();
      const W = T.useCallback((K) => B.current === P.current?.side && M1e(K, P.current?.area), []);
      return /* @__PURE__ */ S.jsx(
        m1e,
        {
          scope: n,
          searchRef: D,
          onItemEnter: T.useCallback(
            (K) => {
              W(K) && K.preventDefault();
            },
            [W]
          ),
          onItemLeave: T.useCallback(
            (K) => {
              W(K) || (A.current?.focus(), R(null));
            },
            [W]
          ),
          onTriggerLeave: T.useCallback(
            (K) => {
              W(K) && K.preventDefault();
            },
            [W]
          ),
          pointerGraceTimerRef: L,
          onPointerGraceIntentChange: T.useCallback((K) => {
            P.current = K;
          }, []),
          children: /* @__PURE__ */ S.jsx(V, { ...F, children: /* @__PURE__ */ S.jsx(
            cb,
            {
              asChild: !0,
              trapped: o,
              onMountAutoFocus: Fe(i, (K) => {
                K.preventDefault(), A.current?.focus({ preventScroll: !0 });
              }),
              onUnmountAutoFocus: a,
              children: /* @__PURE__ */ S.jsx(
                jh,
                {
                  asChild: !0,
                  disableOutsidePointerEvents: s,
                  onEscapeKeyDown: u,
                  onPointerDownOutside: d,
                  onFocusOutside: p,
                  onInteractOutside: h,
                  onDismiss: g,
                  children: /* @__PURE__ */ S.jsx(
                    I8,
                    {
                      asChild: !0,
                      ..._,
                      dir: x.dir,
                      orientation: "vertical",
                      loop: r,
                      currentTabStopId: k,
                      onCurrentTabStopIdChange: R,
                      onEntryFocus: Fe(l, (K) => {
                        x.isUsingKeyboardRef.current || K.preventDefault();
                      }),
                      preventScrollOnEntryFocus: !0,
                      children: /* @__PURE__ */ S.jsx(
                        Tz,
                        {
                          role: "menu",
                          "aria-orientation": "vertical",
                          "data-state": xU(v.open),
                          "data-radix-menu-content": "",
                          dir: x.dir,
                          ...E,
                          ...b,
                          ref: M,
                          style: { outline: "none", ...b.style },
                          onKeyDown: Fe(b.onKeyDown, (K) => {
                            const U = K.target.closest("[data-radix-menu-content]") === K.currentTarget, X = K.ctrlKey || K.altKey || K.metaKey, z = K.key.length === 1;
                            U && (K.key === "Tab" && K.preventDefault(), !X && z && G(K.key));
                            const H = A.current;
                            if (K.target !== H || !s1e.includes(K.key)) return;
                            K.preventDefault();
                            const Q = C().filter((re) => !re.disabled).map((re) => re.ref.current);
                            Z8.includes(K.key) && Q.reverse(), R1e(Q);
                          }),
                          onBlur: Fe(e.onBlur, (K) => {
                            K.currentTarget.contains(K.target) || (window.clearTimeout(I.current), D.current = "");
                          }),
                          onPointerMove: Fe(
                            e.onPointerMove,
                            fh((K) => {
                              const $ = K.target, U = j.current !== K.clientX;
                              if (K.currentTarget.contains($) && U) {
                                const X = K.clientX > j.current ? "right" : "left";
                                B.current = X, j.current = K.clientX;
                              }
                            })
                          )
                        }
                      )
                    }
                  )
                }
              )
            }
          ) })
        }
      );
    }
  );
  rU.displayName = Ro;
  var b1e = "MenuGroup", KT = T.forwardRef(
    (e, t) => {
      const { __scopeMenu: n, ...r } = e;
      return /* @__PURE__ */ S.jsx(xt.div, { role: "group", ...r, ref: t });
    }
  );
  KT.displayName = b1e;
  var x1e = "MenuLabel", oU = T.forwardRef(
    (e, t) => {
      const { __scopeMenu: n, ...r } = e;
      return /* @__PURE__ */ S.jsx(xt.div, { ...r, ref: t });
    }
  );
  oU.displayName = x1e;
  var _0 = "MenuItem", uj = "menu.itemSelect", e1 = T.forwardRef(
    (e, t) => {
      const { disabled: n = !1, onSelect: r, ...o } = e, i = T.useRef(null), a = rm(_0, e.__scopeMenu), s = WT(_0, e.__scopeMenu), l = an(t, i), u = T.useRef(!1), d = () => {
        const p = i.current;
        if (!n && p) {
          const h = new CustomEvent(uj, { bubbles: !0, cancelable: !0 });
          p.addEventListener(uj, (g) => r?.(g), { once: !0 }), Ek(p, h), h.defaultPrevented ? u.current = !1 : a.onClose();
        }
      };
      return /* @__PURE__ */ S.jsx(
        iU,
        {
          ...o,
          ref: l,
          disabled: n,
          onClick: Fe(e.onClick, d),
          onPointerDown: (p) => {
            e.onPointerDown?.(p), u.current = !0;
          },
          onPointerUp: Fe(e.onPointerUp, (p) => {
            u.current || p.currentTarget?.click();
          }),
          onKeyDown: Fe(e.onKeyDown, (p) => {
            const h = s.searchRef.current !== "";
            n || h && p.key === " " || gC.includes(p.key) && (p.currentTarget.click(), p.preventDefault());
          })
        }
      );
    }
  );
  e1.displayName = _0;
  var iU = T.forwardRef(
    (e, t) => {
      const { __scopeMenu: n, disabled: r = !1, textValue: o, ...i } = e, a = WT(_0, n), s = J8(n), l = T.useRef(null), u = an(t, l), [d, p] = T.useState(!1), [h, g] = T.useState("");
      return T.useEffect(() => {
        const y = l.current;
        y && g((y.textContent ?? "").trim());
      }, [i.children]), /* @__PURE__ */ S.jsx(
        uh.ItemSlot,
        {
          scope: n,
          disabled: r,
          textValue: o ?? h,
          children: /* @__PURE__ */ S.jsx(j8, { asChild: !0, ...s, focusable: !r, children: /* @__PURE__ */ S.jsx(
            xt.div,
            {
              role: "menuitem",
              "data-highlighted": d ? "" : void 0,
              "aria-disabled": r || void 0,
              "data-disabled": r ? "" : void 0,
              ...i,
              ref: u,
              onPointerMove: Fe(
                e.onPointerMove,
                fh((y) => {
                  r ? a.onItemLeave(y) : (a.onItemEnter(y), y.defaultPrevented || y.currentTarget.focus({ preventScroll: !0 }));
                })
              ),
              onPointerLeave: Fe(
                e.onPointerLeave,
                fh((y) => a.onItemLeave(y))
              ),
              onFocus: Fe(e.onFocus, () => p(!0)),
              onBlur: Fe(e.onBlur, () => p(!1))
            }
          ) })
        }
      );
    }
  ), w1e = "MenuCheckboxItem", aU = T.forwardRef(
    (e, t) => {
      const { checked: n = !1, onCheckedChange: r, ...o } = e;
      return /* @__PURE__ */ S.jsx(fU, { scope: e.__scopeMenu, checked: n, children: /* @__PURE__ */ S.jsx(
        e1,
        {
          role: "menuitemcheckbox",
          "aria-checked": E0(n) ? "mixed" : n,
          ...o,
          ref: t,
          "data-state": ZT(n),
          onSelect: Fe(
            o.onSelect,
            () => r?.(E0(n) ? !0 : !n),
            { checkForDefaultPrevented: !1 }
          )
        }
      ) });
    }
  );
  aU.displayName = w1e;
  var sU = "MenuRadioGroup", [S1e, _1e] = bc(
    sU,
    { value: void 0, onValueChange: () => {
    } }
  ), lU = T.forwardRef(
    (e, t) => {
      const { value: n, onValueChange: r, ...o } = e, i = Vr(r);
      return /* @__PURE__ */ S.jsx(S1e, { scope: e.__scopeMenu, value: n, onValueChange: i, children: /* @__PURE__ */ S.jsx(KT, { ...o, ref: t }) });
    }
  );
  lU.displayName = sU;
  var cU = "MenuRadioItem", uU = T.forwardRef(
    (e, t) => {
      const { value: n, ...r } = e, o = _1e(cU, e.__scopeMenu), i = n === o.value;
      return /* @__PURE__ */ S.jsx(fU, { scope: e.__scopeMenu, checked: i, children: /* @__PURE__ */ S.jsx(
        e1,
        {
          role: "menuitemradio",
          "aria-checked": i,
          ...r,
          ref: t,
          "data-state": ZT(i),
          onSelect: Fe(
            r.onSelect,
            () => o.onValueChange?.(n),
            { checkForDefaultPrevented: !1 }
          )
        }
      ) });
    }
  );
  uU.displayName = cU;
  var YT = "MenuItemIndicator", [fU, E1e] = bc(
    YT,
    { checked: !1 }
  ), dU = T.forwardRef(
    (e, t) => {
      const { __scopeMenu: n, forceMount: r, ...o } = e, i = E1e(YT, n);
      return /* @__PURE__ */ S.jsx(
        ei,
        {
          present: r || E0(i.checked) || i.checked === !0,
          children: /* @__PURE__ */ S.jsx(
            xt.span,
            {
              ...o,
              ref: t,
              "data-state": ZT(i.checked)
            }
          )
        }
      );
    }
  );
  dU.displayName = YT;
  var C1e = "MenuSeparator", pU = T.forwardRef(
    (e, t) => {
      const { __scopeMenu: n, ...r } = e;
      return /* @__PURE__ */ S.jsx(
        xt.div,
        {
          role: "separator",
          "aria-orientation": "horizontal",
          ...r,
          ref: t
        }
      );
    }
  );
  pU.displayName = C1e;
  var k1e = "MenuArrow", hU = T.forwardRef(
    (e, t) => {
      const { __scopeMenu: n, ...r } = e, o = nm(n);
      return /* @__PURE__ */ S.jsx(Rz, { ...o, ...r, ref: t });
    }
  );
  hU.displayName = k1e;
  var XT = "MenuSub", [T1e, mU] = bc(XT), gU = (e) => {
    const { __scopeMenu: t, children: n, open: r = !1, onOpenChange: o } = e, i = xc(XT, t), a = nm(t), [s, l] = T.useState(null), [u, d] = T.useState(null), p = Vr(o);
    return T.useEffect(() => (i.open === !1 && p(!1), () => p(!1)), [i.open, p]), /* @__PURE__ */ S.jsx(Jk, { ...a, children: /* @__PURE__ */ S.jsx(
      eU,
      {
        scope: t,
        open: r,
        onOpenChange: p,
        content: u,
        onContentChange: d,
        children: /* @__PURE__ */ S.jsx(
          T1e,
          {
            scope: t,
            contentId: Bi(),
            triggerId: Bi(),
            trigger: s,
            onTriggerChange: l,
            children: n
          }
        )
      }
    ) });
  };
  gU.displayName = XT;
  var vp = "MenuSubTrigger", yU = T.forwardRef(
    (e, t) => {
      const n = xc(vp, e.__scopeMenu), r = rm(vp, e.__scopeMenu), o = mU(vp, e.__scopeMenu), i = WT(vp, e.__scopeMenu), a = T.useRef(null), { pointerGraceTimerRef: s, onPointerGraceIntentChange: l } = i, u = { __scopeMenu: e.__scopeMenu }, d = T.useCallback(() => {
        a.current && window.clearTimeout(a.current), a.current = null;
      }, []);
      return T.useEffect(() => d, [d]), T.useEffect(() => {
        const p = s.current;
        return () => {
          window.clearTimeout(p), l(null);
        };
      }, [s, l]), /* @__PURE__ */ S.jsx(qT, { asChild: !0, ...u, children: /* @__PURE__ */ S.jsx(
        iU,
        {
          id: o.triggerId,
          "aria-haspopup": "menu",
          "aria-expanded": n.open,
          "aria-controls": o.contentId,
          "data-state": xU(n.open),
          ...e,
          ref: lb(t, o.onTriggerChange),
          onClick: (p) => {
            e.onClick?.(p), !(e.disabled || p.defaultPrevented) && (p.currentTarget.focus(), n.open || n.onOpenChange(!0));
          },
          onPointerMove: Fe(
            e.onPointerMove,
            fh((p) => {
              i.onItemEnter(p), !p.defaultPrevented && !e.disabled && !n.open && !a.current && (i.onPointerGraceIntentChange(null), a.current = window.setTimeout(() => {
                n.onOpenChange(!0), d();
              }, 100));
            })
          ),
          onPointerLeave: Fe(
            e.onPointerLeave,
            fh((p) => {
              d();
              const h = n.content?.getBoundingClientRect();
              if (h) {
                const g = n.content?.dataset.side, y = g === "right", b = y ? -5 : 5, v = h[y ? "left" : "right"], x = h[y ? "right" : "left"];
                i.onPointerGraceIntentChange({
                  area: [
                    // Apply a bleed on clientX to ensure that our exit point is
                    // consistently within polygon bounds
                    { x: p.clientX + b, y: p.clientY },
                    { x: v, y: h.top },
                    { x, y: h.top },
                    { x, y: h.bottom },
                    { x: v, y: h.bottom }
                  ],
                  side: g
                }), window.clearTimeout(s.current), s.current = window.setTimeout(
                  () => i.onPointerGraceIntentChange(null),
                  300
                );
              } else {
                if (i.onTriggerLeave(p), p.defaultPrevented) return;
                i.onPointerGraceIntentChange(null);
              }
            })
          ),
          onKeyDown: Fe(e.onKeyDown, (p) => {
            const h = i.searchRef.current !== "";
            e.disabled || h && p.key === " " || l1e[r.dir].includes(p.key) && (n.onOpenChange(!0), n.content?.focus(), p.preventDefault());
          })
        }
      ) });
    }
  );
  yU.displayName = vp;
  var vU = "MenuSubContent", bU = T.forwardRef(
    (e, t) => {
      const n = nU(Ro, e.__scopeMenu), { forceMount: r = n.forceMount, ...o } = e, i = xc(Ro, e.__scopeMenu), a = rm(Ro, e.__scopeMenu), s = mU(vU, e.__scopeMenu), l = T.useRef(null), u = an(t, l);
      return /* @__PURE__ */ S.jsx(uh.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ S.jsx(ei, { present: r || i.open, children: /* @__PURE__ */ S.jsx(uh.Slot, { scope: e.__scopeMenu, children: /* @__PURE__ */ S.jsx(
        GT,
        {
          id: s.contentId,
          "aria-labelledby": s.triggerId,
          ...o,
          ref: u,
          align: "start",
          side: a.dir === "rtl" ? "left" : "right",
          disableOutsidePointerEvents: !1,
          disableOutsideScroll: !1,
          trapFocus: !1,
          onOpenAutoFocus: (d) => {
            a.isUsingKeyboardRef.current && l.current?.focus(), d.preventDefault();
          },
          onCloseAutoFocus: (d) => d.preventDefault(),
          onFocusOutside: Fe(e.onFocusOutside, (d) => {
            d.target !== s.trigger && i.onOpenChange(!1);
          }),
          onEscapeKeyDown: Fe(e.onEscapeKeyDown, (d) => {
            a.onClose(), d.preventDefault();
          }),
          onKeyDown: Fe(e.onKeyDown, (d) => {
            const p = d.currentTarget.contains(d.target), h = c1e[a.dir].includes(d.key);
            p && h && (i.onOpenChange(!1), s.trigger?.focus(), d.preventDefault());
          })
        }
      ) }) }) });
    }
  );
  bU.displayName = vU;
  function xU(e) {
    return e ? "open" : "closed";
  }
  function E0(e) {
    return e === "indeterminate";
  }
  function ZT(e) {
    return E0(e) ? "indeterminate" : e ? "checked" : "unchecked";
  }
  function R1e(e) {
    const t = document.activeElement;
    for (const n of e)
      if (n === t || (n.focus(), document.activeElement !== t)) return;
  }
  function O1e(e, t) {
    return e.map((n, r) => e[(t + r) % e.length]);
  }
  function A1e(e, t, n) {
    const o = t.length > 1 && Array.from(t).every((u) => u === t[0]) ? t[0] : t, i = n ? e.indexOf(n) : -1;
    let a = O1e(e, Math.max(i, 0));
    o.length === 1 && (a = a.filter((u) => u !== n));
    const l = a.find(
      (u) => u.toLowerCase().startsWith(o.toLowerCase())
    );
    return l !== n ? l : void 0;
  }
  function N1e(e, t) {
    const { x: n, y: r } = e;
    let o = !1;
    for (let i = 0, a = t.length - 1; i < t.length; a = i++) {
      const s = t[i], l = t[a], u = s.x, d = s.y, p = l.x, h = l.y;
      d > r != h > r && n < (p - u) * (r - d) / (h - d) + u && (o = !o);
    }
    return o;
  }
  function M1e(e, t) {
    if (!t) return !1;
    const n = { x: e.clientX, y: e.clientY };
    return N1e(n, t);
  }
  function fh(e) {
    return (t) => t.pointerType === "mouse" ? e(t) : void 0;
  }
  var P1e = tU, $1e = qT, I1e = rU, j1e = KT, D1e = oU, F1e = e1, L1e = aU, z1e = lU, B1e = uU, U1e = dU, V1e = pU, H1e = hU, q1e = gU, W1e = yU, G1e = bU, t1 = "DropdownMenu", [K1e, fze] = Yi(
    t1,
    [Q8]
  ), Ar = Q8(), [Y1e, wU] = K1e(t1), SU = (e) => {
    const {
      __scopeDropdownMenu: t,
      children: n,
      dir: r,
      open: o,
      defaultOpen: i,
      onOpenChange: a,
      modal: s = !0
    } = e, l = Ar(t), u = T.useRef(null), [d, p] = ll({
      prop: o,
      defaultProp: i ?? !1,
      onChange: a,
      caller: t1
    });
    return /* @__PURE__ */ S.jsx(
      Y1e,
      {
        scope: t,
        triggerId: Bi(),
        triggerRef: u,
        contentId: Bi(),
        open: d,
        onOpenChange: p,
        onOpenToggle: T.useCallback(() => p((h) => !h), [p]),
        modal: s,
        children: /* @__PURE__ */ S.jsx(P1e, { ...l, open: d, onOpenChange: p, dir: r, modal: s, children: n })
      }
    );
  };
  SU.displayName = t1;
  var _U = "DropdownMenuTrigger", EU = T.forwardRef(
    (e, t) => {
      const { __scopeDropdownMenu: n, disabled: r = !1, ...o } = e, i = wU(_U, n), a = Ar(n);
      return /* @__PURE__ */ S.jsx($1e, { asChild: !0, ...a, children: /* @__PURE__ */ S.jsx(
        xt.button,
        {
          type: "button",
          id: i.triggerId,
          "aria-haspopup": "menu",
          "aria-expanded": i.open,
          "aria-controls": i.open ? i.contentId : void 0,
          "data-state": i.open ? "open" : "closed",
          "data-disabled": r ? "" : void 0,
          disabled: r,
          ...o,
          ref: lb(t, i.triggerRef),
          onPointerDown: Fe(e.onPointerDown, (s) => {
            !r && s.button === 0 && s.ctrlKey === !1 && (i.onOpenToggle(), i.open || s.preventDefault());
          }),
          onKeyDown: Fe(e.onKeyDown, (s) => {
            r || (["Enter", " "].includes(s.key) && i.onOpenToggle(), s.key === "ArrowDown" && i.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(s.key) && s.preventDefault());
          })
        }
      ) });
    }
  );
  EU.displayName = _U;
  var CU = "DropdownMenuContent", kU = T.forwardRef(
    (e, t) => {
      const { __scopeDropdownMenu: n, ...r } = e, o = wU(CU, n), i = Ar(n), a = T.useRef(!1);
      return /* @__PURE__ */ S.jsx(
        I1e,
        {
          id: o.contentId,
          "aria-labelledby": o.triggerId,
          ...i,
          ...r,
          ref: t,
          onCloseAutoFocus: Fe(e.onCloseAutoFocus, (s) => {
            a.current || o.triggerRef.current?.focus(), a.current = !1, s.preventDefault();
          }),
          onInteractOutside: Fe(e.onInteractOutside, (s) => {
            const l = s.detail.originalEvent, u = l.button === 0 && l.ctrlKey === !0, d = l.button === 2 || u;
            (!o.modal || d) && (a.current = !0);
          }),
          style: {
            ...e.style,
            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      );
    }
  );
  kU.displayName = CU;
  var X1e = "DropdownMenuGroup", TU = T.forwardRef(
    (e, t) => {
      const { __scopeDropdownMenu: n, ...r } = e, o = Ar(n);
      return /* @__PURE__ */ S.jsx(j1e, { ...o, ...r, ref: t });
    }
  );
  TU.displayName = X1e;
  var Z1e = "DropdownMenuLabel", Q1e = T.forwardRef(
    (e, t) => {
      const { __scopeDropdownMenu: n, ...r } = e, o = Ar(n);
      return /* @__PURE__ */ S.jsx(D1e, { ...o, ...r, ref: t });
    }
  );
  Q1e.displayName = Z1e;
  var J1e = "DropdownMenuItem", RU = T.forwardRef(
    (e, t) => {
      const { __scopeDropdownMenu: n, ...r } = e, o = Ar(n);
      return /* @__PURE__ */ S.jsx(F1e, { ...o, ...r, ref: t });
    }
  );
  RU.displayName = J1e;
  var exe = "DropdownMenuCheckboxItem", txe = T.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Ar(n);
    return /* @__PURE__ */ S.jsx(L1e, { ...o, ...r, ref: t });
  });
  txe.displayName = exe;
  var nxe = "DropdownMenuRadioGroup", OU = T.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Ar(n);
    return /* @__PURE__ */ S.jsx(z1e, { ...o, ...r, ref: t });
  });
  OU.displayName = nxe;
  var rxe = "DropdownMenuRadioItem", AU = T.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Ar(n);
    return /* @__PURE__ */ S.jsx(B1e, { ...o, ...r, ref: t });
  });
  AU.displayName = rxe;
  var oxe = "DropdownMenuItemIndicator", ixe = T.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Ar(n);
    return /* @__PURE__ */ S.jsx(U1e, { ...o, ...r, ref: t });
  });
  ixe.displayName = oxe;
  var axe = "DropdownMenuSeparator", sxe = T.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Ar(n);
    return /* @__PURE__ */ S.jsx(V1e, { ...o, ...r, ref: t });
  });
  sxe.displayName = axe;
  var lxe = "DropdownMenuArrow", cxe = T.forwardRef(
    (e, t) => {
      const { __scopeDropdownMenu: n, ...r } = e, o = Ar(n);
      return /* @__PURE__ */ S.jsx(H1e, { ...o, ...r, ref: t });
    }
  );
  cxe.displayName = lxe;
  var uxe = (e) => {
    const { __scopeDropdownMenu: t, children: n, open: r, onOpenChange: o, defaultOpen: i } = e, a = Ar(t), [s, l] = ll({
      prop: r,
      defaultProp: i ?? !1,
      onChange: o,
      caller: "DropdownMenuSub"
    });
    return /* @__PURE__ */ S.jsx(q1e, { ...a, open: s, onOpenChange: l, children: n });
  }, fxe = "DropdownMenuSubTrigger", NU = T.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Ar(n);
    return /* @__PURE__ */ S.jsx(W1e, { ...o, ...r, ref: t });
  });
  NU.displayName = fxe;
  var dxe = "DropdownMenuSubContent", MU = T.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Ar(n);
    return /* @__PURE__ */ S.jsx(
      G1e,
      {
        ...o,
        ...r,
        ref: t,
        style: {
          ...e.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  });
  MU.displayName = dxe;
  var QT = SU, JT = EU, eR = kU, tR = TU, Oa = RU, pxe = OU, hxe = AU, mxe = uxe, gxe = NU, yxe = MU;
  const vxe = ({
    trigger: e,
    setOpen: t,
    open: n
  }) => {
    const [r, o] = T.useState(""), [i, a] = T.useState(!0), s = jt();
    return s.options.useWorkerManager ? /* @__PURE__ */ S.jsxs(
      Ga,
      {
        setOpen: t,
        open: n,
        trigger: e,
        title: "New Worker",
        description: "Create a new worker",
        children: [
          /* @__PURE__ */ S.jsxs("div", { children: [
            "Name:",
            /* @__PURE__ */ S.jsx("br", {}),
            /* @__PURE__ */ S.jsx(
              "input",
              {
                className: "styledinput",
                onChange: (l) => {
                  o(l.currentTarget.value);
                },
                value: r
              }
            ),
            /* @__PURE__ */ S.jsxs("div", { style: { marginTop: 8 }, children: [
              /* @__PURE__ */ S.jsx(
                "input",
                {
                  type: "checkbox",
                  id: "inVenvCheckbox",
                  checked: i,
                  onChange: (l) => a(l.currentTarget.checked)
                }
              ),
              /* @__PURE__ */ S.jsx("label", { htmlFor: "inVenvCheckbox", style: { marginLeft: 4 }, children: "Create in new virtual environment" })
            ] })
          ] }),
          /* @__PURE__ */ S.jsx("div", { children: r && /* @__PURE__ */ S.jsx("div", { children: /* @__PURE__ */ S.jsx(
            "button",
            {
              className: "styledbtn",
              onClick: () => {
                s.workermanager?.new_worker({
                  name: r,
                  in_venv: i
                  // reference: reference.uuid,
                  // copyLib,
                  // copyNS,
                }), t(!1);
              },
              children: "Create"
            }
          ) }) })
        ]
      }
    ) : null;
  }, bxe = ({
    trigger: e,
    setOpen: t,
    open: n
  }) => {
    const r = jt(), [o, i] = T.useState(!1), a = r.workers(), s = r.worker?.uuid, l = (s ? a[s]?.name : void 0) || s || "worker", u = async () => {
      if (!r.worker) return;
      const d = await r.worker.export({ withFiles: o });
      IG(d, l + ".fnw", "application/zip"), t(!1);
    };
    return /* @__PURE__ */ S.jsx(
      Ga,
      {
        setOpen: t,
        open: n,
        trigger: e,
        title: "Export Worker",
        description: "Export the worker as a .fnw file",
        children: /* @__PURE__ */ S.jsxs("div", { children: [
          /* @__PURE__ */ S.jsxs("div", { children: [
            /* @__PURE__ */ S.jsx(
              "input",
              {
                type: "checkbox",
                className: "styledcheckbox",
                checked: o,
                onChange: (d) => {
                  i(d.currentTarget.checked);
                }
              }
            ),
            "Include Files"
          ] }),
          /* @__PURE__ */ S.jsx("button", { className: "styledbtn", onClick: u, children: "Export" })
        ] })
      }
    );
  }, xxe = () => {
    const e = jt(), t = e.workers(), [n, r] = T.useState(!1), [o, i] = T.useState(!1), a = (g) => {
      g !== "__select__" && e.workers && e.workermanager && t[g] && (!t[g].active && !window.confirm(
        "this is an inactive worker, selecting it will start it, continue?"
      ) || e.workermanager.set_active(g));
    }, s = async () => {
      if (!e.worker || !window.confirm(
        "Updateing the worker might replace the current nodespace, continue?"
      )) return;
      const y = await FG(".fnw");
      e.worker.update_from_export(y);
    }, l = e.options.useWorkerManager && e.workermanager && e.workermanager.open || S0, u = l && Object.keys(t).length > 0, d = e.worker && e.worker.is_open, p = d && l;
    return l || d ? /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      /* @__PURE__ */ S.jsxs(QT, { children: [
        /* @__PURE__ */ S.jsx(JT, { asChild: !0, children: /* @__PURE__ */ S.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ S.jsxs(Ws, { direction: "row", children: [
          "Worker ",
          /* @__PURE__ */ S.jsx(Uk, { className: "m-x-s" })
        ] }) }) }),
        /* @__PURE__ */ S.jsx(eR, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ S.jsxs(tR, { children: [
          u && /* @__PURE__ */ S.jsxs(mxe, { children: [
            /* @__PURE__ */ S.jsx(gxe, { className: "headermenuitem submenuitem", children: /* @__PURE__ */ S.jsxs(Ws, { direction: "row", children: [
              "Select",
              /* @__PURE__ */ S.jsx(Kp, {})
            ] }) }),
            /* @__PURE__ */ S.jsx(
              yxe,
              {
                className: "headermenucontent funcnodescontainer",
                sideOffset: 2,
                alignOffset: -5,
                children: /* @__PURE__ */ S.jsx(
                  pxe,
                  {
                    value: e.worker?.uuid,
                    onValueChange: (g) => {
                      a(g);
                    },
                    children: Object.keys(t).sort((g, y) => {
                      if (t[g].active && !t[y].active)
                        return -1;
                      if (!t[g].active && t[y].active)
                        return 1;
                      const b = t[g].name || g, v = t[y].name || y;
                      return b.localeCompare(v);
                    }).map((g) => /* @__PURE__ */ S.jsx(
                      hxe,
                      {
                        className: "headermenuitem workerselectoption" + (t[g]?.active ? " active" : " inactive") + " headermenuitem",
                        value: g,
                        disabled: g === e.worker?.uuid,
                        children: t[g]?.name || g
                      },
                      g
                    ))
                  }
                )
              }
            )
          ] }),
          d && /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
            p && /* @__PURE__ */ S.jsx(
              Oa,
              {
                className: "headermenuitem",
                onClick: () => {
                  if (e.worker) {
                    if (!e.workermanager)
                      return e.logger.error("no workermanager");
                    e.workermanager?.restart_worker(
                      e.worker.uuid
                    );
                  }
                },
                children: "Restart"
              }
            ),
            /* @__PURE__ */ S.jsx(
              Oa,
              {
                className: "headermenuitem",
                onClick: () => {
                  e.worker && e.worker.stop();
                },
                children: "Stop"
              }
            ),
            /* @__PURE__ */ S.jsx(
              Oa,
              {
                className: "headermenuitem",
                onClick: () => i(!0),
                children: "Export"
              }
            ),
            /* @__PURE__ */ S.jsx(
              Oa,
              {
                className: "headermenuitem",
                onClick: s,
                children: "Update"
              }
            )
          ] }),
          l && /* @__PURE__ */ S.jsx(S.Fragment, { children: /* @__PURE__ */ S.jsx(
            Oa,
            {
              className: "headermenuitem",
              onClick: () => r(!0),
              children: "New"
            }
          ) })
        ] }) })
      ] }),
      /* @__PURE__ */ S.jsx(
        vxe,
        {
          open: n,
          setOpen: r
        }
      ),
      /* @__PURE__ */ S.jsx(
        bxe,
        {
          open: o,
          setOpen: i
        }
      )
    ] }) : null;
  }, wxe = () => {
    const e = jt(), t = () => {
      window.confirm("Are you sure you want to start a new flow?") && e.worker?.clear();
    }, n = async () => {
      const o = await e.worker?.save();
      if (!o) return;
      const i = new Blob([JSON.stringify(o)], {
        type: "application/json"
      }), a = URL.createObjectURL(i), s = document.createElement("a");
      s.href = a, s.download = "flow.json", s.click(), URL.revokeObjectURL(a), s.remove();
    }, r = async () => {
      const o = document.createElement("input");
      o.type = "file", o.accept = ".json", o.onchange = async (i) => {
        const a = i.target.files?.[0];
        if (!a) return;
        const s = new FileReader();
        s.onload = async (l) => {
          const u = l.target?.result;
          if (!u) return;
          const d = JSON.parse(u);
          await e.worker?.load(d);
        }, s.readAsText(a);
      }, o.click();
    };
    return /* @__PURE__ */ S.jsx(S.Fragment, { children: /* @__PURE__ */ S.jsxs(QT, { children: [
      /* @__PURE__ */ S.jsx(JT, { asChild: !0, children: /* @__PURE__ */ S.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ S.jsxs(Ws, { direction: "row", children: [
        "Nodespace ",
        /* @__PURE__ */ S.jsx(Uk, { className: "m-x-s" })
      ] }) }) }),
      /* @__PURE__ */ S.jsx(eR, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ S.jsxs(tR, { children: [
        /* @__PURE__ */ S.jsx(Oa, { className: "headermenuitem", onClick: t, children: "New" }),
        /* @__PURE__ */ S.jsx(Oa, { className: "headermenuitem", onClick: n, children: "Save" }),
        /* @__PURE__ */ S.jsx(Oa, { className: "headermenuitem", onClick: r, children: "Load" })
      ] }) })
    ] }) });
  }, Sxe = ({ theme: e, selected: t }) => /* @__PURE__ */ S.jsxs(
    "div",
    {
      style: {
        width: 80,
        height: 54,
        borderRadius: "var(--fn-border-radius-s, 8px)",
        border: t ? "2.5px solid #1976d2" : "1.5px solid #bbb",
        boxShadow: t ? "0 0 0 2px #1976d2" : "0 1px 4px #0002",
        background: "var(--fn-app-background)",
        display: "flex",
        flexDirection: "column",
        alignItems: "stretch",
        justifyContent: "flex-start",
        position: "relative",
        overflow: "hidden",
        transition: "border 0.2s, box-shadow 0.2s"
      },
      "fn-data-color-theme": e,
      children: [
        /* @__PURE__ */ S.jsx(
          "div",
          {
            style: {
              height: 10,
              background: "var(--fn-primary-color)",
              borderBottom: "1px solid var(--fn-neutral-element-border)"
            }
          }
        ),
        /* @__PURE__ */ S.jsxs("div", { style: { display: "flex", flex: 1 }, children: [
          /* @__PURE__ */ S.jsx(
            "div",
            {
              style: {
                width: 12,
                background: "var(--fn-surface-elevation-low, var(--fn-container-background))",
                borderRight: "1px solid var(--fn-neutral-element-border)"
              }
            }
          ),
          /* @__PURE__ */ S.jsx(
            "div",
            {
              style: {
                flex: 1,
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                background: "var(--fn-container-background)"
              },
              children: /* @__PURE__ */ S.jsxs(
                "div",
                {
                  style: {
                    width: 22,
                    height: 14,
                    borderRadius: "var(--fn-border-radius-xs, 4px)",
                    background: "var(--fn-node-background)",
                    border: "1px solid var(--fn-node-header-color)",
                    boxShadow: "0 1px 2px #0002",
                    display: "flex",
                    flexDirection: "column"
                  },
                  children: [
                    /* @__PURE__ */ S.jsx(
                      "div",
                      {
                        style: {
                          height: 5,
                          background: "var(--fn-node-header-color)",
                          borderTopLeftRadius: "var(--fn-border-radius-xs, 4px)",
                          borderTopRightRadius: "var(--fn-border-radius-xs, 4px)"
                        }
                      }
                    ),
                    /* @__PURE__ */ S.jsx(
                      "div",
                      {
                        style: {
                          flex: 1,
                          background: "transparent"
                        }
                      }
                    )
                  ]
                }
              )
            }
          )
        ] }),
        /* @__PURE__ */ S.jsx(
          "span",
          {
            style: {
              position: "absolute",
              bottom: 2,
              right: 4,
              fontSize: 9,
              color: "var(--fn-text-color-neutral)",
              opacity: 0.7,
              textTransform: "capitalize",
              fontWeight: 600,
              pointerEvents: "none"
            },
            children: e
          }
        ),
        t && /* @__PURE__ */ S.jsx(
          "span",
          {
            style: {
              position: "absolute",
              top: 2,
              left: 6,
              fontSize: 14,
              color: "#1976d2",
              fontWeight: 900,
              pointerEvents: "none"
            },
            "aria-label": "Selected",
            children: ""
          }
        )
      ]
    }
  ), _xe = () => {
    const { colorTheme: e, setColorTheme: t } = nz(), [n, r] = T.useState(null), [o, i] = T.useState(null), a = (l) => {
      l !== e && (i(e), t(l), r(l));
    }, s = (l) => {
      n === l && o && o !== l && t(o), r(null), i(null);
    };
    return /* @__PURE__ */ S.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "1em" }, children: [
      /* @__PURE__ */ S.jsx("div", { style: { marginBottom: 8, fontWeight: 500 }, children: "Theme:" }),
      /* @__PURE__ */ S.jsx("div", { style: {
        display: "grid",
        gridTemplateColumns: "repeat(auto-fill, minmax(80px, 1fr))",
        gap: 16,
        justifyItems: "center"
      }, children: y9.map((l) => /* @__PURE__ */ S.jsx(
        "button",
        {
          onClick: () => {
            t(l), r(null), i(null);
          },
          onMouseEnter: () => a(l),
          onMouseLeave: () => s(l),
          style: {
            background: "none",
            border: "none",
            padding: 0,
            cursor: "pointer",
            outline: "none",
            borderRadius: 8
          },
          "aria-label": `Select ${l} theme`,
          children: /* @__PURE__ */ S.jsx(
            Sxe,
            {
              theme: l,
              selected: e === l
            }
          )
        },
        l
      )) })
    ] });
  }, Exe = () => {
    const [e, t] = T.useState(!1), n = () => {
      t(!0);
    };
    return /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      /* @__PURE__ */ S.jsxs(QT, { children: [
        /* @__PURE__ */ S.jsx(JT, { asChild: !0, children: /* @__PURE__ */ S.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ S.jsxs(Ws, { direction: "row", children: [
          "Settings ",
          /* @__PURE__ */ S.jsx(Uk, { className: "m-x-s" })
        ] }) }) }),
        /* @__PURE__ */ S.jsx(eR, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ S.jsx(tR, { children: /* @__PURE__ */ S.jsx(
          Oa,
          {
            className: "headermenuitem",
            onClick: n,
            children: "Appearance"
          }
        ) }) })
      ] }),
      /* @__PURE__ */ S.jsx(
        Ga,
        {
          open: e,
          setOpen: t,
          title: "Appearance",
          description: "Change the color theme.",
          closebutton: !0,
          children: /* @__PURE__ */ S.jsx(_xe, {})
        }
      )
    ] });
  }, Cxe = ({
    ...e
  }) => {
    const t = jt(), n = t.workerstate();
    return Object.keys(e).length > 0 && t.logger.debug("headerprops", e), /* @__PURE__ */ S.jsxs(Ws, { className: "funcnodesreactflowheader", direction: "row", wrap: !0, children: [
      /* @__PURE__ */ S.jsx(
        Ws,
        {
          className: "headerelement m-w-6",
          grow: {
            "": !0,
            m: !1
          },
          children: /* @__PURE__ */ S.jsx(i1e, {})
        }
      ),
      (e.showmenu || S0) && /* @__PURE__ */ S.jsxs(Ws, { direction: "row", wrap: !0, children: [
        /* @__PURE__ */ S.jsx("div", { className: "headerelement", children: /* @__PURE__ */ S.jsx(xxe, {}) }),
        (t.worker && n.is_open || S0) && /* @__PURE__ */ S.jsx("div", { className: "headerelement", children: /* @__PURE__ */ S.jsx(wxe, {}) }),
        /* @__PURE__ */ S.jsx("div", { className: "headerelement", children: /* @__PURE__ */ S.jsx(Exe, {}) })
      ] })
    ] });
  }, PU = ({ item: e }) => {
    const { node: t } = Or(), n = T.useCallback(() => {
      t?.add_node(e.node_id);
    }, [e.node_id, t]), r = T.useCallback(
      (o) => {
        o.detail === 2 && n();
      },
      [n]
    );
    return /* @__PURE__ */ S.jsx("div", { className: "libnodeentry", onClick: r, title: e.description, children: e.node_name || e.node_id });
  }, $U = (e, t) => {
    const n = e.nodes?.some(
      (o) => o.node_id.toLowerCase().includes(t.toLowerCase())
    ) ?? !1, r = e.subshelves?.some((o) => $U(o, t)) ?? !1;
    return n || r;
  }, nR = ({
    item: e,
    filter: t,
    parentkey: n
  }) => {
    const [r, o] = T.useState(!1), i = () => o(!r), a = e.nodes?.filter(
      (l) => l.node_id.toLowerCase().includes(t.toLowerCase())
    ), s = r || t.length > 0;
    return $U(e, t) ? /* @__PURE__ */ S.jsxs("div", { className: "shelfcontainer", children: [
      /* @__PURE__ */ S.jsxs(
        "div",
        {
          className: "shelftitle",
          onClick: i,
          style: { cursor: "pointer" },
          title: e.description,
          children: [
            /* @__PURE__ */ S.jsx("div", { className: "shelftitle_text", children: e.name }),
            /* @__PURE__ */ S.jsx("div", { className: "expandicon " + (s ? "open" : "close"), children: /* @__PURE__ */ S.jsx(zh, {}) })
          ]
        }
      ),
      /* @__PURE__ */ S.jsx("div", { className: "libnodecontainer " + (s ? "open" : "close"), children: /* @__PURE__ */ S.jsxs("div", { className: "libnodecontainer_inner", children: [
        a && /* @__PURE__ */ S.jsx(S.Fragment, { children: a.map((l) => /* @__PURE__ */ S.jsx(PU, { item: l }, l.node_id)) }),
        e.subshelves && /* @__PURE__ */ S.jsx(S.Fragment, { children: e.subshelves.map((l) => /* @__PURE__ */ S.jsx(
          nR,
          {
            item: l,
            filter: t,
            parentkey: n + l.name
          },
          n + l.name
        )) })
      ] }) }),
      /* @__PURE__ */ S.jsx("hr", {})
    ] }) : /* @__PURE__ */ S.jsx(S.Fragment, {});
  }, kxe = ({
    filter: e,
    setFilter: t
  }) => /* @__PURE__ */ S.jsxs("div", { className: "libfilter", children: [
    /* @__PURE__ */ S.jsx(poe, { fontSize: "inherit" }),
    /* @__PURE__ */ S.jsx(
      "input",
      {
        type: "text",
        placeholder: "Filter",
        value: e,
        onChange: (n) => {
          t(n.target.value);
        }
      }
    ),
    e && /* @__PURE__ */ S.jsx(
      bb,
      {
        fontSize: "inherit",
        onClick: () => {
          t("");
        }
      }
    )
  ] }), Txe = ({
    children: e
  }) => {
    const [t, n] = T.useState(""), r = jt(), [o, i] = T.useState(!0), [a, s] = T.useState(!0), [l, u] = T.useState(!0), [d, p] = T.useState({
      installed: [],
      available: [],
      active: []
    }), [h, g] = T.useState(!1), { lib: y } = Or(), b = (M) => {
      M && (r.worker === void 0 || !r.worker.is_open || y?.get_available_modules().then((I) => {
        p(I);
      }));
    };
    if (!r.worker)
      return /* @__PURE__ */ S.jsx(S.Fragment, {});
    const v = T.useCallback(
      (M, I) => {
        g(!1), y?.add_lib(M.name, I);
      },
      [y]
    ), x = T.useCallback(
      (M, I) => {
        g(!1), y?.add_lib(M.name, I);
      },
      [y]
    ), E = T.useCallback(
      (M) => {
        g(!1), y?.remove_lib(M.name);
      },
      [y]
    ), _ = T.useCallback(
      (M, I) => {
        g(!1), y?.add_lib(M.name, I);
      },
      [y]
    ), C = T.useCallback(
      (M) => M.filter(
        (I) => I.name.toLowerCase().includes(t.toLowerCase()) || I.description.toLowerCase().includes(t.toLowerCase())
      ),
      [t]
    ), k = C(d.available), R = C(d.installed), A = C(d.active);
    return /* @__PURE__ */ S.jsxs(
      Ga,
      {
        title: "Manage Library",
        trigger: e,
        description: "Add or remove libraries to the current worker.",
        onOpenChange: b,
        open: h,
        setOpen: g,
        children: [
          /* @__PURE__ */ S.jsx(
            "input",
            {
              className: "filter-input styledinput",
              type: "text",
              placeholder: "Filter modules...",
              value: t,
              onChange: (M) => n(M.target.value)
            }
          ),
          /* @__PURE__ */ S.jsxs(
            "div",
            {
              className: "packagelist",
              style: { maxHeight: "70%", overflow: "auto" },
              children: [
                R.length > 0 && /* @__PURE__ */ S.jsx(
                  "h3",
                  {
                    onClick: () => {
                      u(!l);
                    },
                    children: "Installed"
                  }
                ),
                l && R.map((M) => /* @__PURE__ */ S.jsx(
                  Jke,
                  {
                    availableModule: M,
                    on_add: v
                  },
                  M.name + M.source
                )),
                k.length > 0 && /* @__PURE__ */ S.jsx(
                  "h3",
                  {
                    onClick: () => {
                      s(!a);
                    },
                    children: "Available"
                  }
                ),
                a && k.map((M) => /* @__PURE__ */ S.jsx(
                  eTe,
                  {
                    availableModule: M,
                    on_add: x
                  },
                  M.name + M.source
                )),
                A.length > 0 && /* @__PURE__ */ S.jsx(
                  "h3",
                  {
                    onClick: () => {
                      i(!o);
                    },
                    children: "Active"
                  }
                ),
                o && A.map((M) => /* @__PURE__ */ S.jsx(
                  Qke,
                  {
                    availableModule: M,
                    on_remove: E,
                    on_update: _
                  },
                  M.name + M.source
                ))
              ]
            }
          )
        ]
      }
    );
  }, rR = ({
    availableModule: e
  }) => /* @__PURE__ */ S.jsxs("div", { className: "module-links", children: [
    e.homepage && /* @__PURE__ */ S.jsx(S.Fragment, { children: /* @__PURE__ */ S.jsx(
      "a",
      {
        href: e.homepage,
        target: "_blank",
        rel: "noopener noreferrer",
        children: "Homepage"
      }
    ) }),
    e.source && e.homepage && " | ",
    e.source && /* @__PURE__ */ S.jsx(S.Fragment, { children: /* @__PURE__ */ S.jsx(
      "a",
      {
        href: e.source,
        target: "_blank",
        rel: "noopener noreferrer",
        children: "Source"
      }
    ) })
  ] });
  function Rxe(e, t) {
    const n = {};
    return (e[e.length - 1] === "" ? [...e, ""] : e).join(
      (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
    ).trim();
  }
  const Oxe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, Axe = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, Nxe = {};
  function fj(e, t) {
    return (Nxe.jsx ? Axe : Oxe).test(e);
  }
  const Mxe = /[ \t\n\f\r]/g;
  function Pxe(e) {
    return typeof e == "object" ? e.type === "text" ? dj(e.value) : !1 : dj(e);
  }
  function dj(e) {
    return e.replace(Mxe, "") === "";
  }
  class om {
    /**
     * @param {SchemaType['property']} property
     *   Property.
     * @param {SchemaType['normal']} normal
     *   Normal.
     * @param {Space | undefined} [space]
     *   Space.
     * @returns
     *   Schema.
     */
    constructor(t, n, r) {
      this.normal = n, this.property = t, r && (this.space = r);
    }
  }
  om.prototype.normal = {};
  om.prototype.property = {};
  om.prototype.space = void 0;
  function IU(e, t) {
    const n = {}, r = {};
    for (const o of e)
      Object.assign(n, o.property), Object.assign(r, o.normal);
    return new om(n, r, t);
  }
  function yC(e) {
    return e.toLowerCase();
  }
  class Hr {
    /**
     * @param {string} property
     *   Property.
     * @param {string} attribute
     *   Attribute.
     * @returns
     *   Info.
     */
    constructor(t, n) {
      this.attribute = n, this.property = t;
    }
  }
  Hr.prototype.attribute = "";
  Hr.prototype.booleanish = !1;
  Hr.prototype.boolean = !1;
  Hr.prototype.commaOrSpaceSeparated = !1;
  Hr.prototype.commaSeparated = !1;
  Hr.prototype.defined = !1;
  Hr.prototype.mustUseProperty = !1;
  Hr.prototype.number = !1;
  Hr.prototype.overloadedBoolean = !1;
  Hr.prototype.property = "";
  Hr.prototype.spaceSeparated = !1;
  Hr.prototype.space = void 0;
  let $xe = 0;
  const dt = wc(), zn = wc(), vC = wc(), ke = wc(), un = wc(), Qu = wc(), Jr = wc();
  function wc() {
    return 2 ** ++$xe;
  }
  const bC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    boolean: dt,
    booleanish: zn,
    commaOrSpaceSeparated: Jr,
    commaSeparated: Qu,
    number: ke,
    overloadedBoolean: vC,
    spaceSeparated: un
  }, Symbol.toStringTag, { value: "Module" })), ZS = (
    /** @type {ReadonlyArray<keyof typeof types>} */
    Object.keys(bC)
  );
  class oR extends Hr {
    /**
     * @constructor
     * @param {string} property
     *   Property.
     * @param {string} attribute
     *   Attribute.
     * @param {number | null | undefined} [mask]
     *   Mask.
     * @param {Space | undefined} [space]
     *   Space.
     * @returns
     *   Info.
     */
    constructor(t, n, r, o) {
      let i = -1;
      if (super(t, n), pj(this, "space", o), typeof r == "number")
        for (; ++i < ZS.length; ) {
          const a = ZS[i];
          pj(this, ZS[i], (r & bC[a]) === bC[a]);
        }
    }
  }
  oR.prototype.defined = !0;
  function pj(e, t, n) {
    n && (e[t] = n);
  }
  function Pf(e) {
    const t = {}, n = {};
    for (const [r, o] of Object.entries(e.properties)) {
      const i = new oR(
        r,
        e.transform(e.attributes || {}, r),
        o,
        e.space
      );
      e.mustUseProperty && e.mustUseProperty.includes(r) && (i.mustUseProperty = !0), t[r] = i, n[yC(r)] = r, n[yC(i.attribute)] = r;
    }
    return new om(t, n, e.space);
  }
  const jU = Pf({
    properties: {
      ariaActiveDescendant: null,
      ariaAtomic: zn,
      ariaAutoComplete: null,
      ariaBusy: zn,
      ariaChecked: zn,
      ariaColCount: ke,
      ariaColIndex: ke,
      ariaColSpan: ke,
      ariaControls: un,
      ariaCurrent: null,
      ariaDescribedBy: un,
      ariaDetails: null,
      ariaDisabled: zn,
      ariaDropEffect: un,
      ariaErrorMessage: null,
      ariaExpanded: zn,
      ariaFlowTo: un,
      ariaGrabbed: zn,
      ariaHasPopup: null,
      ariaHidden: zn,
      ariaInvalid: null,
      ariaKeyShortcuts: null,
      ariaLabel: null,
      ariaLabelledBy: un,
      ariaLevel: ke,
      ariaLive: null,
      ariaModal: zn,
      ariaMultiLine: zn,
      ariaMultiSelectable: zn,
      ariaOrientation: null,
      ariaOwns: un,
      ariaPlaceholder: null,
      ariaPosInSet: ke,
      ariaPressed: zn,
      ariaReadOnly: zn,
      ariaRelevant: null,
      ariaRequired: zn,
      ariaRoleDescription: un,
      ariaRowCount: ke,
      ariaRowIndex: ke,
      ariaRowSpan: ke,
      ariaSelected: zn,
      ariaSetSize: ke,
      ariaSort: null,
      ariaValueMax: ke,
      ariaValueMin: ke,
      ariaValueNow: ke,
      ariaValueText: null,
      role: null
    },
    transform(e, t) {
      return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
    }
  });
  function DU(e, t) {
    return t in e ? e[t] : t;
  }
  function FU(e, t) {
    return DU(e, t.toLowerCase());
  }
  const Ixe = Pf({
    attributes: {
      acceptcharset: "accept-charset",
      classname: "class",
      htmlfor: "for",
      httpequiv: "http-equiv"
    },
    mustUseProperty: ["checked", "multiple", "muted", "selected"],
    properties: {
      // Standard Properties.
      abbr: null,
      accept: Qu,
      acceptCharset: un,
      accessKey: un,
      action: null,
      allow: null,
      allowFullScreen: dt,
      allowPaymentRequest: dt,
      allowUserMedia: dt,
      alt: null,
      as: null,
      async: dt,
      autoCapitalize: null,
      autoComplete: un,
      autoFocus: dt,
      autoPlay: dt,
      blocking: un,
      capture: null,
      charSet: null,
      checked: dt,
      cite: null,
      className: un,
      cols: ke,
      colSpan: null,
      content: null,
      contentEditable: zn,
      controls: dt,
      controlsList: un,
      coords: ke | Qu,
      crossOrigin: null,
      data: null,
      dateTime: null,
      decoding: null,
      default: dt,
      defer: dt,
      dir: null,
      dirName: null,
      disabled: dt,
      download: vC,
      draggable: zn,
      encType: null,
      enterKeyHint: null,
      fetchPriority: null,
      form: null,
      formAction: null,
      formEncType: null,
      formMethod: null,
      formNoValidate: dt,
      formTarget: null,
      headers: un,
      height: ke,
      hidden: vC,
      high: ke,
      href: null,
      hrefLang: null,
      htmlFor: un,
      httpEquiv: un,
      id: null,
      imageSizes: null,
      imageSrcSet: null,
      inert: dt,
      inputMode: null,
      integrity: null,
      is: null,
      isMap: dt,
      itemId: null,
      itemProp: un,
      itemRef: un,
      itemScope: dt,
      itemType: un,
      kind: null,
      label: null,
      lang: null,
      language: null,
      list: null,
      loading: null,
      loop: dt,
      low: ke,
      manifest: null,
      max: null,
      maxLength: ke,
      media: null,
      method: null,
      min: null,
      minLength: ke,
      multiple: dt,
      muted: dt,
      name: null,
      nonce: null,
      noModule: dt,
      noValidate: dt,
      onAbort: null,
      onAfterPrint: null,
      onAuxClick: null,
      onBeforeMatch: null,
      onBeforePrint: null,
      onBeforeToggle: null,
      onBeforeUnload: null,
      onBlur: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onContextLost: null,
      onContextMenu: null,
      onContextRestored: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFormData: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLanguageChange: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadEnd: null,
      onLoadStart: null,
      onMessage: null,
      onMessageError: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRejectionHandled: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onScrollEnd: null,
      onSecurityPolicyViolation: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onSlotChange: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnhandledRejection: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onWheel: null,
      open: dt,
      optimum: ke,
      pattern: null,
      ping: un,
      placeholder: null,
      playsInline: dt,
      popover: null,
      popoverTarget: null,
      popoverTargetAction: null,
      poster: null,
      preload: null,
      readOnly: dt,
      referrerPolicy: null,
      rel: un,
      required: dt,
      reversed: dt,
      rows: ke,
      rowSpan: ke,
      sandbox: un,
      scope: null,
      scoped: dt,
      seamless: dt,
      selected: dt,
      shadowRootClonable: dt,
      shadowRootDelegatesFocus: dt,
      shadowRootMode: null,
      shape: null,
      size: ke,
      sizes: null,
      slot: null,
      span: ke,
      spellCheck: zn,
      src: null,
      srcDoc: null,
      srcLang: null,
      srcSet: null,
      start: ke,
      step: null,
      style: null,
      tabIndex: ke,
      target: null,
      title: null,
      translate: null,
      type: null,
      typeMustMatch: dt,
      useMap: null,
      value: zn,
      width: ke,
      wrap: null,
      writingSuggestions: null,
      // Legacy.
      // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
      align: null,
      // Several. Use CSS `text-align` instead,
      aLink: null,
      // `<body>`. Use CSS `a:active {color}` instead
      archive: un,
      // `<object>`. List of URIs to archives
      axis: null,
      // `<td>` and `<th>`. Use `scope` on `<th>`
      background: null,
      // `<body>`. Use CSS `background-image` instead
      bgColor: null,
      // `<body>` and table elements. Use CSS `background-color` instead
      border: ke,
      // `<table>`. Use CSS `border-width` instead,
      borderColor: null,
      // `<table>`. Use CSS `border-color` instead,
      bottomMargin: ke,
      // `<body>`
      cellPadding: null,
      // `<table>`
      cellSpacing: null,
      // `<table>`
      char: null,
      // Several table elements. When `align=char`, sets the character to align on
      charOff: null,
      // Several table elements. When `char`, offsets the alignment
      classId: null,
      // `<object>`
      clear: null,
      // `<br>`. Use CSS `clear` instead
      code: null,
      // `<object>`
      codeBase: null,
      // `<object>`
      codeType: null,
      // `<object>`
      color: null,
      // `<font>` and `<hr>`. Use CSS instead
      compact: dt,
      // Lists. Use CSS to reduce space between items instead
      declare: dt,
      // `<object>`
      event: null,
      // `<script>`
      face: null,
      // `<font>`. Use CSS instead
      frame: null,
      // `<table>`
      frameBorder: null,
      // `<iframe>`. Use CSS `border` instead
      hSpace: ke,
      // `<img>` and `<object>`
      leftMargin: ke,
      // `<body>`
      link: null,
      // `<body>`. Use CSS `a:link {color: *}` instead
      longDesc: null,
      // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
      lowSrc: null,
      // `<img>`. Use a `<picture>`
      marginHeight: ke,
      // `<body>`
      marginWidth: ke,
      // `<body>`
      noResize: dt,
      // `<frame>`
      noHref: dt,
      // `<area>`. Use no href instead of an explicit `nohref`
      noShade: dt,
      // `<hr>`. Use background-color and height instead of borders
      noWrap: dt,
      // `<td>` and `<th>`
      object: null,
      // `<applet>`
      profile: null,
      // `<head>`
      prompt: null,
      // `<isindex>`
      rev: null,
      // `<link>`
      rightMargin: ke,
      // `<body>`
      rules: null,
      // `<table>`
      scheme: null,
      // `<meta>`
      scrolling: zn,
      // `<frame>`. Use overflow in the child context
      standby: null,
      // `<object>`
      summary: null,
      // `<table>`
      text: null,
      // `<body>`. Use CSS `color` instead
      topMargin: ke,
      // `<body>`
      valueType: null,
      // `<param>`
      version: null,
      // `<html>`. Use a doctype.
      vAlign: null,
      // Several. Use CSS `vertical-align` instead
      vLink: null,
      // `<body>`. Use CSS `a:visited {color}` instead
      vSpace: ke,
      // `<img>` and `<object>`
      // Non-standard Properties.
      allowTransparency: null,
      autoCorrect: null,
      autoSave: null,
      disablePictureInPicture: dt,
      disableRemotePlayback: dt,
      prefix: null,
      property: null,
      results: ke,
      security: null,
      unselectable: null
    },
    space: "html",
    transform: FU
  }), jxe = Pf({
    attributes: {
      accentHeight: "accent-height",
      alignmentBaseline: "alignment-baseline",
      arabicForm: "arabic-form",
      baselineShift: "baseline-shift",
      capHeight: "cap-height",
      className: "class",
      clipPath: "clip-path",
      clipRule: "clip-rule",
      colorInterpolation: "color-interpolation",
      colorInterpolationFilters: "color-interpolation-filters",
      colorProfile: "color-profile",
      colorRendering: "color-rendering",
      crossOrigin: "crossorigin",
      dataType: "datatype",
      dominantBaseline: "dominant-baseline",
      enableBackground: "enable-background",
      fillOpacity: "fill-opacity",
      fillRule: "fill-rule",
      floodColor: "flood-color",
      floodOpacity: "flood-opacity",
      fontFamily: "font-family",
      fontSize: "font-size",
      fontSizeAdjust: "font-size-adjust",
      fontStretch: "font-stretch",
      fontStyle: "font-style",
      fontVariant: "font-variant",
      fontWeight: "font-weight",
      glyphName: "glyph-name",
      glyphOrientationHorizontal: "glyph-orientation-horizontal",
      glyphOrientationVertical: "glyph-orientation-vertical",
      hrefLang: "hreflang",
      horizAdvX: "horiz-adv-x",
      horizOriginX: "horiz-origin-x",
      horizOriginY: "horiz-origin-y",
      imageRendering: "image-rendering",
      letterSpacing: "letter-spacing",
      lightingColor: "lighting-color",
      markerEnd: "marker-end",
      markerMid: "marker-mid",
      markerStart: "marker-start",
      navDown: "nav-down",
      navDownLeft: "nav-down-left",
      navDownRight: "nav-down-right",
      navLeft: "nav-left",
      navNext: "nav-next",
      navPrev: "nav-prev",
      navRight: "nav-right",
      navUp: "nav-up",
      navUpLeft: "nav-up-left",
      navUpRight: "nav-up-right",
      onAbort: "onabort",
      onActivate: "onactivate",
      onAfterPrint: "onafterprint",
      onBeforePrint: "onbeforeprint",
      onBegin: "onbegin",
      onCancel: "oncancel",
      onCanPlay: "oncanplay",
      onCanPlayThrough: "oncanplaythrough",
      onChange: "onchange",
      onClick: "onclick",
      onClose: "onclose",
      onCopy: "oncopy",
      onCueChange: "oncuechange",
      onCut: "oncut",
      onDblClick: "ondblclick",
      onDrag: "ondrag",
      onDragEnd: "ondragend",
      onDragEnter: "ondragenter",
      onDragExit: "ondragexit",
      onDragLeave: "ondragleave",
      onDragOver: "ondragover",
      onDragStart: "ondragstart",
      onDrop: "ondrop",
      onDurationChange: "ondurationchange",
      onEmptied: "onemptied",
      onEnd: "onend",
      onEnded: "onended",
      onError: "onerror",
      onFocus: "onfocus",
      onFocusIn: "onfocusin",
      onFocusOut: "onfocusout",
      onHashChange: "onhashchange",
      onInput: "oninput",
      onInvalid: "oninvalid",
      onKeyDown: "onkeydown",
      onKeyPress: "onkeypress",
      onKeyUp: "onkeyup",
      onLoad: "onload",
      onLoadedData: "onloadeddata",
      onLoadedMetadata: "onloadedmetadata",
      onLoadStart: "onloadstart",
      onMessage: "onmessage",
      onMouseDown: "onmousedown",
      onMouseEnter: "onmouseenter",
      onMouseLeave: "onmouseleave",
      onMouseMove: "onmousemove",
      onMouseOut: "onmouseout",
      onMouseOver: "onmouseover",
      onMouseUp: "onmouseup",
      onMouseWheel: "onmousewheel",
      onOffline: "onoffline",
      onOnline: "ononline",
      onPageHide: "onpagehide",
      onPageShow: "onpageshow",
      onPaste: "onpaste",
      onPause: "onpause",
      onPlay: "onplay",
      onPlaying: "onplaying",
      onPopState: "onpopstate",
      onProgress: "onprogress",
      onRateChange: "onratechange",
      onRepeat: "onrepeat",
      onReset: "onreset",
      onResize: "onresize",
      onScroll: "onscroll",
      onSeeked: "onseeked",
      onSeeking: "onseeking",
      onSelect: "onselect",
      onShow: "onshow",
      onStalled: "onstalled",
      onStorage: "onstorage",
      onSubmit: "onsubmit",
      onSuspend: "onsuspend",
      onTimeUpdate: "ontimeupdate",
      onToggle: "ontoggle",
      onUnload: "onunload",
      onVolumeChange: "onvolumechange",
      onWaiting: "onwaiting",
      onZoom: "onzoom",
      overlinePosition: "overline-position",
      overlineThickness: "overline-thickness",
      paintOrder: "paint-order",
      panose1: "panose-1",
      pointerEvents: "pointer-events",
      referrerPolicy: "referrerpolicy",
      renderingIntent: "rendering-intent",
      shapeRendering: "shape-rendering",
      stopColor: "stop-color",
      stopOpacity: "stop-opacity",
      strikethroughPosition: "strikethrough-position",
      strikethroughThickness: "strikethrough-thickness",
      strokeDashArray: "stroke-dasharray",
      strokeDashOffset: "stroke-dashoffset",
      strokeLineCap: "stroke-linecap",
      strokeLineJoin: "stroke-linejoin",
      strokeMiterLimit: "stroke-miterlimit",
      strokeOpacity: "stroke-opacity",
      strokeWidth: "stroke-width",
      tabIndex: "tabindex",
      textAnchor: "text-anchor",
      textDecoration: "text-decoration",
      textRendering: "text-rendering",
      transformOrigin: "transform-origin",
      typeOf: "typeof",
      underlinePosition: "underline-position",
      underlineThickness: "underline-thickness",
      unicodeBidi: "unicode-bidi",
      unicodeRange: "unicode-range",
      unitsPerEm: "units-per-em",
      vAlphabetic: "v-alphabetic",
      vHanging: "v-hanging",
      vIdeographic: "v-ideographic",
      vMathematical: "v-mathematical",
      vectorEffect: "vector-effect",
      vertAdvY: "vert-adv-y",
      vertOriginX: "vert-origin-x",
      vertOriginY: "vert-origin-y",
      wordSpacing: "word-spacing",
      writingMode: "writing-mode",
      xHeight: "x-height",
      // These were camelcased in Tiny. Now lowercased in SVG 2
      playbackOrder: "playbackorder",
      timelineBegin: "timelinebegin"
    },
    properties: {
      about: Jr,
      accentHeight: ke,
      accumulate: null,
      additive: null,
      alignmentBaseline: null,
      alphabetic: ke,
      amplitude: ke,
      arabicForm: null,
      ascent: ke,
      attributeName: null,
      attributeType: null,
      azimuth: ke,
      bandwidth: null,
      baselineShift: null,
      baseFrequency: null,
      baseProfile: null,
      bbox: null,
      begin: null,
      bias: ke,
      by: null,
      calcMode: null,
      capHeight: ke,
      className: un,
      clip: null,
      clipPath: null,
      clipPathUnits: null,
      clipRule: null,
      color: null,
      colorInterpolation: null,
      colorInterpolationFilters: null,
      colorProfile: null,
      colorRendering: null,
      content: null,
      contentScriptType: null,
      contentStyleType: null,
      crossOrigin: null,
      cursor: null,
      cx: null,
      cy: null,
      d: null,
      dataType: null,
      defaultAction: null,
      descent: ke,
      diffuseConstant: ke,
      direction: null,
      display: null,
      dur: null,
      divisor: ke,
      dominantBaseline: null,
      download: dt,
      dx: null,
      dy: null,
      edgeMode: null,
      editable: null,
      elevation: ke,
      enableBackground: null,
      end: null,
      event: null,
      exponent: ke,
      externalResourcesRequired: null,
      fill: null,
      fillOpacity: ke,
      fillRule: null,
      filter: null,
      filterRes: null,
      filterUnits: null,
      floodColor: null,
      floodOpacity: null,
      focusable: null,
      focusHighlight: null,
      fontFamily: null,
      fontSize: null,
      fontSizeAdjust: null,
      fontStretch: null,
      fontStyle: null,
      fontVariant: null,
      fontWeight: null,
      format: null,
      fr: null,
      from: null,
      fx: null,
      fy: null,
      g1: Qu,
      g2: Qu,
      glyphName: Qu,
      glyphOrientationHorizontal: null,
      glyphOrientationVertical: null,
      glyphRef: null,
      gradientTransform: null,
      gradientUnits: null,
      handler: null,
      hanging: ke,
      hatchContentUnits: null,
      hatchUnits: null,
      height: null,
      href: null,
      hrefLang: null,
      horizAdvX: ke,
      horizOriginX: ke,
      horizOriginY: ke,
      id: null,
      ideographic: ke,
      imageRendering: null,
      initialVisibility: null,
      in: null,
      in2: null,
      intercept: ke,
      k: ke,
      k1: ke,
      k2: ke,
      k3: ke,
      k4: ke,
      kernelMatrix: Jr,
      kernelUnitLength: null,
      keyPoints: null,
      // SEMI_COLON_SEPARATED
      keySplines: null,
      // SEMI_COLON_SEPARATED
      keyTimes: null,
      // SEMI_COLON_SEPARATED
      kerning: null,
      lang: null,
      lengthAdjust: null,
      letterSpacing: null,
      lightingColor: null,
      limitingConeAngle: ke,
      local: null,
      markerEnd: null,
      markerMid: null,
      markerStart: null,
      markerHeight: null,
      markerUnits: null,
      markerWidth: null,
      mask: null,
      maskContentUnits: null,
      maskUnits: null,
      mathematical: null,
      max: null,
      media: null,
      mediaCharacterEncoding: null,
      mediaContentEncodings: null,
      mediaSize: ke,
      mediaTime: null,
      method: null,
      min: null,
      mode: null,
      name: null,
      navDown: null,
      navDownLeft: null,
      navDownRight: null,
      navLeft: null,
      navNext: null,
      navPrev: null,
      navRight: null,
      navUp: null,
      navUpLeft: null,
      navUpRight: null,
      numOctaves: null,
      observer: null,
      offset: null,
      onAbort: null,
      onActivate: null,
      onAfterPrint: null,
      onBeforePrint: null,
      onBegin: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnd: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFocusIn: null,
      onFocusOut: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadStart: null,
      onMessage: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onMouseWheel: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRepeat: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onShow: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onZoom: null,
      opacity: null,
      operator: null,
      order: null,
      orient: null,
      orientation: null,
      origin: null,
      overflow: null,
      overlay: null,
      overlinePosition: ke,
      overlineThickness: ke,
      paintOrder: null,
      panose1: null,
      path: null,
      pathLength: ke,
      patternContentUnits: null,
      patternTransform: null,
      patternUnits: null,
      phase: null,
      ping: un,
      pitch: null,
      playbackOrder: null,
      pointerEvents: null,
      points: null,
      pointsAtX: ke,
      pointsAtY: ke,
      pointsAtZ: ke,
      preserveAlpha: null,
      preserveAspectRatio: null,
      primitiveUnits: null,
      propagate: null,
      property: Jr,
      r: null,
      radius: null,
      referrerPolicy: null,
      refX: null,
      refY: null,
      rel: Jr,
      rev: Jr,
      renderingIntent: null,
      repeatCount: null,
      repeatDur: null,
      requiredExtensions: Jr,
      requiredFeatures: Jr,
      requiredFonts: Jr,
      requiredFormats: Jr,
      resource: null,
      restart: null,
      result: null,
      rotate: null,
      rx: null,
      ry: null,
      scale: null,
      seed: null,
      shapeRendering: null,
      side: null,
      slope: null,
      snapshotTime: null,
      specularConstant: ke,
      specularExponent: ke,
      spreadMethod: null,
      spacing: null,
      startOffset: null,
      stdDeviation: null,
      stemh: null,
      stemv: null,
      stitchTiles: null,
      stopColor: null,
      stopOpacity: null,
      strikethroughPosition: ke,
      strikethroughThickness: ke,
      string: null,
      stroke: null,
      strokeDashArray: Jr,
      strokeDashOffset: null,
      strokeLineCap: null,
      strokeLineJoin: null,
      strokeMiterLimit: ke,
      strokeOpacity: ke,
      strokeWidth: null,
      style: null,
      surfaceScale: ke,
      syncBehavior: null,
      syncBehaviorDefault: null,
      syncMaster: null,
      syncTolerance: null,
      syncToleranceDefault: null,
      systemLanguage: Jr,
      tabIndex: ke,
      tableValues: null,
      target: null,
      targetX: ke,
      targetY: ke,
      textAnchor: null,
      textDecoration: null,
      textRendering: null,
      textLength: null,
      timelineBegin: null,
      title: null,
      transformBehavior: null,
      type: null,
      typeOf: Jr,
      to: null,
      transform: null,
      transformOrigin: null,
      u1: null,
      u2: null,
      underlinePosition: ke,
      underlineThickness: ke,
      unicode: null,
      unicodeBidi: null,
      unicodeRange: null,
      unitsPerEm: ke,
      values: null,
      vAlphabetic: ke,
      vMathematical: ke,
      vectorEffect: null,
      vHanging: ke,
      vIdeographic: ke,
      version: null,
      vertAdvY: ke,
      vertOriginX: ke,
      vertOriginY: ke,
      viewBox: null,
      viewTarget: null,
      visibility: null,
      width: null,
      widths: null,
      wordSpacing: null,
      writingMode: null,
      x: null,
      x1: null,
      x2: null,
      xChannelSelector: null,
      xHeight: ke,
      y: null,
      y1: null,
      y2: null,
      yChannelSelector: null,
      z: null,
      zoomAndPan: null
    },
    space: "svg",
    transform: DU
  }), LU = Pf({
    properties: {
      xLinkActuate: null,
      xLinkArcRole: null,
      xLinkHref: null,
      xLinkRole: null,
      xLinkShow: null,
      xLinkTitle: null,
      xLinkType: null
    },
    space: "xlink",
    transform(e, t) {
      return "xlink:" + t.slice(5).toLowerCase();
    }
  }), zU = Pf({
    attributes: { xmlnsxlink: "xmlns:xlink" },
    properties: { xmlnsXLink: null, xmlns: null },
    space: "xmlns",
    transform: FU
  }), BU = Pf({
    properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
    space: "xml",
    transform(e, t) {
      return "xml:" + t.slice(3).toLowerCase();
    }
  }), Dxe = {
    classId: "classID",
    dataType: "datatype",
    itemId: "itemID",
    strokeDashArray: "strokeDasharray",
    strokeDashOffset: "strokeDashoffset",
    strokeLineCap: "strokeLinecap",
    strokeLineJoin: "strokeLinejoin",
    strokeMiterLimit: "strokeMiterlimit",
    typeOf: "typeof",
    xLinkActuate: "xlinkActuate",
    xLinkArcRole: "xlinkArcrole",
    xLinkHref: "xlinkHref",
    xLinkRole: "xlinkRole",
    xLinkShow: "xlinkShow",
    xLinkTitle: "xlinkTitle",
    xLinkType: "xlinkType",
    xmlnsXLink: "xmlnsXlink"
  }, Fxe = /[A-Z]/g, hj = /-[a-z]/g, Lxe = /^data[-\w.:]+$/i;
  function zxe(e, t) {
    const n = yC(t);
    let r = t, o = Hr;
    if (n in e.normal)
      return e.property[e.normal[n]];
    if (n.length > 4 && n.slice(0, 4) === "data" && Lxe.test(t)) {
      if (t.charAt(4) === "-") {
        const i = t.slice(5).replace(hj, Uxe);
        r = "data" + i.charAt(0).toUpperCase() + i.slice(1);
      } else {
        const i = t.slice(4);
        if (!hj.test(i)) {
          let a = i.replace(Fxe, Bxe);
          a.charAt(0) !== "-" && (a = "-" + a), t = "data" + a;
        }
      }
      o = oR;
    }
    return new o(r, t);
  }
  function Bxe(e) {
    return "-" + e.toLowerCase();
  }
  function Uxe(e) {
    return e.charAt(1).toUpperCase();
  }
  const Vxe = IU([jU, Ixe, LU, zU, BU], "html"), iR = IU([jU, jxe, LU, zU, BU], "svg");
  function Hxe(e) {
    return e.join(" ").trim();
  }
  var Eu = {}, QS, mj;
  function qxe() {
    if (mj) return QS;
    mj = 1;
    var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, t = /\n/g, n = /^\s*/, r = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, o = /^:\s*/, i = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, a = /^[;\s]*/, s = /^\s+|\s+$/g, l = `
`, u = "/", d = "*", p = "", h = "comment", g = "declaration";
    QS = function(b, v) {
      if (typeof b != "string")
        throw new TypeError("First argument must be a string");
      if (!b) return [];
      v = v || {};
      var x = 1, E = 1;
      function _(B) {
        var j = B.match(t);
        j && (x += j.length);
        var V = B.lastIndexOf(l);
        E = ~V ? B.length - V : E + B.length;
      }
      function C() {
        var B = { line: x, column: E };
        return function(j) {
          return j.position = new k(B), M(), j;
        };
      }
      function k(B) {
        this.start = B, this.end = { line: x, column: E }, this.source = v.source;
      }
      k.prototype.content = b;
      function R(B) {
        var j = new Error(
          v.source + ":" + x + ":" + E + ": " + B
        );
        if (j.reason = B, j.filename = v.source, j.line = x, j.column = E, j.source = b, !v.silent) throw j;
      }
      function A(B) {
        var j = B.exec(b);
        if (j) {
          var V = j[0];
          return _(V), b = b.slice(V.length), j;
        }
      }
      function M() {
        A(n);
      }
      function I(B) {
        var j;
        for (B = B || []; j = D(); )
          j !== !1 && B.push(j);
        return B;
      }
      function D() {
        var B = C();
        if (!(u != b.charAt(0) || d != b.charAt(1))) {
          for (var j = 2; p != b.charAt(j) && (d != b.charAt(j) || u != b.charAt(j + 1)); )
            ++j;
          if (j += 2, p === b.charAt(j - 1))
            return R("End of comment missing");
          var V = b.slice(2, j - 2);
          return E += 2, _(V), b = b.slice(j), E += 2, B({
            type: h,
            comment: V
          });
        }
      }
      function L() {
        var B = C(), j = A(r);
        if (j) {
          if (D(), !A(o)) return R("property missing ':'");
          var V = A(i), F = B({
            type: g,
            property: y(j[0].replace(e, p)),
            value: V ? y(V[0].replace(e, p)) : p
          });
          return A(a), F;
        }
      }
      function P() {
        var B = [];
        I(B);
        for (var j; j = L(); )
          j !== !1 && (B.push(j), I(B));
        return B;
      }
      return M(), P();
    };
    function y(b) {
      return b ? b.replace(s, p) : p;
    }
    return QS;
  }
  var gj;
  function Wxe() {
    if (gj) return Eu;
    gj = 1;
    var e = Eu && Eu.__importDefault || function(r) {
      return r && r.__esModule ? r : { default: r };
    };
    Object.defineProperty(Eu, "__esModule", { value: !0 }), Eu.default = n;
    var t = e(qxe());
    function n(r, o) {
      var i = null;
      if (!r || typeof r != "string")
        return i;
      var a = (0, t.default)(r), s = typeof o == "function";
      return a.forEach(function(l) {
        if (l.type === "declaration") {
          var u = l.property, d = l.value;
          s ? o(u, d, l) : d && (i = i || {}, i[u] = d);
        }
      }), i;
    }
    return Eu;
  }
  var Yd = {}, yj;
  function Gxe() {
    if (yj) return Yd;
    yj = 1, Object.defineProperty(Yd, "__esModule", { value: !0 }), Yd.camelCase = void 0;
    var e = /^--[a-zA-Z0-9_-]+$/, t = /-([a-z])/g, n = /^[^-]+$/, r = /^-(webkit|moz|ms|o|khtml)-/, o = /^-(ms)-/, i = function(u) {
      return !u || n.test(u) || e.test(u);
    }, a = function(u, d) {
      return d.toUpperCase();
    }, s = function(u, d) {
      return "".concat(d, "-");
    }, l = function(u, d) {
      return d === void 0 && (d = {}), i(u) ? u : (u = u.toLowerCase(), d.reactCompat ? u = u.replace(o, s) : u = u.replace(r, s), u.replace(t, a));
    };
    return Yd.camelCase = l, Yd;
  }
  var Xd, vj;
  function Kxe() {
    if (vj) return Xd;
    vj = 1;
    var e = Xd && Xd.__importDefault || function(o) {
      return o && o.__esModule ? o : { default: o };
    }, t = e(Wxe()), n = Gxe();
    function r(o, i) {
      var a = {};
      return !o || typeof o != "string" || (0, t.default)(o, function(s, l) {
        s && l && (a[(0, n.camelCase)(s, i)] = l);
      }), a;
    }
    return r.default = r, Xd = r, Xd;
  }
  var Yxe = Kxe();
  const Xxe = /* @__PURE__ */ Jo(Yxe), UU = VU("end"), aR = VU("start");
  function VU(e) {
    return t;
    function t(n) {
      const r = n && n.position && n.position[e] || {};
      if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
        return {
          line: r.line,
          column: r.column,
          offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
        };
    }
  }
  function Zxe(e) {
    const t = aR(e), n = UU(e);
    if (t && n)
      return { start: t, end: n };
  }
  function Mp(e) {
    return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? bj(e.position) : "start" in e || "end" in e ? bj(e) : "line" in e || "column" in e ? xC(e) : "";
  }
  function xC(e) {
    return xj(e && e.line) + ":" + xj(e && e.column);
  }
  function bj(e) {
    return xC(e && e.start) + "-" + xC(e && e.end);
  }
  function xj(e) {
    return e && typeof e == "number" ? e : 1;
  }
  class Sr extends Error {
    /**
     * Create a message for `reason`.
     *
     * >  **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {Options | null | undefined} [options]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns
     *   Instance of `VFileMessage`.
     */
    // eslint-disable-next-line complexity
    constructor(t, n, r) {
      super(), typeof n == "string" && (r = n, n = void 0);
      let o = "", i = {}, a = !1;
      if (n && ("line" in n && "column" in n ? i = { place: n } : "start" in n && "end" in n ? i = { place: n } : "type" in n ? i = {
        ancestors: [n],
        place: n.position
      } : i = { ...n }), typeof t == "string" ? o = t : !i.cause && t && (a = !0, o = t.message, i.cause = t), !i.ruleId && !i.source && typeof r == "string") {
        const l = r.indexOf(":");
        l === -1 ? i.ruleId = r : (i.source = r.slice(0, l), i.ruleId = r.slice(l + 1));
      }
      if (!i.place && i.ancestors && i.ancestors) {
        const l = i.ancestors[i.ancestors.length - 1];
        l && (i.place = l.position);
      }
      const s = i.place && "start" in i.place ? i.place.start : i.place;
      this.ancestors = i.ancestors || void 0, this.cause = i.cause || void 0, this.column = s ? s.column : void 0, this.fatal = void 0, this.file, this.message = o, this.line = s ? s.line : void 0, this.name = Mp(i.place) || "1:1", this.place = i.place || void 0, this.reason = this.message, this.ruleId = i.ruleId || void 0, this.source = i.source || void 0, this.stack = a && i.cause && typeof i.cause.stack == "string" ? i.cause.stack : "", this.actual, this.expected, this.note, this.url;
    }
  }
  Sr.prototype.file = "";
  Sr.prototype.name = "";
  Sr.prototype.reason = "";
  Sr.prototype.message = "";
  Sr.prototype.stack = "";
  Sr.prototype.column = void 0;
  Sr.prototype.line = void 0;
  Sr.prototype.ancestors = void 0;
  Sr.prototype.cause = void 0;
  Sr.prototype.fatal = void 0;
  Sr.prototype.place = void 0;
  Sr.prototype.ruleId = void 0;
  Sr.prototype.source = void 0;
  const sR = {}.hasOwnProperty, Qxe = /* @__PURE__ */ new Map(), Jxe = /[A-Z]/g, ewe = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), twe = /* @__PURE__ */ new Set(["td", "th"]), HU = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
  function nwe(e, t) {
    if (!t || t.Fragment === void 0)
      throw new TypeError("Expected `Fragment` in options");
    const n = t.filePath || void 0;
    let r;
    if (t.development) {
      if (typeof t.jsxDEV != "function")
        throw new TypeError(
          "Expected `jsxDEV` in options when `development: true`"
        );
      r = uwe(n, t.jsxDEV);
    } else {
      if (typeof t.jsx != "function")
        throw new TypeError("Expected `jsx` in production options");
      if (typeof t.jsxs != "function")
        throw new TypeError("Expected `jsxs` in production options");
      r = cwe(n, t.jsx, t.jsxs);
    }
    const o = {
      Fragment: t.Fragment,
      ancestors: [],
      components: t.components || {},
      create: r,
      elementAttributeNameCase: t.elementAttributeNameCase || "react",
      evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
      filePath: n,
      ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
      passKeys: t.passKeys !== !1,
      passNode: t.passNode || !1,
      schema: t.space === "svg" ? iR : Vxe,
      stylePropertyNameCase: t.stylePropertyNameCase || "dom",
      tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
    }, i = qU(o, e, void 0);
    return i && typeof i != "string" ? i : o.create(
      e,
      o.Fragment,
      { children: i || void 0 },
      void 0
    );
  }
  function qU(e, t, n) {
    if (t.type === "element")
      return rwe(e, t, n);
    if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
      return owe(e, t);
    if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
      return awe(e, t, n);
    if (t.type === "mdxjsEsm")
      return iwe(e, t);
    if (t.type === "root")
      return swe(e, t, n);
    if (t.type === "text")
      return lwe(e, t);
  }
  function rwe(e, t, n) {
    const r = e.schema;
    let o = r;
    t.tagName.toLowerCase() === "svg" && r.space === "html" && (o = iR, e.schema = o), e.ancestors.push(t);
    const i = GU(e, t.tagName, !1), a = fwe(e, t);
    let s = cR(e, t);
    return ewe.has(t.tagName) && (s = s.filter(function(l) {
      return typeof l == "string" ? !Pxe(l) : !0;
    })), WU(e, a, i, t), lR(a, s), e.ancestors.pop(), e.schema = r, e.create(t, i, a, n);
  }
  function owe(e, t) {
    if (t.data && t.data.estree && e.evaluater) {
      const r = t.data.estree.body[0];
      return r.type, /** @type {Child | undefined} */
      e.evaluater.evaluateExpression(r.expression);
    }
    dh(e, t.position);
  }
  function iwe(e, t) {
    if (t.data && t.data.estree && e.evaluater)
      return (
        /** @type {Child | undefined} */
        e.evaluater.evaluateProgram(t.data.estree)
      );
    dh(e, t.position);
  }
  function awe(e, t, n) {
    const r = e.schema;
    let o = r;
    t.name === "svg" && r.space === "html" && (o = iR, e.schema = o), e.ancestors.push(t);
    const i = t.name === null ? e.Fragment : GU(e, t.name, !0), a = dwe(e, t), s = cR(e, t);
    return WU(e, a, i, t), lR(a, s), e.ancestors.pop(), e.schema = r, e.create(t, i, a, n);
  }
  function swe(e, t, n) {
    const r = {};
    return lR(r, cR(e, t)), e.create(t, e.Fragment, r, n);
  }
  function lwe(e, t) {
    return t.value;
  }
  function WU(e, t, n, r) {
    typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
  }
  function lR(e, t) {
    if (t.length > 0) {
      const n = t.length > 1 ? t : t[0];
      n && (e.children = n);
    }
  }
  function cwe(e, t, n) {
    return r;
    function r(o, i, a, s) {
      const u = Array.isArray(a.children) ? n : t;
      return s ? u(i, a, s) : u(i, a);
    }
  }
  function uwe(e, t) {
    return n;
    function n(r, o, i, a) {
      const s = Array.isArray(i.children), l = aR(r);
      return t(
        o,
        i,
        a,
        s,
        {
          columnNumber: l ? l.column - 1 : void 0,
          fileName: e,
          lineNumber: l ? l.line : void 0
        },
        void 0
      );
    }
  }
  function fwe(e, t) {
    const n = {};
    let r, o;
    for (o in t.properties)
      if (o !== "children" && sR.call(t.properties, o)) {
        const i = pwe(e, o, t.properties[o]);
        if (i) {
          const [a, s] = i;
          e.tableCellAlignToStyle && a === "align" && typeof s == "string" && twe.has(t.tagName) ? r = s : n[a] = s;
        }
      }
    if (r) {
      const i = (
        /** @type {Style} */
        n.style || (n.style = {})
      );
      i[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
    }
    return n;
  }
  function dwe(e, t) {
    const n = {};
    for (const r of t.attributes)
      if (r.type === "mdxJsxExpressionAttribute")
        if (r.data && r.data.estree && e.evaluater) {
          const i = r.data.estree.body[0];
          i.type;
          const a = i.expression;
          a.type;
          const s = a.properties[0];
          s.type, Object.assign(
            n,
            e.evaluater.evaluateExpression(s.argument)
          );
        } else
          dh(e, t.position);
      else {
        const o = r.name;
        let i;
        if (r.value && typeof r.value == "object")
          if (r.value.data && r.value.data.estree && e.evaluater) {
            const s = r.value.data.estree.body[0];
            s.type, i = e.evaluater.evaluateExpression(s.expression);
          } else
            dh(e, t.position);
        else
          i = r.value === null ? !0 : r.value;
        n[o] = /** @type {Props[keyof Props]} */
        i;
      }
    return n;
  }
  function cR(e, t) {
    const n = [];
    let r = -1;
    const o = e.passKeys ? /* @__PURE__ */ new Map() : Qxe;
    for (; ++r < t.children.length; ) {
      const i = t.children[r];
      let a;
      if (e.passKeys) {
        const l = i.type === "element" ? i.tagName : i.type === "mdxJsxFlowElement" || i.type === "mdxJsxTextElement" ? i.name : void 0;
        if (l) {
          const u = o.get(l) || 0;
          a = l + "-" + u, o.set(l, u + 1);
        }
      }
      const s = qU(e, i, a);
      s !== void 0 && n.push(s);
    }
    return n;
  }
  function pwe(e, t, n) {
    const r = zxe(e.schema, t);
    if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
      if (Array.isArray(n) && (n = r.commaSeparated ? Rxe(n) : Hxe(n)), r.property === "style") {
        let o = typeof n == "object" ? n : hwe(e, String(n));
        return e.stylePropertyNameCase === "css" && (o = mwe(o)), ["style", o];
      }
      return [
        e.elementAttributeNameCase === "react" && r.space ? Dxe[r.property] || r.property : r.attribute,
        n
      ];
    }
  }
  function hwe(e, t) {
    try {
      return Xxe(t, { reactCompat: !0 });
    } catch (n) {
      if (e.ignoreInvalidStyle)
        return {};
      const r = (
        /** @type {Error} */
        n
      ), o = new Sr("Cannot parse `style` attribute", {
        ancestors: e.ancestors,
        cause: r,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      throw o.file = e.filePath || void 0, o.url = HU + "#cannot-parse-style-attribute", o;
    }
  }
  function GU(e, t, n) {
    let r;
    if (!n)
      r = { type: "Literal", value: t };
    else if (t.includes(".")) {
      const o = t.split(".");
      let i = -1, a;
      for (; ++i < o.length; ) {
        const s = fj(o[i]) ? { type: "Identifier", name: o[i] } : { type: "Literal", value: o[i] };
        a = a ? {
          type: "MemberExpression",
          object: a,
          property: s,
          computed: !!(i && s.type === "Literal"),
          optional: !1
        } : s;
      }
      r = a;
    } else
      r = fj(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
    if (r.type === "Literal") {
      const o = (
        /** @type {string | number} */
        r.value
      );
      return sR.call(e.components, o) ? e.components[o] : o;
    }
    if (e.evaluater)
      return e.evaluater.evaluateExpression(r);
    dh(e);
  }
  function dh(e, t) {
    const n = new Sr(
      "Cannot handle MDX estrees without `createEvaluater`",
      {
        ancestors: e.ancestors,
        place: t,
        ruleId: "mdx-estree",
        source: "hast-util-to-jsx-runtime"
      }
    );
    throw n.file = e.filePath || void 0, n.url = HU + "#cannot-handle-mdx-estrees-without-createevaluater", n;
  }
  function mwe(e) {
    const t = {};
    let n;
    for (n in e)
      sR.call(e, n) && (t[gwe(n)] = e[n]);
    return t;
  }
  function gwe(e) {
    let t = e.replace(Jxe, ywe);
    return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
  }
  function ywe(e) {
    return "-" + e.toLowerCase();
  }
  const JS = {
    action: ["form"],
    cite: ["blockquote", "del", "ins", "q"],
    data: ["object"],
    formAction: ["button", "input"],
    href: ["a", "area", "base", "link"],
    icon: ["menuitem"],
    itemId: null,
    manifest: ["html"],
    ping: ["a", "area"],
    poster: ["video"],
    src: [
      "audio",
      "embed",
      "iframe",
      "img",
      "input",
      "script",
      "source",
      "track",
      "video"
    ]
  }, vwe = {};
  function uR(e, t) {
    const n = vwe, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, o = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
    return KU(e, r, o);
  }
  function KU(e, t, n) {
    if (bwe(e)) {
      if ("value" in e)
        return e.type === "html" && !n ? "" : e.value;
      if (t && "alt" in e && e.alt)
        return e.alt;
      if ("children" in e)
        return wj(e.children, t, n);
    }
    return Array.isArray(e) ? wj(e, t, n) : "";
  }
  function wj(e, t, n) {
    const r = [];
    let o = -1;
    for (; ++o < e.length; )
      r[o] = KU(e[o], t, n);
    return r.join("");
  }
  function bwe(e) {
    return !!(e && typeof e == "object");
  }
  const Sj = document.createElement("i");
  function fR(e) {
    const t = "&" + e + ";";
    Sj.innerHTML = t;
    const n = Sj.textContent;
    return (
      // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
      // yield `null`.
      n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n
    );
  }
  function so(e, t, n, r) {
    const o = e.length;
    let i = 0, a;
    if (t < 0 ? t = -t > o ? 0 : o + t : t = t > o ? o : t, n = n > 0 ? n : 0, r.length < 1e4)
      a = Array.from(r), a.unshift(t, n), e.splice(...a);
    else
      for (n && e.splice(t, n); i < r.length; )
        a = r.slice(i, i + 1e4), a.unshift(t, 0), e.splice(...a), i += 1e4, t += 1e4;
  }
  function Eo(e, t) {
    return e.length > 0 ? (so(e, e.length, 0, t), e) : t;
  }
  const _j = {}.hasOwnProperty;
  function YU(e) {
    const t = {};
    let n = -1;
    for (; ++n < e.length; )
      xwe(t, e[n]);
    return t;
  }
  function xwe(e, t) {
    let n;
    for (n in t) {
      const o = (_j.call(e, n) ? e[n] : void 0) || (e[n] = {}), i = t[n];
      let a;
      if (i)
        for (a in i) {
          _j.call(o, a) || (o[a] = []);
          const s = i[a];
          wwe(
            // @ts-expect-error Looks like a list.
            o[a],
            Array.isArray(s) ? s : s ? [s] : []
          );
        }
    }
  }
  function wwe(e, t) {
    let n = -1;
    const r = [];
    for (; ++n < t.length; )
      (t[n].add === "after" ? e : r).push(t[n]);
    so(e, 0, 0, r);
  }
  function XU(e, t) {
    const n = Number.parseInt(e, t);
    return (
      // C0 except for HT, LF, FF, CR, space.
      n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
      n > 126 && n < 160 || // Lone high surrogates and low surrogates.
      n > 55295 && n < 57344 || // Noncharacters.
      n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
      (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
      // Out of range
      n > 1114111 ? "" : String.fromCodePoint(n)
    );
  }
  function Wo(e) {
    return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
  }
  const Tr = ul(/[A-Za-z]/), gr = ul(/[\dA-Za-z]/), Swe = ul(/[#-'*+\--9=?A-Z^-~]/);
  function C0(e) {
    return (
      // Special whitespace codes (which have negative values), C0 and Control
      // character DEL
      e !== null && (e < 32 || e === 127)
    );
  }
  const wC = ul(/\d/), _we = ul(/[\dA-Fa-f]/), Ewe = ul(/[!-/:-@[-`{-~]/);
  function Xe(e) {
    return e !== null && e < -2;
  }
  function on(e) {
    return e !== null && (e < 0 || e === 32);
  }
  function Et(e) {
    return e === -2 || e === -1 || e === 32;
  }
  const n1 = ul(/\p{P}|\p{S}/u), fc = ul(/\s/);
  function ul(e) {
    return t;
    function t(n) {
      return n !== null && n > -1 && e.test(String.fromCharCode(n));
    }
  }
  function $f(e) {
    const t = [];
    let n = -1, r = 0, o = 0;
    for (; ++n < e.length; ) {
      const i = e.charCodeAt(n);
      let a = "";
      if (i === 37 && gr(e.charCodeAt(n + 1)) && gr(e.charCodeAt(n + 2)))
        o = 2;
      else if (i < 128)
        /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(i)) || (a = String.fromCharCode(i));
      else if (i > 55295 && i < 57344) {
        const s = e.charCodeAt(n + 1);
        i < 56320 && s > 56319 && s < 57344 ? (a = String.fromCharCode(i, s), o = 1) : a = "";
      } else
        a = String.fromCharCode(i);
      a && (t.push(e.slice(r, n), encodeURIComponent(a)), r = n + o + 1, a = ""), o && (n += o, o = 0);
    }
    return t.join("") + e.slice(r);
  }
  function Nt(e, t, n, r) {
    const o = r ? r - 1 : Number.POSITIVE_INFINITY;
    let i = 0;
    return a;
    function a(l) {
      return Et(l) ? (e.enter(n), s(l)) : t(l);
    }
    function s(l) {
      return Et(l) && i++ < o ? (e.consume(l), s) : (e.exit(n), t(l));
    }
  }
  const Cwe = {
    tokenize: kwe
  };
  function kwe(e) {
    const t = e.attempt(this.parser.constructs.contentInitial, r, o);
    let n;
    return t;
    function r(s) {
      if (s === null) {
        e.consume(s);
        return;
      }
      return e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), Nt(e, t, "linePrefix");
    }
    function o(s) {
      return e.enter("paragraph"), i(s);
    }
    function i(s) {
      const l = e.enter("chunkText", {
        contentType: "text",
        previous: n
      });
      return n && (n.next = l), n = l, a(s);
    }
    function a(s) {
      if (s === null) {
        e.exit("chunkText"), e.exit("paragraph"), e.consume(s);
        return;
      }
      return Xe(s) ? (e.consume(s), e.exit("chunkText"), i) : (e.consume(s), a);
    }
  }
  const Twe = {
    tokenize: Rwe
  }, Ej = {
    tokenize: Owe
  };
  function Rwe(e) {
    const t = this, n = [];
    let r = 0, o, i, a;
    return s;
    function s(_) {
      if (r < n.length) {
        const C = n[r];
        return t.containerState = C[1], e.attempt(C[0].continuation, l, u)(_);
      }
      return u(_);
    }
    function l(_) {
      if (r++, t.containerState._closeFlow) {
        t.containerState._closeFlow = void 0, o && E();
        const C = t.events.length;
        let k = C, R;
        for (; k--; )
          if (t.events[k][0] === "exit" && t.events[k][1].type === "chunkFlow") {
            R = t.events[k][1].end;
            break;
          }
        x(r);
        let A = C;
        for (; A < t.events.length; )
          t.events[A][1].end = {
            ...R
          }, A++;
        return so(t.events, k + 1, 0, t.events.slice(C)), t.events.length = A, u(_);
      }
      return s(_);
    }
    function u(_) {
      if (r === n.length) {
        if (!o)
          return h(_);
        if (o.currentConstruct && o.currentConstruct.concrete)
          return y(_);
        t.interrupt = !!(o.currentConstruct && !o._gfmTableDynamicInterruptHack);
      }
      return t.containerState = {}, e.check(Ej, d, p)(_);
    }
    function d(_) {
      return o && E(), x(r), h(_);
    }
    function p(_) {
      return t.parser.lazy[t.now().line] = r !== n.length, a = t.now().offset, y(_);
    }
    function h(_) {
      return t.containerState = {}, e.attempt(Ej, g, y)(_);
    }
    function g(_) {
      return r++, n.push([t.currentConstruct, t.containerState]), h(_);
    }
    function y(_) {
      if (_ === null) {
        o && E(), x(0), e.consume(_);
        return;
      }
      return o = o || t.parser.flow(t.now()), e.enter("chunkFlow", {
        _tokenizer: o,
        contentType: "flow",
        previous: i
      }), b(_);
    }
    function b(_) {
      if (_ === null) {
        v(e.exit("chunkFlow"), !0), x(0), e.consume(_);
        return;
      }
      return Xe(_) ? (e.consume(_), v(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, s) : (e.consume(_), b);
    }
    function v(_, C) {
      const k = t.sliceStream(_);
      if (C && k.push(null), _.previous = i, i && (i.next = _), i = _, o.defineSkip(_.start), o.write(k), t.parser.lazy[_.start.line]) {
        let R = o.events.length;
        for (; R--; )
          if (
            // The token starts before the line ending
            o.events[R][1].start.offset < a && // and either is not ended yet
            (!o.events[R][1].end || // or ends after it.
            o.events[R][1].end.offset > a)
          )
            return;
        const A = t.events.length;
        let M = A, I, D;
        for (; M--; )
          if (t.events[M][0] === "exit" && t.events[M][1].type === "chunkFlow") {
            if (I) {
              D = t.events[M][1].end;
              break;
            }
            I = !0;
          }
        for (x(r), R = A; R < t.events.length; )
          t.events[R][1].end = {
            ...D
          }, R++;
        so(t.events, M + 1, 0, t.events.slice(A)), t.events.length = R;
      }
    }
    function x(_) {
      let C = n.length;
      for (; C-- > _; ) {
        const k = n[C];
        t.containerState = k[1], k[0].exit.call(t, e);
      }
      n.length = _;
    }
    function E() {
      o.write([null]), i = void 0, o = void 0, t.containerState._closeFlow = void 0;
    }
  }
  function Owe(e, t, n) {
    return Nt(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
  }
  function mf(e) {
    if (e === null || on(e) || fc(e))
      return 1;
    if (n1(e))
      return 2;
  }
  function r1(e, t, n) {
    const r = [];
    let o = -1;
    for (; ++o < e.length; ) {
      const i = e[o].resolveAll;
      i && !r.includes(i) && (t = i(t, n), r.push(i));
    }
    return t;
  }
  const SC = {
    name: "attention",
    resolveAll: Awe,
    tokenize: Nwe
  };
  function Awe(e, t) {
    let n = -1, r, o, i, a, s, l, u, d;
    for (; ++n < e.length; )
      if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
        for (r = n; r--; )
          if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
          t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
            if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
              continue;
            l = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
            const p = {
              ...e[r][1].end
            }, h = {
              ...e[n][1].start
            };
            Cj(p, -l), Cj(h, l), a = {
              type: l > 1 ? "strongSequence" : "emphasisSequence",
              start: p,
              end: {
                ...e[r][1].end
              }
            }, s = {
              type: l > 1 ? "strongSequence" : "emphasisSequence",
              start: {
                ...e[n][1].start
              },
              end: h
            }, i = {
              type: l > 1 ? "strongText" : "emphasisText",
              start: {
                ...e[r][1].end
              },
              end: {
                ...e[n][1].start
              }
            }, o = {
              type: l > 1 ? "strong" : "emphasis",
              start: {
                ...a.start
              },
              end: {
                ...s.end
              }
            }, e[r][1].end = {
              ...a.start
            }, e[n][1].start = {
              ...s.end
            }, u = [], e[r][1].end.offset - e[r][1].start.offset && (u = Eo(u, [["enter", e[r][1], t], ["exit", e[r][1], t]])), u = Eo(u, [["enter", o, t], ["enter", a, t], ["exit", a, t], ["enter", i, t]]), u = Eo(u, r1(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), u = Eo(u, [["exit", i, t], ["enter", s, t], ["exit", s, t], ["exit", o, t]]), e[n][1].end.offset - e[n][1].start.offset ? (d = 2, u = Eo(u, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : d = 0, so(e, r - 1, n - r + 3, u), n = r + u.length - d - 2;
            break;
          }
      }
    for (n = -1; ++n < e.length; )
      e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
    return e;
  }
  function Nwe(e, t) {
    const n = this.parser.constructs.attentionMarkers.null, r = this.previous, o = mf(r);
    let i;
    return a;
    function a(l) {
      return i = l, e.enter("attentionSequence"), s(l);
    }
    function s(l) {
      if (l === i)
        return e.consume(l), s;
      const u = e.exit("attentionSequence"), d = mf(l), p = !d || d === 2 && o || n.includes(l), h = !o || o === 2 && d || n.includes(r);
      return u._open = !!(i === 42 ? p : p && (o || !h)), u._close = !!(i === 42 ? h : h && (d || !p)), t(l);
    }
  }
  function Cj(e, t) {
    e.column += t, e.offset += t, e._bufferIndex += t;
  }
  const Mwe = {
    name: "autolink",
    tokenize: Pwe
  };
  function Pwe(e, t, n) {
    let r = 0;
    return o;
    function o(g) {
      return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(g), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), i;
    }
    function i(g) {
      return Tr(g) ? (e.consume(g), a) : g === 64 ? n(g) : u(g);
    }
    function a(g) {
      return g === 43 || g === 45 || g === 46 || gr(g) ? (r = 1, s(g)) : u(g);
    }
    function s(g) {
      return g === 58 ? (e.consume(g), r = 0, l) : (g === 43 || g === 45 || g === 46 || gr(g)) && r++ < 32 ? (e.consume(g), s) : (r = 0, u(g));
    }
    function l(g) {
      return g === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(g), e.exit("autolinkMarker"), e.exit("autolink"), t) : g === null || g === 32 || g === 60 || C0(g) ? n(g) : (e.consume(g), l);
    }
    function u(g) {
      return g === 64 ? (e.consume(g), d) : Swe(g) ? (e.consume(g), u) : n(g);
    }
    function d(g) {
      return gr(g) ? p(g) : n(g);
    }
    function p(g) {
      return g === 46 ? (e.consume(g), r = 0, d) : g === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(g), e.exit("autolinkMarker"), e.exit("autolink"), t) : h(g);
    }
    function h(g) {
      if ((g === 45 || gr(g)) && r++ < 63) {
        const y = g === 45 ? h : p;
        return e.consume(g), y;
      }
      return n(g);
    }
  }
  const im = {
    partial: !0,
    tokenize: $we
  };
  function $we(e, t, n) {
    return r;
    function r(i) {
      return Et(i) ? Nt(e, o, "linePrefix")(i) : o(i);
    }
    function o(i) {
      return i === null || Xe(i) ? t(i) : n(i);
    }
  }
  const ZU = {
    continuation: {
      tokenize: jwe
    },
    exit: Dwe,
    name: "blockQuote",
    tokenize: Iwe
  };
  function Iwe(e, t, n) {
    const r = this;
    return o;
    function o(a) {
      if (a === 62) {
        const s = r.containerState;
        return s.open || (e.enter("blockQuote", {
          _container: !0
        }), s.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(a), e.exit("blockQuoteMarker"), i;
      }
      return n(a);
    }
    function i(a) {
      return Et(a) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(a), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(a));
    }
  }
  function jwe(e, t, n) {
    const r = this;
    return o;
    function o(a) {
      return Et(a) ? Nt(e, i, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(a) : i(a);
    }
    function i(a) {
      return e.attempt(ZU, t, n)(a);
    }
  }
  function Dwe(e) {
    e.exit("blockQuote");
  }
  const QU = {
    name: "characterEscape",
    tokenize: Fwe
  };
  function Fwe(e, t, n) {
    return r;
    function r(i) {
      return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(i), e.exit("escapeMarker"), o;
    }
    function o(i) {
      return Ewe(i) ? (e.enter("characterEscapeValue"), e.consume(i), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(i);
    }
  }
  const JU = {
    name: "characterReference",
    tokenize: Lwe
  };
  function Lwe(e, t, n) {
    const r = this;
    let o = 0, i, a;
    return s;
    function s(p) {
      return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(p), e.exit("characterReferenceMarker"), l;
    }
    function l(p) {
      return p === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(p), e.exit("characterReferenceMarkerNumeric"), u) : (e.enter("characterReferenceValue"), i = 31, a = gr, d(p));
    }
    function u(p) {
      return p === 88 || p === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(p), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), i = 6, a = _we, d) : (e.enter("characterReferenceValue"), i = 7, a = wC, d(p));
    }
    function d(p) {
      if (p === 59 && o) {
        const h = e.exit("characterReferenceValue");
        return a === gr && !fR(r.sliceSerialize(h)) ? n(p) : (e.enter("characterReferenceMarker"), e.consume(p), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
      }
      return a(p) && o++ < i ? (e.consume(p), d) : n(p);
    }
  }
  const kj = {
    partial: !0,
    tokenize: Bwe
  }, Tj = {
    concrete: !0,
    name: "codeFenced",
    tokenize: zwe
  };
  function zwe(e, t, n) {
    const r = this, o = {
      partial: !0,
      tokenize: k
    };
    let i = 0, a = 0, s;
    return l;
    function l(R) {
      return u(R);
    }
    function u(R) {
      const A = r.events[r.events.length - 1];
      return i = A && A[1].type === "linePrefix" ? A[2].sliceSerialize(A[1], !0).length : 0, s = R, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), d(R);
    }
    function d(R) {
      return R === s ? (a++, e.consume(R), d) : a < 3 ? n(R) : (e.exit("codeFencedFenceSequence"), Et(R) ? Nt(e, p, "whitespace")(R) : p(R));
    }
    function p(R) {
      return R === null || Xe(R) ? (e.exit("codeFencedFence"), r.interrupt ? t(R) : e.check(kj, b, C)(R)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
        contentType: "string"
      }), h(R));
    }
    function h(R) {
      return R === null || Xe(R) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), p(R)) : Et(R) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), Nt(e, g, "whitespace")(R)) : R === 96 && R === s ? n(R) : (e.consume(R), h);
    }
    function g(R) {
      return R === null || Xe(R) ? p(R) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
        contentType: "string"
      }), y(R));
    }
    function y(R) {
      return R === null || Xe(R) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), p(R)) : R === 96 && R === s ? n(R) : (e.consume(R), y);
    }
    function b(R) {
      return e.attempt(o, C, v)(R);
    }
    function v(R) {
      return e.enter("lineEnding"), e.consume(R), e.exit("lineEnding"), x;
    }
    function x(R) {
      return i > 0 && Et(R) ? Nt(e, E, "linePrefix", i + 1)(R) : E(R);
    }
    function E(R) {
      return R === null || Xe(R) ? e.check(kj, b, C)(R) : (e.enter("codeFlowValue"), _(R));
    }
    function _(R) {
      return R === null || Xe(R) ? (e.exit("codeFlowValue"), E(R)) : (e.consume(R), _);
    }
    function C(R) {
      return e.exit("codeFenced"), t(R);
    }
    function k(R, A, M) {
      let I = 0;
      return D;
      function D(V) {
        return R.enter("lineEnding"), R.consume(V), R.exit("lineEnding"), L;
      }
      function L(V) {
        return R.enter("codeFencedFence"), Et(V) ? Nt(R, P, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(V) : P(V);
      }
      function P(V) {
        return V === s ? (R.enter("codeFencedFenceSequence"), B(V)) : M(V);
      }
      function B(V) {
        return V === s ? (I++, R.consume(V), B) : I >= a ? (R.exit("codeFencedFenceSequence"), Et(V) ? Nt(R, j, "whitespace")(V) : j(V)) : M(V);
      }
      function j(V) {
        return V === null || Xe(V) ? (R.exit("codeFencedFence"), A(V)) : M(V);
      }
    }
  }
  function Bwe(e, t, n) {
    const r = this;
    return o;
    function o(a) {
      return a === null ? n(a) : (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), i);
    }
    function i(a) {
      return r.parser.lazy[r.now().line] ? n(a) : t(a);
    }
  }
  const e_ = {
    name: "codeIndented",
    tokenize: Vwe
  }, Uwe = {
    partial: !0,
    tokenize: Hwe
  };
  function Vwe(e, t, n) {
    const r = this;
    return o;
    function o(u) {
      return e.enter("codeIndented"), Nt(e, i, "linePrefix", 5)(u);
    }
    function i(u) {
      const d = r.events[r.events.length - 1];
      return d && d[1].type === "linePrefix" && d[2].sliceSerialize(d[1], !0).length >= 4 ? a(u) : n(u);
    }
    function a(u) {
      return u === null ? l(u) : Xe(u) ? e.attempt(Uwe, a, l)(u) : (e.enter("codeFlowValue"), s(u));
    }
    function s(u) {
      return u === null || Xe(u) ? (e.exit("codeFlowValue"), a(u)) : (e.consume(u), s);
    }
    function l(u) {
      return e.exit("codeIndented"), t(u);
    }
  }
  function Hwe(e, t, n) {
    const r = this;
    return o;
    function o(a) {
      return r.parser.lazy[r.now().line] ? n(a) : Xe(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), o) : Nt(e, i, "linePrefix", 5)(a);
    }
    function i(a) {
      const s = r.events[r.events.length - 1];
      return s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(a) : Xe(a) ? o(a) : n(a);
    }
  }
  const qwe = {
    name: "codeText",
    previous: Gwe,
    resolve: Wwe,
    tokenize: Kwe
  };
  function Wwe(e) {
    let t = e.length - 4, n = 3, r, o;
    if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
      for (r = n; ++r < t; )
        if (e[r][1].type === "codeTextData") {
          e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
          break;
        }
    }
    for (r = n - 1, t++; ++r <= t; )
      o === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (o = r) : (r === t || e[r][1].type === "lineEnding") && (e[o][1].type = "codeTextData", r !== o + 2 && (e[o][1].end = e[r - 1][1].end, e.splice(o + 2, r - o - 2), t -= r - o - 2, r = o + 2), o = void 0);
    return e;
  }
  function Gwe(e) {
    return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
  }
  function Kwe(e, t, n) {
    let r = 0, o, i;
    return a;
    function a(p) {
      return e.enter("codeText"), e.enter("codeTextSequence"), s(p);
    }
    function s(p) {
      return p === 96 ? (e.consume(p), r++, s) : (e.exit("codeTextSequence"), l(p));
    }
    function l(p) {
      return p === null ? n(p) : p === 32 ? (e.enter("space"), e.consume(p), e.exit("space"), l) : p === 96 ? (i = e.enter("codeTextSequence"), o = 0, d(p)) : Xe(p) ? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), l) : (e.enter("codeTextData"), u(p));
    }
    function u(p) {
      return p === null || p === 32 || p === 96 || Xe(p) ? (e.exit("codeTextData"), l(p)) : (e.consume(p), u);
    }
    function d(p) {
      return p === 96 ? (e.consume(p), o++, d) : o === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(p)) : (i.type = "codeTextData", u(p));
    }
  }
  class Ywe {
    /**
     * @param {ReadonlyArray<T> | null | undefined} [initial]
     *   Initial items (optional).
     * @returns
     *   Splice buffer.
     */
    constructor(t) {
      this.left = t ? [...t] : [], this.right = [];
    }
    /**
     * Array access;
     * does not move the cursor.
     *
     * @param {number} index
     *   Index.
     * @return {T}
     *   Item.
     */
    get(t) {
      if (t < 0 || t >= this.left.length + this.right.length)
        throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
      return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
    }
    /**
     * The length of the splice buffer, one greater than the largest index in the
     * array.
     */
    get length() {
      return this.left.length + this.right.length;
    }
    /**
     * Remove and return `list[0]`;
     * moves the cursor to `0`.
     *
     * @returns {T | undefined}
     *   Item, optional.
     */
    shift() {
      return this.setCursor(0), this.right.pop();
    }
    /**
     * Slice the buffer to get an array;
     * does not move the cursor.
     *
     * @param {number} start
     *   Start.
     * @param {number | null | undefined} [end]
     *   End (optional).
     * @returns {Array<T>}
     *   Array of items.
     */
    slice(t, n) {
      const r = n ?? Number.POSITIVE_INFINITY;
      return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
    }
    /**
     * Mimics the behavior of Array.prototype.splice() except for the change of
     * interface necessary to avoid segfaults when patching in very large arrays.
     *
     * This operation moves cursor is moved to `start` and results in the cursor
     * placed after any inserted items.
     *
     * @param {number} start
     *   Start;
     *   zero-based index at which to start changing the array;
     *   negative numbers count backwards from the end of the array and values
     *   that are out-of bounds are clamped to the appropriate end of the array.
     * @param {number | null | undefined} [deleteCount=0]
     *   Delete count (default: `0`);
     *   maximum number of elements to delete, starting from start.
     * @param {Array<T> | null | undefined} [items=[]]
     *   Items to include in place of the deleted items (default: `[]`).
     * @return {Array<T>}
     *   Any removed items.
     */
    splice(t, n, r) {
      const o = n || 0;
      this.setCursor(Math.trunc(t));
      const i = this.right.splice(this.right.length - o, Number.POSITIVE_INFINITY);
      return r && Zd(this.left, r), i.reverse();
    }
    /**
     * Remove and return the highest-numbered item in the array, so
     * `list[list.length - 1]`;
     * Moves the cursor to `length`.
     *
     * @returns {T | undefined}
     *   Item, optional.
     */
    pop() {
      return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
    }
    /**
     * Inserts a single item to the high-numbered side of the array;
     * moves the cursor to `length`.
     *
     * @param {T} item
     *   Item.
     * @returns {undefined}
     *   Nothing.
     */
    push(t) {
      this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
    }
    /**
     * Inserts many items to the high-numbered side of the array.
     * Moves the cursor to `length`.
     *
     * @param {Array<T>} items
     *   Items.
     * @returns {undefined}
     *   Nothing.
     */
    pushMany(t) {
      this.setCursor(Number.POSITIVE_INFINITY), Zd(this.left, t);
    }
    /**
     * Inserts a single item to the low-numbered side of the array;
     * Moves the cursor to `0`.
     *
     * @param {T} item
     *   Item.
     * @returns {undefined}
     *   Nothing.
     */
    unshift(t) {
      this.setCursor(0), this.right.push(t);
    }
    /**
     * Inserts many items to the low-numbered side of the array;
     * moves the cursor to `0`.
     *
     * @param {Array<T>} items
     *   Items.
     * @returns {undefined}
     *   Nothing.
     */
    unshiftMany(t) {
      this.setCursor(0), Zd(this.right, t.reverse());
    }
    /**
     * Move the cursor to a specific position in the array. Requires
     * time proportional to the distance moved.
     *
     * If `n < 0`, the cursor will end up at the beginning.
     * If `n > length`, the cursor will end up at the end.
     *
     * @param {number} n
     *   Position.
     * @return {undefined}
     *   Nothing.
     */
    setCursor(t) {
      if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
        if (t < this.left.length) {
          const n = this.left.splice(t, Number.POSITIVE_INFINITY);
          Zd(this.right, n.reverse());
        } else {
          const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
          Zd(this.left, n.reverse());
        }
    }
  }
  function Zd(e, t) {
    let n = 0;
    if (t.length < 1e4)
      e.push(...t);
    else
      for (; n < t.length; )
        e.push(...t.slice(n, n + 1e4)), n += 1e4;
  }
  function eV(e) {
    const t = {};
    let n = -1, r, o, i, a, s, l, u;
    const d = new Ywe(e);
    for (; ++n < d.length; ) {
      for (; n in t; )
        n = t[n];
      if (r = d.get(n), n && r[1].type === "chunkFlow" && d.get(n - 1)[1].type === "listItemPrefix" && (l = r[1]._tokenizer.events, i = 0, i < l.length && l[i][1].type === "lineEndingBlank" && (i += 2), i < l.length && l[i][1].type === "content"))
        for (; ++i < l.length && l[i][1].type !== "content"; )
          l[i][1].type === "chunkText" && (l[i][1]._isInFirstContentOfListItem = !0, i++);
      if (r[0] === "enter")
        r[1].contentType && (Object.assign(t, Xwe(d, n)), n = t[n], u = !0);
      else if (r[1]._container) {
        for (i = n, o = void 0; i--; )
          if (a = d.get(i), a[1].type === "lineEnding" || a[1].type === "lineEndingBlank")
            a[0] === "enter" && (o && (d.get(o)[1].type = "lineEndingBlank"), a[1].type = "lineEnding", o = i);
          else if (!(a[1].type === "linePrefix" || a[1].type === "listItemIndent")) break;
        o && (r[1].end = {
          ...d.get(o)[1].start
        }, s = d.slice(o, n), s.unshift(r), d.splice(o, n - o + 1, s));
      }
    }
    return so(e, 0, Number.POSITIVE_INFINITY, d.slice(0)), !u;
  }
  function Xwe(e, t) {
    const n = e.get(t)[1], r = e.get(t)[2];
    let o = t - 1;
    const i = [];
    let a = n._tokenizer;
    a || (a = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (a._contentTypeTextTrailing = !0));
    const s = a.events, l = [], u = {};
    let d, p, h = -1, g = n, y = 0, b = 0;
    const v = [b];
    for (; g; ) {
      for (; e.get(++o)[1] !== g; )
        ;
      i.push(o), g._tokenizer || (d = r.sliceStream(g), g.next || d.push(null), p && a.defineSkip(g.start), g._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = !0), a.write(d), g._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = void 0)), p = g, g = g.next;
    }
    for (g = n; ++h < s.length; )
      // Find a void token that includes a break.
      s[h][0] === "exit" && s[h - 1][0] === "enter" && s[h][1].type === s[h - 1][1].type && s[h][1].start.line !== s[h][1].end.line && (b = h + 1, v.push(b), g._tokenizer = void 0, g.previous = void 0, g = g.next);
    for (a.events = [], g ? (g._tokenizer = void 0, g.previous = void 0) : v.pop(), h = v.length; h--; ) {
      const x = s.slice(v[h], v[h + 1]), E = i.pop();
      l.push([E, E + x.length - 1]), e.splice(E, 2, x);
    }
    for (l.reverse(), h = -1; ++h < l.length; )
      u[y + l[h][0]] = y + l[h][1], y += l[h][1] - l[h][0] - 1;
    return u;
  }
  const Zwe = {
    resolve: Jwe,
    tokenize: eSe
  }, Qwe = {
    partial: !0,
    tokenize: tSe
  };
  function Jwe(e) {
    return eV(e), e;
  }
  function eSe(e, t) {
    let n;
    return r;
    function r(s) {
      return e.enter("content"), n = e.enter("chunkContent", {
        contentType: "content"
      }), o(s);
    }
    function o(s) {
      return s === null ? i(s) : Xe(s) ? e.check(Qwe, a, i)(s) : (e.consume(s), o);
    }
    function i(s) {
      return e.exit("chunkContent"), e.exit("content"), t(s);
    }
    function a(s) {
      return e.consume(s), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
        contentType: "content",
        previous: n
      }), n = n.next, o;
    }
  }
  function tSe(e, t, n) {
    const r = this;
    return o;
    function o(a) {
      return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), Nt(e, i, "linePrefix");
    }
    function i(a) {
      if (a === null || Xe(a))
        return n(a);
      const s = r.events[r.events.length - 1];
      return !r.parser.constructs.disable.null.includes("codeIndented") && s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(a) : e.interrupt(r.parser.constructs.flow, n, t)(a);
    }
  }
  function tV(e, t, n, r, o, i, a, s, l) {
    const u = l || Number.POSITIVE_INFINITY;
    let d = 0;
    return p;
    function p(x) {
      return x === 60 ? (e.enter(r), e.enter(o), e.enter(i), e.consume(x), e.exit(i), h) : x === null || x === 32 || x === 41 || C0(x) ? n(x) : (e.enter(r), e.enter(a), e.enter(s), e.enter("chunkString", {
        contentType: "string"
      }), b(x));
    }
    function h(x) {
      return x === 62 ? (e.enter(i), e.consume(x), e.exit(i), e.exit(o), e.exit(r), t) : (e.enter(s), e.enter("chunkString", {
        contentType: "string"
      }), g(x));
    }
    function g(x) {
      return x === 62 ? (e.exit("chunkString"), e.exit(s), h(x)) : x === null || x === 60 || Xe(x) ? n(x) : (e.consume(x), x === 92 ? y : g);
    }
    function y(x) {
      return x === 60 || x === 62 || x === 92 ? (e.consume(x), g) : g(x);
    }
    function b(x) {
      return !d && (x === null || x === 41 || on(x)) ? (e.exit("chunkString"), e.exit(s), e.exit(a), e.exit(r), t(x)) : d < u && x === 40 ? (e.consume(x), d++, b) : x === 41 ? (e.consume(x), d--, b) : x === null || x === 32 || x === 40 || C0(x) ? n(x) : (e.consume(x), x === 92 ? v : b);
    }
    function v(x) {
      return x === 40 || x === 41 || x === 92 ? (e.consume(x), b) : b(x);
    }
  }
  function nV(e, t, n, r, o, i) {
    const a = this;
    let s = 0, l;
    return u;
    function u(g) {
      return e.enter(r), e.enter(o), e.consume(g), e.exit(o), e.enter(i), d;
    }
    function d(g) {
      return s > 999 || g === null || g === 91 || g === 93 && !l || // To do: remove in the future once weve switched from
      // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
      // which doesnt need this.
      // Hidden footnotes hook.
      /* c8 ignore next 3 */
      g === 94 && !s && "_hiddenFootnoteSupport" in a.parser.constructs ? n(g) : g === 93 ? (e.exit(i), e.enter(o), e.consume(g), e.exit(o), e.exit(r), t) : Xe(g) ? (e.enter("lineEnding"), e.consume(g), e.exit("lineEnding"), d) : (e.enter("chunkString", {
        contentType: "string"
      }), p(g));
    }
    function p(g) {
      return g === null || g === 91 || g === 93 || Xe(g) || s++ > 999 ? (e.exit("chunkString"), d(g)) : (e.consume(g), l || (l = !Et(g)), g === 92 ? h : p);
    }
    function h(g) {
      return g === 91 || g === 92 || g === 93 ? (e.consume(g), s++, p) : p(g);
    }
  }
  function rV(e, t, n, r, o, i) {
    let a;
    return s;
    function s(h) {
      return h === 34 || h === 39 || h === 40 ? (e.enter(r), e.enter(o), e.consume(h), e.exit(o), a = h === 40 ? 41 : h, l) : n(h);
    }
    function l(h) {
      return h === a ? (e.enter(o), e.consume(h), e.exit(o), e.exit(r), t) : (e.enter(i), u(h));
    }
    function u(h) {
      return h === a ? (e.exit(i), l(a)) : h === null ? n(h) : Xe(h) ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), Nt(e, u, "linePrefix")) : (e.enter("chunkString", {
        contentType: "string"
      }), d(h));
    }
    function d(h) {
      return h === a || h === null || Xe(h) ? (e.exit("chunkString"), u(h)) : (e.consume(h), h === 92 ? p : d);
    }
    function p(h) {
      return h === a || h === 92 ? (e.consume(h), d) : d(h);
    }
  }
  function Pp(e, t) {
    let n;
    return r;
    function r(o) {
      return Xe(o) ? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), n = !0, r) : Et(o) ? Nt(e, r, n ? "linePrefix" : "lineSuffix")(o) : t(o);
    }
  }
  const nSe = {
    name: "definition",
    tokenize: oSe
  }, rSe = {
    partial: !0,
    tokenize: iSe
  };
  function oSe(e, t, n) {
    const r = this;
    let o;
    return i;
    function i(g) {
      return e.enter("definition"), a(g);
    }
    function a(g) {
      return nV.call(
        r,
        e,
        s,
        // Note: we dont need to reset the way `markdown-rs` does.
        n,
        "definitionLabel",
        "definitionLabelMarker",
        "definitionLabelString"
      )(g);
    }
    function s(g) {
      return o = Wo(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), g === 58 ? (e.enter("definitionMarker"), e.consume(g), e.exit("definitionMarker"), l) : n(g);
    }
    function l(g) {
      return on(g) ? Pp(e, u)(g) : u(g);
    }
    function u(g) {
      return tV(
        e,
        d,
        // Note: we dont need to reset the way `markdown-rs` does.
        n,
        "definitionDestination",
        "definitionDestinationLiteral",
        "definitionDestinationLiteralMarker",
        "definitionDestinationRaw",
        "definitionDestinationString"
      )(g);
    }
    function d(g) {
      return e.attempt(rSe, p, p)(g);
    }
    function p(g) {
      return Et(g) ? Nt(e, h, "whitespace")(g) : h(g);
    }
    function h(g) {
      return g === null || Xe(g) ? (e.exit("definition"), r.parser.defined.push(o), t(g)) : n(g);
    }
  }
  function iSe(e, t, n) {
    return r;
    function r(s) {
      return on(s) ? Pp(e, o)(s) : n(s);
    }
    function o(s) {
      return rV(e, i, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(s);
    }
    function i(s) {
      return Et(s) ? Nt(e, a, "whitespace")(s) : a(s);
    }
    function a(s) {
      return s === null || Xe(s) ? t(s) : n(s);
    }
  }
  const aSe = {
    name: "hardBreakEscape",
    tokenize: sSe
  };
  function sSe(e, t, n) {
    return r;
    function r(i) {
      return e.enter("hardBreakEscape"), e.consume(i), o;
    }
    function o(i) {
      return Xe(i) ? (e.exit("hardBreakEscape"), t(i)) : n(i);
    }
  }
  const lSe = {
    name: "headingAtx",
    resolve: cSe,
    tokenize: uSe
  };
  function cSe(e, t) {
    let n = e.length - 2, r = 3, o, i;
    return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (o = {
      type: "atxHeadingText",
      start: e[r][1].start,
      end: e[n][1].end
    }, i = {
      type: "chunkText",
      start: e[r][1].start,
      end: e[n][1].end,
      contentType: "text"
    }, so(e, r, n - r + 1, [["enter", o, t], ["enter", i, t], ["exit", i, t], ["exit", o, t]])), e;
  }
  function uSe(e, t, n) {
    let r = 0;
    return o;
    function o(d) {
      return e.enter("atxHeading"), i(d);
    }
    function i(d) {
      return e.enter("atxHeadingSequence"), a(d);
    }
    function a(d) {
      return d === 35 && r++ < 6 ? (e.consume(d), a) : d === null || on(d) ? (e.exit("atxHeadingSequence"), s(d)) : n(d);
    }
    function s(d) {
      return d === 35 ? (e.enter("atxHeadingSequence"), l(d)) : d === null || Xe(d) ? (e.exit("atxHeading"), t(d)) : Et(d) ? Nt(e, s, "whitespace")(d) : (e.enter("atxHeadingText"), u(d));
    }
    function l(d) {
      return d === 35 ? (e.consume(d), l) : (e.exit("atxHeadingSequence"), s(d));
    }
    function u(d) {
      return d === null || d === 35 || on(d) ? (e.exit("atxHeadingText"), s(d)) : (e.consume(d), u);
    }
  }
  const fSe = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "search",
    "section",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul"
  ], Rj = ["pre", "script", "style", "textarea"], dSe = {
    concrete: !0,
    name: "htmlFlow",
    resolveTo: mSe,
    tokenize: gSe
  }, pSe = {
    partial: !0,
    tokenize: vSe
  }, hSe = {
    partial: !0,
    tokenize: ySe
  };
  function mSe(e) {
    let t = e.length;
    for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
      ;
    return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
  }
  function gSe(e, t, n) {
    const r = this;
    let o, i, a, s, l;
    return u;
    function u(z) {
      return d(z);
    }
    function d(z) {
      return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(z), p;
    }
    function p(z) {
      return z === 33 ? (e.consume(z), h) : z === 47 ? (e.consume(z), i = !0, b) : z === 63 ? (e.consume(z), o = 3, r.interrupt ? t : $) : Tr(z) ? (e.consume(z), a = String.fromCharCode(z), v) : n(z);
    }
    function h(z) {
      return z === 45 ? (e.consume(z), o = 2, g) : z === 91 ? (e.consume(z), o = 5, s = 0, y) : Tr(z) ? (e.consume(z), o = 4, r.interrupt ? t : $) : n(z);
    }
    function g(z) {
      return z === 45 ? (e.consume(z), r.interrupt ? t : $) : n(z);
    }
    function y(z) {
      const H = "CDATA[";
      return z === H.charCodeAt(s++) ? (e.consume(z), s === H.length ? r.interrupt ? t : P : y) : n(z);
    }
    function b(z) {
      return Tr(z) ? (e.consume(z), a = String.fromCharCode(z), v) : n(z);
    }
    function v(z) {
      if (z === null || z === 47 || z === 62 || on(z)) {
        const H = z === 47, Y = a.toLowerCase();
        return !H && !i && Rj.includes(Y) ? (o = 1, r.interrupt ? t(z) : P(z)) : fSe.includes(a.toLowerCase()) ? (o = 6, H ? (e.consume(z), x) : r.interrupt ? t(z) : P(z)) : (o = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(z) : i ? E(z) : _(z));
      }
      return z === 45 || gr(z) ? (e.consume(z), a += String.fromCharCode(z), v) : n(z);
    }
    function x(z) {
      return z === 62 ? (e.consume(z), r.interrupt ? t : P) : n(z);
    }
    function E(z) {
      return Et(z) ? (e.consume(z), E) : D(z);
    }
    function _(z) {
      return z === 47 ? (e.consume(z), D) : z === 58 || z === 95 || Tr(z) ? (e.consume(z), C) : Et(z) ? (e.consume(z), _) : D(z);
    }
    function C(z) {
      return z === 45 || z === 46 || z === 58 || z === 95 || gr(z) ? (e.consume(z), C) : k(z);
    }
    function k(z) {
      return z === 61 ? (e.consume(z), R) : Et(z) ? (e.consume(z), k) : _(z);
    }
    function R(z) {
      return z === null || z === 60 || z === 61 || z === 62 || z === 96 ? n(z) : z === 34 || z === 39 ? (e.consume(z), l = z, A) : Et(z) ? (e.consume(z), R) : M(z);
    }
    function A(z) {
      return z === l ? (e.consume(z), l = null, I) : z === null || Xe(z) ? n(z) : (e.consume(z), A);
    }
    function M(z) {
      return z === null || z === 34 || z === 39 || z === 47 || z === 60 || z === 61 || z === 62 || z === 96 || on(z) ? k(z) : (e.consume(z), M);
    }
    function I(z) {
      return z === 47 || z === 62 || Et(z) ? _(z) : n(z);
    }
    function D(z) {
      return z === 62 ? (e.consume(z), L) : n(z);
    }
    function L(z) {
      return z === null || Xe(z) ? P(z) : Et(z) ? (e.consume(z), L) : n(z);
    }
    function P(z) {
      return z === 45 && o === 2 ? (e.consume(z), F) : z === 60 && o === 1 ? (e.consume(z), G) : z === 62 && o === 4 ? (e.consume(z), U) : z === 63 && o === 3 ? (e.consume(z), $) : z === 93 && o === 5 ? (e.consume(z), K) : Xe(z) && (o === 6 || o === 7) ? (e.exit("htmlFlowData"), e.check(pSe, X, B)(z)) : z === null || Xe(z) ? (e.exit("htmlFlowData"), B(z)) : (e.consume(z), P);
    }
    function B(z) {
      return e.check(hSe, j, X)(z);
    }
    function j(z) {
      return e.enter("lineEnding"), e.consume(z), e.exit("lineEnding"), V;
    }
    function V(z) {
      return z === null || Xe(z) ? B(z) : (e.enter("htmlFlowData"), P(z));
    }
    function F(z) {
      return z === 45 ? (e.consume(z), $) : P(z);
    }
    function G(z) {
      return z === 47 ? (e.consume(z), a = "", W) : P(z);
    }
    function W(z) {
      if (z === 62) {
        const H = a.toLowerCase();
        return Rj.includes(H) ? (e.consume(z), U) : P(z);
      }
      return Tr(z) && a.length < 8 ? (e.consume(z), a += String.fromCharCode(z), W) : P(z);
    }
    function K(z) {
      return z === 93 ? (e.consume(z), $) : P(z);
    }
    function $(z) {
      return z === 62 ? (e.consume(z), U) : z === 45 && o === 2 ? (e.consume(z), $) : P(z);
    }
    function U(z) {
      return z === null || Xe(z) ? (e.exit("htmlFlowData"), X(z)) : (e.consume(z), U);
    }
    function X(z) {
      return e.exit("htmlFlow"), t(z);
    }
  }
  function ySe(e, t, n) {
    const r = this;
    return o;
    function o(a) {
      return Xe(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), i) : n(a);
    }
    function i(a) {
      return r.parser.lazy[r.now().line] ? n(a) : t(a);
    }
  }
  function vSe(e, t, n) {
    return r;
    function r(o) {
      return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), e.attempt(im, t, n);
    }
  }
  const bSe = {
    name: "htmlText",
    tokenize: xSe
  };
  function xSe(e, t, n) {
    const r = this;
    let o, i, a;
    return s;
    function s($) {
      return e.enter("htmlText"), e.enter("htmlTextData"), e.consume($), l;
    }
    function l($) {
      return $ === 33 ? (e.consume($), u) : $ === 47 ? (e.consume($), k) : $ === 63 ? (e.consume($), _) : Tr($) ? (e.consume($), M) : n($);
    }
    function u($) {
      return $ === 45 ? (e.consume($), d) : $ === 91 ? (e.consume($), i = 0, y) : Tr($) ? (e.consume($), E) : n($);
    }
    function d($) {
      return $ === 45 ? (e.consume($), g) : n($);
    }
    function p($) {
      return $ === null ? n($) : $ === 45 ? (e.consume($), h) : Xe($) ? (a = p, G($)) : (e.consume($), p);
    }
    function h($) {
      return $ === 45 ? (e.consume($), g) : p($);
    }
    function g($) {
      return $ === 62 ? F($) : $ === 45 ? h($) : p($);
    }
    function y($) {
      const U = "CDATA[";
      return $ === U.charCodeAt(i++) ? (e.consume($), i === U.length ? b : y) : n($);
    }
    function b($) {
      return $ === null ? n($) : $ === 93 ? (e.consume($), v) : Xe($) ? (a = b, G($)) : (e.consume($), b);
    }
    function v($) {
      return $ === 93 ? (e.consume($), x) : b($);
    }
    function x($) {
      return $ === 62 ? F($) : $ === 93 ? (e.consume($), x) : b($);
    }
    function E($) {
      return $ === null || $ === 62 ? F($) : Xe($) ? (a = E, G($)) : (e.consume($), E);
    }
    function _($) {
      return $ === null ? n($) : $ === 63 ? (e.consume($), C) : Xe($) ? (a = _, G($)) : (e.consume($), _);
    }
    function C($) {
      return $ === 62 ? F($) : _($);
    }
    function k($) {
      return Tr($) ? (e.consume($), R) : n($);
    }
    function R($) {
      return $ === 45 || gr($) ? (e.consume($), R) : A($);
    }
    function A($) {
      return Xe($) ? (a = A, G($)) : Et($) ? (e.consume($), A) : F($);
    }
    function M($) {
      return $ === 45 || gr($) ? (e.consume($), M) : $ === 47 || $ === 62 || on($) ? I($) : n($);
    }
    function I($) {
      return $ === 47 ? (e.consume($), F) : $ === 58 || $ === 95 || Tr($) ? (e.consume($), D) : Xe($) ? (a = I, G($)) : Et($) ? (e.consume($), I) : F($);
    }
    function D($) {
      return $ === 45 || $ === 46 || $ === 58 || $ === 95 || gr($) ? (e.consume($), D) : L($);
    }
    function L($) {
      return $ === 61 ? (e.consume($), P) : Xe($) ? (a = L, G($)) : Et($) ? (e.consume($), L) : I($);
    }
    function P($) {
      return $ === null || $ === 60 || $ === 61 || $ === 62 || $ === 96 ? n($) : $ === 34 || $ === 39 ? (e.consume($), o = $, B) : Xe($) ? (a = P, G($)) : Et($) ? (e.consume($), P) : (e.consume($), j);
    }
    function B($) {
      return $ === o ? (e.consume($), o = void 0, V) : $ === null ? n($) : Xe($) ? (a = B, G($)) : (e.consume($), B);
    }
    function j($) {
      return $ === null || $ === 34 || $ === 39 || $ === 60 || $ === 61 || $ === 96 ? n($) : $ === 47 || $ === 62 || on($) ? I($) : (e.consume($), j);
    }
    function V($) {
      return $ === 47 || $ === 62 || on($) ? I($) : n($);
    }
    function F($) {
      return $ === 62 ? (e.consume($), e.exit("htmlTextData"), e.exit("htmlText"), t) : n($);
    }
    function G($) {
      return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume($), e.exit("lineEnding"), W;
    }
    function W($) {
      return Et($) ? Nt(e, K, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)($) : K($);
    }
    function K($) {
      return e.enter("htmlTextData"), a($);
    }
  }
  const dR = {
    name: "labelEnd",
    resolveAll: ESe,
    resolveTo: CSe,
    tokenize: kSe
  }, wSe = {
    tokenize: TSe
  }, SSe = {
    tokenize: RSe
  }, _Se = {
    tokenize: OSe
  };
  function ESe(e) {
    let t = -1;
    const n = [];
    for (; ++t < e.length; ) {
      const r = e[t][1];
      if (n.push(e[t]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
        const o = r.type === "labelImage" ? 4 : 2;
        r.type = "data", t += o;
      }
    }
    return e.length !== n.length && so(e, 0, e.length, n), e;
  }
  function CSe(e, t) {
    let n = e.length, r = 0, o, i, a, s;
    for (; n--; )
      if (o = e[n][1], i) {
        if (o.type === "link" || o.type === "labelLink" && o._inactive)
          break;
        e[n][0] === "enter" && o.type === "labelLink" && (o._inactive = !0);
      } else if (a) {
        if (e[n][0] === "enter" && (o.type === "labelImage" || o.type === "labelLink") && !o._balanced && (i = n, o.type !== "labelLink")) {
          r = 2;
          break;
        }
      } else o.type === "labelEnd" && (a = n);
    const l = {
      type: e[i][1].type === "labelLink" ? "link" : "image",
      start: {
        ...e[i][1].start
      },
      end: {
        ...e[e.length - 1][1].end
      }
    }, u = {
      type: "label",
      start: {
        ...e[i][1].start
      },
      end: {
        ...e[a][1].end
      }
    }, d = {
      type: "labelText",
      start: {
        ...e[i + r + 2][1].end
      },
      end: {
        ...e[a - 2][1].start
      }
    };
    return s = [["enter", l, t], ["enter", u, t]], s = Eo(s, e.slice(i + 1, i + r + 3)), s = Eo(s, [["enter", d, t]]), s = Eo(s, r1(t.parser.constructs.insideSpan.null, e.slice(i + r + 4, a - 3), t)), s = Eo(s, [["exit", d, t], e[a - 2], e[a - 1], ["exit", u, t]]), s = Eo(s, e.slice(a + 1)), s = Eo(s, [["exit", l, t]]), so(e, i, e.length, s), e;
  }
  function kSe(e, t, n) {
    const r = this;
    let o = r.events.length, i, a;
    for (; o--; )
      if ((r.events[o][1].type === "labelImage" || r.events[o][1].type === "labelLink") && !r.events[o][1]._balanced) {
        i = r.events[o][1];
        break;
      }
    return s;
    function s(h) {
      return i ? i._inactive ? p(h) : (a = r.parser.defined.includes(Wo(r.sliceSerialize({
        start: i.end,
        end: r.now()
      }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(h), e.exit("labelMarker"), e.exit("labelEnd"), l) : n(h);
    }
    function l(h) {
      return h === 40 ? e.attempt(wSe, d, a ? d : p)(h) : h === 91 ? e.attempt(SSe, d, a ? u : p)(h) : a ? d(h) : p(h);
    }
    function u(h) {
      return e.attempt(_Se, d, p)(h);
    }
    function d(h) {
      return t(h);
    }
    function p(h) {
      return i._balanced = !0, n(h);
    }
  }
  function TSe(e, t, n) {
    return r;
    function r(p) {
      return e.enter("resource"), e.enter("resourceMarker"), e.consume(p), e.exit("resourceMarker"), o;
    }
    function o(p) {
      return on(p) ? Pp(e, i)(p) : i(p);
    }
    function i(p) {
      return p === 41 ? d(p) : tV(e, a, s, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(p);
    }
    function a(p) {
      return on(p) ? Pp(e, l)(p) : d(p);
    }
    function s(p) {
      return n(p);
    }
    function l(p) {
      return p === 34 || p === 39 || p === 40 ? rV(e, u, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(p) : d(p);
    }
    function u(p) {
      return on(p) ? Pp(e, d)(p) : d(p);
    }
    function d(p) {
      return p === 41 ? (e.enter("resourceMarker"), e.consume(p), e.exit("resourceMarker"), e.exit("resource"), t) : n(p);
    }
  }
  function RSe(e, t, n) {
    const r = this;
    return o;
    function o(s) {
      return nV.call(r, e, i, a, "reference", "referenceMarker", "referenceString")(s);
    }
    function i(s) {
      return r.parser.defined.includes(Wo(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(s) : n(s);
    }
    function a(s) {
      return n(s);
    }
  }
  function OSe(e, t, n) {
    return r;
    function r(i) {
      return e.enter("reference"), e.enter("referenceMarker"), e.consume(i), e.exit("referenceMarker"), o;
    }
    function o(i) {
      return i === 93 ? (e.enter("referenceMarker"), e.consume(i), e.exit("referenceMarker"), e.exit("reference"), t) : n(i);
    }
  }
  const ASe = {
    name: "labelStartImage",
    resolveAll: dR.resolveAll,
    tokenize: NSe
  };
  function NSe(e, t, n) {
    const r = this;
    return o;
    function o(s) {
      return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(s), e.exit("labelImageMarker"), i;
    }
    function i(s) {
      return s === 91 ? (e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelImage"), a) : n(s);
    }
    function a(s) {
      return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s);
    }
  }
  const MSe = {
    name: "labelStartLink",
    resolveAll: dR.resolveAll,
    tokenize: PSe
  };
  function PSe(e, t, n) {
    const r = this;
    return o;
    function o(a) {
      return e.enter("labelLink"), e.enter("labelMarker"), e.consume(a), e.exit("labelMarker"), e.exit("labelLink"), i;
    }
    function i(a) {
      return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(a) : t(a);
    }
  }
  const t_ = {
    name: "lineEnding",
    tokenize: $Se
  };
  function $Se(e, t) {
    return n;
    function n(r) {
      return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), Nt(e, t, "linePrefix");
    }
  }
  const Rv = {
    name: "thematicBreak",
    tokenize: ISe
  };
  function ISe(e, t, n) {
    let r = 0, o;
    return i;
    function i(u) {
      return e.enter("thematicBreak"), a(u);
    }
    function a(u) {
      return o = u, s(u);
    }
    function s(u) {
      return u === o ? (e.enter("thematicBreakSequence"), l(u)) : r >= 3 && (u === null || Xe(u)) ? (e.exit("thematicBreak"), t(u)) : n(u);
    }
    function l(u) {
      return u === o ? (e.consume(u), r++, l) : (e.exit("thematicBreakSequence"), Et(u) ? Nt(e, s, "whitespace")(u) : s(u));
    }
  }
  const Dr = {
    continuation: {
      tokenize: LSe
    },
    exit: BSe,
    name: "list",
    tokenize: FSe
  }, jSe = {
    partial: !0,
    tokenize: USe
  }, DSe = {
    partial: !0,
    tokenize: zSe
  };
  function FSe(e, t, n) {
    const r = this, o = r.events[r.events.length - 1];
    let i = o && o[1].type === "linePrefix" ? o[2].sliceSerialize(o[1], !0).length : 0, a = 0;
    return s;
    function s(g) {
      const y = r.containerState.type || (g === 42 || g === 43 || g === 45 ? "listUnordered" : "listOrdered");
      if (y === "listUnordered" ? !r.containerState.marker || g === r.containerState.marker : wC(g)) {
        if (r.containerState.type || (r.containerState.type = y, e.enter(y, {
          _container: !0
        })), y === "listUnordered")
          return e.enter("listItemPrefix"), g === 42 || g === 45 ? e.check(Rv, n, u)(g) : u(g);
        if (!r.interrupt || g === 49)
          return e.enter("listItemPrefix"), e.enter("listItemValue"), l(g);
      }
      return n(g);
    }
    function l(g) {
      return wC(g) && ++a < 10 ? (e.consume(g), l) : (!r.interrupt || a < 2) && (r.containerState.marker ? g === r.containerState.marker : g === 41 || g === 46) ? (e.exit("listItemValue"), u(g)) : n(g);
    }
    function u(g) {
      return e.enter("listItemMarker"), e.consume(g), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || g, e.check(
        im,
        // Cant be empty when interrupting.
        r.interrupt ? n : d,
        e.attempt(jSe, h, p)
      );
    }
    function d(g) {
      return r.containerState.initialBlankLine = !0, i++, h(g);
    }
    function p(g) {
      return Et(g) ? (e.enter("listItemPrefixWhitespace"), e.consume(g), e.exit("listItemPrefixWhitespace"), h) : n(g);
    }
    function h(g) {
      return r.containerState.size = i + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(g);
    }
  }
  function LSe(e, t, n) {
    const r = this;
    return r.containerState._closeFlow = void 0, e.check(im, o, i);
    function o(s) {
      return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, Nt(e, t, "listItemIndent", r.containerState.size + 1)(s);
    }
    function i(s) {
      return r.containerState.furtherBlankLines || !Et(s) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, a(s)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(DSe, t, a)(s));
    }
    function a(s) {
      return r.containerState._closeFlow = !0, r.interrupt = void 0, Nt(e, e.attempt(Dr, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s);
    }
  }
  function zSe(e, t, n) {
    const r = this;
    return Nt(e, o, "listItemIndent", r.containerState.size + 1);
    function o(i) {
      const a = r.events[r.events.length - 1];
      return a && a[1].type === "listItemIndent" && a[2].sliceSerialize(a[1], !0).length === r.containerState.size ? t(i) : n(i);
    }
  }
  function BSe(e) {
    e.exit(this.containerState.type);
  }
  function USe(e, t, n) {
    const r = this;
    return Nt(e, o, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
    function o(i) {
      const a = r.events[r.events.length - 1];
      return !Et(i) && a && a[1].type === "listItemPrefixWhitespace" ? t(i) : n(i);
    }
  }
  const Oj = {
    name: "setextUnderline",
    resolveTo: VSe,
    tokenize: HSe
  };
  function VSe(e, t) {
    let n = e.length, r, o, i;
    for (; n--; )
      if (e[n][0] === "enter") {
        if (e[n][1].type === "content") {
          r = n;
          break;
        }
        e[n][1].type === "paragraph" && (o = n);
      } else
        e[n][1].type === "content" && e.splice(n, 1), !i && e[n][1].type === "definition" && (i = n);
    const a = {
      type: "setextHeading",
      start: {
        ...e[r][1].start
      },
      end: {
        ...e[e.length - 1][1].end
      }
    };
    return e[o][1].type = "setextHeadingText", i ? (e.splice(o, 0, ["enter", a, t]), e.splice(i + 1, 0, ["exit", e[r][1], t]), e[r][1].end = {
      ...e[i][1].end
    }) : e[r][1] = a, e.push(["exit", a, t]), e;
  }
  function HSe(e, t, n) {
    const r = this;
    let o;
    return i;
    function i(u) {
      let d = r.events.length, p;
      for (; d--; )
        if (r.events[d][1].type !== "lineEnding" && r.events[d][1].type !== "linePrefix" && r.events[d][1].type !== "content") {
          p = r.events[d][1].type === "paragraph";
          break;
        }
      return !r.parser.lazy[r.now().line] && (r.interrupt || p) ? (e.enter("setextHeadingLine"), o = u, a(u)) : n(u);
    }
    function a(u) {
      return e.enter("setextHeadingLineSequence"), s(u);
    }
    function s(u) {
      return u === o ? (e.consume(u), s) : (e.exit("setextHeadingLineSequence"), Et(u) ? Nt(e, l, "lineSuffix")(u) : l(u));
    }
    function l(u) {
      return u === null || Xe(u) ? (e.exit("setextHeadingLine"), t(u)) : n(u);
    }
  }
  const qSe = {
    tokenize: WSe
  };
  function WSe(e) {
    const t = this, n = e.attempt(
      // Try to parse a blank line.
      im,
      r,
      // Try to parse initial flow (essentially, only code).
      e.attempt(this.parser.constructs.flowInitial, o, Nt(e, e.attempt(this.parser.constructs.flow, o, e.attempt(Zwe, o)), "linePrefix"))
    );
    return n;
    function r(i) {
      if (i === null) {
        e.consume(i);
        return;
      }
      return e.enter("lineEndingBlank"), e.consume(i), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
    }
    function o(i) {
      if (i === null) {
        e.consume(i);
        return;
      }
      return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), t.currentConstruct = void 0, n;
    }
  }
  const GSe = {
    resolveAll: iV()
  }, KSe = oV("string"), YSe = oV("text");
  function oV(e) {
    return {
      resolveAll: iV(e === "text" ? XSe : void 0),
      tokenize: t
    };
    function t(n) {
      const r = this, o = this.parser.constructs[e], i = n.attempt(o, a, s);
      return a;
      function a(d) {
        return u(d) ? i(d) : s(d);
      }
      function s(d) {
        if (d === null) {
          n.consume(d);
          return;
        }
        return n.enter("data"), n.consume(d), l;
      }
      function l(d) {
        return u(d) ? (n.exit("data"), i(d)) : (n.consume(d), l);
      }
      function u(d) {
        if (d === null)
          return !0;
        const p = o[d];
        let h = -1;
        if (p)
          for (; ++h < p.length; ) {
            const g = p[h];
            if (!g.previous || g.previous.call(r, r.previous))
              return !0;
          }
        return !1;
      }
    }
  }
  function iV(e) {
    return t;
    function t(n, r) {
      let o = -1, i;
      for (; ++o <= n.length; )
        i === void 0 ? n[o] && n[o][1].type === "data" && (i = o, o++) : (!n[o] || n[o][1].type !== "data") && (o !== i + 2 && (n[i][1].end = n[o - 1][1].end, n.splice(i + 2, o - i - 2), o = i + 2), i = void 0);
      return e ? e(n, r) : n;
    }
  }
  function XSe(e, t) {
    let n = 0;
    for (; ++n <= e.length; )
      if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
        const r = e[n - 1][1], o = t.sliceStream(r);
        let i = o.length, a = -1, s = 0, l;
        for (; i--; ) {
          const u = o[i];
          if (typeof u == "string") {
            for (a = u.length; u.charCodeAt(a - 1) === 32; )
              s++, a--;
            if (a) break;
            a = -1;
          } else if (u === -2)
            l = !0, s++;
          else if (u !== -1) {
            i++;
            break;
          }
        }
        if (t._contentTypeTextTrailing && n === e.length && (s = 0), s) {
          const u = {
            type: n === e.length || l || s < 2 ? "lineSuffix" : "hardBreakTrailing",
            start: {
              _bufferIndex: i ? a : r.start._bufferIndex + a,
              _index: r.start._index + i,
              line: r.end.line,
              column: r.end.column - s,
              offset: r.end.offset - s
            },
            end: {
              ...r.end
            }
          };
          r.end = {
            ...u.start
          }, r.start.offset === r.end.offset ? Object.assign(r, u) : (e.splice(n, 0, ["enter", u, t], ["exit", u, t]), n += 2);
        }
        n++;
      }
    return e;
  }
  const ZSe = {
    42: Dr,
    43: Dr,
    45: Dr,
    48: Dr,
    49: Dr,
    50: Dr,
    51: Dr,
    52: Dr,
    53: Dr,
    54: Dr,
    55: Dr,
    56: Dr,
    57: Dr,
    62: ZU
  }, QSe = {
    91: nSe
  }, JSe = {
    [-2]: e_,
    [-1]: e_,
    32: e_
  }, e_e = {
    35: lSe,
    42: Rv,
    45: [Oj, Rv],
    60: dSe,
    61: Oj,
    95: Rv,
    96: Tj,
    126: Tj
  }, t_e = {
    38: JU,
    92: QU
  }, n_e = {
    [-5]: t_,
    [-4]: t_,
    [-3]: t_,
    33: ASe,
    38: JU,
    42: SC,
    60: [Mwe, bSe],
    91: MSe,
    92: [aSe, QU],
    93: dR,
    95: SC,
    96: qwe
  }, r_e = {
    null: [SC, GSe]
  }, o_e = {
    null: [42, 95]
  }, i_e = {
    null: []
  }, a_e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    attentionMarkers: o_e,
    contentInitial: QSe,
    disable: i_e,
    document: ZSe,
    flow: e_e,
    flowInitial: JSe,
    insideSpan: r_e,
    string: t_e,
    text: n_e
  }, Symbol.toStringTag, { value: "Module" }));
  function s_e(e, t, n) {
    let r = {
      _bufferIndex: -1,
      _index: 0,
      line: n && n.line || 1,
      column: n && n.column || 1,
      offset: n && n.offset || 0
    };
    const o = {}, i = [];
    let a = [], s = [];
    const l = {
      attempt: A(k),
      check: A(R),
      consume: E,
      enter: _,
      exit: C,
      interrupt: A(R, {
        interrupt: !0
      })
    }, u = {
      code: null,
      containerState: {},
      defineSkip: b,
      events: [],
      now: y,
      parser: e,
      previous: null,
      sliceSerialize: h,
      sliceStream: g,
      write: p
    };
    let d = t.tokenize.call(u, l);
    return t.resolveAll && i.push(t), u;
    function p(L) {
      return a = Eo(a, L), v(), a[a.length - 1] !== null ? [] : (M(t, 0), u.events = r1(i, u.events, u), u.events);
    }
    function h(L, P) {
      return c_e(g(L), P);
    }
    function g(L) {
      return l_e(a, L);
    }
    function y() {
      const {
        _bufferIndex: L,
        _index: P,
        line: B,
        column: j,
        offset: V
      } = r;
      return {
        _bufferIndex: L,
        _index: P,
        line: B,
        column: j,
        offset: V
      };
    }
    function b(L) {
      o[L.line] = L.column, D();
    }
    function v() {
      let L;
      for (; r._index < a.length; ) {
        const P = a[r._index];
        if (typeof P == "string")
          for (L = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === L && r._bufferIndex < P.length; )
            x(P.charCodeAt(r._bufferIndex));
        else
          x(P);
      }
    }
    function x(L) {
      d = d(L);
    }
    function E(L) {
      Xe(L) ? (r.line++, r.column = 1, r.offset += L === -3 ? 2 : 1, D()) : L !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
      // strings.
      /** @type {string} */
      a[r._index].length && (r._bufferIndex = -1, r._index++)), u.previous = L;
    }
    function _(L, P) {
      const B = P || {};
      return B.type = L, B.start = y(), u.events.push(["enter", B, u]), s.push(B), B;
    }
    function C(L) {
      const P = s.pop();
      return P.end = y(), u.events.push(["exit", P, u]), P;
    }
    function k(L, P) {
      M(L, P.from);
    }
    function R(L, P) {
      P.restore();
    }
    function A(L, P) {
      return B;
      function B(j, V, F) {
        let G, W, K, $;
        return Array.isArray(j) ? (
          /* c8 ignore next 1 */
          X(j)
        ) : "tokenize" in j ? (
          // Looks like a construct.
          X([
            /** @type {Construct} */
            j
          ])
        ) : U(j);
        function U(Q) {
          return re;
          function re(te) {
            const le = te !== null && Q[te], fe = te !== null && Q.null, J = [
              // To do: add more extension tests.
              /* c8 ignore next 2 */
              ...Array.isArray(le) ? le : le ? [le] : [],
              ...Array.isArray(fe) ? fe : fe ? [fe] : []
            ];
            return X(J)(te);
          }
        }
        function X(Q) {
          return G = Q, W = 0, Q.length === 0 ? F : z(Q[W]);
        }
        function z(Q) {
          return re;
          function re(te) {
            return $ = I(), K = Q, Q.partial || (u.currentConstruct = Q), Q.name && u.parser.constructs.disable.null.includes(Q.name) ? Y() : Q.tokenize.call(
              // If we do have fields, create an object w/ `context` as its
              // prototype.
              // This allows a live binding, which is needed for `interrupt`.
              P ? Object.assign(Object.create(u), P) : u,
              l,
              H,
              Y
            )(te);
          }
        }
        function H(Q) {
          return L(K, $), V;
        }
        function Y(Q) {
          return $.restore(), ++W < G.length ? z(G[W]) : F;
        }
      }
    }
    function M(L, P) {
      L.resolveAll && !i.includes(L) && i.push(L), L.resolve && so(u.events, P, u.events.length - P, L.resolve(u.events.slice(P), u)), L.resolveTo && (u.events = L.resolveTo(u.events, u));
    }
    function I() {
      const L = y(), P = u.previous, B = u.currentConstruct, j = u.events.length, V = Array.from(s);
      return {
        from: j,
        restore: F
      };
      function F() {
        r = L, u.previous = P, u.currentConstruct = B, u.events.length = j, s = V, D();
      }
    }
    function D() {
      r.line in o && r.column < 2 && (r.column = o[r.line], r.offset += o[r.line] - 1);
    }
  }
  function l_e(e, t) {
    const n = t.start._index, r = t.start._bufferIndex, o = t.end._index, i = t.end._bufferIndex;
    let a;
    if (n === o)
      a = [e[n].slice(r, i)];
    else {
      if (a = e.slice(n, o), r > -1) {
        const s = a[0];
        typeof s == "string" ? a[0] = s.slice(r) : a.shift();
      }
      i > 0 && a.push(e[o].slice(0, i));
    }
    return a;
  }
  function c_e(e, t) {
    let n = -1;
    const r = [];
    let o;
    for (; ++n < e.length; ) {
      const i = e[n];
      let a;
      if (typeof i == "string")
        a = i;
      else switch (i) {
        case -5: {
          a = "\r";
          break;
        }
        case -4: {
          a = `
`;
          break;
        }
        case -3: {
          a = `\r
`;
          break;
        }
        case -2: {
          a = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && o) continue;
          a = " ";
          break;
        }
        default:
          a = String.fromCharCode(i);
      }
      o = i === -2, r.push(a);
    }
    return r.join("");
  }
  function u_e(e) {
    const r = {
      constructs: (
        /** @type {FullNormalizedExtension} */
        YU([a_e, ...(e || {}).extensions || []])
      ),
      content: o(Cwe),
      defined: [],
      document: o(Twe),
      flow: o(qSe),
      lazy: {},
      string: o(KSe),
      text: o(YSe)
    };
    return r;
    function o(i) {
      return a;
      function a(s) {
        return s_e(r, i, s);
      }
    }
  }
  function f_e(e) {
    for (; !eV(e); )
      ;
    return e;
  }
  const Aj = /[\0\t\n\r]/g;
  function d_e() {
    let e = 1, t = "", n = !0, r;
    return o;
    function o(i, a, s) {
      const l = [];
      let u, d, p, h, g;
      for (i = t + (typeof i == "string" ? i.toString() : new TextDecoder(a || void 0).decode(i)), p = 0, t = "", n && (i.charCodeAt(0) === 65279 && p++, n = void 0); p < i.length; ) {
        if (Aj.lastIndex = p, u = Aj.exec(i), h = u && u.index !== void 0 ? u.index : i.length, g = i.charCodeAt(h), !u) {
          t = i.slice(p);
          break;
        }
        if (g === 10 && p === h && r)
          l.push(-3), r = void 0;
        else
          switch (r && (l.push(-5), r = void 0), p < h && (l.push(i.slice(p, h)), e += h - p), g) {
            case 0: {
              l.push(65533), e++;
              break;
            }
            case 9: {
              for (d = Math.ceil(e / 4) * 4, l.push(-2); e++ < d; ) l.push(-1);
              break;
            }
            case 10: {
              l.push(-4), e = 1;
              break;
            }
            default:
              r = !0, e = 1;
          }
        p = h + 1;
      }
      return s && (r && l.push(-5), t && l.push(t), l.push(null)), l;
    }
  }
  const p_e = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
  function h_e(e) {
    return e.replace(p_e, m_e);
  }
  function m_e(e, t, n) {
    if (t)
      return t;
    if (n.charCodeAt(0) === 35) {
      const o = n.charCodeAt(1), i = o === 120 || o === 88;
      return XU(n.slice(i ? 2 : 1), i ? 16 : 10);
    }
    return fR(n) || e;
  }
  const aV = {}.hasOwnProperty;
  function g_e(e, t, n) {
    return typeof t != "string" && (n = t, t = void 0), y_e(n)(f_e(u_e(n).document().write(d_e()(e, t, !0))));
  }
  function y_e(e) {
    const t = {
      transforms: [],
      canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
      enter: {
        autolink: i(Ve),
        autolinkProtocol: I,
        autolinkEmail: I,
        atxHeading: i(ge),
        blockQuote: i(fe),
        characterEscape: I,
        characterReference: I,
        codeFenced: i(J),
        codeFencedFenceInfo: a,
        codeFencedFenceMeta: a,
        codeIndented: i(J, a),
        codeText: i(ee, a),
        codeTextData: I,
        data: I,
        codeFlowValue: I,
        definition: i(ie),
        definitionDestinationString: a,
        definitionLabelString: a,
        definitionTitleString: a,
        emphasis: i(ae),
        hardBreakEscape: i(Ce),
        hardBreakTrailing: i(Ce),
        htmlFlow: i(Ne, a),
        htmlFlowData: I,
        htmlText: i(Ne, a),
        htmlTextData: I,
        image: i(Le),
        label: a,
        link: i(Ve),
        listItem: i(ze),
        listItemValue: h,
        listOrdered: i(Ke, p),
        listUnordered: i(Ke),
        paragraph: i(Me),
        reference: z,
        referenceString: a,
        resourceDestinationString: a,
        resourceTitleString: a,
        setextHeading: i(ge),
        strong: i(ct),
        thematicBreak: i(Re)
      },
      exit: {
        atxHeading: l(),
        atxHeadingSequence: k,
        autolink: l(),
        autolinkEmail: le,
        autolinkProtocol: te,
        blockQuote: l(),
        characterEscapeValue: D,
        characterReferenceMarkerHexadecimal: Y,
        characterReferenceMarkerNumeric: Y,
        characterReferenceValue: Q,
        characterReference: re,
        codeFenced: l(v),
        codeFencedFence: b,
        codeFencedFenceInfo: g,
        codeFencedFenceMeta: y,
        codeFlowValue: D,
        codeIndented: l(x),
        codeText: l(V),
        codeTextData: D,
        data: D,
        definition: l(),
        definitionDestinationString: C,
        definitionLabelString: E,
        definitionTitleString: _,
        emphasis: l(),
        hardBreakEscape: l(P),
        hardBreakTrailing: l(P),
        htmlFlow: l(B),
        htmlFlowData: D,
        htmlText: l(j),
        htmlTextData: D,
        image: l(G),
        label: K,
        labelText: W,
        lineEnding: L,
        link: l(F),
        listItem: l(),
        listOrdered: l(),
        listUnordered: l(),
        paragraph: l(),
        referenceString: H,
        resourceDestinationString: $,
        resourceTitleString: U,
        resource: X,
        setextHeading: l(M),
        setextHeadingLineSequence: A,
        setextHeadingText: R,
        strong: l(),
        thematicBreak: l()
      }
    };
    sV(t, (e || {}).mdastExtensions || []);
    const n = {};
    return r;
    function r(oe) {
      let ue = {
        type: "root",
        children: []
      };
      const Se = {
        stack: [ue],
        tokenStack: [],
        config: t,
        enter: s,
        exit: u,
        buffer: a,
        resume: d,
        data: n
      }, _e = [];
      let Ae = -1;
      for (; ++Ae < oe.length; )
        if (oe[Ae][1].type === "listOrdered" || oe[Ae][1].type === "listUnordered")
          if (oe[Ae][0] === "enter")
            _e.push(Ae);
          else {
            const Ue = _e.pop();
            Ae = o(oe, Ue, Ae);
          }
      for (Ae = -1; ++Ae < oe.length; ) {
        const Ue = t[oe[Ae][0]];
        aV.call(Ue, oe[Ae][1].type) && Ue[oe[Ae][1].type].call(Object.assign({
          sliceSerialize: oe[Ae][2].sliceSerialize
        }, Se), oe[Ae][1]);
      }
      if (Se.tokenStack.length > 0) {
        const Ue = Se.tokenStack[Se.tokenStack.length - 1];
        (Ue[1] || Nj).call(Se, void 0, Ue[0]);
      }
      for (ue.position = {
        start: Ms(oe.length > 0 ? oe[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }),
        end: Ms(oe.length > 0 ? oe[oe.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        })
      }, Ae = -1; ++Ae < t.transforms.length; )
        ue = t.transforms[Ae](ue) || ue;
      return ue;
    }
    function o(oe, ue, Se) {
      let _e = ue - 1, Ae = -1, Ue = !1, Ft, ut, sn, Ie;
      for (; ++_e <= Se; ) {
        const tt = oe[_e];
        switch (tt[1].type) {
          case "listUnordered":
          case "listOrdered":
          case "blockQuote": {
            tt[0] === "enter" ? Ae++ : Ae--, Ie = void 0;
            break;
          }
          case "lineEndingBlank": {
            tt[0] === "enter" && (Ft && !Ie && !Ae && !sn && (sn = _e), Ie = void 0);
            break;
          }
          case "linePrefix":
          case "listItemValue":
          case "listItemMarker":
          case "listItemPrefix":
          case "listItemPrefixWhitespace":
            break;
          default:
            Ie = void 0;
        }
        if (!Ae && tt[0] === "enter" && tt[1].type === "listItemPrefix" || Ae === -1 && tt[0] === "exit" && (tt[1].type === "listUnordered" || tt[1].type === "listOrdered")) {
          if (Ft) {
            let Ct = _e;
            for (ut = void 0; Ct--; ) {
              const Sn = oe[Ct];
              if (Sn[1].type === "lineEnding" || Sn[1].type === "lineEndingBlank") {
                if (Sn[0] === "exit") continue;
                ut && (oe[ut][1].type = "lineEndingBlank", Ue = !0), Sn[1].type = "lineEnding", ut = Ct;
              } else if (!(Sn[1].type === "linePrefix" || Sn[1].type === "blockQuotePrefix" || Sn[1].type === "blockQuotePrefixWhitespace" || Sn[1].type === "blockQuoteMarker" || Sn[1].type === "listItemIndent")) break;
            }
            sn && (!ut || sn < ut) && (Ft._spread = !0), Ft.end = Object.assign({}, ut ? oe[ut][1].start : tt[1].end), oe.splice(ut || _e, 0, ["exit", Ft, tt[2]]), _e++, Se++;
          }
          if (tt[1].type === "listItemPrefix") {
            const Ct = {
              type: "listItem",
              _spread: !1,
              start: Object.assign({}, tt[1].start),
              // @ts-expect-error: well add `end` in a second.
              end: void 0
            };
            Ft = Ct, oe.splice(_e, 0, ["enter", Ct, tt[2]]), _e++, Se++, sn = void 0, Ie = !0;
          }
        }
      }
      return oe[ue][1]._spread = Ue, Se;
    }
    function i(oe, ue) {
      return Se;
      function Se(_e) {
        s.call(this, oe(_e), _e), ue && ue.call(this, _e);
      }
    }
    function a() {
      this.stack.push({
        type: "fragment",
        children: []
      });
    }
    function s(oe, ue, Se) {
      this.stack[this.stack.length - 1].children.push(oe), this.stack.push(oe), this.tokenStack.push([ue, Se || void 0]), oe.position = {
        start: Ms(ue.start),
        // @ts-expect-error: `end` will be patched later.
        end: void 0
      };
    }
    function l(oe) {
      return ue;
      function ue(Se) {
        oe && oe.call(this, Se), u.call(this, Se);
      }
    }
    function u(oe, ue) {
      const Se = this.stack.pop(), _e = this.tokenStack.pop();
      if (_e)
        _e[0].type !== oe.type && (ue ? ue.call(this, oe, _e[0]) : (_e[1] || Nj).call(this, oe, _e[0]));
      else throw new Error("Cannot close `" + oe.type + "` (" + Mp({
        start: oe.start,
        end: oe.end
      }) + "): its not open");
      Se.position.end = Ms(oe.end);
    }
    function d() {
      return uR(this.stack.pop());
    }
    function p() {
      this.data.expectingFirstListItemValue = !0;
    }
    function h(oe) {
      if (this.data.expectingFirstListItemValue) {
        const ue = this.stack[this.stack.length - 2];
        ue.start = Number.parseInt(this.sliceSerialize(oe), 10), this.data.expectingFirstListItemValue = void 0;
      }
    }
    function g() {
      const oe = this.resume(), ue = this.stack[this.stack.length - 1];
      ue.lang = oe;
    }
    function y() {
      const oe = this.resume(), ue = this.stack[this.stack.length - 1];
      ue.meta = oe;
    }
    function b() {
      this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
    }
    function v() {
      const oe = this.resume(), ue = this.stack[this.stack.length - 1];
      ue.value = oe.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
    }
    function x() {
      const oe = this.resume(), ue = this.stack[this.stack.length - 1];
      ue.value = oe.replace(/(\r?\n|\r)$/g, "");
    }
    function E(oe) {
      const ue = this.resume(), Se = this.stack[this.stack.length - 1];
      Se.label = ue, Se.identifier = Wo(this.sliceSerialize(oe)).toLowerCase();
    }
    function _() {
      const oe = this.resume(), ue = this.stack[this.stack.length - 1];
      ue.title = oe;
    }
    function C() {
      const oe = this.resume(), ue = this.stack[this.stack.length - 1];
      ue.url = oe;
    }
    function k(oe) {
      const ue = this.stack[this.stack.length - 1];
      if (!ue.depth) {
        const Se = this.sliceSerialize(oe).length;
        ue.depth = Se;
      }
    }
    function R() {
      this.data.setextHeadingSlurpLineEnding = !0;
    }
    function A(oe) {
      const ue = this.stack[this.stack.length - 1];
      ue.depth = this.sliceSerialize(oe).codePointAt(0) === 61 ? 1 : 2;
    }
    function M() {
      this.data.setextHeadingSlurpLineEnding = void 0;
    }
    function I(oe) {
      const Se = this.stack[this.stack.length - 1].children;
      let _e = Se[Se.length - 1];
      (!_e || _e.type !== "text") && (_e = wt(), _e.position = {
        start: Ms(oe.start),
        // @ts-expect-error: well add `end` later.
        end: void 0
      }, Se.push(_e)), this.stack.push(_e);
    }
    function D(oe) {
      const ue = this.stack.pop();
      ue.value += this.sliceSerialize(oe), ue.position.end = Ms(oe.end);
    }
    function L(oe) {
      const ue = this.stack[this.stack.length - 1];
      if (this.data.atHardBreak) {
        const Se = ue.children[ue.children.length - 1];
        Se.position.end = Ms(oe.end), this.data.atHardBreak = void 0;
        return;
      }
      !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(ue.type) && (I.call(this, oe), D.call(this, oe));
    }
    function P() {
      this.data.atHardBreak = !0;
    }
    function B() {
      const oe = this.resume(), ue = this.stack[this.stack.length - 1];
      ue.value = oe;
    }
    function j() {
      const oe = this.resume(), ue = this.stack[this.stack.length - 1];
      ue.value = oe;
    }
    function V() {
      const oe = this.resume(), ue = this.stack[this.stack.length - 1];
      ue.value = oe;
    }
    function F() {
      const oe = this.stack[this.stack.length - 1];
      if (this.data.inReference) {
        const ue = this.data.referenceType || "shortcut";
        oe.type += "Reference", oe.referenceType = ue, delete oe.url, delete oe.title;
      } else
        delete oe.identifier, delete oe.label;
      this.data.referenceType = void 0;
    }
    function G() {
      const oe = this.stack[this.stack.length - 1];
      if (this.data.inReference) {
        const ue = this.data.referenceType || "shortcut";
        oe.type += "Reference", oe.referenceType = ue, delete oe.url, delete oe.title;
      } else
        delete oe.identifier, delete oe.label;
      this.data.referenceType = void 0;
    }
    function W(oe) {
      const ue = this.sliceSerialize(oe), Se = this.stack[this.stack.length - 2];
      Se.label = h_e(ue), Se.identifier = Wo(ue).toLowerCase();
    }
    function K() {
      const oe = this.stack[this.stack.length - 1], ue = this.resume(), Se = this.stack[this.stack.length - 1];
      if (this.data.inReference = !0, Se.type === "link") {
        const _e = oe.children;
        Se.children = _e;
      } else
        Se.alt = ue;
    }
    function $() {
      const oe = this.resume(), ue = this.stack[this.stack.length - 1];
      ue.url = oe;
    }
    function U() {
      const oe = this.resume(), ue = this.stack[this.stack.length - 1];
      ue.title = oe;
    }
    function X() {
      this.data.inReference = void 0;
    }
    function z() {
      this.data.referenceType = "collapsed";
    }
    function H(oe) {
      const ue = this.resume(), Se = this.stack[this.stack.length - 1];
      Se.label = ue, Se.identifier = Wo(this.sliceSerialize(oe)).toLowerCase(), this.data.referenceType = "full";
    }
    function Y(oe) {
      this.data.characterReferenceType = oe.type;
    }
    function Q(oe) {
      const ue = this.sliceSerialize(oe), Se = this.data.characterReferenceType;
      let _e;
      Se ? (_e = XU(ue, Se === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : _e = fR(ue);
      const Ae = this.stack[this.stack.length - 1];
      Ae.value += _e;
    }
    function re(oe) {
      const ue = this.stack.pop();
      ue.position.end = Ms(oe.end);
    }
    function te(oe) {
      D.call(this, oe);
      const ue = this.stack[this.stack.length - 1];
      ue.url = this.sliceSerialize(oe);
    }
    function le(oe) {
      D.call(this, oe);
      const ue = this.stack[this.stack.length - 1];
      ue.url = "mailto:" + this.sliceSerialize(oe);
    }
    function fe() {
      return {
        type: "blockquote",
        children: []
      };
    }
    function J() {
      return {
        type: "code",
        lang: null,
        meta: null,
        value: ""
      };
    }
    function ee() {
      return {
        type: "inlineCode",
        value: ""
      };
    }
    function ie() {
      return {
        type: "definition",
        identifier: "",
        label: null,
        title: null,
        url: ""
      };
    }
    function ae() {
      return {
        type: "emphasis",
        children: []
      };
    }
    function ge() {
      return {
        type: "heading",
        // @ts-expect-error `depth` will be set later.
        depth: 0,
        children: []
      };
    }
    function Ce() {
      return {
        type: "break"
      };
    }
    function Ne() {
      return {
        type: "html",
        value: ""
      };
    }
    function Le() {
      return {
        type: "image",
        title: null,
        url: "",
        alt: null
      };
    }
    function Ve() {
      return {
        type: "link",
        title: null,
        url: "",
        children: []
      };
    }
    function Ke(oe) {
      return {
        type: "list",
        ordered: oe.type === "listOrdered",
        start: null,
        spread: oe._spread,
        children: []
      };
    }
    function ze(oe) {
      return {
        type: "listItem",
        spread: oe._spread,
        checked: null,
        children: []
      };
    }
    function Me() {
      return {
        type: "paragraph",
        children: []
      };
    }
    function ct() {
      return {
        type: "strong",
        children: []
      };
    }
    function wt() {
      return {
        type: "text",
        value: ""
      };
    }
    function Re() {
      return {
        type: "thematicBreak"
      };
    }
  }
  function Ms(e) {
    return {
      line: e.line,
      column: e.column,
      offset: e.offset
    };
  }
  function sV(e, t) {
    let n = -1;
    for (; ++n < t.length; ) {
      const r = t[n];
      Array.isArray(r) ? sV(e, r) : v_e(e, r);
    }
  }
  function v_e(e, t) {
    let n;
    for (n in t)
      if (aV.call(t, n))
        switch (n) {
          case "canContainEols": {
            const r = t[n];
            r && e[n].push(...r);
            break;
          }
          case "transforms": {
            const r = t[n];
            r && e[n].push(...r);
            break;
          }
          case "enter":
          case "exit": {
            const r = t[n];
            r && Object.assign(e[n], r);
            break;
          }
        }
  }
  function Nj(e, t) {
    throw e ? new Error("Cannot close `" + e.type + "` (" + Mp({
      start: e.start,
      end: e.end
    }) + "): a different token (`" + t.type + "`, " + Mp({
      start: t.start,
      end: t.end
    }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + Mp({
      start: t.start,
      end: t.end
    }) + ") is still open");
  }
  function b_e(e) {
    const t = this;
    t.parser = n;
    function n(r) {
      return g_e(r, {
        ...t.data("settings"),
        ...e,
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: t.data("micromarkExtensions") || [],
        mdastExtensions: t.data("fromMarkdownExtensions") || []
      });
    }
  }
  function x_e(e, t) {
    const n = {
      type: "element",
      tagName: "blockquote",
      properties: {},
      children: e.wrap(e.all(t), !0)
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  function w_e(e, t) {
    const n = { type: "element", tagName: "br", properties: {}, children: [] };
    return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
  }
  function S_e(e, t) {
    const n = t.value ? t.value + `
` : "", r = {};
    t.lang && (r.className = ["language-" + t.lang]);
    let o = {
      type: "element",
      tagName: "code",
      properties: r,
      children: [{ type: "text", value: n }]
    };
    return t.meta && (o.data = { meta: t.meta }), e.patch(t, o), o = e.applyData(t, o), o = { type: "element", tagName: "pre", properties: {}, children: [o] }, e.patch(t, o), o;
  }
  function __e(e, t) {
    const n = {
      type: "element",
      tagName: "del",
      properties: {},
      children: e.all(t)
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  function E_e(e, t) {
    const n = {
      type: "element",
      tagName: "em",
      properties: {},
      children: e.all(t)
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  function C_e(e, t) {
    const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), o = $f(r.toLowerCase()), i = e.footnoteOrder.indexOf(r);
    let a, s = e.footnoteCounts.get(r);
    s === void 0 ? (s = 0, e.footnoteOrder.push(r), a = e.footnoteOrder.length) : a = i + 1, s += 1, e.footnoteCounts.set(r, s);
    const l = {
      type: "element",
      tagName: "a",
      properties: {
        href: "#" + n + "fn-" + o,
        id: n + "fnref-" + o + (s > 1 ? "-" + s : ""),
        dataFootnoteRef: !0,
        ariaDescribedBy: ["footnote-label"]
      },
      children: [{ type: "text", value: String(a) }]
    };
    e.patch(t, l);
    const u = {
      type: "element",
      tagName: "sup",
      properties: {},
      children: [l]
    };
    return e.patch(t, u), e.applyData(t, u);
  }
  function k_e(e, t) {
    const n = {
      type: "element",
      tagName: "h" + t.depth,
      properties: {},
      children: e.all(t)
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  function T_e(e, t) {
    if (e.options.allowDangerousHtml) {
      const n = { type: "raw", value: t.value };
      return e.patch(t, n), e.applyData(t, n);
    }
  }
  function lV(e, t) {
    const n = t.referenceType;
    let r = "]";
    if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
      return [{ type: "text", value: "![" + t.alt + r }];
    const o = e.all(t), i = o[0];
    i && i.type === "text" ? i.value = "[" + i.value : o.unshift({ type: "text", value: "[" });
    const a = o[o.length - 1];
    return a && a.type === "text" ? a.value += r : o.push({ type: "text", value: r }), o;
  }
  function R_e(e, t) {
    const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
    if (!r)
      return lV(e, t);
    const o = { src: $f(r.url || ""), alt: t.alt };
    r.title !== null && r.title !== void 0 && (o.title = r.title);
    const i = { type: "element", tagName: "img", properties: o, children: [] };
    return e.patch(t, i), e.applyData(t, i);
  }
  function O_e(e, t) {
    const n = { src: $f(t.url) };
    t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
    const r = { type: "element", tagName: "img", properties: n, children: [] };
    return e.patch(t, r), e.applyData(t, r);
  }
  function A_e(e, t) {
    const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
    e.patch(t, n);
    const r = {
      type: "element",
      tagName: "code",
      properties: {},
      children: [n]
    };
    return e.patch(t, r), e.applyData(t, r);
  }
  function N_e(e, t) {
    const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
    if (!r)
      return lV(e, t);
    const o = { href: $f(r.url || "") };
    r.title !== null && r.title !== void 0 && (o.title = r.title);
    const i = {
      type: "element",
      tagName: "a",
      properties: o,
      children: e.all(t)
    };
    return e.patch(t, i), e.applyData(t, i);
  }
  function M_e(e, t) {
    const n = { href: $f(t.url) };
    t.title !== null && t.title !== void 0 && (n.title = t.title);
    const r = {
      type: "element",
      tagName: "a",
      properties: n,
      children: e.all(t)
    };
    return e.patch(t, r), e.applyData(t, r);
  }
  function P_e(e, t, n) {
    const r = e.all(t), o = n ? $_e(n) : cV(t), i = {}, a = [];
    if (typeof t.checked == "boolean") {
      const d = r[0];
      let p;
      d && d.type === "element" && d.tagName === "p" ? p = d : (p = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(p)), p.children.length > 0 && p.children.unshift({ type: "text", value: " " }), p.children.unshift({
        type: "element",
        tagName: "input",
        properties: { type: "checkbox", checked: t.checked, disabled: !0 },
        children: []
      }), i.className = ["task-list-item"];
    }
    let s = -1;
    for (; ++s < r.length; ) {
      const d = r[s];
      (o || s !== 0 || d.type !== "element" || d.tagName !== "p") && a.push({ type: "text", value: `
` }), d.type === "element" && d.tagName === "p" && !o ? a.push(...d.children) : a.push(d);
    }
    const l = r[r.length - 1];
    l && (o || l.type !== "element" || l.tagName !== "p") && a.push({ type: "text", value: `
` });
    const u = { type: "element", tagName: "li", properties: i, children: a };
    return e.patch(t, u), e.applyData(t, u);
  }
  function $_e(e) {
    let t = !1;
    if (e.type === "list") {
      t = e.spread || !1;
      const n = e.children;
      let r = -1;
      for (; !t && ++r < n.length; )
        t = cV(n[r]);
    }
    return t;
  }
  function cV(e) {
    const t = e.spread;
    return t ?? e.children.length > 1;
  }
  function I_e(e, t) {
    const n = {}, r = e.all(t);
    let o = -1;
    for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++o < r.length; ) {
      const a = r[o];
      if (a.type === "element" && a.tagName === "li" && a.properties && Array.isArray(a.properties.className) && a.properties.className.includes("task-list-item")) {
        n.className = ["contains-task-list"];
        break;
      }
    }
    const i = {
      type: "element",
      tagName: t.ordered ? "ol" : "ul",
      properties: n,
      children: e.wrap(r, !0)
    };
    return e.patch(t, i), e.applyData(t, i);
  }
  function j_e(e, t) {
    const n = {
      type: "element",
      tagName: "p",
      properties: {},
      children: e.all(t)
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  function D_e(e, t) {
    const n = { type: "root", children: e.wrap(e.all(t)) };
    return e.patch(t, n), e.applyData(t, n);
  }
  function F_e(e, t) {
    const n = {
      type: "element",
      tagName: "strong",
      properties: {},
      children: e.all(t)
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  function L_e(e, t) {
    const n = e.all(t), r = n.shift(), o = [];
    if (r) {
      const a = {
        type: "element",
        tagName: "thead",
        properties: {},
        children: e.wrap([r], !0)
      };
      e.patch(t.children[0], a), o.push(a);
    }
    if (n.length > 0) {
      const a = {
        type: "element",
        tagName: "tbody",
        properties: {},
        children: e.wrap(n, !0)
      }, s = aR(t.children[1]), l = UU(t.children[t.children.length - 1]);
      s && l && (a.position = { start: s, end: l }), o.push(a);
    }
    const i = {
      type: "element",
      tagName: "table",
      properties: {},
      children: e.wrap(o, !0)
    };
    return e.patch(t, i), e.applyData(t, i);
  }
  function z_e(e, t, n) {
    const r = n ? n.children : void 0, i = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", a = n && n.type === "table" ? n.align : void 0, s = a ? a.length : t.children.length;
    let l = -1;
    const u = [];
    for (; ++l < s; ) {
      const p = t.children[l], h = {}, g = a ? a[l] : void 0;
      g && (h.align = g);
      let y = { type: "element", tagName: i, properties: h, children: [] };
      p && (y.children = e.all(p), e.patch(p, y), y = e.applyData(p, y)), u.push(y);
    }
    const d = {
      type: "element",
      tagName: "tr",
      properties: {},
      children: e.wrap(u, !0)
    };
    return e.patch(t, d), e.applyData(t, d);
  }
  function B_e(e, t) {
    const n = {
      type: "element",
      tagName: "td",
      // Assume body cell.
      properties: {},
      children: e.all(t)
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  const Mj = 9, Pj = 32;
  function U_e(e) {
    const t = String(e), n = /\r?\n|\r/g;
    let r = n.exec(t), o = 0;
    const i = [];
    for (; r; )
      i.push(
        $j(t.slice(o, r.index), o > 0, !0),
        r[0]
      ), o = r.index + r[0].length, r = n.exec(t);
    return i.push($j(t.slice(o), o > 0, !1)), i.join("");
  }
  function $j(e, t, n) {
    let r = 0, o = e.length;
    if (t) {
      let i = e.codePointAt(r);
      for (; i === Mj || i === Pj; )
        r++, i = e.codePointAt(r);
    }
    if (n) {
      let i = e.codePointAt(o - 1);
      for (; i === Mj || i === Pj; )
        o--, i = e.codePointAt(o - 1);
    }
    return o > r ? e.slice(r, o) : "";
  }
  function V_e(e, t) {
    const n = { type: "text", value: U_e(String(t.value)) };
    return e.patch(t, n), e.applyData(t, n);
  }
  function H_e(e, t) {
    const n = {
      type: "element",
      tagName: "hr",
      properties: {},
      children: []
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  const q_e = {
    blockquote: x_e,
    break: w_e,
    code: S_e,
    delete: __e,
    emphasis: E_e,
    footnoteReference: C_e,
    heading: k_e,
    html: T_e,
    imageReference: R_e,
    image: O_e,
    inlineCode: A_e,
    linkReference: N_e,
    link: M_e,
    listItem: P_e,
    list: I_e,
    paragraph: j_e,
    // @ts-expect-error: root is different, but hard to type.
    root: D_e,
    strong: F_e,
    table: L_e,
    tableCell: B_e,
    tableRow: z_e,
    text: V_e,
    thematicBreak: H_e,
    toml: ly,
    yaml: ly,
    definition: ly,
    footnoteDefinition: ly
  };
  function ly() {
  }
  const uV = -1, o1 = 0, $p = 1, k0 = 2, pR = 3, hR = 4, mR = 5, gR = 6, fV = 7, dV = 8, Ij = typeof self == "object" ? self : globalThis, W_e = (e, t) => {
    const n = (o, i) => (e.set(i, o), o), r = (o) => {
      if (e.has(o))
        return e.get(o);
      const [i, a] = t[o];
      switch (i) {
        case o1:
        case uV:
          return n(a, o);
        case $p: {
          const s = n([], o);
          for (const l of a)
            s.push(r(l));
          return s;
        }
        case k0: {
          const s = n({}, o);
          for (const [l, u] of a)
            s[r(l)] = r(u);
          return s;
        }
        case pR:
          return n(new Date(a), o);
        case hR: {
          const { source: s, flags: l } = a;
          return n(new RegExp(s, l), o);
        }
        case mR: {
          const s = n(/* @__PURE__ */ new Map(), o);
          for (const [l, u] of a)
            s.set(r(l), r(u));
          return s;
        }
        case gR: {
          const s = n(/* @__PURE__ */ new Set(), o);
          for (const l of a)
            s.add(r(l));
          return s;
        }
        case fV: {
          const { name: s, message: l } = a;
          return n(new Ij[s](l), o);
        }
        case dV:
          return n(BigInt(a), o);
        case "BigInt":
          return n(Object(BigInt(a)), o);
        case "ArrayBuffer":
          return n(new Uint8Array(a).buffer, a);
        case "DataView": {
          const { buffer: s } = new Uint8Array(a);
          return n(new DataView(s), a);
        }
      }
      return n(new Ij[i](a), o);
    };
    return r;
  }, jj = (e) => W_e(/* @__PURE__ */ new Map(), e)(0), Cu = "", { toString: G_e } = {}, { keys: K_e } = Object, Qd = (e) => {
    const t = typeof e;
    if (t !== "object" || !e)
      return [o1, t];
    const n = G_e.call(e).slice(8, -1);
    switch (n) {
      case "Array":
        return [$p, Cu];
      case "Object":
        return [k0, Cu];
      case "Date":
        return [pR, Cu];
      case "RegExp":
        return [hR, Cu];
      case "Map":
        return [mR, Cu];
      case "Set":
        return [gR, Cu];
      case "DataView":
        return [$p, n];
    }
    return n.includes("Array") ? [$p, n] : n.includes("Error") ? [fV, n] : [k0, n];
  }, cy = ([e, t]) => e === o1 && (t === "function" || t === "symbol"), Y_e = (e, t, n, r) => {
    const o = (a, s) => {
      const l = r.push(a) - 1;
      return n.set(s, l), l;
    }, i = (a) => {
      if (n.has(a))
        return n.get(a);
      let [s, l] = Qd(a);
      switch (s) {
        case o1: {
          let d = a;
          switch (l) {
            case "bigint":
              s = dV, d = a.toString();
              break;
            case "function":
            case "symbol":
              if (e)
                throw new TypeError("unable to serialize " + l);
              d = null;
              break;
            case "undefined":
              return o([uV], a);
          }
          return o([s, d], a);
        }
        case $p: {
          if (l) {
            let h = a;
            return l === "DataView" ? h = new Uint8Array(a.buffer) : l === "ArrayBuffer" && (h = new Uint8Array(a)), o([l, [...h]], a);
          }
          const d = [], p = o([s, d], a);
          for (const h of a)
            d.push(i(h));
          return p;
        }
        case k0: {
          if (l)
            switch (l) {
              case "BigInt":
                return o([l, a.toString()], a);
              case "Boolean":
              case "Number":
              case "String":
                return o([l, a.valueOf()], a);
            }
          if (t && "toJSON" in a)
            return i(a.toJSON());
          const d = [], p = o([s, d], a);
          for (const h of K_e(a))
            (e || !cy(Qd(a[h]))) && d.push([i(h), i(a[h])]);
          return p;
        }
        case pR:
          return o([s, a.toISOString()], a);
        case hR: {
          const { source: d, flags: p } = a;
          return o([s, { source: d, flags: p }], a);
        }
        case mR: {
          const d = [], p = o([s, d], a);
          for (const [h, g] of a)
            (e || !(cy(Qd(h)) || cy(Qd(g)))) && d.push([i(h), i(g)]);
          return p;
        }
        case gR: {
          const d = [], p = o([s, d], a);
          for (const h of a)
            (e || !cy(Qd(h))) && d.push(i(h));
          return p;
        }
      }
      const { message: u } = a;
      return o([s, { name: l, message: u }], a);
    };
    return i;
  }, Dj = (e, { json: t, lossy: n } = {}) => {
    const r = [];
    return Y_e(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
  }, T0 = typeof structuredClone == "function" ? (
    /* c8 ignore start */
    (e, t) => t && ("json" in t || "lossy" in t) ? jj(Dj(e, t)) : structuredClone(e)
  ) : (e, t) => jj(Dj(e, t));
  function X_e(e, t) {
    const n = [{ type: "text", value: "" }];
    return t > 1 && n.push({
      type: "element",
      tagName: "sup",
      properties: {},
      children: [{ type: "text", value: String(t) }]
    }), n;
  }
  function Z_e(e, t) {
    return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
  }
  function Q_e(e) {
    const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || X_e, r = e.options.footnoteBackLabel || Z_e, o = e.options.footnoteLabel || "Footnotes", i = e.options.footnoteLabelTagName || "h2", a = e.options.footnoteLabelProperties || {
      className: ["sr-only"]
    }, s = [];
    let l = -1;
    for (; ++l < e.footnoteOrder.length; ) {
      const u = e.footnoteById.get(
        e.footnoteOrder[l]
      );
      if (!u)
        continue;
      const d = e.all(u), p = String(u.identifier).toUpperCase(), h = $f(p.toLowerCase());
      let g = 0;
      const y = [], b = e.footnoteCounts.get(p);
      for (; b !== void 0 && ++g <= b; ) {
        y.length > 0 && y.push({ type: "text", value: " " });
        let E = typeof n == "string" ? n : n(l, g);
        typeof E == "string" && (E = { type: "text", value: E }), y.push({
          type: "element",
          tagName: "a",
          properties: {
            href: "#" + t + "fnref-" + h + (g > 1 ? "-" + g : ""),
            dataFootnoteBackref: "",
            ariaLabel: typeof r == "string" ? r : r(l, g),
            className: ["data-footnote-backref"]
          },
          children: Array.isArray(E) ? E : [E]
        });
      }
      const v = d[d.length - 1];
      if (v && v.type === "element" && v.tagName === "p") {
        const E = v.children[v.children.length - 1];
        E && E.type === "text" ? E.value += " " : v.children.push({ type: "text", value: " " }), v.children.push(...y);
      } else
        d.push(...y);
      const x = {
        type: "element",
        tagName: "li",
        properties: { id: t + "fn-" + h },
        children: e.wrap(d, !0)
      };
      e.patch(u, x), s.push(x);
    }
    if (s.length !== 0)
      return {
        type: "element",
        tagName: "section",
        properties: { dataFootnotes: !0, className: ["footnotes"] },
        children: [
          {
            type: "element",
            tagName: i,
            properties: {
              ...T0(a),
              id: "footnote-label"
            },
            children: [{ type: "text", value: o }]
          },
          { type: "text", value: `
` },
          {
            type: "element",
            tagName: "ol",
            properties: {},
            children: e.wrap(s, !0)
          },
          { type: "text", value: `
` }
        ]
      };
  }
  const i1 = (
    // Note: overloads in JSDoc cant yet use different `@template`s.
    /**
     * @type {(
     *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
     *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
     *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
     *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
     *   ((test?: Test) => Check)
     * )}
     */
    /**
     * @param {Test} [test]
     * @returns {Check}
     */
    function(e) {
      if (e == null)
        return nEe;
      if (typeof e == "function")
        return a1(e);
      if (typeof e == "object")
        return Array.isArray(e) ? J_e(e) : eEe(e);
      if (typeof e == "string")
        return tEe(e);
      throw new Error("Expected function, string, or object as test");
    }
  );
  function J_e(e) {
    const t = [];
    let n = -1;
    for (; ++n < e.length; )
      t[n] = i1(e[n]);
    return a1(r);
    function r(...o) {
      let i = -1;
      for (; ++i < t.length; )
        if (t[i].apply(this, o)) return !0;
      return !1;
    }
  }
  function eEe(e) {
    const t = (
      /** @type {Record<string, unknown>} */
      e
    );
    return a1(n);
    function n(r) {
      const o = (
        /** @type {Record<string, unknown>} */
        /** @type {unknown} */
        r
      );
      let i;
      for (i in e)
        if (o[i] !== t[i]) return !1;
      return !0;
    }
  }
  function tEe(e) {
    return a1(t);
    function t(n) {
      return n && n.type === e;
    }
  }
  function a1(e) {
    return t;
    function t(n, r, o) {
      return !!(rEe(n) && e.call(
        this,
        n,
        typeof r == "number" ? r : void 0,
        o || void 0
      ));
    }
  }
  function nEe() {
    return !0;
  }
  function rEe(e) {
    return e !== null && typeof e == "object" && "type" in e;
  }
  const pV = [], oEe = !0, _C = !1, iEe = "skip";
  function hV(e, t, n, r) {
    let o;
    typeof t == "function" && typeof n != "function" ? (r = n, n = t) : o = t;
    const i = i1(o), a = r ? -1 : 1;
    s(e, void 0, [])();
    function s(l, u, d) {
      const p = (
        /** @type {Record<string, unknown>} */
        l && typeof l == "object" ? l : {}
      );
      if (typeof p.type == "string") {
        const g = (
          // `hast`
          typeof p.tagName == "string" ? p.tagName : (
            // `xast`
            typeof p.name == "string" ? p.name : void 0
          )
        );
        Object.defineProperty(h, "name", {
          value: "node (" + (l.type + (g ? "<" + g + ">" : "")) + ")"
        });
      }
      return h;
      function h() {
        let g = pV, y, b, v;
        if ((!t || i(l, u, d[d.length - 1] || void 0)) && (g = aEe(n(l, d)), g[0] === _C))
          return g;
        if ("children" in l && l.children) {
          const x = (
            /** @type {UnistParent} */
            l
          );
          if (x.children && g[0] !== iEe)
            for (b = (r ? x.children.length : -1) + a, v = d.concat(x); b > -1 && b < x.children.length; ) {
              const E = x.children[b];
              if (y = s(E, b, v)(), y[0] === _C)
                return y;
              b = typeof y[1] == "number" ? y[1] : b + a;
            }
        }
        return g;
      }
    }
  }
  function aEe(e) {
    return Array.isArray(e) ? e : typeof e == "number" ? [oEe, e] : e == null ? pV : [e];
  }
  function yR(e, t, n, r) {
    let o, i, a;
    typeof t == "function" && typeof n != "function" ? (i = void 0, a = t, o = n) : (i = t, a = n, o = r), hV(e, i, s, o);
    function s(l, u) {
      const d = u[u.length - 1], p = d ? d.children.indexOf(l) : void 0;
      return a(l, p, d);
    }
  }
  const EC = {}.hasOwnProperty, sEe = {};
  function lEe(e, t) {
    const n = t || sEe, r = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), a = { ...q_e, ...n.handlers }, s = {
      all: u,
      applyData: uEe,
      definitionById: r,
      footnoteById: o,
      footnoteCounts: i,
      footnoteOrder: [],
      handlers: a,
      one: l,
      options: n,
      patch: cEe,
      wrap: dEe
    };
    return yR(e, function(d) {
      if (d.type === "definition" || d.type === "footnoteDefinition") {
        const p = d.type === "definition" ? r : o, h = String(d.identifier).toUpperCase();
        p.has(h) || p.set(h, d);
      }
    }), s;
    function l(d, p) {
      const h = d.type, g = s.handlers[h];
      if (EC.call(s.handlers, h) && g)
        return g(s, d, p);
      if (s.options.passThrough && s.options.passThrough.includes(h)) {
        if ("children" in d) {
          const { children: b, ...v } = d, x = T0(v);
          return x.children = s.all(d), x;
        }
        return T0(d);
      }
      return (s.options.unknownHandler || fEe)(s, d, p);
    }
    function u(d) {
      const p = [];
      if ("children" in d) {
        const h = d.children;
        let g = -1;
        for (; ++g < h.length; ) {
          const y = s.one(h[g], d);
          if (y) {
            if (g && h[g - 1].type === "break" && (!Array.isArray(y) && y.type === "text" && (y.value = Fj(y.value)), !Array.isArray(y) && y.type === "element")) {
              const b = y.children[0];
              b && b.type === "text" && (b.value = Fj(b.value));
            }
            Array.isArray(y) ? p.push(...y) : p.push(y);
          }
        }
      }
      return p;
    }
  }
  function cEe(e, t) {
    e.position && (t.position = Zxe(e));
  }
  function uEe(e, t) {
    let n = t;
    if (e && e.data) {
      const r = e.data.hName, o = e.data.hChildren, i = e.data.hProperties;
      if (typeof r == "string")
        if (n.type === "element")
          n.tagName = r;
        else {
          const a = "children" in n ? n.children : [n];
          n = { type: "element", tagName: r, properties: {}, children: a };
        }
      n.type === "element" && i && Object.assign(n.properties, T0(i)), "children" in n && n.children && o !== null && o !== void 0 && (n.children = o);
    }
    return n;
  }
  function fEe(e, t) {
    const n = t.data || {}, r = "value" in t && !(EC.call(n, "hProperties") || EC.call(n, "hChildren")) ? { type: "text", value: t.value } : {
      type: "element",
      tagName: "div",
      properties: {},
      children: e.all(t)
    };
    return e.patch(t, r), e.applyData(t, r);
  }
  function dEe(e, t) {
    const n = [];
    let r = -1;
    for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
      r && n.push({ type: "text", value: `
` }), n.push(e[r]);
    return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
  }
  function Fj(e) {
    let t = 0, n = e.charCodeAt(t);
    for (; n === 9 || n === 32; )
      t++, n = e.charCodeAt(t);
    return e.slice(t);
  }
  function Lj(e, t) {
    const n = lEe(e, t), r = n.one(e, void 0), o = Q_e(n), i = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
    return o && i.children.push({ type: "text", value: `
` }, o), i;
  }
  function pEe(e, t) {
    return e && "run" in e ? async function(n, r) {
      const o = (
        /** @type {HastRoot} */
        Lj(n, { file: r, ...t })
      );
      await e.run(o, r);
    } : function(n, r) {
      return (
        /** @type {HastRoot} */
        Lj(n, { file: r, ...e || t })
      );
    };
  }
  function zj(e) {
    if (e)
      throw e;
  }
  var n_, Bj;
  function hEe() {
    if (Bj) return n_;
    Bj = 1;
    var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString, n = Object.defineProperty, r = Object.getOwnPropertyDescriptor, o = function(u) {
      return typeof Array.isArray == "function" ? Array.isArray(u) : t.call(u) === "[object Array]";
    }, i = function(u) {
      if (!u || t.call(u) !== "[object Object]")
        return !1;
      var d = e.call(u, "constructor"), p = u.constructor && u.constructor.prototype && e.call(u.constructor.prototype, "isPrototypeOf");
      if (u.constructor && !d && !p)
        return !1;
      var h;
      for (h in u)
        ;
      return typeof h > "u" || e.call(u, h);
    }, a = function(u, d) {
      n && d.name === "__proto__" ? n(u, d.name, {
        enumerable: !0,
        configurable: !0,
        value: d.newValue,
        writable: !0
      }) : u[d.name] = d.newValue;
    }, s = function(u, d) {
      if (d === "__proto__")
        if (e.call(u, d)) {
          if (r)
            return r(u, d).value;
        } else return;
      return u[d];
    };
    return n_ = function l() {
      var u, d, p, h, g, y, b = arguments[0], v = 1, x = arguments.length, E = !1;
      for (typeof b == "boolean" && (E = b, b = arguments[1] || {}, v = 2), (b == null || typeof b != "object" && typeof b != "function") && (b = {}); v < x; ++v)
        if (u = arguments[v], u != null)
          for (d in u)
            p = s(b, d), h = s(u, d), b !== h && (E && h && (i(h) || (g = o(h))) ? (g ? (g = !1, y = p && o(p) ? p : []) : y = p && i(p) ? p : {}, a(b, { name: d, newValue: l(E, y, h) })) : typeof h < "u" && a(b, { name: d, newValue: h }));
      return b;
    }, n_;
  }
  var mEe = hEe();
  const r_ = /* @__PURE__ */ Jo(mEe);
  function CC(e) {
    if (typeof e != "object" || e === null)
      return !1;
    const t = Object.getPrototypeOf(e);
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
  }
  function gEe() {
    const e = [], t = { run: n, use: r };
    return t;
    function n(...o) {
      let i = -1;
      const a = o.pop();
      if (typeof a != "function")
        throw new TypeError("Expected function as last argument, not " + a);
      s(null, ...o);
      function s(l, ...u) {
        const d = e[++i];
        let p = -1;
        if (l) {
          a(l);
          return;
        }
        for (; ++p < o.length; )
          (u[p] === null || u[p] === void 0) && (u[p] = o[p]);
        o = u, d ? yEe(d, s)(...u) : a(null, ...u);
      }
    }
    function r(o) {
      if (typeof o != "function")
        throw new TypeError(
          "Expected `middelware` to be a function, not " + o
        );
      return e.push(o), t;
    }
  }
  function yEe(e, t) {
    let n;
    return r;
    function r(...a) {
      const s = e.length > a.length;
      let l;
      s && a.push(o);
      try {
        l = e.apply(this, a);
      } catch (u) {
        const d = (
          /** @type {Error} */
          u
        );
        if (s && n)
          throw d;
        return o(d);
      }
      s || (l && l.then && typeof l.then == "function" ? l.then(i, o) : l instanceof Error ? o(l) : i(l));
    }
    function o(a, ...s) {
      n || (n = !0, t(a, ...s));
    }
    function i(a) {
      o(null, a);
    }
  }
  const vi = { basename: vEe, dirname: bEe, extname: xEe, join: wEe, sep: "/" };
  function vEe(e, t) {
    if (t !== void 0 && typeof t != "string")
      throw new TypeError('"ext" argument must be a string');
    am(e);
    let n = 0, r = -1, o = e.length, i;
    if (t === void 0 || t.length === 0 || t.length > e.length) {
      for (; o--; )
        if (e.codePointAt(o) === 47) {
          if (i) {
            n = o + 1;
            break;
          }
        } else r < 0 && (i = !0, r = o + 1);
      return r < 0 ? "" : e.slice(n, r);
    }
    if (t === e)
      return "";
    let a = -1, s = t.length - 1;
    for (; o--; )
      if (e.codePointAt(o) === 47) {
        if (i) {
          n = o + 1;
          break;
        }
      } else
        a < 0 && (i = !0, a = o + 1), s > -1 && (e.codePointAt(o) === t.codePointAt(s--) ? s < 0 && (r = o) : (s = -1, r = a));
    return n === r ? r = a : r < 0 && (r = e.length), e.slice(n, r);
  }
  function bEe(e) {
    if (am(e), e.length === 0)
      return ".";
    let t = -1, n = e.length, r;
    for (; --n; )
      if (e.codePointAt(n) === 47) {
        if (r) {
          t = n;
          break;
        }
      } else r || (r = !0);
    return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
  }
  function xEe(e) {
    am(e);
    let t = e.length, n = -1, r = 0, o = -1, i = 0, a;
    for (; t--; ) {
      const s = e.codePointAt(t);
      if (s === 47) {
        if (a) {
          r = t + 1;
          break;
        }
        continue;
      }
      n < 0 && (a = !0, n = t + 1), s === 46 ? o < 0 ? o = t : i !== 1 && (i = 1) : o > -1 && (i = -1);
    }
    return o < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
    i === 0 || // The (right-most) trimmed path component is exactly `..`.
    i === 1 && o === n - 1 && o === r + 1 ? "" : e.slice(o, n);
  }
  function wEe(...e) {
    let t = -1, n;
    for (; ++t < e.length; )
      am(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
    return n === void 0 ? "." : SEe(n);
  }
  function SEe(e) {
    am(e);
    const t = e.codePointAt(0) === 47;
    let n = _Ee(e, !t);
    return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
  }
  function _Ee(e, t) {
    let n = "", r = 0, o = -1, i = 0, a = -1, s, l;
    for (; ++a <= e.length; ) {
      if (a < e.length)
        s = e.codePointAt(a);
      else {
        if (s === 47)
          break;
        s = 47;
      }
      if (s === 47) {
        if (!(o === a - 1 || i === 1)) if (o !== a - 1 && i === 2) {
          if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
            if (n.length > 2) {
              if (l = n.lastIndexOf("/"), l !== n.length - 1) {
                l < 0 ? (n = "", r = 0) : (n = n.slice(0, l), r = n.length - 1 - n.lastIndexOf("/")), o = a, i = 0;
                continue;
              }
            } else if (n.length > 0) {
              n = "", r = 0, o = a, i = 0;
              continue;
            }
          }
          t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
        } else
          n.length > 0 ? n += "/" + e.slice(o + 1, a) : n = e.slice(o + 1, a), r = a - o - 1;
        o = a, i = 0;
      } else s === 46 && i > -1 ? i++ : i = -1;
    }
    return n;
  }
  function am(e) {
    if (typeof e != "string")
      throw new TypeError(
        "Path must be a string. Received " + JSON.stringify(e)
      );
  }
  const EEe = { cwd: CEe };
  function CEe() {
    return "/";
  }
  function kC(e) {
    return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
    e.auth === void 0);
  }
  function kEe(e) {
    if (typeof e == "string")
      e = new URL(e);
    else if (!kC(e)) {
      const t = new TypeError(
        'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
      );
      throw t.code = "ERR_INVALID_ARG_TYPE", t;
    }
    if (e.protocol !== "file:") {
      const t = new TypeError("The URL must be of scheme file");
      throw t.code = "ERR_INVALID_URL_SCHEME", t;
    }
    return TEe(e);
  }
  function TEe(e) {
    if (e.hostname !== "") {
      const r = new TypeError(
        'File URL host must be "localhost" or empty on darwin'
      );
      throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
    }
    const t = e.pathname;
    let n = -1;
    for (; ++n < t.length; )
      if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
        const r = t.codePointAt(n + 2);
        if (r === 70 || r === 102) {
          const o = new TypeError(
            "File URL path must not include encoded / characters"
          );
          throw o.code = "ERR_INVALID_FILE_URL_PATH", o;
        }
      }
    return decodeURIComponent(t);
  }
  const o_ = (
    /** @type {const} */
    [
      "history",
      "path",
      "basename",
      "stem",
      "extname",
      "dirname"
    ]
  );
  class mV {
    /**
     * Create a new virtual file.
     *
     * `options` is treated as:
     *
     * *   `string` or `Uint8Array`  `{value: options}`
     * *   `URL`  `{path: options}`
     * *   `VFile`  shallow copies its data over to the new file
     * *   `object`  all fields are shallow copied over to the new file
     *
     * Path related fields are set in the following order (least specific to
     * most specific): `history`, `path`, `basename`, `stem`, `extname`,
     * `dirname`.
     *
     * You cannot set `dirname` or `extname` without setting either `history`,
     * `path`, `basename`, or `stem` too.
     *
     * @param {Compatible | null | undefined} [value]
     *   File value.
     * @returns
     *   New instance.
     */
    constructor(t) {
      let n;
      t ? kC(t) ? n = { path: t } : typeof t == "string" || REe(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : EEe.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
      let r = -1;
      for (; ++r < o_.length; ) {
        const i = o_[r];
        i in n && n[i] !== void 0 && n[i] !== null && (this[i] = i === "history" ? [...n[i]] : n[i]);
      }
      let o;
      for (o in n)
        o_.includes(o) || (this[o] = n[o]);
    }
    /**
     * Get the basename (including extname) (example: `'index.min.js'`).
     *
     * @returns {string | undefined}
     *   Basename.
     */
    get basename() {
      return typeof this.path == "string" ? vi.basename(this.path) : void 0;
    }
    /**
     * Set basename (including extname) (`'index.min.js'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be nullified (use `file.path = file.dirname` instead).
     *
     * @param {string} basename
     *   Basename.
     * @returns {undefined}
     *   Nothing.
     */
    set basename(t) {
      a_(t, "basename"), i_(t, "basename"), this.path = vi.join(this.dirname || "", t);
    }
    /**
     * Get the parent path (example: `'~'`).
     *
     * @returns {string | undefined}
     *   Dirname.
     */
    get dirname() {
      return typeof this.path == "string" ? vi.dirname(this.path) : void 0;
    }
    /**
     * Set the parent path (example: `'~'`).
     *
     * Cannot be set if theres no `path` yet.
     *
     * @param {string | undefined} dirname
     *   Dirname.
     * @returns {undefined}
     *   Nothing.
     */
    set dirname(t) {
      Uj(this.basename, "dirname"), this.path = vi.join(t || "", this.basename);
    }
    /**
     * Get the extname (including dot) (example: `'.js'`).
     *
     * @returns {string | undefined}
     *   Extname.
     */
    get extname() {
      return typeof this.path == "string" ? vi.extname(this.path) : void 0;
    }
    /**
     * Set the extname (including dot) (example: `'.js'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be set if theres no `path` yet.
     *
     * @param {string | undefined} extname
     *   Extname.
     * @returns {undefined}
     *   Nothing.
     */
    set extname(t) {
      if (i_(t, "extname"), Uj(this.dirname, "extname"), t) {
        if (t.codePointAt(0) !== 46)
          throw new Error("`extname` must start with `.`");
        if (t.includes(".", 1))
          throw new Error("`extname` cannot contain multiple dots");
      }
      this.path = vi.join(this.dirname, this.stem + (t || ""));
    }
    /**
     * Get the full path (example: `'~/index.min.js'`).
     *
     * @returns {string}
     *   Path.
     */
    get path() {
      return this.history[this.history.length - 1];
    }
    /**
     * Set the full path (example: `'~/index.min.js'`).
     *
     * Cannot be nullified.
     * You can set a file URL (a `URL` object with a `file:` protocol) which will
     * be turned into a path with `url.fileURLToPath`.
     *
     * @param {URL | string} path
     *   Path.
     * @returns {undefined}
     *   Nothing.
     */
    set path(t) {
      kC(t) && (t = kEe(t)), a_(t, "path"), this.path !== t && this.history.push(t);
    }
    /**
     * Get the stem (basename w/o extname) (example: `'index.min'`).
     *
     * @returns {string | undefined}
     *   Stem.
     */
    get stem() {
      return typeof this.path == "string" ? vi.basename(this.path, this.extname) : void 0;
    }
    /**
     * Set the stem (basename w/o extname) (example: `'index.min'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be nullified (use `file.path = file.dirname` instead).
     *
     * @param {string} stem
     *   Stem.
     * @returns {undefined}
     *   Nothing.
     */
    set stem(t) {
      a_(t, "stem"), i_(t, "stem"), this.path = vi.join(this.dirname || "", t + (this.extname || ""));
    }
    // Normal prototypal methods.
    /**
     * Create a fatal message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `true` (error; file not usable)
     * and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * >  **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {never}
     *   Never.
     * @throws {VFileMessage}
     *   Message.
     */
    fail(t, n, r) {
      const o = this.message(t, n, r);
      throw o.fatal = !0, o;
    }
    /**
     * Create an info message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `undefined` (info; change
     * likely not needed) and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * >  **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {VFileMessage}
     *   Message.
     */
    info(t, n, r) {
      const o = this.message(t, n, r);
      return o.fatal = void 0, o;
    }
    /**
     * Create a message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `false` (warning; change may be
     * needed) and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * >  **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {VFileMessage}
     *   Message.
     */
    message(t, n, r) {
      const o = new Sr(
        // @ts-expect-error: the overloads are fine.
        t,
        n,
        r
      );
      return this.path && (o.name = this.path + ":" + o.name, o.file = this.path), o.fatal = !1, this.messages.push(o), o;
    }
    /**
     * Serialize the file.
     *
     * > **Note**: which encodings are supported depends on the engine.
     * > For info on Node.js, see:
     * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
     *
     * @param {string | null | undefined} [encoding='utf8']
     *   Character encoding to understand `value` as when its a `Uint8Array`
     *   (default: `'utf-8'`).
     * @returns {string}
     *   Serialized file.
     */
    toString(t) {
      return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
    }
  }
  function i_(e, t) {
    if (e && e.includes(vi.sep))
      throw new Error(
        "`" + t + "` cannot be a path: did not expect `" + vi.sep + "`"
      );
  }
  function a_(e, t) {
    if (!e)
      throw new Error("`" + t + "` cannot be empty");
  }
  function Uj(e, t) {
    if (!e)
      throw new Error("Setting `" + t + "` requires `path` to be set too");
  }
  function REe(e) {
    return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
  }
  const OEe = (
    /**
     * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
     */
    /** @type {unknown} */
    /**
     * @this {Function}
     * @param {string | symbol} property
     * @returns {(...parameters: Array<unknown>) => unknown}
     */
    function(e) {
      const r = (
        /** @type {Record<string | symbol, Function>} */
        // Prototypes do exist.
        // type-coverage:ignore-next-line
        this.constructor.prototype
      ), o = r[e], i = function() {
        return o.apply(i, arguments);
      };
      return Object.setPrototypeOf(i, r), i;
    }
  ), AEe = {}.hasOwnProperty;
  class vR extends OEe {
    /**
     * Create a processor.
     */
    constructor() {
      super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = gEe();
    }
    /**
     * Copy a processor.
     *
     * @deprecated
     *   This is a private internal method and should not be used.
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *   New *unfrozen* processor ({@linkcode Processor}) that is
     *   configured to work the same as its ancestor.
     *   When the descendant processor is configured in the future it does not
     *   affect the ancestral processor.
     */
    copy() {
      const t = (
        /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
        new vR()
      );
      let n = -1;
      for (; ++n < this.attachers.length; ) {
        const r = this.attachers[n];
        t.use(...r);
      }
      return t.data(r_(!0, {}, this.namespace)), t;
    }
    /**
     * Configure the processor with info available to all plugins.
     * Information is stored in an object.
     *
     * Typically, options can be given to a specific plugin, but sometimes it
     * makes sense to have information shared with several plugins.
     * For example, a list of HTML elements that are self-closing, which is
     * needed during all phases.
     *
     * > **Note**: setting information cannot occur on *frozen* processors.
     * > Call the processor first to create a new unfrozen processor.
     *
     * > **Note**: to register custom data in TypeScript, augment the
     * > {@linkcode Data} interface.
     *
     * @example
     *   This example show how to get and set info:
     *
     *   ```js
     *   import {unified} from 'unified'
     *
     *   const processor = unified().data('alpha', 'bravo')
     *
     *   processor.data('alpha') // => 'bravo'
     *
     *   processor.data() // => {alpha: 'bravo'}
     *
     *   processor.data({charlie: 'delta'})
     *
     *   processor.data() // => {charlie: 'delta'}
     *   ```
     *
     * @template {keyof Data} Key
     *
     * @overload
     * @returns {Data}
     *
     * @overload
     * @param {Data} dataset
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @overload
     * @param {Key} key
     * @returns {Data[Key]}
     *
     * @overload
     * @param {Key} key
     * @param {Data[Key]} value
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @param {Data | Key} [key]
     *   Key to get or set, or entire dataset to set, or nothing to get the
     *   entire dataset (optional).
     * @param {Data[Key]} [value]
     *   Value to set (optional).
     * @returns {unknown}
     *   The current processor when setting, the value at `key` when getting, or
     *   the entire dataset when getting without key.
     */
    data(t, n) {
      return typeof t == "string" ? arguments.length === 2 ? (c_("data", this.frozen), this.namespace[t] = n, this) : AEe.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (c_("data", this.frozen), this.namespace = t, this) : this.namespace;
    }
    /**
     * Freeze a processor.
     *
     * Frozen processors are meant to be extended and not to be configured
     * directly.
     *
     * When a processor is frozen it cannot be unfrozen.
     * New processors working the same way can be created by calling the
     * processor.
     *
     * Its possible to freeze processors explicitly by calling `.freeze()`.
     * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
     * `.stringify()`, `.process()`, or `.processSync()` are called.
     *
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *   The current processor.
     */
    freeze() {
      if (this.frozen)
        return this;
      const t = (
        /** @type {Processor} */
        /** @type {unknown} */
        this
      );
      for (; ++this.freezeIndex < this.attachers.length; ) {
        const [n, ...r] = this.attachers[this.freezeIndex];
        if (r[0] === !1)
          continue;
        r[0] === !0 && (r[0] = void 0);
        const o = n.call(t, ...r);
        typeof o == "function" && this.transformers.use(o);
      }
      return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
    }
    /**
     * Parse text to a syntax tree.
     *
     * > **Note**: `parse` freezes the processor if not already *frozen*.
     *
     * > **Note**: `parse` performs the parse phase, not the run phase or other
     * > phases.
     *
     * @param {Compatible | undefined} [file]
     *   file to parse (optional); typically `string` or `VFile`; any value
     *   accepted as `x` in `new VFile(x)`.
     * @returns {ParseTree extends undefined ? Node : ParseTree}
     *   Syntax tree representing `file`.
     */
    parse(t) {
      this.freeze();
      const n = uy(t), r = this.parser || this.Parser;
      return s_("parse", r), r(String(n), n);
    }
    /**
     * Process the given file as configured on the processor.
     *
     * > **Note**: `process` freezes the processor if not already *frozen*.
     *
     * > **Note**: `process` performs the parse, run, and stringify phases.
     *
     * @overload
     * @param {Compatible | undefined} file
     * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
     * @returns {undefined}
     *
     * @overload
     * @param {Compatible | undefined} [file]
     * @returns {Promise<VFileWithOutput<CompileResult>>}
     *
     * @param {Compatible | undefined} [file]
     *   File (optional); typically `string` or `VFile`]; any value accepted as
     *   `x` in `new VFile(x)`.
     * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
     *   Callback (optional).
     * @returns {Promise<VFile> | undefined}
     *   Nothing if `done` is given.
     *   Otherwise a promise, rejected with a fatal error or resolved with the
     *   processed file.
     *
     *   The parsed, transformed, and compiled value is available at
     *   `file.value` (see note).
     *
     *   > **Note**: unified typically compiles by serializing: most
     *   > compilers return `string` (or `Uint8Array`).
     *   > Some compilers, such as the one configured with
     *   > [`rehype-react`][rehype-react], return other values (in this case, a
     *   > React tree).
     *   > If youre using a compiler that doesnt serialize, expect different
     *   > result values.
     *   >
     *   > To register custom results in TypeScript, add them to
     *   > {@linkcode CompileResultMap}.
     *
     *   [rehype-react]: https://github.com/rehypejs/rehype-react
     */
    process(t, n) {
      const r = this;
      return this.freeze(), s_("process", this.parser || this.Parser), l_("process", this.compiler || this.Compiler), n ? o(void 0, n) : new Promise(o);
      function o(i, a) {
        const s = uy(t), l = (
          /** @type {HeadTree extends undefined ? Node : HeadTree} */
          /** @type {unknown} */
          r.parse(s)
        );
        r.run(l, s, function(d, p, h) {
          if (d || !p || !h)
            return u(d);
          const g = (
            /** @type {CompileTree extends undefined ? Node : CompileTree} */
            /** @type {unknown} */
            p
          ), y = r.stringify(g, h);
          PEe(y) ? h.value = y : h.result = y, u(
            d,
            /** @type {VFileWithOutput<CompileResult>} */
            h
          );
        });
        function u(d, p) {
          d || !p ? a(d) : i ? i(p) : n(void 0, p);
        }
      }
    }
    /**
     * Process the given file as configured on the processor.
     *
     * An error is thrown if asynchronous transforms are configured.
     *
     * > **Note**: `processSync` freezes the processor if not already *frozen*.
     *
     * > **Note**: `processSync` performs the parse, run, and stringify phases.
     *
     * @param {Compatible | undefined} [file]
     *   File (optional); typically `string` or `VFile`; any value accepted as
     *   `x` in `new VFile(x)`.
     * @returns {VFileWithOutput<CompileResult>}
     *   The processed file.
     *
     *   The parsed, transformed, and compiled value is available at
     *   `file.value` (see note).
     *
     *   > **Note**: unified typically compiles by serializing: most
     *   > compilers return `string` (or `Uint8Array`).
     *   > Some compilers, such as the one configured with
     *   > [`rehype-react`][rehype-react], return other values (in this case, a
     *   > React tree).
     *   > If youre using a compiler that doesnt serialize, expect different
     *   > result values.
     *   >
     *   > To register custom results in TypeScript, add them to
     *   > {@linkcode CompileResultMap}.
     *
     *   [rehype-react]: https://github.com/rehypejs/rehype-react
     */
    processSync(t) {
      let n = !1, r;
      return this.freeze(), s_("processSync", this.parser || this.Parser), l_("processSync", this.compiler || this.Compiler), this.process(t, o), Hj("processSync", "process", n), r;
      function o(i, a) {
        n = !0, zj(i), r = a;
      }
    }
    /**
     * Run *transformers* on a syntax tree.
     *
     * > **Note**: `run` freezes the processor if not already *frozen*.
     *
     * > **Note**: `run` performs the run phase, not other phases.
     *
     * @overload
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
     * @returns {undefined}
     *
     * @overload
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     * @param {Compatible | undefined} file
     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
     * @returns {undefined}
     *
     * @overload
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     * @param {Compatible | undefined} [file]
     * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
     *
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     *   Tree to transform and inspect.
     * @param {(
     *   RunCallback<TailTree extends undefined ? Node : TailTree> |
     *   Compatible
     * )} [file]
     *   File associated with `node` (optional); any value accepted as `x` in
     *   `new VFile(x)`.
     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
     *   Callback (optional).
     * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
     *   Nothing if `done` is given.
     *   Otherwise, a promise rejected with a fatal error or resolved with the
     *   transformed tree.
     */
    run(t, n, r) {
      Vj(t), this.freeze();
      const o = this.transformers;
      return !r && typeof n == "function" && (r = n, n = void 0), r ? i(void 0, r) : new Promise(i);
      function i(a, s) {
        const l = uy(n);
        o.run(t, l, u);
        function u(d, p, h) {
          const g = (
            /** @type {TailTree extends undefined ? Node : TailTree} */
            p || t
          );
          d ? s(d) : a ? a(g) : r(void 0, g, h);
        }
      }
    }
    /**
     * Run *transformers* on a syntax tree.
     *
     * An error is thrown if asynchronous transforms are configured.
     *
     * > **Note**: `runSync` freezes the processor if not already *frozen*.
     *
     * > **Note**: `runSync` performs the run phase, not other phases.
     *
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     *   Tree to transform and inspect.
     * @param {Compatible | undefined} [file]
     *   File associated with `node` (optional); any value accepted as `x` in
     *   `new VFile(x)`.
     * @returns {TailTree extends undefined ? Node : TailTree}
     *   Transformed tree.
     */
    runSync(t, n) {
      let r = !1, o;
      return this.run(t, n, i), Hj("runSync", "run", r), o;
      function i(a, s) {
        zj(a), o = s, r = !0;
      }
    }
    /**
     * Compile a syntax tree.
     *
     * > **Note**: `stringify` freezes the processor if not already *frozen*.
     *
     * > **Note**: `stringify` performs the stringify phase, not the run phase
     * > or other phases.
     *
     * @param {CompileTree extends undefined ? Node : CompileTree} tree
     *   Tree to compile.
     * @param {Compatible | undefined} [file]
     *   File associated with `node` (optional); any value accepted as `x` in
     *   `new VFile(x)`.
     * @returns {CompileResult extends undefined ? Value : CompileResult}
     *   Textual representation of the tree (see note).
     *
     *   > **Note**: unified typically compiles by serializing: most compilers
     *   > return `string` (or `Uint8Array`).
     *   > Some compilers, such as the one configured with
     *   > [`rehype-react`][rehype-react], return other values (in this case, a
     *   > React tree).
     *   > If youre using a compiler that doesnt serialize, expect different
     *   > result values.
     *   >
     *   > To register custom results in TypeScript, add them to
     *   > {@linkcode CompileResultMap}.
     *
     *   [rehype-react]: https://github.com/rehypejs/rehype-react
     */
    stringify(t, n) {
      this.freeze();
      const r = uy(n), o = this.compiler || this.Compiler;
      return l_("stringify", o), Vj(t), o(t, r);
    }
    /**
     * Configure the processor to use a plugin, a list of usable values, or a
     * preset.
     *
     * If the processor is already using a plugin, the previous plugin
     * configuration is changed based on the options that are passed in.
     * In other words, the plugin is not added a second time.
     *
     * > **Note**: `use` cannot be called on *frozen* processors.
     * > Call the processor first to create a new unfrozen processor.
     *
     * @example
     *   There are many ways to pass plugins to `.use()`.
     *   This example gives an overview:
     *
     *   ```js
     *   import {unified} from 'unified'
     *
     *   unified()
     *     // Plugin with options:
     *     .use(pluginA, {x: true, y: true})
     *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
     *     .use(pluginA, {y: false, z: true})
     *     // Plugins:
     *     .use([pluginB, pluginC])
     *     // Two plugins, the second with options:
     *     .use([pluginD, [pluginE, {}]])
     *     // Preset with plugins and settings:
     *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
     *     // Settings only:
     *     .use({settings: {position: false}})
     *   ```
     *
     * @template {Array<unknown>} [Parameters=[]]
     * @template {Node | string | undefined} [Input=undefined]
     * @template [Output=Input]
     *
     * @overload
     * @param {Preset | null | undefined} [preset]
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @overload
     * @param {PluggableList} list
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @overload
     * @param {Plugin<Parameters, Input, Output>} plugin
     * @param {...(Parameters | [boolean])} parameters
     * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
     *
     * @param {PluggableList | Plugin | Preset | null | undefined} value
     *   Usable value.
     * @param {...unknown} parameters
     *   Parameters, when a plugin is given as a usable value.
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *   Current processor.
     */
    use(t, ...n) {
      const r = this.attachers, o = this.namespace;
      if (c_("use", this.frozen), t != null) if (typeof t == "function")
        l(t, n);
      else if (typeof t == "object")
        Array.isArray(t) ? s(t) : a(t);
      else
        throw new TypeError("Expected usable value, not `" + t + "`");
      return this;
      function i(u) {
        if (typeof u == "function")
          l(u, []);
        else if (typeof u == "object")
          if (Array.isArray(u)) {
            const [d, ...p] = (
              /** @type {PluginTuple<Array<unknown>>} */
              u
            );
            l(d, p);
          } else
            a(u);
        else
          throw new TypeError("Expected usable value, not `" + u + "`");
      }
      function a(u) {
        if (!("plugins" in u) && !("settings" in u))
          throw new Error(
            "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
          );
        s(u.plugins), u.settings && (o.settings = r_(!0, o.settings, u.settings));
      }
      function s(u) {
        let d = -1;
        if (u != null) if (Array.isArray(u))
          for (; ++d < u.length; ) {
            const p = u[d];
            i(p);
          }
        else
          throw new TypeError("Expected a list of plugins, not `" + u + "`");
      }
      function l(u, d) {
        let p = -1, h = -1;
        for (; ++p < r.length; )
          if (r[p][0] === u) {
            h = p;
            break;
          }
        if (h === -1)
          r.push([u, ...d]);
        else if (d.length > 0) {
          let [g, ...y] = d;
          const b = r[h][1];
          CC(b) && CC(g) && (g = r_(!0, b, g)), r[h] = [u, g, ...y];
        }
      }
    }
  }
  const NEe = new vR().freeze();
  function s_(e, t) {
    if (typeof t != "function")
      throw new TypeError("Cannot `" + e + "` without `parser`");
  }
  function l_(e, t) {
    if (typeof t != "function")
      throw new TypeError("Cannot `" + e + "` without `compiler`");
  }
  function c_(e, t) {
    if (t)
      throw new Error(
        "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
      );
  }
  function Vj(e) {
    if (!CC(e) || typeof e.type != "string")
      throw new TypeError("Expected node, got `" + e + "`");
  }
  function Hj(e, t, n) {
    if (!n)
      throw new Error(
        "`" + e + "` finished async. Use `" + t + "` instead"
      );
  }
  function uy(e) {
    return MEe(e) ? e : new mV(e);
  }
  function MEe(e) {
    return !!(e && typeof e == "object" && "message" in e && "messages" in e);
  }
  function PEe(e) {
    return typeof e == "string" || $Ee(e);
  }
  function $Ee(e) {
    return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
  }
  const IEe = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", qj = [], Wj = { allowDangerousHtml: !0 }, jEe = /^(https?|ircs?|mailto|xmpp)$/i, DEe = [
    { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
    { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
    {
      from: "allowNode",
      id: "replace-allownode-allowedtypes-and-disallowedtypes",
      to: "allowElement"
    },
    {
      from: "allowedTypes",
      id: "replace-allownode-allowedtypes-and-disallowedtypes",
      to: "allowedElements"
    },
    { from: "className", id: "remove-classname" },
    {
      from: "disallowedTypes",
      id: "replace-allownode-allowedtypes-and-disallowedtypes",
      to: "disallowedElements"
    },
    { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
    { from: "includeElementIndex", id: "#remove-includeelementindex" },
    {
      from: "includeNodeIndex",
      id: "change-includenodeindex-to-includeelementindex"
    },
    { from: "linkTarget", id: "remove-linktarget" },
    { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
    { from: "rawSourcePos", id: "#remove-rawsourcepos" },
    { from: "renderers", id: "change-renderers-to-components", to: "components" },
    { from: "source", id: "change-source-to-children", to: "children" },
    { from: "sourcePos", id: "#remove-sourcepos" },
    { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
    { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
  ];
  function FEe(e) {
    const t = LEe(e), n = zEe(e);
    return BEe(t.runSync(t.parse(n), n), e);
  }
  function LEe(e) {
    const t = e.rehypePlugins || qj, n = e.remarkPlugins || qj, r = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...Wj } : Wj;
    return NEe().use(b_e).use(n).use(pEe, r).use(t);
  }
  function zEe(e) {
    const t = e.children || "", n = new mV();
    return typeof t == "string" && (n.value = t), n;
  }
  function BEe(e, t) {
    const n = t.allowedElements, r = t.allowElement, o = t.components, i = t.disallowedElements, a = t.skipHtml, s = t.unwrapDisallowed, l = t.urlTransform || UEe;
    for (const d of DEe)
      Object.hasOwn(t, d.from) && ("" + d.from + (d.to ? "use `" + d.to + "` instead" : "remove it") + IEe + d.id, void 0);
    return yR(e, u), nwe(e, {
      Fragment: S.Fragment,
      components: o,
      ignoreInvalidStyle: !0,
      jsx: S.jsx,
      jsxs: S.jsxs,
      passKeys: !0,
      passNode: !0
    });
    function u(d, p, h) {
      if (d.type === "raw" && h && typeof p == "number")
        return a ? h.children.splice(p, 1) : h.children[p] = { type: "text", value: d.value }, p;
      if (d.type === "element") {
        let g;
        for (g in JS)
          if (Object.hasOwn(JS, g) && Object.hasOwn(d.properties, g)) {
            const y = d.properties[g], b = JS[g];
            (b === null || b.includes(d.tagName)) && (d.properties[g] = l(String(y || ""), g, d));
          }
      }
      if (d.type === "element") {
        let g = n ? !n.includes(d.tagName) : i ? i.includes(d.tagName) : !1;
        if (!g && r && typeof p == "number" && (g = !r(d, p, h)), g && h && typeof p == "number")
          return s && d.children ? h.children.splice(p, 1, ...d.children) : h.children.splice(p, 1), p;
      }
    }
  }
  function UEe(e) {
    const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), o = e.indexOf("/");
    return (
      // If there is no protocol, its relative.
      t === -1 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
      o !== -1 && t > o || n !== -1 && t > n || r !== -1 && t > r || // It is a protocol, it should be allowed.
      jEe.test(e.slice(0, t)) ? e : ""
    );
  }
  function Gj(e, t) {
    const n = String(e);
    if (typeof t != "string")
      throw new TypeError("Expected character");
    let r = 0, o = n.indexOf(t);
    for (; o !== -1; )
      r++, o = n.indexOf(t, o + t.length);
    return r;
  }
  function VEe(e) {
    if (typeof e != "string")
      throw new TypeError("Expected a string");
    return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  }
  function HEe(e, t, n) {
    const o = i1((n || {}).ignore || []), i = qEe(t);
    let a = -1;
    for (; ++a < i.length; )
      hV(e, "text", s);
    function s(u, d) {
      let p = -1, h;
      for (; ++p < d.length; ) {
        const g = d[p], y = h ? h.children : void 0;
        if (o(
          g,
          y ? y.indexOf(g) : void 0,
          h
        ))
          return;
        h = g;
      }
      if (h)
        return l(u, d);
    }
    function l(u, d) {
      const p = d[d.length - 1], h = i[a][0], g = i[a][1];
      let y = 0;
      const v = p.children.indexOf(u);
      let x = !1, E = [];
      h.lastIndex = 0;
      let _ = h.exec(u.value);
      for (; _; ) {
        const C = _.index, k = {
          index: _.index,
          input: _.input,
          stack: [...d, u]
        };
        let R = g(..._, k);
        if (typeof R == "string" && (R = R.length > 0 ? { type: "text", value: R } : void 0), R === !1 ? h.lastIndex = C + 1 : (y !== C && E.push({
          type: "text",
          value: u.value.slice(y, C)
        }), Array.isArray(R) ? E.push(...R) : R && E.push(R), y = C + _[0].length, x = !0), !h.global)
          break;
        _ = h.exec(u.value);
      }
      return x ? (y < u.value.length && E.push({ type: "text", value: u.value.slice(y) }), p.children.splice(v, 1, ...E)) : E = [u], v + E.length;
    }
  }
  function qEe(e) {
    const t = [];
    if (!Array.isArray(e))
      throw new TypeError("Expected find and replace tuple or list of tuples");
    const n = !e[0] || Array.isArray(e[0]) ? e : [e];
    let r = -1;
    for (; ++r < n.length; ) {
      const o = n[r];
      t.push([WEe(o[0]), GEe(o[1])]);
    }
    return t;
  }
  function WEe(e) {
    return typeof e == "string" ? new RegExp(VEe(e), "g") : e;
  }
  function GEe(e) {
    return typeof e == "function" ? e : function() {
      return e;
    };
  }
  const u_ = "phrasing", f_ = ["autolink", "link", "image", "label"];
  function KEe() {
    return {
      transforms: [tCe],
      enter: {
        literalAutolink: XEe,
        literalAutolinkEmail: d_,
        literalAutolinkHttp: d_,
        literalAutolinkWww: d_
      },
      exit: {
        literalAutolink: eCe,
        literalAutolinkEmail: JEe,
        literalAutolinkHttp: ZEe,
        literalAutolinkWww: QEe
      }
    };
  }
  function YEe() {
    return {
      unsafe: [
        {
          character: "@",
          before: "[+\\-.\\w]",
          after: "[\\-.\\w]",
          inConstruct: u_,
          notInConstruct: f_
        },
        {
          character: ".",
          before: "[Ww]",
          after: "[\\-.\\w]",
          inConstruct: u_,
          notInConstruct: f_
        },
        {
          character: ":",
          before: "[ps]",
          after: "\\/",
          inConstruct: u_,
          notInConstruct: f_
        }
      ]
    };
  }
  function XEe(e) {
    this.enter({ type: "link", title: null, url: "", children: [] }, e);
  }
  function d_(e) {
    this.config.enter.autolinkProtocol.call(this, e);
  }
  function ZEe(e) {
    this.config.exit.autolinkProtocol.call(this, e);
  }
  function QEe(e) {
    this.config.exit.data.call(this, e);
    const t = this.stack[this.stack.length - 1];
    t.type, t.url = "http://" + this.sliceSerialize(e);
  }
  function JEe(e) {
    this.config.exit.autolinkEmail.call(this, e);
  }
  function eCe(e) {
    this.exit(e);
  }
  function tCe(e) {
    HEe(
      e,
      [
        [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, nCe],
        [/(?<=^|\s|\p{P}|\p{S})([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/gu, rCe]
      ],
      { ignore: ["link", "linkReference"] }
    );
  }
  function nCe(e, t, n, r, o) {
    let i = "";
    if (!gV(o) || (/^w/i.test(t) && (n = t + n, t = "", i = "http://"), !oCe(n)))
      return !1;
    const a = iCe(n + r);
    if (!a[0]) return !1;
    const s = {
      type: "link",
      title: null,
      url: i + t + a[0],
      children: [{ type: "text", value: t + a[0] }]
    };
    return a[1] ? [s, { type: "text", value: a[1] }] : s;
  }
  function rCe(e, t, n, r) {
    return (
      // Not an expected previous character.
      !gV(r, !0) || // Label ends in not allowed character.
      /[-\d_]$/.test(n) ? !1 : {
        type: "link",
        title: null,
        url: "mailto:" + t + "@" + n,
        children: [{ type: "text", value: t + "@" + n }]
      }
    );
  }
  function oCe(e) {
    const t = e.split(".");
    return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
  }
  function iCe(e) {
    const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
    if (!t)
      return [e, void 0];
    e = e.slice(0, t.index);
    let n = t[0], r = n.indexOf(")");
    const o = Gj(e, "(");
    let i = Gj(e, ")");
    for (; r !== -1 && o > i; )
      e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), i++;
    return [e, n];
  }
  function gV(e, t) {
    const n = e.input.charCodeAt(e.index - 1);
    return (e.index === 0 || fc(n) || n1(n)) && // If its an email, the previous character should not be a slash.
    (!t || n !== 47);
  }
  yV.peek = hCe;
  function aCe() {
    this.buffer();
  }
  function sCe(e) {
    this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
  }
  function lCe() {
    this.buffer();
  }
  function cCe(e) {
    this.enter(
      { type: "footnoteDefinition", identifier: "", label: "", children: [] },
      e
    );
  }
  function uCe(e) {
    const t = this.resume(), n = this.stack[this.stack.length - 1];
    n.type, n.identifier = Wo(
      this.sliceSerialize(e)
    ).toLowerCase(), n.label = t;
  }
  function fCe(e) {
    this.exit(e);
  }
  function dCe(e) {
    const t = this.resume(), n = this.stack[this.stack.length - 1];
    n.type, n.identifier = Wo(
      this.sliceSerialize(e)
    ).toLowerCase(), n.label = t;
  }
  function pCe(e) {
    this.exit(e);
  }
  function hCe() {
    return "[";
  }
  function yV(e, t, n, r) {
    const o = n.createTracker(r);
    let i = o.move("[^");
    const a = n.enter("footnoteReference"), s = n.enter("reference");
    return i += o.move(
      n.safe(n.associationId(e), { after: "]", before: i })
    ), s(), a(), i += o.move("]"), i;
  }
  function mCe() {
    return {
      enter: {
        gfmFootnoteCallString: aCe,
        gfmFootnoteCall: sCe,
        gfmFootnoteDefinitionLabelString: lCe,
        gfmFootnoteDefinition: cCe
      },
      exit: {
        gfmFootnoteCallString: uCe,
        gfmFootnoteCall: fCe,
        gfmFootnoteDefinitionLabelString: dCe,
        gfmFootnoteDefinition: pCe
      }
    };
  }
  function gCe(e) {
    let t = !1;
    return e && e.firstLineBlank && (t = !0), {
      handlers: { footnoteDefinition: n, footnoteReference: yV },
      // This is on by default already.
      unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
    };
    function n(r, o, i, a) {
      const s = i.createTracker(a);
      let l = s.move("[^");
      const u = i.enter("footnoteDefinition"), d = i.enter("label");
      return l += s.move(
        i.safe(i.associationId(r), { before: l, after: "]" })
      ), d(), l += s.move("]:"), r.children && r.children.length > 0 && (s.shift(4), l += s.move(
        (t ? `
` : " ") + i.indentLines(
          i.containerFlow(r, s.current()),
          t ? vV : yCe
        )
      )), u(), l;
    }
  }
  function yCe(e, t, n) {
    return t === 0 ? e : vV(e, t, n);
  }
  function vV(e, t, n) {
    return (n ? "" : "    ") + e;
  }
  const vCe = [
    "autolink",
    "destinationLiteral",
    "destinationRaw",
    "reference",
    "titleQuote",
    "titleApostrophe"
  ];
  bV.peek = _Ce;
  function bCe() {
    return {
      canContainEols: ["delete"],
      enter: { strikethrough: wCe },
      exit: { strikethrough: SCe }
    };
  }
  function xCe() {
    return {
      unsafe: [
        {
          character: "~",
          inConstruct: "phrasing",
          notInConstruct: vCe
        }
      ],
      handlers: { delete: bV }
    };
  }
  function wCe(e) {
    this.enter({ type: "delete", children: [] }, e);
  }
  function SCe(e) {
    this.exit(e);
  }
  function bV(e, t, n, r) {
    const o = n.createTracker(r), i = n.enter("strikethrough");
    let a = o.move("~~");
    return a += n.containerPhrasing(e, {
      ...o.current(),
      before: a,
      after: "~"
    }), a += o.move("~~"), i(), a;
  }
  function _Ce() {
    return "~";
  }
  function ECe(e) {
    return e.length;
  }
  function CCe(e, t) {
    const n = t || {}, r = (n.align || []).concat(), o = n.stringLength || ECe, i = [], a = [], s = [], l = [];
    let u = 0, d = -1;
    for (; ++d < e.length; ) {
      const b = [], v = [];
      let x = -1;
      for (e[d].length > u && (u = e[d].length); ++x < e[d].length; ) {
        const E = kCe(e[d][x]);
        if (n.alignDelimiters !== !1) {
          const _ = o(E);
          v[x] = _, (l[x] === void 0 || _ > l[x]) && (l[x] = _);
        }
        b.push(E);
      }
      a[d] = b, s[d] = v;
    }
    let p = -1;
    if (typeof r == "object" && "length" in r)
      for (; ++p < u; )
        i[p] = Kj(r[p]);
    else {
      const b = Kj(r);
      for (; ++p < u; )
        i[p] = b;
    }
    p = -1;
    const h = [], g = [];
    for (; ++p < u; ) {
      const b = i[p];
      let v = "", x = "";
      b === 99 ? (v = ":", x = ":") : b === 108 ? v = ":" : b === 114 && (x = ":");
      let E = n.alignDelimiters === !1 ? 1 : Math.max(
        1,
        l[p] - v.length - x.length
      );
      const _ = v + "-".repeat(E) + x;
      n.alignDelimiters !== !1 && (E = v.length + E + x.length, E > l[p] && (l[p] = E), g[p] = E), h[p] = _;
    }
    a.splice(1, 0, h), s.splice(1, 0, g), d = -1;
    const y = [];
    for (; ++d < a.length; ) {
      const b = a[d], v = s[d];
      p = -1;
      const x = [];
      for (; ++p < u; ) {
        const E = b[p] || "";
        let _ = "", C = "";
        if (n.alignDelimiters !== !1) {
          const k = l[p] - (v[p] || 0), R = i[p];
          R === 114 ? _ = " ".repeat(k) : R === 99 ? k % 2 ? (_ = " ".repeat(k / 2 + 0.5), C = " ".repeat(k / 2 - 0.5)) : (_ = " ".repeat(k / 2), C = _) : C = " ".repeat(k);
        }
        n.delimiterStart !== !1 && !p && x.push("|"), n.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
        // empty: there will be a closing space.
        !(n.alignDelimiters === !1 && E === "") && (n.delimiterStart !== !1 || p) && x.push(" "), n.alignDelimiters !== !1 && x.push(_), x.push(E), n.alignDelimiters !== !1 && x.push(C), n.padding !== !1 && x.push(" "), (n.delimiterEnd !== !1 || p !== u - 1) && x.push("|");
      }
      y.push(
        n.delimiterEnd === !1 ? x.join("").replace(/ +$/, "") : x.join("")
      );
    }
    return y.join(`
`);
  }
  function kCe(e) {
    return e == null ? "" : String(e);
  }
  function Kj(e) {
    const t = typeof e == "string" ? e.codePointAt(0) : 0;
    return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
  }
  function TCe(e, t, n, r) {
    const o = n.enter("blockquote"), i = n.createTracker(r);
    i.move("> "), i.shift(2);
    const a = n.indentLines(
      n.containerFlow(e, i.current()),
      RCe
    );
    return o(), a;
  }
  function RCe(e, t, n) {
    return ">" + (n ? "" : " ") + e;
  }
  function OCe(e, t) {
    return Yj(e, t.inConstruct, !0) && !Yj(e, t.notInConstruct, !1);
  }
  function Yj(e, t, n) {
    if (typeof t == "string" && (t = [t]), !t || t.length === 0)
      return n;
    let r = -1;
    for (; ++r < t.length; )
      if (e.includes(t[r]))
        return !0;
    return !1;
  }
  function Xj(e, t, n, r) {
    let o = -1;
    for (; ++o < n.unsafe.length; )
      if (n.unsafe[o].character === `
` && OCe(n.stack, n.unsafe[o]))
        return /[ \t]/.test(r.before) ? "" : " ";
    return `\\
`;
  }
  function ACe(e, t) {
    const n = String(e);
    let r = n.indexOf(t), o = r, i = 0, a = 0;
    if (typeof t != "string")
      throw new TypeError("Expected substring");
    for (; r !== -1; )
      r === o ? ++i > a && (a = i) : i = 1, o = r + t.length, r = n.indexOf(t, o);
    return a;
  }
  function NCe(e, t) {
    return !!(t.options.fences === !1 && e.value && // If theres no info
    !e.lang && // And theres a non-whitespace character
    /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
  }
  function MCe(e) {
    const t = e.options.fence || "`";
    if (t !== "`" && t !== "~")
      throw new Error(
        "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
      );
    return t;
  }
  function PCe(e, t, n, r) {
    const o = MCe(n), i = e.value || "", a = o === "`" ? "GraveAccent" : "Tilde";
    if (NCe(e, n)) {
      const p = n.enter("codeIndented"), h = n.indentLines(i, $Ce);
      return p(), h;
    }
    const s = n.createTracker(r), l = o.repeat(Math.max(ACe(i, o) + 1, 3)), u = n.enter("codeFenced");
    let d = s.move(l);
    if (e.lang) {
      const p = n.enter(`codeFencedLang${a}`);
      d += s.move(
        n.safe(e.lang, {
          before: d,
          after: " ",
          encode: ["`"],
          ...s.current()
        })
      ), p();
    }
    if (e.lang && e.meta) {
      const p = n.enter(`codeFencedMeta${a}`);
      d += s.move(" "), d += s.move(
        n.safe(e.meta, {
          before: d,
          after: `
`,
          encode: ["`"],
          ...s.current()
        })
      ), p();
    }
    return d += s.move(`
`), i && (d += s.move(i + `
`)), d += s.move(l), u(), d;
  }
  function $Ce(e, t, n) {
    return (n ? "" : "    ") + e;
  }
  function bR(e) {
    const t = e.options.quote || '"';
    if (t !== '"' && t !== "'")
      throw new Error(
        "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
      );
    return t;
  }
  function ICe(e, t, n, r) {
    const o = bR(n), i = o === '"' ? "Quote" : "Apostrophe", a = n.enter("definition");
    let s = n.enter("label");
    const l = n.createTracker(r);
    let u = l.move("[");
    return u += l.move(
      n.safe(n.associationId(e), {
        before: u,
        after: "]",
        ...l.current()
      })
    ), u += l.move("]: "), s(), // If theres no url, or
    !e.url || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"), u += l.move("<"), u += l.move(
      n.safe(e.url, { before: u, after: ">", ...l.current() })
    ), u += l.move(">")) : (s = n.enter("destinationRaw"), u += l.move(
      n.safe(e.url, {
        before: u,
        after: e.title ? " " : `
`,
        ...l.current()
      })
    )), s(), e.title && (s = n.enter(`title${i}`), u += l.move(" " + o), u += l.move(
      n.safe(e.title, {
        before: u,
        after: o,
        ...l.current()
      })
    ), u += l.move(o), s()), a(), u;
  }
  function jCe(e) {
    const t = e.options.emphasis || "*";
    if (t !== "*" && t !== "_")
      throw new Error(
        "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
      );
    return t;
  }
  function ph(e) {
    return "&#x" + e.toString(16).toUpperCase() + ";";
  }
  function R0(e, t, n) {
    const r = mf(e), o = mf(t);
    return r === void 0 ? o === void 0 ? (
      // Letter inside:
      // we have to encode *both* letters for `_` as it is looser.
      // it already forms for `*` (and GFMs `~`).
      n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
    ) : o === 1 ? (
      // Whitespace inside: encode both (letter, whitespace).
      { inside: !0, outside: !0 }
    ) : (
      // Punctuation inside: encode outer (letter)
      { inside: !1, outside: !0 }
    ) : r === 1 ? o === void 0 ? (
      // Letter inside: already forms.
      { inside: !1, outside: !1 }
    ) : o === 1 ? (
      // Whitespace inside: encode both (whitespace).
      { inside: !0, outside: !0 }
    ) : (
      // Punctuation inside: already forms.
      { inside: !1, outside: !1 }
    ) : o === void 0 ? (
      // Letter inside: already forms.
      { inside: !1, outside: !1 }
    ) : o === 1 ? (
      // Whitespace inside: encode inner (whitespace).
      { inside: !0, outside: !1 }
    ) : (
      // Punctuation inside: already forms.
      { inside: !1, outside: !1 }
    );
  }
  xV.peek = DCe;
  function xV(e, t, n, r) {
    const o = jCe(n), i = n.enter("emphasis"), a = n.createTracker(r), s = a.move(o);
    let l = a.move(
      n.containerPhrasing(e, {
        after: o,
        before: s,
        ...a.current()
      })
    );
    const u = l.charCodeAt(0), d = R0(
      r.before.charCodeAt(r.before.length - 1),
      u,
      o
    );
    d.inside && (l = ph(u) + l.slice(1));
    const p = l.charCodeAt(l.length - 1), h = R0(r.after.charCodeAt(0), p, o);
    h.inside && (l = l.slice(0, -1) + ph(p));
    const g = a.move(o);
    return i(), n.attentionEncodeSurroundingInfo = {
      after: h.outside,
      before: d.outside
    }, s + l + g;
  }
  function DCe(e, t, n) {
    return n.options.emphasis || "*";
  }
  function FCe(e, t) {
    let n = !1;
    return yR(e, function(r) {
      if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
        return n = !0, _C;
    }), !!((!e.depth || e.depth < 3) && uR(e) && (t.options.setext || n));
  }
  function LCe(e, t, n, r) {
    const o = Math.max(Math.min(6, e.depth || 1), 1), i = n.createTracker(r);
    if (FCe(e, n)) {
      const d = n.enter("headingSetext"), p = n.enter("phrasing"), h = n.containerPhrasing(e, {
        ...i.current(),
        before: `
`,
        after: `
`
      });
      return p(), d(), h + `
` + (o === 1 ? "=" : "-").repeat(
        // The whole size
        h.length - // Minus the position of the character after the last EOL (or
        // 0 if there is none)
        (Math.max(h.lastIndexOf("\r"), h.lastIndexOf(`
`)) + 1)
      );
    }
    const a = "#".repeat(o), s = n.enter("headingAtx"), l = n.enter("phrasing");
    i.move(a + " ");
    let u = n.containerPhrasing(e, {
      before: "# ",
      after: `
`,
      ...i.current()
    });
    return /^[\t ]/.test(u) && (u = ph(u.charCodeAt(0)) + u.slice(1)), u = u ? a + " " + u : a, n.options.closeAtx && (u += " " + a), l(), s(), u;
  }
  wV.peek = zCe;
  function wV(e) {
    return e.value || "";
  }
  function zCe() {
    return "<";
  }
  SV.peek = BCe;
  function SV(e, t, n, r) {
    const o = bR(n), i = o === '"' ? "Quote" : "Apostrophe", a = n.enter("image");
    let s = n.enter("label");
    const l = n.createTracker(r);
    let u = l.move("![");
    return u += l.move(
      n.safe(e.alt, { before: u, after: "]", ...l.current() })
    ), u += l.move("]("), s(), // If theres no url but there is a title
    !e.url && e.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"), u += l.move("<"), u += l.move(
      n.safe(e.url, { before: u, after: ">", ...l.current() })
    ), u += l.move(">")) : (s = n.enter("destinationRaw"), u += l.move(
      n.safe(e.url, {
        before: u,
        after: e.title ? " " : ")",
        ...l.current()
      })
    )), s(), e.title && (s = n.enter(`title${i}`), u += l.move(" " + o), u += l.move(
      n.safe(e.title, {
        before: u,
        after: o,
        ...l.current()
      })
    ), u += l.move(o), s()), u += l.move(")"), a(), u;
  }
  function BCe() {
    return "!";
  }
  _V.peek = UCe;
  function _V(e, t, n, r) {
    const o = e.referenceType, i = n.enter("imageReference");
    let a = n.enter("label");
    const s = n.createTracker(r);
    let l = s.move("![");
    const u = n.safe(e.alt, {
      before: l,
      after: "]",
      ...s.current()
    });
    l += s.move(u + "]["), a();
    const d = n.stack;
    n.stack = [], a = n.enter("reference");
    const p = n.safe(n.associationId(e), {
      before: l,
      after: "]",
      ...s.current()
    });
    return a(), n.stack = d, i(), o === "full" || !u || u !== p ? l += s.move(p + "]") : o === "shortcut" ? l = l.slice(0, -1) : l += s.move("]"), l;
  }
  function UCe() {
    return "!";
  }
  EV.peek = VCe;
  function EV(e, t, n) {
    let r = e.value || "", o = "`", i = -1;
    for (; new RegExp("(^|[^`])" + o + "([^`]|$)").test(r); )
      o += "`";
    for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++i < n.unsafe.length; ) {
      const a = n.unsafe[i], s = n.compilePattern(a);
      let l;
      if (a.atBreak)
        for (; l = s.exec(r); ) {
          let u = l.index;
          r.charCodeAt(u) === 10 && r.charCodeAt(u - 1) === 13 && u--, r = r.slice(0, u) + " " + r.slice(l.index + 1);
        }
    }
    return o + r + o;
  }
  function VCe() {
    return "`";
  }
  function CV(e, t) {
    const n = uR(e);
    return !!(!t.options.resourceLink && // If theres a url
    e.url && // And theres a no title
    !e.title && // And the content of `node` is a single text node
    e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
    (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol
    /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
    // references dont work), space, or angle brackets
    !/[\0- <>\u007F]/.test(e.url));
  }
  kV.peek = HCe;
  function kV(e, t, n, r) {
    const o = bR(n), i = o === '"' ? "Quote" : "Apostrophe", a = n.createTracker(r);
    let s, l;
    if (CV(e, n)) {
      const d = n.stack;
      n.stack = [], s = n.enter("autolink");
      let p = a.move("<");
      return p += a.move(
        n.containerPhrasing(e, {
          before: p,
          after: ">",
          ...a.current()
        })
      ), p += a.move(">"), s(), n.stack = d, p;
    }
    s = n.enter("link"), l = n.enter("label");
    let u = a.move("[");
    return u += a.move(
      n.containerPhrasing(e, {
        before: u,
        after: "](",
        ...a.current()
      })
    ), u += a.move("]("), l(), // If theres no url but there is a title
    !e.url && e.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(e.url) ? (l = n.enter("destinationLiteral"), u += a.move("<"), u += a.move(
      n.safe(e.url, { before: u, after: ">", ...a.current() })
    ), u += a.move(">")) : (l = n.enter("destinationRaw"), u += a.move(
      n.safe(e.url, {
        before: u,
        after: e.title ? " " : ")",
        ...a.current()
      })
    )), l(), e.title && (l = n.enter(`title${i}`), u += a.move(" " + o), u += a.move(
      n.safe(e.title, {
        before: u,
        after: o,
        ...a.current()
      })
    ), u += a.move(o), l()), u += a.move(")"), s(), u;
  }
  function HCe(e, t, n) {
    return CV(e, n) ? "<" : "[";
  }
  TV.peek = qCe;
  function TV(e, t, n, r) {
    const o = e.referenceType, i = n.enter("linkReference");
    let a = n.enter("label");
    const s = n.createTracker(r);
    let l = s.move("[");
    const u = n.containerPhrasing(e, {
      before: l,
      after: "]",
      ...s.current()
    });
    l += s.move(u + "]["), a();
    const d = n.stack;
    n.stack = [], a = n.enter("reference");
    const p = n.safe(n.associationId(e), {
      before: l,
      after: "]",
      ...s.current()
    });
    return a(), n.stack = d, i(), o === "full" || !u || u !== p ? l += s.move(p + "]") : o === "shortcut" ? l = l.slice(0, -1) : l += s.move("]"), l;
  }
  function qCe() {
    return "[";
  }
  function xR(e) {
    const t = e.options.bullet || "*";
    if (t !== "*" && t !== "+" && t !== "-")
      throw new Error(
        "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
      );
    return t;
  }
  function WCe(e) {
    const t = xR(e), n = e.options.bulletOther;
    if (!n)
      return t === "*" ? "-" : "*";
    if (n !== "*" && n !== "+" && n !== "-")
      throw new Error(
        "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
      );
    if (n === t)
      throw new Error(
        "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
      );
    return n;
  }
  function GCe(e) {
    const t = e.options.bulletOrdered || ".";
    if (t !== "." && t !== ")")
      throw new Error(
        "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
      );
    return t;
  }
  function RV(e) {
    const t = e.options.rule || "*";
    if (t !== "*" && t !== "-" && t !== "_")
      throw new Error(
        "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
      );
    return t;
  }
  function KCe(e, t, n, r) {
    const o = n.enter("list"), i = n.bulletCurrent;
    let a = e.ordered ? GCe(n) : xR(n);
    const s = e.ordered ? a === "." ? ")" : "." : WCe(n);
    let l = t && n.bulletLastUsed ? a === n.bulletLastUsed : !1;
    if (!e.ordered) {
      const d = e.children ? e.children[0] : void 0;
      if (
        // Bullet could be used as a thematic break marker:
        (a === "*" || a === "-") && // Empty first list item:
        d && (!d.children || !d.children[0]) && // Directly in two other list items:
        n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
        n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (l = !0), RV(n) === a && d
      ) {
        let p = -1;
        for (; ++p < e.children.length; ) {
          const h = e.children[p];
          if (h && h.type === "listItem" && h.children && h.children[0] && h.children[0].type === "thematicBreak") {
            l = !0;
            break;
          }
        }
      }
    }
    l && (a = s), n.bulletCurrent = a;
    const u = n.containerFlow(e, r);
    return n.bulletLastUsed = a, n.bulletCurrent = i, o(), u;
  }
  function YCe(e) {
    const t = e.options.listItemIndent || "one";
    if (t !== "tab" && t !== "one" && t !== "mixed")
      throw new Error(
        "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
      );
    return t;
  }
  function XCe(e, t, n, r) {
    const o = YCe(n);
    let i = n.bulletCurrent || xR(n);
    t && t.type === "list" && t.ordered && (i = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + i);
    let a = i.length + 1;
    (o === "tab" || o === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (a = Math.ceil(a / 4) * 4);
    const s = n.createTracker(r);
    s.move(i + " ".repeat(a - i.length)), s.shift(a);
    const l = n.enter("listItem"), u = n.indentLines(
      n.containerFlow(e, s.current()),
      d
    );
    return l(), u;
    function d(p, h, g) {
      return h ? (g ? "" : " ".repeat(a)) + p : (g ? i : i + " ".repeat(a - i.length)) + p;
    }
  }
  function ZCe(e, t, n, r) {
    const o = n.enter("paragraph"), i = n.enter("phrasing"), a = n.containerPhrasing(e, r);
    return i(), o(), a;
  }
  const QCe = (
    /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
    i1([
      "break",
      "delete",
      "emphasis",
      // To do: next major: removed since footnotes were added to GFM.
      "footnote",
      "footnoteReference",
      "image",
      "imageReference",
      "inlineCode",
      // Enabled by `mdast-util-math`:
      "inlineMath",
      "link",
      "linkReference",
      // Enabled by `mdast-util-mdx`:
      "mdxJsxTextElement",
      // Enabled by `mdast-util-mdx`:
      "mdxTextExpression",
      "strong",
      "text",
      // Enabled by `mdast-util-directive`:
      "textDirective"
    ])
  );
  function JCe(e, t, n, r) {
    return (e.children.some(function(a) {
      return QCe(a);
    }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
  }
  function eke(e) {
    const t = e.options.strong || "*";
    if (t !== "*" && t !== "_")
      throw new Error(
        "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
      );
    return t;
  }
  OV.peek = tke;
  function OV(e, t, n, r) {
    const o = eke(n), i = n.enter("strong"), a = n.createTracker(r), s = a.move(o + o);
    let l = a.move(
      n.containerPhrasing(e, {
        after: o,
        before: s,
        ...a.current()
      })
    );
    const u = l.charCodeAt(0), d = R0(
      r.before.charCodeAt(r.before.length - 1),
      u,
      o
    );
    d.inside && (l = ph(u) + l.slice(1));
    const p = l.charCodeAt(l.length - 1), h = R0(r.after.charCodeAt(0), p, o);
    h.inside && (l = l.slice(0, -1) + ph(p));
    const g = a.move(o + o);
    return i(), n.attentionEncodeSurroundingInfo = {
      after: h.outside,
      before: d.outside
    }, s + l + g;
  }
  function tke(e, t, n) {
    return n.options.strong || "*";
  }
  function nke(e, t, n, r) {
    return n.safe(e.value, r);
  }
  function rke(e) {
    const t = e.options.ruleRepetition || 3;
    if (t < 3)
      throw new Error(
        "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
      );
    return t;
  }
  function oke(e, t, n) {
    const r = (RV(n) + (n.options.ruleSpaces ? " " : "")).repeat(rke(n));
    return n.options.ruleSpaces ? r.slice(0, -1) : r;
  }
  const AV = {
    blockquote: TCe,
    break: Xj,
    code: PCe,
    definition: ICe,
    emphasis: xV,
    hardBreak: Xj,
    heading: LCe,
    html: wV,
    image: SV,
    imageReference: _V,
    inlineCode: EV,
    link: kV,
    linkReference: TV,
    list: KCe,
    listItem: XCe,
    paragraph: ZCe,
    root: JCe,
    strong: OV,
    text: nke,
    thematicBreak: oke
  };
  function ike() {
    return {
      enter: {
        table: ake,
        tableData: Zj,
        tableHeader: Zj,
        tableRow: lke
      },
      exit: {
        codeText: cke,
        table: ske,
        tableData: p_,
        tableHeader: p_,
        tableRow: p_
      }
    };
  }
  function ake(e) {
    const t = e._align;
    this.enter(
      {
        type: "table",
        align: t.map(function(n) {
          return n === "none" ? null : n;
        }),
        children: []
      },
      e
    ), this.data.inTable = !0;
  }
  function ske(e) {
    this.exit(e), this.data.inTable = void 0;
  }
  function lke(e) {
    this.enter({ type: "tableRow", children: [] }, e);
  }
  function p_(e) {
    this.exit(e);
  }
  function Zj(e) {
    this.enter({ type: "tableCell", children: [] }, e);
  }
  function cke(e) {
    let t = this.resume();
    this.data.inTable && (t = t.replace(/\\([\\|])/g, uke));
    const n = this.stack[this.stack.length - 1];
    n.type, n.value = t, this.exit(e);
  }
  function uke(e, t) {
    return t === "|" ? t : e;
  }
  function fke(e) {
    const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, o = t.stringLength, i = n ? " " : "|";
    return {
      unsafe: [
        { character: "\r", inConstruct: "tableCell" },
        { character: `
`, inConstruct: "tableCell" },
        // A pipe, when followed by a tab or space (padding), or a dash or colon
        // (unpadded delimiter row), could result in a table.
        { atBreak: !0, character: "|", after: "[	 :-]" },
        // A pipe in a cell must be encoded.
        { character: "|", inConstruct: "tableCell" },
        // A colon must be followed by a dash, in which case it could start a
        // delimiter row.
        { atBreak: !0, character: ":", after: "-" },
        // A delimiter row can also start with a dash, when followed by more
        // dashes, a colon, or a pipe.
        // This is a stricter version than the built in check for lists, thematic
        // breaks, and setex heading underlines though:
        // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
        { atBreak: !0, character: "-", after: "[:|-]" }
      ],
      handlers: {
        inlineCode: h,
        table: a,
        tableCell: l,
        tableRow: s
      }
    };
    function a(g, y, b, v) {
      return u(d(g, b, v), g.align);
    }
    function s(g, y, b, v) {
      const x = p(g, b, v), E = u([x]);
      return E.slice(0, E.indexOf(`
`));
    }
    function l(g, y, b, v) {
      const x = b.enter("tableCell"), E = b.enter("phrasing"), _ = b.containerPhrasing(g, {
        ...v,
        before: i,
        after: i
      });
      return E(), x(), _;
    }
    function u(g, y) {
      return CCe(g, {
        align: y,
        // @ts-expect-error: `markdown-table` types should support `null`.
        alignDelimiters: r,
        // @ts-expect-error: `markdown-table` types should support `null`.
        padding: n,
        // @ts-expect-error: `markdown-table` types should support `null`.
        stringLength: o
      });
    }
    function d(g, y, b) {
      const v = g.children;
      let x = -1;
      const E = [], _ = y.enter("table");
      for (; ++x < v.length; )
        E[x] = p(v[x], y, b);
      return _(), E;
    }
    function p(g, y, b) {
      const v = g.children;
      let x = -1;
      const E = [], _ = y.enter("tableRow");
      for (; ++x < v.length; )
        E[x] = l(v[x], g, y, b);
      return _(), E;
    }
    function h(g, y, b) {
      let v = AV.inlineCode(g, y, b);
      return b.stack.includes("tableCell") && (v = v.replace(/\|/g, "\\$&")), v;
    }
  }
  function dke() {
    return {
      exit: {
        taskListCheckValueChecked: Qj,
        taskListCheckValueUnchecked: Qj,
        paragraph: hke
      }
    };
  }
  function pke() {
    return {
      unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
      handlers: { listItem: mke }
    };
  }
  function Qj(e) {
    const t = this.stack[this.stack.length - 2];
    t.type, t.checked = e.type === "taskListCheckValueChecked";
  }
  function hke(e) {
    const t = this.stack[this.stack.length - 2];
    if (t && t.type === "listItem" && typeof t.checked == "boolean") {
      const n = this.stack[this.stack.length - 1];
      n.type;
      const r = n.children[0];
      if (r && r.type === "text") {
        const o = t.children;
        let i = -1, a;
        for (; ++i < o.length; ) {
          const s = o[i];
          if (s.type === "paragraph") {
            a = s;
            break;
          }
        }
        a === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
      }
    }
    this.exit(e);
  }
  function mke(e, t, n, r) {
    const o = e.children[0], i = typeof e.checked == "boolean" && o && o.type === "paragraph", a = "[" + (e.checked ? "x" : " ") + "] ", s = n.createTracker(r);
    i && s.move(a);
    let l = AV.listItem(e, t, n, {
      ...r,
      ...s.current()
    });
    return i && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, u)), l;
    function u(d) {
      return d + a;
    }
  }
  function gke() {
    return [
      KEe(),
      mCe(),
      bCe(),
      ike(),
      dke()
    ];
  }
  function yke(e) {
    return {
      extensions: [
        YEe(),
        gCe(e),
        xCe(),
        fke(e),
        pke()
      ]
    };
  }
  const vke = {
    tokenize: Eke,
    partial: !0
  }, NV = {
    tokenize: Cke,
    partial: !0
  }, MV = {
    tokenize: kke,
    partial: !0
  }, PV = {
    tokenize: Tke,
    partial: !0
  }, bke = {
    tokenize: Rke,
    partial: !0
  }, $V = {
    name: "wwwAutolink",
    tokenize: Ske,
    previous: jV
  }, IV = {
    name: "protocolAutolink",
    tokenize: _ke,
    previous: DV
  }, Qa = {
    name: "emailAutolink",
    tokenize: wke,
    previous: FV
  }, Qi = {};
  function xke() {
    return {
      text: Qi
    };
  }
  let Pl = 48;
  for (; Pl < 123; )
    Qi[Pl] = Qa, Pl++, Pl === 58 ? Pl = 65 : Pl === 91 && (Pl = 97);
  Qi[43] = Qa;
  Qi[45] = Qa;
  Qi[46] = Qa;
  Qi[95] = Qa;
  Qi[72] = [Qa, IV];
  Qi[104] = [Qa, IV];
  Qi[87] = [Qa, $V];
  Qi[119] = [Qa, $V];
  function wke(e, t, n) {
    const r = this;
    let o, i;
    return a;
    function a(p) {
      return !TC(p) || !FV.call(r, r.previous) || wR(r.events) ? n(p) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), s(p));
    }
    function s(p) {
      return TC(p) ? (e.consume(p), s) : p === 64 ? (e.consume(p), l) : n(p);
    }
    function l(p) {
      return p === 46 ? e.check(bke, d, u)(p) : p === 45 || p === 95 || gr(p) ? (i = !0, e.consume(p), l) : d(p);
    }
    function u(p) {
      return e.consume(p), o = !0, l;
    }
    function d(p) {
      return i && o && Tr(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(p)) : n(p);
    }
  }
  function Ske(e, t, n) {
    const r = this;
    return o;
    function o(a) {
      return a !== 87 && a !== 119 || !jV.call(r, r.previous) || wR(r.events) ? n(a) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(vke, e.attempt(NV, e.attempt(MV, i), n), n)(a));
    }
    function i(a) {
      return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(a);
    }
  }
  function _ke(e, t, n) {
    const r = this;
    let o = "", i = !1;
    return a;
    function a(p) {
      return (p === 72 || p === 104) && DV.call(r, r.previous) && !wR(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), o += String.fromCodePoint(p), e.consume(p), s) : n(p);
    }
    function s(p) {
      if (Tr(p) && o.length < 5)
        return o += String.fromCodePoint(p), e.consume(p), s;
      if (p === 58) {
        const h = o.toLowerCase();
        if (h === "http" || h === "https")
          return e.consume(p), l;
      }
      return n(p);
    }
    function l(p) {
      return p === 47 ? (e.consume(p), i ? u : (i = !0, l)) : n(p);
    }
    function u(p) {
      return p === null || C0(p) || on(p) || fc(p) || n1(p) ? n(p) : e.attempt(NV, e.attempt(MV, d), n)(p);
    }
    function d(p) {
      return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(p);
    }
  }
  function Eke(e, t, n) {
    let r = 0;
    return o;
    function o(a) {
      return (a === 87 || a === 119) && r < 3 ? (r++, e.consume(a), o) : a === 46 && r === 3 ? (e.consume(a), i) : n(a);
    }
    function i(a) {
      return a === null ? n(a) : t(a);
    }
  }
  function Cke(e, t, n) {
    let r, o, i;
    return a;
    function a(u) {
      return u === 46 || u === 95 ? e.check(PV, l, s)(u) : u === null || on(u) || fc(u) || u !== 45 && n1(u) ? l(u) : (i = !0, e.consume(u), a);
    }
    function s(u) {
      return u === 95 ? r = !0 : (o = r, r = void 0), e.consume(u), a;
    }
    function l(u) {
      return o || r || !i ? n(u) : t(u);
    }
  }
  function kke(e, t) {
    let n = 0, r = 0;
    return o;
    function o(a) {
      return a === 40 ? (n++, e.consume(a), o) : a === 41 && r < n ? i(a) : a === 33 || a === 34 || a === 38 || a === 39 || a === 41 || a === 42 || a === 44 || a === 46 || a === 58 || a === 59 || a === 60 || a === 63 || a === 93 || a === 95 || a === 126 ? e.check(PV, t, i)(a) : a === null || on(a) || fc(a) ? t(a) : (e.consume(a), o);
    }
    function i(a) {
      return a === 41 && r++, e.consume(a), o;
    }
  }
  function Tke(e, t, n) {
    return r;
    function r(s) {
      return s === 33 || s === 34 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 63 || s === 95 || s === 126 ? (e.consume(s), r) : s === 38 ? (e.consume(s), i) : s === 93 ? (e.consume(s), o) : (
        // `<` is an end.
        s === 60 || // So is whitespace.
        s === null || on(s) || fc(s) ? t(s) : n(s)
      );
    }
    function o(s) {
      return s === null || s === 40 || s === 91 || on(s) || fc(s) ? t(s) : r(s);
    }
    function i(s) {
      return Tr(s) ? a(s) : n(s);
    }
    function a(s) {
      return s === 59 ? (e.consume(s), r) : Tr(s) ? (e.consume(s), a) : n(s);
    }
  }
  function Rke(e, t, n) {
    return r;
    function r(i) {
      return e.consume(i), o;
    }
    function o(i) {
      return gr(i) ? n(i) : t(i);
    }
  }
  function jV(e) {
    return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || on(e);
  }
  function DV(e) {
    return !Tr(e);
  }
  function FV(e) {
    return !(e === 47 || TC(e));
  }
  function TC(e) {
    return e === 43 || e === 45 || e === 46 || e === 95 || gr(e);
  }
  function wR(e) {
    let t = e.length, n = !1;
    for (; t--; ) {
      const r = e[t][1];
      if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
        n = !0;
        break;
      }
      if (r._gfmAutolinkLiteralWalkedInto) {
        n = !1;
        break;
      }
    }
    return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
  }
  const Oke = {
    tokenize: Dke,
    partial: !0
  };
  function Ake() {
    return {
      document: {
        91: {
          name: "gfmFootnoteDefinition",
          tokenize: $ke,
          continuation: {
            tokenize: Ike
          },
          exit: jke
        }
      },
      text: {
        91: {
          name: "gfmFootnoteCall",
          tokenize: Pke
        },
        93: {
          name: "gfmPotentialFootnoteCall",
          add: "after",
          tokenize: Nke,
          resolveTo: Mke
        }
      }
    };
  }
  function Nke(e, t, n) {
    const r = this;
    let o = r.events.length;
    const i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
    let a;
    for (; o--; ) {
      const l = r.events[o][1];
      if (l.type === "labelImage") {
        a = l;
        break;
      }
      if (l.type === "gfmFootnoteCall" || l.type === "labelLink" || l.type === "label" || l.type === "image" || l.type === "link")
        break;
    }
    return s;
    function s(l) {
      if (!a || !a._balanced)
        return n(l);
      const u = Wo(r.sliceSerialize({
        start: a.end,
        end: r.now()
      }));
      return u.codePointAt(0) !== 94 || !i.includes(u.slice(1)) ? n(l) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(l), e.exit("gfmFootnoteCallLabelMarker"), t(l));
    }
  }
  function Mke(e, t) {
    let n = e.length;
    for (; n--; )
      if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
        e[n][1];
        break;
      }
    e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
    const r = {
      type: "gfmFootnoteCall",
      start: Object.assign({}, e[n + 3][1].start),
      end: Object.assign({}, e[e.length - 1][1].end)
    }, o = {
      type: "gfmFootnoteCallMarker",
      start: Object.assign({}, e[n + 3][1].end),
      end: Object.assign({}, e[n + 3][1].end)
    };
    o.end.column++, o.end.offset++, o.end._bufferIndex++;
    const i = {
      type: "gfmFootnoteCallString",
      start: Object.assign({}, o.end),
      end: Object.assign({}, e[e.length - 1][1].start)
    }, a = {
      type: "chunkString",
      contentType: "string",
      start: Object.assign({}, i.start),
      end: Object.assign({}, i.end)
    }, s = [
      // Take the `labelImageMarker` (now `data`, the `!`)
      e[n + 1],
      e[n + 2],
      ["enter", r, t],
      // The `[`
      e[n + 3],
      e[n + 4],
      // The `^`.
      ["enter", o, t],
      ["exit", o, t],
      // Everything in between.
      ["enter", i, t],
      ["enter", a, t],
      ["exit", a, t],
      ["exit", i, t],
      // The ending (`]`, properly parsed and labelled).
      e[e.length - 2],
      e[e.length - 1],
      ["exit", r, t]
    ];
    return e.splice(n, e.length - n + 1, ...s), e;
  }
  function Pke(e, t, n) {
    const r = this, o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
    let i = 0, a;
    return s;
    function s(p) {
      return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), l;
    }
    function l(p) {
      return p !== 94 ? n(p) : (e.enter("gfmFootnoteCallMarker"), e.consume(p), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", u);
    }
    function u(p) {
      if (
        // Too long.
        i > 999 || // Closing brace with nothing.
        p === 93 && !a || // Space or tab is not supported by GFM for some reason.
        // `\n` and `[` not being supported makes sense.
        p === null || p === 91 || on(p)
      )
        return n(p);
      if (p === 93) {
        e.exit("chunkString");
        const h = e.exit("gfmFootnoteCallString");
        return o.includes(Wo(r.sliceSerialize(h))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(p);
      }
      return on(p) || (a = !0), i++, e.consume(p), p === 92 ? d : u;
    }
    function d(p) {
      return p === 91 || p === 92 || p === 93 ? (e.consume(p), i++, u) : u(p);
    }
  }
  function $ke(e, t, n) {
    const r = this, o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
    let i, a = 0, s;
    return l;
    function l(y) {
      return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(y), e.exit("gfmFootnoteDefinitionLabelMarker"), u;
    }
    function u(y) {
      return y === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(y), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", d) : n(y);
    }
    function d(y) {
      if (
        // Too long.
        a > 999 || // Closing brace with nothing.
        y === 93 && !s || // Space or tab is not supported by GFM for some reason.
        // `\n` and `[` not being supported makes sense.
        y === null || y === 91 || on(y)
      )
        return n(y);
      if (y === 93) {
        e.exit("chunkString");
        const b = e.exit("gfmFootnoteDefinitionLabelString");
        return i = Wo(r.sliceSerialize(b)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(y), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), h;
      }
      return on(y) || (s = !0), a++, e.consume(y), y === 92 ? p : d;
    }
    function p(y) {
      return y === 91 || y === 92 || y === 93 ? (e.consume(y), a++, d) : d(y);
    }
    function h(y) {
      return y === 58 ? (e.enter("definitionMarker"), e.consume(y), e.exit("definitionMarker"), o.includes(i) || o.push(i), Nt(e, g, "gfmFootnoteDefinitionWhitespace")) : n(y);
    }
    function g(y) {
      return t(y);
    }
  }
  function Ike(e, t, n) {
    return e.check(im, t, e.attempt(Oke, t, n));
  }
  function jke(e) {
    e.exit("gfmFootnoteDefinition");
  }
  function Dke(e, t, n) {
    const r = this;
    return Nt(e, o, "gfmFootnoteDefinitionIndent", 5);
    function o(i) {
      const a = r.events[r.events.length - 1];
      return a && a[1].type === "gfmFootnoteDefinitionIndent" && a[2].sliceSerialize(a[1], !0).length === 4 ? t(i) : n(i);
    }
  }
  function Fke(e) {
    let n = (e || {}).singleTilde;
    const r = {
      name: "strikethrough",
      tokenize: i,
      resolveAll: o
    };
    return n == null && (n = !0), {
      text: {
        126: r
      },
      insideSpan: {
        null: [r]
      },
      attentionMarkers: {
        null: [126]
      }
    };
    function o(a, s) {
      let l = -1;
      for (; ++l < a.length; )
        if (a[l][0] === "enter" && a[l][1].type === "strikethroughSequenceTemporary" && a[l][1]._close) {
          let u = l;
          for (; u--; )
            if (a[u][0] === "exit" && a[u][1].type === "strikethroughSequenceTemporary" && a[u][1]._open && // If the sizes are the same:
            a[l][1].end.offset - a[l][1].start.offset === a[u][1].end.offset - a[u][1].start.offset) {
              a[l][1].type = "strikethroughSequence", a[u][1].type = "strikethroughSequence";
              const d = {
                type: "strikethrough",
                start: Object.assign({}, a[u][1].start),
                end: Object.assign({}, a[l][1].end)
              }, p = {
                type: "strikethroughText",
                start: Object.assign({}, a[u][1].end),
                end: Object.assign({}, a[l][1].start)
              }, h = [["enter", d, s], ["enter", a[u][1], s], ["exit", a[u][1], s], ["enter", p, s]], g = s.parser.constructs.insideSpan.null;
              g && so(h, h.length, 0, r1(g, a.slice(u + 1, l), s)), so(h, h.length, 0, [["exit", p, s], ["enter", a[l][1], s], ["exit", a[l][1], s], ["exit", d, s]]), so(a, u - 1, l - u + 3, h), l = u + h.length - 2;
              break;
            }
        }
      for (l = -1; ++l < a.length; )
        a[l][1].type === "strikethroughSequenceTemporary" && (a[l][1].type = "data");
      return a;
    }
    function i(a, s, l) {
      const u = this.previous, d = this.events;
      let p = 0;
      return h;
      function h(y) {
        return u === 126 && d[d.length - 1][1].type !== "characterEscape" ? l(y) : (a.enter("strikethroughSequenceTemporary"), g(y));
      }
      function g(y) {
        const b = mf(u);
        if (y === 126)
          return p > 1 ? l(y) : (a.consume(y), p++, g);
        if (p < 2 && !n) return l(y);
        const v = a.exit("strikethroughSequenceTemporary"), x = mf(y);
        return v._open = !x || x === 2 && !!b, v._close = !b || b === 2 && !!x, s(y);
      }
    }
  }
  class Lke {
    /**
     * Create a new edit map.
     */
    constructor() {
      this.map = [];
    }
    /**
     * Create an edit: a remove and/or add at a certain place.
     *
     * @param {number} index
     * @param {number} remove
     * @param {Array<Event>} add
     * @returns {undefined}
     */
    add(t, n, r) {
      zke(this, t, n, r);
    }
    // To do: add this when moving to `micromark`.
    // /**
    //  * Create an edit: but insert `add` before existing additions.
    //  *
    //  * @param {number} index
    //  * @param {number} remove
    //  * @param {Array<Event>} add
    //  * @returns {undefined}
    //  */
    // addBefore(index, remove, add) {
    //   addImplementation(this, index, remove, add, true)
    // }
    /**
     * Done, change the events.
     *
     * @param {Array<Event>} events
     * @returns {undefined}
     */
    consume(t) {
      if (this.map.sort(function(i, a) {
        return i[0] - a[0];
      }), this.map.length === 0)
        return;
      let n = this.map.length;
      const r = [];
      for (; n > 0; )
        n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
      r.push(t.slice()), t.length = 0;
      let o = r.pop();
      for (; o; ) {
        for (const i of o)
          t.push(i);
        o = r.pop();
      }
      this.map.length = 0;
    }
  }
  function zke(e, t, n, r) {
    let o = 0;
    if (!(n === 0 && r.length === 0)) {
      for (; o < e.map.length; ) {
        if (e.map[o][0] === t) {
          e.map[o][1] += n, e.map[o][2].push(...r);
          return;
        }
        o += 1;
      }
      e.map.push([t, n, r]);
    }
  }
  function Bke(e, t) {
    let n = !1;
    const r = [];
    for (; t < e.length; ) {
      const o = e[t];
      if (n) {
        if (o[0] === "enter")
          o[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
        else if (o[1].type === "tableContent") {
          if (e[t - 1][1].type === "tableDelimiterMarker") {
            const i = r.length - 1;
            r[i] = r[i] === "left" ? "center" : "right";
          }
        } else if (o[1].type === "tableDelimiterRow")
          break;
      } else o[0] === "enter" && o[1].type === "tableDelimiterRow" && (n = !0);
      t += 1;
    }
    return r;
  }
  function Uke() {
    return {
      flow: {
        null: {
          name: "table",
          tokenize: Vke,
          resolveAll: Hke
        }
      }
    };
  }
  function Vke(e, t, n) {
    const r = this;
    let o = 0, i = 0, a;
    return s;
    function s(D) {
      let L = r.events.length - 1;
      for (; L > -1; ) {
        const j = r.events[L][1].type;
        if (j === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
        j === "linePrefix") L--;
        else break;
      }
      const P = L > -1 ? r.events[L][1].type : null, B = P === "tableHead" || P === "tableRow" ? R : l;
      return B === R && r.parser.lazy[r.now().line] ? n(D) : B(D);
    }
    function l(D) {
      return e.enter("tableHead"), e.enter("tableRow"), u(D);
    }
    function u(D) {
      return D === 124 || (a = !0, i += 1), d(D);
    }
    function d(D) {
      return D === null ? n(D) : Xe(D) ? i > 1 ? (i = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(D), e.exit("lineEnding"), g) : n(D) : Et(D) ? Nt(e, d, "whitespace")(D) : (i += 1, a && (a = !1, o += 1), D === 124 ? (e.enter("tableCellDivider"), e.consume(D), e.exit("tableCellDivider"), a = !0, d) : (e.enter("data"), p(D)));
    }
    function p(D) {
      return D === null || D === 124 || on(D) ? (e.exit("data"), d(D)) : (e.consume(D), D === 92 ? h : p);
    }
    function h(D) {
      return D === 92 || D === 124 ? (e.consume(D), p) : p(D);
    }
    function g(D) {
      return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(D) : (e.enter("tableDelimiterRow"), a = !1, Et(D) ? Nt(e, y, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(D) : y(D));
    }
    function y(D) {
      return D === 45 || D === 58 ? v(D) : D === 124 ? (a = !0, e.enter("tableCellDivider"), e.consume(D), e.exit("tableCellDivider"), b) : k(D);
    }
    function b(D) {
      return Et(D) ? Nt(e, v, "whitespace")(D) : v(D);
    }
    function v(D) {
      return D === 58 ? (i += 1, a = !0, e.enter("tableDelimiterMarker"), e.consume(D), e.exit("tableDelimiterMarker"), x) : D === 45 ? (i += 1, x(D)) : D === null || Xe(D) ? C(D) : k(D);
    }
    function x(D) {
      return D === 45 ? (e.enter("tableDelimiterFiller"), E(D)) : k(D);
    }
    function E(D) {
      return D === 45 ? (e.consume(D), E) : D === 58 ? (a = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(D), e.exit("tableDelimiterMarker"), _) : (e.exit("tableDelimiterFiller"), _(D));
    }
    function _(D) {
      return Et(D) ? Nt(e, C, "whitespace")(D) : C(D);
    }
    function C(D) {
      return D === 124 ? y(D) : D === null || Xe(D) ? !a || o !== i ? k(D) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(D)) : k(D);
    }
    function k(D) {
      return n(D);
    }
    function R(D) {
      return e.enter("tableRow"), A(D);
    }
    function A(D) {
      return D === 124 ? (e.enter("tableCellDivider"), e.consume(D), e.exit("tableCellDivider"), A) : D === null || Xe(D) ? (e.exit("tableRow"), t(D)) : Et(D) ? Nt(e, A, "whitespace")(D) : (e.enter("data"), M(D));
    }
    function M(D) {
      return D === null || D === 124 || on(D) ? (e.exit("data"), A(D)) : (e.consume(D), D === 92 ? I : M);
    }
    function I(D) {
      return D === 92 || D === 124 ? (e.consume(D), M) : M(D);
    }
  }
  function Hke(e, t) {
    let n = -1, r = !0, o = 0, i = [0, 0, 0, 0], a = [0, 0, 0, 0], s = !1, l = 0, u, d, p;
    const h = new Lke();
    for (; ++n < e.length; ) {
      const g = e[n], y = g[1];
      g[0] === "enter" ? y.type === "tableHead" ? (s = !1, l !== 0 && (Jj(h, t, l, u, d), d = void 0, l = 0), u = {
        type: "table",
        start: Object.assign({}, y.start),
        // Note: correct end is set later.
        end: Object.assign({}, y.end)
      }, h.add(n, 0, [["enter", u, t]])) : y.type === "tableRow" || y.type === "tableDelimiterRow" ? (r = !0, p = void 0, i = [0, 0, 0, 0], a = [0, n + 1, 0, 0], s && (s = !1, d = {
        type: "tableBody",
        start: Object.assign({}, y.start),
        // Note: correct end is set later.
        end: Object.assign({}, y.end)
      }, h.add(n, 0, [["enter", d, t]])), o = y.type === "tableDelimiterRow" ? 2 : d ? 3 : 1) : o && (y.type === "data" || y.type === "tableDelimiterMarker" || y.type === "tableDelimiterFiller") ? (r = !1, a[2] === 0 && (i[1] !== 0 && (a[0] = a[1], p = fy(h, t, i, o, void 0, p), i = [0, 0, 0, 0]), a[2] = n)) : y.type === "tableCellDivider" && (r ? r = !1 : (i[1] !== 0 && (a[0] = a[1], p = fy(h, t, i, o, void 0, p)), i = a, a = [i[1], n, 0, 0])) : y.type === "tableHead" ? (s = !0, l = n) : y.type === "tableRow" || y.type === "tableDelimiterRow" ? (l = n, i[1] !== 0 ? (a[0] = a[1], p = fy(h, t, i, o, n, p)) : a[1] !== 0 && (p = fy(h, t, a, o, n, p)), o = 0) : o && (y.type === "data" || y.type === "tableDelimiterMarker" || y.type === "tableDelimiterFiller") && (a[3] = n);
    }
    for (l !== 0 && Jj(h, t, l, u, d), h.consume(t.events), n = -1; ++n < t.events.length; ) {
      const g = t.events[n];
      g[0] === "enter" && g[1].type === "table" && (g[1]._align = Bke(t.events, n));
    }
    return e;
  }
  function fy(e, t, n, r, o, i) {
    const a = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", s = "tableContent";
    n[0] !== 0 && (i.end = Object.assign({}, $u(t.events, n[0])), e.add(n[0], 0, [["exit", i, t]]));
    const l = $u(t.events, n[1]);
    if (i = {
      type: a,
      start: Object.assign({}, l),
      // Note: correct end is set later.
      end: Object.assign({}, l)
    }, e.add(n[1], 0, [["enter", i, t]]), n[2] !== 0) {
      const u = $u(t.events, n[2]), d = $u(t.events, n[3]), p = {
        type: s,
        start: Object.assign({}, u),
        end: Object.assign({}, d)
      };
      if (e.add(n[2], 0, [["enter", p, t]]), r !== 2) {
        const h = t.events[n[2]], g = t.events[n[3]];
        if (h[1].end = Object.assign({}, g[1].end), h[1].type = "chunkText", h[1].contentType = "text", n[3] > n[2] + 1) {
          const y = n[2] + 1, b = n[3] - n[2] - 1;
          e.add(y, b, []);
        }
      }
      e.add(n[3] + 1, 0, [["exit", p, t]]);
    }
    return o !== void 0 && (i.end = Object.assign({}, $u(t.events, o)), e.add(o, 0, [["exit", i, t]]), i = void 0), i;
  }
  function Jj(e, t, n, r, o) {
    const i = [], a = $u(t.events, n);
    o && (o.end = Object.assign({}, a), i.push(["exit", o, t])), r.end = Object.assign({}, a), i.push(["exit", r, t]), e.add(n + 1, 0, i);
  }
  function $u(e, t) {
    const n = e[t], r = n[0] === "enter" ? "start" : "end";
    return n[1][r];
  }
  const qke = {
    name: "tasklistCheck",
    tokenize: Gke
  };
  function Wke() {
    return {
      text: {
        91: qke
      }
    };
  }
  function Gke(e, t, n) {
    const r = this;
    return o;
    function o(l) {
      return (
        // Exit if theres stuff before.
        r.previous !== null || // Exit if not in the first content that is the first child of a list
        // item.
        !r._gfmTasklistFirstContentOfListItem ? n(l) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), i)
      );
    }
    function i(l) {
      return on(l) ? (e.enter("taskListCheckValueUnchecked"), e.consume(l), e.exit("taskListCheckValueUnchecked"), a) : l === 88 || l === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(l), e.exit("taskListCheckValueChecked"), a) : n(l);
    }
    function a(l) {
      return l === 93 ? (e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), s) : n(l);
    }
    function s(l) {
      return Xe(l) ? t(l) : Et(l) ? e.check({
        tokenize: Kke
      }, t, n)(l) : n(l);
    }
  }
  function Kke(e, t, n) {
    return Nt(e, r, "whitespace");
    function r(o) {
      return o === null ? n(o) : t(o);
    }
  }
  function Yke(e) {
    return YU([
      xke(),
      Ake(),
      Fke(e),
      Uke(),
      Wke()
    ]);
  }
  const Xke = {};
  function Zke(e) {
    const t = (
      /** @type {Processor<Root>} */
      this
    ), n = e || Xke, r = t.data(), o = r.micromarkExtensions || (r.micromarkExtensions = []), i = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), a = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
    o.push(Yke(n)), i.push(gke()), a.push(yke(n));
  }
  const SR = ({
    availableModule: e
  }) => {
    const [t, n] = T.useState(!1), r = () => n(!t), o = 150, i = e.description.length > o ? e.description.substring(0, o) + "..." : e.description;
    return /* @__PURE__ */ S.jsxs("div", { className: "module-description", children: [
      /* @__PURE__ */ S.jsx(FEe, { remarkPlugins: [Zke], children: t ? e.description.replace(/\\n/g, `
`) : i.replace(/\\n/g, `
`) }),
      e.description.length > o && /* @__PURE__ */ S.jsx("button", { onClick: r, className: "toggle-description", children: t ? "Show less" : "Show more" })
    ] });
  }, eD = [
    ">=",
    "==",
    "<=",
    "<",
    ">"
  ], s1 = ">=", _R = ({
    availableModule: e,
    on_change: t
  }) => {
    const [n, r] = T.useState(
      e.version || "latest"
    ), [o, i] = T.useState(s1), a = (l) => {
      const u = l.target.value;
      r(u), t(u !== "latest" ? o + u : u);
    }, s = (l) => {
      l.target.value !== o && eD.includes(l.target.value) && (i(l.target.value), n !== "latest" && t(l.target.value + n));
    };
    return e.releases && !e.releases.includes(n) && e.releases.unshift(n), /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      /* @__PURE__ */ S.jsx("select", { value: o, onChange: s, children: eD.map((l) => /* @__PURE__ */ S.jsx("option", { value: l, children: l }, l)) }),
      /* @__PURE__ */ S.jsx("select", { onChange: a, value: n, children: e.releases && e.releases.map((l) => /* @__PURE__ */ S.jsx("option", { value: l, children: l }, l)) })
    ] });
  }, Qke = ({
    availableModule: e,
    on_remove: t,
    on_update: n
  }) => {
    const [r, o] = T.useState(
      s1 + e.version || "latest"
    );
    return /* @__PURE__ */ S.jsxs("div", { className: "addable-module", children: [
      /* @__PURE__ */ S.jsx("div", { className: "module-name", children: e.name + (e.version ? ` (${e.version})` : "") }),
      /* @__PURE__ */ S.jsx(rR, { availableModule: e }),
      /* @__PURE__ */ S.jsx(SR, { availableModule: e }),
      /* @__PURE__ */ S.jsxs("div", { children: [
        /* @__PURE__ */ S.jsx(
          _R,
          {
            availableModule: e,
            on_change: o
          }
        ),
        /* @__PURE__ */ S.jsx(
          "button",
          {
            className: "update-button",
            disabled: r === e.version,
            onClick: () => {
              n(e, r);
            },
            children: "Update"
          }
        ),
        /* @__PURE__ */ S.jsx(
          "button",
          {
            className: "remove-button",
            onClick: () => {
              t(e);
            },
            children: "Remove"
          }
        )
      ] })
    ] });
  }, Jke = ({
    availableModule: e,
    on_add: t
  }) => {
    const [n, r] = T.useState(
      s1 + e.version || "latest"
    );
    return /* @__PURE__ */ S.jsxs("div", { className: "addable-module", children: [
      /* @__PURE__ */ S.jsx("div", { className: "module-name", children: e.name + (e.version ? ` (${e.version})` : "") }),
      /* @__PURE__ */ S.jsx(rR, { availableModule: e }),
      /* @__PURE__ */ S.jsx(SR, { availableModule: e }),
      /* @__PURE__ */ S.jsxs("div", { children: [
        /* @__PURE__ */ S.jsx(
          _R,
          {
            availableModule: e,
            on_change: r
          }
        ),
        /* @__PURE__ */ S.jsx(
          "button",
          {
            className: "add-button",
            onClick: () => {
              t(e, n);
            },
            children: "Add"
          }
        )
      ] })
    ] });
  }, eTe = ({
    availableModule: e,
    on_add: t
  }) => {
    const [n, r] = T.useState(
      s1 + e.version || "latest"
    );
    return /* @__PURE__ */ S.jsxs("div", { className: "addable-module", children: [
      /* @__PURE__ */ S.jsx("div", { className: "module-name", children: e.name }),
      /* @__PURE__ */ S.jsx(rR, { availableModule: e }),
      /* @__PURE__ */ S.jsx(SR, { availableModule: e }),
      /* @__PURE__ */ S.jsxs("div", { children: [
        /* @__PURE__ */ S.jsx(
          _R,
          {
            availableModule: e,
            on_change: r
          }
        ),
        /* @__PURE__ */ S.jsx(
          "button",
          {
            className: "add-button",
            onClick: () => {
              t(e, n);
            },
            children: "Add"
          }
        )
      ] })
    ] });
  };
  function Rt(e) {
    return typeof e != "object" || e === null || typeof e.lastModified == "number" && typeof File < "u" && e instanceof File || typeof e.getMonth == "function" && typeof Date < "u" && e instanceof Date ? !1 : !Array.isArray(e);
  }
  function tTe(e) {
    return e.additionalItems === !0 && console.warn("additionalItems=true is currently not supported"), Rt(e.additionalItems);
  }
  function tD(e) {
    if (e === "")
      return;
    if (e === null)
      return null;
    if (/\.$/.test(e) || /\.0$/.test(e) || /\.\d*0$/.test(e))
      return e;
    const t = Number(e);
    return typeof t == "number" && !Number.isNaN(t) ? t : e;
  }
  const $a = "__additional_property", O0 = "additionalProperties", ol = "allOf", At = "anyOf", Oo = "const", l1 = "default", ER = "dependencies", nTe = "enum", lr = "__errors", nn = "$id", rTe = "if", gf = "items", oTe = "_$junk_option_schema_id$_", Ov = "$name", gt = "oneOf", RC = "patternProperties", It = "properties", h_ = "readonly", LV = "required", A0 = "submitButtonOptions", mn = "$ref", bp = "$schema", zV = "root", BV = "_", iTe = ["discriminator", "propertyName"], nD = "formContext", aTe = "layoutGridLookupMap", CR = "__rjsf_additionalProperties", UV = "__rjsf_rootSchema", sTe = "ui:field", kR = "ui:widget", Gs = "ui:options", OC = "ui:globalOptions", lTe = "https://json-schema.org/draft/2019-09/schema", Av = "https://json-schema.org/draft/2020-12/schema";
  function Ze(e = {}, t = {}) {
    return e ? Object.keys(e).filter((n) => n.indexOf("ui:") === 0).reduce((n, r) => {
      const o = e[r];
      return r === kR && Rt(o) ? (console.error("Setting options via ui:widget object is no longer supported, use ui:options instead"), n) : r === Gs && Rt(o) ? { ...n, ...o } : { ...n, [r.substring(3)]: o };
    }, { ...t }) : { ...t };
  }
  function VV(e, t = {}, n) {
    if (!(e.additionalProperties || e.patternProperties))
      return !1;
    const { expandable: r = !0 } = Ze(t);
    return r === !1 ? r : e.maxProperties !== void 0 && n ? Object.keys(n).length < e.maxProperties : !0;
  }
  var HV = typeof window == "object" && window && window.Object === Object && window, cTe = typeof self == "object" && self && self.Object === Object && self, Ji = HV || cTe || Function("return this")(), Ao = Ji.Symbol, qV = Object.prototype, uTe = qV.hasOwnProperty, fTe = qV.toString, Jd = Ao ? Ao.toStringTag : void 0;
  function dTe(e) {
    var t = uTe.call(e, Jd), n = e[Jd];
    try {
      e[Jd] = void 0;
      var r = !0;
    } catch {
    }
    var o = fTe.call(e);
    return r && (t ? e[Jd] = n : delete e[Jd]), o;
  }
  var pTe = Object.prototype, hTe = pTe.toString;
  function mTe(e) {
    return hTe.call(e);
  }
  var gTe = "[object Null]", yTe = "[object Undefined]", rD = Ao ? Ao.toStringTag : void 0;
  function Ja(e) {
    return e == null ? e === void 0 ? yTe : gTe : rD && rD in Object(e) ? dTe(e) : mTe(e);
  }
  function WV(e, t) {
    return function(n) {
      return e(t(n));
    };
  }
  var c1 = WV(Object.getPrototypeOf, Object);
  function No(e) {
    return e != null && typeof e == "object";
  }
  var vTe = "[object Object]", bTe = Function.prototype, xTe = Object.prototype, GV = bTe.toString, wTe = xTe.hasOwnProperty, STe = GV.call(Object);
  function il(e) {
    if (!No(e) || Ja(e) != vTe)
      return !1;
    var t = c1(e);
    if (t === null)
      return !0;
    var n = wTe.call(t, "constructor") && t.constructor;
    return typeof n == "function" && n instanceof n && GV.call(n) == STe;
  }
  function AC(e) {
    const t = {
      // We store the list of errors for this node in a property named __errors
      // to avoid name collision with a possible sub schema field named
      // 'errors' (see `utils.toErrorSchema`).
      [lr]: [],
      addError(n) {
        this[lr].push(n);
      }
    };
    if (Array.isArray(e))
      return e.reduce((n, r, o) => ({ ...n, [o]: AC(r) }), t);
    if (il(e)) {
      const n = e;
      return Object.keys(n).reduce((r, o) => ({ ...r, [o]: AC(n[o]) }), t);
    }
    return t;
  }
  function _Te() {
    this.__data__ = [], this.size = 0;
  }
  function sm(e, t) {
    return e === t || e !== e && t !== t;
  }
  function u1(e, t) {
    for (var n = e.length; n--; )
      if (sm(e[n][0], t))
        return n;
    return -1;
  }
  var ETe = Array.prototype, CTe = ETe.splice;
  function kTe(e) {
    var t = this.__data__, n = u1(t, e);
    if (n < 0)
      return !1;
    var r = t.length - 1;
    return n == r ? t.pop() : CTe.call(t, n, 1), --this.size, !0;
  }
  function TTe(e) {
    var t = this.__data__, n = u1(t, e);
    return n < 0 ? void 0 : t[n][1];
  }
  function RTe(e) {
    return u1(this.__data__, e) > -1;
  }
  function OTe(e, t) {
    var n = this.__data__, r = u1(n, e);
    return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this;
  }
  function es(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
      var r = e[t];
      this.set(r[0], r[1]);
    }
  }
  es.prototype.clear = _Te;
  es.prototype.delete = kTe;
  es.prototype.get = TTe;
  es.prototype.has = RTe;
  es.prototype.set = OTe;
  function ATe() {
    this.__data__ = new es(), this.size = 0;
  }
  function NTe(e) {
    var t = this.__data__, n = t.delete(e);
    return this.size = t.size, n;
  }
  function MTe(e) {
    return this.__data__.get(e);
  }
  function PTe(e) {
    return this.__data__.has(e);
  }
  function Pt(e) {
    var t = typeof e;
    return e != null && (t == "object" || t == "function");
  }
  var $Te = "[object AsyncFunction]", ITe = "[object Function]", jTe = "[object GeneratorFunction]", DTe = "[object Proxy]";
  function lm(e) {
    if (!Pt(e))
      return !1;
    var t = Ja(e);
    return t == ITe || t == jTe || t == $Te || t == DTe;
  }
  var m_ = Ji["__core-js_shared__"], oD = function() {
    var e = /[^.]+$/.exec(m_ && m_.keys && m_.keys.IE_PROTO || "");
    return e ? "Symbol(src)_1." + e : "";
  }();
  function FTe(e) {
    return !!oD && oD in e;
  }
  var LTe = Function.prototype, zTe = LTe.toString;
  function Sc(e) {
    if (e != null) {
      try {
        return zTe.call(e);
      } catch {
      }
      try {
        return e + "";
      } catch {
      }
    }
    return "";
  }
  var BTe = /[\\^$.*+?()[\]{}|]/g, UTe = /^\[object .+?Constructor\]$/, VTe = Function.prototype, HTe = Object.prototype, qTe = VTe.toString, WTe = HTe.hasOwnProperty, GTe = RegExp(
    "^" + qTe.call(WTe).replace(BTe, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function KTe(e) {
    if (!Pt(e) || FTe(e))
      return !1;
    var t = lm(e) ? GTe : UTe;
    return t.test(Sc(e));
  }
  function YTe(e, t) {
    return e?.[t];
  }
  function _c(e, t) {
    var n = YTe(e, t);
    return KTe(n) ? n : void 0;
  }
  var hh = _c(Ji, "Map"), mh = _c(Object, "create");
  function XTe() {
    this.__data__ = mh ? mh(null) : {}, this.size = 0;
  }
  function ZTe(e) {
    var t = this.has(e) && delete this.__data__[e];
    return this.size -= t ? 1 : 0, t;
  }
  var QTe = "__lodash_hash_undefined__", JTe = Object.prototype, eRe = JTe.hasOwnProperty;
  function tRe(e) {
    var t = this.__data__;
    if (mh) {
      var n = t[e];
      return n === QTe ? void 0 : n;
    }
    return eRe.call(t, e) ? t[e] : void 0;
  }
  var nRe = Object.prototype, rRe = nRe.hasOwnProperty;
  function oRe(e) {
    var t = this.__data__;
    return mh ? t[e] !== void 0 : rRe.call(t, e);
  }
  var iRe = "__lodash_hash_undefined__";
  function aRe(e, t) {
    var n = this.__data__;
    return this.size += this.has(e) ? 0 : 1, n[e] = mh && t === void 0 ? iRe : t, this;
  }
  function dc(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
      var r = e[t];
      this.set(r[0], r[1]);
    }
  }
  dc.prototype.clear = XTe;
  dc.prototype.delete = ZTe;
  dc.prototype.get = tRe;
  dc.prototype.has = oRe;
  dc.prototype.set = aRe;
  function sRe() {
    this.size = 0, this.__data__ = {
      hash: new dc(),
      map: new (hh || es)(),
      string: new dc()
    };
  }
  function lRe(e) {
    var t = typeof e;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
  }
  function f1(e, t) {
    var n = e.__data__;
    return lRe(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
  }
  function cRe(e) {
    var t = f1(this, e).delete(e);
    return this.size -= t ? 1 : 0, t;
  }
  function uRe(e) {
    return f1(this, e).get(e);
  }
  function fRe(e) {
    return f1(this, e).has(e);
  }
  function dRe(e, t) {
    var n = f1(this, e), r = n.size;
    return n.set(e, t), this.size += n.size == r ? 0 : 1, this;
  }
  function ts(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
      var r = e[t];
      this.set(r[0], r[1]);
    }
  }
  ts.prototype.clear = sRe;
  ts.prototype.delete = cRe;
  ts.prototype.get = uRe;
  ts.prototype.has = fRe;
  ts.prototype.set = dRe;
  var pRe = 200;
  function hRe(e, t) {
    var n = this.__data__;
    if (n instanceof es) {
      var r = n.__data__;
      if (!hh || r.length < pRe - 1)
        return r.push([e, t]), this.size = ++n.size, this;
      n = this.__data__ = new ts(r);
    }
    return n.set(e, t), this.size = n.size, this;
  }
  function Go(e) {
    var t = this.__data__ = new es(e);
    this.size = t.size;
  }
  Go.prototype.clear = ATe;
  Go.prototype.delete = NTe;
  Go.prototype.get = MTe;
  Go.prototype.has = PTe;
  Go.prototype.set = hRe;
  var mRe = "__lodash_hash_undefined__";
  function gRe(e) {
    return this.__data__.set(e, mRe), this;
  }
  function yRe(e) {
    return this.__data__.has(e);
  }
  function pc(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.__data__ = new ts(); ++t < n; )
      this.add(e[t]);
  }
  pc.prototype.add = pc.prototype.push = gRe;
  pc.prototype.has = yRe;
  function vRe(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length; ++n < r; )
      if (t(e[n], n, e))
        return !0;
    return !1;
  }
  function gh(e, t) {
    return e.has(t);
  }
  var bRe = 1, xRe = 2;
  function KV(e, t, n, r, o, i) {
    var a = n & bRe, s = e.length, l = t.length;
    if (s != l && !(a && l > s))
      return !1;
    var u = i.get(e), d = i.get(t);
    if (u && d)
      return u == t && d == e;
    var p = -1, h = !0, g = n & xRe ? new pc() : void 0;
    for (i.set(e, t), i.set(t, e); ++p < s; ) {
      var y = e[p], b = t[p];
      if (r)
        var v = a ? r(b, y, p, t, e, i) : r(y, b, p, e, t, i);
      if (v !== void 0) {
        if (v)
          continue;
        h = !1;
        break;
      }
      if (g) {
        if (!vRe(t, function(x, E) {
          if (!gh(g, E) && (y === x || o(y, x, n, r, i)))
            return g.push(E);
        })) {
          h = !1;
          break;
        }
      } else if (!(y === b || o(y, b, n, r, i))) {
        h = !1;
        break;
      }
    }
    return i.delete(e), i.delete(t), h;
  }
  var N0 = Ji.Uint8Array;
  function wRe(e) {
    var t = -1, n = Array(e.size);
    return e.forEach(function(r, o) {
      n[++t] = [o, r];
    }), n;
  }
  function TR(e) {
    var t = -1, n = Array(e.size);
    return e.forEach(function(r) {
      n[++t] = r;
    }), n;
  }
  var SRe = 1, _Re = 2, ERe = "[object Boolean]", CRe = "[object Date]", kRe = "[object Error]", TRe = "[object Map]", RRe = "[object Number]", ORe = "[object RegExp]", ARe = "[object Set]", NRe = "[object String]", MRe = "[object Symbol]", PRe = "[object ArrayBuffer]", $Re = "[object DataView]", iD = Ao ? Ao.prototype : void 0, g_ = iD ? iD.valueOf : void 0;
  function IRe(e, t, n, r, o, i, a) {
    switch (n) {
      case $Re:
        if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
          return !1;
        e = e.buffer, t = t.buffer;
      case PRe:
        return !(e.byteLength != t.byteLength || !i(new N0(e), new N0(t)));
      case ERe:
      case CRe:
      case RRe:
        return sm(+e, +t);
      case kRe:
        return e.name == t.name && e.message == t.message;
      case ORe:
      case NRe:
        return e == t + "";
      case TRe:
        var s = wRe;
      case ARe:
        var l = r & SRe;
        if (s || (s = TR), e.size != t.size && !l)
          return !1;
        var u = a.get(e);
        if (u)
          return u == t;
        r |= _Re, a.set(e, t);
        var d = KV(s(e), s(t), r, o, i, a);
        return a.delete(e), d;
      case MRe:
        if (g_)
          return g_.call(e) == g_.call(t);
    }
    return !1;
  }
  function RR(e, t) {
    for (var n = -1, r = t.length, o = e.length; ++n < r; )
      e[o + n] = t[n];
    return e;
  }
  var Kn = Array.isArray;
  function YV(e, t, n) {
    var r = t(e);
    return Kn(e) ? r : RR(r, n(e));
  }
  function jRe(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length, o = 0, i = []; ++n < r; ) {
      var a = e[n];
      t(a, n, e) && (i[o++] = a);
    }
    return i;
  }
  function XV() {
    return [];
  }
  var DRe = Object.prototype, FRe = DRe.propertyIsEnumerable, aD = Object.getOwnPropertySymbols, OR = aD ? function(e) {
    return e == null ? [] : (e = Object(e), jRe(aD(e), function(t) {
      return FRe.call(e, t);
    }));
  } : XV;
  function ZV(e, t) {
    for (var n = -1, r = Array(e); ++n < e; )
      r[n] = t(n);
    return r;
  }
  var LRe = "[object Arguments]";
  function sD(e) {
    return No(e) && Ja(e) == LRe;
  }
  var QV = Object.prototype, zRe = QV.hasOwnProperty, BRe = QV.propertyIsEnumerable, yf = sD(/* @__PURE__ */ function() {
    return arguments;
  }()) ? sD : function(e) {
    return No(e) && zRe.call(e, "callee") && !BRe.call(e, "callee");
  };
  function URe() {
    return !1;
  }
  var JV = typeof ro == "object" && ro && !ro.nodeType && ro, lD = JV && typeof oo == "object" && oo && !oo.nodeType && oo, VRe = lD && lD.exports === JV, cD = VRe ? Ji.Buffer : void 0, HRe = cD ? cD.isBuffer : void 0, hc = HRe || URe, qRe = 9007199254740991, WRe = /^(?:0|[1-9]\d*)$/;
  function d1(e, t) {
    var n = typeof e;
    return t = t ?? qRe, !!t && (n == "number" || n != "symbol" && WRe.test(e)) && e > -1 && e % 1 == 0 && e < t;
  }
  var GRe = 9007199254740991;
  function AR(e) {
    return typeof e == "number" && e > -1 && e % 1 == 0 && e <= GRe;
  }
  var KRe = "[object Arguments]", YRe = "[object Array]", XRe = "[object Boolean]", ZRe = "[object Date]", QRe = "[object Error]", JRe = "[object Function]", eOe = "[object Map]", tOe = "[object Number]", nOe = "[object Object]", rOe = "[object RegExp]", oOe = "[object Set]", iOe = "[object String]", aOe = "[object WeakMap]", sOe = "[object ArrayBuffer]", lOe = "[object DataView]", cOe = "[object Float32Array]", uOe = "[object Float64Array]", fOe = "[object Int8Array]", dOe = "[object Int16Array]", pOe = "[object Int32Array]", hOe = "[object Uint8Array]", mOe = "[object Uint8ClampedArray]", gOe = "[object Uint16Array]", yOe = "[object Uint32Array]", pn = {};
  pn[cOe] = pn[uOe] = pn[fOe] = pn[dOe] = pn[pOe] = pn[hOe] = pn[mOe] = pn[gOe] = pn[yOe] = !0;
  pn[KRe] = pn[YRe] = pn[sOe] = pn[XRe] = pn[lOe] = pn[ZRe] = pn[QRe] = pn[JRe] = pn[eOe] = pn[tOe] = pn[nOe] = pn[rOe] = pn[oOe] = pn[iOe] = pn[aOe] = !1;
  function vOe(e) {
    return No(e) && AR(e.length) && !!pn[Ja(e)];
  }
  function NR(e) {
    return function(t) {
      return e(t);
    };
  }
  var eH = typeof ro == "object" && ro && !ro.nodeType && ro, Ip = eH && typeof oo == "object" && oo && !oo.nodeType && oo, bOe = Ip && Ip.exports === eH, y_ = bOe && HV.process, vf = function() {
    try {
      var e = Ip && Ip.require && Ip.require("util").types;
      return e || y_ && y_.binding && y_.binding("util");
    } catch {
    }
  }(), uD = vf && vf.isTypedArray, cm = uD ? NR(uD) : vOe, xOe = Object.prototype, wOe = xOe.hasOwnProperty;
  function tH(e, t) {
    var n = Kn(e), r = !n && yf(e), o = !n && !r && hc(e), i = !n && !r && !o && cm(e), a = n || r || o || i, s = a ? ZV(e.length, String) : [], l = s.length;
    for (var u in e)
      (t || wOe.call(e, u)) && !(a && // Safari 9 has enumerable `arguments.length` in strict mode.
      (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      o && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      i && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
      d1(u, l))) && s.push(u);
    return s;
  }
  var SOe = Object.prototype;
  function p1(e) {
    var t = e && e.constructor, n = typeof t == "function" && t.prototype || SOe;
    return e === n;
  }
  var _Oe = WV(Object.keys, Object), EOe = Object.prototype, COe = EOe.hasOwnProperty;
  function nH(e) {
    if (!p1(e))
      return _Oe(e);
    var t = [];
    for (var n in Object(e))
      COe.call(e, n) && n != "constructor" && t.push(n);
    return t;
  }
  function Ec(e) {
    return e != null && AR(e.length) && !lm(e);
  }
  function Vo(e) {
    return Ec(e) ? tH(e) : nH(e);
  }
  function NC(e) {
    return YV(e, Vo, OR);
  }
  var kOe = 1, TOe = Object.prototype, ROe = TOe.hasOwnProperty;
  function OOe(e, t, n, r, o, i) {
    var a = n & kOe, s = NC(e), l = s.length, u = NC(t), d = u.length;
    if (l != d && !a)
      return !1;
    for (var p = l; p--; ) {
      var h = s[p];
      if (!(a ? h in t : ROe.call(t, h)))
        return !1;
    }
    var g = i.get(e), y = i.get(t);
    if (g && y)
      return g == t && y == e;
    var b = !0;
    i.set(e, t), i.set(t, e);
    for (var v = a; ++p < l; ) {
      h = s[p];
      var x = e[h], E = t[h];
      if (r)
        var _ = a ? r(E, x, h, t, e, i) : r(x, E, h, e, t, i);
      if (!(_ === void 0 ? x === E || o(x, E, n, r, i) : _)) {
        b = !1;
        break;
      }
      v || (v = h == "constructor");
    }
    if (b && !v) {
      var C = e.constructor, k = t.constructor;
      C != k && "constructor" in e && "constructor" in t && !(typeof C == "function" && C instanceof C && typeof k == "function" && k instanceof k) && (b = !1);
    }
    return i.delete(e), i.delete(t), b;
  }
  var MC = _c(Ji, "DataView"), PC = _c(Ji, "Promise"), Ju = _c(Ji, "Set"), $C = _c(Ji, "WeakMap"), fD = "[object Map]", AOe = "[object Object]", dD = "[object Promise]", pD = "[object Set]", hD = "[object WeakMap]", mD = "[object DataView]", NOe = Sc(MC), MOe = Sc(hh), POe = Sc(PC), $Oe = Sc(Ju), IOe = Sc($C), Co = Ja;
  (MC && Co(new MC(new ArrayBuffer(1))) != mD || hh && Co(new hh()) != fD || PC && Co(PC.resolve()) != dD || Ju && Co(new Ju()) != pD || $C && Co(new $C()) != hD) && (Co = function(e) {
    var t = Ja(e), n = t == AOe ? e.constructor : void 0, r = n ? Sc(n) : "";
    if (r)
      switch (r) {
        case NOe:
          return mD;
        case MOe:
          return fD;
        case POe:
          return dD;
        case $Oe:
          return pD;
        case IOe:
          return hD;
      }
    return t;
  });
  var jOe = 1, gD = "[object Arguments]", yD = "[object Array]", dy = "[object Object]", DOe = Object.prototype, vD = DOe.hasOwnProperty;
  function FOe(e, t, n, r, o, i) {
    var a = Kn(e), s = Kn(t), l = a ? yD : Co(e), u = s ? yD : Co(t);
    l = l == gD ? dy : l, u = u == gD ? dy : u;
    var d = l == dy, p = u == dy, h = l == u;
    if (h && hc(e)) {
      if (!hc(t))
        return !1;
      a = !0, d = !1;
    }
    if (h && !d)
      return i || (i = new Go()), a || cm(e) ? KV(e, t, n, r, o, i) : IRe(e, t, l, n, r, o, i);
    if (!(n & jOe)) {
      var g = d && vD.call(e, "__wrapped__"), y = p && vD.call(t, "__wrapped__");
      if (g || y) {
        var b = g ? e.value() : e, v = y ? t.value() : t;
        return i || (i = new Go()), o(b, v, n, r, i);
      }
    }
    return h ? (i || (i = new Go()), OOe(e, t, n, r, o, i)) : !1;
  }
  function um(e, t, n, r, o) {
    return e === t ? !0 : e == null || t == null || !No(e) && !No(t) ? e !== e && t !== t : FOe(e, t, n, r, um, o);
  }
  function LOe(e, t, n) {
    n = typeof n == "function" ? n : void 0;
    var r = n ? n(e, t) : void 0;
    return r === void 0 ? um(e, t, void 0, n) : !!r;
  }
  function fn(e, t) {
    return LOe(e, t, (n, r) => {
      if (typeof n == "function" && typeof r == "function")
        return !0;
    });
  }
  var zOe = "[object Symbol]";
  function fm(e) {
    return typeof e == "symbol" || No(e) && Ja(e) == zOe;
  }
  var BOe = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, UOe = /^\w*$/;
  function MR(e, t) {
    if (Kn(e))
      return !1;
    var n = typeof e;
    return n == "number" || n == "symbol" || n == "boolean" || e == null || fm(e) ? !0 : UOe.test(e) || !BOe.test(e) || t != null && e in Object(t);
  }
  var VOe = "Expected a function";
  function PR(e, t) {
    if (typeof e != "function" || t != null && typeof t != "function")
      throw new TypeError(VOe);
    var n = function() {
      var r = arguments, o = t ? t.apply(this, r) : r[0], i = n.cache;
      if (i.has(o))
        return i.get(o);
      var a = e.apply(this, r);
      return n.cache = i.set(o, a) || i, a;
    };
    return n.cache = new (PR.Cache || ts)(), n;
  }
  PR.Cache = ts;
  var HOe = 500;
  function qOe(e) {
    var t = PR(e, function(r) {
      return n.size === HOe && n.clear(), r;
    }), n = t.cache;
    return t;
  }
  var WOe = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, GOe = /\\(\\)?/g, rH = qOe(function(e) {
    var t = [];
    return e.charCodeAt(0) === 46 && t.push(""), e.replace(WOe, function(n, r, o, i) {
      t.push(o ? i.replace(GOe, "$1") : r || n);
    }), t;
  });
  function If(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length, o = Array(r); ++n < r; )
      o[n] = t(e[n], n, e);
    return o;
  }
  var bD = Ao ? Ao.prototype : void 0, xD = bD ? bD.toString : void 0;
  function oH(e) {
    if (typeof e == "string")
      return e;
    if (Kn(e))
      return If(e, oH) + "";
    if (fm(e))
      return xD ? xD.call(e) : "";
    var t = e + "";
    return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
  }
  function $R(e) {
    return e == null ? "" : oH(e);
  }
  function jf(e, t) {
    return Kn(e) ? e : MR(e, t) ? [e] : rH($R(e));
  }
  function Cc(e) {
    if (typeof e == "string" || fm(e))
      return e;
    var t = e + "";
    return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
  }
  function h1(e, t) {
    t = jf(t, e);
    for (var n = 0, r = t.length; e != null && n < r; )
      e = e[Cc(t[n++])];
    return n && n == r ? e : void 0;
  }
  function Ee(e, t, n) {
    var r = e == null ? void 0 : h1(e, t);
    return r === void 0 ? n : r;
  }
  var KOe = Object.prototype, YOe = KOe.hasOwnProperty;
  function XOe(e, t) {
    return e != null && YOe.call(e, t);
  }
  function iH(e, t, n) {
    t = jf(t, e);
    for (var r = -1, o = t.length, i = !1; ++r < o; ) {
      var a = Cc(t[r]);
      if (!(i = e != null && n(e, a)))
        break;
      e = e[a];
    }
    return i || ++r != o ? i : (o = e == null ? 0 : e.length, !!o && AR(o) && d1(a, o) && (Kn(e) || yf(e)));
  }
  function kt(e, t) {
    return e != null && iH(e, t, XOe);
  }
  function yh(e, t) {
    return um(e, t);
  }
  var M0 = function() {
    try {
      var e = _c(Object, "defineProperty");
      return e({}, "", {}), e;
    } catch {
    }
  }();
  function IR(e, t, n) {
    t == "__proto__" && M0 ? M0(e, t, {
      configurable: !0,
      enumerable: !0,
      value: n,
      writable: !0
    }) : e[t] = n;
  }
  var ZOe = Object.prototype, QOe = ZOe.hasOwnProperty;
  function jR(e, t, n) {
    var r = e[t];
    (!(QOe.call(e, t) && sm(r, n)) || n === void 0 && !(t in e)) && IR(e, t, n);
  }
  function DR(e, t, n, r) {
    if (!Pt(e))
      return e;
    t = jf(t, e);
    for (var o = -1, i = t.length, a = i - 1, s = e; s != null && ++o < i; ) {
      var l = Cc(t[o]), u = n;
      if (l === "__proto__" || l === "constructor" || l === "prototype")
        return e;
      if (o != a) {
        var d = s[l];
        u = r ? r(d, l, s) : void 0, u === void 0 && (u = Pt(d) ? d : d1(t[o + 1]) ? [] : {});
      }
      jR(s, l, u), s = s[l];
    }
    return e;
  }
  function Xt(e, t, n) {
    return e == null ? e : DR(e, t, n);
  }
  function m1(e) {
    return e;
  }
  function aH(e) {
    return typeof e == "function" ? e : m1;
  }
  var JOe = /\s/;
  function eAe(e) {
    for (var t = e.length; t-- && JOe.test(e.charAt(t)); )
      ;
    return t;
  }
  var tAe = /^\s+/;
  function nAe(e) {
    return e && e.slice(0, eAe(e) + 1).replace(tAe, "");
  }
  var wD = NaN, rAe = /^[-+]0x[0-9a-f]+$/i, oAe = /^0b[01]+$/i, iAe = /^0o[0-7]+$/i, aAe = parseInt;
  function sAe(e) {
    if (typeof e == "number")
      return e;
    if (fm(e))
      return wD;
    if (Pt(e)) {
      var t = typeof e.valueOf == "function" ? e.valueOf() : e;
      e = Pt(t) ? t + "" : t;
    }
    if (typeof e != "string")
      return e === 0 ? e : +e;
    e = nAe(e);
    var n = oAe.test(e);
    return n || iAe.test(e) ? aAe(e.slice(2), n ? 2 : 8) : rAe.test(e) ? wD : +e;
  }
  var SD = 1 / 0, lAe = 17976931348623157e292;
  function cAe(e) {
    if (!e)
      return e === 0 ? e : 0;
    if (e = sAe(e), e === SD || e === -SD) {
      var t = e < 0 ? -1 : 1;
      return t * lAe;
    }
    return e === e ? e : 0;
  }
  function sH(e) {
    var t = cAe(e), n = t % 1;
    return t === t ? n ? t - n : t : 0;
  }
  var uAe = 9007199254740991, v_ = 4294967295, fAe = Math.min;
  function lH(e, t) {
    if (e = sH(e), e < 1 || e > uAe)
      return [];
    var n = v_, r = fAe(e, v_);
    t = aH(t), e -= v_;
    for (var o = ZV(r, t); ++n < e; )
      t(n);
    return o;
  }
  function FR(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length; ++n < r && t(e[n], n, e) !== !1; )
      ;
    return e;
  }
  var _D = Object.create, cH = /* @__PURE__ */ function() {
    function e() {
    }
    return function(t) {
      if (!Pt(t))
        return {};
      if (_D)
        return _D(t);
      e.prototype = t;
      var n = new e();
      return e.prototype = void 0, n;
    };
  }();
  function dAe(e) {
    return function(t, n, r) {
      for (var o = -1, i = Object(t), a = r(t), s = a.length; s--; ) {
        var l = a[++o];
        if (n(i[l], l, i) === !1)
          break;
      }
      return t;
    };
  }
  var uH = dAe();
  function fH(e, t) {
    return e && uH(e, t, Vo);
  }
  var pAe = 1, hAe = 2;
  function mAe(e, t, n, r) {
    var o = n.length, i = o;
    if (e == null)
      return !i;
    for (e = Object(e); o--; ) {
      var a = n[o];
      if (a[2] ? a[1] !== e[a[0]] : !(a[0] in e))
        return !1;
    }
    for (; ++o < i; ) {
      a = n[o];
      var s = a[0], l = e[s], u = a[1];
      if (a[2]) {
        if (l === void 0 && !(s in e))
          return !1;
      } else {
        var d = new Go(), p;
        if (!(p === void 0 ? um(u, l, pAe | hAe, r, d) : p))
          return !1;
      }
    }
    return !0;
  }
  function dH(e) {
    return e === e && !Pt(e);
  }
  function gAe(e) {
    for (var t = Vo(e), n = t.length; n--; ) {
      var r = t[n], o = e[r];
      t[n] = [r, o, dH(o)];
    }
    return t;
  }
  function pH(e, t) {
    return function(n) {
      return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));
    };
  }
  function yAe(e) {
    var t = gAe(e);
    return t.length == 1 && t[0][2] ? pH(t[0][0], t[0][1]) : function(n) {
      return n === e || mAe(n, e, t);
    };
  }
  function vAe(e, t) {
    return e != null && t in Object(e);
  }
  function hH(e, t) {
    return e != null && iH(e, t, vAe);
  }
  var bAe = 1, xAe = 2;
  function wAe(e, t) {
    return MR(e) && dH(t) ? pH(Cc(e), t) : function(n) {
      var r = Ee(n, e);
      return r === void 0 && r === t ? hH(n, e) : um(t, r, bAe | xAe);
    };
  }
  function SAe(e) {
    return function(t) {
      return t?.[e];
    };
  }
  function _Ae(e) {
    return function(t) {
      return h1(t, e);
    };
  }
  function EAe(e) {
    return MR(e) ? SAe(Cc(e)) : _Ae(e);
  }
  function LR(e) {
    return typeof e == "function" ? e : e == null ? m1 : typeof e == "object" ? Kn(e) ? wAe(e[0], e[1]) : yAe(e) : EAe(e);
  }
  function CAe(e, t, n) {
    var r = Kn(e), o = r || hc(e) || cm(e);
    if (t = LR(t), n == null) {
      var i = e && e.constructor;
      o ? n = r ? new i() : [] : Pt(e) ? n = lm(i) ? cH(c1(e)) : {} : n = {};
    }
    return (o ? FR : fH)(e, function(a, s, l) {
      return t(n, a, s, l);
    }), n;
  }
  function IC(e, t, n) {
    (n !== void 0 && !sm(e[t], n) || n === void 0 && !(t in e)) && IR(e, t, n);
  }
  var mH = typeof ro == "object" && ro && !ro.nodeType && ro, ED = mH && typeof oo == "object" && oo && !oo.nodeType && oo, kAe = ED && ED.exports === mH, CD = kAe ? Ji.Buffer : void 0, kD = CD ? CD.allocUnsafe : void 0;
  function gH(e, t) {
    if (t)
      return e.slice();
    var n = e.length, r = kD ? kD(n) : new e.constructor(n);
    return e.copy(r), r;
  }
  function zR(e) {
    var t = new e.constructor(e.byteLength);
    return new N0(t).set(new N0(e)), t;
  }
  function yH(e, t) {
    var n = t ? zR(e.buffer) : e.buffer;
    return new e.constructor(n, e.byteOffset, e.length);
  }
  function BR(e, t) {
    var n = -1, r = e.length;
    for (t || (t = Array(r)); ++n < r; )
      t[n] = e[n];
    return t;
  }
  function vH(e) {
    return typeof e.constructor == "function" && !p1(e) ? cH(c1(e)) : {};
  }
  function vh(e) {
    return No(e) && Ec(e);
  }
  function jC(e, t) {
    if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
      return e[t];
  }
  function Df(e, t, n, r) {
    var o = !n;
    n || (n = {});
    for (var i = -1, a = t.length; ++i < a; ) {
      var s = t[i], l = void 0;
      l === void 0 && (l = e[s]), o ? IR(n, s, l) : jR(n, s, l);
    }
    return n;
  }
  function TAe(e) {
    var t = [];
    if (e != null)
      for (var n in Object(e))
        t.push(n);
    return t;
  }
  var RAe = Object.prototype, OAe = RAe.hasOwnProperty;
  function AAe(e) {
    if (!Pt(e))
      return TAe(e);
    var t = p1(e), n = [];
    for (var r in e)
      r == "constructor" && (t || !OAe.call(e, r)) || n.push(r);
    return n;
  }
  function dm(e) {
    return Ec(e) ? tH(e, !0) : AAe(e);
  }
  function NAe(e) {
    return Df(e, dm(e));
  }
  function MAe(e, t, n, r, o, i, a) {
    var s = jC(e, n), l = jC(t, n), u = a.get(l);
    if (u) {
      IC(e, n, u);
      return;
    }
    var d = i ? i(s, l, n + "", e, t, a) : void 0, p = d === void 0;
    if (p) {
      var h = Kn(l), g = !h && hc(l), y = !h && !g && cm(l);
      d = l, h || g || y ? Kn(s) ? d = s : vh(s) ? d = BR(s) : g ? (p = !1, d = gH(l, !0)) : y ? (p = !1, d = yH(l, !0)) : d = [] : il(l) || yf(l) ? (d = s, yf(s) ? d = NAe(s) : (!Pt(s) || lm(s)) && (d = vH(l))) : p = !1;
    }
    p && (a.set(l, d), o(d, l, r, i, a), a.delete(l)), IC(e, n, d);
  }
  function bH(e, t, n, r, o) {
    e !== t && uH(t, function(i, a) {
      if (o || (o = new Go()), Pt(i))
        MAe(e, t, a, n, bH, r, o);
      else {
        var s = r ? r(jC(e, a), i, a + "", e, t, o) : void 0;
        s === void 0 && (s = i), IC(e, a, s);
      }
    }, dm);
  }
  function PAe(e, t, n) {
    switch (n.length) {
      case 0:
        return e.call(t);
      case 1:
        return e.call(t, n[0]);
      case 2:
        return e.call(t, n[0], n[1]);
      case 3:
        return e.call(t, n[0], n[1], n[2]);
    }
    return e.apply(t, n);
  }
  var TD = Math.max;
  function xH(e, t, n) {
    return t = TD(t === void 0 ? e.length - 1 : t, 0), function() {
      for (var r = arguments, o = -1, i = TD(r.length - t, 0), a = Array(i); ++o < i; )
        a[o] = r[t + o];
      o = -1;
      for (var s = Array(t + 1); ++o < t; )
        s[o] = r[o];
      return s[t] = n(a), PAe(e, this, s);
    };
  }
  function $Ae(e) {
    return function() {
      return e;
    };
  }
  var IAe = M0 ? function(e, t) {
    return M0(e, "toString", {
      configurable: !0,
      enumerable: !1,
      value: $Ae(t),
      writable: !0
    });
  } : m1, jAe = 800, DAe = 16, FAe = Date.now;
  function LAe(e) {
    var t = 0, n = 0;
    return function() {
      var r = FAe(), o = DAe - (r - n);
      if (n = r, o > 0) {
        if (++t >= jAe)
          return arguments[0];
      } else
        t = 0;
      return e.apply(void 0, arguments);
    };
  }
  var wH = LAe(IAe);
  function g1(e, t) {
    return wH(xH(e, t, m1), e + "");
  }
  function zAe(e, t, n) {
    if (!Pt(n))
      return !1;
    var r = typeof t;
    return (r == "number" ? Ec(n) && d1(t, n.length) : r == "string" && t in n) ? sm(n[t], e) : !1;
  }
  function BAe(e) {
    return g1(function(t, n) {
      var r = -1, o = n.length, i = o > 1 ? n[o - 1] : void 0, a = o > 2 ? n[2] : void 0;
      for (i = e.length > 3 && typeof i == "function" ? (o--, i) : void 0, a && zAe(n[0], n[1], a) && (i = o < 3 ? void 0 : i, o = 1), t = Object(t); ++r < o; ) {
        var s = n[r];
        s && e(t, s, r, i);
      }
      return t;
    });
  }
  var UAe = BAe(function(e, t, n) {
    bH(e, t, n);
  }), RD = Ao ? Ao.isConcatSpreadable : void 0;
  function VAe(e) {
    return Kn(e) || yf(e) || !!(RD && e && e[RD]);
  }
  function pm(e, t, n, r, o) {
    var i = -1, a = e.length;
    for (n || (n = VAe), o || (o = []); ++i < a; ) {
      var s = e[i];
      t > 0 && n(s) ? t > 1 ? pm(s, t - 1, n, r, o) : RR(o, s) : r || (o[o.length] = s);
    }
    return o;
  }
  var HAe = 1 / 0;
  function qAe(e) {
    var t = e == null ? 0 : e.length;
    return t ? pm(e, HAe) : [];
  }
  function WAe(e, t, n, r) {
    for (var o = e.length, i = n + -1; ++i < o; )
      if (t(e[i], i, e))
        return i;
    return -1;
  }
  function GAe(e) {
    return e !== e;
  }
  function KAe(e, t, n) {
    for (var r = n - 1, o = e.length; ++r < o; )
      if (e[r] === t)
        return r;
    return -1;
  }
  function SH(e, t, n) {
    return t === t ? KAe(e, t, n) : WAe(e, GAe, n);
  }
  function UR(e, t) {
    var n = e == null ? 0 : e.length;
    return !!n && SH(e, t, 0) > -1;
  }
  function Nv() {
  }
  var YAe = 1 / 0, XAe = Ju && 1 / TR(new Ju([, -0]))[1] == YAe ? function(e) {
    return new Ju(e);
  } : Nv, ZAe = 200;
  function _H(e, t, n) {
    var r = -1, o = UR, i = e.length, a = !0, s = [], l = s;
    if (i >= ZAe) {
      var u = XAe(e);
      if (u)
        return TR(u);
      a = !1, o = gh, l = new pc();
    } else
      l = s;
    e:
      for (; ++r < i; ) {
        var d = e[r], p = d;
        if (d = d !== 0 ? d : 0, a && p === p) {
          for (var h = l.length; h--; )
            if (l[h] === p)
              continue e;
          s.push(d);
        } else o(l, p, n) || (l !== s && l.push(p), s.push(d));
      }
    return s;
  }
  function EH(e) {
    return e && e.length ? _H(e) : [];
  }
  var QAe = "[object Map]", JAe = "[object Set]", eNe = Object.prototype, tNe = eNe.hasOwnProperty;
  function Un(e) {
    if (e == null)
      return !0;
    if (Ec(e) && (Kn(e) || typeof e == "string" || typeof e.splice == "function" || hc(e) || cm(e) || yf(e)))
      return !e.length;
    var t = Co(e);
    if (t == QAe || t == JAe)
      return !e.size;
    if (p1(e))
      return !nH(e).length;
    for (var n in e)
      if (tNe.call(e, n))
        return !1;
    return !0;
  }
  const nNe = Object.prototype;
  function xp(e) {
    for (const t in e)
      if (nNe.hasOwnProperty.call(e, t))
        return !1;
    return !0;
  }
  const rNe = [
    "array",
    "boolean",
    "integer",
    "null",
    "number",
    "object",
    "string"
  ];
  new Set(rNe);
  const oNe = [
    "$defs",
    "definitions",
    "properties",
    "patternProperties",
    "dependencies"
  ];
  new Set(oNe);
  const iNe = [
    "items",
    "allOf",
    "oneOf",
    "anyOf"
  ];
  new Set(iNe);
  const aNe = [
    "items",
    "additionalItems",
    "additionalProperties",
    "propertyNames",
    "contains",
    "if",
    "then",
    "else",
    "not"
  ];
  new Set(aNe);
  function Mv(e) {
    return typeof e == "object";
  }
  function xi(e) {
    return Mv(e) ? xp(e) : e === !0;
  }
  function zu(e, t) {
    return e < t ? -1 : e > t ? 1 : 0;
  }
  function b_(e, t) {
    const n = e.length;
    if (n === 0)
      return t;
    let r = t.length;
    if (r === 0)
      return e;
    if (n < r) {
      const i = e;
      e = t, t = i, r = n;
    }
    const o = new Set(e);
    for (let i = 0; i < r; i++)
      o.add(t[i]);
    return Array.from(o);
  }
  function sNe(e, t) {
    const n = [];
    if (e.length === 0 || t.length === 0)
      return n;
    if (e.length > t.length) {
      const o = e;
      e = t, t = o;
    }
    const r = new Set(t);
    for (let o = 0; o < e.length && r.size > 0; o++) {
      const i = e[o];
      r.delete(i) && n.push(i);
    }
    return n;
  }
  function OD(e) {
    return e.length === 0;
  }
  function x_(e) {
    return (t, n) => {
      const r = t.length - n.length;
      if (r !== 0)
        return r;
      for (let o = 0; o < t.length; o++)
        if (t[o] !== n[o]) {
          const i = e(t[o], n[o]);
          if (i !== 0)
            return i;
        }
      return 0;
    };
  }
  function CH(e, { threshold: t = 12 } = {}) {
    return (n) => {
      const r = n.length;
      if (r === 0)
        return n;
      if (r <= t) {
        const a = [];
        let s = 0;
        e: for (let l = 0; l < r; l++) {
          const u = n[l];
          for (let d = 0; d < s; d++)
            if (e(u, a[d]) === 0)
              continue e;
          s = a.push(u);
        }
        return a;
      }
      const o = n.slice().sort(e);
      let i = 0;
      for (let a = 1; a < r; a++)
        e(o[i], o[a]) !== 0 && ++i !== a && (o[i] = o[a]);
      return o.length = i + 1, o;
    };
  }
  function lNe(e) {
    return (t, n) => {
      const r = [];
      let o = t.length, i = n.length;
      if (o === 0 || i === 0)
        return r;
      if (o > i) {
        const d = t;
        t = n, n = d;
        const p = o;
        o = i, i = p;
      }
      const a = [...t].sort(e), s = [...n].sort(e);
      let l = 0, u = 0;
      for (; l < o && u < i; ) {
        const d = e(a[l], s[u]);
        d === 0 ? ((r.length === 0 || e(r[r.length - 1], a[l]) !== 0) && r.push(a[l]), l++, u++) : d < 0 ? l++ : u++;
      }
      return r;
    };
  }
  function cNe(e, t) {
    return (n) => {
      if (e.has(n))
        return e.get(n);
      const r = t(n);
      return e.set(n, r), r;
    };
  }
  const AD = cNe, kH = () => 0, uNe = (e) => e === void 0, fNe = (e) => typeof e != "object", ND = {
    boolean: 0,
    number: 1,
    string: 2
  };
  function dNe(e, t) {
    const n = typeof e, r = typeof t;
    return n === r ? zu(e, t) : ND[n] - ND[r];
  }
  function pNe(e, t) {
    const n = e.length;
    if (n === 0)
      return t;
    const r = t.length;
    if (r === 0)
      return e;
    if (r > n) {
      const a = e;
      e = t, t = a;
    }
    const o = new Set(e), i = t.length;
    for (let a = 0; a < i; a++) {
      const s = t[a];
      o.has(s) || e.push(s);
    }
    return e;
  }
  function y1(e, t, n = kH) {
    return (r, o) => e(r) ? e(o) ? n(r, o) : -1 : e(o) ? 1 : t(r, o);
  }
  function Iu(e) {
    return y1(uNe, e);
  }
  function js(e, t) {
    return y1((n) => n === void 0 || e(n), t);
  }
  function w_(e, t) {
    return y1(Array.isArray, e, t);
  }
  const Dn = Iu(zu), S_ = js((e) => e === 0, (e, t) => e - t);
  function hNe({ deduplicationCache: e = /* @__PURE__ */ new WeakMap(), sortedKeysCache: t = /* @__PURE__ */ new WeakMap() } = {}) {
    const n = AD(t, (b) => Object.keys(b).sort());
    function r(b) {
      return (v, x) => {
        const E = n(v), _ = n(x), C = Math.min(E.length, _.length);
        for (let k = 0; k < C; k++) {
          const R = zu(E[k], _[k]);
          if (R !== 0)
            return R;
        }
        if (E.length !== _.length)
          return E.length - _.length;
        for (let k = 0; k < C; k++) {
          const R = E[k], A = b(v[R], x[R]);
          if (A !== 0)
            return A;
        }
        return 0;
      };
    }
    function o(b) {
      const v = x_(b), x = AD(
        e,
        // NOTE: Always sort output
        CH(b, { threshold: 0 })
      );
      return (E, _) => v(x(E), x(_));
    }
    const i = o(zu);
    function a(b, v) {
      if (Mv(b)) {
        if (Mv(v)) {
          const x = Object.keys(b), E = Object.keys(v), _ = pNe(x, E), C = _.length;
          for (let k = 0; k < C; k++) {
            const R = _[k];
            if (b[R] === v[R])
              continue;
            const M = (y[R] ?? s)(b[R], v[R]);
            if (M !== 0)
              return M;
          }
          return 0;
        }
        return v === !0 && xp(b) ? 0 : 1;
      }
      return Mv(v) ? b === !0 && xp(v) ? 0 : -1 : zu(b, v);
    }
    const s = Iu(u), l = y1(fNe, w_(r(s), x_(u)), dNe);
    function u(b, v) {
      return b === null ? -1 : v === null ? 1 : l(b, v);
    }
    const d = Iu(a), p = js(xp, r(d)), h = Iu(o(a)), g = js(xi, a), y = {
      $id: Dn,
      $comment: Dn,
      $defs: p,
      $ref: Dn,
      $schema: Dn,
      const: s,
      contains: d,
      contentEncoding: Dn,
      contentMediaType: Dn,
      default: s,
      definitions: p,
      description: Dn,
      else: d,
      examples: s,
      exclusiveMaximum: Dn,
      exclusiveMinimum: Dn,
      format: Dn,
      if: d,
      maximum: Dn,
      maxItems: Dn,
      maxLength: Dn,
      maxProperties: Dn,
      minimum: Dn,
      multipleOf: Dn,
      not: d,
      pattern: Dn,
      propertyNames: d,
      readOnly: Dn,
      then: d,
      title: Dn,
      writeOnly: Dn,
      uniqueItems: js((b) => b === !1, kH),
      minLength: S_,
      minItems: S_,
      minProperties: S_,
      required: js(OD, i),
      enum: js(OD, o(u)),
      type: Iu((b, v) => {
        const x = Array.isArray(b), E = Array.isArray(v);
        return !x && !E ? zu(b, v) : i(x ? b : [b], E ? v : [v]);
      }),
      items: js((b) => !Array.isArray(b) && xi(b), w_(a, x_(a))),
      anyOf: h,
      allOf: h,
      oneOf: h,
      properties: p,
      patternProperties: p,
      additionalProperties: g,
      additionalItems: g,
      dependencies: js(xp, r(Iu(w_(a, i))))
    };
    return {
      compareSchemaValues: u,
      compareSchemaDefinitions: a
    };
  }
  function MD(e) {
    return e;
  }
  const TH = (e, t) => e ? TH(t % e, e) : t, mNe = (e, t) => Math.abs(e * t) / TH(e, t);
  function gNe(e, t) {
    return e === t ? e : `^(?=.*(?:${e}))(?=.*(?:${t})).*$`;
  }
  function* __(e, t, n) {
    const r = e.length, o = t.length;
    if (r > 0 && o > 0)
      for (let i = 0; i < r; i++) {
        const a = e[i];
        for (let s = 0; s < o; s++)
          yield n(a, t[s]);
      }
  }
  function E_(e, t) {
    return e || t;
  }
  function PD(e) {
    return (t, n) => {
      const r = { ...t }, o = Object.keys(n), i = o.length;
      for (let a = 0; a < i; a++) {
        const s = o[a];
        r[s] = t[s] === void 0 ? n[s] : e(t[s], n[s]);
      }
      return r;
    };
  }
  function yNe(e) {
    const t = /* @__PURE__ */ new Map();
    for (const n of e)
      for (const r of n[0])
        t.set(r, n[1]);
    return t;
  }
  function $l(e, t, n) {
    n === void 0 || xi(n) ? delete e[t] : e[t] = n;
  }
  const vNe = [
    "properties",
    "patternProperties",
    "additionalProperties"
  ];
  function $D(e) {
    const t = Object.keys(e), n = t.length, r = [];
    for (let o = 0; o < n; o++) {
      const i = t[o];
      r.push({
        regExp: new RegExp(i),
        schema: e[i]
      });
    }
    return [r, t];
  }
  const ID = [[], []];
  function jD(e, t, n) {
    const r = n.length;
    for (let o = 0; o < r; o++) {
      const i = n[o];
      if (!i.regExp.test(t))
        continue;
      const a = i.schema;
      if (a === !1)
        return !0;
      e.push(a);
    }
    return !1;
  }
  const bNe = [
    "items",
    "additionalItems"
  ], xNe = [
    "if",
    "then",
    "else"
  ];
  function DD(e, t) {
    return t.if !== void 0 && (e.if = t.if), t.then !== void 0 && (e.then = t.then), t.else !== void 0 && (e.else = t.else), e;
  }
  function C_(e, t) {
    if (e === t)
      return e;
    switch (e) {
      case "number":
        if (t === "integer")
          return "integer";
      // eslint-disable-next-line no-fallthrough
      case "integer":
        if (t === "number")
          return "integer";
      // eslint-disable-next-line no-fallthrough
      default:
        return;
    }
  }
  function Il(e, t, n) {
    return [e, t, n];
  }
  function wNe(e) {
    const t = /* @__PURE__ */ new Map();
    for (const [n, r, o] of e) {
      const i = (a) => {
        if (!o(a))
          throw new Error(`Schema keys '${n}' and '${r}' are conflicting (${n}: ${JSON.stringify(a[n])}, ${r}: ${JSON.stringify(a[r])})`);
      };
      for (const a of [
        [n, r],
        [r, n]
      ]) {
        let s = t.get(a[0]);
        s === void 0 && (s = [], t.set(a[0], s)), s.push({ oppositeKey: a[1], check: i });
      }
    }
    return t;
  }
  const SNe = [
    Il("minimum", "maximum", (e) => e.maximum >= e.minimum),
    Il("exclusiveMinimum", "maximum", (e) => e.maximum > e.exclusiveMinimum),
    Il("minimum", "exclusiveMaximum", (e) => e.exclusiveMaximum > e.minimum),
    Il("exclusiveMinimum", "exclusiveMaximum", (e) => e.exclusiveMaximum > e.exclusiveMinimum),
    Il("minLength", "maxLength", (e) => e.maxLength >= e.minLength),
    Il("minItems", "maxItems", (e) => e.maxItems >= e.minItems),
    Il("minProperties", "maxProperties", (e) => e.maxProperties >= e.minProperties)
  ];
  function _Ne({ mergePatterns: e = gNe, isSubRegExp: t = Object.is, intersectJson: n = sNe, deduplicateJsonSchemaDef: r = MD, defaultMerger: o = MD, assigners: i = [], checks: a = SNe, mergers: s } = {}) {
    function l(C) {
      const k = C.length;
      let R = C[0];
      for (let A = 1; A < k; A++) {
        const M = x(R, C[A]);
        if (M === !1)
          return !1;
        xi(M) || (R = M);
      }
      return R;
    }
    function u(C, k, R, A, M, I, D) {
      if (C.length = 0, R === !1)
        return !1;
      if (C.push(R), M !== void 0) {
        if (M === !1)
          return !1;
        C.push(M);
      }
      if (jD(C, k, I))
        return !1;
      const P = C.length < 2;
      if (D === !1) {
        if (P)
          return;
        if (jD(C, k, A))
          return !1;
      } else P && D !== void 0 && C.push(D);
      return C.length === 1 ? C[0] : l(C);
    }
    function d(C, k, R, A, M, I) {
      const D = R.length;
      if (D > 0 && M !== !1)
        if (I)
          Object.assign(C, k);
        else
          for (let L = 0; L < D; L++) {
            const P = R[L];
            A.has(P) || (C[P] = x(k[P], M));
          }
      return C;
    }
    const p = (C, { properties: k = {}, patternProperties: R, additionalProperties: A = !0 }, { properties: M = {}, patternProperties: I, additionalProperties: D = !0 }) => {
      const L = xi(A), P = xi(D);
      if (L && P)
        return $l(C, "properties", E(k, M)), $l(C, "patternProperties", R && I ? E(R, I) : R ?? I), delete C.additionalProperties, C;
      const B = x(A, D);
      $l(C, "additionalProperties", B);
      const j = {}, V = Object.keys(k), F = V.length, [G, W] = R ? $D(R) : ID, [K, $] = I ? $D(I) : ID, U = [], X = /* @__PURE__ */ new Set(), z = P ? void 0 : D;
      for (let le = 0; le < F; le++) {
        const fe = V[le];
        X.add(fe);
        const J = u(U, fe, k[fe], G, M[fe], K, z);
        J !== void 0 && (j[fe] = J);
      }
      const H = Object.keys(M), Y = H.length, Q = L ? void 0 : A;
      for (let le = 0; le < Y; le++) {
        const fe = H[le];
        if (X.has(fe))
          continue;
        const J = u(U, fe, M[fe], K, void 0, G, Q);
        J !== void 0 && (j[fe] = J);
      }
      $l(C, "properties", j);
      let re = {};
      const te = /* @__PURE__ */ new Set();
      if (W.length > 0 && $.length > 0) {
        const le = __(W, $, (fe, J) => {
          t(fe, J) && te.add(fe), t(J, fe) && te.add(J), re[e(fe, J)] = x(R[fe], I[J]);
        });
        for (; !le.next().done; )
          ;
      }
      return re = d(re, R, W, te, D, P), re = d(re, I, $, te, A, L), $l(C, "patternProperties", re), C;
    }, h = (C, { items: k = [], additionalItems: R }, { items: A = [], additionalItems: M }) => {
      const I = Array.isArray(k), D = Array.isArray(A), L = [];
      if (C.items = L, I && D) {
        const [P, B, j] = k.length < A.length ? [k.length, R, A] : [A.length, M, k];
        let V = 0;
        for (; V < P; V++)
          L.push(x(k[V], A[V]));
        if (B === !1)
          C.additionalItems = !1;
        else {
          const F = B === void 0 || xi(B);
          for (; V < j.length; V++)
            L.push(F ? j[V] : x(j[V], B));
          $l(C, "additionalItems", R !== void 0 && M !== void 0 ? x(R, M) : R ?? M);
        }
      } else if (I || D) {
        const [P, B, j] = I ? [k, A, R] : [A, k, M];
        $l(C, "additionalItems", j && x(j, B));
        for (let V = 0; V < P.length; V++)
          L.push(x(P[V], B));
      } else
        delete C.additionalItems, C.items = x(k, A);
      return C;
    }, g = (C, k, R) => {
      DD(C, k);
      const A = DD({}, R);
      return C.allOf === void 0 ? C.allOf = [A] : C.allOf = C.allOf.concat(A), C;
    };
    function y(C, k) {
      return r(Array.from(__(C, k, x)));
    }
    const b = yNe([
      [vNe, p],
      [bNe, h],
      [xNe, g],
      ...i
    ]), v = wNe(a);
    function x(C, k) {
      if (C === !1 || k === !1)
        return !1;
      if (xi(C))
        return xi(k) ? !0 : k;
      if (xi(k))
        return C;
      let R = { ...C };
      const A = /* @__PURE__ */ new Set(), M = /* @__PURE__ */ new Set(), I = Object.keys(k), D = I.length;
      for (let L = 0; L < D; L++) {
        const P = I[L], B = k[P];
        if (B === void 0)
          continue;
        const j = v.get(P);
        if (j !== void 0) {
          const W = j.length;
          for (let K = 0; K < W; K++) {
            const $ = j[K];
            C[$.oppositeKey] !== void 0 && M.add($.check);
          }
        }
        const V = C[P];
        if (V === void 0) {
          R[P] = B;
          continue;
        }
        const F = b.get(P);
        if (F) {
          A.add(F);
          continue;
        }
        const G = _[P] ?? o;
        R[P] = G(V, B);
      }
      for (const L of A)
        R = L(R, C, k);
      for (const L of M)
        L(R);
      return R;
    }
    const E = PD(x), _ = {
      $id: o,
      $ref: o,
      $schema: o,
      $comment: o,
      $defs: E,
      definitions: E,
      type: (C, k) => {
        if (C === k)
          return C;
        const R = Array.isArray(C), A = Array.isArray(k);
        if (!R && !A) {
          const M = C_(C, k);
          if (M !== void 0)
            return M;
        } else if (R || A) {
          const M = /* @__PURE__ */ new Set();
          if (R && A)
            for (const D of __(C, k, C_))
              D !== void 0 && M.add(D);
          else {
            const D = R ? C : k, L = R ? k : C, P = D.length;
            for (let B = 0; B < P; B++) {
              const j = C_(L, D[B]);
              j !== void 0 && M.add(j);
            }
          }
          const I = M.size;
          if (I === 1)
            return M.values().next().value;
          if (I > 1)
            return Array.from(M);
        }
        throw new Error(`It is not possible to create an intersection of the following incompatible types: ${C.toString()}, ${k.toString()}`);
      },
      default: o,
      description: o,
      title: o,
      const: o,
      format: o,
      contentEncoding: o,
      contentMediaType: o,
      not: (C, k) => {
        const R = r([C, k]);
        return R.length === 1 ? R[0] : { anyOf: R };
      },
      pattern: e,
      readOnly: E_,
      writeOnly: E_,
      enum: (C, k) => {
        const R = n(C, k);
        if (R.length === 0)
          throw new Error(`Intersection of the following enums is empty: "${JSON.stringify(C)}", "${JSON.stringify(k)}"`);
        return R;
      },
      anyOf: y,
      oneOf: y,
      allOf: (C, k) => r(C.concat(k)),
      propertyNames: x,
      contains: x,
      dependencies: PD((C, k) => Array.isArray(C) ? Array.isArray(k) ? b_(C, k) : x(k, { required: C }) : Array.isArray(k) ? x(C, { required: k }) : x(C, k)),
      examples: (C, k) => {
        if (!Array.isArray(C) || !Array.isArray(k))
          throw new Error(`Value of the 'examples' field should be an array, but got "${JSON.stringify(C)}" and "${JSON.stringify(k)}"`);
        return b_(C, k);
      },
      multipleOf: (C, k) => {
        let R = 1;
        for (; !Number.isInteger(C) || !Number.isInteger(k); )
          R *= 10, C *= 10, k *= 10;
        return mNe(C, k) / R;
      },
      exclusiveMaximum: Math.min,
      maximum: Math.min,
      maxItems: Math.min,
      maxLength: Math.min,
      maxProperties: Math.min,
      exclusiveMinimum: Math.max,
      minimum: Math.max,
      minItems: Math.max,
      minLength: Math.max,
      minProperties: Math.max,
      uniqueItems: E_,
      required: b_,
      ...s
    };
    return {
      mergeSchemaDefinitions: x,
      mergeArrayOfSchemaDefinitions: l
    };
  }
  function ENe(e) {
    const t = [], n = [e];
    for (; n.length > 0; ) {
      const r = n.pop();
      if (typeof r == "boolean" || r.allOf === void 0) {
        t.push(r);
        continue;
      }
      const { allOf: o, ...i } = r;
      t.push(i);
      for (let a = o.length - 1; a >= 0; a--)
        n.push(o[a]);
    }
    return t;
  }
  function CNe(e) {
    return (t) => e(ENe(t));
  }
  var ep = {}, FD;
  function kNe() {
    if (FD) return ep;
    FD = 1;
    var e = /~/, t = /~[01]/g;
    function n(u) {
      switch (u) {
        case "~1":
          return "/";
        case "~0":
          return "~";
      }
      throw new Error("Invalid tilde escape: " + u);
    }
    function r(u) {
      return e.test(u) ? u.replace(t, n) : u;
    }
    function o(u, d, p) {
      for (var h, g, y = 1, b = d.length; y < b; ) {
        if (d[y] === "constructor" || d[y] === "prototype" || d[y] === "__proto__") return u;
        if (h = r(d[y++]), g = b > y, typeof u[h] > "u" && (Array.isArray(u) && h === "-" && (h = u.length), g && (d[y] !== "" && d[y] < 1 / 0 || d[y] === "-" ? u[h] = [] : u[h] = {})), !g) break;
        u = u[h];
      }
      var v = u[h];
      return p === void 0 ? delete u[h] : u[h] = p, v;
    }
    function i(u) {
      if (typeof u == "string") {
        if (u = u.split("/"), u[0] === "") return u;
        throw new Error("Invalid JSON pointer.");
      } else if (Array.isArray(u)) {
        for (const d of u)
          if (typeof d != "string" && typeof d != "number")
            throw new Error("Invalid JSON pointer. Must be of type string or number.");
        return u;
      }
      throw new Error("Invalid JSON pointer.");
    }
    function a(u, d) {
      if (typeof u != "object") throw new Error("Invalid input object.");
      d = i(d);
      var p = d.length;
      if (p === 1) return u;
      for (var h = 1; h < p; ) {
        if (u = u[r(d[h++])], p === h) return u;
        if (typeof u != "object" || u === null) return;
      }
    }
    function s(u, d, p) {
      if (typeof u != "object") throw new Error("Invalid input object.");
      if (d = i(d), d.length === 0) throw new Error("Invalid JSON pointer for set.");
      return o(u, d, p);
    }
    function l(u) {
      var d = i(u);
      return {
        get: function(p) {
          return a(p, d);
        },
        set: function(p, h) {
          return s(p, d, h);
        }
      };
    }
    return ep.get = a, ep.set = s, ep.compile = l, ep;
  }
  var TNe = kNe();
  const k_ = /* @__PURE__ */ Jo(TNe);
  function RNe(e, t) {
    return e && Df(t, Vo(t), e);
  }
  function ONe(e, t) {
    return e && Df(t, dm(t), e);
  }
  function ANe(e, t) {
    return Df(e, OR(e), t);
  }
  var NNe = Object.getOwnPropertySymbols, RH = NNe ? function(e) {
    for (var t = []; e; )
      RR(t, OR(e)), e = c1(e);
    return t;
  } : XV;
  function MNe(e, t) {
    return Df(e, RH(e), t);
  }
  function VR(e) {
    return YV(e, dm, RH);
  }
  var PNe = Object.prototype, $Ne = PNe.hasOwnProperty;
  function INe(e) {
    var t = e.length, n = new e.constructor(t);
    return t && typeof e[0] == "string" && $Ne.call(e, "index") && (n.index = e.index, n.input = e.input), n;
  }
  function jNe(e, t) {
    var n = t ? zR(e.buffer) : e.buffer;
    return new e.constructor(n, e.byteOffset, e.byteLength);
  }
  var DNe = /\w*$/;
  function FNe(e) {
    var t = new e.constructor(e.source, DNe.exec(e));
    return t.lastIndex = e.lastIndex, t;
  }
  var LD = Ao ? Ao.prototype : void 0, zD = LD ? LD.valueOf : void 0;
  function LNe(e) {
    return zD ? Object(zD.call(e)) : {};
  }
  var zNe = "[object Boolean]", BNe = "[object Date]", UNe = "[object Map]", VNe = "[object Number]", HNe = "[object RegExp]", qNe = "[object Set]", WNe = "[object String]", GNe = "[object Symbol]", KNe = "[object ArrayBuffer]", YNe = "[object DataView]", XNe = "[object Float32Array]", ZNe = "[object Float64Array]", QNe = "[object Int8Array]", JNe = "[object Int16Array]", eMe = "[object Int32Array]", tMe = "[object Uint8Array]", nMe = "[object Uint8ClampedArray]", rMe = "[object Uint16Array]", oMe = "[object Uint32Array]";
  function iMe(e, t, n) {
    var r = e.constructor;
    switch (t) {
      case KNe:
        return zR(e);
      case zNe:
      case BNe:
        return new r(+e);
      case YNe:
        return jNe(e, n);
      case XNe:
      case ZNe:
      case QNe:
      case JNe:
      case eMe:
      case tMe:
      case nMe:
      case rMe:
      case oMe:
        return yH(e, n);
      case UNe:
        return new r();
      case VNe:
      case WNe:
        return new r(e);
      case HNe:
        return FNe(e);
      case qNe:
        return new r();
      case GNe:
        return LNe(e);
    }
  }
  var aMe = "[object Map]";
  function sMe(e) {
    return No(e) && Co(e) == aMe;
  }
  var BD = vf && vf.isMap, lMe = BD ? NR(BD) : sMe, cMe = "[object Set]";
  function uMe(e) {
    return No(e) && Co(e) == cMe;
  }
  var UD = vf && vf.isSet, fMe = UD ? NR(UD) : uMe, dMe = 1, pMe = 2, hMe = 4, OH = "[object Arguments]", mMe = "[object Array]", gMe = "[object Boolean]", yMe = "[object Date]", vMe = "[object Error]", AH = "[object Function]", bMe = "[object GeneratorFunction]", xMe = "[object Map]", wMe = "[object Number]", NH = "[object Object]", SMe = "[object RegExp]", _Me = "[object Set]", EMe = "[object String]", CMe = "[object Symbol]", kMe = "[object WeakMap]", TMe = "[object ArrayBuffer]", RMe = "[object DataView]", OMe = "[object Float32Array]", AMe = "[object Float64Array]", NMe = "[object Int8Array]", MMe = "[object Int16Array]", PMe = "[object Int32Array]", $Me = "[object Uint8Array]", IMe = "[object Uint8ClampedArray]", jMe = "[object Uint16Array]", DMe = "[object Uint32Array]", cn = {};
  cn[OH] = cn[mMe] = cn[TMe] = cn[RMe] = cn[gMe] = cn[yMe] = cn[OMe] = cn[AMe] = cn[NMe] = cn[MMe] = cn[PMe] = cn[xMe] = cn[wMe] = cn[NH] = cn[SMe] = cn[_Me] = cn[EMe] = cn[CMe] = cn[$Me] = cn[IMe] = cn[jMe] = cn[DMe] = !0;
  cn[vMe] = cn[AH] = cn[kMe] = !1;
  function jp(e, t, n, r, o, i) {
    var a, s = t & dMe, l = t & pMe, u = t & hMe;
    if (n && (a = o ? n(e, r, o, i) : n(e)), a !== void 0)
      return a;
    if (!Pt(e))
      return e;
    var d = Kn(e);
    if (d) {
      if (a = INe(e), !s)
        return BR(e, a);
    } else {
      var p = Co(e), h = p == AH || p == bMe;
      if (hc(e))
        return gH(e, s);
      if (p == NH || p == OH || h && !o) {
        if (a = l || h ? {} : vH(e), !s)
          return l ? MNe(e, ONe(a, e)) : ANe(e, RNe(a, e));
      } else {
        if (!cn[p])
          return o ? e : {};
        a = iMe(e, p, s);
      }
    }
    i || (i = new Go());
    var g = i.get(e);
    if (g)
      return g;
    i.set(e, a), fMe(e) ? e.forEach(function(v) {
      a.add(jp(v, t, n, v, e, i));
    }) : lMe(e) && e.forEach(function(v, x) {
      a.set(x, jp(v, t, n, x, e, i));
    });
    var y = u ? l ? VR : NC : l ? dm : Vo, b = d ? void 0 : y(e);
    return FR(b || e, function(v, x) {
      b && (x = v, v = e[x]), jR(a, x, jp(v, t, n, x, e, i));
    }), a;
  }
  function MH(e) {
    var t = e == null ? 0 : e.length;
    return t ? e[t - 1] : void 0;
  }
  function FMe(e, t, n) {
    var r = -1, o = e.length;
    t < 0 && (t = -t > o ? 0 : o + t), n = n > o ? o : n, n < 0 && (n += o), o = t > n ? 0 : n - t >>> 0, t >>>= 0;
    for (var i = Array(o); ++r < o; )
      i[r] = e[r + t];
    return i;
  }
  function LMe(e, t) {
    return t.length < 2 ? e : h1(e, FMe(t, 0, -1));
  }
  function PH(e, t) {
    return t = jf(t, e), e = LMe(e, t), e == null || delete e[Cc(MH(t))];
  }
  function zMe(e) {
    return il(e) ? void 0 : e;
  }
  function DC(e) {
    var t = e == null ? 0 : e.length;
    return t ? pm(e, 1) : [];
  }
  function $H(e) {
    return wH(xH(e, void 0, DC), e + "");
  }
  var BMe = 1, UMe = 2, VMe = 4, bh = $H(function(e, t) {
    var n = {};
    if (e == null)
      return n;
    var r = !1;
    t = If(t, function(i) {
      return i = jf(i, e), r || (r = i.length > 1), i;
    }), Df(e, VR(e), n), r && (n = jp(n, BMe | UMe | VMe, zMe));
    for (var o = t.length; o--; )
      PH(n, t[o]);
    return n;
  }), tp = { exports: {} }, T_, VD;
  function IH() {
    if (VD) return T_;
    VD = 1;
    const e = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu), t = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
    function n(h) {
      let g = "", y = 0, b = 0;
      for (b = 0; b < h.length; b++)
        if (y = h[b].charCodeAt(0), y !== 48) {
          if (!(y >= 48 && y <= 57 || y >= 65 && y <= 70 || y >= 97 && y <= 102))
            return "";
          g += h[b];
          break;
        }
      for (b += 1; b < h.length; b++) {
        if (y = h[b].charCodeAt(0), !(y >= 48 && y <= 57 || y >= 65 && y <= 70 || y >= 97 && y <= 102))
          return "";
        g += h[b];
      }
      return g;
    }
    const r = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
    function o(h) {
      return h.length = 0, !0;
    }
    function i(h, g, y) {
      if (h.length) {
        const b = n(h);
        if (b !== "")
          g.push(b);
        else
          return y.error = !0, !1;
        h.length = 0;
      }
      return !0;
    }
    function a(h) {
      let g = 0;
      const y = { error: !1, address: "", zone: "" }, b = [], v = [];
      let x = !1, E = !1, _ = i;
      for (let C = 0; C < h.length; C++) {
        const k = h[C];
        if (!(k === "[" || k === "]"))
          if (k === ":") {
            if (x === !0 && (E = !0), !_(v, b, y))
              break;
            if (++g > 7) {
              y.error = !0;
              break;
            }
            C > 0 && h[C - 1] === ":" && (x = !0), b.push(":");
            continue;
          } else if (k === "%") {
            if (!_(v, b, y))
              break;
            _ = o;
          } else {
            v.push(k);
            continue;
          }
      }
      return v.length && (_ === o ? y.zone = v.join("") : E ? b.push(v.join("")) : b.push(n(v))), y.address = b.join(""), y;
    }
    function s(h) {
      if (l(h, ":") < 2)
        return { host: h, isIPV6: !1 };
      const g = a(h);
      if (g.error)
        return { host: h, isIPV6: !1 };
      {
        let y = g.address, b = g.address;
        return g.zone && (y += "%" + g.zone, b += "%25" + g.zone), { host: y, isIPV6: !0, escapedHost: b };
      }
    }
    function l(h, g) {
      let y = 0;
      for (let b = 0; b < h.length; b++)
        h[b] === g && y++;
      return y;
    }
    function u(h) {
      let g = h;
      const y = [];
      let b = -1, v = 0;
      for (; v = g.length; ) {
        if (v === 1) {
          if (g === ".")
            break;
          if (g === "/") {
            y.push("/");
            break;
          } else {
            y.push(g);
            break;
          }
        } else if (v === 2) {
          if (g[0] === ".") {
            if (g[1] === ".")
              break;
            if (g[1] === "/") {
              g = g.slice(2);
              continue;
            }
          } else if (g[0] === "/" && (g[1] === "." || g[1] === "/")) {
            y.push("/");
            break;
          }
        } else if (v === 3 && g === "/..") {
          y.length !== 0 && y.pop(), y.push("/");
          break;
        }
        if (g[0] === ".") {
          if (g[1] === ".") {
            if (g[2] === "/") {
              g = g.slice(3);
              continue;
            }
          } else if (g[1] === "/") {
            g = g.slice(2);
            continue;
          }
        } else if (g[0] === "/" && g[1] === ".") {
          if (g[2] === "/") {
            g = g.slice(2);
            continue;
          } else if (g[2] === "." && g[3] === "/") {
            g = g.slice(3), y.length !== 0 && y.pop();
            continue;
          }
        }
        if ((b = g.indexOf("/", 1)) === -1) {
          y.push(g);
          break;
        } else
          y.push(g.slice(0, b)), g = g.slice(b);
      }
      return y.join("");
    }
    function d(h, g) {
      const y = g !== !0 ? escape : unescape;
      return h.scheme !== void 0 && (h.scheme = y(h.scheme)), h.userinfo !== void 0 && (h.userinfo = y(h.userinfo)), h.host !== void 0 && (h.host = y(h.host)), h.path !== void 0 && (h.path = y(h.path)), h.query !== void 0 && (h.query = y(h.query)), h.fragment !== void 0 && (h.fragment = y(h.fragment)), h;
    }
    function p(h) {
      const g = [];
      if (h.userinfo !== void 0 && (g.push(h.userinfo), g.push("@")), h.host !== void 0) {
        let y = unescape(h.host);
        if (!t(y)) {
          const b = s(y);
          b.isIPV6 === !0 ? y = `[${b.escapedHost}]` : y = h.host;
        }
        g.push(y);
      }
      return (typeof h.port == "number" || typeof h.port == "string") && (g.push(":"), g.push(String(h.port))), g.length ? g.join("") : void 0;
    }
    return T_ = {
      nonSimpleDomain: r,
      recomposeAuthority: p,
      normalizeComponentEncoding: d,
      removeDotSegments: u,
      isIPv4: t,
      isUUID: e,
      normalizeIPv6: s,
      stringArrayToHexStripped: n
    }, T_;
  }
  var R_, HD;
  function HMe() {
    if (HD) return R_;
    HD = 1;
    const { isUUID: e } = IH(), t = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu, n = (
      /** @type {const} */
      [
        "http",
        "https",
        "ws",
        "wss",
        "urn",
        "urn:uuid"
      ]
    );
    function r(k) {
      return n.indexOf(
        /** @type {*} */
        k
      ) !== -1;
    }
    function o(k) {
      return k.secure === !0 ? !0 : k.secure === !1 ? !1 : k.scheme ? k.scheme.length === 3 && (k.scheme[0] === "w" || k.scheme[0] === "W") && (k.scheme[1] === "s" || k.scheme[1] === "S") && (k.scheme[2] === "s" || k.scheme[2] === "S") : !1;
    }
    function i(k) {
      return k.host || (k.error = k.error || "HTTP URIs must have a host."), k;
    }
    function a(k) {
      const R = String(k.scheme).toLowerCase() === "https";
      return (k.port === (R ? 443 : 80) || k.port === "") && (k.port = void 0), k.path || (k.path = "/"), k;
    }
    function s(k) {
      return k.secure = o(k), k.resourceName = (k.path || "/") + (k.query ? "?" + k.query : ""), k.path = void 0, k.query = void 0, k;
    }
    function l(k) {
      if ((k.port === (o(k) ? 443 : 80) || k.port === "") && (k.port = void 0), typeof k.secure == "boolean" && (k.scheme = k.secure ? "wss" : "ws", k.secure = void 0), k.resourceName) {
        const [R, A] = k.resourceName.split("?");
        k.path = R && R !== "/" ? R : void 0, k.query = A, k.resourceName = void 0;
      }
      return k.fragment = void 0, k;
    }
    function u(k, R) {
      if (!k.path)
        return k.error = "URN can not be parsed", k;
      const A = k.path.match(t);
      if (A) {
        const M = R.scheme || k.scheme || "urn";
        k.nid = A[1].toLowerCase(), k.nss = A[2];
        const I = `${M}:${R.nid || k.nid}`, D = C(I);
        k.path = void 0, D && (k = D.parse(k, R));
      } else
        k.error = k.error || "URN can not be parsed.";
      return k;
    }
    function d(k, R) {
      if (k.nid === void 0)
        throw new Error("URN without nid cannot be serialized");
      const A = R.scheme || k.scheme || "urn", M = k.nid.toLowerCase(), I = `${A}:${R.nid || M}`, D = C(I);
      D && (k = D.serialize(k, R));
      const L = k, P = k.nss;
      return L.path = `${M || R.nid}:${P}`, R.skipEscape = !0, L;
    }
    function p(k, R) {
      const A = k;
      return A.uuid = A.nss, A.nss = void 0, !R.tolerant && (!A.uuid || !e(A.uuid)) && (A.error = A.error || "UUID is not valid."), A;
    }
    function h(k) {
      const R = k;
      return R.nss = (k.uuid || "").toLowerCase(), R;
    }
    const g = (
      /** @type {SchemeHandler} */
      {
        scheme: "http",
        domainHost: !0,
        parse: i,
        serialize: a
      }
    ), y = (
      /** @type {SchemeHandler} */
      {
        scheme: "https",
        domainHost: g.domainHost,
        parse: i,
        serialize: a
      }
    ), b = (
      /** @type {SchemeHandler} */
      {
        scheme: "ws",
        domainHost: !0,
        parse: s,
        serialize: l
      }
    ), v = (
      /** @type {SchemeHandler} */
      {
        scheme: "wss",
        domainHost: b.domainHost,
        parse: b.parse,
        serialize: b.serialize
      }
    ), _ = (
      /** @type {Record<SchemeName, SchemeHandler>} */
      {
        http: g,
        https: y,
        ws: b,
        wss: v,
        urn: (
          /** @type {SchemeHandler} */
          {
            scheme: "urn",
            parse: u,
            serialize: d,
            skipNormalize: !0
          }
        ),
        "urn:uuid": (
          /** @type {SchemeHandler} */
          {
            scheme: "urn:uuid",
            parse: p,
            serialize: h,
            skipNormalize: !0
          }
        )
      }
    );
    Object.setPrototypeOf(_, null);
    function C(k) {
      return k && (_[
        /** @type {SchemeName} */
        k
      ] || _[
        /** @type {SchemeName} */
        k.toLowerCase()
      ]) || void 0;
    }
    return R_ = {
      wsIsSecure: o,
      SCHEMES: _,
      isValidSchemeName: r,
      getSchemeHandler: C
    }, R_;
  }
  var qD;
  function qMe() {
    if (qD) return tp.exports;
    qD = 1;
    const { normalizeIPv6: e, removeDotSegments: t, recomposeAuthority: n, normalizeComponentEncoding: r, isIPv4: o, nonSimpleDomain: i } = IH(), { SCHEMES: a, getSchemeHandler: s } = HMe();
    function l(v, x) {
      return typeof v == "string" ? v = /** @type {T} */
      h(y(v, x), x) : typeof v == "object" && (v = /** @type {T} */
      y(h(v, x), x)), v;
    }
    function u(v, x, E) {
      const _ = E ? Object.assign({ scheme: "null" }, E) : { scheme: "null" }, C = d(y(v, _), y(x, _), _, !0);
      return _.skipEscape = !0, h(C, _);
    }
    function d(v, x, E, _) {
      const C = {};
      return _ || (v = y(h(v, E), E), x = y(h(x, E), E)), E = E || {}, !E.tolerant && x.scheme ? (C.scheme = x.scheme, C.userinfo = x.userinfo, C.host = x.host, C.port = x.port, C.path = t(x.path || ""), C.query = x.query) : (x.userinfo !== void 0 || x.host !== void 0 || x.port !== void 0 ? (C.userinfo = x.userinfo, C.host = x.host, C.port = x.port, C.path = t(x.path || ""), C.query = x.query) : (x.path ? (x.path[0] === "/" ? C.path = t(x.path) : ((v.userinfo !== void 0 || v.host !== void 0 || v.port !== void 0) && !v.path ? C.path = "/" + x.path : v.path ? C.path = v.path.slice(0, v.path.lastIndexOf("/") + 1) + x.path : C.path = x.path, C.path = t(C.path)), C.query = x.query) : (C.path = v.path, x.query !== void 0 ? C.query = x.query : C.query = v.query), C.userinfo = v.userinfo, C.host = v.host, C.port = v.port), C.scheme = v.scheme), C.fragment = x.fragment, C;
    }
    function p(v, x, E) {
      return typeof v == "string" ? (v = unescape(v), v = h(r(y(v, E), !0), { ...E, skipEscape: !0 })) : typeof v == "object" && (v = h(r(v, !0), { ...E, skipEscape: !0 })), typeof x == "string" ? (x = unescape(x), x = h(r(y(x, E), !0), { ...E, skipEscape: !0 })) : typeof x == "object" && (x = h(r(x, !0), { ...E, skipEscape: !0 })), v.toLowerCase() === x.toLowerCase();
    }
    function h(v, x) {
      const E = {
        host: v.host,
        scheme: v.scheme,
        userinfo: v.userinfo,
        port: v.port,
        path: v.path,
        query: v.query,
        nid: v.nid,
        nss: v.nss,
        uuid: v.uuid,
        fragment: v.fragment,
        reference: v.reference,
        resourceName: v.resourceName,
        secure: v.secure,
        error: ""
      }, _ = Object.assign({}, x), C = [], k = s(_.scheme || E.scheme);
      k && k.serialize && k.serialize(E, _), E.path !== void 0 && (_.skipEscape ? E.path = unescape(E.path) : (E.path = escape(E.path), E.scheme !== void 0 && (E.path = E.path.split("%3A").join(":")))), _.reference !== "suffix" && E.scheme && C.push(E.scheme, ":");
      const R = n(E);
      if (R !== void 0 && (_.reference !== "suffix" && C.push("//"), C.push(R), E.path && E.path[0] !== "/" && C.push("/")), E.path !== void 0) {
        let A = E.path;
        !_.absolutePath && (!k || !k.absolutePath) && (A = t(A)), R === void 0 && A[0] === "/" && A[1] === "/" && (A = "/%2F" + A.slice(2)), C.push(A);
      }
      return E.query !== void 0 && C.push("?", E.query), E.fragment !== void 0 && C.push("#", E.fragment), C.join("");
    }
    const g = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function y(v, x) {
      const E = Object.assign({}, x), _ = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      let C = !1;
      E.reference === "suffix" && (E.scheme ? v = E.scheme + ":" + v : v = "//" + v);
      const k = v.match(g);
      if (k) {
        if (_.scheme = k[1], _.userinfo = k[3], _.host = k[4], _.port = parseInt(k[5], 10), _.path = k[6] || "", _.query = k[7], _.fragment = k[8], isNaN(_.port) && (_.port = k[5]), _.host)
          if (o(_.host) === !1) {
            const M = e(_.host);
            _.host = M.host.toLowerCase(), C = M.isIPV6;
          } else
            C = !0;
        _.scheme === void 0 && _.userinfo === void 0 && _.host === void 0 && _.port === void 0 && _.query === void 0 && !_.path ? _.reference = "same-document" : _.scheme === void 0 ? _.reference = "relative" : _.fragment === void 0 ? _.reference = "absolute" : _.reference = "uri", E.reference && E.reference !== "suffix" && E.reference !== _.reference && (_.error = _.error || "URI is not a " + E.reference + " reference.");
        const R = s(E.scheme || _.scheme);
        if (!E.unicodeSupport && (!R || !R.unicodeSupport) && _.host && (E.domainHost || R && R.domainHost) && C === !1 && i(_.host))
          try {
            _.host = URL.domainToASCII(_.host.toLowerCase());
          } catch (A) {
            _.error = _.error || "Host's domain name can not be converted to ASCII: " + A;
          }
        (!R || R && !R.skipNormalize) && (v.indexOf("%") !== -1 && (_.scheme !== void 0 && (_.scheme = unescape(_.scheme)), _.host !== void 0 && (_.host = unescape(_.host))), _.path && (_.path = escape(unescape(_.path))), _.fragment && (_.fragment = encodeURI(decodeURIComponent(_.fragment)))), R && R.parse && R.parse(_, E);
      } else
        _.error = _.error || "URI can not be parsed.";
      return _;
    }
    const b = {
      SCHEMES: a,
      normalize: l,
      resolve: u,
      resolveComponent: d,
      equal: p,
      serialize: h,
      parse: y
    };
    return tp.exports = b, tp.exports.default = b, tp.exports.fastUri = b, tp.exports;
  }
  var WMe = qMe();
  const HR = /* @__PURE__ */ Jo(WMe);
  function P0(e, t) {
    if (nn in e && HR.equal(e[nn], t))
      return e;
    for (const n of Object.values(e))
      if (Array.isArray(n)) {
        for (const r of n)
          if (Pt(r)) {
            const o = P0(r, t);
            if (o !== void 0)
              return o;
          }
      } else if (Pt(n)) {
        const r = P0(n, t);
        if (r !== void 0)
          return r;
      }
  }
  function FC(e, t) {
    const n = Ee(e, nn, t);
    mn in e && (e = { ...e, [mn]: HR.resolve(n, e[mn]) });
    for (const [r, o] of Object.entries(e))
      Array.isArray(o) ? e = {
        ...e,
        [r]: o.map((i) => Pt(i) ? FC(i, n) : i)
      } : Pt(o) && (e = { ...e, [r]: FC(o, n) });
    return e;
  }
  function qR(e, t) {
    const n = t[e];
    return [bh(t, [e]), n];
  }
  function jH(e, t = {}, n = [], r = Ee(t, [nn])) {
    const o = e || "";
    let i;
    if (o.startsWith("#")) {
      const s = decodeURIComponent(o.substring(1));
      r === void 0 || nn in t && t[nn] === r ? i = k_.get(t, s) : t[bp] === Av && (i = P0(t, r.replace(/\/$/, "")), i !== void 0 && (i = k_.get(i, s)));
    } else if (t[bp] === Av) {
      const s = r ? HR.resolve(r, o) : o, [l, ...u] = s.replace(/#\/?$/, "").split("#");
      i = P0(t, l.replace(/\/$/, "")), i !== void 0 && (r = i[nn], Un(u) || (i = k_.get(i, decodeURIComponent(u.join("#")))));
    }
    if (i === void 0)
      throw new Error(`Could not find a definition for ${e}.`);
    const a = i[mn];
    if (a) {
      if (n.includes(a)) {
        if (n.length === 1)
          throw new Error(`Definition for ${e} is a circular reference`);
        const [d, ...p] = n, h = [...p, o, d].join(" -> ");
        throw new Error(`Definition for ${d} contains a circular reference through ${h}`);
      }
      const [s, l] = qR(mn, i), u = jH(l, t, [...n, o], r);
      return Object.keys(s).length > 0 ? t[bp] === lTe || t[bp] === Av ? { [ol]: [s, u] } : { ...s, ...u } : u;
    }
    return i;
  }
  function DH(e, t = {}, n = Ee(t, [nn])) {
    return jH(e, t, [], n);
  }
  var GMe = "[object String]";
  function al(e) {
    return typeof e == "string" || !Kn(e) && No(e) && Ja(e) == GMe;
  }
  function Wi(e) {
    let t;
    const n = Ee(e, iTe);
    return al(n) ? t = n : n !== void 0 && console.warn(`Expecting discriminator to be a string, got "${typeof n}" instead`), t;
  }
  function xh(e) {
    return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : e == null ? "null" : typeof e == "boolean" ? "boolean" : isNaN(e) ? typeof e == "object" ? "object" : "string" : "number";
  }
  var KMe = g1(function(e) {
    return _H(pm(e, 1, vh, !0));
  });
  function Qo(e) {
    let { type: t } = e;
    return !t && e.const ? xh(e.const) : !t && e.enum ? "string" : !t && (e.properties || e.additionalProperties || e.patternProperties) ? "object" : (Array.isArray(t) && (t.length === 2 && t.includes("null") ? t = t.find((n) => n !== "null") : t = t[0]), t);
  }
  function Ha(e, t) {
    const n = Object.assign({}, e);
    return Object.keys(t).reduce((r, o) => {
      const i = e ? e[o] : {}, a = t[o];
      return e && o in e && Rt(a) ? r[o] = Ha(i, a) : e && t && (Qo(e) === "object" || Qo(t) === "object") && o === LV && Array.isArray(i) && Array.isArray(a) ? r[o] = KMe(i, a) : r[o] = a, r;
    }, n);
  }
  var YMe = "[object Number]";
  function FH(e) {
    return typeof e == "number" || No(e) && Ja(e) == YMe;
  }
  function LH(e, t, n) {
    var r;
    if (e && n) {
      const o = Ee(e, n);
      if (o === void 0)
        return;
      for (let i = 0; i < t.length; i++) {
        const a = t[i], s = Ee(a, [It, n], {});
        if (!(s.type === "object" || s.type === "array") && (s.const === o || !((r = s.enum) === null || r === void 0) && r.includes(o)))
          return i;
      }
    }
  }
  function WR(e, t, n, r, o) {
    if (t === void 0)
      return 0;
    const i = LH(t, n, o);
    if (FH(i))
      return i;
    for (let a = 0; a < n.length; a++) {
      const s = n[a];
      if (o && kt(s, [It, o])) {
        const l = Ee(t, o), u = Ee(s, [It, o], {});
        if (e.isValid(u, l, r))
          return a;
      } else if (s[It]) {
        const l = {
          anyOf: Object.keys(s[It]).map((d) => ({
            required: [d]
          }))
        };
        let u;
        if (s.anyOf) {
          const { ...d } = s;
          d.allOf ? d.allOf = d.allOf.slice() : d.allOf = [], d.allOf.push(l), u = d;
        } else
          u = Object.assign({}, s, l);
        if (delete u.required, e.isValid(u, t, r))
          return a;
      } else if (e.isValid(s, t, r))
        return a;
    }
    return 0;
  }
  function yr(e, t, n = {}, r, o, i = !1) {
    return Mi(e, t, n, r, void 0, void 0, o, i)[0];
  }
  function XMe(e, t, n, r, o, i, a) {
    const { if: s, then: l, else: u, ...d } = t, p = e.isValid(s, i || {}, n);
    let h = [d], g = [];
    if (r)
      l && typeof l != "boolean" && (g = g.concat(Mi(e, l, n, i, r, o, a))), u && typeof u != "boolean" && (g = g.concat(Mi(e, u, n, i, r, o, a)));
    else {
      const y = p ? l : u;
      y && typeof y != "boolean" && (g = g.concat(Mi(e, y, n, i, r, o, a)));
    }
    return g.length && (h = g.map((y) => Ha(d, y))), h.flatMap((y) => Mi(e, y, n, i, r, o, a));
  }
  function zH(e) {
    return e.reduce((n, r) => r.length > 1 ? r.flatMap((o) => lH(n.length, (i) => [...n[i]].concat(o))) : (n.forEach((o) => o.push(r[0])), n), [[]]);
  }
  function BH(e, t) {
    return Object.keys(e.patternProperties).filter((n) => RegExp(n).test(t)).reduce((n, r) => (Xt(n, [r], e.patternProperties[r]), n), {});
  }
  function ZMe(e, t, n, r, o, i, a, s) {
    const l = UH(e, t, n, r, o, i, a, s);
    if (l.length > 1 || l[0] !== t)
      return l;
    if (ER in t)
      return VH(e, t, n, r, o, i, a).flatMap((d) => Mi(e, d, n, i, r, o, a));
    if (ol in t && Array.isArray(t[ol])) {
      const u = t.allOf.map((p) => Mi(e, p, n, i, r, o, a));
      return zH(u).map((p) => ({
        ...t,
        allOf: p
      }));
    }
    return [t];
  }
  function UH(e, t, n, r, o, i, a, s) {
    const l = ef(t, n, o, void 0, s);
    return l !== t ? Mi(e, l, n, i, r, o, a, s) : [t];
  }
  function ef(e, t, n, r, o) {
    if (!Rt(e))
      return e;
    let i = e;
    if (mn in i) {
      const { $ref: a, ...s } = i;
      if (n.includes(a))
        return i;
      n.push(a), i = { ...DH(a, t, r), ...s }, nn in i && (r = i[nn]);
    }
    if (It in i) {
      const a = [], s = CAe(i[It], (l, u, d) => {
        const p = [...n];
        l[d] = ef(u, t, p, r, o), a.push(p);
      }, {});
      UAe(n, EH(qAe(a))), i = { ...i, [It]: s };
    }
    if (gf in i && !Array.isArray(i.items) && typeof i.items != "boolean" && (i = {
      ...i,
      items: ef(i.items, t, n, r, o)
    }), o) {
      let a, s;
      At in e && Array.isArray(e[At]) ? (a = At, s = i[At]) : gt in e && Array.isArray(e[gt]) && (a = gt, s = i[gt]), a && s && (i = {
        ...i,
        [a]: s.map((l) => ef(l, t, n, r, o))
      });
    }
    return fn(e, i) ? e : i;
  }
  function QMe(e, t, n, r, o) {
    const i = {
      ...t,
      properties: { ...t.properties }
    }, a = r && Rt(r) ? r : {};
    return Object.keys(a).forEach((s) => {
      if (!(s in i.properties)) {
        if (RC in i) {
          const l = BH(i, s);
          if (!Un(l)) {
            i.properties[s] = yr(e, { [ol]: Object.values(l) }, n, Ee(a, [s]), o), Xt(i.properties, [s, $a], !0);
            return;
          }
        }
        if (O0 in i && i.additionalProperties !== !1) {
          let l;
          typeof i.additionalProperties != "boolean" ? mn in i.additionalProperties ? l = yr(e, { [mn]: Ee(i.additionalProperties, [mn]) }, n, a, o) : "type" in i.additionalProperties ? l = { ...i.additionalProperties } : At in i.additionalProperties || gt in i.additionalProperties ? l = {
            type: "object",
            ...i.additionalProperties
          } : l = { type: xh(Ee(a, [s])) } : l = { type: xh(Ee(a, [s])) }, i.properties[s] = l, Xt(i.properties, [s, $a], !0);
        } else
          i.properties[s] = { type: "null" }, Xt(i.properties, [s, $a], !0);
      }
    }), i;
  }
  const { compareSchemaDefinitions: JMe, compareSchemaValues: ePe } = hNe(), { mergeArrayOfSchemaDefinitions: tPe } = _Ne({
    intersectJson: lNe(ePe),
    deduplicateJsonSchemaDef: CH(JMe)
  }), nPe = CNe(tPe);
  function rPe(e) {
    return nPe(e);
  }
  function Mi(e, t, n, r, o = !1, i = [], a, s) {
    return Rt(t) ? ZMe(e, t, n, o, i, r, a, s).flatMap((u) => {
      var d;
      let p = u;
      if (rTe in p)
        return XMe(e, p, n, o, i, r, a);
      if (ol in p) {
        if (o) {
          const { allOf: g, ...y } = p;
          return [...g, y];
        }
        try {
          const g = [], y = [];
          (d = p.allOf) === null || d === void 0 || d.forEach((b) => {
            typeof b == "object" && b.contains ? g.push(b) : y.push(b);
          }), g.length && (p = { ...p, allOf: y }), p = a ? a(p) : rPe(p), g.length && (p.allOf = g);
        } catch (g) {
          console.warn(`could not merge subschemas in allOf:
`, g);
          const { allOf: y, ...b } = p;
          return b;
        }
      }
      return It in p && RC in p && (p = Object.keys(p.properties).reduce((g, y) => {
        const b = BH(g, y);
        return Un(b) || (g.properties[y] = yr(e, { allOf: [g.properties[y], ...Object.values(b)] }, n, Ee(r, [y]), a)), g;
      }, {
        ...p,
        properties: { ...p.properties }
      })), RC in p || O0 in p && p.additionalProperties !== !1 ? QMe(e, p, n, r, a) : p;
    }) : [{}];
  }
  function oPe(e, t, n, r, o) {
    let i;
    const { oneOf: a, anyOf: s, ...l } = t;
    if (Array.isArray(a) ? i = a : Array.isArray(s) && (i = s), i) {
      const u = o === void 0 && r ? {} : o, d = Wi(t);
      i = i.map((h) => ef(h, n, []));
      const p = WR(e, u, i, n, d);
      if (r)
        return i.map((h) => Ha(l, h));
      t = Ha(l, i[p]);
    }
    return [t];
  }
  function VH(e, t, n, r, o, i, a) {
    const { dependencies: s, ...l } = t;
    return oPe(e, l, n, r, i).flatMap((d) => HH(e, s, d, n, r, o, i, a));
  }
  function HH(e, t, n, r, o, i, a, s) {
    let l = [n];
    for (const u in t) {
      if (!o && Ee(a, [u]) === void 0 || n.properties && !(u in n.properties))
        continue;
      const [d, p] = qR(u, t);
      return Array.isArray(p) ? l[0] = iPe(n, p) : Rt(p) && (l = aPe(e, n, r, u, p, o, i, a, s)), l.flatMap((h) => HH(e, d, h, r, o, i, a, s));
    }
    return l;
  }
  function iPe(e, t) {
    if (!t)
      return e;
    const n = Array.isArray(e.required) ? Array.from(/* @__PURE__ */ new Set([...e.required, ...t])) : t;
    return { ...e, required: n };
  }
  function aPe(e, t, n, r, o, i, a, s, l) {
    return Mi(e, o, n, s, i, a, l).flatMap((d) => {
      const { oneOf: p, ...h } = d;
      if (t = Ha(t, h), p === void 0)
        return t;
      const g = p.map((b) => typeof b == "boolean" || !(mn in b) ? [b] : UH(e, b, n, i, a, s));
      return zH(g).flatMap((b) => sPe(e, t, n, r, b, i, a, s, l));
    });
  }
  function sPe(e, t, n, r, o, i, a, s, l) {
    const u = o.filter((d) => {
      if (typeof d == "boolean" || !d || !d.properties)
        return !1;
      const { [r]: p } = d.properties;
      if (p) {
        const h = {
          type: "object",
          properties: {
            [r]: p
          }
        };
        return e.isValid(h, s, n) || i;
      }
      return !1;
    });
    return !i && u.length !== 1 ? (console.warn("ignoring oneOf in dependencies because there isn't exactly one subschema that is valid"), [t]) : u.flatMap((d) => {
      const p = d, [h] = qR(r, p.properties), g = { ...p, properties: h };
      return Mi(e, g, n, s, i, a, l).map((b) => Ha(t, b));
    });
  }
  function wp(e, t, n, r, o, i = {}, a) {
    if (Array.isArray(n[o])) {
      const l = Wi(n) || r, u = n[o].map((p) => yr(e, p, t, i, a)), d = Ee(i, l);
      if (d !== void 0)
        return u.find((p) => yh(Ee(p, [It, l, l1], Ee(p, [It, l, Oo])), d));
    }
  }
  function qH(e, t, n, r, o) {
    let i = n;
    if (kt(n, mn) && (i = yr(e, n, t, void 0, o)), Un(r))
      return i;
    const a = Array.isArray(r) ? r : r.split("."), [s, ...l] = a;
    if (s && kt(i, s))
      return i = Ee(i, s), qH(e, t, i, l, o);
  }
  function Pv(e, t, n, r, o, i) {
    const a = qH(e, t, n, r, i);
    return a === void 0 ? o : a;
  }
  const WD = { title: "!@#$_UNKNOWN_$#@!" };
  function lPe(e, t, n, r, o = {}, i) {
    const a = Array.isArray(r) ? [...r] : r.split(".");
    let s = n;
    const l = a.pop();
    a.length && a.forEach((h) => {
      s = Pv(e, t, s, [It, h], {}, i), kt(s, gt) ? s = wp(e, t, s, l, gt, Ee(o, h), i) : kt(s, At) && (s = wp(e, t, s, l, At, Ee(o, h), i));
    }), kt(s, gt) ? s = wp(e, t, s, l, gt, o, i) : kt(s, At) && (s = wp(e, t, s, l, At, o, i));
    let u = Pv(e, t, s, [It, l], WD, i);
    u === WD && (u = void 0);
    const d = Pv(e, t, s, LV, [], i);
    let p;
    return u && Array.isArray(d) && (p = d.includes(l)), { field: u, isRequired: p };
  }
  function cPe(e, t, n, r) {
    var o = -1, i = e == null ? 0 : e.length;
    for (r && i && (n = e[++o]); ++o < i; )
      n = t(n, e[o], o, e);
    return n;
  }
  function uPe(e, t) {
    return function(n, r) {
      if (n == null)
        return n;
      if (!Ec(n))
        return e(n, r);
      for (var o = n.length, i = -1, a = Object(n); ++i < o && r(a[i], i, a) !== !1; )
        ;
      return n;
    };
  }
  var WH = uPe(fH);
  function fPe(e, t, n, r, o) {
    return o(e, function(i, a, s) {
      n = r ? (r = !1, i) : t(n, i, a, s);
    }), n;
  }
  function dPe(e, t, n) {
    var r = Kn(e) ? cPe : fPe, o = arguments.length < 3;
    return r(e, LR(t), n, o, WH);
  }
  const pPe = {
    type: "object",
    $id: oTe,
    properties: {
      __not_really_there__: {
        type: "number"
      }
    }
  };
  function LC(e, t, n, r, o) {
    let i = 0;
    return n && (Pt(n.properties) ? i += dPe(n.properties, (a, s, l) => {
      const u = Ee(r, l);
      if (typeof s == "boolean")
        return a;
      if (kt(s, mn)) {
        const d = yr(e, s, t, u, o);
        return a + LC(e, t, d, u || {}, o);
      }
      if ((kt(s, gt) || kt(s, At)) && u) {
        const d = kt(s, gt) ? gt : At, p = Wi(s);
        return a + wh(e, t, u, Ee(s, d), -1, p, o);
      }
      if (s.type === "object")
        return Pt(u) && (a += 1), a + LC(e, t, s, u, o);
      if (s.type === xh(u)) {
        let d = a + 1;
        return s.default ? d += u === s.default ? 1 : -1 : s.const && (d += u === s.const ? 1 : -1), d;
      }
      return a;
    }, 0) : al(n.type) && n.type === xh(r) && (i += 1)), i;
  }
  function wh(e, t, n, r, o = -1, i, a) {
    const s = r.map((h) => ef(h, t, [])), l = LH(n, r, i);
    if (FH(l))
      return l;
    const u = s.reduce((h, g, y) => (WR(e, n, [pPe, g], t, i) === 1 && h.push(y), h), []);
    if (u.length === 1)
      return u[0];
    u.length || lH(s.length, (h) => u.push(h));
    const d = /* @__PURE__ */ new Set(), { bestIndex: p } = u.reduce((h, g) => {
      const { bestScore: y } = h, b = s[g], v = LC(e, t, b, n, a);
      return d.add(v), v > y ? { bestIndex: g, bestScore: v } : h;
    }, { bestIndex: o, bestScore: 0 });
    return d.size === 1 && o >= 0 ? o : p;
  }
  function GR(e) {
    return Array.isArray(e.items) && e.items.length > 0 && e.items.every((t) => Rt(t));
  }
  function $0(e) {
    return e == null;
  }
  function Sh(e, t, n = !1, r = !1, o = !1) {
    if (Array.isArray(t)) {
      const i = Array.isArray(e) ? e : [], a = o ? i : t, s = o ? t : i, l = a.map((u, d) => s[d] !== void 0 ? Sh(i[d], t[d], n, r, o) : u);
      return (n || o) && l.length < s.length && l.push(...s.slice(l.length)), l;
    }
    if (Rt(t)) {
      const i = Object.assign({}, e);
      return Object.keys(t).reduce((a, s) => {
        var l;
        const u = Ee(t, s), d = Rt(e) && s in e, p = s in t, h = (l = Ee(e, s)) !== null && l !== void 0 ? l : {}, g = d && Object.entries(h).some(([, v]) => Rt(v)), y = d && Rt(Ee(e, s)), b = p && Rt(u);
        return y && b && !g ? (a[s] = {
          ...Ee(e, s),
          ...u
        }, a) : (a[s] = Sh(
          Ee(e, s),
          u,
          n,
          r,
          // overrideFormDataWithDefaults can be true only when the key value exists in defaults
          // Or if the key value doesn't exist in formData
          o && (d || !p)
        ), a);
      }, i);
    }
    return r && (e !== void 0 && $0(t) || typeof t == "number" && isNaN(t)) || o && !$0(t) ? e : t;
  }
  function _h(e, t, n = !1) {
    return Object.keys(t).reduce((r, o) => {
      const i = e ? e[o] : {}, a = t[o];
      if (e && o in e && Rt(a))
        r[o] = _h(i, a, n);
      else if (n && Array.isArray(i) && Array.isArray(a)) {
        let s = a;
        n === "preventDuplicates" && (s = a.reduce((l, u) => (i.includes(u) || l.push(u), l), [])), r[o] = i.concat(s);
      } else
        r[o] = a;
      return r;
    }, Object.assign({}, e));
  }
  function GH(e) {
    return Array.isArray(e.enum) && e.enum.length === 1 || Oo in e;
  }
  function KR(e, t, n = {}, r) {
    const o = yr(e, t, n, void 0, r), i = o.oneOf || o.anyOf;
    return Array.isArray(o.enum) ? !0 : Array.isArray(i) ? i.every((a) => typeof a != "boolean" && GH(a)) : !1;
  }
  function YR(e, t, n, r) {
    return !t.uniqueItems || !t.items || typeof t.items == "boolean" ? !1 : KR(e, t.items, n, r);
  }
  function KH(e) {
    const t = e[Oo], n = Qo(e);
    return Rt(t) && al(t?.$data) && n !== "object" && n !== "array";
  }
  function hPe(e) {
    if (nTe in e && Array.isArray(e.enum) && e.enum.length === 1)
      return e.enum[0];
    if (Oo in e)
      return e.const;
    throw new Error("schema cannot be inferred as a constant");
  }
  function bf(e, t) {
    if (e.enum) {
      let i;
      if (t) {
        const { enumNames: a } = Ze(t);
        i = a;
      }
      return e.enum.map((a, s) => ({ label: i?.[s] || String(a), value: a }));
    }
    let n, r;
    e.anyOf ? (n = e.anyOf, r = t?.anyOf) : e.oneOf && (n = e.oneOf, r = t?.oneOf);
    let o = Wi(e);
    if (t) {
      const { optionsSchemaSelector: i = o } = Ze(t);
      o = i;
    }
    return n && n.map((i, a) => {
      const { title: s } = Ze(r?.[a]), l = i;
      let u, d = s;
      if (o) {
        const p = Ee(l, [It, o], {});
        u = Ee(p, l1, Ee(p, Oo)), d = d || p?.title || l.title || String(u);
      } else
        u = hPe(l), d = d || l.title || String(u);
      return {
        schema: l,
        label: d,
        value: u
      };
    });
  }
  const mPe = ["string", "number", "integer", "boolean", "null"];
  var xf;
  (function(e) {
    e[e.Ignore = 0] = "Ignore", e[e.Invert = 1] = "Invert", e[e.Fallback = 2] = "Fallback";
  })(xf || (xf = {}));
  function O_(e, t = xf.Ignore, n = -1) {
    if (n >= 0) {
      if (Array.isArray(e.items) && n < e.items.length) {
        const r = e.items[n];
        if (typeof r != "boolean")
          return r;
      }
    } else if (e.items && !Array.isArray(e.items) && typeof e.items != "boolean")
      return e.items;
    return t !== xf.Ignore && Rt(e.additionalItems) ? e.additionalItems : {};
  }
  function YH(e, t) {
    const { default: n, type: r } = e;
    return Array.isArray(r) && r.includes("null") && Un(t) && n === null ? null : t;
  }
  function GD(e, t, n, r, o, i = [], a = {}, s = !1, l = !1) {
    const { emptyObjectFields: u = "populateAllDefaults" } = a;
    if (r === !0 || s)
      e[t] = n;
    else if (r === "excludeObjectChildren")
      (l && n !== void 0 || !Rt(n) || !Un(n)) && (e[t] = n);
    else if (u !== "skipDefaults") {
      const d = o === void 0 ? i.includes(t) : o;
      Rt(n) ? u === "skipEmptyDefaults" ? Un(n) || (e[t] = n) : (!Un(n) || i.includes(t)) && (d || u !== "populateRequiredDefaults") && (e[t] = n) : (
        // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions
        // Condition 1: computedDefault is not undefined
        // Condition 2: If emptyObjectFields is 'populateAllDefaults' or 'skipEmptyDefaults)
        // Or if isSelfOrParentRequired is 'true' and the key is a required field
        n !== void 0 && (u === "populateAllDefaults" || u === "skipEmptyDefaults" || d && i.includes(t)) && (e[t] = n)
      );
    }
  }
  function Ks(e, t, n = {}) {
    const { parentDefaults: r, rawFormData: o, rootSchema: i = {}, includeUndefinedValues: a = !1, _recurseList: s = [], experimental_defaultFormStateBehavior: l = void 0, experimental_customMergeAllOf: u = void 0, required: d, shouldMergeDefaultsIntoFormData: p = !1, initialDefaultsGenerated: h } = n;
    let g = Rt(o) ? o : {};
    const y = Rt(t) ? t : {};
    let b = r, v = null, x = l, E = s;
    if (y[Oo] !== void 0 && l?.constAsDefaults !== "never" && !KH(y))
      b = y[Oo];
    else if (Rt(b) && Rt(y.default))
      b = _h(b, y.default);
    else if (l1 in y && !y[At] && !y[gt] && !y[mn])
      b = y.default;
    else if (mn in y) {
      const k = y[mn];
      s.includes(k) || (E = s.concat(k), v = DH(k, i)), v && !b && (b = y.default), p && v && !Rt(o) && (g = o);
    } else if (ER in y) {
      const k = {
        ...KD(e, y, n, b),
        ...g
      };
      v = VH(e, y, i, !1, [], k, u)[0];
    } else if (GR(y))
      b = y.items.map((k, R) => Ks(e, k, {
        rootSchema: i,
        includeUndefinedValues: a,
        _recurseList: s,
        experimental_defaultFormStateBehavior: l,
        experimental_customMergeAllOf: u,
        parentDefaults: Array.isArray(r) ? r[R] : void 0,
        rawFormData: g,
        required: d,
        shouldMergeDefaultsIntoFormData: p
      }));
    else if (gt in y) {
      const { oneOf: k, ...R } = y;
      if (k.length === 0)
        return;
      const A = Wi(y), { type: M = "null" } = R;
      !Array.isArray(M) && mPe.includes(M) && x?.constAsDefaults === "skipOneOf" && (x = {
        ...x,
        constAsDefaults: "never"
      }), v = k[wh(e, i, o ?? y.default, k, 0, A, u)], v = Ha(R, v);
    } else if (At in y) {
      const { anyOf: k, ...R } = y;
      if (k.length === 0)
        return;
      const A = Wi(y);
      v = k[wh(e, i, o ?? y.default, k, 0, A, u)], v = Ha(R, v);
    }
    if (v)
      return Ks(e, v, {
        rootSchema: i,
        includeUndefinedValues: a,
        _recurseList: E,
        experimental_defaultFormStateBehavior: x,
        experimental_customMergeAllOf: u,
        parentDefaults: b,
        rawFormData: o ?? g,
        required: d,
        shouldMergeDefaultsIntoFormData: p,
        initialDefaultsGenerated: h
      });
    b === void 0 && (b = y.default);
    const _ = KD(e, y, n, b);
    let C = _ ?? b;
    if (p) {
      const { arrayMinItems: k = {} } = l || {}, { mergeExtraDefaults: R } = k, A = gPe(e, y, i, o, l, u);
      (!Rt(o) || ol in y) && (C = Sh(C, A, R, !0));
    }
    return C;
  }
  function gPe(e, t, n, r, o, i) {
    const a = !GH(t) && KR(e, t, n, i);
    let s = r;
    if (a) {
      const u = bf(t);
      s = u?.some((p) => fn(p.value, r)) ? r : void 0;
    }
    return t[Oo] && o?.constAsDefaults === "always" && (s = t.const), s;
  }
  function yPe(e, t, { rawFormData: n, rootSchema: r = {}, includeUndefinedValues: o = !1, _recurseList: i = [], experimental_defaultFormStateBehavior: a = void 0, experimental_customMergeAllOf: s = void 0, required: l, shouldMergeDefaultsIntoFormData: u, initialDefaultsGenerated: d } = {}, p) {
    {
      const h = Rt(n) ? n : {}, g = t, y = a?.allOf === "populateDefaults" && ol in g ? yr(e, g, r, h, s) : g, b = y[Oo], v = Object.keys(y.properties || {}).reduce((x, E) => {
        var _;
        const C = Ee(y, [It, E], {}), k = Rt(b) && b[E] !== void 0, R = (Rt(C) && Oo in C || k) && a?.constAsDefaults !== "never" && !KH(C), A = Ks(e, C, {
          rootSchema: r,
          _recurseList: i,
          experimental_defaultFormStateBehavior: a,
          experimental_customMergeAllOf: s,
          includeUndefinedValues: o === !0,
          parentDefaults: Ee(p, [E]),
          rawFormData: Ee(h, [E]),
          required: (_ = y.required) === null || _ === void 0 ? void 0 : _.includes(E),
          shouldMergeDefaultsIntoFormData: u,
          initialDefaultsGenerated: d
        });
        return GD(x, E, A, o, l, y.required, a, R, C?.type === "null"), x;
      }, {});
      if (y.additionalProperties && !d) {
        const x = Rt(y.additionalProperties) ? y.additionalProperties : {}, E = /* @__PURE__ */ new Set();
        Rt(p) && Object.keys(p).filter((C) => !y.properties || !y.properties[C]).forEach((C) => E.add(C));
        const _ = [];
        Object.keys(h).filter((C) => !y.properties || !y.properties[C]).forEach((C) => {
          E.add(C), _.push(C);
        }), E.forEach((C) => {
          var k;
          const R = Ks(e, x, {
            rootSchema: r,
            _recurseList: i,
            experimental_defaultFormStateBehavior: a,
            experimental_customMergeAllOf: s,
            includeUndefinedValues: o === !0,
            parentDefaults: Ee(p, [C]),
            rawFormData: Ee(h, [C]),
            required: (k = y.required) === null || k === void 0 ? void 0 : k.includes(C),
            shouldMergeDefaultsIntoFormData: u,
            initialDefaultsGenerated: d
          });
          GD(v, C, R, o, l, _);
        });
      }
      return YH(t, v);
    }
  }
  function vPe(e, t, { rawFormData: n, rootSchema: r = {}, _recurseList: o = [], experimental_defaultFormStateBehavior: i = void 0, experimental_customMergeAllOf: a = void 0, required: s, requiredAsRoot: l = !1, shouldMergeDefaultsIntoFormData: u, initialDefaultsGenerated: d } = {}, p) {
    var h, g;
    const y = t, b = (h = i?.arrayMinItems) !== null && h !== void 0 ? h : {}, { populate: v, mergeExtraDefaults: x } = b, E = v === "never", _ = v === "requiredOnly", C = v === "all" || !E && !_, k = (g = b?.computeSkipPopulate) !== null && g !== void 0 ? g : () => !1, A = i?.emptyObjectFields === "skipEmptyDefaults" ? void 0 : [];
    if (Array.isArray(p) && (p = p.map((L, P) => {
      const B = O_(y, xf.Fallback, P);
      return Ks(e, B, {
        rootSchema: r,
        _recurseList: o,
        experimental_defaultFormStateBehavior: i,
        experimental_customMergeAllOf: a,
        parentDefaults: L,
        required: s,
        shouldMergeDefaultsIntoFormData: u,
        initialDefaultsGenerated: d
      });
    })), Array.isArray(n)) {
      const L = O_(y);
      if (E)
        p = n;
      else {
        const P = n.map((j, V) => Ks(e, L, {
          rootSchema: r,
          _recurseList: o,
          experimental_defaultFormStateBehavior: i,
          experimental_customMergeAllOf: a,
          rawFormData: j,
          parentDefaults: Ee(p, [V]),
          required: s,
          shouldMergeDefaultsIntoFormData: u,
          initialDefaultsGenerated: d
        }));
        p = Sh(p, P, (_ && s || C) && x);
      }
    }
    if ((Rt(y) && Oo in y && i?.constAsDefaults !== "never") === !1) {
      if (E)
        return p ?? A;
      if (_ && !s)
        return p || void 0;
    }
    let I;
    const D = Array.isArray(p) ? p.length : 0;
    if (!y.minItems || YR(e, y, r, a) || k(e, y, r) || y.minItems <= D)
      I = p || !s && !l ? p : A;
    else {
      const L = p || [], P = O_(y, xf.Invert), B = P.default, j = Array.from({ length: y.minItems - D }, () => Ks(e, P, {
        parentDefaults: B,
        rootSchema: r,
        _recurseList: o,
        experimental_defaultFormStateBehavior: i,
        experimental_customMergeAllOf: a,
        required: s,
        shouldMergeDefaultsIntoFormData: u
      }));
      I = L.concat(j);
    }
    return YH(t, I);
  }
  function KD(e, t, n = {}, r) {
    switch (Qo(t)) {
      // We need to recurse for object schema inner default values.
      case "object":
        return yPe(e, t, n, r);
      case "array":
        return vPe(e, t, n, r);
    }
  }
  function XH(e, t, n, r, o = !1, i, a, s) {
    if (!Rt(t))
      throw new Error("Invalid schema: " + t);
    const l = yr(e, t, r, n, a), u = Ks(e, l, {
      rootSchema: r,
      includeUndefinedValues: o,
      experimental_defaultFormStateBehavior: i,
      experimental_customMergeAllOf: a,
      rawFormData: n,
      shouldMergeDefaultsIntoFormData: !0,
      initialDefaultsGenerated: s,
      requiredAsRoot: !0
    });
    if (l.type !== "object" && Rt(l.default))
      return {
        ...u,
        ...n
      };
    if (Rt(n) || Array.isArray(n)) {
      const { mergeDefaultsIntoFormData: d } = i || {};
      return Sh(
        u,
        n,
        !0,
        d === "useDefaultIfFormDataUndefined",
        !0
      );
    }
    return u;
  }
  function ZH(e = {}) {
    return (
      // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.
      // https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets
      "widget" in Ze(e) && Ze(e).widget !== "hidden"
    );
  }
  function QH(e, t, n = {}, r, o) {
    if (n[kR] === "files")
      return !0;
    if (t.items) {
      const i = yr(e, t.items, r, void 0, o);
      return i.type === "string" && i.format === "data-url";
    }
    return !1;
  }
  function bPe(e, t, n = {}, r, o, i) {
    const a = Ze(n, o), { label: s = !0 } = a;
    let l = !!s;
    if (l) {
      const u = Qo(t), d = Ee(t, $a, !1);
      u === "array" && (l = d || YR(e, t, r, i) || QH(e, t, n, r, i) || ZH(n)), u === "object" && (l = d), u === "boolean" && n && !n[kR] && (l = !1), n && n[sTe] && (l = !1);
    }
    return l;
  }
  const ku = Symbol("no Value");
  function zC(e, t, n, r, o = {}, i) {
    let a;
    if (kt(n, It)) {
      const s = {};
      if (kt(r, It)) {
        const d = Ee(r, It, {});
        Object.keys(d).forEach((p) => {
          kt(o, p) && (s[p] = void 0);
        });
      }
      const l = Object.keys(Ee(n, It, {})), u = {};
      l.forEach((d) => {
        const p = Ee(o, d);
        let h = Ee(r, [It, d], {}), g = Ee(n, [It, d], {});
        kt(h, mn) && (h = yr(e, h, t, p, i)), kt(g, mn) && (g = yr(e, g, t, p, i));
        const y = Ee(h, "type"), b = Ee(g, "type");
        if (!y || y === b)
          if (kt(s, d) && delete s[d], b === "object" || b === "array" && Array.isArray(p)) {
            const v = zC(e, t, g, h, p, i);
            (v !== void 0 || b === "array") && (u[d] = v);
          } else {
            const v = Ee(g, "default", ku), x = Ee(h, "default", ku);
            v !== ku && v !== p && (x === p ? s[d] = v : Ee(g, "readOnly") === !0 && (s[d] = void 0));
            const E = Ee(g, "const", ku), _ = Ee(h, "const", ku);
            E !== ku && E !== p && (s[d] = _ === p ? E : void 0);
          }
      }), a = {
        ...typeof o == "string" || Array.isArray(o) ? void 0 : o,
        ...s,
        ...u
      };
    } else if (Ee(r, "type") === "array" && Ee(n, "type") === "array" && Array.isArray(o)) {
      let s = Ee(r, "items"), l = Ee(n, "items");
      if (typeof s == "object" && typeof l == "object" && !Array.isArray(s) && !Array.isArray(l)) {
        kt(s, mn) && (s = yr(e, s, t, o, i)), kt(l, mn) && (l = yr(e, l, t, o, i));
        const u = Ee(s, "type"), d = Ee(l, "type");
        if (!u || u === d) {
          const p = Ee(n, "maxItems", -1);
          d === "object" ? a = o.reduce((h, g) => {
            const y = zC(e, t, l, s, g, i);
            return y !== void 0 && (p < 0 || h.length < p) && h.push(y), h;
          }, []) : a = p > 0 && o.length > p ? o.slice(0, p) : o;
        }
      } else typeof s == "boolean" && typeof l == "boolean" && s === l && (a = o);
    }
    return a;
  }
  function Hl(e, t, n, r, o, i = [], a) {
    if (mn in t || ER in t || ol in t) {
      const l = yr(e, t, r, o, a);
      if (i.findIndex((d) => fn(d, l)) === -1)
        return Hl(e, l, n, r, o, i.concat(l), a);
    }
    let s = {
      [Ov]: n.replace(/^\./, "")
    };
    if (gt in t || At in t) {
      const l = gt in t ? t.oneOf : t.anyOf, u = Wi(t), d = wh(e, r, o, l, 0, u, a), p = l[d];
      s = {
        ...s,
        ...Hl(e, p, n, r, o, i, a)
      };
    }
    if (O0 in t && t[O0] !== !1 && Xt(s, CR, !0), gf in t && Array.isArray(o)) {
      const { items: l, additionalItems: u } = t;
      Array.isArray(l) ? o.forEach((d, p) => {
        l[p] ? s[p] = Hl(e, l[p], `${n}.${p}`, r, d, i, a) : u ? s[p] = Hl(e, u, `${n}.${p}`, r, d, i, a) : console.warn(`Unable to generate path schema for "${n}.${p}". No schema defined for it`);
      }) : o.forEach((d, p) => {
        s[p] = Hl(e, l, `${n}.${p}`, r, d, i, a);
      });
    } else if (It in t)
      for (const l in t.properties) {
        const u = Ee(t, [It, l], {});
        s[l] = Hl(
          e,
          u,
          `${n}.${l}`,
          r,
          // It's possible that formData is not an object -- this can happen if an
          // array item has just been added, but not populated with data yet
          Ee(o, [l]),
          i,
          a
        );
      }
    return s;
  }
  function xPe(e, t, n = "", r, o, i) {
    return Hl(e, t, n, r, o, void 0, i);
  }
  class wPe {
    /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables
     *
     * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs
     * @param rootSchema - The root schema that will be forwarded to all the APIs
     * @param experimental_defaultFormStateBehavior - Configuration flags to allow users to override default form state behavior
     * @param [experimental_customMergeAllOf] - Optional function that allows for custom merging of `allOf` schemas
     */
    constructor(t, n, r, o) {
      n && n[bp] === Av ? this.rootSchema = FC(n, Ee(n, nn, "#")) : this.rootSchema = n, this.validator = t, this.experimental_defaultFormStateBehavior = r, this.experimental_customMergeAllOf = o;
    }
    /** Returns the `rootSchema` in the `SchemaUtilsType`
     *
     * @returns - The `rootSchema`
     */
    getRootSchema() {
      return this.rootSchema;
    }
    /** Returns the `ValidatorType` in the `SchemaUtilsType`
     *
     * @returns - The `ValidatorType`
     */
    getValidator() {
      return this.validator;
    }
    /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of
     * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation
     * of a new `SchemaUtilsType` with incomplete properties.
     *
     * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one
     * @param rootSchema - The root schema that will be compared against the current one
     * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior
     * @param [experimental_customMergeAllOf] - Optional function that allows for custom merging of `allOf` schemas
     * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`
     */
    doesSchemaUtilsDiffer(t, n, r = {}, o) {
      return !t || !n ? !1 : this.validator !== t || !fn(this.rootSchema, n) || !fn(this.experimental_defaultFormStateBehavior, r) || this.experimental_customMergeAllOf !== o;
    }
    /** Finds the field specified by the `path` within the root or recursed `schema`. If there is no field for the specified
     * `path`, then the default `{ field: undefined, isRequired: undefined }` is returned. It determines whether a leaf
     * field is in the `required` list for its parent and if so, it is marked as required on return.
     *
     * @param schema - The current node within the JSON schema
     * @param path - The remaining keys in the path to the desired field
     * @param [formData] - The form data that is used to determine which oneOf option
     * @returns - An object that contains the field and its required state. If no field can be found then
     *            `{ field: undefined, isRequired: undefined }` is returned.
     */
    findFieldInSchema(t, n, r) {
      return lPe(this.validator, this.rootSchema, t, n, r, this.experimental_customMergeAllOf);
    }
    /** Finds the oneOf option inside the `schema['any/oneOf']` list which has the `properties[selectorField].default` that
     * matches the `formData[selectorField]` value. For the purposes of this function, `selectorField` is either
     * `schema.discriminator.propertyName` or `fallbackField`.
     *
     * @param schema - The schema element in which to search for the selected oneOf option
     * @param fallbackField - The field to use as a backup selector field if the schema does not have a required field
     * @param xxx - Either `oneOf` or `anyOf`, defines which value is being sought
     * @param [formData={}] - The form data that is used to determine which oneOf option
     * @returns - The anyOf/oneOf option that matches the selector field in the schema or undefined if nothing is selected
     */
    findSelectedOptionInXxxOf(t, n, r, o) {
      return wp(this.validator, this.rootSchema, t, n, r, o, this.experimental_customMergeAllOf);
    }
    /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have
     * computed to have defaults provided in the `schema`.
     *
     * @param schema - The schema for which the default state is desired
     * @param [formData] - The current formData, if any, onto which to provide any missing defaults
     * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.
     *          If "excludeObjectChildren", pass `includeUndefinedValues` as false when computing defaults for any nested
     *          object properties.
     * @param initialDefaultsGenerated - Indicates whether or not initial defaults have been generated
     * @returns - The resulting `formData` with all the defaults provided
     */
    getDefaultFormState(t, n, r = !1, o) {
      return XH(this.validator, t, n, this.rootSchema, r, this.experimental_defaultFormStateBehavior, this.experimental_customMergeAllOf, o);
    }
    /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`
     * should be displayed in a UI.
     *
     * @param schema - The schema for which the display label flag is desired
     * @param [uiSchema] - The UI schema from which to derive potentially displayable information
     * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options
     * @returns - True if the label should be displayed or false if it should not
     */
    getDisplayLabel(t, n, r) {
      return bPe(this.validator, t, n, this.rootSchema, r, this.experimental_customMergeAllOf);
    }
    /** Determines which of the given `options` provided most closely matches the `formData`.
     * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.
     *
     * The closest match is determined using the number of matching properties, and more heavily favors options with
     * matching readOnly, default, or const values.
     *
     * @param formData - The form data associated with the schema
     * @param options - The list of options that can be selected from
     * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified
     * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
     *          determine which option is selected
     * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match
     */
    getClosestMatchingOption(t, n, r, o) {
      return wh(this.validator, this.rootSchema, t, n, r, o, this.experimental_customMergeAllOf);
    }
    /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.
     * Always returns the first option if there is nothing that matches.
     *
     * @param formData - The current formData, if any, used to figure out a match
     * @param options - The list of options to find a matching options from
     * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
     *          determine which option is selected
     * @returns - The firstindex of the matched option or 0 if none is available
     */
    getFirstMatchingOption(t, n, r) {
      return WR(this.validator, t, n, this.rootSchema, r);
    }
    getFromSchema(t, n, r) {
      return Pv(
        this.validator,
        this.rootSchema,
        t,
        n,
        // @ts-expect-error TS2769: No overload matches this call
        r,
        this.experimental_customMergeAllOf
      );
    }
    /** Checks to see if the `schema` and `uiSchema` combination represents an array of files
     *
     * @param schema - The schema for which check for array of files flag is desired
     * @param [uiSchema] - The UI schema from which to check the widget
     * @returns - True if schema/uiSchema contains an array of files, otherwise false
     */
    isFilesArray(t, n) {
      return QH(this.validator, t, n, this.rootSchema, this.experimental_customMergeAllOf);
    }
    /** Checks to see if the `schema` combination represents a multi-select
     *
     * @param schema - The schema for which check for a multi-select flag is desired
     * @returns - True if schema contains a multi-select, otherwise false
     */
    isMultiSelect(t) {
      return YR(this.validator, t, this.rootSchema, this.experimental_customMergeAllOf);
    }
    /** Checks to see if the `schema` combination represents a select
     *
     * @param schema - The schema for which check for a select flag is desired
     * @returns - True if schema contains a select, otherwise false
     */
    isSelect(t) {
      return KR(this.validator, t, this.rootSchema, this.experimental_customMergeAllOf);
    }
    /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and
     * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially
     * recursive resolution.
     *
     * @param schema - The schema for which retrieving a schema is desired
     * @param [rawFormData] - The current formData, if any, to assist retrieving a schema
     * @param [resolveAnyOfOrOneOfRefs] - Optional flag indicating whether to resolved refs in anyOf/oneOf lists
     * @returns - The schema having its conditions, additional properties, references and dependencies resolved
     */
    retrieveSchema(t, n, r) {
      return yr(this.validator, t, this.rootSchema, n, this.experimental_customMergeAllOf, r);
    }
    /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the
     * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the
     * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the
     * old schemas that are non-existent in the new schema are set to `undefined`.
     *
     * @param [newSchema] - The new schema for which the data is being sanitized
     * @param [oldSchema] - The old schema from which the data originated
     * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined
     * @returns - The new form data, with all the fields uniquely associated with the old schema set
     *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.
     */
    sanitizeDataForNewSchema(t, n, r) {
      return zC(this.validator, this.rootSchema, t, n, r, this.experimental_customMergeAllOf);
    }
    /** Generates an `PathSchema` object for the `schema`, recursively
     *
     * @param schema - The schema for which the display label flag is desired
     * @param [name] - The base name for the schema
     * @param [formData] - The current formData, if any, onto which to provide any missing defaults
     * @returns - The `PathSchema` object for the `schema`
     */
    toPathSchema(t, n, r) {
      return xPe(this.validator, t, n, this.rootSchema, r, this.experimental_customMergeAllOf);
    }
  }
  function SPe(e, t, n = {}, r) {
    return new wPe(e, t, n, r);
  }
  function _Pe(e) {
    var t;
    if (e.indexOf("data:") === -1)
      throw new Error("File is invalid: URI must be a dataURI");
    const r = e.slice(5).split(";base64,");
    if (r.length !== 2)
      throw new Error("File is invalid: dataURI must be base64");
    const [o, i] = r, [a, ...s] = o.split(";"), l = a || "", u = decodeURI(
      // parse the parameters into key-value pairs, find a key, and extract a value
      // if no key is found, then the name is unknown
      ((t = s.map((d) => d.split("=")).find(([d]) => d === "name")) === null || t === void 0 ? void 0 : t[1]) || "unknown"
    );
    try {
      const d = atob(i), p = new Array(d.length);
      for (let g = 0; g < d.length; g++)
        p[g] = d.charCodeAt(g);
      return { blob: new window.Blob([new Uint8Array(p)], { type: l }), name: u };
    } catch (d) {
      throw new Error("File is invalid: " + d.message);
    }
  }
  function Ds(e, t) {
    let n = String(e);
    for (; n.length < t; )
      n = "0" + n;
    return n;
  }
  function JH(e, t) {
    if (e <= 0 && t <= 0)
      e = (/* @__PURE__ */ new Date()).getFullYear() + e, t = (/* @__PURE__ */ new Date()).getFullYear() + t;
    else if (e < 0 || t < 0)
      throw new Error(`Both start (${e}) and stop (${t}) must both be <= 0 or > 0, got one of each`);
    if (e > t)
      return JH(t, e).reverse();
    const n = [];
    for (let r = e; r <= t; r++)
      n.push({ value: r, label: Ds(r, 2) });
    return n;
  }
  function YD(e, t) {
    if (Object.is(e, t))
      return !0;
    if (e == null || t == null || typeof e != "object" || typeof t != "object")
      return !1;
    const n = Object.keys(e), r = Object.keys(t);
    if (n.length !== r.length)
      return !1;
    for (let o = 0; o < n.length; o++) {
      const i = n[o];
      if (!Object.prototype.hasOwnProperty.call(t, i) || !Object.is(e[i], t[i]))
        return !1;
    }
    return !0;
  }
  function EPe(e, t) {
    let n = e;
    if (Array.isArray(t)) {
      const r = n.split(/(%\d)/);
      t.forEach((o, i) => {
        const a = r.findIndex((s) => s === `%${i + 1}`);
        a >= 0 && (r[a] = o);
      }), n = r.join("");
    }
    return n;
  }
  function CPe(e, t) {
    return EPe(e, t);
  }
  function Jn(e, t = [], n) {
    if (Array.isArray(e))
      return e.map((i) => Jn(i, t)).filter((i) => i !== n);
    const r = e === "" || e === null ? -1 : Number(e), o = t[r];
    return o ? o.value : n;
  }
  function e7(e, t, n = []) {
    const r = Jn(e, n);
    return Array.isArray(t) ? t.filter((o) => !fn(o, r)) : fn(r, t) ? void 0 : t;
  }
  function v1(e, t) {
    return Array.isArray(t) ? t.some((n) => fn(n, e)) : fn(t, e);
  }
  function XR(e, t = [], n = !1) {
    const r = t.map((o, i) => v1(o.value, e) ? String(i) : void 0).filter((o) => typeof o < "u");
    return n ? r : r[0];
  }
  function t7(e, t, n = []) {
    const r = Jn(e, n);
    if (!$0(r)) {
      const o = n.findIndex((s) => r === s.value), i = n.map(({ value: s }) => s);
      return t.slice(0, o).concat(r, t.slice(o)).sort((s, l) => +(i.indexOf(s) > i.indexOf(l)));
    }
    return t;
  }
  var kPe = 1, TPe = 4;
  function ZR(e) {
    return jp(e, kPe | TPe);
  }
  function RPe(e, t, n, r) {
    return r = typeof r == "function" ? r : void 0, e == null ? e : DR(e, t, n, r);
  }
  class n7 {
    /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.
     *
     * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class
     */
    constructor(t) {
      this.errorSchema = {}, this.resetAllErrors(t);
    }
    /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`
     */
    get ErrorSchema() {
      return this.errorSchema;
    }
    /** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.
     *
     * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)
     * @returns - The error block for the given `pathOfError` or the root if not provided
     * @private
     */
    getOrCreateErrorBlock(t) {
      let r = Array.isArray(t) && t.length > 0 || typeof t == "string" ? Ee(this.errorSchema, t) : this.errorSchema;
      return !r && t && (r = {}, RPe(this.errorSchema, t, r, Object)), r;
    }
    /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.
     *
     * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class
     * @returns - The `ErrorSchemaBuilder` object for chaining purposes
     */
    resetAllErrors(t) {
      return this.errorSchema = t ? ZR(t) : {}, this;
    }
    /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within
     * the schema described by the `pathOfError`. For more information about how to specify the path see the
     * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
     *
     * @param errorOrList - The error or list of errors to add into the `ErrorSchema`
     * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)
     * @returns - The `ErrorSchemaBuilder` object for chaining purposes
     */
    addErrors(t, n) {
      const r = this.getOrCreateErrorBlock(n);
      let o = Ee(r, lr);
      return Array.isArray(o) || (o = [], r[lr] = o), Array.isArray(t) ? Xt(r, lr, [.../* @__PURE__ */ new Set([...o, ...t])]) : Xt(r, lr, [.../* @__PURE__ */ new Set([...o, t])]), this;
    }
    /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location
     * within the schema described by the `pathOfError`. For more information about how to specify the path see the
     * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
     *
     * @param errorOrList - The error or list of errors to set into the `ErrorSchema`
     * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)
     * @returns - The `ErrorSchemaBuilder` object for chaining purposes
     */
    setErrors(t, n) {
      const r = this.getOrCreateErrorBlock(n), o = Array.isArray(t) ? [.../* @__PURE__ */ new Set([...t])] : [t];
      return Xt(r, lr, o), this;
    }
    /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by
     * the `pathOfError`. For more information about how to specify the path see the
     * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
     *
     * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)
     * @returns - The `ErrorSchemaBuilder` object for chaining purposes
     */
    clearErrors(t) {
      const n = this.getOrCreateErrorBlock(t);
      return Xt(n, lr, []), this;
    }
  }
  function r7(e, t, n) {
    for (var r = -1, o = t.length, i = {}; ++r < o; ) {
      var a = t[r], s = h1(e, a);
      n(s, a) && DR(i, jf(a, e), s);
    }
    return i;
  }
  function OPe(e, t) {
    if (e == null)
      return {};
    var n = If(VR(e), function(r) {
      return [r];
    });
    return t = LR(t), r7(e, n, function(r, o) {
      return t(r, o[0]);
    });
  }
  var APe = 200;
  function NPe(e, t, n, r) {
    var o = -1, i = UR, a = !0, s = e.length, l = [], u = t.length;
    if (!s)
      return l;
    t.length >= APe && (i = gh, a = !1, t = new pc(t));
    e:
      for (; ++o < s; ) {
        var d = e[o], p = d;
        if (d = d !== 0 ? d : 0, a && p === p) {
          for (var h = u; h--; )
            if (t[h] === p)
              continue e;
          l.push(d);
        } else i(t, p, r) || l.push(d);
      }
    return l;
  }
  var MPe = g1(function(e, t) {
    return vh(e) ? NPe(e, pm(t, 1, vh, !0)) : [];
  });
  function XD(e, t) {
    const n = il(e), r = il(t);
    if (e === t || !n && !r)
      return [];
    if (n && !r)
      return Vo(e);
    if (!n && r)
      return Vo(t);
    {
      const o = Vo(OPe(e, (a, s) => !fn(a, Ee(t, s)))), i = MPe(Vo(t), Vo(e));
      return [...o, ...i];
    }
  }
  function PPe(e, t, n = [1900, (/* @__PURE__ */ new Date()).getFullYear() + 2], r = "YMD") {
    const { day: o, month: i, year: a, hour: s, minute: l, second: u } = e, d = { type: "day", range: [1, 31], value: o }, p = { type: "month", range: [1, 12], value: i }, h = { type: "year", range: n, value: a }, g = [];
    switch (r) {
      case "MDY":
        g.push(p, d, h);
        break;
      case "DMY":
        g.push(d, p, h);
        break;
      case "YMD":
      default:
        g.push(h, p, d);
    }
    return t && g.push({ type: "hour", range: [0, 23], value: s }, { type: "minute", range: [0, 59], value: l }, { type: "second", range: [0, 59], value: u }), g;
  }
  function o7(e) {
    const t = {};
    return e.multipleOf && (t.step = e.multipleOf), (e.minimum || e.minimum === 0) && (t.min = e.minimum), (e.maximum || e.maximum === 0) && (t.max = e.maximum), t;
  }
  function i7(e, t, n = {}, r = !0) {
    const o = {
      type: t || "text",
      ...o7(e)
    };
    return n.inputType ? o.type = n.inputType : t || (e.type === "number" ? (o.type = "number", r && o.step === void 0 && (o.step = "any")) : e.type === "integer" && (o.type = "number", o.step === void 0 && (o.step = 1))), n.autocomplete && (o.autoComplete = n.autocomplete), n.accept && (o.accept = n.accept), o;
  }
  const ZD = {
    props: {
      disabled: !1
    },
    submitText: "Submit",
    norender: !1
  };
  function a7(e = {}) {
    const t = Ze(e);
    if (t && t[A0]) {
      const n = t[A0];
      return { ...ZD, ...n };
    }
    return ZD;
  }
  function et(e, t, n = {}) {
    const { templates: r } = t;
    if (e === "ButtonTemplates")
      return r[e];
    if (Object.hasOwn(n, e) && typeof n[e] == "string" && Object.hasOwn(r, n[e])) {
      const o = n[e];
      return r[o];
    }
    return (
      // Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent
      // To avoid that, we cast uiOptions to `any` before accessing the name field
      n[e] || r[e]
    );
  }
  var $Pe = 0;
  function s7(e) {
    var t = ++$Pe;
    return $R(e) + t;
  }
  function QR() {
    if (typeof process > "u" || Ee(process, "env.NODE_ENV") !== "test")
      return {};
    const e = /* @__PURE__ */ new Map();
    return new Proxy({}, {
      get(t, n) {
        return e.has(n) || e.set(n, s7("test-id-")), e.get(n);
      }
    });
  }
  var A_ = { exports: {} }, Vt = {};
  /**
   * @license React
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var QD;
  function IPe() {
    if (QD) return Vt;
    QD = 1;
    var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), i = Symbol.for("react.provider"), a = Symbol.for("react.context"), s = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), d = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), y;
    y = Symbol.for("react.module.reference");
    function b(v) {
      if (typeof v == "object" && v !== null) {
        var x = v.$$typeof;
        switch (x) {
          case e:
            switch (v = v.type, v) {
              case n:
              case o:
              case r:
              case u:
              case d:
                return v;
              default:
                switch (v = v && v.$$typeof, v) {
                  case s:
                  case a:
                  case l:
                  case h:
                  case p:
                  case i:
                    return v;
                  default:
                    return x;
                }
            }
          case t:
            return x;
        }
      }
    }
    return Vt.ContextConsumer = a, Vt.ContextProvider = i, Vt.Element = e, Vt.ForwardRef = l, Vt.Fragment = n, Vt.Lazy = h, Vt.Memo = p, Vt.Portal = t, Vt.Profiler = o, Vt.StrictMode = r, Vt.Suspense = u, Vt.SuspenseList = d, Vt.isAsyncMode = function() {
      return !1;
    }, Vt.isConcurrentMode = function() {
      return !1;
    }, Vt.isContextConsumer = function(v) {
      return b(v) === a;
    }, Vt.isContextProvider = function(v) {
      return b(v) === i;
    }, Vt.isElement = function(v) {
      return typeof v == "object" && v !== null && v.$$typeof === e;
    }, Vt.isForwardRef = function(v) {
      return b(v) === l;
    }, Vt.isFragment = function(v) {
      return b(v) === n;
    }, Vt.isLazy = function(v) {
      return b(v) === h;
    }, Vt.isMemo = function(v) {
      return b(v) === p;
    }, Vt.isPortal = function(v) {
      return b(v) === t;
    }, Vt.isProfiler = function(v) {
      return b(v) === o;
    }, Vt.isStrictMode = function(v) {
      return b(v) === r;
    }, Vt.isSuspense = function(v) {
      return b(v) === u;
    }, Vt.isSuspenseList = function(v) {
      return b(v) === d;
    }, Vt.isValidElementType = function(v) {
      return typeof v == "string" || typeof v == "function" || v === n || v === o || v === r || v === u || v === d || v === g || typeof v == "object" && v !== null && (v.$$typeof === h || v.$$typeof === p || v.$$typeof === i || v.$$typeof === a || v.$$typeof === l || v.$$typeof === y || v.getModuleId !== void 0);
    }, Vt.typeOf = b, Vt;
  }
  var JD;
  function jPe() {
    return JD || (JD = 1, A_.exports = IPe()), A_.exports;
  }
  var DPe = jPe();
  const e5 = /* @__PURE__ */ Jo(DPe), N_ = {
    boolean: {
      checkbox: "CheckboxWidget",
      radio: "RadioWidget",
      select: "SelectWidget",
      hidden: "HiddenWidget"
    },
    string: {
      text: "TextWidget",
      password: "PasswordWidget",
      email: "EmailWidget",
      hostname: "TextWidget",
      ipv4: "TextWidget",
      ipv6: "TextWidget",
      uri: "URLWidget",
      "data-url": "FileWidget",
      radio: "RadioWidget",
      select: "SelectWidget",
      textarea: "TextareaWidget",
      hidden: "HiddenWidget",
      date: "DateWidget",
      datetime: "DateTimeWidget",
      "date-time": "DateTimeWidget",
      "alt-date": "AltDateWidget",
      "alt-datetime": "AltDateTimeWidget",
      time: "TimeWidget",
      color: "ColorWidget",
      file: "FileWidget"
    },
    number: {
      text: "TextWidget",
      select: "SelectWidget",
      updown: "UpDownWidget",
      range: "RangeWidget",
      radio: "RadioWidget",
      hidden: "HiddenWidget"
    },
    integer: {
      text: "TextWidget",
      select: "SelectWidget",
      updown: "UpDownWidget",
      range: "RangeWidget",
      radio: "RadioWidget",
      hidden: "HiddenWidget"
    },
    array: {
      select: "SelectWidget",
      checkboxes: "CheckboxesWidget",
      files: "FileWidget",
      hidden: "HiddenWidget"
    }
  };
  function FPe(e) {
    let t = Ee(e, "MergedWidget");
    if (!t) {
      const n = e.defaultProps && e.defaultProps.options || {};
      t = ({ options: r, ...o }) => S.jsx(e, { options: { ...n, ...r }, ...o }), Xt(e, "MergedWidget", t);
    }
    return t;
  }
  function Gi(e, t, n = {}) {
    const r = Qo(e);
    if (typeof t == "function" || t && e5.isForwardRef(T.createElement(t)) || e5.isMemo(t))
      return FPe(t);
    if (typeof t != "string")
      throw new Error(`Unsupported widget definition: ${typeof t} in schema: ${JSON.stringify(e)}`);
    if (t in n) {
      const o = n[t];
      return Gi(e, o, n);
    }
    if (typeof r == "string") {
      if (!(r in N_))
        throw new Error(`No widget for type '${r}' in schema: ${JSON.stringify(e)}`);
      if (t in N_[r]) {
        const o = n[N_[r][t]];
        return Gi(e, o, n);
      }
    }
    throw new Error(`No widget '${t}' for type '${r}' in schema: ${JSON.stringify(e)}`);
  }
  function LPe(e) {
    let t = 0;
    for (let n = 0; n < e.length; n += 1) {
      const r = e.charCodeAt(n);
      t = (t << 5) - t + r, t = t & t;
    }
    return t.toString(16);
  }
  function zPe(e) {
    const t = /* @__PURE__ */ new Set();
    return JSON.stringify(e, (n, r) => (t.add(n), r)), JSON.stringify(e, Array.from(t).sort());
  }
  function Pi(e) {
    return LPe(zPe(e));
  }
  function BPe(e) {
    return Pi(e);
  }
  function UPe(e, t, n = {}) {
    try {
      return Gi(e, t, n), !0;
    } catch (r) {
      const o = r;
      if (o.message && (o.message.startsWith("No widget") || o.message.startsWith("Unsupported widget")))
        return !1;
      throw r;
    }
  }
  function kc(e, t) {
    return `${al(e) ? e : e[nn]}__${t}`;
  }
  function Tc(e) {
    return kc(e, "description");
  }
  function JR(e) {
    return kc(e, "error");
  }
  function Eh(e) {
    return kc(e, "examples");
  }
  function eO(e) {
    return kc(e, "help");
  }
  function b1(e) {
    return kc(e, "title");
  }
  function po(e, t = !1) {
    const n = t ? ` ${Eh(e)}` : "";
    return `${JR(e)} ${Tc(e)} ${eO(e)}${n}`;
  }
  function x1(e, t) {
    return `${e}-${t}`;
  }
  function $i(e, t) {
    return kc(e, t);
  }
  function M_(e, t) {
    return kc(e, `optional${t}`);
  }
  function Ff(e) {
    return !$0(e) && (!Pt(e) || Array.isArray(e) || !Un(e));
  }
  function VPe(e, t) {
    const { rootSchema: n, schemaUtils: r } = e;
    if (yh(t, n))
      return !0;
    if (mn in n) {
      const o = r.retrieveSchema(n);
      return yh(t, o);
    }
    return !1;
  }
  function Rc(e, t, n) {
    return t ? n : e;
  }
  function HPe(e) {
    return e ? new Date(e).toJSON() : void 0;
  }
  function tO(e, t, n) {
    const r = [aTe];
    return kt(e, nD) && r.unshift(nD), Ee(e, [...r, t], n);
  }
  function qPe(e, t) {
    if (!Array.isArray(t))
      return e;
    const n = (d) => d.reduce((p, h) => (p[h] = !0, p), {}), r = (d) => d.length > 1 ? `properties '${d.join("', '")}'` : `property '${d[0]}'`, o = n(e), i = t.filter((d) => d === "*" || o[d]), a = n(i), s = e.filter((d) => !a[d]), l = i.indexOf("*");
    if (l === -1) {
      if (s.length)
        throw new Error(`uiSchema order list does not contain ${r(s)}`);
      return i;
    }
    if (l !== i.lastIndexOf("*"))
      throw new Error("uiSchema order list contains more than one wildcard item");
    const u = [...i];
    return u.splice(l, 1, ...s), u;
  }
  function P_(e, t = !0) {
    if (!e)
      return {
        year: -1,
        month: -1,
        day: -1,
        hour: t ? -1 : 0,
        minute: t ? -1 : 0,
        second: t ? -1 : 0
      };
    const n = new Date(e);
    if (Number.isNaN(n.getTime()))
      throw new Error("Unable to parse date " + e);
    return {
      year: n.getUTCFullYear(),
      month: n.getUTCMonth() + 1,
      // oh you, javascript.
      day: n.getUTCDate(),
      hour: t ? n.getUTCHours() : 0,
      minute: t ? n.getUTCMinutes() : 0,
      second: t ? n.getUTCSeconds() : 0
    };
  }
  function Dp(e) {
    if (e.const || e.enum && e.enum.length === 1 && e.enum[0] === !0)
      return !0;
    if (e.anyOf && e.anyOf.length === 1)
      return Dp(e.anyOf[0]);
    if (e.oneOf && e.oneOf.length === 1)
      return Dp(e.oneOf[0]);
    if (e.allOf) {
      const t = (n) => Dp(n);
      return e.allOf.some(t);
    }
    return !1;
  }
  function l7(e, t, n, r = "customDeep") {
    if (r === "always")
      return !0;
    if (r === "shallow") {
      const { props: a, state: s } = e;
      return !YD(a, t) || !YD(s, n);
    }
    const { props: o, state: i } = e;
    return !fn(o, t) || !fn(i, n);
  }
  function t5(e) {
    const t = EH(e.map((n) => Pt(n) ? Qo(n) : void 0).flat().filter((n) => n !== void 0));
    return t.length === 1 ? t[0] : t;
  }
  function hm(e, t, n, r) {
    const { enableOptionalDataFieldForType: o = [] } = Ze(r, e.globalUiOptions);
    let i;
    return At in t && Array.isArray(t[At]) ? i = t5(t[At]) : gt in t && Array.isArray(t[gt]) ? i = t5(t[gt]) : i = Qo(t), !VPe(e, t) && !n && !!i && !Array.isArray(i) && !!o.find((a) => a === i);
  }
  function n5(e, t = !0) {
    const { year: n, month: r, day: o, hour: i = 0, minute: a = 0, second: s = 0 } = e, l = Date.UTC(n, r - 1, o, i, a, s), u = new Date(l).toJSON();
    return t ? u : u.slice(0, 10);
  }
  function nO(e, t = []) {
    if (!e)
      return [];
    let n = [];
    return lr in e && (n = n.concat(e[lr].map((r) => {
      const o = `.${t.join(".")}`;
      return {
        property: o,
        message: r,
        stack: `${o} ${r}`
      };
    }))), Object.keys(e).reduce((r, o) => {
      if (o !== lr) {
        const i = e[o];
        il(i) && (r = r.concat(nO(i, [...t, o])));
      }
      return r;
    }, n);
  }
  function c7(e) {
    return Kn(e) ? If(e, Cc) : fm(e) ? [e] : BR(rH($R(e)));
  }
  function WPe(e) {
    const t = new n7();
    return e.length && e.forEach((n) => {
      const { property: r, message: o } = n, i = r === "." ? [] : c7(r);
      i.length > 0 && i[0] === "" && i.splice(0, 1), o && t.addErrors(o, i);
    }), t.ErrorSchema;
  }
  function Mo(e, t, n, r) {
    const o = Array.isArray(n) ? n : n?.path, i = e === "" ? [] : [e], a = o ? o.concat(...i) : i, s = [t.idPrefix, ...a].join(t.idSeparator);
    let l;
    return t.nameGenerator && a.length > 0 && (l = t.nameGenerator(a, t.idPrefix, r)), { path: a, [nn]: s, ...l !== void 0 && { name: l } };
  }
  function u7(e) {
    return Object.keys(e).reduce((t, n) => {
      if (n === "addError")
        return t;
      {
        const r = e[n];
        return il(r) ? {
          ...t,
          [n]: u7(r)
        } : { ...t, [n]: r };
      }
    }, {});
  }
  function GPe(e) {
    return Object.values(e).every((t) => t !== -1);
  }
  function KPe(e) {
    const { className: t = "form-control", type: n, range: r, value: o, select: i, rootId: a, name: s, disabled: l, readonly: u, autofocus: d, registry: p, onBlur: h, onFocus: g } = e, y = `${a}_${n}`, { SelectWidget: b } = p.widgets, v = T.useCallback((x) => i(n, x), [i, n]);
    return S.jsx(b, { schema: { type: "integer" }, id: y, name: s, className: t, options: { enumOptions: JH(r[0], r[1]) }, placeholder: n, value: o, disabled: l, readonly: u, autofocus: d, onChange: v, onBlur: h, onFocus: g, registry: p, label: "", "aria-describedby": po(a) });
  }
  function YPe(e) {
    const { time: t = !1, disabled: n = !1, readonly: r = !1, options: o, onChange: i, value: a } = e, [s, l] = T.useState(P_(a, t));
    T.useEffect(() => {
      l(P_(a, t));
    }, [t, a]);
    const u = T.useCallback((g, y) => {
      const b = {
        ...s,
        [g]: typeof y > "u" ? -1 : y
      };
      GPe(b) ? i(n5(b, t)) : l(b);
    }, [s, i, t]), d = T.useCallback((g) => {
      g.preventDefault(), !(n || r) && i(void 0);
    }, [n, r, i]), p = T.useCallback((g) => {
      if (g.preventDefault(), n || r)
        return;
      const y = P_((/* @__PURE__ */ new Date()).toJSON(), t);
      i(n5(y, t));
    }, [n, r, t, i]);
    return { elements: T.useMemo(() => PPe(s, t, o.yearsRange, o.format), [s, t, o.yearsRange, o.format]), handleChange: u, handleClear: d, handleSetNow: p };
  }
  function Oc(e) {
    const t = T.useRef(e);
    return yh(e, t.current) || (t.current = e), t.current;
  }
  function XPe(e, t) {
    return e.replace(";base64", `;name=${encodeURIComponent(t)};base64`);
  }
  function ZPe(e) {
    const { name: t, size: n, type: r } = e;
    return new Promise((o, i) => {
      const a = new window.FileReader();
      a.onerror = i, a.onload = (s) => {
        var l;
        typeof ((l = s.target) === null || l === void 0 ? void 0 : l.result) == "string" ? o({
          dataURL: XPe(s.target.result, t),
          name: t,
          size: n,
          type: r
        }) : o({
          dataURL: null,
          name: t,
          size: n,
          type: r
        });
      }, a.readAsDataURL(e);
    });
  }
  function QPe(e) {
    return Promise.all(Array.from(e).map(ZPe));
  }
  function r5(e) {
    return e.reduce((t, n) => {
      if (!n)
        return t;
      try {
        const { blob: r, name: o } = _Pe(n);
        return [
          ...t,
          {
            dataURL: n,
            name: o,
            size: r.size,
            type: r.type
          }
        ];
      } catch {
        return t;
      }
    }, []);
  }
  function JPe(e, t, n = !1) {
    const r = T.useMemo(() => n && e ? Array.isArray(e) ? e : [e] : [], [e, n]), o = T.useMemo(() => Array.isArray(e) ? r5(e) : r5([e || ""]), [e]), i = T.useCallback((s) => {
      QPe(s).then((l) => {
        const u = l.map((d) => d.dataURL || null);
        t(n ? r.concat(...u) : u[0]);
      });
    }, [r, n, t]), a = T.useCallback((s) => {
      if (n) {
        const l = r.filter((u, d) => d !== s);
        t(l);
      } else
        t(void 0);
    }, [r, n, t]);
    return { filesInfo: o, handleChange: i, handleRemove: a };
  }
  function e$e(e) {
    if (!e)
      return "";
    const t = new Date(e), n = Ds(t.getFullYear(), 4), r = Ds(t.getMonth() + 1, 2), o = Ds(t.getDate(), 2), i = Ds(t.getHours(), 2), a = Ds(t.getMinutes(), 2), s = Ds(t.getSeconds(), 2), l = Ds(t.getMilliseconds(), 3);
    return `${n}-${r}-${o}T${i}:${a}:${s}.${l}`;
  }
  function $v(e, t, n = !1) {
    if (!t)
      return e;
    const { errors: r, errorSchema: o } = e;
    let i = nO(t), a = t;
    return Un(o) || (a = _h(o, t, n ? "preventDuplicates" : !0), i = [...r].concat(i)), { errorSchema: a, errors: i };
  }
  function t$e(e) {
    for (const t in e) {
      const n = e, r = n[t];
      t === mn && typeof r == "string" && r.startsWith("#") ? n[t] = UV + r : n[t] = rO(r);
    }
    return e;
  }
  function n$e(e) {
    for (let t = 0; t < e.length; t++)
      e[t] = rO(e[t]);
    return e;
  }
  function rO(e) {
    return Array.isArray(e) ? n$e([...e]) : Pt(e) ? t$e({ ...e }) : e;
  }
  var bt;
  (function(e) {
    e.ArrayItemTitle = "Item", e.MissingItems = "Missing items definition", e.EmptyArray = "No items yet. Use the button below to add some.", e.YesLabel = "Yes", e.NoLabel = "No", e.CloseLabel = "Close", e.ErrorsLabel = "Errors", e.NewStringDefault = "New Value", e.AddButton = "Add", e.AddItemButton = "Add Item", e.CopyButton = "Copy", e.MoveDownButton = "Move down", e.MoveUpButton = "Move up", e.RemoveButton = "Remove", e.NowLabel = "Now", e.ClearLabel = "Clear", e.AriaDateLabel = "Select a date", e.PreviewLabel = "Preview", e.DecrementAriaLabel = "Decrease value by 1", e.IncrementAriaLabel = "Increase value by 1", e.OptionalObjectAdd = "Add data for optional field", e.OptionalObjectRemove = "Remove data for optional field", e.OptionalObjectEmptyMsg = "No data for optional field", e.Type = "Type", e.Value = "Value", e.UnknownFieldType = "Unknown field type %1", e.OptionPrefix = "Option %1", e.TitleOptionPrefix = "%1 option %2", e.KeyLabel = "%1 Key", e.InvalidObjectField = 'Invalid "%1" object field configuration: _%2_.', e.UnsupportedField = "Unsupported field schema.", e.UnsupportedFieldWithId = "Unsupported field schema for field `%1`.", e.UnsupportedFieldWithReason = "Unsupported field schema: _%1_.", e.UnsupportedFieldWithIdAndReason = "Unsupported field schema for field `%1`: _%2_.", e.FilesInfo = "**%1** (%2, %3 bytes)";
  })(bt || (bt = {}));
  function r$e(e, t) {
    var n = Kn(e) ? FR : WH;
    return n(e, aH(t));
  }
  var py = { exports: {} }, $_ = {}, _a = {}, jl = {}, I_ = {}, j_ = {}, D_ = {}, o5;
  function I0() {
    return o5 || (o5 = 1, function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.regexpCode = e.getEsmExportName = e.getProperty = e.safeStringify = e.stringify = e.strConcat = e.addCodeArg = e.str = e._ = e.nil = e._Code = e.Name = e.IDENTIFIER = e._CodeOrName = void 0;
      class t {
      }
      e._CodeOrName = t, e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
      class n extends t {
        constructor(E) {
          if (super(), !e.IDENTIFIER.test(E))
            throw new Error("CodeGen: name must be a valid identifier");
          this.str = E;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          return !1;
        }
        get names() {
          return { [this.str]: 1 };
        }
      }
      e.Name = n;
      class r extends t {
        constructor(E) {
          super(), this._items = typeof E == "string" ? [E] : E;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          if (this._items.length > 1)
            return !1;
          const E = this._items[0];
          return E === "" || E === '""';
        }
        get str() {
          var E;
          return (E = this._str) !== null && E !== void 0 ? E : this._str = this._items.reduce((_, C) => `${_}${C}`, "");
        }
        get names() {
          var E;
          return (E = this._names) !== null && E !== void 0 ? E : this._names = this._items.reduce((_, C) => (C instanceof n && (_[C.str] = (_[C.str] || 0) + 1), _), {});
        }
      }
      e._Code = r, e.nil = new r("");
      function o(x, ...E) {
        const _ = [x[0]];
        let C = 0;
        for (; C < E.length; )
          s(_, E[C]), _.push(x[++C]);
        return new r(_);
      }
      e._ = o;
      const i = new r("+");
      function a(x, ...E) {
        const _ = [g(x[0])];
        let C = 0;
        for (; C < E.length; )
          _.push(i), s(_, E[C]), _.push(i, g(x[++C]));
        return l(_), new r(_);
      }
      e.str = a;
      function s(x, E) {
        E instanceof r ? x.push(...E._items) : E instanceof n ? x.push(E) : x.push(p(E));
      }
      e.addCodeArg = s;
      function l(x) {
        let E = 1;
        for (; E < x.length - 1; ) {
          if (x[E] === i) {
            const _ = u(x[E - 1], x[E + 1]);
            if (_ !== void 0) {
              x.splice(E - 1, 3, _);
              continue;
            }
            x[E++] = "+";
          }
          E++;
        }
      }
      function u(x, E) {
        if (E === '""')
          return x;
        if (x === '""')
          return E;
        if (typeof x == "string")
          return E instanceof n || x[x.length - 1] !== '"' ? void 0 : typeof E != "string" ? `${x.slice(0, -1)}${E}"` : E[0] === '"' ? x.slice(0, -1) + E.slice(1) : void 0;
        if (typeof E == "string" && E[0] === '"' && !(x instanceof n))
          return `"${x}${E.slice(1)}`;
      }
      function d(x, E) {
        return E.emptyStr() ? x : x.emptyStr() ? E : a`${x}${E}`;
      }
      e.strConcat = d;
      function p(x) {
        return typeof x == "number" || typeof x == "boolean" || x === null ? x : g(Array.isArray(x) ? x.join(",") : x);
      }
      function h(x) {
        return new r(g(x));
      }
      e.stringify = h;
      function g(x) {
        return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      }
      e.safeStringify = g;
      function y(x) {
        return typeof x == "string" && e.IDENTIFIER.test(x) ? new r(`.${x}`) : o`[${x}]`;
      }
      e.getProperty = y;
      function b(x) {
        if (typeof x == "string" && e.IDENTIFIER.test(x))
          return new r(`${x}`);
        throw new Error(`CodeGen: invalid export name: ${x}, use explicit $id name mapping`);
      }
      e.getEsmExportName = b;
      function v(x) {
        return new r(x.toString());
      }
      e.regexpCode = v;
    }(D_)), D_;
  }
  var F_ = {}, i5;
  function a5() {
    return i5 || (i5 = 1, function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueScope = e.ValueScopeName = e.Scope = e.varKinds = e.UsedValueState = void 0;
      const t = I0();
      class n extends Error {
        constructor(u) {
          super(`CodeGen: "code" for ${u} not defined`), this.value = u.value;
        }
      }
      var r;
      (function(l) {
        l[l.Started = 0] = "Started", l[l.Completed = 1] = "Completed";
      })(r || (e.UsedValueState = r = {})), e.varKinds = {
        const: new t.Name("const"),
        let: new t.Name("let"),
        var: new t.Name("var")
      };
      class o {
        constructor({ prefixes: u, parent: d } = {}) {
          this._names = {}, this._prefixes = u, this._parent = d;
        }
        toName(u) {
          return u instanceof t.Name ? u : this.name(u);
        }
        name(u) {
          return new t.Name(this._newName(u));
        }
        _newName(u) {
          const d = this._names[u] || this._nameGroup(u);
          return `${u}${d.index++}`;
        }
        _nameGroup(u) {
          var d, p;
          if (!((p = (d = this._parent) === null || d === void 0 ? void 0 : d._prefixes) === null || p === void 0) && p.has(u) || this._prefixes && !this._prefixes.has(u))
            throw new Error(`CodeGen: prefix "${u}" is not allowed in this scope`);
          return this._names[u] = { prefix: u, index: 0 };
        }
      }
      e.Scope = o;
      class i extends t.Name {
        constructor(u, d) {
          super(d), this.prefix = u;
        }
        setValue(u, { property: d, itemIndex: p }) {
          this.value = u, this.scopePath = (0, t._)`.${new t.Name(d)}[${p}]`;
        }
      }
      e.ValueScopeName = i;
      const a = (0, t._)`\n`;
      class s extends o {
        constructor(u) {
          super(u), this._values = {}, this._scope = u.scope, this.opts = { ...u, _n: u.lines ? a : t.nil };
        }
        get() {
          return this._scope;
        }
        name(u) {
          return new i(u, this._newName(u));
        }
        value(u, d) {
          var p;
          if (d.ref === void 0)
            throw new Error("CodeGen: ref must be passed in value");
          const h = this.toName(u), { prefix: g } = h, y = (p = d.key) !== null && p !== void 0 ? p : d.ref;
          let b = this._values[g];
          if (b) {
            const E = b.get(y);
            if (E)
              return E;
          } else
            b = this._values[g] = /* @__PURE__ */ new Map();
          b.set(y, h);
          const v = this._scope[g] || (this._scope[g] = []), x = v.length;
          return v[x] = d.ref, h.setValue(d, { property: g, itemIndex: x }), h;
        }
        getValue(u, d) {
          const p = this._values[u];
          if (p)
            return p.get(d);
        }
        scopeRefs(u, d = this._values) {
          return this._reduceValues(d, (p) => {
            if (p.scopePath === void 0)
              throw new Error(`CodeGen: name "${p}" has no value`);
            return (0, t._)`${u}${p.scopePath}`;
          });
        }
        scopeCode(u = this._values, d, p) {
          return this._reduceValues(u, (h) => {
            if (h.value === void 0)
              throw new Error(`CodeGen: name "${h}" has no value`);
            return h.value.code;
          }, d, p);
        }
        _reduceValues(u, d, p = {}, h) {
          let g = t.nil;
          for (const y in u) {
            const b = u[y];
            if (!b)
              continue;
            const v = p[y] = p[y] || /* @__PURE__ */ new Map();
            b.forEach((x) => {
              if (v.has(x))
                return;
              v.set(x, r.Started);
              let E = d(x);
              if (E) {
                const _ = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
                g = (0, t._)`${g}${_} ${x} = ${E};${this.opts._n}`;
              } else if (E = h?.(x))
                g = (0, t._)`${g}${E}${this.opts._n}`;
              else
                throw new n(x);
              v.set(x, r.Completed);
            });
          }
          return g;
        }
      }
      e.ValueScope = s;
    }(F_)), F_;
  }
  var s5;
  function yt() {
    return s5 || (s5 = 1, function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.or = e.and = e.not = e.CodeGen = e.operators = e.varKinds = e.ValueScopeName = e.ValueScope = e.Scope = e.Name = e.regexpCode = e.stringify = e.getProperty = e.nil = e.strConcat = e.str = e._ = void 0;
      const t = I0(), n = a5();
      var r = I0();
      Object.defineProperty(e, "_", { enumerable: !0, get: function() {
        return r._;
      } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
        return r.str;
      } }), Object.defineProperty(e, "strConcat", { enumerable: !0, get: function() {
        return r.strConcat;
      } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
        return r.nil;
      } }), Object.defineProperty(e, "getProperty", { enumerable: !0, get: function() {
        return r.getProperty;
      } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
        return r.stringify;
      } }), Object.defineProperty(e, "regexpCode", { enumerable: !0, get: function() {
        return r.regexpCode;
      } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
        return r.Name;
      } });
      var o = a5();
      Object.defineProperty(e, "Scope", { enumerable: !0, get: function() {
        return o.Scope;
      } }), Object.defineProperty(e, "ValueScope", { enumerable: !0, get: function() {
        return o.ValueScope;
      } }), Object.defineProperty(e, "ValueScopeName", { enumerable: !0, get: function() {
        return o.ValueScopeName;
      } }), Object.defineProperty(e, "varKinds", { enumerable: !0, get: function() {
        return o.varKinds;
      } }), e.operators = {
        GT: new t._Code(">"),
        GTE: new t._Code(">="),
        LT: new t._Code("<"),
        LTE: new t._Code("<="),
        EQ: new t._Code("==="),
        NEQ: new t._Code("!=="),
        NOT: new t._Code("!"),
        OR: new t._Code("||"),
        AND: new t._Code("&&"),
        ADD: new t._Code("+")
      };
      class i {
        optimizeNodes() {
          return this;
        }
        optimizeNames(H, Y) {
          return this;
        }
      }
      class a extends i {
        constructor(H, Y, Q) {
          super(), this.varKind = H, this.name = Y, this.rhs = Q;
        }
        render({ es5: H, _n: Y }) {
          const Q = H ? n.varKinds.var : this.varKind, re = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
          return `${Q} ${this.name}${re};` + Y;
        }
        optimizeNames(H, Y) {
          if (H[this.name.str])
            return this.rhs && (this.rhs = j(this.rhs, H, Y)), this;
        }
        get names() {
          return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
        }
      }
      class s extends i {
        constructor(H, Y, Q) {
          super(), this.lhs = H, this.rhs = Y, this.sideEffects = Q;
        }
        render({ _n: H }) {
          return `${this.lhs} = ${this.rhs};` + H;
        }
        optimizeNames(H, Y) {
          if (!(this.lhs instanceof t.Name && !H[this.lhs.str] && !this.sideEffects))
            return this.rhs = j(this.rhs, H, Y), this;
        }
        get names() {
          const H = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
          return B(H, this.rhs);
        }
      }
      class l extends s {
        constructor(H, Y, Q, re) {
          super(H, Q, re), this.op = Y;
        }
        render({ _n: H }) {
          return `${this.lhs} ${this.op}= ${this.rhs};` + H;
        }
      }
      class u extends i {
        constructor(H) {
          super(), this.label = H, this.names = {};
        }
        render({ _n: H }) {
          return `${this.label}:` + H;
        }
      }
      class d extends i {
        constructor(H) {
          super(), this.label = H, this.names = {};
        }
        render({ _n: H }) {
          return `break${this.label ? ` ${this.label}` : ""};` + H;
        }
      }
      class p extends i {
        constructor(H) {
          super(), this.error = H;
        }
        render({ _n: H }) {
          return `throw ${this.error};` + H;
        }
        get names() {
          return this.error.names;
        }
      }
      class h extends i {
        constructor(H) {
          super(), this.code = H;
        }
        render({ _n: H }) {
          return `${this.code};` + H;
        }
        optimizeNodes() {
          return `${this.code}` ? this : void 0;
        }
        optimizeNames(H, Y) {
          return this.code = j(this.code, H, Y), this;
        }
        get names() {
          return this.code instanceof t._CodeOrName ? this.code.names : {};
        }
      }
      class g extends i {
        constructor(H = []) {
          super(), this.nodes = H;
        }
        render(H) {
          return this.nodes.reduce((Y, Q) => Y + Q.render(H), "");
        }
        optimizeNodes() {
          const { nodes: H } = this;
          let Y = H.length;
          for (; Y--; ) {
            const Q = H[Y].optimizeNodes();
            Array.isArray(Q) ? H.splice(Y, 1, ...Q) : Q ? H[Y] = Q : H.splice(Y, 1);
          }
          return H.length > 0 ? this : void 0;
        }
        optimizeNames(H, Y) {
          const { nodes: Q } = this;
          let re = Q.length;
          for (; re--; ) {
            const te = Q[re];
            te.optimizeNames(H, Y) || (V(H, te.names), Q.splice(re, 1));
          }
          return Q.length > 0 ? this : void 0;
        }
        get names() {
          return this.nodes.reduce((H, Y) => P(H, Y.names), {});
        }
      }
      class y extends g {
        render(H) {
          return "{" + H._n + super.render(H) + "}" + H._n;
        }
      }
      class b extends g {
      }
      class v extends y {
      }
      v.kind = "else";
      class x extends y {
        constructor(H, Y) {
          super(Y), this.condition = H;
        }
        render(H) {
          let Y = `if(${this.condition})` + super.render(H);
          return this.else && (Y += "else " + this.else.render(H)), Y;
        }
        optimizeNodes() {
          super.optimizeNodes();
          const H = this.condition;
          if (H === !0)
            return this.nodes;
          let Y = this.else;
          if (Y) {
            const Q = Y.optimizeNodes();
            Y = this.else = Array.isArray(Q) ? new v(Q) : Q;
          }
          if (Y)
            return H === !1 ? Y instanceof x ? Y : Y.nodes : this.nodes.length ? this : new x(F(H), Y instanceof x ? [Y] : Y.nodes);
          if (!(H === !1 || !this.nodes.length))
            return this;
        }
        optimizeNames(H, Y) {
          var Q;
          if (this.else = (Q = this.else) === null || Q === void 0 ? void 0 : Q.optimizeNames(H, Y), !!(super.optimizeNames(H, Y) || this.else))
            return this.condition = j(this.condition, H, Y), this;
        }
        get names() {
          const H = super.names;
          return B(H, this.condition), this.else && P(H, this.else.names), H;
        }
      }
      x.kind = "if";
      class E extends y {
      }
      E.kind = "for";
      class _ extends E {
        constructor(H) {
          super(), this.iteration = H;
        }
        render(H) {
          return `for(${this.iteration})` + super.render(H);
        }
        optimizeNames(H, Y) {
          if (super.optimizeNames(H, Y))
            return this.iteration = j(this.iteration, H, Y), this;
        }
        get names() {
          return P(super.names, this.iteration.names);
        }
      }
      class C extends E {
        constructor(H, Y, Q, re) {
          super(), this.varKind = H, this.name = Y, this.from = Q, this.to = re;
        }
        render(H) {
          const Y = H.es5 ? n.varKinds.var : this.varKind, { name: Q, from: re, to: te } = this;
          return `for(${Y} ${Q}=${re}; ${Q}<${te}; ${Q}++)` + super.render(H);
        }
        get names() {
          const H = B(super.names, this.from);
          return B(H, this.to);
        }
      }
      class k extends E {
        constructor(H, Y, Q, re) {
          super(), this.loop = H, this.varKind = Y, this.name = Q, this.iterable = re;
        }
        render(H) {
          return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(H);
        }
        optimizeNames(H, Y) {
          if (super.optimizeNames(H, Y))
            return this.iterable = j(this.iterable, H, Y), this;
        }
        get names() {
          return P(super.names, this.iterable.names);
        }
      }
      class R extends y {
        constructor(H, Y, Q) {
          super(), this.name = H, this.args = Y, this.async = Q;
        }
        render(H) {
          return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(H);
        }
      }
      R.kind = "func";
      class A extends g {
        render(H) {
          return "return " + super.render(H);
        }
      }
      A.kind = "return";
      class M extends y {
        render(H) {
          let Y = "try" + super.render(H);
          return this.catch && (Y += this.catch.render(H)), this.finally && (Y += this.finally.render(H)), Y;
        }
        optimizeNodes() {
          var H, Y;
          return super.optimizeNodes(), (H = this.catch) === null || H === void 0 || H.optimizeNodes(), (Y = this.finally) === null || Y === void 0 || Y.optimizeNodes(), this;
        }
        optimizeNames(H, Y) {
          var Q, re;
          return super.optimizeNames(H, Y), (Q = this.catch) === null || Q === void 0 || Q.optimizeNames(H, Y), (re = this.finally) === null || re === void 0 || re.optimizeNames(H, Y), this;
        }
        get names() {
          const H = super.names;
          return this.catch && P(H, this.catch.names), this.finally && P(H, this.finally.names), H;
        }
      }
      class I extends y {
        constructor(H) {
          super(), this.error = H;
        }
        render(H) {
          return `catch(${this.error})` + super.render(H);
        }
      }
      I.kind = "catch";
      class D extends y {
        render(H) {
          return "finally" + super.render(H);
        }
      }
      D.kind = "finally";
      class L {
        constructor(H, Y = {}) {
          this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...Y, _n: Y.lines ? `
` : "" }, this._extScope = H, this._scope = new n.Scope({ parent: H }), this._nodes = [new b()];
        }
        toString() {
          return this._root.render(this.opts);
        }
        // returns unique name in the internal scope
        name(H) {
          return this._scope.name(H);
        }
        // reserves unique name in the external scope
        scopeName(H) {
          return this._extScope.name(H);
        }
        // reserves unique name in the external scope and assigns value to it
        scopeValue(H, Y) {
          const Q = this._extScope.value(H, Y);
          return (this._values[Q.prefix] || (this._values[Q.prefix] = /* @__PURE__ */ new Set())).add(Q), Q;
        }
        getScopeValue(H, Y) {
          return this._extScope.getValue(H, Y);
        }
        // return code that assigns values in the external scope to the names that are used internally
        // (same names that were returned by gen.scopeName or gen.scopeValue)
        scopeRefs(H) {
          return this._extScope.scopeRefs(H, this._values);
        }
        scopeCode() {
          return this._extScope.scopeCode(this._values);
        }
        _def(H, Y, Q, re) {
          const te = this._scope.toName(Y);
          return Q !== void 0 && re && (this._constants[te.str] = Q), this._leafNode(new a(H, te, Q)), te;
        }
        // `const` declaration (`var` in es5 mode)
        const(H, Y, Q) {
          return this._def(n.varKinds.const, H, Y, Q);
        }
        // `let` declaration with optional assignment (`var` in es5 mode)
        let(H, Y, Q) {
          return this._def(n.varKinds.let, H, Y, Q);
        }
        // `var` declaration with optional assignment
        var(H, Y, Q) {
          return this._def(n.varKinds.var, H, Y, Q);
        }
        // assignment code
        assign(H, Y, Q) {
          return this._leafNode(new s(H, Y, Q));
        }
        // `+=` code
        add(H, Y) {
          return this._leafNode(new l(H, e.operators.ADD, Y));
        }
        // appends passed SafeExpr to code or executes Block
        code(H) {
          return typeof H == "function" ? H() : H !== t.nil && this._leafNode(new h(H)), this;
        }
        // returns code for object literal for the passed argument list of key-value pairs
        object(...H) {
          const Y = ["{"];
          for (const [Q, re] of H)
            Y.length > 1 && Y.push(","), Y.push(Q), (Q !== re || this.opts.es5) && (Y.push(":"), (0, t.addCodeArg)(Y, re));
          return Y.push("}"), new t._Code(Y);
        }
        // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
        if(H, Y, Q) {
          if (this._blockNode(new x(H)), Y && Q)
            this.code(Y).else().code(Q).endIf();
          else if (Y)
            this.code(Y).endIf();
          else if (Q)
            throw new Error('CodeGen: "else" body without "then" body');
          return this;
        }
        // `else if` clause - invalid without `if` or after `else` clauses
        elseIf(H) {
          return this._elseNode(new x(H));
        }
        // `else` clause - only valid after `if` or `else if` clauses
        else() {
          return this._elseNode(new v());
        }
        // end `if` statement (needed if gen.if was used only with condition)
        endIf() {
          return this._endBlockNode(x, v);
        }
        _for(H, Y) {
          return this._blockNode(H), Y && this.code(Y).endFor(), this;
        }
        // a generic `for` clause (or statement if `forBody` is passed)
        for(H, Y) {
          return this._for(new _(H), Y);
        }
        // `for` statement for a range of values
        forRange(H, Y, Q, re, te = this.opts.es5 ? n.varKinds.var : n.varKinds.let) {
          const le = this._scope.toName(H);
          return this._for(new C(te, le, Y, Q), () => re(le));
        }
        // `for-of` statement (in es5 mode replace with a normal for loop)
        forOf(H, Y, Q, re = n.varKinds.const) {
          const te = this._scope.toName(H);
          if (this.opts.es5) {
            const le = Y instanceof t.Name ? Y : this.var("_arr", Y);
            return this.forRange("_i", 0, (0, t._)`${le}.length`, (fe) => {
              this.var(te, (0, t._)`${le}[${fe}]`), Q(te);
            });
          }
          return this._for(new k("of", re, te, Y), () => Q(te));
        }
        // `for-in` statement.
        // With option `ownProperties` replaced with a `for-of` loop for object keys
        forIn(H, Y, Q, re = this.opts.es5 ? n.varKinds.var : n.varKinds.const) {
          if (this.opts.ownProperties)
            return this.forOf(H, (0, t._)`Object.keys(${Y})`, Q);
          const te = this._scope.toName(H);
          return this._for(new k("in", re, te, Y), () => Q(te));
        }
        // end `for` loop
        endFor() {
          return this._endBlockNode(E);
        }
        // `label` statement
        label(H) {
          return this._leafNode(new u(H));
        }
        // `break` statement
        break(H) {
          return this._leafNode(new d(H));
        }
        // `return` statement
        return(H) {
          const Y = new A();
          if (this._blockNode(Y), this.code(H), Y.nodes.length !== 1)
            throw new Error('CodeGen: "return" should have one node');
          return this._endBlockNode(A);
        }
        // `try` statement
        try(H, Y, Q) {
          if (!Y && !Q)
            throw new Error('CodeGen: "try" without "catch" and "finally"');
          const re = new M();
          if (this._blockNode(re), this.code(H), Y) {
            const te = this.name("e");
            this._currNode = re.catch = new I(te), Y(te);
          }
          return Q && (this._currNode = re.finally = new D(), this.code(Q)), this._endBlockNode(I, D);
        }
        // `throw` statement
        throw(H) {
          return this._leafNode(new p(H));
        }
        // start self-balancing block
        block(H, Y) {
          return this._blockStarts.push(this._nodes.length), H && this.code(H).endBlock(Y), this;
        }
        // end the current self-balancing block
        endBlock(H) {
          const Y = this._blockStarts.pop();
          if (Y === void 0)
            throw new Error("CodeGen: not in self-balancing block");
          const Q = this._nodes.length - Y;
          if (Q < 0 || H !== void 0 && Q !== H)
            throw new Error(`CodeGen: wrong number of nodes: ${Q} vs ${H} expected`);
          return this._nodes.length = Y, this;
        }
        // `function` heading (or definition if funcBody is passed)
        func(H, Y = t.nil, Q, re) {
          return this._blockNode(new R(H, Y, Q)), re && this.code(re).endFunc(), this;
        }
        // end function definition
        endFunc() {
          return this._endBlockNode(R);
        }
        optimize(H = 1) {
          for (; H-- > 0; )
            this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
        }
        _leafNode(H) {
          return this._currNode.nodes.push(H), this;
        }
        _blockNode(H) {
          this._currNode.nodes.push(H), this._nodes.push(H);
        }
        _endBlockNode(H, Y) {
          const Q = this._currNode;
          if (Q instanceof H || Y && Q instanceof Y)
            return this._nodes.pop(), this;
          throw new Error(`CodeGen: not in block "${Y ? `${H.kind}/${Y.kind}` : H.kind}"`);
        }
        _elseNode(H) {
          const Y = this._currNode;
          if (!(Y instanceof x))
            throw new Error('CodeGen: "else" without "if"');
          return this._currNode = Y.else = H, this;
        }
        get _root() {
          return this._nodes[0];
        }
        get _currNode() {
          const H = this._nodes;
          return H[H.length - 1];
        }
        set _currNode(H) {
          const Y = this._nodes;
          Y[Y.length - 1] = H;
        }
      }
      e.CodeGen = L;
      function P(z, H) {
        for (const Y in H)
          z[Y] = (z[Y] || 0) + (H[Y] || 0);
        return z;
      }
      function B(z, H) {
        return H instanceof t._CodeOrName ? P(z, H.names) : z;
      }
      function j(z, H, Y) {
        if (z instanceof t.Name)
          return Q(z);
        if (!re(z))
          return z;
        return new t._Code(z._items.reduce((te, le) => (le instanceof t.Name && (le = Q(le)), le instanceof t._Code ? te.push(...le._items) : te.push(le), te), []));
        function Q(te) {
          const le = Y[te.str];
          return le === void 0 || H[te.str] !== 1 ? te : (delete H[te.str], le);
        }
        function re(te) {
          return te instanceof t._Code && te._items.some((le) => le instanceof t.Name && H[le.str] === 1 && Y[le.str] !== void 0);
        }
      }
      function V(z, H) {
        for (const Y in H)
          z[Y] = (z[Y] || 0) - (H[Y] || 0);
      }
      function F(z) {
        return typeof z == "boolean" || typeof z == "number" || z === null ? !z : (0, t._)`!${X(z)}`;
      }
      e.not = F;
      const G = U(e.operators.AND);
      function W(...z) {
        return z.reduce(G);
      }
      e.and = W;
      const K = U(e.operators.OR);
      function $(...z) {
        return z.reduce(K);
      }
      e.or = $;
      function U(z) {
        return (H, Y) => H === t.nil ? Y : Y === t.nil ? H : (0, t._)`${X(H)} ${z} ${X(Y)}`;
      }
      function X(z) {
        return z instanceof t.Name ? z : (0, t._)`(${z})`;
      }
    }(j_)), j_;
  }
  var mt = {}, l5;
  function Dt() {
    if (l5) return mt;
    l5 = 1, Object.defineProperty(mt, "__esModule", { value: !0 }), mt.checkStrictMode = mt.getErrorPath = mt.Type = mt.useFunc = mt.setEvaluated = mt.evaluatedPropsToName = mt.mergeEvaluated = mt.eachItem = mt.unescapeJsonPointer = mt.escapeJsonPointer = mt.escapeFragment = mt.unescapeFragment = mt.schemaRefOrVal = mt.schemaHasRulesButRef = mt.schemaHasRules = mt.checkUnknownRules = mt.alwaysValidSchema = mt.toHash = void 0;
    const e = yt(), t = I0();
    function n(k) {
      const R = {};
      for (const A of k)
        R[A] = !0;
      return R;
    }
    mt.toHash = n;
    function r(k, R) {
      return typeof R == "boolean" ? R : Object.keys(R).length === 0 ? !0 : (o(k, R), !i(R, k.self.RULES.all));
    }
    mt.alwaysValidSchema = r;
    function o(k, R = k.schema) {
      const { opts: A, self: M } = k;
      if (!A.strictSchema || typeof R == "boolean")
        return;
      const I = M.RULES.keywords;
      for (const D in R)
        I[D] || C(k, `unknown keyword: "${D}"`);
    }
    mt.checkUnknownRules = o;
    function i(k, R) {
      if (typeof k == "boolean")
        return !k;
      for (const A in k)
        if (R[A])
          return !0;
      return !1;
    }
    mt.schemaHasRules = i;
    function a(k, R) {
      if (typeof k == "boolean")
        return !k;
      for (const A in k)
        if (A !== "$ref" && R.all[A])
          return !0;
      return !1;
    }
    mt.schemaHasRulesButRef = a;
    function s({ topSchemaRef: k, schemaPath: R }, A, M, I) {
      if (!I) {
        if (typeof A == "number" || typeof A == "boolean")
          return A;
        if (typeof A == "string")
          return (0, e._)`${A}`;
      }
      return (0, e._)`${k}${R}${(0, e.getProperty)(M)}`;
    }
    mt.schemaRefOrVal = s;
    function l(k) {
      return p(decodeURIComponent(k));
    }
    mt.unescapeFragment = l;
    function u(k) {
      return encodeURIComponent(d(k));
    }
    mt.escapeFragment = u;
    function d(k) {
      return typeof k == "number" ? `${k}` : k.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    mt.escapeJsonPointer = d;
    function p(k) {
      return k.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    mt.unescapeJsonPointer = p;
    function h(k, R) {
      if (Array.isArray(k))
        for (const A of k)
          R(A);
      else
        R(k);
    }
    mt.eachItem = h;
    function g({ mergeNames: k, mergeToName: R, mergeValues: A, resultToName: M }) {
      return (I, D, L, P) => {
        const B = L === void 0 ? D : L instanceof e.Name ? (D instanceof e.Name ? k(I, D, L) : R(I, D, L), L) : D instanceof e.Name ? (R(I, L, D), D) : A(D, L);
        return P === e.Name && !(B instanceof e.Name) ? M(I, B) : B;
      };
    }
    mt.mergeEvaluated = {
      props: g({
        mergeNames: (k, R, A) => k.if((0, e._)`${A} !== true && ${R} !== undefined`, () => {
          k.if((0, e._)`${R} === true`, () => k.assign(A, !0), () => k.assign(A, (0, e._)`${A} || {}`).code((0, e._)`Object.assign(${A}, ${R})`));
        }),
        mergeToName: (k, R, A) => k.if((0, e._)`${A} !== true`, () => {
          R === !0 ? k.assign(A, !0) : (k.assign(A, (0, e._)`${A} || {}`), b(k, A, R));
        }),
        mergeValues: (k, R) => k === !0 ? !0 : { ...k, ...R },
        resultToName: y
      }),
      items: g({
        mergeNames: (k, R, A) => k.if((0, e._)`${A} !== true && ${R} !== undefined`, () => k.assign(A, (0, e._)`${R} === true ? true : ${A} > ${R} ? ${A} : ${R}`)),
        mergeToName: (k, R, A) => k.if((0, e._)`${A} !== true`, () => k.assign(A, R === !0 ? !0 : (0, e._)`${A} > ${R} ? ${A} : ${R}`)),
        mergeValues: (k, R) => k === !0 ? !0 : Math.max(k, R),
        resultToName: (k, R) => k.var("items", R)
      })
    };
    function y(k, R) {
      if (R === !0)
        return k.var("props", !0);
      const A = k.var("props", (0, e._)`{}`);
      return R !== void 0 && b(k, A, R), A;
    }
    mt.evaluatedPropsToName = y;
    function b(k, R, A) {
      Object.keys(A).forEach((M) => k.assign((0, e._)`${R}${(0, e.getProperty)(M)}`, !0));
    }
    mt.setEvaluated = b;
    const v = {};
    function x(k, R) {
      return k.scopeValue("func", {
        ref: R,
        code: v[R.code] || (v[R.code] = new t._Code(R.code))
      });
    }
    mt.useFunc = x;
    var E;
    (function(k) {
      k[k.Num = 0] = "Num", k[k.Str = 1] = "Str";
    })(E || (mt.Type = E = {}));
    function _(k, R, A) {
      if (k instanceof e.Name) {
        const M = R === E.Num;
        return A ? M ? (0, e._)`"[" + ${k} + "]"` : (0, e._)`"['" + ${k} + "']"` : M ? (0, e._)`"/" + ${k}` : (0, e._)`"/" + ${k}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return A ? (0, e.getProperty)(k).toString() : "/" + d(k);
    }
    mt.getErrorPath = _;
    function C(k, R, A = k.opts.strictSchema) {
      if (A) {
        if (R = `strict mode: ${R}`, A === !0)
          throw new Error(R);
        k.self.logger.warn(R);
      }
    }
    return mt.checkStrictMode = C, mt;
  }
  var hy = {}, c5;
  function fl() {
    if (c5) return hy;
    c5 = 1, Object.defineProperty(hy, "__esModule", { value: !0 });
    const e = yt(), t = {
      // validation function arguments
      data: new e.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new e.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new e.Name("instancePath"),
      parentData: new e.Name("parentData"),
      parentDataProperty: new e.Name("parentDataProperty"),
      rootData: new e.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new e.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new e.Name("vErrors"),
      // null or array of validation errors
      errors: new e.Name("errors"),
      // counter of validation errors
      this: new e.Name("this"),
      // "globals"
      self: new e.Name("self"),
      scope: new e.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new e.Name("json"),
      jsonPos: new e.Name("jsonPos"),
      jsonLen: new e.Name("jsonLen"),
      jsonPart: new e.Name("jsonPart")
    };
    return hy.default = t, hy;
  }
  var u5;
  function w1() {
    return u5 || (u5 = 1, function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.extendErrors = e.resetErrorsCount = e.reportExtraError = e.reportError = e.keyword$DataError = e.keywordError = void 0;
      const t = yt(), n = Dt(), r = fl();
      e.keywordError = {
        message: ({ keyword: v }) => (0, t.str)`must pass "${v}" keyword validation`
      }, e.keyword$DataError = {
        message: ({ keyword: v, schemaType: x }) => x ? (0, t.str)`"${v}" keyword must be ${x} ($data)` : (0, t.str)`"${v}" keyword is invalid ($data)`
      };
      function o(v, x = e.keywordError, E, _) {
        const { it: C } = v, { gen: k, compositeRule: R, allErrors: A } = C, M = p(v, x, E);
        _ ?? (R || A) ? l(k, M) : u(C, (0, t._)`[${M}]`);
      }
      e.reportError = o;
      function i(v, x = e.keywordError, E) {
        const { it: _ } = v, { gen: C, compositeRule: k, allErrors: R } = _, A = p(v, x, E);
        l(C, A), k || R || u(_, r.default.vErrors);
      }
      e.reportExtraError = i;
      function a(v, x) {
        v.assign(r.default.errors, x), v.if((0, t._)`${r.default.vErrors} !== null`, () => v.if(x, () => v.assign((0, t._)`${r.default.vErrors}.length`, x), () => v.assign(r.default.vErrors, null)));
      }
      e.resetErrorsCount = a;
      function s({ gen: v, keyword: x, schemaValue: E, data: _, errsCount: C, it: k }) {
        if (C === void 0)
          throw new Error("ajv implementation error");
        const R = v.name("err");
        v.forRange("i", C, r.default.errors, (A) => {
          v.const(R, (0, t._)`${r.default.vErrors}[${A}]`), v.if((0, t._)`${R}.instancePath === undefined`, () => v.assign((0, t._)`${R}.instancePath`, (0, t.strConcat)(r.default.instancePath, k.errorPath))), v.assign((0, t._)`${R}.schemaPath`, (0, t.str)`${k.errSchemaPath}/${x}`), k.opts.verbose && (v.assign((0, t._)`${R}.schema`, E), v.assign((0, t._)`${R}.data`, _));
        });
      }
      e.extendErrors = s;
      function l(v, x) {
        const E = v.const("err", x);
        v.if((0, t._)`${r.default.vErrors} === null`, () => v.assign(r.default.vErrors, (0, t._)`[${E}]`), (0, t._)`${r.default.vErrors}.push(${E})`), v.code((0, t._)`${r.default.errors}++`);
      }
      function u(v, x) {
        const { gen: E, validateName: _, schemaEnv: C } = v;
        C.$async ? E.throw((0, t._)`new ${v.ValidationError}(${x})`) : (E.assign((0, t._)`${_}.errors`, x), E.return(!1));
      }
      const d = {
        keyword: new t.Name("keyword"),
        schemaPath: new t.Name("schemaPath"),
        // also used in JTD errors
        params: new t.Name("params"),
        propertyName: new t.Name("propertyName"),
        message: new t.Name("message"),
        schema: new t.Name("schema"),
        parentSchema: new t.Name("parentSchema")
      };
      function p(v, x, E) {
        const { createErrors: _ } = v.it;
        return _ === !1 ? (0, t._)`{}` : h(v, x, E);
      }
      function h(v, x, E = {}) {
        const { gen: _, it: C } = v, k = [
          g(C, E),
          y(v, E)
        ];
        return b(v, x, k), _.object(...k);
      }
      function g({ errorPath: v }, { instancePath: x }) {
        const E = x ? (0, t.str)`${v}${(0, n.getErrorPath)(x, n.Type.Str)}` : v;
        return [r.default.instancePath, (0, t.strConcat)(r.default.instancePath, E)];
      }
      function y({ keyword: v, it: { errSchemaPath: x } }, { schemaPath: E, parentSchema: _ }) {
        let C = _ ? x : (0, t.str)`${x}/${v}`;
        return E && (C = (0, t.str)`${C}${(0, n.getErrorPath)(E, n.Type.Str)}`), [d.schemaPath, C];
      }
      function b(v, { params: x, message: E }, _) {
        const { keyword: C, data: k, schemaValue: R, it: A } = v, { opts: M, propertyName: I, topSchemaRef: D, schemaPath: L } = A;
        _.push([d.keyword, C], [d.params, typeof x == "function" ? x(v) : x || (0, t._)`{}`]), M.messages && _.push([d.message, typeof E == "function" ? E(v) : E]), M.verbose && _.push([d.schema, R], [d.parentSchema, (0, t._)`${D}${L}`], [r.default.data, k]), I && _.push([d.propertyName, I]);
      }
    }(I_)), I_;
  }
  var f5;
  function o$e() {
    if (f5) return jl;
    f5 = 1, Object.defineProperty(jl, "__esModule", { value: !0 }), jl.boolOrEmptySchema = jl.topBoolOrEmptySchema = void 0;
    const e = w1(), t = yt(), n = fl(), r = {
      message: "boolean schema is false"
    };
    function o(s) {
      const { gen: l, schema: u, validateName: d } = s;
      u === !1 ? a(s, !1) : typeof u == "object" && u.$async === !0 ? l.return(n.default.data) : (l.assign((0, t._)`${d}.errors`, null), l.return(!0));
    }
    jl.topBoolOrEmptySchema = o;
    function i(s, l) {
      const { gen: u, schema: d } = s;
      d === !1 ? (u.var(l, !1), a(s)) : u.var(l, !0);
    }
    jl.boolOrEmptySchema = i;
    function a(s, l) {
      const { gen: u, data: d } = s, p = {
        gen: u,
        keyword: "false schema",
        data: d,
        schema: !1,
        schemaCode: !1,
        schemaValue: !1,
        params: {},
        it: s
      };
      (0, e.reportError)(p, r, void 0, l);
    }
    return jl;
  }
  var ir = {}, Dl = {}, d5;
  function f7() {
    if (d5) return Dl;
    d5 = 1, Object.defineProperty(Dl, "__esModule", { value: !0 }), Dl.getRules = Dl.isJSONType = void 0;
    const e = ["string", "number", "integer", "boolean", "null", "object", "array"], t = new Set(e);
    function n(o) {
      return typeof o == "string" && t.has(o);
    }
    Dl.isJSONType = n;
    function r() {
      const o = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...o, integer: !0, boolean: !0, null: !0 },
        rules: [{ rules: [] }, o.number, o.string, o.array, o.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    return Dl.getRules = r, Dl;
  }
  var Ea = {}, p5;
  function d7() {
    if (p5) return Ea;
    p5 = 1, Object.defineProperty(Ea, "__esModule", { value: !0 }), Ea.shouldUseRule = Ea.shouldUseGroup = Ea.schemaHasRulesForType = void 0;
    function e({ schema: r, self: o }, i) {
      const a = o.RULES.types[i];
      return a && a !== !0 && t(r, a);
    }
    Ea.schemaHasRulesForType = e;
    function t(r, o) {
      return o.rules.some((i) => n(r, i));
    }
    Ea.shouldUseGroup = t;
    function n(r, o) {
      var i;
      return r[o.keyword] !== void 0 || ((i = o.definition.implements) === null || i === void 0 ? void 0 : i.some((a) => r[a] !== void 0));
    }
    return Ea.shouldUseRule = n, Ea;
  }
  var h5;
  function j0() {
    if (h5) return ir;
    h5 = 1, Object.defineProperty(ir, "__esModule", { value: !0 }), ir.reportTypeError = ir.checkDataTypes = ir.checkDataType = ir.coerceAndCheckDataType = ir.getJSONTypes = ir.getSchemaTypes = ir.DataType = void 0;
    const e = f7(), t = d7(), n = w1(), r = yt(), o = Dt();
    var i;
    (function(E) {
      E[E.Correct = 0] = "Correct", E[E.Wrong = 1] = "Wrong";
    })(i || (ir.DataType = i = {}));
    function a(E) {
      const _ = s(E.type);
      if (_.includes("null")) {
        if (E.nullable === !1)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!_.length && E.nullable !== void 0)
          throw new Error('"nullable" cannot be used without "type"');
        E.nullable === !0 && _.push("null");
      }
      return _;
    }
    ir.getSchemaTypes = a;
    function s(E) {
      const _ = Array.isArray(E) ? E : E ? [E] : [];
      if (_.every(e.isJSONType))
        return _;
      throw new Error("type must be JSONType or JSONType[]: " + _.join(","));
    }
    ir.getJSONTypes = s;
    function l(E, _) {
      const { gen: C, data: k, opts: R } = E, A = d(_, R.coerceTypes), M = _.length > 0 && !(A.length === 0 && _.length === 1 && (0, t.schemaHasRulesForType)(E, _[0]));
      if (M) {
        const I = y(_, k, R.strictNumbers, i.Wrong);
        C.if(I, () => {
          A.length ? p(E, _, A) : v(E);
        });
      }
      return M;
    }
    ir.coerceAndCheckDataType = l;
    const u = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function d(E, _) {
      return _ ? E.filter((C) => u.has(C) || _ === "array" && C === "array") : [];
    }
    function p(E, _, C) {
      const { gen: k, data: R, opts: A } = E, M = k.let("dataType", (0, r._)`typeof ${R}`), I = k.let("coerced", (0, r._)`undefined`);
      A.coerceTypes === "array" && k.if((0, r._)`${M} == 'object' && Array.isArray(${R}) && ${R}.length == 1`, () => k.assign(R, (0, r._)`${R}[0]`).assign(M, (0, r._)`typeof ${R}`).if(y(_, R, A.strictNumbers), () => k.assign(I, R))), k.if((0, r._)`${I} !== undefined`);
      for (const L of C)
        (u.has(L) || L === "array" && A.coerceTypes === "array") && D(L);
      k.else(), v(E), k.endIf(), k.if((0, r._)`${I} !== undefined`, () => {
        k.assign(R, I), h(E, I);
      });
      function D(L) {
        switch (L) {
          case "string":
            k.elseIf((0, r._)`${M} == "number" || ${M} == "boolean"`).assign(I, (0, r._)`"" + ${R}`).elseIf((0, r._)`${R} === null`).assign(I, (0, r._)`""`);
            return;
          case "number":
            k.elseIf((0, r._)`${M} == "boolean" || ${R} === null
              || (${M} == "string" && ${R} && ${R} == +${R})`).assign(I, (0, r._)`+${R}`);
            return;
          case "integer":
            k.elseIf((0, r._)`${M} === "boolean" || ${R} === null
              || (${M} === "string" && ${R} && ${R} == +${R} && !(${R} % 1))`).assign(I, (0, r._)`+${R}`);
            return;
          case "boolean":
            k.elseIf((0, r._)`${R} === "false" || ${R} === 0 || ${R} === null`).assign(I, !1).elseIf((0, r._)`${R} === "true" || ${R} === 1`).assign(I, !0);
            return;
          case "null":
            k.elseIf((0, r._)`${R} === "" || ${R} === 0 || ${R} === false`), k.assign(I, null);
            return;
          case "array":
            k.elseIf((0, r._)`${M} === "string" || ${M} === "number"
              || ${M} === "boolean" || ${R} === null`).assign(I, (0, r._)`[${R}]`);
        }
      }
    }
    function h({ gen: E, parentData: _, parentDataProperty: C }, k) {
      E.if((0, r._)`${_} !== undefined`, () => E.assign((0, r._)`${_}[${C}]`, k));
    }
    function g(E, _, C, k = i.Correct) {
      const R = k === i.Correct ? r.operators.EQ : r.operators.NEQ;
      let A;
      switch (E) {
        case "null":
          return (0, r._)`${_} ${R} null`;
        case "array":
          A = (0, r._)`Array.isArray(${_})`;
          break;
        case "object":
          A = (0, r._)`${_} && typeof ${_} == "object" && !Array.isArray(${_})`;
          break;
        case "integer":
          A = M((0, r._)`!(${_} % 1) && !isNaN(${_})`);
          break;
        case "number":
          A = M();
          break;
        default:
          return (0, r._)`typeof ${_} ${R} ${E}`;
      }
      return k === i.Correct ? A : (0, r.not)(A);
      function M(I = r.nil) {
        return (0, r.and)((0, r._)`typeof ${_} == "number"`, I, C ? (0, r._)`isFinite(${_})` : r.nil);
      }
    }
    ir.checkDataType = g;
    function y(E, _, C, k) {
      if (E.length === 1)
        return g(E[0], _, C, k);
      let R;
      const A = (0, o.toHash)(E);
      if (A.array && A.object) {
        const M = (0, r._)`typeof ${_} != "object"`;
        R = A.null ? M : (0, r._)`!${_} || ${M}`, delete A.null, delete A.array, delete A.object;
      } else
        R = r.nil;
      A.number && delete A.integer;
      for (const M in A)
        R = (0, r.and)(R, g(M, _, C, k));
      return R;
    }
    ir.checkDataTypes = y;
    const b = {
      message: ({ schema: E }) => `must be ${E}`,
      params: ({ schema: E, schemaValue: _ }) => typeof E == "string" ? (0, r._)`{type: ${E}}` : (0, r._)`{type: ${_}}`
    };
    function v(E) {
      const _ = x(E);
      (0, n.reportError)(_, b);
    }
    ir.reportTypeError = v;
    function x(E) {
      const { gen: _, data: C, schema: k } = E, R = (0, o.schemaRefOrVal)(E, k, "type");
      return {
        gen: _,
        keyword: "type",
        data: C,
        schema: k.type,
        schemaCode: R,
        schemaValue: R,
        parentSchema: k,
        params: {},
        it: E
      };
    }
    return ir;
  }
  var np = {}, m5;
  function i$e() {
    if (m5) return np;
    m5 = 1, Object.defineProperty(np, "__esModule", { value: !0 }), np.assignDefaults = void 0;
    const e = yt(), t = Dt();
    function n(o, i) {
      const { properties: a, items: s } = o.schema;
      if (i === "object" && a)
        for (const l in a)
          r(o, l, a[l].default);
      else i === "array" && Array.isArray(s) && s.forEach((l, u) => r(o, u, l.default));
    }
    np.assignDefaults = n;
    function r(o, i, a) {
      const { gen: s, compositeRule: l, data: u, opts: d } = o;
      if (a === void 0)
        return;
      const p = (0, e._)`${u}${(0, e.getProperty)(i)}`;
      if (l) {
        (0, t.checkStrictMode)(o, `default is ignored for: ${p}`);
        return;
      }
      let h = (0, e._)`${p} === undefined`;
      d.useDefaults === "empty" && (h = (0, e._)`${h} || ${p} === null || ${p} === ""`), s.if(h, (0, e._)`${p} = ${(0, e.stringify)(a)}`);
    }
    return np;
  }
  var Lo = {}, Yt = {}, g5;
  function oi() {
    if (g5) return Yt;
    g5 = 1, Object.defineProperty(Yt, "__esModule", { value: !0 }), Yt.validateUnion = Yt.validateArray = Yt.usePattern = Yt.callValidateCode = Yt.schemaProperties = Yt.allSchemaProperties = Yt.noPropertyInData = Yt.propertyInData = Yt.isOwnProperty = Yt.hasPropFunc = Yt.reportMissingProp = Yt.checkMissingProp = Yt.checkReportMissingProp = void 0;
    const e = yt(), t = Dt(), n = fl(), r = Dt();
    function o(E, _) {
      const { gen: C, data: k, it: R } = E;
      C.if(d(C, k, _, R.opts.ownProperties), () => {
        E.setParams({ missingProperty: (0, e._)`${_}` }, !0), E.error();
      });
    }
    Yt.checkReportMissingProp = o;
    function i({ gen: E, data: _, it: { opts: C } }, k, R) {
      return (0, e.or)(...k.map((A) => (0, e.and)(d(E, _, A, C.ownProperties), (0, e._)`${R} = ${A}`)));
    }
    Yt.checkMissingProp = i;
    function a(E, _) {
      E.setParams({ missingProperty: _ }, !0), E.error();
    }
    Yt.reportMissingProp = a;
    function s(E) {
      return E.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, e._)`Object.prototype.hasOwnProperty`
      });
    }
    Yt.hasPropFunc = s;
    function l(E, _, C) {
      return (0, e._)`${s(E)}.call(${_}, ${C})`;
    }
    Yt.isOwnProperty = l;
    function u(E, _, C, k) {
      const R = (0, e._)`${_}${(0, e.getProperty)(C)} !== undefined`;
      return k ? (0, e._)`${R} && ${l(E, _, C)}` : R;
    }
    Yt.propertyInData = u;
    function d(E, _, C, k) {
      const R = (0, e._)`${_}${(0, e.getProperty)(C)} === undefined`;
      return k ? (0, e.or)(R, (0, e.not)(l(E, _, C))) : R;
    }
    Yt.noPropertyInData = d;
    function p(E) {
      return E ? Object.keys(E).filter((_) => _ !== "__proto__") : [];
    }
    Yt.allSchemaProperties = p;
    function h(E, _) {
      return p(_).filter((C) => !(0, t.alwaysValidSchema)(E, _[C]));
    }
    Yt.schemaProperties = h;
    function g({ schemaCode: E, data: _, it: { gen: C, topSchemaRef: k, schemaPath: R, errorPath: A }, it: M }, I, D, L) {
      const P = L ? (0, e._)`${E}, ${_}, ${k}${R}` : _, B = [
        [n.default.instancePath, (0, e.strConcat)(n.default.instancePath, A)],
        [n.default.parentData, M.parentData],
        [n.default.parentDataProperty, M.parentDataProperty],
        [n.default.rootData, n.default.rootData]
      ];
      M.opts.dynamicRef && B.push([n.default.dynamicAnchors, n.default.dynamicAnchors]);
      const j = (0, e._)`${P}, ${C.object(...B)}`;
      return D !== e.nil ? (0, e._)`${I}.call(${D}, ${j})` : (0, e._)`${I}(${j})`;
    }
    Yt.callValidateCode = g;
    const y = (0, e._)`new RegExp`;
    function b({ gen: E, it: { opts: _ } }, C) {
      const k = _.unicodeRegExp ? "u" : "", { regExp: R } = _.code, A = R(C, k);
      return E.scopeValue("pattern", {
        key: A.toString(),
        ref: A,
        code: (0, e._)`${R.code === "new RegExp" ? y : (0, r.useFunc)(E, R)}(${C}, ${k})`
      });
    }
    Yt.usePattern = b;
    function v(E) {
      const { gen: _, data: C, keyword: k, it: R } = E, A = _.name("valid");
      if (R.allErrors) {
        const I = _.let("valid", !0);
        return M(() => _.assign(I, !1)), I;
      }
      return _.var(A, !0), M(() => _.break()), A;
      function M(I) {
        const D = _.const("len", (0, e._)`${C}.length`);
        _.forRange("i", 0, D, (L) => {
          E.subschema({
            keyword: k,
            dataProp: L,
            dataPropType: t.Type.Num
          }, A), _.if((0, e.not)(A), I);
        });
      }
    }
    Yt.validateArray = v;
    function x(E) {
      const { gen: _, schema: C, keyword: k, it: R } = E;
      if (!Array.isArray(C))
        throw new Error("ajv implementation error");
      if (C.some((D) => (0, t.alwaysValidSchema)(R, D)) && !R.opts.unevaluated)
        return;
      const M = _.let("valid", !1), I = _.name("_valid");
      _.block(() => C.forEach((D, L) => {
        const P = E.subschema({
          keyword: k,
          schemaProp: L,
          compositeRule: !0
        }, I);
        _.assign(M, (0, e._)`${M} || ${I}`), E.mergeValidEvaluated(P, I) || _.if((0, e.not)(M));
      })), E.result(M, () => E.reset(), () => E.error(!0));
    }
    return Yt.validateUnion = x, Yt;
  }
  var y5;
  function a$e() {
    if (y5) return Lo;
    y5 = 1, Object.defineProperty(Lo, "__esModule", { value: !0 }), Lo.validateKeywordUsage = Lo.validSchemaType = Lo.funcKeywordCode = Lo.macroKeywordCode = void 0;
    const e = yt(), t = fl(), n = oi(), r = w1();
    function o(h, g) {
      const { gen: y, keyword: b, schema: v, parentSchema: x, it: E } = h, _ = g.macro.call(E.self, v, x, E), C = u(y, b, _);
      E.opts.validateSchema !== !1 && E.self.validateSchema(_, !0);
      const k = y.name("valid");
      h.subschema({
        schema: _,
        schemaPath: e.nil,
        errSchemaPath: `${E.errSchemaPath}/${b}`,
        topSchemaRef: C,
        compositeRule: !0
      }, k), h.pass(k, () => h.error(!0));
    }
    Lo.macroKeywordCode = o;
    function i(h, g) {
      var y;
      const { gen: b, keyword: v, schema: x, parentSchema: E, $data: _, it: C } = h;
      l(C, g);
      const k = !_ && g.compile ? g.compile.call(C.self, x, E, C) : g.validate, R = u(b, v, k), A = b.let("valid");
      h.block$data(A, M), h.ok((y = g.valid) !== null && y !== void 0 ? y : A);
      function M() {
        if (g.errors === !1)
          L(), g.modifying && a(h), P(() => h.error());
        else {
          const B = g.async ? I() : D();
          g.modifying && a(h), P(() => s(h, B));
        }
      }
      function I() {
        const B = b.let("ruleErrs", null);
        return b.try(() => L((0, e._)`await `), (j) => b.assign(A, !1).if((0, e._)`${j} instanceof ${C.ValidationError}`, () => b.assign(B, (0, e._)`${j}.errors`), () => b.throw(j))), B;
      }
      function D() {
        const B = (0, e._)`${R}.errors`;
        return b.assign(B, null), L(e.nil), B;
      }
      function L(B = g.async ? (0, e._)`await ` : e.nil) {
        const j = C.opts.passContext ? t.default.this : t.default.self, V = !("compile" in g && !_ || g.schema === !1);
        b.assign(A, (0, e._)`${B}${(0, n.callValidateCode)(h, R, j, V)}`, g.modifying);
      }
      function P(B) {
        var j;
        b.if((0, e.not)((j = g.valid) !== null && j !== void 0 ? j : A), B);
      }
    }
    Lo.funcKeywordCode = i;
    function a(h) {
      const { gen: g, data: y, it: b } = h;
      g.if(b.parentData, () => g.assign(y, (0, e._)`${b.parentData}[${b.parentDataProperty}]`));
    }
    function s(h, g) {
      const { gen: y } = h;
      y.if((0, e._)`Array.isArray(${g})`, () => {
        y.assign(t.default.vErrors, (0, e._)`${t.default.vErrors} === null ? ${g} : ${t.default.vErrors}.concat(${g})`).assign(t.default.errors, (0, e._)`${t.default.vErrors}.length`), (0, r.extendErrors)(h);
      }, () => h.error());
    }
    function l({ schemaEnv: h }, g) {
      if (g.async && !h.$async)
        throw new Error("async keyword in sync schema");
    }
    function u(h, g, y) {
      if (y === void 0)
        throw new Error(`keyword "${g}" failed to compile`);
      return h.scopeValue("keyword", typeof y == "function" ? { ref: y } : { ref: y, code: (0, e.stringify)(y) });
    }
    function d(h, g, y = !1) {
      return !g.length || g.some((b) => b === "array" ? Array.isArray(h) : b === "object" ? h && typeof h == "object" && !Array.isArray(h) : typeof h == b || y && typeof h > "u");
    }
    Lo.validSchemaType = d;
    function p({ schema: h, opts: g, self: y, errSchemaPath: b }, v, x) {
      if (Array.isArray(v.keyword) ? !v.keyword.includes(x) : v.keyword !== x)
        throw new Error("ajv implementation error");
      const E = v.dependencies;
      if (E?.some((_) => !Object.prototype.hasOwnProperty.call(h, _)))
        throw new Error(`parent schema must have dependencies of ${x}: ${E.join(",")}`);
      if (v.validateSchema && !v.validateSchema(h[x])) {
        const C = `keyword "${x}" value is invalid at path "${b}": ` + y.errorsText(v.validateSchema.errors);
        if (g.validateSchema === "log")
          y.logger.error(C);
        else
          throw new Error(C);
      }
    }
    return Lo.validateKeywordUsage = p, Lo;
  }
  var Ca = {}, v5;
  function s$e() {
    if (v5) return Ca;
    v5 = 1, Object.defineProperty(Ca, "__esModule", { value: !0 }), Ca.extendSubschemaMode = Ca.extendSubschemaData = Ca.getSubschema = void 0;
    const e = yt(), t = Dt();
    function n(i, { keyword: a, schemaProp: s, schema: l, schemaPath: u, errSchemaPath: d, topSchemaRef: p }) {
      if (a !== void 0 && l !== void 0)
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      if (a !== void 0) {
        const h = i.schema[a];
        return s === void 0 ? {
          schema: h,
          schemaPath: (0, e._)`${i.schemaPath}${(0, e.getProperty)(a)}`,
          errSchemaPath: `${i.errSchemaPath}/${a}`
        } : {
          schema: h[s],
          schemaPath: (0, e._)`${i.schemaPath}${(0, e.getProperty)(a)}${(0, e.getProperty)(s)}`,
          errSchemaPath: `${i.errSchemaPath}/${a}/${(0, t.escapeFragment)(s)}`
        };
      }
      if (l !== void 0) {
        if (u === void 0 || d === void 0 || p === void 0)
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        return {
          schema: l,
          schemaPath: u,
          topSchemaRef: p,
          errSchemaPath: d
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    Ca.getSubschema = n;
    function r(i, a, { dataProp: s, dataPropType: l, data: u, dataTypes: d, propertyName: p }) {
      if (u !== void 0 && s !== void 0)
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      const { gen: h } = a;
      if (s !== void 0) {
        const { errorPath: y, dataPathArr: b, opts: v } = a, x = h.let("data", (0, e._)`${a.data}${(0, e.getProperty)(s)}`, !0);
        g(x), i.errorPath = (0, e.str)`${y}${(0, t.getErrorPath)(s, l, v.jsPropertySyntax)}`, i.parentDataProperty = (0, e._)`${s}`, i.dataPathArr = [...b, i.parentDataProperty];
      }
      if (u !== void 0) {
        const y = u instanceof e.Name ? u : h.let("data", u, !0);
        g(y), p !== void 0 && (i.propertyName = p);
      }
      d && (i.dataTypes = d);
      function g(y) {
        i.data = y, i.dataLevel = a.dataLevel + 1, i.dataTypes = [], a.definedProperties = /* @__PURE__ */ new Set(), i.parentData = a.data, i.dataNames = [...a.dataNames, y];
      }
    }
    Ca.extendSubschemaData = r;
    function o(i, { jtdDiscriminator: a, jtdMetadata: s, compositeRule: l, createErrors: u, allErrors: d }) {
      l !== void 0 && (i.compositeRule = l), u !== void 0 && (i.createErrors = u), d !== void 0 && (i.allErrors = d), i.jtdDiscriminator = a, i.jtdMetadata = s;
    }
    return Ca.extendSubschemaMode = o, Ca;
  }
  var Cr = {}, L_, b5;
  function p7() {
    return b5 || (b5 = 1, L_ = function e(t, n) {
      if (t === n) return !0;
      if (t && n && typeof t == "object" && typeof n == "object") {
        if (t.constructor !== n.constructor) return !1;
        var r, o, i;
        if (Array.isArray(t)) {
          if (r = t.length, r != n.length) return !1;
          for (o = r; o-- !== 0; )
            if (!e(t[o], n[o])) return !1;
          return !0;
        }
        if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
        if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
        if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
        if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
        for (o = r; o-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
        for (o = r; o-- !== 0; ) {
          var a = i[o];
          if (!e(t[a], n[a])) return !1;
        }
        return !0;
      }
      return t !== t && n !== n;
    }), L_;
  }
  var z_ = { exports: {} }, x5;
  function l$e() {
    if (x5) return z_.exports;
    x5 = 1;
    var e = z_.exports = function(r, o, i) {
      typeof o == "function" && (i = o, o = {}), i = o.cb || i;
      var a = typeof i == "function" ? i : i.pre || function() {
      }, s = i.post || function() {
      };
      t(o, a, s, r, "", r);
    };
    e.keywords = {
      additionalItems: !0,
      items: !0,
      contains: !0,
      additionalProperties: !0,
      propertyNames: !0,
      not: !0,
      if: !0,
      then: !0,
      else: !0
    }, e.arrayKeywords = {
      items: !0,
      allOf: !0,
      anyOf: !0,
      oneOf: !0
    }, e.propsKeywords = {
      $defs: !0,
      definitions: !0,
      properties: !0,
      patternProperties: !0,
      dependencies: !0
    }, e.skipKeywords = {
      default: !0,
      enum: !0,
      const: !0,
      required: !0,
      maximum: !0,
      minimum: !0,
      exclusiveMaximum: !0,
      exclusiveMinimum: !0,
      multipleOf: !0,
      maxLength: !0,
      minLength: !0,
      pattern: !0,
      format: !0,
      maxItems: !0,
      minItems: !0,
      uniqueItems: !0,
      maxProperties: !0,
      minProperties: !0
    };
    function t(r, o, i, a, s, l, u, d, p, h) {
      if (a && typeof a == "object" && !Array.isArray(a)) {
        o(a, s, l, u, d, p, h);
        for (var g in a) {
          var y = a[g];
          if (Array.isArray(y)) {
            if (g in e.arrayKeywords)
              for (var b = 0; b < y.length; b++)
                t(r, o, i, y[b], s + "/" + g + "/" + b, l, s, g, a, b);
          } else if (g in e.propsKeywords) {
            if (y && typeof y == "object")
              for (var v in y)
                t(r, o, i, y[v], s + "/" + g + "/" + n(v), l, s, g, a, v);
          } else (g in e.keywords || r.allKeys && !(g in e.skipKeywords)) && t(r, o, i, y, s + "/" + g, l, s, g, a);
        }
        i(a, s, l, u, d, p, h);
      }
    }
    function n(r) {
      return r.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    return z_.exports;
  }
  var w5;
  function S1() {
    if (w5) return Cr;
    w5 = 1, Object.defineProperty(Cr, "__esModule", { value: !0 }), Cr.getSchemaRefs = Cr.resolveUrl = Cr.normalizeId = Cr._getFullPath = Cr.getFullPath = Cr.inlineRef = void 0;
    const e = Dt(), t = p7(), n = l$e(), r = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function o(b, v = !0) {
      return typeof b == "boolean" ? !0 : v === !0 ? !a(b) : v ? s(b) <= v : !1;
    }
    Cr.inlineRef = o;
    const i = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function a(b) {
      for (const v in b) {
        if (i.has(v))
          return !0;
        const x = b[v];
        if (Array.isArray(x) && x.some(a) || typeof x == "object" && a(x))
          return !0;
      }
      return !1;
    }
    function s(b) {
      let v = 0;
      for (const x in b) {
        if (x === "$ref")
          return 1 / 0;
        if (v++, !r.has(x) && (typeof b[x] == "object" && (0, e.eachItem)(b[x], (E) => v += s(E)), v === 1 / 0))
          return 1 / 0;
      }
      return v;
    }
    function l(b, v = "", x) {
      x !== !1 && (v = p(v));
      const E = b.parse(v);
      return u(b, E);
    }
    Cr.getFullPath = l;
    function u(b, v) {
      return b.serialize(v).split("#")[0] + "#";
    }
    Cr._getFullPath = u;
    const d = /#\/?$/;
    function p(b) {
      return b ? b.replace(d, "") : "";
    }
    Cr.normalizeId = p;
    function h(b, v, x) {
      return x = p(x), b.resolve(v, x);
    }
    Cr.resolveUrl = h;
    const g = /^[a-z_][-a-z0-9._]*$/i;
    function y(b, v) {
      if (typeof b == "boolean")
        return {};
      const { schemaId: x, uriResolver: E } = this.opts, _ = p(b[x] || v), C = { "": _ }, k = l(E, _, !1), R = {}, A = /* @__PURE__ */ new Set();
      return n(b, { allKeys: !0 }, (D, L, P, B) => {
        if (B === void 0)
          return;
        const j = k + L;
        let V = C[B];
        typeof D[x] == "string" && (V = F.call(this, D[x])), G.call(this, D.$anchor), G.call(this, D.$dynamicAnchor), C[L] = V;
        function F(W) {
          const K = this.opts.uriResolver.resolve;
          if (W = p(V ? K(V, W) : W), A.has(W))
            throw I(W);
          A.add(W);
          let $ = this.refs[W];
          return typeof $ == "string" && ($ = this.refs[$]), typeof $ == "object" ? M(D, $.schema, W) : W !== p(j) && (W[0] === "#" ? (M(D, R[W], W), R[W] = D) : this.refs[W] = j), W;
        }
        function G(W) {
          if (typeof W == "string") {
            if (!g.test(W))
              throw new Error(`invalid anchor "${W}"`);
            F.call(this, `#${W}`);
          }
        }
      }), R;
      function M(D, L, P) {
        if (L !== void 0 && !t(D, L))
          throw I(P);
      }
      function I(D) {
        return new Error(`reference "${D}" resolves to more than one schema`);
      }
    }
    return Cr.getSchemaRefs = y, Cr;
  }
  var S5;
  function _1() {
    if (S5) return _a;
    S5 = 1, Object.defineProperty(_a, "__esModule", { value: !0 }), _a.getData = _a.KeywordCxt = _a.validateFunctionCode = void 0;
    const e = o$e(), t = j0(), n = d7(), r = j0(), o = i$e(), i = a$e(), a = s$e(), s = yt(), l = fl(), u = S1(), d = Dt(), p = w1();
    function h(J) {
      if (k(J) && (A(J), C(J))) {
        v(J);
        return;
      }
      g(J, () => (0, e.topBoolOrEmptySchema)(J));
    }
    _a.validateFunctionCode = h;
    function g({ gen: J, validateName: ee, schema: ie, schemaEnv: ae, opts: ge }, Ce) {
      ge.code.es5 ? J.func(ee, (0, s._)`${l.default.data}, ${l.default.valCxt}`, ae.$async, () => {
        J.code((0, s._)`"use strict"; ${E(ie, ge)}`), b(J, ge), J.code(Ce);
      }) : J.func(ee, (0, s._)`${l.default.data}, ${y(ge)}`, ae.$async, () => J.code(E(ie, ge)).code(Ce));
    }
    function y(J) {
      return (0, s._)`{${l.default.instancePath}="", ${l.default.parentData}, ${l.default.parentDataProperty}, ${l.default.rootData}=${l.default.data}${J.dynamicRef ? (0, s._)`, ${l.default.dynamicAnchors}={}` : s.nil}}={}`;
    }
    function b(J, ee) {
      J.if(l.default.valCxt, () => {
        J.var(l.default.instancePath, (0, s._)`${l.default.valCxt}.${l.default.instancePath}`), J.var(l.default.parentData, (0, s._)`${l.default.valCxt}.${l.default.parentData}`), J.var(l.default.parentDataProperty, (0, s._)`${l.default.valCxt}.${l.default.parentDataProperty}`), J.var(l.default.rootData, (0, s._)`${l.default.valCxt}.${l.default.rootData}`), ee.dynamicRef && J.var(l.default.dynamicAnchors, (0, s._)`${l.default.valCxt}.${l.default.dynamicAnchors}`);
      }, () => {
        J.var(l.default.instancePath, (0, s._)`""`), J.var(l.default.parentData, (0, s._)`undefined`), J.var(l.default.parentDataProperty, (0, s._)`undefined`), J.var(l.default.rootData, l.default.data), ee.dynamicRef && J.var(l.default.dynamicAnchors, (0, s._)`{}`);
      });
    }
    function v(J) {
      const { schema: ee, opts: ie, gen: ae } = J;
      g(J, () => {
        ie.$comment && ee.$comment && B(J), D(J), ae.let(l.default.vErrors, null), ae.let(l.default.errors, 0), ie.unevaluated && x(J), M(J), j(J);
      });
    }
    function x(J) {
      const { gen: ee, validateName: ie } = J;
      J.evaluated = ee.const("evaluated", (0, s._)`${ie}.evaluated`), ee.if((0, s._)`${J.evaluated}.dynamicProps`, () => ee.assign((0, s._)`${J.evaluated}.props`, (0, s._)`undefined`)), ee.if((0, s._)`${J.evaluated}.dynamicItems`, () => ee.assign((0, s._)`${J.evaluated}.items`, (0, s._)`undefined`));
    }
    function E(J, ee) {
      const ie = typeof J == "object" && J[ee.schemaId];
      return ie && (ee.code.source || ee.code.process) ? (0, s._)`/*# sourceURL=${ie} */` : s.nil;
    }
    function _(J, ee) {
      if (k(J) && (A(J), C(J))) {
        R(J, ee);
        return;
      }
      (0, e.boolOrEmptySchema)(J, ee);
    }
    function C({ schema: J, self: ee }) {
      if (typeof J == "boolean")
        return !J;
      for (const ie in J)
        if (ee.RULES.all[ie])
          return !0;
      return !1;
    }
    function k(J) {
      return typeof J.schema != "boolean";
    }
    function R(J, ee) {
      const { schema: ie, gen: ae, opts: ge } = J;
      ge.$comment && ie.$comment && B(J), L(J), P(J);
      const Ce = ae.const("_errs", l.default.errors);
      M(J, Ce), ae.var(ee, (0, s._)`${Ce} === ${l.default.errors}`);
    }
    function A(J) {
      (0, d.checkUnknownRules)(J), I(J);
    }
    function M(J, ee) {
      if (J.opts.jtd)
        return F(J, [], !1, ee);
      const ie = (0, t.getSchemaTypes)(J.schema), ae = (0, t.coerceAndCheckDataType)(J, ie);
      F(J, ie, !ae, ee);
    }
    function I(J) {
      const { schema: ee, errSchemaPath: ie, opts: ae, self: ge } = J;
      ee.$ref && ae.ignoreKeywordsWithRef && (0, d.schemaHasRulesButRef)(ee, ge.RULES) && ge.logger.warn(`$ref: keywords ignored in schema at path "${ie}"`);
    }
    function D(J) {
      const { schema: ee, opts: ie } = J;
      ee.default !== void 0 && ie.useDefaults && ie.strictSchema && (0, d.checkStrictMode)(J, "default is ignored in the schema root");
    }
    function L(J) {
      const ee = J.schema[J.opts.schemaId];
      ee && (J.baseId = (0, u.resolveUrl)(J.opts.uriResolver, J.baseId, ee));
    }
    function P(J) {
      if (J.schema.$async && !J.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function B({ gen: J, schemaEnv: ee, schema: ie, errSchemaPath: ae, opts: ge }) {
      const Ce = ie.$comment;
      if (ge.$comment === !0)
        J.code((0, s._)`${l.default.self}.logger.log(${Ce})`);
      else if (typeof ge.$comment == "function") {
        const Ne = (0, s.str)`${ae}/$comment`, Le = J.scopeValue("root", { ref: ee.root });
        J.code((0, s._)`${l.default.self}.opts.$comment(${Ce}, ${Ne}, ${Le}.schema)`);
      }
    }
    function j(J) {
      const { gen: ee, schemaEnv: ie, validateName: ae, ValidationError: ge, opts: Ce } = J;
      ie.$async ? ee.if((0, s._)`${l.default.errors} === 0`, () => ee.return(l.default.data), () => ee.throw((0, s._)`new ${ge}(${l.default.vErrors})`)) : (ee.assign((0, s._)`${ae}.errors`, l.default.vErrors), Ce.unevaluated && V(J), ee.return((0, s._)`${l.default.errors} === 0`));
    }
    function V({ gen: J, evaluated: ee, props: ie, items: ae }) {
      ie instanceof s.Name && J.assign((0, s._)`${ee}.props`, ie), ae instanceof s.Name && J.assign((0, s._)`${ee}.items`, ae);
    }
    function F(J, ee, ie, ae) {
      const { gen: ge, schema: Ce, data: Ne, allErrors: Le, opts: Ve, self: Ke } = J, { RULES: ze } = Ke;
      if (Ce.$ref && (Ve.ignoreKeywordsWithRef || !(0, d.schemaHasRulesButRef)(Ce, ze))) {
        ge.block(() => re(J, "$ref", ze.all.$ref.definition));
        return;
      }
      Ve.jtd || W(J, ee), ge.block(() => {
        for (const ct of ze.rules)
          Me(ct);
        Me(ze.post);
      });
      function Me(ct) {
        (0, n.shouldUseGroup)(Ce, ct) && (ct.type ? (ge.if((0, r.checkDataType)(ct.type, Ne, Ve.strictNumbers)), G(J, ct), ee.length === 1 && ee[0] === ct.type && ie && (ge.else(), (0, r.reportTypeError)(J)), ge.endIf()) : G(J, ct), Le || ge.if((0, s._)`${l.default.errors} === ${ae || 0}`));
      }
    }
    function G(J, ee) {
      const { gen: ie, schema: ae, opts: { useDefaults: ge } } = J;
      ge && (0, o.assignDefaults)(J, ee.type), ie.block(() => {
        for (const Ce of ee.rules)
          (0, n.shouldUseRule)(ae, Ce) && re(J, Ce.keyword, Ce.definition, ee.type);
      });
    }
    function W(J, ee) {
      J.schemaEnv.meta || !J.opts.strictTypes || (K(J, ee), J.opts.allowUnionTypes || $(J, ee), U(J, J.dataTypes));
    }
    function K(J, ee) {
      if (ee.length) {
        if (!J.dataTypes.length) {
          J.dataTypes = ee;
          return;
        }
        ee.forEach((ie) => {
          z(J.dataTypes, ie) || Y(J, `type "${ie}" not allowed by context "${J.dataTypes.join(",")}"`);
        }), H(J, ee);
      }
    }
    function $(J, ee) {
      ee.length > 1 && !(ee.length === 2 && ee.includes("null")) && Y(J, "use allowUnionTypes to allow union type keyword");
    }
    function U(J, ee) {
      const ie = J.self.RULES.all;
      for (const ae in ie) {
        const ge = ie[ae];
        if (typeof ge == "object" && (0, n.shouldUseRule)(J.schema, ge)) {
          const { type: Ce } = ge.definition;
          Ce.length && !Ce.some((Ne) => X(ee, Ne)) && Y(J, `missing type "${Ce.join(",")}" for keyword "${ae}"`);
        }
      }
    }
    function X(J, ee) {
      return J.includes(ee) || ee === "number" && J.includes("integer");
    }
    function z(J, ee) {
      return J.includes(ee) || ee === "integer" && J.includes("number");
    }
    function H(J, ee) {
      const ie = [];
      for (const ae of J.dataTypes)
        z(ee, ae) ? ie.push(ae) : ee.includes("integer") && ae === "number" && ie.push("integer");
      J.dataTypes = ie;
    }
    function Y(J, ee) {
      const ie = J.schemaEnv.baseId + J.errSchemaPath;
      ee += ` at "${ie}" (strictTypes)`, (0, d.checkStrictMode)(J, ee, J.opts.strictTypes);
    }
    class Q {
      constructor(ee, ie, ae) {
        if ((0, i.validateKeywordUsage)(ee, ie, ae), this.gen = ee.gen, this.allErrors = ee.allErrors, this.keyword = ae, this.data = ee.data, this.schema = ee.schema[ae], this.$data = ie.$data && ee.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, d.schemaRefOrVal)(ee, this.schema, ae, this.$data), this.schemaType = ie.schemaType, this.parentSchema = ee.schema, this.params = {}, this.it = ee, this.def = ie, this.$data)
          this.schemaCode = ee.gen.const("vSchema", fe(this.$data, ee));
        else if (this.schemaCode = this.schemaValue, !(0, i.validSchemaType)(this.schema, ie.schemaType, ie.allowUndefined))
          throw new Error(`${ae} value must be ${JSON.stringify(ie.schemaType)}`);
        ("code" in ie ? ie.trackErrors : ie.errors !== !1) && (this.errsCount = ee.gen.const("_errs", l.default.errors));
      }
      result(ee, ie, ae) {
        this.failResult((0, s.not)(ee), ie, ae);
      }
      failResult(ee, ie, ae) {
        this.gen.if(ee), ae ? ae() : this.error(), ie ? (this.gen.else(), ie(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
      }
      pass(ee, ie) {
        this.failResult((0, s.not)(ee), void 0, ie);
      }
      fail(ee) {
        if (ee === void 0) {
          this.error(), this.allErrors || this.gen.if(!1);
          return;
        }
        this.gen.if(ee), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
      }
      fail$data(ee) {
        if (!this.$data)
          return this.fail(ee);
        const { schemaCode: ie } = this;
        this.fail((0, s._)`${ie} !== undefined && (${(0, s.or)(this.invalid$data(), ee)})`);
      }
      error(ee, ie, ae) {
        if (ie) {
          this.setParams(ie), this._error(ee, ae), this.setParams({});
          return;
        }
        this._error(ee, ae);
      }
      _error(ee, ie) {
        (ee ? p.reportExtraError : p.reportError)(this, this.def.error, ie);
      }
      $dataError() {
        (0, p.reportError)(this, this.def.$dataError || p.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, p.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(ee) {
        this.allErrors || this.gen.if(ee);
      }
      setParams(ee, ie) {
        ie ? Object.assign(this.params, ee) : this.params = ee;
      }
      block$data(ee, ie, ae = s.nil) {
        this.gen.block(() => {
          this.check$data(ee, ae), ie();
        });
      }
      check$data(ee = s.nil, ie = s.nil) {
        if (!this.$data)
          return;
        const { gen: ae, schemaCode: ge, schemaType: Ce, def: Ne } = this;
        ae.if((0, s.or)((0, s._)`${ge} === undefined`, ie)), ee !== s.nil && ae.assign(ee, !0), (Ce.length || Ne.validateSchema) && (ae.elseIf(this.invalid$data()), this.$dataError(), ee !== s.nil && ae.assign(ee, !1)), ae.else();
      }
      invalid$data() {
        const { gen: ee, schemaCode: ie, schemaType: ae, def: ge, it: Ce } = this;
        return (0, s.or)(Ne(), Le());
        function Ne() {
          if (ae.length) {
            if (!(ie instanceof s.Name))
              throw new Error("ajv implementation error");
            const Ve = Array.isArray(ae) ? ae : [ae];
            return (0, s._)`${(0, r.checkDataTypes)(Ve, ie, Ce.opts.strictNumbers, r.DataType.Wrong)}`;
          }
          return s.nil;
        }
        function Le() {
          if (ge.validateSchema) {
            const Ve = ee.scopeValue("validate$data", { ref: ge.validateSchema });
            return (0, s._)`!${Ve}(${ie})`;
          }
          return s.nil;
        }
      }
      subschema(ee, ie) {
        const ae = (0, a.getSubschema)(this.it, ee);
        (0, a.extendSubschemaData)(ae, this.it, ee), (0, a.extendSubschemaMode)(ae, ee);
        const ge = { ...this.it, ...ae, items: void 0, props: void 0 };
        return _(ge, ie), ge;
      }
      mergeEvaluated(ee, ie) {
        const { it: ae, gen: ge } = this;
        ae.opts.unevaluated && (ae.props !== !0 && ee.props !== void 0 && (ae.props = d.mergeEvaluated.props(ge, ee.props, ae.props, ie)), ae.items !== !0 && ee.items !== void 0 && (ae.items = d.mergeEvaluated.items(ge, ee.items, ae.items, ie)));
      }
      mergeValidEvaluated(ee, ie) {
        const { it: ae, gen: ge } = this;
        if (ae.opts.unevaluated && (ae.props !== !0 || ae.items !== !0))
          return ge.if(ie, () => this.mergeEvaluated(ee, s.Name)), !0;
      }
    }
    _a.KeywordCxt = Q;
    function re(J, ee, ie, ae) {
      const ge = new Q(J, ie, ee);
      "code" in ie ? ie.code(ge, ae) : ge.$data && ie.validate ? (0, i.funcKeywordCode)(ge, ie) : "macro" in ie ? (0, i.macroKeywordCode)(ge, ie) : (ie.compile || ie.validate) && (0, i.funcKeywordCode)(ge, ie);
    }
    const te = /^\/(?:[^~]|~0|~1)*$/, le = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function fe(J, { dataLevel: ee, dataNames: ie, dataPathArr: ae }) {
      let ge, Ce;
      if (J === "")
        return l.default.rootData;
      if (J[0] === "/") {
        if (!te.test(J))
          throw new Error(`Invalid JSON-pointer: ${J}`);
        ge = J, Ce = l.default.rootData;
      } else {
        const Ke = le.exec(J);
        if (!Ke)
          throw new Error(`Invalid JSON-pointer: ${J}`);
        const ze = +Ke[1];
        if (ge = Ke[2], ge === "#") {
          if (ze >= ee)
            throw new Error(Ve("property/index", ze));
          return ae[ee - ze];
        }
        if (ze > ee)
          throw new Error(Ve("data", ze));
        if (Ce = ie[ee - ze], !ge)
          return Ce;
      }
      let Ne = Ce;
      const Le = ge.split("/");
      for (const Ke of Le)
        Ke && (Ce = (0, s._)`${Ce}${(0, s.getProperty)((0, d.unescapeJsonPointer)(Ke))}`, Ne = (0, s._)`${Ne} && ${Ce}`);
      return Ne;
      function Ve(Ke, ze) {
        return `Cannot access ${Ke} ${ze} levels up, current level is ${ee}`;
      }
    }
    return _a.getData = fe, _a;
  }
  var my = {}, _5;
  function oO() {
    if (_5) return my;
    _5 = 1, Object.defineProperty(my, "__esModule", { value: !0 });
    class e extends Error {
      constructor(n) {
        super("validation failed"), this.errors = n, this.ajv = this.validation = !0;
      }
    }
    return my.default = e, my;
  }
  var gy = {}, E5;
  function E1() {
    if (E5) return gy;
    E5 = 1, Object.defineProperty(gy, "__esModule", { value: !0 });
    const e = S1();
    class t extends Error {
      constructor(r, o, i, a) {
        super(a || `can't resolve reference ${i} from id ${o}`), this.missingRef = (0, e.resolveUrl)(r, o, i), this.missingSchema = (0, e.normalizeId)((0, e.getFullPath)(r, this.missingRef));
      }
    }
    return gy.default = t, gy;
  }
  var Qr = {}, C5;
  function iO() {
    if (C5) return Qr;
    C5 = 1, Object.defineProperty(Qr, "__esModule", { value: !0 }), Qr.resolveSchema = Qr.getCompilingSchema = Qr.resolveRef = Qr.compileSchema = Qr.SchemaEnv = void 0;
    const e = yt(), t = oO(), n = fl(), r = S1(), o = Dt(), i = _1();
    class a {
      constructor(x) {
        var E;
        this.refs = {}, this.dynamicAnchors = {};
        let _;
        typeof x.schema == "object" && (_ = x.schema), this.schema = x.schema, this.schemaId = x.schemaId, this.root = x.root || this, this.baseId = (E = x.baseId) !== null && E !== void 0 ? E : (0, r.normalizeId)(_?.[x.schemaId || "$id"]), this.schemaPath = x.schemaPath, this.localRefs = x.localRefs, this.meta = x.meta, this.$async = _?.$async, this.refs = {};
      }
    }
    Qr.SchemaEnv = a;
    function s(v) {
      const x = d.call(this, v);
      if (x)
        return x;
      const E = (0, r.getFullPath)(this.opts.uriResolver, v.root.baseId), { es5: _, lines: C } = this.opts.code, { ownProperties: k } = this.opts, R = new e.CodeGen(this.scope, { es5: _, lines: C, ownProperties: k });
      let A;
      v.$async && (A = R.scopeValue("Error", {
        ref: t.default,
        code: (0, e._)`require("ajv/dist/runtime/validation_error").default`
      }));
      const M = R.scopeName("validate");
      v.validateName = M;
      const I = {
        gen: R,
        allErrors: this.opts.allErrors,
        data: n.default.data,
        parentData: n.default.parentData,
        parentDataProperty: n.default.parentDataProperty,
        dataNames: [n.default.data],
        dataPathArr: [e.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: R.scopeValue("schema", this.opts.code.source === !0 ? { ref: v.schema, code: (0, e.stringify)(v.schema) } : { ref: v.schema }),
        validateName: M,
        ValidationError: A,
        schema: v.schema,
        schemaEnv: v,
        rootId: E,
        baseId: v.baseId || E,
        schemaPath: e.nil,
        errSchemaPath: v.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, e._)`""`,
        opts: this.opts,
        self: this
      };
      let D;
      try {
        this._compilations.add(v), (0, i.validateFunctionCode)(I), R.optimize(this.opts.code.optimize);
        const L = R.toString();
        D = `${R.scopeRefs(n.default.scope)}return ${L}`, this.opts.code.process && (D = this.opts.code.process(D, v));
        const B = new Function(`${n.default.self}`, `${n.default.scope}`, D)(this, this.scope.get());
        if (this.scope.value(M, { ref: B }), B.errors = null, B.schema = v.schema, B.schemaEnv = v, v.$async && (B.$async = !0), this.opts.code.source === !0 && (B.source = { validateName: M, validateCode: L, scopeValues: R._values }), this.opts.unevaluated) {
          const { props: j, items: V } = I;
          B.evaluated = {
            props: j instanceof e.Name ? void 0 : j,
            items: V instanceof e.Name ? void 0 : V,
            dynamicProps: j instanceof e.Name,
            dynamicItems: V instanceof e.Name
          }, B.source && (B.source.evaluated = (0, e.stringify)(B.evaluated));
        }
        return v.validate = B, v;
      } catch (L) {
        throw delete v.validate, delete v.validateName, D && this.logger.error("Error compiling schema, function code:", D), L;
      } finally {
        this._compilations.delete(v);
      }
    }
    Qr.compileSchema = s;
    function l(v, x, E) {
      var _;
      E = (0, r.resolveUrl)(this.opts.uriResolver, x, E);
      const C = v.refs[E];
      if (C)
        return C;
      let k = h.call(this, v, E);
      if (k === void 0) {
        const R = (_ = v.localRefs) === null || _ === void 0 ? void 0 : _[E], { schemaId: A } = this.opts;
        R && (k = new a({ schema: R, schemaId: A, root: v, baseId: x }));
      }
      if (k !== void 0)
        return v.refs[E] = u.call(this, k);
    }
    Qr.resolveRef = l;
    function u(v) {
      return (0, r.inlineRef)(v.schema, this.opts.inlineRefs) ? v.schema : v.validate ? v : s.call(this, v);
    }
    function d(v) {
      for (const x of this._compilations)
        if (p(x, v))
          return x;
    }
    Qr.getCompilingSchema = d;
    function p(v, x) {
      return v.schema === x.schema && v.root === x.root && v.baseId === x.baseId;
    }
    function h(v, x) {
      let E;
      for (; typeof (E = this.refs[x]) == "string"; )
        x = E;
      return E || this.schemas[x] || g.call(this, v, x);
    }
    function g(v, x) {
      const E = this.opts.uriResolver.parse(x), _ = (0, r._getFullPath)(this.opts.uriResolver, E);
      let C = (0, r.getFullPath)(this.opts.uriResolver, v.baseId, void 0);
      if (Object.keys(v.schema).length > 0 && _ === C)
        return b.call(this, E, v);
      const k = (0, r.normalizeId)(_), R = this.refs[k] || this.schemas[k];
      if (typeof R == "string") {
        const A = g.call(this, v, R);
        return typeof A?.schema != "object" ? void 0 : b.call(this, E, A);
      }
      if (typeof R?.schema == "object") {
        if (R.validate || s.call(this, R), k === (0, r.normalizeId)(x)) {
          const { schema: A } = R, { schemaId: M } = this.opts, I = A[M];
          return I && (C = (0, r.resolveUrl)(this.opts.uriResolver, C, I)), new a({ schema: A, schemaId: M, root: v, baseId: C });
        }
        return b.call(this, E, R);
      }
    }
    Qr.resolveSchema = g;
    const y = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function b(v, { baseId: x, schema: E, root: _ }) {
      var C;
      if (((C = v.fragment) === null || C === void 0 ? void 0 : C[0]) !== "/")
        return;
      for (const A of v.fragment.slice(1).split("/")) {
        if (typeof E == "boolean")
          return;
        const M = E[(0, o.unescapeFragment)(A)];
        if (M === void 0)
          return;
        E = M;
        const I = typeof E == "object" && E[this.opts.schemaId];
        !y.has(A) && I && (x = (0, r.resolveUrl)(this.opts.uriResolver, x, I));
      }
      let k;
      if (typeof E != "boolean" && E.$ref && !(0, o.schemaHasRulesButRef)(E, this.RULES)) {
        const A = (0, r.resolveUrl)(this.opts.uriResolver, x, E.$ref);
        k = g.call(this, _, A);
      }
      const { schemaId: R } = this.opts;
      if (k = k || new a({ schema: E, schemaId: R, root: _, baseId: x }), k.schema !== k.root.schema)
        return k;
    }
    return Qr;
  }
  const c$e = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", u$e = "Meta-schema for $data reference (JSON AnySchema extension proposal)", f$e = "object", d$e = ["$data"], p$e = { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, h$e = !1, m$e = {
    $id: c$e,
    description: u$e,
    type: f$e,
    required: d$e,
    properties: p$e,
    additionalProperties: h$e
  };
  var yy = {}, rp = { exports: {} }, B_, k5;
  function g$e() {
    return k5 || (k5 = 1, B_ = {
      HEX: {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        a: 10,
        A: 10,
        b: 11,
        B: 11,
        c: 12,
        C: 12,
        d: 13,
        D: 13,
        e: 14,
        E: 14,
        f: 15,
        F: 15
      }
    }), B_;
  }
  var U_, T5;
  function y$e() {
    if (T5) return U_;
    T5 = 1;
    const { HEX: e } = g$e(), t = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
    function n(b) {
      if (s(b, ".") < 3)
        return { host: b, isIPV4: !1 };
      const v = b.match(t) || [], [x] = v;
      return x ? { host: a(x, "."), isIPV4: !0 } : { host: b, isIPV4: !1 };
    }
    function r(b, v = !1) {
      let x = "", E = !0;
      for (const _ of b) {
        if (e[_] === void 0) return;
        _ !== "0" && E === !0 && (E = !1), E || (x += _);
      }
      return v && x.length === 0 && (x = "0"), x;
    }
    function o(b) {
      let v = 0;
      const x = { error: !1, address: "", zone: "" }, E = [], _ = [];
      let C = !1, k = !1, R = !1;
      function A() {
        if (_.length) {
          if (C === !1) {
            const M = r(_);
            if (M !== void 0)
              E.push(M);
            else
              return x.error = !0, !1;
          }
          _.length = 0;
        }
        return !0;
      }
      for (let M = 0; M < b.length; M++) {
        const I = b[M];
        if (!(I === "[" || I === "]"))
          if (I === ":") {
            if (k === !0 && (R = !0), !A())
              break;
            if (v++, E.push(":"), v > 7) {
              x.error = !0;
              break;
            }
            M - 1 >= 0 && b[M - 1] === ":" && (k = !0);
            continue;
          } else if (I === "%") {
            if (!A())
              break;
            C = !0;
          } else {
            _.push(I);
            continue;
          }
      }
      return _.length && (C ? x.zone = _.join("") : R ? E.push(_.join("")) : E.push(r(_))), x.address = E.join(""), x;
    }
    function i(b) {
      if (s(b, ":") < 2)
        return { host: b, isIPV6: !1 };
      const v = o(b);
      if (v.error)
        return { host: b, isIPV6: !1 };
      {
        let x = v.address, E = v.address;
        return v.zone && (x += "%" + v.zone, E += "%25" + v.zone), { host: x, escapedHost: E, isIPV6: !0 };
      }
    }
    function a(b, v) {
      let x = "", E = !0;
      const _ = b.length;
      for (let C = 0; C < _; C++) {
        const k = b[C];
        k === "0" && E ? (C + 1 <= _ && b[C + 1] === v || C + 1 === _) && (x += k, E = !1) : (k === v ? E = !0 : E = !1, x += k);
      }
      return x;
    }
    function s(b, v) {
      let x = 0;
      for (let E = 0; E < b.length; E++)
        b[E] === v && x++;
      return x;
    }
    const l = /^\.\.?\//u, u = /^\/\.(?:\/|$)/u, d = /^\/\.\.(?:\/|$)/u, p = /^\/?(?:.|\n)*?(?=\/|$)/u;
    function h(b) {
      const v = [];
      for (; b.length; )
        if (b.match(l))
          b = b.replace(l, "");
        else if (b.match(u))
          b = b.replace(u, "/");
        else if (b.match(d))
          b = b.replace(d, "/"), v.pop();
        else if (b === "." || b === "..")
          b = "";
        else {
          const x = b.match(p);
          if (x) {
            const E = x[0];
            b = b.slice(E.length), v.push(E);
          } else
            throw new Error("Unexpected dot segment condition");
        }
      return v.join("");
    }
    function g(b, v) {
      const x = v !== !0 ? escape : unescape;
      return b.scheme !== void 0 && (b.scheme = x(b.scheme)), b.userinfo !== void 0 && (b.userinfo = x(b.userinfo)), b.host !== void 0 && (b.host = x(b.host)), b.path !== void 0 && (b.path = x(b.path)), b.query !== void 0 && (b.query = x(b.query)), b.fragment !== void 0 && (b.fragment = x(b.fragment)), b;
    }
    function y(b) {
      const v = [];
      if (b.userinfo !== void 0 && (v.push(b.userinfo), v.push("@")), b.host !== void 0) {
        let x = unescape(b.host);
        const E = n(x);
        if (E.isIPV4)
          x = E.host;
        else {
          const _ = i(E.host);
          _.isIPV6 === !0 ? x = `[${_.escapedHost}]` : x = b.host;
        }
        v.push(x);
      }
      return (typeof b.port == "number" || typeof b.port == "string") && (v.push(":"), v.push(String(b.port))), v.length ? v.join("") : void 0;
    }
    return U_ = {
      recomposeAuthority: y,
      normalizeComponentEncoding: g,
      removeDotSegments: h,
      normalizeIPv4: n,
      normalizeIPv6: i,
      stringArrayToHexStripped: r
    }, U_;
  }
  var V_, R5;
  function v$e() {
    if (R5) return V_;
    R5 = 1;
    const e = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu, t = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    function n(E) {
      return typeof E.secure == "boolean" ? E.secure : String(E.scheme).toLowerCase() === "wss";
    }
    function r(E) {
      return E.host || (E.error = E.error || "HTTP URIs must have a host."), E;
    }
    function o(E) {
      const _ = String(E.scheme).toLowerCase() === "https";
      return (E.port === (_ ? 443 : 80) || E.port === "") && (E.port = void 0), E.path || (E.path = "/"), E;
    }
    function i(E) {
      return E.secure = n(E), E.resourceName = (E.path || "/") + (E.query ? "?" + E.query : ""), E.path = void 0, E.query = void 0, E;
    }
    function a(E) {
      if ((E.port === (n(E) ? 443 : 80) || E.port === "") && (E.port = void 0), typeof E.secure == "boolean" && (E.scheme = E.secure ? "wss" : "ws", E.secure = void 0), E.resourceName) {
        const [_, C] = E.resourceName.split("?");
        E.path = _ && _ !== "/" ? _ : void 0, E.query = C, E.resourceName = void 0;
      }
      return E.fragment = void 0, E;
    }
    function s(E, _) {
      if (!E.path)
        return E.error = "URN can not be parsed", E;
      const C = E.path.match(t);
      if (C) {
        const k = _.scheme || E.scheme || "urn";
        E.nid = C[1].toLowerCase(), E.nss = C[2];
        const R = `${k}:${_.nid || E.nid}`, A = x[R];
        E.path = void 0, A && (E = A.parse(E, _));
      } else
        E.error = E.error || "URN can not be parsed.";
      return E;
    }
    function l(E, _) {
      const C = _.scheme || E.scheme || "urn", k = E.nid.toLowerCase(), R = `${C}:${_.nid || k}`, A = x[R];
      A && (E = A.serialize(E, _));
      const M = E, I = E.nss;
      return M.path = `${k || _.nid}:${I}`, _.skipEscape = !0, M;
    }
    function u(E, _) {
      const C = E;
      return C.uuid = C.nss, C.nss = void 0, !_.tolerant && (!C.uuid || !e.test(C.uuid)) && (C.error = C.error || "UUID is not valid."), C;
    }
    function d(E) {
      const _ = E;
      return _.nss = (E.uuid || "").toLowerCase(), _;
    }
    const p = {
      scheme: "http",
      domainHost: !0,
      parse: r,
      serialize: o
    }, h = {
      scheme: "https",
      domainHost: p.domainHost,
      parse: r,
      serialize: o
    }, g = {
      scheme: "ws",
      domainHost: !0,
      parse: i,
      serialize: a
    }, y = {
      scheme: "wss",
      domainHost: g.domainHost,
      parse: g.parse,
      serialize: g.serialize
    }, x = {
      http: p,
      https: h,
      ws: g,
      wss: y,
      urn: {
        scheme: "urn",
        parse: s,
        serialize: l,
        skipNormalize: !0
      },
      "urn:uuid": {
        scheme: "urn:uuid",
        parse: u,
        serialize: d,
        skipNormalize: !0
      }
    };
    return V_ = x, V_;
  }
  var O5;
  function b$e() {
    if (O5) return rp.exports;
    O5 = 1;
    const { normalizeIPv6: e, normalizeIPv4: t, removeDotSegments: n, recomposeAuthority: r, normalizeComponentEncoding: o } = y$e(), i = v$e();
    function a(v, x) {
      return typeof v == "string" ? v = d(y(v, x), x) : typeof v == "object" && (v = y(d(v, x), x)), v;
    }
    function s(v, x, E) {
      const _ = Object.assign({ scheme: "null" }, E), C = l(y(v, _), y(x, _), _, !0);
      return d(C, { ..._, skipEscape: !0 });
    }
    function l(v, x, E, _) {
      const C = {};
      return _ || (v = y(d(v, E), E), x = y(d(x, E), E)), E = E || {}, !E.tolerant && x.scheme ? (C.scheme = x.scheme, C.userinfo = x.userinfo, C.host = x.host, C.port = x.port, C.path = n(x.path || ""), C.query = x.query) : (x.userinfo !== void 0 || x.host !== void 0 || x.port !== void 0 ? (C.userinfo = x.userinfo, C.host = x.host, C.port = x.port, C.path = n(x.path || ""), C.query = x.query) : (x.path ? (x.path.charAt(0) === "/" ? C.path = n(x.path) : ((v.userinfo !== void 0 || v.host !== void 0 || v.port !== void 0) && !v.path ? C.path = "/" + x.path : v.path ? C.path = v.path.slice(0, v.path.lastIndexOf("/") + 1) + x.path : C.path = x.path, C.path = n(C.path)), C.query = x.query) : (C.path = v.path, x.query !== void 0 ? C.query = x.query : C.query = v.query), C.userinfo = v.userinfo, C.host = v.host, C.port = v.port), C.scheme = v.scheme), C.fragment = x.fragment, C;
    }
    function u(v, x, E) {
      return typeof v == "string" ? (v = unescape(v), v = d(o(y(v, E), !0), { ...E, skipEscape: !0 })) : typeof v == "object" && (v = d(o(v, !0), { ...E, skipEscape: !0 })), typeof x == "string" ? (x = unescape(x), x = d(o(y(x, E), !0), { ...E, skipEscape: !0 })) : typeof x == "object" && (x = d(o(x, !0), { ...E, skipEscape: !0 })), v.toLowerCase() === x.toLowerCase();
    }
    function d(v, x) {
      const E = {
        host: v.host,
        scheme: v.scheme,
        userinfo: v.userinfo,
        port: v.port,
        path: v.path,
        query: v.query,
        nid: v.nid,
        nss: v.nss,
        uuid: v.uuid,
        fragment: v.fragment,
        reference: v.reference,
        resourceName: v.resourceName,
        secure: v.secure,
        error: ""
      }, _ = Object.assign({}, x), C = [], k = i[(_.scheme || E.scheme || "").toLowerCase()];
      k && k.serialize && k.serialize(E, _), E.path !== void 0 && (_.skipEscape ? E.path = unescape(E.path) : (E.path = escape(E.path), E.scheme !== void 0 && (E.path = E.path.split("%3A").join(":")))), _.reference !== "suffix" && E.scheme && C.push(E.scheme, ":");
      const R = r(E);
      if (R !== void 0 && (_.reference !== "suffix" && C.push("//"), C.push(R), E.path && E.path.charAt(0) !== "/" && C.push("/")), E.path !== void 0) {
        let A = E.path;
        !_.absolutePath && (!k || !k.absolutePath) && (A = n(A)), R === void 0 && (A = A.replace(/^\/\//u, "/%2F")), C.push(A);
      }
      return E.query !== void 0 && C.push("?", E.query), E.fragment !== void 0 && C.push("#", E.fragment), C.join("");
    }
    const p = Array.from({ length: 127 }, (v, x) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(x)));
    function h(v) {
      let x = 0;
      for (let E = 0, _ = v.length; E < _; ++E)
        if (x = v.charCodeAt(E), x > 126 || p[x])
          return !0;
      return !1;
    }
    const g = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function y(v, x) {
      const E = Object.assign({}, x), _ = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      }, C = v.indexOf("%") !== -1;
      let k = !1;
      E.reference === "suffix" && (v = (E.scheme ? E.scheme + ":" : "") + "//" + v);
      const R = v.match(g);
      if (R) {
        if (_.scheme = R[1], _.userinfo = R[3], _.host = R[4], _.port = parseInt(R[5], 10), _.path = R[6] || "", _.query = R[7], _.fragment = R[8], isNaN(_.port) && (_.port = R[5]), _.host) {
          const M = t(_.host);
          if (M.isIPV4 === !1) {
            const I = e(M.host);
            _.host = I.host.toLowerCase(), k = I.isIPV6;
          } else
            _.host = M.host, k = !0;
        }
        _.scheme === void 0 && _.userinfo === void 0 && _.host === void 0 && _.port === void 0 && _.query === void 0 && !_.path ? _.reference = "same-document" : _.scheme === void 0 ? _.reference = "relative" : _.fragment === void 0 ? _.reference = "absolute" : _.reference = "uri", E.reference && E.reference !== "suffix" && E.reference !== _.reference && (_.error = _.error || "URI is not a " + E.reference + " reference.");
        const A = i[(E.scheme || _.scheme || "").toLowerCase()];
        if (!E.unicodeSupport && (!A || !A.unicodeSupport) && _.host && (E.domainHost || A && A.domainHost) && k === !1 && h(_.host))
          try {
            _.host = URL.domainToASCII(_.host.toLowerCase());
          } catch (M) {
            _.error = _.error || "Host's domain name can not be converted to ASCII: " + M;
          }
        (!A || A && !A.skipNormalize) && (C && _.scheme !== void 0 && (_.scheme = unescape(_.scheme)), C && _.host !== void 0 && (_.host = unescape(_.host)), _.path && (_.path = escape(unescape(_.path))), _.fragment && (_.fragment = encodeURI(decodeURIComponent(_.fragment)))), A && A.parse && A.parse(_, E);
      } else
        _.error = _.error || "URI can not be parsed.";
      return _;
    }
    const b = {
      SCHEMES: i,
      normalize: a,
      resolve: s,
      resolveComponents: l,
      equal: u,
      serialize: d,
      parse: y
    };
    return rp.exports = b, rp.exports.default = b, rp.exports.fastUri = b, rp.exports;
  }
  var A5;
  function x$e() {
    if (A5) return yy;
    A5 = 1, Object.defineProperty(yy, "__esModule", { value: !0 });
    const e = b$e();
    return e.code = 'require("ajv/dist/runtime/uri").default', yy.default = e, yy;
  }
  var N5;
  function w$e() {
    return N5 || (N5 = 1, function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
      var t = _1();
      Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
        return t.KeywordCxt;
      } });
      var n = yt();
      Object.defineProperty(e, "_", { enumerable: !0, get: function() {
        return n._;
      } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
        return n.str;
      } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
        return n.stringify;
      } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
        return n.nil;
      } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
        return n.Name;
      } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
        return n.CodeGen;
      } });
      const r = oO(), o = E1(), i = f7(), a = iO(), s = yt(), l = S1(), u = j0(), d = Dt(), p = m$e, h = x$e(), g = ($, U) => new RegExp($, U);
      g.code = "new RegExp";
      const y = ["removeAdditional", "useDefaults", "coerceTypes"], b = /* @__PURE__ */ new Set([
        "validate",
        "serialize",
        "parse",
        "wrapper",
        "root",
        "schema",
        "keyword",
        "pattern",
        "formats",
        "validate$data",
        "func",
        "obj",
        "Error"
      ]), v = {
        errorDataPath: "",
        format: "`validateFormats: false` can be used instead.",
        nullable: '"nullable" keyword is supported by default.',
        jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
        extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
        missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
        processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
        sourceCode: "Use option `code: {source: true}`",
        strictDefaults: "It is default now, see option `strict`.",
        strictKeywords: "It is default now, see option `strict`.",
        uniqueItems: '"uniqueItems" keyword is always validated.',
        unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
        cache: "Map is used as cache, schema object as key.",
        serialize: "Map is used as cache, schema object as key.",
        ajvErrors: "It is default now."
      }, x = {
        ignoreKeywordsWithRef: "",
        jsPropertySyntax: "",
        unicode: '"minLength"/"maxLength" account for unicode characters by default.'
      }, E = 200;
      function _($) {
        var U, X, z, H, Y, Q, re, te, le, fe, J, ee, ie, ae, ge, Ce, Ne, Le, Ve, Ke, ze, Me, ct, wt, Re;
        const oe = $.strict, ue = (U = $.code) === null || U === void 0 ? void 0 : U.optimize, Se = ue === !0 || ue === void 0 ? 1 : ue || 0, _e = (z = (X = $.code) === null || X === void 0 ? void 0 : X.regExp) !== null && z !== void 0 ? z : g, Ae = (H = $.uriResolver) !== null && H !== void 0 ? H : h.default;
        return {
          strictSchema: (Q = (Y = $.strictSchema) !== null && Y !== void 0 ? Y : oe) !== null && Q !== void 0 ? Q : !0,
          strictNumbers: (te = (re = $.strictNumbers) !== null && re !== void 0 ? re : oe) !== null && te !== void 0 ? te : !0,
          strictTypes: (fe = (le = $.strictTypes) !== null && le !== void 0 ? le : oe) !== null && fe !== void 0 ? fe : "log",
          strictTuples: (ee = (J = $.strictTuples) !== null && J !== void 0 ? J : oe) !== null && ee !== void 0 ? ee : "log",
          strictRequired: (ae = (ie = $.strictRequired) !== null && ie !== void 0 ? ie : oe) !== null && ae !== void 0 ? ae : !1,
          code: $.code ? { ...$.code, optimize: Se, regExp: _e } : { optimize: Se, regExp: _e },
          loopRequired: (ge = $.loopRequired) !== null && ge !== void 0 ? ge : E,
          loopEnum: (Ce = $.loopEnum) !== null && Ce !== void 0 ? Ce : E,
          meta: (Ne = $.meta) !== null && Ne !== void 0 ? Ne : !0,
          messages: (Le = $.messages) !== null && Le !== void 0 ? Le : !0,
          inlineRefs: (Ve = $.inlineRefs) !== null && Ve !== void 0 ? Ve : !0,
          schemaId: (Ke = $.schemaId) !== null && Ke !== void 0 ? Ke : "$id",
          addUsedSchema: (ze = $.addUsedSchema) !== null && ze !== void 0 ? ze : !0,
          validateSchema: (Me = $.validateSchema) !== null && Me !== void 0 ? Me : !0,
          validateFormats: (ct = $.validateFormats) !== null && ct !== void 0 ? ct : !0,
          unicodeRegExp: (wt = $.unicodeRegExp) !== null && wt !== void 0 ? wt : !0,
          int32range: (Re = $.int32range) !== null && Re !== void 0 ? Re : !0,
          uriResolver: Ae
        };
      }
      class C {
        constructor(U = {}) {
          this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), U = this.opts = { ...U, ..._(U) };
          const { es5: X, lines: z } = this.opts.code;
          this.scope = new s.ValueScope({ scope: {}, prefixes: b, es5: X, lines: z }), this.logger = P(U.logger);
          const H = U.validateFormats;
          U.validateFormats = !1, this.RULES = (0, i.getRules)(), k.call(this, v, U, "NOT SUPPORTED"), k.call(this, x, U, "DEPRECATED", "warn"), this._metaOpts = D.call(this), U.formats && M.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), U.keywords && I.call(this, U.keywords), typeof U.meta == "object" && this.addMetaSchema(U.meta), A.call(this), U.validateFormats = H;
        }
        _addVocabularies() {
          this.addKeyword("$async");
        }
        _addDefaultMetaSchema() {
          const { $data: U, meta: X, schemaId: z } = this.opts;
          let H = p;
          z === "id" && (H = { ...p }, H.id = H.$id, delete H.$id), X && U && this.addMetaSchema(H, H[z], !1);
        }
        defaultMeta() {
          const { meta: U, schemaId: X } = this.opts;
          return this.opts.defaultMeta = typeof U == "object" ? U[X] || U : void 0;
        }
        validate(U, X) {
          let z;
          if (typeof U == "string") {
            if (z = this.getSchema(U), !z)
              throw new Error(`no schema with key or ref "${U}"`);
          } else
            z = this.compile(U);
          const H = z(X);
          return "$async" in z || (this.errors = z.errors), H;
        }
        compile(U, X) {
          const z = this._addSchema(U, X);
          return z.validate || this._compileSchemaEnv(z);
        }
        compileAsync(U, X) {
          if (typeof this.opts.loadSchema != "function")
            throw new Error("options.loadSchema should be a function");
          const { loadSchema: z } = this.opts;
          return H.call(this, U, X);
          async function H(fe, J) {
            await Y.call(this, fe.$schema);
            const ee = this._addSchema(fe, J);
            return ee.validate || Q.call(this, ee);
          }
          async function Y(fe) {
            fe && !this.getSchema(fe) && await H.call(this, { $ref: fe }, !0);
          }
          async function Q(fe) {
            try {
              return this._compileSchemaEnv(fe);
            } catch (J) {
              if (!(J instanceof o.default))
                throw J;
              return re.call(this, J), await te.call(this, J.missingSchema), Q.call(this, fe);
            }
          }
          function re({ missingSchema: fe, missingRef: J }) {
            if (this.refs[fe])
              throw new Error(`AnySchema ${fe} is loaded but ${J} cannot be resolved`);
          }
          async function te(fe) {
            const J = await le.call(this, fe);
            this.refs[fe] || await Y.call(this, J.$schema), this.refs[fe] || this.addSchema(J, fe, X);
          }
          async function le(fe) {
            const J = this._loading[fe];
            if (J)
              return J;
            try {
              return await (this._loading[fe] = z(fe));
            } finally {
              delete this._loading[fe];
            }
          }
        }
        // Adds schema to the instance
        addSchema(U, X, z, H = this.opts.validateSchema) {
          if (Array.isArray(U)) {
            for (const Q of U)
              this.addSchema(Q, void 0, z, H);
            return this;
          }
          let Y;
          if (typeof U == "object") {
            const { schemaId: Q } = this.opts;
            if (Y = U[Q], Y !== void 0 && typeof Y != "string")
              throw new Error(`schema ${Q} must be string`);
          }
          return X = (0, l.normalizeId)(X || Y), this._checkUnique(X), this.schemas[X] = this._addSchema(U, z, X, H, !0), this;
        }
        // Add schema that will be used to validate other schemas
        // options in META_IGNORE_OPTIONS are alway set to false
        addMetaSchema(U, X, z = this.opts.validateSchema) {
          return this.addSchema(U, X, !0, z), this;
        }
        //  Validate schema against its meta-schema
        validateSchema(U, X) {
          if (typeof U == "boolean")
            return !0;
          let z;
          if (z = U.$schema, z !== void 0 && typeof z != "string")
            throw new Error("$schema must be a string");
          if (z = z || this.opts.defaultMeta || this.defaultMeta(), !z)
            return this.logger.warn("meta-schema not available"), this.errors = null, !0;
          const H = this.validate(z, U);
          if (!H && X) {
            const Y = "schema is invalid: " + this.errorsText();
            if (this.opts.validateSchema === "log")
              this.logger.error(Y);
            else
              throw new Error(Y);
          }
          return H;
        }
        // Get compiled schema by `key` or `ref`.
        // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
        getSchema(U) {
          let X;
          for (; typeof (X = R.call(this, U)) == "string"; )
            U = X;
          if (X === void 0) {
            const { schemaId: z } = this.opts, H = new a.SchemaEnv({ schema: {}, schemaId: z });
            if (X = a.resolveSchema.call(this, H, U), !X)
              return;
            this.refs[U] = X;
          }
          return X.validate || this._compileSchemaEnv(X);
        }
        // Remove cached schema(s).
        // If no parameter is passed all schemas but meta-schemas are removed.
        // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
        // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
        removeSchema(U) {
          if (U instanceof RegExp)
            return this._removeAllSchemas(this.schemas, U), this._removeAllSchemas(this.refs, U), this;
          switch (typeof U) {
            case "undefined":
              return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
            case "string": {
              const X = R.call(this, U);
              return typeof X == "object" && this._cache.delete(X.schema), delete this.schemas[U], delete this.refs[U], this;
            }
            case "object": {
              const X = U;
              this._cache.delete(X);
              let z = U[this.opts.schemaId];
              return z && (z = (0, l.normalizeId)(z), delete this.schemas[z], delete this.refs[z]), this;
            }
            default:
              throw new Error("ajv.removeSchema: invalid parameter");
          }
        }
        // add "vocabulary" - a collection of keywords
        addVocabulary(U) {
          for (const X of U)
            this.addKeyword(X);
          return this;
        }
        addKeyword(U, X) {
          let z;
          if (typeof U == "string")
            z = U, typeof X == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), X.keyword = z);
          else if (typeof U == "object" && X === void 0) {
            if (X = U, z = X.keyword, Array.isArray(z) && !z.length)
              throw new Error("addKeywords: keyword must be string or non-empty array");
          } else
            throw new Error("invalid addKeywords parameters");
          if (j.call(this, z, X), !X)
            return (0, d.eachItem)(z, (Y) => V.call(this, Y)), this;
          G.call(this, X);
          const H = {
            ...X,
            type: (0, u.getJSONTypes)(X.type),
            schemaType: (0, u.getJSONTypes)(X.schemaType)
          };
          return (0, d.eachItem)(z, H.type.length === 0 ? (Y) => V.call(this, Y, H) : (Y) => H.type.forEach((Q) => V.call(this, Y, H, Q))), this;
        }
        getKeyword(U) {
          const X = this.RULES.all[U];
          return typeof X == "object" ? X.definition : !!X;
        }
        // Remove keyword
        removeKeyword(U) {
          const { RULES: X } = this;
          delete X.keywords[U], delete X.all[U];
          for (const z of X.rules) {
            const H = z.rules.findIndex((Y) => Y.keyword === U);
            H >= 0 && z.rules.splice(H, 1);
          }
          return this;
        }
        // Add format
        addFormat(U, X) {
          return typeof X == "string" && (X = new RegExp(X)), this.formats[U] = X, this;
        }
        errorsText(U = this.errors, { separator: X = ", ", dataVar: z = "data" } = {}) {
          return !U || U.length === 0 ? "No errors" : U.map((H) => `${z}${H.instancePath} ${H.message}`).reduce((H, Y) => H + X + Y);
        }
        $dataMetaSchema(U, X) {
          const z = this.RULES.all;
          U = JSON.parse(JSON.stringify(U));
          for (const H of X) {
            const Y = H.split("/").slice(1);
            let Q = U;
            for (const re of Y)
              Q = Q[re];
            for (const re in z) {
              const te = z[re];
              if (typeof te != "object")
                continue;
              const { $data: le } = te.definition, fe = Q[re];
              le && fe && (Q[re] = K(fe));
            }
          }
          return U;
        }
        _removeAllSchemas(U, X) {
          for (const z in U) {
            const H = U[z];
            (!X || X.test(z)) && (typeof H == "string" ? delete U[z] : H && !H.meta && (this._cache.delete(H.schema), delete U[z]));
          }
        }
        _addSchema(U, X, z, H = this.opts.validateSchema, Y = this.opts.addUsedSchema) {
          let Q;
          const { schemaId: re } = this.opts;
          if (typeof U == "object")
            Q = U[re];
          else {
            if (this.opts.jtd)
              throw new Error("schema must be object");
            if (typeof U != "boolean")
              throw new Error("schema must be object or boolean");
          }
          let te = this._cache.get(U);
          if (te !== void 0)
            return te;
          z = (0, l.normalizeId)(Q || z);
          const le = l.getSchemaRefs.call(this, U, z);
          return te = new a.SchemaEnv({ schema: U, schemaId: re, meta: X, baseId: z, localRefs: le }), this._cache.set(te.schema, te), Y && !z.startsWith("#") && (z && this._checkUnique(z), this.refs[z] = te), H && this.validateSchema(U, !0), te;
        }
        _checkUnique(U) {
          if (this.schemas[U] || this.refs[U])
            throw new Error(`schema with key or id "${U}" already exists`);
        }
        _compileSchemaEnv(U) {
          if (U.meta ? this._compileMetaSchema(U) : a.compileSchema.call(this, U), !U.validate)
            throw new Error("ajv implementation error");
          return U.validate;
        }
        _compileMetaSchema(U) {
          const X = this.opts;
          this.opts = this._metaOpts;
          try {
            a.compileSchema.call(this, U);
          } finally {
            this.opts = X;
          }
        }
      }
      C.ValidationError = r.default, C.MissingRefError = o.default, e.default = C;
      function k($, U, X, z = "error") {
        for (const H in $) {
          const Y = H;
          Y in U && this.logger[z](`${X}: option ${H}. ${$[Y]}`);
        }
      }
      function R($) {
        return $ = (0, l.normalizeId)($), this.schemas[$] || this.refs[$];
      }
      function A() {
        const $ = this.opts.schemas;
        if ($)
          if (Array.isArray($))
            this.addSchema($);
          else
            for (const U in $)
              this.addSchema($[U], U);
      }
      function M() {
        for (const $ in this.opts.formats) {
          const U = this.opts.formats[$];
          U && this.addFormat($, U);
        }
      }
      function I($) {
        if (Array.isArray($)) {
          this.addVocabulary($);
          return;
        }
        this.logger.warn("keywords option as map is deprecated, pass array");
        for (const U in $) {
          const X = $[U];
          X.keyword || (X.keyword = U), this.addKeyword(X);
        }
      }
      function D() {
        const $ = { ...this.opts };
        for (const U of y)
          delete $[U];
        return $;
      }
      const L = { log() {
      }, warn() {
      }, error() {
      } };
      function P($) {
        if ($ === !1)
          return L;
        if ($ === void 0)
          return console;
        if ($.log && $.warn && $.error)
          return $;
        throw new Error("logger must implement log, warn and error methods");
      }
      const B = /^[a-z_$][a-z0-9_$:-]*$/i;
      function j($, U) {
        const { RULES: X } = this;
        if ((0, d.eachItem)($, (z) => {
          if (X.keywords[z])
            throw new Error(`Keyword ${z} is already defined`);
          if (!B.test(z))
            throw new Error(`Keyword ${z} has invalid name`);
        }), !!U && U.$data && !("code" in U || "validate" in U))
          throw new Error('$data keyword must have "code" or "validate" function');
      }
      function V($, U, X) {
        var z;
        const H = U?.post;
        if (X && H)
          throw new Error('keyword with "post" flag cannot have "type"');
        const { RULES: Y } = this;
        let Q = H ? Y.post : Y.rules.find(({ type: te }) => te === X);
        if (Q || (Q = { type: X, rules: [] }, Y.rules.push(Q)), Y.keywords[$] = !0, !U)
          return;
        const re = {
          keyword: $,
          definition: {
            ...U,
            type: (0, u.getJSONTypes)(U.type),
            schemaType: (0, u.getJSONTypes)(U.schemaType)
          }
        };
        U.before ? F.call(this, Q, re, U.before) : Q.rules.push(re), Y.all[$] = re, (z = U.implements) === null || z === void 0 || z.forEach((te) => this.addKeyword(te));
      }
      function F($, U, X) {
        const z = $.rules.findIndex((H) => H.keyword === X);
        z >= 0 ? $.rules.splice(z, 0, U) : ($.rules.push(U), this.logger.warn(`rule ${X} is not defined`));
      }
      function G($) {
        let { metaSchema: U } = $;
        U !== void 0 && ($.$data && this.opts.$data && (U = K(U)), $.validateSchema = this.compile(U, !0));
      }
      const W = {
        $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
      };
      function K($) {
        return { anyOf: [$, W] };
      }
    }($_)), $_;
  }
  var vy = {}, by = {}, xy = {}, M5;
  function S$e() {
    if (M5) return xy;
    M5 = 1, Object.defineProperty(xy, "__esModule", { value: !0 });
    const e = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    return xy.default = e, xy;
  }
  var Ps = {}, P5;
  function _$e() {
    if (P5) return Ps;
    P5 = 1, Object.defineProperty(Ps, "__esModule", { value: !0 }), Ps.callRef = Ps.getValidate = void 0;
    const e = E1(), t = oi(), n = yt(), r = fl(), o = iO(), i = Dt(), a = {
      keyword: "$ref",
      schemaType: "string",
      code(u) {
        const { gen: d, schema: p, it: h } = u, { baseId: g, schemaEnv: y, validateName: b, opts: v, self: x } = h, { root: E } = y;
        if ((p === "#" || p === "#/") && g === E.baseId)
          return C();
        const _ = o.resolveRef.call(x, E, g, p);
        if (_ === void 0)
          throw new e.default(h.opts.uriResolver, g, p);
        if (_ instanceof o.SchemaEnv)
          return k(_);
        return R(_);
        function C() {
          if (y === E)
            return l(u, b, y, y.$async);
          const A = d.scopeValue("root", { ref: E });
          return l(u, (0, n._)`${A}.validate`, E, E.$async);
        }
        function k(A) {
          const M = s(u, A);
          l(u, M, A, A.$async);
        }
        function R(A) {
          const M = d.scopeValue("schema", v.code.source === !0 ? { ref: A, code: (0, n.stringify)(A) } : { ref: A }), I = d.name("valid"), D = u.subschema({
            schema: A,
            dataTypes: [],
            schemaPath: n.nil,
            topSchemaRef: M,
            errSchemaPath: p
          }, I);
          u.mergeEvaluated(D), u.ok(I);
        }
      }
    };
    function s(u, d) {
      const { gen: p } = u;
      return d.validate ? p.scopeValue("validate", { ref: d.validate }) : (0, n._)`${p.scopeValue("wrapper", { ref: d })}.validate`;
    }
    Ps.getValidate = s;
    function l(u, d, p, h) {
      const { gen: g, it: y } = u, { allErrors: b, schemaEnv: v, opts: x } = y, E = x.passContext ? r.default.this : n.nil;
      h ? _() : C();
      function _() {
        if (!v.$async)
          throw new Error("async schema referenced by sync schema");
        const A = g.let("valid");
        g.try(() => {
          g.code((0, n._)`await ${(0, t.callValidateCode)(u, d, E)}`), R(d), b || g.assign(A, !0);
        }, (M) => {
          g.if((0, n._)`!(${M} instanceof ${y.ValidationError})`, () => g.throw(M)), k(M), b || g.assign(A, !1);
        }), u.ok(A);
      }
      function C() {
        u.result((0, t.callValidateCode)(u, d, E), () => R(d), () => k(d));
      }
      function k(A) {
        const M = (0, n._)`${A}.errors`;
        g.assign(r.default.vErrors, (0, n._)`${r.default.vErrors} === null ? ${M} : ${r.default.vErrors}.concat(${M})`), g.assign(r.default.errors, (0, n._)`${r.default.vErrors}.length`);
      }
      function R(A) {
        var M;
        if (!y.opts.unevaluated)
          return;
        const I = (M = p?.validate) === null || M === void 0 ? void 0 : M.evaluated;
        if (y.props !== !0)
          if (I && !I.dynamicProps)
            I.props !== void 0 && (y.props = i.mergeEvaluated.props(g, I.props, y.props));
          else {
            const D = g.var("props", (0, n._)`${A}.evaluated.props`);
            y.props = i.mergeEvaluated.props(g, D, y.props, n.Name);
          }
        if (y.items !== !0)
          if (I && !I.dynamicItems)
            I.items !== void 0 && (y.items = i.mergeEvaluated.items(g, I.items, y.items));
          else {
            const D = g.var("items", (0, n._)`${A}.evaluated.items`);
            y.items = i.mergeEvaluated.items(g, D, y.items, n.Name);
          }
      }
    }
    return Ps.callRef = l, Ps.default = a, Ps;
  }
  var $5;
  function E$e() {
    if ($5) return by;
    $5 = 1, Object.defineProperty(by, "__esModule", { value: !0 });
    const e = S$e(), t = _$e(), n = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      e.default,
      t.default
    ];
    return by.default = n, by;
  }
  var wy = {}, Sy = {}, I5;
  function C$e() {
    if (I5) return Sy;
    I5 = 1, Object.defineProperty(Sy, "__esModule", { value: !0 });
    const e = yt(), t = e.operators, n = {
      maximum: { okStr: "<=", ok: t.LTE, fail: t.GT },
      minimum: { okStr: ">=", ok: t.GTE, fail: t.LT },
      exclusiveMaximum: { okStr: "<", ok: t.LT, fail: t.GTE },
      exclusiveMinimum: { okStr: ">", ok: t.GT, fail: t.LTE }
    }, r = {
      message: ({ keyword: i, schemaCode: a }) => (0, e.str)`must be ${n[i].okStr} ${a}`,
      params: ({ keyword: i, schemaCode: a }) => (0, e._)`{comparison: ${n[i].okStr}, limit: ${a}}`
    }, o = {
      keyword: Object.keys(n),
      type: "number",
      schemaType: "number",
      $data: !0,
      error: r,
      code(i) {
        const { keyword: a, data: s, schemaCode: l } = i;
        i.fail$data((0, e._)`${s} ${n[a].fail} ${l} || isNaN(${s})`);
      }
    };
    return Sy.default = o, Sy;
  }
  var _y = {}, j5;
  function k$e() {
    if (j5) return _y;
    j5 = 1, Object.defineProperty(_y, "__esModule", { value: !0 });
    const e = yt(), n = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: !0,
      error: {
        message: ({ schemaCode: r }) => (0, e.str)`must be multiple of ${r}`,
        params: ({ schemaCode: r }) => (0, e._)`{multipleOf: ${r}}`
      },
      code(r) {
        const { gen: o, data: i, schemaCode: a, it: s } = r, l = s.opts.multipleOfPrecision, u = o.let("res"), d = l ? (0, e._)`Math.abs(Math.round(${u}) - ${u}) > 1e-${l}` : (0, e._)`${u} !== parseInt(${u})`;
        r.fail$data((0, e._)`(${a} === 0 || (${u} = ${i}/${a}, ${d}))`);
      }
    };
    return _y.default = n, _y;
  }
  var Ey = {}, Cy = {}, D5;
  function T$e() {
    if (D5) return Cy;
    D5 = 1, Object.defineProperty(Cy, "__esModule", { value: !0 });
    function e(t) {
      const n = t.length;
      let r = 0, o = 0, i;
      for (; o < n; )
        r++, i = t.charCodeAt(o++), i >= 55296 && i <= 56319 && o < n && (i = t.charCodeAt(o), (i & 64512) === 56320 && o++);
      return r;
    }
    return Cy.default = e, e.code = 'require("ajv/dist/runtime/ucs2length").default', Cy;
  }
  var F5;
  function R$e() {
    if (F5) return Ey;
    F5 = 1, Object.defineProperty(Ey, "__esModule", { value: !0 });
    const e = yt(), t = Dt(), n = T$e(), o = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: !0,
      error: {
        message({ keyword: i, schemaCode: a }) {
          const s = i === "maxLength" ? "more" : "fewer";
          return (0, e.str)`must NOT have ${s} than ${a} characters`;
        },
        params: ({ schemaCode: i }) => (0, e._)`{limit: ${i}}`
      },
      code(i) {
        const { keyword: a, data: s, schemaCode: l, it: u } = i, d = a === "maxLength" ? e.operators.GT : e.operators.LT, p = u.opts.unicode === !1 ? (0, e._)`${s}.length` : (0, e._)`${(0, t.useFunc)(i.gen, n.default)}(${s})`;
        i.fail$data((0, e._)`${p} ${d} ${l}`);
      }
    };
    return Ey.default = o, Ey;
  }
  var ky = {}, L5;
  function O$e() {
    if (L5) return ky;
    L5 = 1, Object.defineProperty(ky, "__esModule", { value: !0 });
    const e = oi(), t = yt(), r = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: !0,
      error: {
        message: ({ schemaCode: o }) => (0, t.str)`must match pattern "${o}"`,
        params: ({ schemaCode: o }) => (0, t._)`{pattern: ${o}}`
      },
      code(o) {
        const { data: i, $data: a, schema: s, schemaCode: l, it: u } = o, d = u.opts.unicodeRegExp ? "u" : "", p = a ? (0, t._)`(new RegExp(${l}, ${d}))` : (0, e.usePattern)(o, s);
        o.fail$data((0, t._)`!${p}.test(${i})`);
      }
    };
    return ky.default = r, ky;
  }
  var Ty = {}, z5;
  function A$e() {
    if (z5) return Ty;
    z5 = 1, Object.defineProperty(Ty, "__esModule", { value: !0 });
    const e = yt(), n = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: !0,
      error: {
        message({ keyword: r, schemaCode: o }) {
          const i = r === "maxProperties" ? "more" : "fewer";
          return (0, e.str)`must NOT have ${i} than ${o} properties`;
        },
        params: ({ schemaCode: r }) => (0, e._)`{limit: ${r}}`
      },
      code(r) {
        const { keyword: o, data: i, schemaCode: a } = r, s = o === "maxProperties" ? e.operators.GT : e.operators.LT;
        r.fail$data((0, e._)`Object.keys(${i}).length ${s} ${a}`);
      }
    };
    return Ty.default = n, Ty;
  }
  var Ry = {}, B5;
  function N$e() {
    if (B5) return Ry;
    B5 = 1, Object.defineProperty(Ry, "__esModule", { value: !0 });
    const e = oi(), t = yt(), n = Dt(), o = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: !0,
      error: {
        message: ({ params: { missingProperty: i } }) => (0, t.str)`must have required property '${i}'`,
        params: ({ params: { missingProperty: i } }) => (0, t._)`{missingProperty: ${i}}`
      },
      code(i) {
        const { gen: a, schema: s, schemaCode: l, data: u, $data: d, it: p } = i, { opts: h } = p;
        if (!d && s.length === 0)
          return;
        const g = s.length >= h.loopRequired;
        if (p.allErrors ? y() : b(), h.strictRequired) {
          const E = i.parentSchema.properties, { definedProperties: _ } = i.it;
          for (const C of s)
            if (E?.[C] === void 0 && !_.has(C)) {
              const k = p.schemaEnv.baseId + p.errSchemaPath, R = `required property "${C}" is not defined at "${k}" (strictRequired)`;
              (0, n.checkStrictMode)(p, R, p.opts.strictRequired);
            }
        }
        function y() {
          if (g || d)
            i.block$data(t.nil, v);
          else
            for (const E of s)
              (0, e.checkReportMissingProp)(i, E);
        }
        function b() {
          const E = a.let("missing");
          if (g || d) {
            const _ = a.let("valid", !0);
            i.block$data(_, () => x(E, _)), i.ok(_);
          } else
            a.if((0, e.checkMissingProp)(i, s, E)), (0, e.reportMissingProp)(i, E), a.else();
        }
        function v() {
          a.forOf("prop", l, (E) => {
            i.setParams({ missingProperty: E }), a.if((0, e.noPropertyInData)(a, u, E, h.ownProperties), () => i.error());
          });
        }
        function x(E, _) {
          i.setParams({ missingProperty: E }), a.forOf(E, l, () => {
            a.assign(_, (0, e.propertyInData)(a, u, E, h.ownProperties)), a.if((0, t.not)(_), () => {
              i.error(), a.break();
            });
          }, t.nil);
        }
      }
    };
    return Ry.default = o, Ry;
  }
  var Oy = {}, U5;
  function M$e() {
    if (U5) return Oy;
    U5 = 1, Object.defineProperty(Oy, "__esModule", { value: !0 });
    const e = yt(), n = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: !0,
      error: {
        message({ keyword: r, schemaCode: o }) {
          const i = r === "maxItems" ? "more" : "fewer";
          return (0, e.str)`must NOT have ${i} than ${o} items`;
        },
        params: ({ schemaCode: r }) => (0, e._)`{limit: ${r}}`
      },
      code(r) {
        const { keyword: o, data: i, schemaCode: a } = r, s = o === "maxItems" ? e.operators.GT : e.operators.LT;
        r.fail$data((0, e._)`${i}.length ${s} ${a}`);
      }
    };
    return Oy.default = n, Oy;
  }
  var Ay = {}, Ny = {}, V5;
  function aO() {
    if (V5) return Ny;
    V5 = 1, Object.defineProperty(Ny, "__esModule", { value: !0 });
    const e = p7();
    return e.code = 'require("ajv/dist/runtime/equal").default', Ny.default = e, Ny;
  }
  var H5;
  function P$e() {
    if (H5) return Ay;
    H5 = 1, Object.defineProperty(Ay, "__esModule", { value: !0 });
    const e = j0(), t = yt(), n = Dt(), r = aO(), i = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: !0,
      error: {
        message: ({ params: { i: a, j: s } }) => (0, t.str)`must NOT have duplicate items (items ## ${s} and ${a} are identical)`,
        params: ({ params: { i: a, j: s } }) => (0, t._)`{i: ${a}, j: ${s}}`
      },
      code(a) {
        const { gen: s, data: l, $data: u, schema: d, parentSchema: p, schemaCode: h, it: g } = a;
        if (!u && !d)
          return;
        const y = s.let("valid"), b = p.items ? (0, e.getSchemaTypes)(p.items) : [];
        a.block$data(y, v, (0, t._)`${h} === false`), a.ok(y);
        function v() {
          const C = s.let("i", (0, t._)`${l}.length`), k = s.let("j");
          a.setParams({ i: C, j: k }), s.assign(y, !0), s.if((0, t._)`${C} > 1`, () => (x() ? E : _)(C, k));
        }
        function x() {
          return b.length > 0 && !b.some((C) => C === "object" || C === "array");
        }
        function E(C, k) {
          const R = s.name("item"), A = (0, e.checkDataTypes)(b, R, g.opts.strictNumbers, e.DataType.Wrong), M = s.const("indices", (0, t._)`{}`);
          s.for((0, t._)`;${C}--;`, () => {
            s.let(R, (0, t._)`${l}[${C}]`), s.if(A, (0, t._)`continue`), b.length > 1 && s.if((0, t._)`typeof ${R} == "string"`, (0, t._)`${R} += "_"`), s.if((0, t._)`typeof ${M}[${R}] == "number"`, () => {
              s.assign(k, (0, t._)`${M}[${R}]`), a.error(), s.assign(y, !1).break();
            }).code((0, t._)`${M}[${R}] = ${C}`);
          });
        }
        function _(C, k) {
          const R = (0, n.useFunc)(s, r.default), A = s.name("outer");
          s.label(A).for((0, t._)`;${C}--;`, () => s.for((0, t._)`${k} = ${C}; ${k}--;`, () => s.if((0, t._)`${R}(${l}[${C}], ${l}[${k}])`, () => {
            a.error(), s.assign(y, !1).break(A);
          })));
        }
      }
    };
    return Ay.default = i, Ay;
  }
  var My = {}, q5;
  function $$e() {
    if (q5) return My;
    q5 = 1, Object.defineProperty(My, "__esModule", { value: !0 });
    const e = yt(), t = Dt(), n = aO(), o = {
      keyword: "const",
      $data: !0,
      error: {
        message: "must be equal to constant",
        params: ({ schemaCode: i }) => (0, e._)`{allowedValue: ${i}}`
      },
      code(i) {
        const { gen: a, data: s, $data: l, schemaCode: u, schema: d } = i;
        l || d && typeof d == "object" ? i.fail$data((0, e._)`!${(0, t.useFunc)(a, n.default)}(${s}, ${u})`) : i.fail((0, e._)`${d} !== ${s}`);
      }
    };
    return My.default = o, My;
  }
  var Py = {}, W5;
  function I$e() {
    if (W5) return Py;
    W5 = 1, Object.defineProperty(Py, "__esModule", { value: !0 });
    const e = yt(), t = Dt(), n = aO(), o = {
      keyword: "enum",
      schemaType: "array",
      $data: !0,
      error: {
        message: "must be equal to one of the allowed values",
        params: ({ schemaCode: i }) => (0, e._)`{allowedValues: ${i}}`
      },
      code(i) {
        const { gen: a, data: s, $data: l, schema: u, schemaCode: d, it: p } = i;
        if (!l && u.length === 0)
          throw new Error("enum must have non-empty array");
        const h = u.length >= p.opts.loopEnum;
        let g;
        const y = () => g ?? (g = (0, t.useFunc)(a, n.default));
        let b;
        if (h || l)
          b = a.let("valid"), i.block$data(b, v);
        else {
          if (!Array.isArray(u))
            throw new Error("ajv implementation error");
          const E = a.const("vSchema", d);
          b = (0, e.or)(...u.map((_, C) => x(E, C)));
        }
        i.pass(b);
        function v() {
          a.assign(b, !1), a.forOf("v", d, (E) => a.if((0, e._)`${y()}(${s}, ${E})`, () => a.assign(b, !0).break()));
        }
        function x(E, _) {
          const C = u[_];
          return typeof C == "object" && C !== null ? (0, e._)`${y()}(${s}, ${E}[${_}])` : (0, e._)`${s} === ${C}`;
        }
      }
    };
    return Py.default = o, Py;
  }
  var G5;
  function j$e() {
    if (G5) return wy;
    G5 = 1, Object.defineProperty(wy, "__esModule", { value: !0 });
    const e = C$e(), t = k$e(), n = R$e(), r = O$e(), o = A$e(), i = N$e(), a = M$e(), s = P$e(), l = $$e(), u = I$e(), d = [
      // number
      e.default,
      t.default,
      // string
      n.default,
      r.default,
      // object
      o.default,
      i.default,
      // array
      a.default,
      s.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      l.default,
      u.default
    ];
    return wy.default = d, wy;
  }
  var $y = {}, Tu = {}, K5;
  function h7() {
    if (K5) return Tu;
    K5 = 1, Object.defineProperty(Tu, "__esModule", { value: !0 }), Tu.validateAdditionalItems = void 0;
    const e = yt(), t = Dt(), r = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error: {
        message: ({ params: { len: i } }) => (0, e.str)`must NOT have more than ${i} items`,
        params: ({ params: { len: i } }) => (0, e._)`{limit: ${i}}`
      },
      code(i) {
        const { parentSchema: a, it: s } = i, { items: l } = a;
        if (!Array.isArray(l)) {
          (0, t.checkStrictMode)(s, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        o(i, l);
      }
    };
    function o(i, a) {
      const { gen: s, schema: l, data: u, keyword: d, it: p } = i;
      p.items = !0;
      const h = s.const("len", (0, e._)`${u}.length`);
      if (l === !1)
        i.setParams({ len: a.length }), i.pass((0, e._)`${h} <= ${a.length}`);
      else if (typeof l == "object" && !(0, t.alwaysValidSchema)(p, l)) {
        const y = s.var("valid", (0, e._)`${h} <= ${a.length}`);
        s.if((0, e.not)(y), () => g(y)), i.ok(y);
      }
      function g(y) {
        s.forRange("i", a.length, h, (b) => {
          i.subschema({ keyword: d, dataProp: b, dataPropType: t.Type.Num }, y), p.allErrors || s.if((0, e.not)(y), () => s.break());
        });
      }
    }
    return Tu.validateAdditionalItems = o, Tu.default = r, Tu;
  }
  var Iy = {}, Ru = {}, Y5;
  function m7() {
    if (Y5) return Ru;
    Y5 = 1, Object.defineProperty(Ru, "__esModule", { value: !0 }), Ru.validateTuple = void 0;
    const e = yt(), t = Dt(), n = oi(), r = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(i) {
        const { schema: a, it: s } = i;
        if (Array.isArray(a))
          return o(i, "additionalItems", a);
        s.items = !0, !(0, t.alwaysValidSchema)(s, a) && i.ok((0, n.validateArray)(i));
      }
    };
    function o(i, a, s = i.schema) {
      const { gen: l, parentSchema: u, data: d, keyword: p, it: h } = i;
      b(u), h.opts.unevaluated && s.length && h.items !== !0 && (h.items = t.mergeEvaluated.items(l, s.length, h.items));
      const g = l.name("valid"), y = l.const("len", (0, e._)`${d}.length`);
      s.forEach((v, x) => {
        (0, t.alwaysValidSchema)(h, v) || (l.if((0, e._)`${y} > ${x}`, () => i.subschema({
          keyword: p,
          schemaProp: x,
          dataProp: x
        }, g)), i.ok(g));
      });
      function b(v) {
        const { opts: x, errSchemaPath: E } = h, _ = s.length, C = _ === v.minItems && (_ === v.maxItems || v[a] === !1);
        if (x.strictTuples && !C) {
          const k = `"${p}" is ${_}-tuple, but minItems or maxItems/${a} are not specified or different at path "${E}"`;
          (0, t.checkStrictMode)(h, k, x.strictTuples);
        }
      }
    }
    return Ru.validateTuple = o, Ru.default = r, Ru;
  }
  var X5;
  function D$e() {
    if (X5) return Iy;
    X5 = 1, Object.defineProperty(Iy, "__esModule", { value: !0 });
    const e = m7(), t = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (n) => (0, e.validateTuple)(n, "items")
    };
    return Iy.default = t, Iy;
  }
  var jy = {}, Z5;
  function F$e() {
    if (Z5) return jy;
    Z5 = 1, Object.defineProperty(jy, "__esModule", { value: !0 });
    const e = yt(), t = Dt(), n = oi(), r = h7(), i = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error: {
        message: ({ params: { len: a } }) => (0, e.str)`must NOT have more than ${a} items`,
        params: ({ params: { len: a } }) => (0, e._)`{limit: ${a}}`
      },
      code(a) {
        const { schema: s, parentSchema: l, it: u } = a, { prefixItems: d } = l;
        u.items = !0, !(0, t.alwaysValidSchema)(u, s) && (d ? (0, r.validateAdditionalItems)(a, d) : a.ok((0, n.validateArray)(a)));
      }
    };
    return jy.default = i, jy;
  }
  var Dy = {}, Q5;
  function L$e() {
    if (Q5) return Dy;
    Q5 = 1, Object.defineProperty(Dy, "__esModule", { value: !0 });
    const e = yt(), t = Dt(), r = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: !0,
      error: {
        message: ({ params: { min: o, max: i } }) => i === void 0 ? (0, e.str)`must contain at least ${o} valid item(s)` : (0, e.str)`must contain at least ${o} and no more than ${i} valid item(s)`,
        params: ({ params: { min: o, max: i } }) => i === void 0 ? (0, e._)`{minContains: ${o}}` : (0, e._)`{minContains: ${o}, maxContains: ${i}}`
      },
      code(o) {
        const { gen: i, schema: a, parentSchema: s, data: l, it: u } = o;
        let d, p;
        const { minContains: h, maxContains: g } = s;
        u.opts.next ? (d = h === void 0 ? 1 : h, p = g) : d = 1;
        const y = i.const("len", (0, e._)`${l}.length`);
        if (o.setParams({ min: d, max: p }), p === void 0 && d === 0) {
          (0, t.checkStrictMode)(u, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
          return;
        }
        if (p !== void 0 && d > p) {
          (0, t.checkStrictMode)(u, '"minContains" > "maxContains" is always invalid'), o.fail();
          return;
        }
        if ((0, t.alwaysValidSchema)(u, a)) {
          let _ = (0, e._)`${y} >= ${d}`;
          p !== void 0 && (_ = (0, e._)`${_} && ${y} <= ${p}`), o.pass(_);
          return;
        }
        u.items = !0;
        const b = i.name("valid");
        p === void 0 && d === 1 ? x(b, () => i.if(b, () => i.break())) : d === 0 ? (i.let(b, !0), p !== void 0 && i.if((0, e._)`${l}.length > 0`, v)) : (i.let(b, !1), v()), o.result(b, () => o.reset());
        function v() {
          const _ = i.name("_valid"), C = i.let("count", 0);
          x(_, () => i.if(_, () => E(C)));
        }
        function x(_, C) {
          i.forRange("i", 0, y, (k) => {
            o.subschema({
              keyword: "contains",
              dataProp: k,
              dataPropType: t.Type.Num,
              compositeRule: !0
            }, _), C();
          });
        }
        function E(_) {
          i.code((0, e._)`${_}++`), p === void 0 ? i.if((0, e._)`${_} >= ${d}`, () => i.assign(b, !0).break()) : (i.if((0, e._)`${_} > ${p}`, () => i.assign(b, !1).break()), d === 1 ? i.assign(b, !0) : i.if((0, e._)`${_} >= ${d}`, () => i.assign(b, !0)));
        }
      }
    };
    return Dy.default = r, Dy;
  }
  var H_ = {}, J5;
  function z$e() {
    return J5 || (J5 = 1, function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0;
      const t = yt(), n = Dt(), r = oi();
      e.error = {
        message: ({ params: { property: l, depsCount: u, deps: d } }) => {
          const p = u === 1 ? "property" : "properties";
          return (0, t.str)`must have ${p} ${d} when property ${l} is present`;
        },
        params: ({ params: { property: l, depsCount: u, deps: d, missingProperty: p } }) => (0, t._)`{property: ${l},
    missingProperty: ${p},
    depsCount: ${u},
    deps: ${d}}`
        // TODO change to reference
      };
      const o = {
        keyword: "dependencies",
        type: "object",
        schemaType: "object",
        error: e.error,
        code(l) {
          const [u, d] = i(l);
          a(l, u), s(l, d);
        }
      };
      function i({ schema: l }) {
        const u = {}, d = {};
        for (const p in l) {
          if (p === "__proto__")
            continue;
          const h = Array.isArray(l[p]) ? u : d;
          h[p] = l[p];
        }
        return [u, d];
      }
      function a(l, u = l.schema) {
        const { gen: d, data: p, it: h } = l;
        if (Object.keys(u).length === 0)
          return;
        const g = d.let("missing");
        for (const y in u) {
          const b = u[y];
          if (b.length === 0)
            continue;
          const v = (0, r.propertyInData)(d, p, y, h.opts.ownProperties);
          l.setParams({
            property: y,
            depsCount: b.length,
            deps: b.join(", ")
          }), h.allErrors ? d.if(v, () => {
            for (const x of b)
              (0, r.checkReportMissingProp)(l, x);
          }) : (d.if((0, t._)`${v} && (${(0, r.checkMissingProp)(l, b, g)})`), (0, r.reportMissingProp)(l, g), d.else());
        }
      }
      e.validatePropertyDeps = a;
      function s(l, u = l.schema) {
        const { gen: d, data: p, keyword: h, it: g } = l, y = d.name("valid");
        for (const b in u)
          (0, n.alwaysValidSchema)(g, u[b]) || (d.if(
            (0, r.propertyInData)(d, p, b, g.opts.ownProperties),
            () => {
              const v = l.subschema({ keyword: h, schemaProp: b }, y);
              l.mergeValidEvaluated(v, y);
            },
            () => d.var(y, !0)
            // TODO var
          ), l.ok(y));
      }
      e.validateSchemaDeps = s, e.default = o;
    }(H_)), H_;
  }
  var Fy = {}, e3;
  function B$e() {
    if (e3) return Fy;
    e3 = 1, Object.defineProperty(Fy, "__esModule", { value: !0 });
    const e = yt(), t = Dt(), r = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error: {
        message: "property name must be valid",
        params: ({ params: o }) => (0, e._)`{propertyName: ${o.propertyName}}`
      },
      code(o) {
        const { gen: i, schema: a, data: s, it: l } = o;
        if ((0, t.alwaysValidSchema)(l, a))
          return;
        const u = i.name("valid");
        i.forIn("key", s, (d) => {
          o.setParams({ propertyName: d }), o.subschema({
            keyword: "propertyNames",
            data: d,
            dataTypes: ["string"],
            propertyName: d,
            compositeRule: !0
          }, u), i.if((0, e.not)(u), () => {
            o.error(!0), l.allErrors || i.break();
          });
        }), o.ok(u);
      }
    };
    return Fy.default = r, Fy;
  }
  var Ly = {}, t3;
  function g7() {
    if (t3) return Ly;
    t3 = 1, Object.defineProperty(Ly, "__esModule", { value: !0 });
    const e = oi(), t = yt(), n = fl(), r = Dt(), i = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: !0,
      trackErrors: !0,
      error: {
        message: "must NOT have additional properties",
        params: ({ params: a }) => (0, t._)`{additionalProperty: ${a.additionalProperty}}`
      },
      code(a) {
        const { gen: s, schema: l, parentSchema: u, data: d, errsCount: p, it: h } = a;
        if (!p)
          throw new Error("ajv implementation error");
        const { allErrors: g, opts: y } = h;
        if (h.props = !0, y.removeAdditional !== "all" && (0, r.alwaysValidSchema)(h, l))
          return;
        const b = (0, e.allSchemaProperties)(u.properties), v = (0, e.allSchemaProperties)(u.patternProperties);
        x(), a.ok((0, t._)`${p} === ${n.default.errors}`);
        function x() {
          s.forIn("key", d, (R) => {
            !b.length && !v.length ? C(R) : s.if(E(R), () => C(R));
          });
        }
        function E(R) {
          let A;
          if (b.length > 8) {
            const M = (0, r.schemaRefOrVal)(h, u.properties, "properties");
            A = (0, e.isOwnProperty)(s, M, R);
          } else b.length ? A = (0, t.or)(...b.map((M) => (0, t._)`${R} === ${M}`)) : A = t.nil;
          return v.length && (A = (0, t.or)(A, ...v.map((M) => (0, t._)`${(0, e.usePattern)(a, M)}.test(${R})`))), (0, t.not)(A);
        }
        function _(R) {
          s.code((0, t._)`delete ${d}[${R}]`);
        }
        function C(R) {
          if (y.removeAdditional === "all" || y.removeAdditional && l === !1) {
            _(R);
            return;
          }
          if (l === !1) {
            a.setParams({ additionalProperty: R }), a.error(), g || s.break();
            return;
          }
          if (typeof l == "object" && !(0, r.alwaysValidSchema)(h, l)) {
            const A = s.name("valid");
            y.removeAdditional === "failing" ? (k(R, A, !1), s.if((0, t.not)(A), () => {
              a.reset(), _(R);
            })) : (k(R, A), g || s.if((0, t.not)(A), () => s.break()));
          }
        }
        function k(R, A, M) {
          const I = {
            keyword: "additionalProperties",
            dataProp: R,
            dataPropType: r.Type.Str
          };
          M === !1 && Object.assign(I, {
            compositeRule: !0,
            createErrors: !1,
            allErrors: !1
          }), a.subschema(I, A);
        }
      }
    };
    return Ly.default = i, Ly;
  }
  var zy = {}, n3;
  function U$e() {
    if (n3) return zy;
    n3 = 1, Object.defineProperty(zy, "__esModule", { value: !0 });
    const e = _1(), t = oi(), n = Dt(), r = g7(), o = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(i) {
        const { gen: a, schema: s, parentSchema: l, data: u, it: d } = i;
        d.opts.removeAdditional === "all" && l.additionalProperties === void 0 && r.default.code(new e.KeywordCxt(d, r.default, "additionalProperties"));
        const p = (0, t.allSchemaProperties)(s);
        for (const v of p)
          d.definedProperties.add(v);
        d.opts.unevaluated && p.length && d.props !== !0 && (d.props = n.mergeEvaluated.props(a, (0, n.toHash)(p), d.props));
        const h = p.filter((v) => !(0, n.alwaysValidSchema)(d, s[v]));
        if (h.length === 0)
          return;
        const g = a.name("valid");
        for (const v of h)
          y(v) ? b(v) : (a.if((0, t.propertyInData)(a, u, v, d.opts.ownProperties)), b(v), d.allErrors || a.else().var(g, !0), a.endIf()), i.it.definedProperties.add(v), i.ok(g);
        function y(v) {
          return d.opts.useDefaults && !d.compositeRule && s[v].default !== void 0;
        }
        function b(v) {
          i.subschema({
            keyword: "properties",
            schemaProp: v,
            dataProp: v
          }, g);
        }
      }
    };
    return zy.default = o, zy;
  }
  var By = {}, r3;
  function V$e() {
    if (r3) return By;
    r3 = 1, Object.defineProperty(By, "__esModule", { value: !0 });
    const e = oi(), t = yt(), n = Dt(), r = Dt(), o = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(i) {
        const { gen: a, schema: s, data: l, parentSchema: u, it: d } = i, { opts: p } = d, h = (0, e.allSchemaProperties)(s), g = h.filter((C) => (0, n.alwaysValidSchema)(d, s[C]));
        if (h.length === 0 || g.length === h.length && (!d.opts.unevaluated || d.props === !0))
          return;
        const y = p.strictSchema && !p.allowMatchingProperties && u.properties, b = a.name("valid");
        d.props !== !0 && !(d.props instanceof t.Name) && (d.props = (0, r.evaluatedPropsToName)(a, d.props));
        const { props: v } = d;
        x();
        function x() {
          for (const C of h)
            y && E(C), d.allErrors ? _(C) : (a.var(b, !0), _(C), a.if(b));
        }
        function E(C) {
          for (const k in y)
            new RegExp(C).test(k) && (0, n.checkStrictMode)(d, `property ${k} matches pattern ${C} (use allowMatchingProperties)`);
        }
        function _(C) {
          a.forIn("key", l, (k) => {
            a.if((0, t._)`${(0, e.usePattern)(i, C)}.test(${k})`, () => {
              const R = g.includes(C);
              R || i.subschema({
                keyword: "patternProperties",
                schemaProp: C,
                dataProp: k,
                dataPropType: r.Type.Str
              }, b), d.opts.unevaluated && v !== !0 ? a.assign((0, t._)`${v}[${k}]`, !0) : !R && !d.allErrors && a.if((0, t.not)(b), () => a.break());
            });
          });
        }
      }
    };
    return By.default = o, By;
  }
  var Uy = {}, o3;
  function H$e() {
    if (o3) return Uy;
    o3 = 1, Object.defineProperty(Uy, "__esModule", { value: !0 });
    const e = Dt(), t = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: !0,
      code(n) {
        const { gen: r, schema: o, it: i } = n;
        if ((0, e.alwaysValidSchema)(i, o)) {
          n.fail();
          return;
        }
        const a = r.name("valid");
        n.subschema({
          keyword: "not",
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }, a), n.failResult(a, () => n.reset(), () => n.error());
      },
      error: { message: "must NOT be valid" }
    };
    return Uy.default = t, Uy;
  }
  var Vy = {}, i3;
  function q$e() {
    if (i3) return Vy;
    i3 = 1, Object.defineProperty(Vy, "__esModule", { value: !0 });
    const t = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: !0,
      code: oi().validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    return Vy.default = t, Vy;
  }
  var Hy = {}, a3;
  function W$e() {
    if (a3) return Hy;
    a3 = 1, Object.defineProperty(Hy, "__esModule", { value: !0 });
    const e = yt(), t = Dt(), r = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: !0,
      error: {
        message: "must match exactly one schema in oneOf",
        params: ({ params: o }) => (0, e._)`{passingSchemas: ${o.passing}}`
      },
      code(o) {
        const { gen: i, schema: a, parentSchema: s, it: l } = o;
        if (!Array.isArray(a))
          throw new Error("ajv implementation error");
        if (l.opts.discriminator && s.discriminator)
          return;
        const u = a, d = i.let("valid", !1), p = i.let("passing", null), h = i.name("_valid");
        o.setParams({ passing: p }), i.block(g), o.result(d, () => o.reset(), () => o.error(!0));
        function g() {
          u.forEach((y, b) => {
            let v;
            (0, t.alwaysValidSchema)(l, y) ? i.var(h, !0) : v = o.subschema({
              keyword: "oneOf",
              schemaProp: b,
              compositeRule: !0
            }, h), b > 0 && i.if((0, e._)`${h} && ${d}`).assign(d, !1).assign(p, (0, e._)`[${p}, ${b}]`).else(), i.if(h, () => {
              i.assign(d, !0), i.assign(p, b), v && o.mergeEvaluated(v, e.Name);
            });
          });
        }
      }
    };
    return Hy.default = r, Hy;
  }
  var qy = {}, s3;
  function G$e() {
    if (s3) return qy;
    s3 = 1, Object.defineProperty(qy, "__esModule", { value: !0 });
    const e = Dt(), t = {
      keyword: "allOf",
      schemaType: "array",
      code(n) {
        const { gen: r, schema: o, it: i } = n;
        if (!Array.isArray(o))
          throw new Error("ajv implementation error");
        const a = r.name("valid");
        o.forEach((s, l) => {
          if ((0, e.alwaysValidSchema)(i, s))
            return;
          const u = n.subschema({ keyword: "allOf", schemaProp: l }, a);
          n.ok(a), n.mergeEvaluated(u);
        });
      }
    };
    return qy.default = t, qy;
  }
  var Wy = {}, l3;
  function K$e() {
    if (l3) return Wy;
    l3 = 1, Object.defineProperty(Wy, "__esModule", { value: !0 });
    const e = yt(), t = Dt(), r = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: !0,
      error: {
        message: ({ params: i }) => (0, e.str)`must match "${i.ifClause}" schema`,
        params: ({ params: i }) => (0, e._)`{failingKeyword: ${i.ifClause}}`
      },
      code(i) {
        const { gen: a, parentSchema: s, it: l } = i;
        s.then === void 0 && s.else === void 0 && (0, t.checkStrictMode)(l, '"if" without "then" and "else" is ignored');
        const u = o(l, "then"), d = o(l, "else");
        if (!u && !d)
          return;
        const p = a.let("valid", !0), h = a.name("_valid");
        if (g(), i.reset(), u && d) {
          const b = a.let("ifClause");
          i.setParams({ ifClause: b }), a.if(h, y("then", b), y("else", b));
        } else u ? a.if(h, y("then")) : a.if((0, e.not)(h), y("else"));
        i.pass(p, () => i.error(!0));
        function g() {
          const b = i.subschema({
            keyword: "if",
            compositeRule: !0,
            createErrors: !1,
            allErrors: !1
          }, h);
          i.mergeEvaluated(b);
        }
        function y(b, v) {
          return () => {
            const x = i.subschema({ keyword: b }, h);
            a.assign(p, h), i.mergeValidEvaluated(x, p), v ? a.assign(v, (0, e._)`${b}`) : i.setParams({ ifClause: b });
          };
        }
      }
    };
    function o(i, a) {
      const s = i.schema[a];
      return s !== void 0 && !(0, t.alwaysValidSchema)(i, s);
    }
    return Wy.default = r, Wy;
  }
  var Gy = {}, c3;
  function Y$e() {
    if (c3) return Gy;
    c3 = 1, Object.defineProperty(Gy, "__esModule", { value: !0 });
    const e = Dt(), t = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword: n, parentSchema: r, it: o }) {
        r.if === void 0 && (0, e.checkStrictMode)(o, `"${n}" without "if" is ignored`);
      }
    };
    return Gy.default = t, Gy;
  }
  var u3;
  function X$e() {
    if (u3) return $y;
    u3 = 1, Object.defineProperty($y, "__esModule", { value: !0 });
    const e = h7(), t = D$e(), n = m7(), r = F$e(), o = L$e(), i = z$e(), a = B$e(), s = g7(), l = U$e(), u = V$e(), d = H$e(), p = q$e(), h = W$e(), g = G$e(), y = K$e(), b = Y$e();
    function v(x = !1) {
      const E = [
        // any
        d.default,
        p.default,
        h.default,
        g.default,
        y.default,
        b.default,
        // object
        a.default,
        s.default,
        i.default,
        l.default,
        u.default
      ];
      return x ? E.push(t.default, r.default) : E.push(e.default, n.default), E.push(o.default), E;
    }
    return $y.default = v, $y;
  }
  var Ky = {}, Yy = {}, f3;
  function Z$e() {
    if (f3) return Yy;
    f3 = 1, Object.defineProperty(Yy, "__esModule", { value: !0 });
    const e = yt(), n = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: !0,
      error: {
        message: ({ schemaCode: r }) => (0, e.str)`must match format "${r}"`,
        params: ({ schemaCode: r }) => (0, e._)`{format: ${r}}`
      },
      code(r, o) {
        const { gen: i, data: a, $data: s, schema: l, schemaCode: u, it: d } = r, { opts: p, errSchemaPath: h, schemaEnv: g, self: y } = d;
        if (!p.validateFormats)
          return;
        s ? b() : v();
        function b() {
          const x = i.scopeValue("formats", {
            ref: y.formats,
            code: p.code.formats
          }), E = i.const("fDef", (0, e._)`${x}[${u}]`), _ = i.let("fType"), C = i.let("format");
          i.if((0, e._)`typeof ${E} == "object" && !(${E} instanceof RegExp)`, () => i.assign(_, (0, e._)`${E}.type || "string"`).assign(C, (0, e._)`${E}.validate`), () => i.assign(_, (0, e._)`"string"`).assign(C, E)), r.fail$data((0, e.or)(k(), R()));
          function k() {
            return p.strictSchema === !1 ? e.nil : (0, e._)`${u} && !${C}`;
          }
          function R() {
            const A = g.$async ? (0, e._)`(${E}.async ? await ${C}(${a}) : ${C}(${a}))` : (0, e._)`${C}(${a})`, M = (0, e._)`(typeof ${C} == "function" ? ${A} : ${C}.test(${a}))`;
            return (0, e._)`${C} && ${C} !== true && ${_} === ${o} && !${M}`;
          }
        }
        function v() {
          const x = y.formats[l];
          if (!x) {
            k();
            return;
          }
          if (x === !0)
            return;
          const [E, _, C] = R(x);
          E === o && r.pass(A());
          function k() {
            if (p.strictSchema === !1) {
              y.logger.warn(M());
              return;
            }
            throw new Error(M());
            function M() {
              return `unknown format "${l}" ignored in schema at path "${h}"`;
            }
          }
          function R(M) {
            const I = M instanceof RegExp ? (0, e.regexpCode)(M) : p.code.formats ? (0, e._)`${p.code.formats}${(0, e.getProperty)(l)}` : void 0, D = i.scopeValue("formats", { key: l, ref: M, code: I });
            return typeof M == "object" && !(M instanceof RegExp) ? [M.type || "string", M.validate, (0, e._)`${D}.validate`] : ["string", M, D];
          }
          function A() {
            if (typeof x == "object" && !(x instanceof RegExp) && x.async) {
              if (!g.$async)
                throw new Error("async format in sync schema");
              return (0, e._)`await ${C}(${a})`;
            }
            return typeof _ == "function" ? (0, e._)`${C}(${a})` : (0, e._)`${C}.test(${a})`;
          }
        }
      }
    };
    return Yy.default = n, Yy;
  }
  var d3;
  function Q$e() {
    if (d3) return Ky;
    d3 = 1, Object.defineProperty(Ky, "__esModule", { value: !0 });
    const t = [Z$e().default];
    return Ky.default = t, Ky;
  }
  var Fl = {}, p3;
  function J$e() {
    return p3 || (p3 = 1, Object.defineProperty(Fl, "__esModule", { value: !0 }), Fl.contentVocabulary = Fl.metadataVocabulary = void 0, Fl.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ], Fl.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ]), Fl;
  }
  var h3;
  function e2e() {
    if (h3) return vy;
    h3 = 1, Object.defineProperty(vy, "__esModule", { value: !0 });
    const e = E$e(), t = j$e(), n = X$e(), r = Q$e(), o = J$e(), i = [
      e.default,
      t.default,
      (0, n.default)(),
      r.default,
      o.metadataVocabulary,
      o.contentVocabulary
    ];
    return vy.default = i, vy;
  }
  var Xy = {}, op = {}, m3;
  function t2e() {
    if (m3) return op;
    m3 = 1, Object.defineProperty(op, "__esModule", { value: !0 }), op.DiscrError = void 0;
    var e;
    return function(t) {
      t.Tag = "tag", t.Mapping = "mapping";
    }(e || (op.DiscrError = e = {})), op;
  }
  var g3;
  function n2e() {
    if (g3) return Xy;
    g3 = 1, Object.defineProperty(Xy, "__esModule", { value: !0 });
    const e = yt(), t = t2e(), n = iO(), r = E1(), o = Dt(), a = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error: {
        message: ({ params: { discrError: s, tagName: l } }) => s === t.DiscrError.Tag ? `tag "${l}" must be string` : `value of tag "${l}" must be in oneOf`,
        params: ({ params: { discrError: s, tag: l, tagName: u } }) => (0, e._)`{error: ${s}, tag: ${u}, tagValue: ${l}}`
      },
      code(s) {
        const { gen: l, data: u, schema: d, parentSchema: p, it: h } = s, { oneOf: g } = p;
        if (!h.opts.discriminator)
          throw new Error("discriminator: requires discriminator option");
        const y = d.propertyName;
        if (typeof y != "string")
          throw new Error("discriminator: requires propertyName");
        if (d.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!g)
          throw new Error("discriminator: requires oneOf keyword");
        const b = l.let("valid", !1), v = l.const("tag", (0, e._)`${u}${(0, e.getProperty)(y)}`);
        l.if((0, e._)`typeof ${v} == "string"`, () => x(), () => s.error(!1, { discrError: t.DiscrError.Tag, tag: v, tagName: y })), s.ok(b);
        function x() {
          const C = _();
          l.if(!1);
          for (const k in C)
            l.elseIf((0, e._)`${v} === ${k}`), l.assign(b, E(C[k]));
          l.else(), s.error(!1, { discrError: t.DiscrError.Mapping, tag: v, tagName: y }), l.endIf();
        }
        function E(C) {
          const k = l.name("valid"), R = s.subschema({ keyword: "oneOf", schemaProp: C }, k);
          return s.mergeEvaluated(R, e.Name), k;
        }
        function _() {
          var C;
          const k = {}, R = M(p);
          let A = !0;
          for (let L = 0; L < g.length; L++) {
            let P = g[L];
            if (P?.$ref && !(0, o.schemaHasRulesButRef)(P, h.self.RULES)) {
              const j = P.$ref;
              if (P = n.resolveRef.call(h.self, h.schemaEnv.root, h.baseId, j), P instanceof n.SchemaEnv && (P = P.schema), P === void 0)
                throw new r.default(h.opts.uriResolver, h.baseId, j);
            }
            const B = (C = P?.properties) === null || C === void 0 ? void 0 : C[y];
            if (typeof B != "object")
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${y}"`);
            A = A && (R || M(P)), I(B, L);
          }
          if (!A)
            throw new Error(`discriminator: "${y}" must be required`);
          return k;
          function M({ required: L }) {
            return Array.isArray(L) && L.includes(y);
          }
          function I(L, P) {
            if (L.const)
              D(L.const, P);
            else if (L.enum)
              for (const B of L.enum)
                D(B, P);
            else
              throw new Error(`discriminator: "properties/${y}" must have "const" or "enum"`);
          }
          function D(L, P) {
            if (typeof L != "string" || L in k)
              throw new Error(`discriminator: "${y}" values must be unique strings`);
            k[L] = P;
          }
        }
      }
    };
    return Xy.default = a, Xy;
  }
  const r2e = "http://json-schema.org/draft-07/schema#", o2e = "http://json-schema.org/draft-07/schema#", i2e = "Core schema meta-schema", a2e = { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] } }, s2e = ["object", "boolean"], l2e = { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: !0, readOnly: { type: "boolean", default: !1 }, examples: { type: "array", items: !0 }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: !0 }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: !1 }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: !0, enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: !0 }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, c2e = {
    $schema: r2e,
    $id: o2e,
    title: i2e,
    definitions: a2e,
    type: s2e,
    properties: l2e,
    default: !0
  };
  var y3;
  function y7() {
    return y3 || (y3 = 1, function(e, t) {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = t.Ajv = void 0;
      const n = w$e(), r = e2e(), o = n2e(), i = c2e, a = ["/properties"], s = "http://json-schema.org/draft-07/schema";
      class l extends n.default {
        _addVocabularies() {
          super._addVocabularies(), r.default.forEach((y) => this.addVocabulary(y)), this.opts.discriminator && this.addKeyword(o.default);
        }
        _addDefaultMetaSchema() {
          if (super._addDefaultMetaSchema(), !this.opts.meta)
            return;
          const y = this.opts.$data ? this.$dataMetaSchema(i, a) : i;
          this.addMetaSchema(y, s, !1), this.refs["http://json-schema.org/schema"] = s;
        }
        defaultMeta() {
          return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(s) ? s : void 0);
        }
      }
      t.Ajv = l, e.exports = t = l, e.exports.Ajv = l, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = l;
      var u = _1();
      Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
        return u.KeywordCxt;
      } });
      var d = yt();
      Object.defineProperty(t, "_", { enumerable: !0, get: function() {
        return d._;
      } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
        return d.str;
      } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
        return d.stringify;
      } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
        return d.nil;
      } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
        return d.Name;
      } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
        return d.CodeGen;
      } });
      var p = oO();
      Object.defineProperty(t, "ValidationError", { enumerable: !0, get: function() {
        return p.default;
      } });
      var h = E1();
      Object.defineProperty(t, "MissingRefError", { enumerable: !0, get: function() {
        return h.default;
      } });
    }(py, py.exports)), py.exports;
  }
  var u2e = y7();
  const f2e = /* @__PURE__ */ Jo(u2e);
  var Zy = { exports: {} }, q_ = {}, v3;
  function d2e() {
    return v3 || (v3 = 1, function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.formatNames = e.fastFormats = e.fullFormats = void 0;
      function t(I, D) {
        return { validate: I, compare: D };
      }
      e.fullFormats = {
        // date: http://tools.ietf.org/html/rfc3339#section-5.6
        date: t(i, a),
        // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
        time: t(l, u),
        "date-time": t(p, h),
        // duration: https://tools.ietf.org/html/rfc3339#appendix-A
        duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
        uri: b,
        "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
        // uri-template: https://tools.ietf.org/html/rfc6570
        "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
        // For the source: https://gist.github.com/dperini/729294
        // For test cases: https://mathiasbynens.be/demo/url-regex
        url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
        email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
        hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
        // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
        ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
        regex: M,
        // uuid: http://tools.ietf.org/html/rfc4122
        uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
        // JSON-pointer: https://tools.ietf.org/html/rfc6901
        // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
        "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
        "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
        // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
        "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
        // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
        // byte: https://github.com/miguelmota/is-base64
        byte: x,
        // signed 32 bit integer
        int32: { type: "number", validate: C },
        // signed 64 bit integer
        int64: { type: "number", validate: k },
        // C-type float
        float: { type: "number", validate: R },
        // C-type double
        double: { type: "number", validate: R },
        // hint to the UI to hide input strings
        password: !0,
        // unchecked string payload
        binary: !0
      }, e.fastFormats = {
        ...e.fullFormats,
        date: t(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, a),
        time: t(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, u),
        "date-time": t(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, h),
        // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
        uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
        "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
        // email (sources from jsen validator):
        // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
        // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
        email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
      }, e.formatNames = Object.keys(e.fullFormats);
      function n(I) {
        return I % 4 === 0 && (I % 100 !== 0 || I % 400 === 0);
      }
      const r = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, o = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function i(I) {
        const D = r.exec(I);
        if (!D)
          return !1;
        const L = +D[1], P = +D[2], B = +D[3];
        return P >= 1 && P <= 12 && B >= 1 && B <= (P === 2 && n(L) ? 29 : o[P]);
      }
      function a(I, D) {
        if (I && D)
          return I > D ? 1 : I < D ? -1 : 0;
      }
      const s = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
      function l(I, D) {
        const L = s.exec(I);
        if (!L)
          return !1;
        const P = +L[1], B = +L[2], j = +L[3], V = L[5];
        return (P <= 23 && B <= 59 && j <= 59 || P === 23 && B === 59 && j === 60) && (!D || V !== "");
      }
      function u(I, D) {
        if (!(I && D))
          return;
        const L = s.exec(I), P = s.exec(D);
        if (L && P)
          return I = L[1] + L[2] + L[3] + (L[4] || ""), D = P[1] + P[2] + P[3] + (P[4] || ""), I > D ? 1 : I < D ? -1 : 0;
      }
      const d = /t|\s/i;
      function p(I) {
        const D = I.split(d);
        return D.length === 2 && i(D[0]) && l(D[1], !0);
      }
      function h(I, D) {
        if (!(I && D))
          return;
        const [L, P] = I.split(d), [B, j] = D.split(d), V = a(L, B);
        if (V !== void 0)
          return V || u(P, j);
      }
      const g = /\/|:/, y = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
      function b(I) {
        return g.test(I) && y.test(I);
      }
      const v = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
      function x(I) {
        return v.lastIndex = 0, v.test(I);
      }
      const E = -2147483648, _ = 2 ** 31 - 1;
      function C(I) {
        return Number.isInteger(I) && I <= _ && I >= E;
      }
      function k(I) {
        return Number.isInteger(I);
      }
      function R() {
        return !0;
      }
      const A = /[^\\]\\Z/;
      function M(I) {
        if (A.test(I))
          return !1;
        try {
          return new RegExp(I), !0;
        } catch {
          return !1;
        }
      }
    }(q_)), q_;
  }
  var W_ = {}, b3;
  function p2e() {
    return b3 || (b3 = 1, function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.formatLimitDefinition = void 0;
      const t = y7(), n = yt(), r = n.operators, o = {
        formatMaximum: { okStr: "<=", ok: r.LTE, fail: r.GT },
        formatMinimum: { okStr: ">=", ok: r.GTE, fail: r.LT },
        formatExclusiveMaximum: { okStr: "<", ok: r.LT, fail: r.GTE },
        formatExclusiveMinimum: { okStr: ">", ok: r.GT, fail: r.LTE }
      }, i = {
        message: ({ keyword: s, schemaCode: l }) => n.str`should be ${o[s].okStr} ${l}`,
        params: ({ keyword: s, schemaCode: l }) => n._`{comparison: ${o[s].okStr}, limit: ${l}}`
      };
      e.formatLimitDefinition = {
        keyword: Object.keys(o),
        type: "string",
        schemaType: "string",
        $data: !0,
        error: i,
        code(s) {
          const { gen: l, data: u, schemaCode: d, keyword: p, it: h } = s, { opts: g, self: y } = h;
          if (!g.validateFormats)
            return;
          const b = new t.KeywordCxt(h, y.RULES.all.format.definition, "format");
          b.$data ? v() : x();
          function v() {
            const _ = l.scopeValue("formats", {
              ref: y.formats,
              code: g.code.formats
            }), C = l.const("fmt", n._`${_}[${b.schemaCode}]`);
            s.fail$data(n.or(n._`typeof ${C} != "object"`, n._`${C} instanceof RegExp`, n._`typeof ${C}.compare != "function"`, E(C)));
          }
          function x() {
            const _ = b.schema, C = y.formats[_];
            if (!C || C === !0)
              return;
            if (typeof C != "object" || C instanceof RegExp || typeof C.compare != "function")
              throw new Error(`"${p}": format "${_}" does not define "compare" function`);
            const k = l.scopeValue("formats", {
              key: _,
              ref: C,
              code: g.code.formats ? n._`${g.code.formats}${n.getProperty(_)}` : void 0
            });
            s.fail$data(E(k));
          }
          function E(_) {
            return n._`${_}.compare(${u}, ${d}) ${o[p].fail} 0`;
          }
        },
        dependencies: ["format"]
      };
      const a = (s) => (s.addKeyword(e.formatLimitDefinition), s);
      e.default = a;
    }(W_)), W_;
  }
  var x3;
  function h2e() {
    return x3 || (x3 = 1, function(e, t) {
      Object.defineProperty(t, "__esModule", { value: !0 });
      const n = d2e(), r = p2e(), o = yt(), i = new o.Name("fullFormats"), a = new o.Name("fastFormats"), s = (u, d = { keywords: !0 }) => {
        if (Array.isArray(d))
          return l(u, d, n.fullFormats, i), u;
        const [p, h] = d.mode === "fast" ? [n.fastFormats, a] : [n.fullFormats, i], g = d.formats || n.formatNames;
        return l(u, g, p, h), d.keywords && r.default(u), u;
      };
      s.get = (u, d = "full") => {
        const h = (d === "fast" ? n.fastFormats : n.fullFormats)[u];
        if (!h)
          throw new Error(`Unknown format "${u}"`);
        return h;
      };
      function l(u, d, p, h) {
        var g, y;
        (g = (y = u.opts.code).formats) !== null && g !== void 0 || (y.formats = o._`require("ajv-formats/dist/formats").${h}`);
        for (const b of d)
          u.addFormat(b, p[b]);
      }
      e.exports = t = s, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = s;
    }(Zy, Zy.exports)), Zy.exports;
  }
  var m2e = h2e();
  const w3 = /* @__PURE__ */ Jo(m2e), g2e = {
    allErrors: !0,
    multipleOfPrecision: 8,
    strict: !1,
    verbose: !0,
    discriminator: !1
    // TODO enable this in V6
  }, y2e = /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/, v2e = /^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;
  function b2e(e, t, n = {}, r, o = f2e, i) {
    let a = new o({ ...g2e, ...n });
    return r ? w3(a, r) : r !== !1 && w3(a), a.addFormat("data-url", v2e), a.addFormat("color", y2e), a.addKeyword($a), a.addKeyword(CR), Array.isArray(e) && a.addMetaSchema(e), Pt(t) && Object.keys(t).forEach((s) => {
      a.addFormat(s, t[s]);
    }), i && (a = i(a)), a;
  }
  function x2e(e = [], t) {
    return e.map((r) => {
      var o;
      const { instancePath: i, keyword: a, params: s, schemaPath: l, parentSchema: u, ...d } = r;
      let { message: p = "" } = d, h = i.replace(/\//g, "."), g = `${h} ${p}`.trim(), y = "";
      const b = [
        ...((o = s.deps) === null || o === void 0 ? void 0 : o.split(", ")) || [],
        s.missingProperty,
        s.property
      ].filter((v) => v);
      if (b.length > 0)
        b.forEach((v) => {
          const x = h ? `${h}.${v}` : v;
          let E = Ze(Ee(t, `${x.replace(/^\./, "")}`)).title;
          if (E === void 0) {
            const _ = l.replace(/\/properties\//g, "/").split("/").slice(1, -1).concat([v]);
            E = Ze(Ee(t, _)).title;
          }
          if (E)
            p = p.replace(`'${v}'`, `'${E}'`), y = E;
          else {
            const _ = Ee(u, [It, v, "title"]);
            _ && (p = p.replace(`'${v}'`, `'${_}'`), y = _);
          }
        }), g = p;
      else {
        const v = Ze(Ee(t, `${h.replace(/^\./, "")}`)).title;
        if (v)
          g = `'${v}' ${p}`.trim(), y = v;
        else {
          const x = u?.title;
          x && (g = `'${x}' ${p}`.trim(), y = x);
        }
      }
      return "missingProperty" in s && (h = h ? `${h}.${s.missingProperty}` : s.missingProperty), {
        name: a,
        property: h,
        message: p,
        params: s,
        // specific to ajv
        stack: g,
        schemaPath: l,
        title: y
      };
    }).reduce((r, o) => {
      const { message: i, schemaPath: a } = o, s = a?.indexOf(`/${At}/`), l = a?.indexOf(`/${gt}/`);
      let u;
      return s && s >= 0 ? u = a?.substring(0, s) : l && l >= 0 && (u = a?.substring(0, l)), (u ? r.find((p) => {
        var h;
        return p.message === i && ((h = p.schemaPath) === null || h === void 0 ? void 0 : h.startsWith(u));
      }) : void 0) || r.push(o), r;
    }, []);
  }
  function w2e(e, t, n, r, o, i, a) {
    const { validationError: s } = t;
    let l = x2e(t.errors, a);
    s && (l = [...l, { stack: s.message }]), typeof i == "function" && (l = i(l, a));
    let u = WPe(l);
    if (s && (u = {
      ...u,
      $schema: {
        __errors: [s.message]
      }
    }), typeof o != "function")
      return { errors: l, errorSchema: u };
    const d = XH(e, r, n, r, !0), p = o(d, AC(d), a), h = u7(p);
    return $v({ errors: l, errorSchema: u }, h);
  }
  class S2e {
    /** Constructs an `AJV8Validator` instance using the `options`
     *
     * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance
     * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s
     */
    constructor(t, n) {
      const { additionalMetaSchemas: r, customFormats: o, ajvOptionsOverrides: i, ajvFormatOptions: a, AjvClass: s, extenderFn: l } = t;
      this.ajv = b2e(r, o, i, a, s, l), this.localizer = n;
    }
    /** Resets the internal AJV validator to clear schemas from it. Can be helpful for resetting the validator for tests.
     */
    reset() {
      this.ajv.removeSchema();
    }
    /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use
     * by the playground. Returns the `errors` from the validation
     *
     * @param schema - The schema against which to validate the form data   * @param schema
     * @param formData - The form data to validate
     */
    rawValidation(t, n) {
      var r, o;
      let i, a;
      try {
        t[nn] && (a = this.ajv.getSchema(t[nn])), a === void 0 && (a = this.ajv.compile(t)), a(n);
      } catch (l) {
        i = l;
      }
      let s;
      return a && (typeof this.localizer == "function" && (((r = a.errors) !== null && r !== void 0 ? r : []).forEach((l) => {
        var u;
        ["missingProperty", "property"].forEach((d) => {
          var p;
          !((p = l.params) === null || p === void 0) && p[d] && (l.params[d] = `'${l.params[d]}'`);
        }), !((u = l.params) === null || u === void 0) && u.deps && (l.params.deps = l.params.deps.split(", ").map((d) => `'${d}'`).join(", "));
      }), this.localizer(a.errors), ((o = a.errors) !== null && o !== void 0 ? o : []).forEach((l) => {
        var u;
        ["missingProperty", "property"].forEach((d) => {
          var p;
          !((p = l.params) === null || p === void 0) && p[d] && (l.params[d] = l.params[d].slice(1, -1));
        }), !((u = l.params) === null || u === void 0) && u.deps && (l.params.deps = l.params.deps.split(", ").map((d) => d.slice(1, -1)).join(", "));
      })), s = a.errors || void 0, a.errors = null), {
        errors: s,
        validationError: i
      };
    }
    /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives
     * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also
     * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and
     * transform them in what ever way it chooses.
     *
     * @param formData - The form data to validate
     * @param schema - The schema against which to validate the form data
     * @param [customValidate] - An optional function that is used to perform custom validation
     * @param [transformErrors] - An optional function that is used to transform errors after AJV validation
     * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`
     */
    validateFormData(t, n, r, o, i) {
      const a = this.rawValidation(n, t);
      return w2e(this, a, t, n, r, o, i);
    }
    /**
     * This function checks if a schema needs to be added and if the root schemas don't match it removes the old root schema from the ajv instance and adds the new one.
     * @param rootSchema - The root schema used to provide $ref resolutions
     */
    handleSchemaUpdate(t) {
      var n, r;
      const o = (n = t[nn]) !== null && n !== void 0 ? n : UV;
      this.ajv.getSchema(o) === void 0 ? this.ajv.addSchema(t, o) : fn(t, (r = this.ajv.getSchema(o)) === null || r === void 0 ? void 0 : r.schema) || (this.ajv.removeSchema(o), this.ajv.addSchema(t, o));
    }
    /** Validates data against a schema, returning true if the data is valid, or
     * false otherwise. If the schema is invalid, then this function will return
     * false.
     *
     * @param schema - The schema against which to validate the form data
     * @param formData - The form data to validate
     * @param rootSchema - The root schema used to provide $ref resolutions
     */
    isValid(t, n, r) {
      var o;
      try {
        this.handleSchemaUpdate(r);
        const i = rO(t), a = (o = i[nn]) !== null && o !== void 0 ? o : BPe(i);
        let s;
        return s = this.ajv.getSchema(a), s === void 0 && (s = this.ajv.addSchema(i, a).getSchema(a) || this.ajv.compile(i)), s(n);
      } catch (i) {
        return console.warn("Error encountered compiling schema:", i), !1;
      }
    }
  }
  function _2e(e = {}, t) {
    return new S2e(e, t);
  }
  const E2e = _2e();
  function C2e(e, t) {
    return r7(e, t, function(n, r) {
      return hH(e, r);
    });
  }
  var v7 = $H(function(e, t) {
    return e == null ? {} : C2e(e, t);
  });
  function k2e(e, t) {
    return e == null ? !0 : PH(e, t);
  }
  function BC() {
    return s7("rjsf-array-item-");
  }
  function S3(e) {
    return Array.isArray(e) ? e.map((t) => ({
      key: BC(),
      item: t
    })) : [];
  }
  function b7(e) {
    return Array.isArray(e) ? e.map((t) => t.item) : [];
  }
  function T2e(e) {
    return Array.isArray(e.type) ? !e.type.includes("null") : e.type !== "null";
  }
  function x7(e, t, n, r) {
    let { addable: o } = Ze(r, e.globalUiOptions);
    return o !== !1 && (t.maxItems !== void 0 ? o = n.length < t.maxItems : o = !0), o;
  }
  function w7(e, t, n, r) {
    if (typeof e.items == "function")
      try {
        return e.items(t, n, r);
      } catch (o) {
        console.error(`Error executing dynamic uiSchema.items function for item at index ${n}:`, o);
        return;
      }
    else
      return e.items;
  }
  function R2e(e, t) {
    const { schemaUtils: n, globalFormOptions: r } = e;
    let o = t.items;
    return r.useFallbackUiForUnsupportedType && !o ? o = {} : GR(t) && tTe(t) && (o = t.additionalItems), n.getDefaultFormState(o);
  }
  function O2e(e) {
    const { schema: t, fieldPathId: n, uiSchema: r, formData: o = [], disabled: i = !1, readonly: a = !1, autofocus: s = !1, required: l = !1, placeholder: u, onBlur: d, onFocus: p, registry: h, rawErrors: g, name: y, onSelectChange: b } = e, { widgets: v, schemaUtils: x, globalFormOptions: E, globalUiOptions: _ } = h, C = x.retrieveSchema(t.items, o), k = bf(C, r), { widget: R = "select", title: A, ...M } = Ze(r, _), I = Gi(t, R, v), D = A ?? t.title ?? y, L = x.getDisplayLabel(t, r, _), P = Oc(Mo("", E, n, !0));
    return S.jsx(I, { id: P[nn], name: y, multiple: !0, onChange: b, onBlur: d, onFocus: p, options: { ...M, enumOptions: k }, schema: t, uiSchema: r, registry: h, value: o, disabled: i, readonly: a, required: l, label: D, hideLabel: !L, placeholder: u, autofocus: s, rawErrors: g, htmlName: P.name });
  }
  function A2e(e) {
    const { schema: t, fieldPathId: n, uiSchema: r, disabled: o = !1, readonly: i = !1, autofocus: a = !1, required: s = !1, hideError: l, placeholder: u, onBlur: d, onFocus: p, formData: h = [], registry: g, rawErrors: y, name: b, onSelectChange: v } = e, { widgets: x, schemaUtils: E, globalFormOptions: _, globalUiOptions: C } = g, { widget: k, title: R, ...A } = Ze(r, C), M = Gi(t, k, x), I = R ?? t.title ?? b, D = E.getDisplayLabel(t, r, C), L = Oc(Mo("", _, n, !0));
    return S.jsx(M, { id: L[nn], name: b, multiple: !0, onChange: v, onBlur: d, onFocus: p, options: A, schema: t, uiSchema: r, registry: g, value: h, disabled: o, readonly: i, hideError: l, required: s, label: I, hideLabel: !D, placeholder: u, autofocus: a, rawErrors: y, htmlName: L.name });
  }
  function N2e(e) {
    const { schema: t, uiSchema: n, fieldPathId: r, name: o, disabled: i = !1, readonly: a = !1, autofocus: s = !1, required: l = !1, onBlur: u, onFocus: d, registry: p, formData: h = [], rawErrors: g, onSelectChange: y } = e, { widgets: b, schemaUtils: v, globalFormOptions: x, globalUiOptions: E } = p, { widget: _ = "files", title: C, ...k } = Ze(n, E), R = Gi(t, _, b), A = C ?? t.title ?? o, M = v.getDisplayLabel(t, n, E), I = Oc(Mo("", x, r, !0));
    return S.jsx(R, { options: k, id: I[nn], name: o, multiple: !0, onChange: y, onBlur: u, onFocus: d, schema: t, uiSchema: n, value: h, disabled: i, readonly: a, required: l, registry: p, autofocus: s, rawErrors: g, label: A, hideLabel: !M, htmlName: I.name });
  }
  function S7(e) {
    const { itemKey: t, index: n, name: r, disabled: o, hideError: i, readonly: a, registry: s, uiOptions: l, parentUiSchema: u, canAdd: d, canRemove: p = !0, canMoveUp: h, canMoveDown: g, itemSchema: y, itemData: b, itemUiSchema: v, itemFieldPathId: x, itemErrorSchema: E, autofocus: _, onBlur: C, onFocus: k, onChange: R, rawErrors: A, totalItems: M, title: I, handleAddItem: D, handleCopyItem: L, handleRemoveItem: P, handleReorderItems: B } = e, { schemaUtils: j, fields: { ArraySchemaField: V, SchemaField: F }, globalUiOptions: G } = s, W = Oc(x), K = V || F, $ = et("ArrayFieldItemTemplate", s, l), U = j.getDisplayLabel(y, v, G), { description: X } = Ze(v), z = !!X || !!y.description, { orderable: H = !0, removable: Y = !0, copyable: Q = !1 } = l, re = {
      moveUp: H && h,
      moveDown: H && g,
      copy: Q && d,
      remove: Y && p,
      toolbar: !1
    };
    re.toolbar = Object.keys(re).some((ae) => re[ae]);
    const te = T.useCallback((ae) => {
      D(ae, n + 1);
    }, [D, n]), le = T.useCallback((ae) => {
      L(ae, n);
    }, [L, n]), fe = T.useCallback((ae) => {
      P(ae, n);
    }, [P, n]), J = T.useCallback((ae) => {
      B(ae, n, n - 1);
    }, [B, n]), ee = T.useCallback((ae) => {
      B(ae, n, n + 1);
    }, [B, n]), ie = {
      children: S.jsx(K, { name: r, title: I, index: n, schema: y, uiSchema: v, formData: b, errorSchema: E, fieldPathId: W, required: T2e(y), onChange: R, onBlur: C, onFocus: k, registry: s, disabled: o, readonly: a, hideError: i, autofocus: _, rawErrors: A }),
      buttonsProps: {
        fieldPathId: W,
        disabled: o,
        readonly: a,
        canAdd: d,
        hasCopy: re.copy,
        hasMoveUp: re.moveUp,
        hasMoveDown: re.moveDown,
        hasRemove: re.remove,
        index: n,
        totalItems: M,
        onAddItem: te,
        onCopyItem: le,
        onRemoveItem: fe,
        onMoveUpItem: J,
        onMoveDownItem: ee,
        registry: s,
        schema: y,
        uiSchema: v
      },
      itemKey: t,
      className: "rjsf-array-item",
      disabled: o,
      hasToolbar: re.toolbar,
      index: n,
      totalItems: M,
      readonly: a,
      registry: s,
      schema: y,
      uiSchema: v,
      parentUiSchema: u,
      displayLabel: U,
      hasDescription: z
    };
    return S.jsx($, { ...ie });
  }
  function M2e(e) {
    const { schema: t, uiSchema: n = {}, errorSchema: r, fieldPathId: o, formData: i, name: a, title: s, disabled: l = !1, readonly: u = !1, autofocus: d = !1, required: p = !1, hideError: h = !1, registry: g, onBlur: y, onFocus: b, rawErrors: v, onChange: x, keyedFormData: E, handleAddItem: _, handleCopyItem: C, handleRemoveItem: k, handleReorderItems: R } = e, A = t.title || s || a, { schemaUtils: M, fields: I, formContext: D, globalFormOptions: L, globalUiOptions: P } = g, { OptionalDataControlsField: B } = I, j = Ze(n, P), V = Pt(t.items) ? t.items : {}, F = M.retrieveSchema(V), G = b7(E), W = hm(g, t, p, n), K = Ff(i), $ = x7(g, t, G, n) && (!W || K), U = K ? E : [], X = W ? " rjsf-optional-array-field" : "", z = e.childFieldPathId ?? o, H = W ? S.jsx(B, { ...e, fieldPathId: z }) : void 0, Y = {
      canAdd: $,
      items: U.map((re, te) => {
        const { key: le, item: fe } = re, J = fe, ee = M.retrieveSchema(V, J), ie = r ? r[te] : void 0, ae = Mo(te, L, z), ge = w7(n, fe, te, D), Ce = {
          itemKey: le,
          index: te,
          name: a && `${a}-${te}`,
          registry: g,
          uiOptions: j,
          hideError: h,
          readonly: u,
          disabled: l,
          required: p,
          title: A ? `${A}-${te + 1}` : void 0,
          canAdd: $,
          canMoveUp: te > 0,
          canMoveDown: te < G.length - 1,
          itemSchema: ee,
          itemFieldPathId: ae,
          itemErrorSchema: ie,
          itemData: J,
          itemUiSchema: ge,
          autofocus: d && te === 0,
          onBlur: y,
          onFocus: b,
          rawErrors: v,
          totalItems: E.length,
          handleAddItem: _,
          handleCopyItem: C,
          handleRemoveItem: k,
          handleReorderItems: R,
          onChange: x
        };
        return S.jsx(S7, { ...Ce }, le);
      }),
      className: `rjsf-field rjsf-field-array rjsf-field-array-of-${F.type}${X}`,
      disabled: l,
      fieldPathId: o,
      uiSchema: n,
      onAddClick: _,
      readonly: u,
      required: p,
      schema: t,
      title: A,
      formData: G,
      rawErrors: v,
      registry: g,
      optionalDataControl: H
    }, Q = et("ArrayFieldTemplate", g, j);
    return S.jsx(Q, { ...Y });
  }
  function P2e(e) {
    const { schema: t, uiSchema: n = {}, formData: r, errorSchema: o, fieldPathId: i, name: a, title: s, disabled: l = !1, readonly: u = !1, autofocus: d = !1, required: p = !1, hideError: h = !1, registry: g, onBlur: y, onFocus: b, rawErrors: v, keyedFormData: x, onChange: E, handleAddItem: _, handleCopyItem: C, handleRemoveItem: k, handleReorderItems: R } = e;
    let { formData: A = [] } = e;
    const M = t.title || s || a, { schemaUtils: I, fields: D, formContext: L, globalFormOptions: P, globalUiOptions: B } = g, j = Ze(n, B), { OptionalDataControlsField: V } = D, F = hm(g, t, p, n), G = Ff(r), K = (Pt(t.items) ? t.items : []).map((te, le) => I.retrieveSchema(te, A[le])), $ = Pt(t.additionalItems) ? I.retrieveSchema(t.additionalItems, r) : null, U = e.childFieldPathId ?? i;
    A.length < K.length && (A = A.concat(new Array(K.length - A.length)));
    const X = G ? x : [], z = F ? " rjsf-optional-array-field" : "", H = F ? S.jsx(V, { ...e, fieldPathId: U }) : void 0, Y = x7(g, t, A, n) && !!$ && (!F || G), Q = {
      canAdd: Y,
      className: `rjsf-field rjsf-field-array rjsf-field-array-fixed-items${z}`,
      disabled: l,
      fieldPathId: i,
      formData: r,
      items: X.map((te, le) => {
        const { key: fe, item: J } = te, ee = J, ie = le >= K.length, ae = (ie && Pt(t.additionalItems) ? I.retrieveSchema(t.additionalItems, ee) : K[le]) || {}, ge = Mo(le, P, U);
        let Ce;
        ie ? Ce = n.additionalItems : Array.isArray(n.items) ? Ce = n.items[le] : Ce = w7(n, J, le, L);
        const Ne = o ? o[le] : void 0, Le = {
          index: le,
          itemKey: fe,
          name: a && `${a}-${le}`,
          registry: g,
          uiOptions: j,
          hideError: h,
          readonly: u,
          disabled: l,
          required: p,
          title: M ? `${M}-${le + 1}` : void 0,
          canAdd: Y,
          canRemove: ie,
          canMoveUp: le >= K.length + 1,
          canMoveDown: ie && le < A.length - 1,
          itemSchema: ae,
          itemData: ee,
          itemUiSchema: Ce,
          itemFieldPathId: ge,
          itemErrorSchema: Ne,
          autofocus: d && le === 0,
          onBlur: y,
          onFocus: b,
          rawErrors: v,
          totalItems: x.length,
          onChange: E,
          handleAddItem: _,
          handleCopyItem: C,
          handleRemoveItem: k,
          handleReorderItems: R
        };
        return S.jsx(S7, { ...Le }, fe);
      }),
      onAddClick: _,
      readonly: u,
      required: p,
      registry: g,
      schema: t,
      uiSchema: n,
      title: M,
      errorSchema: o,
      rawErrors: v,
      optionalDataControl: H
    }, re = et("ArrayFieldTemplate", g, j);
    return S.jsx(re, { ...Q });
  }
  function $2e(e = []) {
    const t = T.useMemo(() => Pi(e), [e]), [n, r] = T.useState(() => ({
      formDataHash: t,
      keyedFormData: S3(e)
    }));
    let { keyedFormData: o, formDataHash: i } = n;
    if (t !== i) {
      const s = Array.isArray(e) ? e : [], l = o || [];
      o = s.length === l.length ? l.map((u, d) => ({
        key: u.key,
        item: s[d]
      })) : S3(s), i = t, r({ formDataHash: i, keyedFormData: o });
    }
    const a = T.useCallback((s) => {
      const l = b7(s), u = Pi(l);
      return r({ formDataHash: u, keyedFormData: s }), l;
    }, []);
    return { keyedFormData: o, updateKeyedFormData: a };
  }
  function I2e(e) {
    const { schema: t, uiSchema: n, errorSchema: r, fieldPathId: o, registry: i, formData: a, onChange: s } = e, { globalFormOptions: l, schemaUtils: u, translateString: d } = i, { keyedFormData: p, updateKeyedFormData: h } = $2e(a), g = e.childFieldPathId ?? o, y = T.useCallback((R, A) => {
      R && R.preventDefault();
      let M;
      if (r) {
        M = {};
        for (const L in r) {
          const P = parseInt(L);
          A === void 0 || P < A ? Xt(M, [P], r[L]) : P >= A && Xt(M, [P + 1], r[L]);
        }
      }
      const I = {
        key: BC(),
        item: R2e(i, t)
      }, D = [...p];
      A !== void 0 ? D.splice(A, 0, I) : D.push(I), s(h(D), g.path, M);
    }, [p, i, t, s, h, r, g]), b = T.useCallback((R, A) => {
      R && R.preventDefault();
      let M;
      if (r) {
        M = {};
        for (const L in r) {
          const P = parseInt(L);
          P <= A ? Xt(M, [P], r[L]) : P > A && Xt(M, [P + 1], r[L]);
        }
      }
      const I = {
        key: BC(),
        item: ZR(p[A].item)
      }, D = [...p];
      A !== void 0 ? D.splice(A + 1, 0, I) : D.push(I), s(h(D), g.path, M);
    }, [p, s, h, r, g]), v = T.useCallback((R, A) => {
      R && R.preventDefault();
      let M;
      if (r) {
        M = {};
        for (const D in r) {
          const L = parseInt(D);
          L < A ? Xt(M, [L], r[D]) : L > A && Xt(M, [L - 1], r[D]);
        }
      }
      const I = p.filter((D, L) => L !== A);
      s(h(I), g.path, M);
    }, [p, s, h, r, g]), x = T.useCallback((R, A, M) => {
      R && (R.preventDefault(), R.currentTarget.blur());
      let I;
      if (r) {
        I = {};
        for (const P in r) {
          const B = parseInt(P);
          B == A ? Xt(I, [M], r[A]) : B == M ? Xt(I, [A], r[M]) : Xt(I, [P], r[B]);
        }
      }
      function D() {
        const P = p.slice();
        return P.splice(A, 1), P.splice(M, 0, p[A]), P;
      }
      const L = D();
      s(h(L), g.path, I);
    }, [p, s, h, r, g]), E = T.useCallback((R, A, M, I) => {
      s(
        // We need to treat undefined items as nulls to have validation.
        // See https://github.com/tdegrunt/jsonschema/issues/206
        R === void 0 ? null : R,
        A,
        M,
        I
      );
    }, [s]), _ = T.useCallback((R) => {
      s(R, g.path, void 0, g?.[nn]);
    }, [s, g]), C = {
      ...e,
      formData: a,
      fieldPathId: g,
      onSelectChange: _
    }, k = {
      ...e,
      handleAddItem: y,
      handleCopyItem: b,
      handleRemoveItem: v,
      handleReorderItems: x,
      keyedFormData: p,
      onChange: E
    };
    if (!(gf in t)) {
      if (!l.useFallbackUiForUnsupportedType) {
        const A = Ze(n), M = et("UnsupportedFieldTemplate", i, A);
        return S.jsx(M, { schema: t, fieldPathId: o, reason: d(bt.MissingItems), registry: i });
      }
      const R = { ...t, [gf]: { type: void 0 } };
      C.schema = R, k.schema = R;
    }
    return u.isMultiSelect(C.schema) ? S.jsx(O2e, { ...C }) : ZH(n) ? S.jsx(A2e, { ...C }) : GR(C.schema) ? S.jsx(P2e, { ...k }) : u.isFilesArray(C.schema, n) ? S.jsx(N2e, { ...C }) : S.jsx(M2e, { ...k });
  }
  function j2e(e) {
    const { schema: t, name: n, uiSchema: r, fieldPathId: o, formData: i, registry: a, required: s, disabled: l, readonly: u, hideError: d, autofocus: p, title: h, onChange: g, onFocus: y, onBlur: b, rawErrors: v } = e, { title: x } = t, { widgets: E, translateString: _, globalUiOptions: C } = a, {
      widget: k = "checkbox",
      title: R,
      // Unlike the other fields, don't use `getDisplayLabel()` since it always returns false for the boolean type
      label: A = !0,
      enumNames: M,
      ...I
    } = Ze(r, C), D = Gi(t, k, E), L = _(bt.YesLabel), P = _(bt.NoLabel);
    let B;
    const j = R ?? x ?? h ?? n;
    if (Array.isArray(t.oneOf))
      B = bf({
        oneOf: t.oneOf.map((F) => {
          if (Pt(F))
            return {
              ...F,
              title: F.title || (F.const === !0 ? L : P)
            };
        }).filter((F) => F)
        // cast away the error that typescript can't grok is fixed
      }, r);
    else {
      const F = t.enum ?? [!0, !1];
      !M && F.length === 2 && F.every((G) => typeof G == "boolean") ? B = [
        {
          value: F[0],
          label: F[0] ? L : P
        },
        {
          value: F[1],
          label: F[1] ? L : P
        }
      ] : B = bf({ enum: F }, r);
    }
    const V = T.useCallback((F, G, W) => g(F, o.path, G, W), [g, o]);
    return S.jsx(D, { options: { ...I, enumOptions: B }, schema: t, uiSchema: r, id: o.$id, name: n, onChange: V, onFocus: y, onBlur: b, label: j, hideLabel: !A, value: i, required: s, disabled: l, readonly: u, hideError: d, registry: a, autofocus: p, rawErrors: v, htmlName: o.name });
  }
  function D2e(e) {
    return {
      type: "string",
      enum: ["string", "number", "boolean", "object", "array"],
      default: "string",
      title: e
    };
  }
  function F2e(e) {
    const t = typeof e;
    return t === "string" || t === "number" || t === "boolean" ? t : t === "object" ? Array.isArray(e) ? "array" : "object" : "string";
  }
  function L2e(e, t) {
    switch (t) {
      case "string":
        return String(e);
      case "number": {
        const n = Number(e);
        return isNaN(n) ? 0 : n;
      }
      case "boolean":
        return !!e;
      default:
        return e;
    }
  }
  function z2e(e) {
    const { id: t, formData: n, displayLabel: r = !0, schema: o, name: i, uiSchema: a, required: s, disabled: l = !1, readonly: u = !1, onBlur: d, onFocus: p, registry: h, fieldPathId: g, onChange: y, errorSchema: b } = e, { translateString: v, fields: x, globalFormOptions: E } = h, [_, C] = T.useState(F2e(n)), k = Ze(a), R = Oc(Mo("__internal_type_selector", E, g)), A = v(bt.Type), M = T.useMemo(() => D2e(A), [A]), I = (P) => {
      P != null && (C(P), y(L2e(n, P), g.path, b, t));
    };
    if (!E.useFallbackUiForUnsupportedType) {
      const { reason: P = v(bt.UnknownFieldType, [String(o.type)]) } = e, B = et("UnsupportedFieldTemplate", h, k);
      return S.jsx(B, { schema: o, fieldPathId: g, reason: P, registry: h });
    }
    const D = et("FallbackFieldTemplate", h, k), { SchemaField: L } = x;
    return S.jsx(D, { schema: o, registry: h, typeSelector: S.jsx(L, { fieldPathId: R, name: `${i}__fallback_type`, schema: M, formData: _, onChange: I, onBlur: d, onFocus: p, registry: h, hideLabel: !r, disabled: l, readonly: u, required: s }, n ? Pi(n) : "__empty__"), schemaField: S.jsx(L, { ...e, schema: {
      type: _,
      title: v(bt.Value),
      ..._ === "object" && { additionalProperties: !0 }
    } }) });
  }
  function B2e(e, t) {
    return If(t, function(n) {
      return e[n];
    });
  }
  function U2e(e) {
    return e == null ? [] : B2e(e, Vo(e));
  }
  var V2e = Math.max;
  function H2e(e, t, n, r) {
    e = Ec(e) ? e : U2e(e), n = n ? sH(n) : 0;
    var o = e.length;
    return n < 0 && (n = V2e(o + n, 0)), al(e) ? n <= o && e.indexOf(t, n) > -1 : !!o && SH(e, t, n) > -1;
  }
  var q2e = Math.min;
  function W2e(e, t, n) {
    for (var r = UR, o = e[0].length, i = e.length, a = i, s = Array(i), l = 1 / 0, u = []; a--; ) {
      var d = e[a];
      l = q2e(d.length, l), s[a] = o >= 120 && d.length >= 120 ? new pc(a && d) : void 0;
    }
    d = e[0];
    var p = -1, h = s[0];
    e:
      for (; ++p < o && u.length < l; ) {
        var g = d[p], y = g;
        if (g = g !== 0 ? g : 0, !(h ? gh(h, y) : r(u, y))) {
          for (a = i; --a; ) {
            var b = s[a];
            if (!(b ? gh(b, y) : r(e[a], y)))
              continue e;
          }
          h && h.push(y), u.push(g);
        }
      }
    return u;
  }
  function G2e(e) {
    return vh(e) ? e : [];
  }
  var _3 = g1(function(e) {
    var t = If(e, G2e);
    return t.length && t[0] === e[0] ? W2e(t) : [];
  });
  function _7(e) {
    return e === void 0;
  }
  var Ii;
  (function(e) {
    e.ROW = "ui:row", e.COLUMN = "ui:col", e.COLUMNS = "ui:columns", e.CONDITION = "ui:condition";
  })(Ii || (Ii = {}));
  var Fp;
  (function(e) {
    e.ALL = "all", e.SOME = "some", e.NONE = "none";
  })(Fp || (Fp = {}));
  const K2e = /^\$lookup=(.+)/, G_ = "layoutGrid";
  function E3(e, t) {
    return e ?? t;
  }
  function Y2e(e) {
    return /^\d+?$/.test(e);
  }
  const Ys = QR();
  function X2e(e, t, n, r, o) {
    const i = Ee(n, [OC], {}), a = Ee(n, e), s = { ...Ee(a, [Gs], {}), ...t, ...i }, l = { ...a };
    Un(s) || Xt(l, [Gs], s), Un(i) || Xt(l, [OC], i);
    let { readonly: u } = Ze(l);
    return (o === !0 || _7(u) && r === !0) && (u = !0, kt(s, h_) ? Xt(l, [Gs, h_], !0) : Xt(l, `ui:${h_}`, !0)), { fieldUiSchema: l, uiReadonly: u };
  }
  function Z2e(e, t, n = "$0m3tH1nG Un3xP3cT3d") {
    const r = DC([t]).sort(), o = DC([n]).sort();
    switch (e) {
      case Fp.ALL:
        return yh(r, o);
      case Fp.SOME:
        return _3(r, o).length > 0;
      case Fp.NONE:
        return _3(r, o).length === 0;
      default:
        return !1;
    }
  }
  function C1(e, t, n) {
    let r = {}, o = e[t];
    if (il(o)) {
      const { children: i, className: a, ...s } = o;
      if (o = i, a) {
        const u = a.split(" ").map((d) => tO(n, d, d)).join(" ");
        r = { ...s, className: u };
      } else
        r = s;
    }
    if (!Array.isArray(o))
      throw new TypeError(`Expected array for "${t}" in ${JSON.stringify(e)}`);
    return { children: o, gridProps: r };
  }
  function C3(e, t, n) {
    let r;
    if (Y2e(n) && e && e?.type === "array" && kt(e, gf)) {
      const o = Number(n), i = e[gf];
      Array.isArray(i) ? o > i.length ? r = MH(i) : r = i[o] : r = i, t = {
        [nn]: t[nn],
        path: [...t.path.slice(0, t.path.length - 1), o]
      };
    }
    return { rawSchema: r, fieldPathId: t };
  }
  function Q2e(e, t, n, r, o) {
    const { schemaUtils: i, globalFormOptions: a } = e;
    let s = n, l = o;
    const u = t.split("."), d = u.pop();
    let p = i.retrieveSchema(s, r), h = r, g = p.readOnly;
    u.forEach((v) => {
      if (l = Mo(v, a, l), kt(p, It))
        s = Ee(p, [It, v], {});
      else if (p && (kt(p, gt) || kt(p, At))) {
        const x = kt(p, gt) ? gt : At, E = i.findSelectedOptionInXxxOf(p, v, x, h);
        s = Ee(E, [It, v], {});
      } else {
        const x = C3(p, l, v);
        s = x.rawSchema ?? {}, l = x.fieldPathId;
      }
      h = Ee(h, v, {}), p = i.retrieveSchema(s, h), g = E3(p.readOnly, g);
    });
    let y, b = !1;
    if (Un(p) && (p = void 0), p && d) {
      if (p && (kt(p, gt) || kt(p, At))) {
        const x = kt(p, gt) ? gt : At;
        p = i.findSelectedOptionInXxxOf(p, d, x, h);
      }
      l = Mo(d, a, l), b = p !== void 0 && Array.isArray(p.required) && H2e(p.required, d);
      const v = C3(p, l, d);
      if (v.rawSchema ? (p = v.rawSchema, l = v.fieldPathId) : (p = Ee(p, [It, d]), p = p && i.retrieveSchema(p)), g = E3(p?.readOnly, g), p && (kt(p, gt) || kt(p, At))) {
        const x = kt(p, gt) ? gt : At, E = Wi(p);
        y = { options: p[x], hasDiscriminator: !!E };
      }
    }
    return { schema: p, isRequired: b, isReadonly: g, optionsInfo: y, fieldPathId: l };
  }
  function J2e(e, t) {
    let n = e;
    return al(n) && (n = tO(t, n)), lm(n) ? n : null;
  }
  function eIe(e, t) {
    let n, r = null, o = {}, i;
    if (al(t) || _7(t))
      n = t ?? "";
    else {
      const { name: a = "", render: s, ...l } = t;
      n = a, o = l, Un(o) || r$e(o, (u, d) => {
        if (al(u)) {
          const p = K2e.exec(u);
          if (Array.isArray(p) && p.length > 1) {
            const h = p[1];
            o[d] = tO(e, h, h);
          }
        }
      }), r = J2e(s, e), !a && r && (i = S.jsx(r, { ...l, "data-testid": Ys.uiComponent }));
    }
    return { name: n, UIComponent: r, uiProps: o, rendered: i };
  }
  function k1(e) {
    const { childrenLayoutGridSchemaId: t, ...n } = e, { registry: r, schema: o, formData: i } = n, { schemaUtils: a } = r, s = a.retrieveSchema(o, i);
    return t.map((l) => T.createElement(sO, { ...n, key: `layoutGrid-${Pi(l)}`, schema: s, layoutGridSchema: l }));
  }
  function tIe(e) {
    const { layoutGridSchema: t, ...n } = e, { formData: r, registry: o } = n, { children: i, gridProps: a } = C1(t, Ii.CONDITION, o), { operator: s, field: l = "", value: u } = a, d = Ee(r, l, null);
    return Z2e(s, d, u) ? S.jsx(k1, { ...n, childrenLayoutGridSchemaId: i }) : null;
  }
  function nIe(e) {
    const { layoutGridSchema: t, ...n } = e, { registry: r, uiSchema: o } = n, { children: i, gridProps: a } = C1(t, Ii.COLUMN, r), s = Ze(o), l = et("GridTemplate", r, s);
    return S.jsx(l, { column: !0, "data-testid": Ys.col, ...a, children: S.jsx(k1, { ...n, childrenLayoutGridSchemaId: i }) });
  }
  function rIe(e) {
    const { layoutGridSchema: t, ...n } = e, { registry: r, uiSchema: o } = n, { children: i, gridProps: a } = C1(t, Ii.COLUMNS, r), s = Ze(o), l = et("GridTemplate", r, s);
    return i.map((u) => S.jsx(l, { column: !0, "data-testid": Ys.col, ...a, children: S.jsx(k1, { ...n, childrenLayoutGridSchemaId: [u] }) }, `column-${Pi(u)}`));
  }
  function oIe(e) {
    const { layoutGridSchema: t, ...n } = e, { registry: r, uiSchema: o } = n, { children: i, gridProps: a } = C1(t, Ii.ROW, r), s = Ze(o), l = et("GridTemplate", r, s);
    return S.jsx(l, { ...a, "data-testid": Ys.row, children: S.jsx(k1, { ...n, childrenLayoutGridSchemaId: i }) });
  }
  function iIe(e) {
    const {
      gridSchema: t,
      schema: n,
      uiSchema: r,
      errorSchema: o,
      fieldPathId: i,
      onBlur: a,
      onFocus: s,
      formData: l,
      readonly: u,
      registry: d,
      layoutGridSchema: p,
      // Used to pull this out of otherProps since we don't want to pass it through
      ...h
    } = e, { onChange: g } = h, { fields: y } = d, { SchemaField: b, LayoutMultiSchemaField: v } = y, x = eIe(d, t), { name: E, UIComponent: _, uiProps: C } = x, { schema: k, isRequired: R, isReadonly: A, optionsInfo: M, fieldPathId: I } = Q2e(d, E, n, l, i), D = Oc(I);
    if (x.rendered)
      return x.rendered;
    if (k) {
      const L = M?.hasDiscriminator ? v : b, { fieldUiSchema: P, uiReadonly: B } = X2e(E, C, r, A, u);
      return S.jsx(L, { "data-testid": M?.hasDiscriminator ? Ys.layoutMultiSchemaField : Ys.field, ...h, name: E, required: R, readonly: B, schema: k, uiSchema: P, errorSchema: Ee(o, E), fieldPathId: D, formData: Ee(l, E), onChange: g, onBlur: a, onFocus: s, options: M?.options, registry: d });
    }
    return _ ? S.jsx(_, { "data-testid": Ys.uiComponent, ...h, name: E, required: R, formData: l, readOnly: !!A || u, errorSchema: o, uiSchema: r, schema: n, fieldPathId: i, onBlur: a, onFocus: s, registry: d, ...C }) : null;
  }
  function sO(e) {
    const { uiSchema: t } = e;
    let { layoutGridSchema: n } = e;
    const r = Ze(t);
    if (!n && G_ in r && Pt(r[G_]) && (n = r[G_]), Pt(n)) {
      if (Ii.ROW in n)
        return S.jsx(oIe, { ...e, layoutGridSchema: n });
      if (Ii.COLUMN in n)
        return S.jsx(nIe, { ...e, layoutGridSchema: n });
      if (Ii.COLUMNS in n)
        return S.jsx(rIe, { ...e, layoutGridSchema: n });
      if (Ii.CONDITION in n)
        return S.jsx(tIe, { ...e, layoutGridSchema: n });
    }
    return S.jsx(iIe, { ...e, gridSchema: n });
  }
  sO.TEST_IDS = Ys;
  function aIe(e) {
    const { fieldPathId: t, title: n, schema: r, uiSchema: o, required: i, registry: a, name: s } = e, l = Ze(o, a.globalUiOptions), { title: u } = l, { title: d } = r, p = u || n || d || s;
    if (!p)
      return null;
    const h = et("TitleFieldTemplate", a, l);
    return S.jsx(h, { id: b1(t), title: p, required: i, schema: r, uiSchema: o, registry: a });
  }
  function K_(e, t, n) {
    const r = "!@#!@$@#$!@$#";
    return e.map(({ schema: i }) => i).find((i) => {
      const a = Ee(i, [It, t]);
      return Ee(a, l1, Ee(a, Oo, r)) === n;
    });
  }
  function k3(e, t, n, r, o) {
    const i = t.map((l) => n.retrieveSchema(l, o));
    let a = e;
    kt(e, gt) ? a = { ...e, [gt]: i } : kt(e, At) && (a = { ...e, [At]: i });
    const s = bf(a, r);
    if (!s)
      throw new Error(`No enumOptions were computed from the schema ${JSON.stringify(a)}`);
    return s;
  }
  function sIe(e) {
    const { name: t, baseType: n, disabled: r = !1, formData: o, fieldPathId: i, onBlur: a, onChange: s, options: l, onFocus: u, registry: d, uiSchema: p, schema: h, autofocus: g, readonly: y, required: b, errorSchema: v, hideError: x = !1 } = e, { widgets: E, schemaUtils: _, globalUiOptions: C } = d, [k, R] = T.useState(k3(h, l, _, p, o)), A = Ee(i, nn), M = Wi(h), I = et("FieldErrorTemplate", d, l), D = et("FieldTemplate", d, l), L = Pi(h), P = Pi(l), B = p ? Pi(p) : "", j = o ? Pi(o) : "";
    T.useEffect(() => {
      R(k3(h, l, _, p, o));
    }, [L, P, _, B, j]);
    const { widget: V = M ? "radio" : "select", title: F = "", placeholder: G = "", optionsSchemaSelector: W = M, hideError: K, ...$ } = Ze(p);
    if (!W)
      throw new Error("No selector field provided for the LayoutMultiSchemaField");
    const U = Ee(o, W);
    let X = Ee(k[0]?.schema, [It, W], {});
    const z = K_(k, W, U);
    X = X?.type ? X : { ...X, type: z?.type || n };
    const H = Gi(X, V, E), Y = K === void 0 ? x : !!K, Q = Ee(v, [lr], []), re = bh(v, [lr]), te = _.getDisplayLabel(h, p, C), le = (ee) => {
      const ie = K_(k, W, ee), ae = K_(k, W, U);
      let ge = _.sanitizeDataForNewSchema(ie, ae, o);
      ge && ie && (ge = _.getDefaultFormState(ie, ge, "excludeObjectChildren")), ge && Xt(ge, W, ee), s(ge, i.path, void 0, A);
    }, fe = { enumOptions: k, ...$ }, J = !Y && Q.length > 0 ? S.jsx(I, { fieldPathId: i, schema: h, errors: Q, registry: d }) : void 0;
    return S.jsx(D, { id: A, schema: h, label: (F || h.title) ?? "", disabled: r || Array.isArray(k) && Un(k), uiSchema: p, required: b, readonly: !!y, registry: d, displayLabel: te, errors: J, onChange: s, onKeyRename: Nv, onKeyRenameBlur: Nv, onRemoveProperty: Nv, children: S.jsx(H, { id: A, name: t, schema: h, label: (F || h.title) ?? "", disabled: r || Array.isArray(k) && Un(k), uiSchema: p, autofocus: g, readonly: y, required: b, registry: d, multiple: !1, rawErrors: Q, hideError: Y, hideLabel: !te, errorSchema: re, placeholder: G, onChange: le, onBlur: a, onFocus: u, value: U, options: fe, htmlName: i.name }) });
  }
  class T3 extends T.Component {
    /** Constructs an `AnyOfField` with the given `props` to initialize the initially selected option in state
     *
     * @param props - The `FieldProps` for this template
     */
    constructor(n) {
      super(n);
      /** Callback handler to remember what the currently selected option is. In addition to that the `formData` is updated
       * to remove properties that are not part of the newly selected option schema, and then the updated data is passed to
       * the `onChange` handler.
       *
       * @param option - The new option value being selected
       */
      Wn(this, "onOptionChange", (n) => {
        const { selectedOption: r, retrievedOptions: o } = this.state, { formData: i, onChange: a, registry: s, fieldPathId: l } = this.props, { schemaUtils: u } = s, d = n !== void 0 ? parseInt(n, 10) : -1;
        if (d === r)
          return;
        const p = d >= 0 ? o[d] : void 0, h = r >= 0 ? o[r] : void 0;
        let g = u.sanitizeDataForNewSchema(p, h, i);
        p && (g = u.getDefaultFormState(p, g, "excludeObjectChildren")), this.setState({ selectedOption: d }, () => {
          a(g, l.path, void 0, this.getFieldId());
        });
      });
      const { formData: r, options: o, registry: { schemaUtils: i } } = this.props, a = o.map((s) => i.retrieveSchema(s, r));
      this.state = {
        retrievedOptions: a,
        selectedOption: this.getMatchingOption(0, r, a)
      };
    }
    /** React lifecycle method that is called when the props and/or state for this component is updated. It recomputes the
     * currently selected option based on the overall `formData`
     *
     * @param prevProps - The previous `FieldProps` for this template
     * @param prevState - The previous `AnyOfFieldState` for this template
     */
    componentDidUpdate(n, r) {
      const { formData: o, options: i, fieldPathId: a } = this.props, { selectedOption: s } = this.state;
      let l = this.state;
      if (!fn(n.options, i)) {
        const { registry: { schemaUtils: u } } = this.props, d = i.map((p) => u.retrieveSchema(p, o));
        l = { selectedOption: s, retrievedOptions: d };
      }
      if (!fn(o, n.formData) && a.$id === n.fieldPathId.$id) {
        const { retrievedOptions: u } = l, d = this.getMatchingOption(s, o, u);
        r && d !== s && (l = { selectedOption: d, retrievedOptions: u });
      }
      l !== this.state && this.setState(l);
    }
    /** Determines the best matching option for the given `formData` and `options`.
     *
     * @param formData - The new formData
     * @param options - The list of options to choose from
     * @return - The index of the `option` that best matches the `formData`
     */
    getMatchingOption(n, r, o) {
      const { schema: i, registry: { schemaUtils: a } } = this.props, s = Wi(i);
      return a.getClosestMatchingOption(r, o, n, s);
    }
    getFieldId() {
      const { fieldPathId: n, schema: r } = this.props;
      return `${n.$id}${r.oneOf ? "__oneof_select" : "__anyof_select"}`;
    }
    /** Renders the `AnyOfField` selector along with a `SchemaField` for the value of the `formData`
     */
    render() {
      const { name: n, disabled: r = !1, errorSchema: o = {}, formData: i, onBlur: a, onFocus: s, readonly: l, required: u = !1, registry: d, schema: p, uiSchema: h } = this.props, { widgets: g, fields: y, translateString: b, globalUiOptions: v, schemaUtils: x } = d, { SchemaField: E } = y, _ = et("MultiSchemaFieldTemplate", d, v), C = hm(d, p, u, h), k = Ff(i), { selectedOption: R, retrievedOptions: A } = this.state, { widget: M = "select", placeholder: I, autofocus: D, autocomplete: L, title: P = p.title, ...B } = Ze(h, v), j = Gi({ type: "number" }, M, g), V = Ee(o, lr, []), F = bh(o, [lr]), G = x.getDisplayLabel(p, h, v), W = R >= 0 && A[R] || null;
      let K;
      if (W) {
        const { required: re } = p;
        K = re ? Ha({ required: re }, W) : W;
      }
      let $ = [];
      gt in p && h && gt in h ? Array.isArray(h[gt]) ? $ = h[gt] : console.warn(`uiSchema.oneOf is not an array for "${P || n}"`) : At in p && h && At in h && (Array.isArray(h[At]) ? $ = h[At] : console.warn(`uiSchema.anyOf is not an array for "${P || n}"`));
      let U = h;
      R >= 0 && $.length > R && (U = $[R]);
      const X = P ? bt.TitleOptionPrefix : bt.OptionPrefix, z = P ? [P] : [], H = A.map((re, te) => {
        const { title: le = re.title } = Ze($[te]);
        return {
          label: le || b(X, z.concat(String(te + 1))),
          value: te
        };
      }), Y = !C || k ? S.jsx(j, { id: this.getFieldId(), name: `${n}${p.oneOf ? "__oneof_select" : "__anyof_select"}`, schema: { type: "number", default: 0 }, onChange: this.onOptionChange, onBlur: a, onFocus: s, disabled: r || Un(H), multiple: !1, rawErrors: V, errorSchema: F, value: R >= 0 ? R : void 0, options: { enumOptions: H, ...B }, registry: d, placeholder: I, autocomplete: L, autofocus: D, label: P ?? n, hideLabel: !G, readonly: l }) : void 0, Q = K && K.type !== "null" && S.jsx(E, { ...this.props, schema: K, uiSchema: U }) || null;
      return S.jsx(_, { schema: p, registry: d, uiSchema: h, selector: Y, optionSchemaField: Q });
    }
  }
  const lIe = /\.([0-9]*0)*$/, cIe = /[0.]0*$/;
  function uIe(e) {
    const { registry: t, onChange: n, formData: r, value: o } = e, [i, a] = T.useState(o), { StringField: s } = t.fields;
    let l = r;
    const u = T.useCallback((d, p, h, g) => {
      a(d), `${d}`.charAt(0) === "." && (d = `0${d}`);
      const y = typeof d == "string" && d.match(lIe) ? tD(d.replace(cIe, "")) : tD(d);
      n(y, p, h, g);
    }, [n]);
    if (typeof i == "string" && typeof l == "number") {
      const d = new RegExp(`^(${String(l).replace(".", "\\.")})?\\.?0*$`);
      i.match(d) && (l = i);
    }
    return S.jsx(s, { ...e, formData: l, onChange: u });
  }
  function Ci() {
    return Ci = Object.assign ? Object.assign.bind() : function(e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];
        for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
      }
      return e;
    }, Ci.apply(null, arguments);
  }
  const Qy = ["strong", "em", "del", "mark"], R3 = [["**", Qy[0]], ["__", Qy[0]], ["~~", Qy[2]], ["==", Qy[3]], ["*", "em"], ["_", "em"]];
  function fIe(e, t) {
    for (var n = 1, r = t + 1; r < e.length && n > 0; ) e[r] !== "\\" ? (e[r] === "[" && n++, e[r] === "]" && n--, r++) : r += 2;
    if (n === 0 && r < e.length && (e[r] === "(" || e[r] === "[")) {
      var o = e[r] === "(" ? ")" : "]", i = 1;
      for (r++; r < e.length && i > 0; ) e[r] !== "\\" ? (e[r] === "(" && o === ")" && i++, e[r] === o && i--, r++) : r += 2;
      if (i === 0) return r;
    }
    return -1;
  }
  function dIe(e, t) {
    if (!t || !t.inline && !t.simple) return null;
    var n = e[0];
    if (n !== "*" && n !== "_" && n !== "~" && n !== "=") return null;
    for (var r = "", o = 0, i = "", a = 0; a < 6; a++) {
      var s = R3[a][0];
      if (e.startsWith(s) && e.length >= 2 * s.length) {
        r = s, o = s.length, i = R3[a][1];
        break;
      }
    }
    if (!r) return null;
    for (var l = o, u = !1, d = !1, p = "", h = 0, g = "", y = !1, b = ""; l < e.length; ) {
      var v = e[l];
      if (y) g += v, y = !1, b = v, l++;
      else if (v !== "\\") if (v !== "`" || h !== 0) {
        if (v === "[" && !u && h === 0) {
          var x = fIe(e, l);
          if (x !== -1) {
            g += e.slice(l, x), l = x, b = e[x - 1];
            continue;
          }
        }
        if (d) g += v, p ? v === p && (p = "") : v === '"' || v === "'" ? p = v : v === ">" && (d = !1), b = v, l++;
        else if (v !== "<" || u) {
          if (v === `
` && b === `
` && !u && h === 0) return null;
          if (!u && h === 0) {
            for (var E = 0; l + E < e.length && e[l + E] === r[0]; ) E++;
            if (E >= o && (o !== 1 || r !== "*" && r !== "_" || e[l - 1] !== r && e[l + 1] !== r)) {
              var _ = [e.slice(0, l + E), i, g + e.slice(l + o, l + E)];
              return _.index = 0, _.input = e, _;
            }
          }
          g += v, b = v, l++;
        } else {
          var C = e[l + 1], k = e.indexOf(">", l);
          if (k !== -1) {
            var R = e.slice(l, k + 1).endsWith("/>");
            C === "/" ? h = Math.max(0, h - 1) : R || h++;
          }
          d = !0, g += v, b = v, l++;
        }
      } else u = !u, g += v, b = v, l++;
      else g += v, y = !0, b = v, l++;
    }
    return null;
  }
  const pIe = ["children", "options"], O3 = ["allowFullScreen", "allowTransparency", "autoComplete", "autoFocus", "autoPlay", "cellPadding", "cellSpacing", "charSet", "classId", "colSpan", "contentEditable", "contextMenu", "crossOrigin", "encType", "formAction", "formEncType", "formMethod", "formNoValidate", "formTarget", "frameBorder", "hrefLang", "inputMode", "keyParams", "keyType", "marginHeight", "marginWidth", "maxLength", "mediaGroup", "minLength", "noValidate", "radioGroup", "readOnly", "rowSpan", "spellCheck", "srcDoc", "srcLang", "srcSet", "tabIndex", "useMap"].reduce((e, t) => (e[t.toLowerCase()] = t, e), { class: "className", for: "htmlFor" }), A3 = { amp: "&", apos: "'", gt: ">", lt: "<", nbsp: "", quot: "" }, hIe = ["style", "script", "pre"], mIe = ["src", "href", "data", "formAction", "srcDoc", "action"], gIe = /([-A-Z0-9_:]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|(?:\{((?:\\.|{[^}]*?}|[^}])*)\})))?/gi, yIe = /\n{2,}$/, N3 = /^(\s*>[\s\S]*?)(?=\n\n|$)/, vIe = /^ *> ?/gm, bIe = /^(?:\[!([^\]]*)\]\n)?([\s\S]*)/, xIe = /^ {2,}\n/, wIe = /^(?:([-*_])( *\1){2,}) *(?:\n *)+\n/, M3 = /^(?: {1,3})?(`{3,}|~{3,}) *(\S+)? *([^\n]*?)?\n([\s\S]*?)(?:\1\n?|$)/, P3 = /^(?: {4}[^\n]+\n*)+(?:\n *)+\n?/, SIe = /^(`+)((?:\\`|(?!\1)`|[^`])+)\1/, _Ie = /^(?:\n *)*\n/, EIe = /\r\n?/g, CIe = /^\[\^([^\]]+)](:(.*)((\n+ {4,}.*)|(\n(?!\[\^).+))*)/, kIe = /^\[\^([^\]]+)]/, TIe = /\f/g, RIe = /^---[ \t]*\n(.|\n)*\n---[ \t]*\n/, OIe = /^\[(x|\s)\]/, $3 = /^(#{1,6}) *([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, I3 = /^ *(#{1,6}) +([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, j3 = /^([^\n]+)\n *(=|-)\2{2,} *\n/, lO = /^<([a-z][^ >/]*) ?((?:[^>]*[^/])?)>/i;
  function AIe(e) {
    const t = lO.exec(e);
    if (!t) return null;
    const n = t[1], r = n.toLowerCase(), o = r.length + 1;
    let i = t[0].length;
    e[i] === `
` && i++;
    const a = i;
    let s = i, l = 1;
    const u = e.length;
    for (; l > 0; ) {
      const p = e.indexOf("<", i);
      if (p === -1) return null;
      let h = -1, g = -1;
      if (e[p + 1] === "/") g = p;
      else if (e[p + 1] === r[0] || e[p + 1] === n[0]) {
        let y = !0;
        for (let b = 0; b < r.length; b++) {
          const v = e[p + 1 + b];
          if (v !== r[b] && v !== n[b]) {
            y = !1;
            break;
          }
        }
        !y || e[p + o] !== " " && e[p + o] !== ">" || (h = p);
      }
      if (h !== -1 || g !== -1) if (h !== -1 && (g === -1 || h < g)) i = h + o + 1, l++;
      else {
        let y = g + 2;
        for (; y < u; ) {
          const v = e[y];
          if (v !== " " && v !== "	" && v !== `
` && v !== "\r") break;
          y++;
        }
        if (y + r.length > u) return null;
        let b = !0;
        for (let v = 0; v < r.length; v++) {
          const x = e[y + v];
          if (x !== r[v] && x !== n[v]) {
            b = !1;
            break;
          }
        }
        if (!b) {
          i = y;
          continue;
        }
        for (y += r.length; y < u; ) {
          const v = e[y];
          if (v !== " " && v !== "	" && v !== `
` && v !== "\r") break;
          y++;
        }
        if (y >= u || e[y] !== ">") {
          i = y;
          continue;
        }
        s = g, i = y + 1, l--;
      }
      else i = p + 1;
    }
    let d = 0;
    for (; i + d < u && e[i + d] === `
`; ) d++;
    return [e.slice(0, i + d), n, t[2], e.slice(a, s)];
  }
  const NIe = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi, D3 = /^<!--[\s\S]*?(?:-->)/, MIe = /^(data|aria|x)-[a-z_][a-z\d_.-]*$/, UC = /^ *<([a-z][a-z0-9:]*)(?:\s+((?:<.*?>|[^>])*))?\/?>(?!<\/\1>)(\s*\n)?/i, PIe = /^\{.*\}$/, $Ie = /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/, IIe = /^<([^ >]+[:@\/][^ >]+)>/, jIe = /-([a-z])?/gi, F3 = /^(\|.*)\n(?: *(\|? *[-:]+ *\|[-| :]*)\n((?:.*\|.*\n)*))?\n?/, DIe = /^[^\n]+(?:  \n|\n{2,})/, FIe = /^\[([^\]]*)\]:\s+<?([^\s>]+)>?\s*("([^"]*)")?/, LIe = /^!\[([^\]]*)\] ?\[([^\]]*)\]/, zIe = /^\[([^\]]*)\] ?\[([^\]]*)\]/, BIe = /(\n|^[-*]\s|^#|^ {2,}|^-{2,}|^>\s)/, UIe = /\t/g, VIe = /(^ *\||\| *$)/g, HIe = /^ *:-+: *$/, qIe = /^ *:-+ *$/, WIe = /^ *-+: *$/, GIe = /^(:[a-zA-Z0-9-_]+:)/, KIe = /^\\([^0-9A-Za-z\s])/, YIe = /\\([^0-9A-Za-z\s])/g, XIe = /^[\s\S](?:(?!  \n|[0-9]\.|http)[^=*_~\-\n:<`\\\[!])*/, ZIe = /^\n+/, QIe = /^([ \t]*)/, JIe = /(?:^|\n)( *)$/, cO = "(?:\\d+\\.)", uO = "(?:[*+-])";
  function E7(e) {
    return "( *)(" + (e === 1 ? cO : uO) + ") +";
  }
  const C7 = E7(1), k7 = E7(2);
  function T7(e) {
    return RegExp("^" + (e === 1 ? C7 : k7));
  }
  const eje = T7(1), tje = T7(2);
  function R7(e) {
    return RegExp("^" + (e === 1 ? C7 : k7) + "[^\\n]*(?:\\n(?!\\1" + (e === 1 ? cO : uO) + " )[^\\n]*)*(\\n|$)", "gm");
  }
  const nje = R7(1), rje = R7(2);
  function O7(e) {
    const t = e === 1 ? cO : uO;
    return RegExp("^( *)(" + t + ") [\\s\\S]+?(?:\\n{2,}(?! )(?!\\1" + t + " (?!" + t + " ))\\n*|\\s*\\n*$)");
  }
  const A7 = O7(1), N7 = O7(2);
  function L3(e, t) {
    const n = t === 1, r = n ? A7 : N7, o = n ? nje : rje, i = n ? eje : tje;
    return { t: (a) => i.test(a), o: Hs(function(a, s) {
      const l = JIe.exec(s.prevCapture);
      return l && (s.list || !s.inline && !s.simple) ? r.exec(a = l[1] + a) : null;
    }), u: 1, i(a, s, l) {
      const u = n ? +a[2] : void 0, d = a[0].replace(yIe, `
`).match(o), p = i.exec(d[0]), h = RegExp("^ {1," + (p ? p[0].length : 0) + "}", "gm");
      let g = !1;
      return { items: d.map(function(y, b) {
        const v = y.replace(h, "").replace(i, ""), x = b === d.length - 1, E = yi(v, `

`) || x && g;
        g = E;
        const _ = l.inline, C = l.list;
        let k;
        l.list = !0, E ? (l.inline = !1, k = Lp(v) + `

`) : (l.inline = !0, k = Lp(v));
        const R = s(k, l);
        return l.inline = _, l.list = C, R;
      }), ordered: n, start: u };
    } };
  }
  const oje = RegExp(`^\\[((?:\\[[^\\[\\]]*(?:\\[[^\\[\\]]*\\][^\\[\\]]*)*\\]|[^\\[\\]])*)\\]\\(\\s*<?((?:\\([^)]*\\)|[^\\s\\\\]|\\\\.)*?)>?(?:\\s+['"]([\\s\\S]*?)['"])?\\s*\\)`), ije = /^!\[(.*?)\]\( *((?:\([^)]*\)|[^() ])*) *"?([^)"]*)?"?\)/;
  function z3(e) {
    return typeof e == "string";
  }
  function Lp(e) {
    let t = e.length;
    for (; t > 0 && e[t - 1] <= " "; ) t--;
    return e.slice(0, t);
  }
  function VC(e, t) {
    return e.startsWith(t);
  }
  function yi(e, t) {
    return e.indexOf(t) !== -1;
  }
  function aje(e, t, n) {
    if (Array.isArray(n)) {
      for (let r = 0; r < n.length; r++) if (VC(e, n[r])) return !0;
      return !1;
    }
    return n(e, t);
  }
  function ip(e) {
    return e.replace(/[]/g, "a").replace(/[]/g, "c").replace(/[]/g, "d").replace(/[]/g, "e").replace(/[]/g, "i").replace(/[]/g, "n").replace(/[]/g, "o").replace(/[]/g, "u").replace(/[]/g, "y").replace(/[^a-z0-9- ]/gi, "").replace(/ /gi, "-").toLowerCase();
  }
  function sje(e) {
    return WIe.test(e) ? "right" : HIe.test(e) ? "center" : qIe.test(e) ? "left" : null;
  }
  function B3(e, t, n, r) {
    const o = n.inTable;
    n.inTable = !0;
    let i = [[]], a = "";
    function s() {
      if (!a) return;
      const l = i[i.length - 1];
      l.push.apply(l, t(a, n)), a = "";
    }
    return e.trim().split(/(`[^`]*`|\\\||\|)/).filter(Boolean).forEach((l, u, d) => {
      l.trim() === "|" && (s(), r) ? u !== 0 && u !== d.length - 1 && i.push([]) : a += l;
    }), s(), n.inTable = o, i;
  }
  function lje(e, t, n) {
    n.inline = !0;
    const r = e[2] ? e[2].replace(VIe, "").split("|").map(sje) : [], o = e[3] ? function(a, s, l) {
      return a.trim().split(`
`).map(function(u) {
        return B3(u, s, l, !0);
      });
    }(e[3], t, n) : [], i = B3(e[1], t, n, !!o.length);
    return n.inline = !1, o.length ? { align: r, cells: o, header: i, type: "25" } : { children: i, type: "21" };
  }
  function U3(e, t) {
    return e.align[t] == null ? {} : { textAlign: e.align[t] };
  }
  function Hs(e) {
    return e.inline = 1, e;
  }
  function $s(e) {
    return Hs(function(t, n) {
      return n.inline ? e.exec(t) : null;
    });
  }
  function Jy(e) {
    return Hs(function(t, n) {
      return n.inline || n.simple ? e.exec(t) : null;
    });
  }
  function ka(e) {
    return function(t, n) {
      return n.inline || n.simple ? null : e.exec(t);
    };
  }
  function V3(e) {
    return Hs(function(t) {
      return e.exec(t);
    });
  }
  const cje = /(javascript|vbscript|data(?!:image)):/i;
  function uje(e) {
    try {
      const t = decodeURIComponent(e).replace(/[^A-Za-z0-9/:]/g, "");
      if (cje.test(t)) return null;
    } catch {
      return null;
    }
    return e;
  }
  function bi(e) {
    return e && e.replace(YIe, "$1");
  }
  function Iv(e, t, n) {
    const r = n.inline || !1, o = n.simple || !1;
    n.inline = !0, n.simple = !0;
    const i = e(t, n);
    return n.inline = r, n.simple = o, i;
  }
  function fje(e, t, n) {
    const r = n.inline || !1, o = n.simple || !1;
    n.inline = !1, n.simple = !0;
    const i = e(t, n);
    return n.inline = r, n.simple = o, i;
  }
  function dje(e, t, n) {
    const r = n.inline || !1;
    n.inline = !1;
    const o = e(t, n);
    return n.inline = r, o;
  }
  const pje = (e, t, n) => ({ children: Iv(t, e[2], n) });
  function Y_() {
    return {};
  }
  function hje(...e) {
    return e.filter(Boolean).join(" ");
  }
  function X_(e, t, n) {
    let r = e;
    const o = t.split(".");
    for (; o.length && (r = r[o[0]], r !== void 0); ) o.shift();
    return r || n;
  }
  function Z_(e, t, n, r) {
    if (!t || !t.trim()) return null;
    const o = t.match(gIe);
    return o ? o.reduce(function(i, a) {
      const s = a.indexOf("=");
      if (s !== -1) {
        const l = function(p) {
          return p.indexOf("-") !== -1 && p.match(MIe) === null && (p = p.replace(jIe, function(h, g) {
            return g.toUpperCase();
          })), p;
        }(a.slice(0, s)).trim(), u = O3[l] || l;
        if (u === "ref") return i;
        const d = i[u] = function(p, h, g, y) {
          return h === "style" ? function(b) {
            const v = [];
            if (!b) return v;
            let x = "", E = 0, _ = "";
            for (let k = 0; k < b.length; k++) {
              const R = b[k];
              if (R === '"' || R === "'") _ ? R === _ && (_ = "", E--) : (_ = R, E++);
              else if (R === "(" && x.endsWith("url")) E++;
              else if (R === ")" && E > 0) E--;
              else if (R === ";" && E === 0) {
                const A = x.indexOf(":");
                A > 0 && v.push([x.slice(0, A).trim(), x.slice(A + 1).trim()]), x = "";
                continue;
              }
              x += R;
            }
            const C = x.indexOf(":");
            return C > 0 && v.push([x.slice(0, C).trim(), x.slice(C + 1).trim()]), v;
          }(g).reduce(function(b, [v, x]) {
            return b[v.replace(/(-[a-z])/g, (E) => E[1].toUpperCase())] = y(x, p, v), b;
          }, {}) : mIe.indexOf(h) !== -1 ? y(bi(g), p, h) : (g.match(PIe) && (g = bi(g.slice(1, g.length - 1))), g === "true" || g !== "false" && g);
        }(e, l, function(p) {
          const h = p[0];
          return (h === '"' || h === "'") && p.length >= 2 && p[p.length - 1] === h ? p.slice(1, -1) : p;
        }(a.slice(s + 1).trim()), n);
        typeof d == "string" && (lO.test(d) || UC.test(d)) && (i[u] = r(d.trim()));
      } else a !== "style" && (i[O3[a] || a] = !0);
      return i;
    }, {}) : null;
  }
  function H3(e, t) {
    for (let n = 0; n < e.length; n++) if (e[n].test(t)) return !0;
    return !1;
  }
  function mje(e = "", t = {}) {
    t.overrides = t.overrides || {}, t.namedCodesToUnicode = t.namedCodesToUnicode ? Ci({}, A3, t.namedCodesToUnicode) : A3;
    const n = t.slugify || ip, r = t.sanitizer || uje, o = t.createElement || T.createElement, i = [N3, M3, P3, t.enforceAtxHeadings ? I3 : $3, j3, F3, A7, N7], a = [...i, DIe, lO, D3, UC];
    function s(y, b, ...v) {
      const x = X_(t.overrides, y + ".props", {});
      return o(function(E, _) {
        const C = X_(_, E);
        return C ? typeof C == "function" || typeof C == "object" && "render" in C ? C : X_(_, E + ".component", E) : E;
      }(y, t.overrides), Ci({}, b, x, { className: hje(b?.className, x.className) || void 0 }), ...v);
    }
    function l(y) {
      y = y.replace(RIe, "");
      let b = !1;
      t.forceInline ? b = !0 : t.forceBlock || (b = BIe.test(y) === !1);
      const v = h(b ? y : Lp(y).replace(ZIe, "") + `

`, { inline: b });
      if (t.ast) return v;
      const x = g(v);
      for (; z3(x[x.length - 1]) && !x[x.length - 1].trim(); ) x.pop();
      if (u.length && x.push(s("footer", { key: "footer" }, u.map(function(C) {
        return s("div", { id: n(C.identifier, ip), key: C.identifier }, C.identifier, g(h(C.footnote, { inline: !0 })));
      }))), t.wrapper === null) return x;
      const E = t.wrapper || (b ? "span" : "div");
      let _;
      if (x.length > 1 || t.forceWrapper) _ = x;
      else {
        if (x.length === 1) return _ = x[0], typeof _ == "string" ? s("span", { key: "outer" }, _) : _;
        _ = null;
      }
      return o(E, Ci({ key: "outer" }, t.wrapperProps), _);
    }
    const u = [], d = {}, p = { 0: { t: [">"], o: ka(N3), u: 1, i(y, b, v) {
      const [, x, E] = y[0].replace(vIe, "").match(bIe);
      return { alert: x, children: b(E, v) };
    } }, 1: { t: ["  "], o: $s(xIe), u: 1, i: Y_ }, 2: { t: function(y, b) {
      if (b.inline || b.simple) return !1;
      var v = y[0];
      return v === "-" || v === "*" || v === "_";
    }, o: ka(wIe), u: 1, i: Y_ }, 3: { t: ["    "], o: ka(P3), u: 0, i: (y) => ({ lang: void 0, text: bi(Lp(y[0].replace(/^ {4}/gm, ""))) }) }, 4: { t: ["```", "~~~"], o: ka(M3), u: 0, i: (y) => ({ attrs: Z_("code", y[3] || "", r, l), lang: y[2] || void 0, text: y[4], type: "3" }) }, 5: { t: ["`"], o: Jy(SIe), u: 3, i: (y) => ({ text: bi(y[2]) }) }, 6: { t: ["[^"], o: ka(CIe), u: 0, i: (y) => (u.push({ footnote: y[2], identifier: y[1] }), {}) }, 7: { t: ["[^"], o: $s(kIe), u: 1, i: (y) => ({ target: "#" + n(y[1], ip), text: y[1] }) }, 8: { t: ["[ ]", "[x]"], o: $s(OIe), u: 1, i: (y) => ({ completed: y[1].toLowerCase() === "x" }) }, 9: { t: ["#"], o: ka(t.enforceAtxHeadings ? I3 : $3), u: 1, i: (y, b, v) => ({ children: Iv(b, y[2], v), id: n(y[2], ip), level: y[1].length }) }, 10: { t: (y) => {
      const b = y.indexOf(`
`);
      return b > 0 && b < y.length - 1 && (y[b + 1] === "=" || y[b + 1] === "-");
    }, o: ka(j3), u: 1, i: (y, b, v) => ({ children: Iv(b, y[1], v), level: y[2] === "=" ? 1 : 2, type: "9" }) }, 11: { t: ["<"], o: Hs(AIe), u: 1, i(y, b, v) {
      const [, x] = y[3].match(QIe), E = RegExp("^" + x, "gm"), _ = y[3].replace(E, ""), C = H3(a, _) ? dje : Iv, k = y[1].toLowerCase(), R = hIe.indexOf(k) !== -1, A = (R ? k : y[1]).trim(), M = { attrs: Z_(A, y[2], r, l), noInnerParse: R, tag: A };
      if (v.inAnchor = v.inAnchor || k === "a", R) M.text = y[3];
      else {
        const I = v.inHTML;
        v.inHTML = !0, M.children = C(b, _, v), v.inHTML = I;
      }
      return v.inAnchor = !1, M;
    } }, 13: { t: ["<"], o: V3(UC), u: 1, i(y) {
      const b = y[1].trim();
      return { attrs: Z_(b, y[2] || "", r, l), tag: b };
    } }, 12: { t: ["<!--"], o: V3(D3), u: 1, i: () => ({}) }, 14: { t: ["!["], o: Jy(ije), u: 1, i: (y) => ({ alt: bi(y[1]), target: bi(y[2]), title: bi(y[3]) }) }, 15: { t: ["["], o: $s(oje), u: 3, i: (y, b, v) => ({ children: fje(b, y[1], v), target: bi(y[2]), title: bi(y[3]) }) }, 16: { t: function(y, b) {
      return !(!b.inline || b.inAnchor) && y[0] === "<" && (yi(y, ":") || yi(y, "@") || yi(y, "/"));
    }, o: $s(IIe), u: 0, i(y) {
      let b = y[1], v = !1;
      return yi(b, "@") && !yi(b, "//") && (v = !0, b = b.replace("mailto:", "")), { children: [{ text: b, type: "27" }], target: v ? "mailto:" + b : b, type: "15" };
    } }, 17: { t: (y, b) => !b.inAnchor && !t.disableAutoLink && VC(y, "http"), o: $s($Ie), u: 0, i: (y) => ({ children: [{ text: y[1], type: "27" }], target: y[1], title: void 0, type: "15" }) }, 20: L3(0, 1), 30: L3(0, 2), 19: { t: [`
`], o: ka(_Ie), u: 3, i: Y_ }, 21: { t: function(y, b) {
      return !b.inline && !b.simple;
    }, o: Hs(function(y, b) {
      if (b.inline || b.simple || b.inHTML && !yi(y, `

`) && !yi(b.prevCapture, `

`)) return null;
      let v = "", x = 0;
      for (; ; ) {
        const _ = y.indexOf(`
`, x), C = y.slice(x, _ === -1 ? void 0 : _ + 1), k = y[x];
        if ((k === ">" || k === "#" || k === "|" || k === "`" || k === "~" || k === "*" || k === "-" || k === "_" || k === " ") && H3(i, C) || (v += C, _ === -1 || !C.trim())) break;
        x = _ + 1;
      }
      const E = Lp(v);
      return E === "" ? null : [v, , E];
    }), u: 3, i: pje }, 22: { t: ["["], o: $s(FIe), u: 0, i: (y) => (d[y[1]] = { target: y[2], title: y[4] }, {}) }, 23: { t: ["!["], o: Jy(LIe), u: 0, i: (y) => ({ alt: y[1] ? bi(y[1]) : void 0, ref: y[2] }) }, 24: { t: (y) => y[0] === "[" && !yi(y, "]("), o: $s(zIe), u: 0, i: (y, b, v) => ({ children: b(y[1], v), fallbackChildren: y[0], ref: y[2] }) }, 25: { t: ["|"], o: ka(F3), u: 1, i: lje }, 27: { o: Hs(function(y, b) {
      let v;
      return VC(y, ":") && (v = GIe.exec(y)), v || XIe.exec(y);
    }), u: 4, i(y) {
      const b = y[0];
      return { text: yi(b, "&") ? b.replace(NIe, (v, x) => t.namedCodesToUnicode[x] || v) : b };
    } }, 34: { t: ["*", "_", "~", "="], o: Hs(dIe), u: 2, i: (y, b, v) => ({ children: b(y[2], v), tag: y[1] }) }, 28: { t: ["\\"], o: Jy(KIe), u: 1, i: (y) => ({ text: y[1], type: "27" }) } };
    t.disableParsingRawHTML === !0 && (delete p[11], delete p[13]);
    const h = function(y) {
      var b = Object.keys(y);
      function v(x, E) {
        var _ = [];
        if (E.prevCapture = E.prevCapture || "", x.trim()) for (; x; ) for (var C = 0; C < b.length; ) {
          var k = b[C], R = y[k];
          if (!R.t || aje(x, E, R.t)) {
            var A = R.o(x, E);
            if (A && A[0]) {
              x = x.substring(A[0].length);
              var M = R.i(A, v, E);
              E.prevCapture += A[0], M.type || (M.type = k), _.push(M);
              break;
            }
            C++;
          } else C++;
        }
        return E.prevCapture = "", _;
      }
      return b.sort(function(x, E) {
        return y[x].u - y[E].u || (x < E ? -1 : 1);
      }), function(x, E) {
        return v(function(_) {
          return _.replace(EIe, `
`).replace(TIe, "").replace(UIe, "    ");
        }(x), E);
      };
    }(p), g = /* @__PURE__ */ function(y, b, v, x, E) {
      function _(C) {
        return Array.isArray(C) ? C.map((k) => "text" in k ? k.text : "") : "text" in C ? C.text : "";
      }
      return function C(k, R = {}) {
        const A = (R.renderDepth || 0) + 1;
        if (A > 2500) return _(k);
        R.renderDepth = A;
        try {
          if (Array.isArray(k)) {
            const I = R.key, D = [];
            let L = !1;
            for (let P = 0; P < k.length; P++) {
              R.key = P;
              const B = C(k[P], R), j = z3(B);
              j && L ? D[D.length - 1] += B : B !== null && D.push(B), L = j;
            }
            return R.key = I, R.renderDepth = A - 1, D;
          }
          const M = function(I, D, L) {
            const P = () => function(B, j, V, F, G, W, K) {
              switch (B.type) {
                case "0": {
                  const $ = { key: V.key };
                  return B.alert && ($.className = "markdown-alert-" + W(B.alert.toLowerCase(), ip), B.children.unshift({ attrs: {}, children: [{ type: "27", text: B.alert }], noInnerParse: !0, type: "11", tag: "header" })), F("blockquote", $, j(B.children, V));
                }
                case "1":
                  return F("br", { key: V.key });
                case "2":
                  return F("hr", { key: V.key });
                case "3":
                  return F("pre", { key: V.key }, F("code", Ci({}, B.attrs, { className: B.lang ? "lang-" + B.lang : "" }), B.text));
                case "5":
                  return F("code", { key: V.key }, B.text);
                case "7":
                  return F("a", { key: V.key, href: G(B.target, "a", "href") }, F("sup", { key: V.key }, B.text));
                case "8":
                  return F("input", { checked: B.completed, key: V.key, readOnly: !0, type: "checkbox" });
                case "9":
                  return F("h" + B.level, { id: B.id, key: V.key }, j(B.children, V));
                case "11":
                  return F(B.tag, Ci({ key: V.key }, B.attrs), B.text || (B.children ? j(B.children, V) : ""));
                case "13":
                  return F(B.tag, Ci({}, B.attrs, { key: V.key }));
                case "14":
                  return F("img", { key: V.key, alt: B.alt || void 0, title: B.title || void 0, src: G(B.target, "img", "src") });
                case "15":
                  return F("a", { key: V.key, href: G(B.target, "a", "href"), title: B.title }, j(B.children, V));
                case "23":
                  return K[B.ref] ? F("img", { key: V.key, alt: B.alt, src: G(K[B.ref].target, "img", "src"), title: K[B.ref].title }) : null;
                case "24":
                  return K[B.ref] ? F("a", { key: V.key, href: G(K[B.ref].target, "a", "href"), title: K[B.ref].title }, j(B.children, V)) : F("span", { key: V.key }, B.fallbackChildren);
                case "25": {
                  const $ = B;
                  return F("table", { key: V.key }, F("thead", null, F("tr", null, $.header.map(function(U, X) {
                    return F("th", { key: X, style: U3($, X) }, j(U, V));
                  }))), F("tbody", null, $.cells.map(function(U, X) {
                    return F("tr", { key: X }, U.map(function(z, H) {
                      return F("td", { key: H, style: U3($, H) }, j(z, V));
                    }));
                  })));
                }
                case "27":
                  return B.text;
                case "34":
                  return F(B.tag, { key: V.key }, j(B.children, V));
                case "20":
                case "30":
                  return F(B.ordered ? "ol" : "ul", { key: V.key, start: B.type === "20" ? B.start : void 0 }, B.items.map(function($, U) {
                    return F("li", { key: U }, j($, V));
                  }));
                case "19":
                  return `
`;
                case "21":
                  return F("p", { key: V.key }, j(B.children, V));
                default:
                  return null;
              }
            }(I, D, L, b, v, x, E);
            return y ? y(P, I, D, L) : P();
          }(k, C, R);
          return R.renderDepth = A - 1, M;
        } catch (M) {
          if (M instanceof RangeError && M.message.includes("Maximum call stack")) return _(k);
          throw M;
        }
      };
    }(t.renderRule, s, r, n, d);
    return l(e);
  }
  const mm = (e) => {
    let { children: t, options: n } = e, r = function(o, i) {
      if (o == null) return {};
      var a = {};
      for (var s in o) if ({}.hasOwnProperty.call(o, s)) {
        if (i.indexOf(s) !== -1) continue;
        a[s] = o[s];
      }
      return a;
    }(e, pIe);
    return mje(t ?? "", Ci({}, n, { wrapperProps: Ci({}, n?.wrapperProps, r) }));
  }, M7 = Symbol("remove-this-key"), q3 = Symbol("reset");
  function gje(e, t) {
    return Array.isArray(e.required) && e.required.indexOf(t) !== -1;
  }
  function yje(e, t) {
    switch (t) {
      case "array":
        return [];
      case "boolean":
        return !1;
      case "null":
        return null;
      case "number":
        return 0;
      case "object":
        return {};
      case "string":
      default:
        return e(bt.NewStringDefault);
    }
  }
  function vje(e) {
    const { fieldPathId: t, schema: n, registry: r, uiSchema: o, errorSchema: i, formData: a, onChange: s, onBlur: l, onFocus: u, disabled: d, readonly: p, required: h, hideError: g, propertyName: y, handleKeyRename: b, handleRemoveProperty: v, addedByAdditionalProperties: x } = e, [E, _] = T.useState(!1), { globalFormOptions: C, fields: k } = r, { SchemaField: R } = k, A = Oc(Mo(y, C, t.path)), M = T.useCallback((P, B, j, V) => {
      P === void 0 && x && (P = ""), s(P, B, j, V);
    }, [s, x]), I = T.useCallback((P) => {
      y !== P && _(!0), b(y, P);
    }, [y, b]), D = T.useCallback((P) => {
      const { target: { value: B } } = P;
      I(B);
    }, [I]), L = T.useCallback(() => {
      v(y);
    }, [y, v]);
    return S.jsx(R, { name: y, required: h, schema: n, uiSchema: o, errorSchema: i, fieldPathId: A, formData: a, wasPropertyKeyModified: E, onKeyRename: I, onKeyRenameBlur: D, onRemoveProperty: L, onChange: M, onBlur: l, onFocus: u, registry: r, disabled: d, readonly: p, hideError: g });
  }
  function bje(e) {
    const { schema: t, uiSchema: n = {}, formData: r, errorSchema: o, fieldPathId: i, name: a, required: s = !1, disabled: l, readonly: u, hideError: d, onBlur: p, onFocus: h, onChange: g, registry: y, title: b } = e, { fields: v, schemaUtils: x, translateString: E, globalUiOptions: _ } = y, { OptionalDataControlsField: C } = v, k = x.retrieveSchema(t, r, !0), R = Ze(n, _), { properties: A = {} } = k, M = e.childFieldPathId ?? i, I = R.title ?? k.title ?? b ?? a, D = R.description ?? k.description, L = hm(y, k, s, n), P = Ff(r);
    let B = [];
    const j = T.useCallback((U, X) => {
      const { duplicateKeySuffixSeparator: z = "-" } = Ze(n, _);
      let H = 0, Y = U;
      for (; kt(X, Y); )
        Y = `${U}${z}${++H}`;
      return Y;
    }, [n, _]), V = T.useCallback(() => {
      if (!(k.additionalProperties || k.patternProperties))
        return;
      const { translateString: U } = y, X = { ...r }, z = j("newKey", X);
      if (k.patternProperties)
        Xt(X, z, null);
      else {
        let H, Y, Q;
        if (Pt(k.additionalProperties)) {
          H = k.additionalProperties.type, Y = k.additionalProperties.const, Q = k.additionalProperties.default;
          let te = k.additionalProperties;
          if (mn in te) {
            const { schemaUtils: le } = y;
            te = le.retrieveSchema({ [mn]: te[mn] }, r), H = te.type, Y = te.const, Q = te.default;
          }
          !H && (At in te || gt in te) && (H = "object");
        }
        const re = Y ?? Q ?? yje(U, H);
        Xt(X, z, re);
      }
      g(X, M.path);
    }, [r, g, y, M, j, k]), F = T.useCallback((U, X) => {
      if (U !== X) {
        const z = j(X, r), H = {
          ...r
        }, Y = { [U]: z }, Q = Object.keys(H).map((te) => ({ [Y[te] || te]: H[te] })), re = Object.assign({}, ...Q);
        g(re, M.path);
      }
    }, [r, g, M, j]), G = T.useCallback((U) => {
      g(M7, [...M.path, U]);
    }, [g, M]);
    if (!L || P)
      try {
        const U = Object.keys(A);
        B = qPe(U, R.order);
      } catch (U) {
        return S.jsxs("div", { children: [S.jsx("p", { className: "rjsf-config-error", style: { color: "red" }, children: S.jsx(mm, { options: { disableParsingRawHTML: !0 }, children: E(bt.InvalidObjectField, [a || "root", U.message]) }) }), S.jsx("pre", { children: JSON.stringify(k) })] });
      }
    const W = et("ObjectFieldTemplate", y, R), K = L ? S.jsx(C, { ...e, fieldPathId: M, schema: k }) : void 0, $ = {
      // getDisplayLabel() always returns false for object types, so just check the `uiOptions.label`
      title: R.label === !1 ? "" : I,
      description: R.label === !1 ? void 0 : D,
      properties: B.map((U) => {
        const X = kt(k, [It, U, $a]), z = X ? n.additionalProperties : n[U], H = Ze(z).widget === "hidden";
        return {
          content: S.jsx(vje, { propertyName: U, required: gje(k, U), schema: Ee(k, [It, U], {}), uiSchema: z, errorSchema: Ee(o, [U]), fieldPathId: M, formData: Ee(r, [U]), handleKeyRename: F, handleRemoveProperty: G, addedByAdditionalProperties: X, onChange: g, onBlur: p, onFocus: h, registry: y, disabled: l, readonly: u, hideError: d }, U),
          name: U,
          readonly: u,
          disabled: l,
          required: s,
          hidden: H
        };
      }),
      readonly: u,
      disabled: l,
      required: s,
      fieldPathId: i,
      uiSchema: n,
      errorSchema: o,
      schema: k,
      formData: r,
      registry: y,
      optionalDataControl: K,
      className: L ? "rjsf-optional-object-field" : void 0
    };
    return S.jsx(W, { ...$, onAddProperty: V });
  }
  function xje(e) {
    const { schema: t, uiSchema: n = {}, formData: r, disabled: o = !1, readonly: i = !1, onChange: a, errorSchema: s, fieldPathId: l, registry: u } = e, { globalUiOptions: d = {}, schemaUtils: p, translateString: h } = u, g = Ze(n, d), y = et("OptionalDataControlsTemplate", u, g), b = Ff(r);
    let v, x, E, _;
    if (o || i)
      v = M_(l, "Msg"), x = b ? void 0 : h(bt.OptionalObjectEmptyMsg);
    else {
      const C = b ? bt.OptionalObjectRemove : bt.OptionalObjectAdd;
      x = h(C), b ? (v = M_(l, "Remove"), _ = () => a(void 0, l.path, s)) : (v = M_(l, "Add"), E = () => {
        let k = p.getDefaultFormState(t, r, "excludeObjectChildren");
        k === void 0 && (k = Qo(t) === "array" ? [] : {}), a(k, l.path, s);
      });
    }
    return x && S.jsx(y, { id: v, registry: u, schema: t, uiSchema: n, label: x, onAddClick: E, onRemoveClick: _ });
  }
  const wje = {
    array: "ArrayField",
    boolean: "BooleanField",
    integer: "NumberField",
    number: "NumberField",
    object: "ObjectField",
    string: "StringField",
    null: "NullField"
  };
  function Sje(e, t, n) {
    const r = t.field, { fields: o } = n;
    if (typeof r == "function")
      return r;
    if (typeof r == "string" && r in o)
      return o[r];
    const i = Qo(e), a = Array.isArray(i) ? i[0] : i || "", s = e.$id;
    let l = wje[a];
    return s && s in o && (l = s), !l && (e.anyOf || e.oneOf) ? () => null : l in o ? o[l] : o.FallbackField;
  }
  function _je(e) {
    const { schema: t, fieldPathId: n, uiSchema: r, formData: o, errorSchema: i, name: a, onChange: s, onKeyRename: l, onKeyRenameBlur: u, onRemoveProperty: d, required: p = !1, registry: h, wasPropertyKeyModified: g = !1 } = e, { schemaUtils: y, globalFormOptions: b, globalUiOptions: v, fields: x } = h, { AnyOfField: E, OneOfField: _ } = x, C = Ze(r, v), k = et("FieldTemplate", h, C), R = et("DescriptionFieldTemplate", h, C), A = et("FieldHelpTemplate", h, C), M = et("FieldErrorTemplate", h, C), I = y.retrieveSchema(t, o), D = n[nn], L = T.useCallback((Ce, Ne, Le, Ve) => s(Ce, Ne, Le, Ve || D), [D, s]), P = Sje(I, C, h), B = !!(C.disabled ?? e.disabled), j = !!(C.readonly ?? (e.readonly || e.schema.readOnly || I.readOnly)), V = C.hideError, F = V === void 0 ? e.hideError : !!V, G = !!(C.autofocus ?? e.autofocus);
    if (Object.keys(I).length === 0)
      return null;
    let W = y.getDisplayLabel(I, r, v);
    const K = C.field && C.fieldReplacesAnyOrOneOf === !0;
    let $, U, X = { fieldPathId: n };
    if ((At in I || gt in I) && !K && !y.isSelect(I)) {
      I[At] ? ($ = E, U = I[At].map((Le) => y.retrieveSchema(Pt(Le) ? Le : {}, o))) : I[gt] && ($ = _, U = I[gt].map((Le) => y.retrieveSchema(Pt(Le) ? Le : {}, o)));
      const Ce = hm(h, I, p, r), Ne = Ff(o);
      W = W && (!Ce || Ne), X = {
        childFieldPathId: n,
        // The main FieldComponent will add `XxxOf` onto the fieldPathId to avoid duplication with the rendering of the
        // same FieldComponent by the `XxxOfField`
        fieldPathId: Mo("XxxOf", b, n)
      };
    }
    const { __errors: z, ...H } = i || {}, Y = bh(r, ["ui:classNames", "classNames", "ui:style"]);
    Gs in Y && (Y[Gs] = bh(Y[Gs], ["classNames", "style"]));
    const Q = S.jsx(P, { ...e, onChange: L, ...X, schema: I, uiSchema: Y, disabled: B, readonly: j, hideError: F, autofocus: G, errorSchema: H, rawErrors: z }), re = n[nn];
    let te;
    g ? te = a : te = $a in I ? a : C.title || e.schema.title || I.title || e.title || a;
    const le = C.description || e.schema.description || I.description || "", fe = C.help, J = C.widget === "hidden", ee = ["rjsf-field", `rjsf-field-${Qo(I)}`];
    !F && z && z.length > 0 && ee.push("rjsf-field-error"), C.classNames && ee.push(C.classNames);
    const ie = S.jsx(A, { help: fe, fieldPathId: n, schema: I, uiSchema: r, hasErrors: !F && z && z.length > 0, registry: h }), ae = F || $ && !y.isSelect(I) ? void 0 : S.jsx(M, { errors: z, errorSchema: i, fieldPathId: n, schema: I, uiSchema: r, registry: h }), ge = {
      description: S.jsx(R, { id: Tc(re), description: le, schema: I, uiSchema: r, registry: h }),
      rawDescription: le,
      help: ie,
      rawHelp: typeof fe == "string" ? fe : void 0,
      errors: ae,
      rawErrors: F ? void 0 : z,
      id: re,
      label: te,
      hidden: J,
      onChange: s,
      onKeyRename: l,
      onKeyRenameBlur: u,
      onRemoveProperty: d,
      required: p,
      disabled: B,
      readonly: j,
      hideError: F,
      displayLabel: W,
      classNames: ee.join(" ").trim(),
      style: C.style,
      formData: o,
      schema: I,
      uiSchema: r,
      registry: h
    };
    return S.jsx(k, { ...ge, children: S.jsxs(S.Fragment, { children: [Q, $ && S.jsx($, { name: a, disabled: B, readonly: j, hideError: F, errorSchema: i, formData: o, fieldPathId: n, onBlur: e.onBlur, onChange: e.onChange, onFocus: e.onFocus, options: U, registry: h, required: p, schema: I, uiSchema: r })] }) });
  }
  class Eje extends T.Component {
    shouldComponentUpdate(t) {
      const { registry: { globalFormOptions: n } } = this.props, { experimental_componentUpdateStrategy: r = "customDeep" } = n;
      return l7(this, t, this.state, r);
    }
    render() {
      return S.jsx(_je, { ...this.props });
    }
  }
  function Cje(e) {
    const { schema: t, name: n, uiSchema: r, fieldPathId: o, formData: i, required: a, disabled: s = !1, readonly: l = !1, autofocus: u = !1, onChange: d, onBlur: p, onFocus: h, registry: g, rawErrors: y, hideError: b, title: v } = e, { title: x, format: E } = t, { widgets: _, schemaUtils: C, globalUiOptions: k } = g, R = C.isSelect(t) ? bf(t, r) : void 0;
    let A = R ? "select" : "text";
    E && UPe(t, E, _) && (A = E);
    const { widget: M = A, placeholder: I = "", title: D, ...L } = Ze(r), P = C.getDisplayLabel(t, r, k), B = D ?? v ?? x ?? n, j = Gi(t, M, _), V = T.useCallback((F, G, W) => d(F, o.path, G, W), [d, o]);
    return S.jsx(j, { options: { ...L, enumOptions: R }, schema: t, uiSchema: r, id: o.$id, name: n, label: B, hideLabel: !P, hideError: b, value: i, onChange: V, onBlur: p, onFocus: h, required: a, disabled: s, readonly: l, autofocus: u, registry: g, placeholder: I, rawErrors: y, htmlName: o.name });
  }
  function kje(e) {
    const { formData: t, onChange: n, fieldPathId: r } = e;
    return T.useEffect(() => {
      t === void 0 && n(null, r.path);
    }, [r, t, n]), null;
  }
  function Tje() {
    return {
      AnyOfField: T3,
      ArrayField: I2e,
      // ArrayField falls back to SchemaField if ArraySchemaField is not defined, which it isn't by default
      BooleanField: j2e,
      FallbackField: z2e,
      LayoutGridField: sO,
      LayoutHeaderField: aIe,
      LayoutMultiSchemaField: sIe,
      NumberField: uIe,
      ObjectField: bje,
      OneOfField: T3,
      OptionalDataControlsField: xje,
      SchemaField: Eje,
      StringField: Cje,
      NullField: kje
    };
  }
  function Rje(e) {
    const { fieldPathId: t, description: n, registry: r, schema: o, uiSchema: i } = e, a = Ze(i, r.globalUiOptions), { label: s = !0 } = a;
    if (!n || !s)
      return null;
    const l = et("DescriptionFieldTemplate", r, a);
    return S.jsx(l, { id: Tc(t), description: n, schema: o, uiSchema: i, registry: r });
  }
  function Oje(e) {
    const { children: t, className: n, buttonsProps: r, displayLabel: o, hasDescription: i, hasToolbar: a, registry: s, uiSchema: l } = e, u = Ze(l), d = et("ArrayFieldItemButtonsTemplate", s, u), p = {
      flex: 1,
      paddingLeft: 6,
      paddingRight: 6,
      fontWeight: "bold"
    }, h = i ? 31 : 9, g = { display: "flex", alignItems: o ? "center" : "baseline" }, y = { display: "flex", justifyContent: "flex-end", marginTop: o ? `${h}px` : 0 };
    return S.jsxs("div", { className: n, style: g, children: [S.jsx("div", { className: a ? "col-xs-9 col-md-10 col-xl-11" : "col-xs-12", children: t }), a && S.jsx("div", { className: "col-xs-3 col-md-2 col-xl-1 array-item-toolbox", children: S.jsx("div", { className: "btn-group", style: y, children: S.jsx(d, { ...r, style: p }) }) })] });
  }
  function Aje(e) {
    const { disabled: t, hasCopy: n, hasMoveDown: r, hasMoveUp: o, hasRemove: i, fieldPathId: a, onCopyItem: s, onRemoveItem: l, onMoveDownItem: u, onMoveUpItem: d, readonly: p, registry: h, uiSchema: g } = e, { CopyButton: y, MoveDownButton: b, MoveUpButton: v, RemoveButton: x } = h.templates.ButtonTemplates;
    return S.jsxs(S.Fragment, { children: [(o || r) && S.jsx(v, { id: $i(a, "moveUp"), className: "rjsf-array-item-move-up", disabled: t || p || !o, onClick: d, uiSchema: g, registry: h }), (o || r) && S.jsx(b, { id: $i(a, "moveDown"), className: "rjsf-array-item-move-down", disabled: t || p || !r, onClick: u, uiSchema: g, registry: h }), n && S.jsx(y, { id: $i(a, "copy"), className: "rjsf-array-item-copy", disabled: t || p, onClick: s, uiSchema: g, registry: h }), i && S.jsx(x, { id: $i(a, "remove"), className: "rjsf-array-item-remove", disabled: t || p, onClick: l, uiSchema: g, registry: h })] });
  }
  function Nje(e) {
    const { canAdd: t, className: n, disabled: r, fieldPathId: o, uiSchema: i, items: a, optionalDataControl: s, onAddClick: l, readonly: u, registry: d, required: p, schema: h, title: g } = e, y = Ze(i), b = et("ArrayFieldDescriptionTemplate", d, y), v = et("ArrayFieldTitleTemplate", d, y), x = !u && !r, { ButtonTemplates: { AddButton: E } } = d.templates;
    return S.jsxs("fieldset", { className: n, id: o.$id, children: [S.jsx(v, { fieldPathId: o, title: y.title || g, required: p, schema: h, uiSchema: i, registry: d, optionalDataControl: x ? s : void 0 }), S.jsx(b, { fieldPathId: o, description: y.description || h.description, schema: h, uiSchema: i, registry: d }), x ? void 0 : s, S.jsx("div", { className: "row array-item-list", children: a }), t && S.jsx(E, { id: $i(o, "add"), className: "rjsf-array-item-add", onClick: l, disabled: r || u, uiSchema: i, registry: d })] });
  }
  function Mje(e) {
    const { fieldPathId: t, title: n, schema: r, uiSchema: o, required: i, registry: a, optionalDataControl: s } = e, l = Ze(o, a.globalUiOptions), { label: u = !0 } = l;
    if (!n || !u)
      return null;
    const d = et("TitleFieldTemplate", a, l);
    return S.jsx(d, { id: b1(t), title: n, required: i, schema: r, uiSchema: o, registry: a, optionalDataControl: s });
  }
  function Pje(e) {
    const {
      id: t,
      name: n,
      // remove this from ...rest
      htmlName: r,
      value: o,
      readonly: i,
      disabled: a,
      autofocus: s,
      onBlur: l,
      onFocus: u,
      onChange: d,
      onChangeOverride: p,
      options: h,
      schema: g,
      uiSchema: y,
      registry: b,
      rawErrors: v,
      type: x,
      hideLabel: E,
      // remove this from ...rest
      hideError: _,
      // remove this from ...rest
      ...C
    } = e;
    if (!t)
      throw console.log("No id for", e), new Error(`no id for props ${JSON.stringify(e)}`);
    const k = {
      ...C,
      ...i7(g, x, h)
    };
    let R;
    k.type === "number" || k.type === "integer" ? R = o || o === 0 ? o : "" : R = o ?? "";
    const A = T.useCallback(({ target: { value: D } }) => d(D === "" ? h.emptyValue : D), [d, h]), M = T.useCallback(({ target: D }) => l(t, D && D.value), [l, t]), I = T.useCallback(({ target: D }) => u(t, D && D.value), [u, t]);
    return S.jsxs(S.Fragment, { children: [S.jsx("input", { id: t, name: r || t, className: "form-control", readOnly: i, disabled: a, autoFocus: s, value: R, ...k, list: g.examples ? Eh(t) : void 0, onChange: p || A, onBlur: M, onFocus: I, "aria-describedby": po(t, !!g.examples) }), Array.isArray(g.examples) && S.jsx("datalist", { id: Eh(t), children: g.examples.concat(g.default && !g.examples.includes(g.default) ? [g.default] : []).map((D) => S.jsx("option", { value: D }, D)) }, `datalist_${t}`)] });
  }
  function $je({ uiSchema: e }) {
    const { submitText: t, norender: n, props: r = {} } = a7(e);
    return n ? null : S.jsx("div", { children: S.jsx("button", { type: "submit", ...r, className: `btn btn-info ${r.className || ""}`, children: t }) });
  }
  function mc(e) {
    const { iconType: t = "default", icon: n, className: r, uiSchema: o, registry: i, ...a } = e;
    return S.jsx("button", { type: "button", className: `btn btn-${t} ${r}`, ...a, children: S.jsx("i", { className: `glyphicon glyphicon-${n}` }) });
  }
  function Ije(e) {
    const { registry: { translateString: t } } = e;
    return S.jsx(mc, { title: t(bt.CopyButton), ...e, icon: "copy" });
  }
  function jje(e) {
    const { registry: { translateString: t } } = e;
    return S.jsx(mc, { title: t(bt.MoveDownButton), ...e, icon: "arrow-down" });
  }
  function Dje(e) {
    const { registry: { translateString: t } } = e;
    return S.jsx(mc, { title: t(bt.MoveUpButton), ...e, icon: "arrow-up" });
  }
  function Fje(e) {
    const { registry: { translateString: t } } = e;
    return S.jsx(mc, { title: t(bt.RemoveButton), ...e, iconType: "danger", icon: "remove" });
  }
  function Lje({ id: e, className: t, onClick: n, disabled: r, registry: o }) {
    const { translateString: i } = o;
    return S.jsx("div", { className: "row", children: S.jsx("p", { className: `col-xs-4 col-sm-2 col-lg-1 col-xs-offset-8 col-sm-offset-10 col-lg-offset-11 text-right ${t}`, children: S.jsx(mc, { id: e, iconType: "info", icon: "plus", className: "btn-add col-xs-12", title: i(bt.AddButton), onClick: n, disabled: r, registry: o }) }) });
  }
  function zje() {
    return {
      SubmitButton: $je,
      AddButton: Lje,
      CopyButton: Ije,
      MoveDownButton: jje,
      MoveUpButton: Dje,
      RemoveButton: Fje
    };
  }
  const P7 = QR();
  function fO({ description: e, registry: t, uiSchema: n = {} }) {
    const { globalUiOptions: r } = t;
    return Ze(n, r).enableMarkdownInDescription && typeof e == "string" ? S.jsx(mm, { options: { disableParsingRawHTML: !0 }, "data-testid": P7.markdown, children: e }) : e;
  }
  fO.TEST_IDS = P7;
  function Bje(e) {
    const { id: t, description: n, registry: r, uiSchema: o } = e;
    return n ? S.jsx("div", { id: t, className: "field-description", children: S.jsx(fO, { description: n, registry: r, uiSchema: o }) }) : null;
  }
  function Uje({ errors: e, registry: t }) {
    const { translateString: n } = t;
    return S.jsxs("div", { className: "panel panel-danger errors", children: [S.jsx("div", { className: "panel-heading", children: S.jsx("h3", { className: "panel-title", children: n(bt.ErrorsLabel) }) }), S.jsx("ul", { className: "list-group", children: e.map((r, o) => S.jsx("li", { className: "list-group-item text-danger", children: r.stack }, o)) })] });
  }
  function Vje(e) {
    const { schema: t, registry: n, typeSelector: r, schemaField: o } = e, i = et("MultiSchemaFieldTemplate", n);
    return S.jsx(i, { selector: r, optionSchemaField: o, schema: t, registry: n });
  }
  const Hje = "*";
  function $7(e) {
    const { label: t, required: n, id: r } = e;
    return t ? S.jsxs("label", { className: "control-label", htmlFor: r, children: [t, n && S.jsx("span", { className: "required", children: Hje })] }) : null;
  }
  function qje(e) {
    const { id: t, label: n, children: r, errors: o, help: i, description: a, hidden: s, required: l, displayLabel: u, registry: d, uiSchema: p } = e, h = Ze(p), g = et("WrapIfAdditionalTemplate", d, h);
    if (s)
      return S.jsx("div", { className: "hidden", children: r });
    const y = h.widget === "checkbox";
    return S.jsxs(g, { ...e, children: [u && !y && S.jsx($7, { label: n, required: l, id: t }), u && a ? a : null, r, o, i] });
  }
  function Wje(e) {
    const { errors: t = [], fieldPathId: n } = e;
    if (t.length === 0)
      return null;
    const r = JR(n);
    return S.jsx("div", { children: S.jsx("ul", { id: r, className: "error-detail bs-callout bs-callout-info", children: t.filter((o) => !!o).map((o, i) => S.jsx("li", { className: "text-danger", children: o }, i)) }) });
  }
  const I7 = QR();
  function dO({ help: e, registry: t, uiSchema: n = {} }) {
    const { globalUiOptions: r } = t;
    return Ze(n, r).enableMarkdownInHelp && typeof e == "string" ? S.jsx(mm, { options: { disableParsingRawHTML: !0 }, "data-testid": I7.markdown, children: e }) : e;
  }
  dO.TEST_IDS = I7;
  function Gje(e) {
    const { fieldPathId: t, help: n, uiSchema: r, registry: o } = e;
    return n ? S.jsx("div", { id: eO(t), className: "help-block", children: S.jsx(dO, { help: n, registry: o, uiSchema: r }) }) : null;
  }
  function Kje(e) {
    const { children: t, column: n, className: r, ...o } = e;
    return S.jsx("div", { className: r, ...o, children: t });
  }
  function Yje(e) {
    const { selector: t, optionSchemaField: n } = e;
    return S.jsxs("div", { className: "panel panel-default panel-body", children: [S.jsx("div", { className: "form-group", children: t }), n] });
  }
  function Xje(e) {
    const { className: t, description: n, disabled: r, formData: o, fieldPathId: i, onAddProperty: a, optionalDataControl: s, properties: l, readonly: u, registry: d, required: p, schema: h, title: g, uiSchema: y } = e, b = Ze(y), v = et("TitleFieldTemplate", d, b), x = et("DescriptionFieldTemplate", d, b), E = !u && !r, { ButtonTemplates: { AddButton: _ } } = d.templates;
    return S.jsxs("fieldset", { className: t, id: i.$id, children: [g && S.jsx(v, { id: b1(i), title: g, required: p, schema: h, uiSchema: y, registry: d, optionalDataControl: E ? s : void 0 }), n && S.jsx(x, { id: Tc(i), description: n, schema: h, uiSchema: y, registry: d }), E ? void 0 : s, l.map((C) => C.content), VV(h, y, o) && S.jsx(_, { id: $i(i, "add"), className: "rjsf-object-property-expand", onClick: a, disabled: r || u, uiSchema: y, registry: d })] });
  }
  function Zje(e) {
    const { id: t, registry: n, label: r, onAddClick: o, onRemoveClick: i } = e;
    return o ? S.jsx(mc, { id: t, registry: n, icon: "plus", className: "rjsf-add-optional-data btn-sm", onClick: o, title: r }) : i ? S.jsx(mc, { id: t, registry: n, icon: "remove", className: "rjsf-remove-optional-data btn-sm", onClick: i, title: r }) : S.jsx("em", { id: t, children: r });
  }
  const Qje = "*";
  function Jje(e) {
    const { id: t, title: n, required: r, optionalDataControl: o } = e;
    return S.jsxs("legend", { id: t, children: [n, r && S.jsx("span", { className: "required", children: Qje }), o && S.jsx("span", { className: "pull-right", style: { marginBottom: "2px" }, children: o })] });
  }
  function eDe(e) {
    const { schema: t, fieldPathId: n, reason: r, registry: o } = e, { translateString: i } = o;
    let a = bt.UnsupportedField;
    const s = [];
    return n && n.$id && (a = bt.UnsupportedFieldWithId, s.push(n.$id)), r && (a = a === bt.UnsupportedField ? bt.UnsupportedFieldWithReason : bt.UnsupportedFieldWithIdAndReason, s.push(r)), S.jsxs("div", { className: "unsupported-field", children: [S.jsx("p", { children: S.jsx(mm, { options: { disableParsingRawHTML: !0 }, children: i(a, s) }) }), t && S.jsx("pre", { children: JSON.stringify(t, null, 2) })] });
  }
  function tDe(e) {
    const { id: t, classNames: n, style: r, disabled: o, displayLabel: i, label: a, onKeyRenameBlur: s, onRemoveProperty: l, rawDescription: u, readonly: d, required: p, schema: h, hideError: g, rawErrors: y, children: b, uiSchema: v, registry: x } = e, { templates: E, translateString: _ } = x, { RemoveButton: C } = E.ButtonTemplates, k = _(bt.KeyLabel, [a]), R = $a in h, A = !!u, M = ["form-group", n];
    !g && y && y.length > 0 && M.push("has-error has-danger");
    const I = M.join(" ").trim();
    if (!R)
      return S.jsx("div", { className: I, style: r, children: b });
    const D = A ? 46 : 26;
    return S.jsx("div", { className: I, style: r, children: S.jsxs("div", { className: "row", children: [S.jsx("div", { className: "col-xs-5 form-additional", children: S.jsxs("div", { className: "form-group", children: [i && S.jsx($7, { label: k, required: p, id: `${t}-key` }), i && u && S.jsx("div", { children: "" }), S.jsx("input", { className: "form-control", type: "text", id: `${t}-key`, onBlur: s, defaultValue: a })] }) }), S.jsx("div", { className: "form-additional form-group col-xs-5", children: b }), S.jsx("div", { className: "col-xs-2", style: { marginTop: i ? `${D}px` : void 0 }, children: S.jsx(C, { id: $i(t, "remove"), className: "rjsf-object-property-remove btn-block", style: { border: "0" }, disabled: o || d, onClick: l, uiSchema: v, registry: x }) })] }) });
  }
  function nDe() {
    return {
      ArrayFieldDescriptionTemplate: Rje,
      ArrayFieldItemTemplate: Oje,
      ArrayFieldItemButtonsTemplate: Aje,
      ArrayFieldTemplate: Nje,
      ArrayFieldTitleTemplate: Mje,
      ButtonTemplates: zje(),
      BaseInputTemplate: Pje,
      DescriptionFieldTemplate: Bje,
      ErrorListTemplate: Uje,
      FallbackFieldTemplate: Vje,
      FieldTemplate: qje,
      FieldErrorTemplate: Wje,
      FieldHelpTemplate: Gje,
      GridTemplate: Kje,
      MultiSchemaFieldTemplate: Yje,
      ObjectFieldTemplate: Xje,
      OptionalDataControlsTemplate: Zje,
      TitleFieldTemplate: Jje,
      UnsupportedFieldTemplate: eDe,
      WrapIfAdditionalTemplate: tDe
    };
  }
  function rDe(e) {
    const { disabled: t = !1, readonly: n = !1, autofocus: r = !1, options: o, id: i, name: a, registry: s, onBlur: l, onFocus: u } = e, { translateString: d } = s, { elements: p, handleChange: h, handleClear: g, handleSetNow: y } = YPe(e);
    return S.jsxs("ul", { className: "list-inline", children: [p.map((b, v) => S.jsx("li", { className: "list-inline-item", children: S.jsx(KPe, { rootId: i, name: a, select: h, ...b, disabled: t, readonly: n, registry: s, onBlur: l, onFocus: u, autofocus: r && v === 0 }) }, v)), (o.hideNowButton !== "undefined" ? !o.hideNowButton : !0) && S.jsx("li", { className: "list-inline-item", children: S.jsx("a", { href: "#", className: "btn btn-info btn-now", onClick: y, children: d(bt.NowLabel) }) }), (o.hideClearButton !== "undefined" ? !o.hideClearButton : !0) && S.jsx("li", { className: "list-inline-item", children: S.jsx("a", { href: "#", className: "btn btn-warning btn-clear", onClick: g, children: d(bt.ClearLabel) }) })] });
  }
  function oDe({ time: e = !0, ...t }) {
    const { AltDateWidget: n } = t.registry.widgets;
    return S.jsx(n, { time: e, ...t });
  }
  function iDe({ schema: e, uiSchema: t, options: n, id: r, value: o, disabled: i, readonly: a, label: s, hideLabel: l, autofocus: u = !1, onBlur: d, onFocus: p, onChange: h, registry: g, htmlName: y }) {
    const b = et("DescriptionFieldTemplate", g, n), v = Dp(e), x = T.useCallback((A) => h(A.target.checked), [h]), E = T.useCallback((A) => d(r, A.target.checked), [d, r]), _ = T.useCallback((A) => p(r, A.target.checked), [p, r]), R = Ze(t).widget === "checkbox" ? void 0 : n.description ?? e.description;
    return S.jsxs("div", { className: `checkbox ${i || a ? "disabled" : ""}`, children: [!l && R && S.jsx(b, { id: Tc(r), description: R, schema: e, uiSchema: t, registry: g }), S.jsxs("label", { children: [S.jsx("input", { type: "checkbox", id: r, name: y || r, checked: typeof o > "u" ? !1 : o, required: v, disabled: i || a, autoFocus: u, onChange: x, onBlur: E, onFocus: _, "aria-describedby": po(r) }), Rc(S.jsx("span", { children: s }), l)] })] });
  }
  function aDe({ id: e, disabled: t, options: { inline: n = !1, enumOptions: r, enumDisabled: o, emptyValue: i }, value: a, autofocus: s = !1, readonly: l, onChange: u, onBlur: d, onFocus: p, htmlName: h }) {
    const g = Array.isArray(a) ? a : [a], y = T.useCallback(({ target: v }) => d(e, Jn(v && v.value, r, i)), [d, e, r, i]), b = T.useCallback(({ target: v }) => p(e, Jn(v && v.value, r, i)), [p, e, r, i]);
    return S.jsx("div", { className: "checkboxes", id: e, children: Array.isArray(r) && r.map((v, x) => {
      const E = v1(v.value, g), _ = Array.isArray(o) && o.indexOf(v.value) !== -1, C = t || _ || l ? "disabled" : "", k = (A) => {
        A.target.checked ? u(t7(x, g, r)) : u(e7(x, g, r));
      }, R = S.jsxs("span", { children: [S.jsx("input", { type: "checkbox", id: x1(e, x), name: h || e, checked: E, value: String(x), disabled: t || _ || l, autoFocus: s && x === 0, onChange: k, onBlur: y, onFocus: b, "aria-describedby": po(e) }), S.jsx("span", { children: v.label })] });
      return n ? S.jsx("label", { className: `checkbox-inline ${C}`, children: R }, x) : S.jsx("div", { className: `checkbox ${C}`, children: S.jsx("label", { children: R }) }, x);
    }) });
  }
  function sDe(e) {
    const { disabled: t, readonly: n, options: r, registry: o } = e, i = et("BaseInputTemplate", o, r);
    return S.jsx(i, { type: "color", ...e, disabled: t || n });
  }
  function lDe(e) {
    const { onChange: t, options: n, registry: r } = e, o = et("BaseInputTemplate", r, n), i = T.useCallback((a) => t(a || void 0), [t]);
    return S.jsx(o, { type: "date", ...e, onChange: i });
  }
  function cDe(e) {
    const { onChange: t, value: n, options: r, registry: o } = e, i = et("BaseInputTemplate", o, r);
    return S.jsx(i, { type: "datetime-local", ...e, value: e$e(n), onChange: (a) => t(HPe(a)) });
  }
  function uDe(e) {
    const { options: t, registry: n } = e, r = et("BaseInputTemplate", n, t);
    return S.jsx(r, { type: "email", ...e });
  }
  function fDe({ fileInfo: e, registry: t }) {
    const { translateString: n } = t, { dataURL: r, type: o, name: i } = e;
    return r ? ["image/jpeg", "image/png"].includes(o) ? S.jsx("img", { src: r, style: { maxWidth: "100%" }, className: "file-preview" }) : S.jsxs(S.Fragment, { children: [" ", S.jsx("a", { download: `preview-${i}`, href: r, className: "file-download", children: n(bt.PreviewLabel) })] }) : null;
  }
  function dDe({ filesInfo: e, registry: t, preview: n, onRemove: r, options: o }) {
    if (e.length === 0)
      return null;
    const { translateString: i } = t, { RemoveButton: a } = et("ButtonTemplates", t, o);
    return S.jsx("ul", { className: "file-info", children: e.map((s, l) => {
      const { name: u, size: d, type: p } = s, h = () => r(l);
      return S.jsxs("li", { children: [S.jsx(mm, { children: i(bt.FilesInfo, [u, p, String(d)]) }), n && S.jsx(fDe, { fileInfo: s, registry: t }), S.jsx(a, { onClick: h, registry: t })] }, l);
    }) });
  }
  function pDe(e) {
    const { disabled: t, readonly: n, required: r, multiple: o, onChange: i, value: a, options: s, registry: l } = e, { filesInfo: u, handleChange: d, handleRemove: p } = JPe(a, i, o), h = et("BaseInputTemplate", l, s), g = (y) => {
      y.target.files && d(y.target.files);
    };
    return S.jsxs("div", { children: [S.jsx(h, { ...e, disabled: t || n, type: "file", required: a ? !1 : r, onChangeOverride: g, value: "", accept: s.accept ? String(s.accept) : void 0 }), S.jsx(dDe, { filesInfo: u, onRemove: p, registry: l, preview: s.filePreview, options: s })] });
  }
  function hDe({ id: e, value: t, htmlName: n }) {
    return S.jsx("input", { type: "hidden", id: e, name: n || e, value: typeof t > "u" ? "" : t });
  }
  function mDe(e) {
    const { options: t, registry: n } = e, r = et("BaseInputTemplate", n, t);
    return S.jsx(r, { type: "password", ...e });
  }
  function gDe({ options: e, value: t, required: n, disabled: r, readonly: o, autofocus: i = !1, onBlur: a, onFocus: s, onChange: l, id: u, htmlName: d }) {
    const { enumOptions: p, enumDisabled: h, inline: g, emptyValue: y } = e, b = T.useCallback(({ target: x }) => a(u, Jn(x && x.value, p, y)), [a, p, y, u]), v = T.useCallback(({ target: x }) => s(u, Jn(x && x.value, p, y)), [s, p, y, u]);
    return S.jsx("div", { className: "field-radio-group", id: u, role: "radiogroup", children: Array.isArray(p) && p.map((x, E) => {
      const _ = v1(x.value, t), C = Array.isArray(h) && h.indexOf(x.value) !== -1, k = r || C || o ? "disabled" : "", R = () => l(x.value), A = S.jsxs("span", { children: [S.jsx("input", { type: "radio", id: x1(u, E), checked: _, name: d || u, required: n, value: String(E), disabled: r || C || o, autoFocus: i && E === 0, onChange: R, onBlur: b, onFocus: v, "aria-describedby": po(u) }), S.jsx("span", { children: x.label })] });
      return g ? S.jsx("label", { className: `radio-inline ${k}`, children: A }, E) : S.jsx("div", { className: `radio ${k}`, children: S.jsx("label", { children: A }) }, E);
    }) });
  }
  function yDe(e) {
    const { value: t, registry: { templates: { BaseInputTemplate: n } } } = e;
    return S.jsxs("div", { className: "field-range-wrapper", children: [S.jsx(n, { type: "range", ...e }), S.jsx("span", { className: "range-view", children: t })] });
  }
  function vDe({ id: e, value: t, required: n, disabled: r, readonly: o, autofocus: i, onChange: a, onFocus: s, onBlur: l, schema: u, options: d, htmlName: p }) {
    const { stars: h = 5, shape: g = "star" } = d, y = u.maximum ? Math.min(u.maximum, 5) : Math.min(Math.max(h, 1), 5), b = u.minimum || 0, v = T.useCallback((C) => {
      !r && !o && a(C);
    }, [a, r, o]), x = T.useCallback((C) => {
      if (s) {
        const k = Number(C.target.dataset.value);
        s(e, k);
      }
    }, [s, e]), E = T.useCallback((C) => {
      if (l) {
        const k = Number(C.target.dataset.value);
        l(e, k);
      }
    }, [l, e]), _ = (C) => g === "heart" ? C ? "" : "" : C ? "" : "";
    return S.jsx(S.Fragment, { children: S.jsxs("div", { className: "rating-widget", style: {
      display: "inline-flex",
      fontSize: "1.5rem",
      cursor: r || o ? "default" : "pointer"
    }, children: [[...Array(y)].map((C, k) => {
      const R = b + k, A = R <= t;
      return S.jsx("span", { onClick: () => v(R), onFocus: x, onBlur: E, "data-value": R, tabIndex: r || o ? -1 : 0, role: "radio", "aria-checked": R === t, "aria-label": `${R} ${g === "heart" ? "heart" : "star"}${R === 1 ? "" : "s"}`, style: {
        color: A ? "#FFD700" : "#ccc",
        padding: "0 0.2rem",
        transition: "color 0.2s",
        userSelect: "none"
      }, children: _(A) }, k);
    }), S.jsx("input", { type: "hidden", id: e, name: p || e, value: t || "", required: n, disabled: r || o, "aria-hidden": "true" })] }) });
  }
  function Q_(e, t) {
    return t ? Array.from(e.target.options).slice().filter((n) => n.selected).map((n) => n.value) : e.target.value;
  }
  function bDe({ schema: e, id: t, options: n, value: r, required: o, disabled: i, readonly: a, multiple: s = !1, autofocus: l = !1, onChange: u, onBlur: d, onFocus: p, placeholder: h, htmlName: g }) {
    const { enumOptions: y, enumDisabled: b, emptyValue: v } = n, x = s ? [] : "", E = T.useCallback((A) => {
      const M = Q_(A, s);
      return p(t, Jn(M, y, v));
    }, [p, t, s, y, v]), _ = T.useCallback((A) => {
      const M = Q_(A, s);
      return d(t, Jn(M, y, v));
    }, [d, t, s, y, v]), C = T.useCallback((A) => {
      const M = Q_(A, s);
      return u(Jn(M, y, v));
    }, [u, s, y, v]), k = XR(r, y, s), R = !s && e.default === void 0;
    return S.jsxs("select", { id: t, name: g || t, multiple: s, role: "combobox", className: "form-control", value: typeof k > "u" ? x : k, required: o, disabled: i || a, autoFocus: l, onBlur: _, onFocus: E, onChange: C, "aria-describedby": po(t), children: [R && S.jsx("option", { value: "", children: h }), Array.isArray(y) && y.map(({ value: A, label: M }, I) => {
      const D = b && b.indexOf(A) !== -1;
      return S.jsx("option", { value: String(I), disabled: D, children: M }, I);
    })] });
  }
  function j7({ id: e, options: t = {}, placeholder: n, value: r, required: o, disabled: i, readonly: a, autofocus: s = !1, onChange: l, onBlur: u, onFocus: d, htmlName: p }) {
    const h = T.useCallback(({ target: { value: b } }) => l(b === "" ? t.emptyValue : b), [l, t.emptyValue]), g = T.useCallback(({ target: b }) => u(e, b && b.value), [u, e]), y = T.useCallback(({ target: b }) => d(e, b && b.value), [e, d]);
    return S.jsx("textarea", { id: e, name: p || e, className: "form-control", value: r || "", placeholder: n, required: o, disabled: i, readOnly: a, autoFocus: s, rows: t.rows, onBlur: g, onFocus: y, onChange: h, "aria-describedby": po(e) });
  }
  j7.defaultProps = {
    autofocus: !1,
    options: {}
  };
  function xDe(e) {
    const { options: t, registry: n } = e, r = et("BaseInputTemplate", n, t);
    return S.jsx(r, { ...e });
  }
  function wDe(e) {
    const { onChange: t, options: n, registry: r } = e, o = et("BaseInputTemplate", r, n), i = T.useCallback((a) => t(a ? `${a}:00` : void 0), [t]);
    return S.jsx(o, { type: "time", ...e, onChange: i });
  }
  function SDe(e) {
    const { options: t, registry: n } = e, r = et("BaseInputTemplate", n, t);
    return S.jsx(r, { type: "url", ...e });
  }
  function _De(e) {
    const { options: t, registry: n } = e, r = et("BaseInputTemplate", n, t);
    return S.jsx(r, { type: "number", ...e });
  }
  function EDe() {
    return {
      AltDateWidget: rDe,
      AltDateTimeWidget: oDe,
      CheckboxWidget: iDe,
      CheckboxesWidget: aDe,
      ColorWidget: sDe,
      DateWidget: lDe,
      DateTimeWidget: cDe,
      EmailWidget: uDe,
      FileWidget: pDe,
      HiddenWidget: hDe,
      PasswordWidget: mDe,
      RadioWidget: gDe,
      RangeWidget: yDe,
      RatingWidget: vDe,
      SelectWidget: bDe,
      TextWidget: xDe,
      TextareaWidget: j7,
      TimeWidget: wDe,
      UpDownWidget: _De,
      URLWidget: SDe
    };
  }
  function CDe() {
    return {
      fields: Tje(),
      templates: nDe(),
      widgets: EDe(),
      rootSchema: {},
      formContext: {},
      translateString: CPe,
      globalFormOptions: {
        idPrefix: zV,
        idSeparator: BV,
        useFallbackUiForUnsupportedType: !1
      }
    };
  }
  function Ou(e, t) {
    return {
      ...v7(e, ["schema", "uiSchema", "fieldPathId", "schemaUtils", "formData", "edit", "errors", "errorSchema"]),
      ...t !== void 0 && { status: t }
    };
  }
  let kDe = class extends T.Component {
    /** Constructs the `Form` from the `props`. Will setup the initial state from the props. It will also call the
     * `onChange` handler if the initially provided `formData` is modified to add missing default values as part of the
     * state construction.
     *
     * @param props - The initial props for the `Form`
     */
    constructor(n) {
      super(n);
      /** The ref used to hold the `form` element, this needs to be `any` because `tagName` or `_internalFormWrapper` can
       * provide any possible type here
       */
      Wn(this, "formElement");
      /** The list of pending changes
       */
      Wn(this, "pendingChanges", []);
      /** Returns the `formData` with only the elements specified in the `fields` list
       *
       * @param formData - The data for the `Form`
       * @param fields - The fields to keep while filtering
       */
      Wn(this, "getUsedFormData", (n, r) => {
        if (r.length === 0 && typeof n != "object")
          return n;
        const o = v7(n, r);
        return Array.isArray(n) ? Object.keys(o).map((i) => o[i]) : o;
      });
      /** Returns the list of field names from inspecting the `pathSchema` as well as using the `formData`
       *
       * @param pathSchema - The `PathSchema` object for the form
       * @param [formData] - The form data to use while checking for empty objects/arrays
       */
      Wn(this, "getFieldNames", (n, r) => {
        const o = (a, s) => typeof a != "object" || Un(a) || s && !Un(a), i = (a, s = [], l = [[]]) => {
          const u = Object.keys(a);
          return u.forEach((d) => {
            const p = a[d];
            if (typeof p == "object") {
              const h = l.map((g) => [...g, d]);
              p[CR] && p[Ov] !== "" ? s.push(p[Ov]) : i(p, s, h);
            } else d === Ov && p !== "" && l.forEach((h) => {
              const g = Ee(r, h), y = u.length === 1;
              (o(g, y) || Array.isArray(g) && g.every((b) => o(b, y))) && s.push(h);
            });
          }), s;
        };
        return i(n);
      });
      /** Returns the `formData` after filtering to remove any extra data not in a form field
       *
       * @param formData - The data for the `Form`
       * @returns The `formData` after omitting extra data
       */
      Wn(this, "omitExtraData", (n) => {
        const { schema: r, schemaUtils: o } = this.state, i = o.retrieveSchema(r, n), a = o.toPathSchema(i, "", n), s = this.getFieldNames(a, n);
        return this.getUsedFormData(n, s);
      });
      /** Allows a user to set a value for the provided `fieldPath`, which must be either a dotted path to the field OR a
       * `FieldPathList`. To set the root element, used either `''` or `[]` for the path. Passing undefined will clear the
       * value in the field.
       *
       * @param fieldPath - Either a dotted path to the field or the `FieldPathList` to the field
       * @param [newValue] - The new value for the field
       */
      Wn(this, "setFieldValue", (n, r) => {
        const { registry: o } = this.state, i = Array.isArray(n) ? n : n.split("."), a = Mo("", o.globalFormOptions, i);
        this.onChange(r, i, void 0, a[nn]);
      });
      /** Pushes the given change information into the `pendingChanges` array and then calls `processPendingChanges()` if
       * the array only contains a single pending change.
       *
       * @param newValue - The new form data from a change to a field
       * @param path - The path to the change into which to set the formData
       * @param [newErrorSchema] - The new `ErrorSchema` based on the field change
       * @param [id] - The id of the field that caused the change
       */
      Wn(this, "onChange", (n, r, o, i) => {
        this.pendingChanges.push({ newValue: n, path: r, newErrorSchema: o, id: i }), this.pendingChanges.length === 1 && this.processPendingChange();
      });
      /**
       * Callback function to handle reset form data.
       * - Reset all fields with default values.
       * - Reset validations and errors
       *
       */
      Wn(this, "reset", () => {
        const { formData: n, initialFormData: r = q3, onChange: o } = this.props, s = {
          formData: this.getStateFromProps(this.props, n ?? r, void 0, void 0, void 0, !0).formData,
          errorSchema: {},
          errors: [],
          schemaValidationErrors: [],
          schemaValidationErrorSchema: {},
          initialDefaultsGenerated: !1,
          customErrors: void 0
        };
        this.setState(s, () => o && o(Ou({ ...this.state, ...s })));
      });
      /** Callback function to handle when a field on the form is blurred. Calls the `onBlur` callback for the `Form` if it
       * was provided. Also runs any live validation and/or live omit operations if the flags indicate they should happen
       * during `onBlur`.
       *
       * @param id - The unique `id` of the field that was blurred
       * @param data - The data associated with the field that was blurred
       */
      Wn(this, "onBlur", (n, r) => {
        const { onBlur: o, omitExtraData: i, liveOmit: a, liveValidate: s } = this.props;
        if (o && o(n, r), i === !0 && a === "onBlur" || s === "onBlur") {
          const { onChange: l, extraErrors: u } = this.props, { formData: d } = this.state;
          let p = d, h = { formData: p };
          if (i === !0 && a === "onBlur" && (p = this.omitExtraData(d), h = { formData: p }), s === "onBlur") {
            const { schema: y, schemaUtils: b, errorSchema: v, customErrors: x, retrievedSchema: E } = this.state, _ = this.liveValidate(y, b, v, p, u, x, E);
            h = { formData: p, ..._, customErrors: x };
          }
          const g = Object.keys(h).filter((y) => !y.startsWith("schemaValidation")).some((y) => {
            const b = Ee(this.state, y), v = Ee(h, y);
            return !fn(b, v);
          });
          this.setState(h, () => {
            l && g && l(Ou({ ...this.state, ...h }), n);
          });
        }
      });
      /** Callback function to handle when a field on the form is focused. Calls the `onFocus` callback for the `Form` if it
       * was provided.
       *
       * @param id - The unique `id` of the field that was focused
       * @param data - The data associated with the field that was focused
       */
      Wn(this, "onFocus", (n, r) => {
        const { onFocus: o } = this.props;
        o && o(n, r);
      });
      /** Callback function to handle when the form is submitted. First, it prevents the default event behavior. Nothing
       * happens if the target and currentTarget of the event are not the same. It will omit any extra data in the
       * `formData` in the state if `omitExtraData` is true. It will validate the resulting `formData`, reporting errors
       * via the `onError()` callback unless validation is disabled. Finally, it will add in any `extraErrors` and then call
       * back the `onSubmit` callback if it was provided.
       *
       * @param event - The submit HTML form event
       */
      Wn(this, "onSubmit", (n) => {
        if (n.preventDefault(), n.target !== n.currentTarget)
          return;
        n.persist();
        const { omitExtraData: r, extraErrors: o, noValidate: i, onSubmit: a } = this.props;
        let { formData: s } = this.state;
        if (r === !0 && (s = this.omitExtraData(s)), i || this.validateFormWithFormData(s)) {
          const l = o || {}, u = o ? nO(o) : [];
          this.setState({
            formData: s,
            errors: u,
            errorSchema: l,
            schemaValidationErrors: [],
            schemaValidationErrorSchema: {}
          }, () => {
            a && a(Ou({ ...this.state, formData: s }, "submitted"), n);
          });
        }
      });
      /** Provides a function that can be used to programmatically submit the `Form` */
      Wn(this, "submit", () => {
        if (this.formElement.current) {
          const n = new CustomEvent("submit", {
            cancelable: !0
          });
          n.preventDefault(), this.formElement.current.dispatchEvent(n), this.formElement.current.requestSubmit();
        }
      });
      /** Validates the form using the given `formData`. For use on form submission or on programmatic validation.
       * If `onError` is provided, then it will be called with the list of errors.
       *
       * @param formData - The form data to validate
       * @returns - True if the form is valid, false otherwise.
       */
      Wn(this, "validateFormWithFormData", (n) => {
        const { extraErrors: r, extraErrorsBlockSubmit: o, focusOnFirstError: i, onError: a } = this.props, { errors: s } = this.state, l = this.validate(n);
        let u = l.errors, d = l.errorSchema;
        const p = u, h = d, g = u.length > 0 || r && o;
        if (g) {
          if (r) {
            const y = $v(l, r);
            d = y.errorSchema, u = y.errors;
          }
          i && (typeof i == "function" ? i(u[0]) : this.focusOnError(u[0])), this.setState({
            errors: u,
            errorSchema: d,
            schemaValidationErrors: p,
            schemaValidationErrorSchema: h
          }, () => {
            a ? a(u) : console.error("Form validation failed", u);
          });
        } else s.length > 0 && this.setState({
          errors: [],
          errorSchema: {},
          schemaValidationErrors: [],
          schemaValidationErrorSchema: {}
        });
        return !g;
      });
      if (!n.validator)
        throw new Error("A validator is required for Form functionality to work");
      const { formData: r, initialFormData: o, onChange: i } = n, a = r ?? o;
      this.state = this.getStateFromProps(n, a, void 0, void 0, void 0, !0), i && !fn(this.state.formData, a) && i(Ou(this.state)), this.formElement = T.createRef();
    }
    /**
     * `getSnapshotBeforeUpdate` is a React lifecycle method that is invoked right before the most recently rendered
     * output is committed to the DOM. It enables your component to capture current values (e.g., scroll position) before
     * they are potentially changed.
     *
     * In this case, it checks if the props have changed since the last render. If they have, it computes the next state
     * of the component using `getStateFromProps` method and returns it along with a `shouldUpdate` flag set to `true` IF
     * the `nextState` and `prevState` are different, otherwise `false`. This ensures that we have the most up-to-date
     * state ready to be applied in `componentDidUpdate`.
     *
     * If `formData` hasn't changed, it simply returns an object with `shouldUpdate` set to `false`, indicating that a
     * state update is not necessary.
     *
     * @param prevProps - The previous set of props before the update.
     * @param prevState - The previous state before the update.
     * @returns Either an object containing the next state and a flag indicating that an update should occur, or an object
     *        with a flag indicating that an update is not necessary.
     */
    getSnapshotBeforeUpdate(n, r) {
      if (!fn(this.props, n)) {
        const o = XD(this.props.formData, n.formData), i = XD(this.props.formData, this.state.formData), a = !fn(n.schema, this.props.schema), s = o.length > 0 || !fn(n.formData, this.props.formData), l = i.length > 0 || !fn(this.state.formData, this.props.formData), u = this.getStateFromProps(
          this.props,
          this.props.formData,
          // If the `schema` has changed, we need to update the retrieved schema.
          // Or if the `formData` changes, for example in the case of a schema with dependencies that need to
          //  match one of the subSchemas, the retrieved schema must be updated.
          a || s ? void 0 : this.state.retrievedSchema,
          a,
          o,
          // Skip live validation for this request if no form data has changed from the last state
          !l
        ), d = !fn(u, r);
        return { nextState: u, shouldUpdate: d };
      }
      return { shouldUpdate: !1 };
    }
    /**
     * `componentDidUpdate` is a React lifecycle method that is invoked immediately after updating occurs. This method is
     * not called for the initial render.
     *
     * Here, it checks if an update is necessary based on the `shouldUpdate` flag received from `getSnapshotBeforeUpdate`.
     * If an update is required, it applies the next state and, if needed, triggers the `onChange` handler to inform about
     * changes.
     *
     * @param _ - The previous set of props.
     * @param prevState - The previous state of the component before the update.
     * @param snapshot - The value returned from `getSnapshotBeforeUpdate`.
     */
    componentDidUpdate(n, r, o) {
      if (o.shouldUpdate) {
        const { nextState: i } = o;
        !fn(i.formData, this.props.formData) && !fn(i.formData, r.formData) && this.props.onChange && this.props.onChange(Ou(i)), this.setState(i);
      }
    }
    /** Extracts the updated state from the given `props` and `inputFormData`. As part of this process, the
     * `inputFormData` is first processed to add any missing required defaults. After that, the data is run through the
     * validation process IF required by the `props`.
     *
     * @param props - The props passed to the `Form`
     * @param inputFormData - The new or current data for the `Form`
     * @param retrievedSchema - An expanded schema, if not provided, it will be retrieved from the `schema` and `formData`.
     * @param isSchemaChanged - A flag indicating whether the schema has changed.
     * @param formDataChangedFields - The changed fields of `formData`
     * @param skipLiveValidate - Optional flag, if true, means that we are not running live validation
     * @returns - The new state for the `Form`
     */
    getStateFromProps(n, r, o, i = !1, a = [], s = !1) {
      const l = this.state || {}, u = "schema" in n ? n.schema : this.props.schema, d = "validator" in n ? n.validator : this.props.validator, p = ("uiSchema" in n ? n.uiSchema : this.props.uiSchema) || {}, h = n.formData === void 0 && this.props.formData === void 0, g = typeof r < "u", y = "liveValidate" in n ? n.liveValidate : this.props.liveValidate, b = g && !n.noValidate && y, v = "experimental_defaultFormStateBehavior" in n ? n.experimental_defaultFormStateBehavior : this.props.experimental_defaultFormStateBehavior, x = "experimental_customMergeAllOf" in n ? n.experimental_customMergeAllOf : this.props.experimental_customMergeAllOf;
      let E = l.schemaUtils;
      (!E || E.doesSchemaUtilsDiffer(d, u, v, x)) && (E = SPe(d, u, v, x));
      const _ = E.getRootSchema();
      let C = r;
      r === q3 ? C = void 0 : r === void 0 && h && (C = l.formData);
      const k = E.getDefaultFormState(_, C, !1, l.initialDefaultsGenerated), R = this.updateRetrievedSchema(o ?? E.retrieveSchema(_, k)), A = () => n.noValidate || i ? { errors: [], errorSchema: {} } : n.liveValidate ? {
        errors: l.errors || [],
        errorSchema: l.errorSchema || {}
      } : {
        errors: l.schemaValidationErrors || [],
        errorSchema: l.schemaValidationErrorSchema || {}
      };
      let M, I, D = l.schemaValidationErrors, L = l.schemaValidationErrorSchema;
      if (b && !s) {
        const F = this.liveValidate(
          _,
          E,
          l.errorSchema,
          k,
          void 0,
          l.customErrors,
          o,
          // If retrievedSchema is undefined which means the schema or formData has changed, we do not merge state.
          // Else in the case where it hasn't changed,
          o !== void 0
        );
        M = F.errors, I = F.errorSchema, D = F.schemaValidationErrors, L = F.schemaValidationErrorSchema;
      } else {
        const F = A();
        if (M = F.errors, I = F.errorSchema, a.length > 0 && !b) {
          const W = a.reduce((K, $) => (K[$] = void 0, K), {});
          I = L = _h(F.errorSchema, W, "preventDuplicates");
        }
        const G = this.mergeErrors({ errorSchema: I, errors: M }, n.extraErrors, l.customErrors);
        M = G.errors, I = G.errorSchema;
      }
      const P = this.getRegistry(n, _, E), B = fn(l.registry, P) ? l.registry : P, j = l.fieldPathId && l.fieldPathId?.[nn] === B.globalFormOptions.idPrefix ? l.fieldPathId : Mo("", B.globalFormOptions);
      return {
        schemaUtils: E,
        schema: _,
        uiSchema: p,
        fieldPathId: j,
        formData: k,
        edit: g,
        errors: M,
        errorSchema: I,
        schemaValidationErrors: D,
        schemaValidationErrorSchema: L,
        retrievedSchema: R,
        initialDefaultsGenerated: !0,
        registry: B
      };
    }
    /** React lifecycle method that is used to determine whether component should be updated.
     *
     * @param nextProps - The next version of the props
     * @param nextState - The next version of the state
     * @returns - True if the component should be updated, false otherwise
     */
    shouldComponentUpdate(n, r) {
      const { experimental_componentUpdateStrategy: o = "customDeep" } = this.props;
      return l7(this, n, r, o);
    }
    /** Validates the `formData` against the `schema` using the `altSchemaUtils` (if provided otherwise it uses the
     * `schemaUtils` in the state), returning the results.
     *
     * @param formData - The new form data to validate
     * @param schema - The schema used to validate against
     * @param [altSchemaUtils] - The alternate schemaUtils to use for validation
     * @param [retrievedSchema] - An optionally retrieved schema for per
     */
    validate(n, r = this.state.schema, o, i) {
      const a = o || this.state.schemaUtils, { customValidate: s, transformErrors: l, uiSchema: u } = this.props, d = i ?? a.retrieveSchema(r, n);
      return a.getValidator().validateFormData(n, d, s, l, u);
    }
    /** Renders any errors contained in the `state` in using the `ErrorList`, if not disabled by `showErrorList`. */
    renderErrors(n) {
      const { errors: r, errorSchema: o, schema: i, uiSchema: a } = this.state, s = Ze(a), l = et("ErrorListTemplate", n, s);
      return r && r.length ? S.jsx(l, { errors: r, errorSchema: o || {}, schema: i, uiSchema: a, registry: n }) : null;
    }
    /** Merges any `extraErrors` or `customErrors` into the given `schemaValidation` object, returning the result
     *
     * @param schemaValidation - The `ValidationData` object into which additional errors are merged
     * @param [extraErrors] - The extra errors from the props
     * @param [customErrors] - The customErrors from custom components
     * @return - The `extraErrors` and `customErrors` merged into the `schemaValidation`
     * @private
     */
    mergeErrors(n, r, o) {
      let i = n.errorSchema, a = n.errors;
      if (r) {
        const s = $v(n, r);
        i = s.errorSchema, a = s.errors;
      }
      if (o) {
        const s = $v(n, o.ErrorSchema, !0);
        i = s.errorSchema, a = s.errors;
      }
      return { errors: a, errorSchema: i };
    }
    /** Performs live validation and then updates and returns the errors and error schemas by potentially merging in
     * `extraErrors` and `customErrors`.
     *
     * @param rootSchema - The `rootSchema` from the state
     * @param schemaUtils - The `SchemaUtilsType` from the state
     * @param originalErrorSchema - The original `ErrorSchema` from the state
     * @param [formData] - The new form data to validate
     * @param [extraErrors] - The extra errors from the props
     * @param [customErrors] - The customErrors from custom components
     * @param [retrievedSchema] - An expanded schema, if not provided, it will be retrieved from the `schema` and `formData`
     * @param [mergeIntoOriginalErrorSchema=false] - Optional flag indicating whether we merge into original schema
     * @returns - An object containing `errorSchema`, `errors`, `schemaValidationErrors` and `schemaValidationErrorSchema`
     * @private
     */
    liveValidate(n, r, o, i, a, s, l, u = !1) {
      const d = this.validate(i, n, r, l), p = d.errors;
      let h = d.errorSchema;
      u && (h = _h(o, d.errorSchema, "preventDuplicates"));
      const g = p, y = h;
      return { ...this.mergeErrors({ errorSchema: h, errors: p }, a, s), schemaValidationErrors: g, schemaValidationErrorSchema: y };
    }
    /** Function to handle changes made to a field in the `Form`. This handler gets the first change from the
     * `pendingChanges` list, containing the `newValue` for the `formData` and the `path` at which the `newValue` is to be
     * updated, along with a new, optional `ErrorSchema` for that same `path` and potentially the `id` of the field being
     * changed. It will first update the `formData` with any missing default fields and then, if `omitExtraData` and
     * `liveOmit` are turned on, the `formData` will be filtered to remove any extra data not in a form field. Then, the
     * resulting `formData` will be validated if required. The state will be updated with the new updated (potentially
     * filtered) `formData`, any errors that resulted from validation. Finally the `onChange` callback will be called, if
     * specified, with the updated state and the `processPendingChange()` function is called again.
     */
    processPendingChange() {
      if (this.pendingChanges.length === 0)
        return;
      const { newValue: n, path: r, id: o } = this.pendingChanges[0], { newErrorSchema: i } = this.pendingChanges[0], { extraErrors: a, omitExtraData: s, liveOmit: l, noValidate: u, liveValidate: d, onChange: p } = this.props, { formData: h, schemaUtils: g, schema: y, fieldPathId: b, schemaValidationErrorSchema: v, errors: x } = this.state;
      let { customErrors: E, errorSchema: _ } = this.state;
      const C = b.path[0] || "", k = !r || r.length === 0 || r.length === 1 && r[0] === C;
      let R = this.state.retrievedSchema, A = k ? n : ZR(h);
      if (Rt(A) || Array.isArray(A)) {
        n === M7 ? k2e(A, r) : k || Xt(A, r, n);
        const L = this.getStateFromProps(this.props, A, void 0, void 0, void 0, !0);
        A = L.formData, R = L.retrievedSchema;
      }
      const M = !u && (d === !0 || d === "onChange");
      let I = { formData: A, schema: y }, D = A;
      if (s === !0 && (l === !0 || l === "onChange") && (D = this.omitExtraData(A), I = {
        formData: D
      }), i) {
        const L = k ? v : Ee(v, r);
        if (!Un(L))
          k ? _ = i : Xt(_, r, i);
        else if (E || (E = new n7()), k) {
          const P = Ee(i, lr);
          P && E.setErrors(P);
        } else
          Xt(E.ErrorSchema, r, i);
      } else E && Ee(E.ErrorSchema, [...r, lr]) && E.clearErrors(r);
      if (M && this.pendingChanges.length === 1) {
        const L = this.liveValidate(y, g, _, D, a, E, R);
        I = { formData: D, ...L, customErrors: E };
      } else if (!u && i) {
        const L = this.mergeErrors({ errorSchema: _, errors: x }, a, E);
        I = {
          formData: D,
          ...L,
          customErrors: E
        };
      }
      this.setState(I, () => {
        p && p(Ou({ ...this.state, ...I }), o), this.pendingChanges.shift(), this.processPendingChange();
      });
    }
    /**
     * If the retrievedSchema has changed the new retrievedSchema is returned.
     * Otherwise, the old retrievedSchema is returned to persist reference.
     * -  This ensures that AJV retrieves the schema from the cache when it has not changed,
     *    avoiding the performance cost of recompiling the schema.
     *
     * @param retrievedSchema The new retrieved schema.
     * @returns The new retrieved schema if it has changed, else the old retrieved schema.
     */
    updateRetrievedSchema(n) {
      return fn(n, this.state?.retrievedSchema) ? this.state.retrievedSchema : n;
    }
    /** Extracts the `GlobalFormOptions` from the given Form `props`
     *
     * @param props - The form props to extract the global form options from
     * @returns - The `GlobalFormOptions` from the props
     * @private
     */
    getGlobalFormOptions(n) {
      const { uiSchema: r = {}, experimental_componentUpdateStrategy: o, idSeparator: i = BV, idPrefix: a = zV, nameGenerator: s, useFallbackUiForUnsupportedType: l = !1 } = n;
      return {
        idPrefix: r["ui:rootFieldId"] || a,
        idSeparator: i,
        useFallbackUiForUnsupportedType: l,
        ...o !== void 0 && { experimental_componentUpdateStrategy: o },
        ...s !== void 0 && { nameGenerator: s }
      };
    }
    /** Computed the registry for the form using the given `props`, `schema` and `schemaUtils` */
    getRegistry(n, r, o) {
      const { translateString: i, uiSchema: a = {} } = n, { fields: s, templates: l, widgets: u, formContext: d, translateString: p } = CDe();
      return {
        fields: { ...s, ...n.fields },
        templates: {
          ...l,
          ...n.templates,
          ButtonTemplates: {
            ...l.ButtonTemplates,
            ...n.templates?.ButtonTemplates
          }
        },
        widgets: { ...u, ...n.widgets },
        rootSchema: r,
        formContext: n.formContext || d,
        schemaUtils: o,
        translateString: i || p,
        globalUiOptions: a[OC],
        globalFormOptions: this.getGlobalFormOptions(n)
      };
    }
    /** Attempts to focus on the field associated with the `error`. Uses the `property` field to compute path of the error
     * field, then, using the `idPrefix` and `idSeparator` converts that path into an id. Then the input element with that
     * id is attempted to be found using the `formElement` ref. If it is located, then it is focused.
     *
     * @param error - The error on which to focus
     */
    focusOnError(n) {
      const { idPrefix: r = "root", idSeparator: o = "_" } = this.props, { property: i } = n, a = c7(i);
      a[0] === "" ? a[0] = r : a.unshift(r);
      const s = a.join(o);
      let l = this.formElement.current.elements[s];
      l || (l = this.formElement.current.querySelector(`input[id^="${s}"`)), l && l.length && (l = l[0]), l && l.focus();
    }
    /** Programmatically validate the form.  If `omitExtraData` is true, the `formData` will first be filtered to remove
     * any extra data not in a form field. If `onError` is provided, then it will be called with the list of errors the
     * same way as would happen on form submission.
     *
     * @returns - True if the form is valid, false otherwise.
     */
    validateForm() {
      const { omitExtraData: n } = this.props;
      let { formData: r } = this.state;
      return n === !0 && (r = this.omitExtraData(r)), this.validateFormWithFormData(r);
    }
    /** Renders the `Form` fields inside the <form> | `tagName` or `_internalFormWrapper`, rendering any errors if
     * needed along with the submit button or any children of the form.
     */
    render() {
      const { children: n, id: r, className: o = "", tagName: i, name: a, method: s, target: l, action: u, autoComplete: d, enctype: p, acceptCharset: h, noHtml5Validate: g = !1, disabled: y, readonly: b, showErrorList: v = "top", _internalFormWrapper: x } = this.props, { schema: E, uiSchema: _, formData: C, errorSchema: k, fieldPathId: R, registry: A } = this.state, { SchemaField: M } = A.fields, { SubmitButton: I } = A.templates.ButtonTemplates, D = x ? i : void 0, L = x || i || "form";
      let { [A0]: P = {} } = Ze(_);
      y && (P = { ...P, props: { ...P.props, disabled: !0 } });
      const B = { [Gs]: { [A0]: P } };
      return S.jsxs(L, { className: o || "rjsf", id: r, name: a, method: s, target: l, action: u, autoComplete: d, encType: p, acceptCharset: h, noValidate: g, onSubmit: this.onSubmit, as: D, ref: this.formElement, children: [v === "top" && this.renderErrors(A), S.jsx(M, { name: "", schema: E, uiSchema: _, errorSchema: k, fieldPathId: R, formData: C, onChange: this.onChange, onBlur: this.onBlur, onFocus: this.onFocus, registry: A, disabled: y, readonly: b }), n || S.jsx(I, { uiSchema: B, registry: A }), v === "bottom" && this.renderErrors(A)] });
    }
  };
  function D7(e) {
    return T.forwardRef(({ fields: t, widgets: n, templates: r, ...o }, i) => (t = { ...e?.fields, ...t }, n = { ...e?.widgets, ...n }, r = {
      ...e?.templates,
      ...r,
      ButtonTemplates: {
        ...e?.templates?.ButtonTemplates,
        ...r?.ButtonTemplates
      }
    }, S.jsx(kDe, { ...e, ...o, fields: t, widgets: n, templates: r, ref: i })));
  }
  function HC(...e) {
    return e.reduce((t, n) => n == null ? t : function(...o) {
      t.apply(this, o), n.apply(this, o);
    }, () => {
    });
  }
  function F7(e, t = 166) {
    let n;
    function r(...o) {
      const i = () => {
        e.apply(this, o);
      };
      clearTimeout(n), n = setTimeout(i, t);
    }
    return r.clear = () => {
      clearTimeout(n);
    }, r;
  }
  function Rr(e) {
    return e && e.ownerDocument || document;
  }
  function qa(e) {
    return Rr(e).defaultView || window;
  }
  function W3(e, t) {
    typeof e == "function" ? e(t) : e && (e.current = t);
  }
  function Ch(e) {
    const {
      controlled: t,
      default: n,
      name: r,
      state: o = "value"
    } = e, {
      current: i
    } = T.useRef(t !== void 0), [a, s] = T.useState(n), l = i ? t : a, u = T.useCallback((d) => {
      i || s(d);
    }, []);
    return [l, u];
  }
  function TDe(e, t) {
    const n = e.charCodeAt(2);
    return e[0] === "o" && e[1] === "n" && n >= 65 && n <= 90 && typeof t == "function";
  }
  function L7(e, t) {
    if (!e)
      return t;
    function n(a, s) {
      const l = {};
      return Object.keys(s).forEach((u) => {
        TDe(u, s[u]) && typeof a[u] == "function" && (l[u] = (...d) => {
          a[u](...d), s[u](...d);
        });
      }), l;
    }
    if (typeof e == "function" || typeof t == "function")
      return (a) => {
        const s = typeof t == "function" ? t(a) : t, l = typeof e == "function" ? e({
          ...a,
          ...s
        }) : e, u = je(a?.className, s?.className, l?.className), d = n(l, s);
        return {
          ...s,
          ...l,
          ...d,
          ...!!u && {
            className: u
          },
          ...s?.style && l?.style && {
            style: {
              ...s.style,
              ...l.style
            }
          },
          ...s?.sx && l?.sx && {
            sx: [...Array.isArray(s.sx) ? s.sx : [s.sx], ...Array.isArray(l.sx) ? l.sx : [l.sx]]
          }
        };
      };
    const r = t, o = n(e, r), i = je(r?.className, e?.className);
    return {
      ...t,
      ...e,
      ...o,
      ...!!i && {
        className: i
      },
      ...r?.style && e?.style && {
        style: {
          ...r.style,
          ...e.style
        }
      },
      ...r?.sx && e?.sx && {
        sx: [...Array.isArray(r.sx) ? r.sx : [r.sx], ...Array.isArray(e.sx) ? e.sx : [e.sx]]
      }
    };
  }
  const z7 = co(/* @__PURE__ */ S.jsx("path", {
    d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z"
  }));
  function RDe(e) {
    return typeof e.main == "string";
  }
  function ODe(e, t = []) {
    if (!RDe(e))
      return !1;
    for (const n of t)
      if (!e.hasOwnProperty(n) || typeof e[n] != "string")
        return !1;
    return !0;
  }
  function xr(e = []) {
    return ([, t]) => t && ODe(t, e);
  }
  function ADe(e) {
    return it("MuiCircularProgress", e);
  }
  rt("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "track", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
  const zo = 44, qC = _f`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`, WC = _f`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: -126px;
  }
`, NDe = typeof qC != "string" ? Ph`
        animation: ${qC} 1.4s linear infinite;
      ` : null, MDe = typeof WC != "string" ? Ph`
        animation: ${WC} 1.4s ease-in-out infinite;
      ` : null, PDe = (e) => {
    const {
      classes: t,
      variant: n,
      color: r,
      disableShrink: o
    } = e, i = {
      root: ["root", n, `color${$e(r)}`],
      svg: ["svg"],
      track: ["track"],
      circle: ["circle", `circle${$e(n)}`, o && "circleDisableShrink"]
    };
    return ot(i, ADe, t);
  }, $De = Oe("span", {
    name: "MuiCircularProgress",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[n.variant], t[`color${$e(n.color)}`]];
    }
  })(at(({
    theme: e
  }) => ({
    display: "inline-block",
    variants: [{
      props: {
        variant: "determinate"
      },
      style: {
        transition: e.transitions.create("transform")
      }
    }, {
      props: {
        variant: "indeterminate"
      },
      style: NDe || {
        animation: `${qC} 1.4s linear infinite`
      }
    }, ...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        color: (e.vars || e).palette[t].main
      }
    }))]
  }))), IDe = Oe("svg", {
    name: "MuiCircularProgress",
    slot: "Svg"
  })({
    display: "block"
    // Keeps the progress centered
  }), jDe = Oe("circle", {
    name: "MuiCircularProgress",
    slot: "Circle",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.circle, t[`circle${$e(n.variant)}`], n.disableShrink && t.circleDisableShrink];
    }
  })(at(({
    theme: e
  }) => ({
    stroke: "currentColor",
    variants: [{
      props: {
        variant: "determinate"
      },
      style: {
        transition: e.transitions.create("stroke-dashoffset")
      }
    }, {
      props: {
        variant: "indeterminate"
      },
      style: {
        // Some default value that looks fine waiting for the animation to kicks in.
        strokeDasharray: "80px, 200px",
        strokeDashoffset: 0
        // Add the unit to fix a Edge 16 and below bug.
      }
    }, {
      props: ({
        ownerState: t
      }) => t.variant === "indeterminate" && !t.disableShrink,
      style: MDe || {
        // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.
        animation: `${WC} 1.4s ease-in-out infinite`
      }
    }]
  }))), DDe = Oe("circle", {
    name: "MuiCircularProgress",
    slot: "Track"
  })(at(({
    theme: e
  }) => ({
    stroke: "currentColor",
    opacity: (e.vars || e).palette.action.activatedOpacity
  }))), B7 = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiCircularProgress"
    }), {
      className: o,
      color: i = "primary",
      disableShrink: a = !1,
      enableTrackSlot: s = !1,
      size: l = 40,
      style: u,
      thickness: d = 3.6,
      value: p = 0,
      variant: h = "indeterminate",
      ...g
    } = r, y = {
      ...r,
      color: i,
      disableShrink: a,
      size: l,
      thickness: d,
      value: p,
      variant: h,
      enableTrackSlot: s
    }, b = PDe(y), v = {}, x = {}, E = {};
    if (h === "determinate") {
      const _ = 2 * Math.PI * ((zo - d) / 2);
      v.strokeDasharray = _.toFixed(3), E["aria-valuenow"] = Math.round(p), v.strokeDashoffset = `${((100 - p) / 100 * _).toFixed(3)}px`, x.transform = "rotate(-90deg)";
    }
    return /* @__PURE__ */ S.jsx($De, {
      className: je(b.root, o),
      style: {
        width: l,
        height: l,
        ...x,
        ...u
      },
      ownerState: y,
      ref: n,
      role: "progressbar",
      ...E,
      ...g,
      children: /* @__PURE__ */ S.jsxs(IDe, {
        className: b.svg,
        ownerState: y,
        viewBox: `${zo / 2} ${zo / 2} ${zo} ${zo}`,
        children: [s ? /* @__PURE__ */ S.jsx(DDe, {
          className: b.track,
          ownerState: y,
          cx: zo,
          cy: zo,
          r: (zo - d) / 2,
          fill: "none",
          strokeWidth: d,
          "aria-hidden": "true"
        }) : null, /* @__PURE__ */ S.jsx(jDe, {
          className: b.circle,
          style: v,
          ownerState: y,
          cx: zo,
          cy: zo,
          r: (zo - d) / 2,
          fill: "none",
          strokeWidth: d
        })]
      })
    });
  });
  function FDe(e) {
    return it("MuiIconButton", e);
  }
  const G3 = rt("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge", "loading", "loadingIndicator", "loadingWrapper"]), LDe = (e) => {
    const {
      classes: t,
      disabled: n,
      color: r,
      edge: o,
      size: i,
      loading: a
    } = e, s = {
      root: ["root", a && "loading", n && "disabled", r !== "default" && `color${$e(r)}`, o && `edge${$e(o)}`, `size${$e(i)}`],
      loadingIndicator: ["loadingIndicator"],
      loadingWrapper: ["loadingWrapper"]
    };
    return ot(s, FDe, t);
  }, zDe = Oe(Ih, {
    name: "MuiIconButton",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.loading && t.loading, n.color !== "default" && t[`color${$e(n.color)}`], n.edge && t[`edge${$e(n.edge)}`], t[`size${$e(n.size)}`]];
    }
  })(at(({
    theme: e
  }) => ({
    textAlign: "center",
    flex: "0 0 auto",
    fontSize: e.typography.pxToRem(24),
    padding: 8,
    borderRadius: "50%",
    color: (e.vars || e).palette.action.active,
    transition: e.transitions.create("background-color", {
      duration: e.transitions.duration.shortest
    }),
    variants: [{
      props: (t) => !t.disableRipple,
      style: {
        "--IconButton-hoverBg": e.alpha((e.vars || e).palette.action.active, (e.vars || e).palette.action.hoverOpacity),
        "&:hover": {
          backgroundColor: "var(--IconButton-hoverBg)",
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }
      }
    }, {
      props: {
        edge: "start"
      },
      style: {
        marginLeft: -12
      }
    }, {
      props: {
        edge: "start",
        size: "small"
      },
      style: {
        marginLeft: -3
      }
    }, {
      props: {
        edge: "end"
      },
      style: {
        marginRight: -12
      }
    }, {
      props: {
        edge: "end",
        size: "small"
      },
      style: {
        marginRight: -3
      }
    }]
  })), at(({
    theme: e
  }) => ({
    variants: [{
      props: {
        color: "inherit"
      },
      style: {
        color: "inherit"
      }
    }, ...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        color: (e.vars || e).palette[t].main
      }
    })), ...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        "--IconButton-hoverBg": e.alpha((e.vars || e).palette[t].main, (e.vars || e).palette.action.hoverOpacity)
      }
    })), {
      props: {
        size: "small"
      },
      style: {
        padding: 5,
        fontSize: e.typography.pxToRem(18)
      }
    }, {
      props: {
        size: "large"
      },
      style: {
        padding: 12,
        fontSize: e.typography.pxToRem(28)
      }
    }],
    [`&.${G3.disabled}`]: {
      backgroundColor: "transparent",
      color: (e.vars || e).palette.action.disabled
    },
    [`&.${G3.loading}`]: {
      color: "transparent"
    }
  }))), BDe = Oe("span", {
    name: "MuiIconButton",
    slot: "LoadingIndicator"
  })(({
    theme: e
  }) => ({
    display: "none",
    position: "absolute",
    visibility: "visible",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    color: (e.vars || e).palette.action.disabled,
    variants: [{
      props: {
        loading: !0
      },
      style: {
        display: "flex"
      }
    }]
  })), U7 = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiIconButton"
    }), {
      edge: o = !1,
      children: i,
      className: a,
      color: s = "default",
      disabled: l = !1,
      disableFocusRipple: u = !1,
      size: d = "medium",
      id: p,
      loading: h = null,
      loadingIndicator: g,
      ...y
    } = r, b = Ef(p), v = g ?? /* @__PURE__ */ S.jsx(B7, {
      "aria-labelledby": b,
      color: "inherit",
      size: 16
    }), x = {
      ...r,
      edge: o,
      color: s,
      disabled: l,
      disableFocusRipple: u,
      loading: h,
      loadingIndicator: v,
      size: d
    }, E = LDe(x);
    return /* @__PURE__ */ S.jsxs(zDe, {
      id: h ? b : p,
      className: je(E.root, a),
      centerRipple: !0,
      focusRipple: !u,
      disabled: l || h,
      ref: n,
      ...y,
      ownerState: x,
      children: [typeof h == "boolean" && // use plain HTML span to minimize the runtime overhead
      /* @__PURE__ */ S.jsx("span", {
        className: E.loadingWrapper,
        style: {
          display: "contents"
        },
        children: /* @__PURE__ */ S.jsx(BDe, {
          className: E.loadingIndicator,
          ownerState: x,
          children: h && v
        })
      }), i]
    });
  });
  function UDe({ uiSchema: e, registry: t, ...n }) {
    const { translateString: r } = t;
    return S.jsx(U7, { title: r(bt.AddItemButton), ...n, color: "primary", children: S.jsx(z7, {}) });
  }
  function VDe({
    theme: e,
    ...t
  }) {
    const n = Fi in e ? e[Fi] : void 0;
    return /* @__PURE__ */ S.jsx(rF, {
      ...t,
      themeId: n ? Fi : void 0,
      theme: n || e
    });
  }
  const ev = {
    colorSchemeStorageKey: "mui-color-scheme",
    defaultLightColorScheme: "light",
    defaultDarkColorScheme: "dark",
    modeStorageKey: "mui-mode"
  }, {
    CssVarsProvider: HDe
  } = EX({
    themeId: Fi,
    // @ts-ignore ignore module augmentation tests
    theme: () => rb({
      cssVariables: !0
    }),
    colorSchemeStorageKey: ev.colorSchemeStorageKey,
    modeStorageKey: ev.modeStorageKey,
    defaultColorScheme: {
      light: ev.defaultLightColorScheme,
      dark: ev.defaultDarkColorScheme
    },
    resolveTheme: (e) => {
      const t = {
        ...e,
        typography: lF(e.palette, e.typography)
      };
      return t.unstable_sx = function(r) {
        return Xs({
          sx: r,
          theme: this
        });
      }, t;
    }
  }), qDe = HDe;
  function WDe({
    theme: e,
    ...t
  }) {
    const n = T.useMemo(() => {
      if (typeof e == "function")
        return e;
      const r = Fi in e ? e[Fi] : e;
      return "colorSchemes" in r ? null : "vars" in r ? e : {
        ...e,
        vars: null
      };
    }, [e]);
    return n ? /* @__PURE__ */ S.jsx(VDe, {
      theme: n,
      ...t
    }) : /* @__PURE__ */ S.jsx(qDe, {
      theme: e,
      ...t
    });
  }
  const GDe = rt("MuiBox", ["root"]), KDe = rb(), sl = VY({
    themeId: Fi,
    defaultTheme: KDe,
    defaultClassName: GDe.root,
    generateClassName: K4.generate
  }), cr = qX({
    createStyledComponent: Oe("div", {
      name: "MuiGrid",
      slot: "Root",
      overridesResolver: (e, t) => {
        const {
          ownerState: n
        } = e;
        return [t.root, n.container && t.container];
      }
    }),
    componentName: "MuiGrid",
    useThemeProps: (e) => lt({
      props: e,
      name: "MuiGrid"
    }),
    useTheme: ob
  });
  function YDe(e) {
    return it("MuiPaper", e);
  }
  rt("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
  const XDe = (e) => {
    const {
      square: t,
      elevation: n,
      variant: r,
      classes: o
    } = e, i = {
      root: ["root", r, !t && "rounded", r === "elevation" && `elevation${n}`]
    };
    return ot(i, YDe, o);
  }, ZDe = Oe("div", {
    name: "MuiPaper",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[n.variant], !n.square && t.rounded, n.variant === "elevation" && t[`elevation${n.elevation}`]];
    }
  })(at(({
    theme: e
  }) => ({
    backgroundColor: (e.vars || e).palette.background.paper,
    color: (e.vars || e).palette.text.primary,
    transition: e.transitions.create("box-shadow"),
    variants: [{
      props: ({
        ownerState: t
      }) => !t.square,
      style: {
        borderRadius: e.shape.borderRadius
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        border: `1px solid ${(e.vars || e).palette.divider}`
      }
    }, {
      props: {
        variant: "elevation"
      },
      style: {
        boxShadow: "var(--Paper-shadow)",
        backgroundImage: "var(--Paper-overlay)"
      }
    }]
  }))), T1 = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiPaper"
    }), o = ob(), {
      className: i,
      component: a = "div",
      elevation: s = 1,
      square: l = !1,
      variant: u = "elevation",
      ...d
    } = r, p = {
      ...r,
      component: a,
      elevation: s,
      square: l,
      variant: u
    }, h = XDe(p);
    return /* @__PURE__ */ S.jsx(ZDe, {
      as: a,
      ownerState: p,
      className: je(h.root, i),
      ref: n,
      ...d,
      style: {
        ...u === "elevation" && {
          "--Paper-shadow": (o.vars || o).shadows[s],
          ...o.vars && {
            "--Paper-overlay": o.vars.overlays?.[s]
          },
          ...!o.vars && o.palette.mode === "dark" && {
            "--Paper-overlay": `linear-gradient(${Fv("#fff", uE(s))}, ${Fv("#fff", uE(s))})`
          }
        },
        ...d.style
      }
    });
  });
  function QDe(e) {
    const { children: t, buttonsProps: n, hasDescription: r, hasToolbar: o, uiSchema: i, registry: a } = e, s = Ze(i), l = et("ArrayFieldItemButtonsTemplate", a, s), u = {
      flex: 1,
      paddingLeft: 6,
      paddingRight: 6,
      fontWeight: "bold",
      minWidth: 0
    };
    return S.jsxs(cr, { container: !0, alignItems: "center", children: [S.jsx(cr, { size: { xs: 8, sm: 9, md: 10, lg: 11, xl: 11.25 }, style: { overflow: "auto" }, children: S.jsx(sl, { mb: 2, children: S.jsx(T1, { elevation: 2, children: S.jsx(sl, { p: 2, children: t }) }) }) }), o && S.jsx(cr, { sx: { mt: r ? -5 : -1.5 }, children: S.jsx(l, { ...n, style: u }) })] });
  }
  function JDe(e) {
    const { canAdd: t, disabled: n, fieldPathId: r, uiSchema: o, items: i, optionalDataControl: a, onAddClick: s, readonly: l, registry: u, required: d, schema: p, title: h } = e, g = Ze(o), y = et("ArrayFieldDescriptionTemplate", u, g), b = et("ArrayFieldTitleTemplate", u, g), v = !l && !n, { ButtonTemplates: { AddButton: x } } = u.templates;
    return S.jsx(T1, { elevation: 2, children: S.jsxs(sl, { p: 2, children: [S.jsx(b, { fieldPathId: r, title: g.title || h, schema: p, uiSchema: o, required: d, registry: u, optionalDataControl: v ? a : void 0 }), S.jsx(y, { fieldPathId: r, description: g.description || p.description, schema: p, uiSchema: o, registry: u }), v ? void 0 : a, i, t && S.jsx(cr, { container: !0, justifyContent: "flex-end", children: S.jsx(cr, { children: S.jsx(sl, { mt: 2, children: S.jsx(x, { id: $i(r, "add"), className: "rjsf-array-item-add", onClick: s, disabled: n || l, uiSchema: o, registry: u }) }) }) })] }) });
  }
  function tv(e) {
    return parseInt(e, 10) || 0;
  }
  const e5e = {
    shadow: {
      // Visibility needed to hide the extra text area on iPads
      visibility: "hidden",
      // Remove from the content flow
      position: "absolute",
      // Ignore the scrollbar width
      overflow: "hidden",
      height: 0,
      top: 0,
      left: 0,
      // Create a new layer, increase the isolation of the computed values
      transform: "translateZ(0)"
    }
  };
  function t5e(e) {
    for (const t in e)
      return !1;
    return !0;
  }
  function K3(e) {
    return t5e(e) || e.outerHeightStyle === 0 && !e.overflowing;
  }
  const n5e = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const {
      onChange: r,
      maxRows: o,
      minRows: i = 1,
      style: a,
      value: s,
      ...l
    } = t, {
      current: u
    } = T.useRef(s != null), d = T.useRef(null), p = er(n, d), h = T.useRef(null), g = T.useRef(null), y = T.useCallback(() => {
      const _ = d.current, C = g.current;
      if (!_ || !C)
        return;
      const R = qa(_).getComputedStyle(_);
      if (R.width === "0px")
        return {
          outerHeightStyle: 0,
          overflowing: !1
        };
      C.style.width = R.width, C.value = _.value || t.placeholder || "x", C.value.slice(-1) === `
` && (C.value += " ");
      const A = R.boxSizing, M = tv(R.paddingBottom) + tv(R.paddingTop), I = tv(R.borderBottomWidth) + tv(R.borderTopWidth), D = C.scrollHeight;
      C.value = "x";
      const L = C.scrollHeight;
      let P = D;
      i && (P = Math.max(Number(i) * L, P)), o && (P = Math.min(Number(o) * L, P)), P = Math.max(P, L);
      const B = P + (A === "border-box" ? M + I : 0), j = Math.abs(P - D) <= 1;
      return {
        outerHeightStyle: B,
        overflowing: j
      };
    }, [o, i, t.placeholder]), b = Li(() => {
      const _ = d.current, C = y();
      if (!_ || !C || K3(C))
        return !1;
      const k = C.outerHeightStyle;
      return h.current != null && h.current !== k;
    }), v = T.useCallback(() => {
      const _ = d.current, C = y();
      if (!_ || !C || K3(C))
        return;
      const k = C.outerHeightStyle;
      h.current !== k && (h.current = k, _.style.height = `${k}px`), _.style.overflow = C.overflowing ? "hidden" : "";
    }, [y]), x = T.useRef(-1);
    Ko(() => {
      const _ = F7(v), C = d?.current;
      if (!C)
        return;
      const k = qa(C);
      k.addEventListener("resize", _);
      let R;
      return typeof ResizeObserver < "u" && (R = new ResizeObserver(() => {
        b() && (R.unobserve(C), cancelAnimationFrame(x.current), v(), x.current = requestAnimationFrame(() => {
          R.observe(C);
        }));
      }), R.observe(C)), () => {
        _.clear(), cancelAnimationFrame(x.current), k.removeEventListener("resize", _), R && R.disconnect();
      };
    }, [y, v, b]), Ko(() => {
      v();
    });
    const E = (_) => {
      u || v();
      const C = _.target, k = C.value.length, R = C.value.endsWith(`
`), A = C.selectionStart === k;
      R && A && C.setSelectionRange(k, k), r && r(_);
    };
    return /* @__PURE__ */ S.jsxs(T.Fragment, {
      children: [/* @__PURE__ */ S.jsx("textarea", {
        value: s,
        onChange: E,
        ref: p,
        rows: i,
        style: a,
        ...l
      }), /* @__PURE__ */ S.jsx("textarea", {
        "aria-hidden": !0,
        className: t.className,
        readOnly: !0,
        ref: g,
        tabIndex: -1,
        style: {
          ...e5e.shadow,
          ...a,
          paddingTop: 0,
          paddingBottom: 0
        }
      })]
    });
  });
  function dl({
    props: e,
    states: t,
    muiFormControl: n
  }) {
    return t.reduce((r, o) => (r[o] = e[o], n && typeof e[o] > "u" && (r[o] = n[o]), r), {});
  }
  const pO = /* @__PURE__ */ T.createContext(void 0);
  function ea() {
    return T.useContext(pO);
  }
  function Y3(e) {
    return e != null && !(Array.isArray(e) && e.length === 0);
  }
  function D0(e, t = !1) {
    return e && (Y3(e.value) && e.value !== "" || t && Y3(e.defaultValue) && e.defaultValue !== "");
  }
  function r5e(e) {
    return e.startAdornment;
  }
  function o5e(e) {
    return it("MuiInputBase", e);
  }
  const wf = rt("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
  var X3;
  const R1 = (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.formControl && t.formControl, n.startAdornment && t.adornedStart, n.endAdornment && t.adornedEnd, n.error && t.error, n.size === "small" && t.sizeSmall, n.multiline && t.multiline, n.color && t[`color${$e(n.color)}`], n.fullWidth && t.fullWidth, n.hiddenLabel && t.hiddenLabel];
  }, O1 = (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.input, n.size === "small" && t.inputSizeSmall, n.multiline && t.inputMultiline, n.type === "search" && t.inputTypeSearch, n.startAdornment && t.inputAdornedStart, n.endAdornment && t.inputAdornedEnd, n.hiddenLabel && t.inputHiddenLabel];
  }, i5e = (e) => {
    const {
      classes: t,
      color: n,
      disabled: r,
      error: o,
      endAdornment: i,
      focused: a,
      formControl: s,
      fullWidth: l,
      hiddenLabel: u,
      multiline: d,
      readOnly: p,
      size: h,
      startAdornment: g,
      type: y
    } = e, b = {
      root: ["root", `color${$e(n)}`, r && "disabled", o && "error", l && "fullWidth", a && "focused", s && "formControl", h && h !== "medium" && `size${$e(h)}`, d && "multiline", g && "adornedStart", i && "adornedEnd", u && "hiddenLabel", p && "readOnly"],
      input: ["input", r && "disabled", y === "search" && "inputTypeSearch", d && "inputMultiline", h === "small" && "inputSizeSmall", u && "inputHiddenLabel", g && "inputAdornedStart", i && "inputAdornedEnd", p && "readOnly"]
    };
    return ot(b, o5e, t);
  }, A1 = Oe("div", {
    name: "MuiInputBase",
    slot: "Root",
    overridesResolver: R1
  })(at(({
    theme: e
  }) => ({
    ...e.typography.body1,
    color: (e.vars || e).palette.text.primary,
    lineHeight: "1.4375em",
    // 23px
    boxSizing: "border-box",
    // Prevent padding issue with fullWidth.
    position: "relative",
    cursor: "text",
    display: "inline-flex",
    alignItems: "center",
    [`&.${wf.disabled}`]: {
      color: (e.vars || e).palette.text.disabled,
      cursor: "default"
    },
    variants: [{
      props: ({
        ownerState: t
      }) => t.multiline,
      style: {
        padding: "4px 0 5px"
      }
    }, {
      props: ({
        ownerState: t,
        size: n
      }) => t.multiline && n === "small",
      style: {
        paddingTop: 1
      }
    }, {
      props: ({
        ownerState: t
      }) => t.fullWidth,
      style: {
        width: "100%"
      }
    }]
  }))), N1 = Oe("input", {
    name: "MuiInputBase",
    slot: "Input",
    overridesResolver: O1
  })(at(({
    theme: e
  }) => {
    const t = e.palette.mode === "light", n = {
      color: "currentColor",
      ...e.vars ? {
        opacity: e.vars.opacity.inputPlaceholder
      } : {
        opacity: t ? 0.42 : 0.5
      },
      transition: e.transitions.create("opacity", {
        duration: e.transitions.duration.shorter
      })
    }, r = {
      opacity: "0 !important"
    }, o = e.vars ? {
      opacity: e.vars.opacity.inputPlaceholder
    } : {
      opacity: t ? 0.42 : 0.5
    };
    return {
      font: "inherit",
      letterSpacing: "inherit",
      color: "currentColor",
      padding: "4px 0 5px",
      border: 0,
      boxSizing: "content-box",
      background: "none",
      height: "1.4375em",
      // Reset 23pxthe native input line-height
      margin: 0,
      // Reset for Safari
      WebkitTapHighlightColor: "transparent",
      display: "block",
      // Make the flex item shrink with Firefox
      minWidth: 0,
      width: "100%",
      "&::-webkit-input-placeholder": n,
      "&::-moz-placeholder": n,
      // Firefox 19+
      "&::-ms-input-placeholder": n,
      // Edge
      "&:focus": {
        outline: 0
      },
      // Reset Firefox invalid required input style
      "&:invalid": {
        boxShadow: "none"
      },
      "&::-webkit-search-decoration": {
        // Remove the padding when type=search.
        WebkitAppearance: "none"
      },
      // Show and hide the placeholder logic
      [`label[data-shrink=false] + .${wf.formControl} &`]: {
        "&::-webkit-input-placeholder": r,
        "&::-moz-placeholder": r,
        // Firefox 19+
        "&::-ms-input-placeholder": r,
        // Edge
        "&:focus::-webkit-input-placeholder": o,
        "&:focus::-moz-placeholder": o,
        // Firefox 19+
        "&:focus::-ms-input-placeholder": o
        // Edge
      },
      [`&.${wf.disabled}`]: {
        opacity: 1,
        // Reset iOS opacity
        WebkitTextFillColor: (e.vars || e).palette.text.disabled
        // Fix opacity Safari bug
      },
      variants: [{
        props: ({
          ownerState: i
        }) => !i.disableInjectingGlobalStyles,
        style: {
          animationName: "mui-auto-fill-cancel",
          animationDuration: "10ms",
          "&:-webkit-autofill": {
            animationDuration: "5000s",
            animationName: "mui-auto-fill"
          }
        }
      }, {
        props: {
          size: "small"
        },
        style: {
          paddingTop: 1
        }
      }, {
        props: ({
          ownerState: i
        }) => i.multiline,
        style: {
          height: "auto",
          resize: "none",
          padding: 0,
          paddingTop: 0
        }
      }, {
        props: {
          type: "search"
        },
        style: {
          MozAppearance: "textfield"
          // Improve type search style.
        }
      }]
    };
  })), Z3 = CZ({
    "@keyframes mui-auto-fill": {
      from: {
        display: "block"
      }
    },
    "@keyframes mui-auto-fill-cancel": {
      from: {
        display: "block"
      }
    }
  }), hO = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiInputBase"
    }), {
      "aria-describedby": o,
      autoComplete: i,
      autoFocus: a,
      className: s,
      color: l,
      components: u = {},
      componentsProps: d = {},
      defaultValue: p,
      disabled: h,
      disableInjectingGlobalStyles: g,
      endAdornment: y,
      error: b,
      fullWidth: v = !1,
      id: x,
      inputComponent: E = "input",
      inputProps: _ = {},
      inputRef: C,
      margin: k,
      maxRows: R,
      minRows: A,
      multiline: M = !1,
      name: I,
      onBlur: D,
      onChange: L,
      onClick: P,
      onFocus: B,
      onKeyDown: j,
      onKeyUp: V,
      placeholder: F,
      readOnly: G,
      renderSuffix: W,
      rows: K,
      size: $,
      slotProps: U = {},
      slots: X = {},
      startAdornment: z,
      type: H = "text",
      value: Y,
      ...Q
    } = r, re = _.value != null ? _.value : Y, {
      current: te
    } = T.useRef(re != null), le = T.useRef(), fe = T.useCallback((Ue) => {
    }, []), J = er(le, C, _.ref, fe), [ee, ie] = T.useState(!1), ae = ea(), ge = dl({
      props: r,
      muiFormControl: ae,
      states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
    });
    ge.focused = ae ? ae.focused : ee, T.useEffect(() => {
      !ae && h && ee && (ie(!1), D && D());
    }, [ae, h, ee, D]);
    const Ce = ae && ae.onFilled, Ne = ae && ae.onEmpty, Le = T.useCallback((Ue) => {
      D0(Ue) ? Ce && Ce() : Ne && Ne();
    }, [Ce, Ne]);
    Ko(() => {
      te && Le({
        value: re
      });
    }, [re, Le, te]);
    const Ve = (Ue) => {
      B && B(Ue), _.onFocus && _.onFocus(Ue), ae && ae.onFocus ? ae.onFocus(Ue) : ie(!0);
    }, Ke = (Ue) => {
      D && D(Ue), _.onBlur && _.onBlur(Ue), ae && ae.onBlur ? ae.onBlur(Ue) : ie(!1);
    }, ze = (Ue, ...Ft) => {
      if (!te) {
        const ut = Ue.target || le.current;
        if (ut == null)
          throw new Error(ja(1));
        Le({
          value: ut.value
        });
      }
      _.onChange && _.onChange(Ue, ...Ft), L && L(Ue, ...Ft);
    };
    T.useEffect(() => {
      Le(le.current);
    }, []);
    const Me = (Ue) => {
      le.current && Ue.currentTarget === Ue.target && le.current.focus(), P && P(Ue);
    };
    let ct = E, wt = _;
    M && ct === "input" && (K ? wt = {
      type: void 0,
      minRows: K,
      maxRows: K,
      ...wt
    } : wt = {
      type: void 0,
      maxRows: R,
      minRows: A,
      ...wt
    }, ct = n5e);
    const Re = (Ue) => {
      Le(Ue.animationName === "mui-auto-fill-cancel" ? le.current : {
        value: "x"
      });
    };
    T.useEffect(() => {
      ae && ae.setAdornedStart(!!z);
    }, [ae, z]);
    const oe = {
      ...r,
      color: ge.color || "primary",
      disabled: ge.disabled,
      endAdornment: y,
      error: ge.error,
      focused: ge.focused,
      formControl: ae,
      fullWidth: v,
      hiddenLabel: ge.hiddenLabel,
      multiline: M,
      size: ge.size,
      startAdornment: z,
      type: H
    }, ue = i5e(oe), Se = X.root || u.Root || A1, _e = U.root || d.root || {}, Ae = X.input || u.Input || N1;
    return wt = {
      ...wt,
      ...U.input ?? d.input
    }, /* @__PURE__ */ S.jsxs(T.Fragment, {
      children: [!g && typeof Z3 == "function" && // For Emotion/Styled-components, InputGlobalStyles will be a function
      // For Pigment CSS, this has no effect because the InputGlobalStyles will be null.
      (X3 || (X3 = /* @__PURE__ */ S.jsx(Z3, {}))), /* @__PURE__ */ S.jsxs(Se, {
        ..._e,
        ref: n,
        onClick: Me,
        ...Q,
        ...!zi(Se) && {
          ownerState: {
            ...oe,
            ..._e.ownerState
          }
        },
        className: je(ue.root, _e.className, s, G && "MuiInputBase-readOnly"),
        children: [z, /* @__PURE__ */ S.jsx(pO.Provider, {
          value: null,
          children: /* @__PURE__ */ S.jsx(Ae, {
            "aria-invalid": ge.error,
            "aria-describedby": o,
            autoComplete: i,
            autoFocus: a,
            defaultValue: p,
            disabled: ge.disabled,
            id: x,
            onAnimationStart: Re,
            name: I,
            placeholder: F,
            readOnly: G,
            required: ge.required,
            rows: K,
            value: re,
            onKeyDown: j,
            onKeyUp: V,
            type: H,
            ...wt,
            ...!zi(Ae) && {
              as: ct,
              ownerState: {
                ...oe,
                ...wt.ownerState
              }
            },
            ref: J,
            className: je(ue.input, wt.className, G && "MuiInputBase-readOnly"),
            onBlur: Ke,
            onChange: ze,
            onFocus: Ve
          })
        }), y, W ? W({
          ...ge,
          startAdornment: z
        }) : null]
      })]
    });
  });
  function a5e(e) {
    return it("MuiInput", e);
  }
  const ap = {
    ...wf,
    ...rt("MuiInput", ["root", "underline", "input"])
  }, s5e = (e) => {
    const {
      classes: t,
      disableUnderline: n
    } = e, o = ot({
      root: ["root", !n && "underline"],
      input: ["input"]
    }, a5e, t);
    return {
      ...t,
      // forward classes to the InputBase
      ...o
    };
  }, l5e = Oe(A1, {
    shouldForwardProp: (e) => wr(e) || e === "classes",
    name: "MuiInput",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [...R1(e, t), !n.disableUnderline && t.underline];
    }
  })(at(({
    theme: e
  }) => {
    let n = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
    return e.vars && (n = e.alpha(e.vars.palette.common.onBackground, e.vars.opacity.inputUnderline)), {
      position: "relative",
      variants: [{
        props: ({
          ownerState: r
        }) => r.formControl,
        style: {
          "label + &": {
            marginTop: 16
          }
        }
      }, {
        props: ({
          ownerState: r
        }) => !r.disableUnderline,
        style: {
          "&::after": {
            left: 0,
            bottom: 0,
            content: '""',
            position: "absolute",
            right: 0,
            transform: "scaleX(0)",
            transition: e.transitions.create("transform", {
              duration: e.transitions.duration.shorter,
              easing: e.transitions.easing.easeOut
            }),
            pointerEvents: "none"
            // Transparent to the hover style.
          },
          [`&.${ap.focused}:after`]: {
            // translateX(0) is a workaround for Safari transform scale bug
            // See https://github.com/mui/material-ui/issues/31766
            transform: "scaleX(1) translateX(0)"
          },
          [`&.${ap.error}`]: {
            "&::before, &::after": {
              borderBottomColor: (e.vars || e).palette.error.main
            }
          },
          "&::before": {
            borderBottom: `1px solid ${n}`,
            left: 0,
            bottom: 0,
            content: '"\\00a0"',
            position: "absolute",
            right: 0,
            transition: e.transitions.create("border-bottom-color", {
              duration: e.transitions.duration.shorter
            }),
            pointerEvents: "none"
            // Transparent to the hover style.
          },
          [`&:hover:not(.${ap.disabled}, .${ap.error}):before`]: {
            borderBottom: `2px solid ${(e.vars || e).palette.text.primary}`,
            // Reset on touch devices, it doesn't add specificity
            "@media (hover: none)": {
              borderBottom: `1px solid ${n}`
            }
          },
          [`&.${ap.disabled}:before`]: {
            borderBottomStyle: "dotted"
          }
        }
      }, ...Object.entries(e.palette).filter(xr()).map(([r]) => ({
        props: {
          color: r,
          disableUnderline: !1
        },
        style: {
          "&::after": {
            borderBottom: `2px solid ${(e.vars || e).palette[r].main}`
          }
        }
      }))]
    };
  })), c5e = Oe(N1, {
    name: "MuiInput",
    slot: "Input",
    overridesResolver: O1
  })({}), mO = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiInput"
    }), {
      disableUnderline: o = !1,
      components: i = {},
      componentsProps: a,
      fullWidth: s = !1,
      inputComponent: l = "input",
      multiline: u = !1,
      slotProps: d,
      slots: p = {},
      type: h = "text",
      ...g
    } = r, y = s5e(r), v = {
      root: {
        ownerState: {
          disableUnderline: o
        }
      }
    }, x = d ?? a ? vr(d ?? a, v) : v, E = p.root ?? i.Root ?? l5e, _ = p.input ?? i.Input ?? c5e;
    return /* @__PURE__ */ S.jsx(hO, {
      slots: {
        root: E,
        input: _
      },
      slotProps: x,
      fullWidth: s,
      inputComponent: l,
      multiline: u,
      ref: n,
      type: h,
      ...g,
      classes: y
    });
  });
  mO.muiName = "Input";
  function u5e(e) {
    return it("MuiFilledInput", e);
  }
  const Ll = {
    ...wf,
    ...rt("MuiFilledInput", ["root", "underline", "input", "adornedStart", "adornedEnd", "sizeSmall", "multiline", "hiddenLabel"])
  }, f5e = (e) => {
    const {
      classes: t,
      disableUnderline: n,
      startAdornment: r,
      endAdornment: o,
      size: i,
      hiddenLabel: a,
      multiline: s
    } = e, l = {
      root: ["root", !n && "underline", r && "adornedStart", o && "adornedEnd", i === "small" && `size${$e(i)}`, a && "hiddenLabel", s && "multiline"],
      input: ["input"]
    }, u = ot(l, u5e, t);
    return {
      ...t,
      // forward classes to the InputBase
      ...u
    };
  }, d5e = Oe(A1, {
    shouldForwardProp: (e) => wr(e) || e === "classes",
    name: "MuiFilledInput",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [...R1(e, t), !n.disableUnderline && t.underline];
    }
  })(at(({
    theme: e
  }) => {
    const t = e.palette.mode === "light", n = t ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)", r = t ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)", o = t ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)", i = t ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
    return {
      position: "relative",
      backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r,
      borderTopLeftRadius: (e.vars || e).shape.borderRadius,
      borderTopRightRadius: (e.vars || e).shape.borderRadius,
      transition: e.transitions.create("background-color", {
        duration: e.transitions.duration.shorter,
        easing: e.transitions.easing.easeOut
      }),
      "&:hover": {
        backgroundColor: e.vars ? e.vars.palette.FilledInput.hoverBg : o,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r
        }
      },
      [`&.${Ll.focused}`]: {
        backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r
      },
      [`&.${Ll.disabled}`]: {
        backgroundColor: e.vars ? e.vars.palette.FilledInput.disabledBg : i
      },
      variants: [{
        props: ({
          ownerState: a
        }) => !a.disableUnderline,
        style: {
          "&::after": {
            left: 0,
            bottom: 0,
            content: '""',
            position: "absolute",
            right: 0,
            transform: "scaleX(0)",
            transition: e.transitions.create("transform", {
              duration: e.transitions.duration.shorter,
              easing: e.transitions.easing.easeOut
            }),
            pointerEvents: "none"
            // Transparent to the hover style.
          },
          [`&.${Ll.focused}:after`]: {
            // translateX(0) is a workaround for Safari transform scale bug
            // See https://github.com/mui/material-ui/issues/31766
            transform: "scaleX(1) translateX(0)"
          },
          [`&.${Ll.error}`]: {
            "&::before, &::after": {
              borderBottomColor: (e.vars || e).palette.error.main
            }
          },
          "&::before": {
            borderBottom: `1px solid ${e.vars ? e.alpha(e.vars.palette.common.onBackground, e.vars.opacity.inputUnderline) : n}`,
            left: 0,
            bottom: 0,
            content: '"\\00a0"',
            position: "absolute",
            right: 0,
            transition: e.transitions.create("border-bottom-color", {
              duration: e.transitions.duration.shorter
            }),
            pointerEvents: "none"
            // Transparent to the hover style.
          },
          [`&:hover:not(.${Ll.disabled}, .${Ll.error}):before`]: {
            borderBottom: `1px solid ${(e.vars || e).palette.text.primary}`
          },
          [`&.${Ll.disabled}:before`]: {
            borderBottomStyle: "dotted"
          }
        }
      }, ...Object.entries(e.palette).filter(xr()).map(([a]) => ({
        props: {
          disableUnderline: !1,
          color: a
        },
        style: {
          "&::after": {
            borderBottom: `2px solid ${(e.vars || e).palette[a]?.main}`
          }
        }
      })), {
        props: ({
          ownerState: a
        }) => a.startAdornment,
        style: {
          paddingLeft: 12
        }
      }, {
        props: ({
          ownerState: a
        }) => a.endAdornment,
        style: {
          paddingRight: 12
        }
      }, {
        props: ({
          ownerState: a
        }) => a.multiline,
        style: {
          padding: "25px 12px 8px"
        }
      }, {
        props: ({
          ownerState: a,
          size: s
        }) => a.multiline && s === "small",
        style: {
          paddingTop: 21,
          paddingBottom: 4
        }
      }, {
        props: ({
          ownerState: a
        }) => a.multiline && a.hiddenLabel,
        style: {
          paddingTop: 16,
          paddingBottom: 17
        }
      }, {
        props: ({
          ownerState: a
        }) => a.multiline && a.hiddenLabel && a.size === "small",
        style: {
          paddingTop: 8,
          paddingBottom: 9
        }
      }]
    };
  })), p5e = Oe(N1, {
    name: "MuiFilledInput",
    slot: "Input",
    overridesResolver: O1
  })(at(({
    theme: e
  }) => ({
    paddingTop: 25,
    paddingRight: 12,
    paddingBottom: 8,
    paddingLeft: 12,
    ...!e.vars && {
      "&:-webkit-autofill": {
        WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
        WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
        caretColor: e.palette.mode === "light" ? null : "#fff",
        borderTopLeftRadius: "inherit",
        borderTopRightRadius: "inherit"
      }
    },
    ...e.vars && {
      "&:-webkit-autofill": {
        borderTopLeftRadius: "inherit",
        borderTopRightRadius: "inherit"
      },
      [e.getColorSchemeSelector("dark")]: {
        "&:-webkit-autofill": {
          WebkitBoxShadow: "0 0 0 100px #266798 inset",
          WebkitTextFillColor: "#fff",
          caretColor: "#fff"
        }
      }
    },
    variants: [{
      props: {
        size: "small"
      },
      style: {
        paddingTop: 21,
        paddingBottom: 4
      }
    }, {
      props: ({
        ownerState: t
      }) => t.hiddenLabel,
      style: {
        paddingTop: 16,
        paddingBottom: 17
      }
    }, {
      props: ({
        ownerState: t
      }) => t.startAdornment,
      style: {
        paddingLeft: 0
      }
    }, {
      props: ({
        ownerState: t
      }) => t.endAdornment,
      style: {
        paddingRight: 0
      }
    }, {
      props: ({
        ownerState: t
      }) => t.hiddenLabel && t.size === "small",
      style: {
        paddingTop: 8,
        paddingBottom: 9
      }
    }, {
      props: ({
        ownerState: t
      }) => t.multiline,
      style: {
        paddingTop: 0,
        paddingBottom: 0,
        paddingLeft: 0,
        paddingRight: 0
      }
    }]
  }))), gO = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiFilledInput"
    }), {
      disableUnderline: o = !1,
      components: i = {},
      componentsProps: a,
      fullWidth: s = !1,
      hiddenLabel: l,
      // declare here to prevent spreading to DOM
      inputComponent: u = "input",
      multiline: d = !1,
      slotProps: p,
      slots: h = {},
      type: g = "text",
      ...y
    } = r, b = {
      ...r,
      disableUnderline: o,
      fullWidth: s,
      inputComponent: u,
      multiline: d,
      type: g
    }, v = f5e(r), x = {
      root: {
        ownerState: b
      },
      input: {
        ownerState: b
      }
    }, E = p ?? a ? vr(x, p ?? a) : x, _ = h.root ?? i.Root ?? d5e, C = h.input ?? i.Input ?? p5e;
    return /* @__PURE__ */ S.jsx(hO, {
      slots: {
        root: _,
        input: C
      },
      slotProps: E,
      fullWidth: s,
      inputComponent: u,
      multiline: d,
      ref: n,
      type: g,
      ...y,
      classes: v
    });
  });
  gO.muiName = "Input";
  var Q3;
  const h5e = Oe("fieldset", {
    name: "MuiNotchedOutlined",
    shouldForwardProp: wr
  })({
    textAlign: "left",
    position: "absolute",
    bottom: 0,
    right: 0,
    top: -5,
    left: 0,
    margin: 0,
    padding: "0 8px",
    pointerEvents: "none",
    borderRadius: "inherit",
    borderStyle: "solid",
    borderWidth: 1,
    overflow: "hidden",
    minWidth: "0%"
  }), m5e = Oe("legend", {
    name: "MuiNotchedOutlined",
    shouldForwardProp: wr
  })(at(({
    theme: e
  }) => ({
    float: "unset",
    // Fix conflict with bootstrap
    width: "auto",
    // Fix conflict with bootstrap
    overflow: "hidden",
    // Fix Horizontal scroll when label too long
    variants: [{
      props: ({
        ownerState: t
      }) => !t.withLabel,
      style: {
        padding: 0,
        lineHeight: "11px",
        // sync with `height` in `legend` styles
        transition: e.transitions.create("width", {
          duration: 150,
          easing: e.transitions.easing.easeOut
        })
      }
    }, {
      props: ({
        ownerState: t
      }) => t.withLabel,
      style: {
        display: "block",
        // Fix conflict with normalize.css and sanitize.css
        padding: 0,
        height: 11,
        // sync with `lineHeight` in `legend` styles
        fontSize: "0.75em",
        visibility: "hidden",
        maxWidth: 0.01,
        transition: e.transitions.create("max-width", {
          duration: 50,
          easing: e.transitions.easing.easeOut
        }),
        whiteSpace: "nowrap",
        "& > span": {
          paddingLeft: 5,
          paddingRight: 5,
          display: "inline-block",
          opacity: 0,
          visibility: "visible"
        }
      }
    }, {
      props: ({
        ownerState: t
      }) => t.withLabel && t.notched,
      style: {
        maxWidth: "100%",
        transition: e.transitions.create("max-width", {
          duration: 100,
          easing: e.transitions.easing.easeOut,
          delay: 50
        })
      }
    }]
  })));
  function g5e(e) {
    const {
      children: t,
      classes: n,
      className: r,
      label: o,
      notched: i,
      ...a
    } = e, s = o != null && o !== "", l = {
      ...e,
      notched: i,
      withLabel: s
    };
    return /* @__PURE__ */ S.jsx(h5e, {
      "aria-hidden": !0,
      className: r,
      ownerState: l,
      ...a,
      children: /* @__PURE__ */ S.jsx(m5e, {
        ownerState: l,
        children: s ? /* @__PURE__ */ S.jsx("span", {
          children: o
        }) : (
          // notranslate needed while Google Translate will not fix zero-width space issue
          Q3 || (Q3 = /* @__PURE__ */ S.jsx("span", {
            className: "notranslate",
            "aria-hidden": !0,
            children: ""
          }))
        )
      })
    });
  }
  function y5e(e) {
    return it("MuiOutlinedInput", e);
  }
  const mi = {
    ...wf,
    ...rt("MuiOutlinedInput", ["root", "notchedOutline", "input"])
  }, v5e = (e) => {
    const {
      classes: t
    } = e, r = ot({
      root: ["root"],
      notchedOutline: ["notchedOutline"],
      input: ["input"]
    }, y5e, t);
    return {
      ...t,
      // forward classes to the InputBase
      ...r
    };
  }, b5e = Oe(A1, {
    shouldForwardProp: (e) => wr(e) || e === "classes",
    name: "MuiOutlinedInput",
    slot: "Root",
    overridesResolver: R1
  })(at(({
    theme: e
  }) => {
    const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
    return {
      position: "relative",
      borderRadius: (e.vars || e).shape.borderRadius,
      [`&:hover .${mi.notchedOutline}`]: {
        borderColor: (e.vars || e).palette.text.primary
      },
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        [`&:hover .${mi.notchedOutline}`]: {
          borderColor: e.vars ? e.alpha(e.vars.palette.common.onBackground, 0.23) : t
        }
      },
      [`&.${mi.focused} .${mi.notchedOutline}`]: {
        borderWidth: 2
      },
      variants: [...Object.entries(e.palette).filter(xr()).map(([n]) => ({
        props: {
          color: n
        },
        style: {
          [`&.${mi.focused} .${mi.notchedOutline}`]: {
            borderColor: (e.vars || e).palette[n].main
          }
        }
      })), {
        props: {},
        // to override the above style
        style: {
          [`&.${mi.error} .${mi.notchedOutline}`]: {
            borderColor: (e.vars || e).palette.error.main
          },
          [`&.${mi.disabled} .${mi.notchedOutline}`]: {
            borderColor: (e.vars || e).palette.action.disabled
          }
        }
      }, {
        props: ({
          ownerState: n
        }) => n.startAdornment,
        style: {
          paddingLeft: 14
        }
      }, {
        props: ({
          ownerState: n
        }) => n.endAdornment,
        style: {
          paddingRight: 14
        }
      }, {
        props: ({
          ownerState: n
        }) => n.multiline,
        style: {
          padding: "16.5px 14px"
        }
      }, {
        props: ({
          ownerState: n,
          size: r
        }) => n.multiline && r === "small",
        style: {
          padding: "8.5px 14px"
        }
      }]
    };
  })), x5e = Oe(g5e, {
    name: "MuiOutlinedInput",
    slot: "NotchedOutline"
  })(at(({
    theme: e
  }) => {
    const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
    return {
      borderColor: e.vars ? e.alpha(e.vars.palette.common.onBackground, 0.23) : t
    };
  })), w5e = Oe(N1, {
    name: "MuiOutlinedInput",
    slot: "Input",
    overridesResolver: O1
  })(at(({
    theme: e
  }) => ({
    padding: "16.5px 14px",
    ...!e.vars && {
      "&:-webkit-autofill": {
        WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
        WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
        caretColor: e.palette.mode === "light" ? null : "#fff",
        borderRadius: "inherit"
      }
    },
    ...e.vars && {
      "&:-webkit-autofill": {
        borderRadius: "inherit"
      },
      [e.getColorSchemeSelector("dark")]: {
        "&:-webkit-autofill": {
          WebkitBoxShadow: "0 0 0 100px #266798 inset",
          WebkitTextFillColor: "#fff",
          caretColor: "#fff"
        }
      }
    },
    variants: [{
      props: {
        size: "small"
      },
      style: {
        padding: "8.5px 14px"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.multiline,
      style: {
        padding: 0
      }
    }, {
      props: ({
        ownerState: t
      }) => t.startAdornment,
      style: {
        paddingLeft: 0
      }
    }, {
      props: ({
        ownerState: t
      }) => t.endAdornment,
      style: {
        paddingRight: 0
      }
    }]
  }))), yO = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiOutlinedInput"
    }), {
      components: o = {},
      fullWidth: i = !1,
      inputComponent: a = "input",
      label: s,
      multiline: l = !1,
      notched: u,
      slots: d = {},
      slotProps: p = {},
      type: h = "text",
      ...g
    } = r, y = v5e(r), b = ea(), v = dl({
      props: r,
      muiFormControl: b,
      states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
    }), x = {
      ...r,
      color: v.color || "primary",
      disabled: v.disabled,
      error: v.error,
      focused: v.focused,
      formControl: b,
      fullWidth: i,
      hiddenLabel: v.hiddenLabel,
      multiline: l,
      size: v.size,
      type: h
    }, E = d.root ?? o.Root ?? b5e, _ = d.input ?? o.Input ?? w5e, [C, k] = dn("notchedOutline", {
      elementType: x5e,
      className: y.notchedOutline,
      shouldForwardComponentProp: !0,
      ownerState: x,
      externalForwardedProps: {
        slots: d,
        slotProps: p
      },
      additionalProps: {
        label: s != null && s !== "" && v.required ? /* @__PURE__ */ S.jsxs(T.Fragment, {
          children: [s, "", "*"]
        }) : s
      }
    });
    return /* @__PURE__ */ S.jsx(hO, {
      slots: {
        root: E,
        input: _
      },
      slotProps: p,
      renderSuffix: (R) => /* @__PURE__ */ S.jsx(C, {
        ...k,
        notched: typeof u < "u" ? u : !!(R.startAdornment || R.filled || R.focused)
      }),
      fullWidth: i,
      inputComponent: a,
      multiline: l,
      ref: n,
      type: h,
      ...g,
      classes: {
        ...y,
        notchedOutline: null
      }
    });
  });
  yO.muiName = "Input";
  function S5e(e) {
    return it("MuiFormLabel", e);
  }
  const zp = rt("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]), _5e = (e) => {
    const {
      classes: t,
      color: n,
      focused: r,
      disabled: o,
      error: i,
      filled: a,
      required: s
    } = e, l = {
      root: ["root", `color${$e(n)}`, o && "disabled", i && "error", a && "filled", r && "focused", s && "required"],
      asterisk: ["asterisk", i && "error"]
    };
    return ot(l, S5e, t);
  }, E5e = Oe("label", {
    name: "MuiFormLabel",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.color === "secondary" && t.colorSecondary, n.filled && t.filled];
    }
  })(at(({
    theme: e
  }) => ({
    color: (e.vars || e).palette.text.secondary,
    ...e.typography.body1,
    lineHeight: "1.4375em",
    padding: 0,
    position: "relative",
    variants: [...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        [`&.${zp.focused}`]: {
          color: (e.vars || e).palette[t].main
        }
      }
    })), {
      props: {},
      style: {
        [`&.${zp.disabled}`]: {
          color: (e.vars || e).palette.text.disabled
        },
        [`&.${zp.error}`]: {
          color: (e.vars || e).palette.error.main
        }
      }
    }]
  }))), C5e = Oe("span", {
    name: "MuiFormLabel",
    slot: "Asterisk"
  })(at(({
    theme: e
  }) => ({
    [`&.${zp.error}`]: {
      color: (e.vars || e).palette.error.main
    }
  }))), M1 = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiFormLabel"
    }), {
      children: o,
      className: i,
      color: a,
      component: s = "label",
      disabled: l,
      error: u,
      filled: d,
      focused: p,
      required: h,
      ...g
    } = r, y = ea(), b = dl({
      props: r,
      muiFormControl: y,
      states: ["color", "required", "focused", "disabled", "error", "filled"]
    }), v = {
      ...r,
      color: b.color || "primary",
      component: s,
      disabled: b.disabled,
      error: b.error,
      filled: b.filled,
      focused: b.focused,
      required: b.required
    }, x = _5e(v);
    return /* @__PURE__ */ S.jsxs(E5e, {
      as: s,
      ownerState: v,
      className: je(x.root, i),
      ref: n,
      ...g,
      children: [o, b.required && /* @__PURE__ */ S.jsxs(C5e, {
        ownerState: v,
        "aria-hidden": !0,
        className: x.asterisk,
        children: ["", "*"]
      })]
    });
  });
  function k5e(e) {
    return it("MuiInputLabel", e);
  }
  rt("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
  const T5e = (e) => {
    const {
      classes: t,
      formControl: n,
      size: r,
      shrink: o,
      disableAnimation: i,
      variant: a,
      required: s
    } = e, l = {
      root: ["root", n && "formControl", !i && "animated", o && "shrink", r && r !== "medium" && `size${$e(r)}`, a],
      asterisk: [s && "asterisk"]
    }, u = ot(l, k5e, t);
    return {
      ...t,
      // forward the focused, disabled, etc. classes to the FormLabel
      ...u
    };
  }, R5e = Oe(M1, {
    shouldForwardProp: (e) => wr(e) || e === "classes",
    name: "MuiInputLabel",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [{
        [`& .${zp.asterisk}`]: t.asterisk
      }, t.root, n.formControl && t.formControl, n.size === "small" && t.sizeSmall, n.shrink && t.shrink, !n.disableAnimation && t.animated, n.focused && t.focused, t[n.variant]];
    }
  })(at(({
    theme: e
  }) => ({
    display: "block",
    transformOrigin: "top left",
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",
    maxWidth: "100%",
    variants: [{
      props: ({
        ownerState: t
      }) => t.formControl,
      style: {
        position: "absolute",
        left: 0,
        top: 0,
        // slight alteration to spec spacing to match visual spec result
        transform: "translate(0, 20px) scale(1)"
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        // Compensation for the `Input.inputSizeSmall` style.
        transform: "translate(0, 17px) scale(1)"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.shrink,
      style: {
        transform: "translate(0, -1.5px) scale(0.75)",
        transformOrigin: "top left",
        maxWidth: "133%"
      }
    }, {
      props: ({
        ownerState: t
      }) => !t.disableAnimation,
      style: {
        transition: e.transitions.create(["color", "transform", "max-width"], {
          duration: e.transitions.duration.shorter,
          easing: e.transitions.easing.easeOut
        })
      }
    }, {
      props: {
        variant: "filled"
      },
      style: {
        // Chrome's autofill feature gives the input field a yellow background.
        // Since the input field is behind the label in the HTML tree,
        // the input field is drawn last and hides the label with an opaque background color.
        // zIndex: 1 will raise the label above opaque background-colors of input.
        zIndex: 1,
        pointerEvents: "none",
        transform: "translate(12px, 16px) scale(1)",
        maxWidth: "calc(100% - 24px)"
      }
    }, {
      props: {
        variant: "filled",
        size: "small"
      },
      style: {
        transform: "translate(12px, 13px) scale(1)"
      }
    }, {
      props: ({
        variant: t,
        ownerState: n
      }) => t === "filled" && n.shrink,
      style: {
        userSelect: "none",
        pointerEvents: "auto",
        transform: "translate(12px, 7px) scale(0.75)",
        maxWidth: "calc(133% - 24px)"
      }
    }, {
      props: ({
        variant: t,
        ownerState: n,
        size: r
      }) => t === "filled" && n.shrink && r === "small",
      style: {
        transform: "translate(12px, 4px) scale(0.75)"
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        // see comment above on filled.zIndex
        zIndex: 1,
        pointerEvents: "none",
        transform: "translate(14px, 16px) scale(1)",
        maxWidth: "calc(100% - 24px)"
      }
    }, {
      props: {
        variant: "outlined",
        size: "small"
      },
      style: {
        transform: "translate(14px, 9px) scale(1)"
      }
    }, {
      props: ({
        variant: t,
        ownerState: n
      }) => t === "outlined" && n.shrink,
      style: {
        userSelect: "none",
        pointerEvents: "auto",
        // Theoretically, we should have (8+5)*2/0.75 = 34px
        // but it feels a better when it bleeds a bit on the left, so 32px.
        maxWidth: "calc(133% - 32px)",
        transform: "translate(14px, -9px) scale(0.75)"
      }
    }]
  }))), O5e = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      name: "MuiInputLabel",
      props: t
    }), {
      disableAnimation: o = !1,
      margin: i,
      shrink: a,
      variant: s,
      className: l,
      ...u
    } = r, d = ea();
    let p = a;
    typeof p > "u" && d && (p = d.filled || d.focused || d.adornedStart);
    const h = dl({
      props: r,
      muiFormControl: d,
      states: ["size", "variant", "required", "focused"]
    }), g = {
      ...r,
      disableAnimation: o,
      formControl: d,
      shrink: p,
      size: h.size,
      variant: h.variant,
      required: h.required,
      focused: h.focused
    }, y = T5e(g);
    return /* @__PURE__ */ S.jsx(R5e, {
      "data-shrink": p,
      ref: n,
      className: je(y.root, l),
      ...u,
      ownerState: g,
      classes: y
    });
  });
  function A5e(e) {
    return it("MuiFormControl", e);
  }
  rt("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
  const N5e = (e) => {
    const {
      classes: t,
      margin: n,
      fullWidth: r
    } = e, o = {
      root: ["root", n !== "none" && `margin${$e(n)}`, r && "fullWidth"]
    };
    return ot(o, A5e, t);
  }, M5e = Oe("div", {
    name: "MuiFormControl",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[`margin${$e(n.margin)}`], n.fullWidth && t.fullWidth];
    }
  })({
    display: "inline-flex",
    flexDirection: "column",
    position: "relative",
    // Reset fieldset default style.
    minWidth: 0,
    padding: 0,
    margin: 0,
    border: 0,
    verticalAlign: "top",
    // Fix alignment issue on Safari.
    variants: [{
      props: {
        margin: "normal"
      },
      style: {
        marginTop: 16,
        marginBottom: 8
      }
    }, {
      props: {
        margin: "dense"
      },
      style: {
        marginTop: 8,
        marginBottom: 4
      }
    }, {
      props: {
        fullWidth: !0
      },
      style: {
        width: "100%"
      }
    }]
  }), vO = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiFormControl"
    }), {
      children: o,
      className: i,
      color: a = "primary",
      component: s = "div",
      disabled: l = !1,
      error: u = !1,
      focused: d,
      fullWidth: p = !1,
      hiddenLabel: h = !1,
      margin: g = "none",
      required: y = !1,
      size: b = "medium",
      variant: v = "outlined",
      ...x
    } = r, E = {
      ...r,
      color: a,
      component: s,
      disabled: l,
      error: u,
      fullWidth: p,
      hiddenLabel: h,
      margin: g,
      required: y,
      size: b,
      variant: v
    }, _ = N5e(E), [C, k] = T.useState(() => {
      let V = !1;
      return o && T.Children.forEach(o, (F) => {
        if (!Ep(F, ["Input", "Select"]))
          return;
        const G = Ep(F, ["Select"]) ? F.props.input : F;
        G && r5e(G.props) && (V = !0);
      }), V;
    }), [R, A] = T.useState(() => {
      let V = !1;
      return o && T.Children.forEach(o, (F) => {
        Ep(F, ["Input", "Select"]) && (D0(F.props, !0) || D0(F.props.inputProps, !0)) && (V = !0);
      }), V;
    }), [M, I] = T.useState(!1);
    l && M && I(!1);
    const D = d !== void 0 && !l ? d : M;
    let L;
    T.useRef(!1);
    const P = T.useCallback(() => {
      A(!0);
    }, []), B = T.useCallback(() => {
      A(!1);
    }, []), j = T.useMemo(() => ({
      adornedStart: C,
      setAdornedStart: k,
      color: a,
      disabled: l,
      error: u,
      filled: R,
      focused: D,
      fullWidth: p,
      hiddenLabel: h,
      size: b,
      onBlur: () => {
        I(!1);
      },
      onFocus: () => {
        I(!0);
      },
      onEmpty: B,
      onFilled: P,
      registerEffect: L,
      required: y,
      variant: v
    }), [C, a, l, u, R, D, p, h, L, B, P, y, b, v]);
    return /* @__PURE__ */ S.jsx(pO.Provider, {
      value: j,
      children: /* @__PURE__ */ S.jsx(M5e, {
        as: s,
        ownerState: E,
        className: je(_.root, i),
        ref: n,
        ...x,
        children: o
      })
    });
  });
  function P5e(e) {
    return it("MuiFormHelperText", e);
  }
  const J3 = rt("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
  var e4;
  const $5e = (e) => {
    const {
      classes: t,
      contained: n,
      size: r,
      disabled: o,
      error: i,
      filled: a,
      focused: s,
      required: l
    } = e, u = {
      root: ["root", o && "disabled", i && "error", r && `size${$e(r)}`, n && "contained", s && "focused", a && "filled", l && "required"]
    };
    return ot(u, P5e, t);
  }, I5e = Oe("p", {
    name: "MuiFormHelperText",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.size && t[`size${$e(n.size)}`], n.contained && t.contained, n.filled && t.filled];
    }
  })(at(({
    theme: e
  }) => ({
    color: (e.vars || e).palette.text.secondary,
    ...e.typography.caption,
    textAlign: "left",
    marginTop: 3,
    marginRight: 0,
    marginBottom: 0,
    marginLeft: 0,
    [`&.${J3.disabled}`]: {
      color: (e.vars || e).palette.text.disabled
    },
    [`&.${J3.error}`]: {
      color: (e.vars || e).palette.error.main
    },
    variants: [{
      props: {
        size: "small"
      },
      style: {
        marginTop: 4
      }
    }, {
      props: ({
        ownerState: t
      }) => t.contained,
      style: {
        marginLeft: 14,
        marginRight: 14
      }
    }]
  }))), bO = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiFormHelperText"
    }), {
      children: o,
      className: i,
      component: a = "p",
      disabled: s,
      error: l,
      filled: u,
      focused: d,
      margin: p,
      required: h,
      variant: g,
      ...y
    } = r, b = ea(), v = dl({
      props: r,
      muiFormControl: b,
      states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
    }), x = {
      ...r,
      component: a,
      contained: v.variant === "filled" || v.variant === "outlined",
      variant: v.variant,
      size: v.size,
      disabled: v.disabled,
      error: v.error,
      filled: v.filled,
      focused: v.focused,
      required: v.required
    };
    delete x.ownerState;
    const E = $5e(x);
    return /* @__PURE__ */ S.jsx(I5e, {
      as: a,
      className: je(E.root, i),
      ref: n,
      ...y,
      ownerState: x,
      children: o === " " ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        e4 || (e4 = /* @__PURE__ */ S.jsx("span", {
          className: "notranslate",
          "aria-hidden": !0,
          children: ""
        }))
      ) : o
    });
  });
  function gm(e) {
    return parseInt(T.version, 10) >= 19 ? e?.props?.ref || null : e?.ref || null;
  }
  function Ta(e) {
    const {
      elementType: t,
      externalSlotProps: n,
      ownerState: r,
      skipResolvingSlotProps: o = !1,
      ...i
    } = e, a = o ? {} : gF(n, r), {
      props: s,
      internalRef: l
    } = yF({
      ...i,
      externalSlotProps: a
    }), u = er(l, a?.ref, e.additionalProps?.ref);
    return mF(t, {
      ...s,
      ref: u
    }, r);
  }
  const Ia = /* @__PURE__ */ T.createContext({});
  function j5e(e) {
    return it("MuiList", e);
  }
  rt("MuiList", ["root", "padding", "dense", "subheader"]);
  const D5e = (e) => {
    const {
      classes: t,
      disablePadding: n,
      dense: r,
      subheader: o
    } = e;
    return ot({
      root: ["root", !n && "padding", r && "dense", o && "subheader"]
    }, j5e, t);
  }, F5e = Oe("ul", {
    name: "MuiList",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, !n.disablePadding && t.padding, n.dense && t.dense, n.subheader && t.subheader];
    }
  })({
    listStyle: "none",
    margin: 0,
    padding: 0,
    position: "relative",
    variants: [{
      props: ({
        ownerState: e
      }) => !e.disablePadding,
      style: {
        paddingTop: 8,
        paddingBottom: 8
      }
    }, {
      props: ({
        ownerState: e
      }) => e.subheader,
      style: {
        paddingTop: 0
      }
    }]
  }), xO = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiList"
    }), {
      children: o,
      className: i,
      component: a = "ul",
      dense: s = !1,
      disablePadding: l = !1,
      subheader: u,
      ...d
    } = r, p = T.useMemo(() => ({
      dense: s
    }), [s]), h = {
      ...r,
      component: a,
      dense: s,
      disablePadding: l
    }, g = D5e(h);
    return /* @__PURE__ */ S.jsx(Ia.Provider, {
      value: p,
      children: /* @__PURE__ */ S.jsxs(F5e, {
        as: a,
        className: je(g.root, i),
        ref: n,
        ownerState: h,
        ...d,
        children: [u, o]
      })
    });
  });
  function V7(e = window) {
    const t = e.document.documentElement.clientWidth;
    return e.innerWidth - t;
  }
  function J_(e, t, n) {
    return e === t ? e.firstChild : t && t.nextElementSibling ? t.nextElementSibling : n ? null : e.firstChild;
  }
  function t4(e, t, n) {
    return e === t ? n ? e.firstChild : e.lastChild : t && t.previousElementSibling ? t.previousElementSibling : n ? null : e.lastChild;
  }
  function H7(e, t) {
    if (t === void 0)
      return !0;
    let n = e.innerText;
    return n === void 0 && (n = e.textContent), n = n.trim().toLowerCase(), n.length === 0 ? !1 : t.repeating ? n[0] === t.keys[0] : n.startsWith(t.keys.join(""));
  }
  function sp(e, t, n, r, o, i) {
    let a = !1, s = o(e, t, t ? n : !1);
    for (; s; ) {
      if (s === e.firstChild) {
        if (a)
          return !1;
        a = !0;
      }
      const l = r ? !1 : s.disabled || s.getAttribute("aria-disabled") === "true";
      if (!s.hasAttribute("tabindex") || !H7(s, i) || l)
        s = o(e, s, n);
      else
        return s.focus(), !0;
    }
    return !1;
  }
  const L5e = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const {
      // private
      // eslint-disable-next-line react/prop-types
      actions: r,
      autoFocus: o = !1,
      autoFocusItem: i = !1,
      children: a,
      className: s,
      disabledItemsFocusable: l = !1,
      disableListWrap: u = !1,
      onKeyDown: d,
      variant: p = "selectedMenu",
      ...h
    } = t, g = T.useRef(null), y = T.useRef({
      keys: [],
      repeating: !0,
      previousKeyMatched: !0,
      lastTime: null
    });
    Ko(() => {
      o && g.current.focus();
    }, [o]), T.useImperativeHandle(r, () => ({
      adjustStyleForScrollbar: (_, {
        direction: C
      }) => {
        const k = !g.current.style.width;
        if (_.clientHeight < g.current.clientHeight && k) {
          const R = `${V7(qa(_))}px`;
          g.current.style[C === "rtl" ? "paddingLeft" : "paddingRight"] = R, g.current.style.width = `calc(100% + ${R})`;
        }
        return g.current;
      }
    }), []);
    const b = (_) => {
      const C = g.current, k = _.key;
      if (_.ctrlKey || _.metaKey || _.altKey) {
        d && d(_);
        return;
      }
      const A = Rr(C).activeElement;
      if (k === "ArrowDown")
        _.preventDefault(), sp(C, A, u, l, J_);
      else if (k === "ArrowUp")
        _.preventDefault(), sp(C, A, u, l, t4);
      else if (k === "Home")
        _.preventDefault(), sp(C, null, u, l, J_);
      else if (k === "End")
        _.preventDefault(), sp(C, null, u, l, t4);
      else if (k.length === 1) {
        const M = y.current, I = k.toLowerCase(), D = performance.now();
        M.keys.length > 0 && (D - M.lastTime > 500 ? (M.keys = [], M.repeating = !0, M.previousKeyMatched = !0) : M.repeating && I !== M.keys[0] && (M.repeating = !1)), M.lastTime = D, M.keys.push(I);
        const L = A && !M.repeating && H7(A, M);
        M.previousKeyMatched && (L || sp(C, A, !1, l, J_, M)) ? _.preventDefault() : M.previousKeyMatched = !1;
      }
      d && d(_);
    }, v = er(g, n);
    let x = -1;
    T.Children.forEach(a, (_, C) => {
      if (!/* @__PURE__ */ T.isValidElement(_)) {
        x === C && (x += 1, x >= a.length && (x = -1));
        return;
      }
      _.props.disabled || (p === "selectedMenu" && _.props.selected || x === -1) && (x = C), x === C && (_.props.disabled || _.props.muiSkipListHighlight || _.type.muiSkipListHighlight) && (x += 1, x >= a.length && (x = -1));
    });
    const E = T.Children.map(a, (_, C) => {
      if (C === x) {
        const k = {};
        return i && (k.autoFocus = !0), _.props.tabIndex === void 0 && p === "selectedMenu" && (k.tabIndex = 0), /* @__PURE__ */ T.cloneElement(_, k);
      }
      return _;
    });
    return /* @__PURE__ */ S.jsx(xO, {
      role: "menu",
      ref: v,
      className: s,
      onKeyDown: b,
      tabIndex: o ? 0 : -1,
      ...h,
      children: E
    });
  }), q7 = (e) => e.scrollTop;
  function F0(e, t) {
    const {
      timeout: n,
      easing: r,
      style: o = {}
    } = e;
    return {
      duration: o.transitionDuration ?? (typeof n == "number" ? n : n[t.mode] || 0),
      easing: o.transitionTimingFunction ?? (typeof r == "object" ? r[t.mode] : r),
      delay: o.transitionDelay
    };
  }
  function GC(e) {
    return `scale(${e}, ${e ** 2})`;
  }
  const z5e = {
    entering: {
      opacity: 1,
      transform: GC(1)
    },
    entered: {
      opacity: 1,
      transform: "none"
    }
  }, eE = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent), KC = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const {
      addEndListener: r,
      appear: o = !0,
      children: i,
      easing: a,
      in: s,
      onEnter: l,
      onEntered: u,
      onEntering: d,
      onExit: p,
      onExited: h,
      onExiting: g,
      style: y,
      timeout: b = "auto",
      // eslint-disable-next-line react/prop-types
      TransitionComponent: v = Ki,
      ...x
    } = t, E = hF(), _ = T.useRef(), C = ob(), k = T.useRef(null), R = er(k, gm(i), n), A = (V) => (F) => {
      if (V) {
        const G = k.current;
        F === void 0 ? V(G) : V(G, F);
      }
    }, M = A(d), I = A((V, F) => {
      q7(V);
      const {
        duration: G,
        delay: W,
        easing: K
      } = F0({
        style: y,
        timeout: b,
        easing: a
      }, {
        mode: "enter"
      });
      let $;
      b === "auto" ? ($ = C.transitions.getAutoHeightDuration(V.clientHeight), _.current = $) : $ = G, V.style.transition = [C.transitions.create("opacity", {
        duration: $,
        delay: W
      }), C.transitions.create("transform", {
        duration: eE ? $ : $ * 0.666,
        delay: W,
        easing: K
      })].join(","), l && l(V, F);
    }), D = A(u), L = A(g), P = A((V) => {
      const {
        duration: F,
        delay: G,
        easing: W
      } = F0({
        style: y,
        timeout: b,
        easing: a
      }, {
        mode: "exit"
      });
      let K;
      b === "auto" ? (K = C.transitions.getAutoHeightDuration(V.clientHeight), _.current = K) : K = F, V.style.transition = [C.transitions.create("opacity", {
        duration: K,
        delay: G
      }), C.transitions.create("transform", {
        duration: eE ? K : K * 0.666,
        delay: eE ? G : G || K * 0.333,
        easing: W
      })].join(","), V.style.opacity = 0, V.style.transform = GC(0.75), p && p(V);
    }), B = A(h), j = (V) => {
      b === "auto" && E.start(_.current || 0, V), r && r(k.current, V);
    };
    return /* @__PURE__ */ S.jsx(v, {
      appear: o,
      in: s,
      nodeRef: k,
      onEnter: I,
      onEntered: D,
      onEntering: M,
      onExit: P,
      onExited: B,
      onExiting: L,
      addEndListener: j,
      timeout: b === "auto" ? null : b,
      ...x,
      children: (V, {
        ownerState: F,
        ...G
      }) => /* @__PURE__ */ T.cloneElement(i, {
        style: {
          opacity: 0,
          transform: GC(0.75),
          visibility: V === "exited" && !s ? "hidden" : void 0,
          ...z5e[V],
          ...y,
          ...i.props.style
        },
        ref: R,
        ...G
      })
    });
  });
  KC && (KC.muiSupportAuto = !0);
  function B5e(e) {
    const t = Rr(e);
    return t.body === e ? qa(e).innerWidth > t.documentElement.clientWidth : e.scrollHeight > e.clientHeight;
  }
  function Bp(e, t) {
    t ? e.setAttribute("aria-hidden", "true") : e.removeAttribute("aria-hidden");
  }
  function n4(e) {
    return parseInt(qa(e).getComputedStyle(e).paddingRight, 10) || 0;
  }
  function U5e(e) {
    const n = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].includes(e.tagName), r = e.tagName === "INPUT" && e.getAttribute("type") === "hidden";
    return n || r;
  }
  function r4(e, t, n, r, o) {
    const i = [t, n, ...r];
    [].forEach.call(e.children, (a) => {
      const s = !i.includes(a), l = !U5e(a);
      s && l && Bp(a, o);
    });
  }
  function tE(e, t) {
    let n = -1;
    return e.some((r, o) => t(r) ? (n = o, !0) : !1), n;
  }
  function V5e(e, t) {
    const n = [], r = e.container;
    if (!t.disableScrollLock) {
      if (B5e(r)) {
        const a = V7(qa(r));
        n.push({
          value: r.style.paddingRight,
          property: "padding-right",
          el: r
        }), r.style.paddingRight = `${n4(r) + a}px`;
        const s = Rr(r).querySelectorAll(".mui-fixed");
        [].forEach.call(s, (l) => {
          n.push({
            value: l.style.paddingRight,
            property: "padding-right",
            el: l
          }), l.style.paddingRight = `${n4(l) + a}px`;
        });
      }
      let i;
      if (r.parentNode instanceof DocumentFragment)
        i = Rr(r).body;
      else {
        const a = r.parentElement, s = qa(r);
        i = a?.nodeName === "HTML" && s.getComputedStyle(a).overflowY === "scroll" ? a : r;
      }
      n.push({
        value: i.style.overflow,
        property: "overflow",
        el: i
      }, {
        value: i.style.overflowX,
        property: "overflow-x",
        el: i
      }, {
        value: i.style.overflowY,
        property: "overflow-y",
        el: i
      }), i.style.overflow = "hidden";
    }
    return () => {
      n.forEach(({
        value: i,
        el: a,
        property: s
      }) => {
        i ? a.style.setProperty(s, i) : a.style.removeProperty(s);
      });
    };
  }
  function H5e(e) {
    const t = [];
    return [].forEach.call(e.children, (n) => {
      n.getAttribute("aria-hidden") === "true" && t.push(n);
    }), t;
  }
  class q5e {
    constructor() {
      this.modals = [], this.containers = [];
    }
    add(t, n) {
      let r = this.modals.indexOf(t);
      if (r !== -1)
        return r;
      r = this.modals.length, this.modals.push(t), t.modalRef && Bp(t.modalRef, !1);
      const o = H5e(n);
      r4(n, t.mount, t.modalRef, o, !0);
      const i = tE(this.containers, (a) => a.container === n);
      return i !== -1 ? (this.containers[i].modals.push(t), r) : (this.containers.push({
        modals: [t],
        container: n,
        restore: null,
        hiddenSiblings: o
      }), r);
    }
    mount(t, n) {
      const r = tE(this.containers, (i) => i.modals.includes(t)), o = this.containers[r];
      o.restore || (o.restore = V5e(o, n));
    }
    remove(t, n = !0) {
      const r = this.modals.indexOf(t);
      if (r === -1)
        return r;
      const o = tE(this.containers, (a) => a.modals.includes(t)), i = this.containers[o];
      if (i.modals.splice(i.modals.indexOf(t), 1), this.modals.splice(r, 1), i.modals.length === 0)
        i.restore && i.restore(), t.modalRef && Bp(t.modalRef, n), r4(i.container, t.mount, t.modalRef, i.hiddenSiblings, !1), this.containers.splice(o, 1);
      else {
        const a = i.modals[i.modals.length - 1];
        a.modalRef && Bp(a.modalRef, !1);
      }
      return r;
    }
    isTopModal(t) {
      return this.modals.length > 0 && this.modals[this.modals.length - 1] === t;
    }
  }
  const W5e = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
  function G5e(e) {
    const t = parseInt(e.getAttribute("tabindex") || "", 10);
    return Number.isNaN(t) ? e.contentEditable === "true" || (e.nodeName === "AUDIO" || e.nodeName === "VIDEO" || e.nodeName === "DETAILS") && e.getAttribute("tabindex") === null ? 0 : e.tabIndex : t;
  }
  function K5e(e) {
    if (e.tagName !== "INPUT" || e.type !== "radio" || !e.name)
      return !1;
    const t = (r) => e.ownerDocument.querySelector(`input[type="radio"]${r}`);
    let n = t(`[name="${e.name}"]:checked`);
    return n || (n = t(`[name="${e.name}"]`)), n !== e;
  }
  function Y5e(e) {
    return !(e.disabled || e.tagName === "INPUT" && e.type === "hidden" || K5e(e));
  }
  function X5e(e) {
    const t = [], n = [];
    return Array.from(e.querySelectorAll(W5e)).forEach((r, o) => {
      const i = G5e(r);
      i === -1 || !Y5e(r) || (i === 0 ? t.push(r) : n.push({
        documentOrder: o,
        tabIndex: i,
        node: r
      }));
    }), n.sort((r, o) => r.tabIndex === o.tabIndex ? r.documentOrder - o.documentOrder : r.tabIndex - o.tabIndex).map((r) => r.node).concat(t);
  }
  function Z5e() {
    return !0;
  }
  function Q5e(e) {
    const {
      children: t,
      disableAutoFocus: n = !1,
      disableEnforceFocus: r = !1,
      disableRestoreFocus: o = !1,
      getTabbable: i = X5e,
      isEnabled: a = Z5e,
      open: s
    } = e, l = T.useRef(!1), u = T.useRef(null), d = T.useRef(null), p = T.useRef(null), h = T.useRef(null), g = T.useRef(!1), y = T.useRef(null), b = er(gm(t), y), v = T.useRef(null);
    T.useEffect(() => {
      !s || !y.current || (g.current = !n);
    }, [n, s]), T.useEffect(() => {
      if (!s || !y.current)
        return;
      const _ = Rr(y.current);
      return y.current.contains(_.activeElement) || (y.current.hasAttribute("tabIndex") || y.current.setAttribute("tabIndex", "-1"), g.current && y.current.focus()), () => {
        o || (p.current && p.current.focus && (l.current = !0, p.current.focus()), p.current = null);
      };
    }, [s]), T.useEffect(() => {
      if (!s || !y.current)
        return;
      const _ = Rr(y.current), C = (A) => {
        v.current = A, !(r || !a() || A.key !== "Tab") && _.activeElement === y.current && A.shiftKey && (l.current = !0, d.current && d.current.focus());
      }, k = () => {
        const A = y.current;
        if (A === null)
          return;
        if (!_.hasFocus() || !a() || l.current) {
          l.current = !1;
          return;
        }
        if (A.contains(_.activeElement) || r && _.activeElement !== u.current && _.activeElement !== d.current)
          return;
        if (_.activeElement !== h.current)
          h.current = null;
        else if (h.current !== null)
          return;
        if (!g.current)
          return;
        let M = [];
        if ((_.activeElement === u.current || _.activeElement === d.current) && (M = i(y.current)), M.length > 0) {
          const I = !!(v.current?.shiftKey && v.current?.key === "Tab"), D = M[0], L = M[M.length - 1];
          typeof D != "string" && typeof L != "string" && (I ? L.focus() : D.focus());
        } else
          A.focus();
      };
      _.addEventListener("focusin", k), _.addEventListener("keydown", C, !0);
      const R = setInterval(() => {
        _.activeElement && _.activeElement.tagName === "BODY" && k();
      }, 50);
      return () => {
        clearInterval(R), _.removeEventListener("focusin", k), _.removeEventListener("keydown", C, !0);
      };
    }, [n, r, o, a, s, i]);
    const x = (_) => {
      p.current === null && (p.current = _.relatedTarget), g.current = !0, h.current = _.target;
      const C = t.props.onFocus;
      C && C(_);
    }, E = (_) => {
      p.current === null && (p.current = _.relatedTarget), g.current = !0;
    };
    return /* @__PURE__ */ S.jsxs(T.Fragment, {
      children: [/* @__PURE__ */ S.jsx("div", {
        tabIndex: s ? 0 : -1,
        onFocus: E,
        ref: u,
        "data-testid": "sentinelStart"
      }), /* @__PURE__ */ T.cloneElement(t, {
        ref: b,
        onFocus: x
      }), /* @__PURE__ */ S.jsx("div", {
        tabIndex: s ? 0 : -1,
        onFocus: E,
        ref: d,
        "data-testid": "sentinelEnd"
      })]
    });
  }
  function J5e(e) {
    return typeof e == "function" ? e() : e;
  }
  const e3e = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const {
      children: r,
      container: o,
      disablePortal: i = !1
    } = t, [a, s] = T.useState(null), l = er(/* @__PURE__ */ T.isValidElement(r) ? gm(r) : null, n);
    if (Ko(() => {
      i || s(J5e(o) || document.body);
    }, [o, i]), Ko(() => {
      if (a && !i)
        return W3(n, a), () => {
          W3(n, null);
        };
    }, [n, a, i]), i) {
      if (/* @__PURE__ */ T.isValidElement(r)) {
        const u = {
          ref: l
        };
        return /* @__PURE__ */ T.cloneElement(r, u);
      }
      return r;
    }
    return a && /* @__PURE__ */ gc.createPortal(r, a);
  }), t3e = {
    entering: {
      opacity: 1
    },
    entered: {
      opacity: 1
    }
  }, n3e = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ob(), o = {
      enter: r.transitions.duration.enteringScreen,
      exit: r.transitions.duration.leavingScreen
    }, {
      addEndListener: i,
      appear: a = !0,
      children: s,
      easing: l,
      in: u,
      onEnter: d,
      onEntered: p,
      onEntering: h,
      onExit: g,
      onExited: y,
      onExiting: b,
      style: v,
      timeout: x = o,
      // eslint-disable-next-line react/prop-types
      TransitionComponent: E = Ki,
      ..._
    } = t, C = T.useRef(null), k = er(C, gm(s), n), R = (j) => (V) => {
      if (j) {
        const F = C.current;
        V === void 0 ? j(F) : j(F, V);
      }
    }, A = R(h), M = R((j, V) => {
      q7(j);
      const F = F0({
        style: v,
        timeout: x,
        easing: l
      }, {
        mode: "enter"
      });
      j.style.webkitTransition = r.transitions.create("opacity", F), j.style.transition = r.transitions.create("opacity", F), d && d(j, V);
    }), I = R(p), D = R(b), L = R((j) => {
      const V = F0({
        style: v,
        timeout: x,
        easing: l
      }, {
        mode: "exit"
      });
      j.style.webkitTransition = r.transitions.create("opacity", V), j.style.transition = r.transitions.create("opacity", V), g && g(j);
    }), P = R(y), B = (j) => {
      i && i(C.current, j);
    };
    return /* @__PURE__ */ S.jsx(E, {
      appear: a,
      in: u,
      nodeRef: C,
      onEnter: M,
      onEntered: I,
      onEntering: A,
      onExit: L,
      onExited: P,
      onExiting: D,
      addEndListener: B,
      timeout: x,
      ..._,
      children: (j, {
        ownerState: V,
        ...F
      }) => /* @__PURE__ */ T.cloneElement(s, {
        style: {
          opacity: 0,
          visibility: j === "exited" && !u ? "hidden" : void 0,
          ...t3e[j],
          ...v,
          ...s.props.style
        },
        ref: k,
        ...F
      })
    });
  });
  function r3e(e) {
    return it("MuiBackdrop", e);
  }
  rt("MuiBackdrop", ["root", "invisible"]);
  const o3e = (e) => {
    const {
      classes: t,
      invisible: n
    } = e;
    return ot({
      root: ["root", n && "invisible"]
    }, r3e, t);
  }, i3e = Oe("div", {
    name: "MuiBackdrop",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.invisible && t.invisible];
    }
  })({
    position: "fixed",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    WebkitTapHighlightColor: "transparent",
    variants: [{
      props: {
        invisible: !0
      },
      style: {
        backgroundColor: "transparent"
      }
    }]
  }), a3e = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiBackdrop"
    }), {
      children: o,
      className: i,
      component: a = "div",
      invisible: s = !1,
      open: l,
      components: u = {},
      componentsProps: d = {},
      slotProps: p = {},
      slots: h = {},
      TransitionComponent: g,
      transitionDuration: y,
      ...b
    } = r, v = {
      ...r,
      component: a,
      invisible: s
    }, x = o3e(v), E = {
      transition: g,
      root: u.Root,
      ...h
    }, _ = {
      ...d,
      ...p
    }, C = {
      component: a,
      slots: E,
      slotProps: _
    }, [k, R] = dn("root", {
      elementType: i3e,
      externalForwardedProps: C,
      className: je(x.root, i),
      ownerState: v
    }), [A, M] = dn("transition", {
      elementType: n3e,
      externalForwardedProps: C,
      ownerState: v
    });
    return /* @__PURE__ */ S.jsx(A, {
      in: l,
      timeout: y,
      ...b,
      ...M,
      children: /* @__PURE__ */ S.jsx(k, {
        "aria-hidden": !0,
        ...R,
        classes: x,
        ref: n,
        children: o
      })
    });
  });
  function s3e(e) {
    return typeof e == "function" ? e() : e;
  }
  function l3e(e) {
    return e ? e.props.hasOwnProperty("in") : !1;
  }
  const o4 = () => {
  }, nv = new q5e();
  function c3e(e) {
    const {
      container: t,
      disableEscapeKeyDown: n = !1,
      disableScrollLock: r = !1,
      closeAfterTransition: o = !1,
      onTransitionEnter: i,
      onTransitionExited: a,
      children: s,
      onClose: l,
      open: u,
      rootRef: d
    } = e, p = T.useRef({}), h = T.useRef(null), g = T.useRef(null), y = er(g, d), [b, v] = T.useState(!u), x = l3e(s);
    let E = !0;
    (e["aria-hidden"] === "false" || e["aria-hidden"] === !1) && (E = !1);
    const _ = () => Rr(h.current), C = () => (p.current.modalRef = g.current, p.current.mount = h.current, p.current), k = () => {
      nv.mount(C(), {
        disableScrollLock: r
      }), g.current && (g.current.scrollTop = 0);
    }, R = Li(() => {
      const V = s3e(t) || _().body;
      nv.add(C(), V), g.current && k();
    }), A = () => nv.isTopModal(C()), M = Li((V) => {
      h.current = V, V && (u && A() ? k() : g.current && Bp(g.current, E));
    }), I = T.useCallback(() => {
      nv.remove(C(), E);
    }, [E]);
    T.useEffect(() => () => {
      I();
    }, [I]), T.useEffect(() => {
      u ? R() : (!x || !o) && I();
    }, [u, I, x, o, R]);
    const D = (V) => (F) => {
      V.onKeyDown?.(F), !(F.key !== "Escape" || F.which === 229 || // Wait until IME is settled.
      !A()) && (n || (F.stopPropagation(), l && l(F, "escapeKeyDown")));
    }, L = (V) => (F) => {
      V.onClick?.(F), F.target === F.currentTarget && l && l(F, "backdropClick");
    };
    return {
      getRootProps: (V = {}) => {
        const F = Cp(e);
        delete F.onTransitionEnter, delete F.onTransitionExited;
        const G = {
          ...F,
          ...V
        };
        return {
          /*
           * Marking an element with the role presentation indicates to assistive technology
           * that this element should be ignored; it exists to support the web application and
           * is not meant for humans to interact with directly.
           * https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-static-element-interactions.md
           */
          role: "presentation",
          ...G,
          onKeyDown: D(G),
          ref: y
        };
      },
      getBackdropProps: (V = {}) => {
        const F = V;
        return {
          "aria-hidden": !0,
          ...F,
          onClick: L(F),
          open: u
        };
      },
      getTransitionProps: () => {
        const V = () => {
          v(!1), i && i();
        }, F = () => {
          v(!0), a && a(), o && I();
        };
        return {
          onEnter: HC(V, s?.props.onEnter ?? o4),
          onExited: HC(F, s?.props.onExited ?? o4)
        };
      },
      rootRef: y,
      portalRef: M,
      isTopModal: A,
      exited: b,
      hasTransition: x
    };
  }
  function u3e(e) {
    return it("MuiModal", e);
  }
  rt("MuiModal", ["root", "hidden", "backdrop"]);
  const f3e = (e) => {
    const {
      open: t,
      exited: n,
      classes: r
    } = e;
    return ot({
      root: ["root", !t && n && "hidden"],
      backdrop: ["backdrop"]
    }, u3e, r);
  }, d3e = Oe("div", {
    name: "MuiModal",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, !n.open && n.exited && t.hidden];
    }
  })(at(({
    theme: e
  }) => ({
    position: "fixed",
    zIndex: (e.vars || e).zIndex.modal,
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    variants: [{
      props: ({
        ownerState: t
      }) => !t.open && t.exited,
      style: {
        visibility: "hidden"
      }
    }]
  }))), p3e = Oe(a3e, {
    name: "MuiModal",
    slot: "Backdrop"
  })({
    zIndex: -1
  }), h3e = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      name: "MuiModal",
      props: t
    }), {
      BackdropComponent: o = p3e,
      BackdropProps: i,
      classes: a,
      className: s,
      closeAfterTransition: l = !1,
      children: u,
      container: d,
      component: p,
      components: h = {},
      componentsProps: g = {},
      disableAutoFocus: y = !1,
      disableEnforceFocus: b = !1,
      disableEscapeKeyDown: v = !1,
      disablePortal: x = !1,
      disableRestoreFocus: E = !1,
      disableScrollLock: _ = !1,
      hideBackdrop: C = !1,
      keepMounted: k = !1,
      onClose: R,
      onTransitionEnter: A,
      onTransitionExited: M,
      open: I,
      slotProps: D = {},
      slots: L = {},
      // eslint-disable-next-line react/prop-types
      theme: P,
      ...B
    } = r, j = {
      ...r,
      closeAfterTransition: l,
      disableAutoFocus: y,
      disableEnforceFocus: b,
      disableEscapeKeyDown: v,
      disablePortal: x,
      disableRestoreFocus: E,
      disableScrollLock: _,
      hideBackdrop: C,
      keepMounted: k
    }, {
      getRootProps: V,
      getBackdropProps: F,
      getTransitionProps: G,
      portalRef: W,
      isTopModal: K,
      exited: $,
      hasTransition: U
    } = c3e({
      ...j,
      rootRef: n
    }), X = {
      ...j,
      exited: $
    }, z = f3e(X), H = {};
    if (u.props.tabIndex === void 0 && (H.tabIndex = "-1"), U) {
      const {
        onEnter: fe,
        onExited: J
      } = G();
      H.onEnter = fe, H.onExited = J;
    }
    const Y = {
      slots: {
        root: h.Root,
        backdrop: h.Backdrop,
        ...L
      },
      slotProps: {
        ...g,
        ...D
      }
    }, [Q, re] = dn("root", {
      ref: n,
      elementType: d3e,
      externalForwardedProps: {
        ...Y,
        ...B,
        component: p
      },
      getSlotProps: V,
      ownerState: X,
      className: je(s, z?.root, !X.open && X.exited && z?.hidden)
    }), [te, le] = dn("backdrop", {
      ref: i?.ref,
      elementType: o,
      externalForwardedProps: Y,
      shouldForwardComponentProp: !0,
      additionalProps: i,
      getSlotProps: (fe) => F({
        ...fe,
        onClick: (J) => {
          fe?.onClick && fe.onClick(J);
        }
      }),
      className: je(i?.className, z?.backdrop),
      ownerState: X
    });
    return !k && !I && (!U || $) ? null : /* @__PURE__ */ S.jsx(e3e, {
      ref: W,
      container: d,
      disablePortal: x,
      children: /* @__PURE__ */ S.jsxs(Q, {
        ...re,
        children: [!C && o ? /* @__PURE__ */ S.jsx(te, {
          ...le
        }) : null, /* @__PURE__ */ S.jsx(Q5e, {
          disableEnforceFocus: b,
          disableAutoFocus: y,
          disableRestoreFocus: E,
          isEnabled: K,
          open: I,
          children: /* @__PURE__ */ T.cloneElement(u, H)
        })]
      })
    });
  });
  function m3e(e) {
    return it("MuiPopover", e);
  }
  rt("MuiPopover", ["root", "paper"]);
  function i4(e, t) {
    let n = 0;
    return typeof t == "number" ? n = t : t === "center" ? n = e.height / 2 : t === "bottom" && (n = e.height), n;
  }
  function a4(e, t) {
    let n = 0;
    return typeof t == "number" ? n = t : t === "center" ? n = e.width / 2 : t === "right" && (n = e.width), n;
  }
  function s4(e) {
    return [e.horizontal, e.vertical].map((t) => typeof t == "number" ? `${t}px` : t).join(" ");
  }
  function rv(e) {
    return typeof e == "function" ? e() : e;
  }
  const g3e = (e) => {
    const {
      classes: t
    } = e;
    return ot({
      root: ["root"],
      paper: ["paper"]
    }, m3e, t);
  }, y3e = Oe(h3e, {
    name: "MuiPopover",
    slot: "Root"
  })({}), W7 = Oe(T1, {
    name: "MuiPopover",
    slot: "Paper"
  })({
    position: "absolute",
    overflowY: "auto",
    overflowX: "hidden",
    // So we see the popover when it's empty.
    // It's most likely on issue on userland.
    minWidth: 16,
    minHeight: 16,
    maxWidth: "calc(100% - 32px)",
    maxHeight: "calc(100% - 32px)",
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0
  }), v3e = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiPopover"
    }), {
      action: o,
      anchorEl: i,
      anchorOrigin: a = {
        vertical: "top",
        horizontal: "left"
      },
      anchorPosition: s,
      anchorReference: l = "anchorEl",
      children: u,
      className: d,
      container: p,
      elevation: h = 8,
      marginThreshold: g = 16,
      open: y,
      PaperProps: b = {},
      // TODO: remove in v7
      slots: v = {},
      slotProps: x = {},
      transformOrigin: E = {
        vertical: "top",
        horizontal: "left"
      },
      TransitionComponent: _,
      // TODO: remove in v7
      transitionDuration: C = "auto",
      TransitionProps: k = {},
      // TODO: remove in v7
      disableScrollLock: R = !1,
      ...A
    } = r, M = T.useRef(), I = {
      ...r,
      anchorOrigin: a,
      anchorReference: l,
      elevation: h,
      marginThreshold: g,
      transformOrigin: E,
      TransitionComponent: _,
      transitionDuration: C,
      TransitionProps: k
    }, D = g3e(I), L = T.useCallback(() => {
      if (l === "anchorPosition")
        return s;
      const fe = rv(i), ee = (fe && fe.nodeType === 1 ? fe : Rr(M.current).body).getBoundingClientRect();
      return {
        top: ee.top + i4(ee, a.vertical),
        left: ee.left + a4(ee, a.horizontal)
      };
    }, [i, a.horizontal, a.vertical, s, l]), P = T.useCallback((fe) => ({
      vertical: i4(fe, E.vertical),
      horizontal: a4(fe, E.horizontal)
    }), [E.horizontal, E.vertical]), B = T.useCallback((fe) => {
      const J = {
        width: fe.offsetWidth,
        height: fe.offsetHeight
      }, ee = P(J);
      if (l === "none")
        return {
          top: null,
          left: null,
          transformOrigin: s4(ee)
        };
      const ie = L();
      let ae = ie.top - ee.vertical, ge = ie.left - ee.horizontal;
      const Ce = ae + J.height, Ne = ge + J.width, Le = qa(rv(i)), Ve = Le.innerHeight - g, Ke = Le.innerWidth - g;
      if (g !== null && ae < g) {
        const ze = ae - g;
        ae -= ze, ee.vertical += ze;
      } else if (g !== null && Ce > Ve) {
        const ze = Ce - Ve;
        ae -= ze, ee.vertical += ze;
      }
      if (g !== null && ge < g) {
        const ze = ge - g;
        ge -= ze, ee.horizontal += ze;
      } else if (Ne > Ke) {
        const ze = Ne - Ke;
        ge -= ze, ee.horizontal += ze;
      }
      return {
        top: `${Math.round(ae)}px`,
        left: `${Math.round(ge)}px`,
        transformOrigin: s4(ee)
      };
    }, [i, l, L, P, g]), [j, V] = T.useState(y), F = T.useCallback(() => {
      const fe = M.current;
      if (!fe)
        return;
      const J = B(fe);
      J.top !== null && fe.style.setProperty("top", J.top), J.left !== null && (fe.style.left = J.left), fe.style.transformOrigin = J.transformOrigin, V(!0);
    }, [B]);
    T.useEffect(() => (R && window.addEventListener("scroll", F), () => window.removeEventListener("scroll", F)), [i, R, F]);
    const G = () => {
      F();
    }, W = () => {
      V(!1);
    };
    T.useEffect(() => {
      y && F();
    }), T.useImperativeHandle(o, () => y ? {
      updatePosition: () => {
        F();
      }
    } : null, [y, F]), T.useEffect(() => {
      if (!y)
        return;
      const fe = F7(() => {
        F();
      }), J = qa(rv(i));
      return J.addEventListener("resize", fe), () => {
        fe.clear(), J.removeEventListener("resize", fe);
      };
    }, [i, y, F]);
    let K = C;
    const $ = {
      slots: {
        transition: _,
        ...v
      },
      slotProps: {
        transition: k,
        paper: b,
        ...x
      }
    }, [U, X] = dn("transition", {
      elementType: KC,
      externalForwardedProps: $,
      ownerState: I,
      getSlotProps: (fe) => ({
        ...fe,
        onEntering: (J, ee) => {
          fe.onEntering?.(J, ee), G();
        },
        onExited: (J) => {
          fe.onExited?.(J), W();
        }
      }),
      additionalProps: {
        appear: !0,
        in: y
      }
    });
    C === "auto" && !U.muiSupportAuto && (K = void 0);
    const z = p || (i ? Rr(rv(i)).body : void 0), [H, {
      slots: Y,
      slotProps: Q,
      ...re
    }] = dn("root", {
      ref: n,
      elementType: y3e,
      externalForwardedProps: {
        ...$,
        ...A
      },
      shouldForwardComponentProp: !0,
      additionalProps: {
        slots: {
          backdrop: v.backdrop
        },
        slotProps: {
          backdrop: L7(typeof x.backdrop == "function" ? x.backdrop(I) : x.backdrop, {
            invisible: !0
          })
        },
        container: z,
        open: y
      },
      ownerState: I,
      className: je(D.root, d)
    }), [te, le] = dn("paper", {
      ref: M,
      className: D.paper,
      elementType: W7,
      externalForwardedProps: $,
      shouldForwardComponentProp: !0,
      additionalProps: {
        elevation: h,
        style: j ? void 0 : {
          opacity: 0
        }
      },
      ownerState: I
    });
    return /* @__PURE__ */ S.jsx(H, {
      ...re,
      ...!zi(H) && {
        slots: Y,
        slotProps: Q,
        disableScrollLock: R
      },
      children: /* @__PURE__ */ S.jsx(U, {
        ...X,
        timeout: K,
        children: /* @__PURE__ */ S.jsx(te, {
          ...le,
          children: u
        })
      })
    });
  });
  function b3e(e) {
    return it("MuiMenu", e);
  }
  rt("MuiMenu", ["root", "paper", "list"]);
  const x3e = {
    vertical: "top",
    horizontal: "right"
  }, w3e = {
    vertical: "top",
    horizontal: "left"
  }, S3e = (e) => {
    const {
      classes: t
    } = e;
    return ot({
      root: ["root"],
      paper: ["paper"],
      list: ["list"]
    }, b3e, t);
  }, _3e = Oe(v3e, {
    shouldForwardProp: (e) => wr(e) || e === "classes",
    name: "MuiMenu",
    slot: "Root"
  })({}), E3e = Oe(W7, {
    name: "MuiMenu",
    slot: "Paper"
  })({
    // specZ: The maximum height of a simple menu should be one or more rows less than the view
    // height. This ensures a tappable area outside of the simple menu with which to dismiss
    // the menu.
    maxHeight: "calc(100% - 96px)",
    // Add iOS momentum scrolling for iOS < 13.0
    WebkitOverflowScrolling: "touch"
  }), C3e = Oe(L5e, {
    name: "MuiMenu",
    slot: "List"
  })({
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0
  }), k3e = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiMenu"
    }), {
      autoFocus: o = !0,
      children: i,
      className: a,
      disableAutoFocusItem: s = !1,
      MenuListProps: l = {},
      onClose: u,
      open: d,
      PaperProps: p = {},
      PopoverClasses: h,
      transitionDuration: g = "auto",
      TransitionProps: {
        onEntering: y,
        ...b
      } = {},
      variant: v = "selectedMenu",
      slots: x = {},
      slotProps: E = {},
      ..._
    } = r, C = tF(), k = {
      ...r,
      autoFocus: o,
      disableAutoFocusItem: s,
      MenuListProps: l,
      onEntering: y,
      PaperProps: p,
      transitionDuration: g,
      TransitionProps: b,
      variant: v
    }, R = S3e(k), A = o && !s && d, M = T.useRef(null), I = (K, $) => {
      M.current && M.current.adjustStyleForScrollbar(K, {
        direction: C ? "rtl" : "ltr"
      }), y && y(K, $);
    }, D = (K) => {
      K.key === "Tab" && (K.preventDefault(), u && u(K, "tabKeyDown"));
    };
    let L = -1;
    T.Children.map(i, (K, $) => {
      /* @__PURE__ */ T.isValidElement(K) && (K.props.disabled || (v === "selectedMenu" && K.props.selected || L === -1) && (L = $));
    });
    const P = {
      slots: x,
      slotProps: {
        list: l,
        transition: b,
        paper: p,
        ...E
      }
    }, B = Ta({
      elementType: x.root,
      externalSlotProps: E.root,
      ownerState: k,
      className: [R.root, a]
    }), [j, V] = dn("paper", {
      className: R.paper,
      elementType: E3e,
      externalForwardedProps: P,
      shouldForwardComponentProp: !0,
      ownerState: k
    }), [F, G] = dn("list", {
      className: je(R.list, l.className),
      elementType: C3e,
      shouldForwardComponentProp: !0,
      externalForwardedProps: P,
      getSlotProps: (K) => ({
        ...K,
        onKeyDown: ($) => {
          D($), K.onKeyDown?.($);
        }
      }),
      ownerState: k
    }), W = typeof P.slotProps.transition == "function" ? P.slotProps.transition(k) : P.slotProps.transition;
    return /* @__PURE__ */ S.jsx(_3e, {
      onClose: u,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: C ? "right" : "left"
      },
      transformOrigin: C ? x3e : w3e,
      slots: {
        root: x.root,
        paper: j,
        backdrop: x.backdrop,
        ...x.transition && {
          // TODO: pass `slots.transition` directly once `TransitionComponent` is removed from Popover
          transition: x.transition
        }
      },
      slotProps: {
        root: B,
        paper: V,
        backdrop: typeof E.backdrop == "function" ? E.backdrop(k) : E.backdrop,
        transition: {
          ...W,
          onEntering: (...K) => {
            I(...K), W?.onEntering?.(...K);
          }
        }
      },
      open: d,
      ref: n,
      transitionDuration: g,
      ownerState: k,
      ..._,
      classes: h,
      children: /* @__PURE__ */ S.jsx(F, {
        actions: M,
        autoFocus: o && (L === -1 || s),
        autoFocusItem: A,
        variant: v,
        ...G,
        children: i
      })
    });
  });
  function T3e(e) {
    return it("MuiNativeSelect", e);
  }
  const wO = rt("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]), R3e = (e) => {
    const {
      classes: t,
      variant: n,
      disabled: r,
      multiple: o,
      open: i,
      error: a
    } = e, s = {
      select: ["select", n, r && "disabled", o && "multiple", a && "error"],
      icon: ["icon", `icon${$e(n)}`, i && "iconOpen", r && "disabled"]
    };
    return ot(s, T3e, t);
  }, G7 = Oe("select", {
    name: "MuiNativeSelect"
  })(({
    theme: e
  }) => ({
    // Reset
    MozAppearance: "none",
    // Reset
    WebkitAppearance: "none",
    // When interacting quickly, the text can end up selected.
    // Native select can't be selected either.
    userSelect: "none",
    // Reset
    borderRadius: 0,
    cursor: "pointer",
    "&:focus": {
      // Reset Chrome style
      borderRadius: 0
    },
    [`&.${wO.disabled}`]: {
      cursor: "default"
    },
    "&[multiple]": {
      height: "auto"
    },
    "&:not([multiple]) option, &:not([multiple]) optgroup": {
      backgroundColor: (e.vars || e).palette.background.paper
    },
    variants: [{
      props: ({
        ownerState: t
      }) => t.variant !== "filled" && t.variant !== "outlined",
      style: {
        // Bump specificity to allow extending custom inputs
        "&&&": {
          paddingRight: 24,
          minWidth: 16
          // So it doesn't collapse.
        }
      }
    }, {
      props: {
        variant: "filled"
      },
      style: {
        "&&&": {
          paddingRight: 32
        }
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        borderRadius: (e.vars || e).shape.borderRadius,
        "&:focus": {
          borderRadius: (e.vars || e).shape.borderRadius
          // Reset the reset for Chrome style
        },
        "&&&": {
          paddingRight: 32
        }
      }
    }]
  })), O3e = Oe(G7, {
    name: "MuiNativeSelect",
    slot: "Select",
    shouldForwardProp: wr,
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.select, t[n.variant], n.error && t.error, {
        [`&.${wO.multiple}`]: t.multiple
      }];
    }
  })({}), K7 = Oe("svg", {
    name: "MuiNativeSelect"
  })(({
    theme: e
  }) => ({
    // We use a position absolute over a flexbox in order to forward the pointer events
    // to the input and to support wrapping tags..
    position: "absolute",
    right: 0,
    // Center vertically, height is 1em
    top: "calc(50% - .5em)",
    // Don't block pointer events on the select under the icon.
    pointerEvents: "none",
    color: (e.vars || e).palette.action.active,
    [`&.${wO.disabled}`]: {
      color: (e.vars || e).palette.action.disabled
    },
    variants: [{
      props: ({
        ownerState: t
      }) => t.open,
      style: {
        transform: "rotate(180deg)"
      }
    }, {
      props: {
        variant: "filled"
      },
      style: {
        right: 7
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        right: 7
      }
    }]
  })), A3e = Oe(K7, {
    name: "MuiNativeSelect",
    slot: "Icon",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.icon, n.variant && t[`icon${$e(n.variant)}`], n.open && t.iconOpen];
    }
  })({}), N3e = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const {
      className: r,
      disabled: o,
      error: i,
      IconComponent: a,
      inputRef: s,
      variant: l = "standard",
      ...u
    } = t, d = {
      ...t,
      disabled: o,
      variant: l,
      error: i
    }, p = R3e(d);
    return /* @__PURE__ */ S.jsxs(T.Fragment, {
      children: [/* @__PURE__ */ S.jsx(O3e, {
        ownerState: d,
        className: je(p.select, r),
        disabled: o,
        ref: s || n,
        ...u
      }), t.multiple ? null : /* @__PURE__ */ S.jsx(A3e, {
        as: a,
        ownerState: d,
        className: p.icon
      })]
    });
  });
  function Y7(e) {
    return it("MuiSelect", e);
  }
  const lp = rt("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
  var l4;
  const M3e = Oe(G7, {
    name: "MuiSelect",
    slot: "Select",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [
        // Win specificity over the input base
        {
          [`&.${lp.select}`]: t.select
        },
        {
          [`&.${lp.select}`]: t[n.variant]
        },
        {
          [`&.${lp.error}`]: t.error
        },
        {
          [`&.${lp.multiple}`]: t.multiple
        }
      ];
    }
  })({
    // Win specificity over the input base
    [`&.${lp.select}`]: {
      height: "auto",
      // Resets for multiple select with chips
      minHeight: "1.4375em",
      // Required for select\text-field height consistency
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      overflow: "hidden"
    }
  }), P3e = Oe(K7, {
    name: "MuiSelect",
    slot: "Icon",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.icon, n.variant && t[`icon${$e(n.variant)}`], n.open && t.iconOpen];
    }
  })({}), $3e = Oe("input", {
    shouldForwardProp: (e) => ib(e) && e !== "classes",
    name: "MuiSelect",
    slot: "NativeInput"
  })({
    bottom: 0,
    left: 0,
    position: "absolute",
    opacity: 0,
    pointerEvents: "none",
    width: "100%",
    boxSizing: "border-box"
  });
  function c4(e, t) {
    return typeof t == "object" && t !== null ? e === t : String(e) === String(t);
  }
  function I3e(e) {
    return e == null || typeof e == "string" && !e.trim();
  }
  const j3e = (e) => {
    const {
      classes: t,
      variant: n,
      disabled: r,
      multiple: o,
      open: i,
      error: a
    } = e, s = {
      select: ["select", n, r && "disabled", o && "multiple", a && "error"],
      icon: ["icon", `icon${$e(n)}`, i && "iconOpen", r && "disabled"],
      nativeInput: ["nativeInput"]
    };
    return ot(s, Y7, t);
  }, D3e = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const {
      "aria-describedby": r,
      "aria-label": o,
      autoFocus: i,
      autoWidth: a,
      children: s,
      className: l,
      defaultOpen: u,
      defaultValue: d,
      disabled: p,
      displayEmpty: h,
      error: g = !1,
      IconComponent: y,
      inputRef: b,
      labelId: v,
      MenuProps: x = {},
      multiple: E,
      name: _,
      onBlur: C,
      onChange: k,
      onClose: R,
      onFocus: A,
      onOpen: M,
      open: I,
      readOnly: D,
      renderValue: L,
      required: P,
      SelectDisplayProps: B = {},
      tabIndex: j,
      // catching `type` from Input which makes no sense for SelectInput
      type: V,
      value: F,
      variant: G = "standard",
      ...W
    } = t, [K, $] = Ch({
      controlled: F,
      default: d,
      name: "Select"
    }), [U, X] = Ch({
      controlled: I,
      default: u,
      name: "Select"
    }), z = T.useRef(null), H = T.useRef(null), [Y, Q] = T.useState(null), {
      current: re
    } = T.useRef(I != null), [te, le] = T.useState(), fe = er(n, b), J = T.useCallback((Ie) => {
      H.current = Ie, Ie && Q(Ie);
    }, []), ee = Y?.parentNode;
    T.useImperativeHandle(fe, () => ({
      focus: () => {
        H.current.focus();
      },
      node: z.current,
      value: K
    }), [K]), T.useEffect(() => {
      u && U && Y && !re && (le(a ? null : ee.clientWidth), H.current.focus());
    }, [Y, a]), T.useEffect(() => {
      i && H.current.focus();
    }, [i]), T.useEffect(() => {
      if (!v)
        return;
      const Ie = Rr(H.current).getElementById(v);
      if (Ie) {
        const tt = () => {
          getSelection().isCollapsed && H.current.focus();
        };
        return Ie.addEventListener("click", tt), () => {
          Ie.removeEventListener("click", tt);
        };
      }
    }, [v]);
    const ie = (Ie, tt) => {
      Ie ? M && M(tt) : R && R(tt), re || (le(a ? null : ee.clientWidth), X(Ie));
    }, ae = (Ie) => {
      Ie.button === 0 && (Ie.preventDefault(), H.current.focus(), ie(!0, Ie));
    }, ge = (Ie) => {
      ie(!1, Ie);
    }, Ce = T.Children.toArray(s), Ne = (Ie) => {
      const tt = Ce.find((Ct) => Ct.props.value === Ie.target.value);
      tt !== void 0 && ($(tt.props.value), k && k(Ie, tt));
    }, Le = (Ie) => (tt) => {
      let Ct;
      if (tt.currentTarget.hasAttribute("tabindex")) {
        if (E) {
          Ct = Array.isArray(K) ? K.slice() : [];
          const Sn = K.indexOf(Ie.props.value);
          Sn === -1 ? Ct.push(Ie.props.value) : Ct.splice(Sn, 1);
        } else
          Ct = Ie.props.value;
        if (Ie.props.onClick && Ie.props.onClick(tt), K !== Ct && ($(Ct), k)) {
          const Sn = tt.nativeEvent || tt, $o = new Sn.constructor(Sn.type, Sn);
          Object.defineProperty($o, "target", {
            writable: !0,
            value: {
              value: Ct,
              name: _
            }
          }), k($o, Ie);
        }
        E || ie(!1, tt);
      }
    }, Ve = (Ie) => {
      D || [
        " ",
        "ArrowUp",
        "ArrowDown",
        // The native select doesn't respond to enter on macOS, but it's recommended by
        // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
        "Enter"
      ].includes(Ie.key) && (Ie.preventDefault(), ie(!0, Ie));
    }, Ke = Y !== null && U, ze = (Ie) => {
      !Ke && C && (Object.defineProperty(Ie, "target", {
        writable: !0,
        value: {
          value: K,
          name: _
        }
      }), C(Ie));
    };
    delete W["aria-invalid"];
    let Me, ct;
    const wt = [];
    let Re = !1;
    (D0({
      value: K
    }) || h) && (L ? Me = L(K) : Re = !0);
    const oe = Ce.map((Ie) => {
      if (!/* @__PURE__ */ T.isValidElement(Ie))
        return null;
      let tt;
      if (E) {
        if (!Array.isArray(K))
          throw new Error(ja(2));
        tt = K.some((Ct) => c4(Ct, Ie.props.value)), tt && Re && wt.push(Ie.props.children);
      } else
        tt = c4(K, Ie.props.value), tt && Re && (ct = Ie.props.children);
      return /* @__PURE__ */ T.cloneElement(Ie, {
        "aria-selected": tt ? "true" : "false",
        onClick: Le(Ie),
        onKeyUp: (Ct) => {
          Ct.key === " " && Ct.preventDefault(), Ie.props.onKeyUp && Ie.props.onKeyUp(Ct);
        },
        role: "option",
        selected: tt,
        value: void 0,
        // The value is most likely not a valid HTML attribute.
        "data-value": Ie.props.value
        // Instead, we provide it as a data attribute.
      });
    });
    Re && (E ? wt.length === 0 ? Me = null : Me = wt.reduce((Ie, tt, Ct) => (Ie.push(tt), Ct < wt.length - 1 && Ie.push(", "), Ie), []) : Me = ct);
    let ue = te;
    !a && re && Y && (ue = ee.clientWidth);
    let Se;
    typeof j < "u" ? Se = j : Se = p ? null : 0;
    const _e = B.id || (_ ? `mui-component-select-${_}` : void 0), Ae = {
      ...t,
      variant: G,
      value: K,
      open: Ke,
      error: g
    }, Ue = j3e(Ae), Ft = {
      ...x.PaperProps,
      ...typeof x.slotProps?.paper == "function" ? x.slotProps.paper(Ae) : x.slotProps?.paper
    }, ut = {
      ...x.MenuListProps,
      ...typeof x.slotProps?.list == "function" ? x.slotProps.list(Ae) : x.slotProps?.list
    }, sn = Ef();
    return /* @__PURE__ */ S.jsxs(T.Fragment, {
      children: [/* @__PURE__ */ S.jsx(M3e, {
        as: "div",
        ref: J,
        tabIndex: Se,
        role: "combobox",
        "aria-controls": Ke ? sn : void 0,
        "aria-disabled": p ? "true" : void 0,
        "aria-expanded": Ke ? "true" : "false",
        "aria-haspopup": "listbox",
        "aria-label": o,
        "aria-labelledby": [v, _e].filter(Boolean).join(" ") || void 0,
        "aria-describedby": r,
        "aria-required": P ? "true" : void 0,
        "aria-invalid": g ? "true" : void 0,
        onKeyDown: Ve,
        onMouseDown: p || D ? null : ae,
        onBlur: ze,
        onFocus: A,
        ...B,
        ownerState: Ae,
        className: je(B.className, Ue.select, l),
        id: _e,
        children: I3e(Me) ? (
          // notranslate needed while Google Translate will not fix zero-width space issue
          l4 || (l4 = /* @__PURE__ */ S.jsx("span", {
            className: "notranslate",
            "aria-hidden": !0,
            children: ""
          }))
        ) : Me
      }), /* @__PURE__ */ S.jsx($3e, {
        "aria-invalid": g,
        value: Array.isArray(K) ? K.join(",") : K,
        name: _,
        ref: z,
        "aria-hidden": !0,
        onChange: Ne,
        tabIndex: -1,
        disabled: p,
        className: Ue.nativeInput,
        autoFocus: i,
        required: P,
        ...W,
        ownerState: Ae
      }), /* @__PURE__ */ S.jsx(P3e, {
        as: y,
        className: Ue.icon,
        ownerState: Ae
      }), /* @__PURE__ */ S.jsx(k3e, {
        id: `menu-${_ || ""}`,
        anchorEl: ee,
        open: Ke,
        onClose: ge,
        anchorOrigin: {
          vertical: "bottom",
          horizontal: "center"
        },
        transformOrigin: {
          vertical: "top",
          horizontal: "center"
        },
        ...x,
        slotProps: {
          ...x.slotProps,
          list: {
            "aria-labelledby": v,
            role: "listbox",
            "aria-multiselectable": E ? "true" : void 0,
            disableListWrap: !0,
            id: sn,
            ...ut
          },
          paper: {
            ...Ft,
            style: {
              minWidth: ue,
              ...Ft != null ? Ft.style : null
            }
          }
        },
        children: oe
      })]
    });
  }), F3e = co(/* @__PURE__ */ S.jsx("path", {
    d: "M7 10l5 5 5-5z"
  })), L3e = (e) => {
    const {
      classes: t
    } = e, r = ot({
      root: ["root"]
    }, Y7, t);
    return {
      ...t,
      ...r
    };
  }, SO = {
    name: "MuiSelect",
    slot: "Root",
    shouldForwardProp: (e) => wr(e) && e !== "variant"
  }, z3e = Oe(mO, SO)(""), B3e = Oe(yO, SO)(""), U3e = Oe(gO, SO)(""), X7 = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      name: "MuiSelect",
      props: t
    }), {
      autoWidth: o = !1,
      children: i,
      classes: a = {},
      className: s,
      defaultOpen: l = !1,
      displayEmpty: u = !1,
      IconComponent: d = F3e,
      id: p,
      input: h,
      inputProps: g,
      label: y,
      labelId: b,
      MenuProps: v,
      multiple: x = !1,
      native: E = !1,
      onClose: _,
      onOpen: C,
      open: k,
      renderValue: R,
      SelectDisplayProps: A,
      variant: M = "outlined",
      ...I
    } = r, D = E ? N3e : D3e, L = ea(), P = dl({
      props: r,
      muiFormControl: L,
      states: ["variant", "error"]
    }), B = P.variant || M, j = {
      ...r,
      variant: B,
      classes: a
    }, V = L3e(j), {
      root: F,
      ...G
    } = V, W = h || {
      standard: /* @__PURE__ */ S.jsx(z3e, {
        ownerState: j
      }),
      outlined: /* @__PURE__ */ S.jsx(B3e, {
        label: y,
        ownerState: j
      }),
      filled: /* @__PURE__ */ S.jsx(U3e, {
        ownerState: j
      })
    }[B], K = er(n, gm(W));
    return /* @__PURE__ */ S.jsx(T.Fragment, {
      children: /* @__PURE__ */ T.cloneElement(W, {
        // Most of the logic is implemented in `SelectInput`.
        // The `Select` component is a simple API wrapper to expose something better to play with.
        inputComponent: D,
        inputProps: {
          children: i,
          error: P.error,
          IconComponent: d,
          variant: B,
          type: void 0,
          // We render a select. We can ignore the type provided by the `Input`.
          multiple: x,
          ...E ? {
            id: p
          } : {
            autoWidth: o,
            defaultOpen: l,
            displayEmpty: u,
            labelId: b,
            MenuProps: v,
            onClose: _,
            onOpen: C,
            open: k,
            renderValue: R,
            SelectDisplayProps: {
              id: p,
              ...A
            }
          },
          ...g,
          classes: g ? vr(G, g.classes) : G,
          ...h ? h.props.inputProps : {}
        },
        ...(x && E || u) && B === "outlined" ? {
          notched: !0
        } : {},
        ref: K,
        className: je(W.props.className, s, V.root),
        // If a custom input is provided via 'input' prop, do not allow 'variant' to be propagated to it's root element. See https://github.com/mui/material-ui/issues/33894.
        ...!h && {
          variant: B
        },
        ...I
      })
    });
  });
  X7.muiName = "Select";
  function V3e(e) {
    return it("MuiTextField", e);
  }
  rt("MuiTextField", ["root"]);
  const H3e = {
    standard: mO,
    filled: gO,
    outlined: yO
  }, q3e = (e) => {
    const {
      classes: t
    } = e;
    return ot({
      root: ["root"]
    }, V3e, t);
  }, W3e = Oe(vO, {
    name: "MuiTextField",
    slot: "Root"
  })({}), _O = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiTextField"
    }), {
      autoComplete: o,
      autoFocus: i = !1,
      children: a,
      className: s,
      color: l = "primary",
      defaultValue: u,
      disabled: d = !1,
      error: p = !1,
      FormHelperTextProps: h,
      fullWidth: g = !1,
      helperText: y,
      id: b,
      InputLabelProps: v,
      inputProps: x,
      InputProps: E,
      inputRef: _,
      label: C,
      maxRows: k,
      minRows: R,
      multiline: A = !1,
      name: M,
      onBlur: I,
      onChange: D,
      onFocus: L,
      placeholder: P,
      required: B = !1,
      rows: j,
      select: V = !1,
      SelectProps: F,
      slots: G = {},
      slotProps: W = {},
      type: K,
      value: $,
      variant: U = "outlined",
      ...X
    } = r, z = {
      ...r,
      autoFocus: i,
      color: l,
      disabled: d,
      error: p,
      fullWidth: g,
      multiline: A,
      required: B,
      select: V,
      variant: U
    }, H = q3e(z), Y = Ef(b), Q = y && Y ? `${Y}-helper-text` : void 0, re = C && Y ? `${Y}-label` : void 0, te = H3e[U], le = {
      slots: G,
      slotProps: {
        input: E,
        inputLabel: v,
        htmlInput: x,
        formHelperText: h,
        select: F,
        ...W
      }
    }, fe = {}, J = le.slotProps.inputLabel;
    U === "outlined" && (J && typeof J.shrink < "u" && (fe.notched = J.shrink), fe.label = C), V && ((!F || !F.native) && (fe.id = void 0), fe["aria-describedby"] = void 0);
    const [ee, ie] = dn("root", {
      elementType: W3e,
      shouldForwardComponentProp: !0,
      externalForwardedProps: {
        ...le,
        ...X
      },
      ownerState: z,
      className: je(H.root, s),
      ref: n,
      additionalProps: {
        disabled: d,
        error: p,
        fullWidth: g,
        required: B,
        color: l,
        variant: U
      }
    }), [ae, ge] = dn("input", {
      elementType: te,
      externalForwardedProps: le,
      additionalProps: fe,
      ownerState: z
    }), [Ce, Ne] = dn("inputLabel", {
      elementType: O5e,
      externalForwardedProps: le,
      ownerState: z
    }), [Le, Ve] = dn("htmlInput", {
      elementType: "input",
      externalForwardedProps: le,
      ownerState: z
    }), [Ke, ze] = dn("formHelperText", {
      elementType: bO,
      externalForwardedProps: le,
      ownerState: z
    }), [Me, ct] = dn("select", {
      elementType: X7,
      externalForwardedProps: le,
      ownerState: z
    }), wt = /* @__PURE__ */ S.jsx(ae, {
      "aria-describedby": Q,
      autoComplete: o,
      autoFocus: i,
      defaultValue: u,
      fullWidth: g,
      multiline: A,
      name: M,
      rows: j,
      maxRows: k,
      minRows: R,
      type: K,
      value: $,
      id: Y,
      inputRef: _,
      onBlur: I,
      onChange: D,
      onFocus: L,
      placeholder: P,
      inputProps: Ve,
      slots: {
        input: G.htmlInput ? Le : void 0
      },
      ...ge
    });
    return /* @__PURE__ */ S.jsxs(ee, {
      ...ie,
      children: [C != null && C !== "" && /* @__PURE__ */ S.jsx(Ce, {
        htmlFor: Y,
        id: re,
        ...Ne,
        children: C
      }), V ? /* @__PURE__ */ S.jsx(Me, {
        "aria-describedby": Q,
        id: Y,
        labelId: re,
        value: $,
        input: wt,
        ...ct,
        children: a
      }) : wt, y && /* @__PURE__ */ S.jsx(Ke, {
        id: Q,
        ...ze,
        children: y
      })]
    });
  }), G3e = ["date", "datetime-local", "file", "time"];
  function K3e(e) {
    const {
      id: t,
      name: n,
      // remove this from textFieldProps
      htmlName: r,
      placeholder: o,
      required: i,
      readonly: a,
      disabled: s,
      type: l,
      label: u,
      hideLabel: d,
      hideError: p,
      value: h,
      onChange: g,
      onChangeOverride: y,
      onBlur: b,
      onFocus: v,
      autofocus: x,
      options: E,
      schema: _,
      uiSchema: C,
      rawErrors: k = [],
      errorSchema: R,
      registry: A,
      InputLabelProps: M,
      ...I
    } = e, D = i7(_, l, E), { step: L, min: P, max: B, accept: j, ...V } = D, F = { step: L, min: P, max: B, accept: j, ..._.examples ? { list: Eh(t) } : void 0 }, G = ({ target: { value: U } }) => g(U === "" ? E.emptyValue : U), W = ({ target: U }) => b(t, U && U.value), K = ({ target: U }) => v(t, U && U.value), $ = G3e.includes(l) ? {
      ...M,
      shrink: !0
    } : M;
    return S.jsxs(S.Fragment, { children: [S.jsx(_O, { id: t, name: r || t, placeholder: o, label: Rc(u || void 0, d, void 0), autoFocus: x, required: i, disabled: s || a, slotProps: { htmlInput: F, inputLabel: $ }, ...V, value: h || h === 0 ? h : "", error: k.length > 0, onChange: y || G, onBlur: W, onFocus: K, ...I, "aria-describedby": po(t, !!_.examples) }), Array.isArray(_.examples) && S.jsx("datalist", { id: Eh(t), children: _.examples.concat(_.default && !_.examples.includes(_.default) ? [_.default] : []).map((U) => S.jsx("option", { value: U }, U)) })] });
  }
  function Y3e(e) {
    return it("MuiTypography", e);
  }
  const u4 = rt("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]), X3e = {
    primary: !0,
    secondary: !0,
    error: !0,
    info: !0,
    success: !0,
    warning: !0,
    textPrimary: !0,
    textSecondary: !0,
    textDisabled: !0
  }, Z3e = kZ(), Q3e = (e) => {
    const {
      align: t,
      gutterBottom: n,
      noWrap: r,
      paragraph: o,
      variant: i,
      classes: a
    } = e, s = {
      root: ["root", i, e.align !== "inherit" && `align${$e(t)}`, n && "gutterBottom", r && "noWrap", o && "paragraph"]
    };
    return ot(s, Y3e, a);
  }, J3e = Oe("span", {
    name: "MuiTypography",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.variant && t[n.variant], n.align !== "inherit" && t[`align${$e(n.align)}`], n.noWrap && t.noWrap, n.gutterBottom && t.gutterBottom, n.paragraph && t.paragraph];
    }
  })(at(({
    theme: e
  }) => ({
    margin: 0,
    variants: [{
      props: {
        variant: "inherit"
      },
      style: {
        // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
        font: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit"
      }
    }, ...Object.entries(e.typography).filter(([t, n]) => t !== "inherit" && n && typeof n == "object").map(([t, n]) => ({
      props: {
        variant: t
      },
      style: n
    })), ...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        color: (e.vars || e).palette[t].main
      }
    })), ...Object.entries(e.palette?.text || {}).filter(([, t]) => typeof t == "string").map(([t]) => ({
      props: {
        color: `text${$e(t)}`
      },
      style: {
        color: (e.vars || e).palette.text[t]
      }
    })), {
      props: ({
        ownerState: t
      }) => t.align !== "inherit",
      style: {
        textAlign: "var(--Typography-textAlign)"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.noWrap,
      style: {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.gutterBottom,
      style: {
        marginBottom: "0.35em"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.paragraph,
      style: {
        marginBottom: 16
      }
    }]
  }))), f4 = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    subtitle1: "h6",
    subtitle2: "h6",
    body1: "p",
    body2: "p",
    inherit: "p"
  }, ji = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const {
      color: r,
      ...o
    } = lt({
      props: t,
      name: "MuiTypography"
    }), i = !X3e[r], a = Z3e({
      ...o,
      ...i && {
        color: r
      }
    }), {
      align: s = "inherit",
      className: l,
      component: u,
      gutterBottom: d = !1,
      noWrap: p = !1,
      paragraph: h = !1,
      variant: g = "body1",
      variantMapping: y = f4,
      ...b
    } = a, v = {
      ...a,
      align: s,
      color: r,
      className: l,
      component: u,
      gutterBottom: d,
      noWrap: p,
      paragraph: h,
      variant: g,
      variantMapping: y
    }, x = u || (h ? "p" : y[g] || f4[g]) || "span", E = Q3e(v);
    return /* @__PURE__ */ S.jsx(J3e, {
      as: x,
      ref: n,
      className: je(E.root, l),
      ...b,
      ownerState: v,
      style: {
        ...s !== "inherit" && {
          "--Typography-textAlign": s
        },
        ...b.style
      }
    });
  });
  function e4e(e) {
    const { id: t, description: n, registry: r, uiSchema: o } = e;
    return n ? S.jsx(ji, { id: t, variant: "subtitle2", style: { marginTop: "5px" }, children: S.jsx(fO, { description: n, registry: r, uiSchema: o }) }) : null;
  }
  const t4e = co(/* @__PURE__ */ S.jsx("path", {
    d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m1 15h-2v-2h2zm0-4h-2V7h2z"
  }));
  function n4e(e) {
    return it("MuiListItem", e);
  }
  rt("MuiListItem", ["root", "container", "dense", "alignItemsFlexStart", "divider", "gutters", "padding", "secondaryAction"]);
  const r4e = rt("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"]);
  function o4e(e) {
    return it("MuiListItemSecondaryAction", e);
  }
  rt("MuiListItemSecondaryAction", ["root", "disableGutters"]);
  const i4e = (e) => {
    const {
      disableGutters: t,
      classes: n
    } = e;
    return ot({
      root: ["root", t && "disableGutters"]
    }, o4e, n);
  }, a4e = Oe("div", {
    name: "MuiListItemSecondaryAction",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.disableGutters && t.disableGutters];
    }
  })({
    position: "absolute",
    right: 16,
    top: "50%",
    transform: "translateY(-50%)",
    variants: [{
      props: ({
        ownerState: e
      }) => e.disableGutters,
      style: {
        right: 0
      }
    }]
  }), Z7 = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiListItemSecondaryAction"
    }), {
      className: o,
      ...i
    } = r, a = T.useContext(Ia), s = {
      ...r,
      disableGutters: a.disableGutters
    }, l = i4e(s);
    return /* @__PURE__ */ S.jsx(a4e, {
      className: je(l.root, o),
      ownerState: s,
      ref: n,
      ...i
    });
  });
  Z7.muiName = "ListItemSecondaryAction";
  const s4e = (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.dense && t.dense, n.alignItems === "flex-start" && t.alignItemsFlexStart, n.divider && t.divider, !n.disableGutters && t.gutters, !n.disablePadding && t.padding, n.hasSecondaryAction && t.secondaryAction];
  }, l4e = (e) => {
    const {
      alignItems: t,
      classes: n,
      dense: r,
      disableGutters: o,
      disablePadding: i,
      divider: a,
      hasSecondaryAction: s
    } = e;
    return ot({
      root: ["root", r && "dense", !o && "gutters", !i && "padding", a && "divider", t === "flex-start" && "alignItemsFlexStart", s && "secondaryAction"],
      container: ["container"]
    }, n4e, n);
  }, c4e = Oe("div", {
    name: "MuiListItem",
    slot: "Root",
    overridesResolver: s4e
  })(at(({
    theme: e
  }) => ({
    display: "flex",
    justifyContent: "flex-start",
    alignItems: "center",
    position: "relative",
    textDecoration: "none",
    width: "100%",
    boxSizing: "border-box",
    textAlign: "left",
    variants: [{
      props: ({
        ownerState: t
      }) => !t.disablePadding,
      style: {
        paddingTop: 8,
        paddingBottom: 8
      }
    }, {
      props: ({
        ownerState: t
      }) => !t.disablePadding && t.dense,
      style: {
        paddingTop: 4,
        paddingBottom: 4
      }
    }, {
      props: ({
        ownerState: t
      }) => !t.disablePadding && !t.disableGutters,
      style: {
        paddingLeft: 16,
        paddingRight: 16
      }
    }, {
      props: ({
        ownerState: t
      }) => !t.disablePadding && !!t.secondaryAction,
      style: {
        // Add some space to avoid collision as `ListItemSecondaryAction`
        // is absolutely positioned.
        paddingRight: 48
      }
    }, {
      props: ({
        ownerState: t
      }) => !!t.secondaryAction,
      style: {
        [`& > .${r4e.root}`]: {
          paddingRight: 48
        }
      }
    }, {
      props: {
        alignItems: "flex-start"
      },
      style: {
        alignItems: "flex-start"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.divider,
      style: {
        borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
        backgroundClip: "padding-box"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.button,
      style: {
        transition: e.transitions.create("background-color", {
          duration: e.transitions.duration.shortest
        }),
        "&:hover": {
          textDecoration: "none",
          backgroundColor: (e.vars || e).palette.action.hover,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }
      }
    }, {
      props: ({
        ownerState: t
      }) => t.hasSecondaryAction,
      style: {
        // Add some space to avoid collision as `ListItemSecondaryAction`
        // is absolutely positioned.
        paddingRight: 48
      }
    }]
  }))), u4e = Oe("li", {
    name: "MuiListItem",
    slot: "Container"
  })({
    position: "relative"
  }), Q7 = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiListItem"
    }), {
      alignItems: o = "center",
      children: i,
      className: a,
      component: s,
      components: l = {},
      componentsProps: u = {},
      ContainerComponent: d = "li",
      ContainerProps: {
        className: p,
        ...h
      } = {},
      dense: g = !1,
      disableGutters: y = !1,
      disablePadding: b = !1,
      divider: v = !1,
      secondaryAction: x,
      slotProps: E = {},
      slots: _ = {},
      ...C
    } = r, k = T.useContext(Ia), R = T.useMemo(() => ({
      dense: g || k.dense || !1,
      alignItems: o,
      disableGutters: y
    }), [o, k.dense, g, y]), A = T.useRef(null), M = T.Children.toArray(i), I = M.length && Ep(M[M.length - 1], ["ListItemSecondaryAction"]), D = {
      ...r,
      alignItems: o,
      dense: R.dense,
      disableGutters: y,
      disablePadding: b,
      divider: v,
      hasSecondaryAction: I
    }, L = l4e(D), P = er(A, n), B = _.root || l.Root || c4e, j = E.root || u.root || {}, V = {
      className: je(L.root, j.className, a),
      ...C
    };
    let F = s || "li";
    return I ? (F = !V.component && !s ? "div" : F, d === "li" && (F === "li" ? F = "div" : V.component === "li" && (V.component = "div")), /* @__PURE__ */ S.jsx(Ia.Provider, {
      value: R,
      children: /* @__PURE__ */ S.jsxs(u4e, {
        as: d,
        className: je(L.container, p),
        ref: P,
        ownerState: D,
        ...h,
        children: [/* @__PURE__ */ S.jsx(B, {
          ...j,
          ...!zi(B) && {
            as: F,
            ownerState: {
              ...D,
              ...j.ownerState
            }
          },
          ...V,
          children: M
        }), M.pop()]
      })
    })) : /* @__PURE__ */ S.jsx(Ia.Provider, {
      value: R,
      children: /* @__PURE__ */ S.jsxs(B, {
        ...j,
        as: F,
        ref: P,
        ...!zi(B) && {
          ownerState: {
            ...D,
            ...j.ownerState
          }
        },
        ...V,
        children: [M, x && /* @__PURE__ */ S.jsx(Z7, {
          children: x
        })]
      })
    });
  });
  function f4e(e) {
    return it("MuiListItemIcon", e);
  }
  const d4 = rt("MuiListItemIcon", ["root", "alignItemsFlexStart"]), d4e = (e) => {
    const {
      alignItems: t,
      classes: n
    } = e;
    return ot({
      root: ["root", t === "flex-start" && "alignItemsFlexStart"]
    }, f4e, n);
  }, p4e = Oe("div", {
    name: "MuiListItemIcon",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.alignItems === "flex-start" && t.alignItemsFlexStart];
    }
  })(at(({
    theme: e
  }) => ({
    minWidth: 56,
    color: (e.vars || e).palette.action.active,
    flexShrink: 0,
    display: "inline-flex",
    variants: [{
      props: {
        alignItems: "flex-start"
      },
      style: {
        marginTop: 8
      }
    }]
  }))), h4e = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiListItemIcon"
    }), {
      className: o,
      ...i
    } = r, a = T.useContext(Ia), s = {
      ...r,
      alignItems: a.alignItems
    }, l = d4e(s);
    return /* @__PURE__ */ S.jsx(p4e, {
      className: je(l.root, o),
      ownerState: s,
      ref: n,
      ...i
    });
  });
  function m4e(e) {
    return it("MuiListItemText", e);
  }
  const Bu = rt("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]), g4e = (e) => {
    const {
      classes: t,
      inset: n,
      primary: r,
      secondary: o,
      dense: i
    } = e;
    return ot({
      root: ["root", n && "inset", i && "dense", r && o && "multiline"],
      primary: ["primary"],
      secondary: ["secondary"]
    }, m4e, t);
  }, y4e = Oe("div", {
    name: "MuiListItemText",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [{
        [`& .${Bu.primary}`]: t.primary
      }, {
        [`& .${Bu.secondary}`]: t.secondary
      }, t.root, n.inset && t.inset, n.primary && n.secondary && t.multiline, n.dense && t.dense];
    }
  })({
    flex: "1 1 auto",
    minWidth: 0,
    marginTop: 4,
    marginBottom: 4,
    [`.${u4.root}:where(& .${Bu.primary})`]: {
      display: "block"
    },
    [`.${u4.root}:where(& .${Bu.secondary})`]: {
      display: "block"
    },
    variants: [{
      props: ({
        ownerState: e
      }) => e.primary && e.secondary,
      style: {
        marginTop: 6,
        marginBottom: 6
      }
    }, {
      props: ({
        ownerState: e
      }) => e.inset,
      style: {
        paddingLeft: 56
      }
    }]
  }), v4e = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiListItemText"
    }), {
      children: o,
      className: i,
      disableTypography: a = !1,
      inset: s = !1,
      primary: l,
      primaryTypographyProps: u,
      secondary: d,
      secondaryTypographyProps: p,
      slots: h = {},
      slotProps: g = {},
      ...y
    } = r, {
      dense: b
    } = T.useContext(Ia);
    let v = l ?? o, x = d;
    const E = {
      ...r,
      disableTypography: a,
      inset: s,
      primary: !!v,
      secondary: !!x,
      dense: b
    }, _ = g4e(E), C = {
      slots: h,
      slotProps: {
        primary: u,
        secondary: p,
        ...g
      }
    }, [k, R] = dn("root", {
      className: je(_.root, i),
      elementType: y4e,
      externalForwardedProps: {
        ...C,
        ...y
      },
      ownerState: E,
      ref: n
    }), [A, M] = dn("primary", {
      className: _.primary,
      elementType: ji,
      externalForwardedProps: C,
      ownerState: E
    }), [I, D] = dn("secondary", {
      className: _.secondary,
      elementType: ji,
      externalForwardedProps: C,
      ownerState: E
    });
    return v != null && v.type !== ji && !a && (v = /* @__PURE__ */ S.jsx(A, {
      variant: b ? "body2" : "body1",
      component: M?.variant ? void 0 : "span",
      ...M,
      children: v
    })), x != null && x.type !== ji && !a && (x = /* @__PURE__ */ S.jsx(I, {
      variant: "body2",
      color: "textSecondary",
      ...D,
      children: x
    })), /* @__PURE__ */ S.jsxs(k, {
      ...R,
      children: [v, x]
    });
  });
  function b4e({ errors: e, registry: t }) {
    const { translateString: n } = t;
    return S.jsx(T1, { elevation: 2, children: S.jsxs(sl, { mb: 2, p: 2, children: [S.jsx(ji, { variant: "h6", children: n(bt.ErrorsLabel) }), S.jsx(xO, { dense: !0, children: e.map((r, o) => S.jsxs(Q7, { children: [S.jsx(h4e, { children: S.jsx(t4e, { color: "error" }) }), S.jsx(v4e, { primary: r.stack })] }, o)) })] }) });
  }
  const x4e = co(/* @__PURE__ */ S.jsx("path", {
    d: "m20 12-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8z"
  })), w4e = co(/* @__PURE__ */ S.jsx("path", {
    d: "m4 12 1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8z"
  })), S4e = co(/* @__PURE__ */ S.jsx("path", {
    d: "M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"
  })), _4e = co(/* @__PURE__ */ S.jsx("path", {
    d: "M19 13H5v-2h14z"
  }));
  function ym(e) {
    const { icon: t, color: n, uiSchema: r, registry: o, ...i } = e;
    return S.jsx(U7, { ...i, size: "small", color: n, children: t });
  }
  function E4e(e) {
    const { registry: { translateString: t } } = e;
    return S.jsx(ym, { title: t(bt.CopyButton), ...e, icon: S.jsx(S4e, { fontSize: "small" }) });
  }
  function C4e(e) {
    const { registry: { translateString: t } } = e;
    return S.jsx(ym, { title: t(bt.MoveDownButton), ...e, icon: S.jsx(x4e, { fontSize: "small" }) });
  }
  function k4e(e) {
    const { registry: { translateString: t } } = e;
    return S.jsx(ym, { title: t(bt.MoveUpButton), ...e, icon: S.jsx(w4e, { fontSize: "small" }) });
  }
  function J7(e) {
    const { iconType: t, ...n } = e, { registry: { translateString: r } } = n;
    return S.jsx(ym, { title: r(bt.RemoveButton), ...n, color: "error", icon: S.jsx(_4e, { fontSize: t === "default" ? void 0 : "small" }) });
  }
  function T4e(e) {
    const { errors: t = [], fieldPathId: n } = e;
    if (t.length === 0)
      return null;
    const r = JR(n);
    return S.jsx(xO, { id: r, dense: !0, disablePadding: !0, children: t.map((o, i) => S.jsx(Q7, { disableGutters: !0, children: S.jsx(bO, { component: "div", id: `${r}-${i}`, children: o }) }, i)) });
  }
  function R4e(e) {
    const { fieldPathId: t, help: n, uiSchema: r, registry: o } = e;
    return n ? S.jsx(bO, { component: "div", id: eO(t), style: { marginTop: "5px" }, children: S.jsx(dO, { help: n, registry: o, uiSchema: r }) }) : null;
  }
  function O4e(e) {
    const { id: t, children: n, classNames: r, style: o, disabled: i, displayLabel: a, hidden: s, label: l, onKeyRename: u, onKeyRenameBlur: d, onRemoveProperty: p, readonly: h, required: g, rawErrors: y = [], errors: b, help: v, description: x, rawDescription: E, schema: _, uiSchema: C, registry: k } = e, R = Ze(C), A = et("WrapIfAdditionalTemplate", k, R);
    if (s)
      return S.jsx("div", { style: { display: "none" }, children: n });
    const M = R.widget === "checkbox";
    return S.jsx(A, { classNames: r, style: o, disabled: i, id: t, label: l, displayLabel: a, rawDescription: E, onKeyRename: u, onKeyRenameBlur: d, onRemoveProperty: p, readonly: h, required: g, schema: _, uiSchema: C, registry: k, children: S.jsxs(vO, { fullWidth: !0, error: !!y.length, required: g, children: [n, a && !M && E ? S.jsx(ji, { variant: "caption", color: "textSecondary", children: x }) : null, b, v] }) });
  }
  function A4e(e) {
    const { children: t, column: n, ...r } = e;
    return S.jsx(cr, { container: !n, ...r, children: t });
  }
  function N4e(e) {
    const { optionSchemaField: t, selector: n } = e;
    return S.jsxs(sl, { sx: { mb: 2 }, children: [S.jsx(vO, { fullWidth: !0, sx: { mb: 2 }, children: n }), t] });
  }
  function M4e(e) {
    const { description: t, title: n, properties: r, required: o, disabled: i, readonly: a, uiSchema: s, fieldPathId: l, schema: u, formData: d, optionalDataControl: p, onAddProperty: h, registry: g } = e, y = Ze(s), b = et("TitleFieldTemplate", g, y), v = et("DescriptionFieldTemplate", g, y), x = !a && !i, { ButtonTemplates: { AddButton: E } } = g.templates;
    return S.jsxs(S.Fragment, { children: [n && S.jsx(b, { id: b1(l), title: n, required: o, schema: u, uiSchema: s, registry: g, optionalDataControl: x ? p : void 0 }), t && S.jsx(v, { id: Tc(l), description: t, schema: u, uiSchema: s, registry: g }), S.jsxs(cr, { container: !0, spacing: 2, style: { marginTop: "10px" }, children: [x ? void 0 : p, r.map((_, C) => (
      // Remove the <Grid> if the inner element is hidden as the <Grid>
      // itself would otherwise still take up space.
      _.hidden ? _.content : S.jsx(cr, { size: { xs: 12 }, style: { marginBottom: "10px" }, children: _.content }, C)
    ))] }), VV(u, s, d) && S.jsx(cr, { container: !0, justifyContent: "flex-end", children: S.jsx(cr, { children: S.jsx(E, { id: $i(l, "add"), className: "rjsf-object-property-expand", onClick: h, disabled: i || a, uiSchema: s, registry: g }) }) })] });
  }
  function P4e(e) {
    const { id: t, registry: n, label: r, onAddClick: o, onRemoveClick: i } = e;
    return o ? S.jsx(ym, { id: t, registry: n, className: "rjsf-add-optional-data", onClick: o, title: r, icon: S.jsx(z7, { fontSize: "small" }) }) : i ? S.jsx(J7, { id: t, registry: n, className: "rjsf-remove-optional-data", onClick: i, title: r }) : S.jsx("em", { id: t, children: r });
  }
  function $4e(e) {
    return it("MuiButton", e);
  }
  const zl = rt("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge", "loading", "loadingWrapper", "loadingIconPlaceholder", "loadingIndicator", "loadingPositionCenter", "loadingPositionStart", "loadingPositionEnd"]), I4e = /* @__PURE__ */ T.createContext({}), j4e = /* @__PURE__ */ T.createContext(void 0), D4e = (e) => {
    const {
      color: t,
      disableElevation: n,
      fullWidth: r,
      size: o,
      variant: i,
      loading: a,
      loadingPosition: s,
      classes: l
    } = e, u = {
      root: ["root", a && "loading", i, `${i}${$e(t)}`, `size${$e(o)}`, `${i}Size${$e(o)}`, `color${$e(t)}`, n && "disableElevation", r && "fullWidth", a && `loadingPosition${$e(s)}`],
      startIcon: ["icon", "startIcon", `iconSize${$e(o)}`],
      endIcon: ["icon", "endIcon", `iconSize${$e(o)}`],
      loadingIndicator: ["loadingIndicator"],
      loadingWrapper: ["loadingWrapper"]
    }, d = ot(u, $4e, l);
    return {
      ...l,
      // forward the focused, disabled, etc. classes to the ButtonBase
      ...d
    };
  }, eq = [{
    props: {
      size: "small"
    },
    style: {
      "& > *:nth-of-type(1)": {
        fontSize: 18
      }
    }
  }, {
    props: {
      size: "medium"
    },
    style: {
      "& > *:nth-of-type(1)": {
        fontSize: 20
      }
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      "& > *:nth-of-type(1)": {
        fontSize: 22
      }
    }
  }], F4e = Oe(Ih, {
    shouldForwardProp: (e) => wr(e) || e === "classes",
    name: "MuiButton",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[n.variant], t[`${n.variant}${$e(n.color)}`], t[`size${$e(n.size)}`], t[`${n.variant}Size${$e(n.size)}`], n.color === "inherit" && t.colorInherit, n.disableElevation && t.disableElevation, n.fullWidth && t.fullWidth, n.loading && t.loading];
    }
  })(at(({
    theme: e
  }) => {
    const t = e.palette.mode === "light" ? e.palette.grey[300] : e.palette.grey[800], n = e.palette.mode === "light" ? e.palette.grey.A100 : e.palette.grey[700];
    return {
      ...e.typography.button,
      minWidth: 64,
      padding: "6px 16px",
      border: 0,
      borderRadius: (e.vars || e).shape.borderRadius,
      transition: e.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
        duration: e.transitions.duration.short
      }),
      "&:hover": {
        textDecoration: "none"
      },
      [`&.${zl.disabled}`]: {
        color: (e.vars || e).palette.action.disabled
      },
      variants: [{
        props: {
          variant: "contained"
        },
        style: {
          color: "var(--variant-containedColor)",
          backgroundColor: "var(--variant-containedBg)",
          boxShadow: (e.vars || e).shadows[2],
          "&:hover": {
            boxShadow: (e.vars || e).shadows[4],
            // Reset on touch devices, it doesn't add specificity
            "@media (hover: none)": {
              boxShadow: (e.vars || e).shadows[2]
            }
          },
          "&:active": {
            boxShadow: (e.vars || e).shadows[8]
          },
          [`&.${zl.focusVisible}`]: {
            boxShadow: (e.vars || e).shadows[6]
          },
          [`&.${zl.disabled}`]: {
            color: (e.vars || e).palette.action.disabled,
            boxShadow: (e.vars || e).shadows[0],
            backgroundColor: (e.vars || e).palette.action.disabledBackground
          }
        }
      }, {
        props: {
          variant: "outlined"
        },
        style: {
          padding: "5px 15px",
          border: "1px solid currentColor",
          borderColor: "var(--variant-outlinedBorder, currentColor)",
          backgroundColor: "var(--variant-outlinedBg)",
          color: "var(--variant-outlinedColor)",
          [`&.${zl.disabled}`]: {
            border: `1px solid ${(e.vars || e).palette.action.disabledBackground}`
          }
        }
      }, {
        props: {
          variant: "text"
        },
        style: {
          padding: "6px 8px",
          color: "var(--variant-textColor)",
          backgroundColor: "var(--variant-textBg)"
        }
      }, ...Object.entries(e.palette).filter(xr()).map(([r]) => ({
        props: {
          color: r
        },
        style: {
          "--variant-textColor": (e.vars || e).palette[r].main,
          "--variant-outlinedColor": (e.vars || e).palette[r].main,
          "--variant-outlinedBorder": e.alpha((e.vars || e).palette[r].main, 0.5),
          "--variant-containedColor": (e.vars || e).palette[r].contrastText,
          "--variant-containedBg": (e.vars || e).palette[r].main,
          "@media (hover: hover)": {
            "&:hover": {
              "--variant-containedBg": (e.vars || e).palette[r].dark,
              "--variant-textBg": e.alpha((e.vars || e).palette[r].main, (e.vars || e).palette.action.hoverOpacity),
              "--variant-outlinedBorder": (e.vars || e).palette[r].main,
              "--variant-outlinedBg": e.alpha((e.vars || e).palette[r].main, (e.vars || e).palette.action.hoverOpacity)
            }
          }
        }
      })), {
        props: {
          color: "inherit"
        },
        style: {
          color: "inherit",
          borderColor: "currentColor",
          "--variant-containedBg": e.vars ? e.vars.palette.Button.inheritContainedBg : t,
          "@media (hover: hover)": {
            "&:hover": {
              "--variant-containedBg": e.vars ? e.vars.palette.Button.inheritContainedHoverBg : n,
              "--variant-textBg": e.alpha((e.vars || e).palette.text.primary, (e.vars || e).palette.action.hoverOpacity),
              "--variant-outlinedBg": e.alpha((e.vars || e).palette.text.primary, (e.vars || e).palette.action.hoverOpacity)
            }
          }
        }
      }, {
        props: {
          size: "small",
          variant: "text"
        },
        style: {
          padding: "4px 5px",
          fontSize: e.typography.pxToRem(13)
        }
      }, {
        props: {
          size: "large",
          variant: "text"
        },
        style: {
          padding: "8px 11px",
          fontSize: e.typography.pxToRem(15)
        }
      }, {
        props: {
          size: "small",
          variant: "outlined"
        },
        style: {
          padding: "3px 9px",
          fontSize: e.typography.pxToRem(13)
        }
      }, {
        props: {
          size: "large",
          variant: "outlined"
        },
        style: {
          padding: "7px 21px",
          fontSize: e.typography.pxToRem(15)
        }
      }, {
        props: {
          size: "small",
          variant: "contained"
        },
        style: {
          padding: "4px 10px",
          fontSize: e.typography.pxToRem(13)
        }
      }, {
        props: {
          size: "large",
          variant: "contained"
        },
        style: {
          padding: "8px 22px",
          fontSize: e.typography.pxToRem(15)
        }
      }, {
        props: {
          disableElevation: !0
        },
        style: {
          boxShadow: "none",
          "&:hover": {
            boxShadow: "none"
          },
          [`&.${zl.focusVisible}`]: {
            boxShadow: "none"
          },
          "&:active": {
            boxShadow: "none"
          },
          [`&.${zl.disabled}`]: {
            boxShadow: "none"
          }
        }
      }, {
        props: {
          fullWidth: !0
        },
        style: {
          width: "100%"
        }
      }, {
        props: {
          loadingPosition: "center"
        },
        style: {
          transition: e.transitions.create(["background-color", "box-shadow", "border-color"], {
            duration: e.transitions.duration.short
          }),
          [`&.${zl.loading}`]: {
            color: "transparent"
          }
        }
      }]
    };
  })), L4e = Oe("span", {
    name: "MuiButton",
    slot: "StartIcon",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.startIcon, n.loading && t.startIconLoadingStart, t[`iconSize${$e(n.size)}`]];
    }
  })(({
    theme: e
  }) => ({
    display: "inherit",
    marginRight: 8,
    marginLeft: -4,
    variants: [{
      props: {
        size: "small"
      },
      style: {
        marginLeft: -2
      }
    }, {
      props: {
        loadingPosition: "start",
        loading: !0
      },
      style: {
        transition: e.transitions.create(["opacity"], {
          duration: e.transitions.duration.short
        }),
        opacity: 0
      }
    }, {
      props: {
        loadingPosition: "start",
        loading: !0,
        fullWidth: !0
      },
      style: {
        marginRight: -8
      }
    }, ...eq]
  })), z4e = Oe("span", {
    name: "MuiButton",
    slot: "EndIcon",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.endIcon, n.loading && t.endIconLoadingEnd, t[`iconSize${$e(n.size)}`]];
    }
  })(({
    theme: e
  }) => ({
    display: "inherit",
    marginRight: -4,
    marginLeft: 8,
    variants: [{
      props: {
        size: "small"
      },
      style: {
        marginRight: -2
      }
    }, {
      props: {
        loadingPosition: "end",
        loading: !0
      },
      style: {
        transition: e.transitions.create(["opacity"], {
          duration: e.transitions.duration.short
        }),
        opacity: 0
      }
    }, {
      props: {
        loadingPosition: "end",
        loading: !0,
        fullWidth: !0
      },
      style: {
        marginLeft: -8
      }
    }, ...eq]
  })), B4e = Oe("span", {
    name: "MuiButton",
    slot: "LoadingIndicator"
  })(({
    theme: e
  }) => ({
    display: "none",
    position: "absolute",
    visibility: "visible",
    variants: [{
      props: {
        loading: !0
      },
      style: {
        display: "flex"
      }
    }, {
      props: {
        loadingPosition: "start"
      },
      style: {
        left: 14
      }
    }, {
      props: {
        loadingPosition: "start",
        size: "small"
      },
      style: {
        left: 10
      }
    }, {
      props: {
        variant: "text",
        loadingPosition: "start"
      },
      style: {
        left: 6
      }
    }, {
      props: {
        loadingPosition: "center"
      },
      style: {
        left: "50%",
        transform: "translate(-50%)",
        color: (e.vars || e).palette.action.disabled
      }
    }, {
      props: {
        loadingPosition: "end"
      },
      style: {
        right: 14
      }
    }, {
      props: {
        loadingPosition: "end",
        size: "small"
      },
      style: {
        right: 10
      }
    }, {
      props: {
        variant: "text",
        loadingPosition: "end"
      },
      style: {
        right: 6
      }
    }, {
      props: {
        loadingPosition: "start",
        fullWidth: !0
      },
      style: {
        position: "relative",
        left: -10
      }
    }, {
      props: {
        loadingPosition: "end",
        fullWidth: !0
      },
      style: {
        position: "relative",
        right: -10
      }
    }]
  })), p4 = Oe("span", {
    name: "MuiButton",
    slot: "LoadingIconPlaceholder"
  })({
    display: "inline-block",
    width: "1em",
    height: "1em"
  }), U4e = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = T.useContext(I4e), o = T.useContext(j4e), i = qp(r, t), a = lt({
      props: i,
      name: "MuiButton"
    }), {
      children: s,
      color: l = "primary",
      component: u = "button",
      className: d,
      disabled: p = !1,
      disableElevation: h = !1,
      disableFocusRipple: g = !1,
      endIcon: y,
      focusVisibleClassName: b,
      fullWidth: v = !1,
      id: x,
      loading: E = null,
      loadingIndicator: _,
      loadingPosition: C = "center",
      size: k = "medium",
      startIcon: R,
      type: A,
      variant: M = "text",
      ...I
    } = a, D = Ef(x), L = _ ?? /* @__PURE__ */ S.jsx(B7, {
      "aria-labelledby": D,
      color: "inherit",
      size: 16
    }), P = {
      ...a,
      color: l,
      component: u,
      disabled: p,
      disableElevation: h,
      disableFocusRipple: g,
      fullWidth: v,
      loading: E,
      loadingIndicator: L,
      loadingPosition: C,
      size: k,
      type: A,
      variant: M
    }, B = D4e(P), j = (R || E && C === "start") && /* @__PURE__ */ S.jsx(L4e, {
      className: B.startIcon,
      ownerState: P,
      children: R || /* @__PURE__ */ S.jsx(p4, {
        className: B.loadingIconPlaceholder,
        ownerState: P
      })
    }), V = (y || E && C === "end") && /* @__PURE__ */ S.jsx(z4e, {
      className: B.endIcon,
      ownerState: P,
      children: y || /* @__PURE__ */ S.jsx(p4, {
        className: B.loadingIconPlaceholder,
        ownerState: P
      })
    }), F = o || "", G = typeof E == "boolean" ? (
      // use plain HTML span to minimize the runtime overhead
      /* @__PURE__ */ S.jsx("span", {
        className: B.loadingWrapper,
        style: {
          display: "contents"
        },
        children: E && /* @__PURE__ */ S.jsx(B4e, {
          className: B.loadingIndicator,
          ownerState: P,
          children: L
        })
      })
    ) : null;
    return /* @__PURE__ */ S.jsxs(F4e, {
      ownerState: P,
      className: je(r.className, B.root, d, F),
      component: u,
      disabled: p || E,
      focusRipple: !g,
      focusVisibleClassName: je(B.focusVisible, b),
      ref: n,
      type: A,
      id: E ? D : x,
      ...I,
      classes: B,
      children: [j, C !== "end" && G, s, C === "end" && G, V]
    });
  });
  function V4e({ uiSchema: e }) {
    const { submitText: t, norender: n, props: r = {} } = a7(e);
    return n ? null : S.jsx(sl, { marginTop: 3, children: S.jsx(U4e, { type: "submit", variant: "contained", color: "primary", ...r, children: t }) });
  }
  function H4e(e) {
    return it("MuiDivider", e);
  }
  const h4 = rt("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]), q4e = (e) => {
    const {
      absolute: t,
      children: n,
      classes: r,
      flexItem: o,
      light: i,
      orientation: a,
      textAlign: s,
      variant: l
    } = e;
    return ot({
      root: ["root", t && "absolute", l, i && "light", a === "vertical" && "vertical", o && "flexItem", n && "withChildren", n && a === "vertical" && "withChildrenVertical", s === "right" && a !== "vertical" && "textAlignRight", s === "left" && a !== "vertical" && "textAlignLeft"],
      wrapper: ["wrapper", a === "vertical" && "wrapperVertical"]
    }, H4e, r);
  }, W4e = Oe("div", {
    name: "MuiDivider",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.absolute && t.absolute, t[n.variant], n.light && t.light, n.orientation === "vertical" && t.vertical, n.flexItem && t.flexItem, n.children && t.withChildren, n.children && n.orientation === "vertical" && t.withChildrenVertical, n.textAlign === "right" && n.orientation !== "vertical" && t.textAlignRight, n.textAlign === "left" && n.orientation !== "vertical" && t.textAlignLeft];
    }
  })(at(({
    theme: e
  }) => ({
    margin: 0,
    // Reset browser default style.
    flexShrink: 0,
    borderWidth: 0,
    borderStyle: "solid",
    borderColor: (e.vars || e).palette.divider,
    borderBottomWidth: "thin",
    variants: [{
      props: {
        absolute: !0
      },
      style: {
        position: "absolute",
        bottom: 0,
        left: 0,
        width: "100%"
      }
    }, {
      props: {
        light: !0
      },
      style: {
        borderColor: e.alpha((e.vars || e).palette.divider, 0.08)
      }
    }, {
      props: {
        variant: "inset"
      },
      style: {
        marginLeft: 72
      }
    }, {
      props: {
        variant: "middle",
        orientation: "horizontal"
      },
      style: {
        marginLeft: e.spacing(2),
        marginRight: e.spacing(2)
      }
    }, {
      props: {
        variant: "middle",
        orientation: "vertical"
      },
      style: {
        marginTop: e.spacing(1),
        marginBottom: e.spacing(1)
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        height: "100%",
        borderBottomWidth: 0,
        borderRightWidth: "thin"
      }
    }, {
      props: {
        flexItem: !0
      },
      style: {
        alignSelf: "stretch",
        height: "auto"
      }
    }, {
      props: ({
        ownerState: t
      }) => !!t.children,
      style: {
        display: "flex",
        textAlign: "center",
        border: 0,
        borderTopStyle: "solid",
        borderLeftStyle: "solid",
        "&::before, &::after": {
          content: '""',
          alignSelf: "center"
        }
      }
    }, {
      props: ({
        ownerState: t
      }) => t.children && t.orientation !== "vertical",
      style: {
        "&::before, &::after": {
          width: "100%",
          borderTop: `thin solid ${(e.vars || e).palette.divider}`,
          borderTopStyle: "inherit"
        }
      }
    }, {
      props: ({
        ownerState: t
      }) => t.orientation === "vertical" && t.children,
      style: {
        flexDirection: "column",
        "&::before, &::after": {
          height: "100%",
          borderLeft: `thin solid ${(e.vars || e).palette.divider}`,
          borderLeftStyle: "inherit"
        }
      }
    }, {
      props: ({
        ownerState: t
      }) => t.textAlign === "right" && t.orientation !== "vertical",
      style: {
        "&::before": {
          width: "90%"
        },
        "&::after": {
          width: "10%"
        }
      }
    }, {
      props: ({
        ownerState: t
      }) => t.textAlign === "left" && t.orientation !== "vertical",
      style: {
        "&::before": {
          width: "10%"
        },
        "&::after": {
          width: "90%"
        }
      }
    }]
  }))), G4e = Oe("span", {
    name: "MuiDivider",
    slot: "Wrapper",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.wrapper, n.orientation === "vertical" && t.wrapperVertical];
    }
  })(at(({
    theme: e
  }) => ({
    display: "inline-block",
    paddingLeft: `calc(${e.spacing(1)} * 1.2)`,
    paddingRight: `calc(${e.spacing(1)} * 1.2)`,
    whiteSpace: "nowrap",
    variants: [{
      props: {
        orientation: "vertical"
      },
      style: {
        paddingTop: `calc(${e.spacing(1)} * 1.2)`,
        paddingBottom: `calc(${e.spacing(1)} * 1.2)`
      }
    }]
  }))), YC = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiDivider"
    }), {
      absolute: o = !1,
      children: i,
      className: a,
      orientation: s = "horizontal",
      component: l = i || s === "vertical" ? "div" : "hr",
      flexItem: u = !1,
      light: d = !1,
      role: p = l !== "hr" ? "separator" : void 0,
      textAlign: h = "center",
      variant: g = "fullWidth",
      ...y
    } = r, b = {
      ...r,
      absolute: o,
      component: l,
      flexItem: u,
      light: d,
      orientation: s,
      role: p,
      textAlign: h,
      variant: g
    }, v = q4e(b);
    return /* @__PURE__ */ S.jsx(W4e, {
      as: l,
      className: je(v.root, a),
      role: p,
      ref: n,
      ownerState: b,
      "aria-orientation": p === "separator" && (l !== "hr" || s === "vertical") ? s : void 0,
      ...y,
      children: i ? /* @__PURE__ */ S.jsx(G4e, {
        className: v.wrapper,
        ownerState: b,
        children: i
      }) : null
    });
  });
  YC && (YC.muiSkipListHighlight = !0);
  function K4e({ id: e, title: t, optionalDataControl: n }) {
    let r = S.jsx(ji, { variant: "h5", children: t });
    return n && (r = S.jsxs(cr, { container: !0, spacing: 0, children: [S.jsx(cr, { size: "grow", children: r }), S.jsx(cr, { justifyContent: "flex-end", children: n })] })), S.jsxs(sl, { id: e, mb: 1, mt: 1, children: [r, S.jsx(YC, {})] });
  }
  function Y4e(e) {
    const { children: t, classNames: n, style: r, disabled: o, id: i, label: a, displayLabel: s, onKeyRenameBlur: l, onRemoveProperty: u, readonly: d, required: p, schema: h, uiSchema: g, registry: y } = e, { templates: b, translateString: v } = y, { RemoveButton: x } = b.ButtonTemplates, E = v(bt.KeyLabel, [a]), _ = $a in h, C = {
      flex: 1,
      paddingLeft: 6,
      paddingRight: 6,
      fontWeight: "bold"
    };
    return _ ? S.jsxs(cr, { container: !0, alignItems: "flex-start", spacing: 2, className: n, style: r, children: [S.jsx(cr, { size: 5.5, children: S.jsx(_O, { fullWidth: !0, required: p, label: s ? E : void 0, defaultValue: a, disabled: o || d, id: `${i}-key`, name: `${i}-key`, onBlur: d ? void 0 : l, type: "text" }) }), S.jsx(cr, { size: 5.5, children: t }), S.jsx(cr, { sx: { mt: 1.5 }, children: S.jsx(x, { id: $i(i, "remove"), className: "rjsf-object-property-remove", iconType: "default", style: C, disabled: o || d, onClick: u, uiSchema: g, registry: y }) })] }, `${i}-key`) : S.jsx("div", { className: n, style: r, children: t });
  }
  function X4e() {
    return {
      ArrayFieldItemTemplate: QDe,
      ArrayFieldTemplate: JDe,
      BaseInputTemplate: K3e,
      ButtonTemplates: {
        AddButton: UDe,
        CopyButton: E4e,
        MoveDownButton: C4e,
        MoveUpButton: k4e,
        RemoveButton: J7,
        SubmitButton: V4e
      },
      DescriptionFieldTemplate: e4e,
      ErrorListTemplate: b4e,
      FieldErrorTemplate: T4e,
      FieldHelpTemplate: R4e,
      FieldTemplate: O4e,
      GridTemplate: A4e,
      MultiSchemaFieldTemplate: N4e,
      ObjectFieldTemplate: M4e,
      OptionalDataControlsTemplate: P4e,
      TitleFieldTemplate: K4e,
      WrapIfAdditionalTemplate: Y4e
    };
  }
  function Z4e(e) {
    return it("PrivateSwitchBase", e);
  }
  rt("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
  const Q4e = (e) => {
    const {
      classes: t,
      checked: n,
      disabled: r,
      edge: o
    } = e, i = {
      root: ["root", n && "checked", r && "disabled", o && `edge${$e(o)}`],
      input: ["input"]
    };
    return ot(i, Z4e, t);
  }, J4e = Oe(Ih, {
    name: "MuiSwitchBase"
  })({
    padding: 9,
    borderRadius: "50%",
    variants: [{
      props: {
        edge: "start",
        size: "small"
      },
      style: {
        marginLeft: -3
      }
    }, {
      props: ({
        edge: e,
        ownerState: t
      }) => e === "start" && t.size !== "small",
      style: {
        marginLeft: -12
      }
    }, {
      props: {
        edge: "end",
        size: "small"
      },
      style: {
        marginRight: -3
      }
    }, {
      props: ({
        edge: e,
        ownerState: t
      }) => e === "end" && t.size !== "small",
      style: {
        marginRight: -12
      }
    }]
  }), eFe = Oe("input", {
    name: "MuiSwitchBase",
    shouldForwardProp: wr
  })({
    cursor: "inherit",
    position: "absolute",
    opacity: 0,
    width: "100%",
    height: "100%",
    top: 0,
    left: 0,
    margin: 0,
    padding: 0,
    zIndex: 1
  }), tq = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const {
      autoFocus: r,
      checked: o,
      checkedIcon: i,
      defaultChecked: a,
      disabled: s,
      disableFocusRipple: l = !1,
      edge: u = !1,
      icon: d,
      id: p,
      inputProps: h,
      inputRef: g,
      name: y,
      onBlur: b,
      onChange: v,
      onFocus: x,
      readOnly: E,
      required: _ = !1,
      tabIndex: C,
      type: k,
      value: R,
      slots: A = {},
      slotProps: M = {},
      ...I
    } = t, [D, L] = Ch({
      controlled: o,
      default: !!a,
      name: "SwitchBase",
      state: "checked"
    }), P = ea(), B = (Y) => {
      x && x(Y), P && P.onFocus && P.onFocus(Y);
    }, j = (Y) => {
      b && b(Y), P && P.onBlur && P.onBlur(Y);
    }, V = (Y) => {
      if (Y.nativeEvent.defaultPrevented)
        return;
      const Q = Y.target.checked;
      L(Q), v && v(Y, Q);
    };
    let F = s;
    P && typeof F > "u" && (F = P.disabled);
    const G = k === "checkbox" || k === "radio", W = {
      ...t,
      checked: D,
      disabled: F,
      disableFocusRipple: l,
      edge: u
    }, K = Q4e(W), $ = {
      slots: A,
      slotProps: {
        input: h,
        ...M
      }
    }, [U, X] = dn("root", {
      ref: n,
      elementType: J4e,
      className: K.root,
      shouldForwardComponentProp: !0,
      externalForwardedProps: {
        ...$,
        component: "span",
        ...I
      },
      getSlotProps: (Y) => ({
        ...Y,
        onFocus: (Q) => {
          Y.onFocus?.(Q), B(Q);
        },
        onBlur: (Q) => {
          Y.onBlur?.(Q), j(Q);
        }
      }),
      ownerState: W,
      additionalProps: {
        centerRipple: !0,
        focusRipple: !l,
        disabled: F,
        role: void 0,
        tabIndex: null
      }
    }), [z, H] = dn("input", {
      ref: g,
      elementType: eFe,
      className: K.input,
      externalForwardedProps: $,
      getSlotProps: (Y) => ({
        ...Y,
        onChange: (Q) => {
          Y.onChange?.(Q), V(Q);
        }
      }),
      ownerState: W,
      additionalProps: {
        autoFocus: r,
        checked: o,
        defaultChecked: a,
        disabled: F,
        id: G ? p : void 0,
        name: y,
        readOnly: E,
        required: _,
        tabIndex: C,
        type: k,
        ...k === "checkbox" && R === void 0 ? {} : {
          value: R
        }
      }
    });
    return /* @__PURE__ */ S.jsxs(U, {
      ...X,
      children: [/* @__PURE__ */ S.jsx(z, {
        ...H
      }), D ? i : d]
    });
  }), tFe = co(/* @__PURE__ */ S.jsx("path", {
    d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
  })), nFe = co(/* @__PURE__ */ S.jsx("path", {
    d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
  })), rFe = co(/* @__PURE__ */ S.jsx("path", {
    d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"
  }));
  function oFe(e) {
    return it("MuiCheckbox", e);
  }
  const nE = rt("MuiCheckbox", ["root", "checked", "disabled", "indeterminate", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium"]), iFe = (e) => {
    const {
      classes: t,
      indeterminate: n,
      color: r,
      size: o
    } = e, i = {
      root: ["root", n && "indeterminate", `color${$e(r)}`, `size${$e(o)}`]
    }, a = ot(i, oFe, t);
    return {
      ...t,
      // forward the disabled and checked classes to the SwitchBase
      ...a
    };
  }, aFe = Oe(tq, {
    shouldForwardProp: (e) => wr(e) || e === "classes",
    name: "MuiCheckbox",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.indeterminate && t.indeterminate, t[`size${$e(n.size)}`], n.color !== "default" && t[`color${$e(n.color)}`]];
    }
  })(at(({
    theme: e
  }) => ({
    color: (e.vars || e).palette.text.secondary,
    variants: [{
      props: {
        color: "default",
        disableRipple: !1
      },
      style: {
        "&:hover": {
          backgroundColor: e.alpha((e.vars || e).palette.action.active, (e.vars || e).palette.action.hoverOpacity)
        }
      }
    }, ...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t,
        disableRipple: !1
      },
      style: {
        "&:hover": {
          backgroundColor: e.alpha((e.vars || e).palette[t].main, (e.vars || e).palette.action.hoverOpacity)
        }
      }
    })), ...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        [`&.${nE.checked}, &.${nE.indeterminate}`]: {
          color: (e.vars || e).palette[t].main
        },
        [`&.${nE.disabled}`]: {
          color: (e.vars || e).palette.action.disabled
        }
      }
    })), {
      // Should be last to override other colors
      props: {
        disableRipple: !1
      },
      style: {
        // Reset on touch devices, it doesn't add specificity
        "&:hover": {
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }
      }
    }]
  }))), sFe = /* @__PURE__ */ S.jsx(nFe, {}), lFe = /* @__PURE__ */ S.jsx(tFe, {}), cFe = /* @__PURE__ */ S.jsx(rFe, {}), nq = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiCheckbox"
    }), {
      checkedIcon: o = sFe,
      color: i = "primary",
      icon: a = lFe,
      indeterminate: s = !1,
      indeterminateIcon: l = cFe,
      inputProps: u,
      size: d = "medium",
      disableRipple: p = !1,
      className: h,
      slots: g = {},
      slotProps: y = {},
      ...b
    } = r, v = s ? l : a, x = s ? l : o, E = {
      ...r,
      disableRipple: p,
      color: i,
      indeterminate: s,
      size: d
    }, _ = iFe(E), C = y.input ?? u, [k, R] = dn("root", {
      ref: n,
      elementType: aFe,
      className: je(_.root, h),
      shouldForwardComponentProp: !0,
      externalForwardedProps: {
        slots: g,
        slotProps: y,
        ...b
      },
      ownerState: E,
      additionalProps: {
        type: "checkbox",
        icon: /* @__PURE__ */ T.cloneElement(v, {
          fontSize: v.props.fontSize ?? d
        }),
        checkedIcon: /* @__PURE__ */ T.cloneElement(x, {
          fontSize: x.props.fontSize ?? d
        }),
        disableRipple: p,
        slots: g,
        slotProps: {
          input: L7(typeof C == "function" ? C(E) : C, {
            "data-indeterminate": s
          })
        }
      }
    });
    return /* @__PURE__ */ S.jsx(k, {
      ...R,
      classes: _
    });
  });
  function uFe(e) {
    return it("MuiFormControlLabel", e);
  }
  const Sp = rt("MuiFormControlLabel", ["root", "labelPlacementStart", "labelPlacementTop", "labelPlacementBottom", "disabled", "label", "error", "required", "asterisk"]), fFe = (e) => {
    const {
      classes: t,
      disabled: n,
      labelPlacement: r,
      error: o,
      required: i
    } = e, a = {
      root: ["root", n && "disabled", `labelPlacement${$e(r)}`, o && "error", i && "required"],
      label: ["label", n && "disabled"],
      asterisk: ["asterisk", o && "error"]
    };
    return ot(a, uFe, t);
  }, dFe = Oe("label", {
    name: "MuiFormControlLabel",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [{
        [`& .${Sp.label}`]: t.label
      }, t.root, t[`labelPlacement${$e(n.labelPlacement)}`]];
    }
  })(at(({
    theme: e
  }) => ({
    display: "inline-flex",
    alignItems: "center",
    cursor: "pointer",
    // For correct alignment with the text.
    verticalAlign: "middle",
    WebkitTapHighlightColor: "transparent",
    marginLeft: -11,
    marginRight: 16,
    // used for row presentation of radio/checkbox
    [`&.${Sp.disabled}`]: {
      cursor: "default"
    },
    [`& .${Sp.label}`]: {
      [`&.${Sp.disabled}`]: {
        color: (e.vars || e).palette.text.disabled
      }
    },
    variants: [{
      props: {
        labelPlacement: "start"
      },
      style: {
        flexDirection: "row-reverse",
        marginRight: -11
      }
    }, {
      props: {
        labelPlacement: "top"
      },
      style: {
        flexDirection: "column-reverse"
      }
    }, {
      props: {
        labelPlacement: "bottom"
      },
      style: {
        flexDirection: "column"
      }
    }, {
      props: ({
        labelPlacement: t
      }) => t === "start" || t === "top" || t === "bottom",
      style: {
        marginLeft: 16
        // used for row presentation of radio/checkbox
      }
    }]
  }))), pFe = Oe("span", {
    name: "MuiFormControlLabel",
    slot: "Asterisk"
  })(at(({
    theme: e
  }) => ({
    [`&.${Sp.error}`]: {
      color: (e.vars || e).palette.error.main
    }
  }))), EO = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiFormControlLabel"
    }), {
      checked: o,
      className: i,
      componentsProps: a = {},
      control: s,
      disabled: l,
      disableTypography: u,
      inputRef: d,
      label: p,
      labelPlacement: h = "end",
      name: g,
      onChange: y,
      required: b,
      slots: v = {},
      slotProps: x = {},
      value: E,
      ..._
    } = r, C = ea(), k = l ?? s.props.disabled ?? C?.disabled, R = b ?? s.props.required, A = {
      disabled: k,
      required: R
    };
    ["checked", "name", "onChange", "value", "inputRef"].forEach((V) => {
      typeof s.props[V] > "u" && typeof r[V] < "u" && (A[V] = r[V]);
    });
    const M = dl({
      props: r,
      muiFormControl: C,
      states: ["error"]
    }), I = {
      ...r,
      disabled: k,
      labelPlacement: h,
      required: R,
      error: M.error
    }, D = fFe(I), L = {
      slots: v,
      slotProps: {
        ...a,
        ...x
      }
    }, [P, B] = dn("typography", {
      elementType: ji,
      externalForwardedProps: L,
      ownerState: I
    });
    let j = p;
    return j != null && j.type !== ji && !u && (j = /* @__PURE__ */ S.jsx(P, {
      component: "span",
      ...B,
      className: je(D.label, B?.className),
      children: j
    })), /* @__PURE__ */ S.jsxs(dFe, {
      className: je(D.root, i),
      ownerState: I,
      ref: n,
      ..._,
      children: [/* @__PURE__ */ T.cloneElement(s, A), R ? /* @__PURE__ */ S.jsxs("div", {
        children: [j, /* @__PURE__ */ S.jsxs(pFe, {
          ownerState: I,
          "aria-hidden": !0,
          className: D.asterisk,
          children: ["", "*"]
        })]
      }) : j]
    });
  });
  function hFe(e) {
    var t;
    const { schema: n, id: r, htmlName: o, value: i, disabled: a, readonly: s, label: l = "", hideLabel: u, autofocus: d, onChange: p, onBlur: h, onFocus: g, registry: y, options: b, uiSchema: v } = e, x = et("DescriptionFieldTemplate", y, b), E = Dp(n), _ = (A, M) => p(M), C = () => h(r, i), k = () => g(r, i), R = (t = b.description) !== null && t !== void 0 ? t : n.description;
    return S.jsxs(S.Fragment, { children: [!u && R && S.jsx(x, { id: Tc(r), description: R, schema: n, uiSchema: v, registry: y }), S.jsx(EO, { control: S.jsx(nq, { id: r, name: o || r, checked: typeof i > "u" ? !1 : !!i, required: E, disabled: a || s, autoFocus: d, onChange: _, onBlur: C, onFocus: k, "aria-describedby": po(r) }), label: Rc(l, u, !1) })] });
  }
  function mFe(e) {
    return it("MuiFormGroup", e);
  }
  rt("MuiFormGroup", ["root", "row", "error"]);
  const gFe = (e) => {
    const {
      classes: t,
      row: n,
      error: r
    } = e;
    return ot({
      root: ["root", n && "row", r && "error"]
    }, mFe, t);
  }, yFe = Oe("div", {
    name: "MuiFormGroup",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.row && t.row];
    }
  })({
    display: "flex",
    flexDirection: "column",
    flexWrap: "wrap",
    variants: [{
      props: {
        row: !0
      },
      style: {
        flexDirection: "row"
      }
    }]
  }), rq = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiFormGroup"
    }), {
      className: o,
      row: i = !1,
      ...a
    } = r, s = ea(), l = dl({
      props: r,
      muiFormControl: s,
      states: ["error"]
    }), u = {
      ...r,
      row: i,
      error: l.error
    }, d = gFe(u);
    return /* @__PURE__ */ S.jsx(yFe, {
      className: je(d.root, o),
      ownerState: u,
      ref: n,
      ...a
    });
  });
  function vFe({ label: e, hideLabel: t, id: n, htmlName: r, disabled: o, options: i, value: a, autofocus: s, readonly: l, required: u, onChange: d, onBlur: p, onFocus: h }) {
    const { enumOptions: g, enumDisabled: y, inline: b, emptyValue: v } = i, x = Array.isArray(a) ? a : [a], E = (k) => ({ target: { checked: R } }) => {
      d(R ? t7(k, x, g) : e7(k, x, g));
    }, _ = ({ target: k }) => p(n, Jn(k && k.value, g, v)), C = ({ target: k }) => h(n, Jn(k && k.value, g, v));
    return S.jsxs(S.Fragment, { children: [Rc(S.jsx(M1, { required: u, htmlFor: n, children: e || void 0 }), t), S.jsx(rq, { id: n, row: !!b, children: Array.isArray(g) && g.map((k, R) => {
      const A = v1(k.value, x), M = Array.isArray(y) && y.indexOf(k.value) !== -1, I = S.jsx(nq, { id: x1(n, R), name: r || n, checked: A, disabled: o || M || l, autoFocus: s && R === 0, onChange: E(R), onBlur: _, onFocus: C, "aria-describedby": po(n) });
      return S.jsx(EO, { control: I, label: k.label }, R);
    }) })] });
  }
  const bFe = co(/* @__PURE__ */ S.jsx("path", {
    d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
  })), xFe = co(/* @__PURE__ */ S.jsx("path", {
    d: "M8.465 8.465C9.37 7.56 10.62 7 12 7C14.76 7 17 9.24 17 12C17 13.38 16.44 14.63 15.535 15.535C14.63 16.44 13.38 17 12 17C9.24 17 7 14.76 7 12C7 10.62 7.56 9.37 8.465 8.465Z"
  })), wFe = Oe("span", {
    name: "MuiRadioButtonIcon",
    shouldForwardProp: wr
  })({
    position: "relative",
    display: "flex"
  }), SFe = Oe(bFe, {
    name: "MuiRadioButtonIcon"
  })({
    // Scale applied to prevent dot misalignment in Safari
    transform: "scale(1)"
  }), _Fe = Oe(xFe, {
    name: "MuiRadioButtonIcon"
  })(at(({
    theme: e
  }) => ({
    left: 0,
    position: "absolute",
    transform: "scale(0)",
    transition: e.transitions.create("transform", {
      easing: e.transitions.easing.easeIn,
      duration: e.transitions.duration.shortest
    }),
    variants: [{
      props: {
        checked: !0
      },
      style: {
        transform: "scale(1)",
        transition: e.transitions.create("transform", {
          easing: e.transitions.easing.easeOut,
          duration: e.transitions.duration.shortest
        })
      }
    }]
  })));
  function oq(e) {
    const {
      checked: t = !1,
      classes: n = {},
      fontSize: r
    } = e, o = {
      ...e,
      checked: t
    };
    return /* @__PURE__ */ S.jsxs(wFe, {
      className: n.root,
      ownerState: o,
      children: [/* @__PURE__ */ S.jsx(SFe, {
        fontSize: r,
        className: n.background,
        ownerState: o
      }), /* @__PURE__ */ S.jsx(_Fe, {
        fontSize: r,
        className: n.dot,
        ownerState: o
      })]
    });
  }
  const iq = /* @__PURE__ */ T.createContext(void 0);
  function EFe() {
    return T.useContext(iq);
  }
  function CFe(e) {
    return it("MuiRadio", e);
  }
  const m4 = rt("MuiRadio", ["root", "checked", "disabled", "colorPrimary", "colorSecondary", "sizeSmall"]), kFe = (e) => {
    const {
      classes: t,
      color: n,
      size: r
    } = e, o = {
      root: ["root", `color${$e(n)}`, r !== "medium" && `size${$e(r)}`]
    };
    return {
      ...t,
      ...ot(o, CFe, t)
    };
  }, TFe = Oe(tq, {
    shouldForwardProp: (e) => wr(e) || e === "classes",
    name: "MuiRadio",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.size !== "medium" && t[`size${$e(n.size)}`], t[`color${$e(n.color)}`]];
    }
  })(at(({
    theme: e
  }) => ({
    color: (e.vars || e).palette.text.secondary,
    [`&.${m4.disabled}`]: {
      color: (e.vars || e).palette.action.disabled
    },
    variants: [{
      props: {
        color: "default",
        disabled: !1,
        disableRipple: !1
      },
      style: {
        "&:hover": {
          backgroundColor: e.alpha((e.vars || e).palette.action.active, (e.vars || e).palette.action.hoverOpacity)
        }
      }
    }, ...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t,
        disabled: !1,
        disableRipple: !1
      },
      style: {
        "&:hover": {
          backgroundColor: e.alpha((e.vars || e).palette[t].main, (e.vars || e).palette.action.hoverOpacity)
        }
      }
    })), ...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t,
        disabled: !1
      },
      style: {
        [`&.${m4.checked}`]: {
          color: (e.vars || e).palette[t].main
        }
      }
    })), {
      // Should be last to override other colors
      props: {
        disableRipple: !1
      },
      style: {
        // Reset on touch devices, it doesn't add specificity
        "&:hover": {
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }
      }
    }]
  })));
  function RFe(e, t) {
    return typeof t == "object" && t !== null ? e === t : String(e) === String(t);
  }
  const OFe = /* @__PURE__ */ S.jsx(oq, {
    checked: !0
  }), AFe = /* @__PURE__ */ S.jsx(oq, {}), NFe = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiRadio"
    }), {
      checked: o,
      checkedIcon: i = OFe,
      color: a = "primary",
      icon: s = AFe,
      name: l,
      onChange: u,
      size: d = "medium",
      className: p,
      disabled: h,
      disableRipple: g = !1,
      slots: y = {},
      slotProps: b = {},
      inputProps: v,
      ...x
    } = r, E = ea();
    let _ = h;
    E && typeof _ > "u" && (_ = E.disabled), _ ?? (_ = !1);
    const C = {
      ...r,
      disabled: _,
      disableRipple: g,
      color: a,
      size: d
    }, k = kFe(C), R = EFe();
    let A = o;
    const M = HC(u, R && R.onChange);
    let I = l;
    R && (typeof A > "u" && (A = RFe(R.value, r.value)), typeof I > "u" && (I = R.name));
    const D = b.input ?? v, [L, P] = dn("root", {
      ref: n,
      elementType: TFe,
      className: je(k.root, p),
      shouldForwardComponentProp: !0,
      externalForwardedProps: {
        slots: y,
        slotProps: b,
        ...x
      },
      getSlotProps: (B) => ({
        ...B,
        onChange: (j, ...V) => {
          B.onChange?.(j, ...V), M(j, ...V);
        }
      }),
      ownerState: C,
      additionalProps: {
        type: "radio",
        icon: /* @__PURE__ */ T.cloneElement(s, {
          fontSize: s.props.fontSize ?? d
        }),
        checkedIcon: /* @__PURE__ */ T.cloneElement(i, {
          fontSize: i.props.fontSize ?? d
        }),
        disabled: _,
        name: I,
        checked: A,
        slots: y,
        slotProps: {
          // Do not forward `slotProps.root` again because it's already handled by the `RootSlot` in this file.
          input: typeof D == "function" ? D(C) : D
        }
      }
    });
    return /* @__PURE__ */ S.jsx(L, {
      ...P,
      classes: k
    });
  });
  function MFe(e) {
    return it("MuiRadioGroup", e);
  }
  rt("MuiRadioGroup", ["root", "row", "error"]);
  const PFe = (e) => {
    const {
      classes: t,
      row: n,
      error: r
    } = e;
    return ot({
      root: ["root", n && "row", r && "error"]
    }, MFe, t);
  }, $Fe = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const {
      // private
      // eslint-disable-next-line react/prop-types
      actions: r,
      children: o,
      className: i,
      defaultValue: a,
      name: s,
      onChange: l,
      value: u,
      ...d
    } = t, p = T.useRef(null), h = PFe(t), [g, y] = Ch({
      controlled: u,
      default: a,
      name: "RadioGroup"
    });
    T.useImperativeHandle(r, () => ({
      focus: () => {
        let E = p.current.querySelector("input:not(:disabled):checked");
        E || (E = p.current.querySelector("input:not(:disabled)")), E && E.focus();
      }
    }), []);
    const b = er(n, p), v = Ef(s), x = T.useMemo(() => ({
      name: v,
      onChange(E) {
        y(E.target.value), l && l(E, E.target.value);
      },
      value: g
    }), [v, l, y, g]);
    return /* @__PURE__ */ S.jsx(iq.Provider, {
      value: x,
      children: /* @__PURE__ */ S.jsx(rq, {
        role: "radiogroup",
        ref: b,
        className: je(h.root, i),
        ...d,
        children: o
      })
    });
  });
  function IFe({ id: e, htmlName: t, options: n, value: r, required: o, disabled: i, readonly: a, label: s, hideLabel: l, onChange: u, onBlur: d, onFocus: p }) {
    var h;
    const { enumOptions: g, enumDisabled: y, emptyValue: b } = n, v = (k, R) => u(Jn(R, g, b)), x = ({ target: k }) => d(e, Jn(k && k.value, g, b)), E = ({ target: k }) => p(e, Jn(k && k.value, g, b)), _ = n ? n.inline : !1, C = (h = XR(r, g)) !== null && h !== void 0 ? h : null;
    return S.jsxs(S.Fragment, { children: [Rc(S.jsx(M1, { required: o, htmlFor: e, children: s || void 0 }), l), S.jsx($Fe, { id: e, name: t || e, value: C, row: _, onChange: v, onBlur: x, onFocus: E, "aria-describedby": po(e), children: Array.isArray(g) && g.map((k, R) => {
      const A = Array.isArray(y) && y.indexOf(k.value) !== -1;
      return S.jsx(EO, { control: S.jsx(NFe, { name: t || e, id: x1(e, R), color: "primary" }), label: k.label, value: String(R), disabled: i || A || a }, R);
    }) })] });
  }
  const jFe = {
    border: 0,
    clip: "rect(0 0 0 0)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: 0,
    position: "absolute",
    whiteSpace: "nowrap",
    width: "1px"
  };
  function DFe(e, t, n = (r, o) => r === o) {
    return e.length === t.length && e.every((r, o) => n(r, t[o]));
  }
  const FFe = 2;
  function Au(e, t, n, r, o) {
    return n === 1 ? Math.min(e + t, o) : Math.max(e - t, r);
  }
  function aq(e, t) {
    return e - t;
  }
  function g4(e, t) {
    const {
      index: n
    } = e.reduce((r, o, i) => {
      const a = Math.abs(t - o);
      return r === null || a < r.distance || a === r.distance ? {
        distance: a,
        index: i
      } : r;
    }, null) ?? {};
    return n;
  }
  function ov(e, t) {
    if (t.current !== void 0 && e.changedTouches) {
      const n = e;
      for (let r = 0; r < n.changedTouches.length; r += 1) {
        const o = n.changedTouches[r];
        if (o.identifier === t.current)
          return {
            x: o.clientX,
            y: o.clientY
          };
      }
      return !1;
    }
    return {
      x: e.clientX,
      y: e.clientY
    };
  }
  function L0(e, t, n) {
    return (e - t) * 100 / (n - t);
  }
  function LFe(e, t, n) {
    return (n - t) * e + t;
  }
  function zFe(e) {
    if (Math.abs(e) < 1) {
      const n = e.toExponential().split("e-"), r = n[0].split(".")[1];
      return (r ? r.length : 0) + parseInt(n[1], 10);
    }
    const t = e.toString().split(".")[1];
    return t ? t.length : 0;
  }
  function BFe(e, t, n) {
    const r = Math.round((e - n) / t) * t + n;
    return Number(r.toFixed(zFe(t)));
  }
  function y4({
    values: e,
    newValue: t,
    index: n
  }) {
    const r = e.slice();
    return r[n] = t, r.sort(aq);
  }
  function iv({
    sliderRef: e,
    activeIndex: t,
    setActive: n
  }) {
    const r = Rr(e.current);
    (!e.current?.contains(r.activeElement) || Number(r?.activeElement?.getAttribute("data-index")) !== t) && e.current?.querySelector(`[type="range"][data-index="${t}"]`).focus(), n && n(t);
  }
  function av(e, t) {
    return typeof e == "number" && typeof t == "number" ? e === t : typeof e == "object" && typeof t == "object" ? DFe(e, t) : !1;
  }
  const UFe = {
    horizontal: {
      offset: (e) => ({
        left: `${e}%`
      }),
      leap: (e) => ({
        width: `${e}%`
      })
    },
    "horizontal-reverse": {
      offset: (e) => ({
        right: `${e}%`
      }),
      leap: (e) => ({
        width: `${e}%`
      })
    },
    vertical: {
      offset: (e) => ({
        bottom: `${e}%`
      }),
      leap: (e) => ({
        height: `${e}%`
      })
    }
  }, VFe = (e) => e;
  let sv;
  function v4() {
    return sv === void 0 && (typeof CSS < "u" && typeof CSS.supports == "function" ? sv = CSS.supports("touch-action", "none") : sv = !0), sv;
  }
  function HFe(e) {
    const {
      "aria-labelledby": t,
      defaultValue: n,
      disabled: r = !1,
      disableSwap: o = !1,
      isRtl: i = !1,
      marks: a = !1,
      max: s = 100,
      min: l = 0,
      name: u,
      onChange: d,
      onChangeCommitted: p,
      orientation: h = "horizontal",
      rootRef: g,
      scale: y = VFe,
      step: b = 1,
      shiftStep: v = 10,
      tabIndex: x,
      value: E
    } = e, _ = T.useRef(void 0), [C, k] = T.useState(-1), [R, A] = T.useState(-1), [M, I] = T.useState(!1), D = T.useRef(0), L = T.useRef(null), [P, B] = Ch({
      controlled: E,
      default: n ?? l,
      name: "Slider"
    }), j = d && ((Re, oe, ue) => {
      const Se = Re.nativeEvent || Re, _e = new Se.constructor(Se.type, Se);
      Object.defineProperty(_e, "target", {
        writable: !0,
        value: {
          value: oe,
          name: u
        }
      }), L.current = oe, d(_e, oe, ue);
    }), V = Array.isArray(P);
    let F = V ? P.slice().sort(aq) : [P];
    F = F.map((Re) => Re == null ? l : Nu(Re, l, s));
    const G = a === !0 && b !== null ? [...Array(Math.floor((s - l) / b) + 1)].map((Re, oe) => ({
      value: l + b * oe
    })) : a || [], W = G.map((Re) => Re.value), [K, $] = T.useState(-1), U = T.useRef(null), X = er(g, U), z = (Re) => (oe) => {
      const ue = Number(oe.currentTarget.getAttribute("data-index"));
      zv(oe.target) && $(ue), A(ue), Re?.onFocus?.(oe);
    }, H = (Re) => (oe) => {
      zv(oe.target) || $(-1), A(-1), Re?.onBlur?.(oe);
    }, Y = (Re, oe) => {
      const ue = Number(Re.currentTarget.getAttribute("data-index")), Se = F[ue], _e = W.indexOf(Se);
      let Ae = oe;
      if (G && b == null) {
        const Ue = W[W.length - 1];
        Ae >= Ue ? Ae = Ue : Ae <= W[0] ? Ae = W[0] : Ae = Ae < Se ? W[_e - 1] : W[_e + 1];
      }
      if (Ae = Nu(Ae, l, s), V) {
        o && (Ae = Nu(Ae, F[ue - 1] || -1 / 0, F[ue + 1] || 1 / 0));
        const Ue = Ae;
        Ae = y4({
          values: F,
          newValue: Ae,
          index: ue
        });
        let Ft = ue;
        o || (Ft = Ae.indexOf(Ue)), iv({
          sliderRef: U,
          activeIndex: Ft
        });
      }
      B(Ae), $(ue), j && !av(Ae, P) && j(Re, Ae, ue), p && p(Re, L.current ?? Ae);
    }, Q = (Re) => (oe) => {
      if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "PageUp", "PageDown", "Home", "End"].includes(oe.key)) {
        oe.preventDefault();
        const ue = Number(oe.currentTarget.getAttribute("data-index")), Se = F[ue];
        let _e = null;
        if (b != null) {
          const Ae = oe.shiftKey ? v : b;
          switch (oe.key) {
            case "ArrowUp":
              _e = Au(Se, Ae, 1, l, s);
              break;
            case "ArrowRight":
              _e = Au(Se, Ae, i ? -1 : 1, l, s);
              break;
            case "ArrowDown":
              _e = Au(Se, Ae, -1, l, s);
              break;
            case "ArrowLeft":
              _e = Au(Se, Ae, i ? 1 : -1, l, s);
              break;
            case "PageUp":
              _e = Au(Se, v, 1, l, s);
              break;
            case "PageDown":
              _e = Au(Se, v, -1, l, s);
              break;
            case "Home":
              _e = l;
              break;
            case "End":
              _e = s;
              break;
          }
        } else if (G) {
          const Ae = W[W.length - 1], Ue = W.indexOf(Se), Ft = [i ? "ArrowRight" : "ArrowLeft", "ArrowDown", "PageDown", "Home"], ut = [i ? "ArrowLeft" : "ArrowRight", "ArrowUp", "PageUp", "End"];
          Ft.includes(oe.key) ? Ue === 0 ? _e = W[0] : _e = W[Ue - 1] : ut.includes(oe.key) && (Ue === W.length - 1 ? _e = Ae : _e = W[Ue + 1]);
        }
        _e != null && Y(oe, _e);
      }
      Re?.onKeyDown?.(oe);
    };
    Ko(() => {
      r && U.current.contains(document.activeElement) && document.activeElement?.blur();
    }, [r]), r && C !== -1 && k(-1), r && K !== -1 && $(-1);
    const re = (Re) => (oe) => {
      Re.onChange?.(oe), Y(oe, oe.target.valueAsNumber);
    }, te = T.useRef(void 0);
    let le = h;
    i && h === "horizontal" && (le += "-reverse");
    const fe = ({
      finger: Re,
      move: oe = !1
    }) => {
      const {
        current: ue
      } = U, {
        width: Se,
        height: _e,
        bottom: Ae,
        left: Ue
      } = ue.getBoundingClientRect();
      let Ft;
      le.startsWith("vertical") ? Ft = (Ae - Re.y) / _e : Ft = (Re.x - Ue) / Se, le.includes("-reverse") && (Ft = 1 - Ft);
      let ut;
      if (ut = LFe(Ft, l, s), b)
        ut = BFe(ut, b, l);
      else {
        const Ie = g4(W, ut);
        ut = W[Ie];
      }
      ut = Nu(ut, l, s);
      let sn = 0;
      if (V) {
        oe ? sn = te.current : sn = g4(F, ut), o && (ut = Nu(ut, F[sn - 1] || -1 / 0, F[sn + 1] || 1 / 0));
        const Ie = ut;
        ut = y4({
          values: F,
          newValue: ut,
          index: sn
        }), o && oe || (sn = ut.indexOf(Ie), te.current = sn);
      }
      return {
        newValue: ut,
        activeIndex: sn
      };
    }, J = Li((Re) => {
      const oe = ov(Re, _);
      if (!oe)
        return;
      if (D.current += 1, Re.type === "mousemove" && Re.buttons === 0) {
        ee(Re);
        return;
      }
      const {
        newValue: ue,
        activeIndex: Se
      } = fe({
        finger: oe,
        move: !0
      });
      iv({
        sliderRef: U,
        activeIndex: Se,
        setActive: k
      }), B(ue), !M && D.current > FFe && I(!0), j && !av(ue, P) && j(Re, ue, Se);
    }), ee = Li((Re) => {
      const oe = ov(Re, _);
      if (I(!1), !oe)
        return;
      const {
        newValue: ue
      } = fe({
        finger: oe,
        move: !0
      });
      k(-1), Re.type === "touchend" && A(-1), p && p(Re, L.current ?? ue), _.current = void 0, ae();
    }), ie = Li((Re) => {
      if (r)
        return;
      v4() || Re.preventDefault();
      const oe = Re.changedTouches[0];
      oe != null && (_.current = oe.identifier);
      const ue = ov(Re, _);
      if (ue !== !1) {
        const {
          newValue: _e,
          activeIndex: Ae
        } = fe({
          finger: ue
        });
        iv({
          sliderRef: U,
          activeIndex: Ae,
          setActive: k
        }), B(_e), j && !av(_e, P) && j(Re, _e, Ae);
      }
      D.current = 0;
      const Se = Rr(U.current);
      Se.addEventListener("touchmove", J, {
        passive: !0
      }), Se.addEventListener("touchend", ee, {
        passive: !0
      });
    }), ae = T.useCallback(() => {
      const Re = Rr(U.current);
      Re.removeEventListener("mousemove", J), Re.removeEventListener("mouseup", ee), Re.removeEventListener("touchmove", J), Re.removeEventListener("touchend", ee);
    }, [ee, J]);
    T.useEffect(() => {
      const {
        current: Re
      } = U;
      return Re.addEventListener("touchstart", ie, {
        passive: v4()
      }), () => {
        Re.removeEventListener("touchstart", ie), ae();
      };
    }, [ae, ie]), T.useEffect(() => {
      r && ae();
    }, [r, ae]);
    const ge = (Re) => (oe) => {
      if (Re.onMouseDown?.(oe), r || oe.defaultPrevented || oe.button !== 0)
        return;
      oe.preventDefault();
      const ue = ov(oe, _);
      if (ue !== !1) {
        const {
          newValue: _e,
          activeIndex: Ae
        } = fe({
          finger: ue
        });
        iv({
          sliderRef: U,
          activeIndex: Ae,
          setActive: k
        }), B(_e), j && !av(_e, P) && j(oe, _e, Ae);
      }
      D.current = 0;
      const Se = Rr(U.current);
      Se.addEventListener("mousemove", J, {
        passive: !0
      }), Se.addEventListener("mouseup", ee);
    }, Ce = L0(V ? F[0] : l, l, s), Ne = L0(F[F.length - 1], l, s) - Ce, Le = (Re = {}) => {
      const oe = Cp(Re), ue = {
        onMouseDown: ge(oe || {})
      }, Se = {
        ...oe,
        ...ue
      };
      return {
        ...Re,
        ref: X,
        ...Se
      };
    }, Ve = (Re) => (oe) => {
      Re.onMouseOver?.(oe);
      const ue = Number(oe.currentTarget.getAttribute("data-index"));
      A(ue);
    }, Ke = (Re) => (oe) => {
      Re.onMouseLeave?.(oe), A(-1);
    }, ze = (Re = {}) => {
      const oe = Cp(Re), ue = {
        onMouseOver: Ve(oe || {}),
        onMouseLeave: Ke(oe || {})
      };
      return {
        ...Re,
        ...oe,
        ...ue
      };
    }, Me = (Re) => ({
      // So the non active thumb doesn't show its label on hover.
      pointerEvents: C !== -1 && C !== Re ? "none" : void 0
    });
    let ct;
    return h === "vertical" && (ct = i ? "vertical-rl" : "vertical-lr"), {
      active: C,
      axis: le,
      axisProps: UFe,
      dragging: M,
      focusedThumbIndex: K,
      getHiddenInputProps: (Re = {}) => {
        const oe = Cp(Re), ue = {
          onChange: re(oe || {}),
          onFocus: z(oe || {}),
          onBlur: H(oe || {}),
          onKeyDown: Q(oe || {})
        }, Se = {
          ...oe,
          ...ue
        };
        return {
          tabIndex: x,
          "aria-labelledby": t,
          "aria-orientation": h,
          "aria-valuemax": y(s),
          "aria-valuemin": y(l),
          name: u,
          type: "range",
          min: e.min,
          max: e.max,
          step: e.step === null && e.marks ? "any" : e.step ?? void 0,
          disabled: r,
          ...Re,
          ...Se,
          style: {
            ...jFe,
            direction: i ? "rtl" : "ltr",
            // So that VoiceOver's focus indicator matches the thumb's dimensions
            width: "100%",
            height: "100%",
            writingMode: ct
          }
        };
      },
      getRootProps: Le,
      getThumbProps: ze,
      marks: G,
      open: R,
      range: V,
      rootRef: X,
      trackLeap: Ne,
      trackOffset: Ce,
      values: F,
      getThumbStyle: Me
    };
  }
  const qFe = (e) => !e || !zi(e);
  function WFe(e) {
    return it("MuiSlider", e);
  }
  const ko = rt("MuiSlider", ["root", "active", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "disabled", "dragging", "focusVisible", "mark", "markActive", "marked", "markLabel", "markLabelActive", "rail", "sizeSmall", "thumb", "thumbColorPrimary", "thumbColorSecondary", "thumbColorError", "thumbColorSuccess", "thumbColorInfo", "thumbColorWarning", "track", "trackInverted", "trackFalse", "thumbSizeSmall", "valueLabel", "valueLabelOpen", "valueLabelCircle", "valueLabelLabel", "vertical"]), GFe = (e) => {
    const {
      open: t
    } = e;
    return {
      offset: je(t && ko.valueLabelOpen),
      circle: ko.valueLabelCircle,
      label: ko.valueLabelLabel
    };
  };
  function KFe(e) {
    const {
      children: t,
      className: n,
      value: r
    } = e, o = GFe(e);
    return t ? /* @__PURE__ */ T.cloneElement(t, {
      className: t.props.className
    }, /* @__PURE__ */ S.jsxs(T.Fragment, {
      children: [t.props.children, /* @__PURE__ */ S.jsx("span", {
        className: je(o.offset, n),
        "aria-hidden": !0,
        children: /* @__PURE__ */ S.jsx("span", {
          className: o.circle,
          children: /* @__PURE__ */ S.jsx("span", {
            className: o.label,
            children: r
          })
        })
      })]
    })) : null;
  }
  function b4(e) {
    return e;
  }
  const YFe = Oe("span", {
    name: "MuiSlider",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[`color${$e(n.color)}`], n.size !== "medium" && t[`size${$e(n.size)}`], n.marked && t.marked, n.orientation === "vertical" && t.vertical, n.track === "inverted" && t.trackInverted, n.track === !1 && t.trackFalse];
    }
  })(at(({
    theme: e
  }) => ({
    borderRadius: 12,
    boxSizing: "content-box",
    display: "inline-block",
    position: "relative",
    cursor: "pointer",
    touchAction: "none",
    WebkitTapHighlightColor: "transparent",
    "@media print": {
      colorAdjust: "exact"
    },
    [`&.${ko.disabled}`]: {
      pointerEvents: "none",
      cursor: "default",
      color: (e.vars || e).palette.grey[400]
    },
    [`&.${ko.dragging}`]: {
      [`& .${ko.thumb}, & .${ko.track}`]: {
        transition: "none"
      }
    },
    variants: [...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        color: (e.vars || e).palette[t].main
      }
    })), {
      props: {
        orientation: "horizontal"
      },
      style: {
        height: 4,
        width: "100%",
        padding: "13px 0",
        // The primary input mechanism of the device includes a pointing device of limited accuracy.
        "@media (pointer: coarse)": {
          // Reach 42px touch target, about ~8mm on screen.
          padding: "20px 0"
        }
      }
    }, {
      props: {
        orientation: "horizontal",
        size: "small"
      },
      style: {
        height: 2
      }
    }, {
      props: {
        orientation: "horizontal",
        marked: !0
      },
      style: {
        marginBottom: 20
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        height: "100%",
        width: 4,
        padding: "0 13px",
        // The primary input mechanism of the device includes a pointing device of limited accuracy.
        "@media (pointer: coarse)": {
          // Reach 42px touch target, about ~8mm on screen.
          padding: "0 20px"
        }
      }
    }, {
      props: {
        orientation: "vertical",
        size: "small"
      },
      style: {
        width: 2
      }
    }, {
      props: {
        orientation: "vertical",
        marked: !0
      },
      style: {
        marginRight: 44
      }
    }]
  }))), XFe = Oe("span", {
    name: "MuiSlider",
    slot: "Rail"
  })({
    display: "block",
    position: "absolute",
    borderRadius: "inherit",
    backgroundColor: "currentColor",
    opacity: 0.38,
    variants: [{
      props: {
        orientation: "horizontal"
      },
      style: {
        width: "100%",
        height: "inherit",
        top: "50%",
        transform: "translateY(-50%)"
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        height: "100%",
        width: "inherit",
        left: "50%",
        transform: "translateX(-50%)"
      }
    }, {
      props: {
        track: "inverted"
      },
      style: {
        opacity: 1
      }
    }]
  }), ZFe = Oe("span", {
    name: "MuiSlider",
    slot: "Track"
  })(at(({
    theme: e
  }) => ({
    display: "block",
    position: "absolute",
    borderRadius: "inherit",
    border: "1px solid currentColor",
    backgroundColor: "currentColor",
    transition: e.transitions.create(["left", "width", "bottom", "height"], {
      duration: e.transitions.duration.shortest
    }),
    variants: [{
      props: {
        size: "small"
      },
      style: {
        border: "none"
      }
    }, {
      props: {
        orientation: "horizontal"
      },
      style: {
        height: "inherit",
        top: "50%",
        transform: "translateY(-50%)"
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        width: "inherit",
        left: "50%",
        transform: "translateX(-50%)"
      }
    }, {
      props: {
        track: !1
      },
      style: {
        display: "none"
      }
    }, ...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t,
        track: "inverted"
      },
      style: {
        ...e.vars ? {
          backgroundColor: e.vars.palette.Slider[`${t}Track`],
          borderColor: e.vars.palette.Slider[`${t}Track`]
        } : {
          backgroundColor: e.lighten(e.palette[t].main, 0.62),
          borderColor: e.lighten(e.palette[t].main, 0.62),
          ...e.applyStyles("dark", {
            backgroundColor: e.darken(e.palette[t].main, 0.5)
          }),
          ...e.applyStyles("dark", {
            borderColor: e.darken(e.palette[t].main, 0.5)
          })
        }
      }
    }))]
  }))), QFe = Oe("span", {
    name: "MuiSlider",
    slot: "Thumb",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.thumb, t[`thumbColor${$e(n.color)}`], n.size !== "medium" && t[`thumbSize${$e(n.size)}`]];
    }
  })(at(({
    theme: e
  }) => ({
    position: "absolute",
    width: 20,
    height: 20,
    boxSizing: "border-box",
    borderRadius: "50%",
    outline: 0,
    backgroundColor: "currentColor",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    transition: e.transitions.create(["box-shadow", "left", "bottom"], {
      duration: e.transitions.duration.shortest
    }),
    "&::before": {
      position: "absolute",
      content: '""',
      borderRadius: "inherit",
      width: "100%",
      height: "100%",
      boxShadow: (e.vars || e).shadows[2]
    },
    "&::after": {
      position: "absolute",
      content: '""',
      borderRadius: "50%",
      // 42px is the hit target
      width: 42,
      height: 42,
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)"
    },
    [`&.${ko.disabled}`]: {
      "&:hover": {
        boxShadow: "none"
      }
    },
    variants: [{
      props: {
        size: "small"
      },
      style: {
        width: 12,
        height: 12,
        "&::before": {
          boxShadow: "none"
        }
      }
    }, {
      props: {
        orientation: "horizontal"
      },
      style: {
        top: "50%",
        transform: "translate(-50%, -50%)"
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        left: "50%",
        transform: "translate(-50%, 50%)"
      }
    }, ...Object.entries(e.palette).filter(xr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        [`&:hover, &.${ko.focusVisible}`]: {
          boxShadow: `0px 0px 0px 8px ${e.alpha((e.vars || e).palette[t].main, 0.16)}`,
          "@media (hover: none)": {
            boxShadow: "none"
          }
        },
        [`&.${ko.active}`]: {
          boxShadow: `0px 0px 0px 14px ${e.alpha((e.vars || e).palette[t].main, 0.16)}`
        }
      }
    }))]
  }))), JFe = Oe(KFe, {
    name: "MuiSlider",
    slot: "ValueLabel"
  })(at(({
    theme: e
  }) => ({
    zIndex: 1,
    whiteSpace: "nowrap",
    ...e.typography.body2,
    fontWeight: 500,
    transition: e.transitions.create(["transform"], {
      duration: e.transitions.duration.shortest
    }),
    position: "absolute",
    backgroundColor: (e.vars || e).palette.grey[600],
    borderRadius: 2,
    color: (e.vars || e).palette.common.white,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    padding: "0.25rem 0.75rem",
    variants: [{
      props: {
        orientation: "horizontal"
      },
      style: {
        transform: "translateY(-100%) scale(0)",
        top: "-10px",
        transformOrigin: "bottom center",
        "&::before": {
          position: "absolute",
          content: '""',
          width: 8,
          height: 8,
          transform: "translate(-50%, 50%) rotate(45deg)",
          backgroundColor: "inherit",
          bottom: 0,
          left: "50%"
        },
        [`&.${ko.valueLabelOpen}`]: {
          transform: "translateY(-100%) scale(1)"
        }
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        transform: "translateY(-50%) scale(0)",
        right: "30px",
        top: "50%",
        transformOrigin: "right center",
        "&::before": {
          position: "absolute",
          content: '""',
          width: 8,
          height: 8,
          transform: "translate(-50%, -50%) rotate(45deg)",
          backgroundColor: "inherit",
          right: -8,
          top: "50%"
        },
        [`&.${ko.valueLabelOpen}`]: {
          transform: "translateY(-50%) scale(1)"
        }
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        fontSize: e.typography.pxToRem(12),
        padding: "0.25rem 0.5rem"
      }
    }, {
      props: {
        orientation: "vertical",
        size: "small"
      },
      style: {
        right: "20px"
      }
    }]
  }))), eLe = Oe("span", {
    name: "MuiSlider",
    slot: "Mark",
    shouldForwardProp: (e) => ib(e) && e !== "markActive",
    overridesResolver: (e, t) => {
      const {
        markActive: n
      } = e;
      return [t.mark, n && t.markActive];
    }
  })(at(({
    theme: e
  }) => ({
    position: "absolute",
    width: 2,
    height: 2,
    borderRadius: 1,
    backgroundColor: "currentColor",
    variants: [{
      props: {
        orientation: "horizontal"
      },
      style: {
        top: "50%",
        transform: "translate(-1px, -50%)"
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        left: "50%",
        transform: "translate(-50%, 1px)"
      }
    }, {
      props: {
        markActive: !0
      },
      style: {
        backgroundColor: (e.vars || e).palette.background.paper,
        opacity: 0.8
      }
    }]
  }))), tLe = Oe("span", {
    name: "MuiSlider",
    slot: "MarkLabel",
    shouldForwardProp: (e) => ib(e) && e !== "markLabelActive"
  })(at(({
    theme: e
  }) => ({
    ...e.typography.body2,
    color: (e.vars || e).palette.text.secondary,
    position: "absolute",
    whiteSpace: "nowrap",
    variants: [{
      props: {
        orientation: "horizontal"
      },
      style: {
        top: 30,
        transform: "translateX(-50%)",
        "@media (pointer: coarse)": {
          top: 40
        }
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        left: 36,
        transform: "translateY(50%)",
        "@media (pointer: coarse)": {
          left: 44
        }
      }
    }, {
      props: {
        markLabelActive: !0
      },
      style: {
        color: (e.vars || e).palette.text.primary
      }
    }]
  }))), nLe = (e) => {
    const {
      disabled: t,
      dragging: n,
      marked: r,
      orientation: o,
      track: i,
      classes: a,
      color: s,
      size: l
    } = e, u = {
      root: ["root", t && "disabled", n && "dragging", r && "marked", o === "vertical" && "vertical", i === "inverted" && "trackInverted", i === !1 && "trackFalse", s && `color${$e(s)}`, l && `size${$e(l)}`],
      rail: ["rail"],
      track: ["track"],
      mark: ["mark"],
      markActive: ["markActive"],
      markLabel: ["markLabel"],
      markLabelActive: ["markLabelActive"],
      valueLabel: ["valueLabel"],
      thumb: ["thumb", t && "disabled", l && `thumbSize${$e(l)}`, s && `thumbColor${$e(s)}`],
      active: ["active"],
      disabled: ["disabled"],
      focusVisible: ["focusVisible"]
    };
    return ot(u, WFe, a);
  }, rLe = ({
    children: e
  }) => e, oLe = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiSlider"
    }), o = tF(), {
      "aria-label": i,
      "aria-valuetext": a,
      "aria-labelledby": s,
      // eslint-disable-next-line react/prop-types
      component: l = "span",
      components: u = {},
      componentsProps: d = {},
      color: p = "primary",
      classes: h,
      className: g,
      disableSwap: y = !1,
      disabled: b = !1,
      getAriaLabel: v,
      getAriaValueText: x,
      marks: E = !1,
      max: _ = 100,
      min: C = 0,
      name: k,
      onChange: R,
      onChangeCommitted: A,
      orientation: M = "horizontal",
      shiftStep: I = 10,
      size: D = "medium",
      step: L = 1,
      scale: P = b4,
      slotProps: B,
      slots: j,
      tabIndex: V,
      track: F = "normal",
      value: G,
      valueLabelDisplay: W = "off",
      valueLabelFormat: K = b4,
      ...$
    } = r, U = {
      ...r,
      isRtl: o,
      max: _,
      min: C,
      classes: h,
      disabled: b,
      disableSwap: y,
      orientation: M,
      marks: E,
      color: p,
      size: D,
      step: L,
      shiftStep: I,
      scale: P,
      track: F,
      valueLabelDisplay: W,
      valueLabelFormat: K
    }, {
      axisProps: X,
      getRootProps: z,
      getHiddenInputProps: H,
      getThumbProps: Y,
      open: Q,
      active: re,
      axis: te,
      focusedThumbIndex: le,
      range: fe,
      dragging: J,
      marks: ee,
      values: ie,
      trackOffset: ae,
      trackLeap: ge,
      getThumbStyle: Ce
    } = HFe({
      ...U,
      rootRef: n
    });
    U.marked = ee.length > 0 && ee.some((Zt) => Zt.label), U.dragging = J, U.focusedThumbIndex = le;
    const Ne = nLe(U), Le = j?.root ?? u.Root ?? YFe, Ve = j?.rail ?? u.Rail ?? XFe, Ke = j?.track ?? u.Track ?? ZFe, ze = j?.thumb ?? u.Thumb ?? QFe, Me = j?.valueLabel ?? u.ValueLabel ?? JFe, ct = j?.mark ?? u.Mark ?? eLe, wt = j?.markLabel ?? u.MarkLabel ?? tLe, Re = j?.input ?? u.Input ?? "input", oe = B?.root ?? d.root, ue = B?.rail ?? d.rail, Se = B?.track ?? d.track, _e = B?.thumb ?? d.thumb, Ae = B?.valueLabel ?? d.valueLabel, Ue = B?.mark ?? d.mark, Ft = B?.markLabel ?? d.markLabel, ut = B?.input ?? d.input, sn = Ta({
      elementType: Le,
      getSlotProps: z,
      externalSlotProps: oe,
      externalForwardedProps: $,
      additionalProps: {
        ...qFe(Le) && {
          as: l
        }
      },
      ownerState: {
        ...U,
        ...oe?.ownerState
      },
      className: [Ne.root, g]
    }), Ie = Ta({
      elementType: Ve,
      externalSlotProps: ue,
      ownerState: U,
      className: Ne.rail
    }), tt = Ta({
      elementType: Ke,
      externalSlotProps: Se,
      additionalProps: {
        style: {
          ...X[te].offset(ae),
          ...X[te].leap(ge)
        }
      },
      ownerState: {
        ...U,
        ...Se?.ownerState
      },
      className: Ne.track
    }), Ct = Ta({
      elementType: ze,
      getSlotProps: Y,
      externalSlotProps: _e,
      ownerState: {
        ...U,
        ..._e?.ownerState
      },
      className: Ne.thumb
    }), Sn = Ta({
      elementType: Me,
      externalSlotProps: Ae,
      ownerState: {
        ...U,
        ...Ae?.ownerState
      },
      className: Ne.valueLabel
    }), $o = Ta({
      elementType: ct,
      externalSlotProps: Ue,
      ownerState: U,
      className: Ne.mark
    }), ns = Ta({
      elementType: wt,
      externalSlotProps: Ft,
      ownerState: U,
      className: Ne.markLabel
    }), pl = Ta({
      elementType: Re,
      getSlotProps: H,
      externalSlotProps: ut,
      ownerState: U
    });
    return /* @__PURE__ */ S.jsxs(Le, {
      ...sn,
      children: [/* @__PURE__ */ S.jsx(Ve, {
        ...Ie
      }), /* @__PURE__ */ S.jsx(Ke, {
        ...tt
      }), ee.filter((Zt) => Zt.value >= C && Zt.value <= _).map((Zt, On) => {
        const rs = L0(Zt.value, C, _), ii = X[te].offset(rs);
        let _r;
        return F === !1 ? _r = ie.includes(Zt.value) : _r = F === "normal" && (fe ? Zt.value >= ie[0] && Zt.value <= ie[ie.length - 1] : Zt.value <= ie[0]) || F === "inverted" && (fe ? Zt.value <= ie[0] || Zt.value >= ie[ie.length - 1] : Zt.value >= ie[0]), /* @__PURE__ */ S.jsxs(T.Fragment, {
          children: [/* @__PURE__ */ S.jsx(ct, {
            "data-index": On,
            ...$o,
            ...!zi(ct) && {
              markActive: _r
            },
            style: {
              ...ii,
              ...$o.style
            },
            className: je($o.className, _r && Ne.markActive)
          }), Zt.label != null ? /* @__PURE__ */ S.jsx(wt, {
            "aria-hidden": !0,
            "data-index": On,
            ...ns,
            ...!zi(wt) && {
              markLabelActive: _r
            },
            style: {
              ...ii,
              ...ns.style
            },
            className: je(Ne.markLabel, ns.className, _r && Ne.markLabelActive),
            children: Zt.label
          }) : null]
        }, On);
      }), ie.map((Zt, On) => {
        const rs = L0(Zt, C, _), ii = X[te].offset(rs), _r = W === "off" ? rLe : Me;
        return (
          /* TODO v6: Change component structure. It will help in avoiding the complicated React.cloneElement API added in SliderValueLabel component. Should be: Thumb -> Input, ValueLabel. Follow Joy UI's Slider structure. */
          /* @__PURE__ */ S.jsx(_r, {
            ...!zi(_r) && {
              valueLabelFormat: K,
              valueLabelDisplay: W,
              value: typeof K == "function" ? K(P(Zt), On) : K,
              index: On,
              open: Q === On || re === On || W === "on",
              disabled: b
            },
            ...Sn,
            children: /* @__PURE__ */ S.jsx(ze, {
              "data-index": On,
              ...Ct,
              className: je(Ne.thumb, Ct.className, re === On && Ne.active, le === On && Ne.focusVisible),
              style: {
                ...ii,
                ...Ce(On),
                ...Ct.style
              },
              children: /* @__PURE__ */ S.jsx(Re, {
                "data-index": On,
                "aria-label": v ? v(On) : i,
                "aria-valuenow": P(Zt),
                "aria-labelledby": s,
                "aria-valuetext": x ? x(P(Zt), On) : a,
                value: ie[On],
                ...pl
              })
            })
          }, On)
        );
      })]
    });
  });
  function iLe(e) {
    const { value: t, readonly: n, disabled: r, onBlur: o, onFocus: i, options: a, schema: s, onChange: l, required: u, label: d, hideLabel: p, id: h } = e, g = { value: t, label: d, id: h, name: h, ...o7(s) }, y = (x, E) => {
      l(E ?? a.emptyValue);
    }, b = ({ target: x }) => o(h, x && x.value), v = ({ target: x }) => i(h, x && x.value);
    return S.jsxs(S.Fragment, { children: [Rc(S.jsx(M1, { required: u, htmlFor: h, children: d || void 0 }), p), S.jsx(oLe, { disabled: r || n, onChange: y, onBlur: b, onFocus: v, valueLabelDisplay: "auto", ...g, "aria-describedby": po(h) })] });
  }
  function aLe(e) {
    return it("MuiMenuItem", e);
  }
  const cp = rt("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]), sLe = (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.dense && t.dense, n.divider && t.divider, !n.disableGutters && t.gutters];
  }, lLe = (e) => {
    const {
      disabled: t,
      dense: n,
      divider: r,
      disableGutters: o,
      selected: i,
      classes: a
    } = e, l = ot({
      root: ["root", n && "dense", t && "disabled", !o && "gutters", r && "divider", i && "selected"]
    }, aLe, a);
    return {
      ...a,
      ...l
    };
  }, cLe = Oe(Ih, {
    shouldForwardProp: (e) => wr(e) || e === "classes",
    name: "MuiMenuItem",
    slot: "Root",
    overridesResolver: sLe
  })(at(({
    theme: e
  }) => ({
    ...e.typography.body1,
    display: "flex",
    justifyContent: "flex-start",
    alignItems: "center",
    position: "relative",
    textDecoration: "none",
    minHeight: 48,
    paddingTop: 6,
    paddingBottom: 6,
    boxSizing: "border-box",
    whiteSpace: "nowrap",
    "&:hover": {
      textDecoration: "none",
      backgroundColor: (e.vars || e).palette.action.hover,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    },
    [`&.${cp.selected}`]: {
      backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity),
      [`&.${cp.focusVisible}`]: {
        backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.focusOpacity}`)
      }
    },
    [`&.${cp.selected}:hover`]: {
      backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.hoverOpacity}`),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity)
      }
    },
    [`&.${cp.focusVisible}`]: {
      backgroundColor: (e.vars || e).palette.action.focus
    },
    [`&.${cp.disabled}`]: {
      opacity: (e.vars || e).palette.action.disabledOpacity
    },
    [`& + .${h4.root}`]: {
      marginTop: e.spacing(1),
      marginBottom: e.spacing(1)
    },
    [`& + .${h4.inset}`]: {
      marginLeft: 52
    },
    [`& .${Bu.root}`]: {
      marginTop: 0,
      marginBottom: 0
    },
    [`& .${Bu.inset}`]: {
      paddingLeft: 36
    },
    [`& .${d4.root}`]: {
      minWidth: 36
    },
    variants: [{
      props: ({
        ownerState: t
      }) => !t.disableGutters,
      style: {
        paddingLeft: 16,
        paddingRight: 16
      }
    }, {
      props: ({
        ownerState: t
      }) => t.divider,
      style: {
        borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
        backgroundClip: "padding-box"
      }
    }, {
      props: ({
        ownerState: t
      }) => !t.dense,
      style: {
        [e.breakpoints.up("sm")]: {
          minHeight: "auto"
        }
      }
    }, {
      props: ({
        ownerState: t
      }) => t.dense,
      style: {
        minHeight: 32,
        // https://m2.material.io/components/menus#specs > Dense
        paddingTop: 4,
        paddingBottom: 4,
        ...e.typography.body2,
        [`& .${d4.root} svg`]: {
          fontSize: "1.25rem"
        }
      }
    }]
  }))), x4 = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = lt({
      props: t,
      name: "MuiMenuItem"
    }), {
      autoFocus: o = !1,
      component: i = "li",
      dense: a = !1,
      divider: s = !1,
      disableGutters: l = !1,
      focusVisibleClassName: u,
      role: d = "menuitem",
      tabIndex: p,
      className: h,
      ...g
    } = r, y = T.useContext(Ia), b = T.useMemo(() => ({
      dense: a || y.dense || !1,
      disableGutters: l
    }), [y.dense, a, l]), v = T.useRef(null);
    Ko(() => {
      o && v.current && v.current.focus();
    }, [o]);
    const x = {
      ...r,
      dense: b.dense,
      divider: s,
      disableGutters: l
    }, E = lLe(r), _ = er(v, n);
    let C;
    return r.disabled || (C = p !== void 0 ? p : -1), /* @__PURE__ */ S.jsx(Ia.Provider, {
      value: b,
      children: /* @__PURE__ */ S.jsx(cLe, {
        ref: _,
        role: d,
        tabIndex: C,
        component: i,
        focusVisibleClassName: je(E.focusVisible, u),
        className: je(E.root, h),
        ...g,
        ownerState: x,
        classes: E
      })
    });
  });
  function uLe({
    schema: e,
    id: t,
    name: n,
    // remove this from textFieldProps
    htmlName: r,
    options: o,
    label: i,
    hideLabel: a,
    required: s,
    disabled: l,
    placeholder: u,
    readonly: d,
    value: p,
    multiple: h,
    autofocus: g,
    onChange: y,
    onBlur: b,
    onFocus: v,
    errorSchema: x,
    rawErrors: E = [],
    registry: _,
    uiSchema: C,
    hideError: k,
    ...R
  }) {
    const { enumOptions: A, enumDisabled: M, emptyValue: I } = o;
    h = typeof h > "u" ? !1 : !!h;
    const D = h ? [] : "", L = typeof p > "u" || h && p.length < 1 || !h && p === D, P = ({ target: { value: U } }) => y(Jn(U, A, I)), B = ({ target: U }) => b(t, Jn(U && U.value, A, I)), j = ({ target: U }) => v(t, Jn(U && U.value, A, I)), V = XR(p, A, h), { InputLabelProps: F, SelectProps: G, autocomplete: W, ...K } = R, $ = !h && e.default === void 0;
    return S.jsxs(_O, { id: t, name: r || t, label: Rc(i || void 0, a, void 0), value: !L && typeof V < "u" ? V : D, required: s, disabled: l || d, autoFocus: g, autoComplete: W, placeholder: u, error: E.length > 0, onChange: P, onBlur: B, onFocus: j, ...K, select: !0, InputLabelProps: {
      ...F,
      shrink: !L
    }, SelectProps: {
      ...G,
      multiple: h
    }, "aria-describedby": po(t), children: [$ && S.jsx(x4, { value: "", children: u }), Array.isArray(A) && A.map(({ value: U, label: X }, z) => {
      const H = Array.isArray(M) && M.indexOf(U) !== -1;
      return S.jsx(x4, { value: String(z), disabled: H, children: X }, z);
    })] });
  }
  function fLe(e) {
    const { options: t, registry: n } = e, r = et("BaseInputTemplate", n, t);
    let o = 5;
    return (typeof t.rows == "string" || typeof t.rows == "number") && (o = t.rows), S.jsx(r, { ...e, multiline: !0, rows: o });
  }
  function dLe() {
    return {
      CheckboxWidget: hFe,
      CheckboxesWidget: vFe,
      RadioWidget: IFe,
      RangeWidget: iLe,
      SelectWidget: uLe,
      TextareaWidget: fLe
    };
  }
  function sq() {
    return {
      templates: X4e(),
      widgets: dLe()
    };
  }
  const pLe = sq();
  function hLe() {
    return D7(sq());
  }
  hLe();
  const mLe = D7(pLe), gLe = rb({
    cssVariables: { nativeColor: !0 },
    palette: {
      primary: {
        main: "var(--fn-primary-color)",
        contrastText: "var(--fn-app-background)"
      },
      text: {
        primary: "var(--fn-text-color-neutral)",
        secondary: "var(--fn-text-color-neutral)",
        disabled: "var(--fn-text-color-neutral)"
      },
      common: {
        black: "var(--fn-primary-color)",
        white: "var(--fn-app-background)"
      },
      background: {
        default: "var(--fn-app-background)",
        paper: "var(--fn-app-background)"
      }
    },
    shape: {
      borderRadius: "var(--fn-border-radius-s)"
    }
  }), yLe = ({
    getter: e,
    setter: t,
    setter_calls_getter: n = !1
  }) => {
    const [r, o] = T.useState(null), [i, a] = T.useState(void 0), [s, l] = T.useState(void 0), u = T.useCallback(async () => {
      const p = await e();
      o(p.jsonSchema), a(p.uiSchema), l(p.formData);
    }, [e]), d = T.useCallback(
      async (p) => {
        await t(p), n && await u();
      },
      [t, n, u]
    );
    return T.useEffect(() => {
      u();
    }, [u]), r ? /* @__PURE__ */ S.jsx(WDe, { theme: gLe, children: /* @__PURE__ */ S.jsx(
      mLe,
      {
        schema: r,
        uiSchema: i || void 0,
        formData: s || void 0,
        validator: E2e,
        liveValidate: "onChange",
        onChange: ({ formData: p }) => l(p),
        onSubmit: ({ formData: p }) => d(p)
      }
    ) }) : /* @__PURE__ */ S.jsx("div", { children: "Loading" });
  }, vLe = ({
    ins: e
  }) => {
    const [t, n] = T.useState(e.name), r = jt(), { lib: o } = Or(), i = () => {
      r.worker && o?.remove_external_worker(e.uuid, e.nodeclassid);
    }, a = () => {
      r.worker && (r.worker.update_external_worker(e.uuid, e.nodeclassid, {
        name: t
      }), e.name = t);
    };
    return /* @__PURE__ */ S.jsx(S.Fragment, { children: /* @__PURE__ */ S.jsx(
      Ga,
      {
        title: e.name,
        description: "Settings for " + e.name,
        trigger: /* @__PURE__ */ S.jsx("div", { children: "Settings" }),
        buttons: [
          {
            text: "Save",
            onClick: a,
            close: !0
          },
          {
            text: "Delete",
            onClick: i,
            close: !0
          }
        ],
        children: /* @__PURE__ */ S.jsxs("div", { children: [
          /* @__PURE__ */ S.jsxs("div", { children: [
            /* @__PURE__ */ S.jsx("label", { htmlFor: "name", children: "Name: " }),
            /* @__PURE__ */ S.jsx(
              "input",
              {
                type: "text",
                name: "name",
                value: t,
                onChange: (s) => n(s.target.value),
                className: "styledinput"
              }
            )
          ] }),
          o && /* @__PURE__ */ S.jsx(
            yLe,
            {
              getter: () => o.get_external_worker_config(e.uuid, e.nodeclassid),
              setter: async (s) => {
                if (r.worker)
                  return await r.worker.update_external_worker(
                    e.uuid,
                    e.nodeclassid,
                    {
                      name: t,
                      config: s
                    }
                  );
              },
              setter_calls_getter: !0
            }
          )
        ] })
      }
    ) });
  }, bLe = ({
    ins: e,
    lib: t,
    filter: n = "",
    parentkey: r
  }) => {
    const [o, i] = T.useState(!1), a = () => i(!o), s = t?.nodes?.filter(
      (l) => l.node_id.toLowerCase().includes(n.toLowerCase())
    );
    return /* @__PURE__ */ S.jsxs("div", { className: "shelfcontainer", children: [
      /* @__PURE__ */ S.jsxs(
        "div",
        {
          className: "shelftitle",
          onClick: a,
          style: { cursor: "pointer" },
          title: e.name,
          children: [
            /* @__PURE__ */ S.jsx("div", { className: "shelftitle_text", children: e.name }),
            /* @__PURE__ */ S.jsx("div", { className: "expandicon " + (o ? "open" : "close"), children: /* @__PURE__ */ S.jsx(zh, {}) })
          ]
        }
      ),
      /* @__PURE__ */ S.jsx("div", { className: "libnodecontainer " + (o ? "open" : "close"), children: /* @__PURE__ */ S.jsx("div", { className: "libnodecontainer_inner", children: o && /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
        /* @__PURE__ */ S.jsx("div", { className: "libnodeentry", title: e.uuid, children: /* @__PURE__ */ S.jsx(vLe, { ins: e }) }),
        t && /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
          s && /* @__PURE__ */ S.jsx(S.Fragment, { children: s.map((l) => /* @__PURE__ */ S.jsx(
            PU,
            {
              item: l
            },
            r + l.node_id
          )) }),
          t.subshelves.map((l) => /* @__PURE__ */ S.jsx(
            nR,
            {
              item: l,
              filter: n,
              parentkey: r + l.name
            },
            r + l.name
          ))
        ] })
      ] }) }) })
    ] });
  }, xLe = ({
    item: e,
    mod: t,
    lib: n
  }) => {
    const { lib: r } = Or(), [o, i] = T.useState(!1), a = () => i(!o), s = T.useCallback(() => {
      r?.add_external_worker({
        module: t,
        cls_module: e.module,
        cls_name: e.class_name
      });
    }, [r, t, e]), l = (d) => {
      d.detail === 2 && s();
    }, u = e.name || e.module + "." + e.class_name;
    return /* @__PURE__ */ S.jsxs("div", { className: "shelfcontainer", children: [
      /* @__PURE__ */ S.jsxs(
        "div",
        {
          className: "shelftitle",
          onClick: a,
          style: { cursor: "pointer" },
          title: u,
          children: [
            /* @__PURE__ */ S.jsx("div", { className: "shelftitle_text", children: u }),
            /* @__PURE__ */ S.jsx("div", { className: "expandicon " + (o ? "open" : "close"), children: /* @__PURE__ */ S.jsx(zh, {}) })
          ]
        }
      ),
      /* @__PURE__ */ S.jsx("div", { className: "libnodecontainer " + (o ? "open" : "close"), children: /* @__PURE__ */ S.jsx("div", { className: "libnodecontainer_inner", children: o && /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
        /* @__PURE__ */ S.jsx(
          "div",
          {
            className: "libnodeentry",
            onClick: l,
            title: e.name,
            children: "New Instance"
          }
        ),
        e.instances.map((d) => /* @__PURE__ */ S.jsx(
          bLe,
          {
            ins: d,
            lib: n?.subshelves.find(
              (p) => p.name === d.uuid
            ),
            parentkey: d.uuid
          },
          d.uuid
        ))
      ] }) }) })
    ] });
  }, wLe = ({
    externalworkermod: e,
    lib: t
  }) => {
    const [n, r] = T.useState(!1), o = () => r(!n), i = n;
    return /* @__PURE__ */ S.jsxs("div", { className: "shelfcontainer", children: [
      /* @__PURE__ */ S.jsxs(
        "div",
        {
          className: "shelftitle",
          onClick: o,
          style: { cursor: "pointer" },
          title: e.module,
          children: [
            /* @__PURE__ */ S.jsx("div", { className: "shelftitle_text", children: e.module }),
            /* @__PURE__ */ S.jsx("div", { className: "expandicon " + (i ? "open" : "close"), children: /* @__PURE__ */ S.jsx(zh, {}) })
          ]
        }
      ),
      /* @__PURE__ */ S.jsx("div", { className: "libnodecontainer " + (i ? "open" : "close"), children: /* @__PURE__ */ S.jsx("div", { className: "libnodecontainer_inner", children: e.worker_classes.map((a) => /* @__PURE__ */ S.jsx(
        xLe,
        {
          item: a,
          mod: e.module,
          lib: t
        },
        a.module + a.class_name
      )) }) }),
      /* @__PURE__ */ S.jsx("hr", {})
    ] });
  }, SLe = () => {
    const e = jt(), t = e.lib.libstate(), n = jt(), r = n.local_settings(
      (u) => u.view_settings.expand_lib
    ), o = (u) => {
      n.update_view_settings({ expand_lib: u });
    }, i = obe("m"), [a, s] = T.useState(""), l = e.worker?.state((u) => u.is_open) ?? !1;
    return /* @__PURE__ */ S.jsx(
      FT,
      {
        maxSize: i ? "100%" : "18.75rem",
        direction: i ? "down" : "right",
        containerClassName: "pos-left pos-top bg1 h-12",
        onExpandChange: o,
        expanded: r === void 0 ? !0 : r,
        collapseIcons: {
          up: Xv,
          down: Yp,
          left: Kp,
          right: Yv
        },
        expandIcons: {
          up: Yp,
          down: Xv,
          left: Yv,
          right: Kp
        },
        children: /* @__PURE__ */ S.jsxs("div", { className: "libcontainer", children: [
          /* @__PURE__ */ S.jsxs("div", { className: "library", children: [
            /* @__PURE__ */ S.jsx("div", { className: "libtitle", children: "Lib" }),
            /* @__PURE__ */ S.jsx("hr", { className: "hr_prominent" }),
            /* @__PURE__ */ S.jsx(kxe, { filter: a, setFilter: s }),
            /* @__PURE__ */ S.jsx("div", { className: "vscrollcontainer", children: t.lib.shelves.filter((u) => u.name !== "_external_worker").map((u) => /* @__PURE__ */ S.jsx(
              nR,
              {
                item: u,
                filter: a,
                parentkey: u.name
              },
              u.name
            )) }),
            /* @__PURE__ */ S.jsx("hr", {}),
            /* @__PURE__ */ S.jsx("div", { className: "libtitle", children: "External Worker" }),
            /* @__PURE__ */ S.jsx("hr", { className: "hr_prominent" }),
            /* @__PURE__ */ S.jsx("div", { className: "vscrollcontainer", children: t.external_worker?.map((u) => /* @__PURE__ */ S.jsx(
              wLe,
              {
                externalworkermod: u,
                lib: t.lib.shelves.find(
                  (d) => d.name === "_external_worker"
                )
              },
              u.module
            )) }),
            /* @__PURE__ */ S.jsx("hr", {})
          ] }),
          l && /* @__PURE__ */ S.jsx("div", { className: "addlib", children: /* @__PURE__ */ S.jsx(Txe, { children: /* @__PURE__ */ S.jsx("button", { children: "Manage Libraries" }) }) })
        ] })
      }
    );
  }, _Le = ({
    fnrf_zst: e,
    header: t,
    flow: n,
    library: r
  }) => {
    const [o, i] = T.useState(
      e.options.worker || e.getWorkerManager().worker
    ), a = T.useRef(null);
    e.workermanager && (e.workermanager.on_setWorker = i), T.useEffect(() => {
      e.auto_progress();
    }, []), T.useEffect(() => {
      e.local_state.setState({ funcnodescontainerRef: a.current });
    }, [a]);
    const s = e.plugins();
    return /* @__PURE__ */ S.jsx(V0e, { plugins: s, fnrf_zst: e, children: /* @__PURE__ */ S.jsx(yoe, { children: /* @__PURE__ */ S.jsx(JL.Provider, { value: e, children: /* @__PURE__ */ S.jsx(Us, { asChild: !0, children: /* @__PURE__ */ S.jsx(Ra, { asChild: !0, children: /* @__PURE__ */ S.jsx(
      O8,
      {
        style: {
          height: "100%",
          width: "100%",
          display: "flex",
          flexDirection: "column",
          flex: 1
        },
        children: /* @__PURE__ */ S.jsxs(
          "div",
          {
            ref: a,
            className: "funcnodesreactflowcontainer funcnodescontainer",
            children: [
              t.show && /* @__PURE__ */ S.jsx(Cxe, { ...t }),
              /* @__PURE__ */ S.jsxs("div", { className: "funcnodesreactflowbody", children: [
                /* @__PURE__ */ S.jsx(r1e, { ...n }),
                o && r.show && /* @__PURE__ */ S.jsx(SLe, {}),
                o && n.showNodeSettings && /* @__PURE__ */ S.jsx(cbe, {})
              ] }),
              /* @__PURE__ */ S.jsxs("div", { className: "funcnodesflaotingmenu", children: [
                /* @__PURE__ */ S.jsx(Ra.OutFullScreen, { children: n.allowExpand && /* @__PURE__ */ S.jsxs(Us.Trigger, { children: [
                  /* @__PURE__ */ S.jsx(Us.Expanded, { children: /* @__PURE__ */ S.jsx(
                    soe,
                    {
                      size: "xl",
                      style: { padding: "4px" }
                    }
                  ) }),
                  /* @__PURE__ */ S.jsx(Us.Collapsed, { children: /* @__PURE__ */ S.jsx(
                    loe,
                    {
                      size: "xl",
                      style: { padding: "4px" }
                    }
                  ) })
                ] }) }),
                n.allowFullScreen && /* @__PURE__ */ S.jsxs(Ra.Trigger, { children: [
                  /* @__PURE__ */ S.jsx(Ra.OutFullScreen, { children: /* @__PURE__ */ S.jsx(
                    QL,
                    {
                      size: "xl",
                      style: { padding: "4px" }
                    }
                  ) }),
                  /* @__PURE__ */ S.jsx(Ra.InFullScreen, { children: /* @__PURE__ */ S.jsx(
                    aoe,
                    {
                      size: "xl",
                      style: { padding: "4px" }
                    }
                  ) })
                ] })
              ] })
            ]
          }
        )
      }
    ) }) }) }) }) });
  };
  class Lf {
    constructor(t) {
      this.context = t;
    }
    get nodespaceManager() {
      return this.context.rf.getNodespaceManager();
    }
    get libManager() {
      return this.context.rf.getLibManager();
    }
    get workerManager() {
      return this.context.rf.getWorkerManager();
    }
    get stateManager() {
      return this.context.rf.getStateManager();
    }
    get pluginManager() {
      return this.context.rf.getPluginManager();
    }
    get reactFlowManager() {
      return this.context.rf.getReactFlowManager();
    }
  }
  const w4 = ({
    src_nid: e,
    src_ioid: t,
    trg_nid: n,
    trg_ioid: r
  }) => [`${e}:${t}`, `${n}:${r}`].sort().join("--"), ELe = ({}) => {
    const e = /* @__PURE__ */ new Map();
    return {
      nodesstates: e,
      get_node: (t, n = !0) => {
        const r = e.get(t);
        if (!r && n) {
          const o = e.keys();
          throw new Error(
            `Node ${t} not found, available nodes: ${Array.from(o)}`
          );
        }
        return r;
      }
    };
  };
  class CLe extends Lf {
    constructor(t) {
      super(t), this.on_node_action = (n) => {
        switch (n.type) {
          case "add":
            return this._add_node(n);
          case "update":
            return this._update_node(n);
          case "delete":
            return this._delete_node(n);
          case "error":
            return this._error_action(n);
          case "trigger":
            return this._trigger_action(n);
          default:
            this.context.rf.logger.error("Unknown node action", n);
            return;
        }
      }, this.on_edge_action = (n) => {
        const r = this.reactFlowManager.useReactFlowStore.getState();
        switch (n.type) {
          case "add":
            if (n.from_remote) {
              const o = r.getEdges(), i = w4(n);
              if (o.some((s) => s.id === i))
                return;
              const a = {
                id: i,
                source: n.src_nid,
                target: n.trg_nid,
                sourceHandle: n.src_ioid,
                targetHandle: n.trg_ioid,
                className: "funcnodes-edge animated",
                zIndex: 1003
                // just above elevated groups
              };
              this.context.rf.logger.info("Adding edge", a), r.update_edges([...o, a]), this.workerManager.worker?.api.node.get_remote_node_state(
                n.src_nid
              ), this.workerManager.worker?.api.node.get_remote_node_state(
                n.trg_nid
              );
            }
            break;
          case "delete":
            if (n.from_remote) {
              const o = r.getEdges(), i = w4(n);
              this.context.rf.logger.info("Deleting edge", i);
              const a = o.filter((s) => s.id !== i);
              r.update_edges(a), this.workerManager.worker?.api.node.get_remote_node_state(
                n.src_nid
              ), this.workerManager.worker?.api.node.get_remote_node_state(
                n.trg_nid
              );
            }
            break;
          default:
            this.context.rf.logger.error("Unknown edge action", n);
        }
      }, this.on_group_action = (n) => {
        switch (n.type) {
          case "set":
            return this._set_groups(n.groups);
          case "update":
            return this._update_group(n);
          default:
            this.context.rf.logger.error("Unknown group action", n);
        }
      }, this.clear_all = () => {
        this.context.rf.logger.debug("Clearing all nodespace"), this.workerManager.worker?.disconnect(), this.workerManager.set_worker(void 0), this.workerManager.workermanager?.setWorker(void 0), this.libManager.lib.libstate.getState().set({ lib: { shelves: [] }, external_worker: [] }), this.nodespace.nodesstates.clear(), this.reactFlowManager.useReactFlowStore.getState().update_nodes([]), this.reactFlowManager.useReactFlowStore.getState().update_edges([]), this.stateManager.auto_progress();
      }, this.center_node = (n) => {
        if (!this.reactFlowManager.rf_instance)
          return;
        n = Array.isArray(n) ? n : [n];
        const r = this.reactFlowManager.useReactFlowStore.getState().getNodes().filter((o) => n.includes(o.id));
        r.length > 0 && this.reactFlowManager.rf_instance?.fitView({ padding: 0.2, nodes: r });
      }, this.auto_resize_group = (n) => {
        const r = this.reactFlowManager.useReactFlowStore.getState(), o = r.getNode(n);
        if (o === void 0 || o.type !== "group")
          return;
        const i = o.data.group.node_ids.map((d) => r.getNode(d)).filter((d) => d !== void 0), a = o.data.group.child_groups.map((d) => r.getNode(d)).filter((d) => d !== void 0), s = [...i, ...a], l = this.reactFlowManager.rf_instance?.getNodesBounds(s);
        if (l === void 0)
          return;
        const u = {
          ...o,
          position: {
            x: l.x,
            y: l.y
          },
          height: l.height,
          width: l.width
        };
        u.data.group.position = [l.x, l.y], r.partial_update_nodes([u]);
      }, this.change_group_position = (n) => {
        if (n.position === void 0)
          return;
        const r = this.reactFlowManager.useReactFlowStore.getState(), o = r.getNode(n.id);
        if (o === void 0 || o.type !== "group")
          return;
        const i = [
          ...o.data.group.node_ids,
          ...o.data.group.child_groups
        ], a = this.reactFlowManager.rf_instance?.getNodesBounds(i);
        if (a === void 0)
          return;
        const s = n.position.x - a?.x, l = n.position.y - a?.y, u = [];
        for (const d of i) {
          const p = r.getNode(d);
          p !== void 0 && u.push({
            id: d,
            type: "position",
            position: {
              x: p.position.x + s,
              y: p.position.y + l
            }
          });
        }
        r.onNodesChange(u);
      }, this.change_fn_node_position = (n) => {
        n.position !== void 0 && this.on_node_action({
          type: "update",
          id: n.id,
          node: {
            properties: {
              "frontend:pos": [n.position.x, n.position.y]
            }
          },
          from_remote: !1
        });
      }, this.change_group_dimensions = (n) => {
        if (n.dimensions === void 0)
          return;
        const o = this.reactFlowManager.useReactFlowStore.getState().getNode(n.id);
        o !== void 0 && this.reactFlowManager.useReactFlowStore.getState().partial_update_nodes(NT([n], [o]));
      }, this.change_fn_node_dimensions = (n) => {
        n.dimensions !== void 0 && this.on_node_action({
          type: "update",
          id: n.id,
          node: {
            properties: {
              "frontend:size": [n.dimensions.width, n.dimensions.height]
            }
          },
          from_remote: !1
        });
      }, this._update_group = (n) => {
        if (n.from_remote) {
          const r = this.reactFlowManager.useReactFlowStore.getState(), o = r.getNode(n.id);
          if (o === void 0 || o.type !== "group")
            return;
          const { new_obj: i, change: a } = tc(o.data.group, n.group);
          a && (o.data.group = i), r.partial_update_nodes([o]);
        } else
          this.workerManager.worker && this.workerManager.worker.api.group.locally_update_group(n);
      }, this._set_groups = (n) => {
        const r = this.reactFlowManager.useReactFlowStore.getState(), { default_nodes: o } = VT(r.getNodes()), i = [...o], a = {};
        for (const l in n) {
          const u = n[l];
          for (const p of u.node_ids)
            a[p] = l;
          for (const p of u.child_groups)
            a[p] = l;
          u.position === void 0 && (u.position = [0, 0]);
          const d = {
            id: l,
            type: "group",
            data: { group: n[l], id: l },
            position: { x: u.position[0], y: u.position[1] },
            zIndex: 2
          };
          u.parent_group && (d.data.groupID = u.parent_group), i.push(d);
        }
        for (const l of i)
          l.id in a ? l.data.groupID = a[l.id] : l.data.groupID = void 0;
        const s = HT(i);
        r.update_nodes(s);
        for (const l of s.reverse())
          l.type === "group" && this.auto_resize_group(l.id);
      }, this._add_node = (n) => {
        this.context.rf.logger.info("add node", n);
        const r = this.reactFlowManager.useReactFlowStore.getState();
        if (n.from_remote) {
          let o = this.nodespace.get_node(n.node.id, !1);
          if (o)
            return;
          if (!o)
            try {
              o = Ybe(n.node), this.nodespace.nodesstates.set(n.node.id, o);
            } catch (l) {
              this.context.rf.logger.error(`Failed to create node store ${l}`);
              return;
            }
          const i = o.getState();
          this.context.rf.logger.info("Add node", i.id, i.name);
          const a = n1e(o, this.context.rf), s = [...r.getNodes(), a];
          this.reactFlowManager.useReactFlowStore.getState().update_nodes(s);
          for (const l of a.io_order)
            this.workerManager.worker?.api.node.get_io_value({
              nid: a.id,
              ioid: l
            });
          return setTimeout(() => {
            this.workerManager.worker?.api.hooks.call_hooks("node_added", {
              node: i.id
            });
          }, 0), i;
        }
      }, this._update_node = (n) => {
        if (Object.keys(n.node).length === 0) {
          this.context.rf.logger.error(
            "Node update is empty",
            new Error(JSON.stringify(n))
          );
          return;
        }
        if (n.node.in_trigger && (n.node.error = void 0), n.from_remote) {
          const r = this.nodespace.get_node(n.id, !1);
          if (!r) {
            console.error("Node not found to update", n.id);
            return;
          }
          return r.update(n.node), r.getState();
        } else
          this.workerManager.worker && this.workerManager.worker.api.node.locally_update_node(n);
      }, this._sync_nodes = () => {
        const n = this.reactFlowManager.useReactFlowStore.getState().getNodes(), r = this.nodespace.nodesstates;
        for (const o of r.keys())
          n.some((i) => i.id === o) || r.delete(o);
      }, this._delete_node = (n) => {
        this.context.rf.logger.info("Deleting node", n.id), n.from_remote ? (this.reactFlowManager.useReactFlowStore.getState().onNodesChange([
          {
            type: "remove",
            id: n.id
          }
        ]), this._sync_nodes()) : this.workerManager.worker?.api.node.remove_node(n.id);
      }, this._error_action = (n) => (this.context.rf.logger.error("Error", new Error(JSON.stringify(n))), this.on_node_action({
        type: "update",
        id: n.id,
        node: {
          in_trigger: !1,
          error: n.error
        },
        from_remote: !0
      })), this._trigger_action = (n) => {
        if (n.from_remote)
          return this.on_node_action({
            type: "update",
            id: n.id,
            node: {
              in_trigger: !0,
              error: void 0
            },
            from_remote: !0
          });
        this.workerManager.worker?.api.node.trigger_node(n.id);
      }, this.nodespace = ELe({});
    }
    center_all() {
      this.reactFlowManager.rf_instance?.fitView({ padding: 0.2 });
    }
  }
  const kLe = () => ({
    libstate: To((e, t) => ({
      lib: {
        shelves: []
      },
      external_worker: [],
      set: (n) => e((r) => ({ ...r, ...n })),
      get_lib: () => t().lib,
      get_external_worker: () => t().external_worker
    }))
  });
  class TLe extends Lf {
    constructor(t) {
      super(t), this.lib = kLe();
    }
  }
  class RLe extends Lf {
    constructor(t) {
      super(t), t.rf.logger.debug("Initializing worker manager handler"), this.workers = To((n, r) => ({})), this.workerstate = To((n, r) => ({
        is_open: !1
      }));
    }
    set_worker(t) {
      t !== this.worker && (this._unsubscribeFromWorker && (this._unsubscribeFromWorker(), this._unsubscribeFromWorker = void 0), t ? (this.context.rf.logger.debug("Setting worker in worker manager"), this._unsubscribeFromWorker = t.state.subscribe((n) => {
        this.workerstate.setState(n);
      }), this.workerstate.setState(t.state.getState())) : this.context.rf.logger.debug("Removing worker in worker manager"), this.worker = t, t?.set_zustand(this.context.rf));
    }
  }
  class OLe extends Lf {
    constructor(t) {
      super(t), this.progress_state = To((n, r) => ({
        message: "please select worker",
        status: "info",
        progress: 0,
        blocking: !1
      })), this.local_settings = To(
        (n, r) => ({
          view_settings: {
            expand_node_props: !1,
            expand_lib: !1
          }
        })
      ), this.local_state = To((n, r) => ({
        selected_nodes: [],
        selected_edges: [],
        selected_groups: [],
        funcnodescontainerRef: null
      }));
    }
    set_progress(t) {
      if (t.message === "")
        return this.auto_progress();
      const n = this.progress_state.getState(), { new_obj: r, change: o } = tc(n, t);
      o && this.progress_state.setState(r);
    }
    auto_progress() {
      const t = this.workerManager.workermanager, n = this.workerManager.worker;
      if (t !== void 0 && !t.open)
        return this.set_progress({
          progress: 0,
          message: "connecting to worker manager",
          status: "error",
          blocking: !1
        });
      if (n === void 0)
        return this.set_progress({
          progress: 0,
          message: "please select worker",
          status: "error",
          blocking: !1
        });
      if (!n.is_open)
        return this.set_progress({
          progress: 0,
          message: "connecting to worker",
          status: "info",
          blocking: !0
        });
      this.set_progress({
        progress: 1,
        message: "running",
        status: "info",
        blocking: !1
      });
    }
    update_view_settings(t) {
      K8(this.local_settings, { view_settings: t });
    }
  }
  const lq = "1.0.0", ALe = ["1"], NLe = (e) => {
    if (!e.v.toString().includes(".") || // old polugin version without "."
    !ALe.includes(e.v.toString().split(".")[0]))
      throw new Error(`Unsupported version: ${e.v}`);
    return { ...e, v: lq };
  };
  class MLe extends Lf {
    constructor(t) {
      super(t), this.plugins = To((n, r) => ({})), this.render_options = To((n, r) => ({}));
    }
    add_plugin(t, n) {
      if (n !== void 0)
        try {
          const r = NLe(n);
          this.plugins.setState((o) => ({ ...o, [t]: r }));
        } catch (r) {
          r instanceof Error ? this.context.rf.logger.error(`Error loading plugin ${t}`, r) : this.context.rf.logger.error(
            `Error loading plugin ${t}`,
            new Error(String(r))
          ), this.stateManager.toaster?.error({
            title: "Error",
            description: `Error loading plugin ${t}: ${r instanceof Error ? r.message : String(r)}`,
            duration: 5e3
          });
        }
    }
    update_render_options(t) {
      K8(this.render_options, t);
    }
    async add_packed_plugin(t, n) {
      if (n.js)
        for (const r of n.js) {
          const o = document.createElement("script");
          o.text = atob(r), document.body.appendChild(o);
        }
      if (n.css)
        for (const r of n.css) {
          const o = document.createElement("style");
          o.innerHTML = atob(r), document.head.appendChild(o);
        }
      if (n.module !== void 0) {
        const r = atob(n.module);
        try {
          const i = await new Function(
            "React",
            "FuncNodesReactFlow",
            `
          return (async () => {
            ${r}
            return FuncNodesPlugin;
          })();
        `
          )(ec, yG);
          this.add_plugin(t, i);
        } catch (o) {
          o instanceof Error ? this.context.rf.logger.error(`Error building plugin ${t}`, o) : this.context.rf.logger.error(
            `Error building plugin ${t}`,
            new Error(String(o))
          ), this.stateManager.toaster?.error({
            title: "Error",
            description: `Error building plugin ${t}: ${o}`,
            duration: 5e3
          });
        }
      }
    }
  }
  class PLe extends Lf {
    constructor(t) {
      super(t), this.on_rf_node_change = (n) => {
        const r = this.useReactFlowStore.getState();
        for (const o of n)
          switch (o.type) {
            case "position":
              if (o.position) {
                const i = r.getNode(o.id);
                if (i === void 0)
                  continue;
                i.type === "group" ? this.nodespaceManager.change_group_position(o) : this.nodespaceManager.change_fn_node_position(o), i.data.groupID && this.nodespaceManager.auto_resize_group(i.data.groupID);
              }
              break;
            case "dimensions":
              if (o.dimensions) {
                const i = r.getNode(o.id);
                if (i === void 0)
                  continue;
                i.type === "group" ? this.nodespaceManager.change_group_dimensions(o) : this.nodespaceManager.change_fn_node_dimensions(o), i.data.groupID && this.nodespaceManager.auto_resize_group(
                  i.data.groupID
                );
              }
              break;
          }
      }, this.on_rf_edge_change = (n) => {
      }, this.on_connect = (n) => {
        n.source === null || n.target === null || n.sourceHandle === null || n.targetHandle === null || !this.workerManager.worker || this.workerManager.worker.api.edge.add_edge({
          src_nid: n.source,
          src_ioid: n.sourceHandle,
          trg_nid: n.target,
          trg_ioid: n.targetHandle,
          replace: !0
        });
      }, this.useReactFlowStore = o1e({
        on_node_change: this.on_rf_node_change.bind(this),
        on_edge_change: this.on_rf_edge_change.bind(this),
        on_connect: this.on_connect.bind(this)
      });
    }
  }
  let $Le = class {
    constructor(t) {
      this.reactflowRef = null, this.dev_settings = {
        debug: S0
      }, this.options = t, this.logger = t.logger ?? new QC("fn", _4);
      const n = { rf: this };
      this._nodespaceManager = new CLe(n), this._libManager = new TLe(n), this._workerManager = new RLe(n), this._stateManager = new OLe(n), this._pluginManager = new MLe(n), this._reactFlowManager = new PLe(n);
    }
    // #region handlers
    getNodespaceManager() {
      return this._nodespaceManager;
    }
    getLibManager() {
      return this._libManager;
    }
    getWorkerManager() {
      return this._workerManager;
    }
    getStateManager() {
      return this._stateManager;
    }
    getPluginManager() {
      return this._pluginManager;
    }
    getReactFlowManager() {
      return this._reactFlowManager;
    }
    // #endregion handlers
    // #region nodespace manager
    get nodespace() {
      return this._nodespaceManager.nodespace;
    }
    get on_node_action() {
      return this._nodespaceManager.on_node_action.bind(this._nodespaceManager);
    }
    get on_edge_action() {
      return this._nodespaceManager.on_edge_action.bind(this._nodespaceManager);
    }
    get on_group_action() {
      return this._nodespaceManager.on_group_action.bind(this._nodespaceManager);
    }
    get clear_all() {
      return this._nodespaceManager.clear_all.bind(this._nodespaceManager);
    }
    get center_node() {
      return this._nodespaceManager.center_node.bind(this._nodespaceManager);
    }
    get center_all() {
      return this._nodespaceManager.center_all.bind(this._nodespaceManager);
    }
    // #endregion nodespace manager
    // #region lib manager
    get lib() {
      return this._libManager.lib;
    }
    // #endregion lib manager
    // #region worker manager
    get set_worker() {
      return this._workerManager.set_worker.bind(this._workerManager);
    }
    get workermanager() {
      return this._workerManager.workermanager;
    }
    set workermanager(t) {
      this._workerManager.workermanager = t;
    }
    get worker() {
      return this._workerManager.worker;
    }
    get workers() {
      return this._workerManager.workers;
    }
    get workerstate() {
      return this._workerManager.workerstate;
    }
    get _unsubscribeFromWorker() {
      return this._workerManager._unsubscribeFromWorker?.bind(
        this._workerManager
      );
    }
    // #endregion worker manager
    // #region statemanager
    get set_progress() {
      return this._stateManager.set_progress.bind(this._stateManager);
    }
    get auto_progress() {
      return this._stateManager.auto_progress.bind(this._stateManager);
    }
    get progress_state() {
      return this._stateManager.progress_state;
    }
    get local_settings() {
      return this._stateManager.local_settings;
    }
    get local_state() {
      return this._stateManager.local_state;
    }
    update_view_settings(t) {
      this._stateManager.update_view_settings(t);
    }
    // #endregion statemanager
    // #region plugis
    get plugins() {
      return this._pluginManager.plugins.bind(this._pluginManager);
    }
    get add_plugin() {
      return this._pluginManager.add_plugin.bind(this._pluginManager);
    }
    get add_packed_plugin() {
      return this._pluginManager.add_packed_plugin.bind(this._pluginManager);
    }
    get render_options() {
      return this._pluginManager.render_options.bind(this._pluginManager);
    }
    get update_render_options() {
      return this._pluginManager.update_render_options.bind(this._pluginManager);
    }
    // #endregion plugis
    // #region reactflow
    get useReactFlowStore() {
      return this._reactFlowManager.useReactFlowStore.bind(
        this._reactFlowManager
      );
    }
    get rf_instance() {
      return this._reactFlowManager.rf_instance;
    }
    set rf_instance(t) {
      this._reactFlowManager.rf_instance = t;
    }
    // #endregion reactflow
  };
  const ILe = ek(
    nde,
    (e) => (e.id = fT(), e)
  ), jLe = (e) => {
    if (!e.useWorkerManager && e.worker === void 0)
      throw new Error(
        "If you don't use a worker manager, you must provide a default worker."
      );
    if (e.useWorkerManager && e.workermanager_url === void 0)
      throw new Error(
        "Error: If you use a worker manager, you must provide a worker managerurl."
      );
  }, XC = {};
  window.fnrf_zst === void 0 && (window.fnrf_zst = XC);
  const DLe = (e) => {
    const [t, n] = T.useState(void 0), [r, o] = T.useState(
      void 0
    ), [i, a] = T.useState(!1);
    if (T.useEffect(() => {
      const s = ILe(e);
      s.logger = s.logger || new QC("FuncNodes", s.debug ? "debug" : "info"), s.logger.debug("Initializing FuncNodes with props:", s), n(s), a(!1);
    }, [e]), T.useEffect(() => {
      if (!t) return;
      t.logger?.debug("Initializing/Getting Zustand store");
      const s = XC[t.id];
      if (s === void 0) {
        const l = new $Le(t);
        XC[t.id] = l, o(l);
      } else
        o(s), s.options.debug = t.debug;
    }, [t?.id, t?.debug]), T.useEffect(() => {
      if (!(!t || !r) && !(t.useWorkerManager || !t.worker_url))
        if (t.logger?.debug("Worker effect running"), t.worker) {
          t.worker.set_zustand(r);
          return;
        } else {
          t.logger?.debug("Creating WebSocket worker");
          const s = new g9({
            url: t.worker_url,
            uuid: t.id,
            on_sync_complete: t.on_sync_complete
          });
          return s.set_zustand(r), n(
            (l) => l && { ...l, worker: s, useWorkerManager: !1 }
          ), () => {
            t.logger?.debug("Disconnecting worker"), s.disconnect(), n((l) => l && { ...l, worker: void 0 });
          };
        }
    }, [
      t?.worker_url,
      t?.id,
      t?.useWorkerManager,
      r,
      t?.on_sync_complete
    ]), T.useEffect(() => {
      if (!t?.fnw_url || !t.worker) return;
      t.logger?.debug("Loading fnw_url data");
      let s = !1;
      const l = t.worker.getSyncManager().on_sync_complete;
      return (async () => {
        try {
          const d = await LG(t.fnw_url);
          !s && t.worker && (t.worker.getSyncManager().on_sync_complete = async (p) => {
            await p.update_from_export(d), t.worker.getSyncManager().on_sync_complete = l, l && l(p);
          });
        } catch (d) {
          d instanceof Error ? t.logger?.error("Failed to load fnw_url:", d) : t.logger?.error(
            "Failed to load fnw_url:",
            new Error(String(d))
          );
        }
      })(), () => {
        s = !0, t.worker && (t.worker.getSyncManager().on_sync_complete = l);
      };
    }, [t?.fnw_url, t?.worker]), T.useEffect(() => {
      if (!t || !r || !t.useWorkerManager) return;
      if (!t.workermanager_url)
        throw new Error(
          "Error: If you use a worker manager, you must provide a worker manager url."
        );
      r.logger.info("Worker manager effect running");
      const s = !r.workermanager, l = r.workermanager && r.workermanager.wsuri !== t.workermanager_url;
      if (s || l) {
        r.workermanager && (r.logger.info("Removing existing worker manager"), r.workermanager.remove(), r.workermanager = void 0), r.logger.info("Creating new worker manager");
        const u = new Qfe(
          t.workermanager_url,
          r
        );
        return r.workermanager = u, n((d) => d && { ...d, workermanager: u }), () => {
          r.logger.info("Worker manager cleanup running"), r.workermanager === u ? (r.logger.info("Removing worker manager instance"), u.remove(), r.workermanager = void 0) : r.logger.info(
            "Worker manager instance mismatch, skipping cleanup"
          );
        };
      } else {
        r.logger.info(
          "Worker manager already initialized with correct URL"
        );
        return;
      }
    }, [
      t?.useWorkerManager,
      t?.workermanager_url,
      t?.id,
      r
    ]), T.useEffect(() => {
      if (!t || !r || i) return;
      (t.useWorkerManager ? r.workermanager !== void 0 : t.worker !== void 0) && t.on_ready && typeof t.on_ready == "function" && (t.logger?.debug("Firing on_ready callback"), t.on_ready({ fnrf_zst: r }), a(!0));
    }, [
      t,
      r,
      i,
      t?.useWorkerManager,
      r?.workermanager,
      t?.worker
    ]), t === void 0 || r === void 0)
      return /* @__PURE__ */ S.jsx("div", { children: "Loading..." });
    try {
      jLe(t);
    } catch (s) {
      return /* @__PURE__ */ S.jsx(zG, { error: s });
    }
    return /* @__PURE__ */ S.jsx("div", { className: "FuncnodesApp", children: /* @__PURE__ */ S.jsx(voe, { available_themes: y9, children: /* @__PURE__ */ S.jsx(Xce, { duration: 5e3, children: /* @__PURE__ */ S.jsx(
      _Le,
      {
        fnrf_zst: r,
        header: t.header,
        library: t.library,
        flow: t.flow
      }
    ) }) }) });
  }, cq = (e, t) => {
    t === void 0 && (t = {});
    const { element: n, eleid: r } = typeof e == "string" ? {
      element: document.getElementById(e),
      eleid: e
    } : { element: e, eleid: e.id };
    kG.createRoot(n).render(
      /* @__PURE__ */ S.jsx(T.StrictMode, { children: /* @__PURE__ */ S.jsx(DLe, { ...t, id: t.id || r }) })
    );
  };
  window.FuncNodes = cq;
  window.FuncNodes.version = "1.0.4";
  window.FuncNodes.utils = {
    logger: {
      ConsoleLogger: QC,
      DivLogger: NG,
      BaseLogger: ZC,
      DEBUG: TG,
      INFO: _4,
      WARN: RG,
      ERROR: OG
    }
  };
});
export default FLe();
