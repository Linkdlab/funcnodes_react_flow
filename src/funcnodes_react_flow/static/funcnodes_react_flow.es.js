var BG = Object.defineProperty;
var UG = (e, t, n) => t in e ? BG(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var VG = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var Kn = (e, t, n) => UG(e, typeof t != "symbol" ? t + "" : t, n);
var gze = VG((ao, so) => {
  function HG(e, t) {
    for (var n = 0; n < t.length; n++) {
      const r = t[n];
      if (typeof r != "string" && !Array.isArray(r)) {
        for (const o in r)
          if (o !== "default" && !(o in e)) {
            const i = Object.getOwnPropertyDescriptor(r, o);
            i && Object.defineProperty(e, o, i.get ? i : {
              enumerable: !0,
              get: () => r[o]
            });
          }
      }
    }
    return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
  }
  const qG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    get ArrayBufferDataStructure() {
      return c9;
    },
    get CTypeStructure() {
      return u9;
    },
    get DataPreviewViewRendererToHandlePreviewRenderer() {
      return R8;
    },
    get DataStructure() {
      return Pi;
    },
    get DataViewRendererToDataPreviewViewRenderer() {
      return zr;
    },
    get DataViewRendererToInputRenderer() {
      return O8;
    },
    get DataViewRendererToOverlayRenderer() {
      return a1;
    },
    get FuncNodes() {
      return Iq;
    },
    get FuncNodesRenderer() {
      return $q;
    },
    get FuncNodesWorker() {
      return p9;
    },
    get JSONStructure() {
      return Ks;
    },
    get LATEST_VERSION() {
      return Pq;
    },
    get TextStructure() {
      return f9;
    },
    get deep_merge() {
      return tl;
    },
    get deep_update() {
      return lk;
    },
    get object_factory_maker() {
      return Z0;
    },
    get useFuncNodesContext() {
      return Vt;
    },
    get useIOGetFullValue() {
      return im;
    },
    get useIOStore() {
      return En;
    },
    get useIOValueStore() {
      return B0e;
    },
    get useNodeStore() {
      return mo;
    },
    get useSetIOValue() {
      return kc;
    },
    get useSetIOValueOptions() {
      return z0e;
    },
    get useWorkerApi() {
      return Rr;
    }
  }, Symbol.toStringTag, { value: "Module" }));
  (function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload")) return;
    for (const o of document.querySelectorAll('link[rel="modulepreload"]')) r(o);
    new MutationObserver((o) => {
      for (const i of o)
        if (i.type === "childList")
          for (const a of i.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && r(a);
    }).observe(document, {
      childList: !0,
      subtree: !0
    });
    function n(o) {
      const i = {};
      return o.integrity && (i.integrity = o.integrity), o.referrerPolicy && (i.referrerPolicy = o.referrerPolicy), o.crossOrigin === "use-credentials" ? i.credentials = "include" : o.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i;
    }
    function r(o) {
      if (o.ep) return;
      o.ep = !0;
      const i = n(o);
      fetch(o.href, i);
    }
  })();
  function Xi(e) {
    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
  }
  var eS = { exports: {} }, Vd = {};
  var gP;
  function WG() {
    if (gP) return Vd;
    gP = 1;
    var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.fragment");
    function n(r, o, i) {
      var a = null;
      if (i !== void 0 && (a = "" + i), o.key !== void 0 && (a = "" + o.key), "key" in o) {
        i = {};
        for (var s in o)
          s !== "key" && (i[s] = o[s]);
      } else i = o;
      return o = i.ref, {
        $$typeof: e,
        type: r,
        key: a,
        ref: o !== void 0 ? o : null,
        props: i
      };
    }
    return Vd.Fragment = t, Vd.jsx = n, Vd.jsxs = n, Vd;
  }
  var yP;
  function GG() {
    return yP || (yP = 1, eS.exports = WG()), eS.exports;
  }
  var S = GG(), tS = { exports: {} }, Hd = {}, nS = { exports: {} }, rS = {};
  var vP;
  function KG() {
    return vP || (vP = 1, (function(e) {
      function t(F, K) {
        var W = F.length;
        F.push(K);
        e: for (; 0 < W; ) {
          var Y = W - 1 >>> 1, B = F[Y];
          if (0 < o(B, K))
            F[Y] = K, F[W] = B, W = Y;
          else break e;
        }
      }
      function n(F) {
        return F.length === 0 ? null : F[0];
      }
      function r(F) {
        if (F.length === 0) return null;
        var K = F[0], W = F.pop();
        if (W !== K) {
          F[0] = W;
          e: for (var Y = 0, B = F.length, D = B >>> 1; Y < D; ) {
            var G = 2 * (Y + 1) - 1, z = F[G], H = G + 1, X = F[H];
            if (0 > o(z, W))
              H < B && 0 > o(X, z) ? (F[Y] = X, F[H] = W, Y = H) : (F[Y] = z, F[G] = W, Y = G);
            else if (H < B && 0 > o(X, W))
              F[Y] = X, F[H] = W, Y = H;
            else break e;
          }
        }
        return K;
      }
      function o(F, K) {
        var W = F.sortIndex - K.sortIndex;
        return W !== 0 ? W : F.id - K.id;
      }
      if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
        var i = performance;
        e.unstable_now = function() {
          return i.now();
        };
      } else {
        var a = Date, s = a.now();
        e.unstable_now = function() {
          return a.now() - s;
        };
      }
      var c = [], u = [], d = 1, p = null, m = 3, g = !1, y = !1, b = !1, v = !1, x = typeof setTimeout == "function" ? setTimeout : null, E = typeof clearTimeout == "function" ? clearTimeout : null, _ = typeof setImmediate < "u" ? setImmediate : null;
      function C(F) {
        for (var K = n(u); K !== null; ) {
          if (K.callback === null) r(u);
          else if (K.startTime <= F)
            r(u), K.sortIndex = K.expirationTime, t(c, K);
          else break;
          K = n(u);
        }
      }
      function k(F) {
        if (b = !1, C(F), !y)
          if (n(c) !== null)
            y = !0, A || (A = !0, N());
          else {
            var K = n(u);
            K !== null && V(k, K.startTime - F);
          }
      }
      var A = !1, O = -1, P = 5, I = -1;
      function $() {
        return v ? !0 : !(e.unstable_now() - I < P);
      }
      function L() {
        if (v = !1, A) {
          var F = e.unstable_now();
          I = F;
          var K = !0;
          try {
            e: {
              y = !1, b && (b = !1, E(O), O = -1), g = !0;
              var W = m;
              try {
                t: {
                  for (C(F), p = n(c); p !== null && !(p.expirationTime > F && $()); ) {
                    var Y = p.callback;
                    if (typeof Y == "function") {
                      p.callback = null, m = p.priorityLevel;
                      var B = Y(
                        p.expirationTime <= F
                      );
                      if (F = e.unstable_now(), typeof B == "function") {
                        p.callback = B, C(F), K = !0;
                        break t;
                      }
                      p === n(c) && r(c), C(F);
                    } else r(c);
                    p = n(c);
                  }
                  if (p !== null) K = !0;
                  else {
                    var D = n(u);
                    D !== null && V(
                      k,
                      D.startTime - F
                    ), K = !1;
                  }
                }
                break e;
              } finally {
                p = null, m = W, g = !1;
              }
              K = void 0;
            }
          } finally {
            K ? N() : A = !1;
          }
        }
      }
      var N;
      if (typeof _ == "function")
        N = function() {
          _(L);
        };
      else if (typeof MessageChannel < "u") {
        var U = new MessageChannel(), j = U.port2;
        U.port1.onmessage = L, N = function() {
          j.postMessage(null);
        };
      } else
        N = function() {
          x(L, 0);
        };
      function V(F, K) {
        O = x(function() {
          F(e.unstable_now());
        }, K);
      }
      e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(F) {
        F.callback = null;
      }, e.unstable_forceFrameRate = function(F) {
        0 > F || 125 < F ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : P = 0 < F ? Math.floor(1e3 / F) : 5;
      }, e.unstable_getCurrentPriorityLevel = function() {
        return m;
      }, e.unstable_next = function(F) {
        switch (m) {
          case 1:
          case 2:
          case 3:
            var K = 3;
            break;
          default:
            K = m;
        }
        var W = m;
        m = K;
        try {
          return F();
        } finally {
          m = W;
        }
      }, e.unstable_requestPaint = function() {
        v = !0;
      }, e.unstable_runWithPriority = function(F, K) {
        switch (F) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            F = 3;
        }
        var W = m;
        m = F;
        try {
          return K();
        } finally {
          m = W;
        }
      }, e.unstable_scheduleCallback = function(F, K, W) {
        var Y = e.unstable_now();
        switch (typeof W == "object" && W !== null ? (W = W.delay, W = typeof W == "number" && 0 < W ? Y + W : Y) : W = Y, F) {
          case 1:
            var B = -1;
            break;
          case 2:
            B = 250;
            break;
          case 5:
            B = 1073741823;
            break;
          case 4:
            B = 1e4;
            break;
          default:
            B = 5e3;
        }
        return B = W + B, F = {
          id: d++,
          callback: K,
          priorityLevel: F,
          startTime: W,
          expirationTime: B,
          sortIndex: -1
        }, W > Y ? (F.sortIndex = W, t(u, F), n(c) === null && F === n(u) && (b ? (E(O), O = -1) : b = !0, V(k, W - Y))) : (F.sortIndex = B, t(c, F), y || g || (y = !0, A || (A = !0, N()))), F;
      }, e.unstable_shouldYield = $, e.unstable_wrapCallback = function(F) {
        var K = m;
        return function() {
          var W = m;
          m = K;
          try {
            return F.apply(this, arguments);
          } finally {
            m = W;
          }
        };
      };
    })(rS)), rS;
  }
  var bP;
  function YG() {
    return bP || (bP = 1, nS.exports = KG()), nS.exports;
  }
  var oS = { exports: {} }, at = {};
  var xP;
  function XG() {
    if (xP) return at;
    xP = 1;
    var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.portal"), n = /* @__PURE__ */ Symbol.for("react.fragment"), r = /* @__PURE__ */ Symbol.for("react.strict_mode"), o = /* @__PURE__ */ Symbol.for("react.profiler"), i = /* @__PURE__ */ Symbol.for("react.consumer"), a = /* @__PURE__ */ Symbol.for("react.context"), s = /* @__PURE__ */ Symbol.for("react.forward_ref"), c = /* @__PURE__ */ Symbol.for("react.suspense"), u = /* @__PURE__ */ Symbol.for("react.memo"), d = /* @__PURE__ */ Symbol.for("react.lazy"), p = /* @__PURE__ */ Symbol.for("react.activity"), m = Symbol.iterator;
    function g(D) {
      return D === null || typeof D != "object" ? null : (D = m && D[m] || D["@@iterator"], typeof D == "function" ? D : null);
    }
    var y = {
      isMounted: function() {
        return !1;
      },
      enqueueForceUpdate: function() {
      },
      enqueueReplaceState: function() {
      },
      enqueueSetState: function() {
      }
    }, b = Object.assign, v = {};
    function x(D, G, z) {
      this.props = D, this.context = G, this.refs = v, this.updater = z || y;
    }
    x.prototype.isReactComponent = {}, x.prototype.setState = function(D, G) {
      if (typeof D != "object" && typeof D != "function" && D != null)
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, D, G, "setState");
    }, x.prototype.forceUpdate = function(D) {
      this.updater.enqueueForceUpdate(this, D, "forceUpdate");
    };
    function E() {
    }
    E.prototype = x.prototype;
    function _(D, G, z) {
      this.props = D, this.context = G, this.refs = v, this.updater = z || y;
    }
    var C = _.prototype = new E();
    C.constructor = _, b(C, x.prototype), C.isPureReactComponent = !0;
    var k = Array.isArray;
    function A() {
    }
    var O = { H: null, A: null, T: null, S: null }, P = Object.prototype.hasOwnProperty;
    function I(D, G, z) {
      var H = z.ref;
      return {
        $$typeof: e,
        type: D,
        key: G,
        ref: H !== void 0 ? H : null,
        props: z
      };
    }
    function $(D, G) {
      return I(D.type, G, D.props);
    }
    function L(D) {
      return typeof D == "object" && D !== null && D.$$typeof === e;
    }
    function N(D) {
      var G = { "=": "=0", ":": "=2" };
      return "$" + D.replace(/[=:]/g, function(z) {
        return G[z];
      });
    }
    var U = /\/+/g;
    function j(D, G) {
      return typeof D == "object" && D !== null && D.key != null ? N("" + D.key) : G.toString(36);
    }
    function V(D) {
      switch (D.status) {
        case "fulfilled":
          return D.value;
        case "rejected":
          throw D.reason;
        default:
          switch (typeof D.status == "string" ? D.then(A, A) : (D.status = "pending", D.then(
            function(G) {
              D.status === "pending" && (D.status = "fulfilled", D.value = G);
            },
            function(G) {
              D.status === "pending" && (D.status = "rejected", D.reason = G);
            }
          )), D.status) {
            case "fulfilled":
              return D.value;
            case "rejected":
              throw D.reason;
          }
      }
      throw D;
    }
    function F(D, G, z, H, X) {
      var Q = typeof D;
      (Q === "undefined" || Q === "boolean") && (D = null);
      var ne = !1;
      if (D === null) ne = !0;
      else
        switch (Q) {
          case "bigint":
          case "string":
          case "number":
            ne = !0;
            break;
          case "object":
            switch (D.$$typeof) {
              case e:
              case t:
                ne = !0;
                break;
              case d:
                return ne = D._init, F(
                  ne(D._payload),
                  G,
                  z,
                  H,
                  X
                );
            }
        }
      if (ne)
        return X = X(D), ne = H === "" ? "." + j(D, 0) : H, k(X) ? (z = "", ne != null && (z = ne.replace(U, "$&/") + "/"), F(X, G, z, "", function(ue) {
          return ue;
        })) : X != null && (L(X) && (X = $(
          X,
          z + (X.key == null || D && D.key === X.key ? "" : ("" + X.key).replace(
            U,
            "$&/"
          ) + "/") + ne
        )), G.push(X)), 1;
      ne = 0;
      var te = H === "" ? "." : H + ":";
      if (k(D))
        for (var se = 0; se < D.length; se++)
          H = D[se], Q = te + j(H, se), ne += F(
            H,
            G,
            z,
            Q,
            X
          );
      else if (se = g(D), typeof se == "function")
        for (D = se.call(D), se = 0; !(H = D.next()).done; )
          H = H.value, Q = te + j(H, se++), ne += F(
            H,
            G,
            z,
            Q,
            X
          );
      else if (Q === "object") {
        if (typeof D.then == "function")
          return F(
            V(D),
            G,
            z,
            H,
            X
          );
        throw G = String(D), Error(
          "Objects are not valid as a React child (found: " + (G === "[object Object]" ? "object with keys {" + Object.keys(D).join(", ") + "}" : G) + "). If you meant to render a collection of children, use an array instead."
        );
      }
      return ne;
    }
    function K(D, G, z) {
      if (D == null) return D;
      var H = [], X = 0;
      return F(D, H, "", "", function(Q) {
        return G.call(z, Q, X++);
      }), H;
    }
    function W(D) {
      if (D._status === -1) {
        var G = D._result;
        G = G(), G.then(
          function(z) {
            (D._status === 0 || D._status === -1) && (D._status = 1, D._result = z);
          },
          function(z) {
            (D._status === 0 || D._status === -1) && (D._status = 2, D._result = z);
          }
        ), D._status === -1 && (D._status = 0, D._result = G);
      }
      if (D._status === 1) return D._result.default;
      throw D._result;
    }
    var Y = typeof reportError == "function" ? reportError : function(D) {
      if (typeof window == "object" && typeof window.ErrorEvent == "function") {
        var G = new window.ErrorEvent("error", {
          bubbles: !0,
          cancelable: !0,
          message: typeof D == "object" && D !== null && typeof D.message == "string" ? String(D.message) : String(D),
          error: D
        });
        if (!window.dispatchEvent(G)) return;
      } else if (typeof process == "object" && typeof process.emit == "function") {
        process.emit("uncaughtException", D);
        return;
      }
      console.error(D);
    }, B = {
      map: K,
      forEach: function(D, G, z) {
        K(
          D,
          function() {
            G.apply(this, arguments);
          },
          z
        );
      },
      count: function(D) {
        var G = 0;
        return K(D, function() {
          G++;
        }), G;
      },
      toArray: function(D) {
        return K(D, function(G) {
          return G;
        }) || [];
      },
      only: function(D) {
        if (!L(D))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return D;
      }
    };
    return at.Activity = p, at.Children = B, at.Component = x, at.Fragment = n, at.Profiler = o, at.PureComponent = _, at.StrictMode = r, at.Suspense = c, at.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = O, at.__COMPILER_RUNTIME = {
      __proto__: null,
      c: function(D) {
        return O.H.useMemoCache(D);
      }
    }, at.cache = function(D) {
      return function() {
        return D.apply(null, arguments);
      };
    }, at.cacheSignal = function() {
      return null;
    }, at.cloneElement = function(D, G, z) {
      if (D == null)
        throw Error(
          "The argument must be a React element, but you passed " + D + "."
        );
      var H = b({}, D.props), X = D.key;
      if (G != null)
        for (Q in G.key !== void 0 && (X = "" + G.key), G)
          !P.call(G, Q) || Q === "key" || Q === "__self" || Q === "__source" || Q === "ref" && G.ref === void 0 || (H[Q] = G[Q]);
      var Q = arguments.length - 2;
      if (Q === 1) H.children = z;
      else if (1 < Q) {
        for (var ne = Array(Q), te = 0; te < Q; te++)
          ne[te] = arguments[te + 2];
        H.children = ne;
      }
      return I(D.type, X, H);
    }, at.createContext = function(D) {
      return D = {
        $$typeof: a,
        _currentValue: D,
        _currentValue2: D,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      }, D.Provider = D, D.Consumer = {
        $$typeof: i,
        _context: D
      }, D;
    }, at.createElement = function(D, G, z) {
      var H, X = {}, Q = null;
      if (G != null)
        for (H in G.key !== void 0 && (Q = "" + G.key), G)
          P.call(G, H) && H !== "key" && H !== "__self" && H !== "__source" && (X[H] = G[H]);
      var ne = arguments.length - 2;
      if (ne === 1) X.children = z;
      else if (1 < ne) {
        for (var te = Array(ne), se = 0; se < ne; se++)
          te[se] = arguments[se + 2];
        X.children = te;
      }
      if (D && D.defaultProps)
        for (H in ne = D.defaultProps, ne)
          X[H] === void 0 && (X[H] = ne[H]);
      return I(D, Q, X);
    }, at.createRef = function() {
      return { current: null };
    }, at.forwardRef = function(D) {
      return { $$typeof: s, render: D };
    }, at.isValidElement = L, at.lazy = function(D) {
      return {
        $$typeof: d,
        _payload: { _status: -1, _result: D },
        _init: W
      };
    }, at.memo = function(D, G) {
      return {
        $$typeof: u,
        type: D,
        compare: G === void 0 ? null : G
      };
    }, at.startTransition = function(D) {
      var G = O.T, z = {};
      O.T = z;
      try {
        var H = D(), X = O.S;
        X !== null && X(z, H), typeof H == "object" && H !== null && typeof H.then == "function" && H.then(A, Y);
      } catch (Q) {
        Y(Q);
      } finally {
        G !== null && z.types !== null && (G.types = z.types), O.T = G;
      }
    }, at.unstable_useCacheRefresh = function() {
      return O.H.useCacheRefresh();
    }, at.use = function(D) {
      return O.H.use(D);
    }, at.useActionState = function(D, G, z) {
      return O.H.useActionState(D, G, z);
    }, at.useCallback = function(D, G) {
      return O.H.useCallback(D, G);
    }, at.useContext = function(D) {
      return O.H.useContext(D);
    }, at.useDebugValue = function() {
    }, at.useDeferredValue = function(D, G) {
      return O.H.useDeferredValue(D, G);
    }, at.useEffect = function(D, G) {
      return O.H.useEffect(D, G);
    }, at.useEffectEvent = function(D) {
      return O.H.useEffectEvent(D);
    }, at.useId = function() {
      return O.H.useId();
    }, at.useImperativeHandle = function(D, G, z) {
      return O.H.useImperativeHandle(D, G, z);
    }, at.useInsertionEffect = function(D, G) {
      return O.H.useInsertionEffect(D, G);
    }, at.useLayoutEffect = function(D, G) {
      return O.H.useLayoutEffect(D, G);
    }, at.useMemo = function(D, G) {
      return O.H.useMemo(D, G);
    }, at.useOptimistic = function(D, G) {
      return O.H.useOptimistic(D, G);
    }, at.useReducer = function(D, G, z) {
      return O.H.useReducer(D, G, z);
    }, at.useRef = function(D) {
      return O.H.useRef(D);
    }, at.useState = function(D) {
      return O.H.useState(D);
    }, at.useSyncExternalStore = function(D, G, z) {
      return O.H.useSyncExternalStore(
        D,
        G,
        z
      );
    }, at.useTransition = function() {
      return O.H.useTransition();
    }, at.version = "19.2.3", at;
  }
  var wP;
  function Oh() {
    return wP || (wP = 1, oS.exports = XG()), oS.exports;
  }
  var iS = { exports: {} }, hr = {};
  var SP;
  function ZG() {
    if (SP) return hr;
    SP = 1;
    var e = Oh();
    function t(c) {
      var u = "https://react.dev/errors/" + c;
      if (1 < arguments.length) {
        u += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var d = 2; d < arguments.length; d++)
          u += "&args[]=" + encodeURIComponent(arguments[d]);
      }
      return "Minified React error #" + c + "; visit " + u + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function n() {
    }
    var r = {
      d: {
        f: n,
        r: function() {
          throw Error(t(522));
        },
        D: n,
        C: n,
        L: n,
        m: n,
        X: n,
        S: n,
        M: n
      },
      p: 0,
      findDOMNode: null
    }, o = /* @__PURE__ */ Symbol.for("react.portal");
    function i(c, u, d) {
      var p = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {
        $$typeof: o,
        key: p == null ? null : "" + p,
        children: c,
        containerInfo: u,
        implementation: d
      };
    }
    var a = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function s(c, u) {
      if (c === "font") return "";
      if (typeof u == "string")
        return u === "use-credentials" ? u : "";
    }
    return hr.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r, hr.createPortal = function(c, u) {
      var d = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!u || u.nodeType !== 1 && u.nodeType !== 9 && u.nodeType !== 11)
        throw Error(t(299));
      return i(c, u, null, d);
    }, hr.flushSync = function(c) {
      var u = a.T, d = r.p;
      try {
        if (a.T = null, r.p = 2, c) return c();
      } finally {
        a.T = u, r.p = d, r.d.f();
      }
    }, hr.preconnect = function(c, u) {
      typeof c == "string" && (u ? (u = u.crossOrigin, u = typeof u == "string" ? u === "use-credentials" ? u : "" : void 0) : u = null, r.d.C(c, u));
    }, hr.prefetchDNS = function(c) {
      typeof c == "string" && r.d.D(c);
    }, hr.preinit = function(c, u) {
      if (typeof c == "string" && u && typeof u.as == "string") {
        var d = u.as, p = s(d, u.crossOrigin), m = typeof u.integrity == "string" ? u.integrity : void 0, g = typeof u.fetchPriority == "string" ? u.fetchPriority : void 0;
        d === "style" ? r.d.S(
          c,
          typeof u.precedence == "string" ? u.precedence : void 0,
          {
            crossOrigin: p,
            integrity: m,
            fetchPriority: g
          }
        ) : d === "script" && r.d.X(c, {
          crossOrigin: p,
          integrity: m,
          fetchPriority: g,
          nonce: typeof u.nonce == "string" ? u.nonce : void 0
        });
      }
    }, hr.preinitModule = function(c, u) {
      if (typeof c == "string")
        if (typeof u == "object" && u !== null) {
          if (u.as == null || u.as === "script") {
            var d = s(
              u.as,
              u.crossOrigin
            );
            r.d.M(c, {
              crossOrigin: d,
              integrity: typeof u.integrity == "string" ? u.integrity : void 0,
              nonce: typeof u.nonce == "string" ? u.nonce : void 0
            });
          }
        } else u == null && r.d.M(c);
    }, hr.preload = function(c, u) {
      if (typeof c == "string" && typeof u == "object" && u !== null && typeof u.as == "string") {
        var d = u.as, p = s(d, u.crossOrigin);
        r.d.L(c, d, {
          crossOrigin: p,
          integrity: typeof u.integrity == "string" ? u.integrity : void 0,
          nonce: typeof u.nonce == "string" ? u.nonce : void 0,
          type: typeof u.type == "string" ? u.type : void 0,
          fetchPriority: typeof u.fetchPriority == "string" ? u.fetchPriority : void 0,
          referrerPolicy: typeof u.referrerPolicy == "string" ? u.referrerPolicy : void 0,
          imageSrcSet: typeof u.imageSrcSet == "string" ? u.imageSrcSet : void 0,
          imageSizes: typeof u.imageSizes == "string" ? u.imageSizes : void 0,
          media: typeof u.media == "string" ? u.media : void 0
        });
      }
    }, hr.preloadModule = function(c, u) {
      if (typeof c == "string")
        if (u) {
          var d = s(u.as, u.crossOrigin);
          r.d.m(c, {
            as: typeof u.as == "string" && u.as !== "script" ? u.as : void 0,
            crossOrigin: d,
            integrity: typeof u.integrity == "string" ? u.integrity : void 0
          });
        } else r.d.m(c);
    }, hr.requestFormReset = function(c) {
      r.d.r(c);
    }, hr.unstable_batchedUpdates = function(c, u) {
      return c(u);
    }, hr.useFormState = function(c, u, d) {
      return a.H.useFormState(c, u, d);
    }, hr.useFormStatus = function() {
      return a.H.useHostTransitionStatus();
    }, hr.version = "19.2.3", hr;
  }
  var _P;
  function U4() {
    if (_P) return iS.exports;
    _P = 1;
    function e() {
      if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
        } catch (t) {
          console.error(t);
        }
    }
    return e(), iS.exports = ZG(), iS.exports;
  }
  var EP;
  function QG() {
    if (EP) return Hd;
    EP = 1;
    var e = YG(), t = Oh(), n = U4();
    function r(l) {
      var f = "https://react.dev/errors/" + l;
      if (1 < arguments.length) {
        f += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var h = 2; h < arguments.length; h++)
          f += "&args[]=" + encodeURIComponent(arguments[h]);
      }
      return "Minified React error #" + l + "; visit " + f + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function o(l) {
      return !(!l || l.nodeType !== 1 && l.nodeType !== 9 && l.nodeType !== 11);
    }
    function i(l) {
      var f = l, h = l;
      if (l.alternate) for (; f.return; ) f = f.return;
      else {
        l = f;
        do
          f = l, (f.flags & 4098) !== 0 && (h = f.return), l = f.return;
        while (l);
      }
      return f.tag === 3 ? h : null;
    }
    function a(l) {
      if (l.tag === 13) {
        var f = l.memoizedState;
        if (f === null && (l = l.alternate, l !== null && (f = l.memoizedState)), f !== null) return f.dehydrated;
      }
      return null;
    }
    function s(l) {
      if (l.tag === 31) {
        var f = l.memoizedState;
        if (f === null && (l = l.alternate, l !== null && (f = l.memoizedState)), f !== null) return f.dehydrated;
      }
      return null;
    }
    function c(l) {
      if (i(l) !== l)
        throw Error(r(188));
    }
    function u(l) {
      var f = l.alternate;
      if (!f) {
        if (f = i(l), f === null) throw Error(r(188));
        return f !== l ? null : l;
      }
      for (var h = l, w = f; ; ) {
        var R = h.return;
        if (R === null) break;
        var M = R.alternate;
        if (M === null) {
          if (w = R.return, w !== null) {
            h = w;
            continue;
          }
          break;
        }
        if (R.child === M.child) {
          for (M = R.child; M; ) {
            if (M === h) return c(R), l;
            if (M === w) return c(R), f;
            M = M.sibling;
          }
          throw Error(r(188));
        }
        if (h.return !== w.return) h = R, w = M;
        else {
          for (var q = !1, Z = R.child; Z; ) {
            if (Z === h) {
              q = !0, h = R, w = M;
              break;
            }
            if (Z === w) {
              q = !0, w = R, h = M;
              break;
            }
            Z = Z.sibling;
          }
          if (!q) {
            for (Z = M.child; Z; ) {
              if (Z === h) {
                q = !0, h = M, w = R;
                break;
              }
              if (Z === w) {
                q = !0, w = M, h = R;
                break;
              }
              Z = Z.sibling;
            }
            if (!q) throw Error(r(189));
          }
        }
        if (h.alternate !== w) throw Error(r(190));
      }
      if (h.tag !== 3) throw Error(r(188));
      return h.stateNode.current === h ? l : f;
    }
    function d(l) {
      var f = l.tag;
      if (f === 5 || f === 26 || f === 27 || f === 6) return l;
      for (l = l.child; l !== null; ) {
        if (f = d(l), f !== null) return f;
        l = l.sibling;
      }
      return null;
    }
    var p = Object.assign, m = /* @__PURE__ */ Symbol.for("react.element"), g = /* @__PURE__ */ Symbol.for("react.transitional.element"), y = /* @__PURE__ */ Symbol.for("react.portal"), b = /* @__PURE__ */ Symbol.for("react.fragment"), v = /* @__PURE__ */ Symbol.for("react.strict_mode"), x = /* @__PURE__ */ Symbol.for("react.profiler"), E = /* @__PURE__ */ Symbol.for("react.consumer"), _ = /* @__PURE__ */ Symbol.for("react.context"), C = /* @__PURE__ */ Symbol.for("react.forward_ref"), k = /* @__PURE__ */ Symbol.for("react.suspense"), A = /* @__PURE__ */ Symbol.for("react.suspense_list"), O = /* @__PURE__ */ Symbol.for("react.memo"), P = /* @__PURE__ */ Symbol.for("react.lazy"), I = /* @__PURE__ */ Symbol.for("react.activity"), $ = /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel"), L = Symbol.iterator;
    function N(l) {
      return l === null || typeof l != "object" ? null : (l = L && l[L] || l["@@iterator"], typeof l == "function" ? l : null);
    }
    var U = /* @__PURE__ */ Symbol.for("react.client.reference");
    function j(l) {
      if (l == null) return null;
      if (typeof l == "function")
        return l.$$typeof === U ? null : l.displayName || l.name || null;
      if (typeof l == "string") return l;
      switch (l) {
        case b:
          return "Fragment";
        case x:
          return "Profiler";
        case v:
          return "StrictMode";
        case k:
          return "Suspense";
        case A:
          return "SuspenseList";
        case I:
          return "Activity";
      }
      if (typeof l == "object")
        switch (l.$$typeof) {
          case y:
            return "Portal";
          case _:
            return l.displayName || "Context";
          case E:
            return (l._context.displayName || "Context") + ".Consumer";
          case C:
            var f = l.render;
            return l = l.displayName, l || (l = f.displayName || f.name || "", l = l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef"), l;
          case O:
            return f = l.displayName || null, f !== null ? f : j(l.type) || "Memo";
          case P:
            f = l._payload, l = l._init;
            try {
              return j(l(f));
            } catch {
            }
        }
      return null;
    }
    var V = Array.isArray, F = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, K = n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, W = {
      pending: !1,
      data: null,
      method: null,
      action: null
    }, Y = [], B = -1;
    function D(l) {
      return { current: l };
    }
    function G(l) {
      0 > B || (l.current = Y[B], Y[B] = null, B--);
    }
    function z(l, f) {
      B++, Y[B] = l.current, l.current = f;
    }
    var H = D(null), X = D(null), Q = D(null), ne = D(null);
    function te(l, f) {
      switch (z(Q, f), z(X, l), z(H, null), f.nodeType) {
        case 9:
        case 11:
          l = (l = f.documentElement) && (l = l.namespaceURI) ? LN(l) : 0;
          break;
        default:
          if (l = f.tagName, f = f.namespaceURI)
            f = LN(f), l = zN(f, l);
          else
            switch (l) {
              case "svg":
                l = 1;
                break;
              case "math":
                l = 2;
                break;
              default:
                l = 0;
            }
      }
      G(H), z(H, l);
    }
    function se() {
      G(H), G(X), G(Q);
    }
    function ue(l) {
      l.memoizedState !== null && z(ne, l);
      var f = H.current, h = zN(f, l.type);
      f !== h && (z(X, l), z(H, h));
    }
    function J(l) {
      X.current === l && (G(H), G(X)), ne.current === l && (G(ne), Ld._currentValue = W);
    }
    var ee, ie;
    function le(l) {
      if (ee === void 0)
        try {
          throw Error();
        } catch (h) {
          var f = h.stack.trim().match(/\n( *(at )?)/);
          ee = f && f[1] || "", ie = -1 < h.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < h.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return `
` + ee + l + ie;
    }
    var ge = !1;
    function Se(l, f) {
      if (!l || ge) return "";
      ge = !0;
      var h = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        var w = {
          DetermineComponentFrameRoot: function() {
            try {
              if (f) {
                var we = function() {
                  throw Error();
                };
                if (Object.defineProperty(we.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                }), typeof Reflect == "object" && Reflect.construct) {
                  try {
                    Reflect.construct(we, []);
                  } catch (ye) {
                    var he = ye;
                  }
                  Reflect.construct(l, [], we);
                } else {
                  try {
                    we.call();
                  } catch (ye) {
                    he = ye;
                  }
                  l.call(we.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (ye) {
                  he = ye;
                }
                (we = l()) && typeof we.catch == "function" && we.catch(function() {
                });
              }
            } catch (ye) {
              if (ye && he && typeof ye.stack == "string")
                return [ye.stack, he.stack];
            }
            return [null, null];
          }
        };
        w.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var R = Object.getOwnPropertyDescriptor(
          w.DetermineComponentFrameRoot,
          "name"
        );
        R && R.configurable && Object.defineProperty(
          w.DetermineComponentFrameRoot,
          "name",
          { value: "DetermineComponentFrameRoot" }
        );
        var M = w.DetermineComponentFrameRoot(), q = M[0], Z = M[1];
        if (q && Z) {
          var re = q.split(`
`), pe = Z.split(`
`);
          for (R = w = 0; w < re.length && !re[w].includes("DetermineComponentFrameRoot"); )
            w++;
          for (; R < pe.length && !pe[R].includes(
            "DetermineComponentFrameRoot"
          ); )
            R++;
          if (w === re.length || R === pe.length)
            for (w = re.length - 1, R = pe.length - 1; 1 <= w && 0 <= R && re[w] !== pe[R]; )
              R--;
          for (; 1 <= w && 0 <= R; w--, R--)
            if (re[w] !== pe[R]) {
              if (w !== 1 || R !== 1)
                do
                  if (w--, R--, 0 > R || re[w] !== pe[R]) {
                    var ve = `
` + re[w].replace(" at new ", " at ");
                    return l.displayName && ve.includes("<anonymous>") && (ve = ve.replace("<anonymous>", l.displayName)), ve;
                  }
                while (1 <= w && 0 <= R);
              break;
            }
        }
      } finally {
        ge = !1, Error.prepareStackTrace = h;
      }
      return (h = l ? l.displayName || l.name : "") ? le(h) : "";
    }
    function Me(l, f) {
      switch (l.tag) {
        case 26:
        case 27:
        case 5:
          return le(l.type);
        case 16:
          return le("Lazy");
        case 13:
          return l.child !== f && f !== null ? le("Suspense Fallback") : le("Suspense");
        case 19:
          return le("SuspenseList");
        case 0:
        case 15:
          return Se(l.type, !1);
        case 11:
          return Se(l.type.render, !1);
        case 1:
          return Se(l.type, !0);
        case 31:
          return le("Activity");
        default:
          return "";
      }
    }
    function je(l) {
      try {
        var f = "", h = null;
        do
          f += Me(l, h), h = l, l = l.return;
        while (l);
        return f;
      } catch (w) {
        return `
Error generating stack: ` + w.message + `
` + w.stack;
      }
    }
    var ze = Object.prototype.hasOwnProperty, Ye = e.unstable_scheduleCallback, Ue = e.unstable_cancelCallback, Ne = e.unstable_shouldYield, mt = e.unstable_requestPaint, Je = e.unstable_now, Ae = e.unstable_getCurrentPriorityLevel, oe = e.unstable_ImmediatePriority, fe = e.unstable_UserBlockingPriority, _e = e.unstable_NormalPriority, Ce = e.unstable_LowPriority, Oe = e.unstable_IdlePriority, He = e.log, Ot = e.unstable_setDisableYieldValue, it = null, Et = null;
    function xn(l) {
      if (typeof He == "function" && Ot(l), Et && typeof Et.setStrictMode == "function")
        try {
          Et.setStrictMode(it, l);
        } catch {
        }
    }
    var Mt = Math.clz32 ? Math.clz32 : hn, De = Math.log, ft = Math.LN2;
    function hn(l) {
      return l >>>= 0, l === 0 ? 32 : 31 - (De(l) / ft | 0) | 0;
    }
    var nr = 256, Lo = 262144, on = 4194304;
    function an(l) {
      var f = l & 42;
      if (f !== 0) return f;
      switch (l & -l) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
          return l & 261888;
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return l & 3932160;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return l & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return l;
      }
    }
    function ui(l, f, h) {
      var w = l.pendingLanes;
      if (w === 0) return 0;
      var R = 0, M = l.suspendedLanes, q = l.pingedLanes;
      l = l.warmLanes;
      var Z = w & 134217727;
      return Z !== 0 ? (w = Z & ~M, w !== 0 ? R = an(w) : (q &= Z, q !== 0 ? R = an(q) : h || (h = Z & ~l, h !== 0 && (R = an(h))))) : (Z = w & ~M, Z !== 0 ? R = an(Z) : q !== 0 ? R = an(q) : h || (h = w & ~l, h !== 0 && (R = an(h)))), R === 0 ? 0 : f !== 0 && f !== R && (f & M) === 0 && (M = R & -R, h = f & -f, M >= h || M === 32 && (h & 4194048) !== 0) ? f : R;
    }
    function yo(l, f) {
      return (l.pendingLanes & ~(l.suspendedLanes & ~l.pingedLanes) & f) === 0;
    }
    function Gr(l, f) {
      switch (l) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return f + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return f + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function Em() {
      var l = on;
      return on <<= 1, (on & 62914560) === 0 && (on = 4194304), l;
    }
    function Xf(l) {
      for (var f = [], h = 0; 31 > h; h++) f.push(l);
      return f;
    }
    function bl(l, f) {
      l.pendingLanes |= f, f !== 268435456 && (l.suspendedLanes = 0, l.pingedLanes = 0, l.warmLanes = 0);
    }
    function H1(l, f, h, w, R, M) {
      var q = l.pendingLanes;
      l.pendingLanes = h, l.suspendedLanes = 0, l.pingedLanes = 0, l.warmLanes = 0, l.expiredLanes &= h, l.entangledLanes &= h, l.errorRecoveryDisabledLanes &= h, l.shellSuspendCounter = 0;
      var Z = l.entanglements, re = l.expirationTimes, pe = l.hiddenUpdates;
      for (h = q & ~h; 0 < h; ) {
        var ve = 31 - Mt(h), we = 1 << ve;
        Z[ve] = 0, re[ve] = -1;
        var he = pe[ve];
        if (he !== null)
          for (pe[ve] = null, ve = 0; ve < he.length; ve++) {
            var ye = he[ve];
            ye !== null && (ye.lane &= -536870913);
          }
        h &= ~we;
      }
      w !== 0 && Cm(l, w, 0), M !== 0 && R === 0 && l.tag !== 0 && (l.suspendedLanes |= M & ~(q & ~f));
    }
    function Cm(l, f, h) {
      l.pendingLanes |= f, l.suspendedLanes &= ~f;
      var w = 31 - Mt(f);
      l.entangledLanes |= f, l.entanglements[w] = l.entanglements[w] | 1073741824 | h & 261930;
    }
    function km(l, f) {
      var h = l.entangledLanes |= f;
      for (l = l.entanglements; h; ) {
        var w = 31 - Mt(h), R = 1 << w;
        R & f | l[w] & f && (l[w] |= f), h &= ~R;
      }
    }
    function Tm(l, f) {
      var h = f & -f;
      return h = (h & 42) !== 0 ? 1 : Zf(h), (h & (l.suspendedLanes | f)) !== 0 ? 0 : h;
    }
    function Zf(l) {
      switch (l) {
        case 2:
          l = 1;
          break;
        case 8:
          l = 4;
          break;
        case 32:
          l = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          l = 128;
          break;
        case 268435456:
          l = 134217728;
          break;
        default:
          l = 0;
      }
      return l;
    }
    function Qf(l) {
      return l &= -l, 2 < l ? 8 < l ? (l & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
    }
    function Am() {
      var l = K.p;
      return l !== 0 ? l : (l = window.event, l === void 0 ? 32 : cP(l.type));
    }
    function Rm(l, f) {
      var h = K.p;
      try {
        return K.p = l, f();
      } finally {
        K.p = h;
      }
    }
    var fi = Math.random().toString(36).slice(2), Wn = "__reactFiber$" + fi, pr = "__reactProps$" + fi, ia = "__reactContainer$" + fi, Fc = "__reactEvents$" + fi, Om = "__reactListeners$" + fi, q1 = "__reactHandles$" + fi, Mm = "__reactResources$" + fi, xl = "__reactMarker$" + fi;
    function Jf(l) {
      delete l[Wn], delete l[pr], delete l[Fc], delete l[Om], delete l[q1];
    }
    function ls(l) {
      var f = l[Wn];
      if (f) return f;
      for (var h = l.parentNode; h; ) {
        if (f = h[ia] || h[Wn]) {
          if (h = f.alternate, f.child !== null || h !== null && h.child !== null)
            for (l = GN(l); l !== null; ) {
              if (h = l[Wn]) return h;
              l = GN(l);
            }
          return f;
        }
        l = h, h = l.parentNode;
      }
      return null;
    }
    function cs(l) {
      if (l = l[Wn] || l[ia]) {
        var f = l.tag;
        if (f === 5 || f === 6 || f === 13 || f === 31 || f === 26 || f === 27 || f === 3)
          return l;
      }
      return null;
    }
    function us(l) {
      var f = l.tag;
      if (f === 5 || f === 26 || f === 27 || f === 6) return l.stateNode;
      throw Error(r(33));
    }
    function fs(l) {
      var f = l[Mm];
      return f || (f = l[Mm] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() }), f;
    }
    function jn(l) {
      l[xl] = !0;
    }
    var Nm = /* @__PURE__ */ new Set(), Pm = {};
    function aa(l, f) {
      ds(l, f), ds(l + "Capture", f);
    }
    function ds(l, f) {
      for (Pm[l] = f, l = 0; l < f.length; l++)
        Nm.add(f[l]);
    }
    var W1 = RegExp(
      "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    ), ed = {}, Im = {};
    function G1(l) {
      return ze.call(Im, l) ? !0 : ze.call(ed, l) ? !1 : W1.test(l) ? Im[l] = !0 : (ed[l] = !0, !1);
    }
    function Lc(l, f, h) {
      if (G1(f))
        if (h === null) l.removeAttribute(f);
        else {
          switch (typeof h) {
            case "undefined":
            case "function":
            case "symbol":
              l.removeAttribute(f);
              return;
            case "boolean":
              var w = f.toLowerCase().slice(0, 5);
              if (w !== "data-" && w !== "aria-") {
                l.removeAttribute(f);
                return;
              }
          }
          l.setAttribute(f, "" + h);
        }
    }
    function zc(l, f, h) {
      if (h === null) l.removeAttribute(f);
      else {
        switch (typeof h) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            l.removeAttribute(f);
            return;
        }
        l.setAttribute(f, "" + h);
      }
    }
    function zo(l, f, h, w) {
      if (w === null) l.removeAttribute(h);
      else {
        switch (typeof w) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            l.removeAttribute(h);
            return;
        }
        l.setAttributeNS(f, h, "" + w);
      }
    }
    function Mr(l) {
      switch (typeof l) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return l;
        case "object":
          return l;
        default:
          return "";
      }
    }
    function $m(l) {
      var f = l.type;
      return (l = l.nodeName) && l.toLowerCase() === "input" && (f === "checkbox" || f === "radio");
    }
    function K1(l, f, h) {
      var w = Object.getOwnPropertyDescriptor(
        l.constructor.prototype,
        f
      );
      if (!l.hasOwnProperty(f) && typeof w < "u" && typeof w.get == "function" && typeof w.set == "function") {
        var R = w.get, M = w.set;
        return Object.defineProperty(l, f, {
          configurable: !0,
          get: function() {
            return R.call(this);
          },
          set: function(q) {
            h = "" + q, M.call(this, q);
          }
        }), Object.defineProperty(l, f, {
          enumerable: w.enumerable
        }), {
          getValue: function() {
            return h;
          },
          setValue: function(q) {
            h = "" + q;
          },
          stopTracking: function() {
            l._valueTracker = null, delete l[f];
          }
        };
      }
    }
    function Bc(l) {
      if (!l._valueTracker) {
        var f = $m(l) ? "checked" : "value";
        l._valueTracker = K1(
          l,
          f,
          "" + l[f]
        );
      }
    }
    function jm(l) {
      if (!l) return !1;
      var f = l._valueTracker;
      if (!f) return !0;
      var h = f.getValue(), w = "";
      return l && (w = $m(l) ? l.checked ? "true" : "false" : l.value), l = w, l !== h ? (f.setValue(l), !0) : !1;
    }
    function wl(l) {
      if (l = l || (typeof document < "u" ? document : void 0), typeof l > "u") return null;
      try {
        return l.activeElement || l.body;
      } catch {
        return l.body;
      }
    }
    var Y1 = /[\n"\\]/g;
    function Nr(l) {
      return l.replace(
        Y1,
        function(f) {
          return "\\" + f.charCodeAt(0).toString(16) + " ";
        }
      );
    }
    function Sl(l, f, h, w, R, M, q, Z) {
      l.name = "", q != null && typeof q != "function" && typeof q != "symbol" && typeof q != "boolean" ? l.type = q : l.removeAttribute("type"), f != null ? q === "number" ? (f === 0 && l.value === "" || l.value != f) && (l.value = "" + Mr(f)) : l.value !== "" + Mr(f) && (l.value = "" + Mr(f)) : q !== "submit" && q !== "reset" || l.removeAttribute("value"), f != null ? td(l, q, Mr(f)) : h != null ? td(l, q, Mr(h)) : w != null && l.removeAttribute("value"), R == null && M != null && (l.defaultChecked = !!M), R != null && (l.checked = R && typeof R != "function" && typeof R != "symbol"), Z != null && typeof Z != "function" && typeof Z != "symbol" && typeof Z != "boolean" ? l.name = "" + Mr(Z) : l.removeAttribute("name");
    }
    function Dm(l, f, h, w, R, M, q, Z) {
      if (M != null && typeof M != "function" && typeof M != "symbol" && typeof M != "boolean" && (l.type = M), f != null || h != null) {
        if (!(M !== "submit" && M !== "reset" || f != null)) {
          Bc(l);
          return;
        }
        h = h != null ? "" + Mr(h) : "", f = f != null ? "" + Mr(f) : h, Z || f === l.value || (l.value = f), l.defaultValue = f;
      }
      w = w ?? R, w = typeof w != "function" && typeof w != "symbol" && !!w, l.checked = Z ? l.checked : !!w, l.defaultChecked = !!w, q != null && typeof q != "function" && typeof q != "symbol" && typeof q != "boolean" && (l.name = q), Bc(l);
    }
    function td(l, f, h) {
      f === "number" && wl(l.ownerDocument) === l || l.defaultValue === "" + h || (l.defaultValue = "" + h);
    }
    function sa(l, f, h, w) {
      if (l = l.options, f) {
        f = {};
        for (var R = 0; R < h.length; R++)
          f["$" + h[R]] = !0;
        for (h = 0; h < l.length; h++)
          R = f.hasOwnProperty("$" + l[h].value), l[h].selected !== R && (l[h].selected = R), R && w && (l[h].defaultSelected = !0);
      } else {
        for (h = "" + Mr(h), f = null, R = 0; R < l.length; R++) {
          if (l[R].value === h) {
            l[R].selected = !0, w && (l[R].defaultSelected = !0);
            return;
          }
          f !== null || l[R].disabled || (f = l[R]);
        }
        f !== null && (f.selected = !0);
      }
    }
    function IR(l, f, h) {
      if (f != null && (f = "" + Mr(f), f !== l.value && (l.value = f), h == null)) {
        l.defaultValue !== f && (l.defaultValue = f);
        return;
      }
      l.defaultValue = h != null ? "" + Mr(h) : "";
    }
    function $R(l, f, h, w) {
      if (f == null) {
        if (w != null) {
          if (h != null) throw Error(r(92));
          if (V(w)) {
            if (1 < w.length) throw Error(r(93));
            w = w[0];
          }
          h = w;
        }
        h == null && (h = ""), f = h;
      }
      h = Mr(f), l.defaultValue = h, w = l.textContent, w === h && w !== "" && w !== null && (l.value = w), Bc(l);
    }
    function Uc(l, f) {
      if (f) {
        var h = l.firstChild;
        if (h && h === l.lastChild && h.nodeType === 3) {
          h.nodeValue = f;
          return;
        }
      }
      l.textContent = f;
    }
    var jq = new Set(
      "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
        " "
      )
    );
    function jR(l, f, h) {
      var w = f.indexOf("--") === 0;
      h == null || typeof h == "boolean" || h === "" ? w ? l.setProperty(f, "") : f === "float" ? l.cssFloat = "" : l[f] = "" : w ? l.setProperty(f, h) : typeof h != "number" || h === 0 || jq.has(f) ? f === "float" ? l.cssFloat = h : l[f] = ("" + h).trim() : l[f] = h + "px";
    }
    function DR(l, f, h) {
      if (f != null && typeof f != "object")
        throw Error(r(62));
      if (l = l.style, h != null) {
        for (var w in h)
          !h.hasOwnProperty(w) || f != null && f.hasOwnProperty(w) || (w.indexOf("--") === 0 ? l.setProperty(w, "") : w === "float" ? l.cssFloat = "" : l[w] = "");
        for (var R in f)
          w = f[R], f.hasOwnProperty(R) && h[R] !== w && jR(l, R, w);
      } else
        for (var M in f)
          f.hasOwnProperty(M) && jR(l, M, f[M]);
    }
    function X1(l) {
      if (l.indexOf("-") === -1) return !1;
      switch (l) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var Dq = /* @__PURE__ */ new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"]
    ]), Fq = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function Fm(l) {
      return Fq.test("" + l) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : l;
    }
    function la() {
    }
    var Z1 = null;
    function Q1(l) {
      return l = l.target || l.srcElement || window, l.correspondingUseElement && (l = l.correspondingUseElement), l.nodeType === 3 ? l.parentNode : l;
    }
    var Vc = null, Hc = null;
    function FR(l) {
      var f = cs(l);
      if (f && (l = f.stateNode)) {
        var h = l[pr] || null;
        e: switch (l = f.stateNode, f.type) {
          case "input":
            if (Sl(
              l,
              h.value,
              h.defaultValue,
              h.defaultValue,
              h.checked,
              h.defaultChecked,
              h.type,
              h.name
            ), f = h.name, h.type === "radio" && f != null) {
              for (h = l; h.parentNode; ) h = h.parentNode;
              for (h = h.querySelectorAll(
                'input[name="' + Nr(
                  "" + f
                ) + '"][type="radio"]'
              ), f = 0; f < h.length; f++) {
                var w = h[f];
                if (w !== l && w.form === l.form) {
                  var R = w[pr] || null;
                  if (!R) throw Error(r(90));
                  Sl(
                    w,
                    R.value,
                    R.defaultValue,
                    R.defaultValue,
                    R.checked,
                    R.defaultChecked,
                    R.type,
                    R.name
                  );
                }
              }
              for (f = 0; f < h.length; f++)
                w = h[f], w.form === l.form && jm(w);
            }
            break e;
          case "textarea":
            IR(l, h.value, h.defaultValue);
            break e;
          case "select":
            f = h.value, f != null && sa(l, !!h.multiple, f, !1);
        }
      }
    }
    var J1 = !1;
    function LR(l, f, h) {
      if (J1) return l(f, h);
      J1 = !0;
      try {
        var w = l(f);
        return w;
      } finally {
        if (J1 = !1, (Vc !== null || Hc !== null) && (Cg(), Vc && (f = Vc, l = Hc, Hc = Vc = null, FR(f), l)))
          for (f = 0; f < l.length; f++) FR(l[f]);
      }
    }
    function nd(l, f) {
      var h = l.stateNode;
      if (h === null) return null;
      var w = h[pr] || null;
      if (w === null) return null;
      h = w[f];
      e: switch (f) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (w = !w.disabled) || (l = l.type, w = !(l === "button" || l === "input" || l === "select" || l === "textarea")), l = !w;
          break e;
        default:
          l = !1;
      }
      if (l) return null;
      if (h && typeof h != "function")
        throw Error(
          r(231, f, typeof h)
        );
      return h;
    }
    var ca = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), ex = !1;
    if (ca)
      try {
        var rd = {};
        Object.defineProperty(rd, "passive", {
          get: function() {
            ex = !0;
          }
        }), window.addEventListener("test", rd, rd), window.removeEventListener("test", rd, rd);
      } catch {
        ex = !1;
      }
    var ps = null, tx = null, Lm = null;
    function zR() {
      if (Lm) return Lm;
      var l, f = tx, h = f.length, w, R = "value" in ps ? ps.value : ps.textContent, M = R.length;
      for (l = 0; l < h && f[l] === R[l]; l++) ;
      var q = h - l;
      for (w = 1; w <= q && f[h - w] === R[M - w]; w++) ;
      return Lm = R.slice(l, 1 < w ? 1 - w : void 0);
    }
    function zm(l) {
      var f = l.keyCode;
      return "charCode" in l ? (l = l.charCode, l === 0 && f === 13 && (l = 13)) : l = f, l === 10 && (l = 13), 32 <= l || l === 13 ? l : 0;
    }
    function Bm() {
      return !0;
    }
    function BR() {
      return !1;
    }
    function Pr(l) {
      function f(h, w, R, M, q) {
        this._reactName = h, this._targetInst = R, this.type = w, this.nativeEvent = M, this.target = q, this.currentTarget = null;
        for (var Z in l)
          l.hasOwnProperty(Z) && (h = l[Z], this[Z] = h ? h(M) : M[Z]);
        return this.isDefaultPrevented = (M.defaultPrevented != null ? M.defaultPrevented : M.returnValue === !1) ? Bm : BR, this.isPropagationStopped = BR, this;
      }
      return p(f.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var h = this.nativeEvent;
          h && (h.preventDefault ? h.preventDefault() : typeof h.returnValue != "unknown" && (h.returnValue = !1), this.isDefaultPrevented = Bm);
        },
        stopPropagation: function() {
          var h = this.nativeEvent;
          h && (h.stopPropagation ? h.stopPropagation() : typeof h.cancelBubble != "unknown" && (h.cancelBubble = !0), this.isPropagationStopped = Bm);
        },
        persist: function() {
        },
        isPersistent: Bm
      }), f;
    }
    var _l = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(l) {
        return l.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, Um = Pr(_l), od = p({}, _l, { view: 0, detail: 0 }), Lq = Pr(od), nx, rx, id, Vm = p({}, od, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: ix,
      button: 0,
      buttons: 0,
      relatedTarget: function(l) {
        return l.relatedTarget === void 0 ? l.fromElement === l.srcElement ? l.toElement : l.fromElement : l.relatedTarget;
      },
      movementX: function(l) {
        return "movementX" in l ? l.movementX : (l !== id && (id && l.type === "mousemove" ? (nx = l.screenX - id.screenX, rx = l.screenY - id.screenY) : rx = nx = 0, id = l), nx);
      },
      movementY: function(l) {
        return "movementY" in l ? l.movementY : rx;
      }
    }), UR = Pr(Vm), zq = p({}, Vm, { dataTransfer: 0 }), Bq = Pr(zq), Uq = p({}, od, { relatedTarget: 0 }), ox = Pr(Uq), Vq = p({}, _l, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Hq = Pr(Vq), qq = p({}, _l, {
      clipboardData: function(l) {
        return "clipboardData" in l ? l.clipboardData : window.clipboardData;
      }
    }), Wq = Pr(qq), Gq = p({}, _l, { data: 0 }), VR = Pr(Gq), Kq = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Yq = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, Xq = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function Zq(l) {
      var f = this.nativeEvent;
      return f.getModifierState ? f.getModifierState(l) : (l = Xq[l]) ? !!f[l] : !1;
    }
    function ix() {
      return Zq;
    }
    var Qq = p({}, od, {
      key: function(l) {
        if (l.key) {
          var f = Kq[l.key] || l.key;
          if (f !== "Unidentified") return f;
        }
        return l.type === "keypress" ? (l = zm(l), l === 13 ? "Enter" : String.fromCharCode(l)) : l.type === "keydown" || l.type === "keyup" ? Yq[l.keyCode] || "Unidentified" : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: ix,
      charCode: function(l) {
        return l.type === "keypress" ? zm(l) : 0;
      },
      keyCode: function(l) {
        return l.type === "keydown" || l.type === "keyup" ? l.keyCode : 0;
      },
      which: function(l) {
        return l.type === "keypress" ? zm(l) : l.type === "keydown" || l.type === "keyup" ? l.keyCode : 0;
      }
    }), Jq = Pr(Qq), eW = p({}, Vm, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), HR = Pr(eW), tW = p({}, od, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: ix
    }), nW = Pr(tW), rW = p({}, _l, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), oW = Pr(rW), iW = p({}, Vm, {
      deltaX: function(l) {
        return "deltaX" in l ? l.deltaX : "wheelDeltaX" in l ? -l.wheelDeltaX : 0;
      },
      deltaY: function(l) {
        return "deltaY" in l ? l.deltaY : "wheelDeltaY" in l ? -l.wheelDeltaY : "wheelDelta" in l ? -l.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), aW = Pr(iW), sW = p({}, _l, {
      newState: 0,
      oldState: 0
    }), lW = Pr(sW), cW = [9, 13, 27, 32], ax = ca && "CompositionEvent" in window, ad = null;
    ca && "documentMode" in document && (ad = document.documentMode);
    var uW = ca && "TextEvent" in window && !ad, qR = ca && (!ax || ad && 8 < ad && 11 >= ad), WR = " ", GR = !1;
    function KR(l, f) {
      switch (l) {
        case "keyup":
          return cW.indexOf(f.keyCode) !== -1;
        case "keydown":
          return f.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function YR(l) {
      return l = l.detail, typeof l == "object" && "data" in l ? l.data : null;
    }
    var qc = !1;
    function fW(l, f) {
      switch (l) {
        case "compositionend":
          return YR(f);
        case "keypress":
          return f.which !== 32 ? null : (GR = !0, WR);
        case "textInput":
          return l = f.data, l === WR && GR ? null : l;
        default:
          return null;
      }
    }
    function dW(l, f) {
      if (qc)
        return l === "compositionend" || !ax && KR(l, f) ? (l = zR(), Lm = tx = ps = null, qc = !1, l) : null;
      switch (l) {
        case "paste":
          return null;
        case "keypress":
          if (!(f.ctrlKey || f.altKey || f.metaKey) || f.ctrlKey && f.altKey) {
            if (f.char && 1 < f.char.length)
              return f.char;
            if (f.which) return String.fromCharCode(f.which);
          }
          return null;
        case "compositionend":
          return qR && f.locale !== "ko" ? null : f.data;
        default:
          return null;
      }
    }
    var pW = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function XR(l) {
      var f = l && l.nodeName && l.nodeName.toLowerCase();
      return f === "input" ? !!pW[l.type] : f === "textarea";
    }
    function ZR(l, f, h, w) {
      Vc ? Hc ? Hc.push(w) : Hc = [w] : Vc = w, f = Ng(f, "onChange"), 0 < f.length && (h = new Um(
        "onChange",
        "change",
        null,
        h,
        w
      ), l.push({ event: h, listeners: f }));
    }
    var sd = null, ld = null;
    function hW(l) {
      PN(l, 0);
    }
    function Hm(l) {
      var f = us(l);
      if (jm(f)) return l;
    }
    function QR(l, f) {
      if (l === "change") return f;
    }
    var JR = !1;
    if (ca) {
      var sx;
      if (ca) {
        var lx = "oninput" in document;
        if (!lx) {
          var eO = document.createElement("div");
          eO.setAttribute("oninput", "return;"), lx = typeof eO.oninput == "function";
        }
        sx = lx;
      } else sx = !1;
      JR = sx && (!document.documentMode || 9 < document.documentMode);
    }
    function tO() {
      sd && (sd.detachEvent("onpropertychange", nO), ld = sd = null);
    }
    function nO(l) {
      if (l.propertyName === "value" && Hm(ld)) {
        var f = [];
        ZR(
          f,
          ld,
          l,
          Q1(l)
        ), LR(hW, f);
      }
    }
    function mW(l, f, h) {
      l === "focusin" ? (tO(), sd = f, ld = h, sd.attachEvent("onpropertychange", nO)) : l === "focusout" && tO();
    }
    function gW(l) {
      if (l === "selectionchange" || l === "keyup" || l === "keydown")
        return Hm(ld);
    }
    function yW(l, f) {
      if (l === "click") return Hm(f);
    }
    function vW(l, f) {
      if (l === "input" || l === "change")
        return Hm(f);
    }
    function bW(l, f) {
      return l === f && (l !== 0 || 1 / l === 1 / f) || l !== l && f !== f;
    }
    var Kr = typeof Object.is == "function" ? Object.is : bW;
    function cd(l, f) {
      if (Kr(l, f)) return !0;
      if (typeof l != "object" || l === null || typeof f != "object" || f === null)
        return !1;
      var h = Object.keys(l), w = Object.keys(f);
      if (h.length !== w.length) return !1;
      for (w = 0; w < h.length; w++) {
        var R = h[w];
        if (!ze.call(f, R) || !Kr(l[R], f[R]))
          return !1;
      }
      return !0;
    }
    function rO(l) {
      for (; l && l.firstChild; ) l = l.firstChild;
      return l;
    }
    function oO(l, f) {
      var h = rO(l);
      l = 0;
      for (var w; h; ) {
        if (h.nodeType === 3) {
          if (w = l + h.textContent.length, l <= f && w >= f)
            return { node: h, offset: f - l };
          l = w;
        }
        e: {
          for (; h; ) {
            if (h.nextSibling) {
              h = h.nextSibling;
              break e;
            }
            h = h.parentNode;
          }
          h = void 0;
        }
        h = rO(h);
      }
    }
    function iO(l, f) {
      return l && f ? l === f ? !0 : l && l.nodeType === 3 ? !1 : f && f.nodeType === 3 ? iO(l, f.parentNode) : "contains" in l ? l.contains(f) : l.compareDocumentPosition ? !!(l.compareDocumentPosition(f) & 16) : !1 : !1;
    }
    function aO(l) {
      l = l != null && l.ownerDocument != null && l.ownerDocument.defaultView != null ? l.ownerDocument.defaultView : window;
      for (var f = wl(l.document); f instanceof l.HTMLIFrameElement; ) {
        try {
          var h = typeof f.contentWindow.location.href == "string";
        } catch {
          h = !1;
        }
        if (h) l = f.contentWindow;
        else break;
        f = wl(l.document);
      }
      return f;
    }
    function cx(l) {
      var f = l && l.nodeName && l.nodeName.toLowerCase();
      return f && (f === "input" && (l.type === "text" || l.type === "search" || l.type === "tel" || l.type === "url" || l.type === "password") || f === "textarea" || l.contentEditable === "true");
    }
    var xW = ca && "documentMode" in document && 11 >= document.documentMode, Wc = null, ux = null, ud = null, fx = !1;
    function sO(l, f, h) {
      var w = h.window === h ? h.document : h.nodeType === 9 ? h : h.ownerDocument;
      fx || Wc == null || Wc !== wl(w) || (w = Wc, "selectionStart" in w && cx(w) ? w = { start: w.selectionStart, end: w.selectionEnd } : (w = (w.ownerDocument && w.ownerDocument.defaultView || window).getSelection(), w = {
        anchorNode: w.anchorNode,
        anchorOffset: w.anchorOffset,
        focusNode: w.focusNode,
        focusOffset: w.focusOffset
      }), ud && cd(ud, w) || (ud = w, w = Ng(ux, "onSelect"), 0 < w.length && (f = new Um(
        "onSelect",
        "select",
        null,
        f,
        h
      ), l.push({ event: f, listeners: w }), f.target = Wc)));
    }
    function El(l, f) {
      var h = {};
      return h[l.toLowerCase()] = f.toLowerCase(), h["Webkit" + l] = "webkit" + f, h["Moz" + l] = "moz" + f, h;
    }
    var Gc = {
      animationend: El("Animation", "AnimationEnd"),
      animationiteration: El("Animation", "AnimationIteration"),
      animationstart: El("Animation", "AnimationStart"),
      transitionrun: El("Transition", "TransitionRun"),
      transitionstart: El("Transition", "TransitionStart"),
      transitioncancel: El("Transition", "TransitionCancel"),
      transitionend: El("Transition", "TransitionEnd")
    }, dx = {}, lO = {};
    ca && (lO = document.createElement("div").style, "AnimationEvent" in window || (delete Gc.animationend.animation, delete Gc.animationiteration.animation, delete Gc.animationstart.animation), "TransitionEvent" in window || delete Gc.transitionend.transition);
    function Cl(l) {
      if (dx[l]) return dx[l];
      if (!Gc[l]) return l;
      var f = Gc[l], h;
      for (h in f)
        if (f.hasOwnProperty(h) && h in lO)
          return dx[l] = f[h];
      return l;
    }
    var cO = Cl("animationend"), uO = Cl("animationiteration"), fO = Cl("animationstart"), wW = Cl("transitionrun"), SW = Cl("transitionstart"), _W = Cl("transitioncancel"), dO = Cl("transitionend"), pO = /* @__PURE__ */ new Map(), px = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
    px.push("scrollEnd");
    function Bo(l, f) {
      pO.set(l, f), aa(f, [l]);
    }
    var qm = typeof reportError == "function" ? reportError : function(l) {
      if (typeof window == "object" && typeof window.ErrorEvent == "function") {
        var f = new window.ErrorEvent("error", {
          bubbles: !0,
          cancelable: !0,
          message: typeof l == "object" && l !== null && typeof l.message == "string" ? String(l.message) : String(l),
          error: l
        });
        if (!window.dispatchEvent(f)) return;
      } else if (typeof process == "object" && typeof process.emit == "function") {
        process.emit("uncaughtException", l);
        return;
      }
      console.error(l);
    }, vo = [], Kc = 0, hx = 0;
    function Wm() {
      for (var l = Kc, f = hx = Kc = 0; f < l; ) {
        var h = vo[f];
        vo[f++] = null;
        var w = vo[f];
        vo[f++] = null;
        var R = vo[f];
        vo[f++] = null;
        var M = vo[f];
        if (vo[f++] = null, w !== null && R !== null) {
          var q = w.pending;
          q === null ? R.next = R : (R.next = q.next, q.next = R), w.pending = R;
        }
        M !== 0 && hO(h, R, M);
      }
    }
    function Gm(l, f, h, w) {
      vo[Kc++] = l, vo[Kc++] = f, vo[Kc++] = h, vo[Kc++] = w, hx |= w, l.lanes |= w, l = l.alternate, l !== null && (l.lanes |= w);
    }
    function mx(l, f, h, w) {
      return Gm(l, f, h, w), Km(l);
    }
    function kl(l, f) {
      return Gm(l, null, null, f), Km(l);
    }
    function hO(l, f, h) {
      l.lanes |= h;
      var w = l.alternate;
      w !== null && (w.lanes |= h);
      for (var R = !1, M = l.return; M !== null; )
        M.childLanes |= h, w = M.alternate, w !== null && (w.childLanes |= h), M.tag === 22 && (l = M.stateNode, l === null || l._visibility & 1 || (R = !0)), l = M, M = M.return;
      return l.tag === 3 ? (M = l.stateNode, R && f !== null && (R = 31 - Mt(h), l = M.hiddenUpdates, w = l[R], w === null ? l[R] = [f] : w.push(f), f.lane = h | 536870912), M) : null;
    }
    function Km(l) {
      if (50 < Nd)
        throw Nd = 0, Ew = null, Error(r(185));
      for (var f = l.return; f !== null; )
        l = f, f = l.return;
      return l.tag === 3 ? l.stateNode : null;
    }
    var Yc = {};
    function EW(l, f, h, w) {
      this.tag = l, this.key = h, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = f, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = w, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
    }
    function Yr(l, f, h, w) {
      return new EW(l, f, h, w);
    }
    function gx(l) {
      return l = l.prototype, !(!l || !l.isReactComponent);
    }
    function ua(l, f) {
      var h = l.alternate;
      return h === null ? (h = Yr(
        l.tag,
        f,
        l.key,
        l.mode
      ), h.elementType = l.elementType, h.type = l.type, h.stateNode = l.stateNode, h.alternate = l, l.alternate = h) : (h.pendingProps = f, h.type = l.type, h.flags = 0, h.subtreeFlags = 0, h.deletions = null), h.flags = l.flags & 65011712, h.childLanes = l.childLanes, h.lanes = l.lanes, h.child = l.child, h.memoizedProps = l.memoizedProps, h.memoizedState = l.memoizedState, h.updateQueue = l.updateQueue, f = l.dependencies, h.dependencies = f === null ? null : { lanes: f.lanes, firstContext: f.firstContext }, h.sibling = l.sibling, h.index = l.index, h.ref = l.ref, h.refCleanup = l.refCleanup, h;
    }
    function mO(l, f) {
      l.flags &= 65011714;
      var h = l.alternate;
      return h === null ? (l.childLanes = 0, l.lanes = f, l.child = null, l.subtreeFlags = 0, l.memoizedProps = null, l.memoizedState = null, l.updateQueue = null, l.dependencies = null, l.stateNode = null) : (l.childLanes = h.childLanes, l.lanes = h.lanes, l.child = h.child, l.subtreeFlags = 0, l.deletions = null, l.memoizedProps = h.memoizedProps, l.memoizedState = h.memoizedState, l.updateQueue = h.updateQueue, l.type = h.type, f = h.dependencies, l.dependencies = f === null ? null : {
        lanes: f.lanes,
        firstContext: f.firstContext
      }), l;
    }
    function Ym(l, f, h, w, R, M) {
      var q = 0;
      if (w = l, typeof l == "function") gx(l) && (q = 1);
      else if (typeof l == "string")
        q = RG(
          l,
          h,
          H.current
        ) ? 26 : l === "html" || l === "head" || l === "body" ? 27 : 5;
      else
        e: switch (l) {
          case I:
            return l = Yr(31, h, f, R), l.elementType = I, l.lanes = M, l;
          case b:
            return Tl(h.children, R, M, f);
          case v:
            q = 8, R |= 24;
            break;
          case x:
            return l = Yr(12, h, f, R | 2), l.elementType = x, l.lanes = M, l;
          case k:
            return l = Yr(13, h, f, R), l.elementType = k, l.lanes = M, l;
          case A:
            return l = Yr(19, h, f, R), l.elementType = A, l.lanes = M, l;
          default:
            if (typeof l == "object" && l !== null)
              switch (l.$$typeof) {
                case _:
                  q = 10;
                  break e;
                case E:
                  q = 9;
                  break e;
                case C:
                  q = 11;
                  break e;
                case O:
                  q = 14;
                  break e;
                case P:
                  q = 16, w = null;
                  break e;
              }
            q = 29, h = Error(
              r(130, l === null ? "null" : typeof l, "")
            ), w = null;
        }
      return f = Yr(q, h, f, R), f.elementType = l, f.type = w, f.lanes = M, f;
    }
    function Tl(l, f, h, w) {
      return l = Yr(7, l, w, f), l.lanes = h, l;
    }
    function yx(l, f, h) {
      return l = Yr(6, l, null, f), l.lanes = h, l;
    }
    function gO(l) {
      var f = Yr(18, null, null, 0);
      return f.stateNode = l, f;
    }
    function vx(l, f, h) {
      return f = Yr(
        4,
        l.children !== null ? l.children : [],
        l.key,
        f
      ), f.lanes = h, f.stateNode = {
        containerInfo: l.containerInfo,
        pendingChildren: null,
        implementation: l.implementation
      }, f;
    }
    var yO = /* @__PURE__ */ new WeakMap();
    function bo(l, f) {
      if (typeof l == "object" && l !== null) {
        var h = yO.get(l);
        return h !== void 0 ? h : (f = {
          value: l,
          source: f,
          stack: je(f)
        }, yO.set(l, f), f);
      }
      return {
        value: l,
        source: f,
        stack: je(f)
      };
    }
    var Xc = [], Zc = 0, Xm = null, fd = 0, xo = [], wo = 0, hs = null, di = 1, pi = "";
    function fa(l, f) {
      Xc[Zc++] = fd, Xc[Zc++] = Xm, Xm = l, fd = f;
    }
    function vO(l, f, h) {
      xo[wo++] = di, xo[wo++] = pi, xo[wo++] = hs, hs = l;
      var w = di;
      l = pi;
      var R = 32 - Mt(w) - 1;
      w &= ~(1 << R), h += 1;
      var M = 32 - Mt(f) + R;
      if (30 < M) {
        var q = R - R % 5;
        M = (w & (1 << q) - 1).toString(32), w >>= q, R -= q, di = 1 << 32 - Mt(f) + R | h << R | w, pi = M + l;
      } else
        di = 1 << M | h << R | w, pi = l;
    }
    function bx(l) {
      l.return !== null && (fa(l, 1), vO(l, 1, 0));
    }
    function xx(l) {
      for (; l === Xm; )
        Xm = Xc[--Zc], Xc[Zc] = null, fd = Xc[--Zc], Xc[Zc] = null;
      for (; l === hs; )
        hs = xo[--wo], xo[wo] = null, pi = xo[--wo], xo[wo] = null, di = xo[--wo], xo[wo] = null;
    }
    function bO(l, f) {
      xo[wo++] = di, xo[wo++] = pi, xo[wo++] = hs, di = f.id, pi = f.overflow, hs = l;
    }
    var rr = null, mn = null, At = !1, ms = null, So = !1, wx = Error(r(519));
    function gs(l) {
      var f = Error(
        r(
          418,
          1 < arguments.length && arguments[1] !== void 0 && arguments[1] ? "text" : "HTML",
          ""
        )
      );
      throw dd(bo(f, l)), wx;
    }
    function xO(l) {
      var f = l.stateNode, h = l.type, w = l.memoizedProps;
      switch (f[Wn] = l, f[pr] = w, h) {
        case "dialog":
          St("cancel", f), St("close", f);
          break;
        case "iframe":
        case "object":
        case "embed":
          St("load", f);
          break;
        case "video":
        case "audio":
          for (h = 0; h < Id.length; h++)
            St(Id[h], f);
          break;
        case "source":
          St("error", f);
          break;
        case "img":
        case "image":
        case "link":
          St("error", f), St("load", f);
          break;
        case "details":
          St("toggle", f);
          break;
        case "input":
          St("invalid", f), Dm(
            f,
            w.value,
            w.defaultValue,
            w.checked,
            w.defaultChecked,
            w.type,
            w.name,
            !0
          );
          break;
        case "select":
          St("invalid", f);
          break;
        case "textarea":
          St("invalid", f), $R(f, w.value, w.defaultValue, w.children);
      }
      h = w.children, typeof h != "string" && typeof h != "number" && typeof h != "bigint" || f.textContent === "" + h || w.suppressHydrationWarning === !0 || DN(f.textContent, h) ? (w.popover != null && (St("beforetoggle", f), St("toggle", f)), w.onScroll != null && St("scroll", f), w.onScrollEnd != null && St("scrollend", f), w.onClick != null && (f.onclick = la), f = !0) : f = !1, f || gs(l, !0);
    }
    function wO(l) {
      for (rr = l.return; rr; )
        switch (rr.tag) {
          case 5:
          case 31:
          case 13:
            So = !1;
            return;
          case 27:
          case 3:
            So = !0;
            return;
          default:
            rr = rr.return;
        }
    }
    function Qc(l) {
      if (l !== rr) return !1;
      if (!At) return wO(l), At = !0, !1;
      var f = l.tag, h;
      if ((h = f !== 3 && f !== 27) && ((h = f === 5) && (h = l.type, h = !(h !== "form" && h !== "button") || Lw(l.type, l.memoizedProps)), h = !h), h && mn && gs(l), wO(l), f === 13) {
        if (l = l.memoizedState, l = l !== null ? l.dehydrated : null, !l) throw Error(r(317));
        mn = WN(l);
      } else if (f === 31) {
        if (l = l.memoizedState, l = l !== null ? l.dehydrated : null, !l) throw Error(r(317));
        mn = WN(l);
      } else
        f === 27 ? (f = mn, Os(l.type) ? (l = Hw, Hw = null, mn = l) : mn = f) : mn = rr ? Eo(l.stateNode.nextSibling) : null;
      return !0;
    }
    function Al() {
      mn = rr = null, At = !1;
    }
    function Sx() {
      var l = ms;
      return l !== null && (Dr === null ? Dr = l : Dr.push.apply(
        Dr,
        l
      ), ms = null), l;
    }
    function dd(l) {
      ms === null ? ms = [l] : ms.push(l);
    }
    var _x = D(null), Rl = null, da = null;
    function ys(l, f, h) {
      z(_x, f._currentValue), f._currentValue = h;
    }
    function pa(l) {
      l._currentValue = _x.current, G(_x);
    }
    function Ex(l, f, h) {
      for (; l !== null; ) {
        var w = l.alternate;
        if ((l.childLanes & f) !== f ? (l.childLanes |= f, w !== null && (w.childLanes |= f)) : w !== null && (w.childLanes & f) !== f && (w.childLanes |= f), l === h) break;
        l = l.return;
      }
    }
    function Cx(l, f, h, w) {
      var R = l.child;
      for (R !== null && (R.return = l); R !== null; ) {
        var M = R.dependencies;
        if (M !== null) {
          var q = R.child;
          M = M.firstContext;
          e: for (; M !== null; ) {
            var Z = M;
            M = R;
            for (var re = 0; re < f.length; re++)
              if (Z.context === f[re]) {
                M.lanes |= h, Z = M.alternate, Z !== null && (Z.lanes |= h), Ex(
                  M.return,
                  h,
                  l
                ), w || (q = null);
                break e;
              }
            M = Z.next;
          }
        } else if (R.tag === 18) {
          if (q = R.return, q === null) throw Error(r(341));
          q.lanes |= h, M = q.alternate, M !== null && (M.lanes |= h), Ex(q, h, l), q = null;
        } else q = R.child;
        if (q !== null) q.return = R;
        else
          for (q = R; q !== null; ) {
            if (q === l) {
              q = null;
              break;
            }
            if (R = q.sibling, R !== null) {
              R.return = q.return, q = R;
              break;
            }
            q = q.return;
          }
        R = q;
      }
    }
    function Jc(l, f, h, w) {
      l = null;
      for (var R = f, M = !1; R !== null; ) {
        if (!M) {
          if ((R.flags & 524288) !== 0) M = !0;
          else if ((R.flags & 262144) !== 0) break;
        }
        if (R.tag === 10) {
          var q = R.alternate;
          if (q === null) throw Error(r(387));
          if (q = q.memoizedProps, q !== null) {
            var Z = R.type;
            Kr(R.pendingProps.value, q.value) || (l !== null ? l.push(Z) : l = [Z]);
          }
        } else if (R === ne.current) {
          if (q = R.alternate, q === null) throw Error(r(387));
          q.memoizedState.memoizedState !== R.memoizedState.memoizedState && (l !== null ? l.push(Ld) : l = [Ld]);
        }
        R = R.return;
      }
      l !== null && Cx(
        f,
        l,
        h,
        w
      ), f.flags |= 262144;
    }
    function Zm(l) {
      for (l = l.firstContext; l !== null; ) {
        if (!Kr(
          l.context._currentValue,
          l.memoizedValue
        ))
          return !0;
        l = l.next;
      }
      return !1;
    }
    function Ol(l) {
      Rl = l, da = null, l = l.dependencies, l !== null && (l.firstContext = null);
    }
    function or(l) {
      return SO(Rl, l);
    }
    function Qm(l, f) {
      return Rl === null && Ol(l), SO(l, f);
    }
    function SO(l, f) {
      var h = f._currentValue;
      if (f = { context: f, memoizedValue: h, next: null }, da === null) {
        if (l === null) throw Error(r(308));
        da = f, l.dependencies = { lanes: 0, firstContext: f }, l.flags |= 524288;
      } else da = da.next = f;
      return h;
    }
    var CW = typeof AbortController < "u" ? AbortController : function() {
      var l = [], f = this.signal = {
        aborted: !1,
        addEventListener: function(h, w) {
          l.push(w);
        }
      };
      this.abort = function() {
        f.aborted = !0, l.forEach(function(h) {
          return h();
        });
      };
    }, kW = e.unstable_scheduleCallback, TW = e.unstable_NormalPriority, Dn = {
      $$typeof: _,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0
    };
    function kx() {
      return {
        controller: new CW(),
        data: /* @__PURE__ */ new Map(),
        refCount: 0
      };
    }
    function pd(l) {
      l.refCount--, l.refCount === 0 && kW(TW, function() {
        l.controller.abort();
      });
    }
    var hd = null, Tx = 0, eu = 0, tu = null;
    function AW(l, f) {
      if (hd === null) {
        var h = hd = [];
        Tx = 0, eu = Ow(), tu = {
          status: "pending",
          value: void 0,
          then: function(w) {
            h.push(w);
          }
        };
      }
      return Tx++, f.then(_O, _O), f;
    }
    function _O() {
      if (--Tx === 0 && hd !== null) {
        tu !== null && (tu.status = "fulfilled");
        var l = hd;
        hd = null, eu = 0, tu = null;
        for (var f = 0; f < l.length; f++) (0, l[f])();
      }
    }
    function RW(l, f) {
      var h = [], w = {
        status: "pending",
        value: null,
        reason: null,
        then: function(R) {
          h.push(R);
        }
      };
      return l.then(
        function() {
          w.status = "fulfilled", w.value = f;
          for (var R = 0; R < h.length; R++) (0, h[R])(f);
        },
        function(R) {
          for (w.status = "rejected", w.reason = R, R = 0; R < h.length; R++)
            (0, h[R])(void 0);
        }
      ), w;
    }
    var EO = F.S;
    F.S = function(l, f) {
      sN = Je(), typeof f == "object" && f !== null && typeof f.then == "function" && AW(l, f), EO !== null && EO(l, f);
    };
    var Ml = D(null);
    function Ax() {
      var l = Ml.current;
      return l !== null ? l : sn.pooledCache;
    }
    function Jm(l, f) {
      f === null ? z(Ml, Ml.current) : z(Ml, f.pool);
    }
    function CO() {
      var l = Ax();
      return l === null ? null : { parent: Dn._currentValue, pool: l };
    }
    var nu = Error(r(460)), Rx = Error(r(474)), eg = Error(r(542)), tg = { then: function() {
    } };
    function kO(l) {
      return l = l.status, l === "fulfilled" || l === "rejected";
    }
    function TO(l, f, h) {
      switch (h = l[h], h === void 0 ? l.push(f) : h !== f && (f.then(la, la), f = h), f.status) {
        case "fulfilled":
          return f.value;
        case "rejected":
          throw l = f.reason, RO(l), l;
        default:
          if (typeof f.status == "string") f.then(la, la);
          else {
            if (l = sn, l !== null && 100 < l.shellSuspendCounter)
              throw Error(r(482));
            l = f, l.status = "pending", l.then(
              function(w) {
                if (f.status === "pending") {
                  var R = f;
                  R.status = "fulfilled", R.value = w;
                }
              },
              function(w) {
                if (f.status === "pending") {
                  var R = f;
                  R.status = "rejected", R.reason = w;
                }
              }
            );
          }
          switch (f.status) {
            case "fulfilled":
              return f.value;
            case "rejected":
              throw l = f.reason, RO(l), l;
          }
          throw Pl = f, nu;
      }
    }
    function Nl(l) {
      try {
        var f = l._init;
        return f(l._payload);
      } catch (h) {
        throw h !== null && typeof h == "object" && typeof h.then == "function" ? (Pl = h, nu) : h;
      }
    }
    var Pl = null;
    function AO() {
      if (Pl === null) throw Error(r(459));
      var l = Pl;
      return Pl = null, l;
    }
    function RO(l) {
      if (l === nu || l === eg)
        throw Error(r(483));
    }
    var ru = null, md = 0;
    function ng(l) {
      var f = md;
      return md += 1, ru === null && (ru = []), TO(ru, l, f);
    }
    function gd(l, f) {
      f = f.props.ref, l.ref = f !== void 0 ? f : null;
    }
    function rg(l, f) {
      throw f.$$typeof === m ? Error(r(525)) : (l = Object.prototype.toString.call(f), Error(
        r(
          31,
          l === "[object Object]" ? "object with keys {" + Object.keys(f).join(", ") + "}" : l
        )
      ));
    }
    function OO(l) {
      function f(ce, ae) {
        if (l) {
          var de = ce.deletions;
          de === null ? (ce.deletions = [ae], ce.flags |= 16) : de.push(ae);
        }
      }
      function h(ce, ae) {
        if (!l) return null;
        for (; ae !== null; )
          f(ce, ae), ae = ae.sibling;
        return null;
      }
      function w(ce) {
        for (var ae = /* @__PURE__ */ new Map(); ce !== null; )
          ce.key !== null ? ae.set(ce.key, ce) : ae.set(ce.index, ce), ce = ce.sibling;
        return ae;
      }
      function R(ce, ae) {
        return ce = ua(ce, ae), ce.index = 0, ce.sibling = null, ce;
      }
      function M(ce, ae, de) {
        return ce.index = de, l ? (de = ce.alternate, de !== null ? (de = de.index, de < ae ? (ce.flags |= 67108866, ae) : de) : (ce.flags |= 67108866, ae)) : (ce.flags |= 1048576, ae);
      }
      function q(ce) {
        return l && ce.alternate === null && (ce.flags |= 67108866), ce;
      }
      function Z(ce, ae, de, xe) {
        return ae === null || ae.tag !== 6 ? (ae = yx(de, ce.mode, xe), ae.return = ce, ae) : (ae = R(ae, de), ae.return = ce, ae);
      }
      function re(ce, ae, de, xe) {
        var qe = de.type;
        return qe === b ? ve(
          ce,
          ae,
          de.props.children,
          xe,
          de.key
        ) : ae !== null && (ae.elementType === qe || typeof qe == "object" && qe !== null && qe.$$typeof === P && Nl(qe) === ae.type) ? (ae = R(ae, de.props), gd(ae, de), ae.return = ce, ae) : (ae = Ym(
          de.type,
          de.key,
          de.props,
          null,
          ce.mode,
          xe
        ), gd(ae, de), ae.return = ce, ae);
      }
      function pe(ce, ae, de, xe) {
        return ae === null || ae.tag !== 4 || ae.stateNode.containerInfo !== de.containerInfo || ae.stateNode.implementation !== de.implementation ? (ae = vx(de, ce.mode, xe), ae.return = ce, ae) : (ae = R(ae, de.children || []), ae.return = ce, ae);
      }
      function ve(ce, ae, de, xe, qe) {
        return ae === null || ae.tag !== 7 ? (ae = Tl(
          de,
          ce.mode,
          xe,
          qe
        ), ae.return = ce, ae) : (ae = R(ae, de), ae.return = ce, ae);
      }
      function we(ce, ae, de) {
        if (typeof ae == "string" && ae !== "" || typeof ae == "number" || typeof ae == "bigint")
          return ae = yx(
            "" + ae,
            ce.mode,
            de
          ), ae.return = ce, ae;
        if (typeof ae == "object" && ae !== null) {
          switch (ae.$$typeof) {
            case g:
              return de = Ym(
                ae.type,
                ae.key,
                ae.props,
                null,
                ce.mode,
                de
              ), gd(de, ae), de.return = ce, de;
            case y:
              return ae = vx(
                ae,
                ce.mode,
                de
              ), ae.return = ce, ae;
            case P:
              return ae = Nl(ae), we(ce, ae, de);
          }
          if (V(ae) || N(ae))
            return ae = Tl(
              ae,
              ce.mode,
              de,
              null
            ), ae.return = ce, ae;
          if (typeof ae.then == "function")
            return we(ce, ng(ae), de);
          if (ae.$$typeof === _)
            return we(
              ce,
              Qm(ce, ae),
              de
            );
          rg(ce, ae);
        }
        return null;
      }
      function he(ce, ae, de, xe) {
        var qe = ae !== null ? ae.key : null;
        if (typeof de == "string" && de !== "" || typeof de == "number" || typeof de == "bigint")
          return qe !== null ? null : Z(ce, ae, "" + de, xe);
        if (typeof de == "object" && de !== null) {
          switch (de.$$typeof) {
            case g:
              return de.key === qe ? re(ce, ae, de, xe) : null;
            case y:
              return de.key === qe ? pe(ce, ae, de, xe) : null;
            case P:
              return de = Nl(de), he(ce, ae, de, xe);
          }
          if (V(de) || N(de))
            return qe !== null ? null : ve(ce, ae, de, xe, null);
          if (typeof de.then == "function")
            return he(
              ce,
              ae,
              ng(de),
              xe
            );
          if (de.$$typeof === _)
            return he(
              ce,
              ae,
              Qm(ce, de),
              xe
            );
          rg(ce, de);
        }
        return null;
      }
      function ye(ce, ae, de, xe, qe) {
        if (typeof xe == "string" && xe !== "" || typeof xe == "number" || typeof xe == "bigint")
          return ce = ce.get(de) || null, Z(ae, ce, "" + xe, qe);
        if (typeof xe == "object" && xe !== null) {
          switch (xe.$$typeof) {
            case g:
              return ce = ce.get(
                xe.key === null ? de : xe.key
              ) || null, re(ae, ce, xe, qe);
            case y:
              return ce = ce.get(
                xe.key === null ? de : xe.key
              ) || null, pe(ae, ce, xe, qe);
            case P:
              return xe = Nl(xe), ye(
                ce,
                ae,
                de,
                xe,
                qe
              );
          }
          if (V(xe) || N(xe))
            return ce = ce.get(de) || null, ve(ae, ce, xe, qe, null);
          if (typeof xe.then == "function")
            return ye(
              ce,
              ae,
              de,
              ng(xe),
              qe
            );
          if (xe.$$typeof === _)
            return ye(
              ce,
              ae,
              de,
              Qm(ae, xe),
              qe
            );
          rg(ae, xe);
        }
        return null;
      }
      function Fe(ce, ae, de, xe) {
        for (var qe = null, jt = null, Be = ae, dt = ae = 0, kt = null; Be !== null && dt < de.length; dt++) {
          Be.index > dt ? (kt = Be, Be = null) : kt = Be.sibling;
          var Dt = he(
            ce,
            Be,
            de[dt],
            xe
          );
          if (Dt === null) {
            Be === null && (Be = kt);
            break;
          }
          l && Be && Dt.alternate === null && f(ce, Be), ae = M(Dt, ae, dt), jt === null ? qe = Dt : jt.sibling = Dt, jt = Dt, Be = kt;
        }
        if (dt === de.length)
          return h(ce, Be), At && fa(ce, dt), qe;
        if (Be === null) {
          for (; dt < de.length; dt++)
            Be = we(ce, de[dt], xe), Be !== null && (ae = M(
              Be,
              ae,
              dt
            ), jt === null ? qe = Be : jt.sibling = Be, jt = Be);
          return At && fa(ce, dt), qe;
        }
        for (Be = w(Be); dt < de.length; dt++)
          kt = ye(
            Be,
            ce,
            dt,
            de[dt],
            xe
          ), kt !== null && (l && kt.alternate !== null && Be.delete(
            kt.key === null ? dt : kt.key
          ), ae = M(
            kt,
            ae,
            dt
          ), jt === null ? qe = kt : jt.sibling = kt, jt = kt);
        return l && Be.forEach(function($s) {
          return f(ce, $s);
        }), At && fa(ce, dt), qe;
      }
      function et(ce, ae, de, xe) {
        if (de == null) throw Error(r(151));
        for (var qe = null, jt = null, Be = ae, dt = ae = 0, kt = null, Dt = de.next(); Be !== null && !Dt.done; dt++, Dt = de.next()) {
          Be.index > dt ? (kt = Be, Be = null) : kt = Be.sibling;
          var $s = he(ce, Be, Dt.value, xe);
          if ($s === null) {
            Be === null && (Be = kt);
            break;
          }
          l && Be && $s.alternate === null && f(ce, Be), ae = M($s, ae, dt), jt === null ? qe = $s : jt.sibling = $s, jt = $s, Be = kt;
        }
        if (Dt.done)
          return h(ce, Be), At && fa(ce, dt), qe;
        if (Be === null) {
          for (; !Dt.done; dt++, Dt = de.next())
            Dt = we(ce, Dt.value, xe), Dt !== null && (ae = M(Dt, ae, dt), jt === null ? qe = Dt : jt.sibling = Dt, jt = Dt);
          return At && fa(ce, dt), qe;
        }
        for (Be = w(Be); !Dt.done; dt++, Dt = de.next())
          Dt = ye(Be, ce, dt, Dt.value, xe), Dt !== null && (l && Dt.alternate !== null && Be.delete(Dt.key === null ? dt : Dt.key), ae = M(Dt, ae, dt), jt === null ? qe = Dt : jt.sibling = Dt, jt = Dt);
        return l && Be.forEach(function(zG) {
          return f(ce, zG);
        }), At && fa(ce, dt), qe;
      }
      function tn(ce, ae, de, xe) {
        if (typeof de == "object" && de !== null && de.type === b && de.key === null && (de = de.props.children), typeof de == "object" && de !== null) {
          switch (de.$$typeof) {
            case g:
              e: {
                for (var qe = de.key; ae !== null; ) {
                  if (ae.key === qe) {
                    if (qe = de.type, qe === b) {
                      if (ae.tag === 7) {
                        h(
                          ce,
                          ae.sibling
                        ), xe = R(
                          ae,
                          de.props.children
                        ), xe.return = ce, ce = xe;
                        break e;
                      }
                    } else if (ae.elementType === qe || typeof qe == "object" && qe !== null && qe.$$typeof === P && Nl(qe) === ae.type) {
                      h(
                        ce,
                        ae.sibling
                      ), xe = R(ae, de.props), gd(xe, de), xe.return = ce, ce = xe;
                      break e;
                    }
                    h(ce, ae);
                    break;
                  } else f(ce, ae);
                  ae = ae.sibling;
                }
                de.type === b ? (xe = Tl(
                  de.props.children,
                  ce.mode,
                  xe,
                  de.key
                ), xe.return = ce, ce = xe) : (xe = Ym(
                  de.type,
                  de.key,
                  de.props,
                  null,
                  ce.mode,
                  xe
                ), gd(xe, de), xe.return = ce, ce = xe);
              }
              return q(ce);
            case y:
              e: {
                for (qe = de.key; ae !== null; ) {
                  if (ae.key === qe)
                    if (ae.tag === 4 && ae.stateNode.containerInfo === de.containerInfo && ae.stateNode.implementation === de.implementation) {
                      h(
                        ce,
                        ae.sibling
                      ), xe = R(ae, de.children || []), xe.return = ce, ce = xe;
                      break e;
                    } else {
                      h(ce, ae);
                      break;
                    }
                  else f(ce, ae);
                  ae = ae.sibling;
                }
                xe = vx(de, ce.mode, xe), xe.return = ce, ce = xe;
              }
              return q(ce);
            case P:
              return de = Nl(de), tn(
                ce,
                ae,
                de,
                xe
              );
          }
          if (V(de))
            return Fe(
              ce,
              ae,
              de,
              xe
            );
          if (N(de)) {
            if (qe = N(de), typeof qe != "function") throw Error(r(150));
            return de = qe.call(de), et(
              ce,
              ae,
              de,
              xe
            );
          }
          if (typeof de.then == "function")
            return tn(
              ce,
              ae,
              ng(de),
              xe
            );
          if (de.$$typeof === _)
            return tn(
              ce,
              ae,
              Qm(ce, de),
              xe
            );
          rg(ce, de);
        }
        return typeof de == "string" && de !== "" || typeof de == "number" || typeof de == "bigint" ? (de = "" + de, ae !== null && ae.tag === 6 ? (h(ce, ae.sibling), xe = R(ae, de), xe.return = ce, ce = xe) : (h(ce, ae), xe = yx(de, ce.mode, xe), xe.return = ce, ce = xe), q(ce)) : h(ce, ae);
      }
      return function(ce, ae, de, xe) {
        try {
          md = 0;
          var qe = tn(
            ce,
            ae,
            de,
            xe
          );
          return ru = null, qe;
        } catch (Be) {
          if (Be === nu || Be === eg) throw Be;
          var jt = Yr(29, Be, null, ce.mode);
          return jt.lanes = xe, jt.return = ce, jt;
        }
      };
    }
    var Il = OO(!0), MO = OO(!1), vs = !1;
    function Ox(l) {
      l.updateQueue = {
        baseState: l.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null
      };
    }
    function Mx(l, f) {
      l = l.updateQueue, f.updateQueue === l && (f.updateQueue = {
        baseState: l.baseState,
        firstBaseUpdate: l.firstBaseUpdate,
        lastBaseUpdate: l.lastBaseUpdate,
        shared: l.shared,
        callbacks: null
      });
    }
    function bs(l) {
      return { lane: l, tag: 0, payload: null, callback: null, next: null };
    }
    function xs(l, f, h) {
      var w = l.updateQueue;
      if (w === null) return null;
      if (w = w.shared, (zt & 2) !== 0) {
        var R = w.pending;
        return R === null ? f.next = f : (f.next = R.next, R.next = f), w.pending = f, f = Km(l), hO(l, null, h), f;
      }
      return Gm(l, w, f, h), Km(l);
    }
    function yd(l, f, h) {
      if (f = f.updateQueue, f !== null && (f = f.shared, (h & 4194048) !== 0)) {
        var w = f.lanes;
        w &= l.pendingLanes, h |= w, f.lanes = h, km(l, h);
      }
    }
    function Nx(l, f) {
      var h = l.updateQueue, w = l.alternate;
      if (w !== null && (w = w.updateQueue, h === w)) {
        var R = null, M = null;
        if (h = h.firstBaseUpdate, h !== null) {
          do {
            var q = {
              lane: h.lane,
              tag: h.tag,
              payload: h.payload,
              callback: null,
              next: null
            };
            M === null ? R = M = q : M = M.next = q, h = h.next;
          } while (h !== null);
          M === null ? R = M = f : M = M.next = f;
        } else R = M = f;
        h = {
          baseState: w.baseState,
          firstBaseUpdate: R,
          lastBaseUpdate: M,
          shared: w.shared,
          callbacks: w.callbacks
        }, l.updateQueue = h;
        return;
      }
      l = h.lastBaseUpdate, l === null ? h.firstBaseUpdate = f : l.next = f, h.lastBaseUpdate = f;
    }
    var Px = !1;
    function vd() {
      if (Px) {
        var l = tu;
        if (l !== null) throw l;
      }
    }
    function bd(l, f, h, w) {
      Px = !1;
      var R = l.updateQueue;
      vs = !1;
      var M = R.firstBaseUpdate, q = R.lastBaseUpdate, Z = R.shared.pending;
      if (Z !== null) {
        R.shared.pending = null;
        var re = Z, pe = re.next;
        re.next = null, q === null ? M = pe : q.next = pe, q = re;
        var ve = l.alternate;
        ve !== null && (ve = ve.updateQueue, Z = ve.lastBaseUpdate, Z !== q && (Z === null ? ve.firstBaseUpdate = pe : Z.next = pe, ve.lastBaseUpdate = re));
      }
      if (M !== null) {
        var we = R.baseState;
        q = 0, ve = pe = re = null, Z = M;
        do {
          var he = Z.lane & -536870913, ye = he !== Z.lane;
          if (ye ? (Ct & he) === he : (w & he) === he) {
            he !== 0 && he === eu && (Px = !0), ve !== null && (ve = ve.next = {
              lane: 0,
              tag: Z.tag,
              payload: Z.payload,
              callback: null,
              next: null
            });
            e: {
              var Fe = l, et = Z;
              he = f;
              var tn = h;
              switch (et.tag) {
                case 1:
                  if (Fe = et.payload, typeof Fe == "function") {
                    we = Fe.call(tn, we, he);
                    break e;
                  }
                  we = Fe;
                  break e;
                case 3:
                  Fe.flags = Fe.flags & -65537 | 128;
                case 0:
                  if (Fe = et.payload, he = typeof Fe == "function" ? Fe.call(tn, we, he) : Fe, he == null) break e;
                  we = p({}, we, he);
                  break e;
                case 2:
                  vs = !0;
              }
            }
            he = Z.callback, he !== null && (l.flags |= 64, ye && (l.flags |= 8192), ye = R.callbacks, ye === null ? R.callbacks = [he] : ye.push(he));
          } else
            ye = {
              lane: he,
              tag: Z.tag,
              payload: Z.payload,
              callback: Z.callback,
              next: null
            }, ve === null ? (pe = ve = ye, re = we) : ve = ve.next = ye, q |= he;
          if (Z = Z.next, Z === null) {
            if (Z = R.shared.pending, Z === null)
              break;
            ye = Z, Z = ye.next, ye.next = null, R.lastBaseUpdate = ye, R.shared.pending = null;
          }
        } while (!0);
        ve === null && (re = we), R.baseState = re, R.firstBaseUpdate = pe, R.lastBaseUpdate = ve, M === null && (R.shared.lanes = 0), Cs |= q, l.lanes = q, l.memoizedState = we;
      }
    }
    function NO(l, f) {
      if (typeof l != "function")
        throw Error(r(191, l));
      l.call(f);
    }
    function PO(l, f) {
      var h = l.callbacks;
      if (h !== null)
        for (l.callbacks = null, l = 0; l < h.length; l++)
          NO(h[l], f);
    }
    var ou = D(null), og = D(0);
    function IO(l, f) {
      l = Sa, z(og, l), z(ou, f), Sa = l | f.baseLanes;
    }
    function Ix() {
      z(og, Sa), z(ou, ou.current);
    }
    function $x() {
      Sa = og.current, G(ou), G(og);
    }
    var Xr = D(null), _o = null;
    function ws(l) {
      var f = l.alternate;
      z(Nn, Nn.current & 1), z(Xr, l), _o === null && (f === null || ou.current !== null || f.memoizedState !== null) && (_o = l);
    }
    function jx(l) {
      z(Nn, Nn.current), z(Xr, l), _o === null && (_o = l);
    }
    function $O(l) {
      l.tag === 22 ? (z(Nn, Nn.current), z(Xr, l), _o === null && (_o = l)) : Ss();
    }
    function Ss() {
      z(Nn, Nn.current), z(Xr, Xr.current);
    }
    function Zr(l) {
      G(Xr), _o === l && (_o = null), G(Nn);
    }
    var Nn = D(0);
    function ig(l) {
      for (var f = l; f !== null; ) {
        if (f.tag === 13) {
          var h = f.memoizedState;
          if (h !== null && (h = h.dehydrated, h === null || Uw(h) || Vw(h)))
            return f;
        } else if (f.tag === 19 && (f.memoizedProps.revealOrder === "forwards" || f.memoizedProps.revealOrder === "backwards" || f.memoizedProps.revealOrder === "unstable_legacy-backwards" || f.memoizedProps.revealOrder === "together")) {
          if ((f.flags & 128) !== 0) return f;
        } else if (f.child !== null) {
          f.child.return = f, f = f.child;
          continue;
        }
        if (f === l) break;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === l) return null;
          f = f.return;
        }
        f.sibling.return = f.return, f = f.sibling;
      }
      return null;
    }
    var ha = 0, lt = null, Jt = null, Fn = null, ag = !1, iu = !1, $l = !1, sg = 0, xd = 0, au = null, OW = 0;
    function kn() {
      throw Error(r(321));
    }
    function Dx(l, f) {
      if (f === null) return !1;
      for (var h = 0; h < f.length && h < l.length; h++)
        if (!Kr(l[h], f[h])) return !1;
      return !0;
    }
    function Fx(l, f, h, w, R, M) {
      return ha = M, lt = f, f.memoizedState = null, f.updateQueue = null, f.lanes = 0, F.H = l === null || l.memoizedState === null ? vM : Jx, $l = !1, M = h(w, R), $l = !1, iu && (M = DO(
        f,
        h,
        w,
        R
      )), jO(l), M;
    }
    function jO(l) {
      F.H = _d;
      var f = Jt !== null && Jt.next !== null;
      if (ha = 0, Fn = Jt = lt = null, ag = !1, xd = 0, au = null, f) throw Error(r(300));
      l === null || Ln || (l = l.dependencies, l !== null && Zm(l) && (Ln = !0));
    }
    function DO(l, f, h, w) {
      lt = l;
      var R = 0;
      do {
        if (iu && (au = null), xd = 0, iu = !1, 25 <= R) throw Error(r(301));
        if (R += 1, Fn = Jt = null, l.updateQueue != null) {
          var M = l.updateQueue;
          M.lastEffect = null, M.events = null, M.stores = null, M.memoCache != null && (M.memoCache.index = 0);
        }
        F.H = bM, M = f(h, w);
      } while (iu);
      return M;
    }
    function MW() {
      var l = F.H, f = l.useState()[0];
      return f = typeof f.then == "function" ? wd(f) : f, l = l.useState()[0], (Jt !== null ? Jt.memoizedState : null) !== l && (lt.flags |= 1024), f;
    }
    function Lx() {
      var l = sg !== 0;
      return sg = 0, l;
    }
    function zx(l, f, h) {
      f.updateQueue = l.updateQueue, f.flags &= -2053, l.lanes &= ~h;
    }
    function Bx(l) {
      if (ag) {
        for (l = l.memoizedState; l !== null; ) {
          var f = l.queue;
          f !== null && (f.pending = null), l = l.next;
        }
        ag = !1;
      }
      ha = 0, Fn = Jt = lt = null, iu = !1, xd = sg = 0, au = null;
    }
    function Er() {
      var l = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Fn === null ? lt.memoizedState = Fn = l : Fn = Fn.next = l, Fn;
    }
    function Pn() {
      if (Jt === null) {
        var l = lt.alternate;
        l = l !== null ? l.memoizedState : null;
      } else l = Jt.next;
      var f = Fn === null ? lt.memoizedState : Fn.next;
      if (f !== null)
        Fn = f, Jt = l;
      else {
        if (l === null)
          throw lt.alternate === null ? Error(r(467)) : Error(r(310));
        Jt = l, l = {
          memoizedState: Jt.memoizedState,
          baseState: Jt.baseState,
          baseQueue: Jt.baseQueue,
          queue: Jt.queue,
          next: null
        }, Fn === null ? lt.memoizedState = Fn = l : Fn = Fn.next = l;
      }
      return Fn;
    }
    function lg() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }
    function wd(l) {
      var f = xd;
      return xd += 1, au === null && (au = []), l = TO(au, l, f), f = lt, (Fn === null ? f.memoizedState : Fn.next) === null && (f = f.alternate, F.H = f === null || f.memoizedState === null ? vM : Jx), l;
    }
    function cg(l) {
      if (l !== null && typeof l == "object") {
        if (typeof l.then == "function") return wd(l);
        if (l.$$typeof === _) return or(l);
      }
      throw Error(r(438, String(l)));
    }
    function Ux(l) {
      var f = null, h = lt.updateQueue;
      if (h !== null && (f = h.memoCache), f == null) {
        var w = lt.alternate;
        w !== null && (w = w.updateQueue, w !== null && (w = w.memoCache, w != null && (f = {
          data: w.data.map(function(R) {
            return R.slice();
          }),
          index: 0
        })));
      }
      if (f == null && (f = { data: [], index: 0 }), h === null && (h = lg(), lt.updateQueue = h), h.memoCache = f, h = f.data[f.index], h === void 0)
        for (h = f.data[f.index] = Array(l), w = 0; w < l; w++)
          h[w] = $;
      return f.index++, h;
    }
    function ma(l, f) {
      return typeof f == "function" ? f(l) : f;
    }
    function ug(l) {
      var f = Pn();
      return Vx(f, Jt, l);
    }
    function Vx(l, f, h) {
      var w = l.queue;
      if (w === null) throw Error(r(311));
      w.lastRenderedReducer = h;
      var R = l.baseQueue, M = w.pending;
      if (M !== null) {
        if (R !== null) {
          var q = R.next;
          R.next = M.next, M.next = q;
        }
        f.baseQueue = R = M, w.pending = null;
      }
      if (M = l.baseState, R === null) l.memoizedState = M;
      else {
        f = R.next;
        var Z = q = null, re = null, pe = f, ve = !1;
        do {
          var we = pe.lane & -536870913;
          if (we !== pe.lane ? (Ct & we) === we : (ha & we) === we) {
            var he = pe.revertLane;
            if (he === 0)
              re !== null && (re = re.next = {
                lane: 0,
                revertLane: 0,
                gesture: null,
                action: pe.action,
                hasEagerState: pe.hasEagerState,
                eagerState: pe.eagerState,
                next: null
              }), we === eu && (ve = !0);
            else if ((ha & he) === he) {
              pe = pe.next, he === eu && (ve = !0);
              continue;
            } else
              we = {
                lane: 0,
                revertLane: pe.revertLane,
                gesture: null,
                action: pe.action,
                hasEagerState: pe.hasEagerState,
                eagerState: pe.eagerState,
                next: null
              }, re === null ? (Z = re = we, q = M) : re = re.next = we, lt.lanes |= he, Cs |= he;
            we = pe.action, $l && h(M, we), M = pe.hasEagerState ? pe.eagerState : h(M, we);
          } else
            he = {
              lane: we,
              revertLane: pe.revertLane,
              gesture: pe.gesture,
              action: pe.action,
              hasEagerState: pe.hasEagerState,
              eagerState: pe.eagerState,
              next: null
            }, re === null ? (Z = re = he, q = M) : re = re.next = he, lt.lanes |= we, Cs |= we;
          pe = pe.next;
        } while (pe !== null && pe !== f);
        if (re === null ? q = M : re.next = Z, !Kr(M, l.memoizedState) && (Ln = !0, ve && (h = tu, h !== null)))
          throw h;
        l.memoizedState = M, l.baseState = q, l.baseQueue = re, w.lastRenderedState = M;
      }
      return R === null && (w.lanes = 0), [l.memoizedState, w.dispatch];
    }
    function Hx(l) {
      var f = Pn(), h = f.queue;
      if (h === null) throw Error(r(311));
      h.lastRenderedReducer = l;
      var w = h.dispatch, R = h.pending, M = f.memoizedState;
      if (R !== null) {
        h.pending = null;
        var q = R = R.next;
        do
          M = l(M, q.action), q = q.next;
        while (q !== R);
        Kr(M, f.memoizedState) || (Ln = !0), f.memoizedState = M, f.baseQueue === null && (f.baseState = M), h.lastRenderedState = M;
      }
      return [M, w];
    }
    function FO(l, f, h) {
      var w = lt, R = Pn(), M = At;
      if (M) {
        if (h === void 0) throw Error(r(407));
        h = h();
      } else h = f();
      var q = !Kr(
        (Jt || R).memoizedState,
        h
      );
      if (q && (R.memoizedState = h, Ln = !0), R = R.queue, Gx(BO.bind(null, w, R, l), [
        l
      ]), R.getSnapshot !== f || q || Fn !== null && Fn.memoizedState.tag & 1) {
        if (w.flags |= 2048, su(
          9,
          { destroy: void 0 },
          zO.bind(
            null,
            w,
            R,
            h,
            f
          ),
          null
        ), sn === null) throw Error(r(349));
        M || (ha & 127) !== 0 || LO(w, f, h);
      }
      return h;
    }
    function LO(l, f, h) {
      l.flags |= 16384, l = { getSnapshot: f, value: h }, f = lt.updateQueue, f === null ? (f = lg(), lt.updateQueue = f, f.stores = [l]) : (h = f.stores, h === null ? f.stores = [l] : h.push(l));
    }
    function zO(l, f, h, w) {
      f.value = h, f.getSnapshot = w, UO(f) && VO(l);
    }
    function BO(l, f, h) {
      return h(function() {
        UO(f) && VO(l);
      });
    }
    function UO(l) {
      var f = l.getSnapshot;
      l = l.value;
      try {
        var h = f();
        return !Kr(l, h);
      } catch {
        return !0;
      }
    }
    function VO(l) {
      var f = kl(l, 2);
      f !== null && Fr(f, l, 2);
    }
    function qx(l) {
      var f = Er();
      if (typeof l == "function") {
        var h = l;
        if (l = h(), $l) {
          xn(!0);
          try {
            h();
          } finally {
            xn(!1);
          }
        }
      }
      return f.memoizedState = f.baseState = l, f.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: ma,
        lastRenderedState: l
      }, f;
    }
    function HO(l, f, h, w) {
      return l.baseState = h, Vx(
        l,
        Jt,
        typeof w == "function" ? w : ma
      );
    }
    function NW(l, f, h, w, R) {
      if (pg(l)) throw Error(r(485));
      if (l = f.action, l !== null) {
        var M = {
          payload: R,
          action: l,
          next: null,
          isTransition: !0,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function(q) {
            M.listeners.push(q);
          }
        };
        F.T !== null ? h(!0) : M.isTransition = !1, w(M), h = f.pending, h === null ? (M.next = f.pending = M, qO(f, M)) : (M.next = h.next, f.pending = h.next = M);
      }
    }
    function qO(l, f) {
      var h = f.action, w = f.payload, R = l.state;
      if (f.isTransition) {
        var M = F.T, q = {};
        F.T = q;
        try {
          var Z = h(R, w), re = F.S;
          re !== null && re(q, Z), WO(l, f, Z);
        } catch (pe) {
          Wx(l, f, pe);
        } finally {
          M !== null && q.types !== null && (M.types = q.types), F.T = M;
        }
      } else
        try {
          M = h(R, w), WO(l, f, M);
        } catch (pe) {
          Wx(l, f, pe);
        }
    }
    function WO(l, f, h) {
      h !== null && typeof h == "object" && typeof h.then == "function" ? h.then(
        function(w) {
          GO(l, f, w);
        },
        function(w) {
          return Wx(l, f, w);
        }
      ) : GO(l, f, h);
    }
    function GO(l, f, h) {
      f.status = "fulfilled", f.value = h, KO(f), l.state = h, f = l.pending, f !== null && (h = f.next, h === f ? l.pending = null : (h = h.next, f.next = h, qO(l, h)));
    }
    function Wx(l, f, h) {
      var w = l.pending;
      if (l.pending = null, w !== null) {
        w = w.next;
        do
          f.status = "rejected", f.reason = h, KO(f), f = f.next;
        while (f !== w);
      }
      l.action = null;
    }
    function KO(l) {
      l = l.listeners;
      for (var f = 0; f < l.length; f++) (0, l[f])();
    }
    function YO(l, f) {
      return f;
    }
    function XO(l, f) {
      if (At) {
        var h = sn.formState;
        if (h !== null) {
          e: {
            var w = lt;
            if (At) {
              if (mn) {
                t: {
                  for (var R = mn, M = So; R.nodeType !== 8; ) {
                    if (!M) {
                      R = null;
                      break t;
                    }
                    if (R = Eo(
                      R.nextSibling
                    ), R === null) {
                      R = null;
                      break t;
                    }
                  }
                  M = R.data, R = M === "F!" || M === "F" ? R : null;
                }
                if (R) {
                  mn = Eo(
                    R.nextSibling
                  ), w = R.data === "F!";
                  break e;
                }
              }
              gs(w);
            }
            w = !1;
          }
          w && (f = h[0]);
        }
      }
      return h = Er(), h.memoizedState = h.baseState = f, w = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: YO,
        lastRenderedState: f
      }, h.queue = w, h = mM.bind(
        null,
        lt,
        w
      ), w.dispatch = h, w = qx(!1), M = Qx.bind(
        null,
        lt,
        !1,
        w.queue
      ), w = Er(), R = {
        state: f,
        dispatch: null,
        action: l,
        pending: null
      }, w.queue = R, h = NW.bind(
        null,
        lt,
        R,
        M,
        h
      ), R.dispatch = h, w.memoizedState = l, [f, h, !1];
    }
    function ZO(l) {
      var f = Pn();
      return QO(f, Jt, l);
    }
    function QO(l, f, h) {
      if (f = Vx(
        l,
        f,
        YO
      )[0], l = ug(ma)[0], typeof f == "object" && f !== null && typeof f.then == "function")
        try {
          var w = wd(f);
        } catch (q) {
          throw q === nu ? eg : q;
        }
      else w = f;
      f = Pn();
      var R = f.queue, M = R.dispatch;
      return h !== f.memoizedState && (lt.flags |= 2048, su(
        9,
        { destroy: void 0 },
        PW.bind(null, R, h),
        null
      )), [w, M, l];
    }
    function PW(l, f) {
      l.action = f;
    }
    function JO(l) {
      var f = Pn(), h = Jt;
      if (h !== null)
        return QO(f, h, l);
      Pn(), f = f.memoizedState, h = Pn();
      var w = h.queue.dispatch;
      return h.memoizedState = l, [f, w, !1];
    }
    function su(l, f, h, w) {
      return l = { tag: l, create: h, deps: w, inst: f, next: null }, f = lt.updateQueue, f === null && (f = lg(), lt.updateQueue = f), h = f.lastEffect, h === null ? f.lastEffect = l.next = l : (w = h.next, h.next = l, l.next = w, f.lastEffect = l), l;
    }
    function eM() {
      return Pn().memoizedState;
    }
    function fg(l, f, h, w) {
      var R = Er();
      lt.flags |= l, R.memoizedState = su(
        1 | f,
        { destroy: void 0 },
        h,
        w === void 0 ? null : w
      );
    }
    function dg(l, f, h, w) {
      var R = Pn();
      w = w === void 0 ? null : w;
      var M = R.memoizedState.inst;
      Jt !== null && w !== null && Dx(w, Jt.memoizedState.deps) ? R.memoizedState = su(f, M, h, w) : (lt.flags |= l, R.memoizedState = su(
        1 | f,
        M,
        h,
        w
      ));
    }
    function tM(l, f) {
      fg(8390656, 8, l, f);
    }
    function Gx(l, f) {
      dg(2048, 8, l, f);
    }
    function IW(l) {
      lt.flags |= 4;
      var f = lt.updateQueue;
      if (f === null)
        f = lg(), lt.updateQueue = f, f.events = [l];
      else {
        var h = f.events;
        h === null ? f.events = [l] : h.push(l);
      }
    }
    function nM(l) {
      var f = Pn().memoizedState;
      return IW({ ref: f, nextImpl: l }), function() {
        if ((zt & 2) !== 0) throw Error(r(440));
        return f.impl.apply(void 0, arguments);
      };
    }
    function rM(l, f) {
      return dg(4, 2, l, f);
    }
    function oM(l, f) {
      return dg(4, 4, l, f);
    }
    function iM(l, f) {
      if (typeof f == "function") {
        l = l();
        var h = f(l);
        return function() {
          typeof h == "function" ? h() : f(null);
        };
      }
      if (f != null)
        return l = l(), f.current = l, function() {
          f.current = null;
        };
    }
    function aM(l, f, h) {
      h = h != null ? h.concat([l]) : null, dg(4, 4, iM.bind(null, f, l), h);
    }
    function Kx() {
    }
    function sM(l, f) {
      var h = Pn();
      f = f === void 0 ? null : f;
      var w = h.memoizedState;
      return f !== null && Dx(f, w[1]) ? w[0] : (h.memoizedState = [l, f], l);
    }
    function lM(l, f) {
      var h = Pn();
      f = f === void 0 ? null : f;
      var w = h.memoizedState;
      if (f !== null && Dx(f, w[1]))
        return w[0];
      if (w = l(), $l) {
        xn(!0);
        try {
          l();
        } finally {
          xn(!1);
        }
      }
      return h.memoizedState = [w, f], w;
    }
    function Yx(l, f, h) {
      return h === void 0 || (ha & 1073741824) !== 0 && (Ct & 261930) === 0 ? l.memoizedState = f : (l.memoizedState = h, l = cN(), lt.lanes |= l, Cs |= l, h);
    }
    function cM(l, f, h, w) {
      return Kr(h, f) ? h : ou.current !== null ? (l = Yx(l, h, w), Kr(l, f) || (Ln = !0), l) : (ha & 42) === 0 || (ha & 1073741824) !== 0 && (Ct & 261930) === 0 ? (Ln = !0, l.memoizedState = h) : (l = cN(), lt.lanes |= l, Cs |= l, f);
    }
    function uM(l, f, h, w, R) {
      var M = K.p;
      K.p = M !== 0 && 8 > M ? M : 8;
      var q = F.T, Z = {};
      F.T = Z, Qx(l, !1, f, h);
      try {
        var re = R(), pe = F.S;
        if (pe !== null && pe(Z, re), re !== null && typeof re == "object" && typeof re.then == "function") {
          var ve = RW(
            re,
            w
          );
          Sd(
            l,
            f,
            ve,
            eo(l)
          );
        } else
          Sd(
            l,
            f,
            w,
            eo(l)
          );
      } catch (we) {
        Sd(
          l,
          f,
          { then: function() {
          }, status: "rejected", reason: we },
          eo()
        );
      } finally {
        K.p = M, q !== null && Z.types !== null && (q.types = Z.types), F.T = q;
      }
    }
    function $W() {
    }
    function Xx(l, f, h, w) {
      if (l.tag !== 5) throw Error(r(476));
      var R = fM(l).queue;
      uM(
        l,
        R,
        f,
        W,
        h === null ? $W : function() {
          return dM(l), h(w);
        }
      );
    }
    function fM(l) {
      var f = l.memoizedState;
      if (f !== null) return f;
      f = {
        memoizedState: W,
        baseState: W,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: ma,
          lastRenderedState: W
        },
        next: null
      };
      var h = {};
      return f.next = {
        memoizedState: h,
        baseState: h,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: ma,
          lastRenderedState: h
        },
        next: null
      }, l.memoizedState = f, l = l.alternate, l !== null && (l.memoizedState = f), f;
    }
    function dM(l) {
      var f = fM(l);
      f.next === null && (f = l.alternate.memoizedState), Sd(
        l,
        f.next.queue,
        {},
        eo()
      );
    }
    function Zx() {
      return or(Ld);
    }
    function pM() {
      return Pn().memoizedState;
    }
    function hM() {
      return Pn().memoizedState;
    }
    function jW(l) {
      for (var f = l.return; f !== null; ) {
        switch (f.tag) {
          case 24:
          case 3:
            var h = eo();
            l = bs(h);
            var w = xs(f, l, h);
            w !== null && (Fr(w, f, h), yd(w, f, h)), f = { cache: kx() }, l.payload = f;
            return;
        }
        f = f.return;
      }
    }
    function DW(l, f, h) {
      var w = eo();
      h = {
        lane: w,
        revertLane: 0,
        gesture: null,
        action: h,
        hasEagerState: !1,
        eagerState: null,
        next: null
      }, pg(l) ? gM(f, h) : (h = mx(l, f, h, w), h !== null && (Fr(h, l, w), yM(h, f, w)));
    }
    function mM(l, f, h) {
      var w = eo();
      Sd(l, f, h, w);
    }
    function Sd(l, f, h, w) {
      var R = {
        lane: w,
        revertLane: 0,
        gesture: null,
        action: h,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (pg(l)) gM(f, R);
      else {
        var M = l.alternate;
        if (l.lanes === 0 && (M === null || M.lanes === 0) && (M = f.lastRenderedReducer, M !== null))
          try {
            var q = f.lastRenderedState, Z = M(q, h);
            if (R.hasEagerState = !0, R.eagerState = Z, Kr(Z, q))
              return Gm(l, f, R, 0), sn === null && Wm(), !1;
          } catch {
          }
        if (h = mx(l, f, R, w), h !== null)
          return Fr(h, l, w), yM(h, f, w), !0;
      }
      return !1;
    }
    function Qx(l, f, h, w) {
      if (w = {
        lane: 2,
        revertLane: Ow(),
        gesture: null,
        action: w,
        hasEagerState: !1,
        eagerState: null,
        next: null
      }, pg(l)) {
        if (f) throw Error(r(479));
      } else
        f = mx(
          l,
          h,
          w,
          2
        ), f !== null && Fr(f, l, 2);
    }
    function pg(l) {
      var f = l.alternate;
      return l === lt || f !== null && f === lt;
    }
    function gM(l, f) {
      iu = ag = !0;
      var h = l.pending;
      h === null ? f.next = f : (f.next = h.next, h.next = f), l.pending = f;
    }
    function yM(l, f, h) {
      if ((h & 4194048) !== 0) {
        var w = f.lanes;
        w &= l.pendingLanes, h |= w, f.lanes = h, km(l, h);
      }
    }
    var _d = {
      readContext: or,
      use: cg,
      useCallback: kn,
      useContext: kn,
      useEffect: kn,
      useImperativeHandle: kn,
      useLayoutEffect: kn,
      useInsertionEffect: kn,
      useMemo: kn,
      useReducer: kn,
      useRef: kn,
      useState: kn,
      useDebugValue: kn,
      useDeferredValue: kn,
      useTransition: kn,
      useSyncExternalStore: kn,
      useId: kn,
      useHostTransitionStatus: kn,
      useFormState: kn,
      useActionState: kn,
      useOptimistic: kn,
      useMemoCache: kn,
      useCacheRefresh: kn
    };
    _d.useEffectEvent = kn;
    var vM = {
      readContext: or,
      use: cg,
      useCallback: function(l, f) {
        return Er().memoizedState = [
          l,
          f === void 0 ? null : f
        ], l;
      },
      useContext: or,
      useEffect: tM,
      useImperativeHandle: function(l, f, h) {
        h = h != null ? h.concat([l]) : null, fg(
          4194308,
          4,
          iM.bind(null, f, l),
          h
        );
      },
      useLayoutEffect: function(l, f) {
        return fg(4194308, 4, l, f);
      },
      useInsertionEffect: function(l, f) {
        fg(4, 2, l, f);
      },
      useMemo: function(l, f) {
        var h = Er();
        f = f === void 0 ? null : f;
        var w = l();
        if ($l) {
          xn(!0);
          try {
            l();
          } finally {
            xn(!1);
          }
        }
        return h.memoizedState = [w, f], w;
      },
      useReducer: function(l, f, h) {
        var w = Er();
        if (h !== void 0) {
          var R = h(f);
          if ($l) {
            xn(!0);
            try {
              h(f);
            } finally {
              xn(!1);
            }
          }
        } else R = f;
        return w.memoizedState = w.baseState = R, l = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: l,
          lastRenderedState: R
        }, w.queue = l, l = l.dispatch = DW.bind(
          null,
          lt,
          l
        ), [w.memoizedState, l];
      },
      useRef: function(l) {
        var f = Er();
        return l = { current: l }, f.memoizedState = l;
      },
      useState: function(l) {
        l = qx(l);
        var f = l.queue, h = mM.bind(null, lt, f);
        return f.dispatch = h, [l.memoizedState, h];
      },
      useDebugValue: Kx,
      useDeferredValue: function(l, f) {
        var h = Er();
        return Yx(h, l, f);
      },
      useTransition: function() {
        var l = qx(!1);
        return l = uM.bind(
          null,
          lt,
          l.queue,
          !0,
          !1
        ), Er().memoizedState = l, [!1, l];
      },
      useSyncExternalStore: function(l, f, h) {
        var w = lt, R = Er();
        if (At) {
          if (h === void 0)
            throw Error(r(407));
          h = h();
        } else {
          if (h = f(), sn === null)
            throw Error(r(349));
          (Ct & 127) !== 0 || LO(w, f, h);
        }
        R.memoizedState = h;
        var M = { value: h, getSnapshot: f };
        return R.queue = M, tM(BO.bind(null, w, M, l), [
          l
        ]), w.flags |= 2048, su(
          9,
          { destroy: void 0 },
          zO.bind(
            null,
            w,
            M,
            h,
            f
          ),
          null
        ), h;
      },
      useId: function() {
        var l = Er(), f = sn.identifierPrefix;
        if (At) {
          var h = pi, w = di;
          h = (w & ~(1 << 32 - Mt(w) - 1)).toString(32) + h, f = "_" + f + "R_" + h, h = sg++, 0 < h && (f += "H" + h.toString(32)), f += "_";
        } else
          h = OW++, f = "_" + f + "r_" + h.toString(32) + "_";
        return l.memoizedState = f;
      },
      useHostTransitionStatus: Zx,
      useFormState: XO,
      useActionState: XO,
      useOptimistic: function(l) {
        var f = Er();
        f.memoizedState = f.baseState = l;
        var h = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null
        };
        return f.queue = h, f = Qx.bind(
          null,
          lt,
          !0,
          h
        ), h.dispatch = f, [l, f];
      },
      useMemoCache: Ux,
      useCacheRefresh: function() {
        return Er().memoizedState = jW.bind(
          null,
          lt
        );
      },
      useEffectEvent: function(l) {
        var f = Er(), h = { impl: l };
        return f.memoizedState = h, function() {
          if ((zt & 2) !== 0)
            throw Error(r(440));
          return h.impl.apply(void 0, arguments);
        };
      }
    }, Jx = {
      readContext: or,
      use: cg,
      useCallback: sM,
      useContext: or,
      useEffect: Gx,
      useImperativeHandle: aM,
      useInsertionEffect: rM,
      useLayoutEffect: oM,
      useMemo: lM,
      useReducer: ug,
      useRef: eM,
      useState: function() {
        return ug(ma);
      },
      useDebugValue: Kx,
      useDeferredValue: function(l, f) {
        var h = Pn();
        return cM(
          h,
          Jt.memoizedState,
          l,
          f
        );
      },
      useTransition: function() {
        var l = ug(ma)[0], f = Pn().memoizedState;
        return [
          typeof l == "boolean" ? l : wd(l),
          f
        ];
      },
      useSyncExternalStore: FO,
      useId: pM,
      useHostTransitionStatus: Zx,
      useFormState: ZO,
      useActionState: ZO,
      useOptimistic: function(l, f) {
        var h = Pn();
        return HO(h, Jt, l, f);
      },
      useMemoCache: Ux,
      useCacheRefresh: hM
    };
    Jx.useEffectEvent = nM;
    var bM = {
      readContext: or,
      use: cg,
      useCallback: sM,
      useContext: or,
      useEffect: Gx,
      useImperativeHandle: aM,
      useInsertionEffect: rM,
      useLayoutEffect: oM,
      useMemo: lM,
      useReducer: Hx,
      useRef: eM,
      useState: function() {
        return Hx(ma);
      },
      useDebugValue: Kx,
      useDeferredValue: function(l, f) {
        var h = Pn();
        return Jt === null ? Yx(h, l, f) : cM(
          h,
          Jt.memoizedState,
          l,
          f
        );
      },
      useTransition: function() {
        var l = Hx(ma)[0], f = Pn().memoizedState;
        return [
          typeof l == "boolean" ? l : wd(l),
          f
        ];
      },
      useSyncExternalStore: FO,
      useId: pM,
      useHostTransitionStatus: Zx,
      useFormState: JO,
      useActionState: JO,
      useOptimistic: function(l, f) {
        var h = Pn();
        return Jt !== null ? HO(h, Jt, l, f) : (h.baseState = l, [l, h.queue.dispatch]);
      },
      useMemoCache: Ux,
      useCacheRefresh: hM
    };
    bM.useEffectEvent = nM;
    function ew(l, f, h, w) {
      f = l.memoizedState, h = h(w, f), h = h == null ? f : p({}, f, h), l.memoizedState = h, l.lanes === 0 && (l.updateQueue.baseState = h);
    }
    var tw = {
      enqueueSetState: function(l, f, h) {
        l = l._reactInternals;
        var w = eo(), R = bs(w);
        R.payload = f, h != null && (R.callback = h), f = xs(l, R, w), f !== null && (Fr(f, l, w), yd(f, l, w));
      },
      enqueueReplaceState: function(l, f, h) {
        l = l._reactInternals;
        var w = eo(), R = bs(w);
        R.tag = 1, R.payload = f, h != null && (R.callback = h), f = xs(l, R, w), f !== null && (Fr(f, l, w), yd(f, l, w));
      },
      enqueueForceUpdate: function(l, f) {
        l = l._reactInternals;
        var h = eo(), w = bs(h);
        w.tag = 2, f != null && (w.callback = f), f = xs(l, w, h), f !== null && (Fr(f, l, h), yd(f, l, h));
      }
    };
    function xM(l, f, h, w, R, M, q) {
      return l = l.stateNode, typeof l.shouldComponentUpdate == "function" ? l.shouldComponentUpdate(w, M, q) : f.prototype && f.prototype.isPureReactComponent ? !cd(h, w) || !cd(R, M) : !0;
    }
    function wM(l, f, h, w) {
      l = f.state, typeof f.componentWillReceiveProps == "function" && f.componentWillReceiveProps(h, w), typeof f.UNSAFE_componentWillReceiveProps == "function" && f.UNSAFE_componentWillReceiveProps(h, w), f.state !== l && tw.enqueueReplaceState(f, f.state, null);
    }
    function jl(l, f) {
      var h = f;
      if ("ref" in f) {
        h = {};
        for (var w in f)
          w !== "ref" && (h[w] = f[w]);
      }
      if (l = l.defaultProps) {
        h === f && (h = p({}, h));
        for (var R in l)
          h[R] === void 0 && (h[R] = l[R]);
      }
      return h;
    }
    function SM(l) {
      qm(l);
    }
    function _M(l) {
      console.error(l);
    }
    function EM(l) {
      qm(l);
    }
    function hg(l, f) {
      try {
        var h = l.onUncaughtError;
        h(f.value, { componentStack: f.stack });
      } catch (w) {
        setTimeout(function() {
          throw w;
        });
      }
    }
    function CM(l, f, h) {
      try {
        var w = l.onCaughtError;
        w(h.value, {
          componentStack: h.stack,
          errorBoundary: f.tag === 1 ? f.stateNode : null
        });
      } catch (R) {
        setTimeout(function() {
          throw R;
        });
      }
    }
    function nw(l, f, h) {
      return h = bs(h), h.tag = 3, h.payload = { element: null }, h.callback = function() {
        hg(l, f);
      }, h;
    }
    function kM(l) {
      return l = bs(l), l.tag = 3, l;
    }
    function TM(l, f, h, w) {
      var R = h.type.getDerivedStateFromError;
      if (typeof R == "function") {
        var M = w.value;
        l.payload = function() {
          return R(M);
        }, l.callback = function() {
          CM(f, h, w);
        };
      }
      var q = h.stateNode;
      q !== null && typeof q.componentDidCatch == "function" && (l.callback = function() {
        CM(f, h, w), typeof R != "function" && (ks === null ? ks = /* @__PURE__ */ new Set([this]) : ks.add(this));
        var Z = w.stack;
        this.componentDidCatch(w.value, {
          componentStack: Z !== null ? Z : ""
        });
      });
    }
    function FW(l, f, h, w, R) {
      if (h.flags |= 32768, w !== null && typeof w == "object" && typeof w.then == "function") {
        if (f = h.alternate, f !== null && Jc(
          f,
          h,
          R,
          !0
        ), h = Xr.current, h !== null) {
          switch (h.tag) {
            case 31:
            case 13:
              return _o === null ? kg() : h.alternate === null && Tn === 0 && (Tn = 3), h.flags &= -257, h.flags |= 65536, h.lanes = R, w === tg ? h.flags |= 16384 : (f = h.updateQueue, f === null ? h.updateQueue = /* @__PURE__ */ new Set([w]) : f.add(w), Tw(l, w, R)), !1;
            case 22:
              return h.flags |= 65536, w === tg ? h.flags |= 16384 : (f = h.updateQueue, f === null ? (f = {
                transitions: null,
                markerInstances: null,
                retryQueue: /* @__PURE__ */ new Set([w])
              }, h.updateQueue = f) : (h = f.retryQueue, h === null ? f.retryQueue = /* @__PURE__ */ new Set([w]) : h.add(w)), Tw(l, w, R)), !1;
          }
          throw Error(r(435, h.tag));
        }
        return Tw(l, w, R), kg(), !1;
      }
      if (At)
        return f = Xr.current, f !== null ? ((f.flags & 65536) === 0 && (f.flags |= 256), f.flags |= 65536, f.lanes = R, w !== wx && (l = Error(r(422), { cause: w }), dd(bo(l, h)))) : (w !== wx && (f = Error(r(423), {
          cause: w
        }), dd(
          bo(f, h)
        )), l = l.current.alternate, l.flags |= 65536, R &= -R, l.lanes |= R, w = bo(w, h), R = nw(
          l.stateNode,
          w,
          R
        ), Nx(l, R), Tn !== 4 && (Tn = 2)), !1;
      var M = Error(r(520), { cause: w });
      if (M = bo(M, h), Md === null ? Md = [M] : Md.push(M), Tn !== 4 && (Tn = 2), f === null) return !0;
      w = bo(w, h), h = f;
      do {
        switch (h.tag) {
          case 3:
            return h.flags |= 65536, l = R & -R, h.lanes |= l, l = nw(h.stateNode, w, l), Nx(h, l), !1;
          case 1:
            if (f = h.type, M = h.stateNode, (h.flags & 128) === 0 && (typeof f.getDerivedStateFromError == "function" || M !== null && typeof M.componentDidCatch == "function" && (ks === null || !ks.has(M))))
              return h.flags |= 65536, R &= -R, h.lanes |= R, R = kM(R), TM(
                R,
                l,
                h,
                w
              ), Nx(h, R), !1;
        }
        h = h.return;
      } while (h !== null);
      return !1;
    }
    var rw = Error(r(461)), Ln = !1;
    function ir(l, f, h, w) {
      f.child = l === null ? MO(f, null, h, w) : Il(
        f,
        l.child,
        h,
        w
      );
    }
    function AM(l, f, h, w, R) {
      h = h.render;
      var M = f.ref;
      if ("ref" in w) {
        var q = {};
        for (var Z in w)
          Z !== "ref" && (q[Z] = w[Z]);
      } else q = w;
      return Ol(f), w = Fx(
        l,
        f,
        h,
        q,
        M,
        R
      ), Z = Lx(), l !== null && !Ln ? (zx(l, f, R), ga(l, f, R)) : (At && Z && bx(f), f.flags |= 1, ir(l, f, w, R), f.child);
    }
    function RM(l, f, h, w, R) {
      if (l === null) {
        var M = h.type;
        return typeof M == "function" && !gx(M) && M.defaultProps === void 0 && h.compare === null ? (f.tag = 15, f.type = M, OM(
          l,
          f,
          M,
          w,
          R
        )) : (l = Ym(
          h.type,
          null,
          w,
          f,
          f.mode,
          R
        ), l.ref = f.ref, l.return = f, f.child = l);
      }
      if (M = l.child, !fw(l, R)) {
        var q = M.memoizedProps;
        if (h = h.compare, h = h !== null ? h : cd, h(q, w) && l.ref === f.ref)
          return ga(l, f, R);
      }
      return f.flags |= 1, l = ua(M, w), l.ref = f.ref, l.return = f, f.child = l;
    }
    function OM(l, f, h, w, R) {
      if (l !== null) {
        var M = l.memoizedProps;
        if (cd(M, w) && l.ref === f.ref)
          if (Ln = !1, f.pendingProps = w = M, fw(l, R))
            (l.flags & 131072) !== 0 && (Ln = !0);
          else
            return f.lanes = l.lanes, ga(l, f, R);
      }
      return ow(
        l,
        f,
        h,
        w,
        R
      );
    }
    function MM(l, f, h, w) {
      var R = w.children, M = l !== null ? l.memoizedState : null;
      if (l === null && f.stateNode === null && (f.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      }), w.mode === "hidden") {
        if ((f.flags & 128) !== 0) {
          if (M = M !== null ? M.baseLanes | h : h, l !== null) {
            for (w = f.child = l.child, R = 0; w !== null; )
              R = R | w.lanes | w.childLanes, w = w.sibling;
            w = R & ~M;
          } else w = 0, f.child = null;
          return NM(
            l,
            f,
            M,
            h,
            w
          );
        }
        if ((h & 536870912) !== 0)
          f.memoizedState = { baseLanes: 0, cachePool: null }, l !== null && Jm(
            f,
            M !== null ? M.cachePool : null
          ), M !== null ? IO(f, M) : Ix(), $O(f);
        else
          return w = f.lanes = 536870912, NM(
            l,
            f,
            M !== null ? M.baseLanes | h : h,
            h,
            w
          );
      } else
        M !== null ? (Jm(f, M.cachePool), IO(f, M), Ss(), f.memoizedState = null) : (l !== null && Jm(f, null), Ix(), Ss());
      return ir(l, f, R, h), f.child;
    }
    function Ed(l, f) {
      return l !== null && l.tag === 22 || f.stateNode !== null || (f.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      }), f.sibling;
    }
    function NM(l, f, h, w, R) {
      var M = Ax();
      return M = M === null ? null : { parent: Dn._currentValue, pool: M }, f.memoizedState = {
        baseLanes: h,
        cachePool: M
      }, l !== null && Jm(f, null), Ix(), $O(f), l !== null && Jc(l, f, w, !0), f.childLanes = R, null;
    }
    function mg(l, f) {
      return f = yg(
        { mode: f.mode, children: f.children },
        l.mode
      ), f.ref = l.ref, l.child = f, f.return = l, f;
    }
    function PM(l, f, h) {
      return Il(f, l.child, null, h), l = mg(f, f.pendingProps), l.flags |= 2, Zr(f), f.memoizedState = null, l;
    }
    function LW(l, f, h) {
      var w = f.pendingProps, R = (f.flags & 128) !== 0;
      if (f.flags &= -129, l === null) {
        if (At) {
          if (w.mode === "hidden")
            return l = mg(f, w), f.lanes = 536870912, Ed(null, l);
          if (jx(f), (l = mn) ? (l = qN(
            l,
            So
          ), l = l !== null && l.data === "&" ? l : null, l !== null && (f.memoizedState = {
            dehydrated: l,
            treeContext: hs !== null ? { id: di, overflow: pi } : null,
            retryLane: 536870912,
            hydrationErrors: null
          }, h = gO(l), h.return = f, f.child = h, rr = f, mn = null)) : l = null, l === null) throw gs(f);
          return f.lanes = 536870912, null;
        }
        return mg(f, w);
      }
      var M = l.memoizedState;
      if (M !== null) {
        var q = M.dehydrated;
        if (jx(f), R)
          if (f.flags & 256)
            f.flags &= -257, f = PM(
              l,
              f,
              h
            );
          else if (f.memoizedState !== null)
            f.child = l.child, f.flags |= 128, f = null;
          else throw Error(r(558));
        else if (Ln || Jc(l, f, h, !1), R = (h & l.childLanes) !== 0, Ln || R) {
          if (w = sn, w !== null && (q = Tm(w, h), q !== 0 && q !== M.retryLane))
            throw M.retryLane = q, kl(l, q), Fr(w, l, q), rw;
          kg(), f = PM(
            l,
            f,
            h
          );
        } else
          l = M.treeContext, mn = Eo(q.nextSibling), rr = f, At = !0, ms = null, So = !1, l !== null && bO(f, l), f = mg(f, w), f.flags |= 4096;
        return f;
      }
      return l = ua(l.child, {
        mode: w.mode,
        children: w.children
      }), l.ref = f.ref, f.child = l, l.return = f, l;
    }
    function gg(l, f) {
      var h = f.ref;
      if (h === null)
        l !== null && l.ref !== null && (f.flags |= 4194816);
      else {
        if (typeof h != "function" && typeof h != "object")
          throw Error(r(284));
        (l === null || l.ref !== h) && (f.flags |= 4194816);
      }
    }
    function ow(l, f, h, w, R) {
      return Ol(f), h = Fx(
        l,
        f,
        h,
        w,
        void 0,
        R
      ), w = Lx(), l !== null && !Ln ? (zx(l, f, R), ga(l, f, R)) : (At && w && bx(f), f.flags |= 1, ir(l, f, h, R), f.child);
    }
    function IM(l, f, h, w, R, M) {
      return Ol(f), f.updateQueue = null, h = DO(
        f,
        w,
        h,
        R
      ), jO(l), w = Lx(), l !== null && !Ln ? (zx(l, f, M), ga(l, f, M)) : (At && w && bx(f), f.flags |= 1, ir(l, f, h, M), f.child);
    }
    function $M(l, f, h, w, R) {
      if (Ol(f), f.stateNode === null) {
        var M = Yc, q = h.contextType;
        typeof q == "object" && q !== null && (M = or(q)), M = new h(w, M), f.memoizedState = M.state !== null && M.state !== void 0 ? M.state : null, M.updater = tw, f.stateNode = M, M._reactInternals = f, M = f.stateNode, M.props = w, M.state = f.memoizedState, M.refs = {}, Ox(f), q = h.contextType, M.context = typeof q == "object" && q !== null ? or(q) : Yc, M.state = f.memoizedState, q = h.getDerivedStateFromProps, typeof q == "function" && (ew(
          f,
          h,
          q,
          w
        ), M.state = f.memoizedState), typeof h.getDerivedStateFromProps == "function" || typeof M.getSnapshotBeforeUpdate == "function" || typeof M.UNSAFE_componentWillMount != "function" && typeof M.componentWillMount != "function" || (q = M.state, typeof M.componentWillMount == "function" && M.componentWillMount(), typeof M.UNSAFE_componentWillMount == "function" && M.UNSAFE_componentWillMount(), q !== M.state && tw.enqueueReplaceState(M, M.state, null), bd(f, w, M, R), vd(), M.state = f.memoizedState), typeof M.componentDidMount == "function" && (f.flags |= 4194308), w = !0;
      } else if (l === null) {
        M = f.stateNode;
        var Z = f.memoizedProps, re = jl(h, Z);
        M.props = re;
        var pe = M.context, ve = h.contextType;
        q = Yc, typeof ve == "object" && ve !== null && (q = or(ve));
        var we = h.getDerivedStateFromProps;
        ve = typeof we == "function" || typeof M.getSnapshotBeforeUpdate == "function", Z = f.pendingProps !== Z, ve || typeof M.UNSAFE_componentWillReceiveProps != "function" && typeof M.componentWillReceiveProps != "function" || (Z || pe !== q) && wM(
          f,
          M,
          w,
          q
        ), vs = !1;
        var he = f.memoizedState;
        M.state = he, bd(f, w, M, R), vd(), pe = f.memoizedState, Z || he !== pe || vs ? (typeof we == "function" && (ew(
          f,
          h,
          we,
          w
        ), pe = f.memoizedState), (re = vs || xM(
          f,
          h,
          re,
          w,
          he,
          pe,
          q
        )) ? (ve || typeof M.UNSAFE_componentWillMount != "function" && typeof M.componentWillMount != "function" || (typeof M.componentWillMount == "function" && M.componentWillMount(), typeof M.UNSAFE_componentWillMount == "function" && M.UNSAFE_componentWillMount()), typeof M.componentDidMount == "function" && (f.flags |= 4194308)) : (typeof M.componentDidMount == "function" && (f.flags |= 4194308), f.memoizedProps = w, f.memoizedState = pe), M.props = w, M.state = pe, M.context = q, w = re) : (typeof M.componentDidMount == "function" && (f.flags |= 4194308), w = !1);
      } else {
        M = f.stateNode, Mx(l, f), q = f.memoizedProps, ve = jl(h, q), M.props = ve, we = f.pendingProps, he = M.context, pe = h.contextType, re = Yc, typeof pe == "object" && pe !== null && (re = or(pe)), Z = h.getDerivedStateFromProps, (pe = typeof Z == "function" || typeof M.getSnapshotBeforeUpdate == "function") || typeof M.UNSAFE_componentWillReceiveProps != "function" && typeof M.componentWillReceiveProps != "function" || (q !== we || he !== re) && wM(
          f,
          M,
          w,
          re
        ), vs = !1, he = f.memoizedState, M.state = he, bd(f, w, M, R), vd();
        var ye = f.memoizedState;
        q !== we || he !== ye || vs || l !== null && l.dependencies !== null && Zm(l.dependencies) ? (typeof Z == "function" && (ew(
          f,
          h,
          Z,
          w
        ), ye = f.memoizedState), (ve = vs || xM(
          f,
          h,
          ve,
          w,
          he,
          ye,
          re
        ) || l !== null && l.dependencies !== null && Zm(l.dependencies)) ? (pe || typeof M.UNSAFE_componentWillUpdate != "function" && typeof M.componentWillUpdate != "function" || (typeof M.componentWillUpdate == "function" && M.componentWillUpdate(w, ye, re), typeof M.UNSAFE_componentWillUpdate == "function" && M.UNSAFE_componentWillUpdate(
          w,
          ye,
          re
        )), typeof M.componentDidUpdate == "function" && (f.flags |= 4), typeof M.getSnapshotBeforeUpdate == "function" && (f.flags |= 1024)) : (typeof M.componentDidUpdate != "function" || q === l.memoizedProps && he === l.memoizedState || (f.flags |= 4), typeof M.getSnapshotBeforeUpdate != "function" || q === l.memoizedProps && he === l.memoizedState || (f.flags |= 1024), f.memoizedProps = w, f.memoizedState = ye), M.props = w, M.state = ye, M.context = re, w = ve) : (typeof M.componentDidUpdate != "function" || q === l.memoizedProps && he === l.memoizedState || (f.flags |= 4), typeof M.getSnapshotBeforeUpdate != "function" || q === l.memoizedProps && he === l.memoizedState || (f.flags |= 1024), w = !1);
      }
      return M = w, gg(l, f), w = (f.flags & 128) !== 0, M || w ? (M = f.stateNode, h = w && typeof h.getDerivedStateFromError != "function" ? null : M.render(), f.flags |= 1, l !== null && w ? (f.child = Il(
        f,
        l.child,
        null,
        R
      ), f.child = Il(
        f,
        null,
        h,
        R
      )) : ir(l, f, h, R), f.memoizedState = M.state, l = f.child) : l = ga(
        l,
        f,
        R
      ), l;
    }
    function jM(l, f, h, w) {
      return Al(), f.flags |= 256, ir(l, f, h, w), f.child;
    }
    var iw = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null
    };
    function aw(l) {
      return { baseLanes: l, cachePool: CO() };
    }
    function sw(l, f, h) {
      return l = l !== null ? l.childLanes & ~h : 0, f && (l |= Jr), l;
    }
    function DM(l, f, h) {
      var w = f.pendingProps, R = !1, M = (f.flags & 128) !== 0, q;
      if ((q = M) || (q = l !== null && l.memoizedState === null ? !1 : (Nn.current & 2) !== 0), q && (R = !0, f.flags &= -129), q = (f.flags & 32) !== 0, f.flags &= -33, l === null) {
        if (At) {
          if (R ? ws(f) : Ss(), (l = mn) ? (l = qN(
            l,
            So
          ), l = l !== null && l.data !== "&" ? l : null, l !== null && (f.memoizedState = {
            dehydrated: l,
            treeContext: hs !== null ? { id: di, overflow: pi } : null,
            retryLane: 536870912,
            hydrationErrors: null
          }, h = gO(l), h.return = f, f.child = h, rr = f, mn = null)) : l = null, l === null) throw gs(f);
          return Vw(l) ? f.lanes = 32 : f.lanes = 536870912, null;
        }
        var Z = w.children;
        return w = w.fallback, R ? (Ss(), R = f.mode, Z = yg(
          { mode: "hidden", children: Z },
          R
        ), w = Tl(
          w,
          R,
          h,
          null
        ), Z.return = f, w.return = f, Z.sibling = w, f.child = Z, w = f.child, w.memoizedState = aw(h), w.childLanes = sw(
          l,
          q,
          h
        ), f.memoizedState = iw, Ed(null, w)) : (ws(f), lw(f, Z));
      }
      var re = l.memoizedState;
      if (re !== null && (Z = re.dehydrated, Z !== null)) {
        if (M)
          f.flags & 256 ? (ws(f), f.flags &= -257, f = cw(
            l,
            f,
            h
          )) : f.memoizedState !== null ? (Ss(), f.child = l.child, f.flags |= 128, f = null) : (Ss(), Z = w.fallback, R = f.mode, w = yg(
            { mode: "visible", children: w.children },
            R
          ), Z = Tl(
            Z,
            R,
            h,
            null
          ), Z.flags |= 2, w.return = f, Z.return = f, w.sibling = Z, f.child = w, Il(
            f,
            l.child,
            null,
            h
          ), w = f.child, w.memoizedState = aw(h), w.childLanes = sw(
            l,
            q,
            h
          ), f.memoizedState = iw, f = Ed(null, w));
        else if (ws(f), Vw(Z)) {
          if (q = Z.nextSibling && Z.nextSibling.dataset, q) var pe = q.dgst;
          q = pe, w = Error(r(419)), w.stack = "", w.digest = q, dd({ value: w, source: null, stack: null }), f = cw(
            l,
            f,
            h
          );
        } else if (Ln || Jc(l, f, h, !1), q = (h & l.childLanes) !== 0, Ln || q) {
          if (q = sn, q !== null && (w = Tm(q, h), w !== 0 && w !== re.retryLane))
            throw re.retryLane = w, kl(l, w), Fr(q, l, w), rw;
          Uw(Z) || kg(), f = cw(
            l,
            f,
            h
          );
        } else
          Uw(Z) ? (f.flags |= 192, f.child = l.child, f = null) : (l = re.treeContext, mn = Eo(
            Z.nextSibling
          ), rr = f, At = !0, ms = null, So = !1, l !== null && bO(f, l), f = lw(
            f,
            w.children
          ), f.flags |= 4096);
        return f;
      }
      return R ? (Ss(), Z = w.fallback, R = f.mode, re = l.child, pe = re.sibling, w = ua(re, {
        mode: "hidden",
        children: w.children
      }), w.subtreeFlags = re.subtreeFlags & 65011712, pe !== null ? Z = ua(
        pe,
        Z
      ) : (Z = Tl(
        Z,
        R,
        h,
        null
      ), Z.flags |= 2), Z.return = f, w.return = f, w.sibling = Z, f.child = w, Ed(null, w), w = f.child, Z = l.child.memoizedState, Z === null ? Z = aw(h) : (R = Z.cachePool, R !== null ? (re = Dn._currentValue, R = R.parent !== re ? { parent: re, pool: re } : R) : R = CO(), Z = {
        baseLanes: Z.baseLanes | h,
        cachePool: R
      }), w.memoizedState = Z, w.childLanes = sw(
        l,
        q,
        h
      ), f.memoizedState = iw, Ed(l.child, w)) : (ws(f), h = l.child, l = h.sibling, h = ua(h, {
        mode: "visible",
        children: w.children
      }), h.return = f, h.sibling = null, l !== null && (q = f.deletions, q === null ? (f.deletions = [l], f.flags |= 16) : q.push(l)), f.child = h, f.memoizedState = null, h);
    }
    function lw(l, f) {
      return f = yg(
        { mode: "visible", children: f },
        l.mode
      ), f.return = l, l.child = f;
    }
    function yg(l, f) {
      return l = Yr(22, l, null, f), l.lanes = 0, l;
    }
    function cw(l, f, h) {
      return Il(f, l.child, null, h), l = lw(
        f,
        f.pendingProps.children
      ), l.flags |= 2, f.memoizedState = null, l;
    }
    function FM(l, f, h) {
      l.lanes |= f;
      var w = l.alternate;
      w !== null && (w.lanes |= f), Ex(l.return, f, h);
    }
    function uw(l, f, h, w, R, M) {
      var q = l.memoizedState;
      q === null ? l.memoizedState = {
        isBackwards: f,
        rendering: null,
        renderingStartTime: 0,
        last: w,
        tail: h,
        tailMode: R,
        treeForkCount: M
      } : (q.isBackwards = f, q.rendering = null, q.renderingStartTime = 0, q.last = w, q.tail = h, q.tailMode = R, q.treeForkCount = M);
    }
    function LM(l, f, h) {
      var w = f.pendingProps, R = w.revealOrder, M = w.tail;
      w = w.children;
      var q = Nn.current, Z = (q & 2) !== 0;
      if (Z ? (q = q & 1 | 2, f.flags |= 128) : q &= 1, z(Nn, q), ir(l, f, w, h), w = At ? fd : 0, !Z && l !== null && (l.flags & 128) !== 0)
        e: for (l = f.child; l !== null; ) {
          if (l.tag === 13)
            l.memoizedState !== null && FM(l, h, f);
          else if (l.tag === 19)
            FM(l, h, f);
          else if (l.child !== null) {
            l.child.return = l, l = l.child;
            continue;
          }
          if (l === f) break e;
          for (; l.sibling === null; ) {
            if (l.return === null || l.return === f)
              break e;
            l = l.return;
          }
          l.sibling.return = l.return, l = l.sibling;
        }
      switch (R) {
        case "forwards":
          for (h = f.child, R = null; h !== null; )
            l = h.alternate, l !== null && ig(l) === null && (R = h), h = h.sibling;
          h = R, h === null ? (R = f.child, f.child = null) : (R = h.sibling, h.sibling = null), uw(
            f,
            !1,
            R,
            h,
            M,
            w
          );
          break;
        case "backwards":
        case "unstable_legacy-backwards":
          for (h = null, R = f.child, f.child = null; R !== null; ) {
            if (l = R.alternate, l !== null && ig(l) === null) {
              f.child = R;
              break;
            }
            l = R.sibling, R.sibling = h, h = R, R = l;
          }
          uw(
            f,
            !0,
            h,
            null,
            M,
            w
          );
          break;
        case "together":
          uw(
            f,
            !1,
            null,
            null,
            void 0,
            w
          );
          break;
        default:
          f.memoizedState = null;
      }
      return f.child;
    }
    function ga(l, f, h) {
      if (l !== null && (f.dependencies = l.dependencies), Cs |= f.lanes, (h & f.childLanes) === 0)
        if (l !== null) {
          if (Jc(
            l,
            f,
            h,
            !1
          ), (h & f.childLanes) === 0)
            return null;
        } else return null;
      if (l !== null && f.child !== l.child)
        throw Error(r(153));
      if (f.child !== null) {
        for (l = f.child, h = ua(l, l.pendingProps), f.child = h, h.return = f; l.sibling !== null; )
          l = l.sibling, h = h.sibling = ua(l, l.pendingProps), h.return = f;
        h.sibling = null;
      }
      return f.child;
    }
    function fw(l, f) {
      return (l.lanes & f) !== 0 ? !0 : (l = l.dependencies, !!(l !== null && Zm(l)));
    }
    function zW(l, f, h) {
      switch (f.tag) {
        case 3:
          te(f, f.stateNode.containerInfo), ys(f, Dn, l.memoizedState.cache), Al();
          break;
        case 27:
        case 5:
          ue(f);
          break;
        case 4:
          te(f, f.stateNode.containerInfo);
          break;
        case 10:
          ys(
            f,
            f.type,
            f.memoizedProps.value
          );
          break;
        case 31:
          if (f.memoizedState !== null)
            return f.flags |= 128, jx(f), null;
          break;
        case 13:
          var w = f.memoizedState;
          if (w !== null)
            return w.dehydrated !== null ? (ws(f), f.flags |= 128, null) : (h & f.child.childLanes) !== 0 ? DM(l, f, h) : (ws(f), l = ga(
              l,
              f,
              h
            ), l !== null ? l.sibling : null);
          ws(f);
          break;
        case 19:
          var R = (l.flags & 128) !== 0;
          if (w = (h & f.childLanes) !== 0, w || (Jc(
            l,
            f,
            h,
            !1
          ), w = (h & f.childLanes) !== 0), R) {
            if (w)
              return LM(
                l,
                f,
                h
              );
            f.flags |= 128;
          }
          if (R = f.memoizedState, R !== null && (R.rendering = null, R.tail = null, R.lastEffect = null), z(Nn, Nn.current), w) break;
          return null;
        case 22:
          return f.lanes = 0, MM(
            l,
            f,
            h,
            f.pendingProps
          );
        case 24:
          ys(f, Dn, l.memoizedState.cache);
      }
      return ga(l, f, h);
    }
    function zM(l, f, h) {
      if (l !== null)
        if (l.memoizedProps !== f.pendingProps)
          Ln = !0;
        else {
          if (!fw(l, h) && (f.flags & 128) === 0)
            return Ln = !1, zW(
              l,
              f,
              h
            );
          Ln = (l.flags & 131072) !== 0;
        }
      else
        Ln = !1, At && (f.flags & 1048576) !== 0 && vO(f, fd, f.index);
      switch (f.lanes = 0, f.tag) {
        case 16:
          e: {
            var w = f.pendingProps;
            if (l = Nl(f.elementType), f.type = l, typeof l == "function")
              gx(l) ? (w = jl(l, w), f.tag = 1, f = $M(
                null,
                f,
                l,
                w,
                h
              )) : (f.tag = 0, f = ow(
                null,
                f,
                l,
                w,
                h
              ));
            else {
              if (l != null) {
                var R = l.$$typeof;
                if (R === C) {
                  f.tag = 11, f = AM(
                    null,
                    f,
                    l,
                    w,
                    h
                  );
                  break e;
                } else if (R === O) {
                  f.tag = 14, f = RM(
                    null,
                    f,
                    l,
                    w,
                    h
                  );
                  break e;
                }
              }
              throw f = j(l) || l, Error(r(306, f, ""));
            }
          }
          return f;
        case 0:
          return ow(
            l,
            f,
            f.type,
            f.pendingProps,
            h
          );
        case 1:
          return w = f.type, R = jl(
            w,
            f.pendingProps
          ), $M(
            l,
            f,
            w,
            R,
            h
          );
        case 3:
          e: {
            if (te(
              f,
              f.stateNode.containerInfo
            ), l === null) throw Error(r(387));
            w = f.pendingProps;
            var M = f.memoizedState;
            R = M.element, Mx(l, f), bd(f, w, null, h);
            var q = f.memoizedState;
            if (w = q.cache, ys(f, Dn, w), w !== M.cache && Cx(
              f,
              [Dn],
              h,
              !0
            ), vd(), w = q.element, M.isDehydrated)
              if (M = {
                element: w,
                isDehydrated: !1,
                cache: q.cache
              }, f.updateQueue.baseState = M, f.memoizedState = M, f.flags & 256) {
                f = jM(
                  l,
                  f,
                  w,
                  h
                );
                break e;
              } else if (w !== R) {
                R = bo(
                  Error(r(424)),
                  f
                ), dd(R), f = jM(
                  l,
                  f,
                  w,
                  h
                );
                break e;
              } else
                for (l = f.stateNode.containerInfo, l.nodeType === 9 ? l = l.body : l = l.nodeName === "HTML" ? l.ownerDocument.body : l, mn = Eo(l.firstChild), rr = f, At = !0, ms = null, So = !0, h = MO(
                  f,
                  null,
                  w,
                  h
                ), f.child = h; h; )
                  h.flags = h.flags & -3 | 4096, h = h.sibling;
            else {
              if (Al(), w === R) {
                f = ga(
                  l,
                  f,
                  h
                );
                break e;
              }
              ir(l, f, w, h);
            }
            f = f.child;
          }
          return f;
        case 26:
          return gg(l, f), l === null ? (h = ZN(
            f.type,
            null,
            f.pendingProps,
            null
          )) ? f.memoizedState = h : At || (h = f.type, l = f.pendingProps, w = Pg(
            Q.current
          ).createElement(h), w[Wn] = f, w[pr] = l, ar(w, h, l), jn(w), f.stateNode = w) : f.memoizedState = ZN(
            f.type,
            l.memoizedProps,
            f.pendingProps,
            l.memoizedState
          ), null;
        case 27:
          return ue(f), l === null && At && (w = f.stateNode = KN(
            f.type,
            f.pendingProps,
            Q.current
          ), rr = f, So = !0, R = mn, Os(f.type) ? (Hw = R, mn = Eo(w.firstChild)) : mn = R), ir(
            l,
            f,
            f.pendingProps.children,
            h
          ), gg(l, f), l === null && (f.flags |= 4194304), f.child;
        case 5:
          return l === null && At && ((R = w = mn) && (w = gG(
            w,
            f.type,
            f.pendingProps,
            So
          ), w !== null ? (f.stateNode = w, rr = f, mn = Eo(w.firstChild), So = !1, R = !0) : R = !1), R || gs(f)), ue(f), R = f.type, M = f.pendingProps, q = l !== null ? l.memoizedProps : null, w = M.children, Lw(R, M) ? w = null : q !== null && Lw(R, q) && (f.flags |= 32), f.memoizedState !== null && (R = Fx(
            l,
            f,
            MW,
            null,
            null,
            h
          ), Ld._currentValue = R), gg(l, f), ir(l, f, w, h), f.child;
        case 6:
          return l === null && At && ((l = h = mn) && (h = yG(
            h,
            f.pendingProps,
            So
          ), h !== null ? (f.stateNode = h, rr = f, mn = null, l = !0) : l = !1), l || gs(f)), null;
        case 13:
          return DM(l, f, h);
        case 4:
          return te(
            f,
            f.stateNode.containerInfo
          ), w = f.pendingProps, l === null ? f.child = Il(
            f,
            null,
            w,
            h
          ) : ir(l, f, w, h), f.child;
        case 11:
          return AM(
            l,
            f,
            f.type,
            f.pendingProps,
            h
          );
        case 7:
          return ir(
            l,
            f,
            f.pendingProps,
            h
          ), f.child;
        case 8:
          return ir(
            l,
            f,
            f.pendingProps.children,
            h
          ), f.child;
        case 12:
          return ir(
            l,
            f,
            f.pendingProps.children,
            h
          ), f.child;
        case 10:
          return w = f.pendingProps, ys(f, f.type, w.value), ir(l, f, w.children, h), f.child;
        case 9:
          return R = f.type._context, w = f.pendingProps.children, Ol(f), R = or(R), w = w(R), f.flags |= 1, ir(l, f, w, h), f.child;
        case 14:
          return RM(
            l,
            f,
            f.type,
            f.pendingProps,
            h
          );
        case 15:
          return OM(
            l,
            f,
            f.type,
            f.pendingProps,
            h
          );
        case 19:
          return LM(l, f, h);
        case 31:
          return LW(l, f, h);
        case 22:
          return MM(
            l,
            f,
            h,
            f.pendingProps
          );
        case 24:
          return Ol(f), w = or(Dn), l === null ? (R = Ax(), R === null && (R = sn, M = kx(), R.pooledCache = M, M.refCount++, M !== null && (R.pooledCacheLanes |= h), R = M), f.memoizedState = { parent: w, cache: R }, Ox(f), ys(f, Dn, R)) : ((l.lanes & h) !== 0 && (Mx(l, f), bd(f, null, null, h), vd()), R = l.memoizedState, M = f.memoizedState, R.parent !== w ? (R = { parent: w, cache: w }, f.memoizedState = R, f.lanes === 0 && (f.memoizedState = f.updateQueue.baseState = R), ys(f, Dn, w)) : (w = M.cache, ys(f, Dn, w), w !== R.cache && Cx(
            f,
            [Dn],
            h,
            !0
          ))), ir(
            l,
            f,
            f.pendingProps.children,
            h
          ), f.child;
        case 29:
          throw f.pendingProps;
      }
      throw Error(r(156, f.tag));
    }
    function ya(l) {
      l.flags |= 4;
    }
    function dw(l, f, h, w, R) {
      if ((f = (l.mode & 32) !== 0) && (f = !1), f) {
        if (l.flags |= 16777216, (R & 335544128) === R)
          if (l.stateNode.complete) l.flags |= 8192;
          else if (pN()) l.flags |= 8192;
          else
            throw Pl = tg, Rx;
      } else l.flags &= -16777217;
    }
    function BM(l, f) {
      if (f.type !== "stylesheet" || (f.state.loading & 4) !== 0)
        l.flags &= -16777217;
      else if (l.flags |= 16777216, !nP(f))
        if (pN()) l.flags |= 8192;
        else
          throw Pl = tg, Rx;
    }
    function vg(l, f) {
      f !== null && (l.flags |= 4), l.flags & 16384 && (f = l.tag !== 22 ? Em() : 536870912, l.lanes |= f, fu |= f);
    }
    function Cd(l, f) {
      if (!At)
        switch (l.tailMode) {
          case "hidden":
            f = l.tail;
            for (var h = null; f !== null; )
              f.alternate !== null && (h = f), f = f.sibling;
            h === null ? l.tail = null : h.sibling = null;
            break;
          case "collapsed":
            h = l.tail;
            for (var w = null; h !== null; )
              h.alternate !== null && (w = h), h = h.sibling;
            w === null ? f || l.tail === null ? l.tail = null : l.tail.sibling = null : w.sibling = null;
        }
    }
    function gn(l) {
      var f = l.alternate !== null && l.alternate.child === l.child, h = 0, w = 0;
      if (f)
        for (var R = l.child; R !== null; )
          h |= R.lanes | R.childLanes, w |= R.subtreeFlags & 65011712, w |= R.flags & 65011712, R.return = l, R = R.sibling;
      else
        for (R = l.child; R !== null; )
          h |= R.lanes | R.childLanes, w |= R.subtreeFlags, w |= R.flags, R.return = l, R = R.sibling;
      return l.subtreeFlags |= w, l.childLanes = h, f;
    }
    function BW(l, f, h) {
      var w = f.pendingProps;
      switch (xx(f), f.tag) {
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return gn(f), null;
        case 1:
          return gn(f), null;
        case 3:
          return h = f.stateNode, w = null, l !== null && (w = l.memoizedState.cache), f.memoizedState.cache !== w && (f.flags |= 2048), pa(Dn), se(), h.pendingContext && (h.context = h.pendingContext, h.pendingContext = null), (l === null || l.child === null) && (Qc(f) ? ya(f) : l === null || l.memoizedState.isDehydrated && (f.flags & 256) === 0 || (f.flags |= 1024, Sx())), gn(f), null;
        case 26:
          var R = f.type, M = f.memoizedState;
          return l === null ? (ya(f), M !== null ? (gn(f), BM(f, M)) : (gn(f), dw(
            f,
            R,
            null,
            w,
            h
          ))) : M ? M !== l.memoizedState ? (ya(f), gn(f), BM(f, M)) : (gn(f), f.flags &= -16777217) : (l = l.memoizedProps, l !== w && ya(f), gn(f), dw(
            f,
            R,
            l,
            w,
            h
          )), null;
        case 27:
          if (J(f), h = Q.current, R = f.type, l !== null && f.stateNode != null)
            l.memoizedProps !== w && ya(f);
          else {
            if (!w) {
              if (f.stateNode === null)
                throw Error(r(166));
              return gn(f), null;
            }
            l = H.current, Qc(f) ? xO(f) : (l = KN(R, w, h), f.stateNode = l, ya(f));
          }
          return gn(f), null;
        case 5:
          if (J(f), R = f.type, l !== null && f.stateNode != null)
            l.memoizedProps !== w && ya(f);
          else {
            if (!w) {
              if (f.stateNode === null)
                throw Error(r(166));
              return gn(f), null;
            }
            if (M = H.current, Qc(f))
              xO(f);
            else {
              var q = Pg(
                Q.current
              );
              switch (M) {
                case 1:
                  M = q.createElementNS(
                    "http://www.w3.org/2000/svg",
                    R
                  );
                  break;
                case 2:
                  M = q.createElementNS(
                    "http://www.w3.org/1998/Math/MathML",
                    R
                  );
                  break;
                default:
                  switch (R) {
                    case "svg":
                      M = q.createElementNS(
                        "http://www.w3.org/2000/svg",
                        R
                      );
                      break;
                    case "math":
                      M = q.createElementNS(
                        "http://www.w3.org/1998/Math/MathML",
                        R
                      );
                      break;
                    case "script":
                      M = q.createElement("div"), M.innerHTML = "<script><\/script>", M = M.removeChild(
                        M.firstChild
                      );
                      break;
                    case "select":
                      M = typeof w.is == "string" ? q.createElement("select", {
                        is: w.is
                      }) : q.createElement("select"), w.multiple ? M.multiple = !0 : w.size && (M.size = w.size);
                      break;
                    default:
                      M = typeof w.is == "string" ? q.createElement(R, { is: w.is }) : q.createElement(R);
                  }
              }
              M[Wn] = f, M[pr] = w;
              e: for (q = f.child; q !== null; ) {
                if (q.tag === 5 || q.tag === 6)
                  M.appendChild(q.stateNode);
                else if (q.tag !== 4 && q.tag !== 27 && q.child !== null) {
                  q.child.return = q, q = q.child;
                  continue;
                }
                if (q === f) break e;
                for (; q.sibling === null; ) {
                  if (q.return === null || q.return === f)
                    break e;
                  q = q.return;
                }
                q.sibling.return = q.return, q = q.sibling;
              }
              f.stateNode = M;
              e: switch (ar(M, R, w), R) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  w = !!w.autoFocus;
                  break e;
                case "img":
                  w = !0;
                  break e;
                default:
                  w = !1;
              }
              w && ya(f);
            }
          }
          return gn(f), dw(
            f,
            f.type,
            l === null ? null : l.memoizedProps,
            f.pendingProps,
            h
          ), null;
        case 6:
          if (l && f.stateNode != null)
            l.memoizedProps !== w && ya(f);
          else {
            if (typeof w != "string" && f.stateNode === null)
              throw Error(r(166));
            if (l = Q.current, Qc(f)) {
              if (l = f.stateNode, h = f.memoizedProps, w = null, R = rr, R !== null)
                switch (R.tag) {
                  case 27:
                  case 5:
                    w = R.memoizedProps;
                }
              l[Wn] = f, l = !!(l.nodeValue === h || w !== null && w.suppressHydrationWarning === !0 || DN(l.nodeValue, h)), l || gs(f, !0);
            } else
              l = Pg(l).createTextNode(
                w
              ), l[Wn] = f, f.stateNode = l;
          }
          return gn(f), null;
        case 31:
          if (h = f.memoizedState, l === null || l.memoizedState !== null) {
            if (w = Qc(f), h !== null) {
              if (l === null) {
                if (!w) throw Error(r(318));
                if (l = f.memoizedState, l = l !== null ? l.dehydrated : null, !l) throw Error(r(557));
                l[Wn] = f;
              } else
                Al(), (f.flags & 128) === 0 && (f.memoizedState = null), f.flags |= 4;
              gn(f), l = !1;
            } else
              h = Sx(), l !== null && l.memoizedState !== null && (l.memoizedState.hydrationErrors = h), l = !0;
            if (!l)
              return f.flags & 256 ? (Zr(f), f) : (Zr(f), null);
            if ((f.flags & 128) !== 0)
              throw Error(r(558));
          }
          return gn(f), null;
        case 13:
          if (w = f.memoizedState, l === null || l.memoizedState !== null && l.memoizedState.dehydrated !== null) {
            if (R = Qc(f), w !== null && w.dehydrated !== null) {
              if (l === null) {
                if (!R) throw Error(r(318));
                if (R = f.memoizedState, R = R !== null ? R.dehydrated : null, !R) throw Error(r(317));
                R[Wn] = f;
              } else
                Al(), (f.flags & 128) === 0 && (f.memoizedState = null), f.flags |= 4;
              gn(f), R = !1;
            } else
              R = Sx(), l !== null && l.memoizedState !== null && (l.memoizedState.hydrationErrors = R), R = !0;
            if (!R)
              return f.flags & 256 ? (Zr(f), f) : (Zr(f), null);
          }
          return Zr(f), (f.flags & 128) !== 0 ? (f.lanes = h, f) : (h = w !== null, l = l !== null && l.memoizedState !== null, h && (w = f.child, R = null, w.alternate !== null && w.alternate.memoizedState !== null && w.alternate.memoizedState.cachePool !== null && (R = w.alternate.memoizedState.cachePool.pool), M = null, w.memoizedState !== null && w.memoizedState.cachePool !== null && (M = w.memoizedState.cachePool.pool), M !== R && (w.flags |= 2048)), h !== l && h && (f.child.flags |= 8192), vg(f, f.updateQueue), gn(f), null);
        case 4:
          return se(), l === null && Iw(f.stateNode.containerInfo), gn(f), null;
        case 10:
          return pa(f.type), gn(f), null;
        case 19:
          if (G(Nn), w = f.memoizedState, w === null) return gn(f), null;
          if (R = (f.flags & 128) !== 0, M = w.rendering, M === null)
            if (R) Cd(w, !1);
            else {
              if (Tn !== 0 || l !== null && (l.flags & 128) !== 0)
                for (l = f.child; l !== null; ) {
                  if (M = ig(l), M !== null) {
                    for (f.flags |= 128, Cd(w, !1), l = M.updateQueue, f.updateQueue = l, vg(f, l), f.subtreeFlags = 0, l = h, h = f.child; h !== null; )
                      mO(h, l), h = h.sibling;
                    return z(
                      Nn,
                      Nn.current & 1 | 2
                    ), At && fa(f, w.treeForkCount), f.child;
                  }
                  l = l.sibling;
                }
              w.tail !== null && Je() > _g && (f.flags |= 128, R = !0, Cd(w, !1), f.lanes = 4194304);
            }
          else {
            if (!R)
              if (l = ig(M), l !== null) {
                if (f.flags |= 128, R = !0, l = l.updateQueue, f.updateQueue = l, vg(f, l), Cd(w, !0), w.tail === null && w.tailMode === "hidden" && !M.alternate && !At)
                  return gn(f), null;
              } else
                2 * Je() - w.renderingStartTime > _g && h !== 536870912 && (f.flags |= 128, R = !0, Cd(w, !1), f.lanes = 4194304);
            w.isBackwards ? (M.sibling = f.child, f.child = M) : (l = w.last, l !== null ? l.sibling = M : f.child = M, w.last = M);
          }
          return w.tail !== null ? (l = w.tail, w.rendering = l, w.tail = l.sibling, w.renderingStartTime = Je(), l.sibling = null, h = Nn.current, z(
            Nn,
            R ? h & 1 | 2 : h & 1
          ), At && fa(f, w.treeForkCount), l) : (gn(f), null);
        case 22:
        case 23:
          return Zr(f), $x(), w = f.memoizedState !== null, l !== null ? l.memoizedState !== null !== w && (f.flags |= 8192) : w && (f.flags |= 8192), w ? (h & 536870912) !== 0 && (f.flags & 128) === 0 && (gn(f), f.subtreeFlags & 6 && (f.flags |= 8192)) : gn(f), h = f.updateQueue, h !== null && vg(f, h.retryQueue), h = null, l !== null && l.memoizedState !== null && l.memoizedState.cachePool !== null && (h = l.memoizedState.cachePool.pool), w = null, f.memoizedState !== null && f.memoizedState.cachePool !== null && (w = f.memoizedState.cachePool.pool), w !== h && (f.flags |= 2048), l !== null && G(Ml), null;
        case 24:
          return h = null, l !== null && (h = l.memoizedState.cache), f.memoizedState.cache !== h && (f.flags |= 2048), pa(Dn), gn(f), null;
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error(r(156, f.tag));
    }
    function UW(l, f) {
      switch (xx(f), f.tag) {
        case 1:
          return l = f.flags, l & 65536 ? (f.flags = l & -65537 | 128, f) : null;
        case 3:
          return pa(Dn), se(), l = f.flags, (l & 65536) !== 0 && (l & 128) === 0 ? (f.flags = l & -65537 | 128, f) : null;
        case 26:
        case 27:
        case 5:
          return J(f), null;
        case 31:
          if (f.memoizedState !== null) {
            if (Zr(f), f.alternate === null)
              throw Error(r(340));
            Al();
          }
          return l = f.flags, l & 65536 ? (f.flags = l & -65537 | 128, f) : null;
        case 13:
          if (Zr(f), l = f.memoizedState, l !== null && l.dehydrated !== null) {
            if (f.alternate === null)
              throw Error(r(340));
            Al();
          }
          return l = f.flags, l & 65536 ? (f.flags = l & -65537 | 128, f) : null;
        case 19:
          return G(Nn), null;
        case 4:
          return se(), null;
        case 10:
          return pa(f.type), null;
        case 22:
        case 23:
          return Zr(f), $x(), l !== null && G(Ml), l = f.flags, l & 65536 ? (f.flags = l & -65537 | 128, f) : null;
        case 24:
          return pa(Dn), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function UM(l, f) {
      switch (xx(f), f.tag) {
        case 3:
          pa(Dn), se();
          break;
        case 26:
        case 27:
        case 5:
          J(f);
          break;
        case 4:
          se();
          break;
        case 31:
          f.memoizedState !== null && Zr(f);
          break;
        case 13:
          Zr(f);
          break;
        case 19:
          G(Nn);
          break;
        case 10:
          pa(f.type);
          break;
        case 22:
        case 23:
          Zr(f), $x(), l !== null && G(Ml);
          break;
        case 24:
          pa(Dn);
      }
    }
    function kd(l, f) {
      try {
        var h = f.updateQueue, w = h !== null ? h.lastEffect : null;
        if (w !== null) {
          var R = w.next;
          h = R;
          do {
            if ((h.tag & l) === l) {
              w = void 0;
              var M = h.create, q = h.inst;
              w = M(), q.destroy = w;
            }
            h = h.next;
          } while (h !== R);
        }
      } catch (Z) {
        Kt(f, f.return, Z);
      }
    }
    function _s(l, f, h) {
      try {
        var w = f.updateQueue, R = w !== null ? w.lastEffect : null;
        if (R !== null) {
          var M = R.next;
          w = M;
          do {
            if ((w.tag & l) === l) {
              var q = w.inst, Z = q.destroy;
              if (Z !== void 0) {
                q.destroy = void 0, R = f;
                var re = h, pe = Z;
                try {
                  pe();
                } catch (ve) {
                  Kt(
                    R,
                    re,
                    ve
                  );
                }
              }
            }
            w = w.next;
          } while (w !== M);
        }
      } catch (ve) {
        Kt(f, f.return, ve);
      }
    }
    function VM(l) {
      var f = l.updateQueue;
      if (f !== null) {
        var h = l.stateNode;
        try {
          PO(f, h);
        } catch (w) {
          Kt(l, l.return, w);
        }
      }
    }
    function HM(l, f, h) {
      h.props = jl(
        l.type,
        l.memoizedProps
      ), h.state = l.memoizedState;
      try {
        h.componentWillUnmount();
      } catch (w) {
        Kt(l, f, w);
      }
    }
    function Td(l, f) {
      try {
        var h = l.ref;
        if (h !== null) {
          switch (l.tag) {
            case 26:
            case 27:
            case 5:
              var w = l.stateNode;
              break;
            case 30:
              w = l.stateNode;
              break;
            default:
              w = l.stateNode;
          }
          typeof h == "function" ? l.refCleanup = h(w) : h.current = w;
        }
      } catch (R) {
        Kt(l, f, R);
      }
    }
    function hi(l, f) {
      var h = l.ref, w = l.refCleanup;
      if (h !== null)
        if (typeof w == "function")
          try {
            w();
          } catch (R) {
            Kt(l, f, R);
          } finally {
            l.refCleanup = null, l = l.alternate, l != null && (l.refCleanup = null);
          }
        else if (typeof h == "function")
          try {
            h(null);
          } catch (R) {
            Kt(l, f, R);
          }
        else h.current = null;
    }
    function qM(l) {
      var f = l.type, h = l.memoizedProps, w = l.stateNode;
      try {
        e: switch (f) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            h.autoFocus && w.focus();
            break e;
          case "img":
            h.src ? w.src = h.src : h.srcSet && (w.srcset = h.srcSet);
        }
      } catch (R) {
        Kt(l, l.return, R);
      }
    }
    function pw(l, f, h) {
      try {
        var w = l.stateNode;
        uG(w, l.type, h, f), w[pr] = f;
      } catch (R) {
        Kt(l, l.return, R);
      }
    }
    function WM(l) {
      return l.tag === 5 || l.tag === 3 || l.tag === 26 || l.tag === 27 && Os(l.type) || l.tag === 4;
    }
    function hw(l) {
      e: for (; ; ) {
        for (; l.sibling === null; ) {
          if (l.return === null || WM(l.return)) return null;
          l = l.return;
        }
        for (l.sibling.return = l.return, l = l.sibling; l.tag !== 5 && l.tag !== 6 && l.tag !== 18; ) {
          if (l.tag === 27 && Os(l.type) || l.flags & 2 || l.child === null || l.tag === 4) continue e;
          l.child.return = l, l = l.child;
        }
        if (!(l.flags & 2)) return l.stateNode;
      }
    }
    function mw(l, f, h) {
      var w = l.tag;
      if (w === 5 || w === 6)
        l = l.stateNode, f ? (h.nodeType === 9 ? h.body : h.nodeName === "HTML" ? h.ownerDocument.body : h).insertBefore(l, f) : (f = h.nodeType === 9 ? h.body : h.nodeName === "HTML" ? h.ownerDocument.body : h, f.appendChild(l), h = h._reactRootContainer, h != null || f.onclick !== null || (f.onclick = la));
      else if (w !== 4 && (w === 27 && Os(l.type) && (h = l.stateNode, f = null), l = l.child, l !== null))
        for (mw(l, f, h), l = l.sibling; l !== null; )
          mw(l, f, h), l = l.sibling;
    }
    function bg(l, f, h) {
      var w = l.tag;
      if (w === 5 || w === 6)
        l = l.stateNode, f ? h.insertBefore(l, f) : h.appendChild(l);
      else if (w !== 4 && (w === 27 && Os(l.type) && (h = l.stateNode), l = l.child, l !== null))
        for (bg(l, f, h), l = l.sibling; l !== null; )
          bg(l, f, h), l = l.sibling;
    }
    function GM(l) {
      var f = l.stateNode, h = l.memoizedProps;
      try {
        for (var w = l.type, R = f.attributes; R.length; )
          f.removeAttributeNode(R[0]);
        ar(f, w, h), f[Wn] = l, f[pr] = h;
      } catch (M) {
        Kt(l, l.return, M);
      }
    }
    var va = !1, zn = !1, gw = !1, KM = typeof WeakSet == "function" ? WeakSet : Set, Qn = null;
    function VW(l, f) {
      if (l = l.containerInfo, Dw = zg, l = aO(l), cx(l)) {
        if ("selectionStart" in l)
          var h = {
            start: l.selectionStart,
            end: l.selectionEnd
          };
        else
          e: {
            h = (h = l.ownerDocument) && h.defaultView || window;
            var w = h.getSelection && h.getSelection();
            if (w && w.rangeCount !== 0) {
              h = w.anchorNode;
              var R = w.anchorOffset, M = w.focusNode;
              w = w.focusOffset;
              try {
                h.nodeType, M.nodeType;
              } catch {
                h = null;
                break e;
              }
              var q = 0, Z = -1, re = -1, pe = 0, ve = 0, we = l, he = null;
              t: for (; ; ) {
                for (var ye; we !== h || R !== 0 && we.nodeType !== 3 || (Z = q + R), we !== M || w !== 0 && we.nodeType !== 3 || (re = q + w), we.nodeType === 3 && (q += we.nodeValue.length), (ye = we.firstChild) !== null; )
                  he = we, we = ye;
                for (; ; ) {
                  if (we === l) break t;
                  if (he === h && ++pe === R && (Z = q), he === M && ++ve === w && (re = q), (ye = we.nextSibling) !== null) break;
                  we = he, he = we.parentNode;
                }
                we = ye;
              }
              h = Z === -1 || re === -1 ? null : { start: Z, end: re };
            } else h = null;
          }
        h = h || { start: 0, end: 0 };
      } else h = null;
      for (Fw = { focusedElem: l, selectionRange: h }, zg = !1, Qn = f; Qn !== null; )
        if (f = Qn, l = f.child, (f.subtreeFlags & 1028) !== 0 && l !== null)
          l.return = f, Qn = l;
        else
          for (; Qn !== null; ) {
            switch (f = Qn, M = f.alternate, l = f.flags, f.tag) {
              case 0:
                if ((l & 4) !== 0 && (l = f.updateQueue, l = l !== null ? l.events : null, l !== null))
                  for (h = 0; h < l.length; h++)
                    R = l[h], R.ref.impl = R.nextImpl;
                break;
              case 11:
              case 15:
                break;
              case 1:
                if ((l & 1024) !== 0 && M !== null) {
                  l = void 0, h = f, R = M.memoizedProps, M = M.memoizedState, w = h.stateNode;
                  try {
                    var Fe = jl(
                      h.type,
                      R
                    );
                    l = w.getSnapshotBeforeUpdate(
                      Fe,
                      M
                    ), w.__reactInternalSnapshotBeforeUpdate = l;
                  } catch (et) {
                    Kt(
                      h,
                      h.return,
                      et
                    );
                  }
                }
                break;
              case 3:
                if ((l & 1024) !== 0) {
                  if (l = f.stateNode.containerInfo, h = l.nodeType, h === 9)
                    Bw(l);
                  else if (h === 1)
                    switch (l.nodeName) {
                      case "HEAD":
                      case "HTML":
                      case "BODY":
                        Bw(l);
                        break;
                      default:
                        l.textContent = "";
                    }
                }
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if ((l & 1024) !== 0) throw Error(r(163));
            }
            if (l = f.sibling, l !== null) {
              l.return = f.return, Qn = l;
              break;
            }
            Qn = f.return;
          }
    }
    function YM(l, f, h) {
      var w = h.flags;
      switch (h.tag) {
        case 0:
        case 11:
        case 15:
          xa(l, h), w & 4 && kd(5, h);
          break;
        case 1:
          if (xa(l, h), w & 4)
            if (l = h.stateNode, f === null)
              try {
                l.componentDidMount();
              } catch (q) {
                Kt(h, h.return, q);
              }
            else {
              var R = jl(
                h.type,
                f.memoizedProps
              );
              f = f.memoizedState;
              try {
                l.componentDidUpdate(
                  R,
                  f,
                  l.__reactInternalSnapshotBeforeUpdate
                );
              } catch (q) {
                Kt(
                  h,
                  h.return,
                  q
                );
              }
            }
          w & 64 && VM(h), w & 512 && Td(h, h.return);
          break;
        case 3:
          if (xa(l, h), w & 64 && (l = h.updateQueue, l !== null)) {
            if (f = null, h.child !== null)
              switch (h.child.tag) {
                case 27:
                case 5:
                  f = h.child.stateNode;
                  break;
                case 1:
                  f = h.child.stateNode;
              }
            try {
              PO(l, f);
            } catch (q) {
              Kt(h, h.return, q);
            }
          }
          break;
        case 27:
          f === null && w & 4 && GM(h);
        case 26:
        case 5:
          xa(l, h), f === null && w & 4 && qM(h), w & 512 && Td(h, h.return);
          break;
        case 12:
          xa(l, h);
          break;
        case 31:
          xa(l, h), w & 4 && QM(l, h);
          break;
        case 13:
          xa(l, h), w & 4 && JM(l, h), w & 64 && (l = h.memoizedState, l !== null && (l = l.dehydrated, l !== null && (h = QW.bind(
            null,
            h
          ), vG(l, h))));
          break;
        case 22:
          if (w = h.memoizedState !== null || va, !w) {
            f = f !== null && f.memoizedState !== null || zn, R = va;
            var M = zn;
            va = w, (zn = f) && !M ? wa(
              l,
              h,
              (h.subtreeFlags & 8772) !== 0
            ) : xa(l, h), va = R, zn = M;
          }
          break;
        case 30:
          break;
        default:
          xa(l, h);
      }
    }
    function XM(l) {
      var f = l.alternate;
      f !== null && (l.alternate = null, XM(f)), l.child = null, l.deletions = null, l.sibling = null, l.tag === 5 && (f = l.stateNode, f !== null && Jf(f)), l.stateNode = null, l.return = null, l.dependencies = null, l.memoizedProps = null, l.memoizedState = null, l.pendingProps = null, l.stateNode = null, l.updateQueue = null;
    }
    var wn = null, Ir = !1;
    function ba(l, f, h) {
      for (h = h.child; h !== null; )
        ZM(l, f, h), h = h.sibling;
    }
    function ZM(l, f, h) {
      if (Et && typeof Et.onCommitFiberUnmount == "function")
        try {
          Et.onCommitFiberUnmount(it, h);
        } catch {
        }
      switch (h.tag) {
        case 26:
          zn || hi(h, f), ba(
            l,
            f,
            h
          ), h.memoizedState ? h.memoizedState.count-- : h.stateNode && (h = h.stateNode, h.parentNode.removeChild(h));
          break;
        case 27:
          zn || hi(h, f);
          var w = wn, R = Ir;
          Os(h.type) && (wn = h.stateNode, Ir = !1), ba(
            l,
            f,
            h
          ), jd(h.stateNode), wn = w, Ir = R;
          break;
        case 5:
          zn || hi(h, f);
        case 6:
          if (w = wn, R = Ir, wn = null, ba(
            l,
            f,
            h
          ), wn = w, Ir = R, wn !== null)
            if (Ir)
              try {
                (wn.nodeType === 9 ? wn.body : wn.nodeName === "HTML" ? wn.ownerDocument.body : wn).removeChild(h.stateNode);
              } catch (M) {
                Kt(
                  h,
                  f,
                  M
                );
              }
            else
              try {
                wn.removeChild(h.stateNode);
              } catch (M) {
                Kt(
                  h,
                  f,
                  M
                );
              }
          break;
        case 18:
          wn !== null && (Ir ? (l = wn, VN(
            l.nodeType === 9 ? l.body : l.nodeName === "HTML" ? l.ownerDocument.body : l,
            h.stateNode
          ), bu(l)) : VN(wn, h.stateNode));
          break;
        case 4:
          w = wn, R = Ir, wn = h.stateNode.containerInfo, Ir = !0, ba(
            l,
            f,
            h
          ), wn = w, Ir = R;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          _s(2, h, f), zn || _s(4, h, f), ba(
            l,
            f,
            h
          );
          break;
        case 1:
          zn || (hi(h, f), w = h.stateNode, typeof w.componentWillUnmount == "function" && HM(
            h,
            f,
            w
          )), ba(
            l,
            f,
            h
          );
          break;
        case 21:
          ba(
            l,
            f,
            h
          );
          break;
        case 22:
          zn = (w = zn) || h.memoizedState !== null, ba(
            l,
            f,
            h
          ), zn = w;
          break;
        default:
          ba(
            l,
            f,
            h
          );
      }
    }
    function QM(l, f) {
      if (f.memoizedState === null && (l = f.alternate, l !== null && (l = l.memoizedState, l !== null))) {
        l = l.dehydrated;
        try {
          bu(l);
        } catch (h) {
          Kt(f, f.return, h);
        }
      }
    }
    function JM(l, f) {
      if (f.memoizedState === null && (l = f.alternate, l !== null && (l = l.memoizedState, l !== null && (l = l.dehydrated, l !== null))))
        try {
          bu(l);
        } catch (h) {
          Kt(f, f.return, h);
        }
    }
    function HW(l) {
      switch (l.tag) {
        case 31:
        case 13:
        case 19:
          var f = l.stateNode;
          return f === null && (f = l.stateNode = new KM()), f;
        case 22:
          return l = l.stateNode, f = l._retryCache, f === null && (f = l._retryCache = new KM()), f;
        default:
          throw Error(r(435, l.tag));
      }
    }
    function xg(l, f) {
      var h = HW(l);
      f.forEach(function(w) {
        if (!h.has(w)) {
          h.add(w);
          var R = JW.bind(null, l, w);
          w.then(R, R);
        }
      });
    }
    function $r(l, f) {
      var h = f.deletions;
      if (h !== null)
        for (var w = 0; w < h.length; w++) {
          var R = h[w], M = l, q = f, Z = q;
          e: for (; Z !== null; ) {
            switch (Z.tag) {
              case 27:
                if (Os(Z.type)) {
                  wn = Z.stateNode, Ir = !1;
                  break e;
                }
                break;
              case 5:
                wn = Z.stateNode, Ir = !1;
                break e;
              case 3:
              case 4:
                wn = Z.stateNode.containerInfo, Ir = !0;
                break e;
            }
            Z = Z.return;
          }
          if (wn === null) throw Error(r(160));
          ZM(M, q, R), wn = null, Ir = !1, M = R.alternate, M !== null && (M.return = null), R.return = null;
        }
      if (f.subtreeFlags & 13886)
        for (f = f.child; f !== null; )
          eN(f, l), f = f.sibling;
    }
    var Uo = null;
    function eN(l, f) {
      var h = l.alternate, w = l.flags;
      switch (l.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          $r(f, l), jr(l), w & 4 && (_s(3, l, l.return), kd(3, l), _s(5, l, l.return));
          break;
        case 1:
          $r(f, l), jr(l), w & 512 && (zn || h === null || hi(h, h.return)), w & 64 && va && (l = l.updateQueue, l !== null && (w = l.callbacks, w !== null && (h = l.shared.hiddenCallbacks, l.shared.hiddenCallbacks = h === null ? w : h.concat(w))));
          break;
        case 26:
          var R = Uo;
          if ($r(f, l), jr(l), w & 512 && (zn || h === null || hi(h, h.return)), w & 4) {
            var M = h !== null ? h.memoizedState : null;
            if (w = l.memoizedState, h === null)
              if (w === null)
                if (l.stateNode === null) {
                  e: {
                    w = l.type, h = l.memoizedProps, R = R.ownerDocument || R;
                    t: switch (w) {
                      case "title":
                        M = R.getElementsByTagName("title")[0], (!M || M[xl] || M[Wn] || M.namespaceURI === "http://www.w3.org/2000/svg" || M.hasAttribute("itemprop")) && (M = R.createElement(w), R.head.insertBefore(
                          M,
                          R.querySelector("head > title")
                        )), ar(M, w, h), M[Wn] = l, jn(M), w = M;
                        break e;
                      case "link":
                        var q = eP(
                          "link",
                          "href",
                          R
                        ).get(w + (h.href || ""));
                        if (q) {
                          for (var Z = 0; Z < q.length; Z++)
                            if (M = q[Z], M.getAttribute("href") === (h.href == null || h.href === "" ? null : h.href) && M.getAttribute("rel") === (h.rel == null ? null : h.rel) && M.getAttribute("title") === (h.title == null ? null : h.title) && M.getAttribute("crossorigin") === (h.crossOrigin == null ? null : h.crossOrigin)) {
                              q.splice(Z, 1);
                              break t;
                            }
                        }
                        M = R.createElement(w), ar(M, w, h), R.head.appendChild(M);
                        break;
                      case "meta":
                        if (q = eP(
                          "meta",
                          "content",
                          R
                        ).get(w + (h.content || ""))) {
                          for (Z = 0; Z < q.length; Z++)
                            if (M = q[Z], M.getAttribute("content") === (h.content == null ? null : "" + h.content) && M.getAttribute("name") === (h.name == null ? null : h.name) && M.getAttribute("property") === (h.property == null ? null : h.property) && M.getAttribute("http-equiv") === (h.httpEquiv == null ? null : h.httpEquiv) && M.getAttribute("charset") === (h.charSet == null ? null : h.charSet)) {
                              q.splice(Z, 1);
                              break t;
                            }
                        }
                        M = R.createElement(w), ar(M, w, h), R.head.appendChild(M);
                        break;
                      default:
                        throw Error(r(468, w));
                    }
                    M[Wn] = l, jn(M), w = M;
                  }
                  l.stateNode = w;
                } else
                  tP(
                    R,
                    l.type,
                    l.stateNode
                  );
              else
                l.stateNode = JN(
                  R,
                  w,
                  l.memoizedProps
                );
            else
              M !== w ? (M === null ? h.stateNode !== null && (h = h.stateNode, h.parentNode.removeChild(h)) : M.count--, w === null ? tP(
                R,
                l.type,
                l.stateNode
              ) : JN(
                R,
                w,
                l.memoizedProps
              )) : w === null && l.stateNode !== null && pw(
                l,
                l.memoizedProps,
                h.memoizedProps
              );
          }
          break;
        case 27:
          $r(f, l), jr(l), w & 512 && (zn || h === null || hi(h, h.return)), h !== null && w & 4 && pw(
            l,
            l.memoizedProps,
            h.memoizedProps
          );
          break;
        case 5:
          if ($r(f, l), jr(l), w & 512 && (zn || h === null || hi(h, h.return)), l.flags & 32) {
            R = l.stateNode;
            try {
              Uc(R, "");
            } catch (Fe) {
              Kt(l, l.return, Fe);
            }
          }
          w & 4 && l.stateNode != null && (R = l.memoizedProps, pw(
            l,
            R,
            h !== null ? h.memoizedProps : R
          )), w & 1024 && (gw = !0);
          break;
        case 6:
          if ($r(f, l), jr(l), w & 4) {
            if (l.stateNode === null)
              throw Error(r(162));
            w = l.memoizedProps, h = l.stateNode;
            try {
              h.nodeValue = w;
            } catch (Fe) {
              Kt(l, l.return, Fe);
            }
          }
          break;
        case 3:
          if (jg = null, R = Uo, Uo = Ig(f.containerInfo), $r(f, l), Uo = R, jr(l), w & 4 && h !== null && h.memoizedState.isDehydrated)
            try {
              bu(f.containerInfo);
            } catch (Fe) {
              Kt(l, l.return, Fe);
            }
          gw && (gw = !1, tN(l));
          break;
        case 4:
          w = Uo, Uo = Ig(
            l.stateNode.containerInfo
          ), $r(f, l), jr(l), Uo = w;
          break;
        case 12:
          $r(f, l), jr(l);
          break;
        case 31:
          $r(f, l), jr(l), w & 4 && (w = l.updateQueue, w !== null && (l.updateQueue = null, xg(l, w)));
          break;
        case 13:
          $r(f, l), jr(l), l.child.flags & 8192 && l.memoizedState !== null != (h !== null && h.memoizedState !== null) && (Sg = Je()), w & 4 && (w = l.updateQueue, w !== null && (l.updateQueue = null, xg(l, w)));
          break;
        case 22:
          R = l.memoizedState !== null;
          var re = h !== null && h.memoizedState !== null, pe = va, ve = zn;
          if (va = pe || R, zn = ve || re, $r(f, l), zn = ve, va = pe, jr(l), w & 8192)
            e: for (f = l.stateNode, f._visibility = R ? f._visibility & -2 : f._visibility | 1, R && (h === null || re || va || zn || Dl(l)), h = null, f = l; ; ) {
              if (f.tag === 5 || f.tag === 26) {
                if (h === null) {
                  re = h = f;
                  try {
                    if (M = re.stateNode, R)
                      q = M.style, typeof q.setProperty == "function" ? q.setProperty("display", "none", "important") : q.display = "none";
                    else {
                      Z = re.stateNode;
                      var we = re.memoizedProps.style, he = we != null && we.hasOwnProperty("display") ? we.display : null;
                      Z.style.display = he == null || typeof he == "boolean" ? "" : ("" + he).trim();
                    }
                  } catch (Fe) {
                    Kt(re, re.return, Fe);
                  }
                }
              } else if (f.tag === 6) {
                if (h === null) {
                  re = f;
                  try {
                    re.stateNode.nodeValue = R ? "" : re.memoizedProps;
                  } catch (Fe) {
                    Kt(re, re.return, Fe);
                  }
                }
              } else if (f.tag === 18) {
                if (h === null) {
                  re = f;
                  try {
                    var ye = re.stateNode;
                    R ? HN(ye, !0) : HN(re.stateNode, !1);
                  } catch (Fe) {
                    Kt(re, re.return, Fe);
                  }
                }
              } else if ((f.tag !== 22 && f.tag !== 23 || f.memoizedState === null || f === l) && f.child !== null) {
                f.child.return = f, f = f.child;
                continue;
              }
              if (f === l) break e;
              for (; f.sibling === null; ) {
                if (f.return === null || f.return === l) break e;
                h === f && (h = null), f = f.return;
              }
              h === f && (h = null), f.sibling.return = f.return, f = f.sibling;
            }
          w & 4 && (w = l.updateQueue, w !== null && (h = w.retryQueue, h !== null && (w.retryQueue = null, xg(l, h))));
          break;
        case 19:
          $r(f, l), jr(l), w & 4 && (w = l.updateQueue, w !== null && (l.updateQueue = null, xg(l, w)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          $r(f, l), jr(l);
      }
    }
    function jr(l) {
      var f = l.flags;
      if (f & 2) {
        try {
          for (var h, w = l.return; w !== null; ) {
            if (WM(w)) {
              h = w;
              break;
            }
            w = w.return;
          }
          if (h == null) throw Error(r(160));
          switch (h.tag) {
            case 27:
              var R = h.stateNode, M = hw(l);
              bg(l, M, R);
              break;
            case 5:
              var q = h.stateNode;
              h.flags & 32 && (Uc(q, ""), h.flags &= -33);
              var Z = hw(l);
              bg(l, Z, q);
              break;
            case 3:
            case 4:
              var re = h.stateNode.containerInfo, pe = hw(l);
              mw(
                l,
                pe,
                re
              );
              break;
            default:
              throw Error(r(161));
          }
        } catch (ve) {
          Kt(l, l.return, ve);
        }
        l.flags &= -3;
      }
      f & 4096 && (l.flags &= -4097);
    }
    function tN(l) {
      if (l.subtreeFlags & 1024)
        for (l = l.child; l !== null; ) {
          var f = l;
          tN(f), f.tag === 5 && f.flags & 1024 && f.stateNode.reset(), l = l.sibling;
        }
    }
    function xa(l, f) {
      if (f.subtreeFlags & 8772)
        for (f = f.child; f !== null; )
          YM(l, f.alternate, f), f = f.sibling;
    }
    function Dl(l) {
      for (l = l.child; l !== null; ) {
        var f = l;
        switch (f.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            _s(4, f, f.return), Dl(f);
            break;
          case 1:
            hi(f, f.return);
            var h = f.stateNode;
            typeof h.componentWillUnmount == "function" && HM(
              f,
              f.return,
              h
            ), Dl(f);
            break;
          case 27:
            jd(f.stateNode);
          case 26:
          case 5:
            hi(f, f.return), Dl(f);
            break;
          case 22:
            f.memoizedState === null && Dl(f);
            break;
          case 30:
            Dl(f);
            break;
          default:
            Dl(f);
        }
        l = l.sibling;
      }
    }
    function wa(l, f, h) {
      for (h = h && (f.subtreeFlags & 8772) !== 0, f = f.child; f !== null; ) {
        var w = f.alternate, R = l, M = f, q = M.flags;
        switch (M.tag) {
          case 0:
          case 11:
          case 15:
            wa(
              R,
              M,
              h
            ), kd(4, M);
            break;
          case 1:
            if (wa(
              R,
              M,
              h
            ), w = M, R = w.stateNode, typeof R.componentDidMount == "function")
              try {
                R.componentDidMount();
              } catch (pe) {
                Kt(w, w.return, pe);
              }
            if (w = M, R = w.updateQueue, R !== null) {
              var Z = w.stateNode;
              try {
                var re = R.shared.hiddenCallbacks;
                if (re !== null)
                  for (R.shared.hiddenCallbacks = null, R = 0; R < re.length; R++)
                    NO(re[R], Z);
              } catch (pe) {
                Kt(w, w.return, pe);
              }
            }
            h && q & 64 && VM(M), Td(M, M.return);
            break;
          case 27:
            GM(M);
          case 26:
          case 5:
            wa(
              R,
              M,
              h
            ), h && w === null && q & 4 && qM(M), Td(M, M.return);
            break;
          case 12:
            wa(
              R,
              M,
              h
            );
            break;
          case 31:
            wa(
              R,
              M,
              h
            ), h && q & 4 && QM(R, M);
            break;
          case 13:
            wa(
              R,
              M,
              h
            ), h && q & 4 && JM(R, M);
            break;
          case 22:
            M.memoizedState === null && wa(
              R,
              M,
              h
            ), Td(M, M.return);
            break;
          case 30:
            break;
          default:
            wa(
              R,
              M,
              h
            );
        }
        f = f.sibling;
      }
    }
    function yw(l, f) {
      var h = null;
      l !== null && l.memoizedState !== null && l.memoizedState.cachePool !== null && (h = l.memoizedState.cachePool.pool), l = null, f.memoizedState !== null && f.memoizedState.cachePool !== null && (l = f.memoizedState.cachePool.pool), l !== h && (l != null && l.refCount++, h != null && pd(h));
    }
    function vw(l, f) {
      l = null, f.alternate !== null && (l = f.alternate.memoizedState.cache), f = f.memoizedState.cache, f !== l && (f.refCount++, l != null && pd(l));
    }
    function Vo(l, f, h, w) {
      if (f.subtreeFlags & 10256)
        for (f = f.child; f !== null; )
          nN(
            l,
            f,
            h,
            w
          ), f = f.sibling;
    }
    function nN(l, f, h, w) {
      var R = f.flags;
      switch (f.tag) {
        case 0:
        case 11:
        case 15:
          Vo(
            l,
            f,
            h,
            w
          ), R & 2048 && kd(9, f);
          break;
        case 1:
          Vo(
            l,
            f,
            h,
            w
          );
          break;
        case 3:
          Vo(
            l,
            f,
            h,
            w
          ), R & 2048 && (l = null, f.alternate !== null && (l = f.alternate.memoizedState.cache), f = f.memoizedState.cache, f !== l && (f.refCount++, l != null && pd(l)));
          break;
        case 12:
          if (R & 2048) {
            Vo(
              l,
              f,
              h,
              w
            ), l = f.stateNode;
            try {
              var M = f.memoizedProps, q = M.id, Z = M.onPostCommit;
              typeof Z == "function" && Z(
                q,
                f.alternate === null ? "mount" : "update",
                l.passiveEffectDuration,
                -0
              );
            } catch (re) {
              Kt(f, f.return, re);
            }
          } else
            Vo(
              l,
              f,
              h,
              w
            );
          break;
        case 31:
          Vo(
            l,
            f,
            h,
            w
          );
          break;
        case 13:
          Vo(
            l,
            f,
            h,
            w
          );
          break;
        case 23:
          break;
        case 22:
          M = f.stateNode, q = f.alternate, f.memoizedState !== null ? M._visibility & 2 ? Vo(
            l,
            f,
            h,
            w
          ) : Ad(l, f) : M._visibility & 2 ? Vo(
            l,
            f,
            h,
            w
          ) : (M._visibility |= 2, lu(
            l,
            f,
            h,
            w,
            (f.subtreeFlags & 10256) !== 0 || !1
          )), R & 2048 && yw(q, f);
          break;
        case 24:
          Vo(
            l,
            f,
            h,
            w
          ), R & 2048 && vw(f.alternate, f);
          break;
        default:
          Vo(
            l,
            f,
            h,
            w
          );
      }
    }
    function lu(l, f, h, w, R) {
      for (R = R && ((f.subtreeFlags & 10256) !== 0 || !1), f = f.child; f !== null; ) {
        var M = l, q = f, Z = h, re = w, pe = q.flags;
        switch (q.tag) {
          case 0:
          case 11:
          case 15:
            lu(
              M,
              q,
              Z,
              re,
              R
            ), kd(8, q);
            break;
          case 23:
            break;
          case 22:
            var ve = q.stateNode;
            q.memoizedState !== null ? ve._visibility & 2 ? lu(
              M,
              q,
              Z,
              re,
              R
            ) : Ad(
              M,
              q
            ) : (ve._visibility |= 2, lu(
              M,
              q,
              Z,
              re,
              R
            )), R && pe & 2048 && yw(
              q.alternate,
              q
            );
            break;
          case 24:
            lu(
              M,
              q,
              Z,
              re,
              R
            ), R && pe & 2048 && vw(q.alternate, q);
            break;
          default:
            lu(
              M,
              q,
              Z,
              re,
              R
            );
        }
        f = f.sibling;
      }
    }
    function Ad(l, f) {
      if (f.subtreeFlags & 10256)
        for (f = f.child; f !== null; ) {
          var h = l, w = f, R = w.flags;
          switch (w.tag) {
            case 22:
              Ad(h, w), R & 2048 && yw(
                w.alternate,
                w
              );
              break;
            case 24:
              Ad(h, w), R & 2048 && vw(w.alternate, w);
              break;
            default:
              Ad(h, w);
          }
          f = f.sibling;
        }
    }
    var Rd = 8192;
    function cu(l, f, h) {
      if (l.subtreeFlags & Rd)
        for (l = l.child; l !== null; )
          rN(
            l,
            f,
            h
          ), l = l.sibling;
    }
    function rN(l, f, h) {
      switch (l.tag) {
        case 26:
          cu(
            l,
            f,
            h
          ), l.flags & Rd && l.memoizedState !== null && OG(
            h,
            Uo,
            l.memoizedState,
            l.memoizedProps
          );
          break;
        case 5:
          cu(
            l,
            f,
            h
          );
          break;
        case 3:
        case 4:
          var w = Uo;
          Uo = Ig(l.stateNode.containerInfo), cu(
            l,
            f,
            h
          ), Uo = w;
          break;
        case 22:
          l.memoizedState === null && (w = l.alternate, w !== null && w.memoizedState !== null ? (w = Rd, Rd = 16777216, cu(
            l,
            f,
            h
          ), Rd = w) : cu(
            l,
            f,
            h
          ));
          break;
        default:
          cu(
            l,
            f,
            h
          );
      }
    }
    function oN(l) {
      var f = l.alternate;
      if (f !== null && (l = f.child, l !== null)) {
        f.child = null;
        do
          f = l.sibling, l.sibling = null, l = f;
        while (l !== null);
      }
    }
    function Od(l) {
      var f = l.deletions;
      if ((l.flags & 16) !== 0) {
        if (f !== null)
          for (var h = 0; h < f.length; h++) {
            var w = f[h];
            Qn = w, aN(
              w,
              l
            );
          }
        oN(l);
      }
      if (l.subtreeFlags & 10256)
        for (l = l.child; l !== null; )
          iN(l), l = l.sibling;
    }
    function iN(l) {
      switch (l.tag) {
        case 0:
        case 11:
        case 15:
          Od(l), l.flags & 2048 && _s(9, l, l.return);
          break;
        case 3:
          Od(l);
          break;
        case 12:
          Od(l);
          break;
        case 22:
          var f = l.stateNode;
          l.memoizedState !== null && f._visibility & 2 && (l.return === null || l.return.tag !== 13) ? (f._visibility &= -3, wg(l)) : Od(l);
          break;
        default:
          Od(l);
      }
    }
    function wg(l) {
      var f = l.deletions;
      if ((l.flags & 16) !== 0) {
        if (f !== null)
          for (var h = 0; h < f.length; h++) {
            var w = f[h];
            Qn = w, aN(
              w,
              l
            );
          }
        oN(l);
      }
      for (l = l.child; l !== null; ) {
        switch (f = l, f.tag) {
          case 0:
          case 11:
          case 15:
            _s(8, f, f.return), wg(f);
            break;
          case 22:
            h = f.stateNode, h._visibility & 2 && (h._visibility &= -3, wg(f));
            break;
          default:
            wg(f);
        }
        l = l.sibling;
      }
    }
    function aN(l, f) {
      for (; Qn !== null; ) {
        var h = Qn;
        switch (h.tag) {
          case 0:
          case 11:
          case 15:
            _s(8, h, f);
            break;
          case 23:
          case 22:
            if (h.memoizedState !== null && h.memoizedState.cachePool !== null) {
              var w = h.memoizedState.cachePool.pool;
              w != null && w.refCount++;
            }
            break;
          case 24:
            pd(h.memoizedState.cache);
        }
        if (w = h.child, w !== null) w.return = h, Qn = w;
        else
          e: for (h = l; Qn !== null; ) {
            w = Qn;
            var R = w.sibling, M = w.return;
            if (XM(w), w === h) {
              Qn = null;
              break e;
            }
            if (R !== null) {
              R.return = M, Qn = R;
              break e;
            }
            Qn = M;
          }
      }
    }
    var qW = {
      getCacheForType: function(l) {
        var f = or(Dn), h = f.data.get(l);
        return h === void 0 && (h = l(), f.data.set(l, h)), h;
      },
      cacheSignal: function() {
        return or(Dn).controller.signal;
      }
    }, WW = typeof WeakMap == "function" ? WeakMap : Map, zt = 0, sn = null, wt = null, Ct = 0, Gt = 0, Qr = null, Es = !1, uu = !1, bw = !1, Sa = 0, Tn = 0, Cs = 0, Fl = 0, xw = 0, Jr = 0, fu = 0, Md = null, Dr = null, ww = !1, Sg = 0, sN = 0, _g = 1 / 0, Eg = null, ks = null, Gn = 0, Ts = null, du = null, _a = 0, Sw = 0, _w = null, lN = null, Nd = 0, Ew = null;
    function eo() {
      return (zt & 2) !== 0 && Ct !== 0 ? Ct & -Ct : F.T !== null ? Ow() : Am();
    }
    function cN() {
      if (Jr === 0)
        if ((Ct & 536870912) === 0 || At) {
          var l = Lo;
          Lo <<= 1, (Lo & 3932160) === 0 && (Lo = 262144), Jr = l;
        } else Jr = 536870912;
      return l = Xr.current, l !== null && (l.flags |= 32), Jr;
    }
    function Fr(l, f, h) {
      (l === sn && (Gt === 2 || Gt === 9) || l.cancelPendingCommit !== null) && (pu(l, 0), As(
        l,
        Ct,
        Jr,
        !1
      )), bl(l, h), ((zt & 2) === 0 || l !== sn) && (l === sn && ((zt & 2) === 0 && (Fl |= h), Tn === 4 && As(
        l,
        Ct,
        Jr,
        !1
      )), mi(l));
    }
    function uN(l, f, h) {
      if ((zt & 6) !== 0) throw Error(r(327));
      var w = !h && (f & 127) === 0 && (f & l.expiredLanes) === 0 || yo(l, f), R = w ? YW(l, f) : kw(l, f, !0), M = w;
      do {
        if (R === 0) {
          uu && !w && As(l, f, 0, !1);
          break;
        } else {
          if (h = l.current.alternate, M && !GW(h)) {
            R = kw(l, f, !1), M = !1;
            continue;
          }
          if (R === 2) {
            if (M = f, l.errorRecoveryDisabledLanes & M)
              var q = 0;
            else
              q = l.pendingLanes & -536870913, q = q !== 0 ? q : q & 536870912 ? 536870912 : 0;
            if (q !== 0) {
              f = q;
              e: {
                var Z = l;
                R = Md;
                var re = Z.current.memoizedState.isDehydrated;
                if (re && (pu(Z, q).flags |= 256), q = kw(
                  Z,
                  q,
                  !1
                ), q !== 2) {
                  if (bw && !re) {
                    Z.errorRecoveryDisabledLanes |= M, Fl |= M, R = 4;
                    break e;
                  }
                  M = Dr, Dr = R, M !== null && (Dr === null ? Dr = M : Dr.push.apply(
                    Dr,
                    M
                  ));
                }
                R = q;
              }
              if (M = !1, R !== 2) continue;
            }
          }
          if (R === 1) {
            pu(l, 0), As(l, f, 0, !0);
            break;
          }
          e: {
            switch (w = l, M = R, M) {
              case 0:
              case 1:
                throw Error(r(345));
              case 4:
                if ((f & 4194048) !== f) break;
              case 6:
                As(
                  w,
                  f,
                  Jr,
                  !Es
                );
                break e;
              case 2:
                Dr = null;
                break;
              case 3:
              case 5:
                break;
              default:
                throw Error(r(329));
            }
            if ((f & 62914560) === f && (R = Sg + 300 - Je(), 10 < R)) {
              if (As(
                w,
                f,
                Jr,
                !Es
              ), ui(w, 0, !0) !== 0) break e;
              _a = f, w.timeoutHandle = BN(
                fN.bind(
                  null,
                  w,
                  h,
                  Dr,
                  Eg,
                  ww,
                  f,
                  Jr,
                  Fl,
                  fu,
                  Es,
                  M,
                  "Throttled",
                  -0,
                  0
                ),
                R
              );
              break e;
            }
            fN(
              w,
              h,
              Dr,
              Eg,
              ww,
              f,
              Jr,
              Fl,
              fu,
              Es,
              M,
              null,
              -0,
              0
            );
          }
        }
        break;
      } while (!0);
      mi(l);
    }
    function fN(l, f, h, w, R, M, q, Z, re, pe, ve, we, he, ye) {
      if (l.timeoutHandle = -1, we = f.subtreeFlags, we & 8192 || (we & 16785408) === 16785408) {
        we = {
          stylesheets: null,
          count: 0,
          imgCount: 0,
          imgBytes: 0,
          suspenseyImages: [],
          waitingForImages: !0,
          waitingForViewTransition: !1,
          unsuspend: la
        }, rN(
          f,
          M,
          we
        );
        var Fe = (M & 62914560) === M ? Sg - Je() : (M & 4194048) === M ? sN - Je() : 0;
        if (Fe = MG(
          we,
          Fe
        ), Fe !== null) {
          _a = M, l.cancelPendingCommit = Fe(
            bN.bind(
              null,
              l,
              f,
              M,
              h,
              w,
              R,
              q,
              Z,
              re,
              ve,
              we,
              null,
              he,
              ye
            )
          ), As(l, M, q, !pe);
          return;
        }
      }
      bN(
        l,
        f,
        M,
        h,
        w,
        R,
        q,
        Z,
        re
      );
    }
    function GW(l) {
      for (var f = l; ; ) {
        var h = f.tag;
        if ((h === 0 || h === 11 || h === 15) && f.flags & 16384 && (h = f.updateQueue, h !== null && (h = h.stores, h !== null)))
          for (var w = 0; w < h.length; w++) {
            var R = h[w], M = R.getSnapshot;
            R = R.value;
            try {
              if (!Kr(M(), R)) return !1;
            } catch {
              return !1;
            }
          }
        if (h = f.child, f.subtreeFlags & 16384 && h !== null)
          h.return = f, f = h;
        else {
          if (f === l) break;
          for (; f.sibling === null; ) {
            if (f.return === null || f.return === l) return !0;
            f = f.return;
          }
          f.sibling.return = f.return, f = f.sibling;
        }
      }
      return !0;
    }
    function As(l, f, h, w) {
      f &= ~xw, f &= ~Fl, l.suspendedLanes |= f, l.pingedLanes &= ~f, w && (l.warmLanes |= f), w = l.expirationTimes;
      for (var R = f; 0 < R; ) {
        var M = 31 - Mt(R), q = 1 << M;
        w[M] = -1, R &= ~q;
      }
      h !== 0 && Cm(l, h, f);
    }
    function Cg() {
      return (zt & 6) === 0 ? (Pd(0), !1) : !0;
    }
    function Cw() {
      if (wt !== null) {
        if (Gt === 0)
          var l = wt.return;
        else
          l = wt, da = Rl = null, Bx(l), ru = null, md = 0, l = wt;
        for (; l !== null; )
          UM(l.alternate, l), l = l.return;
        wt = null;
      }
    }
    function pu(l, f) {
      var h = l.timeoutHandle;
      h !== -1 && (l.timeoutHandle = -1, pG(h)), h = l.cancelPendingCommit, h !== null && (l.cancelPendingCommit = null, h()), _a = 0, Cw(), sn = l, wt = h = ua(l.current, null), Ct = f, Gt = 0, Qr = null, Es = !1, uu = yo(l, f), bw = !1, fu = Jr = xw = Fl = Cs = Tn = 0, Dr = Md = null, ww = !1, (f & 8) !== 0 && (f |= f & 32);
      var w = l.entangledLanes;
      if (w !== 0)
        for (l = l.entanglements, w &= f; 0 < w; ) {
          var R = 31 - Mt(w), M = 1 << R;
          f |= l[R], w &= ~M;
        }
      return Sa = f, Wm(), h;
    }
    function dN(l, f) {
      lt = null, F.H = _d, f === nu || f === eg ? (f = AO(), Gt = 3) : f === Rx ? (f = AO(), Gt = 4) : Gt = f === rw ? 8 : f !== null && typeof f == "object" && typeof f.then == "function" ? 6 : 1, Qr = f, wt === null && (Tn = 1, hg(
        l,
        bo(f, l.current)
      ));
    }
    function pN() {
      var l = Xr.current;
      return l === null ? !0 : (Ct & 4194048) === Ct ? _o === null : (Ct & 62914560) === Ct || (Ct & 536870912) !== 0 ? l === _o : !1;
    }
    function hN() {
      var l = F.H;
      return F.H = _d, l === null ? _d : l;
    }
    function mN() {
      var l = F.A;
      return F.A = qW, l;
    }
    function kg() {
      Tn = 4, Es || (Ct & 4194048) !== Ct && Xr.current !== null || (uu = !0), (Cs & 134217727) === 0 && (Fl & 134217727) === 0 || sn === null || As(
        sn,
        Ct,
        Jr,
        !1
      );
    }
    function kw(l, f, h) {
      var w = zt;
      zt |= 2;
      var R = hN(), M = mN();
      (sn !== l || Ct !== f) && (Eg = null, pu(l, f)), f = !1;
      var q = Tn;
      e: do
        try {
          if (Gt !== 0 && wt !== null) {
            var Z = wt, re = Qr;
            switch (Gt) {
              case 8:
                Cw(), q = 6;
                break e;
              case 3:
              case 2:
              case 9:
              case 6:
                Xr.current === null && (f = !0);
                var pe = Gt;
                if (Gt = 0, Qr = null, hu(l, Z, re, pe), h && uu) {
                  q = 0;
                  break e;
                }
                break;
              default:
                pe = Gt, Gt = 0, Qr = null, hu(l, Z, re, pe);
            }
          }
          KW(), q = Tn;
          break;
        } catch (ve) {
          dN(l, ve);
        }
      while (!0);
      return f && l.shellSuspendCounter++, da = Rl = null, zt = w, F.H = R, F.A = M, wt === null && (sn = null, Ct = 0, Wm()), q;
    }
    function KW() {
      for (; wt !== null; ) gN(wt);
    }
    function YW(l, f) {
      var h = zt;
      zt |= 2;
      var w = hN(), R = mN();
      sn !== l || Ct !== f ? (Eg = null, _g = Je() + 500, pu(l, f)) : uu = yo(
        l,
        f
      );
      e: do
        try {
          if (Gt !== 0 && wt !== null) {
            f = wt;
            var M = Qr;
            t: switch (Gt) {
              case 1:
                Gt = 0, Qr = null, hu(l, f, M, 1);
                break;
              case 2:
              case 9:
                if (kO(M)) {
                  Gt = 0, Qr = null, yN(f);
                  break;
                }
                f = function() {
                  Gt !== 2 && Gt !== 9 || sn !== l || (Gt = 7), mi(l);
                }, M.then(f, f);
                break e;
              case 3:
                Gt = 7;
                break e;
              case 4:
                Gt = 5;
                break e;
              case 7:
                kO(M) ? (Gt = 0, Qr = null, yN(f)) : (Gt = 0, Qr = null, hu(l, f, M, 7));
                break;
              case 5:
                var q = null;
                switch (wt.tag) {
                  case 26:
                    q = wt.memoizedState;
                  case 5:
                  case 27:
                    var Z = wt;
                    if (q ? nP(q) : Z.stateNode.complete) {
                      Gt = 0, Qr = null;
                      var re = Z.sibling;
                      if (re !== null) wt = re;
                      else {
                        var pe = Z.return;
                        pe !== null ? (wt = pe, Tg(pe)) : wt = null;
                      }
                      break t;
                    }
                }
                Gt = 0, Qr = null, hu(l, f, M, 5);
                break;
              case 6:
                Gt = 0, Qr = null, hu(l, f, M, 6);
                break;
              case 8:
                Cw(), Tn = 6;
                break e;
              default:
                throw Error(r(462));
            }
          }
          XW();
          break;
        } catch (ve) {
          dN(l, ve);
        }
      while (!0);
      return da = Rl = null, F.H = w, F.A = R, zt = h, wt !== null ? 0 : (sn = null, Ct = 0, Wm(), Tn);
    }
    function XW() {
      for (; wt !== null && !Ne(); )
        gN(wt);
    }
    function gN(l) {
      var f = zM(l.alternate, l, Sa);
      l.memoizedProps = l.pendingProps, f === null ? Tg(l) : wt = f;
    }
    function yN(l) {
      var f = l, h = f.alternate;
      switch (f.tag) {
        case 15:
        case 0:
          f = IM(
            h,
            f,
            f.pendingProps,
            f.type,
            void 0,
            Ct
          );
          break;
        case 11:
          f = IM(
            h,
            f,
            f.pendingProps,
            f.type.render,
            f.ref,
            Ct
          );
          break;
        case 5:
          Bx(f);
        default:
          UM(h, f), f = wt = mO(f, Sa), f = zM(h, f, Sa);
      }
      l.memoizedProps = l.pendingProps, f === null ? Tg(l) : wt = f;
    }
    function hu(l, f, h, w) {
      da = Rl = null, Bx(f), ru = null, md = 0;
      var R = f.return;
      try {
        if (FW(
          l,
          R,
          f,
          h,
          Ct
        )) {
          Tn = 1, hg(
            l,
            bo(h, l.current)
          ), wt = null;
          return;
        }
      } catch (M) {
        if (R !== null) throw wt = R, M;
        Tn = 1, hg(
          l,
          bo(h, l.current)
        ), wt = null;
        return;
      }
      f.flags & 32768 ? (At || w === 1 ? l = !0 : uu || (Ct & 536870912) !== 0 ? l = !1 : (Es = l = !0, (w === 2 || w === 9 || w === 3 || w === 6) && (w = Xr.current, w !== null && w.tag === 13 && (w.flags |= 16384))), vN(f, l)) : Tg(f);
    }
    function Tg(l) {
      var f = l;
      do {
        if ((f.flags & 32768) !== 0) {
          vN(
            f,
            Es
          );
          return;
        }
        l = f.return;
        var h = BW(
          f.alternate,
          f,
          Sa
        );
        if (h !== null) {
          wt = h;
          return;
        }
        if (f = f.sibling, f !== null) {
          wt = f;
          return;
        }
        wt = f = l;
      } while (f !== null);
      Tn === 0 && (Tn = 5);
    }
    function vN(l, f) {
      do {
        var h = UW(l.alternate, l);
        if (h !== null) {
          h.flags &= 32767, wt = h;
          return;
        }
        if (h = l.return, h !== null && (h.flags |= 32768, h.subtreeFlags = 0, h.deletions = null), !f && (l = l.sibling, l !== null)) {
          wt = l;
          return;
        }
        wt = l = h;
      } while (l !== null);
      Tn = 6, wt = null;
    }
    function bN(l, f, h, w, R, M, q, Z, re) {
      l.cancelPendingCommit = null;
      do
        Ag();
      while (Gn !== 0);
      if ((zt & 6) !== 0) throw Error(r(327));
      if (f !== null) {
        if (f === l.current) throw Error(r(177));
        if (M = f.lanes | f.childLanes, M |= hx, H1(
          l,
          h,
          M,
          q,
          Z,
          re
        ), l === sn && (wt = sn = null, Ct = 0), du = f, Ts = l, _a = h, Sw = M, _w = R, lN = w, (f.subtreeFlags & 10256) !== 0 || (f.flags & 10256) !== 0 ? (l.callbackNode = null, l.callbackPriority = 0, eG(_e, function() {
          return EN(), null;
        })) : (l.callbackNode = null, l.callbackPriority = 0), w = (f.flags & 13878) !== 0, (f.subtreeFlags & 13878) !== 0 || w) {
          w = F.T, F.T = null, R = K.p, K.p = 2, q = zt, zt |= 4;
          try {
            VW(l, f, h);
          } finally {
            zt = q, K.p = R, F.T = w;
          }
        }
        Gn = 1, xN(), wN(), SN();
      }
    }
    function xN() {
      if (Gn === 1) {
        Gn = 0;
        var l = Ts, f = du, h = (f.flags & 13878) !== 0;
        if ((f.subtreeFlags & 13878) !== 0 || h) {
          h = F.T, F.T = null;
          var w = K.p;
          K.p = 2;
          var R = zt;
          zt |= 4;
          try {
            eN(f, l);
            var M = Fw, q = aO(l.containerInfo), Z = M.focusedElem, re = M.selectionRange;
            if (q !== Z && Z && Z.ownerDocument && iO(
              Z.ownerDocument.documentElement,
              Z
            )) {
              if (re !== null && cx(Z)) {
                var pe = re.start, ve = re.end;
                if (ve === void 0 && (ve = pe), "selectionStart" in Z)
                  Z.selectionStart = pe, Z.selectionEnd = Math.min(
                    ve,
                    Z.value.length
                  );
                else {
                  var we = Z.ownerDocument || document, he = we && we.defaultView || window;
                  if (he.getSelection) {
                    var ye = he.getSelection(), Fe = Z.textContent.length, et = Math.min(re.start, Fe), tn = re.end === void 0 ? et : Math.min(re.end, Fe);
                    !ye.extend && et > tn && (q = tn, tn = et, et = q);
                    var ce = oO(
                      Z,
                      et
                    ), ae = oO(
                      Z,
                      tn
                    );
                    if (ce && ae && (ye.rangeCount !== 1 || ye.anchorNode !== ce.node || ye.anchorOffset !== ce.offset || ye.focusNode !== ae.node || ye.focusOffset !== ae.offset)) {
                      var de = we.createRange();
                      de.setStart(ce.node, ce.offset), ye.removeAllRanges(), et > tn ? (ye.addRange(de), ye.extend(ae.node, ae.offset)) : (de.setEnd(ae.node, ae.offset), ye.addRange(de));
                    }
                  }
                }
              }
              for (we = [], ye = Z; ye = ye.parentNode; )
                ye.nodeType === 1 && we.push({
                  element: ye,
                  left: ye.scrollLeft,
                  top: ye.scrollTop
                });
              for (typeof Z.focus == "function" && Z.focus(), Z = 0; Z < we.length; Z++) {
                var xe = we[Z];
                xe.element.scrollLeft = xe.left, xe.element.scrollTop = xe.top;
              }
            }
            zg = !!Dw, Fw = Dw = null;
          } finally {
            zt = R, K.p = w, F.T = h;
          }
        }
        l.current = f, Gn = 2;
      }
    }
    function wN() {
      if (Gn === 2) {
        Gn = 0;
        var l = Ts, f = du, h = (f.flags & 8772) !== 0;
        if ((f.subtreeFlags & 8772) !== 0 || h) {
          h = F.T, F.T = null;
          var w = K.p;
          K.p = 2;
          var R = zt;
          zt |= 4;
          try {
            YM(l, f.alternate, f);
          } finally {
            zt = R, K.p = w, F.T = h;
          }
        }
        Gn = 3;
      }
    }
    function SN() {
      if (Gn === 4 || Gn === 3) {
        Gn = 0, mt();
        var l = Ts, f = du, h = _a, w = lN;
        (f.subtreeFlags & 10256) !== 0 || (f.flags & 10256) !== 0 ? Gn = 5 : (Gn = 0, du = Ts = null, _N(l, l.pendingLanes));
        var R = l.pendingLanes;
        if (R === 0 && (ks = null), Qf(h), f = f.stateNode, Et && typeof Et.onCommitFiberRoot == "function")
          try {
            Et.onCommitFiberRoot(
              it,
              f,
              void 0,
              (f.current.flags & 128) === 128
            );
          } catch {
          }
        if (w !== null) {
          f = F.T, R = K.p, K.p = 2, F.T = null;
          try {
            for (var M = l.onRecoverableError, q = 0; q < w.length; q++) {
              var Z = w[q];
              M(Z.value, {
                componentStack: Z.stack
              });
            }
          } finally {
            F.T = f, K.p = R;
          }
        }
        (_a & 3) !== 0 && Ag(), mi(l), R = l.pendingLanes, (h & 261930) !== 0 && (R & 42) !== 0 ? l === Ew ? Nd++ : (Nd = 0, Ew = l) : Nd = 0, Pd(0);
      }
    }
    function _N(l, f) {
      (l.pooledCacheLanes &= f) === 0 && (f = l.pooledCache, f != null && (l.pooledCache = null, pd(f)));
    }
    function Ag() {
      return xN(), wN(), SN(), EN();
    }
    function EN() {
      if (Gn !== 5) return !1;
      var l = Ts, f = Sw;
      Sw = 0;
      var h = Qf(_a), w = F.T, R = K.p;
      try {
        K.p = 32 > h ? 32 : h, F.T = null, h = _w, _w = null;
        var M = Ts, q = _a;
        if (Gn = 0, du = Ts = null, _a = 0, (zt & 6) !== 0) throw Error(r(331));
        var Z = zt;
        if (zt |= 4, iN(M.current), nN(
          M,
          M.current,
          q,
          h
        ), zt = Z, Pd(0, !1), Et && typeof Et.onPostCommitFiberRoot == "function")
          try {
            Et.onPostCommitFiberRoot(it, M);
          } catch {
          }
        return !0;
      } finally {
        K.p = R, F.T = w, _N(l, f);
      }
    }
    function CN(l, f, h) {
      f = bo(h, f), f = nw(l.stateNode, f, 2), l = xs(l, f, 2), l !== null && (bl(l, 2), mi(l));
    }
    function Kt(l, f, h) {
      if (l.tag === 3)
        CN(l, l, h);
      else
        for (; f !== null; ) {
          if (f.tag === 3) {
            CN(
              f,
              l,
              h
            );
            break;
          } else if (f.tag === 1) {
            var w = f.stateNode;
            if (typeof f.type.getDerivedStateFromError == "function" || typeof w.componentDidCatch == "function" && (ks === null || !ks.has(w))) {
              l = bo(h, l), h = kM(2), w = xs(f, h, 2), w !== null && (TM(
                h,
                w,
                f,
                l
              ), bl(w, 2), mi(w));
              break;
            }
          }
          f = f.return;
        }
    }
    function Tw(l, f, h) {
      var w = l.pingCache;
      if (w === null) {
        w = l.pingCache = new WW();
        var R = /* @__PURE__ */ new Set();
        w.set(f, R);
      } else
        R = w.get(f), R === void 0 && (R = /* @__PURE__ */ new Set(), w.set(f, R));
      R.has(h) || (bw = !0, R.add(h), l = ZW.bind(null, l, f, h), f.then(l, l));
    }
    function ZW(l, f, h) {
      var w = l.pingCache;
      w !== null && w.delete(f), l.pingedLanes |= l.suspendedLanes & h, l.warmLanes &= ~h, sn === l && (Ct & h) === h && (Tn === 4 || Tn === 3 && (Ct & 62914560) === Ct && 300 > Je() - Sg ? (zt & 2) === 0 && pu(l, 0) : xw |= h, fu === Ct && (fu = 0)), mi(l);
    }
    function kN(l, f) {
      f === 0 && (f = Em()), l = kl(l, f), l !== null && (bl(l, f), mi(l));
    }
    function QW(l) {
      var f = l.memoizedState, h = 0;
      f !== null && (h = f.retryLane), kN(l, h);
    }
    function JW(l, f) {
      var h = 0;
      switch (l.tag) {
        case 31:
        case 13:
          var w = l.stateNode, R = l.memoizedState;
          R !== null && (h = R.retryLane);
          break;
        case 19:
          w = l.stateNode;
          break;
        case 22:
          w = l.stateNode._retryCache;
          break;
        default:
          throw Error(r(314));
      }
      w !== null && w.delete(f), kN(l, h);
    }
    function eG(l, f) {
      return Ye(l, f);
    }
    var Rg = null, mu = null, Aw = !1, Og = !1, Rw = !1, Rs = 0;
    function mi(l) {
      l !== mu && l.next === null && (mu === null ? Rg = mu = l : mu = mu.next = l), Og = !0, Aw || (Aw = !0, nG());
    }
    function Pd(l, f) {
      if (!Rw && Og) {
        Rw = !0;
        do
          for (var h = !1, w = Rg; w !== null; ) {
            if (l !== 0) {
              var R = w.pendingLanes;
              if (R === 0) var M = 0;
              else {
                var q = w.suspendedLanes, Z = w.pingedLanes;
                M = (1 << 31 - Mt(42 | l) + 1) - 1, M &= R & ~(q & ~Z), M = M & 201326741 ? M & 201326741 | 1 : M ? M | 2 : 0;
              }
              M !== 0 && (h = !0, ON(w, M));
            } else
              M = Ct, M = ui(
                w,
                w === sn ? M : 0,
                w.cancelPendingCommit !== null || w.timeoutHandle !== -1
              ), (M & 3) === 0 || yo(w, M) || (h = !0, ON(w, M));
            w = w.next;
          }
        while (h);
        Rw = !1;
      }
    }
    function tG() {
      TN();
    }
    function TN() {
      Og = Aw = !1;
      var l = 0;
      Rs !== 0 && dG() && (l = Rs);
      for (var f = Je(), h = null, w = Rg; w !== null; ) {
        var R = w.next, M = AN(w, f);
        M === 0 ? (w.next = null, h === null ? Rg = R : h.next = R, R === null && (mu = h)) : (h = w, (l !== 0 || (M & 3) !== 0) && (Og = !0)), w = R;
      }
      Gn !== 0 && Gn !== 5 || Pd(l), Rs !== 0 && (Rs = 0);
    }
    function AN(l, f) {
      for (var h = l.suspendedLanes, w = l.pingedLanes, R = l.expirationTimes, M = l.pendingLanes & -62914561; 0 < M; ) {
        var q = 31 - Mt(M), Z = 1 << q, re = R[q];
        re === -1 ? ((Z & h) === 0 || (Z & w) !== 0) && (R[q] = Gr(Z, f)) : re <= f && (l.expiredLanes |= Z), M &= ~Z;
      }
      if (f = sn, h = Ct, h = ui(
        l,
        l === f ? h : 0,
        l.cancelPendingCommit !== null || l.timeoutHandle !== -1
      ), w = l.callbackNode, h === 0 || l === f && (Gt === 2 || Gt === 9) || l.cancelPendingCommit !== null)
        return w !== null && w !== null && Ue(w), l.callbackNode = null, l.callbackPriority = 0;
      if ((h & 3) === 0 || yo(l, h)) {
        if (f = h & -h, f === l.callbackPriority) return f;
        switch (w !== null && Ue(w), Qf(h)) {
          case 2:
          case 8:
            h = fe;
            break;
          case 32:
            h = _e;
            break;
          case 268435456:
            h = Oe;
            break;
          default:
            h = _e;
        }
        return w = RN.bind(null, l), h = Ye(h, w), l.callbackPriority = f, l.callbackNode = h, f;
      }
      return w !== null && w !== null && Ue(w), l.callbackPriority = 2, l.callbackNode = null, 2;
    }
    function RN(l, f) {
      if (Gn !== 0 && Gn !== 5)
        return l.callbackNode = null, l.callbackPriority = 0, null;
      var h = l.callbackNode;
      if (Ag() && l.callbackNode !== h)
        return null;
      var w = Ct;
      return w = ui(
        l,
        l === sn ? w : 0,
        l.cancelPendingCommit !== null || l.timeoutHandle !== -1
      ), w === 0 ? null : (uN(l, w, f), AN(l, Je()), l.callbackNode != null && l.callbackNode === h ? RN.bind(null, l) : null);
    }
    function ON(l, f) {
      if (Ag()) return null;
      uN(l, f, !0);
    }
    function nG() {
      hG(function() {
        (zt & 6) !== 0 ? Ye(
          oe,
          tG
        ) : TN();
      });
    }
    function Ow() {
      if (Rs === 0) {
        var l = eu;
        l === 0 && (l = nr, nr <<= 1, (nr & 261888) === 0 && (nr = 256)), Rs = l;
      }
      return Rs;
    }
    function MN(l) {
      return l == null || typeof l == "symbol" || typeof l == "boolean" ? null : typeof l == "function" ? l : Fm("" + l);
    }
    function NN(l, f) {
      var h = f.ownerDocument.createElement("input");
      return h.name = f.name, h.value = f.value, l.id && h.setAttribute("form", l.id), f.parentNode.insertBefore(h, f), l = new FormData(l), h.parentNode.removeChild(h), l;
    }
    function rG(l, f, h, w, R) {
      if (f === "submit" && h && h.stateNode === R) {
        var M = MN(
          (R[pr] || null).action
        ), q = w.submitter;
        q && (f = (f = q[pr] || null) ? MN(f.formAction) : q.getAttribute("formAction"), f !== null && (M = f, q = null));
        var Z = new Um(
          "action",
          "action",
          null,
          w,
          R
        );
        l.push({
          event: Z,
          listeners: [
            {
              instance: null,
              listener: function() {
                if (w.defaultPrevented) {
                  if (Rs !== 0) {
                    var re = q ? NN(R, q) : new FormData(R);
                    Xx(
                      h,
                      {
                        pending: !0,
                        data: re,
                        method: R.method,
                        action: M
                      },
                      null,
                      re
                    );
                  }
                } else
                  typeof M == "function" && (Z.preventDefault(), re = q ? NN(R, q) : new FormData(R), Xx(
                    h,
                    {
                      pending: !0,
                      data: re,
                      method: R.method,
                      action: M
                    },
                    M,
                    re
                  ));
              },
              currentTarget: R
            }
          ]
        });
      }
    }
    for (var Mw = 0; Mw < px.length; Mw++) {
      var Nw = px[Mw], oG = Nw.toLowerCase(), iG = Nw[0].toUpperCase() + Nw.slice(1);
      Bo(
        oG,
        "on" + iG
      );
    }
    Bo(cO, "onAnimationEnd"), Bo(uO, "onAnimationIteration"), Bo(fO, "onAnimationStart"), Bo("dblclick", "onDoubleClick"), Bo("focusin", "onFocus"), Bo("focusout", "onBlur"), Bo(wW, "onTransitionRun"), Bo(SW, "onTransitionStart"), Bo(_W, "onTransitionCancel"), Bo(dO, "onTransitionEnd"), ds("onMouseEnter", ["mouseout", "mouseover"]), ds("onMouseLeave", ["mouseout", "mouseover"]), ds("onPointerEnter", ["pointerout", "pointerover"]), ds("onPointerLeave", ["pointerout", "pointerover"]), aa(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(" ")
    ), aa(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    ), aa("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]), aa(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    ), aa(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    ), aa(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
    var Id = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ), aG = new Set(
      "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Id)
    );
    function PN(l, f) {
      f = (f & 4) !== 0;
      for (var h = 0; h < l.length; h++) {
        var w = l[h], R = w.event;
        w = w.listeners;
        e: {
          var M = void 0;
          if (f)
            for (var q = w.length - 1; 0 <= q; q--) {
              var Z = w[q], re = Z.instance, pe = Z.currentTarget;
              if (Z = Z.listener, re !== M && R.isPropagationStopped())
                break e;
              M = Z, R.currentTarget = pe;
              try {
                M(R);
              } catch (ve) {
                qm(ve);
              }
              R.currentTarget = null, M = re;
            }
          else
            for (q = 0; q < w.length; q++) {
              if (Z = w[q], re = Z.instance, pe = Z.currentTarget, Z = Z.listener, re !== M && R.isPropagationStopped())
                break e;
              M = Z, R.currentTarget = pe;
              try {
                M(R);
              } catch (ve) {
                qm(ve);
              }
              R.currentTarget = null, M = re;
            }
        }
      }
    }
    function St(l, f) {
      var h = f[Fc];
      h === void 0 && (h = f[Fc] = /* @__PURE__ */ new Set());
      var w = l + "__bubble";
      h.has(w) || (IN(f, l, 2, !1), h.add(w));
    }
    function Pw(l, f, h) {
      var w = 0;
      f && (w |= 4), IN(
        h,
        l,
        w,
        f
      );
    }
    var Mg = "_reactListening" + Math.random().toString(36).slice(2);
    function Iw(l) {
      if (!l[Mg]) {
        l[Mg] = !0, Nm.forEach(function(h) {
          h !== "selectionchange" && (aG.has(h) || Pw(h, !1, l), Pw(h, !0, l));
        });
        var f = l.nodeType === 9 ? l : l.ownerDocument;
        f === null || f[Mg] || (f[Mg] = !0, Pw("selectionchange", !1, f));
      }
    }
    function IN(l, f, h, w) {
      switch (cP(f)) {
        case 2:
          var R = IG;
          break;
        case 8:
          R = $G;
          break;
        default:
          R = Yw;
      }
      h = R.bind(
        null,
        f,
        h,
        l
      ), R = void 0, !ex || f !== "touchstart" && f !== "touchmove" && f !== "wheel" || (R = !0), w ? R !== void 0 ? l.addEventListener(f, h, {
        capture: !0,
        passive: R
      }) : l.addEventListener(f, h, !0) : R !== void 0 ? l.addEventListener(f, h, {
        passive: R
      }) : l.addEventListener(f, h, !1);
    }
    function $w(l, f, h, w, R) {
      var M = w;
      if ((f & 1) === 0 && (f & 2) === 0 && w !== null)
        e: for (; ; ) {
          if (w === null) return;
          var q = w.tag;
          if (q === 3 || q === 4) {
            var Z = w.stateNode.containerInfo;
            if (Z === R) break;
            if (q === 4)
              for (q = w.return; q !== null; ) {
                var re = q.tag;
                if ((re === 3 || re === 4) && q.stateNode.containerInfo === R)
                  return;
                q = q.return;
              }
            for (; Z !== null; ) {
              if (q = ls(Z), q === null) return;
              if (re = q.tag, re === 5 || re === 6 || re === 26 || re === 27) {
                w = M = q;
                continue e;
              }
              Z = Z.parentNode;
            }
          }
          w = w.return;
        }
      LR(function() {
        var pe = M, ve = Q1(h), we = [];
        e: {
          var he = pO.get(l);
          if (he !== void 0) {
            var ye = Um, Fe = l;
            switch (l) {
              case "keypress":
                if (zm(h) === 0) break e;
              case "keydown":
              case "keyup":
                ye = Jq;
                break;
              case "focusin":
                Fe = "focus", ye = ox;
                break;
              case "focusout":
                Fe = "blur", ye = ox;
                break;
              case "beforeblur":
              case "afterblur":
                ye = ox;
                break;
              case "click":
                if (h.button === 2) break e;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                ye = UR;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                ye = Bq;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                ye = nW;
                break;
              case cO:
              case uO:
              case fO:
                ye = Hq;
                break;
              case dO:
                ye = oW;
                break;
              case "scroll":
              case "scrollend":
                ye = Lq;
                break;
              case "wheel":
                ye = aW;
                break;
              case "copy":
              case "cut":
              case "paste":
                ye = Wq;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                ye = HR;
                break;
              case "toggle":
              case "beforetoggle":
                ye = lW;
            }
            var et = (f & 4) !== 0, tn = !et && (l === "scroll" || l === "scrollend"), ce = et ? he !== null ? he + "Capture" : null : he;
            et = [];
            for (var ae = pe, de; ae !== null; ) {
              var xe = ae;
              if (de = xe.stateNode, xe = xe.tag, xe !== 5 && xe !== 26 && xe !== 27 || de === null || ce === null || (xe = nd(ae, ce), xe != null && et.push(
                $d(ae, xe, de)
              )), tn) break;
              ae = ae.return;
            }
            0 < et.length && (he = new ye(
              he,
              Fe,
              null,
              h,
              ve
            ), we.push({ event: he, listeners: et }));
          }
        }
        if ((f & 7) === 0) {
          e: {
            if (he = l === "mouseover" || l === "pointerover", ye = l === "mouseout" || l === "pointerout", he && h !== Z1 && (Fe = h.relatedTarget || h.fromElement) && (ls(Fe) || Fe[ia]))
              break e;
            if ((ye || he) && (he = ve.window === ve ? ve : (he = ve.ownerDocument) ? he.defaultView || he.parentWindow : window, ye ? (Fe = h.relatedTarget || h.toElement, ye = pe, Fe = Fe ? ls(Fe) : null, Fe !== null && (tn = i(Fe), et = Fe.tag, Fe !== tn || et !== 5 && et !== 27 && et !== 6) && (Fe = null)) : (ye = null, Fe = pe), ye !== Fe)) {
              if (et = UR, xe = "onMouseLeave", ce = "onMouseEnter", ae = "mouse", (l === "pointerout" || l === "pointerover") && (et = HR, xe = "onPointerLeave", ce = "onPointerEnter", ae = "pointer"), tn = ye == null ? he : us(ye), de = Fe == null ? he : us(Fe), he = new et(
                xe,
                ae + "leave",
                ye,
                h,
                ve
              ), he.target = tn, he.relatedTarget = de, xe = null, ls(ve) === pe && (et = new et(
                ce,
                ae + "enter",
                Fe,
                h,
                ve
              ), et.target = de, et.relatedTarget = tn, xe = et), tn = xe, ye && Fe)
                t: {
                  for (et = sG, ce = ye, ae = Fe, de = 0, xe = ce; xe; xe = et(xe))
                    de++;
                  xe = 0;
                  for (var qe = ae; qe; qe = et(qe))
                    xe++;
                  for (; 0 < de - xe; )
                    ce = et(ce), de--;
                  for (; 0 < xe - de; )
                    ae = et(ae), xe--;
                  for (; de--; ) {
                    if (ce === ae || ae !== null && ce === ae.alternate) {
                      et = ce;
                      break t;
                    }
                    ce = et(ce), ae = et(ae);
                  }
                  et = null;
                }
              else et = null;
              ye !== null && $N(
                we,
                he,
                ye,
                et,
                !1
              ), Fe !== null && tn !== null && $N(
                we,
                tn,
                Fe,
                et,
                !0
              );
            }
          }
          e: {
            if (he = pe ? us(pe) : window, ye = he.nodeName && he.nodeName.toLowerCase(), ye === "select" || ye === "input" && he.type === "file")
              var jt = QR;
            else if (XR(he))
              if (JR)
                jt = vW;
              else {
                jt = gW;
                var Be = mW;
              }
            else
              ye = he.nodeName, !ye || ye.toLowerCase() !== "input" || he.type !== "checkbox" && he.type !== "radio" ? pe && X1(pe.elementType) && (jt = QR) : jt = yW;
            if (jt && (jt = jt(l, pe))) {
              ZR(
                we,
                jt,
                h,
                ve
              );
              break e;
            }
            Be && Be(l, he, pe), l === "focusout" && pe && he.type === "number" && pe.memoizedProps.value != null && td(he, "number", he.value);
          }
          switch (Be = pe ? us(pe) : window, l) {
            case "focusin":
              (XR(Be) || Be.contentEditable === "true") && (Wc = Be, ux = pe, ud = null);
              break;
            case "focusout":
              ud = ux = Wc = null;
              break;
            case "mousedown":
              fx = !0;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              fx = !1, sO(we, h, ve);
              break;
            case "selectionchange":
              if (xW) break;
            case "keydown":
            case "keyup":
              sO(we, h, ve);
          }
          var dt;
          if (ax)
            e: {
              switch (l) {
                case "compositionstart":
                  var kt = "onCompositionStart";
                  break e;
                case "compositionend":
                  kt = "onCompositionEnd";
                  break e;
                case "compositionupdate":
                  kt = "onCompositionUpdate";
                  break e;
              }
              kt = void 0;
            }
          else
            qc ? KR(l, h) && (kt = "onCompositionEnd") : l === "keydown" && h.keyCode === 229 && (kt = "onCompositionStart");
          kt && (qR && h.locale !== "ko" && (qc || kt !== "onCompositionStart" ? kt === "onCompositionEnd" && qc && (dt = zR()) : (ps = ve, tx = "value" in ps ? ps.value : ps.textContent, qc = !0)), Be = Ng(pe, kt), 0 < Be.length && (kt = new VR(
            kt,
            l,
            null,
            h,
            ve
          ), we.push({ event: kt, listeners: Be }), dt ? kt.data = dt : (dt = YR(h), dt !== null && (kt.data = dt)))), (dt = uW ? fW(l, h) : dW(l, h)) && (kt = Ng(pe, "onBeforeInput"), 0 < kt.length && (Be = new VR(
            "onBeforeInput",
            "beforeinput",
            null,
            h,
            ve
          ), we.push({
            event: Be,
            listeners: kt
          }), Be.data = dt)), rG(
            we,
            l,
            pe,
            h,
            ve
          );
        }
        PN(we, f);
      });
    }
    function $d(l, f, h) {
      return {
        instance: l,
        listener: f,
        currentTarget: h
      };
    }
    function Ng(l, f) {
      for (var h = f + "Capture", w = []; l !== null; ) {
        var R = l, M = R.stateNode;
        if (R = R.tag, R !== 5 && R !== 26 && R !== 27 || M === null || (R = nd(l, h), R != null && w.unshift(
          $d(l, R, M)
        ), R = nd(l, f), R != null && w.push(
          $d(l, R, M)
        )), l.tag === 3) return w;
        l = l.return;
      }
      return [];
    }
    function sG(l) {
      if (l === null) return null;
      do
        l = l.return;
      while (l && l.tag !== 5 && l.tag !== 27);
      return l || null;
    }
    function $N(l, f, h, w, R) {
      for (var M = f._reactName, q = []; h !== null && h !== w; ) {
        var Z = h, re = Z.alternate, pe = Z.stateNode;
        if (Z = Z.tag, re !== null && re === w) break;
        Z !== 5 && Z !== 26 && Z !== 27 || pe === null || (re = pe, R ? (pe = nd(h, M), pe != null && q.unshift(
          $d(h, pe, re)
        )) : R || (pe = nd(h, M), pe != null && q.push(
          $d(h, pe, re)
        ))), h = h.return;
      }
      q.length !== 0 && l.push({ event: f, listeners: q });
    }
    var lG = /\r\n?/g, cG = /\u0000|\uFFFD/g;
    function jN(l) {
      return (typeof l == "string" ? l : "" + l).replace(lG, `
`).replace(cG, "");
    }
    function DN(l, f) {
      return f = jN(f), jN(l) === f;
    }
    function en(l, f, h, w, R, M) {
      switch (h) {
        case "children":
          typeof w == "string" ? f === "body" || f === "textarea" && w === "" || Uc(l, w) : (typeof w == "number" || typeof w == "bigint") && f !== "body" && Uc(l, "" + w);
          break;
        case "className":
          zc(l, "class", w);
          break;
        case "tabIndex":
          zc(l, "tabindex", w);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          zc(l, h, w);
          break;
        case "style":
          DR(l, w, M);
          break;
        case "data":
          if (f !== "object") {
            zc(l, "data", w);
            break;
          }
        case "src":
        case "href":
          if (w === "" && (f !== "a" || h !== "href")) {
            l.removeAttribute(h);
            break;
          }
          if (w == null || typeof w == "function" || typeof w == "symbol" || typeof w == "boolean") {
            l.removeAttribute(h);
            break;
          }
          w = Fm("" + w), l.setAttribute(h, w);
          break;
        case "action":
        case "formAction":
          if (typeof w == "function") {
            l.setAttribute(
              h,
              "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
            );
            break;
          } else
            typeof M == "function" && (h === "formAction" ? (f !== "input" && en(l, f, "name", R.name, R, null), en(
              l,
              f,
              "formEncType",
              R.formEncType,
              R,
              null
            ), en(
              l,
              f,
              "formMethod",
              R.formMethod,
              R,
              null
            ), en(
              l,
              f,
              "formTarget",
              R.formTarget,
              R,
              null
            )) : (en(l, f, "encType", R.encType, R, null), en(l, f, "method", R.method, R, null), en(l, f, "target", R.target, R, null)));
          if (w == null || typeof w == "symbol" || typeof w == "boolean") {
            l.removeAttribute(h);
            break;
          }
          w = Fm("" + w), l.setAttribute(h, w);
          break;
        case "onClick":
          w != null && (l.onclick = la);
          break;
        case "onScroll":
          w != null && St("scroll", l);
          break;
        case "onScrollEnd":
          w != null && St("scrollend", l);
          break;
        case "dangerouslySetInnerHTML":
          if (w != null) {
            if (typeof w != "object" || !("__html" in w))
              throw Error(r(61));
            if (h = w.__html, h != null) {
              if (R.children != null) throw Error(r(60));
              l.innerHTML = h;
            }
          }
          break;
        case "multiple":
          l.multiple = w && typeof w != "function" && typeof w != "symbol";
          break;
        case "muted":
          l.muted = w && typeof w != "function" && typeof w != "symbol";
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (w == null || typeof w == "function" || typeof w == "boolean" || typeof w == "symbol") {
            l.removeAttribute("xlink:href");
            break;
          }
          h = Fm("" + w), l.setAttributeNS(
            "http://www.w3.org/1999/xlink",
            "xlink:href",
            h
          );
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          w != null && typeof w != "function" && typeof w != "symbol" ? l.setAttribute(h, "" + w) : l.removeAttribute(h);
          break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          w && typeof w != "function" && typeof w != "symbol" ? l.setAttribute(h, "") : l.removeAttribute(h);
          break;
        case "capture":
        case "download":
          w === !0 ? l.setAttribute(h, "") : w !== !1 && w != null && typeof w != "function" && typeof w != "symbol" ? l.setAttribute(h, w) : l.removeAttribute(h);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          w != null && typeof w != "function" && typeof w != "symbol" && !isNaN(w) && 1 <= w ? l.setAttribute(h, w) : l.removeAttribute(h);
          break;
        case "rowSpan":
        case "start":
          w == null || typeof w == "function" || typeof w == "symbol" || isNaN(w) ? l.removeAttribute(h) : l.setAttribute(h, w);
          break;
        case "popover":
          St("beforetoggle", l), St("toggle", l), Lc(l, "popover", w);
          break;
        case "xlinkActuate":
          zo(
            l,
            "http://www.w3.org/1999/xlink",
            "xlink:actuate",
            w
          );
          break;
        case "xlinkArcrole":
          zo(
            l,
            "http://www.w3.org/1999/xlink",
            "xlink:arcrole",
            w
          );
          break;
        case "xlinkRole":
          zo(
            l,
            "http://www.w3.org/1999/xlink",
            "xlink:role",
            w
          );
          break;
        case "xlinkShow":
          zo(
            l,
            "http://www.w3.org/1999/xlink",
            "xlink:show",
            w
          );
          break;
        case "xlinkTitle":
          zo(
            l,
            "http://www.w3.org/1999/xlink",
            "xlink:title",
            w
          );
          break;
        case "xlinkType":
          zo(
            l,
            "http://www.w3.org/1999/xlink",
            "xlink:type",
            w
          );
          break;
        case "xmlBase":
          zo(
            l,
            "http://www.w3.org/XML/1998/namespace",
            "xml:base",
            w
          );
          break;
        case "xmlLang":
          zo(
            l,
            "http://www.w3.org/XML/1998/namespace",
            "xml:lang",
            w
          );
          break;
        case "xmlSpace":
          zo(
            l,
            "http://www.w3.org/XML/1998/namespace",
            "xml:space",
            w
          );
          break;
        case "is":
          Lc(l, "is", w);
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          (!(2 < h.length) || h[0] !== "o" && h[0] !== "O" || h[1] !== "n" && h[1] !== "N") && (h = Dq.get(h) || h, Lc(l, h, w));
      }
    }
    function jw(l, f, h, w, R, M) {
      switch (h) {
        case "style":
          DR(l, w, M);
          break;
        case "dangerouslySetInnerHTML":
          if (w != null) {
            if (typeof w != "object" || !("__html" in w))
              throw Error(r(61));
            if (h = w.__html, h != null) {
              if (R.children != null) throw Error(r(60));
              l.innerHTML = h;
            }
          }
          break;
        case "children":
          typeof w == "string" ? Uc(l, w) : (typeof w == "number" || typeof w == "bigint") && Uc(l, "" + w);
          break;
        case "onScroll":
          w != null && St("scroll", l);
          break;
        case "onScrollEnd":
          w != null && St("scrollend", l);
          break;
        case "onClick":
          w != null && (l.onclick = la);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (!Pm.hasOwnProperty(h))
            e: {
              if (h[0] === "o" && h[1] === "n" && (R = h.endsWith("Capture"), f = h.slice(2, R ? h.length - 7 : void 0), M = l[pr] || null, M = M != null ? M[h] : null, typeof M == "function" && l.removeEventListener(f, M, R), typeof w == "function")) {
                typeof M != "function" && M !== null && (h in l ? l[h] = null : l.hasAttribute(h) && l.removeAttribute(h)), l.addEventListener(f, w, R);
                break e;
              }
              h in l ? l[h] = w : w === !0 ? l.setAttribute(h, "") : Lc(l, h, w);
            }
      }
    }
    function ar(l, f, h) {
      switch (f) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          St("error", l), St("load", l);
          var w = !1, R = !1, M;
          for (M in h)
            if (h.hasOwnProperty(M)) {
              var q = h[M];
              if (q != null)
                switch (M) {
                  case "src":
                    w = !0;
                    break;
                  case "srcSet":
                    R = !0;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(r(137, f));
                  default:
                    en(l, f, M, q, h, null);
                }
            }
          R && en(l, f, "srcSet", h.srcSet, h, null), w && en(l, f, "src", h.src, h, null);
          return;
        case "input":
          St("invalid", l);
          var Z = M = q = R = null, re = null, pe = null;
          for (w in h)
            if (h.hasOwnProperty(w)) {
              var ve = h[w];
              if (ve != null)
                switch (w) {
                  case "name":
                    R = ve;
                    break;
                  case "type":
                    q = ve;
                    break;
                  case "checked":
                    re = ve;
                    break;
                  case "defaultChecked":
                    pe = ve;
                    break;
                  case "value":
                    M = ve;
                    break;
                  case "defaultValue":
                    Z = ve;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (ve != null)
                      throw Error(r(137, f));
                    break;
                  default:
                    en(l, f, w, ve, h, null);
                }
            }
          Dm(
            l,
            M,
            Z,
            re,
            pe,
            q,
            R,
            !1
          );
          return;
        case "select":
          St("invalid", l), w = q = M = null;
          for (R in h)
            if (h.hasOwnProperty(R) && (Z = h[R], Z != null))
              switch (R) {
                case "value":
                  M = Z;
                  break;
                case "defaultValue":
                  q = Z;
                  break;
                case "multiple":
                  w = Z;
                default:
                  en(l, f, R, Z, h, null);
              }
          f = M, h = q, l.multiple = !!w, f != null ? sa(l, !!w, f, !1) : h != null && sa(l, !!w, h, !0);
          return;
        case "textarea":
          St("invalid", l), M = R = w = null;
          for (q in h)
            if (h.hasOwnProperty(q) && (Z = h[q], Z != null))
              switch (q) {
                case "value":
                  w = Z;
                  break;
                case "defaultValue":
                  R = Z;
                  break;
                case "children":
                  M = Z;
                  break;
                case "dangerouslySetInnerHTML":
                  if (Z != null) throw Error(r(91));
                  break;
                default:
                  en(l, f, q, Z, h, null);
              }
          $R(l, w, R, M);
          return;
        case "option":
          for (re in h)
            h.hasOwnProperty(re) && (w = h[re], w != null) && (re === "selected" ? l.selected = w && typeof w != "function" && typeof w != "symbol" : en(l, f, re, w, h, null));
          return;
        case "dialog":
          St("beforetoggle", l), St("toggle", l), St("cancel", l), St("close", l);
          break;
        case "iframe":
        case "object":
          St("load", l);
          break;
        case "video":
        case "audio":
          for (w = 0; w < Id.length; w++)
            St(Id[w], l);
          break;
        case "image":
          St("error", l), St("load", l);
          break;
        case "details":
          St("toggle", l);
          break;
        case "embed":
        case "source":
        case "link":
          St("error", l), St("load", l);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (pe in h)
            if (h.hasOwnProperty(pe) && (w = h[pe], w != null))
              switch (pe) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(r(137, f));
                default:
                  en(l, f, pe, w, h, null);
              }
          return;
        default:
          if (X1(f)) {
            for (ve in h)
              h.hasOwnProperty(ve) && (w = h[ve], w !== void 0 && jw(
                l,
                f,
                ve,
                w,
                h,
                void 0
              ));
            return;
          }
      }
      for (Z in h)
        h.hasOwnProperty(Z) && (w = h[Z], w != null && en(l, f, Z, w, h, null));
    }
    function uG(l, f, h, w) {
      switch (f) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var R = null, M = null, q = null, Z = null, re = null, pe = null, ve = null;
          for (ye in h) {
            var we = h[ye];
            if (h.hasOwnProperty(ye) && we != null)
              switch (ye) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  re = we;
                default:
                  w.hasOwnProperty(ye) || en(l, f, ye, null, w, we);
              }
          }
          for (var he in w) {
            var ye = w[he];
            if (we = h[he], w.hasOwnProperty(he) && (ye != null || we != null))
              switch (he) {
                case "type":
                  M = ye;
                  break;
                case "name":
                  R = ye;
                  break;
                case "checked":
                  pe = ye;
                  break;
                case "defaultChecked":
                  ve = ye;
                  break;
                case "value":
                  q = ye;
                  break;
                case "defaultValue":
                  Z = ye;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (ye != null)
                    throw Error(r(137, f));
                  break;
                default:
                  ye !== we && en(
                    l,
                    f,
                    he,
                    ye,
                    w,
                    we
                  );
              }
          }
          Sl(
            l,
            q,
            Z,
            re,
            pe,
            ve,
            M,
            R
          );
          return;
        case "select":
          ye = q = Z = he = null;
          for (M in h)
            if (re = h[M], h.hasOwnProperty(M) && re != null)
              switch (M) {
                case "value":
                  break;
                case "multiple":
                  ye = re;
                default:
                  w.hasOwnProperty(M) || en(
                    l,
                    f,
                    M,
                    null,
                    w,
                    re
                  );
              }
          for (R in w)
            if (M = w[R], re = h[R], w.hasOwnProperty(R) && (M != null || re != null))
              switch (R) {
                case "value":
                  he = M;
                  break;
                case "defaultValue":
                  Z = M;
                  break;
                case "multiple":
                  q = M;
                default:
                  M !== re && en(
                    l,
                    f,
                    R,
                    M,
                    w,
                    re
                  );
              }
          f = Z, h = q, w = ye, he != null ? sa(l, !!h, he, !1) : !!w != !!h && (f != null ? sa(l, !!h, f, !0) : sa(l, !!h, h ? [] : "", !1));
          return;
        case "textarea":
          ye = he = null;
          for (Z in h)
            if (R = h[Z], h.hasOwnProperty(Z) && R != null && !w.hasOwnProperty(Z))
              switch (Z) {
                case "value":
                  break;
                case "children":
                  break;
                default:
                  en(l, f, Z, null, w, R);
              }
          for (q in w)
            if (R = w[q], M = h[q], w.hasOwnProperty(q) && (R != null || M != null))
              switch (q) {
                case "value":
                  he = R;
                  break;
                case "defaultValue":
                  ye = R;
                  break;
                case "children":
                  break;
                case "dangerouslySetInnerHTML":
                  if (R != null) throw Error(r(91));
                  break;
                default:
                  R !== M && en(l, f, q, R, w, M);
              }
          IR(l, he, ye);
          return;
        case "option":
          for (var Fe in h)
            he = h[Fe], h.hasOwnProperty(Fe) && he != null && !w.hasOwnProperty(Fe) && (Fe === "selected" ? l.selected = !1 : en(
              l,
              f,
              Fe,
              null,
              w,
              he
            ));
          for (re in w)
            he = w[re], ye = h[re], w.hasOwnProperty(re) && he !== ye && (he != null || ye != null) && (re === "selected" ? l.selected = he && typeof he != "function" && typeof he != "symbol" : en(
              l,
              f,
              re,
              he,
              w,
              ye
            ));
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var et in h)
            he = h[et], h.hasOwnProperty(et) && he != null && !w.hasOwnProperty(et) && en(l, f, et, null, w, he);
          for (pe in w)
            if (he = w[pe], ye = h[pe], w.hasOwnProperty(pe) && he !== ye && (he != null || ye != null))
              switch (pe) {
                case "children":
                case "dangerouslySetInnerHTML":
                  if (he != null)
                    throw Error(r(137, f));
                  break;
                default:
                  en(
                    l,
                    f,
                    pe,
                    he,
                    w,
                    ye
                  );
              }
          return;
        default:
          if (X1(f)) {
            for (var tn in h)
              he = h[tn], h.hasOwnProperty(tn) && he !== void 0 && !w.hasOwnProperty(tn) && jw(
                l,
                f,
                tn,
                void 0,
                w,
                he
              );
            for (ve in w)
              he = w[ve], ye = h[ve], !w.hasOwnProperty(ve) || he === ye || he === void 0 && ye === void 0 || jw(
                l,
                f,
                ve,
                he,
                w,
                ye
              );
            return;
          }
      }
      for (var ce in h)
        he = h[ce], h.hasOwnProperty(ce) && he != null && !w.hasOwnProperty(ce) && en(l, f, ce, null, w, he);
      for (we in w)
        he = w[we], ye = h[we], !w.hasOwnProperty(we) || he === ye || he == null && ye == null || en(l, f, we, he, w, ye);
    }
    function FN(l) {
      switch (l) {
        case "css":
        case "script":
        case "font":
        case "img":
        case "image":
        case "input":
        case "link":
          return !0;
        default:
          return !1;
      }
    }
    function fG() {
      if (typeof performance.getEntriesByType == "function") {
        for (var l = 0, f = 0, h = performance.getEntriesByType("resource"), w = 0; w < h.length; w++) {
          var R = h[w], M = R.transferSize, q = R.initiatorType, Z = R.duration;
          if (M && Z && FN(q)) {
            for (q = 0, Z = R.responseEnd, w += 1; w < h.length; w++) {
              var re = h[w], pe = re.startTime;
              if (pe > Z) break;
              var ve = re.transferSize, we = re.initiatorType;
              ve && FN(we) && (re = re.responseEnd, q += ve * (re < Z ? 1 : (Z - pe) / (re - pe)));
            }
            if (--w, f += 8 * (M + q) / (R.duration / 1e3), l++, 10 < l) break;
          }
        }
        if (0 < l) return f / l / 1e6;
      }
      return navigator.connection && (l = navigator.connection.downlink, typeof l == "number") ? l : 5;
    }
    var Dw = null, Fw = null;
    function Pg(l) {
      return l.nodeType === 9 ? l : l.ownerDocument;
    }
    function LN(l) {
      switch (l) {
        case "http://www.w3.org/2000/svg":
          return 1;
        case "http://www.w3.org/1998/Math/MathML":
          return 2;
        default:
          return 0;
      }
    }
    function zN(l, f) {
      if (l === 0)
        switch (f) {
          case "svg":
            return 1;
          case "math":
            return 2;
          default:
            return 0;
        }
      return l === 1 && f === "foreignObject" ? 0 : l;
    }
    function Lw(l, f) {
      return l === "textarea" || l === "noscript" || typeof f.children == "string" || typeof f.children == "number" || typeof f.children == "bigint" || typeof f.dangerouslySetInnerHTML == "object" && f.dangerouslySetInnerHTML !== null && f.dangerouslySetInnerHTML.__html != null;
    }
    var zw = null;
    function dG() {
      var l = window.event;
      return l && l.type === "popstate" ? l === zw ? !1 : (zw = l, !0) : (zw = null, !1);
    }
    var BN = typeof setTimeout == "function" ? setTimeout : void 0, pG = typeof clearTimeout == "function" ? clearTimeout : void 0, UN = typeof Promise == "function" ? Promise : void 0, hG = typeof queueMicrotask == "function" ? queueMicrotask : typeof UN < "u" ? function(l) {
      return UN.resolve(null).then(l).catch(mG);
    } : BN;
    function mG(l) {
      setTimeout(function() {
        throw l;
      });
    }
    function Os(l) {
      return l === "head";
    }
    function VN(l, f) {
      var h = f, w = 0;
      do {
        var R = h.nextSibling;
        if (l.removeChild(h), R && R.nodeType === 8)
          if (h = R.data, h === "/$" || h === "/&") {
            if (w === 0) {
              l.removeChild(R), bu(f);
              return;
            }
            w--;
          } else if (h === "$" || h === "$?" || h === "$~" || h === "$!" || h === "&")
            w++;
          else if (h === "html")
            jd(l.ownerDocument.documentElement);
          else if (h === "head") {
            h = l.ownerDocument.head, jd(h);
            for (var M = h.firstChild; M; ) {
              var q = M.nextSibling, Z = M.nodeName;
              M[xl] || Z === "SCRIPT" || Z === "STYLE" || Z === "LINK" && M.rel.toLowerCase() === "stylesheet" || h.removeChild(M), M = q;
            }
          } else
            h === "body" && jd(l.ownerDocument.body);
        h = R;
      } while (h);
      bu(f);
    }
    function HN(l, f) {
      var h = l;
      l = 0;
      do {
        var w = h.nextSibling;
        if (h.nodeType === 1 ? f ? (h._stashedDisplay = h.style.display, h.style.display = "none") : (h.style.display = h._stashedDisplay || "", h.getAttribute("style") === "" && h.removeAttribute("style")) : h.nodeType === 3 && (f ? (h._stashedText = h.nodeValue, h.nodeValue = "") : h.nodeValue = h._stashedText || ""), w && w.nodeType === 8)
          if (h = w.data, h === "/$") {
            if (l === 0) break;
            l--;
          } else
            h !== "$" && h !== "$?" && h !== "$~" && h !== "$!" || l++;
        h = w;
      } while (h);
    }
    function Bw(l) {
      var f = l.firstChild;
      for (f && f.nodeType === 10 && (f = f.nextSibling); f; ) {
        var h = f;
        switch (f = f.nextSibling, h.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            Bw(h), Jf(h);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if (h.rel.toLowerCase() === "stylesheet") continue;
        }
        l.removeChild(h);
      }
    }
    function gG(l, f, h, w) {
      for (; l.nodeType === 1; ) {
        var R = h;
        if (l.nodeName.toLowerCase() !== f.toLowerCase()) {
          if (!w && (l.nodeName !== "INPUT" || l.type !== "hidden"))
            break;
        } else if (w) {
          if (!l[xl])
            switch (f) {
              case "meta":
                if (!l.hasAttribute("itemprop")) break;
                return l;
              case "link":
                if (M = l.getAttribute("rel"), M === "stylesheet" && l.hasAttribute("data-precedence"))
                  break;
                if (M !== R.rel || l.getAttribute("href") !== (R.href == null || R.href === "" ? null : R.href) || l.getAttribute("crossorigin") !== (R.crossOrigin == null ? null : R.crossOrigin) || l.getAttribute("title") !== (R.title == null ? null : R.title))
                  break;
                return l;
              case "style":
                if (l.hasAttribute("data-precedence")) break;
                return l;
              case "script":
                if (M = l.getAttribute("src"), (M !== (R.src == null ? null : R.src) || l.getAttribute("type") !== (R.type == null ? null : R.type) || l.getAttribute("crossorigin") !== (R.crossOrigin == null ? null : R.crossOrigin)) && M && l.hasAttribute("async") && !l.hasAttribute("itemprop"))
                  break;
                return l;
              default:
                return l;
            }
        } else if (f === "input" && l.type === "hidden") {
          var M = R.name == null ? null : "" + R.name;
          if (R.type === "hidden" && l.getAttribute("name") === M)
            return l;
        } else return l;
        if (l = Eo(l.nextSibling), l === null) break;
      }
      return null;
    }
    function yG(l, f, h) {
      if (f === "") return null;
      for (; l.nodeType !== 3; )
        if ((l.nodeType !== 1 || l.nodeName !== "INPUT" || l.type !== "hidden") && !h || (l = Eo(l.nextSibling), l === null)) return null;
      return l;
    }
    function qN(l, f) {
      for (; l.nodeType !== 8; )
        if ((l.nodeType !== 1 || l.nodeName !== "INPUT" || l.type !== "hidden") && !f || (l = Eo(l.nextSibling), l === null)) return null;
      return l;
    }
    function Uw(l) {
      return l.data === "$?" || l.data === "$~";
    }
    function Vw(l) {
      return l.data === "$!" || l.data === "$?" && l.ownerDocument.readyState !== "loading";
    }
    function vG(l, f) {
      var h = l.ownerDocument;
      if (l.data === "$~") l._reactRetry = f;
      else if (l.data !== "$?" || h.readyState !== "loading")
        f();
      else {
        var w = function() {
          f(), h.removeEventListener("DOMContentLoaded", w);
        };
        h.addEventListener("DOMContentLoaded", w), l._reactRetry = w;
      }
    }
    function Eo(l) {
      for (; l != null; l = l.nextSibling) {
        var f = l.nodeType;
        if (f === 1 || f === 3) break;
        if (f === 8) {
          if (f = l.data, f === "$" || f === "$!" || f === "$?" || f === "$~" || f === "&" || f === "F!" || f === "F")
            break;
          if (f === "/$" || f === "/&") return null;
        }
      }
      return l;
    }
    var Hw = null;
    function WN(l) {
      l = l.nextSibling;
      for (var f = 0; l; ) {
        if (l.nodeType === 8) {
          var h = l.data;
          if (h === "/$" || h === "/&") {
            if (f === 0)
              return Eo(l.nextSibling);
            f--;
          } else
            h !== "$" && h !== "$!" && h !== "$?" && h !== "$~" && h !== "&" || f++;
        }
        l = l.nextSibling;
      }
      return null;
    }
    function GN(l) {
      l = l.previousSibling;
      for (var f = 0; l; ) {
        if (l.nodeType === 8) {
          var h = l.data;
          if (h === "$" || h === "$!" || h === "$?" || h === "$~" || h === "&") {
            if (f === 0) return l;
            f--;
          } else h !== "/$" && h !== "/&" || f++;
        }
        l = l.previousSibling;
      }
      return null;
    }
    function KN(l, f, h) {
      switch (f = Pg(h), l) {
        case "html":
          if (l = f.documentElement, !l) throw Error(r(452));
          return l;
        case "head":
          if (l = f.head, !l) throw Error(r(453));
          return l;
        case "body":
          if (l = f.body, !l) throw Error(r(454));
          return l;
        default:
          throw Error(r(451));
      }
    }
    function jd(l) {
      for (var f = l.attributes; f.length; )
        l.removeAttributeNode(f[0]);
      Jf(l);
    }
    var Co = /* @__PURE__ */ new Map(), YN = /* @__PURE__ */ new Set();
    function Ig(l) {
      return typeof l.getRootNode == "function" ? l.getRootNode() : l.nodeType === 9 ? l : l.ownerDocument;
    }
    var Ea = K.d;
    K.d = {
      f: bG,
      r: xG,
      D: wG,
      C: SG,
      L: _G,
      m: EG,
      X: kG,
      S: CG,
      M: TG
    };
    function bG() {
      var l = Ea.f(), f = Cg();
      return l || f;
    }
    function xG(l) {
      var f = cs(l);
      f !== null && f.tag === 5 && f.type === "form" ? dM(f) : Ea.r(l);
    }
    var gu = typeof document > "u" ? null : document;
    function XN(l, f, h) {
      var w = gu;
      if (w && typeof f == "string" && f) {
        var R = Nr(f);
        R = 'link[rel="' + l + '"][href="' + R + '"]', typeof h == "string" && (R += '[crossorigin="' + h + '"]'), YN.has(R) || (YN.add(R), l = { rel: l, crossOrigin: h, href: f }, w.querySelector(R) === null && (f = w.createElement("link"), ar(f, "link", l), jn(f), w.head.appendChild(f)));
      }
    }
    function wG(l) {
      Ea.D(l), XN("dns-prefetch", l, null);
    }
    function SG(l, f) {
      Ea.C(l, f), XN("preconnect", l, f);
    }
    function _G(l, f, h) {
      Ea.L(l, f, h);
      var w = gu;
      if (w && l && f) {
        var R = 'link[rel="preload"][as="' + Nr(f) + '"]';
        f === "image" && h && h.imageSrcSet ? (R += '[imagesrcset="' + Nr(
          h.imageSrcSet
        ) + '"]', typeof h.imageSizes == "string" && (R += '[imagesizes="' + Nr(
          h.imageSizes
        ) + '"]')) : R += '[href="' + Nr(l) + '"]';
        var M = R;
        switch (f) {
          case "style":
            M = yu(l);
            break;
          case "script":
            M = vu(l);
        }
        Co.has(M) || (l = p(
          {
            rel: "preload",
            href: f === "image" && h && h.imageSrcSet ? void 0 : l,
            as: f
          },
          h
        ), Co.set(M, l), w.querySelector(R) !== null || f === "style" && w.querySelector(Dd(M)) || f === "script" && w.querySelector(Fd(M)) || (f = w.createElement("link"), ar(f, "link", l), jn(f), w.head.appendChild(f)));
      }
    }
    function EG(l, f) {
      Ea.m(l, f);
      var h = gu;
      if (h && l) {
        var w = f && typeof f.as == "string" ? f.as : "script", R = 'link[rel="modulepreload"][as="' + Nr(w) + '"][href="' + Nr(l) + '"]', M = R;
        switch (w) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            M = vu(l);
        }
        if (!Co.has(M) && (l = p({ rel: "modulepreload", href: l }, f), Co.set(M, l), h.querySelector(R) === null)) {
          switch (w) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              if (h.querySelector(Fd(M)))
                return;
          }
          w = h.createElement("link"), ar(w, "link", l), jn(w), h.head.appendChild(w);
        }
      }
    }
    function CG(l, f, h) {
      Ea.S(l, f, h);
      var w = gu;
      if (w && l) {
        var R = fs(w).hoistableStyles, M = yu(l);
        f = f || "default";
        var q = R.get(M);
        if (!q) {
          var Z = { loading: 0, preload: null };
          if (q = w.querySelector(
            Dd(M)
          ))
            Z.loading = 5;
          else {
            l = p(
              { rel: "stylesheet", href: l, "data-precedence": f },
              h
            ), (h = Co.get(M)) && qw(l, h);
            var re = q = w.createElement("link");
            jn(re), ar(re, "link", l), re._p = new Promise(function(pe, ve) {
              re.onload = pe, re.onerror = ve;
            }), re.addEventListener("load", function() {
              Z.loading |= 1;
            }), re.addEventListener("error", function() {
              Z.loading |= 2;
            }), Z.loading |= 4, $g(q, f, w);
          }
          q = {
            type: "stylesheet",
            instance: q,
            count: 1,
            state: Z
          }, R.set(M, q);
        }
      }
    }
    function kG(l, f) {
      Ea.X(l, f);
      var h = gu;
      if (h && l) {
        var w = fs(h).hoistableScripts, R = vu(l), M = w.get(R);
        M || (M = h.querySelector(Fd(R)), M || (l = p({ src: l, async: !0 }, f), (f = Co.get(R)) && Ww(l, f), M = h.createElement("script"), jn(M), ar(M, "link", l), h.head.appendChild(M)), M = {
          type: "script",
          instance: M,
          count: 1,
          state: null
        }, w.set(R, M));
      }
    }
    function TG(l, f) {
      Ea.M(l, f);
      var h = gu;
      if (h && l) {
        var w = fs(h).hoistableScripts, R = vu(l), M = w.get(R);
        M || (M = h.querySelector(Fd(R)), M || (l = p({ src: l, async: !0, type: "module" }, f), (f = Co.get(R)) && Ww(l, f), M = h.createElement("script"), jn(M), ar(M, "link", l), h.head.appendChild(M)), M = {
          type: "script",
          instance: M,
          count: 1,
          state: null
        }, w.set(R, M));
      }
    }
    function ZN(l, f, h, w) {
      var R = (R = Q.current) ? Ig(R) : null;
      if (!R) throw Error(r(446));
      switch (l) {
        case "meta":
        case "title":
          return null;
        case "style":
          return typeof h.precedence == "string" && typeof h.href == "string" ? (f = yu(h.href), h = fs(
            R
          ).hoistableStyles, w = h.get(f), w || (w = {
            type: "style",
            instance: null,
            count: 0,
            state: null
          }, h.set(f, w)), w) : { type: "void", instance: null, count: 0, state: null };
        case "link":
          if (h.rel === "stylesheet" && typeof h.href == "string" && typeof h.precedence == "string") {
            l = yu(h.href);
            var M = fs(
              R
            ).hoistableStyles, q = M.get(l);
            if (q || (R = R.ownerDocument || R, q = {
              type: "stylesheet",
              instance: null,
              count: 0,
              state: { loading: 0, preload: null }
            }, M.set(l, q), (M = R.querySelector(
              Dd(l)
            )) && !M._p && (q.instance = M, q.state.loading = 5), Co.has(l) || (h = {
              rel: "preload",
              as: "style",
              href: h.href,
              crossOrigin: h.crossOrigin,
              integrity: h.integrity,
              media: h.media,
              hrefLang: h.hrefLang,
              referrerPolicy: h.referrerPolicy
            }, Co.set(l, h), M || AG(
              R,
              l,
              h,
              q.state
            ))), f && w === null)
              throw Error(r(528, ""));
            return q;
          }
          if (f && w !== null)
            throw Error(r(529, ""));
          return null;
        case "script":
          return f = h.async, h = h.src, typeof h == "string" && f && typeof f != "function" && typeof f != "symbol" ? (f = vu(h), h = fs(
            R
          ).hoistableScripts, w = h.get(f), w || (w = {
            type: "script",
            instance: null,
            count: 0,
            state: null
          }, h.set(f, w)), w) : { type: "void", instance: null, count: 0, state: null };
        default:
          throw Error(r(444, l));
      }
    }
    function yu(l) {
      return 'href="' + Nr(l) + '"';
    }
    function Dd(l) {
      return 'link[rel="stylesheet"][' + l + "]";
    }
    function QN(l) {
      return p({}, l, {
        "data-precedence": l.precedence,
        precedence: null
      });
    }
    function AG(l, f, h, w) {
      l.querySelector('link[rel="preload"][as="style"][' + f + "]") ? w.loading = 1 : (f = l.createElement("link"), w.preload = f, f.addEventListener("load", function() {
        return w.loading |= 1;
      }), f.addEventListener("error", function() {
        return w.loading |= 2;
      }), ar(f, "link", h), jn(f), l.head.appendChild(f));
    }
    function vu(l) {
      return '[src="' + Nr(l) + '"]';
    }
    function Fd(l) {
      return "script[async]" + l;
    }
    function JN(l, f, h) {
      if (f.count++, f.instance === null)
        switch (f.type) {
          case "style":
            var w = l.querySelector(
              'style[data-href~="' + Nr(h.href) + '"]'
            );
            if (w)
              return f.instance = w, jn(w), w;
            var R = p({}, h, {
              "data-href": h.href,
              "data-precedence": h.precedence,
              href: null,
              precedence: null
            });
            return w = (l.ownerDocument || l).createElement(
              "style"
            ), jn(w), ar(w, "style", R), $g(w, h.precedence, l), f.instance = w;
          case "stylesheet":
            R = yu(h.href);
            var M = l.querySelector(
              Dd(R)
            );
            if (M)
              return f.state.loading |= 4, f.instance = M, jn(M), M;
            w = QN(h), (R = Co.get(R)) && qw(w, R), M = (l.ownerDocument || l).createElement("link"), jn(M);
            var q = M;
            return q._p = new Promise(function(Z, re) {
              q.onload = Z, q.onerror = re;
            }), ar(M, "link", w), f.state.loading |= 4, $g(M, h.precedence, l), f.instance = M;
          case "script":
            return M = vu(h.src), (R = l.querySelector(
              Fd(M)
            )) ? (f.instance = R, jn(R), R) : (w = h, (R = Co.get(M)) && (w = p({}, h), Ww(w, R)), l = l.ownerDocument || l, R = l.createElement("script"), jn(R), ar(R, "link", w), l.head.appendChild(R), f.instance = R);
          case "void":
            return null;
          default:
            throw Error(r(443, f.type));
        }
      else
        f.type === "stylesheet" && (f.state.loading & 4) === 0 && (w = f.instance, f.state.loading |= 4, $g(w, h.precedence, l));
      return f.instance;
    }
    function $g(l, f, h) {
      for (var w = h.querySelectorAll(
        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
      ), R = w.length ? w[w.length - 1] : null, M = R, q = 0; q < w.length; q++) {
        var Z = w[q];
        if (Z.dataset.precedence === f) M = Z;
        else if (M !== R) break;
      }
      M ? M.parentNode.insertBefore(l, M.nextSibling) : (f = h.nodeType === 9 ? h.head : h, f.insertBefore(l, f.firstChild));
    }
    function qw(l, f) {
      l.crossOrigin == null && (l.crossOrigin = f.crossOrigin), l.referrerPolicy == null && (l.referrerPolicy = f.referrerPolicy), l.title == null && (l.title = f.title);
    }
    function Ww(l, f) {
      l.crossOrigin == null && (l.crossOrigin = f.crossOrigin), l.referrerPolicy == null && (l.referrerPolicy = f.referrerPolicy), l.integrity == null && (l.integrity = f.integrity);
    }
    var jg = null;
    function eP(l, f, h) {
      if (jg === null) {
        var w = /* @__PURE__ */ new Map(), R = jg = /* @__PURE__ */ new Map();
        R.set(h, w);
      } else
        R = jg, w = R.get(h), w || (w = /* @__PURE__ */ new Map(), R.set(h, w));
      if (w.has(l)) return w;
      for (w.set(l, null), h = h.getElementsByTagName(l), R = 0; R < h.length; R++) {
        var M = h[R];
        if (!(M[xl] || M[Wn] || l === "link" && M.getAttribute("rel") === "stylesheet") && M.namespaceURI !== "http://www.w3.org/2000/svg") {
          var q = M.getAttribute(f) || "";
          q = l + q;
          var Z = w.get(q);
          Z ? Z.push(M) : w.set(q, [M]);
        }
      }
      return w;
    }
    function tP(l, f, h) {
      l = l.ownerDocument || l, l.head.insertBefore(
        h,
        f === "title" ? l.querySelector("head > title") : null
      );
    }
    function RG(l, f, h) {
      if (h === 1 || f.itemProp != null) return !1;
      switch (l) {
        case "meta":
        case "title":
          return !0;
        case "style":
          if (typeof f.precedence != "string" || typeof f.href != "string" || f.href === "")
            break;
          return !0;
        case "link":
          if (typeof f.rel != "string" || typeof f.href != "string" || f.href === "" || f.onLoad || f.onError)
            break;
          return f.rel === "stylesheet" ? (l = f.disabled, typeof f.precedence == "string" && l == null) : !0;
        case "script":
          if (f.async && typeof f.async != "function" && typeof f.async != "symbol" && !f.onLoad && !f.onError && f.src && typeof f.src == "string")
            return !0;
      }
      return !1;
    }
    function nP(l) {
      return !(l.type === "stylesheet" && (l.state.loading & 3) === 0);
    }
    function OG(l, f, h, w) {
      if (h.type === "stylesheet" && (typeof w.media != "string" || matchMedia(w.media).matches !== !1) && (h.state.loading & 4) === 0) {
        if (h.instance === null) {
          var R = yu(w.href), M = f.querySelector(
            Dd(R)
          );
          if (M) {
            f = M._p, f !== null && typeof f == "object" && typeof f.then == "function" && (l.count++, l = Dg.bind(l), f.then(l, l)), h.state.loading |= 4, h.instance = M, jn(M);
            return;
          }
          M = f.ownerDocument || f, w = QN(w), (R = Co.get(R)) && qw(w, R), M = M.createElement("link"), jn(M);
          var q = M;
          q._p = new Promise(function(Z, re) {
            q.onload = Z, q.onerror = re;
          }), ar(M, "link", w), h.instance = M;
        }
        l.stylesheets === null && (l.stylesheets = /* @__PURE__ */ new Map()), l.stylesheets.set(h, f), (f = h.state.preload) && (h.state.loading & 3) === 0 && (l.count++, h = Dg.bind(l), f.addEventListener("load", h), f.addEventListener("error", h));
      }
    }
    var Gw = 0;
    function MG(l, f) {
      return l.stylesheets && l.count === 0 && Lg(l, l.stylesheets), 0 < l.count || 0 < l.imgCount ? function(h) {
        var w = setTimeout(function() {
          if (l.stylesheets && Lg(l, l.stylesheets), l.unsuspend) {
            var M = l.unsuspend;
            l.unsuspend = null, M();
          }
        }, 6e4 + f);
        0 < l.imgBytes && Gw === 0 && (Gw = 62500 * fG());
        var R = setTimeout(
          function() {
            if (l.waitingForImages = !1, l.count === 0 && (l.stylesheets && Lg(l, l.stylesheets), l.unsuspend)) {
              var M = l.unsuspend;
              l.unsuspend = null, M();
            }
          },
          (l.imgBytes > Gw ? 50 : 800) + f
        );
        return l.unsuspend = h, function() {
          l.unsuspend = null, clearTimeout(w), clearTimeout(R);
        };
      } : null;
    }
    function Dg() {
      if (this.count--, this.count === 0 && (this.imgCount === 0 || !this.waitingForImages)) {
        if (this.stylesheets) Lg(this, this.stylesheets);
        else if (this.unsuspend) {
          var l = this.unsuspend;
          this.unsuspend = null, l();
        }
      }
    }
    var Fg = null;
    function Lg(l, f) {
      l.stylesheets = null, l.unsuspend !== null && (l.count++, Fg = /* @__PURE__ */ new Map(), f.forEach(NG, l), Fg = null, Dg.call(l));
    }
    function NG(l, f) {
      if (!(f.state.loading & 4)) {
        var h = Fg.get(l);
        if (h) var w = h.get(null);
        else {
          h = /* @__PURE__ */ new Map(), Fg.set(l, h);
          for (var R = l.querySelectorAll(
            "link[data-precedence],style[data-precedence]"
          ), M = 0; M < R.length; M++) {
            var q = R[M];
            (q.nodeName === "LINK" || q.getAttribute("media") !== "not all") && (h.set(q.dataset.precedence, q), w = q);
          }
          w && h.set(null, w);
        }
        R = f.instance, q = R.getAttribute("data-precedence"), M = h.get(q) || w, M === w && h.set(null, R), h.set(q, R), this.count++, w = Dg.bind(this), R.addEventListener("load", w), R.addEventListener("error", w), M ? M.parentNode.insertBefore(R, M.nextSibling) : (l = l.nodeType === 9 ? l.head : l, l.insertBefore(R, l.firstChild)), f.state.loading |= 4;
      }
    }
    var Ld = {
      $$typeof: _,
      Provider: null,
      Consumer: null,
      _currentValue: W,
      _currentValue2: W,
      _threadCount: 0
    };
    function PG(l, f, h, w, R, M, q, Z, re) {
      this.tag = 1, this.containerInfo = l, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Xf(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Xf(0), this.hiddenUpdates = Xf(null), this.identifierPrefix = w, this.onUncaughtError = R, this.onCaughtError = M, this.onRecoverableError = q, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = re, this.incompleteTransitions = /* @__PURE__ */ new Map();
    }
    function rP(l, f, h, w, R, M, q, Z, re, pe, ve, we) {
      return l = new PG(
        l,
        f,
        h,
        q,
        re,
        pe,
        ve,
        we,
        Z
      ), f = 1, M === !0 && (f |= 24), M = Yr(3, null, null, f), l.current = M, M.stateNode = l, f = kx(), f.refCount++, l.pooledCache = f, f.refCount++, M.memoizedState = {
        element: w,
        isDehydrated: h,
        cache: f
      }, Ox(M), l;
    }
    function oP(l) {
      return l ? (l = Yc, l) : Yc;
    }
    function iP(l, f, h, w, R, M) {
      R = oP(R), w.context === null ? w.context = R : w.pendingContext = R, w = bs(f), w.payload = { element: h }, M = M === void 0 ? null : M, M !== null && (w.callback = M), h = xs(l, w, f), h !== null && (Fr(h, l, f), yd(h, l, f));
    }
    function aP(l, f) {
      if (l = l.memoizedState, l !== null && l.dehydrated !== null) {
        var h = l.retryLane;
        l.retryLane = h !== 0 && h < f ? h : f;
      }
    }
    function Kw(l, f) {
      aP(l, f), (l = l.alternate) && aP(l, f);
    }
    function sP(l) {
      if (l.tag === 13 || l.tag === 31) {
        var f = kl(l, 67108864);
        f !== null && Fr(f, l, 67108864), Kw(l, 67108864);
      }
    }
    function lP(l) {
      if (l.tag === 13 || l.tag === 31) {
        var f = eo();
        f = Zf(f);
        var h = kl(l, f);
        h !== null && Fr(h, l, f), Kw(l, f);
      }
    }
    var zg = !0;
    function IG(l, f, h, w) {
      var R = F.T;
      F.T = null;
      var M = K.p;
      try {
        K.p = 2, Yw(l, f, h, w);
      } finally {
        K.p = M, F.T = R;
      }
    }
    function $G(l, f, h, w) {
      var R = F.T;
      F.T = null;
      var M = K.p;
      try {
        K.p = 8, Yw(l, f, h, w);
      } finally {
        K.p = M, F.T = R;
      }
    }
    function Yw(l, f, h, w) {
      if (zg) {
        var R = Xw(w);
        if (R === null)
          $w(
            l,
            f,
            w,
            Bg,
            h
          ), uP(l, w);
        else if (DG(
          R,
          l,
          f,
          h,
          w
        ))
          w.stopPropagation();
        else if (uP(l, w), f & 4 && -1 < jG.indexOf(l)) {
          for (; R !== null; ) {
            var M = cs(R);
            if (M !== null)
              switch (M.tag) {
                case 3:
                  if (M = M.stateNode, M.current.memoizedState.isDehydrated) {
                    var q = an(M.pendingLanes);
                    if (q !== 0) {
                      var Z = M;
                      for (Z.pendingLanes |= 2, Z.entangledLanes |= 2; q; ) {
                        var re = 1 << 31 - Mt(q);
                        Z.entanglements[1] |= re, q &= ~re;
                      }
                      mi(M), (zt & 6) === 0 && (_g = Je() + 500, Pd(0));
                    }
                  }
                  break;
                case 31:
                case 13:
                  Z = kl(M, 2), Z !== null && Fr(Z, M, 2), Cg(), Kw(M, 2);
              }
            if (M = Xw(w), M === null && $w(
              l,
              f,
              w,
              Bg,
              h
            ), M === R) break;
            R = M;
          }
          R !== null && w.stopPropagation();
        } else
          $w(
            l,
            f,
            w,
            null,
            h
          );
      }
    }
    function Xw(l) {
      return l = Q1(l), Zw(l);
    }
    var Bg = null;
    function Zw(l) {
      if (Bg = null, l = ls(l), l !== null) {
        var f = i(l);
        if (f === null) l = null;
        else {
          var h = f.tag;
          if (h === 13) {
            if (l = a(f), l !== null) return l;
            l = null;
          } else if (h === 31) {
            if (l = s(f), l !== null) return l;
            l = null;
          } else if (h === 3) {
            if (f.stateNode.current.memoizedState.isDehydrated)
              return f.tag === 3 ? f.stateNode.containerInfo : null;
            l = null;
          } else f !== l && (l = null);
        }
      }
      return Bg = l, null;
    }
    function cP(l) {
      switch (l) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 2;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 8;
        case "message":
          switch (Ae()) {
            case oe:
              return 2;
            case fe:
              return 8;
            case _e:
            case Ce:
              return 32;
            case Oe:
              return 268435456;
            default:
              return 32;
          }
        default:
          return 32;
      }
    }
    var Qw = !1, Ms = null, Ns = null, Ps = null, zd = /* @__PURE__ */ new Map(), Bd = /* @__PURE__ */ new Map(), Is = [], jG = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
      " "
    );
    function uP(l, f) {
      switch (l) {
        case "focusin":
        case "focusout":
          Ms = null;
          break;
        case "dragenter":
        case "dragleave":
          Ns = null;
          break;
        case "mouseover":
        case "mouseout":
          Ps = null;
          break;
        case "pointerover":
        case "pointerout":
          zd.delete(f.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Bd.delete(f.pointerId);
      }
    }
    function Ud(l, f, h, w, R, M) {
      return l === null || l.nativeEvent !== M ? (l = {
        blockedOn: f,
        domEventName: h,
        eventSystemFlags: w,
        nativeEvent: M,
        targetContainers: [R]
      }, f !== null && (f = cs(f), f !== null && sP(f)), l) : (l.eventSystemFlags |= w, f = l.targetContainers, R !== null && f.indexOf(R) === -1 && f.push(R), l);
    }
    function DG(l, f, h, w, R) {
      switch (f) {
        case "focusin":
          return Ms = Ud(
            Ms,
            l,
            f,
            h,
            w,
            R
          ), !0;
        case "dragenter":
          return Ns = Ud(
            Ns,
            l,
            f,
            h,
            w,
            R
          ), !0;
        case "mouseover":
          return Ps = Ud(
            Ps,
            l,
            f,
            h,
            w,
            R
          ), !0;
        case "pointerover":
          var M = R.pointerId;
          return zd.set(
            M,
            Ud(
              zd.get(M) || null,
              l,
              f,
              h,
              w,
              R
            )
          ), !0;
        case "gotpointercapture":
          return M = R.pointerId, Bd.set(
            M,
            Ud(
              Bd.get(M) || null,
              l,
              f,
              h,
              w,
              R
            )
          ), !0;
      }
      return !1;
    }
    function fP(l) {
      var f = ls(l.target);
      if (f !== null) {
        var h = i(f);
        if (h !== null) {
          if (f = h.tag, f === 13) {
            if (f = a(h), f !== null) {
              l.blockedOn = f, Rm(l.priority, function() {
                lP(h);
              });
              return;
            }
          } else if (f === 31) {
            if (f = s(h), f !== null) {
              l.blockedOn = f, Rm(l.priority, function() {
                lP(h);
              });
              return;
            }
          } else if (f === 3 && h.stateNode.current.memoizedState.isDehydrated) {
            l.blockedOn = h.tag === 3 ? h.stateNode.containerInfo : null;
            return;
          }
        }
      }
      l.blockedOn = null;
    }
    function Ug(l) {
      if (l.blockedOn !== null) return !1;
      for (var f = l.targetContainers; 0 < f.length; ) {
        var h = Xw(l.nativeEvent);
        if (h === null) {
          h = l.nativeEvent;
          var w = new h.constructor(
            h.type,
            h
          );
          Z1 = w, h.target.dispatchEvent(w), Z1 = null;
        } else
          return f = cs(h), f !== null && sP(f), l.blockedOn = h, !1;
        f.shift();
      }
      return !0;
    }
    function dP(l, f, h) {
      Ug(l) && h.delete(f);
    }
    function FG() {
      Qw = !1, Ms !== null && Ug(Ms) && (Ms = null), Ns !== null && Ug(Ns) && (Ns = null), Ps !== null && Ug(Ps) && (Ps = null), zd.forEach(dP), Bd.forEach(dP);
    }
    function Vg(l, f) {
      l.blockedOn === f && (l.blockedOn = null, Qw || (Qw = !0, e.unstable_scheduleCallback(
        e.unstable_NormalPriority,
        FG
      )));
    }
    var Hg = null;
    function pP(l) {
      Hg !== l && (Hg = l, e.unstable_scheduleCallback(
        e.unstable_NormalPriority,
        function() {
          Hg === l && (Hg = null);
          for (var f = 0; f < l.length; f += 3) {
            var h = l[f], w = l[f + 1], R = l[f + 2];
            if (typeof w != "function") {
              if (Zw(w || h) === null)
                continue;
              break;
            }
            var M = cs(h);
            M !== null && (l.splice(f, 3), f -= 3, Xx(
              M,
              {
                pending: !0,
                data: R,
                method: h.method,
                action: w
              },
              w,
              R
            ));
          }
        }
      ));
    }
    function bu(l) {
      function f(re) {
        return Vg(re, l);
      }
      Ms !== null && Vg(Ms, l), Ns !== null && Vg(Ns, l), Ps !== null && Vg(Ps, l), zd.forEach(f), Bd.forEach(f);
      for (var h = 0; h < Is.length; h++) {
        var w = Is[h];
        w.blockedOn === l && (w.blockedOn = null);
      }
      for (; 0 < Is.length && (h = Is[0], h.blockedOn === null); )
        fP(h), h.blockedOn === null && Is.shift();
      if (h = (l.ownerDocument || l).$$reactFormReplay, h != null)
        for (w = 0; w < h.length; w += 3) {
          var R = h[w], M = h[w + 1], q = R[pr] || null;
          if (typeof M == "function")
            q || pP(h);
          else if (q) {
            var Z = null;
            if (M && M.hasAttribute("formAction")) {
              if (R = M, q = M[pr] || null)
                Z = q.formAction;
              else if (Zw(R) !== null) continue;
            } else Z = q.action;
            typeof Z == "function" ? h[w + 1] = Z : (h.splice(w, 3), w -= 3), pP(h);
          }
        }
    }
    function hP() {
      function l(M) {
        M.canIntercept && M.info === "react-transition" && M.intercept({
          handler: function() {
            return new Promise(function(q) {
              return R = q;
            });
          },
          focusReset: "manual",
          scroll: "manual"
        });
      }
      function f() {
        R !== null && (R(), R = null), w || setTimeout(h, 20);
      }
      function h() {
        if (!w && !navigation.transition) {
          var M = navigation.currentEntry;
          M && M.url != null && navigation.navigate(M.url, {
            state: M.getState(),
            info: "react-transition",
            history: "replace"
          });
        }
      }
      if (typeof navigation == "object") {
        var w = !1, R = null;
        return navigation.addEventListener("navigate", l), navigation.addEventListener("navigatesuccess", f), navigation.addEventListener("navigateerror", f), setTimeout(h, 100), function() {
          w = !0, navigation.removeEventListener("navigate", l), navigation.removeEventListener("navigatesuccess", f), navigation.removeEventListener("navigateerror", f), R !== null && (R(), R = null);
        };
      }
    }
    function Jw(l) {
      this._internalRoot = l;
    }
    qg.prototype.render = Jw.prototype.render = function(l) {
      var f = this._internalRoot;
      if (f === null) throw Error(r(409));
      var h = f.current, w = eo();
      iP(h, w, l, f, null, null);
    }, qg.prototype.unmount = Jw.prototype.unmount = function() {
      var l = this._internalRoot;
      if (l !== null) {
        this._internalRoot = null;
        var f = l.containerInfo;
        iP(l.current, 2, null, l, null, null), Cg(), f[ia] = null;
      }
    };
    function qg(l) {
      this._internalRoot = l;
    }
    qg.prototype.unstable_scheduleHydration = function(l) {
      if (l) {
        var f = Am();
        l = { blockedOn: null, target: l, priority: f };
        for (var h = 0; h < Is.length && f !== 0 && f < Is[h].priority; h++) ;
        Is.splice(h, 0, l), h === 0 && fP(l);
      }
    };
    var mP = t.version;
    if (mP !== "19.2.3")
      throw Error(
        r(
          527,
          mP,
          "19.2.3"
        )
      );
    K.findDOMNode = function(l) {
      var f = l._reactInternals;
      if (f === void 0)
        throw typeof l.render == "function" ? Error(r(188)) : (l = Object.keys(l).join(","), Error(r(268, l)));
      return l = u(f), l = l !== null ? d(l) : null, l = l === null ? null : l.stateNode, l;
    };
    var LG = {
      bundleType: 0,
      version: "19.2.3",
      rendererPackageName: "react-dom",
      currentDispatcherRef: F,
      reconcilerVersion: "19.2.3"
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
      var Wg = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!Wg.isDisabled && Wg.supportsFiber)
        try {
          it = Wg.inject(
            LG
          ), Et = Wg;
        } catch {
        }
    }
    return Hd.createRoot = function(l, f) {
      if (!o(l)) throw Error(r(299));
      var h = !1, w = "", R = SM, M = _M, q = EM;
      return f != null && (f.unstable_strictMode === !0 && (h = !0), f.identifierPrefix !== void 0 && (w = f.identifierPrefix), f.onUncaughtError !== void 0 && (R = f.onUncaughtError), f.onCaughtError !== void 0 && (M = f.onCaughtError), f.onRecoverableError !== void 0 && (q = f.onRecoverableError)), f = rP(
        l,
        1,
        !1,
        null,
        null,
        h,
        w,
        null,
        R,
        M,
        q,
        hP
      ), l[ia] = f.current, Iw(l), new Jw(f);
    }, Hd.hydrateRoot = function(l, f, h) {
      if (!o(l)) throw Error(r(299));
      var w = !1, R = "", M = SM, q = _M, Z = EM, re = null;
      return h != null && (h.unstable_strictMode === !0 && (w = !0), h.identifierPrefix !== void 0 && (R = h.identifierPrefix), h.onUncaughtError !== void 0 && (M = h.onUncaughtError), h.onCaughtError !== void 0 && (q = h.onCaughtError), h.onRecoverableError !== void 0 && (Z = h.onRecoverableError), h.formState !== void 0 && (re = h.formState)), f = rP(
        l,
        1,
        !0,
        f,
        h ?? null,
        w,
        R,
        re,
        M,
        q,
        Z,
        hP
      ), f.context = oP(null), h = f.current, w = eo(), w = Zf(w), R = bs(w), R.callback = null, xs(h, R, w), h = w, f.current.lanes = h, bl(f, h), mi(f), l[ia] = f.current, Iw(l), new qg(f);
    }, Hd.version = "19.2.3", Hd;
  }
  var CP;
  function JG() {
    if (CP) return tS.exports;
    CP = 1;
    function e() {
      if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
        } catch (t) {
          console.error(t);
        }
    }
    return e(), tS.exports = QG(), tS.exports;
  }
  var eK = JG(), T = Oh();
  const On = /* @__PURE__ */ Xi(T), sc = /* @__PURE__ */ HG({
    __proto__: null,
    default: On
  }, [T]), Xn = {
    /** Debug level - most verbose, for development debugging */
    DEBUG: 0,
    /** Info level - general information about application flow */
    INFO: 10,
    /** Warning level - concerning but non-critical issues */
    WARN: 20,
    /** Error level - critical problems requiring attention */
    ERROR: 30
  }, V4 = Xn.DEBUG, H4 = Xn.INFO, tK = Xn.WARN, nK = Xn.ERROR, kP = (e) => typeof e == "string" ? e : e === Xn.DEBUG ? "DEBUG" : e === Xn.INFO ? "INFO" : e === Xn.WARN ? "WARN" : e === Xn.ERROR ? "ERROR" : "UNKNOWN";
  function rK() {
    const e = [];
    return function(t, n) {
      if (typeof n != "object" || n === null)
        return n;
      for (; e.length > 0 && e.at(-1) !== this; )
        e.pop();
      return e.includes(n) ? "[Circular]" : (e.push(n), n);
    };
  }
  const TP = (e) => {
    if (typeof e == "number") return e;
    const t = e.toLowerCase();
    if (t === "debug") return Xn.DEBUG;
    if (t === "info") return Xn.INFO;
    if (t === "warn" || t === "warning") return Xn.WARN;
    if (t === "error") return Xn.ERROR;
    throw new Error(`Unknown log level: ${e}`);
  };
  class ik {
    /**
     * Create a new BaseLogger instance.
     *
     * @param {string} name - The name/identifier for this logger
     * @param {number | string} [level=LEVELS.INFO] - Initial log level
     * @param {boolean} [with_timestamp=true] - Whether to include timestamps
     * @example
     * ```typescript
     * const logger = new MyLogger("DatabaseService", "DEBUG", true);
     * ```
     */
    constructor(t, n = Xn.INFO, r = !0) {
      this.name = t, this.level = TP(n), this._level_name = kP(this.level), this.with_timestamp = r;
    }
    /**
     * Set the logging level for this logger instance.
     *
     * @param {number | string} level - The new log level (numeric or string)
     * @example
     * ```typescript
     * logger.set_level(DEBUG); // Enable debug logging
     * logger.set_level("debug"); // Same as above using string
     * ```
     */
    set_level(t) {
      typeof t == "string" && (t = TP(t)), this.level = t, this._level_name = kP(this.level);
    }
    /**
     * Get the string representation of the current log level.
     *
     * @returns {string} The current log level as a string
     * @example
     * ```typescript
     * logger.level_name // "INFO"
     * ```
     */
    get level_name() {
      return this._level_name;
    }
    /**
     * Format a log message with level, timestamp, and arguments.
     *
     * @param {string} levelstring - The log level string (DEBUG, INFO, etc.)
     * @param {string} message - The primary log message
     * @param {...any[]} args - Additional arguments to include
     * @returns {string} The formatted log message
     * @example
     * ```typescript
     * // Returns: "12/25/2023, 10:30:15 AM [MyApp] INFO: User logged in {userId: 123}"
     * logger.format_message("INFO", "User logged in", {userId: 123});
     * ```
     */
    format_message(t, n, ...r) {
      return `${this.with_timestamp ? (/* @__PURE__ */ new Date()).toLocaleString() : ""} [${this.name}] ${t}: ${n} ${r.map((i) => JSON.stringify(i, rK())).join(" ")}`.trim();
    }
    /**
     * Log a debug message if the current level allows it.
     *
     * @param {string} message - The primary log message
     * @param {...any[]} args - Additional context arguments
     */
    debug(t, ...n) {
      this.level <= Xn.DEBUG && this.out_debug(this.format_message("DEBUG", t, ...n));
    }
    /**
     * Log an info message if the current level allows it.
     *
     * @param {string} message - The primary log message
     * @param {...any[]} args - Additional context arguments
     */
    info(t, ...n) {
      this.level <= Xn.INFO && this.out_info(this.format_message("INFO", t, ...n));
    }
    /**
     * Log a warning message if the current level allows it.
     *
     * @param {string} message - The primary log message
     * @param {...any[]} args - Additional context arguments
     */
    warn(t, ...n) {
      this.level <= Xn.WARN && this.out_warn(this.format_message("WARN", t, ...n));
    }
    /**
     * Log an error message if the current level allows it.
     *
     * @param {string} message - The primary log message
     * @param {Error} [error] - Optional Error object for stack trace handling
     */
    error(t, n) {
      this.level <= Xn.ERROR && this.out_error(this.format_message("ERROR", t), n);
    }
  }
  class ak extends ik {
    /**
     * Create a new ConsoleLogger instance.
     *
     * @param {string} name - The name/identifier for this logger
     * @param {number | string} [level=LEVELS.INFO] - Initial log level
     * @example
     * ```typescript
     * const logger = new ConsoleLogger("API", "WARN");
     * ```
     */
    constructor(t, n = Xn.INFO) {
      super(t, n);
    }
    /**
     * Output debug message to console.debug.
     *
     * @protected
     * @param {string} formatted_message - The formatted message to output
     */
    out_debug(t) {
      console.debug(t);
    }
    /**
     * Output info message to console.info.
     *
     * @protected
     * @param {string} formatted_message - The formatted message to output
     */
    out_info(t) {
      console.info(t);
    }
    /**
     * Output warning message to console.warn.
     *
     * @protected
     * @param {string} formatted_message - The formatted message to output
     */
    out_warn(t) {
      console.warn(t);
    }
    /**
     * Output error message to console.error.
     *
     * @protected
     * @param {string} formatted_message - The formatted message to output
     * @param {Error | undefined} error - Optional Error object for stack trace handling
     */
    out_error(t, n) {
      console.error(t), n && console.error(n);
    }
  }
  function aS(e) {
    return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }
  class oK extends ik {
    /**
     * Create a new DivLogger instance.
     *
     * @param {HTMLDivElement} div - The HTML div element to append log messages to
     * @param {string} name - The name/identifier for this logger
     * @param {number | string} [level=LEVELS.INFO] - Initial log level
     * @example
     * ```typescript
     * const logContainer = document.createElement('div');
     * const logger = new DivLogger(logContainer, "WebWorker", "DEBUG");
     * ```
     */
    constructor(t, n, r = Xn.INFO) {
      super(n, r), this._div = t;
    }
    /**
     * Format a log message with HTML escaping for safe DOM insertion.
     *
     * Overrides the base implementation to automatically escape HTML content,
     * preventing XSS vulnerabilities when displaying logs in web interfaces.
     *
     * @param {string} levelstring - The log level string (DEBUG, INFO, etc.)
     * @param {string} message - The primary log message
     * @param {...any[]} args - Additional arguments to include
     * @returns {string} The formatted and HTML-escaped log message
     * @example
     * ```typescript
     * // Input: "User input: <script>alert('xss')<\/script>"
     * // Output: "12/25/2023, 10:30:15 AM [UI] INFO: User input: &lt;script&gt;alert('xss')&lt;/script&gt;"
     * ```
     */
    format_message(t, n, ...r) {
      return aS(super.format_message(t, n, ...r));
    }
    /**
     * Output debug message as HTML div with 'debug' class.
     *
     * @protected
     * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
     */
    out_debug(t) {
      this._div.innerHTML += `<div class="debug">${t}</div>`;
    }
    /**
     * Output info message as HTML div with 'info' class.
     *
     * @protected
     * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
     */
    out_info(t) {
      this._div.innerHTML += `<div class="info">${t}</div>`;
    }
    /**
     * Output warning message as HTML div with 'warn' class.
     *
     * @protected
     * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
     */
    out_warn(t) {
      this._div.innerHTML += `<div class="warn">${t}</div>`;
    }
    /**
     * Output error message as HTML div with 'error' class.
     *
     * @protected
     * @param {string} formatted_message - The pre-formatted and HTML-escaped message to output
     * @param {Error | undefined} error - Optional Error object for stack trace handling
     */
    out_error(t, n) {
      let r = t;
      if (n) {
        const o = n.stack ? aS(n.stack) : aS(n.message);
        r += `<br><pre>${o}</pre>`;
      }
      this._div.innerHTML += `<div class="error">${r}</div>`;
    }
  }
  function iK(e) {
    const t = window.atob(e), n = t.length, r = new Uint8Array(n);
    for (let o = 0; o < n; o++)
      r[o] = t.charCodeAt(o);
    return r;
  }
  function aK(e, t) {
    return new Blob([e], { type: t });
  }
  function sK(e, t) {
    return aK(iK(e), t);
  }
  function lK(e, t, n) {
    const r = sK(e, n), o = URL.createObjectURL(r), i = document.createElement("a");
    i.href = o, i.download = t, i.click(), URL.revokeObjectURL(o), i.remove();
  }
  function cK(e, t = !0) {
    return new Promise((n, r) => {
      const o = new FileReader();
      o.onload = () => {
        const i = o.result;
        n(t ? i.split(",")[1] : i);
      }, o.onerror = () => r(o.error), o.readAsDataURL(e);
    });
  }
  function uK(e) {
    return new Promise((t, n) => {
      const r = document.createElement("input");
      r.type = "file", r.accept = e, r.onchange = () => {
        const o = r.files?.[0];
        o ? t(o) : n(new Error("No file selected"));
      }, r.oncancel = () => {
        n(new Error("File selection cancelled"));
      }, r.click();
    });
  }
  function fK(e) {
    return uK(e).then(cK);
  }
  async function dK(e, t = !0) {
    try {
      const n = await fetch(e);
      if (!n.ok)
        throw new Error(
          `Failed to fetch from URL: ${n.status} ${n.statusText}`
        );
      const r = await n.blob();
      return await new Promise((i, a) => {
        const s = new FileReader();
        s.onload = () => {
          const c = s.result;
          typeof c != "string" && (a("Failed to convert URL to Base64: No result from FileReader"), a(s.error)), i(t ? c.split(",")[1] : c);
        }, s.onerror = () => a(s.error), s.readAsDataURL(r);
      });
    } catch (n) {
      throw console.error("Error converting URL to Base64:", n), n;
    }
  }
  function Ws(e) {
    if (Object.prototype.toString.call(e) !== "[object Object]")
      return !1;
    const t = Object.getPrototypeOf(e);
    return t === null || t === Object.prototype;
  }
  function sk(e, t, n = /* @__PURE__ */ new WeakMap()) {
    if (e === t) return !0;
    if (typeof e != "object" || e === null || typeof t != "object" || t === null)
      return !1;
    if (n.has(e))
      return n.get(e) === t;
    if (n.set(e, t), e.constructor !== t.constructor) return !1;
    if (e.constructor === Object || e.constructor === Array) {
      const r = Object.keys(e), o = Object.keys(t);
      if (r.length !== o.length) return !1;
      for (const i of r)
        if (!o.includes(i) || !sk(e[i], t[i], n)) return !1;
    }
    return e instanceof Date && t instanceof Date ? e.getTime() === t.getTime() : !0;
  }
  const tl = (e, t) => {
    let n = !1;
    if (!Ws(e))
      throw new Error("Target must be a plain object not" + typeof e);
    if (!Ws(t))
      throw new Error("Source must be a plain object not" + typeof t);
    const r = { ...e };
    return Object.keys(t).forEach((o) => {
      const i = t[o], a = e[o];
      if (Ws(i) && Ws(a)) {
        const { new_obj: s, change: c } = tl(
          a,
          i
        );
        c && (n = !0, r[o] = s);
      } else sk(a, i) || (n = !0, r[o] = i);
    }), { new_obj: r, change: n };
  }, lk = (e, t) => {
    let n = !1;
    if (!Ws(e))
      throw new Error("Target must be a plain object");
    if (!Ws(t))
      throw new Error("Source must be a plain object");
    const r = { ...e };
    return Object.keys(t).forEach((o) => {
      const i = t[o], a = e[o];
      if (!(a === void 0 && i === void 0)) {
        if (a === void 0) {
          n = !0, r[o] = i;
          return;
        }
        if (Ws(i) && Ws(a)) {
          const { new_obj: s, change: c } = lk(
            a,
            i
          );
          c && (n = !0, r[o] = s);
        }
      }
    }), { new_obj: r, change: n };
  }, Z0 = (e, t = void 0) => {
    const n = JSON.stringify(e);
    return (r) => {
      let o = JSON.parse(n);
      return t !== void 0 && (o = t(o)), r === void 0 ? o : lk(r, o).new_obj;
    };
  }, To = (e, t) => t === void 0 ? [e, !1] : [t, e !== t];
  function q4(e, t) {
    throw new Error("Unhandled case: " + e + " with: " + JSON.stringify(t));
  }
  const qu = (e, t) => {
    if (t === void 0) return [e, !1];
    if (e === void 0) return [t, t !== void 0];
    const { new_obj: n, change: r } = tl(e, t);
    return [n, r];
  }, pK = ({ error: e }) => /* @__PURE__ */ S.jsxs("div", { className: "error-div", children: [
    /* @__PURE__ */ S.jsx("h1", { children: "Error" }),
    /* @__PURE__ */ S.jsx("p", { children: e.message })
  ] });
  var _c = U4();
  const dp = /* @__PURE__ */ Xi(_c), Q0 = T.createContext(
    void 0
  ), Gs = T.forwardRef((e, t) => {
    const {
      asChild: n = !1,
      children: r,
      className: o,
      style: i,
      htime: a = 300,
      vtime: s = 300,
      hdelay: c = 0,
      vdelay: u = 200,
      zIndex: d = 9999,
      ...p
    } = e, [m, g] = T.useState(!1), [y, b] = T.useState({}), v = T.useRef(null), x = T.useRef(null);
    T.useImperativeHandle(t, () => v.current, []);
    const E = T.useMemo(
      () => ({
        horizontal: a,
        vertical: s,
        horizontalDelay: c,
        verticalDelay: u
      }),
      [a, s, c, u]
    ), _ = T.useCallback(
      () => Math.max(
        E.horizontal + E.horizontalDelay,
        E.vertical + E.verticalDelay
      ),
      [E]
    ), C = T.useCallback(async () => {
      if (v.current)
        try {
          const L = v.current.getBoundingClientRect();
          x.current = L, b({
            position: "fixed",
            top: `${L.top}px`,
            left: `${L.left}px`,
            width: `${L.width}px`,
            height: `${L.height}px`,
            zIndex: d,
            transition: "none"
          }), g(!0), v.current.offsetHeight, b((N) => ({
            ...N,
            transition: [
              `width ${E.horizontal}ms ease-in-out ${E.horizontalDelay}ms`,
              `left ${E.horizontal}ms ease-in-out ${E.horizontalDelay}ms`,
              `height ${E.vertical}ms ease-in-out ${E.verticalDelay}ms`,
              `top ${E.vertical}ms ease-in-out ${E.verticalDelay}ms`
            ].join(", ")
          })), requestAnimationFrame(() => {
            b((N) => ({
              ...N,
              top: "0",
              left: "0",
              width: "100vw",
              height: "100vh"
            }));
          }), await new Promise((N) => setTimeout(N, _()));
        } catch (L) {
          console.warn("Error during expand animation:", L), g(!0);
        }
    }, [E, d, _]), k = T.useCallback(async () => {
      if (!v.current || !x.current) return;
      const L = x.current;
      b((N) => ({
        ...N,
        transition: [
          `width ${E.horizontal}ms ease-in-out ${E.verticalDelay}ms`,
          `left ${E.horizontal}ms ease-in-out ${E.verticalDelay}ms`,
          `height ${E.vertical}ms ease-in-out ${E.horizontalDelay}ms`,
          `top ${E.vertical}ms ease-in-out ${E.horizontalDelay}ms`
        ].join(", ")
      })), requestAnimationFrame(() => {
        b((N) => ({
          ...N,
          top: `${L.top}px`,
          left: `${L.left}px`,
          width: `${L.width}px`,
          height: `${L.height}px`
        }));
      }), await new Promise((N) => setTimeout(N, _())), b({}), g(!1), x.current = null;
    }, [E, _]), A = T.useCallback(async () => {
      m ? await k() : await C();
    }, [m, C, k]), O = T.useMemo(
      () => ({ isExpanded: m, toggleExpand: A }),
      [m, A]
    ), P = T.useMemo(
      () => ({ ...i, ...y }),
      [i, y]
    );
    let I;
    if (n && T.isValidElement(r)) {
      const L = r;
      I = T.cloneElement(L, {
        ref: v,
        className: [L.props.className, o].filter(Boolean).join(" "),
        style: { ...L.props.style, ...P },
        ...p
      });
    } else
      I = /* @__PURE__ */ S.jsx("div", { ref: v, className: o, style: P, ...p, children: r });
    const $ = /* @__PURE__ */ S.jsx(Q0.Provider, { value: O, children: I });
    return m ? _c.createPortal($, document.body) : $;
  });
  Gs.displayName = "SmoothExpand";
  Gs.Trigger = function({
    children: t,
    className: n
  }) {
    const r = T.useContext(Q0);
    if (!r)
      throw new Error(
        "SmoothExpand.Trigger must be used within a SmoothExpand component"
      );
    return /* @__PURE__ */ S.jsx(
      "div",
      {
        className: n,
        style: { cursor: "pointer" },
        onClick: r.toggleExpand,
        role: "button",
        tabIndex: 0,
        onKeyDown: (o) => {
          (o.key === "Enter" || o.key === " ") && (o.preventDefault(), r.toggleExpand());
        },
        children: t
      }
    );
  };
  Gs.Expanded = function({
    children: t
  }) {
    const n = T.useContext(Q0);
    if (!n)
      throw new Error(
        "SmoothExpand.Expanded must be used within a SmoothExpand component"
      );
    return n.isExpanded ? /* @__PURE__ */ S.jsx(S.Fragment, { children: t }) : null;
  };
  Gs.Collapsed = function({
    children: t
  }) {
    const n = T.useContext(Q0);
    if (!n)
      throw new Error(
        "SmoothExpand.Collapsed must be used within a SmoothExpand component"
      );
    return n.isExpanded ? null : /* @__PURE__ */ S.jsx(S.Fragment, { children: t });
  };
  const J0 = T.createContext(
    void 0
  ), $a = T.forwardRef((e, t) => {
    const { asChild: n = !1, children: r, className: o, style: i, ...a } = e, [s, c] = T.useState(!1), u = T.useRef(null);
    T.useImperativeHandle(t, () => u.current, []);
    const d = T.useCallback(async (v) => {
      const x = v;
      if (v.requestFullscreen)
        await v.requestFullscreen();
      else if (x.mozRequestFullScreen)
        await x.mozRequestFullScreen();
      else if (x.webkitRequestFullscreen)
        await x.webkitRequestFullscreen();
      else if (x.msRequestFullscreen)
        await x.msRequestFullscreen();
      else
        throw new Error("Fullscreen API is not supported in this browser");
    }, []), p = T.useCallback(async () => {
      const v = document;
      if (document.exitFullscreen)
        await document.exitFullscreen();
      else if (v.mozCancelFullScreen)
        await v.mozCancelFullScreen();
      else if (v.webkitExitFullscreen)
        await v.webkitExitFullscreen();
      else if (v.msExitFullscreen)
        await v.msExitFullscreen();
      else
        throw new Error("Exit fullscreen API is not supported in this browser");
    }, []), m = T.useCallback(async () => {
      try {
        const v = u.current;
        if (!v) {
          console.warn("FullScreen: No element reference available");
          return;
        }
        s ? await p() : await d(v);
      } catch (v) {
        console.error("FullScreen: Error toggling fullscreen mode", v);
      }
    }, [s, d, p]), g = T.useCallback(() => {
      const v = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement);
      c(v);
    }, []);
    T.useEffect(() => {
      const v = [
        "fullscreenchange",
        "webkitfullscreenchange",
        "mozfullscreenchange",
        "MSFullscreenChange"
      ];
      return v.forEach((x) => {
        document.addEventListener(x, g);
      }), () => {
        v.forEach((x) => {
          document.removeEventListener(x, g);
        });
      };
    }, [g]);
    const y = T.useMemo(
      () => ({ isFullScreen: s, toggleFullscreen: m }),
      [s, m]
    );
    let b;
    if (n && T.isValidElement(r)) {
      const v = r;
      b = T.cloneElement(v, {
        ref: u,
        className: [v.props.className, o].filter(Boolean).join(" "),
        style: { ...v.props.style, ...i },
        ...a
      });
    } else
      b = /* @__PURE__ */ S.jsx("div", { ref: u, className: o, style: i, ...a, children: r });
    return /* @__PURE__ */ S.jsx(J0.Provider, { value: y, children: b });
  });
  $a.displayName = "FullScreen";
  $a.Trigger = function({
    children: t,
    className: n
  }) {
    const r = T.useContext(J0);
    if (!r)
      throw new Error(
        "FullScreen.Trigger must be used within a FullScreen component"
      );
    return /* @__PURE__ */ S.jsx(
      "div",
      {
        className: n,
        style: { cursor: "pointer" },
        onClick: r.toggleFullscreen,
        role: "button",
        tabIndex: 0,
        onKeyDown: (o) => {
          (o.key === "Enter" || o.key === " ") && (o.preventDefault(), r.toggleFullscreen());
        },
        children: t
      }
    );
  };
  $a.InFullScreen = function({
    children: t
  }) {
    const n = T.useContext(J0);
    if (!n)
      throw new Error(
        "FullScreen.InFullScreen must be used within a FullScreen component"
      );
    return n.isFullScreen ? /* @__PURE__ */ S.jsx(S.Fragment, { children: t }) : null;
  };
  $a.OutFullScreen = function({
    children: t
  }) {
    const n = T.useContext(J0);
    if (!n)
      throw new Error(
        "FullScreen.OutFullScreen must be used within a FullScreen component"
      );
    return n.isFullScreen ? null : /* @__PURE__ */ S.jsx(S.Fragment, { children: t });
  };
  var sS = { exports: {} }, lS, AP;
  function hK() {
    if (AP) return lS;
    AP = 1;
    var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    return lS = e, lS;
  }
  var cS, RP;
  function mK() {
    if (RP) return cS;
    RP = 1;
    var e = /* @__PURE__ */ hK();
    function t() {
    }
    function n() {
    }
    return n.resetWarningCache = t, cS = function() {
      function r(a, s, c, u, d, p) {
        if (p !== e) {
          var m = new Error(
            "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
          );
          throw m.name = "Invariant Violation", m;
        }
      }
      r.isRequired = r;
      function o() {
        return r;
      }
      var i = {
        array: r,
        bigint: r,
        bool: r,
        func: r,
        number: r,
        object: r,
        string: r,
        symbol: r,
        any: r,
        arrayOf: o,
        element: r,
        elementType: r,
        instanceOf: o,
        node: r,
        objectOf: o,
        oneOf: o,
        oneOfType: o,
        shape: o,
        exact: o,
        checkPropTypes: n,
        resetWarningCache: t
      };
      return i.PropTypes = i, i;
    }, cS;
  }
  var OP;
  function gK() {
    return OP || (OP = 1, sS.exports = /* @__PURE__ */ mK()()), sS.exports;
  }
  var Yn = /* @__PURE__ */ gK();
  function W4(e) {
    var t, n, r = "";
    if (typeof e == "string" || typeof e == "number") r += e;
    else if (typeof e == "object") if (Array.isArray(e)) {
      var o = e.length;
      for (t = 0; t < o; t++) e[t] && (n = W4(e[t])) && (r && (r += " "), r += n);
    } else for (n in e) e[n] && (r && (r += " "), r += n);
    return r;
  }
  function $e() {
    for (var e, t, n = 0, r = "", o = arguments.length; n < o; n++) (e = arguments[n]) && (t = W4(e)) && (r && (r += " "), r += t);
    return r;
  }
  function rt(e, t, n = void 0) {
    const r = {};
    for (const o in e) {
      const i = e[o];
      let a = "", s = !0;
      for (let c = 0; c < i.length; c += 1) {
        const u = i[c];
        u && (a += (s === !0 ? "" : " ") + t(u), s = !1, n && n[u] && (a += " " + n[u]));
      }
      r[o] = a;
    }
    return r;
  }
  const G4 = /* @__PURE__ */ T.createContext();
  function Va(e, ...t) {
    const n = new URL(`https://mui.com/production-error/?code=${e}`);
    return t.forEach((r) => n.searchParams.append("args[]", r)), `Minified MUI error #${e}; visit ${n} for the full message.`;
  }
  function Ie(e) {
    if (typeof e != "string")
      throw new Error(Va(7));
    return e.charAt(0).toUpperCase() + e.slice(1);
  }
  var uS = { exports: {} }, nn = {};
  var MP;
  function yK() {
    if (MP) return nn;
    MP = 1;
    var e = /* @__PURE__ */ Symbol.for("react.transitional.element"), t = /* @__PURE__ */ Symbol.for("react.portal"), n = /* @__PURE__ */ Symbol.for("react.fragment"), r = /* @__PURE__ */ Symbol.for("react.strict_mode"), o = /* @__PURE__ */ Symbol.for("react.profiler"), i = /* @__PURE__ */ Symbol.for("react.consumer"), a = /* @__PURE__ */ Symbol.for("react.context"), s = /* @__PURE__ */ Symbol.for("react.forward_ref"), c = /* @__PURE__ */ Symbol.for("react.suspense"), u = /* @__PURE__ */ Symbol.for("react.suspense_list"), d = /* @__PURE__ */ Symbol.for("react.memo"), p = /* @__PURE__ */ Symbol.for("react.lazy"), m = /* @__PURE__ */ Symbol.for("react.view_transition"), g = /* @__PURE__ */ Symbol.for("react.client.reference");
    function y(b) {
      if (typeof b == "object" && b !== null) {
        var v = b.$$typeof;
        switch (v) {
          case e:
            switch (b = b.type, b) {
              case n:
              case o:
              case r:
              case c:
              case u:
              case m:
                return b;
              default:
                switch (b = b && b.$$typeof, b) {
                  case a:
                  case s:
                  case p:
                  case d:
                    return b;
                  case i:
                    return b;
                  default:
                    return v;
                }
            }
          case t:
            return v;
        }
      }
    }
    return nn.ContextConsumer = i, nn.ContextProvider = a, nn.Element = e, nn.ForwardRef = s, nn.Fragment = n, nn.Lazy = p, nn.Memo = d, nn.Portal = t, nn.Profiler = o, nn.StrictMode = r, nn.Suspense = c, nn.SuspenseList = u, nn.isContextConsumer = function(b) {
      return y(b) === i;
    }, nn.isContextProvider = function(b) {
      return y(b) === a;
    }, nn.isElement = function(b) {
      return typeof b == "object" && b !== null && b.$$typeof === e;
    }, nn.isForwardRef = function(b) {
      return y(b) === s;
    }, nn.isFragment = function(b) {
      return y(b) === n;
    }, nn.isLazy = function(b) {
      return y(b) === p;
    }, nn.isMemo = function(b) {
      return y(b) === d;
    }, nn.isPortal = function(b) {
      return y(b) === t;
    }, nn.isProfiler = function(b) {
      return y(b) === o;
    }, nn.isStrictMode = function(b) {
      return y(b) === r;
    }, nn.isSuspense = function(b) {
      return y(b) === c;
    }, nn.isSuspenseList = function(b) {
      return y(b) === u;
    }, nn.isValidElementType = function(b) {
      return typeof b == "string" || typeof b == "function" || b === n || b === o || b === r || b === c || b === u || typeof b == "object" && b !== null && (b.$$typeof === p || b.$$typeof === d || b.$$typeof === a || b.$$typeof === i || b.$$typeof === s || b.$$typeof === g || b.getModuleId !== void 0);
    }, nn.typeOf = y, nn;
  }
  var NP;
  function vK() {
    return NP || (NP = 1, uS.exports = /* @__PURE__ */ yK()), uS.exports;
  }
  var K4 = /* @__PURE__ */ vK();
  function Ri(e) {
    if (typeof e != "object" || e === null)
      return !1;
    const t = Object.getPrototypeOf(e);
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
  }
  function Y4(e) {
    if (/* @__PURE__ */ T.isValidElement(e) || K4.isValidElementType(e) || !Ri(e))
      return e;
    const t = {};
    return Object.keys(e).forEach((n) => {
      t[n] = Y4(e[n]);
    }), t;
  }
  function xr(e, t, n = {
    clone: !0
  }) {
    const r = n.clone ? {
      ...e
    } : e;
    return Ri(e) && Ri(t) && Object.keys(t).forEach((o) => {
      /* @__PURE__ */ T.isValidElement(t[o]) || K4.isValidElementType(t[o]) ? r[o] = t[o] : Ri(t[o]) && // Avoid prototype pollution
      Object.prototype.hasOwnProperty.call(e, o) && Ri(e[o]) ? r[o] = xr(e[o], t[o], n) : n.clone ? r[o] = Ri(t[o]) ? Y4(t[o]) : t[o] : r[o] = t[o];
    }), r;
  }
  function kp(e, t) {
    return t ? xr(e, t, {
      clone: !1
      // No need to clone deep, it's way faster.
    }) : e;
  }
  function PP(e, t) {
    if (!e.containerQueries)
      return t;
    const n = Object.keys(t).filter((r) => r.startsWith("@container")).sort((r, o) => {
      const i = /min-width:\s*([0-9.]+)/;
      return +(r.match(i)?.[1] || 0) - +(o.match(i)?.[1] || 0);
    });
    return n.length ? n.reduce((r, o) => {
      const i = t[o];
      return delete r[o], r[o] = i, r;
    }, {
      ...t
    }) : t;
  }
  function bK(e, t) {
    return t === "@" || t.startsWith("@") && (e.some((n) => t.startsWith(`@${n}`)) || !!t.match(/^@\d/));
  }
  function xK(e, t) {
    const n = t.match(/^@([^/]+)?\/?(.+)?$/);
    if (!n)
      return null;
    const [, r, o] = n, i = Number.isNaN(+r) ? r || 0 : +r;
    return e.containerQueries(o).up(i);
  }
  function wK(e) {
    const t = (i, a) => i.replace("@media", a ? `@container ${a}` : "@container");
    function n(i, a) {
      i.up = (...s) => t(e.breakpoints.up(...s), a), i.down = (...s) => t(e.breakpoints.down(...s), a), i.between = (...s) => t(e.breakpoints.between(...s), a), i.only = (...s) => t(e.breakpoints.only(...s), a), i.not = (...s) => {
        const c = t(e.breakpoints.not(...s), a);
        return c.includes("not all and") ? c.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or") : c;
      };
    }
    const r = {}, o = (i) => (n(r, i), r);
    return n(o), {
      ...e,
      containerQueries: o
    };
  }
  const eb = {
    xs: 0,
    // phone
    sm: 600,
    // tablet
    md: 900,
    // small laptop
    lg: 1200,
    // desktop
    xl: 1536
    // large screen
  }, IP = {
    // Sorted ASC by size. That's important.
    // It can't be configured as it's used statically for propTypes.
    keys: ["xs", "sm", "md", "lg", "xl"],
    up: (e) => `@media (min-width:${eb[e]}px)`
  }, SK = {
    containerQueries: (e) => ({
      up: (t) => {
        let n = typeof t == "number" ? t : eb[t] || t;
        return typeof n == "number" && (n = `${n}px`), e ? `@container ${e} (min-width:${n})` : `@container (min-width:${n})`;
      }
    })
  };
  function Ha(e, t, n) {
    const r = e.theme || {};
    if (Array.isArray(t)) {
      const i = r.breakpoints || IP;
      return t.reduce((a, s, c) => (a[i.up(i.keys[c])] = n(t[c]), a), {});
    }
    if (typeof t == "object") {
      const i = r.breakpoints || IP;
      return Object.keys(t).reduce((a, s) => {
        if (bK(i.keys, s)) {
          const c = xK(r.containerQueries ? r : SK, s);
          c && (a[c] = n(t[s], s));
        } else if (Object.keys(i.values || eb).includes(s)) {
          const c = i.up(s);
          a[c] = n(t[s], s);
        } else {
          const c = s;
          a[c] = t[c];
        }
        return a;
      }, {});
    }
    return n(t);
  }
  function _K(e = {}) {
    return e.keys?.reduce((n, r) => {
      const o = e.up(r);
      return n[o] = {}, n;
    }, {}) || {};
  }
  function $P(e, t) {
    return e.reduce((n, r) => {
      const o = n[r];
      return (!o || Object.keys(o).length === 0) && delete n[r], n;
    }, t);
  }
  function tb(e, t, n = !0) {
    if (!t || typeof t != "string")
      return null;
    if (e && e.vars && n) {
      const r = `vars.${t}`.split(".").reduce((o, i) => o && o[i] ? o[i] : null, e);
      if (r != null)
        return r;
    }
    return t.split(".").reduce((r, o) => r && r[o] != null ? r[o] : null, e);
  }
  function Zv(e, t, n, r = n) {
    let o;
    return typeof e == "function" ? o = e(n) : Array.isArray(e) ? o = e[n] || r : o = tb(e, n) || r, t && (o = t(o, r, e)), o;
  }
  function $n(e) {
    const {
      prop: t,
      cssProperty: n = e.prop,
      themeKey: r,
      transform: o
    } = e, i = (a) => {
      if (a[t] == null)
        return null;
      const s = a[t], c = a.theme, u = tb(c, r) || {};
      return Ha(a, s, (p) => {
        let m = Zv(u, o, p);
        return p === m && typeof p == "string" && (m = Zv(u, o, `${t}${p === "default" ? "" : Ie(p)}`, p)), n === !1 ? m : {
          [n]: m
        };
      });
    };
    return i.propTypes = {}, i.filterProps = [t], i;
  }
  function EK(e) {
    const t = {};
    return (n) => (t[n] === void 0 && (t[n] = e(n)), t[n]);
  }
  const CK = {
    m: "margin",
    p: "padding"
  }, kK = {
    t: "Top",
    r: "Right",
    b: "Bottom",
    l: "Left",
    x: ["Left", "Right"],
    y: ["Top", "Bottom"]
  }, jP = {
    marginX: "mx",
    marginY: "my",
    paddingX: "px",
    paddingY: "py"
  }, TK = EK((e) => {
    if (e.length > 2)
      if (jP[e])
        e = jP[e];
      else
        return [e];
    const [t, n] = e.split(""), r = CK[t], o = kK[n] || "";
    return Array.isArray(o) ? o.map((i) => r + i) : [r + o];
  }), ck = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], uk = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
  [...ck, ...uk];
  function Mh(e, t, n, r) {
    const o = tb(e, t, !0) ?? n;
    return typeof o == "number" || typeof o == "string" ? (i) => typeof i == "string" ? i : typeof o == "string" ? o.startsWith("var(") && i === 0 ? 0 : o.startsWith("var(") && i === 1 ? o : `calc(${i} * ${o})` : o * i : Array.isArray(o) ? (i) => {
      if (typeof i == "string")
        return i;
      const a = Math.abs(i), s = o[a];
      return i >= 0 ? s : typeof s == "number" ? -s : typeof s == "string" && s.startsWith("var(") ? `calc(-1 * ${s})` : `-${s}`;
    } : typeof o == "function" ? o : () => {
    };
  }
  function fk(e) {
    return Mh(e, "spacing", 8);
  }
  function Nh(e, t) {
    return typeof t == "string" || t == null ? t : e(t);
  }
  function AK(e, t) {
    return (n) => e.reduce((r, o) => (r[o] = Nh(t, n), r), {});
  }
  function RK(e, t, n, r) {
    if (!t.includes(n))
      return null;
    const o = TK(n), i = AK(o, r), a = e[n];
    return Ha(e, a, i);
  }
  function X4(e, t) {
    const n = fk(e.theme);
    return Object.keys(e).map((r) => RK(e, t, r, n)).reduce(kp, {});
  }
  function An(e) {
    return X4(e, ck);
  }
  An.propTypes = {};
  An.filterProps = ck;
  function Rn(e) {
    return X4(e, uk);
  }
  Rn.propTypes = {};
  Rn.filterProps = uk;
  function nb(...e) {
    const t = e.reduce((r, o) => (o.filterProps.forEach((i) => {
      r[i] = o;
    }), r), {}), n = (r) => Object.keys(r).reduce((o, i) => t[i] ? kp(o, t[i](r)) : o, {});
    return n.propTypes = {}, n.filterProps = e.reduce((r, o) => r.concat(o.filterProps), []), n;
  }
  function Ao(e) {
    return typeof e != "number" ? e : `${e}px solid`;
  }
  function Fo(e, t) {
    return $n({
      prop: e,
      themeKey: "borders",
      transform: t
    });
  }
  const OK = Fo("border", Ao), MK = Fo("borderTop", Ao), NK = Fo("borderRight", Ao), PK = Fo("borderBottom", Ao), IK = Fo("borderLeft", Ao), $K = Fo("borderColor"), jK = Fo("borderTopColor"), DK = Fo("borderRightColor"), FK = Fo("borderBottomColor"), LK = Fo("borderLeftColor"), zK = Fo("outline", Ao), BK = Fo("outlineColor"), rb = (e) => {
    if (e.borderRadius !== void 0 && e.borderRadius !== null) {
      const t = Mh(e.theme, "shape.borderRadius", 4), n = (r) => ({
        borderRadius: Nh(t, r)
      });
      return Ha(e, e.borderRadius, n);
    }
    return null;
  };
  rb.propTypes = {};
  rb.filterProps = ["borderRadius"];
  nb(OK, MK, NK, PK, IK, $K, jK, DK, FK, LK, rb, zK, BK);
  const ob = (e) => {
    if (e.gap !== void 0 && e.gap !== null) {
      const t = Mh(e.theme, "spacing", 8), n = (r) => ({
        gap: Nh(t, r)
      });
      return Ha(e, e.gap, n);
    }
    return null;
  };
  ob.propTypes = {};
  ob.filterProps = ["gap"];
  const ib = (e) => {
    if (e.columnGap !== void 0 && e.columnGap !== null) {
      const t = Mh(e.theme, "spacing", 8), n = (r) => ({
        columnGap: Nh(t, r)
      });
      return Ha(e, e.columnGap, n);
    }
    return null;
  };
  ib.propTypes = {};
  ib.filterProps = ["columnGap"];
  const ab = (e) => {
    if (e.rowGap !== void 0 && e.rowGap !== null) {
      const t = Mh(e.theme, "spacing", 8), n = (r) => ({
        rowGap: Nh(t, r)
      });
      return Ha(e, e.rowGap, n);
    }
    return null;
  };
  ab.propTypes = {};
  ab.filterProps = ["rowGap"];
  const UK = $n({
    prop: "gridColumn"
  }), VK = $n({
    prop: "gridRow"
  }), HK = $n({
    prop: "gridAutoFlow"
  }), qK = $n({
    prop: "gridAutoColumns"
  }), WK = $n({
    prop: "gridAutoRows"
  }), GK = $n({
    prop: "gridTemplateColumns"
  }), KK = $n({
    prop: "gridTemplateRows"
  }), YK = $n({
    prop: "gridTemplateAreas"
  }), XK = $n({
    prop: "gridArea"
  });
  nb(ob, ib, ab, UK, VK, HK, qK, WK, GK, KK, YK, XK);
  function Zu(e, t) {
    return t === "grey" ? t : e;
  }
  const ZK = $n({
    prop: "color",
    themeKey: "palette",
    transform: Zu
  }), QK = $n({
    prop: "bgcolor",
    cssProperty: "backgroundColor",
    themeKey: "palette",
    transform: Zu
  }), JK = $n({
    prop: "backgroundColor",
    themeKey: "palette",
    transform: Zu
  });
  nb(ZK, QK, JK);
  function oo(e) {
    return e <= 1 && e !== 0 ? `${e * 100}%` : e;
  }
  const eY = $n({
    prop: "width",
    transform: oo
  }), dk = (e) => {
    if (e.maxWidth !== void 0 && e.maxWidth !== null) {
      const t = (n) => {
        const r = e.theme?.breakpoints?.values?.[n] || eb[n];
        return r ? e.theme?.breakpoints?.unit !== "px" ? {
          maxWidth: `${r}${e.theme.breakpoints.unit}`
        } : {
          maxWidth: r
        } : {
          maxWidth: oo(n)
        };
      };
      return Ha(e, e.maxWidth, t);
    }
    return null;
  };
  dk.filterProps = ["maxWidth"];
  const tY = $n({
    prop: "minWidth",
    transform: oo
  }), nY = $n({
    prop: "height",
    transform: oo
  }), rY = $n({
    prop: "maxHeight",
    transform: oo
  }), oY = $n({
    prop: "minHeight",
    transform: oo
  });
  $n({
    prop: "size",
    cssProperty: "width",
    transform: oo
  });
  $n({
    prop: "size",
    cssProperty: "height",
    transform: oo
  });
  const iY = $n({
    prop: "boxSizing"
  });
  nb(eY, dk, tY, nY, rY, oY, iY);
  const Ph = {
    // borders
    border: {
      themeKey: "borders",
      transform: Ao
    },
    borderTop: {
      themeKey: "borders",
      transform: Ao
    },
    borderRight: {
      themeKey: "borders",
      transform: Ao
    },
    borderBottom: {
      themeKey: "borders",
      transform: Ao
    },
    borderLeft: {
      themeKey: "borders",
      transform: Ao
    },
    borderColor: {
      themeKey: "palette"
    },
    borderTopColor: {
      themeKey: "palette"
    },
    borderRightColor: {
      themeKey: "palette"
    },
    borderBottomColor: {
      themeKey: "palette"
    },
    borderLeftColor: {
      themeKey: "palette"
    },
    outline: {
      themeKey: "borders",
      transform: Ao
    },
    outlineColor: {
      themeKey: "palette"
    },
    borderRadius: {
      themeKey: "shape.borderRadius",
      style: rb
    },
    // palette
    color: {
      themeKey: "palette",
      transform: Zu
    },
    bgcolor: {
      themeKey: "palette",
      cssProperty: "backgroundColor",
      transform: Zu
    },
    backgroundColor: {
      themeKey: "palette",
      transform: Zu
    },
    // spacing
    p: {
      style: Rn
    },
    pt: {
      style: Rn
    },
    pr: {
      style: Rn
    },
    pb: {
      style: Rn
    },
    pl: {
      style: Rn
    },
    px: {
      style: Rn
    },
    py: {
      style: Rn
    },
    padding: {
      style: Rn
    },
    paddingTop: {
      style: Rn
    },
    paddingRight: {
      style: Rn
    },
    paddingBottom: {
      style: Rn
    },
    paddingLeft: {
      style: Rn
    },
    paddingX: {
      style: Rn
    },
    paddingY: {
      style: Rn
    },
    paddingInline: {
      style: Rn
    },
    paddingInlineStart: {
      style: Rn
    },
    paddingInlineEnd: {
      style: Rn
    },
    paddingBlock: {
      style: Rn
    },
    paddingBlockStart: {
      style: Rn
    },
    paddingBlockEnd: {
      style: Rn
    },
    m: {
      style: An
    },
    mt: {
      style: An
    },
    mr: {
      style: An
    },
    mb: {
      style: An
    },
    ml: {
      style: An
    },
    mx: {
      style: An
    },
    my: {
      style: An
    },
    margin: {
      style: An
    },
    marginTop: {
      style: An
    },
    marginRight: {
      style: An
    },
    marginBottom: {
      style: An
    },
    marginLeft: {
      style: An
    },
    marginX: {
      style: An
    },
    marginY: {
      style: An
    },
    marginInline: {
      style: An
    },
    marginInlineStart: {
      style: An
    },
    marginInlineEnd: {
      style: An
    },
    marginBlock: {
      style: An
    },
    marginBlockStart: {
      style: An
    },
    marginBlockEnd: {
      style: An
    },
    // display
    displayPrint: {
      cssProperty: !1,
      transform: (e) => ({
        "@media print": {
          display: e
        }
      })
    },
    display: {},
    overflow: {},
    textOverflow: {},
    visibility: {},
    whiteSpace: {},
    // flexbox
    flexBasis: {},
    flexDirection: {},
    flexWrap: {},
    justifyContent: {},
    alignItems: {},
    alignContent: {},
    order: {},
    flex: {},
    flexGrow: {},
    flexShrink: {},
    alignSelf: {},
    justifyItems: {},
    justifySelf: {},
    // grid
    gap: {
      style: ob
    },
    rowGap: {
      style: ab
    },
    columnGap: {
      style: ib
    },
    gridColumn: {},
    gridRow: {},
    gridAutoFlow: {},
    gridAutoColumns: {},
    gridAutoRows: {},
    gridTemplateColumns: {},
    gridTemplateRows: {},
    gridTemplateAreas: {},
    gridArea: {},
    // positions
    position: {},
    zIndex: {
      themeKey: "zIndex"
    },
    top: {},
    right: {},
    bottom: {},
    left: {},
    // shadows
    boxShadow: {
      themeKey: "shadows"
    },
    // sizing
    width: {
      transform: oo
    },
    maxWidth: {
      style: dk
    },
    minWidth: {
      transform: oo
    },
    height: {
      transform: oo
    },
    maxHeight: {
      transform: oo
    },
    minHeight: {
      transform: oo
    },
    boxSizing: {},
    // typography
    font: {
      themeKey: "font"
    },
    fontFamily: {
      themeKey: "typography"
    },
    fontSize: {
      themeKey: "typography"
    },
    fontStyle: {
      themeKey: "typography"
    },
    fontWeight: {
      themeKey: "typography"
    },
    letterSpacing: {},
    textTransform: {},
    lineHeight: {},
    textAlign: {},
    typography: {
      cssProperty: !1,
      themeKey: "typography"
    }
  };
  function aY(...e) {
    const t = e.reduce((r, o) => r.concat(Object.keys(o)), []), n = new Set(t);
    return e.every((r) => n.size === Object.keys(r).length);
  }
  function sY(e, t) {
    return typeof e == "function" ? e(t) : e;
  }
  function lY() {
    function e(n, r, o, i) {
      const a = {
        [n]: r,
        theme: o
      }, s = i[n];
      if (!s)
        return {
          [n]: r
        };
      const {
        cssProperty: c = n,
        themeKey: u,
        transform: d,
        style: p
      } = s;
      if (r == null)
        return null;
      if (u === "typography" && r === "inherit")
        return {
          [n]: r
        };
      const m = tb(o, u) || {};
      return p ? p(a) : Ha(a, r, (y) => {
        let b = Zv(m, d, y);
        return y === b && typeof y == "string" && (b = Zv(m, d, `${n}${y === "default" ? "" : Ie(y)}`, y)), c === !1 ? b : {
          [c]: b
        };
      });
    }
    function t(n) {
      const {
        sx: r,
        theme: o = {},
        nested: i
      } = n || {};
      if (!r)
        return null;
      const a = o.unstable_sxConfig ?? Ph;
      function s(c) {
        let u = c;
        if (typeof c == "function")
          u = c(o);
        else if (typeof c != "object")
          return c;
        if (!u)
          return null;
        const d = _K(o.breakpoints), p = Object.keys(d);
        let m = d;
        return Object.keys(u).forEach((g) => {
          const y = sY(u[g], o);
          if (y != null)
            if (typeof y == "object")
              if (a[g])
                m = kp(m, e(g, y, o, a));
              else {
                const b = Ha({
                  theme: o
                }, y, (v) => ({
                  [g]: v
                }));
                aY(b, y) ? m[g] = t({
                  sx: y,
                  theme: o,
                  nested: !0
                }) : m = kp(m, b);
              }
            else
              m = kp(m, e(g, y, o, a));
        }), !i && o.modularCssLayers ? {
          "@layer sx": PP(o, $P(p, m))
        } : PP(o, $P(p, m));
      }
      return Array.isArray(r) ? r.map(s) : s(r);
    }
    return t;
  }
  const nl = lY();
  nl.filterProps = ["sx"];
  const cY = (e) => {
    const t = {
      systemProps: {},
      otherProps: {}
    }, n = e?.theme?.unstable_sxConfig ?? Ph;
    return Object.keys(e).forEach((r) => {
      n[r] ? t.systemProps[r] = e[r] : t.otherProps[r] = e[r];
    }), t;
  };
  function pk(e) {
    const {
      sx: t,
      ...n
    } = e, {
      systemProps: r,
      otherProps: o
    } = cY(n);
    let i;
    return Array.isArray(t) ? i = [r, ...t] : typeof t == "function" ? i = (...a) => {
      const s = t(...a);
      return Ri(s) ? {
        ...r,
        ...s
      } : r;
    } : i = {
      ...r,
      ...t
    }, {
      ...o,
      sx: i
    };
  }
  function Ke() {
    return Ke = Object.assign ? Object.assign.bind() : function(e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];
        for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
      }
      return e;
    }, Ke.apply(null, arguments);
  }
  function uY(e) {
    if (e.sheet)
      return e.sheet;
    for (var t = 0; t < document.styleSheets.length; t++)
      if (document.styleSheets[t].ownerNode === e)
        return document.styleSheets[t];
  }
  function fY(e) {
    var t = document.createElement("style");
    return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
  }
  var dY = /* @__PURE__ */ (function() {
    function e(n) {
      var r = this;
      this._insertTag = function(o) {
        var i;
        r.tags.length === 0 ? r.insertionPoint ? i = r.insertionPoint.nextSibling : r.prepend ? i = r.container.firstChild : i = r.before : i = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(o, i), r.tags.push(o);
      }, this.isSpeedy = n.speedy === void 0 ? !0 : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
    }
    var t = e.prototype;
    return t.hydrate = function(r) {
      r.forEach(this._insertTag);
    }, t.insert = function(r) {
      this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(fY(this));
      var o = this.tags[this.tags.length - 1];
      if (this.isSpeedy) {
        var i = uY(o);
        try {
          i.insertRule(r, i.cssRules.length);
        } catch {
        }
      } else
        o.appendChild(document.createTextNode(r));
      this.ctr++;
    }, t.flush = function() {
      this.tags.forEach(function(r) {
        var o;
        return (o = r.parentNode) == null ? void 0 : o.removeChild(r);
      }), this.tags = [], this.ctr = 0;
    }, e;
  })(), mr = "-ms-", Qv = "-moz-", Bt = "-webkit-", Z4 = "comm", hk = "rule", mk = "decl", pY = "@import", Q4 = "@keyframes", hY = "@layer", mY = Math.abs, sb = String.fromCharCode, gY = Object.assign;
  function yY(e, t) {
    return cr(e, 0) ^ 45 ? (((t << 2 ^ cr(e, 0)) << 2 ^ cr(e, 1)) << 2 ^ cr(e, 2)) << 2 ^ cr(e, 3) : 0;
  }
  function J4(e) {
    return e.trim();
  }
  function vY(e, t) {
    return (e = t.exec(e)) ? e[0] : e;
  }
  function Ut(e, t, n) {
    return e.replace(t, n);
  }
  function mE(e, t) {
    return e.indexOf(t);
  }
  function cr(e, t) {
    return e.charCodeAt(t) | 0;
  }
  function Wp(e, t, n) {
    return e.slice(t, n);
  }
  function Ci(e) {
    return e.length;
  }
  function gk(e) {
    return e.length;
  }
  function Gg(e, t) {
    return t.push(e), e;
  }
  function bY(e, t) {
    return e.map(t).join("");
  }
  var lb = 1, ff = 1, eF = 0, Hr = 0, Vn = 0, Pf = "";
  function cb(e, t, n, r, o, i, a) {
    return { value: e, root: t, parent: n, type: r, props: o, children: i, line: lb, column: ff, length: a, return: "" };
  }
  function qd(e, t) {
    return gY(cb("", null, null, "", null, null, 0), e, { length: -e.length }, t);
  }
  function xY() {
    return Vn;
  }
  function wY() {
    return Vn = Hr > 0 ? cr(Pf, --Hr) : 0, ff--, Vn === 10 && (ff = 1, lb--), Vn;
  }
  function lo() {
    return Vn = Hr < eF ? cr(Pf, Hr++) : 0, ff++, Vn === 10 && (ff = 1, lb++), Vn;
  }
  function Li() {
    return cr(Pf, Hr);
  }
  function _v() {
    return Hr;
  }
  function Ih(e, t) {
    return Wp(Pf, e, t);
  }
  function Gp(e) {
    switch (e) {
      // \0 \t \n \r \s whitespace token
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      // ! + , / > @ ~ isolate token
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      // ; { } breakpoint token
      case 59:
      case 123:
      case 125:
        return 4;
      // : accompanied token
      case 58:
        return 3;
      // " ' ( [ opening delimit token
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      // ) ] closing delimit token
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function tF(e) {
    return lb = ff = 1, eF = Ci(Pf = e), Hr = 0, [];
  }
  function nF(e) {
    return Pf = "", e;
  }
  function Ev(e) {
    return J4(Ih(Hr - 1, gE(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
  }
  function SY(e) {
    for (; (Vn = Li()) && Vn < 33; )
      lo();
    return Gp(e) > 2 || Gp(Vn) > 3 ? "" : " ";
  }
  function _Y(e, t) {
    for (; --t && lo() && !(Vn < 48 || Vn > 102 || Vn > 57 && Vn < 65 || Vn > 70 && Vn < 97); )
      ;
    return Ih(e, _v() + (t < 6 && Li() == 32 && lo() == 32));
  }
  function gE(e) {
    for (; lo(); )
      switch (Vn) {
        // ] ) " '
        case e:
          return Hr;
        // " '
        case 34:
        case 39:
          e !== 34 && e !== 39 && gE(Vn);
          break;
        // (
        case 40:
          e === 41 && gE(e);
          break;
        // \
        case 92:
          lo();
          break;
      }
    return Hr;
  }
  function EY(e, t) {
    for (; lo() && e + Vn !== 57; )
      if (e + Vn === 84 && Li() === 47)
        break;
    return "/*" + Ih(t, Hr - 1) + "*" + sb(e === 47 ? e : lo());
  }
  function CY(e) {
    for (; !Gp(Li()); )
      lo();
    return Ih(e, Hr);
  }
  function kY(e) {
    return nF(Cv("", null, null, null, [""], e = tF(e), 0, [0], e));
  }
  function Cv(e, t, n, r, o, i, a, s, c) {
    for (var u = 0, d = 0, p = a, m = 0, g = 0, y = 0, b = 1, v = 1, x = 1, E = 0, _ = "", C = o, k = i, A = r, O = _; v; )
      switch (y = E, E = lo()) {
        // (
        case 40:
          if (y != 108 && cr(O, p - 1) == 58) {
            mE(O += Ut(Ev(E), "&", "&\f"), "&\f") != -1 && (x = -1);
            break;
          }
        // " ' [
        case 34:
        case 39:
        case 91:
          O += Ev(E);
          break;
        // \t \n \r \s
        case 9:
        case 10:
        case 13:
        case 32:
          O += SY(y);
          break;
        // \
        case 92:
          O += _Y(_v() - 1, 7);
          continue;
        // /
        case 47:
          switch (Li()) {
            case 42:
            case 47:
              Gg(TY(EY(lo(), _v()), t, n), c);
              break;
            default:
              O += "/";
          }
          break;
        // {
        case 123 * b:
          s[u++] = Ci(O) * x;
        // } ; \0
        case 125 * b:
        case 59:
        case 0:
          switch (E) {
            // \0 }
            case 0:
            case 125:
              v = 0;
            // ;
            case 59 + d:
              x == -1 && (O = Ut(O, /\f/g, "")), g > 0 && Ci(O) - p && Gg(g > 32 ? FP(O + ";", r, n, p - 1) : FP(Ut(O, " ", "") + ";", r, n, p - 2), c);
              break;
            // @ ;
            case 59:
              O += ";";
            // { rule/at-rule
            default:
              if (Gg(A = DP(O, t, n, u, d, o, s, _, C = [], k = [], p), i), E === 123)
                if (d === 0)
                  Cv(O, t, A, A, C, i, p, s, k);
                else
                  switch (m === 99 && cr(O, 3) === 110 ? 100 : m) {
                    // d l m s
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      Cv(e, A, A, r && Gg(DP(e, A, A, 0, 0, o, s, _, o, C = [], p), k), o, k, p, s, r ? C : k);
                      break;
                    default:
                      Cv(O, A, A, A, [""], k, 0, s, k);
                  }
          }
          u = d = g = 0, b = x = 1, _ = O = "", p = a;
          break;
        // :
        case 58:
          p = 1 + Ci(O), g = y;
        default:
          if (b < 1) {
            if (E == 123)
              --b;
            else if (E == 125 && b++ == 0 && wY() == 125)
              continue;
          }
          switch (O += sb(E), E * b) {
            // &
            case 38:
              x = d > 0 ? 1 : (O += "\f", -1);
              break;
            // ,
            case 44:
              s[u++] = (Ci(O) - 1) * x, x = 1;
              break;
            // @
            case 64:
              Li() === 45 && (O += Ev(lo())), m = Li(), d = p = Ci(_ = O += CY(_v())), E++;
              break;
            // -
            case 45:
              y === 45 && Ci(O) == 2 && (b = 0);
          }
      }
    return i;
  }
  function DP(e, t, n, r, o, i, a, s, c, u, d) {
    for (var p = o - 1, m = o === 0 ? i : [""], g = gk(m), y = 0, b = 0, v = 0; y < r; ++y)
      for (var x = 0, E = Wp(e, p + 1, p = mY(b = a[y])), _ = e; x < g; ++x)
        (_ = J4(b > 0 ? m[x] + " " + E : Ut(E, /&\f/g, m[x]))) && (c[v++] = _);
    return cb(e, t, n, o === 0 ? hk : s, c, u, d);
  }
  function TY(e, t, n) {
    return cb(e, t, n, Z4, sb(xY()), Wp(e, 2, -2), 0);
  }
  function FP(e, t, n, r) {
    return cb(e, t, n, mk, Wp(e, 0, r), Wp(e, r + 1, -1), r);
  }
  function Qu(e, t) {
    for (var n = "", r = gk(e), o = 0; o < r; o++)
      n += t(e[o], o, e, t) || "";
    return n;
  }
  function AY(e, t, n, r) {
    switch (e.type) {
      case hY:
        if (e.children.length) break;
      case pY:
      case mk:
        return e.return = e.return || e.value;
      case Z4:
        return "";
      case Q4:
        return e.return = e.value + "{" + Qu(e.children, r) + "}";
      case hk:
        e.value = e.props.join(",");
    }
    return Ci(n = Qu(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
  }
  function RY(e) {
    var t = gk(e);
    return function(n, r, o, i) {
      for (var a = "", s = 0; s < t; s++)
        a += e[s](n, r, o, i) || "";
      return a;
    };
  }
  function OY(e) {
    return function(t) {
      t.root || (t = t.return) && e(t);
    };
  }
  function rF(e) {
    var t = /* @__PURE__ */ Object.create(null);
    return function(n) {
      return t[n] === void 0 && (t[n] = e(n)), t[n];
    };
  }
  var MY = function(t, n, r) {
    for (var o = 0, i = 0; o = i, i = Li(), o === 38 && i === 12 && (n[r] = 1), !Gp(i); )
      lo();
    return Ih(t, Hr);
  }, NY = function(t, n) {
    var r = -1, o = 44;
    do
      switch (Gp(o)) {
        case 0:
          o === 38 && Li() === 12 && (n[r] = 1), t[r] += MY(Hr - 1, n, r);
          break;
        case 2:
          t[r] += Ev(o);
          break;
        case 4:
          if (o === 44) {
            t[++r] = Li() === 58 ? "&\f" : "", n[r] = t[r].length;
            break;
          }
        // fallthrough
        default:
          t[r] += sb(o);
      }
    while (o = lo());
    return t;
  }, PY = function(t, n) {
    return nF(NY(tF(t), n));
  }, LP = /* @__PURE__ */ new WeakMap(), IY = function(t) {
    if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
    // negative .length indicates that this rule has been already prefixed
    t.length < 1)) {
      for (var n = t.value, r = t.parent, o = t.column === r.column && t.line === r.line; r.type !== "rule"; )
        if (r = r.parent, !r) return;
      if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !LP.get(r)) && !o) {
        LP.set(t, !0);
        for (var i = [], a = PY(n, i), s = r.props, c = 0, u = 0; c < a.length; c++)
          for (var d = 0; d < s.length; d++, u++)
            t.props[u] = i[c] ? a[c].replace(/&\f/g, s[d]) : s[d] + " " + a[c];
      }
    }
  }, $Y = function(t) {
    if (t.type === "decl") {
      var n = t.value;
      // charcode for l
      n.charCodeAt(0) === 108 && // charcode for b
      n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
    }
  };
  function oF(e, t) {
    switch (yY(e, t)) {
      // color-adjust
      case 5103:
        return Bt + "print-" + e + e;
      // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
      case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
      // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
      case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
      // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
      case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
      // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
      case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return Bt + e + e;
      // appearance, user-select, transform, hyphens, text-size-adjust
      case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return Bt + e + Qv + e + mr + e + e;
      // flex, flex-direction
      case 6828:
      case 4268:
        return Bt + e + mr + e + e;
      // order
      case 6165:
        return Bt + e + mr + "flex-" + e + e;
      // align-items
      case 5187:
        return Bt + e + Ut(e, /(\w+).+(:[^]+)/, Bt + "box-$1$2" + mr + "flex-$1$2") + e;
      // align-self
      case 5443:
        return Bt + e + mr + "flex-item-" + Ut(e, /flex-|-self/, "") + e;
      // align-content
      case 4675:
        return Bt + e + mr + "flex-line-pack" + Ut(e, /align-content|flex-|-self/, "") + e;
      // flex-shrink
      case 5548:
        return Bt + e + mr + Ut(e, "shrink", "negative") + e;
      // flex-basis
      case 5292:
        return Bt + e + mr + Ut(e, "basis", "preferred-size") + e;
      // flex-grow
      case 6060:
        return Bt + "box-" + Ut(e, "-grow", "") + Bt + e + mr + Ut(e, "grow", "positive") + e;
      // transition
      case 4554:
        return Bt + Ut(e, /([^-])(transform)/g, "$1" + Bt + "$2") + e;
      // cursor
      case 6187:
        return Ut(Ut(Ut(e, /(zoom-|grab)/, Bt + "$1"), /(image-set)/, Bt + "$1"), e, "") + e;
      // background, background-image
      case 5495:
      case 3959:
        return Ut(e, /(image-set\([^]*)/, Bt + "$1$`$1");
      // justify-content
      case 4968:
        return Ut(Ut(e, /(.+:)(flex-)?(.*)/, Bt + "box-pack:$3" + mr + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + Bt + e + e;
      // (margin|padding)-inline-(start|end)
      case 4095:
      case 3583:
      case 4068:
      case 2532:
        return Ut(e, /(.+)-inline(.+)/, Bt + "$1$2") + e;
      // (min|max)?(width|height|inline-size|block-size)
      case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (Ci(e) - 1 - t > 6) switch (cr(e, t + 1)) {
          // (m)ax-content, (m)in-content
          case 109:
            if (cr(e, t + 4) !== 45) break;
          // (f)ill-available, (f)it-content
          case 102:
            return Ut(e, /(.+:)(.+)-([^]+)/, "$1" + Bt + "$2-$3$1" + Qv + (cr(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
          // (s)tretch
          case 115:
            return ~mE(e, "stretch") ? oF(Ut(e, "stretch", "fill-available"), t) + e : e;
        }
        break;
      // position: sticky
      case 4949:
        if (cr(e, t + 1) !== 115) break;
      // display: (flex|inline-flex)
      case 6444:
        switch (cr(e, Ci(e) - 3 - (~mE(e, "!important") && 10))) {
          // stic(k)y
          case 107:
            return Ut(e, ":", ":" + Bt) + e;
          // (inline-)?fl(e)x
          case 101:
            return Ut(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + Bt + (cr(e, 14) === 45 ? "inline-" : "") + "box$3$1" + Bt + "$2$3$1" + mr + "$2box$3") + e;
        }
        break;
      // writing-mode
      case 5936:
        switch (cr(e, t + 11)) {
          // vertical-l(r)
          case 114:
            return Bt + e + mr + Ut(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
          // vertical-r(l)
          case 108:
            return Bt + e + mr + Ut(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
          // horizontal(-)tb
          case 45:
            return Bt + e + mr + Ut(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
        }
        return Bt + e + mr + e + e;
    }
    return e;
  }
  var jY = function(t, n, r, o) {
    if (t.length > -1 && !t.return) switch (t.type) {
      case mk:
        t.return = oF(t.value, t.length);
        break;
      case Q4:
        return Qu([qd(t, {
          value: Ut(t.value, "@", "@" + Bt)
        })], o);
      case hk:
        if (t.length) return bY(t.props, function(i) {
          switch (vY(i, /(::plac\w+|:read-\w+)/)) {
            // :read-(only|write)
            case ":read-only":
            case ":read-write":
              return Qu([qd(t, {
                props: [Ut(i, /:(read-\w+)/, ":" + Qv + "$1")]
              })], o);
            // :placeholder
            case "::placeholder":
              return Qu([qd(t, {
                props: [Ut(i, /:(plac\w+)/, ":" + Bt + "input-$1")]
              }), qd(t, {
                props: [Ut(i, /:(plac\w+)/, ":" + Qv + "$1")]
              }), qd(t, {
                props: [Ut(i, /:(plac\w+)/, mr + "input-$1")]
              })], o);
          }
          return "";
        });
    }
  }, DY = [jY], FY = function(t) {
    var n = t.key;
    if (n === "css") {
      var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(r, function(b) {
        var v = b.getAttribute("data-emotion");
        v.indexOf(" ") !== -1 && (document.head.appendChild(b), b.setAttribute("data-s", ""));
      });
    }
    var o = t.stylisPlugins || DY, i = {}, a, s = [];
    a = t.container || document.head, Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
      function(b) {
        for (var v = b.getAttribute("data-emotion").split(" "), x = 1; x < v.length; x++)
          i[v[x]] = !0;
        s.push(b);
      }
    );
    var c, u = [IY, $Y];
    {
      var d, p = [AY, OY(function(b) {
        d.insert(b);
      })], m = RY(u.concat(o, p)), g = function(v) {
        return Qu(kY(v), m);
      };
      c = function(v, x, E, _) {
        d = E, g(v ? v + "{" + x.styles + "}" : x.styles), _ && (y.inserted[x.name] = !0);
      };
    }
    var y = {
      key: n,
      sheet: new dY({
        key: n,
        container: a,
        nonce: t.nonce,
        speedy: t.speedy,
        prepend: t.prepend,
        insertionPoint: t.insertionPoint
      }),
      nonce: t.nonce,
      inserted: i,
      registered: {},
      insert: c
    };
    return y.sheet.hydrate(s), y;
  }, fS = { exports: {} }, Ht = {};
  var zP;
  function LY() {
    if (zP) return Ht;
    zP = 1;
    var e = typeof Symbol == "function" && Symbol.for, t = e ? /* @__PURE__ */ Symbol.for("react.element") : 60103, n = e ? /* @__PURE__ */ Symbol.for("react.portal") : 60106, r = e ? /* @__PURE__ */ Symbol.for("react.fragment") : 60107, o = e ? /* @__PURE__ */ Symbol.for("react.strict_mode") : 60108, i = e ? /* @__PURE__ */ Symbol.for("react.profiler") : 60114, a = e ? /* @__PURE__ */ Symbol.for("react.provider") : 60109, s = e ? /* @__PURE__ */ Symbol.for("react.context") : 60110, c = e ? /* @__PURE__ */ Symbol.for("react.async_mode") : 60111, u = e ? /* @__PURE__ */ Symbol.for("react.concurrent_mode") : 60111, d = e ? /* @__PURE__ */ Symbol.for("react.forward_ref") : 60112, p = e ? /* @__PURE__ */ Symbol.for("react.suspense") : 60113, m = e ? /* @__PURE__ */ Symbol.for("react.suspense_list") : 60120, g = e ? /* @__PURE__ */ Symbol.for("react.memo") : 60115, y = e ? /* @__PURE__ */ Symbol.for("react.lazy") : 60116, b = e ? /* @__PURE__ */ Symbol.for("react.block") : 60121, v = e ? /* @__PURE__ */ Symbol.for("react.fundamental") : 60117, x = e ? /* @__PURE__ */ Symbol.for("react.responder") : 60118, E = e ? /* @__PURE__ */ Symbol.for("react.scope") : 60119;
    function _(k) {
      if (typeof k == "object" && k !== null) {
        var A = k.$$typeof;
        switch (A) {
          case t:
            switch (k = k.type, k) {
              case c:
              case u:
              case r:
              case i:
              case o:
              case p:
                return k;
              default:
                switch (k = k && k.$$typeof, k) {
                  case s:
                  case d:
                  case y:
                  case g:
                  case a:
                    return k;
                  default:
                    return A;
                }
            }
          case n:
            return A;
        }
      }
    }
    function C(k) {
      return _(k) === u;
    }
    return Ht.AsyncMode = c, Ht.ConcurrentMode = u, Ht.ContextConsumer = s, Ht.ContextProvider = a, Ht.Element = t, Ht.ForwardRef = d, Ht.Fragment = r, Ht.Lazy = y, Ht.Memo = g, Ht.Portal = n, Ht.Profiler = i, Ht.StrictMode = o, Ht.Suspense = p, Ht.isAsyncMode = function(k) {
      return C(k) || _(k) === c;
    }, Ht.isConcurrentMode = C, Ht.isContextConsumer = function(k) {
      return _(k) === s;
    }, Ht.isContextProvider = function(k) {
      return _(k) === a;
    }, Ht.isElement = function(k) {
      return typeof k == "object" && k !== null && k.$$typeof === t;
    }, Ht.isForwardRef = function(k) {
      return _(k) === d;
    }, Ht.isFragment = function(k) {
      return _(k) === r;
    }, Ht.isLazy = function(k) {
      return _(k) === y;
    }, Ht.isMemo = function(k) {
      return _(k) === g;
    }, Ht.isPortal = function(k) {
      return _(k) === n;
    }, Ht.isProfiler = function(k) {
      return _(k) === i;
    }, Ht.isStrictMode = function(k) {
      return _(k) === o;
    }, Ht.isSuspense = function(k) {
      return _(k) === p;
    }, Ht.isValidElementType = function(k) {
      return typeof k == "string" || typeof k == "function" || k === r || k === u || k === i || k === o || k === p || k === m || typeof k == "object" && k !== null && (k.$$typeof === y || k.$$typeof === g || k.$$typeof === a || k.$$typeof === s || k.$$typeof === d || k.$$typeof === v || k.$$typeof === x || k.$$typeof === E || k.$$typeof === b);
    }, Ht.typeOf = _, Ht;
  }
  var BP;
  function zY() {
    return BP || (BP = 1, fS.exports = LY()), fS.exports;
  }
  var dS, UP;
  function BY() {
    if (UP) return dS;
    UP = 1;
    var e = zY(), t = {
      childContextTypes: !0,
      contextType: !0,
      contextTypes: !0,
      defaultProps: !0,
      displayName: !0,
      getDefaultProps: !0,
      getDerivedStateFromError: !0,
      getDerivedStateFromProps: !0,
      mixins: !0,
      propTypes: !0,
      type: !0
    }, n = {
      name: !0,
      length: !0,
      prototype: !0,
      caller: !0,
      callee: !0,
      arguments: !0,
      arity: !0
    }, r = {
      $$typeof: !0,
      render: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0
    }, o = {
      $$typeof: !0,
      compare: !0,
      defaultProps: !0,
      displayName: !0,
      propTypes: !0,
      type: !0
    }, i = {};
    i[e.ForwardRef] = r, i[e.Memo] = o;
    function a(y) {
      return e.isMemo(y) ? o : i[y.$$typeof] || t;
    }
    var s = Object.defineProperty, c = Object.getOwnPropertyNames, u = Object.getOwnPropertySymbols, d = Object.getOwnPropertyDescriptor, p = Object.getPrototypeOf, m = Object.prototype;
    function g(y, b, v) {
      if (typeof b != "string") {
        if (m) {
          var x = p(b);
          x && x !== m && g(y, x, v);
        }
        var E = c(b);
        u && (E = E.concat(u(b)));
        for (var _ = a(y), C = a(b), k = 0; k < E.length; ++k) {
          var A = E[k];
          if (!n[A] && !(v && v[A]) && !(C && C[A]) && !(_ && _[A])) {
            var O = d(b, A);
            try {
              s(y, A, O);
            } catch {
            }
          }
        }
      }
      return y;
    }
    return dS = g, dS;
  }
  BY();
  var UY = !0;
  function iF(e, t, n) {
    var r = "";
    return n.split(" ").forEach(function(o) {
      e[o] !== void 0 ? t.push(e[o] + ";") : o && (r += o + " ");
    }), r;
  }
  var yk = function(t, n, r) {
    var o = t.key + "-" + n.name;
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (r === !1 || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    UY === !1) && t.registered[o] === void 0 && (t.registered[o] = n.styles);
  }, vk = function(t, n, r) {
    yk(t, n, r);
    var o = t.key + "-" + n.name;
    if (t.inserted[n.name] === void 0) {
      var i = n;
      do
        t.insert(n === i ? "." + o : "", i, t.sheet, !0), i = i.next;
      while (i !== void 0);
    }
  };
  function VY(e) {
    for (var t = 0, n, r = 0, o = e.length; o >= 4; ++r, o -= 4)
      n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
      (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
      n >>> 24, t = /* Math.imul(k, m): */
      (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
    switch (o) {
      case 3:
        t ^= (e.charCodeAt(r + 2) & 255) << 16;
      case 2:
        t ^= (e.charCodeAt(r + 1) & 255) << 8;
      case 1:
        t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
        (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
    }
    return t ^= t >>> 13, t = /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
  }
  var HY = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  }, qY = /[A-Z]|^ms/g, WY = /_EMO_([^_]+?)_([^]*?)_EMO_/g, aF = function(t) {
    return t.charCodeAt(1) === 45;
  }, VP = function(t) {
    return t != null && typeof t != "boolean";
  }, pS = /* @__PURE__ */ rF(function(e) {
    return aF(e) ? e : e.replace(qY, "-$&").toLowerCase();
  }), HP = function(t, n) {
    switch (t) {
      case "animation":
      case "animationName":
        if (typeof n == "string")
          return n.replace(WY, function(r, o, i) {
            return ki = {
              name: o,
              styles: i,
              next: ki
            }, o;
          });
    }
    return HY[t] !== 1 && !aF(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
  };
  function Kp(e, t, n) {
    if (n == null)
      return "";
    var r = n;
    if (r.__emotion_styles !== void 0)
      return r;
    switch (typeof n) {
      case "boolean":
        return "";
      case "object": {
        var o = n;
        if (o.anim === 1)
          return ki = {
            name: o.name,
            styles: o.styles,
            next: ki
          }, o.name;
        var i = n;
        if (i.styles !== void 0) {
          var a = i.next;
          if (a !== void 0)
            for (; a !== void 0; )
              ki = {
                name: a.name,
                styles: a.styles,
                next: ki
              }, a = a.next;
          var s = i.styles + ";";
          return s;
        }
        return GY(e, t, n);
      }
      case "function": {
        if (e !== void 0) {
          var c = ki, u = n(e);
          return ki = c, Kp(e, t, u);
        }
        break;
      }
    }
    var d = n;
    if (t == null)
      return d;
    var p = t[d];
    return p !== void 0 ? p : d;
  }
  function GY(e, t, n) {
    var r = "";
    if (Array.isArray(n))
      for (var o = 0; o < n.length; o++)
        r += Kp(e, t, n[o]) + ";";
    else
      for (var i in n) {
        var a = n[i];
        if (typeof a != "object") {
          var s = a;
          t != null && t[s] !== void 0 ? r += i + "{" + t[s] + "}" : VP(s) && (r += pS(i) + ":" + HP(i, s) + ";");
        } else if (Array.isArray(a) && typeof a[0] == "string" && (t == null || t[a[0]] === void 0))
          for (var c = 0; c < a.length; c++)
            VP(a[c]) && (r += pS(i) + ":" + HP(i, a[c]) + ";");
        else {
          var u = Kp(e, t, a);
          switch (i) {
            case "animation":
            case "animationName": {
              r += pS(i) + ":" + u + ";";
              break;
            }
            default:
              r += i + "{" + u + "}";
          }
        }
      }
    return r;
  }
  var qP = /label:\s*([^\s;{]+)\s*(;|$)/g, ki;
  function $h(e, t, n) {
    if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
      return e[0];
    var r = !0, o = "";
    ki = void 0;
    var i = e[0];
    if (i == null || i.raw === void 0)
      r = !1, o += Kp(n, t, i);
    else {
      var a = i;
      o += a[0];
    }
    for (var s = 1; s < e.length; s++)
      if (o += Kp(n, t, e[s]), r) {
        var c = i;
        o += c[s];
      }
    qP.lastIndex = 0;
    for (var u = "", d; (d = qP.exec(o)) !== null; )
      u += "-" + d[1];
    var p = VY(o) + u;
    return {
      name: p,
      styles: o,
      next: ki
    };
  }
  var KY = function(t) {
    return t();
  }, sF = sc.useInsertionEffect ? sc.useInsertionEffect : !1, lF = sF || KY, WP = sF || T.useLayoutEffect, cF = /* @__PURE__ */ T.createContext(
    // we're doing this to avoid preconstruct's dead code elimination in this one case
    // because this module is primarily intended for the browser and node
    // but it's also required in react native and similar environments sometimes
    // and we could have a special build just for that
    // but this is much easier and the native packages
    // might use a different theme context in the future anyway
    typeof HTMLElement < "u" ? /* @__PURE__ */ FY({
      key: "css"
    }) : null
  );
  cF.Provider;
  var bk = function(t) {
    return /* @__PURE__ */ T.forwardRef(function(n, r) {
      var o = T.useContext(cF);
      return t(n, o, r);
    });
  }, jh = /* @__PURE__ */ T.createContext({}), xk = {}.hasOwnProperty, yE = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", YY = function(t, n) {
    var r = {};
    for (var o in n)
      xk.call(n, o) && (r[o] = n[o]);
    return r[yE] = t, r;
  }, XY = function(t) {
    var n = t.cache, r = t.serialized, o = t.isStringTag;
    return yk(n, r, o), lF(function() {
      return vk(n, r, o);
    }), null;
  }, ZY = /* @__PURE__ */ bk(function(e, t, n) {
    var r = e.css;
    typeof r == "string" && t.registered[r] !== void 0 && (r = t.registered[r]);
    var o = e[yE], i = [r], a = "";
    typeof e.className == "string" ? a = iF(t.registered, i, e.className) : e.className != null && (a = e.className + " ");
    var s = $h(i, void 0, T.useContext(jh));
    a += t.key + "-" + s.name;
    var c = {};
    for (var u in e)
      xk.call(e, u) && u !== "css" && u !== yE && (c[u] = e[u]);
    return c.className = a, n && (c.ref = n), /* @__PURE__ */ T.createElement(T.Fragment, null, /* @__PURE__ */ T.createElement(XY, {
      cache: t,
      serialized: s,
      isStringTag: typeof o == "string"
    }), /* @__PURE__ */ T.createElement(o, c));
  }), QY = ZY, We = function(t, n) {
    var r = arguments;
    if (n == null || !xk.call(n, "css"))
      return T.createElement.apply(void 0, r);
    var o = r.length, i = new Array(o);
    i[0] = QY, i[1] = YY(t, n);
    for (var a = 2; a < o; a++)
      i[a] = r[a];
    return T.createElement.apply(null, i);
  };
  (function(e) {
    var t;
    t || (t = e.JSX || (e.JSX = {}));
  })(We || (We = {}));
  var JY = /* @__PURE__ */ bk(function(e, t) {
    var n = e.styles, r = $h([n], void 0, T.useContext(jh)), o = T.useRef();
    return WP(function() {
      var i = t.key + "-global", a = new t.sheet.constructor({
        key: i,
        nonce: t.sheet.nonce,
        container: t.sheet.container,
        speedy: t.sheet.isSpeedy
      }), s = !1, c = document.querySelector('style[data-emotion="' + i + " " + r.name + '"]');
      return t.sheet.tags.length && (a.before = t.sheet.tags[0]), c !== null && (s = !0, c.setAttribute("data-emotion", i), a.hydrate([c])), o.current = [a, s], function() {
        a.flush();
      };
    }, [t]), WP(function() {
      var i = o.current, a = i[0], s = i[1];
      if (s) {
        i[1] = !1;
        return;
      }
      if (r.next !== void 0 && vk(t, r.next, !0), a.tags.length) {
        var c = a.tags[a.tags.length - 1].nextElementSibling;
        a.before = c, a.flush();
      }
      t.insert("", r, a, !1);
    }, [t, r.name]), null;
  });
  function Dh() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return $h(t);
  }
  function If() {
    var e = Dh.apply(void 0, arguments), t = "animation-" + e.name;
    return {
      name: t,
      styles: "@keyframes " + t + "{" + e.styles + "}",
      anim: 1,
      toString: function() {
        return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
      }
    };
  }
  var eX = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, tX = /* @__PURE__ */ rF(
    function(e) {
      return eX.test(e) || e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) < 91;
    }
    /* Z+1 */
  ), nX = tX, rX = function(t) {
    return t !== "theme";
  }, GP = function(t) {
    return typeof t == "string" && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    t.charCodeAt(0) > 96 ? nX : rX;
  }, KP = function(t, n, r) {
    var o;
    if (n) {
      var i = n.shouldForwardProp;
      o = t.__emotion_forwardProp && i ? function(a) {
        return t.__emotion_forwardProp(a) && i(a);
      } : i;
    }
    return typeof o != "function" && r && (o = t.__emotion_forwardProp), o;
  }, oX = function(t) {
    var n = t.cache, r = t.serialized, o = t.isStringTag;
    return yk(n, r, o), lF(function() {
      return vk(n, r, o);
    }), null;
  }, iX = function e(t, n) {
    var r = t.__emotion_real === t, o = r && t.__emotion_base || t, i, a;
    n !== void 0 && (i = n.label, a = n.target);
    var s = KP(t, n, r), c = s || GP(o), u = !c("as");
    return function() {
      var d = arguments, p = r && t.__emotion_styles !== void 0 ? t.__emotion_styles.slice(0) : [];
      if (i !== void 0 && p.push("label:" + i + ";"), d[0] == null || d[0].raw === void 0)
        p.push.apply(p, d);
      else {
        var m = d[0];
        p.push(m[0]);
        for (var g = d.length, y = 1; y < g; y++)
          p.push(d[y], m[y]);
      }
      var b = bk(function(v, x, E) {
        var _ = u && v.as || o, C = "", k = [], A = v;
        if (v.theme == null) {
          A = {};
          for (var O in v)
            A[O] = v[O];
          A.theme = T.useContext(jh);
        }
        typeof v.className == "string" ? C = iF(x.registered, k, v.className) : v.className != null && (C = v.className + " ");
        var P = $h(p.concat(k), x.registered, A);
        C += x.key + "-" + P.name, a !== void 0 && (C += " " + a);
        var I = u && s === void 0 ? GP(_) : c, $ = {};
        for (var L in v)
          u && L === "as" || I(L) && ($[L] = v[L]);
        return $.className = C, E && ($.ref = E), /* @__PURE__ */ T.createElement(T.Fragment, null, /* @__PURE__ */ T.createElement(oX, {
          cache: x,
          serialized: P,
          isStringTag: typeof _ == "string"
        }), /* @__PURE__ */ T.createElement(_, $));
      });
      return b.displayName = i !== void 0 ? i : "Styled(" + (typeof o == "string" ? o : o.displayName || o.name || "Component") + ")", b.defaultProps = t.defaultProps, b.__emotion_real = b, b.__emotion_base = o, b.__emotion_styles = p, b.__emotion_forwardProp = s, Object.defineProperty(b, "toString", {
        value: function() {
          return "." + a;
        }
      }), b.withComponent = function(v, x) {
        var E = e(v, Ke({}, n, x, {
          shouldForwardProp: KP(b, x, !0)
        }));
        return E.apply(void 0, p);
      }, b;
    };
  }, aX = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    // SVG
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan"
  ], vE = iX.bind(null);
  aX.forEach(function(e) {
    vE[e] = vE(e);
  });
  function sX(e) {
    return e == null || Object.keys(e).length === 0;
  }
  function uF(e) {
    const {
      styles: t,
      defaultTheme: n = {}
    } = e, r = typeof t == "function" ? (o) => t(sX(o) ? n : o) : t;
    return /* @__PURE__ */ S.jsx(JY, {
      styles: r
    });
  }
  function fF(e, t) {
    return vE(e, t);
  }
  function lX(e, t) {
    Array.isArray(e.__emotion_styles) && (e.__emotion_styles = t(e.__emotion_styles));
  }
  const YP = [];
  function Xs(e) {
    return YP[0] = e, $h(YP);
  }
  const cX = (e) => {
    const t = Object.keys(e).map((n) => ({
      key: n,
      val: e[n]
    })) || [];
    return t.sort((n, r) => n.val - r.val), t.reduce((n, r) => ({
      ...n,
      [r.key]: r.val
    }), {});
  };
  function uX(e) {
    const {
      // The breakpoint **start** at this value.
      // For instance with the first breakpoint xs: [xs, sm).
      values: t = {
        xs: 0,
        // phone
        sm: 600,
        // tablet
        md: 900,
        // small laptop
        lg: 1200,
        // desktop
        xl: 1536
        // large screen
      },
      unit: n = "px",
      step: r = 5,
      ...o
    } = e, i = cX(t), a = Object.keys(i);
    function s(m) {
      return `@media (min-width:${typeof t[m] == "number" ? t[m] : m}${n})`;
    }
    function c(m) {
      return `@media (max-width:${(typeof t[m] == "number" ? t[m] : m) - r / 100}${n})`;
    }
    function u(m, g) {
      const y = a.indexOf(g);
      return `@media (min-width:${typeof t[m] == "number" ? t[m] : m}${n}) and (max-width:${(y !== -1 && typeof t[a[y]] == "number" ? t[a[y]] : g) - r / 100}${n})`;
    }
    function d(m) {
      return a.indexOf(m) + 1 < a.length ? u(m, a[a.indexOf(m) + 1]) : s(m);
    }
    function p(m) {
      const g = a.indexOf(m);
      return g === 0 ? s(a[1]) : g === a.length - 1 ? c(a[g]) : u(m, a[a.indexOf(m) + 1]).replace("@media", "@media not all and");
    }
    return {
      keys: a,
      values: i,
      up: s,
      down: c,
      between: u,
      only: d,
      not: p,
      unit: n,
      ...o
    };
  }
  const fX = {
    borderRadius: 4
  };
  function dF(e = 8, t = fk({
    spacing: e
  })) {
    if (e.mui)
      return e;
    const n = (...r) => (r.length === 0 ? [1] : r).map((i) => {
      const a = t(i);
      return typeof a == "number" ? `${a}px` : a;
    }).join(" ");
    return n.mui = !0, n;
  }
  function dX(e, t) {
    const n = this;
    if (n.vars) {
      if (!n.colorSchemes?.[e] || typeof n.getColorSchemeSelector != "function")
        return {};
      let r = n.getColorSchemeSelector(e);
      return r === "&" ? t : ((r.includes("data-") || r.includes(".")) && (r = `*:where(${r.replace(/\s*&$/, "")}) &`), {
        [r]: t
      });
    }
    return n.palette.mode === e ? t : {};
  }
  function ub(e = {}, ...t) {
    const {
      breakpoints: n = {},
      palette: r = {},
      spacing: o,
      shape: i = {},
      ...a
    } = e, s = uX(n), c = dF(o);
    let u = xr({
      breakpoints: s,
      direction: "ltr",
      components: {},
      // Inject component definitions.
      palette: {
        mode: "light",
        ...r
      },
      spacing: c,
      shape: {
        ...fX,
        ...i
      }
    }, a);
    return u = wK(u), u.applyStyles = dX, u = t.reduce((d, p) => xr(d, p), u), u.unstable_sxConfig = {
      ...Ph,
      ...a?.unstable_sxConfig
    }, u.unstable_sx = function(p) {
      return nl({
        sx: p,
        theme: this
      });
    }, u;
  }
  function pX(e) {
    return Object.keys(e).length === 0;
  }
  function wk(e = null) {
    const t = T.useContext(jh);
    return !t || pX(t) ? e : t;
  }
  const hX = ub();
  function Fh(e = hX) {
    return wk(e);
  }
  function hS(e) {
    const t = Xs(e);
    return e !== t && t.styles ? (t.styles.match(/^@layer\s+[^{]*$/) || (t.styles = `@layer global{${t.styles}}`), t) : e;
  }
  function pF({
    styles: e,
    themeId: t,
    defaultTheme: n = {}
  }) {
    const r = Fh(n), o = t && r[t] || r;
    let i = typeof e == "function" ? e(o) : e;
    return o.modularCssLayers && (Array.isArray(i) ? i = i.map((a) => hS(typeof a == "function" ? a(o) : a)) : i = hS(i)), /* @__PURE__ */ S.jsx(uF, {
      styles: i
    });
  }
  const XP = (e) => e, mX = () => {
    let e = XP;
    return {
      configure(t) {
        e = t;
      },
      generate(t) {
        return e(t);
      },
      reset() {
        e = XP;
      }
    };
  }, hF = mX();
  function gX(e = {}) {
    const {
      themeId: t,
      defaultTheme: n,
      defaultClassName: r = "MuiBox-root",
      generateClassName: o
    } = e, i = fF("div", {
      shouldForwardProp: (s) => s !== "theme" && s !== "sx" && s !== "as"
    })(nl);
    return /* @__PURE__ */ T.forwardRef(function(c, u) {
      const d = Fh(n), {
        className: p,
        component: m = "div",
        ...g
      } = pk(c);
      return /* @__PURE__ */ S.jsx(i, {
        as: m,
        ref: u,
        className: $e(p, o ? o(r) : r),
        theme: t && d[t] || d,
        ...g
      });
    });
  }
  const yX = {
    active: "active",
    checked: "checked",
    completed: "completed",
    disabled: "disabled",
    error: "error",
    expanded: "expanded",
    focused: "focused",
    focusVisible: "focusVisible",
    open: "open",
    readOnly: "readOnly",
    required: "required",
    selected: "selected"
  };
  function ot(e, t, n = "Mui") {
    const r = yX[t];
    return r ? `${n}-${r}` : `${hF.generate(e)}-${t}`;
  }
  function nt(e, t, n = "Mui") {
    const r = {};
    return t.forEach((o) => {
      r[o] = ot(e, o, n);
    }), r;
  }
  function mF(e) {
    const {
      variants: t,
      ...n
    } = e, r = {
      variants: t,
      style: Xs(n),
      isProcessed: !0
    };
    return r.style === n || t && t.forEach((o) => {
      typeof o.style != "function" && (o.style = Xs(o.style));
    }), r;
  }
  const vX = ub();
  function mS(e) {
    return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
  }
  function Jl(e, t) {
    return t && e && typeof e == "object" && e.styles && !e.styles.startsWith("@layer") && (e.styles = `@layer ${t}{${String(e.styles)}}`), e;
  }
  function bX(e) {
    return e ? (t, n) => n[e] : null;
  }
  function xX(e, t, n) {
    e.theme = SX(e.theme) ? n : e.theme[t] || e.theme;
  }
  function kv(e, t, n) {
    const r = typeof t == "function" ? t(e) : t;
    if (Array.isArray(r))
      return r.flatMap((o) => kv(e, o, n));
    if (Array.isArray(r?.variants)) {
      let o;
      if (r.isProcessed)
        o = n ? Jl(r.style, n) : r.style;
      else {
        const {
          variants: i,
          ...a
        } = r;
        o = n ? Jl(Xs(a), n) : a;
      }
      return gF(e, r.variants, [o], n);
    }
    return r?.isProcessed ? n ? Jl(Xs(r.style), n) : r.style : n ? Jl(Xs(r), n) : r;
  }
  function gF(e, t, n = [], r = void 0) {
    let o;
    e: for (let i = 0; i < t.length; i += 1) {
      const a = t[i];
      if (typeof a.props == "function") {
        if (o ?? (o = {
          ...e,
          ...e.ownerState,
          ownerState: e.ownerState
        }), !a.props(o))
          continue;
      } else
        for (const s in a.props)
          if (e[s] !== a.props[s] && e.ownerState?.[s] !== a.props[s])
            continue e;
      typeof a.style == "function" ? (o ?? (o = {
        ...e,
        ...e.ownerState,
        ownerState: e.ownerState
      }), n.push(r ? Jl(Xs(a.style(o)), r) : a.style(o))) : n.push(r ? Jl(Xs(a.style), r) : a.style);
    }
    return n;
  }
  function yF(e = {}) {
    const {
      themeId: t,
      defaultTheme: n = vX,
      rootShouldForwardProp: r = mS,
      slotShouldForwardProp: o = mS
    } = e;
    function i(s) {
      xX(s, t, n);
    }
    return (s, c = {}) => {
      lX(s, (A) => A.filter((O) => O !== nl));
      const {
        name: u,
        slot: d,
        skipVariantsResolver: p,
        skipSx: m,
        // TODO v6: remove `lowercaseFirstLetter()` in the next major release
        // For more details: https://github.com/mui/material-ui/pull/37908
        overridesResolver: g = bX(EX(d)),
        ...y
      } = c, b = u && u.startsWith("Mui") || d ? "components" : "custom", v = p !== void 0 ? p : (
        // TODO v6: remove `Root` in the next major release
        // For more details: https://github.com/mui/material-ui/pull/37908
        d && d !== "Root" && d !== "root" || !1
      ), x = m || !1;
      let E = mS;
      d === "Root" || d === "root" ? E = r : d ? E = o : _X(s) && (E = void 0);
      const _ = fF(s, {
        shouldForwardProp: E,
        label: wX(),
        ...y
      }), C = (A) => {
        if (A.__emotion_real === A)
          return A;
        if (typeof A == "function")
          return function(P) {
            return kv(P, A, P.theme.modularCssLayers ? b : void 0);
          };
        if (Ri(A)) {
          const O = mF(A);
          return function(I) {
            return O.variants ? kv(I, O, I.theme.modularCssLayers ? b : void 0) : I.theme.modularCssLayers ? Jl(O.style, b) : O.style;
          };
        }
        return A;
      }, k = (...A) => {
        const O = [], P = A.map(C), I = [];
        if (O.push(i), u && g && I.push(function(U) {
          const V = U.theme.components?.[u]?.styleOverrides;
          if (!V)
            return null;
          const F = {};
          for (const K in V)
            F[K] = kv(U, V[K], U.theme.modularCssLayers ? "theme" : void 0);
          return g(U, F);
        }), u && !v && I.push(function(U) {
          const V = U.theme?.components?.[u]?.variants;
          return V ? gF(U, V, [], U.theme.modularCssLayers ? "theme" : void 0) : null;
        }), x || I.push(nl), Array.isArray(P[0])) {
          const N = P.shift(), U = new Array(O.length).fill(""), j = new Array(I.length).fill("");
          let V;
          V = [...U, ...N, ...j], V.raw = [...U, ...N.raw, ...j], O.unshift(V);
        }
        const $ = [...O, ...P, ...I], L = _(...$);
        return s.muiName && (L.muiName = s.muiName), L;
      };
      return _.withConfig && (k.withConfig = _.withConfig), k;
    };
  }
  function wX(e, t) {
    return void 0;
  }
  function SX(e) {
    for (const t in e)
      return !1;
    return !0;
  }
  function _X(e) {
    return typeof e == "string" && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    e.charCodeAt(0) > 96;
  }
  function EX(e) {
    return e && e.charAt(0).toLowerCase() + e.slice(1);
  }
  const CX = yF();
  function Yp(e, t, n = !1) {
    const r = {
      ...t
    };
    for (const o in e)
      if (Object.prototype.hasOwnProperty.call(e, o)) {
        const i = o;
        if (i === "components" || i === "slots")
          r[i] = {
            ...e[i],
            ...r[i]
          };
        else if (i === "componentsProps" || i === "slotProps") {
          const a = e[i], s = t[i];
          if (!s)
            r[i] = a || {};
          else if (!a)
            r[i] = s;
          else {
            r[i] = {
              ...s
            };
            for (const c in a)
              if (Object.prototype.hasOwnProperty.call(a, c)) {
                const u = c;
                r[i][u] = Yp(a[u], s[u], n);
              }
          }
        } else i === "className" && n && t.className ? r.className = $e(e?.className, t?.className) : i === "style" && n && t.style ? r.style = {
          ...e?.style,
          ...t?.style
        } : r[i] === void 0 && (r[i] = e[i]);
      }
    return r;
  }
  function kX(e) {
    const {
      theme: t,
      name: n,
      props: r
    } = e;
    return !t || !t.components || !t.components[n] || !t.components[n].defaultProps ? r : Yp(t.components[n].defaultProps, r);
  }
  function TX({
    props: e,
    name: t,
    defaultTheme: n,
    themeId: r
  }) {
    let o = Fh(n);
    return r && (o = o[r] || o), kX({
      theme: o,
      name: t,
      props: e
    });
  }
  const ei = typeof window < "u" ? T.useLayoutEffect : T.useEffect;
  function zu(e, t = Number.MIN_SAFE_INTEGER, n = Number.MAX_SAFE_INTEGER) {
    return Math.max(t, Math.min(e, n));
  }
  function Sk(e, t = 0, n = 1) {
    return zu(e, t, n);
  }
  function AX(e) {
    e = e.slice(1);
    const t = new RegExp(`.{1,${e.length >= 6 ? 2 : 1}}`, "g");
    let n = e.match(t);
    return n && n[0].length === 1 && (n = n.map((r) => r + r)), n ? `rgb${n.length === 4 ? "a" : ""}(${n.map((r, o) => o < 3 ? parseInt(r, 16) : Math.round(parseInt(r, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
  }
  function rl(e) {
    if (e.type)
      return e;
    if (e.charAt(0) === "#")
      return rl(AX(e));
    const t = e.indexOf("("), n = e.substring(0, t);
    if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(n))
      throw new Error(Va(9, e));
    let r = e.substring(t + 1, e.length - 1), o;
    if (n === "color") {
      if (r = r.split(" "), o = r.shift(), r.length === 4 && r[3].charAt(0) === "/" && (r[3] = r[3].slice(1)), !["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(o))
        throw new Error(Va(10, o));
    } else
      r = r.split(",");
    return r = r.map((i) => parseFloat(i)), {
      type: n,
      values: r,
      colorSpace: o
    };
  }
  const RX = (e) => {
    const t = rl(e);
    return t.values.slice(0, 3).map((n, r) => t.type.includes("hsl") && r !== 0 ? `${n}%` : n).join(" ");
  }, pp = (e, t) => {
    try {
      return RX(e);
    } catch {
      return e;
    }
  };
  function fb(e) {
    const {
      type: t,
      colorSpace: n
    } = e;
    let {
      values: r
    } = e;
    return t.includes("rgb") ? r = r.map((o, i) => i < 3 ? parseInt(o, 10) : o) : t.includes("hsl") && (r[1] = `${r[1]}%`, r[2] = `${r[2]}%`), t.includes("color") ? r = `${n} ${r.join(" ")}` : r = `${r.join(", ")}`, `${t}(${r})`;
  }
  function vF(e) {
    e = rl(e);
    const {
      values: t
    } = e, n = t[0], r = t[1] / 100, o = t[2] / 100, i = r * Math.min(o, 1 - o), a = (u, d = (u + n / 30) % 12) => o - i * Math.max(Math.min(d - 3, 9 - d, 1), -1);
    let s = "rgb";
    const c = [Math.round(a(0) * 255), Math.round(a(8) * 255), Math.round(a(4) * 255)];
    return e.type === "hsla" && (s += "a", c.push(t[3])), fb({
      type: s,
      values: c
    });
  }
  function bE(e) {
    e = rl(e);
    let t = e.type === "hsl" || e.type === "hsla" ? rl(vF(e)).values : e.values;
    return t = t.map((n) => (e.type !== "color" && (n /= 255), n <= 0.03928 ? n / 12.92 : ((n + 0.055) / 1.055) ** 2.4)), Number((0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2]).toFixed(3));
  }
  function OX(e, t) {
    const n = bE(e), r = bE(t);
    return (Math.max(n, r) + 0.05) / (Math.min(n, r) + 0.05);
  }
  function Jv(e, t) {
    return e = rl(e), t = Sk(t), (e.type === "rgb" || e.type === "hsl") && (e.type += "a"), e.type === "color" ? e.values[3] = `/${t}` : e.values[3] = t, fb(e);
  }
  function Ll(e, t, n) {
    try {
      return Jv(e, t);
    } catch {
      return e;
    }
  }
  function db(e, t) {
    if (e = rl(e), t = Sk(t), e.type.includes("hsl"))
      e.values[2] *= 1 - t;
    else if (e.type.includes("rgb") || e.type.includes("color"))
      for (let n = 0; n < 3; n += 1)
        e.values[n] *= 1 - t;
    return fb(e);
  }
  function Yt(e, t, n) {
    try {
      return db(e, t);
    } catch {
      return e;
    }
  }
  function pb(e, t) {
    if (e = rl(e), t = Sk(t), e.type.includes("hsl"))
      e.values[2] += (100 - e.values[2]) * t;
    else if (e.type.includes("rgb"))
      for (let n = 0; n < 3; n += 1)
        e.values[n] += (255 - e.values[n]) * t;
    else if (e.type.includes("color"))
      for (let n = 0; n < 3; n += 1)
        e.values[n] += (1 - e.values[n]) * t;
    return fb(e);
  }
  function Xt(e, t, n) {
    try {
      return pb(e, t);
    } catch {
      return e;
    }
  }
  function MX(e, t = 0.15) {
    return bE(e) > 0.5 ? db(e, t) : pb(e, t);
  }
  function Kg(e, t, n) {
    try {
      return MX(e, t);
    } catch {
      return e;
    }
  }
  const bF = /* @__PURE__ */ T.createContext(null);
  function _k() {
    return T.useContext(bF);
  }
  const NX = typeof Symbol == "function" && Symbol.for, PX = NX ? /* @__PURE__ */ Symbol.for("mui.nested") : "__THEME_NESTED__";
  function IX(e, t) {
    return typeof t == "function" ? t(e) : {
      ...e,
      ...t
    };
  }
  function $X(e) {
    const {
      children: t,
      theme: n
    } = e, r = _k(), o = T.useMemo(() => {
      const i = r === null ? {
        ...n
      } : IX(r, n);
      return i != null && (i[PX] = r !== null), i;
    }, [n, r]);
    return /* @__PURE__ */ S.jsx(bF.Provider, {
      value: o,
      children: t
    });
  }
  const xF = /* @__PURE__ */ T.createContext();
  function jX({
    value: e,
    ...t
  }) {
    return /* @__PURE__ */ S.jsx(xF.Provider, {
      value: e ?? !0,
      ...t
    });
  }
  const wF = () => T.useContext(xF) ?? !1, SF = /* @__PURE__ */ T.createContext(void 0);
  function DX({
    value: e,
    children: t
  }) {
    return /* @__PURE__ */ S.jsx(SF.Provider, {
      value: e,
      children: t
    });
  }
  function FX(e) {
    const {
      theme: t,
      name: n,
      props: r
    } = e;
    if (!t || !t.components || !t.components[n])
      return r;
    const o = t.components[n];
    return o.defaultProps ? Yp(o.defaultProps, r, t.components.mergeClassNameAndStyle) : !o.styleOverrides && !o.variants ? Yp(o, r, t.components.mergeClassNameAndStyle) : r;
  }
  function LX({
    props: e,
    name: t
  }) {
    const n = T.useContext(SF);
    return FX({
      props: e,
      name: t,
      theme: {
        components: n
      }
    });
  }
  let ZP = 0;
  function zX(e) {
    const [t, n] = T.useState(e), r = e || t;
    return T.useEffect(() => {
      t == null && (ZP += 1, n(`mui-${ZP}`));
    }, [t]), r;
  }
  const BX = {
    ...sc
  }, QP = BX.useId;
  function $f(e) {
    if (QP !== void 0) {
      const t = QP();
      return e ?? t;
    }
    return zX(e);
  }
  function UX(e) {
    const t = wk(), n = $f() || "", {
      modularCssLayers: r
    } = e;
    let o = "mui.global, mui.components, mui.theme, mui.custom, mui.sx";
    return !r || t !== null ? o = "" : typeof r == "string" ? o = r.replace(/mui(?!\.)/g, o) : o = `@layer ${o};`, ei(() => {
      const i = document.querySelector("head");
      if (!i)
        return;
      const a = i.firstChild;
      if (o) {
        if (a && a.hasAttribute?.("data-mui-layer-order") && a.getAttribute("data-mui-layer-order") === n)
          return;
        const s = document.createElement("style");
        s.setAttribute("data-mui-layer-order", n), s.textContent = o, i.prepend(s);
      } else
        i.querySelector(`style[data-mui-layer-order="${n}"]`)?.remove();
    }, [o, n]), o ? /* @__PURE__ */ S.jsx(pF, {
      styles: o
    }) : null;
  }
  const JP = {};
  function e2(e, t, n, r = !1) {
    return T.useMemo(() => {
      const o = e && t[e] || t;
      if (typeof n == "function") {
        const i = n(o), a = e ? {
          ...t,
          [e]: i
        } : i;
        return r ? () => a : a;
      }
      return e ? {
        ...t,
        [e]: n
      } : {
        ...t,
        ...n
      };
    }, [e, t, n, r]);
  }
  function _F(e) {
    const {
      children: t,
      theme: n,
      themeId: r
    } = e, o = wk(JP), i = _k() || JP, a = e2(r, o, n), s = e2(r, i, n, !0), c = (r ? a[r] : a).direction === "rtl", u = UX(a);
    return /* @__PURE__ */ S.jsx($X, {
      theme: s,
      children: /* @__PURE__ */ S.jsx(jh.Provider, {
        value: a,
        children: /* @__PURE__ */ S.jsx(jX, {
          value: c,
          children: /* @__PURE__ */ S.jsxs(DX, {
            value: r ? a[r].components : a.components,
            children: [u, t]
          })
        })
      })
    });
  }
  const t2 = {
    theme: void 0
  };
  function VX(e) {
    let t, n;
    return function(o) {
      let i = t;
      return (i === void 0 || o.theme !== n) && (t2.theme = o.theme, i = mF(e(t2)), t = i, n = o.theme), i;
    };
  }
  const Ek = "mode", Ck = "color-scheme", HX = "data-color-scheme";
  function qX(e) {
    const {
      defaultMode: t = "system",
      defaultLightColorScheme: n = "light",
      defaultDarkColorScheme: r = "dark",
      modeStorageKey: o = Ek,
      colorSchemeStorageKey: i = Ck,
      attribute: a = HX,
      colorSchemeNode: s = "document.documentElement",
      nonce: c
    } = e || {};
    let u = "", d = a;
    if (a === "class" && (d = ".%s"), a === "data" && (d = "[data-%s]"), d.startsWith(".")) {
      const m = d.substring(1);
      u += `${s}.classList.remove('${m}'.replace('%s', light), '${m}'.replace('%s', dark));
      ${s}.classList.add('${m}'.replace('%s', colorScheme));`;
    }
    const p = d.match(/\[([^[\]]+)\]/);
    if (p) {
      const [m, g] = p[1].split("=");
      g || (u += `${s}.removeAttribute('${m}'.replace('%s', light));
      ${s}.removeAttribute('${m}'.replace('%s', dark));`), u += `
      ${s}.setAttribute('${m}'.replace('%s', colorScheme), ${g ? `${g}.replace('%s', colorScheme)` : '""'});`;
    } else d !== ".%s" && (u += `${s}.setAttribute('${d}', colorScheme);`);
    return /* @__PURE__ */ S.jsx("script", {
      suppressHydrationWarning: !0,
      nonce: typeof window > "u" ? c : "",
      dangerouslySetInnerHTML: {
        __html: `(function() {
try {
  let colorScheme = '';
  const mode = localStorage.getItem('${o}') || '${t}';
  const dark = localStorage.getItem('${i}-dark') || '${r}';
  const light = localStorage.getItem('${i}-light') || '${n}';
  if (mode === 'system') {
    // handle system mode
    const mql = window.matchMedia('(prefers-color-scheme: dark)');
    if (mql.matches) {
      colorScheme = dark
    } else {
      colorScheme = light
    }
  }
  if (mode === 'light') {
    colorScheme = light;
  }
  if (mode === 'dark') {
    colorScheme = dark;
  }
  if (colorScheme) {
    ${u}
  }
} catch(e){}})();`
      }
    }, "mui-color-scheme-init");
  }
  function WX() {
  }
  const GX = ({
    key: e,
    storageWindow: t
  }) => (!t && typeof window < "u" && (t = window), {
    get(n) {
      if (typeof window > "u")
        return;
      if (!t)
        return n;
      let r;
      try {
        r = t.localStorage.getItem(e);
      } catch {
      }
      return r || n;
    },
    set: (n) => {
      if (t)
        try {
          t.localStorage.setItem(e, n);
        } catch {
        }
    },
    subscribe: (n) => {
      if (!t)
        return WX;
      const r = (o) => {
        const i = o.newValue;
        o.key === e && n(i);
      };
      return t.addEventListener("storage", r), () => {
        t.removeEventListener("storage", r);
      };
    }
  });
  function gS() {
  }
  function n2(e) {
    if (typeof window < "u" && typeof window.matchMedia == "function" && e === "system")
      return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
  }
  function EF(e, t) {
    if (e.mode === "light" || e.mode === "system" && e.systemMode === "light")
      return t("light");
    if (e.mode === "dark" || e.mode === "system" && e.systemMode === "dark")
      return t("dark");
  }
  function KX(e) {
    return EF(e, (t) => {
      if (t === "light")
        return e.lightColorScheme;
      if (t === "dark")
        return e.darkColorScheme;
    });
  }
  function YX(e) {
    const {
      defaultMode: t = "light",
      defaultLightColorScheme: n,
      defaultDarkColorScheme: r,
      supportedColorSchemes: o = [],
      modeStorageKey: i = Ek,
      colorSchemeStorageKey: a = Ck,
      storageWindow: s = typeof window > "u" ? void 0 : window,
      storageManager: c = GX,
      noSsr: u = !1
    } = e, d = o.join(","), p = o.length > 1, m = T.useMemo(() => c?.({
      key: i,
      storageWindow: s
    }), [c, i, s]), g = T.useMemo(() => c?.({
      key: `${a}-light`,
      storageWindow: s
    }), [c, a, s]), y = T.useMemo(() => c?.({
      key: `${a}-dark`,
      storageWindow: s
    }), [c, a, s]), [b, v] = T.useState(() => {
      const P = m?.get(t) || t, I = g?.get(n) || n, $ = y?.get(r) || r;
      return {
        mode: P,
        systemMode: n2(P),
        lightColorScheme: I,
        darkColorScheme: $
      };
    }), [x, E] = T.useState(u || !p);
    T.useEffect(() => {
      E(!0);
    }, []);
    const _ = KX(b), C = T.useCallback((P) => {
      v((I) => {
        if (P === I.mode)
          return I;
        const $ = P ?? t;
        return m?.set($), {
          ...I,
          mode: $,
          systemMode: n2($)
        };
      });
    }, [m, t]), k = T.useCallback((P) => {
      P ? typeof P == "string" ? P && !d.includes(P) ? console.error(`\`${P}\` does not exist in \`theme.colorSchemes\`.`) : v((I) => {
        const $ = {
          ...I
        };
        return EF(I, (L) => {
          L === "light" && (g?.set(P), $.lightColorScheme = P), L === "dark" && (y?.set(P), $.darkColorScheme = P);
        }), $;
      }) : v((I) => {
        const $ = {
          ...I
        }, L = P.light === null ? n : P.light, N = P.dark === null ? r : P.dark;
        return L && (d.includes(L) ? ($.lightColorScheme = L, g?.set(L)) : console.error(`\`${L}\` does not exist in \`theme.colorSchemes\`.`)), N && (d.includes(N) ? ($.darkColorScheme = N, y?.set(N)) : console.error(`\`${N}\` does not exist in \`theme.colorSchemes\`.`)), $;
      }) : v((I) => (g?.set(n), y?.set(r), {
        ...I,
        lightColorScheme: n,
        darkColorScheme: r
      }));
    }, [d, g, y, n, r]), A = T.useCallback((P) => {
      b.mode === "system" && v((I) => {
        const $ = P?.matches ? "dark" : "light";
        return I.systemMode === $ ? I : {
          ...I,
          systemMode: $
        };
      });
    }, [b.mode]), O = T.useRef(A);
    return O.current = A, T.useEffect(() => {
      if (typeof window.matchMedia != "function" || !p)
        return;
      const P = (...$) => O.current(...$), I = window.matchMedia("(prefers-color-scheme: dark)");
      return I.addListener(P), P(I), () => {
        I.removeListener(P);
      };
    }, [p]), T.useEffect(() => {
      if (p) {
        const P = m?.subscribe((L) => {
          (!L || ["light", "dark", "system"].includes(L)) && C(L || t);
        }) || gS, I = g?.subscribe((L) => {
          (!L || d.match(L)) && k({
            light: L
          });
        }) || gS, $ = y?.subscribe((L) => {
          (!L || d.match(L)) && k({
            dark: L
          });
        }) || gS;
        return () => {
          P(), I(), $();
        };
      }
    }, [k, C, d, t, s, p, m, g, y]), {
      ...b,
      mode: x ? b.mode : void 0,
      systemMode: x ? b.systemMode : void 0,
      colorScheme: x ? _ : void 0,
      setMode: C,
      setColorScheme: k
    };
  }
  const XX = "*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
  function ZX(e) {
    const {
      themeId: t,
      /**
       * This `theme` object needs to follow a certain structure to
       * be used correctly by the finel `CssVarsProvider`. It should have a
       * `colorSchemes` key with the light and dark (and any other) palette.
       * It should also ideally have a vars object created using `prepareCssVars`.
       */
      theme: n = {},
      modeStorageKey: r = Ek,
      colorSchemeStorageKey: o = Ck,
      disableTransitionOnChange: i = !1,
      defaultColorScheme: a,
      resolveTheme: s
    } = e, c = {
      allColorSchemes: [],
      colorScheme: void 0,
      darkColorScheme: void 0,
      lightColorScheme: void 0,
      mode: void 0,
      setColorScheme: () => {
      },
      setMode: () => {
      },
      systemMode: void 0
    }, u = /* @__PURE__ */ T.createContext(void 0), d = () => T.useContext(u) || c, p = {}, m = {};
    function g(x) {
      const {
        children: E,
        theme: _,
        modeStorageKey: C = r,
        colorSchemeStorageKey: k = o,
        disableTransitionOnChange: A = i,
        storageManager: O,
        storageWindow: P = typeof window > "u" ? void 0 : window,
        documentNode: I = typeof document > "u" ? void 0 : document,
        colorSchemeNode: $ = typeof document > "u" ? void 0 : document.documentElement,
        disableNestedContext: L = !1,
        disableStyleSheetGeneration: N = !1,
        defaultMode: U = "system",
        forceThemeRerender: j = !1,
        noSsr: V
      } = x, F = T.useRef(!1), K = _k(), W = T.useContext(u), Y = !!W && !L, B = T.useMemo(() => _ || (typeof n == "function" ? n() : n), [_]), D = B[t], G = D || B, {
        colorSchemes: z = p,
        components: H = m,
        cssVarPrefix: X
      } = G, Q = Object.keys(z).filter((oe) => !!z[oe]).join(","), ne = T.useMemo(() => Q.split(","), [Q]), te = typeof a == "string" ? a : a.light, se = typeof a == "string" ? a : a.dark, ue = z[te] && z[se] ? U : z[G.defaultColorScheme]?.palette?.mode || G.palette?.mode, {
        mode: J,
        setMode: ee,
        systemMode: ie,
        lightColorScheme: le,
        darkColorScheme: ge,
        colorScheme: Se,
        setColorScheme: Me
      } = YX({
        supportedColorSchemes: ne,
        defaultLightColorScheme: te,
        defaultDarkColorScheme: se,
        modeStorageKey: C,
        colorSchemeStorageKey: k,
        defaultMode: ue,
        storageManager: O,
        storageWindow: P,
        noSsr: V
      });
      let je = J, ze = Se;
      Y && (je = W.mode, ze = W.colorScheme);
      let Ye = ze || G.defaultColorScheme;
      G.vars && !j && (Ye = G.defaultColorScheme);
      const Ue = T.useMemo(() => {
        const oe = G.generateThemeVars?.() || G.vars, fe = {
          ...G,
          components: H,
          colorSchemes: z,
          cssVarPrefix: X,
          vars: oe
        };
        if (typeof fe.generateSpacing == "function" && (fe.spacing = fe.generateSpacing()), Ye) {
          const _e = z[Ye];
          _e && typeof _e == "object" && Object.keys(_e).forEach((Ce) => {
            _e[Ce] && typeof _e[Ce] == "object" ? fe[Ce] = {
              ...fe[Ce],
              ..._e[Ce]
            } : fe[Ce] = _e[Ce];
          });
        }
        return s ? s(fe) : fe;
      }, [G, Ye, H, z, X]), Ne = G.colorSchemeSelector;
      ei(() => {
        if (ze && $ && Ne && Ne !== "media") {
          const oe = Ne;
          let fe = Ne;
          if (oe === "class" && (fe = ".%s"), oe === "data" && (fe = "[data-%s]"), oe?.startsWith("data-") && !oe.includes("%s") && (fe = `[${oe}="%s"]`), fe.startsWith("."))
            $.classList.remove(...ne.map((_e) => fe.substring(1).replace("%s", _e))), $.classList.add(fe.substring(1).replace("%s", ze));
          else {
            const _e = fe.replace("%s", ze).match(/\[([^\]]+)\]/);
            if (_e) {
              const [Ce, Oe] = _e[1].split("=");
              Oe || ne.forEach((He) => {
                $.removeAttribute(Ce.replace(ze, He));
              }), $.setAttribute(Ce, Oe ? Oe.replace(/"|'/g, "") : "");
            } else
              $.setAttribute(fe, ze);
          }
        }
      }, [ze, Ne, $, ne]), T.useEffect(() => {
        let oe;
        if (A && F.current && I) {
          const fe = I.createElement("style");
          fe.appendChild(I.createTextNode(XX)), I.head.appendChild(fe), window.getComputedStyle(I.body), oe = setTimeout(() => {
            I.head.removeChild(fe);
          }, 1);
        }
        return () => {
          clearTimeout(oe);
        };
      }, [ze, A, I]), T.useEffect(() => (F.current = !0, () => {
        F.current = !1;
      }), []);
      const mt = T.useMemo(() => ({
        allColorSchemes: ne,
        colorScheme: ze,
        darkColorScheme: ge,
        lightColorScheme: le,
        mode: je,
        setColorScheme: Me,
        setMode: ee,
        systemMode: ie
      }), [ne, ze, ge, le, je, Me, ee, ie, Ue.colorSchemeSelector]);
      let Je = !0;
      (N || G.cssVariables === !1 || Y && K?.cssVarPrefix === X) && (Je = !1);
      const Ae = /* @__PURE__ */ S.jsxs(T.Fragment, {
        children: [/* @__PURE__ */ S.jsx(_F, {
          themeId: D ? t : void 0,
          theme: Ue,
          children: E
        }), Je && /* @__PURE__ */ S.jsx(uF, {
          styles: Ue.generateStyleSheets?.() || []
        })]
      });
      return Y ? Ae : /* @__PURE__ */ S.jsx(u.Provider, {
        value: mt,
        children: Ae
      });
    }
    const y = typeof a == "string" ? a : a.light, b = typeof a == "string" ? a : a.dark;
    return {
      CssVarsProvider: g,
      useColorScheme: d,
      getInitColorSchemeScript: (x) => qX({
        colorSchemeStorageKey: o,
        defaultLightColorScheme: y,
        defaultDarkColorScheme: b,
        modeStorageKey: r,
        ...x
      })
    };
  }
  function QX(e = "") {
    function t(...r) {
      if (!r.length)
        return "";
      const o = r[0];
      return typeof o == "string" && !o.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/) ? `, var(--${e ? `${e}-` : ""}${o}${t(...r.slice(1))})` : `, ${o}`;
    }
    return (r, ...o) => `var(--${e ? `${e}-` : ""}${r}${t(...o)})`;
  }
  const r2 = (e, t, n, r = []) => {
    let o = e;
    t.forEach((i, a) => {
      a === t.length - 1 ? Array.isArray(o) ? o[Number(i)] = n : o && typeof o == "object" && (o[i] = n) : o && typeof o == "object" && (o[i] || (o[i] = r.includes(i) ? [] : {}), o = o[i]);
    });
  }, JX = (e, t, n) => {
    function r(o, i = [], a = []) {
      Object.entries(o).forEach(([s, c]) => {
        (!n || n && !n([...i, s])) && c != null && (typeof c == "object" && Object.keys(c).length > 0 ? r(c, [...i, s], Array.isArray(c) ? [...a, s] : a) : t([...i, s], c, a));
      });
    }
    r(e);
  }, eZ = (e, t) => typeof t == "number" ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some((r) => e.includes(r)) || e[e.length - 1].toLowerCase().includes("opacity") ? t : `${t}px` : t;
  function yS(e, t) {
    const {
      prefix: n,
      shouldSkipGeneratingVar: r
    } = t || {}, o = {}, i = {}, a = {};
    return JX(
      e,
      (s, c, u) => {
        if ((typeof c == "string" || typeof c == "number") && (!r || !r(s, c))) {
          const d = `--${n ? `${n}-` : ""}${s.join("-")}`, p = eZ(s, c);
          Object.assign(o, {
            [d]: p
          }), r2(i, s, `var(${d})`, u), r2(a, s, `var(${d}, ${p})`, u);
        }
      },
      (s) => s[0] === "vars"
      // skip 'vars/*' paths
    ), {
      css: o,
      vars: i,
      varsWithDefaults: a
    };
  }
  function tZ(e, t = {}) {
    const {
      getSelector: n = x,
      disableCssColorScheme: r,
      colorSchemeSelector: o,
      enableContrastVars: i
    } = t, {
      colorSchemes: a = {},
      components: s,
      defaultColorScheme: c = "light",
      ...u
    } = e, {
      vars: d,
      css: p,
      varsWithDefaults: m
    } = yS(u, t);
    let g = m;
    const y = {}, {
      [c]: b,
      ...v
    } = a;
    if (Object.entries(v || {}).forEach(([C, k]) => {
      const {
        vars: A,
        css: O,
        varsWithDefaults: P
      } = yS(k, t);
      g = xr(g, P), y[C] = {
        css: O,
        vars: A
      };
    }), b) {
      const {
        css: C,
        vars: k,
        varsWithDefaults: A
      } = yS(b, t);
      g = xr(g, A), y[c] = {
        css: C,
        vars: k
      };
    }
    function x(C, k) {
      let A = o;
      if (o === "class" && (A = ".%s"), o === "data" && (A = "[data-%s]"), o?.startsWith("data-") && !o.includes("%s") && (A = `[${o}="%s"]`), C) {
        if (A === "media")
          return e.defaultColorScheme === C ? ":root" : {
            [`@media (prefers-color-scheme: ${a[C]?.palette?.mode || C})`]: {
              ":root": k
            }
          };
        if (A)
          return e.defaultColorScheme === C ? `:root, ${A.replace("%s", String(C))}` : A.replace("%s", String(C));
      }
      return ":root";
    }
    return {
      vars: g,
      generateThemeVars: () => {
        let C = {
          ...d
        };
        return Object.entries(y).forEach(([, {
          vars: k
        }]) => {
          C = xr(C, k);
        }), C;
      },
      generateStyleSheets: () => {
        const C = [], k = e.defaultColorScheme || "light";
        function A(I, $) {
          Object.keys($).length && C.push(typeof I == "string" ? {
            [I]: {
              ...$
            }
          } : I);
        }
        A(n(void 0, {
          ...p
        }), p);
        const {
          [k]: O,
          ...P
        } = y;
        if (O) {
          const {
            css: I
          } = O, $ = a[k]?.palette?.mode, L = !r && $ ? {
            colorScheme: $,
            ...I
          } : {
            ...I
          };
          A(n(k, {
            ...L
          }), L);
        }
        return Object.entries(P).forEach(([I, {
          css: $
        }]) => {
          const L = a[I]?.palette?.mode, N = !r && L ? {
            colorScheme: L,
            ...$
          } : {
            ...$
          };
          A(n(I, {
            ...N
          }), N);
        }), i && C.push({
          ":root": {
            // use double underscore to indicate that these are private variables
            "--__l-threshold": "0.7",
            "--__l": "clamp(0, (l / var(--__l-threshold) - 1) * -infinity, 1)",
            "--__a": "clamp(0.87, (l / var(--__l-threshold) - 1) * -infinity, 1)"
            // 0.87 is the default alpha value for black text.
          }
        }), C;
      }
    };
  }
  function nZ(e) {
    return function(n) {
      return e === "media" ? `@media (prefers-color-scheme: ${n})` : e ? e.startsWith("data-") && !e.includes("%s") ? `[${e}="${n}"] &` : e === "class" ? `.${n} &` : e === "data" ? `[data-${n}] &` : `${e.replace("%s", n)} &` : "&";
    };
  }
  function Tp(e, t) {
    return /* @__PURE__ */ T.isValidElement(e) && t.indexOf(
      // For server components `muiName` is available in element.type._payload.value.muiName
      // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
      // eslint-disable-next-line no-underscore-dangle
      e.type.muiName ?? e.type?._payload?.value?.muiName
    ) !== -1;
  }
  const rZ = (e, t) => e.filter((n) => t.includes(n)), jf = (e, t, n) => {
    const r = e.keys[0];
    Array.isArray(t) ? t.forEach((o, i) => {
      n((a, s) => {
        i <= e.keys.length - 1 && (i === 0 ? Object.assign(a, s) : a[e.up(e.keys[i])] = s);
      }, o);
    }) : t && typeof t == "object" ? (Object.keys(t).length > e.keys.length ? e.keys : rZ(e.keys, Object.keys(t))).forEach((i) => {
      if (e.keys.includes(i)) {
        const a = t[i];
        a !== void 0 && n((s, c) => {
          r === i ? Object.assign(s, c) : s[e.up(i)] = c;
        }, a);
      }
    }) : (typeof t == "number" || typeof t == "string") && n((o, i) => {
      Object.assign(o, i);
    }, t);
  };
  function e0(e) {
    return `--Grid-${e}Spacing`;
  }
  function hb(e) {
    return `--Grid-parent-${e}Spacing`;
  }
  const o2 = "--Grid-columns", Ju = "--Grid-parent-columns", oZ = ({
    theme: e,
    ownerState: t
  }) => {
    const n = {};
    return jf(e.breakpoints, t.size, (r, o) => {
      let i = {};
      o === "grow" && (i = {
        flexBasis: 0,
        flexGrow: 1,
        maxWidth: "100%"
      }), o === "auto" && (i = {
        flexBasis: "auto",
        flexGrow: 0,
        flexShrink: 0,
        maxWidth: "none",
        width: "auto"
      }), typeof o == "number" && (i = {
        flexGrow: 0,
        flexBasis: "auto",
        width: `calc(100% * ${o} / var(${Ju}) - (var(${Ju}) - ${o}) * (var(${hb("column")}) / var(${Ju})))`
      }), r(n, i);
    }), n;
  }, iZ = ({
    theme: e,
    ownerState: t
  }) => {
    const n = {};
    return jf(e.breakpoints, t.offset, (r, o) => {
      let i = {};
      o === "auto" && (i = {
        marginLeft: "auto"
      }), typeof o == "number" && (i = {
        marginLeft: o === 0 ? "0px" : `calc(100% * ${o} / var(${Ju}) + var(${hb("column")}) * ${o} / var(${Ju}))`
      }), r(n, i);
    }), n;
  }, aZ = ({
    theme: e,
    ownerState: t
  }) => {
    if (!t.container)
      return {};
    const n = {
      [o2]: 12
    };
    return jf(e.breakpoints, t.columns, (r, o) => {
      const i = o ?? 12;
      r(n, {
        [o2]: i,
        "> *": {
          [Ju]: i
        }
      });
    }), n;
  }, sZ = ({
    theme: e,
    ownerState: t
  }) => {
    if (!t.container)
      return {};
    const n = {};
    return jf(e.breakpoints, t.rowSpacing, (r, o) => {
      const i = typeof o == "string" ? o : e.spacing?.(o);
      r(n, {
        [e0("row")]: i,
        "> *": {
          [hb("row")]: i
        }
      });
    }), n;
  }, lZ = ({
    theme: e,
    ownerState: t
  }) => {
    if (!t.container)
      return {};
    const n = {};
    return jf(e.breakpoints, t.columnSpacing, (r, o) => {
      const i = typeof o == "string" ? o : e.spacing?.(o);
      r(n, {
        [e0("column")]: i,
        "> *": {
          [hb("column")]: i
        }
      });
    }), n;
  }, cZ = ({
    theme: e,
    ownerState: t
  }) => {
    if (!t.container)
      return {};
    const n = {};
    return jf(e.breakpoints, t.direction, (r, o) => {
      r(n, {
        flexDirection: o
      });
    }), n;
  }, uZ = ({
    ownerState: e
  }) => ({
    minWidth: 0,
    boxSizing: "border-box",
    ...e.container && {
      display: "flex",
      flexWrap: "wrap",
      ...e.wrap && e.wrap !== "wrap" && {
        flexWrap: e.wrap
      },
      gap: `var(${e0("row")}) var(${e0("column")})`
    }
  }), fZ = (e) => {
    const t = [];
    return Object.entries(e).forEach(([n, r]) => {
      r !== !1 && r !== void 0 && t.push(`grid-${n}-${String(r)}`);
    }), t;
  }, dZ = (e, t = "xs") => {
    function n(r) {
      return r === void 0 ? !1 : typeof r == "string" && !Number.isNaN(Number(r)) || typeof r == "number" && r > 0;
    }
    if (n(e))
      return [`spacing-${t}-${String(e)}`];
    if (typeof e == "object" && !Array.isArray(e)) {
      const r = [];
      return Object.entries(e).forEach(([o, i]) => {
        n(i) && r.push(`spacing-${o}-${String(i)}`);
      }), r;
    }
    return [];
  }, pZ = (e) => e === void 0 ? [] : typeof e == "object" ? Object.entries(e).map(([t, n]) => `direction-${t}-${n}`) : [`direction-xs-${String(e)}`];
  function hZ(e, t) {
    e.item !== void 0 && delete e.item, e.zeroMinWidth !== void 0 && delete e.zeroMinWidth, t.keys.forEach((n) => {
      e[n] !== void 0 && delete e[n];
    });
  }
  const mZ = ub(), gZ = CX("div", {
    name: "MuiGrid",
    slot: "Root"
  });
  function yZ(e) {
    return TX({
      props: e,
      name: "MuiGrid",
      defaultTheme: mZ
    });
  }
  function vZ(e = {}) {
    const {
      // This will allow adding custom styled fn (for example for custom sx style function)
      createStyledComponent: t = gZ,
      useThemeProps: n = yZ,
      useTheme: r = Fh,
      componentName: o = "MuiGrid"
    } = e, i = (u, d) => {
      const {
        container: p,
        direction: m,
        spacing: g,
        wrap: y,
        size: b
      } = u, v = {
        root: ["root", p && "container", y !== "wrap" && `wrap-xs-${String(y)}`, ...pZ(m), ...fZ(b), ...p ? dZ(g, d.breakpoints.keys[0]) : []]
      };
      return rt(v, (x) => ot(o, x), {});
    };
    function a(u, d, p = () => !0) {
      const m = {};
      return u === null || (Array.isArray(u) ? u.forEach((g, y) => {
        g !== null && p(g) && d.keys[y] && (m[d.keys[y]] = g);
      }) : typeof u == "object" ? Object.keys(u).forEach((g) => {
        const y = u[g];
        y != null && p(y) && (m[g] = y);
      }) : m[d.keys[0]] = u), m;
    }
    const s = t(aZ, lZ, sZ, oZ, cZ, uZ, iZ), c = /* @__PURE__ */ T.forwardRef(function(d, p) {
      const m = r(), g = n(d), y = pk(g);
      hZ(y, m.breakpoints);
      const {
        className: b,
        children: v,
        columns: x = 12,
        container: E = !1,
        component: _ = "div",
        direction: C = "row",
        wrap: k = "wrap",
        size: A = {},
        offset: O = {},
        spacing: P = 0,
        rowSpacing: I = P,
        columnSpacing: $ = P,
        unstable_level: L = 0,
        ...N
      } = y, U = a(A, m.breakpoints, (D) => D !== !1), j = a(O, m.breakpoints), V = d.columns ?? (L ? void 0 : x), F = d.spacing ?? (L ? void 0 : P), K = d.rowSpacing ?? d.spacing ?? (L ? void 0 : I), W = d.columnSpacing ?? d.spacing ?? (L ? void 0 : $), Y = {
        ...y,
        level: L,
        columns: V,
        container: E,
        direction: C,
        wrap: k,
        spacing: F,
        rowSpacing: K,
        columnSpacing: W,
        size: U,
        offset: j
      }, B = i(Y, m);
      return /* @__PURE__ */ S.jsx(s, {
        ref: p,
        as: _,
        ownerState: Y,
        className: $e(B.root, b),
        ...N,
        children: T.Children.map(v, (D) => /* @__PURE__ */ T.isValidElement(D) && Tp(D, ["Grid"]) && E && D.props.container ? /* @__PURE__ */ T.cloneElement(D, {
          unstable_level: D.props?.unstable_level ?? L + 1
        }) : D)
      });
    });
    return c.muiName = "Grid", c;
  }
  const Xp = {
    black: "#000",
    white: "#fff"
  }, bZ = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#eeeeee",
    300: "#e0e0e0",
    400: "#bdbdbd",
    500: "#9e9e9e",
    600: "#757575",
    700: "#616161",
    800: "#424242",
    900: "#212121",
    A100: "#f5f5f5",
    A200: "#eeeeee",
    A400: "#bdbdbd",
    A700: "#616161"
  }, xu = {
    50: "#f3e5f5",
    200: "#ce93d8",
    300: "#ba68c8",
    400: "#ab47bc",
    500: "#9c27b0",
    700: "#7b1fa2"
  }, wu = {
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    700: "#d32f2f",
    800: "#c62828"
  }, Wd = {
    300: "#ffb74d",
    400: "#ffa726",
    500: "#ff9800",
    700: "#f57c00",
    900: "#e65100"
  }, Su = {
    50: "#e3f2fd",
    200: "#90caf9",
    400: "#42a5f5",
    700: "#1976d2",
    800: "#1565c0"
  }, _u = {
    300: "#4fc3f7",
    400: "#29b6f6",
    500: "#03a9f4",
    700: "#0288d1",
    900: "#01579b"
  }, Eu = {
    300: "#81c784",
    400: "#66bb6a",
    500: "#4caf50",
    700: "#388e3c",
    800: "#2e7d32",
    900: "#1b5e20"
  };
  function CF() {
    return {
      // The colors used to style the text.
      text: {
        // The most important text.
        primary: "rgba(0, 0, 0, 0.87)",
        // Secondary text.
        secondary: "rgba(0, 0, 0, 0.6)",
        // Disabled text have even lower visual prominence.
        disabled: "rgba(0, 0, 0, 0.38)"
      },
      // The color used to divide different elements.
      divider: "rgba(0, 0, 0, 0.12)",
      // The background colors used to style the surfaces.
      // Consistency between these values is important.
      background: {
        paper: Xp.white,
        default: Xp.white
      },
      // The colors used to style the action elements.
      action: {
        // The color of an active action like an icon button.
        active: "rgba(0, 0, 0, 0.54)",
        // The color of an hovered action.
        hover: "rgba(0, 0, 0, 0.04)",
        hoverOpacity: 0.04,
        // The color of a selected action.
        selected: "rgba(0, 0, 0, 0.08)",
        selectedOpacity: 0.08,
        // The color of a disabled action.
        disabled: "rgba(0, 0, 0, 0.26)",
        // The background color of a disabled action.
        disabledBackground: "rgba(0, 0, 0, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(0, 0, 0, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.12
      }
    };
  }
  const kF = CF();
  function TF() {
    return {
      text: {
        primary: Xp.white,
        secondary: "rgba(255, 255, 255, 0.7)",
        disabled: "rgba(255, 255, 255, 0.5)",
        icon: "rgba(255, 255, 255, 0.5)"
      },
      divider: "rgba(255, 255, 255, 0.12)",
      background: {
        paper: "#121212",
        default: "#121212"
      },
      action: {
        active: Xp.white,
        hover: "rgba(255, 255, 255, 0.08)",
        hoverOpacity: 0.08,
        selected: "rgba(255, 255, 255, 0.16)",
        selectedOpacity: 0.16,
        disabled: "rgba(255, 255, 255, 0.3)",
        disabledBackground: "rgba(255, 255, 255, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(255, 255, 255, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.24
      }
    };
  }
  const xE = TF();
  function i2(e, t, n, r) {
    const o = r.light || r, i = r.dark || r * 1.5;
    e[t] || (e.hasOwnProperty(n) ? e[t] = e[n] : t === "light" ? e.light = pb(e.main, o) : t === "dark" && (e.dark = db(e.main, i)));
  }
  function a2(e, t, n, r, o) {
    const i = o.light || o, a = o.dark || o * 1.5;
    t[n] || (t.hasOwnProperty(r) ? t[n] = t[r] : n === "light" ? t.light = `color-mix(in ${e}, ${t.main}, #fff ${(i * 100).toFixed(0)}%)` : n === "dark" && (t.dark = `color-mix(in ${e}, ${t.main}, #000 ${(a * 100).toFixed(0)}%)`));
  }
  function xZ(e = "light") {
    return e === "dark" ? {
      main: Su[200],
      light: Su[50],
      dark: Su[400]
    } : {
      main: Su[700],
      light: Su[400],
      dark: Su[800]
    };
  }
  function wZ(e = "light") {
    return e === "dark" ? {
      main: xu[200],
      light: xu[50],
      dark: xu[400]
    } : {
      main: xu[500],
      light: xu[300],
      dark: xu[700]
    };
  }
  function SZ(e = "light") {
    return e === "dark" ? {
      main: wu[500],
      light: wu[300],
      dark: wu[700]
    } : {
      main: wu[700],
      light: wu[400],
      dark: wu[800]
    };
  }
  function _Z(e = "light") {
    return e === "dark" ? {
      main: _u[400],
      light: _u[300],
      dark: _u[700]
    } : {
      main: _u[700],
      light: _u[500],
      dark: _u[900]
    };
  }
  function EZ(e = "light") {
    return e === "dark" ? {
      main: Eu[400],
      light: Eu[300],
      dark: Eu[700]
    } : {
      main: Eu[800],
      light: Eu[500],
      dark: Eu[900]
    };
  }
  function CZ(e = "light") {
    return e === "dark" ? {
      main: Wd[400],
      light: Wd[300],
      dark: Wd[700]
    } : {
      main: "#ed6c02",
      // closest to orange[800] that pass 3:1.
      light: Wd[500],
      dark: Wd[900]
    };
  }
  function kZ(e) {
    return `oklch(from ${e} var(--__l) 0 h / var(--__a))`;
  }
  function kk(e) {
    const {
      mode: t = "light",
      contrastThreshold: n = 3,
      tonalOffset: r = 0.2,
      colorSpace: o,
      ...i
    } = e, a = e.primary || xZ(t), s = e.secondary || wZ(t), c = e.error || SZ(t), u = e.info || _Z(t), d = e.success || EZ(t), p = e.warning || CZ(t);
    function m(v) {
      return o ? kZ(v) : OX(v, xE.text.primary) >= n ? xE.text.primary : kF.text.primary;
    }
    const g = ({
      color: v,
      name: x,
      mainShade: E = 500,
      lightShade: _ = 300,
      darkShade: C = 700
    }) => {
      if (v = {
        ...v
      }, !v.main && v[E] && (v.main = v[E]), !v.hasOwnProperty("main"))
        throw new Error(Va(11, x ? ` (${x})` : "", E));
      if (typeof v.main != "string")
        throw new Error(Va(12, x ? ` (${x})` : "", JSON.stringify(v.main)));
      return o ? (a2(o, v, "light", _, r), a2(o, v, "dark", C, r)) : (i2(v, "light", _, r), i2(v, "dark", C, r)), v.contrastText || (v.contrastText = m(v.main)), v;
    };
    let y;
    return t === "light" ? y = CF() : t === "dark" && (y = TF()), xr({
      // A collection of common colors.
      common: {
        ...Xp
      },
      // prevent mutable object.
      // The palette mode, can be light or dark.
      mode: t,
      // The colors used to represent primary interface elements for a user.
      primary: g({
        color: a,
        name: "primary"
      }),
      // The colors used to represent secondary interface elements for a user.
      secondary: g({
        color: s,
        name: "secondary",
        mainShade: "A400",
        lightShade: "A200",
        darkShade: "A700"
      }),
      // The colors used to represent interface elements that the user should be made aware of.
      error: g({
        color: c,
        name: "error"
      }),
      // The colors used to represent potentially dangerous actions or important messages.
      warning: g({
        color: p,
        name: "warning"
      }),
      // The colors used to present information to the user that is neutral and not necessarily important.
      info: g({
        color: u,
        name: "info"
      }),
      // The colors used to indicate the successful completion of an action that user triggered.
      success: g({
        color: d,
        name: "success"
      }),
      // The grey colors.
      grey: bZ,
      // Used by `getContrastText()` to maximize the contrast between
      // the background and the text.
      contrastThreshold: n,
      // Takes a background color and returns the text color that maximizes the contrast.
      getContrastText: m,
      // Generate a rich color object.
      augmentColor: g,
      // Used by the functions below to shift a color's luminance by approximately
      // two indexes within its tonal palette.
      // E.g., shift from Red 500 to Red 300 or Red 700.
      tonalOffset: r,
      // The light and dark mode object.
      ...y
    }, i);
  }
  function TZ(e) {
    const t = {};
    return Object.entries(e).forEach((r) => {
      const [o, i] = r;
      typeof i == "object" && (t[o] = `${i.fontStyle ? `${i.fontStyle} ` : ""}${i.fontVariant ? `${i.fontVariant} ` : ""}${i.fontWeight ? `${i.fontWeight} ` : ""}${i.fontStretch ? `${i.fontStretch} ` : ""}${i.fontSize || ""}${i.lineHeight ? `/${i.lineHeight} ` : ""}${i.fontFamily || ""}`);
    }), t;
  }
  function AZ(e, t) {
    return {
      toolbar: {
        minHeight: 56,
        [e.up("xs")]: {
          "@media (orientation: landscape)": {
            minHeight: 48
          }
        },
        [e.up("sm")]: {
          minHeight: 64
        }
      },
      ...t
    };
  }
  function RZ(e) {
    return Math.round(e * 1e5) / 1e5;
  }
  const s2 = {
    textTransform: "uppercase"
  }, l2 = '"Roboto", "Helvetica", "Arial", sans-serif';
  function AF(e, t) {
    const {
      fontFamily: n = l2,
      // The default font size of the Material Specification.
      fontSize: r = 14,
      // px
      fontWeightLight: o = 300,
      fontWeightRegular: i = 400,
      fontWeightMedium: a = 500,
      fontWeightBold: s = 700,
      // Tell MUI what's the font-size on the html element.
      // 16px is the default font-size used by browsers.
      htmlFontSize: c = 16,
      // Apply the CSS properties to all the variants.
      allVariants: u,
      pxToRem: d,
      ...p
    } = typeof t == "function" ? t(e) : t, m = r / 14, g = d || ((v) => `${v / c * m}rem`), y = (v, x, E, _, C) => ({
      fontFamily: n,
      fontWeight: v,
      fontSize: g(x),
      // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
      lineHeight: E,
      // The letter spacing was designed for the Roboto font-family. Using the same letter-spacing
      // across font-families can cause issues with the kerning.
      ...n === l2 ? {
        letterSpacing: `${RZ(_ / x)}em`
      } : {},
      ...C,
      ...u
    }), b = {
      h1: y(o, 96, 1.167, -1.5),
      h2: y(o, 60, 1.2, -0.5),
      h3: y(i, 48, 1.167, 0),
      h4: y(i, 34, 1.235, 0.25),
      h5: y(i, 24, 1.334, 0),
      h6: y(a, 20, 1.6, 0.15),
      subtitle1: y(i, 16, 1.75, 0.15),
      subtitle2: y(a, 14, 1.57, 0.1),
      body1: y(i, 16, 1.5, 0.15),
      body2: y(i, 14, 1.43, 0.15),
      button: y(a, 14, 1.75, 0.4, s2),
      caption: y(i, 12, 1.66, 0.4),
      overline: y(i, 12, 2.66, 1, s2),
      // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
      inherit: {
        fontFamily: "inherit",
        fontWeight: "inherit",
        fontSize: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit"
      }
    };
    return xr({
      htmlFontSize: c,
      pxToRem: g,
      fontFamily: n,
      fontSize: r,
      fontWeightLight: o,
      fontWeightRegular: i,
      fontWeightMedium: a,
      fontWeightBold: s,
      ...b
    }, p, {
      clone: !1
      // No need to clone deep
    });
  }
  const OZ = 0.2, MZ = 0.14, NZ = 0.12;
  function Sn(...e) {
    return [`${e[0]}px ${e[1]}px ${e[2]}px ${e[3]}px rgba(0,0,0,${OZ})`, `${e[4]}px ${e[5]}px ${e[6]}px ${e[7]}px rgba(0,0,0,${MZ})`, `${e[8]}px ${e[9]}px ${e[10]}px ${e[11]}px rgba(0,0,0,${NZ})`].join(",");
  }
  const PZ = ["none", Sn(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), Sn(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), Sn(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), Sn(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), Sn(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), Sn(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), Sn(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), Sn(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), Sn(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), Sn(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), Sn(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), Sn(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), Sn(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), Sn(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), Sn(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), Sn(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), Sn(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), Sn(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), Sn(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), Sn(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), Sn(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), Sn(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), Sn(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), Sn(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], IZ = {
    // This is the most common easing curve.
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    // Objects enter the screen at full velocity from off-screen and
    // slowly decelerate to a resting point.
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    // Objects leave the screen at full velocity. They do not decelerate when off-screen.
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    // The sharp curve is used by objects that may return to the screen at any time.
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
  }, $Z = {
    shortest: 150,
    shorter: 200,
    short: 250,
    // most basic recommended timing
    standard: 300,
    // this is to be used in complex animations
    complex: 375,
    // recommended when something is entering screen
    enteringScreen: 225,
    // recommended when something is leaving screen
    leavingScreen: 195
  };
  function c2(e) {
    return `${Math.round(e)}ms`;
  }
  function jZ(e) {
    if (!e)
      return 0;
    const t = e / 36;
    return Math.min(Math.round((4 + 15 * t ** 0.25 + t / 5) * 10), 3e3);
  }
  function DZ(e) {
    const t = {
      ...IZ,
      ...e.easing
    }, n = {
      ...$Z,
      ...e.duration
    };
    return {
      getAutoHeightDuration: jZ,
      create: (o = ["all"], i = {}) => {
        const {
          duration: a = n.standard,
          easing: s = t.easeInOut,
          delay: c = 0,
          ...u
        } = i;
        return (Array.isArray(o) ? o : [o]).map((d) => `${d} ${typeof a == "string" ? a : c2(a)} ${s} ${typeof c == "string" ? c : c2(c)}`).join(",");
      },
      ...e,
      easing: t,
      duration: n
    };
  }
  const FZ = {
    mobileStepper: 1e3,
    fab: 1050,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500
  };
  function LZ(e) {
    return Ri(e) || typeof e > "u" || typeof e == "string" || typeof e == "boolean" || typeof e == "number" || Array.isArray(e);
  }
  function RF(e = {}) {
    const t = {
      ...e
    };
    function n(r) {
      const o = Object.entries(r);
      for (let i = 0; i < o.length; i++) {
        const [a, s] = o[i];
        !LZ(s) || a.startsWith("unstable_") ? delete r[a] : Ri(s) && (r[a] = {
          ...s
        }, n(r[a]));
      }
    }
    return n(t), `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(t, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
  }
  function u2(e) {
    return typeof e == "number" ? `${(e * 100).toFixed(0)}%` : `calc((${e}) * 100%)`;
  }
  const zZ = (e) => {
    if (!Number.isNaN(+e))
      return +e;
    const t = e.match(/\d*\.?\d+/g);
    if (!t)
      return 0;
    let n = 0;
    for (let r = 0; r < t.length; r += 1)
      n += +t[r];
    return n;
  };
  function BZ(e) {
    Object.assign(e, {
      alpha(t, n) {
        const r = this || e;
        return r.colorSpace ? `oklch(from ${t} l c h / ${typeof n == "string" ? `calc(${n})` : n})` : r.vars ? `rgba(${t.replace(/var\(--([^,\s)]+)(?:,[^)]+)?\)+/g, "var(--$1Channel)")} / ${typeof n == "string" ? `calc(${n})` : n})` : Jv(t, zZ(n));
      },
      lighten(t, n) {
        const r = this || e;
        return r.colorSpace ? `color-mix(in ${r.colorSpace}, ${t}, #fff ${u2(n)})` : pb(t, n);
      },
      darken(t, n) {
        const r = this || e;
        return r.colorSpace ? `color-mix(in ${r.colorSpace}, ${t}, #000 ${u2(n)})` : db(t, n);
      }
    });
  }
  function wE(e = {}, ...t) {
    const {
      breakpoints: n,
      mixins: r = {},
      spacing: o,
      palette: i = {},
      transitions: a = {},
      typography: s = {},
      shape: c,
      colorSpace: u,
      ...d
    } = e;
    if (e.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
    // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
    e.generateThemeVars === void 0)
      throw new Error(Va(20));
    const p = kk({
      ...i,
      colorSpace: u
    }), m = ub(e);
    let g = xr(m, {
      mixins: AZ(m.breakpoints, r),
      palette: p,
      // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
      shadows: PZ.slice(),
      typography: AF(p, s),
      transitions: DZ(a),
      zIndex: {
        ...FZ
      }
    });
    return g = xr(g, d), g = t.reduce((y, b) => xr(y, b), g), g.unstable_sxConfig = {
      ...Ph,
      ...d?.unstable_sxConfig
    }, g.unstable_sx = function(b) {
      return nl({
        sx: b,
        theme: this
      });
    }, g.toRuntimeSource = RF, BZ(g), g;
  }
  function SE(e) {
    let t;
    return e < 1 ? t = 5.11916 * e ** 2 : t = 4.5 * Math.log(e + 1) + 2, Math.round(t * 10) / 1e3;
  }
  const UZ = [...Array(25)].map((e, t) => {
    if (t === 0)
      return "none";
    const n = SE(t);
    return `linear-gradient(rgba(255 255 255 / ${n}), rgba(255 255 255 / ${n}))`;
  });
  function OF(e) {
    return {
      inputPlaceholder: e === "dark" ? 0.5 : 0.42,
      inputUnderline: e === "dark" ? 0.7 : 0.42,
      switchTrackDisabled: e === "dark" ? 0.2 : 0.12,
      switchTrack: e === "dark" ? 0.3 : 0.38
    };
  }
  function MF(e) {
    return e === "dark" ? UZ : [];
  }
  function VZ(e) {
    const {
      palette: t = {
        mode: "light"
      },
      // need to cast to avoid module augmentation test
      opacity: n,
      overlays: r,
      colorSpace: o,
      ...i
    } = e, a = kk({
      ...t,
      colorSpace: o
    });
    return {
      palette: a,
      opacity: {
        ...OF(a.mode),
        ...n
      },
      overlays: r || MF(a.mode),
      ...i
    };
  }
  function HZ(e) {
    return !!e[0].match(/(cssVarPrefix|colorSchemeSelector|modularCssLayers|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!e[0].match(/sxConfig$/) || // ends with sxConfig
    e[0] === "palette" && !!e[1]?.match(/(mode|contrastThreshold|tonalOffset)/);
  }
  const qZ = (e) => [...[...Array(25)].map((t, n) => `--${e ? `${e}-` : ""}overlays-${n}`), `--${e ? `${e}-` : ""}palette-AppBar-darkBg`, `--${e ? `${e}-` : ""}palette-AppBar-darkColor`], WZ = (e) => (t, n) => {
    const r = e.rootSelector || ":root", o = e.colorSchemeSelector;
    let i = o;
    if (o === "class" && (i = ".%s"), o === "data" && (i = "[data-%s]"), o?.startsWith("data-") && !o.includes("%s") && (i = `[${o}="%s"]`), e.defaultColorScheme === t) {
      if (t === "dark") {
        const a = {};
        return qZ(e.cssVarPrefix).forEach((s) => {
          a[s] = n[s], delete n[s];
        }), i === "media" ? {
          [r]: n,
          "@media (prefers-color-scheme: dark)": {
            [r]: a
          }
        } : i ? {
          [i.replace("%s", t)]: a,
          [`${r}, ${i.replace("%s", t)}`]: n
        } : {
          [r]: {
            ...n,
            ...a
          }
        };
      }
      if (i && i !== "media")
        return `${r}, ${i.replace("%s", String(t))}`;
    } else if (t) {
      if (i === "media")
        return {
          [`@media (prefers-color-scheme: ${String(t)})`]: {
            [r]: n
          }
        };
      if (i)
        return i.replace("%s", String(t));
    }
    return r;
  };
  function GZ(e, t) {
    t.forEach((n) => {
      e[n] || (e[n] = {});
    });
  }
  function be(e, t, n) {
    !e[t] && n && (e[t] = n);
  }
  function hp(e) {
    return typeof e != "string" || !e.startsWith("hsl") ? e : vF(e);
  }
  function Ca(e, t) {
    `${t}Channel` in e || (e[`${t}Channel`] = pp(hp(e[t])));
  }
  function KZ(e) {
    return typeof e == "number" ? `${e}px` : typeof e == "string" || typeof e == "function" || Array.isArray(e) ? e : "8px";
  }
  const gi = (e) => {
    try {
      return e();
    } catch {
    }
  }, YZ = (e = "mui") => QX(e);
  function vS(e, t, n, r, o) {
    if (!n)
      return;
    n = n === !0 ? {} : n;
    const i = o === "dark" ? "dark" : "light";
    if (!r) {
      t[o] = VZ({
        ...n,
        palette: {
          mode: i,
          ...n?.palette
        },
        colorSpace: e
      });
      return;
    }
    const {
      palette: a,
      ...s
    } = wE({
      ...r,
      palette: {
        mode: i,
        ...n?.palette
      },
      colorSpace: e
    });
    return t[o] = {
      ...n,
      palette: a,
      opacity: {
        ...OF(i),
        ...n?.opacity
      },
      overlays: n?.overlays || MF(i)
    }, s;
  }
  function XZ(e = {}, ...t) {
    const {
      colorSchemes: n = {
        light: !0
      },
      defaultColorScheme: r,
      disableCssColorScheme: o = !1,
      cssVarPrefix: i = "mui",
      nativeColor: a = !1,
      shouldSkipGeneratingVar: s = HZ,
      colorSchemeSelector: c = n.light && n.dark ? "media" : void 0,
      rootSelector: u = ":root",
      ...d
    } = e, p = Object.keys(n)[0], m = r || (n.light && p !== "light" ? "light" : p), g = YZ(i), {
      [m]: y,
      light: b,
      dark: v,
      ...x
    } = n, E = {
      ...x
    };
    let _ = y;
    if ((m === "dark" && !("dark" in n) || m === "light" && !("light" in n)) && (_ = !0), !_)
      throw new Error(Va(21, m));
    let C;
    a && (C = "oklch");
    const k = vS(C, E, _, d, m);
    b && !E.light && vS(C, E, b, void 0, "light"), v && !E.dark && vS(C, E, v, void 0, "dark");
    let A = {
      defaultColorScheme: m,
      ...k,
      cssVarPrefix: i,
      colorSchemeSelector: c,
      rootSelector: u,
      getCssVar: g,
      colorSchemes: E,
      font: {
        ...TZ(k.typography),
        ...k.font
      },
      spacing: KZ(d.spacing)
    };
    Object.keys(A.colorSchemes).forEach((L) => {
      const N = A.colorSchemes[L].palette, U = (V) => {
        const F = V.split("-"), K = F[1], W = F[2];
        return g(V, N[K][W]);
      };
      N.mode === "light" && (be(N.common, "background", "#fff"), be(N.common, "onBackground", "#000")), N.mode === "dark" && (be(N.common, "background", "#000"), be(N.common, "onBackground", "#fff"));
      function j(V, F, K) {
        if (C) {
          let W;
          return V === Ll && (W = `transparent ${((1 - K) * 100).toFixed(0)}%`), V === Yt && (W = `#000 ${(K * 100).toFixed(0)}%`), V === Xt && (W = `#fff ${(K * 100).toFixed(0)}%`), `color-mix(in ${C}, ${F}, ${W})`;
        }
        return V(F, K);
      }
      if (GZ(N, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]), N.mode === "light") {
        be(N.Alert, "errorColor", j(Yt, N.error.light, 0.6)), be(N.Alert, "infoColor", j(Yt, N.info.light, 0.6)), be(N.Alert, "successColor", j(Yt, N.success.light, 0.6)), be(N.Alert, "warningColor", j(Yt, N.warning.light, 0.6)), be(N.Alert, "errorFilledBg", U("palette-error-main")), be(N.Alert, "infoFilledBg", U("palette-info-main")), be(N.Alert, "successFilledBg", U("palette-success-main")), be(N.Alert, "warningFilledBg", U("palette-warning-main")), be(N.Alert, "errorFilledColor", gi(() => N.getContrastText(N.error.main))), be(N.Alert, "infoFilledColor", gi(() => N.getContrastText(N.info.main))), be(N.Alert, "successFilledColor", gi(() => N.getContrastText(N.success.main))), be(N.Alert, "warningFilledColor", gi(() => N.getContrastText(N.warning.main))), be(N.Alert, "errorStandardBg", j(Xt, N.error.light, 0.9)), be(N.Alert, "infoStandardBg", j(Xt, N.info.light, 0.9)), be(N.Alert, "successStandardBg", j(Xt, N.success.light, 0.9)), be(N.Alert, "warningStandardBg", j(Xt, N.warning.light, 0.9)), be(N.Alert, "errorIconColor", U("palette-error-main")), be(N.Alert, "infoIconColor", U("palette-info-main")), be(N.Alert, "successIconColor", U("palette-success-main")), be(N.Alert, "warningIconColor", U("palette-warning-main")), be(N.AppBar, "defaultBg", U("palette-grey-100")), be(N.Avatar, "defaultBg", U("palette-grey-400")), be(N.Button, "inheritContainedBg", U("palette-grey-300")), be(N.Button, "inheritContainedHoverBg", U("palette-grey-A100")), be(N.Chip, "defaultBorder", U("palette-grey-400")), be(N.Chip, "defaultAvatarColor", U("palette-grey-700")), be(N.Chip, "defaultIconColor", U("palette-grey-700")), be(N.FilledInput, "bg", "rgba(0, 0, 0, 0.06)"), be(N.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)"), be(N.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)"), be(N.LinearProgress, "primaryBg", j(Xt, N.primary.main, 0.62)), be(N.LinearProgress, "secondaryBg", j(Xt, N.secondary.main, 0.62)), be(N.LinearProgress, "errorBg", j(Xt, N.error.main, 0.62)), be(N.LinearProgress, "infoBg", j(Xt, N.info.main, 0.62)), be(N.LinearProgress, "successBg", j(Xt, N.success.main, 0.62)), be(N.LinearProgress, "warningBg", j(Xt, N.warning.main, 0.62)), be(N.Skeleton, "bg", C ? j(Ll, N.text.primary, 0.11) : `rgba(${U("palette-text-primaryChannel")} / 0.11)`), be(N.Slider, "primaryTrack", j(Xt, N.primary.main, 0.62)), be(N.Slider, "secondaryTrack", j(Xt, N.secondary.main, 0.62)), be(N.Slider, "errorTrack", j(Xt, N.error.main, 0.62)), be(N.Slider, "infoTrack", j(Xt, N.info.main, 0.62)), be(N.Slider, "successTrack", j(Xt, N.success.main, 0.62)), be(N.Slider, "warningTrack", j(Xt, N.warning.main, 0.62));
        const V = C ? j(Yt, N.background.default, 0.6825) : Kg(N.background.default, 0.8);
        be(N.SnackbarContent, "bg", V), be(N.SnackbarContent, "color", gi(() => C ? xE.text.primary : N.getContrastText(V))), be(N.SpeedDialAction, "fabHoverBg", Kg(N.background.paper, 0.15)), be(N.StepConnector, "border", U("palette-grey-400")), be(N.StepContent, "border", U("palette-grey-400")), be(N.Switch, "defaultColor", U("palette-common-white")), be(N.Switch, "defaultDisabledColor", U("palette-grey-100")), be(N.Switch, "primaryDisabledColor", j(Xt, N.primary.main, 0.62)), be(N.Switch, "secondaryDisabledColor", j(Xt, N.secondary.main, 0.62)), be(N.Switch, "errorDisabledColor", j(Xt, N.error.main, 0.62)), be(N.Switch, "infoDisabledColor", j(Xt, N.info.main, 0.62)), be(N.Switch, "successDisabledColor", j(Xt, N.success.main, 0.62)), be(N.Switch, "warningDisabledColor", j(Xt, N.warning.main, 0.62)), be(N.TableCell, "border", j(Xt, j(Ll, N.divider, 1), 0.88)), be(N.Tooltip, "bg", j(Ll, N.grey[700], 0.92));
      }
      if (N.mode === "dark") {
        be(N.Alert, "errorColor", j(Xt, N.error.light, 0.6)), be(N.Alert, "infoColor", j(Xt, N.info.light, 0.6)), be(N.Alert, "successColor", j(Xt, N.success.light, 0.6)), be(N.Alert, "warningColor", j(Xt, N.warning.light, 0.6)), be(N.Alert, "errorFilledBg", U("palette-error-dark")), be(N.Alert, "infoFilledBg", U("palette-info-dark")), be(N.Alert, "successFilledBg", U("palette-success-dark")), be(N.Alert, "warningFilledBg", U("palette-warning-dark")), be(N.Alert, "errorFilledColor", gi(() => N.getContrastText(N.error.dark))), be(N.Alert, "infoFilledColor", gi(() => N.getContrastText(N.info.dark))), be(N.Alert, "successFilledColor", gi(() => N.getContrastText(N.success.dark))), be(N.Alert, "warningFilledColor", gi(() => N.getContrastText(N.warning.dark))), be(N.Alert, "errorStandardBg", j(Yt, N.error.light, 0.9)), be(N.Alert, "infoStandardBg", j(Yt, N.info.light, 0.9)), be(N.Alert, "successStandardBg", j(Yt, N.success.light, 0.9)), be(N.Alert, "warningStandardBg", j(Yt, N.warning.light, 0.9)), be(N.Alert, "errorIconColor", U("palette-error-main")), be(N.Alert, "infoIconColor", U("palette-info-main")), be(N.Alert, "successIconColor", U("palette-success-main")), be(N.Alert, "warningIconColor", U("palette-warning-main")), be(N.AppBar, "defaultBg", U("palette-grey-900")), be(N.AppBar, "darkBg", U("palette-background-paper")), be(N.AppBar, "darkColor", U("palette-text-primary")), be(N.Avatar, "defaultBg", U("palette-grey-600")), be(N.Button, "inheritContainedBg", U("palette-grey-800")), be(N.Button, "inheritContainedHoverBg", U("palette-grey-700")), be(N.Chip, "defaultBorder", U("palette-grey-700")), be(N.Chip, "defaultAvatarColor", U("palette-grey-300")), be(N.Chip, "defaultIconColor", U("palette-grey-300")), be(N.FilledInput, "bg", "rgba(255, 255, 255, 0.09)"), be(N.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)"), be(N.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)"), be(N.LinearProgress, "primaryBg", j(Yt, N.primary.main, 0.5)), be(N.LinearProgress, "secondaryBg", j(Yt, N.secondary.main, 0.5)), be(N.LinearProgress, "errorBg", j(Yt, N.error.main, 0.5)), be(N.LinearProgress, "infoBg", j(Yt, N.info.main, 0.5)), be(N.LinearProgress, "successBg", j(Yt, N.success.main, 0.5)), be(N.LinearProgress, "warningBg", j(Yt, N.warning.main, 0.5)), be(N.Skeleton, "bg", C ? j(Ll, N.text.primary, 0.13) : `rgba(${U("palette-text-primaryChannel")} / 0.13)`), be(N.Slider, "primaryTrack", j(Yt, N.primary.main, 0.5)), be(N.Slider, "secondaryTrack", j(Yt, N.secondary.main, 0.5)), be(N.Slider, "errorTrack", j(Yt, N.error.main, 0.5)), be(N.Slider, "infoTrack", j(Yt, N.info.main, 0.5)), be(N.Slider, "successTrack", j(Yt, N.success.main, 0.5)), be(N.Slider, "warningTrack", j(Yt, N.warning.main, 0.5));
        const V = C ? j(Xt, N.background.default, 0.985) : Kg(N.background.default, 0.98);
        be(N.SnackbarContent, "bg", V), be(N.SnackbarContent, "color", gi(() => C ? kF.text.primary : N.getContrastText(V))), be(N.SpeedDialAction, "fabHoverBg", Kg(N.background.paper, 0.15)), be(N.StepConnector, "border", U("palette-grey-600")), be(N.StepContent, "border", U("palette-grey-600")), be(N.Switch, "defaultColor", U("palette-grey-300")), be(N.Switch, "defaultDisabledColor", U("palette-grey-600")), be(N.Switch, "primaryDisabledColor", j(Yt, N.primary.main, 0.55)), be(N.Switch, "secondaryDisabledColor", j(Yt, N.secondary.main, 0.55)), be(N.Switch, "errorDisabledColor", j(Yt, N.error.main, 0.55)), be(N.Switch, "infoDisabledColor", j(Yt, N.info.main, 0.55)), be(N.Switch, "successDisabledColor", j(Yt, N.success.main, 0.55)), be(N.Switch, "warningDisabledColor", j(Yt, N.warning.main, 0.55)), be(N.TableCell, "border", j(Yt, j(Ll, N.divider, 1), 0.68)), be(N.Tooltip, "bg", j(Ll, N.grey[700], 0.92));
      }
      Ca(N.background, "default"), Ca(N.background, "paper"), Ca(N.common, "background"), Ca(N.common, "onBackground"), Ca(N, "divider"), Object.keys(N).forEach((V) => {
        const F = N[V];
        V !== "tonalOffset" && F && typeof F == "object" && (F.main && be(N[V], "mainChannel", pp(hp(F.main))), F.light && be(N[V], "lightChannel", pp(hp(F.light))), F.dark && be(N[V], "darkChannel", pp(hp(F.dark))), F.contrastText && be(N[V], "contrastTextChannel", pp(hp(F.contrastText))), V === "text" && (Ca(N[V], "primary"), Ca(N[V], "secondary")), V === "action" && (F.active && Ca(N[V], "active"), F.selected && Ca(N[V], "selected")));
      });
    }), A = t.reduce((L, N) => xr(L, N), A);
    const O = {
      prefix: i,
      disableCssColorScheme: o,
      shouldSkipGeneratingVar: s,
      getSelector: WZ(A),
      enableContrastVars: a
    }, {
      vars: P,
      generateThemeVars: I,
      generateStyleSheets: $
    } = tZ(A, O);
    return A.vars = P, Object.entries(A.colorSchemes[A.defaultColorScheme]).forEach(([L, N]) => {
      A[L] = N;
    }), A.generateThemeVars = I, A.generateStyleSheets = $, A.generateSpacing = function() {
      return dF(d.spacing, fk(this));
    }, A.getColorSchemeSelector = nZ(c), A.spacing = A.generateSpacing(), A.shouldSkipGeneratingVar = s, A.unstable_sxConfig = {
      ...Ph,
      ...d?.unstable_sxConfig
    }, A.unstable_sx = function(N) {
      return nl({
        sx: N,
        theme: this
      });
    }, A.toRuntimeSource = RF, A;
  }
  function f2(e, t, n) {
    e.colorSchemes && n && (e.colorSchemes[t] = {
      ...n !== !0 && n,
      palette: kk({
        ...n === !0 ? {} : n.palette,
        mode: t
      })
      // cast type to skip module augmentation test
    });
  }
  function mb(e = {}, ...t) {
    const {
      palette: n,
      cssVariables: r = !1,
      colorSchemes: o = n ? void 0 : {
        light: !0
      },
      defaultColorScheme: i = n?.mode,
      ...a
    } = e, s = i || "light", c = o?.[s], u = {
      ...o,
      ...n ? {
        [s]: {
          ...typeof c != "boolean" && c,
          palette: n
        }
      } : void 0
    };
    if (r === !1) {
      if (!("colorSchemes" in e))
        return wE(e, ...t);
      let d = n;
      "palette" in e || u[s] && (u[s] !== !0 ? d = u[s].palette : s === "dark" && (d = {
        mode: "dark"
      }));
      const p = wE({
        ...e,
        palette: d
      }, ...t);
      return p.defaultColorScheme = s, p.colorSchemes = u, p.palette.mode === "light" && (p.colorSchemes.light = {
        ...u.light !== !0 && u.light,
        palette: p.palette
      }, f2(p, "dark", u.dark)), p.palette.mode === "dark" && (p.colorSchemes.dark = {
        ...u.dark !== !0 && u.dark,
        palette: p.palette
      }, f2(p, "light", u.light)), p;
    }
    return !n && !("light" in u) && s === "light" && (u.light = !0), XZ({
      ...a,
      colorSchemes: u,
      defaultColorScheme: s,
      ...typeof r != "boolean" && r
    }, ...t);
  }
  const Tk = mb(), zi = "$$material";
  function gb() {
    const e = Fh(Tk);
    return e[zi] || e;
  }
  function ZZ(e) {
    return /* @__PURE__ */ S.jsx(pF, {
      ...e,
      defaultTheme: Tk,
      themeId: zi
    });
  }
  function yb(e) {
    return e !== "ownerState" && e !== "theme" && e !== "sx" && e !== "as";
  }
  const Sr = (e) => yb(e) && e !== "classes", Re = yF({
    themeId: zi,
    defaultTheme: Tk,
    rootShouldForwardProp: Sr
  });
  function QZ(e) {
    return function(n) {
      return (
        // Pigment CSS `globalCss` support callback with theme inside an object but `GlobalStyles` support theme as a callback value.
        /* @__PURE__ */ S.jsx(ZZ, {
          styles: typeof e == "function" ? (r) => e({
            theme: r,
            ...n
          }) : e
        })
      );
    };
  }
  function JZ() {
    return pk;
  }
  const st = VX;
  function ut(e) {
    return LX(e);
  }
  function eQ(e) {
    return ot("MuiTable", e);
  }
  nt("MuiTable", ["root", "stickyHeader"]);
  const tQ = (e) => {
    const {
      classes: t,
      stickyHeader: n
    } = e;
    return rt({
      root: ["root", n && "stickyHeader"]
    }, eQ, t);
  }, nQ = Re("table", {
    name: "MuiTable",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.stickyHeader && t.stickyHeader];
    }
  })(st(({
    theme: e
  }) => ({
    display: "table",
    width: "100%",
    borderCollapse: "collapse",
    borderSpacing: 0,
    "& caption": {
      ...e.typography.body2,
      padding: e.spacing(2),
      color: (e.vars || e).palette.text.secondary,
      textAlign: "left",
      captionSide: "bottom"
    },
    variants: [{
      props: ({
        ownerState: t
      }) => t.stickyHeader,
      style: {
        borderCollapse: "separate"
      }
    }]
  }))), d2 = "table", rQ = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiTable"
    }), {
      className: o,
      component: i = d2,
      padding: a = "normal",
      size: s = "medium",
      stickyHeader: c = !1,
      ...u
    } = r, d = {
      ...r,
      component: i,
      padding: a,
      size: s,
      stickyHeader: c
    }, p = tQ(d), m = T.useMemo(() => ({
      padding: a,
      size: s,
      stickyHeader: c
    }), [a, s, c]);
    return /* @__PURE__ */ S.jsx(G4.Provider, {
      value: m,
      children: /* @__PURE__ */ S.jsx(nQ, {
        as: i,
        role: i === d2 ? null : "table",
        ref: n,
        className: $e(p.root, o),
        ownerState: d,
        ...u
      })
    });
  }), vb = /* @__PURE__ */ T.createContext();
  function oQ(e) {
    return ot("MuiTableBody", e);
  }
  nt("MuiTableBody", ["root"]);
  const iQ = (e) => {
    const {
      classes: t
    } = e;
    return rt({
      root: ["root"]
    }, oQ, t);
  }, aQ = Re("tbody", {
    name: "MuiTableBody",
    slot: "Root"
  })({
    display: "table-row-group"
  }), sQ = {
    variant: "body"
  }, p2 = "tbody", lQ = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiTableBody"
    }), {
      className: o,
      component: i = p2,
      ...a
    } = r, s = {
      ...r,
      component: i
    }, c = iQ(s);
    return /* @__PURE__ */ S.jsx(vb.Provider, {
      value: sQ,
      children: /* @__PURE__ */ S.jsx(aQ, {
        className: $e(c.root, o),
        as: i,
        ref: n,
        role: i === p2 ? null : "rowgroup",
        ownerState: s,
        ...a
      })
    });
  });
  function cQ(e) {
    return ot("MuiTableCell", e);
  }
  const uQ = nt("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]), fQ = (e) => {
    const {
      classes: t,
      variant: n,
      align: r,
      padding: o,
      size: i,
      stickyHeader: a
    } = e, s = {
      root: ["root", n, a && "stickyHeader", r !== "inherit" && `align${Ie(r)}`, o !== "normal" && `padding${Ie(o)}`, `size${Ie(i)}`]
    };
    return rt(s, cQ, t);
  }, dQ = Re("td", {
    name: "MuiTableCell",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[n.variant], t[`size${Ie(n.size)}`], n.padding !== "normal" && t[`padding${Ie(n.padding)}`], n.align !== "inherit" && t[`align${Ie(n.align)}`], n.stickyHeader && t.stickyHeader];
    }
  })(st(({
    theme: e
  }) => ({
    ...e.typography.body2,
    display: "table-cell",
    verticalAlign: "inherit",
    // Workaround for a rendering bug with spanned columns in Chrome 62.0.
    // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
    borderBottom: e.vars ? `1px solid ${e.vars.palette.TableCell.border}` : `1px solid
    ${e.palette.mode === "light" ? e.lighten(e.alpha(e.palette.divider, 1), 0.88) : e.darken(e.alpha(e.palette.divider, 1), 0.68)}`,
    textAlign: "left",
    padding: 16,
    variants: [{
      props: {
        variant: "head"
      },
      style: {
        color: (e.vars || e).palette.text.primary,
        lineHeight: e.typography.pxToRem(24),
        fontWeight: e.typography.fontWeightMedium
      }
    }, {
      props: {
        variant: "body"
      },
      style: {
        color: (e.vars || e).palette.text.primary
      }
    }, {
      props: {
        variant: "footer"
      },
      style: {
        color: (e.vars || e).palette.text.secondary,
        lineHeight: e.typography.pxToRem(21),
        fontSize: e.typography.pxToRem(12)
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        padding: "6px 16px",
        [`&.${uQ.paddingCheckbox}`]: {
          width: 24,
          // prevent the checkbox column from growing
          padding: "0 12px 0 16px",
          "& > *": {
            padding: 0
          }
        }
      }
    }, {
      props: {
        padding: "checkbox"
      },
      style: {
        width: 48,
        // prevent the checkbox column from growing
        padding: "0 0 0 4px"
      }
    }, {
      props: {
        padding: "none"
      },
      style: {
        padding: 0
      }
    }, {
      props: {
        align: "left"
      },
      style: {
        textAlign: "left"
      }
    }, {
      props: {
        align: "center"
      },
      style: {
        textAlign: "center"
      }
    }, {
      props: {
        align: "right"
      },
      style: {
        textAlign: "right",
        flexDirection: "row-reverse"
      }
    }, {
      props: {
        align: "justify"
      },
      style: {
        textAlign: "justify"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.stickyHeader,
      style: {
        position: "sticky",
        top: 0,
        zIndex: 2,
        backgroundColor: (e.vars || e).palette.background.default
      }
    }]
  }))), Yg = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiTableCell"
    }), {
      align: o = "inherit",
      className: i,
      component: a,
      padding: s,
      scope: c,
      size: u,
      sortDirection: d,
      variant: p,
      ...m
    } = r, g = T.useContext(G4), y = T.useContext(vb), b = y && y.variant === "head";
    let v;
    a ? v = a : v = b ? "th" : "td";
    let x = c;
    v === "td" ? x = void 0 : !x && b && (x = "col");
    const E = p || y && y.variant, _ = {
      ...r,
      align: o,
      component: v,
      padding: s || (g && g.padding ? g.padding : "normal"),
      size: u || (g && g.size ? g.size : "medium"),
      sortDirection: d,
      stickyHeader: E === "head" && g && g.stickyHeader,
      variant: E
    }, C = fQ(_);
    let k = null;
    return d && (k = d === "asc" ? "ascending" : "descending"), /* @__PURE__ */ S.jsx(dQ, {
      as: v,
      ref: n,
      className: $e(C.root, i),
      "aria-sort": k,
      scope: x,
      ownerState: _,
      ...m
    });
  });
  function pQ(e) {
    return ot("MuiTableContainer", e);
  }
  nt("MuiTableContainer", ["root"]);
  const hQ = (e) => {
    const {
      classes: t
    } = e;
    return rt({
      root: ["root"]
    }, pQ, t);
  }, mQ = Re("div", {
    name: "MuiTableContainer",
    slot: "Root"
  })({
    width: "100%",
    overflowX: "auto"
  }), gQ = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiTableContainer"
    }), {
      className: o,
      component: i = "div",
      ...a
    } = r, s = {
      ...r,
      component: i
    }, c = hQ(s);
    return /* @__PURE__ */ S.jsx(mQ, {
      ref: n,
      as: i,
      className: $e(c.root, o),
      ownerState: s,
      ...a
    });
  });
  function yQ(e) {
    return ot("MuiTableHead", e);
  }
  nt("MuiTableHead", ["root"]);
  const vQ = (e) => {
    const {
      classes: t
    } = e;
    return rt({
      root: ["root"]
    }, yQ, t);
  }, bQ = Re("thead", {
    name: "MuiTableHead",
    slot: "Root"
  })({
    display: "table-header-group"
  }), xQ = {
    variant: "head"
  }, h2 = "thead", wQ = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiTableHead"
    }), {
      className: o,
      component: i = h2,
      ...a
    } = r, s = {
      ...r,
      component: i
    }, c = vQ(s);
    return /* @__PURE__ */ S.jsx(vb.Provider, {
      value: xQ,
      children: /* @__PURE__ */ S.jsx(bQ, {
        as: i,
        className: $e(c.root, o),
        ref: n,
        role: i === h2 ? null : "rowgroup",
        ownerState: s,
        ...a
      })
    });
  });
  function SQ(e) {
    return ot("MuiTableRow", e);
  }
  const m2 = nt("MuiTableRow", ["root", "selected", "hover", "head", "footer"]), _Q = (e) => {
    const {
      classes: t,
      selected: n,
      hover: r,
      head: o,
      footer: i
    } = e;
    return rt({
      root: ["root", n && "selected", r && "hover", o && "head", i && "footer"]
    }, SQ, t);
  }, EQ = Re("tr", {
    name: "MuiTableRow",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.head && t.head, n.footer && t.footer];
    }
  })(st(({
    theme: e
  }) => ({
    color: "inherit",
    display: "table-row",
    verticalAlign: "middle",
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    [`&.${m2.hover}:hover`]: {
      backgroundColor: (e.vars || e).palette.action.hover
    },
    [`&.${m2.selected}`]: {
      backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity),
      "&:hover": {
        backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.hoverOpacity}`)
      }
    }
  }))), g2 = "tr", Xg = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiTableRow"
    }), {
      className: o,
      component: i = g2,
      hover: a = !1,
      selected: s = !1,
      ...c
    } = r, u = T.useContext(vb), d = {
      ...r,
      component: i,
      hover: a,
      selected: s,
      head: u && u.variant === "head",
      footer: u && u.variant === "footer"
    }, p = _Q(d);
    return /* @__PURE__ */ S.jsx(EQ, {
      as: i,
      ref: n,
      className: $e(p.root, o),
      role: i === g2 ? null : "row",
      ownerState: d,
      ...c
    });
  });
  function t0(e) {
    try {
      return e.matches(":focus-visible");
    } catch {
    }
    return !1;
  }
  function er(...e) {
    const t = T.useRef(void 0), n = T.useCallback((r) => {
      const o = e.map((i) => {
        if (i == null)
          return null;
        if (typeof i == "function") {
          const a = i, s = a(r);
          return typeof s == "function" ? s : () => {
            a(null);
          };
        }
        return i.current = r, () => {
          i.current = null;
        };
      });
      return () => {
        o.forEach((i) => i?.());
      };
    }, e);
    return T.useMemo(() => e.every((r) => r == null) ? null : (r) => {
      t.current && (t.current(), t.current = void 0), r != null && (t.current = n(r));
    }, e);
  }
  function Bi(e) {
    const t = T.useRef(e);
    return ei(() => {
      t.current = e;
    }), T.useRef((...n) => (
      // @ts-expect-error hide `this`
      (0, t.current)(...n)
    )).current;
  }
  const y2 = {};
  function NF(e, t) {
    const n = T.useRef(y2);
    return n.current === y2 && (n.current = e(t)), n;
  }
  class n0 {
    constructor() {
      Kn(this, "mountEffect", () => {
        this.shouldMount && !this.didMount && this.ref.current !== null && (this.didMount = !0, this.mounted.resolve());
      });
      this.ref = {
        current: null
      }, this.mounted = null, this.didMount = !1, this.shouldMount = !1, this.setShouldMount = null;
    }
    /** React ref to the ripple instance */
    /** If the ripple component should be mounted */
    /** Promise that resolves when the ripple component is mounted */
    /** If the ripple component has been mounted */
    /** React state hook setter */
    static create() {
      return new n0();
    }
    static use() {
      const t = NF(n0.create).current, [n, r] = T.useState(!1);
      return t.shouldMount = n, t.setShouldMount = r, T.useEffect(t.mountEffect, [n]), t;
    }
    mount() {
      return this.mounted || (this.mounted = kQ(), this.shouldMount = !0, this.setShouldMount(this.shouldMount)), this.mounted;
    }
    /* Ripple API */
    start(...t) {
      this.mount().then(() => this.ref.current?.start(...t));
    }
    stop(...t) {
      this.mount().then(() => this.ref.current?.stop(...t));
    }
    pulsate(...t) {
      this.mount().then(() => this.ref.current?.pulsate(...t));
    }
  }
  function CQ() {
    return n0.use();
  }
  function kQ() {
    let e, t;
    const n = new Promise((r, o) => {
      e = r, t = o;
    });
    return n.resolve = e, n.reject = t, n;
  }
  function bb(e, t) {
    if (e == null) return {};
    var n = {};
    for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) !== -1) continue;
      n[r] = e[r];
    }
    return n;
  }
  function r0(e, t) {
    return r0 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, r) {
      return n.__proto__ = r, n;
    }, r0(e, t);
  }
  function Ak(e, t) {
    e.prototype = Object.create(t.prototype), e.prototype.constructor = e, r0(e, t);
  }
  const v2 = {
    disabled: !1
  }, o0 = On.createContext(null);
  var TQ = function(t) {
    return t.scrollTop;
  }, mp = "unmounted", Kl = "exited", Yl = "entering", Bu = "entered", _E = "exiting", Zi = /* @__PURE__ */ (function(e) {
    Ak(t, e);
    function t(r, o) {
      var i;
      i = e.call(this, r, o) || this;
      var a = o, s = a && !a.isMounting ? r.enter : r.appear, c;
      return i.appearStatus = null, r.in ? s ? (c = Kl, i.appearStatus = Yl) : c = Bu : r.unmountOnExit || r.mountOnEnter ? c = mp : c = Kl, i.state = {
        status: c
      }, i.nextCallback = null, i;
    }
    t.getDerivedStateFromProps = function(o, i) {
      var a = o.in;
      return a && i.status === mp ? {
        status: Kl
      } : null;
    };
    var n = t.prototype;
    return n.componentDidMount = function() {
      this.updateStatus(!0, this.appearStatus);
    }, n.componentDidUpdate = function(o) {
      var i = null;
      if (o !== this.props) {
        var a = this.state.status;
        this.props.in ? a !== Yl && a !== Bu && (i = Yl) : (a === Yl || a === Bu) && (i = _E);
      }
      this.updateStatus(!1, i);
    }, n.componentWillUnmount = function() {
      this.cancelNextCallback();
    }, n.getTimeouts = function() {
      var o = this.props.timeout, i, a, s;
      return i = a = s = o, o != null && typeof o != "number" && (i = o.exit, a = o.enter, s = o.appear !== void 0 ? o.appear : a), {
        exit: i,
        enter: a,
        appear: s
      };
    }, n.updateStatus = function(o, i) {
      if (o === void 0 && (o = !1), i !== null)
        if (this.cancelNextCallback(), i === Yl) {
          if (this.props.unmountOnExit || this.props.mountOnEnter) {
            var a = this.props.nodeRef ? this.props.nodeRef.current : dp.findDOMNode(this);
            a && TQ(a);
          }
          this.performEnter(o);
        } else
          this.performExit();
      else this.props.unmountOnExit && this.state.status === Kl && this.setState({
        status: mp
      });
    }, n.performEnter = function(o) {
      var i = this, a = this.props.enter, s = this.context ? this.context.isMounting : o, c = this.props.nodeRef ? [s] : [dp.findDOMNode(this), s], u = c[0], d = c[1], p = this.getTimeouts(), m = s ? p.appear : p.enter;
      if (!o && !a || v2.disabled) {
        this.safeSetState({
          status: Bu
        }, function() {
          i.props.onEntered(u);
        });
        return;
      }
      this.props.onEnter(u, d), this.safeSetState({
        status: Yl
      }, function() {
        i.props.onEntering(u, d), i.onTransitionEnd(m, function() {
          i.safeSetState({
            status: Bu
          }, function() {
            i.props.onEntered(u, d);
          });
        });
      });
    }, n.performExit = function() {
      var o = this, i = this.props.exit, a = this.getTimeouts(), s = this.props.nodeRef ? void 0 : dp.findDOMNode(this);
      if (!i || v2.disabled) {
        this.safeSetState({
          status: Kl
        }, function() {
          o.props.onExited(s);
        });
        return;
      }
      this.props.onExit(s), this.safeSetState({
        status: _E
      }, function() {
        o.props.onExiting(s), o.onTransitionEnd(a.exit, function() {
          o.safeSetState({
            status: Kl
          }, function() {
            o.props.onExited(s);
          });
        });
      });
    }, n.cancelNextCallback = function() {
      this.nextCallback !== null && (this.nextCallback.cancel(), this.nextCallback = null);
    }, n.safeSetState = function(o, i) {
      i = this.setNextCallback(i), this.setState(o, i);
    }, n.setNextCallback = function(o) {
      var i = this, a = !0;
      return this.nextCallback = function(s) {
        a && (a = !1, i.nextCallback = null, o(s));
      }, this.nextCallback.cancel = function() {
        a = !1;
      }, this.nextCallback;
    }, n.onTransitionEnd = function(o, i) {
      this.setNextCallback(i);
      var a = this.props.nodeRef ? this.props.nodeRef.current : dp.findDOMNode(this), s = o == null && !this.props.addEndListener;
      if (!a || s) {
        setTimeout(this.nextCallback, 0);
        return;
      }
      if (this.props.addEndListener) {
        var c = this.props.nodeRef ? [this.nextCallback] : [a, this.nextCallback], u = c[0], d = c[1];
        this.props.addEndListener(u, d);
      }
      o != null && setTimeout(this.nextCallback, o);
    }, n.render = function() {
      var o = this.state.status;
      if (o === mp)
        return null;
      var i = this.props, a = i.children;
      i.in, i.mountOnEnter, i.unmountOnExit, i.appear, i.enter, i.exit, i.timeout, i.addEndListener, i.onEnter, i.onEntering, i.onEntered, i.onExit, i.onExiting, i.onExited, i.nodeRef;
      var s = bb(i, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
      return (
        // allows for nested Transitions
        /* @__PURE__ */ On.createElement(o0.Provider, {
          value: null
        }, typeof a == "function" ? a(o, s) : On.cloneElement(On.Children.only(a), s))
      );
    }, t;
  })(On.Component);
  Zi.contextType = o0;
  Zi.propTypes = {};
  function Cu() {
  }
  Zi.defaultProps = {
    in: !1,
    mountOnEnter: !1,
    unmountOnExit: !1,
    appear: !1,
    enter: !0,
    exit: !0,
    onEnter: Cu,
    onEntering: Cu,
    onEntered: Cu,
    onExit: Cu,
    onExiting: Cu,
    onExited: Cu
  };
  Zi.UNMOUNTED = mp;
  Zi.EXITED = Kl;
  Zi.ENTERING = Yl;
  Zi.ENTERED = Bu;
  Zi.EXITING = _E;
  function PF(e) {
    if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  function Rk(e, t) {
    var n = function(i) {
      return t && T.isValidElement(i) ? t(i) : i;
    }, r = /* @__PURE__ */ Object.create(null);
    return e && T.Children.map(e, function(o) {
      return o;
    }).forEach(function(o) {
      r[o.key] = n(o);
    }), r;
  }
  function AQ(e, t) {
    e = e || {}, t = t || {};
    function n(d) {
      return d in t ? t[d] : e[d];
    }
    var r = /* @__PURE__ */ Object.create(null), o = [];
    for (var i in e)
      i in t ? o.length && (r[i] = o, o = []) : o.push(i);
    var a, s = {};
    for (var c in t) {
      if (r[c])
        for (a = 0; a < r[c].length; a++) {
          var u = r[c][a];
          s[r[c][a]] = n(u);
        }
      s[c] = n(c);
    }
    for (a = 0; a < o.length; a++)
      s[o[a]] = n(o[a]);
    return s;
  }
  function ec(e, t, n) {
    return n[t] != null ? n[t] : e.props[t];
  }
  function RQ(e, t) {
    return Rk(e.children, function(n) {
      return T.cloneElement(n, {
        onExited: t.bind(null, n),
        in: !0,
        appear: ec(n, "appear", e),
        enter: ec(n, "enter", e),
        exit: ec(n, "exit", e)
      });
    });
  }
  function OQ(e, t, n) {
    var r = Rk(e.children), o = AQ(t, r);
    return Object.keys(o).forEach(function(i) {
      var a = o[i];
      if (T.isValidElement(a)) {
        var s = i in t, c = i in r, u = t[i], d = T.isValidElement(u) && !u.props.in;
        c && (!s || d) ? o[i] = T.cloneElement(a, {
          onExited: n.bind(null, a),
          in: !0,
          exit: ec(a, "exit", e),
          enter: ec(a, "enter", e)
        }) : !c && s && !d ? o[i] = T.cloneElement(a, {
          in: !1
        }) : c && s && T.isValidElement(u) && (o[i] = T.cloneElement(a, {
          onExited: n.bind(null, a),
          in: u.props.in,
          exit: ec(a, "exit", e),
          enter: ec(a, "enter", e)
        }));
      }
    }), o;
  }
  var MQ = Object.values || function(e) {
    return Object.keys(e).map(function(t) {
      return e[t];
    });
  }, NQ = {
    component: "div",
    childFactory: function(t) {
      return t;
    }
  }, Ok = /* @__PURE__ */ (function(e) {
    Ak(t, e);
    function t(r, o) {
      var i;
      i = e.call(this, r, o) || this;
      var a = i.handleExited.bind(PF(i));
      return i.state = {
        contextValue: {
          isMounting: !0
        },
        handleExited: a,
        firstRender: !0
      }, i;
    }
    var n = t.prototype;
    return n.componentDidMount = function() {
      this.mounted = !0, this.setState({
        contextValue: {
          isMounting: !1
        }
      });
    }, n.componentWillUnmount = function() {
      this.mounted = !1;
    }, t.getDerivedStateFromProps = function(o, i) {
      var a = i.children, s = i.handleExited, c = i.firstRender;
      return {
        children: c ? RQ(o, s) : OQ(o, a, s),
        firstRender: !1
      };
    }, n.handleExited = function(o, i) {
      var a = Rk(this.props.children);
      o.key in a || (o.props.onExited && o.props.onExited(i), this.mounted && this.setState(function(s) {
        var c = Ke({}, s.children);
        return delete c[o.key], {
          children: c
        };
      }));
    }, n.render = function() {
      var o = this.props, i = o.component, a = o.childFactory, s = bb(o, ["component", "childFactory"]), c = this.state.contextValue, u = MQ(this.state.children).map(a);
      return delete s.appear, delete s.enter, delete s.exit, i === null ? /* @__PURE__ */ On.createElement(o0.Provider, {
        value: c
      }, u) : /* @__PURE__ */ On.createElement(o0.Provider, {
        value: c
      }, /* @__PURE__ */ On.createElement(i, s, u));
    }, t;
  })(On.Component);
  Ok.propTypes = {};
  Ok.defaultProps = NQ;
  const PQ = [];
  function IQ(e) {
    T.useEffect(e, PQ);
  }
  class Mk {
    constructor() {
      Kn(this, "currentId", null);
      Kn(this, "clear", () => {
        this.currentId !== null && (clearTimeout(this.currentId), this.currentId = null);
      });
      Kn(this, "disposeEffect", () => this.clear);
    }
    static create() {
      return new Mk();
    }
    /**
     * Executes `fn` after `delay`, clearing any previously scheduled call.
     */
    start(t, n) {
      this.clear(), this.currentId = setTimeout(() => {
        this.currentId = null, n();
      }, t);
    }
  }
  function IF() {
    const e = NF(Mk.create).current;
    return IQ(e.disposeEffect), e;
  }
  function $Q(e) {
    const {
      className: t,
      classes: n,
      pulsate: r = !1,
      rippleX: o,
      rippleY: i,
      rippleSize: a,
      in: s,
      onExited: c,
      timeout: u
    } = e, [d, p] = T.useState(!1), m = $e(t, n.ripple, n.rippleVisible, r && n.ripplePulsate), g = {
      width: a,
      height: a,
      top: -(a / 2) + i,
      left: -(a / 2) + o
    }, y = $e(n.child, d && n.childLeaving, r && n.childPulsate);
    return !s && !d && p(!0), T.useEffect(() => {
      if (!s && c != null) {
        const b = setTimeout(c, u);
        return () => {
          clearTimeout(b);
        };
      }
    }, [c, s, u]), /* @__PURE__ */ S.jsx("span", {
      className: m,
      style: g,
      children: /* @__PURE__ */ S.jsx("span", {
        className: y
      })
    });
  }
  const ko = nt("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), EE = 550, jQ = 80, DQ = If`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`, FQ = If`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`, LQ = If`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`, zQ = Re("span", {
    name: "MuiTouchRipple",
    slot: "Root"
  })({
    overflow: "hidden",
    pointerEvents: "none",
    position: "absolute",
    zIndex: 0,
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    borderRadius: "inherit"
  }), BQ = Re($Q, {
    name: "MuiTouchRipple",
    slot: "Ripple"
  })`
  opacity: 0;
  position: absolute;

  &.${ko.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${DQ};
    animation-duration: ${EE}ms;
    animation-timing-function: ${({
    theme: e
  }) => e.transitions.easing.easeInOut};
  }

  &.${ko.ripplePulsate} {
    animation-duration: ${({
    theme: e
  }) => e.transitions.duration.shorter}ms;
  }

  & .${ko.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${ko.childLeaving} {
    opacity: 0;
    animation-name: ${FQ};
    animation-duration: ${EE}ms;
    animation-timing-function: ${({
    theme: e
  }) => e.transitions.easing.easeInOut};
  }

  & .${ko.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${LQ};
    animation-duration: 2500ms;
    animation-timing-function: ${({
    theme: e
  }) => e.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`, UQ = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiTouchRipple"
    }), {
      center: o = !1,
      classes: i = {},
      className: a,
      ...s
    } = r, [c, u] = T.useState([]), d = T.useRef(0), p = T.useRef(null);
    T.useEffect(() => {
      p.current && (p.current(), p.current = null);
    }, [c]);
    const m = T.useRef(!1), g = IF(), y = T.useRef(null), b = T.useRef(null), v = T.useCallback((C) => {
      const {
        pulsate: k,
        rippleX: A,
        rippleY: O,
        rippleSize: P,
        cb: I
      } = C;
      u(($) => [...$, /* @__PURE__ */ S.jsx(BQ, {
        classes: {
          ripple: $e(i.ripple, ko.ripple),
          rippleVisible: $e(i.rippleVisible, ko.rippleVisible),
          ripplePulsate: $e(i.ripplePulsate, ko.ripplePulsate),
          child: $e(i.child, ko.child),
          childLeaving: $e(i.childLeaving, ko.childLeaving),
          childPulsate: $e(i.childPulsate, ko.childPulsate)
        },
        timeout: EE,
        pulsate: k,
        rippleX: A,
        rippleY: O,
        rippleSize: P
      }, d.current)]), d.current += 1, p.current = I;
    }, [i]), x = T.useCallback((C = {}, k = {}, A = () => {
    }) => {
      const {
        pulsate: O = !1,
        center: P = o || k.pulsate,
        fakeElement: I = !1
        // For test purposes
      } = k;
      if (C?.type === "mousedown" && m.current) {
        m.current = !1;
        return;
      }
      C?.type === "touchstart" && (m.current = !0);
      const $ = I ? null : b.current, L = $ ? $.getBoundingClientRect() : {
        width: 0,
        height: 0,
        left: 0,
        top: 0
      };
      let N, U, j;
      if (P || C === void 0 || C.clientX === 0 && C.clientY === 0 || !C.clientX && !C.touches)
        N = Math.round(L.width / 2), U = Math.round(L.height / 2);
      else {
        const {
          clientX: V,
          clientY: F
        } = C.touches && C.touches.length > 0 ? C.touches[0] : C;
        N = Math.round(V - L.left), U = Math.round(F - L.top);
      }
      if (P)
        j = Math.sqrt((2 * L.width ** 2 + L.height ** 2) / 3), j % 2 === 0 && (j += 1);
      else {
        const V = Math.max(Math.abs(($ ? $.clientWidth : 0) - N), N) * 2 + 2, F = Math.max(Math.abs(($ ? $.clientHeight : 0) - U), U) * 2 + 2;
        j = Math.sqrt(V ** 2 + F ** 2);
      }
      C?.touches ? y.current === null && (y.current = () => {
        v({
          pulsate: O,
          rippleX: N,
          rippleY: U,
          rippleSize: j,
          cb: A
        });
      }, g.start(jQ, () => {
        y.current && (y.current(), y.current = null);
      })) : v({
        pulsate: O,
        rippleX: N,
        rippleY: U,
        rippleSize: j,
        cb: A
      });
    }, [o, v, g]), E = T.useCallback(() => {
      x({}, {
        pulsate: !0
      });
    }, [x]), _ = T.useCallback((C, k) => {
      if (g.clear(), C?.type === "touchend" && y.current) {
        y.current(), y.current = null, g.start(0, () => {
          _(C, k);
        });
        return;
      }
      y.current = null, u((A) => A.length > 0 ? A.slice(1) : A), p.current = k;
    }, [g]);
    return T.useImperativeHandle(n, () => ({
      pulsate: E,
      start: x,
      stop: _
    }), [E, x, _]), /* @__PURE__ */ S.jsx(zQ, {
      className: $e(ko.root, i.root, a),
      ref: b,
      ...s,
      children: /* @__PURE__ */ S.jsx(Ok, {
        component: null,
        exit: !0,
        children: c
      })
    });
  });
  function VQ(e) {
    return ot("MuiButtonBase", e);
  }
  const HQ = nt("MuiButtonBase", ["root", "disabled", "focusVisible"]), qQ = (e) => {
    const {
      disabled: t,
      focusVisible: n,
      focusVisibleClassName: r,
      classes: o
    } = e, a = rt({
      root: ["root", t && "disabled", n && "focusVisible"]
    }, VQ, o);
    return n && r && (a.root += ` ${r}`), a;
  }, WQ = Re("button", {
    name: "MuiButtonBase",
    slot: "Root"
  })({
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    boxSizing: "border-box",
    WebkitTapHighlightColor: "transparent",
    backgroundColor: "transparent",
    // Reset default value
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    border: 0,
    margin: 0,
    // Remove the margin in Safari
    borderRadius: 0,
    padding: 0,
    // Remove the padding in Firefox
    cursor: "pointer",
    userSelect: "none",
    verticalAlign: "middle",
    MozAppearance: "none",
    // Reset
    WebkitAppearance: "none",
    // Reset
    textDecoration: "none",
    // So we take precedent over the style of a native <a /> element.
    color: "inherit",
    "&::-moz-focus-inner": {
      borderStyle: "none"
      // Remove Firefox dotted outline.
    },
    [`&.${HQ.disabled}`]: {
      pointerEvents: "none",
      // Disable link interactions
      cursor: "default"
    },
    "@media print": {
      colorAdjust: "exact"
    }
  }), Lh = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiButtonBase"
    }), {
      action: o,
      centerRipple: i = !1,
      children: a,
      className: s,
      component: c = "button",
      disabled: u = !1,
      disableRipple: d = !1,
      disableTouchRipple: p = !1,
      focusRipple: m = !1,
      focusVisibleClassName: g,
      LinkComponent: y = "a",
      onBlur: b,
      onClick: v,
      onContextMenu: x,
      onDragLeave: E,
      onFocus: _,
      onFocusVisible: C,
      onKeyDown: k,
      onKeyUp: A,
      onMouseDown: O,
      onMouseLeave: P,
      onMouseUp: I,
      onTouchEnd: $,
      onTouchMove: L,
      onTouchStart: N,
      tabIndex: U = 0,
      TouchRippleProps: j,
      touchRippleRef: V,
      type: F,
      ...K
    } = r, W = T.useRef(null), Y = CQ(), B = er(Y.ref, V), [D, G] = T.useState(!1);
    u && D && G(!1), T.useImperativeHandle(o, () => ({
      focusVisible: () => {
        G(!0), W.current.focus();
      }
    }), []);
    const z = Y.shouldMount && !d && !u;
    T.useEffect(() => {
      D && m && !d && Y.pulsate();
    }, [d, m, D, Y]);
    const H = ka(Y, "start", O, p), X = ka(Y, "stop", x, p), Q = ka(Y, "stop", E, p), ne = ka(Y, "stop", I, p), te = ka(Y, "stop", (Ne) => {
      D && Ne.preventDefault(), P && P(Ne);
    }, p), se = ka(Y, "start", N, p), ue = ka(Y, "stop", $, p), J = ka(Y, "stop", L, p), ee = ka(Y, "stop", (Ne) => {
      t0(Ne.target) || G(!1), b && b(Ne);
    }, !1), ie = Bi((Ne) => {
      W.current || (W.current = Ne.currentTarget), t0(Ne.target) && (G(!0), C && C(Ne)), _ && _(Ne);
    }), le = () => {
      const Ne = W.current;
      return c && c !== "button" && !(Ne.tagName === "A" && Ne.href);
    }, ge = Bi((Ne) => {
      m && !Ne.repeat && D && Ne.key === " " && Y.stop(Ne, () => {
        Y.start(Ne);
      }), Ne.target === Ne.currentTarget && le() && Ne.key === " " && Ne.preventDefault(), k && k(Ne), Ne.target === Ne.currentTarget && le() && Ne.key === "Enter" && !u && (Ne.preventDefault(), v && v(Ne));
    }), Se = Bi((Ne) => {
      m && Ne.key === " " && D && !Ne.defaultPrevented && Y.stop(Ne, () => {
        Y.pulsate(Ne);
      }), A && A(Ne), v && Ne.target === Ne.currentTarget && le() && Ne.key === " " && !Ne.defaultPrevented && v(Ne);
    });
    let Me = c;
    Me === "button" && (K.href || K.to) && (Me = y);
    const je = {};
    if (Me === "button") {
      const Ne = !!K.formAction;
      je.type = F === void 0 && !Ne ? "button" : F, je.disabled = u;
    } else
      !K.href && !K.to && (je.role = "button"), u && (je["aria-disabled"] = u);
    const ze = er(n, W), Ye = {
      ...r,
      centerRipple: i,
      component: c,
      disabled: u,
      disableRipple: d,
      disableTouchRipple: p,
      focusRipple: m,
      tabIndex: U,
      focusVisible: D
    }, Ue = qQ(Ye);
    return /* @__PURE__ */ S.jsxs(WQ, {
      as: Me,
      className: $e(Ue.root, s),
      ownerState: Ye,
      onBlur: ee,
      onClick: v,
      onContextMenu: X,
      onFocus: ie,
      onKeyDown: ge,
      onKeyUp: Se,
      onMouseDown: H,
      onMouseLeave: te,
      onMouseUp: ne,
      onDragLeave: Q,
      onTouchEnd: ue,
      onTouchMove: J,
      onTouchStart: se,
      ref: ze,
      tabIndex: u ? -1 : U,
      type: F,
      ...je,
      ...K,
      children: [a, z ? /* @__PURE__ */ S.jsx(UQ, {
        ref: B,
        center: i,
        ...j
      }) : null]
    });
  });
  function ka(e, t, n, r = !1) {
    return Bi((o) => (n && n(o), r || e[t](o), !0));
  }
  function GQ(e) {
    return ot("MuiSvgIcon", e);
  }
  nt("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
  const KQ = (e) => {
    const {
      color: t,
      fontSize: n,
      classes: r
    } = e, o = {
      root: ["root", t !== "inherit" && `color${Ie(t)}`, `fontSize${Ie(n)}`]
    };
    return rt(o, GQ, r);
  }, YQ = Re("svg", {
    name: "MuiSvgIcon",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.color !== "inherit" && t[`color${Ie(n.color)}`], t[`fontSize${Ie(n.fontSize)}`]];
    }
  })(st(({
    theme: e
  }) => ({
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    flexShrink: 0,
    transition: e.transitions?.create?.("fill", {
      duration: (e.vars ?? e).transitions?.duration?.shorter
    }),
    variants: [
      {
        props: (t) => !t.hasSvgAsChild,
        style: {
          // the <svg> will define the property that has `currentColor`
          // for example heroicons uses fill="none" and stroke="currentColor"
          fill: "currentColor"
        }
      },
      {
        props: {
          fontSize: "inherit"
        },
        style: {
          fontSize: "inherit"
        }
      },
      {
        props: {
          fontSize: "small"
        },
        style: {
          fontSize: e.typography?.pxToRem?.(20) || "1.25rem"
        }
      },
      {
        props: {
          fontSize: "medium"
        },
        style: {
          fontSize: e.typography?.pxToRem?.(24) || "1.5rem"
        }
      },
      {
        props: {
          fontSize: "large"
        },
        style: {
          fontSize: e.typography?.pxToRem?.(35) || "2.1875rem"
        }
      },
      // TODO v5 deprecate color prop, v6 remove for sx
      ...Object.entries((e.vars ?? e).palette).filter(([, t]) => t && t.main).map(([t]) => ({
        props: {
          color: t
        },
        style: {
          color: (e.vars ?? e).palette?.[t]?.main
        }
      })),
      {
        props: {
          color: "action"
        },
        style: {
          color: (e.vars ?? e).palette?.action?.active
        }
      },
      {
        props: {
          color: "disabled"
        },
        style: {
          color: (e.vars ?? e).palette?.action?.disabled
        }
      },
      {
        props: {
          color: "inherit"
        },
        style: {
          color: void 0
        }
      }
    ]
  }))), CE = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiSvgIcon"
    }), {
      children: o,
      className: i,
      color: a = "inherit",
      component: s = "svg",
      fontSize: c = "medium",
      htmlColor: u,
      inheritViewBox: d = !1,
      titleAccess: p,
      viewBox: m = "0 0 24 24",
      ...g
    } = r, y = /* @__PURE__ */ T.isValidElement(o) && o.type === "svg", b = {
      ...r,
      color: a,
      component: s,
      fontSize: c,
      instanceFontSize: t.fontSize,
      inheritViewBox: d,
      viewBox: m,
      hasSvgAsChild: y
    }, v = {};
    d || (v.viewBox = m);
    const x = KQ(b);
    return /* @__PURE__ */ S.jsxs(YQ, {
      as: s,
      className: $e(x.root, i),
      focusable: "false",
      color: u,
      "aria-hidden": p ? void 0 : !0,
      role: p ? "img" : void 0,
      ref: n,
      ...v,
      ...g,
      ...y && o.props,
      ownerState: b,
      children: [y ? o.props.children : o, p ? /* @__PURE__ */ S.jsx("title", {
        children: p
      }) : null]
    });
  });
  CE.muiName = "SvgIcon";
  function po(e, t) {
    function n(r, o) {
      return /* @__PURE__ */ S.jsx(CE, {
        "data-testid": void 0,
        ref: o,
        ...r,
        children: e
      });
    }
    return n.muiName = CE.muiName, /* @__PURE__ */ T.memo(/* @__PURE__ */ T.forwardRef(n));
  }
  const XQ = po(/* @__PURE__ */ S.jsx("path", {
    d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
  }));
  function ZQ(e) {
    return ot("MuiTableSortLabel", e);
  }
  const bS = nt("MuiTableSortLabel", ["root", "active", "icon", "iconDirectionDesc", "iconDirectionAsc", "directionDesc", "directionAsc"]);
  function Ui(e) {
    return typeof e == "string";
  }
  function $F(e, t, n) {
    return e === void 0 || Ui(e) ? t : {
      ...t,
      ownerState: {
        ...t.ownerState,
        ...n
      }
    };
  }
  function jF(e, t, n) {
    return typeof e == "function" ? e(t, n) : e;
  }
  function Ap(e, t = []) {
    if (e === void 0)
      return {};
    const n = {};
    return Object.keys(e).filter((r) => r.match(/^on[A-Z]/) && typeof e[r] == "function" && !t.includes(r)).forEach((r) => {
      n[r] = e[r];
    }), n;
  }
  function b2(e) {
    if (e === void 0)
      return {};
    const t = {};
    return Object.keys(e).filter((n) => !(n.match(/^on[A-Z]/) && typeof e[n] == "function")).forEach((n) => {
      t[n] = e[n];
    }), t;
  }
  function DF(e) {
    const {
      getSlotProps: t,
      additionalProps: n,
      externalSlotProps: r,
      externalForwardedProps: o,
      className: i
    } = e;
    if (!t) {
      const g = $e(n?.className, i, o?.className, r?.className), y = {
        ...n?.style,
        ...o?.style,
        ...r?.style
      }, b = {
        ...n,
        ...o,
        ...r
      };
      return g.length > 0 && (b.className = g), Object.keys(y).length > 0 && (b.style = y), {
        props: b,
        internalRef: void 0
      };
    }
    const a = Ap({
      ...o,
      ...r
    }), s = b2(r), c = b2(o), u = t(a), d = $e(u?.className, n?.className, i, o?.className, r?.className), p = {
      ...u?.style,
      ...n?.style,
      ...o?.style,
      ...r?.style
    }, m = {
      ...u,
      ...n,
      ...c,
      ...s
    };
    return d.length > 0 && (m.className = d), Object.keys(p).length > 0 && (m.style = p), {
      props: m,
      internalRef: u.ref
    };
  }
  function ln(e, t) {
    const {
      className: n,
      elementType: r,
      ownerState: o,
      externalForwardedProps: i,
      internalForwardedProps: a,
      shouldForwardComponentProp: s = !1,
      ...c
    } = t, {
      component: u,
      slots: d = {
        [e]: void 0
      },
      slotProps: p = {
        [e]: void 0
      },
      ...m
    } = i, g = d[e] || r, y = jF(p[e], o), {
      props: {
        component: b,
        ...v
      },
      internalRef: x
    } = DF({
      className: n,
      ...c,
      externalForwardedProps: e === "root" ? m : void 0,
      externalSlotProps: y
    }), E = er(x, y?.ref, t.ref), _ = e === "root" ? b || u : b, C = $F(g, {
      ...e === "root" && !u && !d[e] && a,
      ...e !== "root" && !d[e] && a,
      ...v,
      ..._ && !s && {
        as: _
      },
      ..._ && s && {
        component: _
      },
      ref: E
    }, o);
    return [g, C];
  }
  const QQ = (e) => {
    const {
      classes: t,
      direction: n,
      active: r
    } = e, o = {
      root: ["root", r && "active", `direction${Ie(n)}`],
      icon: ["icon", `iconDirection${Ie(n)}`]
    };
    return rt(o, ZQ, t);
  }, JQ = Re(Lh, {
    name: "MuiTableSortLabel",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.active && t.active];
    }
  })(st(({
    theme: e
  }) => ({
    cursor: "pointer",
    display: "inline-flex",
    justifyContent: "flex-start",
    flexDirection: "inherit",
    alignItems: "center",
    "&:focus": {
      color: (e.vars || e).palette.text.secondary
    },
    "&:hover": {
      color: (e.vars || e).palette.text.secondary,
      [`& .${bS.icon}`]: {
        opacity: 0.5
      }
    },
    [`&.${bS.active}`]: {
      color: (e.vars || e).palette.text.primary,
      [`& .${bS.icon}`]: {
        opacity: 1,
        color: (e.vars || e).palette.text.secondary
      }
    }
  }))), eJ = Re("span", {
    name: "MuiTableSortLabel",
    slot: "Icon",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.icon, t[`iconDirection${Ie(n.direction)}`]];
    }
  })(st(({
    theme: e
  }) => ({
    fontSize: 18,
    marginRight: 4,
    marginLeft: 4,
    opacity: 0,
    transition: e.transitions.create(["opacity", "transform"], {
      duration: e.transitions.duration.shorter
    }),
    userSelect: "none",
    variants: [{
      props: {
        direction: "desc"
      },
      style: {
        transform: "rotate(0deg)"
      }
    }, {
      props: {
        direction: "asc"
      },
      style: {
        transform: "rotate(180deg)"
      }
    }]
  }))), tJ = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiTableSortLabel"
    }), {
      active: o = !1,
      children: i,
      className: a,
      direction: s = "asc",
      hideSortIcon: c = !1,
      IconComponent: u = XQ,
      slots: d = {},
      slotProps: p = {},
      ...m
    } = r, g = {
      ...r,
      active: o,
      direction: s,
      hideSortIcon: c,
      IconComponent: u
    }, y = QQ(g), b = {
      slots: d,
      slotProps: p
    }, [v, x] = ln("root", {
      elementType: JQ,
      externalForwardedProps: b,
      ownerState: g,
      className: $e(y.root, a),
      ref: n
    }), [E, _] = ln("icon", {
      elementType: eJ,
      externalForwardedProps: b,
      ownerState: g,
      className: y.icon
    });
    return /* @__PURE__ */ S.jsxs(v, {
      disableRipple: !0,
      component: "span",
      ...x,
      ...m,
      children: [i, c && !o ? null : /* @__PURE__ */ S.jsx(E, {
        as: u,
        ..._
      })]
    });
  }), nJ = (e) => {
    const t = [];
    if (e === void 0)
      return {
        header: [],
        rows: []
      };
    e.data === void 0 && (e.data = []), (e.columns === void 0 || e.columns.length === 0) && (e.data.length === 0 ? e.columns = [] : e.columns = e.data[0].map((r, o) => `col${o}`)), (e.index === void 0 || e.index.length === 0) && (e.index = e.data.map((r, o) => `row${o}`));
    const n = Math.max(e.index.length, e.data.length);
    for (let r = 0; r < n; r++) {
      const i = [r < e.index.length ? e.index[r] : `row${r}`];
      for (let a = 0; a < e.columns.length; a++)
        i.push(e.data[r] ? e.data[r][a] : void 0);
      t.push(i);
    }
    return {
      header: ["index", ...e.columns],
      rows: t
    };
  }, rJ = (e, t) => e === "desc" ? (n, r) => r[t] < n[t] ? -1 : r[t] > n[t] ? 1 : 0 : (n, r) => n[t] < r[t] ? -1 : n[t] > r[t] ? 1 : 0, kE = (e, t) => {
    const n = e.map((r, o) => [
      r,
      o
    ]);
    return n.sort((r, o) => t(r[0], o[0])), n.map((r) => r[0]);
  }, oJ = (e, t, n = 1e3) => {
    if (e.length <= n)
      return kE(e, t);
    const r = [];
    for (let i = 0; i < e.length; i += n)
      r.push(e.slice(i, i + n));
    const o = r.map((i) => kE(i, t));
    return iJ(o, t);
  }, iJ = (e, t) => {
    if (e.length === 1) return e[0];
    const n = [], r = new Array(e.length).fill(0);
    for (; r.some((o, i) => o < e[i].length); ) {
      let o = -1, i = null;
      for (let a = 0; a < e.length; a++)
        if (r[a] < e[a].length) {
          const s = e[a][r[a]];
          (i === null || t(s, i) < 0) && (i = s, o = a);
        }
      o !== -1 && i !== null && (n.push(i), r[o]++);
    }
    return n;
  }, x2 = (e, t, n) => {
    const r = Math.ceil(e / n);
    return {
      currentPage: r === 0 ? 1 : Math.min(Math.max(1, t), r),
      pageSize: n,
      totalPages: r,
      totalRows: e
    };
  }, aJ = (e, t, n) => {
    const r = (t - 1) * n, o = r + n;
    return e.slice(r, o);
  }, sJ = (e, t, n, r, o = 5) => {
    const i = Math.max(0, Math.floor(e / n) - o), a = Math.min(
      r - 1,
      Math.ceil((e + t) / n) + o
    );
    return { startIndex: i, endIndex: a };
  }, lJ = (e, t) => {
    let n;
    return (...r) => {
      clearTimeout(n), n = setTimeout(() => e(...r), t);
    };
  }, FF = ({
    tabledata: e,
    className: t = "",
    size: n = "small",
    onSortChange: r,
    enablePagination: o = void 0,
    pageSize: i = 50,
    enableVirtualScrolling: a = void 0,
    virtualScrollingHeight: s = 400,
    enableLazyLoading: c = void 0,
    onLoadMore: u
  }) => {
    e || (e = {
      columns: [],
      index: [],
      data: []
    });
    const d = e.index.length;
    d > 1e4 && (c = c === void 0 ? !0 : c), d > 1e3 && (a = a === void 0 ? !0 : a), d > 2 * i && (o = o === void 0 ? !0 : o), c = c === void 0 ? !1 : c, a = a === void 0 ? !1 : a, o = o === void 0 ? !1 : o;
    const p = T.useMemo(
      () => nJ(e),
      [e]
    ), [m, g] = T.useState("asc"), [y, b] = T.useState("index"), [v, x] = T.useState(
      () => x2(p.rows.length, 1, i)
    ), [E, _] = T.useState(0), C = T.useRef(null), k = T.useMemo(() => {
      const W = p.header.indexOf(y);
      return W === -1 ? 0 : W;
    }, [p.header, y]), A = T.useMemo(
      () => lJ((W, Y) => {
        g(Y), b(W), r?.(W, Y);
      }, 150),
      [r]
    ), O = T.useCallback(
      (W) => {
        const B = y === W && m === "asc" ? "desc" : "asc";
        p.rows.length > 1e3 ? A(W, B) : (g(B), b(W), r?.(W, B));
      },
      [
        y,
        m,
        r,
        p.rows.length,
        A
      ]
    ), P = T.useMemo(
      () => rJ(m, k),
      [m, k]
    ), I = T.useMemo(() => p.rows.length > 1e3 ? oJ(p.rows, P) : kE(p.rows, P), [p.rows, P]), $ = T.useMemo(() => o ? aJ(I, v.currentPage, v.pageSize) : I, [
      I,
      o,
      v.currentPage,
      v.pageSize
    ]), L = {
      itemHeight: 48,
      // Approximate row height
      overscan: 5,
      containerHeight: s
    }, N = T.useMemo(() => a ? sJ(
      E,
      L.containerHeight,
      L.itemHeight,
      $.length,
      L.overscan
    ) : { startIndex: 0, endIndex: $.length - 1 }, [
      E,
      a,
      $.length,
      L
    ]), U = T.useCallback(
      (W) => {
        a && _(W.currentTarget.scrollTop);
      },
      [a]
    ), j = T.useCallback((W) => {
      x((Y) => ({
        ...Y,
        currentPage: W
      }));
    }, []), V = T.useCallback(
      (W) => {
        if (!(!o || !(W.target.closest(".sortable-table-wrapper") === W.currentTarget)))
          switch (W.key) {
            case "ArrowLeft":
              v.currentPage > 1 && (W.preventDefault(), W.stopPropagation(), j(v.currentPage - 1));
              break;
            case "ArrowRight":
              v.currentPage < v.totalPages && (W.preventDefault(), W.stopPropagation(), j(v.currentPage + 1));
              break;
            case "Home":
              v.currentPage > 1 && (W.preventDefault(), W.stopPropagation(), j(1));
              break;
            case "End":
              v.currentPage < v.totalPages && (W.preventDefault(), W.stopPropagation(), j(v.totalPages));
              break;
          }
      },
      [
        o,
        v.currentPage,
        v.totalPages,
        j
      ]
    );
    T.useEffect(() => {
      o && x((W) => x2(
        I.length,
        W.currentPage,
        // Use previous current page instead of hardcoding 1
        i
      ));
    }, [I.length, o, i]), T.useEffect(() => {
      c && u && v.currentPage >= v.totalPages - 1 && u(v.currentPage + 1);
    }, [
      c,
      u,
      v.currentPage,
      v.totalPages
    ]);
    const F = () => o ? /* @__PURE__ */ S.jsxs("div", { className: "sortable-table-pagination", children: [
      /* @__PURE__ */ S.jsx(
        "button",
        {
          onClick: () => j(v.currentPage - 1),
          disabled: v.currentPage <= 1,
          className: "pagination-button",
          children: "Previous"
        }
      ),
      /* @__PURE__ */ S.jsxs("span", { className: "pagination-info", children: [
        "Page ",
        v.currentPage,
        " of ",
        v.totalPages,
        "(",
        v.totalRows,
        " total rows)"
      ] }),
      /* @__PURE__ */ S.jsx(
        "button",
        {
          onClick: () => j(v.currentPage + 1),
          disabled: v.currentPage >= v.totalPages,
          className: "pagination-button",
          children: "Next"
        }
      )
    ] }) : null, K = () => {
      const W = a ? $.slice(
        N.startIndex,
        N.endIndex + 1
      ) : $;
      return /* @__PURE__ */ S.jsxs(lQ, { children: [
        a && /* @__PURE__ */ S.jsx(
          Xg,
          {
            style: {
              height: N.startIndex * L.itemHeight
            },
            children: /* @__PURE__ */ S.jsx(Yg, { colSpan: p.header.length })
          }
        ),
        W.map((Y, B) => {
          const D = a ? N.startIndex + B : B;
          return /* @__PURE__ */ S.jsx(Xg, { children: Y.map((G, z) => /* @__PURE__ */ S.jsx(
            Yg,
            {
              className: z === 0 ? "sortable-table-index-cell" : "sortable-table-data-cell",
              children: G
            },
            `${e.index?.[D] || D}-${z}`
          )) }, e.index?.[D] || D);
        }),
        a && /* @__PURE__ */ S.jsx(
          Xg,
          {
            style: {
              height: ($.length - N.endIndex - 1) * L.itemHeight
            },
            children: /* @__PURE__ */ S.jsx(Yg, { colSpan: p.header.length })
          }
        )
      ] });
    };
    return /* @__PURE__ */ S.jsxs(
      "div",
      {
        className: "sortable-table-wrapper",
        onKeyDown: V,
        tabIndex: o ? 0 : -1,
        role: o ? "application" : void 0,
        "aria-label": o ? "Sortable table with pagination" : void 0,
        children: [
          /* @__PURE__ */ S.jsx(
            gQ,
            {
              className: `sortable-table-container ${t}`,
              ref: C,
              onScroll: U,
              style: a ? { height: s } : void 0,
              children: /* @__PURE__ */ S.jsxs(rQ, { size: n, children: [
                /* @__PURE__ */ S.jsx(wQ, { className: "sortable-table-head", children: /* @__PURE__ */ S.jsx(Xg, { className: "sortable-table-header-row", children: p.header.map((W) => /* @__PURE__ */ S.jsx(
                  Yg,
                  {
                    className: "sortable-table-header-cell",
                    "aria-label": `Sort by ${W}`,
                    children: /* @__PURE__ */ S.jsx(
                      tJ,
                      {
                        active: y === W,
                        direction: y === W ? m : "asc",
                        onClick: () => O(W),
                        className: "sortable-table-sort-label",
                        sx: {
                          "& .MuiTableSortLabel-icon": {
                            color: "inherit !important"
                          }
                        },
                        children: W
                      }
                    )
                  },
                  W
                )) }) }),
                K()
              ] })
            }
          ),
          F()
        ]
      }
    );
  };
  FF.displayName = "SortableTable";
  function Le(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
    return function(o) {
      if (e?.(o), n === !1 || !o.defaultPrevented)
        return t?.(o);
    };
  }
  function w2(e, t) {
    if (typeof e == "function")
      return e(t);
    e != null && (e.current = t);
  }
  function xb(...e) {
    return (t) => {
      let n = !1;
      const r = e.map((o) => {
        const i = w2(o, t);
        return !n && typeof i == "function" && (n = !0), i;
      });
      if (n)
        return () => {
          for (let o = 0; o < r.length; o++) {
            const i = r[o];
            typeof i == "function" ? i() : w2(e[o], null);
          }
        };
    };
  }
  function un(...e) {
    return T.useCallback(xb(...e), e);
  }
  function cJ(e, t) {
    const n = T.createContext(t), r = (i) => {
      const { children: a, ...s } = i, c = T.useMemo(() => s, Object.values(s));
      return /* @__PURE__ */ S.jsx(n.Provider, { value: c, children: a });
    };
    r.displayName = e + "Provider";
    function o(i) {
      const a = T.useContext(n);
      if (a) return a;
      if (t !== void 0) return t;
      throw new Error(`\`${i}\` must be used within \`${e}\``);
    }
    return [r, o];
  }
  function Qi(e, t = []) {
    let n = [];
    function r(i, a) {
      const s = T.createContext(a), c = n.length;
      n = [...n, a];
      const u = (p) => {
        const { scope: m, children: g, ...y } = p, b = m?.[e]?.[c] || s, v = T.useMemo(() => y, Object.values(y));
        return /* @__PURE__ */ S.jsx(b.Provider, { value: v, children: g });
      };
      u.displayName = i + "Provider";
      function d(p, m) {
        const g = m?.[e]?.[c] || s, y = T.useContext(g);
        if (y) return y;
        if (a !== void 0) return a;
        throw new Error(`\`${p}\` must be used within \`${i}\``);
      }
      return [u, d];
    }
    const o = () => {
      const i = n.map((a) => T.createContext(a));
      return function(s) {
        const c = s?.[e] || i;
        return T.useMemo(
          () => ({ [`__scope${e}`]: { ...s, [e]: c } }),
          [s, c]
        );
      };
    };
    return o.scopeName = e, [r, uJ(o, ...t)];
  }
  function uJ(...e) {
    const t = e[0];
    if (e.length === 1) return t;
    const n = () => {
      const r = e.map((o) => ({
        useScope: o(),
        scopeName: o.scopeName
      }));
      return function(i) {
        const a = r.reduce((s, { useScope: c, scopeName: u }) => {
          const p = c(i)[`__scope${u}`];
          return { ...s, ...p };
        }, {});
        return T.useMemo(() => ({ [`__scope${t.scopeName}`]: a }), [a]);
      };
    };
    return n.scopeName = t.scopeName, n;
  }
  var qa = globalThis?.document ? T.useLayoutEffect : () => {
  }, fJ = sc[" useId ".trim().toString()] || (() => {
  }), dJ = 0;
  function Vi(e) {
    const [t, n] = T.useState(fJ());
    return qa(() => {
      n((r) => r ?? String(dJ++));
    }, [e]), e || (t ? `radix-${t}` : "");
  }
  var pJ = sc[" useInsertionEffect ".trim().toString()] || qa;
  function hl({
    prop: e,
    defaultProp: t,
    onChange: n = () => {
    },
    caller: r
  }) {
    const [o, i, a] = hJ({
      defaultProp: t,
      onChange: n
    }), s = e !== void 0, c = s ? e : o;
    {
      const d = T.useRef(e !== void 0);
      T.useEffect(() => {
        const p = d.current;
        p !== s && console.warn(
          `${r} is changing from ${p ? "controlled" : "uncontrolled"} to ${s ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        ), d.current = s;
      }, [s, r]);
    }
    const u = T.useCallback(
      (d) => {
        if (s) {
          const p = mJ(d) ? d(e) : d;
          p !== e && a.current?.(p);
        } else
          i(d);
      },
      [s, e, i, a]
    );
    return [c, u];
  }
  function hJ({
    defaultProp: e,
    onChange: t
  }) {
    const [n, r] = T.useState(e), o = T.useRef(n), i = T.useRef(t);
    return pJ(() => {
      i.current = t;
    }, [t]), T.useEffect(() => {
      o.current !== n && (i.current?.(n), o.current = n);
    }, [n, o]), [n, r, i];
  }
  function mJ(e) {
    return typeof e == "function";
  }
  // @__NO_SIDE_EFFECTS__
  function df(e) {
    const t = /* @__PURE__ */ gJ(e), n = T.forwardRef((r, o) => {
      const { children: i, ...a } = r, s = T.Children.toArray(i), c = s.find(vJ);
      if (c) {
        const u = c.props.children, d = s.map((p) => p === c ? T.Children.count(u) > 1 ? T.Children.only(null) : T.isValidElement(u) ? u.props.children : null : p);
        return /* @__PURE__ */ S.jsx(t, { ...a, ref: o, children: T.isValidElement(u) ? T.cloneElement(u, void 0, d) : null });
      }
      return /* @__PURE__ */ S.jsx(t, { ...a, ref: o, children: i });
    });
    return n.displayName = `${e}.Slot`, n;
  }
  // @__NO_SIDE_EFFECTS__
  function gJ(e) {
    const t = T.forwardRef((n, r) => {
      const { children: o, ...i } = n;
      if (T.isValidElement(o)) {
        const a = xJ(o), s = bJ(i, o.props);
        return o.type !== T.Fragment && (s.ref = r ? xb(r, a) : a), T.cloneElement(o, s);
      }
      return T.Children.count(o) > 1 ? T.Children.only(null) : null;
    });
    return t.displayName = `${e}.SlotClone`, t;
  }
  var yJ = /* @__PURE__ */ Symbol("radix.slottable");
  function vJ(e) {
    return T.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === yJ;
  }
  function bJ(e, t) {
    const n = { ...t };
    for (const r in t) {
      const o = e[r], i = t[r];
      /^on[A-Z]/.test(r) ? o && i ? n[r] = (...s) => {
        const c = i(...s);
        return o(...s), c;
      } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...i } : r === "className" && (n[r] = [o, i].filter(Boolean).join(" "));
    }
    return { ...e, ...n };
  }
  function xJ(e) {
    let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
    return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
  }
  var wJ = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "select",
    "span",
    "svg",
    "ul"
  ], xt = wJ.reduce((e, t) => {
    const n = /* @__PURE__ */ df(`Primitive.${t}`), r = T.forwardRef((o, i) => {
      const { asChild: a, ...s } = o, c = a ? n : t;
      return typeof window < "u" && (window[/* @__PURE__ */ Symbol.for("radix-ui")] = !0), /* @__PURE__ */ S.jsx(c, { ...s, ref: i });
    });
    return r.displayName = `Primitive.${t}`, { ...e, [t]: r };
  }, {});
  function Nk(e, t) {
    e && _c.flushSync(() => e.dispatchEvent(t));
  }
  function qr(e) {
    const t = T.useRef(e);
    return T.useEffect(() => {
      t.current = e;
    }), T.useMemo(() => (...n) => t.current?.(...n), []);
  }
  function SJ(e, t = globalThis?.document) {
    const n = qr(e);
    T.useEffect(() => {
      const r = (o) => {
        o.key === "Escape" && n(o);
      };
      return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
    }, [n, t]);
  }
  var _J = "DismissableLayer", TE = "dismissableLayer.update", EJ = "dismissableLayer.pointerDownOutside", CJ = "dismissableLayer.focusOutside", S2, LF = T.createContext({
    layers: /* @__PURE__ */ new Set(),
    layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
    branches: /* @__PURE__ */ new Set()
  }), zh = T.forwardRef(
    (e, t) => {
      const {
        disableOutsidePointerEvents: n = !1,
        onEscapeKeyDown: r,
        onPointerDownOutside: o,
        onFocusOutside: i,
        onInteractOutside: a,
        onDismiss: s,
        ...c
      } = e, u = T.useContext(LF), [d, p] = T.useState(null), m = d?.ownerDocument ?? globalThis?.document, [, g] = T.useState({}), y = un(t, (O) => p(O)), b = Array.from(u.layers), [v] = [...u.layersWithOutsidePointerEventsDisabled].slice(-1), x = b.indexOf(v), E = d ? b.indexOf(d) : -1, _ = u.layersWithOutsidePointerEventsDisabled.size > 0, C = E >= x, k = TJ((O) => {
        const P = O.target, I = [...u.branches].some(($) => $.contains(P));
        !C || I || (o?.(O), a?.(O), O.defaultPrevented || s?.());
      }, m), A = AJ((O) => {
        const P = O.target;
        [...u.branches].some(($) => $.contains(P)) || (i?.(O), a?.(O), O.defaultPrevented || s?.());
      }, m);
      return SJ((O) => {
        E === u.layers.size - 1 && (r?.(O), !O.defaultPrevented && s && (O.preventDefault(), s()));
      }, m), T.useEffect(() => {
        if (d)
          return n && (u.layersWithOutsidePointerEventsDisabled.size === 0 && (S2 = m.body.style.pointerEvents, m.body.style.pointerEvents = "none"), u.layersWithOutsidePointerEventsDisabled.add(d)), u.layers.add(d), _2(), () => {
            n && u.layersWithOutsidePointerEventsDisabled.size === 1 && (m.body.style.pointerEvents = S2);
          };
      }, [d, m, n, u]), T.useEffect(() => () => {
        d && (u.layers.delete(d), u.layersWithOutsidePointerEventsDisabled.delete(d), _2());
      }, [d, u]), T.useEffect(() => {
        const O = () => g({});
        return document.addEventListener(TE, O), () => document.removeEventListener(TE, O);
      }, []), /* @__PURE__ */ S.jsx(
        xt.div,
        {
          ...c,
          ref: y,
          style: {
            pointerEvents: _ ? C ? "auto" : "none" : void 0,
            ...e.style
          },
          onFocusCapture: Le(e.onFocusCapture, A.onFocusCapture),
          onBlurCapture: Le(e.onBlurCapture, A.onBlurCapture),
          onPointerDownCapture: Le(
            e.onPointerDownCapture,
            k.onPointerDownCapture
          )
        }
      );
    }
  );
  zh.displayName = _J;
  var kJ = "DismissableLayerBranch", zF = T.forwardRef((e, t) => {
    const n = T.useContext(LF), r = T.useRef(null), o = un(t, r);
    return T.useEffect(() => {
      const i = r.current;
      if (i)
        return n.branches.add(i), () => {
          n.branches.delete(i);
        };
    }, [n.branches]), /* @__PURE__ */ S.jsx(xt.div, { ...e, ref: o });
  });
  zF.displayName = kJ;
  function TJ(e, t = globalThis?.document) {
    const n = qr(e), r = T.useRef(!1), o = T.useRef(() => {
    });
    return T.useEffect(() => {
      const i = (s) => {
        if (s.target && !r.current) {
          let c = function() {
            BF(
              EJ,
              n,
              u,
              { discrete: !0 }
            );
          };
          const u = { originalEvent: s };
          s.pointerType === "touch" ? (t.removeEventListener("click", o.current), o.current = c, t.addEventListener("click", o.current, { once: !0 })) : c();
        } else
          t.removeEventListener("click", o.current);
        r.current = !1;
      }, a = window.setTimeout(() => {
        t.addEventListener("pointerdown", i);
      }, 0);
      return () => {
        window.clearTimeout(a), t.removeEventListener("pointerdown", i), t.removeEventListener("click", o.current);
      };
    }, [t, n]), {
      // ensures we check React component tree (not just DOM tree)
      onPointerDownCapture: () => r.current = !0
    };
  }
  function AJ(e, t = globalThis?.document) {
    const n = qr(e), r = T.useRef(!1);
    return T.useEffect(() => {
      const o = (i) => {
        i.target && !r.current && BF(CJ, n, { originalEvent: i }, {
          discrete: !1
        });
      };
      return t.addEventListener("focusin", o), () => t.removeEventListener("focusin", o);
    }, [t, n]), {
      onFocusCapture: () => r.current = !0,
      onBlurCapture: () => r.current = !1
    };
  }
  function _2() {
    const e = new CustomEvent(TE);
    document.dispatchEvent(e);
  }
  function BF(e, t, n, { discrete: r }) {
    const o = n.originalEvent.target, i = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
    t && o.addEventListener(e, t, { once: !0 }), r ? Nk(o, i) : o.dispatchEvent(i);
  }
  var RJ = zh, OJ = zF, xS = "focusScope.autoFocusOnMount", wS = "focusScope.autoFocusOnUnmount", E2 = { bubbles: !1, cancelable: !0 }, MJ = "FocusScope", wb = T.forwardRef((e, t) => {
    const {
      loop: n = !1,
      trapped: r = !1,
      onMountAutoFocus: o,
      onUnmountAutoFocus: i,
      ...a
    } = e, [s, c] = T.useState(null), u = qr(o), d = qr(i), p = T.useRef(null), m = un(t, (b) => c(b)), g = T.useRef({
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    }).current;
    T.useEffect(() => {
      if (r) {
        let b = function(_) {
          if (g.paused || !s) return;
          const C = _.target;
          s.contains(C) ? p.current = C : Bs(p.current, { select: !0 });
        }, v = function(_) {
          if (g.paused || !s) return;
          const C = _.relatedTarget;
          C !== null && (s.contains(C) || Bs(p.current, { select: !0 }));
        }, x = function(_) {
          if (document.activeElement === document.body)
            for (const k of _)
              k.removedNodes.length > 0 && Bs(s);
        };
        document.addEventListener("focusin", b), document.addEventListener("focusout", v);
        const E = new MutationObserver(x);
        return s && E.observe(s, { childList: !0, subtree: !0 }), () => {
          document.removeEventListener("focusin", b), document.removeEventListener("focusout", v), E.disconnect();
        };
      }
    }, [r, s, g.paused]), T.useEffect(() => {
      if (s) {
        k2.add(g);
        const b = document.activeElement;
        if (!s.contains(b)) {
          const x = new CustomEvent(xS, E2);
          s.addEventListener(xS, u), s.dispatchEvent(x), x.defaultPrevented || (NJ(DJ(UF(s)), { select: !0 }), document.activeElement === b && Bs(s));
        }
        return () => {
          s.removeEventListener(xS, u), setTimeout(() => {
            const x = new CustomEvent(wS, E2);
            s.addEventListener(wS, d), s.dispatchEvent(x), x.defaultPrevented || Bs(b ?? document.body, { select: !0 }), s.removeEventListener(wS, d), k2.remove(g);
          }, 0);
        };
      }
    }, [s, u, d, g]);
    const y = T.useCallback(
      (b) => {
        if (!n && !r || g.paused) return;
        const v = b.key === "Tab" && !b.altKey && !b.ctrlKey && !b.metaKey, x = document.activeElement;
        if (v && x) {
          const E = b.currentTarget, [_, C] = PJ(E);
          _ && C ? !b.shiftKey && x === C ? (b.preventDefault(), n && Bs(_, { select: !0 })) : b.shiftKey && x === _ && (b.preventDefault(), n && Bs(C, { select: !0 })) : x === E && b.preventDefault();
        }
      },
      [n, r, g.paused]
    );
    return /* @__PURE__ */ S.jsx(xt.div, { tabIndex: -1, ...a, ref: m, onKeyDown: y });
  });
  wb.displayName = MJ;
  function NJ(e, { select: t = !1 } = {}) {
    const n = document.activeElement;
    for (const r of e)
      if (Bs(r, { select: t }), document.activeElement !== n) return;
  }
  function PJ(e) {
    const t = UF(e), n = C2(t, e), r = C2(t.reverse(), e);
    return [n, r];
  }
  function UF(e) {
    const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const o = r.tagName === "INPUT" && r.type === "hidden";
        return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    for (; n.nextNode(); ) t.push(n.currentNode);
    return t;
  }
  function C2(e, t) {
    for (const n of e)
      if (!IJ(n, { upTo: t })) return n;
  }
  function IJ(e, { upTo: t }) {
    if (getComputedStyle(e).visibility === "hidden") return !0;
    for (; e; ) {
      if (t !== void 0 && e === t) return !1;
      if (getComputedStyle(e).display === "none") return !0;
      e = e.parentElement;
    }
    return !1;
  }
  function $J(e) {
    return e instanceof HTMLInputElement && "select" in e;
  }
  function Bs(e, { select: t = !1 } = {}) {
    if (e && e.focus) {
      const n = document.activeElement;
      e.focus({ preventScroll: !0 }), e !== n && $J(e) && t && e.select();
    }
  }
  var k2 = jJ();
  function jJ() {
    let e = [];
    return {
      add(t) {
        const n = e[0];
        t !== n && n?.pause(), e = T2(e, t), e.unshift(t);
      },
      remove(t) {
        e = T2(e, t), e[0]?.resume();
      }
    };
  }
  function T2(e, t) {
    const n = [...e], r = n.indexOf(t);
    return r !== -1 && n.splice(r, 1), n;
  }
  function DJ(e) {
    return e.filter((t) => t.tagName !== "A");
  }
  var FJ = "Portal", Sb = T.forwardRef((e, t) => {
    const { container: n, ...r } = e, [o, i] = T.useState(!1);
    qa(() => i(!0), []);
    const a = n || o && globalThis?.document?.body;
    return a ? dp.createPortal(/* @__PURE__ */ S.jsx(xt.div, { ...r, ref: t }), a) : null;
  });
  Sb.displayName = FJ;
  function LJ(e, t) {
    return T.useReducer((n, r) => t[n][r] ?? n, e);
  }
  var ii = (e) => {
    const { present: t, children: n } = e, r = zJ(t), o = typeof n == "function" ? n({ present: r.isPresent }) : T.Children.only(n), i = un(r.ref, BJ(o));
    return typeof n == "function" || r.isPresent ? T.cloneElement(o, { ref: i }) : null;
  };
  ii.displayName = "Presence";
  function zJ(e) {
    const [t, n] = T.useState(), r = T.useRef(null), o = T.useRef(e), i = T.useRef("none"), a = e ? "mounted" : "unmounted", [s, c] = LJ(a, {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
        MOUNT: "mounted",
        ANIMATION_END: "unmounted"
      },
      unmounted: {
        MOUNT: "mounted"
      }
    });
    return T.useEffect(() => {
      const u = Zg(r.current);
      i.current = s === "mounted" ? u : "none";
    }, [s]), qa(() => {
      const u = r.current, d = o.current;
      if (d !== e) {
        const m = i.current, g = Zg(u);
        e ? c("MOUNT") : g === "none" || u?.display === "none" ? c("UNMOUNT") : c(d && m !== g ? "ANIMATION_OUT" : "UNMOUNT"), o.current = e;
      }
    }, [e, c]), qa(() => {
      if (t) {
        let u;
        const d = t.ownerDocument.defaultView ?? window, p = (g) => {
          const b = Zg(r.current).includes(CSS.escape(g.animationName));
          if (g.target === t && b && (c("ANIMATION_END"), !o.current)) {
            const v = t.style.animationFillMode;
            t.style.animationFillMode = "forwards", u = d.setTimeout(() => {
              t.style.animationFillMode === "forwards" && (t.style.animationFillMode = v);
            });
          }
        }, m = (g) => {
          g.target === t && (i.current = Zg(r.current));
        };
        return t.addEventListener("animationstart", m), t.addEventListener("animationcancel", p), t.addEventListener("animationend", p), () => {
          d.clearTimeout(u), t.removeEventListener("animationstart", m), t.removeEventListener("animationcancel", p), t.removeEventListener("animationend", p);
        };
      } else
        c("ANIMATION_END");
    }, [t, c]), {
      isPresent: ["mounted", "unmountSuspended"].includes(s),
      ref: T.useCallback((u) => {
        r.current = u ? getComputedStyle(u) : null, n(u);
      }, [])
    };
  }
  function Zg(e) {
    return e?.animationName || "none";
  }
  function BJ(e) {
    let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning;
    return n ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
  }
  var SS = 0;
  function Pk() {
    T.useEffect(() => {
      const e = document.querySelectorAll("[data-radix-focus-guard]");
      return document.body.insertAdjacentElement("afterbegin", e[0] ?? A2()), document.body.insertAdjacentElement("beforeend", e[1] ?? A2()), SS++, () => {
        SS === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), SS--;
      };
    }, []);
  }
  function A2() {
    const e = document.createElement("span");
    return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
  }
  var Oi = function() {
    return Oi = Object.assign || function(t) {
      for (var n, r = 1, o = arguments.length; r < o; r++) {
        n = arguments[r];
        for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
      }
      return t;
    }, Oi.apply(this, arguments);
  };
  function VF(e, t) {
    var n = {};
    for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
    if (e != null && typeof Object.getOwnPropertySymbols == "function")
      for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
        t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
    return n;
  }
  function Tv(e, t, n) {
    if (n || arguments.length === 2) for (var r = 0, o = t.length, i; r < o; r++)
      (i || !(r in t)) && (i || (i = Array.prototype.slice.call(t, 0, r)), i[r] = t[r]);
    return e.concat(i || Array.prototype.slice.call(t));
  }
  var Av = "right-scroll-bar-position", Rv = "width-before-scroll-bar", UJ = "with-scroll-bars-hidden", VJ = "--removed-body-scroll-bar-size";
  function _S(e, t) {
    return typeof e == "function" ? e(t) : e && (e.current = t), e;
  }
  function HJ(e, t) {
    var n = T.useState(function() {
      return {
        // value
        value: e,
        // last callback
        callback: t,
        // "memoized" public interface
        facade: {
          get current() {
            return n.value;
          },
          set current(r) {
            var o = n.value;
            o !== r && (n.value = r, n.callback(r, o));
          }
        }
      };
    })[0];
    return n.callback = t, n.facade;
  }
  var qJ = typeof window < "u" ? T.useLayoutEffect : T.useEffect, R2 = /* @__PURE__ */ new WeakMap();
  function WJ(e, t) {
    var n = HJ(null, function(r) {
      return e.forEach(function(o) {
        return _S(o, r);
      });
    });
    return qJ(function() {
      var r = R2.get(n);
      if (r) {
        var o = new Set(r), i = new Set(e), a = n.current;
        o.forEach(function(s) {
          i.has(s) || _S(s, null);
        }), i.forEach(function(s) {
          o.has(s) || _S(s, a);
        });
      }
      R2.set(n, e);
    }, [e]), n;
  }
  function GJ(e) {
    return e;
  }
  function KJ(e, t) {
    t === void 0 && (t = GJ);
    var n = [], r = !1, o = {
      read: function() {
        if (r)
          throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
        return n.length ? n[n.length - 1] : e;
      },
      useMedium: function(i) {
        var a = t(i, r);
        return n.push(a), function() {
          n = n.filter(function(s) {
            return s !== a;
          });
        };
      },
      assignSyncMedium: function(i) {
        for (r = !0; n.length; ) {
          var a = n;
          n = [], a.forEach(i);
        }
        n = {
          push: function(s) {
            return i(s);
          },
          filter: function() {
            return n;
          }
        };
      },
      assignMedium: function(i) {
        r = !0;
        var a = [];
        if (n.length) {
          var s = n;
          n = [], s.forEach(i), a = n;
        }
        var c = function() {
          var d = a;
          a = [], d.forEach(i);
        }, u = function() {
          return Promise.resolve().then(c);
        };
        u(), n = {
          push: function(d) {
            a.push(d), u();
          },
          filter: function(d) {
            return a = a.filter(d), n;
          }
        };
      }
    };
    return o;
  }
  function YJ(e) {
    e === void 0 && (e = {});
    var t = KJ(null);
    return t.options = Oi({ async: !0, ssr: !1 }, e), t;
  }
  var HF = function(e) {
    var t = e.sideCar, n = VF(e, ["sideCar"]);
    if (!t)
      throw new Error("Sidecar: please provide `sideCar` property to import the right car");
    var r = t.read();
    if (!r)
      throw new Error("Sidecar medium not found");
    return T.createElement(r, Oi({}, n));
  };
  HF.isSideCarExport = !0;
  function XJ(e, t) {
    return e.useMedium(t), HF;
  }
  var qF = YJ(), ES = function() {
  }, _b = T.forwardRef(function(e, t) {
    var n = T.useRef(null), r = T.useState({
      onScrollCapture: ES,
      onWheelCapture: ES,
      onTouchMoveCapture: ES
    }), o = r[0], i = r[1], a = e.forwardProps, s = e.children, c = e.className, u = e.removeScrollBar, d = e.enabled, p = e.shards, m = e.sideCar, g = e.noRelative, y = e.noIsolation, b = e.inert, v = e.allowPinchZoom, x = e.as, E = x === void 0 ? "div" : x, _ = e.gapMode, C = VF(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), k = m, A = WJ([n, t]), O = Oi(Oi({}, C), o);
    return T.createElement(
      T.Fragment,
      null,
      d && T.createElement(k, { sideCar: qF, removeScrollBar: u, shards: p, noRelative: g, noIsolation: y, inert: b, setCallbacks: i, allowPinchZoom: !!v, lockRef: n, gapMode: _ }),
      a ? T.cloneElement(T.Children.only(s), Oi(Oi({}, O), { ref: A })) : T.createElement(E, Oi({}, O, { className: c, ref: A }), s)
    );
  });
  _b.defaultProps = {
    enabled: !0,
    removeScrollBar: !0,
    inert: !1
  };
  _b.classNames = {
    fullWidth: Rv,
    zeroRight: Av
  };
  var ZJ = function() {
    if (typeof __webpack_nonce__ < "u")
      return __webpack_nonce__;
  };
  function QJ() {
    if (!document)
      return null;
    var e = document.createElement("style");
    e.type = "text/css";
    var t = ZJ();
    return t && e.setAttribute("nonce", t), e;
  }
  function JJ(e, t) {
    e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
  }
  function eee(e) {
    var t = document.head || document.getElementsByTagName("head")[0];
    t.appendChild(e);
  }
  var tee = function() {
    var e = 0, t = null;
    return {
      add: function(n) {
        e == 0 && (t = QJ()) && (JJ(t, n), eee(t)), e++;
      },
      remove: function() {
        e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
      }
    };
  }, nee = function() {
    var e = tee();
    return function(t, n) {
      T.useEffect(function() {
        return e.add(t), function() {
          e.remove();
        };
      }, [t && n]);
    };
  }, WF = function() {
    var e = nee(), t = function(n) {
      var r = n.styles, o = n.dynamic;
      return e(r, o), null;
    };
    return t;
  }, ree = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
  }, CS = function(e) {
    return parseInt(e || "", 10) || 0;
  }, oee = function(e) {
    var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], o = t[e === "padding" ? "paddingRight" : "marginRight"];
    return [CS(n), CS(r), CS(o)];
  }, iee = function(e) {
    if (e === void 0 && (e = "margin"), typeof window > "u")
      return ree;
    var t = oee(e), n = document.documentElement.clientWidth, r = window.innerWidth;
    return {
      left: t[0],
      top: t[1],
      right: t[2],
      gap: Math.max(0, r - n + t[2] - t[0])
    };
  }, aee = WF(), ef = "data-scroll-locked", see = function(e, t, n, r) {
    var o = e.left, i = e.top, a = e.right, s = e.gap;
    return n === void 0 && (n = "margin"), `
  .`.concat(UJ, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(s, "px ").concat(r, `;
  }
  body[`).concat(ef, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
      t && "position: relative ".concat(r, ";"),
      n === "margin" && `
    padding-left: `.concat(o, `px;
    padding-top: `).concat(i, `px;
    padding-right: `).concat(a, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(s, "px ").concat(r, `;
    `),
      n === "padding" && "padding-right: ".concat(s, "px ").concat(r, ";")
    ].filter(Boolean).join(""), `
  }

  .`).concat(Av, ` {
    right: `).concat(s, "px ").concat(r, `;
  }

  .`).concat(Rv, ` {
    margin-right: `).concat(s, "px ").concat(r, `;
  }

  .`).concat(Av, " .").concat(Av, ` {
    right: 0 `).concat(r, `;
  }

  .`).concat(Rv, " .").concat(Rv, ` {
    margin-right: 0 `).concat(r, `;
  }

  body[`).concat(ef, `] {
    `).concat(VJ, ": ").concat(s, `px;
  }
`);
  }, O2 = function() {
    var e = parseInt(document.body.getAttribute(ef) || "0", 10);
    return isFinite(e) ? e : 0;
  }, lee = function() {
    T.useEffect(function() {
      return document.body.setAttribute(ef, (O2() + 1).toString()), function() {
        var e = O2() - 1;
        e <= 0 ? document.body.removeAttribute(ef) : document.body.setAttribute(ef, e.toString());
      };
    }, []);
  }, cee = function(e) {
    var t = e.noRelative, n = e.noImportant, r = e.gapMode, o = r === void 0 ? "margin" : r;
    lee();
    var i = T.useMemo(function() {
      return iee(o);
    }, [o]);
    return T.createElement(aee, { styles: see(i, !t, o, n ? "" : "!important") });
  }, AE = !1;
  if (typeof window < "u")
    try {
      var Qg = Object.defineProperty({}, "passive", {
        get: function() {
          return AE = !0, !0;
        }
      });
      window.addEventListener("test", Qg, Qg), window.removeEventListener("test", Qg, Qg);
    } catch {
      AE = !1;
    }
  var ku = AE ? { passive: !1 } : !1, uee = function(e) {
    return e.tagName === "TEXTAREA";
  }, GF = function(e, t) {
    if (!(e instanceof Element))
      return !1;
    var n = window.getComputedStyle(e);
    return (
      // not-not-scrollable
      n[t] !== "hidden" && // contains scroll inside self
      !(n.overflowY === n.overflowX && !uee(e) && n[t] === "visible")
    );
  }, fee = function(e) {
    return GF(e, "overflowY");
  }, dee = function(e) {
    return GF(e, "overflowX");
  }, M2 = function(e, t) {
    var n = t.ownerDocument, r = t;
    do {
      typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
      var o = KF(e, r);
      if (o) {
        var i = YF(e, r), a = i[1], s = i[2];
        if (a > s)
          return !0;
      }
      r = r.parentNode;
    } while (r && r !== n.body);
    return !1;
  }, pee = function(e) {
    var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
    return [
      t,
      n,
      r
    ];
  }, hee = function(e) {
    var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
    return [
      t,
      n,
      r
    ];
  }, KF = function(e, t) {
    return e === "v" ? fee(t) : dee(t);
  }, YF = function(e, t) {
    return e === "v" ? pee(t) : hee(t);
  }, mee = function(e, t) {
    return e === "h" && t === "rtl" ? -1 : 1;
  }, gee = function(e, t, n, r, o) {
    var i = mee(e, window.getComputedStyle(t).direction), a = i * r, s = n.target, c = t.contains(s), u = !1, d = a > 0, p = 0, m = 0;
    do {
      if (!s)
        break;
      var g = YF(e, s), y = g[0], b = g[1], v = g[2], x = b - v - i * y;
      (y || x) && KF(e, s) && (p += x, m += y);
      var E = s.parentNode;
      s = E && E.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? E.host : E;
    } while (
      // portaled content
      !c && s !== document.body || // self content
      c && (t.contains(s) || t === s)
    );
    return (d && Math.abs(p) < 1 || !d && Math.abs(m) < 1) && (u = !0), u;
  }, Jg = function(e) {
    return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
  }, N2 = function(e) {
    return [e.deltaX, e.deltaY];
  }, P2 = function(e) {
    return e && "current" in e ? e.current : e;
  }, yee = function(e, t) {
    return e[0] === t[0] && e[1] === t[1];
  }, vee = function(e) {
    return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
  }, bee = 0, Tu = [];
  function xee(e) {
    var t = T.useRef([]), n = T.useRef([0, 0]), r = T.useRef(), o = T.useState(bee++)[0], i = T.useState(WF)[0], a = T.useRef(e);
    T.useEffect(function() {
      a.current = e;
    }, [e]), T.useEffect(function() {
      if (e.inert) {
        document.body.classList.add("block-interactivity-".concat(o));
        var b = Tv([e.lockRef.current], (e.shards || []).map(P2), !0).filter(Boolean);
        return b.forEach(function(v) {
          return v.classList.add("allow-interactivity-".concat(o));
        }), function() {
          document.body.classList.remove("block-interactivity-".concat(o)), b.forEach(function(v) {
            return v.classList.remove("allow-interactivity-".concat(o));
          });
        };
      }
    }, [e.inert, e.lockRef.current, e.shards]);
    var s = T.useCallback(function(b, v) {
      if ("touches" in b && b.touches.length === 2 || b.type === "wheel" && b.ctrlKey)
        return !a.current.allowPinchZoom;
      var x = Jg(b), E = n.current, _ = "deltaX" in b ? b.deltaX : E[0] - x[0], C = "deltaY" in b ? b.deltaY : E[1] - x[1], k, A = b.target, O = Math.abs(_) > Math.abs(C) ? "h" : "v";
      if ("touches" in b && O === "h" && A.type === "range")
        return !1;
      var P = M2(O, A);
      if (!P)
        return !0;
      if (P ? k = O : (k = O === "v" ? "h" : "v", P = M2(O, A)), !P)
        return !1;
      if (!r.current && "changedTouches" in b && (_ || C) && (r.current = k), !k)
        return !0;
      var I = r.current || k;
      return gee(I, v, b, I === "h" ? _ : C);
    }, []), c = T.useCallback(function(b) {
      var v = b;
      if (!(!Tu.length || Tu[Tu.length - 1] !== i)) {
        var x = "deltaY" in v ? N2(v) : Jg(v), E = t.current.filter(function(k) {
          return k.name === v.type && (k.target === v.target || v.target === k.shadowParent) && yee(k.delta, x);
        })[0];
        if (E && E.should) {
          v.cancelable && v.preventDefault();
          return;
        }
        if (!E) {
          var _ = (a.current.shards || []).map(P2).filter(Boolean).filter(function(k) {
            return k.contains(v.target);
          }), C = _.length > 0 ? s(v, _[0]) : !a.current.noIsolation;
          C && v.cancelable && v.preventDefault();
        }
      }
    }, []), u = T.useCallback(function(b, v, x, E) {
      var _ = { name: b, delta: v, target: x, should: E, shadowParent: wee(x) };
      t.current.push(_), setTimeout(function() {
        t.current = t.current.filter(function(C) {
          return C !== _;
        });
      }, 1);
    }, []), d = T.useCallback(function(b) {
      n.current = Jg(b), r.current = void 0;
    }, []), p = T.useCallback(function(b) {
      u(b.type, N2(b), b.target, s(b, e.lockRef.current));
    }, []), m = T.useCallback(function(b) {
      u(b.type, Jg(b), b.target, s(b, e.lockRef.current));
    }, []);
    T.useEffect(function() {
      return Tu.push(i), e.setCallbacks({
        onScrollCapture: p,
        onWheelCapture: p,
        onTouchMoveCapture: m
      }), document.addEventListener("wheel", c, ku), document.addEventListener("touchmove", c, ku), document.addEventListener("touchstart", d, ku), function() {
        Tu = Tu.filter(function(b) {
          return b !== i;
        }), document.removeEventListener("wheel", c, ku), document.removeEventListener("touchmove", c, ku), document.removeEventListener("touchstart", d, ku);
      };
    }, []);
    var g = e.removeScrollBar, y = e.inert;
    return T.createElement(
      T.Fragment,
      null,
      y ? T.createElement(i, { styles: vee(o) }) : null,
      g ? T.createElement(cee, { noRelative: e.noRelative, gapMode: e.gapMode }) : null
    );
  }
  function wee(e) {
    for (var t = null; e !== null; )
      e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
    return t;
  }
  const See = XJ(qF, xee);
  var Eb = T.forwardRef(function(e, t) {
    return T.createElement(_b, Oi({}, e, { ref: t, sideCar: See }));
  });
  Eb.classNames = _b.classNames;
  var _ee = function(e) {
    if (typeof document > "u")
      return null;
    var t = Array.isArray(e) ? e[0] : e;
    return t.ownerDocument.body;
  }, Au = /* @__PURE__ */ new WeakMap(), ey = /* @__PURE__ */ new WeakMap(), ty = {}, kS = 0, XF = function(e) {
    return e && (e.host || XF(e.parentNode));
  }, Eee = function(e, t) {
    return t.map(function(n) {
      if (e.contains(n))
        return n;
      var r = XF(n);
      return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
    }).filter(function(n) {
      return !!n;
    });
  }, Cee = function(e, t, n, r) {
    var o = Eee(t, Array.isArray(e) ? e : [e]);
    ty[n] || (ty[n] = /* @__PURE__ */ new WeakMap());
    var i = ty[n], a = [], s = /* @__PURE__ */ new Set(), c = new Set(o), u = function(p) {
      !p || s.has(p) || (s.add(p), u(p.parentNode));
    };
    o.forEach(u);
    var d = function(p) {
      !p || c.has(p) || Array.prototype.forEach.call(p.children, function(m) {
        if (s.has(m))
          d(m);
        else
          try {
            var g = m.getAttribute(r), y = g !== null && g !== "false", b = (Au.get(m) || 0) + 1, v = (i.get(m) || 0) + 1;
            Au.set(m, b), i.set(m, v), a.push(m), b === 1 && y && ey.set(m, !0), v === 1 && m.setAttribute(n, "true"), y || m.setAttribute(r, "true");
          } catch (x) {
            console.error("aria-hidden: cannot operate on ", m, x);
          }
      });
    };
    return d(t), s.clear(), kS++, function() {
      a.forEach(function(p) {
        var m = Au.get(p) - 1, g = i.get(p) - 1;
        Au.set(p, m), i.set(p, g), m || (ey.has(p) || p.removeAttribute(r), ey.delete(p)), g || p.removeAttribute(n);
      }), kS--, kS || (Au = /* @__PURE__ */ new WeakMap(), Au = /* @__PURE__ */ new WeakMap(), ey = /* @__PURE__ */ new WeakMap(), ty = {});
    };
  }, Ik = function(e, t, n) {
    n === void 0 && (n = "data-aria-hidden");
    var r = Array.from(Array.isArray(e) ? e : [e]), o = _ee(e);
    return o ? (r.push.apply(r, Array.from(o.querySelectorAll("[aria-live], script"))), Cee(r, o, n, "aria-hidden")) : function() {
      return null;
    };
  }, Cb = "Dialog", [ZF] = Qi(Cb), [kee, ai] = ZF(Cb), QF = (e) => {
    const {
      __scopeDialog: t,
      children: n,
      open: r,
      defaultOpen: o,
      onOpenChange: i,
      modal: a = !0
    } = e, s = T.useRef(null), c = T.useRef(null), [u, d] = hl({
      prop: r,
      defaultProp: o ?? !1,
      onChange: i,
      caller: Cb
    });
    return /* @__PURE__ */ S.jsx(
      kee,
      {
        scope: t,
        triggerRef: s,
        contentRef: c,
        contentId: Vi(),
        titleId: Vi(),
        descriptionId: Vi(),
        open: u,
        onOpenChange: d,
        onOpenToggle: T.useCallback(() => d((p) => !p), [d]),
        modal: a,
        children: n
      }
    );
  };
  QF.displayName = Cb;
  var JF = "DialogTrigger", eL = T.forwardRef(
    (e, t) => {
      const { __scopeDialog: n, ...r } = e, o = ai(JF, n), i = un(t, o.triggerRef);
      return /* @__PURE__ */ S.jsx(
        xt.button,
        {
          type: "button",
          "aria-haspopup": "dialog",
          "aria-expanded": o.open,
          "aria-controls": o.contentId,
          "data-state": Dk(o.open),
          ...r,
          ref: i,
          onClick: Le(e.onClick, o.onOpenToggle)
        }
      );
    }
  );
  eL.displayName = JF;
  var $k = "DialogPortal", [Tee, tL] = ZF($k, {
    forceMount: void 0
  }), nL = (e) => {
    const { __scopeDialog: t, forceMount: n, children: r, container: o } = e, i = ai($k, t);
    return /* @__PURE__ */ S.jsx(Tee, { scope: t, forceMount: n, children: T.Children.map(r, (a) => /* @__PURE__ */ S.jsx(ii, { present: n || i.open, children: /* @__PURE__ */ S.jsx(Sb, { asChild: !0, container: o, children: a }) })) });
  };
  nL.displayName = $k;
  var i0 = "DialogOverlay", rL = T.forwardRef(
    (e, t) => {
      const n = tL(i0, e.__scopeDialog), { forceMount: r = n.forceMount, ...o } = e, i = ai(i0, e.__scopeDialog);
      return i.modal ? /* @__PURE__ */ S.jsx(ii, { present: r || i.open, children: /* @__PURE__ */ S.jsx(Ree, { ...o, ref: t }) }) : null;
    }
  );
  rL.displayName = i0;
  var Aee = /* @__PURE__ */ df("DialogOverlay.RemoveScroll"), Ree = T.forwardRef(
    (e, t) => {
      const { __scopeDialog: n, ...r } = e, o = ai(i0, n);
      return (
        // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
        // ie. when `Overlay` and `Content` are siblings
        /* @__PURE__ */ S.jsx(Eb, { as: Aee, allowPinchZoom: !0, shards: [o.contentRef], children: /* @__PURE__ */ S.jsx(
          xt.div,
          {
            "data-state": Dk(o.open),
            ...r,
            ref: t,
            style: { pointerEvents: "auto", ...r.style }
          }
        ) })
      );
    }
  ), lc = "DialogContent", oL = T.forwardRef(
    (e, t) => {
      const n = tL(lc, e.__scopeDialog), { forceMount: r = n.forceMount, ...o } = e, i = ai(lc, e.__scopeDialog);
      return /* @__PURE__ */ S.jsx(ii, { present: r || i.open, children: i.modal ? /* @__PURE__ */ S.jsx(Oee, { ...o, ref: t }) : /* @__PURE__ */ S.jsx(Mee, { ...o, ref: t }) });
    }
  );
  oL.displayName = lc;
  var Oee = T.forwardRef(
    (e, t) => {
      const n = ai(lc, e.__scopeDialog), r = T.useRef(null), o = un(t, n.contentRef, r);
      return T.useEffect(() => {
        const i = r.current;
        if (i) return Ik(i);
      }, []), /* @__PURE__ */ S.jsx(
        iL,
        {
          ...e,
          ref: o,
          trapFocus: n.open,
          disableOutsidePointerEvents: !0,
          onCloseAutoFocus: Le(e.onCloseAutoFocus, (i) => {
            i.preventDefault(), n.triggerRef.current?.focus();
          }),
          onPointerDownOutside: Le(e.onPointerDownOutside, (i) => {
            const a = i.detail.originalEvent, s = a.button === 0 && a.ctrlKey === !0;
            (a.button === 2 || s) && i.preventDefault();
          }),
          onFocusOutside: Le(
            e.onFocusOutside,
            (i) => i.preventDefault()
          )
        }
      );
    }
  ), Mee = T.forwardRef(
    (e, t) => {
      const n = ai(lc, e.__scopeDialog), r = T.useRef(!1), o = T.useRef(!1);
      return /* @__PURE__ */ S.jsx(
        iL,
        {
          ...e,
          ref: t,
          trapFocus: !1,
          disableOutsidePointerEvents: !1,
          onCloseAutoFocus: (i) => {
            e.onCloseAutoFocus?.(i), i.defaultPrevented || (r.current || n.triggerRef.current?.focus(), i.preventDefault()), r.current = !1, o.current = !1;
          },
          onInteractOutside: (i) => {
            e.onInteractOutside?.(i), i.defaultPrevented || (r.current = !0, i.detail.originalEvent.type === "pointerdown" && (o.current = !0));
            const a = i.target;
            n.triggerRef.current?.contains(a) && i.preventDefault(), i.detail.originalEvent.type === "focusin" && o.current && i.preventDefault();
          }
        }
      );
    }
  ), iL = T.forwardRef(
    (e, t) => {
      const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: o, onCloseAutoFocus: i, ...a } = e, s = ai(lc, n), c = T.useRef(null), u = un(t, c);
      return Pk(), /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
        /* @__PURE__ */ S.jsx(
          wb,
          {
            asChild: !0,
            loop: !0,
            trapped: r,
            onMountAutoFocus: o,
            onUnmountAutoFocus: i,
            children: /* @__PURE__ */ S.jsx(
              zh,
              {
                role: "dialog",
                id: s.contentId,
                "aria-describedby": s.descriptionId,
                "aria-labelledby": s.titleId,
                "data-state": Dk(s.open),
                ...a,
                ref: u,
                onDismiss: () => s.onOpenChange(!1)
              }
            )
          }
        ),
        /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
          /* @__PURE__ */ S.jsx(Nee, { titleId: s.titleId }),
          /* @__PURE__ */ S.jsx(Iee, { contentRef: c, descriptionId: s.descriptionId })
        ] })
      ] });
    }
  ), jk = "DialogTitle", aL = T.forwardRef(
    (e, t) => {
      const { __scopeDialog: n, ...r } = e, o = ai(jk, n);
      return /* @__PURE__ */ S.jsx(xt.h2, { id: o.titleId, ...r, ref: t });
    }
  );
  aL.displayName = jk;
  var sL = "DialogDescription", lL = T.forwardRef(
    (e, t) => {
      const { __scopeDialog: n, ...r } = e, o = ai(sL, n);
      return /* @__PURE__ */ S.jsx(xt.p, { id: o.descriptionId, ...r, ref: t });
    }
  );
  lL.displayName = sL;
  var cL = "DialogClose", uL = T.forwardRef(
    (e, t) => {
      const { __scopeDialog: n, ...r } = e, o = ai(cL, n);
      return /* @__PURE__ */ S.jsx(
        xt.button,
        {
          type: "button",
          ...r,
          ref: t,
          onClick: Le(e.onClick, () => o.onOpenChange(!1))
        }
      );
    }
  );
  uL.displayName = cL;
  function Dk(e) {
    return e ? "open" : "closed";
  }
  var fL = "DialogTitleWarning", [vze, dL] = cJ(fL, {
    contentName: lc,
    titleName: jk,
    docsSlug: "dialog"
  }), Nee = ({ titleId: e }) => {
    const t = dL(fL), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
    return T.useEffect(() => {
      e && (document.getElementById(e) || console.error(n));
    }, [n, e]), null;
  }, Pee = "DialogDescriptionWarning", Iee = ({ contentRef: e, descriptionId: t }) => {
    const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${dL(Pee).contentName}}.`;
    return T.useEffect(() => {
      const o = e.current?.getAttribute("aria-describedby");
      t && o && (document.getElementById(t) || console.warn(r));
    }, [r, e, t]), null;
  }, $ee = QF, jee = eL, Dee = nL, Fee = rL, Lee = oL, I2 = aL, zee = lL, pL = uL, Bee = Object.freeze({
    // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
    position: "absolute",
    border: 0,
    width: 1,
    height: 1,
    padding: 0,
    margin: -1,
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    wordWrap: "normal"
  }), Uee = "VisuallyHidden", kb = T.forwardRef(
    (e, t) => /* @__PURE__ */ S.jsx(
      xt.span,
      {
        ...e,
        ref: t,
        style: { ...Bee, ...e.style }
      }
    )
  );
  kb.displayName = Uee;
  var Vee = kb;
  function RE(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
    return r;
  }
  function Hee(e) {
    if (Array.isArray(e)) return e;
  }
  function qee(e) {
    if (Array.isArray(e)) return RE(e);
  }
  function Wee(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
  }
  function Gee(e, t) {
    for (var n = 0; n < t.length; n++) {
      var r = t[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, hL(r.key), r);
    }
  }
  function Kee(e, t, n) {
    return t && Gee(e.prototype, t), Object.defineProperty(e, "prototype", {
      writable: !1
    }), e;
  }
  function Ov(e, t) {
    var n = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (!n) {
      if (Array.isArray(e) || (n = Fk(e)) || t) {
        n && (e = n);
        var r = 0, o = function() {
        };
        return {
          s: o,
          n: function() {
            return r >= e.length ? {
              done: !0
            } : {
              done: !1,
              value: e[r++]
            };
          },
          e: function(c) {
            throw c;
          },
          f: o
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var i, a = !0, s = !1;
    return {
      s: function() {
        n = n.call(e);
      },
      n: function() {
        var c = n.next();
        return a = c.done, c;
      },
      e: function(c) {
        s = !0, i = c;
      },
      f: function() {
        try {
          a || n.return == null || n.return();
        } finally {
          if (s) throw i;
        }
      }
    };
  }
  function ht(e, t, n) {
    return (t = hL(t)) in e ? Object.defineProperty(e, t, {
      value: n,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[t] = n, e;
  }
  function Yee(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
  }
  function Xee(e, t) {
    var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n != null) {
      var r, o, i, a, s = [], c = !0, u = !1;
      try {
        if (i = (n = n.call(e)).next, t === 0) {
          if (Object(n) !== n) return;
          c = !1;
        } else for (; !(c = (r = i.call(n)).done) && (s.push(r.value), s.length !== t); c = !0) ;
      } catch (d) {
        u = !0, o = d;
      } finally {
        try {
          if (!c && n.return != null && (a = n.return(), Object(a) !== a)) return;
        } finally {
          if (u) throw o;
        }
      }
      return s;
    }
  }
  function Zee() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function Qee() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function $2(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var r = Object.getOwnPropertySymbols(e);
      t && (r = r.filter(function(o) {
        return Object.getOwnPropertyDescriptor(e, o).enumerable;
      })), n.push.apply(n, r);
    }
    return n;
  }
  function Te(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t] != null ? arguments[t] : {};
      t % 2 ? $2(Object(n), !0).forEach(function(r) {
        ht(e, r, n[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $2(Object(n)).forEach(function(r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
      });
    }
    return e;
  }
  function Tb(e, t) {
    return Hee(e) || Xee(e, t) || Fk(e, t) || Zee();
  }
  function ti(e) {
    return qee(e) || Yee(e) || Fk(e) || Qee();
  }
  function Jee(e, t) {
    if (typeof e != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
      var r = n.call(e, t);
      if (typeof r != "object") return r;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (t === "string" ? String : Number)(e);
  }
  function hL(e) {
    var t = Jee(e, "string");
    return typeof t == "symbol" ? t : t + "";
  }
  function a0(e) {
    "@babel/helpers - typeof";
    return a0 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
      return typeof t;
    } : function(t) {
      return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
    }, a0(e);
  }
  function Fk(e, t) {
    if (e) {
      if (typeof e == "string") return RE(e, t);
      var n = {}.toString.call(e).slice(8, -1);
      return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? RE(e, t) : void 0;
    }
  }
  var j2 = function() {
  }, Lk = {}, mL = {}, gL = null, yL = {
    mark: j2,
    measure: j2
  };
  try {
    typeof window < "u" && (Lk = window), typeof document < "u" && (mL = document), typeof MutationObserver < "u" && (gL = MutationObserver), typeof performance < "u" && (yL = performance);
  } catch {
  }
  var ete = Lk.navigator || {}, D2 = ete.userAgent, F2 = D2 === void 0 ? "" : D2, ol = Lk, vn = mL, L2 = gL, ny = yL;
  ol.document;
  var Ja = !!vn.documentElement && !!vn.head && typeof vn.addEventListener == "function" && typeof vn.createElement == "function", vL = ~F2.indexOf("MSIE") || ~F2.indexOf("Trident/"), TS, tte = /fa(k|kd|s|r|l|t|d|dr|dl|dt|b|slr|slpr|wsb|tl|ns|nds|es|jr|jfr|jdr|usb|ufsb|udsb|cr|ss|sr|sl|st|sds|sdr|sdl|sdt)?[\-\ ]/, nte = /Font ?Awesome ?([567 ]*)(Solid|Regular|Light|Thin|Duotone|Brands|Free|Pro|Sharp Duotone|Sharp|Kit|Notdog Duo|Notdog|Chisel|Etch|Thumbprint|Jelly Fill|Jelly Duo|Jelly|Utility|Utility Fill|Utility Duo|Slab Press|Slab|Whiteboard)?.*/i, bL = {
    classic: {
      fa: "solid",
      fas: "solid",
      "fa-solid": "solid",
      far: "regular",
      "fa-regular": "regular",
      fal: "light",
      "fa-light": "light",
      fat: "thin",
      "fa-thin": "thin",
      fab: "brands",
      "fa-brands": "brands"
    },
    duotone: {
      fa: "solid",
      fad: "solid",
      "fa-solid": "solid",
      "fa-duotone": "solid",
      fadr: "regular",
      "fa-regular": "regular",
      fadl: "light",
      "fa-light": "light",
      fadt: "thin",
      "fa-thin": "thin"
    },
    sharp: {
      fa: "solid",
      fass: "solid",
      "fa-solid": "solid",
      fasr: "regular",
      "fa-regular": "regular",
      fasl: "light",
      "fa-light": "light",
      fast: "thin",
      "fa-thin": "thin"
    },
    "sharp-duotone": {
      fa: "solid",
      fasds: "solid",
      "fa-solid": "solid",
      fasdr: "regular",
      "fa-regular": "regular",
      fasdl: "light",
      "fa-light": "light",
      fasdt: "thin",
      "fa-thin": "thin"
    },
    slab: {
      "fa-regular": "regular",
      faslr: "regular"
    },
    "slab-press": {
      "fa-regular": "regular",
      faslpr: "regular"
    },
    thumbprint: {
      "fa-light": "light",
      fatl: "light"
    },
    whiteboard: {
      "fa-semibold": "semibold",
      fawsb: "semibold"
    },
    notdog: {
      "fa-solid": "solid",
      fans: "solid"
    },
    "notdog-duo": {
      "fa-solid": "solid",
      fands: "solid"
    },
    etch: {
      "fa-solid": "solid",
      faes: "solid"
    },
    jelly: {
      "fa-regular": "regular",
      fajr: "regular"
    },
    "jelly-fill": {
      "fa-regular": "regular",
      fajfr: "regular"
    },
    "jelly-duo": {
      "fa-regular": "regular",
      fajdr: "regular"
    },
    chisel: {
      "fa-regular": "regular",
      facr: "regular"
    },
    utility: {
      "fa-semibold": "semibold",
      fausb: "semibold"
    },
    "utility-duo": {
      "fa-semibold": "semibold",
      faudsb: "semibold"
    },
    "utility-fill": {
      "fa-semibold": "semibold",
      faufsb: "semibold"
    }
  }, rte = {
    GROUP: "duotone-group",
    PRIMARY: "primary",
    SECONDARY: "secondary"
  }, xL = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone", "fa-thumbprint", "fa-whiteboard", "fa-notdog", "fa-notdog-duo", "fa-chisel", "fa-etch", "fa-jelly", "fa-jelly-fill", "fa-jelly-duo", "fa-slab", "fa-slab-press", "fa-utility", "fa-utility-duo", "fa-utility-fill"], dr = "classic", Bh = "duotone", wL = "sharp", SL = "sharp-duotone", _L = "chisel", EL = "etch", CL = "jelly", kL = "jelly-duo", TL = "jelly-fill", AL = "notdog", RL = "notdog-duo", OL = "slab", ML = "slab-press", NL = "thumbprint", PL = "utility", IL = "utility-duo", $L = "utility-fill", jL = "whiteboard", ote = "Classic", ite = "Duotone", ate = "Sharp", ste = "Sharp Duotone", lte = "Chisel", cte = "Etch", ute = "Jelly", fte = "Jelly Duo", dte = "Jelly Fill", pte = "Notdog", hte = "Notdog Duo", mte = "Slab", gte = "Slab Press", yte = "Thumbprint", vte = "Utility", bte = "Utility Duo", xte = "Utility Fill", wte = "Whiteboard", DL = [dr, Bh, wL, SL, _L, EL, CL, kL, TL, AL, RL, OL, ML, NL, PL, IL, $L, jL];
  TS = {}, ht(ht(ht(ht(ht(ht(ht(ht(ht(ht(TS, dr, ote), Bh, ite), wL, ate), SL, ste), _L, lte), EL, cte), CL, ute), kL, fte), TL, dte), AL, pte), ht(ht(ht(ht(ht(ht(ht(ht(TS, RL, hte), OL, mte), ML, gte), NL, yte), PL, vte), IL, bte), $L, xte), jL, wte);
  var Ste = {
    classic: {
      900: "fas",
      400: "far",
      normal: "far",
      300: "fal",
      100: "fat"
    },
    duotone: {
      900: "fad",
      400: "fadr",
      300: "fadl",
      100: "fadt"
    },
    sharp: {
      900: "fass",
      400: "fasr",
      300: "fasl",
      100: "fast"
    },
    "sharp-duotone": {
      900: "fasds",
      400: "fasdr",
      300: "fasdl",
      100: "fasdt"
    },
    slab: {
      400: "faslr"
    },
    "slab-press": {
      400: "faslpr"
    },
    whiteboard: {
      600: "fawsb"
    },
    thumbprint: {
      300: "fatl"
    },
    notdog: {
      900: "fans"
    },
    "notdog-duo": {
      900: "fands"
    },
    etch: {
      900: "faes"
    },
    chisel: {
      400: "facr"
    },
    jelly: {
      400: "fajr"
    },
    "jelly-fill": {
      400: "fajfr"
    },
    "jelly-duo": {
      400: "fajdr"
    },
    utility: {
      600: "fausb"
    },
    "utility-duo": {
      600: "faudsb"
    },
    "utility-fill": {
      600: "faufsb"
    }
  }, _te = {
    "Font Awesome 7 Free": {
      900: "fas",
      400: "far"
    },
    "Font Awesome 7 Pro": {
      900: "fas",
      400: "far",
      normal: "far",
      300: "fal",
      100: "fat"
    },
    "Font Awesome 7 Brands": {
      400: "fab",
      normal: "fab"
    },
    "Font Awesome 7 Duotone": {
      900: "fad",
      400: "fadr",
      normal: "fadr",
      300: "fadl",
      100: "fadt"
    },
    "Font Awesome 7 Sharp": {
      900: "fass",
      400: "fasr",
      normal: "fasr",
      300: "fasl",
      100: "fast"
    },
    "Font Awesome 7 Sharp Duotone": {
      900: "fasds",
      400: "fasdr",
      normal: "fasdr",
      300: "fasdl",
      100: "fasdt"
    },
    "Font Awesome 7 Jelly": {
      400: "fajr",
      normal: "fajr"
    },
    "Font Awesome 7 Jelly Fill": {
      400: "fajfr",
      normal: "fajfr"
    },
    "Font Awesome 7 Jelly Duo": {
      400: "fajdr",
      normal: "fajdr"
    },
    "Font Awesome 7 Slab": {
      400: "faslr",
      normal: "faslr"
    },
    "Font Awesome 7 Slab Press": {
      400: "faslpr",
      normal: "faslpr"
    },
    "Font Awesome 7 Thumbprint": {
      300: "fatl",
      normal: "fatl"
    },
    "Font Awesome 7 Notdog": {
      900: "fans",
      normal: "fans"
    },
    "Font Awesome 7 Notdog Duo": {
      900: "fands",
      normal: "fands"
    },
    "Font Awesome 7 Etch": {
      900: "faes",
      normal: "faes"
    },
    "Font Awesome 7 Chisel": {
      400: "facr",
      normal: "facr"
    },
    "Font Awesome 7 Whiteboard": {
      600: "fawsb",
      normal: "fawsb"
    },
    "Font Awesome 7 Utility": {
      600: "fausb",
      normal: "fausb"
    },
    "Font Awesome 7 Utility Duo": {
      600: "faudsb",
      normal: "faudsb"
    },
    "Font Awesome 7 Utility Fill": {
      600: "faufsb",
      normal: "faufsb"
    }
  }, Ete = /* @__PURE__ */ new Map([["classic", {
    defaultShortPrefixId: "fas",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin", "brands"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["duotone", {
    defaultShortPrefixId: "fad",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["sharp", {
    defaultShortPrefixId: "fass",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["sharp-duotone", {
    defaultShortPrefixId: "fasds",
    defaultStyleId: "solid",
    styleIds: ["solid", "regular", "light", "thin"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["chisel", {
    defaultShortPrefixId: "facr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["etch", {
    defaultShortPrefixId: "faes",
    defaultStyleId: "solid",
    styleIds: ["solid"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["jelly", {
    defaultShortPrefixId: "fajr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["jelly-duo", {
    defaultShortPrefixId: "fajdr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["jelly-fill", {
    defaultShortPrefixId: "fajfr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["notdog", {
    defaultShortPrefixId: "fans",
    defaultStyleId: "solid",
    styleIds: ["solid"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["notdog-duo", {
    defaultShortPrefixId: "fands",
    defaultStyleId: "solid",
    styleIds: ["solid"],
    futureStyleIds: [],
    defaultFontWeight: 900
  }], ["slab", {
    defaultShortPrefixId: "faslr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["slab-press", {
    defaultShortPrefixId: "faslpr",
    defaultStyleId: "regular",
    styleIds: ["regular"],
    futureStyleIds: [],
    defaultFontWeight: 400
  }], ["thumbprint", {
    defaultShortPrefixId: "fatl",
    defaultStyleId: "light",
    styleIds: ["light"],
    futureStyleIds: [],
    defaultFontWeight: 300
  }], ["utility", {
    defaultShortPrefixId: "fausb",
    defaultStyleId: "semibold",
    styleIds: ["semibold"],
    futureStyleIds: [],
    defaultFontWeight: 600
  }], ["utility-duo", {
    defaultShortPrefixId: "faudsb",
    defaultStyleId: "semibold",
    styleIds: ["semibold"],
    futureStyleIds: [],
    defaultFontWeight: 600
  }], ["utility-fill", {
    defaultShortPrefixId: "faufsb",
    defaultStyleId: "semibold",
    styleIds: ["semibold"],
    futureStyleIds: [],
    defaultFontWeight: 600
  }], ["whiteboard", {
    defaultShortPrefixId: "fawsb",
    defaultStyleId: "semibold",
    styleIds: ["semibold"],
    futureStyleIds: [],
    defaultFontWeight: 600
  }]]), Cte = {
    chisel: {
      regular: "facr"
    },
    classic: {
      brands: "fab",
      light: "fal",
      regular: "far",
      solid: "fas",
      thin: "fat"
    },
    duotone: {
      light: "fadl",
      regular: "fadr",
      solid: "fad",
      thin: "fadt"
    },
    etch: {
      solid: "faes"
    },
    jelly: {
      regular: "fajr"
    },
    "jelly-duo": {
      regular: "fajdr"
    },
    "jelly-fill": {
      regular: "fajfr"
    },
    notdog: {
      solid: "fans"
    },
    "notdog-duo": {
      solid: "fands"
    },
    sharp: {
      light: "fasl",
      regular: "fasr",
      solid: "fass",
      thin: "fast"
    },
    "sharp-duotone": {
      light: "fasdl",
      regular: "fasdr",
      solid: "fasds",
      thin: "fasdt"
    },
    slab: {
      regular: "faslr"
    },
    "slab-press": {
      regular: "faslpr"
    },
    thumbprint: {
      light: "fatl"
    },
    utility: {
      semibold: "fausb"
    },
    "utility-duo": {
      semibold: "faudsb"
    },
    "utility-fill": {
      semibold: "faufsb"
    },
    whiteboard: {
      semibold: "fawsb"
    }
  }, FL = ["fak", "fa-kit", "fakd", "fa-kit-duotone"], z2 = {
    kit: {
      fak: "kit",
      "fa-kit": "kit"
    },
    "kit-duotone": {
      fakd: "kit-duotone",
      "fa-kit-duotone": "kit-duotone"
    }
  }, kte = ["kit"], Tte = "kit", Ate = "kit-duotone", Rte = "Kit", Ote = "Kit Duotone";
  ht(ht({}, Tte, Rte), Ate, Ote);
  var Mte = {
    kit: {
      "fa-kit": "fak"
    }
  }, Nte = {
    "Font Awesome Kit": {
      400: "fak",
      normal: "fak"
    },
    "Font Awesome Kit Duotone": {
      400: "fakd",
      normal: "fakd"
    }
  }, Pte = {
    kit: {
      fak: "fa-kit"
    }
  }, B2 = {
    kit: {
      kit: "fak"
    },
    "kit-duotone": {
      "kit-duotone": "fakd"
    }
  }, AS, ry = {
    GROUP: "duotone-group",
    SWAP_OPACITY: "swap-opacity",
    PRIMARY: "primary",
    SECONDARY: "secondary"
  }, Ite = ["fa-classic", "fa-duotone", "fa-sharp", "fa-sharp-duotone", "fa-thumbprint", "fa-whiteboard", "fa-notdog", "fa-notdog-duo", "fa-chisel", "fa-etch", "fa-jelly", "fa-jelly-fill", "fa-jelly-duo", "fa-slab", "fa-slab-press", "fa-utility", "fa-utility-duo", "fa-utility-fill"], $te = "classic", jte = "duotone", Dte = "sharp", Fte = "sharp-duotone", Lte = "chisel", zte = "etch", Bte = "jelly", Ute = "jelly-duo", Vte = "jelly-fill", Hte = "notdog", qte = "notdog-duo", Wte = "slab", Gte = "slab-press", Kte = "thumbprint", Yte = "utility", Xte = "utility-duo", Zte = "utility-fill", Qte = "whiteboard", Jte = "Classic", ene = "Duotone", tne = "Sharp", nne = "Sharp Duotone", rne = "Chisel", one = "Etch", ine = "Jelly", ane = "Jelly Duo", sne = "Jelly Fill", lne = "Notdog", cne = "Notdog Duo", une = "Slab", fne = "Slab Press", dne = "Thumbprint", pne = "Utility", hne = "Utility Duo", mne = "Utility Fill", gne = "Whiteboard";
  AS = {}, ht(ht(ht(ht(ht(ht(ht(ht(ht(ht(AS, $te, Jte), jte, ene), Dte, tne), Fte, nne), Lte, rne), zte, one), Bte, ine), Ute, ane), Vte, sne), Hte, lne), ht(ht(ht(ht(ht(ht(ht(ht(AS, qte, cne), Wte, une), Gte, fne), Kte, dne), Yte, pne), Xte, hne), Zte, mne), Qte, gne);
  var yne = "kit", vne = "kit-duotone", bne = "Kit", xne = "Kit Duotone";
  ht(ht({}, yne, bne), vne, xne);
  var wne = {
    classic: {
      "fa-brands": "fab",
      "fa-duotone": "fad",
      "fa-light": "fal",
      "fa-regular": "far",
      "fa-solid": "fas",
      "fa-thin": "fat"
    },
    duotone: {
      "fa-regular": "fadr",
      "fa-light": "fadl",
      "fa-thin": "fadt"
    },
    sharp: {
      "fa-solid": "fass",
      "fa-regular": "fasr",
      "fa-light": "fasl",
      "fa-thin": "fast"
    },
    "sharp-duotone": {
      "fa-solid": "fasds",
      "fa-regular": "fasdr",
      "fa-light": "fasdl",
      "fa-thin": "fasdt"
    },
    slab: {
      "fa-regular": "faslr"
    },
    "slab-press": {
      "fa-regular": "faslpr"
    },
    whiteboard: {
      "fa-semibold": "fawsb"
    },
    thumbprint: {
      "fa-light": "fatl"
    },
    notdog: {
      "fa-solid": "fans"
    },
    "notdog-duo": {
      "fa-solid": "fands"
    },
    etch: {
      "fa-solid": "faes"
    },
    jelly: {
      "fa-regular": "fajr"
    },
    "jelly-fill": {
      "fa-regular": "fajfr"
    },
    "jelly-duo": {
      "fa-regular": "fajdr"
    },
    chisel: {
      "fa-regular": "facr"
    },
    utility: {
      "fa-semibold": "fausb"
    },
    "utility-duo": {
      "fa-semibold": "faudsb"
    },
    "utility-fill": {
      "fa-semibold": "faufsb"
    }
  }, Sne = {
    classic: ["fas", "far", "fal", "fat", "fad"],
    duotone: ["fadr", "fadl", "fadt"],
    sharp: ["fass", "fasr", "fasl", "fast"],
    "sharp-duotone": ["fasds", "fasdr", "fasdl", "fasdt"],
    slab: ["faslr"],
    "slab-press": ["faslpr"],
    whiteboard: ["fawsb"],
    thumbprint: ["fatl"],
    notdog: ["fans"],
    "notdog-duo": ["fands"],
    etch: ["faes"],
    jelly: ["fajr"],
    "jelly-fill": ["fajfr"],
    "jelly-duo": ["fajdr"],
    chisel: ["facr"],
    utility: ["fausb"],
    "utility-duo": ["faudsb"],
    "utility-fill": ["faufsb"]
  }, OE = {
    classic: {
      fab: "fa-brands",
      fad: "fa-duotone",
      fal: "fa-light",
      far: "fa-regular",
      fas: "fa-solid",
      fat: "fa-thin"
    },
    duotone: {
      fadr: "fa-regular",
      fadl: "fa-light",
      fadt: "fa-thin"
    },
    sharp: {
      fass: "fa-solid",
      fasr: "fa-regular",
      fasl: "fa-light",
      fast: "fa-thin"
    },
    "sharp-duotone": {
      fasds: "fa-solid",
      fasdr: "fa-regular",
      fasdl: "fa-light",
      fasdt: "fa-thin"
    },
    slab: {
      faslr: "fa-regular"
    },
    "slab-press": {
      faslpr: "fa-regular"
    },
    whiteboard: {
      fawsb: "fa-semibold"
    },
    thumbprint: {
      fatl: "fa-light"
    },
    notdog: {
      fans: "fa-solid"
    },
    "notdog-duo": {
      fands: "fa-solid"
    },
    etch: {
      faes: "fa-solid"
    },
    jelly: {
      fajr: "fa-regular"
    },
    "jelly-fill": {
      fajfr: "fa-regular"
    },
    "jelly-duo": {
      fajdr: "fa-regular"
    },
    chisel: {
      facr: "fa-regular"
    },
    utility: {
      fausb: "fa-semibold"
    },
    "utility-duo": {
      faudsb: "fa-semibold"
    },
    "utility-fill": {
      faufsb: "fa-semibold"
    }
  }, _ne = ["fa-solid", "fa-regular", "fa-light", "fa-thin", "fa-duotone", "fa-brands", "fa-semibold"], LL = ["fa", "fas", "far", "fal", "fat", "fad", "fadr", "fadl", "fadt", "fab", "fass", "fasr", "fasl", "fast", "fasds", "fasdr", "fasdl", "fasdt", "faslr", "faslpr", "fawsb", "fatl", "fans", "fands", "faes", "fajr", "fajfr", "fajdr", "facr", "fausb", "faudsb", "faufsb"].concat(Ite, _ne), Ene = ["solid", "regular", "light", "thin", "duotone", "brands", "semibold"], zL = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], Cne = zL.concat([11, 12, 13, 14, 15, 16, 17, 18, 19, 20]), kne = ["aw", "fw", "pull-left", "pull-right"], Tne = [].concat(ti(Object.keys(Sne)), Ene, kne, ["2xs", "xs", "sm", "lg", "xl", "2xl", "beat", "border", "fade", "beat-fade", "bounce", "flip-both", "flip-horizontal", "flip-vertical", "flip", "inverse", "layers", "layers-bottom-left", "layers-bottom-right", "layers-counter", "layers-text", "layers-top-left", "layers-top-right", "li", "pull-end", "pull-start", "pulse", "rotate-180", "rotate-270", "rotate-90", "rotate-by", "shake", "spin-pulse", "spin-reverse", "spin", "stack-1x", "stack-2x", "stack", "ul", "width-auto", "width-fixed", ry.GROUP, ry.SWAP_OPACITY, ry.PRIMARY, ry.SECONDARY]).concat(zL.map(function(e) {
    return "".concat(e, "x");
  })).concat(Cne.map(function(e) {
    return "w-".concat(e);
  })), Ane = {
    "Font Awesome 5 Free": {
      900: "fas",
      400: "far"
    },
    "Font Awesome 5 Pro": {
      900: "fas",
      400: "far",
      normal: "far",
      300: "fal"
    },
    "Font Awesome 5 Brands": {
      400: "fab",
      normal: "fab"
    },
    "Font Awesome 5 Duotone": {
      900: "fad"
    }
  }, Wa = "___FONT_AWESOME___", ME = 16, BL = "fa", UL = "svg-inline--fa", cc = "data-fa-i2svg", NE = "data-fa-pseudo-element", Rne = "data-fa-pseudo-element-pending", zk = "data-prefix", Bk = "data-icon", U2 = "fontawesome-i2svg", One = "async", Mne = ["HTML", "HEAD", "STYLE", "SCRIPT"], VL = ["::before", "::after", ":before", ":after"], HL = (function() {
    try {
      return !0;
    } catch {
      return !1;
    }
  })();
  function Uh(e) {
    return new Proxy(e, {
      get: function(n, r) {
        return r in n ? n[r] : n[dr];
      }
    });
  }
  var qL = Te({}, bL);
  qL[dr] = Te(Te(Te(Te({}, {
    "fa-duotone": "duotone"
  }), bL[dr]), z2.kit), z2["kit-duotone"]);
  var Nne = Uh(qL), PE = Te({}, Cte);
  PE[dr] = Te(Te(Te(Te({}, {
    duotone: "fad"
  }), PE[dr]), B2.kit), B2["kit-duotone"]);
  var V2 = Uh(PE), IE = Te({}, OE);
  IE[dr] = Te(Te({}, IE[dr]), Pte.kit);
  var Uk = Uh(IE), $E = Te({}, wne);
  $E[dr] = Te(Te({}, $E[dr]), Mte.kit);
  Uh($E);
  var Pne = tte, WL = "fa-layers-text", Ine = nte, $ne = Te({}, Ste);
  Uh($ne);
  var jne = ["class", "data-prefix", "data-icon", "data-fa-transform", "data-fa-mask"], RS = rte, Dne = [].concat(ti(kte), ti(Tne)), Rp = ol.FontAwesomeConfig || {};
  function Fne(e) {
    var t = vn.querySelector("script[" + e + "]");
    if (t)
      return t.getAttribute(e);
  }
  function Lne(e) {
    return e === "" ? !0 : e === "false" ? !1 : e === "true" ? !0 : e;
  }
  if (vn && typeof vn.querySelector == "function") {
    var zne = [["data-family-prefix", "familyPrefix"], ["data-css-prefix", "cssPrefix"], ["data-family-default", "familyDefault"], ["data-style-default", "styleDefault"], ["data-replacement-class", "replacementClass"], ["data-auto-replace-svg", "autoReplaceSvg"], ["data-auto-add-css", "autoAddCss"], ["data-search-pseudo-elements", "searchPseudoElements"], ["data-search-pseudo-elements-warnings", "searchPseudoElementsWarnings"], ["data-search-pseudo-elements-full-scan", "searchPseudoElementsFullScan"], ["data-observe-mutations", "observeMutations"], ["data-mutate-approach", "mutateApproach"], ["data-keep-original-source", "keepOriginalSource"], ["data-measure-performance", "measurePerformance"], ["data-show-missing-icons", "showMissingIcons"]];
    zne.forEach(function(e) {
      var t = Tb(e, 2), n = t[0], r = t[1], o = Lne(Fne(n));
      o != null && (Rp[r] = o);
    });
  }
  var GL = {
    styleDefault: "solid",
    familyDefault: dr,
    cssPrefix: BL,
    replacementClass: UL,
    autoReplaceSvg: !0,
    autoAddCss: !0,
    searchPseudoElements: !1,
    searchPseudoElementsWarnings: !0,
    searchPseudoElementsFullScan: !1,
    observeMutations: !0,
    mutateApproach: "async",
    keepOriginalSource: !0,
    measurePerformance: !1,
    showMissingIcons: !0
  };
  Rp.familyPrefix && (Rp.cssPrefix = Rp.familyPrefix);
  var pf = Te(Te({}, GL), Rp);
  pf.autoReplaceSvg || (pf.observeMutations = !1);
  var Ge = {};
  Object.keys(GL).forEach(function(e) {
    Object.defineProperty(Ge, e, {
      enumerable: !0,
      set: function(n) {
        pf[e] = n, Op.forEach(function(r) {
          return r(Ge);
        });
      },
      get: function() {
        return pf[e];
      }
    });
  });
  Object.defineProperty(Ge, "familyPrefix", {
    enumerable: !0,
    set: function(t) {
      pf.cssPrefix = t, Op.forEach(function(n) {
        return n(Ge);
      });
    },
    get: function() {
      return pf.cssPrefix;
    }
  });
  ol.FontAwesomeConfig = Ge;
  var Op = [];
  function Bne(e) {
    return Op.push(e), function() {
      Op.splice(Op.indexOf(e), 1);
    };
  }
  var Ru = ME, Mi = {
    size: 16,
    x: 0,
    y: 0,
    rotate: 0,
    flipX: !1,
    flipY: !1
  };
  function Une(e) {
    if (!(!e || !Ja)) {
      var t = vn.createElement("style");
      t.setAttribute("type", "text/css"), t.innerHTML = e;
      for (var n = vn.head.childNodes, r = null, o = n.length - 1; o > -1; o--) {
        var i = n[o], a = (i.tagName || "").toUpperCase();
        ["STYLE", "LINK"].indexOf(a) > -1 && (r = i);
      }
      return vn.head.insertBefore(t, r), e;
    }
  }
  var Vne = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
  function H2() {
    for (var e = 12, t = ""; e-- > 0; )
      t += Vne[Math.random() * 62 | 0];
    return t;
  }
  function Df(e) {
    for (var t = [], n = (e || []).length >>> 0; n--; )
      t[n] = e[n];
    return t;
  }
  function Vk(e) {
    return e.classList ? Df(e.classList) : (e.getAttribute("class") || "").split(" ").filter(function(t) {
      return t;
    });
  }
  function KL(e) {
    return "".concat(e).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  }
  function Hne(e) {
    return Object.keys(e || {}).reduce(function(t, n) {
      return t + "".concat(n, '="').concat(KL(e[n]), '" ');
    }, "").trim();
  }
  function Ab(e) {
    return Object.keys(e || {}).reduce(function(t, n) {
      return t + "".concat(n, ": ").concat(e[n].trim(), ";");
    }, "");
  }
  function Hk(e) {
    return e.size !== Mi.size || e.x !== Mi.x || e.y !== Mi.y || e.rotate !== Mi.rotate || e.flipX || e.flipY;
  }
  function qne(e) {
    var t = e.transform, n = e.containerWidth, r = e.iconWidth, o = {
      transform: "translate(".concat(n / 2, " 256)")
    }, i = "translate(".concat(t.x * 32, ", ").concat(t.y * 32, ") "), a = "scale(".concat(t.size / 16 * (t.flipX ? -1 : 1), ", ").concat(t.size / 16 * (t.flipY ? -1 : 1), ") "), s = "rotate(".concat(t.rotate, " 0 0)"), c = {
      transform: "".concat(i, " ").concat(a, " ").concat(s)
    }, u = {
      transform: "translate(".concat(r / 2 * -1, " -256)")
    };
    return {
      outer: o,
      inner: c,
      path: u
    };
  }
  function Wne(e) {
    var t = e.transform, n = e.width, r = n === void 0 ? ME : n, o = e.height, i = o === void 0 ? ME : o, a = "";
    return vL ? a += "translate(".concat(t.x / Ru - r / 2, "em, ").concat(t.y / Ru - i / 2, "em) ") : a += "translate(calc(-50% + ".concat(t.x / Ru, "em), calc(-50% + ").concat(t.y / Ru, "em)) "), a += "scale(".concat(t.size / Ru * (t.flipX ? -1 : 1), ", ").concat(t.size / Ru * (t.flipY ? -1 : 1), ") "), a += "rotate(".concat(t.rotate, "deg) "), a;
  }
  var Gne = `:root, :host {
  --fa-font-solid: normal 900 1em/1 "Font Awesome 7 Free";
  --fa-font-regular: normal 400 1em/1 "Font Awesome 7 Free";
  --fa-font-light: normal 300 1em/1 "Font Awesome 7 Pro";
  --fa-font-thin: normal 100 1em/1 "Font Awesome 7 Pro";
  --fa-font-duotone: normal 900 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-regular: normal 400 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-light: normal 300 1em/1 "Font Awesome 7 Duotone";
  --fa-font-duotone-thin: normal 100 1em/1 "Font Awesome 7 Duotone";
  --fa-font-brands: normal 400 1em/1 "Font Awesome 7 Brands";
  --fa-font-sharp-solid: normal 900 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-regular: normal 400 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-light: normal 300 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-thin: normal 100 1em/1 "Font Awesome 7 Sharp";
  --fa-font-sharp-duotone-solid: normal 900 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-regular: normal 400 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-light: normal 300 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-sharp-duotone-thin: normal 100 1em/1 "Font Awesome 7 Sharp Duotone";
  --fa-font-slab-regular: normal 400 1em/1 "Font Awesome 7 Slab";
  --fa-font-slab-press-regular: normal 400 1em/1 "Font Awesome 7 Slab Press";
  --fa-font-whiteboard-semibold: normal 600 1em/1 "Font Awesome 7 Whiteboard";
  --fa-font-thumbprint-light: normal 300 1em/1 "Font Awesome 7 Thumbprint";
  --fa-font-notdog-solid: normal 900 1em/1 "Font Awesome 7 Notdog";
  --fa-font-notdog-duo-solid: normal 900 1em/1 "Font Awesome 7 Notdog Duo";
  --fa-font-etch-solid: normal 900 1em/1 "Font Awesome 7 Etch";
  --fa-font-jelly-regular: normal 400 1em/1 "Font Awesome 7 Jelly";
  --fa-font-jelly-fill-regular: normal 400 1em/1 "Font Awesome 7 Jelly Fill";
  --fa-font-jelly-duo-regular: normal 400 1em/1 "Font Awesome 7 Jelly Duo";
  --fa-font-chisel-regular: normal 400 1em/1 "Font Awesome 7 Chisel";
  --fa-font-utility-semibold: normal 600 1em/1 "Font Awesome 7 Utility";
  --fa-font-utility-duo-semibold: normal 600 1em/1 "Font Awesome 7 Utility Duo";
  --fa-font-utility-fill-semibold: normal 600 1em/1 "Font Awesome 7 Utility Fill";
}

.svg-inline--fa {
  box-sizing: content-box;
  display: var(--fa-display, inline-block);
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
  width: var(--fa-width, 1.25em);
}
.svg-inline--fa.fa-2xs {
  vertical-align: 0.1em;
}
.svg-inline--fa.fa-xs {
  vertical-align: 0em;
}
.svg-inline--fa.fa-sm {
  vertical-align: -0.0714285714em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.2em;
}
.svg-inline--fa.fa-xl {
  vertical-align: -0.25em;
}
.svg-inline--fa.fa-2xl {
  vertical-align: -0.3125em;
}
.svg-inline--fa.fa-pull-left,
.svg-inline--fa .fa-pull-start {
  float: inline-start;
  margin-inline-end: var(--fa-pull-margin, 0.3em);
}
.svg-inline--fa.fa-pull-right,
.svg-inline--fa .fa-pull-end {
  float: inline-end;
  margin-inline-start: var(--fa-pull-margin, 0.3em);
}
.svg-inline--fa.fa-li {
  width: var(--fa-li-width, 2em);
  inset-inline-start: calc(-1 * var(--fa-li-width, 2em));
  inset-block-start: 0.25em; /* syncing vertical alignment with Web Font rendering */
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: var(--fa-width, 1.25em);
}
.fa-layers .svg-inline--fa {
  inset: 0;
  margin: auto;
  position: absolute;
  transform-origin: center center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  transform-origin: center center;
}

.fa-layers-counter {
  background-color: var(--fa-counter-background-color, #ff253a);
  border-radius: var(--fa-counter-border-radius, 1em);
  box-sizing: border-box;
  color: var(--fa-inverse, #fff);
  line-height: var(--fa-counter-line-height, 1);
  max-width: var(--fa-counter-max-width, 5em);
  min-width: var(--fa-counter-min-width, 1.5em);
  overflow: hidden;
  padding: var(--fa-counter-padding, 0.25em 0.5em);
  right: var(--fa-right, 0);
  text-overflow: ellipsis;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-counter-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: var(--fa-bottom, 0);
  right: var(--fa-right, 0);
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: var(--fa-bottom, 0);
  left: var(--fa-left, 0);
  right: auto;
  top: auto;
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: bottom left;
}

.fa-layers-top-right {
  top: var(--fa-top, 0);
  right: var(--fa-right, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top right;
}

.fa-layers-top-left {
  left: var(--fa-left, 0);
  right: auto;
  top: var(--fa-top, 0);
  transform: scale(var(--fa-layers-scale, 0.25));
  transform-origin: top left;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-2xs {
  font-size: calc(10 / 16 * 1em); /* converts a 10px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 10 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 10 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-xs {
  font-size: calc(12 / 16 * 1em); /* converts a 12px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 12 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 12 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-sm {
  font-size: calc(14 / 16 * 1em); /* converts a 14px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 14 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 14 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-lg {
  font-size: calc(20 / 16 * 1em); /* converts a 20px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 20 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 20 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-xl {
  font-size: calc(24 / 16 * 1em); /* converts a 24px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 24 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 24 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-2xl {
  font-size: calc(32 / 16 * 1em); /* converts a 32px size into an em-based value that's relative to the scale's 16px base */
  line-height: calc(1 / 32 * 1em); /* sets the line-height of the icon back to that of it's parent */
  vertical-align: calc((6 / 32 - 0.375) * 1em); /* vertically centers the icon taking into account the surrounding text's descender */
}

.fa-width-auto {
  --fa-width: auto;
}

.fa-fw,
.fa-width-fixed {
  --fa-width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-inline-start: var(--fa-li-margin, 2.5em);
  padding-inline-start: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  inset-inline-start: calc(-1 * var(--fa-li-width, 2em));
  position: absolute;
  text-align: center;
  width: var(--fa-li-width, 2em);
  line-height: inherit;
}

/* Heads Up: Bordered Icons will not be supported in the future!
  - This feature will be deprecated in the next major release of Font Awesome (v8)!
  - You may continue to use it in this version *v7), but it will not be supported in Font Awesome v8.
*/
/* Notes:
* --@{v.$css-prefix}-border-width = 1/16 by default (to render as ~1px based on a 16px default font-size)
* --@{v.$css-prefix}-border-padding =
  ** 3/16 for vertical padding (to give ~2px of vertical whitespace around an icon considering it's vertical alignment)
  ** 4/16 for horizontal padding (to give ~4px of horizontal whitespace around an icon)
*/
.fa-border {
  border-color: var(--fa-border-color, #eee);
  border-radius: var(--fa-border-radius, 0.1em);
  border-style: var(--fa-border-style, solid);
  border-width: var(--fa-border-width, 0.0625em);
  box-sizing: var(--fa-border-box-sizing, content-box);
  padding: var(--fa-border-padding, 0.1875em 0.25em);
}

.fa-pull-left,
.fa-pull-start {
  float: inline-start;
  margin-inline-end: var(--fa-pull-margin, 0.3em);
}

.fa-pull-right,
.fa-pull-end {
  float: inline-end;
  margin-inline-start: var(--fa-pull-margin, 0.3em);
}

.fa-beat {
  animation-name: fa-beat;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-bounce {
  animation-name: fa-bounce;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.28, 0.84, 0.42, 1));
}

.fa-fade {
  animation-name: fa-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-beat-fade {
  animation-name: fa-beat-fade;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, cubic-bezier(0.4, 0, 0.6, 1));
}

.fa-flip {
  animation-name: fa-flip;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, ease-in-out);
}

.fa-shake {
  animation-name: fa-shake;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin {
  animation-name: fa-spin;
  animation-delay: var(--fa-animation-delay, 0s);
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 2s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, linear);
}

.fa-spin-reverse {
  --fa-animation-direction: reverse;
}

.fa-pulse,
.fa-spin-pulse {
  animation-name: fa-spin;
  animation-direction: var(--fa-animation-direction, normal);
  animation-duration: var(--fa-animation-duration, 1s);
  animation-iteration-count: var(--fa-animation-iteration-count, infinite);
  animation-timing-function: var(--fa-animation-timing, steps(8));
}

@media (prefers-reduced-motion: reduce) {
  .fa-beat,
  .fa-bounce,
  .fa-fade,
  .fa-beat-fade,
  .fa-flip,
  .fa-pulse,
  .fa-shake,
  .fa-spin,
  .fa-spin-pulse {
    animation: none !important;
    transition: none !important;
  }
}
@keyframes fa-beat {
  0%, 90% {
    transform: scale(1);
  }
  45% {
    transform: scale(var(--fa-beat-scale, 1.25));
  }
}
@keyframes fa-bounce {
  0% {
    transform: scale(1, 1) translateY(0);
  }
  10% {
    transform: scale(var(--fa-bounce-start-scale-x, 1.1), var(--fa-bounce-start-scale-y, 0.9)) translateY(0);
  }
  30% {
    transform: scale(var(--fa-bounce-jump-scale-x, 0.9), var(--fa-bounce-jump-scale-y, 1.1)) translateY(var(--fa-bounce-height, -0.5em));
  }
  50% {
    transform: scale(var(--fa-bounce-land-scale-x, 1.05), var(--fa-bounce-land-scale-y, 0.95)) translateY(0);
  }
  57% {
    transform: scale(1, 1) translateY(var(--fa-bounce-rebound, -0.125em));
  }
  64% {
    transform: scale(1, 1) translateY(0);
  }
  100% {
    transform: scale(1, 1) translateY(0);
  }
}
@keyframes fa-fade {
  50% {
    opacity: var(--fa-fade-opacity, 0.4);
  }
}
@keyframes fa-beat-fade {
  0%, 100% {
    opacity: var(--fa-beat-fade-opacity, 0.4);
    transform: scale(1);
  }
  50% {
    opacity: 1;
    transform: scale(var(--fa-beat-fade-scale, 1.125));
  }
}
@keyframes fa-flip {
  50% {
    transform: rotate3d(var(--fa-flip-x, 0), var(--fa-flip-y, 1), var(--fa-flip-z, 0), var(--fa-flip-angle, -180deg));
  }
}
@keyframes fa-shake {
  0% {
    transform: rotate(-15deg);
  }
  4% {
    transform: rotate(15deg);
  }
  8%, 24% {
    transform: rotate(-18deg);
  }
  12%, 28% {
    transform: rotate(18deg);
  }
  16% {
    transform: rotate(-22deg);
  }
  20% {
    transform: rotate(22deg);
  }
  32% {
    transform: rotate(-12deg);
  }
  36% {
    transform: rotate(12deg);
  }
  40%, 100% {
    transform: rotate(0deg);
  }
}
@keyframes fa-spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  transform: rotate(90deg);
}

.fa-rotate-180 {
  transform: rotate(180deg);
}

.fa-rotate-270 {
  transform: rotate(270deg);
}

.fa-flip-horizontal {
  transform: scale(-1, 1);
}

.fa-flip-vertical {
  transform: scale(1, -1);
}

.fa-flip-both,
.fa-flip-horizontal.fa-flip-vertical {
  transform: scale(-1, -1);
}

.fa-rotate-by {
  transform: rotate(var(--fa-rotate-angle, 0));
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}

.svg-inline--fa.fa-inverse {
  fill: var(--fa-inverse, #fff);
}

.fa-stack {
  display: inline-block;
  height: 2em;
  line-height: 2em;
  position: relative;
  vertical-align: middle;
  width: 2.5em;
}

.fa-inverse {
  color: var(--fa-inverse, #fff);
}

.svg-inline--fa.fa-stack-1x {
  --fa-width: 1.25em;
  height: 1em;
  width: var(--fa-width);
}
.svg-inline--fa.fa-stack-2x {
  --fa-width: 2.5em;
  height: 2em;
  width: var(--fa-width);
}

.fa-stack-1x,
.fa-stack-2x {
  inset: 0;
  margin: auto;
  position: absolute;
  z-index: var(--fa-stack-z-index, auto);
}`;
  function YL() {
    var e = BL, t = UL, n = Ge.cssPrefix, r = Ge.replacementClass, o = Gne;
    if (n !== e || r !== t) {
      var i = new RegExp("\\.".concat(e, "\\-"), "g"), a = new RegExp("\\--".concat(e, "\\-"), "g"), s = new RegExp("\\.".concat(t), "g");
      o = o.replace(i, ".".concat(n, "-")).replace(a, "--".concat(n, "-")).replace(s, ".".concat(r));
    }
    return o;
  }
  var q2 = !1;
  function OS() {
    Ge.autoAddCss && !q2 && (Une(YL()), q2 = !0);
  }
  var Kne = {
    mixout: function() {
      return {
        dom: {
          css: YL,
          insertCss: OS
        }
      };
    },
    hooks: function() {
      return {
        beforeDOMElementCreation: function() {
          OS();
        },
        beforeI2svg: function() {
          OS();
        }
      };
    }
  }, Ga = ol || {};
  Ga[Wa] || (Ga[Wa] = {});
  Ga[Wa].styles || (Ga[Wa].styles = {});
  Ga[Wa].hooks || (Ga[Wa].hooks = {});
  Ga[Wa].shims || (Ga[Wa].shims = []);
  var Yo = Ga[Wa], XL = [], ZL = function() {
    vn.removeEventListener("DOMContentLoaded", ZL), s0 = 1, XL.map(function(t) {
      return t();
    });
  }, s0 = !1;
  Ja && (s0 = (vn.documentElement.doScroll ? /^loaded|^c/ : /^loaded|^i|^c/).test(vn.readyState), s0 || vn.addEventListener("DOMContentLoaded", ZL));
  function Yne(e) {
    Ja && (s0 ? setTimeout(e, 0) : XL.push(e));
  }
  function Vh(e) {
    var t = e.tag, n = e.attributes, r = n === void 0 ? {} : n, o = e.children, i = o === void 0 ? [] : o;
    return typeof e == "string" ? KL(e) : "<".concat(t, " ").concat(Hne(r), ">").concat(i.map(Vh).join(""), "</").concat(t, ">");
  }
  function W2(e, t, n) {
    if (e && e[t] && e[t][n])
      return {
        prefix: t,
        iconName: n,
        icon: e[t][n]
      };
  }
  var MS = function(t, n, r, o) {
    var i = Object.keys(t), a = i.length, s = n, c, u, d;
    for (r === void 0 ? (c = 1, d = t[i[0]]) : (c = 0, d = r); c < a; c++)
      u = i[c], d = s(d, t[u], u, t);
    return d;
  };
  function QL(e) {
    return ti(e).length !== 1 ? null : e.codePointAt(0).toString(16);
  }
  function G2(e) {
    return Object.keys(e).reduce(function(t, n) {
      var r = e[n], o = !!r.icon;
      return o ? t[r.iconName] = r.icon : t[n] = r, t;
    }, {});
  }
  function jE(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = n.skipHooks, o = r === void 0 ? !1 : r, i = G2(t);
    typeof Yo.hooks.addPack == "function" && !o ? Yo.hooks.addPack(e, G2(t)) : Yo.styles[e] = Te(Te({}, Yo.styles[e] || {}), i), e === "fas" && jE("fa", t);
  }
  var Zp = Yo.styles, Xne = Yo.shims, JL = Object.keys(Uk), Zne = JL.reduce(function(e, t) {
    return e[t] = Object.keys(Uk[t]), e;
  }, {}), qk = null, ez = {}, tz = {}, nz = {}, rz = {}, oz = {};
  function Qne(e) {
    return ~Dne.indexOf(e);
  }
  function Jne(e, t) {
    var n = t.split("-"), r = n[0], o = n.slice(1).join("-");
    return r === e && o !== "" && !Qne(o) ? o : null;
  }
  var iz = function() {
    var t = function(i) {
      return MS(Zp, function(a, s, c) {
        return a[c] = MS(s, i, {}), a;
      }, {});
    };
    ez = t(function(o, i, a) {
      if (i[3] && (o[i[3]] = a), i[2]) {
        var s = i[2].filter(function(c) {
          return typeof c == "number";
        });
        s.forEach(function(c) {
          o[c.toString(16)] = a;
        });
      }
      return o;
    }), tz = t(function(o, i, a) {
      if (o[a] = a, i[2]) {
        var s = i[2].filter(function(c) {
          return typeof c == "string";
        });
        s.forEach(function(c) {
          o[c] = a;
        });
      }
      return o;
    }), oz = t(function(o, i, a) {
      var s = i[2];
      return o[a] = a, s.forEach(function(c) {
        o[c] = a;
      }), o;
    });
    var n = "far" in Zp || Ge.autoFetchSvg, r = MS(Xne, function(o, i) {
      var a = i[0], s = i[1], c = i[2];
      return s === "far" && !n && (s = "fas"), typeof a == "string" && (o.names[a] = {
        prefix: s,
        iconName: c
      }), typeof a == "number" && (o.unicodes[a.toString(16)] = {
        prefix: s,
        iconName: c
      }), o;
    }, {
      names: {},
      unicodes: {}
    });
    nz = r.names, rz = r.unicodes, qk = Rb(Ge.styleDefault, {
      family: Ge.familyDefault
    });
  };
  Bne(function(e) {
    qk = Rb(e.styleDefault, {
      family: Ge.familyDefault
    });
  });
  iz();
  function Wk(e, t) {
    return (ez[e] || {})[t];
  }
  function ere(e, t) {
    return (tz[e] || {})[t];
  }
  function tc(e, t) {
    return (oz[e] || {})[t];
  }
  function az(e) {
    return nz[e] || {
      prefix: null,
      iconName: null
    };
  }
  function tre(e) {
    var t = rz[e], n = Wk("fas", e);
    return t || (n ? {
      prefix: "fas",
      iconName: n
    } : null) || {
      prefix: null,
      iconName: null
    };
  }
  function il() {
    return qk;
  }
  var sz = function() {
    return {
      prefix: null,
      iconName: null,
      rest: []
    };
  };
  function nre(e) {
    var t = dr, n = JL.reduce(function(r, o) {
      return r[o] = "".concat(Ge.cssPrefix, "-").concat(o), r;
    }, {});
    return DL.forEach(function(r) {
      (e.includes(n[r]) || e.some(function(o) {
        return Zne[r].includes(o);
      })) && (t = r);
    }), t;
  }
  function Rb(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.family, r = n === void 0 ? dr : n, o = Nne[r][e];
    if (r === Bh && !e)
      return "fad";
    var i = V2[r][e] || V2[r][o], a = e in Yo.styles ? e : null, s = i || a || null;
    return s;
  }
  function rre(e) {
    var t = [], n = null;
    return e.forEach(function(r) {
      var o = Jne(Ge.cssPrefix, r);
      o ? n = o : r && t.push(r);
    }), {
      iconName: n,
      rest: t
    };
  }
  function K2(e) {
    return e.sort().filter(function(t, n, r) {
      return r.indexOf(t) === n;
    });
  }
  var Y2 = LL.concat(FL);
  function Ob(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.skipLookups, r = n === void 0 ? !1 : n, o = null, i = K2(e.filter(function(g) {
      return Y2.includes(g);
    })), a = K2(e.filter(function(g) {
      return !Y2.includes(g);
    })), s = i.filter(function(g) {
      return o = g, !xL.includes(g);
    }), c = Tb(s, 1), u = c[0], d = u === void 0 ? null : u, p = nre(i), m = Te(Te({}, rre(a)), {}, {
      prefix: Rb(d, {
        family: p
      })
    });
    return Te(Te(Te({}, m), sre({
      values: e,
      family: p,
      styles: Zp,
      config: Ge,
      canonical: m,
      givenPrefix: o
    })), ore(r, o, m));
  }
  function ore(e, t, n) {
    var r = n.prefix, o = n.iconName;
    if (e || !r || !o)
      return {
        prefix: r,
        iconName: o
      };
    var i = t === "fa" ? az(o) : {}, a = tc(r, o);
    return o = i.iconName || a || o, r = i.prefix || r, r === "far" && !Zp.far && Zp.fas && !Ge.autoFetchSvg && (r = "fas"), {
      prefix: r,
      iconName: o
    };
  }
  var ire = DL.filter(function(e) {
    return e !== dr || e !== Bh;
  }), are = Object.keys(OE).filter(function(e) {
    return e !== dr;
  }).map(function(e) {
    return Object.keys(OE[e]);
  }).flat();
  function sre(e) {
    var t = e.values, n = e.family, r = e.canonical, o = e.givenPrefix, i = o === void 0 ? "" : o, a = e.styles, s = a === void 0 ? {} : a, c = e.config, u = c === void 0 ? {} : c, d = n === Bh, p = t.includes("fa-duotone") || t.includes("fad"), m = u.familyDefault === "duotone", g = r.prefix === "fad" || r.prefix === "fa-duotone";
    if (!d && (p || m || g) && (r.prefix = "fad"), (t.includes("fa-brands") || t.includes("fab")) && (r.prefix = "fab"), !r.prefix && ire.includes(n)) {
      var y = Object.keys(s).find(function(v) {
        return are.includes(v);
      });
      if (y || u.autoFetchSvg) {
        var b = Ete.get(n).defaultShortPrefixId;
        r.prefix = b, r.iconName = tc(r.prefix, r.iconName) || r.iconName;
      }
    }
    return (r.prefix === "fa" || i === "fa") && (r.prefix = il() || "fas"), r;
  }
  var lre = /* @__PURE__ */ (function() {
    function e() {
      Wee(this, e), this.definitions = {};
    }
    return Kee(e, [{
      key: "add",
      value: function() {
        for (var n = this, r = arguments.length, o = new Array(r), i = 0; i < r; i++)
          o[i] = arguments[i];
        var a = o.reduce(this._pullDefinitions, {});
        Object.keys(a).forEach(function(s) {
          n.definitions[s] = Te(Te({}, n.definitions[s] || {}), a[s]), jE(s, a[s]);
          var c = Uk[dr][s];
          c && jE(c, a[s]), iz();
        });
      }
    }, {
      key: "reset",
      value: function() {
        this.definitions = {};
      }
    }, {
      key: "_pullDefinitions",
      value: function(n, r) {
        var o = r.prefix && r.iconName && r.icon ? {
          0: r
        } : r;
        return Object.keys(o).map(function(i) {
          var a = o[i], s = a.prefix, c = a.iconName, u = a.icon, d = u[2];
          n[s] || (n[s] = {}), d.length > 0 && d.forEach(function(p) {
            typeof p == "string" && (n[s][p] = u);
          }), n[s][c] = u;
        }), n;
      }
    }]);
  })(), X2 = [], Wu = {}, tf = {}, cre = Object.keys(tf);
  function ure(e, t) {
    var n = t.mixoutsTo;
    return X2 = e, Wu = {}, Object.keys(tf).forEach(function(r) {
      cre.indexOf(r) === -1 && delete tf[r];
    }), X2.forEach(function(r) {
      var o = r.mixout ? r.mixout() : {};
      if (Object.keys(o).forEach(function(a) {
        typeof o[a] == "function" && (n[a] = o[a]), a0(o[a]) === "object" && Object.keys(o[a]).forEach(function(s) {
          n[a] || (n[a] = {}), n[a][s] = o[a][s];
        });
      }), r.hooks) {
        var i = r.hooks();
        Object.keys(i).forEach(function(a) {
          Wu[a] || (Wu[a] = []), Wu[a].push(i[a]);
        });
      }
      r.provides && r.provides(tf);
    }), n;
  }
  function DE(e, t) {
    for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++)
      r[o - 2] = arguments[o];
    var i = Wu[e] || [];
    return i.forEach(function(a) {
      t = a.apply(null, [t].concat(r));
    }), t;
  }
  function uc(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
      n[r - 1] = arguments[r];
    var o = Wu[e] || [];
    o.forEach(function(i) {
      i.apply(null, n);
    });
  }
  function al() {
    var e = arguments[0], t = Array.prototype.slice.call(arguments, 1);
    return tf[e] ? tf[e].apply(null, t) : void 0;
  }
  function FE(e) {
    e.prefix === "fa" && (e.prefix = "fas");
    var t = e.iconName, n = e.prefix || il();
    if (t)
      return t = tc(n, t) || t, W2(lz.definitions, n, t) || W2(Yo.styles, n, t);
  }
  var lz = new lre(), fre = function() {
    Ge.autoReplaceSvg = !1, Ge.observeMutations = !1, uc("noAuto");
  }, dre = {
    i2svg: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return Ja ? (uc("beforeI2svg", t), al("pseudoElements2svg", t), al("i2svg", t)) : Promise.reject(new Error("Operation requires a DOM of some kind."));
    },
    watch: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = t.autoReplaceSvgRoot;
      Ge.autoReplaceSvg === !1 && (Ge.autoReplaceSvg = !0), Ge.observeMutations = !0, Yne(function() {
        hre({
          autoReplaceSvgRoot: n
        }), uc("watch", t);
      });
    }
  }, pre = {
    icon: function(t) {
      if (t === null)
        return null;
      if (a0(t) === "object" && t.prefix && t.iconName)
        return {
          prefix: t.prefix,
          iconName: tc(t.prefix, t.iconName) || t.iconName
        };
      if (Array.isArray(t) && t.length === 2) {
        var n = t[1].indexOf("fa-") === 0 ? t[1].slice(3) : t[1], r = Rb(t[0]);
        return {
          prefix: r,
          iconName: tc(r, n) || n
        };
      }
      if (typeof t == "string" && (t.indexOf("".concat(Ge.cssPrefix, "-")) > -1 || t.match(Pne))) {
        var o = Ob(t.split(" "), {
          skipLookups: !0
        });
        return {
          prefix: o.prefix || il(),
          iconName: tc(o.prefix, o.iconName) || o.iconName
        };
      }
      if (typeof t == "string") {
        var i = il();
        return {
          prefix: i,
          iconName: tc(i, t) || t
        };
      }
    }
  }, ho = {
    noAuto: fre,
    config: Ge,
    dom: dre,
    parse: pre,
    library: lz,
    findIconDefinition: FE,
    toHtml: Vh
  }, hre = function() {
    var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = t.autoReplaceSvgRoot, r = n === void 0 ? vn : n;
    (Object.keys(Yo.styles).length > 0 || Ge.autoFetchSvg) && Ja && Ge.autoReplaceSvg && ho.dom.i2svg({
      node: r
    });
  };
  function Mb(e, t) {
    return Object.defineProperty(e, "abstract", {
      get: t
    }), Object.defineProperty(e, "html", {
      get: function() {
        return e.abstract.map(function(r) {
          return Vh(r);
        });
      }
    }), Object.defineProperty(e, "node", {
      get: function() {
        if (Ja) {
          var r = vn.createElement("div");
          return r.innerHTML = e.html, r.children;
        }
      }
    }), e;
  }
  function mre(e) {
    var t = e.children, n = e.main, r = e.mask, o = e.attributes, i = e.styles, a = e.transform;
    if (Hk(a) && n.found && !r.found) {
      var s = n.width, c = n.height, u = {
        x: s / c / 2,
        y: 0.5
      };
      o.style = Ab(Te(Te({}, i), {}, {
        "transform-origin": "".concat(u.x + a.x / 16, "em ").concat(u.y + a.y / 16, "em")
      }));
    }
    return [{
      tag: "svg",
      attributes: o,
      children: t
    }];
  }
  function gre(e) {
    var t = e.prefix, n = e.iconName, r = e.children, o = e.attributes, i = e.symbol, a = i === !0 ? "".concat(t, "-").concat(Ge.cssPrefix, "-").concat(n) : i;
    return [{
      tag: "svg",
      attributes: {
        style: "display: none;"
      },
      children: [{
        tag: "symbol",
        attributes: Te(Te({}, o), {}, {
          id: a
        }),
        children: r
      }]
    }];
  }
  function yre(e) {
    var t = ["aria-label", "aria-labelledby", "title", "role"];
    return t.some(function(n) {
      return n in e;
    });
  }
  function Gk(e) {
    var t = e.icons, n = t.main, r = t.mask, o = e.prefix, i = e.iconName, a = e.transform, s = e.symbol, c = e.maskId, u = e.extra, d = e.watchable, p = d === void 0 ? !1 : d, m = r.found ? r : n, g = m.width, y = m.height, b = [Ge.replacementClass, i ? "".concat(Ge.cssPrefix, "-").concat(i) : ""].filter(function(k) {
      return u.classes.indexOf(k) === -1;
    }).filter(function(k) {
      return k !== "" || !!k;
    }).concat(u.classes).join(" "), v = {
      children: [],
      attributes: Te(Te({}, u.attributes), {}, {
        "data-prefix": o,
        "data-icon": i,
        class: b,
        role: u.attributes.role || "img",
        viewBox: "0 0 ".concat(g, " ").concat(y)
      })
    };
    !yre(u.attributes) && !u.attributes["aria-hidden"] && (v.attributes["aria-hidden"] = "true"), p && (v.attributes[cc] = "");
    var x = Te(Te({}, v), {}, {
      prefix: o,
      iconName: i,
      main: n,
      mask: r,
      maskId: c,
      transform: a,
      symbol: s,
      styles: Te({}, u.styles)
    }), E = r.found && n.found ? al("generateAbstractMask", x) || {
      children: [],
      attributes: {}
    } : al("generateAbstractIcon", x) || {
      children: [],
      attributes: {}
    }, _ = E.children, C = E.attributes;
    return x.children = _, x.attributes = C, s ? gre(x) : mre(x);
  }
  function Z2(e) {
    var t = e.content, n = e.width, r = e.height, o = e.transform, i = e.extra, a = e.watchable, s = a === void 0 ? !1 : a, c = Te(Te({}, i.attributes), {}, {
      class: i.classes.join(" ")
    });
    s && (c[cc] = "");
    var u = Te({}, i.styles);
    Hk(o) && (u.transform = Wne({
      transform: o,
      width: n,
      height: r
    }), u["-webkit-transform"] = u.transform);
    var d = Ab(u);
    d.length > 0 && (c.style = d);
    var p = [];
    return p.push({
      tag: "span",
      attributes: c,
      children: [t]
    }), p;
  }
  function vre(e) {
    var t = e.content, n = e.extra, r = Te(Te({}, n.attributes), {}, {
      class: n.classes.join(" ")
    }), o = Ab(n.styles);
    o.length > 0 && (r.style = o);
    var i = [];
    return i.push({
      tag: "span",
      attributes: r,
      children: [t]
    }), i;
  }
  var NS = Yo.styles;
  function LE(e) {
    var t = e[0], n = e[1], r = e.slice(4), o = Tb(r, 1), i = o[0], a = null;
    return Array.isArray(i) ? a = {
      tag: "g",
      attributes: {
        class: "".concat(Ge.cssPrefix, "-").concat(RS.GROUP)
      },
      children: [{
        tag: "path",
        attributes: {
          class: "".concat(Ge.cssPrefix, "-").concat(RS.SECONDARY),
          fill: "currentColor",
          d: i[0]
        }
      }, {
        tag: "path",
        attributes: {
          class: "".concat(Ge.cssPrefix, "-").concat(RS.PRIMARY),
          fill: "currentColor",
          d: i[1]
        }
      }]
    } : a = {
      tag: "path",
      attributes: {
        fill: "currentColor",
        d: i
      }
    }, {
      found: !0,
      width: t,
      height: n,
      icon: a
    };
  }
  var bre = {
    found: !1,
    width: 512,
    height: 512
  };
  function xre(e, t) {
    !HL && !Ge.showMissingIcons && e && console.error('Icon with name "'.concat(e, '" and prefix "').concat(t, '" is missing.'));
  }
  function zE(e, t) {
    var n = t;
    return t === "fa" && Ge.styleDefault !== null && (t = il()), new Promise(function(r, o) {
      if (n === "fa") {
        var i = az(e) || {};
        e = i.iconName || e, t = i.prefix || t;
      }
      if (e && t && NS[t] && NS[t][e]) {
        var a = NS[t][e];
        return r(LE(a));
      }
      xre(e, t), r(Te(Te({}, bre), {}, {
        icon: Ge.showMissingIcons && e ? al("missingIconAbstract") || {} : {}
      }));
    });
  }
  var Q2 = function() {
  }, BE = Ge.measurePerformance && ny && ny.mark && ny.measure ? ny : {
    mark: Q2,
    measure: Q2
  }, gp = 'FA "7.1.0"', wre = function(t) {
    return BE.mark("".concat(gp, " ").concat(t, " begins")), function() {
      return cz(t);
    };
  }, cz = function(t) {
    BE.mark("".concat(gp, " ").concat(t, " ends")), BE.measure("".concat(gp, " ").concat(t), "".concat(gp, " ").concat(t, " begins"), "".concat(gp, " ").concat(t, " ends"));
  }, Kk = {
    begin: wre,
    end: cz
  }, Mv = function() {
  };
  function J2(e) {
    var t = e.getAttribute ? e.getAttribute(cc) : null;
    return typeof t == "string";
  }
  function Sre(e) {
    var t = e.getAttribute ? e.getAttribute(zk) : null, n = e.getAttribute ? e.getAttribute(Bk) : null;
    return t && n;
  }
  function _re(e) {
    return e && e.classList && e.classList.contains && e.classList.contains(Ge.replacementClass);
  }
  function Ere() {
    if (Ge.autoReplaceSvg === !0)
      return Nv.replace;
    var e = Nv[Ge.autoReplaceSvg];
    return e || Nv.replace;
  }
  function Cre(e) {
    return vn.createElementNS("http://www.w3.org/2000/svg", e);
  }
  function kre(e) {
    return vn.createElement(e);
  }
  function uz(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.ceFn, r = n === void 0 ? e.tag === "svg" ? Cre : kre : n;
    if (typeof e == "string")
      return vn.createTextNode(e);
    var o = r(e.tag);
    Object.keys(e.attributes || []).forEach(function(a) {
      o.setAttribute(a, e.attributes[a]);
    });
    var i = e.children || [];
    return i.forEach(function(a) {
      o.appendChild(uz(a, {
        ceFn: r
      }));
    }), o;
  }
  function Tre(e) {
    var t = " ".concat(e.outerHTML, " ");
    return t = "".concat(t, "Font Awesome fontawesome.com "), t;
  }
  var Nv = {
    replace: function(t) {
      var n = t[0];
      if (n.parentNode)
        if (t[1].forEach(function(o) {
          n.parentNode.insertBefore(uz(o), n);
        }), n.getAttribute(cc) === null && Ge.keepOriginalSource) {
          var r = vn.createComment(Tre(n));
          n.parentNode.replaceChild(r, n);
        } else
          n.remove();
    },
    nest: function(t) {
      var n = t[0], r = t[1];
      if (~Vk(n).indexOf(Ge.replacementClass))
        return Nv.replace(t);
      var o = new RegExp("".concat(Ge.cssPrefix, "-.*"));
      if (delete r[0].attributes.id, r[0].attributes.class) {
        var i = r[0].attributes.class.split(" ").reduce(function(s, c) {
          return c === Ge.replacementClass || c.match(o) ? s.toSvg.push(c) : s.toNode.push(c), s;
        }, {
          toNode: [],
          toSvg: []
        });
        r[0].attributes.class = i.toSvg.join(" "), i.toNode.length === 0 ? n.removeAttribute("class") : n.setAttribute("class", i.toNode.join(" "));
      }
      var a = r.map(function(s) {
        return Vh(s);
      }).join(`
`);
      n.setAttribute(cc, ""), n.innerHTML = a;
    }
  };
  function eI(e) {
    e();
  }
  function fz(e, t) {
    var n = typeof t == "function" ? t : Mv;
    if (e.length === 0)
      n();
    else {
      var r = eI;
      Ge.mutateApproach === One && (r = ol.requestAnimationFrame || eI), r(function() {
        var o = Ere(), i = Kk.begin("mutate");
        e.map(o), i(), n();
      });
    }
  }
  var Yk = !1;
  function dz() {
    Yk = !0;
  }
  function UE() {
    Yk = !1;
  }
  var l0 = null;
  function tI(e) {
    if (L2 && Ge.observeMutations) {
      var t = e.treeCallback, n = t === void 0 ? Mv : t, r = e.nodeCallback, o = r === void 0 ? Mv : r, i = e.pseudoElementsCallback, a = i === void 0 ? Mv : i, s = e.observeMutationsRoot, c = s === void 0 ? vn : s;
      l0 = new L2(function(u) {
        if (!Yk) {
          var d = il();
          Df(u).forEach(function(p) {
            if (p.type === "childList" && p.addedNodes.length > 0 && !J2(p.addedNodes[0]) && (Ge.searchPseudoElements && a(p.target), n(p.target)), p.type === "attributes" && p.target.parentNode && Ge.searchPseudoElements && a([p.target], !0), p.type === "attributes" && J2(p.target) && ~jne.indexOf(p.attributeName))
              if (p.attributeName === "class" && Sre(p.target)) {
                var m = Ob(Vk(p.target)), g = m.prefix, y = m.iconName;
                p.target.setAttribute(zk, g || d), y && p.target.setAttribute(Bk, y);
              } else _re(p.target) && o(p.target);
          });
        }
      }), Ja && l0.observe(c, {
        childList: !0,
        attributes: !0,
        characterData: !0,
        subtree: !0
      });
    }
  }
  function Are() {
    l0 && l0.disconnect();
  }
  function Rre(e) {
    var t = e.getAttribute("style"), n = [];
    return t && (n = t.split(";").reduce(function(r, o) {
      var i = o.split(":"), a = i[0], s = i.slice(1);
      return a && s.length > 0 && (r[a] = s.join(":").trim()), r;
    }, {})), n;
  }
  function Ore(e) {
    var t = e.getAttribute("data-prefix"), n = e.getAttribute("data-icon"), r = e.innerText !== void 0 ? e.innerText.trim() : "", o = Ob(Vk(e));
    return o.prefix || (o.prefix = il()), t && n && (o.prefix = t, o.iconName = n), o.iconName && o.prefix || (o.prefix && r.length > 0 && (o.iconName = ere(o.prefix, e.innerText) || Wk(o.prefix, QL(e.innerText))), !o.iconName && Ge.autoFetchSvg && e.firstChild && e.firstChild.nodeType === Node.TEXT_NODE && (o.iconName = e.firstChild.data)), o;
  }
  function Mre(e) {
    var t = Df(e.attributes).reduce(function(n, r) {
      return n.name !== "class" && n.name !== "style" && (n[r.name] = r.value), n;
    }, {});
    return t;
  }
  function Nre() {
    return {
      iconName: null,
      prefix: null,
      transform: Mi,
      symbol: !1,
      mask: {
        iconName: null,
        prefix: null,
        rest: []
      },
      maskId: null,
      extra: {
        classes: [],
        styles: {},
        attributes: {}
      }
    };
  }
  function nI(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      styleParser: !0
    }, n = Ore(e), r = n.iconName, o = n.prefix, i = n.rest, a = Mre(e), s = DE("parseNodeAttributes", {}, e), c = t.styleParser ? Rre(e) : [];
    return Te({
      iconName: r,
      prefix: o,
      transform: Mi,
      mask: {
        iconName: null,
        prefix: null,
        rest: []
      },
      maskId: null,
      symbol: !1,
      extra: {
        classes: i,
        styles: c,
        attributes: a
      }
    }, s);
  }
  var Pre = Yo.styles;
  function pz(e) {
    var t = Ge.autoReplaceSvg === "nest" ? nI(e, {
      styleParser: !1
    }) : nI(e);
    return ~t.extra.classes.indexOf(WL) ? al("generateLayersText", e, t) : al("generateSvgReplacementMutation", e, t);
  }
  function Ire() {
    return [].concat(ti(FL), ti(LL));
  }
  function rI(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (!Ja) return Promise.resolve();
    var n = vn.documentElement.classList, r = function(p) {
      return n.add("".concat(U2, "-").concat(p));
    }, o = function(p) {
      return n.remove("".concat(U2, "-").concat(p));
    }, i = Ge.autoFetchSvg ? Ire() : xL.concat(Object.keys(Pre));
    i.includes("fa") || i.push("fa");
    var a = [".".concat(WL, ":not([").concat(cc, "])")].concat(i.map(function(d) {
      return ".".concat(d, ":not([").concat(cc, "])");
    })).join(", ");
    if (a.length === 0)
      return Promise.resolve();
    var s = [];
    try {
      s = Df(e.querySelectorAll(a));
    } catch {
    }
    if (s.length > 0)
      r("pending"), o("complete");
    else
      return Promise.resolve();
    var c = Kk.begin("onTree"), u = s.reduce(function(d, p) {
      try {
        var m = pz(p);
        m && d.push(m);
      } catch (g) {
        HL || g.name === "MissingIcon" && console.error(g);
      }
      return d;
    }, []);
    return new Promise(function(d, p) {
      Promise.all(u).then(function(m) {
        fz(m, function() {
          r("active"), r("complete"), o("pending"), typeof t == "function" && t(), c(), d();
        });
      }).catch(function(m) {
        c(), p(m);
      });
    });
  }
  function $re(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    pz(e).then(function(n) {
      n && fz([n], t);
    });
  }
  function jre(e) {
    return function(t) {
      var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = (t || {}).icon ? t : FE(t || {}), o = n.mask;
      return o && (o = (o || {}).icon ? o : FE(o || {})), e(r, Te(Te({}, n), {}, {
        mask: o
      }));
    };
  }
  var Dre = function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = n.transform, o = r === void 0 ? Mi : r, i = n.symbol, a = i === void 0 ? !1 : i, s = n.mask, c = s === void 0 ? null : s, u = n.maskId, d = u === void 0 ? null : u, p = n.classes, m = p === void 0 ? [] : p, g = n.attributes, y = g === void 0 ? {} : g, b = n.styles, v = b === void 0 ? {} : b;
    if (t) {
      var x = t.prefix, E = t.iconName, _ = t.icon;
      return Mb(Te({
        type: "icon"
      }, t), function() {
        return uc("beforeDOMElementCreation", {
          iconDefinition: t,
          params: n
        }), Gk({
          icons: {
            main: LE(_),
            mask: c ? LE(c.icon) : {
              found: !1,
              width: null,
              height: null,
              icon: {}
            }
          },
          prefix: x,
          iconName: E,
          transform: Te(Te({}, Mi), o),
          symbol: a,
          maskId: d,
          extra: {
            attributes: y,
            styles: v,
            classes: m
          }
        });
      });
    }
  }, Fre = {
    mixout: function() {
      return {
        icon: jre(Dre)
      };
    },
    hooks: function() {
      return {
        mutationObserverCallbacks: function(n) {
          return n.treeCallback = rI, n.nodeCallback = $re, n;
        }
      };
    },
    provides: function(t) {
      t.i2svg = function(n) {
        var r = n.node, o = r === void 0 ? vn : r, i = n.callback, a = i === void 0 ? function() {
        } : i;
        return rI(o, a);
      }, t.generateSvgReplacementMutation = function(n, r) {
        var o = r.iconName, i = r.prefix, a = r.transform, s = r.symbol, c = r.mask, u = r.maskId, d = r.extra;
        return new Promise(function(p, m) {
          Promise.all([zE(o, i), c.iconName ? zE(c.iconName, c.prefix) : Promise.resolve({
            found: !1,
            width: 512,
            height: 512,
            icon: {}
          })]).then(function(g) {
            var y = Tb(g, 2), b = y[0], v = y[1];
            p([n, Gk({
              icons: {
                main: b,
                mask: v
              },
              prefix: i,
              iconName: o,
              transform: a,
              symbol: s,
              maskId: u,
              extra: d,
              watchable: !0
            })]);
          }).catch(m);
        });
      }, t.generateAbstractIcon = function(n) {
        var r = n.children, o = n.attributes, i = n.main, a = n.transform, s = n.styles, c = Ab(s);
        c.length > 0 && (o.style = c);
        var u;
        return Hk(a) && (u = al("generateAbstractTransformGrouping", {
          main: i,
          transform: a,
          containerWidth: i.width,
          iconWidth: i.width
        })), r.push(u || i.icon), {
          children: r,
          attributes: o
        };
      };
    }
  }, Lre = {
    mixout: function() {
      return {
        layer: function(n) {
          var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o = r.classes, i = o === void 0 ? [] : o;
          return Mb({
            type: "layer"
          }, function() {
            uc("beforeDOMElementCreation", {
              assembler: n,
              params: r
            });
            var a = [];
            return n(function(s) {
              Array.isArray(s) ? s.map(function(c) {
                a = a.concat(c.abstract);
              }) : a = a.concat(s.abstract);
            }), [{
              tag: "span",
              attributes: {
                class: ["".concat(Ge.cssPrefix, "-layers")].concat(ti(i)).join(" ")
              },
              children: a
            }];
          });
        }
      };
    }
  }, zre = {
    mixout: function() {
      return {
        counter: function(n) {
          var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          r.title;
          var o = r.classes, i = o === void 0 ? [] : o, a = r.attributes, s = a === void 0 ? {} : a, c = r.styles, u = c === void 0 ? {} : c;
          return Mb({
            type: "counter",
            content: n
          }, function() {
            return uc("beforeDOMElementCreation", {
              content: n,
              params: r
            }), vre({
              content: n.toString(),
              extra: {
                attributes: s,
                styles: u,
                classes: ["".concat(Ge.cssPrefix, "-layers-counter")].concat(ti(i))
              }
            });
          });
        }
      };
    }
  }, Bre = {
    mixout: function() {
      return {
        text: function(n) {
          var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o = r.transform, i = o === void 0 ? Mi : o, a = r.classes, s = a === void 0 ? [] : a, c = r.attributes, u = c === void 0 ? {} : c, d = r.styles, p = d === void 0 ? {} : d;
          return Mb({
            type: "text",
            content: n
          }, function() {
            return uc("beforeDOMElementCreation", {
              content: n,
              params: r
            }), Z2({
              content: n,
              transform: Te(Te({}, Mi), i),
              extra: {
                attributes: u,
                styles: p,
                classes: ["".concat(Ge.cssPrefix, "-layers-text")].concat(ti(s))
              }
            });
          });
        }
      };
    },
    provides: function(t) {
      t.generateLayersText = function(n, r) {
        var o = r.transform, i = r.extra, a = null, s = null;
        if (vL) {
          var c = parseInt(getComputedStyle(n).fontSize, 10), u = n.getBoundingClientRect();
          a = u.width / c, s = u.height / c;
        }
        return Promise.resolve([n, Z2({
          content: n.innerHTML,
          width: a,
          height: s,
          transform: o,
          extra: i,
          watchable: !0
        })]);
      };
    }
  }, hz = new RegExp('"', "ug"), oI = [1105920, 1112319], iI = Te(Te(Te(Te({}, {
    FontAwesome: {
      normal: "fas",
      400: "fas"
    }
  }), _te), Ane), Nte), VE = Object.keys(iI).reduce(function(e, t) {
    return e[t.toLowerCase()] = iI[t], e;
  }, {}), Ure = Object.keys(VE).reduce(function(e, t) {
    var n = VE[t];
    return e[t] = n[900] || ti(Object.entries(n))[0][1], e;
  }, {});
  function Vre(e) {
    var t = e.replace(hz, "");
    return QL(ti(t)[0] || "");
  }
  function Hre(e) {
    var t = e.getPropertyValue("font-feature-settings").includes("ss01"), n = e.getPropertyValue("content"), r = n.replace(hz, ""), o = r.codePointAt(0), i = o >= oI[0] && o <= oI[1], a = r.length === 2 ? r[0] === r[1] : !1;
    return i || a || t;
  }
  function qre(e, t) {
    var n = e.replace(/^['"]|['"]$/g, "").toLowerCase(), r = parseInt(t), o = isNaN(r) ? "normal" : r;
    return (VE[n] || {})[o] || Ure[n];
  }
  function aI(e, t) {
    var n = "".concat(Rne).concat(t.replace(":", "-"));
    return new Promise(function(r, o) {
      if (e.getAttribute(n) !== null)
        return r();
      var i = Df(e.children), a = i.filter(function(A) {
        return A.getAttribute(NE) === t;
      })[0], s = ol.getComputedStyle(e, t), c = s.getPropertyValue("font-family"), u = c.match(Ine), d = s.getPropertyValue("font-weight"), p = s.getPropertyValue("content");
      if (a && !u)
        return e.removeChild(a), r();
      if (u && p !== "none" && p !== "") {
        var m = s.getPropertyValue("content"), g = qre(c, d), y = Vre(m), b = u[0].startsWith("FontAwesome"), v = Hre(s), x = Wk(g, y), E = x;
        if (b) {
          var _ = tre(y);
          _.iconName && _.prefix && (x = _.iconName, g = _.prefix);
        }
        if (x && !v && (!a || a.getAttribute(zk) !== g || a.getAttribute(Bk) !== E)) {
          e.setAttribute(n, E), a && e.removeChild(a);
          var C = Nre(), k = C.extra;
          k.attributes[NE] = t, zE(x, g).then(function(A) {
            var O = Gk(Te(Te({}, C), {}, {
              icons: {
                main: A,
                mask: sz()
              },
              prefix: g,
              iconName: E,
              extra: k,
              watchable: !0
            })), P = vn.createElementNS("http://www.w3.org/2000/svg", "svg");
            t === "::before" ? e.insertBefore(P, e.firstChild) : e.appendChild(P), P.outerHTML = O.map(function(I) {
              return Vh(I);
            }).join(`
`), e.removeAttribute(n), r();
          }).catch(o);
        } else
          r();
      } else
        r();
    });
  }
  function Wre(e) {
    return Promise.all([aI(e, "::before"), aI(e, "::after")]);
  }
  function Gre(e) {
    return e.parentNode !== document.head && !~Mne.indexOf(e.tagName.toUpperCase()) && !e.getAttribute(NE) && (!e.parentNode || e.parentNode.tagName !== "svg");
  }
  var Kre = function(t) {
    return !!t && VL.some(function(n) {
      return t.includes(n);
    });
  }, Yre = function(t) {
    if (!t) return [];
    var n = /* @__PURE__ */ new Set(), r = t.split(/,(?![^()]*\))/).map(function(c) {
      return c.trim();
    });
    r = r.flatMap(function(c) {
      return c.includes("(") ? c : c.split(",").map(function(u) {
        return u.trim();
      });
    });
    var o = Ov(r), i;
    try {
      for (o.s(); !(i = o.n()).done; ) {
        var a = i.value;
        if (Kre(a)) {
          var s = VL.reduce(function(c, u) {
            return c.replace(u, "");
          }, a);
          s !== "" && s !== "*" && n.add(s);
        }
      }
    } catch (c) {
      o.e(c);
    } finally {
      o.f();
    }
    return n;
  };
  function sI(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (Ja) {
      var n;
      if (t)
        n = e;
      else if (Ge.searchPseudoElementsFullScan)
        n = e.querySelectorAll("*");
      else {
        var r = /* @__PURE__ */ new Set(), o = Ov(document.styleSheets), i;
        try {
          for (o.s(); !(i = o.n()).done; ) {
            var a = i.value;
            try {
              var s = Ov(a.cssRules), c;
              try {
                for (s.s(); !(c = s.n()).done; ) {
                  var u = c.value, d = Yre(u.selectorText), p = Ov(d), m;
                  try {
                    for (p.s(); !(m = p.n()).done; ) {
                      var g = m.value;
                      r.add(g);
                    }
                  } catch (b) {
                    p.e(b);
                  } finally {
                    p.f();
                  }
                }
              } catch (b) {
                s.e(b);
              } finally {
                s.f();
              }
            } catch (b) {
              Ge.searchPseudoElementsWarnings && console.warn("Font Awesome: cannot parse stylesheet: ".concat(a.href, " (").concat(b.message, `)
If it declares any Font Awesome CSS pseudo-elements, they will not be rendered as SVG icons. Add crossorigin="anonymous" to the <link>, enable searchPseudoElementsFullScan for slower but more thorough DOM parsing, or suppress this warning by setting searchPseudoElementsWarnings to false.`));
            }
          }
        } catch (b) {
          o.e(b);
        } finally {
          o.f();
        }
        if (!r.size) return;
        var y = Array.from(r).join(", ");
        try {
          n = e.querySelectorAll(y);
        } catch {
        }
      }
      return new Promise(function(b, v) {
        var x = Df(n).filter(Gre).map(Wre), E = Kk.begin("searchPseudoElements");
        dz(), Promise.all(x).then(function() {
          E(), UE(), b();
        }).catch(function() {
          E(), UE(), v();
        });
      });
    }
  }
  var Xre = {
    hooks: function() {
      return {
        mutationObserverCallbacks: function(n) {
          return n.pseudoElementsCallback = sI, n;
        }
      };
    },
    provides: function(t) {
      t.pseudoElements2svg = function(n) {
        var r = n.node, o = r === void 0 ? vn : r;
        Ge.searchPseudoElements && sI(o);
      };
    }
  }, lI = !1, Zre = {
    mixout: function() {
      return {
        dom: {
          unwatch: function() {
            dz(), lI = !0;
          }
        }
      };
    },
    hooks: function() {
      return {
        bootstrap: function() {
          tI(DE("mutationObserverCallbacks", {}));
        },
        noAuto: function() {
          Are();
        },
        watch: function(n) {
          var r = n.observeMutationsRoot;
          lI ? UE() : tI(DE("mutationObserverCallbacks", {
            observeMutationsRoot: r
          }));
        }
      };
    }
  }, cI = function(t) {
    var n = {
      size: 16,
      x: 0,
      y: 0,
      flipX: !1,
      flipY: !1,
      rotate: 0
    };
    return t.toLowerCase().split(" ").reduce(function(r, o) {
      var i = o.toLowerCase().split("-"), a = i[0], s = i.slice(1).join("-");
      if (a && s === "h")
        return r.flipX = !0, r;
      if (a && s === "v")
        return r.flipY = !0, r;
      if (s = parseFloat(s), isNaN(s))
        return r;
      switch (a) {
        case "grow":
          r.size = r.size + s;
          break;
        case "shrink":
          r.size = r.size - s;
          break;
        case "left":
          r.x = r.x - s;
          break;
        case "right":
          r.x = r.x + s;
          break;
        case "up":
          r.y = r.y - s;
          break;
        case "down":
          r.y = r.y + s;
          break;
        case "rotate":
          r.rotate = r.rotate + s;
          break;
      }
      return r;
    }, n);
  }, Qre = {
    mixout: function() {
      return {
        parse: {
          transform: function(n) {
            return cI(n);
          }
        }
      };
    },
    hooks: function() {
      return {
        parseNodeAttributes: function(n, r) {
          var o = r.getAttribute("data-fa-transform");
          return o && (n.transform = cI(o)), n;
        }
      };
    },
    provides: function(t) {
      t.generateAbstractTransformGrouping = function(n) {
        var r = n.main, o = n.transform, i = n.containerWidth, a = n.iconWidth, s = {
          transform: "translate(".concat(i / 2, " 256)")
        }, c = "translate(".concat(o.x * 32, ", ").concat(o.y * 32, ") "), u = "scale(".concat(o.size / 16 * (o.flipX ? -1 : 1), ", ").concat(o.size / 16 * (o.flipY ? -1 : 1), ") "), d = "rotate(".concat(o.rotate, " 0 0)"), p = {
          transform: "".concat(c, " ").concat(u, " ").concat(d)
        }, m = {
          transform: "translate(".concat(a / 2 * -1, " -256)")
        }, g = {
          outer: s,
          inner: p,
          path: m
        };
        return {
          tag: "g",
          attributes: Te({}, g.outer),
          children: [{
            tag: "g",
            attributes: Te({}, g.inner),
            children: [{
              tag: r.icon.tag,
              children: r.icon.children,
              attributes: Te(Te({}, r.icon.attributes), g.path)
            }]
          }]
        };
      };
    }
  }, PS = {
    x: 0,
    y: 0,
    width: "100%",
    height: "100%"
  };
  function uI(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return e.attributes && (e.attributes.fill || t) && (e.attributes.fill = "black"), e;
  }
  function Jre(e) {
    return e.tag === "g" ? e.children : [e];
  }
  var eoe = {
    hooks: function() {
      return {
        parseNodeAttributes: function(n, r) {
          var o = r.getAttribute("data-fa-mask"), i = o ? Ob(o.split(" ").map(function(a) {
            return a.trim();
          })) : sz();
          return i.prefix || (i.prefix = il()), n.mask = i, n.maskId = r.getAttribute("data-fa-mask-id"), n;
        }
      };
    },
    provides: function(t) {
      t.generateAbstractMask = function(n) {
        var r = n.children, o = n.attributes, i = n.main, a = n.mask, s = n.maskId, c = n.transform, u = i.width, d = i.icon, p = a.width, m = a.icon, g = qne({
          transform: c,
          containerWidth: p,
          iconWidth: u
        }), y = {
          tag: "rect",
          attributes: Te(Te({}, PS), {}, {
            fill: "white"
          })
        }, b = d.children ? {
          children: d.children.map(uI)
        } : {}, v = {
          tag: "g",
          attributes: Te({}, g.inner),
          children: [uI(Te({
            tag: d.tag,
            attributes: Te(Te({}, d.attributes), g.path)
          }, b))]
        }, x = {
          tag: "g",
          attributes: Te({}, g.outer),
          children: [v]
        }, E = "mask-".concat(s || H2()), _ = "clip-".concat(s || H2()), C = {
          tag: "mask",
          attributes: Te(Te({}, PS), {}, {
            id: E,
            maskUnits: "userSpaceOnUse",
            maskContentUnits: "userSpaceOnUse"
          }),
          children: [y, x]
        }, k = {
          tag: "defs",
          children: [{
            tag: "clipPath",
            attributes: {
              id: _
            },
            children: Jre(m)
          }, C]
        };
        return r.push(k, {
          tag: "rect",
          attributes: Te({
            fill: "currentColor",
            "clip-path": "url(#".concat(_, ")"),
            mask: "url(#".concat(E, ")")
          }, PS)
        }), {
          children: r,
          attributes: o
        };
      };
    }
  }, toe = {
    provides: function(t) {
      var n = !1;
      ol.matchMedia && (n = ol.matchMedia("(prefers-reduced-motion: reduce)").matches), t.missingIconAbstract = function() {
        var r = [], o = {
          fill: "currentColor"
        }, i = {
          attributeType: "XML",
          repeatCount: "indefinite",
          dur: "2s"
        };
        r.push({
          tag: "path",
          attributes: Te(Te({}, o), {}, {
            d: "M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z"
          })
        });
        var a = Te(Te({}, i), {}, {
          attributeName: "opacity"
        }), s = {
          tag: "circle",
          attributes: Te(Te({}, o), {}, {
            cx: "256",
            cy: "364",
            r: "28"
          }),
          children: []
        };
        return n || s.children.push({
          tag: "animate",
          attributes: Te(Te({}, i), {}, {
            attributeName: "r",
            values: "28;14;28;28;14;28;"
          })
        }, {
          tag: "animate",
          attributes: Te(Te({}, a), {}, {
            values: "1;0;1;1;0;1;"
          })
        }), r.push(s), r.push({
          tag: "path",
          attributes: Te(Te({}, o), {}, {
            opacity: "1",
            d: "M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z"
          }),
          children: n ? [] : [{
            tag: "animate",
            attributes: Te(Te({}, a), {}, {
              values: "1;0;0;0;0;1;"
            })
          }]
        }), n || r.push({
          tag: "path",
          attributes: Te(Te({}, o), {}, {
            opacity: "0",
            d: "M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z"
          }),
          children: [{
            tag: "animate",
            attributes: Te(Te({}, a), {}, {
              values: "0;0;1;1;0;0;"
            })
          }]
        }), {
          tag: "g",
          attributes: {
            class: "missing"
          },
          children: r
        };
      };
    }
  }, noe = {
    hooks: function() {
      return {
        parseNodeAttributes: function(n, r) {
          var o = r.getAttribute("data-fa-symbol"), i = o === null ? !1 : o === "" ? !0 : o;
          return n.symbol = i, n;
        }
      };
    }
  }, roe = [Kne, Fre, Lre, zre, Bre, Xre, Zre, Qre, eoe, toe, noe];
  ure(roe, {
    mixoutsTo: ho
  });
  ho.noAuto;
  var hf = ho.config;
  ho.library;
  ho.dom;
  var mz = ho.parse;
  ho.findIconDefinition;
  ho.toHtml;
  var ooe = ho.icon;
  ho.layer;
  ho.text;
  ho.counter;
  function ioe(e) {
    return e = e - 0, e === e;
  }
  function gz(e) {
    return ioe(e) ? e : (e = e.replace(/[_-]+(.)?/g, (t, n) => n ? n.toUpperCase() : ""), e.charAt(0).toLowerCase() + e.slice(1));
  }
  function aoe(e) {
    return e.charAt(0).toUpperCase() + e.slice(1);
  }
  var Ou = /* @__PURE__ */ new Map(), soe = 1e3;
  function loe(e) {
    if (Ou.has(e))
      return Ou.get(e);
    const t = {};
    let n = 0;
    const r = e.length;
    for (; n < r; ) {
      const o = e.indexOf(";", n), i = o === -1 ? r : o, a = e.slice(n, i).trim();
      if (a) {
        const s = a.indexOf(":");
        if (s > 0) {
          const c = a.slice(0, s).trim(), u = a.slice(s + 1).trim();
          if (c && u) {
            const d = gz(c);
            t[d.startsWith("webkit") ? aoe(d) : d] = u;
          }
        }
      }
      n = i + 1;
    }
    if (Ou.size === soe) {
      const o = Ou.keys().next().value;
      o && Ou.delete(o);
    }
    return Ou.set(e, t), t;
  }
  function yz(e, t, n = {}) {
    if (typeof t == "string")
      return t;
    const r = (t.children || []).map((d) => yz(e, d)), o = t.attributes || {}, i = {};
    for (const [d, p] of Object.entries(o))
      switch (!0) {
        case d === "class": {
          i.className = p;
          break;
        }
        case d === "style": {
          i.style = loe(String(p));
          break;
        }
        case d.startsWith("aria-"):
        case d.startsWith("data-"): {
          i[d.toLowerCase()] = p;
          break;
        }
        default:
          i[gz(d)] = p;
      }
    const {
      style: a,
      role: s,
      "aria-label": c,
      ...u
    } = n;
    return a && (i.style = i.style ? { ...i.style, ...a } : a), s && (i.role = s), c && (i["aria-label"] = c, i["aria-hidden"] = "false"), e(t.tag, { ...u, ...i }, ...r);
  }
  var coe = yz.bind(null, On.createElement), fI = (e, t) => {
    const n = T.useId();
    return e || (t ? n : void 0);
  }, uoe = class {
    constructor(e = "react-fontawesome") {
      this.enabled = !1;
      let t = !1;
      try {
        t = typeof process < "u" && !1;
      } catch {
      }
      this.scope = e, this.enabled = t;
    }
    /**
     * Logs messages to the console if not in production.
     * @param args - The message and/or data to log.
     */
    log(...e) {
      this.enabled && console.log(`[${this.scope}]`, ...e);
    }
    /**
     * Logs warnings to the console if not in production.
     * @param args - The warning message and/or data to log.
     */
    warn(...e) {
      this.enabled && console.warn(`[${this.scope}]`, ...e);
    }
    /**
     * Logs errors to the console if not in production.
     * @param args - The error message and/or data to log.
     */
    error(...e) {
      this.enabled && console.error(`[${this.scope}]`, ...e);
    }
  }, foe = (
    // @ts-expect-error TS2872 - Expression is always truthy - This is true when v7 of SVGCore is used, but not when v6 is used.
    // This is the point of this check - if the property exists on config, we have v7, otherwise we have v6.
    // TS is checking this against the dev dependencies which uses v7, so it reports a false error here.
    "searchPseudoElementsFullScan" in hf ? "7.0.0" : "6.0.0"
  ), doe = Number.parseInt(foe) >= 7, Mp = "fa", Ta = {
    beat: "fa-beat",
    fade: "fa-fade",
    beatFade: "fa-beat-fade",
    bounce: "fa-bounce",
    shake: "fa-shake",
    spin: "fa-spin",
    spinPulse: "fa-spin-pulse",
    spinReverse: "fa-spin-reverse",
    pulse: "fa-pulse"
  }, poe = {
    left: "fa-pull-left",
    right: "fa-pull-right"
  }, hoe = {
    90: "fa-rotate-90",
    180: "fa-rotate-180",
    270: "fa-rotate-270"
  }, moe = {
    "2xs": "fa-2xs",
    xs: "fa-xs",
    sm: "fa-sm",
    lg: "fa-lg",
    xl: "fa-xl",
    "2xl": "fa-2xl",
    "1x": "fa-1x",
    "2x": "fa-2x",
    "3x": "fa-3x",
    "4x": "fa-4x",
    "5x": "fa-5x",
    "6x": "fa-6x",
    "7x": "fa-7x",
    "8x": "fa-8x",
    "9x": "fa-9x",
    "10x": "fa-10x"
  }, Aa = {
    border: "fa-border",
    /** @deprecated */
    fixedWidth: "fa-fw",
    flip: "fa-flip",
    flipHorizontal: "fa-flip-horizontal",
    flipVertical: "fa-flip-vertical",
    inverse: "fa-inverse",
    rotateBy: "fa-rotate-by",
    swapOpacity: "fa-swap-opacity",
    widthAuto: "fa-width-auto"
  };
  function goe(e) {
    const t = hf.cssPrefix || hf.familyPrefix || Mp;
    return t === Mp ? e : e.replace(
      new RegExp(String.raw`(?<=^|\s)${Mp}-`, "g"),
      `${t}-`
    );
  }
  function yoe(e) {
    const {
      beat: t,
      fade: n,
      beatFade: r,
      bounce: o,
      shake: i,
      spin: a,
      spinPulse: s,
      spinReverse: c,
      pulse: u,
      fixedWidth: d,
      inverse: p,
      border: m,
      flip: g,
      size: y,
      rotation: b,
      pull: v,
      swapOpacity: x,
      rotateBy: E,
      widthAuto: _,
      className: C
    } = e, k = [];
    return C && k.push(...C.split(" ")), t && k.push(Ta.beat), n && k.push(Ta.fade), r && k.push(Ta.beatFade), o && k.push(Ta.bounce), i && k.push(Ta.shake), a && k.push(Ta.spin), c && k.push(Ta.spinReverse), s && k.push(Ta.spinPulse), u && k.push(Ta.pulse), d && k.push(Aa.fixedWidth), p && k.push(Aa.inverse), m && k.push(Aa.border), g === !0 && k.push(Aa.flip), (g === "horizontal" || g === "both") && k.push(Aa.flipHorizontal), (g === "vertical" || g === "both") && k.push(Aa.flipVertical), y != null && k.push(moe[y]), b != null && b !== 0 && k.push(hoe[b]), v != null && k.push(poe[v]), x && k.push(Aa.swapOpacity), doe ? (E && k.push(Aa.rotateBy), _ && k.push(Aa.widthAuto), (hf.cssPrefix || hf.familyPrefix || Mp) === Mp ? k : (
      // TODO: see if we can achieve custom prefix support without iterating
      // eslint-disable-next-line unicorn/no-array-callback-reference
      k.map(goe)
    )) : k;
  }
  var voe = (e) => typeof e == "object" && "icon" in e && !!e.icon;
  function dI(e) {
    if (e)
      return voe(e) ? e : mz.icon(e);
  }
  function boe(e) {
    return Object.keys(e);
  }
  var pI = new uoe("FontAwesomeIcon"), vz = {
    border: !1,
    className: "",
    mask: void 0,
    maskId: void 0,
    fixedWidth: !1,
    inverse: !1,
    flip: !1,
    icon: void 0,
    listItem: !1,
    pull: void 0,
    pulse: !1,
    rotation: void 0,
    rotateBy: !1,
    size: void 0,
    spin: !1,
    spinPulse: !1,
    spinReverse: !1,
    beat: !1,
    fade: !1,
    beatFade: !1,
    bounce: !1,
    shake: !1,
    symbol: !1,
    title: "",
    titleId: void 0,
    transform: void 0,
    swapOpacity: !1,
    widthAuto: !1
  }, xoe = new Set(Object.keys(vz)), bz = On.forwardRef((e, t) => {
    const n = { ...vz, ...e }, {
      icon: r,
      mask: o,
      symbol: i,
      title: a,
      titleId: s,
      maskId: c,
      transform: u
    } = n, d = fI(c, !!o), p = fI(s, !!a), m = dI(r);
    if (!m)
      return pI.error("Icon lookup is undefined", r), null;
    const g = yoe(n), y = typeof u == "string" ? mz.transform(u) : u, b = dI(o), v = ooe(m, {
      ...g.length > 0 && { classes: g },
      ...y && { transform: y },
      ...b && { mask: b },
      symbol: i,
      title: a,
      titleId: p,
      maskId: d
    });
    if (!v)
      return pI.error("Could not find icon", m), null;
    const { abstract: x } = v, E = { ref: t };
    for (const _ of boe(n))
      xoe.has(_) || (E[_] = n[_]);
    return coe(x[0], E);
  });
  bz.displayName = "FontAwesomeIcon";
  var woe = {
    prefix: "fas",
    iconName: "magnifying-glass",
    icon: [512, 512, [128269, "search"], "f002", "M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376C296.3 401.1 253.9 416 208 416 93.1 416 0 322.9 0 208S93.1 0 208 0 416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"]
  }, Soe = {
    prefix: "fas",
    iconName: "chevron-up",
    icon: [448, 512, [], "f077", "M201.4 105.4c12.5-12.5 32.8-12.5 45.3 0l192 192c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L224 173.3 54.6 342.6c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3l192-192z"]
  }, _oe = {
    prefix: "fas",
    iconName: "expand",
    icon: [448, 512, [], "f065", "M32 32C14.3 32 0 46.3 0 64l0 96c0 17.7 14.3 32 32 32s32-14.3 32-32l0-64 64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L32 32zM64 352c0-17.7-14.3-32-32-32S0 334.3 0 352l0 96c0 17.7 14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-64zM320 32c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0 0 64c0 17.7 14.3 32 32 32s32-14.3 32-32l0-96c0-17.7-14.3-32-32-32l-96 0zM448 352c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 64-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32l0-96z"]
  }, Eoe = {
    prefix: "fas",
    iconName: "chevron-right",
    icon: [320, 512, [9002], "f054", "M311.1 233.4c12.5 12.5 12.5 32.8 0 45.3l-192 192c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L243.2 256 73.9 86.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l192 192z"]
  }, Coe = {
    prefix: "fas",
    iconName: "circle-xmark",
    icon: [512, 512, [61532, "times-circle", "xmark-circle"], "f057", "M256 512a256 256 0 1 0 0-512 256 256 0 1 0 0 512zM167 167c9.4-9.4 24.6-9.4 33.9 0l55 55 55-55c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9l-55 55 55 55c9.4 9.4 9.4 24.6 0 33.9s-24.6 9.4-33.9 0l-55-55-55 55c-9.4 9.4-24.6 9.4-33.9 0s-9.4-24.6 0-33.9l55-55-55-55c-9.4-9.4-9.4-24.6 0-33.9z"]
  }, koe = {
    prefix: "fas",
    iconName: "network-wired",
    icon: [576, 512, [], "f6ff", "M248 88l80 0 0 48-80 0 0-48zm-8-56c-26.5 0-48 21.5-48 48l0 64c0 26.5 21.5 48 48 48l16 0 0 32-224 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0 0 32-16 0c-26.5 0-48 21.5-48 48l0 64c0 26.5 21.5 48 48 48l96 0c26.5 0 48-21.5 48-48l0-64c0-26.5-21.5-48-48-48l-16 0 0-32 192 0 0 32-16 0c-26.5 0-48 21.5-48 48l0 64c0 26.5 21.5 48 48 48l96 0c26.5 0 48-21.5 48-48l0-64c0-26.5-21.5-48-48-48l-16 0 0-32 96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-224 0 0-32 16 0c26.5 0 48-21.5 48-48l0-64c0-26.5-21.5-48-48-48l-96 0zM448 376l8 0 0 48-80 0 0-48 72 0zm-256 0l8 0 0 48-80 0 0-48 72 0z"]
  }, Toe = {
    prefix: "fas",
    iconName: "gear",
    icon: [512, 512, [9881, "cog"], "f013", "M195.1 9.5C198.1-5.3 211.2-16 226.4-16l59.8 0c15.2 0 28.3 10.7 31.3 25.5L332 79.5c14.1 6 27.3 13.7 39.3 22.8l67.8-22.5c14.4-4.8 30.2 1.2 37.8 14.4l29.9 51.8c7.6 13.2 4.9 29.8-6.5 39.9L447 233.3c.9 7.4 1.3 15 1.3 22.7s-.5 15.3-1.3 22.7l53.4 47.5c11.4 10.1 14 26.8 6.5 39.9l-29.9 51.8c-7.6 13.1-23.4 19.2-37.8 14.4l-67.8-22.5c-12.1 9.1-25.3 16.7-39.3 22.8l-14.4 69.9c-3.1 14.9-16.2 25.5-31.3 25.5l-59.8 0c-15.2 0-28.3-10.7-31.3-25.5l-14.4-69.9c-14.1-6-27.2-13.7-39.3-22.8L73.5 432.3c-14.4 4.8-30.2-1.2-37.8-14.4L5.8 366.1c-7.6-13.2-4.9-29.8 6.5-39.9l53.4-47.5c-.9-7.4-1.3-15-1.3-22.7s.5-15.3 1.3-22.7L12.3 185.8c-11.4-10.1-14-26.8-6.5-39.9L35.7 94.1c7.6-13.2 23.4-19.2 37.8-14.4l67.8 22.5c12.1-9.1 25.3-16.7 39.3-22.8L195.1 9.5zM256.3 336a80 80 0 1 0 -.6-160 80 80 0 1 0 .6 160z"]
  }, Aoe = {
    prefix: "fas",
    iconName: "up-right-and-down-left-from-center",
    icon: [512, 512, ["expand-alt"], "f424", "M344 0L488 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39-87 87c-9.4 9.4-24.6 9.4-33.9 0l-32-32c-9.4-9.4-9.4-24.6 0-33.9l87-87-39-39c-6.9-6.9-8.9-17.2-5.2-26.2S334.3 0 344 0zM168 512L24 512c-13.3 0-24-10.7-24-24L0 344c0-9.7 5.8-18.5 14.8-22.2S34.1 320.2 41 327l39 39 87-87c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2S177.7 512 168 512z"]
  }, Roe = {
    prefix: "fas",
    iconName: "xmark",
    icon: [384, 512, [128473, 10005, 10006, 10060, 215, "close", "multiply", "remove", "times"], "f00d", "M55.1 73.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L147.2 256 9.9 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192.5 301.3 329.9 438.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.8 256 375.1 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192.5 210.7 55.1 73.4z"]
  }, Ooe = {
    prefix: "fas",
    iconName: "lock-open",
    icon: [576, 512, [], "f3c1", "M384 96c0-35.3 28.7-64 64-64s64 28.7 64 64l0 32c0 17.7 14.3 32 32 32s32-14.3 32-32l0-32c0-70.7-57.3-128-128-128S320 25.3 320 96l0 64-160 0c-35.3 0-64 28.7-64 64l0 224c0 35.3 28.7 64 64 64l256 0c35.3 0 64-28.7 64-64l0-224c0-35.3-28.7-64-64-64l-32 0 0-64z"]
  }, Moe = {
    prefix: "fas",
    iconName: "circle-check",
    icon: [512, 512, [61533, "check-circle"], "f058", "M256 512a256 256 0 1 1 0-512 256 256 0 1 1 0 512zM374 145.7c-10.7-7.8-25.7-5.4-33.5 5.3L221.1 315.2 169 263.1c-9.4-9.4-24.6-9.4-33.9 0s-9.4 24.6 0 33.9l72 72c5 5 11.8 7.5 18.8 7s13.4-4.1 17.5-9.8L379.3 179.2c7.8-10.7 5.4-25.7-5.3-33.5z"]
  }, Noe = {
    prefix: "fas",
    iconName: "circle-play",
    icon: [512, 512, [61469, "play-circle"], "f144", "M0 256a256 256 0 1 1 512 0 256 256 0 1 1 -512 0zM188.3 147.1c-7.6 4.2-12.3 12.3-12.3 20.9l0 176c0 8.7 4.7 16.7 12.3 20.9s16.8 4.1 24.3-.5l144-88c7.1-4.4 11.5-12.1 11.5-20.5s-4.4-16.1-11.5-20.5l-144-88c-7.4-4.5-16.7-4.7-24.3-.5z"]
  }, Poe = {
    prefix: "fas",
    iconName: "chevron-down",
    icon: [448, 512, [], "f078", "M201.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L224 338.7 54.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"]
  }, Ioe = {
    prefix: "fas",
    iconName: "chevron-left",
    icon: [320, 512, [9001], "f053", "M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l192 192c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256 246.6 86.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-192 192z"]
  }, $oe = {
    prefix: "fas",
    iconName: "lock",
    icon: [384, 512, [128274], "f023", "M128 96l0 64 128 0 0-64c0-35.3-28.7-64-64-64s-64 28.7-64 64zM64 160l0-64C64 25.3 121.3-32 192-32S320 25.3 320 96l0 64c35.3 0 64 28.7 64 64l0 224c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64L0 224c0-35.3 28.7-64 64-64z"]
  }, joe = {
    prefix: "fas",
    iconName: "down-left-and-up-right-to-center",
    icon: [512, 512, ["compress-alt"], "f422", "M439.5 7c9.4-9.4 24.6-9.4 33.9 0l32 32c9.4 9.4 9.4 24.6 0 33.9l-87 87 39 39c6.9 6.9 8.9 17.2 5.2 26.2S450.2 240 440.5 240l-144 0c-13.3 0-24-10.7-24-24l0-144c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2l39 39 87-87zM72.5 272l144 0c13.3 0 24 10.7 24 24l0 144c0 9.7-5.8 18.5-14.8 22.2s-19.3 1.7-26.2-5.2l-39-39-87 87c-9.4 9.4-24.6 9.4-33.9 0l-32-32c-9.4-9.4-9.4-24.6 0-33.9l87-87-39-39c-6.9-6.9-8.9-17.2-5.2-26.2S62.8 272 72.5 272z"]
  }, Doe = {
    prefix: "fas",
    iconName: "compress",
    icon: [448, 512, [], "f066", "M160 64c0-17.7-14.3-32-32-32S96 46.3 96 64l0 64-64 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32l0-96zM32 320c-17.7 0-32 14.3-32 32s14.3 32 32 32l64 0 0 64c0 17.7 14.3 32 32 32s32-14.3 32-32l0-96c0-17.7-14.3-32-32-32l-96 0zM352 64c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-64 0 0-64zM320 320c-17.7 0-32 14.3-32 32l0 96c0 17.7 14.3 32 32 32s32-14.3 32-32l0-64 64 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-96 0z"]
  }, Foe = {
    prefix: "fas",
    iconName: "bars",
    icon: [448, 512, ["navicon"], "f0c9", "M0 96C0 78.3 14.3 64 32 64l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 128C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 288c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32L32 448c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"]
  };
  hf.autoAddCss = !1;
  const tr = (e) => {
    const { style: t, ...n } = e;
    return /* @__PURE__ */ S.jsx("span", { style: t, children: /* @__PURE__ */ S.jsx(bz, { ...n }) });
  }, Xk = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Foe }), Qp = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Eoe }), c0 = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Ioe }), xz = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: _oe }), Loe = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Doe }), zoe = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: joe }), Boe = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Aoe }), u0 = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Poe }), Jp = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Soe }), Hh = Jp, Nb = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Roe }), Uoe = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Ooe }), Voe = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: $oe }), Hoe = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: koe }), qoe = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Noe }), Woe = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: woe }), Goe = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Toe }), Koe = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Moe }), Yoe = (e) => /* @__PURE__ */ S.jsx(tr, { ...e, icon: Coe }), wz = T.createContext(null), Vt = () => {
    const e = T.useContext(wz);
    if (!e)
      throw new Error(
        "useFuncNodesContext must be used within a FuncNodesContext.Provider"
      );
    return e;
  }, Sz = T.createContext(
    void 0
  ), Zk = () => {
    const e = T.useContext(Sz);
    if (!e)
      throw new Error("useKeyPress must be used within a KeyPressProvider");
    return e;
  }, Xoe = ({
    children: e,
    preventDefault: t = !1,
    ignoredKeys: n = [],
    debug: r = !1,
    target: o
  }) => {
    const [i, a] = T.useState(/* @__PURE__ */ new Set()), s = T.useMemo(
      () => new Set(n),
      [n]
    ), c = T.useRef(i);
    c.current = i;
    const u = T.useMemo(
      () => ({
        keys: i,
        isKeyPressed: (d) => i.has(d),
        areKeysPressed: (...d) => d.every((p) => i.has(p)),
        isAnyKeyPressed: (...d) => d.some((p) => i.has(p))
      }),
      [i]
    );
    return T.useEffect(() => {
      const d = o ?? window;
      if (!d) return;
      const p = (b) => {
        const v = b.key;
        s.has(v) || (t && b.preventDefault(), c.current.has(v) || (r && console.log(`[KeyPress] Key down: ${v}`), a((x) => {
          const E = new Set(x);
          return E.add(v), E;
        })));
      }, m = (b) => {
        const v = b.key;
        c.current.has(v) && (r && console.log(`[KeyPress] Key up: ${v}`), a((x) => {
          const E = new Set(x);
          return E.delete(v), E;
        }));
      }, g = () => {
        c.current.size > 0 && (r && console.log("[KeyPress] Window blur - clearing all keys"), a(/* @__PURE__ */ new Set()));
      }, y = () => {
        document.hidden && c.current.size > 0 && (r && console.log("[KeyPress] Tab hidden - clearing all keys"), a(/* @__PURE__ */ new Set()));
      };
      return d.addEventListener("keydown", p), d.addEventListener("keyup", m), d.addEventListener("blur", g), document.addEventListener("visibilitychange", y), () => {
        d.removeEventListener("keydown", p), d.removeEventListener("keyup", m), d.removeEventListener("blur", g), document.removeEventListener("visibilitychange", y);
      };
    }, [t, s, r, o]), /* @__PURE__ */ S.jsx(Sz.Provider, { value: u, children: e });
  }, _z = T.createContext({
    colorTheme: "classic",
    setColorTheme: () => {
    },
    previewColorTheme: () => {
    }
  }), Zoe = ({
    available_themes: e,
    children: t,
    default_theme: n
  }) => {
    const r = T.useMemo(
      () => new Set(e),
      [e]
    ), [o, i] = T.useState(
      n ?? e[0]
    ), a = T.useCallback(
      (u) => {
        if (!r.has(u))
          throw new Error(
            `Theme "${u}" is not in available_themes: [${Array.from(
              r
            ).join(", ")}]`
          );
        i(u);
        const d = {
          colorTheme: u
        };
        try {
          localStorage.setItem("theme", JSON.stringify(d));
        } catch (p) {
          console.warn("Failed to save theme to localStorage:", p);
        }
      },
      [r]
    ), s = T.useCallback(
      (u) => {
        if (!r.has(u))
          throw new Error(
            `Theme "${u}" is not in available_themes: [${Array.from(
              r
            ).join(", ")}]`
          );
        i(u);
      },
      [r]
    );
    T.useEffect(() => {
      document.documentElement.setAttribute("fn-data-color-theme", o);
    }, [o]), T.useEffect(() => {
      try {
        const u = localStorage.getItem("theme");
        if (!u) return;
        const d = JSON.parse(u);
        d.colorTheme && r.has(d.colorTheme) && i(d.colorTheme);
      } catch (u) {
        console.warn("Failed to load theme from localStorage:", u);
      }
    }, [r]), T.useEffect(() => {
      if (n && !r.has(n)) {
        const u = Array.from(r)[0];
        u && a(u);
      }
    }, [r, n, a]), T.useEffect(() => {
      if (!r.has(o)) {
        const u = Array.from(r)[0];
        u && a(u);
      }
    }, [o, r, a]);
    const c = T.useMemo(
      () => ({
        colorTheme: o,
        setColorTheme: a,
        previewColorTheme: s
      }),
      [o, a, s]
    );
    return /* @__PURE__ */ S.jsx(_z.Provider, { value: c, children: t });
  }, Ez = () => {
    const e = T.useContext(_z);
    if (!e)
      throw new Error("useTheme must be used within a ThemeProvider");
    return e;
  }, Cz = T.memo(({ button: e, index: t }) => {
    const n = T.useCallback(
      (o) => {
        o.preventDefault(), e.onClick(o);
      },
      [e]
    ), r = /* @__PURE__ */ S.jsx(
      "button",
      {
        className: `dialog-send-button ${e.className || ""}`,
        onClick: n,
        disabled: e.disabled,
        "aria-label": e.ariaLabel,
        type: "button",
        children: e.text
      }
    );
    return e.close !== !1 ? /* @__PURE__ */ S.jsx(pL, { asChild: !0, children: r }, t) : /* @__PURE__ */ S.jsx(T.Fragment, { children: r }, t);
  });
  Cz.displayName = "DialogButton";
  const Ji = T.memo(
    ({
      trigger: e,
      title: t,
      description: n,
      children: r,
      closebutton: o = !0,
      onOpenChange: i,
      buttons: a = [],
      open: s,
      setOpen: c,
      modal: u = !0,
      dialogClassName: d = "default-dialog-content",
      ariaLabel: p,
      ariaDescription: m
    }) => {
      const y = Vt().local_state((E) => E.funcnodescontainerRef), b = T.useMemo(
        () => `dialog-content funcnodescontainer ${d}`,
        [d]
      ), v = T.useCallback(
        (E) => {
          try {
            c?.(E), i?.(E);
          } catch (_) {
            console.error("Error in dialog open change handler:", _);
          }
        },
        [c, i]
      ), x = T.useMemo(
        () => a.map((E, _) => /* @__PURE__ */ S.jsx(
          Cz,
          {
            button: E,
            index: _
          },
          `${E.text}-${_}`
        )),
        [a]
      );
      return /* @__PURE__ */ S.jsxs($ee, { open: s, onOpenChange: v, modal: u, children: [
        e && /* @__PURE__ */ S.jsx(jee, { asChild: !0, children: e }),
        /* @__PURE__ */ S.jsxs(Dee, { container: y, children: [
          /* @__PURE__ */ S.jsx(Fee, { className: "dialog-overlay funcnodescontainer" }),
          /* @__PURE__ */ S.jsx(
            Lee,
            {
              asChild: !0,
              ...!n && !m ? { "aria-describedby": void 0 } : {},
              children: /* @__PURE__ */ S.jsxs(
                "div",
                {
                  className: b,
                  role: "dialog",
                  "aria-label": p || t,
                  "aria-description": m || (typeof n == "string" ? n : void 0),
                  children: [
                    t ? /* @__PURE__ */ S.jsx(I2, { className: "dialog-title", children: t }) : /* @__PURE__ */ S.jsx(Vee, { asChild: !0, children: /* @__PURE__ */ S.jsx(I2, { className: "dialog-title", children: p || "Dialog" }) }),
                    n && /* @__PURE__ */ S.jsx(zee, { className: "dialog-description", children: n }),
                    /* @__PURE__ */ S.jsx("div", { className: "dialog-children", role: "main", children: r }),
                    a.length > 0 && /* @__PURE__ */ S.jsx(
                      "div",
                      {
                        className: "dialog-buttons",
                        role: "group",
                        "aria-label": "Dialog actions",
                        children: x
                      }
                    ),
                    o && /* @__PURE__ */ S.jsx(pL, { asChild: !0, children: /* @__PURE__ */ S.jsx(
                      "button",
                      {
                        className: "dialog-close-button",
                        "aria-label": "Close dialog",
                        type: "button",
                        children: /* @__PURE__ */ S.jsx(Nb, {})
                      }
                    ) })
                  ]
                }
              )
            }
          )
        ] })
      ] });
    }
  );
  Ji.displayName = "CustomDialog";
  const Qoe = ["top", "right", "bottom", "left"], sl = Math.min, ro = Math.max, f0 = Math.round, oy = Math.floor, Hi = (e) => ({
    x: e,
    y: e
  }), Joe = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  }, eie = {
    start: "end",
    end: "start"
  };
  function HE(e, t, n) {
    return ro(e, sl(t, n));
  }
  function Ka(e, t) {
    return typeof e == "function" ? e(t) : e;
  }
  function Ya(e) {
    return e.split("-")[0];
  }
  function Ff(e) {
    return e.split("-")[1];
  }
  function Qk(e) {
    return e === "x" ? "y" : "x";
  }
  function Jk(e) {
    return e === "y" ? "height" : "width";
  }
  const tie = /* @__PURE__ */ new Set(["top", "bottom"]);
  function Ni(e) {
    return tie.has(Ya(e)) ? "y" : "x";
  }
  function eT(e) {
    return Qk(Ni(e));
  }
  function nie(e, t, n) {
    n === void 0 && (n = !1);
    const r = Ff(e), o = eT(e), i = Jk(o);
    let a = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
    return t.reference[i] > t.floating[i] && (a = d0(a)), [a, d0(a)];
  }
  function rie(e) {
    const t = d0(e);
    return [qE(e), t, qE(t)];
  }
  function qE(e) {
    return e.replace(/start|end/g, (t) => eie[t]);
  }
  const hI = ["left", "right"], mI = ["right", "left"], oie = ["top", "bottom"], iie = ["bottom", "top"];
  function aie(e, t, n) {
    switch (e) {
      case "top":
      case "bottom":
        return n ? t ? mI : hI : t ? hI : mI;
      case "left":
      case "right":
        return t ? oie : iie;
      default:
        return [];
    }
  }
  function sie(e, t, n, r) {
    const o = Ff(e);
    let i = aie(Ya(e), n === "start", r);
    return o && (i = i.map((a) => a + "-" + o), t && (i = i.concat(i.map(qE)))), i;
  }
  function d0(e) {
    return e.replace(/left|right|bottom|top/g, (t) => Joe[t]);
  }
  function lie(e) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...e
    };
  }
  function kz(e) {
    return typeof e != "number" ? lie(e) : {
      top: e,
      right: e,
      bottom: e,
      left: e
    };
  }
  function p0(e) {
    const {
      x: t,
      y: n,
      width: r,
      height: o
    } = e;
    return {
      width: r,
      height: o,
      top: n,
      left: t,
      right: t + r,
      bottom: n + o,
      x: t,
      y: n
    };
  }
  function gI(e, t, n) {
    let {
      reference: r,
      floating: o
    } = e;
    const i = Ni(t), a = eT(t), s = Jk(a), c = Ya(t), u = i === "y", d = r.x + r.width / 2 - o.width / 2, p = r.y + r.height / 2 - o.height / 2, m = r[s] / 2 - o[s] / 2;
    let g;
    switch (c) {
      case "top":
        g = {
          x: d,
          y: r.y - o.height
        };
        break;
      case "bottom":
        g = {
          x: d,
          y: r.y + r.height
        };
        break;
      case "right":
        g = {
          x: r.x + r.width,
          y: p
        };
        break;
      case "left":
        g = {
          x: r.x - o.width,
          y: p
        };
        break;
      default:
        g = {
          x: r.x,
          y: r.y
        };
    }
    switch (Ff(t)) {
      case "start":
        g[a] -= m * (n && u ? -1 : 1);
        break;
      case "end":
        g[a] += m * (n && u ? -1 : 1);
        break;
    }
    return g;
  }
  const cie = async (e, t, n) => {
    const {
      placement: r = "bottom",
      strategy: o = "absolute",
      middleware: i = [],
      platform: a
    } = n, s = i.filter(Boolean), c = await (a.isRTL == null ? void 0 : a.isRTL(t));
    let u = await a.getElementRects({
      reference: e,
      floating: t,
      strategy: o
    }), {
      x: d,
      y: p
    } = gI(u, r, c), m = r, g = {}, y = 0;
    for (let b = 0; b < s.length; b++) {
      const {
        name: v,
        fn: x
      } = s[b], {
        x: E,
        y: _,
        data: C,
        reset: k
      } = await x({
        x: d,
        y: p,
        initialPlacement: r,
        placement: m,
        strategy: o,
        middlewareData: g,
        rects: u,
        platform: a,
        elements: {
          reference: e,
          floating: t
        }
      });
      d = E ?? d, p = _ ?? p, g = {
        ...g,
        [v]: {
          ...g[v],
          ...C
        }
      }, k && y <= 50 && (y++, typeof k == "object" && (k.placement && (m = k.placement), k.rects && (u = k.rects === !0 ? await a.getElementRects({
        reference: e,
        floating: t,
        strategy: o
      }) : k.rects), {
        x: d,
        y: p
      } = gI(u, m, c)), b = -1);
    }
    return {
      x: d,
      y: p,
      placement: m,
      strategy: o,
      middlewareData: g
    };
  };
  async function eh(e, t) {
    var n;
    t === void 0 && (t = {});
    const {
      x: r,
      y: o,
      platform: i,
      rects: a,
      elements: s,
      strategy: c
    } = e, {
      boundary: u = "clippingAncestors",
      rootBoundary: d = "viewport",
      elementContext: p = "floating",
      altBoundary: m = !1,
      padding: g = 0
    } = Ka(t, e), y = kz(g), v = s[m ? p === "floating" ? "reference" : "floating" : p], x = p0(await i.getClippingRect({
      element: (n = await (i.isElement == null ? void 0 : i.isElement(v))) == null || n ? v : v.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(s.floating)),
      boundary: u,
      rootBoundary: d,
      strategy: c
    })), E = p === "floating" ? {
      x: r,
      y: o,
      width: a.floating.width,
      height: a.floating.height
    } : a.reference, _ = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(s.floating)), C = await (i.isElement == null ? void 0 : i.isElement(_)) ? await (i.getScale == null ? void 0 : i.getScale(_)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    }, k = p0(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
      elements: s,
      rect: E,
      offsetParent: _,
      strategy: c
    }) : E);
    return {
      top: (x.top - k.top + y.top) / C.y,
      bottom: (k.bottom - x.bottom + y.bottom) / C.y,
      left: (x.left - k.left + y.left) / C.x,
      right: (k.right - x.right + y.right) / C.x
    };
  }
  const uie = (e) => ({
    name: "arrow",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: o,
        rects: i,
        platform: a,
        elements: s,
        middlewareData: c
      } = t, {
        element: u,
        padding: d = 0
      } = Ka(e, t) || {};
      if (u == null)
        return {};
      const p = kz(d), m = {
        x: n,
        y: r
      }, g = eT(o), y = Jk(g), b = await a.getDimensions(u), v = g === "y", x = v ? "top" : "left", E = v ? "bottom" : "right", _ = v ? "clientHeight" : "clientWidth", C = i.reference[y] + i.reference[g] - m[g] - i.floating[y], k = m[g] - i.reference[g], A = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(u));
      let O = A ? A[_] : 0;
      (!O || !await (a.isElement == null ? void 0 : a.isElement(A))) && (O = s.floating[_] || i.floating[y]);
      const P = C / 2 - k / 2, I = O / 2 - b[y] / 2 - 1, $ = sl(p[x], I), L = sl(p[E], I), N = $, U = O - b[y] - L, j = O / 2 - b[y] / 2 + P, V = HE(N, j, U), F = !c.arrow && Ff(o) != null && j !== V && i.reference[y] / 2 - (j < N ? $ : L) - b[y] / 2 < 0, K = F ? j < N ? j - N : j - U : 0;
      return {
        [g]: m[g] + K,
        data: {
          [g]: V,
          centerOffset: j - V - K,
          ...F && {
            alignmentOffset: K
          }
        },
        reset: F
      };
    }
  }), fie = function(e) {
    return e === void 0 && (e = {}), {
      name: "flip",
      options: e,
      async fn(t) {
        var n, r;
        const {
          placement: o,
          middlewareData: i,
          rects: a,
          initialPlacement: s,
          platform: c,
          elements: u
        } = t, {
          mainAxis: d = !0,
          crossAxis: p = !0,
          fallbackPlacements: m,
          fallbackStrategy: g = "bestFit",
          fallbackAxisSideDirection: y = "none",
          flipAlignment: b = !0,
          ...v
        } = Ka(e, t);
        if ((n = i.arrow) != null && n.alignmentOffset)
          return {};
        const x = Ya(o), E = Ni(s), _ = Ya(s) === s, C = await (c.isRTL == null ? void 0 : c.isRTL(u.floating)), k = m || (_ || !b ? [d0(s)] : rie(s)), A = y !== "none";
        !m && A && k.push(...sie(s, b, y, C));
        const O = [s, ...k], P = await eh(t, v), I = [];
        let $ = ((r = i.flip) == null ? void 0 : r.overflows) || [];
        if (d && I.push(P[x]), p) {
          const j = nie(o, a, C);
          I.push(P[j[0]], P[j[1]]);
        }
        if ($ = [...$, {
          placement: o,
          overflows: I
        }], !I.every((j) => j <= 0)) {
          var L, N;
          const j = (((L = i.flip) == null ? void 0 : L.index) || 0) + 1, V = O[j];
          if (V && (!(p === "alignment" ? E !== Ni(V) : !1) || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          $.every((W) => W.overflows[0] > 0 && Ni(W.placement) === E)))
            return {
              data: {
                index: j,
                overflows: $
              },
              reset: {
                placement: V
              }
            };
          let F = (N = $.filter((K) => K.overflows[0] <= 0).sort((K, W) => K.overflows[1] - W.overflows[1])[0]) == null ? void 0 : N.placement;
          if (!F)
            switch (g) {
              case "bestFit": {
                var U;
                const K = (U = $.filter((W) => {
                  if (A) {
                    const Y = Ni(W.placement);
                    return Y === E || // Create a bias to the `y` side axis due to horizontal
                    // reading directions favoring greater width.
                    Y === "y";
                  }
                  return !0;
                }).map((W) => [W.placement, W.overflows.filter((Y) => Y > 0).reduce((Y, B) => Y + B, 0)]).sort((W, Y) => W[1] - Y[1])[0]) == null ? void 0 : U[0];
                K && (F = K);
                break;
              }
              case "initialPlacement":
                F = s;
                break;
            }
          if (o !== F)
            return {
              reset: {
                placement: F
              }
            };
        }
        return {};
      }
    };
  };
  function yI(e, t) {
    return {
      top: e.top - t.height,
      right: e.right - t.width,
      bottom: e.bottom - t.height,
      left: e.left - t.width
    };
  }
  function vI(e) {
    return Qoe.some((t) => e[t] >= 0);
  }
  const die = function(e) {
    return e === void 0 && (e = {}), {
      name: "hide",
      options: e,
      async fn(t) {
        const {
          rects: n
        } = t, {
          strategy: r = "referenceHidden",
          ...o
        } = Ka(e, t);
        switch (r) {
          case "referenceHidden": {
            const i = await eh(t, {
              ...o,
              elementContext: "reference"
            }), a = yI(i, n.reference);
            return {
              data: {
                referenceHiddenOffsets: a,
                referenceHidden: vI(a)
              }
            };
          }
          case "escaped": {
            const i = await eh(t, {
              ...o,
              altBoundary: !0
            }), a = yI(i, n.floating);
            return {
              data: {
                escapedOffsets: a,
                escaped: vI(a)
              }
            };
          }
          default:
            return {};
        }
      }
    };
  }, Tz = /* @__PURE__ */ new Set(["left", "top"]);
  async function pie(e, t) {
    const {
      placement: n,
      platform: r,
      elements: o
    } = e, i = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)), a = Ya(n), s = Ff(n), c = Ni(n) === "y", u = Tz.has(a) ? -1 : 1, d = i && c ? -1 : 1, p = Ka(t, e);
    let {
      mainAxis: m,
      crossAxis: g,
      alignmentAxis: y
    } = typeof p == "number" ? {
      mainAxis: p,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: p.mainAxis || 0,
      crossAxis: p.crossAxis || 0,
      alignmentAxis: p.alignmentAxis
    };
    return s && typeof y == "number" && (g = s === "end" ? y * -1 : y), c ? {
      x: g * d,
      y: m * u
    } : {
      x: m * u,
      y: g * d
    };
  }
  const hie = function(e) {
    return e === void 0 && (e = 0), {
      name: "offset",
      options: e,
      async fn(t) {
        var n, r;
        const {
          x: o,
          y: i,
          placement: a,
          middlewareData: s
        } = t, c = await pie(t, e);
        return a === ((n = s.offset) == null ? void 0 : n.placement) && (r = s.arrow) != null && r.alignmentOffset ? {} : {
          x: o + c.x,
          y: i + c.y,
          data: {
            ...c,
            placement: a
          }
        };
      }
    };
  }, mie = function(e) {
    return e === void 0 && (e = {}), {
      name: "shift",
      options: e,
      async fn(t) {
        const {
          x: n,
          y: r,
          placement: o
        } = t, {
          mainAxis: i = !0,
          crossAxis: a = !1,
          limiter: s = {
            fn: (v) => {
              let {
                x,
                y: E
              } = v;
              return {
                x,
                y: E
              };
            }
          },
          ...c
        } = Ka(e, t), u = {
          x: n,
          y: r
        }, d = await eh(t, c), p = Ni(Ya(o)), m = Qk(p);
        let g = u[m], y = u[p];
        if (i) {
          const v = m === "y" ? "top" : "left", x = m === "y" ? "bottom" : "right", E = g + d[v], _ = g - d[x];
          g = HE(E, g, _);
        }
        if (a) {
          const v = p === "y" ? "top" : "left", x = p === "y" ? "bottom" : "right", E = y + d[v], _ = y - d[x];
          y = HE(E, y, _);
        }
        const b = s.fn({
          ...t,
          [m]: g,
          [p]: y
        });
        return {
          ...b,
          data: {
            x: b.x - n,
            y: b.y - r,
            enabled: {
              [m]: i,
              [p]: a
            }
          }
        };
      }
    };
  }, gie = function(e) {
    return e === void 0 && (e = {}), {
      options: e,
      fn(t) {
        const {
          x: n,
          y: r,
          placement: o,
          rects: i,
          middlewareData: a
        } = t, {
          offset: s = 0,
          mainAxis: c = !0,
          crossAxis: u = !0
        } = Ka(e, t), d = {
          x: n,
          y: r
        }, p = Ni(o), m = Qk(p);
        let g = d[m], y = d[p];
        const b = Ka(s, t), v = typeof b == "number" ? {
          mainAxis: b,
          crossAxis: 0
        } : {
          mainAxis: 0,
          crossAxis: 0,
          ...b
        };
        if (c) {
          const _ = m === "y" ? "height" : "width", C = i.reference[m] - i.floating[_] + v.mainAxis, k = i.reference[m] + i.reference[_] - v.mainAxis;
          g < C ? g = C : g > k && (g = k);
        }
        if (u) {
          var x, E;
          const _ = m === "y" ? "width" : "height", C = Tz.has(Ya(o)), k = i.reference[p] - i.floating[_] + (C && ((x = a.offset) == null ? void 0 : x[p]) || 0) + (C ? 0 : v.crossAxis), A = i.reference[p] + i.reference[_] + (C ? 0 : ((E = a.offset) == null ? void 0 : E[p]) || 0) - (C ? v.crossAxis : 0);
          y < k ? y = k : y > A && (y = A);
        }
        return {
          [m]: g,
          [p]: y
        };
      }
    };
  }, yie = function(e) {
    return e === void 0 && (e = {}), {
      name: "size",
      options: e,
      async fn(t) {
        var n, r;
        const {
          placement: o,
          rects: i,
          platform: a,
          elements: s
        } = t, {
          apply: c = () => {
          },
          ...u
        } = Ka(e, t), d = await eh(t, u), p = Ya(o), m = Ff(o), g = Ni(o) === "y", {
          width: y,
          height: b
        } = i.floating;
        let v, x;
        p === "top" || p === "bottom" ? (v = p, x = m === (await (a.isRTL == null ? void 0 : a.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (x = p, v = m === "end" ? "top" : "bottom");
        const E = b - d.top - d.bottom, _ = y - d.left - d.right, C = sl(b - d[v], E), k = sl(y - d[x], _), A = !t.middlewareData.shift;
        let O = C, P = k;
        if ((n = t.middlewareData.shift) != null && n.enabled.x && (P = _), (r = t.middlewareData.shift) != null && r.enabled.y && (O = E), A && !m) {
          const $ = ro(d.left, 0), L = ro(d.right, 0), N = ro(d.top, 0), U = ro(d.bottom, 0);
          g ? P = y - 2 * ($ !== 0 || L !== 0 ? $ + L : ro(d.left, d.right)) : O = b - 2 * (N !== 0 || U !== 0 ? N + U : ro(d.top, d.bottom));
        }
        await c({
          ...t,
          availableWidth: P,
          availableHeight: O
        });
        const I = await a.getDimensions(s.floating);
        return y !== I.width || b !== I.height ? {
          reset: {
            rects: !0
          }
        } : {};
      }
    };
  };
  function Pb() {
    return typeof window < "u";
  }
  function Lf(e) {
    return Az(e) ? (e.nodeName || "").toLowerCase() : "#document";
  }
  function co(e) {
    var t;
    return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
  }
  function ea(e) {
    var t;
    return (t = (Az(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
  }
  function Az(e) {
    return Pb() ? e instanceof Node || e instanceof co(e).Node : !1;
  }
  function ni(e) {
    return Pb() ? e instanceof Element || e instanceof co(e).Element : !1;
  }
  function Wi(e) {
    return Pb() ? e instanceof HTMLElement || e instanceof co(e).HTMLElement : !1;
  }
  function bI(e) {
    return !Pb() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof co(e).ShadowRoot;
  }
  const vie = /* @__PURE__ */ new Set(["inline", "contents"]);
  function qh(e) {
    const {
      overflow: t,
      overflowX: n,
      overflowY: r,
      display: o
    } = ri(e);
    return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !vie.has(o);
  }
  const bie = /* @__PURE__ */ new Set(["table", "td", "th"]);
  function xie(e) {
    return bie.has(Lf(e));
  }
  const wie = [":popover-open", ":modal"];
  function Ib(e) {
    return wie.some((t) => {
      try {
        return e.matches(t);
      } catch {
        return !1;
      }
    });
  }
  const Sie = ["transform", "translate", "scale", "rotate", "perspective"], _ie = ["transform", "translate", "scale", "rotate", "perspective", "filter"], Eie = ["paint", "layout", "strict", "content"];
  function tT(e) {
    const t = nT(), n = ni(e) ? ri(e) : e;
    return Sie.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || _ie.some((r) => (n.willChange || "").includes(r)) || Eie.some((r) => (n.contain || "").includes(r));
  }
  function Cie(e) {
    let t = ll(e);
    for (; Wi(t) && !mf(t); ) {
      if (tT(t))
        return t;
      if (Ib(t))
        return null;
      t = ll(t);
    }
    return null;
  }
  function nT() {
    return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
  }
  const kie = /* @__PURE__ */ new Set(["html", "body", "#document"]);
  function mf(e) {
    return kie.has(Lf(e));
  }
  function ri(e) {
    return co(e).getComputedStyle(e);
  }
  function $b(e) {
    return ni(e) ? {
      scrollLeft: e.scrollLeft,
      scrollTop: e.scrollTop
    } : {
      scrollLeft: e.scrollX,
      scrollTop: e.scrollY
    };
  }
  function ll(e) {
    if (Lf(e) === "html")
      return e;
    const t = (
      // Step into the shadow DOM of the parent of a slotted node.
      e.assignedSlot || // DOM Element detected.
      e.parentNode || // ShadowRoot detected.
      bI(e) && e.host || // Fallback.
      ea(e)
    );
    return bI(t) ? t.host : t;
  }
  function Rz(e) {
    const t = ll(e);
    return mf(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Wi(t) && qh(t) ? t : Rz(t);
  }
  function th(e, t, n) {
    var r;
    t === void 0 && (t = []), n === void 0 && (n = !0);
    const o = Rz(e), i = o === ((r = e.ownerDocument) == null ? void 0 : r.body), a = co(o);
    if (i) {
      const s = WE(a);
      return t.concat(a, a.visualViewport || [], qh(o) ? o : [], s && n ? th(s) : []);
    }
    return t.concat(o, th(o, [], n));
  }
  function WE(e) {
    return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
  }
  function Oz(e) {
    const t = ri(e);
    let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
    const o = Wi(e), i = o ? e.offsetWidth : n, a = o ? e.offsetHeight : r, s = f0(n) !== i || f0(r) !== a;
    return s && (n = i, r = a), {
      width: n,
      height: r,
      $: s
    };
  }
  function rT(e) {
    return ni(e) ? e : e.contextElement;
  }
  function nf(e) {
    const t = rT(e);
    if (!Wi(t))
      return Hi(1);
    const n = t.getBoundingClientRect(), {
      width: r,
      height: o,
      $: i
    } = Oz(t);
    let a = (i ? f0(n.width) : n.width) / r, s = (i ? f0(n.height) : n.height) / o;
    return (!a || !Number.isFinite(a)) && (a = 1), (!s || !Number.isFinite(s)) && (s = 1), {
      x: a,
      y: s
    };
  }
  const Tie = /* @__PURE__ */ Hi(0);
  function Mz(e) {
    const t = co(e);
    return !nT() || !t.visualViewport ? Tie : {
      x: t.visualViewport.offsetLeft,
      y: t.visualViewport.offsetTop
    };
  }
  function Aie(e, t, n) {
    return t === void 0 && (t = !1), !n || t && n !== co(e) ? !1 : t;
  }
  function fc(e, t, n, r) {
    t === void 0 && (t = !1), n === void 0 && (n = !1);
    const o = e.getBoundingClientRect(), i = rT(e);
    let a = Hi(1);
    t && (r ? ni(r) && (a = nf(r)) : a = nf(e));
    const s = Aie(i, n, r) ? Mz(i) : Hi(0);
    let c = (o.left + s.x) / a.x, u = (o.top + s.y) / a.y, d = o.width / a.x, p = o.height / a.y;
    if (i) {
      const m = co(i), g = r && ni(r) ? co(r) : r;
      let y = m, b = WE(y);
      for (; b && r && g !== y; ) {
        const v = nf(b), x = b.getBoundingClientRect(), E = ri(b), _ = x.left + (b.clientLeft + parseFloat(E.paddingLeft)) * v.x, C = x.top + (b.clientTop + parseFloat(E.paddingTop)) * v.y;
        c *= v.x, u *= v.y, d *= v.x, p *= v.y, c += _, u += C, y = co(b), b = WE(y);
      }
    }
    return p0({
      width: d,
      height: p,
      x: c,
      y: u
    });
  }
  function oT(e, t) {
    const n = $b(e).scrollLeft;
    return t ? t.left + n : fc(ea(e)).left + n;
  }
  function Nz(e, t, n) {
    n === void 0 && (n = !1);
    const r = e.getBoundingClientRect(), o = r.left + t.scrollLeft - (n ? 0 : (
      // RTL <body> scrollbar.
      oT(e, r)
    )), i = r.top + t.scrollTop;
    return {
      x: o,
      y: i
    };
  }
  function Rie(e) {
    let {
      elements: t,
      rect: n,
      offsetParent: r,
      strategy: o
    } = e;
    const i = o === "fixed", a = ea(r), s = t ? Ib(t.floating) : !1;
    if (r === a || s && i)
      return n;
    let c = {
      scrollLeft: 0,
      scrollTop: 0
    }, u = Hi(1);
    const d = Hi(0), p = Wi(r);
    if ((p || !p && !i) && ((Lf(r) !== "body" || qh(a)) && (c = $b(r)), Wi(r))) {
      const g = fc(r);
      u = nf(r), d.x = g.x + r.clientLeft, d.y = g.y + r.clientTop;
    }
    const m = a && !p && !i ? Nz(a, c, !0) : Hi(0);
    return {
      width: n.width * u.x,
      height: n.height * u.y,
      x: n.x * u.x - c.scrollLeft * u.x + d.x + m.x,
      y: n.y * u.y - c.scrollTop * u.y + d.y + m.y
    };
  }
  function Oie(e) {
    return Array.from(e.getClientRects());
  }
  function Mie(e) {
    const t = ea(e), n = $b(e), r = e.ownerDocument.body, o = ro(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), i = ro(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
    let a = -n.scrollLeft + oT(e);
    const s = -n.scrollTop;
    return ri(r).direction === "rtl" && (a += ro(t.clientWidth, r.clientWidth) - o), {
      width: o,
      height: i,
      x: a,
      y: s
    };
  }
  function Nie(e, t) {
    const n = co(e), r = ea(e), o = n.visualViewport;
    let i = r.clientWidth, a = r.clientHeight, s = 0, c = 0;
    if (o) {
      i = o.width, a = o.height;
      const u = nT();
      (!u || u && t === "fixed") && (s = o.offsetLeft, c = o.offsetTop);
    }
    return {
      width: i,
      height: a,
      x: s,
      y: c
    };
  }
  const Pie = /* @__PURE__ */ new Set(["absolute", "fixed"]);
  function Iie(e, t) {
    const n = fc(e, !0, t === "fixed"), r = n.top + e.clientTop, o = n.left + e.clientLeft, i = Wi(e) ? nf(e) : Hi(1), a = e.clientWidth * i.x, s = e.clientHeight * i.y, c = o * i.x, u = r * i.y;
    return {
      width: a,
      height: s,
      x: c,
      y: u
    };
  }
  function xI(e, t, n) {
    let r;
    if (t === "viewport")
      r = Nie(e, n);
    else if (t === "document")
      r = Mie(ea(e));
    else if (ni(t))
      r = Iie(t, n);
    else {
      const o = Mz(e);
      r = {
        x: t.x - o.x,
        y: t.y - o.y,
        width: t.width,
        height: t.height
      };
    }
    return p0(r);
  }
  function Pz(e, t) {
    const n = ll(e);
    return n === t || !ni(n) || mf(n) ? !1 : ri(n).position === "fixed" || Pz(n, t);
  }
  function $ie(e, t) {
    const n = t.get(e);
    if (n)
      return n;
    let r = th(e, [], !1).filter((s) => ni(s) && Lf(s) !== "body"), o = null;
    const i = ri(e).position === "fixed";
    let a = i ? ll(e) : e;
    for (; ni(a) && !mf(a); ) {
      const s = ri(a), c = tT(a);
      !c && s.position === "fixed" && (o = null), (i ? !c && !o : !c && s.position === "static" && !!o && Pie.has(o.position) || qh(a) && !c && Pz(e, a)) ? r = r.filter((d) => d !== a) : o = s, a = ll(a);
    }
    return t.set(e, r), r;
  }
  function jie(e) {
    let {
      element: t,
      boundary: n,
      rootBoundary: r,
      strategy: o
    } = e;
    const a = [...n === "clippingAncestors" ? Ib(t) ? [] : $ie(t, this._c) : [].concat(n), r], s = a[0], c = a.reduce((u, d) => {
      const p = xI(t, d, o);
      return u.top = ro(p.top, u.top), u.right = sl(p.right, u.right), u.bottom = sl(p.bottom, u.bottom), u.left = ro(p.left, u.left), u;
    }, xI(t, s, o));
    return {
      width: c.right - c.left,
      height: c.bottom - c.top,
      x: c.left,
      y: c.top
    };
  }
  function Die(e) {
    const {
      width: t,
      height: n
    } = Oz(e);
    return {
      width: t,
      height: n
    };
  }
  function Fie(e, t, n) {
    const r = Wi(t), o = ea(t), i = n === "fixed", a = fc(e, !0, i, t);
    let s = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const c = Hi(0);
    function u() {
      c.x = oT(o);
    }
    if (r || !r && !i)
      if ((Lf(t) !== "body" || qh(o)) && (s = $b(t)), r) {
        const g = fc(t, !0, i, t);
        c.x = g.x + t.clientLeft, c.y = g.y + t.clientTop;
      } else o && u();
    i && !r && o && u();
    const d = o && !r && !i ? Nz(o, s) : Hi(0), p = a.left + s.scrollLeft - c.x - d.x, m = a.top + s.scrollTop - c.y - d.y;
    return {
      x: p,
      y: m,
      width: a.width,
      height: a.height
    };
  }
  function IS(e) {
    return ri(e).position === "static";
  }
  function wI(e, t) {
    if (!Wi(e) || ri(e).position === "fixed")
      return null;
    if (t)
      return t(e);
    let n = e.offsetParent;
    return ea(e) === n && (n = n.ownerDocument.body), n;
  }
  function Iz(e, t) {
    const n = co(e);
    if (Ib(e))
      return n;
    if (!Wi(e)) {
      let o = ll(e);
      for (; o && !mf(o); ) {
        if (ni(o) && !IS(o))
          return o;
        o = ll(o);
      }
      return n;
    }
    let r = wI(e, t);
    for (; r && xie(r) && IS(r); )
      r = wI(r, t);
    return r && mf(r) && IS(r) && !tT(r) ? n : r || Cie(e) || n;
  }
  const Lie = async function(e) {
    const t = this.getOffsetParent || Iz, n = this.getDimensions, r = await n(e.floating);
    return {
      reference: Fie(e.reference, await t(e.floating), e.strategy),
      floating: {
        x: 0,
        y: 0,
        width: r.width,
        height: r.height
      }
    };
  };
  function zie(e) {
    return ri(e).direction === "rtl";
  }
  const Bie = {
    convertOffsetParentRelativeRectToViewportRelativeRect: Rie,
    getDocumentElement: ea,
    getClippingRect: jie,
    getOffsetParent: Iz,
    getElementRects: Lie,
    getClientRects: Oie,
    getDimensions: Die,
    getScale: nf,
    isElement: ni,
    isRTL: zie
  };
  function $z(e, t) {
    return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
  }
  function Uie(e, t) {
    let n = null, r;
    const o = ea(e);
    function i() {
      var s;
      clearTimeout(r), (s = n) == null || s.disconnect(), n = null;
    }
    function a(s, c) {
      s === void 0 && (s = !1), c === void 0 && (c = 1), i();
      const u = e.getBoundingClientRect(), {
        left: d,
        top: p,
        width: m,
        height: g
      } = u;
      if (s || t(), !m || !g)
        return;
      const y = oy(p), b = oy(o.clientWidth - (d + m)), v = oy(o.clientHeight - (p + g)), x = oy(d), _ = {
        rootMargin: -y + "px " + -b + "px " + -v + "px " + -x + "px",
        threshold: ro(0, sl(1, c)) || 1
      };
      let C = !0;
      function k(A) {
        const O = A[0].intersectionRatio;
        if (O !== c) {
          if (!C)
            return a();
          O ? a(!1, O) : r = setTimeout(() => {
            a(!1, 1e-7);
          }, 1e3);
        }
        O === 1 && !$z(u, e.getBoundingClientRect()) && a(), C = !1;
      }
      try {
        n = new IntersectionObserver(k, {
          ..._,
          // Handle <iframe>s
          root: o.ownerDocument
        });
      } catch {
        n = new IntersectionObserver(k, _);
      }
      n.observe(e);
    }
    return a(!0), i;
  }
  function jz(e, t, n, r) {
    r === void 0 && (r = {});
    const {
      ancestorScroll: o = !0,
      ancestorResize: i = !0,
      elementResize: a = typeof ResizeObserver == "function",
      layoutShift: s = typeof IntersectionObserver == "function",
      animationFrame: c = !1
    } = r, u = rT(e), d = o || i ? [...u ? th(u) : [], ...th(t)] : [];
    d.forEach((x) => {
      o && x.addEventListener("scroll", n, {
        passive: !0
      }), i && x.addEventListener("resize", n);
    });
    const p = u && s ? Uie(u, n) : null;
    let m = -1, g = null;
    a && (g = new ResizeObserver((x) => {
      let [E] = x;
      E && E.target === u && g && (g.unobserve(t), cancelAnimationFrame(m), m = requestAnimationFrame(() => {
        var _;
        (_ = g) == null || _.observe(t);
      })), n();
    }), u && !c && g.observe(u), g.observe(t));
    let y, b = c ? fc(e) : null;
    c && v();
    function v() {
      const x = fc(e);
      b && !$z(b, x) && n(), b = x, y = requestAnimationFrame(v);
    }
    return n(), () => {
      var x;
      d.forEach((E) => {
        o && E.removeEventListener("scroll", n), i && E.removeEventListener("resize", n);
      }), p?.(), (x = g) == null || x.disconnect(), g = null, c && cancelAnimationFrame(y);
    };
  }
  const Vie = hie, Hie = mie, qie = fie, Wie = yie, Gie = die, SI = uie, Kie = gie, Yie = (e, t, n) => {
    const r = /* @__PURE__ */ new Map(), o = {
      platform: Bie,
      ...n
    }, i = {
      ...o.platform,
      _c: r
    };
    return cie(e, t, {
      ...o,
      platform: i
    });
  };
  var Xie = typeof document < "u", Zie = function() {
  }, Pv = Xie ? T.useLayoutEffect : Zie;
  function h0(e, t) {
    if (e === t)
      return !0;
    if (typeof e != typeof t)
      return !1;
    if (typeof e == "function" && e.toString() === t.toString())
      return !0;
    let n, r, o;
    if (e && t && typeof e == "object") {
      if (Array.isArray(e)) {
        if (n = e.length, n !== t.length) return !1;
        for (r = n; r-- !== 0; )
          if (!h0(e[r], t[r]))
            return !1;
        return !0;
      }
      if (o = Object.keys(e), n = o.length, n !== Object.keys(t).length)
        return !1;
      for (r = n; r-- !== 0; )
        if (!{}.hasOwnProperty.call(t, o[r]))
          return !1;
      for (r = n; r-- !== 0; ) {
        const i = o[r];
        if (!(i === "_owner" && e.$$typeof) && !h0(e[i], t[i]))
          return !1;
      }
      return !0;
    }
    return e !== e && t !== t;
  }
  function Dz(e) {
    return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
  }
  function _I(e, t) {
    const n = Dz(e);
    return Math.round(t * n) / n;
  }
  function $S(e) {
    const t = T.useRef(e);
    return Pv(() => {
      t.current = e;
    }), t;
  }
  function Qie(e) {
    e === void 0 && (e = {});
    const {
      placement: t = "bottom",
      strategy: n = "absolute",
      middleware: r = [],
      platform: o,
      elements: {
        reference: i,
        floating: a
      } = {},
      transform: s = !0,
      whileElementsMounted: c,
      open: u
    } = e, [d, p] = T.useState({
      x: 0,
      y: 0,
      strategy: n,
      placement: t,
      middlewareData: {},
      isPositioned: !1
    }), [m, g] = T.useState(r);
    h0(m, r) || g(r);
    const [y, b] = T.useState(null), [v, x] = T.useState(null), E = T.useCallback((W) => {
      W !== A.current && (A.current = W, b(W));
    }, []), _ = T.useCallback((W) => {
      W !== O.current && (O.current = W, x(W));
    }, []), C = i || y, k = a || v, A = T.useRef(null), O = T.useRef(null), P = T.useRef(d), I = c != null, $ = $S(c), L = $S(o), N = $S(u), U = T.useCallback(() => {
      if (!A.current || !O.current)
        return;
      const W = {
        placement: t,
        strategy: n,
        middleware: m
      };
      L.current && (W.platform = L.current), Yie(A.current, O.current, W).then((Y) => {
        const B = {
          ...Y,
          // The floating element's position may be recomputed while it's closed
          // but still mounted (such as when transitioning out). To ensure
          // `isPositioned` will be `false` initially on the next open, avoid
          // setting it to `true` when `open === false` (must be specified).
          isPositioned: N.current !== !1
        };
        j.current && !h0(P.current, B) && (P.current = B, _c.flushSync(() => {
          p(B);
        }));
      });
    }, [m, t, n, L, N]);
    Pv(() => {
      u === !1 && P.current.isPositioned && (P.current.isPositioned = !1, p((W) => ({
        ...W,
        isPositioned: !1
      })));
    }, [u]);
    const j = T.useRef(!1);
    Pv(() => (j.current = !0, () => {
      j.current = !1;
    }), []), Pv(() => {
      if (C && (A.current = C), k && (O.current = k), C && k) {
        if ($.current)
          return $.current(C, k, U);
        U();
      }
    }, [C, k, U, $, I]);
    const V = T.useMemo(() => ({
      reference: A,
      floating: O,
      setReference: E,
      setFloating: _
    }), [E, _]), F = T.useMemo(() => ({
      reference: C,
      floating: k
    }), [C, k]), K = T.useMemo(() => {
      const W = {
        position: n,
        left: 0,
        top: 0
      };
      if (!F.floating)
        return W;
      const Y = _I(F.floating, d.x), B = _I(F.floating, d.y);
      return s ? {
        ...W,
        transform: "translate(" + Y + "px, " + B + "px)",
        ...Dz(F.floating) >= 1.5 && {
          willChange: "transform"
        }
      } : {
        position: n,
        left: Y,
        top: B
      };
    }, [n, s, F.floating, d.x, d.y]);
    return T.useMemo(() => ({
      ...d,
      update: U,
      refs: V,
      elements: F,
      floatingStyles: K
    }), [d, U, V, F, K]);
  }
  const Jie = (e) => {
    function t(n) {
      return {}.hasOwnProperty.call(n, "current");
    }
    return {
      name: "arrow",
      options: e,
      fn(n) {
        const {
          element: r,
          padding: o
        } = typeof e == "function" ? e(n) : e;
        return r && t(r) ? r.current != null ? SI({
          element: r.current,
          padding: o
        }).fn(n) : {} : r ? SI({
          element: r,
          padding: o
        }).fn(n) : {};
      }
    };
  }, eae = (e, t) => ({
    ...Vie(e),
    options: [e, t]
  }), tae = (e, t) => ({
    ...Hie(e),
    options: [e, t]
  }), nae = (e, t) => ({
    ...Kie(e),
    options: [e, t]
  }), rae = (e, t) => ({
    ...qie(e),
    options: [e, t]
  }), oae = (e, t) => ({
    ...Wie(e),
    options: [e, t]
  }), iae = (e, t) => ({
    ...Gie(e),
    options: [e, t]
  }), aae = (e, t) => ({
    ...Jie(e),
    options: [e, t]
  });
  var sae = "Arrow", Fz = T.forwardRef((e, t) => {
    const { children: n, width: r = 10, height: o = 5, ...i } = e;
    return /* @__PURE__ */ S.jsx(
      xt.svg,
      {
        ...i,
        ref: t,
        width: r,
        height: o,
        viewBox: "0 0 30 10",
        preserveAspectRatio: "none",
        children: e.asChild ? n : /* @__PURE__ */ S.jsx("polygon", { points: "0,0 30,0 15,10" })
      }
    );
  });
  Fz.displayName = sae;
  var lae = Fz;
  function Lz(e) {
    const [t, n] = T.useState(void 0);
    return qa(() => {
      if (e) {
        n({ width: e.offsetWidth, height: e.offsetHeight });
        const r = new ResizeObserver((o) => {
          if (!Array.isArray(o) || !o.length)
            return;
          const i = o[0];
          let a, s;
          if ("borderBoxSize" in i) {
            const c = i.borderBoxSize, u = Array.isArray(c) ? c[0] : c;
            a = u.inlineSize, s = u.blockSize;
          } else
            a = e.offsetWidth, s = e.offsetHeight;
          n({ width: a, height: s });
        });
        return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
      } else
        n(void 0);
    }, [e]), t;
  }
  var iT = "Popper", [zz, jb] = Qi(iT), [cae, Bz] = zz(iT), Uz = (e) => {
    const { __scopePopper: t, children: n } = e, [r, o] = T.useState(null);
    return /* @__PURE__ */ S.jsx(cae, { scope: t, anchor: r, onAnchorChange: o, children: n });
  };
  Uz.displayName = iT;
  var Vz = "PopperAnchor", Hz = T.forwardRef(
    (e, t) => {
      const { __scopePopper: n, virtualRef: r, ...o } = e, i = Bz(Vz, n), a = T.useRef(null), s = un(t, a), c = T.useRef(null);
      return T.useEffect(() => {
        const u = c.current;
        c.current = r?.current || a.current, u !== c.current && i.onAnchorChange(c.current);
      }), r ? null : /* @__PURE__ */ S.jsx(xt.div, { ...o, ref: s });
    }
  );
  Hz.displayName = Vz;
  var aT = "PopperContent", [uae, fae] = zz(aT), qz = T.forwardRef(
    (e, t) => {
      const {
        __scopePopper: n,
        side: r = "bottom",
        sideOffset: o = 0,
        align: i = "center",
        alignOffset: a = 0,
        arrowPadding: s = 0,
        avoidCollisions: c = !0,
        collisionBoundary: u = [],
        collisionPadding: d = 0,
        sticky: p = "partial",
        hideWhenDetached: m = !1,
        updatePositionStrategy: g = "optimized",
        onPlaced: y,
        ...b
      } = e, v = Bz(aT, n), [x, E] = T.useState(null), _ = un(t, (ne) => E(ne)), [C, k] = T.useState(null), A = Lz(C), O = A?.width ?? 0, P = A?.height ?? 0, I = r + (i !== "center" ? "-" + i : ""), $ = typeof d == "number" ? d : { top: 0, right: 0, bottom: 0, left: 0, ...d }, L = Array.isArray(u) ? u : [u], N = L.length > 0, U = {
        padding: $,
        boundary: L.filter(pae),
        // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
        altBoundary: N
      }, { refs: j, floatingStyles: V, placement: F, isPositioned: K, middlewareData: W } = Qie({
        // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
        strategy: "fixed",
        placement: I,
        whileElementsMounted: (...ne) => jz(...ne, {
          animationFrame: g === "always"
        }),
        elements: {
          reference: v.anchor
        },
        middleware: [
          eae({ mainAxis: o + P, alignmentAxis: a }),
          c && tae({
            mainAxis: !0,
            crossAxis: !1,
            limiter: p === "partial" ? nae() : void 0,
            ...U
          }),
          c && rae({ ...U }),
          oae({
            ...U,
            apply: ({ elements: ne, rects: te, availableWidth: se, availableHeight: ue }) => {
              const { width: J, height: ee } = te.reference, ie = ne.floating.style;
              ie.setProperty("--radix-popper-available-width", `${se}px`), ie.setProperty("--radix-popper-available-height", `${ue}px`), ie.setProperty("--radix-popper-anchor-width", `${J}px`), ie.setProperty("--radix-popper-anchor-height", `${ee}px`);
            }
          }),
          C && aae({ element: C, padding: s }),
          hae({ arrowWidth: O, arrowHeight: P }),
          m && iae({ strategy: "referenceHidden", ...U })
        ]
      }), [Y, B] = Kz(F), D = qr(y);
      qa(() => {
        K && D?.();
      }, [K, D]);
      const G = W.arrow?.x, z = W.arrow?.y, H = W.arrow?.centerOffset !== 0, [X, Q] = T.useState();
      return qa(() => {
        x && Q(window.getComputedStyle(x).zIndex);
      }, [x]), /* @__PURE__ */ S.jsx(
        "div",
        {
          ref: j.setFloating,
          "data-radix-popper-content-wrapper": "",
          style: {
            ...V,
            transform: K ? V.transform : "translate(0, -200%)",
            // keep off the page when measuring
            minWidth: "max-content",
            zIndex: X,
            "--radix-popper-transform-origin": [
              W.transformOrigin?.x,
              W.transformOrigin?.y
            ].join(" "),
            // hide the content if using the hide middleware and should be hidden
            // set visibility to hidden and disable pointer events so the UI behaves
            // as if the PopperContent isn't there at all
            ...W.hide?.referenceHidden && {
              visibility: "hidden",
              pointerEvents: "none"
            }
          },
          dir: e.dir,
          children: /* @__PURE__ */ S.jsx(
            uae,
            {
              scope: n,
              placedSide: Y,
              onArrowChange: k,
              arrowX: G,
              arrowY: z,
              shouldHideArrow: H,
              children: /* @__PURE__ */ S.jsx(
                xt.div,
                {
                  "data-side": Y,
                  "data-align": B,
                  ...b,
                  ref: _,
                  style: {
                    ...b.style,
                    // if the PopperContent hasn't been placed yet (not all measurements done)
                    // we prevent animations so that users's animation don't kick in too early referring wrong sides
                    animation: K ? void 0 : "none"
                  }
                }
              )
            }
          )
        }
      );
    }
  );
  qz.displayName = aT;
  var Wz = "PopperArrow", dae = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
  }, Gz = T.forwardRef(function(t, n) {
    const { __scopePopper: r, ...o } = t, i = fae(Wz, r), a = dae[i.placedSide];
    return (
      // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
      // doesn't report size as we'd expect on SVG elements.
      // it reports their bounding box which is effectively the largest path inside the SVG.
      /* @__PURE__ */ S.jsx(
        "span",
        {
          ref: i.onArrowChange,
          style: {
            position: "absolute",
            left: i.arrowX,
            top: i.arrowY,
            [a]: 0,
            transformOrigin: {
              top: "",
              right: "0 0",
              bottom: "center 0",
              left: "100% 0"
            }[i.placedSide],
            transform: {
              top: "translateY(100%)",
              right: "translateY(50%) rotate(90deg) translateX(-50%)",
              bottom: "rotate(180deg)",
              left: "translateY(50%) rotate(-90deg) translateX(50%)"
            }[i.placedSide],
            visibility: i.shouldHideArrow ? "hidden" : void 0
          },
          children: /* @__PURE__ */ S.jsx(
            lae,
            {
              ...o,
              ref: n,
              style: {
                ...o.style,
                // ensures the element can be measured correctly (mostly for if SVG)
                display: "block"
              }
            }
          )
        }
      )
    );
  });
  Gz.displayName = Wz;
  function pae(e) {
    return e !== null;
  }
  var hae = (e) => ({
    name: "transformOrigin",
    options: e,
    fn(t) {
      const { placement: n, rects: r, middlewareData: o } = t, a = o.arrow?.centerOffset !== 0, s = a ? 0 : e.arrowWidth, c = a ? 0 : e.arrowHeight, [u, d] = Kz(n), p = { start: "0%", center: "50%", end: "100%" }[d], m = (o.arrow?.x ?? 0) + s / 2, g = (o.arrow?.y ?? 0) + c / 2;
      let y = "", b = "";
      return u === "bottom" ? (y = a ? p : `${m}px`, b = `${-c}px`) : u === "top" ? (y = a ? p : `${m}px`, b = `${r.floating.height + c}px`) : u === "right" ? (y = `${-c}px`, b = a ? p : `${g}px`) : u === "left" && (y = `${r.floating.width + c}px`, b = a ? p : `${g}px`), { data: { x: y, y: b } };
    }
  });
  function Kz(e) {
    const [t, n = "center"] = e.split("-");
    return [t, n];
  }
  var sT = Uz, lT = Hz, Yz = qz, Xz = Gz, Db = "Popover", [Zz] = Qi(Db, [
    jb
  ]), Wh = jb(), [mae, ml] = Zz(Db), Qz = (e) => {
    const {
      __scopePopover: t,
      children: n,
      open: r,
      defaultOpen: o,
      onOpenChange: i,
      modal: a = !1
    } = e, s = Wh(t), c = T.useRef(null), [u, d] = T.useState(!1), [p, m] = hl({
      prop: r,
      defaultProp: o ?? !1,
      onChange: i,
      caller: Db
    });
    return /* @__PURE__ */ S.jsx(sT, { ...s, children: /* @__PURE__ */ S.jsx(
      mae,
      {
        scope: t,
        contentId: Vi(),
        triggerRef: c,
        open: p,
        onOpenChange: m,
        onOpenToggle: T.useCallback(() => m((g) => !g), [m]),
        hasCustomAnchor: u,
        onCustomAnchorAdd: T.useCallback(() => d(!0), []),
        onCustomAnchorRemove: T.useCallback(() => d(!1), []),
        modal: a,
        children: n
      }
    ) });
  };
  Qz.displayName = Db;
  var Jz = "PopoverAnchor", gae = T.forwardRef(
    (e, t) => {
      const { __scopePopover: n, ...r } = e, o = ml(Jz, n), i = Wh(n), { onCustomAnchorAdd: a, onCustomAnchorRemove: s } = o;
      return T.useEffect(() => (a(), () => s()), [a, s]), /* @__PURE__ */ S.jsx(lT, { ...i, ...r, ref: t });
    }
  );
  gae.displayName = Jz;
  var e6 = "PopoverTrigger", t6 = T.forwardRef(
    (e, t) => {
      const { __scopePopover: n, ...r } = e, o = ml(e6, n), i = Wh(n), a = un(t, o.triggerRef), s = /* @__PURE__ */ S.jsx(
        xt.button,
        {
          type: "button",
          "aria-haspopup": "dialog",
          "aria-expanded": o.open,
          "aria-controls": o.contentId,
          "data-state": s6(o.open),
          ...r,
          ref: a,
          onClick: Le(e.onClick, o.onOpenToggle)
        }
      );
      return o.hasCustomAnchor ? s : /* @__PURE__ */ S.jsx(lT, { asChild: !0, ...i, children: s });
    }
  );
  t6.displayName = e6;
  var cT = "PopoverPortal", [yae, vae] = Zz(cT, {
    forceMount: void 0
  }), n6 = (e) => {
    const { __scopePopover: t, forceMount: n, children: r, container: o } = e, i = ml(cT, t);
    return /* @__PURE__ */ S.jsx(yae, { scope: t, forceMount: n, children: /* @__PURE__ */ S.jsx(ii, { present: n || i.open, children: /* @__PURE__ */ S.jsx(Sb, { asChild: !0, container: o, children: r }) }) });
  };
  n6.displayName = cT;
  var gf = "PopoverContent", r6 = T.forwardRef(
    (e, t) => {
      const n = vae(gf, e.__scopePopover), { forceMount: r = n.forceMount, ...o } = e, i = ml(gf, e.__scopePopover);
      return /* @__PURE__ */ S.jsx(ii, { present: r || i.open, children: i.modal ? /* @__PURE__ */ S.jsx(xae, { ...o, ref: t }) : /* @__PURE__ */ S.jsx(wae, { ...o, ref: t }) });
    }
  );
  r6.displayName = gf;
  var bae = /* @__PURE__ */ df("PopoverContent.RemoveScroll"), xae = T.forwardRef(
    (e, t) => {
      const n = ml(gf, e.__scopePopover), r = T.useRef(null), o = un(t, r), i = T.useRef(!1);
      return T.useEffect(() => {
        const a = r.current;
        if (a) return Ik(a);
      }, []), /* @__PURE__ */ S.jsx(Eb, { as: bae, allowPinchZoom: !0, children: /* @__PURE__ */ S.jsx(
        o6,
        {
          ...e,
          ref: o,
          trapFocus: n.open,
          disableOutsidePointerEvents: !0,
          onCloseAutoFocus: Le(e.onCloseAutoFocus, (a) => {
            a.preventDefault(), i.current || n.triggerRef.current?.focus();
          }),
          onPointerDownOutside: Le(
            e.onPointerDownOutside,
            (a) => {
              const s = a.detail.originalEvent, c = s.button === 0 && s.ctrlKey === !0, u = s.button === 2 || c;
              i.current = u;
            },
            { checkForDefaultPrevented: !1 }
          ),
          onFocusOutside: Le(
            e.onFocusOutside,
            (a) => a.preventDefault(),
            { checkForDefaultPrevented: !1 }
          )
        }
      ) });
    }
  ), wae = T.forwardRef(
    (e, t) => {
      const n = ml(gf, e.__scopePopover), r = T.useRef(!1), o = T.useRef(!1);
      return /* @__PURE__ */ S.jsx(
        o6,
        {
          ...e,
          ref: t,
          trapFocus: !1,
          disableOutsidePointerEvents: !1,
          onCloseAutoFocus: (i) => {
            e.onCloseAutoFocus?.(i), i.defaultPrevented || (r.current || n.triggerRef.current?.focus(), i.preventDefault()), r.current = !1, o.current = !1;
          },
          onInteractOutside: (i) => {
            e.onInteractOutside?.(i), i.defaultPrevented || (r.current = !0, i.detail.originalEvent.type === "pointerdown" && (o.current = !0));
            const a = i.target;
            n.triggerRef.current?.contains(a) && i.preventDefault(), i.detail.originalEvent.type === "focusin" && o.current && i.preventDefault();
          }
        }
      );
    }
  ), o6 = T.forwardRef(
    (e, t) => {
      const {
        __scopePopover: n,
        trapFocus: r,
        onOpenAutoFocus: o,
        onCloseAutoFocus: i,
        disableOutsidePointerEvents: a,
        onEscapeKeyDown: s,
        onPointerDownOutside: c,
        onFocusOutside: u,
        onInteractOutside: d,
        ...p
      } = e, m = ml(gf, n), g = Wh(n);
      return Pk(), /* @__PURE__ */ S.jsx(
        wb,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: o,
          onUnmountAutoFocus: i,
          children: /* @__PURE__ */ S.jsx(
            zh,
            {
              asChild: !0,
              disableOutsidePointerEvents: a,
              onInteractOutside: d,
              onEscapeKeyDown: s,
              onPointerDownOutside: c,
              onFocusOutside: u,
              onDismiss: () => m.onOpenChange(!1),
              children: /* @__PURE__ */ S.jsx(
                Yz,
                {
                  "data-state": s6(m.open),
                  role: "dialog",
                  id: m.contentId,
                  ...g,
                  ...p,
                  ref: t,
                  style: {
                    ...p.style,
                    "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                    "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                    "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                    "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                    "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                  }
                }
              )
            }
          )
        }
      );
    }
  ), i6 = "PopoverClose", Sae = T.forwardRef(
    (e, t) => {
      const { __scopePopover: n, ...r } = e, o = ml(i6, n);
      return /* @__PURE__ */ S.jsx(
        xt.button,
        {
          type: "button",
          ...r,
          ref: t,
          onClick: Le(e.onClick, () => o.onOpenChange(!1))
        }
      );
    }
  );
  Sae.displayName = i6;
  var _ae = "PopoverArrow", a6 = T.forwardRef(
    (e, t) => {
      const { __scopePopover: n, ...r } = e, o = Wh(n);
      return /* @__PURE__ */ S.jsx(Xz, { ...o, ...r, ref: t });
    }
  );
  a6.displayName = _ae;
  function s6(e) {
    return e ? "open" : "closed";
  }
  var l6 = Qz, c6 = t6, u6 = n6, f6 = r6, Eae = a6;
  const nh = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  }, d6 = {};
  for (const e of Object.keys(nh))
    d6[nh[e]] = e;
  const Pe = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    oklab: { channels: 3, labels: ["okl", "oka", "okb"] },
    lch: { channels: 3, labels: "lch" },
    oklch: { channels: 3, labels: ["okl", "okc", "okh"] },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  }, La = (6 / 29) ** 3;
  function rf(e) {
    const t = e > 31308e-7 ? 1.055 * e ** 0.4166666666666667 - 0.055 : e * 12.92;
    return Math.min(Math.max(0, t), 1);
  }
  function of(e) {
    return e > 0.04045 ? ((e + 0.055) / 1.055) ** 2.4 : e / 12.92;
  }
  for (const e of Object.keys(Pe)) {
    if (!("channels" in Pe[e]))
      throw new Error("missing channels property: " + e);
    if (!("labels" in Pe[e]))
      throw new Error("missing channel labels property: " + e);
    if (Pe[e].labels.length !== Pe[e].channels)
      throw new Error("channel and label counts mismatch: " + e);
    const { channels: t, labels: n } = Pe[e];
    delete Pe[e].channels, delete Pe[e].labels, Object.defineProperty(Pe[e], "channels", { value: t }), Object.defineProperty(Pe[e], "labels", { value: n });
  }
  Pe.rgb.hsl = function(e) {
    const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.min(t, n, r), i = Math.max(t, n, r), a = i - o;
    let s, c;
    switch (i) {
      case o: {
        s = 0;
        break;
      }
      case t: {
        s = (n - r) / a;
        break;
      }
      case n: {
        s = 2 + (r - t) / a;
        break;
      }
      case r: {
        s = 4 + (t - n) / a;
        break;
      }
    }
    s = Math.min(s * 60, 360), s < 0 && (s += 360);
    const u = (o + i) / 2;
    return i === o ? c = 0 : u <= 0.5 ? c = a / (i + o) : c = a / (2 - i - o), [s, c * 100, u * 100];
  };
  Pe.rgb.hsv = function(e) {
    let t, n, r, o, i;
    const a = e[0] / 255, s = e[1] / 255, c = e[2] / 255, u = Math.max(a, s, c), d = u - Math.min(a, s, c), p = function(m) {
      return (u - m) / 6 / d + 1 / 2;
    };
    if (d === 0)
      o = 0, i = 0;
    else {
      switch (i = d / u, t = p(a), n = p(s), r = p(c), u) {
        case a: {
          o = r - n;
          break;
        }
        case s: {
          o = 1 / 3 + t - r;
          break;
        }
        case c: {
          o = 2 / 3 + n - t;
          break;
        }
      }
      o < 0 ? o += 1 : o > 1 && (o -= 1);
    }
    return [
      o * 360,
      i * 100,
      u * 100
    ];
  };
  Pe.rgb.hwb = function(e) {
    const t = e[0], n = e[1];
    let r = e[2];
    const o = Pe.rgb.hsl(e)[0], i = 1 / 255 * Math.min(t, Math.min(n, r));
    return r = 1 - 1 / 255 * Math.max(t, Math.max(n, r)), [o, i * 100, r * 100];
  };
  Pe.rgb.oklab = function(e) {
    const t = of(e[0] / 255), n = of(e[1] / 255), r = of(e[2] / 255), o = Math.cbrt(0.4122214708 * t + 0.5363325363 * n + 0.0514459929 * r), i = Math.cbrt(0.2119034982 * t + 0.6806995451 * n + 0.1073969566 * r), a = Math.cbrt(0.0883024619 * t + 0.2817188376 * n + 0.6299787005 * r), s = 0.2104542553 * o + 0.793617785 * i - 0.0040720468 * a, c = 1.9779984951 * o - 2.428592205 * i + 0.4505937099 * a, u = 0.0259040371 * o + 0.7827717662 * i - 0.808675766 * a;
    return [s * 100, c * 100, u * 100];
  };
  Pe.rgb.cmyk = function(e) {
    const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.min(1 - t, 1 - n, 1 - r), i = (1 - t - o) / (1 - o) || 0, a = (1 - n - o) / (1 - o) || 0, s = (1 - r - o) / (1 - o) || 0;
    return [i * 100, a * 100, s * 100, o * 100];
  };
  function Cae(e, t) {
    return (e[0] - t[0]) ** 2 + (e[1] - t[1]) ** 2 + (e[2] - t[2]) ** 2;
  }
  Pe.rgb.keyword = function(e) {
    const t = d6[e];
    if (t)
      return t;
    let n = Number.POSITIVE_INFINITY, r;
    for (const o of Object.keys(nh)) {
      const i = nh[o], a = Cae(e, i);
      a < n && (n = a, r = o);
    }
    return r;
  };
  Pe.keyword.rgb = function(e) {
    return [...nh[e]];
  };
  Pe.rgb.xyz = function(e) {
    const t = of(e[0] / 255), n = of(e[1] / 255), r = of(e[2] / 255), o = t * 0.4124564 + n * 0.3575761 + r * 0.1804375, i = t * 0.2126729 + n * 0.7151522 + r * 0.072175, a = t * 0.0193339 + n * 0.119192 + r * 0.9503041;
    return [o * 100, i * 100, a * 100];
  };
  Pe.rgb.lab = function(e) {
    const t = Pe.rgb.xyz(e);
    let n = t[0], r = t[1], o = t[2];
    n /= 95.047, r /= 100, o /= 108.883, n = n > La ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > La ? r ** (1 / 3) : 7.787 * r + 16 / 116, o = o > La ? o ** (1 / 3) : 7.787 * o + 16 / 116;
    const i = 116 * r - 16, a = 500 * (n - r), s = 200 * (r - o);
    return [i, a, s];
  };
  Pe.hsl.rgb = function(e) {
    const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
    let o, i;
    if (n === 0)
      return i = r * 255, [i, i, i];
    const a = r < 0.5 ? r * (1 + n) : r + n - r * n, s = 2 * r - a, c = [0, 0, 0];
    for (let u = 0; u < 3; u++)
      o = t + 1 / 3 * -(u - 1), o < 0 && o++, o > 1 && o--, 6 * o < 1 ? i = s + (a - s) * 6 * o : 2 * o < 1 ? i = a : 3 * o < 2 ? i = s + (a - s) * (2 / 3 - o) * 6 : i = s, c[u] = i * 255;
    return c;
  };
  Pe.hsl.hsv = function(e) {
    const t = e[0];
    let n = e[1] / 100, r = e[2] / 100, o = n;
    const i = Math.max(r, 0.01);
    r *= 2, n *= r <= 1 ? r : 2 - r, o *= i <= 1 ? i : 2 - i;
    const a = (r + n) / 2, s = r === 0 ? 2 * o / (i + o) : 2 * n / (r + n);
    return [t, s * 100, a * 100];
  };
  Pe.hsv.rgb = function(e) {
    const t = e[0] / 60, n = e[1] / 100;
    let r = e[2] / 100;
    const o = Math.floor(t) % 6, i = t - Math.floor(t), a = 255 * r * (1 - n), s = 255 * r * (1 - n * i), c = 255 * r * (1 - n * (1 - i));
    switch (r *= 255, o) {
      case 0:
        return [r, c, a];
      case 1:
        return [s, r, a];
      case 2:
        return [a, r, c];
      case 3:
        return [a, s, r];
      case 4:
        return [c, a, r];
      case 5:
        return [r, a, s];
    }
  };
  Pe.hsv.hsl = function(e) {
    const t = e[0], n = e[1] / 100, r = e[2] / 100, o = Math.max(r, 0.01);
    let i, a;
    a = (2 - n) * r;
    const s = (2 - n) * o;
    return i = n * o, i /= s <= 1 ? s : 2 - s, i = i || 0, a /= 2, [t, i * 100, a * 100];
  };
  Pe.hwb.rgb = function(e) {
    const t = e[0] / 360;
    let n = e[1] / 100, r = e[2] / 100;
    const o = n + r;
    let i;
    o > 1 && (n /= o, r /= o);
    const a = Math.floor(6 * t), s = 1 - r;
    i = 6 * t - a, (a & 1) !== 0 && (i = 1 - i);
    const c = n + i * (s - n);
    let u, d, p;
    switch (a) {
      default:
      case 6:
      case 0: {
        u = s, d = c, p = n;
        break;
      }
      case 1: {
        u = c, d = s, p = n;
        break;
      }
      case 2: {
        u = n, d = s, p = c;
        break;
      }
      case 3: {
        u = n, d = c, p = s;
        break;
      }
      case 4: {
        u = c, d = n, p = s;
        break;
      }
      case 5: {
        u = s, d = n, p = c;
        break;
      }
    }
    return [u * 255, d * 255, p * 255];
  };
  Pe.cmyk.rgb = function(e) {
    const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = e[3] / 100, i = 1 - Math.min(1, t * (1 - o) + o), a = 1 - Math.min(1, n * (1 - o) + o), s = 1 - Math.min(1, r * (1 - o) + o);
    return [i * 255, a * 255, s * 255];
  };
  Pe.xyz.rgb = function(e) {
    const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100;
    let o, i, a;
    return o = t * 3.2404542 + n * -1.5371385 + r * -0.4985314, i = t * -0.969266 + n * 1.8760108 + r * 0.041556, a = t * 0.0556434 + n * -0.2040259 + r * 1.0572252, o = rf(o), i = rf(i), a = rf(a), [o * 255, i * 255, a * 255];
  };
  Pe.xyz.lab = function(e) {
    let t = e[0], n = e[1], r = e[2];
    t /= 95.047, n /= 100, r /= 108.883, t = t > La ? t ** (1 / 3) : 7.787 * t + 16 / 116, n = n > La ? n ** (1 / 3) : 7.787 * n + 16 / 116, r = r > La ? r ** (1 / 3) : 7.787 * r + 16 / 116;
    const o = 116 * n - 16, i = 500 * (t - n), a = 200 * (n - r);
    return [o, i, a];
  };
  Pe.xyz.oklab = function(e) {
    const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = Math.cbrt(0.8189330101 * t + 0.3618667424 * n - 0.1288597137 * r), i = Math.cbrt(0.0329845436 * t + 0.9293118715 * n + 0.0361456387 * r), a = Math.cbrt(0.0482003018 * t + 0.2643662691 * n + 0.633851707 * r), s = 0.2104542553 * o + 0.793617785 * i - 0.0040720468 * a, c = 1.9779984951 * o - 2.428592205 * i + 0.4505937099 * a, u = 0.0259040371 * o + 0.7827717662 * i - 0.808675766 * a;
    return [s * 100, c * 100, u * 100];
  };
  Pe.oklab.oklch = function(e) {
    return Pe.lab.lch(e);
  };
  Pe.oklab.xyz = function(e) {
    const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = (0.999999998 * t + 0.396337792 * n + 0.215803758 * r) ** 3, i = (1.000000008 * t - 0.105561342 * n - 0.063854175 * r) ** 3, a = (1.000000055 * t - 0.089484182 * n - 1.291485538 * r) ** 3, s = 1.227013851 * o - 0.55779998 * i + 0.281256149 * a, c = -0.040580178 * o + 1.11225687 * i - 0.071676679 * a, u = -0.076381285 * o - 0.421481978 * i + 1.58616322 * a;
    return [s * 100, c * 100, u * 100];
  };
  Pe.oklab.rgb = function(e) {
    const t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, o = (t + 0.3963377774 * n + 0.2158037573 * r) ** 3, i = (t - 0.1055613458 * n - 0.0638541728 * r) ** 3, a = (t - 0.0894841775 * n - 1.291485548 * r) ** 3, s = rf(4.0767416621 * o - 3.3077115913 * i + 0.2309699292 * a), c = rf(-1.2684380046 * o + 2.6097574011 * i - 0.3413193965 * a), u = rf(-0.0041960863 * o - 0.7034186147 * i + 1.707614701 * a);
    return [s * 255, c * 255, u * 255];
  };
  Pe.oklch.oklab = function(e) {
    return Pe.lch.lab(e);
  };
  Pe.lab.xyz = function(e) {
    const t = e[0], n = e[1], r = e[2];
    let o, i, a;
    i = (t + 16) / 116, o = n / 500 + i, a = i - r / 200;
    const s = i ** 3, c = o ** 3, u = a ** 3;
    return i = s > La ? s : (i - 16 / 116) / 7.787, o = c > La ? c : (o - 16 / 116) / 7.787, a = u > La ? u : (a - 16 / 116) / 7.787, o *= 95.047, i *= 100, a *= 108.883, [o, i, a];
  };
  Pe.lab.lch = function(e) {
    const t = e[0], n = e[1], r = e[2];
    let o;
    o = Math.atan2(r, n) * 360 / 2 / Math.PI, o < 0 && (o += 360);
    const a = Math.sqrt(n * n + r * r);
    return [t, a, o];
  };
  Pe.lch.lab = function(e) {
    const t = e[0], n = e[1], o = e[2] / 360 * 2 * Math.PI, i = n * Math.cos(o), a = n * Math.sin(o);
    return [t, i, a];
  };
  Pe.rgb.ansi16 = function(e, t = null) {
    const [n, r, o] = e;
    let i = t === null ? Pe.rgb.hsv(e)[2] : t;
    if (i = Math.round(i / 50), i === 0)
      return 30;
    let a = 30 + (Math.round(o / 255) << 2 | Math.round(r / 255) << 1 | Math.round(n / 255));
    return i === 2 && (a += 60), a;
  };
  Pe.hsv.ansi16 = function(e) {
    return Pe.rgb.ansi16(Pe.hsv.rgb(e), e[2]);
  };
  Pe.rgb.ansi256 = function(e) {
    const t = e[0], n = e[1], r = e[2];
    return t >> 4 === n >> 4 && n >> 4 === r >> 4 ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(r / 255 * 5);
  };
  Pe.ansi16.rgb = function(e) {
    e = e[0];
    let t = e % 10;
    if (t === 0 || t === 7)
      return e > 50 && (t += 3.5), t = t / 10.5 * 255, [t, t, t];
    const n = (Math.trunc(e > 50) + 1) * 0.5, r = (t & 1) * n * 255, o = (t >> 1 & 1) * n * 255, i = (t >> 2 & 1) * n * 255;
    return [r, o, i];
  };
  Pe.ansi256.rgb = function(e) {
    if (e = e[0], e >= 232) {
      const i = (e - 232) * 10 + 8;
      return [i, i, i];
    }
    e -= 16;
    let t;
    const n = Math.floor(e / 36) / 5 * 255, r = Math.floor((t = e % 36) / 6) / 5 * 255, o = t % 6 / 5 * 255;
    return [n, r, o];
  };
  Pe.rgb.hex = function(e) {
    const n = (((Math.round(e[0]) & 255) << 16) + ((Math.round(e[1]) & 255) << 8) + (Math.round(e[2]) & 255)).toString(16).toUpperCase();
    return "000000".slice(n.length) + n;
  };
  Pe.hex.rgb = function(e) {
    const t = e.toString(16).match(/[a-f\d]{6}|[a-f\d]{3}/i);
    if (!t)
      return [0, 0, 0];
    let n = t[0];
    t[0].length === 3 && (n = [...n].map((s) => s + s).join(""));
    const r = Number.parseInt(n, 16), o = r >> 16 & 255, i = r >> 8 & 255, a = r & 255;
    return [o, i, a];
  };
  Pe.rgb.hcg = function(e) {
    const t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, o = Math.max(Math.max(t, n), r), i = Math.min(Math.min(t, n), r), a = o - i;
    let s;
    const c = a < 1 ? i / (1 - a) : 0;
    return a <= 0 ? s = 0 : o === t ? s = (n - r) / a % 6 : o === n ? s = 2 + (r - t) / a : s = 4 + (t - n) / a, s /= 6, s %= 1, [s * 360, a * 100, c * 100];
  };
  Pe.hsl.hcg = function(e) {
    const t = e[1] / 100, n = e[2] / 100, r = n < 0.5 ? 2 * t * n : 2 * t * (1 - n);
    let o = 0;
    return r < 1 && (o = (n - 0.5 * r) / (1 - r)), [e[0], r * 100, o * 100];
  };
  Pe.hsv.hcg = function(e) {
    const t = e[1] / 100, n = e[2] / 100, r = t * n;
    let o = 0;
    return r < 1 && (o = (n - r) / (1 - r)), [e[0], r * 100, o * 100];
  };
  Pe.hcg.rgb = function(e) {
    const t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
    if (n === 0)
      return [r * 255, r * 255, r * 255];
    const o = [0, 0, 0], i = t % 1 * 6, a = i % 1, s = 1 - a;
    let c = 0;
    switch (Math.floor(i)) {
      case 0: {
        o[0] = 1, o[1] = a, o[2] = 0;
        break;
      }
      case 1: {
        o[0] = s, o[1] = 1, o[2] = 0;
        break;
      }
      case 2: {
        o[0] = 0, o[1] = 1, o[2] = a;
        break;
      }
      case 3: {
        o[0] = 0, o[1] = s, o[2] = 1;
        break;
      }
      case 4: {
        o[0] = a, o[1] = 0, o[2] = 1;
        break;
      }
      default:
        o[0] = 1, o[1] = 0, o[2] = s;
    }
    return c = (1 - n) * r, [
      (n * o[0] + c) * 255,
      (n * o[1] + c) * 255,
      (n * o[2] + c) * 255
    ];
  };
  Pe.hcg.hsv = function(e) {
    const t = e[1] / 100, n = e[2] / 100, r = t + n * (1 - t);
    let o = 0;
    return r > 0 && (o = t / r), [e[0], o * 100, r * 100];
  };
  Pe.hcg.hsl = function(e) {
    const t = e[1] / 100, r = e[2] / 100 * (1 - t) + 0.5 * t;
    let o = 0;
    return r > 0 && r < 0.5 ? o = t / (2 * r) : r >= 0.5 && r < 1 && (o = t / (2 * (1 - r))), [e[0], o * 100, r * 100];
  };
  Pe.hcg.hwb = function(e) {
    const t = e[1] / 100, n = e[2] / 100, r = t + n * (1 - t);
    return [e[0], (r - t) * 100, (1 - r) * 100];
  };
  Pe.hwb.hcg = function(e) {
    const t = e[1] / 100, r = 1 - e[2] / 100, o = r - t;
    let i = 0;
    return o < 1 && (i = (r - o) / (1 - o)), [e[0], o * 100, i * 100];
  };
  Pe.apple.rgb = function(e) {
    return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255];
  };
  Pe.rgb.apple = function(e) {
    return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535];
  };
  Pe.gray.rgb = function(e) {
    return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255];
  };
  Pe.gray.hsl = function(e) {
    return [0, 0, e[0]];
  };
  Pe.gray.hsv = Pe.gray.hsl;
  Pe.gray.hwb = function(e) {
    return [0, 100, e[0]];
  };
  Pe.gray.cmyk = function(e) {
    return [0, 0, 0, e[0]];
  };
  Pe.gray.lab = function(e) {
    return [e[0], 0, 0];
  };
  Pe.gray.hex = function(e) {
    const t = Math.round(e[0] / 100 * 255) & 255, r = ((t << 16) + (t << 8) + t).toString(16).toUpperCase();
    return "000000".slice(r.length) + r;
  };
  Pe.rgb.gray = function(e) {
    return [(e[0] + e[1] + e[2]) / 3 / 255 * 100];
  };
  function kae() {
    const e = {}, t = Object.keys(Pe);
    for (let { length: n } = t, r = 0; r < n; r++)
      e[t[r]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return e;
  }
  function Tae(e) {
    const t = kae(), n = [e];
    for (t[e].distance = 0; n.length > 0; ) {
      const r = n.pop(), o = Object.keys(Pe[r]);
      for (let { length: i } = o, a = 0; a < i; a++) {
        const s = o[a], c = t[s];
        c.distance === -1 && (c.distance = t[r].distance + 1, c.parent = r, n.unshift(s));
      }
    }
    return t;
  }
  function Aae(e, t) {
    return function(n) {
      return t(e(n));
    };
  }
  function Rae(e, t) {
    const n = [t[e].parent, e];
    let r = Pe[t[e].parent][e], o = t[e].parent;
    for (; t[o].parent; )
      n.unshift(t[o].parent), r = Aae(Pe[t[o].parent][o], r), o = t[o].parent;
    return r.conversion = n, r;
  }
  function Oae(e) {
    const t = Tae(e), n = {}, r = Object.keys(t);
    for (let { length: o } = r, i = 0; i < o; i++) {
      const a = r[i];
      t[a].parent !== null && (n[a] = Rae(a, t));
    }
    return n;
  }
  const Ql = {}, Mae = Object.keys(Pe);
  function Nae(e) {
    const t = function(...n) {
      const r = n[0];
      return r == null ? r : (r.length > 1 && (n = r), e(n));
    };
    return "conversion" in e && (t.conversion = e.conversion), t;
  }
  function Pae(e) {
    const t = function(...n) {
      const r = n[0];
      if (r == null)
        return r;
      r.length > 1 && (n = r);
      const o = e(n);
      if (typeof o == "object")
        for (let { length: i } = o, a = 0; a < i; a++)
          o[a] = Math.round(o[a]);
      return o;
    };
    return "conversion" in e && (t.conversion = e.conversion), t;
  }
  for (const e of Mae) {
    Ql[e] = {}, Object.defineProperty(Ql[e], "channels", { value: Pe[e].channels }), Object.defineProperty(Ql[e], "labels", { value: Pe[e].labels });
    const t = Oae(e), n = Object.keys(t);
    for (const r of n) {
      const o = t[r];
      Ql[e][r] = Pae(o), Ql[e][r].raw = Nae(o);
    }
  }
  const Iae = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: Ql
  }, Symbol.toStringTag, { value: "Module" })), gr = (e, t) => {
    const n = Array.isArray(t) ? t : [t];
    if (n[0] === void 0 || n[0] === null)
      return gr("rgb", [0, 0, 0]);
    const r = Ql[e];
    if (!r)
      throw new Error(
        `Unsupported color type: ${e} allowed are ${Object.keys(Iae).join(
          ", "
        )}`
      );
    r[e] = () => n;
    const o = (a) => {
      const s = a(...n);
      return Array.isArray(s) ? s[0] != null : s;
    };
    if (!o(r.rgb) || !o(r.hsl))
      return gr("rgb", [0, 0, 0]);
    const i = {};
    return Object.keys(r).forEach((a) => {
      const s = r[a];
      typeof s == "function" && (i[a] = () => a === e ? n : s(...n));
    }), i;
  }, $ae = ({
    onChange: e,
    colorconverter: t,
    allow_null: n = !1
  }) => {
    if (t === null && !n)
      throw new Error("Color converter is null");
    const [r, o] = T.useState(t), [i, a] = T.useState([0, 0, 0]), [s, c] = T.useState([0, 0, 0]), [u, d] = T.useState([0, 0, 0]), [p, m] = T.useState("000");
    T.useEffect(() => {
      if (!r) {
        if (!n) throw new Error("Color converter is null");
        c([0, 0, 0]), a([0, 0, 0]), d([0, 0, 0]), m("");
        return;
      }
      a(r.hsl()), c(r.rgb()), d(r.hsv()), m(r.hex());
    }, [r]);
    const g = {
      backgroundColor: `hsl(${i[0]}, ${i[1]}%, ${i[2]}%)`,
      padding: "10px",
      margin: "10px 0"
    };
    return /* @__PURE__ */ S.jsxs("div", { style: { backgroundColor: "white" }, children: [
      /* @__PURE__ */ S.jsx("div", { style: g, children: "Color Preview" }),
      /* @__PURE__ */ S.jsxs("div", { className: "colorspace", children: [
        /* @__PURE__ */ S.jsx("div", { className: "colorspace_title", children: "RGB" }),
        /* @__PURE__ */ S.jsx("div", {}),
        /* @__PURE__ */ S.jsx("label", { children: "Red" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "255",
            value: s[0],
            onChange: (y) => {
              const b = [parseInt(y.target.value), s[1], s[2]], v = gr("rgb", b);
              o(v), e(v);
            },
            style: { background: "linear-gradient(to right, #000, #f00)" }
          }
        ),
        /* @__PURE__ */ S.jsx("label", { children: "Green" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "255",
            value: s[1],
            onChange: (y) => {
              const b = [s[0], parseInt(y.target.value), s[2]], v = gr("rgb", b);
              o(v), e(v);
            },
            style: { background: "linear-gradient(to right, #000, #0f0)" }
          }
        ),
        /* @__PURE__ */ S.jsx("label", { children: "Blue" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "255",
            value: s[2],
            onChange: (y) => {
              const b = [s[0], s[1], parseInt(y.target.value)], v = gr("rgb", b);
              o(v), e(v);
            },
            style: { background: "linear-gradient(to right, #000, #00f)" }
          }
        )
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "colorspace", children: [
        /* @__PURE__ */ S.jsx("div", { className: "colorspace_title", children: "HSL" }),
        /* @__PURE__ */ S.jsx("div", {}),
        /* @__PURE__ */ S.jsx("label", { children: "Hue" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "360",
            value: i[0],
            onChange: (y) => {
              const b = [parseInt(y.target.value), i[1], i[2]], v = gr("hsl", b);
              o(v), e(v);
            },
            style: {
              background: "linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)"
            }
          }
        ),
        /* @__PURE__ */ S.jsx("label", { children: "Saturation" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "100",
            value: i[1],
            onChange: (y) => {
              const b = [i[0], parseInt(y.target.value), i[2]], v = gr("hsl", b);
              o(v), e(v);
            },
            style: {
              background: `linear-gradient(to right, #fff, hsl(${i[0]}, 100%, 50%))`
            }
          }
        ),
        /* @__PURE__ */ S.jsx("label", { children: "Lightness" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "100",
            value: i[2],
            onChange: (y) => {
              const b = [i[0], i[1], parseInt(y.target.value)], v = gr("hsl", b);
              o(v), e(v);
            },
            style: {
              background: `linear-gradient(to right, #000, hsl(${i[0]}, 100%, 50%), #fff)`
            }
          }
        )
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "colorspace", children: [
        /* @__PURE__ */ S.jsx("div", { className: "colorspace_title", children: "HSV" }),
        /* @__PURE__ */ S.jsx("div", {}),
        /* @__PURE__ */ S.jsx("label", { children: "Hue" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "360",
            value: u[0],
            onChange: (y) => {
              const b = [parseInt(y.target.value), u[1], u[2]], v = gr("hsv", b);
              o(v), e(v);
            },
            style: {
              background: "linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)"
            }
          }
        ),
        /* @__PURE__ */ S.jsx("label", { children: "Saturation" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "100",
            value: u[1],
            onChange: (y) => {
              const b = [u[0], parseInt(y.target.value), u[2]], v = gr("hsv", b);
              o(v), e(v);
            },
            style: {
              background: `linear-gradient(to right, #fff, hsl(${i[0]}, 100%, 50%))`
            }
          }
        ),
        /* @__PURE__ */ S.jsx("label", { children: "Value" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "range",
            min: "0",
            max: "100",
            value: u[2],
            onChange: (y) => {
              const b = [u[0], u[1], parseInt(y.target.value)], v = gr("hsv", b);
              o(v), e(v);
            },
            style: {
              background: `linear-gradient(to right, #000, hsl(${i[0]}, 100%, 50%))`
            }
          }
        )
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "colorspace", children: [
        /* @__PURE__ */ S.jsx("div", { className: "colorspace_title", children: "HEX" }),
        /* @__PURE__ */ S.jsx("div", {}),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "text",
            value: p,
            onChange: (y) => {
              const b = y.target.value === "" ? null : gr("hex", [y.target.value]);
              o(b), e(b);
            }
          }
        )
      ] })
    ] });
  }, jae = ({
    inicolordata: e,
    inicolorspace: t,
    allow_null: n = !1,
    delay: r = 1e3,
    onChange: o,
    portalContainer: i
  }) => {
    const a = e !== void 0 ? e : [0, 0, 0], s = e === void 0 ? "rgb" : t || "hex", c = Array.isArray(a) ? a : [a], u = T.useMemo(() => {
      let b = gr(s, c);
      return b.rgb() === void 0 && (b = gr("rgb", [0, 0, 0])), b;
    }, [s, c]), [d, p] = T.useState(u);
    T.useEffect(() => {
      const b = e !== void 0 ? e : [0, 0, 0], v = e === void 0 ? "rgb" : t || "hex", x = Array.isArray(b) ? b : [b];
      let E = gr(v, x);
      E.rgb() === void 0 && (E = gr("rgb", [0, 0, 0])), p(E);
    }, [JSON.stringify(e), t]);
    const m = T.useRef(null), g = T.useCallback(
      (b) => {
        if (b === null && !n)
          throw new Error("Color is null");
        b !== null && p(b), m.current && clearTimeout(m.current), o && (m.current = setTimeout(() => {
          o(b), m.current = null;
        }, r));
      },
      [n, o, r]
    );
    T.useEffect(() => () => {
      m.current && clearTimeout(m.current);
    }, []);
    const y = T.useMemo(
      () => ({
        background: "#" + d.hex(),
        borderRadius: "0.3rem",
        width: "2rem",
        height: "1rem"
      }),
      [d]
    );
    return /* @__PURE__ */ S.jsxs(l6, { children: [
      /* @__PURE__ */ S.jsx(c6, { asChild: !0, children: /* @__PURE__ */ S.jsx("button", { style: y }) }),
      /* @__PURE__ */ S.jsx(u6, { container: i, children: /* @__PURE__ */ S.jsx(f6, { side: "left", className: "iotooltipcontent", children: /* @__PURE__ */ S.jsx(
        $ae,
        {
          onChange: g,
          colorconverter: d,
          allow_null: n
        }
      ) }) })
    ] });
  };
  function dc(e) {
    "@babel/helpers - typeof";
    return dc = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
      return typeof t;
    } : function(t) {
      return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
    }, dc(e);
  }
  function Dae(e, t) {
    if (dc(e) != "object" || !e) return e;
    var n = e[Symbol.toPrimitive];
    if (n !== void 0) {
      var r = n.call(e, t);
      if (dc(r) != "object") return r;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (t === "string" ? String : Number)(e);
  }
  function p6(e) {
    var t = Dae(e, "string");
    return dc(t) == "symbol" ? t : t + "";
  }
  function yp(e, t, n) {
    return (t = p6(t)) in e ? Object.defineProperty(e, t, {
      value: n,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[t] = n, e;
  }
  function EI(e, t) {
    var n = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var r = Object.getOwnPropertySymbols(e);
      t && (r = r.filter(function(o) {
        return Object.getOwnPropertyDescriptor(e, o).enumerable;
      })), n.push.apply(n, r);
    }
    return n;
  }
  function Xe(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t] != null ? arguments[t] : {};
      t % 2 ? EI(Object(n), !0).forEach(function(r) {
        yp(e, r, n[r]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : EI(Object(n)).forEach(function(r) {
        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
      });
    }
    return e;
  }
  function Fae(e) {
    if (Array.isArray(e)) return e;
  }
  function Lae(e, t) {
    var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (n != null) {
      var r, o, i, a, s = [], c = !0, u = !1;
      try {
        if (i = (n = n.call(e)).next, t === 0) {
          if (Object(n) !== n) return;
          c = !1;
        } else for (; !(c = (r = i.call(n)).done) && (s.push(r.value), s.length !== t); c = !0) ;
      } catch (d) {
        u = !0, o = d;
      } finally {
        try {
          if (!c && n.return != null && (a = n.return(), Object(a) !== a)) return;
        } finally {
          if (u) throw o;
        }
      }
      return s;
    }
  }
  function GE(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
    return r;
  }
  function h6(e, t) {
    if (e) {
      if (typeof e == "string") return GE(e, t);
      var n = {}.toString.call(e).slice(8, -1);
      return n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set" ? Array.from(e) : n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? GE(e, t) : void 0;
    }
  }
  function zae() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function za(e, t) {
    return Fae(e) || Lae(e, t) || h6(e, t) || zae();
  }
  function es(e, t) {
    if (e == null) return {};
    var n, r, o = bb(e, t);
    if (Object.getOwnPropertySymbols) {
      var i = Object.getOwnPropertySymbols(e);
      for (r = 0; r < i.length; r++) n = i[r], t.indexOf(n) === -1 && {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
    }
    return o;
  }
  var Bae = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
  function Uae(e) {
    var t = e.defaultInputValue, n = t === void 0 ? "" : t, r = e.defaultMenuIsOpen, o = r === void 0 ? !1 : r, i = e.defaultValue, a = i === void 0 ? null : i, s = e.inputValue, c = e.menuIsOpen, u = e.onChange, d = e.onInputChange, p = e.onMenuClose, m = e.onMenuOpen, g = e.value, y = es(e, Bae), b = T.useState(s !== void 0 ? s : n), v = za(b, 2), x = v[0], E = v[1], _ = T.useState(c !== void 0 ? c : o), C = za(_, 2), k = C[0], A = C[1], O = T.useState(g !== void 0 ? g : a), P = za(O, 2), I = P[0], $ = P[1], L = T.useCallback(function(W, Y) {
      typeof u == "function" && u(W, Y), $(W);
    }, [u]), N = T.useCallback(function(W, Y) {
      var B;
      typeof d == "function" && (B = d(W, Y)), E(B !== void 0 ? B : W);
    }, [d]), U = T.useCallback(function() {
      typeof m == "function" && m(), A(!0);
    }, [m]), j = T.useCallback(function() {
      typeof p == "function" && p(), A(!1);
    }, [p]), V = s !== void 0 ? s : x, F = c !== void 0 ? c : k, K = g !== void 0 ? g : I;
    return Xe(Xe({}, y), {}, {
      inputValue: V,
      menuIsOpen: F,
      onChange: L,
      onInputChange: N,
      onMenuClose: j,
      onMenuOpen: U,
      value: K
    });
  }
  function Vae(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
  }
  function CI(e, t) {
    for (var n = 0; n < t.length; n++) {
      var r = t[n];
      r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, p6(r.key), r);
    }
  }
  function Hae(e, t, n) {
    return t && CI(e.prototype, t), n && CI(e, n), Object.defineProperty(e, "prototype", {
      writable: !1
    }), e;
  }
  function qae(e, t) {
    if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
    e.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: e,
        writable: !0,
        configurable: !0
      }
    }), Object.defineProperty(e, "prototype", {
      writable: !1
    }), t && r0(e, t);
  }
  function m0(e) {
    return m0 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    }, m0(e);
  }
  function m6() {
    try {
      var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch {
    }
    return (m6 = function() {
      return !!e;
    })();
  }
  function Wae(e, t) {
    if (t && (dc(t) == "object" || typeof t == "function")) return t;
    if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
    return PF(e);
  }
  function Gae(e) {
    var t = m6();
    return function() {
      var n, r = m0(e);
      if (t) {
        var o = m0(this).constructor;
        n = Reflect.construct(r, arguments, o);
      } else n = r.apply(this, arguments);
      return Wae(this, n);
    };
  }
  function Kae(e) {
    if (Array.isArray(e)) return GE(e);
  }
  function Yae(e) {
    if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
  }
  function Xae() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function uT(e) {
    return Kae(e) || Yae(e) || h6(e) || Xae();
  }
  function Zae(e, t) {
    return t || (t = e.slice(0)), Object.freeze(Object.defineProperties(e, {
      raw: {
        value: Object.freeze(t)
      }
    }));
  }
  var KE = T.useLayoutEffect, Qae = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"], g0 = function() {
  };
  function Jae(e, t) {
    return t ? t[0] === "-" ? e + t : e + "__" + t : e;
  }
  function ese(e, t) {
    for (var n = arguments.length, r = new Array(n > 2 ? n - 2 : 0), o = 2; o < n; o++)
      r[o - 2] = arguments[o];
    var i = [].concat(r);
    if (t && e)
      for (var a in t)
        t.hasOwnProperty(a) && t[a] && i.push("".concat(Jae(e, a)));
    return i.filter(function(s) {
      return s;
    }).map(function(s) {
      return String(s).trim();
    }).join(" ");
  }
  var kI = function(t) {
    return cse(t) ? t.filter(Boolean) : dc(t) === "object" && t !== null ? [t] : [];
  }, g6 = function(t) {
    t.className, t.clearValue, t.cx, t.getStyles, t.getClassNames, t.getValue, t.hasValue, t.isMulti, t.isRtl, t.options, t.selectOption, t.selectProps, t.setValue, t.theme;
    var n = es(t, Qae);
    return Xe({}, n);
  }, Mn = function(t, n, r) {
    var o = t.cx, i = t.getStyles, a = t.getClassNames, s = t.className;
    return {
      css: i(n, t),
      className: o(r ?? {}, a(n, t), s)
    };
  };
  function Fb(e) {
    return [document.documentElement, document.body, window].indexOf(e) > -1;
  }
  function tse(e) {
    return Fb(e) ? window.innerHeight : e.clientHeight;
  }
  function y6(e) {
    return Fb(e) ? window.pageYOffset : e.scrollTop;
  }
  function y0(e, t) {
    if (Fb(e)) {
      window.scrollTo(0, t);
      return;
    }
    e.scrollTop = t;
  }
  function nse(e) {
    var t = getComputedStyle(e), n = t.position === "absolute", r = /(auto|scroll)/;
    if (t.position === "fixed") return document.documentElement;
    for (var o = e; o = o.parentElement; )
      if (t = getComputedStyle(o), !(n && t.position === "static") && r.test(t.overflow + t.overflowY + t.overflowX))
        return o;
    return document.documentElement;
  }
  function rse(e, t, n, r) {
    return n * ((e = e / r - 1) * e * e + 1) + t;
  }
  function iy(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : g0, o = y6(e), i = t - o, a = 10, s = 0;
    function c() {
      s += a;
      var u = rse(s, o, i, n);
      y0(e, u), s < n ? window.requestAnimationFrame(c) : r(e);
    }
    c();
  }
  function TI(e, t) {
    var n = e.getBoundingClientRect(), r = t.getBoundingClientRect(), o = t.offsetHeight / 3;
    r.bottom + o > n.bottom ? y0(e, Math.min(t.offsetTop + t.clientHeight - e.offsetHeight + o, e.scrollHeight)) : r.top - o < n.top && y0(e, Math.max(t.offsetTop - o, 0));
  }
  function ose(e) {
    var t = e.getBoundingClientRect();
    return {
      bottom: t.bottom,
      height: t.height,
      left: t.left,
      right: t.right,
      top: t.top,
      width: t.width
    };
  }
  function AI() {
    try {
      return document.createEvent("TouchEvent"), !0;
    } catch {
      return !1;
    }
  }
  function ise() {
    try {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    } catch {
      return !1;
    }
  }
  var v6 = !1, ase = {
    get passive() {
      return v6 = !0;
    }
  }, ay = typeof window < "u" ? window : {};
  ay.addEventListener && ay.removeEventListener && (ay.addEventListener("p", g0, ase), ay.removeEventListener("p", g0, !1));
  var sse = v6;
  function lse(e) {
    return e != null;
  }
  function cse(e) {
    return Array.isArray(e);
  }
  function sy(e, t, n) {
    return e ? t : n;
  }
  var use = function(t) {
    for (var n = arguments.length, r = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)
      r[o - 1] = arguments[o];
    var i = Object.entries(t).filter(function(a) {
      var s = za(a, 1), c = s[0];
      return !r.includes(c);
    });
    return i.reduce(function(a, s) {
      var c = za(s, 2), u = c[0], d = c[1];
      return a[u] = d, a;
    }, {});
  }, fse = ["children", "innerProps"], dse = ["children", "innerProps"];
  function pse(e) {
    var t = e.maxHeight, n = e.menuEl, r = e.minHeight, o = e.placement, i = e.shouldScroll, a = e.isFixedPosition, s = e.controlHeight, c = nse(n), u = {
      placement: "bottom",
      maxHeight: t
    };
    if (!n || !n.offsetParent) return u;
    var d = c.getBoundingClientRect(), p = d.height, m = n.getBoundingClientRect(), g = m.bottom, y = m.height, b = m.top, v = n.offsetParent.getBoundingClientRect(), x = v.top, E = a ? window.innerHeight : tse(c), _ = y6(c), C = parseInt(getComputedStyle(n).marginBottom, 10), k = parseInt(getComputedStyle(n).marginTop, 10), A = x - k, O = E - b, P = A + _, I = p - _ - b, $ = g - E + _ + C, L = _ + b - k, N = 160;
    switch (o) {
      case "auto":
      case "bottom":
        if (O >= y)
          return {
            placement: "bottom",
            maxHeight: t
          };
        if (I >= y && !a)
          return i && iy(c, $, N), {
            placement: "bottom",
            maxHeight: t
          };
        if (!a && I >= r || a && O >= r) {
          i && iy(c, $, N);
          var U = a ? O - C : I - C;
          return {
            placement: "bottom",
            maxHeight: U
          };
        }
        if (o === "auto" || a) {
          var j = t, V = a ? A : P;
          return V >= r && (j = Math.min(V - C - s, t)), {
            placement: "top",
            maxHeight: j
          };
        }
        if (o === "bottom")
          return i && y0(c, $), {
            placement: "bottom",
            maxHeight: t
          };
        break;
      case "top":
        if (A >= y)
          return {
            placement: "top",
            maxHeight: t
          };
        if (P >= y && !a)
          return i && iy(c, L, N), {
            placement: "top",
            maxHeight: t
          };
        if (!a && P >= r || a && A >= r) {
          var F = t;
          return (!a && P >= r || a && A >= r) && (F = a ? A - k : P - k), i && iy(c, L, N), {
            placement: "top",
            maxHeight: F
          };
        }
        return {
          placement: "bottom",
          maxHeight: t
        };
      default:
        throw new Error('Invalid placement provided "'.concat(o, '".'));
    }
    return u;
  }
  function hse(e) {
    var t = {
      bottom: "top",
      top: "bottom"
    };
    return e ? t[e] : "bottom";
  }
  var b6 = function(t) {
    return t === "auto" ? "bottom" : t;
  }, mse = function(t, n) {
    var r, o = t.placement, i = t.theme, a = i.borderRadius, s = i.spacing, c = i.colors;
    return Xe((r = {
      label: "menu"
    }, yp(r, hse(o), "100%"), yp(r, "position", "absolute"), yp(r, "width", "100%"), yp(r, "zIndex", 1), r), n ? {} : {
      backgroundColor: c.neutral0,
      borderRadius: a,
      boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
      marginBottom: s.menuGutter,
      marginTop: s.menuGutter
    });
  }, x6 = /* @__PURE__ */ T.createContext(null), gse = function(t) {
    var n = t.children, r = t.minMenuHeight, o = t.maxMenuHeight, i = t.menuPlacement, a = t.menuPosition, s = t.menuShouldScrollIntoView, c = t.theme, u = T.useContext(x6) || {}, d = u.setPortalPlacement, p = T.useRef(null), m = T.useState(o), g = za(m, 2), y = g[0], b = g[1], v = T.useState(null), x = za(v, 2), E = x[0], _ = x[1], C = c.spacing.controlHeight;
    return KE(function() {
      var k = p.current;
      if (k) {
        var A = a === "fixed", O = s && !A, P = pse({
          maxHeight: o,
          menuEl: k,
          minHeight: r,
          placement: i,
          shouldScroll: O,
          isFixedPosition: A,
          controlHeight: C
        });
        b(P.maxHeight), _(P.placement), d?.(P.placement);
      }
    }, [o, i, a, s, r, d, C]), n({
      ref: p,
      placerProps: Xe(Xe({}, t), {}, {
        placement: E || b6(i),
        maxHeight: y
      })
    });
  }, yse = function(t) {
    var n = t.children, r = t.innerRef, o = t.innerProps;
    return We("div", Ke({}, Mn(t, "menu", {
      menu: !0
    }), {
      ref: r
    }, o), n);
  }, vse = yse, bse = function(t, n) {
    var r = t.maxHeight, o = t.theme.spacing.baseUnit;
    return Xe({
      maxHeight: r,
      overflowY: "auto",
      position: "relative",
      // required for offset[Height, Top] > keyboard scroll
      WebkitOverflowScrolling: "touch"
    }, n ? {} : {
      paddingBottom: o,
      paddingTop: o
    });
  }, xse = function(t) {
    var n = t.children, r = t.innerProps, o = t.innerRef, i = t.isMulti;
    return We("div", Ke({}, Mn(t, "menuList", {
      "menu-list": !0,
      "menu-list--is-multi": i
    }), {
      ref: o
    }, r), n);
  }, w6 = function(t, n) {
    var r = t.theme, o = r.spacing.baseUnit, i = r.colors;
    return Xe({
      textAlign: "center"
    }, n ? {} : {
      color: i.neutral40,
      padding: "".concat(o * 2, "px ").concat(o * 3, "px")
    });
  }, wse = w6, Sse = w6, _se = function(t) {
    var n = t.children, r = n === void 0 ? "No options" : n, o = t.innerProps, i = es(t, fse);
    return We("div", Ke({}, Mn(Xe(Xe({}, i), {}, {
      children: r,
      innerProps: o
    }), "noOptionsMessage", {
      "menu-notice": !0,
      "menu-notice--no-options": !0
    }), o), r);
  }, Ese = function(t) {
    var n = t.children, r = n === void 0 ? "Loading..." : n, o = t.innerProps, i = es(t, dse);
    return We("div", Ke({}, Mn(Xe(Xe({}, i), {}, {
      children: r,
      innerProps: o
    }), "loadingMessage", {
      "menu-notice": !0,
      "menu-notice--loading": !0
    }), o), r);
  }, Cse = function(t) {
    var n = t.rect, r = t.offset, o = t.position;
    return {
      left: n.left,
      position: o,
      top: r,
      width: n.width,
      zIndex: 1
    };
  }, kse = function(t) {
    var n = t.appendTo, r = t.children, o = t.controlElement, i = t.innerProps, a = t.menuPlacement, s = t.menuPosition, c = T.useRef(null), u = T.useRef(null), d = T.useState(b6(a)), p = za(d, 2), m = p[0], g = p[1], y = T.useMemo(function() {
      return {
        setPortalPlacement: g
      };
    }, []), b = T.useState(null), v = za(b, 2), x = v[0], E = v[1], _ = T.useCallback(function() {
      if (o) {
        var O = ose(o), P = s === "fixed" ? 0 : window.pageYOffset, I = O[m] + P;
        (I !== x?.offset || O.left !== x?.rect.left || O.width !== x?.rect.width) && E({
          offset: I,
          rect: O
        });
      }
    }, [o, s, m, x?.offset, x?.rect.left, x?.rect.width]);
    KE(function() {
      _();
    }, [_]);
    var C = T.useCallback(function() {
      typeof u.current == "function" && (u.current(), u.current = null), o && c.current && (u.current = jz(o, c.current, _, {
        elementResize: "ResizeObserver" in window
      }));
    }, [o, _]);
    KE(function() {
      C();
    }, [C]);
    var k = T.useCallback(function(O) {
      c.current = O, C();
    }, [C]);
    if (!n && s !== "fixed" || !x) return null;
    var A = We("div", Ke({
      ref: k
    }, Mn(Xe(Xe({}, t), {}, {
      offset: x.offset,
      position: s,
      rect: x.rect
    }), "menuPortal", {
      "menu-portal": !0
    }), i), r);
    return We(x6.Provider, {
      value: y
    }, n ? /* @__PURE__ */ _c.createPortal(A, n) : A);
  }, Tse = function(t) {
    var n = t.isDisabled, r = t.isRtl;
    return {
      label: "container",
      direction: r ? "rtl" : void 0,
      pointerEvents: n ? "none" : void 0,
      // cancel mouse events when disabled
      position: "relative"
    };
  }, Ase = function(t) {
    var n = t.children, r = t.innerProps, o = t.isDisabled, i = t.isRtl;
    return We("div", Ke({}, Mn(t, "container", {
      "--is-disabled": o,
      "--is-rtl": i
    }), r), n);
  }, Rse = function(t, n) {
    var r = t.theme.spacing, o = t.isMulti, i = t.hasValue, a = t.selectProps.controlShouldRenderValue;
    return Xe({
      alignItems: "center",
      display: o && i && a ? "flex" : "grid",
      flex: 1,
      flexWrap: "wrap",
      WebkitOverflowScrolling: "touch",
      position: "relative",
      overflow: "hidden"
    }, n ? {} : {
      padding: "".concat(r.baseUnit / 2, "px ").concat(r.baseUnit * 2, "px")
    });
  }, Ose = function(t) {
    var n = t.children, r = t.innerProps, o = t.isMulti, i = t.hasValue;
    return We("div", Ke({}, Mn(t, "valueContainer", {
      "value-container": !0,
      "value-container--is-multi": o,
      "value-container--has-value": i
    }), r), n);
  }, Mse = function() {
    return {
      alignItems: "center",
      alignSelf: "stretch",
      display: "flex",
      flexShrink: 0
    };
  }, Nse = function(t) {
    var n = t.children, r = t.innerProps;
    return We("div", Ke({}, Mn(t, "indicatorsContainer", {
      indicators: !0
    }), r), n);
  }, RI, Pse = ["size"], Ise = ["innerProps", "isRtl", "size"], $se = {
    name: "8mmkcg",
    styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
  }, S6 = function(t) {
    var n = t.size, r = es(t, Pse);
    return We("svg", Ke({
      height: n,
      width: n,
      viewBox: "0 0 20 20",
      "aria-hidden": "true",
      focusable: "false",
      css: $se
    }, r));
  }, fT = function(t) {
    return We(S6, Ke({
      size: 20
    }, t), We("path", {
      d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
    }));
  }, _6 = function(t) {
    return We(S6, Ke({
      size: 20
    }, t), We("path", {
      d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
    }));
  }, E6 = function(t, n) {
    var r = t.isFocused, o = t.theme, i = o.spacing.baseUnit, a = o.colors;
    return Xe({
      label: "indicatorContainer",
      display: "flex",
      transition: "color 150ms"
    }, n ? {} : {
      color: r ? a.neutral60 : a.neutral20,
      padding: i * 2,
      ":hover": {
        color: r ? a.neutral80 : a.neutral40
      }
    });
  }, jse = E6, Dse = function(t) {
    var n = t.children, r = t.innerProps;
    return We("div", Ke({}, Mn(t, "dropdownIndicator", {
      indicator: !0,
      "dropdown-indicator": !0
    }), r), n || We(_6, null));
  }, Fse = E6, Lse = function(t) {
    var n = t.children, r = t.innerProps;
    return We("div", Ke({}, Mn(t, "clearIndicator", {
      indicator: !0,
      "clear-indicator": !0
    }), r), n || We(fT, null));
  }, zse = function(t, n) {
    var r = t.isDisabled, o = t.theme, i = o.spacing.baseUnit, a = o.colors;
    return Xe({
      label: "indicatorSeparator",
      alignSelf: "stretch",
      width: 1
    }, n ? {} : {
      backgroundColor: r ? a.neutral10 : a.neutral20,
      marginBottom: i * 2,
      marginTop: i * 2
    });
  }, Bse = function(t) {
    var n = t.innerProps;
    return We("span", Ke({}, n, Mn(t, "indicatorSeparator", {
      "indicator-separator": !0
    })));
  }, Use = If(RI || (RI = Zae([`
  0%, 80%, 100% { opacity: 0; }
  40% { opacity: 1; }
`]))), Vse = function(t, n) {
    var r = t.isFocused, o = t.size, i = t.theme, a = i.colors, s = i.spacing.baseUnit;
    return Xe({
      label: "loadingIndicator",
      display: "flex",
      transition: "color 150ms",
      alignSelf: "center",
      fontSize: o,
      lineHeight: 1,
      marginRight: o,
      textAlign: "center",
      verticalAlign: "middle"
    }, n ? {} : {
      color: r ? a.neutral60 : a.neutral20,
      padding: s * 2
    });
  }, jS = function(t) {
    var n = t.delay, r = t.offset;
    return We("span", {
      css: /* @__PURE__ */ Dh({
        animation: "".concat(Use, " 1s ease-in-out ").concat(n, "ms infinite;"),
        backgroundColor: "currentColor",
        borderRadius: "1em",
        display: "inline-block",
        marginLeft: r ? "1em" : void 0,
        height: "1em",
        verticalAlign: "top",
        width: "1em"
      }, "", "")
    });
  }, Hse = function(t) {
    var n = t.innerProps, r = t.isRtl, o = t.size, i = o === void 0 ? 4 : o, a = es(t, Ise);
    return We("div", Ke({}, Mn(Xe(Xe({}, a), {}, {
      innerProps: n,
      isRtl: r,
      size: i
    }), "loadingIndicator", {
      indicator: !0,
      "loading-indicator": !0
    }), n), We(jS, {
      delay: 0,
      offset: r
    }), We(jS, {
      delay: 160,
      offset: !0
    }), We(jS, {
      delay: 320,
      offset: !r
    }));
  }, qse = function(t, n) {
    var r = t.isDisabled, o = t.isFocused, i = t.theme, a = i.colors, s = i.borderRadius, c = i.spacing;
    return Xe({
      label: "control",
      alignItems: "center",
      cursor: "default",
      display: "flex",
      flexWrap: "wrap",
      justifyContent: "space-between",
      minHeight: c.controlHeight,
      outline: "0 !important",
      position: "relative",
      transition: "all 100ms"
    }, n ? {} : {
      backgroundColor: r ? a.neutral5 : a.neutral0,
      borderColor: r ? a.neutral10 : o ? a.primary : a.neutral20,
      borderRadius: s,
      borderStyle: "solid",
      borderWidth: 1,
      boxShadow: o ? "0 0 0 1px ".concat(a.primary) : void 0,
      "&:hover": {
        borderColor: o ? a.primary : a.neutral30
      }
    });
  }, Wse = function(t) {
    var n = t.children, r = t.isDisabled, o = t.isFocused, i = t.innerRef, a = t.innerProps, s = t.menuIsOpen;
    return We("div", Ke({
      ref: i
    }, Mn(t, "control", {
      control: !0,
      "control--is-disabled": r,
      "control--is-focused": o,
      "control--menu-is-open": s
    }), a, {
      "aria-disabled": r || void 0
    }), n);
  }, Gse = Wse, Kse = ["data"], Yse = function(t, n) {
    var r = t.theme.spacing;
    return n ? {} : {
      paddingBottom: r.baseUnit * 2,
      paddingTop: r.baseUnit * 2
    };
  }, Xse = function(t) {
    var n = t.children, r = t.cx, o = t.getStyles, i = t.getClassNames, a = t.Heading, s = t.headingProps, c = t.innerProps, u = t.label, d = t.theme, p = t.selectProps;
    return We("div", Ke({}, Mn(t, "group", {
      group: !0
    }), c), We(a, Ke({}, s, {
      selectProps: p,
      theme: d,
      getStyles: o,
      getClassNames: i,
      cx: r
    }), u), We("div", null, n));
  }, Zse = function(t, n) {
    var r = t.theme, o = r.colors, i = r.spacing;
    return Xe({
      label: "group",
      cursor: "default",
      display: "block"
    }, n ? {} : {
      color: o.neutral40,
      fontSize: "75%",
      fontWeight: 500,
      marginBottom: "0.25em",
      paddingLeft: i.baseUnit * 3,
      paddingRight: i.baseUnit * 3,
      textTransform: "uppercase"
    });
  }, Qse = function(t) {
    var n = g6(t);
    n.data;
    var r = es(n, Kse);
    return We("div", Ke({}, Mn(t, "groupHeading", {
      "group-heading": !0
    }), r));
  }, Jse = Xse, ele = ["innerRef", "isDisabled", "isHidden", "inputClassName"], tle = function(t, n) {
    var r = t.isDisabled, o = t.value, i = t.theme, a = i.spacing, s = i.colors;
    return Xe(Xe({
      visibility: r ? "hidden" : "visible",
      // force css to recompute when value change due to @emotion bug.
      // We can remove it whenever the bug is fixed.
      transform: o ? "translateZ(0)" : ""
    }, nle), n ? {} : {
      margin: a.baseUnit / 2,
      paddingBottom: a.baseUnit / 2,
      paddingTop: a.baseUnit / 2,
      color: s.neutral80
    });
  }, C6 = {
    gridArea: "1 / 2",
    font: "inherit",
    minWidth: "2px",
    border: 0,
    margin: 0,
    outline: 0,
    padding: 0
  }, nle = {
    flex: "1 1 auto",
    display: "inline-grid",
    gridArea: "1 / 1 / 2 / 3",
    gridTemplateColumns: "0 min-content",
    "&:after": Xe({
      content: 'attr(data-value) " "',
      visibility: "hidden",
      whiteSpace: "pre"
    }, C6)
  }, rle = function(t) {
    return Xe({
      label: "input",
      color: "inherit",
      background: 0,
      opacity: t ? 0 : 1,
      width: "100%"
    }, C6);
  }, ole = function(t) {
    var n = t.cx, r = t.value, o = g6(t), i = o.innerRef, a = o.isDisabled, s = o.isHidden, c = o.inputClassName, u = es(o, ele);
    return We("div", Ke({}, Mn(t, "input", {
      "input-container": !0
    }), {
      "data-value": r || ""
    }), We("input", Ke({
      className: n({
        input: !0
      }, c),
      ref: i,
      style: rle(s),
      disabled: a
    }, u)));
  }, ile = ole, ale = function(t, n) {
    var r = t.theme, o = r.spacing, i = r.borderRadius, a = r.colors;
    return Xe({
      label: "multiValue",
      display: "flex",
      minWidth: 0
    }, n ? {} : {
      backgroundColor: a.neutral10,
      borderRadius: i / 2,
      margin: o.baseUnit / 2
    });
  }, sle = function(t, n) {
    var r = t.theme, o = r.borderRadius, i = r.colors, a = t.cropWithEllipsis;
    return Xe({
      overflow: "hidden",
      textOverflow: a || a === void 0 ? "ellipsis" : void 0,
      whiteSpace: "nowrap"
    }, n ? {} : {
      borderRadius: o / 2,
      color: i.neutral80,
      fontSize: "85%",
      padding: 3,
      paddingLeft: 6
    });
  }, lle = function(t, n) {
    var r = t.theme, o = r.spacing, i = r.borderRadius, a = r.colors, s = t.isFocused;
    return Xe({
      alignItems: "center",
      display: "flex"
    }, n ? {} : {
      borderRadius: i / 2,
      backgroundColor: s ? a.dangerLight : void 0,
      paddingLeft: o.baseUnit,
      paddingRight: o.baseUnit,
      ":hover": {
        backgroundColor: a.dangerLight,
        color: a.danger
      }
    });
  }, k6 = function(t) {
    var n = t.children, r = t.innerProps;
    return We("div", r, n);
  }, cle = k6, ule = k6;
  function fle(e) {
    var t = e.children, n = e.innerProps;
    return We("div", Ke({
      role: "button"
    }, n), t || We(fT, {
      size: 14
    }));
  }
  var dle = function(t) {
    var n = t.children, r = t.components, o = t.data, i = t.innerProps, a = t.isDisabled, s = t.removeProps, c = t.selectProps, u = r.Container, d = r.Label, p = r.Remove;
    return We(u, {
      data: o,
      innerProps: Xe(Xe({}, Mn(t, "multiValue", {
        "multi-value": !0,
        "multi-value--is-disabled": a
      })), i),
      selectProps: c
    }, We(d, {
      data: o,
      innerProps: Xe({}, Mn(t, "multiValueLabel", {
        "multi-value__label": !0
      })),
      selectProps: c
    }, n), We(p, {
      data: o,
      innerProps: Xe(Xe({}, Mn(t, "multiValueRemove", {
        "multi-value__remove": !0
      })), {}, {
        "aria-label": "Remove ".concat(n || "option")
      }, s),
      selectProps: c
    }));
  }, ple = dle, hle = function(t, n) {
    var r = t.isDisabled, o = t.isFocused, i = t.isSelected, a = t.theme, s = a.spacing, c = a.colors;
    return Xe({
      label: "option",
      cursor: "default",
      display: "block",
      fontSize: "inherit",
      width: "100%",
      userSelect: "none",
      WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
    }, n ? {} : {
      backgroundColor: i ? c.primary : o ? c.primary25 : "transparent",
      color: r ? c.neutral20 : i ? c.neutral0 : "inherit",
      padding: "".concat(s.baseUnit * 2, "px ").concat(s.baseUnit * 3, "px"),
      // provide some affordance on touch devices
      ":active": {
        backgroundColor: r ? void 0 : i ? c.primary : c.primary50
      }
    });
  }, mle = function(t) {
    var n = t.children, r = t.isDisabled, o = t.isFocused, i = t.isSelected, a = t.innerRef, s = t.innerProps;
    return We("div", Ke({}, Mn(t, "option", {
      option: !0,
      "option--is-disabled": r,
      "option--is-focused": o,
      "option--is-selected": i
    }), {
      ref: a,
      "aria-disabled": r
    }, s), n);
  }, gle = mle, yle = function(t, n) {
    var r = t.theme, o = r.spacing, i = r.colors;
    return Xe({
      label: "placeholder",
      gridArea: "1 / 1 / 2 / 3"
    }, n ? {} : {
      color: i.neutral50,
      marginLeft: o.baseUnit / 2,
      marginRight: o.baseUnit / 2
    });
  }, vle = function(t) {
    var n = t.children, r = t.innerProps;
    return We("div", Ke({}, Mn(t, "placeholder", {
      placeholder: !0
    }), r), n);
  }, ble = vle, xle = function(t, n) {
    var r = t.isDisabled, o = t.theme, i = o.spacing, a = o.colors;
    return Xe({
      label: "singleValue",
      gridArea: "1 / 1 / 2 / 3",
      maxWidth: "100%",
      overflow: "hidden",
      textOverflow: "ellipsis",
      whiteSpace: "nowrap"
    }, n ? {} : {
      color: r ? a.neutral40 : a.neutral80,
      marginLeft: i.baseUnit / 2,
      marginRight: i.baseUnit / 2
    });
  }, wle = function(t) {
    var n = t.children, r = t.isDisabled, o = t.innerProps;
    return We("div", Ke({}, Mn(t, "singleValue", {
      "single-value": !0,
      "single-value--is-disabled": r
    }), o), n);
  }, Sle = wle, _le = {
    ClearIndicator: Lse,
    Control: Gse,
    DropdownIndicator: Dse,
    DownChevron: _6,
    CrossIcon: fT,
    Group: Jse,
    GroupHeading: Qse,
    IndicatorsContainer: Nse,
    IndicatorSeparator: Bse,
    Input: ile,
    LoadingIndicator: Hse,
    Menu: vse,
    MenuList: xse,
    MenuPortal: kse,
    LoadingMessage: Ese,
    NoOptionsMessage: _se,
    MultiValue: ple,
    MultiValueContainer: cle,
    MultiValueLabel: ule,
    MultiValueRemove: fle,
    Option: gle,
    Placeholder: ble,
    SelectContainer: Ase,
    SingleValue: Sle,
    ValueContainer: Ose
  }, Ele = function(t) {
    return Xe(Xe({}, _le), t.components);
  }, OI = Number.isNaN || function(t) {
    return typeof t == "number" && t !== t;
  };
  function Cle(e, t) {
    return !!(e === t || OI(e) && OI(t));
  }
  function kle(e, t) {
    if (e.length !== t.length)
      return !1;
    for (var n = 0; n < e.length; n++)
      if (!Cle(e[n], t[n]))
        return !1;
    return !0;
  }
  function Tle(e, t) {
    t === void 0 && (t = kle);
    var n = null;
    function r() {
      for (var o = [], i = 0; i < arguments.length; i++)
        o[i] = arguments[i];
      if (n && n.lastThis === this && t(o, n.lastArgs))
        return n.lastResult;
      var a = e.apply(this, o);
      return n = {
        lastResult: a,
        lastArgs: o,
        lastThis: this
      }, a;
    }
    return r.clear = function() {
      n = null;
    }, r;
  }
  var Ale = {
    name: "7pg0cj-a11yText",
    styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
  }, Rle = function(t) {
    return We("span", Ke({
      css: Ale
    }, t));
  }, MI = Rle, Ole = {
    guidance: function(t) {
      var n = t.isSearchable, r = t.isMulti, o = t.tabSelectsValue, i = t.context, a = t.isInitialFocus;
      switch (i) {
        case "menu":
          return "Use Up and Down to choose options, press Enter to select the currently focused option, press Escape to exit the menu".concat(o ? ", press Tab to select the option and exit the menu" : "", ".");
        case "input":
          return a ? "".concat(t["aria-label"] || "Select", " is focused ").concat(n ? ",type to refine list" : "", ", press Down to open the menu, ").concat(r ? " press left to focus selected values" : "") : "";
        case "value":
          return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
        default:
          return "";
      }
    },
    onChange: function(t) {
      var n = t.action, r = t.label, o = r === void 0 ? "" : r, i = t.labels, a = t.isDisabled;
      switch (n) {
        case "deselect-option":
        case "pop-value":
        case "remove-value":
          return "option ".concat(o, ", deselected.");
        case "clear":
          return "All selected options have been cleared.";
        case "initial-input-focus":
          return "option".concat(i.length > 1 ? "s" : "", " ").concat(i.join(","), ", selected.");
        case "select-option":
          return a ? "option ".concat(o, " is disabled. Select another option.") : "option ".concat(o, ", selected.");
        default:
          return "";
      }
    },
    onFocus: function(t) {
      var n = t.context, r = t.focused, o = t.options, i = t.label, a = i === void 0 ? "" : i, s = t.selectValue, c = t.isDisabled, u = t.isSelected, d = t.isAppleDevice, p = function(b, v) {
        return b && b.length ? "".concat(b.indexOf(v) + 1, " of ").concat(b.length) : "";
      };
      if (n === "value" && s)
        return "value ".concat(a, " focused, ").concat(p(s, r), ".");
      if (n === "menu" && d) {
        var m = c ? " disabled" : "", g = "".concat(u ? " selected" : "").concat(m);
        return "".concat(a).concat(g, ", ").concat(p(o, r), ".");
      }
      return "";
    },
    onFilter: function(t) {
      var n = t.inputValue, r = t.resultsMessage;
      return "".concat(r).concat(n ? " for search term " + n : "", ".");
    }
  }, Mle = function(t) {
    var n = t.ariaSelection, r = t.focusedOption, o = t.focusedValue, i = t.focusableOptions, a = t.isFocused, s = t.selectValue, c = t.selectProps, u = t.id, d = t.isAppleDevice, p = c.ariaLiveMessages, m = c.getOptionLabel, g = c.inputValue, y = c.isMulti, b = c.isOptionDisabled, v = c.isSearchable, x = c.menuIsOpen, E = c.options, _ = c.screenReaderStatus, C = c.tabSelectsValue, k = c.isLoading, A = c["aria-label"], O = c["aria-live"], P = T.useMemo(function() {
      return Xe(Xe({}, Ole), p || {});
    }, [p]), I = T.useMemo(function() {
      var V = "";
      if (n && P.onChange) {
        var F = n.option, K = n.options, W = n.removedValue, Y = n.removedValues, B = n.value, D = function(te) {
          return Array.isArray(te) ? null : te;
        }, G = W || F || D(B), z = G ? m(G) : "", H = K || Y || void 0, X = H ? H.map(m) : [], Q = Xe({
          // multiSelected items are usually items that have already been selected
          // or set by the user as a default value so we assume they are not disabled
          isDisabled: G && b(G, s),
          label: z,
          labels: X
        }, n);
        V = P.onChange(Q);
      }
      return V;
    }, [n, P, b, s, m]), $ = T.useMemo(function() {
      var V = "", F = r || o, K = !!(r && s && s.includes(r));
      if (F && P.onFocus) {
        var W = {
          focused: F,
          label: m(F),
          isDisabled: b(F, s),
          isSelected: K,
          options: i,
          context: F === r ? "menu" : "value",
          selectValue: s,
          isAppleDevice: d
        };
        V = P.onFocus(W);
      }
      return V;
    }, [r, o, m, b, P, i, s, d]), L = T.useMemo(function() {
      var V = "";
      if (x && E.length && !k && P.onFilter) {
        var F = _({
          count: i.length
        });
        V = P.onFilter({
          inputValue: g,
          resultsMessage: F
        });
      }
      return V;
    }, [i, g, x, P, E, _, k]), N = n?.action === "initial-input-focus", U = T.useMemo(function() {
      var V = "";
      if (P.guidance) {
        var F = o ? "value" : x ? "menu" : "input";
        V = P.guidance({
          "aria-label": A,
          context: F,
          isDisabled: r && b(r, s),
          isMulti: y,
          isSearchable: v,
          tabSelectsValue: C,
          isInitialFocus: N
        });
      }
      return V;
    }, [A, r, o, y, b, v, x, P, s, C, N]), j = We(T.Fragment, null, We("span", {
      id: "aria-selection"
    }, I), We("span", {
      id: "aria-focused"
    }, $), We("span", {
      id: "aria-results"
    }, L), We("span", {
      id: "aria-guidance"
    }, U));
    return We(T.Fragment, null, We(MI, {
      id: u
    }, N && j), We(MI, {
      "aria-live": O,
      "aria-atomic": "false",
      "aria-relevant": "additions text",
      role: "log"
    }, a && !N && j));
  }, Nle = Mle, YE = [{
    base: "A",
    letters: "A"
  }, {
    base: "AA",
    letters: ""
  }, {
    base: "AE",
    letters: ""
  }, {
    base: "AO",
    letters: ""
  }, {
    base: "AU",
    letters: ""
  }, {
    base: "AV",
    letters: ""
  }, {
    base: "AY",
    letters: ""
  }, {
    base: "B",
    letters: "B"
  }, {
    base: "C",
    letters: "C"
  }, {
    base: "D",
    letters: "D"
  }, {
    base: "DZ",
    letters: ""
  }, {
    base: "Dz",
    letters: ""
  }, {
    base: "E",
    letters: "E"
  }, {
    base: "F",
    letters: "F"
  }, {
    base: "G",
    letters: "G"
  }, {
    base: "H",
    letters: "H"
  }, {
    base: "I",
    letters: "I"
  }, {
    base: "J",
    letters: "J"
  }, {
    base: "K",
    letters: "K"
  }, {
    base: "L",
    letters: "L"
  }, {
    base: "LJ",
    letters: ""
  }, {
    base: "Lj",
    letters: ""
  }, {
    base: "M",
    letters: "M"
  }, {
    base: "N",
    letters: "N"
  }, {
    base: "NJ",
    letters: ""
  }, {
    base: "Nj",
    letters: ""
  }, {
    base: "O",
    letters: "O"
  }, {
    base: "OI",
    letters: ""
  }, {
    base: "OO",
    letters: ""
  }, {
    base: "OU",
    letters: ""
  }, {
    base: "P",
    letters: "P"
  }, {
    base: "Q",
    letters: "Q"
  }, {
    base: "R",
    letters: "R"
  }, {
    base: "S",
    letters: "S"
  }, {
    base: "T",
    letters: "T"
  }, {
    base: "TZ",
    letters: ""
  }, {
    base: "U",
    letters: "U"
  }, {
    base: "V",
    letters: "V"
  }, {
    base: "VY",
    letters: ""
  }, {
    base: "W",
    letters: "W"
  }, {
    base: "X",
    letters: "X"
  }, {
    base: "Y",
    letters: "Y"
  }, {
    base: "Z",
    letters: "Z"
  }, {
    base: "a",
    letters: "a"
  }, {
    base: "aa",
    letters: ""
  }, {
    base: "ae",
    letters: ""
  }, {
    base: "ao",
    letters: ""
  }, {
    base: "au",
    letters: ""
  }, {
    base: "av",
    letters: ""
  }, {
    base: "ay",
    letters: ""
  }, {
    base: "b",
    letters: "b"
  }, {
    base: "c",
    letters: "c"
  }, {
    base: "d",
    letters: "d"
  }, {
    base: "dz",
    letters: ""
  }, {
    base: "e",
    letters: "e"
  }, {
    base: "f",
    letters: "f"
  }, {
    base: "g",
    letters: "g"
  }, {
    base: "h",
    letters: "h"
  }, {
    base: "hv",
    letters: ""
  }, {
    base: "i",
    letters: "i"
  }, {
    base: "j",
    letters: "j"
  }, {
    base: "k",
    letters: "k"
  }, {
    base: "l",
    letters: "l"
  }, {
    base: "lj",
    letters: ""
  }, {
    base: "m",
    letters: "m"
  }, {
    base: "n",
    letters: "n"
  }, {
    base: "nj",
    letters: ""
  }, {
    base: "o",
    letters: "o"
  }, {
    base: "oi",
    letters: ""
  }, {
    base: "ou",
    letters: ""
  }, {
    base: "oo",
    letters: ""
  }, {
    base: "p",
    letters: "p"
  }, {
    base: "q",
    letters: "q"
  }, {
    base: "r",
    letters: "r"
  }, {
    base: "s",
    letters: "s"
  }, {
    base: "t",
    letters: "t"
  }, {
    base: "tz",
    letters: ""
  }, {
    base: "u",
    letters: "u"
  }, {
    base: "v",
    letters: "v"
  }, {
    base: "vy",
    letters: ""
  }, {
    base: "w",
    letters: "w"
  }, {
    base: "x",
    letters: "x"
  }, {
    base: "y",
    letters: "y"
  }, {
    base: "z",
    letters: "z"
  }], Ple = new RegExp("[" + YE.map(function(e) {
    return e.letters;
  }).join("") + "]", "g"), T6 = {};
  for (var DS = 0; DS < YE.length; DS++)
    for (var FS = YE[DS], LS = 0; LS < FS.letters.length; LS++)
      T6[FS.letters[LS]] = FS.base;
  var A6 = function(t) {
    return t.replace(Ple, function(n) {
      return T6[n];
    });
  }, Ile = Tle(A6), NI = function(t) {
    return t.replace(/^\s+|\s+$/g, "");
  }, $le = function(t) {
    return "".concat(t.label, " ").concat(t.value);
  }, jle = function(t) {
    return function(n, r) {
      if (n.data.__isNew__) return !0;
      var o = Xe({
        ignoreCase: !0,
        ignoreAccents: !0,
        stringify: $le,
        trim: !0,
        matchFrom: "any"
      }, t), i = o.ignoreCase, a = o.ignoreAccents, s = o.stringify, c = o.trim, u = o.matchFrom, d = c ? NI(r) : r, p = c ? NI(s(n)) : s(n);
      return i && (d = d.toLowerCase(), p = p.toLowerCase()), a && (d = Ile(d), p = A6(p)), u === "start" ? p.substr(0, d.length) === d : p.indexOf(d) > -1;
    };
  }, Dle = ["innerRef"];
  function Fle(e) {
    var t = e.innerRef, n = es(e, Dle), r = use(n, "onExited", "in", "enter", "exit", "appear");
    return We("input", Ke({
      ref: t
    }, r, {
      css: /* @__PURE__ */ Dh({
        label: "dummyInput",
        // get rid of any default styles
        background: 0,
        border: 0,
        // important! this hides the flashing cursor
        caretColor: "transparent",
        fontSize: "inherit",
        gridArea: "1 / 1 / 2 / 3",
        outline: 0,
        padding: 0,
        // important! without `width` browsers won't allow focus
        width: 1,
        // remove cursor on desktop
        color: "transparent",
        // remove cursor on mobile whilst maintaining "scroll into view" behaviour
        left: -100,
        opacity: 0,
        position: "relative",
        transform: "scale(.01)"
      }, "", "")
    }));
  }
  var Lle = function(t) {
    t.cancelable && t.preventDefault(), t.stopPropagation();
  };
  function zle(e) {
    var t = e.isEnabled, n = e.onBottomArrive, r = e.onBottomLeave, o = e.onTopArrive, i = e.onTopLeave, a = T.useRef(!1), s = T.useRef(!1), c = T.useRef(0), u = T.useRef(null), d = T.useCallback(function(v, x) {
      if (u.current !== null) {
        var E = u.current, _ = E.scrollTop, C = E.scrollHeight, k = E.clientHeight, A = u.current, O = x > 0, P = C - k - _, I = !1;
        P > x && a.current && (r && r(v), a.current = !1), O && s.current && (i && i(v), s.current = !1), O && x > P ? (n && !a.current && n(v), A.scrollTop = C, I = !0, a.current = !0) : !O && -x > _ && (o && !s.current && o(v), A.scrollTop = 0, I = !0, s.current = !0), I && Lle(v);
      }
    }, [n, r, o, i]), p = T.useCallback(function(v) {
      d(v, v.deltaY);
    }, [d]), m = T.useCallback(function(v) {
      c.current = v.changedTouches[0].clientY;
    }, []), g = T.useCallback(function(v) {
      var x = c.current - v.changedTouches[0].clientY;
      d(v, x);
    }, [d]), y = T.useCallback(function(v) {
      if (v) {
        var x = sse ? {
          passive: !1
        } : !1;
        v.addEventListener("wheel", p, x), v.addEventListener("touchstart", m, x), v.addEventListener("touchmove", g, x);
      }
    }, [g, m, p]), b = T.useCallback(function(v) {
      v && (v.removeEventListener("wheel", p, !1), v.removeEventListener("touchstart", m, !1), v.removeEventListener("touchmove", g, !1));
    }, [g, m, p]);
    return T.useEffect(function() {
      if (t) {
        var v = u.current;
        return y(v), function() {
          b(v);
        };
      }
    }, [t, y, b]), function(v) {
      u.current = v;
    };
  }
  var PI = ["boxSizing", "height", "overflow", "paddingRight", "position"], II = {
    boxSizing: "border-box",
    // account for possible declaration `width: 100%;` on body
    overflow: "hidden",
    position: "relative",
    height: "100%"
  };
  function $I(e) {
    e.cancelable && e.preventDefault();
  }
  function jI(e) {
    e.stopPropagation();
  }
  function DI() {
    var e = this.scrollTop, t = this.scrollHeight, n = e + this.offsetHeight;
    e === 0 ? this.scrollTop = 1 : n === t && (this.scrollTop = e - 1);
  }
  function FI() {
    return "ontouchstart" in window || navigator.maxTouchPoints;
  }
  var LI = !!(typeof window < "u" && window.document && window.document.createElement), Gd = 0, Mu = {
    capture: !1,
    passive: !1
  };
  function Ble(e) {
    var t = e.isEnabled, n = e.accountForScrollbars, r = n === void 0 ? !0 : n, o = T.useRef({}), i = T.useRef(null), a = T.useCallback(function(c) {
      if (LI) {
        var u = document.body, d = u && u.style;
        if (r && PI.forEach(function(y) {
          var b = d && d[y];
          o.current[y] = b;
        }), r && Gd < 1) {
          var p = parseInt(o.current.paddingRight, 10) || 0, m = document.body ? document.body.clientWidth : 0, g = window.innerWidth - m + p || 0;
          Object.keys(II).forEach(function(y) {
            var b = II[y];
            d && (d[y] = b);
          }), d && (d.paddingRight = "".concat(g, "px"));
        }
        u && FI() && (u.addEventListener("touchmove", $I, Mu), c && (c.addEventListener("touchstart", DI, Mu), c.addEventListener("touchmove", jI, Mu))), Gd += 1;
      }
    }, [r]), s = T.useCallback(function(c) {
      if (LI) {
        var u = document.body, d = u && u.style;
        Gd = Math.max(Gd - 1, 0), r && Gd < 1 && PI.forEach(function(p) {
          var m = o.current[p];
          d && (d[p] = m);
        }), u && FI() && (u.removeEventListener("touchmove", $I, Mu), c && (c.removeEventListener("touchstart", DI, Mu), c.removeEventListener("touchmove", jI, Mu)));
      }
    }, [r]);
    return T.useEffect(function() {
      if (t) {
        var c = i.current;
        return a(c), function() {
          s(c);
        };
      }
    }, [t, a, s]), function(c) {
      i.current = c;
    };
  }
  var Ule = function(t) {
    var n = t.target;
    return n.ownerDocument.activeElement && n.ownerDocument.activeElement.blur();
  }, Vle = {
    name: "1kfdb0e",
    styles: "position:fixed;left:0;bottom:0;right:0;top:0"
  };
  function Hle(e) {
    var t = e.children, n = e.lockEnabled, r = e.captureEnabled, o = r === void 0 ? !0 : r, i = e.onBottomArrive, a = e.onBottomLeave, s = e.onTopArrive, c = e.onTopLeave, u = zle({
      isEnabled: o,
      onBottomArrive: i,
      onBottomLeave: a,
      onTopArrive: s,
      onTopLeave: c
    }), d = Ble({
      isEnabled: n
    }), p = function(g) {
      u(g), d(g);
    };
    return We(T.Fragment, null, n && We("div", {
      onClick: Ule,
      css: Vle
    }), t(p));
  }
  var qle = {
    name: "1a0ro4n-requiredInput",
    styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
  }, Wle = function(t) {
    var n = t.name, r = t.onFocus;
    return We("input", {
      required: !0,
      name: n,
      tabIndex: -1,
      "aria-hidden": "true",
      onFocus: r,
      css: qle,
      value: "",
      onChange: function() {
      }
    });
  }, Gle = Wle;
  function dT(e) {
    var t;
    return typeof window < "u" && window.navigator != null ? e.test(((t = window.navigator.userAgentData) === null || t === void 0 ? void 0 : t.platform) || window.navigator.platform) : !1;
  }
  function Kle() {
    return dT(/^iPhone/i);
  }
  function R6() {
    return dT(/^Mac/i);
  }
  function Yle() {
    return dT(/^iPad/i) || // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.
    R6() && navigator.maxTouchPoints > 1;
  }
  function Xle() {
    return Kle() || Yle();
  }
  function Zle() {
    return R6() || Xle();
  }
  var Qle = function(t) {
    return t.label;
  }, Jle = function(t) {
    return t.label;
  }, ece = function(t) {
    return t.value;
  }, tce = function(t) {
    return !!t.isDisabled;
  }, nce = {
    clearIndicator: Fse,
    container: Tse,
    control: qse,
    dropdownIndicator: jse,
    group: Yse,
    groupHeading: Zse,
    indicatorsContainer: Mse,
    indicatorSeparator: zse,
    input: tle,
    loadingIndicator: Vse,
    loadingMessage: Sse,
    menu: mse,
    menuList: bse,
    menuPortal: Cse,
    multiValue: ale,
    multiValueLabel: sle,
    multiValueRemove: lle,
    noOptionsMessage: wse,
    option: hle,
    placeholder: yle,
    singleValue: xle,
    valueContainer: Rse
  }, rce = {
    primary: "#2684FF",
    primary75: "#4C9AFF",
    primary50: "#B2D4FF",
    primary25: "#DEEBFF",
    danger: "#DE350B",
    dangerLight: "#FFBDAD",
    neutral0: "hsl(0, 0%, 100%)",
    neutral5: "hsl(0, 0%, 95%)",
    neutral10: "hsl(0, 0%, 90%)",
    neutral20: "hsl(0, 0%, 80%)",
    neutral30: "hsl(0, 0%, 70%)",
    neutral40: "hsl(0, 0%, 60%)",
    neutral50: "hsl(0, 0%, 50%)",
    neutral60: "hsl(0, 0%, 40%)",
    neutral70: "hsl(0, 0%, 30%)",
    neutral80: "hsl(0, 0%, 20%)",
    neutral90: "hsl(0, 0%, 10%)"
  }, oce = 4, O6 = 4, ice = 38, ace = O6 * 2, sce = {
    baseUnit: O6,
    controlHeight: ice,
    menuGutter: ace
  }, zS = {
    borderRadius: oce,
    colors: rce,
    spacing: sce
  }, lce = {
    "aria-live": "polite",
    backspaceRemovesValue: !0,
    blurInputOnSelect: AI(),
    captureMenuScroll: !AI(),
    classNames: {},
    closeMenuOnSelect: !0,
    closeMenuOnScroll: !1,
    components: {},
    controlShouldRenderValue: !0,
    escapeClearsValue: !1,
    filterOption: jle(),
    formatGroupLabel: Qle,
    getOptionLabel: Jle,
    getOptionValue: ece,
    isDisabled: !1,
    isLoading: !1,
    isMulti: !1,
    isRtl: !1,
    isSearchable: !0,
    isOptionDisabled: tce,
    loadingMessage: function() {
      return "Loading...";
    },
    maxMenuHeight: 300,
    minMenuHeight: 140,
    menuIsOpen: !1,
    menuPlacement: "bottom",
    menuPosition: "absolute",
    menuShouldBlockScroll: !1,
    menuShouldScrollIntoView: !ise(),
    noOptionsMessage: function() {
      return "No options";
    },
    openMenuOnFocus: !1,
    openMenuOnClick: !0,
    options: [],
    pageSize: 5,
    placeholder: "Select...",
    screenReaderStatus: function(t) {
      var n = t.count;
      return "".concat(n, " result").concat(n !== 1 ? "s" : "", " available");
    },
    styles: {},
    tabIndex: 0,
    tabSelectsValue: !0,
    unstyled: !1
  };
  function zI(e, t, n, r) {
    var o = P6(e, t, n), i = I6(e, t, n), a = N6(e, t), s = v0(e, t);
    return {
      type: "option",
      data: t,
      isDisabled: o,
      isSelected: i,
      label: a,
      value: s,
      index: r
    };
  }
  function Iv(e, t) {
    return e.options.map(function(n, r) {
      if ("options" in n) {
        var o = n.options.map(function(a, s) {
          return zI(e, a, t, s);
        }).filter(function(a) {
          return UI(e, a);
        });
        return o.length > 0 ? {
          type: "group",
          data: n,
          options: o,
          index: r
        } : void 0;
      }
      var i = zI(e, n, t, r);
      return UI(e, i) ? i : void 0;
    }).filter(lse);
  }
  function M6(e) {
    return e.reduce(function(t, n) {
      return n.type === "group" ? t.push.apply(t, uT(n.options.map(function(r) {
        return r.data;
      }))) : t.push(n.data), t;
    }, []);
  }
  function BI(e, t) {
    return e.reduce(function(n, r) {
      return r.type === "group" ? n.push.apply(n, uT(r.options.map(function(o) {
        return {
          data: o.data,
          id: "".concat(t, "-").concat(r.index, "-").concat(o.index)
        };
      }))) : n.push({
        data: r.data,
        id: "".concat(t, "-").concat(r.index)
      }), n;
    }, []);
  }
  function cce(e, t) {
    return M6(Iv(e, t));
  }
  function UI(e, t) {
    var n = e.inputValue, r = n === void 0 ? "" : n, o = t.data, i = t.isSelected, a = t.label, s = t.value;
    return (!j6(e) || !i) && $6(e, {
      label: a,
      value: s,
      data: o
    }, r);
  }
  function uce(e, t) {
    var n = e.focusedValue, r = e.selectValue, o = r.indexOf(n);
    if (o > -1) {
      var i = t.indexOf(n);
      if (i > -1)
        return n;
      if (o < t.length)
        return t[o];
    }
    return null;
  }
  function fce(e, t) {
    var n = e.focusedOption;
    return n && t.indexOf(n) > -1 ? n : t[0];
  }
  var BS = function(t, n) {
    var r, o = (r = t.find(function(i) {
      return i.data === n;
    })) === null || r === void 0 ? void 0 : r.id;
    return o || null;
  }, N6 = function(t, n) {
    return t.getOptionLabel(n);
  }, v0 = function(t, n) {
    return t.getOptionValue(n);
  };
  function P6(e, t, n) {
    return typeof e.isOptionDisabled == "function" ? e.isOptionDisabled(t, n) : !1;
  }
  function I6(e, t, n) {
    if (n.indexOf(t) > -1) return !0;
    if (typeof e.isOptionSelected == "function")
      return e.isOptionSelected(t, n);
    var r = v0(e, t);
    return n.some(function(o) {
      return v0(e, o) === r;
    });
  }
  function $6(e, t, n) {
    return e.filterOption ? e.filterOption(t, n) : !0;
  }
  var j6 = function(t) {
    var n = t.hideSelectedOptions, r = t.isMulti;
    return n === void 0 ? r : n;
  }, dce = 1, D6 = /* @__PURE__ */ (function(e) {
    qae(n, e);
    var t = Gae(n);
    function n(r) {
      var o;
      if (Vae(this, n), o = t.call(this, r), o.state = {
        ariaSelection: null,
        focusedOption: null,
        focusedOptionId: null,
        focusableOptionsWithIds: [],
        focusedValue: null,
        inputIsHidden: !1,
        isFocused: !1,
        selectValue: [],
        clearFocusValueOnUpdate: !1,
        prevWasFocused: !1,
        inputIsHiddenAfterUpdate: void 0,
        prevProps: void 0,
        instancePrefix: "",
        isAppleDevice: !1
      }, o.blockOptionHover = !1, o.isComposing = !1, o.commonProps = void 0, o.initialTouchX = 0, o.initialTouchY = 0, o.openAfterFocus = !1, o.scrollToFocusedOptionOnUpdate = !1, o.userIsDragging = void 0, o.controlRef = null, o.getControlRef = function(c) {
        o.controlRef = c;
      }, o.focusedOptionRef = null, o.getFocusedOptionRef = function(c) {
        o.focusedOptionRef = c;
      }, o.menuListRef = null, o.getMenuListRef = function(c) {
        o.menuListRef = c;
      }, o.inputRef = null, o.getInputRef = function(c) {
        o.inputRef = c;
      }, o.focus = o.focusInput, o.blur = o.blurInput, o.onChange = function(c, u) {
        var d = o.props, p = d.onChange, m = d.name;
        u.name = m, o.ariaOnChange(c, u), p(c, u);
      }, o.setValue = function(c, u, d) {
        var p = o.props, m = p.closeMenuOnSelect, g = p.isMulti, y = p.inputValue;
        o.onInputChange("", {
          action: "set-value",
          prevInputValue: y
        }), m && (o.setState({
          inputIsHiddenAfterUpdate: !g
        }), o.onMenuClose()), o.setState({
          clearFocusValueOnUpdate: !0
        }), o.onChange(c, {
          action: u,
          option: d
        });
      }, o.selectOption = function(c) {
        var u = o.props, d = u.blurInputOnSelect, p = u.isMulti, m = u.name, g = o.state.selectValue, y = p && o.isOptionSelected(c, g), b = o.isOptionDisabled(c, g);
        if (y) {
          var v = o.getOptionValue(c);
          o.setValue(g.filter(function(x) {
            return o.getOptionValue(x) !== v;
          }), "deselect-option", c);
        } else if (!b)
          p ? o.setValue([].concat(uT(g), [c]), "select-option", c) : o.setValue(c, "select-option");
        else {
          o.ariaOnChange(c, {
            action: "select-option",
            option: c,
            name: m
          });
          return;
        }
        d && o.blurInput();
      }, o.removeValue = function(c) {
        var u = o.props.isMulti, d = o.state.selectValue, p = o.getOptionValue(c), m = d.filter(function(y) {
          return o.getOptionValue(y) !== p;
        }), g = sy(u, m, m[0] || null);
        o.onChange(g, {
          action: "remove-value",
          removedValue: c
        }), o.focusInput();
      }, o.clearValue = function() {
        var c = o.state.selectValue;
        o.onChange(sy(o.props.isMulti, [], null), {
          action: "clear",
          removedValues: c
        });
      }, o.popValue = function() {
        var c = o.props.isMulti, u = o.state.selectValue, d = u[u.length - 1], p = u.slice(0, u.length - 1), m = sy(c, p, p[0] || null);
        d && o.onChange(m, {
          action: "pop-value",
          removedValue: d
        });
      }, o.getFocusedOptionId = function(c) {
        return BS(o.state.focusableOptionsWithIds, c);
      }, o.getFocusableOptionsWithIds = function() {
        return BI(Iv(o.props, o.state.selectValue), o.getElementId("option"));
      }, o.getValue = function() {
        return o.state.selectValue;
      }, o.cx = function() {
        for (var c = arguments.length, u = new Array(c), d = 0; d < c; d++)
          u[d] = arguments[d];
        return ese.apply(void 0, [o.props.classNamePrefix].concat(u));
      }, o.getOptionLabel = function(c) {
        return N6(o.props, c);
      }, o.getOptionValue = function(c) {
        return v0(o.props, c);
      }, o.getStyles = function(c, u) {
        var d = o.props.unstyled, p = nce[c](u, d);
        p.boxSizing = "border-box";
        var m = o.props.styles[c];
        return m ? m(p, u) : p;
      }, o.getClassNames = function(c, u) {
        var d, p;
        return (d = (p = o.props.classNames)[c]) === null || d === void 0 ? void 0 : d.call(p, u);
      }, o.getElementId = function(c) {
        return "".concat(o.state.instancePrefix, "-").concat(c);
      }, o.getComponents = function() {
        return Ele(o.props);
      }, o.buildCategorizedOptions = function() {
        return Iv(o.props, o.state.selectValue);
      }, o.getCategorizedOptions = function() {
        return o.props.menuIsOpen ? o.buildCategorizedOptions() : [];
      }, o.buildFocusableOptions = function() {
        return M6(o.buildCategorizedOptions());
      }, o.getFocusableOptions = function() {
        return o.props.menuIsOpen ? o.buildFocusableOptions() : [];
      }, o.ariaOnChange = function(c, u) {
        o.setState({
          ariaSelection: Xe({
            value: c
          }, u)
        });
      }, o.onMenuMouseDown = function(c) {
        c.button === 0 && (c.stopPropagation(), c.preventDefault(), o.focusInput());
      }, o.onMenuMouseMove = function(c) {
        o.blockOptionHover = !1;
      }, o.onControlMouseDown = function(c) {
        if (!c.defaultPrevented) {
          var u = o.props.openMenuOnClick;
          o.state.isFocused ? o.props.menuIsOpen ? c.target.tagName !== "INPUT" && c.target.tagName !== "TEXTAREA" && o.onMenuClose() : u && o.openMenu("first") : (u && (o.openAfterFocus = !0), o.focusInput()), c.target.tagName !== "INPUT" && c.target.tagName !== "TEXTAREA" && c.preventDefault();
        }
      }, o.onDropdownIndicatorMouseDown = function(c) {
        if (!(c && c.type === "mousedown" && c.button !== 0) && !o.props.isDisabled) {
          var u = o.props, d = u.isMulti, p = u.menuIsOpen;
          o.focusInput(), p ? (o.setState({
            inputIsHiddenAfterUpdate: !d
          }), o.onMenuClose()) : o.openMenu("first"), c.preventDefault();
        }
      }, o.onClearIndicatorMouseDown = function(c) {
        c && c.type === "mousedown" && c.button !== 0 || (o.clearValue(), c.preventDefault(), o.openAfterFocus = !1, c.type === "touchend" ? o.focusInput() : setTimeout(function() {
          return o.focusInput();
        }));
      }, o.onScroll = function(c) {
        typeof o.props.closeMenuOnScroll == "boolean" ? c.target instanceof HTMLElement && Fb(c.target) && o.props.onMenuClose() : typeof o.props.closeMenuOnScroll == "function" && o.props.closeMenuOnScroll(c) && o.props.onMenuClose();
      }, o.onCompositionStart = function() {
        o.isComposing = !0;
      }, o.onCompositionEnd = function() {
        o.isComposing = !1;
      }, o.onTouchStart = function(c) {
        var u = c.touches, d = u && u.item(0);
        d && (o.initialTouchX = d.clientX, o.initialTouchY = d.clientY, o.userIsDragging = !1);
      }, o.onTouchMove = function(c) {
        var u = c.touches, d = u && u.item(0);
        if (d) {
          var p = Math.abs(d.clientX - o.initialTouchX), m = Math.abs(d.clientY - o.initialTouchY), g = 5;
          o.userIsDragging = p > g || m > g;
        }
      }, o.onTouchEnd = function(c) {
        o.userIsDragging || (o.controlRef && !o.controlRef.contains(c.target) && o.menuListRef && !o.menuListRef.contains(c.target) && o.blurInput(), o.initialTouchX = 0, o.initialTouchY = 0);
      }, o.onControlTouchEnd = function(c) {
        o.userIsDragging || o.onControlMouseDown(c);
      }, o.onClearIndicatorTouchEnd = function(c) {
        o.userIsDragging || o.onClearIndicatorMouseDown(c);
      }, o.onDropdownIndicatorTouchEnd = function(c) {
        o.userIsDragging || o.onDropdownIndicatorMouseDown(c);
      }, o.handleInputChange = function(c) {
        var u = o.props.inputValue, d = c.currentTarget.value;
        o.setState({
          inputIsHiddenAfterUpdate: !1
        }), o.onInputChange(d, {
          action: "input-change",
          prevInputValue: u
        }), o.props.menuIsOpen || o.onMenuOpen();
      }, o.onInputFocus = function(c) {
        o.props.onFocus && o.props.onFocus(c), o.setState({
          inputIsHiddenAfterUpdate: !1,
          isFocused: !0
        }), (o.openAfterFocus || o.props.openMenuOnFocus) && o.openMenu("first"), o.openAfterFocus = !1;
      }, o.onInputBlur = function(c) {
        var u = o.props.inputValue;
        if (o.menuListRef && o.menuListRef.contains(document.activeElement)) {
          o.inputRef.focus();
          return;
        }
        o.props.onBlur && o.props.onBlur(c), o.onInputChange("", {
          action: "input-blur",
          prevInputValue: u
        }), o.onMenuClose(), o.setState({
          focusedValue: null,
          isFocused: !1
        });
      }, o.onOptionHover = function(c) {
        if (!(o.blockOptionHover || o.state.focusedOption === c)) {
          var u = o.getFocusableOptions(), d = u.indexOf(c);
          o.setState({
            focusedOption: c,
            focusedOptionId: d > -1 ? o.getFocusedOptionId(c) : null
          });
        }
      }, o.shouldHideSelectedOptions = function() {
        return j6(o.props);
      }, o.onValueInputFocus = function(c) {
        c.preventDefault(), c.stopPropagation(), o.focus();
      }, o.onKeyDown = function(c) {
        var u = o.props, d = u.isMulti, p = u.backspaceRemovesValue, m = u.escapeClearsValue, g = u.inputValue, y = u.isClearable, b = u.isDisabled, v = u.menuIsOpen, x = u.onKeyDown, E = u.tabSelectsValue, _ = u.openMenuOnFocus, C = o.state, k = C.focusedOption, A = C.focusedValue, O = C.selectValue;
        if (!b && !(typeof x == "function" && (x(c), c.defaultPrevented))) {
          switch (o.blockOptionHover = !0, c.key) {
            case "ArrowLeft":
              if (!d || g) return;
              o.focusValue("previous");
              break;
            case "ArrowRight":
              if (!d || g) return;
              o.focusValue("next");
              break;
            case "Delete":
            case "Backspace":
              if (g) return;
              if (A)
                o.removeValue(A);
              else {
                if (!p) return;
                d ? o.popValue() : y && o.clearValue();
              }
              break;
            case "Tab":
              if (o.isComposing || c.shiftKey || !v || !E || !k || // don't capture the event if the menu opens on focus and the focused
              // option is already selected; it breaks the flow of navigation
              _ && o.isOptionSelected(k, O))
                return;
              o.selectOption(k);
              break;
            case "Enter":
              if (c.keyCode === 229)
                break;
              if (v) {
                if (!k || o.isComposing) return;
                o.selectOption(k);
                break;
              }
              return;
            case "Escape":
              v ? (o.setState({
                inputIsHiddenAfterUpdate: !1
              }), o.onInputChange("", {
                action: "menu-close",
                prevInputValue: g
              }), o.onMenuClose()) : y && m && o.clearValue();
              break;
            case " ":
              if (g)
                return;
              if (!v) {
                o.openMenu("first");
                break;
              }
              if (!k) return;
              o.selectOption(k);
              break;
            case "ArrowUp":
              v ? o.focusOption("up") : o.openMenu("last");
              break;
            case "ArrowDown":
              v ? o.focusOption("down") : o.openMenu("first");
              break;
            case "PageUp":
              if (!v) return;
              o.focusOption("pageup");
              break;
            case "PageDown":
              if (!v) return;
              o.focusOption("pagedown");
              break;
            case "Home":
              if (!v) return;
              o.focusOption("first");
              break;
            case "End":
              if (!v) return;
              o.focusOption("last");
              break;
            default:
              return;
          }
          c.preventDefault();
        }
      }, o.state.instancePrefix = "react-select-" + (o.props.instanceId || ++dce), o.state.selectValue = kI(r.value), r.menuIsOpen && o.state.selectValue.length) {
        var i = o.getFocusableOptionsWithIds(), a = o.buildFocusableOptions(), s = a.indexOf(o.state.selectValue[0]);
        o.state.focusableOptionsWithIds = i, o.state.focusedOption = a[s], o.state.focusedOptionId = BS(i, a[s]);
      }
      return o;
    }
    return Hae(n, [{
      key: "componentDidMount",
      value: function() {
        this.startListeningComposition(), this.startListeningToTouch(), this.props.closeMenuOnScroll && document && document.addEventListener && document.addEventListener("scroll", this.onScroll, !0), this.props.autoFocus && this.focusInput(), this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef && TI(this.menuListRef, this.focusedOptionRef), Zle() && this.setState({
          isAppleDevice: !0
        });
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        var i = this.props, a = i.isDisabled, s = i.menuIsOpen, c = this.state.isFocused;
        // ensure focus is restored correctly when the control becomes enabled
        (c && !a && o.isDisabled || // ensure focus is on the Input when the menu opens
        c && s && !o.menuIsOpen) && this.focusInput(), c && a && !o.isDisabled ? this.setState({
          isFocused: !1
        }, this.onMenuClose) : !c && !a && o.isDisabled && this.inputRef === document.activeElement && this.setState({
          isFocused: !0
        }), this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate && (TI(this.menuListRef, this.focusedOptionRef), this.scrollToFocusedOptionOnUpdate = !1);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        this.stopListeningComposition(), this.stopListeningToTouch(), document.removeEventListener("scroll", this.onScroll, !0);
      }
      // ==============================
      // Consumer Handlers
      // ==============================
    }, {
      key: "onMenuOpen",
      value: function() {
        this.props.onMenuOpen();
      }
    }, {
      key: "onMenuClose",
      value: function() {
        this.onInputChange("", {
          action: "menu-close",
          prevInputValue: this.props.inputValue
        }), this.props.onMenuClose();
      }
    }, {
      key: "onInputChange",
      value: function(o, i) {
        this.props.onInputChange(o, i);
      }
      // ==============================
      // Methods
      // ==============================
    }, {
      key: "focusInput",
      value: function() {
        this.inputRef && this.inputRef.focus();
      }
    }, {
      key: "blurInput",
      value: function() {
        this.inputRef && this.inputRef.blur();
      }
      // aliased for consumers
    }, {
      key: "openMenu",
      value: function(o) {
        var i = this, a = this.state, s = a.selectValue, c = a.isFocused, u = this.buildFocusableOptions(), d = o === "first" ? 0 : u.length - 1;
        if (!this.props.isMulti) {
          var p = u.indexOf(s[0]);
          p > -1 && (d = p);
        }
        this.scrollToFocusedOptionOnUpdate = !(c && this.menuListRef), this.setState({
          inputIsHiddenAfterUpdate: !1,
          focusedValue: null,
          focusedOption: u[d],
          focusedOptionId: this.getFocusedOptionId(u[d])
        }, function() {
          return i.onMenuOpen();
        });
      }
    }, {
      key: "focusValue",
      value: function(o) {
        var i = this.state, a = i.selectValue, s = i.focusedValue;
        if (this.props.isMulti) {
          this.setState({
            focusedOption: null
          });
          var c = a.indexOf(s);
          s || (c = -1);
          var u = a.length - 1, d = -1;
          if (a.length) {
            switch (o) {
              case "previous":
                c === 0 ? d = 0 : c === -1 ? d = u : d = c - 1;
                break;
              case "next":
                c > -1 && c < u && (d = c + 1);
                break;
            }
            this.setState({
              inputIsHidden: d !== -1,
              focusedValue: a[d]
            });
          }
        }
      }
    }, {
      key: "focusOption",
      value: function() {
        var o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first", i = this.props.pageSize, a = this.state.focusedOption, s = this.getFocusableOptions();
        if (s.length) {
          var c = 0, u = s.indexOf(a);
          a || (u = -1), o === "up" ? c = u > 0 ? u - 1 : s.length - 1 : o === "down" ? c = (u + 1) % s.length : o === "pageup" ? (c = u - i, c < 0 && (c = 0)) : o === "pagedown" ? (c = u + i, c > s.length - 1 && (c = s.length - 1)) : o === "last" && (c = s.length - 1), this.scrollToFocusedOptionOnUpdate = !0, this.setState({
            focusedOption: s[c],
            focusedValue: null,
            focusedOptionId: this.getFocusedOptionId(s[c])
          });
        }
      }
    }, {
      key: "getTheme",
      value: (
        // ==============================
        // Getters
        // ==============================
        (function() {
          return this.props.theme ? typeof this.props.theme == "function" ? this.props.theme(zS) : Xe(Xe({}, zS), this.props.theme) : zS;
        })
      )
    }, {
      key: "getCommonProps",
      value: function() {
        var o = this.clearValue, i = this.cx, a = this.getStyles, s = this.getClassNames, c = this.getValue, u = this.selectOption, d = this.setValue, p = this.props, m = p.isMulti, g = p.isRtl, y = p.options, b = this.hasValue();
        return {
          clearValue: o,
          cx: i,
          getStyles: a,
          getClassNames: s,
          getValue: c,
          hasValue: b,
          isMulti: m,
          isRtl: g,
          options: y,
          selectOption: u,
          selectProps: p,
          setValue: d,
          theme: this.getTheme()
        };
      }
    }, {
      key: "hasValue",
      value: function() {
        var o = this.state.selectValue;
        return o.length > 0;
      }
    }, {
      key: "hasOptions",
      value: function() {
        return !!this.getFocusableOptions().length;
      }
    }, {
      key: "isClearable",
      value: function() {
        var o = this.props, i = o.isClearable, a = o.isMulti;
        return i === void 0 ? a : i;
      }
    }, {
      key: "isOptionDisabled",
      value: function(o, i) {
        return P6(this.props, o, i);
      }
    }, {
      key: "isOptionSelected",
      value: function(o, i) {
        return I6(this.props, o, i);
      }
    }, {
      key: "filterOption",
      value: function(o, i) {
        return $6(this.props, o, i);
      }
    }, {
      key: "formatOptionLabel",
      value: function(o, i) {
        if (typeof this.props.formatOptionLabel == "function") {
          var a = this.props.inputValue, s = this.state.selectValue;
          return this.props.formatOptionLabel(o, {
            context: i,
            inputValue: a,
            selectValue: s
          });
        } else
          return this.getOptionLabel(o);
      }
    }, {
      key: "formatGroupLabel",
      value: function(o) {
        return this.props.formatGroupLabel(o);
      }
      // ==============================
      // Mouse Handlers
      // ==============================
    }, {
      key: "startListeningComposition",
      value: (
        // ==============================
        // Composition Handlers
        // ==============================
        (function() {
          document && document.addEventListener && (document.addEventListener("compositionstart", this.onCompositionStart, !1), document.addEventListener("compositionend", this.onCompositionEnd, !1));
        })
      )
    }, {
      key: "stopListeningComposition",
      value: function() {
        document && document.removeEventListener && (document.removeEventListener("compositionstart", this.onCompositionStart), document.removeEventListener("compositionend", this.onCompositionEnd));
      }
    }, {
      key: "startListeningToTouch",
      value: (
        // ==============================
        // Touch Handlers
        // ==============================
        (function() {
          document && document.addEventListener && (document.addEventListener("touchstart", this.onTouchStart, !1), document.addEventListener("touchmove", this.onTouchMove, !1), document.addEventListener("touchend", this.onTouchEnd, !1));
        })
      )
    }, {
      key: "stopListeningToTouch",
      value: function() {
        document && document.removeEventListener && (document.removeEventListener("touchstart", this.onTouchStart), document.removeEventListener("touchmove", this.onTouchMove), document.removeEventListener("touchend", this.onTouchEnd));
      }
    }, {
      key: "renderInput",
      value: (
        // ==============================
        // Renderers
        // ==============================
        (function() {
          var o = this.props, i = o.isDisabled, a = o.isSearchable, s = o.inputId, c = o.inputValue, u = o.tabIndex, d = o.form, p = o.menuIsOpen, m = o.required, g = this.getComponents(), y = g.Input, b = this.state, v = b.inputIsHidden, x = b.ariaSelection, E = this.commonProps, _ = s || this.getElementId("input"), C = Xe(Xe(Xe({
            "aria-autocomplete": "list",
            "aria-expanded": p,
            "aria-haspopup": !0,
            "aria-errormessage": this.props["aria-errormessage"],
            "aria-invalid": this.props["aria-invalid"],
            "aria-label": this.props["aria-label"],
            "aria-labelledby": this.props["aria-labelledby"],
            "aria-required": m,
            role: "combobox",
            "aria-activedescendant": this.state.isAppleDevice ? void 0 : this.state.focusedOptionId || ""
          }, p && {
            "aria-controls": this.getElementId("listbox")
          }), !a && {
            "aria-readonly": !0
          }), this.hasValue() ? x?.action === "initial-input-focus" && {
            "aria-describedby": this.getElementId("live-region")
          } : {
            "aria-describedby": this.getElementId("placeholder")
          });
          return a ? /* @__PURE__ */ T.createElement(y, Ke({}, E, {
            autoCapitalize: "none",
            autoComplete: "off",
            autoCorrect: "off",
            id: _,
            innerRef: this.getInputRef,
            isDisabled: i,
            isHidden: v,
            onBlur: this.onInputBlur,
            onChange: this.handleInputChange,
            onFocus: this.onInputFocus,
            spellCheck: "false",
            tabIndex: u,
            form: d,
            type: "text",
            value: c
          }, C)) : /* @__PURE__ */ T.createElement(Fle, Ke({
            id: _,
            innerRef: this.getInputRef,
            onBlur: this.onInputBlur,
            onChange: g0,
            onFocus: this.onInputFocus,
            disabled: i,
            tabIndex: u,
            inputMode: "none",
            form: d,
            value: ""
          }, C));
        })
      )
    }, {
      key: "renderPlaceholderOrValue",
      value: function() {
        var o = this, i = this.getComponents(), a = i.MultiValue, s = i.MultiValueContainer, c = i.MultiValueLabel, u = i.MultiValueRemove, d = i.SingleValue, p = i.Placeholder, m = this.commonProps, g = this.props, y = g.controlShouldRenderValue, b = g.isDisabled, v = g.isMulti, x = g.inputValue, E = g.placeholder, _ = this.state, C = _.selectValue, k = _.focusedValue, A = _.isFocused;
        if (!this.hasValue() || !y)
          return x ? null : /* @__PURE__ */ T.createElement(p, Ke({}, m, {
            key: "placeholder",
            isDisabled: b,
            isFocused: A,
            innerProps: {
              id: this.getElementId("placeholder")
            }
          }), E);
        if (v)
          return C.map(function(P, I) {
            var $ = P === k, L = "".concat(o.getOptionLabel(P), "-").concat(o.getOptionValue(P));
            return /* @__PURE__ */ T.createElement(a, Ke({}, m, {
              components: {
                Container: s,
                Label: c,
                Remove: u
              },
              isFocused: $,
              isDisabled: b,
              key: L,
              index: I,
              removeProps: {
                onClick: function() {
                  return o.removeValue(P);
                },
                onTouchEnd: function() {
                  return o.removeValue(P);
                },
                onMouseDown: function(U) {
                  U.preventDefault();
                }
              },
              data: P
            }), o.formatOptionLabel(P, "value"));
          });
        if (x)
          return null;
        var O = C[0];
        return /* @__PURE__ */ T.createElement(d, Ke({}, m, {
          data: O,
          isDisabled: b
        }), this.formatOptionLabel(O, "value"));
      }
    }, {
      key: "renderClearIndicator",
      value: function() {
        var o = this.getComponents(), i = o.ClearIndicator, a = this.commonProps, s = this.props, c = s.isDisabled, u = s.isLoading, d = this.state.isFocused;
        if (!this.isClearable() || !i || c || !this.hasValue() || u)
          return null;
        var p = {
          onMouseDown: this.onClearIndicatorMouseDown,
          onTouchEnd: this.onClearIndicatorTouchEnd,
          "aria-hidden": "true"
        };
        return /* @__PURE__ */ T.createElement(i, Ke({}, a, {
          innerProps: p,
          isFocused: d
        }));
      }
    }, {
      key: "renderLoadingIndicator",
      value: function() {
        var o = this.getComponents(), i = o.LoadingIndicator, a = this.commonProps, s = this.props, c = s.isDisabled, u = s.isLoading, d = this.state.isFocused;
        if (!i || !u) return null;
        var p = {
          "aria-hidden": "true"
        };
        return /* @__PURE__ */ T.createElement(i, Ke({}, a, {
          innerProps: p,
          isDisabled: c,
          isFocused: d
        }));
      }
    }, {
      key: "renderIndicatorSeparator",
      value: function() {
        var o = this.getComponents(), i = o.DropdownIndicator, a = o.IndicatorSeparator;
        if (!i || !a) return null;
        var s = this.commonProps, c = this.props.isDisabled, u = this.state.isFocused;
        return /* @__PURE__ */ T.createElement(a, Ke({}, s, {
          isDisabled: c,
          isFocused: u
        }));
      }
    }, {
      key: "renderDropdownIndicator",
      value: function() {
        var o = this.getComponents(), i = o.DropdownIndicator;
        if (!i) return null;
        var a = this.commonProps, s = this.props.isDisabled, c = this.state.isFocused, u = {
          onMouseDown: this.onDropdownIndicatorMouseDown,
          onTouchEnd: this.onDropdownIndicatorTouchEnd,
          "aria-hidden": "true"
        };
        return /* @__PURE__ */ T.createElement(i, Ke({}, a, {
          innerProps: u,
          isDisabled: s,
          isFocused: c
        }));
      }
    }, {
      key: "renderMenu",
      value: function() {
        var o = this, i = this.getComponents(), a = i.Group, s = i.GroupHeading, c = i.Menu, u = i.MenuList, d = i.MenuPortal, p = i.LoadingMessage, m = i.NoOptionsMessage, g = i.Option, y = this.commonProps, b = this.state.focusedOption, v = this.props, x = v.captureMenuScroll, E = v.inputValue, _ = v.isLoading, C = v.loadingMessage, k = v.minMenuHeight, A = v.maxMenuHeight, O = v.menuIsOpen, P = v.menuPlacement, I = v.menuPosition, $ = v.menuPortalTarget, L = v.menuShouldBlockScroll, N = v.menuShouldScrollIntoView, U = v.noOptionsMessage, j = v.onMenuScrollToTop, V = v.onMenuScrollToBottom;
        if (!O) return null;
        var F = function(z, H) {
          var X = z.type, Q = z.data, ne = z.isDisabled, te = z.isSelected, se = z.label, ue = z.value, J = b === Q, ee = ne ? void 0 : function() {
            return o.onOptionHover(Q);
          }, ie = ne ? void 0 : function() {
            return o.selectOption(Q);
          }, le = "".concat(o.getElementId("option"), "-").concat(H), ge = {
            id: le,
            onClick: ie,
            onMouseMove: ee,
            onMouseOver: ee,
            tabIndex: -1,
            role: "option",
            "aria-selected": o.state.isAppleDevice ? void 0 : te
            // is not supported on Apple devices
          };
          return /* @__PURE__ */ T.createElement(g, Ke({}, y, {
            innerProps: ge,
            data: Q,
            isDisabled: ne,
            isSelected: te,
            key: le,
            label: se,
            type: X,
            value: ue,
            isFocused: J,
            innerRef: J ? o.getFocusedOptionRef : void 0
          }), o.formatOptionLabel(z.data, "menu"));
        }, K;
        if (this.hasOptions())
          K = this.getCategorizedOptions().map(function(G) {
            if (G.type === "group") {
              var z = G.data, H = G.options, X = G.index, Q = "".concat(o.getElementId("group"), "-").concat(X), ne = "".concat(Q, "-heading");
              return /* @__PURE__ */ T.createElement(a, Ke({}, y, {
                key: Q,
                data: z,
                options: H,
                Heading: s,
                headingProps: {
                  id: ne,
                  data: G.data
                },
                label: o.formatGroupLabel(G.data)
              }), G.options.map(function(te) {
                return F(te, "".concat(X, "-").concat(te.index));
              }));
            } else if (G.type === "option")
              return F(G, "".concat(G.index));
          });
        else if (_) {
          var W = C({
            inputValue: E
          });
          if (W === null) return null;
          K = /* @__PURE__ */ T.createElement(p, y, W);
        } else {
          var Y = U({
            inputValue: E
          });
          if (Y === null) return null;
          K = /* @__PURE__ */ T.createElement(m, y, Y);
        }
        var B = {
          minMenuHeight: k,
          maxMenuHeight: A,
          menuPlacement: P,
          menuPosition: I,
          menuShouldScrollIntoView: N
        }, D = /* @__PURE__ */ T.createElement(gse, Ke({}, y, B), function(G) {
          var z = G.ref, H = G.placerProps, X = H.placement, Q = H.maxHeight;
          return /* @__PURE__ */ T.createElement(c, Ke({}, y, B, {
            innerRef: z,
            innerProps: {
              onMouseDown: o.onMenuMouseDown,
              onMouseMove: o.onMenuMouseMove
            },
            isLoading: _,
            placement: X
          }), /* @__PURE__ */ T.createElement(Hle, {
            captureEnabled: x,
            onTopArrive: j,
            onBottomArrive: V,
            lockEnabled: L
          }, function(ne) {
            return /* @__PURE__ */ T.createElement(u, Ke({}, y, {
              innerRef: function(se) {
                o.getMenuListRef(se), ne(se);
              },
              innerProps: {
                role: "listbox",
                "aria-multiselectable": y.isMulti,
                id: o.getElementId("listbox")
              },
              isLoading: _,
              maxHeight: Q,
              focusedOption: b
            }), K);
          }));
        });
        return $ || I === "fixed" ? /* @__PURE__ */ T.createElement(d, Ke({}, y, {
          appendTo: $,
          controlElement: this.controlRef,
          menuPlacement: P,
          menuPosition: I
        }), D) : D;
      }
    }, {
      key: "renderFormField",
      value: function() {
        var o = this, i = this.props, a = i.delimiter, s = i.isDisabled, c = i.isMulti, u = i.name, d = i.required, p = this.state.selectValue;
        if (d && !this.hasValue() && !s)
          return /* @__PURE__ */ T.createElement(Gle, {
            name: u,
            onFocus: this.onValueInputFocus
          });
        if (!(!u || s))
          if (c)
            if (a) {
              var m = p.map(function(b) {
                return o.getOptionValue(b);
              }).join(a);
              return /* @__PURE__ */ T.createElement("input", {
                name: u,
                type: "hidden",
                value: m
              });
            } else {
              var g = p.length > 0 ? p.map(function(b, v) {
                return /* @__PURE__ */ T.createElement("input", {
                  key: "i-".concat(v),
                  name: u,
                  type: "hidden",
                  value: o.getOptionValue(b)
                });
              }) : /* @__PURE__ */ T.createElement("input", {
                name: u,
                type: "hidden",
                value: ""
              });
              return /* @__PURE__ */ T.createElement("div", null, g);
            }
          else {
            var y = p[0] ? this.getOptionValue(p[0]) : "";
            return /* @__PURE__ */ T.createElement("input", {
              name: u,
              type: "hidden",
              value: y
            });
          }
      }
    }, {
      key: "renderLiveRegion",
      value: function() {
        var o = this.commonProps, i = this.state, a = i.ariaSelection, s = i.focusedOption, c = i.focusedValue, u = i.isFocused, d = i.selectValue, p = this.getFocusableOptions();
        return /* @__PURE__ */ T.createElement(Nle, Ke({}, o, {
          id: this.getElementId("live-region"),
          ariaSelection: a,
          focusedOption: s,
          focusedValue: c,
          isFocused: u,
          selectValue: d,
          focusableOptions: p,
          isAppleDevice: this.state.isAppleDevice
        }));
      }
    }, {
      key: "render",
      value: function() {
        var o = this.getComponents(), i = o.Control, a = o.IndicatorsContainer, s = o.SelectContainer, c = o.ValueContainer, u = this.props, d = u.className, p = u.id, m = u.isDisabled, g = u.menuIsOpen, y = this.state.isFocused, b = this.commonProps = this.getCommonProps();
        return /* @__PURE__ */ T.createElement(s, Ke({}, b, {
          className: d,
          innerProps: {
            id: p,
            onKeyDown: this.onKeyDown
          },
          isDisabled: m,
          isFocused: y
        }), this.renderLiveRegion(), /* @__PURE__ */ T.createElement(i, Ke({}, b, {
          innerRef: this.getControlRef,
          innerProps: {
            onMouseDown: this.onControlMouseDown,
            onTouchEnd: this.onControlTouchEnd
          },
          isDisabled: m,
          isFocused: y,
          menuIsOpen: g
        }), /* @__PURE__ */ T.createElement(c, Ke({}, b, {
          isDisabled: m
        }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ T.createElement(a, Ke({}, b, {
          isDisabled: m
        }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function(o, i) {
        var a = i.prevProps, s = i.clearFocusValueOnUpdate, c = i.inputIsHiddenAfterUpdate, u = i.ariaSelection, d = i.isFocused, p = i.prevWasFocused, m = i.instancePrefix, g = o.options, y = o.value, b = o.menuIsOpen, v = o.inputValue, x = o.isMulti, E = kI(y), _ = {};
        if (a && (y !== a.value || g !== a.options || b !== a.menuIsOpen || v !== a.inputValue)) {
          var C = b ? cce(o, E) : [], k = b ? BI(Iv(o, E), "".concat(m, "-option")) : [], A = s ? uce(i, E) : null, O = fce(i, C), P = BS(k, O);
          _ = {
            selectValue: E,
            focusedOption: O,
            focusedOptionId: P,
            focusableOptionsWithIds: k,
            focusedValue: A,
            clearFocusValueOnUpdate: !1
          };
        }
        var I = c != null && o !== a ? {
          inputIsHidden: c,
          inputIsHiddenAfterUpdate: void 0
        } : {}, $ = u, L = d && p;
        return d && !L && ($ = {
          value: sy(x, E, E[0] || null),
          options: E,
          action: "initial-input-focus"
        }, L = !p), u?.action === "initial-input-focus" && ($ = null), Xe(Xe(Xe({}, _), I), {}, {
          prevProps: o,
          ariaSelection: $,
          prevWasFocused: L
        });
      }
    }]), n;
  })(T.Component);
  D6.defaultProps = lce;
  var pce = /* @__PURE__ */ T.forwardRef(function(e, t) {
    var n = Uae(e);
    return /* @__PURE__ */ T.createElement(D6, Ke({
      ref: t
    }, n));
  }), hce = pce;
  const mce = ({
    options: e,
    items_per_page: t,
    className: n,
    defaultValue: r,
    onChange: o
  }) => {
    const [i, a] = T.useState(""), [s, c] = T.useState(0), u = (g) => {
      a(g.toLowerCase()), c(0);
    }, d = e.filter((g) => g.label.toLowerCase().includes(i) || g.value.toLowerCase().includes(i));
    var p;
    t !== void 0 ? p = d.slice(
      s * t,
      (s + 1) * t
    ) : p = d;
    const m = {
      control: (g) => ({
        ...g,
        minHeight: void 0
      })
    };
    return /* @__PURE__ */ S.jsx(
      hce,
      {
        options: p,
        onInputChange: u,
        onChange: o,
        inputValue: i,
        isSearchable: !0,
        placeholder: "Select an option...",
        className: n,
        unstyled: !0,
        styles: m,
        classNamePrefix: "styled-select",
        defaultValue: r,
        value: r
      }
    );
  }, gce = (e) => typeof e == "boolean" || e instanceof Boolean, yce = (e) => typeof e == "number" || e instanceof Number, vce = (e) => typeof e == "bigint" || e instanceof BigInt, F6 = (e) => !!e && e instanceof Date, bce = (e) => typeof e == "string" || e instanceof String, xce = (e) => Array.isArray(e), L6 = (e) => typeof e == "object" && e !== null, z6 = (e) => !!e && e instanceof Object && typeof e == "function";
  function b0(e, t) {
    return t === void 0 && (t = !1), !e || t ? `"${e}"` : e;
  }
  function wce(e, t, n) {
    return n ? JSON.stringify(e) : t ? `"${e}"` : e;
  }
  function B6(e) {
    let {
      field: t,
      value: n,
      data: r,
      lastElement: o,
      openBracket: i,
      closeBracket: a,
      level: s,
      style: c,
      shouldExpandNode: u,
      clickToExpandNode: d,
      outerRef: p,
      beforeExpandChange: m
    } = e;
    const g = T.useRef(!1), [y, b] = T.useState(() => u(s, n, t)), v = T.useRef(null);
    T.useEffect(() => {
      g.current ? b(u(s, n, t)) : g.current = !0;
    }, [u]);
    const x = T.useId();
    if (r.length === 0)
      return Sce({
        field: t,
        openBracket: i,
        closeBracket: a,
        lastElement: o,
        style: c
      });
    const E = y ? c.collapseIcon : c.expandIcon, _ = y ? c.ariaLables.collapseJson : c.ariaLables.expandJson, C = s + 1, k = r.length - 1, A = (I) => {
      y !== I && (!m || m({
        level: s,
        value: n,
        field: t,
        newExpandValue: I
      })) && b(I);
    }, O = (I) => {
      if (I.key === "ArrowRight" || I.key === "ArrowLeft")
        I.preventDefault(), A(I.key === "ArrowRight");
      else if (I.key === "ArrowUp" || I.key === "ArrowDown") {
        I.preventDefault();
        const $ = I.key === "ArrowUp" ? -1 : 1;
        if (!p.current) return;
        const L = p.current.querySelectorAll("[role=button]");
        let N = -1;
        for (let j = 0; j < L.length; j++)
          if (L[j].tabIndex === 0) {
            N = j;
            break;
          }
        if (N < 0)
          return;
        const U = (N + $ + L.length) % L.length;
        L[N].tabIndex = -1, L[U].tabIndex = 0, L[U].focus();
      }
    }, P = () => {
      var I;
      A(!y);
      const $ = v.current;
      if (!$) return;
      const L = (I = p.current) === null || I === void 0 ? void 0 : I.querySelector('[role=button][tabindex="0"]');
      L && (L.tabIndex = -1), $.tabIndex = 0, $.focus();
    };
    return /* @__PURE__ */ T.createElement("div", {
      className: c.basicChildStyle,
      role: "treeitem",
      "aria-expanded": y,
      "aria-selected": void 0
    }, /* @__PURE__ */ T.createElement("span", {
      className: E,
      onClick: P,
      onKeyDown: O,
      role: "button",
      "aria-label": _,
      "aria-expanded": y,
      "aria-controls": y ? x : void 0,
      ref: v,
      tabIndex: s === 0 ? 0 : -1
    }), (t || t === "") && (d ? /* @__PURE__ */ T.createElement("span", {
      className: c.clickableLabel,
      onClick: P,
      onKeyDown: O
    }, b0(t, c.quotesForFieldNames), ":") : /* @__PURE__ */ T.createElement("span", {
      className: c.label
    }, b0(t, c.quotesForFieldNames), ":")), /* @__PURE__ */ T.createElement("span", {
      className: c.punctuation
    }, i), y ? /* @__PURE__ */ T.createElement("ul", {
      id: x,
      role: "group",
      className: c.childFieldsContainer
    }, r.map((I, $) => /* @__PURE__ */ T.createElement(XE, {
      key: I[0] || $,
      field: I[0],
      value: I[1],
      style: c,
      lastElement: $ === k,
      level: C,
      shouldExpandNode: u,
      clickToExpandNode: d,
      beforeExpandChange: m,
      outerRef: p
    }))) : /* @__PURE__ */ T.createElement("span", {
      className: c.collapsedContent,
      onClick: P,
      onKeyDown: O
    }), /* @__PURE__ */ T.createElement("span", {
      className: c.punctuation
    }, a), !o && /* @__PURE__ */ T.createElement("span", {
      className: c.punctuation
    }, ","));
  }
  function Sce(e) {
    let {
      field: t,
      openBracket: n,
      closeBracket: r,
      lastElement: o,
      style: i
    } = e;
    return /* @__PURE__ */ T.createElement("div", {
      className: i.basicChildStyle,
      role: "treeitem",
      "aria-selected": void 0
    }, (t || t === "") && /* @__PURE__ */ T.createElement("span", {
      className: i.label
    }, b0(t, i.quotesForFieldNames), ":"), /* @__PURE__ */ T.createElement("span", {
      className: i.punctuation
    }, n), /* @__PURE__ */ T.createElement("span", {
      className: i.punctuation
    }, r), !o && /* @__PURE__ */ T.createElement("span", {
      className: i.punctuation
    }, ","));
  }
  function _ce(e) {
    let {
      field: t,
      value: n,
      style: r,
      lastElement: o,
      shouldExpandNode: i,
      clickToExpandNode: a,
      level: s,
      outerRef: c,
      beforeExpandChange: u
    } = e;
    return B6({
      field: t,
      value: n,
      lastElement: o || !1,
      level: s,
      openBracket: "{",
      closeBracket: "}",
      style: r,
      shouldExpandNode: i,
      clickToExpandNode: a,
      data: Object.keys(n).map((d) => [d, n[d]]),
      outerRef: c,
      beforeExpandChange: u
    });
  }
  function Ece(e) {
    let {
      field: t,
      value: n,
      style: r,
      lastElement: o,
      level: i,
      shouldExpandNode: a,
      clickToExpandNode: s,
      outerRef: c,
      beforeExpandChange: u
    } = e;
    return B6({
      field: t,
      value: n,
      lastElement: o || !1,
      level: i,
      openBracket: "[",
      closeBracket: "]",
      style: r,
      shouldExpandNode: a,
      clickToExpandNode: s,
      data: n.map((d) => [void 0, d]),
      outerRef: c,
      beforeExpandChange: u
    });
  }
  function Cce(e) {
    let {
      field: t,
      value: n,
      style: r,
      lastElement: o
    } = e, i, a = r.otherValue;
    return n === null ? (i = "null", a = r.nullValue) : n === void 0 ? (i = "undefined", a = r.undefinedValue) : bce(n) ? (i = wce(n, !r.noQuotesForStringValues, r.stringifyStringValues), a = r.stringValue) : gce(n) ? (i = n ? "true" : "false", a = r.booleanValue) : yce(n) ? (i = n.toString(), a = r.numberValue) : vce(n) ? (i = `${n.toString()}n`, a = r.numberValue) : F6(n) ? i = n.toISOString() : z6(n) ? i = "function() { }" : i = n.toString(), /* @__PURE__ */ T.createElement("div", {
      className: r.basicChildStyle,
      role: "treeitem",
      "aria-selected": void 0
    }, (t || t === "") && /* @__PURE__ */ T.createElement("span", {
      className: r.label
    }, b0(t, r.quotesForFieldNames), ":"), /* @__PURE__ */ T.createElement("span", {
      className: a
    }, i), !o && /* @__PURE__ */ T.createElement("span", {
      className: r.punctuation
    }, ","));
  }
  function XE(e) {
    const t = e.value;
    return xce(t) ? /* @__PURE__ */ T.createElement(Ece, Object.assign({}, e)) : L6(t) && !F6(t) && !z6(t) ? /* @__PURE__ */ T.createElement(_ce, Object.assign({}, e)) : /* @__PURE__ */ T.createElement(Cce, Object.assign({}, e));
  }
  var Wt = { "container-light": "_2IvMF _GzYRV", "basic-element-style": "_2bkNM", "child-fields-container": "_1BXBN", "label-light": "_1MGIk", "clickable-label-light": "_2YKJg _1MGIk _1MFti", "punctuation-light": "_3uHL6 _3eOF8", "value-null-light": "_2T6PJ", "value-undefined-light": "_1Gho6", "value-string-light": "_vGjyY", "value-number-light": "_1bQdo", "value-boolean-light": "_3zQKs", "value-other-light": "_1xvuR", "collapse-icon-light": "_oLqym _f10Tu _1MFti _1LId0", "expand-icon-light": "_2AXVT _f10Tu _1MFti _1UmXx", "collapsed-content-light": "_2KJWg _1pNG9 _1MFti", "container-dark": "_11RoI _GzYRV", "expand-icon-dark": "_17H2C _f10Tu _1MFti _1UmXx", "collapse-icon-dark": "_3QHg2 _f10Tu _1MFti _1LId0", "collapsed-content-dark": "_3fDAz _1pNG9 _1MFti", "label-dark": "_2bSDX", "clickable-label-dark": "_1RQEj _2bSDX _1MFti", "punctuation-dark": "_gsbQL _3eOF8", "value-null-dark": "_LaAZe", "value-undefined-dark": "_GTKgm", "value-string-dark": "_Chy1W", "value-number-dark": "_2bveF", "value-boolean-dark": "_2vRm-", "value-other-dark": "_1prJR" };
  const U6 = {
    collapseJson: "collapse JSON",
    expandJson: "expand JSON"
  }, US = {
    container: Wt["container-light"],
    basicChildStyle: Wt["basic-element-style"],
    childFieldsContainer: Wt["child-fields-container"],
    label: Wt["label-light"],
    clickableLabel: Wt["clickable-label-light"],
    nullValue: Wt["value-null-light"],
    undefinedValue: Wt["value-undefined-light"],
    stringValue: Wt["value-string-light"],
    booleanValue: Wt["value-boolean-light"],
    numberValue: Wt["value-number-light"],
    otherValue: Wt["value-other-light"],
    punctuation: Wt["punctuation-light"],
    collapseIcon: Wt["collapse-icon-light"],
    expandIcon: Wt["expand-icon-light"],
    collapsedContent: Wt["collapsed-content-light"],
    noQuotesForStringValues: !1,
    quotesForFieldNames: !1,
    ariaLables: U6,
    stringifyStringValues: !1
  }, kce = {
    container: Wt["container-dark"],
    basicChildStyle: Wt["basic-element-style"],
    childFieldsContainer: Wt["child-fields-container"],
    label: Wt["label-dark"],
    clickableLabel: Wt["clickable-label-dark"],
    nullValue: Wt["value-null-dark"],
    undefinedValue: Wt["value-undefined-dark"],
    stringValue: Wt["value-string-dark"],
    booleanValue: Wt["value-boolean-dark"],
    numberValue: Wt["value-number-dark"],
    otherValue: Wt["value-other-dark"],
    punctuation: Wt["punctuation-dark"],
    collapseIcon: Wt["collapse-icon-dark"],
    expandIcon: Wt["expand-icon-dark"],
    collapsedContent: Wt["collapsed-content-dark"],
    noQuotesForStringValues: !1,
    quotesForFieldNames: !1,
    ariaLables: U6,
    stringifyStringValues: !1
  }, Tce = () => !0, Ace = (e) => e < 1, Rce = (e) => {
    let {
      data: t,
      style: n = US,
      shouldExpandNode: r = Tce,
      clickToExpandNode: o = !1,
      beforeExpandChange: i,
      compactTopLevel: a,
      ...s
    } = e;
    const c = T.useRef(null);
    return /* @__PURE__ */ T.createElement("div", Object.assign({
      "aria-label": "JSON view"
    }, s, {
      className: n.container,
      ref: c,
      role: "tree"
    }), a && L6(t) ? Object.entries(t).map((u) => {
      let [d, p] = u;
      return /* @__PURE__ */ T.createElement(XE, {
        key: d,
        field: d,
        value: p,
        style: {
          ...US,
          ...n
        },
        lastElement: !0,
        level: 1,
        shouldExpandNode: r,
        clickToExpandNode: o,
        beforeExpandChange: i,
        outerRef: c
      });
    }) : /* @__PURE__ */ T.createElement(XE, {
      value: t,
      style: {
        ...US,
        ...n
      },
      lastElement: !0,
      level: 0,
      shouldExpandNode: r,
      clickToExpandNode: o,
      outerRef: c,
      beforeExpandChange: i
    }));
  };
  function Oce(e) {
    for (const t in e)
      if (Object.hasOwn(e, t))
        return !1;
    return !0;
  }
  function Mce(e) {
    if (e == null || typeof e != "object")
      return !1;
    const t = Object.getPrototypeOf(e);
    return t !== null && t !== Object.prototype ? !1 : Oce(e);
  }
  const Nce = ({
    data: e,
    className: t = "json-display"
  }) => /* @__PURE__ */ S.jsx("div", { className: t, children: /* @__PURE__ */ S.jsx(
    Rce,
    {
      data: Mce(e) ? "" : e,
      style: kce,
      shouldExpandNode: Ace
    }
  ) });
  function Pce(e, t, n = {}) {
    const {
      maxFontSize: r = 100,
      // default maximum font size
      minFontSize: o = 6,
      // default minimum font size
      decrementFactor: i = 0.9
      // font size decrement step
    } = n;
    if (!e || !t)
      return;
    if (i >= 1 || i <= 0)
      throw new Error("decrementFactor must be between 0 and 1");
    const a = e.getBoundingClientRect(), s = a.width, c = a.height;
    let u = r;
    t.style.whiteSpace = "nowrap", t.style.display = "inline-block", t.style.fontSize = u + "px";
    let d = t.getBoundingClientRect();
    for (; (d.width > s || d.height > c) && u > o; )
      u *= i, t.style.fontSize = u + "px", d = t.getBoundingClientRect();
  }
  function Ice(e = {
    n: 0,
    elapsed: 0,
    ascii: !1,
    unit: "it",
    unit_scale: !1,
    unit_divisor: 1e3
  }) {
    let t = e.total ?? null;
    const {
      n = 0,
      unit_scale: r = !1,
      elapsed: o = 0,
      // ascii,
      unit: i = "it",
      unit_divisor: a = 1e3,
      // ncols = undefined,
      prefix: s = "",
      rate: c = void 0,
      // bar_format = undefined,
      postfix: u = null,
      initial: d = 0
      // colour = undefined,
    } = e;
    t !== null && n >= t + 0.5 && (t = null);
    let p = n, m = t, g = c;
    r && r !== !0 && r !== 1 && (t !== null && (m = t * r), p = n * r, c !== void 0 && (g = c * r));
    const y = VI(o);
    g === void 0 && o > 0 && (g = (p - d) / o);
    const b = g ? 1 / g : void 0, [v, x] = g ? ly(g, a) : [void 0, ""], [E, _] = b ? ly(b, 1e3) : [void 0, ""], C = (v || "?") + `${x}${i}/s`, k = E ? `${E}${_}s/` + i : "?", A = b && b > 1 ? k : C, O = r ? ly(p, a).join("") : p.toString(), P = r && m !== null ? ly(m, a).join("") : m?.toString() ?? "?", I = g && m !== null ? (m - p) / g : 0, $ = g ? VI(I) : "?", L = s ? `${s}: ` : "";
    if (t !== null) {
      const N = p / t * 100, U = ` ${O}/${P} [${y} < ${$}, ${A}${u ?? ""}]`;
      return `${L}${N.toFixed(0)}%${U}`;
    }
    return `${L}${O}${i} [${y}, ${A}${u ?? ""}]`;
  }
  function VI(e) {
    const t = Math.floor(e / 60), n = Math.floor(e % 60);
    return `${t}:${n.toString().padStart(2, "0")}`;
  }
  function ly(e, t) {
    const n = ["", "K", "M", "G", "T"];
    let r = 0;
    for (; e >= t && r < n.length - 1; )
      e /= t, r++;
    return [e.toFixed(2), n[r]];
  }
  const $ce = ({ state: e, className: t = "reacttqdm", ...n }) => {
    const r = T.useRef(null), o = T.useRef(null);
    T.useEffect(() => {
      const a = () => {
        !r.current || !o.current || Pce(r.current, o.current, {
          maxFontSize: 12,
          decrementFactor: 0.9
        });
      };
      return a(), window.addEventListener("resize", a), () => {
        window.removeEventListener("resize", a);
      };
    }, [e]);
    const i = e.total ? (e.n ?? 0) / e.total * 100 : 0;
    return /* @__PURE__ */ S.jsx("div", { ref: r, className: t, ...n, children: /* @__PURE__ */ S.jsxs(
      "div",
      {
        style: {
          position: "relative",
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center"
        },
        children: [
          /* @__PURE__ */ S.jsx(
            "div",
            {
              className: t + "-bar",
              style: {
                position: "absolute",
                width: "100%",
                height: "100%",
                // Adjust height if needed
                overflow: "hidden"
              },
              children: /* @__PURE__ */ S.jsx(
                "div",
                {
                  className: t + "-progress",
                  style: {
                    width: `${i}%`,
                    height: "100%"
                  }
                }
              )
            }
          ),
          /* @__PURE__ */ S.jsx("div", { className: t + "-text", ref: o, children: Ice(e) })
        ]
      }
    ) });
  };
  var cy = {};
  var HI;
  function jce() {
    if (HI) return cy;
    HI = 1;
    var e = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, t = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/, n = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, r = /\\([\u000b\u0020-\u00ff])/g, o = /([\\"])/g, i = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
    cy.format = a, cy.parse = s;
    function a(p) {
      if (!p || typeof p != "object")
        throw new TypeError("argument obj is required");
      var m = p.parameters, g = p.type;
      if (!g || !i.test(g))
        throw new TypeError("invalid type");
      var y = g;
      if (m && typeof m == "object")
        for (var b, v = Object.keys(m).sort(), x = 0; x < v.length; x++) {
          if (b = v[x], !n.test(b))
            throw new TypeError("invalid parameter name");
          y += "; " + b + "=" + u(m[b]);
        }
      return y;
    }
    function s(p) {
      if (!p)
        throw new TypeError("argument string is required");
      var m = typeof p == "object" ? c(p) : p;
      if (typeof m != "string")
        throw new TypeError("argument string is required to be a string");
      var g = m.indexOf(";"), y = g !== -1 ? m.slice(0, g).trim() : m.trim();
      if (!i.test(y))
        throw new TypeError("invalid media type");
      var b = new d(y.toLowerCase());
      if (g !== -1) {
        var v, x, E;
        for (e.lastIndex = g; x = e.exec(m); ) {
          if (x.index !== g)
            throw new TypeError("invalid parameter format");
          g += x[0].length, v = x[1].toLowerCase(), E = x[2], E.charCodeAt(0) === 34 && (E = E.slice(1, -1), E.indexOf("\\") !== -1 && (E = E.replace(r, "$1"))), b.parameters[v] = E;
        }
        if (g !== m.length)
          throw new TypeError("invalid parameter format");
      }
      return b;
    }
    function c(p) {
      var m;
      if (typeof p.getHeader == "function" ? m = p.getHeader("content-type") : typeof p.headers == "object" && (m = p.headers && p.headers["content-type"]), typeof m != "string")
        throw new TypeError("content-type header is missing from object");
      return m;
    }
    function u(p) {
      var m = String(p);
      if (n.test(m))
        return m;
      if (m.length > 0 && !t.test(m))
        throw new TypeError("invalid parameter value");
      return '"' + m.replace(o, "\\$1") + '"';
    }
    function d(p) {
      this.parameters = /* @__PURE__ */ Object.create(null), this.type = p;
    }
    return cy;
  }
  var Dce = jce(), Uu = /* @__PURE__ */ new Map(), V6 = function(t) {
    return t.cloneNode(!0);
  }, qI = function() {
    return window.location.protocol === "file:";
  }, H6 = function(t, n, r) {
    var o = new XMLHttpRequest();
    o.onreadystatechange = function() {
      try {
        if (!/\.svg/i.test(t) && o.readyState === 2) {
          var i = o.getResponseHeader("Content-Type");
          if (!i)
            throw new Error("Content type not found");
          var a = Dce.parse(i).type;
          if (!(a === "image/svg+xml" || a === "text/plain"))
            throw new Error("Invalid content type: ".concat(a));
        }
        if (o.readyState === 4) {
          if (o.status === 404 || o.responseXML === null)
            throw new Error(qI() ? "Note: SVG injection ajax calls do not work locally without adjusting security settings in your browser. Or consider using a local webserver." : "Unable to load SVG file: " + t);
          if (o.status === 200 || qI() && o.status === 0)
            r(null, o);
          else
            throw new Error("There was a problem injecting the SVG: " + o.status + " " + o.statusText);
        }
      } catch (s) {
        if (o.abort(), s instanceof Error)
          r(s, o);
        else
          throw s;
      }
    }, o.open("GET", t), o.withCredentials = n, o.overrideMimeType && o.overrideMimeType("text/xml"), o.send();
  }, Hs = {}, WI = function(t, n) {
    Hs[t] = Hs[t] || [], Hs[t].push(n);
  }, Fce = function(t) {
    for (var n = function(a, s) {
      setTimeout(function() {
        if (Array.isArray(Hs[t])) {
          var c = Uu.get(t), u = Hs[t][a];
          c instanceof SVGSVGElement && u(null, V6(c)), c instanceof Error && u(c), a === Hs[t].length - 1 && delete Hs[t];
        }
      }, 0);
    }, r = 0, o = Hs[t].length; r < o; r++)
      n(r);
  }, Lce = function(t, n, r) {
    if (Uu.has(t)) {
      var o = Uu.get(t);
      if (o === void 0) {
        WI(t, r);
        return;
      }
      if (o instanceof SVGSVGElement) {
        r(null, V6(o));
        return;
      }
    }
    Uu.set(t, void 0), WI(t, r), H6(t, n, function(i, a) {
      var s;
      i ? Uu.set(t, i) : ((s = a.responseXML) === null || s === void 0 ? void 0 : s.documentElement) instanceof SVGSVGElement && Uu.set(t, a.responseXML.documentElement), Fce(t);
    });
  }, zce = function(t, n, r) {
    H6(t, n, function(o, i) {
      var a;
      o ? r(o) : ((a = i.responseXML) === null || a === void 0 ? void 0 : a.documentElement) instanceof SVGSVGElement && r(null, i.responseXML.documentElement);
    });
  }, Bce = 0, Uce = function() {
    return ++Bce;
  }, yi = [], GI = {}, Vce = "http://www.w3.org/2000/svg", VS = "http://www.w3.org/1999/xlink", KI = function(t, n, r, o, i, a, s) {
    var c = t.getAttribute("data-src") || t.getAttribute("src");
    if (!c) {
      s(new Error("Invalid data-src or src attribute"));
      return;
    }
    if (yi.indexOf(t) !== -1) {
      yi.splice(yi.indexOf(t), 1), t = null;
      return;
    }
    yi.push(t), t.setAttribute("src", "");
    var u = o ? Lce : zce;
    u(c, i, function(d, p) {
      if (!p) {
        yi.splice(yi.indexOf(t), 1), t = null, s(d);
        return;
      }
      var m = t.getAttribute("id");
      m && p.setAttribute("id", m);
      var g = t.getAttribute("title");
      g && p.setAttribute("title", g);
      var y = t.getAttribute("width");
      y && p.setAttribute("width", y);
      var b = t.getAttribute("height");
      b && p.setAttribute("height", b);
      var v = Array.from(new Set(Tv(Tv(Tv([], (p.getAttribute("class") || "").split(" "), !0), ["injected-svg"], !1), (t.getAttribute("class") || "").split(" "), !0))).join(" ").trim();
      p.setAttribute("class", v);
      var x = t.getAttribute("style");
      x && p.setAttribute("style", x), p.setAttribute("data-src", c);
      var E = [].filter.call(t.attributes, function(W) {
        return /^data-\w[\w-]*$/.test(W.name);
      });
      if (Array.prototype.forEach.call(E, function(W) {
        W.name && W.value && p.setAttribute(W.name, W.value);
      }), r) {
        var _ = {
          clipPath: ["clip-path"],
          "color-profile": ["color-profile"],
          cursor: ["cursor"],
          filter: ["filter"],
          linearGradient: ["fill", "stroke"],
          marker: ["marker", "marker-start", "marker-mid", "marker-end"],
          mask: ["mask"],
          path: [],
          pattern: ["fill", "stroke"],
          radialGradient: ["fill", "stroke"]
        }, C, k, A, O, P;
        Object.keys(_).forEach(function(W) {
          C = W, A = _[W], k = p.querySelectorAll(C + "[id]");
          for (var Y = function(z, H) {
            O = k[z].id, P = O + "-" + Uce();
            var X;
            Array.prototype.forEach.call(A, function(ie) {
              X = p.querySelectorAll("[" + ie + '*="' + O + '"]');
              for (var le = 0, ge = X.length; le < ge; le++) {
                var Se = X[le].getAttribute(ie);
                Se && !Se.match(new RegExp('url\\("?#' + O + '"?\\)')) || X[le].setAttribute(ie, "url(#" + P + ")");
              }
            });
            for (var Q = p.querySelectorAll("[*|href]"), ne = [], te = 0, se = Q.length; te < se; te++) {
              var ue = Q[te].getAttributeNS(VS, "href");
              ue && ue.toString() === "#" + k[z].id && ne.push(Q[te]);
            }
            for (var J = 0, ee = ne.length; J < ee; J++)
              ne[J].setAttributeNS(VS, "href", "#" + P);
            k[z].id = P;
          }, B = 0, D = k.length; B < D; B++)
            Y(B);
        });
      }
      p.removeAttribute("xmlns:a");
      for (var I = p.querySelectorAll("script"), $ = [], L, N, U = 0, j = I.length; U < j; U++)
        N = I[U].getAttribute("type"), (!N || N === "application/ecmascript" || N === "application/javascript" || N === "text/javascript") && (L = I[U].innerText || I[U].textContent, L && $.push(L), p.removeChild(I[U]));
      if ($.length > 0 && (n === "always" || n === "once" && !GI[c])) {
        for (var V = 0, F = $.length; V < F; V++)
          new Function($[V])(window);
        GI[c] = !0;
      }
      var K = p.querySelectorAll("style");
      if (Array.prototype.forEach.call(K, function(W) {
        W.textContent += "";
      }), p.setAttribute("xmlns", Vce), p.setAttribute("xmlns:xlink", VS), a(p), !t.parentNode) {
        yi.splice(yi.indexOf(t), 1), t = null, s(new Error("Parent node is null"));
        return;
      }
      t.parentNode.replaceChild(p, t), yi.splice(yi.indexOf(t), 1), t = null, s(null, p);
    });
  }, Hce = function(t, n) {
    var r = n === void 0 ? {} : n, o = r.afterAll, i = o === void 0 ? function() {
    } : o, a = r.afterEach, s = a === void 0 ? function() {
    } : a, c = r.beforeEach, u = c === void 0 ? function() {
    } : c, d = r.cacheRequests, p = d === void 0 ? !0 : d, m = r.evalScripts, g = m === void 0 ? "never" : m, y = r.httpRequestWithCredentials, b = y === void 0 ? !1 : y, v = r.renumerateIRIElements, x = v === void 0 ? !0 : v;
    if (t && "length" in t)
      for (var E = 0, _ = 0, C = t.length; _ < C; _++)
        KI(t[_], g, x, p, b, u, function(k, A) {
          s(k, A), t && "length" in t && t.length === ++E && i(E);
        });
    else t ? KI(t, g, x, p, b, u, function(k, A) {
      s(k, A), i(1), t = null;
    }) : i(0);
  }, qce = function(t) {
    var n = t?.ownerDocument || document;
    return n.defaultView || window;
  }, Wce = function(t, n) {
    for (var r in t)
      if (!(r in n))
        return !0;
    for (var o in n)
      if (t[o] !== n[o])
        return !0;
    return !1;
  }, Gce = ["afterInjection", "beforeInjection", "desc", "evalScripts", "fallback", "httpRequestWithCredentials", "loading", "renumerateIRIElements", "src", "title", "useRequestCache", "wrapper"], uy = "http://www.w3.org/2000/svg", YI = "http://www.w3.org/1999/xlink", pT = /* @__PURE__ */ (function(e) {
    function t() {
      for (var r, o = arguments.length, i = new Array(o), a = 0; a < o; a++)
        i[a] = arguments[a];
      return r = e.call.apply(e, [this].concat(i)) || this, r.initialState = {
        hasError: !1,
        isLoading: !0
      }, r.state = r.initialState, r._isMounted = !1, r.reactWrapper = void 0, r.nonReactWrapper = void 0, r.refCallback = function(s) {
        r.reactWrapper = s;
      }, r;
    }
    Ak(t, e);
    var n = t.prototype;
    return n.renderSVG = function() {
      var o = this;
      if (this.reactWrapper instanceof qce(this.reactWrapper).Node) {
        var i = this.props, a = i.desc, s = i.evalScripts, c = i.httpRequestWithCredentials, u = i.renumerateIRIElements, d = i.src, p = i.title, m = i.useRequestCache, g = this.props.onError, y = this.props.beforeInjection, b = this.props.afterInjection, v = this.props.wrapper, x, E;
        v === "svg" ? (x = document.createElementNS(uy, v), x.setAttribute("xmlns", uy), x.setAttribute("xmlns:xlink", YI), E = document.createElementNS(uy, v)) : (x = document.createElement(v), E = document.createElement(v)), x.appendChild(E), E.dataset.src = d, this.nonReactWrapper = this.reactWrapper.appendChild(x);
        var _ = function(O) {
          if (o.removeSVG(), !o._isMounted) {
            g(O);
            return;
          }
          o.setState(function() {
            return {
              hasError: !0,
              isLoading: !1
            };
          }, function() {
            g(O);
          });
        }, C = function(O, P) {
          if (O) {
            _(O);
            return;
          }
          o._isMounted && o.setState(function() {
            return {
              isLoading: !1
            };
          }, function() {
            try {
              b(P);
            } catch (I) {
              _(I);
            }
          });
        }, k = function(O) {
          if (O.setAttribute("role", "img"), a) {
            var P = O.querySelector(":scope > desc");
            P && O.removeChild(P);
            var I = document.createElement("desc");
            I.innerHTML = a, O.prepend(I);
          }
          if (p) {
            var $ = O.querySelector(":scope > title");
            $ && O.removeChild($);
            var L = document.createElement("title");
            L.innerHTML = p, O.prepend(L);
          }
          try {
            y(O);
          } catch (N) {
            _(N);
          }
        };
        Hce(E, {
          afterEach: C,
          beforeEach: k,
          cacheRequests: m,
          evalScripts: s,
          httpRequestWithCredentials: c,
          renumerateIRIElements: u
        });
      }
    }, n.removeSVG = function() {
      var o;
      (o = this.nonReactWrapper) != null && o.parentNode && (this.nonReactWrapper.parentNode.removeChild(this.nonReactWrapper), this.nonReactWrapper = null);
    }, n.componentDidMount = function() {
      this._isMounted = !0, this.renderSVG();
    }, n.componentDidUpdate = function(o) {
      var i = this;
      Wce(Ke({}, o), this.props) && this.setState(function() {
        return i.initialState;
      }, function() {
        i.removeSVG(), i.renderSVG();
      });
    }, n.componentWillUnmount = function() {
      this._isMounted = !1, this.removeSVG();
    }, n.render = function() {
      var o = this.props;
      o.afterInjection, o.beforeInjection, o.desc, o.evalScripts;
      var i = o.fallback;
      o.httpRequestWithCredentials;
      var a = o.loading;
      o.renumerateIRIElements, o.src, o.title, o.useRequestCache;
      var s = o.wrapper, c = bb(o, Gce), u = s;
      return /* @__PURE__ */ T.createElement(u, Ke({}, c, {
        ref: this.refCallback
      }, s === "svg" ? {
        xmlns: uy,
        xmlnsXlink: YI
      } : {}), this.state.isLoading && a && /* @__PURE__ */ T.createElement(a, null), this.state.hasError && i && /* @__PURE__ */ T.createElement(i, null));
    }, t;
  })(T.Component);
  pT.defaultProps = {
    afterInjection: function() {
    },
    beforeInjection: function() {
    },
    desc: "",
    evalScripts: "never",
    fallback: null,
    httpRequestWithCredentials: !1,
    loading: null,
    onError: function() {
    },
    renumerateIRIElements: !0,
    title: "",
    useRequestCache: !0,
    wrapper: "div"
  };
  pT.propTypes = {
    afterInjection: Yn.func,
    beforeInjection: Yn.func,
    desc: Yn.string,
    evalScripts: Yn.oneOf(["always", "once", "never"]),
    fallback: Yn.oneOfType([Yn.func, Yn.object, Yn.string]),
    httpRequestWithCredentials: Yn.bool,
    loading: Yn.oneOfType([Yn.func, Yn.object, Yn.string]),
    onError: Yn.func,
    renumerateIRIElements: Yn.bool,
    src: Yn.string.isRequired,
    title: Yn.string,
    useRequestCache: Yn.bool,
    wrapper: Yn.oneOf(["div", "span", "svg"])
  };
  const hT = ({
    text: e = "No image data provided"
  }) => /* @__PURE__ */ S.jsx(
    "div",
    {
      style: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        minHeight: "100px",
        border: "1px dashed #ccc",
        color: "#666"
      },
      children: e
    }
  ), Kce = T.memo(
    ({
      value: e,
      format: t = "jpeg",
      alt: n = "Base64 image",
      onError: r,
      onLoad: o,
      ...i
    }) => {
      const [a, s] = T.useState(!1), [c, u] = T.useState(!0), d = T.useRef(null), p = T.useMemo(() => {
        if (typeof e == "string")
          return e;
        if (e && typeof e == "object" && "data" in e) {
          const b = e.data;
          if (b instanceof ArrayBuffer) {
            const v = new Uint8Array(b);
            let x = "";
            for (let E = 0; E < v.byteLength; E++)
              x += String.fromCharCode(v[E]);
            return btoa(x);
          }
        }
        return "";
      }, [e]), m = T.useMemo(() => p ? `data:image/${t};base64,${p}` : "", [p, t]), g = T.useCallback(
        (b) => {
          s(!0), u(!1), r?.(b);
        },
        [r]
      ), y = T.useCallback(() => {
        u(!1), s(!1), o?.();
      }, [o]);
      return T.useEffect(() => {
        const b = d.current;
        if (b)
          return b.addEventListener("error", g), b.addEventListener("load", y), () => {
            b.removeEventListener("error", g), b.removeEventListener("load", y);
          };
      }, [g, y, e]), T.useEffect(() => {
        s(!1), u(!0);
      }, [e]), p ? a ? /* @__PURE__ */ S.jsx(
        "div",
        {
          style: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            minHeight: "100px",
            border: "1px dashed #ccc",
            color: "#666"
          },
          children: "Failed to load base64 image"
        }
      ) : /* @__PURE__ */ S.jsx(
        "img",
        {
          ref: d,
          src: m,
          alt: n,
          className: `base64-image-renderer image-renderer ${i.className || ""} ${c ? " loading" : ""}`,
          ...i
        }
      ) : /* @__PURE__ */ S.jsx(hT, {});
    }
  ), Yce = T.memo(
    ({
      value: e,
      alt: t = "SVG image",
      onError: n,
      onLoad: r,
      ...o
    }) => {
      const [i, a] = T.useState(!1), s = T.useMemo(() => {
        if (!e) return "";
        try {
          return `data:image/svg+xml;base64,${btoa(e)}`;
        } catch (u) {
          return console.error("Failed to encode SVG to base64:", u), "";
        }
      }, [e]);
      T.useEffect(() => {
        a(!1);
      }, [e]);
      const c = T.useCallback(
        (u) => {
          a(!0), n?.(u);
        },
        [n]
      );
      return e ? i || !s ? /* @__PURE__ */ S.jsx(
        "div",
        {
          style: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            minHeight: "100px",
            border: "1px dashed #ccc",
            color: "#666"
          },
          children: "Failed to load SVG"
        }
      ) : /* @__PURE__ */ S.jsx(
        pT,
        {
          src: s,
          className: `svg-renderer ${o.className || ""}`,
          style: {
            maxWidth: "100%",
            maxHeight: "100%",
            ...o.style
          },
          beforeInjection: (u) => {
            u.classList.add("svg-renderer"), u.setAttribute("style", "max-width: 100%; max-height: 100%;"), u.setAttribute("width", "100%"), u.setAttribute("height", "100%"), u.setAttribute("aria-label", t);
            const d = () => {
              a(!1), r?.();
            }, p = (m) => {
              a(!0), n?.(m);
            };
            try {
              u.addEventListener("load", d), u.addEventListener("error", p);
            } catch {
              d();
            }
          },
          onError: c
        }
      ) : /* @__PURE__ */ S.jsx(hT, {});
    }
  ), Xce = T.memo(
    ({
      src: e,
      alt: t = "Streaming image",
      onError: n,
      onLoad: r,
      ...o
    }) => {
      const i = T.useRef(null), [a, s] = T.useState(!1), [c, u] = T.useState(!0);
      T.useEffect(() => {
        i.current && e && (u(!0), s(!1), i.current.src = e);
      }, [e]);
      const d = T.useCallback(
        (m) => {
          s(!0), u(!1), n?.(m);
        },
        [n]
      ), p = T.useCallback(() => {
        u(!1), s(!1), r?.();
      }, [r]);
      return T.useEffect(() => {
        const m = i.current;
        if (m)
          return m.addEventListener("error", d), m.addEventListener("load", p), () => {
            m.removeEventListener("error", d), m.removeEventListener("load", p);
          };
      }, [d, p]), a ? /* @__PURE__ */ S.jsx(hT, { text: "Failed to load image" }) : /* @__PURE__ */ S.jsx(
        "img",
        {
          ref: i,
          className: `streaming-image image-renderer ${o.className || ""} ${c ? " loading" : ""}`,
          alt: t,
          ...o
        }
      );
    }
  );
  function Lb(e) {
    const t = e + "CollectionProvider", [n, r] = Qi(t), [o, i] = n(
      t,
      { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
    ), a = (b) => {
      const { scope: v, children: x } = b, E = On.useRef(null), _ = On.useRef(/* @__PURE__ */ new Map()).current;
      return /* @__PURE__ */ S.jsx(o, { scope: v, itemMap: _, collectionRef: E, children: x });
    };
    a.displayName = t;
    const s = e + "CollectionSlot", c = /* @__PURE__ */ df(s), u = On.forwardRef(
      (b, v) => {
        const { scope: x, children: E } = b, _ = i(s, x), C = un(v, _.collectionRef);
        return /* @__PURE__ */ S.jsx(c, { ref: C, children: E });
      }
    );
    u.displayName = s;
    const d = e + "CollectionItemSlot", p = "data-radix-collection-item", m = /* @__PURE__ */ df(d), g = On.forwardRef(
      (b, v) => {
        const { scope: x, children: E, ..._ } = b, C = On.useRef(null), k = un(v, C), A = i(d, x);
        return On.useEffect(() => (A.itemMap.set(C, { ref: C, ..._ }), () => {
          A.itemMap.delete(C);
        })), /* @__PURE__ */ S.jsx(m, { [p]: "", ref: k, children: E });
      }
    );
    g.displayName = d;
    function y(b) {
      const v = i(e + "CollectionConsumer", b);
      return On.useCallback(() => {
        const E = v.collectionRef.current;
        if (!E) return [];
        const _ = Array.from(E.querySelectorAll(`[${p}]`));
        return Array.from(v.itemMap.values()).sort(
          (A, O) => _.indexOf(A.ref.current) - _.indexOf(O.ref.current)
        );
      }, [v.collectionRef, v.itemMap]);
    }
    return [
      { Provider: a, Slot: u, ItemSlot: g },
      y,
      r
    ];
  }
  var mT = "ToastProvider", [gT, Zce, Qce] = Lb("Toast"), [q6] = Qi("Toast", [Qce]), [Jce, zb] = q6(mT), W6 = (e) => {
    const {
      __scopeToast: t,
      label: n = "Notification",
      duration: r = 5e3,
      swipeDirection: o = "right",
      swipeThreshold: i = 50,
      children: a
    } = e, [s, c] = T.useState(null), [u, d] = T.useState(0), p = T.useRef(!1), m = T.useRef(!1);
    return n.trim() || console.error(
      `Invalid prop \`label\` supplied to \`${mT}\`. Expected non-empty \`string\`.`
    ), /* @__PURE__ */ S.jsx(gT.Provider, { scope: t, children: /* @__PURE__ */ S.jsx(
      Jce,
      {
        scope: t,
        label: n,
        duration: r,
        swipeDirection: o,
        swipeThreshold: i,
        toastCount: u,
        viewport: s,
        onViewportChange: c,
        onToastAdd: T.useCallback(() => d((g) => g + 1), []),
        onToastRemove: T.useCallback(() => d((g) => g - 1), []),
        isFocusedToastEscapeKeyDownRef: p,
        isClosePausedRef: m,
        children: a
      }
    ) });
  };
  W6.displayName = mT;
  var G6 = "ToastViewport", eue = ["F8"], ZE = "toast.viewportPause", QE = "toast.viewportResume", K6 = T.forwardRef(
    (e, t) => {
      const {
        __scopeToast: n,
        hotkey: r = eue,
        label: o = "Notifications ({hotkey})",
        ...i
      } = e, a = zb(G6, n), s = Zce(n), c = T.useRef(null), u = T.useRef(null), d = T.useRef(null), p = T.useRef(null), m = un(t, p, a.onViewportChange), g = r.join("+").replace(/Key/g, "").replace(/Digit/g, ""), y = a.toastCount > 0;
      T.useEffect(() => {
        const v = (x) => {
          r.length !== 0 && r.every((_) => x[_] || x.code === _) && p.current?.focus();
        };
        return document.addEventListener("keydown", v), () => document.removeEventListener("keydown", v);
      }, [r]), T.useEffect(() => {
        const v = c.current, x = p.current;
        if (y && v && x) {
          const E = () => {
            if (!a.isClosePausedRef.current) {
              const A = new CustomEvent(ZE);
              x.dispatchEvent(A), a.isClosePausedRef.current = !0;
            }
          }, _ = () => {
            if (a.isClosePausedRef.current) {
              const A = new CustomEvent(QE);
              x.dispatchEvent(A), a.isClosePausedRef.current = !1;
            }
          }, C = (A) => {
            !v.contains(A.relatedTarget) && _();
          }, k = () => {
            v.contains(document.activeElement) || _();
          };
          return v.addEventListener("focusin", E), v.addEventListener("focusout", C), v.addEventListener("pointermove", E), v.addEventListener("pointerleave", k), window.addEventListener("blur", E), window.addEventListener("focus", _), () => {
            v.removeEventListener("focusin", E), v.removeEventListener("focusout", C), v.removeEventListener("pointermove", E), v.removeEventListener("pointerleave", k), window.removeEventListener("blur", E), window.removeEventListener("focus", _);
          };
        }
      }, [y, a.isClosePausedRef]);
      const b = T.useCallback(
        ({ tabbingDirection: v }) => {
          const E = s().map((_) => {
            const C = _.ref.current, k = [C, ...pue(C)];
            return v === "forwards" ? k : k.reverse();
          });
          return (v === "forwards" ? E.reverse() : E).flat();
        },
        [s]
      );
      return T.useEffect(() => {
        const v = p.current;
        if (v) {
          const x = (E) => {
            const _ = E.altKey || E.ctrlKey || E.metaKey;
            if (E.key === "Tab" && !_) {
              const k = document.activeElement, A = E.shiftKey;
              if (E.target === v && A) {
                u.current?.focus();
                return;
              }
              const I = b({ tabbingDirection: A ? "backwards" : "forwards" }), $ = I.findIndex((L) => L === k);
              HS(I.slice($ + 1)) ? E.preventDefault() : A ? u.current?.focus() : d.current?.focus();
            }
          };
          return v.addEventListener("keydown", x), () => v.removeEventListener("keydown", x);
        }
      }, [s, b]), /* @__PURE__ */ S.jsxs(
        OJ,
        {
          ref: c,
          role: "region",
          "aria-label": o.replace("{hotkey}", g),
          tabIndex: -1,
          style: { pointerEvents: y ? void 0 : "none" },
          children: [
            y && /* @__PURE__ */ S.jsx(
              JE,
              {
                ref: u,
                onFocusFromOutsideViewport: () => {
                  const v = b({
                    tabbingDirection: "forwards"
                  });
                  HS(v);
                }
              }
            ),
            /* @__PURE__ */ S.jsx(gT.Slot, { scope: n, children: /* @__PURE__ */ S.jsx(xt.ol, { tabIndex: -1, ...i, ref: m }) }),
            y && /* @__PURE__ */ S.jsx(
              JE,
              {
                ref: d,
                onFocusFromOutsideViewport: () => {
                  const v = b({
                    tabbingDirection: "backwards"
                  });
                  HS(v);
                }
              }
            )
          ]
        }
      );
    }
  );
  K6.displayName = G6;
  var Y6 = "ToastFocusProxy", JE = T.forwardRef(
    (e, t) => {
      const { __scopeToast: n, onFocusFromOutsideViewport: r, ...o } = e, i = zb(Y6, n);
      return /* @__PURE__ */ S.jsx(
        kb,
        {
          tabIndex: 0,
          ...o,
          ref: t,
          style: { position: "fixed" },
          onFocus: (a) => {
            const s = a.relatedTarget;
            !i.viewport?.contains(s) && r();
          }
        }
      );
    }
  );
  JE.displayName = Y6;
  var Gh = "Toast", tue = "toast.swipeStart", nue = "toast.swipeMove", rue = "toast.swipeCancel", oue = "toast.swipeEnd", X6 = T.forwardRef(
    (e, t) => {
      const { forceMount: n, open: r, defaultOpen: o, onOpenChange: i, ...a } = e, [s, c] = hl({
        prop: r,
        defaultProp: o ?? !0,
        onChange: i,
        caller: Gh
      });
      return /* @__PURE__ */ S.jsx(ii, { present: n || s, children: /* @__PURE__ */ S.jsx(
        sue,
        {
          open: s,
          ...a,
          ref: t,
          onClose: () => c(!1),
          onPause: qr(e.onPause),
          onResume: qr(e.onResume),
          onSwipeStart: Le(e.onSwipeStart, (u) => {
            u.currentTarget.setAttribute("data-swipe", "start");
          }),
          onSwipeMove: Le(e.onSwipeMove, (u) => {
            const { x: d, y: p } = u.detail.delta;
            u.currentTarget.setAttribute("data-swipe", "move"), u.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${d}px`), u.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${p}px`);
          }),
          onSwipeCancel: Le(e.onSwipeCancel, (u) => {
            u.currentTarget.setAttribute("data-swipe", "cancel"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), u.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), u.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
          }),
          onSwipeEnd: Le(e.onSwipeEnd, (u) => {
            const { x: d, y: p } = u.detail.delta;
            u.currentTarget.setAttribute("data-swipe", "end"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), u.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), u.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${d}px`), u.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${p}px`), c(!1);
          })
        }
      ) });
    }
  );
  X6.displayName = Gh;
  var [iue, aue] = q6(Gh, {
    onClose() {
    }
  }), sue = T.forwardRef(
    (e, t) => {
      const {
        __scopeToast: n,
        type: r = "foreground",
        duration: o,
        open: i,
        onClose: a,
        onEscapeKeyDown: s,
        onPause: c,
        onResume: u,
        onSwipeStart: d,
        onSwipeMove: p,
        onSwipeCancel: m,
        onSwipeEnd: g,
        ...y
      } = e, b = zb(Gh, n), [v, x] = T.useState(null), E = un(t, (j) => x(j)), _ = T.useRef(null), C = T.useRef(null), k = o || b.duration, A = T.useRef(0), O = T.useRef(k), P = T.useRef(0), { onToastAdd: I, onToastRemove: $ } = b, L = qr(() => {
        v?.contains(document.activeElement) && b.viewport?.focus(), a();
      }), N = T.useCallback(
        (j) => {
          !j || j === 1 / 0 || (window.clearTimeout(P.current), A.current = (/* @__PURE__ */ new Date()).getTime(), P.current = window.setTimeout(L, j));
        },
        [L]
      );
      T.useEffect(() => {
        const j = b.viewport;
        if (j) {
          const V = () => {
            N(O.current), u?.();
          }, F = () => {
            const K = (/* @__PURE__ */ new Date()).getTime() - A.current;
            O.current = O.current - K, window.clearTimeout(P.current), c?.();
          };
          return j.addEventListener(ZE, F), j.addEventListener(QE, V), () => {
            j.removeEventListener(ZE, F), j.removeEventListener(QE, V);
          };
        }
      }, [b.viewport, k, c, u, N]), T.useEffect(() => {
        i && !b.isClosePausedRef.current && N(k);
      }, [i, k, b.isClosePausedRef, N]), T.useEffect(() => (I(), () => $()), [I, $]);
      const U = T.useMemo(() => v ? r9(v) : null, [v]);
      return b.viewport ? /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
        U && /* @__PURE__ */ S.jsx(
          lue,
          {
            __scopeToast: n,
            role: "status",
            "aria-live": r === "foreground" ? "assertive" : "polite",
            children: U
          }
        ),
        /* @__PURE__ */ S.jsx(iue, { scope: n, onClose: L, children: _c.createPortal(
          /* @__PURE__ */ S.jsx(gT.ItemSlot, { scope: n, children: /* @__PURE__ */ S.jsx(
            RJ,
            {
              asChild: !0,
              onEscapeKeyDown: Le(s, () => {
                b.isFocusedToastEscapeKeyDownRef.current || L(), b.isFocusedToastEscapeKeyDownRef.current = !1;
              }),
              children: /* @__PURE__ */ S.jsx(
                xt.li,
                {
                  tabIndex: 0,
                  "data-state": i ? "open" : "closed",
                  "data-swipe-direction": b.swipeDirection,
                  ...y,
                  ref: E,
                  style: { userSelect: "none", touchAction: "none", ...e.style },
                  onKeyDown: Le(e.onKeyDown, (j) => {
                    j.key === "Escape" && (s?.(j.nativeEvent), j.nativeEvent.defaultPrevented || (b.isFocusedToastEscapeKeyDownRef.current = !0, L()));
                  }),
                  onPointerDown: Le(e.onPointerDown, (j) => {
                    j.button === 0 && (_.current = { x: j.clientX, y: j.clientY });
                  }),
                  onPointerMove: Le(e.onPointerMove, (j) => {
                    if (!_.current) return;
                    const V = j.clientX - _.current.x, F = j.clientY - _.current.y, K = !!C.current, W = ["left", "right"].includes(b.swipeDirection), Y = ["left", "up"].includes(b.swipeDirection) ? Math.min : Math.max, B = W ? Y(0, V) : 0, D = W ? 0 : Y(0, F), G = j.pointerType === "touch" ? 10 : 2, z = { x: B, y: D }, H = { originalEvent: j, delta: z };
                    K ? (C.current = z, fy(nue, p, H, {
                      discrete: !1
                    })) : XI(z, b.swipeDirection, G) ? (C.current = z, fy(tue, d, H, {
                      discrete: !1
                    }), j.target.setPointerCapture(j.pointerId)) : (Math.abs(V) > G || Math.abs(F) > G) && (_.current = null);
                  }),
                  onPointerUp: Le(e.onPointerUp, (j) => {
                    const V = C.current, F = j.target;
                    if (F.hasPointerCapture(j.pointerId) && F.releasePointerCapture(j.pointerId), C.current = null, _.current = null, V) {
                      const K = j.currentTarget, W = { originalEvent: j, delta: V };
                      XI(V, b.swipeDirection, b.swipeThreshold) ? fy(oue, g, W, {
                        discrete: !0
                      }) : fy(
                        rue,
                        m,
                        W,
                        {
                          discrete: !0
                        }
                      ), K.addEventListener("click", (Y) => Y.preventDefault(), {
                        once: !0
                      });
                    }
                  })
                }
              )
            }
          ) }),
          b.viewport
        ) })
      ] }) : null;
    }
  ), lue = (e) => {
    const { __scopeToast: t, children: n, ...r } = e, o = zb(Gh, t), [i, a] = T.useState(!1), [s, c] = T.useState(!1);
    return fue(() => a(!0)), T.useEffect(() => {
      const u = window.setTimeout(() => c(!0), 1e3);
      return () => window.clearTimeout(u);
    }, []), s ? null : /* @__PURE__ */ S.jsx(Sb, { asChild: !0, children: /* @__PURE__ */ S.jsx(kb, { ...r, children: i && /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      o.label,
      " ",
      n
    ] }) }) });
  }, cue = "ToastTitle", Z6 = T.forwardRef(
    (e, t) => {
      const { __scopeToast: n, ...r } = e;
      return /* @__PURE__ */ S.jsx(xt.div, { ...r, ref: t });
    }
  );
  Z6.displayName = cue;
  var uue = "ToastDescription", Q6 = T.forwardRef(
    (e, t) => {
      const { __scopeToast: n, ...r } = e;
      return /* @__PURE__ */ S.jsx(xt.div, { ...r, ref: t });
    }
  );
  Q6.displayName = uue;
  var J6 = "ToastAction", e9 = T.forwardRef(
    (e, t) => {
      const { altText: n, ...r } = e;
      return n.trim() ? /* @__PURE__ */ S.jsx(n9, { altText: n, asChild: !0, children: /* @__PURE__ */ S.jsx(yT, { ...r, ref: t }) }) : (console.error(
        `Invalid prop \`altText\` supplied to \`${J6}\`. Expected non-empty \`string\`.`
      ), null);
    }
  );
  e9.displayName = J6;
  var t9 = "ToastClose", yT = T.forwardRef(
    (e, t) => {
      const { __scopeToast: n, ...r } = e, o = aue(t9, n);
      return /* @__PURE__ */ S.jsx(n9, { asChild: !0, children: /* @__PURE__ */ S.jsx(
        xt.button,
        {
          type: "button",
          ...r,
          ref: t,
          onClick: Le(e.onClick, o.onClose)
        }
      ) });
    }
  );
  yT.displayName = t9;
  var n9 = T.forwardRef((e, t) => {
    const { __scopeToast: n, altText: r, ...o } = e;
    return /* @__PURE__ */ S.jsx(
      xt.div,
      {
        "data-radix-toast-announce-exclude": "",
        "data-radix-toast-announce-alt": r || void 0,
        ...o,
        ref: t
      }
    );
  });
  function r9(e) {
    const t = [];
    return Array.from(e.childNodes).forEach((r) => {
      if (r.nodeType === r.TEXT_NODE && r.textContent && t.push(r.textContent), due(r)) {
        const o = r.ariaHidden || r.hidden || r.style.display === "none", i = r.dataset.radixToastAnnounceExclude === "";
        if (!o)
          if (i) {
            const a = r.dataset.radixToastAnnounceAlt;
            a && t.push(a);
          } else
            t.push(...r9(r));
      }
    }), t;
  }
  function fy(e, t, n, { discrete: r }) {
    const o = n.originalEvent.currentTarget, i = new CustomEvent(e, { bubbles: !0, cancelable: !0, detail: n });
    t && o.addEventListener(e, t, { once: !0 }), r ? Nk(o, i) : o.dispatchEvent(i);
  }
  var XI = (e, t, n = 0) => {
    const r = Math.abs(e.x), o = Math.abs(e.y), i = r > o;
    return t === "left" || t === "right" ? i && r > n : !i && o > n;
  };
  function fue(e = () => {
  }) {
    const t = qr(e);
    qa(() => {
      let n = 0, r = 0;
      return n = window.requestAnimationFrame(() => r = window.requestAnimationFrame(t)), () => {
        window.cancelAnimationFrame(n), window.cancelAnimationFrame(r);
      };
    }, [t]);
  }
  function due(e) {
    return e.nodeType === e.ELEMENT_NODE;
  }
  function pue(e) {
    const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (r) => {
        const o = r.tagName === "INPUT" && r.type === "hidden";
        return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    for (; n.nextNode(); ) t.push(n.currentNode);
    return t;
  }
  function HS(e) {
    const t = document.activeElement;
    return e.some((n) => n === t ? !0 : (n.focus(), document.activeElement !== t));
  }
  var hue = W6, mue = K6, gue = X6, yue = Z6, vue = Q6, bue = e9, xue = yT;
  const lr = [];
  for (let e = 0; e < 256; ++e)
    lr.push((e + 256).toString(16).slice(1));
  function wue(e, t = 0) {
    return (lr[e[t + 0]] + lr[e[t + 1]] + lr[e[t + 2]] + lr[e[t + 3]] + "-" + lr[e[t + 4]] + lr[e[t + 5]] + "-" + lr[e[t + 6]] + lr[e[t + 7]] + "-" + lr[e[t + 8]] + lr[e[t + 9]] + "-" + lr[e[t + 10]] + lr[e[t + 11]] + lr[e[t + 12]] + lr[e[t + 13]] + lr[e[t + 14]] + lr[e[t + 15]]).toLowerCase();
  }
  let qS;
  const Sue = new Uint8Array(16);
  function _ue() {
    if (!qS) {
      if (typeof crypto > "u" || !crypto.getRandomValues)
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      qS = crypto.getRandomValues.bind(crypto);
    }
    return qS(Sue);
  }
  const Eue = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), ZI = { randomUUID: Eue };
  function Cue(e, t, n) {
    e = e || {};
    const r = e.random ?? e.rng?.() ?? _ue();
    if (r.length < 16)
      throw new Error("Random bytes length must be >= 16");
    return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, wue(r);
  }
  function vT(e, t, n) {
    return ZI.randomUUID && !e ? ZI.randomUUID() : Cue(e);
  }
  const o9 = T.createContext(
    void 0
  ), i9 = T.createContext(
    void 0
  ), kue = 350, Tue = ({ children: e, fixedHeight: t, duration: n = 5e3, maxVisible: r = 3, ...o }) => {
    const [i, a] = T.useState(/* @__PURE__ */ new Map()), s = T.useRef(/* @__PURE__ */ new Map()), c = T.useRef(null), u = T.useRef(!0), d = T.useCallback(() => {
      const x = Array.from(s.current).reverse();
      if (t) {
        const E = t;
        x.forEach(([, _], C) => {
          if (!_) return;
          _.setAttribute("data-front", String(C === 0)), _.setAttribute("data-hidden", String(C >= r)), _.style.setProperty("--index", String(C)), _.style.setProperty("--height", `${t}px`), _.style.setProperty("--front-height", `${E}px`);
          const k = t * C;
          _.style.setProperty("--hover-offset-y", `-${k}px`);
        });
      } else {
        const E = x.map(([, C]) => {
          if (!C) return 0;
          const k = C.querySelector(
            ".ToastInner"
          );
          if (!k) return C.clientHeight;
          const A = k.style.height;
          k.style.height = "auto";
          const O = C.clientHeight;
          return k.style.height = A, O;
        }), _ = E[0] || 0;
        x.forEach(([, C], k) => {
          if (!C) return;
          const A = E[k];
          C.setAttribute("data-front", String(k === 0)), C.setAttribute("data-hidden", String(k >= r)), C.style.setProperty("--index", String(k)), C.style.setProperty("--height", `${A}px`), C.style.setProperty("--front-height", `${_}px`);
          const O = E.slice(0, k).reduce((P, I) => P + I, 0);
          C.style.setProperty("--hover-offset-y", `-${O}px`);
        });
      }
    }, [t, r]), p = T.useCallback(
      (x) => {
        a((E) => {
          const _ = new Map(E);
          return _.set(vT(), {
            ...x,
            duration: x.duration || n,
            open: !0
          }), _;
        });
      },
      [n]
    ), m = T.useCallback((x) => {
      u.current && a((E) => {
        const _ = new Map(E);
        return _.delete(x), _;
      });
    }, []), g = T.useCallback(
      (x) => p({ ...x, status: x.status || "default" }),
      [p]
    ), y = T.useCallback(
      (x) => p({ ...x, status: "success" }),
      [p]
    ), b = T.useCallback(
      (x) => p({ ...x, status: "error" }),
      [p]
    );
    T.useEffect(() => (u.current = !0, () => {
      u.current = !1;
    }), []), T.useEffect(() => {
      const x = c.current;
      if (x) {
        const E = () => {
          s.current.forEach((k) => {
            k.setAttribute("data-hovering", "true");
          });
        }, _ = (k) => {
          (!x.contains(k.target) || x === k.target) && s.current.forEach((A) => {
            A.setAttribute("data-hovering", "false");
          });
        }, C = () => {
          s.current.forEach((k) => {
            k.setAttribute("data-hovering", "false");
          });
        };
        return x.addEventListener("pointermove", E), x.addEventListener("pointerleave", C), x.addEventListener("focusin", E), x.addEventListener("focusout", _), () => {
          x.removeEventListener("pointermove", E), x.removeEventListener("pointerleave", C), x.removeEventListener("focusin", E), x.removeEventListener("focusout", _);
        };
      }
    }, []);
    const v = T.useMemo(
      () => Object.assign(g, {
        success: y,
        error: b
      }),
      [g, y, b]
    );
    return /* @__PURE__ */ S.jsx(o9.Provider, { value: v, children: /* @__PURE__ */ S.jsx(
      i9.Provider,
      {
        value: T.useMemo(
          () => ({
            toastElementsMapRef: s,
            sortToasts: d
          }),
          [d]
        ),
        children: /* @__PURE__ */ S.jsxs(hue, { ...o, children: [
          e,
          Array.from(i).map(([x, E]) => /* @__PURE__ */ S.jsx(
            Oue,
            {
              id: x,
              toast: E,
              onOpenChange: (_) => {
                _ || (s.current.delete(x), d(), a((C) => {
                  const k = new Map(C), A = k.get(x);
                  return A && k.set(x, { ...A, open: !1 }), k;
                }), setTimeout(() => {
                  m(x);
                }, kue));
              }
            },
            x
          )),
          /* @__PURE__ */ S.jsx(
            mue,
            {
              ref: c,
              className: "ToastViewport",
              style: t ? {
                "--fixed-toast-height": `${t}px`
              } : void 0
            }
          )
        ] })
      }
    ) });
  }, Aue = () => {
    const e = T.useContext(o9);
    if (e) return e;
    throw new Error("useToast must be used within Toasts");
  }, Rue = () => {
    const e = T.useContext(i9);
    if (e) return e;
    throw new Error("useToastContext must be used within Toasts");
  }, Oue = ({
    onOpenChange: e,
    toast: t,
    id: n,
    ...r
  }) => {
    const o = T.useRef(null), i = Rue(), { sortToasts: a, toastElementsMapRef: s } = i, c = s.current;
    return T.useLayoutEffect(() => (o.current && (c.set(n, o.current), a()), () => {
      c.delete(n), a();
    }), [n, a, c]), /* @__PURE__ */ S.jsx(
      gue,
      {
        ...r,
        ref: o,
        type: t.type,
        duration: t.duration,
        className: "ToastRoot",
        onOpenChange: e,
        open: t.open,
        children: /* @__PURE__ */ S.jsxs("div", { className: "ToastInner", "data-status": t.status, children: [
          /* @__PURE__ */ S.jsx(Mue, { status: t.status }),
          t.title && /* @__PURE__ */ S.jsx(yue, { className: "ToastTitle", children: t.title }),
          /* @__PURE__ */ S.jsx(vue, { className: "ToastDescription", children: t.description }),
          t.action && /* @__PURE__ */ S.jsx(
            bue,
            {
              className: "ToastAction Button small green",
              altText: t.action.altText,
              onClick: t.action.onClick,
              asChild: !0,
              children: /* @__PURE__ */ S.jsx("button", { children: t.action.label })
            }
          ),
          /* @__PURE__ */ S.jsx(xue, { "aria-label": "Close", className: "ToastClose", children: /* @__PURE__ */ S.jsx(Nb, { style: { fontSize: "12px" } }) })
        ] })
      }
    );
  }, Mue = ({ status: e }) => e !== "default" && e ? /* @__PURE__ */ S.jsxs("div", { style: { gridArea: "icon", alignSelf: "start" }, children: [
    e === "success" && /* @__PURE__ */ S.jsx(Koe, { style: { color: "#61d345", fontSize: "20px" } }),
    e === "error" && /* @__PURE__ */ S.jsx(Yoe, { style: { color: "#ff4b4b", fontSize: "20px" } })
  ] }) : null, Nue = {}, QI = (e) => {
    let t;
    const n = /* @__PURE__ */ new Set(), r = (d, p) => {
      const m = typeof d == "function" ? d(t) : d;
      if (!Object.is(m, t)) {
        const g = t;
        t = p ?? (typeof m != "object" || m === null) ? m : Object.assign({}, t, m), n.forEach((y) => y(t, g));
      }
    }, o = () => t, c = { setState: r, getState: o, getInitialState: () => u, subscribe: (d) => (n.add(d), () => n.delete(d)), destroy: () => {
      (Nue ? "production" : void 0) !== "production" && console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      ), n.clear();
    } }, u = t = e(r, o, c);
    return c;
  }, a9 = (e) => e ? QI(e) : QI;
  var WS = { exports: {} }, GS = {}, KS = { exports: {} }, YS = {};
  var JI;
  function Pue() {
    if (JI) return YS;
    JI = 1;
    var e = Oh();
    function t(p, m) {
      return p === m && (p !== 0 || 1 / p === 1 / m) || p !== p && m !== m;
    }
    var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, o = e.useEffect, i = e.useLayoutEffect, a = e.useDebugValue;
    function s(p, m) {
      var g = m(), y = r({ inst: { value: g, getSnapshot: m } }), b = y[0].inst, v = y[1];
      return i(
        function() {
          b.value = g, b.getSnapshot = m, c(b) && v({ inst: b });
        },
        [p, g, m]
      ), o(
        function() {
          return c(b) && v({ inst: b }), p(function() {
            c(b) && v({ inst: b });
          });
        },
        [p]
      ), a(g), g;
    }
    function c(p) {
      var m = p.getSnapshot;
      p = p.value;
      try {
        var g = m();
        return !n(p, g);
      } catch {
        return !0;
      }
    }
    function u(p, m) {
      return m();
    }
    var d = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? u : s;
    return YS.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : d, YS;
  }
  var e$;
  function Iue() {
    return e$ || (e$ = 1, KS.exports = Pue()), KS.exports;
  }
  var t$;
  function $ue() {
    if (t$) return GS;
    t$ = 1;
    var e = Oh(), t = Iue();
    function n(u, d) {
      return u === d && (u !== 0 || 1 / u === 1 / d) || u !== u && d !== d;
    }
    var r = typeof Object.is == "function" ? Object.is : n, o = t.useSyncExternalStore, i = e.useRef, a = e.useEffect, s = e.useMemo, c = e.useDebugValue;
    return GS.useSyncExternalStoreWithSelector = function(u, d, p, m, g) {
      var y = i(null);
      if (y.current === null) {
        var b = { hasValue: !1, value: null };
        y.current = b;
      } else b = y.current;
      y = s(
        function() {
          function x(A) {
            if (!E) {
              if (E = !0, _ = A, A = m(A), g !== void 0 && b.hasValue) {
                var O = b.value;
                if (g(O, A))
                  return C = O;
              }
              return C = A;
            }
            if (O = C, r(_, A)) return O;
            var P = m(A);
            return g !== void 0 && g(O, P) ? (_ = A, O) : (_ = A, C = P);
          }
          var E = !1, _, C, k = p === void 0 ? null : p;
          return [
            function() {
              return x(d());
            },
            k === null ? void 0 : function() {
              return x(k());
            }
          ];
        },
        [d, p, m, g]
      );
      var v = o(u, y[0], y[1]);
      return a(
        function() {
          b.hasValue = !0, b.value = v;
        },
        [v]
      ), c(v), v;
    }, GS;
  }
  var n$;
  function jue() {
    return n$ || (n$ = 1, WS.exports = $ue()), WS.exports;
  }
  var Due = jue();
  const s9 = /* @__PURE__ */ Xi(Due), l9 = {}, { useDebugValue: Fue } = On, { useSyncExternalStoreWithSelector: Lue } = s9;
  let r$ = !1;
  const zue = (e) => e;
  function Bue(e, t = zue, n) {
    (l9 ? "production" : void 0) !== "production" && n && !r$ && (console.warn(
      "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
    ), r$ = !0);
    const r = Lue(
      e.subscribe,
      e.getState,
      e.getServerState || e.getInitialState,
      t,
      n
    );
    return Fue(r), r;
  }
  const o$ = (e) => {
    (l9 ? "production" : void 0) !== "production" && typeof e != "function" && console.warn(
      "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
    );
    const t = typeof e == "function" ? a9(e) : e, n = (r, o) => Bue(t, r, o);
    return Object.assign(n, t), n;
  }, No = (e) => e ? o$(e) : o$;
  class ts {
    constructor(t) {
      this.context = t;
    }
    get communicationManager() {
      return this.context.worker.getCommunicationManager();
    }
    get eventManager() {
      return this.context.worker.getEventManager();
    }
    get hookManager() {
      return this.context.worker.getHookManager();
    }
    get nodeManager() {
      return this.context.worker.getNodeManager();
    }
    get syncManager() {
      return this.context.worker.getSyncManager();
    }
    get connectionHealthManager() {
      return this.context.worker.getConnectionHealthManager();
    }
    get edgeManager() {
      return this.context.worker.getEdgeManager();
    }
    get groupManager() {
      return this.context.worker.getGroupManager();
    }
    get libraryManager() {
      return this.context.worker.getLibraryManager();
    }
  }
  const dy = 2e3;
  class Uue extends ts {
    constructor(t) {
      super(t), this._responsive = !1, this._last_pong = 0, this._last_pong = Date.now() - dy * 100;
    }
    start() {
      this.stop(), this.pingInterval = setInterval(() => {
        this.context.worker.is_open && this.context.worker.send({ type: "ping" });
      }, dy), this.responsivenessCheckInterval = setInterval(() => {
        this._responsive = Date.now() - this._last_pong <= dy * 3;
      }, dy * 2);
    }
    stop() {
      this.pingInterval && clearInterval(this.pingInterval), this.responsivenessCheckInterval && clearInterval(this.responsivenessCheckInterval);
    }
    receivePong() {
      this._last_pong = Date.now(), this._responsive = !0;
    }
    isResponsive() {
      return this._responsive;
    }
  }
  const i$ = (e, t) => {
    e.properties = e.properties || {}, t.pos && (e.properties["frontend:pos"] = t.pos), t.size && (e.properties["frontend:size"] = t.size), t.collapsed !== void 0 && (e.properties["frontend:collapsed"] = !!t.collapsed);
  }, a$ = 2e3, s$ = 2e3;
  class Vue extends ts {
    constructor(t) {
      super(t), this._local_nodeupdates = /* @__PURE__ */ new Map(), this._local_groupupdates = /* @__PURE__ */ new Map(), this._after_next_sync = [], this.on_sync_complete = t.on_sync_complete || (async () => {
      });
    }
    start() {
      this._nodeupdatetimer = setTimeout(() => {
        this.sync_local_node_updates();
      }, a$), this._groupupdatetimer = setTimeout(() => {
        this.sync_local_group_updates();
      }, s$);
    }
    stop() {
      this._nodeupdatetimer && clearTimeout(this._nodeupdatetimer), this._groupupdatetimer && clearTimeout(this._groupupdatetimer);
    }
    async stepwise_fullsync() {
      if (!this.context.worker._zustand || !this.context.worker.is_open) return;
      await this.sync_lib(), await this.sync_external_worker(), await this.sync_funcnodes_plugins(), await this.sync_nodespace(), await this.sync_view_state(), await this.on_sync_complete(this.context.worker);
      const t = this._after_next_sync.splice(0);
      for (const n of t)
        await n(this.context.worker), this._after_next_sync.includes(n) && this._after_next_sync.splice(this._after_next_sync.indexOf(n), 1);
    }
    add_after_next_sync(t) {
      this._after_next_sync.push(t);
    }
    remove_after_next_sync(t) {
      this._after_next_sync = this._after_next_sync.filter(
        (n) => n !== t
      );
    }
    async sync_lib() {
      if (!this.context.worker._zustand || !this.context.worker.is_open) return;
      const t = await this.communicationManager._send_cmd({
        cmd: "get_library",
        wait_for_response: !0,
        retries: 2,
        unique: !0
      });
      this.context.worker._zustand.lib.libstate.getState().set({
        lib: t
      });
    }
    async sync_external_worker() {
      if (!this.context.worker._zustand || !this.context.worker.is_open) return;
      const t = await this.communicationManager._send_cmd({
        cmd: "get_worker_dependencies",
        wait_for_response: !0,
        unique: !0
      });
      this.context.worker._zustand.lib.libstate.getState().set({
        external_worker: t
      });
    }
    async sync_funcnodes_plugins() {
      if (!this.context.worker._zustand || !this.context.worker.is_open) return;
      const t = await this.context.worker.getCommunicationManager()._send_cmd({
        cmd: "get_plugin_keys",
        wait_for_response: !0,
        unique: !0,
        kwargs: { type: "react" }
      });
      for (const n of t) {
        const r = await this.context.worker.getCommunicationManager()._send_cmd({
          cmd: "get_plugin",
          wait_for_response: !0,
          kwargs: { key: n, type: "react" },
          unique: !0
        });
        this.context.worker._zustand.add_packed_plugin(n, r);
      }
    }
    async sync_view_state() {
      if (!this.context.worker._zustand || !this.context.worker.is_open) return;
      const t = await this.context.worker.getCommunicationManager()._send_cmd({
        cmd: "view_state",
        wait_for_response: !0,
        unique: !0
      });
      t.renderoptions && this.context.worker._zustand.update_render_options(t.renderoptions);
      const n = t.nodes;
      if (n)
        for (const r in n) {
          const o = {};
          i$(o, n[r]), this.context.worker._zustand.on_node_action({
            type: "update",
            node: o,
            id: r,
            from_remote: !0
          });
        }
    }
    async sync_nodespace() {
      if (!this.context.worker._zustand || !this.context.worker.is_open) return;
      const t = await this.context.worker.getCommunicationManager()._send_cmd({
        cmd: "get_nodes",
        kwargs: { with_frontend: !0 },
        wait_for_response: !0,
        unique: !0
      });
      for (const o of t)
        this.eventManager._receive_node_added(o);
      const n = await this.context.worker.getCommunicationManager()._send_cmd({
        cmd: "get_edges",
        wait_for_response: !0,
        unique: !0
      });
      for (const o of n)
        this.eventManager._receive_edge_added(...o);
      const r = await this.context.worker.getCommunicationManager()._send_cmd({
        cmd: "get_groups",
        kwargs: {},
        wait_for_response: !0,
        unique: !0
      });
      this.eventManager._receive_groups(r);
    }
    async fullsync() {
      if (!this.context.worker._zustand || !this.context.worker.is_open) return;
      let t;
      for (; ; )
        try {
          t = await this.communicationManager._send_cmd({
            cmd: "full_state",
            unique: !0
          });
          break;
        } catch (o) {
          o instanceof Error ? this.context.worker._zustand.logger.error("Error in fullsync", o) : this.context.worker._zustand.logger.error(
            "Error in fullsync",
            new Error(JSON.stringify(o))
          );
        }
      this.context.worker._zustand.logger.debug("Full state", t), this.context.worker._zustand.lib.libstate.getState().set({
        lib: t.backend.lib,
        external_worker: t.worker_dependencies
      }), t.view.renderoptions && this.context.worker._zustand.update_render_options(
        t.view.renderoptions
      );
      const n = t.view.nodes;
      for (const o of t.backend.nodes) {
        const i = n[o.id];
        i !== void 0 && i$(o, i), this.eventManager._receive_node_added(o);
      }
      for (const o of t.backend.edges)
        this.eventManager._receive_edge_added(...o);
      const r = t.backend.groups;
      r && this.eventManager._receive_groups(r);
    }
    sync_local_node_updates() {
      clearTimeout(this._nodeupdatetimer), this._local_nodeupdates.forEach(async (t, n) => {
        const r = await this.context.worker.getCommunicationManager()._send_cmd({
          cmd: "update_node",
          kwargs: { nid: n, data: t },
          wait_for_response: !0
        });
        this.context.worker._zustand && Object.keys(r).length > 0 && this.context.worker._zustand.on_node_action({
          type: "update",
          node: r,
          id: n,
          from_remote: !0
        });
      }), this._local_nodeupdates.clear(), this._nodeupdatetimer = setTimeout(() => {
        this.sync_local_node_updates();
      }, a$);
    }
    sync_local_group_updates() {
      clearTimeout(this._groupupdatetimer), this._local_groupupdates.forEach(async (t, n) => {
        const r = await this.communicationManager._send_cmd({
          cmd: "update_group",
          kwargs: { gid: n, data: t },
          wait_for_response: !0
        });
        this.context.worker._zustand && this.context.worker._zustand.on_group_action({
          type: "update",
          group: r,
          id: n,
          from_remote: !0
        });
      }), this._local_groupupdates.clear(), this._groupupdatetimer = setTimeout(() => {
        this.sync_local_group_updates();
      }, s$);
    }
    locally_update_node(t) {
      const n = this._local_nodeupdates.get(t.id);
      if (n) {
        const { new_obj: r, change: o } = tl(n, t.node);
        o && this._local_nodeupdates.set(t.id, r);
      } else
        this._local_nodeupdates.set(t.id, t.node);
      t.immediate && this.sync_local_node_updates();
    }
    locally_update_group(t) {
      const n = this._local_groupupdates.get(t.id);
      if (n) {
        const { new_obj: r, change: o } = tl(n, t.group);
        o && this._local_groupupdates.set(t.id, r);
      } else
        this._local_groupupdates.set(t.id, t.group);
      t.immediate && this.sync_local_group_updates();
    }
  }
  class Pi {
    /**
     * Creates a new DataStructure instance.
     *
     * @param props - Configuration object containing data and MIME type
     */
    constructor({ data: t, mime: n }) {
      this._data = t, this._mime = n;
    }
    /**
     * Gets the raw wrapped data.
     *
     * @returns The original data in its native type
     */
    get data() {
      return this._data;
    }
    /**
     * Gets the data cast to the expected return type.
     * This is a type assertion and should be overridden in subclasses for proper type conversion.
     *
     * @returns The data cast to type R
     */
    get value() {
      return this._data;
    }
    /**
     * Gets the MIME type of the wrapped data.
     *
     * @returns The MIME type string
     */
    get mime() {
      return this._mime;
    }
    /**
     * Returns a string representation of the DataStructure.
     * The format varies based on the data type:
     * - ArrayBuffer: shows byte length
     * - Blob: shows size
     * - String/Array: shows length
     * - Object: shows number of keys
     * - Other types: shows only MIME type
     *
     * @returns String representation in format "DataStructure(size,mime)" or "DataStructure(mime)"
     */
    toString() {
      return this._data instanceof ArrayBuffer ? `DataStructure(${this._data.byteLength},${this._mime})` : this._data instanceof Blob ? `DataStructure(${this._data.size},${this._mime})` : this._data instanceof String ? `DataStructure(${this._data.length},${this._mime})` : this._data instanceof Array ? `DataStructure(${this._data.length},${this._mime})` : this._data instanceof Object ? `DataStructure(${Object.keys(this._data).length},${this._mime})` : `DataStructure(${this._mime})`;
    }
    /**
     * Returns the JSON representation of this DataStructure.
     * Currently delegates to toString() method.
     *
     * @returns JSON string representation
     */
    toJSON() {
      return this.toString();
    }
    /**
     * Cleans up resources associated with this DataStructure.
     * Base implementation does nothing, but subclasses may override to release resources.
     */
    dispose() {
    }
  }
  class c9 extends Pi {
    constructor({ data: t, mime: n }) {
      super({ data: Bb(t), mime: n });
    }
    get objectUrl() {
      if (this._objectUrl)
        return this._objectUrl;
      const t = this.data instanceof Blob ? this.data : new Blob([this.data], { type: this.mime });
      return this._objectUrl = URL.createObjectURL(t), this._objectUrl;
    }
    dispose() {
      this._objectUrl && URL.revokeObjectURL(this._objectUrl), super.dispose();
    }
    get value() {
      return this.objectUrl;
    }
  }
  const Bb = (e) => {
    if (e instanceof ArrayBuffer)
      return e;
    const t = ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e), n = new ArrayBuffer(t.byteLength);
    return new Uint8Array(n).set(t), n;
  }, Hue = {
    x: (e, t) => null,
    //  pad byte 	no value 	(7 )
    c: (e, t) => new DataView(e).getInt8(0),
    //  char 	bytes of length 1 	1 	b 	signed char 	integer 	1 	(1 ), (2 )
    B: (e, t) => new DataView(e).getUint8(0),
    //  unsigned char 	integer 	1 	(2 )
    "?": (e, t) => new DataView(e).getInt8(0) === 1,
    //  _Bool 	bool 	1 	(1 )
    h: (e, t) => new DataView(e).getInt16(0, t),
    //  short 	integer 	2 	(2 )
    H: (e, t) => new DataView(e).getUint16(0, t),
    //  unsigned short 	integer 	2 	(2 )
    i: (e, t) => new DataView(e).getInt32(0, t),
    //  int 	integer 	4 	(2 )
    I: (e, t) => new DataView(e).getUint32(0, t),
    //  unsigned int 	integer 	4 	(2 )
    l: (e, t) => new DataView(e).getInt32(0, t),
    //  long 	integer 	4 	(2 )
    L: (e, t) => new DataView(e).getUint32(0, t),
    //  unsigned long 	integer 	4 	(2 )
    q: (e, t) => Number(
      new DataView(e).getBigInt64(0, t)
    ),
    //  long long 	integer 	8 	(2 )
    Q: (e, t) => Number(
      new DataView(e).getBigUint64(0, t)
    ),
    //  unsigned long long 	integer 	8 	(2 )
    n: (e, t) => Number(
      new DataView(e).getBigInt64(0, t)
    ),
    //  ssize_t 	integer 	(3 )
    N: (e, t) => Number(
      new DataView(e).getBigUint64(0, t)
    ),
    //  size_t 	integer 	(3 )
    // "e":(data:ArrayBufferLike)=>{return new DataView(to_arraybuffer(data)).getFloat16(0)}, //  (6 ) float 	2 	(4 )
    f: (e, t) => new DataView(e).getFloat32(0, t),
    //  float 	float 	4 	(4 )
    d: (e, t) => new DataView(e).getFloat64(0, t),
    //  double 	float 	8 	(4 )
    s: (e, t) => new TextDecoder().decode(e),
    //  char[] 	bytes 	(9 )
    p: (e, t) => new TextDecoder().decode(e),
    //  char[] 	bytes 	(8 )
    P: (e, t) => Number(
      new DataView(e).getBigUint64(0, t)
    )
    //  void* 	int
  };
  class u9 extends Pi {
    constructor({ data: t, mime: n }) {
      super({ data: Bb(t), mime: n }), this._cType = n.split("application/fn.struct.")[1], this._value = null, this.parse_value();
    }
    parse_value() {
      let t = !0, n = this._cType;
      return n.startsWith("<") && (t = !0, n = n.slice(1)), n.startsWith(">") && (t = !1, n = n.slice(1)), n.startsWith("!") && (t = !1, n = n.slice(1)), n.startsWith("@") && (t = !1, n = n.slice(1)), n.startsWith("=") && (t = !1, n = n.slice(1)), this._value = Hue[n](this.data, t), this._value;
    }
    get value() {
      return this._value;
    }
    toString() {
      return this._value === null ? "null" : this._value.toString();
    }
  }
  class Ks extends Pi {
    constructor({ data: t, mime: n }) {
      const r = Bb(t);
      super({ data: r, mime: n }), r.byteLength === 0 ? this._json = void 0 : (this._json = JSON.parse(new TextDecoder().decode(r)), this._json === "<NoValue>" && (this._json = void 0));
    }
    get value() {
      return this._json;
    }
    static fromObject(t) {
      const n = t === "<NoValue>" ? new Uint8Array(0) : new TextEncoder().encode(JSON.stringify(t));
      return new Ks({ data: n, mime: "application/json" });
    }
    toString() {
      return typeof this._json == "string" ? this._json : JSON.stringify(this._json);
    }
  }
  class f9 extends Pi {
    constructor({ data: t, mime: n }) {
      const r = Bb(t);
      super({ data: r, mime: n }), this._value = new TextDecoder().decode(r);
    }
    get value() {
      return this._value;
    }
    toString() {
      return this._value;
    }
  }
  const d9 = ({
    data: e,
    mime: t
  }) => {
    const n = typeof SharedArrayBuffer < "u" && e instanceof SharedArrayBuffer;
    return e instanceof ArrayBuffer || ArrayBuffer.isView(e) || n ? t.startsWith("application/fn.struct.") ? new u9({ data: e, mime: t }) : t.startsWith("application/json") ? new Ks({ data: e, mime: t }) : t === "text" || t.startsWith("text/") ? new f9({ data: e, mime: t }) : new c9({ data: e, mime: t }) : new Pi({ data: e, mime: t });
  };
  class que extends ts {
    constructor(t) {
      super(t), this.CHUNK_TIMEOUT = 1e4, this._unique_cmd_outs = {}, this.blobChunks = {}, this.cleanupChunks = () => {
        const n = Date.now();
        for (const r in this.blobChunks)
          n - this.blobChunks[r].timestamp > this.CHUNK_TIMEOUT && delete this.blobChunks[r];
      }, this.messagePromises = /* @__PURE__ */ new Map();
    }
    start() {
      this._chunk_cleanup_timer = setInterval(
        this.cleanupChunks.bind(this),
        this.CHUNK_TIMEOUT / 2
      );
    }
    stop() {
      this._chunk_cleanup_timer && clearInterval(this._chunk_cleanup_timer);
    }
    send(t) {
      this.context.worker.send(t);
    }
    async _send_cmd({
      cmd: t,
      kwargs: n,
      as_bytes: r = !1,
      wait_for_response: o = !0,
      response_timeout: i = 5e3,
      retries: a = 2,
      unique: s = !1
    }) {
      const c = {
        type: "cmd",
        as_bytes: r,
        cmd: t,
        kwargs: n || {}
      };
      if (await new Promise(async (u) => {
        if (this.context.worker.is_responsive) return u();
        const d = setInterval(() => {
          this.context.worker.is_responsive && (clearInterval(d), u());
        }, 100);
      }), o) {
        if (s && this._unique_cmd_outs[c.cmd] !== void 0)
          return this._unique_cmd_outs[c.cmd];
        a < 0 && (a = 0);
        const d = (async () => {
          let p;
          for (; a >= 0; ) {
            const m = c.id || vT();
            c.id = m;
            const g = new Promise((y, b) => {
              const v = setTimeout(() => {
                b("Timeout@wait_for_response for " + t);
              }, i);
              this.messagePromises.set(m, {
                resolve: (x) => {
                  clearTimeout(v), y(x), this.messagePromises.delete(m);
                },
                reject: (x) => {
                  clearTimeout(v), b(x), this.messagePromises.delete(m);
                }
              });
            });
            await this.send(c);
            try {
              p = await g;
              break;
            } catch (y) {
              if (a === 0)
                throw delete this._unique_cmd_outs[c.cmd], y;
              a -= 1;
              continue;
            }
          }
          return delete this._unique_cmd_outs[c.cmd], p;
        })();
        return s && (this._unique_cmd_outs[c.cmd] = d), d;
      }
      return this.send(c);
    }
    async receive(t) {
      let n;
      switch (this.connectionHealthManager.receivePong(), t.type) {
        case "pong":
          return this.connectionHealthManager.receivePong();
        case "nsevent":
          return await this.context.worker.getEventManager().receive_nodespace_event(t);
        case "result":
          if (n = t.id && this.messagePromises.get(t.id), n)
            return n.resolve(t.result);
          break;
        case "error":
          if (this.context.worker.on_error(t.tb + `
` + t.error), n = t.id && this.messagePromises.get(t.id), n)
            return n.reject(t.error);
          break;
        case "progress":
          if (!this.context.worker._zustand) return;
          this.context.worker._zustand.set_progress(t);
          break;
        case "workerevent":
          return await this.context.worker.getEventManager().receive_workerevent(t);
        case "large_message":
          return await this.context.worker.handle_large_message_hint(t);
        default:
          console.warn("Unhandled message", t);
          break;
      }
    }
    async receive_bytes(t, n) {
      const { type: r } = t;
      if (r === "io_value") {
        if (!this.context.worker._zustand) return;
        const { node: o, io: i, preview: a, mime: s } = t, c = a ? "value" : "fullvalue";
        (!o || !i) && console.error("Invalid io_value message", t);
        const u = d9({
          data: n,
          mime: s || "application/octet-stream"
        });
        this.context.worker._zustand.on_node_action({
          type: "update",
          node: {
            id: o,
            io: {
              [i]: {
                [c]: u
              }
            }
          },
          id: o,
          from_remote: !0
        });
      } else if (r == "result") {
        const o = t.id && this.messagePromises.get(t.id);
        o && o.resolve({ bytes: n, header: t });
      } else
        console.warn("Unhandled bytes message", t);
    }
    async onbytes(t) {
      try {
        const n = new TextDecoder("utf-8").decode(t), r = n.indexOf(`\r
\r
`);
        if (r === -1) {
          console.error(`Header terminator not found for:
`, n);
          return;
        }
        const o = n.substring(0, r + 4), i = t.slice(r + 4), a = o.split(";"), s = {};
        if (a.forEach((p) => {
          const [m, g] = p.split("=");
          s[m.trim()] = g.trim();
        }), !s.chunk || !s.msgid) {
          console.error(
            "Header missing required fields chunk or msgid",
            s
          );
          return;
        }
        const [c, u] = s.chunk.split("/"), d = s.msgid;
        if (c === "1" && u === "1")
          return this.receive_bytes(s, i);
        if (this.blobChunks[d] || (this.blobChunks[d] = {
          chunks: Array.from({ length: parseInt(u) }, () => null),
          timestamp: Date.now()
        }), this.blobChunks[d].chunks.length !== parseInt(u)) {
          console.error("Total chunks mismatch");
          return;
        }
        if (this.blobChunks[d].chunks[parseInt(c) - 1] = t, this.blobChunks[d].chunks.every((p) => p !== null)) {
          const p = new Uint8Array(
            this.blobChunks[d].chunks.reduce((m, g) => m.concat(Array.from(g)), [])
          );
          this.receive_bytes(s, p), delete this.blobChunks[d];
        }
      } catch (n) {
        console.error("Websocketworker: onbytes error", n, t);
        return;
      }
    }
  }
  class Wue extends ts {
    constructor() {
      super(...arguments), this._ns_event_intercepts = /* @__PURE__ */ new Map();
    }
    start() {
    }
    stop() {
    }
    async _receive_edge_added(t, n, r, o) {
      this.context.worker._zustand && this.context.worker._zustand.on_edge_action({
        type: "add",
        from_remote: !0,
        src_nid: t,
        src_ioid: n,
        trg_nid: r,
        trg_ioid: o
      });
    }
    async _receive_groups(t) {
      this.context.worker._zustand && this.context.worker._zustand.on_group_action({
        type: "set",
        groups: t
      });
    }
    async _receive_node_added(t) {
      if (this.context.worker._zustand)
        return this.context.worker._zustand.on_node_action({
          type: "add",
          node: t,
          id: t.id,
          from_remote: !0
        });
    }
    async receive_workerevent({ event: t, data: n }) {
      switch (t) {
        case "worker_error":
          return this.context.worker._zustand ? this.context.worker._zustand.logger.error(n.error) : void 0;
        case "update_worker_dependencies":
          return this.context.worker._zustand ? this.context.worker._zustand.lib.libstate.getState().set({
            external_worker: n.worker_dependencies
          }) : void 0;
        case "lib_update":
          await this.context.worker.getSyncManager().sync_lib();
          return;
        case "fullsync":
          await this.context.worker.getSyncManager().stepwise_fullsync();
          return;
        case "external_worker_update":
          await this.context.worker.getSyncManager().sync_lib(), await this.context.worker.getSyncManager().sync_external_worker();
          return;
        case "repos_update":
          await this.hookManager.call_hooks(
            "repos_update",
            n.repos ?? n
          );
          return;
        case "starting":
          this.hookManager.call_hooks("starting");
          return;
        case "stopping":
          this.hookManager.call_hooks("stopping");
          return;
        default:
          console.warn("Unhandled worker event", t, n);
          break;
      }
    }
    async intercept_ns_event(t) {
      let n = t;
      for (const r of this._ns_event_intercepts.get(t.event) || [])
        n = await r(n);
      return n;
    }
    async receive_nodespace_event(t) {
      const { event: n, data: r } = await this.intercept_ns_event(t);
      switch (n) {
        case "after_set_value":
          return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              io: {
                [r.io]: {
                  value: r.result
                }
              }
            },
            id: r.node,
            from_remote: !0
          }) : void 0;
        case "after_update_value_options":
          return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              io: {
                [r.io]: {
                  value_options: r.result
                }
              }
            },
            id: r.node,
            from_remote: !0
          }) : void 0;
        case "triggerstart":
          return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              in_trigger: !0
            },
            id: r.node,
            from_remote: !0
          }) : void 0;
        case "triggerdone":
          return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              in_trigger: !1
            },
            id: r.node,
            from_remote: !0
          }) : void 0;
        case "triggerfast":
          if (!this.context.worker._zustand) return;
          this.context.worker._zustand.on_node_action({
            type: "update",
            node: {
              id: r.node,
              in_trigger: !0
            },
            id: r.node,
            from_remote: !0
          }), setTimeout(() => {
            this.context.worker._zustand && this.context.worker._zustand.on_node_action({
              type: "update",
              node: {
                id: r.node,
                in_trigger: !1
              },
              id: r.node,
              from_remote: !0
            });
          }, 50);
          return;
        case "node_trigger_error":
          return this.context.worker._zustand ? this.context.worker._zustand.on_node_action({
            type: "error",
            errortype: "trigger",
            error: r.error,
            id: r.node,
            tb: r.tb,
            from_remote: !0
          }) : void 0;
        case "node_removed":
          if (!this.context.worker._zustand) return;
          this.context.worker._zustand.on_node_action({
            type: "delete",
            id: r.node,
            from_remote: !0
          }), this.hookManager.call_hooks("node_removed", {
            node: r.node
          });
          return;
        case "node_added":
          this._receive_node_added(r.node);
          return;
        case "after_disconnect":
          return !r.result || !Array.isArray(r.result) || r.result.length !== 4 || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.on_edge_action({
            type: "delete",
            from_remote: !0,
            src_nid: r.result[0],
            src_ioid: r.result[1],
            trg_nid: r.result[2],
            trg_ioid: r.result[3]
          });
        case "after_unforward":
          return !r.result || !Array.isArray(r.result) || r.result.length !== 4 || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.on_edge_action({
            type: "delete",
            from_remote: !0,
            src_nid: r.result[0],
            src_ioid: r.result[1],
            trg_nid: r.result[2],
            trg_ioid: r.result[3]
          });
        case "after_connect":
          return !r.result || !Array.isArray(r.result) || r.result.length !== 4 ? void 0 : this._receive_edge_added(
            ...r.result
          );
        case "after_forward":
          return !r.result || !Array.isArray(r.result) || r.result.length !== 4 ? void 0 : this._receive_edge_added(
            ...r.result
          );
        case "after_add_shelf":
          return !r.result || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.lib.libstate.getState().set({
            lib: r.result
          });
        case "after_remove_shelf":
          return !r.result || !this.context.worker._zustand ? void 0 : this.context.worker._zustand.lib.libstate.getState().set({
            lib: r.result
          });
        case "progress":
          if (!this.context.worker._zustand) return;
          if (r.node)
            return this.context.worker._zustand.on_node_action({
              type: "update",
              node: {
                id: r.node,
                progress: r.info
              },
              id: r.node,
              from_remote: !0
            });
          console.warn("Unhandled nodepsace event", n, r);
          break;
        default:
          if (["after_set_nodespace"].includes(n)) return;
          console.warn("Unhandled nodepsace event", n, r);
          break;
      }
    }
    add_ns_event_intercept(t, n) {
      const r = this._ns_event_intercepts.get(t) || [];
      return r.push(n), this._ns_event_intercepts.set(t, r), () => {
        const i = this._ns_event_intercepts.get(t) || [], a = i.indexOf(n);
        a >= 0 && i.splice(a, 1);
      };
    }
  }
  class Gue extends ts {
    constructor() {
      super(...arguments), this._hooks = /* @__PURE__ */ new Map();
    }
    start() {
    }
    stop() {
    }
    add_hook(t, n) {
      const r = this._hooks.get(t) || [];
      return r.push(n), this._hooks.set(t, r), () => {
        const i = this._hooks.get(t) || [], a = i.indexOf(n);
        a >= 0 && i.splice(a, 1);
      };
    }
    async call_hooks(t, n) {
      const r = [];
      for (const o of this._hooks.get(t) || []) {
        const i = o({ worker: this.context.worker, data: n });
        i instanceof Promise && r.push(i);
      }
      await Promise.all(r);
    }
  }
  class Kue extends ts {
    start() {
    }
    stop() {
    }
    async trigger_node(t) {
      await this.communicationManager._send_cmd({
        cmd: "trigger_node",
        kwargs: { nid: t },
        wait_for_response: !1
      });
    }
    async add_node(t) {
      const n = await this.communicationManager._send_cmd({
        cmd: "add_node",
        kwargs: { id: t }
      });
      return this.eventManager._receive_node_added(n);
    }
    async remove_node(t) {
      await this.communicationManager._send_cmd({
        cmd: "remove_node",
        kwargs: { id: t }
      });
    }
    locally_update_node(t) {
      this.syncManager.locally_update_node(t);
    }
    set_io_value({
      nid: t,
      ioid: n,
      value: r,
      set_default: o = !1
    }) {
      return this.communicationManager._send_cmd({
        cmd: "set_io_value",
        kwargs: { nid: t, ioid: n, value: r, set_default: o },
        wait_for_response: !0
      });
    }
    set_io_value_options({
      nid: t,
      ioid: n,
      values: r,
      keys: o,
      nullable: i
    }) {
      return this.communicationManager._send_cmd({
        cmd: "update_io_value_options",
        kwargs: {
          nid: t,
          ioid: n,
          options: {
            options: {
              type: "enum",
              values: r,
              keys: o,
              nullable: i
            }
          }
        }
      });
    }
    async get_io_value({ nid: t, ioid: n }) {
      const r = await this.communicationManager._send_cmd({
        cmd: "get_io_value",
        kwargs: { nid: t, ioid: n },
        wait_for_response: !0
      });
      return this.context.worker._zustand && this.context.worker._zustand.on_node_action({
        type: "update",
        node: {
          io: {
            [n]: {
              value: r
            }
          }
        },
        id: t,
        from_remote: !0
      }), r;
    }
    async get_ios_values({ nid: t }) {
      const n = await this.communicationManager._send_cmd({
        cmd: "get_ios_values",
        kwargs: { nid: t },
        wait_for_response: !0
      });
      if (!this.context.worker._zustand) return n;
      const r = {};
      for (const o in n)
        r[o] = { value: n[o] };
      return this.context.worker._zustand.on_node_action({
        type: "update",
        node: {
          io: r
        },
        id: t,
        from_remote: !0
      }), n;
    }
    async get_io_full_value({ nid: t, ioid: n }) {
      const r = await this.communicationManager._send_cmd({
        cmd: "get_io_full_value",
        kwargs: { nid: t, ioid: n },
        wait_for_response: !0,
        as_bytes: !0
      }), { header: o, bytes: i } = r, { mime: a } = o, s = d9({
        data: i,
        mime: a || "application/octet-stream"
      });
      return this.context.worker._zustand?.on_node_action?.({
        type: "update",
        node: {
          id: t,
          io: {
            [n]: {
              fullvalue: s
            }
          }
        },
        id: t,
        from_remote: !0
      }), s;
    }
    async update_io_options({
      nid: t,
      ioid: n,
      options: r
    }) {
      const o = await this.communicationManager._send_cmd({
        cmd: "update_io_options",
        kwargs: { nid: t, ioid: n, ...r },
        wait_for_response: !0
      });
      if (!this.context.worker._zustand) return o;
      this.context.worker._zustand.on_node_action({
        type: "update",
        node: {
          io: {
            [n]: {
              ...r
            }
          }
        },
        id: t,
        from_remote: !0
      });
    }
    async get_node_status(t) {
      return await this.communicationManager._send_cmd({
        cmd: "get_node_state",
        kwargs: { nid: t },
        wait_for_response: !0
      });
    }
    async get_remote_node_state(t) {
      const n = await this.communicationManager._send_cmd({
        cmd: "get_node_state",
        kwargs: { nid: t },
        wait_for_response: !0
      });
      this.context.worker._zustand && this.context.worker._zustand.on_node_action({
        type: "update",
        node: n,
        id: n.id,
        from_remote: !0
      });
    }
  }
  class Yue extends ts {
    start() {
    }
    stop() {
    }
    add_edge({
      src_nid: t,
      src_ioid: n,
      trg_nid: r,
      trg_ioid: o,
      replace: i = !1
    }) {
      return this.communicationManager._send_cmd({
        cmd: "add_edge",
        kwargs: { src_nid: t, src_ioid: n, trg_nid: r, trg_ioid: o, replace: i }
      });
    }
    remove_edge({
      src_nid: t,
      src_ioid: n,
      trg_nid: r,
      trg_ioid: o
    }) {
      return this.communicationManager._send_cmd({
        cmd: "remove_edge",
        kwargs: { src_nid: t, src_ioid: n, trg_nid: r, trg_ioid: o }
      });
    }
  }
  class Xue extends ts {
    start() {
    }
    stop() {
    }
    async group_nodes(t, n) {
      const r = await this.communicationManager._send_cmd({
        cmd: "group_nodes",
        kwargs: { node_ids: t, group_ids: n },
        wait_for_response: !0
      });
      return this.eventManager._receive_groups(r), r;
    }
    async remove_group(t) {
      await this.communicationManager._send_cmd({
        cmd: "remove_group",
        kwargs: { gid: t },
        wait_for_response: !0
      }), await this.syncManager.sync_nodespace();
    }
    locally_update_group(t) {
      this.syncManager.locally_update_group(t);
    }
  }
  class Zue extends ts {
    constructor() {
      super(...arguments), this._available_modules_cache = {
        installed: [],
        available: [],
        active: []
      };
    }
    start() {
    }
    stop() {
    }
    async add_external_worker({
      module: t,
      cls_module: n,
      cls_name: r
    }) {
      return await this.communicationManager._send_cmd({
        cmd: "add_external_worker",
        kwargs: { module: t, cls_module: n, cls_name: r }
      });
    }
    async add_lib(t, n) {
      return await this.communicationManager._send_cmd({
        cmd: "add_package_dependency",
        kwargs: { name: t, version: n },
        wait_for_response: !1
      });
    }
    async remove_lib(t) {
      return await this.communicationManager._send_cmd({
        cmd: "remove_package_dependency",
        kwargs: { name: t },
        wait_for_response: !1
      });
    }
    async get_available_modules({
      wait_for_response: t = !1,
      on_load: n
    }) {
      const r = this.communicationManager._send_cmd({
        cmd: "get_available_modules",
        wait_for_response: !0,
        unique: !0
      }).then((o) => {
        this._available_modules_cache = o, n && n(this._available_modules_cache);
      });
      return t && await r, this._available_modules_cache;
    }
    async remove_external_worker(t, n) {
      return await this.communicationManager._send_cmd({
        cmd: "remove_external_worker",
        kwargs: { worker_id: t, class_id: n },
        wait_for_response: !0
      });
    }
    async get_external_worker_config(t, n) {
      return await this.communicationManager._send_cmd({
        cmd: "get_external_worker_config",
        kwargs: { worker_id: t, class_id: n },
        wait_for_response: !0
      });
    }
  }
  class p9 {
    // Public getter for handlers to access eventManager
    getEventManager() {
      return this._eventManager;
    }
    getSyncManager() {
      return this._syncManager;
    }
    getCommunicationManager() {
      return this._communicationManager;
    }
    getConnectionHealthManager() {
      return this._connectionhealthManager;
    }
    getHookManager() {
      return this._hookManager;
    }
    getNodeManager() {
      return this._nodeManager;
    }
    getEdgeManager() {
      return this._edgeManager;
    }
    getGroupManager() {
      return this._groupManager;
    }
    getLibraryManager() {
      return this._libraryManager;
    }
    constructor(t) {
      this.uuid = t.uuid, this.on_error = t.on_error || ((r) => {
        this._zustand?.logger.error(r);
      }), this.state = No((r, o) => ({
        is_open: !1
      }));
      const n = { worker: this };
      this._connectionhealthManager = new Uue(
        n
      ), this._communicationManager = new que(n), this._eventManager = new Wue({
        ...n
      }), this._syncManager = new Vue({
        ...n,
        on_sync_complete: t.on_sync_complete
      }), this._hookManager = new Gue(n), this._nodeManager = new Kue(n), this._edgeManager = new Yue(n), this._groupManager = new Xue(n), this._libraryManager = new Zue(n), this._communicationManager.start(), this._connectionhealthManager.start(), this._syncManager.start(), this._eventManager.start(), this._hookManager.start(), this._nodeManager.start(), this._edgeManager.start(), this._groupManager.start(), this._libraryManager.start(), t.zustand && this.set_zustand(t.zustand), this.api = {
        node: this._nodeManager,
        group: this._groupManager,
        edge: this._edgeManager,
        hooks: this._hookManager,
        lib: this._libraryManager
      };
    }
    set_zustand(t) {
      t !== this._zustand && (t.logger.debug("Setting zustand for worker"), this._zustand = t, t.set_worker(this), this._zustand.auto_progress(), this._syncManager.stepwise_fullsync());
    }
    get is_open() {
      return this.state.getState().is_open;
    }
    set is_open(t) {
      this.state.setState({ is_open: t });
    }
    get is_responsive() {
      return this._connectionhealthManager.isResponsive();
    }
    clear() {
      return this._communicationManager._send_cmd({ cmd: "clear", unique: !0 });
    }
    save() {
      return this._communicationManager._send_cmd({
        cmd: "save",
        wait_for_response: !0,
        unique: !0
      });
    }
    load(t) {
      return this._communicationManager._send_cmd({
        cmd: "load_data",
        kwargs: { data: t },
        wait_for_response: !0
      }).then(() => {
        this._syncManager.stepwise_fullsync();
      });
    }
    async get_runstate() {
      return await this._communicationManager._send_cmd({
        cmd: "get_runstate",
        wait_for_response: !0,
        unique: !0
      });
    }
    async send(t) {
      throw new Error("async send(data: any)  not implemented");
    }
    async upload_file(t) {
      throw new Error("upload_file not implemented ");
    }
    async handle_large_message_hint({}) {
      throw new Error(
        "async handle_large_message_hint({}: LargeMessageHint) not implemented "
      );
    }
    disconnect() {
    }
    onclose() {
      this.is_open = !1, this._zustand && this._zustand.auto_progress();
    }
    async reconnect() {
    }
    async stop() {
      window.localStorage.getItem("funcnodes__active_worker") == this.uuid && window.localStorage.removeItem("funcnodes__active_worker"), await this._communicationManager._send_cmd({
        cmd: "stop_worker",
        wait_for_response: !1
      });
      const n = this.onclose.bind(this);
      this.onclose = () => {
        n(), this._zustand && (this._zustand.worker === this && this._zustand.clear_all(), this.onclose = n);
      };
    }
    async update_external_worker(t, n, r) {
      return await this._communicationManager._send_cmd({
        cmd: "update_external_worker",
        kwargs: { worker_id: t, class_id: n, ...r },
        wait_for_response: !0
      });
    }
    async export({ withFiles: t = !1 }) {
      return await this._communicationManager._send_cmd({
        cmd: "export_worker",
        wait_for_response: !0,
        kwargs: { with_files: t }
      });
    }
    async update_from_export(t) {
      const n = this._hookManager.add_hook("node_added", async ({}) => {
        this._zustand?.center_all();
      });
      try {
        const r = await this._communicationManager._send_cmd({
          cmd: "update_from_export",
          kwargs: { data: t },
          wait_for_response: !0,
          response_timeout: 6e5,
          // 10 minutes
          unique: !0
        });
        return await new Promise((o) => {
          setTimeout(() => {
            o();
          }, 1e3);
        }), await this._syncManager.stepwise_fullsync(), r;
      } finally {
        n();
      }
    }
    /**
     * @deprecated This method is deprecated. Use the API or getCommunicationManager()._send_cmd directly instead.
     */
    _send_cmd(t) {
      return this._communicationManager._send_cmd(t);
    }
    /**
     * @deprecated This method is deprecated. Use the API or getNodeManager().set_io_value directly instead.
     */
    set_io_value(t) {
      return this._nodeManager.set_io_value(t);
    }
    /**
     * @deprecated This method is deprecated. Use the API or getNodeManager().get_io_value directly instead.
     */
    get_io_value(t) {
      return this._nodeManager.get_io_value(t);
    }
  }
  function h9(e, t) {
    return function() {
      return e.apply(t, arguments);
    };
  }
  const { toString: Que } = Object.prototype, { getPrototypeOf: bT } = Object, { iterator: Ub, toStringTag: m9 } = Symbol, Vb = /* @__PURE__ */ ((e) => (t) => {
    const n = Que.call(t);
    return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null)), si = (e) => (e = e.toLowerCase(), (t) => Vb(t) === e), Hb = (e) => (t) => typeof t === e, { isArray: zf } = Array, yf = Hb("undefined");
  function Kh(e) {
    return e !== null && !yf(e) && e.constructor !== null && !yf(e.constructor) && Ur(e.constructor.isBuffer) && e.constructor.isBuffer(e);
  }
  const g9 = si("ArrayBuffer");
  function Jue(e) {
    let t;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && g9(e.buffer), t;
  }
  const efe = Hb("string"), Ur = Hb("function"), y9 = Hb("number"), Yh = (e) => e !== null && typeof e == "object", tfe = (e) => e === !0 || e === !1, $v = (e) => {
    if (Vb(e) !== "object")
      return !1;
    const t = bT(e);
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(m9 in e) && !(Ub in e);
  }, nfe = (e) => {
    if (!Yh(e) || Kh(e))
      return !1;
    try {
      return Object.keys(e).length === 0 && Object.getPrototypeOf(e) === Object.prototype;
    } catch {
      return !1;
    }
  }, rfe = si("Date"), ofe = si("File"), ife = si("Blob"), afe = si("FileList"), sfe = (e) => Yh(e) && Ur(e.pipe), lfe = (e) => {
    let t;
    return e && (typeof FormData == "function" && e instanceof FormData || Ur(e.append) && ((t = Vb(e)) === "formdata" || // detect form-data instance
    t === "object" && Ur(e.toString) && e.toString() === "[object FormData]"));
  }, cfe = si("URLSearchParams"), [ufe, ffe, dfe, pfe] = ["ReadableStream", "Request", "Response", "Headers"].map(si), hfe = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function Xh(e, t, { allOwnKeys: n = !1 } = {}) {
    if (e === null || typeof e > "u")
      return;
    let r, o;
    if (typeof e != "object" && (e = [e]), zf(e))
      for (r = 0, o = e.length; r < o; r++)
        t.call(null, e[r], r, e);
    else {
      if (Kh(e))
        return;
      const i = n ? Object.getOwnPropertyNames(e) : Object.keys(e), a = i.length;
      let s;
      for (r = 0; r < a; r++)
        s = i[r], t.call(null, e[s], s, e);
    }
  }
  function v9(e, t) {
    if (Kh(e))
      return null;
    t = t.toLowerCase();
    const n = Object.keys(e);
    let r = n.length, o;
    for (; r-- > 0; )
      if (o = n[r], t === o.toLowerCase())
        return o;
    return null;
  }
  const nc = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : window, b9 = (e) => !yf(e) && e !== nc;
  function eC() {
    const { caseless: e, skipUndefined: t } = b9(this) && this || {}, n = {}, r = (o, i) => {
      const a = e && v9(n, i) || i;
      $v(n[a]) && $v(o) ? n[a] = eC(n[a], o) : $v(o) ? n[a] = eC({}, o) : zf(o) ? n[a] = o.slice() : (!t || !yf(o)) && (n[a] = o);
    };
    for (let o = 0, i = arguments.length; o < i; o++)
      arguments[o] && Xh(arguments[o], r);
    return n;
  }
  const mfe = (e, t, n, { allOwnKeys: r } = {}) => (Xh(t, (o, i) => {
    n && Ur(o) ? e[i] = h9(o, n) : e[i] = o;
  }, { allOwnKeys: r }), e), gfe = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), yfe = (e, t, n, r) => {
    e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
      value: t.prototype
    }), n && Object.assign(e.prototype, n);
  }, vfe = (e, t, n, r) => {
    let o, i, a;
    const s = {};
    if (t = t || {}, e == null) return t;
    do {
      for (o = Object.getOwnPropertyNames(e), i = o.length; i-- > 0; )
        a = o[i], (!r || r(a, e, t)) && !s[a] && (t[a] = e[a], s[a] = !0);
      e = n !== !1 && bT(e);
    } while (e && (!n || n(e, t)) && e !== Object.prototype);
    return t;
  }, bfe = (e, t, n) => {
    e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
    const r = e.indexOf(t, n);
    return r !== -1 && r === n;
  }, xfe = (e) => {
    if (!e) return null;
    if (zf(e)) return e;
    let t = e.length;
    if (!y9(t)) return null;
    const n = new Array(t);
    for (; t-- > 0; )
      n[t] = e[t];
    return n;
  }, wfe = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && bT(Uint8Array)), Sfe = (e, t) => {
    const r = (e && e[Ub]).call(e);
    let o;
    for (; (o = r.next()) && !o.done; ) {
      const i = o.value;
      t.call(e, i[0], i[1]);
    }
  }, _fe = (e, t) => {
    let n;
    const r = [];
    for (; (n = e.exec(t)) !== null; )
      r.push(n);
    return r;
  }, Efe = si("HTMLFormElement"), Cfe = (e) => e.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function(n, r, o) {
      return r.toUpperCase() + o;
    }
  ), l$ = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), kfe = si("RegExp"), x9 = (e, t) => {
    const n = Object.getOwnPropertyDescriptors(e), r = {};
    Xh(n, (o, i) => {
      let a;
      (a = t(o, i, e)) !== !1 && (r[i] = a || o);
    }), Object.defineProperties(e, r);
  }, Tfe = (e) => {
    x9(e, (t, n) => {
      if (Ur(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
        return !1;
      const r = e[n];
      if (Ur(r)) {
        if (t.enumerable = !1, "writable" in t) {
          t.writable = !1;
          return;
        }
        t.set || (t.set = () => {
          throw Error("Can not rewrite read-only method '" + n + "'");
        });
      }
    });
  }, Afe = (e, t) => {
    const n = {}, r = (o) => {
      o.forEach((i) => {
        n[i] = !0;
      });
    };
    return zf(e) ? r(e) : r(String(e).split(t)), n;
  }, Rfe = () => {
  }, Ofe = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
  function Mfe(e) {
    return !!(e && Ur(e.append) && e[m9] === "FormData" && e[Ub]);
  }
  const Nfe = (e) => {
    const t = new Array(10), n = (r, o) => {
      if (Yh(r)) {
        if (t.indexOf(r) >= 0)
          return;
        if (Kh(r))
          return r;
        if (!("toJSON" in r)) {
          t[o] = r;
          const i = zf(r) ? [] : {};
          return Xh(r, (a, s) => {
            const c = n(a, o + 1);
            !yf(c) && (i[s] = c);
          }), t[o] = void 0, i;
        }
      }
      return r;
    };
    return n(e, 0);
  }, Pfe = si("AsyncFunction"), Ife = (e) => e && (Yh(e) || Ur(e)) && Ur(e.then) && Ur(e.catch), w9 = ((e, t) => e ? setImmediate : t ? ((n, r) => (nc.addEventListener("message", ({ source: o, data: i }) => {
    o === nc && i === n && r.length && r.shift()();
  }, !1), (o) => {
    r.push(o), nc.postMessage(n, "*");
  }))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
    typeof setImmediate == "function",
    Ur(nc.postMessage)
  ), $fe = typeof queueMicrotask < "u" ? queueMicrotask.bind(nc) : typeof process < "u" && process.nextTick || w9, jfe = (e) => e != null && Ur(e[Ub]), me = {
    isArray: zf,
    isArrayBuffer: g9,
    isBuffer: Kh,
    isFormData: lfe,
    isArrayBufferView: Jue,
    isString: efe,
    isNumber: y9,
    isBoolean: tfe,
    isObject: Yh,
    isPlainObject: $v,
    isEmptyObject: nfe,
    isReadableStream: ufe,
    isRequest: ffe,
    isResponse: dfe,
    isHeaders: pfe,
    isUndefined: yf,
    isDate: rfe,
    isFile: ofe,
    isBlob: ife,
    isRegExp: kfe,
    isFunction: Ur,
    isStream: sfe,
    isURLSearchParams: cfe,
    isTypedArray: wfe,
    isFileList: afe,
    forEach: Xh,
    merge: eC,
    extend: mfe,
    trim: hfe,
    stripBOM: gfe,
    inherits: yfe,
    toFlatObject: vfe,
    kindOf: Vb,
    kindOfTest: si,
    endsWith: bfe,
    toArray: xfe,
    forEachEntry: Sfe,
    matchAll: _fe,
    isHTMLForm: Efe,
    hasOwnProperty: l$,
    hasOwnProp: l$,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors: x9,
    freezeMethods: Tfe,
    toObjectSet: Afe,
    toCamelCase: Cfe,
    noop: Rfe,
    toFiniteNumber: Ofe,
    findKey: v9,
    global: nc,
    isContextDefined: b9,
    isSpecCompliantForm: Mfe,
    toJSONObject: Nfe,
    isAsyncFn: Pfe,
    isThenable: Ife,
    setImmediate: w9,
    asap: $fe,
    isIterable: jfe
  };
  function ct(e, t, n, r, o) {
    Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), o && (this.response = o, this.status = o.status ? o.status : null);
  }
  me.inherits(ct, Error, {
    toJSON: function() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: me.toJSONObject(this.config),
        code: this.code,
        status: this.status
      };
    }
  });
  const S9 = ct.prototype, _9 = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((e) => {
    _9[e] = { value: e };
  });
  Object.defineProperties(ct, _9);
  Object.defineProperty(S9, "isAxiosError", { value: !0 });
  ct.from = (e, t, n, r, o, i) => {
    const a = Object.create(S9);
    me.toFlatObject(e, a, function(d) {
      return d !== Error.prototype;
    }, (u) => u !== "isAxiosError");
    const s = e && e.message ? e.message : "Error", c = t == null && e ? e.code : t;
    return ct.call(a, s, c, n, r, o), e && a.cause == null && Object.defineProperty(a, "cause", { value: e, configurable: !0 }), a.name = e && e.name || "Error", i && Object.assign(a, i), a;
  };
  const Dfe = null;
  function tC(e) {
    return me.isPlainObject(e) || me.isArray(e);
  }
  function E9(e) {
    return me.endsWith(e, "[]") ? e.slice(0, -2) : e;
  }
  function c$(e, t, n) {
    return e ? e.concat(t).map(function(o, i) {
      return o = E9(o), !n && i ? "[" + o + "]" : o;
    }).join(n ? "." : "") : t;
  }
  function Ffe(e) {
    return me.isArray(e) && !e.some(tC);
  }
  const Lfe = me.toFlatObject(me, {}, null, function(t) {
    return /^is[A-Z]/.test(t);
  });
  function qb(e, t, n) {
    if (!me.isObject(e))
      throw new TypeError("target must be an object");
    t = t || new FormData(), n = me.toFlatObject(n, {
      metaTokens: !0,
      dots: !1,
      indexes: !1
    }, !1, function(b, v) {
      return !me.isUndefined(v[b]);
    });
    const r = n.metaTokens, o = n.visitor || d, i = n.dots, a = n.indexes, c = (n.Blob || typeof Blob < "u" && Blob) && me.isSpecCompliantForm(t);
    if (!me.isFunction(o))
      throw new TypeError("visitor must be a function");
    function u(y) {
      if (y === null) return "";
      if (me.isDate(y))
        return y.toISOString();
      if (me.isBoolean(y))
        return y.toString();
      if (!c && me.isBlob(y))
        throw new ct("Blob is not supported. Use a Buffer instead.");
      return me.isArrayBuffer(y) || me.isTypedArray(y) ? c && typeof Blob == "function" ? new Blob([y]) : Buffer.from(y) : y;
    }
    function d(y, b, v) {
      let x = y;
      if (y && !v && typeof y == "object") {
        if (me.endsWith(b, "{}"))
          b = r ? b : b.slice(0, -2), y = JSON.stringify(y);
        else if (me.isArray(y) && Ffe(y) || (me.isFileList(y) || me.endsWith(b, "[]")) && (x = me.toArray(y)))
          return b = E9(b), x.forEach(function(_, C) {
            !(me.isUndefined(_) || _ === null) && t.append(
              // eslint-disable-next-line no-nested-ternary
              a === !0 ? c$([b], C, i) : a === null ? b : b + "[]",
              u(_)
            );
          }), !1;
      }
      return tC(y) ? !0 : (t.append(c$(v, b, i), u(y)), !1);
    }
    const p = [], m = Object.assign(Lfe, {
      defaultVisitor: d,
      convertValue: u,
      isVisitable: tC
    });
    function g(y, b) {
      if (!me.isUndefined(y)) {
        if (p.indexOf(y) !== -1)
          throw Error("Circular reference detected in " + b.join("."));
        p.push(y), me.forEach(y, function(x, E) {
          (!(me.isUndefined(x) || x === null) && o.call(
            t,
            x,
            me.isString(E) ? E.trim() : E,
            b,
            m
          )) === !0 && g(x, b ? b.concat(E) : [E]);
        }), p.pop();
      }
    }
    if (!me.isObject(e))
      throw new TypeError("data must be an object");
    return g(e), t;
  }
  function u$(e) {
    const t = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
      return t[r];
    });
  }
  function xT(e, t) {
    this._pairs = [], e && qb(e, this, t);
  }
  const C9 = xT.prototype;
  C9.append = function(t, n) {
    this._pairs.push([t, n]);
  };
  C9.toString = function(t) {
    const n = t ? function(r) {
      return t.call(this, r, u$);
    } : u$;
    return this._pairs.map(function(o) {
      return n(o[0]) + "=" + n(o[1]);
    }, "").join("&");
  };
  function zfe(e) {
    return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
  }
  function k9(e, t, n) {
    if (!t)
      return e;
    const r = n && n.encode || zfe;
    me.isFunction(n) && (n = {
      serialize: n
    });
    const o = n && n.serialize;
    let i;
    if (o ? i = o(t, n) : i = me.isURLSearchParams(t) ? t.toString() : new xT(t, n).toString(r), i) {
      const a = e.indexOf("#");
      a !== -1 && (e = e.slice(0, a)), e += (e.indexOf("?") === -1 ? "?" : "&") + i;
    }
    return e;
  }
  class f$ {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(t, n, r) {
      return this.handlers.push({
        fulfilled: t,
        rejected: n,
        synchronous: r ? r.synchronous : !1,
        runWhen: r ? r.runWhen : null
      }), this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {void}
     */
    eject(t) {
      this.handlers[t] && (this.handlers[t] = null);
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      this.handlers && (this.handlers = []);
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(t) {
      me.forEach(this.handlers, function(r) {
        r !== null && t(r);
      });
    }
  }
  const T9 = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
  }, Bfe = typeof URLSearchParams < "u" ? URLSearchParams : xT, Ufe = typeof FormData < "u" ? FormData : null, Vfe = typeof Blob < "u" ? Blob : null, Hfe = {
    isBrowser: !0,
    classes: {
      URLSearchParams: Bfe,
      FormData: Ufe,
      Blob: Vfe
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
  }, wT = typeof window < "u" && typeof document < "u", nC = typeof navigator == "object" && navigator || void 0, qfe = wT && (!nC || ["ReactNative", "NativeScript", "NS"].indexOf(nC.product) < 0), Wfe = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts == "function", Gfe = wT && window.location.href || "http://localhost", Kfe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    hasBrowserEnv: wT,
    hasStandardBrowserEnv: qfe,
    hasStandardBrowserWebWorkerEnv: Wfe,
    navigator: nC,
    origin: Gfe
  }, Symbol.toStringTag, { value: "Module" })), yr = {
    ...Kfe,
    ...Hfe
  };
  function Yfe(e, t) {
    return qb(e, new yr.classes.URLSearchParams(), {
      visitor: function(n, r, o, i) {
        return yr.isNode && me.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : i.defaultVisitor.apply(this, arguments);
      },
      ...t
    });
  }
  function Xfe(e) {
    return me.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
  }
  function Zfe(e) {
    const t = {}, n = Object.keys(e);
    let r;
    const o = n.length;
    let i;
    for (r = 0; r < o; r++)
      i = n[r], t[i] = e[i];
    return t;
  }
  function A9(e) {
    function t(n, r, o, i) {
      let a = n[i++];
      if (a === "__proto__") return !0;
      const s = Number.isFinite(+a), c = i >= n.length;
      return a = !a && me.isArray(o) ? o.length : a, c ? (me.hasOwnProp(o, a) ? o[a] = [o[a], r] : o[a] = r, !s) : ((!o[a] || !me.isObject(o[a])) && (o[a] = []), t(n, r, o[a], i) && me.isArray(o[a]) && (o[a] = Zfe(o[a])), !s);
    }
    if (me.isFormData(e) && me.isFunction(e.entries)) {
      const n = {};
      return me.forEachEntry(e, (r, o) => {
        t(Xfe(r), o, n, 0);
      }), n;
    }
    return null;
  }
  function Qfe(e, t, n) {
    if (me.isString(e))
      try {
        return (t || JSON.parse)(e), me.trim(e);
      } catch (r) {
        if (r.name !== "SyntaxError")
          throw r;
      }
    return (n || JSON.stringify)(e);
  }
  const Zh = {
    transitional: T9,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function(t, n) {
      const r = n.getContentType() || "", o = r.indexOf("application/json") > -1, i = me.isObject(t);
      if (i && me.isHTMLForm(t) && (t = new FormData(t)), me.isFormData(t))
        return o ? JSON.stringify(A9(t)) : t;
      if (me.isArrayBuffer(t) || me.isBuffer(t) || me.isStream(t) || me.isFile(t) || me.isBlob(t) || me.isReadableStream(t))
        return t;
      if (me.isArrayBufferView(t))
        return t.buffer;
      if (me.isURLSearchParams(t))
        return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
      let s;
      if (i) {
        if (r.indexOf("application/x-www-form-urlencoded") > -1)
          return Yfe(t, this.formSerializer).toString();
        if ((s = me.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
          const c = this.env && this.env.FormData;
          return qb(
            s ? { "files[]": t } : t,
            c && new c(),
            this.formSerializer
          );
        }
      }
      return i || o ? (n.setContentType("application/json", !1), Qfe(t)) : t;
    }],
    transformResponse: [function(t) {
      const n = this.transitional || Zh.transitional, r = n && n.forcedJSONParsing, o = this.responseType === "json";
      if (me.isResponse(t) || me.isReadableStream(t))
        return t;
      if (t && me.isString(t) && (r && !this.responseType || o)) {
        const a = !(n && n.silentJSONParsing) && o;
        try {
          return JSON.parse(t, this.parseReviver);
        } catch (s) {
          if (a)
            throw s.name === "SyntaxError" ? ct.from(s, ct.ERR_BAD_RESPONSE, this, null, this.response) : s;
        }
      }
      return t;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: yr.classes.FormData,
      Blob: yr.classes.Blob
    },
    validateStatus: function(t) {
      return t >= 200 && t < 300;
    },
    headers: {
      common: {
        Accept: "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  me.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
    Zh.headers[e] = {};
  });
  const Jfe = me.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]), ede = (e) => {
    const t = {};
    let n, r, o;
    return e && e.split(`
`).forEach(function(a) {
      o = a.indexOf(":"), n = a.substring(0, o).trim().toLowerCase(), r = a.substring(o + 1).trim(), !(!n || t[n] && Jfe[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
    }), t;
  }, d$ = /* @__PURE__ */ Symbol("internals");
  function Kd(e) {
    return e && String(e).trim().toLowerCase();
  }
  function jv(e) {
    return e === !1 || e == null ? e : me.isArray(e) ? e.map(jv) : String(e);
  }
  function tde(e) {
    const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let r;
    for (; r = n.exec(e); )
      t[r[1]] = r[2];
    return t;
  }
  const nde = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
  function XS(e, t, n, r, o) {
    if (me.isFunction(r))
      return r.call(this, t, n);
    if (o && (t = n), !!me.isString(t)) {
      if (me.isString(r))
        return t.indexOf(r) !== -1;
      if (me.isRegExp(r))
        return r.test(t);
    }
  }
  function rde(e) {
    return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
  }
  function ode(e, t) {
    const n = me.toCamelCase(" " + t);
    ["get", "set", "has"].forEach((r) => {
      Object.defineProperty(e, r + n, {
        value: function(o, i, a) {
          return this[r].call(this, t, o, i, a);
        },
        configurable: !0
      });
    });
  }
  let Vr = class {
    constructor(t) {
      t && this.set(t);
    }
    set(t, n, r) {
      const o = this;
      function i(s, c, u) {
        const d = Kd(c);
        if (!d)
          throw new Error("header name must be a non-empty string");
        const p = me.findKey(o, d);
        (!p || o[p] === void 0 || u === !0 || u === void 0 && o[p] !== !1) && (o[p || c] = jv(s));
      }
      const a = (s, c) => me.forEach(s, (u, d) => i(u, d, c));
      if (me.isPlainObject(t) || t instanceof this.constructor)
        a(t, n);
      else if (me.isString(t) && (t = t.trim()) && !nde(t))
        a(ede(t), n);
      else if (me.isObject(t) && me.isIterable(t)) {
        let s = {}, c, u;
        for (const d of t) {
          if (!me.isArray(d))
            throw TypeError("Object iterator must return a key-value pair");
          s[u = d[0]] = (c = s[u]) ? me.isArray(c) ? [...c, d[1]] : [c, d[1]] : d[1];
        }
        a(s, n);
      } else
        t != null && i(n, t, r);
      return this;
    }
    get(t, n) {
      if (t = Kd(t), t) {
        const r = me.findKey(this, t);
        if (r) {
          const o = this[r];
          if (!n)
            return o;
          if (n === !0)
            return tde(o);
          if (me.isFunction(n))
            return n.call(this, o, r);
          if (me.isRegExp(n))
            return n.exec(o);
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(t, n) {
      if (t = Kd(t), t) {
        const r = me.findKey(this, t);
        return !!(r && this[r] !== void 0 && (!n || XS(this, this[r], r, n)));
      }
      return !1;
    }
    delete(t, n) {
      const r = this;
      let o = !1;
      function i(a) {
        if (a = Kd(a), a) {
          const s = me.findKey(r, a);
          s && (!n || XS(r, r[s], s, n)) && (delete r[s], o = !0);
        }
      }
      return me.isArray(t) ? t.forEach(i) : i(t), o;
    }
    clear(t) {
      const n = Object.keys(this);
      let r = n.length, o = !1;
      for (; r--; ) {
        const i = n[r];
        (!t || XS(this, this[i], i, t, !0)) && (delete this[i], o = !0);
      }
      return o;
    }
    normalize(t) {
      const n = this, r = {};
      return me.forEach(this, (o, i) => {
        const a = me.findKey(r, i);
        if (a) {
          n[a] = jv(o), delete n[i];
          return;
        }
        const s = t ? rde(i) : String(i).trim();
        s !== i && delete n[i], n[s] = jv(o), r[s] = !0;
      }), this;
    }
    concat(...t) {
      return this.constructor.concat(this, ...t);
    }
    toJSON(t) {
      const n = /* @__PURE__ */ Object.create(null);
      return me.forEach(this, (r, o) => {
        r != null && r !== !1 && (n[o] = t && me.isArray(r) ? r.join(", ") : r);
      }), n;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
    }
    getSetCookie() {
      return this.get("set-cookie") || [];
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(t) {
      return t instanceof this ? t : new this(t);
    }
    static concat(t, ...n) {
      const r = new this(t);
      return n.forEach((o) => r.set(o)), r;
    }
    static accessor(t) {
      const r = (this[d$] = this[d$] = {
        accessors: {}
      }).accessors, o = this.prototype;
      function i(a) {
        const s = Kd(a);
        r[s] || (ode(o, a), r[s] = !0);
      }
      return me.isArray(t) ? t.forEach(i) : i(t), this;
    }
  };
  Vr.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  me.reduceDescriptors(Vr.prototype, ({ value: e }, t) => {
    let n = t[0].toUpperCase() + t.slice(1);
    return {
      get: () => e,
      set(r) {
        this[n] = r;
      }
    };
  });
  me.freezeMethods(Vr);
  function ZS(e, t) {
    const n = this || Zh, r = t || n, o = Vr.from(r.headers);
    let i = r.data;
    return me.forEach(e, function(s) {
      i = s.call(n, i, o.normalize(), t ? t.status : void 0);
    }), o.normalize(), i;
  }
  function R9(e) {
    return !!(e && e.__CANCEL__);
  }
  function Bf(e, t, n) {
    ct.call(this, e ?? "canceled", ct.ERR_CANCELED, t, n), this.name = "CanceledError";
  }
  me.inherits(Bf, ct, {
    __CANCEL__: !0
  });
  function O9(e, t, n) {
    const r = n.config.validateStatus;
    !n.status || !r || r(n.status) ? e(n) : t(new ct(
      "Request failed with status code " + n.status,
      [ct.ERR_BAD_REQUEST, ct.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
      n.config,
      n.request,
      n
    ));
  }
  function ide(e) {
    const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
    return t && t[1] || "";
  }
  function ade(e, t) {
    e = e || 10;
    const n = new Array(e), r = new Array(e);
    let o = 0, i = 0, a;
    return t = t !== void 0 ? t : 1e3, function(c) {
      const u = Date.now(), d = r[i];
      a || (a = u), n[o] = c, r[o] = u;
      let p = i, m = 0;
      for (; p !== o; )
        m += n[p++], p = p % e;
      if (o = (o + 1) % e, o === i && (i = (i + 1) % e), u - a < t)
        return;
      const g = d && u - d;
      return g ? Math.round(m * 1e3 / g) : void 0;
    };
  }
  function sde(e, t) {
    let n = 0, r = 1e3 / t, o, i;
    const a = (u, d = Date.now()) => {
      n = d, o = null, i && (clearTimeout(i), i = null), e(...u);
    };
    return [(...u) => {
      const d = Date.now(), p = d - n;
      p >= r ? a(u, d) : (o = u, i || (i = setTimeout(() => {
        i = null, a(o);
      }, r - p)));
    }, () => o && a(o)];
  }
  const x0 = (e, t, n = 3) => {
    let r = 0;
    const o = ade(50, 250);
    return sde((i) => {
      const a = i.loaded, s = i.lengthComputable ? i.total : void 0, c = a - r, u = o(c), d = a <= s;
      r = a;
      const p = {
        loaded: a,
        total: s,
        progress: s ? a / s : void 0,
        bytes: c,
        rate: u || void 0,
        estimated: u && s && d ? (s - a) / u : void 0,
        event: i,
        lengthComputable: s != null,
        [t ? "download" : "upload"]: !0
      };
      e(p);
    }, n);
  }, p$ = (e, t) => {
    const n = e != null;
    return [(r) => t[0]({
      lengthComputable: n,
      total: e,
      loaded: r
    }), t[1]];
  }, h$ = (e) => (...t) => me.asap(() => e(...t)), lde = yr.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t) => (n) => (n = new URL(n, yr.origin), e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(
    new URL(yr.origin),
    yr.navigator && /(msie|trident)/i.test(yr.navigator.userAgent)
  ) : () => !0, cde = yr.hasStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    {
      write(e, t, n, r, o, i, a) {
        if (typeof document > "u") return;
        const s = [`${e}=${encodeURIComponent(t)}`];
        me.isNumber(n) && s.push(`expires=${new Date(n).toUTCString()}`), me.isString(r) && s.push(`path=${r}`), me.isString(o) && s.push(`domain=${o}`), i === !0 && s.push("secure"), me.isString(a) && s.push(`SameSite=${a}`), document.cookie = s.join("; ");
      },
      read(e) {
        if (typeof document > "u") return null;
        const t = document.cookie.match(new RegExp("(?:^|; )" + e + "=([^;]*)"));
        return t ? decodeURIComponent(t[1]) : null;
      },
      remove(e) {
        this.write(e, "", Date.now() - 864e5, "/");
      }
    }
  ) : (
    // Non-standard browser env (web workers, react-native) lack needed support.
    {
      write() {
      },
      read() {
        return null;
      },
      remove() {
      }
    }
  );
  function ude(e) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
  }
  function fde(e, t) {
    return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
  }
  function M9(e, t, n) {
    let r = !ude(t);
    return e && (r || n == !1) ? fde(e, t) : t;
  }
  const m$ = (e) => e instanceof Vr ? { ...e } : e;
  function pc(e, t) {
    t = t || {};
    const n = {};
    function r(u, d, p, m) {
      return me.isPlainObject(u) && me.isPlainObject(d) ? me.merge.call({ caseless: m }, u, d) : me.isPlainObject(d) ? me.merge({}, d) : me.isArray(d) ? d.slice() : d;
    }
    function o(u, d, p, m) {
      if (me.isUndefined(d)) {
        if (!me.isUndefined(u))
          return r(void 0, u, p, m);
      } else return r(u, d, p, m);
    }
    function i(u, d) {
      if (!me.isUndefined(d))
        return r(void 0, d);
    }
    function a(u, d) {
      if (me.isUndefined(d)) {
        if (!me.isUndefined(u))
          return r(void 0, u);
      } else return r(void 0, d);
    }
    function s(u, d, p) {
      if (p in t)
        return r(u, d);
      if (p in e)
        return r(void 0, u);
    }
    const c = {
      url: i,
      method: i,
      data: i,
      baseURL: a,
      transformRequest: a,
      transformResponse: a,
      paramsSerializer: a,
      timeout: a,
      timeoutMessage: a,
      withCredentials: a,
      withXSRFToken: a,
      adapter: a,
      responseType: a,
      xsrfCookieName: a,
      xsrfHeaderName: a,
      onUploadProgress: a,
      onDownloadProgress: a,
      decompress: a,
      maxContentLength: a,
      maxBodyLength: a,
      beforeRedirect: a,
      transport: a,
      httpAgent: a,
      httpsAgent: a,
      cancelToken: a,
      socketPath: a,
      responseEncoding: a,
      validateStatus: s,
      headers: (u, d, p) => o(m$(u), m$(d), p, !0)
    };
    return me.forEach(Object.keys({ ...e, ...t }), function(d) {
      const p = c[d] || o, m = p(e[d], t[d], d);
      me.isUndefined(m) && p !== s || (n[d] = m);
    }), n;
  }
  const N9 = (e) => {
    const t = pc({}, e);
    let { data: n, withXSRFToken: r, xsrfHeaderName: o, xsrfCookieName: i, headers: a, auth: s } = t;
    if (t.headers = a = Vr.from(a), t.url = k9(M9(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), s && a.set(
      "Authorization",
      "Basic " + btoa((s.username || "") + ":" + (s.password ? unescape(encodeURIComponent(s.password)) : ""))
    ), me.isFormData(n)) {
      if (yr.hasStandardBrowserEnv || yr.hasStandardBrowserWebWorkerEnv)
        a.setContentType(void 0);
      else if (me.isFunction(n.getHeaders)) {
        const c = n.getHeaders(), u = ["content-type", "content-length"];
        Object.entries(c).forEach(([d, p]) => {
          u.includes(d.toLowerCase()) && a.set(d, p);
        });
      }
    }
    if (yr.hasStandardBrowserEnv && (r && me.isFunction(r) && (r = r(t)), r || r !== !1 && lde(t.url))) {
      const c = o && i && cde.read(i);
      c && a.set(o, c);
    }
    return t;
  }, dde = typeof XMLHttpRequest < "u", pde = dde && function(e) {
    return new Promise(function(n, r) {
      const o = N9(e);
      let i = o.data;
      const a = Vr.from(o.headers).normalize();
      let { responseType: s, onUploadProgress: c, onDownloadProgress: u } = o, d, p, m, g, y;
      function b() {
        g && g(), y && y(), o.cancelToken && o.cancelToken.unsubscribe(d), o.signal && o.signal.removeEventListener("abort", d);
      }
      let v = new XMLHttpRequest();
      v.open(o.method.toUpperCase(), o.url, !0), v.timeout = o.timeout;
      function x() {
        if (!v)
          return;
        const _ = Vr.from(
          "getAllResponseHeaders" in v && v.getAllResponseHeaders()
        ), k = {
          data: !s || s === "text" || s === "json" ? v.responseText : v.response,
          status: v.status,
          statusText: v.statusText,
          headers: _,
          config: e,
          request: v
        };
        O9(function(O) {
          n(O), b();
        }, function(O) {
          r(O), b();
        }, k), v = null;
      }
      "onloadend" in v ? v.onloadend = x : v.onreadystatechange = function() {
        !v || v.readyState !== 4 || v.status === 0 && !(v.responseURL && v.responseURL.indexOf("file:") === 0) || setTimeout(x);
      }, v.onabort = function() {
        v && (r(new ct("Request aborted", ct.ECONNABORTED, e, v)), v = null);
      }, v.onerror = function(C) {
        const k = C && C.message ? C.message : "Network Error", A = new ct(k, ct.ERR_NETWORK, e, v);
        A.event = C || null, r(A), v = null;
      }, v.ontimeout = function() {
        let C = o.timeout ? "timeout of " + o.timeout + "ms exceeded" : "timeout exceeded";
        const k = o.transitional || T9;
        o.timeoutErrorMessage && (C = o.timeoutErrorMessage), r(new ct(
          C,
          k.clarifyTimeoutError ? ct.ETIMEDOUT : ct.ECONNABORTED,
          e,
          v
        )), v = null;
      }, i === void 0 && a.setContentType(null), "setRequestHeader" in v && me.forEach(a.toJSON(), function(C, k) {
        v.setRequestHeader(k, C);
      }), me.isUndefined(o.withCredentials) || (v.withCredentials = !!o.withCredentials), s && s !== "json" && (v.responseType = o.responseType), u && ([m, y] = x0(u, !0), v.addEventListener("progress", m)), c && v.upload && ([p, g] = x0(c), v.upload.addEventListener("progress", p), v.upload.addEventListener("loadend", g)), (o.cancelToken || o.signal) && (d = (_) => {
        v && (r(!_ || _.type ? new Bf(null, e, v) : _), v.abort(), v = null);
      }, o.cancelToken && o.cancelToken.subscribe(d), o.signal && (o.signal.aborted ? d() : o.signal.addEventListener("abort", d)));
      const E = ide(o.url);
      if (E && yr.protocols.indexOf(E) === -1) {
        r(new ct("Unsupported protocol " + E + ":", ct.ERR_BAD_REQUEST, e));
        return;
      }
      v.send(i || null);
    });
  }, hde = (e, t) => {
    const { length: n } = e = e ? e.filter(Boolean) : [];
    if (t || n) {
      let r = new AbortController(), o;
      const i = function(u) {
        if (!o) {
          o = !0, s();
          const d = u instanceof Error ? u : this.reason;
          r.abort(d instanceof ct ? d : new Bf(d instanceof Error ? d.message : d));
        }
      };
      let a = t && setTimeout(() => {
        a = null, i(new ct(`timeout ${t} of ms exceeded`, ct.ETIMEDOUT));
      }, t);
      const s = () => {
        e && (a && clearTimeout(a), a = null, e.forEach((u) => {
          u.unsubscribe ? u.unsubscribe(i) : u.removeEventListener("abort", i);
        }), e = null);
      };
      e.forEach((u) => u.addEventListener("abort", i));
      const { signal: c } = r;
      return c.unsubscribe = () => me.asap(s), c;
    }
  }, mde = function* (e, t) {
    let n = e.byteLength;
    if (n < t) {
      yield e;
      return;
    }
    let r = 0, o;
    for (; r < n; )
      o = r + t, yield e.slice(r, o), r = o;
  }, gde = async function* (e, t) {
    for await (const n of yde(e))
      yield* mde(n, t);
  }, yde = async function* (e) {
    if (e[Symbol.asyncIterator]) {
      yield* e;
      return;
    }
    const t = e.getReader();
    try {
      for (; ; ) {
        const { done: n, value: r } = await t.read();
        if (n)
          break;
        yield r;
      }
    } finally {
      await t.cancel();
    }
  }, g$ = (e, t, n, r) => {
    const o = gde(e, t);
    let i = 0, a, s = (c) => {
      a || (a = !0, r && r(c));
    };
    return new ReadableStream({
      async pull(c) {
        try {
          const { done: u, value: d } = await o.next();
          if (u) {
            s(), c.close();
            return;
          }
          let p = d.byteLength;
          if (n) {
            let m = i += p;
            n(m);
          }
          c.enqueue(new Uint8Array(d));
        } catch (u) {
          throw s(u), u;
        }
      },
      cancel(c) {
        return s(c), o.return();
      }
    }, {
      highWaterMark: 2
    });
  }, y$ = 64 * 1024, { isFunction: py } = me, vde = (({ Request: e, Response: t }) => ({
    Request: e,
    Response: t
  }))(me.global), {
    ReadableStream: v$,
    TextEncoder: b$
  } = me.global, x$ = (e, ...t) => {
    try {
      return !!e(...t);
    } catch {
      return !1;
    }
  }, bde = (e) => {
    e = me.merge.call({
      skipUndefined: !0
    }, vde, e);
    const { fetch: t, Request: n, Response: r } = e, o = t ? py(t) : typeof fetch == "function", i = py(n), a = py(r);
    if (!o)
      return !1;
    const s = o && py(v$), c = o && (typeof b$ == "function" ? /* @__PURE__ */ ((y) => (b) => y.encode(b))(new b$()) : async (y) => new Uint8Array(await new n(y).arrayBuffer())), u = i && s && x$(() => {
      let y = !1;
      const b = new n(yr.origin, {
        body: new v$(),
        method: "POST",
        get duplex() {
          return y = !0, "half";
        }
      }).headers.has("Content-Type");
      return y && !b;
    }), d = a && s && x$(() => me.isReadableStream(new r("").body)), p = {
      stream: d && ((y) => y.body)
    };
    o && ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((y) => {
      !p[y] && (p[y] = (b, v) => {
        let x = b && b[y];
        if (x)
          return x.call(b);
        throw new ct(`Response type '${y}' is not supported`, ct.ERR_NOT_SUPPORT, v);
      });
    });
    const m = async (y) => {
      if (y == null)
        return 0;
      if (me.isBlob(y))
        return y.size;
      if (me.isSpecCompliantForm(y))
        return (await new n(yr.origin, {
          method: "POST",
          body: y
        }).arrayBuffer()).byteLength;
      if (me.isArrayBufferView(y) || me.isArrayBuffer(y))
        return y.byteLength;
      if (me.isURLSearchParams(y) && (y = y + ""), me.isString(y))
        return (await c(y)).byteLength;
    }, g = async (y, b) => {
      const v = me.toFiniteNumber(y.getContentLength());
      return v ?? m(b);
    };
    return async (y) => {
      let {
        url: b,
        method: v,
        data: x,
        signal: E,
        cancelToken: _,
        timeout: C,
        onDownloadProgress: k,
        onUploadProgress: A,
        responseType: O,
        headers: P,
        withCredentials: I = "same-origin",
        fetchOptions: $
      } = N9(y), L = t || fetch;
      O = O ? (O + "").toLowerCase() : "text";
      let N = hde([E, _ && _.toAbortSignal()], C), U = null;
      const j = N && N.unsubscribe && (() => {
        N.unsubscribe();
      });
      let V;
      try {
        if (A && u && v !== "get" && v !== "head" && (V = await g(P, x)) !== 0) {
          let D = new n(b, {
            method: "POST",
            body: x,
            duplex: "half"
          }), G;
          if (me.isFormData(x) && (G = D.headers.get("content-type")) && P.setContentType(G), D.body) {
            const [z, H] = p$(
              V,
              x0(h$(A))
            );
            x = g$(D.body, y$, z, H);
          }
        }
        me.isString(I) || (I = I ? "include" : "omit");
        const F = i && "credentials" in n.prototype, K = {
          ...$,
          signal: N,
          method: v.toUpperCase(),
          headers: P.normalize().toJSON(),
          body: x,
          duplex: "half",
          credentials: F ? I : void 0
        };
        U = i && new n(b, K);
        let W = await (i ? L(U, $) : L(b, K));
        const Y = d && (O === "stream" || O === "response");
        if (d && (k || Y && j)) {
          const D = {};
          ["status", "statusText", "headers"].forEach((X) => {
            D[X] = W[X];
          });
          const G = me.toFiniteNumber(W.headers.get("content-length")), [z, H] = k && p$(
            G,
            x0(h$(k), !0)
          ) || [];
          W = new r(
            g$(W.body, y$, z, () => {
              H && H(), j && j();
            }),
            D
          );
        }
        O = O || "text";
        let B = await p[me.findKey(p, O) || "text"](W, y);
        return !Y && j && j(), await new Promise((D, G) => {
          O9(D, G, {
            data: B,
            headers: Vr.from(W.headers),
            status: W.status,
            statusText: W.statusText,
            config: y,
            request: U
          });
        });
      } catch (F) {
        throw j && j(), F && F.name === "TypeError" && /Load failed|fetch/i.test(F.message) ? Object.assign(
          new ct("Network Error", ct.ERR_NETWORK, y, U),
          {
            cause: F.cause || F
          }
        ) : ct.from(F, F && F.code, y, U);
      }
    };
  }, xde = /* @__PURE__ */ new Map(), P9 = (e) => {
    let t = e && e.env || {};
    const { fetch: n, Request: r, Response: o } = t, i = [
      r,
      o,
      n
    ];
    let a = i.length, s = a, c, u, d = xde;
    for (; s--; )
      c = i[s], u = d.get(c), u === void 0 && d.set(c, u = s ? /* @__PURE__ */ new Map() : bde(t)), d = u;
    return u;
  };
  P9();
  const ST = {
    http: Dfe,
    xhr: pde,
    fetch: {
      get: P9
    }
  };
  me.forEach(ST, (e, t) => {
    if (e) {
      try {
        Object.defineProperty(e, "name", { value: t });
      } catch {
      }
      Object.defineProperty(e, "adapterName", { value: t });
    }
  });
  const w$ = (e) => `- ${e}`, wde = (e) => me.isFunction(e) || e === null || e === !1;
  function Sde(e, t) {
    e = me.isArray(e) ? e : [e];
    const { length: n } = e;
    let r, o;
    const i = {};
    for (let a = 0; a < n; a++) {
      r = e[a];
      let s;
      if (o = r, !wde(r) && (o = ST[(s = String(r)).toLowerCase()], o === void 0))
        throw new ct(`Unknown adapter '${s}'`);
      if (o && (me.isFunction(o) || (o = o.get(t))))
        break;
      i[s || "#" + a] = o;
    }
    if (!o) {
      const a = Object.entries(i).map(
        ([c, u]) => `adapter ${c} ` + (u === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let s = n ? a.length > 1 ? `since :
` + a.map(w$).join(`
`) : " " + w$(a[0]) : "as no adapter specified";
      throw new ct(
        "There is no suitable adapter to dispatch the request " + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return o;
  }
  const I9 = {
    /**
     * Resolve an adapter from a list of adapter names or functions.
     * @type {Function}
     */
    getAdapter: Sde,
    /**
     * Exposes all known adapters
     * @type {Object<string, Function|Object>}
     */
    adapters: ST
  };
  function QS(e) {
    if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
      throw new Bf(null, e);
  }
  function S$(e) {
    return QS(e), e.headers = Vr.from(e.headers), e.data = ZS.call(
      e,
      e.transformRequest
    ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), I9.getAdapter(e.adapter || Zh.adapter, e)(e).then(function(r) {
      return QS(e), r.data = ZS.call(
        e,
        e.transformResponse,
        r
      ), r.headers = Vr.from(r.headers), r;
    }, function(r) {
      return R9(r) || (QS(e), r && r.response && (r.response.data = ZS.call(
        e,
        e.transformResponse,
        r.response
      ), r.response.headers = Vr.from(r.response.headers))), Promise.reject(r);
    });
  }
  const $9 = "1.13.2", Wb = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
    Wb[e] = function(r) {
      return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
    };
  });
  const _$ = {};
  Wb.transitional = function(t, n, r) {
    function o(i, a) {
      return "[Axios v" + $9 + "] Transitional option '" + i + "'" + a + (r ? ". " + r : "");
    }
    return (i, a, s) => {
      if (t === !1)
        throw new ct(
          o(a, " has been removed" + (n ? " in " + n : "")),
          ct.ERR_DEPRECATED
        );
      return n && !_$[a] && (_$[a] = !0, console.warn(
        o(
          a,
          " has been deprecated since v" + n + " and will be removed in the near future"
        )
      )), t ? t(i, a, s) : !0;
    };
  };
  Wb.spelling = function(t) {
    return (n, r) => (console.warn(`${r} is likely a misspelling of ${t}`), !0);
  };
  function _de(e, t, n) {
    if (typeof e != "object")
      throw new ct("options must be an object", ct.ERR_BAD_OPTION_VALUE);
    const r = Object.keys(e);
    let o = r.length;
    for (; o-- > 0; ) {
      const i = r[o], a = t[i];
      if (a) {
        const s = e[i], c = s === void 0 || a(s, i, e);
        if (c !== !0)
          throw new ct("option " + i + " must be " + c, ct.ERR_BAD_OPTION_VALUE);
        continue;
      }
      if (n !== !0)
        throw new ct("Unknown option " + i, ct.ERR_BAD_OPTION);
    }
  }
  const Dv = {
    assertOptions: _de,
    validators: Wb
  }, vi = Dv.validators;
  let oc = class {
    constructor(t) {
      this.defaults = t || {}, this.interceptors = {
        request: new f$(),
        response: new f$()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    async request(t, n) {
      try {
        return await this._request(t, n);
      } catch (r) {
        if (r instanceof Error) {
          let o = {};
          Error.captureStackTrace ? Error.captureStackTrace(o) : o = new Error();
          const i = o.stack ? o.stack.replace(/^.+\n/, "") : "";
          try {
            r.stack ? i && !String(r.stack).endsWith(i.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + i) : r.stack = i;
          } catch {
          }
        }
        throw r;
      }
    }
    _request(t, n) {
      typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = pc(this.defaults, n);
      const { transitional: r, paramsSerializer: o, headers: i } = n;
      r !== void 0 && Dv.assertOptions(r, {
        silentJSONParsing: vi.transitional(vi.boolean),
        forcedJSONParsing: vi.transitional(vi.boolean),
        clarifyTimeoutError: vi.transitional(vi.boolean)
      }, !1), o != null && (me.isFunction(o) ? n.paramsSerializer = {
        serialize: o
      } : Dv.assertOptions(o, {
        encode: vi.function,
        serialize: vi.function
      }, !0)), n.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? n.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : n.allowAbsoluteUrls = !0), Dv.assertOptions(n, {
        baseUrl: vi.spelling("baseURL"),
        withXsrfToken: vi.spelling("withXSRFToken")
      }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase();
      let a = i && me.merge(
        i.common,
        i[n.method]
      );
      i && me.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (y) => {
          delete i[y];
        }
      ), n.headers = Vr.concat(a, i);
      const s = [];
      let c = !0;
      this.interceptors.request.forEach(function(b) {
        typeof b.runWhen == "function" && b.runWhen(n) === !1 || (c = c && b.synchronous, s.unshift(b.fulfilled, b.rejected));
      });
      const u = [];
      this.interceptors.response.forEach(function(b) {
        u.push(b.fulfilled, b.rejected);
      });
      let d, p = 0, m;
      if (!c) {
        const y = [S$.bind(this), void 0];
        for (y.unshift(...s), y.push(...u), m = y.length, d = Promise.resolve(n); p < m; )
          d = d.then(y[p++], y[p++]);
        return d;
      }
      m = s.length;
      let g = n;
      for (; p < m; ) {
        const y = s[p++], b = s[p++];
        try {
          g = y(g);
        } catch (v) {
          b.call(this, v);
          break;
        }
      }
      try {
        d = S$.call(this, g);
      } catch (y) {
        return Promise.reject(y);
      }
      for (p = 0, m = u.length; p < m; )
        d = d.then(u[p++], u[p++]);
      return d;
    }
    getUri(t) {
      t = pc(this.defaults, t);
      const n = M9(t.baseURL, t.url, t.allowAbsoluteUrls);
      return k9(n, t.params, t.paramsSerializer);
    }
  };
  me.forEach(["delete", "get", "head", "options"], function(t) {
    oc.prototype[t] = function(n, r) {
      return this.request(pc(r || {}, {
        method: t,
        url: n,
        data: (r || {}).data
      }));
    };
  });
  me.forEach(["post", "put", "patch"], function(t) {
    function n(r) {
      return function(i, a, s) {
        return this.request(pc(s || {}, {
          method: t,
          headers: r ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url: i,
          data: a
        }));
      };
    }
    oc.prototype[t] = n(), oc.prototype[t + "Form"] = n(!0);
  });
  let Ede = class j9 {
    constructor(t) {
      if (typeof t != "function")
        throw new TypeError("executor must be a function.");
      let n;
      this.promise = new Promise(function(i) {
        n = i;
      });
      const r = this;
      this.promise.then((o) => {
        if (!r._listeners) return;
        let i = r._listeners.length;
        for (; i-- > 0; )
          r._listeners[i](o);
        r._listeners = null;
      }), this.promise.then = (o) => {
        let i;
        const a = new Promise((s) => {
          r.subscribe(s), i = s;
        }).then(o);
        return a.cancel = function() {
          r.unsubscribe(i);
        }, a;
      }, t(function(i, a, s) {
        r.reason || (r.reason = new Bf(i, a, s), n(r.reason));
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason)
        throw this.reason;
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(t) {
      if (this.reason) {
        t(this.reason);
        return;
      }
      this._listeners ? this._listeners.push(t) : this._listeners = [t];
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(t) {
      if (!this._listeners)
        return;
      const n = this._listeners.indexOf(t);
      n !== -1 && this._listeners.splice(n, 1);
    }
    toAbortSignal() {
      const t = new AbortController(), n = (r) => {
        t.abort(r);
      };
      return this.subscribe(n), t.signal.unsubscribe = () => this.unsubscribe(n), t.signal;
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let t;
      return {
        token: new j9(function(o) {
          t = o;
        }),
        cancel: t
      };
    }
  };
  function Cde(e) {
    return function(n) {
      return e.apply(null, n);
    };
  }
  function kde(e) {
    return me.isObject(e) && e.isAxiosError === !0;
  }
  const rC = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511,
    WebServerIsDown: 521,
    ConnectionTimedOut: 522,
    OriginIsUnreachable: 523,
    TimeoutOccurred: 524,
    SslHandshakeFailed: 525,
    InvalidSslCertificate: 526
  };
  Object.entries(rC).forEach(([e, t]) => {
    rC[t] = e;
  });
  function D9(e) {
    const t = new oc(e), n = h9(oc.prototype.request, t);
    return me.extend(n, oc.prototype, t, { allOwnKeys: !0 }), me.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(o) {
      return D9(pc(e, o));
    }, n;
  }
  const In = D9(Zh);
  In.Axios = oc;
  In.CanceledError = Bf;
  In.CancelToken = Ede;
  In.isCancel = R9;
  In.VERSION = $9;
  In.toFormData = qb;
  In.AxiosError = ct;
  In.Cancel = In.CanceledError;
  In.all = function(t) {
    return Promise.all(t);
  };
  In.spread = Cde;
  In.isAxiosError = kde;
  In.mergeConfig = pc;
  In.AxiosHeaders = Vr;
  In.formToJSON = (e) => A9(me.isHTMLForm(e) ? new FormData(e) : e);
  In.getAdapter = I9.getAdapter;
  In.HttpStatusCode = rC;
  In.default = In;
  const {
    Axios: wze,
    AxiosError: Sze,
    CanceledError: _ze,
    isCancel: Eze,
    CancelToken: Cze,
    VERSION: kze,
    all: Tze,
    Cancel: Aze,
    isAxiosError: Rze,
    spread: Oze,
    toFormData: Mze,
    AxiosHeaders: Nze,
    HttpStatusCode: Pze,
    formToJSON: Ize,
    getAdapter: $ze,
    mergeConfig: jze
  } = In;
  class F9 extends p9 {
    constructor(t) {
      super(t), this._websocket = null, this.reconnectAttempts = 0, this.maxReconnectAttempts = 999, this.initialTimeout = 200, this.maxTimeout = 5e3, this._reconnect = !0, this._reconnect_timeout = void 0, this._url = t.url, this._reconnect_timeout = setTimeout(() => {
        this.connect();
      }, 200), this._zustand && this._zustand.auto_progress();
    }
    connect() {
      this._zustand?.logger.info("Connecting to websocket"), this.is_open = !1, this._websocket = new WebSocket(this._url), this._websocket.onopen = () => {
        this.onopen();
      }, this._websocket.onclose = () => {
        this.onclose();
      }, this._websocket.onerror = () => {
        this.on_ws_error();
      }, this._websocket.onmessage = (t) => {
        typeof t.data == "string" ? this.onmessage(t.data) : t.data instanceof Blob && t.data.arrayBuffer().then((n) => {
          const r = new Uint8Array(n);
          this.getCommunicationManager().onbytes(r);
        });
      };
    }
    calculateReconnectTimeout() {
      return Math.min(
        this.initialTimeout * Math.pow(2, this.reconnectAttempts),
        this.maxTimeout
      );
    }
    auto_reconnect() {
      if (this.reconnectAttempts < this.maxReconnectAttempts) {
        let t = this.calculateReconnectTimeout();
        this._zustand?.logger.info(`Attempting to reconnect in ${t} ms`), this._reconnect_timeout = setTimeout(() => {
          this._websocket && this._websocket.readyState === WebSocket.OPEN || (this.reconnectAttempts++, this.connect());
        }, t);
      } else
        this._zustand?.logger.warn(
          "Maximum reconnect attempts reached. Giving up."
        );
    }
    async onmessage(t) {
      try {
        const n = JSON.parse(t);
        this._zustand?.logger.debug(
          `Recieved data of length: ${t.length} and data"`,
          n
        ), await this.getCommunicationManager().receive(n);
      } catch (n) {
        console.error("Websocketworker: onmessage JSON.parse error", n, t);
        return;
      }
    }
    get http_protocol() {
      return this.secure_url ? "https" : "http";
    }
    get secure_url() {
      return this._url.startsWith("wss");
    }
    get url_wo_protocol() {
      return this._url.substring(this.secure_url ? 6 : 5);
    }
    get http_url() {
      var t = this.http_protocol + "://" + this.url_wo_protocol;
      return t[t.length - 1] !== "/" && (t += "/"), t;
    }
    get_io_subscription_url({
      node_id: t,
      io_id: n,
      stream: r
    }) {
      let o = this.http_url + `node/${t}/io/${n}/value`;
      return r && (o += "/stream"), o;
    }
    async upload_file({
      files: t,
      onProgressCallback: n,
      root: r
    }) {
      const o = `${this.http_url}upload/`, i = new FormData(), a = Array.isArray(t) ? t : Array.from(t);
      for (const s of a) {
        const c = s.webkitRelativePath || s.name, u = r ? `${r}/${c}` : c;
        i.append("file", s, u);
      }
      try {
        return (await In.post(o, i, {
          headers: {
            "Content-Type": "multipart/form-data"
          },
          onUploadProgress: (c) => {
            n && n(c.loaded, c.total);
          }
        })).data.file;
      } catch {
        throw new Error("Failed to upload file");
      }
    }
    async handle_large_message_hint({ msg_id: t }) {
      const n = this.http_url + "message/" + t, o = await (await fetch(n, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          "Access-Control-Allow-Origin": "*"
        }
      })).json();
      this.getCommunicationManager().receive(o);
    }
    onopen() {
      this._zustand?.logger.info("Websocket opened"), this.is_open = !0, this._zustand && this._zustand.auto_progress(), this.reconnectAttempts = 0, this.getSyncManager().stepwise_fullsync();
    }
    onclose() {
      this._zustand?.logger.info("Websocket closed"), super.onclose(), this._reconnect && (this._zustand?.logger.info("Websocket closed,reconnecting"), this.auto_reconnect());
    }
    on_ws_error() {
      this._zustand?.logger.warn("Websocket error"), this._websocket ? this._websocket.close() : this.auto_reconnect();
    }
    async send_large_message(t) {
      const n = `${this.http_url}message/`;
      await fetch(n, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: t
      });
    }
    async send(t) {
      if (!this._websocket || this._websocket.readyState !== WebSocket.OPEN) {
        this._zustand?.logger.warn("Websocket not connected");
        return;
      }
      const n = JSON.stringify(t);
      if (new Blob([n]).size > 1e6)
        return this._zustand?.logger.info("Data too large, sending via http"), await this.send_large_message(n);
      this._zustand?.logger.debug("Sending data", t), this._websocket.send(n);
    }
    async stop() {
      await super.stop(), this._reconnect = !1;
    }
    close() {
      this._websocket && this._websocket.close();
    }
    disconnect() {
      super.disconnect(), this._reconnect = !1, this._reconnect_timeout && (clearTimeout(this._reconnect_timeout), this._reconnect_timeout = void 0), this.close();
    }
    async reconnect() {
      if (await super.reconnect(), this._reconnect = !0, this._websocket && (this._zustand?.logger.info("Reconnecting"), (this._websocket.readyState === WebSocket.OPEN || this._websocket.readyState === WebSocket.CONNECTING) && (this._websocket.readyState === WebSocket.CONNECTING && await new Promise((t, n) => {
        if (this._websocket === null) return;
        let r = setTimeout(() => {
          n("Timeout@reconnect");
        }, 2e3);
        this._websocket.addEventListener(
          "open",
          () => {
            clearTimeout(r), t(null);
          },
          { once: !0 }
        ), this._websocket.readyState === WebSocket.OPEN && (clearTimeout(r), t(null));
      }), this._websocket.readyState === WebSocket.OPEN))) {
        this.getSyncManager().stepwise_fullsync();
        return;
      }
      this.connect();
    }
  }
  class Tde {
    constructor(t, n) {
      this.ws = null, this.reconnectAttempts = 0, this.maxReconnectAttempts = 999, this.initialTimeout = 200, this.maxTimeout = 2e3, n.logger.debug("Initializing worker manager"), this._wsuri = t, this.zustand = n, this.workers = {}, this.on_setWorker = (r) => {
        this.zustand.set_worker(r);
      }, this.connectionTimeout = setTimeout(() => {
        this.connect();
      }, 200);
    }
    get wsuri() {
      return this._wsuri;
    }
    get open() {
      return this.ws?.readyState === WebSocket.OPEN;
    }
    connect() {
      this.zustand.set_progress({
        progress: 0,
        message: "connecting to worker manager",
        status: "info",
        blocking: !0
      }), this.zustand.logger.info("Connecting to websocket:", this._wsuri), this.ws = new WebSocket(this._wsuri), this.ws.onopen = () => {
        this.onopen();
      }, this.ws.onclose = () => {
        this.onclose();
      }, this.ws.onerror = () => {
        this.on_ws_error();
      }, this.ws.onmessage = (t) => {
        typeof t.data == "string" ? this.onmessage(t.data) : console.error(
          "WorkerManager: onmessage event.data is not a string",
          typeof t.data
        );
      }, this.connectionTimeout = setTimeout(() => {
        this.ws?.readyState !== WebSocket.OPEN && this.on_ws_error();
      }, 5e3);
    }
    on_ws_error() {
      console.warn("Websocket error"), this.ws ? this.ws.close() : this.reconnect();
    }
    onopen() {
      this.connectionTimeout && (clearTimeout(this.connectionTimeout), this.connectionTimeout = void 0), this.zustand.auto_progress(), this.ws && this.ws.send("worker_status");
    }
    onmessage(t) {
      try {
        let n = JSON.parse(t);
        if (n.type === "worker_status") {
          const r = {};
          for (let o of n.active)
            o.active = !0, r[o.uuid] = o;
          for (let o of n.inactive)
            o.active = !1, r[o.uuid] = o;
          if (this.zustand.workers.setState(r), !this.zustand.worker) {
            const o = window.localStorage.getItem(
              "funcnodes__active_worker"
            );
            o && r[o] && r[o].active && this.set_active(o);
          }
          return;
        } else if (n.type === "set_worker") {
          if (n.data.type === "WSWorker") {
            let r = "ws" + (n.data.ssl ? "s" : "") + "://" + n.data.host + ":" + n.data.port;
            this.setWorker(
              this.workers[n.data.uuid] || new F9({
                url: r,
                zustand: this.zustand,
                uuid: n.data.uuid,
                on_sync_complete: this.zustand.options.on_sync_complete
              })
            );
          } else
            this.zustand.logger.error("WorkerManager: unknown worker type", n);
          return;
        } else if (n.type === "progress") {
          this.zustand.set_progress(n);
          return;
        }
        this.zustand.logger.error("WorkerManager: unknown message", n);
      } catch (n) {
        console.error("WorkerManager: onmessage JSON.parse error", n, t);
        return;
      }
    }
    setWorker(t) {
      for (let n in this.workers)
        n !== t?.uuid && this.workers[n].disconnect();
      t !== void 0 && (this.workers[t.uuid] = t, t.reconnect()), t?.uuid && window.localStorage.setItem("funcnodes__active_worker", t?.uuid), this.zustand.worker !== void 0 && this.zustand.clear_all(), this.zustand.set_worker(t), this.on_setWorker(t);
    }
    async restart_worker(t) {
      this.ws?.send(JSON.stringify({ type: "restart_worker", workerid: t }));
    }
    calculateReconnectTimeout() {
      return Math.min(
        this.initialTimeout * Math.pow(2, this.reconnectAttempts),
        this.maxTimeout
      );
    }
    reconnect() {
      if (this.reconnectAttempts < this.maxReconnectAttempts) {
        let t = this.calculateReconnectTimeout();
        this.zustand.logger.info(`Attempting to reconnect in ${t} ms`), setTimeout(() => {
          this.ws && this.ws.readyState === WebSocket.OPEN || (this.reconnectAttempts++, this.connect());
        }, t);
      } else
        this.zustand.logger.warn(
          "Maximum reconnect attempts reached. Giving up."
        );
    }
    onclose() {
      this.zustand.logger.warn("WorkerManager: onclose"), this.reconnect();
    }
    set_active(t) {
      this.ws && this.ws.send(JSON.stringify({ type: "set_active", workerid: t }));
    }
    new_worker({
      name: t,
      reference: n,
      copyLib: r,
      copyNS: o,
      in_venv: i
    }) {
      t || (t = void 0), r || (r = !1), o || (o = !1), n || (n = void 0, r = !1, o = !1), this.ws && this.ws.send(
        JSON.stringify({
          type: "new_worker",
          kwargs: {
            name: t,
            reference: n,
            copyLib: r,
            copyNS: o,
            in_venv: i
          }
        })
      );
    }
    remove() {
      for (let t in this.workers)
        this.workers[t].disconnect();
      this.connectionTimeout && (clearTimeout(this.connectionTimeout), this.connectionTimeout = void 0), this.ws && (this.ws.onclose = () => {
      }, this.ws.onerror = () => {
      }, this.ws.onmessage = () => {
      }, this.ws.onopen = () => {
      }, this.ws.close());
    }
  }
  const Rr = () => {
    const e = Vt();
    return e.worker ? {
      ...e.worker.api,
      worker: e.worker
    } : {
      node: void 0,
      group: void 0,
      edge: void 0,
      hooks: void 0,
      lib: void 0,
      worker: e.worker
    };
  }, Ade = {
    show: !0
  }, Rde = {
    show: !0,
    showmenu: !0
  }, Ode = {
    minimap: !0,
    static: !1,
    minZoom: 0.1,
    maxZoom: 5,
    allowFullScreen: !0,
    allowExpand: !0,
    showNodeSettings: !0
  }, Mde = {
    id: "",
    // required
    debug: !1,
    useWorkerManager: !0,
    show_library: !0,
    header: Rde,
    flow: Ode,
    library: Ade
  }, L9 = [
    "classic",
    "metal",
    "light",
    "solarized",
    "midnight",
    "forest",
    "scientific",
    "neon",
    "ocean",
    "sunset"
  ];
  function qn(e) {
    if (typeof e == "string" || typeof e == "number") return "" + e;
    let t = "";
    if (Array.isArray(e))
      for (let n = 0, r; n < e.length; n++)
        (r = qn(e[n])) !== "" && (t += (t && " ") + r);
    else
      for (let n in e)
        e[n] && (t += (t && " ") + n);
    return t;
  }
  var Nde = { value: () => {
  } };
  function Gb() {
    for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {
      if (!(r = arguments[e] + "") || r in n || /[\s.]/.test(r)) throw new Error("illegal type: " + r);
      n[r] = [];
    }
    return new Fv(n);
  }
  function Fv(e) {
    this._ = e;
  }
  function Pde(e, t) {
    return e.trim().split(/^|\s+/).map(function(n) {
      var r = "", o = n.indexOf(".");
      if (o >= 0 && (r = n.slice(o + 1), n = n.slice(0, o)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
      return { type: n, name: r };
    });
  }
  Fv.prototype = Gb.prototype = {
    constructor: Fv,
    on: function(e, t) {
      var n = this._, r = Pde(e + "", n), o, i = -1, a = r.length;
      if (arguments.length < 2) {
        for (; ++i < a; ) if ((o = (e = r[i]).type) && (o = Ide(n[o], e.name))) return o;
        return;
      }
      if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
      for (; ++i < a; )
        if (o = (e = r[i]).type) n[o] = E$(n[o], e.name, t);
        else if (t == null) for (o in n) n[o] = E$(n[o], e.name, null);
      return this;
    },
    copy: function() {
      var e = {}, t = this._;
      for (var n in t) e[n] = t[n].slice();
      return new Fv(e);
    },
    call: function(e, t) {
      if ((o = arguments.length - 2) > 0) for (var n = new Array(o), r = 0, o, i; r < o; ++r) n[r] = arguments[r + 2];
      if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
      for (i = this._[e], r = 0, o = i.length; r < o; ++r) i[r].value.apply(t, n);
    },
    apply: function(e, t, n) {
      if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
      for (var r = this._[e], o = 0, i = r.length; o < i; ++o) r[o].value.apply(t, n);
    }
  };
  function Ide(e, t) {
    for (var n = 0, r = e.length, o; n < r; ++n)
      if ((o = e[n]).name === t)
        return o.value;
  }
  function E$(e, t, n) {
    for (var r = 0, o = e.length; r < o; ++r)
      if (e[r].name === t) {
        e[r] = Nde, e = e.slice(0, r).concat(e.slice(r + 1));
        break;
      }
    return n != null && e.push({ name: t, value: n }), e;
  }
  var oC = "http://www.w3.org/1999/xhtml";
  const C$ = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: oC,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  function Kb(e) {
    var t = e += "", n = t.indexOf(":");
    return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), C$.hasOwnProperty(t) ? { space: C$[t], local: e } : e;
  }
  function $de(e) {
    return function() {
      var t = this.ownerDocument, n = this.namespaceURI;
      return n === oC && t.documentElement.namespaceURI === oC ? t.createElement(e) : t.createElementNS(n, e);
    };
  }
  function jde(e) {
    return function() {
      return this.ownerDocument.createElementNS(e.space, e.local);
    };
  }
  function z9(e) {
    var t = Kb(e);
    return (t.local ? jde : $de)(t);
  }
  function Dde() {
  }
  function _T(e) {
    return e == null ? Dde : function() {
      return this.querySelector(e);
    };
  }
  function Fde(e) {
    typeof e != "function" && (e = _T(e));
    for (var t = this._groups, n = t.length, r = new Array(n), o = 0; o < n; ++o)
      for (var i = t[o], a = i.length, s = r[o] = new Array(a), c, u, d = 0; d < a; ++d)
        (c = i[d]) && (u = e.call(c, c.__data__, d, i)) && ("__data__" in c && (u.__data__ = c.__data__), s[d] = u);
    return new fo(r, this._parents);
  }
  function Lde(e) {
    return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
  }
  function zde() {
    return [];
  }
  function B9(e) {
    return e == null ? zde : function() {
      return this.querySelectorAll(e);
    };
  }
  function Bde(e) {
    return function() {
      return Lde(e.apply(this, arguments));
    };
  }
  function Ude(e) {
    typeof e == "function" ? e = Bde(e) : e = B9(e);
    for (var t = this._groups, n = t.length, r = [], o = [], i = 0; i < n; ++i)
      for (var a = t[i], s = a.length, c, u = 0; u < s; ++u)
        (c = a[u]) && (r.push(e.call(c, c.__data__, u, a)), o.push(c));
    return new fo(r, o);
  }
  function U9(e) {
    return function() {
      return this.matches(e);
    };
  }
  function V9(e) {
    return function(t) {
      return t.matches(e);
    };
  }
  var Vde = Array.prototype.find;
  function Hde(e) {
    return function() {
      return Vde.call(this.children, e);
    };
  }
  function qde() {
    return this.firstElementChild;
  }
  function Wde(e) {
    return this.select(e == null ? qde : Hde(typeof e == "function" ? e : V9(e)));
  }
  var Gde = Array.prototype.filter;
  function Kde() {
    return Array.from(this.children);
  }
  function Yde(e) {
    return function() {
      return Gde.call(this.children, e);
    };
  }
  function Xde(e) {
    return this.selectAll(e == null ? Kde : Yde(typeof e == "function" ? e : V9(e)));
  }
  function Zde(e) {
    typeof e != "function" && (e = U9(e));
    for (var t = this._groups, n = t.length, r = new Array(n), o = 0; o < n; ++o)
      for (var i = t[o], a = i.length, s = r[o] = [], c, u = 0; u < a; ++u)
        (c = i[u]) && e.call(c, c.__data__, u, i) && s.push(c);
    return new fo(r, this._parents);
  }
  function H9(e) {
    return new Array(e.length);
  }
  function Qde() {
    return new fo(this._enter || this._groups.map(H9), this._parents);
  }
  function w0(e, t) {
    this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
  }
  w0.prototype = {
    constructor: w0,
    appendChild: function(e) {
      return this._parent.insertBefore(e, this._next);
    },
    insertBefore: function(e, t) {
      return this._parent.insertBefore(e, t);
    },
    querySelector: function(e) {
      return this._parent.querySelector(e);
    },
    querySelectorAll: function(e) {
      return this._parent.querySelectorAll(e);
    }
  };
  function Jde(e) {
    return function() {
      return e;
    };
  }
  function epe(e, t, n, r, o, i) {
    for (var a = 0, s, c = t.length, u = i.length; a < u; ++a)
      (s = t[a]) ? (s.__data__ = i[a], r[a] = s) : n[a] = new w0(e, i[a]);
    for (; a < c; ++a)
      (s = t[a]) && (o[a] = s);
  }
  function tpe(e, t, n, r, o, i, a) {
    var s, c, u = /* @__PURE__ */ new Map(), d = t.length, p = i.length, m = new Array(d), g;
    for (s = 0; s < d; ++s)
      (c = t[s]) && (m[s] = g = a.call(c, c.__data__, s, t) + "", u.has(g) ? o[s] = c : u.set(g, c));
    for (s = 0; s < p; ++s)
      g = a.call(e, i[s], s, i) + "", (c = u.get(g)) ? (r[s] = c, c.__data__ = i[s], u.delete(g)) : n[s] = new w0(e, i[s]);
    for (s = 0; s < d; ++s)
      (c = t[s]) && u.get(m[s]) === c && (o[s] = c);
  }
  function npe(e) {
    return e.__data__;
  }
  function rpe(e, t) {
    if (!arguments.length) return Array.from(this, npe);
    var n = t ? tpe : epe, r = this._parents, o = this._groups;
    typeof e != "function" && (e = Jde(e));
    for (var i = o.length, a = new Array(i), s = new Array(i), c = new Array(i), u = 0; u < i; ++u) {
      var d = r[u], p = o[u], m = p.length, g = ope(e.call(d, d && d.__data__, u, r)), y = g.length, b = s[u] = new Array(y), v = a[u] = new Array(y), x = c[u] = new Array(m);
      n(d, p, b, v, x, g, t);
      for (var E = 0, _ = 0, C, k; E < y; ++E)
        if (C = b[E]) {
          for (E >= _ && (_ = E + 1); !(k = v[_]) && ++_ < y; ) ;
          C._next = k || null;
        }
    }
    return a = new fo(a, r), a._enter = s, a._exit = c, a;
  }
  function ope(e) {
    return typeof e == "object" && "length" in e ? e : Array.from(e);
  }
  function ipe() {
    return new fo(this._exit || this._groups.map(H9), this._parents);
  }
  function ape(e, t, n) {
    var r = this.enter(), o = this, i = this.exit();
    return typeof e == "function" ? (r = e(r), r && (r = r.selection())) : r = r.append(e + ""), t != null && (o = t(o), o && (o = o.selection())), n == null ? i.remove() : n(i), r && o ? r.merge(o).order() : o;
  }
  function spe(e) {
    for (var t = e.selection ? e.selection() : e, n = this._groups, r = t._groups, o = n.length, i = r.length, a = Math.min(o, i), s = new Array(o), c = 0; c < a; ++c)
      for (var u = n[c], d = r[c], p = u.length, m = s[c] = new Array(p), g, y = 0; y < p; ++y)
        (g = u[y] || d[y]) && (m[y] = g);
    for (; c < o; ++c)
      s[c] = n[c];
    return new fo(s, this._parents);
  }
  function lpe() {
    for (var e = this._groups, t = -1, n = e.length; ++t < n; )
      for (var r = e[t], o = r.length - 1, i = r[o], a; --o >= 0; )
        (a = r[o]) && (i && a.compareDocumentPosition(i) ^ 4 && i.parentNode.insertBefore(a, i), i = a);
    return this;
  }
  function cpe(e) {
    e || (e = upe);
    function t(p, m) {
      return p && m ? e(p.__data__, m.__data__) : !p - !m;
    }
    for (var n = this._groups, r = n.length, o = new Array(r), i = 0; i < r; ++i) {
      for (var a = n[i], s = a.length, c = o[i] = new Array(s), u, d = 0; d < s; ++d)
        (u = a[d]) && (c[d] = u);
      c.sort(t);
    }
    return new fo(o, this._parents).order();
  }
  function upe(e, t) {
    return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
  }
  function fpe() {
    var e = arguments[0];
    return arguments[0] = this, e.apply(null, arguments), this;
  }
  function dpe() {
    return Array.from(this);
  }
  function ppe() {
    for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
      for (var r = e[t], o = 0, i = r.length; o < i; ++o) {
        var a = r[o];
        if (a) return a;
      }
    return null;
  }
  function hpe() {
    let e = 0;
    for (const t of this) ++e;
    return e;
  }
  function mpe() {
    return !this.node();
  }
  function gpe(e) {
    for (var t = this._groups, n = 0, r = t.length; n < r; ++n)
      for (var o = t[n], i = 0, a = o.length, s; i < a; ++i)
        (s = o[i]) && e.call(s, s.__data__, i, o);
    return this;
  }
  function ype(e) {
    return function() {
      this.removeAttribute(e);
    };
  }
  function vpe(e) {
    return function() {
      this.removeAttributeNS(e.space, e.local);
    };
  }
  function bpe(e, t) {
    return function() {
      this.setAttribute(e, t);
    };
  }
  function xpe(e, t) {
    return function() {
      this.setAttributeNS(e.space, e.local, t);
    };
  }
  function wpe(e, t) {
    return function() {
      var n = t.apply(this, arguments);
      n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
    };
  }
  function Spe(e, t) {
    return function() {
      var n = t.apply(this, arguments);
      n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
    };
  }
  function _pe(e, t) {
    var n = Kb(e);
    if (arguments.length < 2) {
      var r = this.node();
      return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);
    }
    return this.each((t == null ? n.local ? vpe : ype : typeof t == "function" ? n.local ? Spe : wpe : n.local ? xpe : bpe)(n, t));
  }
  function q9(e) {
    return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
  }
  function Epe(e) {
    return function() {
      this.style.removeProperty(e);
    };
  }
  function Cpe(e, t, n) {
    return function() {
      this.style.setProperty(e, t, n);
    };
  }
  function kpe(e, t, n) {
    return function() {
      var r = t.apply(this, arguments);
      r == null ? this.style.removeProperty(e) : this.style.setProperty(e, r, n);
    };
  }
  function Tpe(e, t, n) {
    return arguments.length > 1 ? this.each((t == null ? Epe : typeof t == "function" ? kpe : Cpe)(e, t, n ?? "")) : vf(this.node(), e);
  }
  function vf(e, t) {
    return e.style.getPropertyValue(t) || q9(e).getComputedStyle(e, null).getPropertyValue(t);
  }
  function Ape(e) {
    return function() {
      delete this[e];
    };
  }
  function Rpe(e, t) {
    return function() {
      this[e] = t;
    };
  }
  function Ope(e, t) {
    return function() {
      var n = t.apply(this, arguments);
      n == null ? delete this[e] : this[e] = n;
    };
  }
  function Mpe(e, t) {
    return arguments.length > 1 ? this.each((t == null ? Ape : typeof t == "function" ? Ope : Rpe)(e, t)) : this.node()[e];
  }
  function W9(e) {
    return e.trim().split(/^|\s+/);
  }
  function ET(e) {
    return e.classList || new G9(e);
  }
  function G9(e) {
    this._node = e, this._names = W9(e.getAttribute("class") || "");
  }
  G9.prototype = {
    add: function(e) {
      var t = this._names.indexOf(e);
      t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
    },
    remove: function(e) {
      var t = this._names.indexOf(e);
      t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
    },
    contains: function(e) {
      return this._names.indexOf(e) >= 0;
    }
  };
  function K9(e, t) {
    for (var n = ET(e), r = -1, o = t.length; ++r < o; ) n.add(t[r]);
  }
  function Y9(e, t) {
    for (var n = ET(e), r = -1, o = t.length; ++r < o; ) n.remove(t[r]);
  }
  function Npe(e) {
    return function() {
      K9(this, e);
    };
  }
  function Ppe(e) {
    return function() {
      Y9(this, e);
    };
  }
  function Ipe(e, t) {
    return function() {
      (t.apply(this, arguments) ? K9 : Y9)(this, e);
    };
  }
  function $pe(e, t) {
    var n = W9(e + "");
    if (arguments.length < 2) {
      for (var r = ET(this.node()), o = -1, i = n.length; ++o < i; ) if (!r.contains(n[o])) return !1;
      return !0;
    }
    return this.each((typeof t == "function" ? Ipe : t ? Npe : Ppe)(n, t));
  }
  function jpe() {
    this.textContent = "";
  }
  function Dpe(e) {
    return function() {
      this.textContent = e;
    };
  }
  function Fpe(e) {
    return function() {
      var t = e.apply(this, arguments);
      this.textContent = t ?? "";
    };
  }
  function Lpe(e) {
    return arguments.length ? this.each(e == null ? jpe : (typeof e == "function" ? Fpe : Dpe)(e)) : this.node().textContent;
  }
  function zpe() {
    this.innerHTML = "";
  }
  function Bpe(e) {
    return function() {
      this.innerHTML = e;
    };
  }
  function Upe(e) {
    return function() {
      var t = e.apply(this, arguments);
      this.innerHTML = t ?? "";
    };
  }
  function Vpe(e) {
    return arguments.length ? this.each(e == null ? zpe : (typeof e == "function" ? Upe : Bpe)(e)) : this.node().innerHTML;
  }
  function Hpe() {
    this.nextSibling && this.parentNode.appendChild(this);
  }
  function qpe() {
    return this.each(Hpe);
  }
  function Wpe() {
    this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }
  function Gpe() {
    return this.each(Wpe);
  }
  function Kpe(e) {
    var t = typeof e == "function" ? e : z9(e);
    return this.select(function() {
      return this.appendChild(t.apply(this, arguments));
    });
  }
  function Ype() {
    return null;
  }
  function Xpe(e, t) {
    var n = typeof e == "function" ? e : z9(e), r = t == null ? Ype : typeof t == "function" ? t : _T(t);
    return this.select(function() {
      return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null);
    });
  }
  function Zpe() {
    var e = this.parentNode;
    e && e.removeChild(this);
  }
  function Qpe() {
    return this.each(Zpe);
  }
  function Jpe() {
    var e = this.cloneNode(!1), t = this.parentNode;
    return t ? t.insertBefore(e, this.nextSibling) : e;
  }
  function ehe() {
    var e = this.cloneNode(!0), t = this.parentNode;
    return t ? t.insertBefore(e, this.nextSibling) : e;
  }
  function the(e) {
    return this.select(e ? ehe : Jpe);
  }
  function nhe(e) {
    return arguments.length ? this.property("__data__", e) : this.node().__data__;
  }
  function rhe(e) {
    return function(t) {
      e.call(this, t, this.__data__);
    };
  }
  function ohe(e) {
    return e.trim().split(/^|\s+/).map(function(t) {
      var n = "", r = t.indexOf(".");
      return r >= 0 && (n = t.slice(r + 1), t = t.slice(0, r)), { type: t, name: n };
    });
  }
  function ihe(e) {
    return function() {
      var t = this.__on;
      if (t) {
        for (var n = 0, r = -1, o = t.length, i; n < o; ++n)
          i = t[n], (!e.type || i.type === e.type) && i.name === e.name ? this.removeEventListener(i.type, i.listener, i.options) : t[++r] = i;
        ++r ? t.length = r : delete this.__on;
      }
    };
  }
  function ahe(e, t, n) {
    return function() {
      var r = this.__on, o, i = rhe(t);
      if (r) {
        for (var a = 0, s = r.length; a < s; ++a)
          if ((o = r[a]).type === e.type && o.name === e.name) {
            this.removeEventListener(o.type, o.listener, o.options), this.addEventListener(o.type, o.listener = i, o.options = n), o.value = t;
            return;
          }
      }
      this.addEventListener(e.type, i, n), o = { type: e.type, name: e.name, value: t, listener: i, options: n }, r ? r.push(o) : this.__on = [o];
    };
  }
  function she(e, t, n) {
    var r = ohe(e + ""), o, i = r.length, a;
    if (arguments.length < 2) {
      var s = this.node().__on;
      if (s) {
        for (var c = 0, u = s.length, d; c < u; ++c)
          for (o = 0, d = s[c]; o < i; ++o)
            if ((a = r[o]).type === d.type && a.name === d.name)
              return d.value;
      }
      return;
    }
    for (s = t ? ahe : ihe, o = 0; o < i; ++o) this.each(s(r[o], t, n));
    return this;
  }
  function X9(e, t, n) {
    var r = q9(e), o = r.CustomEvent;
    typeof o == "function" ? o = new o(t, n) : (o = r.document.createEvent("Event"), n ? (o.initEvent(t, n.bubbles, n.cancelable), o.detail = n.detail) : o.initEvent(t, !1, !1)), e.dispatchEvent(o);
  }
  function lhe(e, t) {
    return function() {
      return X9(this, e, t);
    };
  }
  function che(e, t) {
    return function() {
      return X9(this, e, t.apply(this, arguments));
    };
  }
  function uhe(e, t) {
    return this.each((typeof t == "function" ? che : lhe)(e, t));
  }
  function* fhe() {
    for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
      for (var r = e[t], o = 0, i = r.length, a; o < i; ++o)
        (a = r[o]) && (yield a);
  }
  var Z9 = [null];
  function fo(e, t) {
    this._groups = e, this._parents = t;
  }
  function Qh() {
    return new fo([[document.documentElement]], Z9);
  }
  function dhe() {
    return this;
  }
  fo.prototype = Qh.prototype = {
    constructor: fo,
    select: Fde,
    selectAll: Ude,
    selectChild: Wde,
    selectChildren: Xde,
    filter: Zde,
    data: rpe,
    enter: Qde,
    exit: ipe,
    join: ape,
    merge: spe,
    selection: dhe,
    order: lpe,
    sort: cpe,
    call: fpe,
    nodes: dpe,
    node: ppe,
    size: hpe,
    empty: mpe,
    each: gpe,
    attr: _pe,
    style: Tpe,
    property: Mpe,
    classed: $pe,
    text: Lpe,
    html: Vpe,
    raise: qpe,
    lower: Gpe,
    append: Kpe,
    insert: Xpe,
    remove: Qpe,
    clone: the,
    datum: nhe,
    on: she,
    dispatch: uhe,
    [Symbol.iterator]: fhe
  };
  function io(e) {
    return typeof e == "string" ? new fo([[document.querySelector(e)]], [document.documentElement]) : new fo([[e]], Z9);
  }
  function phe(e) {
    let t;
    for (; t = e.sourceEvent; ) e = t;
    return e;
  }
  function Wo(e, t) {
    if (e = phe(e), t === void 0 && (t = e.currentTarget), t) {
      var n = t.ownerSVGElement || t;
      if (n.createSVGPoint) {
        var r = n.createSVGPoint();
        return r.x = e.clientX, r.y = e.clientY, r = r.matrixTransform(t.getScreenCTM().inverse()), [r.x, r.y];
      }
      if (t.getBoundingClientRect) {
        var o = t.getBoundingClientRect();
        return [e.clientX - o.left - t.clientLeft, e.clientY - o.top - t.clientTop];
      }
    }
    return [e.pageX, e.pageY];
  }
  const hhe = { passive: !1 }, rh = { capture: !0, passive: !1 };
  function JS(e) {
    e.stopImmediatePropagation();
  }
  function af(e) {
    e.preventDefault(), e.stopImmediatePropagation();
  }
  function Q9(e) {
    var t = e.document.documentElement, n = io(e).on("dragstart.drag", af, rh);
    "onselectstart" in t ? n.on("selectstart.drag", af, rh) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
  }
  function J9(e, t) {
    var n = e.document.documentElement, r = io(e).on("dragstart.drag", null);
    t && (r.on("click.drag", af, rh), setTimeout(function() {
      r.on("click.drag", null);
    }, 0)), "onselectstart" in n ? r.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
  }
  const hy = (e) => () => e;
  function iC(e, {
    sourceEvent: t,
    subject: n,
    target: r,
    identifier: o,
    active: i,
    x: a,
    y: s,
    dx: c,
    dy: u,
    dispatch: d
  }) {
    Object.defineProperties(this, {
      type: { value: e, enumerable: !0, configurable: !0 },
      sourceEvent: { value: t, enumerable: !0, configurable: !0 },
      subject: { value: n, enumerable: !0, configurable: !0 },
      target: { value: r, enumerable: !0, configurable: !0 },
      identifier: { value: o, enumerable: !0, configurable: !0 },
      active: { value: i, enumerable: !0, configurable: !0 },
      x: { value: a, enumerable: !0, configurable: !0 },
      y: { value: s, enumerable: !0, configurable: !0 },
      dx: { value: c, enumerable: !0, configurable: !0 },
      dy: { value: u, enumerable: !0, configurable: !0 },
      _: { value: d }
    });
  }
  iC.prototype.on = function() {
    var e = this._.on.apply(this._, arguments);
    return e === this._ ? this : e;
  };
  function mhe(e) {
    return !e.ctrlKey && !e.button;
  }
  function ghe() {
    return this.parentNode;
  }
  function yhe(e, t) {
    return t ?? { x: e.x, y: e.y };
  }
  function vhe() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function eB() {
    var e = mhe, t = ghe, n = yhe, r = vhe, o = {}, i = Gb("start", "drag", "end"), a = 0, s, c, u, d, p = 0;
    function m(C) {
      C.on("mousedown.drag", g).filter(r).on("touchstart.drag", v).on("touchmove.drag", x, hhe).on("touchend.drag touchcancel.drag", E).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    function g(C, k) {
      if (!(d || !e.call(this, C, k))) {
        var A = _(this, t.call(this, C, k), C, k, "mouse");
        A && (io(C.view).on("mousemove.drag", y, rh).on("mouseup.drag", b, rh), Q9(C.view), JS(C), u = !1, s = C.clientX, c = C.clientY, A("start", C));
      }
    }
    function y(C) {
      if (af(C), !u) {
        var k = C.clientX - s, A = C.clientY - c;
        u = k * k + A * A > p;
      }
      o.mouse("drag", C);
    }
    function b(C) {
      io(C.view).on("mousemove.drag mouseup.drag", null), J9(C.view, u), af(C), o.mouse("end", C);
    }
    function v(C, k) {
      if (e.call(this, C, k)) {
        var A = C.changedTouches, O = t.call(this, C, k), P = A.length, I, $;
        for (I = 0; I < P; ++I)
          ($ = _(this, O, C, k, A[I].identifier, A[I])) && (JS(C), $("start", C, A[I]));
      }
    }
    function x(C) {
      var k = C.changedTouches, A = k.length, O, P;
      for (O = 0; O < A; ++O)
        (P = o[k[O].identifier]) && (af(C), P("drag", C, k[O]));
    }
    function E(C) {
      var k = C.changedTouches, A = k.length, O, P;
      for (d && clearTimeout(d), d = setTimeout(function() {
        d = null;
      }, 500), O = 0; O < A; ++O)
        (P = o[k[O].identifier]) && (JS(C), P("end", C, k[O]));
    }
    function _(C, k, A, O, P, I) {
      var $ = i.copy(), L = Wo(I || A, k), N, U, j;
      if ((j = n.call(C, new iC("beforestart", {
        sourceEvent: A,
        target: m,
        identifier: P,
        active: a,
        x: L[0],
        y: L[1],
        dx: 0,
        dy: 0,
        dispatch: $
      }), O)) != null)
        return N = j.x - L[0] || 0, U = j.y - L[1] || 0, function V(F, K, W) {
          var Y = L, B;
          switch (F) {
            case "start":
              o[P] = V, B = a++;
              break;
            case "end":
              delete o[P], --a;
            // falls through
            case "drag":
              L = Wo(W || K, k), B = a;
              break;
          }
          $.call(
            F,
            C,
            new iC(F, {
              sourceEvent: K,
              subject: j,
              target: m,
              identifier: P,
              active: B,
              x: L[0] + N,
              y: L[1] + U,
              dx: L[0] - Y[0],
              dy: L[1] - Y[1],
              dispatch: $
            }),
            O
          );
        };
    }
    return m.filter = function(C) {
      return arguments.length ? (e = typeof C == "function" ? C : hy(!!C), m) : e;
    }, m.container = function(C) {
      return arguments.length ? (t = typeof C == "function" ? C : hy(C), m) : t;
    }, m.subject = function(C) {
      return arguments.length ? (n = typeof C == "function" ? C : hy(C), m) : n;
    }, m.touchable = function(C) {
      return arguments.length ? (r = typeof C == "function" ? C : hy(!!C), m) : r;
    }, m.on = function() {
      var C = i.on.apply(i, arguments);
      return C === i ? m : C;
    }, m.clickDistance = function(C) {
      return arguments.length ? (p = (C = +C) * C, m) : Math.sqrt(p);
    }, m;
  }
  function CT(e, t, n) {
    e.prototype = t.prototype = n, n.constructor = e;
  }
  function tB(e, t) {
    var n = Object.create(e.prototype);
    for (var r in t) n[r] = t[r];
    return n;
  }
  function Jh() {
  }
  var oh = 0.7, S0 = 1 / oh, sf = "\\s*([+-]?\\d+)\\s*", ih = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", qi = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", bhe = /^#([0-9a-f]{3,8})$/, xhe = new RegExp(`^rgb\\(${sf},${sf},${sf}\\)$`), whe = new RegExp(`^rgb\\(${qi},${qi},${qi}\\)$`), She = new RegExp(`^rgba\\(${sf},${sf},${sf},${ih}\\)$`), _he = new RegExp(`^rgba\\(${qi},${qi},${qi},${ih}\\)$`), Ehe = new RegExp(`^hsl\\(${ih},${qi},${qi}\\)$`), Che = new RegExp(`^hsla\\(${ih},${qi},${qi},${ih}\\)$`), k$ = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  CT(Jh, hc, {
    copy(e) {
      return Object.assign(new this.constructor(), this, e);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: T$,
    // Deprecated! Use color.formatHex.
    formatHex: T$,
    formatHex8: khe,
    formatHsl: The,
    formatRgb: A$,
    toString: A$
  });
  function T$() {
    return this.rgb().formatHex();
  }
  function khe() {
    return this.rgb().formatHex8();
  }
  function The() {
    return nB(this).formatHsl();
  }
  function A$() {
    return this.rgb().formatRgb();
  }
  function hc(e) {
    var t, n;
    return e = (e + "").trim().toLowerCase(), (t = bhe.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? R$(t) : n === 3 ? new Br(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? my(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? my(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = xhe.exec(e)) ? new Br(t[1], t[2], t[3], 1) : (t = whe.exec(e)) ? new Br(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = She.exec(e)) ? my(t[1], t[2], t[3], t[4]) : (t = _he.exec(e)) ? my(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = Ehe.exec(e)) ? N$(t[1], t[2] / 100, t[3] / 100, 1) : (t = Che.exec(e)) ? N$(t[1], t[2] / 100, t[3] / 100, t[4]) : k$.hasOwnProperty(e) ? R$(k$[e]) : e === "transparent" ? new Br(NaN, NaN, NaN, 0) : null;
  }
  function R$(e) {
    return new Br(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
  }
  function my(e, t, n, r) {
    return r <= 0 && (e = t = n = NaN), new Br(e, t, n, r);
  }
  function Ahe(e) {
    return e instanceof Jh || (e = hc(e)), e ? (e = e.rgb(), new Br(e.r, e.g, e.b, e.opacity)) : new Br();
  }
  function aC(e, t, n, r) {
    return arguments.length === 1 ? Ahe(e) : new Br(e, t, n, r ?? 1);
  }
  function Br(e, t, n, r) {
    this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;
  }
  CT(Br, aC, tB(Jh, {
    brighter(e) {
      return e = e == null ? S0 : Math.pow(S0, e), new Br(this.r * e, this.g * e, this.b * e, this.opacity);
    },
    darker(e) {
      return e = e == null ? oh : Math.pow(oh, e), new Br(this.r * e, this.g * e, this.b * e, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Br(ic(this.r), ic(this.g), ic(this.b), _0(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
    },
    hex: O$,
    // Deprecated! Use color.formatHex.
    formatHex: O$,
    formatHex8: Rhe,
    formatRgb: M$,
    toString: M$
  }));
  function O$() {
    return `#${rc(this.r)}${rc(this.g)}${rc(this.b)}`;
  }
  function Rhe() {
    return `#${rc(this.r)}${rc(this.g)}${rc(this.b)}${rc((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function M$() {
    const e = _0(this.opacity);
    return `${e === 1 ? "rgb(" : "rgba("}${ic(this.r)}, ${ic(this.g)}, ${ic(this.b)}${e === 1 ? ")" : `, ${e})`}`;
  }
  function _0(e) {
    return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
  }
  function ic(e) {
    return Math.max(0, Math.min(255, Math.round(e) || 0));
  }
  function rc(e) {
    return e = ic(e), (e < 16 ? "0" : "") + e.toString(16);
  }
  function N$(e, t, n, r) {
    return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new Go(e, t, n, r);
  }
  function nB(e) {
    if (e instanceof Go) return new Go(e.h, e.s, e.l, e.opacity);
    if (e instanceof Jh || (e = hc(e)), !e) return new Go();
    if (e instanceof Go) return e;
    e = e.rgb();
    var t = e.r / 255, n = e.g / 255, r = e.b / 255, o = Math.min(t, n, r), i = Math.max(t, n, r), a = NaN, s = i - o, c = (i + o) / 2;
    return s ? (t === i ? a = (n - r) / s + (n < r) * 6 : n === i ? a = (r - t) / s + 2 : a = (t - n) / s + 4, s /= c < 0.5 ? i + o : 2 - i - o, a *= 60) : s = c > 0 && c < 1 ? 0 : a, new Go(a, s, c, e.opacity);
  }
  function Ohe(e, t, n, r) {
    return arguments.length === 1 ? nB(e) : new Go(e, t, n, r ?? 1);
  }
  function Go(e, t, n, r) {
    this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
  }
  CT(Go, Ohe, tB(Jh, {
    brighter(e) {
      return e = e == null ? S0 : Math.pow(S0, e), new Go(this.h, this.s, this.l * e, this.opacity);
    },
    darker(e) {
      return e = e == null ? oh : Math.pow(oh, e), new Go(this.h, this.s, this.l * e, this.opacity);
    },
    rgb() {
      var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * t, o = 2 * n - r;
      return new Br(
        e_(e >= 240 ? e - 240 : e + 120, o, r),
        e_(e, o, r),
        e_(e < 120 ? e + 240 : e - 120, o, r),
        this.opacity
      );
    },
    clamp() {
      return new Go(P$(this.h), gy(this.s), gy(this.l), _0(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
    },
    formatHsl() {
      const e = _0(this.opacity);
      return `${e === 1 ? "hsl(" : "hsla("}${P$(this.h)}, ${gy(this.s) * 100}%, ${gy(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
    }
  }));
  function P$(e) {
    return e = (e || 0) % 360, e < 0 ? e + 360 : e;
  }
  function gy(e) {
    return Math.max(0, Math.min(1, e || 0));
  }
  function e_(e, t, n) {
    return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
  }
  const kT = (e) => () => e;
  function Mhe(e, t) {
    return function(n) {
      return e + n * t;
    };
  }
  function Nhe(e, t, n) {
    return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(r) {
      return Math.pow(e + r * t, n);
    };
  }
  function Phe(e) {
    return (e = +e) == 1 ? rB : function(t, n) {
      return n - t ? Nhe(t, n, e) : kT(isNaN(t) ? n : t);
    };
  }
  function rB(e, t) {
    var n = t - e;
    return n ? Mhe(e, n) : kT(isNaN(e) ? t : e);
  }
  const E0 = (function e(t) {
    var n = Phe(t);
    function r(o, i) {
      var a = n((o = aC(o)).r, (i = aC(i)).r), s = n(o.g, i.g), c = n(o.b, i.b), u = rB(o.opacity, i.opacity);
      return function(d) {
        return o.r = a(d), o.g = s(d), o.b = c(d), o.opacity = u(d), o + "";
      };
    }
    return r.gamma = e, r;
  })(1);
  function Ihe(e, t) {
    t || (t = []);
    var n = e ? Math.min(t.length, e.length) : 0, r = t.slice(), o;
    return function(i) {
      for (o = 0; o < n; ++o) r[o] = e[o] * (1 - i) + t[o] * i;
      return r;
    };
  }
  function $he(e) {
    return ArrayBuffer.isView(e) && !(e instanceof DataView);
  }
  function jhe(e, t) {
    var n = t ? t.length : 0, r = e ? Math.min(n, e.length) : 0, o = new Array(r), i = new Array(n), a;
    for (a = 0; a < r; ++a) o[a] = Np(e[a], t[a]);
    for (; a < n; ++a) i[a] = t[a];
    return function(s) {
      for (a = 0; a < r; ++a) i[a] = o[a](s);
      return i;
    };
  }
  function Dhe(e, t) {
    var n = /* @__PURE__ */ new Date();
    return e = +e, t = +t, function(r) {
      return n.setTime(e * (1 - r) + t * r), n;
    };
  }
  function Ti(e, t) {
    return e = +e, t = +t, function(n) {
      return e * (1 - n) + t * n;
    };
  }
  function Fhe(e, t) {
    var n = {}, r = {}, o;
    (e === null || typeof e != "object") && (e = {}), (t === null || typeof t != "object") && (t = {});
    for (o in t)
      o in e ? n[o] = Np(e[o], t[o]) : r[o] = t[o];
    return function(i) {
      for (o in n) r[o] = n[o](i);
      return r;
    };
  }
  var sC = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, t_ = new RegExp(sC.source, "g");
  function Lhe(e) {
    return function() {
      return e;
    };
  }
  function zhe(e) {
    return function(t) {
      return e(t) + "";
    };
  }
  function oB(e, t) {
    var n = sC.lastIndex = t_.lastIndex = 0, r, o, i, a = -1, s = [], c = [];
    for (e = e + "", t = t + ""; (r = sC.exec(e)) && (o = t_.exec(t)); )
      (i = o.index) > n && (i = t.slice(n, i), s[a] ? s[a] += i : s[++a] = i), (r = r[0]) === (o = o[0]) ? s[a] ? s[a] += o : s[++a] = o : (s[++a] = null, c.push({ i: a, x: Ti(r, o) })), n = t_.lastIndex;
    return n < t.length && (i = t.slice(n), s[a] ? s[a] += i : s[++a] = i), s.length < 2 ? c[0] ? zhe(c[0].x) : Lhe(t) : (t = c.length, function(u) {
      for (var d = 0, p; d < t; ++d) s[(p = c[d]).i] = p.x(u);
      return s.join("");
    });
  }
  function Np(e, t) {
    var n = typeof t, r;
    return t == null || n === "boolean" ? kT(t) : (n === "number" ? Ti : n === "string" ? (r = hc(t)) ? (t = r, E0) : oB : t instanceof hc ? E0 : t instanceof Date ? Dhe : $he(t) ? Ihe : Array.isArray(t) ? jhe : typeof t.valueOf != "function" && typeof t.toString != "function" || isNaN(t) ? Fhe : Ti)(e, t);
  }
  var I$ = 180 / Math.PI, lC = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
  };
  function iB(e, t, n, r, o, i) {
    var a, s, c;
    return (a = Math.sqrt(e * e + t * t)) && (e /= a, t /= a), (c = e * n + t * r) && (n -= e * c, r -= t * c), (s = Math.sqrt(n * n + r * r)) && (n /= s, r /= s, c /= s), e * r < t * n && (e = -e, t = -t, c = -c, a = -a), {
      translateX: o,
      translateY: i,
      rotate: Math.atan2(t, e) * I$,
      skewX: Math.atan(c) * I$,
      scaleX: a,
      scaleY: s
    };
  }
  var yy;
  function Bhe(e) {
    const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
    return t.isIdentity ? lC : iB(t.a, t.b, t.c, t.d, t.e, t.f);
  }
  function Uhe(e) {
    return e == null || (yy || (yy = document.createElementNS("http://www.w3.org/2000/svg", "g")), yy.setAttribute("transform", e), !(e = yy.transform.baseVal.consolidate())) ? lC : (e = e.matrix, iB(e.a, e.b, e.c, e.d, e.e, e.f));
  }
  function aB(e, t, n, r) {
    function o(u) {
      return u.length ? u.pop() + " " : "";
    }
    function i(u, d, p, m, g, y) {
      if (u !== p || d !== m) {
        var b = g.push("translate(", null, t, null, n);
        y.push({ i: b - 4, x: Ti(u, p) }, { i: b - 2, x: Ti(d, m) });
      } else (p || m) && g.push("translate(" + p + t + m + n);
    }
    function a(u, d, p, m) {
      u !== d ? (u - d > 180 ? d += 360 : d - u > 180 && (u += 360), m.push({ i: p.push(o(p) + "rotate(", null, r) - 2, x: Ti(u, d) })) : d && p.push(o(p) + "rotate(" + d + r);
    }
    function s(u, d, p, m) {
      u !== d ? m.push({ i: p.push(o(p) + "skewX(", null, r) - 2, x: Ti(u, d) }) : d && p.push(o(p) + "skewX(" + d + r);
    }
    function c(u, d, p, m, g, y) {
      if (u !== p || d !== m) {
        var b = g.push(o(g) + "scale(", null, ",", null, ")");
        y.push({ i: b - 4, x: Ti(u, p) }, { i: b - 2, x: Ti(d, m) });
      } else (p !== 1 || m !== 1) && g.push(o(g) + "scale(" + p + "," + m + ")");
    }
    return function(u, d) {
      var p = [], m = [];
      return u = e(u), d = e(d), i(u.translateX, u.translateY, d.translateX, d.translateY, p, m), a(u.rotate, d.rotate, p, m), s(u.skewX, d.skewX, p, m), c(u.scaleX, u.scaleY, d.scaleX, d.scaleY, p, m), u = d = null, function(g) {
        for (var y = -1, b = m.length, v; ++y < b; ) p[(v = m[y]).i] = v.x(g);
        return p.join("");
      };
    };
  }
  var Vhe = aB(Bhe, "px, ", "px)", "deg)"), Hhe = aB(Uhe, ", ", ")", ")"), qhe = 1e-12;
  function $$(e) {
    return ((e = Math.exp(e)) + 1 / e) / 2;
  }
  function Whe(e) {
    return ((e = Math.exp(e)) - 1 / e) / 2;
  }
  function Ghe(e) {
    return ((e = Math.exp(2 * e)) - 1) / (e + 1);
  }
  const Lv = (function e(t, n, r) {
    function o(i, a) {
      var s = i[0], c = i[1], u = i[2], d = a[0], p = a[1], m = a[2], g = d - s, y = p - c, b = g * g + y * y, v, x;
      if (b < qhe)
        x = Math.log(m / u) / t, v = function(O) {
          return [
            s + O * g,
            c + O * y,
            u * Math.exp(t * O * x)
          ];
        };
      else {
        var E = Math.sqrt(b), _ = (m * m - u * u + r * b) / (2 * u * n * E), C = (m * m - u * u - r * b) / (2 * m * n * E), k = Math.log(Math.sqrt(_ * _ + 1) - _), A = Math.log(Math.sqrt(C * C + 1) - C);
        x = (A - k) / t, v = function(O) {
          var P = O * x, I = $$(k), $ = u / (n * E) * (I * Ghe(t * P + k) - Whe(k));
          return [
            s + $ * g,
            c + $ * y,
            u * I / $$(t * P + k)
          ];
        };
      }
      return v.duration = x * 1e3 * t / Math.SQRT2, v;
    }
    return o.rho = function(i) {
      var a = Math.max(1e-3, +i), s = a * a, c = s * s;
      return e(a, s, c);
    }, o;
  })(Math.SQRT2, 2, 4);
  var bf = 0, vp = 0, Yd = 0, sB = 1e3, C0, bp, k0 = 0, mc = 0, Yb = 0, ah = typeof performance == "object" && performance.now ? performance : Date, lB = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
    setTimeout(e, 17);
  };
  function TT() {
    return mc || (lB(Khe), mc = ah.now() + Yb);
  }
  function Khe() {
    mc = 0;
  }
  function T0() {
    this._call = this._time = this._next = null;
  }
  T0.prototype = cB.prototype = {
    constructor: T0,
    restart: function(e, t, n) {
      if (typeof e != "function") throw new TypeError("callback is not a function");
      n = (n == null ? TT() : +n) + (t == null ? 0 : +t), !this._next && bp !== this && (bp ? bp._next = this : C0 = this, bp = this), this._call = e, this._time = n, cC();
    },
    stop: function() {
      this._call && (this._call = null, this._time = 1 / 0, cC());
    }
  };
  function cB(e, t, n) {
    var r = new T0();
    return r.restart(e, t, n), r;
  }
  function Yhe() {
    TT(), ++bf;
    for (var e = C0, t; e; )
      (t = mc - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
    --bf;
  }
  function j$() {
    mc = (k0 = ah.now()) + Yb, bf = vp = 0;
    try {
      Yhe();
    } finally {
      bf = 0, Zhe(), mc = 0;
    }
  }
  function Xhe() {
    var e = ah.now(), t = e - k0;
    t > sB && (Yb -= t, k0 = e);
  }
  function Zhe() {
    for (var e, t = C0, n, r = 1 / 0; t; )
      t._call ? (r > t._time && (r = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : C0 = n);
    bp = e, cC(r);
  }
  function cC(e) {
    if (!bf) {
      vp && (vp = clearTimeout(vp));
      var t = e - mc;
      t > 24 ? (e < 1 / 0 && (vp = setTimeout(j$, e - ah.now() - Yb)), Yd && (Yd = clearInterval(Yd))) : (Yd || (k0 = ah.now(), Yd = setInterval(Xhe, sB)), bf = 1, lB(j$));
    }
  }
  function D$(e, t, n) {
    var r = new T0();
    return t = t == null ? 0 : +t, r.restart((o) => {
      r.stop(), e(o + t);
    }, t, n), r;
  }
  var Qhe = Gb("start", "end", "cancel", "interrupt"), Jhe = [], uB = 0, F$ = 1, uC = 2, zv = 3, L$ = 4, fC = 5, Bv = 6;
  function Xb(e, t, n, r, o, i) {
    var a = e.__transition;
    if (!a) e.__transition = {};
    else if (n in a) return;
    eme(e, n, {
      name: t,
      index: r,
      // For context during callback.
      group: o,
      // For context during callback.
      on: Qhe,
      tween: Jhe,
      time: i.time,
      delay: i.delay,
      duration: i.duration,
      ease: i.ease,
      timer: null,
      state: uB
    });
  }
  function AT(e, t) {
    var n = li(e, t);
    if (n.state > uB) throw new Error("too late; already scheduled");
    return n;
  }
  function ta(e, t) {
    var n = li(e, t);
    if (n.state > zv) throw new Error("too late; already running");
    return n;
  }
  function li(e, t) {
    var n = e.__transition;
    if (!n || !(n = n[t])) throw new Error("transition not found");
    return n;
  }
  function eme(e, t, n) {
    var r = e.__transition, o;
    r[t] = n, n.timer = cB(i, 0, n.time);
    function i(u) {
      n.state = F$, n.timer.restart(a, n.delay, n.time), n.delay <= u && a(u - n.delay);
    }
    function a(u) {
      var d, p, m, g;
      if (n.state !== F$) return c();
      for (d in r)
        if (g = r[d], g.name === n.name) {
          if (g.state === zv) return D$(a);
          g.state === L$ ? (g.state = Bv, g.timer.stop(), g.on.call("interrupt", e, e.__data__, g.index, g.group), delete r[d]) : +d < t && (g.state = Bv, g.timer.stop(), g.on.call("cancel", e, e.__data__, g.index, g.group), delete r[d]);
        }
      if (D$(function() {
        n.state === zv && (n.state = L$, n.timer.restart(s, n.delay, n.time), s(u));
      }), n.state = uC, n.on.call("start", e, e.__data__, n.index, n.group), n.state === uC) {
        for (n.state = zv, o = new Array(m = n.tween.length), d = 0, p = -1; d < m; ++d)
          (g = n.tween[d].value.call(e, e.__data__, n.index, n.group)) && (o[++p] = g);
        o.length = p + 1;
      }
    }
    function s(u) {
      for (var d = u < n.duration ? n.ease.call(null, u / n.duration) : (n.timer.restart(c), n.state = fC, 1), p = -1, m = o.length; ++p < m; )
        o[p].call(e, d);
      n.state === fC && (n.on.call("end", e, e.__data__, n.index, n.group), c());
    }
    function c() {
      n.state = Bv, n.timer.stop(), delete r[t];
      for (var u in r) return;
      delete e.__transition;
    }
  }
  function Uv(e, t) {
    var n = e.__transition, r, o, i = !0, a;
    if (n) {
      t = t == null ? null : t + "";
      for (a in n) {
        if ((r = n[a]).name !== t) {
          i = !1;
          continue;
        }
        o = r.state > uC && r.state < fC, r.state = Bv, r.timer.stop(), r.on.call(o ? "interrupt" : "cancel", e, e.__data__, r.index, r.group), delete n[a];
      }
      i && delete e.__transition;
    }
  }
  function tme(e) {
    return this.each(function() {
      Uv(this, e);
    });
  }
  function nme(e, t) {
    var n, r;
    return function() {
      var o = ta(this, e), i = o.tween;
      if (i !== n) {
        r = n = i;
        for (var a = 0, s = r.length; a < s; ++a)
          if (r[a].name === t) {
            r = r.slice(), r.splice(a, 1);
            break;
          }
      }
      o.tween = r;
    };
  }
  function rme(e, t, n) {
    var r, o;
    if (typeof n != "function") throw new Error();
    return function() {
      var i = ta(this, e), a = i.tween;
      if (a !== r) {
        o = (r = a).slice();
        for (var s = { name: t, value: n }, c = 0, u = o.length; c < u; ++c)
          if (o[c].name === t) {
            o[c] = s;
            break;
          }
        c === u && o.push(s);
      }
      i.tween = o;
    };
  }
  function ome(e, t) {
    var n = this._id;
    if (e += "", arguments.length < 2) {
      for (var r = li(this.node(), n).tween, o = 0, i = r.length, a; o < i; ++o)
        if ((a = r[o]).name === e)
          return a.value;
      return null;
    }
    return this.each((t == null ? nme : rme)(n, e, t));
  }
  function RT(e, t, n) {
    var r = e._id;
    return e.each(function() {
      var o = ta(this, r);
      (o.value || (o.value = {}))[t] = n.apply(this, arguments);
    }), function(o) {
      return li(o, r).value[t];
    };
  }
  function fB(e, t) {
    var n;
    return (typeof t == "number" ? Ti : t instanceof hc ? E0 : (n = hc(t)) ? (t = n, E0) : oB)(e, t);
  }
  function ime(e) {
    return function() {
      this.removeAttribute(e);
    };
  }
  function ame(e) {
    return function() {
      this.removeAttributeNS(e.space, e.local);
    };
  }
  function sme(e, t, n) {
    var r, o = n + "", i;
    return function() {
      var a = this.getAttribute(e);
      return a === o ? null : a === r ? i : i = t(r = a, n);
    };
  }
  function lme(e, t, n) {
    var r, o = n + "", i;
    return function() {
      var a = this.getAttributeNS(e.space, e.local);
      return a === o ? null : a === r ? i : i = t(r = a, n);
    };
  }
  function cme(e, t, n) {
    var r, o, i;
    return function() {
      var a, s = n(this), c;
      return s == null ? void this.removeAttribute(e) : (a = this.getAttribute(e), c = s + "", a === c ? null : a === r && c === o ? i : (o = c, i = t(r = a, s)));
    };
  }
  function ume(e, t, n) {
    var r, o, i;
    return function() {
      var a, s = n(this), c;
      return s == null ? void this.removeAttributeNS(e.space, e.local) : (a = this.getAttributeNS(e.space, e.local), c = s + "", a === c ? null : a === r && c === o ? i : (o = c, i = t(r = a, s)));
    };
  }
  function fme(e, t) {
    var n = Kb(e), r = n === "transform" ? Hhe : fB;
    return this.attrTween(e, typeof t == "function" ? (n.local ? ume : cme)(n, r, RT(this, "attr." + e, t)) : t == null ? (n.local ? ame : ime)(n) : (n.local ? lme : sme)(n, r, t));
  }
  function dme(e, t) {
    return function(n) {
      this.setAttribute(e, t.call(this, n));
    };
  }
  function pme(e, t) {
    return function(n) {
      this.setAttributeNS(e.space, e.local, t.call(this, n));
    };
  }
  function hme(e, t) {
    var n, r;
    function o() {
      var i = t.apply(this, arguments);
      return i !== r && (n = (r = i) && pme(e, i)), n;
    }
    return o._value = t, o;
  }
  function mme(e, t) {
    var n, r;
    function o() {
      var i = t.apply(this, arguments);
      return i !== r && (n = (r = i) && dme(e, i)), n;
    }
    return o._value = t, o;
  }
  function gme(e, t) {
    var n = "attr." + e;
    if (arguments.length < 2) return (n = this.tween(n)) && n._value;
    if (t == null) return this.tween(n, null);
    if (typeof t != "function") throw new Error();
    var r = Kb(e);
    return this.tween(n, (r.local ? hme : mme)(r, t));
  }
  function yme(e, t) {
    return function() {
      AT(this, e).delay = +t.apply(this, arguments);
    };
  }
  function vme(e, t) {
    return t = +t, function() {
      AT(this, e).delay = t;
    };
  }
  function bme(e) {
    var t = this._id;
    return arguments.length ? this.each((typeof e == "function" ? yme : vme)(t, e)) : li(this.node(), t).delay;
  }
  function xme(e, t) {
    return function() {
      ta(this, e).duration = +t.apply(this, arguments);
    };
  }
  function wme(e, t) {
    return t = +t, function() {
      ta(this, e).duration = t;
    };
  }
  function Sme(e) {
    var t = this._id;
    return arguments.length ? this.each((typeof e == "function" ? xme : wme)(t, e)) : li(this.node(), t).duration;
  }
  function _me(e, t) {
    if (typeof t != "function") throw new Error();
    return function() {
      ta(this, e).ease = t;
    };
  }
  function Eme(e) {
    var t = this._id;
    return arguments.length ? this.each(_me(t, e)) : li(this.node(), t).ease;
  }
  function Cme(e, t) {
    return function() {
      var n = t.apply(this, arguments);
      if (typeof n != "function") throw new Error();
      ta(this, e).ease = n;
    };
  }
  function kme(e) {
    if (typeof e != "function") throw new Error();
    return this.each(Cme(this._id, e));
  }
  function Tme(e) {
    typeof e != "function" && (e = U9(e));
    for (var t = this._groups, n = t.length, r = new Array(n), o = 0; o < n; ++o)
      for (var i = t[o], a = i.length, s = r[o] = [], c, u = 0; u < a; ++u)
        (c = i[u]) && e.call(c, c.__data__, u, i) && s.push(c);
    return new Xa(r, this._parents, this._name, this._id);
  }
  function Ame(e) {
    if (e._id !== this._id) throw new Error();
    for (var t = this._groups, n = e._groups, r = t.length, o = n.length, i = Math.min(r, o), a = new Array(r), s = 0; s < i; ++s)
      for (var c = t[s], u = n[s], d = c.length, p = a[s] = new Array(d), m, g = 0; g < d; ++g)
        (m = c[g] || u[g]) && (p[g] = m);
    for (; s < r; ++s)
      a[s] = t[s];
    return new Xa(a, this._parents, this._name, this._id);
  }
  function Rme(e) {
    return (e + "").trim().split(/^|\s+/).every(function(t) {
      var n = t.indexOf(".");
      return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
    });
  }
  function Ome(e, t, n) {
    var r, o, i = Rme(t) ? AT : ta;
    return function() {
      var a = i(this, e), s = a.on;
      s !== r && (o = (r = s).copy()).on(t, n), a.on = o;
    };
  }
  function Mme(e, t) {
    var n = this._id;
    return arguments.length < 2 ? li(this.node(), n).on.on(e) : this.each(Ome(n, e, t));
  }
  function Nme(e) {
    return function() {
      var t = this.parentNode;
      for (var n in this.__transition) if (+n !== e) return;
      t && t.removeChild(this);
    };
  }
  function Pme() {
    return this.on("end.remove", Nme(this._id));
  }
  function Ime(e) {
    var t = this._name, n = this._id;
    typeof e != "function" && (e = _T(e));
    for (var r = this._groups, o = r.length, i = new Array(o), a = 0; a < o; ++a)
      for (var s = r[a], c = s.length, u = i[a] = new Array(c), d, p, m = 0; m < c; ++m)
        (d = s[m]) && (p = e.call(d, d.__data__, m, s)) && ("__data__" in d && (p.__data__ = d.__data__), u[m] = p, Xb(u[m], t, n, m, u, li(d, n)));
    return new Xa(i, this._parents, t, n);
  }
  function $me(e) {
    var t = this._name, n = this._id;
    typeof e != "function" && (e = B9(e));
    for (var r = this._groups, o = r.length, i = [], a = [], s = 0; s < o; ++s)
      for (var c = r[s], u = c.length, d, p = 0; p < u; ++p)
        if (d = c[p]) {
          for (var m = e.call(d, d.__data__, p, c), g, y = li(d, n), b = 0, v = m.length; b < v; ++b)
            (g = m[b]) && Xb(g, t, n, b, m, y);
          i.push(m), a.push(d);
        }
    return new Xa(i, a, t, n);
  }
  var jme = Qh.prototype.constructor;
  function Dme() {
    return new jme(this._groups, this._parents);
  }
  function Fme(e, t) {
    var n, r, o;
    return function() {
      var i = vf(this, e), a = (this.style.removeProperty(e), vf(this, e));
      return i === a ? null : i === n && a === r ? o : o = t(n = i, r = a);
    };
  }
  function dB(e) {
    return function() {
      this.style.removeProperty(e);
    };
  }
  function Lme(e, t, n) {
    var r, o = n + "", i;
    return function() {
      var a = vf(this, e);
      return a === o ? null : a === r ? i : i = t(r = a, n);
    };
  }
  function zme(e, t, n) {
    var r, o, i;
    return function() {
      var a = vf(this, e), s = n(this), c = s + "";
      return s == null && (c = s = (this.style.removeProperty(e), vf(this, e))), a === c ? null : a === r && c === o ? i : (o = c, i = t(r = a, s));
    };
  }
  function Bme(e, t) {
    var n, r, o, i = "style." + t, a = "end." + i, s;
    return function() {
      var c = ta(this, e), u = c.on, d = c.value[i] == null ? s || (s = dB(t)) : void 0;
      (u !== n || o !== d) && (r = (n = u).copy()).on(a, o = d), c.on = r;
    };
  }
  function Ume(e, t, n) {
    var r = (e += "") == "transform" ? Vhe : fB;
    return t == null ? this.styleTween(e, Fme(e, r)).on("end.style." + e, dB(e)) : typeof t == "function" ? this.styleTween(e, zme(e, r, RT(this, "style." + e, t))).each(Bme(this._id, e)) : this.styleTween(e, Lme(e, r, t), n).on("end.style." + e, null);
  }
  function Vme(e, t, n) {
    return function(r) {
      this.style.setProperty(e, t.call(this, r), n);
    };
  }
  function Hme(e, t, n) {
    var r, o;
    function i() {
      var a = t.apply(this, arguments);
      return a !== o && (r = (o = a) && Vme(e, a, n)), r;
    }
    return i._value = t, i;
  }
  function qme(e, t, n) {
    var r = "style." + (e += "");
    if (arguments.length < 2) return (r = this.tween(r)) && r._value;
    if (t == null) return this.tween(r, null);
    if (typeof t != "function") throw new Error();
    return this.tween(r, Hme(e, t, n ?? ""));
  }
  function Wme(e) {
    return function() {
      this.textContent = e;
    };
  }
  function Gme(e) {
    return function() {
      var t = e(this);
      this.textContent = t ?? "";
    };
  }
  function Kme(e) {
    return this.tween("text", typeof e == "function" ? Gme(RT(this, "text", e)) : Wme(e == null ? "" : e + ""));
  }
  function Yme(e) {
    return function(t) {
      this.textContent = e.call(this, t);
    };
  }
  function Xme(e) {
    var t, n;
    function r() {
      var o = e.apply(this, arguments);
      return o !== n && (t = (n = o) && Yme(o)), t;
    }
    return r._value = e, r;
  }
  function Zme(e) {
    var t = "text";
    if (arguments.length < 1) return (t = this.tween(t)) && t._value;
    if (e == null) return this.tween(t, null);
    if (typeof e != "function") throw new Error();
    return this.tween(t, Xme(e));
  }
  function Qme() {
    for (var e = this._name, t = this._id, n = pB(), r = this._groups, o = r.length, i = 0; i < o; ++i)
      for (var a = r[i], s = a.length, c, u = 0; u < s; ++u)
        if (c = a[u]) {
          var d = li(c, t);
          Xb(c, e, n, u, a, {
            time: d.time + d.delay + d.duration,
            delay: 0,
            duration: d.duration,
            ease: d.ease
          });
        }
    return new Xa(r, this._parents, e, n);
  }
  function Jme() {
    var e, t, n = this, r = n._id, o = n.size();
    return new Promise(function(i, a) {
      var s = { value: a }, c = { value: function() {
        --o === 0 && i();
      } };
      n.each(function() {
        var u = ta(this, r), d = u.on;
        d !== e && (t = (e = d).copy(), t._.cancel.push(s), t._.interrupt.push(s), t._.end.push(c)), u.on = t;
      }), o === 0 && i();
    });
  }
  var ege = 0;
  function Xa(e, t, n, r) {
    this._groups = e, this._parents = t, this._name = n, this._id = r;
  }
  function pB() {
    return ++ege;
  }
  var Ra = Qh.prototype;
  Xa.prototype = {
    constructor: Xa,
    select: Ime,
    selectAll: $me,
    selectChild: Ra.selectChild,
    selectChildren: Ra.selectChildren,
    filter: Tme,
    merge: Ame,
    selection: Dme,
    transition: Qme,
    call: Ra.call,
    nodes: Ra.nodes,
    node: Ra.node,
    size: Ra.size,
    empty: Ra.empty,
    each: Ra.each,
    on: Mme,
    attr: fme,
    attrTween: gme,
    style: Ume,
    styleTween: qme,
    text: Kme,
    textTween: Zme,
    remove: Pme,
    tween: ome,
    delay: bme,
    duration: Sme,
    ease: Eme,
    easeVarying: kme,
    end: Jme,
    [Symbol.iterator]: Ra[Symbol.iterator]
  };
  function tge(e) {
    return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
  }
  var nge = {
    time: null,
    // Set on use.
    delay: 0,
    duration: 250,
    ease: tge
  };
  function rge(e, t) {
    for (var n; !(n = e.__transition) || !(n = n[t]); )
      if (!(e = e.parentNode))
        throw new Error(`transition ${t} not found`);
    return n;
  }
  function oge(e) {
    var t, n;
    e instanceof Xa ? (t = e._id, e = e._name) : (t = pB(), (n = nge).time = TT(), e = e == null ? null : e + "");
    for (var r = this._groups, o = r.length, i = 0; i < o; ++i)
      for (var a = r[i], s = a.length, c, u = 0; u < s; ++u)
        (c = a[u]) && Xb(c, e, t, u, a, n || rge(c, t));
    return new Xa(r, this._parents, e, t);
  }
  Qh.prototype.interrupt = tme;
  Qh.prototype.transition = oge;
  const vy = (e) => () => e;
  function ige(e, {
    sourceEvent: t,
    target: n,
    transform: r,
    dispatch: o
  }) {
    Object.defineProperties(this, {
      type: { value: e, enumerable: !0, configurable: !0 },
      sourceEvent: { value: t, enumerable: !0, configurable: !0 },
      target: { value: n, enumerable: !0, configurable: !0 },
      transform: { value: r, enumerable: !0, configurable: !0 },
      _: { value: o }
    });
  }
  function Da(e, t, n) {
    this.k = e, this.x = t, this.y = n;
  }
  Da.prototype = {
    constructor: Da,
    scale: function(e) {
      return e === 1 ? this : new Da(this.k * e, this.x, this.y);
    },
    translate: function(e, t) {
      return e === 0 & t === 0 ? this : new Da(this.k, this.x + this.k * e, this.y + this.k * t);
    },
    apply: function(e) {
      return [e[0] * this.k + this.x, e[1] * this.k + this.y];
    },
    applyX: function(e) {
      return e * this.k + this.x;
    },
    applyY: function(e) {
      return e * this.k + this.y;
    },
    invert: function(e) {
      return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
    },
    invertX: function(e) {
      return (e - this.x) / this.k;
    },
    invertY: function(e) {
      return (e - this.y) / this.k;
    },
    rescaleX: function(e) {
      return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
    },
    rescaleY: function(e) {
      return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
    },
    toString: function() {
      return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
    }
  };
  var Zb = new Da(1, 0, 0);
  hB.prototype = Da.prototype;
  function hB(e) {
    for (; !e.__zoom; ) if (!(e = e.parentNode)) return Zb;
    return e.__zoom;
  }
  function n_(e) {
    e.stopImmediatePropagation();
  }
  function Xd(e) {
    e.preventDefault(), e.stopImmediatePropagation();
  }
  function age(e) {
    return (!e.ctrlKey || e.type === "wheel") && !e.button;
  }
  function sge() {
    var e = this;
    return e instanceof SVGElement ? (e = e.ownerSVGElement || e, e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]]) : [[0, 0], [e.clientWidth, e.clientHeight]];
  }
  function z$() {
    return this.__zoom || Zb;
  }
  function lge(e) {
    return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * (e.ctrlKey ? 10 : 1);
  }
  function cge() {
    return navigator.maxTouchPoints || "ontouchstart" in this;
  }
  function uge(e, t, n) {
    var r = e.invertX(t[0][0]) - n[0][0], o = e.invertX(t[1][0]) - n[1][0], i = e.invertY(t[0][1]) - n[0][1], a = e.invertY(t[1][1]) - n[1][1];
    return e.translate(
      o > r ? (r + o) / 2 : Math.min(0, r) || Math.max(0, o),
      a > i ? (i + a) / 2 : Math.min(0, i) || Math.max(0, a)
    );
  }
  function mB() {
    var e = age, t = sge, n = uge, r = lge, o = cge, i = [0, 1 / 0], a = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], s = 250, c = Lv, u = Gb("start", "zoom", "end"), d, p, m, g = 500, y = 150, b = 0, v = 10;
    function x(j) {
      j.property("__zoom", z$).on("wheel.zoom", P, { passive: !1 }).on("mousedown.zoom", I).on("dblclick.zoom", $).filter(o).on("touchstart.zoom", L).on("touchmove.zoom", N).on("touchend.zoom touchcancel.zoom", U).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
    }
    x.transform = function(j, V, F, K) {
      var W = j.selection ? j.selection() : j;
      W.property("__zoom", z$), j !== W ? k(j, V, F, K) : W.interrupt().each(function() {
        A(this, arguments).event(K).start().zoom(null, typeof V == "function" ? V.apply(this, arguments) : V).end();
      });
    }, x.scaleBy = function(j, V, F, K) {
      x.scaleTo(j, function() {
        var W = this.__zoom.k, Y = typeof V == "function" ? V.apply(this, arguments) : V;
        return W * Y;
      }, F, K);
    }, x.scaleTo = function(j, V, F, K) {
      x.transform(j, function() {
        var W = t.apply(this, arguments), Y = this.__zoom, B = F == null ? C(W) : typeof F == "function" ? F.apply(this, arguments) : F, D = Y.invert(B), G = typeof V == "function" ? V.apply(this, arguments) : V;
        return n(_(E(Y, G), B, D), W, a);
      }, F, K);
    }, x.translateBy = function(j, V, F, K) {
      x.transform(j, function() {
        return n(this.__zoom.translate(
          typeof V == "function" ? V.apply(this, arguments) : V,
          typeof F == "function" ? F.apply(this, arguments) : F
        ), t.apply(this, arguments), a);
      }, null, K);
    }, x.translateTo = function(j, V, F, K, W) {
      x.transform(j, function() {
        var Y = t.apply(this, arguments), B = this.__zoom, D = K == null ? C(Y) : typeof K == "function" ? K.apply(this, arguments) : K;
        return n(Zb.translate(D[0], D[1]).scale(B.k).translate(
          typeof V == "function" ? -V.apply(this, arguments) : -V,
          typeof F == "function" ? -F.apply(this, arguments) : -F
        ), Y, a);
      }, K, W);
    };
    function E(j, V) {
      return V = Math.max(i[0], Math.min(i[1], V)), V === j.k ? j : new Da(V, j.x, j.y);
    }
    function _(j, V, F) {
      var K = V[0] - F[0] * j.k, W = V[1] - F[1] * j.k;
      return K === j.x && W === j.y ? j : new Da(j.k, K, W);
    }
    function C(j) {
      return [(+j[0][0] + +j[1][0]) / 2, (+j[0][1] + +j[1][1]) / 2];
    }
    function k(j, V, F, K) {
      j.on("start.zoom", function() {
        A(this, arguments).event(K).start();
      }).on("interrupt.zoom end.zoom", function() {
        A(this, arguments).event(K).end();
      }).tween("zoom", function() {
        var W = this, Y = arguments, B = A(W, Y).event(K), D = t.apply(W, Y), G = F == null ? C(D) : typeof F == "function" ? F.apply(W, Y) : F, z = Math.max(D[1][0] - D[0][0], D[1][1] - D[0][1]), H = W.__zoom, X = typeof V == "function" ? V.apply(W, Y) : V, Q = c(H.invert(G).concat(z / H.k), X.invert(G).concat(z / X.k));
        return function(ne) {
          if (ne === 1) ne = X;
          else {
            var te = Q(ne), se = z / te[2];
            ne = new Da(se, G[0] - te[0] * se, G[1] - te[1] * se);
          }
          B.zoom(null, ne);
        };
      });
    }
    function A(j, V, F) {
      return !F && j.__zooming || new O(j, V);
    }
    function O(j, V) {
      this.that = j, this.args = V, this.active = 0, this.sourceEvent = null, this.extent = t.apply(j, V), this.taps = 0;
    }
    O.prototype = {
      event: function(j) {
        return j && (this.sourceEvent = j), this;
      },
      start: function() {
        return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
      },
      zoom: function(j, V) {
        return this.mouse && j !== "mouse" && (this.mouse[1] = V.invert(this.mouse[0])), this.touch0 && j !== "touch" && (this.touch0[1] = V.invert(this.touch0[0])), this.touch1 && j !== "touch" && (this.touch1[1] = V.invert(this.touch1[0])), this.that.__zoom = V, this.emit("zoom"), this;
      },
      end: function() {
        return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
      },
      emit: function(j) {
        var V = io(this.that).datum();
        u.call(
          j,
          this.that,
          new ige(j, {
            sourceEvent: this.sourceEvent,
            target: x,
            transform: this.that.__zoom,
            dispatch: u
          }),
          V
        );
      }
    };
    function P(j, ...V) {
      if (!e.apply(this, arguments)) return;
      var F = A(this, V).event(j), K = this.__zoom, W = Math.max(i[0], Math.min(i[1], K.k * Math.pow(2, r.apply(this, arguments)))), Y = Wo(j);
      if (F.wheel)
        (F.mouse[0][0] !== Y[0] || F.mouse[0][1] !== Y[1]) && (F.mouse[1] = K.invert(F.mouse[0] = Y)), clearTimeout(F.wheel);
      else {
        if (K.k === W) return;
        F.mouse = [Y, K.invert(Y)], Uv(this), F.start();
      }
      Xd(j), F.wheel = setTimeout(B, y), F.zoom("mouse", n(_(E(K, W), F.mouse[0], F.mouse[1]), F.extent, a));
      function B() {
        F.wheel = null, F.end();
      }
    }
    function I(j, ...V) {
      if (m || !e.apply(this, arguments)) return;
      var F = j.currentTarget, K = A(this, V, !0).event(j), W = io(j.view).on("mousemove.zoom", G, !0).on("mouseup.zoom", z, !0), Y = Wo(j, F), B = j.clientX, D = j.clientY;
      Q9(j.view), n_(j), K.mouse = [Y, this.__zoom.invert(Y)], Uv(this), K.start();
      function G(H) {
        if (Xd(H), !K.moved) {
          var X = H.clientX - B, Q = H.clientY - D;
          K.moved = X * X + Q * Q > b;
        }
        K.event(H).zoom("mouse", n(_(K.that.__zoom, K.mouse[0] = Wo(H, F), K.mouse[1]), K.extent, a));
      }
      function z(H) {
        W.on("mousemove.zoom mouseup.zoom", null), J9(H.view, K.moved), Xd(H), K.event(H).end();
      }
    }
    function $(j, ...V) {
      if (e.apply(this, arguments)) {
        var F = this.__zoom, K = Wo(j.changedTouches ? j.changedTouches[0] : j, this), W = F.invert(K), Y = F.k * (j.shiftKey ? 0.5 : 2), B = n(_(E(F, Y), K, W), t.apply(this, V), a);
        Xd(j), s > 0 ? io(this).transition().duration(s).call(k, B, K, j) : io(this).call(x.transform, B, K, j);
      }
    }
    function L(j, ...V) {
      if (e.apply(this, arguments)) {
        var F = j.touches, K = F.length, W = A(this, V, j.changedTouches.length === K).event(j), Y, B, D, G;
        for (n_(j), B = 0; B < K; ++B)
          D = F[B], G = Wo(D, this), G = [G, this.__zoom.invert(G), D.identifier], W.touch0 ? !W.touch1 && W.touch0[2] !== G[2] && (W.touch1 = G, W.taps = 0) : (W.touch0 = G, Y = !0, W.taps = 1 + !!d);
        d && (d = clearTimeout(d)), Y && (W.taps < 2 && (p = G[0], d = setTimeout(function() {
          d = null;
        }, g)), Uv(this), W.start());
      }
    }
    function N(j, ...V) {
      if (this.__zooming) {
        var F = A(this, V).event(j), K = j.changedTouches, W = K.length, Y, B, D, G;
        for (Xd(j), Y = 0; Y < W; ++Y)
          B = K[Y], D = Wo(B, this), F.touch0 && F.touch0[2] === B.identifier ? F.touch0[0] = D : F.touch1 && F.touch1[2] === B.identifier && (F.touch1[0] = D);
        if (B = F.that.__zoom, F.touch1) {
          var z = F.touch0[0], H = F.touch0[1], X = F.touch1[0], Q = F.touch1[1], ne = (ne = X[0] - z[0]) * ne + (ne = X[1] - z[1]) * ne, te = (te = Q[0] - H[0]) * te + (te = Q[1] - H[1]) * te;
          B = E(B, Math.sqrt(ne / te)), D = [(z[0] + X[0]) / 2, (z[1] + X[1]) / 2], G = [(H[0] + Q[0]) / 2, (H[1] + Q[1]) / 2];
        } else if (F.touch0) D = F.touch0[0], G = F.touch0[1];
        else return;
        F.zoom("touch", n(_(B, D, G), F.extent, a));
      }
    }
    function U(j, ...V) {
      if (this.__zooming) {
        var F = A(this, V).event(j), K = j.changedTouches, W = K.length, Y, B;
        for (n_(j), m && clearTimeout(m), m = setTimeout(function() {
          m = null;
        }, g), Y = 0; Y < W; ++Y)
          B = K[Y], F.touch0 && F.touch0[2] === B.identifier ? delete F.touch0 : F.touch1 && F.touch1[2] === B.identifier && delete F.touch1;
        if (F.touch1 && !F.touch0 && (F.touch0 = F.touch1, delete F.touch1), F.touch0) F.touch0[1] = this.__zoom.invert(F.touch0[0]);
        else if (F.end(), F.taps === 2 && (B = Wo(B, this), Math.hypot(p[0] - B[0], p[1] - B[1]) < v)) {
          var D = io(this).on("dblclick.zoom");
          D && D.apply(this, arguments);
        }
      }
    }
    return x.wheelDelta = function(j) {
      return arguments.length ? (r = typeof j == "function" ? j : vy(+j), x) : r;
    }, x.filter = function(j) {
      return arguments.length ? (e = typeof j == "function" ? j : vy(!!j), x) : e;
    }, x.touchable = function(j) {
      return arguments.length ? (o = typeof j == "function" ? j : vy(!!j), x) : o;
    }, x.extent = function(j) {
      return arguments.length ? (t = typeof j == "function" ? j : vy([[+j[0][0], +j[0][1]], [+j[1][0], +j[1][1]]]), x) : t;
    }, x.scaleExtent = function(j) {
      return arguments.length ? (i[0] = +j[0], i[1] = +j[1], x) : [i[0], i[1]];
    }, x.translateExtent = function(j) {
      return arguments.length ? (a[0][0] = +j[0][0], a[1][0] = +j[1][0], a[0][1] = +j[0][1], a[1][1] = +j[1][1], x) : [[a[0][0], a[0][1]], [a[1][0], a[1][1]]];
    }, x.constrain = function(j) {
      return arguments.length ? (n = j, x) : n;
    }, x.duration = function(j) {
      return arguments.length ? (s = +j, x) : s;
    }, x.interpolate = function(j) {
      return arguments.length ? (c = j, x) : c;
    }, x.on = function() {
      var j = u.on.apply(u, arguments);
      return j === u ? x : j;
    }, x.clickDistance = function(j) {
      return arguments.length ? (b = (j = +j) * j, x) : Math.sqrt(b);
    }, x.tapDistance = function(j) {
      return arguments.length ? (v = +j, x) : v;
    }, x;
  }
  const Gi = {
    error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
    error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
    error003: (e) => `Node type "${e}" not found. Using fallback type "default".`,
    error004: () => "The React Flow parent container needs a width and a height to render the graph.",
    error005: () => "Only child nodes can use a parent extent.",
    error006: () => "Can't create edge. An edge needs a source and a target.",
    error007: (e) => `The old edge with id=${e} does not exist.`,
    error009: (e) => `Marker type "${e}" doesn't exist.`,
    error008: (e, { id: t, sourceHandle: n, targetHandle: r }) => `Couldn't create edge for ${e} handle id: "${e === "source" ? n : r}", edge id: ${t}.`,
    error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
    error011: (e) => `Edge type "${e}" not found. Using fallback type "default".`,
    error012: (e) => `Node with id "${e}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
    error013: (e = "react") => `It seems that you haven't loaded the styles. Please import '@xyflow/${e}/dist/style.css' or base.css to make sure everything is working properly.`,
    error014: () => "useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.",
    error015: () => "It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs."
  }, sh = [
    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
  ], gB = ["Enter", " ", "Escape"], yB = {
    "node.a11yDescription.default": "Press enter or space to select a node. Press delete to remove it and escape to cancel.",
    "node.a11yDescription.keyboardDisabled": "Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.",
    "node.a11yDescription.ariaLiveMessage": ({ direction: e, x: t, y: n }) => `Moved selected node ${e}. New position, x: ${t}, y: ${n}`,
    "edge.a11yDescription.default": "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.",
    // Control elements
    "controls.ariaLabel": "Control Panel",
    "controls.zoomIn.ariaLabel": "Zoom In",
    "controls.zoomOut.ariaLabel": "Zoom Out",
    "controls.fitView.ariaLabel": "Fit View",
    "controls.interactive.ariaLabel": "Toggle Interactivity",
    // Mini map
    "minimap.ariaLabel": "Mini Map",
    // Handle
    "handle.ariaLabel": "Handle"
  };
  var xf;
  (function(e) {
    e.Strict = "strict", e.Loose = "loose";
  })(xf || (xf = {}));
  var ac;
  (function(e) {
    e.Free = "free", e.Vertical = "vertical", e.Horizontal = "horizontal";
  })(ac || (ac = {}));
  var lh;
  (function(e) {
    e.Partial = "partial", e.Full = "full";
  })(lh || (lh = {}));
  const vB = {
    inProgress: !1,
    isValid: null,
    from: null,
    fromHandle: null,
    fromPosition: null,
    fromNode: null,
    to: null,
    toHandle: null,
    toPosition: null,
    toNode: null,
    pointer: null
  };
  var qs;
  (function(e) {
    e.Bezier = "default", e.Straight = "straight", e.Step = "step", e.SmoothStep = "smoothstep", e.SimpleBezier = "simplebezier";
  })(qs || (qs = {}));
  var A0;
  (function(e) {
    e.Arrow = "arrow", e.ArrowClosed = "arrowclosed";
  })(A0 || (A0 = {}));
  var Ve;
  (function(e) {
    e.Left = "left", e.Top = "top", e.Right = "right", e.Bottom = "bottom";
  })(Ve || (Ve = {}));
  const B$ = {
    [Ve.Left]: Ve.Right,
    [Ve.Right]: Ve.Left,
    [Ve.Top]: Ve.Bottom,
    [Ve.Bottom]: Ve.Top
  };
  function bB(e) {
    return e === null ? null : e ? "valid" : "invalid";
  }
  const xB = (e) => "id" in e && "source" in e && "target" in e, fge = (e) => "id" in e && "position" in e && !("source" in e) && !("target" in e), OT = (e) => "id" in e && "internals" in e && !("source" in e) && !("target" in e), em = (e, t = [0, 0]) => {
    const { width: n, height: r } = ns(e), o = e.origin ?? t, i = n * o[0], a = r * o[1];
    return {
      x: e.position.x - i,
      y: e.position.y - a
    };
  }, dge = (e, t = { nodeOrigin: [0, 0] }) => {
    if (e.length === 0)
      return { x: 0, y: 0, width: 0, height: 0 };
    const n = e.reduce((r, o) => {
      const i = typeof o == "string";
      let a = !t.nodeLookup && !i ? o : void 0;
      t.nodeLookup && (a = i ? t.nodeLookup.get(o) : OT(o) ? o : t.nodeLookup.get(o.id));
      const s = a ? R0(a, t.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };
      return Qb(r, s);
    }, { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 });
    return Jb(n);
  }, tm = (e, t = {}) => {
    let n = { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 }, r = !1;
    return e.forEach((o) => {
      (t.filter === void 0 || t.filter(o)) && (n = Qb(n, R0(o)), r = !0);
    }), r ? Jb(n) : { x: 0, y: 0, width: 0, height: 0 };
  }, MT = (e, t, [n, r, o] = [0, 0, 1], i = !1, a = !1) => {
    const s = {
      ...rm(t, [n, r, o]),
      width: t.width / o,
      height: t.height / o
    }, c = [];
    for (const u of e.values()) {
      const { measured: d, selectable: p = !0, hidden: m = !1 } = u;
      if (a && !p || m)
        continue;
      const g = d.width ?? u.width ?? u.initialWidth ?? null, y = d.height ?? u.height ?? u.initialHeight ?? null, b = ch(s, Sf(u)), v = (g ?? 0) * (y ?? 0), x = i && b > 0;
      (!u.internals.handleBounds || x || b >= v || u.dragging) && c.push(u);
    }
    return c;
  }, pge = (e, t) => {
    const n = /* @__PURE__ */ new Set();
    return e.forEach((r) => {
      n.add(r.id);
    }), t.filter((r) => n.has(r.source) || n.has(r.target));
  };
  function hge(e, t) {
    const n = /* @__PURE__ */ new Map(), r = t?.nodes ? new Set(t.nodes.map((o) => o.id)) : null;
    return e.forEach((o) => {
      o.measured.width && o.measured.height && (t?.includeHiddenNodes || !o.hidden) && (!r || r.has(o.id)) && n.set(o.id, o);
    }), n;
  }
  async function mge({ nodes: e, width: t, height: n, panZoom: r, minZoom: o, maxZoom: i }, a) {
    if (e.size === 0)
      return Promise.resolve(!0);
    const s = hge(e, a), c = tm(s), u = NT(c, t, n, a?.minZoom ?? o, a?.maxZoom ?? i, a?.padding ?? 0.1);
    return await r.setViewport(u, {
      duration: a?.duration,
      ease: a?.ease,
      interpolate: a?.interpolate
    }), Promise.resolve(!0);
  }
  function wB({ nodeId: e, nextPosition: t, nodeLookup: n, nodeOrigin: r = [0, 0], nodeExtent: o, onError: i }) {
    const a = n.get(e), s = a.parentId ? n.get(a.parentId) : void 0, { x: c, y: u } = s ? s.internals.positionAbsolute : { x: 0, y: 0 }, d = a.origin ?? r;
    let p = a.extent || o;
    if (a.extent === "parent" && !a.expandParent)
      if (!s)
        i?.("005", Gi.error005());
      else {
        const g = s.measured.width, y = s.measured.height;
        g && y && (p = [
          [c, u],
          [c + g, u + y]
        ]);
      }
    else s && _f(a.extent) && (p = [
      [a.extent[0][0] + c, a.extent[0][1] + u],
      [a.extent[1][0] + c, a.extent[1][1] + u]
    ]);
    const m = _f(p) ? gc(t, p, a.measured) : t;
    return (a.measured.width === void 0 || a.measured.height === void 0) && i?.("015", Gi.error015()), {
      position: {
        x: m.x - c + (a.measured.width ?? 0) * d[0],
        y: m.y - u + (a.measured.height ?? 0) * d[1]
      },
      positionAbsolute: m
    };
  }
  async function gge({ nodesToRemove: e = [], edgesToRemove: t = [], nodes: n, edges: r, onBeforeDelete: o }) {
    const i = new Set(e.map((m) => m.id)), a = [];
    for (const m of n) {
      if (m.deletable === !1)
        continue;
      const g = i.has(m.id), y = !g && m.parentId && a.find((b) => b.id === m.parentId);
      (g || y) && a.push(m);
    }
    const s = new Set(t.map((m) => m.id)), c = r.filter((m) => m.deletable !== !1), d = pge(a, c);
    for (const m of c)
      s.has(m.id) && !d.find((y) => y.id === m.id) && d.push(m);
    if (!o)
      return {
        edges: d,
        nodes: a
      };
    const p = await o({
      nodes: a,
      edges: d
    });
    return typeof p == "boolean" ? p ? { edges: d, nodes: a } : { edges: [], nodes: [] } : p;
  }
  const wf = (e, t = 0, n = 1) => Math.min(Math.max(e, t), n), gc = (e = { x: 0, y: 0 }, t, n) => ({
    x: wf(e.x, t[0][0], t[1][0] - (n?.width ?? 0)),
    y: wf(e.y, t[0][1], t[1][1] - (n?.height ?? 0))
  });
  function SB(e, t, n) {
    const { width: r, height: o } = ns(n), { x: i, y: a } = n.internals.positionAbsolute;
    return gc(e, [
      [i, a],
      [i + r, a + o]
    ], t);
  }
  const U$ = (e, t, n) => e < t ? wf(Math.abs(e - t), 1, t) / t : e > n ? -wf(Math.abs(e - n), 1, t) / t : 0, _B = (e, t, n = 15, r = 40) => {
    const o = U$(e.x, r, t.width - r) * n, i = U$(e.y, r, t.height - r) * n;
    return [o, i];
  }, Qb = (e, t) => ({
    x: Math.min(e.x, t.x),
    y: Math.min(e.y, t.y),
    x2: Math.max(e.x2, t.x2),
    y2: Math.max(e.y2, t.y2)
  }), dC = ({ x: e, y: t, width: n, height: r }) => ({
    x: e,
    y: t,
    x2: e + n,
    y2: t + r
  }), Jb = ({ x: e, y: t, x2: n, y2: r }) => ({
    x: e,
    y: t,
    width: n - e,
    height: r - t
  }), Sf = (e, t = [0, 0]) => {
    const { x: n, y: r } = OT(e) ? e.internals.positionAbsolute : em(e, t);
    return {
      x: n,
      y: r,
      width: e.measured?.width ?? e.width ?? e.initialWidth ?? 0,
      height: e.measured?.height ?? e.height ?? e.initialHeight ?? 0
    };
  }, R0 = (e, t = [0, 0]) => {
    const { x: n, y: r } = OT(e) ? e.internals.positionAbsolute : em(e, t);
    return {
      x: n,
      y: r,
      x2: n + (e.measured?.width ?? e.width ?? e.initialWidth ?? 0),
      y2: r + (e.measured?.height ?? e.height ?? e.initialHeight ?? 0)
    };
  }, EB = (e, t) => Jb(Qb(dC(e), dC(t))), ch = (e, t) => {
    const n = Math.max(0, Math.min(e.x + e.width, t.x + t.width) - Math.max(e.x, t.x)), r = Math.max(0, Math.min(e.y + e.height, t.y + t.height) - Math.max(e.y, t.y));
    return Math.ceil(n * r);
  }, V$ = (e) => Xo(e.width) && Xo(e.height) && Xo(e.x) && Xo(e.y), Xo = (e) => !isNaN(e) && isFinite(e), yge = (e, t) => {
  }, nm = (e, t = [1, 1]) => ({
    x: t[0] * Math.round(e.x / t[0]),
    y: t[1] * Math.round(e.y / t[1])
  }), rm = ({ x: e, y: t }, [n, r, o], i = !1, a = [1, 1]) => {
    const s = {
      x: (e - n) / o,
      y: (t - r) / o
    };
    return i ? nm(s, a) : s;
  }, O0 = ({ x: e, y: t }, [n, r, o]) => ({
    x: e * o + n,
    y: t * o + r
  });
  function Nu(e, t) {
    if (typeof e == "number")
      return Math.floor((t - t / (1 + e)) * 0.5);
    if (typeof e == "string" && e.endsWith("px")) {
      const n = parseFloat(e);
      if (!Number.isNaN(n))
        return Math.floor(n);
    }
    if (typeof e == "string" && e.endsWith("%")) {
      const n = parseFloat(e);
      if (!Number.isNaN(n))
        return Math.floor(t * n * 0.01);
    }
    return console.error(`[React Flow] The padding value "${e}" is invalid. Please provide a number or a string with a valid unit (px or %).`), 0;
  }
  function vge(e, t, n) {
    if (typeof e == "string" || typeof e == "number") {
      const r = Nu(e, n), o = Nu(e, t);
      return {
        top: r,
        right: o,
        bottom: r,
        left: o,
        x: o * 2,
        y: r * 2
      };
    }
    if (typeof e == "object") {
      const r = Nu(e.top ?? e.y ?? 0, n), o = Nu(e.bottom ?? e.y ?? 0, n), i = Nu(e.left ?? e.x ?? 0, t), a = Nu(e.right ?? e.x ?? 0, t);
      return { top: r, right: a, bottom: o, left: i, x: i + a, y: r + o };
    }
    return { top: 0, right: 0, bottom: 0, left: 0, x: 0, y: 0 };
  }
  function bge(e, t, n, r, o, i) {
    const { x: a, y: s } = O0(e, [t, n, r]), { x: c, y: u } = O0({ x: e.x + e.width, y: e.y + e.height }, [t, n, r]), d = o - c, p = i - u;
    return {
      left: Math.floor(a),
      top: Math.floor(s),
      right: Math.floor(d),
      bottom: Math.floor(p)
    };
  }
  const NT = (e, t, n, r, o, i) => {
    const a = vge(i, t, n), s = (t - a.x) / e.width, c = (n - a.y) / e.height, u = Math.min(s, c), d = wf(u, r, o), p = e.x + e.width / 2, m = e.y + e.height / 2, g = t / 2 - p * d, y = n / 2 - m * d, b = bge(e, g, y, d, t, n), v = {
      left: Math.min(b.left - a.left, 0),
      top: Math.min(b.top - a.top, 0),
      right: Math.min(b.right - a.right, 0),
      bottom: Math.min(b.bottom - a.bottom, 0)
    };
    return {
      x: g - v.left + v.right,
      y: y - v.top + v.bottom,
      zoom: d
    };
  }, uh = () => typeof navigator < "u" && navigator?.userAgent?.indexOf("Mac") >= 0;
  function _f(e) {
    return e != null && e !== "parent";
  }
  function ns(e) {
    return {
      width: e.measured?.width ?? e.width ?? e.initialWidth ?? 0,
      height: e.measured?.height ?? e.height ?? e.initialHeight ?? 0
    };
  }
  function CB(e) {
    return (e.measured?.width ?? e.width ?? e.initialWidth) !== void 0 && (e.measured?.height ?? e.height ?? e.initialHeight) !== void 0;
  }
  function kB(e, t = { width: 0, height: 0 }, n, r, o) {
    const i = { ...e }, a = r.get(n);
    if (a) {
      const s = a.origin || o;
      i.x += a.internals.positionAbsolute.x - (t.width ?? 0) * s[0], i.y += a.internals.positionAbsolute.y - (t.height ?? 0) * s[1];
    }
    return i;
  }
  function H$(e, t) {
    if (e.size !== t.size)
      return !1;
    for (const n of e)
      if (!t.has(n))
        return !1;
    return !0;
  }
  function xge() {
    let e, t;
    return { promise: new Promise((r, o) => {
      e = r, t = o;
    }), resolve: e, reject: t };
  }
  function wge(e) {
    return { ...yB, ...e || {} };
  }
  function Pp(e, { snapGrid: t = [0, 0], snapToGrid: n = !1, transform: r, containerBounds: o }) {
    const { x: i, y: a } = Zo(e), s = rm({ x: i - (o?.left ?? 0), y: a - (o?.top ?? 0) }, r), { x: c, y: u } = n ? nm(s, t) : s;
    return {
      xSnapped: c,
      ySnapped: u,
      ...s
    };
  }
  const PT = (e) => ({
    width: e.offsetWidth,
    height: e.offsetHeight
  }), TB = (e) => e?.getRootNode?.() || window?.document, Sge = ["INPUT", "SELECT", "TEXTAREA"];
  function AB(e) {
    const t = e.composedPath?.()?.[0] || e.target;
    return t?.nodeType !== 1 ? !1 : Sge.includes(t.nodeName) || t.hasAttribute("contenteditable") || !!t.closest(".nokey");
  }
  const RB = (e) => "clientX" in e, Zo = (e, t) => {
    const n = RB(e), r = n ? e.clientX : e.touches?.[0].clientX, o = n ? e.clientY : e.touches?.[0].clientY;
    return {
      x: r - (t?.left ?? 0),
      y: o - (t?.top ?? 0)
    };
  }, q$ = (e, t, n, r, o) => {
    const i = t.querySelectorAll(`.${e}`);
    return !i || !i.length ? null : Array.from(i).map((a) => {
      const s = a.getBoundingClientRect();
      return {
        id: a.getAttribute("data-handleid"),
        type: e,
        nodeId: o,
        position: a.getAttribute("data-handlepos"),
        x: (s.left - n.left) / r,
        y: (s.top - n.top) / r,
        ...PT(a)
      };
    });
  };
  function OB({ sourceX: e, sourceY: t, targetX: n, targetY: r, sourceControlX: o, sourceControlY: i, targetControlX: a, targetControlY: s }) {
    const c = e * 0.125 + o * 0.375 + a * 0.375 + n * 0.125, u = t * 0.125 + i * 0.375 + s * 0.375 + r * 0.125, d = Math.abs(c - e), p = Math.abs(u - t);
    return [c, u, d, p];
  }
  function by(e, t) {
    return e >= 0 ? 0.5 * e : t * 25 * Math.sqrt(-e);
  }
  function W$({ pos: e, x1: t, y1: n, x2: r, y2: o, c: i }) {
    switch (e) {
      case Ve.Left:
        return [t - by(t - r, i), n];
      case Ve.Right:
        return [t + by(r - t, i), n];
      case Ve.Top:
        return [t, n - by(n - o, i)];
      case Ve.Bottom:
        return [t, n + by(o - n, i)];
    }
  }
  function IT({ sourceX: e, sourceY: t, sourcePosition: n = Ve.Bottom, targetX: r, targetY: o, targetPosition: i = Ve.Top, curvature: a = 0.25 }) {
    const [s, c] = W$({
      pos: n,
      x1: e,
      y1: t,
      x2: r,
      y2: o,
      c: a
    }), [u, d] = W$({
      pos: i,
      x1: r,
      y1: o,
      x2: e,
      y2: t,
      c: a
    }), [p, m, g, y] = OB({
      sourceX: e,
      sourceY: t,
      targetX: r,
      targetY: o,
      sourceControlX: s,
      sourceControlY: c,
      targetControlX: u,
      targetControlY: d
    });
    return [
      `M${e},${t} C${s},${c} ${u},${d} ${r},${o}`,
      p,
      m,
      g,
      y
    ];
  }
  function MB({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
    const o = Math.abs(n - e) / 2, i = n < e ? n + o : n - o, a = Math.abs(r - t) / 2, s = r < t ? r + a : r - a;
    return [i, s, o, a];
  }
  function _ge({ sourceNode: e, targetNode: t, selected: n = !1, zIndex: r = 0, elevateOnSelect: o = !1, zIndexMode: i = "basic" }) {
    if (i === "manual")
      return r;
    const a = o && n ? r + 1e3 : r, s = Math.max(e.parentId || o && e.selected ? e.internals.z : 0, t.parentId || o && t.selected ? t.internals.z : 0);
    return a + s;
  }
  function Ege({ sourceNode: e, targetNode: t, width: n, height: r, transform: o }) {
    const i = Qb(R0(e), R0(t));
    i.x === i.x2 && (i.x2 += 1), i.y === i.y2 && (i.y2 += 1);
    const a = {
      x: -o[0] / o[2],
      y: -o[1] / o[2],
      width: n / o[2],
      height: r / o[2]
    };
    return ch(a, Jb(i)) > 0;
  }
  const Cge = ({ source: e, sourceHandle: t, target: n, targetHandle: r }) => `xy-edge__${e}${t || ""}-${n}${r || ""}`, kge = (e, t) => t.some((n) => n.source === e.source && n.target === e.target && (n.sourceHandle === e.sourceHandle || !n.sourceHandle && !e.sourceHandle) && (n.targetHandle === e.targetHandle || !n.targetHandle && !e.targetHandle)), Tge = (e, t, n = {}) => {
    if (!e.source || !e.target)
      return t;
    const r = n.getEdgeId || Cge;
    let o;
    return xB(e) ? o = { ...e } : o = {
      ...e,
      id: r(e)
    }, kge(o, t) ? t : (o.sourceHandle === null && delete o.sourceHandle, o.targetHandle === null && delete o.targetHandle, t.concat(o));
  };
  function NB({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
    const [o, i, a, s] = MB({
      sourceX: e,
      sourceY: t,
      targetX: n,
      targetY: r
    });
    return [`M ${e},${t}L ${n},${r}`, o, i, a, s];
  }
  const G$ = {
    [Ve.Left]: { x: -1, y: 0 },
    [Ve.Right]: { x: 1, y: 0 },
    [Ve.Top]: { x: 0, y: -1 },
    [Ve.Bottom]: { x: 0, y: 1 }
  }, Age = ({ source: e, sourcePosition: t = Ve.Bottom, target: n }) => t === Ve.Left || t === Ve.Right ? e.x < n.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : e.y < n.y ? { x: 0, y: 1 } : { x: 0, y: -1 }, K$ = (e, t) => Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
  function Rge({ source: e, sourcePosition: t = Ve.Bottom, target: n, targetPosition: r = Ve.Top, center: o, offset: i, stepPosition: a }) {
    const s = G$[t], c = G$[r], u = { x: e.x + s.x * i, y: e.y + s.y * i }, d = { x: n.x + c.x * i, y: n.y + c.y * i }, p = Age({
      source: u,
      sourcePosition: t,
      target: d
    }), m = p.x !== 0 ? "x" : "y", g = p[m];
    let y = [], b, v;
    const x = { x: 0, y: 0 }, E = { x: 0, y: 0 }, [, , _, C] = MB({
      sourceX: e.x,
      sourceY: e.y,
      targetX: n.x,
      targetY: n.y
    });
    if (s[m] * c[m] === -1) {
      m === "x" ? (b = o.x ?? u.x + (d.x - u.x) * a, v = o.y ?? (u.y + d.y) / 2) : (b = o.x ?? (u.x + d.x) / 2, v = o.y ?? u.y + (d.y - u.y) * a);
      const A = [
        { x: b, y: u.y },
        { x: b, y: d.y }
      ], O = [
        { x: u.x, y: v },
        { x: d.x, y: v }
      ];
      s[m] === g ? y = m === "x" ? A : O : y = m === "x" ? O : A;
    } else {
      const A = [{ x: u.x, y: d.y }], O = [{ x: d.x, y: u.y }];
      if (m === "x" ? y = s.x === g ? O : A : y = s.y === g ? A : O, t === r) {
        const N = Math.abs(e[m] - n[m]);
        if (N <= i) {
          const U = Math.min(i - 1, i - N);
          s[m] === g ? x[m] = (u[m] > e[m] ? -1 : 1) * U : E[m] = (d[m] > n[m] ? -1 : 1) * U;
        }
      }
      if (t !== r) {
        const N = m === "x" ? "y" : "x", U = s[m] === c[N], j = u[N] > d[N], V = u[N] < d[N];
        (s[m] === 1 && (!U && j || U && V) || s[m] !== 1 && (!U && V || U && j)) && (y = m === "x" ? A : O);
      }
      const P = { x: u.x + x.x, y: u.y + x.y }, I = { x: d.x + E.x, y: d.y + E.y }, $ = Math.max(Math.abs(P.x - y[0].x), Math.abs(I.x - y[0].x)), L = Math.max(Math.abs(P.y - y[0].y), Math.abs(I.y - y[0].y));
      $ >= L ? (b = (P.x + I.x) / 2, v = y[0].y) : (b = y[0].x, v = (P.y + I.y) / 2);
    }
    return [[
      e,
      { x: u.x + x.x, y: u.y + x.y },
      ...y,
      { x: d.x + E.x, y: d.y + E.y },
      n
    ], b, v, _, C];
  }
  function Oge(e, t, n, r) {
    const o = Math.min(K$(e, t) / 2, K$(t, n) / 2, r), { x: i, y: a } = t;
    if (e.x === i && i === n.x || e.y === a && a === n.y)
      return `L${i} ${a}`;
    if (e.y === a) {
      const u = e.x < n.x ? -1 : 1, d = e.y < n.y ? 1 : -1;
      return `L ${i + o * u},${a}Q ${i},${a} ${i},${a + o * d}`;
    }
    const s = e.x < n.x ? 1 : -1, c = e.y < n.y ? -1 : 1;
    return `L ${i},${a + o * c}Q ${i},${a} ${i + o * s},${a}`;
  }
  function pC({ sourceX: e, sourceY: t, sourcePosition: n = Ve.Bottom, targetX: r, targetY: o, targetPosition: i = Ve.Top, borderRadius: a = 5, centerX: s, centerY: c, offset: u = 20, stepPosition: d = 0.5 }) {
    const [p, m, g, y, b] = Rge({
      source: { x: e, y: t },
      sourcePosition: n,
      target: { x: r, y: o },
      targetPosition: i,
      center: { x: s, y: c },
      offset: u,
      stepPosition: d
    });
    return [p.reduce((x, E, _) => {
      let C = "";
      return _ > 0 && _ < p.length - 1 ? C = Oge(p[_ - 1], E, p[_ + 1], a) : C = `${_ === 0 ? "M" : "L"}${E.x} ${E.y}`, x += C, x;
    }, ""), m, g, y, b];
  }
  function Y$(e) {
    return e && !!(e.internals.handleBounds || e.handles?.length) && !!(e.measured.width || e.width || e.initialWidth);
  }
  function Mge(e) {
    const { sourceNode: t, targetNode: n } = e;
    if (!Y$(t) || !Y$(n))
      return null;
    const r = t.internals.handleBounds || X$(t.handles), o = n.internals.handleBounds || X$(n.handles), i = Z$(r?.source ?? [], e.sourceHandle), a = Z$(
      // when connection type is loose we can define all handles as sources and connect source -> source
      e.connectionMode === xf.Strict ? o?.target ?? [] : (o?.target ?? []).concat(o?.source ?? []),
      e.targetHandle
    );
    if (!i || !a)
      return e.onError?.("008", Gi.error008(i ? "target" : "source", {
        id: e.id,
        sourceHandle: e.sourceHandle,
        targetHandle: e.targetHandle
      })), null;
    const s = i?.position || Ve.Bottom, c = a?.position || Ve.Top, u = yc(t, i, s), d = yc(n, a, c);
    return {
      sourceX: u.x,
      sourceY: u.y,
      targetX: d.x,
      targetY: d.y,
      sourcePosition: s,
      targetPosition: c
    };
  }
  function X$(e) {
    if (!e)
      return null;
    const t = [], n = [];
    for (const r of e)
      r.width = r.width ?? 1, r.height = r.height ?? 1, r.type === "source" ? t.push(r) : r.type === "target" && n.push(r);
    return {
      source: t,
      target: n
    };
  }
  function yc(e, t, n = Ve.Left, r = !1) {
    const o = (t?.x ?? 0) + e.internals.positionAbsolute.x, i = (t?.y ?? 0) + e.internals.positionAbsolute.y, { width: a, height: s } = t ?? ns(e);
    if (r)
      return { x: o + a / 2, y: i + s / 2 };
    switch (t?.position ?? n) {
      case Ve.Top:
        return { x: o + a / 2, y: i };
      case Ve.Right:
        return { x: o + a, y: i + s / 2 };
      case Ve.Bottom:
        return { x: o + a / 2, y: i + s };
      case Ve.Left:
        return { x: o, y: i + s / 2 };
    }
  }
  function Z$(e, t) {
    return e && (t ? e.find((n) => n.id === t) : e[0]) || null;
  }
  function hC(e, t) {
    return e ? typeof e == "string" ? e : `${t ? `${t}__` : ""}${Object.keys(e).sort().map((r) => `${r}=${e[r]}`).join("&")}` : "";
  }
  function Nge(e, { id: t, defaultColor: n, defaultMarkerStart: r, defaultMarkerEnd: o }) {
    const i = /* @__PURE__ */ new Set();
    return e.reduce((a, s) => ([s.markerStart || r, s.markerEnd || o].forEach((c) => {
      if (c && typeof c == "object") {
        const u = hC(c, t);
        i.has(u) || (a.push({ id: u, color: c.color || n, ...c }), i.add(u));
      }
    }), a), []).sort((a, s) => a.id.localeCompare(s.id));
  }
  const PB = 1e3, Pge = 10, $T = {
    nodeOrigin: [0, 0],
    nodeExtent: sh,
    elevateNodesOnSelect: !0,
    zIndexMode: "basic",
    defaults: {}
  }, Ige = {
    ...$T,
    checkEquality: !0
  };
  function jT(e, t) {
    const n = { ...e };
    for (const r in t)
      t[r] !== void 0 && (n[r] = t[r]);
    return n;
  }
  function $ge(e, t, n) {
    const r = jT($T, n);
    for (const o of e.values())
      if (o.parentId)
        FT(o, e, t, r);
      else {
        const i = em(o, r.nodeOrigin), a = _f(o.extent) ? o.extent : r.nodeExtent, s = gc(i, a, ns(o));
        o.internals.positionAbsolute = s;
      }
  }
  function jge(e, t) {
    if (!e.handles)
      return e.measured ? t?.internals.handleBounds : void 0;
    const n = [], r = [];
    for (const o of e.handles) {
      const i = {
        id: o.id,
        width: o.width ?? 1,
        height: o.height ?? 1,
        nodeId: e.id,
        x: o.x,
        y: o.y,
        position: o.position,
        type: o.type
      };
      o.type === "source" ? n.push(i) : o.type === "target" && r.push(i);
    }
    return {
      source: n,
      target: r
    };
  }
  function DT(e) {
    return e === "manual";
  }
  function mC(e, t, n, r = {}) {
    const o = jT(Ige, r), i = { i: 0 }, a = new Map(t), s = o?.elevateNodesOnSelect && !DT(o.zIndexMode) ? PB : 0;
    let c = e.length > 0;
    t.clear(), n.clear();
    for (const u of e) {
      let d = a.get(u.id);
      if (o.checkEquality && u === d?.internals.userNode)
        t.set(u.id, d);
      else {
        const p = em(u, o.nodeOrigin), m = _f(u.extent) ? u.extent : o.nodeExtent, g = gc(p, m, ns(u));
        d = {
          ...o.defaults,
          ...u,
          measured: {
            width: u.measured?.width,
            height: u.measured?.height
          },
          internals: {
            positionAbsolute: g,
            // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured
            handleBounds: jge(u, d),
            z: IB(u, s, o.zIndexMode),
            userNode: u
          }
        }, t.set(u.id, d);
      }
      (d.measured === void 0 || d.measured.width === void 0 || d.measured.height === void 0) && !d.hidden && (c = !1), u.parentId && FT(d, t, n, r, i);
    }
    return c;
  }
  function Dge(e, t) {
    if (!e.parentId)
      return;
    const n = t.get(e.parentId);
    n ? n.set(e.id, e) : t.set(e.parentId, /* @__PURE__ */ new Map([[e.id, e]]));
  }
  function FT(e, t, n, r, o) {
    const { elevateNodesOnSelect: i, nodeOrigin: a, nodeExtent: s, zIndexMode: c } = jT($T, r), u = e.parentId, d = t.get(u);
    if (!d) {
      console.warn(`Parent node ${u} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);
      return;
    }
    Dge(e, n), o && !d.parentId && d.internals.rootParentIndex === void 0 && c === "auto" && (d.internals.rootParentIndex = ++o.i, d.internals.z = d.internals.z + o.i * Pge), o && d.internals.rootParentIndex !== void 0 && (o.i = d.internals.rootParentIndex);
    const p = i && !DT(c) ? PB : 0, { x: m, y: g, z: y } = Fge(e, d, a, s, p, c), { positionAbsolute: b } = e.internals, v = m !== b.x || g !== b.y;
    (v || y !== e.internals.z) && t.set(e.id, {
      ...e,
      internals: {
        ...e.internals,
        positionAbsolute: v ? { x: m, y: g } : b,
        z: y
      }
    });
  }
  function IB(e, t, n) {
    const r = Xo(e.zIndex) ? e.zIndex : 0;
    return DT(n) ? r : r + (e.selected ? t : 0);
  }
  function Fge(e, t, n, r, o, i) {
    const { x: a, y: s } = t.internals.positionAbsolute, c = ns(e), u = em(e, n), d = _f(e.extent) ? gc(u, e.extent, c) : u;
    let p = gc({ x: a + d.x, y: s + d.y }, r, c);
    e.extent === "parent" && (p = SB(p, c, t));
    const m = IB(e, o, i), g = t.internals.z ?? 0;
    return {
      x: p.x,
      y: p.y,
      z: g >= m ? g + 1 : m
    };
  }
  function LT(e, t, n, r = [0, 0]) {
    const o = [], i = /* @__PURE__ */ new Map();
    for (const a of e) {
      const s = t.get(a.parentId);
      if (!s)
        continue;
      const c = i.get(a.parentId)?.expandedRect ?? Sf(s), u = EB(c, a.rect);
      i.set(a.parentId, { expandedRect: u, parent: s });
    }
    return i.size > 0 && i.forEach(({ expandedRect: a, parent: s }, c) => {
      const u = s.internals.positionAbsolute, d = ns(s), p = s.origin ?? r, m = a.x < u.x ? Math.round(Math.abs(u.x - a.x)) : 0, g = a.y < u.y ? Math.round(Math.abs(u.y - a.y)) : 0, y = Math.max(d.width, Math.round(a.width)), b = Math.max(d.height, Math.round(a.height)), v = (y - d.width) * p[0], x = (b - d.height) * p[1];
      (m > 0 || g > 0 || v || x) && (o.push({
        id: c,
        type: "position",
        position: {
          x: s.position.x - m + v,
          y: s.position.y - g + x
        }
      }), n.get(c)?.forEach((E) => {
        e.some((_) => _.id === E.id) || o.push({
          id: E.id,
          type: "position",
          position: {
            x: E.position.x + m,
            y: E.position.y + g
          }
        });
      })), (d.width < a.width || d.height < a.height || m || g) && o.push({
        id: c,
        type: "dimensions",
        setAttributes: !0,
        dimensions: {
          width: y + (m ? p[0] * m - v : 0),
          height: b + (g ? p[1] * g - x : 0)
        }
      });
    }), o;
  }
  function Lge(e, t, n, r, o, i, a) {
    const s = r?.querySelector(".xyflow__viewport");
    let c = !1;
    if (!s)
      return { changes: [], updatedInternals: c };
    const u = [], d = window.getComputedStyle(s), { m22: p } = new window.DOMMatrixReadOnly(d.transform), m = [];
    for (const g of e.values()) {
      const y = t.get(g.id);
      if (!y)
        continue;
      if (y.hidden) {
        t.set(y.id, {
          ...y,
          internals: {
            ...y.internals,
            handleBounds: void 0
          }
        }), c = !0;
        continue;
      }
      const b = PT(g.nodeElement), v = y.measured.width !== b.width || y.measured.height !== b.height;
      if (!!(b.width && b.height && (v || !y.internals.handleBounds || g.force))) {
        const E = g.nodeElement.getBoundingClientRect(), _ = _f(y.extent) ? y.extent : i;
        let { positionAbsolute: C } = y.internals;
        y.parentId && y.extent === "parent" ? C = SB(C, b, t.get(y.parentId)) : _ && (C = gc(C, _, b));
        const k = {
          ...y,
          measured: b,
          internals: {
            ...y.internals,
            positionAbsolute: C,
            handleBounds: {
              source: q$("source", g.nodeElement, E, p, y.id),
              target: q$("target", g.nodeElement, E, p, y.id)
            }
          }
        };
        t.set(y.id, k), y.parentId && FT(k, t, n, { nodeOrigin: o, zIndexMode: a }), c = !0, v && (u.push({
          id: y.id,
          type: "dimensions",
          dimensions: b
        }), y.expandParent && y.parentId && m.push({
          id: y.id,
          parentId: y.parentId,
          rect: Sf(k, o)
        }));
      }
    }
    if (m.length > 0) {
      const g = LT(m, t, n, o);
      u.push(...g);
    }
    return { changes: u, updatedInternals: c };
  }
  async function zge({ delta: e, panZoom: t, transform: n, translateExtent: r, width: o, height: i }) {
    if (!t || !e.x && !e.y)
      return Promise.resolve(!1);
    const a = await t.setViewportConstrained({
      x: n[0] + e.x,
      y: n[1] + e.y,
      zoom: n[2]
    }, [
      [0, 0],
      [o, i]
    ], r), s = !!a && (a.x !== n[0] || a.y !== n[1] || a.k !== n[2]);
    return Promise.resolve(s);
  }
  function Q$(e, t, n, r, o, i) {
    let a = o;
    const s = r.get(a) || /* @__PURE__ */ new Map();
    r.set(a, s.set(n, t)), a = `${o}-${e}`;
    const c = r.get(a) || /* @__PURE__ */ new Map();
    if (r.set(a, c.set(n, t)), i) {
      a = `${o}-${e}-${i}`;
      const u = r.get(a) || /* @__PURE__ */ new Map();
      r.set(a, u.set(n, t));
    }
  }
  function $B(e, t, n) {
    e.clear(), t.clear();
    for (const r of n) {
      const { source: o, target: i, sourceHandle: a = null, targetHandle: s = null } = r, c = { edgeId: r.id, source: o, target: i, sourceHandle: a, targetHandle: s }, u = `${o}-${a}--${i}-${s}`, d = `${i}-${s}--${o}-${a}`;
      Q$("source", c, d, e, o, a), Q$("target", c, u, e, i, s), t.set(r.id, r);
    }
  }
  function jB(e, t) {
    if (!e.parentId)
      return !1;
    const n = t.get(e.parentId);
    return n ? n.selected ? !0 : jB(n, t) : !1;
  }
  function J$(e, t, n) {
    let r = e;
    do {
      if (r?.matches?.(t))
        return !0;
      if (r === n)
        return !1;
      r = r?.parentElement;
    } while (r);
    return !1;
  }
  function Bge(e, t, n, r) {
    const o = /* @__PURE__ */ new Map();
    for (const [i, a] of e)
      if ((a.selected || a.id === r) && (!a.parentId || !jB(a, e)) && (a.draggable || t && typeof a.draggable > "u")) {
        const s = e.get(i);
        s && o.set(i, {
          id: i,
          position: s.position || { x: 0, y: 0 },
          distance: {
            x: n.x - s.internals.positionAbsolute.x,
            y: n.y - s.internals.positionAbsolute.y
          },
          extent: s.extent,
          parentId: s.parentId,
          origin: s.origin,
          expandParent: s.expandParent,
          internals: {
            positionAbsolute: s.internals.positionAbsolute || { x: 0, y: 0 }
          },
          measured: {
            width: s.measured.width ?? 0,
            height: s.measured.height ?? 0
          }
        });
      }
    return o;
  }
  function r_({ nodeId: e, dragItems: t, nodeLookup: n, dragging: r = !0 }) {
    const o = [];
    for (const [a, s] of t) {
      const c = n.get(a)?.internals.userNode;
      c && o.push({
        ...c,
        position: s.position,
        dragging: r
      });
    }
    if (!e)
      return [o[0], o];
    const i = n.get(e)?.internals.userNode;
    return [
      i ? {
        ...i,
        position: t.get(e)?.position || i.position,
        dragging: r
      } : o[0],
      o
    ];
  }
  function Uge({ dragItems: e, snapGrid: t, x: n, y: r }) {
    const o = e.values().next().value;
    if (!o)
      return null;
    const i = {
      x: n - o.distance.x,
      y: r - o.distance.y
    }, a = nm(i, t);
    return {
      x: a.x - i.x,
      y: a.y - i.y
    };
  }
  function Vge({ onNodeMouseDown: e, getStoreItems: t, onDragStart: n, onDrag: r, onDragStop: o }) {
    let i = { x: null, y: null }, a = 0, s = /* @__PURE__ */ new Map(), c = !1, u = { x: 0, y: 0 }, d = null, p = !1, m = null, g = !1, y = !1, b = null;
    function v({ noDragClassName: E, handleSelector: _, domNode: C, isSelectable: k, nodeId: A, nodeClickDistance: O = 0 }) {
      m = io(C);
      function P({ x: N, y: U }) {
        const { nodeLookup: j, nodeExtent: V, snapGrid: F, snapToGrid: K, nodeOrigin: W, onNodeDrag: Y, onSelectionDrag: B, onError: D, updateNodePositions: G } = t();
        i = { x: N, y: U };
        let z = !1;
        const H = s.size > 1, X = H && V ? dC(tm(s)) : null, Q = H && K ? Uge({
          dragItems: s,
          snapGrid: F,
          x: N,
          y: U
        }) : null;
        for (const [ne, te] of s) {
          if (!j.has(ne))
            continue;
          let se = { x: N - te.distance.x, y: U - te.distance.y };
          K && (se = Q ? {
            x: Math.round(se.x + Q.x),
            y: Math.round(se.y + Q.y)
          } : nm(se, F));
          let ue = null;
          if (H && V && !te.extent && X) {
            const { positionAbsolute: ie } = te.internals, le = ie.x - X.x + V[0][0], ge = ie.x + te.measured.width - X.x2 + V[1][0], Se = ie.y - X.y + V[0][1], Me = ie.y + te.measured.height - X.y2 + V[1][1];
            ue = [
              [le, Se],
              [ge, Me]
            ];
          }
          const { position: J, positionAbsolute: ee } = wB({
            nodeId: ne,
            nextPosition: se,
            nodeLookup: j,
            nodeExtent: ue || V,
            nodeOrigin: W,
            onError: D
          });
          z = z || te.position.x !== J.x || te.position.y !== J.y, te.position = J, te.internals.positionAbsolute = ee;
        }
        if (y = y || z, !!z && (G(s, !0), b && (r || Y || !A && B))) {
          const [ne, te] = r_({
            nodeId: A,
            dragItems: s,
            nodeLookup: j
          });
          r?.(b, s, ne, te), Y?.(b, ne, te), A || B?.(b, te);
        }
      }
      async function I() {
        if (!d)
          return;
        const { transform: N, panBy: U, autoPanSpeed: j, autoPanOnNodeDrag: V } = t();
        if (!V) {
          c = !1, cancelAnimationFrame(a);
          return;
        }
        const [F, K] = _B(u, d, j);
        (F !== 0 || K !== 0) && (i.x = (i.x ?? 0) - F / N[2], i.y = (i.y ?? 0) - K / N[2], await U({ x: F, y: K }) && P(i)), a = requestAnimationFrame(I);
      }
      function $(N) {
        const { nodeLookup: U, multiSelectionActive: j, nodesDraggable: V, transform: F, snapGrid: K, snapToGrid: W, selectNodesOnDrag: Y, onNodeDragStart: B, onSelectionDragStart: D, unselectNodesAndEdges: G } = t();
        p = !0, (!Y || !k) && !j && A && (U.get(A)?.selected || G()), k && Y && A && e?.(A);
        const z = Pp(N.sourceEvent, { transform: F, snapGrid: K, snapToGrid: W, containerBounds: d });
        if (i = z, s = Bge(U, V, z, A), s.size > 0 && (n || B || !A && D)) {
          const [H, X] = r_({
            nodeId: A,
            dragItems: s,
            nodeLookup: U
          });
          n?.(N.sourceEvent, s, H, X), B?.(N.sourceEvent, H, X), A || D?.(N.sourceEvent, X);
        }
      }
      const L = eB().clickDistance(O).on("start", (N) => {
        const { domNode: U, nodeDragThreshold: j, transform: V, snapGrid: F, snapToGrid: K } = t();
        d = U?.getBoundingClientRect() || null, g = !1, y = !1, b = N.sourceEvent, j === 0 && $(N), i = Pp(N.sourceEvent, { transform: V, snapGrid: F, snapToGrid: K, containerBounds: d }), u = Zo(N.sourceEvent, d);
      }).on("drag", (N) => {
        const { autoPanOnNodeDrag: U, transform: j, snapGrid: V, snapToGrid: F, nodeDragThreshold: K, nodeLookup: W } = t(), Y = Pp(N.sourceEvent, { transform: j, snapGrid: V, snapToGrid: F, containerBounds: d });
        if (b = N.sourceEvent, (N.sourceEvent.type === "touchmove" && N.sourceEvent.touches.length > 1 || // if user deletes a node while dragging, we need to abort the drag to prevent errors
        A && !W.has(A)) && (g = !0), !g) {
          if (!c && U && p && (c = !0, I()), !p) {
            const B = Zo(N.sourceEvent, d), D = B.x - u.x, G = B.y - u.y;
            Math.sqrt(D * D + G * G) > K && $(N);
          }
          (i.x !== Y.xSnapped || i.y !== Y.ySnapped) && s && p && (u = Zo(N.sourceEvent, d), P(Y));
        }
      }).on("end", (N) => {
        if (!(!p || g) && (c = !1, p = !1, cancelAnimationFrame(a), s.size > 0)) {
          const { nodeLookup: U, updateNodePositions: j, onNodeDragStop: V, onSelectionDragStop: F } = t();
          if (y && (j(s, !1), y = !1), o || V || !A && F) {
            const [K, W] = r_({
              nodeId: A,
              dragItems: s,
              nodeLookup: U,
              dragging: !1
            });
            o?.(N.sourceEvent, s, K, W), V?.(N.sourceEvent, K, W), A || F?.(N.sourceEvent, W);
          }
        }
      }).filter((N) => {
        const U = N.target;
        return !N.button && (!E || !J$(U, `.${E}`, C)) && (!_ || J$(U, _, C));
      });
      m.call(L);
    }
    function x() {
      m?.on(".drag", null);
    }
    return {
      update: v,
      destroy: x
    };
  }
  function Hge(e, t, n) {
    const r = [], o = {
      x: e.x - n,
      y: e.y - n,
      width: n * 2,
      height: n * 2
    };
    for (const i of t.values())
      ch(o, Sf(i)) > 0 && r.push(i);
    return r;
  }
  const qge = 250;
  function Wge(e, t, n, r) {
    let o = [], i = 1 / 0;
    const a = Hge(e, n, t + qge);
    for (const s of a) {
      const c = [...s.internals.handleBounds?.source ?? [], ...s.internals.handleBounds?.target ?? []];
      for (const u of c) {
        if (r.nodeId === u.nodeId && r.type === u.type && r.id === u.id)
          continue;
        const { x: d, y: p } = yc(s, u, u.position, !0), m = Math.sqrt(Math.pow(d - e.x, 2) + Math.pow(p - e.y, 2));
        m > t || (m < i ? (o = [{ ...u, x: d, y: p }], i = m) : m === i && o.push({ ...u, x: d, y: p }));
      }
    }
    if (!o.length)
      return null;
    if (o.length > 1) {
      const s = r.type === "source" ? "target" : "source";
      return o.find((c) => c.type === s) ?? o[0];
    }
    return o[0];
  }
  function DB(e, t, n, r, o, i = !1) {
    const a = r.get(e);
    if (!a)
      return null;
    const s = o === "strict" ? a.internals.handleBounds?.[t] : [...a.internals.handleBounds?.source ?? [], ...a.internals.handleBounds?.target ?? []], c = (n ? s?.find((u) => u.id === n) : s?.[0]) ?? null;
    return c && i ? { ...c, ...yc(a, c, c.position, !0) } : c;
  }
  function FB(e, t) {
    return e || (t?.classList.contains("target") ? "target" : t?.classList.contains("source") ? "source" : null);
  }
  function Gge(e, t) {
    let n = null;
    return t ? n = !0 : e && !t && (n = !1), n;
  }
  const LB = () => !0;
  function Kge(e, { connectionMode: t, connectionRadius: n, handleId: r, nodeId: o, edgeUpdaterType: i, isTarget: a, domNode: s, nodeLookup: c, lib: u, autoPanOnConnect: d, flowId: p, panBy: m, cancelConnection: g, onConnectStart: y, onConnect: b, onConnectEnd: v, isValidConnection: x = LB, onReconnectEnd: E, updateConnection: _, getTransform: C, getFromHandle: k, autoPanSpeed: A, dragThreshold: O = 1, handleDomNode: P }) {
    const I = TB(e.target);
    let $ = 0, L;
    const { x: N, y: U } = Zo(e), j = FB(i, P), V = s?.getBoundingClientRect();
    let F = !1;
    if (!V || !j)
      return;
    const K = DB(o, j, r, c, t);
    if (!K)
      return;
    let W = Zo(e, V), Y = !1, B = null, D = !1, G = null;
    function z() {
      if (!d || !V)
        return;
      const [J, ee] = _B(W, V, A);
      m({ x: J, y: ee }), $ = requestAnimationFrame(z);
    }
    const H = {
      ...K,
      nodeId: o,
      type: j,
      position: K.position
    }, X = c.get(o);
    let ne = {
      inProgress: !0,
      isValid: null,
      from: yc(X, H, Ve.Left, !0),
      fromHandle: H,
      fromPosition: H.position,
      fromNode: X,
      to: W,
      toHandle: null,
      toPosition: B$[H.position],
      toNode: null,
      pointer: W
    };
    function te() {
      F = !0, _(ne), y?.(e, { nodeId: o, handleId: r, handleType: j });
    }
    O === 0 && te();
    function se(J) {
      if (!F) {
        const { x: Me, y: je } = Zo(J), ze = Me - N, Ye = je - U;
        if (!(ze * ze + Ye * Ye > O * O))
          return;
        te();
      }
      if (!k() || !H) {
        ue(J);
        return;
      }
      const ee = C();
      W = Zo(J, V), L = Wge(rm(W, ee, !1, [1, 1]), n, c, H), Y || (z(), Y = !0);
      const ie = zB(J, {
        handle: L,
        connectionMode: t,
        fromNodeId: o,
        fromHandleId: r,
        fromType: a ? "target" : "source",
        isValidConnection: x,
        doc: I,
        lib: u,
        flowId: p,
        nodeLookup: c
      });
      G = ie.handleDomNode, B = ie.connection, D = Gge(!!L, ie.isValid);
      const le = c.get(o), ge = le ? yc(le, H, Ve.Left, !0) : ne.from, Se = {
        ...ne,
        from: ge,
        isValid: D,
        to: ie.toHandle && D ? O0({ x: ie.toHandle.x, y: ie.toHandle.y }, ee) : W,
        toHandle: ie.toHandle,
        toPosition: D && ie.toHandle ? ie.toHandle.position : B$[H.position],
        toNode: ie.toHandle ? c.get(ie.toHandle.nodeId) : null,
        pointer: W
      };
      _(Se), ne = Se;
    }
    function ue(J) {
      if (!("touches" in J && J.touches.length > 0)) {
        if (F) {
          (L || G) && B && D && b?.(B);
          const { inProgress: ee, ...ie } = ne, le = {
            ...ie,
            toPosition: ne.toHandle ? ne.toPosition : null
          };
          v?.(J, le), i && E?.(J, le);
        }
        g(), cancelAnimationFrame($), Y = !1, D = !1, B = null, G = null, I.removeEventListener("mousemove", se), I.removeEventListener("mouseup", ue), I.removeEventListener("touchmove", se), I.removeEventListener("touchend", ue);
      }
    }
    I.addEventListener("mousemove", se), I.addEventListener("mouseup", ue), I.addEventListener("touchmove", se), I.addEventListener("touchend", ue);
  }
  function zB(e, { handle: t, connectionMode: n, fromNodeId: r, fromHandleId: o, fromType: i, doc: a, lib: s, flowId: c, isValidConnection: u = LB, nodeLookup: d }) {
    const p = i === "target", m = t ? a.querySelector(`.${s}-flow__handle[data-id="${c}-${t?.nodeId}-${t?.id}-${t?.type}"]`) : null, { x: g, y } = Zo(e), b = a.elementFromPoint(g, y), v = b?.classList.contains(`${s}-flow__handle`) ? b : m, x = {
      handleDomNode: v,
      isValid: !1,
      connection: null,
      toHandle: null
    };
    if (v) {
      const E = FB(void 0, v), _ = v.getAttribute("data-nodeid"), C = v.getAttribute("data-handleid"), k = v.classList.contains("connectable"), A = v.classList.contains("connectableend");
      if (!_ || !E)
        return x;
      const O = {
        source: p ? _ : r,
        sourceHandle: p ? C : o,
        target: p ? r : _,
        targetHandle: p ? o : C
      };
      x.connection = O;
      const I = k && A && (n === xf.Strict ? p && E === "source" || !p && E === "target" : _ !== r || C !== o);
      x.isValid = I && u(O), x.toHandle = DB(_, E, C, d, n, !0);
    }
    return x;
  }
  const gC = {
    onPointerDown: Kge,
    isValid: zB
  };
  function Yge({ domNode: e, panZoom: t, getTransform: n, getViewScale: r }) {
    const o = io(e);
    function i({ translateExtent: s, width: c, height: u, zoomStep: d = 1, pannable: p = !0, zoomable: m = !0, inversePan: g = !1 }) {
      const y = (_) => {
        if (_.sourceEvent.type !== "wheel" || !t)
          return;
        const C = n(), k = _.sourceEvent.ctrlKey && uh() ? 10 : 1, A = -_.sourceEvent.deltaY * (_.sourceEvent.deltaMode === 1 ? 0.05 : _.sourceEvent.deltaMode ? 1 : 2e-3) * d, O = C[2] * Math.pow(2, A * k);
        t.scaleTo(O);
      };
      let b = [0, 0];
      const v = (_) => {
        (_.sourceEvent.type === "mousedown" || _.sourceEvent.type === "touchstart") && (b = [
          _.sourceEvent.clientX ?? _.sourceEvent.touches[0].clientX,
          _.sourceEvent.clientY ?? _.sourceEvent.touches[0].clientY
        ]);
      }, x = (_) => {
        const C = n();
        if (_.sourceEvent.type !== "mousemove" && _.sourceEvent.type !== "touchmove" || !t)
          return;
        const k = [
          _.sourceEvent.clientX ?? _.sourceEvent.touches[0].clientX,
          _.sourceEvent.clientY ?? _.sourceEvent.touches[0].clientY
        ], A = [k[0] - b[0], k[1] - b[1]];
        b = k;
        const O = r() * Math.max(C[2], Math.log(C[2])) * (g ? -1 : 1), P = {
          x: C[0] - A[0] * O,
          y: C[1] - A[1] * O
        }, I = [
          [0, 0],
          [c, u]
        ];
        t.setViewportConstrained({
          x: P.x,
          y: P.y,
          zoom: C[2]
        }, I, s);
      }, E = mB().on("start", v).on("zoom", p ? x : null).on("zoom.wheel", m ? y : null);
      o.call(E, {});
    }
    function a() {
      o.on("zoom", null);
    }
    return {
      update: i,
      destroy: a,
      pointer: Wo
    };
  }
  const e1 = (e) => ({
    x: e.x,
    y: e.y,
    zoom: e.k
  }), o_ = ({ x: e, y: t, zoom: n }) => Zb.translate(e, t).scale(n), Gu = (e, t) => e.target.closest(`.${t}`), BB = (e, t) => t === 2 && Array.isArray(e) && e.includes(2), Xge = (e) => ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2, i_ = (e, t = 0, n = Xge, r = () => {
  }) => {
    const o = typeof t == "number" && t > 0;
    return o || r(), o ? e.transition().duration(t).ease(n).on("end", r) : e;
  }, UB = (e) => {
    const t = e.ctrlKey && uh() ? 10 : 1;
    return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * t;
  };
  function Zge({ zoomPanValues: e, noWheelClassName: t, d3Selection: n, d3Zoom: r, panOnScrollMode: o, panOnScrollSpeed: i, zoomOnPinch: a, onPanZoomStart: s, onPanZoom: c, onPanZoomEnd: u }) {
    return (d) => {
      if (Gu(d, t))
        return d.ctrlKey && d.preventDefault(), !1;
      d.preventDefault(), d.stopImmediatePropagation();
      const p = n.property("__zoom").k || 1;
      if (d.ctrlKey && a) {
        const v = Wo(d), x = UB(d), E = p * Math.pow(2, x);
        r.scaleTo(n, E, v, d);
        return;
      }
      const m = d.deltaMode === 1 ? 20 : 1;
      let g = o === ac.Vertical ? 0 : d.deltaX * m, y = o === ac.Horizontal ? 0 : d.deltaY * m;
      !uh() && d.shiftKey && o !== ac.Vertical && (g = d.deltaY * m, y = 0), r.translateBy(
        n,
        -(g / p) * i,
        -(y / p) * i,
        // @ts-ignore
        { internal: !0 }
      );
      const b = e1(n.property("__zoom"));
      clearTimeout(e.panScrollTimeout), e.isPanScrolling ? (c?.(d, b), e.panScrollTimeout = setTimeout(() => {
        u?.(d, b), e.isPanScrolling = !1;
      }, 150)) : (e.isPanScrolling = !0, s?.(d, b));
    };
  }
  function Qge({ noWheelClassName: e, preventScrolling: t, d3ZoomHandler: n }) {
    return function(r, o) {
      const i = r.type === "wheel", a = !t && i && !r.ctrlKey, s = Gu(r, e);
      if (r.ctrlKey && i && s && r.preventDefault(), a || s)
        return null;
      r.preventDefault(), n.call(this, r, o);
    };
  }
  function Jge({ zoomPanValues: e, onDraggingChange: t, onPanZoomStart: n }) {
    return (r) => {
      if (r.sourceEvent?.internal)
        return;
      const o = e1(r.transform);
      e.mouseButton = r.sourceEvent?.button || 0, e.isZoomingOrPanning = !0, e.prevViewport = o, r.sourceEvent?.type === "mousedown" && t(!0), n && n?.(r.sourceEvent, o);
    };
  }
  function eye({ zoomPanValues: e, panOnDrag: t, onPaneContextMenu: n, onTransformChange: r, onPanZoom: o }) {
    return (i) => {
      e.usedRightMouseButton = !!(n && BB(t, e.mouseButton ?? 0)), i.sourceEvent?.sync || r([i.transform.x, i.transform.y, i.transform.k]), o && !i.sourceEvent?.internal && o?.(i.sourceEvent, e1(i.transform));
    };
  }
  function tye({ zoomPanValues: e, panOnDrag: t, panOnScroll: n, onDraggingChange: r, onPanZoomEnd: o, onPaneContextMenu: i }) {
    return (a) => {
      if (!a.sourceEvent?.internal && (e.isZoomingOrPanning = !1, i && BB(t, e.mouseButton ?? 0) && !e.usedRightMouseButton && a.sourceEvent && i(a.sourceEvent), e.usedRightMouseButton = !1, r(!1), o)) {
        const s = e1(a.transform);
        e.prevViewport = s, clearTimeout(e.timerId), e.timerId = setTimeout(
          () => {
            o?.(a.sourceEvent, s);
          },
          // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
          n ? 150 : 0
        );
      }
    };
  }
  function nye({ zoomActivationKeyPressed: e, zoomOnScroll: t, zoomOnPinch: n, panOnDrag: r, panOnScroll: o, zoomOnDoubleClick: i, userSelectionActive: a, noWheelClassName: s, noPanClassName: c, lib: u, connectionInProgress: d }) {
    return (p) => {
      const m = e || t, g = n && p.ctrlKey, y = p.type === "wheel";
      if (p.button === 1 && p.type === "mousedown" && (Gu(p, `${u}-flow__node`) || Gu(p, `${u}-flow__edge`)))
        return !0;
      if (!r && !m && !o && !i && !n || a || d && !y || Gu(p, s) && y || Gu(p, c) && (!y || o && y && !e) || !n && p.ctrlKey && y)
        return !1;
      if (!n && p.type === "touchstart" && p.touches?.length > 1)
        return p.preventDefault(), !1;
      if (!m && !o && !g && y || !r && (p.type === "mousedown" || p.type === "touchstart") || Array.isArray(r) && !r.includes(p.button) && p.type === "mousedown")
        return !1;
      const b = Array.isArray(r) && r.includes(p.button) || !p.button || p.button <= 1;
      return (!p.ctrlKey || y) && b;
    };
  }
  function rye({ domNode: e, minZoom: t, maxZoom: n, translateExtent: r, viewport: o, onPanZoom: i, onPanZoomStart: a, onPanZoomEnd: s, onDraggingChange: c }) {
    const u = {
      isZoomingOrPanning: !1,
      usedRightMouseButton: !1,
      prevViewport: {},
      mouseButton: 0,
      timerId: void 0,
      panScrollTimeout: void 0,
      isPanScrolling: !1
    }, d = e.getBoundingClientRect(), p = mB().scaleExtent([t, n]).translateExtent(r), m = io(e).call(p);
    E({
      x: o.x,
      y: o.y,
      zoom: wf(o.zoom, t, n)
    }, [
      [0, 0],
      [d.width, d.height]
    ], r);
    const g = m.on("wheel.zoom"), y = m.on("dblclick.zoom");
    p.wheelDelta(UB);
    function b(L, N) {
      return m ? new Promise((U) => {
        p?.interpolate(N?.interpolate === "linear" ? Np : Lv).transform(i_(m, N?.duration, N?.ease, () => U(!0)), L);
      }) : Promise.resolve(!1);
    }
    function v({ noWheelClassName: L, noPanClassName: N, onPaneContextMenu: U, userSelectionActive: j, panOnScroll: V, panOnDrag: F, panOnScrollMode: K, panOnScrollSpeed: W, preventScrolling: Y, zoomOnPinch: B, zoomOnScroll: D, zoomOnDoubleClick: G, zoomActivationKeyPressed: z, lib: H, onTransformChange: X, connectionInProgress: Q, paneClickDistance: ne, selectionOnDrag: te }) {
      j && !u.isZoomingOrPanning && x();
      const se = V && !z && !j;
      p.clickDistance(te ? 1 / 0 : !Xo(ne) || ne < 0 ? 0 : ne);
      const ue = se ? Zge({
        zoomPanValues: u,
        noWheelClassName: L,
        d3Selection: m,
        d3Zoom: p,
        panOnScrollMode: K,
        panOnScrollSpeed: W,
        zoomOnPinch: B,
        onPanZoomStart: a,
        onPanZoom: i,
        onPanZoomEnd: s
      }) : Qge({
        noWheelClassName: L,
        preventScrolling: Y,
        d3ZoomHandler: g
      });
      if (m.on("wheel.zoom", ue, { passive: !1 }), !j) {
        const ee = Jge({
          zoomPanValues: u,
          onDraggingChange: c,
          onPanZoomStart: a
        });
        p.on("start", ee);
        const ie = eye({
          zoomPanValues: u,
          panOnDrag: F,
          onPaneContextMenu: !!U,
          onPanZoom: i,
          onTransformChange: X
        });
        p.on("zoom", ie);
        const le = tye({
          zoomPanValues: u,
          panOnDrag: F,
          panOnScroll: V,
          onPaneContextMenu: U,
          onPanZoomEnd: s,
          onDraggingChange: c
        });
        p.on("end", le);
      }
      const J = nye({
        zoomActivationKeyPressed: z,
        panOnDrag: F,
        zoomOnScroll: D,
        panOnScroll: V,
        zoomOnDoubleClick: G,
        zoomOnPinch: B,
        userSelectionActive: j,
        noPanClassName: N,
        noWheelClassName: L,
        lib: H,
        connectionInProgress: Q
      });
      p.filter(J), G ? m.on("dblclick.zoom", y) : m.on("dblclick.zoom", null);
    }
    function x() {
      p.on("zoom", null);
    }
    async function E(L, N, U) {
      const j = o_(L), V = p?.constrain()(j, N, U);
      return V && await b(V), new Promise((F) => F(V));
    }
    async function _(L, N) {
      const U = o_(L);
      return await b(U, N), new Promise((j) => j(U));
    }
    function C(L) {
      if (m) {
        const N = o_(L), U = m.property("__zoom");
        (U.k !== L.zoom || U.x !== L.x || U.y !== L.y) && p?.transform(m, N, null, { sync: !0 });
      }
    }
    function k() {
      const L = m ? hB(m.node()) : { x: 0, y: 0, k: 1 };
      return { x: L.x, y: L.y, zoom: L.k };
    }
    function A(L, N) {
      return m ? new Promise((U) => {
        p?.interpolate(N?.interpolate === "linear" ? Np : Lv).scaleTo(i_(m, N?.duration, N?.ease, () => U(!0)), L);
      }) : Promise.resolve(!1);
    }
    function O(L, N) {
      return m ? new Promise((U) => {
        p?.interpolate(N?.interpolate === "linear" ? Np : Lv).scaleBy(i_(m, N?.duration, N?.ease, () => U(!0)), L);
      }) : Promise.resolve(!1);
    }
    function P(L) {
      p?.scaleExtent(L);
    }
    function I(L) {
      p?.translateExtent(L);
    }
    function $(L) {
      const N = !Xo(L) || L < 0 ? 0 : L;
      p?.clickDistance(N);
    }
    return {
      update: v,
      destroy: x,
      setViewport: _,
      setViewportConstrained: E,
      getViewport: k,
      scaleTo: A,
      scaleBy: O,
      setScaleExtent: P,
      setTranslateExtent: I,
      syncViewport: C,
      setClickDistance: $
    };
  }
  var Ef;
  (function(e) {
    e.Line = "line", e.Handle = "handle";
  })(Ef || (Ef = {}));
  function oye({ width: e, prevWidth: t, height: n, prevHeight: r, affectsX: o, affectsY: i }) {
    const a = e - t, s = n - r, c = [a > 0 ? 1 : a < 0 ? -1 : 0, s > 0 ? 1 : s < 0 ? -1 : 0];
    return a && o && (c[0] = c[0] * -1), s && i && (c[1] = c[1] * -1), c;
  }
  function ej(e) {
    const t = e.includes("right") || e.includes("left"), n = e.includes("bottom") || e.includes("top"), r = e.includes("left"), o = e.includes("top");
    return {
      isHorizontal: t,
      isVertical: n,
      affectsX: r,
      affectsY: o
    };
  }
  function js(e, t) {
    return Math.max(0, t - e);
  }
  function Ds(e, t) {
    return Math.max(0, e - t);
  }
  function xy(e, t, n) {
    return Math.max(0, t - e, e - n);
  }
  function tj(e, t) {
    return e ? !t : t;
  }
  function iye(e, t, n, r, o, i, a, s) {
    let { affectsX: c, affectsY: u } = t;
    const { isHorizontal: d, isVertical: p } = t, m = d && p, { xSnapped: g, ySnapped: y } = n, { minWidth: b, maxWidth: v, minHeight: x, maxHeight: E } = r, { x: _, y: C, width: k, height: A, aspectRatio: O } = e;
    let P = Math.floor(d ? g - e.pointerX : 0), I = Math.floor(p ? y - e.pointerY : 0);
    const $ = k + (c ? -P : P), L = A + (u ? -I : I), N = -i[0] * k, U = -i[1] * A;
    let j = xy($, b, v), V = xy(L, x, E);
    if (a) {
      let W = 0, Y = 0;
      c && P < 0 ? W = js(_ + P + N, a[0][0]) : !c && P > 0 && (W = Ds(_ + $ + N, a[1][0])), u && I < 0 ? Y = js(C + I + U, a[0][1]) : !u && I > 0 && (Y = Ds(C + L + U, a[1][1])), j = Math.max(j, W), V = Math.max(V, Y);
    }
    if (s) {
      let W = 0, Y = 0;
      c && P > 0 ? W = Ds(_ + P, s[0][0]) : !c && P < 0 && (W = js(_ + $, s[1][0])), u && I > 0 ? Y = Ds(C + I, s[0][1]) : !u && I < 0 && (Y = js(C + L, s[1][1])), j = Math.max(j, W), V = Math.max(V, Y);
    }
    if (o) {
      if (d) {
        const W = xy($ / O, x, E) * O;
        if (j = Math.max(j, W), a) {
          let Y = 0;
          !c && !u || c && !u && m ? Y = Ds(C + U + $ / O, a[1][1]) * O : Y = js(C + U + (c ? P : -P) / O, a[0][1]) * O, j = Math.max(j, Y);
        }
        if (s) {
          let Y = 0;
          !c && !u || c && !u && m ? Y = js(C + $ / O, s[1][1]) * O : Y = Ds(C + (c ? P : -P) / O, s[0][1]) * O, j = Math.max(j, Y);
        }
      }
      if (p) {
        const W = xy(L * O, b, v) / O;
        if (V = Math.max(V, W), a) {
          let Y = 0;
          !c && !u || u && !c && m ? Y = Ds(_ + L * O + N, a[1][0]) / O : Y = js(_ + (u ? I : -I) * O + N, a[0][0]) / O, V = Math.max(V, Y);
        }
        if (s) {
          let Y = 0;
          !c && !u || u && !c && m ? Y = js(_ + L * O, s[1][0]) / O : Y = Ds(_ + (u ? I : -I) * O, s[0][0]) / O, V = Math.max(V, Y);
        }
      }
    }
    I = I + (I < 0 ? V : -V), P = P + (P < 0 ? j : -j), o && (m ? $ > L * O ? I = (tj(c, u) ? -P : P) / O : P = (tj(c, u) ? -I : I) * O : d ? (I = P / O, u = c) : (P = I * O, c = u));
    const F = c ? _ + P : _, K = u ? C + I : C;
    return {
      width: k + (c ? -P : P),
      height: A + (u ? -I : I),
      x: i[0] * P * (c ? -1 : 1) + F,
      y: i[1] * I * (u ? -1 : 1) + K
    };
  }
  const VB = { width: 0, height: 0, x: 0, y: 0 }, aye = {
    ...VB,
    pointerX: 0,
    pointerY: 0,
    aspectRatio: 1
  };
  function sye(e) {
    return [
      [0, 0],
      [e.measured.width, e.measured.height]
    ];
  }
  function lye(e, t, n) {
    const r = t.position.x + e.position.x, o = t.position.y + e.position.y, i = e.measured.width ?? 0, a = e.measured.height ?? 0, s = n[0] * i, c = n[1] * a;
    return [
      [r - s, o - c],
      [r + i - s, o + a - c]
    ];
  }
  function cye({ domNode: e, nodeId: t, getStoreItems: n, onChange: r, onEnd: o }) {
    const i = io(e);
    let a = {
      controlDirection: ej("bottom-right"),
      boundaries: {
        minWidth: 0,
        minHeight: 0,
        maxWidth: Number.MAX_VALUE,
        maxHeight: Number.MAX_VALUE
      },
      resizeDirection: void 0,
      keepAspectRatio: !1
    };
    function s({ controlPosition: u, boundaries: d, keepAspectRatio: p, resizeDirection: m, onResizeStart: g, onResize: y, onResizeEnd: b, shouldResize: v }) {
      let x = { ...VB }, E = { ...aye };
      a = {
        boundaries: d,
        resizeDirection: m,
        keepAspectRatio: p,
        controlDirection: ej(u)
      };
      let _, C = null, k = [], A, O, P, I = !1;
      const $ = eB().on("start", (L) => {
        const { nodeLookup: N, transform: U, snapGrid: j, snapToGrid: V, nodeOrigin: F, paneDomNode: K } = n();
        if (_ = N.get(t), !_)
          return;
        C = K?.getBoundingClientRect() ?? null;
        const { xSnapped: W, ySnapped: Y } = Pp(L.sourceEvent, {
          transform: U,
          snapGrid: j,
          snapToGrid: V,
          containerBounds: C
        });
        x = {
          width: _.measured.width ?? 0,
          height: _.measured.height ?? 0,
          x: _.position.x ?? 0,
          y: _.position.y ?? 0
        }, E = {
          ...x,
          pointerX: W,
          pointerY: Y,
          aspectRatio: x.width / x.height
        }, A = void 0, _.parentId && (_.extent === "parent" || _.expandParent) && (A = N.get(_.parentId), O = A && _.extent === "parent" ? sye(A) : void 0), k = [], P = void 0;
        for (const [B, D] of N)
          if (D.parentId === t && (k.push({
            id: B,
            position: { ...D.position },
            extent: D.extent
          }), D.extent === "parent" || D.expandParent)) {
            const G = lye(D, _, D.origin ?? F);
            P ? P = [
              [Math.min(G[0][0], P[0][0]), Math.min(G[0][1], P[0][1])],
              [Math.max(G[1][0], P[1][0]), Math.max(G[1][1], P[1][1])]
            ] : P = G;
          }
        g?.(L, { ...x });
      }).on("drag", (L) => {
        const { transform: N, snapGrid: U, snapToGrid: j, nodeOrigin: V } = n(), F = Pp(L.sourceEvent, {
          transform: N,
          snapGrid: U,
          snapToGrid: j,
          containerBounds: C
        }), K = [];
        if (!_)
          return;
        const { x: W, y: Y, width: B, height: D } = x, G = {}, z = _.origin ?? V, { width: H, height: X, x: Q, y: ne } = iye(E, a.controlDirection, F, a.boundaries, a.keepAspectRatio, z, O, P), te = H !== B, se = X !== D, ue = Q !== W && te, J = ne !== Y && se;
        if (!ue && !J && !te && !se)
          return;
        if ((ue || J || z[0] === 1 || z[1] === 1) && (G.x = ue ? Q : x.x, G.y = J ? ne : x.y, x.x = G.x, x.y = G.y, k.length > 0)) {
          const ge = Q - W, Se = ne - Y;
          for (const Me of k)
            Me.position = {
              x: Me.position.x - ge + z[0] * (H - B),
              y: Me.position.y - Se + z[1] * (X - D)
            }, K.push(Me);
        }
        if ((te || se) && (G.width = te && (!a.resizeDirection || a.resizeDirection === "horizontal") ? H : x.width, G.height = se && (!a.resizeDirection || a.resizeDirection === "vertical") ? X : x.height, x.width = G.width, x.height = G.height), A && _.expandParent) {
          const ge = z[0] * (G.width ?? 0);
          G.x && G.x < ge && (x.x = ge, E.x = E.x - (G.x - ge));
          const Se = z[1] * (G.height ?? 0);
          G.y && G.y < Se && (x.y = Se, E.y = E.y - (G.y - Se));
        }
        const ee = oye({
          width: x.width,
          prevWidth: B,
          height: x.height,
          prevHeight: D,
          affectsX: a.controlDirection.affectsX,
          affectsY: a.controlDirection.affectsY
        }), ie = { ...x, direction: ee };
        v?.(L, ie) !== !1 && (I = !0, y?.(L, ie), r(G, K));
      }).on("end", (L) => {
        I && (b?.(L, { ...x }), o?.({ ...x }), I = !1);
      });
      i.call($);
    }
    function c() {
      i.on(".drag", null);
    }
    return {
      update: s,
      destroy: c
    };
  }
  const { useDebugValue: uye } = On, { useSyncExternalStoreWithSelector: fye } = s9, dye = (e) => e;
  function HB(e, t = dye, n) {
    const r = fye(
      e.subscribe,
      e.getState,
      e.getServerState || e.getInitialState,
      t,
      n
    );
    return uye(r), r;
  }
  const nj = (e, t) => {
    const n = a9(e), r = (o, i = t) => HB(n, o, i);
    return Object.assign(r, n), r;
  }, pye = (e, t) => e ? nj(e, t) : nj;
  function _n(e, t) {
    if (Object.is(e, t))
      return !0;
    if (typeof e != "object" || e === null || typeof t != "object" || t === null)
      return !1;
    if (e instanceof Map && t instanceof Map) {
      if (e.size !== t.size) return !1;
      for (const [r, o] of e)
        if (!Object.is(o, t.get(r)))
          return !1;
      return !0;
    }
    if (e instanceof Set && t instanceof Set) {
      if (e.size !== t.size) return !1;
      for (const r of e)
        if (!t.has(r))
          return !1;
      return !0;
    }
    const n = Object.keys(e);
    if (n.length !== Object.keys(t).length)
      return !1;
    for (const r of n)
      if (!Object.prototype.hasOwnProperty.call(t, r) || !Object.is(e[r], t[r]))
        return !1;
    return !0;
  }
  const t1 = T.createContext(null), hye = t1.Provider, qB = Gi.error001();
  function It(e, t) {
    const n = T.useContext(t1);
    if (n === null)
      throw new Error(qB);
    return HB(n, e, t);
  }
  function Cn() {
    const e = T.useContext(t1);
    if (e === null)
      throw new Error(qB);
    return T.useMemo(() => ({
      getState: e.getState,
      setState: e.setState,
      subscribe: e.subscribe
    }), [e]);
  }
  const rj = { display: "none" }, mye = {
    position: "absolute",
    width: 1,
    height: 1,
    margin: -1,
    border: 0,
    padding: 0,
    overflow: "hidden",
    clip: "rect(0px, 0px, 0px, 0px)",
    clipPath: "inset(100%)"
  }, WB = "react-flow__node-desc", GB = "react-flow__edge-desc", gye = "react-flow__aria-live", yye = (e) => e.ariaLiveMessage, vye = (e) => e.ariaLabelConfig;
  function bye({ rfId: e }) {
    const t = It(yye);
    return S.jsx("div", { id: `${gye}-${e}`, "aria-live": "assertive", "aria-atomic": "true", style: mye, children: t });
  }
  function xye({ rfId: e, disableKeyboardA11y: t }) {
    const n = It(vye);
    return S.jsxs(S.Fragment, { children: [S.jsx("div", { id: `${WB}-${e}`, style: rj, children: t ? n["node.a11yDescription.default"] : n["node.a11yDescription.keyboardDisabled"] }), S.jsx("div", { id: `${GB}-${e}`, style: rj, children: n["edge.a11yDescription.default"] }), !t && S.jsx(bye, { rfId: e })] });
  }
  const n1 = T.forwardRef(({ position: e = "top-left", children: t, className: n, style: r, ...o }, i) => {
    const a = `${e}`.split("-");
    return S.jsx("div", { className: qn(["react-flow__panel", n, ...a]), style: r, ref: i, ...o, children: t });
  });
  n1.displayName = "Panel";
  function wye({ proOptions: e, position: t = "bottom-right" }) {
    return e?.hideAttribution ? null : S.jsx(n1, { position: t, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev", children: S.jsx("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution", children: "React Flow" }) });
  }
  const Sye = (e) => {
    const t = [], n = [];
    for (const [, r] of e.nodeLookup)
      r.selected && t.push(r.internals.userNode);
    for (const [, r] of e.edgeLookup)
      r.selected && n.push(r);
    return { selectedNodes: t, selectedEdges: n };
  }, wy = (e) => e.id;
  function _ye(e, t) {
    return _n(e.selectedNodes.map(wy), t.selectedNodes.map(wy)) && _n(e.selectedEdges.map(wy), t.selectedEdges.map(wy));
  }
  function Eye({ onSelectionChange: e }) {
    const t = Cn(), { selectedNodes: n, selectedEdges: r } = It(Sye, _ye);
    return T.useEffect(() => {
      const o = { nodes: n, edges: r };
      e?.(o), t.getState().onSelectionChangeHandlers.forEach((i) => i(o));
    }, [n, r, e]), null;
  }
  const Cye = (e) => !!e.onSelectionChangeHandlers;
  function kye({ onSelectionChange: e }) {
    const t = It(Cye);
    return e || t ? S.jsx(Eye, { onSelectionChange: e }) : null;
  }
  const KB = [0, 0], Tye = { x: 0, y: 0, zoom: 1 }, Aye = [
    "nodes",
    "edges",
    "defaultNodes",
    "defaultEdges",
    "onConnect",
    "onConnectStart",
    "onConnectEnd",
    "onClickConnectStart",
    "onClickConnectEnd",
    "nodesDraggable",
    "autoPanOnNodeFocus",
    "nodesConnectable",
    "nodesFocusable",
    "edgesFocusable",
    "edgesReconnectable",
    "elevateNodesOnSelect",
    "elevateEdgesOnSelect",
    "minZoom",
    "maxZoom",
    "nodeExtent",
    "onNodesChange",
    "onEdgesChange",
    "elementsSelectable",
    "connectionMode",
    "snapGrid",
    "snapToGrid",
    "translateExtent",
    "connectOnClick",
    "defaultEdgeOptions",
    "fitView",
    "fitViewOptions",
    "onNodesDelete",
    "onEdgesDelete",
    "onDelete",
    "onNodeDrag",
    "onNodeDragStart",
    "onNodeDragStop",
    "onSelectionDrag",
    "onSelectionDragStart",
    "onSelectionDragStop",
    "onMoveStart",
    "onMove",
    "onMoveEnd",
    "noPanClassName",
    "nodeOrigin",
    "autoPanOnConnect",
    "autoPanOnNodeDrag",
    "onError",
    "connectionRadius",
    "isValidConnection",
    "selectNodesOnDrag",
    "nodeDragThreshold",
    "connectionDragThreshold",
    "onBeforeDelete",
    "debug",
    "autoPanSpeed",
    "ariaLabelConfig",
    "zIndexMode"
  ], oj = [...Aye, "rfId"], Rye = (e) => ({
    setNodes: e.setNodes,
    setEdges: e.setEdges,
    setMinZoom: e.setMinZoom,
    setMaxZoom: e.setMaxZoom,
    setTranslateExtent: e.setTranslateExtent,
    setNodeExtent: e.setNodeExtent,
    reset: e.reset,
    setDefaultNodesAndEdges: e.setDefaultNodesAndEdges
  }), ij = {
    /*
     * these are values that are also passed directly to other components
     * than the StoreUpdater. We can reduce the number of setStore calls
     * by setting the same values here as prev fields.
     */
    translateExtent: sh,
    nodeOrigin: KB,
    minZoom: 0.5,
    maxZoom: 2,
    elementsSelectable: !0,
    noPanClassName: "nopan",
    rfId: "1"
  };
  function Oye(e) {
    const { setNodes: t, setEdges: n, setMinZoom: r, setMaxZoom: o, setTranslateExtent: i, setNodeExtent: a, reset: s, setDefaultNodesAndEdges: c } = It(Rye, _n), u = Cn();
    T.useEffect(() => (c(e.defaultNodes, e.defaultEdges), () => {
      d.current = ij, s();
    }), []);
    const d = T.useRef(ij);
    return T.useEffect(
      () => {
        for (const p of oj) {
          const m = e[p], g = d.current[p];
          m !== g && (typeof e[p] > "u" || (p === "nodes" ? t(m) : p === "edges" ? n(m) : p === "minZoom" ? r(m) : p === "maxZoom" ? o(m) : p === "translateExtent" ? i(m) : p === "nodeExtent" ? a(m) : p === "ariaLabelConfig" ? u.setState({ ariaLabelConfig: wge(m) }) : p === "fitView" ? u.setState({ fitViewQueued: m }) : p === "fitViewOptions" ? u.setState({ fitViewOptions: m }) : u.setState({ [p]: m })));
        }
        d.current = e;
      },
      // Only re-run the effect if one of the fields we track changes
      oj.map((p) => e[p])
    ), null;
  }
  function aj() {
    return typeof window > "u" || !window.matchMedia ? null : window.matchMedia("(prefers-color-scheme: dark)");
  }
  function Mye(e) {
    const [t, n] = T.useState(e === "system" ? null : e);
    return T.useEffect(() => {
      if (e !== "system") {
        n(e);
        return;
      }
      const r = aj(), o = () => n(r?.matches ? "dark" : "light");
      return o(), r?.addEventListener("change", o), () => {
        r?.removeEventListener("change", o);
      };
    }, [e]), t !== null ? t : aj()?.matches ? "dark" : "light";
  }
  const sj = typeof document < "u" ? document : null;
  function Fa(e = null, t = { target: sj, actInsideInputWithModifier: !0 }) {
    const [n, r] = T.useState(!1), o = T.useRef(!1), i = T.useRef(/* @__PURE__ */ new Set([])), [a, s] = T.useMemo(() => {
      if (e !== null) {
        const u = (Array.isArray(e) ? e : [e]).filter((p) => typeof p == "string").map((p) => p.replace("+", `
`).replace(`

`, `
+`).split(`
`)), d = u.reduce((p, m) => p.concat(...m), []);
        return [u, d];
      }
      return [[], []];
    }, [e]);
    return T.useEffect(() => {
      const c = t?.target ?? sj, u = t?.actInsideInputWithModifier ?? !0;
      if (e !== null) {
        const d = (g) => {
          if (o.current = g.ctrlKey || g.metaKey || g.shiftKey || g.altKey, (!o.current || o.current && !u) && AB(g))
            return !1;
          const b = cj(g.code, s);
          if (i.current.add(g[b]), lj(a, i.current, !1)) {
            const v = g.composedPath?.()?.[0] || g.target, x = v?.nodeName === "BUTTON" || v?.nodeName === "A";
            t.preventDefault !== !1 && (o.current || !x) && g.preventDefault(), r(!0);
          }
        }, p = (g) => {
          const y = cj(g.code, s);
          lj(a, i.current, !0) ? (r(!1), i.current.clear()) : i.current.delete(g[y]), g.key === "Meta" && i.current.clear(), o.current = !1;
        }, m = () => {
          i.current.clear(), r(!1);
        };
        return c?.addEventListener("keydown", d), c?.addEventListener("keyup", p), window.addEventListener("blur", m), window.addEventListener("contextmenu", m), () => {
          c?.removeEventListener("keydown", d), c?.removeEventListener("keyup", p), window.removeEventListener("blur", m), window.removeEventListener("contextmenu", m);
        };
      }
    }, [e, r]), n;
  }
  function lj(e, t, n) {
    return e.filter((r) => n || r.length === t.size).some((r) => r.every((o) => t.has(o)));
  }
  function cj(e, t) {
    return t.includes(e) ? "code" : "key";
  }
  const Nye = () => {
    const e = Cn();
    return T.useMemo(() => ({
      zoomIn: (t) => {
        const { panZoom: n } = e.getState();
        return n ? n.scaleBy(1.2, { duration: t?.duration }) : Promise.resolve(!1);
      },
      zoomOut: (t) => {
        const { panZoom: n } = e.getState();
        return n ? n.scaleBy(1 / 1.2, { duration: t?.duration }) : Promise.resolve(!1);
      },
      zoomTo: (t, n) => {
        const { panZoom: r } = e.getState();
        return r ? r.scaleTo(t, { duration: n?.duration }) : Promise.resolve(!1);
      },
      getZoom: () => e.getState().transform[2],
      setViewport: async (t, n) => {
        const { transform: [r, o, i], panZoom: a } = e.getState();
        return a ? (await a.setViewport({
          x: t.x ?? r,
          y: t.y ?? o,
          zoom: t.zoom ?? i
        }, n), Promise.resolve(!0)) : Promise.resolve(!1);
      },
      getViewport: () => {
        const [t, n, r] = e.getState().transform;
        return { x: t, y: n, zoom: r };
      },
      setCenter: async (t, n, r) => e.getState().setCenter(t, n, r),
      fitBounds: async (t, n) => {
        const { width: r, height: o, minZoom: i, maxZoom: a, panZoom: s } = e.getState(), c = NT(t, r, o, i, a, n?.padding ?? 0.1);
        return s ? (await s.setViewport(c, {
          duration: n?.duration,
          ease: n?.ease,
          interpolate: n?.interpolate
        }), Promise.resolve(!0)) : Promise.resolve(!1);
      },
      screenToFlowPosition: (t, n = {}) => {
        const { transform: r, snapGrid: o, snapToGrid: i, domNode: a } = e.getState();
        if (!a)
          return t;
        const { x: s, y: c } = a.getBoundingClientRect(), u = {
          x: t.x - s,
          y: t.y - c
        }, d = n.snapGrid ?? o, p = n.snapToGrid ?? i;
        return rm(u, r, p, d);
      },
      flowToScreenPosition: (t) => {
        const { transform: n, domNode: r } = e.getState();
        if (!r)
          return t;
        const { x: o, y: i } = r.getBoundingClientRect(), a = O0(t, n);
        return {
          x: a.x + o,
          y: a.y + i
        };
      }
    }), []);
  };
  function YB(e, t) {
    const n = [], r = /* @__PURE__ */ new Map(), o = [];
    for (const i of e)
      if (i.type === "add") {
        o.push(i);
        continue;
      } else if (i.type === "remove" || i.type === "replace")
        r.set(i.id, [i]);
      else {
        const a = r.get(i.id);
        a ? a.push(i) : r.set(i.id, [i]);
      }
    for (const i of t) {
      const a = r.get(i.id);
      if (!a) {
        n.push(i);
        continue;
      }
      if (a[0].type === "remove")
        continue;
      if (a[0].type === "replace") {
        n.push({ ...a[0].item });
        continue;
      }
      const s = { ...i };
      for (const c of a)
        Pye(c, s);
      n.push(s);
    }
    return o.length && o.forEach((i) => {
      i.index !== void 0 ? n.splice(i.index, 0, { ...i.item }) : n.push({ ...i.item });
    }), n;
  }
  function Pye(e, t) {
    switch (e.type) {
      case "select": {
        t.selected = e.selected;
        break;
      }
      case "position": {
        typeof e.position < "u" && (t.position = e.position), typeof e.dragging < "u" && (t.dragging = e.dragging);
        break;
      }
      case "dimensions": {
        typeof e.dimensions < "u" && (t.measured = {
          ...e.dimensions
        }, e.setAttributes && ((e.setAttributes === !0 || e.setAttributes === "width") && (t.width = e.dimensions.width), (e.setAttributes === !0 || e.setAttributes === "height") && (t.height = e.dimensions.height))), typeof e.resizing == "boolean" && (t.resizing = e.resizing);
        break;
      }
    }
  }
  function zT(e, t) {
    return YB(e, t);
  }
  function XB(e, t) {
    return YB(e, t);
  }
  function Xl(e, t) {
    return {
      id: e,
      type: "select",
      selected: t
    };
  }
  function Ku(e, t = /* @__PURE__ */ new Set(), n = !1) {
    const r = [];
    for (const [o, i] of e) {
      const a = t.has(o);
      !(i.selected === void 0 && !a) && i.selected !== a && (n && (i.selected = a), r.push(Xl(i.id, a)));
    }
    return r;
  }
  function uj({ items: e = [], lookup: t }) {
    const n = [], r = new Map(e.map((o) => [o.id, o]));
    for (const [o, i] of e.entries()) {
      const a = t.get(i.id), s = a?.internals?.userNode ?? a;
      s !== void 0 && s !== i && n.push({ id: i.id, item: i, type: "replace" }), s === void 0 && n.push({ item: i, type: "add", index: o });
    }
    for (const [o] of t)
      r.get(o) === void 0 && n.push({ id: o, type: "remove" });
    return n;
  }
  function fj(e) {
    return {
      id: e.id,
      type: "remove"
    };
  }
  const dj = (e) => fge(e), Iye = (e) => xB(e);
  function ZB(e) {
    return T.forwardRef(e);
  }
  const $ye = typeof window < "u" ? T.useLayoutEffect : T.useEffect;
  function pj(e) {
    const [t, n] = T.useState(BigInt(0)), [r] = T.useState(() => jye(() => n((o) => o + BigInt(1))));
    return $ye(() => {
      const o = r.get();
      o.length && (e(o), r.reset());
    }, [t]), r;
  }
  function jye(e) {
    let t = [];
    return {
      get: () => t,
      reset: () => {
        t = [];
      },
      push: (n) => {
        t.push(n), e();
      }
    };
  }
  const QB = T.createContext(null);
  function Dye({ children: e }) {
    const t = Cn(), n = T.useCallback((s) => {
      const { nodes: c = [], setNodes: u, hasDefaultNodes: d, onNodesChange: p, nodeLookup: m, fitViewQueued: g, onNodesChangeMiddlewareMap: y } = t.getState();
      let b = c;
      for (const x of s)
        b = typeof x == "function" ? x(b) : x;
      let v = uj({
        items: b,
        lookup: m
      });
      for (const x of y.values())
        v = x(v);
      d && u(b), v.length > 0 ? p?.(v) : g && window.requestAnimationFrame(() => {
        const { fitViewQueued: x, nodes: E, setNodes: _ } = t.getState();
        x && _(E);
      });
    }, []), r = pj(n), o = T.useCallback((s) => {
      const { edges: c = [], setEdges: u, hasDefaultEdges: d, onEdgesChange: p, edgeLookup: m } = t.getState();
      let g = c;
      for (const y of s)
        g = typeof y == "function" ? y(g) : y;
      d ? u(g) : p && p(uj({
        items: g,
        lookup: m
      }));
    }, []), i = pj(o), a = T.useMemo(() => ({ nodeQueue: r, edgeQueue: i }), []);
    return S.jsx(QB.Provider, { value: a, children: e });
  }
  function Fye() {
    const e = T.useContext(QB);
    if (!e)
      throw new Error("useBatchContext must be used within a BatchProvider");
    return e;
  }
  const Lye = (e) => !!e.panZoom;
  function Ec() {
    const e = Nye(), t = Cn(), n = Fye(), r = It(Lye), o = T.useMemo(() => {
      const i = (p) => t.getState().nodeLookup.get(p), a = (p) => {
        n.nodeQueue.push(p);
      }, s = (p) => {
        n.edgeQueue.push(p);
      }, c = (p) => {
        const { nodeLookup: m, nodeOrigin: g } = t.getState(), y = dj(p) ? p : m.get(p.id), b = y.parentId ? kB(y.position, y.measured, y.parentId, m, g) : y.position, v = {
          ...y,
          position: b,
          width: y.measured?.width ?? y.width,
          height: y.measured?.height ?? y.height
        };
        return Sf(v);
      }, u = (p, m, g = { replace: !1 }) => {
        a((y) => y.map((b) => {
          if (b.id === p) {
            const v = typeof m == "function" ? m(b) : m;
            return g.replace && dj(v) ? v : { ...b, ...v };
          }
          return b;
        }));
      }, d = (p, m, g = { replace: !1 }) => {
        s((y) => y.map((b) => {
          if (b.id === p) {
            const v = typeof m == "function" ? m(b) : m;
            return g.replace && Iye(v) ? v : { ...b, ...v };
          }
          return b;
        }));
      };
      return {
        getNodes: () => t.getState().nodes.map((p) => ({ ...p })),
        getNode: (p) => i(p)?.internals.userNode,
        getInternalNode: i,
        getEdges: () => {
          const { edges: p = [] } = t.getState();
          return p.map((m) => ({ ...m }));
        },
        getEdge: (p) => t.getState().edgeLookup.get(p),
        setNodes: a,
        setEdges: s,
        addNodes: (p) => {
          const m = Array.isArray(p) ? p : [p];
          n.nodeQueue.push((g) => [...g, ...m]);
        },
        addEdges: (p) => {
          const m = Array.isArray(p) ? p : [p];
          n.edgeQueue.push((g) => [...g, ...m]);
        },
        toObject: () => {
          const { nodes: p = [], edges: m = [], transform: g } = t.getState(), [y, b, v] = g;
          return {
            nodes: p.map((x) => ({ ...x })),
            edges: m.map((x) => ({ ...x })),
            viewport: {
              x: y,
              y: b,
              zoom: v
            }
          };
        },
        deleteElements: async ({ nodes: p = [], edges: m = [] }) => {
          const { nodes: g, edges: y, onNodesDelete: b, onEdgesDelete: v, triggerNodeChanges: x, triggerEdgeChanges: E, onDelete: _, onBeforeDelete: C } = t.getState(), { nodes: k, edges: A } = await gge({
            nodesToRemove: p,
            edgesToRemove: m,
            nodes: g,
            edges: y,
            onBeforeDelete: C
          }), O = A.length > 0, P = k.length > 0;
          if (O) {
            const I = A.map(fj);
            v?.(A), E(I);
          }
          if (P) {
            const I = k.map(fj);
            b?.(k), x(I);
          }
          return (P || O) && _?.({ nodes: k, edges: A }), { deletedNodes: k, deletedEdges: A };
        },
        /**
         * Partial is defined as "the 2 nodes/areas are intersecting partially".
         * If a is contained in b or b is contained in a, they are both
         * considered fully intersecting.
         */
        getIntersectingNodes: (p, m = !0, g) => {
          const y = V$(p), b = y ? p : c(p), v = g !== void 0;
          return b ? (g || t.getState().nodes).filter((x) => {
            const E = t.getState().nodeLookup.get(x.id);
            if (E && !y && (x.id === p.id || !E.internals.positionAbsolute))
              return !1;
            const _ = Sf(v ? x : E), C = ch(_, b);
            return m && C > 0 || C >= _.width * _.height || C >= b.width * b.height;
          }) : [];
        },
        isNodeIntersecting: (p, m, g = !0) => {
          const b = V$(p) ? p : c(p);
          if (!b)
            return !1;
          const v = ch(b, m);
          return g && v > 0 || v >= m.width * m.height || v >= b.width * b.height;
        },
        updateNode: u,
        updateNodeData: (p, m, g = { replace: !1 }) => {
          u(p, (y) => {
            const b = typeof m == "function" ? m(y) : m;
            return g.replace ? { ...y, data: b } : { ...y, data: { ...y.data, ...b } };
          }, g);
        },
        updateEdge: d,
        updateEdgeData: (p, m, g = { replace: !1 }) => {
          d(p, (y) => {
            const b = typeof m == "function" ? m(y) : m;
            return g.replace ? { ...y, data: b } : { ...y, data: { ...y.data, ...b } };
          }, g);
        },
        getNodesBounds: (p) => {
          const { nodeLookup: m, nodeOrigin: g } = t.getState();
          return dge(p, { nodeLookup: m, nodeOrigin: g });
        },
        getHandleConnections: ({ type: p, id: m, nodeId: g }) => Array.from(t.getState().connectionLookup.get(`${g}-${p}${m ? `-${m}` : ""}`)?.values() ?? []),
        getNodeConnections: ({ type: p, handleId: m, nodeId: g }) => Array.from(t.getState().connectionLookup.get(`${g}${p ? m ? `-${p}-${m}` : `-${p}` : ""}`)?.values() ?? []),
        fitView: async (p) => {
          const m = t.getState().fitViewResolver ?? xge();
          return t.setState({ fitViewQueued: !0, fitViewOptions: p, fitViewResolver: m }), n.nodeQueue.push((g) => [...g]), m.promise;
        }
      };
    }, []);
    return T.useMemo(() => ({
      ...o,
      ...e,
      viewportInitialized: r
    }), [r]);
  }
  const hj = (e) => e.selected, zye = typeof window < "u" ? window : void 0;
  function Bye({ deleteKeyCode: e, multiSelectionKeyCode: t }) {
    const n = Cn(), { deleteElements: r } = Ec(), o = Fa(e, { actInsideInputWithModifier: !1 }), i = Fa(t, { target: zye });
    T.useEffect(() => {
      if (o) {
        const { edges: a, nodes: s } = n.getState();
        r({ nodes: s.filter(hj), edges: a.filter(hj) }), n.setState({ nodesSelectionActive: !1 });
      }
    }, [o]), T.useEffect(() => {
      n.setState({ multiSelectionActive: i });
    }, [i]);
  }
  function Uye(e) {
    const t = Cn();
    T.useEffect(() => {
      const n = () => {
        if (!e.current || !(e.current.checkVisibility?.() ?? !0))
          return !1;
        const r = PT(e.current);
        (r.height === 0 || r.width === 0) && t.getState().onError?.("004", Gi.error004()), t.setState({ width: r.width || 500, height: r.height || 500 });
      };
      if (e.current) {
        n(), window.addEventListener("resize", n);
        const r = new ResizeObserver(() => n());
        return r.observe(e.current), () => {
          window.removeEventListener("resize", n), r && e.current && r.unobserve(e.current);
        };
      }
    }, []);
  }
  const r1 = {
    position: "absolute",
    width: "100%",
    height: "100%",
    top: 0,
    left: 0
  }, Vye = (e) => ({
    userSelectionActive: e.userSelectionActive,
    lib: e.lib,
    connectionInProgress: e.connection.inProgress
  });
  function Hye({ onPaneContextMenu: e, zoomOnScroll: t = !0, zoomOnPinch: n = !0, panOnScroll: r = !1, panOnScrollSpeed: o = 0.5, panOnScrollMode: i = ac.Free, zoomOnDoubleClick: a = !0, panOnDrag: s = !0, defaultViewport: c, translateExtent: u, minZoom: d, maxZoom: p, zoomActivationKeyCode: m, preventScrolling: g = !0, children: y, noWheelClassName: b, noPanClassName: v, onViewportChange: x, isControlledViewport: E, paneClickDistance: _, selectionOnDrag: C }) {
    const k = Cn(), A = T.useRef(null), { userSelectionActive: O, lib: P, connectionInProgress: I } = It(Vye, _n), $ = Fa(m), L = T.useRef();
    Uye(A);
    const N = T.useCallback((U) => {
      x?.({ x: U[0], y: U[1], zoom: U[2] }), E || k.setState({ transform: U });
    }, [x, E]);
    return T.useEffect(() => {
      if (A.current) {
        L.current = rye({
          domNode: A.current,
          minZoom: d,
          maxZoom: p,
          translateExtent: u,
          viewport: c,
          onDraggingChange: (F) => k.setState({ paneDragging: F }),
          onPanZoomStart: (F, K) => {
            const { onViewportChangeStart: W, onMoveStart: Y } = k.getState();
            Y?.(F, K), W?.(K);
          },
          onPanZoom: (F, K) => {
            const { onViewportChange: W, onMove: Y } = k.getState();
            Y?.(F, K), W?.(K);
          },
          onPanZoomEnd: (F, K) => {
            const { onViewportChangeEnd: W, onMoveEnd: Y } = k.getState();
            Y?.(F, K), W?.(K);
          }
        });
        const { x: U, y: j, zoom: V } = L.current.getViewport();
        return k.setState({
          panZoom: L.current,
          transform: [U, j, V],
          domNode: A.current.closest(".react-flow")
        }), () => {
          L.current?.destroy();
        };
      }
    }, []), T.useEffect(() => {
      L.current?.update({
        onPaneContextMenu: e,
        zoomOnScroll: t,
        zoomOnPinch: n,
        panOnScroll: r,
        panOnScrollSpeed: o,
        panOnScrollMode: i,
        zoomOnDoubleClick: a,
        panOnDrag: s,
        zoomActivationKeyPressed: $,
        preventScrolling: g,
        noPanClassName: v,
        userSelectionActive: O,
        noWheelClassName: b,
        lib: P,
        onTransformChange: N,
        connectionInProgress: I,
        selectionOnDrag: C,
        paneClickDistance: _
      });
    }, [
      e,
      t,
      n,
      r,
      o,
      i,
      a,
      s,
      $,
      g,
      v,
      O,
      b,
      P,
      N,
      I,
      C,
      _
    ]), S.jsx("div", { className: "react-flow__renderer", ref: A, style: r1, children: y });
  }
  const qye = (e) => ({
    userSelectionActive: e.userSelectionActive,
    userSelectionRect: e.userSelectionRect
  });
  function Wye() {
    const { userSelectionActive: e, userSelectionRect: t } = It(qye, _n);
    return e && t ? S.jsx("div", { className: "react-flow__selection react-flow__container", style: {
      width: t.width,
      height: t.height,
      transform: `translate(${t.x}px, ${t.y}px)`
    } }) : null;
  }
  const a_ = (e, t) => (n) => {
    n.target === t.current && e?.(n);
  }, Gye = (e) => ({
    userSelectionActive: e.userSelectionActive,
    elementsSelectable: e.elementsSelectable,
    connectionInProgress: e.connection.inProgress,
    dragging: e.paneDragging
  });
  function Kye({ isSelecting: e, selectionKeyPressed: t, selectionMode: n = lh.Full, panOnDrag: r, paneClickDistance: o, selectionOnDrag: i, onSelectionStart: a, onSelectionEnd: s, onPaneClick: c, onPaneContextMenu: u, onPaneScroll: d, onPaneMouseEnter: p, onPaneMouseMove: m, onPaneMouseLeave: g, children: y }) {
    const b = Cn(), { userSelectionActive: v, elementsSelectable: x, dragging: E, connectionInProgress: _ } = It(Gye, _n), C = x && (e || v), k = T.useRef(null), A = T.useRef(), O = T.useRef(/* @__PURE__ */ new Set()), P = T.useRef(/* @__PURE__ */ new Set()), I = T.useRef(!1), $ = (W) => {
      if (I.current || _) {
        I.current = !1;
        return;
      }
      c?.(W), b.getState().resetSelectedElements(), b.setState({ nodesSelectionActive: !1 });
    }, L = (W) => {
      if (Array.isArray(r) && r?.includes(2)) {
        W.preventDefault();
        return;
      }
      u?.(W);
    }, N = d ? (W) => d(W) : void 0, U = (W) => {
      I.current && (W.stopPropagation(), I.current = !1);
    }, j = (W) => {
      const { domNode: Y } = b.getState();
      if (A.current = Y?.getBoundingClientRect(), !A.current)
        return;
      const B = W.target === k.current;
      if (!B && !!W.target.closest(".nokey") || !e || !(i && B || t) || W.button !== 0 || !W.isPrimary)
        return;
      W.target?.setPointerCapture?.(W.pointerId), I.current = !1;
      const { x: z, y: H } = Zo(W.nativeEvent, A.current);
      b.setState({
        userSelectionRect: {
          width: 0,
          height: 0,
          startX: z,
          startY: H,
          x: z,
          y: H
        }
      }), B || (W.stopPropagation(), W.preventDefault());
    }, V = (W) => {
      const { userSelectionRect: Y, transform: B, nodeLookup: D, edgeLookup: G, connectionLookup: z, triggerNodeChanges: H, triggerEdgeChanges: X, defaultEdgeOptions: Q, resetSelectedElements: ne } = b.getState();
      if (!A.current || !Y)
        return;
      const { x: te, y: se } = Zo(W.nativeEvent, A.current), { startX: ue, startY: J } = Y;
      if (!I.current) {
        const Se = t ? 0 : o;
        if (Math.hypot(te - ue, se - J) <= Se)
          return;
        ne(), a?.(W);
      }
      I.current = !0;
      const ee = {
        startX: ue,
        startY: J,
        x: te < ue ? te : ue,
        y: se < J ? se : J,
        width: Math.abs(te - ue),
        height: Math.abs(se - J)
      }, ie = O.current, le = P.current;
      O.current = new Set(MT(D, ee, B, n === lh.Partial, !0).map((Se) => Se.id)), P.current = /* @__PURE__ */ new Set();
      const ge = Q?.selectable ?? !0;
      for (const Se of O.current) {
        const Me = z.get(Se);
        if (Me)
          for (const { edgeId: je } of Me.values()) {
            const ze = G.get(je);
            ze && (ze.selectable ?? ge) && P.current.add(je);
          }
      }
      if (!H$(ie, O.current)) {
        const Se = Ku(D, O.current, !0);
        H(Se);
      }
      if (!H$(le, P.current)) {
        const Se = Ku(G, P.current);
        X(Se);
      }
      b.setState({
        userSelectionRect: ee,
        userSelectionActive: !0,
        nodesSelectionActive: !1
      });
    }, F = (W) => {
      W.button === 0 && (W.target?.releasePointerCapture?.(W.pointerId), !v && W.target === k.current && b.getState().userSelectionRect && $?.(W), b.setState({
        userSelectionActive: !1,
        userSelectionRect: null
      }), I.current && (s?.(W), b.setState({
        nodesSelectionActive: O.current.size > 0
      })));
    }, K = r === !0 || Array.isArray(r) && r.includes(0);
    return S.jsxs("div", { className: qn(["react-flow__pane", { draggable: K, dragging: E, selection: e }]), onClick: C ? void 0 : a_($, k), onContextMenu: a_(L, k), onWheel: a_(N, k), onPointerEnter: C ? void 0 : p, onPointerMove: C ? V : m, onPointerUp: C ? F : void 0, onPointerDownCapture: C ? j : void 0, onClickCapture: C ? U : void 0, onPointerLeave: g, ref: k, style: r1, children: [y, S.jsx(Wye, {})] });
  }
  function yC({ id: e, store: t, unselect: n = !1, nodeRef: r }) {
    const { addSelectedNodes: o, unselectNodesAndEdges: i, multiSelectionActive: a, nodeLookup: s, onError: c } = t.getState(), u = s.get(e);
    if (!u) {
      c?.("012", Gi.error012(e));
      return;
    }
    t.setState({ nodesSelectionActive: !1 }), u.selected ? (n || u.selected && a) && (i({ nodes: [u], edges: [] }), requestAnimationFrame(() => r?.current?.blur())) : o([e]);
  }
  function JB({ nodeRef: e, disabled: t = !1, noDragClassName: n, handleSelector: r, nodeId: o, isSelectable: i, nodeClickDistance: a }) {
    const s = Cn(), [c, u] = T.useState(!1), d = T.useRef();
    return T.useEffect(() => {
      d.current = Vge({
        getStoreItems: () => s.getState(),
        onNodeMouseDown: (p) => {
          yC({
            id: p,
            store: s,
            nodeRef: e
          });
        },
        onDragStart: () => {
          u(!0);
        },
        onDragStop: () => {
          u(!1);
        }
      });
    }, []), T.useEffect(() => {
      if (t)
        d.current?.destroy();
      else if (e.current)
        return d.current?.update({
          noDragClassName: n,
          handleSelector: r,
          domNode: e.current,
          isSelectable: i,
          nodeId: o,
          nodeClickDistance: a
        }), () => {
          d.current?.destroy();
        };
    }, [n, r, t, i, e, o]), c;
  }
  const Yye = (e) => (t) => t.selected && (t.draggable || e && typeof t.draggable > "u");
  function e8() {
    const e = Cn();
    return T.useCallback((n) => {
      const { nodeExtent: r, snapToGrid: o, snapGrid: i, nodesDraggable: a, onError: s, updateNodePositions: c, nodeLookup: u, nodeOrigin: d } = e.getState(), p = /* @__PURE__ */ new Map(), m = Yye(a), g = o ? i[0] : 5, y = o ? i[1] : 5, b = n.direction.x * g * n.factor, v = n.direction.y * y * n.factor;
      for (const [, x] of u) {
        if (!m(x))
          continue;
        let E = {
          x: x.internals.positionAbsolute.x + b,
          y: x.internals.positionAbsolute.y + v
        };
        o && (E = nm(E, i));
        const { position: _, positionAbsolute: C } = wB({
          nodeId: x.id,
          nextPosition: E,
          nodeLookup: u,
          nodeExtent: r,
          nodeOrigin: d,
          onError: s
        });
        x.position = _, x.internals.positionAbsolute = C, p.set(x.id, x);
      }
      c(p);
    }, []);
  }
  const BT = T.createContext(null), Xye = BT.Provider;
  BT.Consumer;
  const t8 = () => T.useContext(BT), Zye = (e) => ({
    connectOnClick: e.connectOnClick,
    noPanClassName: e.noPanClassName,
    rfId: e.rfId
  }), Qye = (e, t, n) => (r) => {
    const { connectionClickStartHandle: o, connectionMode: i, connection: a } = r, { fromHandle: s, toHandle: c, isValid: u } = a, d = c?.nodeId === e && c?.id === t && c?.type === n;
    return {
      connectingFrom: s?.nodeId === e && s?.id === t && s?.type === n,
      connectingTo: d,
      clickConnecting: o?.nodeId === e && o?.id === t && o?.type === n,
      isPossibleEndHandle: i === xf.Strict ? s?.type !== n : e !== s?.nodeId || t !== s?.id,
      connectionInProcess: !!s,
      clickConnectionInProcess: !!o,
      valid: d && u
    };
  };
  function Jye({ type: e = "source", position: t = Ve.Top, isValidConnection: n, isConnectable: r = !0, isConnectableStart: o = !0, isConnectableEnd: i = !0, id: a, onConnect: s, children: c, className: u, onMouseDown: d, onTouchStart: p, ...m }, g) {
    const y = a || null, b = e === "target", v = Cn(), x = t8(), { connectOnClick: E, noPanClassName: _, rfId: C } = It(Zye, _n), { connectingFrom: k, connectingTo: A, clickConnecting: O, isPossibleEndHandle: P, connectionInProcess: I, clickConnectionInProcess: $, valid: L } = It(Qye(x, y, e), _n);
    x || v.getState().onError?.("010", Gi.error010());
    const N = (V) => {
      const { defaultEdgeOptions: F, onConnect: K, hasDefaultEdges: W } = v.getState(), Y = {
        ...F,
        ...V
      };
      if (W) {
        const { edges: B, setEdges: D } = v.getState();
        D(Tge(Y, B));
      }
      K?.(Y), s?.(Y);
    }, U = (V) => {
      if (!x)
        return;
      const F = RB(V.nativeEvent);
      if (o && (F && V.button === 0 || !F)) {
        const K = v.getState();
        gC.onPointerDown(V.nativeEvent, {
          handleDomNode: V.currentTarget,
          autoPanOnConnect: K.autoPanOnConnect,
          connectionMode: K.connectionMode,
          connectionRadius: K.connectionRadius,
          domNode: K.domNode,
          nodeLookup: K.nodeLookup,
          lib: K.lib,
          isTarget: b,
          handleId: y,
          nodeId: x,
          flowId: K.rfId,
          panBy: K.panBy,
          cancelConnection: K.cancelConnection,
          onConnectStart: K.onConnectStart,
          onConnectEnd: K.onConnectEnd,
          updateConnection: K.updateConnection,
          onConnect: N,
          isValidConnection: n || K.isValidConnection,
          getTransform: () => v.getState().transform,
          getFromHandle: () => v.getState().connection.fromHandle,
          autoPanSpeed: K.autoPanSpeed,
          dragThreshold: K.connectionDragThreshold
        });
      }
      F ? d?.(V) : p?.(V);
    }, j = (V) => {
      const { onClickConnectStart: F, onClickConnectEnd: K, connectionClickStartHandle: W, connectionMode: Y, isValidConnection: B, lib: D, rfId: G, nodeLookup: z, connection: H } = v.getState();
      if (!x || !W && !o)
        return;
      if (!W) {
        F?.(V.nativeEvent, { nodeId: x, handleId: y, handleType: e }), v.setState({ connectionClickStartHandle: { nodeId: x, type: e, id: y } });
        return;
      }
      const X = TB(V.target), Q = n || B, { connection: ne, isValid: te } = gC.isValid(V.nativeEvent, {
        handle: {
          nodeId: x,
          id: y,
          type: e
        },
        connectionMode: Y,
        fromNodeId: W.nodeId,
        fromHandleId: W.id || null,
        fromType: W.type,
        isValidConnection: Q,
        flowId: G,
        doc: X,
        lib: D,
        nodeLookup: z
      });
      te && ne && N(ne);
      const se = structuredClone(H);
      delete se.inProgress, se.toPosition = se.toHandle ? se.toHandle.position : null, K?.(V, se), v.setState({ connectionClickStartHandle: null });
    };
    return S.jsx("div", { "data-handleid": y, "data-nodeid": x, "data-handlepos": t, "data-id": `${C}-${x}-${y}-${e}`, className: qn([
      "react-flow__handle",
      `react-flow__handle-${t}`,
      "nodrag",
      _,
      u,
      {
        source: !b,
        target: b,
        connectable: r,
        connectablestart: o,
        connectableend: i,
        clickconnecting: O,
        connectingfrom: k,
        connectingto: A,
        valid: L,
        /*
         * shows where you can start a connection from
         * and where you can end it while connecting
         */
        connectionindicator: r && (!I || P) && (I || $ ? i : o)
      }
    ]), onMouseDown: U, onTouchStart: U, onClick: E ? j : void 0, ref: g, ...m, children: c });
  }
  const fh = T.memo(ZB(Jye));
  function eve({ data: e, isConnectable: t, sourcePosition: n = Ve.Bottom }) {
    return S.jsxs(S.Fragment, { children: [e?.label, S.jsx(fh, { type: "source", position: n, isConnectable: t })] });
  }
  function tve({ data: e, isConnectable: t, targetPosition: n = Ve.Top, sourcePosition: r = Ve.Bottom }) {
    return S.jsxs(S.Fragment, { children: [S.jsx(fh, { type: "target", position: n, isConnectable: t }), e?.label, S.jsx(fh, { type: "source", position: r, isConnectable: t })] });
  }
  function nve() {
    return null;
  }
  function rve({ data: e, isConnectable: t, targetPosition: n = Ve.Top }) {
    return S.jsxs(S.Fragment, { children: [S.jsx(fh, { type: "target", position: n, isConnectable: t }), e?.label] });
  }
  const M0 = {
    ArrowUp: { x: 0, y: -1 },
    ArrowDown: { x: 0, y: 1 },
    ArrowLeft: { x: -1, y: 0 },
    ArrowRight: { x: 1, y: 0 }
  }, mj = {
    input: eve,
    default: tve,
    output: rve,
    group: nve
  };
  function ove(e) {
    return e.internals.handleBounds === void 0 ? {
      width: e.width ?? e.initialWidth ?? e.style?.width,
      height: e.height ?? e.initialHeight ?? e.style?.height
    } : {
      width: e.width ?? e.style?.width,
      height: e.height ?? e.style?.height
    };
  }
  const ive = (e) => {
    const { width: t, height: n, x: r, y: o } = tm(e.nodeLookup, {
      filter: (i) => !!i.selected
    });
    return {
      width: Xo(t) ? t : null,
      height: Xo(n) ? n : null,
      userSelectionActive: e.userSelectionActive,
      transformString: `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]}) translate(${r}px,${o}px)`
    };
  };
  function ave({ onSelectionContextMenu: e, noPanClassName: t, disableKeyboardA11y: n }) {
    const r = Cn(), { width: o, height: i, transformString: a, userSelectionActive: s } = It(ive, _n), c = e8(), u = T.useRef(null);
    if (T.useEffect(() => {
      n || u.current?.focus({
        preventScroll: !0
      });
    }, [n]), JB({
      nodeRef: u
    }), s || !o || !i)
      return null;
    const d = e ? (m) => {
      const g = r.getState().nodes.filter((y) => y.selected);
      e(m, g);
    } : void 0, p = (m) => {
      Object.prototype.hasOwnProperty.call(M0, m.key) && (m.preventDefault(), c({
        direction: M0[m.key],
        factor: m.shiftKey ? 4 : 1
      }));
    };
    return S.jsx("div", { className: qn(["react-flow__nodesselection", "react-flow__container", t]), style: {
      transform: a
    }, children: S.jsx("div", { ref: u, className: "react-flow__nodesselection-rect", onContextMenu: d, tabIndex: n ? void 0 : -1, onKeyDown: n ? void 0 : p, style: {
      width: o,
      height: i
    } }) });
  }
  const gj = typeof window < "u" ? window : void 0, sve = (e) => ({ nodesSelectionActive: e.nodesSelectionActive, userSelectionActive: e.userSelectionActive });
  function n8({ children: e, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: o, onPaneContextMenu: i, onPaneScroll: a, paneClickDistance: s, deleteKeyCode: c, selectionKeyCode: u, selectionOnDrag: d, selectionMode: p, onSelectionStart: m, onSelectionEnd: g, multiSelectionKeyCode: y, panActivationKeyCode: b, zoomActivationKeyCode: v, elementsSelectable: x, zoomOnScroll: E, zoomOnPinch: _, panOnScroll: C, panOnScrollSpeed: k, panOnScrollMode: A, zoomOnDoubleClick: O, panOnDrag: P, defaultViewport: I, translateExtent: $, minZoom: L, maxZoom: N, preventScrolling: U, onSelectionContextMenu: j, noWheelClassName: V, noPanClassName: F, disableKeyboardA11y: K, onViewportChange: W, isControlledViewport: Y }) {
    const { nodesSelectionActive: B, userSelectionActive: D } = It(sve, _n), G = Fa(u, { target: gj }), z = Fa(b, { target: gj }), H = z || P, X = z || C, Q = d && H !== !0, ne = G || D || Q;
    return Bye({ deleteKeyCode: c, multiSelectionKeyCode: y }), S.jsx(Hye, { onPaneContextMenu: i, elementsSelectable: x, zoomOnScroll: E, zoomOnPinch: _, panOnScroll: X, panOnScrollSpeed: k, panOnScrollMode: A, zoomOnDoubleClick: O, panOnDrag: !G && H, defaultViewport: I, translateExtent: $, minZoom: L, maxZoom: N, zoomActivationKeyCode: v, preventScrolling: U, noWheelClassName: V, noPanClassName: F, onViewportChange: W, isControlledViewport: Y, paneClickDistance: s, selectionOnDrag: Q, children: S.jsxs(Kye, { onSelectionStart: m, onSelectionEnd: g, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: o, onPaneContextMenu: i, onPaneScroll: a, panOnDrag: H, isSelecting: !!ne, selectionMode: p, selectionKeyPressed: G, paneClickDistance: s, selectionOnDrag: Q, children: [e, B && S.jsx(ave, { onSelectionContextMenu: j, noPanClassName: F, disableKeyboardA11y: K })] }) });
  }
  n8.displayName = "FlowRenderer";
  const lve = T.memo(n8), cve = (e) => (t) => e ? MT(t.nodeLookup, { x: 0, y: 0, width: t.width, height: t.height }, t.transform, !0).map((n) => n.id) : Array.from(t.nodeLookup.keys());
  function uve(e) {
    return It(T.useCallback(cve(e), [e]), _n);
  }
  const fve = (e) => e.updateNodeInternals;
  function dve() {
    const e = It(fve), [t] = T.useState(() => typeof ResizeObserver > "u" ? null : new ResizeObserver((n) => {
      const r = /* @__PURE__ */ new Map();
      n.forEach((o) => {
        const i = o.target.getAttribute("data-id");
        r.set(i, {
          id: i,
          nodeElement: o.target,
          force: !0
        });
      }), e(r);
    }));
    return T.useEffect(() => () => {
      t?.disconnect();
    }, [t]), t;
  }
  function pve({ node: e, nodeType: t, hasDimensions: n, resizeObserver: r }) {
    const o = Cn(), i = T.useRef(null), a = T.useRef(null), s = T.useRef(e.sourcePosition), c = T.useRef(e.targetPosition), u = T.useRef(t), d = n && !!e.internals.handleBounds;
    return T.useEffect(() => {
      i.current && !e.hidden && (!d || a.current !== i.current) && (a.current && r?.unobserve(a.current), r?.observe(i.current), a.current = i.current);
    }, [d, e.hidden]), T.useEffect(() => () => {
      a.current && (r?.unobserve(a.current), a.current = null);
    }, []), T.useEffect(() => {
      if (i.current) {
        const p = u.current !== t, m = s.current !== e.sourcePosition, g = c.current !== e.targetPosition;
        (p || m || g) && (u.current = t, s.current = e.sourcePosition, c.current = e.targetPosition, o.getState().updateNodeInternals(/* @__PURE__ */ new Map([[e.id, { id: e.id, nodeElement: i.current, force: !0 }]])));
      }
    }, [e.id, t, e.sourcePosition, e.targetPosition]), i;
  }
  function hve({ id: e, onClick: t, onMouseEnter: n, onMouseMove: r, onMouseLeave: o, onContextMenu: i, onDoubleClick: a, nodesDraggable: s, elementsSelectable: c, nodesConnectable: u, nodesFocusable: d, resizeObserver: p, noDragClassName: m, noPanClassName: g, disableKeyboardA11y: y, rfId: b, nodeTypes: v, nodeClickDistance: x, onError: E }) {
    const { node: _, internals: C, isParent: k } = It((te) => {
      const se = te.nodeLookup.get(e), ue = te.parentLookup.has(e);
      return {
        node: se,
        internals: se.internals,
        isParent: ue
      };
    }, _n);
    let A = _.type || "default", O = v?.[A] || mj[A];
    O === void 0 && (E?.("003", Gi.error003(A)), A = "default", O = v?.default || mj.default);
    const P = !!(_.draggable || s && typeof _.draggable > "u"), I = !!(_.selectable || c && typeof _.selectable > "u"), $ = !!(_.connectable || u && typeof _.connectable > "u"), L = !!(_.focusable || d && typeof _.focusable > "u"), N = Cn(), U = CB(_), j = pve({ node: _, nodeType: A, hasDimensions: U, resizeObserver: p }), V = JB({
      nodeRef: j,
      disabled: _.hidden || !P,
      noDragClassName: m,
      handleSelector: _.dragHandle,
      nodeId: e,
      isSelectable: I,
      nodeClickDistance: x
    }), F = e8();
    if (_.hidden)
      return null;
    const K = ns(_), W = ove(_), Y = I || P || t || n || r || o, B = n ? (te) => n(te, { ...C.userNode }) : void 0, D = r ? (te) => r(te, { ...C.userNode }) : void 0, G = o ? (te) => o(te, { ...C.userNode }) : void 0, z = i ? (te) => i(te, { ...C.userNode }) : void 0, H = a ? (te) => a(te, { ...C.userNode }) : void 0, X = (te) => {
      const { selectNodesOnDrag: se, nodeDragThreshold: ue } = N.getState();
      I && (!se || !P || ue > 0) && yC({
        id: e,
        store: N,
        nodeRef: j
      }), t && t(te, { ...C.userNode });
    }, Q = (te) => {
      if (!(AB(te.nativeEvent) || y)) {
        if (gB.includes(te.key) && I) {
          const se = te.key === "Escape";
          yC({
            id: e,
            store: N,
            unselect: se,
            nodeRef: j
          });
        } else if (P && _.selected && Object.prototype.hasOwnProperty.call(M0, te.key)) {
          te.preventDefault();
          const { ariaLabelConfig: se } = N.getState();
          N.setState({
            ariaLiveMessage: se["node.a11yDescription.ariaLiveMessage"]({
              direction: te.key.replace("Arrow", "").toLowerCase(),
              x: ~~C.positionAbsolute.x,
              y: ~~C.positionAbsolute.y
            })
          }), F({
            direction: M0[te.key],
            factor: te.shiftKey ? 4 : 1
          });
        }
      }
    }, ne = () => {
      if (y || !j.current?.matches(":focus-visible"))
        return;
      const { transform: te, width: se, height: ue, autoPanOnNodeFocus: J, setCenter: ee } = N.getState();
      if (!J)
        return;
      MT(/* @__PURE__ */ new Map([[e, _]]), { x: 0, y: 0, width: se, height: ue }, te, !0).length > 0 || ee(_.position.x + K.width / 2, _.position.y + K.height / 2, {
        zoom: te[2]
      });
    };
    return S.jsx("div", { className: qn([
      "react-flow__node",
      `react-flow__node-${A}`,
      {
        // this is overwritable by passing `nopan` as a class name
        [g]: P
      },
      _.className,
      {
        selected: _.selected,
        selectable: I,
        parent: k,
        draggable: P,
        dragging: V
      }
    ]), ref: j, style: {
      zIndex: C.z,
      transform: `translate(${C.positionAbsolute.x}px,${C.positionAbsolute.y}px)`,
      pointerEvents: Y ? "all" : "none",
      visibility: U ? "visible" : "hidden",
      ..._.style,
      ...W
    }, "data-id": e, "data-testid": `rf__node-${e}`, onMouseEnter: B, onMouseMove: D, onMouseLeave: G, onContextMenu: z, onClick: X, onDoubleClick: H, onKeyDown: L ? Q : void 0, tabIndex: L ? 0 : void 0, onFocus: L ? ne : void 0, role: _.ariaRole ?? (L ? "group" : void 0), "aria-roledescription": "node", "aria-describedby": y ? void 0 : `${WB}-${b}`, "aria-label": _.ariaLabel, ..._.domAttributes, children: S.jsx(Xye, { value: e, children: S.jsx(O, { id: e, data: _.data, type: A, positionAbsoluteX: C.positionAbsolute.x, positionAbsoluteY: C.positionAbsolute.y, selected: _.selected ?? !1, selectable: I, draggable: P, deletable: _.deletable ?? !0, isConnectable: $, sourcePosition: _.sourcePosition, targetPosition: _.targetPosition, dragging: V, dragHandle: _.dragHandle, zIndex: C.z, parentId: _.parentId, ...K }) }) });
  }
  var mve = T.memo(hve);
  const gve = (e) => ({
    nodesDraggable: e.nodesDraggable,
    nodesConnectable: e.nodesConnectable,
    nodesFocusable: e.nodesFocusable,
    elementsSelectable: e.elementsSelectable,
    onError: e.onError
  });
  function r8(e) {
    const { nodesDraggable: t, nodesConnectable: n, nodesFocusable: r, elementsSelectable: o, onError: i } = It(gve, _n), a = uve(e.onlyRenderVisibleElements), s = dve();
    return S.jsx("div", { className: "react-flow__nodes", style: r1, children: a.map((c) => (
      /*
       * The split of responsibilities between NodeRenderer and
       * NodeComponentWrapper may appear weird. However, its designed to
       * minimize the cost of updates when individual nodes change.
       *
       * For example, when youre dragging a single node, that node gets
       * updated multiple times per second. If `NodeRenderer` were to update
       * every time, it would have to re-run the `nodes.map()` loop every
       * time. This gets pricey with hundreds of nodes, especially if every
       * loop cycle does more than just rendering a JSX element!
       *
       * As a result of this choice, we took the following implementation
       * decisions:
       * - NodeRenderer subscribes *only* to node IDs  and therefore
       *   rerender *only* when visible nodes are added or removed.
       * - NodeRenderer performs all operations the result of which can be
       *   shared between nodes (such as creating the `ResizeObserver`
       *   instance, or subscribing to `selector`). This means extra prop
       *   drilling into `NodeComponentWrapper`, but it means we need to run
       *   these operations only once  instead of once per node.
       * - Any operations that youd normally write inside `nodes.map` are
       *   moved into `NodeComponentWrapper`. This ensures they are
       *   memorized  so if `NodeRenderer` *has* to rerender, it only
       *   needs to regenerate the list of nodes, nothing else.
       */
      S.jsx(mve, { id: c, nodeTypes: e.nodeTypes, nodeExtent: e.nodeExtent, onClick: e.onNodeClick, onMouseEnter: e.onNodeMouseEnter, onMouseMove: e.onNodeMouseMove, onMouseLeave: e.onNodeMouseLeave, onContextMenu: e.onNodeContextMenu, onDoubleClick: e.onNodeDoubleClick, noDragClassName: e.noDragClassName, noPanClassName: e.noPanClassName, rfId: e.rfId, disableKeyboardA11y: e.disableKeyboardA11y, resizeObserver: s, nodesDraggable: t, nodesConnectable: n, nodesFocusable: r, elementsSelectable: o, nodeClickDistance: e.nodeClickDistance, onError: i }, c)
    )) });
  }
  r8.displayName = "NodeRenderer";
  const yve = T.memo(r8);
  function vve(e) {
    return It(T.useCallback((n) => {
      if (!e)
        return n.edges.map((o) => o.id);
      const r = [];
      if (n.width && n.height)
        for (const o of n.edges) {
          const i = n.nodeLookup.get(o.source), a = n.nodeLookup.get(o.target);
          i && a && Ege({
            sourceNode: i,
            targetNode: a,
            width: n.width,
            height: n.height,
            transform: n.transform
          }) && r.push(o.id);
        }
      return r;
    }, [e]), _n);
  }
  const bve = ({ color: e = "none", strokeWidth: t = 1 }) => {
    const n = {
      strokeWidth: t,
      ...e && { stroke: e }
    };
    return S.jsx("polyline", { className: "arrow", style: n, strokeLinecap: "round", fill: "none", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4" });
  }, xve = ({ color: e = "none", strokeWidth: t = 1 }) => {
    const n = {
      strokeWidth: t,
      ...e && { stroke: e, fill: e }
    };
    return S.jsx("polyline", { className: "arrowclosed", style: n, strokeLinecap: "round", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4 -5,-4" });
  }, yj = {
    [A0.Arrow]: bve,
    [A0.ArrowClosed]: xve
  };
  function wve(e) {
    const t = Cn();
    return T.useMemo(() => Object.prototype.hasOwnProperty.call(yj, e) ? yj[e] : (t.getState().onError?.("009", Gi.error009(e)), null), [e]);
  }
  const Sve = ({ id: e, type: t, color: n, width: r = 12.5, height: o = 12.5, markerUnits: i = "strokeWidth", strokeWidth: a, orient: s = "auto-start-reverse" }) => {
    const c = wve(t);
    return c ? S.jsx("marker", { className: "react-flow__arrowhead", id: e, markerWidth: `${r}`, markerHeight: `${o}`, viewBox: "-10 -10 20 20", markerUnits: i, orient: s, refX: "0", refY: "0", children: S.jsx(c, { color: n, strokeWidth: a }) }) : null;
  }, o8 = ({ defaultColor: e, rfId: t }) => {
    const n = It((i) => i.edges), r = It((i) => i.defaultEdgeOptions), o = T.useMemo(() => Nge(n, {
      id: t,
      defaultColor: e,
      defaultMarkerStart: r?.markerStart,
      defaultMarkerEnd: r?.markerEnd
    }), [n, r, t, e]);
    return o.length ? S.jsx("svg", { className: "react-flow__marker", "aria-hidden": "true", children: S.jsx("defs", { children: o.map((i) => S.jsx(Sve, { id: i.id, type: i.type, color: i.color, width: i.width, height: i.height, markerUnits: i.markerUnits, strokeWidth: i.strokeWidth, orient: i.orient }, i.id)) }) }) : null;
  };
  o8.displayName = "MarkerDefinitions";
  var _ve = T.memo(o8);
  function i8({ x: e, y: t, label: n, labelStyle: r, labelShowBg: o = !0, labelBgStyle: i, labelBgPadding: a = [2, 4], labelBgBorderRadius: s = 2, children: c, className: u, ...d }) {
    const [p, m] = T.useState({ x: 1, y: 0, width: 0, height: 0 }), g = qn(["react-flow__edge-textwrapper", u]), y = T.useRef(null);
    return T.useEffect(() => {
      if (y.current) {
        const b = y.current.getBBox();
        m({
          x: b.x,
          y: b.y,
          width: b.width,
          height: b.height
        });
      }
    }, [n]), n ? S.jsxs("g", { transform: `translate(${e - p.width / 2} ${t - p.height / 2})`, className: g, visibility: p.width ? "visible" : "hidden", ...d, children: [o && S.jsx("rect", { width: p.width + 2 * a[0], x: -a[0], y: -a[1], height: p.height + 2 * a[1], className: "react-flow__edge-textbg", style: i, rx: s, ry: s }), S.jsx("text", { className: "react-flow__edge-text", y: p.height / 2, dy: "0.3em", ref: y, style: r, children: n }), c] }) : null;
  }
  i8.displayName = "EdgeText";
  const Eve = T.memo(i8);
  function om({ path: e, labelX: t, labelY: n, label: r, labelStyle: o, labelShowBg: i, labelBgStyle: a, labelBgPadding: s, labelBgBorderRadius: c, interactionWidth: u = 20, ...d }) {
    return S.jsxs(S.Fragment, { children: [S.jsx("path", { ...d, d: e, fill: "none", className: qn(["react-flow__edge-path", d.className]) }), u ? S.jsx("path", { d: e, fill: "none", strokeOpacity: 0, strokeWidth: u, className: "react-flow__edge-interaction" }) : null, r && Xo(t) && Xo(n) ? S.jsx(Eve, { x: t, y: n, label: r, labelStyle: o, labelShowBg: i, labelBgStyle: a, labelBgPadding: s, labelBgBorderRadius: c }) : null] });
  }
  function vj({ pos: e, x1: t, y1: n, x2: r, y2: o }) {
    return e === Ve.Left || e === Ve.Right ? [0.5 * (t + r), n] : [t, 0.5 * (n + o)];
  }
  function a8({ sourceX: e, sourceY: t, sourcePosition: n = Ve.Bottom, targetX: r, targetY: o, targetPosition: i = Ve.Top }) {
    const [a, s] = vj({
      pos: n,
      x1: e,
      y1: t,
      x2: r,
      y2: o
    }), [c, u] = vj({
      pos: i,
      x1: r,
      y1: o,
      x2: e,
      y2: t
    }), [d, p, m, g] = OB({
      sourceX: e,
      sourceY: t,
      targetX: r,
      targetY: o,
      sourceControlX: a,
      sourceControlY: s,
      targetControlX: c,
      targetControlY: u
    });
    return [
      `M${e},${t} C${a},${s} ${c},${u} ${r},${o}`,
      d,
      p,
      m,
      g
    ];
  }
  function s8(e) {
    return T.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: i, sourcePosition: a, targetPosition: s, label: c, labelStyle: u, labelShowBg: d, labelBgStyle: p, labelBgPadding: m, labelBgBorderRadius: g, style: y, markerEnd: b, markerStart: v, interactionWidth: x }) => {
      const [E, _, C] = a8({
        sourceX: n,
        sourceY: r,
        sourcePosition: a,
        targetX: o,
        targetY: i,
        targetPosition: s
      }), k = e.isInternal ? void 0 : t;
      return S.jsx(om, { id: k, path: E, labelX: _, labelY: C, label: c, labelStyle: u, labelShowBg: d, labelBgStyle: p, labelBgPadding: m, labelBgBorderRadius: g, style: y, markerEnd: b, markerStart: v, interactionWidth: x });
    });
  }
  const Cve = s8({ isInternal: !1 }), l8 = s8({ isInternal: !0 });
  Cve.displayName = "SimpleBezierEdge";
  l8.displayName = "SimpleBezierEdgeInternal";
  function c8(e) {
    return T.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: i, label: a, labelStyle: s, labelShowBg: c, labelBgStyle: u, labelBgPadding: d, labelBgBorderRadius: p, style: m, sourcePosition: g = Ve.Bottom, targetPosition: y = Ve.Top, markerEnd: b, markerStart: v, pathOptions: x, interactionWidth: E }) => {
      const [_, C, k] = pC({
        sourceX: n,
        sourceY: r,
        sourcePosition: g,
        targetX: o,
        targetY: i,
        targetPosition: y,
        borderRadius: x?.borderRadius,
        offset: x?.offset,
        stepPosition: x?.stepPosition
      }), A = e.isInternal ? void 0 : t;
      return S.jsx(om, { id: A, path: _, labelX: C, labelY: k, label: a, labelStyle: s, labelShowBg: c, labelBgStyle: u, labelBgPadding: d, labelBgBorderRadius: p, style: m, markerEnd: b, markerStart: v, interactionWidth: E });
    });
  }
  const u8 = c8({ isInternal: !1 }), f8 = c8({ isInternal: !0 });
  u8.displayName = "SmoothStepEdge";
  f8.displayName = "SmoothStepEdgeInternal";
  function d8(e) {
    return T.memo(({ id: t, ...n }) => {
      const r = e.isInternal ? void 0 : t;
      return S.jsx(u8, { ...n, id: r, pathOptions: T.useMemo(() => ({ borderRadius: 0, offset: n.pathOptions?.offset }), [n.pathOptions?.offset]) });
    });
  }
  const kve = d8({ isInternal: !1 }), p8 = d8({ isInternal: !0 });
  kve.displayName = "StepEdge";
  p8.displayName = "StepEdgeInternal";
  function h8(e) {
    return T.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: i, label: a, labelStyle: s, labelShowBg: c, labelBgStyle: u, labelBgPadding: d, labelBgBorderRadius: p, style: m, markerEnd: g, markerStart: y, interactionWidth: b }) => {
      const [v, x, E] = NB({ sourceX: n, sourceY: r, targetX: o, targetY: i }), _ = e.isInternal ? void 0 : t;
      return S.jsx(om, { id: _, path: v, labelX: x, labelY: E, label: a, labelStyle: s, labelShowBg: c, labelBgStyle: u, labelBgPadding: d, labelBgBorderRadius: p, style: m, markerEnd: g, markerStart: y, interactionWidth: b });
    });
  }
  const Tve = h8({ isInternal: !1 }), m8 = h8({ isInternal: !0 });
  Tve.displayName = "StraightEdge";
  m8.displayName = "StraightEdgeInternal";
  function g8(e) {
    return T.memo(({ id: t, sourceX: n, sourceY: r, targetX: o, targetY: i, sourcePosition: a = Ve.Bottom, targetPosition: s = Ve.Top, label: c, labelStyle: u, labelShowBg: d, labelBgStyle: p, labelBgPadding: m, labelBgBorderRadius: g, style: y, markerEnd: b, markerStart: v, pathOptions: x, interactionWidth: E }) => {
      const [_, C, k] = IT({
        sourceX: n,
        sourceY: r,
        sourcePosition: a,
        targetX: o,
        targetY: i,
        targetPosition: s,
        curvature: x?.curvature
      }), A = e.isInternal ? void 0 : t;
      return S.jsx(om, { id: A, path: _, labelX: C, labelY: k, label: c, labelStyle: u, labelShowBg: d, labelBgStyle: p, labelBgPadding: m, labelBgBorderRadius: g, style: y, markerEnd: b, markerStart: v, interactionWidth: E });
    });
  }
  const Ave = g8({ isInternal: !1 }), y8 = g8({ isInternal: !0 });
  Ave.displayName = "BezierEdge";
  y8.displayName = "BezierEdgeInternal";
  const bj = {
    default: y8,
    straight: m8,
    step: p8,
    smoothstep: f8,
    simplebezier: l8
  }, xj = {
    sourceX: null,
    sourceY: null,
    targetX: null,
    targetY: null,
    sourcePosition: null,
    targetPosition: null
  }, Rve = (e, t, n) => n === Ve.Left ? e - t : n === Ve.Right ? e + t : e, Ove = (e, t, n) => n === Ve.Top ? e - t : n === Ve.Bottom ? e + t : e, wj = "react-flow__edgeupdater";
  function Sj({ position: e, centerX: t, centerY: n, radius: r = 10, onMouseDown: o, onMouseEnter: i, onMouseOut: a, type: s }) {
    return S.jsx("circle", { onMouseDown: o, onMouseEnter: i, onMouseOut: a, className: qn([wj, `${wj}-${s}`]), cx: Rve(t, r, e), cy: Ove(n, r, e), r, stroke: "transparent", fill: "transparent" });
  }
  function Mve({ isReconnectable: e, reconnectRadius: t, edge: n, sourceX: r, sourceY: o, targetX: i, targetY: a, sourcePosition: s, targetPosition: c, onReconnect: u, onReconnectStart: d, onReconnectEnd: p, setReconnecting: m, setUpdateHover: g }) {
    const y = Cn(), b = (C, k) => {
      if (C.button !== 0)
        return;
      const { autoPanOnConnect: A, domNode: O, isValidConnection: P, connectionMode: I, connectionRadius: $, lib: L, onConnectStart: N, onConnectEnd: U, cancelConnection: j, nodeLookup: V, rfId: F, panBy: K, updateConnection: W } = y.getState(), Y = k.type === "target", B = (z, H) => {
        m(!1), p?.(z, n, k.type, H);
      }, D = (z) => u?.(n, z), G = (z, H) => {
        m(!0), d?.(C, n, k.type), N?.(z, H);
      };
      gC.onPointerDown(C.nativeEvent, {
        autoPanOnConnect: A,
        connectionMode: I,
        connectionRadius: $,
        domNode: O,
        handleId: k.id,
        nodeId: k.nodeId,
        nodeLookup: V,
        isTarget: Y,
        edgeUpdaterType: k.type,
        lib: L,
        flowId: F,
        cancelConnection: j,
        panBy: K,
        isValidConnection: P,
        onConnect: D,
        onConnectStart: G,
        onConnectEnd: U,
        onReconnectEnd: B,
        updateConnection: W,
        getTransform: () => y.getState().transform,
        getFromHandle: () => y.getState().connection.fromHandle,
        dragThreshold: y.getState().connectionDragThreshold,
        handleDomNode: C.currentTarget
      });
    }, v = (C) => b(C, { nodeId: n.target, id: n.targetHandle ?? null, type: "target" }), x = (C) => b(C, { nodeId: n.source, id: n.sourceHandle ?? null, type: "source" }), E = () => g(!0), _ = () => g(!1);
    return S.jsxs(S.Fragment, { children: [(e === !0 || e === "source") && S.jsx(Sj, { position: s, centerX: r, centerY: o, radius: t, onMouseDown: v, onMouseEnter: E, onMouseOut: _, type: "source" }), (e === !0 || e === "target") && S.jsx(Sj, { position: c, centerX: i, centerY: a, radius: t, onMouseDown: x, onMouseEnter: E, onMouseOut: _, type: "target" })] });
  }
  function Nve({ id: e, edgesFocusable: t, edgesReconnectable: n, elementsSelectable: r, onClick: o, onDoubleClick: i, onContextMenu: a, onMouseEnter: s, onMouseMove: c, onMouseLeave: u, reconnectRadius: d, onReconnect: p, onReconnectStart: m, onReconnectEnd: g, rfId: y, edgeTypes: b, noPanClassName: v, onError: x, disableKeyboardA11y: E }) {
    let _ = It((ee) => ee.edgeLookup.get(e));
    const C = It((ee) => ee.defaultEdgeOptions);
    _ = C ? { ...C, ..._ } : _;
    let k = _.type || "default", A = b?.[k] || bj[k];
    A === void 0 && (x?.("011", Gi.error011(k)), k = "default", A = b?.default || bj.default);
    const O = !!(_.focusable || t && typeof _.focusable > "u"), P = typeof p < "u" && (_.reconnectable || n && typeof _.reconnectable > "u"), I = !!(_.selectable || r && typeof _.selectable > "u"), $ = T.useRef(null), [L, N] = T.useState(!1), [U, j] = T.useState(!1), V = Cn(), { zIndex: F, sourceX: K, sourceY: W, targetX: Y, targetY: B, sourcePosition: D, targetPosition: G } = It(T.useCallback((ee) => {
      const ie = ee.nodeLookup.get(_.source), le = ee.nodeLookup.get(_.target);
      if (!ie || !le)
        return {
          zIndex: _.zIndex,
          ...xj
        };
      const ge = Mge({
        id: e,
        sourceNode: ie,
        targetNode: le,
        sourceHandle: _.sourceHandle || null,
        targetHandle: _.targetHandle || null,
        connectionMode: ee.connectionMode,
        onError: x
      });
      return {
        zIndex: _ge({
          selected: _.selected,
          zIndex: _.zIndex,
          sourceNode: ie,
          targetNode: le,
          elevateOnSelect: ee.elevateEdgesOnSelect,
          zIndexMode: ee.zIndexMode
        }),
        ...ge || xj
      };
    }, [_.source, _.target, _.sourceHandle, _.targetHandle, _.selected, _.zIndex]), _n), z = T.useMemo(() => _.markerStart ? `url('#${hC(_.markerStart, y)}')` : void 0, [_.markerStart, y]), H = T.useMemo(() => _.markerEnd ? `url('#${hC(_.markerEnd, y)}')` : void 0, [_.markerEnd, y]);
    if (_.hidden || K === null || W === null || Y === null || B === null)
      return null;
    const X = (ee) => {
      const { addSelectedEdges: ie, unselectNodesAndEdges: le, multiSelectionActive: ge } = V.getState();
      I && (V.setState({ nodesSelectionActive: !1 }), _.selected && ge ? (le({ nodes: [], edges: [_] }), $.current?.blur()) : ie([e])), o && o(ee, _);
    }, Q = i ? (ee) => {
      i(ee, { ..._ });
    } : void 0, ne = a ? (ee) => {
      a(ee, { ..._ });
    } : void 0, te = s ? (ee) => {
      s(ee, { ..._ });
    } : void 0, se = c ? (ee) => {
      c(ee, { ..._ });
    } : void 0, ue = u ? (ee) => {
      u(ee, { ..._ });
    } : void 0, J = (ee) => {
      if (!E && gB.includes(ee.key) && I) {
        const { unselectNodesAndEdges: ie, addSelectedEdges: le } = V.getState();
        ee.key === "Escape" ? ($.current?.blur(), ie({ edges: [_] })) : le([e]);
      }
    };
    return S.jsx("svg", { style: { zIndex: F }, children: S.jsxs("g", { className: qn([
      "react-flow__edge",
      `react-flow__edge-${k}`,
      _.className,
      v,
      {
        selected: _.selected,
        animated: _.animated,
        inactive: !I && !o,
        updating: L,
        selectable: I
      }
    ]), onClick: X, onDoubleClick: Q, onContextMenu: ne, onMouseEnter: te, onMouseMove: se, onMouseLeave: ue, onKeyDown: O ? J : void 0, tabIndex: O ? 0 : void 0, role: _.ariaRole ?? (O ? "group" : "img"), "aria-roledescription": "edge", "data-id": e, "data-testid": `rf__edge-${e}`, "aria-label": _.ariaLabel === null ? void 0 : _.ariaLabel || `Edge from ${_.source} to ${_.target}`, "aria-describedby": O ? `${GB}-${y}` : void 0, ref: $, ..._.domAttributes, children: [!U && S.jsx(A, { id: e, source: _.source, target: _.target, type: _.type, selected: _.selected, animated: _.animated, selectable: I, deletable: _.deletable ?? !0, label: _.label, labelStyle: _.labelStyle, labelShowBg: _.labelShowBg, labelBgStyle: _.labelBgStyle, labelBgPadding: _.labelBgPadding, labelBgBorderRadius: _.labelBgBorderRadius, sourceX: K, sourceY: W, targetX: Y, targetY: B, sourcePosition: D, targetPosition: G, data: _.data, style: _.style, sourceHandleId: _.sourceHandle, targetHandleId: _.targetHandle, markerStart: z, markerEnd: H, pathOptions: "pathOptions" in _ ? _.pathOptions : void 0, interactionWidth: _.interactionWidth }), P && S.jsx(Mve, { edge: _, isReconnectable: P, reconnectRadius: d, onReconnect: p, onReconnectStart: m, onReconnectEnd: g, sourceX: K, sourceY: W, targetX: Y, targetY: B, sourcePosition: D, targetPosition: G, setUpdateHover: N, setReconnecting: j })] }) });
  }
  var Pve = T.memo(Nve);
  const Ive = (e) => ({
    edgesFocusable: e.edgesFocusable,
    edgesReconnectable: e.edgesReconnectable,
    elementsSelectable: e.elementsSelectable,
    connectionMode: e.connectionMode,
    onError: e.onError
  });
  function v8({ defaultMarkerColor: e, onlyRenderVisibleElements: t, rfId: n, edgeTypes: r, noPanClassName: o, onReconnect: i, onEdgeContextMenu: a, onEdgeMouseEnter: s, onEdgeMouseMove: c, onEdgeMouseLeave: u, onEdgeClick: d, reconnectRadius: p, onEdgeDoubleClick: m, onReconnectStart: g, onReconnectEnd: y, disableKeyboardA11y: b }) {
    const { edgesFocusable: v, edgesReconnectable: x, elementsSelectable: E, onError: _ } = It(Ive, _n), C = vve(t);
    return S.jsxs("div", { className: "react-flow__edges", children: [S.jsx(_ve, { defaultColor: e, rfId: n }), C.map((k) => S.jsx(Pve, { id: k, edgesFocusable: v, edgesReconnectable: x, elementsSelectable: E, noPanClassName: o, onReconnect: i, onContextMenu: a, onMouseEnter: s, onMouseMove: c, onMouseLeave: u, onClick: d, reconnectRadius: p, onDoubleClick: m, onReconnectStart: g, onReconnectEnd: y, rfId: n, onError: _, edgeTypes: r, disableKeyboardA11y: b }, k))] });
  }
  v8.displayName = "EdgeRenderer";
  const $ve = T.memo(v8), jve = (e) => `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]})`;
  function Dve({ children: e }) {
    const t = It(jve);
    return S.jsx("div", { className: "react-flow__viewport xyflow__viewport react-flow__container", style: { transform: t }, children: e });
  }
  function Fve(e) {
    const t = Ec(), n = T.useRef(!1);
    T.useEffect(() => {
      !n.current && t.viewportInitialized && e && (setTimeout(() => e(t), 1), n.current = !0);
    }, [e, t.viewportInitialized]);
  }
  const Lve = (e) => e.panZoom?.syncViewport;
  function zve(e) {
    const t = It(Lve), n = Cn();
    return T.useEffect(() => {
      e && (t?.(e), n.setState({ transform: [e.x, e.y, e.zoom] }));
    }, [e, t]), null;
  }
  function Bve(e) {
    return e.connection.inProgress ? { ...e.connection, to: rm(e.connection.to, e.transform) } : { ...e.connection };
  }
  function Uve(e) {
    return Bve;
  }
  function Vve(e) {
    const t = Uve();
    return It(t, _n);
  }
  const Hve = (e) => ({
    nodesConnectable: e.nodesConnectable,
    isValid: e.connection.isValid,
    inProgress: e.connection.inProgress,
    width: e.width,
    height: e.height
  });
  function qve({ containerStyle: e, style: t, type: n, component: r }) {
    const { nodesConnectable: o, width: i, height: a, isValid: s, inProgress: c } = It(Hve, _n);
    return !(i && o && c) ? null : S.jsx("svg", { style: e, width: i, height: a, className: "react-flow__connectionline react-flow__container", children: S.jsx("g", { className: qn(["react-flow__connection", bB(s)]), children: S.jsx(b8, { style: t, type: n, CustomComponent: r, isValid: s }) }) });
  }
  const b8 = ({ style: e, type: t = qs.Bezier, CustomComponent: n, isValid: r }) => {
    const { inProgress: o, from: i, fromNode: a, fromHandle: s, fromPosition: c, to: u, toNode: d, toHandle: p, toPosition: m, pointer: g } = Vve();
    if (!o)
      return;
    if (n)
      return S.jsx(n, { connectionLineType: t, connectionLineStyle: e, fromNode: a, fromHandle: s, fromX: i.x, fromY: i.y, toX: u.x, toY: u.y, fromPosition: c, toPosition: m, connectionStatus: bB(r), toNode: d, toHandle: p, pointer: g });
    let y = "";
    const b = {
      sourceX: i.x,
      sourceY: i.y,
      sourcePosition: c,
      targetX: u.x,
      targetY: u.y,
      targetPosition: m
    };
    switch (t) {
      case qs.Bezier:
        [y] = IT(b);
        break;
      case qs.SimpleBezier:
        [y] = a8(b);
        break;
      case qs.Step:
        [y] = pC({
          ...b,
          borderRadius: 0
        });
        break;
      case qs.SmoothStep:
        [y] = pC(b);
        break;
      default:
        [y] = NB(b);
    }
    return S.jsx("path", { d: y, fill: "none", className: "react-flow__connection-path", style: e });
  };
  b8.displayName = "ConnectionLine";
  const Wve = {};
  function _j(e = Wve) {
    T.useRef(e), Cn(), T.useEffect(() => {
    }, [e]);
  }
  function Gve() {
    Cn(), T.useRef(!1), T.useEffect(() => {
    }, []);
  }
  function x8({ nodeTypes: e, edgeTypes: t, onInit: n, onNodeClick: r, onEdgeClick: o, onNodeDoubleClick: i, onEdgeDoubleClick: a, onNodeMouseEnter: s, onNodeMouseMove: c, onNodeMouseLeave: u, onNodeContextMenu: d, onSelectionContextMenu: p, onSelectionStart: m, onSelectionEnd: g, connectionLineType: y, connectionLineStyle: b, connectionLineComponent: v, connectionLineContainerStyle: x, selectionKeyCode: E, selectionOnDrag: _, selectionMode: C, multiSelectionKeyCode: k, panActivationKeyCode: A, zoomActivationKeyCode: O, deleteKeyCode: P, onlyRenderVisibleElements: I, elementsSelectable: $, defaultViewport: L, translateExtent: N, minZoom: U, maxZoom: j, preventScrolling: V, defaultMarkerColor: F, zoomOnScroll: K, zoomOnPinch: W, panOnScroll: Y, panOnScrollSpeed: B, panOnScrollMode: D, zoomOnDoubleClick: G, panOnDrag: z, onPaneClick: H, onPaneMouseEnter: X, onPaneMouseMove: Q, onPaneMouseLeave: ne, onPaneScroll: te, onPaneContextMenu: se, paneClickDistance: ue, nodeClickDistance: J, onEdgeContextMenu: ee, onEdgeMouseEnter: ie, onEdgeMouseMove: le, onEdgeMouseLeave: ge, reconnectRadius: Se, onReconnect: Me, onReconnectStart: je, onReconnectEnd: ze, noDragClassName: Ye, noWheelClassName: Ue, noPanClassName: Ne, disableKeyboardA11y: mt, nodeExtent: Je, rfId: Ae, viewport: oe, onViewportChange: fe }) {
    return _j(e), _j(t), Gve(), Fve(n), zve(oe), S.jsx(lve, { onPaneClick: H, onPaneMouseEnter: X, onPaneMouseMove: Q, onPaneMouseLeave: ne, onPaneContextMenu: se, onPaneScroll: te, paneClickDistance: ue, deleteKeyCode: P, selectionKeyCode: E, selectionOnDrag: _, selectionMode: C, onSelectionStart: m, onSelectionEnd: g, multiSelectionKeyCode: k, panActivationKeyCode: A, zoomActivationKeyCode: O, elementsSelectable: $, zoomOnScroll: K, zoomOnPinch: W, zoomOnDoubleClick: G, panOnScroll: Y, panOnScrollSpeed: B, panOnScrollMode: D, panOnDrag: z, defaultViewport: L, translateExtent: N, minZoom: U, maxZoom: j, onSelectionContextMenu: p, preventScrolling: V, noDragClassName: Ye, noWheelClassName: Ue, noPanClassName: Ne, disableKeyboardA11y: mt, onViewportChange: fe, isControlledViewport: !!oe, children: S.jsxs(Dve, { children: [S.jsx($ve, { edgeTypes: t, onEdgeClick: o, onEdgeDoubleClick: a, onReconnect: Me, onReconnectStart: je, onReconnectEnd: ze, onlyRenderVisibleElements: I, onEdgeContextMenu: ee, onEdgeMouseEnter: ie, onEdgeMouseMove: le, onEdgeMouseLeave: ge, reconnectRadius: Se, defaultMarkerColor: F, noPanClassName: Ne, disableKeyboardA11y: mt, rfId: Ae }), S.jsx(qve, { style: b, type: y, component: v, containerStyle: x }), S.jsx("div", { className: "react-flow__edgelabel-renderer" }), S.jsx(yve, { nodeTypes: e, onNodeClick: r, onNodeDoubleClick: i, onNodeMouseEnter: s, onNodeMouseMove: c, onNodeMouseLeave: u, onNodeContextMenu: d, nodeClickDistance: J, onlyRenderVisibleElements: I, noPanClassName: Ne, noDragClassName: Ye, disableKeyboardA11y: mt, nodeExtent: Je, rfId: Ae }), S.jsx("div", { className: "react-flow__viewport-portal" })] }) });
  }
  x8.displayName = "GraphView";
  const Kve = T.memo(x8), Ej = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, width: o, height: i, fitView: a, fitViewOptions: s, minZoom: c = 0.5, maxZoom: u = 2, nodeOrigin: d, nodeExtent: p, zIndexMode: m = "basic" } = {}) => {
    const g = /* @__PURE__ */ new Map(), y = /* @__PURE__ */ new Map(), b = /* @__PURE__ */ new Map(), v = /* @__PURE__ */ new Map(), x = r ?? t ?? [], E = n ?? e ?? [], _ = d ?? [0, 0], C = p ?? sh;
    $B(b, v, x);
    const k = mC(E, g, y, {
      nodeOrigin: _,
      nodeExtent: C,
      zIndexMode: m
    });
    let A = [0, 0, 1];
    if (a && o && i) {
      const O = tm(g, {
        filter: (L) => !!((L.width || L.initialWidth) && (L.height || L.initialHeight))
      }), { x: P, y: I, zoom: $ } = NT(O, o, i, c, u, s?.padding ?? 0.1);
      A = [P, I, $];
    }
    return {
      rfId: "1",
      width: o ?? 0,
      height: i ?? 0,
      transform: A,
      nodes: E,
      nodesInitialized: k,
      nodeLookup: g,
      parentLookup: y,
      edges: x,
      edgeLookup: v,
      connectionLookup: b,
      onNodesChange: null,
      onEdgesChange: null,
      hasDefaultNodes: n !== void 0,
      hasDefaultEdges: r !== void 0,
      panZoom: null,
      minZoom: c,
      maxZoom: u,
      translateExtent: sh,
      nodeExtent: C,
      nodesSelectionActive: !1,
      userSelectionActive: !1,
      userSelectionRect: null,
      connectionMode: xf.Strict,
      domNode: null,
      paneDragging: !1,
      noPanClassName: "nopan",
      nodeOrigin: _,
      nodeDragThreshold: 1,
      connectionDragThreshold: 1,
      snapGrid: [15, 15],
      snapToGrid: !1,
      nodesDraggable: !0,
      nodesConnectable: !0,
      nodesFocusable: !0,
      edgesFocusable: !0,
      edgesReconnectable: !0,
      elementsSelectable: !0,
      elevateNodesOnSelect: !0,
      elevateEdgesOnSelect: !0,
      selectNodesOnDrag: !0,
      multiSelectionActive: !1,
      fitViewQueued: a ?? !1,
      fitViewOptions: s,
      fitViewResolver: null,
      connection: { ...vB },
      connectionClickStartHandle: null,
      connectOnClick: !0,
      ariaLiveMessage: "",
      autoPanOnConnect: !0,
      autoPanOnNodeDrag: !0,
      autoPanOnNodeFocus: !0,
      autoPanSpeed: 15,
      connectionRadius: 20,
      onError: yge,
      isValidConnection: void 0,
      onSelectionChangeHandlers: [],
      lib: "react",
      debug: !1,
      ariaLabelConfig: yB,
      zIndexMode: m,
      onNodesChangeMiddlewareMap: /* @__PURE__ */ new Map(),
      onEdgesChangeMiddlewareMap: /* @__PURE__ */ new Map()
    };
  }, Yve = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, width: o, height: i, fitView: a, fitViewOptions: s, minZoom: c, maxZoom: u, nodeOrigin: d, nodeExtent: p, zIndexMode: m }) => pye((g, y) => {
    async function b() {
      const { nodeLookup: v, panZoom: x, fitViewOptions: E, fitViewResolver: _, width: C, height: k, minZoom: A, maxZoom: O } = y();
      x && (await mge({
        nodes: v,
        width: C,
        height: k,
        panZoom: x,
        minZoom: A,
        maxZoom: O
      }, E), _?.resolve(!0), g({ fitViewResolver: null }));
    }
    return {
      ...Ej({
        nodes: e,
        edges: t,
        width: o,
        height: i,
        fitView: a,
        fitViewOptions: s,
        minZoom: c,
        maxZoom: u,
        nodeOrigin: d,
        nodeExtent: p,
        defaultNodes: n,
        defaultEdges: r,
        zIndexMode: m
      }),
      setNodes: (v) => {
        const { nodeLookup: x, parentLookup: E, nodeOrigin: _, elevateNodesOnSelect: C, fitViewQueued: k, zIndexMode: A } = y(), O = mC(v, x, E, {
          nodeOrigin: _,
          nodeExtent: p,
          elevateNodesOnSelect: C,
          checkEquality: !0,
          zIndexMode: A
        });
        k && O ? (b(), g({ nodes: v, nodesInitialized: O, fitViewQueued: !1, fitViewOptions: void 0 })) : g({ nodes: v, nodesInitialized: O });
      },
      setEdges: (v) => {
        const { connectionLookup: x, edgeLookup: E } = y();
        $B(x, E, v), g({ edges: v });
      },
      setDefaultNodesAndEdges: (v, x) => {
        if (v) {
          const { setNodes: E } = y();
          E(v), g({ hasDefaultNodes: !0 });
        }
        if (x) {
          const { setEdges: E } = y();
          E(x), g({ hasDefaultEdges: !0 });
        }
      },
      /*
       * Every node gets registerd at a ResizeObserver. Whenever a node
       * changes its dimensions, this function is called to measure the
       * new dimensions and update the nodes.
       */
      updateNodeInternals: (v) => {
        const { triggerNodeChanges: x, nodeLookup: E, parentLookup: _, domNode: C, nodeOrigin: k, nodeExtent: A, debug: O, fitViewQueued: P, zIndexMode: I } = y(), { changes: $, updatedInternals: L } = Lge(v, E, _, C, k, A, I);
        L && ($ge(E, _, { nodeOrigin: k, nodeExtent: A, zIndexMode: I }), P ? (b(), g({ fitViewQueued: !1, fitViewOptions: void 0 })) : g({}), $?.length > 0 && (O && console.log("React Flow: trigger node changes", $), x?.($)));
      },
      updateNodePositions: (v, x = !1) => {
        const E = [];
        let _ = [];
        const { nodeLookup: C, triggerNodeChanges: k, connection: A, updateConnection: O, onNodesChangeMiddlewareMap: P } = y();
        for (const [I, $] of v) {
          const L = C.get(I), N = !!(L?.expandParent && L?.parentId && $?.position), U = {
            id: I,
            type: "position",
            position: N ? {
              x: Math.max(0, $.position.x),
              y: Math.max(0, $.position.y)
            } : $.position,
            dragging: x
          };
          if (L && A.inProgress && A.fromNode.id === L.id) {
            const j = yc(L, A.fromHandle, Ve.Left, !0);
            O({ ...A, from: j });
          }
          N && L.parentId && E.push({
            id: I,
            parentId: L.parentId,
            rect: {
              ...$.internals.positionAbsolute,
              width: $.measured.width ?? 0,
              height: $.measured.height ?? 0
            }
          }), _.push(U);
        }
        if (E.length > 0) {
          const { parentLookup: I, nodeOrigin: $ } = y(), L = LT(E, C, I, $);
          _.push(...L);
        }
        for (const I of P.values())
          _ = I(_);
        k(_);
      },
      triggerNodeChanges: (v) => {
        const { onNodesChange: x, setNodes: E, nodes: _, hasDefaultNodes: C, debug: k } = y();
        if (v?.length) {
          if (C) {
            const A = zT(v, _);
            E(A);
          }
          k && console.log("React Flow: trigger node changes", v), x?.(v);
        }
      },
      triggerEdgeChanges: (v) => {
        const { onEdgesChange: x, setEdges: E, edges: _, hasDefaultEdges: C, debug: k } = y();
        if (v?.length) {
          if (C) {
            const A = XB(v, _);
            E(A);
          }
          k && console.log("React Flow: trigger edge changes", v), x?.(v);
        }
      },
      addSelectedNodes: (v) => {
        const { multiSelectionActive: x, edgeLookup: E, nodeLookup: _, triggerNodeChanges: C, triggerEdgeChanges: k } = y();
        if (x) {
          const A = v.map((O) => Xl(O, !0));
          C(A);
          return;
        }
        C(Ku(_, /* @__PURE__ */ new Set([...v]), !0)), k(Ku(E));
      },
      addSelectedEdges: (v) => {
        const { multiSelectionActive: x, edgeLookup: E, nodeLookup: _, triggerNodeChanges: C, triggerEdgeChanges: k } = y();
        if (x) {
          const A = v.map((O) => Xl(O, !0));
          k(A);
          return;
        }
        k(Ku(E, /* @__PURE__ */ new Set([...v]))), C(Ku(_, /* @__PURE__ */ new Set(), !0));
      },
      unselectNodesAndEdges: ({ nodes: v, edges: x } = {}) => {
        const { edges: E, nodes: _, nodeLookup: C, triggerNodeChanges: k, triggerEdgeChanges: A } = y(), O = v || _, P = x || E, I = O.map((L) => {
          const N = C.get(L.id);
          return N && (N.selected = !1), Xl(L.id, !1);
        }), $ = P.map((L) => Xl(L.id, !1));
        k(I), A($);
      },
      setMinZoom: (v) => {
        const { panZoom: x, maxZoom: E } = y();
        x?.setScaleExtent([v, E]), g({ minZoom: v });
      },
      setMaxZoom: (v) => {
        const { panZoom: x, minZoom: E } = y();
        x?.setScaleExtent([E, v]), g({ maxZoom: v });
      },
      setTranslateExtent: (v) => {
        y().panZoom?.setTranslateExtent(v), g({ translateExtent: v });
      },
      resetSelectedElements: () => {
        const { edges: v, nodes: x, triggerNodeChanges: E, triggerEdgeChanges: _, elementsSelectable: C } = y();
        if (!C)
          return;
        const k = x.reduce((O, P) => P.selected ? [...O, Xl(P.id, !1)] : O, []), A = v.reduce((O, P) => P.selected ? [...O, Xl(P.id, !1)] : O, []);
        E(k), _(A);
      },
      setNodeExtent: (v) => {
        const { nodes: x, nodeLookup: E, parentLookup: _, nodeOrigin: C, elevateNodesOnSelect: k, nodeExtent: A, zIndexMode: O } = y();
        v[0][0] === A[0][0] && v[0][1] === A[0][1] && v[1][0] === A[1][0] && v[1][1] === A[1][1] || (mC(x, E, _, {
          nodeOrigin: C,
          nodeExtent: v,
          elevateNodesOnSelect: k,
          checkEquality: !1,
          zIndexMode: O
        }), g({ nodeExtent: v }));
      },
      panBy: (v) => {
        const { transform: x, width: E, height: _, panZoom: C, translateExtent: k } = y();
        return zge({ delta: v, panZoom: C, transform: x, translateExtent: k, width: E, height: _ });
      },
      setCenter: async (v, x, E) => {
        const { width: _, height: C, maxZoom: k, panZoom: A } = y();
        if (!A)
          return Promise.resolve(!1);
        const O = typeof E?.zoom < "u" ? E.zoom : k;
        return await A.setViewport({
          x: _ / 2 - v * O,
          y: C / 2 - x * O,
          zoom: O
        }, { duration: E?.duration, ease: E?.ease, interpolate: E?.interpolate }), Promise.resolve(!0);
      },
      cancelConnection: () => {
        g({
          connection: { ...vB }
        });
      },
      updateConnection: (v) => {
        g({ connection: v });
      },
      reset: () => g({ ...Ej() })
    };
  }, Object.is);
  function Xve({ initialNodes: e, initialEdges: t, defaultNodes: n, defaultEdges: r, initialWidth: o, initialHeight: i, initialMinZoom: a, initialMaxZoom: s, initialFitViewOptions: c, fitView: u, nodeOrigin: d, nodeExtent: p, zIndexMode: m, children: g }) {
    const [y] = T.useState(() => Yve({
      nodes: e,
      edges: t,
      defaultNodes: n,
      defaultEdges: r,
      width: o,
      height: i,
      fitView: u,
      minZoom: a,
      maxZoom: s,
      fitViewOptions: c,
      nodeOrigin: d,
      nodeExtent: p,
      zIndexMode: m
    }));
    return S.jsx(hye, { value: y, children: S.jsx(Dye, { children: g }) });
  }
  function Zve({ children: e, nodes: t, edges: n, defaultNodes: r, defaultEdges: o, width: i, height: a, fitView: s, fitViewOptions: c, minZoom: u, maxZoom: d, nodeOrigin: p, nodeExtent: m, zIndexMode: g }) {
    return T.useContext(t1) ? S.jsx(S.Fragment, { children: e }) : S.jsx(Xve, { initialNodes: t, initialEdges: n, defaultNodes: r, defaultEdges: o, initialWidth: i, initialHeight: a, fitView: s, initialFitViewOptions: c, initialMinZoom: u, initialMaxZoom: d, nodeOrigin: p, nodeExtent: m, zIndexMode: g, children: e });
  }
  const Qve = {
    width: "100%",
    height: "100%",
    overflow: "hidden",
    position: "relative",
    zIndex: 0
  };
  function Jve({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, className: o, nodeTypes: i, edgeTypes: a, onNodeClick: s, onEdgeClick: c, onInit: u, onMove: d, onMoveStart: p, onMoveEnd: m, onConnect: g, onConnectStart: y, onConnectEnd: b, onClickConnectStart: v, onClickConnectEnd: x, onNodeMouseEnter: E, onNodeMouseMove: _, onNodeMouseLeave: C, onNodeContextMenu: k, onNodeDoubleClick: A, onNodeDragStart: O, onNodeDrag: P, onNodeDragStop: I, onNodesDelete: $, onEdgesDelete: L, onDelete: N, onSelectionChange: U, onSelectionDragStart: j, onSelectionDrag: V, onSelectionDragStop: F, onSelectionContextMenu: K, onSelectionStart: W, onSelectionEnd: Y, onBeforeDelete: B, connectionMode: D, connectionLineType: G = qs.Bezier, connectionLineStyle: z, connectionLineComponent: H, connectionLineContainerStyle: X, deleteKeyCode: Q = "Backspace", selectionKeyCode: ne = "Shift", selectionOnDrag: te = !1, selectionMode: se = lh.Full, panActivationKeyCode: ue = "Space", multiSelectionKeyCode: J = uh() ? "Meta" : "Control", zoomActivationKeyCode: ee = uh() ? "Meta" : "Control", snapToGrid: ie, snapGrid: le, onlyRenderVisibleElements: ge = !1, selectNodesOnDrag: Se, nodesDraggable: Me, autoPanOnNodeFocus: je, nodesConnectable: ze, nodesFocusable: Ye, nodeOrigin: Ue = KB, edgesFocusable: Ne, edgesReconnectable: mt, elementsSelectable: Je = !0, defaultViewport: Ae = Tye, minZoom: oe = 0.5, maxZoom: fe = 2, translateExtent: _e = sh, preventScrolling: Ce = !0, nodeExtent: Oe, defaultMarkerColor: He = "#b1b1b7", zoomOnScroll: Ot = !0, zoomOnPinch: it = !0, panOnScroll: Et = !1, panOnScrollSpeed: xn = 0.5, panOnScrollMode: Mt = ac.Free, zoomOnDoubleClick: De = !0, panOnDrag: ft = !0, onPaneClick: hn, onPaneMouseEnter: nr, onPaneMouseMove: Lo, onPaneMouseLeave: on, onPaneScroll: an, onPaneContextMenu: ui, paneClickDistance: yo = 1, nodeClickDistance: Gr = 0, children: Em, onReconnect: Xf, onReconnectStart: bl, onReconnectEnd: H1, onEdgeContextMenu: Cm, onEdgeDoubleClick: km, onEdgeMouseEnter: Tm, onEdgeMouseMove: Zf, onEdgeMouseLeave: Qf, reconnectRadius: Am = 10, onNodesChange: Rm, onEdgesChange: fi, noDragClassName: Wn = "nodrag", noWheelClassName: pr = "nowheel", noPanClassName: ia = "nopan", fitView: Fc, fitViewOptions: Om, connectOnClick: q1, attributionPosition: Mm, proOptions: xl, defaultEdgeOptions: Jf, elevateNodesOnSelect: ls = !0, elevateEdgesOnSelect: cs = !1, disableKeyboardA11y: us = !1, autoPanOnConnect: fs, autoPanOnNodeDrag: jn, autoPanSpeed: Nm, connectionRadius: Pm, isValidConnection: aa, onError: ds, style: W1, id: ed, nodeDragThreshold: Im, connectionDragThreshold: G1, viewport: Lc, onViewportChange: zc, width: zo, height: Mr, colorMode: $m = "light", debug: K1, onScroll: Bc, ariaLabelConfig: jm, zIndexMode: wl = "basic", ...Y1 }, Nr) {
    const Sl = ed || "1", Dm = Mye($m), td = T.useCallback((sa) => {
      sa.currentTarget.scrollTo({ top: 0, left: 0, behavior: "instant" }), Bc?.(sa);
    }, [Bc]);
    return S.jsx("div", { "data-testid": "rf__wrapper", ...Y1, onScroll: td, style: { ...W1, ...Qve }, ref: Nr, className: qn(["react-flow", o, Dm]), id: ed, role: "application", children: S.jsxs(Zve, { nodes: e, edges: t, width: zo, height: Mr, fitView: Fc, fitViewOptions: Om, minZoom: oe, maxZoom: fe, nodeOrigin: Ue, nodeExtent: Oe, zIndexMode: wl, children: [S.jsx(Kve, { onInit: u, onNodeClick: s, onEdgeClick: c, onNodeMouseEnter: E, onNodeMouseMove: _, onNodeMouseLeave: C, onNodeContextMenu: k, onNodeDoubleClick: A, nodeTypes: i, edgeTypes: a, connectionLineType: G, connectionLineStyle: z, connectionLineComponent: H, connectionLineContainerStyle: X, selectionKeyCode: ne, selectionOnDrag: te, selectionMode: se, deleteKeyCode: Q, multiSelectionKeyCode: J, panActivationKeyCode: ue, zoomActivationKeyCode: ee, onlyRenderVisibleElements: ge, defaultViewport: Ae, translateExtent: _e, minZoom: oe, maxZoom: fe, preventScrolling: Ce, zoomOnScroll: Ot, zoomOnPinch: it, zoomOnDoubleClick: De, panOnScroll: Et, panOnScrollSpeed: xn, panOnScrollMode: Mt, panOnDrag: ft, onPaneClick: hn, onPaneMouseEnter: nr, onPaneMouseMove: Lo, onPaneMouseLeave: on, onPaneScroll: an, onPaneContextMenu: ui, paneClickDistance: yo, nodeClickDistance: Gr, onSelectionContextMenu: K, onSelectionStart: W, onSelectionEnd: Y, onReconnect: Xf, onReconnectStart: bl, onReconnectEnd: H1, onEdgeContextMenu: Cm, onEdgeDoubleClick: km, onEdgeMouseEnter: Tm, onEdgeMouseMove: Zf, onEdgeMouseLeave: Qf, reconnectRadius: Am, defaultMarkerColor: He, noDragClassName: Wn, noWheelClassName: pr, noPanClassName: ia, rfId: Sl, disableKeyboardA11y: us, nodeExtent: Oe, viewport: Lc, onViewportChange: zc }), S.jsx(Oye, { nodes: e, edges: t, defaultNodes: n, defaultEdges: r, onConnect: g, onConnectStart: y, onConnectEnd: b, onClickConnectStart: v, onClickConnectEnd: x, nodesDraggable: Me, autoPanOnNodeFocus: je, nodesConnectable: ze, nodesFocusable: Ye, edgesFocusable: Ne, edgesReconnectable: mt, elementsSelectable: Je, elevateNodesOnSelect: ls, elevateEdgesOnSelect: cs, minZoom: oe, maxZoom: fe, nodeExtent: Oe, onNodesChange: Rm, onEdgesChange: fi, snapToGrid: ie, snapGrid: le, connectionMode: D, translateExtent: _e, connectOnClick: q1, defaultEdgeOptions: Jf, fitView: Fc, fitViewOptions: Om, onNodesDelete: $, onEdgesDelete: L, onDelete: N, onNodeDragStart: O, onNodeDrag: P, onNodeDragStop: I, onSelectionDrag: V, onSelectionDragStart: j, onSelectionDragStop: F, onMove: d, onMoveStart: p, onMoveEnd: m, noPanClassName: ia, nodeOrigin: Ue, rfId: Sl, autoPanOnConnect: fs, autoPanOnNodeDrag: jn, autoPanSpeed: Nm, onError: ds, connectionRadius: Pm, isValidConnection: aa, selectNodesOnDrag: Se, nodeDragThreshold: Im, connectionDragThreshold: G1, onBeforeDelete: B, debug: K1, ariaLabelConfig: jm, zIndexMode: wl }), S.jsx(kye, { onSelectionChange: U }), Em, S.jsx(wye, { proOptions: xl, position: Mm }), S.jsx(xye, { rfId: Sl, disableKeyboardA11y: us })] }) });
  }
  var e0e = ZB(Jve);
  function t0e({ dimensions: e, lineWidth: t, variant: n, className: r }) {
    return S.jsx("path", { strokeWidth: t, d: `M${e[0] / 2} 0 V${e[1]} M0 ${e[1] / 2} H${e[0]}`, className: qn(["react-flow__background-pattern", n, r]) });
  }
  function n0e({ radius: e, className: t }) {
    return S.jsx("circle", { cx: e, cy: e, r: e, className: qn(["react-flow__background-pattern", "dots", t]) });
  }
  var kr;
  (function(e) {
    e.Lines = "lines", e.Dots = "dots", e.Cross = "cross";
  })(kr || (kr = {}));
  const r0e = {
    [kr.Dots]: 1,
    [kr.Lines]: 1,
    [kr.Cross]: 6
  }, o0e = (e) => ({ transform: e.transform, patternId: `pattern-${e.rfId}` });
  function w8({
    id: e,
    variant: t = kr.Dots,
    // only used for dots and cross
    gap: n = 20,
    // only used for lines and cross
    size: r,
    lineWidth: o = 1,
    offset: i = 0,
    color: a,
    bgColor: s,
    style: c,
    className: u,
    patternClassName: d
  }) {
    const p = T.useRef(null), { transform: m, patternId: g } = It(o0e, _n), y = r || r0e[t], b = t === kr.Dots, v = t === kr.Cross, x = Array.isArray(n) ? n : [n, n], E = [x[0] * m[2] || 1, x[1] * m[2] || 1], _ = y * m[2], C = Array.isArray(i) ? i : [i, i], k = v ? [_, _] : E, A = [
      C[0] * m[2] || 1 + k[0] / 2,
      C[1] * m[2] || 1 + k[1] / 2
    ], O = `${g}${e || ""}`;
    return S.jsxs("svg", { className: qn(["react-flow__background", u]), style: {
      ...c,
      ...r1,
      "--xy-background-color-props": s,
      "--xy-background-pattern-color-props": a
    }, ref: p, "data-testid": "rf__background", children: [S.jsx("pattern", { id: O, x: m[0] % E[0], y: m[1] % E[1], width: E[0], height: E[1], patternUnits: "userSpaceOnUse", patternTransform: `translate(-${A[0]},-${A[1]})`, children: b ? S.jsx(n0e, { radius: _ / 2, className: d }) : S.jsx(t0e, { dimensions: k, lineWidth: o, variant: t, className: d }) }), S.jsx("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: `url(#${O})` })] });
  }
  w8.displayName = "Background";
  const i0e = T.memo(w8);
  function a0e() {
    return S.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", children: S.jsx("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" }) });
  }
  function s0e() {
    return S.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 5", children: S.jsx("path", { d: "M0 0h32v4.2H0z" }) });
  }
  function l0e() {
    return S.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 30", children: S.jsx("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" }) });
  }
  function c0e() {
    return S.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: S.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" }) });
  }
  function u0e() {
    return S.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: S.jsx("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z" }) });
  }
  function Sy({ children: e, className: t, ...n }) {
    return S.jsx("button", { type: "button", className: qn(["react-flow__controls-button", t]), ...n, children: e });
  }
  const f0e = (e) => ({
    isInteractive: e.nodesDraggable || e.nodesConnectable || e.elementsSelectable,
    minZoomReached: e.transform[2] <= e.minZoom,
    maxZoomReached: e.transform[2] >= e.maxZoom,
    ariaLabelConfig: e.ariaLabelConfig
  });
  function S8({ style: e, showZoom: t = !0, showFitView: n = !0, showInteractive: r = !0, fitViewOptions: o, onZoomIn: i, onZoomOut: a, onFitView: s, onInteractiveChange: c, className: u, children: d, position: p = "bottom-left", orientation: m = "vertical", "aria-label": g }) {
    const y = Cn(), { isInteractive: b, minZoomReached: v, maxZoomReached: x, ariaLabelConfig: E } = It(f0e, _n), { zoomIn: _, zoomOut: C, fitView: k } = Ec(), A = () => {
      _(), i?.();
    }, O = () => {
      C(), a?.();
    }, P = () => {
      k(o), s?.();
    }, I = () => {
      y.setState({
        nodesDraggable: !b,
        nodesConnectable: !b,
        elementsSelectable: !b
      }), c?.(!b);
    }, $ = m === "horizontal" ? "horizontal" : "vertical";
    return S.jsxs(n1, { className: qn(["react-flow__controls", $, u]), position: p, style: e, "data-testid": "rf__controls", "aria-label": g ?? E["controls.ariaLabel"], children: [t && S.jsxs(S.Fragment, { children: [S.jsx(Sy, { onClick: A, className: "react-flow__controls-zoomin", title: E["controls.zoomIn.ariaLabel"], "aria-label": E["controls.zoomIn.ariaLabel"], disabled: x, children: S.jsx(a0e, {}) }), S.jsx(Sy, { onClick: O, className: "react-flow__controls-zoomout", title: E["controls.zoomOut.ariaLabel"], "aria-label": E["controls.zoomOut.ariaLabel"], disabled: v, children: S.jsx(s0e, {}) })] }), n && S.jsx(Sy, { className: "react-flow__controls-fitview", onClick: P, title: E["controls.fitView.ariaLabel"], "aria-label": E["controls.fitView.ariaLabel"], children: S.jsx(l0e, {}) }), r && S.jsx(Sy, { className: "react-flow__controls-interactive", onClick: I, title: E["controls.interactive.ariaLabel"], "aria-label": E["controls.interactive.ariaLabel"], children: b ? S.jsx(u0e, {}) : S.jsx(c0e, {}) }), d] });
  }
  S8.displayName = "Controls";
  T.memo(S8);
  function d0e({ id: e, x: t, y: n, width: r, height: o, style: i, color: a, strokeColor: s, strokeWidth: c, className: u, borderRadius: d, shapeRendering: p, selected: m, onClick: g }) {
    const { background: y, backgroundColor: b } = i || {}, v = a || y || b;
    return S.jsx("rect", { className: qn(["react-flow__minimap-node", { selected: m }, u]), x: t, y: n, rx: d, ry: d, width: r, height: o, style: {
      fill: v,
      stroke: s,
      strokeWidth: c
    }, shapeRendering: p, onClick: g ? (x) => g(x, e) : void 0 });
  }
  const p0e = T.memo(d0e), h0e = (e) => e.nodes.map((t) => t.id), s_ = (e) => e instanceof Function ? e : () => e;
  function m0e({
    nodeStrokeColor: e,
    nodeColor: t,
    nodeClassName: n = "",
    nodeBorderRadius: r = 5,
    nodeStrokeWidth: o,
    /*
     * We need to rename the prop to be `CapitalCase` so that JSX will render it as
     * a component properly.
     */
    nodeComponent: i = p0e,
    onClick: a
  }) {
    const s = It(h0e, _n), c = s_(t), u = s_(e), d = s_(n), p = typeof window > "u" || window.chrome ? "crispEdges" : "geometricPrecision";
    return S.jsx(S.Fragment, { children: s.map((m) => (
      /*
       * The split of responsibilities between MiniMapNodes and
       * NodeComponentWrapper may appear weird. However, its designed to
       * minimize the cost of updates when individual nodes change.
       *
       * For more details, see a similar commit in `NodeRenderer/index.tsx`.
       */
      S.jsx(y0e, { id: m, nodeColorFunc: c, nodeStrokeColorFunc: u, nodeClassNameFunc: d, nodeBorderRadius: r, nodeStrokeWidth: o, NodeComponent: i, onClick: a, shapeRendering: p }, m)
    )) });
  }
  function g0e({ id: e, nodeColorFunc: t, nodeStrokeColorFunc: n, nodeClassNameFunc: r, nodeBorderRadius: o, nodeStrokeWidth: i, shapeRendering: a, NodeComponent: s, onClick: c }) {
    const { node: u, x: d, y: p, width: m, height: g } = It((y) => {
      const { internals: b } = y.nodeLookup.get(e), v = b.userNode, { x, y: E } = b.positionAbsolute, { width: _, height: C } = ns(v);
      return {
        node: v,
        x,
        y: E,
        width: _,
        height: C
      };
    }, _n);
    return !u || u.hidden || !CB(u) ? null : S.jsx(s, { x: d, y: p, width: m, height: g, style: u.style, selected: !!u.selected, className: r(u), color: t(u), borderRadius: o, strokeColor: n(u), strokeWidth: i, shapeRendering: a, onClick: c, id: u.id });
  }
  const y0e = T.memo(g0e);
  var v0e = T.memo(m0e);
  const b0e = 200, x0e = 150, w0e = (e) => !e.hidden, S0e = (e) => {
    const t = {
      x: -e.transform[0] / e.transform[2],
      y: -e.transform[1] / e.transform[2],
      width: e.width / e.transform[2],
      height: e.height / e.transform[2]
    };
    return {
      viewBB: t,
      boundingRect: e.nodeLookup.size > 0 ? EB(tm(e.nodeLookup, { filter: w0e }), t) : t,
      rfId: e.rfId,
      panZoom: e.panZoom,
      translateExtent: e.translateExtent,
      flowWidth: e.width,
      flowHeight: e.height,
      ariaLabelConfig: e.ariaLabelConfig
    };
  }, _0e = "react-flow__minimap-desc";
  function _8({
    style: e,
    className: t,
    nodeStrokeColor: n,
    nodeColor: r,
    nodeClassName: o = "",
    nodeBorderRadius: i = 5,
    nodeStrokeWidth: a,
    /*
     * We need to rename the prop to be `CapitalCase` so that JSX will render it as
     * a component properly.
     */
    nodeComponent: s,
    bgColor: c,
    maskColor: u,
    maskStrokeColor: d,
    maskStrokeWidth: p,
    position: m = "bottom-right",
    onClick: g,
    onNodeClick: y,
    pannable: b = !1,
    zoomable: v = !1,
    ariaLabel: x,
    inversePan: E,
    zoomStep: _ = 1,
    offsetScale: C = 5
  }) {
    const k = Cn(), A = T.useRef(null), { boundingRect: O, viewBB: P, rfId: I, panZoom: $, translateExtent: L, flowWidth: N, flowHeight: U, ariaLabelConfig: j } = It(S0e, _n), V = e?.width ?? b0e, F = e?.height ?? x0e, K = O.width / V, W = O.height / F, Y = Math.max(K, W), B = Y * V, D = Y * F, G = C * Y, z = O.x - (B - O.width) / 2 - G, H = O.y - (D - O.height) / 2 - G, X = B + G * 2, Q = D + G * 2, ne = `${_0e}-${I}`, te = T.useRef(0), se = T.useRef();
    te.current = Y, T.useEffect(() => {
      if (A.current && $)
        return se.current = Yge({
          domNode: A.current,
          panZoom: $,
          getTransform: () => k.getState().transform,
          getViewScale: () => te.current
        }), () => {
          se.current?.destroy();
        };
    }, [$]), T.useEffect(() => {
      se.current?.update({
        translateExtent: L,
        width: N,
        height: U,
        inversePan: E,
        pannable: b,
        zoomStep: _,
        zoomable: v
      });
    }, [b, v, E, _, L, N, U]);
    const ue = g ? (ie) => {
      const [le, ge] = se.current?.pointer(ie) || [0, 0];
      g(ie, { x: le, y: ge });
    } : void 0, J = y ? T.useCallback((ie, le) => {
      const ge = k.getState().nodeLookup.get(le).internals.userNode;
      y(ie, ge);
    }, []) : void 0, ee = x ?? j["minimap.ariaLabel"];
    return S.jsx(n1, { position: m, style: {
      ...e,
      "--xy-minimap-background-color-props": typeof c == "string" ? c : void 0,
      "--xy-minimap-mask-background-color-props": typeof u == "string" ? u : void 0,
      "--xy-minimap-mask-stroke-color-props": typeof d == "string" ? d : void 0,
      "--xy-minimap-mask-stroke-width-props": typeof p == "number" ? p * Y : void 0,
      "--xy-minimap-node-background-color-props": typeof r == "string" ? r : void 0,
      "--xy-minimap-node-stroke-color-props": typeof n == "string" ? n : void 0,
      "--xy-minimap-node-stroke-width-props": typeof a == "number" ? a : void 0
    }, className: qn(["react-flow__minimap", t]), "data-testid": "rf__minimap", children: S.jsxs("svg", { width: V, height: F, viewBox: `${z} ${H} ${X} ${Q}`, className: "react-flow__minimap-svg", role: "img", "aria-labelledby": ne, ref: A, onClick: ue, children: [ee && S.jsx("title", { id: ne, children: ee }), S.jsx(v0e, { onClick: J, nodeColor: r, nodeStrokeColor: n, nodeBorderRadius: i, nodeClassName: o, nodeStrokeWidth: a, nodeComponent: s }), S.jsx("path", { className: "react-flow__minimap-mask", d: `M${z - G},${H - G}h${X + G * 2}v${Q + G * 2}h${-X - G * 2}z
        M${P.x},${P.y}h${P.width}v${P.height}h${-P.width}z`, fillRule: "evenodd", pointerEvents: "none" })] }) });
  }
  _8.displayName = "MiniMap";
  const E0e = T.memo(_8), C0e = (e) => (t) => e ? `${Math.max(1 / t.transform[2], 1)}` : void 0, k0e = {
    [Ef.Line]: "right",
    [Ef.Handle]: "bottom-right"
  };
  function T0e({ nodeId: e, position: t, variant: n = Ef.Handle, className: r, style: o = void 0, children: i, color: a, minWidth: s = 10, minHeight: c = 10, maxWidth: u = Number.MAX_VALUE, maxHeight: d = Number.MAX_VALUE, keepAspectRatio: p = !1, resizeDirection: m, autoScale: g = !0, shouldResize: y, onResizeStart: b, onResize: v, onResizeEnd: x }) {
    const E = t8(), _ = typeof e == "string" ? e : E, C = Cn(), k = T.useRef(null), A = n === Ef.Handle, O = It(T.useCallback(C0e(A && g), [A, g]), _n), P = T.useRef(null), I = t ?? k0e[n];
    T.useEffect(() => {
      if (!(!k.current || !_))
        return P.current || (P.current = cye({
          domNode: k.current,
          nodeId: _,
          getStoreItems: () => {
            const { nodeLookup: L, transform: N, snapGrid: U, snapToGrid: j, nodeOrigin: V, domNode: F } = C.getState();
            return {
              nodeLookup: L,
              transform: N,
              snapGrid: U,
              snapToGrid: j,
              nodeOrigin: V,
              paneDomNode: F
            };
          },
          onChange: (L, N) => {
            const { triggerNodeChanges: U, nodeLookup: j, parentLookup: V, nodeOrigin: F } = C.getState(), K = [], W = { x: L.x, y: L.y }, Y = j.get(_);
            if (Y && Y.expandParent && Y.parentId) {
              const B = Y.origin ?? F, D = L.width ?? Y.measured.width ?? 0, G = L.height ?? Y.measured.height ?? 0, z = {
                id: Y.id,
                parentId: Y.parentId,
                rect: {
                  width: D,
                  height: G,
                  ...kB({
                    x: L.x ?? Y.position.x,
                    y: L.y ?? Y.position.y
                  }, { width: D, height: G }, Y.parentId, j, B)
                }
              }, H = LT([z], j, V, F);
              K.push(...H), W.x = L.x ? Math.max(B[0] * D, L.x) : void 0, W.y = L.y ? Math.max(B[1] * G, L.y) : void 0;
            }
            if (W.x !== void 0 && W.y !== void 0) {
              const B = {
                id: _,
                type: "position",
                position: { ...W }
              };
              K.push(B);
            }
            if (L.width !== void 0 && L.height !== void 0) {
              const D = {
                id: _,
                type: "dimensions",
                resizing: !0,
                setAttributes: m ? m === "horizontal" ? "width" : "height" : !0,
                dimensions: {
                  width: L.width,
                  height: L.height
                }
              };
              K.push(D);
            }
            for (const B of N) {
              const D = {
                ...B,
                type: "position"
              };
              K.push(D);
            }
            U(K);
          },
          onEnd: ({ width: L, height: N }) => {
            const U = {
              id: _,
              type: "dimensions",
              resizing: !1,
              dimensions: {
                width: L,
                height: N
              }
            };
            C.getState().triggerNodeChanges([U]);
          }
        })), P.current.update({
          controlPosition: I,
          boundaries: {
            minWidth: s,
            minHeight: c,
            maxWidth: u,
            maxHeight: d
          },
          keepAspectRatio: p,
          resizeDirection: m,
          onResizeStart: b,
          onResize: v,
          onResizeEnd: x,
          shouldResize: y
        }), () => {
          P.current?.destroy();
        };
    }, [
      I,
      s,
      c,
      u,
      d,
      p,
      b,
      v,
      x,
      y
    ]);
    const $ = I.split("-");
    return S.jsx("div", { className: qn(["react-flow__resize-control", "nodrag", ...$, n, r]), ref: k, style: {
      ...o,
      scale: O,
      ...a && { [A ? "backgroundColor" : "borderColor"]: a }
    }, children: i });
  }
  T.memo(T0e);
  function A0e(e, t) {
    if (Object.is(e, t))
      return !0;
    if (typeof e != "object" || e === null || typeof t != "object" || t === null)
      return !1;
    if (e instanceof Map && t instanceof Map) {
      if (e.size !== t.size) return !1;
      for (const [r, o] of e)
        if (!Object.is(o, t.get(r)))
          return !1;
      return !0;
    }
    if (e instanceof Set && t instanceof Set) {
      if (e.size !== t.size) return !1;
      for (const r of e)
        if (!t.has(r))
          return !1;
      return !0;
    }
    const n = Object.keys(e);
    if (n.length !== Object.keys(t).length)
      return !1;
    for (const r of n)
      if (!Object.prototype.hasOwnProperty.call(t, r) || !Object.is(e[r], t[r]))
        return !1;
    return !0;
  }
  const { useRef: R0e } = On;
  function UT(e) {
    const t = R0e();
    return (n) => {
      const r = e(n);
      return A0e(t.current, r) ? t.current : t.current = r;
    };
  }
  const O0e = () => {
    const { group: e } = Rr();
    return async (t, n) => {
      if (e)
        return await e.group_nodes(t, n);
    };
  }, M0e = () => {
    const { group: e } = Rr();
    return async (t) => {
      if (e)
        for (const n of t)
          await e.remove_group(n);
    };
  }, N0e = ({ data: e }) => {
    const t = e?.group?.id || e?.id, n = M0e(), r = T.useCallback(
      (o) => {
        o.stopPropagation(), t && n([t]);
      },
      [t, n]
    );
    return /* @__PURE__ */ S.jsxs("div", { className: "fn-group", children: [
      /* @__PURE__ */ S.jsx(
        "button",
        {
          className: "fn-group-remove",
          title: "Remove group",
          onClick: r,
          children: /* @__PURE__ */ S.jsx(Nb, {})
        }
      ),
      "Group"
    ] });
  }, E8 = (e, t) => {
    if (typeof e == "string")
      return e in t ? [t[e], e] : [e, e];
    if ("allOf" in e && e.allOf !== void 0)
      return [void 0, void 0];
    if ("anyOf" in e && e.anyOf !== void 0) {
      const n = e.anyOf.map(
        (r) => E8(r || "any", t)
      );
      for (const r of n)
        switch (r[0]) {
          case "bool":
            return ["bool", r[1]];
          case "enum":
            return ["enum", r[1]];
          case "float":
            return ["float", r[1]];
          case "int":
            return ["int", r[1]];
          case "string":
            return ["string", r[1]];
          case "str":
            return ["string", r[1]];
        }
      return [void 0, void 0];
    }
    return !("type" in e) || e.type === void 0 ? [void 0, void 0] : e.type === "enum" ? ["enum", "enum"] : [void 0, void 0];
  }, Cc = (e, t) => E8(e.render_options?.type ?? "any", t), VT = T.memo(
    ({ value: e }) => {
      const t = e?.toString() ?? "", n = Math.round(3 * t.length / 4);
      return /* @__PURE__ */ S.jsx("div", { children: /* @__PURE__ */ S.jsxs("pre", { children: [
        "Bytes(",
        n,
        ")"
      ] }) });
    }
  ), C8 = T.memo(
    ({ value: e }) => typeof e != "string" ? /* @__PURE__ */ S.jsx("div", { children: "Invalid SVG" }) : /* @__PURE__ */ S.jsx(Yce, { value: e })
  ), k8 = ({
    value: e,
    preValue: t,
    onLoaded: n
  }) => {
    const [r, o] = T.useState(
      t?.toString() || e?.toString()
    );
    return T.useEffect(() => {
      if (e === t || e == null) return;
      const a = new Image(), s = e.toString();
      return a.onload = () => {
        n?.(), o(s);
      }, a.src = s, () => {
        a.onload = null;
      };
    }, [e, t, n]), r === void 0 ? /* @__PURE__ */ S.jsx(S.Fragment, {}) : typeof r != "string" ? (console.error("ImageRenderer: value is not a string", r), /* @__PURE__ */ S.jsx(S.Fragment, {})) : r.startsWith("data:") || r.startsWith("blob:") ? /* @__PURE__ */ S.jsx(Xce, { src: r }) : /* @__PURE__ */ S.jsx(Kce, { value: r, format: "jpeg" });
  }, T8 = (e) => {
    let t = "";
    if (typeof e == "string")
      t = e;
    else if (typeof e == "number" || typeof e == "boolean")
      t = String(e);
    else if (e === null)
      t = "null";
    else {
      if (e === void 0)
        return;
      try {
        t = JSON.stringify(e);
      } catch {
      }
    }
    return t;
  }, P0e = T.memo(
    ({ value: e }) => /* @__PURE__ */ S.jsx("div", { children: /* @__PURE__ */ S.jsx("pre", { children: T8(e) ?? "" }) })
  ), o1 = ({
    value: e
  }) => /* @__PURE__ */ S.jsx(Nce, { data: e }), A8 = T.memo(
    ({ value: e }) => {
      if (typeof e != "object" || e == null)
        return /* @__PURE__ */ S.jsx("div", { children: "Invalid Table" });
      if (!("columns" in e && "index" in e && "data" in e))
        return /* @__PURE__ */ S.jsx("div", { children: "Invalid Table" });
      if (!Array.isArray(e.columns) || !Array.isArray(e.index) || !Array.isArray(e.data) || !e.data.every((n) => Array.isArray(n)))
        return /* @__PURE__ */ S.jsx("div", { children: "Invalid Table" });
      const t = {
        columns: e.columns || [],
        index: e.index || [],
        data: e.data || []
      };
      return /* @__PURE__ */ S.jsx(FF, { tabledata: t });
    }
  ), N0 = (e) => /* @__PURE__ */ S.jsx(P0e, { ...e }), P0 = o1, HT = {
    string: N0,
    str: N0,
    table: A8,
    image: k8,
    svg: C8,
    dict: o1,
    bytes: VT
  }, i1 = T.createContext({}), mo = () => T.useContext(i1), cl = T.createContext(void 0);
  function En(e) {
    if (e)
      return mo().io_stores.get(e);
    {
      const t = T.useContext(cl);
      if (!t)
        throw new Error("IOContext not set");
      return t;
    }
  }
  const I0e = () => {
    const e = En(), { full: t, preview: n } = e.valuestore(), r = JSON.stringify(t?.value || n?.value) || "";
    return `Bytes(${Math.round(3 * r.length / 4)})`;
  }, $0e = {
    bytes: I0e
  }, a1 = (e) => ({ value: t, preValue: n, onLoaded: r }) => /* @__PURE__ */ S.jsx(e, { value: t, preValue: n, onLoaded: r }), zr = (e, t = void 0, n = {}) => ({}) => {
    const r = En(), { full: o, preview: i } = r.valuestore(), s = (o === void 0 ? i : o)?.value || t;
    return /* @__PURE__ */ S.jsx(e, { value: s, ...n });
  }, R8 = (e) => ({}) => /* @__PURE__ */ S.jsx(e, {}), O8 = (e, t = void 0) => ({}) => {
    const n = En(), { full: r, preview: o } = n.valuestore(), a = (r === void 0 ? o : r)?.value || t;
    return /* @__PURE__ */ S.jsx(e, { value: a });
  }, j0e = {
    ...Object.fromEntries(
      Object.entries(HT).map(([e, t]) => [
        e,
        t ? a1(t) : void 0
      ])
    )
  }, Cj = a1(o1), M8 = {
    ...Object.fromEntries(
      Object.entries(HT).map(([e, t]) => [
        e,
        t ? zr(t) : void 0
      ])
    ),
    string: zr(N0),
    str: zr(N0),
    table: zr(A8, void 0, {
      pageSize: 10
    }),
    image: zr(k8),
    svg: zr(C8, ""),
    dict: zr(o1, "{}"),
    bytes: zr(VT, "")
  }, D0e = {
    ...Object.fromEntries(
      Object.entries(M8).map(([e, t]) => [
        e,
        t ? R8(t) : void 0
      ])
    )
  }, F0e = () => {
    const e = En(), { preview: t, full: n } = e.valuestore();
    let o = T8(n || t) ?? "";
    return o.length > 63 && (o = o.slice(0, 60) + "..."), /* @__PURE__ */ S.jsx("div", { children: o });
  }, L0e = {};
  function kc(e) {
    const { node: t } = Rr();
    if (e || (e = En().use()), typeof e == "string" && (e = En(e)?.use(), !e))
      throw new Error(`No IO found for ${e}`);
    if (!e)
      throw new Error("No IO found");
    return T.useCallback(
      (r, o) => {
        t?.set_io_value({
          nid: e.node,
          ioid: e.id,
          value: r,
          set_default: o ?? e.render_options.set_default
        });
      },
      [e, t]
    );
  }
  function z0e(e) {
    const { node: t } = Rr();
    let n, r;
    if (!e) {
      const a = En().useShallow((s) => ({
        io_id: s.id,
        node_id: s.node
      }));
      n = a.io_id, r = a.node_id;
    }
    if (typeof e == "string") {
      const i = En(e);
      if (!i)
        throw new Error(`No IO found for ${e}`);
      const a = i.useShallow((s) => ({
        io_id: s.id,
        node_id: s.node
      }));
      n = a.io_id, r = a.node_id;
    } else {
      if (!e)
        throw new Error("No IO found");
      n = e.id, r = e.node;
    }
    return T.useCallback(
      (i) => {
        t?.set_io_value_options({
          nid: r,
          ioid: n,
          values: i.values ?? i.keys,
          keys: i.keys,
          nullable: i.nullable ?? !1
        });
      },
      [t, n, r]
    );
  }
  function B0e(e) {
    return En(e)?.valuestore();
  }
  function im(e) {
    const t = En(e);
    if (!t) return;
    const { node: n, id: r } = t.useShallow((a) => ({
      node: a.node,
      id: a.id
    })), { node: o } = Rr();
    return T.useCallback(async () => {
      const a = await o?.get_io_full_value({ nid: n, ioid: r });
      return t.updateValueStore({ full: a }), a;
    }, [o, n, r]);
  }
  function qT(e) {
    const t = En(e);
    if (!t) return;
    const { node: n, id: r } = t.useShallow((a) => ({
      node: a.node,
      id: a.id
    })), { node: o } = Rr();
    return T.useCallback(
      (a) => {
        o?.update_io_options({
          nid: n,
          ioid: r,
          options: { hidden: a }
        });
      },
      [o, n, r]
    );
  }
  const U0e = ({ inputconverter: e }) => {
    const t = En(), { preview: n } = t.valuestore(), r = t.use(), o = n?.value === void 0, i = T.useRef(null), a = kc(r);
    T.useEffect(() => {
      i.current && (i.current.indeterminate = o);
    }, [i, o]);
    const s = T.useCallback(
      (c) => {
        let u = c.target.checked;
        try {
          u = e[0](c.target.checked);
        } catch {
        }
        a(u);
      },
      [a, e]
    );
    return /* @__PURE__ */ S.jsx(
      "input",
      {
        ref: i,
        type: "checkbox",
        className: "styledcheckbox booleaninput",
        checked: !!e[1](n?.value),
        onChange: s,
        disabled: r.connected
      }
    );
  }, V0e = ({}) => {
    const e = En(), t = Vt(), n = e.use(), { preview: r, full: o } = e.valuestore(), i = o === void 0 ? r?.value : o.value, a = kc(n), s = typeof i == "string" || Array.isArray(i) && i.every((m) => typeof m == "number") ? i : void 0, c = n.value_options?.colorspace || "hex", u = T.useCallback(
      (m) => {
        let g = "<NoValue>";
        m && (m[c] ? g = m[c]() : g = m.hex()), m === null && (g = null);
        try {
          g = g;
        } catch {
        }
        a(g);
      },
      [a, c]
    );
    let d = !1;
    typeof n.type != "string" && "anyOf" in n.type && n.type.anyOf !== void 0 && (d = n.type.anyOf.some((m) => m === "None"));
    const p = t.local_state(() => t.reactflowRef);
    return /* @__PURE__ */ S.jsx(
      jae,
      {
        onChange: u,
        inicolordata: s,
        allow_null: d,
        inicolorspace: c,
        portalContainer: p
      }
    );
  };
  function N8(e, [t, n]) {
    return Math.min(n, Math.max(t, e));
  }
  var H0e = T.createContext(void 0);
  function s1(e) {
    const t = T.useContext(H0e);
    return e || t || "ltr";
  }
  function q0e(e) {
    const t = T.useRef({ value: e, previous: e });
    return T.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]);
  }
  var P8 = ["PageUp", "PageDown"], I8 = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], $8 = {
    "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
    "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
    "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
    "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
  }, Uf = "Slider", [vC, W0e, G0e] = Lb(Uf), [j8] = Qi(Uf, [
    G0e
  ]), [K0e, l1] = j8(Uf), D8 = T.forwardRef(
    (e, t) => {
      const {
        name: n,
        min: r = 0,
        max: o = 100,
        step: i = 1,
        orientation: a = "horizontal",
        disabled: s = !1,
        minStepsBetweenThumbs: c = 0,
        defaultValue: u = [r],
        value: d,
        onValueChange: p = () => {
        },
        onValueCommit: m = () => {
        },
        inverted: g = !1,
        form: y,
        ...b
      } = e, v = T.useRef(/* @__PURE__ */ new Set()), x = T.useRef(0), _ = a === "horizontal" ? Y0e : X0e, [C = [], k] = hl({
        prop: d,
        defaultProp: u,
        onChange: (L) => {
          [...v.current][x.current]?.focus(), p(L);
        }
      }), A = T.useRef(C);
      function O(L) {
        const N = tbe(C, L);
        $(L, N);
      }
      function P(L) {
        $(L, x.current);
      }
      function I() {
        const L = A.current[x.current];
        C[x.current] !== L && m(C);
      }
      function $(L, N, { commit: U } = { commit: !1 }) {
        const j = ibe(i), V = abe(Math.round((L - r) / i) * i + r, j), F = N8(V, [r, o]);
        k((K = []) => {
          const W = J0e(K, F, N);
          if (obe(W, c * i)) {
            x.current = W.indexOf(F);
            const Y = String(W) !== String(K);
            return Y && U && m(W), Y ? W : K;
          } else
            return K;
        });
      }
      return /* @__PURE__ */ S.jsx(
        K0e,
        {
          scope: e.__scopeSlider,
          name: n,
          disabled: s,
          min: r,
          max: o,
          valueIndexToChangeRef: x,
          thumbs: v.current,
          values: C,
          orientation: a,
          form: y,
          children: /* @__PURE__ */ S.jsx(vC.Provider, { scope: e.__scopeSlider, children: /* @__PURE__ */ S.jsx(vC.Slot, { scope: e.__scopeSlider, children: /* @__PURE__ */ S.jsx(
            _,
            {
              "aria-disabled": s,
              "data-disabled": s ? "" : void 0,
              ...b,
              ref: t,
              onPointerDown: Le(b.onPointerDown, () => {
                s || (A.current = C);
              }),
              min: r,
              max: o,
              inverted: g,
              onSlideStart: s ? void 0 : O,
              onSlideMove: s ? void 0 : P,
              onSlideEnd: s ? void 0 : I,
              onHomeKeyDown: () => !s && $(r, 0, { commit: !0 }),
              onEndKeyDown: () => !s && $(o, C.length - 1, { commit: !0 }),
              onStepKeyDown: ({ event: L, direction: N }) => {
                if (!s) {
                  const V = P8.includes(L.key) || L.shiftKey && I8.includes(L.key) ? 10 : 1, F = x.current, K = C[F], W = i * V * N;
                  $(K + W, F, { commit: !0 });
                }
              }
            }
          ) }) })
        }
      );
    }
  );
  D8.displayName = Uf;
  var [F8, L8] = j8(Uf, {
    startEdge: "left",
    endEdge: "right",
    size: "width",
    direction: 1
  }), Y0e = T.forwardRef(
    (e, t) => {
      const {
        min: n,
        max: r,
        dir: o,
        inverted: i,
        onSlideStart: a,
        onSlideMove: s,
        onSlideEnd: c,
        onStepKeyDown: u,
        ...d
      } = e, [p, m] = T.useState(null), g = un(t, (_) => m(_)), y = T.useRef(void 0), b = s1(o), v = b === "ltr", x = v && !i || !v && i;
      function E(_) {
        const C = y.current || p.getBoundingClientRect(), k = [0, C.width], O = WT(k, x ? [n, r] : [r, n]);
        return y.current = C, O(_ - C.left);
      }
      return /* @__PURE__ */ S.jsx(
        F8,
        {
          scope: e.__scopeSlider,
          startEdge: x ? "left" : "right",
          endEdge: x ? "right" : "left",
          direction: x ? 1 : -1,
          size: "width",
          children: /* @__PURE__ */ S.jsx(
            z8,
            {
              dir: b,
              "data-orientation": "horizontal",
              ...d,
              ref: g,
              style: {
                ...d.style,
                "--radix-slider-thumb-transform": "translateX(-50%)"
              },
              onSlideStart: (_) => {
                const C = E(_.clientX);
                a?.(C);
              },
              onSlideMove: (_) => {
                const C = E(_.clientX);
                s?.(C);
              },
              onSlideEnd: () => {
                y.current = void 0, c?.();
              },
              onStepKeyDown: (_) => {
                const k = $8[x ? "from-left" : "from-right"].includes(_.key);
                u?.({ event: _, direction: k ? -1 : 1 });
              }
            }
          )
        }
      );
    }
  ), X0e = T.forwardRef(
    (e, t) => {
      const {
        min: n,
        max: r,
        inverted: o,
        onSlideStart: i,
        onSlideMove: a,
        onSlideEnd: s,
        onStepKeyDown: c,
        ...u
      } = e, d = T.useRef(null), p = un(t, d), m = T.useRef(void 0), g = !o;
      function y(b) {
        const v = m.current || d.current.getBoundingClientRect(), x = [0, v.height], _ = WT(x, g ? [r, n] : [n, r]);
        return m.current = v, _(b - v.top);
      }
      return /* @__PURE__ */ S.jsx(
        F8,
        {
          scope: e.__scopeSlider,
          startEdge: g ? "bottom" : "top",
          endEdge: g ? "top" : "bottom",
          size: "height",
          direction: g ? 1 : -1,
          children: /* @__PURE__ */ S.jsx(
            z8,
            {
              "data-orientation": "vertical",
              ...u,
              ref: p,
              style: {
                ...u.style,
                "--radix-slider-thumb-transform": "translateY(50%)"
              },
              onSlideStart: (b) => {
                const v = y(b.clientY);
                i?.(v);
              },
              onSlideMove: (b) => {
                const v = y(b.clientY);
                a?.(v);
              },
              onSlideEnd: () => {
                m.current = void 0, s?.();
              },
              onStepKeyDown: (b) => {
                const x = $8[g ? "from-bottom" : "from-top"].includes(b.key);
                c?.({ event: b, direction: x ? -1 : 1 });
              }
            }
          )
        }
      );
    }
  ), z8 = T.forwardRef(
    (e, t) => {
      const {
        __scopeSlider: n,
        onSlideStart: r,
        onSlideMove: o,
        onSlideEnd: i,
        onHomeKeyDown: a,
        onEndKeyDown: s,
        onStepKeyDown: c,
        ...u
      } = e, d = l1(Uf, n);
      return /* @__PURE__ */ S.jsx(
        xt.span,
        {
          ...u,
          ref: t,
          onKeyDown: Le(e.onKeyDown, (p) => {
            p.key === "Home" ? (a(p), p.preventDefault()) : p.key === "End" ? (s(p), p.preventDefault()) : P8.concat(I8).includes(p.key) && (c(p), p.preventDefault());
          }),
          onPointerDown: Le(e.onPointerDown, (p) => {
            const m = p.target;
            m.setPointerCapture(p.pointerId), p.preventDefault(), d.thumbs.has(m) ? m.focus() : r(p);
          }),
          onPointerMove: Le(e.onPointerMove, (p) => {
            p.target.hasPointerCapture(p.pointerId) && o(p);
          }),
          onPointerUp: Le(e.onPointerUp, (p) => {
            const m = p.target;
            m.hasPointerCapture(p.pointerId) && (m.releasePointerCapture(p.pointerId), i(p));
          })
        }
      );
    }
  ), B8 = "SliderTrack", U8 = T.forwardRef(
    (e, t) => {
      const { __scopeSlider: n, ...r } = e, o = l1(B8, n);
      return /* @__PURE__ */ S.jsx(
        xt.span,
        {
          "data-disabled": o.disabled ? "" : void 0,
          "data-orientation": o.orientation,
          ...r,
          ref: t
        }
      );
    }
  );
  U8.displayName = B8;
  var bC = "SliderRange", V8 = T.forwardRef(
    (e, t) => {
      const { __scopeSlider: n, ...r } = e, o = l1(bC, n), i = L8(bC, n), a = T.useRef(null), s = un(t, a), c = o.values.length, u = o.values.map(
        (m) => W8(m, o.min, o.max)
      ), d = c > 1 ? Math.min(...u) : 0, p = 100 - Math.max(...u);
      return /* @__PURE__ */ S.jsx(
        xt.span,
        {
          "data-orientation": o.orientation,
          "data-disabled": o.disabled ? "" : void 0,
          ...r,
          ref: s,
          style: {
            ...e.style,
            [i.startEdge]: d + "%",
            [i.endEdge]: p + "%"
          }
        }
      );
    }
  );
  V8.displayName = bC;
  var xC = "SliderThumb", H8 = T.forwardRef(
    (e, t) => {
      const n = W0e(e.__scopeSlider), [r, o] = T.useState(null), i = un(t, (s) => o(s)), a = T.useMemo(
        () => r ? n().findIndex((s) => s.ref.current === r) : -1,
        [n, r]
      );
      return /* @__PURE__ */ S.jsx(Z0e, { ...e, ref: i, index: a });
    }
  ), Z0e = T.forwardRef(
    (e, t) => {
      const { __scopeSlider: n, index: r, name: o, ...i } = e, a = l1(xC, n), s = L8(xC, n), [c, u] = T.useState(null), d = un(t, (E) => u(E)), p = c ? a.form || !!c.closest("form") : !0, m = Lz(c), g = a.values[r], y = g === void 0 ? 0 : W8(g, a.min, a.max), b = ebe(r, a.values.length), v = m?.[s.size], x = v ? nbe(v, y, s.direction) : 0;
      return T.useEffect(() => {
        if (c)
          return a.thumbs.add(c), () => {
            a.thumbs.delete(c);
          };
      }, [c, a.thumbs]), /* @__PURE__ */ S.jsxs(
        "span",
        {
          style: {
            transform: "var(--radix-slider-thumb-transform)",
            position: "absolute",
            [s.startEdge]: `calc(${y}% + ${x}px)`
          },
          children: [
            /* @__PURE__ */ S.jsx(vC.ItemSlot, { scope: e.__scopeSlider, children: /* @__PURE__ */ S.jsx(
              xt.span,
              {
                role: "slider",
                "aria-label": e["aria-label"] || b,
                "aria-valuemin": a.min,
                "aria-valuenow": g,
                "aria-valuemax": a.max,
                "aria-orientation": a.orientation,
                "data-orientation": a.orientation,
                "data-disabled": a.disabled ? "" : void 0,
                tabIndex: a.disabled ? void 0 : 0,
                ...i,
                ref: d,
                style: g === void 0 ? { display: "none" } : e.style,
                onFocus: Le(e.onFocus, () => {
                  a.valueIndexToChangeRef.current = r;
                })
              }
            ) }),
            p && /* @__PURE__ */ S.jsx(
              q8,
              {
                name: o ?? (a.name ? a.name + (a.values.length > 1 ? "[]" : "") : void 0),
                form: a.form,
                value: g
              },
              r
            )
          ]
        }
      );
    }
  );
  H8.displayName = xC;
  var Q0e = "RadioBubbleInput", q8 = T.forwardRef(
    ({ __scopeSlider: e, value: t, ...n }, r) => {
      const o = T.useRef(null), i = un(o, r), a = q0e(t);
      return T.useEffect(() => {
        const s = o.current;
        if (!s) return;
        const c = window.HTMLInputElement.prototype, d = Object.getOwnPropertyDescriptor(c, "value").set;
        if (a !== t && d) {
          const p = new Event("input", { bubbles: !0 });
          d.call(s, t), s.dispatchEvent(p);
        }
      }, [a, t]), /* @__PURE__ */ S.jsx(
        xt.input,
        {
          style: { display: "none" },
          ...n,
          ref: i,
          defaultValue: t
        }
      );
    }
  );
  q8.displayName = Q0e;
  function J0e(e = [], t, n) {
    const r = [...e];
    return r[n] = t, r.sort((o, i) => o - i);
  }
  function W8(e, t, n) {
    const i = 100 / (n - t) * (e - t);
    return N8(i, [0, 100]);
  }
  function ebe(e, t) {
    return t > 2 ? `Value ${e + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][e] : void 0;
  }
  function tbe(e, t) {
    if (e.length === 1) return 0;
    const n = e.map((o) => Math.abs(o - t)), r = Math.min(...n);
    return n.indexOf(r);
  }
  function nbe(e, t, n) {
    const r = e / 2, i = WT([0, 50], [0, r]);
    return (r - i(t) * n) * n;
  }
  function rbe(e) {
    return e.slice(0, -1).map((t, n) => e[n + 1] - t);
  }
  function obe(e, t) {
    if (t > 0) {
      const n = rbe(e);
      return Math.min(...n) >= t;
    }
    return !0;
  }
  function WT(e, t) {
    return (n) => {
      if (e[0] === e[1] || t[0] === t[1]) return t[0];
      const r = (t[1] - t[0]) / (e[1] - e[0]);
      return t[0] + r * (n - e[0]);
    };
  }
  function ibe(e) {
    return (String(e).split(".")[1] || "").length;
  }
  function abe(e, t) {
    const n = Math.pow(10, t);
    return Math.round(e * n) / n;
  }
  var sbe = D8, lbe = U8, cbe = V8, ube = H8;
  function fbe(e) {
    return e === 0 ? 0 : Math.abs(e) < 1e-12 ? e : Number(e.toPrecision(12));
  }
  const G8 = ({
    inputconverter: e,
    parser: t = (n) => parseFloat(n)
  }) => {
    const n = En(), { preview: r } = n.valuestore(), o = n.use(), i = kc(o), [a, s] = T.useState(
      e[1](r?.value)
    );
    T.useEffect(() => {
      s(e[1](r?.value));
    }, [r]);
    const c = T.useCallback(
      (g) => {
        g = t(
          parseFloat(g.toString()).toString()
          // parse float first for e notation
        ), isNaN(g) ? (g = "<NoValue>", s("")) : (o.value_options?.min !== void 0 && g < o.value_options.min && (g = o.value_options.min), o.value_options?.max !== void 0 && g > o.value_options.max && (g = o.value_options.max), g = fbe(g), s(g.toString()));
        try {
          g = e[0](g);
        } catch {
        }
        g !== r?.value && i(g);
      },
      [o, e, i]
    ), u = T.useCallback(
      (g) => {
        c(g.target.value);
      },
      [c]
    );
    let d = o.connected ? e[1](r?.value) : a;
    d === void 0 && (d = o.value_options?.min), d === void 0 && (d = o.value_options?.max), d === void 0 && (d = ""), d === null && (d = "");
    let p = null, m = 1;
    return o.value_options?.step !== void 0 ? m = o.value_options.step : o.value_options?.max !== void 0 && o.value_options?.min !== void 0 && (m = (o.value_options?.max - o.value_options?.min) / 1e3), o.value_options?.max !== void 0 && o.value_options?.min !== void 0 && !o.connected && (p = /* @__PURE__ */ S.jsx("div", { style: { minWidth: "6.25rem" }, className: "SliderContainer", children: /* @__PURE__ */ S.jsxs(
      sbe,
      {
        className: "SliderRoot",
        value: [d === void 0 ? o.value_options?.min : d],
        min: o.value_options?.min,
        max: o.value_options?.max,
        step: m,
        disabled: o.connected,
        onValueCommit: (g) => {
          isNaN(g[0]) || c(g[0]);
        },
        onValueChange: (g) => {
          isNaN(g[0]) || s(g[0].toString());
        },
        onKeyDown: (g) => {
          ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(
            g.key
          ) && g.stopPropagation();
        },
        children: [
          /* @__PURE__ */ S.jsx(lbe, { className: "SliderTrack", children: /* @__PURE__ */ S.jsx(cbe, { className: "SliderRange" }) }),
          /* @__PURE__ */ S.jsx(ube, { className: "SliderThumb" })
        ]
      }
    ) })), /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      p,
      /* @__PURE__ */ S.jsx(
        "input",
        {
          type: "text",
          className: "nodedatainput styledinput numberinput",
          value: d,
          onChange: (g) => s(g.target.value),
          onBlur: u,
          step: m,
          onKeyDown: (g) => {
            if (!(g.ctrlKey || g.metaKey)) {
              if (g.key === "ArrowUp") {
                g.shiftKey && (m *= 10);
                let y = (parseFloat(d) || 0) + m;
                c(y);
                return;
              }
              if (g.key === "ArrowDown") {
                g.shiftKey && (m *= 10);
                let y = (parseFloat(d) || 0) - m;
                c(y);
                return;
              }
              !/^[0-9.eE+-]$/.test(g.key) && !["Backspace", "ArrowLeft", "ArrowRight", "Delete", "Tab"].includes(
                g.key
              ) && g.preventDefault();
            }
          },
          disabled: o.connected,
          min: o.value_options?.min,
          max: o.value_options?.max
        }
      )
    ] });
  }, dbe = ({ inputconverter: e }) => G8({ inputconverter: e, parser: parseFloat }), pbe = ({ inputconverter: e }) => G8({ inputconverter: e, parser: parseInt }), hbe = (e) => e, mbe = (e) => parseFloat(e), gbe = (e) => !!e, ybe = (e) => e === "null" ? null : e, vbe = (e) => e === "nuinputconvertermber" ? mbe : e === "boolean" ? gbe : e === "undefined" ? ybe : hbe, dh = ({
    inputconverter: e,
    parser: t
  }) => {
    const n = En(), r = n.use(), { preview: o, full: i } = n.valuestore(), a = i === void 0 ? o?.value : i.value, s = kc(r);
    let c = r.value_options?.options || [];
    Array.isArray(c) && (c = {
      type: "enum",
      values: c,
      keys: c.map((b) => b === null ? "None" : b.toString()),
      nullable: !1
    }), c.type !== "enum" && (c = {
      type: "enum",
      values: Object.values(c),
      keys: Object.keys(c),
      nullable: !1
    }), c = c, c.nullable && !c.values.includes(null) && !c.keys.includes("None") && (c.values.unshift(null), c.keys.unshift("None"));
    const u = [];
    for (let b = 0; b < c.values.length; b++) {
      const v = c.values[b] === null || c.values[b] === void 0 ? "undefined" : typeof c.values[b];
      let x = c.values[b];
      x === null && (x = "null"), x === void 0 && (x = "undefined"), u.push([c.keys[b], x.toString(), v]);
    }
    const d = T.useCallback(
      ({
        value: b,
        // label
        datatype: v
      }) => {
        let E = (t || vbe(v))(b);
        try {
          E = e[0](b);
        } catch {
        }
        s(E);
      },
      [r, e, s]
    );
    let p = a;
    p === null && (p = "null"), p === void 0 && (p = "undefined");
    const m = u.find((b) => b[1] === p.toString());
    let g;
    m !== void 0 && (g = {
      value: m[1],
      label: m[0],
      datatype: m[2]
    });
    const y = u.map(
      (b) => ({
        value: b[1],
        label: b[0],
        datatype: b[2]
      })
    );
    return (
      // <Suspense fallback={<select disabled={true}></select>}>
      /* @__PURE__ */ S.jsx(
        mce,
        {
          className: "nodedatainput styleddropdown",
          options: y,
          defaultValue: g,
          onChange: (b) => {
            if (b === null) {
              d({
                value: "<NoValue>",
                datatype: "string"
              });
              return;
            }
            d(b);
          }
        }
      )
    );
  }, kj = ({ inputconverter: e }) => {
    const t = En(), { preview: n, full: r } = t.valuestore(), o = t.use(), i = r === void 0 ? n?.value : r?.value, a = kc(o), [s, c] = T.useState(e[1](i));
    T.useEffect(() => {
      c(e[1](i));
    }, [i]);
    const u = T.useCallback(
      (g) => {
        let y = g.target.value;
        y || (y = "<NoValue>");
        try {
          y = e[0](y);
        } catch {
        }
        y !== i && a(y);
      },
      [a, e, i]
    );
    let d = o.connected ? e[1](i) : s;
    d == null && (d = ""), d = d.toString();
    const p = (d.toString().match(/\n/g) || []).length, m = Math.max(...d.split(`
`).map((g) => g.length), 0);
    return /* @__PURE__ */ S.jsx(
      "textarea",
      {
        className: "nodedatainput styledinput stringinput",
        value: d,
        onChange: (g) => c(g.target.value),
        onBlur: (g) => {
          u(g);
        },
        disabled: o.connected,
        rows: p + 1,
        cols: m + 1
      }
    );
  };
  function Rt(e) {
    return typeof e != "object" || e === null || typeof e.lastModified == "number" && typeof File < "u" && e instanceof File || typeof e.getMonth == "function" && typeof Date < "u" && e instanceof Date ? !1 : !Array.isArray(e);
  }
  function bbe(e) {
    return e.additionalItems === !0 && console.warn("additionalItems=true is currently not supported"), Rt(e.additionalItems);
  }
  function Tj(e) {
    if (e === "")
      return;
    if (e === null)
      return null;
    if (/\.$/.test(e) || /\.0$/.test(e) || /\.\d*0$/.test(e))
      return e;
    const t = Number(e);
    return typeof t == "number" && !Number.isNaN(t) ? t : e;
  }
  const Ba = "__additional_property", I0 = "additionalProperties", ul = "allOf", Nt = "anyOf", Io = "const", c1 = "default", GT = "dependencies", xbe = "enum", ur = "__errors", rn = "$id", wbe = "if", Cf = "items", Sbe = "_$junk_option_schema_id$_", Vv = "$name", yt = "oneOf", wC = "patternProperties", Ft = "properties", l_ = "readonly", K8 = "required", $0 = "submitButtonOptions", bn = "$ref", xp = "$schema", Y8 = "root", X8 = "_", _be = ["discriminator", "propertyName"], Aj = "formContext", Ebe = "layoutGridLookupMap", KT = "__rjsf_additionalProperties", Z8 = "__rjsf_rootSchema", Cbe = "ui:field", YT = "ui:widget", Zs = "ui:options", SC = "ui:globalOptions", kbe = "https://json-schema.org/draft/2019-09/schema", Hv = "https://json-schema.org/draft/2020-12/schema";
  function Qe(e = {}, t = {}) {
    return e ? Object.keys(e).filter((n) => n.indexOf("ui:") === 0).reduce((n, r) => {
      const o = e[r];
      return r === YT && Rt(o) ? (console.error("Setting options via ui:widget object is no longer supported, use ui:options instead"), n) : r === Zs && Rt(o) ? { ...n, ...o } : { ...n, [r.substring(3)]: o };
    }, { ...t }) : { ...t };
  }
  function Q8(e, t = {}, n) {
    if (!(e.additionalProperties || e.patternProperties))
      return !1;
    const { expandable: r = !0 } = Qe(t);
    return r === !1 ? r : e.maxProperties !== void 0 && n ? Object.keys(n).length < e.maxProperties : !0;
  }
  var J8 = typeof window == "object" && window && window.Object === Object && window, Tbe = typeof self == "object" && self && self.Object === Object && self, na = J8 || Tbe || Function("return this")(), $o = na.Symbol, eU = Object.prototype, Abe = eU.hasOwnProperty, Rbe = eU.toString, Zd = $o ? $o.toStringTag : void 0;
  function Obe(e) {
    var t = Abe.call(e, Zd), n = e[Zd];
    try {
      e[Zd] = void 0;
      var r = !0;
    } catch {
    }
    var o = Rbe.call(e);
    return r && (t ? e[Zd] = n : delete e[Zd]), o;
  }
  var Mbe = Object.prototype, Nbe = Mbe.toString;
  function Pbe(e) {
    return Nbe.call(e);
  }
  var Ibe = "[object Null]", $be = "[object Undefined]", Rj = $o ? $o.toStringTag : void 0;
  function rs(e) {
    return e == null ? e === void 0 ? $be : Ibe : Rj && Rj in Object(e) ? Obe(e) : Pbe(e);
  }
  function tU(e, t) {
    return function(n) {
      return e(t(n));
    };
  }
  var u1 = tU(Object.getPrototypeOf, Object);
  function jo(e) {
    return e != null && typeof e == "object";
  }
  var jbe = "[object Object]", Dbe = Function.prototype, Fbe = Object.prototype, nU = Dbe.toString, Lbe = Fbe.hasOwnProperty, zbe = nU.call(Object);
  function fl(e) {
    if (!jo(e) || rs(e) != jbe)
      return !1;
    var t = u1(e);
    if (t === null)
      return !0;
    var n = Lbe.call(t, "constructor") && t.constructor;
    return typeof n == "function" && n instanceof n && nU.call(n) == zbe;
  }
  function _C(e) {
    const t = {
      // We store the list of errors for this node in a property named __errors
      // to avoid name collision with a possible sub schema field named
      // 'errors' (see `utils.toErrorSchema`).
      [ur]: [],
      addError(n) {
        this[ur].push(n);
      }
    };
    if (Array.isArray(e))
      return e.reduce((n, r, o) => ({ ...n, [o]: _C(r) }), t);
    if (fl(e)) {
      const n = e;
      return Object.keys(n).reduce((r, o) => ({ ...r, [o]: _C(n[o]) }), t);
    }
    return t;
  }
  function Bbe() {
    this.__data__ = [], this.size = 0;
  }
  function am(e, t) {
    return e === t || e !== e && t !== t;
  }
  function f1(e, t) {
    for (var n = e.length; n--; )
      if (am(e[n][0], t))
        return n;
    return -1;
  }
  var Ube = Array.prototype, Vbe = Ube.splice;
  function Hbe(e) {
    var t = this.__data__, n = f1(t, e);
    if (n < 0)
      return !1;
    var r = t.length - 1;
    return n == r ? t.pop() : Vbe.call(t, n, 1), --this.size, !0;
  }
  function qbe(e) {
    var t = this.__data__, n = f1(t, e);
    return n < 0 ? void 0 : t[n][1];
  }
  function Wbe(e) {
    return f1(this.__data__, e) > -1;
  }
  function Gbe(e, t) {
    var n = this.__data__, r = f1(n, e);
    return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this;
  }
  function os(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
      var r = e[t];
      this.set(r[0], r[1]);
    }
  }
  os.prototype.clear = Bbe;
  os.prototype.delete = Hbe;
  os.prototype.get = qbe;
  os.prototype.has = Wbe;
  os.prototype.set = Gbe;
  function Kbe() {
    this.__data__ = new os(), this.size = 0;
  }
  function Ybe(e) {
    var t = this.__data__, n = t.delete(e);
    return this.size = t.size, n;
  }
  function Xbe(e) {
    return this.__data__.get(e);
  }
  function Zbe(e) {
    return this.__data__.has(e);
  }
  function $t(e) {
    var t = typeof e;
    return e != null && (t == "object" || t == "function");
  }
  var Qbe = "[object AsyncFunction]", Jbe = "[object Function]", e1e = "[object GeneratorFunction]", t1e = "[object Proxy]";
  function sm(e) {
    if (!$t(e))
      return !1;
    var t = rs(e);
    return t == Jbe || t == e1e || t == Qbe || t == t1e;
  }
  var c_ = na["__core-js_shared__"], Oj = (function() {
    var e = /[^.]+$/.exec(c_ && c_.keys && c_.keys.IE_PROTO || "");
    return e ? "Symbol(src)_1." + e : "";
  })();
  function n1e(e) {
    return !!Oj && Oj in e;
  }
  var r1e = Function.prototype, o1e = r1e.toString;
  function Tc(e) {
    if (e != null) {
      try {
        return o1e.call(e);
      } catch {
      }
      try {
        return e + "";
      } catch {
      }
    }
    return "";
  }
  var i1e = /[\\^$.*+?()[\]{}|]/g, a1e = /^\[object .+?Constructor\]$/, s1e = Function.prototype, l1e = Object.prototype, c1e = s1e.toString, u1e = l1e.hasOwnProperty, f1e = RegExp(
    "^" + c1e.call(u1e).replace(i1e, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function d1e(e) {
    if (!$t(e) || n1e(e))
      return !1;
    var t = sm(e) ? f1e : a1e;
    return t.test(Tc(e));
  }
  function p1e(e, t) {
    return e?.[t];
  }
  function Ac(e, t) {
    var n = p1e(e, t);
    return d1e(n) ? n : void 0;
  }
  var ph = Ac(na, "Map"), hh = Ac(Object, "create");
  function h1e() {
    this.__data__ = hh ? hh(null) : {}, this.size = 0;
  }
  function m1e(e) {
    var t = this.has(e) && delete this.__data__[e];
    return this.size -= t ? 1 : 0, t;
  }
  var g1e = "__lodash_hash_undefined__", y1e = Object.prototype, v1e = y1e.hasOwnProperty;
  function b1e(e) {
    var t = this.__data__;
    if (hh) {
      var n = t[e];
      return n === g1e ? void 0 : n;
    }
    return v1e.call(t, e) ? t[e] : void 0;
  }
  var x1e = Object.prototype, w1e = x1e.hasOwnProperty;
  function S1e(e) {
    var t = this.__data__;
    return hh ? t[e] !== void 0 : w1e.call(t, e);
  }
  var _1e = "__lodash_hash_undefined__";
  function E1e(e, t) {
    var n = this.__data__;
    return this.size += this.has(e) ? 0 : 1, n[e] = hh && t === void 0 ? _1e : t, this;
  }
  function vc(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
      var r = e[t];
      this.set(r[0], r[1]);
    }
  }
  vc.prototype.clear = h1e;
  vc.prototype.delete = m1e;
  vc.prototype.get = b1e;
  vc.prototype.has = S1e;
  vc.prototype.set = E1e;
  function C1e() {
    this.size = 0, this.__data__ = {
      hash: new vc(),
      map: new (ph || os)(),
      string: new vc()
    };
  }
  function k1e(e) {
    var t = typeof e;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
  }
  function d1(e, t) {
    var n = e.__data__;
    return k1e(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
  }
  function T1e(e) {
    var t = d1(this, e).delete(e);
    return this.size -= t ? 1 : 0, t;
  }
  function A1e(e) {
    return d1(this, e).get(e);
  }
  function R1e(e) {
    return d1(this, e).has(e);
  }
  function O1e(e, t) {
    var n = d1(this, e), r = n.size;
    return n.set(e, t), this.size += n.size == r ? 0 : 1, this;
  }
  function is(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.clear(); ++t < n; ) {
      var r = e[t];
      this.set(r[0], r[1]);
    }
  }
  is.prototype.clear = C1e;
  is.prototype.delete = T1e;
  is.prototype.get = A1e;
  is.prototype.has = R1e;
  is.prototype.set = O1e;
  var M1e = 200;
  function N1e(e, t) {
    var n = this.__data__;
    if (n instanceof os) {
      var r = n.__data__;
      if (!ph || r.length < M1e - 1)
        return r.push([e, t]), this.size = ++n.size, this;
      n = this.__data__ = new is(r);
    }
    return n.set(e, t), this.size = n.size, this;
  }
  function Qo(e) {
    var t = this.__data__ = new os(e);
    this.size = t.size;
  }
  Qo.prototype.clear = Kbe;
  Qo.prototype.delete = Ybe;
  Qo.prototype.get = Xbe;
  Qo.prototype.has = Zbe;
  Qo.prototype.set = N1e;
  var P1e = "__lodash_hash_undefined__";
  function I1e(e) {
    return this.__data__.set(e, P1e), this;
  }
  function $1e(e) {
    return this.__data__.has(e);
  }
  function bc(e) {
    var t = -1, n = e == null ? 0 : e.length;
    for (this.__data__ = new is(); ++t < n; )
      this.add(e[t]);
  }
  bc.prototype.add = bc.prototype.push = I1e;
  bc.prototype.has = $1e;
  function j1e(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length; ++n < r; )
      if (t(e[n], n, e))
        return !0;
    return !1;
  }
  function mh(e, t) {
    return e.has(t);
  }
  var D1e = 1, F1e = 2;
  function rU(e, t, n, r, o, i) {
    var a = n & D1e, s = e.length, c = t.length;
    if (s != c && !(a && c > s))
      return !1;
    var u = i.get(e), d = i.get(t);
    if (u && d)
      return u == t && d == e;
    var p = -1, m = !0, g = n & F1e ? new bc() : void 0;
    for (i.set(e, t), i.set(t, e); ++p < s; ) {
      var y = e[p], b = t[p];
      if (r)
        var v = a ? r(b, y, p, t, e, i) : r(y, b, p, e, t, i);
      if (v !== void 0) {
        if (v)
          continue;
        m = !1;
        break;
      }
      if (g) {
        if (!j1e(t, function(x, E) {
          if (!mh(g, E) && (y === x || o(y, x, n, r, i)))
            return g.push(E);
        })) {
          m = !1;
          break;
        }
      } else if (!(y === b || o(y, b, n, r, i))) {
        m = !1;
        break;
      }
    }
    return i.delete(e), i.delete(t), m;
  }
  var j0 = na.Uint8Array;
  function L1e(e) {
    var t = -1, n = Array(e.size);
    return e.forEach(function(r, o) {
      n[++t] = [o, r];
    }), n;
  }
  function XT(e) {
    var t = -1, n = Array(e.size);
    return e.forEach(function(r) {
      n[++t] = r;
    }), n;
  }
  var z1e = 1, B1e = 2, U1e = "[object Boolean]", V1e = "[object Date]", H1e = "[object Error]", q1e = "[object Map]", W1e = "[object Number]", G1e = "[object RegExp]", K1e = "[object Set]", Y1e = "[object String]", X1e = "[object Symbol]", Z1e = "[object ArrayBuffer]", Q1e = "[object DataView]", Mj = $o ? $o.prototype : void 0, u_ = Mj ? Mj.valueOf : void 0;
  function J1e(e, t, n, r, o, i, a) {
    switch (n) {
      case Q1e:
        if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
          return !1;
        e = e.buffer, t = t.buffer;
      case Z1e:
        return !(e.byteLength != t.byteLength || !i(new j0(e), new j0(t)));
      case U1e:
      case V1e:
      case W1e:
        return am(+e, +t);
      case H1e:
        return e.name == t.name && e.message == t.message;
      case G1e:
      case Y1e:
        return e == t + "";
      case q1e:
        var s = L1e;
      case K1e:
        var c = r & z1e;
        if (s || (s = XT), e.size != t.size && !c)
          return !1;
        var u = a.get(e);
        if (u)
          return u == t;
        r |= B1e, a.set(e, t);
        var d = rU(s(e), s(t), r, o, i, a);
        return a.delete(e), d;
      case X1e:
        if (u_)
          return u_.call(e) == u_.call(t);
    }
    return !1;
  }
  function ZT(e, t) {
    for (var n = -1, r = t.length, o = e.length; ++n < r; )
      e[o + n] = t[n];
    return e;
  }
  var Zn = Array.isArray;
  function oU(e, t, n) {
    var r = t(e);
    return Zn(e) ? r : ZT(r, n(e));
  }
  function exe(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length, o = 0, i = []; ++n < r; ) {
      var a = e[n];
      t(a, n, e) && (i[o++] = a);
    }
    return i;
  }
  function iU() {
    return [];
  }
  var txe = Object.prototype, nxe = txe.propertyIsEnumerable, Nj = Object.getOwnPropertySymbols, QT = Nj ? function(e) {
    return e == null ? [] : (e = Object(e), exe(Nj(e), function(t) {
      return nxe.call(e, t);
    }));
  } : iU;
  function aU(e, t) {
    for (var n = -1, r = Array(e); ++n < e; )
      r[n] = t(n);
    return r;
  }
  var rxe = "[object Arguments]";
  function Pj(e) {
    return jo(e) && rs(e) == rxe;
  }
  var sU = Object.prototype, oxe = sU.hasOwnProperty, ixe = sU.propertyIsEnumerable, kf = Pj(/* @__PURE__ */ (function() {
    return arguments;
  })()) ? Pj : function(e) {
    return jo(e) && oxe.call(e, "callee") && !ixe.call(e, "callee");
  };
  function axe() {
    return !1;
  }
  var lU = typeof ao == "object" && ao && !ao.nodeType && ao, Ij = lU && typeof so == "object" && so && !so.nodeType && so, sxe = Ij && Ij.exports === lU, $j = sxe ? na.Buffer : void 0, lxe = $j ? $j.isBuffer : void 0, xc = lxe || axe, cxe = 9007199254740991, uxe = /^(?:0|[1-9]\d*)$/;
  function p1(e, t) {
    var n = typeof e;
    return t = t ?? cxe, !!t && (n == "number" || n != "symbol" && uxe.test(e)) && e > -1 && e % 1 == 0 && e < t;
  }
  var fxe = 9007199254740991;
  function JT(e) {
    return typeof e == "number" && e > -1 && e % 1 == 0 && e <= fxe;
  }
  var dxe = "[object Arguments]", pxe = "[object Array]", hxe = "[object Boolean]", mxe = "[object Date]", gxe = "[object Error]", yxe = "[object Function]", vxe = "[object Map]", bxe = "[object Number]", xxe = "[object Object]", wxe = "[object RegExp]", Sxe = "[object Set]", _xe = "[object String]", Exe = "[object WeakMap]", Cxe = "[object ArrayBuffer]", kxe = "[object DataView]", Txe = "[object Float32Array]", Axe = "[object Float64Array]", Rxe = "[object Int8Array]", Oxe = "[object Int16Array]", Mxe = "[object Int32Array]", Nxe = "[object Uint8Array]", Pxe = "[object Uint8ClampedArray]", Ixe = "[object Uint16Array]", $xe = "[object Uint32Array]", yn = {};
  yn[Txe] = yn[Axe] = yn[Rxe] = yn[Oxe] = yn[Mxe] = yn[Nxe] = yn[Pxe] = yn[Ixe] = yn[$xe] = !0;
  yn[dxe] = yn[pxe] = yn[Cxe] = yn[hxe] = yn[kxe] = yn[mxe] = yn[gxe] = yn[yxe] = yn[vxe] = yn[bxe] = yn[xxe] = yn[wxe] = yn[Sxe] = yn[_xe] = yn[Exe] = !1;
  function jxe(e) {
    return jo(e) && JT(e.length) && !!yn[rs(e)];
  }
  function eA(e) {
    return function(t) {
      return e(t);
    };
  }
  var cU = typeof ao == "object" && ao && !ao.nodeType && ao, Ip = cU && typeof so == "object" && so && !so.nodeType && so, Dxe = Ip && Ip.exports === cU, f_ = Dxe && J8.process, Tf = (function() {
    try {
      var e = Ip && Ip.require && Ip.require("util").types;
      return e || f_ && f_.binding && f_.binding("util");
    } catch {
    }
  })(), jj = Tf && Tf.isTypedArray, lm = jj ? eA(jj) : jxe, Fxe = Object.prototype, Lxe = Fxe.hasOwnProperty;
  function uU(e, t) {
    var n = Zn(e), r = !n && kf(e), o = !n && !r && xc(e), i = !n && !r && !o && lm(e), a = n || r || o || i, s = a ? aU(e.length, String) : [], c = s.length;
    for (var u in e)
      (t || Lxe.call(e, u)) && !(a && // Safari 9 has enumerable `arguments.length` in strict mode.
      (u == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      o && (u == "offset" || u == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      i && (u == "buffer" || u == "byteLength" || u == "byteOffset") || // Skip index properties.
      p1(u, c))) && s.push(u);
    return s;
  }
  var zxe = Object.prototype;
  function h1(e) {
    var t = e && e.constructor, n = typeof t == "function" && t.prototype || zxe;
    return e === n;
  }
  var Bxe = tU(Object.keys, Object), Uxe = Object.prototype, Vxe = Uxe.hasOwnProperty;
  function fU(e) {
    if (!h1(e))
      return Bxe(e);
    var t = [];
    for (var n in Object(e))
      Vxe.call(e, n) && n != "constructor" && t.push(n);
    return t;
  }
  function Rc(e) {
    return e != null && JT(e.length) && !sm(e);
  }
  function Ko(e) {
    return Rc(e) ? uU(e) : fU(e);
  }
  function EC(e) {
    return oU(e, Ko, QT);
  }
  var Hxe = 1, qxe = Object.prototype, Wxe = qxe.hasOwnProperty;
  function Gxe(e, t, n, r, o, i) {
    var a = n & Hxe, s = EC(e), c = s.length, u = EC(t), d = u.length;
    if (c != d && !a)
      return !1;
    for (var p = c; p--; ) {
      var m = s[p];
      if (!(a ? m in t : Wxe.call(t, m)))
        return !1;
    }
    var g = i.get(e), y = i.get(t);
    if (g && y)
      return g == t && y == e;
    var b = !0;
    i.set(e, t), i.set(t, e);
    for (var v = a; ++p < c; ) {
      m = s[p];
      var x = e[m], E = t[m];
      if (r)
        var _ = a ? r(E, x, m, t, e, i) : r(x, E, m, e, t, i);
      if (!(_ === void 0 ? x === E || o(x, E, n, r, i) : _)) {
        b = !1;
        break;
      }
      v || (v = m == "constructor");
    }
    if (b && !v) {
      var C = e.constructor, k = t.constructor;
      C != k && "constructor" in e && "constructor" in t && !(typeof C == "function" && C instanceof C && typeof k == "function" && k instanceof k) && (b = !1);
    }
    return i.delete(e), i.delete(t), b;
  }
  var CC = Ac(na, "DataView"), kC = Ac(na, "Promise"), lf = Ac(na, "Set"), TC = Ac(na, "WeakMap"), Dj = "[object Map]", Kxe = "[object Object]", Fj = "[object Promise]", Lj = "[object Set]", zj = "[object WeakMap]", Bj = "[object DataView]", Yxe = Tc(CC), Xxe = Tc(ph), Zxe = Tc(kC), Qxe = Tc(lf), Jxe = Tc(TC), Ro = rs;
  (CC && Ro(new CC(new ArrayBuffer(1))) != Bj || ph && Ro(new ph()) != Dj || kC && Ro(kC.resolve()) != Fj || lf && Ro(new lf()) != Lj || TC && Ro(new TC()) != zj) && (Ro = function(e) {
    var t = rs(e), n = t == Kxe ? e.constructor : void 0, r = n ? Tc(n) : "";
    if (r)
      switch (r) {
        case Yxe:
          return Bj;
        case Xxe:
          return Dj;
        case Zxe:
          return Fj;
        case Qxe:
          return Lj;
        case Jxe:
          return zj;
      }
    return t;
  });
  var ewe = 1, Uj = "[object Arguments]", Vj = "[object Array]", _y = "[object Object]", twe = Object.prototype, Hj = twe.hasOwnProperty;
  function nwe(e, t, n, r, o, i) {
    var a = Zn(e), s = Zn(t), c = a ? Vj : Ro(e), u = s ? Vj : Ro(t);
    c = c == Uj ? _y : c, u = u == Uj ? _y : u;
    var d = c == _y, p = u == _y, m = c == u;
    if (m && xc(e)) {
      if (!xc(t))
        return !1;
      a = !0, d = !1;
    }
    if (m && !d)
      return i || (i = new Qo()), a || lm(e) ? rU(e, t, n, r, o, i) : J1e(e, t, c, n, r, o, i);
    if (!(n & ewe)) {
      var g = d && Hj.call(e, "__wrapped__"), y = p && Hj.call(t, "__wrapped__");
      if (g || y) {
        var b = g ? e.value() : e, v = y ? t.value() : t;
        return i || (i = new Qo()), o(b, v, n, r, i);
      }
    }
    return m ? (i || (i = new Qo()), Gxe(e, t, n, r, o, i)) : !1;
  }
  function cm(e, t, n, r, o) {
    return e === t ? !0 : e == null || t == null || !jo(e) && !jo(t) ? e !== e && t !== t : nwe(e, t, n, r, cm, o);
  }
  function rwe(e, t, n) {
    n = typeof n == "function" ? n : void 0;
    var r = n ? n(e, t) : void 0;
    return r === void 0 ? cm(e, t, void 0, n) : !!r;
  }
  function pn(e, t) {
    return rwe(e, t, (n, r) => {
      if (typeof n == "function" && typeof r == "function")
        return !0;
    });
  }
  var owe = "[object Symbol]";
  function um(e) {
    return typeof e == "symbol" || jo(e) && rs(e) == owe;
  }
  var iwe = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, awe = /^\w*$/;
  function tA(e, t) {
    if (Zn(e))
      return !1;
    var n = typeof e;
    return n == "number" || n == "symbol" || n == "boolean" || e == null || um(e) ? !0 : awe.test(e) || !iwe.test(e) || t != null && e in Object(t);
  }
  var swe = "Expected a function";
  function nA(e, t) {
    if (typeof e != "function" || t != null && typeof t != "function")
      throw new TypeError(swe);
    var n = function() {
      var r = arguments, o = t ? t.apply(this, r) : r[0], i = n.cache;
      if (i.has(o))
        return i.get(o);
      var a = e.apply(this, r);
      return n.cache = i.set(o, a) || i, a;
    };
    return n.cache = new (nA.Cache || is)(), n;
  }
  nA.Cache = is;
  var lwe = 500;
  function cwe(e) {
    var t = nA(e, function(r) {
      return n.size === lwe && n.clear(), r;
    }), n = t.cache;
    return t;
  }
  var uwe = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, fwe = /\\(\\)?/g, dU = cwe(function(e) {
    var t = [];
    return e.charCodeAt(0) === 46 && t.push(""), e.replace(uwe, function(n, r, o, i) {
      t.push(o ? i.replace(fwe, "$1") : r || n);
    }), t;
  });
  function Vf(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length, o = Array(r); ++n < r; )
      o[n] = t(e[n], n, e);
    return o;
  }
  var qj = $o ? $o.prototype : void 0, Wj = qj ? qj.toString : void 0;
  function pU(e) {
    if (typeof e == "string")
      return e;
    if (Zn(e))
      return Vf(e, pU) + "";
    if (um(e))
      return Wj ? Wj.call(e) : "";
    var t = e + "";
    return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
  }
  function rA(e) {
    return e == null ? "" : pU(e);
  }
  function Hf(e, t) {
    return Zn(e) ? e : tA(e, t) ? [e] : dU(rA(e));
  }
  function Oc(e) {
    if (typeof e == "string" || um(e))
      return e;
    var t = e + "";
    return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
  }
  function m1(e, t) {
    t = Hf(t, e);
    for (var n = 0, r = t.length; e != null && n < r; )
      e = e[Oc(t[n++])];
    return n && n == r ? e : void 0;
  }
  function Ee(e, t, n) {
    var r = e == null ? void 0 : m1(e, t);
    return r === void 0 ? n : r;
  }
  var dwe = Object.prototype, pwe = dwe.hasOwnProperty;
  function hwe(e, t) {
    return e != null && pwe.call(e, t);
  }
  function hU(e, t, n) {
    t = Hf(t, e);
    for (var r = -1, o = t.length, i = !1; ++r < o; ) {
      var a = Oc(t[r]);
      if (!(i = e != null && n(e, a)))
        break;
      e = e[a];
    }
    return i || ++r != o ? i : (o = e == null ? 0 : e.length, !!o && JT(o) && p1(a, o) && (Zn(e) || kf(e)));
  }
  function Tt(e, t) {
    return e != null && hU(e, t, hwe);
  }
  function gh(e, t) {
    return cm(e, t);
  }
  var D0 = (function() {
    try {
      var e = Ac(Object, "defineProperty");
      return e({}, "", {}), e;
    } catch {
    }
  })();
  function oA(e, t, n) {
    t == "__proto__" && D0 ? D0(e, t, {
      configurable: !0,
      enumerable: !0,
      value: n,
      writable: !0
    }) : e[t] = n;
  }
  var mwe = Object.prototype, gwe = mwe.hasOwnProperty;
  function iA(e, t, n) {
    var r = e[t];
    (!(gwe.call(e, t) && am(r, n)) || n === void 0 && !(t in e)) && oA(e, t, n);
  }
  function aA(e, t, n, r) {
    if (!$t(e))
      return e;
    t = Hf(t, e);
    for (var o = -1, i = t.length, a = i - 1, s = e; s != null && ++o < i; ) {
      var c = Oc(t[o]), u = n;
      if (c === "__proto__" || c === "constructor" || c === "prototype")
        return e;
      if (o != a) {
        var d = s[c];
        u = r ? r(d, c, s) : void 0, u === void 0 && (u = $t(d) ? d : p1(t[o + 1]) ? [] : {});
      }
      iA(s, c, u), s = s[c];
    }
    return e;
  }
  function Qt(e, t, n) {
    return e == null ? e : aA(e, t, n);
  }
  function g1(e) {
    return e;
  }
  function mU(e) {
    return typeof e == "function" ? e : g1;
  }
  var ywe = /\s/;
  function vwe(e) {
    for (var t = e.length; t-- && ywe.test(e.charAt(t)); )
      ;
    return t;
  }
  var bwe = /^\s+/;
  function xwe(e) {
    return e && e.slice(0, vwe(e) + 1).replace(bwe, "");
  }
  var Gj = NaN, wwe = /^[-+]0x[0-9a-f]+$/i, Swe = /^0b[01]+$/i, _we = /^0o[0-7]+$/i, Ewe = parseInt;
  function Cwe(e) {
    if (typeof e == "number")
      return e;
    if (um(e))
      return Gj;
    if ($t(e)) {
      var t = typeof e.valueOf == "function" ? e.valueOf() : e;
      e = $t(t) ? t + "" : t;
    }
    if (typeof e != "string")
      return e === 0 ? e : +e;
    e = xwe(e);
    var n = Swe.test(e);
    return n || _we.test(e) ? Ewe(e.slice(2), n ? 2 : 8) : wwe.test(e) ? Gj : +e;
  }
  var Kj = 1 / 0, kwe = 17976931348623157e292;
  function Twe(e) {
    if (!e)
      return e === 0 ? e : 0;
    if (e = Cwe(e), e === Kj || e === -Kj) {
      var t = e < 0 ? -1 : 1;
      return t * kwe;
    }
    return e === e ? e : 0;
  }
  function gU(e) {
    var t = Twe(e), n = t % 1;
    return t === t ? n ? t - n : t : 0;
  }
  var Awe = 9007199254740991, d_ = 4294967295, Rwe = Math.min;
  function yU(e, t) {
    if (e = gU(e), e < 1 || e > Awe)
      return [];
    var n = d_, r = Rwe(e, d_);
    t = mU(t), e -= d_;
    for (var o = aU(r, t); ++n < e; )
      t(n);
    return o;
  }
  function sA(e, t) {
    for (var n = -1, r = e == null ? 0 : e.length; ++n < r && t(e[n], n, e) !== !1; )
      ;
    return e;
  }
  var Yj = Object.create, vU = /* @__PURE__ */ (function() {
    function e() {
    }
    return function(t) {
      if (!$t(t))
        return {};
      if (Yj)
        return Yj(t);
      e.prototype = t;
      var n = new e();
      return e.prototype = void 0, n;
    };
  })();
  function Owe(e) {
    return function(t, n, r) {
      for (var o = -1, i = Object(t), a = r(t), s = a.length; s--; ) {
        var c = a[++o];
        if (n(i[c], c, i) === !1)
          break;
      }
      return t;
    };
  }
  var bU = Owe();
  function xU(e, t) {
    return e && bU(e, t, Ko);
  }
  var Mwe = 1, Nwe = 2;
  function Pwe(e, t, n, r) {
    var o = n.length, i = o;
    if (e == null)
      return !i;
    for (e = Object(e); o--; ) {
      var a = n[o];
      if (a[2] ? a[1] !== e[a[0]] : !(a[0] in e))
        return !1;
    }
    for (; ++o < i; ) {
      a = n[o];
      var s = a[0], c = e[s], u = a[1];
      if (a[2]) {
        if (c === void 0 && !(s in e))
          return !1;
      } else {
        var d = new Qo(), p;
        if (!(p === void 0 ? cm(u, c, Mwe | Nwe, r, d) : p))
          return !1;
      }
    }
    return !0;
  }
  function wU(e) {
    return e === e && !$t(e);
  }
  function Iwe(e) {
    for (var t = Ko(e), n = t.length; n--; ) {
      var r = t[n], o = e[r];
      t[n] = [r, o, wU(o)];
    }
    return t;
  }
  function SU(e, t) {
    return function(n) {
      return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));
    };
  }
  function $we(e) {
    var t = Iwe(e);
    return t.length == 1 && t[0][2] ? SU(t[0][0], t[0][1]) : function(n) {
      return n === e || Pwe(n, e, t);
    };
  }
  function jwe(e, t) {
    return e != null && t in Object(e);
  }
  function _U(e, t) {
    return e != null && hU(e, t, jwe);
  }
  var Dwe = 1, Fwe = 2;
  function Lwe(e, t) {
    return tA(e) && wU(t) ? SU(Oc(e), t) : function(n) {
      var r = Ee(n, e);
      return r === void 0 && r === t ? _U(n, e) : cm(t, r, Dwe | Fwe);
    };
  }
  function zwe(e) {
    return function(t) {
      return t?.[e];
    };
  }
  function Bwe(e) {
    return function(t) {
      return m1(t, e);
    };
  }
  function Uwe(e) {
    return tA(e) ? zwe(Oc(e)) : Bwe(e);
  }
  function lA(e) {
    return typeof e == "function" ? e : e == null ? g1 : typeof e == "object" ? Zn(e) ? Lwe(e[0], e[1]) : $we(e) : Uwe(e);
  }
  function Vwe(e, t, n) {
    var r = Zn(e), o = r || xc(e) || lm(e);
    if (t = lA(t), n == null) {
      var i = e && e.constructor;
      o ? n = r ? new i() : [] : $t(e) ? n = sm(i) ? vU(u1(e)) : {} : n = {};
    }
    return (o ? sA : xU)(e, function(a, s, c) {
      return t(n, a, s, c);
    }), n;
  }
  function AC(e, t, n) {
    (n !== void 0 && !am(e[t], n) || n === void 0 && !(t in e)) && oA(e, t, n);
  }
  var EU = typeof ao == "object" && ao && !ao.nodeType && ao, Xj = EU && typeof so == "object" && so && !so.nodeType && so, Hwe = Xj && Xj.exports === EU, Zj = Hwe ? na.Buffer : void 0, Qj = Zj ? Zj.allocUnsafe : void 0;
  function CU(e, t) {
    if (t)
      return e.slice();
    var n = e.length, r = Qj ? Qj(n) : new e.constructor(n);
    return e.copy(r), r;
  }
  function cA(e) {
    var t = new e.constructor(e.byteLength);
    return new j0(t).set(new j0(e)), t;
  }
  function kU(e, t) {
    var n = t ? cA(e.buffer) : e.buffer;
    return new e.constructor(n, e.byteOffset, e.length);
  }
  function uA(e, t) {
    var n = -1, r = e.length;
    for (t || (t = Array(r)); ++n < r; )
      t[n] = e[n];
    return t;
  }
  function TU(e) {
    return typeof e.constructor == "function" && !h1(e) ? vU(u1(e)) : {};
  }
  function yh(e) {
    return jo(e) && Rc(e);
  }
  function RC(e, t) {
    if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
      return e[t];
  }
  function qf(e, t, n, r) {
    var o = !n;
    n || (n = {});
    for (var i = -1, a = t.length; ++i < a; ) {
      var s = t[i], c = void 0;
      c === void 0 && (c = e[s]), o ? oA(n, s, c) : iA(n, s, c);
    }
    return n;
  }
  function qwe(e) {
    var t = [];
    if (e != null)
      for (var n in Object(e))
        t.push(n);
    return t;
  }
  var Wwe = Object.prototype, Gwe = Wwe.hasOwnProperty;
  function Kwe(e) {
    if (!$t(e))
      return qwe(e);
    var t = h1(e), n = [];
    for (var r in e)
      r == "constructor" && (t || !Gwe.call(e, r)) || n.push(r);
    return n;
  }
  function fm(e) {
    return Rc(e) ? uU(e, !0) : Kwe(e);
  }
  function Ywe(e) {
    return qf(e, fm(e));
  }
  function Xwe(e, t, n, r, o, i, a) {
    var s = RC(e, n), c = RC(t, n), u = a.get(c);
    if (u) {
      AC(e, n, u);
      return;
    }
    var d = i ? i(s, c, n + "", e, t, a) : void 0, p = d === void 0;
    if (p) {
      var m = Zn(c), g = !m && xc(c), y = !m && !g && lm(c);
      d = c, m || g || y ? Zn(s) ? d = s : yh(s) ? d = uA(s) : g ? (p = !1, d = CU(c, !0)) : y ? (p = !1, d = kU(c, !0)) : d = [] : fl(c) || kf(c) ? (d = s, kf(s) ? d = Ywe(s) : (!$t(s) || sm(s)) && (d = TU(c))) : p = !1;
    }
    p && (a.set(c, d), o(d, c, r, i, a), a.delete(c)), AC(e, n, d);
  }
  function AU(e, t, n, r, o) {
    e !== t && bU(t, function(i, a) {
      if (o || (o = new Qo()), $t(i))
        Xwe(e, t, a, n, AU, r, o);
      else {
        var s = r ? r(RC(e, a), i, a + "", e, t, o) : void 0;
        s === void 0 && (s = i), AC(e, a, s);
      }
    }, fm);
  }
  function Zwe(e, t, n) {
    switch (n.length) {
      case 0:
        return e.call(t);
      case 1:
        return e.call(t, n[0]);
      case 2:
        return e.call(t, n[0], n[1]);
      case 3:
        return e.call(t, n[0], n[1], n[2]);
    }
    return e.apply(t, n);
  }
  var Jj = Math.max;
  function RU(e, t, n) {
    return t = Jj(t === void 0 ? e.length - 1 : t, 0), function() {
      for (var r = arguments, o = -1, i = Jj(r.length - t, 0), a = Array(i); ++o < i; )
        a[o] = r[t + o];
      o = -1;
      for (var s = Array(t + 1); ++o < t; )
        s[o] = r[o];
      return s[t] = n(a), Zwe(e, this, s);
    };
  }
  function Qwe(e) {
    return function() {
      return e;
    };
  }
  var Jwe = D0 ? function(e, t) {
    return D0(e, "toString", {
      configurable: !0,
      enumerable: !1,
      value: Qwe(t),
      writable: !0
    });
  } : g1, eSe = 800, tSe = 16, nSe = Date.now;
  function rSe(e) {
    var t = 0, n = 0;
    return function() {
      var r = nSe(), o = tSe - (r - n);
      if (n = r, o > 0) {
        if (++t >= eSe)
          return arguments[0];
      } else
        t = 0;
      return e.apply(void 0, arguments);
    };
  }
  var OU = rSe(Jwe);
  function y1(e, t) {
    return OU(RU(e, t, g1), e + "");
  }
  function oSe(e, t, n) {
    if (!$t(n))
      return !1;
    var r = typeof t;
    return (r == "number" ? Rc(n) && p1(t, n.length) : r == "string" && t in n) ? am(n[t], e) : !1;
  }
  function iSe(e) {
    return y1(function(t, n) {
      var r = -1, o = n.length, i = o > 1 ? n[o - 1] : void 0, a = o > 2 ? n[2] : void 0;
      for (i = e.length > 3 && typeof i == "function" ? (o--, i) : void 0, a && oSe(n[0], n[1], a) && (i = o < 3 ? void 0 : i, o = 1), t = Object(t); ++r < o; ) {
        var s = n[r];
        s && e(t, s, r, i);
      }
      return t;
    });
  }
  var aSe = iSe(function(e, t, n) {
    AU(e, t, n);
  }), eD = $o ? $o.isConcatSpreadable : void 0;
  function sSe(e) {
    return Zn(e) || kf(e) || !!(eD && e && e[eD]);
  }
  function dm(e, t, n, r, o) {
    var i = -1, a = e.length;
    for (n || (n = sSe), o || (o = []); ++i < a; ) {
      var s = e[i];
      t > 0 && n(s) ? t > 1 ? dm(s, t - 1, n, r, o) : ZT(o, s) : r || (o[o.length] = s);
    }
    return o;
  }
  var lSe = 1 / 0;
  function cSe(e) {
    var t = e == null ? 0 : e.length;
    return t ? dm(e, lSe) : [];
  }
  function uSe(e, t, n, r) {
    for (var o = e.length, i = n + -1; ++i < o; )
      if (t(e[i], i, e))
        return i;
    return -1;
  }
  function fSe(e) {
    return e !== e;
  }
  function dSe(e, t, n) {
    for (var r = n - 1, o = e.length; ++r < o; )
      if (e[r] === t)
        return r;
    return -1;
  }
  function MU(e, t, n) {
    return t === t ? dSe(e, t, n) : uSe(e, fSe, n);
  }
  function fA(e, t) {
    var n = e == null ? 0 : e.length;
    return !!n && MU(e, t, 0) > -1;
  }
  function qv() {
  }
  var pSe = 1 / 0, hSe = lf && 1 / XT(new lf([, -0]))[1] == pSe ? function(e) {
    return new lf(e);
  } : qv, mSe = 200;
  function NU(e, t, n) {
    var r = -1, o = fA, i = e.length, a = !0, s = [], c = s;
    if (i >= mSe) {
      var u = hSe(e);
      if (u)
        return XT(u);
      a = !1, o = mh, c = new bc();
    } else
      c = s;
    e:
      for (; ++r < i; ) {
        var d = e[r], p = d;
        if (d = d !== 0 ? d : 0, a && p === p) {
          for (var m = c.length; m--; )
            if (c[m] === p)
              continue e;
          s.push(d);
        } else o(c, p, n) || (c !== s && c.push(p), s.push(d));
      }
    return s;
  }
  function PU(e) {
    return e && e.length ? NU(e) : [];
  }
  var gSe = "[object Map]", ySe = "[object Set]", vSe = Object.prototype, bSe = vSe.hasOwnProperty;
  function Hn(e) {
    if (e == null)
      return !0;
    if (Rc(e) && (Zn(e) || typeof e == "string" || typeof e.splice == "function" || xc(e) || lm(e) || kf(e)))
      return !e.length;
    var t = Ro(e);
    if (t == gSe || t == ySe)
      return !e.size;
    if (h1(e))
      return !fU(e).length;
    for (var n in e)
      if (bSe.call(e, n))
        return !1;
    return !0;
  }
  const xSe = Object.prototype;
  function wp(e) {
    for (const t in e)
      if (xSe.hasOwnProperty.call(e, t))
        return !1;
    return !0;
  }
  const wSe = [
    "array",
    "boolean",
    "integer",
    "null",
    "number",
    "object",
    "string"
  ];
  new Set(wSe);
  const SSe = [
    "$defs",
    "definitions",
    "properties",
    "patternProperties",
    "dependencies"
  ];
  new Set(SSe);
  const _Se = [
    "items",
    "allOf",
    "oneOf",
    "anyOf"
  ];
  new Set(_Se);
  const ESe = [
    "items",
    "additionalItems",
    "additionalProperties",
    "propertyNames",
    "contains",
    "if",
    "then",
    "else",
    "not"
  ];
  new Set(ESe);
  function Wv(e) {
    return typeof e == "object";
  }
  function Ei(e) {
    return Wv(e) ? wp(e) : e === !0;
  }
  function Yu(e, t) {
    return e < t ? -1 : e > t ? 1 : 0;
  }
  function p_(e, t) {
    const n = e.length;
    if (n === 0)
      return t;
    let r = t.length;
    if (r === 0)
      return e;
    if (n < r) {
      const i = e;
      e = t, t = i, r = n;
    }
    const o = new Set(e);
    for (let i = 0; i < r; i++)
      o.add(t[i]);
    return Array.from(o);
  }
  function CSe(e, t) {
    const n = [];
    if (e.length === 0 || t.length === 0)
      return n;
    if (e.length > t.length) {
      const o = e;
      e = t, t = o;
    }
    const r = new Set(t);
    for (let o = 0; o < e.length && r.size > 0; o++) {
      const i = e[o];
      r.delete(i) && n.push(i);
    }
    return n;
  }
  function tD(e) {
    return e.length === 0;
  }
  function h_(e) {
    return (t, n) => {
      const r = t.length - n.length;
      if (r !== 0)
        return r;
      for (let o = 0; o < t.length; o++)
        if (t[o] !== n[o]) {
          const i = e(t[o], n[o]);
          if (i !== 0)
            return i;
        }
      return 0;
    };
  }
  function IU(e, { threshold: t = 12 } = {}) {
    return (n) => {
      const r = n.length;
      if (r === 0)
        return n;
      if (r <= t) {
        const a = [];
        let s = 0;
        e: for (let c = 0; c < r; c++) {
          const u = n[c];
          for (let d = 0; d < s; d++)
            if (e(u, a[d]) === 0)
              continue e;
          s = a.push(u);
        }
        return a;
      }
      const o = n.slice().sort(e);
      let i = 0;
      for (let a = 1; a < r; a++)
        e(o[i], o[a]) !== 0 && ++i !== a && (o[i] = o[a]);
      return o.length = i + 1, o;
    };
  }
  function kSe(e) {
    return (t, n) => {
      const r = [];
      let o = t.length, i = n.length;
      if (o === 0 || i === 0)
        return r;
      if (o > i) {
        const d = t;
        t = n, n = d;
        const p = o;
        o = i, i = p;
      }
      const a = [...t].sort(e), s = [...n].sort(e);
      let c = 0, u = 0;
      for (; c < o && u < i; ) {
        const d = e(a[c], s[u]);
        d === 0 ? ((r.length === 0 || e(r[r.length - 1], a[c]) !== 0) && r.push(a[c]), c++, u++) : d < 0 ? c++ : u++;
      }
      return r;
    };
  }
  function TSe(e, t) {
    return (n) => {
      if (e.has(n))
        return e.get(n);
      const r = t(n);
      return e.set(n, r), r;
    };
  }
  const nD = TSe, $U = () => 0, ASe = (e) => e === void 0, RSe = (e) => typeof e != "object", rD = {
    boolean: 0,
    number: 1,
    string: 2
  };
  function OSe(e, t) {
    const n = typeof e, r = typeof t;
    return n === r ? Yu(e, t) : rD[n] - rD[r];
  }
  function MSe(e, t) {
    const n = e.length;
    if (n === 0)
      return t;
    const r = t.length;
    if (r === 0)
      return e;
    if (r > n) {
      const a = e;
      e = t, t = a;
    }
    const o = new Set(e), i = t.length;
    for (let a = 0; a < i; a++) {
      const s = t[a];
      o.has(s) || e.push(s);
    }
    return e;
  }
  function v1(e, t, n = $U) {
    return (r, o) => e(r) ? e(o) ? n(r, o) : -1 : e(o) ? 1 : t(r, o);
  }
  function Vu(e) {
    return v1(ASe, e);
  }
  function Us(e, t) {
    return v1((n) => n === void 0 || e(n), t);
  }
  function m_(e, t) {
    return v1(Array.isArray, e, t);
  }
  const Bn = Vu(Yu), g_ = Us((e) => e === 0, (e, t) => e - t);
  function NSe({ deduplicationCache: e = /* @__PURE__ */ new WeakMap(), sortedKeysCache: t = /* @__PURE__ */ new WeakMap() } = {}) {
    const n = nD(t, (b) => Object.keys(b).sort());
    function r(b) {
      return (v, x) => {
        const E = n(v), _ = n(x), C = Math.min(E.length, _.length);
        for (let k = 0; k < C; k++) {
          const A = Yu(E[k], _[k]);
          if (A !== 0)
            return A;
        }
        if (E.length !== _.length)
          return E.length - _.length;
        for (let k = 0; k < C; k++) {
          const A = E[k], O = b(v[A], x[A]);
          if (O !== 0)
            return O;
        }
        return 0;
      };
    }
    function o(b) {
      const v = h_(b), x = nD(
        e,
        // NOTE: Always sort output
        IU(b, { threshold: 0 })
      );
      return (E, _) => v(x(E), x(_));
    }
    const i = o(Yu);
    function a(b, v) {
      if (Wv(b)) {
        if (Wv(v)) {
          const x = Object.keys(b), E = Object.keys(v), _ = MSe(x, E), C = _.length;
          for (let k = 0; k < C; k++) {
            const A = _[k];
            if (b[A] === v[A])
              continue;
            const P = (y[A] ?? s)(b[A], v[A]);
            if (P !== 0)
              return P;
          }
          return 0;
        }
        return v === !0 && wp(b) ? 0 : 1;
      }
      return Wv(v) ? b === !0 && wp(v) ? 0 : -1 : Yu(b, v);
    }
    const s = Vu(u), c = v1(RSe, m_(r(s), h_(u)), OSe);
    function u(b, v) {
      return b === null ? -1 : v === null ? 1 : c(b, v);
    }
    const d = Vu(a), p = Us(wp, r(d)), m = Vu(o(a)), g = Us(Ei, a), y = {
      $id: Bn,
      $comment: Bn,
      $defs: p,
      $ref: Bn,
      $schema: Bn,
      const: s,
      contains: d,
      contentEncoding: Bn,
      contentMediaType: Bn,
      default: s,
      definitions: p,
      description: Bn,
      else: d,
      examples: s,
      exclusiveMaximum: Bn,
      exclusiveMinimum: Bn,
      format: Bn,
      if: d,
      maximum: Bn,
      maxItems: Bn,
      maxLength: Bn,
      maxProperties: Bn,
      minimum: Bn,
      multipleOf: Bn,
      not: d,
      pattern: Bn,
      propertyNames: d,
      readOnly: Bn,
      then: d,
      title: Bn,
      writeOnly: Bn,
      uniqueItems: Us((b) => b === !1, $U),
      minLength: g_,
      minItems: g_,
      minProperties: g_,
      required: Us(tD, i),
      enum: Us(tD, o(u)),
      type: Vu((b, v) => {
        const x = Array.isArray(b), E = Array.isArray(v);
        return !x && !E ? Yu(b, v) : i(x ? b : [b], E ? v : [v]);
      }),
      items: Us((b) => !Array.isArray(b) && Ei(b), m_(a, h_(a))),
      anyOf: m,
      allOf: m,
      oneOf: m,
      properties: p,
      patternProperties: p,
      additionalProperties: g,
      additionalItems: g,
      dependencies: Us(wp, r(Vu(m_(a, i))))
    };
    return {
      compareSchemaValues: u,
      compareSchemaDefinitions: a
    };
  }
  function oD(e) {
    return e;
  }
  const jU = (e, t) => e ? jU(t % e, e) : t, PSe = (e, t) => Math.abs(e * t) / jU(e, t);
  function ISe(e, t) {
    return e === t ? e : `^(?=.*(?:${e}))(?=.*(?:${t})).*$`;
  }
  function* y_(e, t, n) {
    const r = e.length, o = t.length;
    if (r > 0 && o > 0)
      for (let i = 0; i < r; i++) {
        const a = e[i];
        for (let s = 0; s < o; s++)
          yield n(a, t[s]);
      }
  }
  function v_(e, t) {
    return e || t;
  }
  function iD(e) {
    return (t, n) => {
      const r = { ...t }, o = Object.keys(n), i = o.length;
      for (let a = 0; a < i; a++) {
        const s = o[a];
        r[s] = t[s] === void 0 ? n[s] : e(t[s], n[s]);
      }
      return r;
    };
  }
  function $Se(e) {
    const t = /* @__PURE__ */ new Map();
    for (const n of e)
      for (const r of n[0])
        t.set(r, n[1]);
    return t;
  }
  function zl(e, t, n) {
    n === void 0 || Ei(n) ? delete e[t] : e[t] = n;
  }
  const jSe = [
    "properties",
    "patternProperties",
    "additionalProperties"
  ];
  function aD(e) {
    const t = Object.keys(e), n = t.length, r = [];
    for (let o = 0; o < n; o++) {
      const i = t[o];
      r.push({
        regExp: new RegExp(i),
        schema: e[i]
      });
    }
    return [r, t];
  }
  const sD = [[], []];
  function lD(e, t, n) {
    const r = n.length;
    for (let o = 0; o < r; o++) {
      const i = n[o];
      if (!i.regExp.test(t))
        continue;
      const a = i.schema;
      if (a === !1)
        return !0;
      e.push(a);
    }
    return !1;
  }
  const DSe = [
    "items",
    "additionalItems"
  ], FSe = [
    "if",
    "then",
    "else"
  ];
  function cD(e, t) {
    return t.if !== void 0 && (e.if = t.if), t.then !== void 0 && (e.then = t.then), t.else !== void 0 && (e.else = t.else), e;
  }
  function b_(e, t) {
    if (e === t)
      return e;
    switch (e) {
      case "number":
        if (t === "integer")
          return "integer";
      // eslint-disable-next-line no-fallthrough
      case "integer":
        if (t === "number")
          return "integer";
      // eslint-disable-next-line no-fallthrough
      default:
        return;
    }
  }
  function Bl(e, t, n) {
    return [e, t, n];
  }
  function LSe(e) {
    const t = /* @__PURE__ */ new Map();
    for (const [n, r, o] of e) {
      const i = (a) => {
        if (!o(a))
          throw new Error(`Schema keys '${n}' and '${r}' are conflicting (${n}: ${JSON.stringify(a[n])}, ${r}: ${JSON.stringify(a[r])})`);
      };
      for (const a of [
        [n, r],
        [r, n]
      ]) {
        let s = t.get(a[0]);
        s === void 0 && (s = [], t.set(a[0], s)), s.push({ oppositeKey: a[1], check: i });
      }
    }
    return t;
  }
  const zSe = [
    Bl("minimum", "maximum", (e) => e.maximum >= e.minimum),
    Bl("exclusiveMinimum", "maximum", (e) => e.maximum > e.exclusiveMinimum),
    Bl("minimum", "exclusiveMaximum", (e) => e.exclusiveMaximum > e.minimum),
    Bl("exclusiveMinimum", "exclusiveMaximum", (e) => e.exclusiveMaximum > e.exclusiveMinimum),
    Bl("minLength", "maxLength", (e) => e.maxLength >= e.minLength),
    Bl("minItems", "maxItems", (e) => e.maxItems >= e.minItems),
    Bl("minProperties", "maxProperties", (e) => e.maxProperties >= e.minProperties)
  ];
  function BSe({ mergePatterns: e = ISe, isSubRegExp: t = Object.is, intersectJson: n = CSe, deduplicateJsonSchemaDef: r = oD, defaultMerger: o = oD, assigners: i = [], checks: a = zSe, mergers: s } = {}) {
    function c(C) {
      const k = C.length;
      let A = C[0];
      for (let O = 1; O < k; O++) {
        const P = x(A, C[O]);
        if (P === !1)
          return !1;
        Ei(P) || (A = P);
      }
      return A;
    }
    function u(C, k, A, O, P, I, $) {
      if (C.length = 0, A === !1)
        return !1;
      if (C.push(A), P !== void 0) {
        if (P === !1)
          return !1;
        C.push(P);
      }
      if (lD(C, k, I))
        return !1;
      const N = C.length < 2;
      if ($ === !1) {
        if (N)
          return;
        if (lD(C, k, O))
          return !1;
      } else N && $ !== void 0 && C.push($);
      return C.length === 1 ? C[0] : c(C);
    }
    function d(C, k, A, O, P, I) {
      const $ = A.length;
      if ($ > 0 && P !== !1)
        if (I)
          Object.assign(C, k);
        else
          for (let L = 0; L < $; L++) {
            const N = A[L];
            O.has(N) || (C[N] = x(k[N], P));
          }
      return C;
    }
    const p = (C, { properties: k = {}, patternProperties: A, additionalProperties: O = !0 }, { properties: P = {}, patternProperties: I, additionalProperties: $ = !0 }) => {
      const L = Ei(O), N = Ei($);
      if (L && N)
        return zl(C, "properties", E(k, P)), zl(C, "patternProperties", A && I ? E(A, I) : A ?? I), delete C.additionalProperties, C;
      const U = x(O, $);
      zl(C, "additionalProperties", U);
      const j = {}, V = Object.keys(k), F = V.length, [K, W] = A ? aD(A) : sD, [Y, B] = I ? aD(I) : sD, D = [], G = /* @__PURE__ */ new Set(), z = N ? void 0 : $;
      for (let se = 0; se < F; se++) {
        const ue = V[se];
        G.add(ue);
        const J = u(D, ue, k[ue], K, P[ue], Y, z);
        J !== void 0 && (j[ue] = J);
      }
      const H = Object.keys(P), X = H.length, Q = L ? void 0 : O;
      for (let se = 0; se < X; se++) {
        const ue = H[se];
        if (G.has(ue))
          continue;
        const J = u(D, ue, P[ue], Y, void 0, K, Q);
        J !== void 0 && (j[ue] = J);
      }
      zl(C, "properties", j);
      let ne = {};
      const te = /* @__PURE__ */ new Set();
      if (W.length > 0 && B.length > 0) {
        const se = y_(W, B, (ue, J) => {
          t(ue, J) && te.add(ue), t(J, ue) && te.add(J), ne[e(ue, J)] = x(A[ue], I[J]);
        });
        for (; !se.next().done; )
          ;
      }
      return ne = d(ne, A, W, te, $, N), ne = d(ne, I, B, te, O, L), zl(C, "patternProperties", ne), C;
    }, m = (C, { items: k = [], additionalItems: A }, { items: O = [], additionalItems: P }) => {
      const I = Array.isArray(k), $ = Array.isArray(O), L = [];
      if (C.items = L, I && $) {
        const [N, U, j] = k.length < O.length ? [k.length, A, O] : [O.length, P, k];
        let V = 0;
        for (; V < N; V++)
          L.push(x(k[V], O[V]));
        if (U === !1)
          C.additionalItems = !1;
        else {
          const F = U === void 0 || Ei(U);
          for (; V < j.length; V++)
            L.push(F ? j[V] : x(j[V], U));
          zl(C, "additionalItems", A !== void 0 && P !== void 0 ? x(A, P) : A ?? P);
        }
      } else if (I || $) {
        const [N, U, j] = I ? [k, O, A] : [O, k, P];
        zl(C, "additionalItems", j && x(j, U));
        for (let V = 0; V < N.length; V++)
          L.push(x(N[V], U));
      } else
        delete C.additionalItems, C.items = x(k, O);
      return C;
    }, g = (C, k, A) => {
      cD(C, k);
      const O = cD({}, A);
      return C.allOf === void 0 ? C.allOf = [O] : C.allOf = C.allOf.concat(O), C;
    };
    function y(C, k) {
      return r(Array.from(y_(C, k, x)));
    }
    const b = $Se([
      [jSe, p],
      [DSe, m],
      [FSe, g],
      ...i
    ]), v = LSe(a);
    function x(C, k) {
      if (C === !1 || k === !1)
        return !1;
      if (Ei(C))
        return Ei(k) ? !0 : k;
      if (Ei(k))
        return C;
      let A = { ...C };
      const O = /* @__PURE__ */ new Set(), P = /* @__PURE__ */ new Set(), I = Object.keys(k), $ = I.length;
      for (let L = 0; L < $; L++) {
        const N = I[L], U = k[N];
        if (U === void 0)
          continue;
        const j = v.get(N);
        if (j !== void 0) {
          const W = j.length;
          for (let Y = 0; Y < W; Y++) {
            const B = j[Y];
            C[B.oppositeKey] !== void 0 && P.add(B.check);
          }
        }
        const V = C[N];
        if (V === void 0) {
          A[N] = U;
          continue;
        }
        const F = b.get(N);
        if (F) {
          O.add(F);
          continue;
        }
        const K = _[N] ?? o;
        A[N] = K(V, U);
      }
      for (const L of O)
        A = L(A, C, k);
      for (const L of P)
        L(A);
      return A;
    }
    const E = iD(x), _ = {
      $id: o,
      $ref: o,
      $schema: o,
      $comment: o,
      $defs: E,
      definitions: E,
      type: (C, k) => {
        if (C === k)
          return C;
        const A = Array.isArray(C), O = Array.isArray(k);
        if (!A && !O) {
          const P = b_(C, k);
          if (P !== void 0)
            return P;
        } else if (A || O) {
          const P = /* @__PURE__ */ new Set();
          if (A && O)
            for (const $ of y_(C, k, b_))
              $ !== void 0 && P.add($);
          else {
            const $ = A ? C : k, L = A ? k : C, N = $.length;
            for (let U = 0; U < N; U++) {
              const j = b_(L, $[U]);
              j !== void 0 && P.add(j);
            }
          }
          const I = P.size;
          if (I === 1)
            return P.values().next().value;
          if (I > 1)
            return Array.from(P);
        }
        throw new Error(`It is not possible to create an intersection of the following incompatible types: ${C.toString()}, ${k.toString()}`);
      },
      default: o,
      description: o,
      title: o,
      const: o,
      format: o,
      contentEncoding: o,
      contentMediaType: o,
      not: (C, k) => {
        const A = r([C, k]);
        return A.length === 1 ? A[0] : { anyOf: A };
      },
      pattern: e,
      readOnly: v_,
      writeOnly: v_,
      enum: (C, k) => {
        const A = n(C, k);
        if (A.length === 0)
          throw new Error(`Intersection of the following enums is empty: "${JSON.stringify(C)}", "${JSON.stringify(k)}"`);
        return A;
      },
      anyOf: y,
      oneOf: y,
      allOf: (C, k) => r(C.concat(k)),
      propertyNames: x,
      contains: x,
      dependencies: iD((C, k) => Array.isArray(C) ? Array.isArray(k) ? p_(C, k) : x(k, { required: C }) : Array.isArray(k) ? x(C, { required: k }) : x(C, k)),
      examples: (C, k) => {
        if (!Array.isArray(C) || !Array.isArray(k))
          throw new Error(`Value of the 'examples' field should be an array, but got "${JSON.stringify(C)}" and "${JSON.stringify(k)}"`);
        return p_(C, k);
      },
      multipleOf: (C, k) => {
        let A = 1;
        for (; !Number.isInteger(C) || !Number.isInteger(k); )
          A *= 10, C *= 10, k *= 10;
        return PSe(C, k) / A;
      },
      exclusiveMaximum: Math.min,
      maximum: Math.min,
      maxItems: Math.min,
      maxLength: Math.min,
      maxProperties: Math.min,
      exclusiveMinimum: Math.max,
      minimum: Math.max,
      minItems: Math.max,
      minLength: Math.max,
      minProperties: Math.max,
      uniqueItems: v_,
      required: p_,
      ...s
    };
    return {
      mergeSchemaDefinitions: x,
      mergeArrayOfSchemaDefinitions: c
    };
  }
  function USe(e) {
    const t = [], n = [e];
    for (; n.length > 0; ) {
      const r = n.pop();
      if (typeof r == "boolean" || r.allOf === void 0) {
        t.push(r);
        continue;
      }
      const { allOf: o, ...i } = r;
      t.push(i);
      for (let a = o.length - 1; a >= 0; a--)
        n.push(o[a]);
    }
    return t;
  }
  function VSe(e) {
    return (t) => e(USe(t));
  }
  var Qd = {}, uD;
  function HSe() {
    if (uD) return Qd;
    uD = 1;
    var e = /~/, t = /~[01]/g;
    function n(u) {
      switch (u) {
        case "~1":
          return "/";
        case "~0":
          return "~";
      }
      throw new Error("Invalid tilde escape: " + u);
    }
    function r(u) {
      return e.test(u) ? u.replace(t, n) : u;
    }
    function o(u, d, p) {
      for (var m, g, y = 1, b = d.length; y < b; ) {
        if (d[y] === "constructor" || d[y] === "prototype" || d[y] === "__proto__") return u;
        if (m = r(d[y++]), g = b > y, typeof u[m] > "u" && (Array.isArray(u) && m === "-" && (m = u.length), g && (d[y] !== "" && d[y] < 1 / 0 || d[y] === "-" ? u[m] = [] : u[m] = {})), !g) break;
        u = u[m];
      }
      var v = u[m];
      return p === void 0 ? delete u[m] : u[m] = p, v;
    }
    function i(u) {
      if (typeof u == "string") {
        if (u = u.split("/"), u[0] === "") return u;
        throw new Error("Invalid JSON pointer.");
      } else if (Array.isArray(u)) {
        for (const d of u)
          if (typeof d != "string" && typeof d != "number")
            throw new Error("Invalid JSON pointer. Must be of type string or number.");
        return u;
      }
      throw new Error("Invalid JSON pointer.");
    }
    function a(u, d) {
      if (typeof u != "object") throw new Error("Invalid input object.");
      d = i(d);
      var p = d.length;
      if (p === 1) return u;
      for (var m = 1; m < p; ) {
        if (u = u[r(d[m++])], p === m) return u;
        if (typeof u != "object" || u === null) return;
      }
    }
    function s(u, d, p) {
      if (typeof u != "object") throw new Error("Invalid input object.");
      if (d = i(d), d.length === 0) throw new Error("Invalid JSON pointer for set.");
      return o(u, d, p);
    }
    function c(u) {
      var d = i(u);
      return {
        get: function(p) {
          return a(p, d);
        },
        set: function(p, m) {
          return s(p, d, m);
        }
      };
    }
    return Qd.get = a, Qd.set = s, Qd.compile = c, Qd;
  }
  var qSe = HSe();
  const x_ = /* @__PURE__ */ Xi(qSe);
  function WSe(e, t) {
    return e && qf(t, Ko(t), e);
  }
  function GSe(e, t) {
    return e && qf(t, fm(t), e);
  }
  function KSe(e, t) {
    return qf(e, QT(e), t);
  }
  var YSe = Object.getOwnPropertySymbols, DU = YSe ? function(e) {
    for (var t = []; e; )
      ZT(t, QT(e)), e = u1(e);
    return t;
  } : iU;
  function XSe(e, t) {
    return qf(e, DU(e), t);
  }
  function dA(e) {
    return oU(e, fm, DU);
  }
  var ZSe = Object.prototype, QSe = ZSe.hasOwnProperty;
  function JSe(e) {
    var t = e.length, n = new e.constructor(t);
    return t && typeof e[0] == "string" && QSe.call(e, "index") && (n.index = e.index, n.input = e.input), n;
  }
  function e_e(e, t) {
    var n = t ? cA(e.buffer) : e.buffer;
    return new e.constructor(n, e.byteOffset, e.byteLength);
  }
  var t_e = /\w*$/;
  function n_e(e) {
    var t = new e.constructor(e.source, t_e.exec(e));
    return t.lastIndex = e.lastIndex, t;
  }
  var fD = $o ? $o.prototype : void 0, dD = fD ? fD.valueOf : void 0;
  function r_e(e) {
    return dD ? Object(dD.call(e)) : {};
  }
  var o_e = "[object Boolean]", i_e = "[object Date]", a_e = "[object Map]", s_e = "[object Number]", l_e = "[object RegExp]", c_e = "[object Set]", u_e = "[object String]", f_e = "[object Symbol]", d_e = "[object ArrayBuffer]", p_e = "[object DataView]", h_e = "[object Float32Array]", m_e = "[object Float64Array]", g_e = "[object Int8Array]", y_e = "[object Int16Array]", v_e = "[object Int32Array]", b_e = "[object Uint8Array]", x_e = "[object Uint8ClampedArray]", w_e = "[object Uint16Array]", S_e = "[object Uint32Array]";
  function __e(e, t, n) {
    var r = e.constructor;
    switch (t) {
      case d_e:
        return cA(e);
      case o_e:
      case i_e:
        return new r(+e);
      case p_e:
        return e_e(e, n);
      case h_e:
      case m_e:
      case g_e:
      case y_e:
      case v_e:
      case b_e:
      case x_e:
      case w_e:
      case S_e:
        return kU(e, n);
      case a_e:
        return new r();
      case s_e:
      case u_e:
        return new r(e);
      case l_e:
        return n_e(e);
      case c_e:
        return new r();
      case f_e:
        return r_e(e);
    }
  }
  var E_e = "[object Map]";
  function C_e(e) {
    return jo(e) && Ro(e) == E_e;
  }
  var pD = Tf && Tf.isMap, k_e = pD ? eA(pD) : C_e, T_e = "[object Set]";
  function A_e(e) {
    return jo(e) && Ro(e) == T_e;
  }
  var hD = Tf && Tf.isSet, R_e = hD ? eA(hD) : A_e, O_e = 1, M_e = 2, N_e = 4, FU = "[object Arguments]", P_e = "[object Array]", I_e = "[object Boolean]", $_e = "[object Date]", j_e = "[object Error]", LU = "[object Function]", D_e = "[object GeneratorFunction]", F_e = "[object Map]", L_e = "[object Number]", zU = "[object Object]", z_e = "[object RegExp]", B_e = "[object Set]", U_e = "[object String]", V_e = "[object Symbol]", H_e = "[object WeakMap]", q_e = "[object ArrayBuffer]", W_e = "[object DataView]", G_e = "[object Float32Array]", K_e = "[object Float64Array]", Y_e = "[object Int8Array]", X_e = "[object Int16Array]", Z_e = "[object Int32Array]", Q_e = "[object Uint8Array]", J_e = "[object Uint8ClampedArray]", eEe = "[object Uint16Array]", tEe = "[object Uint32Array]", fn = {};
  fn[FU] = fn[P_e] = fn[q_e] = fn[W_e] = fn[I_e] = fn[$_e] = fn[G_e] = fn[K_e] = fn[Y_e] = fn[X_e] = fn[Z_e] = fn[F_e] = fn[L_e] = fn[zU] = fn[z_e] = fn[B_e] = fn[U_e] = fn[V_e] = fn[Q_e] = fn[J_e] = fn[eEe] = fn[tEe] = !0;
  fn[j_e] = fn[LU] = fn[H_e] = !1;
  function $p(e, t, n, r, o, i) {
    var a, s = t & O_e, c = t & M_e, u = t & N_e;
    if (n && (a = o ? n(e, r, o, i) : n(e)), a !== void 0)
      return a;
    if (!$t(e))
      return e;
    var d = Zn(e);
    if (d) {
      if (a = JSe(e), !s)
        return uA(e, a);
    } else {
      var p = Ro(e), m = p == LU || p == D_e;
      if (xc(e))
        return CU(e, s);
      if (p == zU || p == FU || m && !o) {
        if (a = c || m ? {} : TU(e), !s)
          return c ? XSe(e, GSe(a, e)) : KSe(e, WSe(a, e));
      } else {
        if (!fn[p])
          return o ? e : {};
        a = __e(e, p, s);
      }
    }
    i || (i = new Qo());
    var g = i.get(e);
    if (g)
      return g;
    i.set(e, a), R_e(e) ? e.forEach(function(v) {
      a.add($p(v, t, n, v, e, i));
    }) : k_e(e) && e.forEach(function(v, x) {
      a.set(x, $p(v, t, n, x, e, i));
    });
    var y = u ? c ? dA : EC : c ? fm : Ko, b = d ? void 0 : y(e);
    return sA(b || e, function(v, x) {
      b && (x = v, v = e[x]), iA(a, x, $p(v, t, n, x, e, i));
    }), a;
  }
  function BU(e) {
    var t = e == null ? 0 : e.length;
    return t ? e[t - 1] : void 0;
  }
  function nEe(e, t, n) {
    var r = -1, o = e.length;
    t < 0 && (t = -t > o ? 0 : o + t), n = n > o ? o : n, n < 0 && (n += o), o = t > n ? 0 : n - t >>> 0, t >>>= 0;
    for (var i = Array(o); ++r < o; )
      i[r] = e[r + t];
    return i;
  }
  function rEe(e, t) {
    return t.length < 2 ? e : m1(e, nEe(t, 0, -1));
  }
  function UU(e, t) {
    return t = Hf(t, e), e = rEe(e, t), e == null || delete e[Oc(BU(t))];
  }
  function oEe(e) {
    return fl(e) ? void 0 : e;
  }
  function OC(e) {
    var t = e == null ? 0 : e.length;
    return t ? dm(e, 1) : [];
  }
  function VU(e) {
    return OU(RU(e, void 0, OC), e + "");
  }
  var iEe = 1, aEe = 2, sEe = 4, vh = VU(function(e, t) {
    var n = {};
    if (e == null)
      return n;
    var r = !1;
    t = Vf(t, function(i) {
      return i = Hf(i, e), r || (r = i.length > 1), i;
    }), qf(e, dA(e), n), r && (n = $p(n, iEe | aEe | sEe, oEe));
    for (var o = t.length; o--; )
      UU(n, t[o]);
    return n;
  }), Jd = { exports: {} }, w_, mD;
  function HU() {
    if (mD) return w_;
    mD = 1;
    const e = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu), t = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
    function n(m) {
      let g = "", y = 0, b = 0;
      for (b = 0; b < m.length; b++)
        if (y = m[b].charCodeAt(0), y !== 48) {
          if (!(y >= 48 && y <= 57 || y >= 65 && y <= 70 || y >= 97 && y <= 102))
            return "";
          g += m[b];
          break;
        }
      for (b += 1; b < m.length; b++) {
        if (y = m[b].charCodeAt(0), !(y >= 48 && y <= 57 || y >= 65 && y <= 70 || y >= 97 && y <= 102))
          return "";
        g += m[b];
      }
      return g;
    }
    const r = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
    function o(m) {
      return m.length = 0, !0;
    }
    function i(m, g, y) {
      if (m.length) {
        const b = n(m);
        if (b !== "")
          g.push(b);
        else
          return y.error = !0, !1;
        m.length = 0;
      }
      return !0;
    }
    function a(m) {
      let g = 0;
      const y = { error: !1, address: "", zone: "" }, b = [], v = [];
      let x = !1, E = !1, _ = i;
      for (let C = 0; C < m.length; C++) {
        const k = m[C];
        if (!(k === "[" || k === "]"))
          if (k === ":") {
            if (x === !0 && (E = !0), !_(v, b, y))
              break;
            if (++g > 7) {
              y.error = !0;
              break;
            }
            C > 0 && m[C - 1] === ":" && (x = !0), b.push(":");
            continue;
          } else if (k === "%") {
            if (!_(v, b, y))
              break;
            _ = o;
          } else {
            v.push(k);
            continue;
          }
      }
      return v.length && (_ === o ? y.zone = v.join("") : E ? b.push(v.join("")) : b.push(n(v))), y.address = b.join(""), y;
    }
    function s(m) {
      if (c(m, ":") < 2)
        return { host: m, isIPV6: !1 };
      const g = a(m);
      if (g.error)
        return { host: m, isIPV6: !1 };
      {
        let y = g.address, b = g.address;
        return g.zone && (y += "%" + g.zone, b += "%25" + g.zone), { host: y, isIPV6: !0, escapedHost: b };
      }
    }
    function c(m, g) {
      let y = 0;
      for (let b = 0; b < m.length; b++)
        m[b] === g && y++;
      return y;
    }
    function u(m) {
      let g = m;
      const y = [];
      let b = -1, v = 0;
      for (; v = g.length; ) {
        if (v === 1) {
          if (g === ".")
            break;
          if (g === "/") {
            y.push("/");
            break;
          } else {
            y.push(g);
            break;
          }
        } else if (v === 2) {
          if (g[0] === ".") {
            if (g[1] === ".")
              break;
            if (g[1] === "/") {
              g = g.slice(2);
              continue;
            }
          } else if (g[0] === "/" && (g[1] === "." || g[1] === "/")) {
            y.push("/");
            break;
          }
        } else if (v === 3 && g === "/..") {
          y.length !== 0 && y.pop(), y.push("/");
          break;
        }
        if (g[0] === ".") {
          if (g[1] === ".") {
            if (g[2] === "/") {
              g = g.slice(3);
              continue;
            }
          } else if (g[1] === "/") {
            g = g.slice(2);
            continue;
          }
        } else if (g[0] === "/" && g[1] === ".") {
          if (g[2] === "/") {
            g = g.slice(2);
            continue;
          } else if (g[2] === "." && g[3] === "/") {
            g = g.slice(3), y.length !== 0 && y.pop();
            continue;
          }
        }
        if ((b = g.indexOf("/", 1)) === -1) {
          y.push(g);
          break;
        } else
          y.push(g.slice(0, b)), g = g.slice(b);
      }
      return y.join("");
    }
    function d(m, g) {
      const y = g !== !0 ? escape : unescape;
      return m.scheme !== void 0 && (m.scheme = y(m.scheme)), m.userinfo !== void 0 && (m.userinfo = y(m.userinfo)), m.host !== void 0 && (m.host = y(m.host)), m.path !== void 0 && (m.path = y(m.path)), m.query !== void 0 && (m.query = y(m.query)), m.fragment !== void 0 && (m.fragment = y(m.fragment)), m;
    }
    function p(m) {
      const g = [];
      if (m.userinfo !== void 0 && (g.push(m.userinfo), g.push("@")), m.host !== void 0) {
        let y = unescape(m.host);
        if (!t(y)) {
          const b = s(y);
          b.isIPV6 === !0 ? y = `[${b.escapedHost}]` : y = m.host;
        }
        g.push(y);
      }
      return (typeof m.port == "number" || typeof m.port == "string") && (g.push(":"), g.push(String(m.port))), g.length ? g.join("") : void 0;
    }
    return w_ = {
      nonSimpleDomain: r,
      recomposeAuthority: p,
      normalizeComponentEncoding: d,
      removeDotSegments: u,
      isIPv4: t,
      isUUID: e,
      normalizeIPv6: s,
      stringArrayToHexStripped: n
    }, w_;
  }
  var S_, gD;
  function lEe() {
    if (gD) return S_;
    gD = 1;
    const { isUUID: e } = HU(), t = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu, n = (
      /** @type {const} */
      [
        "http",
        "https",
        "ws",
        "wss",
        "urn",
        "urn:uuid"
      ]
    );
    function r(k) {
      return n.indexOf(
        /** @type {*} */
        k
      ) !== -1;
    }
    function o(k) {
      return k.secure === !0 ? !0 : k.secure === !1 ? !1 : k.scheme ? k.scheme.length === 3 && (k.scheme[0] === "w" || k.scheme[0] === "W") && (k.scheme[1] === "s" || k.scheme[1] === "S") && (k.scheme[2] === "s" || k.scheme[2] === "S") : !1;
    }
    function i(k) {
      return k.host || (k.error = k.error || "HTTP URIs must have a host."), k;
    }
    function a(k) {
      const A = String(k.scheme).toLowerCase() === "https";
      return (k.port === (A ? 443 : 80) || k.port === "") && (k.port = void 0), k.path || (k.path = "/"), k;
    }
    function s(k) {
      return k.secure = o(k), k.resourceName = (k.path || "/") + (k.query ? "?" + k.query : ""), k.path = void 0, k.query = void 0, k;
    }
    function c(k) {
      if ((k.port === (o(k) ? 443 : 80) || k.port === "") && (k.port = void 0), typeof k.secure == "boolean" && (k.scheme = k.secure ? "wss" : "ws", k.secure = void 0), k.resourceName) {
        const [A, O] = k.resourceName.split("?");
        k.path = A && A !== "/" ? A : void 0, k.query = O, k.resourceName = void 0;
      }
      return k.fragment = void 0, k;
    }
    function u(k, A) {
      if (!k.path)
        return k.error = "URN can not be parsed", k;
      const O = k.path.match(t);
      if (O) {
        const P = A.scheme || k.scheme || "urn";
        k.nid = O[1].toLowerCase(), k.nss = O[2];
        const I = `${P}:${A.nid || k.nid}`, $ = C(I);
        k.path = void 0, $ && (k = $.parse(k, A));
      } else
        k.error = k.error || "URN can not be parsed.";
      return k;
    }
    function d(k, A) {
      if (k.nid === void 0)
        throw new Error("URN without nid cannot be serialized");
      const O = A.scheme || k.scheme || "urn", P = k.nid.toLowerCase(), I = `${O}:${A.nid || P}`, $ = C(I);
      $ && (k = $.serialize(k, A));
      const L = k, N = k.nss;
      return L.path = `${P || A.nid}:${N}`, A.skipEscape = !0, L;
    }
    function p(k, A) {
      const O = k;
      return O.uuid = O.nss, O.nss = void 0, !A.tolerant && (!O.uuid || !e(O.uuid)) && (O.error = O.error || "UUID is not valid."), O;
    }
    function m(k) {
      const A = k;
      return A.nss = (k.uuid || "").toLowerCase(), A;
    }
    const g = (
      /** @type {SchemeHandler} */
      {
        scheme: "http",
        domainHost: !0,
        parse: i,
        serialize: a
      }
    ), y = (
      /** @type {SchemeHandler} */
      {
        scheme: "https",
        domainHost: g.domainHost,
        parse: i,
        serialize: a
      }
    ), b = (
      /** @type {SchemeHandler} */
      {
        scheme: "ws",
        domainHost: !0,
        parse: s,
        serialize: c
      }
    ), v = (
      /** @type {SchemeHandler} */
      {
        scheme: "wss",
        domainHost: b.domainHost,
        parse: b.parse,
        serialize: b.serialize
      }
    ), _ = (
      /** @type {Record<SchemeName, SchemeHandler>} */
      {
        http: g,
        https: y,
        ws: b,
        wss: v,
        urn: (
          /** @type {SchemeHandler} */
          {
            scheme: "urn",
            parse: u,
            serialize: d,
            skipNormalize: !0
          }
        ),
        "urn:uuid": (
          /** @type {SchemeHandler} */
          {
            scheme: "urn:uuid",
            parse: p,
            serialize: m,
            skipNormalize: !0
          }
        )
      }
    );
    Object.setPrototypeOf(_, null);
    function C(k) {
      return k && (_[
        /** @type {SchemeName} */
        k
      ] || _[
        /** @type {SchemeName} */
        k.toLowerCase()
      ]) || void 0;
    }
    return S_ = {
      wsIsSecure: o,
      SCHEMES: _,
      isValidSchemeName: r,
      getSchemeHandler: C
    }, S_;
  }
  var yD;
  function cEe() {
    if (yD) return Jd.exports;
    yD = 1;
    const { normalizeIPv6: e, removeDotSegments: t, recomposeAuthority: n, normalizeComponentEncoding: r, isIPv4: o, nonSimpleDomain: i } = HU(), { SCHEMES: a, getSchemeHandler: s } = lEe();
    function c(v, x) {
      return typeof v == "string" ? v = /** @type {T} */
      m(y(v, x), x) : typeof v == "object" && (v = /** @type {T} */
      y(m(v, x), x)), v;
    }
    function u(v, x, E) {
      const _ = E ? Object.assign({ scheme: "null" }, E) : { scheme: "null" }, C = d(y(v, _), y(x, _), _, !0);
      return _.skipEscape = !0, m(C, _);
    }
    function d(v, x, E, _) {
      const C = {};
      return _ || (v = y(m(v, E), E), x = y(m(x, E), E)), E = E || {}, !E.tolerant && x.scheme ? (C.scheme = x.scheme, C.userinfo = x.userinfo, C.host = x.host, C.port = x.port, C.path = t(x.path || ""), C.query = x.query) : (x.userinfo !== void 0 || x.host !== void 0 || x.port !== void 0 ? (C.userinfo = x.userinfo, C.host = x.host, C.port = x.port, C.path = t(x.path || ""), C.query = x.query) : (x.path ? (x.path[0] === "/" ? C.path = t(x.path) : ((v.userinfo !== void 0 || v.host !== void 0 || v.port !== void 0) && !v.path ? C.path = "/" + x.path : v.path ? C.path = v.path.slice(0, v.path.lastIndexOf("/") + 1) + x.path : C.path = x.path, C.path = t(C.path)), C.query = x.query) : (C.path = v.path, x.query !== void 0 ? C.query = x.query : C.query = v.query), C.userinfo = v.userinfo, C.host = v.host, C.port = v.port), C.scheme = v.scheme), C.fragment = x.fragment, C;
    }
    function p(v, x, E) {
      return typeof v == "string" ? (v = unescape(v), v = m(r(y(v, E), !0), { ...E, skipEscape: !0 })) : typeof v == "object" && (v = m(r(v, !0), { ...E, skipEscape: !0 })), typeof x == "string" ? (x = unescape(x), x = m(r(y(x, E), !0), { ...E, skipEscape: !0 })) : typeof x == "object" && (x = m(r(x, !0), { ...E, skipEscape: !0 })), v.toLowerCase() === x.toLowerCase();
    }
    function m(v, x) {
      const E = {
        host: v.host,
        scheme: v.scheme,
        userinfo: v.userinfo,
        port: v.port,
        path: v.path,
        query: v.query,
        nid: v.nid,
        nss: v.nss,
        uuid: v.uuid,
        fragment: v.fragment,
        reference: v.reference,
        resourceName: v.resourceName,
        secure: v.secure,
        error: ""
      }, _ = Object.assign({}, x), C = [], k = s(_.scheme || E.scheme);
      k && k.serialize && k.serialize(E, _), E.path !== void 0 && (_.skipEscape ? E.path = unescape(E.path) : (E.path = escape(E.path), E.scheme !== void 0 && (E.path = E.path.split("%3A").join(":")))), _.reference !== "suffix" && E.scheme && C.push(E.scheme, ":");
      const A = n(E);
      if (A !== void 0 && (_.reference !== "suffix" && C.push("//"), C.push(A), E.path && E.path[0] !== "/" && C.push("/")), E.path !== void 0) {
        let O = E.path;
        !_.absolutePath && (!k || !k.absolutePath) && (O = t(O)), A === void 0 && O[0] === "/" && O[1] === "/" && (O = "/%2F" + O.slice(2)), C.push(O);
      }
      return E.query !== void 0 && C.push("?", E.query), E.fragment !== void 0 && C.push("#", E.fragment), C.join("");
    }
    const g = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function y(v, x) {
      const E = Object.assign({}, x), _ = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      let C = !1;
      E.reference === "suffix" && (E.scheme ? v = E.scheme + ":" + v : v = "//" + v);
      const k = v.match(g);
      if (k) {
        if (_.scheme = k[1], _.userinfo = k[3], _.host = k[4], _.port = parseInt(k[5], 10), _.path = k[6] || "", _.query = k[7], _.fragment = k[8], isNaN(_.port) && (_.port = k[5]), _.host)
          if (o(_.host) === !1) {
            const P = e(_.host);
            _.host = P.host.toLowerCase(), C = P.isIPV6;
          } else
            C = !0;
        _.scheme === void 0 && _.userinfo === void 0 && _.host === void 0 && _.port === void 0 && _.query === void 0 && !_.path ? _.reference = "same-document" : _.scheme === void 0 ? _.reference = "relative" : _.fragment === void 0 ? _.reference = "absolute" : _.reference = "uri", E.reference && E.reference !== "suffix" && E.reference !== _.reference && (_.error = _.error || "URI is not a " + E.reference + " reference.");
        const A = s(E.scheme || _.scheme);
        if (!E.unicodeSupport && (!A || !A.unicodeSupport) && _.host && (E.domainHost || A && A.domainHost) && C === !1 && i(_.host))
          try {
            _.host = URL.domainToASCII(_.host.toLowerCase());
          } catch (O) {
            _.error = _.error || "Host's domain name can not be converted to ASCII: " + O;
          }
        (!A || A && !A.skipNormalize) && (v.indexOf("%") !== -1 && (_.scheme !== void 0 && (_.scheme = unescape(_.scheme)), _.host !== void 0 && (_.host = unescape(_.host))), _.path && (_.path = escape(unescape(_.path))), _.fragment && (_.fragment = encodeURI(decodeURIComponent(_.fragment)))), A && A.parse && A.parse(_, E);
      } else
        _.error = _.error || "URI can not be parsed.";
      return _;
    }
    const b = {
      SCHEMES: a,
      normalize: c,
      resolve: u,
      resolveComponent: d,
      equal: p,
      serialize: m,
      parse: y
    };
    return Jd.exports = b, Jd.exports.default = b, Jd.exports.fastUri = b, Jd.exports;
  }
  var uEe = cEe();
  const pA = /* @__PURE__ */ Xi(uEe);
  function F0(e, t) {
    if (rn in e && pA.equal(e[rn], t))
      return e;
    for (const n of Object.values(e))
      if (Array.isArray(n)) {
        for (const r of n)
          if ($t(r)) {
            const o = F0(r, t);
            if (o !== void 0)
              return o;
          }
      } else if ($t(n)) {
        const r = F0(n, t);
        if (r !== void 0)
          return r;
      }
  }
  function MC(e, t) {
    const n = Ee(e, rn, t);
    bn in e && (e = { ...e, [bn]: pA.resolve(n, e[bn]) });
    for (const [r, o] of Object.entries(e))
      Array.isArray(o) ? e = {
        ...e,
        [r]: o.map((i) => $t(i) ? MC(i, n) : i)
      } : $t(o) && (e = { ...e, [r]: MC(o, n) });
    return e;
  }
  function hA(e, t) {
    const n = t[e];
    return [vh(t, [e]), n];
  }
  function qU(e, t = {}, n = [], r = Ee(t, [rn])) {
    const o = e || "";
    let i;
    if (o.startsWith("#")) {
      const s = decodeURIComponent(o.substring(1));
      r === void 0 || rn in t && t[rn] === r ? i = x_.get(t, s) : t[xp] === Hv && (i = F0(t, r.replace(/\/$/, "")), i !== void 0 && (i = x_.get(i, s)));
    } else if (t[xp] === Hv) {
      const s = r ? pA.resolve(r, o) : o, [c, ...u] = s.replace(/#\/?$/, "").split("#");
      i = F0(t, c.replace(/\/$/, "")), i !== void 0 && (r = i[rn], Hn(u) || (i = x_.get(i, decodeURIComponent(u.join("#")))));
    }
    if (i === void 0)
      throw new Error(`Could not find a definition for ${e}.`);
    const a = i[bn];
    if (a) {
      if (n.includes(a)) {
        if (n.length === 1)
          throw new Error(`Definition for ${e} is a circular reference`);
        const [d, ...p] = n, m = [...p, o, d].join(" -> ");
        throw new Error(`Definition for ${d} contains a circular reference through ${m}`);
      }
      const [s, c] = hA(bn, i), u = qU(c, t, [...n, o], r);
      return Object.keys(s).length > 0 ? t[xp] === kbe || t[xp] === Hv ? { [ul]: [s, u] } : { ...s, ...u } : u;
    }
    return i;
  }
  function WU(e, t = {}, n = Ee(t, [rn])) {
    return qU(e, t, [], n);
  }
  var fEe = "[object String]";
  function dl(e) {
    return typeof e == "string" || !Zn(e) && jo(e) && rs(e) == fEe;
  }
  function Ki(e) {
    let t;
    const n = Ee(e, _be);
    return dl(n) ? t = n : n !== void 0 && console.warn(`Expecting discriminator to be a string, got "${typeof n}" instead`), t;
  }
  function bh(e) {
    return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : e == null ? "null" : typeof e == "boolean" ? "boolean" : isNaN(e) ? typeof e == "object" ? "object" : "string" : "number";
  }
  var dEe = y1(function(e) {
    return NU(dm(e, 1, yh, !0));
  });
  function oi(e) {
    let { type: t } = e;
    return !t && e.const ? bh(e.const) : !t && e.enum ? "string" : !t && (e.properties || e.additionalProperties || e.patternProperties) ? "object" : (Array.isArray(t) && (t.length === 2 && t.includes("null") ? t = t.find((n) => n !== "null") : t = t[0]), t);
  }
  function Za(e, t) {
    const n = Object.assign({}, e);
    return Object.keys(t).reduce((r, o) => {
      const i = e ? e[o] : {}, a = t[o];
      return e && o in e && Rt(a) ? r[o] = Za(i, a) : e && t && (oi(e) === "object" || oi(t) === "object") && o === K8 && Array.isArray(i) && Array.isArray(a) ? r[o] = dEe(i, a) : r[o] = a, r;
    }, n);
  }
  var pEe = "[object Number]";
  function GU(e) {
    return typeof e == "number" || jo(e) && rs(e) == pEe;
  }
  function KU(e, t, n) {
    var r;
    if (e && n) {
      const o = Ee(e, n);
      if (o === void 0)
        return;
      for (let i = 0; i < t.length; i++) {
        const a = t[i], s = Ee(a, [Ft, n], {});
        if (!(s.type === "object" || s.type === "array") && (s.const === o || !((r = s.enum) === null || r === void 0) && r.includes(o)))
          return i;
      }
    }
  }
  function mA(e, t, n, r, o) {
    if (t === void 0)
      return 0;
    const i = KU(t, n, o);
    if (GU(i))
      return i;
    for (let a = 0; a < n.length; a++) {
      const s = n[a];
      if (o && Tt(s, [Ft, o])) {
        const c = Ee(t, o), u = Ee(s, [Ft, o], {});
        if (e.isValid(u, c, r))
          return a;
      } else if (s[Ft]) {
        const c = {
          anyOf: Object.keys(s[Ft]).map((d) => ({
            required: [d]
          }))
        };
        let u;
        if (s.anyOf) {
          const { ...d } = s;
          d.allOf ? d.allOf = d.allOf.slice() : d.allOf = [], d.allOf.push(c), u = d;
        } else
          u = Object.assign({}, s, c);
        if (delete u.required, e.isValid(u, t, r))
          return a;
      } else if (e.isValid(s, t, r))
        return a;
    }
    return 0;
  }
  function vr(e, t, n = {}, r, o, i = !1) {
    return Ii(e, t, n, r, void 0, void 0, o, i)[0];
  }
  function hEe(e, t, n, r, o, i, a) {
    const { if: s, then: c, else: u, ...d } = t, p = e.isValid(s, i || {}, n);
    let m = [d], g = [];
    if (r)
      c && typeof c != "boolean" && (g = g.concat(Ii(e, c, n, i, r, o, a))), u && typeof u != "boolean" && (g = g.concat(Ii(e, u, n, i, r, o, a)));
    else {
      const y = p ? c : u;
      y && typeof y != "boolean" && (g = g.concat(Ii(e, y, n, i, r, o, a)));
    }
    return g.length && (m = g.map((y) => Za(d, y))), m.flatMap((y) => Ii(e, y, n, i, r, o, a));
  }
  function YU(e) {
    return e.reduce((n, r) => r.length > 1 ? r.flatMap((o) => yU(n.length, (i) => [...n[i]].concat(o))) : (n.forEach((o) => o.push(r[0])), n), [[]]);
  }
  function XU(e, t) {
    return Object.keys(e.patternProperties).filter((n) => RegExp(n).test(t)).reduce((n, r) => (Qt(n, [r], e.patternProperties[r]), n), {});
  }
  function mEe(e, t, n, r, o, i, a, s) {
    const c = ZU(e, t, n, r, o, i, a, s);
    if (c.length > 1 || c[0] !== t)
      return c;
    if (GT in t)
      return QU(e, t, n, r, o, i, a).flatMap((d) => Ii(e, d, n, i, r, o, a));
    if (ul in t && Array.isArray(t[ul])) {
      const u = t.allOf.map((p) => Ii(e, p, n, i, r, o, a));
      return YU(u).map((p) => ({
        ...t,
        allOf: p
      }));
    }
    return [t];
  }
  function ZU(e, t, n, r, o, i, a, s) {
    const c = cf(t, n, o, void 0, s);
    return c !== t ? Ii(e, c, n, i, r, o, a, s) : [t];
  }
  function cf(e, t, n, r, o) {
    if (!Rt(e))
      return e;
    let i = e;
    if (bn in i) {
      const { $ref: a, ...s } = i;
      if (n.includes(a))
        return i;
      n.push(a), i = { ...WU(a, t, r), ...s }, rn in i && (r = i[rn]);
    }
    if (Ft in i) {
      const a = [], s = Vwe(i[Ft], (c, u, d) => {
        const p = [...n];
        c[d] = cf(u, t, p, r, o), a.push(p);
      }, {});
      aSe(n, PU(cSe(a))), i = { ...i, [Ft]: s };
    }
    if (Cf in i && !Array.isArray(i.items) && typeof i.items != "boolean" && (i = {
      ...i,
      items: cf(i.items, t, n, r, o)
    }), o) {
      let a, s;
      Nt in e && Array.isArray(e[Nt]) ? (a = Nt, s = i[Nt]) : yt in e && Array.isArray(e[yt]) && (a = yt, s = i[yt]), a && s && (i = {
        ...i,
        [a]: s.map((c) => cf(c, t, n, r, o))
      });
    }
    return pn(e, i) ? e : i;
  }
  function gEe(e, t, n, r, o) {
    const i = {
      ...t,
      properties: { ...t.properties }
    }, a = r && Rt(r) ? r : {};
    return Object.keys(a).forEach((s) => {
      if (!(s in i.properties)) {
        if (wC in i) {
          const c = XU(i, s);
          if (!Hn(c)) {
            i.properties[s] = vr(e, { [ul]: Object.values(c) }, n, Ee(a, [s]), o), Qt(i.properties, [s, Ba], !0);
            return;
          }
        }
        if (I0 in i && i.additionalProperties !== !1) {
          let c;
          typeof i.additionalProperties != "boolean" ? bn in i.additionalProperties ? c = vr(e, { [bn]: Ee(i.additionalProperties, [bn]) }, n, a, o) : "type" in i.additionalProperties ? c = { ...i.additionalProperties } : Nt in i.additionalProperties || yt in i.additionalProperties ? c = {
            type: "object",
            ...i.additionalProperties
          } : c = { type: bh(Ee(a, [s])) } : c = { type: bh(Ee(a, [s])) }, i.properties[s] = c, Qt(i.properties, [s, Ba], !0);
        } else
          i.properties[s] = { type: "null" }, Qt(i.properties, [s, Ba], !0);
      }
    }), i;
  }
  const { compareSchemaDefinitions: yEe, compareSchemaValues: vEe } = NSe(), { mergeArrayOfSchemaDefinitions: bEe } = BSe({
    intersectJson: kSe(vEe),
    deduplicateJsonSchemaDef: IU(yEe)
  }), xEe = VSe(bEe);
  function wEe(e) {
    return xEe(e);
  }
  function Ii(e, t, n, r, o = !1, i = [], a, s) {
    return Rt(t) ? mEe(e, t, n, o, i, r, a, s).flatMap((u) => {
      var d;
      let p = u;
      if (wbe in p)
        return hEe(e, p, n, o, i, r, a);
      if (ul in p) {
        if (o) {
          const { allOf: g, ...y } = p;
          return [...g, y];
        }
        try {
          const g = [], y = [];
          (d = p.allOf) === null || d === void 0 || d.forEach((b) => {
            typeof b == "object" && b.contains ? g.push(b) : y.push(b);
          }), g.length && (p = { ...p, allOf: y }), p = a ? a(p) : wEe(p), g.length && (p.allOf = g);
        } catch (g) {
          console.warn(`could not merge subschemas in allOf:
`, g);
          const { allOf: y, ...b } = p;
          return b;
        }
      }
      return Ft in p && wC in p && (p = Object.keys(p.properties).reduce((g, y) => {
        const b = XU(g, y);
        return Hn(b) || (g.properties[y] = vr(e, { allOf: [g.properties[y], ...Object.values(b)] }, n, Ee(r, [y]), a)), g;
      }, {
        ...p,
        properties: { ...p.properties }
      })), wC in p || I0 in p && p.additionalProperties !== !1 ? gEe(e, p, n, r, a) : p;
    }) : [{}];
  }
  function SEe(e, t, n, r, o) {
    let i;
    const { oneOf: a, anyOf: s, ...c } = t;
    if (Array.isArray(a) ? i = a : Array.isArray(s) && (i = s), i) {
      const u = o === void 0 && r ? {} : o, d = Ki(t);
      i = i.map((m) => cf(m, n, []));
      const p = mA(e, u, i, n, d);
      if (r)
        return i.map((m) => Za(c, m));
      t = Za(c, i[p]);
    }
    return [t];
  }
  function QU(e, t, n, r, o, i, a) {
    const { dependencies: s, ...c } = t;
    return SEe(e, c, n, r, i).flatMap((d) => JU(e, s, d, n, r, o, i, a));
  }
  function JU(e, t, n, r, o, i, a, s) {
    let c = [n];
    for (const u in t) {
      if (!o && Ee(a, [u]) === void 0 || n.properties && !(u in n.properties))
        continue;
      const [d, p] = hA(u, t);
      return Array.isArray(p) ? c[0] = _Ee(n, p) : Rt(p) && (c = EEe(e, n, r, u, p, o, i, a, s)), c.flatMap((m) => JU(e, d, m, r, o, i, a, s));
    }
    return c;
  }
  function _Ee(e, t) {
    if (!t)
      return e;
    const n = Array.isArray(e.required) ? Array.from(/* @__PURE__ */ new Set([...e.required, ...t])) : t;
    return { ...e, required: n };
  }
  function EEe(e, t, n, r, o, i, a, s, c) {
    return Ii(e, o, n, s, i, a, c).flatMap((d) => {
      const { oneOf: p, ...m } = d;
      if (t = Za(t, m), p === void 0)
        return t;
      const g = p.map((b) => typeof b == "boolean" || !(bn in b) ? [b] : ZU(e, b, n, i, a, s));
      return YU(g).flatMap((b) => CEe(e, t, n, r, b, i, a, s, c));
    });
  }
  function CEe(e, t, n, r, o, i, a, s, c) {
    const u = o.filter((d) => {
      if (typeof d == "boolean" || !d || !d.properties)
        return !1;
      const { [r]: p } = d.properties;
      if (p) {
        const m = {
          type: "object",
          properties: {
            [r]: p
          }
        };
        return e.isValid(m, s, n) || i;
      }
      return !1;
    });
    return !i && u.length !== 1 ? (console.warn("ignoring oneOf in dependencies because there isn't exactly one subschema that is valid"), [t]) : u.flatMap((d) => {
      const p = d, [m] = hA(r, p.properties), g = { ...p, properties: m };
      return Ii(e, g, n, s, i, a, c).map((b) => Za(t, b));
    });
  }
  function Sp(e, t, n, r, o, i = {}, a) {
    if (Array.isArray(n[o])) {
      const c = Ki(n) || r, u = n[o].map((p) => vr(e, p, t, i, a)), d = Ee(i, c);
      if (d !== void 0)
        return u.find((p) => gh(Ee(p, [Ft, c, c1], Ee(p, [Ft, c, Io])), d));
    }
  }
  function eV(e, t, n, r, o) {
    let i = n;
    if (Tt(n, bn) && (i = vr(e, n, t, void 0, o)), Hn(r))
      return i;
    const a = Array.isArray(r) ? r : r.split("."), [s, ...c] = a;
    if (s && Tt(i, s))
      return i = Ee(i, s), eV(e, t, i, c, o);
  }
  function Gv(e, t, n, r, o, i) {
    const a = eV(e, t, n, r, i);
    return a === void 0 ? o : a;
  }
  const vD = { title: "!@#$_UNKNOWN_$#@!" };
  function kEe(e, t, n, r, o = {}, i) {
    const a = Array.isArray(r) ? [...r] : r.split(".");
    let s = n;
    const c = a.pop();
    a.length && a.forEach((m) => {
      s = Gv(e, t, s, [Ft, m], {}, i), Tt(s, yt) ? s = Sp(e, t, s, c, yt, Ee(o, m), i) : Tt(s, Nt) && (s = Sp(e, t, s, c, Nt, Ee(o, m), i));
    }), Tt(s, yt) ? s = Sp(e, t, s, c, yt, o, i) : Tt(s, Nt) && (s = Sp(e, t, s, c, Nt, o, i));
    let u = Gv(e, t, s, [Ft, c], vD, i);
    u === vD && (u = void 0);
    const d = Gv(e, t, s, K8, [], i);
    let p;
    return u && Array.isArray(d) && (p = d.includes(c)), { field: u, isRequired: p };
  }
  function TEe(e, t, n, r) {
    var o = -1, i = e == null ? 0 : e.length;
    for (r && i && (n = e[++o]); ++o < i; )
      n = t(n, e[o], o, e);
    return n;
  }
  function AEe(e, t) {
    return function(n, r) {
      if (n == null)
        return n;
      if (!Rc(n))
        return e(n, r);
      for (var o = n.length, i = -1, a = Object(n); ++i < o && r(a[i], i, a) !== !1; )
        ;
      return n;
    };
  }
  var tV = AEe(xU);
  function REe(e, t, n, r, o) {
    return o(e, function(i, a, s) {
      n = r ? (r = !1, i) : t(n, i, a, s);
    }), n;
  }
  function OEe(e, t, n) {
    var r = Zn(e) ? TEe : REe, o = arguments.length < 3;
    return r(e, lA(t), n, o, tV);
  }
  const MEe = {
    type: "object",
    $id: Sbe,
    properties: {
      __not_really_there__: {
        type: "number"
      }
    }
  };
  function NC(e, t, n, r, o) {
    let i = 0;
    return n && ($t(n.properties) ? i += OEe(n.properties, (a, s, c) => {
      const u = Ee(r, c);
      if (typeof s == "boolean")
        return a;
      if (Tt(s, bn)) {
        const d = vr(e, s, t, u, o);
        return a + NC(e, t, d, u || {}, o);
      }
      if ((Tt(s, yt) || Tt(s, Nt)) && u) {
        const d = Tt(s, yt) ? yt : Nt, p = Ki(s);
        return a + xh(e, t, u, Ee(s, d), -1, p, o);
      }
      if (s.type === "object")
        return $t(u) && (a += 1), a + NC(e, t, s, u, o);
      if (s.type === bh(u)) {
        let d = a + 1;
        return s.default ? d += u === s.default ? 1 : -1 : s.const && (d += u === s.const ? 1 : -1), d;
      }
      return a;
    }, 0) : dl(n.type) && n.type === bh(r) && (i += 1)), i;
  }
  function xh(e, t, n, r, o = -1, i, a) {
    const s = r.map((m) => cf(m, t, [])), c = KU(n, r, i);
    if (GU(c))
      return c;
    const u = s.reduce((m, g, y) => (mA(e, n, [MEe, g], t, i) === 1 && m.push(y), m), []);
    if (u.length === 1)
      return u[0];
    u.length || yU(s.length, (m) => u.push(m));
    const d = /* @__PURE__ */ new Set(), { bestIndex: p } = u.reduce((m, g) => {
      const { bestScore: y } = m, b = s[g], v = NC(e, t, b, n, a);
      return d.add(v), v > y ? { bestIndex: g, bestScore: v } : m;
    }, { bestIndex: o, bestScore: 0 });
    return d.size === 1 && o >= 0 ? o : p;
  }
  function gA(e) {
    return Array.isArray(e.items) && e.items.length > 0 && e.items.every((t) => Rt(t));
  }
  function L0(e) {
    return e == null;
  }
  function wh(e, t, n = !1, r = !1, o = !1) {
    if (Array.isArray(t)) {
      const i = Array.isArray(e) ? e : [], a = o ? i : t, s = o ? t : i, c = a.map((u, d) => s[d] !== void 0 ? wh(i[d], t[d], n, r, o) : u);
      return (n || o) && c.length < s.length && c.push(...s.slice(c.length)), c;
    }
    if (Rt(t)) {
      const i = Object.assign({}, e);
      return Object.keys(t).reduce((a, s) => {
        var c;
        const u = Ee(t, s), d = Rt(e) && s in e, p = s in t, m = (c = Ee(e, s)) !== null && c !== void 0 ? c : {}, g = d && Object.entries(m).some(([, v]) => Rt(v)), y = d && Rt(Ee(e, s)), b = p && Rt(u);
        return y && b && !g ? (a[s] = {
          ...Ee(e, s),
          ...u
        }, a) : (a[s] = wh(
          Ee(e, s),
          u,
          n,
          r,
          // overrideFormDataWithDefaults can be true only when the key value exists in defaults
          // Or if the key value doesn't exist in formData
          o && (d || !p)
        ), a);
      }, i);
    }
    return r && (e !== void 0 && L0(t) || typeof t == "number" && isNaN(t)) || o && !L0(t) ? e : t;
  }
  function Sh(e, t, n = !1) {
    return Object.keys(t).reduce((r, o) => {
      const i = e ? e[o] : {}, a = t[o];
      if (e && o in e && Rt(a))
        r[o] = Sh(i, a, n);
      else if (n && Array.isArray(i) && Array.isArray(a)) {
        let s = a;
        n === "preventDuplicates" && (s = a.reduce((c, u) => (i.includes(u) || c.push(u), c), [])), r[o] = i.concat(s);
      } else
        r[o] = a;
      return r;
    }, Object.assign({}, e));
  }
  function nV(e) {
    return Array.isArray(e.enum) && e.enum.length === 1 || Io in e;
  }
  function yA(e, t, n = {}, r) {
    const o = vr(e, t, n, void 0, r), i = o.oneOf || o.anyOf;
    return Array.isArray(o.enum) ? !0 : Array.isArray(i) ? i.every((a) => typeof a != "boolean" && nV(a)) : !1;
  }
  function vA(e, t, n, r) {
    return !t.uniqueItems || !t.items || typeof t.items == "boolean" ? !1 : yA(e, t.items, n, r);
  }
  function rV(e) {
    const t = e[Io], n = oi(e);
    return Rt(t) && dl(t?.$data) && n !== "object" && n !== "array";
  }
  function NEe(e) {
    if (xbe in e && Array.isArray(e.enum) && e.enum.length === 1)
      return e.enum[0];
    if (Io in e)
      return e.const;
    throw new Error("schema cannot be inferred as a constant");
  }
  function Af(e, t) {
    if (e.enum) {
      let i;
      if (t) {
        const { enumNames: a } = Qe(t);
        i = a;
      }
      return e.enum.map((a, s) => ({ label: i?.[s] || String(a), value: a }));
    }
    let n, r;
    e.anyOf ? (n = e.anyOf, r = t?.anyOf) : e.oneOf && (n = e.oneOf, r = t?.oneOf);
    let o = Ki(e);
    if (t) {
      const { optionsSchemaSelector: i = o } = Qe(t);
      o = i;
    }
    return n && n.map((i, a) => {
      const { title: s } = Qe(r?.[a]), c = i;
      let u, d = s;
      if (o) {
        const p = Ee(c, [Ft, o], {});
        u = Ee(p, c1, Ee(p, Io)), d = d || p?.title || c.title || String(u);
      } else
        u = NEe(c), d = d || c.title || String(u);
      return {
        schema: c,
        label: d,
        value: u
      };
    });
  }
  const PEe = ["string", "number", "integer", "boolean", "null"];
  var Rf;
  (function(e) {
    e[e.Ignore = 0] = "Ignore", e[e.Invert = 1] = "Invert", e[e.Fallback = 2] = "Fallback";
  })(Rf || (Rf = {}));
  function __(e, t = Rf.Ignore, n = -1) {
    if (n >= 0) {
      if (Array.isArray(e.items) && n < e.items.length) {
        const r = e.items[n];
        if (typeof r != "boolean")
          return r;
      }
    } else if (e.items && !Array.isArray(e.items) && typeof e.items != "boolean")
      return e.items;
    return t !== Rf.Ignore && Rt(e.additionalItems) ? e.additionalItems : {};
  }
  function oV(e, t) {
    const { default: n, type: r } = e;
    return Array.isArray(r) && r.includes("null") && Hn(t) && n === null ? null : t;
  }
  function bD(e, t, n, r, o, i = [], a = {}, s = !1, c = !1) {
    const { emptyObjectFields: u = "populateAllDefaults" } = a;
    if (r === !0 || s)
      e[t] = n;
    else if (r === "excludeObjectChildren")
      (c && n !== void 0 || !Rt(n) || !Hn(n)) && (e[t] = n);
    else if (u !== "skipDefaults") {
      const d = o === void 0 ? i.includes(t) : o;
      Rt(n) ? u === "skipEmptyDefaults" ? Hn(n) || (e[t] = n) : (!Hn(n) || i.includes(t)) && (d || u !== "populateRequiredDefaults") && (e[t] = n) : (
        // Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions
        // Condition 1: computedDefault is not undefined
        // Condition 2: If emptyObjectFields is 'populateAllDefaults' or 'skipEmptyDefaults)
        // Or if isSelfOrParentRequired is 'true' and the key is a required field
        n !== void 0 && (u === "populateAllDefaults" || u === "skipEmptyDefaults" || d && i.includes(t)) && (e[t] = n)
      );
    }
  }
  function Qs(e, t, n = {}) {
    const { parentDefaults: r, rawFormData: o, rootSchema: i = {}, includeUndefinedValues: a = !1, _recurseList: s = [], experimental_defaultFormStateBehavior: c = void 0, experimental_customMergeAllOf: u = void 0, required: d, shouldMergeDefaultsIntoFormData: p = !1, initialDefaultsGenerated: m } = n;
    let g = Rt(o) ? o : {};
    const y = Rt(t) ? t : {};
    let b = r, v = null, x = c, E = s;
    if (y[Io] !== void 0 && c?.constAsDefaults !== "never" && !rV(y))
      b = y[Io];
    else if (Rt(b) && Rt(y.default))
      b = Sh(b, y.default);
    else if (c1 in y && !y[Nt] && !y[yt] && !y[bn])
      b = y.default;
    else if (bn in y) {
      const k = y[bn];
      s.includes(k) || (E = s.concat(k), v = WU(k, i)), v && !b && (b = y.default), p && v && !Rt(o) && (g = o);
    } else if (GT in y) {
      const k = {
        ...xD(e, y, n, b),
        ...g
      };
      v = QU(e, y, i, !1, [], k, u)[0];
    } else if (gA(y))
      b = y.items.map((k, A) => Qs(e, k, {
        rootSchema: i,
        includeUndefinedValues: a,
        _recurseList: s,
        experimental_defaultFormStateBehavior: c,
        experimental_customMergeAllOf: u,
        parentDefaults: Array.isArray(r) ? r[A] : void 0,
        rawFormData: g,
        required: d,
        shouldMergeDefaultsIntoFormData: p
      }));
    else if (yt in y) {
      const { oneOf: k, ...A } = y;
      if (k.length === 0)
        return;
      const O = Ki(y), { type: P = "null" } = A;
      !Array.isArray(P) && PEe.includes(P) && x?.constAsDefaults === "skipOneOf" && (x = {
        ...x,
        constAsDefaults: "never"
      }), v = k[xh(e, i, o ?? y.default, k, 0, O, u)], v = Za(A, v);
    } else if (Nt in y) {
      const { anyOf: k, ...A } = y;
      if (k.length === 0)
        return;
      const O = Ki(y);
      v = k[xh(e, i, o ?? y.default, k, 0, O, u)], v = Za(A, v);
    }
    if (v)
      return Qs(e, v, {
        rootSchema: i,
        includeUndefinedValues: a,
        _recurseList: E,
        experimental_defaultFormStateBehavior: x,
        experimental_customMergeAllOf: u,
        parentDefaults: b,
        rawFormData: o ?? g,
        required: d,
        shouldMergeDefaultsIntoFormData: p,
        initialDefaultsGenerated: m
      });
    b === void 0 && (b = y.default);
    const _ = xD(e, y, n, b);
    let C = _ ?? b;
    if (p) {
      const { arrayMinItems: k = {} } = c || {}, { mergeExtraDefaults: A } = k, O = IEe(e, y, i, o, c, u);
      (!Rt(o) || ul in y) && (C = wh(C, O, A, !0));
    }
    return C;
  }
  function IEe(e, t, n, r, o, i) {
    const a = !nV(t) && yA(e, t, n, i);
    let s = r;
    if (a) {
      const u = Af(t);
      s = u?.some((p) => pn(p.value, r)) ? r : void 0;
    }
    return t[Io] && o?.constAsDefaults === "always" && (s = t.const), s;
  }
  function $Ee(e, t, { rawFormData: n, rootSchema: r = {}, includeUndefinedValues: o = !1, _recurseList: i = [], experimental_defaultFormStateBehavior: a = void 0, experimental_customMergeAllOf: s = void 0, required: c, shouldMergeDefaultsIntoFormData: u, initialDefaultsGenerated: d } = {}, p) {
    {
      const m = Rt(n) ? n : {}, g = t, y = a?.allOf === "populateDefaults" && ul in g ? vr(e, g, r, m, s) : g, b = y[Io], v = Object.keys(y.properties || {}).reduce((x, E) => {
        var _;
        const C = Ee(y, [Ft, E], {}), k = Rt(b) && b[E] !== void 0, A = (Rt(C) && Io in C || k) && a?.constAsDefaults !== "never" && !rV(C), O = Qs(e, C, {
          rootSchema: r,
          _recurseList: i,
          experimental_defaultFormStateBehavior: a,
          experimental_customMergeAllOf: s,
          includeUndefinedValues: o === !0,
          parentDefaults: Ee(p, [E]),
          rawFormData: Ee(m, [E]),
          required: (_ = y.required) === null || _ === void 0 ? void 0 : _.includes(E),
          shouldMergeDefaultsIntoFormData: u,
          initialDefaultsGenerated: d
        });
        return bD(x, E, O, o, c, y.required, a, A, C?.type === "null"), x;
      }, {});
      if (y.additionalProperties && !d) {
        const x = Rt(y.additionalProperties) ? y.additionalProperties : {}, E = /* @__PURE__ */ new Set();
        Rt(p) && Object.keys(p).filter((C) => !y.properties || !y.properties[C]).forEach((C) => E.add(C));
        const _ = [];
        Object.keys(m).filter((C) => !y.properties || !y.properties[C]).forEach((C) => {
          E.add(C), _.push(C);
        }), E.forEach((C) => {
          var k;
          const A = Qs(e, x, {
            rootSchema: r,
            _recurseList: i,
            experimental_defaultFormStateBehavior: a,
            experimental_customMergeAllOf: s,
            includeUndefinedValues: o === !0,
            parentDefaults: Ee(p, [C]),
            rawFormData: Ee(m, [C]),
            required: (k = y.required) === null || k === void 0 ? void 0 : k.includes(C),
            shouldMergeDefaultsIntoFormData: u,
            initialDefaultsGenerated: d
          });
          bD(v, C, A, o, c, _);
        });
      }
      return oV(t, v);
    }
  }
  function jEe(e, t, { rawFormData: n, rootSchema: r = {}, _recurseList: o = [], experimental_defaultFormStateBehavior: i = void 0, experimental_customMergeAllOf: a = void 0, required: s, requiredAsRoot: c = !1, shouldMergeDefaultsIntoFormData: u, initialDefaultsGenerated: d } = {}, p) {
    var m, g;
    const y = t, b = (m = i?.arrayMinItems) !== null && m !== void 0 ? m : {}, { populate: v, mergeExtraDefaults: x } = b, E = v === "never", _ = v === "requiredOnly", C = v === "all" || !E && !_, k = (g = b?.computeSkipPopulate) !== null && g !== void 0 ? g : (() => !1), O = i?.emptyObjectFields === "skipEmptyDefaults" ? void 0 : [];
    if (Array.isArray(p) && (p = p.map((L, N) => {
      const U = __(y, Rf.Fallback, N);
      return Qs(e, U, {
        rootSchema: r,
        _recurseList: o,
        experimental_defaultFormStateBehavior: i,
        experimental_customMergeAllOf: a,
        parentDefaults: L,
        required: s,
        shouldMergeDefaultsIntoFormData: u,
        initialDefaultsGenerated: d
      });
    })), Array.isArray(n)) {
      const L = __(y);
      if (E)
        p = n;
      else {
        const N = n.map((j, V) => Qs(e, L, {
          rootSchema: r,
          _recurseList: o,
          experimental_defaultFormStateBehavior: i,
          experimental_customMergeAllOf: a,
          rawFormData: j,
          parentDefaults: Ee(p, [V]),
          required: s,
          shouldMergeDefaultsIntoFormData: u,
          initialDefaultsGenerated: d
        }));
        p = wh(p, N, (_ && s || C) && x);
      }
    }
    if ((Rt(y) && Io in y && i?.constAsDefaults !== "never") === !1) {
      if (E)
        return p ?? O;
      if (_ && !s)
        return p || void 0;
    }
    let I;
    const $ = Array.isArray(p) ? p.length : 0;
    if (!y.minItems || vA(e, y, r, a) || k(e, y, r) || y.minItems <= $)
      I = p || !s && !c ? p : O;
    else {
      const L = p || [], N = __(y, Rf.Invert), U = N.default, j = Array.from({ length: y.minItems - $ }, () => Qs(e, N, {
        parentDefaults: U,
        rootSchema: r,
        _recurseList: o,
        experimental_defaultFormStateBehavior: i,
        experimental_customMergeAllOf: a,
        required: s,
        shouldMergeDefaultsIntoFormData: u
      }));
      I = L.concat(j);
    }
    return oV(t, I);
  }
  function xD(e, t, n = {}, r) {
    switch (oi(t)) {
      // We need to recurse for object schema inner default values.
      case "object":
        return $Ee(e, t, n, r);
      case "array":
        return jEe(e, t, n, r);
    }
  }
  function iV(e, t, n, r, o = !1, i, a, s) {
    if (!Rt(t))
      throw new Error("Invalid schema: " + t);
    const c = vr(e, t, r, n, a), u = Qs(e, c, {
      rootSchema: r,
      includeUndefinedValues: o,
      experimental_defaultFormStateBehavior: i,
      experimental_customMergeAllOf: a,
      rawFormData: n,
      shouldMergeDefaultsIntoFormData: !0,
      initialDefaultsGenerated: s,
      requiredAsRoot: !0
    });
    if (c.type !== "object" && Rt(c.default))
      return {
        ...u,
        ...n
      };
    if (Rt(n) || Array.isArray(n)) {
      const { mergeDefaultsIntoFormData: d } = i || {};
      return wh(
        u,
        n,
        !0,
        d === "useDefaultIfFormDataUndefined",
        !0
      );
    }
    return u;
  }
  function aV(e = {}) {
    return (
      // TODO: Remove the `&& uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.
      // https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets
      "widget" in Qe(e) && Qe(e).widget !== "hidden"
    );
  }
  function sV(e, t, n = {}, r, o) {
    if (n[YT] === "files")
      return !0;
    if (t.items) {
      const i = vr(e, t.items, r, void 0, o);
      return i.type === "string" && i.format === "data-url";
    }
    return !1;
  }
  function DEe(e, t, n = {}, r, o, i) {
    const a = Qe(n, o), { label: s = !0 } = a;
    let c = !!s;
    if (c) {
      const u = oi(t), d = Ee(t, Ba, !1);
      u === "array" && (c = d || vA(e, t, r, i) || sV(e, t, n, r, i) || aV(n)), u === "object" && (c = d), u === "boolean" && n && !n[YT] && (c = !1), n && n[Cbe] && (c = !1);
    }
    return c;
  }
  const Pu = /* @__PURE__ */ Symbol("no Value");
  function PC(e, t, n, r, o = {}, i) {
    let a;
    if (Tt(n, Ft)) {
      const s = {};
      if (Tt(r, Ft)) {
        const d = Ee(r, Ft, {});
        Object.keys(d).forEach((p) => {
          Tt(o, p) && (s[p] = void 0);
        });
      }
      const c = Object.keys(Ee(n, Ft, {})), u = {};
      c.forEach((d) => {
        const p = Ee(o, d);
        let m = Ee(r, [Ft, d], {}), g = Ee(n, [Ft, d], {});
        Tt(m, bn) && (m = vr(e, m, t, p, i)), Tt(g, bn) && (g = vr(e, g, t, p, i));
        const y = Ee(m, "type"), b = Ee(g, "type");
        if (!y || y === b)
          if (Tt(s, d) && delete s[d], b === "object" || b === "array" && Array.isArray(p)) {
            const v = PC(e, t, g, m, p, i);
            (v !== void 0 || b === "array") && (u[d] = v);
          } else {
            const v = Ee(g, "default", Pu), x = Ee(m, "default", Pu);
            v !== Pu && v !== p && (x === p ? s[d] = v : Ee(g, "readOnly") === !0 && (s[d] = void 0));
            const E = Ee(g, "const", Pu), _ = Ee(m, "const", Pu);
            E !== Pu && E !== p && (s[d] = _ === p ? E : void 0);
          }
      }), a = {
        ...typeof o == "string" || Array.isArray(o) ? void 0 : o,
        ...s,
        ...u
      };
    } else if (Ee(r, "type") === "array" && Ee(n, "type") === "array" && Array.isArray(o)) {
      let s = Ee(r, "items"), c = Ee(n, "items");
      if (typeof s == "object" && typeof c == "object" && !Array.isArray(s) && !Array.isArray(c)) {
        Tt(s, bn) && (s = vr(e, s, t, o, i)), Tt(c, bn) && (c = vr(e, c, t, o, i));
        const u = Ee(s, "type"), d = Ee(c, "type");
        if (!u || u === d) {
          const p = Ee(n, "maxItems", -1);
          d === "object" ? a = o.reduce((m, g) => {
            const y = PC(e, t, c, s, g, i);
            return y !== void 0 && (p < 0 || m.length < p) && m.push(y), m;
          }, []) : a = p > 0 && o.length > p ? o.slice(0, p) : o;
        }
      } else typeof s == "boolean" && typeof c == "boolean" && s === c && (a = o);
    }
    return a;
  }
  function Zl(e, t, n, r, o, i = [], a) {
    if (bn in t || GT in t || ul in t) {
      const c = vr(e, t, r, o, a);
      if (i.findIndex((d) => pn(d, c)) === -1)
        return Zl(e, c, n, r, o, i.concat(c), a);
    }
    let s = {
      [Vv]: n.replace(/^\./, "")
    };
    if (yt in t || Nt in t) {
      const c = yt in t ? t.oneOf : t.anyOf, u = Ki(t), d = xh(e, r, o, c, 0, u, a), p = c[d];
      s = {
        ...s,
        ...Zl(e, p, n, r, o, i, a)
      };
    }
    if (I0 in t && t[I0] !== !1 && Qt(s, KT, !0), Cf in t && Array.isArray(o)) {
      const { items: c, additionalItems: u } = t;
      Array.isArray(c) ? o.forEach((d, p) => {
        c[p] ? s[p] = Zl(e, c[p], `${n}.${p}`, r, d, i, a) : u ? s[p] = Zl(e, u, `${n}.${p}`, r, d, i, a) : console.warn(`Unable to generate path schema for "${n}.${p}". No schema defined for it`);
      }) : o.forEach((d, p) => {
        s[p] = Zl(e, c, `${n}.${p}`, r, d, i, a);
      });
    } else if (Ft in t)
      for (const c in t.properties) {
        const u = Ee(t, [Ft, c], {});
        s[c] = Zl(
          e,
          u,
          `${n}.${c}`,
          r,
          // It's possible that formData is not an object -- this can happen if an
          // array item has just been added, but not populated with data yet
          Ee(o, [c]),
          i,
          a
        );
      }
    return s;
  }
  function FEe(e, t, n = "", r, o, i) {
    return Zl(e, t, n, r, o, void 0, i);
  }
  class LEe {
    /** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables
     *
     * @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs
     * @param rootSchema - The root schema that will be forwarded to all the APIs
     * @param experimental_defaultFormStateBehavior - Configuration flags to allow users to override default form state behavior
     * @param [experimental_customMergeAllOf] - Optional function that allows for custom merging of `allOf` schemas
     */
    constructor(t, n, r, o) {
      n && n[xp] === Hv ? this.rootSchema = MC(n, Ee(n, rn, "#")) : this.rootSchema = n, this.validator = t, this.experimental_defaultFormStateBehavior = r, this.experimental_customMergeAllOf = o;
    }
    /** Returns the `rootSchema` in the `SchemaUtilsType`
     *
     * @returns - The `rootSchema`
     */
    getRootSchema() {
      return this.rootSchema;
    }
    /** Returns the `ValidatorType` in the `SchemaUtilsType`
     *
     * @returns - The `ValidatorType`
     */
    getValidator() {
      return this.validator;
    }
    /** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of
     * the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation
     * of a new `SchemaUtilsType` with incomplete properties.
     *
     * @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one
     * @param rootSchema - The root schema that will be compared against the current one
     * @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior
     * @param [experimental_customMergeAllOf] - Optional function that allows for custom merging of `allOf` schemas
     * @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`
     */
    doesSchemaUtilsDiffer(t, n, r = {}, o) {
      return !t || !n ? !1 : this.validator !== t || !pn(this.rootSchema, n) || !pn(this.experimental_defaultFormStateBehavior, r) || this.experimental_customMergeAllOf !== o;
    }
    /** Finds the field specified by the `path` within the root or recursed `schema`. If there is no field for the specified
     * `path`, then the default `{ field: undefined, isRequired: undefined }` is returned. It determines whether a leaf
     * field is in the `required` list for its parent and if so, it is marked as required on return.
     *
     * @param schema - The current node within the JSON schema
     * @param path - The remaining keys in the path to the desired field
     * @param [formData] - The form data that is used to determine which oneOf option
     * @returns - An object that contains the field and its required state. If no field can be found then
     *            `{ field: undefined, isRequired: undefined }` is returned.
     */
    findFieldInSchema(t, n, r) {
      return kEe(this.validator, this.rootSchema, t, n, r, this.experimental_customMergeAllOf);
    }
    /** Finds the oneOf option inside the `schema['any/oneOf']` list which has the `properties[selectorField].default` that
     * matches the `formData[selectorField]` value. For the purposes of this function, `selectorField` is either
     * `schema.discriminator.propertyName` or `fallbackField`.
     *
     * @param schema - The schema element in which to search for the selected oneOf option
     * @param fallbackField - The field to use as a backup selector field if the schema does not have a required field
     * @param xxx - Either `oneOf` or `anyOf`, defines which value is being sought
     * @param [formData={}] - The form data that is used to determine which oneOf option
     * @returns - The anyOf/oneOf option that matches the selector field in the schema or undefined if nothing is selected
     */
    findSelectedOptionInXxxOf(t, n, r, o) {
      return Sp(this.validator, this.rootSchema, t, n, r, o, this.experimental_customMergeAllOf);
    }
    /** Returns the superset of `formData` that includes the given set updated to include any missing fields that have
     * computed to have defaults provided in the `schema`.
     *
     * @param schema - The schema for which the default state is desired
     * @param [formData] - The current formData, if any, onto which to provide any missing defaults
     * @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.
     *          If "excludeObjectChildren", pass `includeUndefinedValues` as false when computing defaults for any nested
     *          object properties.
     * @param initialDefaultsGenerated - Indicates whether or not initial defaults have been generated
     * @returns - The resulting `formData` with all the defaults provided
     */
    getDefaultFormState(t, n, r = !1, o) {
      return iV(this.validator, t, n, this.rootSchema, r, this.experimental_defaultFormStateBehavior, this.experimental_customMergeAllOf, o);
    }
    /** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`
     * should be displayed in a UI.
     *
     * @param schema - The schema for which the display label flag is desired
     * @param [uiSchema] - The UI schema from which to derive potentially displayable information
     * @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options
     * @returns - True if the label should be displayed or false if it should not
     */
    getDisplayLabel(t, n, r) {
      return DEe(this.validator, t, n, this.rootSchema, r, this.experimental_customMergeAllOf);
    }
    /** Determines which of the given `options` provided most closely matches the `formData`.
     * Returns the index of the option that is valid and is the closest match, or 0 if there is no match.
     *
     * The closest match is determined using the number of matching properties, and more heavily favors options with
     * matching readOnly, default, or const values.
     *
     * @param formData - The form data associated with the schema
     * @param options - The list of options that can be selected from
     * @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified
     * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
     *          determine which option is selected
     * @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match
     */
    getClosestMatchingOption(t, n, r, o) {
      return xh(this.validator, this.rootSchema, t, n, r, o, this.experimental_customMergeAllOf);
    }
    /** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.
     * Always returns the first option if there is nothing that matches.
     *
     * @param formData - The current formData, if any, used to figure out a match
     * @param options - The list of options to find a matching options from
     * @param [discriminatorField] - The optional name of the field within the options object whose value is used to
     *          determine which option is selected
     * @returns - The firstindex of the matched option or 0 if none is available
     */
    getFirstMatchingOption(t, n, r) {
      return mA(this.validator, t, n, this.rootSchema, r);
    }
    getFromSchema(t, n, r) {
      return Gv(
        this.validator,
        this.rootSchema,
        t,
        n,
        // @ts-expect-error TS2769: No overload matches this call
        r,
        this.experimental_customMergeAllOf
      );
    }
    /** Checks to see if the `schema` and `uiSchema` combination represents an array of files
     *
     * @param schema - The schema for which check for array of files flag is desired
     * @param [uiSchema] - The UI schema from which to check the widget
     * @returns - True if schema/uiSchema contains an array of files, otherwise false
     */
    isFilesArray(t, n) {
      return sV(this.validator, t, n, this.rootSchema, this.experimental_customMergeAllOf);
    }
    /** Checks to see if the `schema` combination represents a multi-select
     *
     * @param schema - The schema for which check for a multi-select flag is desired
     * @returns - True if schema contains a multi-select, otherwise false
     */
    isMultiSelect(t) {
      return vA(this.validator, t, this.rootSchema, this.experimental_customMergeAllOf);
    }
    /** Checks to see if the `schema` combination represents a select
     *
     * @param schema - The schema for which check for a select flag is desired
     * @returns - True if schema contains a select, otherwise false
     */
    isSelect(t) {
      return yA(this.validator, t, this.rootSchema, this.experimental_customMergeAllOf);
    }
    /** Retrieves an expanded schema that has had all of its conditions, additional properties, references and
     * dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially
     * recursive resolution.
     *
     * @param schema - The schema for which retrieving a schema is desired
     * @param [rawFormData] - The current formData, if any, to assist retrieving a schema
     * @param [resolveAnyOfOrOneOfRefs] - Optional flag indicating whether to resolved refs in anyOf/oneOf lists
     * @returns - The schema having its conditions, additional properties, references and dependencies resolved
     */
    retrieveSchema(t, n, r) {
      return vr(this.validator, t, this.rootSchema, n, this.experimental_customMergeAllOf, r);
    }
    /** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the
     * new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the
     * nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the
     * old schemas that are non-existent in the new schema are set to `undefined`.
     *
     * @param [newSchema] - The new schema for which the data is being sanitized
     * @param [oldSchema] - The old schema from which the data originated
     * @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined
     * @returns - The new form data, with all the fields uniquely associated with the old schema set
     *      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.
     */
    sanitizeDataForNewSchema(t, n, r) {
      return PC(this.validator, this.rootSchema, t, n, r, this.experimental_customMergeAllOf);
    }
    /** Generates an `PathSchema` object for the `schema`, recursively
     *
     * @param schema - The schema for which the display label flag is desired
     * @param [name] - The base name for the schema
     * @param [formData] - The current formData, if any, onto which to provide any missing defaults
     * @returns - The `PathSchema` object for the `schema`
     */
    toPathSchema(t, n, r) {
      return FEe(this.validator, t, n, this.rootSchema, r, this.experimental_customMergeAllOf);
    }
  }
  function zEe(e, t, n = {}, r) {
    return new LEe(e, t, n, r);
  }
  function BEe(e) {
    var t;
    if (e.indexOf("data:") === -1)
      throw new Error("File is invalid: URI must be a dataURI");
    const r = e.slice(5).split(";base64,");
    if (r.length !== 2)
      throw new Error("File is invalid: dataURI must be base64");
    const [o, i] = r, [a, ...s] = o.split(";"), c = a || "", u = decodeURI(
      // parse the parameters into key-value pairs, find a key, and extract a value
      // if no key is found, then the name is unknown
      ((t = s.map((d) => d.split("=")).find(([d]) => d === "name")) === null || t === void 0 ? void 0 : t[1]) || "unknown"
    );
    try {
      const d = atob(i), p = new Array(d.length);
      for (let g = 0; g < d.length; g++)
        p[g] = d.charCodeAt(g);
      return { blob: new window.Blob([new Uint8Array(p)], { type: c }), name: u };
    } catch (d) {
      throw new Error("File is invalid: " + d.message);
    }
  }
  function Vs(e, t) {
    let n = String(e);
    for (; n.length < t; )
      n = "0" + n;
    return n;
  }
  function lV(e, t) {
    if (e <= 0 && t <= 0)
      e = (/* @__PURE__ */ new Date()).getFullYear() + e, t = (/* @__PURE__ */ new Date()).getFullYear() + t;
    else if (e < 0 || t < 0)
      throw new Error(`Both start (${e}) and stop (${t}) must both be <= 0 or > 0, got one of each`);
    if (e > t)
      return lV(t, e).reverse();
    const n = [];
    for (let r = e; r <= t; r++)
      n.push({ value: r, label: Vs(r, 2) });
    return n;
  }
  function wD(e, t) {
    if (Object.is(e, t))
      return !0;
    if (e == null || t == null || typeof e != "object" || typeof t != "object")
      return !1;
    const n = Object.keys(e), r = Object.keys(t);
    if (n.length !== r.length)
      return !1;
    for (let o = 0; o < n.length; o++) {
      const i = n[o];
      if (!Object.prototype.hasOwnProperty.call(t, i) || !Object.is(e[i], t[i]))
        return !1;
    }
    return !0;
  }
  function UEe(e, t) {
    let n = e;
    if (Array.isArray(t)) {
      const r = n.split(/(%\d)/);
      t.forEach((o, i) => {
        const a = r.findIndex((s) => s === `%${i + 1}`);
        a >= 0 && (r[a] = o);
      }), n = r.join("");
    }
    return n;
  }
  function VEe(e, t) {
    return UEe(e, t);
  }
  function Jn(e, t = [], n) {
    if (Array.isArray(e))
      return e.map((i) => Jn(i, t)).filter((i) => i !== n);
    const r = e === "" || e === null ? -1 : Number(e), o = t[r];
    return o ? o.value : n;
  }
  function cV(e, t, n = []) {
    const r = Jn(e, n);
    return Array.isArray(t) ? t.filter((o) => !pn(o, r)) : pn(r, t) ? void 0 : t;
  }
  function b1(e, t) {
    return Array.isArray(t) ? t.some((n) => pn(n, e)) : pn(t, e);
  }
  function bA(e, t = [], n = !1) {
    const r = t.map((o, i) => b1(o.value, e) ? String(i) : void 0).filter((o) => typeof o < "u");
    return n ? r : r[0];
  }
  function uV(e, t, n = []) {
    const r = Jn(e, n);
    if (!L0(r)) {
      const o = n.findIndex((s) => r === s.value), i = n.map(({ value: s }) => s);
      return t.slice(0, o).concat(r, t.slice(o)).sort((s, c) => +(i.indexOf(s) > i.indexOf(c)));
    }
    return t;
  }
  var HEe = 1, qEe = 4;
  function xA(e) {
    return $p(e, HEe | qEe);
  }
  function WEe(e, t, n, r) {
    return r = typeof r == "function" ? r : void 0, e == null ? e : aA(e, t, n, r);
  }
  class fV {
    /** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.
     *
     * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class
     */
    constructor(t) {
      this.errorSchema = {}, this.resetAllErrors(t);
    }
    /** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`
     */
    get ErrorSchema() {
      return this.errorSchema;
    }
    /** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.
     *
     * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)
     * @returns - The error block for the given `pathOfError` or the root if not provided
     * @private
     */
    getOrCreateErrorBlock(t) {
      let r = Array.isArray(t) && t.length > 0 || typeof t == "string" ? Ee(this.errorSchema, t) : this.errorSchema;
      return !r && t && (r = {}, WEe(this.errorSchema, t, r, Object)), r;
    }
    /** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.
     *
     * @param [initialSchema] - The optional set of initial errors, that will be cloned into the class
     * @returns - The `ErrorSchemaBuilder` object for chaining purposes
     */
    resetAllErrors(t) {
      return this.errorSchema = t ? xA(t) : {}, this;
    }
    /** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within
     * the schema described by the `pathOfError`. For more information about how to specify the path see the
     * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
     *
     * @param errorOrList - The error or list of errors to add into the `ErrorSchema`
     * @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)
     * @returns - The `ErrorSchemaBuilder` object for chaining purposes
     */
    addErrors(t, n) {
      const r = this.getOrCreateErrorBlock(n);
      let o = Ee(r, ur);
      return Array.isArray(o) || (o = [], r[ur] = o), Array.isArray(t) ? Qt(r, ur, [.../* @__PURE__ */ new Set([...o, ...t])]) : Qt(r, ur, [.../* @__PURE__ */ new Set([...o, t])]), this;
    }
    /** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location
     * within the schema described by the `pathOfError`. For more information about how to specify the path see the
     * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
     *
     * @param errorOrList - The error or list of errors to set into the `ErrorSchema`
     * @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)
     * @returns - The `ErrorSchemaBuilder` object for chaining purposes
     */
    setErrors(t, n) {
      const r = this.getOrCreateErrorBlock(n), o = Array.isArray(t) ? [.../* @__PURE__ */ new Set([...t])] : [t];
      return Qt(r, ur, o), this;
    }
    /** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by
     * the `pathOfError`. For more information about how to specify the path see the
     * [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).
     *
     * @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)
     * @returns - The `ErrorSchemaBuilder` object for chaining purposes
     */
    clearErrors(t) {
      const n = this.getOrCreateErrorBlock(t);
      return Qt(n, ur, []), this;
    }
  }
  function dV(e, t, n) {
    for (var r = -1, o = t.length, i = {}; ++r < o; ) {
      var a = t[r], s = m1(e, a);
      n(s, a) && aA(i, Hf(a, e), s);
    }
    return i;
  }
  function GEe(e, t) {
    if (e == null)
      return {};
    var n = Vf(dA(e), function(r) {
      return [r];
    });
    return t = lA(t), dV(e, n, function(r, o) {
      return t(r, o[0]);
    });
  }
  var KEe = 200;
  function YEe(e, t, n, r) {
    var o = -1, i = fA, a = !0, s = e.length, c = [], u = t.length;
    if (!s)
      return c;
    t.length >= KEe && (i = mh, a = !1, t = new bc(t));
    e:
      for (; ++o < s; ) {
        var d = e[o], p = d;
        if (d = d !== 0 ? d : 0, a && p === p) {
          for (var m = u; m--; )
            if (t[m] === p)
              continue e;
          c.push(d);
        } else i(t, p, r) || c.push(d);
      }
    return c;
  }
  var XEe = y1(function(e, t) {
    return yh(e) ? YEe(e, dm(t, 1, yh, !0)) : [];
  });
  function SD(e, t) {
    const n = fl(e), r = fl(t);
    if (e === t || !n && !r)
      return [];
    if (n && !r)
      return Ko(e);
    if (!n && r)
      return Ko(t);
    {
      const o = Ko(GEe(e, (a, s) => !pn(a, Ee(t, s)))), i = XEe(Ko(t), Ko(e));
      return [...o, ...i];
    }
  }
  function ZEe(e, t, n = [1900, (/* @__PURE__ */ new Date()).getFullYear() + 2], r = "YMD") {
    const { day: o, month: i, year: a, hour: s, minute: c, second: u } = e, d = { type: "day", range: [1, 31], value: o }, p = { type: "month", range: [1, 12], value: i }, m = { type: "year", range: n, value: a }, g = [];
    switch (r) {
      case "MDY":
        g.push(p, d, m);
        break;
      case "DMY":
        g.push(d, p, m);
        break;
      default:
        g.push(m, p, d);
    }
    return t && g.push({ type: "hour", range: [0, 23], value: s }, { type: "minute", range: [0, 59], value: c }, { type: "second", range: [0, 59], value: u }), g;
  }
  function pV(e) {
    const t = {};
    return e.multipleOf && (t.step = e.multipleOf), (e.minimum || e.minimum === 0) && (t.min = e.minimum), (e.maximum || e.maximum === 0) && (t.max = e.maximum), t;
  }
  function hV(e, t, n = {}, r = !0) {
    const o = {
      type: t || "text",
      ...pV(e)
    };
    return n.inputType ? o.type = n.inputType : t || (e.type === "number" ? (o.type = "number", r && o.step === void 0 && (o.step = "any")) : e.type === "integer" && (o.type = "number", o.step === void 0 && (o.step = 1))), n.autocomplete && (o.autoComplete = n.autocomplete), n.accept && (o.accept = n.accept), o;
  }
  const _D = {
    props: {
      disabled: !1
    },
    submitText: "Submit",
    norender: !1
  };
  function mV(e = {}) {
    const t = Qe(e);
    if (t && t[$0]) {
      const n = t[$0];
      return { ..._D, ...n };
    }
    return _D;
  }
  function tt(e, t, n = {}) {
    const { templates: r } = t;
    if (e === "ButtonTemplates")
      return r[e];
    if (Object.hasOwn(n, e) && typeof n[e] == "string" && Object.hasOwn(r, n[e])) {
      const o = n[e];
      return r[o];
    }
    return (
      // Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent
      // To avoid that, we cast uiOptions to `any` before accessing the name field
      n[e] || r[e]
    );
  }
  var QEe = 0;
  function gV(e) {
    var t = ++QEe;
    return rA(e) + t;
  }
  function wA() {
    if (typeof process > "u" || Ee(process, "env.NODE_ENV") !== "test")
      return {};
    const e = /* @__PURE__ */ new Map();
    return new Proxy({}, {
      get(t, n) {
        return e.has(n) || e.set(n, gV("test-id-")), e.get(n);
      }
    });
  }
  var E_ = { exports: {} }, qt = {};
  var ED;
  function JEe() {
    if (ED) return qt;
    ED = 1;
    var e = /* @__PURE__ */ Symbol.for("react.element"), t = /* @__PURE__ */ Symbol.for("react.portal"), n = /* @__PURE__ */ Symbol.for("react.fragment"), r = /* @__PURE__ */ Symbol.for("react.strict_mode"), o = /* @__PURE__ */ Symbol.for("react.profiler"), i = /* @__PURE__ */ Symbol.for("react.provider"), a = /* @__PURE__ */ Symbol.for("react.context"), s = /* @__PURE__ */ Symbol.for("react.server_context"), c = /* @__PURE__ */ Symbol.for("react.forward_ref"), u = /* @__PURE__ */ Symbol.for("react.suspense"), d = /* @__PURE__ */ Symbol.for("react.suspense_list"), p = /* @__PURE__ */ Symbol.for("react.memo"), m = /* @__PURE__ */ Symbol.for("react.lazy"), g = /* @__PURE__ */ Symbol.for("react.offscreen"), y;
    y = /* @__PURE__ */ Symbol.for("react.module.reference");
    function b(v) {
      if (typeof v == "object" && v !== null) {
        var x = v.$$typeof;
        switch (x) {
          case e:
            switch (v = v.type, v) {
              case n:
              case o:
              case r:
              case u:
              case d:
                return v;
              default:
                switch (v = v && v.$$typeof, v) {
                  case s:
                  case a:
                  case c:
                  case m:
                  case p:
                  case i:
                    return v;
                  default:
                    return x;
                }
            }
          case t:
            return x;
        }
      }
    }
    return qt.ContextConsumer = a, qt.ContextProvider = i, qt.Element = e, qt.ForwardRef = c, qt.Fragment = n, qt.Lazy = m, qt.Memo = p, qt.Portal = t, qt.Profiler = o, qt.StrictMode = r, qt.Suspense = u, qt.SuspenseList = d, qt.isAsyncMode = function() {
      return !1;
    }, qt.isConcurrentMode = function() {
      return !1;
    }, qt.isContextConsumer = function(v) {
      return b(v) === a;
    }, qt.isContextProvider = function(v) {
      return b(v) === i;
    }, qt.isElement = function(v) {
      return typeof v == "object" && v !== null && v.$$typeof === e;
    }, qt.isForwardRef = function(v) {
      return b(v) === c;
    }, qt.isFragment = function(v) {
      return b(v) === n;
    }, qt.isLazy = function(v) {
      return b(v) === m;
    }, qt.isMemo = function(v) {
      return b(v) === p;
    }, qt.isPortal = function(v) {
      return b(v) === t;
    }, qt.isProfiler = function(v) {
      return b(v) === o;
    }, qt.isStrictMode = function(v) {
      return b(v) === r;
    }, qt.isSuspense = function(v) {
      return b(v) === u;
    }, qt.isSuspenseList = function(v) {
      return b(v) === d;
    }, qt.isValidElementType = function(v) {
      return typeof v == "string" || typeof v == "function" || v === n || v === o || v === r || v === u || v === d || v === g || typeof v == "object" && v !== null && (v.$$typeof === m || v.$$typeof === p || v.$$typeof === i || v.$$typeof === a || v.$$typeof === c || v.$$typeof === y || v.getModuleId !== void 0);
    }, qt.typeOf = b, qt;
  }
  var CD;
  function eCe() {
    return CD || (CD = 1, E_.exports = JEe()), E_.exports;
  }
  var tCe = eCe();
  const kD = /* @__PURE__ */ Xi(tCe), C_ = {
    boolean: {
      checkbox: "CheckboxWidget",
      radio: "RadioWidget",
      select: "SelectWidget",
      hidden: "HiddenWidget"
    },
    string: {
      text: "TextWidget",
      password: "PasswordWidget",
      email: "EmailWidget",
      hostname: "TextWidget",
      ipv4: "TextWidget",
      ipv6: "TextWidget",
      uri: "URLWidget",
      "data-url": "FileWidget",
      radio: "RadioWidget",
      select: "SelectWidget",
      textarea: "TextareaWidget",
      hidden: "HiddenWidget",
      date: "DateWidget",
      datetime: "DateTimeWidget",
      "date-time": "DateTimeWidget",
      "alt-date": "AltDateWidget",
      "alt-datetime": "AltDateTimeWidget",
      time: "TimeWidget",
      color: "ColorWidget",
      file: "FileWidget"
    },
    number: {
      text: "TextWidget",
      select: "SelectWidget",
      updown: "UpDownWidget",
      range: "RangeWidget",
      radio: "RadioWidget",
      hidden: "HiddenWidget"
    },
    integer: {
      text: "TextWidget",
      select: "SelectWidget",
      updown: "UpDownWidget",
      range: "RangeWidget",
      radio: "RadioWidget",
      hidden: "HiddenWidget"
    },
    array: {
      select: "SelectWidget",
      checkboxes: "CheckboxesWidget",
      files: "FileWidget",
      hidden: "HiddenWidget"
    }
  };
  function nCe(e) {
    let t = Ee(e, "MergedWidget");
    if (!t) {
      const n = e.defaultProps && e.defaultProps.options || {};
      t = ({ options: r, ...o }) => S.jsx(e, { options: { ...n, ...r }, ...o }), Qt(e, "MergedWidget", t);
    }
    return t;
  }
  function Yi(e, t, n = {}) {
    const r = oi(e);
    if (typeof t == "function" || t && kD.isForwardRef(T.createElement(t)) || kD.isMemo(t))
      return nCe(t);
    if (typeof t != "string")
      throw new Error(`Unsupported widget definition: ${typeof t} in schema: ${JSON.stringify(e)}`);
    if (t in n) {
      const o = n[t];
      return Yi(e, o, n);
    }
    if (typeof r == "string") {
      if (!(r in C_))
        throw new Error(`No widget for type '${r}' in schema: ${JSON.stringify(e)}`);
      if (t in C_[r]) {
        const o = n[C_[r][t]];
        return Yi(e, o, n);
      }
    }
    throw new Error(`No widget '${t}' for type '${r}' in schema: ${JSON.stringify(e)}`);
  }
  function rCe(e) {
    let t = 0;
    for (let n = 0; n < e.length; n += 1) {
      const r = e.charCodeAt(n);
      t = (t << 5) - t + r, t = t & t;
    }
    return t.toString(16);
  }
  function oCe(e) {
    const t = /* @__PURE__ */ new Set();
    return JSON.stringify(e, (n, r) => (t.add(n), r)), JSON.stringify(e, Array.from(t).sort());
  }
  function $i(e) {
    return rCe(oCe(e));
  }
  function iCe(e) {
    return $i(e);
  }
  function aCe(e, t, n = {}) {
    try {
      return Yi(e, t, n), !0;
    } catch (r) {
      const o = r;
      if (o.message && (o.message.startsWith("No widget") || o.message.startsWith("Unsupported widget")))
        return !1;
      throw r;
    }
  }
  function Mc(e, t) {
    return `${dl(e) ? e : e[rn]}__${t}`;
  }
  function Nc(e) {
    return Mc(e, "description");
  }
  function SA(e) {
    return Mc(e, "error");
  }
  function _h(e) {
    return Mc(e, "examples");
  }
  function _A(e) {
    return Mc(e, "help");
  }
  function x1(e) {
    return Mc(e, "title");
  }
  function go(e, t = !1) {
    const n = t ? ` ${_h(e)}` : "";
    return `${SA(e)} ${Nc(e)} ${_A(e)}${n}`;
  }
  function w1(e, t) {
    return `${e}-${t}`;
  }
  function ji(e, t) {
    return Mc(e, t);
  }
  function k_(e, t) {
    return Mc(e, `optional${t}`);
  }
  function Wf(e) {
    return !L0(e) && (!$t(e) || Array.isArray(e) || !Hn(e));
  }
  function sCe(e, t) {
    const { rootSchema: n, schemaUtils: r } = e;
    if (gh(t, n))
      return !0;
    if (bn in n) {
      const o = r.retrieveSchema(n);
      return gh(t, o);
    }
    return !1;
  }
  function Pc(e, t, n) {
    return t ? n : e;
  }
  function lCe(e) {
    return e ? new Date(e).toJSON() : void 0;
  }
  function EA(e, t, n) {
    const r = [Ebe];
    return Tt(e, Aj) && r.unshift(Aj), Ee(e, [...r, t], n);
  }
  function cCe(e, t) {
    if (!Array.isArray(t))
      return e;
    const n = (d) => d.reduce((p, m) => (p[m] = !0, p), {}), r = (d) => d.length > 1 ? `properties '${d.join("', '")}'` : `property '${d[0]}'`, o = n(e), i = t.filter((d) => d === "*" || o[d]), a = n(i), s = e.filter((d) => !a[d]), c = i.indexOf("*");
    if (c === -1) {
      if (s.length)
        throw new Error(`uiSchema order list does not contain ${r(s)}`);
      return i;
    }
    if (c !== i.lastIndexOf("*"))
      throw new Error("uiSchema order list contains more than one wildcard item");
    const u = [...i];
    return u.splice(c, 1, ...s), u;
  }
  function T_(e, t = !0) {
    if (!e)
      return {
        year: -1,
        month: -1,
        day: -1,
        hour: t ? -1 : 0,
        minute: t ? -1 : 0,
        second: t ? -1 : 0
      };
    const n = new Date(e);
    if (Number.isNaN(n.getTime()))
      throw new Error("Unable to parse date " + e);
    return {
      year: n.getUTCFullYear(),
      month: n.getUTCMonth() + 1,
      // oh you, javascript.
      day: n.getUTCDate(),
      hour: t ? n.getUTCHours() : 0,
      minute: t ? n.getUTCMinutes() : 0,
      second: t ? n.getUTCSeconds() : 0
    };
  }
  function jp(e) {
    if (e.const || e.enum && e.enum.length === 1 && e.enum[0] === !0)
      return !0;
    if (e.anyOf && e.anyOf.length === 1)
      return jp(e.anyOf[0]);
    if (e.oneOf && e.oneOf.length === 1)
      return jp(e.oneOf[0]);
    if (e.allOf) {
      const t = (n) => jp(n);
      return e.allOf.some(t);
    }
    return !1;
  }
  function yV(e, t, n, r = "customDeep") {
    if (r === "always")
      return !0;
    if (r === "shallow") {
      const { props: a, state: s } = e;
      return !wD(a, t) || !wD(s, n);
    }
    const { props: o, state: i } = e;
    return !pn(o, t) || !pn(i, n);
  }
  function TD(e) {
    const t = PU(e.map((n) => $t(n) ? oi(n) : void 0).flat().filter((n) => n !== void 0));
    return t.length === 1 ? t[0] : t;
  }
  function pm(e, t, n, r) {
    const { enableOptionalDataFieldForType: o = [] } = Qe(r, e.globalUiOptions);
    let i;
    return Nt in t && Array.isArray(t[Nt]) ? i = TD(t[Nt]) : yt in t && Array.isArray(t[yt]) ? i = TD(t[yt]) : i = oi(t), !sCe(e, t) && !n && !!i && !Array.isArray(i) && !!o.find((a) => a === i);
  }
  function AD(e, t = !0) {
    const { year: n, month: r, day: o, hour: i = 0, minute: a = 0, second: s = 0 } = e, c = Date.UTC(n, r - 1, o, i, a, s), u = new Date(c).toJSON();
    return t ? u : u.slice(0, 10);
  }
  function CA(e, t = []) {
    if (!e)
      return [];
    let n = [];
    return ur in e && (n = n.concat(e[ur].map((r) => {
      const o = `.${t.join(".")}`;
      return {
        property: o,
        message: r,
        stack: `${o} ${r}`
      };
    }))), Object.keys(e).reduce((r, o) => {
      if (o !== ur) {
        const i = e[o];
        fl(i) && (r = r.concat(CA(i, [...t, o])));
      }
      return r;
    }, n);
  }
  function vV(e) {
    return Zn(e) ? Vf(e, Oc) : um(e) ? [e] : uA(dU(rA(e)));
  }
  function uCe(e) {
    const t = new fV();
    return e.length && e.forEach((n) => {
      const { property: r, message: o } = n, i = r === "." ? [] : vV(r);
      i.length > 0 && i[0] === "" && i.splice(0, 1), o && t.addErrors(o, i);
    }), t.ErrorSchema;
  }
  function Do(e, t, n, r) {
    const o = Array.isArray(n) ? n : n?.path, i = e === "" ? [] : [e], a = o ? o.concat(...i) : i, s = [t.idPrefix, ...a].join(t.idSeparator);
    let c;
    return t.nameGenerator && a.length > 0 && (c = t.nameGenerator(a, t.idPrefix, r)), { path: a, [rn]: s, ...c !== void 0 && { name: c } };
  }
  function bV(e) {
    return Object.keys(e).reduce((t, n) => {
      if (n === "addError")
        return t;
      {
        const r = e[n];
        return fl(r) ? {
          ...t,
          [n]: bV(r)
        } : { ...t, [n]: r };
      }
    }, {});
  }
  function fCe(e) {
    return Object.values(e).every((t) => t !== -1);
  }
  function dCe(e) {
    const { className: t = "form-control", type: n, range: r, value: o, select: i, rootId: a, name: s, disabled: c, readonly: u, autofocus: d, registry: p, onBlur: m, onFocus: g } = e, y = `${a}_${n}`, { SelectWidget: b } = p.widgets, v = T.useCallback((x) => i(n, x), [i, n]);
    return S.jsx(b, { schema: { type: "integer" }, id: y, name: s, className: t, options: { enumOptions: lV(r[0], r[1]) }, placeholder: n, value: o, disabled: c, readonly: u, autofocus: d, onChange: v, onBlur: m, onFocus: g, registry: p, label: "", "aria-describedby": go(a) });
  }
  function pCe(e) {
    const { time: t = !1, disabled: n = !1, readonly: r = !1, options: o, onChange: i, value: a } = e, [s, c] = T.useState(T_(a, t));
    T.useEffect(() => {
      c(T_(a, t));
    }, [t, a]);
    const u = T.useCallback((g, y) => {
      const b = {
        ...s,
        [g]: typeof y > "u" ? -1 : y
      };
      fCe(b) ? i(AD(b, t)) : c(b);
    }, [s, i, t]), d = T.useCallback((g) => {
      g.preventDefault(), !(n || r) && i(void 0);
    }, [n, r, i]), p = T.useCallback((g) => {
      if (g.preventDefault(), n || r)
        return;
      const y = T_((/* @__PURE__ */ new Date()).toJSON(), t);
      i(AD(y, t));
    }, [n, r, t, i]);
    return { elements: T.useMemo(() => ZEe(s, t, o.yearsRange, o.format), [s, t, o.yearsRange, o.format]), handleChange: u, handleClear: d, handleSetNow: p };
  }
  function Ic(e) {
    const t = T.useRef(e);
    return gh(e, t.current) || (t.current = e), t.current;
  }
  function hCe(e, t) {
    return e.replace(";base64", `;name=${encodeURIComponent(t)};base64`);
  }
  function mCe(e) {
    const { name: t, size: n, type: r } = e;
    return new Promise((o, i) => {
      const a = new window.FileReader();
      a.onerror = i, a.onload = (s) => {
        var c;
        typeof ((c = s.target) === null || c === void 0 ? void 0 : c.result) == "string" ? o({
          dataURL: hCe(s.target.result, t),
          name: t,
          size: n,
          type: r
        }) : o({
          dataURL: null,
          name: t,
          size: n,
          type: r
        });
      }, a.readAsDataURL(e);
    });
  }
  function gCe(e) {
    return Promise.all(Array.from(e).map(mCe));
  }
  function RD(e) {
    return e.reduce((t, n) => {
      if (!n)
        return t;
      try {
        const { blob: r, name: o } = BEe(n);
        return [
          ...t,
          {
            dataURL: n,
            name: o,
            size: r.size,
            type: r.type
          }
        ];
      } catch {
        return t;
      }
    }, []);
  }
  function yCe(e, t, n = !1) {
    const r = T.useMemo(() => n && e ? Array.isArray(e) ? e : [e] : [], [e, n]), o = T.useMemo(() => Array.isArray(e) ? RD(e) : RD([e || ""]), [e]), i = T.useCallback((s) => {
      gCe(s).then((c) => {
        const u = c.map((d) => d.dataURL || null);
        t(n ? r.concat(...u) : u[0]);
      });
    }, [r, n, t]), a = T.useCallback((s) => {
      if (n) {
        const c = r.filter((u, d) => d !== s);
        t(c);
      } else
        t(void 0);
    }, [r, n, t]);
    return { filesInfo: o, handleChange: i, handleRemove: a };
  }
  function vCe(e) {
    if (!e)
      return "";
    const t = new Date(e), n = Vs(t.getFullYear(), 4), r = Vs(t.getMonth() + 1, 2), o = Vs(t.getDate(), 2), i = Vs(t.getHours(), 2), a = Vs(t.getMinutes(), 2), s = Vs(t.getSeconds(), 2), c = Vs(t.getMilliseconds(), 3);
    return `${n}-${r}-${o}T${i}:${a}:${s}.${c}`;
  }
  function Kv(e, t, n = !1) {
    if (!t)
      return e;
    const { errors: r, errorSchema: o } = e;
    let i = CA(t), a = t;
    return Hn(o) || (a = Sh(o, t, n ? "preventDuplicates" : !0), i = [...r].concat(i)), { errorSchema: a, errors: i };
  }
  function bCe(e) {
    for (const t in e) {
      const n = e, r = n[t];
      t === bn && typeof r == "string" && r.startsWith("#") ? n[t] = Z8 + r : n[t] = kA(r);
    }
    return e;
  }
  function xCe(e) {
    for (let t = 0; t < e.length; t++)
      e[t] = kA(e[t]);
    return e;
  }
  function kA(e) {
    return Array.isArray(e) ? xCe([...e]) : $t(e) ? bCe({ ...e }) : e;
  }
  var bt;
  (function(e) {
    e.ArrayItemTitle = "Item", e.MissingItems = "Missing items definition", e.EmptyArray = "No items yet. Use the button below to add some.", e.YesLabel = "Yes", e.NoLabel = "No", e.CloseLabel = "Close", e.ErrorsLabel = "Errors", e.NewStringDefault = "New Value", e.AddButton = "Add", e.AddItemButton = "Add Item", e.CopyButton = "Copy", e.MoveDownButton = "Move down", e.MoveUpButton = "Move up", e.RemoveButton = "Remove", e.NowLabel = "Now", e.ClearLabel = "Clear", e.AriaDateLabel = "Select a date", e.PreviewLabel = "Preview", e.DecrementAriaLabel = "Decrease value by 1", e.IncrementAriaLabel = "Increase value by 1", e.OptionalObjectAdd = "Add data for optional field", e.OptionalObjectRemove = "Remove data for optional field", e.OptionalObjectEmptyMsg = "No data for optional field", e.Type = "Type", e.Value = "Value", e.UnknownFieldType = "Unknown field type %1", e.OptionPrefix = "Option %1", e.TitleOptionPrefix = "%1 option %2", e.KeyLabel = "%1 Key", e.InvalidObjectField = 'Invalid "%1" object field configuration: _%2_.', e.UnsupportedField = "Unsupported field schema.", e.UnsupportedFieldWithId = "Unsupported field schema for field `%1`.", e.UnsupportedFieldWithReason = "Unsupported field schema: _%1_.", e.UnsupportedFieldWithIdAndReason = "Unsupported field schema for field `%1`: _%2_.", e.FilesInfo = "**%1** (%2, %3 bytes)";
  })(bt || (bt = {}));
  function wCe(e, t) {
    var n = Zn(e) ? sA : tV;
    return n(e, mU(t));
  }
  var Ey = { exports: {} }, A_ = {}, Oa = {}, Ul = {}, R_ = {}, O_ = {}, M_ = {}, OD;
  function z0() {
    return OD || (OD = 1, (function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.regexpCode = e.getEsmExportName = e.getProperty = e.safeStringify = e.stringify = e.strConcat = e.addCodeArg = e.str = e._ = e.nil = e._Code = e.Name = e.IDENTIFIER = e._CodeOrName = void 0;
      class t {
      }
      e._CodeOrName = t, e.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
      class n extends t {
        constructor(E) {
          if (super(), !e.IDENTIFIER.test(E))
            throw new Error("CodeGen: name must be a valid identifier");
          this.str = E;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          return !1;
        }
        get names() {
          return { [this.str]: 1 };
        }
      }
      e.Name = n;
      class r extends t {
        constructor(E) {
          super(), this._items = typeof E == "string" ? [E] : E;
        }
        toString() {
          return this.str;
        }
        emptyStr() {
          if (this._items.length > 1)
            return !1;
          const E = this._items[0];
          return E === "" || E === '""';
        }
        get str() {
          var E;
          return (E = this._str) !== null && E !== void 0 ? E : this._str = this._items.reduce((_, C) => `${_}${C}`, "");
        }
        get names() {
          var E;
          return (E = this._names) !== null && E !== void 0 ? E : this._names = this._items.reduce((_, C) => (C instanceof n && (_[C.str] = (_[C.str] || 0) + 1), _), {});
        }
      }
      e._Code = r, e.nil = new r("");
      function o(x, ...E) {
        const _ = [x[0]];
        let C = 0;
        for (; C < E.length; )
          s(_, E[C]), _.push(x[++C]);
        return new r(_);
      }
      e._ = o;
      const i = new r("+");
      function a(x, ...E) {
        const _ = [g(x[0])];
        let C = 0;
        for (; C < E.length; )
          _.push(i), s(_, E[C]), _.push(i, g(x[++C]));
        return c(_), new r(_);
      }
      e.str = a;
      function s(x, E) {
        E instanceof r ? x.push(...E._items) : E instanceof n ? x.push(E) : x.push(p(E));
      }
      e.addCodeArg = s;
      function c(x) {
        let E = 1;
        for (; E < x.length - 1; ) {
          if (x[E] === i) {
            const _ = u(x[E - 1], x[E + 1]);
            if (_ !== void 0) {
              x.splice(E - 1, 3, _);
              continue;
            }
            x[E++] = "+";
          }
          E++;
        }
      }
      function u(x, E) {
        if (E === '""')
          return x;
        if (x === '""')
          return E;
        if (typeof x == "string")
          return E instanceof n || x[x.length - 1] !== '"' ? void 0 : typeof E != "string" ? `${x.slice(0, -1)}${E}"` : E[0] === '"' ? x.slice(0, -1) + E.slice(1) : void 0;
        if (typeof E == "string" && E[0] === '"' && !(x instanceof n))
          return `"${x}${E.slice(1)}`;
      }
      function d(x, E) {
        return E.emptyStr() ? x : x.emptyStr() ? E : a`${x}${E}`;
      }
      e.strConcat = d;
      function p(x) {
        return typeof x == "number" || typeof x == "boolean" || x === null ? x : g(Array.isArray(x) ? x.join(",") : x);
      }
      function m(x) {
        return new r(g(x));
      }
      e.stringify = m;
      function g(x) {
        return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      }
      e.safeStringify = g;
      function y(x) {
        return typeof x == "string" && e.IDENTIFIER.test(x) ? new r(`.${x}`) : o`[${x}]`;
      }
      e.getProperty = y;
      function b(x) {
        if (typeof x == "string" && e.IDENTIFIER.test(x))
          return new r(`${x}`);
        throw new Error(`CodeGen: invalid export name: ${x}, use explicit $id name mapping`);
      }
      e.getEsmExportName = b;
      function v(x) {
        return new r(x.toString());
      }
      e.regexpCode = v;
    })(M_)), M_;
  }
  var N_ = {}, MD;
  function ND() {
    return MD || (MD = 1, (function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.ValueScope = e.ValueScopeName = e.Scope = e.varKinds = e.UsedValueState = void 0;
      const t = z0();
      class n extends Error {
        constructor(u) {
          super(`CodeGen: "code" for ${u} not defined`), this.value = u.value;
        }
      }
      var r;
      (function(c) {
        c[c.Started = 0] = "Started", c[c.Completed = 1] = "Completed";
      })(r || (e.UsedValueState = r = {})), e.varKinds = {
        const: new t.Name("const"),
        let: new t.Name("let"),
        var: new t.Name("var")
      };
      class o {
        constructor({ prefixes: u, parent: d } = {}) {
          this._names = {}, this._prefixes = u, this._parent = d;
        }
        toName(u) {
          return u instanceof t.Name ? u : this.name(u);
        }
        name(u) {
          return new t.Name(this._newName(u));
        }
        _newName(u) {
          const d = this._names[u] || this._nameGroup(u);
          return `${u}${d.index++}`;
        }
        _nameGroup(u) {
          var d, p;
          if (!((p = (d = this._parent) === null || d === void 0 ? void 0 : d._prefixes) === null || p === void 0) && p.has(u) || this._prefixes && !this._prefixes.has(u))
            throw new Error(`CodeGen: prefix "${u}" is not allowed in this scope`);
          return this._names[u] = { prefix: u, index: 0 };
        }
      }
      e.Scope = o;
      class i extends t.Name {
        constructor(u, d) {
          super(d), this.prefix = u;
        }
        setValue(u, { property: d, itemIndex: p }) {
          this.value = u, this.scopePath = (0, t._)`.${new t.Name(d)}[${p}]`;
        }
      }
      e.ValueScopeName = i;
      const a = (0, t._)`\n`;
      class s extends o {
        constructor(u) {
          super(u), this._values = {}, this._scope = u.scope, this.opts = { ...u, _n: u.lines ? a : t.nil };
        }
        get() {
          return this._scope;
        }
        name(u) {
          return new i(u, this._newName(u));
        }
        value(u, d) {
          var p;
          if (d.ref === void 0)
            throw new Error("CodeGen: ref must be passed in value");
          const m = this.toName(u), { prefix: g } = m, y = (p = d.key) !== null && p !== void 0 ? p : d.ref;
          let b = this._values[g];
          if (b) {
            const E = b.get(y);
            if (E)
              return E;
          } else
            b = this._values[g] = /* @__PURE__ */ new Map();
          b.set(y, m);
          const v = this._scope[g] || (this._scope[g] = []), x = v.length;
          return v[x] = d.ref, m.setValue(d, { property: g, itemIndex: x }), m;
        }
        getValue(u, d) {
          const p = this._values[u];
          if (p)
            return p.get(d);
        }
        scopeRefs(u, d = this._values) {
          return this._reduceValues(d, (p) => {
            if (p.scopePath === void 0)
              throw new Error(`CodeGen: name "${p}" has no value`);
            return (0, t._)`${u}${p.scopePath}`;
          });
        }
        scopeCode(u = this._values, d, p) {
          return this._reduceValues(u, (m) => {
            if (m.value === void 0)
              throw new Error(`CodeGen: name "${m}" has no value`);
            return m.value.code;
          }, d, p);
        }
        _reduceValues(u, d, p = {}, m) {
          let g = t.nil;
          for (const y in u) {
            const b = u[y];
            if (!b)
              continue;
            const v = p[y] = p[y] || /* @__PURE__ */ new Map();
            b.forEach((x) => {
              if (v.has(x))
                return;
              v.set(x, r.Started);
              let E = d(x);
              if (E) {
                const _ = this.opts.es5 ? e.varKinds.var : e.varKinds.const;
                g = (0, t._)`${g}${_} ${x} = ${E};${this.opts._n}`;
              } else if (E = m?.(x))
                g = (0, t._)`${g}${E}${this.opts._n}`;
              else
                throw new n(x);
              v.set(x, r.Completed);
            });
          }
          return g;
        }
      }
      e.ValueScope = s;
    })(N_)), N_;
  }
  var PD;
  function vt() {
    return PD || (PD = 1, (function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.or = e.and = e.not = e.CodeGen = e.operators = e.varKinds = e.ValueScopeName = e.ValueScope = e.Scope = e.Name = e.regexpCode = e.stringify = e.getProperty = e.nil = e.strConcat = e.str = e._ = void 0;
      const t = z0(), n = ND();
      var r = z0();
      Object.defineProperty(e, "_", { enumerable: !0, get: function() {
        return r._;
      } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
        return r.str;
      } }), Object.defineProperty(e, "strConcat", { enumerable: !0, get: function() {
        return r.strConcat;
      } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
        return r.nil;
      } }), Object.defineProperty(e, "getProperty", { enumerable: !0, get: function() {
        return r.getProperty;
      } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
        return r.stringify;
      } }), Object.defineProperty(e, "regexpCode", { enumerable: !0, get: function() {
        return r.regexpCode;
      } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
        return r.Name;
      } });
      var o = ND();
      Object.defineProperty(e, "Scope", { enumerable: !0, get: function() {
        return o.Scope;
      } }), Object.defineProperty(e, "ValueScope", { enumerable: !0, get: function() {
        return o.ValueScope;
      } }), Object.defineProperty(e, "ValueScopeName", { enumerable: !0, get: function() {
        return o.ValueScopeName;
      } }), Object.defineProperty(e, "varKinds", { enumerable: !0, get: function() {
        return o.varKinds;
      } }), e.operators = {
        GT: new t._Code(">"),
        GTE: new t._Code(">="),
        LT: new t._Code("<"),
        LTE: new t._Code("<="),
        EQ: new t._Code("==="),
        NEQ: new t._Code("!=="),
        NOT: new t._Code("!"),
        OR: new t._Code("||"),
        AND: new t._Code("&&"),
        ADD: new t._Code("+")
      };
      class i {
        optimizeNodes() {
          return this;
        }
        optimizeNames(H, X) {
          return this;
        }
      }
      class a extends i {
        constructor(H, X, Q) {
          super(), this.varKind = H, this.name = X, this.rhs = Q;
        }
        render({ es5: H, _n: X }) {
          const Q = H ? n.varKinds.var : this.varKind, ne = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
          return `${Q} ${this.name}${ne};` + X;
        }
        optimizeNames(H, X) {
          if (H[this.name.str])
            return this.rhs && (this.rhs = j(this.rhs, H, X)), this;
        }
        get names() {
          return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
        }
      }
      class s extends i {
        constructor(H, X, Q) {
          super(), this.lhs = H, this.rhs = X, this.sideEffects = Q;
        }
        render({ _n: H }) {
          return `${this.lhs} = ${this.rhs};` + H;
        }
        optimizeNames(H, X) {
          if (!(this.lhs instanceof t.Name && !H[this.lhs.str] && !this.sideEffects))
            return this.rhs = j(this.rhs, H, X), this;
        }
        get names() {
          const H = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
          return U(H, this.rhs);
        }
      }
      class c extends s {
        constructor(H, X, Q, ne) {
          super(H, Q, ne), this.op = X;
        }
        render({ _n: H }) {
          return `${this.lhs} ${this.op}= ${this.rhs};` + H;
        }
      }
      class u extends i {
        constructor(H) {
          super(), this.label = H, this.names = {};
        }
        render({ _n: H }) {
          return `${this.label}:` + H;
        }
      }
      class d extends i {
        constructor(H) {
          super(), this.label = H, this.names = {};
        }
        render({ _n: H }) {
          return `break${this.label ? ` ${this.label}` : ""};` + H;
        }
      }
      class p extends i {
        constructor(H) {
          super(), this.error = H;
        }
        render({ _n: H }) {
          return `throw ${this.error};` + H;
        }
        get names() {
          return this.error.names;
        }
      }
      class m extends i {
        constructor(H) {
          super(), this.code = H;
        }
        render({ _n: H }) {
          return `${this.code};` + H;
        }
        optimizeNodes() {
          return `${this.code}` ? this : void 0;
        }
        optimizeNames(H, X) {
          return this.code = j(this.code, H, X), this;
        }
        get names() {
          return this.code instanceof t._CodeOrName ? this.code.names : {};
        }
      }
      class g extends i {
        constructor(H = []) {
          super(), this.nodes = H;
        }
        render(H) {
          return this.nodes.reduce((X, Q) => X + Q.render(H), "");
        }
        optimizeNodes() {
          const { nodes: H } = this;
          let X = H.length;
          for (; X--; ) {
            const Q = H[X].optimizeNodes();
            Array.isArray(Q) ? H.splice(X, 1, ...Q) : Q ? H[X] = Q : H.splice(X, 1);
          }
          return H.length > 0 ? this : void 0;
        }
        optimizeNames(H, X) {
          const { nodes: Q } = this;
          let ne = Q.length;
          for (; ne--; ) {
            const te = Q[ne];
            te.optimizeNames(H, X) || (V(H, te.names), Q.splice(ne, 1));
          }
          return Q.length > 0 ? this : void 0;
        }
        get names() {
          return this.nodes.reduce((H, X) => N(H, X.names), {});
        }
      }
      class y extends g {
        render(H) {
          return "{" + H._n + super.render(H) + "}" + H._n;
        }
      }
      class b extends g {
      }
      class v extends y {
      }
      v.kind = "else";
      class x extends y {
        constructor(H, X) {
          super(X), this.condition = H;
        }
        render(H) {
          let X = `if(${this.condition})` + super.render(H);
          return this.else && (X += "else " + this.else.render(H)), X;
        }
        optimizeNodes() {
          super.optimizeNodes();
          const H = this.condition;
          if (H === !0)
            return this.nodes;
          let X = this.else;
          if (X) {
            const Q = X.optimizeNodes();
            X = this.else = Array.isArray(Q) ? new v(Q) : Q;
          }
          if (X)
            return H === !1 ? X instanceof x ? X : X.nodes : this.nodes.length ? this : new x(F(H), X instanceof x ? [X] : X.nodes);
          if (!(H === !1 || !this.nodes.length))
            return this;
        }
        optimizeNames(H, X) {
          var Q;
          if (this.else = (Q = this.else) === null || Q === void 0 ? void 0 : Q.optimizeNames(H, X), !!(super.optimizeNames(H, X) || this.else))
            return this.condition = j(this.condition, H, X), this;
        }
        get names() {
          const H = super.names;
          return U(H, this.condition), this.else && N(H, this.else.names), H;
        }
      }
      x.kind = "if";
      class E extends y {
      }
      E.kind = "for";
      class _ extends E {
        constructor(H) {
          super(), this.iteration = H;
        }
        render(H) {
          return `for(${this.iteration})` + super.render(H);
        }
        optimizeNames(H, X) {
          if (super.optimizeNames(H, X))
            return this.iteration = j(this.iteration, H, X), this;
        }
        get names() {
          return N(super.names, this.iteration.names);
        }
      }
      class C extends E {
        constructor(H, X, Q, ne) {
          super(), this.varKind = H, this.name = X, this.from = Q, this.to = ne;
        }
        render(H) {
          const X = H.es5 ? n.varKinds.var : this.varKind, { name: Q, from: ne, to: te } = this;
          return `for(${X} ${Q}=${ne}; ${Q}<${te}; ${Q}++)` + super.render(H);
        }
        get names() {
          const H = U(super.names, this.from);
          return U(H, this.to);
        }
      }
      class k extends E {
        constructor(H, X, Q, ne) {
          super(), this.loop = H, this.varKind = X, this.name = Q, this.iterable = ne;
        }
        render(H) {
          return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(H);
        }
        optimizeNames(H, X) {
          if (super.optimizeNames(H, X))
            return this.iterable = j(this.iterable, H, X), this;
        }
        get names() {
          return N(super.names, this.iterable.names);
        }
      }
      class A extends y {
        constructor(H, X, Q) {
          super(), this.name = H, this.args = X, this.async = Q;
        }
        render(H) {
          return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(H);
        }
      }
      A.kind = "func";
      class O extends g {
        render(H) {
          return "return " + super.render(H);
        }
      }
      O.kind = "return";
      class P extends y {
        render(H) {
          let X = "try" + super.render(H);
          return this.catch && (X += this.catch.render(H)), this.finally && (X += this.finally.render(H)), X;
        }
        optimizeNodes() {
          var H, X;
          return super.optimizeNodes(), (H = this.catch) === null || H === void 0 || H.optimizeNodes(), (X = this.finally) === null || X === void 0 || X.optimizeNodes(), this;
        }
        optimizeNames(H, X) {
          var Q, ne;
          return super.optimizeNames(H, X), (Q = this.catch) === null || Q === void 0 || Q.optimizeNames(H, X), (ne = this.finally) === null || ne === void 0 || ne.optimizeNames(H, X), this;
        }
        get names() {
          const H = super.names;
          return this.catch && N(H, this.catch.names), this.finally && N(H, this.finally.names), H;
        }
      }
      class I extends y {
        constructor(H) {
          super(), this.error = H;
        }
        render(H) {
          return `catch(${this.error})` + super.render(H);
        }
      }
      I.kind = "catch";
      class $ extends y {
        render(H) {
          return "finally" + super.render(H);
        }
      }
      $.kind = "finally";
      class L {
        constructor(H, X = {}) {
          this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...X, _n: X.lines ? `
` : "" }, this._extScope = H, this._scope = new n.Scope({ parent: H }), this._nodes = [new b()];
        }
        toString() {
          return this._root.render(this.opts);
        }
        // returns unique name in the internal scope
        name(H) {
          return this._scope.name(H);
        }
        // reserves unique name in the external scope
        scopeName(H) {
          return this._extScope.name(H);
        }
        // reserves unique name in the external scope and assigns value to it
        scopeValue(H, X) {
          const Q = this._extScope.value(H, X);
          return (this._values[Q.prefix] || (this._values[Q.prefix] = /* @__PURE__ */ new Set())).add(Q), Q;
        }
        getScopeValue(H, X) {
          return this._extScope.getValue(H, X);
        }
        // return code that assigns values in the external scope to the names that are used internally
        // (same names that were returned by gen.scopeName or gen.scopeValue)
        scopeRefs(H) {
          return this._extScope.scopeRefs(H, this._values);
        }
        scopeCode() {
          return this._extScope.scopeCode(this._values);
        }
        _def(H, X, Q, ne) {
          const te = this._scope.toName(X);
          return Q !== void 0 && ne && (this._constants[te.str] = Q), this._leafNode(new a(H, te, Q)), te;
        }
        // `const` declaration (`var` in es5 mode)
        const(H, X, Q) {
          return this._def(n.varKinds.const, H, X, Q);
        }
        // `let` declaration with optional assignment (`var` in es5 mode)
        let(H, X, Q) {
          return this._def(n.varKinds.let, H, X, Q);
        }
        // `var` declaration with optional assignment
        var(H, X, Q) {
          return this._def(n.varKinds.var, H, X, Q);
        }
        // assignment code
        assign(H, X, Q) {
          return this._leafNode(new s(H, X, Q));
        }
        // `+=` code
        add(H, X) {
          return this._leafNode(new c(H, e.operators.ADD, X));
        }
        // appends passed SafeExpr to code or executes Block
        code(H) {
          return typeof H == "function" ? H() : H !== t.nil && this._leafNode(new m(H)), this;
        }
        // returns code for object literal for the passed argument list of key-value pairs
        object(...H) {
          const X = ["{"];
          for (const [Q, ne] of H)
            X.length > 1 && X.push(","), X.push(Q), (Q !== ne || this.opts.es5) && (X.push(":"), (0, t.addCodeArg)(X, ne));
          return X.push("}"), new t._Code(X);
        }
        // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
        if(H, X, Q) {
          if (this._blockNode(new x(H)), X && Q)
            this.code(X).else().code(Q).endIf();
          else if (X)
            this.code(X).endIf();
          else if (Q)
            throw new Error('CodeGen: "else" body without "then" body');
          return this;
        }
        // `else if` clause - invalid without `if` or after `else` clauses
        elseIf(H) {
          return this._elseNode(new x(H));
        }
        // `else` clause - only valid after `if` or `else if` clauses
        else() {
          return this._elseNode(new v());
        }
        // end `if` statement (needed if gen.if was used only with condition)
        endIf() {
          return this._endBlockNode(x, v);
        }
        _for(H, X) {
          return this._blockNode(H), X && this.code(X).endFor(), this;
        }
        // a generic `for` clause (or statement if `forBody` is passed)
        for(H, X) {
          return this._for(new _(H), X);
        }
        // `for` statement for a range of values
        forRange(H, X, Q, ne, te = this.opts.es5 ? n.varKinds.var : n.varKinds.let) {
          const se = this._scope.toName(H);
          return this._for(new C(te, se, X, Q), () => ne(se));
        }
        // `for-of` statement (in es5 mode replace with a normal for loop)
        forOf(H, X, Q, ne = n.varKinds.const) {
          const te = this._scope.toName(H);
          if (this.opts.es5) {
            const se = X instanceof t.Name ? X : this.var("_arr", X);
            return this.forRange("_i", 0, (0, t._)`${se}.length`, (ue) => {
              this.var(te, (0, t._)`${se}[${ue}]`), Q(te);
            });
          }
          return this._for(new k("of", ne, te, X), () => Q(te));
        }
        // `for-in` statement.
        // With option `ownProperties` replaced with a `for-of` loop for object keys
        forIn(H, X, Q, ne = this.opts.es5 ? n.varKinds.var : n.varKinds.const) {
          if (this.opts.ownProperties)
            return this.forOf(H, (0, t._)`Object.keys(${X})`, Q);
          const te = this._scope.toName(H);
          return this._for(new k("in", ne, te, X), () => Q(te));
        }
        // end `for` loop
        endFor() {
          return this._endBlockNode(E);
        }
        // `label` statement
        label(H) {
          return this._leafNode(new u(H));
        }
        // `break` statement
        break(H) {
          return this._leafNode(new d(H));
        }
        // `return` statement
        return(H) {
          const X = new O();
          if (this._blockNode(X), this.code(H), X.nodes.length !== 1)
            throw new Error('CodeGen: "return" should have one node');
          return this._endBlockNode(O);
        }
        // `try` statement
        try(H, X, Q) {
          if (!X && !Q)
            throw new Error('CodeGen: "try" without "catch" and "finally"');
          const ne = new P();
          if (this._blockNode(ne), this.code(H), X) {
            const te = this.name("e");
            this._currNode = ne.catch = new I(te), X(te);
          }
          return Q && (this._currNode = ne.finally = new $(), this.code(Q)), this._endBlockNode(I, $);
        }
        // `throw` statement
        throw(H) {
          return this._leafNode(new p(H));
        }
        // start self-balancing block
        block(H, X) {
          return this._blockStarts.push(this._nodes.length), H && this.code(H).endBlock(X), this;
        }
        // end the current self-balancing block
        endBlock(H) {
          const X = this._blockStarts.pop();
          if (X === void 0)
            throw new Error("CodeGen: not in self-balancing block");
          const Q = this._nodes.length - X;
          if (Q < 0 || H !== void 0 && Q !== H)
            throw new Error(`CodeGen: wrong number of nodes: ${Q} vs ${H} expected`);
          return this._nodes.length = X, this;
        }
        // `function` heading (or definition if funcBody is passed)
        func(H, X = t.nil, Q, ne) {
          return this._blockNode(new A(H, X, Q)), ne && this.code(ne).endFunc(), this;
        }
        // end function definition
        endFunc() {
          return this._endBlockNode(A);
        }
        optimize(H = 1) {
          for (; H-- > 0; )
            this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
        }
        _leafNode(H) {
          return this._currNode.nodes.push(H), this;
        }
        _blockNode(H) {
          this._currNode.nodes.push(H), this._nodes.push(H);
        }
        _endBlockNode(H, X) {
          const Q = this._currNode;
          if (Q instanceof H || X && Q instanceof X)
            return this._nodes.pop(), this;
          throw new Error(`CodeGen: not in block "${X ? `${H.kind}/${X.kind}` : H.kind}"`);
        }
        _elseNode(H) {
          const X = this._currNode;
          if (!(X instanceof x))
            throw new Error('CodeGen: "else" without "if"');
          return this._currNode = X.else = H, this;
        }
        get _root() {
          return this._nodes[0];
        }
        get _currNode() {
          const H = this._nodes;
          return H[H.length - 1];
        }
        set _currNode(H) {
          const X = this._nodes;
          X[X.length - 1] = H;
        }
      }
      e.CodeGen = L;
      function N(z, H) {
        for (const X in H)
          z[X] = (z[X] || 0) + (H[X] || 0);
        return z;
      }
      function U(z, H) {
        return H instanceof t._CodeOrName ? N(z, H.names) : z;
      }
      function j(z, H, X) {
        if (z instanceof t.Name)
          return Q(z);
        if (!ne(z))
          return z;
        return new t._Code(z._items.reduce((te, se) => (se instanceof t.Name && (se = Q(se)), se instanceof t._Code ? te.push(...se._items) : te.push(se), te), []));
        function Q(te) {
          const se = X[te.str];
          return se === void 0 || H[te.str] !== 1 ? te : (delete H[te.str], se);
        }
        function ne(te) {
          return te instanceof t._Code && te._items.some((se) => se instanceof t.Name && H[se.str] === 1 && X[se.str] !== void 0);
        }
      }
      function V(z, H) {
        for (const X in H)
          z[X] = (z[X] || 0) - (H[X] || 0);
      }
      function F(z) {
        return typeof z == "boolean" || typeof z == "number" || z === null ? !z : (0, t._)`!${G(z)}`;
      }
      e.not = F;
      const K = D(e.operators.AND);
      function W(...z) {
        return z.reduce(K);
      }
      e.and = W;
      const Y = D(e.operators.OR);
      function B(...z) {
        return z.reduce(Y);
      }
      e.or = B;
      function D(z) {
        return (H, X) => H === t.nil ? X : X === t.nil ? H : (0, t._)`${G(H)} ${z} ${G(X)}`;
      }
      function G(z) {
        return z instanceof t.Name ? z : (0, t._)`(${z})`;
      }
    })(O_)), O_;
  }
  var gt = {}, ID;
  function Lt() {
    if (ID) return gt;
    ID = 1, Object.defineProperty(gt, "__esModule", { value: !0 }), gt.checkStrictMode = gt.getErrorPath = gt.Type = gt.useFunc = gt.setEvaluated = gt.evaluatedPropsToName = gt.mergeEvaluated = gt.eachItem = gt.unescapeJsonPointer = gt.escapeJsonPointer = gt.escapeFragment = gt.unescapeFragment = gt.schemaRefOrVal = gt.schemaHasRulesButRef = gt.schemaHasRules = gt.checkUnknownRules = gt.alwaysValidSchema = gt.toHash = void 0;
    const e = vt(), t = z0();
    function n(k) {
      const A = {};
      for (const O of k)
        A[O] = !0;
      return A;
    }
    gt.toHash = n;
    function r(k, A) {
      return typeof A == "boolean" ? A : Object.keys(A).length === 0 ? !0 : (o(k, A), !i(A, k.self.RULES.all));
    }
    gt.alwaysValidSchema = r;
    function o(k, A = k.schema) {
      const { opts: O, self: P } = k;
      if (!O.strictSchema || typeof A == "boolean")
        return;
      const I = P.RULES.keywords;
      for (const $ in A)
        I[$] || C(k, `unknown keyword: "${$}"`);
    }
    gt.checkUnknownRules = o;
    function i(k, A) {
      if (typeof k == "boolean")
        return !k;
      for (const O in k)
        if (A[O])
          return !0;
      return !1;
    }
    gt.schemaHasRules = i;
    function a(k, A) {
      if (typeof k == "boolean")
        return !k;
      for (const O in k)
        if (O !== "$ref" && A.all[O])
          return !0;
      return !1;
    }
    gt.schemaHasRulesButRef = a;
    function s({ topSchemaRef: k, schemaPath: A }, O, P, I) {
      if (!I) {
        if (typeof O == "number" || typeof O == "boolean")
          return O;
        if (typeof O == "string")
          return (0, e._)`${O}`;
      }
      return (0, e._)`${k}${A}${(0, e.getProperty)(P)}`;
    }
    gt.schemaRefOrVal = s;
    function c(k) {
      return p(decodeURIComponent(k));
    }
    gt.unescapeFragment = c;
    function u(k) {
      return encodeURIComponent(d(k));
    }
    gt.escapeFragment = u;
    function d(k) {
      return typeof k == "number" ? `${k}` : k.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    gt.escapeJsonPointer = d;
    function p(k) {
      return k.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    gt.unescapeJsonPointer = p;
    function m(k, A) {
      if (Array.isArray(k))
        for (const O of k)
          A(O);
      else
        A(k);
    }
    gt.eachItem = m;
    function g({ mergeNames: k, mergeToName: A, mergeValues: O, resultToName: P }) {
      return (I, $, L, N) => {
        const U = L === void 0 ? $ : L instanceof e.Name ? ($ instanceof e.Name ? k(I, $, L) : A(I, $, L), L) : $ instanceof e.Name ? (A(I, L, $), $) : O($, L);
        return N === e.Name && !(U instanceof e.Name) ? P(I, U) : U;
      };
    }
    gt.mergeEvaluated = {
      props: g({
        mergeNames: (k, A, O) => k.if((0, e._)`${O} !== true && ${A} !== undefined`, () => {
          k.if((0, e._)`${A} === true`, () => k.assign(O, !0), () => k.assign(O, (0, e._)`${O} || {}`).code((0, e._)`Object.assign(${O}, ${A})`));
        }),
        mergeToName: (k, A, O) => k.if((0, e._)`${O} !== true`, () => {
          A === !0 ? k.assign(O, !0) : (k.assign(O, (0, e._)`${O} || {}`), b(k, O, A));
        }),
        mergeValues: (k, A) => k === !0 ? !0 : { ...k, ...A },
        resultToName: y
      }),
      items: g({
        mergeNames: (k, A, O) => k.if((0, e._)`${O} !== true && ${A} !== undefined`, () => k.assign(O, (0, e._)`${A} === true ? true : ${O} > ${A} ? ${O} : ${A}`)),
        mergeToName: (k, A, O) => k.if((0, e._)`${O} !== true`, () => k.assign(O, A === !0 ? !0 : (0, e._)`${O} > ${A} ? ${O} : ${A}`)),
        mergeValues: (k, A) => k === !0 ? !0 : Math.max(k, A),
        resultToName: (k, A) => k.var("items", A)
      })
    };
    function y(k, A) {
      if (A === !0)
        return k.var("props", !0);
      const O = k.var("props", (0, e._)`{}`);
      return A !== void 0 && b(k, O, A), O;
    }
    gt.evaluatedPropsToName = y;
    function b(k, A, O) {
      Object.keys(O).forEach((P) => k.assign((0, e._)`${A}${(0, e.getProperty)(P)}`, !0));
    }
    gt.setEvaluated = b;
    const v = {};
    function x(k, A) {
      return k.scopeValue("func", {
        ref: A,
        code: v[A.code] || (v[A.code] = new t._Code(A.code))
      });
    }
    gt.useFunc = x;
    var E;
    (function(k) {
      k[k.Num = 0] = "Num", k[k.Str = 1] = "Str";
    })(E || (gt.Type = E = {}));
    function _(k, A, O) {
      if (k instanceof e.Name) {
        const P = A === E.Num;
        return O ? P ? (0, e._)`"[" + ${k} + "]"` : (0, e._)`"['" + ${k} + "']"` : P ? (0, e._)`"/" + ${k}` : (0, e._)`"/" + ${k}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return O ? (0, e.getProperty)(k).toString() : "/" + d(k);
    }
    gt.getErrorPath = _;
    function C(k, A, O = k.opts.strictSchema) {
      if (O) {
        if (A = `strict mode: ${A}`, O === !0)
          throw new Error(A);
        k.self.logger.warn(A);
      }
    }
    return gt.checkStrictMode = C, gt;
  }
  var Cy = {}, $D;
  function gl() {
    if ($D) return Cy;
    $D = 1, Object.defineProperty(Cy, "__esModule", { value: !0 });
    const e = vt(), t = {
      // validation function arguments
      data: new e.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new e.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new e.Name("instancePath"),
      parentData: new e.Name("parentData"),
      parentDataProperty: new e.Name("parentDataProperty"),
      rootData: new e.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new e.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new e.Name("vErrors"),
      // null or array of validation errors
      errors: new e.Name("errors"),
      // counter of validation errors
      this: new e.Name("this"),
      // "globals"
      self: new e.Name("self"),
      scope: new e.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new e.Name("json"),
      jsonPos: new e.Name("jsonPos"),
      jsonLen: new e.Name("jsonLen"),
      jsonPart: new e.Name("jsonPart")
    };
    return Cy.default = t, Cy;
  }
  var jD;
  function S1() {
    return jD || (jD = 1, (function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.extendErrors = e.resetErrorsCount = e.reportExtraError = e.reportError = e.keyword$DataError = e.keywordError = void 0;
      const t = vt(), n = Lt(), r = gl();
      e.keywordError = {
        message: ({ keyword: v }) => (0, t.str)`must pass "${v}" keyword validation`
      }, e.keyword$DataError = {
        message: ({ keyword: v, schemaType: x }) => x ? (0, t.str)`"${v}" keyword must be ${x} ($data)` : (0, t.str)`"${v}" keyword is invalid ($data)`
      };
      function o(v, x = e.keywordError, E, _) {
        const { it: C } = v, { gen: k, compositeRule: A, allErrors: O } = C, P = p(v, x, E);
        _ ?? (A || O) ? c(k, P) : u(C, (0, t._)`[${P}]`);
      }
      e.reportError = o;
      function i(v, x = e.keywordError, E) {
        const { it: _ } = v, { gen: C, compositeRule: k, allErrors: A } = _, O = p(v, x, E);
        c(C, O), k || A || u(_, r.default.vErrors);
      }
      e.reportExtraError = i;
      function a(v, x) {
        v.assign(r.default.errors, x), v.if((0, t._)`${r.default.vErrors} !== null`, () => v.if(x, () => v.assign((0, t._)`${r.default.vErrors}.length`, x), () => v.assign(r.default.vErrors, null)));
      }
      e.resetErrorsCount = a;
      function s({ gen: v, keyword: x, schemaValue: E, data: _, errsCount: C, it: k }) {
        if (C === void 0)
          throw new Error("ajv implementation error");
        const A = v.name("err");
        v.forRange("i", C, r.default.errors, (O) => {
          v.const(A, (0, t._)`${r.default.vErrors}[${O}]`), v.if((0, t._)`${A}.instancePath === undefined`, () => v.assign((0, t._)`${A}.instancePath`, (0, t.strConcat)(r.default.instancePath, k.errorPath))), v.assign((0, t._)`${A}.schemaPath`, (0, t.str)`${k.errSchemaPath}/${x}`), k.opts.verbose && (v.assign((0, t._)`${A}.schema`, E), v.assign((0, t._)`${A}.data`, _));
        });
      }
      e.extendErrors = s;
      function c(v, x) {
        const E = v.const("err", x);
        v.if((0, t._)`${r.default.vErrors} === null`, () => v.assign(r.default.vErrors, (0, t._)`[${E}]`), (0, t._)`${r.default.vErrors}.push(${E})`), v.code((0, t._)`${r.default.errors}++`);
      }
      function u(v, x) {
        const { gen: E, validateName: _, schemaEnv: C } = v;
        C.$async ? E.throw((0, t._)`new ${v.ValidationError}(${x})`) : (E.assign((0, t._)`${_}.errors`, x), E.return(!1));
      }
      const d = {
        keyword: new t.Name("keyword"),
        schemaPath: new t.Name("schemaPath"),
        // also used in JTD errors
        params: new t.Name("params"),
        propertyName: new t.Name("propertyName"),
        message: new t.Name("message"),
        schema: new t.Name("schema"),
        parentSchema: new t.Name("parentSchema")
      };
      function p(v, x, E) {
        const { createErrors: _ } = v.it;
        return _ === !1 ? (0, t._)`{}` : m(v, x, E);
      }
      function m(v, x, E = {}) {
        const { gen: _, it: C } = v, k = [
          g(C, E),
          y(v, E)
        ];
        return b(v, x, k), _.object(...k);
      }
      function g({ errorPath: v }, { instancePath: x }) {
        const E = x ? (0, t.str)`${v}${(0, n.getErrorPath)(x, n.Type.Str)}` : v;
        return [r.default.instancePath, (0, t.strConcat)(r.default.instancePath, E)];
      }
      function y({ keyword: v, it: { errSchemaPath: x } }, { schemaPath: E, parentSchema: _ }) {
        let C = _ ? x : (0, t.str)`${x}/${v}`;
        return E && (C = (0, t.str)`${C}${(0, n.getErrorPath)(E, n.Type.Str)}`), [d.schemaPath, C];
      }
      function b(v, { params: x, message: E }, _) {
        const { keyword: C, data: k, schemaValue: A, it: O } = v, { opts: P, propertyName: I, topSchemaRef: $, schemaPath: L } = O;
        _.push([d.keyword, C], [d.params, typeof x == "function" ? x(v) : x || (0, t._)`{}`]), P.messages && _.push([d.message, typeof E == "function" ? E(v) : E]), P.verbose && _.push([d.schema, A], [d.parentSchema, (0, t._)`${$}${L}`], [r.default.data, k]), I && _.push([d.propertyName, I]);
      }
    })(R_)), R_;
  }
  var DD;
  function SCe() {
    if (DD) return Ul;
    DD = 1, Object.defineProperty(Ul, "__esModule", { value: !0 }), Ul.boolOrEmptySchema = Ul.topBoolOrEmptySchema = void 0;
    const e = S1(), t = vt(), n = gl(), r = {
      message: "boolean schema is false"
    };
    function o(s) {
      const { gen: c, schema: u, validateName: d } = s;
      u === !1 ? a(s, !1) : typeof u == "object" && u.$async === !0 ? c.return(n.default.data) : (c.assign((0, t._)`${d}.errors`, null), c.return(!0));
    }
    Ul.topBoolOrEmptySchema = o;
    function i(s, c) {
      const { gen: u, schema: d } = s;
      d === !1 ? (u.var(c, !1), a(s)) : u.var(c, !0);
    }
    Ul.boolOrEmptySchema = i;
    function a(s, c) {
      const { gen: u, data: d } = s, p = {
        gen: u,
        keyword: "false schema",
        data: d,
        schema: !1,
        schemaCode: !1,
        schemaValue: !1,
        params: {},
        it: s
      };
      (0, e.reportError)(p, r, void 0, c);
    }
    return Ul;
  }
  var sr = {}, Vl = {}, FD;
  function xV() {
    if (FD) return Vl;
    FD = 1, Object.defineProperty(Vl, "__esModule", { value: !0 }), Vl.getRules = Vl.isJSONType = void 0;
    const e = ["string", "number", "integer", "boolean", "null", "object", "array"], t = new Set(e);
    function n(o) {
      return typeof o == "string" && t.has(o);
    }
    Vl.isJSONType = n;
    function r() {
      const o = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...o, integer: !0, boolean: !0, null: !0 },
        rules: [{ rules: [] }, o.number, o.string, o.array, o.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    return Vl.getRules = r, Vl;
  }
  var Ma = {}, LD;
  function wV() {
    if (LD) return Ma;
    LD = 1, Object.defineProperty(Ma, "__esModule", { value: !0 }), Ma.shouldUseRule = Ma.shouldUseGroup = Ma.schemaHasRulesForType = void 0;
    function e({ schema: r, self: o }, i) {
      const a = o.RULES.types[i];
      return a && a !== !0 && t(r, a);
    }
    Ma.schemaHasRulesForType = e;
    function t(r, o) {
      return o.rules.some((i) => n(r, i));
    }
    Ma.shouldUseGroup = t;
    function n(r, o) {
      var i;
      return r[o.keyword] !== void 0 || ((i = o.definition.implements) === null || i === void 0 ? void 0 : i.some((a) => r[a] !== void 0));
    }
    return Ma.shouldUseRule = n, Ma;
  }
  var zD;
  function B0() {
    if (zD) return sr;
    zD = 1, Object.defineProperty(sr, "__esModule", { value: !0 }), sr.reportTypeError = sr.checkDataTypes = sr.checkDataType = sr.coerceAndCheckDataType = sr.getJSONTypes = sr.getSchemaTypes = sr.DataType = void 0;
    const e = xV(), t = wV(), n = S1(), r = vt(), o = Lt();
    var i;
    (function(E) {
      E[E.Correct = 0] = "Correct", E[E.Wrong = 1] = "Wrong";
    })(i || (sr.DataType = i = {}));
    function a(E) {
      const _ = s(E.type);
      if (_.includes("null")) {
        if (E.nullable === !1)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!_.length && E.nullable !== void 0)
          throw new Error('"nullable" cannot be used without "type"');
        E.nullable === !0 && _.push("null");
      }
      return _;
    }
    sr.getSchemaTypes = a;
    function s(E) {
      const _ = Array.isArray(E) ? E : E ? [E] : [];
      if (_.every(e.isJSONType))
        return _;
      throw new Error("type must be JSONType or JSONType[]: " + _.join(","));
    }
    sr.getJSONTypes = s;
    function c(E, _) {
      const { gen: C, data: k, opts: A } = E, O = d(_, A.coerceTypes), P = _.length > 0 && !(O.length === 0 && _.length === 1 && (0, t.schemaHasRulesForType)(E, _[0]));
      if (P) {
        const I = y(_, k, A.strictNumbers, i.Wrong);
        C.if(I, () => {
          O.length ? p(E, _, O) : v(E);
        });
      }
      return P;
    }
    sr.coerceAndCheckDataType = c;
    const u = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function d(E, _) {
      return _ ? E.filter((C) => u.has(C) || _ === "array" && C === "array") : [];
    }
    function p(E, _, C) {
      const { gen: k, data: A, opts: O } = E, P = k.let("dataType", (0, r._)`typeof ${A}`), I = k.let("coerced", (0, r._)`undefined`);
      O.coerceTypes === "array" && k.if((0, r._)`${P} == 'object' && Array.isArray(${A}) && ${A}.length == 1`, () => k.assign(A, (0, r._)`${A}[0]`).assign(P, (0, r._)`typeof ${A}`).if(y(_, A, O.strictNumbers), () => k.assign(I, A))), k.if((0, r._)`${I} !== undefined`);
      for (const L of C)
        (u.has(L) || L === "array" && O.coerceTypes === "array") && $(L);
      k.else(), v(E), k.endIf(), k.if((0, r._)`${I} !== undefined`, () => {
        k.assign(A, I), m(E, I);
      });
      function $(L) {
        switch (L) {
          case "string":
            k.elseIf((0, r._)`${P} == "number" || ${P} == "boolean"`).assign(I, (0, r._)`"" + ${A}`).elseIf((0, r._)`${A} === null`).assign(I, (0, r._)`""`);
            return;
          case "number":
            k.elseIf((0, r._)`${P} == "boolean" || ${A} === null
              || (${P} == "string" && ${A} && ${A} == +${A})`).assign(I, (0, r._)`+${A}`);
            return;
          case "integer":
            k.elseIf((0, r._)`${P} === "boolean" || ${A} === null
              || (${P} === "string" && ${A} && ${A} == +${A} && !(${A} % 1))`).assign(I, (0, r._)`+${A}`);
            return;
          case "boolean":
            k.elseIf((0, r._)`${A} === "false" || ${A} === 0 || ${A} === null`).assign(I, !1).elseIf((0, r._)`${A} === "true" || ${A} === 1`).assign(I, !0);
            return;
          case "null":
            k.elseIf((0, r._)`${A} === "" || ${A} === 0 || ${A} === false`), k.assign(I, null);
            return;
          case "array":
            k.elseIf((0, r._)`${P} === "string" || ${P} === "number"
              || ${P} === "boolean" || ${A} === null`).assign(I, (0, r._)`[${A}]`);
        }
      }
    }
    function m({ gen: E, parentData: _, parentDataProperty: C }, k) {
      E.if((0, r._)`${_} !== undefined`, () => E.assign((0, r._)`${_}[${C}]`, k));
    }
    function g(E, _, C, k = i.Correct) {
      const A = k === i.Correct ? r.operators.EQ : r.operators.NEQ;
      let O;
      switch (E) {
        case "null":
          return (0, r._)`${_} ${A} null`;
        case "array":
          O = (0, r._)`Array.isArray(${_})`;
          break;
        case "object":
          O = (0, r._)`${_} && typeof ${_} == "object" && !Array.isArray(${_})`;
          break;
        case "integer":
          O = P((0, r._)`!(${_} % 1) && !isNaN(${_})`);
          break;
        case "number":
          O = P();
          break;
        default:
          return (0, r._)`typeof ${_} ${A} ${E}`;
      }
      return k === i.Correct ? O : (0, r.not)(O);
      function P(I = r.nil) {
        return (0, r.and)((0, r._)`typeof ${_} == "number"`, I, C ? (0, r._)`isFinite(${_})` : r.nil);
      }
    }
    sr.checkDataType = g;
    function y(E, _, C, k) {
      if (E.length === 1)
        return g(E[0], _, C, k);
      let A;
      const O = (0, o.toHash)(E);
      if (O.array && O.object) {
        const P = (0, r._)`typeof ${_} != "object"`;
        A = O.null ? P : (0, r._)`!${_} || ${P}`, delete O.null, delete O.array, delete O.object;
      } else
        A = r.nil;
      O.number && delete O.integer;
      for (const P in O)
        A = (0, r.and)(A, g(P, _, C, k));
      return A;
    }
    sr.checkDataTypes = y;
    const b = {
      message: ({ schema: E }) => `must be ${E}`,
      params: ({ schema: E, schemaValue: _ }) => typeof E == "string" ? (0, r._)`{type: ${E}}` : (0, r._)`{type: ${_}}`
    };
    function v(E) {
      const _ = x(E);
      (0, n.reportError)(_, b);
    }
    sr.reportTypeError = v;
    function x(E) {
      const { gen: _, data: C, schema: k } = E, A = (0, o.schemaRefOrVal)(E, k, "type");
      return {
        gen: _,
        keyword: "type",
        data: C,
        schema: k.type,
        schemaCode: A,
        schemaValue: A,
        parentSchema: k,
        params: {},
        it: E
      };
    }
    return sr;
  }
  var ep = {}, BD;
  function _Ce() {
    if (BD) return ep;
    BD = 1, Object.defineProperty(ep, "__esModule", { value: !0 }), ep.assignDefaults = void 0;
    const e = vt(), t = Lt();
    function n(o, i) {
      const { properties: a, items: s } = o.schema;
      if (i === "object" && a)
        for (const c in a)
          r(o, c, a[c].default);
      else i === "array" && Array.isArray(s) && s.forEach((c, u) => r(o, u, c.default));
    }
    ep.assignDefaults = n;
    function r(o, i, a) {
      const { gen: s, compositeRule: c, data: u, opts: d } = o;
      if (a === void 0)
        return;
      const p = (0, e._)`${u}${(0, e.getProperty)(i)}`;
      if (c) {
        (0, t.checkStrictMode)(o, `default is ignored for: ${p}`);
        return;
      }
      let m = (0, e._)`${p} === undefined`;
      d.useDefaults === "empty" && (m = (0, e._)`${m} || ${p} === null || ${p} === ""`), s.if(m, (0, e._)`${p} = ${(0, e.stringify)(a)}`);
    }
    return ep;
  }
  var Ho = {}, Zt = {}, UD;
  function ci() {
    if (UD) return Zt;
    UD = 1, Object.defineProperty(Zt, "__esModule", { value: !0 }), Zt.validateUnion = Zt.validateArray = Zt.usePattern = Zt.callValidateCode = Zt.schemaProperties = Zt.allSchemaProperties = Zt.noPropertyInData = Zt.propertyInData = Zt.isOwnProperty = Zt.hasPropFunc = Zt.reportMissingProp = Zt.checkMissingProp = Zt.checkReportMissingProp = void 0;
    const e = vt(), t = Lt(), n = gl(), r = Lt();
    function o(E, _) {
      const { gen: C, data: k, it: A } = E;
      C.if(d(C, k, _, A.opts.ownProperties), () => {
        E.setParams({ missingProperty: (0, e._)`${_}` }, !0), E.error();
      });
    }
    Zt.checkReportMissingProp = o;
    function i({ gen: E, data: _, it: { opts: C } }, k, A) {
      return (0, e.or)(...k.map((O) => (0, e.and)(d(E, _, O, C.ownProperties), (0, e._)`${A} = ${O}`)));
    }
    Zt.checkMissingProp = i;
    function a(E, _) {
      E.setParams({ missingProperty: _ }, !0), E.error();
    }
    Zt.reportMissingProp = a;
    function s(E) {
      return E.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, e._)`Object.prototype.hasOwnProperty`
      });
    }
    Zt.hasPropFunc = s;
    function c(E, _, C) {
      return (0, e._)`${s(E)}.call(${_}, ${C})`;
    }
    Zt.isOwnProperty = c;
    function u(E, _, C, k) {
      const A = (0, e._)`${_}${(0, e.getProperty)(C)} !== undefined`;
      return k ? (0, e._)`${A} && ${c(E, _, C)}` : A;
    }
    Zt.propertyInData = u;
    function d(E, _, C, k) {
      const A = (0, e._)`${_}${(0, e.getProperty)(C)} === undefined`;
      return k ? (0, e.or)(A, (0, e.not)(c(E, _, C))) : A;
    }
    Zt.noPropertyInData = d;
    function p(E) {
      return E ? Object.keys(E).filter((_) => _ !== "__proto__") : [];
    }
    Zt.allSchemaProperties = p;
    function m(E, _) {
      return p(_).filter((C) => !(0, t.alwaysValidSchema)(E, _[C]));
    }
    Zt.schemaProperties = m;
    function g({ schemaCode: E, data: _, it: { gen: C, topSchemaRef: k, schemaPath: A, errorPath: O }, it: P }, I, $, L) {
      const N = L ? (0, e._)`${E}, ${_}, ${k}${A}` : _, U = [
        [n.default.instancePath, (0, e.strConcat)(n.default.instancePath, O)],
        [n.default.parentData, P.parentData],
        [n.default.parentDataProperty, P.parentDataProperty],
        [n.default.rootData, n.default.rootData]
      ];
      P.opts.dynamicRef && U.push([n.default.dynamicAnchors, n.default.dynamicAnchors]);
      const j = (0, e._)`${N}, ${C.object(...U)}`;
      return $ !== e.nil ? (0, e._)`${I}.call(${$}, ${j})` : (0, e._)`${I}(${j})`;
    }
    Zt.callValidateCode = g;
    const y = (0, e._)`new RegExp`;
    function b({ gen: E, it: { opts: _ } }, C) {
      const k = _.unicodeRegExp ? "u" : "", { regExp: A } = _.code, O = A(C, k);
      return E.scopeValue("pattern", {
        key: O.toString(),
        ref: O,
        code: (0, e._)`${A.code === "new RegExp" ? y : (0, r.useFunc)(E, A)}(${C}, ${k})`
      });
    }
    Zt.usePattern = b;
    function v(E) {
      const { gen: _, data: C, keyword: k, it: A } = E, O = _.name("valid");
      if (A.allErrors) {
        const I = _.let("valid", !0);
        return P(() => _.assign(I, !1)), I;
      }
      return _.var(O, !0), P(() => _.break()), O;
      function P(I) {
        const $ = _.const("len", (0, e._)`${C}.length`);
        _.forRange("i", 0, $, (L) => {
          E.subschema({
            keyword: k,
            dataProp: L,
            dataPropType: t.Type.Num
          }, O), _.if((0, e.not)(O), I);
        });
      }
    }
    Zt.validateArray = v;
    function x(E) {
      const { gen: _, schema: C, keyword: k, it: A } = E;
      if (!Array.isArray(C))
        throw new Error("ajv implementation error");
      if (C.some(($) => (0, t.alwaysValidSchema)(A, $)) && !A.opts.unevaluated)
        return;
      const P = _.let("valid", !1), I = _.name("_valid");
      _.block(() => C.forEach(($, L) => {
        const N = E.subschema({
          keyword: k,
          schemaProp: L,
          compositeRule: !0
        }, I);
        _.assign(P, (0, e._)`${P} || ${I}`), E.mergeValidEvaluated(N, I) || _.if((0, e.not)(P));
      })), E.result(P, () => E.reset(), () => E.error(!0));
    }
    return Zt.validateUnion = x, Zt;
  }
  var VD;
  function ECe() {
    if (VD) return Ho;
    VD = 1, Object.defineProperty(Ho, "__esModule", { value: !0 }), Ho.validateKeywordUsage = Ho.validSchemaType = Ho.funcKeywordCode = Ho.macroKeywordCode = void 0;
    const e = vt(), t = gl(), n = ci(), r = S1();
    function o(m, g) {
      const { gen: y, keyword: b, schema: v, parentSchema: x, it: E } = m, _ = g.macro.call(E.self, v, x, E), C = u(y, b, _);
      E.opts.validateSchema !== !1 && E.self.validateSchema(_, !0);
      const k = y.name("valid");
      m.subschema({
        schema: _,
        schemaPath: e.nil,
        errSchemaPath: `${E.errSchemaPath}/${b}`,
        topSchemaRef: C,
        compositeRule: !0
      }, k), m.pass(k, () => m.error(!0));
    }
    Ho.macroKeywordCode = o;
    function i(m, g) {
      var y;
      const { gen: b, keyword: v, schema: x, parentSchema: E, $data: _, it: C } = m;
      c(C, g);
      const k = !_ && g.compile ? g.compile.call(C.self, x, E, C) : g.validate, A = u(b, v, k), O = b.let("valid");
      m.block$data(O, P), m.ok((y = g.valid) !== null && y !== void 0 ? y : O);
      function P() {
        if (g.errors === !1)
          L(), g.modifying && a(m), N(() => m.error());
        else {
          const U = g.async ? I() : $();
          g.modifying && a(m), N(() => s(m, U));
        }
      }
      function I() {
        const U = b.let("ruleErrs", null);
        return b.try(() => L((0, e._)`await `), (j) => b.assign(O, !1).if((0, e._)`${j} instanceof ${C.ValidationError}`, () => b.assign(U, (0, e._)`${j}.errors`), () => b.throw(j))), U;
      }
      function $() {
        const U = (0, e._)`${A}.errors`;
        return b.assign(U, null), L(e.nil), U;
      }
      function L(U = g.async ? (0, e._)`await ` : e.nil) {
        const j = C.opts.passContext ? t.default.this : t.default.self, V = !("compile" in g && !_ || g.schema === !1);
        b.assign(O, (0, e._)`${U}${(0, n.callValidateCode)(m, A, j, V)}`, g.modifying);
      }
      function N(U) {
        var j;
        b.if((0, e.not)((j = g.valid) !== null && j !== void 0 ? j : O), U);
      }
    }
    Ho.funcKeywordCode = i;
    function a(m) {
      const { gen: g, data: y, it: b } = m;
      g.if(b.parentData, () => g.assign(y, (0, e._)`${b.parentData}[${b.parentDataProperty}]`));
    }
    function s(m, g) {
      const { gen: y } = m;
      y.if((0, e._)`Array.isArray(${g})`, () => {
        y.assign(t.default.vErrors, (0, e._)`${t.default.vErrors} === null ? ${g} : ${t.default.vErrors}.concat(${g})`).assign(t.default.errors, (0, e._)`${t.default.vErrors}.length`), (0, r.extendErrors)(m);
      }, () => m.error());
    }
    function c({ schemaEnv: m }, g) {
      if (g.async && !m.$async)
        throw new Error("async keyword in sync schema");
    }
    function u(m, g, y) {
      if (y === void 0)
        throw new Error(`keyword "${g}" failed to compile`);
      return m.scopeValue("keyword", typeof y == "function" ? { ref: y } : { ref: y, code: (0, e.stringify)(y) });
    }
    function d(m, g, y = !1) {
      return !g.length || g.some((b) => b === "array" ? Array.isArray(m) : b === "object" ? m && typeof m == "object" && !Array.isArray(m) : typeof m == b || y && typeof m > "u");
    }
    Ho.validSchemaType = d;
    function p({ schema: m, opts: g, self: y, errSchemaPath: b }, v, x) {
      if (Array.isArray(v.keyword) ? !v.keyword.includes(x) : v.keyword !== x)
        throw new Error("ajv implementation error");
      const E = v.dependencies;
      if (E?.some((_) => !Object.prototype.hasOwnProperty.call(m, _)))
        throw new Error(`parent schema must have dependencies of ${x}: ${E.join(",")}`);
      if (v.validateSchema && !v.validateSchema(m[x])) {
        const C = `keyword "${x}" value is invalid at path "${b}": ` + y.errorsText(v.validateSchema.errors);
        if (g.validateSchema === "log")
          y.logger.error(C);
        else
          throw new Error(C);
      }
    }
    return Ho.validateKeywordUsage = p, Ho;
  }
  var Na = {}, HD;
  function CCe() {
    if (HD) return Na;
    HD = 1, Object.defineProperty(Na, "__esModule", { value: !0 }), Na.extendSubschemaMode = Na.extendSubschemaData = Na.getSubschema = void 0;
    const e = vt(), t = Lt();
    function n(i, { keyword: a, schemaProp: s, schema: c, schemaPath: u, errSchemaPath: d, topSchemaRef: p }) {
      if (a !== void 0 && c !== void 0)
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      if (a !== void 0) {
        const m = i.schema[a];
        return s === void 0 ? {
          schema: m,
          schemaPath: (0, e._)`${i.schemaPath}${(0, e.getProperty)(a)}`,
          errSchemaPath: `${i.errSchemaPath}/${a}`
        } : {
          schema: m[s],
          schemaPath: (0, e._)`${i.schemaPath}${(0, e.getProperty)(a)}${(0, e.getProperty)(s)}`,
          errSchemaPath: `${i.errSchemaPath}/${a}/${(0, t.escapeFragment)(s)}`
        };
      }
      if (c !== void 0) {
        if (u === void 0 || d === void 0 || p === void 0)
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        return {
          schema: c,
          schemaPath: u,
          topSchemaRef: p,
          errSchemaPath: d
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    Na.getSubschema = n;
    function r(i, a, { dataProp: s, dataPropType: c, data: u, dataTypes: d, propertyName: p }) {
      if (u !== void 0 && s !== void 0)
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      const { gen: m } = a;
      if (s !== void 0) {
        const { errorPath: y, dataPathArr: b, opts: v } = a, x = m.let("data", (0, e._)`${a.data}${(0, e.getProperty)(s)}`, !0);
        g(x), i.errorPath = (0, e.str)`${y}${(0, t.getErrorPath)(s, c, v.jsPropertySyntax)}`, i.parentDataProperty = (0, e._)`${s}`, i.dataPathArr = [...b, i.parentDataProperty];
      }
      if (u !== void 0) {
        const y = u instanceof e.Name ? u : m.let("data", u, !0);
        g(y), p !== void 0 && (i.propertyName = p);
      }
      d && (i.dataTypes = d);
      function g(y) {
        i.data = y, i.dataLevel = a.dataLevel + 1, i.dataTypes = [], a.definedProperties = /* @__PURE__ */ new Set(), i.parentData = a.data, i.dataNames = [...a.dataNames, y];
      }
    }
    Na.extendSubschemaData = r;
    function o(i, { jtdDiscriminator: a, jtdMetadata: s, compositeRule: c, createErrors: u, allErrors: d }) {
      c !== void 0 && (i.compositeRule = c), u !== void 0 && (i.createErrors = u), d !== void 0 && (i.allErrors = d), i.jtdDiscriminator = a, i.jtdMetadata = s;
    }
    return Na.extendSubschemaMode = o, Na;
  }
  var Cr = {}, P_, qD;
  function SV() {
    return qD || (qD = 1, P_ = function e(t, n) {
      if (t === n) return !0;
      if (t && n && typeof t == "object" && typeof n == "object") {
        if (t.constructor !== n.constructor) return !1;
        var r, o, i;
        if (Array.isArray(t)) {
          if (r = t.length, r != n.length) return !1;
          for (o = r; o-- !== 0; )
            if (!e(t[o], n[o])) return !1;
          return !0;
        }
        if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
        if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
        if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
        if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
        for (o = r; o-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
        for (o = r; o-- !== 0; ) {
          var a = i[o];
          if (!e(t[a], n[a])) return !1;
        }
        return !0;
      }
      return t !== t && n !== n;
    }), P_;
  }
  var I_ = { exports: {} }, WD;
  function kCe() {
    if (WD) return I_.exports;
    WD = 1;
    var e = I_.exports = function(r, o, i) {
      typeof o == "function" && (i = o, o = {}), i = o.cb || i;
      var a = typeof i == "function" ? i : i.pre || function() {
      }, s = i.post || function() {
      };
      t(o, a, s, r, "", r);
    };
    e.keywords = {
      additionalItems: !0,
      items: !0,
      contains: !0,
      additionalProperties: !0,
      propertyNames: !0,
      not: !0,
      if: !0,
      then: !0,
      else: !0
    }, e.arrayKeywords = {
      items: !0,
      allOf: !0,
      anyOf: !0,
      oneOf: !0
    }, e.propsKeywords = {
      $defs: !0,
      definitions: !0,
      properties: !0,
      patternProperties: !0,
      dependencies: !0
    }, e.skipKeywords = {
      default: !0,
      enum: !0,
      const: !0,
      required: !0,
      maximum: !0,
      minimum: !0,
      exclusiveMaximum: !0,
      exclusiveMinimum: !0,
      multipleOf: !0,
      maxLength: !0,
      minLength: !0,
      pattern: !0,
      format: !0,
      maxItems: !0,
      minItems: !0,
      uniqueItems: !0,
      maxProperties: !0,
      minProperties: !0
    };
    function t(r, o, i, a, s, c, u, d, p, m) {
      if (a && typeof a == "object" && !Array.isArray(a)) {
        o(a, s, c, u, d, p, m);
        for (var g in a) {
          var y = a[g];
          if (Array.isArray(y)) {
            if (g in e.arrayKeywords)
              for (var b = 0; b < y.length; b++)
                t(r, o, i, y[b], s + "/" + g + "/" + b, c, s, g, a, b);
          } else if (g in e.propsKeywords) {
            if (y && typeof y == "object")
              for (var v in y)
                t(r, o, i, y[v], s + "/" + g + "/" + n(v), c, s, g, a, v);
          } else (g in e.keywords || r.allKeys && !(g in e.skipKeywords)) && t(r, o, i, y, s + "/" + g, c, s, g, a);
        }
        i(a, s, c, u, d, p, m);
      }
    }
    function n(r) {
      return r.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    return I_.exports;
  }
  var GD;
  function _1() {
    if (GD) return Cr;
    GD = 1, Object.defineProperty(Cr, "__esModule", { value: !0 }), Cr.getSchemaRefs = Cr.resolveUrl = Cr.normalizeId = Cr._getFullPath = Cr.getFullPath = Cr.inlineRef = void 0;
    const e = Lt(), t = SV(), n = kCe(), r = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function o(b, v = !0) {
      return typeof b == "boolean" ? !0 : v === !0 ? !a(b) : v ? s(b) <= v : !1;
    }
    Cr.inlineRef = o;
    const i = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function a(b) {
      for (const v in b) {
        if (i.has(v))
          return !0;
        const x = b[v];
        if (Array.isArray(x) && x.some(a) || typeof x == "object" && a(x))
          return !0;
      }
      return !1;
    }
    function s(b) {
      let v = 0;
      for (const x in b) {
        if (x === "$ref")
          return 1 / 0;
        if (v++, !r.has(x) && (typeof b[x] == "object" && (0, e.eachItem)(b[x], (E) => v += s(E)), v === 1 / 0))
          return 1 / 0;
      }
      return v;
    }
    function c(b, v = "", x) {
      x !== !1 && (v = p(v));
      const E = b.parse(v);
      return u(b, E);
    }
    Cr.getFullPath = c;
    function u(b, v) {
      return b.serialize(v).split("#")[0] + "#";
    }
    Cr._getFullPath = u;
    const d = /#\/?$/;
    function p(b) {
      return b ? b.replace(d, "") : "";
    }
    Cr.normalizeId = p;
    function m(b, v, x) {
      return x = p(x), b.resolve(v, x);
    }
    Cr.resolveUrl = m;
    const g = /^[a-z_][-a-z0-9._]*$/i;
    function y(b, v) {
      if (typeof b == "boolean")
        return {};
      const { schemaId: x, uriResolver: E } = this.opts, _ = p(b[x] || v), C = { "": _ }, k = c(E, _, !1), A = {}, O = /* @__PURE__ */ new Set();
      return n(b, { allKeys: !0 }, ($, L, N, U) => {
        if (U === void 0)
          return;
        const j = k + L;
        let V = C[U];
        typeof $[x] == "string" && (V = F.call(this, $[x])), K.call(this, $.$anchor), K.call(this, $.$dynamicAnchor), C[L] = V;
        function F(W) {
          const Y = this.opts.uriResolver.resolve;
          if (W = p(V ? Y(V, W) : W), O.has(W))
            throw I(W);
          O.add(W);
          let B = this.refs[W];
          return typeof B == "string" && (B = this.refs[B]), typeof B == "object" ? P($, B.schema, W) : W !== p(j) && (W[0] === "#" ? (P($, A[W], W), A[W] = $) : this.refs[W] = j), W;
        }
        function K(W) {
          if (typeof W == "string") {
            if (!g.test(W))
              throw new Error(`invalid anchor "${W}"`);
            F.call(this, `#${W}`);
          }
        }
      }), A;
      function P($, L, N) {
        if (L !== void 0 && !t($, L))
          throw I(N);
      }
      function I($) {
        return new Error(`reference "${$}" resolves to more than one schema`);
      }
    }
    return Cr.getSchemaRefs = y, Cr;
  }
  var KD;
  function E1() {
    if (KD) return Oa;
    KD = 1, Object.defineProperty(Oa, "__esModule", { value: !0 }), Oa.getData = Oa.KeywordCxt = Oa.validateFunctionCode = void 0;
    const e = SCe(), t = B0(), n = wV(), r = B0(), o = _Ce(), i = ECe(), a = CCe(), s = vt(), c = gl(), u = _1(), d = Lt(), p = S1();
    function m(J) {
      if (k(J) && (O(J), C(J))) {
        v(J);
        return;
      }
      g(J, () => (0, e.topBoolOrEmptySchema)(J));
    }
    Oa.validateFunctionCode = m;
    function g({ gen: J, validateName: ee, schema: ie, schemaEnv: le, opts: ge }, Se) {
      ge.code.es5 ? J.func(ee, (0, s._)`${c.default.data}, ${c.default.valCxt}`, le.$async, () => {
        J.code((0, s._)`"use strict"; ${E(ie, ge)}`), b(J, ge), J.code(Se);
      }) : J.func(ee, (0, s._)`${c.default.data}, ${y(ge)}`, le.$async, () => J.code(E(ie, ge)).code(Se));
    }
    function y(J) {
      return (0, s._)`{${c.default.instancePath}="", ${c.default.parentData}, ${c.default.parentDataProperty}, ${c.default.rootData}=${c.default.data}${J.dynamicRef ? (0, s._)`, ${c.default.dynamicAnchors}={}` : s.nil}}={}`;
    }
    function b(J, ee) {
      J.if(c.default.valCxt, () => {
        J.var(c.default.instancePath, (0, s._)`${c.default.valCxt}.${c.default.instancePath}`), J.var(c.default.parentData, (0, s._)`${c.default.valCxt}.${c.default.parentData}`), J.var(c.default.parentDataProperty, (0, s._)`${c.default.valCxt}.${c.default.parentDataProperty}`), J.var(c.default.rootData, (0, s._)`${c.default.valCxt}.${c.default.rootData}`), ee.dynamicRef && J.var(c.default.dynamicAnchors, (0, s._)`${c.default.valCxt}.${c.default.dynamicAnchors}`);
      }, () => {
        J.var(c.default.instancePath, (0, s._)`""`), J.var(c.default.parentData, (0, s._)`undefined`), J.var(c.default.parentDataProperty, (0, s._)`undefined`), J.var(c.default.rootData, c.default.data), ee.dynamicRef && J.var(c.default.dynamicAnchors, (0, s._)`{}`);
      });
    }
    function v(J) {
      const { schema: ee, opts: ie, gen: le } = J;
      g(J, () => {
        ie.$comment && ee.$comment && U(J), $(J), le.let(c.default.vErrors, null), le.let(c.default.errors, 0), ie.unevaluated && x(J), P(J), j(J);
      });
    }
    function x(J) {
      const { gen: ee, validateName: ie } = J;
      J.evaluated = ee.const("evaluated", (0, s._)`${ie}.evaluated`), ee.if((0, s._)`${J.evaluated}.dynamicProps`, () => ee.assign((0, s._)`${J.evaluated}.props`, (0, s._)`undefined`)), ee.if((0, s._)`${J.evaluated}.dynamicItems`, () => ee.assign((0, s._)`${J.evaluated}.items`, (0, s._)`undefined`));
    }
    function E(J, ee) {
      const ie = typeof J == "object" && J[ee.schemaId];
      return ie && (ee.code.source || ee.code.process) ? (0, s._)`/*# sourceURL=${ie} */` : s.nil;
    }
    function _(J, ee) {
      if (k(J) && (O(J), C(J))) {
        A(J, ee);
        return;
      }
      (0, e.boolOrEmptySchema)(J, ee);
    }
    function C({ schema: J, self: ee }) {
      if (typeof J == "boolean")
        return !J;
      for (const ie in J)
        if (ee.RULES.all[ie])
          return !0;
      return !1;
    }
    function k(J) {
      return typeof J.schema != "boolean";
    }
    function A(J, ee) {
      const { schema: ie, gen: le, opts: ge } = J;
      ge.$comment && ie.$comment && U(J), L(J), N(J);
      const Se = le.const("_errs", c.default.errors);
      P(J, Se), le.var(ee, (0, s._)`${Se} === ${c.default.errors}`);
    }
    function O(J) {
      (0, d.checkUnknownRules)(J), I(J);
    }
    function P(J, ee) {
      if (J.opts.jtd)
        return F(J, [], !1, ee);
      const ie = (0, t.getSchemaTypes)(J.schema), le = (0, t.coerceAndCheckDataType)(J, ie);
      F(J, ie, !le, ee);
    }
    function I(J) {
      const { schema: ee, errSchemaPath: ie, opts: le, self: ge } = J;
      ee.$ref && le.ignoreKeywordsWithRef && (0, d.schemaHasRulesButRef)(ee, ge.RULES) && ge.logger.warn(`$ref: keywords ignored in schema at path "${ie}"`);
    }
    function $(J) {
      const { schema: ee, opts: ie } = J;
      ee.default !== void 0 && ie.useDefaults && ie.strictSchema && (0, d.checkStrictMode)(J, "default is ignored in the schema root");
    }
    function L(J) {
      const ee = J.schema[J.opts.schemaId];
      ee && (J.baseId = (0, u.resolveUrl)(J.opts.uriResolver, J.baseId, ee));
    }
    function N(J) {
      if (J.schema.$async && !J.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function U({ gen: J, schemaEnv: ee, schema: ie, errSchemaPath: le, opts: ge }) {
      const Se = ie.$comment;
      if (ge.$comment === !0)
        J.code((0, s._)`${c.default.self}.logger.log(${Se})`);
      else if (typeof ge.$comment == "function") {
        const Me = (0, s.str)`${le}/$comment`, je = J.scopeValue("root", { ref: ee.root });
        J.code((0, s._)`${c.default.self}.opts.$comment(${Se}, ${Me}, ${je}.schema)`);
      }
    }
    function j(J) {
      const { gen: ee, schemaEnv: ie, validateName: le, ValidationError: ge, opts: Se } = J;
      ie.$async ? ee.if((0, s._)`${c.default.errors} === 0`, () => ee.return(c.default.data), () => ee.throw((0, s._)`new ${ge}(${c.default.vErrors})`)) : (ee.assign((0, s._)`${le}.errors`, c.default.vErrors), Se.unevaluated && V(J), ee.return((0, s._)`${c.default.errors} === 0`));
    }
    function V({ gen: J, evaluated: ee, props: ie, items: le }) {
      ie instanceof s.Name && J.assign((0, s._)`${ee}.props`, ie), le instanceof s.Name && J.assign((0, s._)`${ee}.items`, le);
    }
    function F(J, ee, ie, le) {
      const { gen: ge, schema: Se, data: Me, allErrors: je, opts: ze, self: Ye } = J, { RULES: Ue } = Ye;
      if (Se.$ref && (ze.ignoreKeywordsWithRef || !(0, d.schemaHasRulesButRef)(Se, Ue))) {
        ge.block(() => ne(J, "$ref", Ue.all.$ref.definition));
        return;
      }
      ze.jtd || W(J, ee), ge.block(() => {
        for (const mt of Ue.rules)
          Ne(mt);
        Ne(Ue.post);
      });
      function Ne(mt) {
        (0, n.shouldUseGroup)(Se, mt) && (mt.type ? (ge.if((0, r.checkDataType)(mt.type, Me, ze.strictNumbers)), K(J, mt), ee.length === 1 && ee[0] === mt.type && ie && (ge.else(), (0, r.reportTypeError)(J)), ge.endIf()) : K(J, mt), je || ge.if((0, s._)`${c.default.errors} === ${le || 0}`));
      }
    }
    function K(J, ee) {
      const { gen: ie, schema: le, opts: { useDefaults: ge } } = J;
      ge && (0, o.assignDefaults)(J, ee.type), ie.block(() => {
        for (const Se of ee.rules)
          (0, n.shouldUseRule)(le, Se) && ne(J, Se.keyword, Se.definition, ee.type);
      });
    }
    function W(J, ee) {
      J.schemaEnv.meta || !J.opts.strictTypes || (Y(J, ee), J.opts.allowUnionTypes || B(J, ee), D(J, J.dataTypes));
    }
    function Y(J, ee) {
      if (ee.length) {
        if (!J.dataTypes.length) {
          J.dataTypes = ee;
          return;
        }
        ee.forEach((ie) => {
          z(J.dataTypes, ie) || X(J, `type "${ie}" not allowed by context "${J.dataTypes.join(",")}"`);
        }), H(J, ee);
      }
    }
    function B(J, ee) {
      ee.length > 1 && !(ee.length === 2 && ee.includes("null")) && X(J, "use allowUnionTypes to allow union type keyword");
    }
    function D(J, ee) {
      const ie = J.self.RULES.all;
      for (const le in ie) {
        const ge = ie[le];
        if (typeof ge == "object" && (0, n.shouldUseRule)(J.schema, ge)) {
          const { type: Se } = ge.definition;
          Se.length && !Se.some((Me) => G(ee, Me)) && X(J, `missing type "${Se.join(",")}" for keyword "${le}"`);
        }
      }
    }
    function G(J, ee) {
      return J.includes(ee) || ee === "number" && J.includes("integer");
    }
    function z(J, ee) {
      return J.includes(ee) || ee === "integer" && J.includes("number");
    }
    function H(J, ee) {
      const ie = [];
      for (const le of J.dataTypes)
        z(ee, le) ? ie.push(le) : ee.includes("integer") && le === "number" && ie.push("integer");
      J.dataTypes = ie;
    }
    function X(J, ee) {
      const ie = J.schemaEnv.baseId + J.errSchemaPath;
      ee += ` at "${ie}" (strictTypes)`, (0, d.checkStrictMode)(J, ee, J.opts.strictTypes);
    }
    class Q {
      constructor(ee, ie, le) {
        if ((0, i.validateKeywordUsage)(ee, ie, le), this.gen = ee.gen, this.allErrors = ee.allErrors, this.keyword = le, this.data = ee.data, this.schema = ee.schema[le], this.$data = ie.$data && ee.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, d.schemaRefOrVal)(ee, this.schema, le, this.$data), this.schemaType = ie.schemaType, this.parentSchema = ee.schema, this.params = {}, this.it = ee, this.def = ie, this.$data)
          this.schemaCode = ee.gen.const("vSchema", ue(this.$data, ee));
        else if (this.schemaCode = this.schemaValue, !(0, i.validSchemaType)(this.schema, ie.schemaType, ie.allowUndefined))
          throw new Error(`${le} value must be ${JSON.stringify(ie.schemaType)}`);
        ("code" in ie ? ie.trackErrors : ie.errors !== !1) && (this.errsCount = ee.gen.const("_errs", c.default.errors));
      }
      result(ee, ie, le) {
        this.failResult((0, s.not)(ee), ie, le);
      }
      failResult(ee, ie, le) {
        this.gen.if(ee), le ? le() : this.error(), ie ? (this.gen.else(), ie(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
      }
      pass(ee, ie) {
        this.failResult((0, s.not)(ee), void 0, ie);
      }
      fail(ee) {
        if (ee === void 0) {
          this.error(), this.allErrors || this.gen.if(!1);
          return;
        }
        this.gen.if(ee), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
      }
      fail$data(ee) {
        if (!this.$data)
          return this.fail(ee);
        const { schemaCode: ie } = this;
        this.fail((0, s._)`${ie} !== undefined && (${(0, s.or)(this.invalid$data(), ee)})`);
      }
      error(ee, ie, le) {
        if (ie) {
          this.setParams(ie), this._error(ee, le), this.setParams({});
          return;
        }
        this._error(ee, le);
      }
      _error(ee, ie) {
        (ee ? p.reportExtraError : p.reportError)(this, this.def.error, ie);
      }
      $dataError() {
        (0, p.reportError)(this, this.def.$dataError || p.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, p.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(ee) {
        this.allErrors || this.gen.if(ee);
      }
      setParams(ee, ie) {
        ie ? Object.assign(this.params, ee) : this.params = ee;
      }
      block$data(ee, ie, le = s.nil) {
        this.gen.block(() => {
          this.check$data(ee, le), ie();
        });
      }
      check$data(ee = s.nil, ie = s.nil) {
        if (!this.$data)
          return;
        const { gen: le, schemaCode: ge, schemaType: Se, def: Me } = this;
        le.if((0, s.or)((0, s._)`${ge} === undefined`, ie)), ee !== s.nil && le.assign(ee, !0), (Se.length || Me.validateSchema) && (le.elseIf(this.invalid$data()), this.$dataError(), ee !== s.nil && le.assign(ee, !1)), le.else();
      }
      invalid$data() {
        const { gen: ee, schemaCode: ie, schemaType: le, def: ge, it: Se } = this;
        return (0, s.or)(Me(), je());
        function Me() {
          if (le.length) {
            if (!(ie instanceof s.Name))
              throw new Error("ajv implementation error");
            const ze = Array.isArray(le) ? le : [le];
            return (0, s._)`${(0, r.checkDataTypes)(ze, ie, Se.opts.strictNumbers, r.DataType.Wrong)}`;
          }
          return s.nil;
        }
        function je() {
          if (ge.validateSchema) {
            const ze = ee.scopeValue("validate$data", { ref: ge.validateSchema });
            return (0, s._)`!${ze}(${ie})`;
          }
          return s.nil;
        }
      }
      subschema(ee, ie) {
        const le = (0, a.getSubschema)(this.it, ee);
        (0, a.extendSubschemaData)(le, this.it, ee), (0, a.extendSubschemaMode)(le, ee);
        const ge = { ...this.it, ...le, items: void 0, props: void 0 };
        return _(ge, ie), ge;
      }
      mergeEvaluated(ee, ie) {
        const { it: le, gen: ge } = this;
        le.opts.unevaluated && (le.props !== !0 && ee.props !== void 0 && (le.props = d.mergeEvaluated.props(ge, ee.props, le.props, ie)), le.items !== !0 && ee.items !== void 0 && (le.items = d.mergeEvaluated.items(ge, ee.items, le.items, ie)));
      }
      mergeValidEvaluated(ee, ie) {
        const { it: le, gen: ge } = this;
        if (le.opts.unevaluated && (le.props !== !0 || le.items !== !0))
          return ge.if(ie, () => this.mergeEvaluated(ee, s.Name)), !0;
      }
    }
    Oa.KeywordCxt = Q;
    function ne(J, ee, ie, le) {
      const ge = new Q(J, ie, ee);
      "code" in ie ? ie.code(ge, le) : ge.$data && ie.validate ? (0, i.funcKeywordCode)(ge, ie) : "macro" in ie ? (0, i.macroKeywordCode)(ge, ie) : (ie.compile || ie.validate) && (0, i.funcKeywordCode)(ge, ie);
    }
    const te = /^\/(?:[^~]|~0|~1)*$/, se = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function ue(J, { dataLevel: ee, dataNames: ie, dataPathArr: le }) {
      let ge, Se;
      if (J === "")
        return c.default.rootData;
      if (J[0] === "/") {
        if (!te.test(J))
          throw new Error(`Invalid JSON-pointer: ${J}`);
        ge = J, Se = c.default.rootData;
      } else {
        const Ye = se.exec(J);
        if (!Ye)
          throw new Error(`Invalid JSON-pointer: ${J}`);
        const Ue = +Ye[1];
        if (ge = Ye[2], ge === "#") {
          if (Ue >= ee)
            throw new Error(ze("property/index", Ue));
          return le[ee - Ue];
        }
        if (Ue > ee)
          throw new Error(ze("data", Ue));
        if (Se = ie[ee - Ue], !ge)
          return Se;
      }
      let Me = Se;
      const je = ge.split("/");
      for (const Ye of je)
        Ye && (Se = (0, s._)`${Se}${(0, s.getProperty)((0, d.unescapeJsonPointer)(Ye))}`, Me = (0, s._)`${Me} && ${Se}`);
      return Me;
      function ze(Ye, Ue) {
        return `Cannot access ${Ye} ${Ue} levels up, current level is ${ee}`;
      }
    }
    return Oa.getData = ue, Oa;
  }
  var ky = {}, YD;
  function TA() {
    if (YD) return ky;
    YD = 1, Object.defineProperty(ky, "__esModule", { value: !0 });
    class e extends Error {
      constructor(n) {
        super("validation failed"), this.errors = n, this.ajv = this.validation = !0;
      }
    }
    return ky.default = e, ky;
  }
  var Ty = {}, XD;
  function C1() {
    if (XD) return Ty;
    XD = 1, Object.defineProperty(Ty, "__esModule", { value: !0 });
    const e = _1();
    class t extends Error {
      constructor(r, o, i, a) {
        super(a || `can't resolve reference ${i} from id ${o}`), this.missingRef = (0, e.resolveUrl)(r, o, i), this.missingSchema = (0, e.normalizeId)((0, e.getFullPath)(r, this.missingRef));
      }
    }
    return Ty.default = t, Ty;
  }
  var to = {}, ZD;
  function AA() {
    if (ZD) return to;
    ZD = 1, Object.defineProperty(to, "__esModule", { value: !0 }), to.resolveSchema = to.getCompilingSchema = to.resolveRef = to.compileSchema = to.SchemaEnv = void 0;
    const e = vt(), t = TA(), n = gl(), r = _1(), o = Lt(), i = E1();
    class a {
      constructor(x) {
        var E;
        this.refs = {}, this.dynamicAnchors = {};
        let _;
        typeof x.schema == "object" && (_ = x.schema), this.schema = x.schema, this.schemaId = x.schemaId, this.root = x.root || this, this.baseId = (E = x.baseId) !== null && E !== void 0 ? E : (0, r.normalizeId)(_?.[x.schemaId || "$id"]), this.schemaPath = x.schemaPath, this.localRefs = x.localRefs, this.meta = x.meta, this.$async = _?.$async, this.refs = {};
      }
    }
    to.SchemaEnv = a;
    function s(v) {
      const x = d.call(this, v);
      if (x)
        return x;
      const E = (0, r.getFullPath)(this.opts.uriResolver, v.root.baseId), { es5: _, lines: C } = this.opts.code, { ownProperties: k } = this.opts, A = new e.CodeGen(this.scope, { es5: _, lines: C, ownProperties: k });
      let O;
      v.$async && (O = A.scopeValue("Error", {
        ref: t.default,
        code: (0, e._)`require("ajv/dist/runtime/validation_error").default`
      }));
      const P = A.scopeName("validate");
      v.validateName = P;
      const I = {
        gen: A,
        allErrors: this.opts.allErrors,
        data: n.default.data,
        parentData: n.default.parentData,
        parentDataProperty: n.default.parentDataProperty,
        dataNames: [n.default.data],
        dataPathArr: [e.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: A.scopeValue("schema", this.opts.code.source === !0 ? { ref: v.schema, code: (0, e.stringify)(v.schema) } : { ref: v.schema }),
        validateName: P,
        ValidationError: O,
        schema: v.schema,
        schemaEnv: v,
        rootId: E,
        baseId: v.baseId || E,
        schemaPath: e.nil,
        errSchemaPath: v.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, e._)`""`,
        opts: this.opts,
        self: this
      };
      let $;
      try {
        this._compilations.add(v), (0, i.validateFunctionCode)(I), A.optimize(this.opts.code.optimize);
        const L = A.toString();
        $ = `${A.scopeRefs(n.default.scope)}return ${L}`, this.opts.code.process && ($ = this.opts.code.process($, v));
        const U = new Function(`${n.default.self}`, `${n.default.scope}`, $)(this, this.scope.get());
        if (this.scope.value(P, { ref: U }), U.errors = null, U.schema = v.schema, U.schemaEnv = v, v.$async && (U.$async = !0), this.opts.code.source === !0 && (U.source = { validateName: P, validateCode: L, scopeValues: A._values }), this.opts.unevaluated) {
          const { props: j, items: V } = I;
          U.evaluated = {
            props: j instanceof e.Name ? void 0 : j,
            items: V instanceof e.Name ? void 0 : V,
            dynamicProps: j instanceof e.Name,
            dynamicItems: V instanceof e.Name
          }, U.source && (U.source.evaluated = (0, e.stringify)(U.evaluated));
        }
        return v.validate = U, v;
      } catch (L) {
        throw delete v.validate, delete v.validateName, $ && this.logger.error("Error compiling schema, function code:", $), L;
      } finally {
        this._compilations.delete(v);
      }
    }
    to.compileSchema = s;
    function c(v, x, E) {
      var _;
      E = (0, r.resolveUrl)(this.opts.uriResolver, x, E);
      const C = v.refs[E];
      if (C)
        return C;
      let k = m.call(this, v, E);
      if (k === void 0) {
        const A = (_ = v.localRefs) === null || _ === void 0 ? void 0 : _[E], { schemaId: O } = this.opts;
        A && (k = new a({ schema: A, schemaId: O, root: v, baseId: x }));
      }
      if (k !== void 0)
        return v.refs[E] = u.call(this, k);
    }
    to.resolveRef = c;
    function u(v) {
      return (0, r.inlineRef)(v.schema, this.opts.inlineRefs) ? v.schema : v.validate ? v : s.call(this, v);
    }
    function d(v) {
      for (const x of this._compilations)
        if (p(x, v))
          return x;
    }
    to.getCompilingSchema = d;
    function p(v, x) {
      return v.schema === x.schema && v.root === x.root && v.baseId === x.baseId;
    }
    function m(v, x) {
      let E;
      for (; typeof (E = this.refs[x]) == "string"; )
        x = E;
      return E || this.schemas[x] || g.call(this, v, x);
    }
    function g(v, x) {
      const E = this.opts.uriResolver.parse(x), _ = (0, r._getFullPath)(this.opts.uriResolver, E);
      let C = (0, r.getFullPath)(this.opts.uriResolver, v.baseId, void 0);
      if (Object.keys(v.schema).length > 0 && _ === C)
        return b.call(this, E, v);
      const k = (0, r.normalizeId)(_), A = this.refs[k] || this.schemas[k];
      if (typeof A == "string") {
        const O = g.call(this, v, A);
        return typeof O?.schema != "object" ? void 0 : b.call(this, E, O);
      }
      if (typeof A?.schema == "object") {
        if (A.validate || s.call(this, A), k === (0, r.normalizeId)(x)) {
          const { schema: O } = A, { schemaId: P } = this.opts, I = O[P];
          return I && (C = (0, r.resolveUrl)(this.opts.uriResolver, C, I)), new a({ schema: O, schemaId: P, root: v, baseId: C });
        }
        return b.call(this, E, A);
      }
    }
    to.resolveSchema = g;
    const y = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function b(v, { baseId: x, schema: E, root: _ }) {
      var C;
      if (((C = v.fragment) === null || C === void 0 ? void 0 : C[0]) !== "/")
        return;
      for (const O of v.fragment.slice(1).split("/")) {
        if (typeof E == "boolean")
          return;
        const P = E[(0, o.unescapeFragment)(O)];
        if (P === void 0)
          return;
        E = P;
        const I = typeof E == "object" && E[this.opts.schemaId];
        !y.has(O) && I && (x = (0, r.resolveUrl)(this.opts.uriResolver, x, I));
      }
      let k;
      if (typeof E != "boolean" && E.$ref && !(0, o.schemaHasRulesButRef)(E, this.RULES)) {
        const O = (0, r.resolveUrl)(this.opts.uriResolver, x, E.$ref);
        k = g.call(this, _, O);
      }
      const { schemaId: A } = this.opts;
      if (k = k || new a({ schema: E, schemaId: A, root: _, baseId: x }), k.schema !== k.root.schema)
        return k;
    }
    return to;
  }
  const TCe = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", ACe = "Meta-schema for $data reference (JSON AnySchema extension proposal)", RCe = "object", OCe = ["$data"], MCe = { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, NCe = !1, PCe = {
    $id: TCe,
    description: ACe,
    type: RCe,
    required: OCe,
    properties: MCe,
    additionalProperties: NCe
  };
  var Ay = {}, tp = { exports: {} }, $_, QD;
  function ICe() {
    return QD || (QD = 1, $_ = {
      HEX: {
        0: 0,
        1: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        a: 10,
        A: 10,
        b: 11,
        B: 11,
        c: 12,
        C: 12,
        d: 13,
        D: 13,
        e: 14,
        E: 14,
        f: 15,
        F: 15
      }
    }), $_;
  }
  var j_, JD;
  function $Ce() {
    if (JD) return j_;
    JD = 1;
    const { HEX: e } = ICe(), t = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
    function n(b) {
      if (s(b, ".") < 3)
        return { host: b, isIPV4: !1 };
      const v = b.match(t) || [], [x] = v;
      return x ? { host: a(x, "."), isIPV4: !0 } : { host: b, isIPV4: !1 };
    }
    function r(b, v = !1) {
      let x = "", E = !0;
      for (const _ of b) {
        if (e[_] === void 0) return;
        _ !== "0" && E === !0 && (E = !1), E || (x += _);
      }
      return v && x.length === 0 && (x = "0"), x;
    }
    function o(b) {
      let v = 0;
      const x = { error: !1, address: "", zone: "" }, E = [], _ = [];
      let C = !1, k = !1, A = !1;
      function O() {
        if (_.length) {
          if (C === !1) {
            const P = r(_);
            if (P !== void 0)
              E.push(P);
            else
              return x.error = !0, !1;
          }
          _.length = 0;
        }
        return !0;
      }
      for (let P = 0; P < b.length; P++) {
        const I = b[P];
        if (!(I === "[" || I === "]"))
          if (I === ":") {
            if (k === !0 && (A = !0), !O())
              break;
            if (v++, E.push(":"), v > 7) {
              x.error = !0;
              break;
            }
            P - 1 >= 0 && b[P - 1] === ":" && (k = !0);
            continue;
          } else if (I === "%") {
            if (!O())
              break;
            C = !0;
          } else {
            _.push(I);
            continue;
          }
      }
      return _.length && (C ? x.zone = _.join("") : A ? E.push(_.join("")) : E.push(r(_))), x.address = E.join(""), x;
    }
    function i(b) {
      if (s(b, ":") < 2)
        return { host: b, isIPV6: !1 };
      const v = o(b);
      if (v.error)
        return { host: b, isIPV6: !1 };
      {
        let x = v.address, E = v.address;
        return v.zone && (x += "%" + v.zone, E += "%25" + v.zone), { host: x, escapedHost: E, isIPV6: !0 };
      }
    }
    function a(b, v) {
      let x = "", E = !0;
      const _ = b.length;
      for (let C = 0; C < _; C++) {
        const k = b[C];
        k === "0" && E ? (C + 1 <= _ && b[C + 1] === v || C + 1 === _) && (x += k, E = !1) : (k === v ? E = !0 : E = !1, x += k);
      }
      return x;
    }
    function s(b, v) {
      let x = 0;
      for (let E = 0; E < b.length; E++)
        b[E] === v && x++;
      return x;
    }
    const c = /^\.\.?\//u, u = /^\/\.(?:\/|$)/u, d = /^\/\.\.(?:\/|$)/u, p = /^\/?(?:.|\n)*?(?=\/|$)/u;
    function m(b) {
      const v = [];
      for (; b.length; )
        if (b.match(c))
          b = b.replace(c, "");
        else if (b.match(u))
          b = b.replace(u, "/");
        else if (b.match(d))
          b = b.replace(d, "/"), v.pop();
        else if (b === "." || b === "..")
          b = "";
        else {
          const x = b.match(p);
          if (x) {
            const E = x[0];
            b = b.slice(E.length), v.push(E);
          } else
            throw new Error("Unexpected dot segment condition");
        }
      return v.join("");
    }
    function g(b, v) {
      const x = v !== !0 ? escape : unescape;
      return b.scheme !== void 0 && (b.scheme = x(b.scheme)), b.userinfo !== void 0 && (b.userinfo = x(b.userinfo)), b.host !== void 0 && (b.host = x(b.host)), b.path !== void 0 && (b.path = x(b.path)), b.query !== void 0 && (b.query = x(b.query)), b.fragment !== void 0 && (b.fragment = x(b.fragment)), b;
    }
    function y(b) {
      const v = [];
      if (b.userinfo !== void 0 && (v.push(b.userinfo), v.push("@")), b.host !== void 0) {
        let x = unescape(b.host);
        const E = n(x);
        if (E.isIPV4)
          x = E.host;
        else {
          const _ = i(E.host);
          _.isIPV6 === !0 ? x = `[${_.escapedHost}]` : x = b.host;
        }
        v.push(x);
      }
      return (typeof b.port == "number" || typeof b.port == "string") && (v.push(":"), v.push(String(b.port))), v.length ? v.join("") : void 0;
    }
    return j_ = {
      recomposeAuthority: y,
      normalizeComponentEncoding: g,
      removeDotSegments: m,
      normalizeIPv4: n,
      normalizeIPv6: i,
      stringArrayToHexStripped: r
    }, j_;
  }
  var D_, e5;
  function jCe() {
    if (e5) return D_;
    e5 = 1;
    const e = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu, t = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    function n(E) {
      return typeof E.secure == "boolean" ? E.secure : String(E.scheme).toLowerCase() === "wss";
    }
    function r(E) {
      return E.host || (E.error = E.error || "HTTP URIs must have a host."), E;
    }
    function o(E) {
      const _ = String(E.scheme).toLowerCase() === "https";
      return (E.port === (_ ? 443 : 80) || E.port === "") && (E.port = void 0), E.path || (E.path = "/"), E;
    }
    function i(E) {
      return E.secure = n(E), E.resourceName = (E.path || "/") + (E.query ? "?" + E.query : ""), E.path = void 0, E.query = void 0, E;
    }
    function a(E) {
      if ((E.port === (n(E) ? 443 : 80) || E.port === "") && (E.port = void 0), typeof E.secure == "boolean" && (E.scheme = E.secure ? "wss" : "ws", E.secure = void 0), E.resourceName) {
        const [_, C] = E.resourceName.split("?");
        E.path = _ && _ !== "/" ? _ : void 0, E.query = C, E.resourceName = void 0;
      }
      return E.fragment = void 0, E;
    }
    function s(E, _) {
      if (!E.path)
        return E.error = "URN can not be parsed", E;
      const C = E.path.match(t);
      if (C) {
        const k = _.scheme || E.scheme || "urn";
        E.nid = C[1].toLowerCase(), E.nss = C[2];
        const A = `${k}:${_.nid || E.nid}`, O = x[A];
        E.path = void 0, O && (E = O.parse(E, _));
      } else
        E.error = E.error || "URN can not be parsed.";
      return E;
    }
    function c(E, _) {
      const C = _.scheme || E.scheme || "urn", k = E.nid.toLowerCase(), A = `${C}:${_.nid || k}`, O = x[A];
      O && (E = O.serialize(E, _));
      const P = E, I = E.nss;
      return P.path = `${k || _.nid}:${I}`, _.skipEscape = !0, P;
    }
    function u(E, _) {
      const C = E;
      return C.uuid = C.nss, C.nss = void 0, !_.tolerant && (!C.uuid || !e.test(C.uuid)) && (C.error = C.error || "UUID is not valid."), C;
    }
    function d(E) {
      const _ = E;
      return _.nss = (E.uuid || "").toLowerCase(), _;
    }
    const p = {
      scheme: "http",
      domainHost: !0,
      parse: r,
      serialize: o
    }, m = {
      scheme: "https",
      domainHost: p.domainHost,
      parse: r,
      serialize: o
    }, g = {
      scheme: "ws",
      domainHost: !0,
      parse: i,
      serialize: a
    }, y = {
      scheme: "wss",
      domainHost: g.domainHost,
      parse: g.parse,
      serialize: g.serialize
    }, x = {
      http: p,
      https: m,
      ws: g,
      wss: y,
      urn: {
        scheme: "urn",
        parse: s,
        serialize: c,
        skipNormalize: !0
      },
      "urn:uuid": {
        scheme: "urn:uuid",
        parse: u,
        serialize: d,
        skipNormalize: !0
      }
    };
    return D_ = x, D_;
  }
  var t5;
  function DCe() {
    if (t5) return tp.exports;
    t5 = 1;
    const { normalizeIPv6: e, normalizeIPv4: t, removeDotSegments: n, recomposeAuthority: r, normalizeComponentEncoding: o } = $Ce(), i = jCe();
    function a(v, x) {
      return typeof v == "string" ? v = d(y(v, x), x) : typeof v == "object" && (v = y(d(v, x), x)), v;
    }
    function s(v, x, E) {
      const _ = Object.assign({ scheme: "null" }, E), C = c(y(v, _), y(x, _), _, !0);
      return d(C, { ..._, skipEscape: !0 });
    }
    function c(v, x, E, _) {
      const C = {};
      return _ || (v = y(d(v, E), E), x = y(d(x, E), E)), E = E || {}, !E.tolerant && x.scheme ? (C.scheme = x.scheme, C.userinfo = x.userinfo, C.host = x.host, C.port = x.port, C.path = n(x.path || ""), C.query = x.query) : (x.userinfo !== void 0 || x.host !== void 0 || x.port !== void 0 ? (C.userinfo = x.userinfo, C.host = x.host, C.port = x.port, C.path = n(x.path || ""), C.query = x.query) : (x.path ? (x.path.charAt(0) === "/" ? C.path = n(x.path) : ((v.userinfo !== void 0 || v.host !== void 0 || v.port !== void 0) && !v.path ? C.path = "/" + x.path : v.path ? C.path = v.path.slice(0, v.path.lastIndexOf("/") + 1) + x.path : C.path = x.path, C.path = n(C.path)), C.query = x.query) : (C.path = v.path, x.query !== void 0 ? C.query = x.query : C.query = v.query), C.userinfo = v.userinfo, C.host = v.host, C.port = v.port), C.scheme = v.scheme), C.fragment = x.fragment, C;
    }
    function u(v, x, E) {
      return typeof v == "string" ? (v = unescape(v), v = d(o(y(v, E), !0), { ...E, skipEscape: !0 })) : typeof v == "object" && (v = d(o(v, !0), { ...E, skipEscape: !0 })), typeof x == "string" ? (x = unescape(x), x = d(o(y(x, E), !0), { ...E, skipEscape: !0 })) : typeof x == "object" && (x = d(o(x, !0), { ...E, skipEscape: !0 })), v.toLowerCase() === x.toLowerCase();
    }
    function d(v, x) {
      const E = {
        host: v.host,
        scheme: v.scheme,
        userinfo: v.userinfo,
        port: v.port,
        path: v.path,
        query: v.query,
        nid: v.nid,
        nss: v.nss,
        uuid: v.uuid,
        fragment: v.fragment,
        reference: v.reference,
        resourceName: v.resourceName,
        secure: v.secure,
        error: ""
      }, _ = Object.assign({}, x), C = [], k = i[(_.scheme || E.scheme || "").toLowerCase()];
      k && k.serialize && k.serialize(E, _), E.path !== void 0 && (_.skipEscape ? E.path = unescape(E.path) : (E.path = escape(E.path), E.scheme !== void 0 && (E.path = E.path.split("%3A").join(":")))), _.reference !== "suffix" && E.scheme && C.push(E.scheme, ":");
      const A = r(E);
      if (A !== void 0 && (_.reference !== "suffix" && C.push("//"), C.push(A), E.path && E.path.charAt(0) !== "/" && C.push("/")), E.path !== void 0) {
        let O = E.path;
        !_.absolutePath && (!k || !k.absolutePath) && (O = n(O)), A === void 0 && (O = O.replace(/^\/\//u, "/%2F")), C.push(O);
      }
      return E.query !== void 0 && C.push("?", E.query), E.fragment !== void 0 && C.push("#", E.fragment), C.join("");
    }
    const p = Array.from({ length: 127 }, (v, x) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(x)));
    function m(v) {
      let x = 0;
      for (let E = 0, _ = v.length; E < _; ++E)
        if (x = v.charCodeAt(E), x > 126 || p[x])
          return !0;
      return !1;
    }
    const g = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function y(v, x) {
      const E = Object.assign({}, x), _ = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      }, C = v.indexOf("%") !== -1;
      let k = !1;
      E.reference === "suffix" && (v = (E.scheme ? E.scheme + ":" : "") + "//" + v);
      const A = v.match(g);
      if (A) {
        if (_.scheme = A[1], _.userinfo = A[3], _.host = A[4], _.port = parseInt(A[5], 10), _.path = A[6] || "", _.query = A[7], _.fragment = A[8], isNaN(_.port) && (_.port = A[5]), _.host) {
          const P = t(_.host);
          if (P.isIPV4 === !1) {
            const I = e(P.host);
            _.host = I.host.toLowerCase(), k = I.isIPV6;
          } else
            _.host = P.host, k = !0;
        }
        _.scheme === void 0 && _.userinfo === void 0 && _.host === void 0 && _.port === void 0 && _.query === void 0 && !_.path ? _.reference = "same-document" : _.scheme === void 0 ? _.reference = "relative" : _.fragment === void 0 ? _.reference = "absolute" : _.reference = "uri", E.reference && E.reference !== "suffix" && E.reference !== _.reference && (_.error = _.error || "URI is not a " + E.reference + " reference.");
        const O = i[(E.scheme || _.scheme || "").toLowerCase()];
        if (!E.unicodeSupport && (!O || !O.unicodeSupport) && _.host && (E.domainHost || O && O.domainHost) && k === !1 && m(_.host))
          try {
            _.host = URL.domainToASCII(_.host.toLowerCase());
          } catch (P) {
            _.error = _.error || "Host's domain name can not be converted to ASCII: " + P;
          }
        (!O || O && !O.skipNormalize) && (C && _.scheme !== void 0 && (_.scheme = unescape(_.scheme)), C && _.host !== void 0 && (_.host = unescape(_.host)), _.path && (_.path = escape(unescape(_.path))), _.fragment && (_.fragment = encodeURI(decodeURIComponent(_.fragment)))), O && O.parse && O.parse(_, E);
      } else
        _.error = _.error || "URI can not be parsed.";
      return _;
    }
    const b = {
      SCHEMES: i,
      normalize: a,
      resolve: s,
      resolveComponents: c,
      equal: u,
      serialize: d,
      parse: y
    };
    return tp.exports = b, tp.exports.default = b, tp.exports.fastUri = b, tp.exports;
  }
  var n5;
  function FCe() {
    if (n5) return Ay;
    n5 = 1, Object.defineProperty(Ay, "__esModule", { value: !0 });
    const e = DCe();
    return e.code = 'require("ajv/dist/runtime/uri").default', Ay.default = e, Ay;
  }
  var r5;
  function LCe() {
    return r5 || (r5 = 1, (function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.CodeGen = e.Name = e.nil = e.stringify = e.str = e._ = e.KeywordCxt = void 0;
      var t = E1();
      Object.defineProperty(e, "KeywordCxt", { enumerable: !0, get: function() {
        return t.KeywordCxt;
      } });
      var n = vt();
      Object.defineProperty(e, "_", { enumerable: !0, get: function() {
        return n._;
      } }), Object.defineProperty(e, "str", { enumerable: !0, get: function() {
        return n.str;
      } }), Object.defineProperty(e, "stringify", { enumerable: !0, get: function() {
        return n.stringify;
      } }), Object.defineProperty(e, "nil", { enumerable: !0, get: function() {
        return n.nil;
      } }), Object.defineProperty(e, "Name", { enumerable: !0, get: function() {
        return n.Name;
      } }), Object.defineProperty(e, "CodeGen", { enumerable: !0, get: function() {
        return n.CodeGen;
      } });
      const r = TA(), o = C1(), i = xV(), a = AA(), s = vt(), c = _1(), u = B0(), d = Lt(), p = PCe, m = FCe(), g = (B, D) => new RegExp(B, D);
      g.code = "new RegExp";
      const y = ["removeAdditional", "useDefaults", "coerceTypes"], b = /* @__PURE__ */ new Set([
        "validate",
        "serialize",
        "parse",
        "wrapper",
        "root",
        "schema",
        "keyword",
        "pattern",
        "formats",
        "validate$data",
        "func",
        "obj",
        "Error"
      ]), v = {
        errorDataPath: "",
        format: "`validateFormats: false` can be used instead.",
        nullable: '"nullable" keyword is supported by default.',
        jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
        extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
        missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
        processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
        sourceCode: "Use option `code: {source: true}`",
        strictDefaults: "It is default now, see option `strict`.",
        strictKeywords: "It is default now, see option `strict`.",
        uniqueItems: '"uniqueItems" keyword is always validated.',
        unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
        cache: "Map is used as cache, schema object as key.",
        serialize: "Map is used as cache, schema object as key.",
        ajvErrors: "It is default now."
      }, x = {
        ignoreKeywordsWithRef: "",
        jsPropertySyntax: "",
        unicode: '"minLength"/"maxLength" account for unicode characters by default.'
      }, E = 200;
      function _(B) {
        var D, G, z, H, X, Q, ne, te, se, ue, J, ee, ie, le, ge, Se, Me, je, ze, Ye, Ue, Ne, mt, Je, Ae;
        const oe = B.strict, fe = (D = B.code) === null || D === void 0 ? void 0 : D.optimize, _e = fe === !0 || fe === void 0 ? 1 : fe || 0, Ce = (z = (G = B.code) === null || G === void 0 ? void 0 : G.regExp) !== null && z !== void 0 ? z : g, Oe = (H = B.uriResolver) !== null && H !== void 0 ? H : m.default;
        return {
          strictSchema: (Q = (X = B.strictSchema) !== null && X !== void 0 ? X : oe) !== null && Q !== void 0 ? Q : !0,
          strictNumbers: (te = (ne = B.strictNumbers) !== null && ne !== void 0 ? ne : oe) !== null && te !== void 0 ? te : !0,
          strictTypes: (ue = (se = B.strictTypes) !== null && se !== void 0 ? se : oe) !== null && ue !== void 0 ? ue : "log",
          strictTuples: (ee = (J = B.strictTuples) !== null && J !== void 0 ? J : oe) !== null && ee !== void 0 ? ee : "log",
          strictRequired: (le = (ie = B.strictRequired) !== null && ie !== void 0 ? ie : oe) !== null && le !== void 0 ? le : !1,
          code: B.code ? { ...B.code, optimize: _e, regExp: Ce } : { optimize: _e, regExp: Ce },
          loopRequired: (ge = B.loopRequired) !== null && ge !== void 0 ? ge : E,
          loopEnum: (Se = B.loopEnum) !== null && Se !== void 0 ? Se : E,
          meta: (Me = B.meta) !== null && Me !== void 0 ? Me : !0,
          messages: (je = B.messages) !== null && je !== void 0 ? je : !0,
          inlineRefs: (ze = B.inlineRefs) !== null && ze !== void 0 ? ze : !0,
          schemaId: (Ye = B.schemaId) !== null && Ye !== void 0 ? Ye : "$id",
          addUsedSchema: (Ue = B.addUsedSchema) !== null && Ue !== void 0 ? Ue : !0,
          validateSchema: (Ne = B.validateSchema) !== null && Ne !== void 0 ? Ne : !0,
          validateFormats: (mt = B.validateFormats) !== null && mt !== void 0 ? mt : !0,
          unicodeRegExp: (Je = B.unicodeRegExp) !== null && Je !== void 0 ? Je : !0,
          int32range: (Ae = B.int32range) !== null && Ae !== void 0 ? Ae : !0,
          uriResolver: Oe
        };
      }
      class C {
        constructor(D = {}) {
          this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), D = this.opts = { ...D, ..._(D) };
          const { es5: G, lines: z } = this.opts.code;
          this.scope = new s.ValueScope({ scope: {}, prefixes: b, es5: G, lines: z }), this.logger = N(D.logger);
          const H = D.validateFormats;
          D.validateFormats = !1, this.RULES = (0, i.getRules)(), k.call(this, v, D, "NOT SUPPORTED"), k.call(this, x, D, "DEPRECATED", "warn"), this._metaOpts = $.call(this), D.formats && P.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), D.keywords && I.call(this, D.keywords), typeof D.meta == "object" && this.addMetaSchema(D.meta), O.call(this), D.validateFormats = H;
        }
        _addVocabularies() {
          this.addKeyword("$async");
        }
        _addDefaultMetaSchema() {
          const { $data: D, meta: G, schemaId: z } = this.opts;
          let H = p;
          z === "id" && (H = { ...p }, H.id = H.$id, delete H.$id), G && D && this.addMetaSchema(H, H[z], !1);
        }
        defaultMeta() {
          const { meta: D, schemaId: G } = this.opts;
          return this.opts.defaultMeta = typeof D == "object" ? D[G] || D : void 0;
        }
        validate(D, G) {
          let z;
          if (typeof D == "string") {
            if (z = this.getSchema(D), !z)
              throw new Error(`no schema with key or ref "${D}"`);
          } else
            z = this.compile(D);
          const H = z(G);
          return "$async" in z || (this.errors = z.errors), H;
        }
        compile(D, G) {
          const z = this._addSchema(D, G);
          return z.validate || this._compileSchemaEnv(z);
        }
        compileAsync(D, G) {
          if (typeof this.opts.loadSchema != "function")
            throw new Error("options.loadSchema should be a function");
          const { loadSchema: z } = this.opts;
          return H.call(this, D, G);
          async function H(ue, J) {
            await X.call(this, ue.$schema);
            const ee = this._addSchema(ue, J);
            return ee.validate || Q.call(this, ee);
          }
          async function X(ue) {
            ue && !this.getSchema(ue) && await H.call(this, { $ref: ue }, !0);
          }
          async function Q(ue) {
            try {
              return this._compileSchemaEnv(ue);
            } catch (J) {
              if (!(J instanceof o.default))
                throw J;
              return ne.call(this, J), await te.call(this, J.missingSchema), Q.call(this, ue);
            }
          }
          function ne({ missingSchema: ue, missingRef: J }) {
            if (this.refs[ue])
              throw new Error(`AnySchema ${ue} is loaded but ${J} cannot be resolved`);
          }
          async function te(ue) {
            const J = await se.call(this, ue);
            this.refs[ue] || await X.call(this, J.$schema), this.refs[ue] || this.addSchema(J, ue, G);
          }
          async function se(ue) {
            const J = this._loading[ue];
            if (J)
              return J;
            try {
              return await (this._loading[ue] = z(ue));
            } finally {
              delete this._loading[ue];
            }
          }
        }
        // Adds schema to the instance
        addSchema(D, G, z, H = this.opts.validateSchema) {
          if (Array.isArray(D)) {
            for (const Q of D)
              this.addSchema(Q, void 0, z, H);
            return this;
          }
          let X;
          if (typeof D == "object") {
            const { schemaId: Q } = this.opts;
            if (X = D[Q], X !== void 0 && typeof X != "string")
              throw new Error(`schema ${Q} must be string`);
          }
          return G = (0, c.normalizeId)(G || X), this._checkUnique(G), this.schemas[G] = this._addSchema(D, z, G, H, !0), this;
        }
        // Add schema that will be used to validate other schemas
        // options in META_IGNORE_OPTIONS are alway set to false
        addMetaSchema(D, G, z = this.opts.validateSchema) {
          return this.addSchema(D, G, !0, z), this;
        }
        //  Validate schema against its meta-schema
        validateSchema(D, G) {
          if (typeof D == "boolean")
            return !0;
          let z;
          if (z = D.$schema, z !== void 0 && typeof z != "string")
            throw new Error("$schema must be a string");
          if (z = z || this.opts.defaultMeta || this.defaultMeta(), !z)
            return this.logger.warn("meta-schema not available"), this.errors = null, !0;
          const H = this.validate(z, D);
          if (!H && G) {
            const X = "schema is invalid: " + this.errorsText();
            if (this.opts.validateSchema === "log")
              this.logger.error(X);
            else
              throw new Error(X);
          }
          return H;
        }
        // Get compiled schema by `key` or `ref`.
        // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
        getSchema(D) {
          let G;
          for (; typeof (G = A.call(this, D)) == "string"; )
            D = G;
          if (G === void 0) {
            const { schemaId: z } = this.opts, H = new a.SchemaEnv({ schema: {}, schemaId: z });
            if (G = a.resolveSchema.call(this, H, D), !G)
              return;
            this.refs[D] = G;
          }
          return G.validate || this._compileSchemaEnv(G);
        }
        // Remove cached schema(s).
        // If no parameter is passed all schemas but meta-schemas are removed.
        // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
        // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
        removeSchema(D) {
          if (D instanceof RegExp)
            return this._removeAllSchemas(this.schemas, D), this._removeAllSchemas(this.refs, D), this;
          switch (typeof D) {
            case "undefined":
              return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
            case "string": {
              const G = A.call(this, D);
              return typeof G == "object" && this._cache.delete(G.schema), delete this.schemas[D], delete this.refs[D], this;
            }
            case "object": {
              const G = D;
              this._cache.delete(G);
              let z = D[this.opts.schemaId];
              return z && (z = (0, c.normalizeId)(z), delete this.schemas[z], delete this.refs[z]), this;
            }
            default:
              throw new Error("ajv.removeSchema: invalid parameter");
          }
        }
        // add "vocabulary" - a collection of keywords
        addVocabulary(D) {
          for (const G of D)
            this.addKeyword(G);
          return this;
        }
        addKeyword(D, G) {
          let z;
          if (typeof D == "string")
            z = D, typeof G == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), G.keyword = z);
          else if (typeof D == "object" && G === void 0) {
            if (G = D, z = G.keyword, Array.isArray(z) && !z.length)
              throw new Error("addKeywords: keyword must be string or non-empty array");
          } else
            throw new Error("invalid addKeywords parameters");
          if (j.call(this, z, G), !G)
            return (0, d.eachItem)(z, (X) => V.call(this, X)), this;
          K.call(this, G);
          const H = {
            ...G,
            type: (0, u.getJSONTypes)(G.type),
            schemaType: (0, u.getJSONTypes)(G.schemaType)
          };
          return (0, d.eachItem)(z, H.type.length === 0 ? (X) => V.call(this, X, H) : (X) => H.type.forEach((Q) => V.call(this, X, H, Q))), this;
        }
        getKeyword(D) {
          const G = this.RULES.all[D];
          return typeof G == "object" ? G.definition : !!G;
        }
        // Remove keyword
        removeKeyword(D) {
          const { RULES: G } = this;
          delete G.keywords[D], delete G.all[D];
          for (const z of G.rules) {
            const H = z.rules.findIndex((X) => X.keyword === D);
            H >= 0 && z.rules.splice(H, 1);
          }
          return this;
        }
        // Add format
        addFormat(D, G) {
          return typeof G == "string" && (G = new RegExp(G)), this.formats[D] = G, this;
        }
        errorsText(D = this.errors, { separator: G = ", ", dataVar: z = "data" } = {}) {
          return !D || D.length === 0 ? "No errors" : D.map((H) => `${z}${H.instancePath} ${H.message}`).reduce((H, X) => H + G + X);
        }
        $dataMetaSchema(D, G) {
          const z = this.RULES.all;
          D = JSON.parse(JSON.stringify(D));
          for (const H of G) {
            const X = H.split("/").slice(1);
            let Q = D;
            for (const ne of X)
              Q = Q[ne];
            for (const ne in z) {
              const te = z[ne];
              if (typeof te != "object")
                continue;
              const { $data: se } = te.definition, ue = Q[ne];
              se && ue && (Q[ne] = Y(ue));
            }
          }
          return D;
        }
        _removeAllSchemas(D, G) {
          for (const z in D) {
            const H = D[z];
            (!G || G.test(z)) && (typeof H == "string" ? delete D[z] : H && !H.meta && (this._cache.delete(H.schema), delete D[z]));
          }
        }
        _addSchema(D, G, z, H = this.opts.validateSchema, X = this.opts.addUsedSchema) {
          let Q;
          const { schemaId: ne } = this.opts;
          if (typeof D == "object")
            Q = D[ne];
          else {
            if (this.opts.jtd)
              throw new Error("schema must be object");
            if (typeof D != "boolean")
              throw new Error("schema must be object or boolean");
          }
          let te = this._cache.get(D);
          if (te !== void 0)
            return te;
          z = (0, c.normalizeId)(Q || z);
          const se = c.getSchemaRefs.call(this, D, z);
          return te = new a.SchemaEnv({ schema: D, schemaId: ne, meta: G, baseId: z, localRefs: se }), this._cache.set(te.schema, te), X && !z.startsWith("#") && (z && this._checkUnique(z), this.refs[z] = te), H && this.validateSchema(D, !0), te;
        }
        _checkUnique(D) {
          if (this.schemas[D] || this.refs[D])
            throw new Error(`schema with key or id "${D}" already exists`);
        }
        _compileSchemaEnv(D) {
          if (D.meta ? this._compileMetaSchema(D) : a.compileSchema.call(this, D), !D.validate)
            throw new Error("ajv implementation error");
          return D.validate;
        }
        _compileMetaSchema(D) {
          const G = this.opts;
          this.opts = this._metaOpts;
          try {
            a.compileSchema.call(this, D);
          } finally {
            this.opts = G;
          }
        }
      }
      C.ValidationError = r.default, C.MissingRefError = o.default, e.default = C;
      function k(B, D, G, z = "error") {
        for (const H in B) {
          const X = H;
          X in D && this.logger[z](`${G}: option ${H}. ${B[X]}`);
        }
      }
      function A(B) {
        return B = (0, c.normalizeId)(B), this.schemas[B] || this.refs[B];
      }
      function O() {
        const B = this.opts.schemas;
        if (B)
          if (Array.isArray(B))
            this.addSchema(B);
          else
            for (const D in B)
              this.addSchema(B[D], D);
      }
      function P() {
        for (const B in this.opts.formats) {
          const D = this.opts.formats[B];
          D && this.addFormat(B, D);
        }
      }
      function I(B) {
        if (Array.isArray(B)) {
          this.addVocabulary(B);
          return;
        }
        this.logger.warn("keywords option as map is deprecated, pass array");
        for (const D in B) {
          const G = B[D];
          G.keyword || (G.keyword = D), this.addKeyword(G);
        }
      }
      function $() {
        const B = { ...this.opts };
        for (const D of y)
          delete B[D];
        return B;
      }
      const L = { log() {
      }, warn() {
      }, error() {
      } };
      function N(B) {
        if (B === !1)
          return L;
        if (B === void 0)
          return console;
        if (B.log && B.warn && B.error)
          return B;
        throw new Error("logger must implement log, warn and error methods");
      }
      const U = /^[a-z_$][a-z0-9_$:-]*$/i;
      function j(B, D) {
        const { RULES: G } = this;
        if ((0, d.eachItem)(B, (z) => {
          if (G.keywords[z])
            throw new Error(`Keyword ${z} is already defined`);
          if (!U.test(z))
            throw new Error(`Keyword ${z} has invalid name`);
        }), !!D && D.$data && !("code" in D || "validate" in D))
          throw new Error('$data keyword must have "code" or "validate" function');
      }
      function V(B, D, G) {
        var z;
        const H = D?.post;
        if (G && H)
          throw new Error('keyword with "post" flag cannot have "type"');
        const { RULES: X } = this;
        let Q = H ? X.post : X.rules.find(({ type: te }) => te === G);
        if (Q || (Q = { type: G, rules: [] }, X.rules.push(Q)), X.keywords[B] = !0, !D)
          return;
        const ne = {
          keyword: B,
          definition: {
            ...D,
            type: (0, u.getJSONTypes)(D.type),
            schemaType: (0, u.getJSONTypes)(D.schemaType)
          }
        };
        D.before ? F.call(this, Q, ne, D.before) : Q.rules.push(ne), X.all[B] = ne, (z = D.implements) === null || z === void 0 || z.forEach((te) => this.addKeyword(te));
      }
      function F(B, D, G) {
        const z = B.rules.findIndex((H) => H.keyword === G);
        z >= 0 ? B.rules.splice(z, 0, D) : (B.rules.push(D), this.logger.warn(`rule ${G} is not defined`));
      }
      function K(B) {
        let { metaSchema: D } = B;
        D !== void 0 && (B.$data && this.opts.$data && (D = Y(D)), B.validateSchema = this.compile(D, !0));
      }
      const W = {
        $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
      };
      function Y(B) {
        return { anyOf: [B, W] };
      }
    })(A_)), A_;
  }
  var Ry = {}, Oy = {}, My = {}, o5;
  function zCe() {
    if (o5) return My;
    o5 = 1, Object.defineProperty(My, "__esModule", { value: !0 });
    const e = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    return My.default = e, My;
  }
  var Fs = {}, i5;
  function BCe() {
    if (i5) return Fs;
    i5 = 1, Object.defineProperty(Fs, "__esModule", { value: !0 }), Fs.callRef = Fs.getValidate = void 0;
    const e = C1(), t = ci(), n = vt(), r = gl(), o = AA(), i = Lt(), a = {
      keyword: "$ref",
      schemaType: "string",
      code(u) {
        const { gen: d, schema: p, it: m } = u, { baseId: g, schemaEnv: y, validateName: b, opts: v, self: x } = m, { root: E } = y;
        if ((p === "#" || p === "#/") && g === E.baseId)
          return C();
        const _ = o.resolveRef.call(x, E, g, p);
        if (_ === void 0)
          throw new e.default(m.opts.uriResolver, g, p);
        if (_ instanceof o.SchemaEnv)
          return k(_);
        return A(_);
        function C() {
          if (y === E)
            return c(u, b, y, y.$async);
          const O = d.scopeValue("root", { ref: E });
          return c(u, (0, n._)`${O}.validate`, E, E.$async);
        }
        function k(O) {
          const P = s(u, O);
          c(u, P, O, O.$async);
        }
        function A(O) {
          const P = d.scopeValue("schema", v.code.source === !0 ? { ref: O, code: (0, n.stringify)(O) } : { ref: O }), I = d.name("valid"), $ = u.subschema({
            schema: O,
            dataTypes: [],
            schemaPath: n.nil,
            topSchemaRef: P,
            errSchemaPath: p
          }, I);
          u.mergeEvaluated($), u.ok(I);
        }
      }
    };
    function s(u, d) {
      const { gen: p } = u;
      return d.validate ? p.scopeValue("validate", { ref: d.validate }) : (0, n._)`${p.scopeValue("wrapper", { ref: d })}.validate`;
    }
    Fs.getValidate = s;
    function c(u, d, p, m) {
      const { gen: g, it: y } = u, { allErrors: b, schemaEnv: v, opts: x } = y, E = x.passContext ? r.default.this : n.nil;
      m ? _() : C();
      function _() {
        if (!v.$async)
          throw new Error("async schema referenced by sync schema");
        const O = g.let("valid");
        g.try(() => {
          g.code((0, n._)`await ${(0, t.callValidateCode)(u, d, E)}`), A(d), b || g.assign(O, !0);
        }, (P) => {
          g.if((0, n._)`!(${P} instanceof ${y.ValidationError})`, () => g.throw(P)), k(P), b || g.assign(O, !1);
        }), u.ok(O);
      }
      function C() {
        u.result((0, t.callValidateCode)(u, d, E), () => A(d), () => k(d));
      }
      function k(O) {
        const P = (0, n._)`${O}.errors`;
        g.assign(r.default.vErrors, (0, n._)`${r.default.vErrors} === null ? ${P} : ${r.default.vErrors}.concat(${P})`), g.assign(r.default.errors, (0, n._)`${r.default.vErrors}.length`);
      }
      function A(O) {
        var P;
        if (!y.opts.unevaluated)
          return;
        const I = (P = p?.validate) === null || P === void 0 ? void 0 : P.evaluated;
        if (y.props !== !0)
          if (I && !I.dynamicProps)
            I.props !== void 0 && (y.props = i.mergeEvaluated.props(g, I.props, y.props));
          else {
            const $ = g.var("props", (0, n._)`${O}.evaluated.props`);
            y.props = i.mergeEvaluated.props(g, $, y.props, n.Name);
          }
        if (y.items !== !0)
          if (I && !I.dynamicItems)
            I.items !== void 0 && (y.items = i.mergeEvaluated.items(g, I.items, y.items));
          else {
            const $ = g.var("items", (0, n._)`${O}.evaluated.items`);
            y.items = i.mergeEvaluated.items(g, $, y.items, n.Name);
          }
      }
    }
    return Fs.callRef = c, Fs.default = a, Fs;
  }
  var a5;
  function UCe() {
    if (a5) return Oy;
    a5 = 1, Object.defineProperty(Oy, "__esModule", { value: !0 });
    const e = zCe(), t = BCe(), n = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      e.default,
      t.default
    ];
    return Oy.default = n, Oy;
  }
  var Ny = {}, Py = {}, s5;
  function VCe() {
    if (s5) return Py;
    s5 = 1, Object.defineProperty(Py, "__esModule", { value: !0 });
    const e = vt(), t = e.operators, n = {
      maximum: { okStr: "<=", ok: t.LTE, fail: t.GT },
      minimum: { okStr: ">=", ok: t.GTE, fail: t.LT },
      exclusiveMaximum: { okStr: "<", ok: t.LT, fail: t.GTE },
      exclusiveMinimum: { okStr: ">", ok: t.GT, fail: t.LTE }
    }, r = {
      message: ({ keyword: i, schemaCode: a }) => (0, e.str)`must be ${n[i].okStr} ${a}`,
      params: ({ keyword: i, schemaCode: a }) => (0, e._)`{comparison: ${n[i].okStr}, limit: ${a}}`
    }, o = {
      keyword: Object.keys(n),
      type: "number",
      schemaType: "number",
      $data: !0,
      error: r,
      code(i) {
        const { keyword: a, data: s, schemaCode: c } = i;
        i.fail$data((0, e._)`${s} ${n[a].fail} ${c} || isNaN(${s})`);
      }
    };
    return Py.default = o, Py;
  }
  var Iy = {}, l5;
  function HCe() {
    if (l5) return Iy;
    l5 = 1, Object.defineProperty(Iy, "__esModule", { value: !0 });
    const e = vt(), n = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: !0,
      error: {
        message: ({ schemaCode: r }) => (0, e.str)`must be multiple of ${r}`,
        params: ({ schemaCode: r }) => (0, e._)`{multipleOf: ${r}}`
      },
      code(r) {
        const { gen: o, data: i, schemaCode: a, it: s } = r, c = s.opts.multipleOfPrecision, u = o.let("res"), d = c ? (0, e._)`Math.abs(Math.round(${u}) - ${u}) > 1e-${c}` : (0, e._)`${u} !== parseInt(${u})`;
        r.fail$data((0, e._)`(${a} === 0 || (${u} = ${i}/${a}, ${d}))`);
      }
    };
    return Iy.default = n, Iy;
  }
  var $y = {}, jy = {}, c5;
  function qCe() {
    if (c5) return jy;
    c5 = 1, Object.defineProperty(jy, "__esModule", { value: !0 });
    function e(t) {
      const n = t.length;
      let r = 0, o = 0, i;
      for (; o < n; )
        r++, i = t.charCodeAt(o++), i >= 55296 && i <= 56319 && o < n && (i = t.charCodeAt(o), (i & 64512) === 56320 && o++);
      return r;
    }
    return jy.default = e, e.code = 'require("ajv/dist/runtime/ucs2length").default', jy;
  }
  var u5;
  function WCe() {
    if (u5) return $y;
    u5 = 1, Object.defineProperty($y, "__esModule", { value: !0 });
    const e = vt(), t = Lt(), n = qCe(), o = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: !0,
      error: {
        message({ keyword: i, schemaCode: a }) {
          const s = i === "maxLength" ? "more" : "fewer";
          return (0, e.str)`must NOT have ${s} than ${a} characters`;
        },
        params: ({ schemaCode: i }) => (0, e._)`{limit: ${i}}`
      },
      code(i) {
        const { keyword: a, data: s, schemaCode: c, it: u } = i, d = a === "maxLength" ? e.operators.GT : e.operators.LT, p = u.opts.unicode === !1 ? (0, e._)`${s}.length` : (0, e._)`${(0, t.useFunc)(i.gen, n.default)}(${s})`;
        i.fail$data((0, e._)`${p} ${d} ${c}`);
      }
    };
    return $y.default = o, $y;
  }
  var Dy = {}, f5;
  function GCe() {
    if (f5) return Dy;
    f5 = 1, Object.defineProperty(Dy, "__esModule", { value: !0 });
    const e = ci(), t = vt(), r = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: !0,
      error: {
        message: ({ schemaCode: o }) => (0, t.str)`must match pattern "${o}"`,
        params: ({ schemaCode: o }) => (0, t._)`{pattern: ${o}}`
      },
      code(o) {
        const { data: i, $data: a, schema: s, schemaCode: c, it: u } = o, d = u.opts.unicodeRegExp ? "u" : "", p = a ? (0, t._)`(new RegExp(${c}, ${d}))` : (0, e.usePattern)(o, s);
        o.fail$data((0, t._)`!${p}.test(${i})`);
      }
    };
    return Dy.default = r, Dy;
  }
  var Fy = {}, d5;
  function KCe() {
    if (d5) return Fy;
    d5 = 1, Object.defineProperty(Fy, "__esModule", { value: !0 });
    const e = vt(), n = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: !0,
      error: {
        message({ keyword: r, schemaCode: o }) {
          const i = r === "maxProperties" ? "more" : "fewer";
          return (0, e.str)`must NOT have ${i} than ${o} properties`;
        },
        params: ({ schemaCode: r }) => (0, e._)`{limit: ${r}}`
      },
      code(r) {
        const { keyword: o, data: i, schemaCode: a } = r, s = o === "maxProperties" ? e.operators.GT : e.operators.LT;
        r.fail$data((0, e._)`Object.keys(${i}).length ${s} ${a}`);
      }
    };
    return Fy.default = n, Fy;
  }
  var Ly = {}, p5;
  function YCe() {
    if (p5) return Ly;
    p5 = 1, Object.defineProperty(Ly, "__esModule", { value: !0 });
    const e = ci(), t = vt(), n = Lt(), o = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: !0,
      error: {
        message: ({ params: { missingProperty: i } }) => (0, t.str)`must have required property '${i}'`,
        params: ({ params: { missingProperty: i } }) => (0, t._)`{missingProperty: ${i}}`
      },
      code(i) {
        const { gen: a, schema: s, schemaCode: c, data: u, $data: d, it: p } = i, { opts: m } = p;
        if (!d && s.length === 0)
          return;
        const g = s.length >= m.loopRequired;
        if (p.allErrors ? y() : b(), m.strictRequired) {
          const E = i.parentSchema.properties, { definedProperties: _ } = i.it;
          for (const C of s)
            if (E?.[C] === void 0 && !_.has(C)) {
              const k = p.schemaEnv.baseId + p.errSchemaPath, A = `required property "${C}" is not defined at "${k}" (strictRequired)`;
              (0, n.checkStrictMode)(p, A, p.opts.strictRequired);
            }
        }
        function y() {
          if (g || d)
            i.block$data(t.nil, v);
          else
            for (const E of s)
              (0, e.checkReportMissingProp)(i, E);
        }
        function b() {
          const E = a.let("missing");
          if (g || d) {
            const _ = a.let("valid", !0);
            i.block$data(_, () => x(E, _)), i.ok(_);
          } else
            a.if((0, e.checkMissingProp)(i, s, E)), (0, e.reportMissingProp)(i, E), a.else();
        }
        function v() {
          a.forOf("prop", c, (E) => {
            i.setParams({ missingProperty: E }), a.if((0, e.noPropertyInData)(a, u, E, m.ownProperties), () => i.error());
          });
        }
        function x(E, _) {
          i.setParams({ missingProperty: E }), a.forOf(E, c, () => {
            a.assign(_, (0, e.propertyInData)(a, u, E, m.ownProperties)), a.if((0, t.not)(_), () => {
              i.error(), a.break();
            });
          }, t.nil);
        }
      }
    };
    return Ly.default = o, Ly;
  }
  var zy = {}, h5;
  function XCe() {
    if (h5) return zy;
    h5 = 1, Object.defineProperty(zy, "__esModule", { value: !0 });
    const e = vt(), n = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: !0,
      error: {
        message({ keyword: r, schemaCode: o }) {
          const i = r === "maxItems" ? "more" : "fewer";
          return (0, e.str)`must NOT have ${i} than ${o} items`;
        },
        params: ({ schemaCode: r }) => (0, e._)`{limit: ${r}}`
      },
      code(r) {
        const { keyword: o, data: i, schemaCode: a } = r, s = o === "maxItems" ? e.operators.GT : e.operators.LT;
        r.fail$data((0, e._)`${i}.length ${s} ${a}`);
      }
    };
    return zy.default = n, zy;
  }
  var By = {}, Uy = {}, m5;
  function RA() {
    if (m5) return Uy;
    m5 = 1, Object.defineProperty(Uy, "__esModule", { value: !0 });
    const e = SV();
    return e.code = 'require("ajv/dist/runtime/equal").default', Uy.default = e, Uy;
  }
  var g5;
  function ZCe() {
    if (g5) return By;
    g5 = 1, Object.defineProperty(By, "__esModule", { value: !0 });
    const e = B0(), t = vt(), n = Lt(), r = RA(), i = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: !0,
      error: {
        message: ({ params: { i: a, j: s } }) => (0, t.str)`must NOT have duplicate items (items ## ${s} and ${a} are identical)`,
        params: ({ params: { i: a, j: s } }) => (0, t._)`{i: ${a}, j: ${s}}`
      },
      code(a) {
        const { gen: s, data: c, $data: u, schema: d, parentSchema: p, schemaCode: m, it: g } = a;
        if (!u && !d)
          return;
        const y = s.let("valid"), b = p.items ? (0, e.getSchemaTypes)(p.items) : [];
        a.block$data(y, v, (0, t._)`${m} === false`), a.ok(y);
        function v() {
          const C = s.let("i", (0, t._)`${c}.length`), k = s.let("j");
          a.setParams({ i: C, j: k }), s.assign(y, !0), s.if((0, t._)`${C} > 1`, () => (x() ? E : _)(C, k));
        }
        function x() {
          return b.length > 0 && !b.some((C) => C === "object" || C === "array");
        }
        function E(C, k) {
          const A = s.name("item"), O = (0, e.checkDataTypes)(b, A, g.opts.strictNumbers, e.DataType.Wrong), P = s.const("indices", (0, t._)`{}`);
          s.for((0, t._)`;${C}--;`, () => {
            s.let(A, (0, t._)`${c}[${C}]`), s.if(O, (0, t._)`continue`), b.length > 1 && s.if((0, t._)`typeof ${A} == "string"`, (0, t._)`${A} += "_"`), s.if((0, t._)`typeof ${P}[${A}] == "number"`, () => {
              s.assign(k, (0, t._)`${P}[${A}]`), a.error(), s.assign(y, !1).break();
            }).code((0, t._)`${P}[${A}] = ${C}`);
          });
        }
        function _(C, k) {
          const A = (0, n.useFunc)(s, r.default), O = s.name("outer");
          s.label(O).for((0, t._)`;${C}--;`, () => s.for((0, t._)`${k} = ${C}; ${k}--;`, () => s.if((0, t._)`${A}(${c}[${C}], ${c}[${k}])`, () => {
            a.error(), s.assign(y, !1).break(O);
          })));
        }
      }
    };
    return By.default = i, By;
  }
  var Vy = {}, y5;
  function QCe() {
    if (y5) return Vy;
    y5 = 1, Object.defineProperty(Vy, "__esModule", { value: !0 });
    const e = vt(), t = Lt(), n = RA(), o = {
      keyword: "const",
      $data: !0,
      error: {
        message: "must be equal to constant",
        params: ({ schemaCode: i }) => (0, e._)`{allowedValue: ${i}}`
      },
      code(i) {
        const { gen: a, data: s, $data: c, schemaCode: u, schema: d } = i;
        c || d && typeof d == "object" ? i.fail$data((0, e._)`!${(0, t.useFunc)(a, n.default)}(${s}, ${u})`) : i.fail((0, e._)`${d} !== ${s}`);
      }
    };
    return Vy.default = o, Vy;
  }
  var Hy = {}, v5;
  function JCe() {
    if (v5) return Hy;
    v5 = 1, Object.defineProperty(Hy, "__esModule", { value: !0 });
    const e = vt(), t = Lt(), n = RA(), o = {
      keyword: "enum",
      schemaType: "array",
      $data: !0,
      error: {
        message: "must be equal to one of the allowed values",
        params: ({ schemaCode: i }) => (0, e._)`{allowedValues: ${i}}`
      },
      code(i) {
        const { gen: a, data: s, $data: c, schema: u, schemaCode: d, it: p } = i;
        if (!c && u.length === 0)
          throw new Error("enum must have non-empty array");
        const m = u.length >= p.opts.loopEnum;
        let g;
        const y = () => g ?? (g = (0, t.useFunc)(a, n.default));
        let b;
        if (m || c)
          b = a.let("valid"), i.block$data(b, v);
        else {
          if (!Array.isArray(u))
            throw new Error("ajv implementation error");
          const E = a.const("vSchema", d);
          b = (0, e.or)(...u.map((_, C) => x(E, C)));
        }
        i.pass(b);
        function v() {
          a.assign(b, !1), a.forOf("v", d, (E) => a.if((0, e._)`${y()}(${s}, ${E})`, () => a.assign(b, !0).break()));
        }
        function x(E, _) {
          const C = u[_];
          return typeof C == "object" && C !== null ? (0, e._)`${y()}(${s}, ${E}[${_}])` : (0, e._)`${s} === ${C}`;
        }
      }
    };
    return Hy.default = o, Hy;
  }
  var b5;
  function eke() {
    if (b5) return Ny;
    b5 = 1, Object.defineProperty(Ny, "__esModule", { value: !0 });
    const e = VCe(), t = HCe(), n = WCe(), r = GCe(), o = KCe(), i = YCe(), a = XCe(), s = ZCe(), c = QCe(), u = JCe(), d = [
      // number
      e.default,
      t.default,
      // string
      n.default,
      r.default,
      // object
      o.default,
      i.default,
      // array
      a.default,
      s.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      c.default,
      u.default
    ];
    return Ny.default = d, Ny;
  }
  var qy = {}, Iu = {}, x5;
  function _V() {
    if (x5) return Iu;
    x5 = 1, Object.defineProperty(Iu, "__esModule", { value: !0 }), Iu.validateAdditionalItems = void 0;
    const e = vt(), t = Lt(), r = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error: {
        message: ({ params: { len: i } }) => (0, e.str)`must NOT have more than ${i} items`,
        params: ({ params: { len: i } }) => (0, e._)`{limit: ${i}}`
      },
      code(i) {
        const { parentSchema: a, it: s } = i, { items: c } = a;
        if (!Array.isArray(c)) {
          (0, t.checkStrictMode)(s, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        o(i, c);
      }
    };
    function o(i, a) {
      const { gen: s, schema: c, data: u, keyword: d, it: p } = i;
      p.items = !0;
      const m = s.const("len", (0, e._)`${u}.length`);
      if (c === !1)
        i.setParams({ len: a.length }), i.pass((0, e._)`${m} <= ${a.length}`);
      else if (typeof c == "object" && !(0, t.alwaysValidSchema)(p, c)) {
        const y = s.var("valid", (0, e._)`${m} <= ${a.length}`);
        s.if((0, e.not)(y), () => g(y)), i.ok(y);
      }
      function g(y) {
        s.forRange("i", a.length, m, (b) => {
          i.subschema({ keyword: d, dataProp: b, dataPropType: t.Type.Num }, y), p.allErrors || s.if((0, e.not)(y), () => s.break());
        });
      }
    }
    return Iu.validateAdditionalItems = o, Iu.default = r, Iu;
  }
  var Wy = {}, $u = {}, w5;
  function EV() {
    if (w5) return $u;
    w5 = 1, Object.defineProperty($u, "__esModule", { value: !0 }), $u.validateTuple = void 0;
    const e = vt(), t = Lt(), n = ci(), r = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(i) {
        const { schema: a, it: s } = i;
        if (Array.isArray(a))
          return o(i, "additionalItems", a);
        s.items = !0, !(0, t.alwaysValidSchema)(s, a) && i.ok((0, n.validateArray)(i));
      }
    };
    function o(i, a, s = i.schema) {
      const { gen: c, parentSchema: u, data: d, keyword: p, it: m } = i;
      b(u), m.opts.unevaluated && s.length && m.items !== !0 && (m.items = t.mergeEvaluated.items(c, s.length, m.items));
      const g = c.name("valid"), y = c.const("len", (0, e._)`${d}.length`);
      s.forEach((v, x) => {
        (0, t.alwaysValidSchema)(m, v) || (c.if((0, e._)`${y} > ${x}`, () => i.subschema({
          keyword: p,
          schemaProp: x,
          dataProp: x
        }, g)), i.ok(g));
      });
      function b(v) {
        const { opts: x, errSchemaPath: E } = m, _ = s.length, C = _ === v.minItems && (_ === v.maxItems || v[a] === !1);
        if (x.strictTuples && !C) {
          const k = `"${p}" is ${_}-tuple, but minItems or maxItems/${a} are not specified or different at path "${E}"`;
          (0, t.checkStrictMode)(m, k, x.strictTuples);
        }
      }
    }
    return $u.validateTuple = o, $u.default = r, $u;
  }
  var S5;
  function tke() {
    if (S5) return Wy;
    S5 = 1, Object.defineProperty(Wy, "__esModule", { value: !0 });
    const e = EV(), t = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (n) => (0, e.validateTuple)(n, "items")
    };
    return Wy.default = t, Wy;
  }
  var Gy = {}, _5;
  function nke() {
    if (_5) return Gy;
    _5 = 1, Object.defineProperty(Gy, "__esModule", { value: !0 });
    const e = vt(), t = Lt(), n = ci(), r = _V(), i = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error: {
        message: ({ params: { len: a } }) => (0, e.str)`must NOT have more than ${a} items`,
        params: ({ params: { len: a } }) => (0, e._)`{limit: ${a}}`
      },
      code(a) {
        const { schema: s, parentSchema: c, it: u } = a, { prefixItems: d } = c;
        u.items = !0, !(0, t.alwaysValidSchema)(u, s) && (d ? (0, r.validateAdditionalItems)(a, d) : a.ok((0, n.validateArray)(a)));
      }
    };
    return Gy.default = i, Gy;
  }
  var Ky = {}, E5;
  function rke() {
    if (E5) return Ky;
    E5 = 1, Object.defineProperty(Ky, "__esModule", { value: !0 });
    const e = vt(), t = Lt(), r = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: !0,
      error: {
        message: ({ params: { min: o, max: i } }) => i === void 0 ? (0, e.str)`must contain at least ${o} valid item(s)` : (0, e.str)`must contain at least ${o} and no more than ${i} valid item(s)`,
        params: ({ params: { min: o, max: i } }) => i === void 0 ? (0, e._)`{minContains: ${o}}` : (0, e._)`{minContains: ${o}, maxContains: ${i}}`
      },
      code(o) {
        const { gen: i, schema: a, parentSchema: s, data: c, it: u } = o;
        let d, p;
        const { minContains: m, maxContains: g } = s;
        u.opts.next ? (d = m === void 0 ? 1 : m, p = g) : d = 1;
        const y = i.const("len", (0, e._)`${c}.length`);
        if (o.setParams({ min: d, max: p }), p === void 0 && d === 0) {
          (0, t.checkStrictMode)(u, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
          return;
        }
        if (p !== void 0 && d > p) {
          (0, t.checkStrictMode)(u, '"minContains" > "maxContains" is always invalid'), o.fail();
          return;
        }
        if ((0, t.alwaysValidSchema)(u, a)) {
          let _ = (0, e._)`${y} >= ${d}`;
          p !== void 0 && (_ = (0, e._)`${_} && ${y} <= ${p}`), o.pass(_);
          return;
        }
        u.items = !0;
        const b = i.name("valid");
        p === void 0 && d === 1 ? x(b, () => i.if(b, () => i.break())) : d === 0 ? (i.let(b, !0), p !== void 0 && i.if((0, e._)`${c}.length > 0`, v)) : (i.let(b, !1), v()), o.result(b, () => o.reset());
        function v() {
          const _ = i.name("_valid"), C = i.let("count", 0);
          x(_, () => i.if(_, () => E(C)));
        }
        function x(_, C) {
          i.forRange("i", 0, y, (k) => {
            o.subschema({
              keyword: "contains",
              dataProp: k,
              dataPropType: t.Type.Num,
              compositeRule: !0
            }, _), C();
          });
        }
        function E(_) {
          i.code((0, e._)`${_}++`), p === void 0 ? i.if((0, e._)`${_} >= ${d}`, () => i.assign(b, !0).break()) : (i.if((0, e._)`${_} > ${p}`, () => i.assign(b, !1).break()), d === 1 ? i.assign(b, !0) : i.if((0, e._)`${_} >= ${d}`, () => i.assign(b, !0)));
        }
      }
    };
    return Ky.default = r, Ky;
  }
  var F_ = {}, C5;
  function oke() {
    return C5 || (C5 = 1, (function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.validateSchemaDeps = e.validatePropertyDeps = e.error = void 0;
      const t = vt(), n = Lt(), r = ci();
      e.error = {
        message: ({ params: { property: c, depsCount: u, deps: d } }) => {
          const p = u === 1 ? "property" : "properties";
          return (0, t.str)`must have ${p} ${d} when property ${c} is present`;
        },
        params: ({ params: { property: c, depsCount: u, deps: d, missingProperty: p } }) => (0, t._)`{property: ${c},
    missingProperty: ${p},
    depsCount: ${u},
    deps: ${d}}`
        // TODO change to reference
      };
      const o = {
        keyword: "dependencies",
        type: "object",
        schemaType: "object",
        error: e.error,
        code(c) {
          const [u, d] = i(c);
          a(c, u), s(c, d);
        }
      };
      function i({ schema: c }) {
        const u = {}, d = {};
        for (const p in c) {
          if (p === "__proto__")
            continue;
          const m = Array.isArray(c[p]) ? u : d;
          m[p] = c[p];
        }
        return [u, d];
      }
      function a(c, u = c.schema) {
        const { gen: d, data: p, it: m } = c;
        if (Object.keys(u).length === 0)
          return;
        const g = d.let("missing");
        for (const y in u) {
          const b = u[y];
          if (b.length === 0)
            continue;
          const v = (0, r.propertyInData)(d, p, y, m.opts.ownProperties);
          c.setParams({
            property: y,
            depsCount: b.length,
            deps: b.join(", ")
          }), m.allErrors ? d.if(v, () => {
            for (const x of b)
              (0, r.checkReportMissingProp)(c, x);
          }) : (d.if((0, t._)`${v} && (${(0, r.checkMissingProp)(c, b, g)})`), (0, r.reportMissingProp)(c, g), d.else());
        }
      }
      e.validatePropertyDeps = a;
      function s(c, u = c.schema) {
        const { gen: d, data: p, keyword: m, it: g } = c, y = d.name("valid");
        for (const b in u)
          (0, n.alwaysValidSchema)(g, u[b]) || (d.if(
            (0, r.propertyInData)(d, p, b, g.opts.ownProperties),
            () => {
              const v = c.subschema({ keyword: m, schemaProp: b }, y);
              c.mergeValidEvaluated(v, y);
            },
            () => d.var(y, !0)
            // TODO var
          ), c.ok(y));
      }
      e.validateSchemaDeps = s, e.default = o;
    })(F_)), F_;
  }
  var Yy = {}, k5;
  function ike() {
    if (k5) return Yy;
    k5 = 1, Object.defineProperty(Yy, "__esModule", { value: !0 });
    const e = vt(), t = Lt(), r = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error: {
        message: "property name must be valid",
        params: ({ params: o }) => (0, e._)`{propertyName: ${o.propertyName}}`
      },
      code(o) {
        const { gen: i, schema: a, data: s, it: c } = o;
        if ((0, t.alwaysValidSchema)(c, a))
          return;
        const u = i.name("valid");
        i.forIn("key", s, (d) => {
          o.setParams({ propertyName: d }), o.subschema({
            keyword: "propertyNames",
            data: d,
            dataTypes: ["string"],
            propertyName: d,
            compositeRule: !0
          }, u), i.if((0, e.not)(u), () => {
            o.error(!0), c.allErrors || i.break();
          });
        }), o.ok(u);
      }
    };
    return Yy.default = r, Yy;
  }
  var Xy = {}, T5;
  function CV() {
    if (T5) return Xy;
    T5 = 1, Object.defineProperty(Xy, "__esModule", { value: !0 });
    const e = ci(), t = vt(), n = gl(), r = Lt(), i = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: !0,
      trackErrors: !0,
      error: {
        message: "must NOT have additional properties",
        params: ({ params: a }) => (0, t._)`{additionalProperty: ${a.additionalProperty}}`
      },
      code(a) {
        const { gen: s, schema: c, parentSchema: u, data: d, errsCount: p, it: m } = a;
        if (!p)
          throw new Error("ajv implementation error");
        const { allErrors: g, opts: y } = m;
        if (m.props = !0, y.removeAdditional !== "all" && (0, r.alwaysValidSchema)(m, c))
          return;
        const b = (0, e.allSchemaProperties)(u.properties), v = (0, e.allSchemaProperties)(u.patternProperties);
        x(), a.ok((0, t._)`${p} === ${n.default.errors}`);
        function x() {
          s.forIn("key", d, (A) => {
            !b.length && !v.length ? C(A) : s.if(E(A), () => C(A));
          });
        }
        function E(A) {
          let O;
          if (b.length > 8) {
            const P = (0, r.schemaRefOrVal)(m, u.properties, "properties");
            O = (0, e.isOwnProperty)(s, P, A);
          } else b.length ? O = (0, t.or)(...b.map((P) => (0, t._)`${A} === ${P}`)) : O = t.nil;
          return v.length && (O = (0, t.or)(O, ...v.map((P) => (0, t._)`${(0, e.usePattern)(a, P)}.test(${A})`))), (0, t.not)(O);
        }
        function _(A) {
          s.code((0, t._)`delete ${d}[${A}]`);
        }
        function C(A) {
          if (y.removeAdditional === "all" || y.removeAdditional && c === !1) {
            _(A);
            return;
          }
          if (c === !1) {
            a.setParams({ additionalProperty: A }), a.error(), g || s.break();
            return;
          }
          if (typeof c == "object" && !(0, r.alwaysValidSchema)(m, c)) {
            const O = s.name("valid");
            y.removeAdditional === "failing" ? (k(A, O, !1), s.if((0, t.not)(O), () => {
              a.reset(), _(A);
            })) : (k(A, O), g || s.if((0, t.not)(O), () => s.break()));
          }
        }
        function k(A, O, P) {
          const I = {
            keyword: "additionalProperties",
            dataProp: A,
            dataPropType: r.Type.Str
          };
          P === !1 && Object.assign(I, {
            compositeRule: !0,
            createErrors: !1,
            allErrors: !1
          }), a.subschema(I, O);
        }
      }
    };
    return Xy.default = i, Xy;
  }
  var Zy = {}, A5;
  function ake() {
    if (A5) return Zy;
    A5 = 1, Object.defineProperty(Zy, "__esModule", { value: !0 });
    const e = E1(), t = ci(), n = Lt(), r = CV(), o = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(i) {
        const { gen: a, schema: s, parentSchema: c, data: u, it: d } = i;
        d.opts.removeAdditional === "all" && c.additionalProperties === void 0 && r.default.code(new e.KeywordCxt(d, r.default, "additionalProperties"));
        const p = (0, t.allSchemaProperties)(s);
        for (const v of p)
          d.definedProperties.add(v);
        d.opts.unevaluated && p.length && d.props !== !0 && (d.props = n.mergeEvaluated.props(a, (0, n.toHash)(p), d.props));
        const m = p.filter((v) => !(0, n.alwaysValidSchema)(d, s[v]));
        if (m.length === 0)
          return;
        const g = a.name("valid");
        for (const v of m)
          y(v) ? b(v) : (a.if((0, t.propertyInData)(a, u, v, d.opts.ownProperties)), b(v), d.allErrors || a.else().var(g, !0), a.endIf()), i.it.definedProperties.add(v), i.ok(g);
        function y(v) {
          return d.opts.useDefaults && !d.compositeRule && s[v].default !== void 0;
        }
        function b(v) {
          i.subschema({
            keyword: "properties",
            schemaProp: v,
            dataProp: v
          }, g);
        }
      }
    };
    return Zy.default = o, Zy;
  }
  var Qy = {}, R5;
  function ske() {
    if (R5) return Qy;
    R5 = 1, Object.defineProperty(Qy, "__esModule", { value: !0 });
    const e = ci(), t = vt(), n = Lt(), r = Lt(), o = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(i) {
        const { gen: a, schema: s, data: c, parentSchema: u, it: d } = i, { opts: p } = d, m = (0, e.allSchemaProperties)(s), g = m.filter((C) => (0, n.alwaysValidSchema)(d, s[C]));
        if (m.length === 0 || g.length === m.length && (!d.opts.unevaluated || d.props === !0))
          return;
        const y = p.strictSchema && !p.allowMatchingProperties && u.properties, b = a.name("valid");
        d.props !== !0 && !(d.props instanceof t.Name) && (d.props = (0, r.evaluatedPropsToName)(a, d.props));
        const { props: v } = d;
        x();
        function x() {
          for (const C of m)
            y && E(C), d.allErrors ? _(C) : (a.var(b, !0), _(C), a.if(b));
        }
        function E(C) {
          for (const k in y)
            new RegExp(C).test(k) && (0, n.checkStrictMode)(d, `property ${k} matches pattern ${C} (use allowMatchingProperties)`);
        }
        function _(C) {
          a.forIn("key", c, (k) => {
            a.if((0, t._)`${(0, e.usePattern)(i, C)}.test(${k})`, () => {
              const A = g.includes(C);
              A || i.subschema({
                keyword: "patternProperties",
                schemaProp: C,
                dataProp: k,
                dataPropType: r.Type.Str
              }, b), d.opts.unevaluated && v !== !0 ? a.assign((0, t._)`${v}[${k}]`, !0) : !A && !d.allErrors && a.if((0, t.not)(b), () => a.break());
            });
          });
        }
      }
    };
    return Qy.default = o, Qy;
  }
  var Jy = {}, O5;
  function lke() {
    if (O5) return Jy;
    O5 = 1, Object.defineProperty(Jy, "__esModule", { value: !0 });
    const e = Lt(), t = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: !0,
      code(n) {
        const { gen: r, schema: o, it: i } = n;
        if ((0, e.alwaysValidSchema)(i, o)) {
          n.fail();
          return;
        }
        const a = r.name("valid");
        n.subschema({
          keyword: "not",
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }, a), n.failResult(a, () => n.reset(), () => n.error());
      },
      error: { message: "must NOT be valid" }
    };
    return Jy.default = t, Jy;
  }
  var ev = {}, M5;
  function cke() {
    if (M5) return ev;
    M5 = 1, Object.defineProperty(ev, "__esModule", { value: !0 });
    const t = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: !0,
      code: ci().validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    return ev.default = t, ev;
  }
  var tv = {}, N5;
  function uke() {
    if (N5) return tv;
    N5 = 1, Object.defineProperty(tv, "__esModule", { value: !0 });
    const e = vt(), t = Lt(), r = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: !0,
      error: {
        message: "must match exactly one schema in oneOf",
        params: ({ params: o }) => (0, e._)`{passingSchemas: ${o.passing}}`
      },
      code(o) {
        const { gen: i, schema: a, parentSchema: s, it: c } = o;
        if (!Array.isArray(a))
          throw new Error("ajv implementation error");
        if (c.opts.discriminator && s.discriminator)
          return;
        const u = a, d = i.let("valid", !1), p = i.let("passing", null), m = i.name("_valid");
        o.setParams({ passing: p }), i.block(g), o.result(d, () => o.reset(), () => o.error(!0));
        function g() {
          u.forEach((y, b) => {
            let v;
            (0, t.alwaysValidSchema)(c, y) ? i.var(m, !0) : v = o.subschema({
              keyword: "oneOf",
              schemaProp: b,
              compositeRule: !0
            }, m), b > 0 && i.if((0, e._)`${m} && ${d}`).assign(d, !1).assign(p, (0, e._)`[${p}, ${b}]`).else(), i.if(m, () => {
              i.assign(d, !0), i.assign(p, b), v && o.mergeEvaluated(v, e.Name);
            });
          });
        }
      }
    };
    return tv.default = r, tv;
  }
  var nv = {}, P5;
  function fke() {
    if (P5) return nv;
    P5 = 1, Object.defineProperty(nv, "__esModule", { value: !0 });
    const e = Lt(), t = {
      keyword: "allOf",
      schemaType: "array",
      code(n) {
        const { gen: r, schema: o, it: i } = n;
        if (!Array.isArray(o))
          throw new Error("ajv implementation error");
        const a = r.name("valid");
        o.forEach((s, c) => {
          if ((0, e.alwaysValidSchema)(i, s))
            return;
          const u = n.subschema({ keyword: "allOf", schemaProp: c }, a);
          n.ok(a), n.mergeEvaluated(u);
        });
      }
    };
    return nv.default = t, nv;
  }
  var rv = {}, I5;
  function dke() {
    if (I5) return rv;
    I5 = 1, Object.defineProperty(rv, "__esModule", { value: !0 });
    const e = vt(), t = Lt(), r = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: !0,
      error: {
        message: ({ params: i }) => (0, e.str)`must match "${i.ifClause}" schema`,
        params: ({ params: i }) => (0, e._)`{failingKeyword: ${i.ifClause}}`
      },
      code(i) {
        const { gen: a, parentSchema: s, it: c } = i;
        s.then === void 0 && s.else === void 0 && (0, t.checkStrictMode)(c, '"if" without "then" and "else" is ignored');
        const u = o(c, "then"), d = o(c, "else");
        if (!u && !d)
          return;
        const p = a.let("valid", !0), m = a.name("_valid");
        if (g(), i.reset(), u && d) {
          const b = a.let("ifClause");
          i.setParams({ ifClause: b }), a.if(m, y("then", b), y("else", b));
        } else u ? a.if(m, y("then")) : a.if((0, e.not)(m), y("else"));
        i.pass(p, () => i.error(!0));
        function g() {
          const b = i.subschema({
            keyword: "if",
            compositeRule: !0,
            createErrors: !1,
            allErrors: !1
          }, m);
          i.mergeEvaluated(b);
        }
        function y(b, v) {
          return () => {
            const x = i.subschema({ keyword: b }, m);
            a.assign(p, m), i.mergeValidEvaluated(x, p), v ? a.assign(v, (0, e._)`${b}`) : i.setParams({ ifClause: b });
          };
        }
      }
    };
    function o(i, a) {
      const s = i.schema[a];
      return s !== void 0 && !(0, t.alwaysValidSchema)(i, s);
    }
    return rv.default = r, rv;
  }
  var ov = {}, $5;
  function pke() {
    if ($5) return ov;
    $5 = 1, Object.defineProperty(ov, "__esModule", { value: !0 });
    const e = Lt(), t = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword: n, parentSchema: r, it: o }) {
        r.if === void 0 && (0, e.checkStrictMode)(o, `"${n}" without "if" is ignored`);
      }
    };
    return ov.default = t, ov;
  }
  var j5;
  function hke() {
    if (j5) return qy;
    j5 = 1, Object.defineProperty(qy, "__esModule", { value: !0 });
    const e = _V(), t = tke(), n = EV(), r = nke(), o = rke(), i = oke(), a = ike(), s = CV(), c = ake(), u = ske(), d = lke(), p = cke(), m = uke(), g = fke(), y = dke(), b = pke();
    function v(x = !1) {
      const E = [
        // any
        d.default,
        p.default,
        m.default,
        g.default,
        y.default,
        b.default,
        // object
        a.default,
        s.default,
        i.default,
        c.default,
        u.default
      ];
      return x ? E.push(t.default, r.default) : E.push(e.default, n.default), E.push(o.default), E;
    }
    return qy.default = v, qy;
  }
  var iv = {}, av = {}, D5;
  function mke() {
    if (D5) return av;
    D5 = 1, Object.defineProperty(av, "__esModule", { value: !0 });
    const e = vt(), n = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: !0,
      error: {
        message: ({ schemaCode: r }) => (0, e.str)`must match format "${r}"`,
        params: ({ schemaCode: r }) => (0, e._)`{format: ${r}}`
      },
      code(r, o) {
        const { gen: i, data: a, $data: s, schema: c, schemaCode: u, it: d } = r, { opts: p, errSchemaPath: m, schemaEnv: g, self: y } = d;
        if (!p.validateFormats)
          return;
        s ? b() : v();
        function b() {
          const x = i.scopeValue("formats", {
            ref: y.formats,
            code: p.code.formats
          }), E = i.const("fDef", (0, e._)`${x}[${u}]`), _ = i.let("fType"), C = i.let("format");
          i.if((0, e._)`typeof ${E} == "object" && !(${E} instanceof RegExp)`, () => i.assign(_, (0, e._)`${E}.type || "string"`).assign(C, (0, e._)`${E}.validate`), () => i.assign(_, (0, e._)`"string"`).assign(C, E)), r.fail$data((0, e.or)(k(), A()));
          function k() {
            return p.strictSchema === !1 ? e.nil : (0, e._)`${u} && !${C}`;
          }
          function A() {
            const O = g.$async ? (0, e._)`(${E}.async ? await ${C}(${a}) : ${C}(${a}))` : (0, e._)`${C}(${a})`, P = (0, e._)`(typeof ${C} == "function" ? ${O} : ${C}.test(${a}))`;
            return (0, e._)`${C} && ${C} !== true && ${_} === ${o} && !${P}`;
          }
        }
        function v() {
          const x = y.formats[c];
          if (!x) {
            k();
            return;
          }
          if (x === !0)
            return;
          const [E, _, C] = A(x);
          E === o && r.pass(O());
          function k() {
            if (p.strictSchema === !1) {
              y.logger.warn(P());
              return;
            }
            throw new Error(P());
            function P() {
              return `unknown format "${c}" ignored in schema at path "${m}"`;
            }
          }
          function A(P) {
            const I = P instanceof RegExp ? (0, e.regexpCode)(P) : p.code.formats ? (0, e._)`${p.code.formats}${(0, e.getProperty)(c)}` : void 0, $ = i.scopeValue("formats", { key: c, ref: P, code: I });
            return typeof P == "object" && !(P instanceof RegExp) ? [P.type || "string", P.validate, (0, e._)`${$}.validate`] : ["string", P, $];
          }
          function O() {
            if (typeof x == "object" && !(x instanceof RegExp) && x.async) {
              if (!g.$async)
                throw new Error("async format in sync schema");
              return (0, e._)`await ${C}(${a})`;
            }
            return typeof _ == "function" ? (0, e._)`${C}(${a})` : (0, e._)`${C}.test(${a})`;
          }
        }
      }
    };
    return av.default = n, av;
  }
  var F5;
  function gke() {
    if (F5) return iv;
    F5 = 1, Object.defineProperty(iv, "__esModule", { value: !0 });
    const t = [mke().default];
    return iv.default = t, iv;
  }
  var Hl = {}, L5;
  function yke() {
    return L5 || (L5 = 1, Object.defineProperty(Hl, "__esModule", { value: !0 }), Hl.contentVocabulary = Hl.metadataVocabulary = void 0, Hl.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ], Hl.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ]), Hl;
  }
  var z5;
  function vke() {
    if (z5) return Ry;
    z5 = 1, Object.defineProperty(Ry, "__esModule", { value: !0 });
    const e = UCe(), t = eke(), n = hke(), r = gke(), o = yke(), i = [
      e.default,
      t.default,
      (0, n.default)(),
      r.default,
      o.metadataVocabulary,
      o.contentVocabulary
    ];
    return Ry.default = i, Ry;
  }
  var sv = {}, np = {}, B5;
  function bke() {
    if (B5) return np;
    B5 = 1, Object.defineProperty(np, "__esModule", { value: !0 }), np.DiscrError = void 0;
    var e;
    return (function(t) {
      t.Tag = "tag", t.Mapping = "mapping";
    })(e || (np.DiscrError = e = {})), np;
  }
  var U5;
  function xke() {
    if (U5) return sv;
    U5 = 1, Object.defineProperty(sv, "__esModule", { value: !0 });
    const e = vt(), t = bke(), n = AA(), r = C1(), o = Lt(), a = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error: {
        message: ({ params: { discrError: s, tagName: c } }) => s === t.DiscrError.Tag ? `tag "${c}" must be string` : `value of tag "${c}" must be in oneOf`,
        params: ({ params: { discrError: s, tag: c, tagName: u } }) => (0, e._)`{error: ${s}, tag: ${u}, tagValue: ${c}}`
      },
      code(s) {
        const { gen: c, data: u, schema: d, parentSchema: p, it: m } = s, { oneOf: g } = p;
        if (!m.opts.discriminator)
          throw new Error("discriminator: requires discriminator option");
        const y = d.propertyName;
        if (typeof y != "string")
          throw new Error("discriminator: requires propertyName");
        if (d.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!g)
          throw new Error("discriminator: requires oneOf keyword");
        const b = c.let("valid", !1), v = c.const("tag", (0, e._)`${u}${(0, e.getProperty)(y)}`);
        c.if((0, e._)`typeof ${v} == "string"`, () => x(), () => s.error(!1, { discrError: t.DiscrError.Tag, tag: v, tagName: y })), s.ok(b);
        function x() {
          const C = _();
          c.if(!1);
          for (const k in C)
            c.elseIf((0, e._)`${v} === ${k}`), c.assign(b, E(C[k]));
          c.else(), s.error(!1, { discrError: t.DiscrError.Mapping, tag: v, tagName: y }), c.endIf();
        }
        function E(C) {
          const k = c.name("valid"), A = s.subschema({ keyword: "oneOf", schemaProp: C }, k);
          return s.mergeEvaluated(A, e.Name), k;
        }
        function _() {
          var C;
          const k = {}, A = P(p);
          let O = !0;
          for (let L = 0; L < g.length; L++) {
            let N = g[L];
            if (N?.$ref && !(0, o.schemaHasRulesButRef)(N, m.self.RULES)) {
              const j = N.$ref;
              if (N = n.resolveRef.call(m.self, m.schemaEnv.root, m.baseId, j), N instanceof n.SchemaEnv && (N = N.schema), N === void 0)
                throw new r.default(m.opts.uriResolver, m.baseId, j);
            }
            const U = (C = N?.properties) === null || C === void 0 ? void 0 : C[y];
            if (typeof U != "object")
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${y}"`);
            O = O && (A || P(N)), I(U, L);
          }
          if (!O)
            throw new Error(`discriminator: "${y}" must be required`);
          return k;
          function P({ required: L }) {
            return Array.isArray(L) && L.includes(y);
          }
          function I(L, N) {
            if (L.const)
              $(L.const, N);
            else if (L.enum)
              for (const U of L.enum)
                $(U, N);
            else
              throw new Error(`discriminator: "properties/${y}" must have "const" or "enum"`);
          }
          function $(L, N) {
            if (typeof L != "string" || L in k)
              throw new Error(`discriminator: "${y}" values must be unique strings`);
            k[L] = N;
          }
        }
      }
    };
    return sv.default = a, sv;
  }
  const wke = "http://json-schema.org/draft-07/schema#", Ske = "http://json-schema.org/draft-07/schema#", _ke = "Core schema meta-schema", Eke = { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: !0, default: [] } }, Cke = ["object", "boolean"], kke = { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: !0, readOnly: { type: "boolean", default: !1 }, examples: { type: "array", items: !0 }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: !0 }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: !1 }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: !0, enum: { type: "array", items: !0, minItems: 1, uniqueItems: !0 }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: !0 }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, Tke = {
    $schema: wke,
    $id: Ske,
    title: _ke,
    definitions: Eke,
    type: Cke,
    properties: kke,
    default: !0
  };
  var V5;
  function kV() {
    return V5 || (V5 = 1, (function(e, t) {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.MissingRefError = t.ValidationError = t.CodeGen = t.Name = t.nil = t.stringify = t.str = t._ = t.KeywordCxt = t.Ajv = void 0;
      const n = LCe(), r = vke(), o = xke(), i = Tke, a = ["/properties"], s = "http://json-schema.org/draft-07/schema";
      class c extends n.default {
        _addVocabularies() {
          super._addVocabularies(), r.default.forEach((y) => this.addVocabulary(y)), this.opts.discriminator && this.addKeyword(o.default);
        }
        _addDefaultMetaSchema() {
          if (super._addDefaultMetaSchema(), !this.opts.meta)
            return;
          const y = this.opts.$data ? this.$dataMetaSchema(i, a) : i;
          this.addMetaSchema(y, s, !1), this.refs["http://json-schema.org/schema"] = s;
        }
        defaultMeta() {
          return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(s) ? s : void 0);
        }
      }
      t.Ajv = c, e.exports = t = c, e.exports.Ajv = c, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = c;
      var u = E1();
      Object.defineProperty(t, "KeywordCxt", { enumerable: !0, get: function() {
        return u.KeywordCxt;
      } });
      var d = vt();
      Object.defineProperty(t, "_", { enumerable: !0, get: function() {
        return d._;
      } }), Object.defineProperty(t, "str", { enumerable: !0, get: function() {
        return d.str;
      } }), Object.defineProperty(t, "stringify", { enumerable: !0, get: function() {
        return d.stringify;
      } }), Object.defineProperty(t, "nil", { enumerable: !0, get: function() {
        return d.nil;
      } }), Object.defineProperty(t, "Name", { enumerable: !0, get: function() {
        return d.Name;
      } }), Object.defineProperty(t, "CodeGen", { enumerable: !0, get: function() {
        return d.CodeGen;
      } });
      var p = TA();
      Object.defineProperty(t, "ValidationError", { enumerable: !0, get: function() {
        return p.default;
      } });
      var m = C1();
      Object.defineProperty(t, "MissingRefError", { enumerable: !0, get: function() {
        return m.default;
      } });
    })(Ey, Ey.exports)), Ey.exports;
  }
  var Ake = kV();
  const Rke = /* @__PURE__ */ Xi(Ake);
  var lv = { exports: {} }, L_ = {}, H5;
  function Oke() {
    return H5 || (H5 = 1, (function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.formatNames = e.fastFormats = e.fullFormats = void 0;
      function t(I, $) {
        return { validate: I, compare: $ };
      }
      e.fullFormats = {
        // date: http://tools.ietf.org/html/rfc3339#section-5.6
        date: t(i, a),
        // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
        time: t(c, u),
        "date-time": t(p, m),
        // duration: https://tools.ietf.org/html/rfc3339#appendix-A
        duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
        uri: b,
        "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
        // uri-template: https://tools.ietf.org/html/rfc6570
        "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
        // For the source: https://gist.github.com/dperini/729294
        // For test cases: https://mathiasbynens.be/demo/url-regex
        url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
        email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
        hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
        // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
        ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
        ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
        regex: P,
        // uuid: http://tools.ietf.org/html/rfc4122
        uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
        // JSON-pointer: https://tools.ietf.org/html/rfc6901
        // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
        "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
        "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
        // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
        "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
        // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
        // byte: https://github.com/miguelmota/is-base64
        byte: x,
        // signed 32 bit integer
        int32: { type: "number", validate: C },
        // signed 64 bit integer
        int64: { type: "number", validate: k },
        // C-type float
        float: { type: "number", validate: A },
        // C-type double
        double: { type: "number", validate: A },
        // hint to the UI to hide input strings
        password: !0,
        // unchecked string payload
        binary: !0
      }, e.fastFormats = {
        ...e.fullFormats,
        date: t(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, a),
        time: t(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, u),
        "date-time": t(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, m),
        // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
        uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
        "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
        // email (sources from jsen validator):
        // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
        // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
        email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
      }, e.formatNames = Object.keys(e.fullFormats);
      function n(I) {
        return I % 4 === 0 && (I % 100 !== 0 || I % 400 === 0);
      }
      const r = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, o = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function i(I) {
        const $ = r.exec(I);
        if (!$)
          return !1;
        const L = +$[1], N = +$[2], U = +$[3];
        return N >= 1 && N <= 12 && U >= 1 && U <= (N === 2 && n(L) ? 29 : o[N]);
      }
      function a(I, $) {
        if (I && $)
          return I > $ ? 1 : I < $ ? -1 : 0;
      }
      const s = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
      function c(I, $) {
        const L = s.exec(I);
        if (!L)
          return !1;
        const N = +L[1], U = +L[2], j = +L[3], V = L[5];
        return (N <= 23 && U <= 59 && j <= 59 || N === 23 && U === 59 && j === 60) && (!$ || V !== "");
      }
      function u(I, $) {
        if (!(I && $))
          return;
        const L = s.exec(I), N = s.exec($);
        if (L && N)
          return I = L[1] + L[2] + L[3] + (L[4] || ""), $ = N[1] + N[2] + N[3] + (N[4] || ""), I > $ ? 1 : I < $ ? -1 : 0;
      }
      const d = /t|\s/i;
      function p(I) {
        const $ = I.split(d);
        return $.length === 2 && i($[0]) && c($[1], !0);
      }
      function m(I, $) {
        if (!(I && $))
          return;
        const [L, N] = I.split(d), [U, j] = $.split(d), V = a(L, U);
        if (V !== void 0)
          return V || u(N, j);
      }
      const g = /\/|:/, y = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
      function b(I) {
        return g.test(I) && y.test(I);
      }
      const v = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
      function x(I) {
        return v.lastIndex = 0, v.test(I);
      }
      const E = -2147483648, _ = 2 ** 31 - 1;
      function C(I) {
        return Number.isInteger(I) && I <= _ && I >= E;
      }
      function k(I) {
        return Number.isInteger(I);
      }
      function A() {
        return !0;
      }
      const O = /[^\\]\\Z/;
      function P(I) {
        if (O.test(I))
          return !1;
        try {
          return new RegExp(I), !0;
        } catch {
          return !1;
        }
      }
    })(L_)), L_;
  }
  var z_ = {}, q5;
  function Mke() {
    return q5 || (q5 = 1, (function(e) {
      Object.defineProperty(e, "__esModule", { value: !0 }), e.formatLimitDefinition = void 0;
      const t = kV(), n = vt(), r = n.operators, o = {
        formatMaximum: { okStr: "<=", ok: r.LTE, fail: r.GT },
        formatMinimum: { okStr: ">=", ok: r.GTE, fail: r.LT },
        formatExclusiveMaximum: { okStr: "<", ok: r.LT, fail: r.GTE },
        formatExclusiveMinimum: { okStr: ">", ok: r.GT, fail: r.LTE }
      }, i = {
        message: ({ keyword: s, schemaCode: c }) => n.str`should be ${o[s].okStr} ${c}`,
        params: ({ keyword: s, schemaCode: c }) => n._`{comparison: ${o[s].okStr}, limit: ${c}}`
      };
      e.formatLimitDefinition = {
        keyword: Object.keys(o),
        type: "string",
        schemaType: "string",
        $data: !0,
        error: i,
        code(s) {
          const { gen: c, data: u, schemaCode: d, keyword: p, it: m } = s, { opts: g, self: y } = m;
          if (!g.validateFormats)
            return;
          const b = new t.KeywordCxt(m, y.RULES.all.format.definition, "format");
          b.$data ? v() : x();
          function v() {
            const _ = c.scopeValue("formats", {
              ref: y.formats,
              code: g.code.formats
            }), C = c.const("fmt", n._`${_}[${b.schemaCode}]`);
            s.fail$data(n.or(n._`typeof ${C} != "object"`, n._`${C} instanceof RegExp`, n._`typeof ${C}.compare != "function"`, E(C)));
          }
          function x() {
            const _ = b.schema, C = y.formats[_];
            if (!C || C === !0)
              return;
            if (typeof C != "object" || C instanceof RegExp || typeof C.compare != "function")
              throw new Error(`"${p}": format "${_}" does not define "compare" function`);
            const k = c.scopeValue("formats", {
              key: _,
              ref: C,
              code: g.code.formats ? n._`${g.code.formats}${n.getProperty(_)}` : void 0
            });
            s.fail$data(E(k));
          }
          function E(_) {
            return n._`${_}.compare(${u}, ${d}) ${o[p].fail} 0`;
          }
        },
        dependencies: ["format"]
      };
      const a = (s) => (s.addKeyword(e.formatLimitDefinition), s);
      e.default = a;
    })(z_)), z_;
  }
  var W5;
  function Nke() {
    return W5 || (W5 = 1, (function(e, t) {
      Object.defineProperty(t, "__esModule", { value: !0 });
      const n = Oke(), r = Mke(), o = vt(), i = new o.Name("fullFormats"), a = new o.Name("fastFormats"), s = (u, d = { keywords: !0 }) => {
        if (Array.isArray(d))
          return c(u, d, n.fullFormats, i), u;
        const [p, m] = d.mode === "fast" ? [n.fastFormats, a] : [n.fullFormats, i], g = d.formats || n.formatNames;
        return c(u, g, p, m), d.keywords && r.default(u), u;
      };
      s.get = (u, d = "full") => {
        const m = (d === "fast" ? n.fastFormats : n.fullFormats)[u];
        if (!m)
          throw new Error(`Unknown format "${u}"`);
        return m;
      };
      function c(u, d, p, m) {
        var g, y;
        (g = (y = u.opts.code).formats) !== null && g !== void 0 || (y.formats = o._`require("ajv-formats/dist/formats").${m}`);
        for (const b of d)
          u.addFormat(b, p[b]);
      }
      e.exports = t = s, Object.defineProperty(t, "__esModule", { value: !0 }), t.default = s;
    })(lv, lv.exports)), lv.exports;
  }
  var Pke = Nke();
  const G5 = /* @__PURE__ */ Xi(Pke), Ike = {
    allErrors: !0,
    multipleOfPrecision: 8,
    strict: !1,
    verbose: !0,
    discriminator: !1
    // TODO enable this in V6
  }, $ke = /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/, jke = /^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;
  function Dke(e, t, n = {}, r, o = Rke, i) {
    let a = new o({ ...Ike, ...n });
    return r ? G5(a, r) : r !== !1 && G5(a), a.addFormat("data-url", jke), a.addFormat("color", $ke), a.addKeyword(Ba), a.addKeyword(KT), Array.isArray(e) && a.addMetaSchema(e), $t(t) && Object.keys(t).forEach((s) => {
      a.addFormat(s, t[s]);
    }), i && (a = i(a)), a;
  }
  function Fke(e = [], t) {
    return e.map((r) => {
      var o;
      const { instancePath: i, keyword: a, params: s, schemaPath: c, parentSchema: u, ...d } = r;
      let { message: p = "" } = d, m = i.replace(/\//g, "."), g = `${m} ${p}`.trim(), y = "";
      const b = [
        ...((o = s.deps) === null || o === void 0 ? void 0 : o.split(", ")) || [],
        s.missingProperty,
        s.property
      ].filter((v) => v);
      if (b.length > 0)
        b.forEach((v) => {
          const x = m ? `${m}.${v}` : v;
          let E = Qe(Ee(t, `${x.replace(/^\./, "")}`)).title;
          if (E === void 0) {
            const _ = c.replace(/\/properties\//g, "/").split("/").slice(1, -1).concat([v]);
            E = Qe(Ee(t, _)).title;
          }
          if (E)
            p = p.replace(`'${v}'`, `'${E}'`), y = E;
          else {
            const _ = Ee(u, [Ft, v, "title"]);
            _ && (p = p.replace(`'${v}'`, `'${_}'`), y = _);
          }
        }), g = p;
      else {
        const v = Qe(Ee(t, `${m.replace(/^\./, "")}`)).title;
        if (v)
          g = `'${v}' ${p}`.trim(), y = v;
        else {
          const x = u?.title;
          x && (g = `'${x}' ${p}`.trim(), y = x);
        }
      }
      return "missingProperty" in s && (m = m ? `${m}.${s.missingProperty}` : s.missingProperty), {
        name: a,
        property: m,
        message: p,
        params: s,
        // specific to ajv
        stack: g,
        schemaPath: c,
        title: y
      };
    }).reduce((r, o) => {
      const { message: i, schemaPath: a } = o, s = a?.indexOf(`/${Nt}/`), c = a?.indexOf(`/${yt}/`);
      let u;
      return s && s >= 0 ? u = a?.substring(0, s) : c && c >= 0 && (u = a?.substring(0, c)), u && r.find((p) => {
        var m;
        return p.message === i && ((m = p.schemaPath) === null || m === void 0 ? void 0 : m.startsWith(u));
      }) || r.push(o), r;
    }, []);
  }
  function Lke(e, t, n, r, o, i, a) {
    const { validationError: s } = t;
    let c = Fke(t.errors, a);
    s && (c = [...c, { stack: s.message }]), typeof i == "function" && (c = i(c, a));
    let u = uCe(c);
    if (s && (u = {
      ...u,
      $schema: {
        __errors: [s.message]
      }
    }), typeof o != "function")
      return { errors: c, errorSchema: u };
    const d = iV(e, r, n, r, !0), p = o(d, _C(d), a), m = bV(p);
    return Kv({ errors: c, errorSchema: u }, m);
  }
  class zke {
    /** Constructs an `AJV8Validator` instance using the `options`
     *
     * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance
     * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s
     */
    constructor(t, n) {
      const { additionalMetaSchemas: r, customFormats: o, ajvOptionsOverrides: i, ajvFormatOptions: a, AjvClass: s, extenderFn: c } = t;
      this.ajv = Dke(r, o, i, a, s, c), this.localizer = n;
    }
    /** Resets the internal AJV validator to clear schemas from it. Can be helpful for resetting the validator for tests.
     */
    reset() {
      this.ajv.removeSchema();
    }
    /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use
     * by the playground. Returns the `errors` from the validation
     *
     * @param schema - The schema against which to validate the form data   * @param schema
     * @param formData - The form data to validate
     */
    rawValidation(t, n) {
      var r, o;
      let i, a;
      try {
        t[rn] && (a = this.ajv.getSchema(t[rn])), a === void 0 && (a = this.ajv.compile(t)), a(n);
      } catch (c) {
        i = c;
      }
      let s;
      return a && (typeof this.localizer == "function" && (((r = a.errors) !== null && r !== void 0 ? r : []).forEach((c) => {
        var u;
        ["missingProperty", "property"].forEach((d) => {
          var p;
          !((p = c.params) === null || p === void 0) && p[d] && (c.params[d] = `'${c.params[d]}'`);
        }), !((u = c.params) === null || u === void 0) && u.deps && (c.params.deps = c.params.deps.split(", ").map((d) => `'${d}'`).join(", "));
      }), this.localizer(a.errors), ((o = a.errors) !== null && o !== void 0 ? o : []).forEach((c) => {
        var u;
        ["missingProperty", "property"].forEach((d) => {
          var p;
          !((p = c.params) === null || p === void 0) && p[d] && (c.params[d] = c.params[d].slice(1, -1));
        }), !((u = c.params) === null || u === void 0) && u.deps && (c.params.deps = c.params.deps.split(", ").map((d) => d.slice(1, -1)).join(", "));
      })), s = a.errors || void 0, a.errors = null), {
        errors: s,
        validationError: i
      };
    }
    /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives
     * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also
     * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and
     * transform them in what ever way it chooses.
     *
     * @param formData - The form data to validate
     * @param schema - The schema against which to validate the form data
     * @param [customValidate] - An optional function that is used to perform custom validation
     * @param [transformErrors] - An optional function that is used to transform errors after AJV validation
     * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`
     */
    validateFormData(t, n, r, o, i) {
      const a = this.rawValidation(n, t);
      return Lke(this, a, t, n, r, o, i);
    }
    /**
     * This function checks if a schema needs to be added and if the root schemas don't match it removes the old root schema from the ajv instance and adds the new one.
     * @param rootSchema - The root schema used to provide $ref resolutions
     */
    handleSchemaUpdate(t) {
      var n, r;
      const o = (n = t[rn]) !== null && n !== void 0 ? n : Z8;
      this.ajv.getSchema(o) === void 0 ? this.ajv.addSchema(t, o) : pn(t, (r = this.ajv.getSchema(o)) === null || r === void 0 ? void 0 : r.schema) || (this.ajv.removeSchema(o), this.ajv.addSchema(t, o));
    }
    /** Validates data against a schema, returning true if the data is valid, or
     * false otherwise. If the schema is invalid, then this function will return
     * false.
     *
     * @param schema - The schema against which to validate the form data
     * @param formData - The form data to validate
     * @param rootSchema - The root schema used to provide $ref resolutions
     */
    isValid(t, n, r) {
      var o;
      try {
        this.handleSchemaUpdate(r);
        const i = kA(t), a = (o = i[rn]) !== null && o !== void 0 ? o : iCe(i);
        let s;
        return s = this.ajv.getSchema(a), s === void 0 && (s = this.ajv.addSchema(i, a).getSchema(a) || this.ajv.compile(i)), s(n);
      } catch (i) {
        return console.warn("Error encountered compiling schema:", i), !1;
      }
    }
  }
  function Bke(e = {}, t) {
    return new zke(e, t);
  }
  const Uke = Bke();
  function Vke(e, t) {
    return dV(e, t, function(n, r) {
      return _U(e, r);
    });
  }
  var TV = VU(function(e, t) {
    return e == null ? {} : Vke(e, t);
  });
  function Hke(e, t) {
    return e == null ? !0 : UU(e, t);
  }
  function IC() {
    return gV("rjsf-array-item-");
  }
  function K5(e) {
    return Array.isArray(e) ? e.map((t) => ({
      key: IC(),
      item: t
    })) : [];
  }
  function AV(e) {
    return Array.isArray(e) ? e.map((t) => t.item) : [];
  }
  function qke(e) {
    return Array.isArray(e.type) ? !e.type.includes("null") : e.type !== "null";
  }
  function RV(e, t, n, r) {
    let { addable: o } = Qe(r, e.globalUiOptions);
    return o !== !1 && (t.maxItems !== void 0 ? o = n.length < t.maxItems : o = !0), o;
  }
  function OV(e, t, n, r) {
    if (typeof e.items == "function")
      try {
        return e.items(t, n, r);
      } catch (o) {
        console.error(`Error executing dynamic uiSchema.items function for item at index ${n}:`, o);
        return;
      }
    else
      return e.items;
  }
  function Wke(e, t) {
    const { schemaUtils: n, globalFormOptions: r } = e;
    let o = t.items;
    return r.useFallbackUiForUnsupportedType && !o ? o = {} : gA(t) && bbe(t) && (o = t.additionalItems), n.getDefaultFormState(o);
  }
  function Gke(e) {
    const { schema: t, fieldPathId: n, uiSchema: r, formData: o = [], disabled: i = !1, readonly: a = !1, autofocus: s = !1, required: c = !1, placeholder: u, onBlur: d, onFocus: p, registry: m, rawErrors: g, name: y, onSelectChange: b } = e, { widgets: v, schemaUtils: x, globalFormOptions: E, globalUiOptions: _ } = m, C = x.retrieveSchema(t.items, o), k = Af(C, r), { widget: A = "select", title: O, ...P } = Qe(r, _), I = Yi(t, A, v), $ = O ?? t.title ?? y, L = x.getDisplayLabel(t, r, _), N = Ic(Do("", E, n, !0));
    return S.jsx(I, { id: N[rn], name: y, multiple: !0, onChange: b, onBlur: d, onFocus: p, options: { ...P, enumOptions: k }, schema: t, uiSchema: r, registry: m, value: o, disabled: i, readonly: a, required: c, label: $, hideLabel: !L, placeholder: u, autofocus: s, rawErrors: g, htmlName: N.name });
  }
  function Kke(e) {
    const { schema: t, fieldPathId: n, uiSchema: r, disabled: o = !1, readonly: i = !1, autofocus: a = !1, required: s = !1, hideError: c, placeholder: u, onBlur: d, onFocus: p, formData: m = [], registry: g, rawErrors: y, name: b, onSelectChange: v } = e, { widgets: x, schemaUtils: E, globalFormOptions: _, globalUiOptions: C } = g, { widget: k, title: A, ...O } = Qe(r, C), P = Yi(t, k, x), I = A ?? t.title ?? b, $ = E.getDisplayLabel(t, r, C), L = Ic(Do("", _, n, !0));
    return S.jsx(P, { id: L[rn], name: b, multiple: !0, onChange: v, onBlur: d, onFocus: p, options: O, schema: t, uiSchema: r, registry: g, value: m, disabled: o, readonly: i, hideError: c, required: s, label: I, hideLabel: !$, placeholder: u, autofocus: a, rawErrors: y, htmlName: L.name });
  }
  function Yke(e) {
    const { schema: t, uiSchema: n, fieldPathId: r, name: o, disabled: i = !1, readonly: a = !1, autofocus: s = !1, required: c = !1, onBlur: u, onFocus: d, registry: p, formData: m = [], rawErrors: g, onSelectChange: y } = e, { widgets: b, schemaUtils: v, globalFormOptions: x, globalUiOptions: E } = p, { widget: _ = "files", title: C, ...k } = Qe(n, E), A = Yi(t, _, b), O = C ?? t.title ?? o, P = v.getDisplayLabel(t, n, E), I = Ic(Do("", x, r, !0));
    return S.jsx(A, { options: k, id: I[rn], name: o, multiple: !0, onChange: y, onBlur: u, onFocus: d, schema: t, uiSchema: n, value: m, disabled: i, readonly: a, required: c, registry: p, autofocus: s, rawErrors: g, label: O, hideLabel: !P, htmlName: I.name });
  }
  function MV(e) {
    const { itemKey: t, index: n, name: r, disabled: o, hideError: i, readonly: a, registry: s, uiOptions: c, parentUiSchema: u, canAdd: d, canRemove: p = !0, canMoveUp: m, canMoveDown: g, itemSchema: y, itemData: b, itemUiSchema: v, itemFieldPathId: x, itemErrorSchema: E, autofocus: _, onBlur: C, onFocus: k, onChange: A, rawErrors: O, totalItems: P, title: I, handleAddItem: $, handleCopyItem: L, handleRemoveItem: N, handleReorderItems: U } = e, { schemaUtils: j, fields: { ArraySchemaField: V, SchemaField: F }, globalUiOptions: K } = s, W = Ic(x), Y = V || F, B = tt("ArrayFieldItemTemplate", s, c), D = j.getDisplayLabel(y, v, K), { description: G } = Qe(v), z = !!G || !!y.description, { orderable: H = !0, removable: X = !0, copyable: Q = !1 } = c, ne = {
      moveUp: H && m,
      moveDown: H && g,
      copy: Q && d,
      remove: X && p,
      toolbar: !1
    };
    ne.toolbar = Object.keys(ne).some((le) => ne[le]);
    const te = T.useCallback((le) => {
      $(le, n + 1);
    }, [$, n]), se = T.useCallback((le) => {
      L(le, n);
    }, [L, n]), ue = T.useCallback((le) => {
      N(le, n);
    }, [N, n]), J = T.useCallback((le) => {
      U(le, n, n - 1);
    }, [U, n]), ee = T.useCallback((le) => {
      U(le, n, n + 1);
    }, [U, n]), ie = {
      children: S.jsx(Y, { name: r, title: I, index: n, schema: y, uiSchema: v, formData: b, errorSchema: E, fieldPathId: W, required: qke(y), onChange: A, onBlur: C, onFocus: k, registry: s, disabled: o, readonly: a, hideError: i, autofocus: _, rawErrors: O }),
      buttonsProps: {
        fieldPathId: W,
        disabled: o,
        readonly: a,
        canAdd: d,
        hasCopy: ne.copy,
        hasMoveUp: ne.moveUp,
        hasMoveDown: ne.moveDown,
        hasRemove: ne.remove,
        index: n,
        totalItems: P,
        onAddItem: te,
        onCopyItem: se,
        onRemoveItem: ue,
        onMoveUpItem: J,
        onMoveDownItem: ee,
        registry: s,
        schema: y,
        uiSchema: v
      },
      itemKey: t,
      className: "rjsf-array-item",
      disabled: o,
      hasToolbar: ne.toolbar,
      index: n,
      totalItems: P,
      readonly: a,
      registry: s,
      schema: y,
      uiSchema: v,
      parentUiSchema: u,
      displayLabel: D,
      hasDescription: z
    };
    return S.jsx(B, { ...ie });
  }
  function Xke(e) {
    const { schema: t, uiSchema: n = {}, errorSchema: r, fieldPathId: o, formData: i, name: a, title: s, disabled: c = !1, readonly: u = !1, autofocus: d = !1, required: p = !1, hideError: m = !1, registry: g, onBlur: y, onFocus: b, rawErrors: v, onChange: x, keyedFormData: E, handleAddItem: _, handleCopyItem: C, handleRemoveItem: k, handleReorderItems: A } = e, O = t.title || s || a, { schemaUtils: P, fields: I, formContext: $, globalFormOptions: L, globalUiOptions: N } = g, { OptionalDataControlsField: U } = I, j = Qe(n, N), V = $t(t.items) ? t.items : {}, F = P.retrieveSchema(V), K = AV(E), W = pm(g, t, p, n), Y = Wf(i), B = RV(g, t, K, n) && (!W || Y), D = Y ? E : [], G = W ? " rjsf-optional-array-field" : "", z = e.childFieldPathId ?? o, H = W ? S.jsx(U, { ...e, fieldPathId: z }) : void 0, X = {
      canAdd: B,
      items: D.map((ne, te) => {
        const { key: se, item: ue } = ne, J = ue, ee = P.retrieveSchema(V, J), ie = r ? r[te] : void 0, le = Do(te, L, z), ge = OV(n, ue, te, $), Se = {
          itemKey: se,
          index: te,
          name: a && `${a}-${te}`,
          registry: g,
          uiOptions: j,
          hideError: m,
          readonly: u,
          disabled: c,
          required: p,
          title: O ? `${O}-${te + 1}` : void 0,
          canAdd: B,
          canMoveUp: te > 0,
          canMoveDown: te < K.length - 1,
          itemSchema: ee,
          itemFieldPathId: le,
          itemErrorSchema: ie,
          itemData: J,
          itemUiSchema: ge,
          autofocus: d && te === 0,
          onBlur: y,
          onFocus: b,
          rawErrors: v,
          totalItems: E.length,
          handleAddItem: _,
          handleCopyItem: C,
          handleRemoveItem: k,
          handleReorderItems: A,
          onChange: x
        };
        return S.jsx(MV, { ...Se }, se);
      }),
      className: `rjsf-field rjsf-field-array rjsf-field-array-of-${F.type}${G}`,
      disabled: c,
      fieldPathId: o,
      uiSchema: n,
      onAddClick: _,
      readonly: u,
      required: p,
      schema: t,
      title: O,
      formData: K,
      rawErrors: v,
      registry: g,
      optionalDataControl: H
    }, Q = tt("ArrayFieldTemplate", g, j);
    return S.jsx(Q, { ...X });
  }
  function Zke(e) {
    const { schema: t, uiSchema: n = {}, formData: r, errorSchema: o, fieldPathId: i, name: a, title: s, disabled: c = !1, readonly: u = !1, autofocus: d = !1, required: p = !1, hideError: m = !1, registry: g, onBlur: y, onFocus: b, rawErrors: v, keyedFormData: x, onChange: E, handleAddItem: _, handleCopyItem: C, handleRemoveItem: k, handleReorderItems: A } = e;
    let { formData: O = [] } = e;
    const P = t.title || s || a, { schemaUtils: I, fields: $, formContext: L, globalFormOptions: N, globalUiOptions: U } = g, j = Qe(n, U), { OptionalDataControlsField: V } = $, F = pm(g, t, p, n), K = Wf(r), Y = ($t(t.items) ? t.items : []).map((te, se) => I.retrieveSchema(te, O[se])), B = $t(t.additionalItems) ? I.retrieveSchema(t.additionalItems, r) : null, D = e.childFieldPathId ?? i;
    O.length < Y.length && (O = O.concat(new Array(Y.length - O.length)));
    const G = K ? x : [], z = F ? " rjsf-optional-array-field" : "", H = F ? S.jsx(V, { ...e, fieldPathId: D }) : void 0, X = RV(g, t, O, n) && !!B && (!F || K), Q = {
      canAdd: X,
      className: `rjsf-field rjsf-field-array rjsf-field-array-fixed-items${z}`,
      disabled: c,
      fieldPathId: i,
      formData: r,
      items: G.map((te, se) => {
        const { key: ue, item: J } = te, ee = J, ie = se >= Y.length, le = (ie && $t(t.additionalItems) ? I.retrieveSchema(t.additionalItems, ee) : Y[se]) || {}, ge = Do(se, N, D);
        let Se;
        ie ? Se = n.additionalItems : Array.isArray(n.items) ? Se = n.items[se] : Se = OV(n, J, se, L);
        const Me = o ? o[se] : void 0, je = {
          index: se,
          itemKey: ue,
          name: a && `${a}-${se}`,
          registry: g,
          uiOptions: j,
          hideError: m,
          readonly: u,
          disabled: c,
          required: p,
          title: P ? `${P}-${se + 1}` : void 0,
          canAdd: X,
          canRemove: ie,
          canMoveUp: se >= Y.length + 1,
          canMoveDown: ie && se < O.length - 1,
          itemSchema: le,
          itemData: ee,
          itemUiSchema: Se,
          itemFieldPathId: ge,
          itemErrorSchema: Me,
          autofocus: d && se === 0,
          onBlur: y,
          onFocus: b,
          rawErrors: v,
          totalItems: x.length,
          onChange: E,
          handleAddItem: _,
          handleCopyItem: C,
          handleRemoveItem: k,
          handleReorderItems: A
        };
        return S.jsx(MV, { ...je }, ue);
      }),
      onAddClick: _,
      readonly: u,
      required: p,
      registry: g,
      schema: t,
      uiSchema: n,
      title: P,
      errorSchema: o,
      rawErrors: v,
      optionalDataControl: H
    }, ne = tt("ArrayFieldTemplate", g, j);
    return S.jsx(ne, { ...Q });
  }
  function Qke(e = []) {
    const t = T.useMemo(() => $i(e), [e]), [n, r] = T.useState(() => ({
      formDataHash: t,
      keyedFormData: K5(e)
    }));
    let { keyedFormData: o, formDataHash: i } = n;
    if (t !== i) {
      const s = Array.isArray(e) ? e : [], c = o || [];
      o = s.length === c.length ? c.map((u, d) => ({
        key: u.key,
        item: s[d]
      })) : K5(s), i = t, r({ formDataHash: i, keyedFormData: o });
    }
    const a = T.useCallback((s) => {
      const c = AV(s), u = $i(c);
      return r({ formDataHash: u, keyedFormData: s }), c;
    }, []);
    return { keyedFormData: o, updateKeyedFormData: a };
  }
  function Jke(e) {
    const { schema: t, uiSchema: n, errorSchema: r, fieldPathId: o, registry: i, formData: a, onChange: s } = e, { globalFormOptions: c, schemaUtils: u, translateString: d } = i, { keyedFormData: p, updateKeyedFormData: m } = Qke(a), g = e.childFieldPathId ?? o, y = T.useCallback((A, O) => {
      A && A.preventDefault();
      let P;
      if (r) {
        P = {};
        for (const L in r) {
          const N = parseInt(L);
          O === void 0 || N < O ? Qt(P, [N], r[L]) : N >= O && Qt(P, [N + 1], r[L]);
        }
      }
      const I = {
        key: IC(),
        item: Wke(i, t)
      }, $ = [...p];
      O !== void 0 ? $.splice(O, 0, I) : $.push(I), s(m($), g.path, P);
    }, [p, i, t, s, m, r, g]), b = T.useCallback((A, O) => {
      A && A.preventDefault();
      let P;
      if (r) {
        P = {};
        for (const L in r) {
          const N = parseInt(L);
          N <= O ? Qt(P, [N], r[L]) : N > O && Qt(P, [N + 1], r[L]);
        }
      }
      const I = {
        key: IC(),
        item: xA(p[O].item)
      }, $ = [...p];
      O !== void 0 ? $.splice(O + 1, 0, I) : $.push(I), s(m($), g.path, P);
    }, [p, s, m, r, g]), v = T.useCallback((A, O) => {
      A && A.preventDefault();
      let P;
      if (r) {
        P = {};
        for (const $ in r) {
          const L = parseInt($);
          L < O ? Qt(P, [L], r[$]) : L > O && Qt(P, [L - 1], r[$]);
        }
      }
      const I = p.filter(($, L) => L !== O);
      s(m(I), g.path, P);
    }, [p, s, m, r, g]), x = T.useCallback((A, O, P) => {
      A && (A.preventDefault(), A.currentTarget.blur());
      let I;
      if (r) {
        I = {};
        for (const N in r) {
          const U = parseInt(N);
          U == O ? Qt(I, [P], r[O]) : U == P ? Qt(I, [O], r[P]) : Qt(I, [N], r[U]);
        }
      }
      function $() {
        const N = p.slice();
        return N.splice(O, 1), N.splice(P, 0, p[O]), N;
      }
      const L = $();
      s(m(L), g.path, I);
    }, [p, s, m, r, g]), E = T.useCallback((A, O, P, I) => {
      s(
        // We need to treat undefined items as nulls to have validation.
        // See https://github.com/tdegrunt/jsonschema/issues/206
        A === void 0 ? null : A,
        O,
        P,
        I
      );
    }, [s]), _ = T.useCallback((A) => {
      s(A, g.path, void 0, g?.[rn]);
    }, [s, g]), C = {
      ...e,
      formData: a,
      fieldPathId: g,
      onSelectChange: _
    }, k = {
      ...e,
      handleAddItem: y,
      handleCopyItem: b,
      handleRemoveItem: v,
      handleReorderItems: x,
      keyedFormData: p,
      onChange: E
    };
    if (!(Cf in t)) {
      if (!c.useFallbackUiForUnsupportedType) {
        const O = Qe(n), P = tt("UnsupportedFieldTemplate", i, O);
        return S.jsx(P, { schema: t, fieldPathId: o, reason: d(bt.MissingItems), registry: i });
      }
      const A = { ...t, [Cf]: { type: void 0 } };
      C.schema = A, k.schema = A;
    }
    return u.isMultiSelect(C.schema) ? S.jsx(Gke, { ...C }) : aV(n) ? S.jsx(Kke, { ...C }) : gA(C.schema) ? S.jsx(Zke, { ...k }) : u.isFilesArray(C.schema, n) ? S.jsx(Yke, { ...C }) : S.jsx(Xke, { ...k });
  }
  function eTe(e) {
    const { schema: t, name: n, uiSchema: r, fieldPathId: o, formData: i, registry: a, required: s, disabled: c, readonly: u, hideError: d, autofocus: p, title: m, onChange: g, onFocus: y, onBlur: b, rawErrors: v } = e, { title: x } = t, { widgets: E, translateString: _, globalUiOptions: C } = a, {
      widget: k = "checkbox",
      title: A,
      // Unlike the other fields, don't use `getDisplayLabel()` since it always returns false for the boolean type
      label: O = !0,
      enumNames: P,
      ...I
    } = Qe(r, C), $ = Yi(t, k, E), L = _(bt.YesLabel), N = _(bt.NoLabel);
    let U;
    const j = A ?? x ?? m ?? n;
    if (Array.isArray(t.oneOf))
      U = Af({
        oneOf: t.oneOf.map((F) => {
          if ($t(F))
            return {
              ...F,
              title: F.title || (F.const === !0 ? L : N)
            };
        }).filter((F) => F)
        // cast away the error that typescript can't grok is fixed
      }, r);
    else {
      const F = t.enum ?? [!0, !1];
      !P && F.length === 2 && F.every((K) => typeof K == "boolean") ? U = [
        {
          value: F[0],
          label: F[0] ? L : N
        },
        {
          value: F[1],
          label: F[1] ? L : N
        }
      ] : U = Af({ enum: F }, r);
    }
    const V = T.useCallback((F, K, W) => g(F, o.path, K, W), [g, o]);
    return S.jsx($, { options: { ...I, enumOptions: U }, schema: t, uiSchema: r, id: o.$id, name: n, onChange: V, onFocus: y, onBlur: b, label: j, hideLabel: !O, value: i, required: s, disabled: c, readonly: u, hideError: d, registry: a, autofocus: p, rawErrors: v, htmlName: o.name });
  }
  function tTe(e) {
    return {
      type: "string",
      enum: ["string", "number", "boolean", "object", "array"],
      default: "string",
      title: e
    };
  }
  function nTe(e) {
    const t = typeof e;
    return t === "string" || t === "number" || t === "boolean" ? t : t === "object" ? Array.isArray(e) ? "array" : "object" : "string";
  }
  function rTe(e, t) {
    switch (t) {
      case "string":
        return String(e);
      case "number": {
        const n = Number(e);
        return isNaN(n) ? 0 : n;
      }
      case "boolean":
        return !!e;
      default:
        return e;
    }
  }
  function oTe(e) {
    const { id: t, formData: n, displayLabel: r = !0, schema: o, name: i, uiSchema: a, required: s, disabled: c = !1, readonly: u = !1, onBlur: d, onFocus: p, registry: m, fieldPathId: g, onChange: y, errorSchema: b } = e, { translateString: v, fields: x, globalFormOptions: E } = m, [_, C] = T.useState(nTe(n)), k = Qe(a), A = Ic(Do("__internal_type_selector", E, g)), O = v(bt.Type), P = T.useMemo(() => tTe(O), [O]), I = (N) => {
      N != null && (C(N), y(rTe(n, N), g.path, b, t));
    };
    if (!E.useFallbackUiForUnsupportedType) {
      const { reason: N = v(bt.UnknownFieldType, [String(o.type)]) } = e, U = tt("UnsupportedFieldTemplate", m, k);
      return S.jsx(U, { schema: o, fieldPathId: g, reason: N, registry: m });
    }
    const $ = tt("FallbackFieldTemplate", m, k), { SchemaField: L } = x;
    return S.jsx($, { schema: o, registry: m, typeSelector: S.jsx(L, { fieldPathId: A, name: `${i}__fallback_type`, schema: P, formData: _, onChange: I, onBlur: d, onFocus: p, registry: m, hideLabel: !r, disabled: c, readonly: u, required: s }, n ? $i(n) : "__empty__"), schemaField: S.jsx(L, { ...e, schema: {
      type: _,
      title: v(bt.Value),
      ..._ === "object" && { additionalProperties: !0 }
    } }) });
  }
  function iTe(e, t) {
    return Vf(t, function(n) {
      return e[n];
    });
  }
  function aTe(e) {
    return e == null ? [] : iTe(e, Ko(e));
  }
  var sTe = Math.max;
  function lTe(e, t, n, r) {
    e = Rc(e) ? e : aTe(e), n = n ? gU(n) : 0;
    var o = e.length;
    return n < 0 && (n = sTe(o + n, 0)), dl(e) ? n <= o && e.indexOf(t, n) > -1 : !!o && MU(e, t, n) > -1;
  }
  var cTe = Math.min;
  function uTe(e, t, n) {
    for (var r = fA, o = e[0].length, i = e.length, a = i, s = Array(i), c = 1 / 0, u = []; a--; ) {
      var d = e[a];
      c = cTe(d.length, c), s[a] = o >= 120 && d.length >= 120 ? new bc(a && d) : void 0;
    }
    d = e[0];
    var p = -1, m = s[0];
    e:
      for (; ++p < o && u.length < c; ) {
        var g = d[p], y = g;
        if (g = g !== 0 ? g : 0, !(m ? mh(m, y) : r(u, y))) {
          for (a = i; --a; ) {
            var b = s[a];
            if (!(b ? mh(b, y) : r(e[a], y)))
              continue e;
          }
          m && m.push(y), u.push(g);
        }
      }
    return u;
  }
  function fTe(e) {
    return yh(e) ? e : [];
  }
  var Y5 = y1(function(e) {
    var t = Vf(e, fTe);
    return t.length && t[0] === e[0] ? uTe(t) : [];
  });
  function NV(e) {
    return e === void 0;
  }
  var Di;
  (function(e) {
    e.ROW = "ui:row", e.COLUMN = "ui:col", e.COLUMNS = "ui:columns", e.CONDITION = "ui:condition";
  })(Di || (Di = {}));
  var Dp;
  (function(e) {
    e.ALL = "all", e.SOME = "some", e.NONE = "none";
  })(Dp || (Dp = {}));
  const dTe = /^\$lookup=(.+)/, B_ = "layoutGrid";
  function X5(e, t) {
    return e ?? t;
  }
  function pTe(e) {
    return /^\d+?$/.test(e);
  }
  const Js = wA();
  function hTe(e, t, n, r, o) {
    const i = Ee(n, [SC], {}), a = Ee(n, e), s = { ...Ee(a, [Zs], {}), ...t, ...i }, c = { ...a };
    Hn(s) || Qt(c, [Zs], s), Hn(i) || Qt(c, [SC], i);
    let { readonly: u } = Qe(c);
    return (o === !0 || NV(u) && r === !0) && (u = !0, Tt(s, l_) ? Qt(c, [Zs, l_], !0) : Qt(c, `ui:${l_}`, !0)), { fieldUiSchema: c, uiReadonly: u };
  }
  function mTe(e, t, n = "$0m3tH1nG Un3xP3cT3d") {
    const r = OC([t]).sort(), o = OC([n]).sort();
    switch (e) {
      case Dp.ALL:
        return gh(r, o);
      case Dp.SOME:
        return Y5(r, o).length > 0;
      case Dp.NONE:
        return Y5(r, o).length === 0;
      default:
        return !1;
    }
  }
  function k1(e, t, n) {
    let r = {}, o = e[t];
    if (fl(o)) {
      const { children: i, className: a, ...s } = o;
      if (o = i, a) {
        const u = a.split(" ").map((d) => EA(n, d, d)).join(" ");
        r = { ...s, className: u };
      } else
        r = s;
    }
    if (!Array.isArray(o))
      throw new TypeError(`Expected array for "${t}" in ${JSON.stringify(e)}`);
    return { children: o, gridProps: r };
  }
  function Z5(e, t, n) {
    let r;
    if (pTe(n) && e && e?.type === "array" && Tt(e, Cf)) {
      const o = Number(n), i = e[Cf];
      Array.isArray(i) ? o > i.length ? r = BU(i) : r = i[o] : r = i, t = {
        [rn]: t[rn],
        path: [...t.path.slice(0, t.path.length - 1), o]
      };
    }
    return { rawSchema: r, fieldPathId: t };
  }
  function gTe(e, t, n, r, o) {
    const { schemaUtils: i, globalFormOptions: a } = e;
    let s = n, c = o;
    const u = t.split("."), d = u.pop();
    let p = i.retrieveSchema(s, r), m = r, g = p.readOnly;
    u.forEach((v) => {
      if (c = Do(v, a, c), Tt(p, Ft))
        s = Ee(p, [Ft, v], {});
      else if (p && (Tt(p, yt) || Tt(p, Nt))) {
        const x = Tt(p, yt) ? yt : Nt, E = i.findSelectedOptionInXxxOf(p, v, x, m);
        s = Ee(E, [Ft, v], {});
      } else {
        const x = Z5(p, c, v);
        s = x.rawSchema ?? {}, c = x.fieldPathId;
      }
      m = Ee(m, v, {}), p = i.retrieveSchema(s, m), g = X5(p.readOnly, g);
    });
    let y, b = !1;
    if (Hn(p) && (p = void 0), p && d) {
      if (p && (Tt(p, yt) || Tt(p, Nt))) {
        const x = Tt(p, yt) ? yt : Nt;
        p = i.findSelectedOptionInXxxOf(p, d, x, m);
      }
      c = Do(d, a, c), b = p !== void 0 && Array.isArray(p.required) && lTe(p.required, d);
      const v = Z5(p, c, d);
      if (v.rawSchema ? (p = v.rawSchema, c = v.fieldPathId) : (p = Ee(p, [Ft, d]), p = p && i.retrieveSchema(p)), g = X5(p?.readOnly, g), p && (Tt(p, yt) || Tt(p, Nt))) {
        const x = Tt(p, yt) ? yt : Nt, E = Ki(p);
        y = { options: p[x], hasDiscriminator: !!E };
      }
    }
    return { schema: p, isRequired: b, isReadonly: g, optionsInfo: y, fieldPathId: c };
  }
  function yTe(e, t) {
    let n = e;
    return dl(n) && (n = EA(t, n)), sm(n) ? n : null;
  }
  function vTe(e, t) {
    let n, r = null, o = {}, i;
    if (dl(t) || NV(t))
      n = t ?? "";
    else {
      const { name: a = "", render: s, ...c } = t;
      n = a, o = c, Hn(o) || wCe(o, (u, d) => {
        if (dl(u)) {
          const p = dTe.exec(u);
          if (Array.isArray(p) && p.length > 1) {
            const m = p[1];
            o[d] = EA(e, m, m);
          }
        }
      }), r = yTe(s, e), !a && r && (i = S.jsx(r, { ...c, "data-testid": Js.uiComponent }));
    }
    return { name: n, UIComponent: r, uiProps: o, rendered: i };
  }
  function T1(e) {
    const { childrenLayoutGridSchemaId: t, ...n } = e, { registry: r, schema: o, formData: i } = n, { schemaUtils: a } = r, s = a.retrieveSchema(o, i);
    return t.map((c) => T.createElement(OA, { ...n, key: `layoutGrid-${$i(c)}`, schema: s, layoutGridSchema: c }));
  }
  function bTe(e) {
    const { layoutGridSchema: t, ...n } = e, { formData: r, registry: o } = n, { children: i, gridProps: a } = k1(t, Di.CONDITION, o), { operator: s, field: c = "", value: u } = a, d = Ee(r, c, null);
    return mTe(s, d, u) ? S.jsx(T1, { ...n, childrenLayoutGridSchemaId: i }) : null;
  }
  function xTe(e) {
    const { layoutGridSchema: t, ...n } = e, { registry: r, uiSchema: o } = n, { children: i, gridProps: a } = k1(t, Di.COLUMN, r), s = Qe(o), c = tt("GridTemplate", r, s);
    return S.jsx(c, { column: !0, "data-testid": Js.col, ...a, children: S.jsx(T1, { ...n, childrenLayoutGridSchemaId: i }) });
  }
  function wTe(e) {
    const { layoutGridSchema: t, ...n } = e, { registry: r, uiSchema: o } = n, { children: i, gridProps: a } = k1(t, Di.COLUMNS, r), s = Qe(o), c = tt("GridTemplate", r, s);
    return i.map((u) => S.jsx(c, { column: !0, "data-testid": Js.col, ...a, children: S.jsx(T1, { ...n, childrenLayoutGridSchemaId: [u] }) }, `column-${$i(u)}`));
  }
  function STe(e) {
    const { layoutGridSchema: t, ...n } = e, { registry: r, uiSchema: o } = n, { children: i, gridProps: a } = k1(t, Di.ROW, r), s = Qe(o), c = tt("GridTemplate", r, s);
    return S.jsx(c, { ...a, "data-testid": Js.row, children: S.jsx(T1, { ...n, childrenLayoutGridSchemaId: i }) });
  }
  function _Te(e) {
    const {
      gridSchema: t,
      schema: n,
      uiSchema: r,
      errorSchema: o,
      fieldPathId: i,
      onBlur: a,
      onFocus: s,
      formData: c,
      readonly: u,
      registry: d,
      layoutGridSchema: p,
      // Used to pull this out of otherProps since we don't want to pass it through
      ...m
    } = e, { onChange: g } = m, { fields: y } = d, { SchemaField: b, LayoutMultiSchemaField: v } = y, x = vTe(d, t), { name: E, UIComponent: _, uiProps: C } = x, { schema: k, isRequired: A, isReadonly: O, optionsInfo: P, fieldPathId: I } = gTe(d, E, n, c, i), $ = Ic(I);
    if (x.rendered)
      return x.rendered;
    if (k) {
      const L = P?.hasDiscriminator ? v : b, { fieldUiSchema: N, uiReadonly: U } = hTe(E, C, r, O, u);
      return S.jsx(L, { "data-testid": P?.hasDiscriminator ? Js.layoutMultiSchemaField : Js.field, ...m, name: E, required: A, readonly: U, schema: k, uiSchema: N, errorSchema: Ee(o, E), fieldPathId: $, formData: Ee(c, E), onChange: g, onBlur: a, onFocus: s, options: P?.options, registry: d });
    }
    return _ ? S.jsx(_, { "data-testid": Js.uiComponent, ...m, name: E, required: A, formData: c, readOnly: !!O || u, errorSchema: o, uiSchema: r, schema: n, fieldPathId: i, onBlur: a, onFocus: s, registry: d, ...C }) : null;
  }
  function OA(e) {
    const { uiSchema: t } = e;
    let { layoutGridSchema: n } = e;
    const r = Qe(t);
    if (!n && B_ in r && $t(r[B_]) && (n = r[B_]), $t(n)) {
      if (Di.ROW in n)
        return S.jsx(STe, { ...e, layoutGridSchema: n });
      if (Di.COLUMN in n)
        return S.jsx(xTe, { ...e, layoutGridSchema: n });
      if (Di.COLUMNS in n)
        return S.jsx(wTe, { ...e, layoutGridSchema: n });
      if (Di.CONDITION in n)
        return S.jsx(bTe, { ...e, layoutGridSchema: n });
    }
    return S.jsx(_Te, { ...e, gridSchema: n });
  }
  OA.TEST_IDS = Js;
  function ETe(e) {
    const { fieldPathId: t, title: n, schema: r, uiSchema: o, required: i, registry: a, name: s } = e, c = Qe(o, a.globalUiOptions), { title: u } = c, { title: d } = r, p = u || n || d || s;
    if (!p)
      return null;
    const m = tt("TitleFieldTemplate", a, c);
    return S.jsx(m, { id: x1(t), title: p, required: i, schema: r, uiSchema: o, registry: a });
  }
  function U_(e, t, n) {
    const r = "!@#!@$@#$!@$#";
    return e.map(({ schema: i }) => i).find((i) => {
      const a = Ee(i, [Ft, t]);
      return Ee(a, c1, Ee(a, Io, r)) === n;
    });
  }
  function Q5(e, t, n, r, o) {
    const i = t.map((c) => n.retrieveSchema(c, o));
    let a = e;
    Tt(e, yt) ? a = { ...e, [yt]: i } : Tt(e, Nt) && (a = { ...e, [Nt]: i });
    const s = Af(a, r);
    if (!s)
      throw new Error(`No enumOptions were computed from the schema ${JSON.stringify(a)}`);
    return s;
  }
  function CTe(e) {
    const { name: t, baseType: n, disabled: r = !1, formData: o, fieldPathId: i, onBlur: a, onChange: s, options: c, onFocus: u, registry: d, uiSchema: p, schema: m, autofocus: g, readonly: y, required: b, errorSchema: v, hideError: x = !1 } = e, { widgets: E, schemaUtils: _, globalUiOptions: C } = d, [k, A] = T.useState(Q5(m, c, _, p, o)), O = Ee(i, rn), P = Ki(m), I = tt("FieldErrorTemplate", d, c), $ = tt("FieldTemplate", d, c), L = $i(m), N = $i(c), U = p ? $i(p) : "", j = o ? $i(o) : "";
    T.useEffect(() => {
      A(Q5(m, c, _, p, o));
    }, [L, N, _, U, j]);
    const { widget: V = P ? "radio" : "select", title: F = "", placeholder: K = "", optionsSchemaSelector: W = P, hideError: Y, ...B } = Qe(p);
    if (!W)
      throw new Error("No selector field provided for the LayoutMultiSchemaField");
    const D = Ee(o, W);
    let G = Ee(k[0]?.schema, [Ft, W], {});
    const z = U_(k, W, D);
    G = G?.type ? G : { ...G, type: z?.type || n };
    const H = Yi(G, V, E), X = Y === void 0 ? x : !!Y, Q = Ee(v, [ur], []), ne = vh(v, [ur]), te = _.getDisplayLabel(m, p, C), se = (ee) => {
      const ie = U_(k, W, ee), le = U_(k, W, D);
      let ge = _.sanitizeDataForNewSchema(ie, le, o);
      ge && ie && (ge = _.getDefaultFormState(ie, ge, "excludeObjectChildren")), ge && Qt(ge, W, ee), s(ge, i.path, void 0, O);
    }, ue = { enumOptions: k, ...B }, J = !X && Q.length > 0 ? S.jsx(I, { fieldPathId: i, schema: m, errors: Q, registry: d }) : void 0;
    return S.jsx($, { id: O, schema: m, label: (F || m.title) ?? "", disabled: r || Array.isArray(k) && Hn(k), uiSchema: p, required: b, readonly: !!y, registry: d, displayLabel: te, errors: J, onChange: s, onKeyRename: qv, onKeyRenameBlur: qv, onRemoveProperty: qv, children: S.jsx(H, { id: O, name: t, schema: m, label: (F || m.title) ?? "", disabled: r || Array.isArray(k) && Hn(k), uiSchema: p, autofocus: g, readonly: y, required: b, registry: d, multiple: !1, rawErrors: Q, hideError: X, hideLabel: !te, errorSchema: ne, placeholder: K, onChange: se, onBlur: a, onFocus: u, value: D, options: ue, htmlName: i.name }) });
  }
  class J5 extends T.Component {
    /** Constructs an `AnyOfField` with the given `props` to initialize the initially selected option in state
     *
     * @param props - The `FieldProps` for this template
     */
    constructor(n) {
      super(n);
      /** Callback handler to remember what the currently selected option is. In addition to that the `formData` is updated
       * to remove properties that are not part of the newly selected option schema, and then the updated data is passed to
       * the `onChange` handler.
       *
       * @param option - The new option value being selected
       */
      Kn(this, "onOptionChange", (n) => {
        const { selectedOption: r, retrievedOptions: o } = this.state, { formData: i, onChange: a, registry: s, fieldPathId: c } = this.props, { schemaUtils: u } = s, d = n !== void 0 ? parseInt(n, 10) : -1;
        if (d === r)
          return;
        const p = d >= 0 ? o[d] : void 0, m = r >= 0 ? o[r] : void 0;
        let g = u.sanitizeDataForNewSchema(p, m, i);
        p && (g = u.getDefaultFormState(p, g, "excludeObjectChildren")), this.setState({ selectedOption: d }, () => {
          a(g, c.path, void 0, this.getFieldId());
        });
      });
      const { formData: r, options: o, registry: { schemaUtils: i } } = this.props, a = o.map((s) => i.retrieveSchema(s, r));
      this.state = {
        retrievedOptions: a,
        selectedOption: this.getMatchingOption(0, r, a)
      };
    }
    /** React lifecycle method that is called when the props and/or state for this component is updated. It recomputes the
     * currently selected option based on the overall `formData`
     *
     * @param prevProps - The previous `FieldProps` for this template
     * @param prevState - The previous `AnyOfFieldState` for this template
     */
    componentDidUpdate(n, r) {
      const { formData: o, options: i, fieldPathId: a } = this.props, { selectedOption: s } = this.state;
      let c = this.state;
      if (!pn(n.options, i)) {
        const { registry: { schemaUtils: u } } = this.props, d = i.map((p) => u.retrieveSchema(p, o));
        c = { selectedOption: s, retrievedOptions: d };
      }
      if (!pn(o, n.formData) && a.$id === n.fieldPathId.$id) {
        const { retrievedOptions: u } = c, d = this.getMatchingOption(s, o, u);
        r && d !== s && (c = { selectedOption: d, retrievedOptions: u });
      }
      c !== this.state && this.setState(c);
    }
    /** Determines the best matching option for the given `formData` and `options`.
     *
     * @param formData - The new formData
     * @param options - The list of options to choose from
     * @return - The index of the `option` that best matches the `formData`
     */
    getMatchingOption(n, r, o) {
      const { schema: i, registry: { schemaUtils: a } } = this.props, s = Ki(i);
      return a.getClosestMatchingOption(r, o, n, s);
    }
    getFieldId() {
      const { fieldPathId: n, schema: r } = this.props;
      return `${n.$id}${r.oneOf ? "__oneof_select" : "__anyof_select"}`;
    }
    /** Renders the `AnyOfField` selector along with a `SchemaField` for the value of the `formData`
     */
    render() {
      const { name: n, disabled: r = !1, errorSchema: o = {}, formData: i, onBlur: a, onFocus: s, readonly: c, required: u = !1, registry: d, schema: p, uiSchema: m } = this.props, { widgets: g, fields: y, translateString: b, globalUiOptions: v, schemaUtils: x } = d, { SchemaField: E } = y, _ = tt("MultiSchemaFieldTemplate", d, v), C = pm(d, p, u, m), k = Wf(i), { selectedOption: A, retrievedOptions: O } = this.state, { widget: P = "select", placeholder: I, autofocus: $, autocomplete: L, title: N = p.title, ...U } = Qe(m, v), j = Yi({ type: "number" }, P, g), V = Ee(o, ur, []), F = vh(o, [ur]), K = x.getDisplayLabel(p, m, v), W = A >= 0 && O[A] || null;
      let Y;
      if (W) {
        const { required: ne } = p;
        Y = ne ? Za({ required: ne }, W) : W;
      }
      let B = [];
      yt in p && m && yt in m ? Array.isArray(m[yt]) ? B = m[yt] : console.warn(`uiSchema.oneOf is not an array for "${N || n}"`) : Nt in p && m && Nt in m && (Array.isArray(m[Nt]) ? B = m[Nt] : console.warn(`uiSchema.anyOf is not an array for "${N || n}"`));
      let D = m;
      A >= 0 && B.length > A && (D = B[A]);
      const G = N ? bt.TitleOptionPrefix : bt.OptionPrefix, z = N ? [N] : [], H = O.map((ne, te) => {
        const { title: se = ne.title } = Qe(B[te]);
        return {
          label: se || b(G, z.concat(String(te + 1))),
          value: te
        };
      }), X = !C || k ? S.jsx(j, { id: this.getFieldId(), name: `${n}${p.oneOf ? "__oneof_select" : "__anyof_select"}`, schema: { type: "number", default: 0 }, onChange: this.onOptionChange, onBlur: a, onFocus: s, disabled: r || Hn(H), multiple: !1, rawErrors: V, errorSchema: F, value: A >= 0 ? A : void 0, options: { enumOptions: H, ...U }, registry: d, placeholder: I, autocomplete: L, autofocus: $, label: N ?? n, hideLabel: !K, readonly: c }) : void 0, Q = Y && Y.type !== "null" && S.jsx(E, { ...this.props, schema: Y, uiSchema: D }) || null;
      return S.jsx(_, { schema: p, registry: d, uiSchema: m, selector: X, optionSchemaField: Q });
    }
  }
  const kTe = /\.([0-9]*0)*$/, TTe = /[0.]0*$/;
  function ATe(e) {
    const { registry: t, onChange: n, formData: r, value: o } = e, [i, a] = T.useState(o), { StringField: s } = t.fields;
    let c = r;
    const u = T.useCallback((d, p, m, g) => {
      a(d), `${d}`.charAt(0) === "." && (d = `0${d}`);
      const y = typeof d == "string" && d.match(kTe) ? Tj(d.replace(TTe, "")) : Tj(d);
      n(y, p, m, g);
    }, [n]);
    if (typeof i == "string" && typeof c == "number") {
      const d = new RegExp(`^(${String(c).replace(".", "\\.")})?\\.?0*$`);
      i.match(d) && (c = i);
    }
    return S.jsx(s, { ...e, formData: c, onChange: u });
  }
  function Ai() {
    return Ai = Object.assign ? Object.assign.bind() : function(e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = arguments[t];
        for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
      }
      return e;
    }, Ai.apply(null, arguments);
  }
  const cv = ["strong", "em", "del", "mark"], e3 = [["**", cv[0]], ["__", cv[0]], ["~~", cv[2]], ["==", cv[3]], ["*", "em"], ["_", "em"]];
  function RTe(e, t) {
    for (var n = 1, r = t + 1; r < e.length && n > 0; ) e[r] !== "\\" ? (e[r] === "[" && n++, e[r] === "]" && n--, r++) : r += 2;
    if (n === 0 && r < e.length && (e[r] === "(" || e[r] === "[")) {
      var o = e[r] === "(" ? ")" : "]", i = 1;
      for (r++; r < e.length && i > 0; ) e[r] !== "\\" ? (e[r] === "(" && o === ")" && i++, e[r] === o && i--, r++) : r += 2;
      if (i === 0) return r;
    }
    return -1;
  }
  function OTe(e, t) {
    if (!t || !t.inline && !t.simple) return null;
    var n = e[0];
    if (n !== "*" && n !== "_" && n !== "~" && n !== "=") return null;
    for (var r = "", o = 0, i = "", a = 0; a < 6; a++) {
      var s = e3[a][0];
      if (e.startsWith(s) && e.length >= 2 * s.length) {
        r = s, o = s.length, i = e3[a][1];
        break;
      }
    }
    if (!r) return null;
    for (var c = o, u = !1, d = !1, p = "", m = 0, g = "", y = !1, b = ""; c < e.length; ) {
      var v = e[c];
      if (y) g += v, y = !1, b = v, c++;
      else if (v !== "\\") if (v !== "`" || m !== 0) {
        if (v === "[" && !u && m === 0) {
          var x = RTe(e, c);
          if (x !== -1) {
            g += e.slice(c, x), c = x, b = e[x - 1];
            continue;
          }
        }
        if (d) g += v, p ? v === p && (p = "") : v === '"' || v === "'" ? p = v : v === ">" && (d = !1), b = v, c++;
        else if (v !== "<" || u) {
          if (v === `
` && b === `
` && !u && m === 0) return null;
          if (!u && m === 0) {
            for (var E = 0; c + E < e.length && e[c + E] === r[0]; ) E++;
            if (E >= o && (o !== 1 || r !== "*" && r !== "_" || e[c - 1] !== r && e[c + 1] !== r)) {
              var _ = [e.slice(0, c + E), i, g + e.slice(c + o, c + E)];
              return _.index = 0, _.input = e, _;
            }
          }
          g += v, b = v, c++;
        } else {
          var C = e[c + 1], k = e.indexOf(">", c);
          if (k !== -1) {
            var A = e.slice(c, k + 1).endsWith("/>");
            C === "/" ? m = Math.max(0, m - 1) : A || m++;
          }
          d = !0, g += v, b = v, c++;
        }
      } else u = !u, g += v, b = v, c++;
      else g += v, y = !0, b = v, c++;
    }
    return null;
  }
  const MTe = ["children", "options"], t3 = ["allowFullScreen", "allowTransparency", "autoComplete", "autoFocus", "autoPlay", "cellPadding", "cellSpacing", "charSet", "classId", "colSpan", "contentEditable", "contextMenu", "crossOrigin", "encType", "formAction", "formEncType", "formMethod", "formNoValidate", "formTarget", "frameBorder", "hrefLang", "inputMode", "keyParams", "keyType", "marginHeight", "marginWidth", "maxLength", "mediaGroup", "minLength", "noValidate", "radioGroup", "readOnly", "rowSpan", "spellCheck", "srcDoc", "srcLang", "srcSet", "tabIndex", "useMap"].reduce((e, t) => (e[t.toLowerCase()] = t, e), { class: "className", for: "htmlFor" }), n3 = { amp: "&", apos: "'", gt: ">", lt: "<", nbsp: "", quot: "" }, NTe = ["style", "script", "pre"], PTe = ["src", "href", "data", "formAction", "srcDoc", "action"], ITe = /([-A-Z0-9_:]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|(?:\{((?:\\.|{[^}]*?}|[^}])*)\})))?/gi, $Te = /\n{2,}$/, r3 = /^(\s*>[\s\S]*?)(?=\n\n|$)/, jTe = /^ *> ?/gm, DTe = /^(?:\[!([^\]]*)\]\n)?([\s\S]*)/, FTe = /^ {2,}\n/, LTe = /^(?:([-*_])( *\1){2,}) *(?:\n *)+\n/, o3 = /^(?: {1,3})?(`{3,}|~{3,}) *(\S+)? *([^\n]*?)?\n([\s\S]*?)(?:\1\n?|$)/, i3 = /^(?: {4}[^\n]+\n*)+(?:\n *)+\n?/, zTe = /^(`+)((?:\\`|(?!\1)`|[^`])+)\1/, BTe = /^(?:\n *)*\n/, UTe = /\r\n?/g, VTe = /^\[\^([^\]]+)](:(.*)((\n+ {4,}.*)|(\n(?!\[\^).+))*)/, HTe = /^\[\^([^\]]+)]/, qTe = /\f/g, WTe = /^---[ \t]*\n(.|\n)*\n---[ \t]*\n/, GTe = /^\[(x|\s)\]/, a3 = /^(#{1,6}) *([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, s3 = /^ *(#{1,6}) +([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/, l3 = /^([^\n]+)\n *(=|-)\2{2,} *\n/, MA = /^<([a-z][^ >/]*) ?((?:[^>]*[^/])?)>/i;
  function KTe(e) {
    const t = MA.exec(e);
    if (!t) return null;
    const n = t[1], r = n.toLowerCase(), o = r.length + 1;
    let i = t[0].length;
    e[i] === `
` && i++;
    const a = i;
    let s = i, c = 1;
    const u = e.length;
    for (; c > 0; ) {
      const p = e.indexOf("<", i);
      if (p === -1) return null;
      let m = -1, g = -1;
      if (e[p + 1] === "/") g = p;
      else if (e[p + 1] === r[0] || e[p + 1] === n[0]) {
        let y = !0;
        for (let b = 0; b < r.length; b++) {
          const v = e[p + 1 + b];
          if (v !== r[b] && v !== n[b]) {
            y = !1;
            break;
          }
        }
        !y || e[p + o] !== " " && e[p + o] !== ">" || (m = p);
      }
      if (m !== -1 || g !== -1) if (m !== -1 && (g === -1 || m < g)) i = m + o + 1, c++;
      else {
        let y = g + 2;
        for (; y < u; ) {
          const v = e[y];
          if (v !== " " && v !== "	" && v !== `
` && v !== "\r") break;
          y++;
        }
        if (y + r.length > u) return null;
        let b = !0;
        for (let v = 0; v < r.length; v++) {
          const x = e[y + v];
          if (x !== r[v] && x !== n[v]) {
            b = !1;
            break;
          }
        }
        if (!b) {
          i = y;
          continue;
        }
        for (y += r.length; y < u; ) {
          const v = e[y];
          if (v !== " " && v !== "	" && v !== `
` && v !== "\r") break;
          y++;
        }
        if (y >= u || e[y] !== ">") {
          i = y;
          continue;
        }
        s = g, i = y + 1, c--;
      }
      else i = p + 1;
    }
    let d = 0;
    for (; i + d < u && e[i + d] === `
`; ) d++;
    return [e.slice(0, i + d), n, t[2], e.slice(a, s)];
  }
  const YTe = /&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi, c3 = /^<!--[\s\S]*?(?:-->)/, XTe = /^(data|aria|x)-[a-z_][a-z\d_.-]*$/, $C = /^ *<([a-z][a-z0-9:]*)(?:\s+((?:<.*?>|[^>])*))?\/?>(?!<\/\1>)(\s*\n)?/i, ZTe = /^\{.*\}$/, QTe = /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/, JTe = /^<([^ >]+[:@\/][^ >]+)>/, eAe = /-([a-z])?/gi, u3 = /^(\|.*)\n(?: *(\|? *[-:]+ *\|[-| :]*)\n((?:.*\|.*\n)*))?\n?/, tAe = /^[^\n]+(?:  \n|\n{2,})/, nAe = /^\[([^\]]*)\]:\s+<?([^\s>]+)>?\s*("([^"]*)")?/, rAe = /^!\[([^\]]*)\] ?\[([^\]]*)\]/, oAe = /^\[([^\]]*)\] ?\[([^\]]*)\]/, iAe = /(\n|^[-*]\s|^#|^ {2,}|^-{2,}|^>\s)/, aAe = /\t/g, sAe = /(^ *\||\| *$)/g, lAe = /^ *:-+: *$/, cAe = /^ *:-+ *$/, uAe = /^ *-+: *$/, fAe = /^(:[a-zA-Z0-9-_]+:)/, dAe = /^\\([^0-9A-Za-z\s])/, pAe = /\\([^0-9A-Za-z\s])/g, hAe = /^[\s\S](?:(?!  \n|[0-9]\.|http)[^=*_~\-\n:<`\\\[!])*/, mAe = /^\n+/, gAe = /^([ \t]*)/, yAe = /(?:^|\n)( *)$/, NA = "(?:\\d+\\.)", PA = "(?:[*+-])";
  function PV(e) {
    return "( *)(" + (e === 1 ? NA : PA) + ") +";
  }
  const IV = PV(1), $V = PV(2);
  function jV(e) {
    return RegExp("^" + (e === 1 ? IV : $V));
  }
  const vAe = jV(1), bAe = jV(2);
  function DV(e) {
    return RegExp("^" + (e === 1 ? IV : $V) + "[^\\n]*(?:\\n(?!\\1" + (e === 1 ? NA : PA) + " )[^\\n]*)*(\\n|$)", "gm");
  }
  const xAe = DV(1), wAe = DV(2);
  function FV(e) {
    const t = e === 1 ? NA : PA;
    return RegExp("^( *)(" + t + ") [\\s\\S]+?(?:\\n{2,}(?! )(?!\\1" + t + " (?!" + t + " ))\\n*|\\s*\\n*$)");
  }
  const LV = FV(1), zV = FV(2);
  function f3(e, t) {
    const n = t === 1, r = n ? LV : zV, o = n ? xAe : wAe, i = n ? vAe : bAe;
    return { t: (a) => i.test(a), o: Ys(function(a, s) {
      const c = yAe.exec(s.prevCapture);
      return c && (s.list || !s.inline && !s.simple) ? r.exec(a = c[1] + a) : null;
    }), u: 1, i(a, s, c) {
      const u = n ? +a[2] : void 0, d = a[0].replace($Te, `
`).match(o), p = i.exec(d[0]), m = RegExp("^ {1," + (p ? p[0].length : 0) + "}", "gm");
      let g = !1;
      return { items: d.map(function(y, b) {
        const v = y.replace(m, "").replace(i, ""), x = b === d.length - 1, E = xi(v, `

`) || x && g;
        g = E;
        const _ = c.inline, C = c.list;
        let k;
        c.list = !0, E ? (c.inline = !1, k = Fp(v) + `

`) : (c.inline = !0, k = Fp(v));
        const A = s(k, c);
        return c.inline = _, c.list = C, A;
      }), ordered: n, start: u };
    } };
  }
  const SAe = RegExp(`^\\[((?:\\[[^\\[\\]]*(?:\\[[^\\[\\]]*\\][^\\[\\]]*)*\\]|[^\\[\\]])*)\\]\\(\\s*<?((?:\\([^)]*\\)|[^\\s\\\\]|\\\\.)*?)>?(?:\\s+['"]([\\s\\S]*?)['"])?\\s*\\)`), _Ae = /^!\[(.*?)\]\( *((?:\([^)]*\)|[^() ])*) *"?([^)"]*)?"?\)/;
  function d3(e) {
    return typeof e == "string";
  }
  function Fp(e) {
    let t = e.length;
    for (; t > 0 && e[t - 1] <= " "; ) t--;
    return e.slice(0, t);
  }
  function jC(e, t) {
    return e.startsWith(t);
  }
  function xi(e, t) {
    return e.indexOf(t) !== -1;
  }
  function EAe(e, t, n) {
    if (Array.isArray(n)) {
      for (let r = 0; r < n.length; r++) if (jC(e, n[r])) return !0;
      return !1;
    }
    return n(e, t);
  }
  function rp(e) {
    return e.replace(/[]/g, "a").replace(/[]/g, "c").replace(/[]/g, "d").replace(/[]/g, "e").replace(/[]/g, "i").replace(/[]/g, "n").replace(/[]/g, "o").replace(/[]/g, "u").replace(/[]/g, "y").replace(/[^a-z0-9- ]/gi, "").replace(/ /gi, "-").toLowerCase();
  }
  function CAe(e) {
    return uAe.test(e) ? "right" : lAe.test(e) ? "center" : cAe.test(e) ? "left" : null;
  }
  function p3(e, t, n, r) {
    const o = n.inTable;
    n.inTable = !0;
    let i = [[]], a = "";
    function s() {
      if (!a) return;
      const c = i[i.length - 1];
      c.push.apply(c, t(a, n)), a = "";
    }
    return e.trim().split(/(`[^`]*`|\\\||\|)/).filter(Boolean).forEach((c, u, d) => {
      c.trim() === "|" && (s(), r) ? u !== 0 && u !== d.length - 1 && i.push([]) : a += c;
    }), s(), n.inTable = o, i;
  }
  function kAe(e, t, n) {
    n.inline = !0;
    const r = e[2] ? e[2].replace(sAe, "").split("|").map(CAe) : [], o = e[3] ? (function(a, s, c) {
      return a.trim().split(`
`).map(function(u) {
        return p3(u, s, c, !0);
      });
    })(e[3], t, n) : [], i = p3(e[1], t, n, !!o.length);
    return n.inline = !1, o.length ? { align: r, cells: o, header: i, type: "25" } : { children: i, type: "21" };
  }
  function h3(e, t) {
    return e.align[t] == null ? {} : { textAlign: e.align[t] };
  }
  function Ys(e) {
    return e.inline = 1, e;
  }
  function Ls(e) {
    return Ys(function(t, n) {
      return n.inline ? e.exec(t) : null;
    });
  }
  function uv(e) {
    return Ys(function(t, n) {
      return n.inline || n.simple ? e.exec(t) : null;
    });
  }
  function Pa(e) {
    return function(t, n) {
      return n.inline || n.simple ? null : e.exec(t);
    };
  }
  function m3(e) {
    return Ys(function(t) {
      return e.exec(t);
    });
  }
  const TAe = /(javascript|vbscript|data(?!:image)):/i;
  function AAe(e) {
    try {
      const t = decodeURIComponent(e).replace(/[^A-Za-z0-9/:]/g, "");
      if (TAe.test(t)) return null;
    } catch {
      return null;
    }
    return e;
  }
  function Si(e) {
    return e && e.replace(pAe, "$1");
  }
  function Yv(e, t, n) {
    const r = n.inline || !1, o = n.simple || !1;
    n.inline = !0, n.simple = !0;
    const i = e(t, n);
    return n.inline = r, n.simple = o, i;
  }
  function RAe(e, t, n) {
    const r = n.inline || !1, o = n.simple || !1;
    n.inline = !1, n.simple = !0;
    const i = e(t, n);
    return n.inline = r, n.simple = o, i;
  }
  function OAe(e, t, n) {
    const r = n.inline || !1;
    n.inline = !1;
    const o = e(t, n);
    return n.inline = r, o;
  }
  const MAe = (e, t, n) => ({ children: Yv(t, e[2], n) });
  function V_() {
    return {};
  }
  function NAe(...e) {
    return e.filter(Boolean).join(" ");
  }
  function H_(e, t, n) {
    let r = e;
    const o = t.split(".");
    for (; o.length && (r = r[o[0]], r !== void 0); ) o.shift();
    return r || n;
  }
  function q_(e, t, n, r) {
    if (!t || !t.trim()) return null;
    const o = t.match(ITe);
    return o ? o.reduce(function(i, a) {
      const s = a.indexOf("=");
      if (s !== -1) {
        const c = (function(p) {
          return p.indexOf("-") !== -1 && p.match(XTe) === null && (p = p.replace(eAe, function(m, g) {
            return g.toUpperCase();
          })), p;
        })(a.slice(0, s)).trim(), u = t3[c] || c;
        if (u === "ref") return i;
        const d = i[u] = (function(p, m, g, y) {
          return m === "style" ? (function(b) {
            const v = [];
            if (!b) return v;
            let x = "", E = 0, _ = "";
            for (let k = 0; k < b.length; k++) {
              const A = b[k];
              if (A === '"' || A === "'") _ ? A === _ && (_ = "", E--) : (_ = A, E++);
              else if (A === "(" && x.endsWith("url")) E++;
              else if (A === ")" && E > 0) E--;
              else if (A === ";" && E === 0) {
                const O = x.indexOf(":");
                O > 0 && v.push([x.slice(0, O).trim(), x.slice(O + 1).trim()]), x = "";
                continue;
              }
              x += A;
            }
            const C = x.indexOf(":");
            return C > 0 && v.push([x.slice(0, C).trim(), x.slice(C + 1).trim()]), v;
          })(g).reduce(function(b, [v, x]) {
            return b[v.replace(/(-[a-z])/g, (E) => E[1].toUpperCase())] = y(x, p, v), b;
          }, {}) : PTe.indexOf(m) !== -1 ? y(Si(g), p, m) : (g.match(ZTe) && (g = Si(g.slice(1, g.length - 1))), g === "true" || g !== "false" && g);
        })(e, c, (function(p) {
          const m = p[0];
          return (m === '"' || m === "'") && p.length >= 2 && p[p.length - 1] === m ? p.slice(1, -1) : p;
        })(a.slice(s + 1).trim()), n);
        typeof d == "string" && (MA.test(d) || $C.test(d)) && (i[u] = r(d.trim()));
      } else a !== "style" && (i[t3[a] || a] = !0);
      return i;
    }, {}) : null;
  }
  function g3(e, t) {
    for (let n = 0; n < e.length; n++) if (e[n].test(t)) return !0;
    return !1;
  }
  function PAe(e = "", t = {}) {
    t.overrides = t.overrides || {}, t.namedCodesToUnicode = t.namedCodesToUnicode ? Ai({}, n3, t.namedCodesToUnicode) : n3;
    const n = t.slugify || rp, r = t.sanitizer || AAe, o = t.createElement || T.createElement, i = [r3, o3, i3, t.enforceAtxHeadings ? s3 : a3, l3, u3, LV, zV], a = [...i, tAe, MA, c3, $C];
    function s(y, b, ...v) {
      const x = H_(t.overrides, y + ".props", {});
      return o((function(E, _) {
        const C = H_(_, E);
        return C ? typeof C == "function" || typeof C == "object" && "render" in C ? C : H_(_, E + ".component", E) : E;
      })(y, t.overrides), Ai({}, b, x, { className: NAe(b?.className, x.className) || void 0 }), ...v);
    }
    function c(y) {
      y = y.replace(WTe, "");
      let b = !1;
      t.forceInline ? b = !0 : t.forceBlock || (b = iAe.test(y) === !1);
      const v = m(b ? y : Fp(y).replace(mAe, "") + `

`, { inline: b });
      if (t.ast) return v;
      const x = g(v);
      for (; d3(x[x.length - 1]) && !x[x.length - 1].trim(); ) x.pop();
      if (u.length && x.push(s("footer", { key: "footer" }, u.map(function(C) {
        return s("div", { id: n(C.identifier, rp), key: C.identifier }, C.identifier, g(m(C.footnote, { inline: !0 })));
      }))), t.wrapper === null) return x;
      const E = t.wrapper || (b ? "span" : "div");
      let _;
      if (x.length > 1 || t.forceWrapper) _ = x;
      else {
        if (x.length === 1) return _ = x[0], typeof _ == "string" ? s("span", { key: "outer" }, _) : _;
        _ = null;
      }
      return o(E, Ai({ key: "outer" }, t.wrapperProps), _);
    }
    const u = [], d = {}, p = { 0: { t: [">"], o: Pa(r3), u: 1, i(y, b, v) {
      const [, x, E] = y[0].replace(jTe, "").match(DTe);
      return { alert: x, children: b(E, v) };
    } }, 1: { t: ["  "], o: Ls(FTe), u: 1, i: V_ }, 2: { t: function(y, b) {
      if (b.inline || b.simple) return !1;
      var v = y[0];
      return v === "-" || v === "*" || v === "_";
    }, o: Pa(LTe), u: 1, i: V_ }, 3: { t: ["    "], o: Pa(i3), u: 0, i: (y) => ({ lang: void 0, text: Si(Fp(y[0].replace(/^ {4}/gm, ""))) }) }, 4: { t: ["```", "~~~"], o: Pa(o3), u: 0, i: (y) => ({ attrs: q_("code", y[3] || "", r, c), lang: y[2] || void 0, text: y[4], type: "3" }) }, 5: { t: ["`"], o: uv(zTe), u: 3, i: (y) => ({ text: Si(y[2]) }) }, 6: { t: ["[^"], o: Pa(VTe), u: 0, i: (y) => (u.push({ footnote: y[2], identifier: y[1] }), {}) }, 7: { t: ["[^"], o: Ls(HTe), u: 1, i: (y) => ({ target: "#" + n(y[1], rp), text: y[1] }) }, 8: { t: ["[ ]", "[x]"], o: Ls(GTe), u: 1, i: (y) => ({ completed: y[1].toLowerCase() === "x" }) }, 9: { t: ["#"], o: Pa(t.enforceAtxHeadings ? s3 : a3), u: 1, i: (y, b, v) => ({ children: Yv(b, y[2], v), id: n(y[2], rp), level: y[1].length }) }, 10: { t: (y) => {
      const b = y.indexOf(`
`);
      return b > 0 && b < y.length - 1 && (y[b + 1] === "=" || y[b + 1] === "-");
    }, o: Pa(l3), u: 1, i: (y, b, v) => ({ children: Yv(b, y[1], v), level: y[2] === "=" ? 1 : 2, type: "9" }) }, 11: { t: ["<"], o: Ys(KTe), u: 1, i(y, b, v) {
      const [, x] = y[3].match(gAe), E = RegExp("^" + x, "gm"), _ = y[3].replace(E, ""), C = g3(a, _) ? OAe : Yv, k = y[1].toLowerCase(), A = NTe.indexOf(k) !== -1, O = (A ? k : y[1]).trim(), P = { attrs: q_(O, y[2], r, c), noInnerParse: A, tag: O };
      if (v.inAnchor = v.inAnchor || k === "a", A) P.text = y[3];
      else {
        const I = v.inHTML;
        v.inHTML = !0, P.children = C(b, _, v), v.inHTML = I;
      }
      return v.inAnchor = !1, P;
    } }, 13: { t: ["<"], o: m3($C), u: 1, i(y) {
      const b = y[1].trim();
      return { attrs: q_(b, y[2] || "", r, c), tag: b };
    } }, 12: { t: ["<!--"], o: m3(c3), u: 1, i: () => ({}) }, 14: { t: ["!["], o: uv(_Ae), u: 1, i: (y) => ({ alt: Si(y[1]), target: Si(y[2]), title: Si(y[3]) }) }, 15: { t: ["["], o: Ls(SAe), u: 3, i: (y, b, v) => ({ children: RAe(b, y[1], v), target: Si(y[2]), title: Si(y[3]) }) }, 16: { t: function(y, b) {
      return !(!b.inline || b.inAnchor) && y[0] === "<" && (xi(y, ":") || xi(y, "@") || xi(y, "/"));
    }, o: Ls(JTe), u: 0, i(y) {
      let b = y[1], v = !1;
      return xi(b, "@") && !xi(b, "//") && (v = !0, b = b.replace("mailto:", "")), { children: [{ text: b, type: "27" }], target: v ? "mailto:" + b : b, type: "15" };
    } }, 17: { t: (y, b) => !b.inAnchor && !t.disableAutoLink && jC(y, "http"), o: Ls(QTe), u: 0, i: (y) => ({ children: [{ text: y[1], type: "27" }], target: y[1], title: void 0, type: "15" }) }, 20: f3(0, 1), 30: f3(0, 2), 19: { t: [`
`], o: Pa(BTe), u: 3, i: V_ }, 21: { t: function(y, b) {
      return !b.inline && !b.simple;
    }, o: Ys(function(y, b) {
      if (b.inline || b.simple || b.inHTML && !xi(y, `

`) && !xi(b.prevCapture, `

`)) return null;
      let v = "", x = 0;
      for (; ; ) {
        const _ = y.indexOf(`
`, x), C = y.slice(x, _ === -1 ? void 0 : _ + 1), k = y[x];
        if ((k === ">" || k === "#" || k === "|" || k === "`" || k === "~" || k === "*" || k === "-" || k === "_" || k === " ") && g3(i, C) || (v += C, _ === -1 || !C.trim())) break;
        x = _ + 1;
      }
      const E = Fp(v);
      return E === "" ? null : [v, , E];
    }), u: 3, i: MAe }, 22: { t: ["["], o: Ls(nAe), u: 0, i: (y) => (d[y[1]] = { target: y[2], title: y[4] }, {}) }, 23: { t: ["!["], o: uv(rAe), u: 0, i: (y) => ({ alt: y[1] ? Si(y[1]) : void 0, ref: y[2] }) }, 24: { t: (y) => y[0] === "[" && !xi(y, "]("), o: Ls(oAe), u: 0, i: (y, b, v) => ({ children: b(y[1], v), fallbackChildren: y[0], ref: y[2] }) }, 25: { t: ["|"], o: Pa(u3), u: 1, i: kAe }, 27: { o: Ys(function(y, b) {
      let v;
      return jC(y, ":") && (v = fAe.exec(y)), v || hAe.exec(y);
    }), u: 4, i(y) {
      const b = y[0];
      return { text: xi(b, "&") ? b.replace(YTe, (v, x) => t.namedCodesToUnicode[x] || v) : b };
    } }, 34: { t: ["*", "_", "~", "="], o: Ys(OTe), u: 2, i: (y, b, v) => ({ children: b(y[2], v), tag: y[1] }) }, 28: { t: ["\\"], o: uv(dAe), u: 1, i: (y) => ({ text: y[1], type: "27" }) } };
    t.disableParsingRawHTML === !0 && (delete p[11], delete p[13]);
    const m = (function(y) {
      var b = Object.keys(y);
      function v(x, E) {
        var _ = [];
        if (E.prevCapture = E.prevCapture || "", x.trim()) for (; x; ) for (var C = 0; C < b.length; ) {
          var k = b[C], A = y[k];
          if (!A.t || EAe(x, E, A.t)) {
            var O = A.o(x, E);
            if (O && O[0]) {
              x = x.substring(O[0].length);
              var P = A.i(O, v, E);
              E.prevCapture += O[0], P.type || (P.type = k), _.push(P);
              break;
            }
            C++;
          } else C++;
        }
        return E.prevCapture = "", _;
      }
      return b.sort(function(x, E) {
        return y[x].u - y[E].u || (x < E ? -1 : 1);
      }), function(x, E) {
        return v((function(_) {
          return _.replace(UTe, `
`).replace(qTe, "").replace(aAe, "    ");
        })(x), E);
      };
    })(p), g = /* @__PURE__ */ (function(y, b, v, x, E) {
      function _(C) {
        return Array.isArray(C) ? C.map((k) => "text" in k ? k.text : "") : "text" in C ? C.text : "";
      }
      return function C(k, A = {}) {
        const O = (A.renderDepth || 0) + 1;
        if (O > 2500) return _(k);
        A.renderDepth = O;
        try {
          if (Array.isArray(k)) {
            const I = A.key, $ = [];
            let L = !1;
            for (let N = 0; N < k.length; N++) {
              A.key = N;
              const U = C(k[N], A), j = d3(U);
              j && L ? $[$.length - 1] += U : U !== null && $.push(U), L = j;
            }
            return A.key = I, A.renderDepth = O - 1, $;
          }
          const P = (function(I, $, L) {
            const N = () => (function(U, j, V, F, K, W, Y) {
              switch (U.type) {
                case "0": {
                  const B = { key: V.key };
                  return U.alert && (B.className = "markdown-alert-" + W(U.alert.toLowerCase(), rp), U.children.unshift({ attrs: {}, children: [{ type: "27", text: U.alert }], noInnerParse: !0, type: "11", tag: "header" })), F("blockquote", B, j(U.children, V));
                }
                case "1":
                  return F("br", { key: V.key });
                case "2":
                  return F("hr", { key: V.key });
                case "3":
                  return F("pre", { key: V.key }, F("code", Ai({}, U.attrs, { className: U.lang ? "lang-" + U.lang : "" }), U.text));
                case "5":
                  return F("code", { key: V.key }, U.text);
                case "7":
                  return F("a", { key: V.key, href: K(U.target, "a", "href") }, F("sup", { key: V.key }, U.text));
                case "8":
                  return F("input", { checked: U.completed, key: V.key, readOnly: !0, type: "checkbox" });
                case "9":
                  return F("h" + U.level, { id: U.id, key: V.key }, j(U.children, V));
                case "11":
                  return F(U.tag, Ai({ key: V.key }, U.attrs), U.text || (U.children ? j(U.children, V) : ""));
                case "13":
                  return F(U.tag, Ai({}, U.attrs, { key: V.key }));
                case "14":
                  return F("img", { key: V.key, alt: U.alt || void 0, title: U.title || void 0, src: K(U.target, "img", "src") });
                case "15":
                  return F("a", { key: V.key, href: K(U.target, "a", "href"), title: U.title }, j(U.children, V));
                case "23":
                  return Y[U.ref] ? F("img", { key: V.key, alt: U.alt, src: K(Y[U.ref].target, "img", "src"), title: Y[U.ref].title }) : null;
                case "24":
                  return Y[U.ref] ? F("a", { key: V.key, href: K(Y[U.ref].target, "a", "href"), title: Y[U.ref].title }, j(U.children, V)) : F("span", { key: V.key }, U.fallbackChildren);
                case "25": {
                  const B = U;
                  return F("table", { key: V.key }, F("thead", null, F("tr", null, B.header.map(function(D, G) {
                    return F("th", { key: G, style: h3(B, G) }, j(D, V));
                  }))), F("tbody", null, B.cells.map(function(D, G) {
                    return F("tr", { key: G }, D.map(function(z, H) {
                      return F("td", { key: H, style: h3(B, H) }, j(z, V));
                    }));
                  })));
                }
                case "27":
                  return U.text;
                case "34":
                  return F(U.tag, { key: V.key }, j(U.children, V));
                case "20":
                case "30":
                  return F(U.ordered ? "ol" : "ul", { key: V.key, start: U.type === "20" ? U.start : void 0 }, U.items.map(function(B, D) {
                    return F("li", { key: D }, j(B, V));
                  }));
                case "19":
                  return `
`;
                case "21":
                  return F("p", { key: V.key }, j(U.children, V));
                default:
                  return null;
              }
            })(I, $, L, b, v, x, E);
            return y ? y(N, I, $, L) : N();
          })(k, C, A);
          return A.renderDepth = O - 1, P;
        } catch (P) {
          if (P instanceof RangeError && P.message.includes("Maximum call stack")) return _(k);
          throw P;
        }
      };
    })(t.renderRule, s, r, n, d);
    return c(e);
  }
  const hm = (e) => {
    let { children: t, options: n } = e, r = (function(o, i) {
      if (o == null) return {};
      var a = {};
      for (var s in o) if ({}.hasOwnProperty.call(o, s)) {
        if (i.indexOf(s) !== -1) continue;
        a[s] = o[s];
      }
      return a;
    })(e, MTe);
    return PAe(t ?? "", Ai({}, n, { wrapperProps: Ai({}, n?.wrapperProps, r) }));
  }, BV = /* @__PURE__ */ Symbol("remove-this-key"), y3 = /* @__PURE__ */ Symbol("reset");
  function IAe(e, t) {
    return Array.isArray(e.required) && e.required.indexOf(t) !== -1;
  }
  function $Ae(e, t) {
    switch (t) {
      case "array":
        return [];
      case "boolean":
        return !1;
      case "null":
        return null;
      case "number":
        return 0;
      case "object":
        return {};
      default:
        return e(bt.NewStringDefault);
    }
  }
  function jAe(e) {
    const { fieldPathId: t, schema: n, registry: r, uiSchema: o, errorSchema: i, formData: a, onChange: s, onBlur: c, onFocus: u, disabled: d, readonly: p, required: m, hideError: g, propertyName: y, handleKeyRename: b, handleRemoveProperty: v, addedByAdditionalProperties: x } = e, [E, _] = T.useState(!1), { globalFormOptions: C, fields: k } = r, { SchemaField: A } = k, O = Ic(Do(y, C, t.path)), P = T.useCallback((N, U, j, V) => {
      N === void 0 && x && (N = ""), s(N, U, j, V);
    }, [s, x]), I = T.useCallback((N) => {
      y !== N && _(!0), b(y, N);
    }, [y, b]), $ = T.useCallback((N) => {
      const { target: { value: U } } = N;
      I(U);
    }, [I]), L = T.useCallback(() => {
      v(y);
    }, [y, v]);
    return S.jsx(A, { name: y, required: m, schema: n, uiSchema: o, errorSchema: i, fieldPathId: O, formData: a, wasPropertyKeyModified: E, onKeyRename: I, onKeyRenameBlur: $, onRemoveProperty: L, onChange: P, onBlur: c, onFocus: u, registry: r, disabled: d, readonly: p, hideError: g });
  }
  function DAe(e) {
    const { schema: t, uiSchema: n = {}, formData: r, errorSchema: o, fieldPathId: i, name: a, required: s = !1, disabled: c, readonly: u, hideError: d, onBlur: p, onFocus: m, onChange: g, registry: y, title: b } = e, { fields: v, schemaUtils: x, translateString: E, globalUiOptions: _ } = y, { OptionalDataControlsField: C } = v, k = x.retrieveSchema(t, r, !0), A = Qe(n, _), { properties: O = {} } = k, P = e.childFieldPathId ?? i, I = A.title ?? k.title ?? b ?? a, $ = A.description ?? k.description, L = pm(y, k, s, n), N = Wf(r);
    let U = [];
    const j = T.useCallback((D, G) => {
      const { duplicateKeySuffixSeparator: z = "-" } = Qe(n, _);
      let H = 0, X = D;
      for (; Tt(G, X); )
        X = `${D}${z}${++H}`;
      return X;
    }, [n, _]), V = T.useCallback(() => {
      if (!(k.additionalProperties || k.patternProperties))
        return;
      const { translateString: D } = y, G = { ...r }, z = j("newKey", G);
      if (k.patternProperties)
        Qt(G, z, null);
      else {
        let H, X, Q;
        if ($t(k.additionalProperties)) {
          H = k.additionalProperties.type, X = k.additionalProperties.const, Q = k.additionalProperties.default;
          let te = k.additionalProperties;
          if (bn in te) {
            const { schemaUtils: se } = y;
            te = se.retrieveSchema({ [bn]: te[bn] }, r), H = te.type, X = te.const, Q = te.default;
          }
          !H && (Nt in te || yt in te) && (H = "object");
        }
        const ne = X ?? Q ?? $Ae(D, H);
        Qt(G, z, ne);
      }
      g(G, P.path);
    }, [r, g, y, P, j, k]), F = T.useCallback((D, G) => {
      if (D !== G) {
        const z = j(G, r), H = {
          ...r
        }, X = { [D]: z }, Q = Object.keys(H).map((te) => ({ [X[te] || te]: H[te] })), ne = Object.assign({}, ...Q);
        g(ne, P.path);
      }
    }, [r, g, P, j]), K = T.useCallback((D) => {
      g(BV, [...P.path, D]);
    }, [g, P]);
    if (!L || N)
      try {
        const D = Object.keys(O);
        U = cCe(D, A.order);
      } catch (D) {
        return S.jsxs("div", { children: [S.jsx("p", { className: "rjsf-config-error", style: { color: "red" }, children: S.jsx(hm, { options: { disableParsingRawHTML: !0 }, children: E(bt.InvalidObjectField, [a || "root", D.message]) }) }), S.jsx("pre", { children: JSON.stringify(k) })] });
      }
    const W = tt("ObjectFieldTemplate", y, A), Y = L ? S.jsx(C, { ...e, fieldPathId: P, schema: k }) : void 0, B = {
      // getDisplayLabel() always returns false for object types, so just check the `uiOptions.label`
      title: A.label === !1 ? "" : I,
      description: A.label === !1 ? void 0 : $,
      properties: U.map((D) => {
        const G = Tt(k, [Ft, D, Ba]), z = G ? n.additionalProperties : n[D], H = Qe(z).widget === "hidden";
        return {
          content: S.jsx(jAe, { propertyName: D, required: IAe(k, D), schema: Ee(k, [Ft, D], {}), uiSchema: z, errorSchema: Ee(o, [D]), fieldPathId: P, formData: Ee(r, [D]), handleKeyRename: F, handleRemoveProperty: K, addedByAdditionalProperties: G, onChange: g, onBlur: p, onFocus: m, registry: y, disabled: c, readonly: u, hideError: d }, D),
          name: D,
          readonly: u,
          disabled: c,
          required: s,
          hidden: H
        };
      }),
      readonly: u,
      disabled: c,
      required: s,
      fieldPathId: i,
      uiSchema: n,
      errorSchema: o,
      schema: k,
      formData: r,
      registry: y,
      optionalDataControl: Y,
      className: L ? "rjsf-optional-object-field" : void 0
    };
    return S.jsx(W, { ...B, onAddProperty: V });
  }
  function FAe(e) {
    const { schema: t, uiSchema: n = {}, formData: r, disabled: o = !1, readonly: i = !1, onChange: a, errorSchema: s, fieldPathId: c, registry: u } = e, { globalUiOptions: d = {}, schemaUtils: p, translateString: m } = u, g = Qe(n, d), y = tt("OptionalDataControlsTemplate", u, g), b = Wf(r);
    let v, x, E, _;
    if (o || i)
      v = k_(c, "Msg"), x = b ? void 0 : m(bt.OptionalObjectEmptyMsg);
    else {
      const C = b ? bt.OptionalObjectRemove : bt.OptionalObjectAdd;
      x = m(C), b ? (v = k_(c, "Remove"), _ = () => a(void 0, c.path, s)) : (v = k_(c, "Add"), E = () => {
        let k = p.getDefaultFormState(t, r, "excludeObjectChildren");
        k === void 0 && (k = oi(t) === "array" ? [] : {}), a(k, c.path, s);
      });
    }
    return x && S.jsx(y, { id: v, registry: u, schema: t, uiSchema: n, label: x, onAddClick: E, onRemoveClick: _ });
  }
  const LAe = {
    array: "ArrayField",
    boolean: "BooleanField",
    integer: "NumberField",
    number: "NumberField",
    object: "ObjectField",
    string: "StringField",
    null: "NullField"
  };
  function zAe(e, t, n) {
    const r = t.field, { fields: o } = n;
    if (typeof r == "function")
      return r;
    if (typeof r == "string" && r in o)
      return o[r];
    const i = oi(e), a = Array.isArray(i) ? i[0] : i || "", s = e.$id;
    let c = LAe[a];
    return s && s in o && (c = s), !c && (e.anyOf || e.oneOf) ? () => null : c in o ? o[c] : o.FallbackField;
  }
  function BAe(e) {
    const { schema: t, fieldPathId: n, uiSchema: r, formData: o, errorSchema: i, name: a, onChange: s, onKeyRename: c, onKeyRenameBlur: u, onRemoveProperty: d, required: p = !1, registry: m, wasPropertyKeyModified: g = !1 } = e, { schemaUtils: y, globalFormOptions: b, globalUiOptions: v, fields: x } = m, { AnyOfField: E, OneOfField: _ } = x, C = Qe(r, v), k = tt("FieldTemplate", m, C), A = tt("DescriptionFieldTemplate", m, C), O = tt("FieldHelpTemplate", m, C), P = tt("FieldErrorTemplate", m, C), I = y.retrieveSchema(t, o), $ = n[rn], L = T.useCallback((Se, Me, je, ze) => s(Se, Me, je, ze || $), [$, s]), N = zAe(I, C, m), U = !!(C.disabled ?? e.disabled), j = !!(C.readonly ?? (e.readonly || e.schema.readOnly || I.readOnly)), V = C.hideError, F = V === void 0 ? e.hideError : !!V, K = !!(C.autofocus ?? e.autofocus);
    if (Object.keys(I).length === 0)
      return null;
    let W = y.getDisplayLabel(I, r, v);
    const Y = C.field && C.fieldReplacesAnyOrOneOf === !0;
    let B, D, G = { fieldPathId: n };
    if ((Nt in I || yt in I) && !Y && !y.isSelect(I)) {
      I[Nt] ? (B = E, D = I[Nt].map((je) => y.retrieveSchema($t(je) ? je : {}, o))) : I[yt] && (B = _, D = I[yt].map((je) => y.retrieveSchema($t(je) ? je : {}, o)));
      const Se = pm(m, I, p, r), Me = Wf(o);
      W = W && (!Se || Me), G = {
        childFieldPathId: n,
        // The main FieldComponent will add `XxxOf` onto the fieldPathId to avoid duplication with the rendering of the
        // same FieldComponent by the `XxxOfField`
        fieldPathId: Do("XxxOf", b, n)
      };
    }
    const { __errors: z, ...H } = i || {}, X = vh(r, ["ui:classNames", "classNames", "ui:style"]);
    Zs in X && (X[Zs] = vh(X[Zs], ["classNames", "style"]));
    const Q = S.jsx(N, { ...e, onChange: L, ...G, schema: I, uiSchema: X, disabled: U, readonly: j, hideError: F, autofocus: K, errorSchema: H, rawErrors: z }), ne = n[rn];
    let te;
    g ? te = a : te = Ba in I ? a : C.title || e.schema.title || I.title || e.title || a;
    const se = C.description || e.schema.description || I.description || "", ue = C.help, J = C.widget === "hidden", ee = ["rjsf-field", `rjsf-field-${oi(I)}`];
    !F && z && z.length > 0 && ee.push("rjsf-field-error"), C.classNames && ee.push(C.classNames);
    const ie = S.jsx(O, { help: ue, fieldPathId: n, schema: I, uiSchema: r, hasErrors: !F && z && z.length > 0, registry: m }), le = F || B && !y.isSelect(I) ? void 0 : S.jsx(P, { errors: z, errorSchema: i, fieldPathId: n, schema: I, uiSchema: r, registry: m }), ge = {
      description: S.jsx(A, { id: Nc(ne), description: se, schema: I, uiSchema: r, registry: m }),
      rawDescription: se,
      help: ie,
      rawHelp: typeof ue == "string" ? ue : void 0,
      errors: le,
      rawErrors: F ? void 0 : z,
      id: ne,
      label: te,
      hidden: J,
      onChange: s,
      onKeyRename: c,
      onKeyRenameBlur: u,
      onRemoveProperty: d,
      required: p,
      disabled: U,
      readonly: j,
      hideError: F,
      displayLabel: W,
      classNames: ee.join(" ").trim(),
      style: C.style,
      formData: o,
      schema: I,
      uiSchema: r,
      registry: m
    };
    return S.jsx(k, { ...ge, children: S.jsxs(S.Fragment, { children: [Q, B && S.jsx(B, { name: a, disabled: U, readonly: j, hideError: F, errorSchema: i, formData: o, fieldPathId: n, onBlur: e.onBlur, onChange: e.onChange, onFocus: e.onFocus, options: D, registry: m, required: p, schema: I, uiSchema: r })] }) });
  }
  class UAe extends T.Component {
    shouldComponentUpdate(t) {
      const { registry: { globalFormOptions: n } } = this.props, { experimental_componentUpdateStrategy: r = "customDeep" } = n;
      return yV(this, t, this.state, r);
    }
    render() {
      return S.jsx(BAe, { ...this.props });
    }
  }
  function VAe(e) {
    const { schema: t, name: n, uiSchema: r, fieldPathId: o, formData: i, required: a, disabled: s = !1, readonly: c = !1, autofocus: u = !1, onChange: d, onBlur: p, onFocus: m, registry: g, rawErrors: y, hideError: b, title: v } = e, { title: x, format: E } = t, { widgets: _, schemaUtils: C, globalUiOptions: k } = g, A = C.isSelect(t) ? Af(t, r) : void 0;
    let O = A ? "select" : "text";
    E && aCe(t, E, _) && (O = E);
    const { widget: P = O, placeholder: I = "", title: $, ...L } = Qe(r), N = C.getDisplayLabel(t, r, k), U = $ ?? v ?? x ?? n, j = Yi(t, P, _), V = T.useCallback((F, K, W) => d(F, o.path, K, W), [d, o]);
    return S.jsx(j, { options: { ...L, enumOptions: A }, schema: t, uiSchema: r, id: o.$id, name: n, label: U, hideLabel: !N, hideError: b, value: i, onChange: V, onBlur: p, onFocus: m, required: a, disabled: s, readonly: c, autofocus: u, registry: g, placeholder: I, rawErrors: y, htmlName: o.name });
  }
  function HAe(e) {
    const { formData: t, onChange: n, fieldPathId: r } = e;
    return T.useEffect(() => {
      t === void 0 && n(null, r.path);
    }, [r, t, n]), null;
  }
  function qAe() {
    return {
      AnyOfField: J5,
      ArrayField: Jke,
      // ArrayField falls back to SchemaField if ArraySchemaField is not defined, which it isn't by default
      BooleanField: eTe,
      FallbackField: oTe,
      LayoutGridField: OA,
      LayoutHeaderField: ETe,
      LayoutMultiSchemaField: CTe,
      NumberField: ATe,
      ObjectField: DAe,
      OneOfField: J5,
      OptionalDataControlsField: FAe,
      SchemaField: UAe,
      StringField: VAe,
      NullField: HAe
    };
  }
  function WAe(e) {
    const { fieldPathId: t, description: n, registry: r, schema: o, uiSchema: i } = e, a = Qe(i, r.globalUiOptions), { label: s = !0 } = a;
    if (!n || !s)
      return null;
    const c = tt("DescriptionFieldTemplate", r, a);
    return S.jsx(c, { id: Nc(t), description: n, schema: o, uiSchema: i, registry: r });
  }
  function GAe(e) {
    const { children: t, className: n, buttonsProps: r, displayLabel: o, hasDescription: i, hasToolbar: a, registry: s, uiSchema: c } = e, u = Qe(c), d = tt("ArrayFieldItemButtonsTemplate", s, u), p = {
      flex: 1,
      paddingLeft: 6,
      paddingRight: 6,
      fontWeight: "bold"
    }, m = i ? 31 : 9, g = { display: "flex", alignItems: o ? "center" : "baseline" }, y = { display: "flex", justifyContent: "flex-end", marginTop: o ? `${m}px` : 0 };
    return S.jsxs("div", { className: n, style: g, children: [S.jsx("div", { className: a ? "col-xs-9 col-md-10 col-xl-11" : "col-xs-12", children: t }), a && S.jsx("div", { className: "col-xs-3 col-md-2 col-xl-1 array-item-toolbox", children: S.jsx("div", { className: "btn-group", style: y, children: S.jsx(d, { ...r, style: p }) }) })] });
  }
  function KAe(e) {
    const { disabled: t, hasCopy: n, hasMoveDown: r, hasMoveUp: o, hasRemove: i, fieldPathId: a, onCopyItem: s, onRemoveItem: c, onMoveDownItem: u, onMoveUpItem: d, readonly: p, registry: m, uiSchema: g } = e, { CopyButton: y, MoveDownButton: b, MoveUpButton: v, RemoveButton: x } = m.templates.ButtonTemplates;
    return S.jsxs(S.Fragment, { children: [(o || r) && S.jsx(v, { id: ji(a, "moveUp"), className: "rjsf-array-item-move-up", disabled: t || p || !o, onClick: d, uiSchema: g, registry: m }), (o || r) && S.jsx(b, { id: ji(a, "moveDown"), className: "rjsf-array-item-move-down", disabled: t || p || !r, onClick: u, uiSchema: g, registry: m }), n && S.jsx(y, { id: ji(a, "copy"), className: "rjsf-array-item-copy", disabled: t || p, onClick: s, uiSchema: g, registry: m }), i && S.jsx(x, { id: ji(a, "remove"), className: "rjsf-array-item-remove", disabled: t || p, onClick: c, uiSchema: g, registry: m })] });
  }
  function YAe(e) {
    const { canAdd: t, className: n, disabled: r, fieldPathId: o, uiSchema: i, items: a, optionalDataControl: s, onAddClick: c, readonly: u, registry: d, required: p, schema: m, title: g } = e, y = Qe(i), b = tt("ArrayFieldDescriptionTemplate", d, y), v = tt("ArrayFieldTitleTemplate", d, y), x = !u && !r, { ButtonTemplates: { AddButton: E } } = d.templates;
    return S.jsxs("fieldset", { className: n, id: o.$id, children: [S.jsx(v, { fieldPathId: o, title: y.title || g, required: p, schema: m, uiSchema: i, registry: d, optionalDataControl: x ? s : void 0 }), S.jsx(b, { fieldPathId: o, description: y.description || m.description, schema: m, uiSchema: i, registry: d }), x ? void 0 : s, S.jsx("div", { className: "row array-item-list", children: a }), t && S.jsx(E, { id: ji(o, "add"), className: "rjsf-array-item-add", onClick: c, disabled: r || u, uiSchema: i, registry: d })] });
  }
  function XAe(e) {
    const { fieldPathId: t, title: n, schema: r, uiSchema: o, required: i, registry: a, optionalDataControl: s } = e, c = Qe(o, a.globalUiOptions), { label: u = !0 } = c;
    if (!n || !u)
      return null;
    const d = tt("TitleFieldTemplate", a, c);
    return S.jsx(d, { id: x1(t), title: n, required: i, schema: r, uiSchema: o, registry: a, optionalDataControl: s });
  }
  function ZAe(e) {
    const {
      id: t,
      name: n,
      // remove this from ...rest
      htmlName: r,
      value: o,
      readonly: i,
      disabled: a,
      autofocus: s,
      onBlur: c,
      onFocus: u,
      onChange: d,
      onChangeOverride: p,
      options: m,
      schema: g,
      uiSchema: y,
      registry: b,
      rawErrors: v,
      type: x,
      hideLabel: E,
      // remove this from ...rest
      hideError: _,
      // remove this from ...rest
      ...C
    } = e;
    if (!t)
      throw console.log("No id for", e), new Error(`no id for props ${JSON.stringify(e)}`);
    const k = {
      ...C,
      ...hV(g, x, m)
    };
    let A;
    k.type === "number" || k.type === "integer" ? A = o || o === 0 ? o : "" : A = o ?? "";
    const O = T.useCallback(({ target: { value: $ } }) => d($ === "" ? m.emptyValue : $), [d, m]), P = T.useCallback(({ target: $ }) => c(t, $ && $.value), [c, t]), I = T.useCallback(({ target: $ }) => u(t, $ && $.value), [u, t]);
    return S.jsxs(S.Fragment, { children: [S.jsx("input", { id: t, name: r || t, className: "form-control", readOnly: i, disabled: a, autoFocus: s, value: A, ...k, list: g.examples ? _h(t) : void 0, onChange: p || O, onBlur: P, onFocus: I, "aria-describedby": go(t, !!g.examples) }), Array.isArray(g.examples) && S.jsx("datalist", { id: _h(t), children: g.examples.concat(g.default && !g.examples.includes(g.default) ? [g.default] : []).map(($) => S.jsx("option", { value: $ }, $)) }, `datalist_${t}`)] });
  }
  function QAe({ uiSchema: e }) {
    const { submitText: t, norender: n, props: r = {} } = mV(e);
    return n ? null : S.jsx("div", { children: S.jsx("button", { type: "submit", ...r, className: `btn btn-info ${r.className || ""}`, children: t }) });
  }
  function wc(e) {
    const { iconType: t = "default", icon: n, className: r, uiSchema: o, registry: i, ...a } = e;
    return S.jsx("button", { type: "button", className: `btn btn-${t} ${r}`, ...a, children: S.jsx("i", { className: `glyphicon glyphicon-${n}` }) });
  }
  function JAe(e) {
    const { registry: { translateString: t } } = e;
    return S.jsx(wc, { title: t(bt.CopyButton), ...e, icon: "copy" });
  }
  function eRe(e) {
    const { registry: { translateString: t } } = e;
    return S.jsx(wc, { title: t(bt.MoveDownButton), ...e, icon: "arrow-down" });
  }
  function tRe(e) {
    const { registry: { translateString: t } } = e;
    return S.jsx(wc, { title: t(bt.MoveUpButton), ...e, icon: "arrow-up" });
  }
  function nRe(e) {
    const { registry: { translateString: t } } = e;
    return S.jsx(wc, { title: t(bt.RemoveButton), ...e, iconType: "danger", icon: "remove" });
  }
  function rRe({ id: e, className: t, onClick: n, disabled: r, registry: o }) {
    const { translateString: i } = o;
    return S.jsx("div", { className: "row", children: S.jsx("p", { className: `col-xs-4 col-sm-2 col-lg-1 col-xs-offset-8 col-sm-offset-10 col-lg-offset-11 text-right ${t}`, children: S.jsx(wc, { id: e, iconType: "info", icon: "plus", className: "btn-add col-xs-12", title: i(bt.AddButton), onClick: n, disabled: r, registry: o }) }) });
  }
  function oRe() {
    return {
      SubmitButton: QAe,
      AddButton: rRe,
      CopyButton: JAe,
      MoveDownButton: eRe,
      MoveUpButton: tRe,
      RemoveButton: nRe
    };
  }
  const UV = wA();
  function IA({ description: e, registry: t, uiSchema: n = {} }) {
    const { globalUiOptions: r } = t;
    return Qe(n, r).enableMarkdownInDescription && typeof e == "string" ? S.jsx(hm, { options: { disableParsingRawHTML: !0 }, "data-testid": UV.markdown, children: e }) : e;
  }
  IA.TEST_IDS = UV;
  function iRe(e) {
    const { id: t, description: n, registry: r, uiSchema: o } = e;
    return n ? S.jsx("div", { id: t, className: "field-description", children: S.jsx(IA, { description: n, registry: r, uiSchema: o }) }) : null;
  }
  function aRe({ errors: e, registry: t }) {
    const { translateString: n } = t;
    return S.jsxs("div", { className: "panel panel-danger errors", children: [S.jsx("div", { className: "panel-heading", children: S.jsx("h3", { className: "panel-title", children: n(bt.ErrorsLabel) }) }), S.jsx("ul", { className: "list-group", children: e.map((r, o) => S.jsx("li", { className: "list-group-item text-danger", children: r.stack }, o)) })] });
  }
  function sRe(e) {
    const { schema: t, registry: n, typeSelector: r, schemaField: o } = e, i = tt("MultiSchemaFieldTemplate", n);
    return S.jsx(i, { selector: r, optionSchemaField: o, schema: t, registry: n });
  }
  const lRe = "*";
  function VV(e) {
    const { label: t, required: n, id: r } = e;
    return t ? S.jsxs("label", { className: "control-label", htmlFor: r, children: [t, n && S.jsx("span", { className: "required", children: lRe })] }) : null;
  }
  function cRe(e) {
    const { id: t, label: n, children: r, errors: o, help: i, description: a, hidden: s, required: c, displayLabel: u, registry: d, uiSchema: p } = e, m = Qe(p), g = tt("WrapIfAdditionalTemplate", d, m);
    if (s)
      return S.jsx("div", { className: "hidden", children: r });
    const y = m.widget === "checkbox";
    return S.jsxs(g, { ...e, children: [u && !y && S.jsx(VV, { label: n, required: c, id: t }), u && a ? a : null, r, o, i] });
  }
  function uRe(e) {
    const { errors: t = [], fieldPathId: n } = e;
    if (t.length === 0)
      return null;
    const r = SA(n);
    return S.jsx("div", { children: S.jsx("ul", { id: r, className: "error-detail bs-callout bs-callout-info", children: t.filter((o) => !!o).map((o, i) => S.jsx("li", { className: "text-danger", children: o }, i)) }) });
  }
  const HV = wA();
  function $A({ help: e, registry: t, uiSchema: n = {} }) {
    const { globalUiOptions: r } = t;
    return Qe(n, r).enableMarkdownInHelp && typeof e == "string" ? S.jsx(hm, { options: { disableParsingRawHTML: !0 }, "data-testid": HV.markdown, children: e }) : e;
  }
  $A.TEST_IDS = HV;
  function fRe(e) {
    const { fieldPathId: t, help: n, uiSchema: r, registry: o } = e;
    return n ? S.jsx("div", { id: _A(t), className: "help-block", children: S.jsx($A, { help: n, registry: o, uiSchema: r }) }) : null;
  }
  function dRe(e) {
    const { children: t, column: n, className: r, ...o } = e;
    return S.jsx("div", { className: r, ...o, children: t });
  }
  function pRe(e) {
    const { selector: t, optionSchemaField: n } = e;
    return S.jsxs("div", { className: "panel panel-default panel-body", children: [S.jsx("div", { className: "form-group", children: t }), n] });
  }
  function hRe(e) {
    const { className: t, description: n, disabled: r, formData: o, fieldPathId: i, onAddProperty: a, optionalDataControl: s, properties: c, readonly: u, registry: d, required: p, schema: m, title: g, uiSchema: y } = e, b = Qe(y), v = tt("TitleFieldTemplate", d, b), x = tt("DescriptionFieldTemplate", d, b), E = !u && !r, { ButtonTemplates: { AddButton: _ } } = d.templates;
    return S.jsxs("fieldset", { className: t, id: i.$id, children: [g && S.jsx(v, { id: x1(i), title: g, required: p, schema: m, uiSchema: y, registry: d, optionalDataControl: E ? s : void 0 }), n && S.jsx(x, { id: Nc(i), description: n, schema: m, uiSchema: y, registry: d }), E ? void 0 : s, c.map((C) => C.content), Q8(m, y, o) && S.jsx(_, { id: ji(i, "add"), className: "rjsf-object-property-expand", onClick: a, disabled: r || u, uiSchema: y, registry: d })] });
  }
  function mRe(e) {
    const { id: t, registry: n, label: r, onAddClick: o, onRemoveClick: i } = e;
    return o ? S.jsx(wc, { id: t, registry: n, icon: "plus", className: "rjsf-add-optional-data btn-sm", onClick: o, title: r }) : i ? S.jsx(wc, { id: t, registry: n, icon: "remove", className: "rjsf-remove-optional-data btn-sm", onClick: i, title: r }) : S.jsx("em", { id: t, children: r });
  }
  const gRe = "*";
  function yRe(e) {
    const { id: t, title: n, required: r, optionalDataControl: o } = e;
    return S.jsxs("legend", { id: t, children: [n, r && S.jsx("span", { className: "required", children: gRe }), o && S.jsx("span", { className: "pull-right", style: { marginBottom: "2px" }, children: o })] });
  }
  function vRe(e) {
    const { schema: t, fieldPathId: n, reason: r, registry: o } = e, { translateString: i } = o;
    let a = bt.UnsupportedField;
    const s = [];
    return n && n.$id && (a = bt.UnsupportedFieldWithId, s.push(n.$id)), r && (a = a === bt.UnsupportedField ? bt.UnsupportedFieldWithReason : bt.UnsupportedFieldWithIdAndReason, s.push(r)), S.jsxs("div", { className: "unsupported-field", children: [S.jsx("p", { children: S.jsx(hm, { options: { disableParsingRawHTML: !0 }, children: i(a, s) }) }), t && S.jsx("pre", { children: JSON.stringify(t, null, 2) })] });
  }
  function bRe(e) {
    const { id: t, classNames: n, style: r, disabled: o, displayLabel: i, label: a, onKeyRenameBlur: s, onRemoveProperty: c, rawDescription: u, readonly: d, required: p, schema: m, hideError: g, rawErrors: y, children: b, uiSchema: v, registry: x } = e, { templates: E, translateString: _ } = x, { RemoveButton: C } = E.ButtonTemplates, k = _(bt.KeyLabel, [a]), A = Ba in m, O = !!u, P = ["form-group", n];
    !g && y && y.length > 0 && P.push("has-error has-danger");
    const I = P.join(" ").trim();
    if (!A)
      return S.jsx("div", { className: I, style: r, children: b });
    const $ = O ? 46 : 26;
    return S.jsx("div", { className: I, style: r, children: S.jsxs("div", { className: "row", children: [S.jsx("div", { className: "col-xs-5 form-additional", children: S.jsxs("div", { className: "form-group", children: [i && S.jsx(VV, { label: k, required: p, id: `${t}-key` }), i && u && S.jsx("div", { children: "" }), S.jsx("input", { className: "form-control", type: "text", id: `${t}-key`, onBlur: s, defaultValue: a })] }) }), S.jsx("div", { className: "form-additional form-group col-xs-5", children: b }), S.jsx("div", { className: "col-xs-2", style: { marginTop: i ? `${$}px` : void 0 }, children: S.jsx(C, { id: ji(t, "remove"), className: "rjsf-object-property-remove btn-block", style: { border: "0" }, disabled: o || d, onClick: c, uiSchema: v, registry: x }) })] }) });
  }
  function xRe() {
    return {
      ArrayFieldDescriptionTemplate: WAe,
      ArrayFieldItemTemplate: GAe,
      ArrayFieldItemButtonsTemplate: KAe,
      ArrayFieldTemplate: YAe,
      ArrayFieldTitleTemplate: XAe,
      ButtonTemplates: oRe(),
      BaseInputTemplate: ZAe,
      DescriptionFieldTemplate: iRe,
      ErrorListTemplate: aRe,
      FallbackFieldTemplate: sRe,
      FieldTemplate: cRe,
      FieldErrorTemplate: uRe,
      FieldHelpTemplate: fRe,
      GridTemplate: dRe,
      MultiSchemaFieldTemplate: pRe,
      ObjectFieldTemplate: hRe,
      OptionalDataControlsTemplate: mRe,
      TitleFieldTemplate: yRe,
      UnsupportedFieldTemplate: vRe,
      WrapIfAdditionalTemplate: bRe
    };
  }
  function wRe(e) {
    const { disabled: t = !1, readonly: n = !1, autofocus: r = !1, options: o, id: i, name: a, registry: s, onBlur: c, onFocus: u } = e, { translateString: d } = s, { elements: p, handleChange: m, handleClear: g, handleSetNow: y } = pCe(e);
    return S.jsxs("ul", { className: "list-inline", children: [p.map((b, v) => S.jsx("li", { className: "list-inline-item", children: S.jsx(dCe, { rootId: i, name: a, select: m, ...b, disabled: t, readonly: n, registry: s, onBlur: c, onFocus: u, autofocus: r && v === 0 }) }, v)), (o.hideNowButton !== "undefined" ? !o.hideNowButton : !0) && S.jsx("li", { className: "list-inline-item", children: S.jsx("a", { href: "#", className: "btn btn-info btn-now", onClick: y, children: d(bt.NowLabel) }) }), (o.hideClearButton !== "undefined" ? !o.hideClearButton : !0) && S.jsx("li", { className: "list-inline-item", children: S.jsx("a", { href: "#", className: "btn btn-warning btn-clear", onClick: g, children: d(bt.ClearLabel) }) })] });
  }
  function SRe({ time: e = !0, ...t }) {
    const { AltDateWidget: n } = t.registry.widgets;
    return S.jsx(n, { time: e, ...t });
  }
  function _Re({ schema: e, uiSchema: t, options: n, id: r, value: o, disabled: i, readonly: a, label: s, hideLabel: c, autofocus: u = !1, onBlur: d, onFocus: p, onChange: m, registry: g, htmlName: y }) {
    const b = tt("DescriptionFieldTemplate", g, n), v = jp(e), x = T.useCallback((O) => m(O.target.checked), [m]), E = T.useCallback((O) => d(r, O.target.checked), [d, r]), _ = T.useCallback((O) => p(r, O.target.checked), [p, r]), A = Qe(t).widget === "checkbox" ? void 0 : n.description ?? e.description;
    return S.jsxs("div", { className: `checkbox ${i || a ? "disabled" : ""}`, children: [!c && A && S.jsx(b, { id: Nc(r), description: A, schema: e, uiSchema: t, registry: g }), S.jsxs("label", { children: [S.jsx("input", { type: "checkbox", id: r, name: y || r, checked: typeof o > "u" ? !1 : o, required: v, disabled: i || a, autoFocus: u, onChange: x, onBlur: E, onFocus: _, "aria-describedby": go(r) }), Pc(S.jsx("span", { children: s }), c)] })] });
  }
  function ERe({ id: e, disabled: t, options: { inline: n = !1, enumOptions: r, enumDisabled: o, emptyValue: i }, value: a, autofocus: s = !1, readonly: c, onChange: u, onBlur: d, onFocus: p, htmlName: m }) {
    const g = Array.isArray(a) ? a : [a], y = T.useCallback(({ target: v }) => d(e, Jn(v && v.value, r, i)), [d, e, r, i]), b = T.useCallback(({ target: v }) => p(e, Jn(v && v.value, r, i)), [p, e, r, i]);
    return S.jsx("div", { className: "checkboxes", id: e, children: Array.isArray(r) && r.map((v, x) => {
      const E = b1(v.value, g), _ = Array.isArray(o) && o.indexOf(v.value) !== -1, C = t || _ || c ? "disabled" : "", k = (O) => {
        O.target.checked ? u(uV(x, g, r)) : u(cV(x, g, r));
      }, A = S.jsxs("span", { children: [S.jsx("input", { type: "checkbox", id: w1(e, x), name: m || e, checked: E, value: String(x), disabled: t || _ || c, autoFocus: s && x === 0, onChange: k, onBlur: y, onFocus: b, "aria-describedby": go(e) }), S.jsx("span", { children: v.label })] });
      return n ? S.jsx("label", { className: `checkbox-inline ${C}`, children: A }, x) : S.jsx("div", { className: `checkbox ${C}`, children: S.jsx("label", { children: A }) }, x);
    }) });
  }
  function CRe(e) {
    const { disabled: t, readonly: n, options: r, registry: o } = e, i = tt("BaseInputTemplate", o, r);
    return S.jsx(i, { type: "color", ...e, disabled: t || n });
  }
  function kRe(e) {
    const { onChange: t, options: n, registry: r } = e, o = tt("BaseInputTemplate", r, n), i = T.useCallback((a) => t(a || void 0), [t]);
    return S.jsx(o, { type: "date", ...e, onChange: i });
  }
  function TRe(e) {
    const { onChange: t, value: n, options: r, registry: o } = e, i = tt("BaseInputTemplate", o, r);
    return S.jsx(i, { type: "datetime-local", ...e, value: vCe(n), onChange: (a) => t(lCe(a)) });
  }
  function ARe(e) {
    const { options: t, registry: n } = e, r = tt("BaseInputTemplate", n, t);
    return S.jsx(r, { type: "email", ...e });
  }
  function RRe({ fileInfo: e, registry: t }) {
    const { translateString: n } = t, { dataURL: r, type: o, name: i } = e;
    return r ? ["image/jpeg", "image/png"].includes(o) ? S.jsx("img", { src: r, style: { maxWidth: "100%" }, className: "file-preview" }) : S.jsxs(S.Fragment, { children: [" ", S.jsx("a", { download: `preview-${i}`, href: r, className: "file-download", children: n(bt.PreviewLabel) })] }) : null;
  }
  function ORe({ filesInfo: e, registry: t, preview: n, onRemove: r, options: o }) {
    if (e.length === 0)
      return null;
    const { translateString: i } = t, { RemoveButton: a } = tt("ButtonTemplates", t, o);
    return S.jsx("ul", { className: "file-info", children: e.map((s, c) => {
      const { name: u, size: d, type: p } = s, m = () => r(c);
      return S.jsxs("li", { children: [S.jsx(hm, { children: i(bt.FilesInfo, [u, p, String(d)]) }), n && S.jsx(RRe, { fileInfo: s, registry: t }), S.jsx(a, { onClick: m, registry: t })] }, c);
    }) });
  }
  function MRe(e) {
    const { disabled: t, readonly: n, required: r, multiple: o, onChange: i, value: a, options: s, registry: c } = e, { filesInfo: u, handleChange: d, handleRemove: p } = yCe(a, i, o), m = tt("BaseInputTemplate", c, s), g = (y) => {
      y.target.files && d(y.target.files);
    };
    return S.jsxs("div", { children: [S.jsx(m, { ...e, disabled: t || n, type: "file", required: a ? !1 : r, onChangeOverride: g, value: "", accept: s.accept ? String(s.accept) : void 0 }), S.jsx(ORe, { filesInfo: u, onRemove: p, registry: c, preview: s.filePreview, options: s })] });
  }
  function NRe({ id: e, value: t, htmlName: n }) {
    return S.jsx("input", { type: "hidden", id: e, name: n || e, value: typeof t > "u" ? "" : t });
  }
  function PRe(e) {
    const { options: t, registry: n } = e, r = tt("BaseInputTemplate", n, t);
    return S.jsx(r, { type: "password", ...e });
  }
  function IRe({ options: e, value: t, required: n, disabled: r, readonly: o, autofocus: i = !1, onBlur: a, onFocus: s, onChange: c, id: u, htmlName: d }) {
    const { enumOptions: p, enumDisabled: m, inline: g, emptyValue: y } = e, b = T.useCallback(({ target: x }) => a(u, Jn(x && x.value, p, y)), [a, p, y, u]), v = T.useCallback(({ target: x }) => s(u, Jn(x && x.value, p, y)), [s, p, y, u]);
    return S.jsx("div", { className: "field-radio-group", id: u, role: "radiogroup", children: Array.isArray(p) && p.map((x, E) => {
      const _ = b1(x.value, t), C = Array.isArray(m) && m.indexOf(x.value) !== -1, k = r || C || o ? "disabled" : "", A = () => c(x.value), O = S.jsxs("span", { children: [S.jsx("input", { type: "radio", id: w1(u, E), checked: _, name: d || u, required: n, value: String(E), disabled: r || C || o, autoFocus: i && E === 0, onChange: A, onBlur: b, onFocus: v, "aria-describedby": go(u) }), S.jsx("span", { children: x.label })] });
      return g ? S.jsx("label", { className: `radio-inline ${k}`, children: O }, E) : S.jsx("div", { className: `radio ${k}`, children: S.jsx("label", { children: O }) }, E);
    }) });
  }
  function $Re(e) {
    const { value: t, registry: { templates: { BaseInputTemplate: n } } } = e;
    return S.jsxs("div", { className: "field-range-wrapper", children: [S.jsx(n, { type: "range", ...e }), S.jsx("span", { className: "range-view", children: t })] });
  }
  function jRe({ id: e, value: t, required: n, disabled: r, readonly: o, autofocus: i, onChange: a, onFocus: s, onBlur: c, schema: u, options: d, htmlName: p }) {
    const { stars: m = 5, shape: g = "star" } = d, y = u.maximum ? Math.min(u.maximum, 5) : Math.min(Math.max(m, 1), 5), b = u.minimum || 0, v = T.useCallback((C) => {
      !r && !o && a(C);
    }, [a, r, o]), x = T.useCallback((C) => {
      if (s) {
        const k = Number(C.target.dataset.value);
        s(e, k);
      }
    }, [s, e]), E = T.useCallback((C) => {
      if (c) {
        const k = Number(C.target.dataset.value);
        c(e, k);
      }
    }, [c, e]), _ = (C) => g === "heart" ? C ? "" : "" : C ? "" : "";
    return S.jsx(S.Fragment, { children: S.jsxs("div", { className: "rating-widget", style: {
      display: "inline-flex",
      fontSize: "1.5rem",
      cursor: r || o ? "default" : "pointer"
    }, children: [[...Array(y)].map((C, k) => {
      const A = b + k, O = A <= t;
      return S.jsx("span", { onClick: () => v(A), onFocus: x, onBlur: E, "data-value": A, tabIndex: r || o ? -1 : 0, role: "radio", "aria-checked": A === t, "aria-label": `${A} ${g === "heart" ? "heart" : "star"}${A === 1 ? "" : "s"}`, style: {
        color: O ? "#FFD700" : "#ccc",
        padding: "0 0.2rem",
        transition: "color 0.2s",
        userSelect: "none"
      }, children: _(O) }, k);
    }), S.jsx("input", { type: "hidden", id: e, name: p || e, value: t || "", required: n, disabled: r || o, "aria-hidden": "true" })] }) });
  }
  function W_(e, t) {
    return t ? Array.from(e.target.options).slice().filter((n) => n.selected).map((n) => n.value) : e.target.value;
  }
  function DRe({ schema: e, id: t, options: n, value: r, required: o, disabled: i, readonly: a, multiple: s = !1, autofocus: c = !1, onChange: u, onBlur: d, onFocus: p, placeholder: m, htmlName: g }) {
    const { enumOptions: y, enumDisabled: b, emptyValue: v } = n, x = s ? [] : "", E = T.useCallback((O) => {
      const P = W_(O, s);
      return p(t, Jn(P, y, v));
    }, [p, t, s, y, v]), _ = T.useCallback((O) => {
      const P = W_(O, s);
      return d(t, Jn(P, y, v));
    }, [d, t, s, y, v]), C = T.useCallback((O) => {
      const P = W_(O, s);
      return u(Jn(P, y, v));
    }, [u, s, y, v]), k = bA(r, y, s), A = !s && e.default === void 0;
    return S.jsxs("select", { id: t, name: g || t, multiple: s, role: "combobox", className: "form-control", value: typeof k > "u" ? x : k, required: o, disabled: i || a, autoFocus: c, onBlur: _, onFocus: E, onChange: C, "aria-describedby": go(t), children: [A && S.jsx("option", { value: "", children: m }), Array.isArray(y) && y.map(({ value: O, label: P }, I) => {
      const $ = b && b.indexOf(O) !== -1;
      return S.jsx("option", { value: String(I), disabled: $, children: P }, I);
    })] });
  }
  function qV({ id: e, options: t = {}, placeholder: n, value: r, required: o, disabled: i, readonly: a, autofocus: s = !1, onChange: c, onBlur: u, onFocus: d, htmlName: p }) {
    const m = T.useCallback(({ target: { value: b } }) => c(b === "" ? t.emptyValue : b), [c, t.emptyValue]), g = T.useCallback(({ target: b }) => u(e, b && b.value), [u, e]), y = T.useCallback(({ target: b }) => d(e, b && b.value), [e, d]);
    return S.jsx("textarea", { id: e, name: p || e, className: "form-control", value: r || "", placeholder: n, required: o, disabled: i, readOnly: a, autoFocus: s, rows: t.rows, onBlur: g, onFocus: y, onChange: m, "aria-describedby": go(e) });
  }
  qV.defaultProps = {
    autofocus: !1,
    options: {}
  };
  function FRe(e) {
    const { options: t, registry: n } = e, r = tt("BaseInputTemplate", n, t);
    return S.jsx(r, { ...e });
  }
  function LRe(e) {
    const { onChange: t, options: n, registry: r } = e, o = tt("BaseInputTemplate", r, n), i = T.useCallback((a) => t(a ? `${a}:00` : void 0), [t]);
    return S.jsx(o, { type: "time", ...e, onChange: i });
  }
  function zRe(e) {
    const { options: t, registry: n } = e, r = tt("BaseInputTemplate", n, t);
    return S.jsx(r, { type: "url", ...e });
  }
  function BRe(e) {
    const { options: t, registry: n } = e, r = tt("BaseInputTemplate", n, t);
    return S.jsx(r, { type: "number", ...e });
  }
  function URe() {
    return {
      AltDateWidget: wRe,
      AltDateTimeWidget: SRe,
      CheckboxWidget: _Re,
      CheckboxesWidget: ERe,
      ColorWidget: CRe,
      DateWidget: kRe,
      DateTimeWidget: TRe,
      EmailWidget: ARe,
      FileWidget: MRe,
      HiddenWidget: NRe,
      PasswordWidget: PRe,
      RadioWidget: IRe,
      RangeWidget: $Re,
      RatingWidget: jRe,
      SelectWidget: DRe,
      TextWidget: FRe,
      TextareaWidget: qV,
      TimeWidget: LRe,
      UpDownWidget: BRe,
      URLWidget: zRe
    };
  }
  function VRe() {
    return {
      fields: qAe(),
      templates: xRe(),
      widgets: URe(),
      rootSchema: {},
      formContext: {},
      translateString: VEe,
      globalFormOptions: {
        idPrefix: Y8,
        idSeparator: X8,
        useFallbackUiForUnsupportedType: !1
      }
    };
  }
  function ju(e, t) {
    return {
      ...TV(e, ["schema", "uiSchema", "fieldPathId", "schemaUtils", "formData", "edit", "errors", "errorSchema"]),
      ...t !== void 0 && { status: t }
    };
  }
  let HRe = class extends T.Component {
    /** Constructs the `Form` from the `props`. Will setup the initial state from the props. It will also call the
     * `onChange` handler if the initially provided `formData` is modified to add missing default values as part of the
     * state construction.
     *
     * @param props - The initial props for the `Form`
     */
    constructor(n) {
      super(n);
      /** The ref used to hold the `form` element, this needs to be `any` because `tagName` or `_internalFormWrapper` can
       * provide any possible type here
       */
      Kn(this, "formElement");
      /** The list of pending changes
       */
      Kn(this, "pendingChanges", []);
      /** Returns the `formData` with only the elements specified in the `fields` list
       *
       * @param formData - The data for the `Form`
       * @param fields - The fields to keep while filtering
       */
      Kn(this, "getUsedFormData", (n, r) => {
        if (r.length === 0 && typeof n != "object")
          return n;
        const o = TV(n, r);
        return Array.isArray(n) ? Object.keys(o).map((i) => o[i]) : o;
      });
      /** Returns the list of field names from inspecting the `pathSchema` as well as using the `formData`
       *
       * @param pathSchema - The `PathSchema` object for the form
       * @param [formData] - The form data to use while checking for empty objects/arrays
       */
      Kn(this, "getFieldNames", (n, r) => {
        const o = (a, s) => typeof a != "object" || Hn(a) || s && !Hn(a), i = (a, s = [], c = [[]]) => {
          const u = Object.keys(a);
          return u.forEach((d) => {
            const p = a[d];
            if (typeof p == "object") {
              const m = c.map((g) => [...g, d]);
              p[KT] && p[Vv] !== "" ? s.push(p[Vv]) : i(p, s, m);
            } else d === Vv && p !== "" && c.forEach((m) => {
              const g = Ee(r, m), y = u.length === 1;
              (o(g, y) || Array.isArray(g) && g.every((b) => o(b, y))) && s.push(m);
            });
          }), s;
        };
        return i(n);
      });
      /** Returns the `formData` after filtering to remove any extra data not in a form field
       *
       * @param formData - The data for the `Form`
       * @returns The `formData` after omitting extra data
       */
      Kn(this, "omitExtraData", (n) => {
        const { schema: r, schemaUtils: o } = this.state, i = o.retrieveSchema(r, n), a = o.toPathSchema(i, "", n), s = this.getFieldNames(a, n);
        return this.getUsedFormData(n, s);
      });
      /** Allows a user to set a value for the provided `fieldPath`, which must be either a dotted path to the field OR a
       * `FieldPathList`. To set the root element, used either `''` or `[]` for the path. Passing undefined will clear the
       * value in the field.
       *
       * @param fieldPath - Either a dotted path to the field or the `FieldPathList` to the field
       * @param [newValue] - The new value for the field
       */
      Kn(this, "setFieldValue", (n, r) => {
        const { registry: o } = this.state, i = Array.isArray(n) ? n : n.split("."), a = Do("", o.globalFormOptions, i);
        this.onChange(r, i, void 0, a[rn]);
      });
      /** Pushes the given change information into the `pendingChanges` array and then calls `processPendingChanges()` if
       * the array only contains a single pending change.
       *
       * @param newValue - The new form data from a change to a field
       * @param path - The path to the change into which to set the formData
       * @param [newErrorSchema] - The new `ErrorSchema` based on the field change
       * @param [id] - The id of the field that caused the change
       */
      Kn(this, "onChange", (n, r, o, i) => {
        this.pendingChanges.push({ newValue: n, path: r, newErrorSchema: o, id: i }), this.pendingChanges.length === 1 && this.processPendingChange();
      });
      /**
       * Callback function to handle reset form data.
       * - Reset all fields with default values.
       * - Reset validations and errors
       *
       */
      Kn(this, "reset", () => {
        const { formData: n, initialFormData: r = y3, onChange: o } = this.props, s = {
          formData: this.getStateFromProps(this.props, n ?? r, void 0, void 0, void 0, !0).formData,
          errorSchema: {},
          errors: [],
          schemaValidationErrors: [],
          schemaValidationErrorSchema: {},
          initialDefaultsGenerated: !1,
          customErrors: void 0
        };
        this.setState(s, () => o && o(ju({ ...this.state, ...s })));
      });
      /** Callback function to handle when a field on the form is blurred. Calls the `onBlur` callback for the `Form` if it
       * was provided. Also runs any live validation and/or live omit operations if the flags indicate they should happen
       * during `onBlur`.
       *
       * @param id - The unique `id` of the field that was blurred
       * @param data - The data associated with the field that was blurred
       */
      Kn(this, "onBlur", (n, r) => {
        const { onBlur: o, omitExtraData: i, liveOmit: a, liveValidate: s } = this.props;
        if (o && o(n, r), i === !0 && a === "onBlur" || s === "onBlur") {
          const { onChange: c, extraErrors: u } = this.props, { formData: d } = this.state;
          let p = d, m = { formData: p };
          if (i === !0 && a === "onBlur" && (p = this.omitExtraData(d), m = { formData: p }), s === "onBlur") {
            const { schema: y, schemaUtils: b, errorSchema: v, customErrors: x, retrievedSchema: E } = this.state, _ = this.liveValidate(y, b, v, p, u, x, E);
            m = { formData: p, ..._, customErrors: x };
          }
          const g = Object.keys(m).filter((y) => !y.startsWith("schemaValidation")).some((y) => {
            const b = Ee(this.state, y), v = Ee(m, y);
            return !pn(b, v);
          });
          this.setState(m, () => {
            c && g && c(ju({ ...this.state, ...m }), n);
          });
        }
      });
      /** Callback function to handle when a field on the form is focused. Calls the `onFocus` callback for the `Form` if it
       * was provided.
       *
       * @param id - The unique `id` of the field that was focused
       * @param data - The data associated with the field that was focused
       */
      Kn(this, "onFocus", (n, r) => {
        const { onFocus: o } = this.props;
        o && o(n, r);
      });
      /** Callback function to handle when the form is submitted. First, it prevents the default event behavior. Nothing
       * happens if the target and currentTarget of the event are not the same. It will omit any extra data in the
       * `formData` in the state if `omitExtraData` is true. It will validate the resulting `formData`, reporting errors
       * via the `onError()` callback unless validation is disabled. Finally, it will add in any `extraErrors` and then call
       * back the `onSubmit` callback if it was provided.
       *
       * @param event - The submit HTML form event
       */
      Kn(this, "onSubmit", (n) => {
        if (n.preventDefault(), n.target !== n.currentTarget)
          return;
        n.persist();
        const { omitExtraData: r, extraErrors: o, noValidate: i, onSubmit: a } = this.props;
        let { formData: s } = this.state;
        if (r === !0 && (s = this.omitExtraData(s)), i || this.validateFormWithFormData(s)) {
          const c = o || {}, u = o ? CA(o) : [];
          this.setState({
            formData: s,
            errors: u,
            errorSchema: c,
            schemaValidationErrors: [],
            schemaValidationErrorSchema: {}
          }, () => {
            a && a(ju({ ...this.state, formData: s }, "submitted"), n);
          });
        }
      });
      /** Provides a function that can be used to programmatically submit the `Form` */
      Kn(this, "submit", () => {
        if (this.formElement.current) {
          const n = new CustomEvent("submit", {
            cancelable: !0
          });
          n.preventDefault(), this.formElement.current.dispatchEvent(n), this.formElement.current.requestSubmit();
        }
      });
      /** Validates the form using the given `formData`. For use on form submission or on programmatic validation.
       * If `onError` is provided, then it will be called with the list of errors.
       *
       * @param formData - The form data to validate
       * @returns - True if the form is valid, false otherwise.
       */
      Kn(this, "validateFormWithFormData", (n) => {
        const { extraErrors: r, extraErrorsBlockSubmit: o, focusOnFirstError: i, onError: a } = this.props, { errors: s } = this.state, c = this.validate(n);
        let u = c.errors, d = c.errorSchema;
        const p = u, m = d, g = u.length > 0 || r && o;
        if (g) {
          if (r) {
            const y = Kv(c, r);
            d = y.errorSchema, u = y.errors;
          }
          i && (typeof i == "function" ? i(u[0]) : this.focusOnError(u[0])), this.setState({
            errors: u,
            errorSchema: d,
            schemaValidationErrors: p,
            schemaValidationErrorSchema: m
          }, () => {
            a ? a(u) : console.error("Form validation failed", u);
          });
        } else s.length > 0 && this.setState({
          errors: [],
          errorSchema: {},
          schemaValidationErrors: [],
          schemaValidationErrorSchema: {}
        });
        return !g;
      });
      if (!n.validator)
        throw new Error("A validator is required for Form functionality to work");
      const { formData: r, initialFormData: o, onChange: i } = n, a = r ?? o;
      this.state = this.getStateFromProps(n, a, void 0, void 0, void 0, !0), i && !pn(this.state.formData, a) && i(ju(this.state)), this.formElement = T.createRef();
    }
    /**
     * `getSnapshotBeforeUpdate` is a React lifecycle method that is invoked right before the most recently rendered
     * output is committed to the DOM. It enables your component to capture current values (e.g., scroll position) before
     * they are potentially changed.
     *
     * In this case, it checks if the props have changed since the last render. If they have, it computes the next state
     * of the component using `getStateFromProps` method and returns it along with a `shouldUpdate` flag set to `true` IF
     * the `nextState` and `prevState` are different, otherwise `false`. This ensures that we have the most up-to-date
     * state ready to be applied in `componentDidUpdate`.
     *
     * If `formData` hasn't changed, it simply returns an object with `shouldUpdate` set to `false`, indicating that a
     * state update is not necessary.
     *
     * @param prevProps - The previous set of props before the update.
     * @param prevState - The previous state before the update.
     * @returns Either an object containing the next state and a flag indicating that an update should occur, or an object
     *        with a flag indicating that an update is not necessary.
     */
    getSnapshotBeforeUpdate(n, r) {
      if (!pn(this.props, n)) {
        const o = SD(this.props.formData, n.formData), i = SD(this.props.formData, this.state.formData), a = !pn(n.schema, this.props.schema), s = o.length > 0 || !pn(n.formData, this.props.formData), c = i.length > 0 || !pn(this.state.formData, this.props.formData), u = this.getStateFromProps(
          this.props,
          this.props.formData,
          // If the `schema` has changed, we need to update the retrieved schema.
          // Or if the `formData` changes, for example in the case of a schema with dependencies that need to
          //  match one of the subSchemas, the retrieved schema must be updated.
          a || s ? void 0 : this.state.retrievedSchema,
          a,
          o,
          // Skip live validation for this request if no form data has changed from the last state
          !c
        ), d = !pn(u, r);
        return { nextState: u, shouldUpdate: d };
      }
      return { shouldUpdate: !1 };
    }
    /**
     * `componentDidUpdate` is a React lifecycle method that is invoked immediately after updating occurs. This method is
     * not called for the initial render.
     *
     * Here, it checks if an update is necessary based on the `shouldUpdate` flag received from `getSnapshotBeforeUpdate`.
     * If an update is required, it applies the next state and, if needed, triggers the `onChange` handler to inform about
     * changes.
     *
     * @param _ - The previous set of props.
     * @param prevState - The previous state of the component before the update.
     * @param snapshot - The value returned from `getSnapshotBeforeUpdate`.
     */
    componentDidUpdate(n, r, o) {
      if (o.shouldUpdate) {
        const { nextState: i } = o;
        !pn(i.formData, this.props.formData) && !pn(i.formData, r.formData) && this.props.onChange && this.props.onChange(ju(i)), this.setState(i);
      }
    }
    /** Extracts the updated state from the given `props` and `inputFormData`. As part of this process, the
     * `inputFormData` is first processed to add any missing required defaults. After that, the data is run through the
     * validation process IF required by the `props`.
     *
     * @param props - The props passed to the `Form`
     * @param inputFormData - The new or current data for the `Form`
     * @param retrievedSchema - An expanded schema, if not provided, it will be retrieved from the `schema` and `formData`.
     * @param isSchemaChanged - A flag indicating whether the schema has changed.
     * @param formDataChangedFields - The changed fields of `formData`
     * @param skipLiveValidate - Optional flag, if true, means that we are not running live validation
     * @returns - The new state for the `Form`
     */
    getStateFromProps(n, r, o, i = !1, a = [], s = !1) {
      const c = this.state || {}, u = "schema" in n ? n.schema : this.props.schema, d = "validator" in n ? n.validator : this.props.validator, p = ("uiSchema" in n ? n.uiSchema : this.props.uiSchema) || {}, m = n.formData === void 0 && this.props.formData === void 0, g = typeof r < "u", y = "liveValidate" in n ? n.liveValidate : this.props.liveValidate, b = g && !n.noValidate && y, v = "experimental_defaultFormStateBehavior" in n ? n.experimental_defaultFormStateBehavior : this.props.experimental_defaultFormStateBehavior, x = "experimental_customMergeAllOf" in n ? n.experimental_customMergeAllOf : this.props.experimental_customMergeAllOf;
      let E = c.schemaUtils;
      (!E || E.doesSchemaUtilsDiffer(d, u, v, x)) && (E = zEe(d, u, v, x));
      const _ = E.getRootSchema();
      let C = r;
      r === y3 ? C = void 0 : r === void 0 && m && (C = c.formData);
      const k = E.getDefaultFormState(_, C, !1, c.initialDefaultsGenerated), A = this.updateRetrievedSchema(o ?? E.retrieveSchema(_, k)), O = () => n.noValidate || i ? { errors: [], errorSchema: {} } : n.liveValidate ? {
        errors: c.errors || [],
        errorSchema: c.errorSchema || {}
      } : {
        errors: c.schemaValidationErrors || [],
        errorSchema: c.schemaValidationErrorSchema || {}
      };
      let P, I, $ = c.schemaValidationErrors, L = c.schemaValidationErrorSchema;
      if (b && !s) {
        const F = this.liveValidate(
          _,
          E,
          c.errorSchema,
          k,
          void 0,
          c.customErrors,
          o,
          // If retrievedSchema is undefined which means the schema or formData has changed, we do not merge state.
          // Else in the case where it hasn't changed,
          o !== void 0
        );
        P = F.errors, I = F.errorSchema, $ = F.schemaValidationErrors, L = F.schemaValidationErrorSchema;
      } else {
        const F = O();
        if (P = F.errors, I = F.errorSchema, a.length > 0 && !b) {
          const W = a.reduce((Y, B) => (Y[B] = void 0, Y), {});
          I = L = Sh(F.errorSchema, W, "preventDuplicates");
        }
        const K = this.mergeErrors({ errorSchema: I, errors: P }, n.extraErrors, c.customErrors);
        P = K.errors, I = K.errorSchema;
      }
      const N = this.getRegistry(n, _, E), U = pn(c.registry, N) ? c.registry : N, j = c.fieldPathId && c.fieldPathId?.[rn] === U.globalFormOptions.idPrefix ? c.fieldPathId : Do("", U.globalFormOptions);
      return {
        schemaUtils: E,
        schema: _,
        uiSchema: p,
        fieldPathId: j,
        formData: k,
        edit: g,
        errors: P,
        errorSchema: I,
        schemaValidationErrors: $,
        schemaValidationErrorSchema: L,
        retrievedSchema: A,
        initialDefaultsGenerated: !0,
        registry: U
      };
    }
    /** React lifecycle method that is used to determine whether component should be updated.
     *
     * @param nextProps - The next version of the props
     * @param nextState - The next version of the state
     * @returns - True if the component should be updated, false otherwise
     */
    shouldComponentUpdate(n, r) {
      const { experimental_componentUpdateStrategy: o = "customDeep" } = this.props;
      return yV(this, n, r, o);
    }
    /** Validates the `formData` against the `schema` using the `altSchemaUtils` (if provided otherwise it uses the
     * `schemaUtils` in the state), returning the results.
     *
     * @param formData - The new form data to validate
     * @param schema - The schema used to validate against
     * @param [altSchemaUtils] - The alternate schemaUtils to use for validation
     * @param [retrievedSchema] - An optionally retrieved schema for per
     */
    validate(n, r = this.state.schema, o, i) {
      const a = o || this.state.schemaUtils, { customValidate: s, transformErrors: c, uiSchema: u } = this.props, d = i ?? a.retrieveSchema(r, n);
      return a.getValidator().validateFormData(n, d, s, c, u);
    }
    /** Renders any errors contained in the `state` in using the `ErrorList`, if not disabled by `showErrorList`. */
    renderErrors(n) {
      const { errors: r, errorSchema: o, schema: i, uiSchema: a } = this.state, s = Qe(a), c = tt("ErrorListTemplate", n, s);
      return r && r.length ? S.jsx(c, { errors: r, errorSchema: o || {}, schema: i, uiSchema: a, registry: n }) : null;
    }
    /** Merges any `extraErrors` or `customErrors` into the given `schemaValidation` object, returning the result
     *
     * @param schemaValidation - The `ValidationData` object into which additional errors are merged
     * @param [extraErrors] - The extra errors from the props
     * @param [customErrors] - The customErrors from custom components
     * @return - The `extraErrors` and `customErrors` merged into the `schemaValidation`
     * @private
     */
    mergeErrors(n, r, o) {
      let i = n.errorSchema, a = n.errors;
      if (r) {
        const s = Kv(n, r);
        i = s.errorSchema, a = s.errors;
      }
      if (o) {
        const s = Kv(n, o.ErrorSchema, !0);
        i = s.errorSchema, a = s.errors;
      }
      return { errors: a, errorSchema: i };
    }
    /** Performs live validation and then updates and returns the errors and error schemas by potentially merging in
     * `extraErrors` and `customErrors`.
     *
     * @param rootSchema - The `rootSchema` from the state
     * @param schemaUtils - The `SchemaUtilsType` from the state
     * @param originalErrorSchema - The original `ErrorSchema` from the state
     * @param [formData] - The new form data to validate
     * @param [extraErrors] - The extra errors from the props
     * @param [customErrors] - The customErrors from custom components
     * @param [retrievedSchema] - An expanded schema, if not provided, it will be retrieved from the `schema` and `formData`
     * @param [mergeIntoOriginalErrorSchema=false] - Optional flag indicating whether we merge into original schema
     * @returns - An object containing `errorSchema`, `errors`, `schemaValidationErrors` and `schemaValidationErrorSchema`
     * @private
     */
    liveValidate(n, r, o, i, a, s, c, u = !1) {
      const d = this.validate(i, n, r, c), p = d.errors;
      let m = d.errorSchema;
      u && (m = Sh(o, d.errorSchema, "preventDuplicates"));
      const g = p, y = m;
      return { ...this.mergeErrors({ errorSchema: m, errors: p }, a, s), schemaValidationErrors: g, schemaValidationErrorSchema: y };
    }
    /** Function to handle changes made to a field in the `Form`. This handler gets the first change from the
     * `pendingChanges` list, containing the `newValue` for the `formData` and the `path` at which the `newValue` is to be
     * updated, along with a new, optional `ErrorSchema` for that same `path` and potentially the `id` of the field being
     * changed. It will first update the `formData` with any missing default fields and then, if `omitExtraData` and
     * `liveOmit` are turned on, the `formData` will be filtered to remove any extra data not in a form field. Then, the
     * resulting `formData` will be validated if required. The state will be updated with the new updated (potentially
     * filtered) `formData`, any errors that resulted from validation. Finally the `onChange` callback will be called, if
     * specified, with the updated state and the `processPendingChange()` function is called again.
     */
    processPendingChange() {
      if (this.pendingChanges.length === 0)
        return;
      const { newValue: n, path: r, id: o } = this.pendingChanges[0], { newErrorSchema: i } = this.pendingChanges[0], { extraErrors: a, omitExtraData: s, liveOmit: c, noValidate: u, liveValidate: d, onChange: p } = this.props, { formData: m, schemaUtils: g, schema: y, fieldPathId: b, schemaValidationErrorSchema: v, errors: x } = this.state;
      let { customErrors: E, errorSchema: _ } = this.state;
      const C = b.path[0] || "", k = !r || r.length === 0 || r.length === 1 && r[0] === C;
      let A = this.state.retrievedSchema, O = k ? n : xA(m);
      if (Rt(O) || Array.isArray(O)) {
        n === BV ? Hke(O, r) : k || Qt(O, r, n);
        const L = this.getStateFromProps(this.props, O, void 0, void 0, void 0, !0);
        O = L.formData, A = L.retrievedSchema;
      }
      const P = !u && (d === !0 || d === "onChange");
      let I = { formData: O, schema: y }, $ = O;
      if (s === !0 && (c === !0 || c === "onChange") && ($ = this.omitExtraData(O), I = {
        formData: $
      }), i) {
        const L = k ? v : Ee(v, r);
        if (!Hn(L))
          k ? _ = i : Qt(_, r, i);
        else if (E || (E = new fV()), k) {
          const N = Ee(i, ur);
          N && E.setErrors(N);
        } else
          Qt(E.ErrorSchema, r, i);
      } else E && Ee(E.ErrorSchema, [...r, ur]) && E.clearErrors(r);
      if (P && this.pendingChanges.length === 1) {
        const L = this.liveValidate(y, g, _, $, a, E, A);
        I = { formData: $, ...L, customErrors: E };
      } else if (!u && i) {
        const L = this.mergeErrors({ errorSchema: _, errors: x }, a, E);
        I = {
          formData: $,
          ...L,
          customErrors: E
        };
      }
      this.setState(I, () => {
        p && p(ju({ ...this.state, ...I }), o), this.pendingChanges.shift(), this.processPendingChange();
      });
    }
    /**
     * If the retrievedSchema has changed the new retrievedSchema is returned.
     * Otherwise, the old retrievedSchema is returned to persist reference.
     * -  This ensures that AJV retrieves the schema from the cache when it has not changed,
     *    avoiding the performance cost of recompiling the schema.
     *
     * @param retrievedSchema The new retrieved schema.
     * @returns The new retrieved schema if it has changed, else the old retrieved schema.
     */
    updateRetrievedSchema(n) {
      return pn(n, this.state?.retrievedSchema) ? this.state.retrievedSchema : n;
    }
    /** Extracts the `GlobalFormOptions` from the given Form `props`
     *
     * @param props - The form props to extract the global form options from
     * @returns - The `GlobalFormOptions` from the props
     * @private
     */
    getGlobalFormOptions(n) {
      const { uiSchema: r = {}, experimental_componentUpdateStrategy: o, idSeparator: i = X8, idPrefix: a = Y8, nameGenerator: s, useFallbackUiForUnsupportedType: c = !1 } = n;
      return {
        idPrefix: r["ui:rootFieldId"] || a,
        idSeparator: i,
        useFallbackUiForUnsupportedType: c,
        ...o !== void 0 && { experimental_componentUpdateStrategy: o },
        ...s !== void 0 && { nameGenerator: s }
      };
    }
    /** Computed the registry for the form using the given `props`, `schema` and `schemaUtils` */
    getRegistry(n, r, o) {
      const { translateString: i, uiSchema: a = {} } = n, { fields: s, templates: c, widgets: u, formContext: d, translateString: p } = VRe();
      return {
        fields: { ...s, ...n.fields },
        templates: {
          ...c,
          ...n.templates,
          ButtonTemplates: {
            ...c.ButtonTemplates,
            ...n.templates?.ButtonTemplates
          }
        },
        widgets: { ...u, ...n.widgets },
        rootSchema: r,
        formContext: n.formContext || d,
        schemaUtils: o,
        translateString: i || p,
        globalUiOptions: a[SC],
        globalFormOptions: this.getGlobalFormOptions(n)
      };
    }
    /** Attempts to focus on the field associated with the `error`. Uses the `property` field to compute path of the error
     * field, then, using the `idPrefix` and `idSeparator` converts that path into an id. Then the input element with that
     * id is attempted to be found using the `formElement` ref. If it is located, then it is focused.
     *
     * @param error - The error on which to focus
     */
    focusOnError(n) {
      const { idPrefix: r = "root", idSeparator: o = "_" } = this.props, { property: i } = n, a = vV(i);
      a[0] === "" ? a[0] = r : a.unshift(r);
      const s = a.join(o);
      let c = this.formElement.current.elements[s];
      c || (c = this.formElement.current.querySelector(`input[id^="${s}"`)), c && c.length && (c = c[0]), c && c.focus();
    }
    /** Programmatically validate the form.  If `omitExtraData` is true, the `formData` will first be filtered to remove
     * any extra data not in a form field. If `onError` is provided, then it will be called with the list of errors the
     * same way as would happen on form submission.
     *
     * @returns - True if the form is valid, false otherwise.
     */
    validateForm() {
      const { omitExtraData: n } = this.props;
      let { formData: r } = this.state;
      return n === !0 && (r = this.omitExtraData(r)), this.validateFormWithFormData(r);
    }
    /** Renders the `Form` fields inside the <form> | `tagName` or `_internalFormWrapper`, rendering any errors if
     * needed along with the submit button or any children of the form.
     */
    render() {
      const { children: n, id: r, className: o = "", tagName: i, name: a, method: s, target: c, action: u, autoComplete: d, enctype: p, acceptCharset: m, noHtml5Validate: g = !1, disabled: y, readonly: b, showErrorList: v = "top", _internalFormWrapper: x } = this.props, { schema: E, uiSchema: _, formData: C, errorSchema: k, fieldPathId: A, registry: O } = this.state, { SchemaField: P } = O.fields, { SubmitButton: I } = O.templates.ButtonTemplates, $ = x ? i : void 0, L = x || i || "form";
      let { [$0]: N = {} } = Qe(_);
      y && (N = { ...N, props: { ...N.props, disabled: !0 } });
      const U = { [Zs]: { [$0]: N } };
      return S.jsxs(L, { className: o || "rjsf", id: r, name: a, method: s, target: c, action: u, autoComplete: d, encType: p, acceptCharset: m, noValidate: g, onSubmit: this.onSubmit, as: $, ref: this.formElement, children: [v === "top" && this.renderErrors(O), S.jsx(P, { name: "", schema: E, uiSchema: _, errorSchema: k, fieldPathId: A, formData: C, onChange: this.onChange, onBlur: this.onBlur, onFocus: this.onFocus, registry: O, disabled: y, readonly: b }), n || S.jsx(I, { uiSchema: U, registry: O }), v === "bottom" && this.renderErrors(O)] });
    }
  };
  function WV(e) {
    return T.forwardRef(({ fields: t, widgets: n, templates: r, ...o }, i) => (t = { ...e?.fields, ...t }, n = { ...e?.widgets, ...n }, r = {
      ...e?.templates,
      ...r,
      ButtonTemplates: {
        ...e?.templates?.ButtonTemplates,
        ...r?.ButtonTemplates
      }
    }, S.jsx(HRe, { ...e, ...o, fields: t, widgets: n, templates: r, ref: i })));
  }
  function DC(...e) {
    return e.reduce((t, n) => n == null ? t : function(...o) {
      t.apply(this, o), n.apply(this, o);
    }, () => {
    });
  }
  function GV(e, t = 166) {
    let n;
    function r(...o) {
      const i = () => {
        e.apply(this, o);
      };
      clearTimeout(n), n = setTimeout(i, t);
    }
    return r.clear = () => {
      clearTimeout(n);
    }, r;
  }
  function Ar(e) {
    return e && e.ownerDocument || document;
  }
  function Qa(e) {
    return Ar(e).defaultView || window;
  }
  function v3(e, t) {
    typeof e == "function" ? e(t) : e && (e.current = t);
  }
  function Eh(e) {
    const {
      controlled: t,
      default: n,
      name: r,
      state: o = "value"
    } = e, {
      current: i
    } = T.useRef(t !== void 0), [a, s] = T.useState(n), c = i ? t : a, u = T.useCallback((d) => {
      i || s(d);
    }, []);
    return [c, u];
  }
  function qRe(e, t) {
    const n = e.charCodeAt(2);
    return e[0] === "o" && e[1] === "n" && n >= 65 && n <= 90 && typeof t == "function";
  }
  function KV(e, t) {
    if (!e)
      return t;
    function n(a, s) {
      const c = {};
      return Object.keys(s).forEach((u) => {
        qRe(u, s[u]) && typeof a[u] == "function" && (c[u] = (...d) => {
          a[u](...d), s[u](...d);
        });
      }), c;
    }
    if (typeof e == "function" || typeof t == "function")
      return (a) => {
        const s = typeof t == "function" ? t(a) : t, c = typeof e == "function" ? e({
          ...a,
          ...s
        }) : e, u = $e(a?.className, s?.className, c?.className), d = n(c, s);
        return {
          ...s,
          ...c,
          ...d,
          ...!!u && {
            className: u
          },
          ...s?.style && c?.style && {
            style: {
              ...s.style,
              ...c.style
            }
          },
          ...s?.sx && c?.sx && {
            sx: [...Array.isArray(s.sx) ? s.sx : [s.sx], ...Array.isArray(c.sx) ? c.sx : [c.sx]]
          }
        };
      };
    const r = t, o = n(e, r), i = $e(r?.className, e?.className);
    return {
      ...t,
      ...e,
      ...o,
      ...!!i && {
        className: i
      },
      ...r?.style && e?.style && {
        style: {
          ...r.style,
          ...e.style
        }
      },
      ...r?.sx && e?.sx && {
        sx: [...Array.isArray(r.sx) ? r.sx : [r.sx], ...Array.isArray(e.sx) ? e.sx : [e.sx]]
      }
    };
  }
  const YV = po(/* @__PURE__ */ S.jsx("path", {
    d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z"
  }));
  function WRe(e) {
    return typeof e.main == "string";
  }
  function GRe(e, t = []) {
    if (!WRe(e))
      return !1;
    for (const n of t)
      if (!e.hasOwnProperty(n) || typeof e[n] != "string")
        return !1;
    return !0;
  }
  function wr(e = []) {
    return ([, t]) => t && GRe(t, e);
  }
  function KRe(e) {
    return ot("MuiCircularProgress", e);
  }
  nt("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "track", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
  const qo = 44, FC = If`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`, LC = If`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: -126px;
  }
`, YRe = typeof FC != "string" ? Dh`
        animation: ${FC} 1.4s linear infinite;
      ` : null, XRe = typeof LC != "string" ? Dh`
        animation: ${LC} 1.4s ease-in-out infinite;
      ` : null, ZRe = (e) => {
    const {
      classes: t,
      variant: n,
      color: r,
      disableShrink: o
    } = e, i = {
      root: ["root", n, `color${Ie(r)}`],
      svg: ["svg"],
      track: ["track"],
      circle: ["circle", `circle${Ie(n)}`, o && "circleDisableShrink"]
    };
    return rt(i, KRe, t);
  }, QRe = Re("span", {
    name: "MuiCircularProgress",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[n.variant], t[`color${Ie(n.color)}`]];
    }
  })(st(({
    theme: e
  }) => ({
    display: "inline-block",
    variants: [{
      props: {
        variant: "determinate"
      },
      style: {
        transition: e.transitions.create("transform")
      }
    }, {
      props: {
        variant: "indeterminate"
      },
      style: YRe || {
        animation: `${FC} 1.4s linear infinite`
      }
    }, ...Object.entries(e.palette).filter(wr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        color: (e.vars || e).palette[t].main
      }
    }))]
  }))), JRe = Re("svg", {
    name: "MuiCircularProgress",
    slot: "Svg"
  })({
    display: "block"
    // Keeps the progress centered
  }), eOe = Re("circle", {
    name: "MuiCircularProgress",
    slot: "Circle",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.circle, t[`circle${Ie(n.variant)}`], n.disableShrink && t.circleDisableShrink];
    }
  })(st(({
    theme: e
  }) => ({
    stroke: "currentColor",
    variants: [{
      props: {
        variant: "determinate"
      },
      style: {
        transition: e.transitions.create("stroke-dashoffset")
      }
    }, {
      props: {
        variant: "indeterminate"
      },
      style: {
        // Some default value that looks fine waiting for the animation to kicks in.
        strokeDasharray: "80px, 200px",
        strokeDashoffset: 0
        // Add the unit to fix a Edge 16 and below bug.
      }
    }, {
      props: ({
        ownerState: t
      }) => t.variant === "indeterminate" && !t.disableShrink,
      style: XRe || {
        // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.
        animation: `${LC} 1.4s ease-in-out infinite`
      }
    }]
  }))), tOe = Re("circle", {
    name: "MuiCircularProgress",
    slot: "Track"
  })(st(({
    theme: e
  }) => ({
    stroke: "currentColor",
    opacity: (e.vars || e).palette.action.activatedOpacity
  }))), XV = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiCircularProgress"
    }), {
      className: o,
      color: i = "primary",
      disableShrink: a = !1,
      enableTrackSlot: s = !1,
      size: c = 40,
      style: u,
      thickness: d = 3.6,
      value: p = 0,
      variant: m = "indeterminate",
      ...g
    } = r, y = {
      ...r,
      color: i,
      disableShrink: a,
      size: c,
      thickness: d,
      value: p,
      variant: m,
      enableTrackSlot: s
    }, b = ZRe(y), v = {}, x = {}, E = {};
    if (m === "determinate") {
      const _ = 2 * Math.PI * ((qo - d) / 2);
      v.strokeDasharray = _.toFixed(3), E["aria-valuenow"] = Math.round(p), v.strokeDashoffset = `${((100 - p) / 100 * _).toFixed(3)}px`, x.transform = "rotate(-90deg)";
    }
    return /* @__PURE__ */ S.jsx(QRe, {
      className: $e(b.root, o),
      style: {
        width: c,
        height: c,
        ...x,
        ...u
      },
      ownerState: y,
      ref: n,
      role: "progressbar",
      ...E,
      ...g,
      children: /* @__PURE__ */ S.jsxs(JRe, {
        className: b.svg,
        ownerState: y,
        viewBox: `${qo / 2} ${qo / 2} ${qo} ${qo}`,
        children: [s ? /* @__PURE__ */ S.jsx(tOe, {
          className: b.track,
          ownerState: y,
          cx: qo,
          cy: qo,
          r: (qo - d) / 2,
          fill: "none",
          strokeWidth: d,
          "aria-hidden": "true"
        }) : null, /* @__PURE__ */ S.jsx(eOe, {
          className: b.circle,
          style: v,
          ownerState: y,
          cx: qo,
          cy: qo,
          r: (qo - d) / 2,
          fill: "none",
          strokeWidth: d
        })]
      })
    });
  });
  function nOe(e) {
    return ot("MuiIconButton", e);
  }
  const b3 = nt("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge", "loading", "loadingIndicator", "loadingWrapper"]), rOe = (e) => {
    const {
      classes: t,
      disabled: n,
      color: r,
      edge: o,
      size: i,
      loading: a
    } = e, s = {
      root: ["root", a && "loading", n && "disabled", r !== "default" && `color${Ie(r)}`, o && `edge${Ie(o)}`, `size${Ie(i)}`],
      loadingIndicator: ["loadingIndicator"],
      loadingWrapper: ["loadingWrapper"]
    };
    return rt(s, nOe, t);
  }, oOe = Re(Lh, {
    name: "MuiIconButton",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.loading && t.loading, n.color !== "default" && t[`color${Ie(n.color)}`], n.edge && t[`edge${Ie(n.edge)}`], t[`size${Ie(n.size)}`]];
    }
  })(st(({
    theme: e
  }) => ({
    textAlign: "center",
    flex: "0 0 auto",
    fontSize: e.typography.pxToRem(24),
    padding: 8,
    borderRadius: "50%",
    color: (e.vars || e).palette.action.active,
    transition: e.transitions.create("background-color", {
      duration: e.transitions.duration.shortest
    }),
    variants: [{
      props: (t) => !t.disableRipple,
      style: {
        "--IconButton-hoverBg": e.alpha((e.vars || e).palette.action.active, (e.vars || e).palette.action.hoverOpacity),
        "&:hover": {
          backgroundColor: "var(--IconButton-hoverBg)",
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }
      }
    }, {
      props: {
        edge: "start"
      },
      style: {
        marginLeft: -12
      }
    }, {
      props: {
        edge: "start",
        size: "small"
      },
      style: {
        marginLeft: -3
      }
    }, {
      props: {
        edge: "end"
      },
      style: {
        marginRight: -12
      }
    }, {
      props: {
        edge: "end",
        size: "small"
      },
      style: {
        marginRight: -3
      }
    }]
  })), st(({
    theme: e
  }) => ({
    variants: [{
      props: {
        color: "inherit"
      },
      style: {
        color: "inherit"
      }
    }, ...Object.entries(e.palette).filter(wr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        color: (e.vars || e).palette[t].main
      }
    })), ...Object.entries(e.palette).filter(wr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        "--IconButton-hoverBg": e.alpha((e.vars || e).palette[t].main, (e.vars || e).palette.action.hoverOpacity)
      }
    })), {
      props: {
        size: "small"
      },
      style: {
        padding: 5,
        fontSize: e.typography.pxToRem(18)
      }
    }, {
      props: {
        size: "large"
      },
      style: {
        padding: 12,
        fontSize: e.typography.pxToRem(28)
      }
    }],
    [`&.${b3.disabled}`]: {
      backgroundColor: "transparent",
      color: (e.vars || e).palette.action.disabled
    },
    [`&.${b3.loading}`]: {
      color: "transparent"
    }
  }))), iOe = Re("span", {
    name: "MuiIconButton",
    slot: "LoadingIndicator"
  })(({
    theme: e
  }) => ({
    display: "none",
    position: "absolute",
    visibility: "visible",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    color: (e.vars || e).palette.action.disabled,
    variants: [{
      props: {
        loading: !0
      },
      style: {
        display: "flex"
      }
    }]
  })), ZV = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiIconButton"
    }), {
      edge: o = !1,
      children: i,
      className: a,
      color: s = "default",
      disabled: c = !1,
      disableFocusRipple: u = !1,
      size: d = "medium",
      id: p,
      loading: m = null,
      loadingIndicator: g,
      ...y
    } = r, b = $f(p), v = g ?? /* @__PURE__ */ S.jsx(XV, {
      "aria-labelledby": b,
      color: "inherit",
      size: 16
    }), x = {
      ...r,
      edge: o,
      color: s,
      disabled: c,
      disableFocusRipple: u,
      loading: m,
      loadingIndicator: v,
      size: d
    }, E = rOe(x);
    return /* @__PURE__ */ S.jsxs(oOe, {
      id: m ? b : p,
      className: $e(E.root, a),
      centerRipple: !0,
      focusRipple: !u,
      disabled: c || m,
      ref: n,
      ...y,
      ownerState: x,
      children: [typeof m == "boolean" && // use plain HTML span to minimize the runtime overhead
      /* @__PURE__ */ S.jsx("span", {
        className: E.loadingWrapper,
        style: {
          display: "contents"
        },
        children: /* @__PURE__ */ S.jsx(iOe, {
          className: E.loadingIndicator,
          ownerState: x,
          children: m && v
        })
      }), i]
    });
  });
  function aOe({ uiSchema: e, registry: t, ...n }) {
    const { translateString: r } = t;
    return S.jsx(ZV, { title: r(bt.AddItemButton), ...n, color: "primary", children: S.jsx(YV, {}) });
  }
  function sOe({
    theme: e,
    ...t
  }) {
    const n = zi in e ? e[zi] : void 0;
    return /* @__PURE__ */ S.jsx(_F, {
      ...t,
      themeId: n ? zi : void 0,
      theme: n || e
    });
  }
  const fv = {
    colorSchemeStorageKey: "mui-color-scheme",
    defaultLightColorScheme: "light",
    defaultDarkColorScheme: "dark",
    modeStorageKey: "mui-mode"
  }, {
    CssVarsProvider: lOe
  } = ZX({
    themeId: zi,
    // @ts-ignore ignore module augmentation tests
    theme: () => mb({
      cssVariables: !0
    }),
    colorSchemeStorageKey: fv.colorSchemeStorageKey,
    modeStorageKey: fv.modeStorageKey,
    defaultColorScheme: {
      light: fv.defaultLightColorScheme,
      dark: fv.defaultDarkColorScheme
    },
    resolveTheme: (e) => {
      const t = {
        ...e,
        typography: AF(e.palette, e.typography)
      };
      return t.unstable_sx = function(r) {
        return nl({
          sx: r,
          theme: this
        });
      }, t;
    }
  }), cOe = lOe;
  function uOe({
    theme: e,
    ...t
  }) {
    const n = T.useMemo(() => {
      if (typeof e == "function")
        return e;
      const r = zi in e ? e[zi] : e;
      return "colorSchemes" in r ? null : "vars" in r ? e : {
        ...e,
        vars: null
      };
    }, [e]);
    return n ? /* @__PURE__ */ S.jsx(sOe, {
      theme: n,
      ...t
    }) : /* @__PURE__ */ S.jsx(cOe, {
      theme: e,
      ...t
    });
  }
  const fOe = nt("MuiBox", ["root"]), dOe = mb(), pl = gX({
    themeId: zi,
    defaultTheme: dOe,
    defaultClassName: fOe.root,
    generateClassName: hF.generate
  }), fr = vZ({
    createStyledComponent: Re("div", {
      name: "MuiGrid",
      slot: "Root",
      overridesResolver: (e, t) => {
        const {
          ownerState: n
        } = e;
        return [t.root, n.container && t.container];
      }
    }),
    componentName: "MuiGrid",
    useThemeProps: (e) => ut({
      props: e,
      name: "MuiGrid"
    }),
    useTheme: gb
  });
  function pOe(e) {
    return ot("MuiPaper", e);
  }
  nt("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
  const hOe = (e) => {
    const {
      square: t,
      elevation: n,
      variant: r,
      classes: o
    } = e, i = {
      root: ["root", r, !t && "rounded", r === "elevation" && `elevation${n}`]
    };
    return rt(i, pOe, o);
  }, mOe = Re("div", {
    name: "MuiPaper",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[n.variant], !n.square && t.rounded, n.variant === "elevation" && t[`elevation${n.elevation}`]];
    }
  })(st(({
    theme: e
  }) => ({
    backgroundColor: (e.vars || e).palette.background.paper,
    color: (e.vars || e).palette.text.primary,
    transition: e.transitions.create("box-shadow"),
    variants: [{
      props: ({
        ownerState: t
      }) => !t.square,
      style: {
        borderRadius: e.shape.borderRadius
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        border: `1px solid ${(e.vars || e).palette.divider}`
      }
    }, {
      props: {
        variant: "elevation"
      },
      style: {
        boxShadow: "var(--Paper-shadow)",
        backgroundImage: "var(--Paper-overlay)"
      }
    }]
  }))), A1 = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiPaper"
    }), o = gb(), {
      className: i,
      component: a = "div",
      elevation: s = 1,
      square: c = !1,
      variant: u = "elevation",
      ...d
    } = r, p = {
      ...r,
      component: a,
      elevation: s,
      square: c,
      variant: u
    }, m = hOe(p);
    return /* @__PURE__ */ S.jsx(mOe, {
      as: a,
      ownerState: p,
      className: $e(m.root, i),
      ref: n,
      ...d,
      style: {
        ...u === "elevation" && {
          "--Paper-shadow": (o.vars || o).shadows[s],
          ...o.vars && {
            "--Paper-overlay": o.vars.overlays?.[s]
          },
          ...!o.vars && o.palette.mode === "dark" && {
            "--Paper-overlay": `linear-gradient(${Jv("#fff", SE(s))}, ${Jv("#fff", SE(s))})`
          }
        },
        ...d.style
      }
    });
  });
  function gOe(e) {
    const { children: t, buttonsProps: n, hasDescription: r, hasToolbar: o, uiSchema: i, registry: a } = e, s = Qe(i), c = tt("ArrayFieldItemButtonsTemplate", a, s), u = {
      flex: 1,
      paddingLeft: 6,
      paddingRight: 6,
      fontWeight: "bold",
      minWidth: 0
    };
    return S.jsxs(fr, { container: !0, alignItems: "center", children: [S.jsx(fr, { size: { xs: 8, sm: 9, md: 10, lg: 11, xl: 11.25 }, style: { overflow: "auto" }, children: S.jsx(pl, { mb: 2, children: S.jsx(A1, { elevation: 2, children: S.jsx(pl, { p: 2, children: t }) }) }) }), o && S.jsx(fr, { sx: { mt: r ? -5 : -1.5 }, children: S.jsx(c, { ...n, style: u }) })] });
  }
  function yOe(e) {
    const { canAdd: t, disabled: n, fieldPathId: r, uiSchema: o, items: i, optionalDataControl: a, onAddClick: s, readonly: c, registry: u, required: d, schema: p, title: m } = e, g = Qe(o), y = tt("ArrayFieldDescriptionTemplate", u, g), b = tt("ArrayFieldTitleTemplate", u, g), v = !c && !n, { ButtonTemplates: { AddButton: x } } = u.templates;
    return S.jsx(A1, { elevation: 2, children: S.jsxs(pl, { p: 2, children: [S.jsx(b, { fieldPathId: r, title: g.title || m, schema: p, uiSchema: o, required: d, registry: u, optionalDataControl: v ? a : void 0 }), S.jsx(y, { fieldPathId: r, description: g.description || p.description, schema: p, uiSchema: o, registry: u }), v ? void 0 : a, i, t && S.jsx(fr, { container: !0, justifyContent: "flex-end", children: S.jsx(fr, { children: S.jsx(pl, { mt: 2, children: S.jsx(x, { id: ji(r, "add"), className: "rjsf-array-item-add", onClick: s, disabled: n || c, uiSchema: o, registry: u }) }) }) })] }) });
  }
  function dv(e) {
    return parseInt(e, 10) || 0;
  }
  const vOe = {
    shadow: {
      // Visibility needed to hide the extra text area on iPads
      visibility: "hidden",
      // Remove from the content flow
      position: "absolute",
      // Ignore the scrollbar width
      overflow: "hidden",
      height: 0,
      top: 0,
      left: 0,
      // Create a new layer, increase the isolation of the computed values
      transform: "translateZ(0)"
    }
  };
  function bOe(e) {
    for (const t in e)
      return !1;
    return !0;
  }
  function x3(e) {
    return bOe(e) || e.outerHeightStyle === 0 && !e.overflowing;
  }
  const xOe = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const {
      onChange: r,
      maxRows: o,
      minRows: i = 1,
      style: a,
      value: s,
      ...c
    } = t, {
      current: u
    } = T.useRef(s != null), d = T.useRef(null), p = er(n, d), m = T.useRef(null), g = T.useRef(null), y = T.useCallback(() => {
      const _ = d.current, C = g.current;
      if (!_ || !C)
        return;
      const A = Qa(_).getComputedStyle(_);
      if (A.width === "0px")
        return {
          outerHeightStyle: 0,
          overflowing: !1
        };
      C.style.width = A.width, C.value = _.value || t.placeholder || "x", C.value.slice(-1) === `
` && (C.value += " ");
      const O = A.boxSizing, P = dv(A.paddingBottom) + dv(A.paddingTop), I = dv(A.borderBottomWidth) + dv(A.borderTopWidth), $ = C.scrollHeight;
      C.value = "x";
      const L = C.scrollHeight;
      let N = $;
      i && (N = Math.max(Number(i) * L, N)), o && (N = Math.min(Number(o) * L, N)), N = Math.max(N, L);
      const U = N + (O === "border-box" ? P + I : 0), j = Math.abs(N - $) <= 1;
      return {
        outerHeightStyle: U,
        overflowing: j
      };
    }, [o, i, t.placeholder]), b = Bi(() => {
      const _ = d.current, C = y();
      if (!_ || !C || x3(C))
        return !1;
      const k = C.outerHeightStyle;
      return m.current != null && m.current !== k;
    }), v = T.useCallback(() => {
      const _ = d.current, C = y();
      if (!_ || !C || x3(C))
        return;
      const k = C.outerHeightStyle;
      m.current !== k && (m.current = k, _.style.height = `${k}px`), _.style.overflow = C.overflowing ? "hidden" : "";
    }, [y]), x = T.useRef(-1);
    ei(() => {
      const _ = GV(v), C = d?.current;
      if (!C)
        return;
      const k = Qa(C);
      k.addEventListener("resize", _);
      let A;
      return typeof ResizeObserver < "u" && (A = new ResizeObserver(() => {
        b() && (A.unobserve(C), cancelAnimationFrame(x.current), v(), x.current = requestAnimationFrame(() => {
          A.observe(C);
        }));
      }), A.observe(C)), () => {
        _.clear(), cancelAnimationFrame(x.current), k.removeEventListener("resize", _), A && A.disconnect();
      };
    }, [y, v, b]), ei(() => {
      v();
    });
    const E = (_) => {
      u || v();
      const C = _.target, k = C.value.length, A = C.value.endsWith(`
`), O = C.selectionStart === k;
      A && O && C.setSelectionRange(k, k), r && r(_);
    };
    return /* @__PURE__ */ S.jsxs(T.Fragment, {
      children: [/* @__PURE__ */ S.jsx("textarea", {
        value: s,
        onChange: E,
        ref: p,
        rows: i,
        style: a,
        ...c
      }), /* @__PURE__ */ S.jsx("textarea", {
        "aria-hidden": !0,
        className: t.className,
        readOnly: !0,
        ref: g,
        tabIndex: -1,
        style: {
          ...vOe.shadow,
          ...a,
          paddingTop: 0,
          paddingBottom: 0
        }
      })]
    });
  });
  function yl({
    props: e,
    states: t,
    muiFormControl: n
  }) {
    return t.reduce((r, o) => (r[o] = e[o], n && typeof e[o] > "u" && (r[o] = n[o]), r), {});
  }
  const jA = /* @__PURE__ */ T.createContext(void 0);
  function ra() {
    return T.useContext(jA);
  }
  function w3(e) {
    return e != null && !(Array.isArray(e) && e.length === 0);
  }
  function U0(e, t = !1) {
    return e && (w3(e.value) && e.value !== "" || t && w3(e.defaultValue) && e.defaultValue !== "");
  }
  function wOe(e) {
    return e.startAdornment;
  }
  function SOe(e) {
    return ot("MuiInputBase", e);
  }
  const Of = nt("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
  var S3;
  const R1 = (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.formControl && t.formControl, n.startAdornment && t.adornedStart, n.endAdornment && t.adornedEnd, n.error && t.error, n.size === "small" && t.sizeSmall, n.multiline && t.multiline, n.color && t[`color${Ie(n.color)}`], n.fullWidth && t.fullWidth, n.hiddenLabel && t.hiddenLabel];
  }, O1 = (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.input, n.size === "small" && t.inputSizeSmall, n.multiline && t.inputMultiline, n.type === "search" && t.inputTypeSearch, n.startAdornment && t.inputAdornedStart, n.endAdornment && t.inputAdornedEnd, n.hiddenLabel && t.inputHiddenLabel];
  }, _Oe = (e) => {
    const {
      classes: t,
      color: n,
      disabled: r,
      error: o,
      endAdornment: i,
      focused: a,
      formControl: s,
      fullWidth: c,
      hiddenLabel: u,
      multiline: d,
      readOnly: p,
      size: m,
      startAdornment: g,
      type: y
    } = e, b = {
      root: ["root", `color${Ie(n)}`, r && "disabled", o && "error", c && "fullWidth", a && "focused", s && "formControl", m && m !== "medium" && `size${Ie(m)}`, d && "multiline", g && "adornedStart", i && "adornedEnd", u && "hiddenLabel", p && "readOnly"],
      input: ["input", r && "disabled", y === "search" && "inputTypeSearch", d && "inputMultiline", m === "small" && "inputSizeSmall", u && "inputHiddenLabel", g && "inputAdornedStart", i && "inputAdornedEnd", p && "readOnly"]
    };
    return rt(b, SOe, t);
  }, M1 = Re("div", {
    name: "MuiInputBase",
    slot: "Root",
    overridesResolver: R1
  })(st(({
    theme: e
  }) => ({
    ...e.typography.body1,
    color: (e.vars || e).palette.text.primary,
    lineHeight: "1.4375em",
    // 23px
    boxSizing: "border-box",
    // Prevent padding issue with fullWidth.
    position: "relative",
    cursor: "text",
    display: "inline-flex",
    alignItems: "center",
    [`&.${Of.disabled}`]: {
      color: (e.vars || e).palette.text.disabled,
      cursor: "default"
    },
    variants: [{
      props: ({
        ownerState: t
      }) => t.multiline,
      style: {
        padding: "4px 0 5px"
      }
    }, {
      props: ({
        ownerState: t,
        size: n
      }) => t.multiline && n === "small",
      style: {
        paddingTop: 1
      }
    }, {
      props: ({
        ownerState: t
      }) => t.fullWidth,
      style: {
        width: "100%"
      }
    }]
  }))), N1 = Re("input", {
    name: "MuiInputBase",
    slot: "Input",
    overridesResolver: O1
  })(st(({
    theme: e
  }) => {
    const t = e.palette.mode === "light", n = {
      color: "currentColor",
      ...e.vars ? {
        opacity: e.vars.opacity.inputPlaceholder
      } : {
        opacity: t ? 0.42 : 0.5
      },
      transition: e.transitions.create("opacity", {
        duration: e.transitions.duration.shorter
      })
    }, r = {
      opacity: "0 !important"
    }, o = e.vars ? {
      opacity: e.vars.opacity.inputPlaceholder
    } : {
      opacity: t ? 0.42 : 0.5
    };
    return {
      font: "inherit",
      letterSpacing: "inherit",
      color: "currentColor",
      padding: "4px 0 5px",
      border: 0,
      boxSizing: "content-box",
      background: "none",
      height: "1.4375em",
      // Reset 23pxthe native input line-height
      margin: 0,
      // Reset for Safari
      WebkitTapHighlightColor: "transparent",
      display: "block",
      // Make the flex item shrink with Firefox
      minWidth: 0,
      width: "100%",
      "&::-webkit-input-placeholder": n,
      "&::-moz-placeholder": n,
      // Firefox 19+
      "&::-ms-input-placeholder": n,
      // Edge
      "&:focus": {
        outline: 0
      },
      // Reset Firefox invalid required input style
      "&:invalid": {
        boxShadow: "none"
      },
      "&::-webkit-search-decoration": {
        // Remove the padding when type=search.
        WebkitAppearance: "none"
      },
      // Show and hide the placeholder logic
      [`label[data-shrink=false] + .${Of.formControl} &`]: {
        "&::-webkit-input-placeholder": r,
        "&::-moz-placeholder": r,
        // Firefox 19+
        "&::-ms-input-placeholder": r,
        // Edge
        "&:focus::-webkit-input-placeholder": o,
        "&:focus::-moz-placeholder": o,
        // Firefox 19+
        "&:focus::-ms-input-placeholder": o
        // Edge
      },
      [`&.${Of.disabled}`]: {
        opacity: 1,
        // Reset iOS opacity
        WebkitTextFillColor: (e.vars || e).palette.text.disabled
        // Fix opacity Safari bug
      },
      variants: [{
        props: ({
          ownerState: i
        }) => !i.disableInjectingGlobalStyles,
        style: {
          animationName: "mui-auto-fill-cancel",
          animationDuration: "10ms",
          "&:-webkit-autofill": {
            animationDuration: "5000s",
            animationName: "mui-auto-fill"
          }
        }
      }, {
        props: {
          size: "small"
        },
        style: {
          paddingTop: 1
        }
      }, {
        props: ({
          ownerState: i
        }) => i.multiline,
        style: {
          height: "auto",
          resize: "none",
          padding: 0,
          paddingTop: 0
        }
      }, {
        props: {
          type: "search"
        },
        style: {
          MozAppearance: "textfield"
          // Improve type search style.
        }
      }]
    };
  })), _3 = QZ({
    "@keyframes mui-auto-fill": {
      from: {
        display: "block"
      }
    },
    "@keyframes mui-auto-fill-cancel": {
      from: {
        display: "block"
      }
    }
  }), DA = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiInputBase"
    }), {
      "aria-describedby": o,
      autoComplete: i,
      autoFocus: a,
      className: s,
      color: c,
      components: u = {},
      componentsProps: d = {},
      defaultValue: p,
      disabled: m,
      disableInjectingGlobalStyles: g,
      endAdornment: y,
      error: b,
      fullWidth: v = !1,
      id: x,
      inputComponent: E = "input",
      inputProps: _ = {},
      inputRef: C,
      margin: k,
      maxRows: A,
      minRows: O,
      multiline: P = !1,
      name: I,
      onBlur: $,
      onChange: L,
      onClick: N,
      onFocus: U,
      onKeyDown: j,
      onKeyUp: V,
      placeholder: F,
      readOnly: K,
      renderSuffix: W,
      rows: Y,
      size: B,
      slotProps: D = {},
      slots: G = {},
      startAdornment: z,
      type: H = "text",
      value: X,
      ...Q
    } = r, ne = _.value != null ? _.value : X, {
      current: te
    } = T.useRef(ne != null), se = T.useRef(), ue = T.useCallback((He) => {
    }, []), J = er(se, C, _.ref, ue), [ee, ie] = T.useState(!1), le = ra(), ge = yl({
      props: r,
      muiFormControl: le,
      states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
    });
    ge.focused = le ? le.focused : ee, T.useEffect(() => {
      !le && m && ee && (ie(!1), $ && $());
    }, [le, m, ee, $]);
    const Se = le && le.onFilled, Me = le && le.onEmpty, je = T.useCallback((He) => {
      U0(He) ? Se && Se() : Me && Me();
    }, [Se, Me]);
    ei(() => {
      te && je({
        value: ne
      });
    }, [ne, je, te]);
    const ze = (He) => {
      U && U(He), _.onFocus && _.onFocus(He), le && le.onFocus ? le.onFocus(He) : ie(!0);
    }, Ye = (He) => {
      $ && $(He), _.onBlur && _.onBlur(He), le && le.onBlur ? le.onBlur(He) : ie(!1);
    }, Ue = (He, ...Ot) => {
      if (!te) {
        const it = He.target || se.current;
        if (it == null)
          throw new Error(Va(1));
        je({
          value: it.value
        });
      }
      _.onChange && _.onChange(He, ...Ot), L && L(He, ...Ot);
    };
    T.useEffect(() => {
      je(se.current);
    }, []);
    const Ne = (He) => {
      se.current && He.currentTarget === He.target && se.current.focus(), N && N(He);
    };
    let mt = E, Je = _;
    P && mt === "input" && (Y ? Je = {
      type: void 0,
      minRows: Y,
      maxRows: Y,
      ...Je
    } : Je = {
      type: void 0,
      maxRows: A,
      minRows: O,
      ...Je
    }, mt = xOe);
    const Ae = (He) => {
      je(He.animationName === "mui-auto-fill-cancel" ? se.current : {
        value: "x"
      });
    };
    T.useEffect(() => {
      le && le.setAdornedStart(!!z);
    }, [le, z]);
    const oe = {
      ...r,
      color: ge.color || "primary",
      disabled: ge.disabled,
      endAdornment: y,
      error: ge.error,
      focused: ge.focused,
      formControl: le,
      fullWidth: v,
      hiddenLabel: ge.hiddenLabel,
      multiline: P,
      size: ge.size,
      startAdornment: z,
      type: H
    }, fe = _Oe(oe), _e = G.root || u.Root || M1, Ce = D.root || d.root || {}, Oe = G.input || u.Input || N1;
    return Je = {
      ...Je,
      ...D.input ?? d.input
    }, /* @__PURE__ */ S.jsxs(T.Fragment, {
      children: [!g && typeof _3 == "function" && // For Emotion/Styled-components, InputGlobalStyles will be a function
      // For Pigment CSS, this has no effect because the InputGlobalStyles will be null.
      (S3 || (S3 = /* @__PURE__ */ S.jsx(_3, {}))), /* @__PURE__ */ S.jsxs(_e, {
        ...Ce,
        ref: n,
        onClick: Ne,
        ...Q,
        ...!Ui(_e) && {
          ownerState: {
            ...oe,
            ...Ce.ownerState
          }
        },
        className: $e(fe.root, Ce.className, s, K && "MuiInputBase-readOnly"),
        children: [z, /* @__PURE__ */ S.jsx(jA.Provider, {
          value: null,
          children: /* @__PURE__ */ S.jsx(Oe, {
            "aria-invalid": ge.error,
            "aria-describedby": o,
            autoComplete: i,
            autoFocus: a,
            defaultValue: p,
            disabled: ge.disabled,
            id: x,
            onAnimationStart: Ae,
            name: I,
            placeholder: F,
            readOnly: K,
            required: ge.required,
            rows: Y,
            value: ne,
            onKeyDown: j,
            onKeyUp: V,
            type: H,
            ...Je,
            ...!Ui(Oe) && {
              as: mt,
              ownerState: {
                ...oe,
                ...Je.ownerState
              }
            },
            ref: J,
            className: $e(fe.input, Je.className, K && "MuiInputBase-readOnly"),
            onBlur: Ye,
            onChange: Ue,
            onFocus: ze
          })
        }), y, W ? W({
          ...ge,
          startAdornment: z
        }) : null]
      })]
    });
  });
  function EOe(e) {
    return ot("MuiInput", e);
  }
  const op = {
    ...Of,
    ...nt("MuiInput", ["root", "underline", "input"])
  }, COe = (e) => {
    const {
      classes: t,
      disableUnderline: n
    } = e, o = rt({
      root: ["root", !n && "underline"],
      input: ["input"]
    }, EOe, t);
    return {
      ...t,
      // forward classes to the InputBase
      ...o
    };
  }, kOe = Re(M1, {
    shouldForwardProp: (e) => Sr(e) || e === "classes",
    name: "MuiInput",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [...R1(e, t), !n.disableUnderline && t.underline];
    }
  })(st(({
    theme: e
  }) => {
    let n = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
    return e.vars && (n = e.alpha(e.vars.palette.common.onBackground, e.vars.opacity.inputUnderline)), {
      position: "relative",
      variants: [{
        props: ({
          ownerState: r
        }) => r.formControl,
        style: {
          "label + &": {
            marginTop: 16
          }
        }
      }, {
        props: ({
          ownerState: r
        }) => !r.disableUnderline,
        style: {
          "&::after": {
            left: 0,
            bottom: 0,
            content: '""',
            position: "absolute",
            right: 0,
            transform: "scaleX(0)",
            transition: e.transitions.create("transform", {
              duration: e.transitions.duration.shorter,
              easing: e.transitions.easing.easeOut
            }),
            pointerEvents: "none"
            // Transparent to the hover style.
          },
          [`&.${op.focused}:after`]: {
            // translateX(0) is a workaround for Safari transform scale bug
            // See https://github.com/mui/material-ui/issues/31766
            transform: "scaleX(1) translateX(0)"
          },
          [`&.${op.error}`]: {
            "&::before, &::after": {
              borderBottomColor: (e.vars || e).palette.error.main
            }
          },
          "&::before": {
            borderBottom: `1px solid ${n}`,
            left: 0,
            bottom: 0,
            content: '"\\00a0"',
            position: "absolute",
            right: 0,
            transition: e.transitions.create("border-bottom-color", {
              duration: e.transitions.duration.shorter
            }),
            pointerEvents: "none"
            // Transparent to the hover style.
          },
          [`&:hover:not(.${op.disabled}, .${op.error}):before`]: {
            borderBottom: `2px solid ${(e.vars || e).palette.text.primary}`,
            // Reset on touch devices, it doesn't add specificity
            "@media (hover: none)": {
              borderBottom: `1px solid ${n}`
            }
          },
          [`&.${op.disabled}:before`]: {
            borderBottomStyle: "dotted"
          }
        }
      }, ...Object.entries(e.palette).filter(wr()).map(([r]) => ({
        props: {
          color: r,
          disableUnderline: !1
        },
        style: {
          "&::after": {
            borderBottom: `2px solid ${(e.vars || e).palette[r].main}`
          }
        }
      }))]
    };
  })), TOe = Re(N1, {
    name: "MuiInput",
    slot: "Input",
    overridesResolver: O1
  })({}), FA = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiInput"
    }), {
      disableUnderline: o = !1,
      components: i = {},
      componentsProps: a,
      fullWidth: s = !1,
      inputComponent: c = "input",
      multiline: u = !1,
      slotProps: d,
      slots: p = {},
      type: m = "text",
      ...g
    } = r, y = COe(r), v = {
      root: {
        ownerState: {
          disableUnderline: o
        }
      }
    }, x = d ?? a ? xr(d ?? a, v) : v, E = p.root ?? i.Root ?? kOe, _ = p.input ?? i.Input ?? TOe;
    return /* @__PURE__ */ S.jsx(DA, {
      slots: {
        root: E,
        input: _
      },
      slotProps: x,
      fullWidth: s,
      inputComponent: c,
      multiline: u,
      ref: n,
      type: m,
      ...g,
      classes: y
    });
  });
  FA.muiName = "Input";
  function AOe(e) {
    return ot("MuiFilledInput", e);
  }
  const ql = {
    ...Of,
    ...nt("MuiFilledInput", ["root", "underline", "input", "adornedStart", "adornedEnd", "sizeSmall", "multiline", "hiddenLabel"])
  }, ROe = (e) => {
    const {
      classes: t,
      disableUnderline: n,
      startAdornment: r,
      endAdornment: o,
      size: i,
      hiddenLabel: a,
      multiline: s
    } = e, c = {
      root: ["root", !n && "underline", r && "adornedStart", o && "adornedEnd", i === "small" && `size${Ie(i)}`, a && "hiddenLabel", s && "multiline"],
      input: ["input"]
    }, u = rt(c, AOe, t);
    return {
      ...t,
      // forward classes to the InputBase
      ...u
    };
  }, OOe = Re(M1, {
    shouldForwardProp: (e) => Sr(e) || e === "classes",
    name: "MuiFilledInput",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [...R1(e, t), !n.disableUnderline && t.underline];
    }
  })(st(({
    theme: e
  }) => {
    const t = e.palette.mode === "light", n = t ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)", r = t ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)", o = t ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)", i = t ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
    return {
      position: "relative",
      backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r,
      borderTopLeftRadius: (e.vars || e).shape.borderRadius,
      borderTopRightRadius: (e.vars || e).shape.borderRadius,
      transition: e.transitions.create("background-color", {
        duration: e.transitions.duration.shorter,
        easing: e.transitions.easing.easeOut
      }),
      "&:hover": {
        backgroundColor: e.vars ? e.vars.palette.FilledInput.hoverBg : o,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r
        }
      },
      [`&.${ql.focused}`]: {
        backgroundColor: e.vars ? e.vars.palette.FilledInput.bg : r
      },
      [`&.${ql.disabled}`]: {
        backgroundColor: e.vars ? e.vars.palette.FilledInput.disabledBg : i
      },
      variants: [{
        props: ({
          ownerState: a
        }) => !a.disableUnderline,
        style: {
          "&::after": {
            left: 0,
            bottom: 0,
            content: '""',
            position: "absolute",
            right: 0,
            transform: "scaleX(0)",
            transition: e.transitions.create("transform", {
              duration: e.transitions.duration.shorter,
              easing: e.transitions.easing.easeOut
            }),
            pointerEvents: "none"
            // Transparent to the hover style.
          },
          [`&.${ql.focused}:after`]: {
            // translateX(0) is a workaround for Safari transform scale bug
            // See https://github.com/mui/material-ui/issues/31766
            transform: "scaleX(1) translateX(0)"
          },
          [`&.${ql.error}`]: {
            "&::before, &::after": {
              borderBottomColor: (e.vars || e).palette.error.main
            }
          },
          "&::before": {
            borderBottom: `1px solid ${e.vars ? e.alpha(e.vars.palette.common.onBackground, e.vars.opacity.inputUnderline) : n}`,
            left: 0,
            bottom: 0,
            content: '"\\00a0"',
            position: "absolute",
            right: 0,
            transition: e.transitions.create("border-bottom-color", {
              duration: e.transitions.duration.shorter
            }),
            pointerEvents: "none"
            // Transparent to the hover style.
          },
          [`&:hover:not(.${ql.disabled}, .${ql.error}):before`]: {
            borderBottom: `1px solid ${(e.vars || e).palette.text.primary}`
          },
          [`&.${ql.disabled}:before`]: {
            borderBottomStyle: "dotted"
          }
        }
      }, ...Object.entries(e.palette).filter(wr()).map(([a]) => ({
        props: {
          disableUnderline: !1,
          color: a
        },
        style: {
          "&::after": {
            borderBottom: `2px solid ${(e.vars || e).palette[a]?.main}`
          }
        }
      })), {
        props: ({
          ownerState: a
        }) => a.startAdornment,
        style: {
          paddingLeft: 12
        }
      }, {
        props: ({
          ownerState: a
        }) => a.endAdornment,
        style: {
          paddingRight: 12
        }
      }, {
        props: ({
          ownerState: a
        }) => a.multiline,
        style: {
          padding: "25px 12px 8px"
        }
      }, {
        props: ({
          ownerState: a,
          size: s
        }) => a.multiline && s === "small",
        style: {
          paddingTop: 21,
          paddingBottom: 4
        }
      }, {
        props: ({
          ownerState: a
        }) => a.multiline && a.hiddenLabel,
        style: {
          paddingTop: 16,
          paddingBottom: 17
        }
      }, {
        props: ({
          ownerState: a
        }) => a.multiline && a.hiddenLabel && a.size === "small",
        style: {
          paddingTop: 8,
          paddingBottom: 9
        }
      }]
    };
  })), MOe = Re(N1, {
    name: "MuiFilledInput",
    slot: "Input",
    overridesResolver: O1
  })(st(({
    theme: e
  }) => ({
    paddingTop: 25,
    paddingRight: 12,
    paddingBottom: 8,
    paddingLeft: 12,
    ...!e.vars && {
      "&:-webkit-autofill": {
        WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
        WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
        caretColor: e.palette.mode === "light" ? null : "#fff",
        borderTopLeftRadius: "inherit",
        borderTopRightRadius: "inherit"
      }
    },
    ...e.vars && {
      "&:-webkit-autofill": {
        borderTopLeftRadius: "inherit",
        borderTopRightRadius: "inherit"
      },
      [e.getColorSchemeSelector("dark")]: {
        "&:-webkit-autofill": {
          WebkitBoxShadow: "0 0 0 100px #266798 inset",
          WebkitTextFillColor: "#fff",
          caretColor: "#fff"
        }
      }
    },
    variants: [{
      props: {
        size: "small"
      },
      style: {
        paddingTop: 21,
        paddingBottom: 4
      }
    }, {
      props: ({
        ownerState: t
      }) => t.hiddenLabel,
      style: {
        paddingTop: 16,
        paddingBottom: 17
      }
    }, {
      props: ({
        ownerState: t
      }) => t.startAdornment,
      style: {
        paddingLeft: 0
      }
    }, {
      props: ({
        ownerState: t
      }) => t.endAdornment,
      style: {
        paddingRight: 0
      }
    }, {
      props: ({
        ownerState: t
      }) => t.hiddenLabel && t.size === "small",
      style: {
        paddingTop: 8,
        paddingBottom: 9
      }
    }, {
      props: ({
        ownerState: t
      }) => t.multiline,
      style: {
        paddingTop: 0,
        paddingBottom: 0,
        paddingLeft: 0,
        paddingRight: 0
      }
    }]
  }))), LA = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiFilledInput"
    }), {
      disableUnderline: o = !1,
      components: i = {},
      componentsProps: a,
      fullWidth: s = !1,
      hiddenLabel: c,
      // declare here to prevent spreading to DOM
      inputComponent: u = "input",
      multiline: d = !1,
      slotProps: p,
      slots: m = {},
      type: g = "text",
      ...y
    } = r, b = {
      ...r,
      disableUnderline: o,
      fullWidth: s,
      inputComponent: u,
      multiline: d,
      type: g
    }, v = ROe(r), x = {
      root: {
        ownerState: b
      },
      input: {
        ownerState: b
      }
    }, E = p ?? a ? xr(x, p ?? a) : x, _ = m.root ?? i.Root ?? OOe, C = m.input ?? i.Input ?? MOe;
    return /* @__PURE__ */ S.jsx(DA, {
      slots: {
        root: _,
        input: C
      },
      slotProps: E,
      fullWidth: s,
      inputComponent: u,
      multiline: d,
      ref: n,
      type: g,
      ...y,
      classes: v
    });
  });
  LA.muiName = "Input";
  var E3;
  const NOe = Re("fieldset", {
    name: "MuiNotchedOutlined",
    shouldForwardProp: Sr
  })({
    textAlign: "left",
    position: "absolute",
    bottom: 0,
    right: 0,
    top: -5,
    left: 0,
    margin: 0,
    padding: "0 8px",
    pointerEvents: "none",
    borderRadius: "inherit",
    borderStyle: "solid",
    borderWidth: 1,
    overflow: "hidden",
    minWidth: "0%"
  }), POe = Re("legend", {
    name: "MuiNotchedOutlined",
    shouldForwardProp: Sr
  })(st(({
    theme: e
  }) => ({
    float: "unset",
    // Fix conflict with bootstrap
    width: "auto",
    // Fix conflict with bootstrap
    overflow: "hidden",
    // Fix Horizontal scroll when label too long
    variants: [{
      props: ({
        ownerState: t
      }) => !t.withLabel,
      style: {
        padding: 0,
        lineHeight: "11px",
        // sync with `height` in `legend` styles
        transition: e.transitions.create("width", {
          duration: 150,
          easing: e.transitions.easing.easeOut
        })
      }
    }, {
      props: ({
        ownerState: t
      }) => t.withLabel,
      style: {
        display: "block",
        // Fix conflict with normalize.css and sanitize.css
        padding: 0,
        height: 11,
        // sync with `lineHeight` in `legend` styles
        fontSize: "0.75em",
        visibility: "hidden",
        maxWidth: 0.01,
        transition: e.transitions.create("max-width", {
          duration: 50,
          easing: e.transitions.easing.easeOut
        }),
        whiteSpace: "nowrap",
        "& > span": {
          paddingLeft: 5,
          paddingRight: 5,
          display: "inline-block",
          opacity: 0,
          visibility: "visible"
        }
      }
    }, {
      props: ({
        ownerState: t
      }) => t.withLabel && t.notched,
      style: {
        maxWidth: "100%",
        transition: e.transitions.create("max-width", {
          duration: 100,
          easing: e.transitions.easing.easeOut,
          delay: 50
        })
      }
    }]
  })));
  function IOe(e) {
    const {
      children: t,
      classes: n,
      className: r,
      label: o,
      notched: i,
      ...a
    } = e, s = o != null && o !== "", c = {
      ...e,
      notched: i,
      withLabel: s
    };
    return /* @__PURE__ */ S.jsx(NOe, {
      "aria-hidden": !0,
      className: r,
      ownerState: c,
      ...a,
      children: /* @__PURE__ */ S.jsx(POe, {
        ownerState: c,
        children: s ? /* @__PURE__ */ S.jsx("span", {
          children: o
        }) : (
          // notranslate needed while Google Translate will not fix zero-width space issue
          E3 || (E3 = /* @__PURE__ */ S.jsx("span", {
            className: "notranslate",
            "aria-hidden": !0,
            children: ""
          }))
        )
      })
    });
  }
  function $Oe(e) {
    return ot("MuiOutlinedInput", e);
  }
  const bi = {
    ...Of,
    ...nt("MuiOutlinedInput", ["root", "notchedOutline", "input"])
  }, jOe = (e) => {
    const {
      classes: t
    } = e, r = rt({
      root: ["root"],
      notchedOutline: ["notchedOutline"],
      input: ["input"]
    }, $Oe, t);
    return {
      ...t,
      // forward classes to the InputBase
      ...r
    };
  }, DOe = Re(M1, {
    shouldForwardProp: (e) => Sr(e) || e === "classes",
    name: "MuiOutlinedInput",
    slot: "Root",
    overridesResolver: R1
  })(st(({
    theme: e
  }) => {
    const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
    return {
      position: "relative",
      borderRadius: (e.vars || e).shape.borderRadius,
      [`&:hover .${bi.notchedOutline}`]: {
        borderColor: (e.vars || e).palette.text.primary
      },
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        [`&:hover .${bi.notchedOutline}`]: {
          borderColor: e.vars ? e.alpha(e.vars.palette.common.onBackground, 0.23) : t
        }
      },
      [`&.${bi.focused} .${bi.notchedOutline}`]: {
        borderWidth: 2
      },
      variants: [...Object.entries(e.palette).filter(wr()).map(([n]) => ({
        props: {
          color: n
        },
        style: {
          [`&.${bi.focused} .${bi.notchedOutline}`]: {
            borderColor: (e.vars || e).palette[n].main
          }
        }
      })), {
        props: {},
        // to override the above style
        style: {
          [`&.${bi.error} .${bi.notchedOutline}`]: {
            borderColor: (e.vars || e).palette.error.main
          },
          [`&.${bi.disabled} .${bi.notchedOutline}`]: {
            borderColor: (e.vars || e).palette.action.disabled
          }
        }
      }, {
        props: ({
          ownerState: n
        }) => n.startAdornment,
        style: {
          paddingLeft: 14
        }
      }, {
        props: ({
          ownerState: n
        }) => n.endAdornment,
        style: {
          paddingRight: 14
        }
      }, {
        props: ({
          ownerState: n
        }) => n.multiline,
        style: {
          padding: "16.5px 14px"
        }
      }, {
        props: ({
          ownerState: n,
          size: r
        }) => n.multiline && r === "small",
        style: {
          padding: "8.5px 14px"
        }
      }]
    };
  })), FOe = Re(IOe, {
    name: "MuiOutlinedInput",
    slot: "NotchedOutline"
  })(st(({
    theme: e
  }) => {
    const t = e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
    return {
      borderColor: e.vars ? e.alpha(e.vars.palette.common.onBackground, 0.23) : t
    };
  })), LOe = Re(N1, {
    name: "MuiOutlinedInput",
    slot: "Input",
    overridesResolver: O1
  })(st(({
    theme: e
  }) => ({
    padding: "16.5px 14px",
    ...!e.vars && {
      "&:-webkit-autofill": {
        WebkitBoxShadow: e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
        WebkitTextFillColor: e.palette.mode === "light" ? null : "#fff",
        caretColor: e.palette.mode === "light" ? null : "#fff",
        borderRadius: "inherit"
      }
    },
    ...e.vars && {
      "&:-webkit-autofill": {
        borderRadius: "inherit"
      },
      [e.getColorSchemeSelector("dark")]: {
        "&:-webkit-autofill": {
          WebkitBoxShadow: "0 0 0 100px #266798 inset",
          WebkitTextFillColor: "#fff",
          caretColor: "#fff"
        }
      }
    },
    variants: [{
      props: {
        size: "small"
      },
      style: {
        padding: "8.5px 14px"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.multiline,
      style: {
        padding: 0
      }
    }, {
      props: ({
        ownerState: t
      }) => t.startAdornment,
      style: {
        paddingLeft: 0
      }
    }, {
      props: ({
        ownerState: t
      }) => t.endAdornment,
      style: {
        paddingRight: 0
      }
    }]
  }))), zA = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiOutlinedInput"
    }), {
      components: o = {},
      fullWidth: i = !1,
      inputComponent: a = "input",
      label: s,
      multiline: c = !1,
      notched: u,
      slots: d = {},
      slotProps: p = {},
      type: m = "text",
      ...g
    } = r, y = jOe(r), b = ra(), v = yl({
      props: r,
      muiFormControl: b,
      states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
    }), x = {
      ...r,
      color: v.color || "primary",
      disabled: v.disabled,
      error: v.error,
      focused: v.focused,
      formControl: b,
      fullWidth: i,
      hiddenLabel: v.hiddenLabel,
      multiline: c,
      size: v.size,
      type: m
    }, E = d.root ?? o.Root ?? DOe, _ = d.input ?? o.Input ?? LOe, [C, k] = ln("notchedOutline", {
      elementType: FOe,
      className: y.notchedOutline,
      shouldForwardComponentProp: !0,
      ownerState: x,
      externalForwardedProps: {
        slots: d,
        slotProps: p
      },
      additionalProps: {
        label: s != null && s !== "" && v.required ? /* @__PURE__ */ S.jsxs(T.Fragment, {
          children: [s, "", "*"]
        }) : s
      }
    });
    return /* @__PURE__ */ S.jsx(DA, {
      slots: {
        root: E,
        input: _
      },
      slotProps: p,
      renderSuffix: (A) => /* @__PURE__ */ S.jsx(C, {
        ...k,
        notched: typeof u < "u" ? u : !!(A.startAdornment || A.filled || A.focused)
      }),
      fullWidth: i,
      inputComponent: a,
      multiline: c,
      ref: n,
      type: m,
      ...g,
      classes: {
        ...y,
        notchedOutline: null
      }
    });
  });
  zA.muiName = "Input";
  function zOe(e) {
    return ot("MuiFormLabel", e);
  }
  const Lp = nt("MuiFormLabel", ["root", "colorSecondary", "focused", "disabled", "error", "filled", "required", "asterisk"]), BOe = (e) => {
    const {
      classes: t,
      color: n,
      focused: r,
      disabled: o,
      error: i,
      filled: a,
      required: s
    } = e, c = {
      root: ["root", `color${Ie(n)}`, o && "disabled", i && "error", a && "filled", r && "focused", s && "required"],
      asterisk: ["asterisk", i && "error"]
    };
    return rt(c, zOe, t);
  }, UOe = Re("label", {
    name: "MuiFormLabel",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.color === "secondary" && t.colorSecondary, n.filled && t.filled];
    }
  })(st(({
    theme: e
  }) => ({
    color: (e.vars || e).palette.text.secondary,
    ...e.typography.body1,
    lineHeight: "1.4375em",
    padding: 0,
    position: "relative",
    variants: [...Object.entries(e.palette).filter(wr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        [`&.${Lp.focused}`]: {
          color: (e.vars || e).palette[t].main
        }
      }
    })), {
      props: {},
      style: {
        [`&.${Lp.disabled}`]: {
          color: (e.vars || e).palette.text.disabled
        },
        [`&.${Lp.error}`]: {
          color: (e.vars || e).palette.error.main
        }
      }
    }]
  }))), VOe = Re("span", {
    name: "MuiFormLabel",
    slot: "Asterisk"
  })(st(({
    theme: e
  }) => ({
    [`&.${Lp.error}`]: {
      color: (e.vars || e).palette.error.main
    }
  }))), P1 = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiFormLabel"
    }), {
      children: o,
      className: i,
      color: a,
      component: s = "label",
      disabled: c,
      error: u,
      filled: d,
      focused: p,
      required: m,
      ...g
    } = r, y = ra(), b = yl({
      props: r,
      muiFormControl: y,
      states: ["color", "required", "focused", "disabled", "error", "filled"]
    }), v = {
      ...r,
      color: b.color || "primary",
      component: s,
      disabled: b.disabled,
      error: b.error,
      filled: b.filled,
      focused: b.focused,
      required: b.required
    }, x = BOe(v);
    return /* @__PURE__ */ S.jsxs(UOe, {
      as: s,
      ownerState: v,
      className: $e(x.root, i),
      ref: n,
      ...g,
      children: [o, b.required && /* @__PURE__ */ S.jsxs(VOe, {
        ownerState: v,
        "aria-hidden": !0,
        className: x.asterisk,
        children: ["", "*"]
      })]
    });
  });
  function HOe(e) {
    return ot("MuiInputLabel", e);
  }
  nt("MuiInputLabel", ["root", "focused", "disabled", "error", "required", "asterisk", "formControl", "sizeSmall", "shrink", "animated", "standard", "filled", "outlined"]);
  const qOe = (e) => {
    const {
      classes: t,
      formControl: n,
      size: r,
      shrink: o,
      disableAnimation: i,
      variant: a,
      required: s
    } = e, c = {
      root: ["root", n && "formControl", !i && "animated", o && "shrink", r && r !== "medium" && `size${Ie(r)}`, a],
      asterisk: [s && "asterisk"]
    }, u = rt(c, HOe, t);
    return {
      ...t,
      // forward the focused, disabled, etc. classes to the FormLabel
      ...u
    };
  }, WOe = Re(P1, {
    shouldForwardProp: (e) => Sr(e) || e === "classes",
    name: "MuiInputLabel",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [{
        [`& .${Lp.asterisk}`]: t.asterisk
      }, t.root, n.formControl && t.formControl, n.size === "small" && t.sizeSmall, n.shrink && t.shrink, !n.disableAnimation && t.animated, n.focused && t.focused, t[n.variant]];
    }
  })(st(({
    theme: e
  }) => ({
    display: "block",
    transformOrigin: "top left",
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",
    maxWidth: "100%",
    variants: [{
      props: ({
        ownerState: t
      }) => t.formControl,
      style: {
        position: "absolute",
        left: 0,
        top: 0,
        // slight alteration to spec spacing to match visual spec result
        transform: "translate(0, 20px) scale(1)"
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        // Compensation for the `Input.inputSizeSmall` style.
        transform: "translate(0, 17px) scale(1)"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.shrink,
      style: {
        transform: "translate(0, -1.5px) scale(0.75)",
        transformOrigin: "top left",
        maxWidth: "133%"
      }
    }, {
      props: ({
        ownerState: t
      }) => !t.disableAnimation,
      style: {
        transition: e.transitions.create(["color", "transform", "max-width"], {
          duration: e.transitions.duration.shorter,
          easing: e.transitions.easing.easeOut
        })
      }
    }, {
      props: {
        variant: "filled"
      },
      style: {
        // Chrome's autofill feature gives the input field a yellow background.
        // Since the input field is behind the label in the HTML tree,
        // the input field is drawn last and hides the label with an opaque background color.
        // zIndex: 1 will raise the label above opaque background-colors of input.
        zIndex: 1,
        pointerEvents: "none",
        transform: "translate(12px, 16px) scale(1)",
        maxWidth: "calc(100% - 24px)"
      }
    }, {
      props: {
        variant: "filled",
        size: "small"
      },
      style: {
        transform: "translate(12px, 13px) scale(1)"
      }
    }, {
      props: ({
        variant: t,
        ownerState: n
      }) => t === "filled" && n.shrink,
      style: {
        userSelect: "none",
        pointerEvents: "auto",
        transform: "translate(12px, 7px) scale(0.75)",
        maxWidth: "calc(133% - 24px)"
      }
    }, {
      props: ({
        variant: t,
        ownerState: n,
        size: r
      }) => t === "filled" && n.shrink && r === "small",
      style: {
        transform: "translate(12px, 4px) scale(0.75)"
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        // see comment above on filled.zIndex
        zIndex: 1,
        pointerEvents: "none",
        transform: "translate(14px, 16px) scale(1)",
        maxWidth: "calc(100% - 24px)"
      }
    }, {
      props: {
        variant: "outlined",
        size: "small"
      },
      style: {
        transform: "translate(14px, 9px) scale(1)"
      }
    }, {
      props: ({
        variant: t,
        ownerState: n
      }) => t === "outlined" && n.shrink,
      style: {
        userSelect: "none",
        pointerEvents: "auto",
        // Theoretically, we should have (8+5)*2/0.75 = 34px
        // but it feels a better when it bleeds a bit on the left, so 32px.
        maxWidth: "calc(133% - 32px)",
        transform: "translate(14px, -9px) scale(0.75)"
      }
    }]
  }))), GOe = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      name: "MuiInputLabel",
      props: t
    }), {
      disableAnimation: o = !1,
      margin: i,
      shrink: a,
      variant: s,
      className: c,
      ...u
    } = r, d = ra();
    let p = a;
    typeof p > "u" && d && (p = d.filled || d.focused || d.adornedStart);
    const m = yl({
      props: r,
      muiFormControl: d,
      states: ["size", "variant", "required", "focused"]
    }), g = {
      ...r,
      disableAnimation: o,
      formControl: d,
      shrink: p,
      size: m.size,
      variant: m.variant,
      required: m.required,
      focused: m.focused
    }, y = qOe(g);
    return /* @__PURE__ */ S.jsx(WOe, {
      "data-shrink": p,
      ref: n,
      className: $e(y.root, c),
      ...u,
      ownerState: g,
      classes: y
    });
  });
  function KOe(e) {
    return ot("MuiFormControl", e);
  }
  nt("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
  const YOe = (e) => {
    const {
      classes: t,
      margin: n,
      fullWidth: r
    } = e, o = {
      root: ["root", n !== "none" && `margin${Ie(n)}`, r && "fullWidth"]
    };
    return rt(o, KOe, t);
  }, XOe = Re("div", {
    name: "MuiFormControl",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[`margin${Ie(n.margin)}`], n.fullWidth && t.fullWidth];
    }
  })({
    display: "inline-flex",
    flexDirection: "column",
    position: "relative",
    // Reset fieldset default style.
    minWidth: 0,
    padding: 0,
    margin: 0,
    border: 0,
    verticalAlign: "top",
    // Fix alignment issue on Safari.
    variants: [{
      props: {
        margin: "normal"
      },
      style: {
        marginTop: 16,
        marginBottom: 8
      }
    }, {
      props: {
        margin: "dense"
      },
      style: {
        marginTop: 8,
        marginBottom: 4
      }
    }, {
      props: {
        fullWidth: !0
      },
      style: {
        width: "100%"
      }
    }]
  }), BA = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiFormControl"
    }), {
      children: o,
      className: i,
      color: a = "primary",
      component: s = "div",
      disabled: c = !1,
      error: u = !1,
      focused: d,
      fullWidth: p = !1,
      hiddenLabel: m = !1,
      margin: g = "none",
      required: y = !1,
      size: b = "medium",
      variant: v = "outlined",
      ...x
    } = r, E = {
      ...r,
      color: a,
      component: s,
      disabled: c,
      error: u,
      fullWidth: p,
      hiddenLabel: m,
      margin: g,
      required: y,
      size: b,
      variant: v
    }, _ = YOe(E), [C, k] = T.useState(() => {
      let V = !1;
      return o && T.Children.forEach(o, (F) => {
        if (!Tp(F, ["Input", "Select"]))
          return;
        const K = Tp(F, ["Select"]) ? F.props.input : F;
        K && wOe(K.props) && (V = !0);
      }), V;
    }), [A, O] = T.useState(() => {
      let V = !1;
      return o && T.Children.forEach(o, (F) => {
        Tp(F, ["Input", "Select"]) && (U0(F.props, !0) || U0(F.props.inputProps, !0)) && (V = !0);
      }), V;
    }), [P, I] = T.useState(!1);
    c && P && I(!1);
    const $ = d !== void 0 && !c ? d : P;
    let L;
    T.useRef(!1);
    const N = T.useCallback(() => {
      O(!0);
    }, []), U = T.useCallback(() => {
      O(!1);
    }, []), j = T.useMemo(() => ({
      adornedStart: C,
      setAdornedStart: k,
      color: a,
      disabled: c,
      error: u,
      filled: A,
      focused: $,
      fullWidth: p,
      hiddenLabel: m,
      size: b,
      onBlur: () => {
        I(!1);
      },
      onFocus: () => {
        I(!0);
      },
      onEmpty: U,
      onFilled: N,
      registerEffect: L,
      required: y,
      variant: v
    }), [C, a, c, u, A, $, p, m, L, U, N, y, b, v]);
    return /* @__PURE__ */ S.jsx(jA.Provider, {
      value: j,
      children: /* @__PURE__ */ S.jsx(XOe, {
        as: s,
        ownerState: E,
        className: $e(_.root, i),
        ref: n,
        ...x,
        children: o
      })
    });
  });
  function ZOe(e) {
    return ot("MuiFormHelperText", e);
  }
  const C3 = nt("MuiFormHelperText", ["root", "error", "disabled", "sizeSmall", "sizeMedium", "contained", "focused", "filled", "required"]);
  var k3;
  const QOe = (e) => {
    const {
      classes: t,
      contained: n,
      size: r,
      disabled: o,
      error: i,
      filled: a,
      focused: s,
      required: c
    } = e, u = {
      root: ["root", o && "disabled", i && "error", r && `size${Ie(r)}`, n && "contained", s && "focused", a && "filled", c && "required"]
    };
    return rt(u, ZOe, t);
  }, JOe = Re("p", {
    name: "MuiFormHelperText",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.size && t[`size${Ie(n.size)}`], n.contained && t.contained, n.filled && t.filled];
    }
  })(st(({
    theme: e
  }) => ({
    color: (e.vars || e).palette.text.secondary,
    ...e.typography.caption,
    textAlign: "left",
    marginTop: 3,
    marginRight: 0,
    marginBottom: 0,
    marginLeft: 0,
    [`&.${C3.disabled}`]: {
      color: (e.vars || e).palette.text.disabled
    },
    [`&.${C3.error}`]: {
      color: (e.vars || e).palette.error.main
    },
    variants: [{
      props: {
        size: "small"
      },
      style: {
        marginTop: 4
      }
    }, {
      props: ({
        ownerState: t
      }) => t.contained,
      style: {
        marginLeft: 14,
        marginRight: 14
      }
    }]
  }))), UA = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiFormHelperText"
    }), {
      children: o,
      className: i,
      component: a = "p",
      disabled: s,
      error: c,
      filled: u,
      focused: d,
      margin: p,
      required: m,
      variant: g,
      ...y
    } = r, b = ra(), v = yl({
      props: r,
      muiFormControl: b,
      states: ["variant", "size", "disabled", "error", "filled", "focused", "required"]
    }), x = {
      ...r,
      component: a,
      contained: v.variant === "filled" || v.variant === "outlined",
      variant: v.variant,
      size: v.size,
      disabled: v.disabled,
      error: v.error,
      filled: v.filled,
      focused: v.focused,
      required: v.required
    };
    delete x.ownerState;
    const E = QOe(x);
    return /* @__PURE__ */ S.jsx(JOe, {
      as: a,
      className: $e(E.root, i),
      ref: n,
      ...y,
      ownerState: x,
      children: o === " " ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        k3 || (k3 = /* @__PURE__ */ S.jsx("span", {
          className: "notranslate",
          "aria-hidden": !0,
          children: ""
        }))
      ) : o
    });
  });
  function mm(e) {
    return parseInt(T.version, 10) >= 19 ? e?.props?.ref || null : e?.ref || null;
  }
  function Ia(e) {
    const {
      elementType: t,
      externalSlotProps: n,
      ownerState: r,
      skipResolvingSlotProps: o = !1,
      ...i
    } = e, a = o ? {} : jF(n, r), {
      props: s,
      internalRef: c
    } = DF({
      ...i,
      externalSlotProps: a
    }), u = er(c, a?.ref, e.additionalProps?.ref);
    return $F(t, {
      ...s,
      ref: u
    }, r);
  }
  const Ua = /* @__PURE__ */ T.createContext({});
  function eMe(e) {
    return ot("MuiList", e);
  }
  nt("MuiList", ["root", "padding", "dense", "subheader"]);
  const tMe = (e) => {
    const {
      classes: t,
      disablePadding: n,
      dense: r,
      subheader: o
    } = e;
    return rt({
      root: ["root", !n && "padding", r && "dense", o && "subheader"]
    }, eMe, t);
  }, nMe = Re("ul", {
    name: "MuiList",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, !n.disablePadding && t.padding, n.dense && t.dense, n.subheader && t.subheader];
    }
  })({
    listStyle: "none",
    margin: 0,
    padding: 0,
    position: "relative",
    variants: [{
      props: ({
        ownerState: e
      }) => !e.disablePadding,
      style: {
        paddingTop: 8,
        paddingBottom: 8
      }
    }, {
      props: ({
        ownerState: e
      }) => e.subheader,
      style: {
        paddingTop: 0
      }
    }]
  }), VA = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiList"
    }), {
      children: o,
      className: i,
      component: a = "ul",
      dense: s = !1,
      disablePadding: c = !1,
      subheader: u,
      ...d
    } = r, p = T.useMemo(() => ({
      dense: s
    }), [s]), m = {
      ...r,
      component: a,
      dense: s,
      disablePadding: c
    }, g = tMe(m);
    return /* @__PURE__ */ S.jsx(Ua.Provider, {
      value: p,
      children: /* @__PURE__ */ S.jsxs(nMe, {
        as: a,
        className: $e(g.root, i),
        ref: n,
        ownerState: m,
        ...d,
        children: [u, o]
      })
    });
  });
  function _p(e) {
    let t = e.activeElement;
    for (; t?.shadowRoot?.activeElement != null; )
      t = t.shadowRoot.activeElement;
    return t;
  }
  function QV(e = window) {
    const t = e.document.documentElement.clientWidth;
    return e.innerWidth - t;
  }
  function G_(e, t, n) {
    return e === t ? e.firstChild : t && t.nextElementSibling ? t.nextElementSibling : n ? null : e.firstChild;
  }
  function T3(e, t, n) {
    return e === t ? n ? e.firstChild : e.lastChild : t && t.previousElementSibling ? t.previousElementSibling : n ? null : e.lastChild;
  }
  function JV(e, t) {
    if (t === void 0)
      return !0;
    let n = e.innerText;
    return n === void 0 && (n = e.textContent), n = n.trim().toLowerCase(), n.length === 0 ? !1 : t.repeating ? n[0] === t.keys[0] : n.startsWith(t.keys.join(""));
  }
  function ip(e, t, n, r, o, i) {
    let a = !1, s = o(e, t, t ? n : !1);
    for (; s; ) {
      if (s === e.firstChild) {
        if (a)
          return !1;
        a = !0;
      }
      const c = r ? !1 : s.disabled || s.getAttribute("aria-disabled") === "true";
      if (!s.hasAttribute("tabindex") || !JV(s, i) || c)
        s = o(e, s, n);
      else
        return s.focus(), !0;
    }
    return !1;
  }
  const rMe = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const {
      // private
      // eslint-disable-next-line react/prop-types
      actions: r,
      autoFocus: o = !1,
      autoFocusItem: i = !1,
      children: a,
      className: s,
      disabledItemsFocusable: c = !1,
      disableListWrap: u = !1,
      onKeyDown: d,
      variant: p = "selectedMenu",
      ...m
    } = t, g = T.useRef(null), y = T.useRef({
      keys: [],
      repeating: !0,
      previousKeyMatched: !0,
      lastTime: null
    });
    ei(() => {
      o && g.current.focus();
    }, [o]), T.useImperativeHandle(r, () => ({
      adjustStyleForScrollbar: (_, {
        direction: C
      }) => {
        const k = !g.current.style.width;
        if (_.clientHeight < g.current.clientHeight && k) {
          const A = `${QV(Qa(_))}px`;
          g.current.style[C === "rtl" ? "paddingLeft" : "paddingRight"] = A, g.current.style.width = `calc(100% + ${A})`;
        }
        return g.current;
      }
    }), []);
    const b = (_) => {
      const C = g.current, k = _.key;
      if (_.ctrlKey || _.metaKey || _.altKey) {
        d && d(_);
        return;
      }
      const O = _p(Ar(C));
      if (k === "ArrowDown")
        _.preventDefault(), ip(C, O, u, c, G_);
      else if (k === "ArrowUp")
        _.preventDefault(), ip(C, O, u, c, T3);
      else if (k === "Home")
        _.preventDefault(), ip(C, null, u, c, G_);
      else if (k === "End")
        _.preventDefault(), ip(C, null, u, c, T3);
      else if (k.length === 1) {
        const P = y.current, I = k.toLowerCase(), $ = performance.now();
        P.keys.length > 0 && ($ - P.lastTime > 500 ? (P.keys = [], P.repeating = !0, P.previousKeyMatched = !0) : P.repeating && I !== P.keys[0] && (P.repeating = !1)), P.lastTime = $, P.keys.push(I);
        const L = O && !P.repeating && JV(O, P);
        P.previousKeyMatched && (L || ip(C, O, !1, c, G_, P)) ? _.preventDefault() : P.previousKeyMatched = !1;
      }
      d && d(_);
    }, v = er(g, n);
    let x = -1;
    T.Children.forEach(a, (_, C) => {
      if (!/* @__PURE__ */ T.isValidElement(_)) {
        x === C && (x += 1, x >= a.length && (x = -1));
        return;
      }
      _.props.disabled || (p === "selectedMenu" && _.props.selected || x === -1) && (x = C), x === C && (_.props.disabled || _.props.muiSkipListHighlight || _.type.muiSkipListHighlight) && (x += 1, x >= a.length && (x = -1));
    });
    const E = T.Children.map(a, (_, C) => {
      if (C === x) {
        const k = {};
        return i && (k.autoFocus = !0), _.props.tabIndex === void 0 && p === "selectedMenu" && (k.tabIndex = 0), /* @__PURE__ */ T.cloneElement(_, k);
      }
      return _;
    });
    return /* @__PURE__ */ S.jsx(VA, {
      role: "menu",
      ref: v,
      className: s,
      onKeyDown: b,
      tabIndex: o ? 0 : -1,
      ...m,
      children: E
    });
  }), eH = (e) => e.scrollTop;
  function V0(e, t) {
    const {
      timeout: n,
      easing: r,
      style: o = {}
    } = e;
    return {
      duration: o.transitionDuration ?? (typeof n == "number" ? n : n[t.mode] || 0),
      easing: o.transitionTimingFunction ?? (typeof r == "object" ? r[t.mode] : r),
      delay: o.transitionDelay
    };
  }
  function zC(e) {
    return `scale(${e}, ${e ** 2})`;
  }
  const oMe = {
    entering: {
      opacity: 1,
      transform: zC(1)
    },
    entered: {
      opacity: 1,
      transform: "none"
    }
  }, K_ = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent), BC = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const {
      addEndListener: r,
      appear: o = !0,
      children: i,
      easing: a,
      in: s,
      onEnter: c,
      onEntered: u,
      onEntering: d,
      onExit: p,
      onExited: m,
      onExiting: g,
      style: y,
      timeout: b = "auto",
      // eslint-disable-next-line react/prop-types
      TransitionComponent: v = Zi,
      ...x
    } = t, E = IF(), _ = T.useRef(), C = gb(), k = T.useRef(null), A = er(k, mm(i), n), O = (V) => (F) => {
      if (V) {
        const K = k.current;
        F === void 0 ? V(K) : V(K, F);
      }
    }, P = O(d), I = O((V, F) => {
      eH(V);
      const {
        duration: K,
        delay: W,
        easing: Y
      } = V0({
        style: y,
        timeout: b,
        easing: a
      }, {
        mode: "enter"
      });
      let B;
      b === "auto" ? (B = C.transitions.getAutoHeightDuration(V.clientHeight), _.current = B) : B = K, V.style.transition = [C.transitions.create("opacity", {
        duration: B,
        delay: W
      }), C.transitions.create("transform", {
        duration: K_ ? B : B * 0.666,
        delay: W,
        easing: Y
      })].join(","), c && c(V, F);
    }), $ = O(u), L = O(g), N = O((V) => {
      const {
        duration: F,
        delay: K,
        easing: W
      } = V0({
        style: y,
        timeout: b,
        easing: a
      }, {
        mode: "exit"
      });
      let Y;
      b === "auto" ? (Y = C.transitions.getAutoHeightDuration(V.clientHeight), _.current = Y) : Y = F, V.style.transition = [C.transitions.create("opacity", {
        duration: Y,
        delay: K
      }), C.transitions.create("transform", {
        duration: K_ ? Y : Y * 0.666,
        delay: K_ ? K : K || Y * 0.333,
        easing: W
      })].join(","), V.style.opacity = 0, V.style.transform = zC(0.75), p && p(V);
    }), U = O(m), j = (V) => {
      b === "auto" && E.start(_.current || 0, V), r && r(k.current, V);
    };
    return /* @__PURE__ */ S.jsx(v, {
      appear: o,
      in: s,
      nodeRef: k,
      onEnter: I,
      onEntered: $,
      onEntering: P,
      onExit: N,
      onExited: U,
      onExiting: L,
      addEndListener: j,
      timeout: b === "auto" ? null : b,
      ...x,
      children: (V, {
        ownerState: F,
        ...K
      }) => /* @__PURE__ */ T.cloneElement(i, {
        style: {
          opacity: 0,
          transform: zC(0.75),
          visibility: V === "exited" && !s ? "hidden" : void 0,
          ...oMe[V],
          ...y,
          ...i.props.style
        },
        ref: A,
        ...K
      })
    });
  });
  BC && (BC.muiSupportAuto = !0);
  function iMe(e) {
    const t = Ar(e);
    return t.body === e ? Qa(e).innerWidth > t.documentElement.clientWidth : e.scrollHeight > e.clientHeight;
  }
  function zp(e, t) {
    t ? e.setAttribute("aria-hidden", "true") : e.removeAttribute("aria-hidden");
  }
  function A3(e) {
    return parseInt(Qa(e).getComputedStyle(e).paddingRight, 10) || 0;
  }
  function aMe(e) {
    const n = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].includes(e.tagName), r = e.tagName === "INPUT" && e.getAttribute("type") === "hidden";
    return n || r;
  }
  function R3(e, t, n, r, o) {
    const i = [t, n, ...r];
    [].forEach.call(e.children, (a) => {
      const s = !i.includes(a), c = !aMe(a);
      s && c && zp(a, o);
    });
  }
  function Y_(e, t) {
    let n = -1;
    return e.some((r, o) => t(r) ? (n = o, !0) : !1), n;
  }
  function sMe(e, t) {
    const n = [], r = e.container;
    if (!t.disableScrollLock) {
      if (iMe(r)) {
        const a = QV(Qa(r));
        n.push({
          value: r.style.paddingRight,
          property: "padding-right",
          el: r
        }), r.style.paddingRight = `${A3(r) + a}px`;
        const s = Ar(r).querySelectorAll(".mui-fixed");
        [].forEach.call(s, (c) => {
          n.push({
            value: c.style.paddingRight,
            property: "padding-right",
            el: c
          }), c.style.paddingRight = `${A3(c) + a}px`;
        });
      }
      let i;
      if (r.parentNode instanceof DocumentFragment)
        i = Ar(r).body;
      else {
        const a = r.parentElement, s = Qa(r);
        i = a?.nodeName === "HTML" && s.getComputedStyle(a).overflowY === "scroll" ? a : r;
      }
      n.push({
        value: i.style.overflow,
        property: "overflow",
        el: i
      }, {
        value: i.style.overflowX,
        property: "overflow-x",
        el: i
      }, {
        value: i.style.overflowY,
        property: "overflow-y",
        el: i
      }), i.style.overflow = "hidden";
    }
    return () => {
      n.forEach(({
        value: i,
        el: a,
        property: s
      }) => {
        i ? a.style.setProperty(s, i) : a.style.removeProperty(s);
      });
    };
  }
  function lMe(e) {
    const t = [];
    return [].forEach.call(e.children, (n) => {
      n.getAttribute("aria-hidden") === "true" && t.push(n);
    }), t;
  }
  class cMe {
    constructor() {
      this.modals = [], this.containers = [];
    }
    add(t, n) {
      let r = this.modals.indexOf(t);
      if (r !== -1)
        return r;
      r = this.modals.length, this.modals.push(t), t.modalRef && zp(t.modalRef, !1);
      const o = lMe(n);
      R3(n, t.mount, t.modalRef, o, !0);
      const i = Y_(this.containers, (a) => a.container === n);
      return i !== -1 ? (this.containers[i].modals.push(t), r) : (this.containers.push({
        modals: [t],
        container: n,
        restore: null,
        hiddenSiblings: o
      }), r);
    }
    mount(t, n) {
      const r = Y_(this.containers, (i) => i.modals.includes(t)), o = this.containers[r];
      o.restore || (o.restore = sMe(o, n));
    }
    remove(t, n = !0) {
      const r = this.modals.indexOf(t);
      if (r === -1)
        return r;
      const o = Y_(this.containers, (a) => a.modals.includes(t)), i = this.containers[o];
      if (i.modals.splice(i.modals.indexOf(t), 1), this.modals.splice(r, 1), i.modals.length === 0)
        i.restore && i.restore(), t.modalRef && zp(t.modalRef, n), R3(i.container, t.mount, t.modalRef, i.hiddenSiblings, !1), this.containers.splice(o, 1);
      else {
        const a = i.modals[i.modals.length - 1];
        a.modalRef && zp(a.modalRef, !1);
      }
      return r;
    }
    isTopModal(t) {
      return this.modals.length > 0 && this.modals[this.modals.length - 1] === t;
    }
  }
  const uMe = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
  function fMe(e) {
    const t = parseInt(e.getAttribute("tabindex") || "", 10);
    return Number.isNaN(t) ? e.contentEditable === "true" || (e.nodeName === "AUDIO" || e.nodeName === "VIDEO" || e.nodeName === "DETAILS") && e.getAttribute("tabindex") === null ? 0 : e.tabIndex : t;
  }
  function dMe(e) {
    if (e.tagName !== "INPUT" || e.type !== "radio" || !e.name)
      return !1;
    const t = (r) => e.ownerDocument.querySelector(`input[type="radio"]${r}`);
    let n = t(`[name="${e.name}"]:checked`);
    return n || (n = t(`[name="${e.name}"]`)), n !== e;
  }
  function pMe(e) {
    return !(e.disabled || e.tagName === "INPUT" && e.type === "hidden" || dMe(e));
  }
  function hMe(e) {
    const t = [], n = [];
    return Array.from(e.querySelectorAll(uMe)).forEach((r, o) => {
      const i = fMe(r);
      i === -1 || !pMe(r) || (i === 0 ? t.push(r) : n.push({
        documentOrder: o,
        tabIndex: i,
        node: r
      }));
    }), n.sort((r, o) => r.tabIndex === o.tabIndex ? r.documentOrder - o.documentOrder : r.tabIndex - o.tabIndex).map((r) => r.node).concat(t);
  }
  function mMe() {
    return !0;
  }
  function gMe(e) {
    const {
      children: t,
      disableAutoFocus: n = !1,
      disableEnforceFocus: r = !1,
      disableRestoreFocus: o = !1,
      getTabbable: i = hMe,
      isEnabled: a = mMe,
      open: s
    } = e, c = T.useRef(!1), u = T.useRef(null), d = T.useRef(null), p = T.useRef(null), m = T.useRef(null), g = T.useRef(!1), y = T.useRef(null), b = er(mm(t), y), v = T.useRef(null);
    T.useEffect(() => {
      !s || !y.current || (g.current = !n);
    }, [n, s]), T.useEffect(() => {
      if (!s || !y.current)
        return;
      const _ = Ar(y.current), C = _p(_);
      return y.current.contains(C) || (y.current.hasAttribute("tabIndex") || y.current.setAttribute("tabIndex", "-1"), g.current && y.current.focus()), () => {
        o || (p.current && p.current.focus && (c.current = !0, p.current.focus()), p.current = null);
      };
    }, [s]), T.useEffect(() => {
      if (!s || !y.current)
        return;
      const _ = Ar(y.current), C = _p(_), k = (P) => {
        v.current = P, !(r || !a() || P.key !== "Tab") && C === y.current && P.shiftKey && (c.current = !0, d.current && d.current.focus());
      }, A = () => {
        const P = y.current;
        if (P === null)
          return;
        const I = _p(_);
        if (!_.hasFocus() || !a() || c.current) {
          c.current = !1;
          return;
        }
        if (P.contains(I) || r && I !== u.current && I !== d.current)
          return;
        if (I !== m.current)
          m.current = null;
        else if (m.current !== null)
          return;
        if (!g.current)
          return;
        let $ = [];
        if ((I === u.current || I === d.current) && ($ = i(y.current)), $.length > 0) {
          const L = !!(v.current?.shiftKey && v.current?.key === "Tab"), N = $[0], U = $[$.length - 1];
          typeof N != "string" && typeof U != "string" && (L ? U.focus() : N.focus());
        } else
          P.focus();
      };
      _.addEventListener("focusin", A), _.addEventListener("keydown", k, !0);
      const O = setInterval(() => {
        const P = _p(_);
        P && P.tagName === "BODY" && A();
      }, 50);
      return () => {
        clearInterval(O), _.removeEventListener("focusin", A), _.removeEventListener("keydown", k, !0);
      };
    }, [n, r, o, a, s, i]);
    const x = (_) => {
      p.current === null && (p.current = _.relatedTarget), g.current = !0, m.current = _.target;
      const C = t.props.onFocus;
      C && C(_);
    }, E = (_) => {
      p.current === null && (p.current = _.relatedTarget), g.current = !0;
    };
    return /* @__PURE__ */ S.jsxs(T.Fragment, {
      children: [/* @__PURE__ */ S.jsx("div", {
        tabIndex: s ? 0 : -1,
        onFocus: E,
        ref: u,
        "data-testid": "sentinelStart"
      }), /* @__PURE__ */ T.cloneElement(t, {
        ref: b,
        onFocus: x
      }), /* @__PURE__ */ S.jsx("div", {
        tabIndex: s ? 0 : -1,
        onFocus: E,
        ref: d,
        "data-testid": "sentinelEnd"
      })]
    });
  }
  function yMe(e) {
    return typeof e == "function" ? e() : e;
  }
  const vMe = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const {
      children: r,
      container: o,
      disablePortal: i = !1
    } = t, [a, s] = T.useState(null), c = er(/* @__PURE__ */ T.isValidElement(r) ? mm(r) : null, n);
    if (ei(() => {
      i || s(yMe(o) || document.body);
    }, [o, i]), ei(() => {
      if (a && !i)
        return v3(n, a), () => {
          v3(n, null);
        };
    }, [n, a, i]), i) {
      if (/* @__PURE__ */ T.isValidElement(r)) {
        const u = {
          ref: c
        };
        return /* @__PURE__ */ T.cloneElement(r, u);
      }
      return r;
    }
    return a && /* @__PURE__ */ _c.createPortal(r, a);
  }), bMe = {
    entering: {
      opacity: 1
    },
    entered: {
      opacity: 1
    }
  }, xMe = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = gb(), o = {
      enter: r.transitions.duration.enteringScreen,
      exit: r.transitions.duration.leavingScreen
    }, {
      addEndListener: i,
      appear: a = !0,
      children: s,
      easing: c,
      in: u,
      onEnter: d,
      onEntered: p,
      onEntering: m,
      onExit: g,
      onExited: y,
      onExiting: b,
      style: v,
      timeout: x = o,
      // eslint-disable-next-line react/prop-types
      TransitionComponent: E = Zi,
      ..._
    } = t, C = T.useRef(null), k = er(C, mm(s), n), A = (j) => (V) => {
      if (j) {
        const F = C.current;
        V === void 0 ? j(F) : j(F, V);
      }
    }, O = A(m), P = A((j, V) => {
      eH(j);
      const F = V0({
        style: v,
        timeout: x,
        easing: c
      }, {
        mode: "enter"
      });
      j.style.webkitTransition = r.transitions.create("opacity", F), j.style.transition = r.transitions.create("opacity", F), d && d(j, V);
    }), I = A(p), $ = A(b), L = A((j) => {
      const V = V0({
        style: v,
        timeout: x,
        easing: c
      }, {
        mode: "exit"
      });
      j.style.webkitTransition = r.transitions.create("opacity", V), j.style.transition = r.transitions.create("opacity", V), g && g(j);
    }), N = A(y), U = (j) => {
      i && i(C.current, j);
    };
    return /* @__PURE__ */ S.jsx(E, {
      appear: a,
      in: u,
      nodeRef: C,
      onEnter: P,
      onEntered: I,
      onEntering: O,
      onExit: L,
      onExited: N,
      onExiting: $,
      addEndListener: U,
      timeout: x,
      ..._,
      children: (j, {
        ownerState: V,
        ...F
      }) => /* @__PURE__ */ T.cloneElement(s, {
        style: {
          opacity: 0,
          visibility: j === "exited" && !u ? "hidden" : void 0,
          ...bMe[j],
          ...v,
          ...s.props.style
        },
        ref: k,
        ...F
      })
    });
  });
  function wMe(e) {
    return ot("MuiBackdrop", e);
  }
  nt("MuiBackdrop", ["root", "invisible"]);
  const SMe = (e) => {
    const {
      classes: t,
      invisible: n
    } = e;
    return rt({
      root: ["root", n && "invisible"]
    }, wMe, t);
  }, _Me = Re("div", {
    name: "MuiBackdrop",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.invisible && t.invisible];
    }
  })({
    position: "fixed",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    WebkitTapHighlightColor: "transparent",
    variants: [{
      props: {
        invisible: !0
      },
      style: {
        backgroundColor: "transparent"
      }
    }]
  }), EMe = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiBackdrop"
    }), {
      children: o,
      className: i,
      component: a = "div",
      invisible: s = !1,
      open: c,
      components: u = {},
      componentsProps: d = {},
      slotProps: p = {},
      slots: m = {},
      TransitionComponent: g,
      transitionDuration: y,
      ...b
    } = r, v = {
      ...r,
      component: a,
      invisible: s
    }, x = SMe(v), E = {
      transition: g,
      root: u.Root,
      ...m
    }, _ = {
      ...d,
      ...p
    }, C = {
      component: a,
      slots: E,
      slotProps: _
    }, [k, A] = ln("root", {
      elementType: _Me,
      externalForwardedProps: C,
      className: $e(x.root, i),
      ownerState: v
    }), [O, P] = ln("transition", {
      elementType: xMe,
      externalForwardedProps: C,
      ownerState: v
    });
    return /* @__PURE__ */ S.jsx(O, {
      in: c,
      timeout: y,
      ...b,
      ...P,
      children: /* @__PURE__ */ S.jsx(k, {
        "aria-hidden": !0,
        ...A,
        classes: x,
        ref: n,
        children: o
      })
    });
  });
  function CMe(e) {
    return typeof e == "function" ? e() : e;
  }
  function kMe(e) {
    return e ? e.props.hasOwnProperty("in") : !1;
  }
  const O3 = () => {
  }, pv = new cMe();
  function TMe(e) {
    const {
      container: t,
      disableEscapeKeyDown: n = !1,
      disableScrollLock: r = !1,
      closeAfterTransition: o = !1,
      onTransitionEnter: i,
      onTransitionExited: a,
      children: s,
      onClose: c,
      open: u,
      rootRef: d
    } = e, p = T.useRef({}), m = T.useRef(null), g = T.useRef(null), y = er(g, d), [b, v] = T.useState(!u), x = kMe(s);
    let E = !0;
    (e["aria-hidden"] === "false" || e["aria-hidden"] === !1) && (E = !1);
    const _ = () => Ar(m.current), C = () => (p.current.modalRef = g.current, p.current.mount = m.current, p.current), k = () => {
      pv.mount(C(), {
        disableScrollLock: r
      }), g.current && (g.current.scrollTop = 0);
    }, A = Bi(() => {
      const V = CMe(t) || _().body;
      pv.add(C(), V), g.current && k();
    }), O = () => pv.isTopModal(C()), P = Bi((V) => {
      m.current = V, V && (u && O() ? k() : g.current && zp(g.current, E));
    }), I = T.useCallback(() => {
      pv.remove(C(), E);
    }, [E]);
    T.useEffect(() => () => {
      I();
    }, [I]), T.useEffect(() => {
      u ? A() : (!x || !o) && I();
    }, [u, I, x, o, A]);
    const $ = (V) => (F) => {
      V.onKeyDown?.(F), !(F.key !== "Escape" || F.which === 229 || // Wait until IME is settled.
      !O()) && (n || (F.stopPropagation(), c && c(F, "escapeKeyDown")));
    }, L = (V) => (F) => {
      V.onClick?.(F), F.target === F.currentTarget && c && c(F, "backdropClick");
    };
    return {
      getRootProps: (V = {}) => {
        const F = Ap(e);
        delete F.onTransitionEnter, delete F.onTransitionExited;
        const K = {
          ...F,
          ...V
        };
        return {
          /*
           * Marking an element with the role presentation indicates to assistive technology
           * that this element should be ignored; it exists to support the web application and
           * is not meant for humans to interact with directly.
           * https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-static-element-interactions.md
           */
          role: "presentation",
          ...K,
          onKeyDown: $(K),
          ref: y
        };
      },
      getBackdropProps: (V = {}) => {
        const F = V;
        return {
          "aria-hidden": !0,
          ...F,
          onClick: L(F),
          open: u
        };
      },
      getTransitionProps: () => {
        const V = () => {
          v(!1), i && i();
        }, F = () => {
          v(!0), a && a(), o && I();
        };
        return {
          onEnter: DC(V, s?.props.onEnter ?? O3),
          onExited: DC(F, s?.props.onExited ?? O3)
        };
      },
      rootRef: y,
      portalRef: P,
      isTopModal: O,
      exited: b,
      hasTransition: x
    };
  }
  function AMe(e) {
    return ot("MuiModal", e);
  }
  nt("MuiModal", ["root", "hidden", "backdrop"]);
  const RMe = (e) => {
    const {
      open: t,
      exited: n,
      classes: r
    } = e;
    return rt({
      root: ["root", !t && n && "hidden"],
      backdrop: ["backdrop"]
    }, AMe, r);
  }, OMe = Re("div", {
    name: "MuiModal",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, !n.open && n.exited && t.hidden];
    }
  })(st(({
    theme: e
  }) => ({
    position: "fixed",
    zIndex: (e.vars || e).zIndex.modal,
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    variants: [{
      props: ({
        ownerState: t
      }) => !t.open && t.exited,
      style: {
        visibility: "hidden"
      }
    }]
  }))), MMe = Re(EMe, {
    name: "MuiModal",
    slot: "Backdrop"
  })({
    zIndex: -1
  }), NMe = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      name: "MuiModal",
      props: t
    }), {
      BackdropComponent: o = MMe,
      BackdropProps: i,
      classes: a,
      className: s,
      closeAfterTransition: c = !1,
      children: u,
      container: d,
      component: p,
      components: m = {},
      componentsProps: g = {},
      disableAutoFocus: y = !1,
      disableEnforceFocus: b = !1,
      disableEscapeKeyDown: v = !1,
      disablePortal: x = !1,
      disableRestoreFocus: E = !1,
      disableScrollLock: _ = !1,
      hideBackdrop: C = !1,
      keepMounted: k = !1,
      onClose: A,
      onTransitionEnter: O,
      onTransitionExited: P,
      open: I,
      slotProps: $ = {},
      slots: L = {},
      // eslint-disable-next-line react/prop-types
      theme: N,
      ...U
    } = r, j = {
      ...r,
      closeAfterTransition: c,
      disableAutoFocus: y,
      disableEnforceFocus: b,
      disableEscapeKeyDown: v,
      disablePortal: x,
      disableRestoreFocus: E,
      disableScrollLock: _,
      hideBackdrop: C,
      keepMounted: k
    }, {
      getRootProps: V,
      getBackdropProps: F,
      getTransitionProps: K,
      portalRef: W,
      isTopModal: Y,
      exited: B,
      hasTransition: D
    } = TMe({
      ...j,
      rootRef: n
    }), G = {
      ...j,
      exited: B
    }, z = RMe(G), H = {};
    if (u.props.tabIndex === void 0 && (H.tabIndex = "-1"), D) {
      const {
        onEnter: ue,
        onExited: J
      } = K();
      H.onEnter = ue, H.onExited = J;
    }
    const X = {
      slots: {
        root: m.Root,
        backdrop: m.Backdrop,
        ...L
      },
      slotProps: {
        ...g,
        ...$
      }
    }, [Q, ne] = ln("root", {
      ref: n,
      elementType: OMe,
      externalForwardedProps: {
        ...X,
        ...U,
        component: p
      },
      getSlotProps: V,
      ownerState: G,
      className: $e(s, z?.root, !G.open && G.exited && z?.hidden)
    }), [te, se] = ln("backdrop", {
      ref: i?.ref,
      elementType: o,
      externalForwardedProps: X,
      shouldForwardComponentProp: !0,
      additionalProps: i,
      getSlotProps: (ue) => F({
        ...ue,
        onClick: (J) => {
          ue?.onClick && ue.onClick(J);
        }
      }),
      className: $e(i?.className, z?.backdrop),
      ownerState: G
    });
    return !k && !I && (!D || B) ? null : /* @__PURE__ */ S.jsx(vMe, {
      ref: W,
      container: d,
      disablePortal: x,
      children: /* @__PURE__ */ S.jsxs(Q, {
        ...ne,
        children: [!C && o ? /* @__PURE__ */ S.jsx(te, {
          ...se
        }) : null, /* @__PURE__ */ S.jsx(gMe, {
          disableEnforceFocus: b,
          disableAutoFocus: y,
          disableRestoreFocus: E,
          isEnabled: Y,
          open: I,
          children: /* @__PURE__ */ T.cloneElement(u, H)
        })]
      })
    });
  });
  function PMe(e) {
    return ot("MuiPopover", e);
  }
  nt("MuiPopover", ["root", "paper"]);
  function M3(e, t) {
    let n = 0;
    return typeof t == "number" ? n = t : t === "center" ? n = e.height / 2 : t === "bottom" && (n = e.height), n;
  }
  function N3(e, t) {
    let n = 0;
    return typeof t == "number" ? n = t : t === "center" ? n = e.width / 2 : t === "right" && (n = e.width), n;
  }
  function P3(e) {
    return [e.horizontal, e.vertical].map((t) => typeof t == "number" ? `${t}px` : t).join(" ");
  }
  function hv(e) {
    return typeof e == "function" ? e() : e;
  }
  const IMe = (e) => {
    const {
      classes: t
    } = e;
    return rt({
      root: ["root"],
      paper: ["paper"]
    }, PMe, t);
  }, $Me = Re(NMe, {
    name: "MuiPopover",
    slot: "Root"
  })({}), tH = Re(A1, {
    name: "MuiPopover",
    slot: "Paper"
  })({
    position: "absolute",
    overflowY: "auto",
    overflowX: "hidden",
    // So we see the popover when it's empty.
    // It's most likely on issue on userland.
    minWidth: 16,
    minHeight: 16,
    maxWidth: "calc(100% - 32px)",
    maxHeight: "calc(100% - 32px)",
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0
  }), jMe = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiPopover"
    }), {
      action: o,
      anchorEl: i,
      anchorOrigin: a = {
        vertical: "top",
        horizontal: "left"
      },
      anchorPosition: s,
      anchorReference: c = "anchorEl",
      children: u,
      className: d,
      container: p,
      elevation: m = 8,
      marginThreshold: g = 16,
      open: y,
      PaperProps: b = {},
      // TODO: remove in v7
      slots: v = {},
      slotProps: x = {},
      transformOrigin: E = {
        vertical: "top",
        horizontal: "left"
      },
      TransitionComponent: _,
      // TODO: remove in v7
      transitionDuration: C = "auto",
      TransitionProps: k = {},
      // TODO: remove in v7
      disableScrollLock: A = !1,
      ...O
    } = r, P = T.useRef(), I = {
      ...r,
      anchorOrigin: a,
      anchorReference: c,
      elevation: m,
      marginThreshold: g,
      transformOrigin: E,
      TransitionComponent: _,
      transitionDuration: C,
      TransitionProps: k
    }, $ = IMe(I), L = T.useCallback(() => {
      if (c === "anchorPosition")
        return s;
      const ue = hv(i), ee = (ue && ue.nodeType === 1 ? ue : Ar(P.current).body).getBoundingClientRect();
      return {
        top: ee.top + M3(ee, a.vertical),
        left: ee.left + N3(ee, a.horizontal)
      };
    }, [i, a.horizontal, a.vertical, s, c]), N = T.useCallback((ue) => ({
      vertical: M3(ue, E.vertical),
      horizontal: N3(ue, E.horizontal)
    }), [E.horizontal, E.vertical]), U = T.useCallback((ue) => {
      const J = {
        width: ue.offsetWidth,
        height: ue.offsetHeight
      }, ee = N(J);
      if (c === "none")
        return {
          top: null,
          left: null,
          transformOrigin: P3(ee)
        };
      const ie = L();
      let le = ie.top - ee.vertical, ge = ie.left - ee.horizontal;
      const Se = le + J.height, Me = ge + J.width, je = Qa(hv(i)), ze = je.innerHeight - g, Ye = je.innerWidth - g;
      if (g !== null && le < g) {
        const Ue = le - g;
        le -= Ue, ee.vertical += Ue;
      } else if (g !== null && Se > ze) {
        const Ue = Se - ze;
        le -= Ue, ee.vertical += Ue;
      }
      if (g !== null && ge < g) {
        const Ue = ge - g;
        ge -= Ue, ee.horizontal += Ue;
      } else if (Me > Ye) {
        const Ue = Me - Ye;
        ge -= Ue, ee.horizontal += Ue;
      }
      return {
        top: `${Math.round(le)}px`,
        left: `${Math.round(ge)}px`,
        transformOrigin: P3(ee)
      };
    }, [i, c, L, N, g]), [j, V] = T.useState(y), F = T.useCallback(() => {
      const ue = P.current;
      if (!ue)
        return;
      const J = U(ue);
      J.top !== null && ue.style.setProperty("top", J.top), J.left !== null && (ue.style.left = J.left), ue.style.transformOrigin = J.transformOrigin, V(!0);
    }, [U]);
    T.useEffect(() => (A && window.addEventListener("scroll", F), () => window.removeEventListener("scroll", F)), [i, A, F]);
    const K = () => {
      F();
    }, W = () => {
      V(!1);
    };
    T.useEffect(() => {
      y && F();
    }), T.useImperativeHandle(o, () => y ? {
      updatePosition: () => {
        F();
      }
    } : null, [y, F]), T.useEffect(() => {
      if (!y)
        return;
      const ue = GV(() => {
        F();
      }), J = Qa(hv(i));
      return J.addEventListener("resize", ue), () => {
        ue.clear(), J.removeEventListener("resize", ue);
      };
    }, [i, y, F]);
    let Y = C;
    const B = {
      slots: {
        transition: _,
        ...v
      },
      slotProps: {
        transition: k,
        paper: b,
        ...x
      }
    }, [D, G] = ln("transition", {
      elementType: BC,
      externalForwardedProps: B,
      ownerState: I,
      getSlotProps: (ue) => ({
        ...ue,
        onEntering: (J, ee) => {
          ue.onEntering?.(J, ee), K();
        },
        onExited: (J) => {
          ue.onExited?.(J), W();
        }
      }),
      additionalProps: {
        appear: !0,
        in: y
      }
    });
    C === "auto" && !D.muiSupportAuto && (Y = void 0);
    const z = p || (i ? Ar(hv(i)).body : void 0), [H, {
      slots: X,
      slotProps: Q,
      ...ne
    }] = ln("root", {
      ref: n,
      elementType: $Me,
      externalForwardedProps: {
        ...B,
        ...O
      },
      shouldForwardComponentProp: !0,
      additionalProps: {
        slots: {
          backdrop: v.backdrop
        },
        slotProps: {
          backdrop: KV(typeof x.backdrop == "function" ? x.backdrop(I) : x.backdrop, {
            invisible: !0
          })
        },
        container: z,
        open: y
      },
      ownerState: I,
      className: $e($.root, d)
    }), [te, se] = ln("paper", {
      ref: P,
      className: $.paper,
      elementType: tH,
      externalForwardedProps: B,
      shouldForwardComponentProp: !0,
      additionalProps: {
        elevation: m,
        style: j ? void 0 : {
          opacity: 0
        }
      },
      ownerState: I
    });
    return /* @__PURE__ */ S.jsx(H, {
      ...ne,
      ...!Ui(H) && {
        slots: X,
        slotProps: Q,
        disableScrollLock: A
      },
      children: /* @__PURE__ */ S.jsx(D, {
        ...G,
        timeout: Y,
        children: /* @__PURE__ */ S.jsx(te, {
          ...se,
          children: u
        })
      })
    });
  });
  function DMe(e) {
    return ot("MuiMenu", e);
  }
  nt("MuiMenu", ["root", "paper", "list"]);
  const FMe = {
    vertical: "top",
    horizontal: "right"
  }, LMe = {
    vertical: "top",
    horizontal: "left"
  }, zMe = (e) => {
    const {
      classes: t
    } = e;
    return rt({
      root: ["root"],
      paper: ["paper"],
      list: ["list"]
    }, DMe, t);
  }, BMe = Re(jMe, {
    shouldForwardProp: (e) => Sr(e) || e === "classes",
    name: "MuiMenu",
    slot: "Root"
  })({}), UMe = Re(tH, {
    name: "MuiMenu",
    slot: "Paper"
  })({
    // specZ: The maximum height of a simple menu should be one or more rows less than the view
    // height. This ensures a tappable area outside of the simple menu with which to dismiss
    // the menu.
    maxHeight: "calc(100% - 96px)",
    // Add iOS momentum scrolling for iOS < 13.0
    WebkitOverflowScrolling: "touch"
  }), VMe = Re(rMe, {
    name: "MuiMenu",
    slot: "List"
  })({
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0
  }), HMe = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiMenu"
    }), {
      autoFocus: o = !0,
      children: i,
      className: a,
      disableAutoFocusItem: s = !1,
      MenuListProps: c = {},
      onClose: u,
      open: d,
      PaperProps: p = {},
      PopoverClasses: m,
      transitionDuration: g = "auto",
      TransitionProps: {
        onEntering: y,
        ...b
      } = {},
      variant: v = "selectedMenu",
      slots: x = {},
      slotProps: E = {},
      ..._
    } = r, C = wF(), k = {
      ...r,
      autoFocus: o,
      disableAutoFocusItem: s,
      MenuListProps: c,
      onEntering: y,
      PaperProps: p,
      transitionDuration: g,
      TransitionProps: b,
      variant: v
    }, A = zMe(k), O = o && !s && d, P = T.useRef(null), I = (Y, B) => {
      P.current && P.current.adjustStyleForScrollbar(Y, {
        direction: C ? "rtl" : "ltr"
      }), y && y(Y, B);
    }, $ = (Y) => {
      Y.key === "Tab" && (Y.preventDefault(), u && u(Y, "tabKeyDown"));
    };
    let L = -1;
    T.Children.map(i, (Y, B) => {
      /* @__PURE__ */ T.isValidElement(Y) && (Y.props.disabled || (v === "selectedMenu" && Y.props.selected || L === -1) && (L = B));
    });
    const N = {
      slots: x,
      slotProps: {
        list: c,
        transition: b,
        paper: p,
        ...E
      }
    }, U = Ia({
      elementType: x.root,
      externalSlotProps: E.root,
      ownerState: k,
      className: [A.root, a]
    }), [j, V] = ln("paper", {
      className: A.paper,
      elementType: UMe,
      externalForwardedProps: N,
      shouldForwardComponentProp: !0,
      ownerState: k
    }), [F, K] = ln("list", {
      className: $e(A.list, c.className),
      elementType: VMe,
      shouldForwardComponentProp: !0,
      externalForwardedProps: N,
      getSlotProps: (Y) => ({
        ...Y,
        onKeyDown: (B) => {
          $(B), Y.onKeyDown?.(B);
        }
      }),
      ownerState: k
    }), W = typeof N.slotProps.transition == "function" ? N.slotProps.transition(k) : N.slotProps.transition;
    return /* @__PURE__ */ S.jsx(BMe, {
      onClose: u,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: C ? "right" : "left"
      },
      transformOrigin: C ? FMe : LMe,
      slots: {
        root: x.root,
        paper: j,
        backdrop: x.backdrop,
        ...x.transition && {
          // TODO: pass `slots.transition` directly once `TransitionComponent` is removed from Popover
          transition: x.transition
        }
      },
      slotProps: {
        root: U,
        paper: V,
        backdrop: typeof E.backdrop == "function" ? E.backdrop(k) : E.backdrop,
        transition: {
          ...W,
          onEntering: (...Y) => {
            I(...Y), W?.onEntering?.(...Y);
          }
        }
      },
      open: d,
      ref: n,
      transitionDuration: g,
      ownerState: k,
      ..._,
      classes: m,
      children: /* @__PURE__ */ S.jsx(F, {
        actions: P,
        autoFocus: o && (L === -1 || s),
        autoFocusItem: O,
        variant: v,
        ...K,
        children: i
      })
    });
  });
  function qMe(e) {
    return ot("MuiNativeSelect", e);
  }
  const HA = nt("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]), WMe = (e) => {
    const {
      classes: t,
      variant: n,
      disabled: r,
      multiple: o,
      open: i,
      error: a
    } = e, s = {
      select: ["select", n, r && "disabled", o && "multiple", a && "error"],
      icon: ["icon", `icon${Ie(n)}`, i && "iconOpen", r && "disabled"]
    };
    return rt(s, qMe, t);
  }, nH = Re("select", {
    name: "MuiNativeSelect"
  })(({
    theme: e
  }) => ({
    // Reset
    MozAppearance: "none",
    // Reset
    WebkitAppearance: "none",
    // When interacting quickly, the text can end up selected.
    // Native select can't be selected either.
    userSelect: "none",
    // Reset
    borderRadius: 0,
    cursor: "pointer",
    "&:focus": {
      // Reset Chrome style
      borderRadius: 0
    },
    [`&.${HA.disabled}`]: {
      cursor: "default"
    },
    "&[multiple]": {
      height: "auto"
    },
    "&:not([multiple]) option, &:not([multiple]) optgroup": {
      backgroundColor: (e.vars || e).palette.background.paper
    },
    variants: [{
      props: ({
        ownerState: t
      }) => t.variant !== "filled" && t.variant !== "outlined",
      style: {
        // Bump specificity to allow extending custom inputs
        "&&&": {
          paddingRight: 24,
          minWidth: 16
          // So it doesn't collapse.
        }
      }
    }, {
      props: {
        variant: "filled"
      },
      style: {
        "&&&": {
          paddingRight: 32
        }
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        borderRadius: (e.vars || e).shape.borderRadius,
        "&:focus": {
          borderRadius: (e.vars || e).shape.borderRadius
          // Reset the reset for Chrome style
        },
        "&&&": {
          paddingRight: 32
        }
      }
    }]
  })), GMe = Re(nH, {
    name: "MuiNativeSelect",
    slot: "Select",
    shouldForwardProp: Sr,
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.select, t[n.variant], n.error && t.error, {
        [`&.${HA.multiple}`]: t.multiple
      }];
    }
  })({}), rH = Re("svg", {
    name: "MuiNativeSelect"
  })(({
    theme: e
  }) => ({
    // We use a position absolute over a flexbox in order to forward the pointer events
    // to the input and to support wrapping tags..
    position: "absolute",
    right: 0,
    // Center vertically, height is 1em
    top: "calc(50% - .5em)",
    // Don't block pointer events on the select under the icon.
    pointerEvents: "none",
    color: (e.vars || e).palette.action.active,
    [`&.${HA.disabled}`]: {
      color: (e.vars || e).palette.action.disabled
    },
    variants: [{
      props: ({
        ownerState: t
      }) => t.open,
      style: {
        transform: "rotate(180deg)"
      }
    }, {
      props: {
        variant: "filled"
      },
      style: {
        right: 7
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        right: 7
      }
    }]
  })), KMe = Re(rH, {
    name: "MuiNativeSelect",
    slot: "Icon",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.icon, n.variant && t[`icon${Ie(n.variant)}`], n.open && t.iconOpen];
    }
  })({}), YMe = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const {
      className: r,
      disabled: o,
      error: i,
      IconComponent: a,
      inputRef: s,
      variant: c = "standard",
      ...u
    } = t, d = {
      ...t,
      disabled: o,
      variant: c,
      error: i
    }, p = WMe(d);
    return /* @__PURE__ */ S.jsxs(T.Fragment, {
      children: [/* @__PURE__ */ S.jsx(GMe, {
        ownerState: d,
        className: $e(p.select, r),
        disabled: o,
        ref: s || n,
        ...u
      }), t.multiple ? null : /* @__PURE__ */ S.jsx(KMe, {
        as: a,
        ownerState: d,
        className: p.icon
      })]
    });
  });
  function oH(e) {
    return ot("MuiSelect", e);
  }
  const ap = nt("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
  var I3;
  const XMe = Re(nH, {
    name: "MuiSelect",
    slot: "Select",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [
        // Win specificity over the input base
        {
          [`&.${ap.select}`]: t.select
        },
        {
          [`&.${ap.select}`]: t[n.variant]
        },
        {
          [`&.${ap.error}`]: t.error
        },
        {
          [`&.${ap.multiple}`]: t.multiple
        }
      ];
    }
  })({
    // Win specificity over the input base
    [`&.${ap.select}`]: {
      height: "auto",
      // Resets for multiple select with chips
      minHeight: "1.4375em",
      // Required for select\text-field height consistency
      textOverflow: "ellipsis",
      whiteSpace: "nowrap",
      overflow: "hidden"
    }
  }), ZMe = Re(rH, {
    name: "MuiSelect",
    slot: "Icon",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.icon, n.variant && t[`icon${Ie(n.variant)}`], n.open && t.iconOpen];
    }
  })({}), QMe = Re("input", {
    shouldForwardProp: (e) => yb(e) && e !== "classes",
    name: "MuiSelect",
    slot: "NativeInput"
  })({
    bottom: 0,
    left: 0,
    position: "absolute",
    opacity: 0,
    pointerEvents: "none",
    width: "100%",
    boxSizing: "border-box"
  });
  function $3(e, t) {
    return typeof t == "object" && t !== null ? e === t : String(e) === String(t);
  }
  function JMe(e) {
    return e == null || typeof e == "string" && !e.trim();
  }
  const eNe = (e) => {
    const {
      classes: t,
      variant: n,
      disabled: r,
      multiple: o,
      open: i,
      error: a
    } = e, s = {
      select: ["select", n, r && "disabled", o && "multiple", a && "error"],
      icon: ["icon", `icon${Ie(n)}`, i && "iconOpen", r && "disabled"],
      nativeInput: ["nativeInput"]
    };
    return rt(s, oH, t);
  }, tNe = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const {
      "aria-describedby": r,
      "aria-label": o,
      autoFocus: i,
      autoWidth: a,
      children: s,
      className: c,
      defaultOpen: u,
      defaultValue: d,
      disabled: p,
      displayEmpty: m,
      error: g = !1,
      IconComponent: y,
      inputRef: b,
      labelId: v,
      MenuProps: x = {},
      multiple: E,
      name: _,
      onBlur: C,
      onChange: k,
      onClose: A,
      onFocus: O,
      // eslint-disable-next-line react/prop-types
      onKeyDown: P,
      // eslint-disable-next-line react/prop-types
      onMouseDown: I,
      onOpen: $,
      open: L,
      readOnly: N,
      renderValue: U,
      required: j,
      SelectDisplayProps: V = {},
      tabIndex: F,
      // catching `type` from Input which makes no sense for SelectInput
      type: K,
      value: W,
      variant: Y = "standard",
      ...B
    } = t, [D, G] = Eh({
      controlled: W,
      default: d,
      name: "Select"
    }), [z, H] = Eh({
      controlled: L,
      default: u,
      name: "Select"
    }), X = T.useRef(null), Q = T.useRef(null), [ne, te] = T.useState(null), {
      current: se
    } = T.useRef(L != null), [ue, J] = T.useState(), ee = er(n, b), ie = T.useCallback((De) => {
      Q.current = De, De && te(De);
    }, []), le = ne?.parentNode;
    T.useImperativeHandle(ee, () => ({
      focus: () => {
        Q.current.focus();
      },
      node: X.current,
      value: D
    }), [D]), T.useEffect(() => {
      u && z && ne && !se && (J(a ? null : le.clientWidth), Q.current.focus());
    }, [ne, a]), T.useEffect(() => {
      i && Q.current.focus();
    }, [i]), T.useEffect(() => {
      if (!v)
        return;
      const De = Ar(Q.current).getElementById(v);
      if (De) {
        const ft = () => {
          getSelection().isCollapsed && Q.current.focus();
        };
        return De.addEventListener("click", ft), () => {
          De.removeEventListener("click", ft);
        };
      }
    }, [v]);
    const ge = (De, ft) => {
      De ? $ && $(ft) : A && A(ft), se || (J(a ? null : le.clientWidth), H(De));
    }, Se = (De) => {
      I?.(De), De.button === 0 && (De.preventDefault(), Q.current.focus(), ge(!0, De));
    }, Me = (De) => {
      ge(!1, De);
    }, je = T.Children.toArray(s), ze = (De) => {
      const ft = je.find((hn) => hn.props.value === De.target.value);
      ft !== void 0 && (G(ft.props.value), k && k(De, ft));
    }, Ye = (De) => (ft) => {
      let hn;
      if (ft.currentTarget.hasAttribute("tabindex")) {
        if (E) {
          hn = Array.isArray(D) ? D.slice() : [];
          const nr = D.indexOf(De.props.value);
          nr === -1 ? hn.push(De.props.value) : hn.splice(nr, 1);
        } else
          hn = De.props.value;
        if (De.props.onClick && De.props.onClick(ft), D !== hn && (G(hn), k)) {
          const nr = ft.nativeEvent || ft, Lo = new nr.constructor(nr.type, nr);
          Object.defineProperty(Lo, "target", {
            writable: !0,
            value: {
              value: hn,
              name: _
            }
          }), k(Lo, De);
        }
        E || ge(!1, ft);
      }
    }, Ue = (De) => {
      N || ([
        " ",
        "ArrowUp",
        "ArrowDown",
        // The native select doesn't respond to enter on macOS, but it's recommended by
        // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
        "Enter"
      ].includes(De.key) && (De.preventDefault(), ge(!0, De)), P?.(De));
    }, Ne = ne !== null && z, mt = (De) => {
      !Ne && C && (Object.defineProperty(De, "target", {
        writable: !0,
        value: {
          value: D,
          name: _
        }
      }), C(De));
    };
    delete B["aria-invalid"];
    let Je, Ae;
    const oe = [];
    let fe = !1;
    (U0({
      value: D
    }) || m) && (U ? Je = U(D) : fe = !0);
    const _e = je.map((De) => {
      if (!/* @__PURE__ */ T.isValidElement(De))
        return null;
      let ft;
      if (E) {
        if (!Array.isArray(D))
          throw new Error(Va(2));
        ft = D.some((hn) => $3(hn, De.props.value)), ft && fe && oe.push(De.props.children);
      } else
        ft = $3(D, De.props.value), ft && fe && (Ae = De.props.children);
      return /* @__PURE__ */ T.cloneElement(De, {
        "aria-selected": ft ? "true" : "false",
        onClick: Ye(De),
        onKeyUp: (hn) => {
          hn.key === " " && hn.preventDefault(), De.props.onKeyUp && De.props.onKeyUp(hn);
        },
        role: "option",
        selected: ft,
        value: void 0,
        // The value is most likely not a valid HTML attribute.
        "data-value": De.props.value
        // Instead, we provide it as a data attribute.
      });
    });
    fe && (E ? oe.length === 0 ? Je = null : Je = oe.reduce((De, ft, hn) => (De.push(ft), hn < oe.length - 1 && De.push(", "), De), []) : Je = Ae);
    let Ce = ue;
    !a && se && ne && (Ce = le.clientWidth);
    let Oe;
    typeof F < "u" ? Oe = F : Oe = p ? null : 0;
    const He = V.id || (_ ? `mui-component-select-${_}` : void 0), Ot = {
      ...t,
      variant: Y,
      value: D,
      open: Ne,
      error: g
    }, it = eNe(Ot), Et = {
      ...x.PaperProps,
      ...typeof x.slotProps?.paper == "function" ? x.slotProps.paper(Ot) : x.slotProps?.paper
    }, xn = {
      ...x.MenuListProps,
      ...typeof x.slotProps?.list == "function" ? x.slotProps.list(Ot) : x.slotProps?.list
    }, Mt = $f();
    return /* @__PURE__ */ S.jsxs(T.Fragment, {
      children: [/* @__PURE__ */ S.jsx(XMe, {
        as: "div",
        ref: ie,
        tabIndex: Oe,
        role: "combobox",
        "aria-controls": Ne ? Mt : void 0,
        "aria-disabled": p ? "true" : void 0,
        "aria-expanded": Ne ? "true" : "false",
        "aria-haspopup": "listbox",
        "aria-label": o,
        "aria-labelledby": [v, He].filter(Boolean).join(" ") || void 0,
        "aria-describedby": r,
        "aria-required": j ? "true" : void 0,
        "aria-invalid": g ? "true" : void 0,
        onKeyDown: Ue,
        onMouseDown: p || N ? null : Se,
        onBlur: mt,
        onFocus: O,
        ...V,
        ownerState: Ot,
        className: $e(V.className, it.select, c),
        id: He,
        children: JMe(Je) ? (
          // notranslate needed while Google Translate will not fix zero-width space issue
          I3 || (I3 = /* @__PURE__ */ S.jsx("span", {
            className: "notranslate",
            "aria-hidden": !0,
            children: ""
          }))
        ) : Je
      }), /* @__PURE__ */ S.jsx(QMe, {
        "aria-invalid": g,
        value: Array.isArray(D) ? D.join(",") : D,
        name: _,
        ref: X,
        "aria-hidden": !0,
        onChange: ze,
        tabIndex: -1,
        disabled: p,
        className: it.nativeInput,
        autoFocus: i,
        required: j,
        ...B,
        ownerState: Ot
      }), /* @__PURE__ */ S.jsx(ZMe, {
        as: y,
        className: it.icon,
        ownerState: Ot
      }), /* @__PURE__ */ S.jsx(HMe, {
        id: `menu-${_ || ""}`,
        anchorEl: le,
        open: Ne,
        onClose: Me,
        anchorOrigin: {
          vertical: "bottom",
          horizontal: "center"
        },
        transformOrigin: {
          vertical: "top",
          horizontal: "center"
        },
        ...x,
        slotProps: {
          ...x.slotProps,
          list: {
            "aria-labelledby": v,
            role: "listbox",
            "aria-multiselectable": E ? "true" : void 0,
            disableListWrap: !0,
            id: Mt,
            ...xn
          },
          paper: {
            ...Et,
            style: {
              minWidth: Ce,
              ...Et != null ? Et.style : null
            }
          }
        },
        children: _e
      })]
    });
  }), nNe = po(/* @__PURE__ */ S.jsx("path", {
    d: "M7 10l5 5 5-5z"
  })), rNe = (e) => {
    const {
      classes: t
    } = e, r = rt({
      root: ["root"]
    }, oH, t);
    return {
      ...t,
      ...r
    };
  }, qA = {
    name: "MuiSelect",
    slot: "Root",
    shouldForwardProp: (e) => Sr(e) && e !== "variant"
  }, oNe = Re(FA, qA)(""), iNe = Re(zA, qA)(""), aNe = Re(LA, qA)(""), iH = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      name: "MuiSelect",
      props: t
    }), {
      autoWidth: o = !1,
      children: i,
      classes: a = {},
      className: s,
      defaultOpen: c = !1,
      displayEmpty: u = !1,
      IconComponent: d = nNe,
      id: p,
      input: m,
      inputProps: g,
      label: y,
      labelId: b,
      MenuProps: v,
      multiple: x = !1,
      native: E = !1,
      onClose: _,
      onOpen: C,
      open: k,
      renderValue: A,
      SelectDisplayProps: O,
      variant: P = "outlined",
      ...I
    } = r, $ = E ? YMe : tNe, L = ra(), N = yl({
      props: r,
      muiFormControl: L,
      states: ["variant", "error"]
    }), U = N.variant || P, j = {
      ...r,
      variant: U,
      classes: a
    }, V = rNe(j), {
      root: F,
      ...K
    } = V, W = m || {
      standard: /* @__PURE__ */ S.jsx(oNe, {
        ownerState: j
      }),
      outlined: /* @__PURE__ */ S.jsx(iNe, {
        label: y,
        ownerState: j
      }),
      filled: /* @__PURE__ */ S.jsx(aNe, {
        ownerState: j
      })
    }[U], Y = er(n, mm(W));
    return /* @__PURE__ */ S.jsx(T.Fragment, {
      children: /* @__PURE__ */ T.cloneElement(W, {
        // Most of the logic is implemented in `SelectInput`.
        // The `Select` component is a simple API wrapper to expose something better to play with.
        inputComponent: $,
        inputProps: {
          children: i,
          error: N.error,
          IconComponent: d,
          variant: U,
          type: void 0,
          // We render a select. We can ignore the type provided by the `Input`.
          multiple: x,
          ...E ? {
            id: p
          } : {
            autoWidth: o,
            defaultOpen: c,
            displayEmpty: u,
            labelId: b,
            MenuProps: v,
            onClose: _,
            onOpen: C,
            open: k,
            renderValue: A,
            SelectDisplayProps: {
              id: p,
              ...O
            }
          },
          ...g,
          classes: g ? xr(K, g.classes) : K,
          ...m ? m.props.inputProps : {}
        },
        ...(x && E || u) && U === "outlined" ? {
          notched: !0
        } : {},
        ref: Y,
        className: $e(W.props.className, s, V.root),
        // If a custom input is provided via 'input' prop, do not allow 'variant' to be propagated to it's root element. See https://github.com/mui/material-ui/issues/33894.
        ...!m && {
          variant: U
        },
        ...I
      })
    });
  });
  iH.muiName = "Select";
  function sNe(e) {
    return ot("MuiTextField", e);
  }
  nt("MuiTextField", ["root"]);
  const lNe = {
    standard: FA,
    filled: LA,
    outlined: zA
  }, cNe = (e) => {
    const {
      classes: t
    } = e;
    return rt({
      root: ["root"]
    }, sNe, t);
  }, uNe = Re(BA, {
    name: "MuiTextField",
    slot: "Root"
  })({}), WA = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiTextField"
    }), {
      autoComplete: o,
      autoFocus: i = !1,
      children: a,
      className: s,
      color: c = "primary",
      defaultValue: u,
      disabled: d = !1,
      error: p = !1,
      FormHelperTextProps: m,
      fullWidth: g = !1,
      helperText: y,
      id: b,
      InputLabelProps: v,
      inputProps: x,
      InputProps: E,
      inputRef: _,
      label: C,
      maxRows: k,
      minRows: A,
      multiline: O = !1,
      name: P,
      onBlur: I,
      onChange: $,
      onFocus: L,
      placeholder: N,
      required: U = !1,
      rows: j,
      select: V = !1,
      SelectProps: F,
      slots: K = {},
      slotProps: W = {},
      type: Y,
      value: B,
      variant: D = "outlined",
      ...G
    } = r, z = {
      ...r,
      autoFocus: i,
      color: c,
      disabled: d,
      error: p,
      fullWidth: g,
      multiline: O,
      required: U,
      select: V,
      variant: D
    }, H = cNe(z), X = $f(b), Q = y && X ? `${X}-helper-text` : void 0, ne = C && X ? `${X}-label` : void 0, te = lNe[D], se = {
      slots: K,
      slotProps: {
        input: E,
        inputLabel: v,
        htmlInput: x,
        formHelperText: m,
        select: F,
        ...W
      }
    }, ue = {}, J = se.slotProps.inputLabel;
    D === "outlined" && (J && typeof J.shrink < "u" && (ue.notched = J.shrink), ue.label = C), V && ((!F || !F.native) && (ue.id = void 0), ue["aria-describedby"] = void 0);
    const [ee, ie] = ln("root", {
      elementType: uNe,
      shouldForwardComponentProp: !0,
      externalForwardedProps: {
        ...se,
        ...G
      },
      ownerState: z,
      className: $e(H.root, s),
      ref: n,
      additionalProps: {
        disabled: d,
        error: p,
        fullWidth: g,
        required: U,
        color: c,
        variant: D
      }
    }), [le, ge] = ln("input", {
      elementType: te,
      externalForwardedProps: se,
      additionalProps: ue,
      ownerState: z
    }), [Se, Me] = ln("inputLabel", {
      elementType: GOe,
      externalForwardedProps: se,
      ownerState: z
    }), [je, ze] = ln("htmlInput", {
      elementType: "input",
      externalForwardedProps: se,
      ownerState: z
    }), [Ye, Ue] = ln("formHelperText", {
      elementType: UA,
      externalForwardedProps: se,
      ownerState: z
    }), [Ne, mt] = ln("select", {
      elementType: iH,
      externalForwardedProps: se,
      ownerState: z
    }), Je = /* @__PURE__ */ S.jsx(le, {
      "aria-describedby": Q,
      autoComplete: o,
      autoFocus: i,
      defaultValue: u,
      fullWidth: g,
      multiline: O,
      name: P,
      rows: j,
      maxRows: k,
      minRows: A,
      type: Y,
      value: B,
      id: X,
      inputRef: _,
      onBlur: I,
      onChange: $,
      onFocus: L,
      placeholder: N,
      inputProps: ze,
      slots: {
        input: K.htmlInput ? je : void 0
      },
      ...ge
    });
    return /* @__PURE__ */ S.jsxs(ee, {
      ...ie,
      children: [C != null && C !== "" && /* @__PURE__ */ S.jsx(Se, {
        htmlFor: X,
        id: ne,
        ...Me,
        children: C
      }), V ? /* @__PURE__ */ S.jsx(Ne, {
        "aria-describedby": Q,
        id: X,
        labelId: ne,
        value: B,
        input: Je,
        ...mt,
        children: a
      }) : Je, y && /* @__PURE__ */ S.jsx(Ye, {
        id: Q,
        ...Ue,
        children: y
      })]
    });
  }), fNe = ["date", "datetime-local", "file", "time"];
  function dNe(e) {
    const {
      id: t,
      name: n,
      // remove this from textFieldProps
      htmlName: r,
      placeholder: o,
      required: i,
      readonly: a,
      disabled: s,
      type: c,
      label: u,
      hideLabel: d,
      hideError: p,
      value: m,
      onChange: g,
      onChangeOverride: y,
      onBlur: b,
      onFocus: v,
      autofocus: x,
      options: E,
      schema: _,
      uiSchema: C,
      rawErrors: k = [],
      errorSchema: A,
      registry: O,
      InputLabelProps: P,
      ...I
    } = e, $ = hV(_, c, E), { step: L, min: N, max: U, accept: j, ...V } = $, F = { step: L, min: N, max: U, accept: j, ..._.examples ? { list: _h(t) } : void 0 }, K = ({ target: { value: D } }) => g(D === "" ? E.emptyValue : D), W = ({ target: D }) => b(t, D && D.value), Y = ({ target: D }) => v(t, D && D.value), B = fNe.includes(c) ? {
      ...P,
      shrink: !0
    } : P;
    return S.jsxs(S.Fragment, { children: [S.jsx(WA, { id: t, name: r || t, placeholder: o, label: Pc(u || void 0, d, void 0), autoFocus: x, required: i, disabled: s || a, slotProps: { htmlInput: F, inputLabel: B }, ...V, value: m || m === 0 ? m : "", error: k.length > 0, onChange: y || K, onBlur: W, onFocus: Y, ...I, "aria-describedby": go(t, !!_.examples) }), Array.isArray(_.examples) && S.jsx("datalist", { id: _h(t), children: _.examples.concat(_.default && !_.examples.includes(_.default) ? [_.default] : []).map((D) => S.jsx("option", { value: D }, D)) })] });
  }
  function pNe(e) {
    return ot("MuiTypography", e);
  }
  const j3 = nt("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]), hNe = {
    primary: !0,
    secondary: !0,
    error: !0,
    info: !0,
    success: !0,
    warning: !0,
    textPrimary: !0,
    textSecondary: !0,
    textDisabled: !0
  }, mNe = JZ(), gNe = (e) => {
    const {
      align: t,
      gutterBottom: n,
      noWrap: r,
      paragraph: o,
      variant: i,
      classes: a
    } = e, s = {
      root: ["root", i, e.align !== "inherit" && `align${Ie(t)}`, n && "gutterBottom", r && "noWrap", o && "paragraph"]
    };
    return rt(s, pNe, a);
  }, yNe = Re("span", {
    name: "MuiTypography",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.variant && t[n.variant], n.align !== "inherit" && t[`align${Ie(n.align)}`], n.noWrap && t.noWrap, n.gutterBottom && t.gutterBottom, n.paragraph && t.paragraph];
    }
  })(st(({
    theme: e
  }) => ({
    margin: 0,
    variants: [{
      props: {
        variant: "inherit"
      },
      style: {
        // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
        font: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit"
      }
    }, ...Object.entries(e.typography).filter(([t, n]) => t !== "inherit" && n && typeof n == "object").map(([t, n]) => ({
      props: {
        variant: t
      },
      style: n
    })), ...Object.entries(e.palette).filter(wr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        color: (e.vars || e).palette[t].main
      }
    })), ...Object.entries(e.palette?.text || {}).filter(([, t]) => typeof t == "string").map(([t]) => ({
      props: {
        color: `text${Ie(t)}`
      },
      style: {
        color: (e.vars || e).palette.text[t]
      }
    })), {
      props: ({
        ownerState: t
      }) => t.align !== "inherit",
      style: {
        textAlign: "var(--Typography-textAlign)"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.noWrap,
      style: {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.gutterBottom,
      style: {
        marginBottom: "0.35em"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.paragraph,
      style: {
        marginBottom: 16
      }
    }]
  }))), D3 = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    subtitle1: "h6",
    subtitle2: "h6",
    body1: "p",
    body2: "p",
    inherit: "p"
  }, Fi = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const {
      color: r,
      ...o
    } = ut({
      props: t,
      name: "MuiTypography"
    }), i = !hNe[r], a = mNe({
      ...o,
      ...i && {
        color: r
      }
    }), {
      align: s = "inherit",
      className: c,
      component: u,
      gutterBottom: d = !1,
      noWrap: p = !1,
      paragraph: m = !1,
      variant: g = "body1",
      variantMapping: y = D3,
      ...b
    } = a, v = {
      ...a,
      align: s,
      color: r,
      className: c,
      component: u,
      gutterBottom: d,
      noWrap: p,
      paragraph: m,
      variant: g,
      variantMapping: y
    }, x = u || (m ? "p" : y[g] || D3[g]) || "span", E = gNe(v);
    return /* @__PURE__ */ S.jsx(yNe, {
      as: x,
      ref: n,
      className: $e(E.root, c),
      ...b,
      ownerState: v,
      style: {
        ...s !== "inherit" && {
          "--Typography-textAlign": s
        },
        ...b.style
      }
    });
  });
  function vNe(e) {
    const { id: t, description: n, registry: r, uiSchema: o } = e;
    return n ? S.jsx(Fi, { id: t, variant: "subtitle2", style: { marginTop: "5px" }, children: S.jsx(IA, { description: n, registry: r, uiSchema: o }) }) : null;
  }
  const bNe = po(/* @__PURE__ */ S.jsx("path", {
    d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m1 15h-2v-2h2zm0-4h-2V7h2z"
  }));
  function xNe(e) {
    return ot("MuiListItem", e);
  }
  nt("MuiListItem", ["root", "container", "dense", "alignItemsFlexStart", "divider", "gutters", "padding", "secondaryAction"]);
  const wNe = nt("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"]);
  function SNe(e) {
    return ot("MuiListItemSecondaryAction", e);
  }
  nt("MuiListItemSecondaryAction", ["root", "disableGutters"]);
  const _Ne = (e) => {
    const {
      disableGutters: t,
      classes: n
    } = e;
    return rt({
      root: ["root", t && "disableGutters"]
    }, SNe, n);
  }, ENe = Re("div", {
    name: "MuiListItemSecondaryAction",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.disableGutters && t.disableGutters];
    }
  })({
    position: "absolute",
    right: 16,
    top: "50%",
    transform: "translateY(-50%)",
    variants: [{
      props: ({
        ownerState: e
      }) => e.disableGutters,
      style: {
        right: 0
      }
    }]
  }), aH = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiListItemSecondaryAction"
    }), {
      className: o,
      ...i
    } = r, a = T.useContext(Ua), s = {
      ...r,
      disableGutters: a.disableGutters
    }, c = _Ne(s);
    return /* @__PURE__ */ S.jsx(ENe, {
      className: $e(c.root, o),
      ownerState: s,
      ref: n,
      ...i
    });
  });
  aH.muiName = "ListItemSecondaryAction";
  const CNe = (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.dense && t.dense, n.alignItems === "flex-start" && t.alignItemsFlexStart, n.divider && t.divider, !n.disableGutters && t.gutters, !n.disablePadding && t.padding, n.hasSecondaryAction && t.secondaryAction];
  }, kNe = (e) => {
    const {
      alignItems: t,
      classes: n,
      dense: r,
      disableGutters: o,
      disablePadding: i,
      divider: a,
      hasSecondaryAction: s
    } = e;
    return rt({
      root: ["root", r && "dense", !o && "gutters", !i && "padding", a && "divider", t === "flex-start" && "alignItemsFlexStart", s && "secondaryAction"],
      container: ["container"],
      secondaryAction: ["secondaryAction"]
    }, xNe, n);
  }, TNe = Re("div", {
    name: "MuiListItem",
    slot: "Root",
    overridesResolver: CNe
  })(st(({
    theme: e
  }) => ({
    display: "flex",
    justifyContent: "flex-start",
    alignItems: "center",
    position: "relative",
    textDecoration: "none",
    width: "100%",
    boxSizing: "border-box",
    textAlign: "left",
    variants: [{
      props: ({
        ownerState: t
      }) => !t.disablePadding,
      style: {
        paddingTop: 8,
        paddingBottom: 8
      }
    }, {
      props: ({
        ownerState: t
      }) => !t.disablePadding && t.dense,
      style: {
        paddingTop: 4,
        paddingBottom: 4
      }
    }, {
      props: ({
        ownerState: t
      }) => !t.disablePadding && !t.disableGutters,
      style: {
        paddingLeft: 16,
        paddingRight: 16
      }
    }, {
      props: ({
        ownerState: t
      }) => !t.disablePadding && !!t.secondaryAction,
      style: {
        // Add some space to avoid collision as `ListItemSecondaryAction`
        // is absolutely positioned.
        paddingRight: 48
      }
    }, {
      props: ({
        ownerState: t
      }) => !!t.secondaryAction,
      style: {
        [`& > .${wNe.root}`]: {
          paddingRight: 48
        }
      }
    }, {
      props: {
        alignItems: "flex-start"
      },
      style: {
        alignItems: "flex-start"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.divider,
      style: {
        borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
        backgroundClip: "padding-box"
      }
    }, {
      props: ({
        ownerState: t
      }) => t.button,
      style: {
        transition: e.transitions.create("background-color", {
          duration: e.transitions.duration.shortest
        }),
        "&:hover": {
          textDecoration: "none",
          backgroundColor: (e.vars || e).palette.action.hover,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }
      }
    }, {
      props: ({
        ownerState: t
      }) => t.hasSecondaryAction,
      style: {
        // Add some space to avoid collision as `ListItemSecondaryAction`
        // is absolutely positioned.
        paddingRight: 48
      }
    }]
  }))), ANe = Re("li", {
    name: "MuiListItem",
    slot: "Container"
  })({
    position: "relative"
  }), sH = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiListItem"
    }), {
      alignItems: o = "center",
      children: i,
      className: a,
      component: s,
      components: c = {},
      componentsProps: u = {},
      ContainerComponent: d = "li",
      ContainerProps: {
        className: p,
        ...m
      } = {},
      dense: g = !1,
      disableGutters: y = !1,
      disablePadding: b = !1,
      divider: v = !1,
      secondaryAction: x,
      slotProps: E = {},
      slots: _ = {},
      ...C
    } = r, k = T.useContext(Ua), A = T.useMemo(() => ({
      dense: g || k.dense || !1,
      alignItems: o,
      disableGutters: y
    }), [o, k.dense, g, y]), O = T.useRef(null), P = T.Children.toArray(i), I = P.length && Tp(P[P.length - 1], ["ListItemSecondaryAction"]), $ = {
      ...r,
      alignItems: o,
      dense: A.dense,
      disableGutters: y,
      disablePadding: b,
      divider: v,
      hasSecondaryAction: I
    }, L = kNe($), N = er(O, n), U = {
      slots: _,
      slotProps: E
    }, [j, V] = ln("secondaryAction", {
      elementType: aH,
      externalForwardedProps: U,
      ownerState: $,
      className: L.secondaryAction
    }), F = _.root || c.Root || TNe, K = E.root || u.root || {}, W = {
      className: $e(L.root, K.className, a),
      ...C
    };
    let Y = s || "li";
    return I ? (Y = !W.component && !s ? "div" : Y, d === "li" && (Y === "li" ? Y = "div" : W.component === "li" && (W.component = "div")), /* @__PURE__ */ S.jsx(Ua.Provider, {
      value: A,
      children: /* @__PURE__ */ S.jsxs(ANe, {
        as: d,
        className: $e(L.container, p),
        ref: N,
        ownerState: $,
        ...m,
        children: [/* @__PURE__ */ S.jsx(F, {
          ...K,
          ...!Ui(F) && {
            as: Y,
            ownerState: {
              ...$,
              ...K.ownerState
            }
          },
          ...W,
          children: P
        }), P.pop()]
      })
    })) : /* @__PURE__ */ S.jsx(Ua.Provider, {
      value: A,
      children: /* @__PURE__ */ S.jsxs(F, {
        ...K,
        as: Y,
        ref: N,
        ...!Ui(F) && {
          ownerState: {
            ...$,
            ...K.ownerState
          }
        },
        ...W,
        children: [P, x && /* @__PURE__ */ S.jsx(j, {
          ...V,
          children: x
        })]
      })
    });
  });
  function RNe(e) {
    return ot("MuiListItemIcon", e);
  }
  const F3 = nt("MuiListItemIcon", ["root", "alignItemsFlexStart"]), ONe = (e) => {
    const {
      alignItems: t,
      classes: n
    } = e;
    return rt({
      root: ["root", t === "flex-start" && "alignItemsFlexStart"]
    }, RNe, n);
  }, MNe = Re("div", {
    name: "MuiListItemIcon",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.alignItems === "flex-start" && t.alignItemsFlexStart];
    }
  })(st(({
    theme: e
  }) => ({
    minWidth: 56,
    color: (e.vars || e).palette.action.active,
    flexShrink: 0,
    display: "inline-flex",
    variants: [{
      props: {
        alignItems: "flex-start"
      },
      style: {
        marginTop: 8
      }
    }]
  }))), NNe = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiListItemIcon"
    }), {
      className: o,
      ...i
    } = r, a = T.useContext(Ua), s = {
      ...r,
      alignItems: a.alignItems
    }, c = ONe(s);
    return /* @__PURE__ */ S.jsx(MNe, {
      className: $e(c.root, o),
      ownerState: s,
      ref: n,
      ...i
    });
  });
  function PNe(e) {
    return ot("MuiListItemText", e);
  }
  const Xu = nt("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]), INe = (e) => {
    const {
      classes: t,
      inset: n,
      primary: r,
      secondary: o,
      dense: i
    } = e;
    return rt({
      root: ["root", n && "inset", i && "dense", r && o && "multiline"],
      primary: ["primary"],
      secondary: ["secondary"]
    }, PNe, t);
  }, $Ne = Re("div", {
    name: "MuiListItemText",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [{
        [`& .${Xu.primary}`]: t.primary
      }, {
        [`& .${Xu.secondary}`]: t.secondary
      }, t.root, n.inset && t.inset, n.primary && n.secondary && t.multiline, n.dense && t.dense];
    }
  })({
    flex: "1 1 auto",
    minWidth: 0,
    marginTop: 4,
    marginBottom: 4,
    [`.${j3.root}:where(& .${Xu.primary})`]: {
      display: "block"
    },
    [`.${j3.root}:where(& .${Xu.secondary})`]: {
      display: "block"
    },
    variants: [{
      props: ({
        ownerState: e
      }) => e.primary && e.secondary,
      style: {
        marginTop: 6,
        marginBottom: 6
      }
    }, {
      props: ({
        ownerState: e
      }) => e.inset,
      style: {
        paddingLeft: 56
      }
    }]
  }), jNe = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiListItemText"
    }), {
      children: o,
      className: i,
      disableTypography: a = !1,
      inset: s = !1,
      primary: c,
      primaryTypographyProps: u,
      secondary: d,
      secondaryTypographyProps: p,
      slots: m = {},
      slotProps: g = {},
      ...y
    } = r, {
      dense: b
    } = T.useContext(Ua);
    let v = c ?? o, x = d;
    const E = {
      ...r,
      disableTypography: a,
      inset: s,
      primary: !!v,
      secondary: !!x,
      dense: b
    }, _ = INe(E), C = {
      slots: m,
      slotProps: {
        primary: u,
        secondary: p,
        ...g
      }
    }, [k, A] = ln("root", {
      className: $e(_.root, i),
      elementType: $Ne,
      externalForwardedProps: {
        ...C,
        ...y
      },
      ownerState: E,
      ref: n
    }), [O, P] = ln("primary", {
      className: _.primary,
      elementType: Fi,
      externalForwardedProps: C,
      ownerState: E
    }), [I, $] = ln("secondary", {
      className: _.secondary,
      elementType: Fi,
      externalForwardedProps: C,
      ownerState: E
    });
    return v != null && v.type !== Fi && !a && (v = /* @__PURE__ */ S.jsx(O, {
      variant: b ? "body2" : "body1",
      component: P?.variant ? void 0 : "span",
      ...P,
      children: v
    })), x != null && x.type !== Fi && !a && (x = /* @__PURE__ */ S.jsx(I, {
      variant: "body2",
      color: "textSecondary",
      ...$,
      children: x
    })), /* @__PURE__ */ S.jsxs(k, {
      ...A,
      children: [v, x]
    });
  });
  function DNe({ errors: e, registry: t }) {
    const { translateString: n } = t;
    return S.jsx(A1, { elevation: 2, children: S.jsxs(pl, { mb: 2, p: 2, children: [S.jsx(Fi, { variant: "h6", children: n(bt.ErrorsLabel) }), S.jsx(VA, { dense: !0, children: e.map((r, o) => S.jsxs(sH, { children: [S.jsx(NNe, { children: S.jsx(bNe, { color: "error" }) }), S.jsx(jNe, { primary: r.stack })] }, o)) })] }) });
  }
  const FNe = po(/* @__PURE__ */ S.jsx("path", {
    d: "m20 12-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8z"
  })), LNe = po(/* @__PURE__ */ S.jsx("path", {
    d: "m4 12 1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8z"
  })), zNe = po(/* @__PURE__ */ S.jsx("path", {
    d: "M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"
  })), BNe = po(/* @__PURE__ */ S.jsx("path", {
    d: "M19 13H5v-2h14z"
  }));
  function gm(e) {
    const { icon: t, color: n, uiSchema: r, registry: o, ...i } = e;
    return S.jsx(ZV, { ...i, size: "small", color: n, children: t });
  }
  function UNe(e) {
    const { registry: { translateString: t } } = e;
    return S.jsx(gm, { title: t(bt.CopyButton), ...e, icon: S.jsx(zNe, { fontSize: "small" }) });
  }
  function VNe(e) {
    const { registry: { translateString: t } } = e;
    return S.jsx(gm, { title: t(bt.MoveDownButton), ...e, icon: S.jsx(FNe, { fontSize: "small" }) });
  }
  function HNe(e) {
    const { registry: { translateString: t } } = e;
    return S.jsx(gm, { title: t(bt.MoveUpButton), ...e, icon: S.jsx(LNe, { fontSize: "small" }) });
  }
  function lH(e) {
    const { iconType: t, ...n } = e, { registry: { translateString: r } } = n;
    return S.jsx(gm, { title: r(bt.RemoveButton), ...n, color: "error", icon: S.jsx(BNe, { fontSize: t === "default" ? void 0 : "small" }) });
  }
  function qNe(e) {
    const { errors: t = [], fieldPathId: n } = e;
    if (t.length === 0)
      return null;
    const r = SA(n);
    return S.jsx(VA, { id: r, dense: !0, disablePadding: !0, children: t.map((o, i) => S.jsx(sH, { disableGutters: !0, children: S.jsx(UA, { component: "div", id: `${r}-${i}`, children: o }) }, i)) });
  }
  function WNe(e) {
    const { fieldPathId: t, help: n, uiSchema: r, registry: o } = e;
    return n ? S.jsx(UA, { component: "div", id: _A(t), style: { marginTop: "5px" }, children: S.jsx($A, { help: n, registry: o, uiSchema: r }) }) : null;
  }
  function GNe(e) {
    const { id: t, children: n, classNames: r, style: o, disabled: i, displayLabel: a, hidden: s, label: c, onKeyRename: u, onKeyRenameBlur: d, onRemoveProperty: p, readonly: m, required: g, rawErrors: y = [], errors: b, help: v, description: x, rawDescription: E, schema: _, uiSchema: C, registry: k } = e, A = Qe(C), O = tt("WrapIfAdditionalTemplate", k, A);
    if (s)
      return S.jsx("div", { style: { display: "none" }, children: n });
    const P = A.widget === "checkbox";
    return S.jsx(O, { classNames: r, style: o, disabled: i, id: t, label: c, displayLabel: a, rawDescription: E, onKeyRename: u, onKeyRenameBlur: d, onRemoveProperty: p, readonly: m, required: g, schema: _, uiSchema: C, registry: k, children: S.jsxs(BA, { fullWidth: !0, error: !!y.length, required: g, children: [n, a && !P && E ? S.jsx(Fi, { variant: "caption", color: "textSecondary", children: x }) : null, b, v] }) });
  }
  function KNe(e) {
    const { children: t, column: n, ...r } = e;
    return S.jsx(fr, { container: !n, ...r, children: t });
  }
  function YNe(e) {
    const { optionSchemaField: t, selector: n } = e;
    return S.jsxs(pl, { sx: { mb: 2 }, children: [S.jsx(BA, { fullWidth: !0, sx: { mb: 2 }, children: n }), t] });
  }
  function XNe(e) {
    const { description: t, title: n, properties: r, required: o, disabled: i, readonly: a, uiSchema: s, fieldPathId: c, schema: u, formData: d, optionalDataControl: p, onAddProperty: m, registry: g } = e, y = Qe(s), b = tt("TitleFieldTemplate", g, y), v = tt("DescriptionFieldTemplate", g, y), x = !a && !i, { ButtonTemplates: { AddButton: E } } = g.templates;
    return S.jsxs(S.Fragment, { children: [n && S.jsx(b, { id: x1(c), title: n, required: o, schema: u, uiSchema: s, registry: g, optionalDataControl: x ? p : void 0 }), t && S.jsx(v, { id: Nc(c), description: t, schema: u, uiSchema: s, registry: g }), S.jsxs(fr, { container: !0, spacing: 2, style: { marginTop: "10px" }, children: [x ? void 0 : p, r.map((_, C) => (
      // Remove the <Grid> if the inner element is hidden as the <Grid>
      // itself would otherwise still take up space.
      _.hidden ? _.content : S.jsx(fr, { size: { xs: 12 }, style: { marginBottom: "10px" }, children: _.content }, C)
    ))] }), Q8(u, s, d) && S.jsx(fr, { container: !0, justifyContent: "flex-end", children: S.jsx(fr, { children: S.jsx(E, { id: ji(c, "add"), className: "rjsf-object-property-expand", onClick: m, disabled: i || a, uiSchema: s, registry: g }) }) })] });
  }
  function ZNe(e) {
    const { id: t, registry: n, label: r, onAddClick: o, onRemoveClick: i } = e;
    return o ? S.jsx(gm, { id: t, registry: n, className: "rjsf-add-optional-data", onClick: o, title: r, icon: S.jsx(YV, { fontSize: "small" }) }) : i ? S.jsx(lH, { id: t, registry: n, className: "rjsf-remove-optional-data", onClick: i, title: r }) : S.jsx("em", { id: t, children: r });
  }
  function QNe(e) {
    return ot("MuiButton", e);
  }
  const Wl = nt("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge", "loading", "loadingWrapper", "loadingIconPlaceholder", "loadingIndicator", "loadingPositionCenter", "loadingPositionStart", "loadingPositionEnd"]), JNe = /* @__PURE__ */ T.createContext({}), ePe = /* @__PURE__ */ T.createContext(void 0), tPe = (e) => {
    const {
      color: t,
      disableElevation: n,
      fullWidth: r,
      size: o,
      variant: i,
      loading: a,
      loadingPosition: s,
      classes: c
    } = e, u = {
      root: ["root", a && "loading", i, `${i}${Ie(t)}`, `size${Ie(o)}`, `${i}Size${Ie(o)}`, `color${Ie(t)}`, n && "disableElevation", r && "fullWidth", a && `loadingPosition${Ie(s)}`],
      startIcon: ["icon", "startIcon", `iconSize${Ie(o)}`],
      endIcon: ["icon", "endIcon", `iconSize${Ie(o)}`],
      loadingIndicator: ["loadingIndicator"],
      loadingWrapper: ["loadingWrapper"]
    }, d = rt(u, QNe, c);
    return {
      ...c,
      // forward the focused, disabled, etc. classes to the ButtonBase
      ...d
    };
  }, cH = [{
    props: {
      size: "small"
    },
    style: {
      "& > *:nth-of-type(1)": {
        fontSize: 18
      }
    }
  }, {
    props: {
      size: "medium"
    },
    style: {
      "& > *:nth-of-type(1)": {
        fontSize: 20
      }
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      "& > *:nth-of-type(1)": {
        fontSize: 22
      }
    }
  }], nPe = Re(Lh, {
    shouldForwardProp: (e) => Sr(e) || e === "classes",
    name: "MuiButton",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[n.variant], t[`${n.variant}${Ie(n.color)}`], t[`size${Ie(n.size)}`], t[`${n.variant}Size${Ie(n.size)}`], n.color === "inherit" && t.colorInherit, n.disableElevation && t.disableElevation, n.fullWidth && t.fullWidth, n.loading && t.loading];
    }
  })(st(({
    theme: e
  }) => {
    const t = e.palette.mode === "light" ? e.palette.grey[300] : e.palette.grey[800], n = e.palette.mode === "light" ? e.palette.grey.A100 : e.palette.grey[700];
    return {
      ...e.typography.button,
      minWidth: 64,
      padding: "6px 16px",
      border: 0,
      borderRadius: (e.vars || e).shape.borderRadius,
      transition: e.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
        duration: e.transitions.duration.short
      }),
      "&:hover": {
        textDecoration: "none"
      },
      [`&.${Wl.disabled}`]: {
        color: (e.vars || e).palette.action.disabled
      },
      variants: [{
        props: {
          variant: "contained"
        },
        style: {
          color: "var(--variant-containedColor)",
          backgroundColor: "var(--variant-containedBg)",
          boxShadow: (e.vars || e).shadows[2],
          "&:hover": {
            boxShadow: (e.vars || e).shadows[4],
            // Reset on touch devices, it doesn't add specificity
            "@media (hover: none)": {
              boxShadow: (e.vars || e).shadows[2]
            }
          },
          "&:active": {
            boxShadow: (e.vars || e).shadows[8]
          },
          [`&.${Wl.focusVisible}`]: {
            boxShadow: (e.vars || e).shadows[6]
          },
          [`&.${Wl.disabled}`]: {
            color: (e.vars || e).palette.action.disabled,
            boxShadow: (e.vars || e).shadows[0],
            backgroundColor: (e.vars || e).palette.action.disabledBackground
          }
        }
      }, {
        props: {
          variant: "outlined"
        },
        style: {
          padding: "5px 15px",
          border: "1px solid currentColor",
          borderColor: "var(--variant-outlinedBorder, currentColor)",
          backgroundColor: "var(--variant-outlinedBg)",
          color: "var(--variant-outlinedColor)",
          [`&.${Wl.disabled}`]: {
            border: `1px solid ${(e.vars || e).palette.action.disabledBackground}`
          }
        }
      }, {
        props: {
          variant: "text"
        },
        style: {
          padding: "6px 8px",
          color: "var(--variant-textColor)",
          backgroundColor: "var(--variant-textBg)"
        }
      }, ...Object.entries(e.palette).filter(wr()).map(([r]) => ({
        props: {
          color: r
        },
        style: {
          "--variant-textColor": (e.vars || e).palette[r].main,
          "--variant-outlinedColor": (e.vars || e).palette[r].main,
          "--variant-outlinedBorder": e.alpha((e.vars || e).palette[r].main, 0.5),
          "--variant-containedColor": (e.vars || e).palette[r].contrastText,
          "--variant-containedBg": (e.vars || e).palette[r].main,
          "@media (hover: hover)": {
            "&:hover": {
              "--variant-containedBg": (e.vars || e).palette[r].dark,
              "--variant-textBg": e.alpha((e.vars || e).palette[r].main, (e.vars || e).palette.action.hoverOpacity),
              "--variant-outlinedBorder": (e.vars || e).palette[r].main,
              "--variant-outlinedBg": e.alpha((e.vars || e).palette[r].main, (e.vars || e).palette.action.hoverOpacity)
            }
          }
        }
      })), {
        props: {
          color: "inherit"
        },
        style: {
          color: "inherit",
          borderColor: "currentColor",
          "--variant-containedBg": e.vars ? e.vars.palette.Button.inheritContainedBg : t,
          "@media (hover: hover)": {
            "&:hover": {
              "--variant-containedBg": e.vars ? e.vars.palette.Button.inheritContainedHoverBg : n,
              "--variant-textBg": e.alpha((e.vars || e).palette.text.primary, (e.vars || e).palette.action.hoverOpacity),
              "--variant-outlinedBg": e.alpha((e.vars || e).palette.text.primary, (e.vars || e).palette.action.hoverOpacity)
            }
          }
        }
      }, {
        props: {
          size: "small",
          variant: "text"
        },
        style: {
          padding: "4px 5px",
          fontSize: e.typography.pxToRem(13)
        }
      }, {
        props: {
          size: "large",
          variant: "text"
        },
        style: {
          padding: "8px 11px",
          fontSize: e.typography.pxToRem(15)
        }
      }, {
        props: {
          size: "small",
          variant: "outlined"
        },
        style: {
          padding: "3px 9px",
          fontSize: e.typography.pxToRem(13)
        }
      }, {
        props: {
          size: "large",
          variant: "outlined"
        },
        style: {
          padding: "7px 21px",
          fontSize: e.typography.pxToRem(15)
        }
      }, {
        props: {
          size: "small",
          variant: "contained"
        },
        style: {
          padding: "4px 10px",
          fontSize: e.typography.pxToRem(13)
        }
      }, {
        props: {
          size: "large",
          variant: "contained"
        },
        style: {
          padding: "8px 22px",
          fontSize: e.typography.pxToRem(15)
        }
      }, {
        props: {
          disableElevation: !0
        },
        style: {
          boxShadow: "none",
          "&:hover": {
            boxShadow: "none"
          },
          [`&.${Wl.focusVisible}`]: {
            boxShadow: "none"
          },
          "&:active": {
            boxShadow: "none"
          },
          [`&.${Wl.disabled}`]: {
            boxShadow: "none"
          }
        }
      }, {
        props: {
          fullWidth: !0
        },
        style: {
          width: "100%"
        }
      }, {
        props: {
          loadingPosition: "center"
        },
        style: {
          transition: e.transitions.create(["background-color", "box-shadow", "border-color"], {
            duration: e.transitions.duration.short
          }),
          [`&.${Wl.loading}`]: {
            color: "transparent"
          }
        }
      }]
    };
  })), rPe = Re("span", {
    name: "MuiButton",
    slot: "StartIcon",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.startIcon, n.loading && t.startIconLoadingStart, t[`iconSize${Ie(n.size)}`]];
    }
  })(({
    theme: e
  }) => ({
    display: "inherit",
    marginRight: 8,
    marginLeft: -4,
    variants: [{
      props: {
        size: "small"
      },
      style: {
        marginLeft: -2
      }
    }, {
      props: {
        loadingPosition: "start",
        loading: !0
      },
      style: {
        transition: e.transitions.create(["opacity"], {
          duration: e.transitions.duration.short
        }),
        opacity: 0
      }
    }, {
      props: {
        loadingPosition: "start",
        loading: !0,
        fullWidth: !0
      },
      style: {
        marginRight: -8
      }
    }, ...cH]
  })), oPe = Re("span", {
    name: "MuiButton",
    slot: "EndIcon",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.endIcon, n.loading && t.endIconLoadingEnd, t[`iconSize${Ie(n.size)}`]];
    }
  })(({
    theme: e
  }) => ({
    display: "inherit",
    marginRight: -4,
    marginLeft: 8,
    variants: [{
      props: {
        size: "small"
      },
      style: {
        marginRight: -2
      }
    }, {
      props: {
        loadingPosition: "end",
        loading: !0
      },
      style: {
        transition: e.transitions.create(["opacity"], {
          duration: e.transitions.duration.short
        }),
        opacity: 0
      }
    }, {
      props: {
        loadingPosition: "end",
        loading: !0,
        fullWidth: !0
      },
      style: {
        marginLeft: -8
      }
    }, ...cH]
  })), iPe = Re("span", {
    name: "MuiButton",
    slot: "LoadingIndicator"
  })(({
    theme: e
  }) => ({
    display: "none",
    position: "absolute",
    visibility: "visible",
    variants: [{
      props: {
        loading: !0
      },
      style: {
        display: "flex"
      }
    }, {
      props: {
        loadingPosition: "start"
      },
      style: {
        left: 14
      }
    }, {
      props: {
        loadingPosition: "start",
        size: "small"
      },
      style: {
        left: 10
      }
    }, {
      props: {
        variant: "text",
        loadingPosition: "start"
      },
      style: {
        left: 6
      }
    }, {
      props: {
        loadingPosition: "center"
      },
      style: {
        left: "50%",
        transform: "translate(-50%)",
        color: (e.vars || e).palette.action.disabled
      }
    }, {
      props: {
        loadingPosition: "end"
      },
      style: {
        right: 14
      }
    }, {
      props: {
        loadingPosition: "end",
        size: "small"
      },
      style: {
        right: 10
      }
    }, {
      props: {
        variant: "text",
        loadingPosition: "end"
      },
      style: {
        right: 6
      }
    }, {
      props: {
        loadingPosition: "start",
        fullWidth: !0
      },
      style: {
        position: "relative",
        left: -10
      }
    }, {
      props: {
        loadingPosition: "end",
        fullWidth: !0
      },
      style: {
        position: "relative",
        right: -10
      }
    }]
  })), L3 = Re("span", {
    name: "MuiButton",
    slot: "LoadingIconPlaceholder"
  })({
    display: "inline-block",
    width: "1em",
    height: "1em"
  }), aPe = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = T.useContext(JNe), o = T.useContext(ePe), i = Yp(r, t), a = ut({
      props: i,
      name: "MuiButton"
    }), {
      children: s,
      color: c = "primary",
      component: u = "button",
      className: d,
      disabled: p = !1,
      disableElevation: m = !1,
      disableFocusRipple: g = !1,
      endIcon: y,
      focusVisibleClassName: b,
      fullWidth: v = !1,
      id: x,
      loading: E = null,
      loadingIndicator: _,
      loadingPosition: C = "center",
      size: k = "medium",
      startIcon: A,
      type: O,
      variant: P = "text",
      ...I
    } = a, $ = $f(x), L = _ ?? /* @__PURE__ */ S.jsx(XV, {
      "aria-labelledby": $,
      color: "inherit",
      size: 16
    }), N = {
      ...a,
      color: c,
      component: u,
      disabled: p,
      disableElevation: m,
      disableFocusRipple: g,
      fullWidth: v,
      loading: E,
      loadingIndicator: L,
      loadingPosition: C,
      size: k,
      type: O,
      variant: P
    }, U = tPe(N), j = (A || E && C === "start") && /* @__PURE__ */ S.jsx(rPe, {
      className: U.startIcon,
      ownerState: N,
      children: A || /* @__PURE__ */ S.jsx(L3, {
        className: U.loadingIconPlaceholder,
        ownerState: N
      })
    }), V = (y || E && C === "end") && /* @__PURE__ */ S.jsx(oPe, {
      className: U.endIcon,
      ownerState: N,
      children: y || /* @__PURE__ */ S.jsx(L3, {
        className: U.loadingIconPlaceholder,
        ownerState: N
      })
    }), F = o || "", K = typeof E == "boolean" ? (
      // use plain HTML span to minimize the runtime overhead
      /* @__PURE__ */ S.jsx("span", {
        className: U.loadingWrapper,
        style: {
          display: "contents"
        },
        children: E && /* @__PURE__ */ S.jsx(iPe, {
          className: U.loadingIndicator,
          ownerState: N,
          children: L
        })
      })
    ) : null;
    return /* @__PURE__ */ S.jsxs(nPe, {
      ownerState: N,
      className: $e(r.className, U.root, d, F),
      component: u,
      disabled: p || E,
      focusRipple: !g,
      focusVisibleClassName: $e(U.focusVisible, b),
      ref: n,
      type: O,
      id: E ? $ : x,
      ...I,
      classes: U,
      children: [j, C !== "end" && K, s, C === "end" && K, V]
    });
  });
  function sPe({ uiSchema: e }) {
    const { submitText: t, norender: n, props: r = {} } = mV(e);
    return n ? null : S.jsx(pl, { marginTop: 3, children: S.jsx(aPe, { type: "submit", variant: "contained", color: "primary", ...r, children: t }) });
  }
  function lPe(e) {
    return ot("MuiDivider", e);
  }
  const z3 = nt("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]), cPe = (e) => {
    const {
      absolute: t,
      children: n,
      classes: r,
      flexItem: o,
      light: i,
      orientation: a,
      textAlign: s,
      variant: c
    } = e;
    return rt({
      root: ["root", t && "absolute", c, i && "light", a === "vertical" && "vertical", o && "flexItem", n && "withChildren", n && a === "vertical" && "withChildrenVertical", s === "right" && a !== "vertical" && "textAlignRight", s === "left" && a !== "vertical" && "textAlignLeft"],
      wrapper: ["wrapper", a === "vertical" && "wrapperVertical"]
    }, lPe, r);
  }, uPe = Re("div", {
    name: "MuiDivider",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.absolute && t.absolute, t[n.variant], n.light && t.light, n.orientation === "vertical" && t.vertical, n.flexItem && t.flexItem, n.children && t.withChildren, n.children && n.orientation === "vertical" && t.withChildrenVertical, n.textAlign === "right" && n.orientation !== "vertical" && t.textAlignRight, n.textAlign === "left" && n.orientation !== "vertical" && t.textAlignLeft];
    }
  })(st(({
    theme: e
  }) => ({
    margin: 0,
    // Reset browser default style.
    flexShrink: 0,
    borderWidth: 0,
    borderStyle: "solid",
    borderColor: (e.vars || e).palette.divider,
    borderBottomWidth: "thin",
    variants: [{
      props: {
        absolute: !0
      },
      style: {
        position: "absolute",
        bottom: 0,
        left: 0,
        width: "100%"
      }
    }, {
      props: {
        light: !0
      },
      style: {
        borderColor: e.alpha((e.vars || e).palette.divider, 0.08)
      }
    }, {
      props: {
        variant: "inset"
      },
      style: {
        marginLeft: 72
      }
    }, {
      props: {
        variant: "middle",
        orientation: "horizontal"
      },
      style: {
        marginLeft: e.spacing(2),
        marginRight: e.spacing(2)
      }
    }, {
      props: {
        variant: "middle",
        orientation: "vertical"
      },
      style: {
        marginTop: e.spacing(1),
        marginBottom: e.spacing(1)
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        height: "100%",
        borderBottomWidth: 0,
        borderRightWidth: "thin"
      }
    }, {
      props: {
        flexItem: !0
      },
      style: {
        alignSelf: "stretch",
        height: "auto"
      }
    }, {
      props: ({
        ownerState: t
      }) => !!t.children,
      style: {
        display: "flex",
        textAlign: "center",
        border: 0,
        borderTopStyle: "solid",
        borderLeftStyle: "solid",
        "&::before, &::after": {
          content: '""',
          alignSelf: "center"
        }
      }
    }, {
      props: ({
        ownerState: t
      }) => t.children && t.orientation !== "vertical",
      style: {
        "&::before, &::after": {
          width: "100%",
          borderTop: `thin solid ${(e.vars || e).palette.divider}`,
          borderTopStyle: "inherit"
        }
      }
    }, {
      props: ({
        ownerState: t
      }) => t.orientation === "vertical" && t.children,
      style: {
        flexDirection: "column",
        "&::before, &::after": {
          height: "100%",
          borderLeft: `thin solid ${(e.vars || e).palette.divider}`,
          borderLeftStyle: "inherit"
        }
      }
    }, {
      props: ({
        ownerState: t
      }) => t.textAlign === "right" && t.orientation !== "vertical",
      style: {
        "&::before": {
          width: "90%"
        },
        "&::after": {
          width: "10%"
        }
      }
    }, {
      props: ({
        ownerState: t
      }) => t.textAlign === "left" && t.orientation !== "vertical",
      style: {
        "&::before": {
          width: "10%"
        },
        "&::after": {
          width: "90%"
        }
      }
    }]
  }))), fPe = Re("span", {
    name: "MuiDivider",
    slot: "Wrapper",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.wrapper, n.orientation === "vertical" && t.wrapperVertical];
    }
  })(st(({
    theme: e
  }) => ({
    display: "inline-block",
    paddingLeft: `calc(${e.spacing(1)} * 1.2)`,
    paddingRight: `calc(${e.spacing(1)} * 1.2)`,
    whiteSpace: "nowrap",
    variants: [{
      props: {
        orientation: "vertical"
      },
      style: {
        paddingTop: `calc(${e.spacing(1)} * 1.2)`,
        paddingBottom: `calc(${e.spacing(1)} * 1.2)`
      }
    }]
  }))), UC = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiDivider"
    }), {
      absolute: o = !1,
      children: i,
      className: a,
      orientation: s = "horizontal",
      component: c = i || s === "vertical" ? "div" : "hr",
      flexItem: u = !1,
      light: d = !1,
      role: p = c !== "hr" ? "separator" : void 0,
      textAlign: m = "center",
      variant: g = "fullWidth",
      ...y
    } = r, b = {
      ...r,
      absolute: o,
      component: c,
      flexItem: u,
      light: d,
      orientation: s,
      role: p,
      textAlign: m,
      variant: g
    }, v = cPe(b);
    return /* @__PURE__ */ S.jsx(uPe, {
      as: c,
      className: $e(v.root, a),
      role: p,
      ref: n,
      ownerState: b,
      "aria-orientation": p === "separator" && (c !== "hr" || s === "vertical") ? s : void 0,
      ...y,
      children: i ? /* @__PURE__ */ S.jsx(fPe, {
        className: v.wrapper,
        ownerState: b,
        children: i
      }) : null
    });
  });
  UC && (UC.muiSkipListHighlight = !0);
  function dPe({ id: e, title: t, optionalDataControl: n }) {
    let r = S.jsx(Fi, { variant: "h5", children: t });
    return n && (r = S.jsxs(fr, { container: !0, spacing: 0, children: [S.jsx(fr, { size: "grow", children: r }), S.jsx(fr, { justifyContent: "flex-end", children: n })] })), S.jsxs(pl, { id: e, mb: 1, mt: 1, children: [r, S.jsx(UC, {})] });
  }
  function pPe(e) {
    const { children: t, classNames: n, style: r, disabled: o, id: i, label: a, displayLabel: s, onKeyRenameBlur: c, onRemoveProperty: u, readonly: d, required: p, schema: m, uiSchema: g, registry: y } = e, { templates: b, translateString: v } = y, { RemoveButton: x } = b.ButtonTemplates, E = v(bt.KeyLabel, [a]), _ = Ba in m, C = {
      flex: 1,
      paddingLeft: 6,
      paddingRight: 6,
      fontWeight: "bold"
    };
    return _ ? S.jsxs(fr, { container: !0, alignItems: "flex-start", spacing: 2, className: n, style: r, children: [S.jsx(fr, { size: 5.5, children: S.jsx(WA, { fullWidth: !0, required: p, label: s ? E : void 0, defaultValue: a, disabled: o || d, id: `${i}-key`, name: `${i}-key`, onBlur: d ? void 0 : c, type: "text" }) }), S.jsx(fr, { size: 5.5, children: t }), S.jsx(fr, { sx: { mt: 1.5 }, children: S.jsx(x, { id: ji(i, "remove"), className: "rjsf-object-property-remove", iconType: "default", style: C, disabled: o || d, onClick: u, uiSchema: g, registry: y }) })] }, `${i}-key`) : S.jsx("div", { className: n, style: r, children: t });
  }
  function hPe() {
    return {
      ArrayFieldItemTemplate: gOe,
      ArrayFieldTemplate: yOe,
      BaseInputTemplate: dNe,
      ButtonTemplates: {
        AddButton: aOe,
        CopyButton: UNe,
        MoveDownButton: VNe,
        MoveUpButton: HNe,
        RemoveButton: lH,
        SubmitButton: sPe
      },
      DescriptionFieldTemplate: vNe,
      ErrorListTemplate: DNe,
      FieldErrorTemplate: qNe,
      FieldHelpTemplate: WNe,
      FieldTemplate: GNe,
      GridTemplate: KNe,
      MultiSchemaFieldTemplate: YNe,
      ObjectFieldTemplate: XNe,
      OptionalDataControlsTemplate: ZNe,
      TitleFieldTemplate: dPe,
      WrapIfAdditionalTemplate: pPe
    };
  }
  function mPe(e) {
    return ot("PrivateSwitchBase", e);
  }
  nt("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
  const gPe = (e) => {
    const {
      classes: t,
      checked: n,
      disabled: r,
      edge: o
    } = e, i = {
      root: ["root", n && "checked", r && "disabled", o && `edge${Ie(o)}`],
      input: ["input"]
    };
    return rt(i, mPe, t);
  }, yPe = Re(Lh, {
    name: "MuiSwitchBase"
  })({
    padding: 9,
    borderRadius: "50%",
    variants: [{
      props: {
        edge: "start",
        size: "small"
      },
      style: {
        marginLeft: -3
      }
    }, {
      props: ({
        edge: e,
        ownerState: t
      }) => e === "start" && t.size !== "small",
      style: {
        marginLeft: -12
      }
    }, {
      props: {
        edge: "end",
        size: "small"
      },
      style: {
        marginRight: -3
      }
    }, {
      props: ({
        edge: e,
        ownerState: t
      }) => e === "end" && t.size !== "small",
      style: {
        marginRight: -12
      }
    }]
  }), vPe = Re("input", {
    name: "MuiSwitchBase",
    shouldForwardProp: Sr
  })({
    cursor: "inherit",
    position: "absolute",
    opacity: 0,
    width: "100%",
    height: "100%",
    top: 0,
    left: 0,
    margin: 0,
    padding: 0,
    zIndex: 1
  }), uH = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const {
      autoFocus: r,
      checked: o,
      checkedIcon: i,
      defaultChecked: a,
      disabled: s,
      disableFocusRipple: c = !1,
      edge: u = !1,
      icon: d,
      id: p,
      inputProps: m,
      inputRef: g,
      name: y,
      onBlur: b,
      onChange: v,
      onFocus: x,
      readOnly: E,
      required: _ = !1,
      tabIndex: C,
      type: k,
      value: A,
      slots: O = {},
      slotProps: P = {},
      ...I
    } = t, [$, L] = Eh({
      controlled: o,
      default: !!a,
      name: "SwitchBase",
      state: "checked"
    }), N = ra(), U = (X) => {
      x && x(X), N && N.onFocus && N.onFocus(X);
    }, j = (X) => {
      b && b(X), N && N.onBlur && N.onBlur(X);
    }, V = (X) => {
      if (X.nativeEvent.defaultPrevented)
        return;
      const Q = X.target.checked;
      L(Q), v && v(X, Q);
    };
    let F = s;
    N && typeof F > "u" && (F = N.disabled);
    const K = k === "checkbox" || k === "radio", W = {
      ...t,
      checked: $,
      disabled: F,
      disableFocusRipple: c,
      edge: u
    }, Y = gPe(W), B = {
      slots: O,
      slotProps: {
        input: m,
        ...P
      }
    }, [D, G] = ln("root", {
      ref: n,
      elementType: yPe,
      className: Y.root,
      shouldForwardComponentProp: !0,
      externalForwardedProps: {
        ...B,
        component: "span",
        ...I
      },
      getSlotProps: (X) => ({
        ...X,
        onFocus: (Q) => {
          X.onFocus?.(Q), U(Q);
        },
        onBlur: (Q) => {
          X.onBlur?.(Q), j(Q);
        }
      }),
      ownerState: W,
      additionalProps: {
        centerRipple: !0,
        focusRipple: !c,
        disabled: F,
        role: void 0,
        tabIndex: null
      }
    }), [z, H] = ln("input", {
      ref: g,
      elementType: vPe,
      className: Y.input,
      externalForwardedProps: B,
      getSlotProps: (X) => ({
        ...X,
        onChange: (Q) => {
          X.onChange?.(Q), V(Q);
        }
      }),
      ownerState: W,
      additionalProps: {
        autoFocus: r,
        checked: o,
        defaultChecked: a,
        disabled: F,
        id: K ? p : void 0,
        name: y,
        readOnly: E,
        required: _,
        tabIndex: C,
        type: k,
        ...k === "checkbox" && A === void 0 ? {} : {
          value: A
        }
      }
    });
    return /* @__PURE__ */ S.jsxs(D, {
      ...G,
      children: [/* @__PURE__ */ S.jsx(z, {
        ...H
      }), $ ? i : d]
    });
  }), bPe = po(/* @__PURE__ */ S.jsx("path", {
    d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
  })), xPe = po(/* @__PURE__ */ S.jsx("path", {
    d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
  })), wPe = po(/* @__PURE__ */ S.jsx("path", {
    d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"
  }));
  function SPe(e) {
    return ot("MuiCheckbox", e);
  }
  const X_ = nt("MuiCheckbox", ["root", "checked", "disabled", "indeterminate", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium"]), _Pe = (e) => {
    const {
      classes: t,
      indeterminate: n,
      color: r,
      size: o
    } = e, i = {
      root: ["root", n && "indeterminate", `color${Ie(r)}`, `size${Ie(o)}`]
    }, a = rt(i, SPe, t);
    return {
      ...t,
      // forward the disabled and checked classes to the SwitchBase
      ...a
    };
  }, EPe = Re(uH, {
    shouldForwardProp: (e) => Sr(e) || e === "classes",
    name: "MuiCheckbox",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.indeterminate && t.indeterminate, t[`size${Ie(n.size)}`], n.color !== "default" && t[`color${Ie(n.color)}`]];
    }
  })(st(({
    theme: e
  }) => ({
    color: (e.vars || e).palette.text.secondary,
    variants: [{
      props: {
        color: "default",
        disableRipple: !1
      },
      style: {
        "&:hover": {
          backgroundColor: e.alpha((e.vars || e).palette.action.active, (e.vars || e).palette.action.hoverOpacity)
        }
      }
    }, ...Object.entries(e.palette).filter(wr()).map(([t]) => ({
      props: {
        color: t,
        disableRipple: !1
      },
      style: {
        "&:hover": {
          backgroundColor: e.alpha((e.vars || e).palette[t].main, (e.vars || e).palette.action.hoverOpacity)
        }
      }
    })), ...Object.entries(e.palette).filter(wr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        [`&.${X_.checked}, &.${X_.indeterminate}`]: {
          color: (e.vars || e).palette[t].main
        },
        [`&.${X_.disabled}`]: {
          color: (e.vars || e).palette.action.disabled
        }
      }
    })), {
      // Should be last to override other colors
      props: {
        disableRipple: !1
      },
      style: {
        // Reset on touch devices, it doesn't add specificity
        "&:hover": {
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }
      }
    }]
  }))), CPe = /* @__PURE__ */ S.jsx(xPe, {}), kPe = /* @__PURE__ */ S.jsx(bPe, {}), TPe = /* @__PURE__ */ S.jsx(wPe, {}), fH = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiCheckbox"
    }), {
      checkedIcon: o = CPe,
      color: i = "primary",
      icon: a = kPe,
      indeterminate: s = !1,
      indeterminateIcon: c = TPe,
      inputProps: u,
      size: d = "medium",
      disableRipple: p = !1,
      className: m,
      slots: g = {},
      slotProps: y = {},
      ...b
    } = r, v = s ? c : a, x = s ? c : o, E = {
      ...r,
      disableRipple: p,
      color: i,
      indeterminate: s,
      size: d
    }, _ = _Pe(E), C = y.input ?? u, [k, A] = ln("root", {
      ref: n,
      elementType: EPe,
      className: $e(_.root, m),
      shouldForwardComponentProp: !0,
      externalForwardedProps: {
        slots: g,
        slotProps: y,
        ...b
      },
      ownerState: E,
      additionalProps: {
        type: "checkbox",
        icon: /* @__PURE__ */ T.cloneElement(v, {
          fontSize: v.props.fontSize ?? d
        }),
        checkedIcon: /* @__PURE__ */ T.cloneElement(x, {
          fontSize: x.props.fontSize ?? d
        }),
        disableRipple: p,
        slots: g,
        slotProps: {
          input: KV(typeof C == "function" ? C(E) : C, {
            "data-indeterminate": s
          })
        }
      }
    });
    return /* @__PURE__ */ S.jsx(k, {
      ...A,
      classes: _
    });
  });
  function APe(e) {
    return ot("MuiFormControlLabel", e);
  }
  const Ep = nt("MuiFormControlLabel", ["root", "labelPlacementStart", "labelPlacementTop", "labelPlacementBottom", "disabled", "label", "error", "required", "asterisk"]), RPe = (e) => {
    const {
      classes: t,
      disabled: n,
      labelPlacement: r,
      error: o,
      required: i
    } = e, a = {
      root: ["root", n && "disabled", `labelPlacement${Ie(r)}`, o && "error", i && "required"],
      label: ["label", n && "disabled"],
      asterisk: ["asterisk", o && "error"]
    };
    return rt(a, APe, t);
  }, OPe = Re("label", {
    name: "MuiFormControlLabel",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [{
        [`& .${Ep.label}`]: t.label
      }, t.root, t[`labelPlacement${Ie(n.labelPlacement)}`]];
    }
  })(st(({
    theme: e
  }) => ({
    display: "inline-flex",
    alignItems: "center",
    cursor: "pointer",
    // For correct alignment with the text.
    verticalAlign: "middle",
    WebkitTapHighlightColor: "transparent",
    marginLeft: -11,
    marginRight: 16,
    // used for row presentation of radio/checkbox
    [`&.${Ep.disabled}`]: {
      cursor: "default"
    },
    [`& .${Ep.label}`]: {
      [`&.${Ep.disabled}`]: {
        color: (e.vars || e).palette.text.disabled
      }
    },
    variants: [{
      props: {
        labelPlacement: "start"
      },
      style: {
        flexDirection: "row-reverse",
        marginRight: -11
      }
    }, {
      props: {
        labelPlacement: "top"
      },
      style: {
        flexDirection: "column-reverse"
      }
    }, {
      props: {
        labelPlacement: "bottom"
      },
      style: {
        flexDirection: "column"
      }
    }, {
      props: ({
        labelPlacement: t
      }) => t === "start" || t === "top" || t === "bottom",
      style: {
        marginLeft: 16
        // used for row presentation of radio/checkbox
      }
    }]
  }))), MPe = Re("span", {
    name: "MuiFormControlLabel",
    slot: "Asterisk"
  })(st(({
    theme: e
  }) => ({
    [`&.${Ep.error}`]: {
      color: (e.vars || e).palette.error.main
    }
  }))), GA = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiFormControlLabel"
    }), {
      checked: o,
      className: i,
      componentsProps: a = {},
      control: s,
      disabled: c,
      disableTypography: u,
      inputRef: d,
      label: p,
      labelPlacement: m = "end",
      name: g,
      onChange: y,
      required: b,
      slots: v = {},
      slotProps: x = {},
      value: E,
      ..._
    } = r, C = ra(), k = c ?? s.props.disabled ?? C?.disabled, A = b ?? s.props.required, O = {
      disabled: k,
      required: A
    };
    ["checked", "name", "onChange", "value", "inputRef"].forEach((V) => {
      typeof s.props[V] > "u" && typeof r[V] < "u" && (O[V] = r[V]);
    });
    const P = yl({
      props: r,
      muiFormControl: C,
      states: ["error"]
    }), I = {
      ...r,
      disabled: k,
      labelPlacement: m,
      required: A,
      error: P.error
    }, $ = RPe(I), L = {
      slots: v,
      slotProps: {
        ...a,
        ...x
      }
    }, [N, U] = ln("typography", {
      elementType: Fi,
      externalForwardedProps: L,
      ownerState: I
    });
    let j = p;
    return j != null && j.type !== Fi && !u && (j = /* @__PURE__ */ S.jsx(N, {
      component: "span",
      ...U,
      className: $e($.label, U?.className),
      children: j
    })), /* @__PURE__ */ S.jsxs(OPe, {
      className: $e($.root, i),
      ownerState: I,
      ref: n,
      ..._,
      children: [/* @__PURE__ */ T.cloneElement(s, O), A ? /* @__PURE__ */ S.jsxs("div", {
        children: [j, /* @__PURE__ */ S.jsxs(MPe, {
          ownerState: I,
          "aria-hidden": !0,
          className: $.asterisk,
          children: ["", "*"]
        })]
      }) : j]
    });
  });
  function NPe(e) {
    var t;
    const { schema: n, id: r, htmlName: o, value: i, disabled: a, readonly: s, label: c = "", hideLabel: u, autofocus: d, onChange: p, onBlur: m, onFocus: g, registry: y, options: b, uiSchema: v } = e, x = tt("DescriptionFieldTemplate", y, b), E = jp(n), _ = (O, P) => p(P), C = () => m(r, i), k = () => g(r, i), A = (t = b.description) !== null && t !== void 0 ? t : n.description;
    return S.jsxs(S.Fragment, { children: [!u && A && S.jsx(x, { id: Nc(r), description: A, schema: n, uiSchema: v, registry: y }), S.jsx(GA, { control: S.jsx(fH, { id: r, name: o || r, checked: typeof i > "u" ? !1 : !!i, required: E, disabled: a || s, autoFocus: d, onChange: _, onBlur: C, onFocus: k, "aria-describedby": go(r) }), label: Pc(c, u, !1) })] });
  }
  function PPe(e) {
    return ot("MuiFormGroup", e);
  }
  nt("MuiFormGroup", ["root", "row", "error"]);
  const IPe = (e) => {
    const {
      classes: t,
      row: n,
      error: r
    } = e;
    return rt({
      root: ["root", n && "row", r && "error"]
    }, PPe, t);
  }, $Pe = Re("div", {
    name: "MuiFormGroup",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.row && t.row];
    }
  })({
    display: "flex",
    flexDirection: "column",
    flexWrap: "wrap",
    variants: [{
      props: {
        row: !0
      },
      style: {
        flexDirection: "row"
      }
    }]
  }), dH = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiFormGroup"
    }), {
      className: o,
      row: i = !1,
      ...a
    } = r, s = ra(), c = yl({
      props: r,
      muiFormControl: s,
      states: ["error"]
    }), u = {
      ...r,
      row: i,
      error: c.error
    }, d = IPe(u);
    return /* @__PURE__ */ S.jsx($Pe, {
      className: $e(d.root, o),
      ownerState: u,
      ref: n,
      ...a
    });
  });
  function jPe({ label: e, hideLabel: t, id: n, htmlName: r, disabled: o, options: i, value: a, autofocus: s, readonly: c, required: u, onChange: d, onBlur: p, onFocus: m }) {
    const { enumOptions: g, enumDisabled: y, inline: b, emptyValue: v } = i, x = Array.isArray(a) ? a : [a], E = (k) => ({ target: { checked: A } }) => {
      d(A ? uV(k, x, g) : cV(k, x, g));
    }, _ = ({ target: k }) => p(n, Jn(k && k.value, g, v)), C = ({ target: k }) => m(n, Jn(k && k.value, g, v));
    return S.jsxs(S.Fragment, { children: [Pc(S.jsx(P1, { required: u, htmlFor: n, children: e || void 0 }), t), S.jsx(dH, { id: n, row: !!b, children: Array.isArray(g) && g.map((k, A) => {
      const O = b1(k.value, x), P = Array.isArray(y) && y.indexOf(k.value) !== -1, I = S.jsx(fH, { id: w1(n, A), name: r || n, checked: O, disabled: o || P || c, autoFocus: s && A === 0, onChange: E(A), onBlur: _, onFocus: C, "aria-describedby": go(n) });
      return S.jsx(GA, { control: I, label: k.label }, A);
    }) })] });
  }
  const DPe = po(/* @__PURE__ */ S.jsx("path", {
    d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"
  })), FPe = po(/* @__PURE__ */ S.jsx("path", {
    d: "M8.465 8.465C9.37 7.56 10.62 7 12 7C14.76 7 17 9.24 17 12C17 13.38 16.44 14.63 15.535 15.535C14.63 16.44 13.38 17 12 17C9.24 17 7 14.76 7 12C7 10.62 7.56 9.37 8.465 8.465Z"
  })), LPe = Re("span", {
    name: "MuiRadioButtonIcon",
    shouldForwardProp: Sr
  })({
    position: "relative",
    display: "flex"
  }), zPe = Re(DPe, {
    name: "MuiRadioButtonIcon"
  })({
    // Scale applied to prevent dot misalignment in Safari
    transform: "scale(1)"
  }), BPe = Re(FPe, {
    name: "MuiRadioButtonIcon"
  })(st(({
    theme: e
  }) => ({
    left: 0,
    position: "absolute",
    transform: "scale(0)",
    transition: e.transitions.create("transform", {
      easing: e.transitions.easing.easeIn,
      duration: e.transitions.duration.shortest
    }),
    variants: [{
      props: {
        checked: !0
      },
      style: {
        transform: "scale(1)",
        transition: e.transitions.create("transform", {
          easing: e.transitions.easing.easeOut,
          duration: e.transitions.duration.shortest
        })
      }
    }]
  })));
  function pH(e) {
    const {
      checked: t = !1,
      classes: n = {},
      fontSize: r
    } = e, o = {
      ...e,
      checked: t
    };
    return /* @__PURE__ */ S.jsxs(LPe, {
      className: n.root,
      ownerState: o,
      children: [/* @__PURE__ */ S.jsx(zPe, {
        fontSize: r,
        className: n.background,
        ownerState: o
      }), /* @__PURE__ */ S.jsx(BPe, {
        fontSize: r,
        className: n.dot,
        ownerState: o
      })]
    });
  }
  const hH = /* @__PURE__ */ T.createContext(void 0);
  function UPe() {
    return T.useContext(hH);
  }
  function VPe(e) {
    return ot("MuiRadio", e);
  }
  const B3 = nt("MuiRadio", ["root", "checked", "disabled", "colorPrimary", "colorSecondary", "sizeSmall"]), HPe = (e) => {
    const {
      classes: t,
      color: n,
      size: r
    } = e, o = {
      root: ["root", `color${Ie(n)}`, r !== "medium" && `size${Ie(r)}`]
    };
    return {
      ...t,
      ...rt(o, VPe, t)
    };
  }, qPe = Re(uH, {
    shouldForwardProp: (e) => Sr(e) || e === "classes",
    name: "MuiRadio",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, n.size !== "medium" && t[`size${Ie(n.size)}`], t[`color${Ie(n.color)}`]];
    }
  })(st(({
    theme: e
  }) => ({
    color: (e.vars || e).palette.text.secondary,
    [`&.${B3.disabled}`]: {
      color: (e.vars || e).palette.action.disabled
    },
    variants: [{
      props: {
        color: "default",
        disabled: !1,
        disableRipple: !1
      },
      style: {
        "&:hover": {
          backgroundColor: e.alpha((e.vars || e).palette.action.active, (e.vars || e).palette.action.hoverOpacity)
        }
      }
    }, ...Object.entries(e.palette).filter(wr()).map(([t]) => ({
      props: {
        color: t,
        disabled: !1,
        disableRipple: !1
      },
      style: {
        "&:hover": {
          backgroundColor: e.alpha((e.vars || e).palette[t].main, (e.vars || e).palette.action.hoverOpacity)
        }
      }
    })), ...Object.entries(e.palette).filter(wr()).map(([t]) => ({
      props: {
        color: t,
        disabled: !1
      },
      style: {
        [`&.${B3.checked}`]: {
          color: (e.vars || e).palette[t].main
        }
      }
    })), {
      // Should be last to override other colors
      props: {
        disableRipple: !1
      },
      style: {
        // Reset on touch devices, it doesn't add specificity
        "&:hover": {
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }
      }
    }]
  })));
  function WPe(e, t) {
    return typeof t == "object" && t !== null ? e === t : String(e) === String(t);
  }
  const GPe = /* @__PURE__ */ S.jsx(pH, {
    checked: !0
  }), KPe = /* @__PURE__ */ S.jsx(pH, {}), YPe = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiRadio"
    }), {
      checked: o,
      checkedIcon: i = GPe,
      color: a = "primary",
      icon: s = KPe,
      name: c,
      onChange: u,
      size: d = "medium",
      className: p,
      disabled: m,
      disableRipple: g = !1,
      slots: y = {},
      slotProps: b = {},
      inputProps: v,
      ...x
    } = r, E = ra();
    let _ = m;
    E && typeof _ > "u" && (_ = E.disabled), _ ?? (_ = !1);
    const C = {
      ...r,
      disabled: _,
      disableRipple: g,
      color: a,
      size: d
    }, k = HPe(C), A = UPe();
    let O = o;
    const P = DC(u, A && A.onChange);
    let I = c;
    A && (typeof O > "u" && (O = WPe(A.value, r.value)), typeof I > "u" && (I = A.name));
    const $ = b.input ?? v, [L, N] = ln("root", {
      ref: n,
      elementType: qPe,
      className: $e(k.root, p),
      shouldForwardComponentProp: !0,
      externalForwardedProps: {
        slots: y,
        slotProps: b,
        ...x
      },
      getSlotProps: (U) => ({
        ...U,
        onChange: (j, ...V) => {
          U.onChange?.(j, ...V), P(j, ...V);
        }
      }),
      ownerState: C,
      additionalProps: {
        type: "radio",
        icon: /* @__PURE__ */ T.cloneElement(s, {
          fontSize: s.props.fontSize ?? d
        }),
        checkedIcon: /* @__PURE__ */ T.cloneElement(i, {
          fontSize: i.props.fontSize ?? d
        }),
        disabled: _,
        name: I,
        checked: O,
        slots: y,
        slotProps: {
          // Do not forward `slotProps.root` again because it's already handled by the `RootSlot` in this file.
          input: typeof $ == "function" ? $(C) : $
        }
      }
    });
    return /* @__PURE__ */ S.jsx(L, {
      ...N,
      classes: k
    });
  });
  function XPe(e) {
    return ot("MuiRadioGroup", e);
  }
  nt("MuiRadioGroup", ["root", "row", "error"]);
  const ZPe = (e) => {
    const {
      classes: t,
      row: n,
      error: r
    } = e;
    return rt({
      root: ["root", n && "row", r && "error"]
    }, XPe, t);
  }, QPe = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const {
      // private
      // eslint-disable-next-line react/prop-types
      actions: r,
      children: o,
      className: i,
      defaultValue: a,
      name: s,
      onChange: c,
      value: u,
      ...d
    } = t, p = T.useRef(null), m = ZPe(t), [g, y] = Eh({
      controlled: u,
      default: a,
      name: "RadioGroup"
    });
    T.useImperativeHandle(r, () => ({
      focus: () => {
        let E = p.current.querySelector("input:not(:disabled):checked");
        E || (E = p.current.querySelector("input:not(:disabled)")), E && E.focus();
      }
    }), []);
    const b = er(n, p), v = $f(s), x = T.useMemo(() => ({
      name: v,
      onChange(E) {
        y(E.target.value), c && c(E, E.target.value);
      },
      value: g
    }), [v, c, y, g]);
    return /* @__PURE__ */ S.jsx(hH.Provider, {
      value: x,
      children: /* @__PURE__ */ S.jsx(dH, {
        role: "radiogroup",
        ref: b,
        className: $e(m.root, i),
        ...d,
        children: o
      })
    });
  });
  function JPe({ id: e, htmlName: t, options: n, value: r, required: o, disabled: i, readonly: a, label: s, hideLabel: c, onChange: u, onBlur: d, onFocus: p }) {
    var m;
    const { enumOptions: g, enumDisabled: y, emptyValue: b } = n, v = (k, A) => u(Jn(A, g, b)), x = ({ target: k }) => d(e, Jn(k && k.value, g, b)), E = ({ target: k }) => p(e, Jn(k && k.value, g, b)), _ = n ? n.inline : !1, C = (m = bA(r, g)) !== null && m !== void 0 ? m : null;
    return S.jsxs(S.Fragment, { children: [Pc(S.jsx(P1, { required: o, htmlFor: e, children: s || void 0 }), c), S.jsx(QPe, { id: e, name: t || e, value: C, row: _, onChange: v, onBlur: x, onFocus: E, "aria-describedby": go(e), children: Array.isArray(g) && g.map((k, A) => {
      const O = Array.isArray(y) && y.indexOf(k.value) !== -1;
      return S.jsx(GA, { control: S.jsx(YPe, { name: t || e, id: w1(e, A), color: "primary" }), label: k.label, value: String(A), disabled: i || O || a }, A);
    }) })] });
  }
  const e2e = {
    border: 0,
    clip: "rect(0 0 0 0)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: 0,
    position: "absolute",
    whiteSpace: "nowrap",
    width: "1px"
  };
  function t2e(e, t, n = (r, o) => r === o) {
    return e.length === t.length && e.every((r, o) => n(r, t[o]));
  }
  const n2e = 2;
  function Du(e, t, n, r, o) {
    return n === 1 ? Math.min(e + t, o) : Math.max(e - t, r);
  }
  function mH(e, t) {
    return e - t;
  }
  function U3(e, t) {
    const {
      index: n
    } = e.reduce((r, o, i) => {
      const a = Math.abs(t - o);
      return r === null || a < r.distance || a === r.distance ? {
        distance: a,
        index: i
      } : r;
    }, null) ?? {};
    return n;
  }
  function mv(e, t) {
    if (t.current !== void 0 && e.changedTouches) {
      const n = e;
      for (let r = 0; r < n.changedTouches.length; r += 1) {
        const o = n.changedTouches[r];
        if (o.identifier === t.current)
          return {
            x: o.clientX,
            y: o.clientY
          };
      }
      return !1;
    }
    return {
      x: e.clientX,
      y: e.clientY
    };
  }
  function H0(e, t, n) {
    return (e - t) * 100 / (n - t);
  }
  function r2e(e, t, n) {
    return (n - t) * e + t;
  }
  function o2e(e) {
    if (Math.abs(e) < 1) {
      const n = e.toExponential().split("e-"), r = n[0].split(".")[1];
      return (r ? r.length : 0) + parseInt(n[1], 10);
    }
    const t = e.toString().split(".")[1];
    return t ? t.length : 0;
  }
  function i2e(e, t, n) {
    const r = Math.round((e - n) / t) * t + n;
    return Number(r.toFixed(o2e(t)));
  }
  function V3({
    values: e,
    newValue: t,
    index: n
  }) {
    const r = e.slice();
    return r[n] = t, r.sort(mH);
  }
  function gv({
    sliderRef: e,
    activeIndex: t,
    setActive: n
  }) {
    const r = Ar(e.current);
    (!e.current?.contains(r.activeElement) || Number(r?.activeElement?.getAttribute("data-index")) !== t) && e.current?.querySelector(`[type="range"][data-index="${t}"]`).focus(), n && n(t);
  }
  function yv(e, t) {
    return typeof e == "number" && typeof t == "number" ? e === t : typeof e == "object" && typeof t == "object" ? t2e(e, t) : !1;
  }
  const a2e = {
    horizontal: {
      offset: (e) => ({
        left: `${e}%`
      }),
      leap: (e) => ({
        width: `${e}%`
      })
    },
    "horizontal-reverse": {
      offset: (e) => ({
        right: `${e}%`
      }),
      leap: (e) => ({
        width: `${e}%`
      })
    },
    vertical: {
      offset: (e) => ({
        bottom: `${e}%`
      }),
      leap: (e) => ({
        height: `${e}%`
      })
    }
  }, s2e = (e) => e;
  let vv;
  function H3() {
    return vv === void 0 && (typeof CSS < "u" && typeof CSS.supports == "function" ? vv = CSS.supports("touch-action", "none") : vv = !0), vv;
  }
  function l2e(e) {
    const {
      "aria-labelledby": t,
      defaultValue: n,
      disabled: r = !1,
      disableSwap: o = !1,
      isRtl: i = !1,
      marks: a = !1,
      max: s = 100,
      min: c = 0,
      name: u,
      onChange: d,
      onChangeCommitted: p,
      orientation: m = "horizontal",
      rootRef: g,
      scale: y = s2e,
      step: b = 1,
      shiftStep: v = 10,
      tabIndex: x,
      value: E
    } = e, _ = T.useRef(void 0), [C, k] = T.useState(-1), [A, O] = T.useState(-1), [P, I] = T.useState(!1), $ = T.useRef(0), L = T.useRef(null), [N, U] = Eh({
      controlled: E,
      default: n ?? c,
      name: "Slider"
    }), j = d && ((Ae, oe, fe) => {
      const _e = Ae.nativeEvent || Ae, Ce = new _e.constructor(_e.type, _e);
      Object.defineProperty(Ce, "target", {
        writable: !0,
        value: {
          value: oe,
          name: u
        }
      }), L.current = oe, d(Ce, oe, fe);
    }), V = Array.isArray(N);
    let F = V ? N.slice().sort(mH) : [N];
    F = F.map((Ae) => Ae == null ? c : zu(Ae, c, s));
    const K = a === !0 && b !== null ? [...Array(Math.floor((s - c) / b) + 1)].map((Ae, oe) => ({
      value: c + b * oe
    })) : a || [], W = K.map((Ae) => Ae.value), [Y, B] = T.useState(-1), D = T.useRef(null), G = er(g, D), z = (Ae) => (oe) => {
      const fe = Number(oe.currentTarget.getAttribute("data-index"));
      t0(oe.target) && B(fe), O(fe), Ae?.onFocus?.(oe);
    }, H = (Ae) => (oe) => {
      t0(oe.target) || B(-1), O(-1), Ae?.onBlur?.(oe);
    }, X = (Ae, oe) => {
      const fe = Number(Ae.currentTarget.getAttribute("data-index")), _e = F[fe], Ce = W.indexOf(_e);
      let Oe = oe;
      if (K && b == null) {
        const He = W[W.length - 1];
        Oe >= He ? Oe = He : Oe <= W[0] ? Oe = W[0] : Oe = Oe < _e ? W[Ce - 1] : W[Ce + 1];
      }
      if (Oe = zu(Oe, c, s), V) {
        o && (Oe = zu(Oe, F[fe - 1] || -1 / 0, F[fe + 1] || 1 / 0));
        const He = Oe;
        Oe = V3({
          values: F,
          newValue: Oe,
          index: fe
        });
        let Ot = fe;
        o || (Ot = Oe.indexOf(He)), gv({
          sliderRef: D,
          activeIndex: Ot
        });
      }
      U(Oe), B(fe), j && !yv(Oe, N) && j(Ae, Oe, fe), p && p(Ae, L.current ?? Oe);
    }, Q = (Ae) => (oe) => {
      if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "PageUp", "PageDown", "Home", "End"].includes(oe.key)) {
        oe.preventDefault();
        const fe = Number(oe.currentTarget.getAttribute("data-index")), _e = F[fe];
        let Ce = null;
        if (b != null) {
          const Oe = oe.shiftKey ? v : b;
          switch (oe.key) {
            case "ArrowUp":
              Ce = Du(_e, Oe, 1, c, s);
              break;
            case "ArrowRight":
              Ce = Du(_e, Oe, i ? -1 : 1, c, s);
              break;
            case "ArrowDown":
              Ce = Du(_e, Oe, -1, c, s);
              break;
            case "ArrowLeft":
              Ce = Du(_e, Oe, i ? 1 : -1, c, s);
              break;
            case "PageUp":
              Ce = Du(_e, v, 1, c, s);
              break;
            case "PageDown":
              Ce = Du(_e, v, -1, c, s);
              break;
            case "Home":
              Ce = c;
              break;
            case "End":
              Ce = s;
              break;
          }
        } else if (K) {
          const Oe = W[W.length - 1], He = W.indexOf(_e), Ot = [i ? "ArrowRight" : "ArrowLeft", "ArrowDown", "PageDown", "Home"], it = [i ? "ArrowLeft" : "ArrowRight", "ArrowUp", "PageUp", "End"];
          Ot.includes(oe.key) ? He === 0 ? Ce = W[0] : Ce = W[He - 1] : it.includes(oe.key) && (He === W.length - 1 ? Ce = Oe : Ce = W[He + 1]);
        }
        Ce != null && X(oe, Ce);
      }
      Ae?.onKeyDown?.(oe);
    };
    ei(() => {
      r && D.current.contains(document.activeElement) && document.activeElement?.blur();
    }, [r]), r && C !== -1 && k(-1), r && Y !== -1 && B(-1);
    const ne = (Ae) => (oe) => {
      Ae.onChange?.(oe), X(oe, oe.target.valueAsNumber);
    }, te = T.useRef(void 0);
    let se = m;
    i && m === "horizontal" && (se += "-reverse");
    const ue = ({
      finger: Ae,
      move: oe = !1
    }) => {
      const {
        current: fe
      } = D, {
        width: _e,
        height: Ce,
        bottom: Oe,
        left: He
      } = fe.getBoundingClientRect();
      let Ot;
      se.startsWith("vertical") ? Ot = (Oe - Ae.y) / Ce : Ot = (Ae.x - He) / _e, se.includes("-reverse") && (Ot = 1 - Ot);
      let it;
      if (it = r2e(Ot, c, s), b)
        it = i2e(it, b, c);
      else {
        const xn = U3(W, it);
        it = W[xn];
      }
      it = zu(it, c, s);
      let Et = 0;
      if (V) {
        oe ? Et = te.current : Et = U3(F, it), o && (it = zu(it, F[Et - 1] || -1 / 0, F[Et + 1] || 1 / 0));
        const xn = it;
        it = V3({
          values: F,
          newValue: it,
          index: Et
        }), o && oe || (Et = it.indexOf(xn), te.current = Et);
      }
      return {
        newValue: it,
        activeIndex: Et
      };
    }, J = Bi((Ae) => {
      const oe = mv(Ae, _);
      if (!oe)
        return;
      if ($.current += 1, Ae.type === "mousemove" && Ae.buttons === 0) {
        ee(Ae);
        return;
      }
      const {
        newValue: fe,
        activeIndex: _e
      } = ue({
        finger: oe,
        move: !0
      });
      gv({
        sliderRef: D,
        activeIndex: _e,
        setActive: k
      }), U(fe), !P && $.current > n2e && I(!0), j && !yv(fe, N) && j(Ae, fe, _e);
    }), ee = Bi((Ae) => {
      const oe = mv(Ae, _);
      if (I(!1), !oe)
        return;
      const {
        newValue: fe
      } = ue({
        finger: oe,
        move: !0
      });
      k(-1), Ae.type === "touchend" && O(-1), p && p(Ae, L.current ?? fe), _.current = void 0, le();
    }), ie = Bi((Ae) => {
      if (r)
        return;
      H3() || Ae.preventDefault();
      const oe = Ae.changedTouches[0];
      oe != null && (_.current = oe.identifier);
      const fe = mv(Ae, _);
      if (fe !== !1) {
        const {
          newValue: Ce,
          activeIndex: Oe
        } = ue({
          finger: fe
        });
        gv({
          sliderRef: D,
          activeIndex: Oe,
          setActive: k
        }), U(Ce), j && !yv(Ce, N) && j(Ae, Ce, Oe);
      }
      $.current = 0;
      const _e = Ar(D.current);
      _e.addEventListener("touchmove", J, {
        passive: !0
      }), _e.addEventListener("touchend", ee, {
        passive: !0
      });
    }), le = T.useCallback(() => {
      const Ae = Ar(D.current);
      Ae.removeEventListener("mousemove", J), Ae.removeEventListener("mouseup", ee), Ae.removeEventListener("touchmove", J), Ae.removeEventListener("touchend", ee);
    }, [ee, J]);
    T.useEffect(() => {
      const {
        current: Ae
      } = D;
      return Ae.addEventListener("touchstart", ie, {
        passive: H3()
      }), () => {
        Ae.removeEventListener("touchstart", ie), le();
      };
    }, [le, ie]), T.useEffect(() => {
      r && le();
    }, [r, le]);
    const ge = (Ae) => (oe) => {
      if (Ae.onMouseDown?.(oe), r || oe.defaultPrevented || oe.button !== 0)
        return;
      oe.preventDefault();
      const fe = mv(oe, _);
      if (fe !== !1) {
        const {
          newValue: Ce,
          activeIndex: Oe
        } = ue({
          finger: fe
        });
        gv({
          sliderRef: D,
          activeIndex: Oe,
          setActive: k
        }), U(Ce), j && !yv(Ce, N) && j(oe, Ce, Oe);
      }
      $.current = 0;
      const _e = Ar(D.current);
      _e.addEventListener("mousemove", J, {
        passive: !0
      }), _e.addEventListener("mouseup", ee);
    }, Se = H0(V ? F[0] : c, c, s), Me = H0(F[F.length - 1], c, s) - Se, je = (Ae = {}) => {
      const oe = Ap(Ae), fe = {
        onMouseDown: ge(oe || {})
      }, _e = {
        ...oe,
        ...fe
      };
      return {
        ...Ae,
        ref: G,
        ..._e
      };
    }, ze = (Ae) => (oe) => {
      Ae.onMouseOver?.(oe);
      const fe = Number(oe.currentTarget.getAttribute("data-index"));
      O(fe);
    }, Ye = (Ae) => (oe) => {
      Ae.onMouseLeave?.(oe), O(-1);
    }, Ue = (Ae = {}) => {
      const oe = Ap(Ae), fe = {
        onMouseOver: ze(oe || {}),
        onMouseLeave: Ye(oe || {})
      };
      return {
        ...Ae,
        ...oe,
        ...fe
      };
    }, Ne = (Ae) => ({
      // So the non active thumb doesn't show its label on hover.
      pointerEvents: C !== -1 && C !== Ae ? "none" : void 0
    });
    let mt;
    return m === "vertical" && (mt = i ? "vertical-rl" : "vertical-lr"), {
      active: C,
      axis: se,
      axisProps: a2e,
      dragging: P,
      focusedThumbIndex: Y,
      getHiddenInputProps: (Ae = {}) => {
        const oe = Ap(Ae), fe = {
          onChange: ne(oe || {}),
          onFocus: z(oe || {}),
          onBlur: H(oe || {}),
          onKeyDown: Q(oe || {})
        }, _e = {
          ...oe,
          ...fe
        };
        return {
          tabIndex: x,
          "aria-labelledby": t,
          "aria-orientation": m,
          "aria-valuemax": y(s),
          "aria-valuemin": y(c),
          name: u,
          type: "range",
          min: e.min,
          max: e.max,
          step: e.step === null && e.marks ? "any" : e.step ?? void 0,
          disabled: r,
          ...Ae,
          ..._e,
          style: {
            ...e2e,
            direction: i ? "rtl" : "ltr",
            // So that VoiceOver's focus indicator matches the thumb's dimensions
            width: "100%",
            height: "100%",
            writingMode: mt
          }
        };
      },
      getRootProps: je,
      getThumbProps: Ue,
      marks: K,
      open: A,
      range: V,
      rootRef: G,
      trackLeap: Me,
      trackOffset: Se,
      values: F,
      getThumbStyle: Ne
    };
  }
  const c2e = (e) => !e || !Ui(e);
  function u2e(e) {
    return ot("MuiSlider", e);
  }
  const Mo = nt("MuiSlider", ["root", "active", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "disabled", "dragging", "focusVisible", "mark", "markActive", "marked", "markLabel", "markLabelActive", "rail", "sizeSmall", "thumb", "thumbColorPrimary", "thumbColorSecondary", "thumbColorError", "thumbColorSuccess", "thumbColorInfo", "thumbColorWarning", "track", "trackInverted", "trackFalse", "thumbSizeSmall", "valueLabel", "valueLabelOpen", "valueLabelCircle", "valueLabelLabel", "vertical"]), f2e = (e) => {
    const {
      open: t
    } = e;
    return {
      offset: $e(t && Mo.valueLabelOpen),
      circle: Mo.valueLabelCircle,
      label: Mo.valueLabelLabel
    };
  };
  function d2e(e) {
    const {
      children: t,
      className: n,
      value: r
    } = e, o = f2e(e);
    return t ? /* @__PURE__ */ T.cloneElement(t, {
      className: t.props.className
    }, /* @__PURE__ */ S.jsxs(T.Fragment, {
      children: [t.props.children, /* @__PURE__ */ S.jsx("span", {
        className: $e(o.offset, n),
        "aria-hidden": !0,
        children: /* @__PURE__ */ S.jsx("span", {
          className: o.circle,
          children: /* @__PURE__ */ S.jsx("span", {
            className: o.label,
            children: r
          })
        })
      })]
    })) : null;
  }
  function q3(e) {
    return e;
  }
  const p2e = Re("span", {
    name: "MuiSlider",
    slot: "Root",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.root, t[`color${Ie(n.color)}`], n.size !== "medium" && t[`size${Ie(n.size)}`], n.marked && t.marked, n.orientation === "vertical" && t.vertical, n.track === "inverted" && t.trackInverted, n.track === !1 && t.trackFalse];
    }
  })(st(({
    theme: e
  }) => ({
    borderRadius: 12,
    boxSizing: "content-box",
    display: "inline-block",
    position: "relative",
    cursor: "pointer",
    touchAction: "none",
    WebkitTapHighlightColor: "transparent",
    "@media print": {
      colorAdjust: "exact"
    },
    [`&.${Mo.disabled}`]: {
      pointerEvents: "none",
      cursor: "default",
      color: (e.vars || e).palette.grey[400]
    },
    [`&.${Mo.dragging}`]: {
      [`& .${Mo.thumb}, & .${Mo.track}`]: {
        transition: "none"
      }
    },
    variants: [...Object.entries(e.palette).filter(wr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        color: (e.vars || e).palette[t].main
      }
    })), {
      props: {
        orientation: "horizontal"
      },
      style: {
        height: 4,
        width: "100%",
        padding: "13px 0",
        // The primary input mechanism of the device includes a pointing device of limited accuracy.
        "@media (pointer: coarse)": {
          // Reach 42px touch target, about ~8mm on screen.
          padding: "20px 0"
        }
      }
    }, {
      props: {
        orientation: "horizontal",
        size: "small"
      },
      style: {
        height: 2
      }
    }, {
      props: {
        orientation: "horizontal",
        marked: !0
      },
      style: {
        marginBottom: 20
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        height: "100%",
        width: 4,
        padding: "0 13px",
        // The primary input mechanism of the device includes a pointing device of limited accuracy.
        "@media (pointer: coarse)": {
          // Reach 42px touch target, about ~8mm on screen.
          padding: "0 20px"
        }
      }
    }, {
      props: {
        orientation: "vertical",
        size: "small"
      },
      style: {
        width: 2
      }
    }, {
      props: {
        orientation: "vertical",
        marked: !0
      },
      style: {
        marginRight: 44
      }
    }]
  }))), h2e = Re("span", {
    name: "MuiSlider",
    slot: "Rail"
  })({
    display: "block",
    position: "absolute",
    borderRadius: "inherit",
    backgroundColor: "currentColor",
    opacity: 0.38,
    variants: [{
      props: {
        orientation: "horizontal"
      },
      style: {
        width: "100%",
        height: "inherit",
        top: "50%",
        transform: "translateY(-50%)"
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        height: "100%",
        width: "inherit",
        left: "50%",
        transform: "translateX(-50%)"
      }
    }, {
      props: {
        track: "inverted"
      },
      style: {
        opacity: 1
      }
    }]
  }), m2e = Re("span", {
    name: "MuiSlider",
    slot: "Track"
  })(st(({
    theme: e
  }) => ({
    display: "block",
    position: "absolute",
    borderRadius: "inherit",
    border: "1px solid currentColor",
    backgroundColor: "currentColor",
    transition: e.transitions.create(["left", "width", "bottom", "height"], {
      duration: e.transitions.duration.shortest
    }),
    variants: [{
      props: {
        size: "small"
      },
      style: {
        border: "none"
      }
    }, {
      props: {
        orientation: "horizontal"
      },
      style: {
        height: "inherit",
        top: "50%",
        transform: "translateY(-50%)"
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        width: "inherit",
        left: "50%",
        transform: "translateX(-50%)"
      }
    }, {
      props: {
        track: !1
      },
      style: {
        display: "none"
      }
    }, ...Object.entries(e.palette).filter(wr()).map(([t]) => ({
      props: {
        color: t,
        track: "inverted"
      },
      style: {
        ...e.vars ? {
          backgroundColor: e.vars.palette.Slider[`${t}Track`],
          borderColor: e.vars.palette.Slider[`${t}Track`]
        } : {
          backgroundColor: e.lighten(e.palette[t].main, 0.62),
          borderColor: e.lighten(e.palette[t].main, 0.62),
          ...e.applyStyles("dark", {
            backgroundColor: e.darken(e.palette[t].main, 0.5)
          }),
          ...e.applyStyles("dark", {
            borderColor: e.darken(e.palette[t].main, 0.5)
          })
        }
      }
    }))]
  }))), g2e = Re("span", {
    name: "MuiSlider",
    slot: "Thumb",
    overridesResolver: (e, t) => {
      const {
        ownerState: n
      } = e;
      return [t.thumb, t[`thumbColor${Ie(n.color)}`], n.size !== "medium" && t[`thumbSize${Ie(n.size)}`]];
    }
  })(st(({
    theme: e
  }) => ({
    position: "absolute",
    width: 20,
    height: 20,
    boxSizing: "border-box",
    borderRadius: "50%",
    outline: 0,
    backgroundColor: "currentColor",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    transition: e.transitions.create(["box-shadow", "left", "bottom"], {
      duration: e.transitions.duration.shortest
    }),
    "&::before": {
      position: "absolute",
      content: '""',
      borderRadius: "inherit",
      width: "100%",
      height: "100%",
      boxShadow: (e.vars || e).shadows[2]
    },
    "&::after": {
      position: "absolute",
      content: '""',
      borderRadius: "50%",
      // 42px is the hit target
      width: 42,
      height: 42,
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)"
    },
    [`&.${Mo.disabled}`]: {
      "&:hover": {
        boxShadow: "none"
      }
    },
    variants: [{
      props: {
        size: "small"
      },
      style: {
        width: 12,
        height: 12,
        "&::before": {
          boxShadow: "none"
        }
      }
    }, {
      props: {
        orientation: "horizontal"
      },
      style: {
        top: "50%",
        transform: "translate(-50%, -50%)"
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        left: "50%",
        transform: "translate(-50%, 50%)"
      }
    }, ...Object.entries(e.palette).filter(wr()).map(([t]) => ({
      props: {
        color: t
      },
      style: {
        [`&:hover, &.${Mo.focusVisible}`]: {
          boxShadow: `0px 0px 0px 8px ${e.alpha((e.vars || e).palette[t].main, 0.16)}`,
          "@media (hover: none)": {
            boxShadow: "none"
          }
        },
        [`&.${Mo.active}`]: {
          boxShadow: `0px 0px 0px 14px ${e.alpha((e.vars || e).palette[t].main, 0.16)}`
        }
      }
    }))]
  }))), y2e = Re(d2e, {
    name: "MuiSlider",
    slot: "ValueLabel"
  })(st(({
    theme: e
  }) => ({
    zIndex: 1,
    whiteSpace: "nowrap",
    ...e.typography.body2,
    fontWeight: 500,
    transition: e.transitions.create(["transform"], {
      duration: e.transitions.duration.shortest
    }),
    position: "absolute",
    backgroundColor: (e.vars || e).palette.grey[600],
    borderRadius: 2,
    color: (e.vars || e).palette.common.white,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    padding: "0.25rem 0.75rem",
    variants: [{
      props: {
        orientation: "horizontal"
      },
      style: {
        transform: "translateY(-100%) scale(0)",
        top: "-10px",
        transformOrigin: "bottom center",
        "&::before": {
          position: "absolute",
          content: '""',
          width: 8,
          height: 8,
          transform: "translate(-50%, 50%) rotate(45deg)",
          backgroundColor: "inherit",
          bottom: 0,
          left: "50%"
        },
        [`&.${Mo.valueLabelOpen}`]: {
          transform: "translateY(-100%) scale(1)"
        }
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        transform: "translateY(-50%) scale(0)",
        right: "30px",
        top: "50%",
        transformOrigin: "right center",
        "&::before": {
          position: "absolute",
          content: '""',
          width: 8,
          height: 8,
          transform: "translate(-50%, -50%) rotate(45deg)",
          backgroundColor: "inherit",
          right: -8,
          top: "50%"
        },
        [`&.${Mo.valueLabelOpen}`]: {
          transform: "translateY(-50%) scale(1)"
        }
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        fontSize: e.typography.pxToRem(12),
        padding: "0.25rem 0.5rem"
      }
    }, {
      props: {
        orientation: "vertical",
        size: "small"
      },
      style: {
        right: "20px"
      }
    }]
  }))), v2e = Re("span", {
    name: "MuiSlider",
    slot: "Mark",
    shouldForwardProp: (e) => yb(e) && e !== "markActive",
    overridesResolver: (e, t) => {
      const {
        markActive: n
      } = e;
      return [t.mark, n && t.markActive];
    }
  })(st(({
    theme: e
  }) => ({
    position: "absolute",
    width: 2,
    height: 2,
    borderRadius: 1,
    backgroundColor: "currentColor",
    variants: [{
      props: {
        orientation: "horizontal"
      },
      style: {
        top: "50%",
        transform: "translate(-1px, -50%)"
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        left: "50%",
        transform: "translate(-50%, 1px)"
      }
    }, {
      props: {
        markActive: !0
      },
      style: {
        backgroundColor: (e.vars || e).palette.background.paper,
        opacity: 0.8
      }
    }]
  }))), b2e = Re("span", {
    name: "MuiSlider",
    slot: "MarkLabel",
    shouldForwardProp: (e) => yb(e) && e !== "markLabelActive"
  })(st(({
    theme: e
  }) => ({
    ...e.typography.body2,
    color: (e.vars || e).palette.text.secondary,
    position: "absolute",
    whiteSpace: "nowrap",
    variants: [{
      props: {
        orientation: "horizontal"
      },
      style: {
        top: 30,
        transform: "translateX(-50%)",
        "@media (pointer: coarse)": {
          top: 40
        }
      }
    }, {
      props: {
        orientation: "vertical"
      },
      style: {
        left: 36,
        transform: "translateY(50%)",
        "@media (pointer: coarse)": {
          left: 44
        }
      }
    }, {
      props: {
        markLabelActive: !0
      },
      style: {
        color: (e.vars || e).palette.text.primary
      }
    }]
  }))), x2e = (e) => {
    const {
      disabled: t,
      dragging: n,
      marked: r,
      orientation: o,
      track: i,
      classes: a,
      color: s,
      size: c
    } = e, u = {
      root: ["root", t && "disabled", n && "dragging", r && "marked", o === "vertical" && "vertical", i === "inverted" && "trackInverted", i === !1 && "trackFalse", s && `color${Ie(s)}`, c && `size${Ie(c)}`],
      rail: ["rail"],
      track: ["track"],
      mark: ["mark"],
      markActive: ["markActive"],
      markLabel: ["markLabel"],
      markLabelActive: ["markLabelActive"],
      valueLabel: ["valueLabel"],
      thumb: ["thumb", t && "disabled", c && `thumbSize${Ie(c)}`, s && `thumbColor${Ie(s)}`],
      active: ["active"],
      disabled: ["disabled"],
      focusVisible: ["focusVisible"]
    };
    return rt(u, u2e, a);
  }, w2e = ({
    children: e
  }) => e, S2e = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiSlider"
    }), o = wF(), {
      "aria-label": i,
      "aria-valuetext": a,
      "aria-labelledby": s,
      // eslint-disable-next-line react/prop-types
      component: c = "span",
      components: u = {},
      componentsProps: d = {},
      color: p = "primary",
      classes: m,
      className: g,
      disableSwap: y = !1,
      disabled: b = !1,
      getAriaLabel: v,
      getAriaValueText: x,
      marks: E = !1,
      max: _ = 100,
      min: C = 0,
      name: k,
      onChange: A,
      onChangeCommitted: O,
      orientation: P = "horizontal",
      shiftStep: I = 10,
      size: $ = "medium",
      step: L = 1,
      scale: N = q3,
      slotProps: U,
      slots: j,
      tabIndex: V,
      track: F = "normal",
      value: K,
      valueLabelDisplay: W = "off",
      valueLabelFormat: Y = q3,
      ...B
    } = r, D = {
      ...r,
      isRtl: o,
      max: _,
      min: C,
      classes: m,
      disabled: b,
      disableSwap: y,
      orientation: P,
      marks: E,
      color: p,
      size: $,
      step: L,
      shiftStep: I,
      scale: N,
      track: F,
      valueLabelDisplay: W,
      valueLabelFormat: Y
    }, {
      axisProps: G,
      getRootProps: z,
      getHiddenInputProps: H,
      getThumbProps: X,
      open: Q,
      active: ne,
      axis: te,
      focusedThumbIndex: se,
      range: ue,
      dragging: J,
      marks: ee,
      values: ie,
      trackOffset: le,
      trackLeap: ge,
      getThumbStyle: Se
    } = l2e({
      ...D,
      rootRef: n
    });
    D.marked = ee.length > 0 && ee.some((on) => on.label), D.dragging = J, D.focusedThumbIndex = se;
    const Me = x2e(D), je = j?.root ?? u.Root ?? p2e, ze = j?.rail ?? u.Rail ?? h2e, Ye = j?.track ?? u.Track ?? m2e, Ue = j?.thumb ?? u.Thumb ?? g2e, Ne = j?.valueLabel ?? u.ValueLabel ?? y2e, mt = j?.mark ?? u.Mark ?? v2e, Je = j?.markLabel ?? u.MarkLabel ?? b2e, Ae = j?.input ?? u.Input ?? "input", oe = U?.root ?? d.root, fe = U?.rail ?? d.rail, _e = U?.track ?? d.track, Ce = U?.thumb ?? d.thumb, Oe = U?.valueLabel ?? d.valueLabel, He = U?.mark ?? d.mark, Ot = U?.markLabel ?? d.markLabel, it = U?.input ?? d.input, Et = Ia({
      elementType: je,
      getSlotProps: z,
      externalSlotProps: oe,
      externalForwardedProps: B,
      additionalProps: {
        ...c2e(je) && {
          as: c
        }
      },
      ownerState: {
        ...D,
        ...oe?.ownerState
      },
      className: [Me.root, g]
    }), xn = Ia({
      elementType: ze,
      externalSlotProps: fe,
      ownerState: D,
      className: Me.rail
    }), Mt = Ia({
      elementType: Ye,
      externalSlotProps: _e,
      additionalProps: {
        style: {
          ...G[te].offset(le),
          ...G[te].leap(ge)
        }
      },
      ownerState: {
        ...D,
        ..._e?.ownerState
      },
      className: Me.track
    }), De = Ia({
      elementType: Ue,
      getSlotProps: X,
      externalSlotProps: Ce,
      ownerState: {
        ...D,
        ...Ce?.ownerState
      },
      className: Me.thumb
    }), ft = Ia({
      elementType: Ne,
      externalSlotProps: Oe,
      ownerState: {
        ...D,
        ...Oe?.ownerState
      },
      className: Me.valueLabel
    }), hn = Ia({
      elementType: mt,
      externalSlotProps: He,
      ownerState: D,
      className: Me.mark
    }), nr = Ia({
      elementType: Je,
      externalSlotProps: Ot,
      ownerState: D,
      className: Me.markLabel
    }), Lo = Ia({
      elementType: Ae,
      getSlotProps: H,
      externalSlotProps: it,
      ownerState: D
    });
    return /* @__PURE__ */ S.jsxs(je, {
      ...Et,
      children: [/* @__PURE__ */ S.jsx(ze, {
        ...xn
      }), /* @__PURE__ */ S.jsx(Ye, {
        ...Mt
      }), ee.filter((on) => on.value >= C && on.value <= _).map((on, an) => {
        const ui = H0(on.value, C, _), yo = G[te].offset(ui);
        let Gr;
        return F === !1 ? Gr = ie.includes(on.value) : Gr = F === "normal" && (ue ? on.value >= ie[0] && on.value <= ie[ie.length - 1] : on.value <= ie[0]) || F === "inverted" && (ue ? on.value <= ie[0] || on.value >= ie[ie.length - 1] : on.value >= ie[0]), /* @__PURE__ */ S.jsxs(T.Fragment, {
          children: [/* @__PURE__ */ S.jsx(mt, {
            "data-index": an,
            ...hn,
            ...!Ui(mt) && {
              markActive: Gr
            },
            style: {
              ...yo,
              ...hn.style
            },
            className: $e(hn.className, Gr && Me.markActive)
          }), on.label != null ? /* @__PURE__ */ S.jsx(Je, {
            "aria-hidden": !0,
            "data-index": an,
            ...nr,
            ...!Ui(Je) && {
              markLabelActive: Gr
            },
            style: {
              ...yo,
              ...nr.style
            },
            className: $e(Me.markLabel, nr.className, Gr && Me.markLabelActive),
            children: on.label
          }) : null]
        }, an);
      }), ie.map((on, an) => {
        const ui = H0(on, C, _), yo = G[te].offset(ui), Gr = W === "off" ? w2e : Ne;
        return (
          /* TODO v6: Change component structure. It will help in avoiding the complicated React.cloneElement API added in SliderValueLabel component. Should be: Thumb -> Input, ValueLabel. Follow Joy UI's Slider structure. */
          /* @__PURE__ */ S.jsx(Gr, {
            ...!Ui(Gr) && {
              valueLabelFormat: Y,
              valueLabelDisplay: W,
              value: typeof Y == "function" ? Y(N(on), an) : Y,
              index: an,
              open: Q === an || ne === an || W === "on",
              disabled: b
            },
            ...ft,
            children: /* @__PURE__ */ S.jsx(Ue, {
              "data-index": an,
              ...De,
              className: $e(Me.thumb, De.className, ne === an && Me.active, se === an && Me.focusVisible),
              style: {
                ...yo,
                ...Se(an),
                ...De.style
              },
              children: /* @__PURE__ */ S.jsx(Ae, {
                "data-index": an,
                "aria-label": v ? v(an) : i,
                "aria-valuenow": N(on),
                "aria-labelledby": s,
                "aria-valuetext": x ? x(N(on), an) : a,
                value: ie[an],
                ...Lo
              })
            })
          }, an)
        );
      })]
    });
  });
  function _2e(e) {
    const { value: t, readonly: n, disabled: r, onBlur: o, onFocus: i, options: a, schema: s, onChange: c, required: u, label: d, hideLabel: p, id: m } = e, g = { value: t, label: d, id: m, name: m, ...pV(s) }, y = (x, E) => {
      c(E ?? a.emptyValue);
    }, b = ({ target: x }) => o(m, x && x.value), v = ({ target: x }) => i(m, x && x.value);
    return S.jsxs(S.Fragment, { children: [Pc(S.jsx(P1, { required: u, htmlFor: m, children: d || void 0 }), p), S.jsx(S2e, { disabled: r || n, onChange: y, onBlur: b, onFocus: v, valueLabelDisplay: "auto", ...g, "aria-describedby": go(m) })] });
  }
  function E2e(e) {
    return ot("MuiMenuItem", e);
  }
  const sp = nt("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]), C2e = (e, t) => {
    const {
      ownerState: n
    } = e;
    return [t.root, n.dense && t.dense, n.divider && t.divider, !n.disableGutters && t.gutters];
  }, k2e = (e) => {
    const {
      disabled: t,
      dense: n,
      divider: r,
      disableGutters: o,
      selected: i,
      classes: a
    } = e, c = rt({
      root: ["root", n && "dense", t && "disabled", !o && "gutters", r && "divider", i && "selected"]
    }, E2e, a);
    return {
      ...a,
      ...c
    };
  }, T2e = Re(Lh, {
    shouldForwardProp: (e) => Sr(e) || e === "classes",
    name: "MuiMenuItem",
    slot: "Root",
    overridesResolver: C2e
  })(st(({
    theme: e
  }) => ({
    ...e.typography.body1,
    display: "flex",
    justifyContent: "flex-start",
    alignItems: "center",
    position: "relative",
    textDecoration: "none",
    minHeight: 48,
    paddingTop: 6,
    paddingBottom: 6,
    boxSizing: "border-box",
    whiteSpace: "nowrap",
    "&:hover": {
      textDecoration: "none",
      backgroundColor: (e.vars || e).palette.action.hover,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    },
    [`&.${sp.selected}`]: {
      backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity),
      [`&.${sp.focusVisible}`]: {
        backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.focusOpacity}`)
      }
    },
    [`&.${sp.selected}:hover`]: {
      backgroundColor: e.alpha((e.vars || e).palette.primary.main, `${(e.vars || e).palette.action.selectedOpacity} + ${(e.vars || e).palette.action.hoverOpacity}`),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: e.alpha((e.vars || e).palette.primary.main, (e.vars || e).palette.action.selectedOpacity)
      }
    },
    [`&.${sp.focusVisible}`]: {
      backgroundColor: (e.vars || e).palette.action.focus
    },
    [`&.${sp.disabled}`]: {
      opacity: (e.vars || e).palette.action.disabledOpacity
    },
    [`& + .${z3.root}`]: {
      marginTop: e.spacing(1),
      marginBottom: e.spacing(1)
    },
    [`& + .${z3.inset}`]: {
      marginLeft: 52
    },
    [`& .${Xu.root}`]: {
      marginTop: 0,
      marginBottom: 0
    },
    [`& .${Xu.inset}`]: {
      paddingLeft: 36
    },
    [`& .${F3.root}`]: {
      minWidth: 36
    },
    variants: [{
      props: ({
        ownerState: t
      }) => !t.disableGutters,
      style: {
        paddingLeft: 16,
        paddingRight: 16
      }
    }, {
      props: ({
        ownerState: t
      }) => t.divider,
      style: {
        borderBottom: `1px solid ${(e.vars || e).palette.divider}`,
        backgroundClip: "padding-box"
      }
    }, {
      props: ({
        ownerState: t
      }) => !t.dense,
      style: {
        [e.breakpoints.up("sm")]: {
          minHeight: "auto"
        }
      }
    }, {
      props: ({
        ownerState: t
      }) => t.dense,
      style: {
        minHeight: 32,
        // https://m2.material.io/components/menus#specs > Dense
        paddingTop: 4,
        paddingBottom: 4,
        ...e.typography.body2,
        [`& .${F3.root} svg`]: {
          fontSize: "1.25rem"
        }
      }
    }]
  }))), W3 = /* @__PURE__ */ T.forwardRef(function(t, n) {
    const r = ut({
      props: t,
      name: "MuiMenuItem"
    }), {
      autoFocus: o = !1,
      component: i = "li",
      dense: a = !1,
      divider: s = !1,
      disableGutters: c = !1,
      focusVisibleClassName: u,
      role: d = "menuitem",
      tabIndex: p,
      className: m,
      ...g
    } = r, y = T.useContext(Ua), b = T.useMemo(() => ({
      dense: a || y.dense || !1,
      disableGutters: c
    }), [y.dense, a, c]), v = T.useRef(null);
    ei(() => {
      o && v.current && v.current.focus();
    }, [o]);
    const x = {
      ...r,
      dense: b.dense,
      divider: s,
      disableGutters: c
    }, E = k2e(r), _ = er(v, n);
    let C;
    return r.disabled || (C = p !== void 0 ? p : -1), /* @__PURE__ */ S.jsx(Ua.Provider, {
      value: b,
      children: /* @__PURE__ */ S.jsx(T2e, {
        ref: _,
        role: d,
        tabIndex: C,
        component: i,
        focusVisibleClassName: $e(E.focusVisible, u),
        className: $e(E.root, m),
        ...g,
        ownerState: x,
        classes: E
      })
    });
  });
  function A2e({
    schema: e,
    id: t,
    name: n,
    // remove this from textFieldProps
    htmlName: r,
    options: o,
    label: i,
    hideLabel: a,
    required: s,
    disabled: c,
    placeholder: u,
    readonly: d,
    value: p,
    multiple: m,
    autofocus: g,
    onChange: y,
    onBlur: b,
    onFocus: v,
    errorSchema: x,
    rawErrors: E = [],
    registry: _,
    uiSchema: C,
    hideError: k,
    ...A
  }) {
    const { enumOptions: O, enumDisabled: P, emptyValue: I } = o;
    m = typeof m > "u" ? !1 : !!m;
    const $ = m ? [] : "", L = typeof p > "u" || m && p.length < 1 || !m && p === $, N = ({ target: { value: D } }) => y(Jn(D, O, I)), U = ({ target: D }) => b(t, Jn(D && D.value, O, I)), j = ({ target: D }) => v(t, Jn(D && D.value, O, I)), V = bA(p, O, m), { InputLabelProps: F, SelectProps: K, autocomplete: W, ...Y } = A, B = !m && e.default === void 0;
    return S.jsxs(WA, { id: t, name: r || t, label: Pc(i || void 0, a, void 0), value: !L && typeof V < "u" ? V : $, required: s, disabled: c || d, autoFocus: g, autoComplete: W, placeholder: u, error: E.length > 0, onChange: N, onBlur: U, onFocus: j, ...Y, select: !0, InputLabelProps: {
      ...F,
      shrink: !L
    }, SelectProps: {
      ...K,
      multiple: m
    }, "aria-describedby": go(t), children: [B && S.jsx(W3, { value: "", children: u }), Array.isArray(O) && O.map(({ value: D, label: G }, z) => {
      const H = Array.isArray(P) && P.indexOf(D) !== -1;
      return S.jsx(W3, { value: String(z), disabled: H, children: G }, z);
    })] });
  }
  function R2e(e) {
    const { options: t, registry: n } = e, r = tt("BaseInputTemplate", n, t);
    let o = 5;
    return (typeof t.rows == "string" || typeof t.rows == "number") && (o = t.rows), S.jsx(r, { ...e, multiline: !0, rows: o });
  }
  function O2e() {
    return {
      CheckboxWidget: NPe,
      CheckboxesWidget: jPe,
      RadioWidget: JPe,
      RangeWidget: _2e,
      SelectWidget: A2e,
      TextareaWidget: R2e
    };
  }
  function gH() {
    return {
      templates: hPe(),
      widgets: O2e()
    };
  }
  const M2e = gH();
  function N2e() {
    return WV(gH());
  }
  N2e();
  const P2e = WV(M2e), I2e = mb({
    cssVariables: { nativeColor: !0 },
    palette: {
      primary: {
        main: "var(--fn-primary-color)",
        contrastText: "var(--fn-app-background)"
      },
      text: {
        primary: "var(--fn-text-color-neutral)",
        secondary: "var(--fn-text-color-neutral)",
        disabled: "var(--fn-text-color-neutral)",
        primaryChannel: "var(--fn-text-color-neutral-channel)",
        secondaryChannel: "var(--fn-text-color-neutral-channel)"
      },
      common: {
        black: "var(--fn-primary-color)",
        white: "var(--fn-app-background)"
      },
      background: {
        default: "var(--fn-app-background)",
        paper: "var(--fn-app-background)",
        defaultChannel: "var(--fn-app-background-channel)",
        paperChannel: "var(--fn-app-background-channel)"
      }
    },
    shape: {
      borderRadius: "var(--fn-border-radius-s)"
    }
  }), yH = ({
    getter: e,
    setter: t,
    setter_calls_getter: n = !1,
    disabled: r = !1,
    readonly: o = !1
  }) => {
    const [i, a] = T.useState(null), [s, c] = T.useState(void 0), [u, d] = T.useState(void 0), p = T.useCallback(async () => {
      const g = await e();
      a(g.jsonSchema), c(g.uiSchema), d(g.formData);
    }, [e]), m = T.useCallback(
      async (g) => {
        await t(g), n && await p();
      },
      [t, n, p]
    );
    return T.useEffect(() => {
      p();
    }, [p]), i ? /* @__PURE__ */ S.jsx(uOe, { theme: I2e, children: /* @__PURE__ */ S.jsx(
      P2e,
      {
        schema: i,
        uiSchema: s || void 0,
        formData: u || void 0,
        validator: Uke,
        liveValidate: "onChange",
        onChange: ({ formData: g }) => d(g),
        onSubmit: ({ formData: g }) => m(g),
        disabled: r,
        readonly: o
      }
    ) }) : /* @__PURE__ */ S.jsx("div", { children: "Loading" });
  }, $2e = ({
    jsonSchema: e,
    uiSchema: t,
    full: n,
    readonly: r
  }) => {
    const o = {
      jsonSchema: e,
      uiSchema: t,
      formData: {}
    };
    r && (o.uiSchema = {
      ...o.uiSchema,
      "ui:readonly": !0,
      "ui:disabled": !0,
      "ui:submitButtonOptions": {
        norender: !0,
        props: {
          disabled: r,
          className: "btn btn-info"
        }
      }
    });
    const i = n?.value;
    return i && (typeof i == "object" && i !== null && "schema" in i && "data" in i ? (o.jsonSchema = i.schema, o.formData = i.data ?? {}) : o.formData = i), o;
  }, j2e = ({ inputconverter: e }) => {
    const t = En(), { preview: n, full: r } = t.valuestore(), o = t.use(), [i, a] = T.useState(!1), s = im(), c = kc(o), u = o.render_options.schema, d = o.render_options.uiSchema, p = T.useMemo(() => {
      if (!u)
        throw new Error("No jsonSchema provided");
      return $2e({
        jsonSchema: u,
        uiSchema: d,
        full: r,
        readonly: o.connected
      });
    }, [u, d, r, n, o.connected]), m = T.useCallback(
      async () => p,
      [p]
    ), g = T.useCallback(
      async (y) => {
        c(y), a(!1);
      },
      [c]
    );
    return /* @__PURE__ */ S.jsx(
      Ji,
      {
        title: o.name,
        description: "Edit " + o.name,
        open: i,
        setOpen: a,
        trigger: /* @__PURE__ */ S.jsx("button", { className: "nodedatainput styledinput", children: "Edit" }),
        onOpenChange: (y) => {
          y && !r && s?.();
        },
        children: /* @__PURE__ */ S.jsx(
          yH,
          {
            getter: m,
            setter: g,
            setter_calls_getter: !1,
            disabled: o.connected,
            readonly: o.connected
          }
        )
      }
    );
  }, D2e = {
    float: dbe,
    int: pbe,
    bool: U0e,
    string: kj,
    str: kj,
    color: V0e,
    select: dh,
    enum: dh,
    json_schema: j2e,
    bytes: O8(VT, "")
  }, F2e = {}, L2e = {}, wi = {
    Inputrenderer: D2e,
    Outputrenderer: L0e,
    HandlePreviewRenderer: D0e,
    DataOverlayRenderer: j0e,
    DataPreviewViewRenderer: M8,
    DataViewRenderer: HT,
    InLineRenderer: $0e,
    NodeRenderer: F2e,
    NodeHooks: L2e
  }, z2e = (e, t) => {
    const n = t.options || {}, r = n.overwrite === void 0 ? !0 : n.overwrite;
    switch (t.type) {
      case "EXTEND_INPUT_RENDER":
        return !r && e.Inputrenderer[t.payload.type] ? e : {
          ...e,
          Inputrenderer: {
            ...e.Inputrenderer,
            [t.payload.type]: t.payload.component
          }
        };
      case "EXTEND_FROM_PLUGIN": {
        let a = !1;
        const s = [
          [t.payload.plugin.input_renderers || {}, e.Inputrenderer],
          [t.payload.plugin.output_renderers || {}, e.Outputrenderer],
          [
            t.payload.plugin.handle_preview_renderers || {},
            e.HandlePreviewRenderer
          ],
          [
            t.payload.plugin.data_overlay_renderers || {},
            e.DataOverlayRenderer
          ],
          [
            t.payload.plugin.data_preview_renderers || {},
            e.DataPreviewViewRenderer
          ],
          [
            t.payload.plugin.data_view_renderers || {},
            e.DataViewRenderer
          ],
          [t.payload.plugin.node_renderers || {}, e.NodeRenderer],
          [t.payload.plugin.node_hooks || {}, e.NodeHooks]
        ];
        for (const [u, d] of s) {
          if (Object.keys(u).length > 0) {
            if (r)
              a = !0;
            else
              for (const p in u)
                if (!d[p]) {
                  a = !0;
                  break;
                }
          }
          if (a) break;
        }
        if (!a)
          return e;
        const c = { ...e };
        return s.forEach(([u, d]) => {
          Object.assign(d, u);
        }), c;
      }
      default:
        const i = {
          EXTEND_OUTPUT_RENDER: "Outputrenderer",
          EXTEND_HANDLE_PREVIEW_RENDER: "HandlePreviewRenderer",
          EXTEND_DATA_OVERLAY_RENDER: "DataOverlayRenderer",
          EXTEND_DATA_PREVIEW_RENDER: "DataPreviewViewRenderer",
          EXTEND_DATA_VIEW_RENDER: "DataViewRenderer",
          EXTEND_NODE_CONTEXT_EXTENDER: "NodeContextExtenders",
          EXTEND_NODE_RENDERER: "NodeRenderer",
          EXTEND_NODE_HOOKS: "NodeHooks"
        }[t.type];
        if (i) {
          const a = e[i];
          return !r && a[t.payload.type] ? e : {
            ...e,
            [i]: {
              ...a,
              [t.payload.type]: t.payload.component
            }
          };
        }
        return e;
    }
  }, B2e = ({
    children: e,
    plugins: t,
    fnrf_zst: n
  }) => {
    const [r, o] = T.useReducer(
      z2e,
      wi
    ), i = T.useCallback(
      (y, b, v) => {
        o({
          type: "EXTEND_INPUT_RENDER",
          payload: { type: y, component: b },
          options: v
        });
      },
      []
    ), a = T.useCallback(
      (y, b, v) => {
        o({
          type: "EXTEND_OUTPUT_RENDER",
          payload: { type: y, component: b },
          options: v
        });
      },
      []
    ), s = T.useCallback(
      (y, b, v) => {
        o({
          type: "EXTEND_HANDLE_PREVIEW_RENDER",
          payload: { type: y, component: b },
          options: v
        });
      },
      []
    ), c = T.useCallback(
      (y, b, v) => {
        o({
          type: "EXTEND_DATA_OVERLAY_RENDER",
          payload: { type: y, component: b },
          options: v
        });
      },
      []
    ), u = T.useCallback(
      (y, b, v) => {
        o({
          type: "EXTEND_DATA_PREVIEW_RENDER",
          payload: { type: y, component: b },
          options: v
        });
      },
      []
    ), d = T.useCallback(
      (y, b, v) => {
        o({
          type: "EXTEND_DATA_VIEW_RENDER",
          payload: { type: y, component: b },
          options: v
        });
      },
      []
    ), p = T.useCallback(
      (y, b, v) => {
        o({
          type: "EXTEND_NODE_RENDERER",
          payload: { type: y, component: b },
          options: v
        });
      },
      []
    ), m = T.useCallback(
      (y, b, v) => {
        o({
          type: "EXTEND_NODE_HOOKS",
          payload: { type: y, component: b },
          options: v
        });
      },
      []
    ), g = T.useCallback(
      (y, b) => {
        o({
          type: "EXTEND_FROM_PLUGIN",
          payload: { plugin: y },
          options: b
        });
      },
      []
    );
    return T.useEffect(() => {
      for (const y in t) {
        const b = t[y];
        if (!b) continue;
        const v = b.renderpluginfactory;
        v && g(v({ React: sc, fnrf_zst: n, NodeContext: i1 }));
      }
    }, [t, g, n]), /* @__PURE__ */ S.jsx(
      as.Provider,
      {
        value: {
          Inputrenderer: r.Inputrenderer,
          Outputrenderer: r.Outputrenderer,
          HandlePreviewRenderer: r.HandlePreviewRenderer,
          DataOverlayRenderer: r.DataOverlayRenderer,
          DataPreviewViewRenderer: r.DataPreviewViewRenderer,
          DataViewRenderer: r.DataViewRenderer,
          InLineRenderer: r.InLineRenderer,
          NodeRenderer: r.NodeRenderer,
          NodeHooks: r.NodeHooks,
          extendNodeRenderer: p,
          extendInputRenderMapping: i,
          extendOutputRenderMapping: a,
          extendHandlePreviewRenderMapping: s,
          extendDataOverlayRenderMapping: c,
          extendDataPreviewRenderMapping: u,
          extendDataViewRenderMapping: d,
          extendNodeHooks: m,
          extendFromPlugin: g
        },
        children: e
      }
    );
  }, as = T.createContext({
    Inputrenderer: wi.Inputrenderer,
    Outputrenderer: wi.Outputrenderer,
    HandlePreviewRenderer: wi.HandlePreviewRenderer,
    DataOverlayRenderer: wi.DataOverlayRenderer,
    DataPreviewViewRenderer: wi.DataPreviewViewRenderer,
    DataViewRenderer: wi.DataViewRenderer,
    InLineRenderer: wi.InLineRenderer,
    NodeRenderer: wi.NodeRenderer,
    NodeHooks: wi.NodeHooks,
    extendInputRenderMapping: (e, t, n) => {
    },
    extendOutputRenderMapping: (e, t, n) => {
    },
    extendHandlePreviewRenderMapping: (e, t, n) => {
    },
    extendDataOverlayRenderMapping: (e, t, n) => {
    },
    extendDataPreviewRenderMapping: (e, t, n) => {
    },
    extendDataViewRenderMapping: (e, t, n) => {
    },
    extendNodeRenderer: (e, t, n) => {
    },
    extendNodeHooks: (e, t, n) => {
    },
    extendFromPlugin: (e, t) => {
    }
  }), vH = (e) => {
    const t = Vt(), { DataOverlayRenderer: n, DataViewRenderer: r } = T.useContext(as);
    if (e === void 0) return;
    const o = t.render_options(), [i] = Cc(e, o.typemap || {});
    return i ? n[i] ? n[i] : r[i] ? a1(r[i]) : Cj : Cj;
  }, U2e = (e) => {
    const t = Vt(), n = vH(e), { DataPreviewViewRenderer: r, DataViewRenderer: o } = T.useContext(as), i = t.render_options();
    if (e === void 0) return [void 0, n];
    const [a] = Cc(e, i.typemap || {});
    return a ? r[a] ? [r[a], n] : o[a] ? [
      zr(o[a]),
      n
    ] : [
      zr(P0),
      n
    ] : [
      zr(P0),
      n
    ];
  }, V2e = (e) => {
    const n = Vt().render_options(), { HandlePreviewRenderer: r, DataPreviewViewRenderer: o } = T.useContext(as), i = vH(e);
    let a;
    if (e) {
      const [s] = Cc(e, n.typemap || {});
      s ? r[s] ? a = r[s] : o[s] ? a = o[s] : a = zr(
        P0
      ) : a = zr(
        P0
      );
    }
    return [a, i];
  }, H2e = (e) => {
    const [t, n] = T.useState(!1), r = e.use((o) => o.in_trigger);
    return T.useEffect(() => {
      let o;
      return r && !t ? n(!0) : t && (o = setTimeout(() => n(!1), 200)), () => clearTimeout(o);
    }, [r, t]), { visualTrigger: t, nodestore: e };
  }, bH = ({
    iostore: e,
    Component: t
  }) => {
    const [n, r] = T.useState(void 0), [o, i] = T.useState(void 0), { full: a } = e.valuestore(), s = im();
    T.useEffect(() => {
      a === void 0 ? s?.() : i(a.value);
    }, [a, s]);
    const c = () => {
      o !== void 0 && r(o);
    };
    return /* @__PURE__ */ S.jsx(
      t,
      {
        value: o,
        preValue: n,
        onLoaded: c
      }
    );
  }, xH = ({
    Component: e
  }) => /* @__PURE__ */ S.jsx(e, {}), VC = ({
    typestring: e,
    preview: t,
    ...n
  }) => {
    const [r, o] = T.useState(!1), [i, a] = T.useState(!1), s = Vt(), c = En(), u = c.use(), d = im(), [p, m] = V2e(u), g = s.local_state(() => s.reactflowRef);
    return (
      // <Tooltip.Provider>
      /* @__PURE__ */ S.jsxs(l6, { open: r || i, onOpenChange: a, children: [
        /* @__PURE__ */ S.jsx(c6, { asChild: !0, children: /* @__PURE__ */ S.jsx(fh, { id: u.id, "data-type": e, ...n }) }),
        /* @__PURE__ */ S.jsx(u6, { container: g, children: /* @__PURE__ */ S.jsxs(
          f6,
          {
            className: "iotooltipcontent",
            sideOffset: 5,
            avoidCollisions: !0,
            collisionBoundary: g,
            collisionPadding: 10,
            onOpenAutoFocus: (y) => y.preventDefault(),
            onCloseAutoFocus: (y) => y.preventDefault(),
            children: [
              /* @__PURE__ */ S.jsxs("div", { className: "iotooltip_container", children: [
                /* @__PURE__ */ S.jsxs("div", { className: "iotooltip_header", children: [
                  u.name,
                  r ? /* @__PURE__ */ S.jsx(Voe, { onClick: () => o(!1) }) : /* @__PURE__ */ S.jsx(Uoe, { onClick: () => o(!0) }),
                  m && /* @__PURE__ */ S.jsx(
                    Ji,
                    {
                      title: u.full_id,
                      trigger: /* @__PURE__ */ S.jsx(xz, {}),
                      onOpenChange: (y) => {
                        y && d?.(), o(y);
                      },
                      children: /* @__PURE__ */ S.jsx(
                        bH,
                        {
                          Component: m,
                          iostore: c
                        }
                      )
                    }
                  )
                ] }),
                p ? /* @__PURE__ */ S.jsx(xH, { Component: p }) : `no preview available for "${e}"`
              ] }),
              /* @__PURE__ */ S.jsx(Eae, { className: "iotooltipcontentarrow" })
            ]
          }
        ) })
      ] })
    );
  }, Mf = {
    "": [(e) => e, (e) => e],
    str_to_json: [
      (e) => JSON.parse(e),
      (e) => typeof e == "string" ? e : JSON.stringify(e)
    ],
    str_to_list: [
      (e) => {
        try {
          const t = JSON.parse(e);
          return Array.isArray(t) ? t : [t];
        } catch {
          try {
            return JSON.parse("[" + e + "]");
          } catch {
          }
        }
        throw new Error("Invalid list");
      },
      (e) => JSON.stringify(e)
    ]
  }, q2e = ({
    setNodeSettingsPath: e,
    setShowSettings: t
  }) => {
    const r = Vt().render_options(), i = En().use(), [a, s] = Cc(i, r.typemap || {}), { Inputrenderer: c } = T.useContext(as), u = a ? i.value_options?.options ? dh : c[a] : void 0, d = Mf[(s && r.inputconverter?.[s]) ?? ""] || Mf[""], { keys: p } = Zk(), m = (g) => {
      p.has("s") && (e && e("inputs/" + i.id), t && t(!0), g.stopPropagation());
    };
    return i.hidden ? null : /* @__PURE__ */ S.jsxs(
      "div",
      {
        className: "nodeinput",
        "data-type": a,
        onClick: m,
        children: [
          /* @__PURE__ */ S.jsx(
            VC,
            {
              typestring: a,
              position: Ve.Left,
              type: "target"
            }
          ),
          /* @__PURE__ */ S.jsxs("div", { className: "inner_nodeio", children: [
            u && /* @__PURE__ */ S.jsx("div", { className: "iovaluefield nodrag", "data-type": a, children: /* @__PURE__ */ S.jsx(u, { inputconverter: d }) }),
            /* @__PURE__ */ S.jsx("div", { className: "ioname", children: i.name })
          ] }),
          /* @__PURE__ */ S.jsx(
            VC,
            {
              typestring: a,
              position: Ve.Right,
              type: "source"
            }
          )
        ]
      }
    );
  }, W2e = ({
    setNodeSettingsPath: e,
    setShowSettings: t
  }) => {
    const r = Vt().render_options(), i = En().use(), [a] = Cc(i, r.typemap || {}), { Outputrenderer: s } = T.useContext(as), { keys: c } = Zk(), u = a ? s[a] : void 0, d = (p) => {
      c.has("s") && (e && e("outputs/" + i.id), t && t(!0), p.stopPropagation());
    };
    return i.hidden ? null : /* @__PURE__ */ S.jsxs(
      "div",
      {
        className: "nodeoutput",
        "data-type": a,
        onClick: d,
        children: [
          /* @__PURE__ */ S.jsx(
            VC,
            {
              typestring: a,
              position: Ve.Right,
              type: "source"
            }
          ),
          /* @__PURE__ */ S.jsxs("div", { className: "inner_nodeio", children: [
            /* @__PURE__ */ S.jsx("div", { className: "ioname", children: i.name }),
            u ? /* @__PURE__ */ S.jsx("div", { className: "iovaluefield nodrag", children: /* @__PURE__ */ S.jsx(u, {}) }) : /* @__PURE__ */ S.jsx("div", { className: "iovaluefield", children: /* @__PURE__ */ S.jsx(F0e, {}) })
          ] })
        ]
      }
    );
  }, G2e = () => {
    const t = Vt().render_options(), r = En().use(), o = qT(), [i, a] = Cc(r, t.typemap || {}), { Inputrenderer: s } = T.useContext(as), c = i ? r.value_options?.options ? dh : s[i] : void 0, u = Mf[(a && t.inputconverter?.[a]) ?? ""] || Mf[""];
    return /* @__PURE__ */ S.jsxs("div", { className: "nodesettings_component", children: [
      /* @__PURE__ */ S.jsx("div", { children: r.name }),
      c && /* @__PURE__ */ S.jsx(c, { inputconverter: u }),
      /* @__PURE__ */ S.jsx("div", { children: /* @__PURE__ */ S.jsxs("label", { children: [
        "hidden:",
        /* @__PURE__ */ S.jsx(
          "input",
          {
            className: "styledcheckbox",
            type: "checkbox",
            disabled: r.connected,
            onChange: (d) => {
              o?.(d.target.checked);
            },
            checked: r.hidden
          }
        )
      ] }) })
    ] });
  }, K2e = () => {
    const t = En().use(), n = qT();
    return /* @__PURE__ */ S.jsxs("div", { className: "nodesettings_component", children: [
      /* @__PURE__ */ S.jsx("div", { children: t.name }),
      /* @__PURE__ */ S.jsx("div", { children: /* @__PURE__ */ S.jsxs("label", { children: [
        "hidden:",
        /* @__PURE__ */ S.jsx(
          "input",
          {
            className: "styledcheckbox",
            type: "checkbox",
            disabled: t.connected,
            onChange: (r) => {
              n?.(r.target.checked);
            },
            checked: t.hidden
          }
        )
      ] }) })
    ] });
  }, wH = ({}) => {
    const e = Vt(), { node: t } = Rr(), r = En().use(), o = e.render_options(), i = qT(), [a, s] = T.useState(r.name);
    T.useEffect(() => s(r.name), [r.name]);
    const c = T.useCallback(
      (b) => s(b.target.value),
      []
    ), u = T.useCallback(() => {
      a !== r.name && t?.update_io_options({
        nid: r.node,
        ioid: r.id,
        options: { name: a }
      });
    }, [r, t, a]), [d, p] = Cc(
      r,
      o.typemap || {}
    ), m = Mf[(p && o.inputconverter?.[p]) ?? ""] || Mf[""], { Inputrenderer: g } = T.useContext(as), y = d ? r.value_options?.options ? dh : g[d] : void 0;
    return /* @__PURE__ */ S.jsxs("div", { className: "nodesettings-io-entry funcnodes-control-group", children: [
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { htmlFor: `io-name-${r.id}`, children: "Name:" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            id: `io-name-${r.id}`,
            type: "text",
            value: a,
            onChange: c,
            onBlur: u,
            className: "styledinput"
          }
        )
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "ID:" }),
        /* @__PURE__ */ S.jsx("span", { children: r.id })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Value:" }),
        y && /* @__PURE__ */ S.jsx(y, { inputconverter: m })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Type:" }),
        /* @__PURE__ */ S.jsx("pre", { children: JSON.stringify(r.type, null, 2) })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { htmlFor: `io-hidden-${r.id}`, children: "Hidden:" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            id: `io-hidden-${r.id}`,
            type: "checkbox",
            checked: r.hidden,
            onChange: (b) => i?.(b.target.checked),
            className: "styledcheckbox",
            disabled: r.connected && r.is_input
          }
        )
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Value Options:" }),
        /* @__PURE__ */ S.jsx("pre", { children: JSON.stringify(r.value_options, null, 2) })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Render Options:" }),
        /* @__PURE__ */ S.jsx("pre", { className: "code-display", children: JSON.stringify(r.render_options, null, 2) })
      ] }),
      r.is_input && /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
        /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
          /* @__PURE__ */ S.jsx("label", { children: "Does Trigger:" }),
          /* @__PURE__ */ S.jsx("span", { children: String(r.does_trigger) })
        ] }),
        /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
          /* @__PURE__ */ S.jsx("label", { children: "Required:" }),
          /* @__PURE__ */ S.jsx("span", { children: String(r.required) })
        ] })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Emit Value Set:" }),
        /* @__PURE__ */ S.jsx("span", { children: String(r.emit_value_set) })
      ] }),
      /* @__PURE__ */ S.jsx("hr", {})
    ] });
  }, HC = {
    xxs: 0,
    xs: 320,
    s: 480,
    m: 768,
    l: 960,
    xl: 1280,
    xxl: 1920
  }, Y2e = Object.entries(HC).sort(
    ([, e], [, t]) => t - e
  ), SH = T.createContext(void 0), X2e = (e, t) => {
    let n;
    return ((...r) => {
      clearTimeout(n), n = setTimeout(() => e(...r), t);
    });
  }, Z2e = (e) => {
    for (const [t, n] of Y2e)
      if (e >= n)
        return t;
    return "xxs";
  }, _H = T.memo(
    T.forwardRef(
      (e, t) => {
        const { className: n, children: r, ...o } = e, [i, a] = T.useState(
          {
            wKey: "m",
            w: 0,
            h: 0
          }
        ), s = T.useRef(null);
        T.useImperativeHandle(
          t,
          () => s.current,
          []
        );
        const c = T.useCallback((d) => {
          const p = d.width, m = d.height, g = Z2e(p);
          a((y) => y.wKey === g && y.w === p && y.h === m ? y : { wKey: g, w: p, h: m });
        }, []), u = T.useMemo(
          () => X2e(c, 16),
          [c]
        );
        return T.useEffect(() => {
          const d = s.current;
          if (!d)
            return;
          const p = new ResizeObserver((m) => {
            const g = m[0];
            g && u(g.contentRect);
          });
          return c(d.getBoundingClientRect()), p.observe(d), () => {
            p.disconnect();
          };
        }, [c, u]), /* @__PURE__ */ S.jsx(SH.Provider, { value: i, children: /* @__PURE__ */ S.jsx(
          "div",
          {
            ref: s,
            className: `size-context w-${i.wKey} ${n || ""}`.trim(),
            ...o,
            children: r
          }
        ) });
      }
    )
  );
  _H.displayName = "SizeContextContainer";
  const Q2e = () => {
    const e = T.useContext(SH);
    if (!e)
      throw new Error(
        "useSizeContext must be used within a SizeContextContainerContext"
      );
    return e;
  }, J2e = (e, t) => e === t ? !1 : e === "" ? !0 : HC[e] < HC[t], eIe = (e) => {
    const { wKey: t } = Q2e();
    return J2e(t, e);
  }, G3 = (e, t, n = "", r = "") => {
    const o = [];
    return typeof e == "string" ? o.push(`${t}-${e}`) : typeof e == "boolean" ? o.push(e ? n : r) : e && typeof e == "object" && Object.entries(e).forEach(([i, a]) => {
      if (typeof a == "string")
        o.push(
          i === "" ? `${t}-${a}` : `${i}-${t}-${a}`
        );
      else if (typeof a == "boolean") {
        const s = a ? n : r;
        s && o.push(i === "" ? s : `${i}-${s}`);
      }
    }), o.filter(Boolean).join(" ");
  }, el = T.memo(
    ({
      direction: e,
      className: t = "",
      children: n,
      wrap: r = !1,
      grow: o = !1,
      ...i
    }) => {
      const a = "float-container", s = G3(e, "direction"), c = G3(o, "", "grow", "no-grow"), d = [
        a,
        s,
        c,
        typeof r == "boolean" && r ? "flex-wrap" : "",
        t
      ].filter(Boolean).join(" ");
      return /* @__PURE__ */ S.jsx("div", { className: d, ...i, children: n });
    }
  );
  el.displayName = "FloatContainer";
  const tIe = {
    up: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" }),
    down: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" }),
    left: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" }),
    right: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" })
  }, nIe = {
    up: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" }),
    down: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" }),
    left: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" }),
    right: (e) => /* @__PURE__ */ S.jsx(S.Fragment, { children: "" })
  }, KA = T.memo(
    ({
      direction: e,
      expanded: t = !0,
      children: n,
      className: r,
      maxSize: o = "18.75rem",
      expanderSize: i = "2rem",
      containerStyle: a,
      style: s,
      containerClassName: c,
      expandIcons: u,
      collapseIcons: d,
      onExpandChange: p,
      ...m
    }) => {
      const [g, y] = T.useState(t);
      T.useEffect(() => {
        y(t);
      }, [t]);
      const b = T.useCallback(() => {
        y(($) => {
          const L = !$;
          return p?.(L), L;
        });
      }, [p]), v = T.useCallback(
        ($) => {
          ($.key === "Enter" || $.key === " ") && ($.preventDefault(), b());
        },
        [b]
      ), x = e === "right" || e === "left", E = e === "left" || e === "up", _ = g ? d?.[e] || nIe[e] : u?.[e] || tIe[e], C = `${e} ${g ? "expanded" : "collapsed"}`, k = T.useMemo(
        () => ({
          [x ? "width" : "height"]: g ? o : i
        }),
        [x, g, o, i]
      ), A = T.useMemo(
        () => ({
          [x ? "width" : "height"]: g ? o : 0
        }),
        [x, g, o]
      ), O = T.useMemo(
        () => ({
          [x ? "width" : "height"]: i
        }),
        [x, i]
      ), P = /* @__PURE__ */ S.jsx(
        "div",
        {
          className: `expanding_container_content ${C} ${r || ""}`.trim(),
          style: { ...s, ...A },
          ...m,
          children: n
        }
      ), I = /* @__PURE__ */ S.jsx(
        "div",
        {
          className: `expanding_container_expander ${C}`,
          onClick: b,
          onKeyDown: v,
          style: O,
          role: "button",
          tabIndex: 0,
          "aria-label": `${g ? "Collapse" : "Expand"} ${e}`,
          children: /* @__PURE__ */ S.jsx(_, {})
        }
      );
      return /* @__PURE__ */ S.jsxs(
        "div",
        {
          className: `expanding_container ${C} ${c || ""}`,
          style: { ...a, ...k },
          children: [
            E ? I : P,
            E ? P : I
          ]
        }
      );
    }
  );
  KA.displayName = "ExpandingContainer";
  const rIe = ({ nodestore: e }) => {
    const t = e.use();
    return /* @__PURE__ */ S.jsx(i1.Provider, { value: e, children: /* @__PURE__ */ S.jsxs("div", { className: "nodesettings_content", children: [
      /* @__PURE__ */ S.jsx("div", { className: "nodesettings_section", children: /* @__PURE__ */ S.jsxs("div", { className: "nodesettings_component", children: [
        /* @__PURE__ */ S.jsx("div", { children: "Name" }),
        /* @__PURE__ */ S.jsx("div", { children: /* @__PURE__ */ S.jsx(QA, {}) })
      ] }) }),
      /* @__PURE__ */ S.jsxs("div", { className: "nodesettings_section", children: [
        /* @__PURE__ */ S.jsx("div", { children: "Inputs" }),
        t.inputs.map((n) => {
          const r = e.io_stores.get(n);
          if (r)
            return /* @__PURE__ */ S.jsx(cl.Provider, { value: r, children: /* @__PURE__ */ S.jsx(G2e, {}) }, n);
        })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "nodesettings_section", children: [
        /* @__PURE__ */ S.jsx("div", { children: "Outputs" }),
        t.outputs.map((n) => {
          const r = e.io_stores.get(n);
          if (r)
            return /* @__PURE__ */ S.jsx(cl.Provider, { value: r, children: /* @__PURE__ */ S.jsx(K2e, {}) }, n);
        })
      ] })
    ] }) });
  }, oIe = () => {
    const e = Vt(), t = e.local_state((r) => r.selected_nodes);
    if (t.length === 0)
      return /* @__PURE__ */ S.jsx("div", { children: "Node Settings" });
    if (t.length > 1)
      return /* @__PURE__ */ S.jsx("div", { children: "Multiple Nodes Selected" });
    const n = e.nodespace.get_node(t[0]);
    return n ? /* @__PURE__ */ S.jsx(rIe, { nodestore: n }) : /* @__PURE__ */ S.jsx("div", { children: "Node not found" });
  }, iIe = () => {
    const e = Vt(), t = e.local_settings(
      (r) => r.view_settings.expand_node_props
    ), n = (r) => {
      e.update_view_settings({ expand_node_props: r });
    };
    return /* @__PURE__ */ S.jsx(
      KA,
      {
        direction: "left",
        expanded: t === void 0 ? !1 : t,
        containerClassName: "pos-right pos-top bg1 h-12",
        className: "nodesettings_content",
        onExpandChange: n,
        collapseIcons: {
          up: u0,
          down: Jp,
          left: Qp,
          right: c0
        },
        expandIcons: {
          up: Jp,
          down: u0,
          left: c0,
          right: Qp
        },
        children: /* @__PURE__ */ S.jsx(oIe, {})
      }
    );
  };
  var Z_ = "rovingFocusGroup.onEntryFocus", aIe = { bubbles: !1, cancelable: !0 }, ym = "RovingFocusGroup", [qC, EH, sIe] = Lb(ym), [lIe, I1] = Qi(
    ym,
    [sIe]
  ), [cIe, uIe] = lIe(ym), CH = T.forwardRef(
    (e, t) => /* @__PURE__ */ S.jsx(qC.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ S.jsx(qC.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ S.jsx(fIe, { ...e, ref: t }) }) })
  );
  CH.displayName = ym;
  var fIe = T.forwardRef((e, t) => {
    const {
      __scopeRovingFocusGroup: n,
      orientation: r,
      loop: o = !1,
      dir: i,
      currentTabStopId: a,
      defaultCurrentTabStopId: s,
      onCurrentTabStopIdChange: c,
      onEntryFocus: u,
      preventScrollOnEntryFocus: d = !1,
      ...p
    } = e, m = T.useRef(null), g = un(t, m), y = s1(i), [b, v] = hl({
      prop: a,
      defaultProp: s ?? null,
      onChange: c,
      caller: ym
    }), [x, E] = T.useState(!1), _ = qr(u), C = EH(n), k = T.useRef(!1), [A, O] = T.useState(0);
    return T.useEffect(() => {
      const P = m.current;
      if (P)
        return P.addEventListener(Z_, _), () => P.removeEventListener(Z_, _);
    }, [_]), /* @__PURE__ */ S.jsx(
      cIe,
      {
        scope: n,
        orientation: r,
        dir: y,
        loop: o,
        currentTabStopId: b,
        onItemFocus: T.useCallback(
          (P) => v(P),
          [v]
        ),
        onItemShiftTab: T.useCallback(() => E(!0), []),
        onFocusableItemAdd: T.useCallback(
          () => O((P) => P + 1),
          []
        ),
        onFocusableItemRemove: T.useCallback(
          () => O((P) => P - 1),
          []
        ),
        children: /* @__PURE__ */ S.jsx(
          xt.div,
          {
            tabIndex: x || A === 0 ? -1 : 0,
            "data-orientation": r,
            ...p,
            ref: g,
            style: { outline: "none", ...e.style },
            onMouseDown: Le(e.onMouseDown, () => {
              k.current = !0;
            }),
            onFocus: Le(e.onFocus, (P) => {
              const I = !k.current;
              if (P.target === P.currentTarget && I && !x) {
                const $ = new CustomEvent(Z_, aIe);
                if (P.currentTarget.dispatchEvent($), !$.defaultPrevented) {
                  const L = C().filter((F) => F.focusable), N = L.find((F) => F.active), U = L.find((F) => F.id === b), V = [N, U, ...L].filter(
                    Boolean
                  ).map((F) => F.ref.current);
                  AH(V, d);
                }
              }
              k.current = !1;
            }),
            onBlur: Le(e.onBlur, () => E(!1))
          }
        )
      }
    );
  }), kH = "RovingFocusGroupItem", TH = T.forwardRef(
    (e, t) => {
      const {
        __scopeRovingFocusGroup: n,
        focusable: r = !0,
        active: o = !1,
        tabStopId: i,
        children: a,
        ...s
      } = e, c = Vi(), u = i || c, d = uIe(kH, n), p = d.currentTabStopId === u, m = EH(n), { onFocusableItemAdd: g, onFocusableItemRemove: y, currentTabStopId: b } = d;
      return T.useEffect(() => {
        if (r)
          return g(), () => y();
      }, [r, g, y]), /* @__PURE__ */ S.jsx(
        qC.ItemSlot,
        {
          scope: n,
          id: u,
          focusable: r,
          active: o,
          children: /* @__PURE__ */ S.jsx(
            xt.span,
            {
              tabIndex: p ? 0 : -1,
              "data-orientation": d.orientation,
              ...s,
              ref: t,
              onMouseDown: Le(e.onMouseDown, (v) => {
                r ? d.onItemFocus(u) : v.preventDefault();
              }),
              onFocus: Le(e.onFocus, () => d.onItemFocus(u)),
              onKeyDown: Le(e.onKeyDown, (v) => {
                if (v.key === "Tab" && v.shiftKey) {
                  d.onItemShiftTab();
                  return;
                }
                if (v.target !== v.currentTarget) return;
                const x = hIe(v, d.orientation, d.dir);
                if (x !== void 0) {
                  if (v.metaKey || v.ctrlKey || v.altKey || v.shiftKey) return;
                  v.preventDefault();
                  let _ = m().filter((C) => C.focusable).map((C) => C.ref.current);
                  if (x === "last") _.reverse();
                  else if (x === "prev" || x === "next") {
                    x === "prev" && _.reverse();
                    const C = _.indexOf(v.currentTarget);
                    _ = d.loop ? mIe(_, C + 1) : _.slice(C + 1);
                  }
                  setTimeout(() => AH(_));
                }
              }),
              children: typeof a == "function" ? a({ isCurrentTabStop: p, hasTabStop: b != null }) : a
            }
          )
        }
      );
    }
  );
  TH.displayName = kH;
  var dIe = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last"
  };
  function pIe(e, t) {
    return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
  }
  function hIe(e, t, n) {
    const r = pIe(e.key, n);
    if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
      return dIe[r];
  }
  function AH(e, t = !1) {
    const n = document.activeElement;
    for (const r of e)
      if (r === n || (r.focus({ preventScroll: t }), document.activeElement !== n)) return;
  }
  function mIe(e, t) {
    return e.map((n, r) => e[(t + r) % e.length]);
  }
  var RH = CH, OH = TH, $1 = "Tabs", [gIe] = Qi($1, [
    I1
  ]), MH = I1(), [yIe, YA] = gIe($1), NH = T.forwardRef(
    (e, t) => {
      const {
        __scopeTabs: n,
        value: r,
        onValueChange: o,
        defaultValue: i,
        orientation: a = "horizontal",
        dir: s,
        activationMode: c = "automatic",
        ...u
      } = e, d = s1(s), [p, m] = hl({
        prop: r,
        onChange: o,
        defaultProp: i ?? "",
        caller: $1
      });
      return /* @__PURE__ */ S.jsx(
        yIe,
        {
          scope: n,
          baseId: Vi(),
          value: p,
          onValueChange: m,
          orientation: a,
          dir: d,
          activationMode: c,
          children: /* @__PURE__ */ S.jsx(
            xt.div,
            {
              dir: d,
              "data-orientation": a,
              ...u,
              ref: t
            }
          )
        }
      );
    }
  );
  NH.displayName = $1;
  var PH = "TabsList", IH = T.forwardRef(
    (e, t) => {
      const { __scopeTabs: n, loop: r = !0, ...o } = e, i = YA(PH, n), a = MH(n);
      return /* @__PURE__ */ S.jsx(
        RH,
        {
          asChild: !0,
          ...a,
          orientation: i.orientation,
          dir: i.dir,
          loop: r,
          children: /* @__PURE__ */ S.jsx(
            xt.div,
            {
              role: "tablist",
              "aria-orientation": i.orientation,
              ...o,
              ref: t
            }
          )
        }
      );
    }
  );
  IH.displayName = PH;
  var $H = "TabsTrigger", jH = T.forwardRef(
    (e, t) => {
      const { __scopeTabs: n, value: r, disabled: o = !1, ...i } = e, a = YA($H, n), s = MH(n), c = LH(a.baseId, r), u = zH(a.baseId, r), d = r === a.value;
      return /* @__PURE__ */ S.jsx(
        OH,
        {
          asChild: !0,
          ...s,
          focusable: !o,
          active: d,
          children: /* @__PURE__ */ S.jsx(
            xt.button,
            {
              type: "button",
              role: "tab",
              "aria-selected": d,
              "aria-controls": u,
              "data-state": d ? "active" : "inactive",
              "data-disabled": o ? "" : void 0,
              disabled: o,
              id: c,
              ...i,
              ref: t,
              onMouseDown: Le(e.onMouseDown, (p) => {
                !o && p.button === 0 && p.ctrlKey === !1 ? a.onValueChange(r) : p.preventDefault();
              }),
              onKeyDown: Le(e.onKeyDown, (p) => {
                [" ", "Enter"].includes(p.key) && a.onValueChange(r);
              }),
              onFocus: Le(e.onFocus, () => {
                const p = a.activationMode !== "manual";
                !d && !o && p && a.onValueChange(r);
              })
            }
          )
        }
      );
    }
  );
  jH.displayName = $H;
  var DH = "TabsContent", FH = T.forwardRef(
    (e, t) => {
      const { __scopeTabs: n, value: r, forceMount: o, children: i, ...a } = e, s = YA(DH, n), c = LH(s.baseId, r), u = zH(s.baseId, r), d = r === s.value, p = T.useRef(d);
      return T.useEffect(() => {
        const m = requestAnimationFrame(() => p.current = !1);
        return () => cancelAnimationFrame(m);
      }, []), /* @__PURE__ */ S.jsx(ii, { present: o || d, children: ({ present: m }) => /* @__PURE__ */ S.jsx(
        xt.div,
        {
          "data-state": d ? "active" : "inactive",
          "data-orientation": s.orientation,
          role: "tabpanel",
          "aria-labelledby": c,
          hidden: !m,
          id: u,
          tabIndex: 0,
          ...a,
          ref: t,
          style: {
            ...e.style,
            animationDuration: p.current ? "0s" : void 0
          },
          children: m && i
        }
      ) });
    }
  );
  FH.displayName = DH;
  function LH(e, t) {
    return `${e}-trigger-${t}`;
  }
  function zH(e, t) {
    return `${e}-content-${t}`;
  }
  var XA = NH, ZA = IH, Bp = jH, Up = FH;
  const vIe = ({}) => {
    const e = Vt(), t = mo(), { description: n, id: r, node_id: o, node_name: i, reset_inputs_on_trigger: a } = t.useShallow((p) => ({
      description: p.description,
      id: p.id,
      node_id: p.node_id,
      node_name: p.node_name,
      reset_inputs_on_trigger: p.reset_inputs_on_trigger
    })), [s, c] = T.useState(
      n || ""
    );
    T.useEffect(() => c(n || ""), [n]);
    const u = (p) => c(p.target.value), d = () => {
      s !== (n || "") && e.on_node_action({
        type: "update",
        from_remote: !1,
        id: r,
        node: { description: s }
      });
    };
    return /* @__PURE__ */ S.jsxs("div", { className: "nodesettings-section funcnodes-control-group", children: [
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { htmlFor: `node-name-${r}`, children: "Name:" }),
        /* @__PURE__ */ S.jsx(QA, {})
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Instance ID:" }),
        /* @__PURE__ */ S.jsx("span", { children: r })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Node Type ID:" }),
        /* @__PURE__ */ S.jsx("span", { children: o })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Node Type Name:" }),
        /* @__PURE__ */ S.jsx("span", { children: i })
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { htmlFor: `node-desc-${r}`, children: "Description:" }),
        /* @__PURE__ */ S.jsx(
          "textarea",
          {
            id: `node-desc-${r}`,
            value: s,
            onChange: u,
            onBlur: d,
            className: "styledinput",
            rows: 3
          }
        )
      ] }),
      /* @__PURE__ */ S.jsxs("div", { className: "funcnodes-control-row", children: [
        /* @__PURE__ */ S.jsx("label", { children: "Reset Inputs on Trigger:" }),
        /* @__PURE__ */ S.jsx(
          "input",
          {
            type: "checkbox",
            checked: a,
            onChange: (p) => {
              e.on_node_action({
                type: "update",
                from_remote: !1,
                id: r,
                node: { reset_inputs_on_trigger: p.target.checked }
              });
            },
            className: "styledcheckbox"
          }
        )
      ] })
    ] });
  }, bIe = ({ splitnodesettingsPath: e = [] }) => {
    const t = mo(), n = t.use((r) => r.inputs);
    return /* @__PURE__ */ S.jsxs(
      XA,
      {
        defaultValue: e[0] || n[0],
        className: "nodesettings-tabs funcnodes-control-root",
        children: [
          /* @__PURE__ */ S.jsx(
            ZA,
            {
              className: "nodesettings-tabs-list",
              "aria-label": "Manage node inputs",
              children: n.map((r) => /* @__PURE__ */ S.jsx(
                Bp,
                {
                  value: r,
                  className: "nodesettings-tabs-trigger",
                  children: r
                },
                r
              ))
            }
          ),
          n.map((r) => {
            const o = t.io_stores.get(r);
            return /* @__PURE__ */ S.jsx(
              Up,
              {
                value: r,
                className: "nodesettings-tabs-content nodesettings-io-list",
                children: o && /* @__PURE__ */ S.jsx(cl.Provider, { value: o, children: /* @__PURE__ */ S.jsx(wH, {}) })
              },
              r
            );
          })
        ]
      }
    );
  }, xIe = ({ splitnodesettingsPath: e = [] }) => {
    const t = mo(), n = t.use((r) => r.outputs);
    return /* @__PURE__ */ S.jsxs(
      XA,
      {
        defaultValue: e[0] || n[0],
        className: "nodesettings-tabs funcnodes-control-root",
        children: [
          /* @__PURE__ */ S.jsx(
            ZA,
            {
              className: "nodesettings-tabs-list",
              "aria-label": "Manage node outputs",
              children: n.map((r) => /* @__PURE__ */ S.jsx(
                Bp,
                {
                  value: r,
                  className: "nodesettings-tabs-trigger",
                  children: r
                },
                r
              ))
            }
          ),
          n.map((r) => {
            const o = t.io_stores.get(r);
            return /* @__PURE__ */ S.jsx(
              Up,
              {
                value: r,
                className: "nodesettings-tabs-content nodesettings-io-list",
                children: o && /* @__PURE__ */ S.jsx(cl.Provider, { value: o, children: /* @__PURE__ */ S.jsx(wH, {}) })
              },
              r
            );
          })
        ]
      }
    );
  }, wIe = ({
    nodeSettingsPath: e
  }) => {
    const t = e.split("/") || ["general"];
    return /* @__PURE__ */ S.jsxs(
      XA,
      {
        defaultValue: t[0] || "general",
        className: "nodesettings-tabs funcnodes-control-root",
        children: [
          /* @__PURE__ */ S.jsxs(
            ZA,
            {
              className: "nodesettings-tabs-list",
              "aria-label": "Manage node settings",
              children: [
                /* @__PURE__ */ S.jsx(Bp, { value: "general", className: "nodesettings-tabs-trigger", children: "General" }),
                /* @__PURE__ */ S.jsx(Bp, { value: "inputs", className: "nodesettings-tabs-trigger", children: "Inputs" }),
                /* @__PURE__ */ S.jsx(Bp, { value: "outputs", className: "nodesettings-tabs-trigger", children: "Outputs" })
              ]
            }
          ),
          /* @__PURE__ */ S.jsx(Up, { value: "general", className: "nodesettings-tabs-content", children: /* @__PURE__ */ S.jsx(vIe, {}) }),
          /* @__PURE__ */ S.jsx(
            Up,
            {
              value: "inputs",
              className: "nodesettings-tabs-content nodesettings-io-list",
              children: /* @__PURE__ */ S.jsx(
                bIe,
                {
                  splitnodesettingsPath: (
                    // all but first element
                    t.slice(1)
                  )
                }
              )
            }
          ),
          /* @__PURE__ */ S.jsx(
            Up,
            {
              value: "outputs",
              className: "nodesettings-tabs-content nodesettings-io-list",
              children: /* @__PURE__ */ S.jsx(
                xIe,
                {
                  splitnodesettingsPath: (
                    // all but first element
                    t.slice(1)
                  )
                }
              )
            }
          )
        ]
      }
    );
  }, SIe = T.memo(
    ({ isOpen: e, onOpenChange: t, nodeSettingsPath: n }) => {
      const o = mo().use((i) => i.id);
      return /* @__PURE__ */ S.jsx(
        Ji,
        {
          title: `Node Settings: ${o}`,
          open: e,
          onOpenChange: t,
          dialogClassName: "nodesettings-dialog",
          children: /* @__PURE__ */ S.jsx(wIe, { nodeSettingsPath: n })
        }
      );
    }
  ), _Ie = T.memo(({ toogleShowSettings: e }) => {
    const t = Vt(), { node: n } = Rr(), r = mo(), { id: o, description: i, node_name: a } = r.useShallow((c) => ({
      id: c.id,
      description: c.description,
      node_name: c.node_name
    })), s = T.useCallback(() => {
      t.on_node_action({
        type: "trigger",
        from_remote: !1,
        id: o
      });
    }, [t, o]);
    return /* @__PURE__ */ S.jsxs("div", { className: "nodeheader", title: i || a, children: [
      /* @__PURE__ */ S.jsxs("div", { className: "nodeheader_element", children: [
        /* @__PURE__ */ S.jsx(
          qoe,
          {
            fontSize: "inherit",
            className: "triggerbutton nodeheaderbutton ",
            onClick: s
          }
        ),
        /* @__PURE__ */ S.jsx(
          Hoe,
          {
            fontSize: "inherit",
            className: "nodestatusbutton nodeheaderbutton",
            onClick: async () => {
              n && console.log("nodestatus", await n.get_node_status(o));
            }
          }
        ),
        /* @__PURE__ */ S.jsx(
          Goe,
          {
            fontSize: "inherit",
            className: "nodesettingsbutton nodeheaderbutton",
            onClick: () => {
              e?.();
            }
          }
        )
      ] }),
      /* @__PURE__ */ S.jsx("div", { className: "nodeheader_element nodeheader_title", children: /* @__PURE__ */ S.jsx("div", { className: "nodeheader_title_text", children: a }) }),
      /* @__PURE__ */ S.jsx("div", { className: "nodeheader_element", children: /* @__PURE__ */ S.jsx(Hh, { fontSize: "inherit" }) })
    ] });
  }), EIe = T.memo(({ iostore: e }) => {
    const t = e.use(), r = mo().use((s) => s.render_options), o = im(t.id), [i, a] = U2e(t);
    return /* @__PURE__ */ S.jsx(
      "div",
      {
        className: "nodrag nodedatabody",
        "data-src": r?.data?.src || "",
        children: i && t && /* @__PURE__ */ S.jsx(cl.Provider, { value: e, children: /* @__PURE__ */ S.jsx(
          Ji,
          {
            title: t.full_id,
            trigger: /* @__PURE__ */ S.jsx("div", { className: "nodedatabutton", children: /* @__PURE__ */ S.jsx(xH, { Component: i }) }),
            onOpenChange: (s) => {
              s && o?.();
            },
            children: a && /* @__PURE__ */ S.jsx(bH, { Component: a, iostore: e })
          }
        ) })
      }
    );
  }), CIe = T.memo(
    ({ setShowSettings: e, setNodeSettingsPath: t }) => {
      const n = mo(), { render_options: r, outputs: o, inputs: i } = n.useShallow(
        (s) => ({
          render_options: s.render_options,
          outputs: s.outputs,
          inputs: s.inputs
        })
      ), a = r?.data?.src ? n.io_stores.get(r?.data?.src) : void 0;
      return /* @__PURE__ */ S.jsxs("div", { className: "nodebody nowheel ", children: [
        o.map((s) => {
          const c = n.io_stores.get(s);
          if (c)
            return /* @__PURE__ */ S.jsx(cl.Provider, { value: c, children: /* @__PURE__ */ S.jsx(
              W2e,
              {
                setNodeSettingsPath: t,
                setShowSettings: e
              }
            ) }, s);
        }),
        a && /* @__PURE__ */ S.jsx(EIe, { iostore: a }),
        i.map((s) => {
          const c = n.io_stores.get(s);
          if (c)
            return /* @__PURE__ */ S.jsx(cl.Provider, { value: c, children: /* @__PURE__ */ S.jsx(
              q2e,
              {
                setNodeSettingsPath: t,
                setShowSettings: e
              }
            ) }, s);
        })
      ] });
    }
  ), QA = () => {
    const e = mo(), { original_name: t, id: n } = e.useShallow((c) => ({
      original_name: c.name,
      id: c.id
    })), [r, o] = T.useState(t);
    T.useEffect(() => {
      o(t);
    }, [t]);
    const i = Vt(), a = (c) => {
      o(c.target.value);
    }, s = (c) => {
      const u = c.target.value;
      u !== t && i.on_node_action({
        type: "update",
        from_remote: !1,
        id: n,
        node: { name: u }
      });
    };
    return /* @__PURE__ */ S.jsx(
      "input",
      {
        className: "nodename_input",
        value: r,
        onChange: a,
        onBlur: s
      }
    );
  }, kIe = () => {
    const t = mo().use((n) => n.progress);
    return t ? /* @__PURE__ */ S.jsx(
      $ce,
      {
        state: t,
        className: "nodeprogress"
      }
    ) : null;
  }, TIe = T.memo(() => {
    const t = mo().use((n) => n.error);
    return /* @__PURE__ */ S.jsxs("div", { className: "nodefooter", children: [
      t && /* @__PURE__ */ S.jsx("div", { className: "nodeerror", children: t }),
      /* @__PURE__ */ S.jsx(kIe, {})
    ] });
  }), AIe = () => {
    const e = mo(), { collapsed: t, error: n, node_id: r } = e.useShallow((y) => ({
      collapsed: y.properties["frontend:collapsed"] || !1,
      error: y.error,
      node_id: y.node_id
    })), { visualTrigger: o } = H2e(e), [i, a] = T.useState(!1), [s, c] = T.useState(""), { keys: u } = Zk(), p = T.useContext(as).NodeHooks[r] ?? [], m = T.useCallback(() => {
      a((y) => !y);
    }, []), g = (y) => {
      u.has("s") && !i && (c(""), a(!0), y.stopPropagation());
    };
    return /* @__PURE__ */ S.jsxs(
      "div",
      {
        className: "innernode" + (o ? " intrigger" : "") + (n ? " error" : ""),
        onClick: g,
        children: [
          /* @__PURE__ */ S.jsx(_Ie, { toogleShowSettings: m }),
          /* @__PURE__ */ S.jsx(QA, {}),
          t ? null : /* @__PURE__ */ S.jsx(
            CIe,
            {
              setNodeSettingsPath: c,
              setShowSettings: a
            }
          ),
          /* @__PURE__ */ S.jsx(TIe, {}),
          /* @__PURE__ */ S.jsx(
            SIe,
            {
              isOpen: i,
              onOpenChange: a,
              nodeSettingsPath: s
            }
          ),
          p.map((y, b) => /* @__PURE__ */ S.jsx(T.Fragment, { children: /* @__PURE__ */ S.jsx(y, {}) }, b))
        ]
      }
    );
  }, RIe = T.memo(
    ({ data: e }) => /* @__PURE__ */ S.jsx(i1.Provider, { value: e.nodestore, children: /* @__PURE__ */ S.jsx(AIe, {}) }),
    (e, t) => e.data.nodestore === t.data.nodestore
  ), OIe = ({
    id: e,
    sourceX: t,
    sourceY: n,
    targetX: r,
    targetY: o,
    sourcePosition: i,
    targetPosition: a,
    data: s,
    ...c
  }) => {
    const [u] = IT({
      sourceX: t,
      sourceY: n,
      sourcePosition: i,
      targetX: r,
      targetY: o,
      targetPosition: a
    });
    return /* @__PURE__ */ S.jsx(S.Fragment, { children: /* @__PURE__ */ S.jsx(om, { id: e, path: u, ...c }) });
  }, MIe = {
    default: RIe,
    group: N0e
  }, NIe = {
    default: OIe
  }, PIe = (e) => ({
    nodes: e.getNodes(),
    edges: e.getEdges(),
    onNodesChange: e.onNodesChange,
    onEdgesChange: e.onEdgesChange,
    onConnect: e.onConnect
  }), JA = (e) => {
    const t = /* @__PURE__ */ new Set(), n = e.filter(
      (o) => o.type === "group"
    );
    n.forEach((o) => {
      t.add(o.id);
    });
    const r = e.filter(
      (o) => !t.has(o.id)
    );
    return { group_nodes: n, default_nodes: r };
  };
  function eR(e) {
    const t = new Map(e.map((a) => [a.id, a])), n = /* @__PURE__ */ new Map(), r = [];
    for (const a of e)
      if (n.has(a.id) || n.set(a.id, []), a.parentId && t.has(a.parentId)) {
        const s = t.get(a.parentId);
        if (s) {
          const c = n.get(s.id) || [];
          c.push(a), n.set(s.id, c);
        } else
          r.push(a);
      } else
        r.push(a);
    const o = [];
    function i(a) {
      o.push(a);
      const s = n.get(a.id) || [];
      for (const c of s)
        i(c);
    }
    for (const a of r)
      i(a);
    if (o.length !== e.length) {
      console.warn(
        "Sorting mismatch: Not all nodes could be placed. Check for circular dependencies or missing parents."
      );
      const a = new Set(o.map((s) => s.id));
      e.forEach((s) => {
        a.has(s.id) || o.push(s);
      });
    }
    return o;
  }
  const BH = () => {
    const { getNodes: e } = Ec();
    return {
      getNodes: e,
      getSelectedNodes: (o) => (o === void 0 && (o = e()), o.filter((i) => i.selected)),
      getSplitNodes: (o) => {
        o === void 0 && (o = e());
        const { group_nodes: i, default_nodes: a } = JA(o);
        return { group_nodes: i, default_nodes: a };
      },
      getSortedNodes: (o) => (o === void 0 && (o = e()), eR(o))
    };
  }, UH = (e, t) => {
    const n = e.getState(), { new_obj: r, change: o } = tl(n, t);
    o && e.setState(r);
  }, VH = (e) => No(e);
  function K3(e) {
    return e != null && typeof e == "object" && "id" in e && typeof e.id == "string";
  }
  const HH = (e) => {
    let t = e.io ?? {}, n = e.io_order, r = [];
    const o = {};
    if (n === void 0)
      if (Array.isArray(t)) {
        const i = t.filter(K3);
        r = i.map((a) => a.id);
        for (const a of i)
          o[a.id] = a;
      } else {
        r = Object.keys(t);
        for (const i in t)
          t[i] !== void 0 && (o[i] = t[i]);
      }
    else if (r = n, Array.isArray(t)) {
      const i = t.filter(K3);
      for (const a of i)
        o[a.id] = a, r.includes(a.id) || r.push(a.id);
    } else
      for (const i in t)
        t[i] !== void 0 && (o[i] = t[i]), r.includes(i) || r.push(i);
    return { ...e, io_order: r, io: o };
  }, IIe = {
    id: "dummy",
    node_id: "dummy",
    node_name: "dummy",
    properties: {
      "frontend:size": [200, 100],
      "frontend:pos": [NaN, NaN],
      "frontend:collapsed": !1
    },
    io: {},
    io_order: [],
    name: "dummy",
    in_trigger: !1,
    reset_inputs_on_trigger: !1,
    progress: {
      ascii: !1,
      elapsed: 0,
      initial: 0,
      n: 0,
      prefix: "idle",
      unit: "it",
      unit_divisor: 1e3,
      unit_scale: !1
    }
  }, $Ie = {
    id: "dummy",
    name: "dummy",
    node: "dummy",
    full_id: "dummy",
    type: "any",
    value: void 0,
    is_input: !1,
    connected: !1,
    does_trigger: !0,
    fullvalue: void 0,
    render_options: {
      set_default: !0,
      type: "any"
    },
    hidden: !1,
    emit_value_set: !0,
    required: !1
  }, jIe = Z0(IIe), DIe = Z0($Ie), FIe = (e) => {
    const t = e.io_order;
    if (t === void 0)
      throw new Error("Node must have io_order");
    return {
      ...e,
      inputs: Object.keys(e.io).filter((r) => e.io[r].is_input),
      outputs: Object.keys(e.io).filter((r) => !e.io[r].is_input),
      io_order: t
    };
  }, LIe = (e) => (e.value === "<NoValue>" && (e.value = void 0), e.fullvalue === "<NoValue>" && (e.fullvalue = void 0), e.hidden === void 0 && (e.hidden = !1), [{
    ...e
  }, e.value, e.fullvalue]), zIe = (e) => {
    if (!e.id)
      throw new Error("Node must have an id");
    const t = jIe(e);
    return FIe(t);
  }, BIe = (e, t) => {
    const n = e.getState(), r = {}, o = HH(t), i = Object.keys(o);
    for (const a of i)
      switch (a) {
        case "id": {
          const [s, c] = To(
            n[a],
            o[a]
          );
          c && (r[a] = s);
          break;
        }
        case "node_id": {
          const [s, c] = To(
            n[a],
            o[a]
          );
          c && (r[a] = s);
          break;
        }
        case "node_name": {
          const [s, c] = To(
            n[a],
            o[a]
          );
          c && (r[a] = s);
          break;
        }
        case "name": {
          const [s, c] = To(
            n[a],
            o[a]
          );
          c && (r[a] = s);
          break;
        }
        case "in_trigger": {
          const [s, c] = To(
            n[a],
            o[a]
          );
          c && (r[a] = s);
          break;
        }
        case "error": {
          o[a] !== n[a] && (r[a] = o[a]);
          break;
        }
        case "render_options": {
          const [s, c] = qu(
            n[a],
            o[a]
          );
          c && (r[a] = s);
          break;
        }
        case "io_order": {
          const [s, c] = ((u, d) => d === void 0 ? [u, !1] : [d, !sk(u, d)])(n[a], o[a]);
          c && (r[a] = s.filter((u) => u !== void 0));
          break;
        }
        case "io": {
          const s = o[a];
          if (s === void 0) break;
          for (const c in s) {
            const u = e.io_stores.get(c);
            if (!u) {
              console.error("io key not found in oldvalue:", c);
              continue;
            }
            u.update(s[c]);
          }
          break;
        }
        case "progress": {
          const [s, c] = qu(
            n[a],
            o[a]
          );
          c && (r[a] = s);
          break;
        }
        case "description": {
          r[a] = o[a];
          break;
        }
        case "properties": {
          const [s, c] = qu(
            n[a],
            o[a]
          );
          c && (r[a] = s);
          break;
        }
        case "status": {
          const [s, c] = qu(
            n[a],
            o[a]
          );
          c && (r[a] = s);
          break;
        }
        case "reset_inputs_on_trigger": {
          const [s, c] = To(
            n[a],
            o[a]
          );
          c && (r[a] = s);
          break;
        }
        default:
          try {
            q4(a, o[a]);
          } catch (s) {
            console.error(s);
          }
      }
    Object.keys(r).length > 0 && e.setState(r);
  }, UIe = (e, t) => {
    const n = e.getState(), r = {}, o = {}, i = Object.keys(t);
    for (const a of i)
      switch (a) {
        case "name": {
          const [s, c] = To(
            n[a],
            t[a]
          );
          c && (r[a] = s);
          break;
        }
        case "id": {
          const [s, c] = To(
            n[a],
            t[a]
          );
          c && (r[a] = s);
          break;
        }
        case "connected": {
          const [s, c] = To(
            n[a],
            t[a]
          );
          c && (r[a] = s);
          break;
        }
        case "does_trigger": {
          const [s, c] = To(
            n[a],
            t[a]
          );
          c && (r[a] = s);
          break;
        }
        case "hidden": {
          const [s, c] = To(
            n[a],
            t[a]
          );
          c && (r[a] = s);
          break;
        }
        case "full_id": {
          const [s, c] = To(
            n[a],
            t[a]
          );
          c && (r[a] = s);
          break;
        }
        case "is_input":
          break;
        case "node":
          break;
        case "type":
          break;
        case "value": {
          o.preview = t[a];
          break;
        }
        case "fullvalue": {
          o.full = t[a];
          break;
        }
        case "render_options": {
          const [s, c] = qu(
            n[a],
            t[a]
          );
          c && (r[a] = s);
          break;
        }
        case "value_options": {
          const [s, c] = qu(
            n[a],
            t[a]
          );
          c && (r[a] = s);
          break;
        }
        case "valuepreview_type": {
          r[a] = t[a];
          break;
        }
        case "emit_value_set": {
          r[a] = t[a];
          break;
        }
        case "default": {
          r[a] = t[a];
          break;
        }
        case "required": {
          r[a] = t[a];
          break;
        }
        default:
          try {
            q4(a, t[a]);
          } catch (s) {
            console.error(s);
          }
      }
    Object.keys(o).length > 0 && e.updateValueStore(o), Object.keys(r).length > 0 && e.setState(r);
  }, VIe = (e) => {
    if (!e.id)
      throw new Error(
        "IO must have an id but is missing for " + JSON.stringify(e)
      );
    e.name === void 0 && (e.name = e.id);
    const t = DIe(e);
    return (t.render_options.type === "any" || t.render_options.type === void 0) && (t.render_options.type = t.type), LIe(t);
  }, HIe = (e, t) => {
    let n;
    const [r, o, i] = VIe(t);
    return n = {
      io_state: VH((a, s) => r),
      use: (a) => a ? n.io_state(a) : n.io_state(),
      useShallow: (a) => n.io_state(UT(a)),
      getState: () => n.io_state.getState(),
      setState: (a) => {
        n.io_state.setState(a);
      },
      update: (a) => {
        UIe(n, a);
      },
      valuestore: No((a, s) => {
        let c = o;
        c === "<NoValue>" && (c = void 0), !(c instanceof Pi) && c !== void 0 && (c = Ks.fromObject(c));
        let u = i;
        return u === "<NoValue>" && (u = void 0), !(u instanceof Pi) && u !== void 0 && (u = Ks.fromObject(u)), {
          preview: c,
          full: u
        };
      }),
      updateValueStore: (a) => {
        n.valuestore.setState((s) => (s.preview && typeof s.preview.dispose == "function" && s.preview.dispose(), s.full && typeof s.full.dispose == "function" && s.full.dispose(), a.preview !== void 0 && a.full === void 0 && (a.full = void 0, s.full = void 0), a.preview !== void 0 && !(a.preview instanceof Pi) && (a.preview = Ks.fromObject(a.preview)), a.full !== void 0 && !(a.full instanceof Pi) && (a.full = Ks.fromObject(a.full)), { ...s, ...a }));
      },
      node: e,
      serialize: () => {
        const a = n.io_state.getState(), s = n.valuestore.getState();
        return {
          ...a,
          value: s.preview,
          fullvalue: s.full,
          render_options: a.render_options,
          valuepreview_type: a.valuepreview_type,
          emit_value_set: a.emit_value_set
        };
      }
    }, n;
  }, qIe = (e) => {
    const t = {
      use: (i) => i ? r.node_state(i) : r.node_state(),
      useShallow: (i) => r.node_state(UT(i)),
      io_stores: /* @__PURE__ */ new Map(),
      getState: () => r.node_state.getState(),
      setState: (i) => {
        r.node_state.setState(i);
      },
      update: (i) => {
        BIe(r, i);
      },
      serialize: () => ({
        ...r.node_state.getState(),
        io: Object.fromEntries(
          Array.from(r.io_stores.entries()).map(([s, c]) => [
            s,
            c.serialize()
          ])
        )
      })
    }, n = HH(e), r = {
      ...t,
      node_state: VH((i, a) => zIe(n))
    }, o = n.io;
    return Object.entries(o).forEach(([i, a]) => {
      a !== void 0 && r.io_stores.set(i, HIe(n.id, a));
    }), r;
  }, WIe = () => {
    const e = Vt();
    return {
      onSelectionChange: T.useCallback(
        ({ nodes: n, edges: r }) => {
          const { group_nodes: o, default_nodes: i } = JA(n), a = e.local_state.getState();
          e.local_state.setState({
            ...a,
            selected_nodes: i.map((s) => s.id),
            selected_edges: r.map((s) => s.id),
            selected_groups: o.map((s) => s.id)
          });
        },
        [e]
      )
    };
  }, GIe = () => {
    const e = Ec(), t = Vt();
    return t.rf_instance = e, /* @__PURE__ */ S.jsx(S.Fragment, {});
  }, KIe = () => {
    const e = Vt(), { getEdges: t } = Ec(), { getSelectedNodes: n } = BH();
    return {
      copySelectedNodes: T.useCallback(() => {
        const o = t(), i = n();
        if (i.length === 0) return;
        const a = { nodes: [], edges: [] };
        for (const u of i) {
          const d = e.nodespace.get_node(u.id, !1);
          d && a.nodes.push(d.serialize());
        }
        const s = new Set(i.map((u) => u.id)), c = o.filter(
          (u) => s.has(u.source) && s.has(u.target)
        );
        for (const u of c)
          !u.sourceHandle || !u.targetHandle || a.edges.push({
            src_nid: u.source,
            src_ioid: u.sourceHandle,
            trg_nid: u.target,
            trg_ioid: u.targetHandle
          });
        navigator.clipboard.writeText(JSON.stringify(a));
      }, [n, t, e])
    };
  }, YIe = () => {
    const e = Fa("Delete"), t = Fa(["Meta+c", "Control+c", "Strg+c"]), n = Fa(["Control+g", "Meta+g"]), r = Fa(["Control+Alt+g", "Meta+Alt+g"]), o = O0e(), { getEdges: i } = Ec(), { getNodes: a, getSelectedNodes: s, getSplitNodes: c } = BH(), { copySelectedNodes: u } = KIe(), { node: d, group: p, edge: m } = Rr();
    return T.useEffect(() => {
      if (e) {
        const g = i().filter((x) => x.selected);
        for (const x of g)
          !x.source || !x.target || !x.sourceHandle || !x.targetHandle || m?.remove_edge({
            src_nid: x.source,
            src_ioid: x.sourceHandle,
            trg_nid: x.target,
            trg_ioid: x.targetHandle
          });
        const y = s(), { group_nodes: b, default_nodes: v } = c(y);
        for (const x of v)
          d?.remove_node(x.id);
        for (const x of b)
          p?.remove_group(x.id);
      }
    }, [e, a, i, d, p, m]), T.useEffect(() => {
      t && u();
    }, [t, u]), T.useEffect(() => {
      if (n) {
        const g = s(), { group_nodes: y, default_nodes: b } = c(g);
        g.length > 0 && o(
          b.map((v) => v.id),
          y.map((v) => v.id)
        );
      }
    }, [n, a]), T.useEffect(() => {
      if (r) {
        const g = s(), { group_nodes: y } = c(g);
        y.forEach((b) => {
          p?.remove_group(b.id);
        });
      }
    }, [r, a]), /* @__PURE__ */ S.jsx(S.Fragment, {});
  }, XIe = () => {
    const { node: e, edge: t } = Rr(), n = Vt();
    return T.useCallback(
      async (o, i) => {
        try {
          if (!o || !e || !t) return;
          const a = JSON.parse(o);
          if (!a || !n.worker || !a.nodes) return;
          const s = [0, 0];
          for (const u of a.nodes)
            s[0] += u.properties["frontend:pos"][0], s[1] += u.properties["frontend:pos"][1];
          s[0] /= a.nodes.length, s[1] /= a.nodes.length;
          const c = [];
          for (const u of a.nodes) {
            const d = {
              id: u.node_id,
              src_id: u.id,
              position: [
                u.properties["frontend:pos"][0] - s[0],
                u.properties["frontend:pos"][1] - s[1]
              ]
            };
            c.push(d);
          }
          for (const u of c) {
            const d = await e.add_node(u.id);
            !d || !n.nodespace.get_node(d.id, !1) || (u.new_id = d.id, i([
              {
                id: d.id,
                type: "position",
                position: {
                  x: u.position[0] + d.properties["frontend:pos"][0],
                  y: u.position[1] + d.properties["frontend:pos"][1]
                }
              }
            ]));
          }
          for (const u of a.edges) {
            const d = c.find(
              (m) => m.src_id === u.src_nid
            ), p = c.find(
              (m) => m.src_id === u.trg_nid
            );
            !d || !p || !d.new_id || !p.new_id || t.add_edge({
              src_nid: d.new_id,
              src_ioid: u.src_ioid,
              trg_nid: p.new_id,
              trg_ioid: u.trg_ioid
            });
          }
        } catch (a) {
          console.error("Failed to process pasted data:", a);
        }
      },
      [e, t, n]
    );
  }, ZIe = (e, t) => {
    const n = e.properties || {};
    n["frontend:size"] || (n["frontend:size"] = [200, 100]);
    const r = n["frontend:pos"];
    if (!r || r.length !== 2 || isNaN(r[0]) || r[0] === null || isNaN(r[1]) || r[1] === null)
      if (!t || !t.rf_instance || t.reactflowRef === null)
        n["frontend:pos"] = [0, 0];
      else {
        const i = t.reactflowRef.getBoundingClientRect(), a = i.left + i.width / 2, s = i.top + i.height / 2, c = t.rf_instance.screenToFlowPosition({
          x: a,
          y: s
        });
        n["frontend:pos"] = [
          c.x - n["frontend:size"][0] / 2,
          c.y - n["frontend:size"][0] / 2
        ];
      }
    n["frontend:collapsed"] || (n["frontend:collapsed"] = !1), e.properties = n;
  }, QIe = (e, t) => {
    const n = e.getState();
    if (ZIe(n, t), n.id === void 0)
      throw new Error("Node must have an id");
    const r = {
      nodestore: e
    };
    return {
      position: {
        x: n.properties["frontend:pos"][0],
        y: n.properties["frontend:pos"][1]
      },
      data: r,
      type: "default",
      zIndex: 1003,
      // expandParent: true,
      ...n
    };
  }, Y3 = {
    default: kr.Dots,
    metal: kr.Cross,
    light: kr.Dots,
    solarized: kr.Dots,
    midnight: kr.Dots,
    forest: kr.Dots,
    scientific: kr.Lines
  }, JIe = (e) => {
    const t = Vt(), n = T.useRef(null), { colorTheme: r } = Ez(), { onSelectionChange: o } = WIe(), i = Aue();
    T.useEffect(() => {
      t.getStateManager().toaster = i;
    }, []), T.useEffect(() => {
      t.reactflowRef = n.current;
    }, [n]);
    const { nodes: a, edges: s, onNodesChange: c, onEdgesChange: u, onConnect: d } = t.useReactFlowStore(UT(PIe)), p = XIe(), m = T.useCallback(
      (g) => {
        const y = n.current;
        if (!y) return;
        let b = g.target, v = 0;
        for (; b && b.parentElement && b !== y; )
          v++, b = b.parentElement;
        t.logger.debug(`onPasteCapture: ${v} steps to reactflow`), v <= 2 && p(
          g.clipboardData.getData("text/plain"),
          c
        );
      },
      [p, c, t.logger]
    );
    return /* @__PURE__ */ S.jsx("div", { className: "reactflowlayer", children: /* @__PURE__ */ S.jsxs(
      e0e,
      {
        onPasteCapture: m,
        nodes: a,
        edges: s,
        onNodesChange: c,
        onEdgesChange: u,
        onConnect: d,
        nodeTypes: MIe,
        edgeTypes: NIe,
        minZoom: e.minZoom,
        maxZoom: e.maxZoom,
        fitView: !0,
        onSelectionChange: o,
        ref: n,
        panOnDrag: !e.static,
        children: [
          /* @__PURE__ */ S.jsx(GIe, {}),
          /* @__PURE__ */ S.jsx(YIe, {}),
          /* @__PURE__ */ S.jsx(
            i0e,
            {
              color: "#888",
              gap: 24,
              size: 2,
              variant: Y3[r] || Y3.default,
              patternClassName: "fn-background-pattern"
            }
          ),
          e.minimap && /* @__PURE__ */ S.jsx(
            E0e,
            {
              nodeStrokeWidth: 3,
              pannable: !e.static,
              zoomable: !e.static,
              zoomStep: 3
            }
          )
        ]
      }
    ) });
  }, e$e = ({
    on_node_change: e,
    on_edge_change: t,
    on_connect: n
  }) => {
    const r = e || ((s) => {
    }), o = t || ((s) => {
    }), i = n || ((s) => {
    });
    return No((s, c) => ({
      _nodes: [],
      _edges: [],
      _nodes_map: /* @__PURE__ */ new Map(),
      update_nodes: (u) => {
        u = eR(u), s({
          _nodes: u,
          _nodes_map: new Map(u.map((d) => [d.id, d]))
        });
      },
      partial_update_nodes: (u) => {
        const d = c(), p = d._nodes, m = new Map(
          p.map((g) => [g.id, g])
        );
        for (const g of u)
          m.set(g.id, g);
        d.update_nodes(Array.from(m.values()));
      },
      update_edges: (u) => {
        s({
          _edges: u
        });
      },
      onNodesChange: (u) => {
        const d = c();
        d.update_nodes(zT(u, d._nodes)), r(u);
      },
      onEdgesChange: (u) => {
        s({
          _edges: XB(u, c()._edges)
        }), o(u);
      },
      onConnect: (u) => {
        u.source == null || u.target == null || i(u);
      },
      getNode: (u) => c()._nodes_map.get(u),
      getNodes: () => c()._nodes,
      getEdges: () => c()._edges
    }));
  }, t$e = () => {
    const t = Vt().progress_state();
    return /* @__PURE__ */ S.jsxs("div", { className: "statusbar", children: [
      /* @__PURE__ */ S.jsx(
        "span",
        {
          className: "statusbar-progressbar",
          style: { width: Math.min(100, 100 * t.progress) + "%" }
        }
      ),
      /* @__PURE__ */ S.jsx("span", { className: "statusbar-message", children: t.message })
    ] });
  }, Ch = () => window?._FUNCNODES_DEV ?? !1;
  var WC = ["Enter", " "], n$e = ["ArrowDown", "PageUp", "Home"], qH = ["ArrowUp", "PageDown", "End"], r$e = [...n$e, ...qH], o$e = {
    ltr: [...WC, "ArrowRight"],
    rtl: [...WC, "ArrowLeft"]
  }, i$e = {
    ltr: ["ArrowLeft"],
    rtl: ["ArrowRight"]
  }, vm = "Menu", [kh, a$e, s$e] = Lb(vm), [$c, WH] = Qi(vm, [
    s$e,
    jb,
    I1
  ]), bm = jb(), GH = I1(), [KH, jc] = $c(vm), [l$e, xm] = $c(vm), YH = (e) => {
    const { __scopeMenu: t, open: n = !1, children: r, dir: o, onOpenChange: i, modal: a = !0 } = e, s = bm(t), [c, u] = T.useState(null), d = T.useRef(!1), p = qr(i), m = s1(o);
    return T.useEffect(() => {
      const g = () => {
        d.current = !0, document.addEventListener("pointerdown", y, { capture: !0, once: !0 }), document.addEventListener("pointermove", y, { capture: !0, once: !0 });
      }, y = () => d.current = !1;
      return document.addEventListener("keydown", g, { capture: !0 }), () => {
        document.removeEventListener("keydown", g, { capture: !0 }), document.removeEventListener("pointerdown", y, { capture: !0 }), document.removeEventListener("pointermove", y, { capture: !0 });
      };
    }, []), /* @__PURE__ */ S.jsx(sT, { ...s, children: /* @__PURE__ */ S.jsx(
      KH,
      {
        scope: t,
        open: n,
        onOpenChange: p,
        content: c,
        onContentChange: u,
        children: /* @__PURE__ */ S.jsx(
          l$e,
          {
            scope: t,
            onClose: T.useCallback(() => p(!1), [p]),
            isUsingKeyboardRef: d,
            dir: m,
            modal: a,
            children: r
          }
        )
      }
    ) });
  };
  YH.displayName = vm;
  var c$e = "MenuAnchor", tR = T.forwardRef(
    (e, t) => {
      const { __scopeMenu: n, ...r } = e, o = bm(n);
      return /* @__PURE__ */ S.jsx(lT, { ...o, ...r, ref: t });
    }
  );
  tR.displayName = c$e;
  var u$e = "MenuPortal", [Fze, XH] = $c(u$e, {
    forceMount: void 0
  }), Po = "MenuContent", [f$e, nR] = $c(Po), ZH = T.forwardRef(
    (e, t) => {
      const n = XH(Po, e.__scopeMenu), { forceMount: r = n.forceMount, ...o } = e, i = jc(Po, e.__scopeMenu), a = xm(Po, e.__scopeMenu);
      return /* @__PURE__ */ S.jsx(kh.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ S.jsx(ii, { present: r || i.open, children: /* @__PURE__ */ S.jsx(kh.Slot, { scope: e.__scopeMenu, children: a.modal ? /* @__PURE__ */ S.jsx(d$e, { ...o, ref: t }) : /* @__PURE__ */ S.jsx(p$e, { ...o, ref: t }) }) }) });
    }
  ), d$e = T.forwardRef(
    (e, t) => {
      const n = jc(Po, e.__scopeMenu), r = T.useRef(null), o = un(t, r);
      return T.useEffect(() => {
        const i = r.current;
        if (i) return Ik(i);
      }, []), /* @__PURE__ */ S.jsx(
        rR,
        {
          ...e,
          ref: o,
          trapFocus: n.open,
          disableOutsidePointerEvents: n.open,
          disableOutsideScroll: !0,
          onFocusOutside: Le(
            e.onFocusOutside,
            (i) => i.preventDefault(),
            { checkForDefaultPrevented: !1 }
          ),
          onDismiss: () => n.onOpenChange(!1)
        }
      );
    }
  ), p$e = T.forwardRef((e, t) => {
    const n = jc(Po, e.__scopeMenu);
    return /* @__PURE__ */ S.jsx(
      rR,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }), h$e = /* @__PURE__ */ df("MenuContent.ScrollLock"), rR = T.forwardRef(
    (e, t) => {
      const {
        __scopeMenu: n,
        loop: r = !1,
        trapFocus: o,
        onOpenAutoFocus: i,
        onCloseAutoFocus: a,
        disableOutsidePointerEvents: s,
        onEntryFocus: c,
        onEscapeKeyDown: u,
        onPointerDownOutside: d,
        onFocusOutside: p,
        onInteractOutside: m,
        onDismiss: g,
        disableOutsideScroll: y,
        ...b
      } = e, v = jc(Po, n), x = xm(Po, n), E = bm(n), _ = GH(n), C = a$e(n), [k, A] = T.useState(null), O = T.useRef(null), P = un(t, O, v.onContentChange), I = T.useRef(0), $ = T.useRef(""), L = T.useRef(0), N = T.useRef(null), U = T.useRef("right"), j = T.useRef(0), V = y ? Eb : T.Fragment, F = y ? { as: h$e, allowPinchZoom: !0 } : void 0, K = (Y) => {
        const B = $.current + Y, D = C().filter((ne) => !ne.disabled), G = document.activeElement, z = D.find((ne) => ne.ref.current === G)?.textValue, H = D.map((ne) => ne.textValue), X = k$e(H, B, z), Q = D.find((ne) => ne.textValue === X)?.ref.current;
        (function ne(te) {
          $.current = te, window.clearTimeout(I.current), te !== "" && (I.current = window.setTimeout(() => ne(""), 1e3));
        })(B), Q && setTimeout(() => Q.focus());
      };
      T.useEffect(() => () => window.clearTimeout(I.current), []), Pk();
      const W = T.useCallback((Y) => U.current === N.current?.side && A$e(Y, N.current?.area), []);
      return /* @__PURE__ */ S.jsx(
        f$e,
        {
          scope: n,
          searchRef: $,
          onItemEnter: T.useCallback(
            (Y) => {
              W(Y) && Y.preventDefault();
            },
            [W]
          ),
          onItemLeave: T.useCallback(
            (Y) => {
              W(Y) || (O.current?.focus(), A(null));
            },
            [W]
          ),
          onTriggerLeave: T.useCallback(
            (Y) => {
              W(Y) && Y.preventDefault();
            },
            [W]
          ),
          pointerGraceTimerRef: L,
          onPointerGraceIntentChange: T.useCallback((Y) => {
            N.current = Y;
          }, []),
          children: /* @__PURE__ */ S.jsx(V, { ...F, children: /* @__PURE__ */ S.jsx(
            wb,
            {
              asChild: !0,
              trapped: o,
              onMountAutoFocus: Le(i, (Y) => {
                Y.preventDefault(), O.current?.focus({ preventScroll: !0 });
              }),
              onUnmountAutoFocus: a,
              children: /* @__PURE__ */ S.jsx(
                zh,
                {
                  asChild: !0,
                  disableOutsidePointerEvents: s,
                  onEscapeKeyDown: u,
                  onPointerDownOutside: d,
                  onFocusOutside: p,
                  onInteractOutside: m,
                  onDismiss: g,
                  children: /* @__PURE__ */ S.jsx(
                    RH,
                    {
                      asChild: !0,
                      ..._,
                      dir: x.dir,
                      orientation: "vertical",
                      loop: r,
                      currentTabStopId: k,
                      onCurrentTabStopIdChange: A,
                      onEntryFocus: Le(c, (Y) => {
                        x.isUsingKeyboardRef.current || Y.preventDefault();
                      }),
                      preventScrollOnEntryFocus: !0,
                      children: /* @__PURE__ */ S.jsx(
                        Yz,
                        {
                          role: "menu",
                          "aria-orientation": "vertical",
                          "data-state": h7(v.open),
                          "data-radix-menu-content": "",
                          dir: x.dir,
                          ...E,
                          ...b,
                          ref: P,
                          style: { outline: "none", ...b.style },
                          onKeyDown: Le(b.onKeyDown, (Y) => {
                            const D = Y.target.closest("[data-radix-menu-content]") === Y.currentTarget, G = Y.ctrlKey || Y.altKey || Y.metaKey, z = Y.key.length === 1;
                            D && (Y.key === "Tab" && Y.preventDefault(), !G && z && K(Y.key));
                            const H = O.current;
                            if (Y.target !== H || !r$e.includes(Y.key)) return;
                            Y.preventDefault();
                            const Q = C().filter((ne) => !ne.disabled).map((ne) => ne.ref.current);
                            qH.includes(Y.key) && Q.reverse(), E$e(Q);
                          }),
                          onBlur: Le(e.onBlur, (Y) => {
                            Y.currentTarget.contains(Y.target) || (window.clearTimeout(I.current), $.current = "");
                          }),
                          onPointerMove: Le(
                            e.onPointerMove,
                            Th((Y) => {
                              const B = Y.target, D = j.current !== Y.clientX;
                              if (Y.currentTarget.contains(B) && D) {
                                const G = Y.clientX > j.current ? "right" : "left";
                                U.current = G, j.current = Y.clientX;
                              }
                            })
                          )
                        }
                      )
                    }
                  )
                }
              )
            }
          ) })
        }
      );
    }
  );
  ZH.displayName = Po;
  var m$e = "MenuGroup", oR = T.forwardRef(
    (e, t) => {
      const { __scopeMenu: n, ...r } = e;
      return /* @__PURE__ */ S.jsx(xt.div, { role: "group", ...r, ref: t });
    }
  );
  oR.displayName = m$e;
  var g$e = "MenuLabel", QH = T.forwardRef(
    (e, t) => {
      const { __scopeMenu: n, ...r } = e;
      return /* @__PURE__ */ S.jsx(xt.div, { ...r, ref: t });
    }
  );
  QH.displayName = g$e;
  var q0 = "MenuItem", X3 = "menu.itemSelect", j1 = T.forwardRef(
    (e, t) => {
      const { disabled: n = !1, onSelect: r, ...o } = e, i = T.useRef(null), a = xm(q0, e.__scopeMenu), s = nR(q0, e.__scopeMenu), c = un(t, i), u = T.useRef(!1), d = () => {
        const p = i.current;
        if (!n && p) {
          const m = new CustomEvent(X3, { bubbles: !0, cancelable: !0 });
          p.addEventListener(X3, (g) => r?.(g), { once: !0 }), Nk(p, m), m.defaultPrevented ? u.current = !1 : a.onClose();
        }
      };
      return /* @__PURE__ */ S.jsx(
        JH,
        {
          ...o,
          ref: c,
          disabled: n,
          onClick: Le(e.onClick, d),
          onPointerDown: (p) => {
            e.onPointerDown?.(p), u.current = !0;
          },
          onPointerUp: Le(e.onPointerUp, (p) => {
            u.current || p.currentTarget?.click();
          }),
          onKeyDown: Le(e.onKeyDown, (p) => {
            const m = s.searchRef.current !== "";
            n || m && p.key === " " || WC.includes(p.key) && (p.currentTarget.click(), p.preventDefault());
          })
        }
      );
    }
  );
  j1.displayName = q0;
  var JH = T.forwardRef(
    (e, t) => {
      const { __scopeMenu: n, disabled: r = !1, textValue: o, ...i } = e, a = nR(q0, n), s = GH(n), c = T.useRef(null), u = un(t, c), [d, p] = T.useState(!1), [m, g] = T.useState("");
      return T.useEffect(() => {
        const y = c.current;
        y && g((y.textContent ?? "").trim());
      }, [i.children]), /* @__PURE__ */ S.jsx(
        kh.ItemSlot,
        {
          scope: n,
          disabled: r,
          textValue: o ?? m,
          children: /* @__PURE__ */ S.jsx(OH, { asChild: !0, ...s, focusable: !r, children: /* @__PURE__ */ S.jsx(
            xt.div,
            {
              role: "menuitem",
              "data-highlighted": d ? "" : void 0,
              "aria-disabled": r || void 0,
              "data-disabled": r ? "" : void 0,
              ...i,
              ref: u,
              onPointerMove: Le(
                e.onPointerMove,
                Th((y) => {
                  r ? a.onItemLeave(y) : (a.onItemEnter(y), y.defaultPrevented || y.currentTarget.focus({ preventScroll: !0 }));
                })
              ),
              onPointerLeave: Le(
                e.onPointerLeave,
                Th((y) => a.onItemLeave(y))
              ),
              onFocus: Le(e.onFocus, () => p(!0)),
              onBlur: Le(e.onBlur, () => p(!1))
            }
          ) })
        }
      );
    }
  ), y$e = "MenuCheckboxItem", e7 = T.forwardRef(
    (e, t) => {
      const { checked: n = !1, onCheckedChange: r, ...o } = e;
      return /* @__PURE__ */ S.jsx(i7, { scope: e.__scopeMenu, checked: n, children: /* @__PURE__ */ S.jsx(
        j1,
        {
          role: "menuitemcheckbox",
          "aria-checked": W0(n) ? "mixed" : n,
          ...o,
          ref: t,
          "data-state": sR(n),
          onSelect: Le(
            o.onSelect,
            () => r?.(W0(n) ? !0 : !n),
            { checkForDefaultPrevented: !1 }
          )
        }
      ) });
    }
  );
  e7.displayName = y$e;
  var t7 = "MenuRadioGroup", [v$e, b$e] = $c(
    t7,
    { value: void 0, onValueChange: () => {
    } }
  ), n7 = T.forwardRef(
    (e, t) => {
      const { value: n, onValueChange: r, ...o } = e, i = qr(r);
      return /* @__PURE__ */ S.jsx(v$e, { scope: e.__scopeMenu, value: n, onValueChange: i, children: /* @__PURE__ */ S.jsx(oR, { ...o, ref: t }) });
    }
  );
  n7.displayName = t7;
  var r7 = "MenuRadioItem", o7 = T.forwardRef(
    (e, t) => {
      const { value: n, ...r } = e, o = b$e(r7, e.__scopeMenu), i = n === o.value;
      return /* @__PURE__ */ S.jsx(i7, { scope: e.__scopeMenu, checked: i, children: /* @__PURE__ */ S.jsx(
        j1,
        {
          role: "menuitemradio",
          "aria-checked": i,
          ...r,
          ref: t,
          "data-state": sR(i),
          onSelect: Le(
            r.onSelect,
            () => o.onValueChange?.(n),
            { checkForDefaultPrevented: !1 }
          )
        }
      ) });
    }
  );
  o7.displayName = r7;
  var iR = "MenuItemIndicator", [i7, x$e] = $c(
    iR,
    { checked: !1 }
  ), a7 = T.forwardRef(
    (e, t) => {
      const { __scopeMenu: n, forceMount: r, ...o } = e, i = x$e(iR, n);
      return /* @__PURE__ */ S.jsx(
        ii,
        {
          present: r || W0(i.checked) || i.checked === !0,
          children: /* @__PURE__ */ S.jsx(
            xt.span,
            {
              ...o,
              ref: t,
              "data-state": sR(i.checked)
            }
          )
        }
      );
    }
  );
  a7.displayName = iR;
  var w$e = "MenuSeparator", s7 = T.forwardRef(
    (e, t) => {
      const { __scopeMenu: n, ...r } = e;
      return /* @__PURE__ */ S.jsx(
        xt.div,
        {
          role: "separator",
          "aria-orientation": "horizontal",
          ...r,
          ref: t
        }
      );
    }
  );
  s7.displayName = w$e;
  var S$e = "MenuArrow", l7 = T.forwardRef(
    (e, t) => {
      const { __scopeMenu: n, ...r } = e, o = bm(n);
      return /* @__PURE__ */ S.jsx(Xz, { ...o, ...r, ref: t });
    }
  );
  l7.displayName = S$e;
  var aR = "MenuSub", [_$e, c7] = $c(aR), u7 = (e) => {
    const { __scopeMenu: t, children: n, open: r = !1, onOpenChange: o } = e, i = jc(aR, t), a = bm(t), [s, c] = T.useState(null), [u, d] = T.useState(null), p = qr(o);
    return T.useEffect(() => (i.open === !1 && p(!1), () => p(!1)), [i.open, p]), /* @__PURE__ */ S.jsx(sT, { ...a, children: /* @__PURE__ */ S.jsx(
      KH,
      {
        scope: t,
        open: r,
        onOpenChange: p,
        content: u,
        onContentChange: d,
        children: /* @__PURE__ */ S.jsx(
          _$e,
          {
            scope: t,
            contentId: Vi(),
            triggerId: Vi(),
            trigger: s,
            onTriggerChange: c,
            children: n
          }
        )
      }
    ) });
  };
  u7.displayName = aR;
  var Cp = "MenuSubTrigger", f7 = T.forwardRef(
    (e, t) => {
      const n = jc(Cp, e.__scopeMenu), r = xm(Cp, e.__scopeMenu), o = c7(Cp, e.__scopeMenu), i = nR(Cp, e.__scopeMenu), a = T.useRef(null), { pointerGraceTimerRef: s, onPointerGraceIntentChange: c } = i, u = { __scopeMenu: e.__scopeMenu }, d = T.useCallback(() => {
        a.current && window.clearTimeout(a.current), a.current = null;
      }, []);
      return T.useEffect(() => d, [d]), T.useEffect(() => {
        const p = s.current;
        return () => {
          window.clearTimeout(p), c(null);
        };
      }, [s, c]), /* @__PURE__ */ S.jsx(tR, { asChild: !0, ...u, children: /* @__PURE__ */ S.jsx(
        JH,
        {
          id: o.triggerId,
          "aria-haspopup": "menu",
          "aria-expanded": n.open,
          "aria-controls": o.contentId,
          "data-state": h7(n.open),
          ...e,
          ref: xb(t, o.onTriggerChange),
          onClick: (p) => {
            e.onClick?.(p), !(e.disabled || p.defaultPrevented) && (p.currentTarget.focus(), n.open || n.onOpenChange(!0));
          },
          onPointerMove: Le(
            e.onPointerMove,
            Th((p) => {
              i.onItemEnter(p), !p.defaultPrevented && !e.disabled && !n.open && !a.current && (i.onPointerGraceIntentChange(null), a.current = window.setTimeout(() => {
                n.onOpenChange(!0), d();
              }, 100));
            })
          ),
          onPointerLeave: Le(
            e.onPointerLeave,
            Th((p) => {
              d();
              const m = n.content?.getBoundingClientRect();
              if (m) {
                const g = n.content?.dataset.side, y = g === "right", b = y ? -5 : 5, v = m[y ? "left" : "right"], x = m[y ? "right" : "left"];
                i.onPointerGraceIntentChange({
                  area: [
                    // Apply a bleed on clientX to ensure that our exit point is
                    // consistently within polygon bounds
                    { x: p.clientX + b, y: p.clientY },
                    { x: v, y: m.top },
                    { x, y: m.top },
                    { x, y: m.bottom },
                    { x: v, y: m.bottom }
                  ],
                  side: g
                }), window.clearTimeout(s.current), s.current = window.setTimeout(
                  () => i.onPointerGraceIntentChange(null),
                  300
                );
              } else {
                if (i.onTriggerLeave(p), p.defaultPrevented) return;
                i.onPointerGraceIntentChange(null);
              }
            })
          ),
          onKeyDown: Le(e.onKeyDown, (p) => {
            const m = i.searchRef.current !== "";
            e.disabled || m && p.key === " " || o$e[r.dir].includes(p.key) && (n.onOpenChange(!0), n.content?.focus(), p.preventDefault());
          })
        }
      ) });
    }
  );
  f7.displayName = Cp;
  var d7 = "MenuSubContent", p7 = T.forwardRef(
    (e, t) => {
      const n = XH(Po, e.__scopeMenu), { forceMount: r = n.forceMount, ...o } = e, i = jc(Po, e.__scopeMenu), a = xm(Po, e.__scopeMenu), s = c7(d7, e.__scopeMenu), c = T.useRef(null), u = un(t, c);
      return /* @__PURE__ */ S.jsx(kh.Provider, { scope: e.__scopeMenu, children: /* @__PURE__ */ S.jsx(ii, { present: r || i.open, children: /* @__PURE__ */ S.jsx(kh.Slot, { scope: e.__scopeMenu, children: /* @__PURE__ */ S.jsx(
        rR,
        {
          id: s.contentId,
          "aria-labelledby": s.triggerId,
          ...o,
          ref: u,
          align: "start",
          side: a.dir === "rtl" ? "left" : "right",
          disableOutsidePointerEvents: !1,
          disableOutsideScroll: !1,
          trapFocus: !1,
          onOpenAutoFocus: (d) => {
            a.isUsingKeyboardRef.current && c.current?.focus(), d.preventDefault();
          },
          onCloseAutoFocus: (d) => d.preventDefault(),
          onFocusOutside: Le(e.onFocusOutside, (d) => {
            d.target !== s.trigger && i.onOpenChange(!1);
          }),
          onEscapeKeyDown: Le(e.onEscapeKeyDown, (d) => {
            a.onClose(), d.preventDefault();
          }),
          onKeyDown: Le(e.onKeyDown, (d) => {
            const p = d.currentTarget.contains(d.target), m = i$e[a.dir].includes(d.key);
            p && m && (i.onOpenChange(!1), s.trigger?.focus(), d.preventDefault());
          })
        }
      ) }) }) });
    }
  );
  p7.displayName = d7;
  function h7(e) {
    return e ? "open" : "closed";
  }
  function W0(e) {
    return e === "indeterminate";
  }
  function sR(e) {
    return W0(e) ? "indeterminate" : e ? "checked" : "unchecked";
  }
  function E$e(e) {
    const t = document.activeElement;
    for (const n of e)
      if (n === t || (n.focus(), document.activeElement !== t)) return;
  }
  function C$e(e, t) {
    return e.map((n, r) => e[(t + r) % e.length]);
  }
  function k$e(e, t, n) {
    const o = t.length > 1 && Array.from(t).every((u) => u === t[0]) ? t[0] : t, i = n ? e.indexOf(n) : -1;
    let a = C$e(e, Math.max(i, 0));
    o.length === 1 && (a = a.filter((u) => u !== n));
    const c = a.find(
      (u) => u.toLowerCase().startsWith(o.toLowerCase())
    );
    return c !== n ? c : void 0;
  }
  function T$e(e, t) {
    const { x: n, y: r } = e;
    let o = !1;
    for (let i = 0, a = t.length - 1; i < t.length; a = i++) {
      const s = t[i], c = t[a], u = s.x, d = s.y, p = c.x, m = c.y;
      d > r != m > r && n < (p - u) * (r - d) / (m - d) + u && (o = !o);
    }
    return o;
  }
  function A$e(e, t) {
    if (!t) return !1;
    const n = { x: e.clientX, y: e.clientY };
    return T$e(n, t);
  }
  function Th(e) {
    return (t) => t.pointerType === "mouse" ? e(t) : void 0;
  }
  var R$e = YH, O$e = tR, M$e = ZH, N$e = oR, P$e = QH, I$e = j1, $$e = e7, j$e = n7, D$e = o7, F$e = a7, L$e = s7, z$e = l7, B$e = u7, U$e = f7, V$e = p7, D1 = "DropdownMenu", [H$e] = Qi(
    D1,
    [WH]
  ), Or = WH(), [q$e, m7] = H$e(D1), g7 = (e) => {
    const {
      __scopeDropdownMenu: t,
      children: n,
      dir: r,
      open: o,
      defaultOpen: i,
      onOpenChange: a,
      modal: s = !0
    } = e, c = Or(t), u = T.useRef(null), [d, p] = hl({
      prop: o,
      defaultProp: i ?? !1,
      onChange: a,
      caller: D1
    });
    return /* @__PURE__ */ S.jsx(
      q$e,
      {
        scope: t,
        triggerId: Vi(),
        triggerRef: u,
        contentId: Vi(),
        open: d,
        onOpenChange: p,
        onOpenToggle: T.useCallback(() => p((m) => !m), [p]),
        modal: s,
        children: /* @__PURE__ */ S.jsx(R$e, { ...c, open: d, onOpenChange: p, dir: r, modal: s, children: n })
      }
    );
  };
  g7.displayName = D1;
  var y7 = "DropdownMenuTrigger", v7 = T.forwardRef(
    (e, t) => {
      const { __scopeDropdownMenu: n, disabled: r = !1, ...o } = e, i = m7(y7, n), a = Or(n);
      return /* @__PURE__ */ S.jsx(O$e, { asChild: !0, ...a, children: /* @__PURE__ */ S.jsx(
        xt.button,
        {
          type: "button",
          id: i.triggerId,
          "aria-haspopup": "menu",
          "aria-expanded": i.open,
          "aria-controls": i.open ? i.contentId : void 0,
          "data-state": i.open ? "open" : "closed",
          "data-disabled": r ? "" : void 0,
          disabled: r,
          ...o,
          ref: xb(t, i.triggerRef),
          onPointerDown: Le(e.onPointerDown, (s) => {
            !r && s.button === 0 && s.ctrlKey === !1 && (i.onOpenToggle(), i.open || s.preventDefault());
          }),
          onKeyDown: Le(e.onKeyDown, (s) => {
            r || (["Enter", " "].includes(s.key) && i.onOpenToggle(), s.key === "ArrowDown" && i.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(s.key) && s.preventDefault());
          })
        }
      ) });
    }
  );
  v7.displayName = y7;
  var b7 = "DropdownMenuContent", x7 = T.forwardRef(
    (e, t) => {
      const { __scopeDropdownMenu: n, ...r } = e, o = m7(b7, n), i = Or(n), a = T.useRef(!1);
      return /* @__PURE__ */ S.jsx(
        M$e,
        {
          id: o.contentId,
          "aria-labelledby": o.triggerId,
          ...i,
          ...r,
          ref: t,
          onCloseAutoFocus: Le(e.onCloseAutoFocus, (s) => {
            a.current || o.triggerRef.current?.focus(), a.current = !1, s.preventDefault();
          }),
          onInteractOutside: Le(e.onInteractOutside, (s) => {
            const c = s.detail.originalEvent, u = c.button === 0 && c.ctrlKey === !0, d = c.button === 2 || u;
            (!o.modal || d) && (a.current = !0);
          }),
          style: {
            ...e.style,
            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      );
    }
  );
  x7.displayName = b7;
  var W$e = "DropdownMenuGroup", w7 = T.forwardRef(
    (e, t) => {
      const { __scopeDropdownMenu: n, ...r } = e, o = Or(n);
      return /* @__PURE__ */ S.jsx(N$e, { ...o, ...r, ref: t });
    }
  );
  w7.displayName = W$e;
  var G$e = "DropdownMenuLabel", K$e = T.forwardRef(
    (e, t) => {
      const { __scopeDropdownMenu: n, ...r } = e, o = Or(n);
      return /* @__PURE__ */ S.jsx(P$e, { ...o, ...r, ref: t });
    }
  );
  K$e.displayName = G$e;
  var Y$e = "DropdownMenuItem", S7 = T.forwardRef(
    (e, t) => {
      const { __scopeDropdownMenu: n, ...r } = e, o = Or(n);
      return /* @__PURE__ */ S.jsx(I$e, { ...o, ...r, ref: t });
    }
  );
  S7.displayName = Y$e;
  var X$e = "DropdownMenuCheckboxItem", Z$e = T.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Or(n);
    return /* @__PURE__ */ S.jsx($$e, { ...o, ...r, ref: t });
  });
  Z$e.displayName = X$e;
  var Q$e = "DropdownMenuRadioGroup", _7 = T.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Or(n);
    return /* @__PURE__ */ S.jsx(j$e, { ...o, ...r, ref: t });
  });
  _7.displayName = Q$e;
  var J$e = "DropdownMenuRadioItem", E7 = T.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Or(n);
    return /* @__PURE__ */ S.jsx(D$e, { ...o, ...r, ref: t });
  });
  E7.displayName = J$e;
  var eje = "DropdownMenuItemIndicator", tje = T.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Or(n);
    return /* @__PURE__ */ S.jsx(F$e, { ...o, ...r, ref: t });
  });
  tje.displayName = eje;
  var nje = "DropdownMenuSeparator", rje = T.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Or(n);
    return /* @__PURE__ */ S.jsx(L$e, { ...o, ...r, ref: t });
  });
  rje.displayName = nje;
  var oje = "DropdownMenuArrow", ije = T.forwardRef(
    (e, t) => {
      const { __scopeDropdownMenu: n, ...r } = e, o = Or(n);
      return /* @__PURE__ */ S.jsx(z$e, { ...o, ...r, ref: t });
    }
  );
  ije.displayName = oje;
  var aje = (e) => {
    const { __scopeDropdownMenu: t, children: n, open: r, onOpenChange: o, defaultOpen: i } = e, a = Or(t), [s, c] = hl({
      prop: r,
      defaultProp: i ?? !1,
      onChange: o,
      caller: "DropdownMenuSub"
    });
    return /* @__PURE__ */ S.jsx(B$e, { ...a, open: s, onOpenChange: c, children: n });
  }, sje = "DropdownMenuSubTrigger", C7 = T.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Or(n);
    return /* @__PURE__ */ S.jsx(U$e, { ...o, ...r, ref: t });
  });
  C7.displayName = sje;
  var lje = "DropdownMenuSubContent", k7 = T.forwardRef((e, t) => {
    const { __scopeDropdownMenu: n, ...r } = e, o = Or(n);
    return /* @__PURE__ */ S.jsx(
      V$e,
      {
        ...o,
        ...r,
        ref: t,
        style: {
          ...e.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  });
  k7.displayName = lje;
  var lR = g7, cR = v7, uR = x7, fR = w7, ja = S7, cje = _7, uje = E7, fje = aje, dje = C7, pje = k7;
  const hje = ({
    trigger: e,
    setOpen: t,
    open: n
  }) => {
    const [r, o] = T.useState(""), [i, a] = T.useState(!0), s = Vt();
    return s.options.useWorkerManager ? /* @__PURE__ */ S.jsxs(
      Ji,
      {
        setOpen: t,
        open: n,
        trigger: e,
        title: "New Worker",
        description: "Create a new worker",
        children: [
          /* @__PURE__ */ S.jsxs("div", { children: [
            "Name:",
            /* @__PURE__ */ S.jsx("br", {}),
            /* @__PURE__ */ S.jsx(
              "input",
              {
                className: "styledinput",
                onChange: (c) => {
                  o(c.currentTarget.value);
                },
                value: r
              }
            ),
            /* @__PURE__ */ S.jsxs("div", { style: { marginTop: 8 }, children: [
              /* @__PURE__ */ S.jsx(
                "input",
                {
                  type: "checkbox",
                  id: "inVenvCheckbox",
                  checked: i,
                  onChange: (c) => a(c.currentTarget.checked)
                }
              ),
              /* @__PURE__ */ S.jsx("label", { htmlFor: "inVenvCheckbox", style: { marginLeft: 4 }, children: "Create in new virtual environment" })
            ] })
          ] }),
          /* @__PURE__ */ S.jsx("div", { children: r && /* @__PURE__ */ S.jsx("div", { children: /* @__PURE__ */ S.jsx(
            "button",
            {
              className: "styledbtn",
              onClick: () => {
                s.workermanager?.new_worker({
                  name: r,
                  in_venv: i
                  // reference: reference.uuid,
                  // copyLib,
                  // copyNS,
                }), t(!1);
              },
              children: "Create"
            }
          ) }) })
        ]
      }
    ) : null;
  }, mje = ({
    trigger: e,
    setOpen: t,
    open: n
  }) => {
    const r = Vt(), [o, i] = T.useState(!1), a = r.workers(), s = r.worker?.uuid, c = (s ? a[s]?.name : void 0) || s || "worker", u = async () => {
      if (!r.worker) return;
      const d = await r.worker.export({ withFiles: o });
      lK(d, c + ".fnw", "application/zip"), t(!1);
    };
    return /* @__PURE__ */ S.jsx(
      Ji,
      {
        setOpen: t,
        open: n,
        trigger: e,
        title: "Export Worker",
        description: "Export the worker as a .fnw file",
        children: /* @__PURE__ */ S.jsxs("div", { children: [
          /* @__PURE__ */ S.jsxs("div", { children: [
            /* @__PURE__ */ S.jsx(
              "input",
              {
                type: "checkbox",
                className: "styledcheckbox",
                checked: o,
                onChange: (d) => {
                  i(d.currentTarget.checked);
                }
              }
            ),
            "Include Files"
          ] }),
          /* @__PURE__ */ S.jsx("button", { className: "styledbtn", onClick: u, children: "Export" })
        ] })
      }
    );
  }, gje = () => {
    const e = Vt(), t = e.workers(), [n, r] = T.useState(!1), [o, i] = T.useState(!1), a = (g) => {
      g !== "__select__" && e.workers && e.workermanager && t[g] && (!t[g].active && !window.confirm(
        "this is an inactive worker, selecting it will start it, continue?"
      ) || e.workermanager.set_active(g));
    }, s = async () => {
      if (!e.worker || !window.confirm(
        "Updateing the worker might replace the current nodespace, continue?"
      )) return;
      const y = await fK(".fnw");
      e.worker.update_from_export(y);
    }, c = e.options.useWorkerManager && e.workermanager && e.workermanager.open || Ch(), u = c && Object.keys(t).length > 0, d = e.worker && e.worker.is_open, p = d && c;
    return c || d ? /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      /* @__PURE__ */ S.jsxs(lR, { children: [
        /* @__PURE__ */ S.jsx(cR, { asChild: !0, children: /* @__PURE__ */ S.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ S.jsxs(el, { direction: "row", children: [
          "Worker ",
          /* @__PURE__ */ S.jsx(Xk, { className: "m-x-s" })
        ] }) }) }),
        /* @__PURE__ */ S.jsx(uR, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ S.jsxs(fR, { children: [
          u && /* @__PURE__ */ S.jsxs(fje, { children: [
            /* @__PURE__ */ S.jsx(dje, { className: "headermenuitem submenuitem", children: /* @__PURE__ */ S.jsxs(el, { direction: "row", children: [
              "Select",
              /* @__PURE__ */ S.jsx(Qp, {})
            ] }) }),
            /* @__PURE__ */ S.jsx(
              pje,
              {
                className: "headermenucontent funcnodescontainer",
                sideOffset: 2,
                alignOffset: -5,
                children: /* @__PURE__ */ S.jsx(
                  cje,
                  {
                    value: e.worker?.uuid,
                    onValueChange: (g) => {
                      a(g);
                    },
                    children: Object.keys(t).sort((g, y) => {
                      if (t[g].active && !t[y].active)
                        return -1;
                      if (!t[g].active && t[y].active)
                        return 1;
                      const b = t[g].name || g, v = t[y].name || y;
                      return b.localeCompare(v);
                    }).map((g) => /* @__PURE__ */ S.jsx(
                      uje,
                      {
                        className: "headermenuitem workerselectoption" + (t[g]?.active ? " active" : " inactive") + " headermenuitem",
                        value: g,
                        disabled: g === e.worker?.uuid,
                        children: t[g]?.name || g
                      },
                      g
                    ))
                  }
                )
              }
            )
          ] }),
          d && /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
            p && /* @__PURE__ */ S.jsx(
              ja,
              {
                className: "headermenuitem",
                onClick: () => {
                  if (e.worker) {
                    if (!e.workermanager)
                      return e.logger.error("no workermanager");
                    e.workermanager?.restart_worker(
                      e.worker.uuid
                    );
                  }
                },
                children: "Restart"
              }
            ),
            /* @__PURE__ */ S.jsx(
              ja,
              {
                className: "headermenuitem",
                onClick: () => {
                  e.worker && e.worker.stop();
                },
                children: "Stop"
              }
            ),
            /* @__PURE__ */ S.jsx(
              ja,
              {
                className: "headermenuitem",
                onClick: () => i(!0),
                children: "Export"
              }
            ),
            /* @__PURE__ */ S.jsx(
              ja,
              {
                className: "headermenuitem",
                onClick: s,
                children: "Update"
              }
            )
          ] }),
          c && /* @__PURE__ */ S.jsx(S.Fragment, { children: /* @__PURE__ */ S.jsx(
            ja,
            {
              className: "headermenuitem",
              onClick: () => r(!0),
              children: "New"
            }
          ) })
        ] }) })
      ] }),
      /* @__PURE__ */ S.jsx(
        hje,
        {
          open: n,
          setOpen: r
        }
      ),
      /* @__PURE__ */ S.jsx(
        mje,
        {
          open: o,
          setOpen: i
        }
      )
    ] }) : null;
  }, yje = () => {
    const e = Vt(), t = () => {
      window.confirm("Are you sure you want to start a new flow?") && e.worker?.clear();
    }, n = async () => {
      const o = await e.worker?.save();
      if (!o) return;
      const i = new Blob([JSON.stringify(o)], {
        type: "application/json"
      }), a = URL.createObjectURL(i), s = document.createElement("a");
      s.href = a, s.download = "flow.json", s.click(), URL.revokeObjectURL(a), s.remove();
    }, r = async () => {
      const o = document.createElement("input");
      o.type = "file", o.accept = ".json", o.onchange = async (i) => {
        const a = i.target.files?.[0];
        if (!a) return;
        const s = new FileReader();
        s.onload = async (c) => {
          const u = c.target?.result;
          if (!u) return;
          const d = JSON.parse(u);
          await e.worker?.load(d);
        }, s.readAsText(a);
      }, o.click();
    };
    return /* @__PURE__ */ S.jsx(S.Fragment, { children: /* @__PURE__ */ S.jsxs(lR, { children: [
      /* @__PURE__ */ S.jsx(cR, { asChild: !0, children: /* @__PURE__ */ S.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ S.jsxs(el, { direction: "row", children: [
        "Nodespace ",
        /* @__PURE__ */ S.jsx(Xk, { className: "m-x-s" })
      ] }) }) }),
      /* @__PURE__ */ S.jsx(uR, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ S.jsxs(fR, { children: [
        /* @__PURE__ */ S.jsx(ja, { className: "headermenuitem", onClick: t, children: "New" }),
        /* @__PURE__ */ S.jsx(ja, { className: "headermenuitem", onClick: n, children: "Save" }),
        /* @__PURE__ */ S.jsx(ja, { className: "headermenuitem", onClick: r, children: "Load" })
      ] }) })
    ] }) });
  }, vje = ({ theme: e, selected: t }) => /* @__PURE__ */ S.jsxs(
    "div",
    {
      style: {
        width: 80,
        height: 54,
        borderRadius: "var(--fn-border-radius-s, 8px)",
        border: t ? "2.5px solid #1976d2" : "1.5px solid #bbb",
        boxShadow: t ? "0 0 0 2px #1976d2" : "0 1px 4px #0002",
        background: "var(--fn-app-background)",
        display: "flex",
        flexDirection: "column",
        alignItems: "stretch",
        justifyContent: "flex-start",
        position: "relative",
        overflow: "hidden",
        transition: "border 0.2s, box-shadow 0.2s"
      },
      "fn-data-color-theme": e,
      children: [
        /* @__PURE__ */ S.jsx(
          "div",
          {
            style: {
              height: 10,
              background: "var(--fn-primary-color)",
              borderBottom: "1px solid var(--fn-neutral-element-border)"
            }
          }
        ),
        /* @__PURE__ */ S.jsxs("div", { style: { display: "flex", flex: 1 }, children: [
          /* @__PURE__ */ S.jsx(
            "div",
            {
              style: {
                width: 12,
                background: "var(--fn-surface-elevation-low, var(--fn-container-background))",
                borderRight: "1px solid var(--fn-neutral-element-border)"
              }
            }
          ),
          /* @__PURE__ */ S.jsx(
            "div",
            {
              style: {
                flex: 1,
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                background: "var(--fn-container-background)"
              },
              children: /* @__PURE__ */ S.jsxs(
                "div",
                {
                  style: {
                    width: 22,
                    height: 14,
                    borderRadius: "var(--fn-border-radius-xs, 4px)",
                    background: "var(--fn-node-background)",
                    border: "1px solid var(--fn-node-header-color)",
                    boxShadow: "0 1px 2px #0002",
                    display: "flex",
                    flexDirection: "column"
                  },
                  children: [
                    /* @__PURE__ */ S.jsx(
                      "div",
                      {
                        style: {
                          height: 5,
                          background: "var(--fn-node-header-color)",
                          borderTopLeftRadius: "var(--fn-border-radius-xs, 4px)",
                          borderTopRightRadius: "var(--fn-border-radius-xs, 4px)"
                        }
                      }
                    ),
                    /* @__PURE__ */ S.jsx(
                      "div",
                      {
                        style: {
                          flex: 1,
                          background: "transparent"
                        }
                      }
                    )
                  ]
                }
              )
            }
          )
        ] }),
        /* @__PURE__ */ S.jsx(
          "span",
          {
            style: {
              position: "absolute",
              bottom: 2,
              right: 4,
              fontSize: 9,
              color: "var(--fn-text-color-neutral)",
              opacity: 0.7,
              textTransform: "capitalize",
              fontWeight: 600,
              pointerEvents: "none"
            },
            children: e
          }
        ),
        t && /* @__PURE__ */ S.jsx(
          "span",
          {
            style: {
              position: "absolute",
              top: 2,
              left: 6,
              fontSize: 14,
              color: "#1976d2",
              fontWeight: 900,
              pointerEvents: "none"
            },
            "aria-label": "Selected",
            children: ""
          }
        )
      ]
    }
  ), bje = () => {
    const { colorTheme: e, setColorTheme: t } = Ez(), [n, r] = T.useState(null), [o, i] = T.useState(null), a = (c) => {
      c !== e && (i(e), t(c), r(c));
    }, s = (c) => {
      n === c && o && o !== c && t(o), r(null), i(null);
    };
    return /* @__PURE__ */ S.jsxs("div", { style: { display: "flex", flexDirection: "column", gap: "1em" }, children: [
      /* @__PURE__ */ S.jsx("div", { style: { marginBottom: 8, fontWeight: 500 }, children: "Theme:" }),
      /* @__PURE__ */ S.jsx("div", { style: {
        display: "grid",
        gridTemplateColumns: "repeat(auto-fill, minmax(80px, 1fr))",
        gap: 16,
        justifyItems: "center"
      }, children: L9.map((c) => /* @__PURE__ */ S.jsx(
        "button",
        {
          onClick: () => {
            t(c), r(null), i(null);
          },
          onMouseEnter: () => a(c),
          onMouseLeave: () => s(c),
          style: {
            background: "none",
            border: "none",
            padding: 0,
            cursor: "pointer",
            outline: "none",
            borderRadius: 8
          },
          "aria-label": `Select ${c} theme`,
          children: /* @__PURE__ */ S.jsx(
            vje,
            {
              theme: c,
              selected: e === c
            }
          )
        },
        c
      )) })
    ] });
  }, xje = () => {
    const [e, t] = T.useState(!1), n = () => {
      t(!0);
    };
    return /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      /* @__PURE__ */ S.jsxs(lR, { children: [
        /* @__PURE__ */ S.jsx(cR, { asChild: !0, children: /* @__PURE__ */ S.jsx("button", { className: "styledbtn", children: /* @__PURE__ */ S.jsxs(el, { direction: "row", children: [
          "Settings ",
          /* @__PURE__ */ S.jsx(Xk, { className: "m-x-s" })
        ] }) }) }),
        /* @__PURE__ */ S.jsx(uR, { className: "headermenucontent funcnodescontainer", children: /* @__PURE__ */ S.jsx(fR, { children: /* @__PURE__ */ S.jsx(
          ja,
          {
            className: "headermenuitem",
            onClick: n,
            children: "Appearance"
          }
        ) }) })
      ] }),
      /* @__PURE__ */ S.jsx(
        Ji,
        {
          open: e,
          setOpen: t,
          title: "Appearance",
          description: "Change the color theme.",
          closebutton: !0,
          children: /* @__PURE__ */ S.jsx(bje, {})
        }
      )
    ] });
  }, wje = ({
    ...e
  }) => {
    const t = Vt(), n = t.workerstate();
    return Object.keys(e).length > 0 && t.logger.debug("headerprops", e), /* @__PURE__ */ S.jsxs(el, { className: "funcnodesreactflowheader", direction: "row", wrap: !0, children: [
      /* @__PURE__ */ S.jsx(
        el,
        {
          className: "headerelement m-w-6",
          grow: {
            "": !0,
            m: !1
          },
          children: /* @__PURE__ */ S.jsx(t$e, {})
        }
      ),
      (e.showmenu || Ch()) && /* @__PURE__ */ S.jsxs(el, { direction: "row", wrap: !0, children: [
        /* @__PURE__ */ S.jsx("div", { className: "headerelement", children: /* @__PURE__ */ S.jsx(gje, {}) }),
        (t.worker && n.is_open || Ch()) && /* @__PURE__ */ S.jsx("div", { className: "headerelement", children: /* @__PURE__ */ S.jsx(yje, {}) }),
        /* @__PURE__ */ S.jsx("div", { className: "headerelement", children: /* @__PURE__ */ S.jsx(xje, {}) })
      ] })
    ] });
  }, T7 = ({ item: e }) => {
    const { node: t } = Rr(), n = T.useCallback(() => {
      t?.add_node(e.node_id);
    }, [e.node_id, t]), r = T.useCallback(
      (o) => {
        o.detail === 2 && n();
      },
      [n]
    );
    return /* @__PURE__ */ S.jsx("div", { className: "libnodeentry", onClick: r, title: e.description, children: e.node_name || e.node_id });
  }, A7 = (e, t) => {
    const n = e.nodes?.some(
      (o) => o.node_id.toLowerCase().includes(t.toLowerCase())
    ) ?? !1, r = e.subshelves?.some((o) => A7(o, t)) ?? !1;
    return n || r;
  }, dR = ({
    item: e,
    filter: t,
    parentkey: n
  }) => {
    const [r, o] = T.useState(!1), i = () => o(!r), a = e.nodes?.filter(
      (c) => c.node_id.toLowerCase().includes(t.toLowerCase())
    ), s = r || t.length > 0;
    return A7(e, t) ? /* @__PURE__ */ S.jsxs("div", { className: "shelfcontainer", children: [
      /* @__PURE__ */ S.jsxs(
        "div",
        {
          className: "shelftitle",
          onClick: i,
          style: { cursor: "pointer" },
          title: e.description,
          children: [
            /* @__PURE__ */ S.jsx("div", { className: "shelftitle_text", children: e.name }),
            /* @__PURE__ */ S.jsx("div", { className: "expandicon " + (s ? "open" : "close"), children: /* @__PURE__ */ S.jsx(Hh, {}) })
          ]
        }
      ),
      /* @__PURE__ */ S.jsx("div", { className: "libnodecontainer " + (s ? "open" : "close"), children: /* @__PURE__ */ S.jsxs("div", { className: "libnodecontainer_inner", children: [
        a && /* @__PURE__ */ S.jsx(S.Fragment, { children: a.map((c) => /* @__PURE__ */ S.jsx(T7, { item: c }, c.node_id)) }),
        e.subshelves && /* @__PURE__ */ S.jsx(S.Fragment, { children: e.subshelves.map((c) => /* @__PURE__ */ S.jsx(
          dR,
          {
            item: c,
            filter: t,
            parentkey: n + c.name
          },
          n + c.name
        )) })
      ] }) }),
      /* @__PURE__ */ S.jsx("hr", {})
    ] }) : /* @__PURE__ */ S.jsx(S.Fragment, {});
  }, Sje = ({
    filter: e,
    setFilter: t
  }) => /* @__PURE__ */ S.jsxs("div", { className: "libfilter", children: [
    /* @__PURE__ */ S.jsx(Woe, { fontSize: "inherit" }),
    /* @__PURE__ */ S.jsx(
      "input",
      {
        type: "text",
        placeholder: "Filter",
        value: e,
        onChange: (n) => {
          t(n.target.value);
        }
      }
    ),
    e && /* @__PURE__ */ S.jsx(
      Nb,
      {
        fontSize: "inherit",
        onClick: () => {
          t("");
        }
      }
    )
  ] }), _je = ({
    children: e
  }) => {
    const [t, n] = T.useState(""), r = Vt(), [o, i] = T.useState(!0), [a, s] = T.useState(!0), [c, u] = T.useState(!0), [d, p] = T.useState({
      installed: [],
      available: [],
      active: []
    }), [m, g] = T.useState(!1), { lib: y } = Rr(), b = (P) => {
      P && (r.worker === void 0 || !r.worker.is_open || y?.get_available_modules({
        on_load: (I) => {
          p(I);
        }
      }).then((I) => {
        p(I);
      }));
    };
    if (!r.worker)
      return /* @__PURE__ */ S.jsx(S.Fragment, {});
    const v = T.useCallback(
      (P, I) => {
        g(!1), y?.add_lib(P.name, I);
      },
      [y]
    ), x = T.useCallback(
      (P, I) => {
        g(!1), y?.add_lib(P.name, I);
      },
      [y]
    ), E = T.useCallback(
      (P) => {
        g(!1), y?.remove_lib(P.name);
      },
      [y]
    ), _ = T.useCallback(
      (P, I) => {
        g(!1), y?.add_lib(P.name, I);
      },
      [y]
    ), C = T.useCallback(
      (P) => P.filter(
        (I) => I.name.toLowerCase().includes(t.toLowerCase()) || I.description.toLowerCase().includes(t.toLowerCase())
      ),
      [t]
    ), k = C(d.available), A = C(d.installed), O = C(d.active);
    return /* @__PURE__ */ S.jsxs(
      Ji,
      {
        title: "Manage Library",
        trigger: e,
        description: "Add or remove libraries to the current worker.",
        onOpenChange: b,
        open: m,
        setOpen: g,
        children: [
          /* @__PURE__ */ S.jsx(
            "input",
            {
              className: "filter-input styledinput",
              type: "text",
              placeholder: "Filter modules...",
              value: t,
              onChange: (P) => n(P.target.value)
            }
          ),
          /* @__PURE__ */ S.jsxs(
            "div",
            {
              className: "packagelist",
              style: { maxHeight: "70%", overflow: "auto" },
              children: [
                A.length > 0 && /* @__PURE__ */ S.jsx(
                  "h3",
                  {
                    onClick: () => {
                      u(!c);
                    },
                    children: "Installed"
                  }
                ),
                c && A.map((P) => /* @__PURE__ */ S.jsx(
                  YLe,
                  {
                    availableModule: P,
                    on_add: v
                  },
                  P.name + P.source
                )),
                k.length > 0 && /* @__PURE__ */ S.jsx(
                  "h3",
                  {
                    onClick: () => {
                      s(!a);
                    },
                    children: "Available"
                  }
                ),
                a && k.map((P) => /* @__PURE__ */ S.jsx(
                  XLe,
                  {
                    availableModule: P,
                    on_add: x
                  },
                  P.name + P.source
                )),
                O.length > 0 && /* @__PURE__ */ S.jsx(
                  "h3",
                  {
                    onClick: () => {
                      i(!o);
                    },
                    children: "Active"
                  }
                ),
                o && O.map((P) => /* @__PURE__ */ S.jsx(
                  KLe,
                  {
                    availableModule: P,
                    on_remove: E,
                    on_update: _
                  },
                  P.name + P.source
                ))
              ]
            }
          )
        ]
      }
    );
  }, pR = ({
    availableModule: e
  }) => /* @__PURE__ */ S.jsxs("div", { className: "module-links", children: [
    e.homepage && /* @__PURE__ */ S.jsx(S.Fragment, { children: /* @__PURE__ */ S.jsx(
      "a",
      {
        href: e.homepage,
        target: "_blank",
        rel: "noopener noreferrer",
        children: "Homepage"
      }
    ) }),
    e.source && e.homepage && " | ",
    e.source && /* @__PURE__ */ S.jsx(S.Fragment, { children: /* @__PURE__ */ S.jsx(
      "a",
      {
        href: e.source,
        target: "_blank",
        rel: "noopener noreferrer",
        children: "Source"
      }
    ) })
  ] });
  function Eje(e, t) {
    const n = {};
    return (e[e.length - 1] === "" ? [...e, ""] : e).join(
      (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
    ).trim();
  }
  const Cje = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, kje = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, Tje = {};
  function Z3(e, t) {
    return (Tje.jsx ? kje : Cje).test(e);
  }
  const Aje = /[ \t\n\f\r]/g;
  function Rje(e) {
    return typeof e == "object" ? e.type === "text" ? Q3(e.value) : !1 : Q3(e);
  }
  function Q3(e) {
    return e.replace(Aje, "") === "";
  }
  class wm {
    /**
     * @param {SchemaType['property']} property
     *   Property.
     * @param {SchemaType['normal']} normal
     *   Normal.
     * @param {Space | undefined} [space]
     *   Space.
     * @returns
     *   Schema.
     */
    constructor(t, n, r) {
      this.normal = n, this.property = t, r && (this.space = r);
    }
  }
  wm.prototype.normal = {};
  wm.prototype.property = {};
  wm.prototype.space = void 0;
  function R7(e, t) {
    const n = {}, r = {};
    for (const o of e)
      Object.assign(n, o.property), Object.assign(r, o.normal);
    return new wm(n, r, t);
  }
  function GC(e) {
    return e.toLowerCase();
  }
  class Wr {
    /**
     * @param {string} property
     *   Property.
     * @param {string} attribute
     *   Attribute.
     * @returns
     *   Info.
     */
    constructor(t, n) {
      this.attribute = n, this.property = t;
    }
  }
  Wr.prototype.attribute = "";
  Wr.prototype.booleanish = !1;
  Wr.prototype.boolean = !1;
  Wr.prototype.commaOrSpaceSeparated = !1;
  Wr.prototype.commaSeparated = !1;
  Wr.prototype.defined = !1;
  Wr.prototype.mustUseProperty = !1;
  Wr.prototype.number = !1;
  Wr.prototype.overloadedBoolean = !1;
  Wr.prototype.property = "";
  Wr.prototype.spaceSeparated = !1;
  Wr.prototype.space = void 0;
  let Oje = 0;
  const pt = Dc(), Un = Dc(), KC = Dc(), ke = Dc(), dn = Dc(), uf = Dc(), no = Dc();
  function Dc() {
    return 2 ** ++Oje;
  }
  const YC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    boolean: pt,
    booleanish: Un,
    commaOrSpaceSeparated: no,
    commaSeparated: uf,
    number: ke,
    overloadedBoolean: KC,
    spaceSeparated: dn
  }, Symbol.toStringTag, { value: "Module" })), Q_ = (
    /** @type {ReadonlyArray<keyof typeof types>} */
    Object.keys(YC)
  );
  class hR extends Wr {
    /**
     * @constructor
     * @param {string} property
     *   Property.
     * @param {string} attribute
     *   Attribute.
     * @param {number | null | undefined} [mask]
     *   Mask.
     * @param {Space | undefined} [space]
     *   Space.
     * @returns
     *   Info.
     */
    constructor(t, n, r, o) {
      let i = -1;
      if (super(t, n), J3(this, "space", o), typeof r == "number")
        for (; ++i < Q_.length; ) {
          const a = Q_[i];
          J3(this, Q_[i], (r & YC[a]) === YC[a]);
        }
    }
  }
  hR.prototype.defined = !0;
  function J3(e, t, n) {
    n && (e[t] = n);
  }
  function Gf(e) {
    const t = {}, n = {};
    for (const [r, o] of Object.entries(e.properties)) {
      const i = new hR(
        r,
        e.transform(e.attributes || {}, r),
        o,
        e.space
      );
      e.mustUseProperty && e.mustUseProperty.includes(r) && (i.mustUseProperty = !0), t[r] = i, n[GC(r)] = r, n[GC(i.attribute)] = r;
    }
    return new wm(t, n, e.space);
  }
  const O7 = Gf({
    properties: {
      ariaActiveDescendant: null,
      ariaAtomic: Un,
      ariaAutoComplete: null,
      ariaBusy: Un,
      ariaChecked: Un,
      ariaColCount: ke,
      ariaColIndex: ke,
      ariaColSpan: ke,
      ariaControls: dn,
      ariaCurrent: null,
      ariaDescribedBy: dn,
      ariaDetails: null,
      ariaDisabled: Un,
      ariaDropEffect: dn,
      ariaErrorMessage: null,
      ariaExpanded: Un,
      ariaFlowTo: dn,
      ariaGrabbed: Un,
      ariaHasPopup: null,
      ariaHidden: Un,
      ariaInvalid: null,
      ariaKeyShortcuts: null,
      ariaLabel: null,
      ariaLabelledBy: dn,
      ariaLevel: ke,
      ariaLive: null,
      ariaModal: Un,
      ariaMultiLine: Un,
      ariaMultiSelectable: Un,
      ariaOrientation: null,
      ariaOwns: dn,
      ariaPlaceholder: null,
      ariaPosInSet: ke,
      ariaPressed: Un,
      ariaReadOnly: Un,
      ariaRelevant: null,
      ariaRequired: Un,
      ariaRoleDescription: dn,
      ariaRowCount: ke,
      ariaRowIndex: ke,
      ariaRowSpan: ke,
      ariaSelected: Un,
      ariaSetSize: ke,
      ariaSort: null,
      ariaValueMax: ke,
      ariaValueMin: ke,
      ariaValueNow: ke,
      ariaValueText: null,
      role: null
    },
    transform(e, t) {
      return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
    }
  });
  function M7(e, t) {
    return t in e ? e[t] : t;
  }
  function N7(e, t) {
    return M7(e, t.toLowerCase());
  }
  const Mje = Gf({
    attributes: {
      acceptcharset: "accept-charset",
      classname: "class",
      htmlfor: "for",
      httpequiv: "http-equiv"
    },
    mustUseProperty: ["checked", "multiple", "muted", "selected"],
    properties: {
      // Standard Properties.
      abbr: null,
      accept: uf,
      acceptCharset: dn,
      accessKey: dn,
      action: null,
      allow: null,
      allowFullScreen: pt,
      allowPaymentRequest: pt,
      allowUserMedia: pt,
      alt: null,
      as: null,
      async: pt,
      autoCapitalize: null,
      autoComplete: dn,
      autoFocus: pt,
      autoPlay: pt,
      blocking: dn,
      capture: null,
      charSet: null,
      checked: pt,
      cite: null,
      className: dn,
      cols: ke,
      colSpan: null,
      content: null,
      contentEditable: Un,
      controls: pt,
      controlsList: dn,
      coords: ke | uf,
      crossOrigin: null,
      data: null,
      dateTime: null,
      decoding: null,
      default: pt,
      defer: pt,
      dir: null,
      dirName: null,
      disabled: pt,
      download: KC,
      draggable: Un,
      encType: null,
      enterKeyHint: null,
      fetchPriority: null,
      form: null,
      formAction: null,
      formEncType: null,
      formMethod: null,
      formNoValidate: pt,
      formTarget: null,
      headers: dn,
      height: ke,
      hidden: KC,
      high: ke,
      href: null,
      hrefLang: null,
      htmlFor: dn,
      httpEquiv: dn,
      id: null,
      imageSizes: null,
      imageSrcSet: null,
      inert: pt,
      inputMode: null,
      integrity: null,
      is: null,
      isMap: pt,
      itemId: null,
      itemProp: dn,
      itemRef: dn,
      itemScope: pt,
      itemType: dn,
      kind: null,
      label: null,
      lang: null,
      language: null,
      list: null,
      loading: null,
      loop: pt,
      low: ke,
      manifest: null,
      max: null,
      maxLength: ke,
      media: null,
      method: null,
      min: null,
      minLength: ke,
      multiple: pt,
      muted: pt,
      name: null,
      nonce: null,
      noModule: pt,
      noValidate: pt,
      onAbort: null,
      onAfterPrint: null,
      onAuxClick: null,
      onBeforeMatch: null,
      onBeforePrint: null,
      onBeforeToggle: null,
      onBeforeUnload: null,
      onBlur: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onContextLost: null,
      onContextMenu: null,
      onContextRestored: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFormData: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLanguageChange: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadEnd: null,
      onLoadStart: null,
      onMessage: null,
      onMessageError: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRejectionHandled: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onScrollEnd: null,
      onSecurityPolicyViolation: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onSlotChange: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnhandledRejection: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onWheel: null,
      open: pt,
      optimum: ke,
      pattern: null,
      ping: dn,
      placeholder: null,
      playsInline: pt,
      popover: null,
      popoverTarget: null,
      popoverTargetAction: null,
      poster: null,
      preload: null,
      readOnly: pt,
      referrerPolicy: null,
      rel: dn,
      required: pt,
      reversed: pt,
      rows: ke,
      rowSpan: ke,
      sandbox: dn,
      scope: null,
      scoped: pt,
      seamless: pt,
      selected: pt,
      shadowRootClonable: pt,
      shadowRootDelegatesFocus: pt,
      shadowRootMode: null,
      shape: null,
      size: ke,
      sizes: null,
      slot: null,
      span: ke,
      spellCheck: Un,
      src: null,
      srcDoc: null,
      srcLang: null,
      srcSet: null,
      start: ke,
      step: null,
      style: null,
      tabIndex: ke,
      target: null,
      title: null,
      translate: null,
      type: null,
      typeMustMatch: pt,
      useMap: null,
      value: Un,
      width: ke,
      wrap: null,
      writingSuggestions: null,
      // Legacy.
      // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
      align: null,
      // Several. Use CSS `text-align` instead,
      aLink: null,
      // `<body>`. Use CSS `a:active {color}` instead
      archive: dn,
      // `<object>`. List of URIs to archives
      axis: null,
      // `<td>` and `<th>`. Use `scope` on `<th>`
      background: null,
      // `<body>`. Use CSS `background-image` instead
      bgColor: null,
      // `<body>` and table elements. Use CSS `background-color` instead
      border: ke,
      // `<table>`. Use CSS `border-width` instead,
      borderColor: null,
      // `<table>`. Use CSS `border-color` instead,
      bottomMargin: ke,
      // `<body>`
      cellPadding: null,
      // `<table>`
      cellSpacing: null,
      // `<table>`
      char: null,
      // Several table elements. When `align=char`, sets the character to align on
      charOff: null,
      // Several table elements. When `char`, offsets the alignment
      classId: null,
      // `<object>`
      clear: null,
      // `<br>`. Use CSS `clear` instead
      code: null,
      // `<object>`
      codeBase: null,
      // `<object>`
      codeType: null,
      // `<object>`
      color: null,
      // `<font>` and `<hr>`. Use CSS instead
      compact: pt,
      // Lists. Use CSS to reduce space between items instead
      declare: pt,
      // `<object>`
      event: null,
      // `<script>`
      face: null,
      // `<font>`. Use CSS instead
      frame: null,
      // `<table>`
      frameBorder: null,
      // `<iframe>`. Use CSS `border` instead
      hSpace: ke,
      // `<img>` and `<object>`
      leftMargin: ke,
      // `<body>`
      link: null,
      // `<body>`. Use CSS `a:link {color: *}` instead
      longDesc: null,
      // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
      lowSrc: null,
      // `<img>`. Use a `<picture>`
      marginHeight: ke,
      // `<body>`
      marginWidth: ke,
      // `<body>`
      noResize: pt,
      // `<frame>`
      noHref: pt,
      // `<area>`. Use no href instead of an explicit `nohref`
      noShade: pt,
      // `<hr>`. Use background-color and height instead of borders
      noWrap: pt,
      // `<td>` and `<th>`
      object: null,
      // `<applet>`
      profile: null,
      // `<head>`
      prompt: null,
      // `<isindex>`
      rev: null,
      // `<link>`
      rightMargin: ke,
      // `<body>`
      rules: null,
      // `<table>`
      scheme: null,
      // `<meta>`
      scrolling: Un,
      // `<frame>`. Use overflow in the child context
      standby: null,
      // `<object>`
      summary: null,
      // `<table>`
      text: null,
      // `<body>`. Use CSS `color` instead
      topMargin: ke,
      // `<body>`
      valueType: null,
      // `<param>`
      version: null,
      // `<html>`. Use a doctype.
      vAlign: null,
      // Several. Use CSS `vertical-align` instead
      vLink: null,
      // `<body>`. Use CSS `a:visited {color}` instead
      vSpace: ke,
      // `<img>` and `<object>`
      // Non-standard Properties.
      allowTransparency: null,
      autoCorrect: null,
      autoSave: null,
      disablePictureInPicture: pt,
      disableRemotePlayback: pt,
      prefix: null,
      property: null,
      results: ke,
      security: null,
      unselectable: null
    },
    space: "html",
    transform: N7
  }), Nje = Gf({
    attributes: {
      accentHeight: "accent-height",
      alignmentBaseline: "alignment-baseline",
      arabicForm: "arabic-form",
      baselineShift: "baseline-shift",
      capHeight: "cap-height",
      className: "class",
      clipPath: "clip-path",
      clipRule: "clip-rule",
      colorInterpolation: "color-interpolation",
      colorInterpolationFilters: "color-interpolation-filters",
      colorProfile: "color-profile",
      colorRendering: "color-rendering",
      crossOrigin: "crossorigin",
      dataType: "datatype",
      dominantBaseline: "dominant-baseline",
      enableBackground: "enable-background",
      fillOpacity: "fill-opacity",
      fillRule: "fill-rule",
      floodColor: "flood-color",
      floodOpacity: "flood-opacity",
      fontFamily: "font-family",
      fontSize: "font-size",
      fontSizeAdjust: "font-size-adjust",
      fontStretch: "font-stretch",
      fontStyle: "font-style",
      fontVariant: "font-variant",
      fontWeight: "font-weight",
      glyphName: "glyph-name",
      glyphOrientationHorizontal: "glyph-orientation-horizontal",
      glyphOrientationVertical: "glyph-orientation-vertical",
      hrefLang: "hreflang",
      horizAdvX: "horiz-adv-x",
      horizOriginX: "horiz-origin-x",
      horizOriginY: "horiz-origin-y",
      imageRendering: "image-rendering",
      letterSpacing: "letter-spacing",
      lightingColor: "lighting-color",
      markerEnd: "marker-end",
      markerMid: "marker-mid",
      markerStart: "marker-start",
      navDown: "nav-down",
      navDownLeft: "nav-down-left",
      navDownRight: "nav-down-right",
      navLeft: "nav-left",
      navNext: "nav-next",
      navPrev: "nav-prev",
      navRight: "nav-right",
      navUp: "nav-up",
      navUpLeft: "nav-up-left",
      navUpRight: "nav-up-right",
      onAbort: "onabort",
      onActivate: "onactivate",
      onAfterPrint: "onafterprint",
      onBeforePrint: "onbeforeprint",
      onBegin: "onbegin",
      onCancel: "oncancel",
      onCanPlay: "oncanplay",
      onCanPlayThrough: "oncanplaythrough",
      onChange: "onchange",
      onClick: "onclick",
      onClose: "onclose",
      onCopy: "oncopy",
      onCueChange: "oncuechange",
      onCut: "oncut",
      onDblClick: "ondblclick",
      onDrag: "ondrag",
      onDragEnd: "ondragend",
      onDragEnter: "ondragenter",
      onDragExit: "ondragexit",
      onDragLeave: "ondragleave",
      onDragOver: "ondragover",
      onDragStart: "ondragstart",
      onDrop: "ondrop",
      onDurationChange: "ondurationchange",
      onEmptied: "onemptied",
      onEnd: "onend",
      onEnded: "onended",
      onError: "onerror",
      onFocus: "onfocus",
      onFocusIn: "onfocusin",
      onFocusOut: "onfocusout",
      onHashChange: "onhashchange",
      onInput: "oninput",
      onInvalid: "oninvalid",
      onKeyDown: "onkeydown",
      onKeyPress: "onkeypress",
      onKeyUp: "onkeyup",
      onLoad: "onload",
      onLoadedData: "onloadeddata",
      onLoadedMetadata: "onloadedmetadata",
      onLoadStart: "onloadstart",
      onMessage: "onmessage",
      onMouseDown: "onmousedown",
      onMouseEnter: "onmouseenter",
      onMouseLeave: "onmouseleave",
      onMouseMove: "onmousemove",
      onMouseOut: "onmouseout",
      onMouseOver: "onmouseover",
      onMouseUp: "onmouseup",
      onMouseWheel: "onmousewheel",
      onOffline: "onoffline",
      onOnline: "ononline",
      onPageHide: "onpagehide",
      onPageShow: "onpageshow",
      onPaste: "onpaste",
      onPause: "onpause",
      onPlay: "onplay",
      onPlaying: "onplaying",
      onPopState: "onpopstate",
      onProgress: "onprogress",
      onRateChange: "onratechange",
      onRepeat: "onrepeat",
      onReset: "onreset",
      onResize: "onresize",
      onScroll: "onscroll",
      onSeeked: "onseeked",
      onSeeking: "onseeking",
      onSelect: "onselect",
      onShow: "onshow",
      onStalled: "onstalled",
      onStorage: "onstorage",
      onSubmit: "onsubmit",
      onSuspend: "onsuspend",
      onTimeUpdate: "ontimeupdate",
      onToggle: "ontoggle",
      onUnload: "onunload",
      onVolumeChange: "onvolumechange",
      onWaiting: "onwaiting",
      onZoom: "onzoom",
      overlinePosition: "overline-position",
      overlineThickness: "overline-thickness",
      paintOrder: "paint-order",
      panose1: "panose-1",
      pointerEvents: "pointer-events",
      referrerPolicy: "referrerpolicy",
      renderingIntent: "rendering-intent",
      shapeRendering: "shape-rendering",
      stopColor: "stop-color",
      stopOpacity: "stop-opacity",
      strikethroughPosition: "strikethrough-position",
      strikethroughThickness: "strikethrough-thickness",
      strokeDashArray: "stroke-dasharray",
      strokeDashOffset: "stroke-dashoffset",
      strokeLineCap: "stroke-linecap",
      strokeLineJoin: "stroke-linejoin",
      strokeMiterLimit: "stroke-miterlimit",
      strokeOpacity: "stroke-opacity",
      strokeWidth: "stroke-width",
      tabIndex: "tabindex",
      textAnchor: "text-anchor",
      textDecoration: "text-decoration",
      textRendering: "text-rendering",
      transformOrigin: "transform-origin",
      typeOf: "typeof",
      underlinePosition: "underline-position",
      underlineThickness: "underline-thickness",
      unicodeBidi: "unicode-bidi",
      unicodeRange: "unicode-range",
      unitsPerEm: "units-per-em",
      vAlphabetic: "v-alphabetic",
      vHanging: "v-hanging",
      vIdeographic: "v-ideographic",
      vMathematical: "v-mathematical",
      vectorEffect: "vector-effect",
      vertAdvY: "vert-adv-y",
      vertOriginX: "vert-origin-x",
      vertOriginY: "vert-origin-y",
      wordSpacing: "word-spacing",
      writingMode: "writing-mode",
      xHeight: "x-height",
      // These were camelcased in Tiny. Now lowercased in SVG 2
      playbackOrder: "playbackorder",
      timelineBegin: "timelinebegin"
    },
    properties: {
      about: no,
      accentHeight: ke,
      accumulate: null,
      additive: null,
      alignmentBaseline: null,
      alphabetic: ke,
      amplitude: ke,
      arabicForm: null,
      ascent: ke,
      attributeName: null,
      attributeType: null,
      azimuth: ke,
      bandwidth: null,
      baselineShift: null,
      baseFrequency: null,
      baseProfile: null,
      bbox: null,
      begin: null,
      bias: ke,
      by: null,
      calcMode: null,
      capHeight: ke,
      className: dn,
      clip: null,
      clipPath: null,
      clipPathUnits: null,
      clipRule: null,
      color: null,
      colorInterpolation: null,
      colorInterpolationFilters: null,
      colorProfile: null,
      colorRendering: null,
      content: null,
      contentScriptType: null,
      contentStyleType: null,
      crossOrigin: null,
      cursor: null,
      cx: null,
      cy: null,
      d: null,
      dataType: null,
      defaultAction: null,
      descent: ke,
      diffuseConstant: ke,
      direction: null,
      display: null,
      dur: null,
      divisor: ke,
      dominantBaseline: null,
      download: pt,
      dx: null,
      dy: null,
      edgeMode: null,
      editable: null,
      elevation: ke,
      enableBackground: null,
      end: null,
      event: null,
      exponent: ke,
      externalResourcesRequired: null,
      fill: null,
      fillOpacity: ke,
      fillRule: null,
      filter: null,
      filterRes: null,
      filterUnits: null,
      floodColor: null,
      floodOpacity: null,
      focusable: null,
      focusHighlight: null,
      fontFamily: null,
      fontSize: null,
      fontSizeAdjust: null,
      fontStretch: null,
      fontStyle: null,
      fontVariant: null,
      fontWeight: null,
      format: null,
      fr: null,
      from: null,
      fx: null,
      fy: null,
      g1: uf,
      g2: uf,
      glyphName: uf,
      glyphOrientationHorizontal: null,
      glyphOrientationVertical: null,
      glyphRef: null,
      gradientTransform: null,
      gradientUnits: null,
      handler: null,
      hanging: ke,
      hatchContentUnits: null,
      hatchUnits: null,
      height: null,
      href: null,
      hrefLang: null,
      horizAdvX: ke,
      horizOriginX: ke,
      horizOriginY: ke,
      id: null,
      ideographic: ke,
      imageRendering: null,
      initialVisibility: null,
      in: null,
      in2: null,
      intercept: ke,
      k: ke,
      k1: ke,
      k2: ke,
      k3: ke,
      k4: ke,
      kernelMatrix: no,
      kernelUnitLength: null,
      keyPoints: null,
      // SEMI_COLON_SEPARATED
      keySplines: null,
      // SEMI_COLON_SEPARATED
      keyTimes: null,
      // SEMI_COLON_SEPARATED
      kerning: null,
      lang: null,
      lengthAdjust: null,
      letterSpacing: null,
      lightingColor: null,
      limitingConeAngle: ke,
      local: null,
      markerEnd: null,
      markerMid: null,
      markerStart: null,
      markerHeight: null,
      markerUnits: null,
      markerWidth: null,
      mask: null,
      maskContentUnits: null,
      maskUnits: null,
      mathematical: null,
      max: null,
      media: null,
      mediaCharacterEncoding: null,
      mediaContentEncodings: null,
      mediaSize: ke,
      mediaTime: null,
      method: null,
      min: null,
      mode: null,
      name: null,
      navDown: null,
      navDownLeft: null,
      navDownRight: null,
      navLeft: null,
      navNext: null,
      navPrev: null,
      navRight: null,
      navUp: null,
      navUpLeft: null,
      navUpRight: null,
      numOctaves: null,
      observer: null,
      offset: null,
      onAbort: null,
      onActivate: null,
      onAfterPrint: null,
      onBeforePrint: null,
      onBegin: null,
      onCancel: null,
      onCanPlay: null,
      onCanPlayThrough: null,
      onChange: null,
      onClick: null,
      onClose: null,
      onCopy: null,
      onCueChange: null,
      onCut: null,
      onDblClick: null,
      onDrag: null,
      onDragEnd: null,
      onDragEnter: null,
      onDragExit: null,
      onDragLeave: null,
      onDragOver: null,
      onDragStart: null,
      onDrop: null,
      onDurationChange: null,
      onEmptied: null,
      onEnd: null,
      onEnded: null,
      onError: null,
      onFocus: null,
      onFocusIn: null,
      onFocusOut: null,
      onHashChange: null,
      onInput: null,
      onInvalid: null,
      onKeyDown: null,
      onKeyPress: null,
      onKeyUp: null,
      onLoad: null,
      onLoadedData: null,
      onLoadedMetadata: null,
      onLoadStart: null,
      onMessage: null,
      onMouseDown: null,
      onMouseEnter: null,
      onMouseLeave: null,
      onMouseMove: null,
      onMouseOut: null,
      onMouseOver: null,
      onMouseUp: null,
      onMouseWheel: null,
      onOffline: null,
      onOnline: null,
      onPageHide: null,
      onPageShow: null,
      onPaste: null,
      onPause: null,
      onPlay: null,
      onPlaying: null,
      onPopState: null,
      onProgress: null,
      onRateChange: null,
      onRepeat: null,
      onReset: null,
      onResize: null,
      onScroll: null,
      onSeeked: null,
      onSeeking: null,
      onSelect: null,
      onShow: null,
      onStalled: null,
      onStorage: null,
      onSubmit: null,
      onSuspend: null,
      onTimeUpdate: null,
      onToggle: null,
      onUnload: null,
      onVolumeChange: null,
      onWaiting: null,
      onZoom: null,
      opacity: null,
      operator: null,
      order: null,
      orient: null,
      orientation: null,
      origin: null,
      overflow: null,
      overlay: null,
      overlinePosition: ke,
      overlineThickness: ke,
      paintOrder: null,
      panose1: null,
      path: null,
      pathLength: ke,
      patternContentUnits: null,
      patternTransform: null,
      patternUnits: null,
      phase: null,
      ping: dn,
      pitch: null,
      playbackOrder: null,
      pointerEvents: null,
      points: null,
      pointsAtX: ke,
      pointsAtY: ke,
      pointsAtZ: ke,
      preserveAlpha: null,
      preserveAspectRatio: null,
      primitiveUnits: null,
      propagate: null,
      property: no,
      r: null,
      radius: null,
      referrerPolicy: null,
      refX: null,
      refY: null,
      rel: no,
      rev: no,
      renderingIntent: null,
      repeatCount: null,
      repeatDur: null,
      requiredExtensions: no,
      requiredFeatures: no,
      requiredFonts: no,
      requiredFormats: no,
      resource: null,
      restart: null,
      result: null,
      rotate: null,
      rx: null,
      ry: null,
      scale: null,
      seed: null,
      shapeRendering: null,
      side: null,
      slope: null,
      snapshotTime: null,
      specularConstant: ke,
      specularExponent: ke,
      spreadMethod: null,
      spacing: null,
      startOffset: null,
      stdDeviation: null,
      stemh: null,
      stemv: null,
      stitchTiles: null,
      stopColor: null,
      stopOpacity: null,
      strikethroughPosition: ke,
      strikethroughThickness: ke,
      string: null,
      stroke: null,
      strokeDashArray: no,
      strokeDashOffset: null,
      strokeLineCap: null,
      strokeLineJoin: null,
      strokeMiterLimit: ke,
      strokeOpacity: ke,
      strokeWidth: null,
      style: null,
      surfaceScale: ke,
      syncBehavior: null,
      syncBehaviorDefault: null,
      syncMaster: null,
      syncTolerance: null,
      syncToleranceDefault: null,
      systemLanguage: no,
      tabIndex: ke,
      tableValues: null,
      target: null,
      targetX: ke,
      targetY: ke,
      textAnchor: null,
      textDecoration: null,
      textRendering: null,
      textLength: null,
      timelineBegin: null,
      title: null,
      transformBehavior: null,
      type: null,
      typeOf: no,
      to: null,
      transform: null,
      transformOrigin: null,
      u1: null,
      u2: null,
      underlinePosition: ke,
      underlineThickness: ke,
      unicode: null,
      unicodeBidi: null,
      unicodeRange: null,
      unitsPerEm: ke,
      values: null,
      vAlphabetic: ke,
      vMathematical: ke,
      vectorEffect: null,
      vHanging: ke,
      vIdeographic: ke,
      version: null,
      vertAdvY: ke,
      vertOriginX: ke,
      vertOriginY: ke,
      viewBox: null,
      viewTarget: null,
      visibility: null,
      width: null,
      widths: null,
      wordSpacing: null,
      writingMode: null,
      x: null,
      x1: null,
      x2: null,
      xChannelSelector: null,
      xHeight: ke,
      y: null,
      y1: null,
      y2: null,
      yChannelSelector: null,
      z: null,
      zoomAndPan: null
    },
    space: "svg",
    transform: M7
  }), P7 = Gf({
    properties: {
      xLinkActuate: null,
      xLinkArcRole: null,
      xLinkHref: null,
      xLinkRole: null,
      xLinkShow: null,
      xLinkTitle: null,
      xLinkType: null
    },
    space: "xlink",
    transform(e, t) {
      return "xlink:" + t.slice(5).toLowerCase();
    }
  }), I7 = Gf({
    attributes: { xmlnsxlink: "xmlns:xlink" },
    properties: { xmlnsXLink: null, xmlns: null },
    space: "xmlns",
    transform: N7
  }), $7 = Gf({
    properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
    space: "xml",
    transform(e, t) {
      return "xml:" + t.slice(3).toLowerCase();
    }
  }), Pje = {
    classId: "classID",
    dataType: "datatype",
    itemId: "itemID",
    strokeDashArray: "strokeDasharray",
    strokeDashOffset: "strokeDashoffset",
    strokeLineCap: "strokeLinecap",
    strokeLineJoin: "strokeLinejoin",
    strokeMiterLimit: "strokeMiterlimit",
    typeOf: "typeof",
    xLinkActuate: "xlinkActuate",
    xLinkArcRole: "xlinkArcrole",
    xLinkHref: "xlinkHref",
    xLinkRole: "xlinkRole",
    xLinkShow: "xlinkShow",
    xLinkTitle: "xlinkTitle",
    xLinkType: "xlinkType",
    xmlnsXLink: "xmlnsXlink"
  }, Ije = /[A-Z]/g, e4 = /-[a-z]/g, $je = /^data[-\w.:]+$/i;
  function jje(e, t) {
    const n = GC(t);
    let r = t, o = Wr;
    if (n in e.normal)
      return e.property[e.normal[n]];
    if (n.length > 4 && n.slice(0, 4) === "data" && $je.test(t)) {
      if (t.charAt(4) === "-") {
        const i = t.slice(5).replace(e4, Fje);
        r = "data" + i.charAt(0).toUpperCase() + i.slice(1);
      } else {
        const i = t.slice(4);
        if (!e4.test(i)) {
          let a = i.replace(Ije, Dje);
          a.charAt(0) !== "-" && (a = "-" + a), t = "data" + a;
        }
      }
      o = hR;
    }
    return new o(r, t);
  }
  function Dje(e) {
    return "-" + e.toLowerCase();
  }
  function Fje(e) {
    return e.charAt(1).toUpperCase();
  }
  const Lje = R7([O7, Mje, P7, I7, $7], "html"), mR = R7([O7, Nje, P7, I7, $7], "svg");
  function zje(e) {
    return e.join(" ").trim();
  }
  var Fu = {}, J_, t4;
  function Bje() {
    if (t4) return J_;
    t4 = 1;
    var e = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, t = /\n/g, n = /^\s*/, r = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, o = /^:\s*/, i = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, a = /^[;\s]*/, s = /^\s+|\s+$/g, c = `
`, u = "/", d = "*", p = "", m = "comment", g = "declaration";
    J_ = function(b, v) {
      if (typeof b != "string")
        throw new TypeError("First argument must be a string");
      if (!b) return [];
      v = v || {};
      var x = 1, E = 1;
      function _(U) {
        var j = U.match(t);
        j && (x += j.length);
        var V = U.lastIndexOf(c);
        E = ~V ? U.length - V : E + U.length;
      }
      function C() {
        var U = { line: x, column: E };
        return function(j) {
          return j.position = new k(U), P(), j;
        };
      }
      function k(U) {
        this.start = U, this.end = { line: x, column: E }, this.source = v.source;
      }
      k.prototype.content = b;
      function A(U) {
        var j = new Error(
          v.source + ":" + x + ":" + E + ": " + U
        );
        if (j.reason = U, j.filename = v.source, j.line = x, j.column = E, j.source = b, !v.silent) throw j;
      }
      function O(U) {
        var j = U.exec(b);
        if (j) {
          var V = j[0];
          return _(V), b = b.slice(V.length), j;
        }
      }
      function P() {
        O(n);
      }
      function I(U) {
        var j;
        for (U = U || []; j = $(); )
          j !== !1 && U.push(j);
        return U;
      }
      function $() {
        var U = C();
        if (!(u != b.charAt(0) || d != b.charAt(1))) {
          for (var j = 2; p != b.charAt(j) && (d != b.charAt(j) || u != b.charAt(j + 1)); )
            ++j;
          if (j += 2, p === b.charAt(j - 1))
            return A("End of comment missing");
          var V = b.slice(2, j - 2);
          return E += 2, _(V), b = b.slice(j), E += 2, U({
            type: m,
            comment: V
          });
        }
      }
      function L() {
        var U = C(), j = O(r);
        if (j) {
          if ($(), !O(o)) return A("property missing ':'");
          var V = O(i), F = U({
            type: g,
            property: y(j[0].replace(e, p)),
            value: V ? y(V[0].replace(e, p)) : p
          });
          return O(a), F;
        }
      }
      function N() {
        var U = [];
        I(U);
        for (var j; j = L(); )
          j !== !1 && (U.push(j), I(U));
        return U;
      }
      return P(), N();
    };
    function y(b) {
      return b ? b.replace(s, p) : p;
    }
    return J_;
  }
  var n4;
  function Uje() {
    if (n4) return Fu;
    n4 = 1;
    var e = Fu && Fu.__importDefault || function(r) {
      return r && r.__esModule ? r : { default: r };
    };
    Object.defineProperty(Fu, "__esModule", { value: !0 }), Fu.default = n;
    var t = e(Bje());
    function n(r, o) {
      var i = null;
      if (!r || typeof r != "string")
        return i;
      var a = (0, t.default)(r), s = typeof o == "function";
      return a.forEach(function(c) {
        if (c.type === "declaration") {
          var u = c.property, d = c.value;
          s ? o(u, d, c) : d && (i = i || {}, i[u] = d);
        }
      }), i;
    }
    return Fu;
  }
  var lp = {}, r4;
  function Vje() {
    if (r4) return lp;
    r4 = 1, Object.defineProperty(lp, "__esModule", { value: !0 }), lp.camelCase = void 0;
    var e = /^--[a-zA-Z0-9_-]+$/, t = /-([a-z])/g, n = /^[^-]+$/, r = /^-(webkit|moz|ms|o|khtml)-/, o = /^-(ms)-/, i = function(u) {
      return !u || n.test(u) || e.test(u);
    }, a = function(u, d) {
      return d.toUpperCase();
    }, s = function(u, d) {
      return "".concat(d, "-");
    }, c = function(u, d) {
      return d === void 0 && (d = {}), i(u) ? u : (u = u.toLowerCase(), d.reactCompat ? u = u.replace(o, s) : u = u.replace(r, s), u.replace(t, a));
    };
    return lp.camelCase = c, lp;
  }
  var cp, o4;
  function Hje() {
    if (o4) return cp;
    o4 = 1;
    var e = cp && cp.__importDefault || function(o) {
      return o && o.__esModule ? o : { default: o };
    }, t = e(Uje()), n = Vje();
    function r(o, i) {
      var a = {};
      return !o || typeof o != "string" || (0, t.default)(o, function(s, c) {
        s && c && (a[(0, n.camelCase)(s, i)] = c);
      }), a;
    }
    return r.default = r, cp = r, cp;
  }
  var qje = Hje();
  const Wje = /* @__PURE__ */ Xi(qje), j7 = D7("end"), gR = D7("start");
  function D7(e) {
    return t;
    function t(n) {
      const r = n && n.position && n.position[e] || {};
      if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
        return {
          line: r.line,
          column: r.column,
          offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
        };
    }
  }
  function Gje(e) {
    const t = gR(e), n = j7(e);
    if (t && n)
      return { start: t, end: n };
  }
  function Vp(e) {
    return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? i4(e.position) : "start" in e || "end" in e ? i4(e) : "line" in e || "column" in e ? XC(e) : "";
  }
  function XC(e) {
    return a4(e && e.line) + ":" + a4(e && e.column);
  }
  function i4(e) {
    return XC(e && e.start) + "-" + XC(e && e.end);
  }
  function a4(e) {
    return e && typeof e == "number" ? e : 1;
  }
  class _r extends Error {
    /**
     * Create a message for `reason`.
     *
     * >  **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {Options | null | undefined} [options]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns
     *   Instance of `VFileMessage`.
     */
    // eslint-disable-next-line complexity
    constructor(t, n, r) {
      super(), typeof n == "string" && (r = n, n = void 0);
      let o = "", i = {}, a = !1;
      if (n && ("line" in n && "column" in n ? i = { place: n } : "start" in n && "end" in n ? i = { place: n } : "type" in n ? i = {
        ancestors: [n],
        place: n.position
      } : i = { ...n }), typeof t == "string" ? o = t : !i.cause && t && (a = !0, o = t.message, i.cause = t), !i.ruleId && !i.source && typeof r == "string") {
        const c = r.indexOf(":");
        c === -1 ? i.ruleId = r : (i.source = r.slice(0, c), i.ruleId = r.slice(c + 1));
      }
      if (!i.place && i.ancestors && i.ancestors) {
        const c = i.ancestors[i.ancestors.length - 1];
        c && (i.place = c.position);
      }
      const s = i.place && "start" in i.place ? i.place.start : i.place;
      this.ancestors = i.ancestors || void 0, this.cause = i.cause || void 0, this.column = s ? s.column : void 0, this.fatal = void 0, this.file, this.message = o, this.line = s ? s.line : void 0, this.name = Vp(i.place) || "1:1", this.place = i.place || void 0, this.reason = this.message, this.ruleId = i.ruleId || void 0, this.source = i.source || void 0, this.stack = a && i.cause && typeof i.cause.stack == "string" ? i.cause.stack : "", this.actual, this.expected, this.note, this.url;
    }
  }
  _r.prototype.file = "";
  _r.prototype.name = "";
  _r.prototype.reason = "";
  _r.prototype.message = "";
  _r.prototype.stack = "";
  _r.prototype.column = void 0;
  _r.prototype.line = void 0;
  _r.prototype.ancestors = void 0;
  _r.prototype.cause = void 0;
  _r.prototype.fatal = void 0;
  _r.prototype.place = void 0;
  _r.prototype.ruleId = void 0;
  _r.prototype.source = void 0;
  const yR = {}.hasOwnProperty, Kje = /* @__PURE__ */ new Map(), Yje = /[A-Z]/g, Xje = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), Zje = /* @__PURE__ */ new Set(["td", "th"]), F7 = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
  function Qje(e, t) {
    if (!t || t.Fragment === void 0)
      throw new TypeError("Expected `Fragment` in options");
    const n = t.filePath || void 0;
    let r;
    if (t.development) {
      if (typeof t.jsxDEV != "function")
        throw new TypeError(
          "Expected `jsxDEV` in options when `development: true`"
        );
      r = aDe(n, t.jsxDEV);
    } else {
      if (typeof t.jsx != "function")
        throw new TypeError("Expected `jsx` in production options");
      if (typeof t.jsxs != "function")
        throw new TypeError("Expected `jsxs` in production options");
      r = iDe(n, t.jsx, t.jsxs);
    }
    const o = {
      Fragment: t.Fragment,
      ancestors: [],
      components: t.components || {},
      create: r,
      elementAttributeNameCase: t.elementAttributeNameCase || "react",
      evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
      filePath: n,
      ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
      passKeys: t.passKeys !== !1,
      passNode: t.passNode || !1,
      schema: t.space === "svg" ? mR : Lje,
      stylePropertyNameCase: t.stylePropertyNameCase || "dom",
      tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
    }, i = L7(o, e, void 0);
    return i && typeof i != "string" ? i : o.create(
      e,
      o.Fragment,
      { children: i || void 0 },
      void 0
    );
  }
  function L7(e, t, n) {
    if (t.type === "element")
      return Jje(e, t, n);
    if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
      return eDe(e, t);
    if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
      return nDe(e, t, n);
    if (t.type === "mdxjsEsm")
      return tDe(e, t);
    if (t.type === "root")
      return rDe(e, t, n);
    if (t.type === "text")
      return oDe(e, t);
  }
  function Jje(e, t, n) {
    const r = e.schema;
    let o = r;
    t.tagName.toLowerCase() === "svg" && r.space === "html" && (o = mR, e.schema = o), e.ancestors.push(t);
    const i = B7(e, t.tagName, !1), a = sDe(e, t);
    let s = bR(e, t);
    return Xje.has(t.tagName) && (s = s.filter(function(c) {
      return typeof c == "string" ? !Rje(c) : !0;
    })), z7(e, a, i, t), vR(a, s), e.ancestors.pop(), e.schema = r, e.create(t, i, a, n);
  }
  function eDe(e, t) {
    if (t.data && t.data.estree && e.evaluater) {
      const r = t.data.estree.body[0];
      return r.type, /** @type {Child | undefined} */
      e.evaluater.evaluateExpression(r.expression);
    }
    Ah(e, t.position);
  }
  function tDe(e, t) {
    if (t.data && t.data.estree && e.evaluater)
      return (
        /** @type {Child | undefined} */
        e.evaluater.evaluateProgram(t.data.estree)
      );
    Ah(e, t.position);
  }
  function nDe(e, t, n) {
    const r = e.schema;
    let o = r;
    t.name === "svg" && r.space === "html" && (o = mR, e.schema = o), e.ancestors.push(t);
    const i = t.name === null ? e.Fragment : B7(e, t.name, !0), a = lDe(e, t), s = bR(e, t);
    return z7(e, a, i, t), vR(a, s), e.ancestors.pop(), e.schema = r, e.create(t, i, a, n);
  }
  function rDe(e, t, n) {
    const r = {};
    return vR(r, bR(e, t)), e.create(t, e.Fragment, r, n);
  }
  function oDe(e, t) {
    return t.value;
  }
  function z7(e, t, n, r) {
    typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
  }
  function vR(e, t) {
    if (t.length > 0) {
      const n = t.length > 1 ? t : t[0];
      n && (e.children = n);
    }
  }
  function iDe(e, t, n) {
    return r;
    function r(o, i, a, s) {
      const u = Array.isArray(a.children) ? n : t;
      return s ? u(i, a, s) : u(i, a);
    }
  }
  function aDe(e, t) {
    return n;
    function n(r, o, i, a) {
      const s = Array.isArray(i.children), c = gR(r);
      return t(
        o,
        i,
        a,
        s,
        {
          columnNumber: c ? c.column - 1 : void 0,
          fileName: e,
          lineNumber: c ? c.line : void 0
        },
        void 0
      );
    }
  }
  function sDe(e, t) {
    const n = {};
    let r, o;
    for (o in t.properties)
      if (o !== "children" && yR.call(t.properties, o)) {
        const i = cDe(e, o, t.properties[o]);
        if (i) {
          const [a, s] = i;
          e.tableCellAlignToStyle && a === "align" && typeof s == "string" && Zje.has(t.tagName) ? r = s : n[a] = s;
        }
      }
    if (r) {
      const i = (
        /** @type {Style} */
        n.style || (n.style = {})
      );
      i[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
    }
    return n;
  }
  function lDe(e, t) {
    const n = {};
    for (const r of t.attributes)
      if (r.type === "mdxJsxExpressionAttribute")
        if (r.data && r.data.estree && e.evaluater) {
          const i = r.data.estree.body[0];
          i.type;
          const a = i.expression;
          a.type;
          const s = a.properties[0];
          s.type, Object.assign(
            n,
            e.evaluater.evaluateExpression(s.argument)
          );
        } else
          Ah(e, t.position);
      else {
        const o = r.name;
        let i;
        if (r.value && typeof r.value == "object")
          if (r.value.data && r.value.data.estree && e.evaluater) {
            const s = r.value.data.estree.body[0];
            s.type, i = e.evaluater.evaluateExpression(s.expression);
          } else
            Ah(e, t.position);
        else
          i = r.value === null ? !0 : r.value;
        n[o] = /** @type {Props[keyof Props]} */
        i;
      }
    return n;
  }
  function bR(e, t) {
    const n = [];
    let r = -1;
    const o = e.passKeys ? /* @__PURE__ */ new Map() : Kje;
    for (; ++r < t.children.length; ) {
      const i = t.children[r];
      let a;
      if (e.passKeys) {
        const c = i.type === "element" ? i.tagName : i.type === "mdxJsxFlowElement" || i.type === "mdxJsxTextElement" ? i.name : void 0;
        if (c) {
          const u = o.get(c) || 0;
          a = c + "-" + u, o.set(c, u + 1);
        }
      }
      const s = L7(e, i, a);
      s !== void 0 && n.push(s);
    }
    return n;
  }
  function cDe(e, t, n) {
    const r = jje(e.schema, t);
    if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
      if (Array.isArray(n) && (n = r.commaSeparated ? Eje(n) : zje(n)), r.property === "style") {
        let o = typeof n == "object" ? n : uDe(e, String(n));
        return e.stylePropertyNameCase === "css" && (o = fDe(o)), ["style", o];
      }
      return [
        e.elementAttributeNameCase === "react" && r.space ? Pje[r.property] || r.property : r.attribute,
        n
      ];
    }
  }
  function uDe(e, t) {
    try {
      return Wje(t, { reactCompat: !0 });
    } catch (n) {
      if (e.ignoreInvalidStyle)
        return {};
      const r = (
        /** @type {Error} */
        n
      ), o = new _r("Cannot parse `style` attribute", {
        ancestors: e.ancestors,
        cause: r,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      throw o.file = e.filePath || void 0, o.url = F7 + "#cannot-parse-style-attribute", o;
    }
  }
  function B7(e, t, n) {
    let r;
    if (!n)
      r = { type: "Literal", value: t };
    else if (t.includes(".")) {
      const o = t.split(".");
      let i = -1, a;
      for (; ++i < o.length; ) {
        const s = Z3(o[i]) ? { type: "Identifier", name: o[i] } : { type: "Literal", value: o[i] };
        a = a ? {
          type: "MemberExpression",
          object: a,
          property: s,
          computed: !!(i && s.type === "Literal"),
          optional: !1
        } : s;
      }
      r = a;
    } else
      r = Z3(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
    if (r.type === "Literal") {
      const o = (
        /** @type {string | number} */
        r.value
      );
      return yR.call(e.components, o) ? e.components[o] : o;
    }
    if (e.evaluater)
      return e.evaluater.evaluateExpression(r);
    Ah(e);
  }
  function Ah(e, t) {
    const n = new _r(
      "Cannot handle MDX estrees without `createEvaluater`",
      {
        ancestors: e.ancestors,
        place: t,
        ruleId: "mdx-estree",
        source: "hast-util-to-jsx-runtime"
      }
    );
    throw n.file = e.filePath || void 0, n.url = F7 + "#cannot-handle-mdx-estrees-without-createevaluater", n;
  }
  function fDe(e) {
    const t = {};
    let n;
    for (n in e)
      yR.call(e, n) && (t[dDe(n)] = e[n]);
    return t;
  }
  function dDe(e) {
    let t = e.replace(Yje, pDe);
    return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
  }
  function pDe(e) {
    return "-" + e.toLowerCase();
  }
  const eE = {
    action: ["form"],
    cite: ["blockquote", "del", "ins", "q"],
    data: ["object"],
    formAction: ["button", "input"],
    href: ["a", "area", "base", "link"],
    icon: ["menuitem"],
    itemId: null,
    manifest: ["html"],
    ping: ["a", "area"],
    poster: ["video"],
    src: [
      "audio",
      "embed",
      "iframe",
      "img",
      "input",
      "script",
      "source",
      "track",
      "video"
    ]
  }, hDe = {};
  function xR(e, t) {
    const n = hDe, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, o = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
    return U7(e, r, o);
  }
  function U7(e, t, n) {
    if (mDe(e)) {
      if ("value" in e)
        return e.type === "html" && !n ? "" : e.value;
      if (t && "alt" in e && e.alt)
        return e.alt;
      if ("children" in e)
        return s4(e.children, t, n);
    }
    return Array.isArray(e) ? s4(e, t, n) : "";
  }
  function s4(e, t, n) {
    const r = [];
    let o = -1;
    for (; ++o < e.length; )
      r[o] = U7(e[o], t, n);
    return r.join("");
  }
  function mDe(e) {
    return !!(e && typeof e == "object");
  }
  const l4 = document.createElement("i");
  function wR(e) {
    const t = "&" + e + ";";
    l4.innerHTML = t;
    const n = l4.textContent;
    return (
      // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
      // yield `null`.
      n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n
    );
  }
  function uo(e, t, n, r) {
    const o = e.length;
    let i = 0, a;
    if (t < 0 ? t = -t > o ? 0 : o + t : t = t > o ? o : t, n = n > 0 ? n : 0, r.length < 1e4)
      a = Array.from(r), a.unshift(t, n), e.splice(...a);
    else
      for (n && e.splice(t, n); i < r.length; )
        a = r.slice(i, i + 1e4), a.unshift(t, 0), e.splice(...a), i += 1e4, t += 1e4;
  }
  function Oo(e, t) {
    return e.length > 0 ? (uo(e, e.length, 0, t), e) : t;
  }
  const c4 = {}.hasOwnProperty;
  function V7(e) {
    const t = {};
    let n = -1;
    for (; ++n < e.length; )
      gDe(t, e[n]);
    return t;
  }
  function gDe(e, t) {
    let n;
    for (n in t) {
      const o = (c4.call(e, n) ? e[n] : void 0) || (e[n] = {}), i = t[n];
      let a;
      if (i)
        for (a in i) {
          c4.call(o, a) || (o[a] = []);
          const s = i[a];
          yDe(
            // @ts-expect-error Looks like a list.
            o[a],
            Array.isArray(s) ? s : s ? [s] : []
          );
        }
    }
  }
  function yDe(e, t) {
    let n = -1;
    const r = [];
    for (; ++n < t.length; )
      (t[n].add === "after" ? e : r).push(t[n]);
    uo(e, 0, 0, r);
  }
  function H7(e, t) {
    const n = Number.parseInt(e, t);
    return (
      // C0 except for HT, LF, FF, CR, space.
      n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
      n > 126 && n < 160 || // Lone high surrogates and low surrogates.
      n > 55295 && n < 57344 || // Noncharacters.
      n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
      (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
      // Out of range
      n > 1114111 ? "" : String.fromCodePoint(n)
    );
  }
  function Jo(e) {
    return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
  }
  const Tr = vl(/[A-Za-z]/), br = vl(/[\dA-Za-z]/), vDe = vl(/[#-'*+\--9=?A-Z^-~]/);
  function G0(e) {
    return (
      // Special whitespace codes (which have negative values), C0 and Control
      // character DEL
      e !== null && (e < 32 || e === 127)
    );
  }
  const ZC = vl(/\d/), bDe = vl(/[\dA-Fa-f]/), xDe = vl(/[!-/:-@[-`{-~]/);
  function Ze(e) {
    return e !== null && e < -2;
  }
  function cn(e) {
    return e !== null && (e < 0 || e === 32);
  }
  function _t(e) {
    return e === -2 || e === -1 || e === 32;
  }
  const F1 = vl(/\p{P}|\p{S}/u), Sc = vl(/\s/);
  function vl(e) {
    return t;
    function t(n) {
      return n !== null && n > -1 && e.test(String.fromCharCode(n));
    }
  }
  function Kf(e) {
    const t = [];
    let n = -1, r = 0, o = 0;
    for (; ++n < e.length; ) {
      const i = e.charCodeAt(n);
      let a = "";
      if (i === 37 && br(e.charCodeAt(n + 1)) && br(e.charCodeAt(n + 2)))
        o = 2;
      else if (i < 128)
        /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(i)) || (a = String.fromCharCode(i));
      else if (i > 55295 && i < 57344) {
        const s = e.charCodeAt(n + 1);
        i < 56320 && s > 56319 && s < 57344 ? (a = String.fromCharCode(i, s), o = 1) : a = "";
      } else
        a = String.fromCharCode(i);
      a && (t.push(e.slice(r, n), encodeURIComponent(a)), r = n + o + 1, a = ""), o && (n += o, o = 0);
    }
    return t.join("") + e.slice(r);
  }
  function Pt(e, t, n, r) {
    const o = r ? r - 1 : Number.POSITIVE_INFINITY;
    let i = 0;
    return a;
    function a(c) {
      return _t(c) ? (e.enter(n), s(c)) : t(c);
    }
    function s(c) {
      return _t(c) && i++ < o ? (e.consume(c), s) : (e.exit(n), t(c));
    }
  }
  const wDe = {
    tokenize: SDe
  };
  function SDe(e) {
    const t = e.attempt(this.parser.constructs.contentInitial, r, o);
    let n;
    return t;
    function r(s) {
      if (s === null) {
        e.consume(s);
        return;
      }
      return e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), Pt(e, t, "linePrefix");
    }
    function o(s) {
      return e.enter("paragraph"), i(s);
    }
    function i(s) {
      const c = e.enter("chunkText", {
        contentType: "text",
        previous: n
      });
      return n && (n.next = c), n = c, a(s);
    }
    function a(s) {
      if (s === null) {
        e.exit("chunkText"), e.exit("paragraph"), e.consume(s);
        return;
      }
      return Ze(s) ? (e.consume(s), e.exit("chunkText"), i) : (e.consume(s), a);
    }
  }
  const _De = {
    tokenize: EDe
  }, u4 = {
    tokenize: CDe
  };
  function EDe(e) {
    const t = this, n = [];
    let r = 0, o, i, a;
    return s;
    function s(_) {
      if (r < n.length) {
        const C = n[r];
        return t.containerState = C[1], e.attempt(C[0].continuation, c, u)(_);
      }
      return u(_);
    }
    function c(_) {
      if (r++, t.containerState._closeFlow) {
        t.containerState._closeFlow = void 0, o && E();
        const C = t.events.length;
        let k = C, A;
        for (; k--; )
          if (t.events[k][0] === "exit" && t.events[k][1].type === "chunkFlow") {
            A = t.events[k][1].end;
            break;
          }
        x(r);
        let O = C;
        for (; O < t.events.length; )
          t.events[O][1].end = {
            ...A
          }, O++;
        return uo(t.events, k + 1, 0, t.events.slice(C)), t.events.length = O, u(_);
      }
      return s(_);
    }
    function u(_) {
      if (r === n.length) {
        if (!o)
          return m(_);
        if (o.currentConstruct && o.currentConstruct.concrete)
          return y(_);
        t.interrupt = !!(o.currentConstruct && !o._gfmTableDynamicInterruptHack);
      }
      return t.containerState = {}, e.check(u4, d, p)(_);
    }
    function d(_) {
      return o && E(), x(r), m(_);
    }
    function p(_) {
      return t.parser.lazy[t.now().line] = r !== n.length, a = t.now().offset, y(_);
    }
    function m(_) {
      return t.containerState = {}, e.attempt(u4, g, y)(_);
    }
    function g(_) {
      return r++, n.push([t.currentConstruct, t.containerState]), m(_);
    }
    function y(_) {
      if (_ === null) {
        o && E(), x(0), e.consume(_);
        return;
      }
      return o = o || t.parser.flow(t.now()), e.enter("chunkFlow", {
        _tokenizer: o,
        contentType: "flow",
        previous: i
      }), b(_);
    }
    function b(_) {
      if (_ === null) {
        v(e.exit("chunkFlow"), !0), x(0), e.consume(_);
        return;
      }
      return Ze(_) ? (e.consume(_), v(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, s) : (e.consume(_), b);
    }
    function v(_, C) {
      const k = t.sliceStream(_);
      if (C && k.push(null), _.previous = i, i && (i.next = _), i = _, o.defineSkip(_.start), o.write(k), t.parser.lazy[_.start.line]) {
        let A = o.events.length;
        for (; A--; )
          if (
            // The token starts before the line ending
            o.events[A][1].start.offset < a && // and either is not ended yet
            (!o.events[A][1].end || // or ends after it.
            o.events[A][1].end.offset > a)
          )
            return;
        const O = t.events.length;
        let P = O, I, $;
        for (; P--; )
          if (t.events[P][0] === "exit" && t.events[P][1].type === "chunkFlow") {
            if (I) {
              $ = t.events[P][1].end;
              break;
            }
            I = !0;
          }
        for (x(r), A = O; A < t.events.length; )
          t.events[A][1].end = {
            ...$
          }, A++;
        uo(t.events, P + 1, 0, t.events.slice(O)), t.events.length = A;
      }
    }
    function x(_) {
      let C = n.length;
      for (; C-- > _; ) {
        const k = n[C];
        t.containerState = k[1], k[0].exit.call(t, e);
      }
      n.length = _;
    }
    function E() {
      o.write([null]), i = void 0, o = void 0, t.containerState._closeFlow = void 0;
    }
  }
  function CDe(e, t, n) {
    return Pt(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4);
  }
  function Nf(e) {
    if (e === null || cn(e) || Sc(e))
      return 1;
    if (F1(e))
      return 2;
  }
  function L1(e, t, n) {
    const r = [];
    let o = -1;
    for (; ++o < e.length; ) {
      const i = e[o].resolveAll;
      i && !r.includes(i) && (t = i(t, n), r.push(i));
    }
    return t;
  }
  const QC = {
    name: "attention",
    resolveAll: kDe,
    tokenize: TDe
  };
  function kDe(e, t) {
    let n = -1, r, o, i, a, s, c, u, d;
    for (; ++n < e.length; )
      if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
        for (r = n; r--; )
          if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
          t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
            if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
              continue;
            c = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
            const p = {
              ...e[r][1].end
            }, m = {
              ...e[n][1].start
            };
            f4(p, -c), f4(m, c), a = {
              type: c > 1 ? "strongSequence" : "emphasisSequence",
              start: p,
              end: {
                ...e[r][1].end
              }
            }, s = {
              type: c > 1 ? "strongSequence" : "emphasisSequence",
              start: {
                ...e[n][1].start
              },
              end: m
            }, i = {
              type: c > 1 ? "strongText" : "emphasisText",
              start: {
                ...e[r][1].end
              },
              end: {
                ...e[n][1].start
              }
            }, o = {
              type: c > 1 ? "strong" : "emphasis",
              start: {
                ...a.start
              },
              end: {
                ...s.end
              }
            }, e[r][1].end = {
              ...a.start
            }, e[n][1].start = {
              ...s.end
            }, u = [], e[r][1].end.offset - e[r][1].start.offset && (u = Oo(u, [["enter", e[r][1], t], ["exit", e[r][1], t]])), u = Oo(u, [["enter", o, t], ["enter", a, t], ["exit", a, t], ["enter", i, t]]), u = Oo(u, L1(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), u = Oo(u, [["exit", i, t], ["enter", s, t], ["exit", s, t], ["exit", o, t]]), e[n][1].end.offset - e[n][1].start.offset ? (d = 2, u = Oo(u, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : d = 0, uo(e, r - 1, n - r + 3, u), n = r + u.length - d - 2;
            break;
          }
      }
    for (n = -1; ++n < e.length; )
      e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
    return e;
  }
  function TDe(e, t) {
    const n = this.parser.constructs.attentionMarkers.null, r = this.previous, o = Nf(r);
    let i;
    return a;
    function a(c) {
      return i = c, e.enter("attentionSequence"), s(c);
    }
    function s(c) {
      if (c === i)
        return e.consume(c), s;
      const u = e.exit("attentionSequence"), d = Nf(c), p = !d || d === 2 && o || n.includes(c), m = !o || o === 2 && d || n.includes(r);
      return u._open = !!(i === 42 ? p : p && (o || !m)), u._close = !!(i === 42 ? m : m && (d || !p)), t(c);
    }
  }
  function f4(e, t) {
    e.column += t, e.offset += t, e._bufferIndex += t;
  }
  const ADe = {
    name: "autolink",
    tokenize: RDe
  };
  function RDe(e, t, n) {
    let r = 0;
    return o;
    function o(g) {
      return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(g), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), i;
    }
    function i(g) {
      return Tr(g) ? (e.consume(g), a) : g === 64 ? n(g) : u(g);
    }
    function a(g) {
      return g === 43 || g === 45 || g === 46 || br(g) ? (r = 1, s(g)) : u(g);
    }
    function s(g) {
      return g === 58 ? (e.consume(g), r = 0, c) : (g === 43 || g === 45 || g === 46 || br(g)) && r++ < 32 ? (e.consume(g), s) : (r = 0, u(g));
    }
    function c(g) {
      return g === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(g), e.exit("autolinkMarker"), e.exit("autolink"), t) : g === null || g === 32 || g === 60 || G0(g) ? n(g) : (e.consume(g), c);
    }
    function u(g) {
      return g === 64 ? (e.consume(g), d) : vDe(g) ? (e.consume(g), u) : n(g);
    }
    function d(g) {
      return br(g) ? p(g) : n(g);
    }
    function p(g) {
      return g === 46 ? (e.consume(g), r = 0, d) : g === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(g), e.exit("autolinkMarker"), e.exit("autolink"), t) : m(g);
    }
    function m(g) {
      if ((g === 45 || br(g)) && r++ < 63) {
        const y = g === 45 ? m : p;
        return e.consume(g), y;
      }
      return n(g);
    }
  }
  const Sm = {
    partial: !0,
    tokenize: ODe
  };
  function ODe(e, t, n) {
    return r;
    function r(i) {
      return _t(i) ? Pt(e, o, "linePrefix")(i) : o(i);
    }
    function o(i) {
      return i === null || Ze(i) ? t(i) : n(i);
    }
  }
  const q7 = {
    continuation: {
      tokenize: NDe
    },
    exit: PDe,
    name: "blockQuote",
    tokenize: MDe
  };
  function MDe(e, t, n) {
    const r = this;
    return o;
    function o(a) {
      if (a === 62) {
        const s = r.containerState;
        return s.open || (e.enter("blockQuote", {
          _container: !0
        }), s.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(a), e.exit("blockQuoteMarker"), i;
      }
      return n(a);
    }
    function i(a) {
      return _t(a) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(a), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(a));
    }
  }
  function NDe(e, t, n) {
    const r = this;
    return o;
    function o(a) {
      return _t(a) ? Pt(e, i, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(a) : i(a);
    }
    function i(a) {
      return e.attempt(q7, t, n)(a);
    }
  }
  function PDe(e) {
    e.exit("blockQuote");
  }
  const W7 = {
    name: "characterEscape",
    tokenize: IDe
  };
  function IDe(e, t, n) {
    return r;
    function r(i) {
      return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(i), e.exit("escapeMarker"), o;
    }
    function o(i) {
      return xDe(i) ? (e.enter("characterEscapeValue"), e.consume(i), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(i);
    }
  }
  const G7 = {
    name: "characterReference",
    tokenize: $De
  };
  function $De(e, t, n) {
    const r = this;
    let o = 0, i, a;
    return s;
    function s(p) {
      return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(p), e.exit("characterReferenceMarker"), c;
    }
    function c(p) {
      return p === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(p), e.exit("characterReferenceMarkerNumeric"), u) : (e.enter("characterReferenceValue"), i = 31, a = br, d(p));
    }
    function u(p) {
      return p === 88 || p === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(p), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), i = 6, a = bDe, d) : (e.enter("characterReferenceValue"), i = 7, a = ZC, d(p));
    }
    function d(p) {
      if (p === 59 && o) {
        const m = e.exit("characterReferenceValue");
        return a === br && !wR(r.sliceSerialize(m)) ? n(p) : (e.enter("characterReferenceMarker"), e.consume(p), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
      }
      return a(p) && o++ < i ? (e.consume(p), d) : n(p);
    }
  }
  const d4 = {
    partial: !0,
    tokenize: DDe
  }, p4 = {
    concrete: !0,
    name: "codeFenced",
    tokenize: jDe
  };
  function jDe(e, t, n) {
    const r = this, o = {
      partial: !0,
      tokenize: k
    };
    let i = 0, a = 0, s;
    return c;
    function c(A) {
      return u(A);
    }
    function u(A) {
      const O = r.events[r.events.length - 1];
      return i = O && O[1].type === "linePrefix" ? O[2].sliceSerialize(O[1], !0).length : 0, s = A, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), d(A);
    }
    function d(A) {
      return A === s ? (a++, e.consume(A), d) : a < 3 ? n(A) : (e.exit("codeFencedFenceSequence"), _t(A) ? Pt(e, p, "whitespace")(A) : p(A));
    }
    function p(A) {
      return A === null || Ze(A) ? (e.exit("codeFencedFence"), r.interrupt ? t(A) : e.check(d4, b, C)(A)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
        contentType: "string"
      }), m(A));
    }
    function m(A) {
      return A === null || Ze(A) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), p(A)) : _t(A) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), Pt(e, g, "whitespace")(A)) : A === 96 && A === s ? n(A) : (e.consume(A), m);
    }
    function g(A) {
      return A === null || Ze(A) ? p(A) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
        contentType: "string"
      }), y(A));
    }
    function y(A) {
      return A === null || Ze(A) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), p(A)) : A === 96 && A === s ? n(A) : (e.consume(A), y);
    }
    function b(A) {
      return e.attempt(o, C, v)(A);
    }
    function v(A) {
      return e.enter("lineEnding"), e.consume(A), e.exit("lineEnding"), x;
    }
    function x(A) {
      return i > 0 && _t(A) ? Pt(e, E, "linePrefix", i + 1)(A) : E(A);
    }
    function E(A) {
      return A === null || Ze(A) ? e.check(d4, b, C)(A) : (e.enter("codeFlowValue"), _(A));
    }
    function _(A) {
      return A === null || Ze(A) ? (e.exit("codeFlowValue"), E(A)) : (e.consume(A), _);
    }
    function C(A) {
      return e.exit("codeFenced"), t(A);
    }
    function k(A, O, P) {
      let I = 0;
      return $;
      function $(V) {
        return A.enter("lineEnding"), A.consume(V), A.exit("lineEnding"), L;
      }
      function L(V) {
        return A.enter("codeFencedFence"), _t(V) ? Pt(A, N, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(V) : N(V);
      }
      function N(V) {
        return V === s ? (A.enter("codeFencedFenceSequence"), U(V)) : P(V);
      }
      function U(V) {
        return V === s ? (I++, A.consume(V), U) : I >= a ? (A.exit("codeFencedFenceSequence"), _t(V) ? Pt(A, j, "whitespace")(V) : j(V)) : P(V);
      }
      function j(V) {
        return V === null || Ze(V) ? (A.exit("codeFencedFence"), O(V)) : P(V);
      }
    }
  }
  function DDe(e, t, n) {
    const r = this;
    return o;
    function o(a) {
      return a === null ? n(a) : (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), i);
    }
    function i(a) {
      return r.parser.lazy[r.now().line] ? n(a) : t(a);
    }
  }
  const tE = {
    name: "codeIndented",
    tokenize: LDe
  }, FDe = {
    partial: !0,
    tokenize: zDe
  };
  function LDe(e, t, n) {
    const r = this;
    return o;
    function o(u) {
      return e.enter("codeIndented"), Pt(e, i, "linePrefix", 5)(u);
    }
    function i(u) {
      const d = r.events[r.events.length - 1];
      return d && d[1].type === "linePrefix" && d[2].sliceSerialize(d[1], !0).length >= 4 ? a(u) : n(u);
    }
    function a(u) {
      return u === null ? c(u) : Ze(u) ? e.attempt(FDe, a, c)(u) : (e.enter("codeFlowValue"), s(u));
    }
    function s(u) {
      return u === null || Ze(u) ? (e.exit("codeFlowValue"), a(u)) : (e.consume(u), s);
    }
    function c(u) {
      return e.exit("codeIndented"), t(u);
    }
  }
  function zDe(e, t, n) {
    const r = this;
    return o;
    function o(a) {
      return r.parser.lazy[r.now().line] ? n(a) : Ze(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), o) : Pt(e, i, "linePrefix", 5)(a);
    }
    function i(a) {
      const s = r.events[r.events.length - 1];
      return s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(a) : Ze(a) ? o(a) : n(a);
    }
  }
  const BDe = {
    name: "codeText",
    previous: VDe,
    resolve: UDe,
    tokenize: HDe
  };
  function UDe(e) {
    let t = e.length - 4, n = 3, r, o;
    if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
      for (r = n; ++r < t; )
        if (e[r][1].type === "codeTextData") {
          e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
          break;
        }
    }
    for (r = n - 1, t++; ++r <= t; )
      o === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (o = r) : (r === t || e[r][1].type === "lineEnding") && (e[o][1].type = "codeTextData", r !== o + 2 && (e[o][1].end = e[r - 1][1].end, e.splice(o + 2, r - o - 2), t -= r - o - 2, r = o + 2), o = void 0);
    return e;
  }
  function VDe(e) {
    return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
  }
  function HDe(e, t, n) {
    let r = 0, o, i;
    return a;
    function a(p) {
      return e.enter("codeText"), e.enter("codeTextSequence"), s(p);
    }
    function s(p) {
      return p === 96 ? (e.consume(p), r++, s) : (e.exit("codeTextSequence"), c(p));
    }
    function c(p) {
      return p === null ? n(p) : p === 32 ? (e.enter("space"), e.consume(p), e.exit("space"), c) : p === 96 ? (i = e.enter("codeTextSequence"), o = 0, d(p)) : Ze(p) ? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), c) : (e.enter("codeTextData"), u(p));
    }
    function u(p) {
      return p === null || p === 32 || p === 96 || Ze(p) ? (e.exit("codeTextData"), c(p)) : (e.consume(p), u);
    }
    function d(p) {
      return p === 96 ? (e.consume(p), o++, d) : o === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(p)) : (i.type = "codeTextData", u(p));
    }
  }
  class qDe {
    /**
     * @param {ReadonlyArray<T> | null | undefined} [initial]
     *   Initial items (optional).
     * @returns
     *   Splice buffer.
     */
    constructor(t) {
      this.left = t ? [...t] : [], this.right = [];
    }
    /**
     * Array access;
     * does not move the cursor.
     *
     * @param {number} index
     *   Index.
     * @return {T}
     *   Item.
     */
    get(t) {
      if (t < 0 || t >= this.left.length + this.right.length)
        throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
      return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
    }
    /**
     * The length of the splice buffer, one greater than the largest index in the
     * array.
     */
    get length() {
      return this.left.length + this.right.length;
    }
    /**
     * Remove and return `list[0]`;
     * moves the cursor to `0`.
     *
     * @returns {T | undefined}
     *   Item, optional.
     */
    shift() {
      return this.setCursor(0), this.right.pop();
    }
    /**
     * Slice the buffer to get an array;
     * does not move the cursor.
     *
     * @param {number} start
     *   Start.
     * @param {number | null | undefined} [end]
     *   End (optional).
     * @returns {Array<T>}
     *   Array of items.
     */
    slice(t, n) {
      const r = n ?? Number.POSITIVE_INFINITY;
      return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
    }
    /**
     * Mimics the behavior of Array.prototype.splice() except for the change of
     * interface necessary to avoid segfaults when patching in very large arrays.
     *
     * This operation moves cursor is moved to `start` and results in the cursor
     * placed after any inserted items.
     *
     * @param {number} start
     *   Start;
     *   zero-based index at which to start changing the array;
     *   negative numbers count backwards from the end of the array and values
     *   that are out-of bounds are clamped to the appropriate end of the array.
     * @param {number | null | undefined} [deleteCount=0]
     *   Delete count (default: `0`);
     *   maximum number of elements to delete, starting from start.
     * @param {Array<T> | null | undefined} [items=[]]
     *   Items to include in place of the deleted items (default: `[]`).
     * @return {Array<T>}
     *   Any removed items.
     */
    splice(t, n, r) {
      const o = n || 0;
      this.setCursor(Math.trunc(t));
      const i = this.right.splice(this.right.length - o, Number.POSITIVE_INFINITY);
      return r && up(this.left, r), i.reverse();
    }
    /**
     * Remove and return the highest-numbered item in the array, so
     * `list[list.length - 1]`;
     * Moves the cursor to `length`.
     *
     * @returns {T | undefined}
     *   Item, optional.
     */
    pop() {
      return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
    }
    /**
     * Inserts a single item to the high-numbered side of the array;
     * moves the cursor to `length`.
     *
     * @param {T} item
     *   Item.
     * @returns {undefined}
     *   Nothing.
     */
    push(t) {
      this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
    }
    /**
     * Inserts many items to the high-numbered side of the array.
     * Moves the cursor to `length`.
     *
     * @param {Array<T>} items
     *   Items.
     * @returns {undefined}
     *   Nothing.
     */
    pushMany(t) {
      this.setCursor(Number.POSITIVE_INFINITY), up(this.left, t);
    }
    /**
     * Inserts a single item to the low-numbered side of the array;
     * Moves the cursor to `0`.
     *
     * @param {T} item
     *   Item.
     * @returns {undefined}
     *   Nothing.
     */
    unshift(t) {
      this.setCursor(0), this.right.push(t);
    }
    /**
     * Inserts many items to the low-numbered side of the array;
     * moves the cursor to `0`.
     *
     * @param {Array<T>} items
     *   Items.
     * @returns {undefined}
     *   Nothing.
     */
    unshiftMany(t) {
      this.setCursor(0), up(this.right, t.reverse());
    }
    /**
     * Move the cursor to a specific position in the array. Requires
     * time proportional to the distance moved.
     *
     * If `n < 0`, the cursor will end up at the beginning.
     * If `n > length`, the cursor will end up at the end.
     *
     * @param {number} n
     *   Position.
     * @return {undefined}
     *   Nothing.
     */
    setCursor(t) {
      if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
        if (t < this.left.length) {
          const n = this.left.splice(t, Number.POSITIVE_INFINITY);
          up(this.right, n.reverse());
        } else {
          const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
          up(this.left, n.reverse());
        }
    }
  }
  function up(e, t) {
    let n = 0;
    if (t.length < 1e4)
      e.push(...t);
    else
      for (; n < t.length; )
        e.push(...t.slice(n, n + 1e4)), n += 1e4;
  }
  function K7(e) {
    const t = {};
    let n = -1, r, o, i, a, s, c, u;
    const d = new qDe(e);
    for (; ++n < d.length; ) {
      for (; n in t; )
        n = t[n];
      if (r = d.get(n), n && r[1].type === "chunkFlow" && d.get(n - 1)[1].type === "listItemPrefix" && (c = r[1]._tokenizer.events, i = 0, i < c.length && c[i][1].type === "lineEndingBlank" && (i += 2), i < c.length && c[i][1].type === "content"))
        for (; ++i < c.length && c[i][1].type !== "content"; )
          c[i][1].type === "chunkText" && (c[i][1]._isInFirstContentOfListItem = !0, i++);
      if (r[0] === "enter")
        r[1].contentType && (Object.assign(t, WDe(d, n)), n = t[n], u = !0);
      else if (r[1]._container) {
        for (i = n, o = void 0; i--; )
          if (a = d.get(i), a[1].type === "lineEnding" || a[1].type === "lineEndingBlank")
            a[0] === "enter" && (o && (d.get(o)[1].type = "lineEndingBlank"), a[1].type = "lineEnding", o = i);
          else if (!(a[1].type === "linePrefix" || a[1].type === "listItemIndent")) break;
        o && (r[1].end = {
          ...d.get(o)[1].start
        }, s = d.slice(o, n), s.unshift(r), d.splice(o, n - o + 1, s));
      }
    }
    return uo(e, 0, Number.POSITIVE_INFINITY, d.slice(0)), !u;
  }
  function WDe(e, t) {
    const n = e.get(t)[1], r = e.get(t)[2];
    let o = t - 1;
    const i = [];
    let a = n._tokenizer;
    a || (a = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (a._contentTypeTextTrailing = !0));
    const s = a.events, c = [], u = {};
    let d, p, m = -1, g = n, y = 0, b = 0;
    const v = [b];
    for (; g; ) {
      for (; e.get(++o)[1] !== g; )
        ;
      i.push(o), g._tokenizer || (d = r.sliceStream(g), g.next || d.push(null), p && a.defineSkip(g.start), g._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = !0), a.write(d), g._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = void 0)), p = g, g = g.next;
    }
    for (g = n; ++m < s.length; )
      // Find a void token that includes a break.
      s[m][0] === "exit" && s[m - 1][0] === "enter" && s[m][1].type === s[m - 1][1].type && s[m][1].start.line !== s[m][1].end.line && (b = m + 1, v.push(b), g._tokenizer = void 0, g.previous = void 0, g = g.next);
    for (a.events = [], g ? (g._tokenizer = void 0, g.previous = void 0) : v.pop(), m = v.length; m--; ) {
      const x = s.slice(v[m], v[m + 1]), E = i.pop();
      c.push([E, E + x.length - 1]), e.splice(E, 2, x);
    }
    for (c.reverse(), m = -1; ++m < c.length; )
      u[y + c[m][0]] = y + c[m][1], y += c[m][1] - c[m][0] - 1;
    return u;
  }
  const GDe = {
    resolve: YDe,
    tokenize: XDe
  }, KDe = {
    partial: !0,
    tokenize: ZDe
  };
  function YDe(e) {
    return K7(e), e;
  }
  function XDe(e, t) {
    let n;
    return r;
    function r(s) {
      return e.enter("content"), n = e.enter("chunkContent", {
        contentType: "content"
      }), o(s);
    }
    function o(s) {
      return s === null ? i(s) : Ze(s) ? e.check(KDe, a, i)(s) : (e.consume(s), o);
    }
    function i(s) {
      return e.exit("chunkContent"), e.exit("content"), t(s);
    }
    function a(s) {
      return e.consume(s), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
        contentType: "content",
        previous: n
      }), n = n.next, o;
    }
  }
  function ZDe(e, t, n) {
    const r = this;
    return o;
    function o(a) {
      return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), Pt(e, i, "linePrefix");
    }
    function i(a) {
      if (a === null || Ze(a))
        return n(a);
      const s = r.events[r.events.length - 1];
      return !r.parser.constructs.disable.null.includes("codeIndented") && s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(a) : e.interrupt(r.parser.constructs.flow, n, t)(a);
    }
  }
  function Y7(e, t, n, r, o, i, a, s, c) {
    const u = c || Number.POSITIVE_INFINITY;
    let d = 0;
    return p;
    function p(x) {
      return x === 60 ? (e.enter(r), e.enter(o), e.enter(i), e.consume(x), e.exit(i), m) : x === null || x === 32 || x === 41 || G0(x) ? n(x) : (e.enter(r), e.enter(a), e.enter(s), e.enter("chunkString", {
        contentType: "string"
      }), b(x));
    }
    function m(x) {
      return x === 62 ? (e.enter(i), e.consume(x), e.exit(i), e.exit(o), e.exit(r), t) : (e.enter(s), e.enter("chunkString", {
        contentType: "string"
      }), g(x));
    }
    function g(x) {
      return x === 62 ? (e.exit("chunkString"), e.exit(s), m(x)) : x === null || x === 60 || Ze(x) ? n(x) : (e.consume(x), x === 92 ? y : g);
    }
    function y(x) {
      return x === 60 || x === 62 || x === 92 ? (e.consume(x), g) : g(x);
    }
    function b(x) {
      return !d && (x === null || x === 41 || cn(x)) ? (e.exit("chunkString"), e.exit(s), e.exit(a), e.exit(r), t(x)) : d < u && x === 40 ? (e.consume(x), d++, b) : x === 41 ? (e.consume(x), d--, b) : x === null || x === 32 || x === 40 || G0(x) ? n(x) : (e.consume(x), x === 92 ? v : b);
    }
    function v(x) {
      return x === 40 || x === 41 || x === 92 ? (e.consume(x), b) : b(x);
    }
  }
  function X7(e, t, n, r, o, i) {
    const a = this;
    let s = 0, c;
    return u;
    function u(g) {
      return e.enter(r), e.enter(o), e.consume(g), e.exit(o), e.enter(i), d;
    }
    function d(g) {
      return s > 999 || g === null || g === 91 || g === 93 && !c || // To do: remove in the future once weve switched from
      // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
      // which doesnt need this.
      // Hidden footnotes hook.
      /* c8 ignore next 3 */
      g === 94 && !s && "_hiddenFootnoteSupport" in a.parser.constructs ? n(g) : g === 93 ? (e.exit(i), e.enter(o), e.consume(g), e.exit(o), e.exit(r), t) : Ze(g) ? (e.enter("lineEnding"), e.consume(g), e.exit("lineEnding"), d) : (e.enter("chunkString", {
        contentType: "string"
      }), p(g));
    }
    function p(g) {
      return g === null || g === 91 || g === 93 || Ze(g) || s++ > 999 ? (e.exit("chunkString"), d(g)) : (e.consume(g), c || (c = !_t(g)), g === 92 ? m : p);
    }
    function m(g) {
      return g === 91 || g === 92 || g === 93 ? (e.consume(g), s++, p) : p(g);
    }
  }
  function Z7(e, t, n, r, o, i) {
    let a;
    return s;
    function s(m) {
      return m === 34 || m === 39 || m === 40 ? (e.enter(r), e.enter(o), e.consume(m), e.exit(o), a = m === 40 ? 41 : m, c) : n(m);
    }
    function c(m) {
      return m === a ? (e.enter(o), e.consume(m), e.exit(o), e.exit(r), t) : (e.enter(i), u(m));
    }
    function u(m) {
      return m === a ? (e.exit(i), c(a)) : m === null ? n(m) : Ze(m) ? (e.enter("lineEnding"), e.consume(m), e.exit("lineEnding"), Pt(e, u, "linePrefix")) : (e.enter("chunkString", {
        contentType: "string"
      }), d(m));
    }
    function d(m) {
      return m === a || m === null || Ze(m) ? (e.exit("chunkString"), u(m)) : (e.consume(m), m === 92 ? p : d);
    }
    function p(m) {
      return m === a || m === 92 ? (e.consume(m), d) : d(m);
    }
  }
  function Hp(e, t) {
    let n;
    return r;
    function r(o) {
      return Ze(o) ? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), n = !0, r) : _t(o) ? Pt(e, r, n ? "linePrefix" : "lineSuffix")(o) : t(o);
    }
  }
  const QDe = {
    name: "definition",
    tokenize: e5e
  }, JDe = {
    partial: !0,
    tokenize: t5e
  };
  function e5e(e, t, n) {
    const r = this;
    let o;
    return i;
    function i(g) {
      return e.enter("definition"), a(g);
    }
    function a(g) {
      return X7.call(
        r,
        e,
        s,
        // Note: we dont need to reset the way `markdown-rs` does.
        n,
        "definitionLabel",
        "definitionLabelMarker",
        "definitionLabelString"
      )(g);
    }
    function s(g) {
      return o = Jo(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), g === 58 ? (e.enter("definitionMarker"), e.consume(g), e.exit("definitionMarker"), c) : n(g);
    }
    function c(g) {
      return cn(g) ? Hp(e, u)(g) : u(g);
    }
    function u(g) {
      return Y7(
        e,
        d,
        // Note: we dont need to reset the way `markdown-rs` does.
        n,
        "definitionDestination",
        "definitionDestinationLiteral",
        "definitionDestinationLiteralMarker",
        "definitionDestinationRaw",
        "definitionDestinationString"
      )(g);
    }
    function d(g) {
      return e.attempt(JDe, p, p)(g);
    }
    function p(g) {
      return _t(g) ? Pt(e, m, "whitespace")(g) : m(g);
    }
    function m(g) {
      return g === null || Ze(g) ? (e.exit("definition"), r.parser.defined.push(o), t(g)) : n(g);
    }
  }
  function t5e(e, t, n) {
    return r;
    function r(s) {
      return cn(s) ? Hp(e, o)(s) : n(s);
    }
    function o(s) {
      return Z7(e, i, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(s);
    }
    function i(s) {
      return _t(s) ? Pt(e, a, "whitespace")(s) : a(s);
    }
    function a(s) {
      return s === null || Ze(s) ? t(s) : n(s);
    }
  }
  const n5e = {
    name: "hardBreakEscape",
    tokenize: r5e
  };
  function r5e(e, t, n) {
    return r;
    function r(i) {
      return e.enter("hardBreakEscape"), e.consume(i), o;
    }
    function o(i) {
      return Ze(i) ? (e.exit("hardBreakEscape"), t(i)) : n(i);
    }
  }
  const o5e = {
    name: "headingAtx",
    resolve: i5e,
    tokenize: a5e
  };
  function i5e(e, t) {
    let n = e.length - 2, r = 3, o, i;
    return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (o = {
      type: "atxHeadingText",
      start: e[r][1].start,
      end: e[n][1].end
    }, i = {
      type: "chunkText",
      start: e[r][1].start,
      end: e[n][1].end,
      contentType: "text"
    }, uo(e, r, n - r + 1, [["enter", o, t], ["enter", i, t], ["exit", i, t], ["exit", o, t]])), e;
  }
  function a5e(e, t, n) {
    let r = 0;
    return o;
    function o(d) {
      return e.enter("atxHeading"), i(d);
    }
    function i(d) {
      return e.enter("atxHeadingSequence"), a(d);
    }
    function a(d) {
      return d === 35 && r++ < 6 ? (e.consume(d), a) : d === null || cn(d) ? (e.exit("atxHeadingSequence"), s(d)) : n(d);
    }
    function s(d) {
      return d === 35 ? (e.enter("atxHeadingSequence"), c(d)) : d === null || Ze(d) ? (e.exit("atxHeading"), t(d)) : _t(d) ? Pt(e, s, "whitespace")(d) : (e.enter("atxHeadingText"), u(d));
    }
    function c(d) {
      return d === 35 ? (e.consume(d), c) : (e.exit("atxHeadingSequence"), s(d));
    }
    function u(d) {
      return d === null || d === 35 || cn(d) ? (e.exit("atxHeadingText"), s(d)) : (e.consume(d), u);
    }
  }
  const s5e = [
    "address",
    "article",
    "aside",
    "base",
    "basefont",
    "blockquote",
    "body",
    "caption",
    "center",
    "col",
    "colgroup",
    "dd",
    "details",
    "dialog",
    "dir",
    "div",
    "dl",
    "dt",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "frame",
    "frameset",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hr",
    "html",
    "iframe",
    "legend",
    "li",
    "link",
    "main",
    "menu",
    "menuitem",
    "nav",
    "noframes",
    "ol",
    "optgroup",
    "option",
    "p",
    "param",
    "search",
    "section",
    "summary",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "title",
    "tr",
    "track",
    "ul"
  ], h4 = ["pre", "script", "style", "textarea"], l5e = {
    concrete: !0,
    name: "htmlFlow",
    resolveTo: f5e,
    tokenize: d5e
  }, c5e = {
    partial: !0,
    tokenize: h5e
  }, u5e = {
    partial: !0,
    tokenize: p5e
  };
  function f5e(e) {
    let t = e.length;
    for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
      ;
    return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
  }
  function d5e(e, t, n) {
    const r = this;
    let o, i, a, s, c;
    return u;
    function u(z) {
      return d(z);
    }
    function d(z) {
      return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(z), p;
    }
    function p(z) {
      return z === 33 ? (e.consume(z), m) : z === 47 ? (e.consume(z), i = !0, b) : z === 63 ? (e.consume(z), o = 3, r.interrupt ? t : B) : Tr(z) ? (e.consume(z), a = String.fromCharCode(z), v) : n(z);
    }
    function m(z) {
      return z === 45 ? (e.consume(z), o = 2, g) : z === 91 ? (e.consume(z), o = 5, s = 0, y) : Tr(z) ? (e.consume(z), o = 4, r.interrupt ? t : B) : n(z);
    }
    function g(z) {
      return z === 45 ? (e.consume(z), r.interrupt ? t : B) : n(z);
    }
    function y(z) {
      const H = "CDATA[";
      return z === H.charCodeAt(s++) ? (e.consume(z), s === H.length ? r.interrupt ? t : N : y) : n(z);
    }
    function b(z) {
      return Tr(z) ? (e.consume(z), a = String.fromCharCode(z), v) : n(z);
    }
    function v(z) {
      if (z === null || z === 47 || z === 62 || cn(z)) {
        const H = z === 47, X = a.toLowerCase();
        return !H && !i && h4.includes(X) ? (o = 1, r.interrupt ? t(z) : N(z)) : s5e.includes(a.toLowerCase()) ? (o = 6, H ? (e.consume(z), x) : r.interrupt ? t(z) : N(z)) : (o = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(z) : i ? E(z) : _(z));
      }
      return z === 45 || br(z) ? (e.consume(z), a += String.fromCharCode(z), v) : n(z);
    }
    function x(z) {
      return z === 62 ? (e.consume(z), r.interrupt ? t : N) : n(z);
    }
    function E(z) {
      return _t(z) ? (e.consume(z), E) : $(z);
    }
    function _(z) {
      return z === 47 ? (e.consume(z), $) : z === 58 || z === 95 || Tr(z) ? (e.consume(z), C) : _t(z) ? (e.consume(z), _) : $(z);
    }
    function C(z) {
      return z === 45 || z === 46 || z === 58 || z === 95 || br(z) ? (e.consume(z), C) : k(z);
    }
    function k(z) {
      return z === 61 ? (e.consume(z), A) : _t(z) ? (e.consume(z), k) : _(z);
    }
    function A(z) {
      return z === null || z === 60 || z === 61 || z === 62 || z === 96 ? n(z) : z === 34 || z === 39 ? (e.consume(z), c = z, O) : _t(z) ? (e.consume(z), A) : P(z);
    }
    function O(z) {
      return z === c ? (e.consume(z), c = null, I) : z === null || Ze(z) ? n(z) : (e.consume(z), O);
    }
    function P(z) {
      return z === null || z === 34 || z === 39 || z === 47 || z === 60 || z === 61 || z === 62 || z === 96 || cn(z) ? k(z) : (e.consume(z), P);
    }
    function I(z) {
      return z === 47 || z === 62 || _t(z) ? _(z) : n(z);
    }
    function $(z) {
      return z === 62 ? (e.consume(z), L) : n(z);
    }
    function L(z) {
      return z === null || Ze(z) ? N(z) : _t(z) ? (e.consume(z), L) : n(z);
    }
    function N(z) {
      return z === 45 && o === 2 ? (e.consume(z), F) : z === 60 && o === 1 ? (e.consume(z), K) : z === 62 && o === 4 ? (e.consume(z), D) : z === 63 && o === 3 ? (e.consume(z), B) : z === 93 && o === 5 ? (e.consume(z), Y) : Ze(z) && (o === 6 || o === 7) ? (e.exit("htmlFlowData"), e.check(c5e, G, U)(z)) : z === null || Ze(z) ? (e.exit("htmlFlowData"), U(z)) : (e.consume(z), N);
    }
    function U(z) {
      return e.check(u5e, j, G)(z);
    }
    function j(z) {
      return e.enter("lineEnding"), e.consume(z), e.exit("lineEnding"), V;
    }
    function V(z) {
      return z === null || Ze(z) ? U(z) : (e.enter("htmlFlowData"), N(z));
    }
    function F(z) {
      return z === 45 ? (e.consume(z), B) : N(z);
    }
    function K(z) {
      return z === 47 ? (e.consume(z), a = "", W) : N(z);
    }
    function W(z) {
      if (z === 62) {
        const H = a.toLowerCase();
        return h4.includes(H) ? (e.consume(z), D) : N(z);
      }
      return Tr(z) && a.length < 8 ? (e.consume(z), a += String.fromCharCode(z), W) : N(z);
    }
    function Y(z) {
      return z === 93 ? (e.consume(z), B) : N(z);
    }
    function B(z) {
      return z === 62 ? (e.consume(z), D) : z === 45 && o === 2 ? (e.consume(z), B) : N(z);
    }
    function D(z) {
      return z === null || Ze(z) ? (e.exit("htmlFlowData"), G(z)) : (e.consume(z), D);
    }
    function G(z) {
      return e.exit("htmlFlow"), t(z);
    }
  }
  function p5e(e, t, n) {
    const r = this;
    return o;
    function o(a) {
      return Ze(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), i) : n(a);
    }
    function i(a) {
      return r.parser.lazy[r.now().line] ? n(a) : t(a);
    }
  }
  function h5e(e, t, n) {
    return r;
    function r(o) {
      return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), e.attempt(Sm, t, n);
    }
  }
  const m5e = {
    name: "htmlText",
    tokenize: g5e
  };
  function g5e(e, t, n) {
    const r = this;
    let o, i, a;
    return s;
    function s(B) {
      return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(B), c;
    }
    function c(B) {
      return B === 33 ? (e.consume(B), u) : B === 47 ? (e.consume(B), k) : B === 63 ? (e.consume(B), _) : Tr(B) ? (e.consume(B), P) : n(B);
    }
    function u(B) {
      return B === 45 ? (e.consume(B), d) : B === 91 ? (e.consume(B), i = 0, y) : Tr(B) ? (e.consume(B), E) : n(B);
    }
    function d(B) {
      return B === 45 ? (e.consume(B), g) : n(B);
    }
    function p(B) {
      return B === null ? n(B) : B === 45 ? (e.consume(B), m) : Ze(B) ? (a = p, K(B)) : (e.consume(B), p);
    }
    function m(B) {
      return B === 45 ? (e.consume(B), g) : p(B);
    }
    function g(B) {
      return B === 62 ? F(B) : B === 45 ? m(B) : p(B);
    }
    function y(B) {
      const D = "CDATA[";
      return B === D.charCodeAt(i++) ? (e.consume(B), i === D.length ? b : y) : n(B);
    }
    function b(B) {
      return B === null ? n(B) : B === 93 ? (e.consume(B), v) : Ze(B) ? (a = b, K(B)) : (e.consume(B), b);
    }
    function v(B) {
      return B === 93 ? (e.consume(B), x) : b(B);
    }
    function x(B) {
      return B === 62 ? F(B) : B === 93 ? (e.consume(B), x) : b(B);
    }
    function E(B) {
      return B === null || B === 62 ? F(B) : Ze(B) ? (a = E, K(B)) : (e.consume(B), E);
    }
    function _(B) {
      return B === null ? n(B) : B === 63 ? (e.consume(B), C) : Ze(B) ? (a = _, K(B)) : (e.consume(B), _);
    }
    function C(B) {
      return B === 62 ? F(B) : _(B);
    }
    function k(B) {
      return Tr(B) ? (e.consume(B), A) : n(B);
    }
    function A(B) {
      return B === 45 || br(B) ? (e.consume(B), A) : O(B);
    }
    function O(B) {
      return Ze(B) ? (a = O, K(B)) : _t(B) ? (e.consume(B), O) : F(B);
    }
    function P(B) {
      return B === 45 || br(B) ? (e.consume(B), P) : B === 47 || B === 62 || cn(B) ? I(B) : n(B);
    }
    function I(B) {
      return B === 47 ? (e.consume(B), F) : B === 58 || B === 95 || Tr(B) ? (e.consume(B), $) : Ze(B) ? (a = I, K(B)) : _t(B) ? (e.consume(B), I) : F(B);
    }
    function $(B) {
      return B === 45 || B === 46 || B === 58 || B === 95 || br(B) ? (e.consume(B), $) : L(B);
    }
    function L(B) {
      return B === 61 ? (e.consume(B), N) : Ze(B) ? (a = L, K(B)) : _t(B) ? (e.consume(B), L) : I(B);
    }
    function N(B) {
      return B === null || B === 60 || B === 61 || B === 62 || B === 96 ? n(B) : B === 34 || B === 39 ? (e.consume(B), o = B, U) : Ze(B) ? (a = N, K(B)) : _t(B) ? (e.consume(B), N) : (e.consume(B), j);
    }
    function U(B) {
      return B === o ? (e.consume(B), o = void 0, V) : B === null ? n(B) : Ze(B) ? (a = U, K(B)) : (e.consume(B), U);
    }
    function j(B) {
      return B === null || B === 34 || B === 39 || B === 60 || B === 61 || B === 96 ? n(B) : B === 47 || B === 62 || cn(B) ? I(B) : (e.consume(B), j);
    }
    function V(B) {
      return B === 47 || B === 62 || cn(B) ? I(B) : n(B);
    }
    function F(B) {
      return B === 62 ? (e.consume(B), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(B);
    }
    function K(B) {
      return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(B), e.exit("lineEnding"), W;
    }
    function W(B) {
      return _t(B) ? Pt(e, Y, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(B) : Y(B);
    }
    function Y(B) {
      return e.enter("htmlTextData"), a(B);
    }
  }
  const SR = {
    name: "labelEnd",
    resolveAll: x5e,
    resolveTo: w5e,
    tokenize: S5e
  }, y5e = {
    tokenize: _5e
  }, v5e = {
    tokenize: E5e
  }, b5e = {
    tokenize: C5e
  };
  function x5e(e) {
    let t = -1;
    const n = [];
    for (; ++t < e.length; ) {
      const r = e[t][1];
      if (n.push(e[t]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") {
        const o = r.type === "labelImage" ? 4 : 2;
        r.type = "data", t += o;
      }
    }
    return e.length !== n.length && uo(e, 0, e.length, n), e;
  }
  function w5e(e, t) {
    let n = e.length, r = 0, o, i, a, s;
    for (; n--; )
      if (o = e[n][1], i) {
        if (o.type === "link" || o.type === "labelLink" && o._inactive)
          break;
        e[n][0] === "enter" && o.type === "labelLink" && (o._inactive = !0);
      } else if (a) {
        if (e[n][0] === "enter" && (o.type === "labelImage" || o.type === "labelLink") && !o._balanced && (i = n, o.type !== "labelLink")) {
          r = 2;
          break;
        }
      } else o.type === "labelEnd" && (a = n);
    const c = {
      type: e[i][1].type === "labelLink" ? "link" : "image",
      start: {
        ...e[i][1].start
      },
      end: {
        ...e[e.length - 1][1].end
      }
    }, u = {
      type: "label",
      start: {
        ...e[i][1].start
      },
      end: {
        ...e[a][1].end
      }
    }, d = {
      type: "labelText",
      start: {
        ...e[i + r + 2][1].end
      },
      end: {
        ...e[a - 2][1].start
      }
    };
    return s = [["enter", c, t], ["enter", u, t]], s = Oo(s, e.slice(i + 1, i + r + 3)), s = Oo(s, [["enter", d, t]]), s = Oo(s, L1(t.parser.constructs.insideSpan.null, e.slice(i + r + 4, a - 3), t)), s = Oo(s, [["exit", d, t], e[a - 2], e[a - 1], ["exit", u, t]]), s = Oo(s, e.slice(a + 1)), s = Oo(s, [["exit", c, t]]), uo(e, i, e.length, s), e;
  }
  function S5e(e, t, n) {
    const r = this;
    let o = r.events.length, i, a;
    for (; o--; )
      if ((r.events[o][1].type === "labelImage" || r.events[o][1].type === "labelLink") && !r.events[o][1]._balanced) {
        i = r.events[o][1];
        break;
      }
    return s;
    function s(m) {
      return i ? i._inactive ? p(m) : (a = r.parser.defined.includes(Jo(r.sliceSerialize({
        start: i.end,
        end: r.now()
      }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(m), e.exit("labelMarker"), e.exit("labelEnd"), c) : n(m);
    }
    function c(m) {
      return m === 40 ? e.attempt(y5e, d, a ? d : p)(m) : m === 91 ? e.attempt(v5e, d, a ? u : p)(m) : a ? d(m) : p(m);
    }
    function u(m) {
      return e.attempt(b5e, d, p)(m);
    }
    function d(m) {
      return t(m);
    }
    function p(m) {
      return i._balanced = !0, n(m);
    }
  }
  function _5e(e, t, n) {
    return r;
    function r(p) {
      return e.enter("resource"), e.enter("resourceMarker"), e.consume(p), e.exit("resourceMarker"), o;
    }
    function o(p) {
      return cn(p) ? Hp(e, i)(p) : i(p);
    }
    function i(p) {
      return p === 41 ? d(p) : Y7(e, a, s, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(p);
    }
    function a(p) {
      return cn(p) ? Hp(e, c)(p) : d(p);
    }
    function s(p) {
      return n(p);
    }
    function c(p) {
      return p === 34 || p === 39 || p === 40 ? Z7(e, u, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(p) : d(p);
    }
    function u(p) {
      return cn(p) ? Hp(e, d)(p) : d(p);
    }
    function d(p) {
      return p === 41 ? (e.enter("resourceMarker"), e.consume(p), e.exit("resourceMarker"), e.exit("resource"), t) : n(p);
    }
  }
  function E5e(e, t, n) {
    const r = this;
    return o;
    function o(s) {
      return X7.call(r, e, i, a, "reference", "referenceMarker", "referenceString")(s);
    }
    function i(s) {
      return r.parser.defined.includes(Jo(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(s) : n(s);
    }
    function a(s) {
      return n(s);
    }
  }
  function C5e(e, t, n) {
    return r;
    function r(i) {
      return e.enter("reference"), e.enter("referenceMarker"), e.consume(i), e.exit("referenceMarker"), o;
    }
    function o(i) {
      return i === 93 ? (e.enter("referenceMarker"), e.consume(i), e.exit("referenceMarker"), e.exit("reference"), t) : n(i);
    }
  }
  const k5e = {
    name: "labelStartImage",
    resolveAll: SR.resolveAll,
    tokenize: T5e
  };
  function T5e(e, t, n) {
    const r = this;
    return o;
    function o(s) {
      return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(s), e.exit("labelImageMarker"), i;
    }
    function i(s) {
      return s === 91 ? (e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelImage"), a) : n(s);
    }
    function a(s) {
      return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s);
    }
  }
  const A5e = {
    name: "labelStartLink",
    resolveAll: SR.resolveAll,
    tokenize: R5e
  };
  function R5e(e, t, n) {
    const r = this;
    return o;
    function o(a) {
      return e.enter("labelLink"), e.enter("labelMarker"), e.consume(a), e.exit("labelMarker"), e.exit("labelLink"), i;
    }
    function i(a) {
      return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(a) : t(a);
    }
  }
  const nE = {
    name: "lineEnding",
    tokenize: O5e
  };
  function O5e(e, t) {
    return n;
    function n(r) {
      return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), Pt(e, t, "linePrefix");
    }
  }
  const Xv = {
    name: "thematicBreak",
    tokenize: M5e
  };
  function M5e(e, t, n) {
    let r = 0, o;
    return i;
    function i(u) {
      return e.enter("thematicBreak"), a(u);
    }
    function a(u) {
      return o = u, s(u);
    }
    function s(u) {
      return u === o ? (e.enter("thematicBreakSequence"), c(u)) : r >= 3 && (u === null || Ze(u)) ? (e.exit("thematicBreak"), t(u)) : n(u);
    }
    function c(u) {
      return u === o ? (e.consume(u), r++, c) : (e.exit("thematicBreakSequence"), _t(u) ? Pt(e, s, "whitespace")(u) : s(u));
    }
  }
  const Lr = {
    continuation: {
      tokenize: $5e
    },
    exit: D5e,
    name: "list",
    tokenize: I5e
  }, N5e = {
    partial: !0,
    tokenize: F5e
  }, P5e = {
    partial: !0,
    tokenize: j5e
  };
  function I5e(e, t, n) {
    const r = this, o = r.events[r.events.length - 1];
    let i = o && o[1].type === "linePrefix" ? o[2].sliceSerialize(o[1], !0).length : 0, a = 0;
    return s;
    function s(g) {
      const y = r.containerState.type || (g === 42 || g === 43 || g === 45 ? "listUnordered" : "listOrdered");
      if (y === "listUnordered" ? !r.containerState.marker || g === r.containerState.marker : ZC(g)) {
        if (r.containerState.type || (r.containerState.type = y, e.enter(y, {
          _container: !0
        })), y === "listUnordered")
          return e.enter("listItemPrefix"), g === 42 || g === 45 ? e.check(Xv, n, u)(g) : u(g);
        if (!r.interrupt || g === 49)
          return e.enter("listItemPrefix"), e.enter("listItemValue"), c(g);
      }
      return n(g);
    }
    function c(g) {
      return ZC(g) && ++a < 10 ? (e.consume(g), c) : (!r.interrupt || a < 2) && (r.containerState.marker ? g === r.containerState.marker : g === 41 || g === 46) ? (e.exit("listItemValue"), u(g)) : n(g);
    }
    function u(g) {
      return e.enter("listItemMarker"), e.consume(g), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || g, e.check(
        Sm,
        // Cant be empty when interrupting.
        r.interrupt ? n : d,
        e.attempt(N5e, m, p)
      );
    }
    function d(g) {
      return r.containerState.initialBlankLine = !0, i++, m(g);
    }
    function p(g) {
      return _t(g) ? (e.enter("listItemPrefixWhitespace"), e.consume(g), e.exit("listItemPrefixWhitespace"), m) : n(g);
    }
    function m(g) {
      return r.containerState.size = i + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(g);
    }
  }
  function $5e(e, t, n) {
    const r = this;
    return r.containerState._closeFlow = void 0, e.check(Sm, o, i);
    function o(s) {
      return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, Pt(e, t, "listItemIndent", r.containerState.size + 1)(s);
    }
    function i(s) {
      return r.containerState.furtherBlankLines || !_t(s) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, a(s)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(P5e, t, a)(s));
    }
    function a(s) {
      return r.containerState._closeFlow = !0, r.interrupt = void 0, Pt(e, e.attempt(Lr, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s);
    }
  }
  function j5e(e, t, n) {
    const r = this;
    return Pt(e, o, "listItemIndent", r.containerState.size + 1);
    function o(i) {
      const a = r.events[r.events.length - 1];
      return a && a[1].type === "listItemIndent" && a[2].sliceSerialize(a[1], !0).length === r.containerState.size ? t(i) : n(i);
    }
  }
  function D5e(e) {
    e.exit(this.containerState.type);
  }
  function F5e(e, t, n) {
    const r = this;
    return Pt(e, o, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
    function o(i) {
      const a = r.events[r.events.length - 1];
      return !_t(i) && a && a[1].type === "listItemPrefixWhitespace" ? t(i) : n(i);
    }
  }
  const m4 = {
    name: "setextUnderline",
    resolveTo: L5e,
    tokenize: z5e
  };
  function L5e(e, t) {
    let n = e.length, r, o, i;
    for (; n--; )
      if (e[n][0] === "enter") {
        if (e[n][1].type === "content") {
          r = n;
          break;
        }
        e[n][1].type === "paragraph" && (o = n);
      } else
        e[n][1].type === "content" && e.splice(n, 1), !i && e[n][1].type === "definition" && (i = n);
    const a = {
      type: "setextHeading",
      start: {
        ...e[r][1].start
      },
      end: {
        ...e[e.length - 1][1].end
      }
    };
    return e[o][1].type = "setextHeadingText", i ? (e.splice(o, 0, ["enter", a, t]), e.splice(i + 1, 0, ["exit", e[r][1], t]), e[r][1].end = {
      ...e[i][1].end
    }) : e[r][1] = a, e.push(["exit", a, t]), e;
  }
  function z5e(e, t, n) {
    const r = this;
    let o;
    return i;
    function i(u) {
      let d = r.events.length, p;
      for (; d--; )
        if (r.events[d][1].type !== "lineEnding" && r.events[d][1].type !== "linePrefix" && r.events[d][1].type !== "content") {
          p = r.events[d][1].type === "paragraph";
          break;
        }
      return !r.parser.lazy[r.now().line] && (r.interrupt || p) ? (e.enter("setextHeadingLine"), o = u, a(u)) : n(u);
    }
    function a(u) {
      return e.enter("setextHeadingLineSequence"), s(u);
    }
    function s(u) {
      return u === o ? (e.consume(u), s) : (e.exit("setextHeadingLineSequence"), _t(u) ? Pt(e, c, "lineSuffix")(u) : c(u));
    }
    function c(u) {
      return u === null || Ze(u) ? (e.exit("setextHeadingLine"), t(u)) : n(u);
    }
  }
  const B5e = {
    tokenize: U5e
  };
  function U5e(e) {
    const t = this, n = e.attempt(
      // Try to parse a blank line.
      Sm,
      r,
      // Try to parse initial flow (essentially, only code).
      e.attempt(this.parser.constructs.flowInitial, o, Pt(e, e.attempt(this.parser.constructs.flow, o, e.attempt(GDe, o)), "linePrefix"))
    );
    return n;
    function r(i) {
      if (i === null) {
        e.consume(i);
        return;
      }
      return e.enter("lineEndingBlank"), e.consume(i), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
    }
    function o(i) {
      if (i === null) {
        e.consume(i);
        return;
      }
      return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), t.currentConstruct = void 0, n;
    }
  }
  const V5e = {
    resolveAll: J7()
  }, H5e = Q7("string"), q5e = Q7("text");
  function Q7(e) {
    return {
      resolveAll: J7(e === "text" ? W5e : void 0),
      tokenize: t
    };
    function t(n) {
      const r = this, o = this.parser.constructs[e], i = n.attempt(o, a, s);
      return a;
      function a(d) {
        return u(d) ? i(d) : s(d);
      }
      function s(d) {
        if (d === null) {
          n.consume(d);
          return;
        }
        return n.enter("data"), n.consume(d), c;
      }
      function c(d) {
        return u(d) ? (n.exit("data"), i(d)) : (n.consume(d), c);
      }
      function u(d) {
        if (d === null)
          return !0;
        const p = o[d];
        let m = -1;
        if (p)
          for (; ++m < p.length; ) {
            const g = p[m];
            if (!g.previous || g.previous.call(r, r.previous))
              return !0;
          }
        return !1;
      }
    }
  }
  function J7(e) {
    return t;
    function t(n, r) {
      let o = -1, i;
      for (; ++o <= n.length; )
        i === void 0 ? n[o] && n[o][1].type === "data" && (i = o, o++) : (!n[o] || n[o][1].type !== "data") && (o !== i + 2 && (n[i][1].end = n[o - 1][1].end, n.splice(i + 2, o - i - 2), o = i + 2), i = void 0);
      return e ? e(n, r) : n;
    }
  }
  function W5e(e, t) {
    let n = 0;
    for (; ++n <= e.length; )
      if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
        const r = e[n - 1][1], o = t.sliceStream(r);
        let i = o.length, a = -1, s = 0, c;
        for (; i--; ) {
          const u = o[i];
          if (typeof u == "string") {
            for (a = u.length; u.charCodeAt(a - 1) === 32; )
              s++, a--;
            if (a) break;
            a = -1;
          } else if (u === -2)
            c = !0, s++;
          else if (u !== -1) {
            i++;
            break;
          }
        }
        if (t._contentTypeTextTrailing && n === e.length && (s = 0), s) {
          const u = {
            type: n === e.length || c || s < 2 ? "lineSuffix" : "hardBreakTrailing",
            start: {
              _bufferIndex: i ? a : r.start._bufferIndex + a,
              _index: r.start._index + i,
              line: r.end.line,
              column: r.end.column - s,
              offset: r.end.offset - s
            },
            end: {
              ...r.end
            }
          };
          r.end = {
            ...u.start
          }, r.start.offset === r.end.offset ? Object.assign(r, u) : (e.splice(n, 0, ["enter", u, t], ["exit", u, t]), n += 2);
        }
        n++;
      }
    return e;
  }
  const G5e = {
    42: Lr,
    43: Lr,
    45: Lr,
    48: Lr,
    49: Lr,
    50: Lr,
    51: Lr,
    52: Lr,
    53: Lr,
    54: Lr,
    55: Lr,
    56: Lr,
    57: Lr,
    62: q7
  }, K5e = {
    91: QDe
  }, Y5e = {
    [-2]: tE,
    [-1]: tE,
    32: tE
  }, X5e = {
    35: o5e,
    42: Xv,
    45: [m4, Xv],
    60: l5e,
    61: m4,
    95: Xv,
    96: p4,
    126: p4
  }, Z5e = {
    38: G7,
    92: W7
  }, Q5e = {
    [-5]: nE,
    [-4]: nE,
    [-3]: nE,
    33: k5e,
    38: G7,
    42: QC,
    60: [ADe, m5e],
    91: A5e,
    92: [n5e, W7],
    93: SR,
    95: QC,
    96: BDe
  }, J5e = {
    null: [QC, V5e]
  }, e3e = {
    null: [42, 95]
  }, t3e = {
    null: []
  }, n3e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    attentionMarkers: e3e,
    contentInitial: K5e,
    disable: t3e,
    document: G5e,
    flow: X5e,
    flowInitial: Y5e,
    insideSpan: J5e,
    string: Z5e,
    text: Q5e
  }, Symbol.toStringTag, { value: "Module" }));
  function r3e(e, t, n) {
    let r = {
      _bufferIndex: -1,
      _index: 0,
      line: n && n.line || 1,
      column: n && n.column || 1,
      offset: n && n.offset || 0
    };
    const o = {}, i = [];
    let a = [], s = [];
    const c = {
      attempt: O(k),
      check: O(A),
      consume: E,
      enter: _,
      exit: C,
      interrupt: O(A, {
        interrupt: !0
      })
    }, u = {
      code: null,
      containerState: {},
      defineSkip: b,
      events: [],
      now: y,
      parser: e,
      previous: null,
      sliceSerialize: m,
      sliceStream: g,
      write: p
    };
    let d = t.tokenize.call(u, c);
    return t.resolveAll && i.push(t), u;
    function p(L) {
      return a = Oo(a, L), v(), a[a.length - 1] !== null ? [] : (P(t, 0), u.events = L1(i, u.events, u), u.events);
    }
    function m(L, N) {
      return i3e(g(L), N);
    }
    function g(L) {
      return o3e(a, L);
    }
    function y() {
      const {
        _bufferIndex: L,
        _index: N,
        line: U,
        column: j,
        offset: V
      } = r;
      return {
        _bufferIndex: L,
        _index: N,
        line: U,
        column: j,
        offset: V
      };
    }
    function b(L) {
      o[L.line] = L.column, $();
    }
    function v() {
      let L;
      for (; r._index < a.length; ) {
        const N = a[r._index];
        if (typeof N == "string")
          for (L = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === L && r._bufferIndex < N.length; )
            x(N.charCodeAt(r._bufferIndex));
        else
          x(N);
      }
    }
    function x(L) {
      d = d(L);
    }
    function E(L) {
      Ze(L) ? (r.line++, r.column = 1, r.offset += L === -3 ? 2 : 1, $()) : L !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === // Points w/ non-negative `_bufferIndex` reference
      // strings.
      /** @type {string} */
      a[r._index].length && (r._bufferIndex = -1, r._index++)), u.previous = L;
    }
    function _(L, N) {
      const U = N || {};
      return U.type = L, U.start = y(), u.events.push(["enter", U, u]), s.push(U), U;
    }
    function C(L) {
      const N = s.pop();
      return N.end = y(), u.events.push(["exit", N, u]), N;
    }
    function k(L, N) {
      P(L, N.from);
    }
    function A(L, N) {
      N.restore();
    }
    function O(L, N) {
      return U;
      function U(j, V, F) {
        let K, W, Y, B;
        return Array.isArray(j) ? (
          /* c8 ignore next 1 */
          G(j)
        ) : "tokenize" in j ? (
          // Looks like a construct.
          G([
            /** @type {Construct} */
            j
          ])
        ) : D(j);
        function D(Q) {
          return ne;
          function ne(te) {
            const se = te !== null && Q[te], ue = te !== null && Q.null, J = [
              // To do: add more extension tests.
              /* c8 ignore next 2 */
              ...Array.isArray(se) ? se : se ? [se] : [],
              ...Array.isArray(ue) ? ue : ue ? [ue] : []
            ];
            return G(J)(te);
          }
        }
        function G(Q) {
          return K = Q, W = 0, Q.length === 0 ? F : z(Q[W]);
        }
        function z(Q) {
          return ne;
          function ne(te) {
            return B = I(), Y = Q, Q.partial || (u.currentConstruct = Q), Q.name && u.parser.constructs.disable.null.includes(Q.name) ? X() : Q.tokenize.call(
              // If we do have fields, create an object w/ `context` as its
              // prototype.
              // This allows a live binding, which is needed for `interrupt`.
              N ? Object.assign(Object.create(u), N) : u,
              c,
              H,
              X
            )(te);
          }
        }
        function H(Q) {
          return L(Y, B), V;
        }
        function X(Q) {
          return B.restore(), ++W < K.length ? z(K[W]) : F;
        }
      }
    }
    function P(L, N) {
      L.resolveAll && !i.includes(L) && i.push(L), L.resolve && uo(u.events, N, u.events.length - N, L.resolve(u.events.slice(N), u)), L.resolveTo && (u.events = L.resolveTo(u.events, u));
    }
    function I() {
      const L = y(), N = u.previous, U = u.currentConstruct, j = u.events.length, V = Array.from(s);
      return {
        from: j,
        restore: F
      };
      function F() {
        r = L, u.previous = N, u.currentConstruct = U, u.events.length = j, s = V, $();
      }
    }
    function $() {
      r.line in o && r.column < 2 && (r.column = o[r.line], r.offset += o[r.line] - 1);
    }
  }
  function o3e(e, t) {
    const n = t.start._index, r = t.start._bufferIndex, o = t.end._index, i = t.end._bufferIndex;
    let a;
    if (n === o)
      a = [e[n].slice(r, i)];
    else {
      if (a = e.slice(n, o), r > -1) {
        const s = a[0];
        typeof s == "string" ? a[0] = s.slice(r) : a.shift();
      }
      i > 0 && a.push(e[o].slice(0, i));
    }
    return a;
  }
  function i3e(e, t) {
    let n = -1;
    const r = [];
    let o;
    for (; ++n < e.length; ) {
      const i = e[n];
      let a;
      if (typeof i == "string")
        a = i;
      else switch (i) {
        case -5: {
          a = "\r";
          break;
        }
        case -4: {
          a = `
`;
          break;
        }
        case -3: {
          a = `\r
`;
          break;
        }
        case -2: {
          a = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && o) continue;
          a = " ";
          break;
        }
        default:
          a = String.fromCharCode(i);
      }
      o = i === -2, r.push(a);
    }
    return r.join("");
  }
  function a3e(e) {
    const r = {
      constructs: (
        /** @type {FullNormalizedExtension} */
        V7([n3e, ...(e || {}).extensions || []])
      ),
      content: o(wDe),
      defined: [],
      document: o(_De),
      flow: o(B5e),
      lazy: {},
      string: o(H5e),
      text: o(q5e)
    };
    return r;
    function o(i) {
      return a;
      function a(s) {
        return r3e(r, i, s);
      }
    }
  }
  function s3e(e) {
    for (; !K7(e); )
      ;
    return e;
  }
  const g4 = /[\0\t\n\r]/g;
  function l3e() {
    let e = 1, t = "", n = !0, r;
    return o;
    function o(i, a, s) {
      const c = [];
      let u, d, p, m, g;
      for (i = t + (typeof i == "string" ? i.toString() : new TextDecoder(a || void 0).decode(i)), p = 0, t = "", n && (i.charCodeAt(0) === 65279 && p++, n = void 0); p < i.length; ) {
        if (g4.lastIndex = p, u = g4.exec(i), m = u && u.index !== void 0 ? u.index : i.length, g = i.charCodeAt(m), !u) {
          t = i.slice(p);
          break;
        }
        if (g === 10 && p === m && r)
          c.push(-3), r = void 0;
        else
          switch (r && (c.push(-5), r = void 0), p < m && (c.push(i.slice(p, m)), e += m - p), g) {
            case 0: {
              c.push(65533), e++;
              break;
            }
            case 9: {
              for (d = Math.ceil(e / 4) * 4, c.push(-2); e++ < d; ) c.push(-1);
              break;
            }
            case 10: {
              c.push(-4), e = 1;
              break;
            }
            default:
              r = !0, e = 1;
          }
        p = m + 1;
      }
      return s && (r && c.push(-5), t && c.push(t), c.push(null)), c;
    }
  }
  const c3e = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
  function u3e(e) {
    return e.replace(c3e, f3e);
  }
  function f3e(e, t, n) {
    if (t)
      return t;
    if (n.charCodeAt(0) === 35) {
      const o = n.charCodeAt(1), i = o === 120 || o === 88;
      return H7(n.slice(i ? 2 : 1), i ? 16 : 10);
    }
    return wR(n) || e;
  }
  const eq = {}.hasOwnProperty;
  function d3e(e, t, n) {
    return typeof t != "string" && (n = t, t = void 0), p3e(n)(s3e(a3e(n).document().write(l3e()(e, t, !0))));
  }
  function p3e(e) {
    const t = {
      transforms: [],
      canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
      enter: {
        autolink: i(ze),
        autolinkProtocol: I,
        autolinkEmail: I,
        atxHeading: i(ge),
        blockQuote: i(ue),
        characterEscape: I,
        characterReference: I,
        codeFenced: i(J),
        codeFencedFenceInfo: a,
        codeFencedFenceMeta: a,
        codeIndented: i(J, a),
        codeText: i(ee, a),
        codeTextData: I,
        data: I,
        codeFlowValue: I,
        definition: i(ie),
        definitionDestinationString: a,
        definitionLabelString: a,
        definitionTitleString: a,
        emphasis: i(le),
        hardBreakEscape: i(Se),
        hardBreakTrailing: i(Se),
        htmlFlow: i(Me, a),
        htmlFlowData: I,
        htmlText: i(Me, a),
        htmlTextData: I,
        image: i(je),
        label: a,
        link: i(ze),
        listItem: i(Ue),
        listItemValue: m,
        listOrdered: i(Ye, p),
        listUnordered: i(Ye),
        paragraph: i(Ne),
        reference: z,
        referenceString: a,
        resourceDestinationString: a,
        resourceTitleString: a,
        setextHeading: i(ge),
        strong: i(mt),
        thematicBreak: i(Ae)
      },
      exit: {
        atxHeading: c(),
        atxHeadingSequence: k,
        autolink: c(),
        autolinkEmail: se,
        autolinkProtocol: te,
        blockQuote: c(),
        characterEscapeValue: $,
        characterReferenceMarkerHexadecimal: X,
        characterReferenceMarkerNumeric: X,
        characterReferenceValue: Q,
        characterReference: ne,
        codeFenced: c(v),
        codeFencedFence: b,
        codeFencedFenceInfo: g,
        codeFencedFenceMeta: y,
        codeFlowValue: $,
        codeIndented: c(x),
        codeText: c(V),
        codeTextData: $,
        data: $,
        definition: c(),
        definitionDestinationString: C,
        definitionLabelString: E,
        definitionTitleString: _,
        emphasis: c(),
        hardBreakEscape: c(N),
        hardBreakTrailing: c(N),
        htmlFlow: c(U),
        htmlFlowData: $,
        htmlText: c(j),
        htmlTextData: $,
        image: c(K),
        label: Y,
        labelText: W,
        lineEnding: L,
        link: c(F),
        listItem: c(),
        listOrdered: c(),
        listUnordered: c(),
        paragraph: c(),
        referenceString: H,
        resourceDestinationString: B,
        resourceTitleString: D,
        resource: G,
        setextHeading: c(P),
        setextHeadingLineSequence: O,
        setextHeadingText: A,
        strong: c(),
        thematicBreak: c()
      }
    };
    tq(t, (e || {}).mdastExtensions || []);
    const n = {};
    return r;
    function r(oe) {
      let fe = {
        type: "root",
        children: []
      };
      const _e = {
        stack: [fe],
        tokenStack: [],
        config: t,
        enter: s,
        exit: u,
        buffer: a,
        resume: d,
        data: n
      }, Ce = [];
      let Oe = -1;
      for (; ++Oe < oe.length; )
        if (oe[Oe][1].type === "listOrdered" || oe[Oe][1].type === "listUnordered")
          if (oe[Oe][0] === "enter")
            Ce.push(Oe);
          else {
            const He = Ce.pop();
            Oe = o(oe, He, Oe);
          }
      for (Oe = -1; ++Oe < oe.length; ) {
        const He = t[oe[Oe][0]];
        eq.call(He, oe[Oe][1].type) && He[oe[Oe][1].type].call(Object.assign({
          sliceSerialize: oe[Oe][2].sliceSerialize
        }, _e), oe[Oe][1]);
      }
      if (_e.tokenStack.length > 0) {
        const He = _e.tokenStack[_e.tokenStack.length - 1];
        (He[1] || y4).call(_e, void 0, He[0]);
      }
      for (fe.position = {
        start: zs(oe.length > 0 ? oe[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }),
        end: zs(oe.length > 0 ? oe[oe.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        })
      }, Oe = -1; ++Oe < t.transforms.length; )
        fe = t.transforms[Oe](fe) || fe;
      return fe;
    }
    function o(oe, fe, _e) {
      let Ce = fe - 1, Oe = -1, He = !1, Ot, it, Et, xn;
      for (; ++Ce <= _e; ) {
        const Mt = oe[Ce];
        switch (Mt[1].type) {
          case "listUnordered":
          case "listOrdered":
          case "blockQuote": {
            Mt[0] === "enter" ? Oe++ : Oe--, xn = void 0;
            break;
          }
          case "lineEndingBlank": {
            Mt[0] === "enter" && (Ot && !xn && !Oe && !Et && (Et = Ce), xn = void 0);
            break;
          }
          case "linePrefix":
          case "listItemValue":
          case "listItemMarker":
          case "listItemPrefix":
          case "listItemPrefixWhitespace":
            break;
          default:
            xn = void 0;
        }
        if (!Oe && Mt[0] === "enter" && Mt[1].type === "listItemPrefix" || Oe === -1 && Mt[0] === "exit" && (Mt[1].type === "listUnordered" || Mt[1].type === "listOrdered")) {
          if (Ot) {
            let De = Ce;
            for (it = void 0; De--; ) {
              const ft = oe[De];
              if (ft[1].type === "lineEnding" || ft[1].type === "lineEndingBlank") {
                if (ft[0] === "exit") continue;
                it && (oe[it][1].type = "lineEndingBlank", He = !0), ft[1].type = "lineEnding", it = De;
              } else if (!(ft[1].type === "linePrefix" || ft[1].type === "blockQuotePrefix" || ft[1].type === "blockQuotePrefixWhitespace" || ft[1].type === "blockQuoteMarker" || ft[1].type === "listItemIndent")) break;
            }
            Et && (!it || Et < it) && (Ot._spread = !0), Ot.end = Object.assign({}, it ? oe[it][1].start : Mt[1].end), oe.splice(it || Ce, 0, ["exit", Ot, Mt[2]]), Ce++, _e++;
          }
          if (Mt[1].type === "listItemPrefix") {
            const De = {
              type: "listItem",
              _spread: !1,
              start: Object.assign({}, Mt[1].start),
              // @ts-expect-error: well add `end` in a second.
              end: void 0
            };
            Ot = De, oe.splice(Ce, 0, ["enter", De, Mt[2]]), Ce++, _e++, Et = void 0, xn = !0;
          }
        }
      }
      return oe[fe][1]._spread = He, _e;
    }
    function i(oe, fe) {
      return _e;
      function _e(Ce) {
        s.call(this, oe(Ce), Ce), fe && fe.call(this, Ce);
      }
    }
    function a() {
      this.stack.push({
        type: "fragment",
        children: []
      });
    }
    function s(oe, fe, _e) {
      this.stack[this.stack.length - 1].children.push(oe), this.stack.push(oe), this.tokenStack.push([fe, _e || void 0]), oe.position = {
        start: zs(fe.start),
        // @ts-expect-error: `end` will be patched later.
        end: void 0
      };
    }
    function c(oe) {
      return fe;
      function fe(_e) {
        oe && oe.call(this, _e), u.call(this, _e);
      }
    }
    function u(oe, fe) {
      const _e = this.stack.pop(), Ce = this.tokenStack.pop();
      if (Ce)
        Ce[0].type !== oe.type && (fe ? fe.call(this, oe, Ce[0]) : (Ce[1] || y4).call(this, oe, Ce[0]));
      else throw new Error("Cannot close `" + oe.type + "` (" + Vp({
        start: oe.start,
        end: oe.end
      }) + "): its not open");
      _e.position.end = zs(oe.end);
    }
    function d() {
      return xR(this.stack.pop());
    }
    function p() {
      this.data.expectingFirstListItemValue = !0;
    }
    function m(oe) {
      if (this.data.expectingFirstListItemValue) {
        const fe = this.stack[this.stack.length - 2];
        fe.start = Number.parseInt(this.sliceSerialize(oe), 10), this.data.expectingFirstListItemValue = void 0;
      }
    }
    function g() {
      const oe = this.resume(), fe = this.stack[this.stack.length - 1];
      fe.lang = oe;
    }
    function y() {
      const oe = this.resume(), fe = this.stack[this.stack.length - 1];
      fe.meta = oe;
    }
    function b() {
      this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
    }
    function v() {
      const oe = this.resume(), fe = this.stack[this.stack.length - 1];
      fe.value = oe.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
    }
    function x() {
      const oe = this.resume(), fe = this.stack[this.stack.length - 1];
      fe.value = oe.replace(/(\r?\n|\r)$/g, "");
    }
    function E(oe) {
      const fe = this.resume(), _e = this.stack[this.stack.length - 1];
      _e.label = fe, _e.identifier = Jo(this.sliceSerialize(oe)).toLowerCase();
    }
    function _() {
      const oe = this.resume(), fe = this.stack[this.stack.length - 1];
      fe.title = oe;
    }
    function C() {
      const oe = this.resume(), fe = this.stack[this.stack.length - 1];
      fe.url = oe;
    }
    function k(oe) {
      const fe = this.stack[this.stack.length - 1];
      if (!fe.depth) {
        const _e = this.sliceSerialize(oe).length;
        fe.depth = _e;
      }
    }
    function A() {
      this.data.setextHeadingSlurpLineEnding = !0;
    }
    function O(oe) {
      const fe = this.stack[this.stack.length - 1];
      fe.depth = this.sliceSerialize(oe).codePointAt(0) === 61 ? 1 : 2;
    }
    function P() {
      this.data.setextHeadingSlurpLineEnding = void 0;
    }
    function I(oe) {
      const _e = this.stack[this.stack.length - 1].children;
      let Ce = _e[_e.length - 1];
      (!Ce || Ce.type !== "text") && (Ce = Je(), Ce.position = {
        start: zs(oe.start),
        // @ts-expect-error: well add `end` later.
        end: void 0
      }, _e.push(Ce)), this.stack.push(Ce);
    }
    function $(oe) {
      const fe = this.stack.pop();
      fe.value += this.sliceSerialize(oe), fe.position.end = zs(oe.end);
    }
    function L(oe) {
      const fe = this.stack[this.stack.length - 1];
      if (this.data.atHardBreak) {
        const _e = fe.children[fe.children.length - 1];
        _e.position.end = zs(oe.end), this.data.atHardBreak = void 0;
        return;
      }
      !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(fe.type) && (I.call(this, oe), $.call(this, oe));
    }
    function N() {
      this.data.atHardBreak = !0;
    }
    function U() {
      const oe = this.resume(), fe = this.stack[this.stack.length - 1];
      fe.value = oe;
    }
    function j() {
      const oe = this.resume(), fe = this.stack[this.stack.length - 1];
      fe.value = oe;
    }
    function V() {
      const oe = this.resume(), fe = this.stack[this.stack.length - 1];
      fe.value = oe;
    }
    function F() {
      const oe = this.stack[this.stack.length - 1];
      if (this.data.inReference) {
        const fe = this.data.referenceType || "shortcut";
        oe.type += "Reference", oe.referenceType = fe, delete oe.url, delete oe.title;
      } else
        delete oe.identifier, delete oe.label;
      this.data.referenceType = void 0;
    }
    function K() {
      const oe = this.stack[this.stack.length - 1];
      if (this.data.inReference) {
        const fe = this.data.referenceType || "shortcut";
        oe.type += "Reference", oe.referenceType = fe, delete oe.url, delete oe.title;
      } else
        delete oe.identifier, delete oe.label;
      this.data.referenceType = void 0;
    }
    function W(oe) {
      const fe = this.sliceSerialize(oe), _e = this.stack[this.stack.length - 2];
      _e.label = u3e(fe), _e.identifier = Jo(fe).toLowerCase();
    }
    function Y() {
      const oe = this.stack[this.stack.length - 1], fe = this.resume(), _e = this.stack[this.stack.length - 1];
      if (this.data.inReference = !0, _e.type === "link") {
        const Ce = oe.children;
        _e.children = Ce;
      } else
        _e.alt = fe;
    }
    function B() {
      const oe = this.resume(), fe = this.stack[this.stack.length - 1];
      fe.url = oe;
    }
    function D() {
      const oe = this.resume(), fe = this.stack[this.stack.length - 1];
      fe.title = oe;
    }
    function G() {
      this.data.inReference = void 0;
    }
    function z() {
      this.data.referenceType = "collapsed";
    }
    function H(oe) {
      const fe = this.resume(), _e = this.stack[this.stack.length - 1];
      _e.label = fe, _e.identifier = Jo(this.sliceSerialize(oe)).toLowerCase(), this.data.referenceType = "full";
    }
    function X(oe) {
      this.data.characterReferenceType = oe.type;
    }
    function Q(oe) {
      const fe = this.sliceSerialize(oe), _e = this.data.characterReferenceType;
      let Ce;
      _e ? (Ce = H7(fe, _e === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Ce = wR(fe);
      const Oe = this.stack[this.stack.length - 1];
      Oe.value += Ce;
    }
    function ne(oe) {
      const fe = this.stack.pop();
      fe.position.end = zs(oe.end);
    }
    function te(oe) {
      $.call(this, oe);
      const fe = this.stack[this.stack.length - 1];
      fe.url = this.sliceSerialize(oe);
    }
    function se(oe) {
      $.call(this, oe);
      const fe = this.stack[this.stack.length - 1];
      fe.url = "mailto:" + this.sliceSerialize(oe);
    }
    function ue() {
      return {
        type: "blockquote",
        children: []
      };
    }
    function J() {
      return {
        type: "code",
        lang: null,
        meta: null,
        value: ""
      };
    }
    function ee() {
      return {
        type: "inlineCode",
        value: ""
      };
    }
    function ie() {
      return {
        type: "definition",
        identifier: "",
        label: null,
        title: null,
        url: ""
      };
    }
    function le() {
      return {
        type: "emphasis",
        children: []
      };
    }
    function ge() {
      return {
        type: "heading",
        // @ts-expect-error `depth` will be set later.
        depth: 0,
        children: []
      };
    }
    function Se() {
      return {
        type: "break"
      };
    }
    function Me() {
      return {
        type: "html",
        value: ""
      };
    }
    function je() {
      return {
        type: "image",
        title: null,
        url: "",
        alt: null
      };
    }
    function ze() {
      return {
        type: "link",
        title: null,
        url: "",
        children: []
      };
    }
    function Ye(oe) {
      return {
        type: "list",
        ordered: oe.type === "listOrdered",
        start: null,
        spread: oe._spread,
        children: []
      };
    }
    function Ue(oe) {
      return {
        type: "listItem",
        spread: oe._spread,
        checked: null,
        children: []
      };
    }
    function Ne() {
      return {
        type: "paragraph",
        children: []
      };
    }
    function mt() {
      return {
        type: "strong",
        children: []
      };
    }
    function Je() {
      return {
        type: "text",
        value: ""
      };
    }
    function Ae() {
      return {
        type: "thematicBreak"
      };
    }
  }
  function zs(e) {
    return {
      line: e.line,
      column: e.column,
      offset: e.offset
    };
  }
  function tq(e, t) {
    let n = -1;
    for (; ++n < t.length; ) {
      const r = t[n];
      Array.isArray(r) ? tq(e, r) : h3e(e, r);
    }
  }
  function h3e(e, t) {
    let n;
    for (n in t)
      if (eq.call(t, n))
        switch (n) {
          case "canContainEols": {
            const r = t[n];
            r && e[n].push(...r);
            break;
          }
          case "transforms": {
            const r = t[n];
            r && e[n].push(...r);
            break;
          }
          case "enter":
          case "exit": {
            const r = t[n];
            r && Object.assign(e[n], r);
            break;
          }
        }
  }
  function y4(e, t) {
    throw e ? new Error("Cannot close `" + e.type + "` (" + Vp({
      start: e.start,
      end: e.end
    }) + "): a different token (`" + t.type + "`, " + Vp({
      start: t.start,
      end: t.end
    }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + Vp({
      start: t.start,
      end: t.end
    }) + ") is still open");
  }
  function m3e(e) {
    const t = this;
    t.parser = n;
    function n(r) {
      return d3e(r, {
        ...t.data("settings"),
        ...e,
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: t.data("micromarkExtensions") || [],
        mdastExtensions: t.data("fromMarkdownExtensions") || []
      });
    }
  }
  function g3e(e, t) {
    const n = {
      type: "element",
      tagName: "blockquote",
      properties: {},
      children: e.wrap(e.all(t), !0)
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  function y3e(e, t) {
    const n = { type: "element", tagName: "br", properties: {}, children: [] };
    return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
  }
  function v3e(e, t) {
    const n = t.value ? t.value + `
` : "", r = {};
    t.lang && (r.className = ["language-" + t.lang]);
    let o = {
      type: "element",
      tagName: "code",
      properties: r,
      children: [{ type: "text", value: n }]
    };
    return t.meta && (o.data = { meta: t.meta }), e.patch(t, o), o = e.applyData(t, o), o = { type: "element", tagName: "pre", properties: {}, children: [o] }, e.patch(t, o), o;
  }
  function b3e(e, t) {
    const n = {
      type: "element",
      tagName: "del",
      properties: {},
      children: e.all(t)
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  function x3e(e, t) {
    const n = {
      type: "element",
      tagName: "em",
      properties: {},
      children: e.all(t)
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  function w3e(e, t) {
    const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), o = Kf(r.toLowerCase()), i = e.footnoteOrder.indexOf(r);
    let a, s = e.footnoteCounts.get(r);
    s === void 0 ? (s = 0, e.footnoteOrder.push(r), a = e.footnoteOrder.length) : a = i + 1, s += 1, e.footnoteCounts.set(r, s);
    const c = {
      type: "element",
      tagName: "a",
      properties: {
        href: "#" + n + "fn-" + o,
        id: n + "fnref-" + o + (s > 1 ? "-" + s : ""),
        dataFootnoteRef: !0,
        ariaDescribedBy: ["footnote-label"]
      },
      children: [{ type: "text", value: String(a) }]
    };
    e.patch(t, c);
    const u = {
      type: "element",
      tagName: "sup",
      properties: {},
      children: [c]
    };
    return e.patch(t, u), e.applyData(t, u);
  }
  function S3e(e, t) {
    const n = {
      type: "element",
      tagName: "h" + t.depth,
      properties: {},
      children: e.all(t)
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  function _3e(e, t) {
    if (e.options.allowDangerousHtml) {
      const n = { type: "raw", value: t.value };
      return e.patch(t, n), e.applyData(t, n);
    }
  }
  function nq(e, t) {
    const n = t.referenceType;
    let r = "]";
    if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
      return [{ type: "text", value: "![" + t.alt + r }];
    const o = e.all(t), i = o[0];
    i && i.type === "text" ? i.value = "[" + i.value : o.unshift({ type: "text", value: "[" });
    const a = o[o.length - 1];
    return a && a.type === "text" ? a.value += r : o.push({ type: "text", value: r }), o;
  }
  function E3e(e, t) {
    const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
    if (!r)
      return nq(e, t);
    const o = { src: Kf(r.url || ""), alt: t.alt };
    r.title !== null && r.title !== void 0 && (o.title = r.title);
    const i = { type: "element", tagName: "img", properties: o, children: [] };
    return e.patch(t, i), e.applyData(t, i);
  }
  function C3e(e, t) {
    const n = { src: Kf(t.url) };
    t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
    const r = { type: "element", tagName: "img", properties: n, children: [] };
    return e.patch(t, r), e.applyData(t, r);
  }
  function k3e(e, t) {
    const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
    e.patch(t, n);
    const r = {
      type: "element",
      tagName: "code",
      properties: {},
      children: [n]
    };
    return e.patch(t, r), e.applyData(t, r);
  }
  function T3e(e, t) {
    const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
    if (!r)
      return nq(e, t);
    const o = { href: Kf(r.url || "") };
    r.title !== null && r.title !== void 0 && (o.title = r.title);
    const i = {
      type: "element",
      tagName: "a",
      properties: o,
      children: e.all(t)
    };
    return e.patch(t, i), e.applyData(t, i);
  }
  function A3e(e, t) {
    const n = { href: Kf(t.url) };
    t.title !== null && t.title !== void 0 && (n.title = t.title);
    const r = {
      type: "element",
      tagName: "a",
      properties: n,
      children: e.all(t)
    };
    return e.patch(t, r), e.applyData(t, r);
  }
  function R3e(e, t, n) {
    const r = e.all(t), o = n ? O3e(n) : rq(t), i = {}, a = [];
    if (typeof t.checked == "boolean") {
      const d = r[0];
      let p;
      d && d.type === "element" && d.tagName === "p" ? p = d : (p = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(p)), p.children.length > 0 && p.children.unshift({ type: "text", value: " " }), p.children.unshift({
        type: "element",
        tagName: "input",
        properties: { type: "checkbox", checked: t.checked, disabled: !0 },
        children: []
      }), i.className = ["task-list-item"];
    }
    let s = -1;
    for (; ++s < r.length; ) {
      const d = r[s];
      (o || s !== 0 || d.type !== "element" || d.tagName !== "p") && a.push({ type: "text", value: `
` }), d.type === "element" && d.tagName === "p" && !o ? a.push(...d.children) : a.push(d);
    }
    const c = r[r.length - 1];
    c && (o || c.type !== "element" || c.tagName !== "p") && a.push({ type: "text", value: `
` });
    const u = { type: "element", tagName: "li", properties: i, children: a };
    return e.patch(t, u), e.applyData(t, u);
  }
  function O3e(e) {
    let t = !1;
    if (e.type === "list") {
      t = e.spread || !1;
      const n = e.children;
      let r = -1;
      for (; !t && ++r < n.length; )
        t = rq(n[r]);
    }
    return t;
  }
  function rq(e) {
    const t = e.spread;
    return t ?? e.children.length > 1;
  }
  function M3e(e, t) {
    const n = {}, r = e.all(t);
    let o = -1;
    for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++o < r.length; ) {
      const a = r[o];
      if (a.type === "element" && a.tagName === "li" && a.properties && Array.isArray(a.properties.className) && a.properties.className.includes("task-list-item")) {
        n.className = ["contains-task-list"];
        break;
      }
    }
    const i = {
      type: "element",
      tagName: t.ordered ? "ol" : "ul",
      properties: n,
      children: e.wrap(r, !0)
    };
    return e.patch(t, i), e.applyData(t, i);
  }
  function N3e(e, t) {
    const n = {
      type: "element",
      tagName: "p",
      properties: {},
      children: e.all(t)
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  function P3e(e, t) {
    const n = { type: "root", children: e.wrap(e.all(t)) };
    return e.patch(t, n), e.applyData(t, n);
  }
  function I3e(e, t) {
    const n = {
      type: "element",
      tagName: "strong",
      properties: {},
      children: e.all(t)
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  function $3e(e, t) {
    const n = e.all(t), r = n.shift(), o = [];
    if (r) {
      const a = {
        type: "element",
        tagName: "thead",
        properties: {},
        children: e.wrap([r], !0)
      };
      e.patch(t.children[0], a), o.push(a);
    }
    if (n.length > 0) {
      const a = {
        type: "element",
        tagName: "tbody",
        properties: {},
        children: e.wrap(n, !0)
      }, s = gR(t.children[1]), c = j7(t.children[t.children.length - 1]);
      s && c && (a.position = { start: s, end: c }), o.push(a);
    }
    const i = {
      type: "element",
      tagName: "table",
      properties: {},
      children: e.wrap(o, !0)
    };
    return e.patch(t, i), e.applyData(t, i);
  }
  function j3e(e, t, n) {
    const r = n ? n.children : void 0, i = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", a = n && n.type === "table" ? n.align : void 0, s = a ? a.length : t.children.length;
    let c = -1;
    const u = [];
    for (; ++c < s; ) {
      const p = t.children[c], m = {}, g = a ? a[c] : void 0;
      g && (m.align = g);
      let y = { type: "element", tagName: i, properties: m, children: [] };
      p && (y.children = e.all(p), e.patch(p, y), y = e.applyData(p, y)), u.push(y);
    }
    const d = {
      type: "element",
      tagName: "tr",
      properties: {},
      children: e.wrap(u, !0)
    };
    return e.patch(t, d), e.applyData(t, d);
  }
  function D3e(e, t) {
    const n = {
      type: "element",
      tagName: "td",
      // Assume body cell.
      properties: {},
      children: e.all(t)
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  const v4 = 9, b4 = 32;
  function F3e(e) {
    const t = String(e), n = /\r?\n|\r/g;
    let r = n.exec(t), o = 0;
    const i = [];
    for (; r; )
      i.push(
        x4(t.slice(o, r.index), o > 0, !0),
        r[0]
      ), o = r.index + r[0].length, r = n.exec(t);
    return i.push(x4(t.slice(o), o > 0, !1)), i.join("");
  }
  function x4(e, t, n) {
    let r = 0, o = e.length;
    if (t) {
      let i = e.codePointAt(r);
      for (; i === v4 || i === b4; )
        r++, i = e.codePointAt(r);
    }
    if (n) {
      let i = e.codePointAt(o - 1);
      for (; i === v4 || i === b4; )
        o--, i = e.codePointAt(o - 1);
    }
    return o > r ? e.slice(r, o) : "";
  }
  function L3e(e, t) {
    const n = { type: "text", value: F3e(String(t.value)) };
    return e.patch(t, n), e.applyData(t, n);
  }
  function z3e(e, t) {
    const n = {
      type: "element",
      tagName: "hr",
      properties: {},
      children: []
    };
    return e.patch(t, n), e.applyData(t, n);
  }
  const B3e = {
    blockquote: g3e,
    break: y3e,
    code: v3e,
    delete: b3e,
    emphasis: x3e,
    footnoteReference: w3e,
    heading: S3e,
    html: _3e,
    imageReference: E3e,
    image: C3e,
    inlineCode: k3e,
    linkReference: T3e,
    link: A3e,
    listItem: R3e,
    list: M3e,
    paragraph: N3e,
    // @ts-expect-error: root is different, but hard to type.
    root: P3e,
    strong: I3e,
    table: $3e,
    tableCell: D3e,
    tableRow: j3e,
    text: L3e,
    thematicBreak: z3e,
    toml: bv,
    yaml: bv,
    definition: bv,
    footnoteDefinition: bv
  };
  function bv() {
  }
  const oq = -1, z1 = 0, qp = 1, K0 = 2, _R = 3, ER = 4, CR = 5, kR = 6, iq = 7, aq = 8, w4 = typeof self == "object" ? self : globalThis, U3e = (e, t) => {
    const n = (o, i) => (e.set(i, o), o), r = (o) => {
      if (e.has(o))
        return e.get(o);
      const [i, a] = t[o];
      switch (i) {
        case z1:
        case oq:
          return n(a, o);
        case qp: {
          const s = n([], o);
          for (const c of a)
            s.push(r(c));
          return s;
        }
        case K0: {
          const s = n({}, o);
          for (const [c, u] of a)
            s[r(c)] = r(u);
          return s;
        }
        case _R:
          return n(new Date(a), o);
        case ER: {
          const { source: s, flags: c } = a;
          return n(new RegExp(s, c), o);
        }
        case CR: {
          const s = n(/* @__PURE__ */ new Map(), o);
          for (const [c, u] of a)
            s.set(r(c), r(u));
          return s;
        }
        case kR: {
          const s = n(/* @__PURE__ */ new Set(), o);
          for (const c of a)
            s.add(r(c));
          return s;
        }
        case iq: {
          const { name: s, message: c } = a;
          return n(new w4[s](c), o);
        }
        case aq:
          return n(BigInt(a), o);
        case "BigInt":
          return n(Object(BigInt(a)), o);
        case "ArrayBuffer":
          return n(new Uint8Array(a).buffer, a);
        case "DataView": {
          const { buffer: s } = new Uint8Array(a);
          return n(new DataView(s), a);
        }
      }
      return n(new w4[i](a), o);
    };
    return r;
  }, S4 = (e) => U3e(/* @__PURE__ */ new Map(), e)(0), Lu = "", { toString: V3e } = {}, { keys: H3e } = Object, fp = (e) => {
    const t = typeof e;
    if (t !== "object" || !e)
      return [z1, t];
    const n = V3e.call(e).slice(8, -1);
    switch (n) {
      case "Array":
        return [qp, Lu];
      case "Object":
        return [K0, Lu];
      case "Date":
        return [_R, Lu];
      case "RegExp":
        return [ER, Lu];
      case "Map":
        return [CR, Lu];
      case "Set":
        return [kR, Lu];
      case "DataView":
        return [qp, n];
    }
    return n.includes("Array") ? [qp, n] : n.includes("Error") ? [iq, n] : [K0, n];
  }, xv = ([e, t]) => e === z1 && (t === "function" || t === "symbol"), q3e = (e, t, n, r) => {
    const o = (a, s) => {
      const c = r.push(a) - 1;
      return n.set(s, c), c;
    }, i = (a) => {
      if (n.has(a))
        return n.get(a);
      let [s, c] = fp(a);
      switch (s) {
        case z1: {
          let d = a;
          switch (c) {
            case "bigint":
              s = aq, d = a.toString();
              break;
            case "function":
            case "symbol":
              if (e)
                throw new TypeError("unable to serialize " + c);
              d = null;
              break;
            case "undefined":
              return o([oq], a);
          }
          return o([s, d], a);
        }
        case qp: {
          if (c) {
            let m = a;
            return c === "DataView" ? m = new Uint8Array(a.buffer) : c === "ArrayBuffer" && (m = new Uint8Array(a)), o([c, [...m]], a);
          }
          const d = [], p = o([s, d], a);
          for (const m of a)
            d.push(i(m));
          return p;
        }
        case K0: {
          if (c)
            switch (c) {
              case "BigInt":
                return o([c, a.toString()], a);
              case "Boolean":
              case "Number":
              case "String":
                return o([c, a.valueOf()], a);
            }
          if (t && "toJSON" in a)
            return i(a.toJSON());
          const d = [], p = o([s, d], a);
          for (const m of H3e(a))
            (e || !xv(fp(a[m]))) && d.push([i(m), i(a[m])]);
          return p;
        }
        case _R:
          return o([s, a.toISOString()], a);
        case ER: {
          const { source: d, flags: p } = a;
          return o([s, { source: d, flags: p }], a);
        }
        case CR: {
          const d = [], p = o([s, d], a);
          for (const [m, g] of a)
            (e || !(xv(fp(m)) || xv(fp(g)))) && d.push([i(m), i(g)]);
          return p;
        }
        case kR: {
          const d = [], p = o([s, d], a);
          for (const m of a)
            (e || !xv(fp(m))) && d.push(i(m));
          return p;
        }
      }
      const { message: u } = a;
      return o([s, { name: c, message: u }], a);
    };
    return i;
  }, _4 = (e, { json: t, lossy: n } = {}) => {
    const r = [];
    return q3e(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
  }, Y0 = typeof structuredClone == "function" ? (
    /* c8 ignore start */
    (e, t) => t && ("json" in t || "lossy" in t) ? S4(_4(e, t)) : structuredClone(e)
  ) : (e, t) => S4(_4(e, t));
  function W3e(e, t) {
    const n = [{ type: "text", value: "" }];
    return t > 1 && n.push({
      type: "element",
      tagName: "sup",
      properties: {},
      children: [{ type: "text", value: String(t) }]
    }), n;
  }
  function G3e(e, t) {
    return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
  }
  function K3e(e) {
    const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || W3e, r = e.options.footnoteBackLabel || G3e, o = e.options.footnoteLabel || "Footnotes", i = e.options.footnoteLabelTagName || "h2", a = e.options.footnoteLabelProperties || {
      className: ["sr-only"]
    }, s = [];
    let c = -1;
    for (; ++c < e.footnoteOrder.length; ) {
      const u = e.footnoteById.get(
        e.footnoteOrder[c]
      );
      if (!u)
        continue;
      const d = e.all(u), p = String(u.identifier).toUpperCase(), m = Kf(p.toLowerCase());
      let g = 0;
      const y = [], b = e.footnoteCounts.get(p);
      for (; b !== void 0 && ++g <= b; ) {
        y.length > 0 && y.push({ type: "text", value: " " });
        let E = typeof n == "string" ? n : n(c, g);
        typeof E == "string" && (E = { type: "text", value: E }), y.push({
          type: "element",
          tagName: "a",
          properties: {
            href: "#" + t + "fnref-" + m + (g > 1 ? "-" + g : ""),
            dataFootnoteBackref: "",
            ariaLabel: typeof r == "string" ? r : r(c, g),
            className: ["data-footnote-backref"]
          },
          children: Array.isArray(E) ? E : [E]
        });
      }
      const v = d[d.length - 1];
      if (v && v.type === "element" && v.tagName === "p") {
        const E = v.children[v.children.length - 1];
        E && E.type === "text" ? E.value += " " : v.children.push({ type: "text", value: " " }), v.children.push(...y);
      } else
        d.push(...y);
      const x = {
        type: "element",
        tagName: "li",
        properties: { id: t + "fn-" + m },
        children: e.wrap(d, !0)
      };
      e.patch(u, x), s.push(x);
    }
    if (s.length !== 0)
      return {
        type: "element",
        tagName: "section",
        properties: { dataFootnotes: !0, className: ["footnotes"] },
        children: [
          {
            type: "element",
            tagName: i,
            properties: {
              ...Y0(a),
              id: "footnote-label"
            },
            children: [{ type: "text", value: o }]
          },
          { type: "text", value: `
` },
          {
            type: "element",
            tagName: "ol",
            properties: {},
            children: e.wrap(s, !0)
          },
          { type: "text", value: `
` }
        ]
      };
  }
  const B1 = (
    // Note: overloads in JSDoc cant yet use different `@template`s.
    /**
     * @type {(
     *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
     *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
     *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
     *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
     *   ((test?: Test) => Check)
     * )}
     */
    /**
     * @param {Test} [test]
     * @returns {Check}
     */
    (function(e) {
      if (e == null)
        return Q3e;
      if (typeof e == "function")
        return U1(e);
      if (typeof e == "object")
        return Array.isArray(e) ? Y3e(e) : X3e(e);
      if (typeof e == "string")
        return Z3e(e);
      throw new Error("Expected function, string, or object as test");
    })
  );
  function Y3e(e) {
    const t = [];
    let n = -1;
    for (; ++n < e.length; )
      t[n] = B1(e[n]);
    return U1(r);
    function r(...o) {
      let i = -1;
      for (; ++i < t.length; )
        if (t[i].apply(this, o)) return !0;
      return !1;
    }
  }
  function X3e(e) {
    const t = (
      /** @type {Record<string, unknown>} */
      e
    );
    return U1(n);
    function n(r) {
      const o = (
        /** @type {Record<string, unknown>} */
        /** @type {unknown} */
        r
      );
      let i;
      for (i in e)
        if (o[i] !== t[i]) return !1;
      return !0;
    }
  }
  function Z3e(e) {
    return U1(t);
    function t(n) {
      return n && n.type === e;
    }
  }
  function U1(e) {
    return t;
    function t(n, r, o) {
      return !!(J3e(n) && e.call(
        this,
        n,
        typeof r == "number" ? r : void 0,
        o || void 0
      ));
    }
  }
  function Q3e() {
    return !0;
  }
  function J3e(e) {
    return e !== null && typeof e == "object" && "type" in e;
  }
  const sq = [], e4e = !0, JC = !1, t4e = "skip";
  function lq(e, t, n, r) {
    let o;
    typeof t == "function" && typeof n != "function" ? (r = n, n = t) : o = t;
    const i = B1(o), a = r ? -1 : 1;
    s(e, void 0, [])();
    function s(c, u, d) {
      const p = (
        /** @type {Record<string, unknown>} */
        c && typeof c == "object" ? c : {}
      );
      if (typeof p.type == "string") {
        const g = (
          // `hast`
          typeof p.tagName == "string" ? p.tagName : (
            // `xast`
            typeof p.name == "string" ? p.name : void 0
          )
        );
        Object.defineProperty(m, "name", {
          value: "node (" + (c.type + (g ? "<" + g + ">" : "")) + ")"
        });
      }
      return m;
      function m() {
        let g = sq, y, b, v;
        if ((!t || i(c, u, d[d.length - 1] || void 0)) && (g = n4e(n(c, d)), g[0] === JC))
          return g;
        if ("children" in c && c.children) {
          const x = (
            /** @type {UnistParent} */
            c
          );
          if (x.children && g[0] !== t4e)
            for (b = (r ? x.children.length : -1) + a, v = d.concat(x); b > -1 && b < x.children.length; ) {
              const E = x.children[b];
              if (y = s(E, b, v)(), y[0] === JC)
                return y;
              b = typeof y[1] == "number" ? y[1] : b + a;
            }
        }
        return g;
      }
    }
  }
  function n4e(e) {
    return Array.isArray(e) ? e : typeof e == "number" ? [e4e, e] : e == null ? sq : [e];
  }
  function TR(e, t, n, r) {
    let o, i, a;
    typeof t == "function" && typeof n != "function" ? (i = void 0, a = t, o = n) : (i = t, a = n, o = r), lq(e, i, s, o);
    function s(c, u) {
      const d = u[u.length - 1], p = d ? d.children.indexOf(c) : void 0;
      return a(c, p, d);
    }
  }
  const ek = {}.hasOwnProperty, r4e = {};
  function o4e(e, t) {
    const n = t || r4e, r = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), a = { ...B3e, ...n.handlers }, s = {
      all: u,
      applyData: a4e,
      definitionById: r,
      footnoteById: o,
      footnoteCounts: i,
      footnoteOrder: [],
      handlers: a,
      one: c,
      options: n,
      patch: i4e,
      wrap: l4e
    };
    return TR(e, function(d) {
      if (d.type === "definition" || d.type === "footnoteDefinition") {
        const p = d.type === "definition" ? r : o, m = String(d.identifier).toUpperCase();
        p.has(m) || p.set(m, d);
      }
    }), s;
    function c(d, p) {
      const m = d.type, g = s.handlers[m];
      if (ek.call(s.handlers, m) && g)
        return g(s, d, p);
      if (s.options.passThrough && s.options.passThrough.includes(m)) {
        if ("children" in d) {
          const { children: b, ...v } = d, x = Y0(v);
          return x.children = s.all(d), x;
        }
        return Y0(d);
      }
      return (s.options.unknownHandler || s4e)(s, d, p);
    }
    function u(d) {
      const p = [];
      if ("children" in d) {
        const m = d.children;
        let g = -1;
        for (; ++g < m.length; ) {
          const y = s.one(m[g], d);
          if (y) {
            if (g && m[g - 1].type === "break" && (!Array.isArray(y) && y.type === "text" && (y.value = E4(y.value)), !Array.isArray(y) && y.type === "element")) {
              const b = y.children[0];
              b && b.type === "text" && (b.value = E4(b.value));
            }
            Array.isArray(y) ? p.push(...y) : p.push(y);
          }
        }
      }
      return p;
    }
  }
  function i4e(e, t) {
    e.position && (t.position = Gje(e));
  }
  function a4e(e, t) {
    let n = t;
    if (e && e.data) {
      const r = e.data.hName, o = e.data.hChildren, i = e.data.hProperties;
      if (typeof r == "string")
        if (n.type === "element")
          n.tagName = r;
        else {
          const a = "children" in n ? n.children : [n];
          n = { type: "element", tagName: r, properties: {}, children: a };
        }
      n.type === "element" && i && Object.assign(n.properties, Y0(i)), "children" in n && n.children && o !== null && o !== void 0 && (n.children = o);
    }
    return n;
  }
  function s4e(e, t) {
    const n = t.data || {}, r = "value" in t && !(ek.call(n, "hProperties") || ek.call(n, "hChildren")) ? { type: "text", value: t.value } : {
      type: "element",
      tagName: "div",
      properties: {},
      children: e.all(t)
    };
    return e.patch(t, r), e.applyData(t, r);
  }
  function l4e(e, t) {
    const n = [];
    let r = -1;
    for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
      r && n.push({ type: "text", value: `
` }), n.push(e[r]);
    return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
  }
  function E4(e) {
    let t = 0, n = e.charCodeAt(t);
    for (; n === 9 || n === 32; )
      t++, n = e.charCodeAt(t);
    return e.slice(t);
  }
  function C4(e, t) {
    const n = o4e(e, t), r = n.one(e, void 0), o = K3e(n), i = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
    return o && i.children.push({ type: "text", value: `
` }, o), i;
  }
  function c4e(e, t) {
    return e && "run" in e ? async function(n, r) {
      const o = (
        /** @type {HastRoot} */
        C4(n, { file: r, ...t })
      );
      await e.run(o, r);
    } : function(n, r) {
      return (
        /** @type {HastRoot} */
        C4(n, { file: r, ...e || t })
      );
    };
  }
  function k4(e) {
    if (e)
      throw e;
  }
  var rE, T4;
  function u4e() {
    if (T4) return rE;
    T4 = 1;
    var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString, n = Object.defineProperty, r = Object.getOwnPropertyDescriptor, o = function(u) {
      return typeof Array.isArray == "function" ? Array.isArray(u) : t.call(u) === "[object Array]";
    }, i = function(u) {
      if (!u || t.call(u) !== "[object Object]")
        return !1;
      var d = e.call(u, "constructor"), p = u.constructor && u.constructor.prototype && e.call(u.constructor.prototype, "isPrototypeOf");
      if (u.constructor && !d && !p)
        return !1;
      var m;
      for (m in u)
        ;
      return typeof m > "u" || e.call(u, m);
    }, a = function(u, d) {
      n && d.name === "__proto__" ? n(u, d.name, {
        enumerable: !0,
        configurable: !0,
        value: d.newValue,
        writable: !0
      }) : u[d.name] = d.newValue;
    }, s = function(u, d) {
      if (d === "__proto__")
        if (e.call(u, d)) {
          if (r)
            return r(u, d).value;
        } else return;
      return u[d];
    };
    return rE = function c() {
      var u, d, p, m, g, y, b = arguments[0], v = 1, x = arguments.length, E = !1;
      for (typeof b == "boolean" && (E = b, b = arguments[1] || {}, v = 2), (b == null || typeof b != "object" && typeof b != "function") && (b = {}); v < x; ++v)
        if (u = arguments[v], u != null)
          for (d in u)
            p = s(b, d), m = s(u, d), b !== m && (E && m && (i(m) || (g = o(m))) ? (g ? (g = !1, y = p && o(p) ? p : []) : y = p && i(p) ? p : {}, a(b, { name: d, newValue: c(E, y, m) })) : typeof m < "u" && a(b, { name: d, newValue: m }));
      return b;
    }, rE;
  }
  var f4e = u4e();
  const oE = /* @__PURE__ */ Xi(f4e);
  function tk(e) {
    if (typeof e != "object" || e === null)
      return !1;
    const t = Object.getPrototypeOf(e);
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
  }
  function d4e() {
    const e = [], t = { run: n, use: r };
    return t;
    function n(...o) {
      let i = -1;
      const a = o.pop();
      if (typeof a != "function")
        throw new TypeError("Expected function as last argument, not " + a);
      s(null, ...o);
      function s(c, ...u) {
        const d = e[++i];
        let p = -1;
        if (c) {
          a(c);
          return;
        }
        for (; ++p < o.length; )
          (u[p] === null || u[p] === void 0) && (u[p] = o[p]);
        o = u, d ? p4e(d, s)(...u) : a(null, ...u);
      }
    }
    function r(o) {
      if (typeof o != "function")
        throw new TypeError(
          "Expected `middelware` to be a function, not " + o
        );
      return e.push(o), t;
    }
  }
  function p4e(e, t) {
    let n;
    return r;
    function r(...a) {
      const s = e.length > a.length;
      let c;
      s && a.push(o);
      try {
        c = e.apply(this, a);
      } catch (u) {
        const d = (
          /** @type {Error} */
          u
        );
        if (s && n)
          throw d;
        return o(d);
      }
      s || (c && c.then && typeof c.then == "function" ? c.then(i, o) : c instanceof Error ? o(c) : i(c));
    }
    function o(a, ...s) {
      n || (n = !0, t(a, ...s));
    }
    function i(a) {
      o(null, a);
    }
  }
  const _i = { basename: h4e, dirname: m4e, extname: g4e, join: y4e, sep: "/" };
  function h4e(e, t) {
    if (t !== void 0 && typeof t != "string")
      throw new TypeError('"ext" argument must be a string');
    _m(e);
    let n = 0, r = -1, o = e.length, i;
    if (t === void 0 || t.length === 0 || t.length > e.length) {
      for (; o--; )
        if (e.codePointAt(o) === 47) {
          if (i) {
            n = o + 1;
            break;
          }
        } else r < 0 && (i = !0, r = o + 1);
      return r < 0 ? "" : e.slice(n, r);
    }
    if (t === e)
      return "";
    let a = -1, s = t.length - 1;
    for (; o--; )
      if (e.codePointAt(o) === 47) {
        if (i) {
          n = o + 1;
          break;
        }
      } else
        a < 0 && (i = !0, a = o + 1), s > -1 && (e.codePointAt(o) === t.codePointAt(s--) ? s < 0 && (r = o) : (s = -1, r = a));
    return n === r ? r = a : r < 0 && (r = e.length), e.slice(n, r);
  }
  function m4e(e) {
    if (_m(e), e.length === 0)
      return ".";
    let t = -1, n = e.length, r;
    for (; --n; )
      if (e.codePointAt(n) === 47) {
        if (r) {
          t = n;
          break;
        }
      } else r || (r = !0);
    return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
  }
  function g4e(e) {
    _m(e);
    let t = e.length, n = -1, r = 0, o = -1, i = 0, a;
    for (; t--; ) {
      const s = e.codePointAt(t);
      if (s === 47) {
        if (a) {
          r = t + 1;
          break;
        }
        continue;
      }
      n < 0 && (a = !0, n = t + 1), s === 46 ? o < 0 ? o = t : i !== 1 && (i = 1) : o > -1 && (i = -1);
    }
    return o < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
    i === 0 || // The (right-most) trimmed path component is exactly `..`.
    i === 1 && o === n - 1 && o === r + 1 ? "" : e.slice(o, n);
  }
  function y4e(...e) {
    let t = -1, n;
    for (; ++t < e.length; )
      _m(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
    return n === void 0 ? "." : v4e(n);
  }
  function v4e(e) {
    _m(e);
    const t = e.codePointAt(0) === 47;
    let n = b4e(e, !t);
    return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
  }
  function b4e(e, t) {
    let n = "", r = 0, o = -1, i = 0, a = -1, s, c;
    for (; ++a <= e.length; ) {
      if (a < e.length)
        s = e.codePointAt(a);
      else {
        if (s === 47)
          break;
        s = 47;
      }
      if (s === 47) {
        if (!(o === a - 1 || i === 1)) if (o !== a - 1 && i === 2) {
          if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
            if (n.length > 2) {
              if (c = n.lastIndexOf("/"), c !== n.length - 1) {
                c < 0 ? (n = "", r = 0) : (n = n.slice(0, c), r = n.length - 1 - n.lastIndexOf("/")), o = a, i = 0;
                continue;
              }
            } else if (n.length > 0) {
              n = "", r = 0, o = a, i = 0;
              continue;
            }
          }
          t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
        } else
          n.length > 0 ? n += "/" + e.slice(o + 1, a) : n = e.slice(o + 1, a), r = a - o - 1;
        o = a, i = 0;
      } else s === 46 && i > -1 ? i++ : i = -1;
    }
    return n;
  }
  function _m(e) {
    if (typeof e != "string")
      throw new TypeError(
        "Path must be a string. Received " + JSON.stringify(e)
      );
  }
  const x4e = { cwd: w4e };
  function w4e() {
    return "/";
  }
  function nk(e) {
    return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
    e.auth === void 0);
  }
  function S4e(e) {
    if (typeof e == "string")
      e = new URL(e);
    else if (!nk(e)) {
      const t = new TypeError(
        'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
      );
      throw t.code = "ERR_INVALID_ARG_TYPE", t;
    }
    if (e.protocol !== "file:") {
      const t = new TypeError("The URL must be of scheme file");
      throw t.code = "ERR_INVALID_URL_SCHEME", t;
    }
    return _4e(e);
  }
  function _4e(e) {
    if (e.hostname !== "") {
      const r = new TypeError(
        'File URL host must be "localhost" or empty on darwin'
      );
      throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
    }
    const t = e.pathname;
    let n = -1;
    for (; ++n < t.length; )
      if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
        const r = t.codePointAt(n + 2);
        if (r === 70 || r === 102) {
          const o = new TypeError(
            "File URL path must not include encoded / characters"
          );
          throw o.code = "ERR_INVALID_FILE_URL_PATH", o;
        }
      }
    return decodeURIComponent(t);
  }
  const iE = (
    /** @type {const} */
    [
      "history",
      "path",
      "basename",
      "stem",
      "extname",
      "dirname"
    ]
  );
  class cq {
    /**
     * Create a new virtual file.
     *
     * `options` is treated as:
     *
     * *   `string` or `Uint8Array`  `{value: options}`
     * *   `URL`  `{path: options}`
     * *   `VFile`  shallow copies its data over to the new file
     * *   `object`  all fields are shallow copied over to the new file
     *
     * Path related fields are set in the following order (least specific to
     * most specific): `history`, `path`, `basename`, `stem`, `extname`,
     * `dirname`.
     *
     * You cannot set `dirname` or `extname` without setting either `history`,
     * `path`, `basename`, or `stem` too.
     *
     * @param {Compatible | null | undefined} [value]
     *   File value.
     * @returns
     *   New instance.
     */
    constructor(t) {
      let n;
      t ? nk(t) ? n = { path: t } : typeof t == "string" || E4e(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : x4e.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
      let r = -1;
      for (; ++r < iE.length; ) {
        const i = iE[r];
        i in n && n[i] !== void 0 && n[i] !== null && (this[i] = i === "history" ? [...n[i]] : n[i]);
      }
      let o;
      for (o in n)
        iE.includes(o) || (this[o] = n[o]);
    }
    /**
     * Get the basename (including extname) (example: `'index.min.js'`).
     *
     * @returns {string | undefined}
     *   Basename.
     */
    get basename() {
      return typeof this.path == "string" ? _i.basename(this.path) : void 0;
    }
    /**
     * Set basename (including extname) (`'index.min.js'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be nullified (use `file.path = file.dirname` instead).
     *
     * @param {string} basename
     *   Basename.
     * @returns {undefined}
     *   Nothing.
     */
    set basename(t) {
      sE(t, "basename"), aE(t, "basename"), this.path = _i.join(this.dirname || "", t);
    }
    /**
     * Get the parent path (example: `'~'`).
     *
     * @returns {string | undefined}
     *   Dirname.
     */
    get dirname() {
      return typeof this.path == "string" ? _i.dirname(this.path) : void 0;
    }
    /**
     * Set the parent path (example: `'~'`).
     *
     * Cannot be set if theres no `path` yet.
     *
     * @param {string | undefined} dirname
     *   Dirname.
     * @returns {undefined}
     *   Nothing.
     */
    set dirname(t) {
      A4(this.basename, "dirname"), this.path = _i.join(t || "", this.basename);
    }
    /**
     * Get the extname (including dot) (example: `'.js'`).
     *
     * @returns {string | undefined}
     *   Extname.
     */
    get extname() {
      return typeof this.path == "string" ? _i.extname(this.path) : void 0;
    }
    /**
     * Set the extname (including dot) (example: `'.js'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be set if theres no `path` yet.
     *
     * @param {string | undefined} extname
     *   Extname.
     * @returns {undefined}
     *   Nothing.
     */
    set extname(t) {
      if (aE(t, "extname"), A4(this.dirname, "extname"), t) {
        if (t.codePointAt(0) !== 46)
          throw new Error("`extname` must start with `.`");
        if (t.includes(".", 1))
          throw new Error("`extname` cannot contain multiple dots");
      }
      this.path = _i.join(this.dirname, this.stem + (t || ""));
    }
    /**
     * Get the full path (example: `'~/index.min.js'`).
     *
     * @returns {string}
     *   Path.
     */
    get path() {
      return this.history[this.history.length - 1];
    }
    /**
     * Set the full path (example: `'~/index.min.js'`).
     *
     * Cannot be nullified.
     * You can set a file URL (a `URL` object with a `file:` protocol) which will
     * be turned into a path with `url.fileURLToPath`.
     *
     * @param {URL | string} path
     *   Path.
     * @returns {undefined}
     *   Nothing.
     */
    set path(t) {
      nk(t) && (t = S4e(t)), sE(t, "path"), this.path !== t && this.history.push(t);
    }
    /**
     * Get the stem (basename w/o extname) (example: `'index.min'`).
     *
     * @returns {string | undefined}
     *   Stem.
     */
    get stem() {
      return typeof this.path == "string" ? _i.basename(this.path, this.extname) : void 0;
    }
    /**
     * Set the stem (basename w/o extname) (example: `'index.min'`).
     *
     * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
     * on windows).
     * Cannot be nullified (use `file.path = file.dirname` instead).
     *
     * @param {string} stem
     *   Stem.
     * @returns {undefined}
     *   Nothing.
     */
    set stem(t) {
      sE(t, "stem"), aE(t, "stem"), this.path = _i.join(this.dirname || "", t + (this.extname || ""));
    }
    // Normal prototypal methods.
    /**
     * Create a fatal message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `true` (error; file not usable)
     * and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * >  **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {never}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {never}
     *   Never.
     * @throws {VFileMessage}
     *   Message.
     */
    fail(t, n, r) {
      const o = this.message(t, n, r);
      throw o.fatal = !0, o;
    }
    /**
     * Create an info message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `undefined` (info; change
     * likely not needed) and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * >  **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {VFileMessage}
     *   Message.
     */
    info(t, n, r) {
      const o = this.message(t, n, r);
      return o.fatal = void 0, o;
    }
    /**
     * Create a message for `reason` associated with the file.
     *
     * The `fatal` field of the message is set to `false` (warning; change may be
     * needed) and the `file` field is set to the current file path.
     * The message is added to the `messages` field on `file`.
     *
     * >  **Note**: also has obsolete signatures.
     *
     * @overload
     * @param {string} reason
     * @param {MessageOptions | null | undefined} [options]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {string} reason
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Node | NodeLike | null | undefined} parent
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {Point | Position | null | undefined} place
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @overload
     * @param {Error | VFileMessage} cause
     * @param {string | null | undefined} [origin]
     * @returns {VFileMessage}
     *
     * @param {Error | VFileMessage | string} causeOrReason
     *   Reason for message, should use markdown.
     * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
     *   Configuration (optional).
     * @param {string | null | undefined} [origin]
     *   Place in code where the message originates (example:
     *   `'my-package:my-rule'` or `'my-rule'`).
     * @returns {VFileMessage}
     *   Message.
     */
    message(t, n, r) {
      const o = new _r(
        // @ts-expect-error: the overloads are fine.
        t,
        n,
        r
      );
      return this.path && (o.name = this.path + ":" + o.name, o.file = this.path), o.fatal = !1, this.messages.push(o), o;
    }
    /**
     * Serialize the file.
     *
     * > **Note**: which encodings are supported depends on the engine.
     * > For info on Node.js, see:
     * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
     *
     * @param {string | null | undefined} [encoding='utf8']
     *   Character encoding to understand `value` as when its a `Uint8Array`
     *   (default: `'utf-8'`).
     * @returns {string}
     *   Serialized file.
     */
    toString(t) {
      return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
    }
  }
  function aE(e, t) {
    if (e && e.includes(_i.sep))
      throw new Error(
        "`" + t + "` cannot be a path: did not expect `" + _i.sep + "`"
      );
  }
  function sE(e, t) {
    if (!e)
      throw new Error("`" + t + "` cannot be empty");
  }
  function A4(e, t) {
    if (!e)
      throw new Error("Setting `" + t + "` requires `path` to be set too");
  }
  function E4e(e) {
    return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
  }
  const C4e = (
    /**
     * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
     */
    /** @type {unknown} */
    /**
     * @this {Function}
     * @param {string | symbol} property
     * @returns {(...parameters: Array<unknown>) => unknown}
     */
    (function(e) {
      const r = (
        /** @type {Record<string | symbol, Function>} */
        // Prototypes do exist.
        // type-coverage:ignore-next-line
        this.constructor.prototype
      ), o = r[e], i = function() {
        return o.apply(i, arguments);
      };
      return Object.setPrototypeOf(i, r), i;
    })
  ), k4e = {}.hasOwnProperty;
  class AR extends C4e {
    /**
     * Create a processor.
     */
    constructor() {
      super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = d4e();
    }
    /**
     * Copy a processor.
     *
     * @deprecated
     *   This is a private internal method and should not be used.
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *   New *unfrozen* processor ({@linkcode Processor}) that is
     *   configured to work the same as its ancestor.
     *   When the descendant processor is configured in the future it does not
     *   affect the ancestral processor.
     */
    copy() {
      const t = (
        /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
        new AR()
      );
      let n = -1;
      for (; ++n < this.attachers.length; ) {
        const r = this.attachers[n];
        t.use(...r);
      }
      return t.data(oE(!0, {}, this.namespace)), t;
    }
    /**
     * Configure the processor with info available to all plugins.
     * Information is stored in an object.
     *
     * Typically, options can be given to a specific plugin, but sometimes it
     * makes sense to have information shared with several plugins.
     * For example, a list of HTML elements that are self-closing, which is
     * needed during all phases.
     *
     * > **Note**: setting information cannot occur on *frozen* processors.
     * > Call the processor first to create a new unfrozen processor.
     *
     * > **Note**: to register custom data in TypeScript, augment the
     * > {@linkcode Data} interface.
     *
     * @example
     *   This example show how to get and set info:
     *
     *   ```js
     *   import {unified} from 'unified'
     *
     *   const processor = unified().data('alpha', 'bravo')
     *
     *   processor.data('alpha') // => 'bravo'
     *
     *   processor.data() // => {alpha: 'bravo'}
     *
     *   processor.data({charlie: 'delta'})
     *
     *   processor.data() // => {charlie: 'delta'}
     *   ```
     *
     * @template {keyof Data} Key
     *
     * @overload
     * @returns {Data}
     *
     * @overload
     * @param {Data} dataset
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @overload
     * @param {Key} key
     * @returns {Data[Key]}
     *
     * @overload
     * @param {Key} key
     * @param {Data[Key]} value
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @param {Data | Key} [key]
     *   Key to get or set, or entire dataset to set, or nothing to get the
     *   entire dataset (optional).
     * @param {Data[Key]} [value]
     *   Value to set (optional).
     * @returns {unknown}
     *   The current processor when setting, the value at `key` when getting, or
     *   the entire dataset when getting without key.
     */
    data(t, n) {
      return typeof t == "string" ? arguments.length === 2 ? (uE("data", this.frozen), this.namespace[t] = n, this) : k4e.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (uE("data", this.frozen), this.namespace = t, this) : this.namespace;
    }
    /**
     * Freeze a processor.
     *
     * Frozen processors are meant to be extended and not to be configured
     * directly.
     *
     * When a processor is frozen it cannot be unfrozen.
     * New processors working the same way can be created by calling the
     * processor.
     *
     * Its possible to freeze processors explicitly by calling `.freeze()`.
     * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
     * `.stringify()`, `.process()`, or `.processSync()` are called.
     *
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *   The current processor.
     */
    freeze() {
      if (this.frozen)
        return this;
      const t = (
        /** @type {Processor} */
        /** @type {unknown} */
        this
      );
      for (; ++this.freezeIndex < this.attachers.length; ) {
        const [n, ...r] = this.attachers[this.freezeIndex];
        if (r[0] === !1)
          continue;
        r[0] === !0 && (r[0] = void 0);
        const o = n.call(t, ...r);
        typeof o == "function" && this.transformers.use(o);
      }
      return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
    }
    /**
     * Parse text to a syntax tree.
     *
     * > **Note**: `parse` freezes the processor if not already *frozen*.
     *
     * > **Note**: `parse` performs the parse phase, not the run phase or other
     * > phases.
     *
     * @param {Compatible | undefined} [file]
     *   file to parse (optional); typically `string` or `VFile`; any value
     *   accepted as `x` in `new VFile(x)`.
     * @returns {ParseTree extends undefined ? Node : ParseTree}
     *   Syntax tree representing `file`.
     */
    parse(t) {
      this.freeze();
      const n = wv(t), r = this.parser || this.Parser;
      return lE("parse", r), r(String(n), n);
    }
    /**
     * Process the given file as configured on the processor.
     *
     * > **Note**: `process` freezes the processor if not already *frozen*.
     *
     * > **Note**: `process` performs the parse, run, and stringify phases.
     *
     * @overload
     * @param {Compatible | undefined} file
     * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
     * @returns {undefined}
     *
     * @overload
     * @param {Compatible | undefined} [file]
     * @returns {Promise<VFileWithOutput<CompileResult>>}
     *
     * @param {Compatible | undefined} [file]
     *   File (optional); typically `string` or `VFile`]; any value accepted as
     *   `x` in `new VFile(x)`.
     * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
     *   Callback (optional).
     * @returns {Promise<VFile> | undefined}
     *   Nothing if `done` is given.
     *   Otherwise a promise, rejected with a fatal error or resolved with the
     *   processed file.
     *
     *   The parsed, transformed, and compiled value is available at
     *   `file.value` (see note).
     *
     *   > **Note**: unified typically compiles by serializing: most
     *   > compilers return `string` (or `Uint8Array`).
     *   > Some compilers, such as the one configured with
     *   > [`rehype-react`][rehype-react], return other values (in this case, a
     *   > React tree).
     *   > If youre using a compiler that doesnt serialize, expect different
     *   > result values.
     *   >
     *   > To register custom results in TypeScript, add them to
     *   > {@linkcode CompileResultMap}.
     *
     *   [rehype-react]: https://github.com/rehypejs/rehype-react
     */
    process(t, n) {
      const r = this;
      return this.freeze(), lE("process", this.parser || this.Parser), cE("process", this.compiler || this.Compiler), n ? o(void 0, n) : new Promise(o);
      function o(i, a) {
        const s = wv(t), c = (
          /** @type {HeadTree extends undefined ? Node : HeadTree} */
          /** @type {unknown} */
          r.parse(s)
        );
        r.run(c, s, function(d, p, m) {
          if (d || !p || !m)
            return u(d);
          const g = (
            /** @type {CompileTree extends undefined ? Node : CompileTree} */
            /** @type {unknown} */
            p
          ), y = r.stringify(g, m);
          R4e(y) ? m.value = y : m.result = y, u(
            d,
            /** @type {VFileWithOutput<CompileResult>} */
            m
          );
        });
        function u(d, p) {
          d || !p ? a(d) : i ? i(p) : n(void 0, p);
        }
      }
    }
    /**
     * Process the given file as configured on the processor.
     *
     * An error is thrown if asynchronous transforms are configured.
     *
     * > **Note**: `processSync` freezes the processor if not already *frozen*.
     *
     * > **Note**: `processSync` performs the parse, run, and stringify phases.
     *
     * @param {Compatible | undefined} [file]
     *   File (optional); typically `string` or `VFile`; any value accepted as
     *   `x` in `new VFile(x)`.
     * @returns {VFileWithOutput<CompileResult>}
     *   The processed file.
     *
     *   The parsed, transformed, and compiled value is available at
     *   `file.value` (see note).
     *
     *   > **Note**: unified typically compiles by serializing: most
     *   > compilers return `string` (or `Uint8Array`).
     *   > Some compilers, such as the one configured with
     *   > [`rehype-react`][rehype-react], return other values (in this case, a
     *   > React tree).
     *   > If youre using a compiler that doesnt serialize, expect different
     *   > result values.
     *   >
     *   > To register custom results in TypeScript, add them to
     *   > {@linkcode CompileResultMap}.
     *
     *   [rehype-react]: https://github.com/rehypejs/rehype-react
     */
    processSync(t) {
      let n = !1, r;
      return this.freeze(), lE("processSync", this.parser || this.Parser), cE("processSync", this.compiler || this.Compiler), this.process(t, o), O4("processSync", "process", n), r;
      function o(i, a) {
        n = !0, k4(i), r = a;
      }
    }
    /**
     * Run *transformers* on a syntax tree.
     *
     * > **Note**: `run` freezes the processor if not already *frozen*.
     *
     * > **Note**: `run` performs the run phase, not other phases.
     *
     * @overload
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
     * @returns {undefined}
     *
     * @overload
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     * @param {Compatible | undefined} file
     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
     * @returns {undefined}
     *
     * @overload
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     * @param {Compatible | undefined} [file]
     * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
     *
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     *   Tree to transform and inspect.
     * @param {(
     *   RunCallback<TailTree extends undefined ? Node : TailTree> |
     *   Compatible
     * )} [file]
     *   File associated with `node` (optional); any value accepted as `x` in
     *   `new VFile(x)`.
     * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
     *   Callback (optional).
     * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
     *   Nothing if `done` is given.
     *   Otherwise, a promise rejected with a fatal error or resolved with the
     *   transformed tree.
     */
    run(t, n, r) {
      R4(t), this.freeze();
      const o = this.transformers;
      return !r && typeof n == "function" && (r = n, n = void 0), r ? i(void 0, r) : new Promise(i);
      function i(a, s) {
        const c = wv(n);
        o.run(t, c, u);
        function u(d, p, m) {
          const g = (
            /** @type {TailTree extends undefined ? Node : TailTree} */
            p || t
          );
          d ? s(d) : a ? a(g) : r(void 0, g, m);
        }
      }
    }
    /**
     * Run *transformers* on a syntax tree.
     *
     * An error is thrown if asynchronous transforms are configured.
     *
     * > **Note**: `runSync` freezes the processor if not already *frozen*.
     *
     * > **Note**: `runSync` performs the run phase, not other phases.
     *
     * @param {HeadTree extends undefined ? Node : HeadTree} tree
     *   Tree to transform and inspect.
     * @param {Compatible | undefined} [file]
     *   File associated with `node` (optional); any value accepted as `x` in
     *   `new VFile(x)`.
     * @returns {TailTree extends undefined ? Node : TailTree}
     *   Transformed tree.
     */
    runSync(t, n) {
      let r = !1, o;
      return this.run(t, n, i), O4("runSync", "run", r), o;
      function i(a, s) {
        k4(a), o = s, r = !0;
      }
    }
    /**
     * Compile a syntax tree.
     *
     * > **Note**: `stringify` freezes the processor if not already *frozen*.
     *
     * > **Note**: `stringify` performs the stringify phase, not the run phase
     * > or other phases.
     *
     * @param {CompileTree extends undefined ? Node : CompileTree} tree
     *   Tree to compile.
     * @param {Compatible | undefined} [file]
     *   File associated with `node` (optional); any value accepted as `x` in
     *   `new VFile(x)`.
     * @returns {CompileResult extends undefined ? Value : CompileResult}
     *   Textual representation of the tree (see note).
     *
     *   > **Note**: unified typically compiles by serializing: most compilers
     *   > return `string` (or `Uint8Array`).
     *   > Some compilers, such as the one configured with
     *   > [`rehype-react`][rehype-react], return other values (in this case, a
     *   > React tree).
     *   > If youre using a compiler that doesnt serialize, expect different
     *   > result values.
     *   >
     *   > To register custom results in TypeScript, add them to
     *   > {@linkcode CompileResultMap}.
     *
     *   [rehype-react]: https://github.com/rehypejs/rehype-react
     */
    stringify(t, n) {
      this.freeze();
      const r = wv(n), o = this.compiler || this.Compiler;
      return cE("stringify", o), R4(t), o(t, r);
    }
    /**
     * Configure the processor to use a plugin, a list of usable values, or a
     * preset.
     *
     * If the processor is already using a plugin, the previous plugin
     * configuration is changed based on the options that are passed in.
     * In other words, the plugin is not added a second time.
     *
     * > **Note**: `use` cannot be called on *frozen* processors.
     * > Call the processor first to create a new unfrozen processor.
     *
     * @example
     *   There are many ways to pass plugins to `.use()`.
     *   This example gives an overview:
     *
     *   ```js
     *   import {unified} from 'unified'
     *
     *   unified()
     *     // Plugin with options:
     *     .use(pluginA, {x: true, y: true})
     *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
     *     .use(pluginA, {y: false, z: true})
     *     // Plugins:
     *     .use([pluginB, pluginC])
     *     // Two plugins, the second with options:
     *     .use([pluginD, [pluginE, {}]])
     *     // Preset with plugins and settings:
     *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
     *     // Settings only:
     *     .use({settings: {position: false}})
     *   ```
     *
     * @template {Array<unknown>} [Parameters=[]]
     * @template {Node | string | undefined} [Input=undefined]
     * @template [Output=Input]
     *
     * @overload
     * @param {Preset | null | undefined} [preset]
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @overload
     * @param {PluggableList} list
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *
     * @overload
     * @param {Plugin<Parameters, Input, Output>} plugin
     * @param {...(Parameters | [boolean])} parameters
     * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
     *
     * @param {PluggableList | Plugin | Preset | null | undefined} value
     *   Usable value.
     * @param {...unknown} parameters
     *   Parameters, when a plugin is given as a usable value.
     * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
     *   Current processor.
     */
    use(t, ...n) {
      const r = this.attachers, o = this.namespace;
      if (uE("use", this.frozen), t != null) if (typeof t == "function")
        c(t, n);
      else if (typeof t == "object")
        Array.isArray(t) ? s(t) : a(t);
      else
        throw new TypeError("Expected usable value, not `" + t + "`");
      return this;
      function i(u) {
        if (typeof u == "function")
          c(u, []);
        else if (typeof u == "object")
          if (Array.isArray(u)) {
            const [d, ...p] = (
              /** @type {PluginTuple<Array<unknown>>} */
              u
            );
            c(d, p);
          } else
            a(u);
        else
          throw new TypeError("Expected usable value, not `" + u + "`");
      }
      function a(u) {
        if (!("plugins" in u) && !("settings" in u))
          throw new Error(
            "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
          );
        s(u.plugins), u.settings && (o.settings = oE(!0, o.settings, u.settings));
      }
      function s(u) {
        let d = -1;
        if (u != null) if (Array.isArray(u))
          for (; ++d < u.length; ) {
            const p = u[d];
            i(p);
          }
        else
          throw new TypeError("Expected a list of plugins, not `" + u + "`");
      }
      function c(u, d) {
        let p = -1, m = -1;
        for (; ++p < r.length; )
          if (r[p][0] === u) {
            m = p;
            break;
          }
        if (m === -1)
          r.push([u, ...d]);
        else if (d.length > 0) {
          let [g, ...y] = d;
          const b = r[m][1];
          tk(b) && tk(g) && (g = oE(!0, b, g)), r[m] = [u, g, ...y];
        }
      }
    }
  }
  const T4e = new AR().freeze();
  function lE(e, t) {
    if (typeof t != "function")
      throw new TypeError("Cannot `" + e + "` without `parser`");
  }
  function cE(e, t) {
    if (typeof t != "function")
      throw new TypeError("Cannot `" + e + "` without `compiler`");
  }
  function uE(e, t) {
    if (t)
      throw new Error(
        "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
      );
  }
  function R4(e) {
    if (!tk(e) || typeof e.type != "string")
      throw new TypeError("Expected node, got `" + e + "`");
  }
  function O4(e, t, n) {
    if (!n)
      throw new Error(
        "`" + e + "` finished async. Use `" + t + "` instead"
      );
  }
  function wv(e) {
    return A4e(e) ? e : new cq(e);
  }
  function A4e(e) {
    return !!(e && typeof e == "object" && "message" in e && "messages" in e);
  }
  function R4e(e) {
    return typeof e == "string" || O4e(e);
  }
  function O4e(e) {
    return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
  }
  const M4e = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", M4 = [], N4 = { allowDangerousHtml: !0 }, N4e = /^(https?|ircs?|mailto|xmpp)$/i, P4e = [
    { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
    { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
    {
      from: "allowNode",
      id: "replace-allownode-allowedtypes-and-disallowedtypes",
      to: "allowElement"
    },
    {
      from: "allowedTypes",
      id: "replace-allownode-allowedtypes-and-disallowedtypes",
      to: "allowedElements"
    },
    { from: "className", id: "remove-classname" },
    {
      from: "disallowedTypes",
      id: "replace-allownode-allowedtypes-and-disallowedtypes",
      to: "disallowedElements"
    },
    { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
    { from: "includeElementIndex", id: "#remove-includeelementindex" },
    {
      from: "includeNodeIndex",
      id: "change-includenodeindex-to-includeelementindex"
    },
    { from: "linkTarget", id: "remove-linktarget" },
    { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
    { from: "rawSourcePos", id: "#remove-rawsourcepos" },
    { from: "renderers", id: "change-renderers-to-components", to: "components" },
    { from: "source", id: "change-source-to-children", to: "children" },
    { from: "sourcePos", id: "#remove-sourcepos" },
    { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
    { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
  ];
  function I4e(e) {
    const t = $4e(e), n = j4e(e);
    return D4e(t.runSync(t.parse(n), n), e);
  }
  function $4e(e) {
    const t = e.rehypePlugins || M4, n = e.remarkPlugins || M4, r = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...N4 } : N4;
    return T4e().use(m3e).use(n).use(c4e, r).use(t);
  }
  function j4e(e) {
    const t = e.children || "", n = new cq();
    return typeof t == "string" && (n.value = t), n;
  }
  function D4e(e, t) {
    const n = t.allowedElements, r = t.allowElement, o = t.components, i = t.disallowedElements, a = t.skipHtml, s = t.unwrapDisallowed, c = t.urlTransform || F4e;
    for (const d of P4e)
      Object.hasOwn(t, d.from) && ("" + d.from + (d.to ? "use `" + d.to + "` instead" : "remove it") + M4e + d.id, void 0);
    return TR(e, u), Qje(e, {
      Fragment: S.Fragment,
      components: o,
      ignoreInvalidStyle: !0,
      jsx: S.jsx,
      jsxs: S.jsxs,
      passKeys: !0,
      passNode: !0
    });
    function u(d, p, m) {
      if (d.type === "raw" && m && typeof p == "number")
        return a ? m.children.splice(p, 1) : m.children[p] = { type: "text", value: d.value }, p;
      if (d.type === "element") {
        let g;
        for (g in eE)
          if (Object.hasOwn(eE, g) && Object.hasOwn(d.properties, g)) {
            const y = d.properties[g], b = eE[g];
            (b === null || b.includes(d.tagName)) && (d.properties[g] = c(String(y || ""), g, d));
          }
      }
      if (d.type === "element") {
        let g = n ? !n.includes(d.tagName) : i ? i.includes(d.tagName) : !1;
        if (!g && r && typeof p == "number" && (g = !r(d, p, m)), g && m && typeof p == "number")
          return s && d.children ? m.children.splice(p, 1, ...d.children) : m.children.splice(p, 1), p;
      }
    }
  }
  function F4e(e) {
    const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), o = e.indexOf("/");
    return (
      // If there is no protocol, its relative.
      t === -1 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
      o !== -1 && t > o || n !== -1 && t > n || r !== -1 && t > r || // It is a protocol, it should be allowed.
      N4e.test(e.slice(0, t)) ? e : ""
    );
  }
  function P4(e, t) {
    const n = String(e);
    if (typeof t != "string")
      throw new TypeError("Expected character");
    let r = 0, o = n.indexOf(t);
    for (; o !== -1; )
      r++, o = n.indexOf(t, o + t.length);
    return r;
  }
  function L4e(e) {
    if (typeof e != "string")
      throw new TypeError("Expected a string");
    return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  }
  function z4e(e, t, n) {
    const o = B1((n || {}).ignore || []), i = B4e(t);
    let a = -1;
    for (; ++a < i.length; )
      lq(e, "text", s);
    function s(u, d) {
      let p = -1, m;
      for (; ++p < d.length; ) {
        const g = d[p], y = m ? m.children : void 0;
        if (o(
          g,
          y ? y.indexOf(g) : void 0,
          m
        ))
          return;
        m = g;
      }
      if (m)
        return c(u, d);
    }
    function c(u, d) {
      const p = d[d.length - 1], m = i[a][0], g = i[a][1];
      let y = 0;
      const v = p.children.indexOf(u);
      let x = !1, E = [];
      m.lastIndex = 0;
      let _ = m.exec(u.value);
      for (; _; ) {
        const C = _.index, k = {
          index: _.index,
          input: _.input,
          stack: [...d, u]
        };
        let A = g(..._, k);
        if (typeof A == "string" && (A = A.length > 0 ? { type: "text", value: A } : void 0), A === !1 ? m.lastIndex = C + 1 : (y !== C && E.push({
          type: "text",
          value: u.value.slice(y, C)
        }), Array.isArray(A) ? E.push(...A) : A && E.push(A), y = C + _[0].length, x = !0), !m.global)
          break;
        _ = m.exec(u.value);
      }
      return x ? (y < u.value.length && E.push({ type: "text", value: u.value.slice(y) }), p.children.splice(v, 1, ...E)) : E = [u], v + E.length;
    }
  }
  function B4e(e) {
    const t = [];
    if (!Array.isArray(e))
      throw new TypeError("Expected find and replace tuple or list of tuples");
    const n = !e[0] || Array.isArray(e[0]) ? e : [e];
    let r = -1;
    for (; ++r < n.length; ) {
      const o = n[r];
      t.push([U4e(o[0]), V4e(o[1])]);
    }
    return t;
  }
  function U4e(e) {
    return typeof e == "string" ? new RegExp(L4e(e), "g") : e;
  }
  function V4e(e) {
    return typeof e == "function" ? e : function() {
      return e;
    };
  }
  const fE = "phrasing", dE = ["autolink", "link", "image", "label"];
  function H4e() {
    return {
      transforms: [Z4e],
      enter: {
        literalAutolink: W4e,
        literalAutolinkEmail: pE,
        literalAutolinkHttp: pE,
        literalAutolinkWww: pE
      },
      exit: {
        literalAutolink: X4e,
        literalAutolinkEmail: Y4e,
        literalAutolinkHttp: G4e,
        literalAutolinkWww: K4e
      }
    };
  }
  function q4e() {
    return {
      unsafe: [
        {
          character: "@",
          before: "[+\\-.\\w]",
          after: "[\\-.\\w]",
          inConstruct: fE,
          notInConstruct: dE
        },
        {
          character: ".",
          before: "[Ww]",
          after: "[\\-.\\w]",
          inConstruct: fE,
          notInConstruct: dE
        },
        {
          character: ":",
          before: "[ps]",
          after: "\\/",
          inConstruct: fE,
          notInConstruct: dE
        }
      ]
    };
  }
  function W4e(e) {
    this.enter({ type: "link", title: null, url: "", children: [] }, e);
  }
  function pE(e) {
    this.config.enter.autolinkProtocol.call(this, e);
  }
  function G4e(e) {
    this.config.exit.autolinkProtocol.call(this, e);
  }
  function K4e(e) {
    this.config.exit.data.call(this, e);
    const t = this.stack[this.stack.length - 1];
    t.type, t.url = "http://" + this.sliceSerialize(e);
  }
  function Y4e(e) {
    this.config.exit.autolinkEmail.call(this, e);
  }
  function X4e(e) {
    this.exit(e);
  }
  function Z4e(e) {
    z4e(
      e,
      [
        [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, Q4e],
        [/(?<=^|\s|\p{P}|\p{S})([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/gu, J4e]
      ],
      { ignore: ["link", "linkReference"] }
    );
  }
  function Q4e(e, t, n, r, o) {
    let i = "";
    if (!uq(o) || (/^w/i.test(t) && (n = t + n, t = "", i = "http://"), !eFe(n)))
      return !1;
    const a = tFe(n + r);
    if (!a[0]) return !1;
    const s = {
      type: "link",
      title: null,
      url: i + t + a[0],
      children: [{ type: "text", value: t + a[0] }]
    };
    return a[1] ? [s, { type: "text", value: a[1] }] : s;
  }
  function J4e(e, t, n, r) {
    return (
      // Not an expected previous character.
      !uq(r, !0) || // Label ends in not allowed character.
      /[-\d_]$/.test(n) ? !1 : {
        type: "link",
        title: null,
        url: "mailto:" + t + "@" + n,
        children: [{ type: "text", value: t + "@" + n }]
      }
    );
  }
  function eFe(e) {
    const t = e.split(".");
    return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
  }
  function tFe(e) {
    const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
    if (!t)
      return [e, void 0];
    e = e.slice(0, t.index);
    let n = t[0], r = n.indexOf(")");
    const o = P4(e, "(");
    let i = P4(e, ")");
    for (; r !== -1 && o > i; )
      e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), i++;
    return [e, n];
  }
  function uq(e, t) {
    const n = e.input.charCodeAt(e.index - 1);
    return (e.index === 0 || Sc(n) || F1(n)) && // If its an email, the previous character should not be a slash.
    (!t || n !== 47);
  }
  fq.peek = uFe;
  function nFe() {
    this.buffer();
  }
  function rFe(e) {
    this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
  }
  function oFe() {
    this.buffer();
  }
  function iFe(e) {
    this.enter(
      { type: "footnoteDefinition", identifier: "", label: "", children: [] },
      e
    );
  }
  function aFe(e) {
    const t = this.resume(), n = this.stack[this.stack.length - 1];
    n.type, n.identifier = Jo(
      this.sliceSerialize(e)
    ).toLowerCase(), n.label = t;
  }
  function sFe(e) {
    this.exit(e);
  }
  function lFe(e) {
    const t = this.resume(), n = this.stack[this.stack.length - 1];
    n.type, n.identifier = Jo(
      this.sliceSerialize(e)
    ).toLowerCase(), n.label = t;
  }
  function cFe(e) {
    this.exit(e);
  }
  function uFe() {
    return "[";
  }
  function fq(e, t, n, r) {
    const o = n.createTracker(r);
    let i = o.move("[^");
    const a = n.enter("footnoteReference"), s = n.enter("reference");
    return i += o.move(
      n.safe(n.associationId(e), { after: "]", before: i })
    ), s(), a(), i += o.move("]"), i;
  }
  function fFe() {
    return {
      enter: {
        gfmFootnoteCallString: nFe,
        gfmFootnoteCall: rFe,
        gfmFootnoteDefinitionLabelString: oFe,
        gfmFootnoteDefinition: iFe
      },
      exit: {
        gfmFootnoteCallString: aFe,
        gfmFootnoteCall: sFe,
        gfmFootnoteDefinitionLabelString: lFe,
        gfmFootnoteDefinition: cFe
      }
    };
  }
  function dFe(e) {
    let t = !1;
    return e && e.firstLineBlank && (t = !0), {
      handlers: { footnoteDefinition: n, footnoteReference: fq },
      // This is on by default already.
      unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
    };
    function n(r, o, i, a) {
      const s = i.createTracker(a);
      let c = s.move("[^");
      const u = i.enter("footnoteDefinition"), d = i.enter("label");
      return c += s.move(
        i.safe(i.associationId(r), { before: c, after: "]" })
      ), d(), c += s.move("]:"), r.children && r.children.length > 0 && (s.shift(4), c += s.move(
        (t ? `
` : " ") + i.indentLines(
          i.containerFlow(r, s.current()),
          t ? dq : pFe
        )
      )), u(), c;
    }
  }
  function pFe(e, t, n) {
    return t === 0 ? e : dq(e, t, n);
  }
  function dq(e, t, n) {
    return (n ? "" : "    ") + e;
  }
  const hFe = [
    "autolink",
    "destinationLiteral",
    "destinationRaw",
    "reference",
    "titleQuote",
    "titleApostrophe"
  ];
  pq.peek = bFe;
  function mFe() {
    return {
      canContainEols: ["delete"],
      enter: { strikethrough: yFe },
      exit: { strikethrough: vFe }
    };
  }
  function gFe() {
    return {
      unsafe: [
        {
          character: "~",
          inConstruct: "phrasing",
          notInConstruct: hFe
        }
      ],
      handlers: { delete: pq }
    };
  }
  function yFe(e) {
    this.enter({ type: "delete", children: [] }, e);
  }
  function vFe(e) {
    this.exit(e);
  }
  function pq(e, t, n, r) {
    const o = n.createTracker(r), i = n.enter("strikethrough");
    let a = o.move("~~");
    return a += n.containerPhrasing(e, {
      ...o.current(),
      before: a,
      after: "~"
    }), a += o.move("~~"), i(), a;
  }
  function bFe() {
    return "~";
  }
  function xFe(e) {
    return e.length;
  }
  function wFe(e, t) {
    const n = t || {}, r = (n.align || []).concat(), o = n.stringLength || xFe, i = [], a = [], s = [], c = [];
    let u = 0, d = -1;
    for (; ++d < e.length; ) {
      const b = [], v = [];
      let x = -1;
      for (e[d].length > u && (u = e[d].length); ++x < e[d].length; ) {
        const E = SFe(e[d][x]);
        if (n.alignDelimiters !== !1) {
          const _ = o(E);
          v[x] = _, (c[x] === void 0 || _ > c[x]) && (c[x] = _);
        }
        b.push(E);
      }
      a[d] = b, s[d] = v;
    }
    let p = -1;
    if (typeof r == "object" && "length" in r)
      for (; ++p < u; )
        i[p] = I4(r[p]);
    else {
      const b = I4(r);
      for (; ++p < u; )
        i[p] = b;
    }
    p = -1;
    const m = [], g = [];
    for (; ++p < u; ) {
      const b = i[p];
      let v = "", x = "";
      b === 99 ? (v = ":", x = ":") : b === 108 ? v = ":" : b === 114 && (x = ":");
      let E = n.alignDelimiters === !1 ? 1 : Math.max(
        1,
        c[p] - v.length - x.length
      );
      const _ = v + "-".repeat(E) + x;
      n.alignDelimiters !== !1 && (E = v.length + E + x.length, E > c[p] && (c[p] = E), g[p] = E), m[p] = _;
    }
    a.splice(1, 0, m), s.splice(1, 0, g), d = -1;
    const y = [];
    for (; ++d < a.length; ) {
      const b = a[d], v = s[d];
      p = -1;
      const x = [];
      for (; ++p < u; ) {
        const E = b[p] || "";
        let _ = "", C = "";
        if (n.alignDelimiters !== !1) {
          const k = c[p] - (v[p] || 0), A = i[p];
          A === 114 ? _ = " ".repeat(k) : A === 99 ? k % 2 ? (_ = " ".repeat(k / 2 + 0.5), C = " ".repeat(k / 2 - 0.5)) : (_ = " ".repeat(k / 2), C = _) : C = " ".repeat(k);
        }
        n.delimiterStart !== !1 && !p && x.push("|"), n.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
        // empty: there will be a closing space.
        !(n.alignDelimiters === !1 && E === "") && (n.delimiterStart !== !1 || p) && x.push(" "), n.alignDelimiters !== !1 && x.push(_), x.push(E), n.alignDelimiters !== !1 && x.push(C), n.padding !== !1 && x.push(" "), (n.delimiterEnd !== !1 || p !== u - 1) && x.push("|");
      }
      y.push(
        n.delimiterEnd === !1 ? x.join("").replace(/ +$/, "") : x.join("")
      );
    }
    return y.join(`
`);
  }
  function SFe(e) {
    return e == null ? "" : String(e);
  }
  function I4(e) {
    const t = typeof e == "string" ? e.codePointAt(0) : 0;
    return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
  }
  function _Fe(e, t, n, r) {
    const o = n.enter("blockquote"), i = n.createTracker(r);
    i.move("> "), i.shift(2);
    const a = n.indentLines(
      n.containerFlow(e, i.current()),
      EFe
    );
    return o(), a;
  }
  function EFe(e, t, n) {
    return ">" + (n ? "" : " ") + e;
  }
  function CFe(e, t) {
    return $4(e, t.inConstruct, !0) && !$4(e, t.notInConstruct, !1);
  }
  function $4(e, t, n) {
    if (typeof t == "string" && (t = [t]), !t || t.length === 0)
      return n;
    let r = -1;
    for (; ++r < t.length; )
      if (e.includes(t[r]))
        return !0;
    return !1;
  }
  function j4(e, t, n, r) {
    let o = -1;
    for (; ++o < n.unsafe.length; )
      if (n.unsafe[o].character === `
` && CFe(n.stack, n.unsafe[o]))
        return /[ \t]/.test(r.before) ? "" : " ";
    return `\\
`;
  }
  function kFe(e, t) {
    const n = String(e);
    let r = n.indexOf(t), o = r, i = 0, a = 0;
    if (typeof t != "string")
      throw new TypeError("Expected substring");
    for (; r !== -1; )
      r === o ? ++i > a && (a = i) : i = 1, o = r + t.length, r = n.indexOf(t, o);
    return a;
  }
  function TFe(e, t) {
    return !!(t.options.fences === !1 && e.value && // If theres no info
    !e.lang && // And theres a non-whitespace character
    /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
  }
  function AFe(e) {
    const t = e.options.fence || "`";
    if (t !== "`" && t !== "~")
      throw new Error(
        "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
      );
    return t;
  }
  function RFe(e, t, n, r) {
    const o = AFe(n), i = e.value || "", a = o === "`" ? "GraveAccent" : "Tilde";
    if (TFe(e, n)) {
      const p = n.enter("codeIndented"), m = n.indentLines(i, OFe);
      return p(), m;
    }
    const s = n.createTracker(r), c = o.repeat(Math.max(kFe(i, o) + 1, 3)), u = n.enter("codeFenced");
    let d = s.move(c);
    if (e.lang) {
      const p = n.enter(`codeFencedLang${a}`);
      d += s.move(
        n.safe(e.lang, {
          before: d,
          after: " ",
          encode: ["`"],
          ...s.current()
        })
      ), p();
    }
    if (e.lang && e.meta) {
      const p = n.enter(`codeFencedMeta${a}`);
      d += s.move(" "), d += s.move(
        n.safe(e.meta, {
          before: d,
          after: `
`,
          encode: ["`"],
          ...s.current()
        })
      ), p();
    }
    return d += s.move(`
`), i && (d += s.move(i + `
`)), d += s.move(c), u(), d;
  }
  function OFe(e, t, n) {
    return (n ? "" : "    ") + e;
  }
  function RR(e) {
    const t = e.options.quote || '"';
    if (t !== '"' && t !== "'")
      throw new Error(
        "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
      );
    return t;
  }
  function MFe(e, t, n, r) {
    const o = RR(n), i = o === '"' ? "Quote" : "Apostrophe", a = n.enter("definition");
    let s = n.enter("label");
    const c = n.createTracker(r);
    let u = c.move("[");
    return u += c.move(
      n.safe(n.associationId(e), {
        before: u,
        after: "]",
        ...c.current()
      })
    ), u += c.move("]: "), s(), // If theres no url, or
    !e.url || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"), u += c.move("<"), u += c.move(
      n.safe(e.url, { before: u, after: ">", ...c.current() })
    ), u += c.move(">")) : (s = n.enter("destinationRaw"), u += c.move(
      n.safe(e.url, {
        before: u,
        after: e.title ? " " : `
`,
        ...c.current()
      })
    )), s(), e.title && (s = n.enter(`title${i}`), u += c.move(" " + o), u += c.move(
      n.safe(e.title, {
        before: u,
        after: o,
        ...c.current()
      })
    ), u += c.move(o), s()), a(), u;
  }
  function NFe(e) {
    const t = e.options.emphasis || "*";
    if (t !== "*" && t !== "_")
      throw new Error(
        "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
      );
    return t;
  }
  function Rh(e) {
    return "&#x" + e.toString(16).toUpperCase() + ";";
  }
  function X0(e, t, n) {
    const r = Nf(e), o = Nf(t);
    return r === void 0 ? o === void 0 ? (
      // Letter inside:
      // we have to encode *both* letters for `_` as it is looser.
      // it already forms for `*` (and GFMs `~`).
      n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
    ) : o === 1 ? (
      // Whitespace inside: encode both (letter, whitespace).
      { inside: !0, outside: !0 }
    ) : (
      // Punctuation inside: encode outer (letter)
      { inside: !1, outside: !0 }
    ) : r === 1 ? o === void 0 ? (
      // Letter inside: already forms.
      { inside: !1, outside: !1 }
    ) : o === 1 ? (
      // Whitespace inside: encode both (whitespace).
      { inside: !0, outside: !0 }
    ) : (
      // Punctuation inside: already forms.
      { inside: !1, outside: !1 }
    ) : o === void 0 ? (
      // Letter inside: already forms.
      { inside: !1, outside: !1 }
    ) : o === 1 ? (
      // Whitespace inside: encode inner (whitespace).
      { inside: !0, outside: !1 }
    ) : (
      // Punctuation inside: already forms.
      { inside: !1, outside: !1 }
    );
  }
  hq.peek = PFe;
  function hq(e, t, n, r) {
    const o = NFe(n), i = n.enter("emphasis"), a = n.createTracker(r), s = a.move(o);
    let c = a.move(
      n.containerPhrasing(e, {
        after: o,
        before: s,
        ...a.current()
      })
    );
    const u = c.charCodeAt(0), d = X0(
      r.before.charCodeAt(r.before.length - 1),
      u,
      o
    );
    d.inside && (c = Rh(u) + c.slice(1));
    const p = c.charCodeAt(c.length - 1), m = X0(r.after.charCodeAt(0), p, o);
    m.inside && (c = c.slice(0, -1) + Rh(p));
    const g = a.move(o);
    return i(), n.attentionEncodeSurroundingInfo = {
      after: m.outside,
      before: d.outside
    }, s + c + g;
  }
  function PFe(e, t, n) {
    return n.options.emphasis || "*";
  }
  function IFe(e, t) {
    let n = !1;
    return TR(e, function(r) {
      if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
        return n = !0, JC;
    }), !!((!e.depth || e.depth < 3) && xR(e) && (t.options.setext || n));
  }
  function $Fe(e, t, n, r) {
    const o = Math.max(Math.min(6, e.depth || 1), 1), i = n.createTracker(r);
    if (IFe(e, n)) {
      const d = n.enter("headingSetext"), p = n.enter("phrasing"), m = n.containerPhrasing(e, {
        ...i.current(),
        before: `
`,
        after: `
`
      });
      return p(), d(), m + `
` + (o === 1 ? "=" : "-").repeat(
        // The whole size
        m.length - // Minus the position of the character after the last EOL (or
        // 0 if there is none)
        (Math.max(m.lastIndexOf("\r"), m.lastIndexOf(`
`)) + 1)
      );
    }
    const a = "#".repeat(o), s = n.enter("headingAtx"), c = n.enter("phrasing");
    i.move(a + " ");
    let u = n.containerPhrasing(e, {
      before: "# ",
      after: `
`,
      ...i.current()
    });
    return /^[\t ]/.test(u) && (u = Rh(u.charCodeAt(0)) + u.slice(1)), u = u ? a + " " + u : a, n.options.closeAtx && (u += " " + a), c(), s(), u;
  }
  mq.peek = jFe;
  function mq(e) {
    return e.value || "";
  }
  function jFe() {
    return "<";
  }
  gq.peek = DFe;
  function gq(e, t, n, r) {
    const o = RR(n), i = o === '"' ? "Quote" : "Apostrophe", a = n.enter("image");
    let s = n.enter("label");
    const c = n.createTracker(r);
    let u = c.move("![");
    return u += c.move(
      n.safe(e.alt, { before: u, after: "]", ...c.current() })
    ), u += c.move("]("), s(), // If theres no url but there is a title
    !e.url && e.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"), u += c.move("<"), u += c.move(
      n.safe(e.url, { before: u, after: ">", ...c.current() })
    ), u += c.move(">")) : (s = n.enter("destinationRaw"), u += c.move(
      n.safe(e.url, {
        before: u,
        after: e.title ? " " : ")",
        ...c.current()
      })
    )), s(), e.title && (s = n.enter(`title${i}`), u += c.move(" " + o), u += c.move(
      n.safe(e.title, {
        before: u,
        after: o,
        ...c.current()
      })
    ), u += c.move(o), s()), u += c.move(")"), a(), u;
  }
  function DFe() {
    return "!";
  }
  yq.peek = FFe;
  function yq(e, t, n, r) {
    const o = e.referenceType, i = n.enter("imageReference");
    let a = n.enter("label");
    const s = n.createTracker(r);
    let c = s.move("![");
    const u = n.safe(e.alt, {
      before: c,
      after: "]",
      ...s.current()
    });
    c += s.move(u + "]["), a();
    const d = n.stack;
    n.stack = [], a = n.enter("reference");
    const p = n.safe(n.associationId(e), {
      before: c,
      after: "]",
      ...s.current()
    });
    return a(), n.stack = d, i(), o === "full" || !u || u !== p ? c += s.move(p + "]") : o === "shortcut" ? c = c.slice(0, -1) : c += s.move("]"), c;
  }
  function FFe() {
    return "!";
  }
  vq.peek = LFe;
  function vq(e, t, n) {
    let r = e.value || "", o = "`", i = -1;
    for (; new RegExp("(^|[^`])" + o + "([^`]|$)").test(r); )
      o += "`";
    for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++i < n.unsafe.length; ) {
      const a = n.unsafe[i], s = n.compilePattern(a);
      let c;
      if (a.atBreak)
        for (; c = s.exec(r); ) {
          let u = c.index;
          r.charCodeAt(u) === 10 && r.charCodeAt(u - 1) === 13 && u--, r = r.slice(0, u) + " " + r.slice(c.index + 1);
        }
    }
    return o + r + o;
  }
  function LFe() {
    return "`";
  }
  function bq(e, t) {
    const n = xR(e);
    return !!(!t.options.resourceLink && // If theres a url
    e.url && // And theres a no title
    !e.title && // And the content of `node` is a single text node
    e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
    (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol
    /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
    // references dont work), space, or angle brackets
    !/[\0- <>\u007F]/.test(e.url));
  }
  xq.peek = zFe;
  function xq(e, t, n, r) {
    const o = RR(n), i = o === '"' ? "Quote" : "Apostrophe", a = n.createTracker(r);
    let s, c;
    if (bq(e, n)) {
      const d = n.stack;
      n.stack = [], s = n.enter("autolink");
      let p = a.move("<");
      return p += a.move(
        n.containerPhrasing(e, {
          before: p,
          after: ">",
          ...a.current()
        })
      ), p += a.move(">"), s(), n.stack = d, p;
    }
    s = n.enter("link"), c = n.enter("label");
    let u = a.move("[");
    return u += a.move(
      n.containerPhrasing(e, {
        before: u,
        after: "](",
        ...a.current()
      })
    ), u += a.move("]("), c(), // If theres no url but there is a title
    !e.url && e.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(e.url) ? (c = n.enter("destinationLiteral"), u += a.move("<"), u += a.move(
      n.safe(e.url, { before: u, after: ">", ...a.current() })
    ), u += a.move(">")) : (c = n.enter("destinationRaw"), u += a.move(
      n.safe(e.url, {
        before: u,
        after: e.title ? " " : ")",
        ...a.current()
      })
    )), c(), e.title && (c = n.enter(`title${i}`), u += a.move(" " + o), u += a.move(
      n.safe(e.title, {
        before: u,
        after: o,
        ...a.current()
      })
    ), u += a.move(o), c()), u += a.move(")"), s(), u;
  }
  function zFe(e, t, n) {
    return bq(e, n) ? "<" : "[";
  }
  wq.peek = BFe;
  function wq(e, t, n, r) {
    const o = e.referenceType, i = n.enter("linkReference");
    let a = n.enter("label");
    const s = n.createTracker(r);
    let c = s.move("[");
    const u = n.containerPhrasing(e, {
      before: c,
      after: "]",
      ...s.current()
    });
    c += s.move(u + "]["), a();
    const d = n.stack;
    n.stack = [], a = n.enter("reference");
    const p = n.safe(n.associationId(e), {
      before: c,
      after: "]",
      ...s.current()
    });
    return a(), n.stack = d, i(), o === "full" || !u || u !== p ? c += s.move(p + "]") : o === "shortcut" ? c = c.slice(0, -1) : c += s.move("]"), c;
  }
  function BFe() {
    return "[";
  }
  function OR(e) {
    const t = e.options.bullet || "*";
    if (t !== "*" && t !== "+" && t !== "-")
      throw new Error(
        "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
      );
    return t;
  }
  function UFe(e) {
    const t = OR(e), n = e.options.bulletOther;
    if (!n)
      return t === "*" ? "-" : "*";
    if (n !== "*" && n !== "+" && n !== "-")
      throw new Error(
        "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
      );
    if (n === t)
      throw new Error(
        "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
      );
    return n;
  }
  function VFe(e) {
    const t = e.options.bulletOrdered || ".";
    if (t !== "." && t !== ")")
      throw new Error(
        "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
      );
    return t;
  }
  function Sq(e) {
    const t = e.options.rule || "*";
    if (t !== "*" && t !== "-" && t !== "_")
      throw new Error(
        "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
      );
    return t;
  }
  function HFe(e, t, n, r) {
    const o = n.enter("list"), i = n.bulletCurrent;
    let a = e.ordered ? VFe(n) : OR(n);
    const s = e.ordered ? a === "." ? ")" : "." : UFe(n);
    let c = t && n.bulletLastUsed ? a === n.bulletLastUsed : !1;
    if (!e.ordered) {
      const d = e.children ? e.children[0] : void 0;
      if (
        // Bullet could be used as a thematic break marker:
        (a === "*" || a === "-") && // Empty first list item:
        d && (!d.children || !d.children[0]) && // Directly in two other list items:
        n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
        n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (c = !0), Sq(n) === a && d
      ) {
        let p = -1;
        for (; ++p < e.children.length; ) {
          const m = e.children[p];
          if (m && m.type === "listItem" && m.children && m.children[0] && m.children[0].type === "thematicBreak") {
            c = !0;
            break;
          }
        }
      }
    }
    c && (a = s), n.bulletCurrent = a;
    const u = n.containerFlow(e, r);
    return n.bulletLastUsed = a, n.bulletCurrent = i, o(), u;
  }
  function qFe(e) {
    const t = e.options.listItemIndent || "one";
    if (t !== "tab" && t !== "one" && t !== "mixed")
      throw new Error(
        "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
      );
    return t;
  }
  function WFe(e, t, n, r) {
    const o = qFe(n);
    let i = n.bulletCurrent || OR(n);
    t && t.type === "list" && t.ordered && (i = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + i);
    let a = i.length + 1;
    (o === "tab" || o === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (a = Math.ceil(a / 4) * 4);
    const s = n.createTracker(r);
    s.move(i + " ".repeat(a - i.length)), s.shift(a);
    const c = n.enter("listItem"), u = n.indentLines(
      n.containerFlow(e, s.current()),
      d
    );
    return c(), u;
    function d(p, m, g) {
      return m ? (g ? "" : " ".repeat(a)) + p : (g ? i : i + " ".repeat(a - i.length)) + p;
    }
  }
  function GFe(e, t, n, r) {
    const o = n.enter("paragraph"), i = n.enter("phrasing"), a = n.containerPhrasing(e, r);
    return i(), o(), a;
  }
  const KFe = (
    /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
    B1([
      "break",
      "delete",
      "emphasis",
      // To do: next major: removed since footnotes were added to GFM.
      "footnote",
      "footnoteReference",
      "image",
      "imageReference",
      "inlineCode",
      // Enabled by `mdast-util-math`:
      "inlineMath",
      "link",
      "linkReference",
      // Enabled by `mdast-util-mdx`:
      "mdxJsxTextElement",
      // Enabled by `mdast-util-mdx`:
      "mdxTextExpression",
      "strong",
      "text",
      // Enabled by `mdast-util-directive`:
      "textDirective"
    ])
  );
  function YFe(e, t, n, r) {
    return (e.children.some(function(a) {
      return KFe(a);
    }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
  }
  function XFe(e) {
    const t = e.options.strong || "*";
    if (t !== "*" && t !== "_")
      throw new Error(
        "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
      );
    return t;
  }
  _q.peek = ZFe;
  function _q(e, t, n, r) {
    const o = XFe(n), i = n.enter("strong"), a = n.createTracker(r), s = a.move(o + o);
    let c = a.move(
      n.containerPhrasing(e, {
        after: o,
        before: s,
        ...a.current()
      })
    );
    const u = c.charCodeAt(0), d = X0(
      r.before.charCodeAt(r.before.length - 1),
      u,
      o
    );
    d.inside && (c = Rh(u) + c.slice(1));
    const p = c.charCodeAt(c.length - 1), m = X0(r.after.charCodeAt(0), p, o);
    m.inside && (c = c.slice(0, -1) + Rh(p));
    const g = a.move(o + o);
    return i(), n.attentionEncodeSurroundingInfo = {
      after: m.outside,
      before: d.outside
    }, s + c + g;
  }
  function ZFe(e, t, n) {
    return n.options.strong || "*";
  }
  function QFe(e, t, n, r) {
    return n.safe(e.value, r);
  }
  function JFe(e) {
    const t = e.options.ruleRepetition || 3;
    if (t < 3)
      throw new Error(
        "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
      );
    return t;
  }
  function eLe(e, t, n) {
    const r = (Sq(n) + (n.options.ruleSpaces ? " " : "")).repeat(JFe(n));
    return n.options.ruleSpaces ? r.slice(0, -1) : r;
  }
  const Eq = {
    blockquote: _Fe,
    break: j4,
    code: RFe,
    definition: MFe,
    emphasis: hq,
    hardBreak: j4,
    heading: $Fe,
    html: mq,
    image: gq,
    imageReference: yq,
    inlineCode: vq,
    link: xq,
    linkReference: wq,
    list: HFe,
    listItem: WFe,
    paragraph: GFe,
    root: YFe,
    strong: _q,
    text: QFe,
    thematicBreak: eLe
  };
  function tLe() {
    return {
      enter: {
        table: nLe,
        tableData: D4,
        tableHeader: D4,
        tableRow: oLe
      },
      exit: {
        codeText: iLe,
        table: rLe,
        tableData: hE,
        tableHeader: hE,
        tableRow: hE
      }
    };
  }
  function nLe(e) {
    const t = e._align;
    this.enter(
      {
        type: "table",
        align: t.map(function(n) {
          return n === "none" ? null : n;
        }),
        children: []
      },
      e
    ), this.data.inTable = !0;
  }
  function rLe(e) {
    this.exit(e), this.data.inTable = void 0;
  }
  function oLe(e) {
    this.enter({ type: "tableRow", children: [] }, e);
  }
  function hE(e) {
    this.exit(e);
  }
  function D4(e) {
    this.enter({ type: "tableCell", children: [] }, e);
  }
  function iLe(e) {
    let t = this.resume();
    this.data.inTable && (t = t.replace(/\\([\\|])/g, aLe));
    const n = this.stack[this.stack.length - 1];
    n.type, n.value = t, this.exit(e);
  }
  function aLe(e, t) {
    return t === "|" ? t : e;
  }
  function sLe(e) {
    const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, o = t.stringLength, i = n ? " " : "|";
    return {
      unsafe: [
        { character: "\r", inConstruct: "tableCell" },
        { character: `
`, inConstruct: "tableCell" },
        // A pipe, when followed by a tab or space (padding), or a dash or colon
        // (unpadded delimiter row), could result in a table.
        { atBreak: !0, character: "|", after: "[	 :-]" },
        // A pipe in a cell must be encoded.
        { character: "|", inConstruct: "tableCell" },
        // A colon must be followed by a dash, in which case it could start a
        // delimiter row.
        { atBreak: !0, character: ":", after: "-" },
        // A delimiter row can also start with a dash, when followed by more
        // dashes, a colon, or a pipe.
        // This is a stricter version than the built in check for lists, thematic
        // breaks, and setex heading underlines though:
        // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
        { atBreak: !0, character: "-", after: "[:|-]" }
      ],
      handlers: {
        inlineCode: m,
        table: a,
        tableCell: c,
        tableRow: s
      }
    };
    function a(g, y, b, v) {
      return u(d(g, b, v), g.align);
    }
    function s(g, y, b, v) {
      const x = p(g, b, v), E = u([x]);
      return E.slice(0, E.indexOf(`
`));
    }
    function c(g, y, b, v) {
      const x = b.enter("tableCell"), E = b.enter("phrasing"), _ = b.containerPhrasing(g, {
        ...v,
        before: i,
        after: i
      });
      return E(), x(), _;
    }
    function u(g, y) {
      return wFe(g, {
        align: y,
        // @ts-expect-error: `markdown-table` types should support `null`.
        alignDelimiters: r,
        // @ts-expect-error: `markdown-table` types should support `null`.
        padding: n,
        // @ts-expect-error: `markdown-table` types should support `null`.
        stringLength: o
      });
    }
    function d(g, y, b) {
      const v = g.children;
      let x = -1;
      const E = [], _ = y.enter("table");
      for (; ++x < v.length; )
        E[x] = p(v[x], y, b);
      return _(), E;
    }
    function p(g, y, b) {
      const v = g.children;
      let x = -1;
      const E = [], _ = y.enter("tableRow");
      for (; ++x < v.length; )
        E[x] = c(v[x], g, y, b);
      return _(), E;
    }
    function m(g, y, b) {
      let v = Eq.inlineCode(g, y, b);
      return b.stack.includes("tableCell") && (v = v.replace(/\|/g, "\\$&")), v;
    }
  }
  function lLe() {
    return {
      exit: {
        taskListCheckValueChecked: F4,
        taskListCheckValueUnchecked: F4,
        paragraph: uLe
      }
    };
  }
  function cLe() {
    return {
      unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
      handlers: { listItem: fLe }
    };
  }
  function F4(e) {
    const t = this.stack[this.stack.length - 2];
    t.type, t.checked = e.type === "taskListCheckValueChecked";
  }
  function uLe(e) {
    const t = this.stack[this.stack.length - 2];
    if (t && t.type === "listItem" && typeof t.checked == "boolean") {
      const n = this.stack[this.stack.length - 1];
      n.type;
      const r = n.children[0];
      if (r && r.type === "text") {
        const o = t.children;
        let i = -1, a;
        for (; ++i < o.length; ) {
          const s = o[i];
          if (s.type === "paragraph") {
            a = s;
            break;
          }
        }
        a === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
      }
    }
    this.exit(e);
  }
  function fLe(e, t, n, r) {
    const o = e.children[0], i = typeof e.checked == "boolean" && o && o.type === "paragraph", a = "[" + (e.checked ? "x" : " ") + "] ", s = n.createTracker(r);
    i && s.move(a);
    let c = Eq.listItem(e, t, n, {
      ...r,
      ...s.current()
    });
    return i && (c = c.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, u)), c;
    function u(d) {
      return d + a;
    }
  }
  function dLe() {
    return [
      H4e(),
      fFe(),
      mFe(),
      tLe(),
      lLe()
    ];
  }
  function pLe(e) {
    return {
      extensions: [
        q4e(),
        dFe(e),
        gFe(),
        sLe(e),
        cLe()
      ]
    };
  }
  const hLe = {
    tokenize: xLe,
    partial: !0
  }, Cq = {
    tokenize: wLe,
    partial: !0
  }, kq = {
    tokenize: SLe,
    partial: !0
  }, Tq = {
    tokenize: _Le,
    partial: !0
  }, mLe = {
    tokenize: ELe,
    partial: !0
  }, Aq = {
    name: "wwwAutolink",
    tokenize: vLe,
    previous: Oq
  }, Rq = {
    name: "protocolAutolink",
    tokenize: bLe,
    previous: Mq
  }, ss = {
    name: "emailAutolink",
    tokenize: yLe,
    previous: Nq
  }, oa = {};
  function gLe() {
    return {
      text: oa
    };
  }
  let Gl = 48;
  for (; Gl < 123; )
    oa[Gl] = ss, Gl++, Gl === 58 ? Gl = 65 : Gl === 91 && (Gl = 97);
  oa[43] = ss;
  oa[45] = ss;
  oa[46] = ss;
  oa[95] = ss;
  oa[72] = [ss, Rq];
  oa[104] = [ss, Rq];
  oa[87] = [ss, Aq];
  oa[119] = [ss, Aq];
  function yLe(e, t, n) {
    const r = this;
    let o, i;
    return a;
    function a(p) {
      return !rk(p) || !Nq.call(r, r.previous) || MR(r.events) ? n(p) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), s(p));
    }
    function s(p) {
      return rk(p) ? (e.consume(p), s) : p === 64 ? (e.consume(p), c) : n(p);
    }
    function c(p) {
      return p === 46 ? e.check(mLe, d, u)(p) : p === 45 || p === 95 || br(p) ? (i = !0, e.consume(p), c) : d(p);
    }
    function u(p) {
      return e.consume(p), o = !0, c;
    }
    function d(p) {
      return i && o && Tr(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(p)) : n(p);
    }
  }
  function vLe(e, t, n) {
    const r = this;
    return o;
    function o(a) {
      return a !== 87 && a !== 119 || !Oq.call(r, r.previous) || MR(r.events) ? n(a) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(hLe, e.attempt(Cq, e.attempt(kq, i), n), n)(a));
    }
    function i(a) {
      return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(a);
    }
  }
  function bLe(e, t, n) {
    const r = this;
    let o = "", i = !1;
    return a;
    function a(p) {
      return (p === 72 || p === 104) && Mq.call(r, r.previous) && !MR(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), o += String.fromCodePoint(p), e.consume(p), s) : n(p);
    }
    function s(p) {
      if (Tr(p) && o.length < 5)
        return o += String.fromCodePoint(p), e.consume(p), s;
      if (p === 58) {
        const m = o.toLowerCase();
        if (m === "http" || m === "https")
          return e.consume(p), c;
      }
      return n(p);
    }
    function c(p) {
      return p === 47 ? (e.consume(p), i ? u : (i = !0, c)) : n(p);
    }
    function u(p) {
      return p === null || G0(p) || cn(p) || Sc(p) || F1(p) ? n(p) : e.attempt(Cq, e.attempt(kq, d), n)(p);
    }
    function d(p) {
      return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(p);
    }
  }
  function xLe(e, t, n) {
    let r = 0;
    return o;
    function o(a) {
      return (a === 87 || a === 119) && r < 3 ? (r++, e.consume(a), o) : a === 46 && r === 3 ? (e.consume(a), i) : n(a);
    }
    function i(a) {
      return a === null ? n(a) : t(a);
    }
  }
  function wLe(e, t, n) {
    let r, o, i;
    return a;
    function a(u) {
      return u === 46 || u === 95 ? e.check(Tq, c, s)(u) : u === null || cn(u) || Sc(u) || u !== 45 && F1(u) ? c(u) : (i = !0, e.consume(u), a);
    }
    function s(u) {
      return u === 95 ? r = !0 : (o = r, r = void 0), e.consume(u), a;
    }
    function c(u) {
      return o || r || !i ? n(u) : t(u);
    }
  }
  function SLe(e, t) {
    let n = 0, r = 0;
    return o;
    function o(a) {
      return a === 40 ? (n++, e.consume(a), o) : a === 41 && r < n ? i(a) : a === 33 || a === 34 || a === 38 || a === 39 || a === 41 || a === 42 || a === 44 || a === 46 || a === 58 || a === 59 || a === 60 || a === 63 || a === 93 || a === 95 || a === 126 ? e.check(Tq, t, i)(a) : a === null || cn(a) || Sc(a) ? t(a) : (e.consume(a), o);
    }
    function i(a) {
      return a === 41 && r++, e.consume(a), o;
    }
  }
  function _Le(e, t, n) {
    return r;
    function r(s) {
      return s === 33 || s === 34 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 63 || s === 95 || s === 126 ? (e.consume(s), r) : s === 38 ? (e.consume(s), i) : s === 93 ? (e.consume(s), o) : (
        // `<` is an end.
        s === 60 || // So is whitespace.
        s === null || cn(s) || Sc(s) ? t(s) : n(s)
      );
    }
    function o(s) {
      return s === null || s === 40 || s === 91 || cn(s) || Sc(s) ? t(s) : r(s);
    }
    function i(s) {
      return Tr(s) ? a(s) : n(s);
    }
    function a(s) {
      return s === 59 ? (e.consume(s), r) : Tr(s) ? (e.consume(s), a) : n(s);
    }
  }
  function ELe(e, t, n) {
    return r;
    function r(i) {
      return e.consume(i), o;
    }
    function o(i) {
      return br(i) ? n(i) : t(i);
    }
  }
  function Oq(e) {
    return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || cn(e);
  }
  function Mq(e) {
    return !Tr(e);
  }
  function Nq(e) {
    return !(e === 47 || rk(e));
  }
  function rk(e) {
    return e === 43 || e === 45 || e === 46 || e === 95 || br(e);
  }
  function MR(e) {
    let t = e.length, n = !1;
    for (; t--; ) {
      const r = e[t][1];
      if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
        n = !0;
        break;
      }
      if (r._gfmAutolinkLiteralWalkedInto) {
        n = !1;
        break;
      }
    }
    return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
  }
  const CLe = {
    tokenize: PLe,
    partial: !0
  };
  function kLe() {
    return {
      document: {
        91: {
          name: "gfmFootnoteDefinition",
          tokenize: OLe,
          continuation: {
            tokenize: MLe
          },
          exit: NLe
        }
      },
      text: {
        91: {
          name: "gfmFootnoteCall",
          tokenize: RLe
        },
        93: {
          name: "gfmPotentialFootnoteCall",
          add: "after",
          tokenize: TLe,
          resolveTo: ALe
        }
      }
    };
  }
  function TLe(e, t, n) {
    const r = this;
    let o = r.events.length;
    const i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
    let a;
    for (; o--; ) {
      const c = r.events[o][1];
      if (c.type === "labelImage") {
        a = c;
        break;
      }
      if (c.type === "gfmFootnoteCall" || c.type === "labelLink" || c.type === "label" || c.type === "image" || c.type === "link")
        break;
    }
    return s;
    function s(c) {
      if (!a || !a._balanced)
        return n(c);
      const u = Jo(r.sliceSerialize({
        start: a.end,
        end: r.now()
      }));
      return u.codePointAt(0) !== 94 || !i.includes(u.slice(1)) ? n(c) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(c), e.exit("gfmFootnoteCallLabelMarker"), t(c));
    }
  }
  function ALe(e, t) {
    let n = e.length;
    for (; n--; )
      if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
        e[n][1];
        break;
      }
    e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
    const r = {
      type: "gfmFootnoteCall",
      start: Object.assign({}, e[n + 3][1].start),
      end: Object.assign({}, e[e.length - 1][1].end)
    }, o = {
      type: "gfmFootnoteCallMarker",
      start: Object.assign({}, e[n + 3][1].end),
      end: Object.assign({}, e[n + 3][1].end)
    };
    o.end.column++, o.end.offset++, o.end._bufferIndex++;
    const i = {
      type: "gfmFootnoteCallString",
      start: Object.assign({}, o.end),
      end: Object.assign({}, e[e.length - 1][1].start)
    }, a = {
      type: "chunkString",
      contentType: "string",
      start: Object.assign({}, i.start),
      end: Object.assign({}, i.end)
    }, s = [
      // Take the `labelImageMarker` (now `data`, the `!`)
      e[n + 1],
      e[n + 2],
      ["enter", r, t],
      // The `[`
      e[n + 3],
      e[n + 4],
      // The `^`.
      ["enter", o, t],
      ["exit", o, t],
      // Everything in between.
      ["enter", i, t],
      ["enter", a, t],
      ["exit", a, t],
      ["exit", i, t],
      // The ending (`]`, properly parsed and labelled).
      e[e.length - 2],
      e[e.length - 1],
      ["exit", r, t]
    ];
    return e.splice(n, e.length - n + 1, ...s), e;
  }
  function RLe(e, t, n) {
    const r = this, o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
    let i = 0, a;
    return s;
    function s(p) {
      return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), c;
    }
    function c(p) {
      return p !== 94 ? n(p) : (e.enter("gfmFootnoteCallMarker"), e.consume(p), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", u);
    }
    function u(p) {
      if (
        // Too long.
        i > 999 || // Closing brace with nothing.
        p === 93 && !a || // Space or tab is not supported by GFM for some reason.
        // `\n` and `[` not being supported makes sense.
        p === null || p === 91 || cn(p)
      )
        return n(p);
      if (p === 93) {
        e.exit("chunkString");
        const m = e.exit("gfmFootnoteCallString");
        return o.includes(Jo(r.sliceSerialize(m))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(p);
      }
      return cn(p) || (a = !0), i++, e.consume(p), p === 92 ? d : u;
    }
    function d(p) {
      return p === 91 || p === 92 || p === 93 ? (e.consume(p), i++, u) : u(p);
    }
  }
  function OLe(e, t, n) {
    const r = this, o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
    let i, a = 0, s;
    return c;
    function c(y) {
      return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(y), e.exit("gfmFootnoteDefinitionLabelMarker"), u;
    }
    function u(y) {
      return y === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(y), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", d) : n(y);
    }
    function d(y) {
      if (
        // Too long.
        a > 999 || // Closing brace with nothing.
        y === 93 && !s || // Space or tab is not supported by GFM for some reason.
        // `\n` and `[` not being supported makes sense.
        y === null || y === 91 || cn(y)
      )
        return n(y);
      if (y === 93) {
        e.exit("chunkString");
        const b = e.exit("gfmFootnoteDefinitionLabelString");
        return i = Jo(r.sliceSerialize(b)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(y), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), m;
      }
      return cn(y) || (s = !0), a++, e.consume(y), y === 92 ? p : d;
    }
    function p(y) {
      return y === 91 || y === 92 || y === 93 ? (e.consume(y), a++, d) : d(y);
    }
    function m(y) {
      return y === 58 ? (e.enter("definitionMarker"), e.consume(y), e.exit("definitionMarker"), o.includes(i) || o.push(i), Pt(e, g, "gfmFootnoteDefinitionWhitespace")) : n(y);
    }
    function g(y) {
      return t(y);
    }
  }
  function MLe(e, t, n) {
    return e.check(Sm, t, e.attempt(CLe, t, n));
  }
  function NLe(e) {
    e.exit("gfmFootnoteDefinition");
  }
  function PLe(e, t, n) {
    const r = this;
    return Pt(e, o, "gfmFootnoteDefinitionIndent", 5);
    function o(i) {
      const a = r.events[r.events.length - 1];
      return a && a[1].type === "gfmFootnoteDefinitionIndent" && a[2].sliceSerialize(a[1], !0).length === 4 ? t(i) : n(i);
    }
  }
  function ILe(e) {
    let n = (e || {}).singleTilde;
    const r = {
      name: "strikethrough",
      tokenize: i,
      resolveAll: o
    };
    return n == null && (n = !0), {
      text: {
        126: r
      },
      insideSpan: {
        null: [r]
      },
      attentionMarkers: {
        null: [126]
      }
    };
    function o(a, s) {
      let c = -1;
      for (; ++c < a.length; )
        if (a[c][0] === "enter" && a[c][1].type === "strikethroughSequenceTemporary" && a[c][1]._close) {
          let u = c;
          for (; u--; )
            if (a[u][0] === "exit" && a[u][1].type === "strikethroughSequenceTemporary" && a[u][1]._open && // If the sizes are the same:
            a[c][1].end.offset - a[c][1].start.offset === a[u][1].end.offset - a[u][1].start.offset) {
              a[c][1].type = "strikethroughSequence", a[u][1].type = "strikethroughSequence";
              const d = {
                type: "strikethrough",
                start: Object.assign({}, a[u][1].start),
                end: Object.assign({}, a[c][1].end)
              }, p = {
                type: "strikethroughText",
                start: Object.assign({}, a[u][1].end),
                end: Object.assign({}, a[c][1].start)
              }, m = [["enter", d, s], ["enter", a[u][1], s], ["exit", a[u][1], s], ["enter", p, s]], g = s.parser.constructs.insideSpan.null;
              g && uo(m, m.length, 0, L1(g, a.slice(u + 1, c), s)), uo(m, m.length, 0, [["exit", p, s], ["enter", a[c][1], s], ["exit", a[c][1], s], ["exit", d, s]]), uo(a, u - 1, c - u + 3, m), c = u + m.length - 2;
              break;
            }
        }
      for (c = -1; ++c < a.length; )
        a[c][1].type === "strikethroughSequenceTemporary" && (a[c][1].type = "data");
      return a;
    }
    function i(a, s, c) {
      const u = this.previous, d = this.events;
      let p = 0;
      return m;
      function m(y) {
        return u === 126 && d[d.length - 1][1].type !== "characterEscape" ? c(y) : (a.enter("strikethroughSequenceTemporary"), g(y));
      }
      function g(y) {
        const b = Nf(u);
        if (y === 126)
          return p > 1 ? c(y) : (a.consume(y), p++, g);
        if (p < 2 && !n) return c(y);
        const v = a.exit("strikethroughSequenceTemporary"), x = Nf(y);
        return v._open = !x || x === 2 && !!b, v._close = !b || b === 2 && !!x, s(y);
      }
    }
  }
  class $Le {
    /**
     * Create a new edit map.
     */
    constructor() {
      this.map = [];
    }
    /**
     * Create an edit: a remove and/or add at a certain place.
     *
     * @param {number} index
     * @param {number} remove
     * @param {Array<Event>} add
     * @returns {undefined}
     */
    add(t, n, r) {
      jLe(this, t, n, r);
    }
    // To do: add this when moving to `micromark`.
    // /**
    //  * Create an edit: but insert `add` before existing additions.
    //  *
    //  * @param {number} index
    //  * @param {number} remove
    //  * @param {Array<Event>} add
    //  * @returns {undefined}
    //  */
    // addBefore(index, remove, add) {
    //   addImplementation(this, index, remove, add, true)
    // }
    /**
     * Done, change the events.
     *
     * @param {Array<Event>} events
     * @returns {undefined}
     */
    consume(t) {
      if (this.map.sort(function(i, a) {
        return i[0] - a[0];
      }), this.map.length === 0)
        return;
      let n = this.map.length;
      const r = [];
      for (; n > 0; )
        n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
      r.push(t.slice()), t.length = 0;
      let o = r.pop();
      for (; o; ) {
        for (const i of o)
          t.push(i);
        o = r.pop();
      }
      this.map.length = 0;
    }
  }
  function jLe(e, t, n, r) {
    let o = 0;
    if (!(n === 0 && r.length === 0)) {
      for (; o < e.map.length; ) {
        if (e.map[o][0] === t) {
          e.map[o][1] += n, e.map[o][2].push(...r);
          return;
        }
        o += 1;
      }
      e.map.push([t, n, r]);
    }
  }
  function DLe(e, t) {
    let n = !1;
    const r = [];
    for (; t < e.length; ) {
      const o = e[t];
      if (n) {
        if (o[0] === "enter")
          o[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
        else if (o[1].type === "tableContent") {
          if (e[t - 1][1].type === "tableDelimiterMarker") {
            const i = r.length - 1;
            r[i] = r[i] === "left" ? "center" : "right";
          }
        } else if (o[1].type === "tableDelimiterRow")
          break;
      } else o[0] === "enter" && o[1].type === "tableDelimiterRow" && (n = !0);
      t += 1;
    }
    return r;
  }
  function FLe() {
    return {
      flow: {
        null: {
          name: "table",
          tokenize: LLe,
          resolveAll: zLe
        }
      }
    };
  }
  function LLe(e, t, n) {
    const r = this;
    let o = 0, i = 0, a;
    return s;
    function s($) {
      let L = r.events.length - 1;
      for (; L > -1; ) {
        const j = r.events[L][1].type;
        if (j === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
        j === "linePrefix") L--;
        else break;
      }
      const N = L > -1 ? r.events[L][1].type : null, U = N === "tableHead" || N === "tableRow" ? A : c;
      return U === A && r.parser.lazy[r.now().line] ? n($) : U($);
    }
    function c($) {
      return e.enter("tableHead"), e.enter("tableRow"), u($);
    }
    function u($) {
      return $ === 124 || (a = !0, i += 1), d($);
    }
    function d($) {
      return $ === null ? n($) : Ze($) ? i > 1 ? (i = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume($), e.exit("lineEnding"), g) : n($) : _t($) ? Pt(e, d, "whitespace")($) : (i += 1, a && (a = !1, o += 1), $ === 124 ? (e.enter("tableCellDivider"), e.consume($), e.exit("tableCellDivider"), a = !0, d) : (e.enter("data"), p($)));
    }
    function p($) {
      return $ === null || $ === 124 || cn($) ? (e.exit("data"), d($)) : (e.consume($), $ === 92 ? m : p);
    }
    function m($) {
      return $ === 92 || $ === 124 ? (e.consume($), p) : p($);
    }
    function g($) {
      return r.interrupt = !1, r.parser.lazy[r.now().line] ? n($) : (e.enter("tableDelimiterRow"), a = !1, _t($) ? Pt(e, y, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)($) : y($));
    }
    function y($) {
      return $ === 45 || $ === 58 ? v($) : $ === 124 ? (a = !0, e.enter("tableCellDivider"), e.consume($), e.exit("tableCellDivider"), b) : k($);
    }
    function b($) {
      return _t($) ? Pt(e, v, "whitespace")($) : v($);
    }
    function v($) {
      return $ === 58 ? (i += 1, a = !0, e.enter("tableDelimiterMarker"), e.consume($), e.exit("tableDelimiterMarker"), x) : $ === 45 ? (i += 1, x($)) : $ === null || Ze($) ? C($) : k($);
    }
    function x($) {
      return $ === 45 ? (e.enter("tableDelimiterFiller"), E($)) : k($);
    }
    function E($) {
      return $ === 45 ? (e.consume($), E) : $ === 58 ? (a = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume($), e.exit("tableDelimiterMarker"), _) : (e.exit("tableDelimiterFiller"), _($));
    }
    function _($) {
      return _t($) ? Pt(e, C, "whitespace")($) : C($);
    }
    function C($) {
      return $ === 124 ? y($) : $ === null || Ze($) ? !a || o !== i ? k($) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t($)) : k($);
    }
    function k($) {
      return n($);
    }
    function A($) {
      return e.enter("tableRow"), O($);
    }
    function O($) {
      return $ === 124 ? (e.enter("tableCellDivider"), e.consume($), e.exit("tableCellDivider"), O) : $ === null || Ze($) ? (e.exit("tableRow"), t($)) : _t($) ? Pt(e, O, "whitespace")($) : (e.enter("data"), P($));
    }
    function P($) {
      return $ === null || $ === 124 || cn($) ? (e.exit("data"), O($)) : (e.consume($), $ === 92 ? I : P);
    }
    function I($) {
      return $ === 92 || $ === 124 ? (e.consume($), P) : P($);
    }
  }
  function zLe(e, t) {
    let n = -1, r = !0, o = 0, i = [0, 0, 0, 0], a = [0, 0, 0, 0], s = !1, c = 0, u, d, p;
    const m = new $Le();
    for (; ++n < e.length; ) {
      const g = e[n], y = g[1];
      g[0] === "enter" ? y.type === "tableHead" ? (s = !1, c !== 0 && (L4(m, t, c, u, d), d = void 0, c = 0), u = {
        type: "table",
        start: Object.assign({}, y.start),
        // Note: correct end is set later.
        end: Object.assign({}, y.end)
      }, m.add(n, 0, [["enter", u, t]])) : y.type === "tableRow" || y.type === "tableDelimiterRow" ? (r = !0, p = void 0, i = [0, 0, 0, 0], a = [0, n + 1, 0, 0], s && (s = !1, d = {
        type: "tableBody",
        start: Object.assign({}, y.start),
        // Note: correct end is set later.
        end: Object.assign({}, y.end)
      }, m.add(n, 0, [["enter", d, t]])), o = y.type === "tableDelimiterRow" ? 2 : d ? 3 : 1) : o && (y.type === "data" || y.type === "tableDelimiterMarker" || y.type === "tableDelimiterFiller") ? (r = !1, a[2] === 0 && (i[1] !== 0 && (a[0] = a[1], p = Sv(m, t, i, o, void 0, p), i = [0, 0, 0, 0]), a[2] = n)) : y.type === "tableCellDivider" && (r ? r = !1 : (i[1] !== 0 && (a[0] = a[1], p = Sv(m, t, i, o, void 0, p)), i = a, a = [i[1], n, 0, 0])) : y.type === "tableHead" ? (s = !0, c = n) : y.type === "tableRow" || y.type === "tableDelimiterRow" ? (c = n, i[1] !== 0 ? (a[0] = a[1], p = Sv(m, t, i, o, n, p)) : a[1] !== 0 && (p = Sv(m, t, a, o, n, p)), o = 0) : o && (y.type === "data" || y.type === "tableDelimiterMarker" || y.type === "tableDelimiterFiller") && (a[3] = n);
    }
    for (c !== 0 && L4(m, t, c, u, d), m.consume(t.events), n = -1; ++n < t.events.length; ) {
      const g = t.events[n];
      g[0] === "enter" && g[1].type === "table" && (g[1]._align = DLe(t.events, n));
    }
    return e;
  }
  function Sv(e, t, n, r, o, i) {
    const a = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", s = "tableContent";
    n[0] !== 0 && (i.end = Object.assign({}, Hu(t.events, n[0])), e.add(n[0], 0, [["exit", i, t]]));
    const c = Hu(t.events, n[1]);
    if (i = {
      type: a,
      start: Object.assign({}, c),
      // Note: correct end is set later.
      end: Object.assign({}, c)
    }, e.add(n[1], 0, [["enter", i, t]]), n[2] !== 0) {
      const u = Hu(t.events, n[2]), d = Hu(t.events, n[3]), p = {
        type: s,
        start: Object.assign({}, u),
        end: Object.assign({}, d)
      };
      if (e.add(n[2], 0, [["enter", p, t]]), r !== 2) {
        const m = t.events[n[2]], g = t.events[n[3]];
        if (m[1].end = Object.assign({}, g[1].end), m[1].type = "chunkText", m[1].contentType = "text", n[3] > n[2] + 1) {
          const y = n[2] + 1, b = n[3] - n[2] - 1;
          e.add(y, b, []);
        }
      }
      e.add(n[3] + 1, 0, [["exit", p, t]]);
    }
    return o !== void 0 && (i.end = Object.assign({}, Hu(t.events, o)), e.add(o, 0, [["exit", i, t]]), i = void 0), i;
  }
  function L4(e, t, n, r, o) {
    const i = [], a = Hu(t.events, n);
    o && (o.end = Object.assign({}, a), i.push(["exit", o, t])), r.end = Object.assign({}, a), i.push(["exit", r, t]), e.add(n + 1, 0, i);
  }
  function Hu(e, t) {
    const n = e[t], r = n[0] === "enter" ? "start" : "end";
    return n[1][r];
  }
  const BLe = {
    name: "tasklistCheck",
    tokenize: VLe
  };
  function ULe() {
    return {
      text: {
        91: BLe
      }
    };
  }
  function VLe(e, t, n) {
    const r = this;
    return o;
    function o(c) {
      return (
        // Exit if theres stuff before.
        r.previous !== null || // Exit if not in the first content that is the first child of a list
        // item.
        !r._gfmTasklistFirstContentOfListItem ? n(c) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), i)
      );
    }
    function i(c) {
      return cn(c) ? (e.enter("taskListCheckValueUnchecked"), e.consume(c), e.exit("taskListCheckValueUnchecked"), a) : c === 88 || c === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(c), e.exit("taskListCheckValueChecked"), a) : n(c);
    }
    function a(c) {
      return c === 93 ? (e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), s) : n(c);
    }
    function s(c) {
      return Ze(c) ? t(c) : _t(c) ? e.check({
        tokenize: HLe
      }, t, n)(c) : n(c);
    }
  }
  function HLe(e, t, n) {
    return Pt(e, r, "whitespace");
    function r(o) {
      return o === null ? n(o) : t(o);
    }
  }
  function qLe(e) {
    return V7([
      gLe(),
      kLe(),
      ILe(e),
      FLe(),
      ULe()
    ]);
  }
  const WLe = {};
  function GLe(e) {
    const t = (
      /** @type {Processor<Root>} */
      this
    ), n = e || WLe, r = t.data(), o = r.micromarkExtensions || (r.micromarkExtensions = []), i = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), a = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
    o.push(qLe(n)), i.push(dLe()), a.push(pLe(n));
  }
  const NR = ({
    availableModule: e
  }) => {
    const [t, n] = T.useState(!1), r = () => n(!t), o = 150, i = e.description.length > o ? e.description.substring(0, o) + "..." : e.description;
    return /* @__PURE__ */ S.jsxs("div", { className: "module-description", children: [
      /* @__PURE__ */ S.jsx(I4e, { remarkPlugins: [GLe], children: t ? e.description.replace(/\\n/g, `
`) : i.replace(/\\n/g, `
`) }),
      e.description.length > o && /* @__PURE__ */ S.jsx("button", { onClick: r, className: "toggle-description", children: t ? "Show less" : "Show more" })
    ] });
  }, z4 = [
    ">=",
    "==",
    "<=",
    "<",
    ">"
  ], V1 = ">=", PR = ({
    availableModule: e,
    on_change: t
  }) => {
    const [n, r] = T.useState(
      e.version || "latest"
    ), [o, i] = T.useState(V1), a = (c) => {
      const u = c.target.value;
      r(u), t(u !== "latest" ? o + u : u);
    }, s = (c) => {
      c.target.value !== o && z4.includes(c.target.value) && (i(c.target.value), n !== "latest" && t(c.target.value + n));
    };
    return e.releases && !e.releases.includes(n) && e.releases.unshift(n), /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
      /* @__PURE__ */ S.jsx("select", { value: o, onChange: s, children: z4.map((c) => /* @__PURE__ */ S.jsx("option", { value: c, children: c }, c)) }),
      /* @__PURE__ */ S.jsx("select", { onChange: a, value: n, children: e.releases && e.releases.map((c) => /* @__PURE__ */ S.jsx("option", { value: c, children: c }, c)) })
    ] });
  }, KLe = ({
    availableModule: e,
    on_remove: t,
    on_update: n
  }) => {
    const [r, o] = T.useState(
      V1 + e.version || "latest"
    );
    return /* @__PURE__ */ S.jsxs("div", { className: "addable-module", children: [
      /* @__PURE__ */ S.jsx("div", { className: "module-name", children: e.name + (e.version ? ` (${e.version})` : "") }),
      /* @__PURE__ */ S.jsx(pR, { availableModule: e }),
      /* @__PURE__ */ S.jsx(NR, { availableModule: e }),
      /* @__PURE__ */ S.jsxs("div", { children: [
        /* @__PURE__ */ S.jsx(
          PR,
          {
            availableModule: e,
            on_change: o
          }
        ),
        /* @__PURE__ */ S.jsx(
          "button",
          {
            className: "update-button",
            disabled: r === e.version,
            onClick: () => {
              n(e, r);
            },
            children: "Update"
          }
        ),
        /* @__PURE__ */ S.jsx(
          "button",
          {
            className: "remove-button",
            onClick: () => {
              t(e);
            },
            children: "Remove"
          }
        )
      ] })
    ] });
  }, YLe = ({
    availableModule: e,
    on_add: t
  }) => {
    const [n, r] = T.useState(
      V1 + e.version || "latest"
    );
    return /* @__PURE__ */ S.jsxs("div", { className: "addable-module", children: [
      /* @__PURE__ */ S.jsx("div", { className: "module-name", children: e.name + (e.version ? ` (${e.version})` : "") }),
      /* @__PURE__ */ S.jsx(pR, { availableModule: e }),
      /* @__PURE__ */ S.jsx(NR, { availableModule: e }),
      /* @__PURE__ */ S.jsxs("div", { children: [
        /* @__PURE__ */ S.jsx(
          PR,
          {
            availableModule: e,
            on_change: r
          }
        ),
        /* @__PURE__ */ S.jsx(
          "button",
          {
            className: "add-button",
            onClick: () => {
              t(e, n);
            },
            children: "Add"
          }
        )
      ] })
    ] });
  }, XLe = ({
    availableModule: e,
    on_add: t
  }) => {
    const [n, r] = T.useState(
      V1 + e.version || "latest"
    );
    return /* @__PURE__ */ S.jsxs("div", { className: "addable-module", children: [
      /* @__PURE__ */ S.jsx("div", { className: "module-name", children: e.name }),
      /* @__PURE__ */ S.jsx(pR, { availableModule: e }),
      /* @__PURE__ */ S.jsx(NR, { availableModule: e }),
      /* @__PURE__ */ S.jsxs("div", { children: [
        /* @__PURE__ */ S.jsx(
          PR,
          {
            availableModule: e,
            on_change: r
          }
        ),
        /* @__PURE__ */ S.jsx(
          "button",
          {
            className: "add-button",
            onClick: () => {
              t(e, n);
            },
            children: "Add"
          }
        )
      ] })
    ] });
  }, ZLe = ({
    ins: e
  }) => {
    const [t, n] = T.useState(e.name), r = Vt(), { lib: o } = Rr(), i = () => {
      r.worker && o?.remove_external_worker(e.uuid, e.nodeclassid);
    }, a = () => {
      r.worker && (r.worker.update_external_worker(e.uuid, e.nodeclassid, {
        name: t
      }), e.name = t);
    };
    return /* @__PURE__ */ S.jsx(S.Fragment, { children: /* @__PURE__ */ S.jsx(
      Ji,
      {
        title: e.name,
        description: "Settings for " + e.name,
        trigger: /* @__PURE__ */ S.jsx("div", { children: "Settings" }),
        buttons: [
          {
            text: "Save",
            onClick: a,
            close: !0
          },
          {
            text: "Delete",
            onClick: i,
            close: !0
          }
        ],
        children: /* @__PURE__ */ S.jsxs("div", { children: [
          /* @__PURE__ */ S.jsxs("div", { children: [
            /* @__PURE__ */ S.jsx("label", { htmlFor: "name", children: "Name: " }),
            /* @__PURE__ */ S.jsx(
              "input",
              {
                type: "text",
                name: "name",
                value: t,
                onChange: (s) => n(s.target.value),
                className: "styledinput"
              }
            )
          ] }),
          o && /* @__PURE__ */ S.jsx(
            yH,
            {
              getter: () => o.get_external_worker_config(e.uuid, e.nodeclassid),
              setter: async (s) => {
                if (r.worker)
                  return await r.worker.update_external_worker(
                    e.uuid,
                    e.nodeclassid,
                    {
                      name: t,
                      config: s
                    }
                  );
              },
              setter_calls_getter: !0
            }
          )
        ] })
      }
    ) });
  }, QLe = ({
    ins: e,
    lib: t,
    filter: n = "",
    parentkey: r
  }) => {
    const [o, i] = T.useState(!1), a = () => i(!o), s = t?.nodes?.filter(
      (c) => c.node_id.toLowerCase().includes(n.toLowerCase())
    );
    return /* @__PURE__ */ S.jsxs("div", { className: "shelfcontainer", children: [
      /* @__PURE__ */ S.jsxs(
        "div",
        {
          className: "shelftitle",
          onClick: a,
          style: { cursor: "pointer" },
          title: e.name,
          children: [
            /* @__PURE__ */ S.jsx("div", { className: "shelftitle_text", children: e.name }),
            /* @__PURE__ */ S.jsx("div", { className: "expandicon " + (o ? "open" : "close"), children: /* @__PURE__ */ S.jsx(Hh, {}) })
          ]
        }
      ),
      /* @__PURE__ */ S.jsx("div", { className: "libnodecontainer " + (o ? "open" : "close"), children: /* @__PURE__ */ S.jsx("div", { className: "libnodecontainer_inner", children: o && /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
        /* @__PURE__ */ S.jsx("div", { className: "libnodeentry", title: e.uuid, children: /* @__PURE__ */ S.jsx(ZLe, { ins: e }) }),
        t && /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
          s && /* @__PURE__ */ S.jsx(S.Fragment, { children: s.map((c) => /* @__PURE__ */ S.jsx(
            T7,
            {
              item: c
            },
            r + c.node_id
          )) }),
          t.subshelves.map((c) => /* @__PURE__ */ S.jsx(
            dR,
            {
              item: c,
              filter: n,
              parentkey: r + c.name
            },
            r + c.name
          ))
        ] })
      ] }) }) })
    ] });
  }, JLe = ({
    item: e,
    mod: t,
    lib: n
  }) => {
    const { lib: r } = Rr(), [o, i] = T.useState(!1), a = () => i(!o), s = T.useCallback(() => {
      r?.add_external_worker({
        module: t,
        cls_module: e.module,
        cls_name: e.class_name
      });
    }, [r, t, e]), c = (d) => {
      d.detail === 2 && s();
    }, u = e.name || e.module + "." + e.class_name;
    return /* @__PURE__ */ S.jsxs("div", { className: "shelfcontainer", children: [
      /* @__PURE__ */ S.jsxs(
        "div",
        {
          className: "shelftitle",
          onClick: a,
          style: { cursor: "pointer" },
          title: u,
          children: [
            /* @__PURE__ */ S.jsx("div", { className: "shelftitle_text", children: u }),
            /* @__PURE__ */ S.jsx("div", { className: "expandicon " + (o ? "open" : "close"), children: /* @__PURE__ */ S.jsx(Hh, {}) })
          ]
        }
      ),
      /* @__PURE__ */ S.jsx("div", { className: "libnodecontainer " + (o ? "open" : "close"), children: /* @__PURE__ */ S.jsx("div", { className: "libnodecontainer_inner", children: o && /* @__PURE__ */ S.jsxs(S.Fragment, { children: [
        /* @__PURE__ */ S.jsx(
          "div",
          {
            className: "libnodeentry",
            onClick: c,
            title: e.name,
            children: "New Instance"
          }
        ),
        e.instances.map((d) => /* @__PURE__ */ S.jsx(
          QLe,
          {
            ins: d,
            lib: n?.subshelves.find(
              (p) => p.name === d.uuid
            ),
            parentkey: d.uuid
          },
          d.uuid
        ))
      ] }) }) })
    ] });
  }, eze = ({
    externalworkermod: e,
    lib: t
  }) => {
    const [n, r] = T.useState(!1), o = () => r(!n), i = n;
    return /* @__PURE__ */ S.jsxs("div", { className: "shelfcontainer", children: [
      /* @__PURE__ */ S.jsxs(
        "div",
        {
          className: "shelftitle",
          onClick: o,
          style: { cursor: "pointer" },
          title: e.module,
          children: [
            /* @__PURE__ */ S.jsx("div", { className: "shelftitle_text", children: e.module }),
            /* @__PURE__ */ S.jsx("div", { className: "expandicon " + (i ? "open" : "close"), children: /* @__PURE__ */ S.jsx(Hh, {}) })
          ]
        }
      ),
      /* @__PURE__ */ S.jsx("div", { className: "libnodecontainer " + (i ? "open" : "close"), children: /* @__PURE__ */ S.jsx("div", { className: "libnodecontainer_inner", children: e.worker_classes.map((a) => /* @__PURE__ */ S.jsx(
        JLe,
        {
          item: a,
          mod: e.module,
          lib: t
        },
        a.module + a.class_name
      )) }) }),
      /* @__PURE__ */ S.jsx("hr", {})
    ] });
  }, tze = () => {
    const e = Vt(), t = e.lib.libstate(), n = e.local_settings(
      (c) => c.view_settings.expand_lib
    ), r = (c) => {
      e.update_view_settings({ expand_lib: c });
    }, o = eIe("m"), [i, a] = T.useState(""), s = e.workerstate((c) => c.is_open);
    return /* @__PURE__ */ S.jsx(
      KA,
      {
        maxSize: o ? "100%" : "18.75rem",
        direction: o ? "down" : "right",
        containerClassName: "pos-left pos-top bg1 h-12",
        onExpandChange: r,
        expanded: n === void 0 ? !0 : n,
        collapseIcons: {
          up: u0,
          down: Jp,
          left: Qp,
          right: c0
        },
        expandIcons: {
          up: Jp,
          down: u0,
          left: c0,
          right: Qp
        },
        children: /* @__PURE__ */ S.jsxs("div", { className: "libcontainer", children: [
          /* @__PURE__ */ S.jsxs("div", { className: "library", children: [
            /* @__PURE__ */ S.jsx("div", { className: "libtitle", children: "Lib" }),
            /* @__PURE__ */ S.jsx("hr", { className: "hr_prominent" }),
            /* @__PURE__ */ S.jsx(Sje, { filter: i, setFilter: a }),
            /* @__PURE__ */ S.jsx("div", { className: "vscrollcontainer", children: t.lib.shelves.filter((c) => c.name !== "_external_worker").map((c) => /* @__PURE__ */ S.jsx(
              dR,
              {
                item: c,
                filter: i,
                parentkey: c.name
              },
              c.name
            )) }),
            /* @__PURE__ */ S.jsx("hr", {}),
            /* @__PURE__ */ S.jsx("div", { className: "libtitle", children: "External Worker" }),
            /* @__PURE__ */ S.jsx("hr", { className: "hr_prominent" }),
            /* @__PURE__ */ S.jsx("div", { className: "vscrollcontainer", children: t.external_worker?.map((c) => /* @__PURE__ */ S.jsx(
              eze,
              {
                externalworkermod: c,
                lib: t.lib.shelves.find(
                  (u) => u.name === "_external_worker"
                )
              },
              c.module
            )) }),
            /* @__PURE__ */ S.jsx("hr", {})
          ] }),
          s && /* @__PURE__ */ S.jsx("div", { className: "addlib", children: /* @__PURE__ */ S.jsx(_je, { children: /* @__PURE__ */ S.jsx("button", { children: "Manage Libraries" }) }) })
        ] })
      }
    );
  }, nze = ({
    fnrf_zst: e,
    header: t,
    flow: n,
    library: r
  }) => {
    const [o, i] = T.useState(
      e.options.worker || e.getWorkerManager().worker
    ), a = T.useRef(null);
    e.workermanager && (e.workermanager.on_setWorker = i), T.useEffect(() => {
      e.auto_progress();
    }, []), T.useEffect(() => {
      e.local_state.setState({ funcnodescontainerRef: a.current });
    }, [a]);
    const s = e.plugins();
    return /* @__PURE__ */ S.jsx(B2e, { plugins: s, fnrf_zst: e, children: /* @__PURE__ */ S.jsx(Xoe, { children: /* @__PURE__ */ S.jsx(wz.Provider, { value: e, children: /* @__PURE__ */ S.jsx(Gs, { asChild: !0, children: /* @__PURE__ */ S.jsx($a, { asChild: !0, children: /* @__PURE__ */ S.jsx(
      _H,
      {
        style: {
          height: "100%",
          width: "100%",
          display: "flex",
          flexDirection: "column",
          flex: 1
        },
        children: /* @__PURE__ */ S.jsxs(
          "div",
          {
            ref: a,
            className: "funcnodesreactflowcontainer funcnodescontainer",
            children: [
              t.show && /* @__PURE__ */ S.jsx(wje, { ...t }),
              /* @__PURE__ */ S.jsxs("div", { className: "funcnodesreactflowbody", children: [
                /* @__PURE__ */ S.jsx(JIe, { ...n }),
                o && r.show && /* @__PURE__ */ S.jsx(tze, {}),
                o && n.showNodeSettings && /* @__PURE__ */ S.jsx(iIe, {})
              ] }),
              /* @__PURE__ */ S.jsxs("div", { className: "funcnodesflaotingmenu", children: [
                /* @__PURE__ */ S.jsx($a.OutFullScreen, { children: n.allowExpand && /* @__PURE__ */ S.jsxs(Gs.Trigger, { children: [
                  /* @__PURE__ */ S.jsx(Gs.Expanded, { children: /* @__PURE__ */ S.jsx(
                    zoe,
                    {
                      size: "xl",
                      style: { padding: "4px" }
                    }
                  ) }),
                  /* @__PURE__ */ S.jsx(Gs.Collapsed, { children: /* @__PURE__ */ S.jsx(
                    Boe,
                    {
                      size: "xl",
                      style: { padding: "4px" }
                    }
                  ) })
                ] }) }),
                n.allowFullScreen && /* @__PURE__ */ S.jsxs($a.Trigger, { children: [
                  /* @__PURE__ */ S.jsx($a.OutFullScreen, { children: /* @__PURE__ */ S.jsx(
                    xz,
                    {
                      size: "xl",
                      style: { padding: "4px" }
                    }
                  ) }),
                  /* @__PURE__ */ S.jsx($a.InFullScreen, { children: /* @__PURE__ */ S.jsx(
                    Loe,
                    {
                      size: "xl",
                      style: { padding: "4px" }
                    }
                  ) })
                ] })
              ] })
            ]
          }
        )
      }
    ) }) }) }) }) });
  };
  class Yf {
    constructor(t) {
      this.context = t;
    }
    get nodespaceManager() {
      return this.context.rf.getNodespaceManager();
    }
    get libManager() {
      return this.context.rf.getLibManager();
    }
    get workerManager() {
      return this.context.rf.getWorkerManager();
    }
    get stateManager() {
      return this.context.rf.getStateManager();
    }
    get pluginManager() {
      return this.context.rf.getPluginManager();
    }
    get reactFlowManager() {
      return this.context.rf.getReactFlowManager();
    }
  }
  const B4 = ({
    src_nid: e,
    src_ioid: t,
    trg_nid: n,
    trg_ioid: r
  }) => [`${e}:${t}`, `${n}:${r}`].sort().join("--"), rze = ({}) => {
    const e = /* @__PURE__ */ new Map();
    return {
      nodesstates: e,
      get_node: (t, n = !0) => {
        const r = e.get(t);
        if (!r && n) {
          const o = e.keys();
          throw new Error(
            `Node ${t} not found, available nodes: ${Array.from(o)}`
          );
        }
        return r;
      }
    };
  };
  class oze extends Yf {
    constructor(t) {
      super(t), this.on_node_action = (n) => {
        switch (n.type) {
          case "add":
            return this._add_node(n);
          case "update":
            return this._update_node(n);
          case "delete":
            return this._delete_node(n);
          case "error":
            return this._error_action(n);
          case "trigger":
            return this._trigger_action(n);
          default:
            this.context.rf.logger.error("Unknown node action", n);
            return;
        }
      }, this.on_edge_action = (n) => {
        const r = this.reactFlowManager.useReactFlowStore.getState();
        switch (n.type) {
          case "add":
            if (n.from_remote) {
              const o = r.getEdges(), i = B4(n);
              if (o.some((s) => s.id === i))
                return;
              const a = {
                id: i,
                source: n.src_nid,
                target: n.trg_nid,
                sourceHandle: n.src_ioid,
                targetHandle: n.trg_ioid,
                className: "funcnodes-edge animated",
                zIndex: 1003
                // just above elevated groups
              };
              this.context.rf.logger.info("Adding edge", a), r.update_edges([...o, a]), this.workerManager.worker?.api.node.get_remote_node_state(
                n.src_nid
              ), this.workerManager.worker?.api.node.get_remote_node_state(
                n.trg_nid
              );
            }
            break;
          case "delete":
            if (n.from_remote) {
              const o = r.getEdges(), i = B4(n);
              this.context.rf.logger.info("Deleting edge", i);
              const a = o.filter((s) => s.id !== i);
              r.update_edges(a), this.workerManager.worker?.api.node.get_remote_node_state(
                n.src_nid
              ), this.workerManager.worker?.api.node.get_remote_node_state(
                n.trg_nid
              );
            }
            break;
          default:
            this.context.rf.logger.error("Unknown edge action", n);
        }
      }, this.on_group_action = (n) => {
        switch (n.type) {
          case "set":
            return this._set_groups(n.groups);
          case "update":
            return this._update_group(n);
          default:
            this.context.rf.logger.error("Unknown group action", n);
        }
      }, this.clear_all = () => {
        this.context.rf.logger.debug("Clearing all nodespace"), this.workerManager.worker?.disconnect(), this.workerManager.set_worker(void 0), this.workerManager.workermanager?.setWorker(void 0), this.libManager.lib.libstate.getState().set({ lib: { shelves: [] }, external_worker: [] }), this.nodespace.nodesstates.clear(), this.reactFlowManager.useReactFlowStore.getState().update_nodes([]), this.reactFlowManager.useReactFlowStore.getState().update_edges([]), this.stateManager.auto_progress();
      }, this.center_node = (n) => {
        if (!this.reactFlowManager.rf_instance)
          return;
        n = Array.isArray(n) ? n : [n];
        const r = this.reactFlowManager.useReactFlowStore.getState().getNodes().filter((o) => n.includes(o.id));
        r.length > 0 && this.reactFlowManager.rf_instance?.fitView({ padding: 0.2, nodes: r });
      }, this.auto_resize_group = (n) => {
        const r = this.reactFlowManager.useReactFlowStore.getState(), o = r.getNode(n);
        if (o === void 0 || o.type !== "group")
          return;
        const i = o.data.group.node_ids.map((d) => r.getNode(d)).filter((d) => d !== void 0), a = o.data.group.child_groups.map((d) => r.getNode(d)).filter((d) => d !== void 0), s = [...i, ...a], c = this.reactFlowManager.rf_instance?.getNodesBounds(s);
        if (c === void 0)
          return;
        const u = {
          ...o,
          position: {
            x: c.x,
            y: c.y
          },
          height: c.height,
          width: c.width
        };
        u.data.group.position = [c.x, c.y], r.partial_update_nodes([u]);
      }, this.change_group_position = (n) => {
        if (n.position === void 0)
          return;
        const r = this.reactFlowManager.useReactFlowStore.getState(), o = r.getNode(n.id);
        if (o === void 0 || o.type !== "group")
          return;
        const i = [
          ...o.data.group.node_ids,
          ...o.data.group.child_groups
        ], a = this.reactFlowManager.rf_instance?.getNodesBounds(i);
        if (a === void 0)
          return;
        const s = n.position.x - a?.x, c = n.position.y - a?.y, u = [];
        for (const d of i) {
          const p = r.getNode(d);
          p !== void 0 && u.push({
            id: d,
            type: "position",
            position: {
              x: p.position.x + s,
              y: p.position.y + c
            }
          });
        }
        r.onNodesChange(u);
      }, this.change_fn_node_position = (n) => {
        n.position !== void 0 && this.on_node_action({
          type: "update",
          id: n.id,
          node: {
            properties: {
              "frontend:pos": [n.position.x, n.position.y]
            }
          },
          from_remote: !1
        });
      }, this.change_group_dimensions = (n) => {
        if (n.dimensions === void 0)
          return;
        const o = this.reactFlowManager.useReactFlowStore.getState().getNode(n.id);
        o !== void 0 && this.reactFlowManager.useReactFlowStore.getState().partial_update_nodes(zT([n], [o]));
      }, this.change_fn_node_dimensions = (n) => {
        n.dimensions !== void 0 && this.on_node_action({
          type: "update",
          id: n.id,
          node: {
            properties: {
              "frontend:size": [n.dimensions.width, n.dimensions.height]
            }
          },
          from_remote: !1
        });
      }, this._update_group = (n) => {
        if (n.from_remote) {
          const r = this.reactFlowManager.useReactFlowStore.getState(), o = r.getNode(n.id);
          if (o === void 0 || o.type !== "group")
            return;
          const { new_obj: i, change: a } = tl(o.data.group, n.group);
          a && (o.data.group = i), r.partial_update_nodes([o]);
        } else
          this.workerManager.worker && this.workerManager.worker.api.group.locally_update_group(n);
      }, this._set_groups = (n) => {
        const r = this.reactFlowManager.useReactFlowStore.getState(), { default_nodes: o } = JA(r.getNodes()), i = [...o], a = {};
        for (const c in n) {
          const u = n[c];
          for (const p of u.node_ids)
            a[p] = c;
          for (const p of u.child_groups)
            a[p] = c;
          u.position === void 0 && (u.position = [0, 0]);
          const d = {
            id: c,
            type: "group",
            data: { group: n[c], id: c },
            position: { x: u.position[0], y: u.position[1] },
            zIndex: 2
          };
          u.parent_group && (d.data.groupID = u.parent_group), i.push(d);
        }
        for (const c of i)
          c.id in a ? c.data.groupID = a[c.id] : c.data.groupID = void 0;
        const s = eR(i);
        r.update_nodes(s);
        for (const c of s.reverse())
          c.type === "group" && this.auto_resize_group(c.id);
      }, this._add_node = (n) => {
        this.context.rf.logger.info("add node", n);
        const r = this.reactFlowManager.useReactFlowStore.getState();
        if (n.from_remote) {
          let o = this.nodespace.get_node(n.node.id, !1);
          if (o)
            return;
          if (!o)
            try {
              o = qIe(n.node), this.nodespace.nodesstates.set(n.node.id, o);
            } catch (c) {
              this.context.rf.logger.error(`Failed to create node store ${c}`);
              return;
            }
          const i = o.getState();
          this.context.rf.logger.info("Add node", i.id, i.name);
          const a = QIe(o, this.context.rf), s = [...r.getNodes(), a];
          this.reactFlowManager.useReactFlowStore.getState().update_nodes(s);
          for (const c of a.io_order)
            this.workerManager.worker?.api.node.get_io_value({
              nid: a.id,
              ioid: c
            });
          return setTimeout(() => {
            this.workerManager.worker?.api.hooks.call_hooks("node_added", {
              node: i.id
            });
          }, 0), i;
        }
      }, this._update_node = (n) => {
        if (Object.keys(n.node).length === 0) {
          this.context.rf.logger.error(
            "Node update is empty",
            new Error(JSON.stringify(n))
          );
          return;
        }
        if (n.node.in_trigger && (n.node.error = void 0), n.from_remote) {
          const r = this.nodespace.get_node(n.id, !1);
          if (!r) {
            console.error("Node not found to update", n.id);
            return;
          }
          return r.update(n.node), r.getState();
        } else
          this.workerManager.worker && this.workerManager.worker.api.node.locally_update_node(n);
      }, this._sync_nodes = () => {
        const n = this.reactFlowManager.useReactFlowStore.getState().getNodes(), r = this.nodespace.nodesstates;
        for (const o of r.keys())
          n.some((i) => i.id === o) || r.delete(o);
      }, this._delete_node = (n) => {
        this.context.rf.logger.info("Deleting node", n.id), n.from_remote ? (this.reactFlowManager.useReactFlowStore.getState().onNodesChange([
          {
            type: "remove",
            id: n.id
          }
        ]), this._sync_nodes()) : this.workerManager.worker?.api.node.remove_node(n.id);
      }, this._error_action = (n) => (this.context.rf.logger.error("Error", new Error(JSON.stringify(n))), this.on_node_action({
        type: "update",
        id: n.id,
        node: {
          in_trigger: !1,
          error: n.error
        },
        from_remote: !0
      })), this._trigger_action = (n) => {
        if (n.from_remote)
          return this.on_node_action({
            type: "update",
            id: n.id,
            node: {
              in_trigger: !0,
              error: void 0
            },
            from_remote: !0
          });
        this.workerManager.worker?.api.node.trigger_node(n.id);
      }, this.nodespace = rze({});
    }
    center_all() {
      this.reactFlowManager.rf_instance?.fitView({ padding: 0.2 });
    }
  }
  const ize = () => ({
    libstate: No((e, t) => ({
      lib: {
        shelves: []
      },
      external_worker: [],
      set: (n) => e((r) => ({ ...r, ...n })),
      get_lib: () => t().lib,
      get_external_worker: () => t().external_worker
    }))
  });
  class aze extends Yf {
    constructor(t) {
      super(t), this.lib = ize();
    }
  }
  class sze extends Yf {
    constructor(t) {
      super(t), t.rf.logger.debug("Initializing worker manager handler"), this.workers = No((n, r) => ({})), this.workerstate = No((n, r) => ({
        is_open: !1
      }));
    }
    set_worker(t) {
      t !== this.worker && (this._unsubscribeFromWorker && (this._unsubscribeFromWorker(), this._unsubscribeFromWorker = void 0), t ? (this.context.rf.logger.debug("Setting worker in worker manager"), this._unsubscribeFromWorker = t.state.subscribe((n) => {
        this.workerstate.setState(n);
      }), this.workerstate.setState(t.state.getState())) : this.context.rf.logger.debug("Removing worker in worker manager"), this.worker = t, t?.set_zustand(this.context.rf));
    }
  }
  class lze extends Yf {
    constructor(t) {
      super(t), this.progress_state = No((n, r) => ({
        message: "please select worker",
        status: "info",
        progress: 0,
        blocking: !1
      })), this.local_settings = No(
        (n, r) => ({
          view_settings: {
            expand_node_props: !1,
            expand_lib: !1
          }
        })
      ), this.local_state = No((n, r) => ({
        selected_nodes: [],
        selected_edges: [],
        selected_groups: [],
        funcnodescontainerRef: null
      }));
    }
    set_progress(t) {
      if (t.message === "")
        return this.auto_progress();
      const n = this.progress_state.getState(), { new_obj: r, change: o } = tl(n, t);
      o && this.progress_state.setState(r);
    }
    auto_progress() {
      const t = this.workerManager.workermanager, n = this.workerManager.worker;
      if (t !== void 0 && !t.open)
        return this.set_progress({
          progress: 0,
          message: "connecting to worker manager",
          status: "error",
          blocking: !1
        });
      if (n === void 0)
        return this.set_progress({
          progress: 0,
          message: "please select worker",
          status: "error",
          blocking: !1
        });
      if (!n.is_open)
        return this.set_progress({
          progress: 0,
          message: "connecting to worker",
          status: "info",
          blocking: !0
        });
      this.set_progress({
        progress: 1,
        message: "running",
        status: "info",
        blocking: !1
      });
    }
    update_view_settings(t) {
      UH(this.local_settings, { view_settings: t });
    }
  }
  const Pq = "1.0.0", cze = ["1"], uze = (e) => {
    if (!e.v.toString().includes(".") || // old polugin version without "."
    !cze.includes(e.v.toString().split(".")[0]))
      throw new Error(`Unsupported version: ${e.v}`);
    return { ...e, v: Pq };
  };
  class fze extends Yf {
    constructor(t) {
      super(t), this.plugins = No((n, r) => ({})), this.render_options = No((n, r) => ({}));
    }
    add_plugin(t, n) {
      if (n !== void 0)
        try {
          const r = uze(n);
          this.plugins.setState((o) => ({ ...o, [t]: r }));
        } catch (r) {
          r instanceof Error ? this.context.rf.logger.error(`Error loading plugin ${t}`, r) : this.context.rf.logger.error(
            `Error loading plugin ${t}`,
            new Error(String(r))
          ), this.stateManager.toaster?.error({
            title: "Error",
            description: `Error loading plugin ${t}: ${r instanceof Error ? r.message : String(r)}`,
            duration: 5e3
          });
        }
    }
    update_render_options(t) {
      UH(this.render_options, t);
    }
    async add_packed_plugin(t, n) {
      if (n.js)
        for (const r of n.js) {
          const o = document.createElement("script");
          o.text = atob(r), document.body.appendChild(o);
        }
      if (n.css)
        for (const r of n.css) {
          const o = document.createElement("style");
          o.innerHTML = atob(r), document.head.appendChild(o);
        }
      if (n.module !== void 0) {
        const r = atob(n.module);
        try {
          const i = await new Function(
            "React",
            "FuncNodesReactFlow",
            `
          return (async () => {
            ${r}
            return FuncNodesPlugin;
          })();
        `
          )(sc, qG);
          this.add_plugin(t, i);
        } catch (o) {
          o instanceof Error ? this.context.rf.logger.error(`Error building plugin ${t}`, o) : this.context.rf.logger.error(
            `Error building plugin ${t}`,
            new Error(String(o))
          ), this.stateManager.toaster?.error({
            title: "Error",
            description: `Error building plugin ${t}: ${o}`,
            duration: 5e3
          });
        }
      }
    }
  }
  class dze extends Yf {
    constructor(t) {
      super(t), this.on_rf_node_change = (n) => {
        const r = this.useReactFlowStore.getState();
        for (const o of n)
          switch (o.type) {
            case "position":
              if (o.position) {
                const i = r.getNode(o.id);
                if (i === void 0)
                  continue;
                i.type === "group" ? this.nodespaceManager.change_group_position(o) : this.nodespaceManager.change_fn_node_position(o), i.data.groupID && this.nodespaceManager.auto_resize_group(i.data.groupID);
              }
              break;
            case "dimensions":
              if (o.dimensions) {
                const i = r.getNode(o.id);
                if (i === void 0)
                  continue;
                i.type === "group" ? this.nodespaceManager.change_group_dimensions(o) : this.nodespaceManager.change_fn_node_dimensions(o), i.data.groupID && this.nodespaceManager.auto_resize_group(
                  i.data.groupID
                );
              }
              break;
          }
      }, this.on_rf_edge_change = (n) => {
      }, this.on_connect = (n) => {
        n.source === null || n.target === null || n.sourceHandle === null || n.targetHandle === null || !this.workerManager.worker || this.workerManager.worker.api.edge.add_edge({
          src_nid: n.source,
          src_ioid: n.sourceHandle,
          trg_nid: n.target,
          trg_ioid: n.targetHandle,
          replace: !0
        });
      }, this.useReactFlowStore = e$e({
        on_node_change: this.on_rf_node_change.bind(this),
        on_edge_change: this.on_rf_edge_change.bind(this),
        on_connect: this.on_connect.bind(this)
      });
    }
  }
  let pze = class {
    constructor(t) {
      this.reactflowRef = null, this.dev_settings = {
        debug: Ch()
      }, this.options = t, this.logger = t.logger ?? new ak("fn", Ch() ? V4 : H4);
      const n = { rf: this };
      this._nodespaceManager = new oze(n), this._libManager = new aze(n), this._workerManager = new sze(n), this._stateManager = new lze(n), this._pluginManager = new fze(n), this._reactFlowManager = new dze(n);
    }
    // #region handlers
    getNodespaceManager() {
      return this._nodespaceManager;
    }
    getLibManager() {
      return this._libManager;
    }
    getWorkerManager() {
      return this._workerManager;
    }
    getStateManager() {
      return this._stateManager;
    }
    getPluginManager() {
      return this._pluginManager;
    }
    getReactFlowManager() {
      return this._reactFlowManager;
    }
    // #endregion handlers
    // #region nodespace manager
    get nodespace() {
      return this._nodespaceManager.nodespace;
    }
    get on_node_action() {
      return this._nodespaceManager.on_node_action.bind(this._nodespaceManager);
    }
    get on_edge_action() {
      return this._nodespaceManager.on_edge_action.bind(this._nodespaceManager);
    }
    get on_group_action() {
      return this._nodespaceManager.on_group_action.bind(this._nodespaceManager);
    }
    get clear_all() {
      return this._nodespaceManager.clear_all.bind(this._nodespaceManager);
    }
    get center_node() {
      return this._nodespaceManager.center_node.bind(this._nodespaceManager);
    }
    get center_all() {
      return this._nodespaceManager.center_all.bind(this._nodespaceManager);
    }
    // #endregion nodespace manager
    // #region lib manager
    get lib() {
      return this._libManager.lib;
    }
    // #endregion lib manager
    // #region worker manager
    get set_worker() {
      return this._workerManager.set_worker.bind(this._workerManager);
    }
    get workermanager() {
      return this._workerManager.workermanager;
    }
    set workermanager(t) {
      this._workerManager.workermanager = t;
    }
    get worker() {
      return this._workerManager.worker;
    }
    get workers() {
      return this._workerManager.workers;
    }
    get workerstate() {
      return this._workerManager.workerstate;
    }
    get _unsubscribeFromWorker() {
      return this._workerManager._unsubscribeFromWorker?.bind(
        this._workerManager
      );
    }
    // #endregion worker manager
    // #region statemanager
    get set_progress() {
      return this._stateManager.set_progress.bind(this._stateManager);
    }
    get auto_progress() {
      return this._stateManager.auto_progress.bind(this._stateManager);
    }
    get progress_state() {
      return this._stateManager.progress_state;
    }
    get local_settings() {
      return this._stateManager.local_settings;
    }
    get local_state() {
      return this._stateManager.local_state;
    }
    update_view_settings(t) {
      this._stateManager.update_view_settings(t);
    }
    // #endregion statemanager
    // #region plugis
    get plugins() {
      return this._pluginManager.plugins.bind(this._pluginManager);
    }
    get add_plugin() {
      return this._pluginManager.add_plugin.bind(this._pluginManager);
    }
    get add_packed_plugin() {
      return this._pluginManager.add_packed_plugin.bind(this._pluginManager);
    }
    get render_options() {
      return this._pluginManager.render_options.bind(this._pluginManager);
    }
    get update_render_options() {
      return this._pluginManager.update_render_options.bind(this._pluginManager);
    }
    // #endregion plugis
    // #region reactflow
    get useReactFlowStore() {
      return this._reactFlowManager.useReactFlowStore.bind(
        this._reactFlowManager
      );
    }
    get rf_instance() {
      return this._reactFlowManager.rf_instance;
    }
    set rf_instance(t) {
      this._reactFlowManager.rf_instance = t;
    }
    // #endregion reactflow
  };
  const hze = Z0(
    Mde,
    (e) => (e.id = vT(), e)
  ), mze = (e) => {
    if (!e.useWorkerManager && e.worker === void 0)
      throw new Error(
        "If you don't use a worker manager, you must provide a default worker."
      );
    if (e.useWorkerManager && e.workermanager_url === void 0)
      throw new Error(
        "Error: If you use a worker manager, you must provide a worker managerurl."
      );
  }, ok = {};
  window.fnrf_zst === void 0 && (window.fnrf_zst = ok);
  const Iq = (e) => {
    const [t, n] = T.useState(void 0), [r, o] = T.useState(
      void 0
    ), [i, a] = T.useState(!1);
    if (T.useEffect(() => {
      const s = hze(e);
      s.logger = s.logger || new ak("FuncNodes", s.debug ? "debug" : "info"), s.logger.debug("Initializing FuncNodes with props:", s), n(s), a(!1);
    }, [e]), T.useEffect(() => {
      if (!t) return;
      t.logger?.debug("Initializing/Getting Zustand store");
      const s = ok[t.id];
      if (s === void 0) {
        const c = new pze(t);
        ok[t.id] = c, o(c);
      } else
        o(s), s.options.debug = t.debug;
    }, [t?.id, t?.debug]), T.useEffect(() => {
      if (!(!t || !r) && !(t.useWorkerManager || // a) a worker manager is used
      !t.worker_url && !t.worker))
        if (t.logger?.debug("Worker effect running"), !t.worker && t.worker_url) {
          t.logger?.debug("Creating WebSocket worker");
          const s = new F9({
            url: t.worker_url,
            uuid: t.id,
            on_sync_complete: t.on_sync_complete
          });
          return s.set_zustand(r), n(
            (c) => c && { ...c, worker: s, useWorkerManager: !1 }
          ), () => {
            t.logger?.debug("Disconnecting worker"), s.disconnect(), n((c) => c && { ...c, worker: void 0 });
          };
        } else {
          t.worker?.set_zustand(r);
          return;
        }
    }, [
      t?.worker_url,
      t?.id,
      t?.useWorkerManager,
      r,
      t?.on_sync_complete
    ]), T.useEffect(() => {
      if (!t?.fnw_url || !t.worker) return;
      t.logger?.debug("Loading fnw_url data");
      let s = !1;
      const c = t.worker.getSyncManager();
      let u;
      return (async () => {
        try {
          const p = await dK(t.fnw_url);
          if (s) return;
          u = async (m) => {
            s || await m.update_from_export(p);
          }, c.add_after_next_sync(u);
        } catch (p) {
          p instanceof Error ? t.logger?.error("Failed to load fnw_url:", p) : t.logger?.error(
            "Failed to load fnw_url:",
            new Error(String(p))
          );
        }
      })(), () => {
        s = !0, u && c.remove_after_next_sync(u);
      };
    }, [t?.fnw_url, t?.worker]), T.useEffect(() => {
      if (!t || !r || !t.useWorkerManager) return;
      if (!t.workermanager_url)
        throw new Error(
          "Error: If you use a worker manager, you must provide a worker manager url."
        );
      r.logger.info("Worker manager effect running");
      const s = !r.workermanager, c = r.workermanager && r.workermanager.wsuri !== t.workermanager_url;
      if (s || c) {
        r.workermanager && (r.logger.info("Removing existing worker manager"), r.workermanager.remove(), r.workermanager = void 0), r.logger.info("Creating new worker manager");
        const u = new Tde(
          t.workermanager_url,
          r
        );
        return r.workermanager = u, n((d) => d && { ...d, workermanager: u }), () => {
          r.logger.info("Worker manager cleanup running"), r.workermanager === u ? (r.logger.info("Removing worker manager instance"), u.remove(), r.workermanager = void 0) : r.logger.info(
            "Worker manager instance mismatch, skipping cleanup"
          );
        };
      } else {
        r.logger.info(
          "Worker manager already initialized with correct URL"
        );
        return;
      }
    }, [
      t?.useWorkerManager,
      t?.workermanager_url,
      t?.id,
      r
    ]), T.useEffect(() => {
      if (!t || !r || i) return;
      (t.useWorkerManager ? r.workermanager !== void 0 : t.worker !== void 0) && t.on_ready && typeof t.on_ready == "function" && (t.logger?.debug("Firing on_ready callback"), t.on_ready({ fnrf_zst: r }), a(!0));
    }, [
      t,
      r,
      i,
      t?.useWorkerManager,
      r?.workermanager,
      t?.worker
    ]), t === void 0 || r === void 0)
      return /* @__PURE__ */ S.jsx("div", { children: "Loading..." });
    try {
      mze(t);
    } catch (s) {
      return /* @__PURE__ */ S.jsx(pK, { error: s });
    }
    return /* @__PURE__ */ S.jsx("div", { className: "FuncnodesApp", children: /* @__PURE__ */ S.jsx(Zoe, { available_themes: L9, children: /* @__PURE__ */ S.jsx(Tue, { duration: 5e3, children: /* @__PURE__ */ S.jsx(
      nze,
      {
        fnrf_zst: r,
        header: t.header,
        library: t.library,
        flow: t.flow
      }
    ) }) }) });
  }, $q = (e, t) => {
    t === void 0 && (t = {});
    const { element: n, eleid: r } = typeof e == "string" ? {
      element: document.getElementById(e),
      eleid: e
    } : { element: e, eleid: e.id };
    eK.createRoot(n).render(
      /* @__PURE__ */ S.jsx(T.StrictMode, { children: /* @__PURE__ */ S.jsx(Iq, { ...t, id: t.id || r }) })
    );
  };
  window.FuncNodes = $q;
  window.FuncNodes.version = "2.2.1";
  window.FuncNodes.utils = {
    logger: {
      ConsoleLogger: ak,
      DivLogger: oK,
      BaseLogger: ik,
      DEBUG: V4,
      INFO: H4,
      WARN: tK,
      ERROR: nK
    }
  };
});
export default gze();
